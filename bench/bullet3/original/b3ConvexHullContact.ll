target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%class.b3Vector3 = type { %union.anon.1 }
%union.anon.1 = type { [4 x float] }
%struct.b3BvhInfo = type { %class.b3Vector3, %class.b3Vector3, %class.b3Vector3, i32, i32, i32, i32 }
%struct.b3BvhSubtreeInfoData = type { [3 x i16], [3 x i16], i32, i32, [3 x i32] }
%struct.b3QuantizedBvhNodeData = type { [3 x i16], [3 x i16], i32 }
%struct.b3Int4 = type { %union.anon }
%union.anon = type { %struct.anon }
%struct.anon = type { i32, i32, i32, i32 }
%struct.b3RigidBodyData = type { %class.b3Vector3, %class.b3Quaternion, %class.b3Vector3, %class.b3Vector3, i32, float, float, float }
%class.b3Quaternion = type { %class.b3QuadWord }
%class.b3QuadWord = type { %union.anon.3 }
%union.anon.3 = type { [4 x float] }
%struct.b3Collidable = type { %union.anon.5, %union.anon.6, i32, %union.anon.7 }
%union.anon.5 = type { i32 }
%union.anon.6 = type { float }
%union.anon.7 = type { i32 }
%class.b3BvhSubtreeInfo = type { %struct.b3BvhSubtreeInfoData }
%struct.b3QuantizedBvhNode = type { %struct.b3QuantizedBvhNodeData }
%struct.b3Aabb = type { %union.anon.8, %union.anon.9 }
%union.anon.8 = type { [4 x float] }
%union.anon.9 = type { [4 x float] }
%struct.anon.2 = type { float, float, float, float }
%struct.anon.0 = type { [4 x i32] }
%struct.b3ConvexPolyhedronData = type { %class.b3Vector3, %class.b3Vector3, %class.b3Vector3, %class.b3Vector3, float, i32, i32, i32, i32, i32, i32, i32 }
%struct.b3GpuFace = type { %class.b3Vector3, i32, i32, i32, i32 }
%struct.b3GpuChildShape = type { %class.b3Vector3, %class.b3Quaternion, %union.anon.10, %union.anon.11, %union.anon.12, i32 }
%union.anon.10 = type { i32 }
%union.anon.11 = type { float }
%union.anon.12 = type { float }
%class.b3Transform = type { %class.b3Matrix3x3, %class.b3Vector3 }
%class.b3Matrix3x3 = type { [3 x %class.b3Vector3] }
%struct.b3Contact4Data = type { [4 x %class.b3Vector3], %class.b3Vector3, i16, i16, i32, i32, i32, i32, i32, i32, i32 }
%struct.GpuSatCollision = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, %class.b3OpenCLArray, %class.b3OpenCLArray.13, %class.b3OpenCLArray, %class.b3OpenCLArray.15, %class.b3OpenCLArray.13, %class.b3OpenCLArray, %class.b3OpenCLArray.13, %class.b3OpenCLArray.13, %class.b3OpenCLArray.17, %class.b3OpenCLArray, %class.b3OpenCLArray.13, %class.b3OpenCLArray.13 }
%class.b3OpenCLArray.15 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%class.b3OpenCLArray.17 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%class.b3OpenCLArray = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%class.b3OpenCLArray.13 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%class.b3AlignedObjectArray = type <{ %class.b3AlignedAllocator, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator = type { i8 }
%class.b3AlignedObjectArray.19 = type <{ %class.b3AlignedAllocator.20, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.20 = type { i8 }
%class.b3AlignedObjectArray.23 = type <{ %class.b3AlignedAllocator.24, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.24 = type { i8 }
%class.b3ProfileZone = type { i8 }
%struct.b3Contact4 = type { %struct.b3Contact4Data }
%struct.anon.4 = type { float, float, float, float }
%class.b3AlignedObjectArray.27 = type <{ %class.b3AlignedAllocator.28, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.28 = type { i8 }
%class.b3AlignedObjectArray.31 = type <{ %class.b3AlignedAllocator.32, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.32 = type { i8 }
%class.b3AlignedObjectArray.35 = type <{ %class.b3AlignedAllocator.36, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.36 = type { i8 }
%class.b3AlignedObjectArray.39 = type <{ %class.b3AlignedAllocator.40, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.40 = type { i8 }
%class.b3AlignedObjectArray.51 = type <{ %class.b3AlignedAllocator.52, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.52 = type { i8 }
%struct.b3Int2 = type { %union.anon.55 }
%union.anon.55 = type { %struct.anon.56 }
%struct.anon.56 = type { i32, i32 }
%class.b3AlignedObjectArray.43 = type <{ %class.b3AlignedAllocator.44, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.44 = type { i8 }
%class.b3AlignedObjectArray.47 = type <{ %class.b3AlignedAllocator.48, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.48 = type { i8 }
%class.b3AlignedObjectArray.58 = type <{ %class.b3AlignedAllocator.59, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.59 = type { i8 }
%struct.anon.57 = type { [2 x i32] }
%class.b3AlignedObjectArray.62 = type <{ %class.b3AlignedAllocator.63, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.63 = type { i8 }
%class.b3AlignedObjectArray.66 = type <{ %class.b3AlignedAllocator.67, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.67 = type { i8 }
%struct.b3BufferInfoCL = type <{ ptr, i8, [7 x i8] }>
%class.b3LauncherCL = type { ptr, ptr, ptr, i32, [4 x i8], %class.b3AlignedObjectArray.82, i32, i8, ptr, %class.b3AlignedObjectArray.86 }
%class.b3AlignedObjectArray.82 = type <{ %class.b3AlignedAllocator.83, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.83 = type { i8 }
%class.b3AlignedObjectArray.86 = type <{ %class.b3AlignedAllocator.87, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.87 = type { i8 }
%class.b3AlignedObjectArray.92 = type <{ %class.b3AlignedAllocator.93, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.93 = type { i8 }
%class.b3OpenCLArray.70 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%class.b3OpenCLArray.72 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%class.b3OpenCLArray.74 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%class.b3OpenCLArray.76 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%class.b3OpenCLArray.78 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%class.b3OpenCLArray.80 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%struct.b3KernelArgData = type { i32, i32, i32, i32, %union.anon.104 }
%union.anon.104 = type { ptr, [8 x i8] }
%class.b3OpenCLArray.90 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%struct._b3MprSimplex_t = type { [4 x %struct._b3MprSupport_t], i32, [12 x i8] }
%struct._b3MprSupport_t = type { %class.b3Vector3, %class.b3Vector3, %class.b3Vector3 }
%class.b3OpenCLArray.96 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%class.b3OpenCLArray.98 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%class.b3OpenCLArray.100 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%class.b3OpenCLArray.102 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>

$_Z19b3QuantizeWithClampPtRK9b3Vector3iS2_S2_S2_ = comdat any

$_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_ = comdat any

$_Z8b3IsLeafPK22b3QuantizedBvhNodeData = comdat any

$_Z18b3GetTriangleIndexPK22b3QuantizedBvhNodeData = comdat any

$_Z11b3AtomicAddPVii = comdat any

$_Z10b3MakeInt4iiii = comdat any

$_Z16b3GetEscapeIndexPK22b3QuantizedBvhNodeData = comdat any

$_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3 = comdat any

$_Z5b3DotRK9b3Vector3S1_ = comdat any

$_ZN9b3Vector3mLERKf = comdat any

$_Z13b3TestSepAxisPK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_PS2_PS3_S9_Pf = comdat any

$_ZngRK9b3Vector3 = comdat any

$_Z13b3MakeVector3fff = comdat any

$_Z7b3CrossRK9b3Vector3S1_ = comdat any

$_Z14b3IsAlmostZeroRK9b3Vector3 = comdat any

$_Z12b3NormalizedRK9b3Vector3 = comdat any

$_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_ = comdat any

$_Z13b3MakeVector3ffff = comdat any

$_ZN9b3Vector3pLERKS_ = comdat any

$_Z11b3MinFloat4RK9b3Vector3S1_ = comdat any

$_Z11b3MaxFloat4RK9b3Vector3S1_ = comdat any

$_ZmiRK9b3Vector3S1_ = comdat any

$_ZmlRK9b3Vector3RKf = comdat any

$_Z16b3TransformPointRK9b3Vector3S1_RK12b3Quaternion = comdat any

$_Z9b3QuatMulRK12b3QuaternionS1_ = comdat any

$_Z19b3FindClippingFacesRK9b3Vector3PK22b3ConvexPolyhedronDataS4_S1_RK12b3QuaternionS1_S7_PS_S8_S8_iffPS0_PK9b3GpuFacePKiS9_SC_SE_P6b3Int4i = comdat any

$_Z7b3Lerp3RK9b3Vector3S1_f = comdat any

$_ZN9b3Vector3dVERKf = comdat any

$_ZN13b3OpenCLArrayI9b3Vector3EC2EP11_cl_contextP17_cl_command_queuemb = comdat any

$_ZN13b3OpenCLArrayIiEC2EP11_cl_contextP17_cl_command_queuemb = comdat any

$_ZN13b3OpenCLArrayIfEC2EP11_cl_contextP17_cl_command_queuemb = comdat any

$_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairEC2EP11_cl_contextP17_cl_command_queuemb = comdat any

$_ZN13b3OpenCLArrayIiE9push_backERKib = comdat any

$_ZN13b3OpenCLUtils26compileCLProgramFromStringEP11_cl_contextP13_cl_device_idPKcPiS5_S5_b = comdat any

$_ZN13b3OpenCLUtils25compileCLKernelFromStringEP11_cl_contextP13_cl_device_idPKcS5_PiP11_cl_programS5_ = comdat any

$_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb = comdat any

$_ZN13b3OpenCLArrayI9b3Vector3E19copyFromHostPointerEPKS0_mmb = comdat any

$_ZN13b3OpenCLArrayIiED2Ev = comdat any

$_ZN13b3OpenCLArrayI9b3Vector3ED2Ev = comdat any

$_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairED2Ev = comdat any

$_ZN13b3OpenCLArrayIfED2Ev = comdat any

$__clang_call_terminate = comdat any

$_ZN9b3Vector3cvPfEv = comdat any

$_ZNK9b3Vector3cvPKfEv = comdat any

$_ZmlRKfRK9b3Vector3 = comdat any

$_ZN11b3TransformC2Ev = comdat any

$_ZN11b3Transform11setIdentityEv = comdat any

$_ZN11b3Transform9setOriginERK9b3Vector3 = comdat any

$_ZN11b3Transform11setRotationERK12b3Quaternion = comdat any

$_ZNK11b3TransformclERK9b3Vector3 = comdat any

$_ZNK9b3Vector35crossERKS_ = comdat any

$_ZN9b3Vector39normalizeEv = comdat any

$_ZNK20b3AlignedObjectArrayI9b3Vector3EixEi = comdat any

$_Z12IsAlmostZeroRK9b3Vector3 = comdat any

$_Z7projectRK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionS4_RK20b3AlignedObjectArrayIS2_ERfSC_ = comdat any

$_Z5lerp3RK9b3Vector3S1_f = comdat any

$_ZNK20b3AlignedObjectArrayI9b3GpuFaceEixEi = comdat any

$_ZNK20b3AlignedObjectArrayIiEixEi = comdat any

$_ZNK20b3AlignedObjectArrayI12b3CollidableEixEi = comdat any

$_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEixEi = comdat any

$_ZN12b3QuaternionC2ERKfS1_S1_S1_ = comdat any

$_ZNK11b3Transform11getRotationEv = comdat any

$_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE2atEi = comdat any

$_ZN11b3Transform9getOriginEv = comdat any

$_ZN13b3ProfileZoneC2EPKc = comdat any

$_ZN20b3AlignedObjectArrayI10b3Contact4E6expandERKS0_ = comdat any

$_ZN20b3AlignedObjectArrayI10b3Contact4E2atEi = comdat any

$_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataE2atEi = comdat any

$_ZN13b3ProfileZoneD2Ev = comdat any

$_ZNK11b3Transform7inverseEv = comdat any

$_ZNK11b3TransformmlERKS_ = comdat any

$_ZN11b3TransformaSERKS_ = comdat any

$_ZmlRK11b3Matrix3x3RK9b3Vector3 = comdat any

$_ZN11b3Transform8getBasisEv = comdat any

$_ZNK9b3Vector33dotERKS_ = comdat any

$_ZNK11b3TransformmlERK9b3Vector3 = comdat any

$_ZN10b3Contact416setFrictionCoeffEf = comdat any

$_ZN10b3Contact420setRestituitionCoeffEf = comdat any

$_ZN20b3AlignedObjectArrayI9b3BvhInfoEixEi = comdat any

$_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoEixEi = comdat any

$_Z12MyUnQuantizePKtRK9b3Vector3S3_ = comdat any

$_Z16b3TransformAabb2RK9b3Vector3S1_fS1_RK12b3QuaternionPS_S5_ = comdat any

$_Z21b3TestAabbAgainstAabbRK9b3Vector3S1_S1_S1_ = comdat any

$_ZN20b3AlignedObjectArrayI6b3Int2EC2Ev = comdat any

$_ZN20b3AlignedObjectArrayI6b3Int2E6resizeEiRKS0_ = comdat any

$_ZN20b3AlignedObjectArrayI6b3Int2EixEi = comdat any

$_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeEixEi = comdat any

$_ZNK18b3QuantizedBvhNode10isLeafNodeEv = comdat any

$_ZNK18b3QuantizedBvhNode14getEscapeIndexEv = comdat any

$_Z10b3MakeInt2ii = comdat any

$_ZNK18b3QuantizedBvhNode16getTriangleIndexEv = comdat any

$_Z5b3MaxIiERKT_S2_S2_ = comdat any

$_ZN20b3AlignedObjectArrayI6b3Int2ED2Ev = comdat any

$_ZplRK9b3Vector3S1_ = comdat any

$_ZNK20b3AlignedObjectArrayI6b3AabbEixEi = comdat any

$_ZN20b3AlignedObjectArrayIiEixEi = comdat any

$_ZN20b3AlignedObjectArrayI9b3Vector3EixEi = comdat any

$_Z27b3Contact4Data_setNumPointsP14b3Contact4Datai = comdat any

$_ZN20b3AlignedObjectArrayI6b3Int4EC2Ev = comdat any

$_ZN20b3AlignedObjectArrayI6b3Int4E6resizeEiRKS0_ = comdat any

$_ZN20b3AlignedObjectArrayI6b3Int4EixEi = comdat any

$_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev = comdat any

$_ZN20b3AlignedObjectArrayIiEC2Ev = comdat any

$_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_ = comdat any

$_ZN20b3AlignedObjectArrayIiE6resizeEiRKi = comdat any

$_ZN20b3AlignedObjectArrayIiED2Ev = comdat any

$_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev = comdat any

$_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev = comdat any

$_ZmlRK12b3QuaternionS1_ = comdat any

$_Z16IsPointInPolygonRK9b3Vector3PK9b3GpuFacePS0_PKiPS_ = comdat any

$_ZNK9b3Vector37length2Ev = comdat any

$_Z6b3Sqrtf = comdat any

$_ZdvRK9b3Vector3RKf = comdat any

$_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataEixEi = comdat any

$_ZN13b3OpenCLArrayIiE19copyFromHostPointerEPKimmb = comdat any

$_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv = comdat any

$_ZN14b3BufferInfoCLC2EP7_cl_memb = comdat any

$_ZNK13b3OpenCLArrayI15b3RigidBodyDataE11getBufferCLEv = comdat any

$_ZNK13b3OpenCLArrayI12b3CollidableE11getBufferCLEv = comdat any

$_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE11getBufferCLEv = comdat any

$_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv = comdat any

$_ZNK13b3OpenCLArrayI9b3GpuFaceE11getBufferCLEv = comdat any

$_ZNK13b3OpenCLArrayIiE11getBufferCLEv = comdat any

$_ZNK13b3OpenCLArrayI10b3Contact4E11getBufferCLEv = comdat any

$_ZN12b3LauncherCL8setConstIiEEvRKT_ = comdat any

$_ZN12b3LauncherCL8launch1DEii = comdat any

$_ZNK13b3OpenCLArrayIiE2atEm = comdat any

$_ZN13b3OpenCLArrayI10b3Contact4E6resizeEmb = comdat any

$_ZN13b3OpenCLArrayIiE6resizeEmb = comdat any

$_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE6resizeEmb = comdat any

$_ZN13b3OpenCLArrayIfE6resizeEmb = comdat any

$_ZNK13b3OpenCLArrayI6b3AabbE11getBufferCLEv = comdat any

$_ZNK13b3OpenCLArrayIfE11getBufferCLEv = comdat any

$_ZNK13b3OpenCLArrayI6b3Int4E10copyToHostER20b3AlignedObjectArrayIS0_Eb = comdat any

$_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEC2Ev = comdat any

$_ZNK13b3OpenCLArrayI15b3RigidBodyDataE10copyToHostER20b3AlignedObjectArrayIS0_Eb = comdat any

$_ZN20b3AlignedObjectArrayI12b3CollidableEC2Ev = comdat any

$_ZNK13b3OpenCLArrayI12b3CollidableE10copyToHostER20b3AlignedObjectArrayIS0_Eb = comdat any

$_ZN20b3AlignedObjectArrayI15b3GpuChildShapeEC2Ev = comdat any

$_ZNK13b3OpenCLArrayI15b3GpuChildShapeE10copyToHostER20b3AlignedObjectArrayIS0_Eb = comdat any

$_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEC2Ev = comdat any

$_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE10copyToHostER20b3AlignedObjectArrayIS0_Eb = comdat any

$_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb = comdat any

$_ZN20b3AlignedObjectArrayI9b3GpuFaceEC2Ev = comdat any

$_ZNK13b3OpenCLArrayI9b3GpuFaceE10copyToHostER20b3AlignedObjectArrayIS0_Eb = comdat any

$_ZNK13b3OpenCLArrayIiE10copyToHostER20b3AlignedObjectArrayIiEb = comdat any

$_ZN20b3AlignedObjectArrayI10b3Contact4EC2Ev = comdat any

$_ZNK13b3OpenCLArrayI10b3Contact4E10copyToHostER20b3AlignedObjectArrayIS0_Eb = comdat any

$_ZN20b3AlignedObjectArrayI10b3Contact4E6resizeEiRKS0_ = comdat any

$_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEixEi = comdat any

$_ZN20b3AlignedObjectArrayI12b3CollidableEixEi = comdat any

$_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEixEi = comdat any

$_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi = comdat any

$_ZN20b3AlignedObjectArrayI9b3GpuFaceE2atEi = comdat any

$_ZN20b3AlignedObjectArrayIiE2atEi = comdat any

$_Z16b3MprPenetrationiiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_PiPfSB_SB_ = comdat any

$_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE2atEi = comdat any

$_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev = comdat any

$_ZN13b3OpenCLArrayI10b3Contact4E12copyFromHostERK20b3AlignedObjectArrayIS0_Eb = comdat any

$_ZN13b3OpenCLArrayIiE12copyFromHostERK20b3AlignedObjectArrayIiEb = comdat any

$_ZN13b3OpenCLArrayI9b3Vector3E12copyFromHostERK20b3AlignedObjectArrayIS0_Eb = comdat any

$_ZN20b3AlignedObjectArrayI9b3GpuFaceED2Ev = comdat any

$_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataED2Ev = comdat any

$_ZN20b3AlignedObjectArrayI15b3GpuChildShapeED2Ev = comdat any

$_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev = comdat any

$_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev = comdat any

$_ZNK13b3OpenCLArrayI15b3GpuChildShapeE11getBufferCLEv = comdat any

$_ZNK13b3OpenCLArrayI25b3CompoundOverlappingPairE11getBufferCLEv = comdat any

$_ZNK13b3OpenCLArrayI16b3BvhSubtreeInfoE11getBufferCLEv = comdat any

$_ZNK13b3OpenCLArrayI18b3QuantizedBvhNodeE11getBufferCLEv = comdat any

$_ZNK13b3OpenCLArrayI9b3BvhInfoE11getBufferCLEv = comdat any

$_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeEC2Ev = comdat any

$_ZNK13b3OpenCLArrayI18b3QuantizedBvhNodeE10copyToHostER20b3AlignedObjectArrayIS0_Eb = comdat any

$_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoEC2Ev = comdat any

$_ZNK13b3OpenCLArrayI16b3BvhSubtreeInfoE10copyToHostER20b3AlignedObjectArrayIS0_Eb = comdat any

$_ZN20b3AlignedObjectArrayI9b3BvhInfoEC2Ev = comdat any

$_ZNK13b3OpenCLArrayI9b3BvhInfoE10copyToHostER20b3AlignedObjectArrayIS0_Eb = comdat any

$_ZN20b3AlignedObjectArrayI6b3AabbEC2Ev = comdat any

$_ZNK13b3OpenCLArrayI6b3AabbE10copyToHostER20b3AlignedObjectArrayIS0_Eb = comdat any

$_ZNK20b3AlignedObjectArrayI15b3GpuChildShapeE4sizeEv = comdat any

$_ZN20b3AlignedObjectArrayI15b3GpuChildShapeEixEi = comdat any

$_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE19copyFromHostPointerEPKS0_mmb = comdat any

$_ZN20b3AlignedObjectArrayI6b3AabbED2Ev = comdat any

$_ZN20b3AlignedObjectArrayI9b3BvhInfoED2Ev = comdat any

$_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoED2Ev = comdat any

$_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeED2Ev = comdat any

$_ZNK13b3OpenCLArrayI18b3QuantizedBvhNodeE4sizeEv = comdat any

$_ZN20b3AlignedObjectArrayI6b3Int4E2atEi = comdat any

$_ZN20b3AlignedObjectArrayI12b3CollidableE2atEi = comdat any

$_ZN20b3AlignedObjectArrayI6b3AabbE2atEi = comdat any

$_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE2atEi = comdat any

$_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE2atEi = comdat any

$_ZN20b3AlignedObjectArrayI9b3BvhInfoE2atEi = comdat any

$_ZN13b3OpenCLArrayI6b3Int4E12copyFromHostERK20b3AlignedObjectArrayIS0_Eb = comdat any

$_ZN13b3OpenCLArrayI6b3Int4E6resizeEmb = comdat any

$_ZNK20b3AlignedObjectArrayI9b3Vector3E4sizeEv = comdat any

$_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE2atEi = comdat any

$_ZNK13b3OpenCLArrayI6b3Int4E4sizeEv = comdat any

$_ZNK13b3OpenCLArrayI9b3Vector3E4sizeEv = comdat any

$_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE2atEi = comdat any

$_ZN13b3OpenCLArrayI10b3Contact4E7reserveEmb = comdat any

$_ZNK13b3OpenCLArrayI10b3Contact4E8capacityEv = comdat any

$_ZNK13b3OpenCLArrayI25b3CompoundOverlappingPairE4sizeEv = comdat any

$_ZmlRK9b3Vector3S1_ = comdat any

$_ZmlRK12b3QuaternionRK9b3Vector3 = comdat any

$_ZNK12b3Quaternion7inverseEv = comdat any

$_ZN12b3QuaternionmLERKS_ = comdat any

$_ZNK10b3QuadWord4getXEv = comdat any

$_ZNK10b3QuadWord4getYEv = comdat any

$_ZNK10b3QuadWord4getZEv = comdat any

$_ZNK12b3Quaternion4getWEv = comdat any

$_ZNK9b3Vector34getXEv = comdat any

$_ZNK9b3Vector34getZEv = comdat any

$_ZNK9b3Vector34getYEv = comdat any

$_ZN10b3QuadWord8setValueERKfS1_S1_S1_ = comdat any

$_ZN9b3Vector38setValueERKfS1_S1_ = comdat any

$_Z6b3Fabsf = comdat any

$_ZNK9b3Vector310normalizedEv = comdat any

$_ZNK9b3Vector36lengthEv = comdat any

$_Z13b3QuatInverseRK12b3Quaternion = comdat any

$_ZN9b3Vector36setMinERKS_ = comdat any

$_Z8b3SetMinIfEvRT_RKS0_ = comdat any

$_ZN9b3Vector36setMaxERKS_ = comdat any

$_Z8b3SetMaxIfEvRT_RKS0_ = comdat any

$_ZN11b3Matrix3x3C2Ev = comdat any

$_ZN11b3Matrix3x311setIdentityEv = comdat any

$_ZN11b3Matrix3x38setValueERKfS1_S1_S1_S1_S1_S1_S1_S1_ = comdat any

$_ZN11b3Matrix3x311setRotationERK12b3Quaternion = comdat any

$_ZNK12b3Quaternion7length2Ev = comdat any

$_ZNK12b3Quaternion3dotERKS_ = comdat any

$_ZNK9b3Vector34dot3ERKS_S1_S1_ = comdat any

$_ZNK11b3Matrix3x3ixEi = comdat any

$_ZN10b3QuadWordC2ERKfS1_S1_S1_ = comdat any

$_ZN12b3QuaternionC2Ev = comdat any

$_ZNK11b3Matrix3x311getRotationER12b3Quaternion = comdat any

$_ZN10b3QuadWordC2Ev = comdat any

$_ZNK11b3Matrix3x39transposeEv = comdat any

$_ZN11b3TransformC2ERK11b3Matrix3x3RK9b3Vector3 = comdat any

$_ZN11b3Matrix3x3C2ERKfS1_S1_S1_S1_S1_S1_S1_S1_ = comdat any

$_ZN11b3Matrix3x3C2ERKS_ = comdat any

$_ZmlRK11b3Matrix3x3S1_ = comdat any

$_ZNK11b3Matrix3x35tdotxERK9b3Vector3 = comdat any

$_ZNK11b3Matrix3x35tdotyERK9b3Vector3 = comdat any

$_ZNK11b3Matrix3x35tdotzERK9b3Vector3 = comdat any

$_ZN11b3Matrix3x3aSERKS_ = comdat any

$_Z23b3QuatGetRotationMatrixRK12b3Quaternion = comdat any

$_Z16b3AbsoluteMat3x3RK11b3Matrix3x3 = comdat any

$_ZNK11b3Matrix3x36getRowEi = comdat any

$_ZN11b3Matrix3x3C2ERK12b3Quaternion = comdat any

$_ZNK11b3Matrix3x38absoluteEv = comdat any

$_ZN12b3LauncherCL8launch2DEiiii = comdat any

$_Z5b3MaxImERKT_S2_S2_ = comdat any

$_Z12b3FindOriginiiPK15b3RigidBodyDataP15_b3MprSupport_t = comdat any

$_Z18b3MprSimplexPointWP15_b3MprSimplex_ti = comdat any

$_Z19b3MprSimplexSetSizeP15_b3MprSimplex_ti = comdat any

$_Z11b3MprVec3EqPK9b3Vector3S1_ = comdat any

$_Z17b3MprSimplexPointPK15_b3MprSimplex_ti = comdat any

$_Z12b3MprVec3SetP9b3Vector3fff = comdat any

$_Z12b3MprVec3AddP9b3Vector3PKS_ = comdat any

$_Z13b3MprVec3CopyP9b3Vector3PKS_ = comdat any

$_Z14b3MprVec3ScaleP9b3Vector3f = comdat any

$_Z18b3MprVec3NormalizeP9b3Vector3 = comdat any

$_Z12b3MprSupportiiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_SA_P15_b3MprSupport_t = comdat any

$_Z12b3MprVec3DotPK9b3Vector3S1_ = comdat any

$_Z11b3MprIsZerof = comdat any

$_Z14b3MprVec3CrossP9b3Vector3PKS_S2_ = comdat any

$_Z13b3MprVec3Len2PK9b3Vector3 = comdat any

$_Z13b3MprVec3Sub2P9b3Vector3PKS_S2_ = comdat any

$_Z16b3MprSimplexSwapP15_b3MprSimplex_tmm = comdat any

$_Z16b3MprSimplexSizePK15_b3MprSimplex_t = comdat any

$_Z15b3MprSimplexSetP15_b3MprSimplex_tmPK15_b3MprSupport_t = comdat any

$_Z7b3MprEqff = comdat any

$_ZSt4fabsf = comdat any

$_Z8b3MaxDotRK9b3Vector3PS0_iPf = comdat any

$_Z23b3LocalGetSupportVertexRK9b3Vector3PK22b3ConvexPolyhedronDataPS0_ = comdat any

$_Z16b3MprSupportCopyP15_b3MprSupport_tPKS_ = comdat any

$_Z11b3PortalDirPK15_b3MprSimplex_tP9b3Vector3 = comdat any

$_Z22portalEncapsulesOriginPK15_b3MprSimplex_tPK9b3Vector3 = comdat any

$_Z24portalCanEncapsuleOriginPK15_b3MprSimplex_tPK15_b3MprSupport_tPK9b3Vector3 = comdat any

$_Z20portalReachTolerancePK15_b3MprSimplex_tPK15_b3MprSupport_tPK9b3Vector3 = comdat any

$_Z14b3ExpandPortalP15_b3MprSimplex_tPK15_b3MprSupport_t = comdat any

$_Z22b3MprVec3PointTriDist2PK9b3Vector3S1_S1_S1_PS_ = comdat any

$_Z14b3MprVec3Dist2PK9b3Vector3S1_ = comdat any

$_Z27_b3MprVec3PointSegmentDist2PK9b3Vector3S1_S1_PS_ = comdat any

$_ZN13b3OpenCLArrayI9b3Vector3E7reserveEmb = comdat any

$_ZN13b3OpenCLArrayI9b3Vector3ED0Ev = comdat any

$_ZNK13b3OpenCLArrayI9b3Vector3E8capacityEv = comdat any

$_ZNK13b3OpenCLArrayI9b3Vector3E8copyToCLEP7_cl_memmmm = comdat any

$_ZN13b3OpenCLArrayI9b3Vector3E10deallocateEv = comdat any

$_ZN13b3OpenCLArrayIiE7reserveEmb = comdat any

$_ZN13b3OpenCLArrayIiED0Ev = comdat any

$_ZNK13b3OpenCLArrayIiE8capacityEv = comdat any

$_ZNK13b3OpenCLArrayIiE8copyToCLEP7_cl_memmmm = comdat any

$_ZNK13b3OpenCLArrayIiE4sizeEv = comdat any

$_ZN13b3OpenCLArrayIiE10deallocateEv = comdat any

$_ZN13b3OpenCLArrayIfE7reserveEmb = comdat any

$_ZN13b3OpenCLArrayIfED0Ev = comdat any

$_ZNK13b3OpenCLArrayIfE8capacityEv = comdat any

$_ZNK13b3OpenCLArrayIfE8copyToCLEP7_cl_memmmm = comdat any

$_ZNK13b3OpenCLArrayIfE4sizeEv = comdat any

$_ZN13b3OpenCLArrayIfE10deallocateEv = comdat any

$_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE7reserveEmb = comdat any

$_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairED0Ev = comdat any

$_ZNK13b3OpenCLArrayI25b3CompoundOverlappingPairE8capacityEv = comdat any

$_ZNK13b3OpenCLArrayI25b3CompoundOverlappingPairE8copyToCLEP7_cl_memmmm = comdat any

$_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE10deallocateEv = comdat any

$_ZN13b3OpenCLArrayIiE9allocSizeEm = comdat any

$_ZNK20b3AlignedObjectArrayI10b3Contact4E4sizeEv = comdat any

$_ZNK20b3AlignedObjectArrayI10b3Contact4E8capacityEv = comdat any

$_ZN20b3AlignedObjectArrayI10b3Contact4E7reserveEi = comdat any

$_ZN20b3AlignedObjectArrayI10b3Contact4E9allocSizeEi = comdat any

$_ZN10b3Contact4nwEmPv = comdat any

$_ZN20b3AlignedObjectArrayI10b3Contact4E8allocateEi = comdat any

$_ZNK20b3AlignedObjectArrayI10b3Contact4E4copyEiiPS0_ = comdat any

$_ZN20b3AlignedObjectArrayI10b3Contact4E7destroyEii = comdat any

$_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv = comdat any

$_ZN18b3AlignedAllocatorI10b3Contact4Lj16EE8allocateEiPPKS0_ = comdat any

$_ZN18b3AlignedAllocatorI10b3Contact4Lj16EE10deallocateEPS0_ = comdat any

$_ZN18b3AlignedAllocatorI6b3Int2Lj16EEC2Ev = comdat any

$_ZN20b3AlignedObjectArrayI6b3Int2E4initEv = comdat any

$_ZN20b3AlignedObjectArrayI6b3Int2E5clearEv = comdat any

$_ZN20b3AlignedObjectArrayI6b3Int2E7destroyEii = comdat any

$_ZNK20b3AlignedObjectArrayI6b3Int2E4sizeEv = comdat any

$_ZN20b3AlignedObjectArrayI6b3Int2E10deallocateEv = comdat any

$_ZN18b3AlignedAllocatorI6b3Int2Lj16EE10deallocateEPS0_ = comdat any

$_ZN20b3AlignedObjectArrayI6b3Int2E7reserveEi = comdat any

$_ZNK20b3AlignedObjectArrayI6b3Int2E8capacityEv = comdat any

$_ZN20b3AlignedObjectArrayI6b3Int2E8allocateEi = comdat any

$_ZNK20b3AlignedObjectArrayI6b3Int2E4copyEiiPS0_ = comdat any

$_ZN18b3AlignedAllocatorI6b3Int2Lj16EE8allocateEiPPKS0_ = comdat any

$_ZN18b3AlignedAllocatorI6b3Int4Lj16EEC2Ev = comdat any

$_ZN20b3AlignedObjectArrayI6b3Int4E4initEv = comdat any

$_ZN20b3AlignedObjectArrayI6b3Int4E5clearEv = comdat any

$_ZN20b3AlignedObjectArrayI6b3Int4E7destroyEii = comdat any

$_ZNK20b3AlignedObjectArrayI6b3Int4E4sizeEv = comdat any

$_ZN20b3AlignedObjectArrayI6b3Int4E10deallocateEv = comdat any

$_ZN18b3AlignedAllocatorI6b3Int4Lj16EE10deallocateEPS0_ = comdat any

$_ZN20b3AlignedObjectArrayI6b3Int4E7reserveEi = comdat any

$_ZN6b3Int4nwEmPv = comdat any

$_ZNK20b3AlignedObjectArrayI6b3Int4E8capacityEv = comdat any

$_ZN20b3AlignedObjectArrayI6b3Int4E8allocateEi = comdat any

$_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_ = comdat any

$_ZN18b3AlignedAllocatorI6b3Int4Lj16EE8allocateEiPPKS0_ = comdat any

$_ZN18b3AlignedAllocatorI9b3Vector3Lj16EEC2Ev = comdat any

$_ZN20b3AlignedObjectArrayI9b3Vector3E4initEv = comdat any

$_ZN20b3AlignedObjectArrayI9b3Vector3E5clearEv = comdat any

$_ZN20b3AlignedObjectArrayI9b3Vector3E7destroyEii = comdat any

$_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv = comdat any

$_ZN18b3AlignedAllocatorI9b3Vector3Lj16EE10deallocateEPS0_ = comdat any

$_ZN18b3AlignedAllocatorIiLj16EEC2Ev = comdat any

$_ZN20b3AlignedObjectArrayIiE4initEv = comdat any

$_ZN20b3AlignedObjectArrayIiE5clearEv = comdat any

$_ZN20b3AlignedObjectArrayIiE7destroyEii = comdat any

$_ZNK20b3AlignedObjectArrayIiE4sizeEv = comdat any

$_ZN20b3AlignedObjectArrayIiE10deallocateEv = comdat any

$_ZN18b3AlignedAllocatorIiLj16EE10deallocateEPi = comdat any

$_ZN20b3AlignedObjectArrayI9b3Vector3E7reserveEi = comdat any

$_ZN9b3Vector3nwEmPv = comdat any

$_ZNK20b3AlignedObjectArrayI9b3Vector3E8capacityEv = comdat any

$_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi = comdat any

$_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_ = comdat any

$_ZN18b3AlignedAllocatorI9b3Vector3Lj16EE8allocateEiPPKS0_ = comdat any

$_ZN20b3AlignedObjectArrayIiE7reserveEi = comdat any

$_ZNK20b3AlignedObjectArrayIiE8capacityEv = comdat any

$_ZN20b3AlignedObjectArrayIiE8allocateEi = comdat any

$_ZNK20b3AlignedObjectArrayIiE4copyEiiPi = comdat any

$_ZN18b3AlignedAllocatorIiLj16EE8allocateEiPPKi = comdat any

$_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_ = comdat any

$_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4sizeEv = comdat any

$_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE8capacityEv = comdat any

$_ZN20b3AlignedObjectArrayI15b3KernelArgDataE7reserveEi = comdat any

$_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9allocSizeEi = comdat any

$_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi = comdat any

$_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_ = comdat any

$_ZN20b3AlignedObjectArrayI15b3KernelArgDataE7destroyEii = comdat any

$_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv = comdat any

$_ZN18b3AlignedAllocatorI15b3KernelArgDataLj16EE8allocateEiPPKS0_ = comdat any

$_ZN18b3AlignedAllocatorI15b3KernelArgDataLj16EE10deallocateEPS0_ = comdat any

$_ZNK13b3OpenCLArrayIiE17copyToHostPointerEPimmb = comdat any

$_ZNK13b3OpenCLArrayI10b3Contact4E4sizeEv = comdat any

$_ZNK13b3OpenCLArrayI6b3Int4E17copyToHostPointerEPS0_mmb = comdat any

$_ZNK13b3OpenCLArrayI6b3Int4E8capacityEv = comdat any

$_ZN18b3AlignedAllocatorI15b3RigidBodyDataLj16EEC2Ev = comdat any

$_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE4initEv = comdat any

$_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE5clearEv = comdat any

$_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE7destroyEii = comdat any

$_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataE4sizeEv = comdat any

$_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE10deallocateEv = comdat any

$_ZN18b3AlignedAllocatorI15b3RigidBodyDataLj16EE10deallocateEPS0_ = comdat any

$_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE6resizeEiRKS0_ = comdat any

$_ZNK13b3OpenCLArrayI15b3RigidBodyDataE4sizeEv = comdat any

$_ZN15b3RigidBodyDataC2Ev = comdat any

$_ZNK13b3OpenCLArrayI15b3RigidBodyDataE17copyToHostPointerEPS0_mmb = comdat any

$_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE7reserveEi = comdat any

$_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataE8capacityEv = comdat any

$_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE8allocateEi = comdat any

$_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataE4copyEiiPS0_ = comdat any

$_ZN18b3AlignedAllocatorI15b3RigidBodyDataLj16EE8allocateEiPPKS0_ = comdat any

$_ZNK13b3OpenCLArrayI15b3RigidBodyDataE8capacityEv = comdat any

$_ZN18b3AlignedAllocatorI12b3CollidableLj16EEC2Ev = comdat any

$_ZN20b3AlignedObjectArrayI12b3CollidableE4initEv = comdat any

$_ZN20b3AlignedObjectArrayI12b3CollidableE5clearEv = comdat any

$_ZN20b3AlignedObjectArrayI12b3CollidableE7destroyEii = comdat any

$_ZNK20b3AlignedObjectArrayI12b3CollidableE4sizeEv = comdat any

$_ZN20b3AlignedObjectArrayI12b3CollidableE10deallocateEv = comdat any

$_ZN18b3AlignedAllocatorI12b3CollidableLj16EE10deallocateEPS0_ = comdat any

$_ZN20b3AlignedObjectArrayI12b3CollidableE6resizeEiRKS0_ = comdat any

$_ZNK13b3OpenCLArrayI12b3CollidableE4sizeEv = comdat any

$_ZNK13b3OpenCLArrayI12b3CollidableE17copyToHostPointerEPS0_mmb = comdat any

$_ZN20b3AlignedObjectArrayI12b3CollidableE7reserveEi = comdat any

$_ZNK20b3AlignedObjectArrayI12b3CollidableE8capacityEv = comdat any

$_ZN20b3AlignedObjectArrayI12b3CollidableE8allocateEi = comdat any

$_ZNK20b3AlignedObjectArrayI12b3CollidableE4copyEiiPS0_ = comdat any

$_ZN18b3AlignedAllocatorI12b3CollidableLj16EE8allocateEiPPKS0_ = comdat any

$_ZNK13b3OpenCLArrayI12b3CollidableE8capacityEv = comdat any

$_ZN18b3AlignedAllocatorI15b3GpuChildShapeLj16EEC2Ev = comdat any

$_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE4initEv = comdat any

$_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE5clearEv = comdat any

$_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE7destroyEii = comdat any

$_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE10deallocateEv = comdat any

$_ZN18b3AlignedAllocatorI15b3GpuChildShapeLj16EE10deallocateEPS0_ = comdat any

$_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE6resizeEiRKS0_ = comdat any

$_ZNK13b3OpenCLArrayI15b3GpuChildShapeE4sizeEv = comdat any

$_ZN15b3GpuChildShapeC2Ev = comdat any

$_ZNK13b3OpenCLArrayI15b3GpuChildShapeE17copyToHostPointerEPS0_mmb = comdat any

$_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE7reserveEi = comdat any

$_ZNK20b3AlignedObjectArrayI15b3GpuChildShapeE8capacityEv = comdat any

$_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE8allocateEi = comdat any

$_ZNK20b3AlignedObjectArrayI15b3GpuChildShapeE4copyEiiPS0_ = comdat any

$_ZN18b3AlignedAllocatorI15b3GpuChildShapeLj16EE8allocateEiPPKS0_ = comdat any

$_ZNK13b3OpenCLArrayI15b3GpuChildShapeE8capacityEv = comdat any

$_ZN18b3AlignedAllocatorI22b3ConvexPolyhedronDataLj16EEC2Ev = comdat any

$_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE4initEv = comdat any

$_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE5clearEv = comdat any

$_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE7destroyEii = comdat any

$_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE4sizeEv = comdat any

$_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE10deallocateEv = comdat any

$_ZN18b3AlignedAllocatorI22b3ConvexPolyhedronDataLj16EE10deallocateEPS0_ = comdat any

$_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE6resizeEiRKS0_ = comdat any

$_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE4sizeEv = comdat any

$_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE17copyToHostPointerEPS0_mmb = comdat any

$_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE7reserveEi = comdat any

$_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE8capacityEv = comdat any

$_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE8allocateEi = comdat any

$_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE4copyEiiPS0_ = comdat any

$_ZN18b3AlignedAllocatorI22b3ConvexPolyhedronDataLj16EE8allocateEiPPKS0_ = comdat any

$_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE8capacityEv = comdat any

$_ZNK13b3OpenCLArrayI9b3Vector3E17copyToHostPointerEPS0_mmb = comdat any

$_ZN18b3AlignedAllocatorI9b3GpuFaceLj16EEC2Ev = comdat any

$_ZN20b3AlignedObjectArrayI9b3GpuFaceE4initEv = comdat any

$_ZN20b3AlignedObjectArrayI9b3GpuFaceE5clearEv = comdat any

$_ZN20b3AlignedObjectArrayI9b3GpuFaceE7destroyEii = comdat any

$_ZNK20b3AlignedObjectArrayI9b3GpuFaceE4sizeEv = comdat any

$_ZN20b3AlignedObjectArrayI9b3GpuFaceE10deallocateEv = comdat any

$_ZN18b3AlignedAllocatorI9b3GpuFaceLj16EE10deallocateEPS0_ = comdat any

$_ZN20b3AlignedObjectArrayI9b3GpuFaceE6resizeEiRKS0_ = comdat any

$_ZNK13b3OpenCLArrayI9b3GpuFaceE4sizeEv = comdat any

$_ZNK13b3OpenCLArrayI9b3GpuFaceE17copyToHostPointerEPS0_mmb = comdat any

$_ZN20b3AlignedObjectArrayI9b3GpuFaceEixEi = comdat any

$_ZN20b3AlignedObjectArrayI9b3GpuFaceE7reserveEi = comdat any

$_ZNK20b3AlignedObjectArrayI9b3GpuFaceE8capacityEv = comdat any

$_ZN20b3AlignedObjectArrayI9b3GpuFaceE8allocateEi = comdat any

$_ZNK20b3AlignedObjectArrayI9b3GpuFaceE4copyEiiPS0_ = comdat any

$_ZN18b3AlignedAllocatorI9b3GpuFaceLj16EE8allocateEiPPKS0_ = comdat any

$_ZNK13b3OpenCLArrayI9b3GpuFaceE8capacityEv = comdat any

$_ZN18b3AlignedAllocatorI10b3Contact4Lj16EEC2Ev = comdat any

$_ZN20b3AlignedObjectArrayI10b3Contact4E4initEv = comdat any

$_ZN20b3AlignedObjectArrayI10b3Contact4E5clearEv = comdat any

$_ZNK13b3OpenCLArrayI10b3Contact4E17copyToHostPointerEPS0_mmb = comdat any

$_ZN20b3AlignedObjectArrayI10b3Contact4EixEi = comdat any

$_ZN13b3OpenCLArrayI10b3Contact4E19copyFromHostPointerEPKS0_mmb = comdat any

$_ZNK20b3AlignedObjectArrayI10b3Contact4EixEi = comdat any

$_ZN18b3AlignedAllocatorI18b3QuantizedBvhNodeLj16EEC2Ev = comdat any

$_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE4initEv = comdat any

$_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE5clearEv = comdat any

$_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE7destroyEii = comdat any

$_ZNK20b3AlignedObjectArrayI18b3QuantizedBvhNodeE4sizeEv = comdat any

$_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE10deallocateEv = comdat any

$_ZN18b3AlignedAllocatorI18b3QuantizedBvhNodeLj16EE10deallocateEPS0_ = comdat any

$_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE6resizeEiRKS0_ = comdat any

$_ZNK13b3OpenCLArrayI18b3QuantizedBvhNodeE17copyToHostPointerEPS0_mmb = comdat any

$_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE7reserveEi = comdat any

$_ZN18b3QuantizedBvhNodenwEmPv = comdat any

$_ZNK20b3AlignedObjectArrayI18b3QuantizedBvhNodeE8capacityEv = comdat any

$_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE8allocateEi = comdat any

$_ZNK20b3AlignedObjectArrayI18b3QuantizedBvhNodeE4copyEiiPS0_ = comdat any

$_ZN18b3AlignedAllocatorI18b3QuantizedBvhNodeLj16EE8allocateEiPPKS0_ = comdat any

$_ZNK13b3OpenCLArrayI18b3QuantizedBvhNodeE8capacityEv = comdat any

$_ZN18b3AlignedAllocatorI16b3BvhSubtreeInfoLj16EEC2Ev = comdat any

$_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE4initEv = comdat any

$_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE5clearEv = comdat any

$_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE7destroyEii = comdat any

$_ZNK20b3AlignedObjectArrayI16b3BvhSubtreeInfoE4sizeEv = comdat any

$_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE10deallocateEv = comdat any

$_ZN18b3AlignedAllocatorI16b3BvhSubtreeInfoLj16EE10deallocateEPS0_ = comdat any

$_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE6resizeEiRKS0_ = comdat any

$_ZNK13b3OpenCLArrayI16b3BvhSubtreeInfoE4sizeEv = comdat any

$_ZN16b3BvhSubtreeInfoC2Ev = comdat any

$_ZNK13b3OpenCLArrayI16b3BvhSubtreeInfoE17copyToHostPointerEPS0_mmb = comdat any

$_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE7reserveEi = comdat any

$_ZN16b3BvhSubtreeInfonwEmPv = comdat any

$_ZNK20b3AlignedObjectArrayI16b3BvhSubtreeInfoE8capacityEv = comdat any

$_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE8allocateEi = comdat any

$_ZNK20b3AlignedObjectArrayI16b3BvhSubtreeInfoE4copyEiiPS0_ = comdat any

$_ZN18b3AlignedAllocatorI16b3BvhSubtreeInfoLj16EE8allocateEiPPKS0_ = comdat any

$_ZNK13b3OpenCLArrayI16b3BvhSubtreeInfoE8capacityEv = comdat any

$_ZN18b3AlignedAllocatorI9b3BvhInfoLj16EEC2Ev = comdat any

$_ZN20b3AlignedObjectArrayI9b3BvhInfoE4initEv = comdat any

$_ZN20b3AlignedObjectArrayI9b3BvhInfoE5clearEv = comdat any

$_ZN20b3AlignedObjectArrayI9b3BvhInfoE7destroyEii = comdat any

$_ZNK20b3AlignedObjectArrayI9b3BvhInfoE4sizeEv = comdat any

$_ZN20b3AlignedObjectArrayI9b3BvhInfoE10deallocateEv = comdat any

$_ZN18b3AlignedAllocatorI9b3BvhInfoLj16EE10deallocateEPS0_ = comdat any

$_ZN20b3AlignedObjectArrayI9b3BvhInfoE6resizeEiRKS0_ = comdat any

$_ZNK13b3OpenCLArrayI9b3BvhInfoE4sizeEv = comdat any

$_ZNK13b3OpenCLArrayI9b3BvhInfoE17copyToHostPointerEPS0_mmb = comdat any

$_ZN20b3AlignedObjectArrayI9b3BvhInfoE7reserveEi = comdat any

$_ZNK20b3AlignedObjectArrayI9b3BvhInfoE8capacityEv = comdat any

$_ZN20b3AlignedObjectArrayI9b3BvhInfoE8allocateEi = comdat any

$_ZNK20b3AlignedObjectArrayI9b3BvhInfoE4copyEiiPS0_ = comdat any

$_ZN18b3AlignedAllocatorI9b3BvhInfoLj16EE8allocateEiPPKS0_ = comdat any

$_ZNK13b3OpenCLArrayI9b3BvhInfoE8capacityEv = comdat any

$_ZN18b3AlignedAllocatorI6b3AabbLj16EEC2Ev = comdat any

$_ZN20b3AlignedObjectArrayI6b3AabbE4initEv = comdat any

$_ZN20b3AlignedObjectArrayI6b3AabbE5clearEv = comdat any

$_ZN20b3AlignedObjectArrayI6b3AabbE7destroyEii = comdat any

$_ZNK20b3AlignedObjectArrayI6b3AabbE4sizeEv = comdat any

$_ZN20b3AlignedObjectArrayI6b3AabbE10deallocateEv = comdat any

$_ZN18b3AlignedAllocatorI6b3AabbLj16EE10deallocateEPS0_ = comdat any

$_ZN20b3AlignedObjectArrayI6b3AabbE6resizeEiRKS0_ = comdat any

$_ZNK13b3OpenCLArrayI6b3AabbE4sizeEv = comdat any

$_ZNK13b3OpenCLArrayI6b3AabbE17copyToHostPointerEPS0_mmb = comdat any

$_ZN20b3AlignedObjectArrayI6b3AabbEixEi = comdat any

$_ZN20b3AlignedObjectArrayI6b3AabbE7reserveEi = comdat any

$_ZNK20b3AlignedObjectArrayI6b3AabbE8capacityEv = comdat any

$_ZN20b3AlignedObjectArrayI6b3AabbE8allocateEi = comdat any

$_ZNK20b3AlignedObjectArrayI6b3AabbE4copyEiiPS0_ = comdat any

$_ZN18b3AlignedAllocatorI6b3AabbLj16EE8allocateEiPPKS0_ = comdat any

$_ZNK13b3OpenCLArrayI6b3AabbE8capacityEv = comdat any

$_ZN13b3OpenCLArrayI6b3Int4E19copyFromHostPointerEPKS0_mmb = comdat any

$_ZNK20b3AlignedObjectArrayI6b3Int4EixEi = comdat any

$_ZN13b3OpenCLArrayI6b3Int4E7reserveEmb = comdat any

$_ZNK13b3OpenCLArrayI6b3Int4E8copyToCLEP7_cl_memmmm = comdat any

$_ZN13b3OpenCLArrayI6b3Int4E10deallocateEv = comdat any

$_ZNK13b3OpenCLArrayI10b3Contact4E8copyToCLEP7_cl_memmmm = comdat any

$_ZN13b3OpenCLArrayI10b3Contact4E10deallocateEv = comdat any

$_ZTV13b3OpenCLArrayI9b3Vector3E = comdat any

$_ZTS13b3OpenCLArrayI9b3Vector3E = comdat any

$_ZTI13b3OpenCLArrayI9b3Vector3E = comdat any

$_ZTV13b3OpenCLArrayIiE = comdat any

$_ZTS13b3OpenCLArrayIiE = comdat any

$_ZTI13b3OpenCLArrayIiE = comdat any

$_ZTV13b3OpenCLArrayIfE = comdat any

$_ZTS13b3OpenCLArrayIfE = comdat any

$_ZTI13b3OpenCLArrayIfE = comdat any

$_ZTV13b3OpenCLArrayI25b3CompoundOverlappingPairE = comdat any

$_ZTS13b3OpenCLArrayI25b3CompoundOverlappingPairE = comdat any

$_ZTI13b3OpenCLArrayI25b3CompoundOverlappingPairE = comdat any

@findSeparatingAxisOnGpu = dso_local global i8 1, align 1
@splitSearchSepAxisConcave = dso_local global i8 0, align 1
@splitSearchSepAxisConvex = dso_local global i8 1, align 1
@useMprGpu = dso_local global i8 1, align 1
@bvhTraversalKernelGPU = dso_local global i8 1, align 1
@findConcaveSeparatingAxisKernelGPU = dso_local global i8 1, align 1
@clipConcaveFacesAndFindContactsCPU = dso_local global i8 0, align 1
@clipConvexFacesAndFindContactsCPU = dso_local global i8 0, align 1
@reduceConcaveContactsOnGPU = dso_local global i8 1, align 1
@reduceConvexContactsOnGPU = dso_local global i8 1, align 1
@findConvexClippingFacesGPU = dso_local global i8 1, align 1
@useGjk = dso_local global i8 0, align 1
@useGjkContacts = dso_local global i8 0, align 1
@b3g_actualSATPairTests = dso_local global i32 0, align 4
@unitSphere162 = dso_local global [162 x %class.b3Vector3] zeroinitializer, align 16
@_ZZ28b3FindSeparatingAxisEdgeEdgePK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_PfbE12maxEdgeTests = internal global i32 0, align 4
@.str = private unnamed_addr constant [19 x i8] c"maxEdgeTests = %d\0A\00", align 1
@.str.1 = private unnamed_addr constant [30 x i8] c"hullA->m_numUniqueEdges = %d\0A\00", align 1
@.str.2 = private unnamed_addr constant [30 x i8] c"hullB->m_numUniqueEdges = %d\0A\00", align 1
@_ZTV15GpuSatCollision = dso_local unnamed_addr constant { [4 x ptr] } { [4 x ptr] [ptr null, ptr @_ZTI15GpuSatCollision, ptr @_ZN15GpuSatCollisionD1Ev, ptr @_ZN15GpuSatCollisionD0Ev] }, align 8
@_ZL12mprKernelsCL = internal global ptr @.str.66, align 8
@_ZL19satConcaveKernelsCL = internal global ptr @.str.67, align 8
@.str.3 = private unnamed_addr constant [54 x i8] c"src/Bullet3OpenCL/NarrowphaseCollision/kernels/mpr.cl\00", align 1
@.str.4 = private unnamed_addr constant [21 x i8] c"mprPenetrationKernel\00", align 1
@.str.5 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.6 = private unnamed_addr constant [35 x i8] c"findSeparatingAxisUnitSphereKernel\00", align 1
@_ZL12satKernelsCL = internal global ptr @.str.68, align 8
@.str.7 = private unnamed_addr constant [54 x i8] c"src/Bullet3OpenCL/NarrowphaseCollision/kernels/sat.cl\00", align 1
@.str.8 = private unnamed_addr constant [61 x i8] c"src/Bullet3OpenCL/NarrowphaseCollision/kernels/satConcave.cl\00", align 1
@.str.9 = private unnamed_addr constant [25 x i8] c"findSeparatingAxisKernel\00", align 1
@.str.10 = private unnamed_addr constant [35 x i8] c"findSeparatingAxisVertexFaceKernel\00", align 1
@.str.11 = private unnamed_addr constant [33 x i8] c"findSeparatingAxisEdgeEdgeKernel\00", align 1
@.str.12 = private unnamed_addr constant [32 x i8] c"findConcaveSeparatingAxisKernel\00", align 1
@.str.13 = private unnamed_addr constant [42 x i8] c"findConcaveSeparatingAxisVertexFaceKernel\00", align 1
@.str.14 = private unnamed_addr constant [40 x i8] c"findConcaveSeparatingAxisEdgeEdgeKernel\00", align 1
@.str.15 = private unnamed_addr constant [24 x i8] c"findCompoundPairsKernel\00", align 1
@.str.16 = private unnamed_addr constant [27 x i8] c"processCompoundPairsKernel\00", align 1
@_ZL16satClipKernelsCL = internal global ptr @.str.69, align 8
@.str.17 = private unnamed_addr constant [70 x i8] c"src/Bullet3OpenCL/NarrowphaseCollision/kernels/satClipHullContacts.cl\00", align 1
@.str.18 = private unnamed_addr constant [19 x i8] c"clipHullHullKernel\00", align 1
@.str.19 = private unnamed_addr constant [28 x i8] c"clipCompoundsHullHullKernel\00", align 1
@.str.20 = private unnamed_addr constant [24 x i8] c"findClippingFacesKernel\00", align 1
@.str.21 = private unnamed_addr constant [31 x i8] c"clipFacesAndFindContactsKernel\00", align 1
@.str.22 = private unnamed_addr constant [32 x i8] c"clipHullHullConcaveConvexKernel\00", align 1
@.str.23 = private unnamed_addr constant [26 x i8] c"newContactReductionKernel\00", align 1
@_ZL20bvhTraversalKernelCL = internal global ptr @.str.70, align 8
@.str.24 = private unnamed_addr constant [63 x i8] c"src/Bullet3OpenCL/NarrowphaseCollision/kernels/bvhTraversal.cl\00", align 1
@.str.25 = private unnamed_addr constant [19 x i8] c"bvhTraversalKernel\00", align 1
@_ZL26primitiveContactsKernelsCL = internal global ptr @.str.71, align 8
@.str.26 = private unnamed_addr constant [68 x i8] c"src/Bullet3OpenCL/NarrowphaseCollision/kernels/primitiveContacts.cl\00", align 1
@.str.27 = private unnamed_addr constant [24 x i8] c"primitiveContactsKernel\00", align 1
@.str.28 = private unnamed_addr constant [32 x i8] c"findConcaveSphereContactsKernel\00", align 1
@.str.29 = private unnamed_addr constant [37 x i8] c"processCompoundPairsPrimitivesKernel\00", align 1
@__clewReleaseKernel = external global ptr, align 8
@.str.30 = private unnamed_addr constant [17 x i8] c"b3Error[%s,%d]:\0A\00", align 1
@.str.31 = private unnamed_addr constant [156 x i8] c"generated/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/bullet3/bullet3/src/Bullet3OpenCL/NarrowphaseCollision/b3ConvexHullContact.cpp\00", align 1
@.str.32 = private unnamed_addr constant [37 x i8] c"exceeding contact capacity (%d,%df)\0A\00", align 1
@.str.33 = private unnamed_addr constant [8 x i8] c"overlap\00", align 1
@.str.34 = private unnamed_addr constant [43 x i8] c"Error: exceeding contact capacity (%d/%d)\0A\00", align 1
@numAabbChecks = dso_local global i32 0, align 4
@maxNumAabbChecks = dso_local global i32 0, align 4
@maxDepth = dso_local global i32 0, align 4
@.str.35 = private unnamed_addr constant [13 x i8] c"maxDepth=%d\0A\00", align 1
@.str.36 = private unnamed_addr constant [41 x i8] c"Error: traversal exceeded maxStackDepth\0A\00", align 1
@.str.37 = private unnamed_addr constant [21 x i8] c"maxNumAabbChecks=%d\0A\00", align 1
@.str.38 = private unnamed_addr constant [63 x i8] c"numCompoundPairsOut exceeded maxNumCompoundPairsCapacity (%d)\0A\00", align 1
@_ZZ26computeContactSphereConvexiiiiiPK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataPK9b3Vector3PKiPK9b3GpuFaceP10b3Contact4RiiE9numChecks = internal global i32 0, align 4
@_ZL12myframecount = internal global i32 0, align 4
@.str.39 = private unnamed_addr constant [26 x i8] c"m_primitiveContactsKernel\00", align 1
@__clewFinish = external global ptr, align 8
@.str.40 = private unnamed_addr constant [34 x i8] c"computeConvexConvexContactsGPUSAT\00", align 1
@.str.41 = private unnamed_addr constant [42 x i8] c"Error: contacts exceeds capacity (%d/%d)\0A\00", align 1
@.str.42 = private unnamed_addr constant [27 x i8] c"m_findSeparatingAxisKernel\00", align 1
@.str.43 = private unnamed_addr constant [29 x i8] c"findSeparatingAxisKernel CPU\00", align 1
@_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E7maxdiff = internal global float 0.000000e+00, align 4
@.str.44 = private unnamed_addr constant [19 x i8] c"maxdiff = %20.10f\0A\00", align 1
@_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E7maxdiff_0 = internal global float 0.000000e+00, align 4
@_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E8maxDepth = internal global float 0.000000e+00, align 4
@.str.45 = private unnamed_addr constant [19 x i8] c"MPR maxdepth = %f\0A\00", align 1
@.str.46 = private unnamed_addr constant [10 x i8] c"rejected\0A\00", align 1
@.str.47 = private unnamed_addr constant [26 x i8] c"m_findCompoundPairsKernel\00", align 1
@.str.48 = private unnamed_addr constant [21 x i8] c"numCompoundPairs=%d\0A\00", align 1
@.str.49 = private unnamed_addr constant [41 x i8] c"Exceeded compound pair capacity (%d/%d)\0A\00", align 1
@.str.50 = private unnamed_addr constant [39 x i8] c"m_processCompoundPairsPrimitivesKernel\00", align 1
@.str.51 = private unnamed_addr constant [29 x i8] c"m_processCompoundPairsKernel\00", align 1
@.str.52 = private unnamed_addr constant [21 x i8] c"m_bvhTraversalKernel\00", align 1
@_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E39exceeded_maxTriConvexPairCapacity_count = internal global i32 0, align 4
@.str.53 = private unnamed_addr constant [86 x i8] c"Exceeded the maxTriConvexPairCapacity (found %d but max is %d, it happened %d times)\0A\00", align 1
@.str.54 = private unnamed_addr constant [44 x i8] c"m_findConcaveSeparatingAxisVertexFaceKernel\00", align 1
@.str.55 = private unnamed_addr constant [42 x i8] c"m_findConcaveSeparatingAxisEdgeEdgeKernel\00", align 1
@.str.56 = private unnamed_addr constant [34 x i8] c"m_findConcaveSeparatingAxisKernel\00", align 1
@.str.57 = private unnamed_addr constant [34 x i8] c"m_findConcaveSphereContactsKernel\00", align 1
@.str.58 = private unnamed_addr constant [25 x i8] c"clipFacesAndFindContacts\00", align 1
@.str.59 = private unnamed_addr constant [27 x i8] c"m_clipFacesAndFindContacts\00", align 1
@.str.60 = private unnamed_addr constant [28 x i8] c"m_newContactReductionKernel\00", align 1
@.str.61 = private unnamed_addr constant [34 x i8] c"m_clipHullHullConcaveConvexKernel\00", align 1
@.str.62 = private unnamed_addr constant [26 x i8] c"m_findClippingFacesKernel\00", align 1
@.str.63 = private unnamed_addr constant [21 x i8] c"m_clipHullHullKernel\00", align 1
@.str.64 = private unnamed_addr constant [35 x i8] c"Exceeded contact capacity (%d/%d)\0A\00", align 1
@.str.65 = private unnamed_addr constant [30 x i8] c"m_clipCompoundsHullHullKernel\00", align 1
@_ZTVN10__cxxabiv117__class_type_infoE = external global [0 x ptr]
@_ZTS15GpuSatCollision = dso_local constant [18 x i8] c"15GpuSatCollision\00", align 1
@_ZTI15GpuSatCollision = dso_local constant { ptr, ptr } { ptr getelementptr inbounds (ptr, ptr @_ZTVN10__cxxabiv117__class_type_infoE, i64 2), ptr @_ZTS15GpuSatCollision }, align 8
@.str.66 = private unnamed_addr constant [43628 x i8] c"/***\0A * ---------------------------------\0A * Copyright (c)2012 Daniel Fiser <danfis@danfis.cz>\0A *\0A *  This file was ported from mpr.c file, part of libccd.\0A *  The Minkoski Portal Refinement implementation was ported \0A *  to OpenCL by Erwin Coumans for the Bullet 3 Physics library.\0A *  at http://github.com/erwincoumans/bullet3\0A *\0A *  Distributed under the OSI-approved BSD License (the \22License\22);\0A *  see <http://www.opensource.org/licenses/bsd-license.php>.\0A *  This software is distributed WITHOUT ANY WARRANTY; without even the\0A *  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\0A *  See the License for more information.\0A */\0A#ifndef B3_MPR_PENETRATION_H\0A#define B3_MPR_PENETRATION_H\0A#ifndef B3_PLATFORM_DEFINITIONS_H\0A#define B3_PLATFORM_DEFINITIONS_H\0Astruct MyTest\0A{\0A\09int bla;\0A};\0A#ifdef __cplusplus\0A#else\0A//keep B3_LARGE_FLOAT*B3_LARGE_FLOAT < FLT_MAX\0A#define B3_LARGE_FLOAT 1e18f\0A#define B3_INFINITY 1e18f\0A#define b3Assert(a)\0A#define b3ConstArray(a) __global const a*\0A#define b3AtomicInc atomic_inc\0A#define b3AtomicAdd atomic_add\0A#define b3Fabs fabs\0A#define b3Sqrt native_sqrt\0A#define b3Sin native_sin\0A#define b3Cos native_cos\0A#define B3_STATIC\0A#endif\0A#endif\0A#ifndef B3_FLOAT4_H\0A#define B3_FLOAT4_H\0A#ifndef B3_PLATFORM_DEFINITIONS_H\0A#ifdef __cplusplus\0A#else\0A#endif\0A#endif\0A#ifdef __cplusplus\0A#else\0A\09typedef float4\09b3Float4;\0A\09#define b3Float4ConstArg const b3Float4\0A\09#define b3MakeFloat4 (float4)\0A\09float b3Dot3F4(b3Float4ConstArg v0,b3Float4ConstArg v1)\0A\09{\0A\09\09float4 a1 = b3MakeFloat4(v0.xyz,0.f);\0A\09\09float4 b1 = b3MakeFloat4(v1.xyz,0.f);\0A\09\09return dot(a1, b1);\0A\09}\0A\09b3Float4 b3Cross3(b3Float4ConstArg v0,b3Float4ConstArg v1)\0A\09{\0A\09\09float4 a1 = b3MakeFloat4(v0.xyz,0.f);\0A\09\09float4 b1 = b3MakeFloat4(v1.xyz,0.f);\0A\09\09return cross(a1, b1);\0A\09}\0A\09#define b3MinFloat4 min\0A\09#define b3MaxFloat4 max\0A\09#define b3Normalized(a) normalize(a)\0A#endif \0A\09\09\0Ainline bool b3IsAlmostZero(b3Float4ConstArg v)\0A{\0A\09if(b3Fabs(v.x)>1e-6 || b3Fabs(v.y)>1e-6 || b3Fabs(v.z)>1e-6)\09\0A\09\09return false;\0A\09return true;\0A}\0Ainline int    b3MaxDot( b3Float4ConstArg vec, __global const b3Float4* vecArray, int vecLen, float* dotOut )\0A{\0A    float maxDot = -B3_INFINITY;\0A    int i = 0;\0A    int ptIndex = -1;\0A    for( i = 0; i < vecLen; i++ )\0A    {\0A        float dot = b3Dot3F4(vecArray[i],vec);\0A            \0A        if( dot > maxDot )\0A        {\0A            maxDot = dot;\0A            ptIndex = i;\0A        }\0A    }\0A\09b3Assert(ptIndex>=0);\0A    if (ptIndex<0)\0A\09{\0A\09\09ptIndex = 0;\0A\09}\0A    *dotOut = maxDot;\0A    return ptIndex;\0A}\0A#endif //B3_FLOAT4_H\0A#ifndef B3_RIGIDBODY_DATA_H\0A#define B3_RIGIDBODY_DATA_H\0A#ifndef B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_FLOAT4_H\0A#ifndef B3_QUAT_H\0A#define B3_QUAT_H\0A#ifndef B3_PLATFORM_DEFINITIONS_H\0A#ifdef __cplusplus\0A#else\0A#endif\0A#endif\0A#ifndef B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A\09typedef float4\09b3Quat;\0A\09#define b3QuatConstArg const b3Quat\0A\09\0A\09\0Ainline float4 b3FastNormalize4(float4 v)\0A{\0A\09v = (float4)(v.xyz,0.f);\0A\09return fast_normalize(v);\0A}\0A\09\0Ainline b3Quat b3QuatMul(b3Quat a, b3Quat b);\0Ainline b3Quat b3QuatNormalized(b3QuatConstArg in);\0Ainline b3Quat b3QuatRotate(b3QuatConstArg q, b3QuatConstArg vec);\0Ainline b3Quat b3QuatInvert(b3QuatConstArg q);\0Ainline b3Quat b3QuatInverse(b3QuatConstArg q);\0Ainline b3Quat b3QuatMul(b3QuatConstArg a, b3QuatConstArg b)\0A{\0A\09b3Quat ans;\0A\09ans = b3Cross3( a, b );\0A\09ans += a.w*b+b.w*a;\0A//\09ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);\0A\09ans.w = a.w*b.w - b3Dot3F4(a, b);\0A\09return ans;\0A}\0Ainline b3Quat b3QuatNormalized(b3QuatConstArg in)\0A{\0A\09b3Quat q;\0A\09q=in;\0A\09//return b3FastNormalize4(in);\0A\09float len = native_sqrt(dot(q, q));\0A\09if(len > 0.f)\0A\09{\0A\09\09q *= 1.f / len;\0A\09}\0A\09else\0A\09{\0A\09\09q.x = q.y = q.z = 0.f;\0A\09\09q.w = 1.f;\0A\09}\0A\09return q;\0A}\0Ainline float4 b3QuatRotate(b3QuatConstArg q, b3QuatConstArg vec)\0A{\0A\09b3Quat qInv = b3QuatInvert( q );\0A\09float4 vcpy = vec;\0A\09vcpy.w = 0.f;\0A\09float4 out = b3QuatMul(b3QuatMul(q,vcpy),qInv);\0A\09return out;\0A}\0Ainline b3Quat b3QuatInverse(b3QuatConstArg q)\0A{\0A\09return (b3Quat)(-q.xyz, q.w);\0A}\0Ainline b3Quat b3QuatInvert(b3QuatConstArg q)\0A{\0A\09return (b3Quat)(-q.xyz, q.w);\0A}\0Ainline float4 b3QuatInvRotate(b3QuatConstArg q, b3QuatConstArg vec)\0A{\0A\09return b3QuatRotate( b3QuatInvert( q ), vec );\0A}\0Ainline b3Float4 b3TransformPoint(b3Float4ConstArg point, b3Float4ConstArg translation, b3QuatConstArg  orientation)\0A{\0A\09return b3QuatRotate( orientation, point ) + (translation);\0A}\0A\09\0A#endif \0A#endif //B3_QUAT_H\0A#ifndef B3_MAT3x3_H\0A#define B3_MAT3x3_H\0A#ifndef B3_QUAT_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_QUAT_H\0A#ifdef __cplusplus\0A#else\0Atypedef struct\0A{\0A\09b3Float4 m_row[3];\0A}b3Mat3x3;\0A#define b3Mat3x3ConstArg const b3Mat3x3\0A#define b3GetRow(m,row) (m.m_row[row])\0Ainline b3Mat3x3 b3QuatGetRotationMatrix(b3Quat quat)\0A{\0A\09b3Float4 quat2 = (b3Float4)(quat.x*quat.x, quat.y*quat.y, quat.z*quat.z, 0.f);\0A\09b3Mat3x3 out;\0A\09out.m_row[0].x=1-2*quat2.y-2*quat2.z;\0A\09out.m_row[0].y=2*quat.x*quat.y-2*quat.w*quat.z;\0A\09out.m_row[0].z=2*quat.x*quat.z+2*quat.w*quat.y;\0A\09out.m_row[0].w = 0.f;\0A\09out.m_row[1].x=2*quat.x*quat.y+2*quat.w*quat.z;\0A\09out.m_row[1].y=1-2*quat2.x-2*quat2.z;\0A\09out.m_row[1].z=2*quat.y*quat.z-2*quat.w*quat.x;\0A\09out.m_row[1].w = 0.f;\0A\09out.m_row[2].x=2*quat.x*quat.z-2*quat.w*quat.y;\0A\09out.m_row[2].y=2*quat.y*quat.z+2*quat.w*quat.x;\0A\09out.m_row[2].z=1-2*quat2.x-2*quat2.y;\0A\09out.m_row[2].w = 0.f;\0A\09return out;\0A}\0Ainline b3Mat3x3 b3AbsoluteMat3x3(b3Mat3x3ConstArg matIn)\0A{\0A\09b3Mat3x3 out;\0A\09out.m_row[0] = fabs(matIn.m_row[0]);\0A\09out.m_row[1] = fabs(matIn.m_row[1]);\0A\09out.m_row[2] = fabs(matIn.m_row[2]);\0A\09return out;\0A}\0A__inline\0Ab3Mat3x3 mtZero();\0A__inline\0Ab3Mat3x3 mtIdentity();\0A__inline\0Ab3Mat3x3 mtTranspose(b3Mat3x3 m);\0A__inline\0Ab3Mat3x3 mtMul(b3Mat3x3 a, b3Mat3x3 b);\0A__inline\0Ab3Float4 mtMul1(b3Mat3x3 a, b3Float4 b);\0A__inline\0Ab3Float4 mtMul3(b3Float4 a, b3Mat3x3 b);\0A__inline\0Ab3Mat3x3 mtZero()\0A{\0A\09b3Mat3x3 m;\0A\09m.m_row[0] = (b3Float4)(0.f);\0A\09m.m_row[1] = (b3Float4)(0.f);\0A\09m.m_row[2] = (b3Float4)(0.f);\0A\09return m;\0A}\0A__inline\0Ab3Mat3x3 mtIdentity()\0A{\0A\09b3Mat3x3 m;\0A\09m.m_row[0] = (b3Float4)(1,0,0,0);\0A\09m.m_row[1] = (b3Float4)(0,1,0,0);\0A\09m.m_row[2] = (b3Float4)(0,0,1,0);\0A\09return m;\0A}\0A__inline\0Ab3Mat3x3 mtTranspose(b3Mat3x3 m)\0A{\0A\09b3Mat3x3 out;\0A\09out.m_row[0] = (b3Float4)(m.m_row[0].x, m.m_row[1].x, m.m_row[2].x, 0.f);\0A\09out.m_row[1] = (b3Float4)(m.m_row[0].y, m.m_row[1].y, m.m_row[2].y, 0.f);\0A\09out.m_row[2] = (b3Float4)(m.m_row[0].z, m.m_row[1].z, m.m_row[2].z, 0.f);\0A\09return out;\0A}\0A__inline\0Ab3Mat3x3 mtMul(b3Mat3x3 a, b3Mat3x3 b)\0A{\0A\09b3Mat3x3 transB;\0A\09transB = mtTranspose( b );\0A\09b3Mat3x3 ans;\0A\09//\09why this doesn't run when 0ing in the for{}\0A\09a.m_row[0].w = 0.f;\0A\09a.m_row[1].w = 0.f;\0A\09a.m_row[2].w = 0.f;\0A\09for(int i=0; i<3; i++)\0A\09{\0A//\09a.m_row[i].w = 0.f;\0A\09\09ans.m_row[i].x = b3Dot3F4(a.m_row[i],transB.m_row[0]);\0A\09\09ans.m_row[i].y = b3Dot3F4(a.m_row[i],transB.m_row[1]);\0A\09\09ans.m_row[i].z = b3Dot3F4(a.m_row[i],transB.m_row[2]);\0A\09\09ans.m_row[i].w = 0.f;\0A\09}\0A\09return ans;\0A}\0A__inline\0Ab3Float4 mtMul1(b3Mat3x3 a, b3Float4 b)\0A{\0A\09b3Float4 ans;\0A\09ans.x = b3Dot3F4( a.m_row[0], b );\0A\09ans.y = b3Dot3F4( a.m_row[1], b );\0A\09ans.z = b3Dot3F4( a.m_row[2], b );\0A\09ans.w = 0.f;\0A\09return ans;\0A}\0A__inline\0Ab3Float4 mtMul3(b3Float4 a, b3Mat3x3 b)\0A{\0A\09b3Float4 colx = b3MakeFloat4(b.m_row[0].x, b.m_row[1].x, b.m_row[2].x, 0);\0A\09b3Float4 coly = b3MakeFloat4(b.m_row[0].y, b.m_row[1].y, b.m_row[2].y, 0);\0A\09b3Float4 colz = b3MakeFloat4(b.m_row[0].z, b.m_row[1].z, b.m_row[2].z, 0);\0A\09b3Float4 ans;\0A\09ans.x = b3Dot3F4( a, colx );\0A\09ans.y = b3Dot3F4( a, coly );\0A\09ans.z = b3Dot3F4( a, colz );\0A\09return ans;\0A}\0A#endif\0A#endif //B3_MAT3x3_H\0Atypedef struct b3RigidBodyData b3RigidBodyData_t;\0Astruct b3RigidBodyData\0A{\0A\09b3Float4\09\09\09\09m_pos;\0A\09b3Quat\09\09\09\09\09m_quat;\0A\09b3Float4\09\09\09\09m_linVel;\0A\09b3Float4\09\09\09\09m_angVel;\0A\09int \09\09\09\09\09m_collidableIdx;\0A\09float \09\09\09\09m_invMass;\0A\09float \09\09\09\09m_restituitionCoeff;\0A\09float \09\09\09\09m_frictionCoeff;\0A};\0Atypedef struct b3InertiaData b3InertiaData_t;\0Astruct b3InertiaData\0A{\0A\09b3Mat3x3 m_invInertiaWorld;\0A\09b3Mat3x3 m_initInvInertia;\0A};\0A#endif //B3_RIGIDBODY_DATA_H\0A\09\0A#ifndef B3_CONVEX_POLYHEDRON_DATA_H\0A#define B3_CONVEX_POLYHEDRON_DATA_H\0A#ifndef B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_FLOAT4_H\0A#ifndef B3_QUAT_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_QUAT_H\0Atypedef struct b3GpuFace b3GpuFace_t;\0Astruct b3GpuFace\0A{\0A\09b3Float4 m_plane;\0A\09int m_indexOffset;\0A\09int m_numIndices;\0A\09int m_unusedPadding1;\0A\09int m_unusedPadding2;\0A};\0Atypedef struct b3ConvexPolyhedronData b3ConvexPolyhedronData_t;\0Astruct b3ConvexPolyhedronData\0A{\0A\09b3Float4\09\09m_localCenter;\0A\09b3Float4\09\09m_extents;\0A\09b3Float4\09\09mC;\0A\09b3Float4\09\09mE;\0A\09float\09\09\09m_radius;\0A\09int\09m_faceOffset;\0A\09int m_numFaces;\0A\09int\09m_numVertices;\0A\09int m_vertexOffset;\0A\09int\09m_uniqueEdgesOffset;\0A\09int\09m_numUniqueEdges;\0A\09int m_unused;\0A};\0A#endif //B3_CONVEX_POLYHEDRON_DATA_H\0A#ifndef B3_COLLIDABLE_H\0A#define B3_COLLIDABLE_H\0A#ifndef B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_FLOAT4_H\0A#ifndef B3_QUAT_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_QUAT_H\0Aenum b3ShapeTypes\0A{\0A\09SHAPE_HEIGHT_FIELD=1,\0A\09SHAPE_CONVEX_HULL=3,\0A\09SHAPE_PLANE=4,\0A\09SHAPE_CONCAVE_TRIMESH=5,\0A\09SHAPE_COMPOUND_OF_CONVEX_HULLS=6,\0A\09SHAPE_SPHERE=7,\0A\09MAX_NUM_SHAPE_TYPES,\0A};\0Atypedef struct b3Collidable b3Collidable_t;\0Astruct b3Collidable\0A{\0A\09union {\0A\09\09int m_numChildShapes;\0A\09\09int m_bvhIndex;\0A\09};\0A\09union\0A\09{\0A\09\09float m_radius;\0A\09\09int\09m_compoundBvhIndex;\0A\09};\0A\09int m_shapeType;\0A\09int m_shapeIndex;\0A};\0Atypedef struct b3GpuChildShape b3GpuChildShape_t;\0Astruct b3GpuChildShape\0A{\0A\09b3Float4\09m_childPosition;\0A\09b3Quat\09\09m_childOrientation;\0A\09int m_shapeIndex;\0A\09int m_unused0;\0A\09int m_unused1;\0A\09int m_unused2;\0A};\0Astruct b3CompoundOverlappingPair\0A{\0A\09int m_bodyIndexA;\0A\09int m_bodyIndexB;\0A//\09int\09m_pairType;\0A\09int m_childShapeIndexA;\0A\09int m_childShapeIndexB;\0A};\0A#endif //B3_COLLIDABLE_H\0A#ifdef __cplusplus\0A#else\0A#define B3_MPR_SQRT sqrt\0A#endif\0A#define B3_MPR_FMIN(x, y) ((x) < (y) ? (x) : (y))\0A#define B3_MPR_FABS fabs\0A#define B3_MPR_TOLERANCE 1E-6f\0A#define B3_MPR_MAX_ITERATIONS 1000\0Astruct _b3MprSupport_t \0A{\0A    b3Float4 v;  //!< Support point in minkowski sum\0A    b3Float4 v1; //!< Support point in obj1\0A    b3Float4 v2; //!< Support point in obj2\0A};\0Atypedef struct _b3MprSupport_t b3MprSupport_t;\0Astruct _b3MprSimplex_t \0A{\0A    b3MprSupport_t ps[4];\0A    int last; //!< index of last added point\0A};\0Atypedef struct _b3MprSimplex_t b3MprSimplex_t;\0Ainline b3MprSupport_t* b3MprSimplexPointW(b3MprSimplex_t *s, int idx)\0A{\0A    return &s->ps[idx];\0A}\0Ainline void b3MprSimplexSetSize(b3MprSimplex_t *s, int size)\0A{\0A    s->last = size - 1;\0A}\0Ainline int b3MprSimplexSize(const b3MprSimplex_t *s)\0A{\0A    return s->last + 1;\0A}\0Ainline const b3MprSupport_t* b3MprSimplexPoint(const b3MprSimplex_t* s, int idx)\0A{\0A    // here is no check on boundaries\0A    return &s->ps[idx];\0A}\0Ainline void b3MprSupportCopy(b3MprSupport_t *d, const b3MprSupport_t *s)\0A{\0A    *d = *s;\0A}\0Ainline void b3MprSimplexSet(b3MprSimplex_t *s, size_t pos, const b3MprSupport_t *a)\0A{\0A    b3MprSupportCopy(s->ps + pos, a);\0A}\0Ainline void b3MprSimplexSwap(b3MprSimplex_t *s, size_t pos1, size_t pos2)\0A{\0A    b3MprSupport_t supp;\0A    b3MprSupportCopy(&supp, &s->ps[pos1]);\0A    b3MprSupportCopy(&s->ps[pos1], &s->ps[pos2]);\0A    b3MprSupportCopy(&s->ps[pos2], &supp);\0A}\0Ainline int b3MprIsZero(float val)\0A{\0A    return B3_MPR_FABS(val) < FLT_EPSILON;\0A}\0Ainline int b3MprEq(float _a, float _b)\0A{\0A    float ab;\0A    float a, b;\0A    ab = B3_MPR_FABS(_a - _b);\0A    if (B3_MPR_FABS(ab) < FLT_EPSILON)\0A        return 1;\0A    a = B3_MPR_FABS(_a);\0A    b = B3_MPR_FABS(_b);\0A    if (b > a){\0A        return ab < FLT_EPSILON * b;\0A    }else{\0A        return ab < FLT_EPSILON * a;\0A    }\0A}\0Ainline int b3MprVec3Eq(const b3Float4* a, const b3Float4 *b)\0A{\0A    return b3MprEq((*a).x, (*b).x)\0A            && b3MprEq((*a).y, (*b).y)\0A            && b3MprEq((*a).z, (*b).z);\0A}\0Ainline b3Float4 b3LocalGetSupportVertex(b3Float4ConstArg supportVec,__global const b3ConvexPolyhedronData_t* hull, \09b3ConstArray(b3Float4) verticesA)\0A{\0A\09b3Float4 supVec = b3MakeFloat4(0,0,0,0);\0A\09float maxDot = -B3_LARGE_FLOAT;\0A    if( 0 < hull->m_numVertices )\0A    {\0A        const b3Float4 scaled = supportVec;\0A\09\09int index = b3MaxDot(scaled, &verticesA[hull->m_vertexOffset], hull->m_numVertices, &maxDot);\0A        return verticesA[hull->m_vertexOffset+index];\0A    }\0A    return supVec;\0A}\0AB3_STATIC void b3MprConvexSupport(int pairIndex,int bodyIndex,  b3ConstArray(b3RigidBodyData_t) cpuBodyBuf, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3ConvexPolyhedronData_t) cpuConvexData, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3Collidable_t)\09\09\09\09cpuCollidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3Float4)\09\09\09\09\09cpuVertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global b3Float4* sepAxis,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09const b3Float4* _dir, b3Float4* outp, int logme)\0A{\0A\09//dir is in worldspace, move to local space\0A\09\0A\09b3Float4 pos = cpuBodyBuf[bodyIndex].m_pos;\0A\09b3Quat orn = cpuBodyBuf[bodyIndex].m_quat;\0A\09\0A\09b3Float4 dir = b3MakeFloat4((*_dir).x,(*_dir).y,(*_dir).z,0.f);\0A\09\0A\09const b3Float4 localDir = b3QuatRotate(b3QuatInverse(orn),dir);\0A\09\0A\09//find local support vertex\0A\09int colIndex = cpuBodyBuf[bodyIndex].m_collidableIdx;\0A\09\0A\09b3Assert(cpuCollidables[colIndex].m_shapeType==SHAPE_CONVEX_HULL);\0A\09__global const b3ConvexPolyhedronData_t* hull = &cpuConvexData[cpuCollidables[colIndex].m_shapeIndex];\0A\09\0A\09b3Float4 pInA;\0A\09if (logme)\0A\09{\0A\09\09b3Float4 supVec = b3MakeFloat4(0,0,0,0);\0A\09\09float maxDot = -B3_LARGE_FLOAT;\0A\09\09if( 0 < hull->m_numVertices )\0A\09\09{\0A\09\09\09const b3Float4 scaled = localDir;\0A\09\09\09int index = b3MaxDot(scaled, &cpuVertices[hull->m_vertexOffset], hull->m_numVertices, &maxDot);\0A\09\09\09pInA = cpuVertices[hull->m_vertexOffset+index];\0A\09\09\09\0A\09\09}\0A\09} else\0A\09{\0A\09\09pInA = b3LocalGetSupportVertex(localDir,hull,cpuVertices);\0A\09}\0A\09//move vertex to world space\0A\09*outp = b3TransformPoint(pInA,pos,orn);\0A\09\0A}\0Ainline void b3MprSupport(int pairIndex,int bodyIndexA, int bodyIndexB,   b3ConstArray(b3RigidBodyData_t) cpuBodyBuf, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3ConvexPolyhedronData_t) cpuConvexData, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3Collidable_t)\09\09\09\09cpuCollidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3Float4)\09\09\09\09\09cpuVertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global b3Float4* sepAxis,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09const b3Float4* _dir, b3MprSupport_t *supp)\0A{\0A    b3Float4 dir;\0A\09dir = *_dir;\0A\09b3MprConvexSupport(pairIndex,bodyIndexA,cpuBodyBuf,cpuConvexData,cpuCollidables,cpuVertices,sepAxis,&dir, &supp->v1,0);\0A    dir = *_dir*-1.f;\0A\09b3MprConvexSupport(pairIndex,bodyIndexB,cpuBodyBuf,cpuConvexData,cpuCollidables,cpuVertices,sepAxis,&dir, &supp->v2,0);\0A    supp->v = supp->v1 - supp->v2;\0A}\0Ainline void b3FindOrigin(int bodyIndexA, int bodyIndexB, b3ConstArray(b3RigidBodyData_t) cpuBodyBuf, b3MprSupport_t *center)\0A{\0A    center->v1 = cpuBodyBuf[bodyIndexA].m_pos;\0A\09center->v2 = cpuBodyBuf[bodyIndexB].m_pos;\0A    center->v = center->v1 - center->v2;\0A}\0Ainline void b3MprVec3Set(b3Float4 *v, float x, float y, float z)\0A{\0A\09(*v).x = x;\0A\09(*v).y = y;\0A\09(*v).z = z;\0A\09(*v).w = 0.f;\0A}\0Ainline void b3MprVec3Add(b3Float4 *v, const b3Float4 *w)\0A{\0A    (*v).x += (*w).x;\0A    (*v).y += (*w).y;\0A    (*v).z += (*w).z;\0A}\0Ainline void b3MprVec3Copy(b3Float4 *v, const b3Float4 *w)\0A{\0A    *v = *w;\0A}\0Ainline void b3MprVec3Scale(b3Float4 *d, float k)\0A{\0A    *d *= k;\0A}\0Ainline float b3MprVec3Dot(const b3Float4 *a, const b3Float4 *b)\0A{\0A    float dot;\0A\09dot = b3Dot3F4(*a,*b);\0A    return dot;\0A}\0Ainline float b3MprVec3Len2(const b3Float4 *v)\0A{\0A    return b3MprVec3Dot(v, v);\0A}\0Ainline void b3MprVec3Normalize(b3Float4 *d)\0A{\0A    float k = 1.f / B3_MPR_SQRT(b3MprVec3Len2(d));\0A    b3MprVec3Scale(d, k);\0A}\0Ainline void b3MprVec3Cross(b3Float4 *d, const b3Float4 *a, const b3Float4 *b)\0A{\0A\09*d = b3Cross3(*a,*b);\0A\09\0A}\0Ainline void b3MprVec3Sub2(b3Float4 *d, const b3Float4 *v, const b3Float4 *w)\0A{\0A\09*d = *v - *w;\0A}\0Ainline void b3PortalDir(const b3MprSimplex_t *portal, b3Float4 *dir)\0A{\0A    b3Float4 v2v1, v3v1;\0A    b3MprVec3Sub2(&v2v1, &b3MprSimplexPoint(portal, 2)->v,\0A                       &b3MprSimplexPoint(portal, 1)->v);\0A    b3MprVec3Sub2(&v3v1, &b3MprSimplexPoint(portal, 3)->v,\0A                       &b3MprSimplexPoint(portal, 1)->v);\0A    b3MprVec3Cross(dir, &v2v1, &v3v1);\0A    b3MprVec3Normalize(dir);\0A}\0Ainline int portalEncapsulesOrigin(const b3MprSimplex_t *portal,\0A                                       const b3Float4 *dir)\0A{\0A    float dot;\0A    dot = b3MprVec3Dot(dir, &b3MprSimplexPoint(portal, 1)->v);\0A    return b3MprIsZero(dot) || dot > 0.f;\0A}\0Ainline int portalReachTolerance(const b3MprSimplex_t *portal,\0A                                     const b3MprSupport_t *v4,\0A                                     const b3Float4 *dir)\0A{\0A    float dv1, dv2, dv3, dv4;\0A    float dot1, dot2, dot3;\0A    // find the smallest dot product of dir and {v1-v4, v2-v4, v3-v4}\0A    dv1 = b3MprVec3Dot(&b3MprSimplexPoint(portal, 1)->v, dir);\0A    dv2 = b3MprVec3Dot(&b3MprSimplexPoint(portal, 2)->v, dir);\0A    dv3 = b3MprVec3Dot(&b3MprSimplexPoint(portal, 3)->v, dir);\0A    dv4 = b3MprVec3Dot(&v4->v, dir);\0A    dot1 = dv4 - dv1;\0A    dot2 = dv4 - dv2;\0A    dot3 = dv4 - dv3;\0A    dot1 = B3_MPR_FMIN(dot1, dot2);\0A    dot1 = B3_MPR_FMIN(dot1, dot3);\0A    return b3MprEq(dot1, B3_MPR_TOLERANCE) || dot1 < B3_MPR_TOLERANCE;\0A}\0Ainline int portalCanEncapsuleOrigin(const b3MprSimplex_t *portal,   \0A                                         const b3MprSupport_t *v4,\0A                                         const b3Float4 *dir)\0A{\0A    float dot;\0A    dot = b3MprVec3Dot(&v4->v, dir);\0A    return b3MprIsZero(dot) || dot > 0.f;\0A}\0Ainline void b3ExpandPortal(b3MprSimplex_t *portal,\0A                              const b3MprSupport_t *v4)\0A{\0A    float dot;\0A    b3Float4 v4v0;\0A    b3MprVec3Cross(&v4v0, &v4->v, &b3MprSimplexPoint(portal, 0)->v);\0A    dot = b3MprVec3Dot(&b3MprSimplexPoint(portal, 1)->v, &v4v0);\0A    if (dot > 0.f){\0A        dot = b3MprVec3Dot(&b3MprSimplexPoint(portal, 2)->v, &v4v0);\0A        if (dot > 0.f){\0A            b3MprSimplexSet(portal, 1, v4);\0A        }else{\0A            b3MprSimplexSet(portal, 3, v4);\0A        }\0A    }else{\0A        dot = b3MprVec3Dot(&b3MprSimplexPoint(portal, 3)->v, &v4v0);\0A        if (dot > 0.f){\0A            b3MprSimplexSet(portal, 2, v4);\0A        }else{\0A            b3MprSimplexSet(portal, 1, v4);\0A        }\0A    }\0A}\0AB3_STATIC int b3DiscoverPortal(int pairIndex, int bodyIndexA, int bodyIndexB,  b3ConstArray(b3RigidBodyData_t) cpuBodyBuf, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3ConvexPolyhedronData_t) cpuConvexData, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3Collidable_t)\09\09\09\09cpuCollidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3Float4)\09\09\09\09\09cpuVertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global b3Float4* sepAxis,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global int*\09hasSepAxis,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3MprSimplex_t *portal)\0A{\0A    b3Float4 dir, va, vb;\0A    float dot;\0A    int cont;\0A\09\0A\09\0A    // vertex 0 is center of portal\0A    b3FindOrigin(bodyIndexA,bodyIndexB,cpuBodyBuf, b3MprSimplexPointW(portal, 0));\0A    // vertex 0 is center of portal\0A    b3MprSimplexSetSize(portal, 1);\0A\09\0A\09b3Float4 zero = b3MakeFloat4(0,0,0,0);\0A\09b3Float4* b3mpr_vec3_origin = &zero;\0A    if (b3MprVec3Eq(&b3MprSimplexPoint(portal, 0)->v, b3mpr_vec3_origin)){\0A        // Portal's center lies on origin (0,0,0) => we know that objects\0A        // intersect but we would need to know penetration info.\0A        // So move center little bit...\0A        b3MprVec3Set(&va, FLT_EPSILON * 10.f, 0.f, 0.f);\0A        b3MprVec3Add(&b3MprSimplexPointW(portal, 0)->v, &va);\0A    }\0A    // vertex 1 = support in direction of origin\0A    b3MprVec3Copy(&dir, &b3MprSimplexPoint(portal, 0)->v);\0A    b3MprVec3Scale(&dir, -1.f);\0A    b3MprVec3Normalize(&dir);\0A    b3MprSupport(pairIndex,bodyIndexA,bodyIndexB,cpuBodyBuf,cpuConvexData,cpuCollidables,cpuVertices, sepAxis,&dir, b3MprSimplexPointW(portal, 1));\0A    b3MprSimplexSetSize(portal, 2);\0A    // test if origin isn't outside of v1\0A    dot = b3MprVec3Dot(&b3MprSimplexPoint(portal, 1)->v, &dir);\0A\09\0A    if (b3MprIsZero(dot) || dot < 0.f)\0A        return -1;\0A    // vertex 2\0A    b3MprVec3Cross(&dir, &b3MprSimplexPoint(portal, 0)->v,\0A                       &b3MprSimplexPoint(portal, 1)->v);\0A    if (b3MprIsZero(b3MprVec3Len2(&dir))){\0A        if (b3MprVec3Eq(&b3MprSimplexPoint(portal, 1)->v, b3mpr_vec3_origin)){\0A            // origin lies on v1\0A            return 1;\0A        }else{\0A            // origin lies on v0-v1 segment\0A            return 2;\0A        }\0A    }\0A    b3MprVec3Normalize(&dir);\0A\09 b3MprSupport(pairIndex,bodyIndexA,bodyIndexB,cpuBodyBuf,cpuConvexData,cpuCollidables,cpuVertices, sepAxis,&dir, b3MprSimplexPointW(portal, 2));\0A    \0A    dot = b3MprVec3Dot(&b3MprSimplexPoint(portal, 2)->v, &dir);\0A    if (b3MprIsZero(dot) || dot < 0.f)\0A        return -1;\0A    b3MprSimplexSetSize(portal, 3);\0A    // vertex 3 direction\0A    b3MprVec3Sub2(&va, &b3MprSimplexPoint(portal, 1)->v,\0A                     &b3MprSimplexPoint(portal, 0)->v);\0A    b3MprVec3Sub2(&vb, &b3MprSimplexPoint(portal, 2)->v,\0A                     &b3MprSimplexPoint(portal, 0)->v);\0A    b3MprVec3Cross(&dir, &va, &vb);\0A    b3MprVec3Normalize(&dir);\0A    // it is better to form portal faces to be oriented \22outside\22 origin\0A    dot = b3MprVec3Dot(&dir, &b3MprSimplexPoint(portal, 0)->v);\0A    if (dot > 0.f){\0A        b3MprSimplexSwap(portal, 1, 2);\0A        b3MprVec3Scale(&dir, -1.f);\0A    }\0A    while (b3MprSimplexSize(portal) < 4){\0A\09\09 b3MprSupport(pairIndex,bodyIndexA,bodyIndexB,cpuBodyBuf,cpuConvexData,cpuCollidables,cpuVertices, sepAxis,&dir, b3MprSimplexPointW(portal, 3));\0A        \0A        dot = b3MprVec3Dot(&b3MprSimplexPoint(portal, 3)->v, &dir);\0A        if (b3MprIsZero(dot) || dot < 0.f)\0A            return -1;\0A        cont = 0;\0A        // test if origin is outside (v1, v0, v3) - set v2 as v3 and\0A        // continue\0A        b3MprVec3Cross(&va, &b3MprSimplexPoint(portal, 1)->v,\0A                          &b3MprSimplexPoint(portal, 3)->v);\0A        dot = b3MprVec3Dot(&va, &b3MprSimplexPoint(portal, 0)->v);\0A        if (dot < 0.f && !b3MprIsZero(dot)){\0A            b3MprSimplexSet(portal, 2, b3MprSimplexPoint(portal, 3));\0A            cont = 1;\0A        }\0A        if (!cont){\0A            // test if origin is outside (v3, v0, v2) - set v1 as v3 and\0A            // continue\0A            b3MprVec3Cross(&va, &b3MprSimplexPoint(portal, 3)->v,\0A                              &b3MprSimplexPoint(portal, 2)->v);\0A            dot = b3MprVec3Dot(&va, &b3MprSimplexPoint(portal, 0)->v);\0A            if (dot < 0.f && !b3MprIsZero(dot)){\0A                b3MprSimplexSet(portal, 1, b3MprSimplexPoint(portal, 3));\0A                cont = 1;\0A            }\0A        }\0A        if (cont){\0A            b3MprVec3Sub2(&va, &b3MprSimplexPoint(portal, 1)->v,\0A                             &b3MprSimplexPoint(portal, 0)->v);\0A            b3MprVec3Sub2(&vb, &b3MprSimplexPoint(portal, 2)->v,\0A                             &b3MprSimplexPoint(portal, 0)->v);\0A            b3MprVec3Cross(&dir, &va, &vb);\0A            b3MprVec3Normalize(&dir);\0A        }else{\0A            b3MprSimplexSetSize(portal, 4);\0A        }\0A    }\0A    return 0;\0A}\0AB3_STATIC int b3RefinePortal(int pairIndex,int bodyIndexA, int bodyIndexB,  b3ConstArray(b3RigidBodyData_t) cpuBodyBuf, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3ConvexPolyhedronData_t) cpuConvexData, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3Collidable_t)\09\09\09\09cpuCollidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3Float4)\09\09\09\09\09cpuVertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global b3Float4* sepAxis,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3MprSimplex_t *portal)\0A{\0A    b3Float4 dir;\0A    b3MprSupport_t v4;\0A\09for (int i=0;i<B3_MPR_MAX_ITERATIONS;i++)\0A    //while (1)\0A\09{\0A        // compute direction outside the portal (from v0 throught v1,v2,v3\0A        // face)\0A        b3PortalDir(portal, &dir);\0A        // test if origin is inside the portal\0A        if (portalEncapsulesOrigin(portal, &dir))\0A            return 0;\0A        // get next support point\0A        \0A\09\09 b3MprSupport(pairIndex,bodyIndexA,bodyIndexB,cpuBodyBuf,cpuConvexData,cpuCollidables,cpuVertices, sepAxis,&dir, &v4);\0A        // test if v4 can expand portal to contain origin and if portal\0A        // expanding doesn't reach given tolerance\0A        if (!portalCanEncapsuleOrigin(portal, &v4, &dir)\0A                || portalReachTolerance(portal, &v4, &dir))\0A\09\09{\0A            return -1;\0A        }\0A        // v1-v2-v3 triangle must be rearranged to face outside Minkowski\0A        // difference (direction from v0).\0A        b3ExpandPortal(portal, &v4);\0A    }\0A    return -1;\0A}\0AB3_STATIC void b3FindPos(const b3MprSimplex_t *portal, b3Float4 *pos)\0A{\0A\09b3Float4 zero = b3MakeFloat4(0,0,0,0);\0A\09b3Float4* b3mpr_vec3_origin = &zero;\0A    b3Float4 dir;\0A    size_t i;\0A    float b[4], sum, inv;\0A    b3Float4 vec, p1, p2;\0A    b3PortalDir(portal, &dir);\0A    // use barycentric coordinates of tetrahedron to find origin\0A    b3MprVec3Cross(&vec, &b3MprSimplexPoint(portal, 1)->v,\0A                       &b3MprSimplexPoint(portal, 2)->v);\0A    b[0] = b3MprVec3Dot(&vec, &b3MprSimplexPoint(portal, 3)->v);\0A    b3MprVec3Cross(&vec, &b3MprSimplexPoint(portal, 3)->v,\0A                       &b3MprSimplexPoint(portal, 2)->v);\0A    b[1] = b3MprVec3Dot(&vec, &b3MprSimplexPoint(portal, 0)->v);\0A    b3MprVec3Cross(&vec, &b3MprSimplexPoint(portal, 0)->v,\0A                       &b3MprSimplexPoint(portal, 1)->v);\0A    b[2] = b3MprVec3Dot(&vec, &b3MprSimplexPoint(portal, 3)->v);\0A    b3MprVec3Cross(&vec, &b3MprSimplexPoint(portal, 2)->v,\0A                       &b3MprSimplexPoint(portal, 1)->v);\0A    b[3] = b3MprVec3Dot(&vec, &b3MprSimplexPoint(portal, 0)->v);\0A\09sum = b[0] + b[1] + b[2] + b[3];\0A    if (b3MprIsZero(sum) || sum < 0.f){\0A\09\09b[0] = 0.f;\0A        b3MprVec3Cross(&vec, &b3MprSimplexPoint(portal, 2)->v,\0A                           &b3MprSimplexPoint(portal, 3)->v);\0A        b[1] = b3MprVec3Dot(&vec, &dir);\0A        b3MprVec3Cross(&vec, &b3MprSimplexPoint(portal, 3)->v,\0A                           &b3MprSimplexPoint(portal, 1)->v);\0A        b[2] = b3MprVec3Dot(&vec, &dir);\0A        b3MprVec3Cross(&vec, &b3MprSimplexPoint(portal, 1)->v,\0A                           &b3MprSimplexPoint(portal, 2)->v);\0A        b[3] = b3MprVec3Dot(&vec, &dir);\0A\09\09sum = b[1] + b[2] + b[3];\0A\09}\0A\09inv = 1.f / sum;\0A    b3MprVec3Copy(&p1, b3mpr_vec3_origin);\0A    b3MprVec3Copy(&p2, b3mpr_vec3_origin);\0A    for (i = 0; i < 4; i++){\0A        b3MprVec3Copy(&vec, &b3MprSimplexPoint(portal, i)->v1);\0A        b3MprVec3Scale(&vec, b[i]);\0A        b3MprVec3Add(&p1, &vec);\0A        b3MprVec3Copy(&vec, &b3MprSimplexPoint(portal, i)->v2);\0A        b3MprVec3Scale(&vec, b[i]);\0A        b3MprVec3Add(&p2, &vec);\0A    }\0A    b3MprVec3Scale(&p1, inv);\0A    b3MprVec3Scale(&p2, inv);\0A    b3MprVec3Copy(pos, &p1);\0A    b3MprVec3Add(pos, &p2);\0A    b3MprVec3Scale(pos, 0.5);\0A}\0Ainline float b3MprVec3Dist2(const b3Float4 *a, const b3Float4 *b)\0A{\0A    b3Float4 ab;\0A    b3MprVec3Sub2(&ab, a, b);\0A    return b3MprVec3Len2(&ab);\0A}\0Ainline float _b3MprVec3PointSegmentDist2(const b3Float4 *P,\0A                                                  const b3Float4 *x0,\0A                                                  const b3Float4 *b,\0A                                                  b3Float4 *witness)\0A{\0A    // The computation comes from solving equation of segment:\0A    //      S(t) = x0 + t.d\0A    //          where - x0 is initial point of segment\0A    //                - d is direction of segment from x0 (|d| > 0)\0A    //                - t belongs to <0, 1> interval\0A    // \0A    // Than, distance from a segment to some point P can be expressed:\0A    //      D(t) = |x0 + t.d - P|^2\0A    //          which is distance from any point on segment. Minimization\0A    //          of this function brings distance from P to segment.\0A    // Minimization of D(t) leads to simple quadratic equation that's\0A    // solving is straightforward.\0A    //\0A    // Bonus of this method is witness point for free.\0A    float dist, t;\0A    b3Float4 d, a;\0A    // direction of segment\0A    b3MprVec3Sub2(&d, b, x0);\0A    // precompute vector from P to x0\0A    b3MprVec3Sub2(&a, x0, P);\0A    t  = -1.f * b3MprVec3Dot(&a, &d);\0A    t /= b3MprVec3Len2(&d);\0A    if (t < 0.f || b3MprIsZero(t)){\0A        dist = b3MprVec3Dist2(x0, P);\0A        if (witness)\0A            b3MprVec3Copy(witness, x0);\0A    }else if (t > 1.f || b3MprEq(t, 1.f)){\0A        dist = b3MprVec3Dist2(b, P);\0A        if (witness)\0A            b3MprVec3Copy(witness, b);\0A    }else{\0A        if (witness){\0A            b3MprVec3Copy(witness, &d);\0A            b3MprVec3Scale(witness, t);\0A            b3MprVec3Add(witness, x0);\0A            dist = b3MprVec3Dist2(witness, P);\0A        }else{\0A            // recycling variables\0A            b3MprVec3Scale(&d, t);\0A            b3MprVec3Add(&d, &a);\0A            dist = b3MprVec3Len2(&d);\0A        }\0A    }\0A    return dist;\0A}\0Ainline float b3MprVec3PointTriDist2(const b3Float4 *P,\0A                                const b3Float4 *x0, const b3Float4 *B,\0A                                const b3Float4 *C,\0A                                b3Float4 *witness)\0A{\0A    // Computation comes from analytic expression for triangle (x0, B, C)\0A    //      T(s, t) = x0 + s.d1 + t.d2, where d1 = B - x0 and d2 = C - x0 and\0A    // Then equation for distance is:\0A    //      D(s, t) = | T(s, t) - P |^2\0A    // This leads to minimization of quadratic function of two variables.\0A    // The solution from is taken only if s is between 0 and 1, t is\0A    // between 0 and 1 and t + s < 1, otherwise distance from segment is\0A    // computed.\0A    b3Float4 d1, d2, a;\0A    float u, v, w, p, q, r;\0A    float s, t, dist, dist2;\0A    b3Float4 witness2;\0A    b3MprVec3Sub2(&d1, B, x0);\0A    b3MprVec3Sub2(&d2, C, x0);\0A    b3MprVec3Sub2(&a, x0, P);\0A    u = b3MprVec3Dot(&a, &a);\0A    v = b3MprVec3Dot(&d1, &d1);\0A    w = b3MprVec3Dot(&d2, &d2);\0A    p = b3MprVec3Dot(&a, &d1);\0A    q = b3MprVec3Dot(&a, &d2);\0A    r = b3MprVec3Dot(&d1, &d2);\0A    s = (q * r - w * p) / (w * v - r * r);\0A    t = (-s * r - q) / w;\0A    if ((b3MprIsZero(s) || s > 0.f)\0A            && (b3MprEq(s, 1.f) || s < 1.f)\0A            && (b3MprIsZero(t) || t > 0.f)\0A            && (b3MprEq(t, 1.f) || t < 1.f)\0A            && (b3MprEq(t + s, 1.f) || t + s < 1.f)){\0A        if (witness){\0A            b3MprVec3Scale(&d1, s);\0A            b3MprVec3Scale(&d2, t);\0A            b3MprVec3Copy(witness, x0);\0A            b3MprVec3Add(witness, &d1);\0A            b3MprVec3Add(witness, &d2);\0A            dist = b3MprVec3Dist2(witness, P);\0A        }else{\0A            dist  = s * s * v;\0A            dist += t * t * w;\0A            dist += 2.f * s * t * r;\0A            dist += 2.f * s * p;\0A            dist += 2.f * t * q;\0A            dist += u;\0A        }\0A    }else{\0A        dist = _b3MprVec3PointSegmentDist2(P, x0, B, witness);\0A        dist2 = _b3MprVec3PointSegmentDist2(P, x0, C, &witness2);\0A        if (dist2 < dist){\0A            dist = dist2;\0A            if (witness)\0A                b3MprVec3Copy(witness, &witness2);\0A        }\0A        dist2 = _b3MprVec3PointSegmentDist2(P, B, C, &witness2);\0A        if (dist2 < dist){\0A            dist = dist2;\0A            if (witness)\0A                b3MprVec3Copy(witness, &witness2);\0A        }\0A    }\0A    return dist;\0A}\0AB3_STATIC void b3FindPenetr(int pairIndex,int bodyIndexA, int bodyIndexB,  b3ConstArray(b3RigidBodyData_t) cpuBodyBuf, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3ConvexPolyhedronData_t) cpuConvexData, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3Collidable_t)\09\09\09\09cpuCollidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3Float4)\09\09\09\09\09cpuVertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global b3Float4* sepAxis,\0A                       b3MprSimplex_t *portal,\0A                       float *depth, b3Float4 *pdir, b3Float4 *pos)\0A{\0A    b3Float4 dir;\0A    b3MprSupport_t v4;\0A    unsigned long iterations;\0A\09b3Float4 zero = b3MakeFloat4(0,0,0,0);\0A\09b3Float4* b3mpr_vec3_origin = &zero;\0A    iterations = 1UL;\0A\09for (int i=0;i<B3_MPR_MAX_ITERATIONS;i++)\0A    //while (1)\0A\09{\0A        // compute portal direction and obtain next support point\0A        b3PortalDir(portal, &dir);\0A        \0A\09\09 b3MprSupport(pairIndex,bodyIndexA,bodyIndexB,cpuBodyBuf,cpuConvexData,cpuCollidables,cpuVertices, sepAxis,&dir, &v4);\0A        // reached tolerance -> find penetration info\0A        if (portalReachTolerance(portal, &v4, &dir)\0A                || iterations ==B3_MPR_MAX_ITERATIONS)\0A\09\09{\0A            *depth = b3MprVec3PointTriDist2(b3mpr_vec3_origin,&b3MprSimplexPoint(portal, 1)->v,&b3MprSimplexPoint(portal, 2)->v,&b3MprSimplexPoint(portal, 3)->v,pdir);\0A            *depth = B3_MPR_SQRT(*depth);\0A\09\09\09\0A\09\09\09if (b3MprIsZero((*pdir).x) && b3MprIsZero((*pdir).y) && b3MprIsZero((*pdir).z))\0A\09\09\09{\0A\09\09\09\09\0A\09\09\09\09*pdir = dir;\0A\09\09\09} \0A\09\09\09b3MprVec3Normalize(pdir);\0A\09\09\09\0A            // barycentric coordinates:\0A            b3FindPos(portal, pos);\0A            return;\0A        }\0A        b3ExpandPortal(portal, &v4);\0A        iterations++;\0A    }\0A}\0AB3_STATIC void b3FindPenetrTouch(b3MprSimplex_t *portal,float *depth, b3Float4 *dir, b3Float4 *pos)\0A{\0A    // Touching contact on portal's v1 - so depth is zero and direction\0A    // is unimportant and pos can be guessed\0A    *depth = 0.f;\0A    b3Float4 zero = b3MakeFloat4(0,0,0,0);\0A\09b3Float4* b3mpr_vec3_origin = &zero;\0A\09b3MprVec3Copy(dir, b3mpr_vec3_origin);\0A    b3MprVec3Copy(pos, &b3MprSimplexPoint(portal, 1)->v1);\0A    b3MprVec3Add(pos, &b3MprSimplexPoint(portal, 1)->v2);\0A    b3MprVec3Scale(pos, 0.5);\0A}\0AB3_STATIC void b3FindPenetrSegment(b3MprSimplex_t *portal,\0A                              float *depth, b3Float4 *dir, b3Float4 *pos)\0A{\0A    \0A    // Origin lies on v0-v1 segment.\0A    // Depth is distance to v1, direction also and position must be\0A    // computed\0A    b3MprVec3Copy(pos, &b3MprSimplexPoint(portal, 1)->v1);\0A    b3MprVec3Add(pos, &b3MprSimplexPoint(portal, 1)->v2);\0A    b3MprVec3Scale(pos, 0.5f);\0A    \0A    b3MprVec3Copy(dir, &b3MprSimplexPoint(portal, 1)->v);\0A    *depth = B3_MPR_SQRT(b3MprVec3Len2(dir));\0A    b3MprVec3Normalize(dir);\0A}\0Ainline int b3MprPenetration(int pairIndex, int bodyIndexA, int bodyIndexB,\0A\09\09\09\09\09b3ConstArray(b3RigidBodyData_t) cpuBodyBuf,\0A\09\09\09\09\09b3ConstArray(b3ConvexPolyhedronData_t) cpuConvexData, \0A\09\09\09\09\09b3ConstArray(b3Collidable_t)\09cpuCollidables,\0A\09\09\09\09\09b3ConstArray(b3Float4)\09cpuVertices,\0A\09\09\09\09\09__global b3Float4* sepAxis,\0A\09\09\09\09\09__global int*\09hasSepAxis,\0A\09\09\09\09\09float *depthOut, b3Float4* dirOut, b3Float4* posOut)\0A{\0A\09\0A\09 b3MprSimplex_t portal;\0A\09 \0A//\09if (!hasSepAxis[pairIndex])\0A\09//\09return -1;\0A\09\0A\09hasSepAxis[pairIndex] = 0;\0A\09 int res;\0A    // Phase 1: Portal discovery\0A    res = b3DiscoverPortal(pairIndex,bodyIndexA,bodyIndexB,cpuBodyBuf,cpuConvexData,cpuCollidables,cpuVertices,sepAxis,hasSepAxis, &portal);\0A\09\0A\09  \0A\09//sepAxis[pairIndex] = *pdir;//or -dir?\0A\09switch (res)\0A\09{\0A\09case 0:\0A\09\09{\0A\09\09\09// Phase 2: Portal refinement\0A\09\09\0A\09\09\09res = b3RefinePortal(pairIndex,bodyIndexA,bodyIndexB,cpuBodyBuf,cpuConvexData,cpuCollidables,cpuVertices, sepAxis,&portal);\0A\09\09\09if (res < 0)\0A\09\09\09\09return -1;\0A\09\09\09// Phase 3. Penetration info\0A\09\09\09b3FindPenetr(pairIndex,bodyIndexA,bodyIndexB,cpuBodyBuf,cpuConvexData,cpuCollidables,cpuVertices, sepAxis,&portal, depthOut, dirOut, posOut);\0A\09\09\09hasSepAxis[pairIndex] = 1;\0A\09\09\09sepAxis[pairIndex] = -*dirOut;\0A\09\09\09break;\0A\09\09}\0A\09case 1:\0A\09\09{\0A\09\09\09 // Touching contact on portal's v1.\0A\09\09\09b3FindPenetrTouch(&portal, depthOut, dirOut, posOut);\0A\09\09\09break;\0A\09\09}\0A\09case 2:\0A\09\09{\0A\09\09\09\0A\09\09\09b3FindPenetrSegment( &portal, depthOut, dirOut, posOut);\0A\09\09\09break;\0A\09\09}\0A\09default:\0A\09\09{\0A\09\09\09hasSepAxis[pairIndex]=0;\0A\09\09\09//if (res < 0)\0A\09\09\09//{\0A\09\09\09\09// Origin isn't inside portal - no collision.\0A\09\09\09\09return -1;\0A\09\09\09//}\0A\09\09}\0A\09};\0A\09\0A\09return 0;\0A};\0A#endif //B3_MPR_PENETRATION_H\0A#ifndef B3_CONTACT4DATA_H\0A#define B3_CONTACT4DATA_H\0A#ifndef B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_FLOAT4_H\0Atypedef  struct b3Contact4Data b3Contact4Data_t;\0Astruct b3Contact4Data\0A{\0A\09b3Float4\09m_worldPosB[4];\0A//\09b3Float4\09m_localPosA[4];\0A//\09b3Float4\09m_localPosB[4];\0A\09b3Float4\09m_worldNormalOnB;\09//\09w: m_nPoints\0A\09unsigned short  m_restituitionCoeffCmp;\0A\09unsigned short  m_frictionCoeffCmp;\0A\09int m_batchIdx;\0A\09int m_bodyAPtrAndSignBit;//x:m_bodyAPtr, y:m_bodyBPtr\0A\09int m_bodyBPtrAndSignBit;\0A\09int\09m_childIndexA;\0A\09int\09m_childIndexB;\0A\09int m_unused1;\0A\09int m_unused2;\0A};\0Ainline int b3Contact4Data_getNumPoints(const struct b3Contact4Data* contact)\0A{\0A\09return (int)contact->m_worldNormalOnB.w;\0A};\0Ainline void b3Contact4Data_setNumPoints(struct b3Contact4Data* contact, int numPoints)\0A{\0A\09contact->m_worldNormalOnB.w = (float)numPoints;\0A};\0A#endif //B3_CONTACT4DATA_H\0A#define AppendInc(x, out) out = atomic_inc(x)\0A#define GET_NPOINTS(x) (x).m_worldNormalOnB.w\0A#ifdef cl_ext_atomic_counters_32\0A\09#pragma OPENCL EXTENSION cl_ext_atomic_counters_32 : enable\0A#else\0A\09#define counter32_t volatile __global int*\0A#endif\0A__kernel void   mprPenetrationKernel( __global int4* pairs,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3RigidBodyData_t* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3Collidable_t* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3ConvexPolyhedronData_t* convexShapes, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* vertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global float4* separatingNormals,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global int* hasSeparatingAxis,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global struct b3Contact4Data* restrict globalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09counter32_t nGlobalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int contactCapacity,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numPairs)\0A{\0A\09int i = get_global_id(0);\0A\09int pairIndex = i;\0A\09if (i<numPairs)\0A\09{\0A\09\09int bodyIndexA = pairs[i].x;\0A\09\09int bodyIndexB = pairs[i].y;\0A\09\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09\0A\09\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09\09\0A\09\09\0A\09\09//once the broadphase avoids static-static pairs, we can remove this test\0A\09\09if ((rigidBodies[bodyIndexA].m_invMass==0) &&(rigidBodies[bodyIndexB].m_invMass==0))\0A\09\09{\0A\09\09\09return;\0A\09\09}\0A\09\09\0A\09\09if ((collidables[collidableIndexA].m_shapeType!=SHAPE_CONVEX_HULL) ||(collidables[collidableIndexB].m_shapeType!=SHAPE_CONVEX_HULL))\0A\09\09{\0A\09\09\09return;\0A\09\09}\0A\09\09float depthOut;\0A\09\09b3Float4 dirOut;\0A\09\09b3Float4 posOut;\0A\09\09int res = b3MprPenetration(pairIndex, bodyIndexA, bodyIndexB,rigidBodies,convexShapes,collidables,vertices,separatingNormals,hasSeparatingAxis,&depthOut, &dirOut, &posOut);\0A\09\09\0A\09\09\0A\09\09\0A\09\09\0A\09\09if (res==0)\0A\09\09{\0A\09\09\09//add a contact\0A\09\09\09int dstIdx;\0A\09\09\09AppendInc( nGlobalContactsOut, dstIdx );\0A\09\09\09if (dstIdx<contactCapacity)\0A\09\09\09{\0A\09\09\09\09pairs[pairIndex].z = dstIdx;\0A\09\09\09\09__global struct b3Contact4Data* c = globalContactsOut + dstIdx;\0A\09\09\09\09c->m_worldNormalOnB = -dirOut;//normal;\0A\09\09\09\09c->m_restituitionCoeffCmp = (0.f*0xffff);c->m_frictionCoeffCmp = (0.7f*0xffff);\0A\09\09\09\09c->m_batchIdx = pairIndex;\0A\09\09\09\09int bodyA = pairs[pairIndex].x;\0A\09\09\09\09int bodyB = pairs[pairIndex].y;\0A\09\09\09\09c->m_bodyAPtrAndSignBit = rigidBodies[bodyA].m_invMass==0 ? -bodyA:bodyA;\0A\09\09\09\09c->m_bodyBPtrAndSignBit = rigidBodies[bodyB].m_invMass==0 ? -bodyB:bodyB;\0A\09\09\09\09c->m_childIndexA = -1;\0A\09\09\09\09c->m_childIndexB = -1;\0A\09\09\09\09//for (int i=0;i<nContacts;i++)\0A\09\09\09\09posOut.w = -depthOut;\0A\09\09\09\09c->m_worldPosB[0] = posOut;//localPoints[contactIdx[i]];\0A\09\09\09\09GET_NPOINTS(*c) = 1;//nContacts;\0A\09\09\09}\0A\09\09}\0A\09}\0A}\0Atypedef float4 Quaternion;\0A#define make_float4 (float4)\0A__inline\0Afloat dot3F4(float4 a, float4 b)\0A{\0A\09float4 a1 = make_float4(a.xyz,0.f);\0A\09float4 b1 = make_float4(b.xyz,0.f);\0A\09return dot(a1, b1);\0A}\0A__inline\0Afloat4 cross3(float4 a, float4 b)\0A{\0A\09return cross(a,b);\0A}\0A__inline\0AQuaternion qtMul(Quaternion a, Quaternion b)\0A{\0A\09Quaternion ans;\0A\09ans = cross3( a, b );\0A\09ans += a.w*b+b.w*a;\0A//\09ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);\0A\09ans.w = a.w*b.w - dot3F4(a, b);\0A\09return ans;\0A}\0A__inline\0AQuaternion qtInvert(Quaternion q)\0A{\0A\09return (Quaternion)(-q.xyz, q.w);\0A}\0A__inline\0Afloat4 qtRotate(Quaternion q, float4 vec)\0A{\0A\09Quaternion qInv = qtInvert( q );\0A\09float4 vcpy = vec;\0A\09vcpy.w = 0.f;\0A\09float4 out = qtMul(qtMul(q,vcpy),qInv);\0A\09return out;\0A}\0A__inline\0Afloat4 transform(const float4* p, const float4* translation, const Quaternion* orientation)\0A{\0A\09return qtRotate( *orientation, *p ) + (*translation);\0A}\0A__inline\0Afloat4 qtInvRotate(const Quaternion q, float4 vec)\0A{\0A\09return qtRotate( qtInvert( q ), vec );\0A}\0Ainline void project(__global const b3ConvexPolyhedronData_t* hull,  const float4 pos, const float4 orn, \0Aconst float4* dir, __global const float4* vertices, float* min, float* max)\0A{\0A\09min[0] = FLT_MAX;\0A\09max[0] = -FLT_MAX;\0A\09int numVerts = hull->m_numVertices;\0A\09const float4 localDir = qtInvRotate(orn,*dir);\0A\09float offset = dot(pos,*dir);\0A\09for(int i=0;i<numVerts;i++)\0A\09{\0A\09\09float dp = dot(vertices[hull->m_vertexOffset+i],localDir);\0A\09\09if(dp < min[0])\09\0A\09\09\09min[0] = dp;\0A\09\09if(dp > max[0])\09\0A\09\09\09max[0] = dp;\0A\09}\0A\09if(min[0]>max[0])\0A\09{\0A\09\09float tmp = min[0];\0A\09\09min[0] = max[0];\0A\09\09max[0] = tmp;\0A\09}\0A\09min[0] += offset;\0A\09max[0] += offset;\0A}\0Abool findSeparatingAxisUnitSphere(\09__global const b3ConvexPolyhedronData_t* hullA, __global const b3ConvexPolyhedronData_t* hullB, \0A\09const float4 posA1,\0A\09const float4 ornA,\0A\09const float4 posB1,\0A\09const float4 ornB,\0A\09const float4 DeltaC2,\0A\09__global const float4* vertices,\0A\09__global const float4* unitSphereDirections,\0A\09int numUnitSphereDirections,\0A\09float4* sep,\0A\09float* dmin)\0A{\0A\09\0A\09float4 posA = posA1;\0A\09posA.w = 0.f;\0A\09float4 posB = posB1;\0A\09posB.w = 0.f;\0A\09int curPlaneTests=0;\0A\09int curEdgeEdge = 0;\0A\09// Test unit sphere directions\0A\09for (int i=0;i<numUnitSphereDirections;i++)\0A\09{\0A\09\09float4 crossje;\0A\09\09crossje = unitSphereDirections[i];\09\0A\09\09if (dot3F4(DeltaC2,crossje)>0)\0A\09\09\09crossje *= -1.f;\0A\09\09{\0A\09\09\09float dist;\0A\09\09\09bool result = true;\0A\09\09\09float Min0,Max0;\0A\09\09\09float Min1,Max1;\0A\09\09\09project(hullA,posA,ornA,&crossje,vertices, &Min0, &Max0);\0A\09\09\09project(hullB,posB,ornB,&crossje,vertices, &Min1, &Max1);\0A\09\09\0A\09\09\09if(Max0<Min1 || Max1<Min0)\0A\09\09\09\09return false;\0A\09\09\0A\09\09\09float d0 = Max0 - Min1;\0A\09\09\09float d1 = Max1 - Min0;\0A\09\09\09dist = d0<d1 ? d0:d1;\0A\09\09\09result = true;\0A\09\0A\09\09\09if(dist<*dmin)\0A\09\09\09{\0A\09\09\09\09*dmin = dist;\0A\09\09\09\09*sep = crossje;\0A\09\09\09}\0A\09\09}\0A\09}\0A\09\0A\09if((dot3F4(-DeltaC2,*sep))>0.0f)\0A\09{\0A\09\09*sep = -(*sep);\0A\09}\0A\09return true;\0A}\0A__kernel void   findSeparatingAxisUnitSphereKernel( __global const int4* pairs, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3RigidBodyData_t* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3Collidable_t* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3ConvexPolyhedronData_t* convexShapes, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* vertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* unitSphereDirections,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global  float4* separatingNormals,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global  int* hasSeparatingAxis,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global  float* dmins,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numUnitSphereDirections,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numPairs\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09)\0A{\0A\09int i = get_global_id(0);\0A\09\0A\09if (i<numPairs)\0A\09{\0A\09\09if (hasSeparatingAxis[i])\0A\09\09{\0A\09\0A\09\09\09int bodyIndexA = pairs[i].x;\0A\09\09\09int bodyIndexB = pairs[i].y;\0A\09\0A\09\09\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09\09\0A\09\09\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09\09\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09\09\09\0A\09\09\09\0A\09\09\09int numFacesA = convexShapes[shapeIndexA].m_numFaces;\0A\09\0A\09\09\09float dmin = dmins[i];\0A\09\0A\09\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09\09posA.w = 0.f;\0A\09\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09posB.w = 0.f;\0A\09\09\09float4 c0local = convexShapes[shapeIndexA].m_localCenter;\0A\09\09\09float4 ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09\09float4 c0 = transform(&c0local, &posA, &ornA);\0A\09\09\09float4 c1local = convexShapes[shapeIndexB].m_localCenter;\0A\09\09\09float4 ornB =rigidBodies[bodyIndexB].m_quat;\0A\09\09\09float4 c1 = transform(&c1local,&posB,&ornB);\0A\09\09\09const float4 DeltaC2 = c0 - c1;\0A\09\09\09float4 sepNormal = separatingNormals[i];\0A\09\09\09\0A\09\09\09int numEdgeEdgeDirections = convexShapes[shapeIndexA].m_numUniqueEdges*convexShapes[shapeIndexB].m_numUniqueEdges;\0A\09\09\09if (numEdgeEdgeDirections>numUnitSphereDirections)\0A\09\09\09{\0A\09\09\09\09bool sepEE = findSeparatingAxisUnitSphere(\09&convexShapes[shapeIndexA], &convexShapes[shapeIndexB],posA,ornA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09posB,ornB,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09DeltaC2,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09vertices,unitSphereDirections,numUnitSphereDirections,&sepNormal,&dmin);\0A\09\09\09\09if (!sepEE)\0A\09\09\09\09{\0A\09\09\09\09\09hasSeparatingAxis[i] = 0;\0A\09\09\09\09} else\0A\09\09\09\09{\0A\09\09\09\09\09hasSeparatingAxis[i] = 1;\0A\09\09\09\09\09separatingNormals[i] = sepNormal;\0A\09\09\09\09}\0A\09\09\09}\0A\09\09}\09\09//if (hasSeparatingAxis[i])\0A\09}//(i<numPairs)\0A}\0A\00", align 1
@.str.67 = private unnamed_addr constant [42233 x i8] c"//keep this enum in sync with the CPU version (in btCollidable.h)\0A//written by Erwin Coumans\0A#define SHAPE_CONVEX_HULL 3\0A#define SHAPE_CONCAVE_TRIMESH 5\0A#define TRIANGLE_NUM_CONVEX_FACES 5\0A#define SHAPE_COMPOUND_OF_CONVEX_HULLS 6\0A#define B3_MAX_STACK_DEPTH 256\0Atypedef unsigned int u32;\0A///keep this in sync with btCollidable.h\0Atypedef struct\0A{\0A\09union {\0A\09\09int m_numChildShapes;\0A\09\09int m_bvhIndex;\0A\09};\0A\09union\0A\09{\0A\09\09float m_radius;\0A\09\09int\09m_compoundBvhIndex;\0A\09};\0A\09\0A\09int m_shapeType;\0A\09int m_shapeIndex;\0A\09\0A} btCollidableGpu;\0A#define MAX_NUM_PARTS_IN_BITS 10\0A///b3QuantizedBvhNode is a compressed aabb node, 16 bytes.\0A///Node can be used for leafnode or internal node. Leafnodes can point to 32-bit triangle index (non-negative range).\0Atypedef struct\0A{\0A\09//12 bytes\0A\09unsigned short int\09m_quantizedAabbMin[3];\0A\09unsigned short int\09m_quantizedAabbMax[3];\0A\09//4 bytes\0A\09int\09m_escapeIndexOrTriangleIndex;\0A} b3QuantizedBvhNode;\0Atypedef struct\0A{\0A\09float4\09\09m_aabbMin;\0A\09float4\09\09m_aabbMax;\0A\09float4\09\09m_quantization;\0A\09int\09\09\09m_numNodes;\0A\09int\09\09\09m_numSubTrees;\0A\09int\09\09\09m_nodeOffset;\0A\09int\09\09\09m_subTreeOffset;\0A} b3BvhInfo;\0Aint\09getTriangleIndex(const b3QuantizedBvhNode* rootNode)\0A{\0A\09unsigned int x=0;\0A\09unsigned int y = (~(x&0))<<(31-MAX_NUM_PARTS_IN_BITS);\0A\09// Get only the lower bits where the triangle index is stored\0A\09return (rootNode->m_escapeIndexOrTriangleIndex&~(y));\0A}\0Aint\09getTriangleIndexGlobal(__global const b3QuantizedBvhNode* rootNode)\0A{\0A\09unsigned int x=0;\0A\09unsigned int y = (~(x&0))<<(31-MAX_NUM_PARTS_IN_BITS);\0A\09// Get only the lower bits where the triangle index is stored\0A\09return (rootNode->m_escapeIndexOrTriangleIndex&~(y));\0A}\0Aint isLeafNode(const b3QuantizedBvhNode* rootNode)\0A{\0A\09//skipindex is negative (internal node), triangleindex >=0 (leafnode)\0A\09return (rootNode->m_escapeIndexOrTriangleIndex >= 0)? 1 : 0;\0A}\0Aint isLeafNodeGlobal(__global const b3QuantizedBvhNode* rootNode)\0A{\0A\09//skipindex is negative (internal node), triangleindex >=0 (leafnode)\0A\09return (rootNode->m_escapeIndexOrTriangleIndex >= 0)? 1 : 0;\0A}\0A\09\0Aint getEscapeIndex(const b3QuantizedBvhNode* rootNode)\0A{\0A\09return -rootNode->m_escapeIndexOrTriangleIndex;\0A}\0Aint getEscapeIndexGlobal(__global const b3QuantizedBvhNode* rootNode)\0A{\0A\09return -rootNode->m_escapeIndexOrTriangleIndex;\0A}\0Atypedef struct\0A{\0A\09//12 bytes\0A\09unsigned short int\09m_quantizedAabbMin[3];\0A\09unsigned short int\09m_quantizedAabbMax[3];\0A\09//4 bytes, points to the root of the subtree\0A\09int\09\09\09m_rootNodeIndex;\0A\09//4 bytes\0A\09int\09\09\09m_subtreeSize;\0A\09int\09\09\09m_padding[3];\0A} b3BvhSubtreeInfo;\0Atypedef struct\0A{\0A\09float4\09m_childPosition;\0A\09float4\09m_childOrientation;\0A\09int m_shapeIndex;\0A\09int m_unused0;\0A\09int m_unused1;\0A\09int m_unused2;\0A} btGpuChildShape;\0Atypedef struct\0A{\0A\09float4 m_pos;\0A\09float4 m_quat;\0A\09float4 m_linVel;\0A\09float4 m_angVel;\0A\09u32 m_collidableIdx;\0A\09float m_invMass;\0A\09float m_restituitionCoeff;\0A\09float m_frictionCoeff;\0A} BodyData;\0Atypedef struct  \0A{\0A\09float4\09\09m_localCenter;\0A\09float4\09\09m_extents;\0A\09float4\09\09mC;\0A\09float4\09\09mE;\0A\09\0A\09float\09\09\09m_radius;\0A\09int\09m_faceOffset;\0A\09int m_numFaces;\0A\09int\09m_numVertices;\0A\09int m_vertexOffset;\0A\09int\09m_uniqueEdgesOffset;\0A\09int\09m_numUniqueEdges;\0A\09int m_unused;\0A} ConvexPolyhedronCL;\0Atypedef struct \0A{\0A\09union\0A\09{\0A\09\09float4\09m_min;\0A\09\09float   m_minElems[4];\0A\09\09int\09\09\09m_minIndices[4];\0A\09};\0A\09union\0A\09{\0A\09\09float4\09m_max;\0A\09\09float   m_maxElems[4];\0A\09\09int\09\09\09m_maxIndices[4];\0A\09};\0A} btAabbCL;\0A#ifndef B3_AABB_H\0A#define B3_AABB_H\0A#ifndef B3_FLOAT4_H\0A#define B3_FLOAT4_H\0A#ifndef B3_PLATFORM_DEFINITIONS_H\0A#define B3_PLATFORM_DEFINITIONS_H\0Astruct MyTest\0A{\0A\09int bla;\0A};\0A#ifdef __cplusplus\0A#else\0A//keep B3_LARGE_FLOAT*B3_LARGE_FLOAT < FLT_MAX\0A#define B3_LARGE_FLOAT 1e18f\0A#define B3_INFINITY 1e18f\0A#define b3Assert(a)\0A#define b3ConstArray(a) __global const a*\0A#define b3AtomicInc atomic_inc\0A#define b3AtomicAdd atomic_add\0A#define b3Fabs fabs\0A#define b3Sqrt native_sqrt\0A#define b3Sin native_sin\0A#define b3Cos native_cos\0A#define B3_STATIC\0A#endif\0A#endif\0A#ifdef __cplusplus\0A#else\0A\09typedef float4\09b3Float4;\0A\09#define b3Float4ConstArg const b3Float4\0A\09#define b3MakeFloat4 (float4)\0A\09float b3Dot3F4(b3Float4ConstArg v0,b3Float4ConstArg v1)\0A\09{\0A\09\09float4 a1 = b3MakeFloat4(v0.xyz,0.f);\0A\09\09float4 b1 = b3MakeFloat4(v1.xyz,0.f);\0A\09\09return dot(a1, b1);\0A\09}\0A\09b3Float4 b3Cross3(b3Float4ConstArg v0,b3Float4ConstArg v1)\0A\09{\0A\09\09float4 a1 = b3MakeFloat4(v0.xyz,0.f);\0A\09\09float4 b1 = b3MakeFloat4(v1.xyz,0.f);\0A\09\09return cross(a1, b1);\0A\09}\0A\09#define b3MinFloat4 min\0A\09#define b3MaxFloat4 max\0A\09#define b3Normalized(a) normalize(a)\0A#endif \0A\09\09\0Ainline bool b3IsAlmostZero(b3Float4ConstArg v)\0A{\0A\09if(b3Fabs(v.x)>1e-6 || b3Fabs(v.y)>1e-6 || b3Fabs(v.z)>1e-6)\09\0A\09\09return false;\0A\09return true;\0A}\0Ainline int    b3MaxDot( b3Float4ConstArg vec, __global const b3Float4* vecArray, int vecLen, float* dotOut )\0A{\0A    float maxDot = -B3_INFINITY;\0A    int i = 0;\0A    int ptIndex = -1;\0A    for( i = 0; i < vecLen; i++ )\0A    {\0A        float dot = b3Dot3F4(vecArray[i],vec);\0A            \0A        if( dot > maxDot )\0A        {\0A            maxDot = dot;\0A            ptIndex = i;\0A        }\0A    }\0A\09b3Assert(ptIndex>=0);\0A    if (ptIndex<0)\0A\09{\0A\09\09ptIndex = 0;\0A\09}\0A    *dotOut = maxDot;\0A    return ptIndex;\0A}\0A#endif //B3_FLOAT4_H\0A#ifndef B3_MAT3x3_H\0A#define B3_MAT3x3_H\0A#ifndef B3_QUAT_H\0A#define B3_QUAT_H\0A#ifndef B3_PLATFORM_DEFINITIONS_H\0A#ifdef __cplusplus\0A#else\0A#endif\0A#endif\0A#ifndef B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A\09typedef float4\09b3Quat;\0A\09#define b3QuatConstArg const b3Quat\0A\09\0A\09\0Ainline float4 b3FastNormalize4(float4 v)\0A{\0A\09v = (float4)(v.xyz,0.f);\0A\09return fast_normalize(v);\0A}\0A\09\0Ainline b3Quat b3QuatMul(b3Quat a, b3Quat b);\0Ainline b3Quat b3QuatNormalized(b3QuatConstArg in);\0Ainline b3Quat b3QuatRotate(b3QuatConstArg q, b3QuatConstArg vec);\0Ainline b3Quat b3QuatInvert(b3QuatConstArg q);\0Ainline b3Quat b3QuatInverse(b3QuatConstArg q);\0Ainline b3Quat b3QuatMul(b3QuatConstArg a, b3QuatConstArg b)\0A{\0A\09b3Quat ans;\0A\09ans = b3Cross3( a, b );\0A\09ans += a.w*b+b.w*a;\0A//\09ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);\0A\09ans.w = a.w*b.w - b3Dot3F4(a, b);\0A\09return ans;\0A}\0Ainline b3Quat b3QuatNormalized(b3QuatConstArg in)\0A{\0A\09b3Quat q;\0A\09q=in;\0A\09//return b3FastNormalize4(in);\0A\09float len = native_sqrt(dot(q, q));\0A\09if(len > 0.f)\0A\09{\0A\09\09q *= 1.f / len;\0A\09}\0A\09else\0A\09{\0A\09\09q.x = q.y = q.z = 0.f;\0A\09\09q.w = 1.f;\0A\09}\0A\09return q;\0A}\0Ainline float4 b3QuatRotate(b3QuatConstArg q, b3QuatConstArg vec)\0A{\0A\09b3Quat qInv = b3QuatInvert( q );\0A\09float4 vcpy = vec;\0A\09vcpy.w = 0.f;\0A\09float4 out = b3QuatMul(b3QuatMul(q,vcpy),qInv);\0A\09return out;\0A}\0Ainline b3Quat b3QuatInverse(b3QuatConstArg q)\0A{\0A\09return (b3Quat)(-q.xyz, q.w);\0A}\0Ainline b3Quat b3QuatInvert(b3QuatConstArg q)\0A{\0A\09return (b3Quat)(-q.xyz, q.w);\0A}\0Ainline float4 b3QuatInvRotate(b3QuatConstArg q, b3QuatConstArg vec)\0A{\0A\09return b3QuatRotate( b3QuatInvert( q ), vec );\0A}\0Ainline b3Float4 b3TransformPoint(b3Float4ConstArg point, b3Float4ConstArg translation, b3QuatConstArg  orientation)\0A{\0A\09return b3QuatRotate( orientation, point ) + (translation);\0A}\0A\09\0A#endif \0A#endif //B3_QUAT_H\0A#ifdef __cplusplus\0A#else\0Atypedef struct\0A{\0A\09b3Float4 m_row[3];\0A}b3Mat3x3;\0A#define b3Mat3x3ConstArg const b3Mat3x3\0A#define b3GetRow(m,row) (m.m_row[row])\0Ainline b3Mat3x3 b3QuatGetRotationMatrix(b3Quat quat)\0A{\0A\09b3Float4 quat2 = (b3Float4)(quat.x*quat.x, quat.y*quat.y, quat.z*quat.z, 0.f);\0A\09b3Mat3x3 out;\0A\09out.m_row[0].x=1-2*quat2.y-2*quat2.z;\0A\09out.m_row[0].y=2*quat.x*quat.y-2*quat.w*quat.z;\0A\09out.m_row[0].z=2*quat.x*quat.z+2*quat.w*quat.y;\0A\09out.m_row[0].w = 0.f;\0A\09out.m_row[1].x=2*quat.x*quat.y+2*quat.w*quat.z;\0A\09out.m_row[1].y=1-2*quat2.x-2*quat2.z;\0A\09out.m_row[1].z=2*quat.y*quat.z-2*quat.w*quat.x;\0A\09out.m_row[1].w = 0.f;\0A\09out.m_row[2].x=2*quat.x*quat.z-2*quat.w*quat.y;\0A\09out.m_row[2].y=2*quat.y*quat.z+2*quat.w*quat.x;\0A\09out.m_row[2].z=1-2*quat2.x-2*quat2.y;\0A\09out.m_row[2].w = 0.f;\0A\09return out;\0A}\0Ainline b3Mat3x3 b3AbsoluteMat3x3(b3Mat3x3ConstArg matIn)\0A{\0A\09b3Mat3x3 out;\0A\09out.m_row[0] = fabs(matIn.m_row[0]);\0A\09out.m_row[1] = fabs(matIn.m_row[1]);\0A\09out.m_row[2] = fabs(matIn.m_row[2]);\0A\09return out;\0A}\0A__inline\0Ab3Mat3x3 mtZero();\0A__inline\0Ab3Mat3x3 mtIdentity();\0A__inline\0Ab3Mat3x3 mtTranspose(b3Mat3x3 m);\0A__inline\0Ab3Mat3x3 mtMul(b3Mat3x3 a, b3Mat3x3 b);\0A__inline\0Ab3Float4 mtMul1(b3Mat3x3 a, b3Float4 b);\0A__inline\0Ab3Float4 mtMul3(b3Float4 a, b3Mat3x3 b);\0A__inline\0Ab3Mat3x3 mtZero()\0A{\0A\09b3Mat3x3 m;\0A\09m.m_row[0] = (b3Float4)(0.f);\0A\09m.m_row[1] = (b3Float4)(0.f);\0A\09m.m_row[2] = (b3Float4)(0.f);\0A\09return m;\0A}\0A__inline\0Ab3Mat3x3 mtIdentity()\0A{\0A\09b3Mat3x3 m;\0A\09m.m_row[0] = (b3Float4)(1,0,0,0);\0A\09m.m_row[1] = (b3Float4)(0,1,0,0);\0A\09m.m_row[2] = (b3Float4)(0,0,1,0);\0A\09return m;\0A}\0A__inline\0Ab3Mat3x3 mtTranspose(b3Mat3x3 m)\0A{\0A\09b3Mat3x3 out;\0A\09out.m_row[0] = (b3Float4)(m.m_row[0].x, m.m_row[1].x, m.m_row[2].x, 0.f);\0A\09out.m_row[1] = (b3Float4)(m.m_row[0].y, m.m_row[1].y, m.m_row[2].y, 0.f);\0A\09out.m_row[2] = (b3Float4)(m.m_row[0].z, m.m_row[1].z, m.m_row[2].z, 0.f);\0A\09return out;\0A}\0A__inline\0Ab3Mat3x3 mtMul(b3Mat3x3 a, b3Mat3x3 b)\0A{\0A\09b3Mat3x3 transB;\0A\09transB = mtTranspose( b );\0A\09b3Mat3x3 ans;\0A\09//\09why this doesn't run when 0ing in the for{}\0A\09a.m_row[0].w = 0.f;\0A\09a.m_row[1].w = 0.f;\0A\09a.m_row[2].w = 0.f;\0A\09for(int i=0; i<3; i++)\0A\09{\0A//\09a.m_row[i].w = 0.f;\0A\09\09ans.m_row[i].x = b3Dot3F4(a.m_row[i],transB.m_row[0]);\0A\09\09ans.m_row[i].y = b3Dot3F4(a.m_row[i],transB.m_row[1]);\0A\09\09ans.m_row[i].z = b3Dot3F4(a.m_row[i],transB.m_row[2]);\0A\09\09ans.m_row[i].w = 0.f;\0A\09}\0A\09return ans;\0A}\0A__inline\0Ab3Float4 mtMul1(b3Mat3x3 a, b3Float4 b)\0A{\0A\09b3Float4 ans;\0A\09ans.x = b3Dot3F4( a.m_row[0], b );\0A\09ans.y = b3Dot3F4( a.m_row[1], b );\0A\09ans.z = b3Dot3F4( a.m_row[2], b );\0A\09ans.w = 0.f;\0A\09return ans;\0A}\0A__inline\0Ab3Float4 mtMul3(b3Float4 a, b3Mat3x3 b)\0A{\0A\09b3Float4 colx = b3MakeFloat4(b.m_row[0].x, b.m_row[1].x, b.m_row[2].x, 0);\0A\09b3Float4 coly = b3MakeFloat4(b.m_row[0].y, b.m_row[1].y, b.m_row[2].y, 0);\0A\09b3Float4 colz = b3MakeFloat4(b.m_row[0].z, b.m_row[1].z, b.m_row[2].z, 0);\0A\09b3Float4 ans;\0A\09ans.x = b3Dot3F4( a, colx );\0A\09ans.y = b3Dot3F4( a, coly );\0A\09ans.z = b3Dot3F4( a, colz );\0A\09return ans;\0A}\0A#endif\0A#endif //B3_MAT3x3_H\0Atypedef struct b3Aabb b3Aabb_t;\0Astruct b3Aabb\0A{\0A\09union\0A\09{\0A\09\09float m_min[4];\0A\09\09b3Float4 m_minVec;\0A\09\09int m_minIndices[4];\0A\09};\0A\09union\0A\09{\0A\09\09float\09m_max[4];\0A\09\09b3Float4 m_maxVec;\0A\09\09int m_signedMaxIndices[4];\0A\09};\0A};\0Ainline void b3TransformAabb2(b3Float4ConstArg localAabbMin,b3Float4ConstArg localAabbMax, float margin,\0A\09\09\09\09\09\09b3Float4ConstArg pos,\0A\09\09\09\09\09\09b3QuatConstArg orn,\0A\09\09\09\09\09\09b3Float4* aabbMinOut,b3Float4* aabbMaxOut)\0A{\0A\09\09b3Float4 localHalfExtents = 0.5f*(localAabbMax-localAabbMin);\0A\09\09localHalfExtents+=b3MakeFloat4(margin,margin,margin,0.f);\0A\09\09b3Float4 localCenter = 0.5f*(localAabbMax+localAabbMin);\0A\09\09b3Mat3x3 m;\0A\09\09m = b3QuatGetRotationMatrix(orn);\0A\09\09b3Mat3x3 abs_b = b3AbsoluteMat3x3(m);\0A\09\09b3Float4 center = b3TransformPoint(localCenter,pos,orn);\0A\09\09\0A\09\09b3Float4 extent = b3MakeFloat4(b3Dot3F4(localHalfExtents,b3GetRow(abs_b,0)),\0A\09\09\09\09\09\09\09\09\09\09 b3Dot3F4(localHalfExtents,b3GetRow(abs_b,1)),\0A\09\09\09\09\09\09\09\09\09\09 b3Dot3F4(localHalfExtents,b3GetRow(abs_b,2)),\0A\09\09\09\09\09\09\09\09\09\09 0.f);\0A\09\09*aabbMinOut = center-extent;\0A\09\09*aabbMaxOut = center+extent;\0A}\0A/// conservative test for overlap between two aabbs\0Ainline bool b3TestAabbAgainstAabb(b3Float4ConstArg aabbMin1,b3Float4ConstArg aabbMax1,\0A\09\09\09\09\09\09\09\09b3Float4ConstArg aabbMin2, b3Float4ConstArg aabbMax2)\0A{\0A\09bool overlap = true;\0A\09overlap = (aabbMin1.x > aabbMax2.x || aabbMax1.x < aabbMin2.x) ? false : overlap;\0A\09overlap = (aabbMin1.z > aabbMax2.z || aabbMax1.z < aabbMin2.z) ? false : overlap;\0A\09overlap = (aabbMin1.y > aabbMax2.y || aabbMax1.y < aabbMin2.y) ? false : overlap;\0A\09return overlap;\0A}\0A#endif //B3_AABB_H\0A/*\0ABullet Continuous Collision Detection and Physics Library\0ACopyright (c) 2003-2013 Erwin Coumans  http://bulletphysics.org\0AThis software is provided 'as-is', without any express or implied warranty.\0AIn no event will the authors be held liable for any damages arising from the use of this software.\0APermission is granted to anyone to use this software for any purpose,\0Aincluding commercial applications, and to alter it and redistribute it freely,\0Asubject to the following restrictions:\0A1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.\0A2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.\0A3. This notice may not be removed or altered from any source distribution.\0A*/\0A#ifndef B3_INT2_H\0A#define B3_INT2_H\0A#ifdef __cplusplus\0A#else\0A#define b3UnsignedInt2 uint2\0A#define b3Int2 int2\0A#define b3MakeInt2 (int2)\0A#endif //__cplusplus\0A#endif\0Atypedef struct\0A{\0A\09float4 m_plane;\0A\09int m_indexOffset;\0A\09int m_numIndices;\0A} btGpuFace;\0A#define make_float4 (float4)\0A__inline\0Afloat4 cross3(float4 a, float4 b)\0A{\0A\09return cross(a,b);\0A\09\0A//\09float4 a1 = make_float4(a.xyz,0.f);\0A//\09float4 b1 = make_float4(b.xyz,0.f);\0A//\09return cross(a1,b1);\0A//float4 c = make_float4(a.y*b.z - a.z*b.y,a.z*b.x - a.x*b.z,a.x*b.y - a.y*b.x,0.f);\0A\09\0A\09//\09float4 c = make_float4(a.y*b.z - a.z*b.y,1.f,a.x*b.y - a.y*b.x,0.f);\0A\09\0A\09//return c;\0A}\0A__inline\0Afloat dot3F4(float4 a, float4 b)\0A{\0A\09float4 a1 = make_float4(a.xyz,0.f);\0A\09float4 b1 = make_float4(b.xyz,0.f);\0A\09return dot(a1, b1);\0A}\0A__inline\0Afloat4 fastNormalize4(float4 v)\0A{\0A\09v = make_float4(v.xyz,0.f);\0A\09return fast_normalize(v);\0A}\0A///////////////////////////////////////\0A//\09Quaternion\0A///////////////////////////////////////\0Atypedef float4 Quaternion;\0A__inline\0AQuaternion qtMul(Quaternion a, Quaternion b);\0A__inline\0AQuaternion qtNormalize(Quaternion in);\0A__inline\0Afloat4 qtRotate(Quaternion q, float4 vec);\0A__inline\0AQuaternion qtInvert(Quaternion q);\0A__inline\0AQuaternion qtMul(Quaternion a, Quaternion b)\0A{\0A\09Quaternion ans;\0A\09ans = cross3( a, b );\0A\09ans += a.w*b+b.w*a;\0A//\09ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);\0A\09ans.w = a.w*b.w - dot3F4(a, b);\0A\09return ans;\0A}\0A__inline\0AQuaternion qtNormalize(Quaternion in)\0A{\0A\09return fastNormalize4(in);\0A//\09in /= length( in );\0A//\09return in;\0A}\0A__inline\0Afloat4 qtRotate(Quaternion q, float4 vec)\0A{\0A\09Quaternion qInv = qtInvert( q );\0A\09float4 vcpy = vec;\0A\09vcpy.w = 0.f;\0A\09float4 out = qtMul(qtMul(q,vcpy),qInv);\0A\09return out;\0A}\0A__inline\0AQuaternion qtInvert(Quaternion q)\0A{\0A\09return (Quaternion)(-q.xyz, q.w);\0A}\0A__inline\0Afloat4 qtInvRotate(const Quaternion q, float4 vec)\0A{\0A\09return qtRotate( qtInvert( q ), vec );\0A}\0A__inline\0Afloat4 transform(const float4* p, const float4* translation, const Quaternion* orientation)\0A{\0A\09return qtRotate( *orientation, *p ) + (*translation);\0A}\0A__inline\0Afloat4 normalize3(const float4 a)\0A{\0A\09float4 n = make_float4(a.x, a.y, a.z, 0.f);\0A\09return fastNormalize4( n );\0A}\0Ainline void projectLocal(const ConvexPolyhedronCL* hull,  const float4 pos, const float4 orn, \0Aconst float4* dir, const float4* vertices, float* min, float* max)\0A{\0A\09min[0] = FLT_MAX;\0A\09max[0] = -FLT_MAX;\0A\09int numVerts = hull->m_numVertices;\0A\09const float4 localDir = qtInvRotate(orn,*dir);\0A\09float offset = dot(pos,*dir);\0A\09for(int i=0;i<numVerts;i++)\0A\09{\0A\09\09float dp = dot(vertices[hull->m_vertexOffset+i],localDir);\0A\09\09if(dp < min[0])\09\0A\09\09\09min[0] = dp;\0A\09\09if(dp > max[0])\09\0A\09\09\09max[0] = dp;\0A\09}\0A\09if(min[0]>max[0])\0A\09{\0A\09\09float tmp = min[0];\0A\09\09min[0] = max[0];\0A\09\09max[0] = tmp;\0A\09}\0A\09min[0] += offset;\0A\09max[0] += offset;\0A}\0Ainline void project(__global const ConvexPolyhedronCL* hull,  const float4 pos, const float4 orn, \0Aconst float4* dir, __global const float4* vertices, float* min, float* max)\0A{\0A\09min[0] = FLT_MAX;\0A\09max[0] = -FLT_MAX;\0A\09int numVerts = hull->m_numVertices;\0A\09const float4 localDir = qtInvRotate(orn,*dir);\0A\09float offset = dot(pos,*dir);\0A\09for(int i=0;i<numVerts;i++)\0A\09{\0A\09\09float dp = dot(vertices[hull->m_vertexOffset+i],localDir);\0A\09\09if(dp < min[0])\09\0A\09\09\09min[0] = dp;\0A\09\09if(dp > max[0])\09\0A\09\09\09max[0] = dp;\0A\09}\0A\09if(min[0]>max[0])\0A\09{\0A\09\09float tmp = min[0];\0A\09\09min[0] = max[0];\0A\09\09max[0] = tmp;\0A\09}\0A\09min[0] += offset;\0A\09max[0] += offset;\0A}\0Ainline bool TestSepAxisLocalA(const ConvexPolyhedronCL* hullA, __global const ConvexPolyhedronCL* hullB, \0A\09const float4 posA,const float4 ornA,\0A\09const float4 posB,const float4 ornB,\0A\09float4* sep_axis, const float4* verticesA, __global const float4* verticesB,float* depth)\0A{\0A\09float Min0,Max0;\0A\09float Min1,Max1;\0A\09projectLocal(hullA,posA,ornA,sep_axis,verticesA, &Min0, &Max0);\0A\09project(hullB,posB,ornB, sep_axis,verticesB, &Min1, &Max1);\0A\09if(Max0<Min1 || Max1<Min0)\0A\09\09return false;\0A\09float d0 = Max0 - Min1;\0A\09float d1 = Max1 - Min0;\0A\09*depth = d0<d1 ? d0:d1;\0A\09return true;\0A}\0Ainline bool IsAlmostZero(const float4 v)\0A{\0A\09if(fabs(v.x)>1e-6f || fabs(v.y)>1e-6f || fabs(v.z)>1e-6f)\0A\09\09return false;\0A\09return true;\0A}\0Abool findSeparatingAxisLocalA(\09const ConvexPolyhedronCL* hullA, __global const ConvexPolyhedronCL* hullB, \0A\09const float4 posA1,\0A\09const float4 ornA,\0A\09const float4 posB1,\0A\09const float4 ornB,\0A\09const float4 DeltaC2,\0A\09\0A\09const float4* verticesA, \0A\09const float4* uniqueEdgesA, \0A\09const btGpuFace* facesA,\0A\09const int*  indicesA,\0A\09__global const float4* verticesB, \0A\09__global const float4* uniqueEdgesB, \0A\09__global const btGpuFace* facesB,\0A\09__global const int*  indicesB,\0A\09float4* sep,\0A\09float* dmin)\0A{\0A\09\0A\09float4 posA = posA1;\0A\09posA.w = 0.f;\0A\09float4 posB = posB1;\0A\09posB.w = 0.f;\0A\09int curPlaneTests=0;\0A\09{\0A\09\09int numFacesA = hullA->m_numFaces;\0A\09\09// Test normals from hullA\0A\09\09for(int i=0;i<numFacesA;i++)\0A\09\09{\0A\09\09\09const float4 normal = facesA[hullA->m_faceOffset+i].m_plane;\0A\09\09\09float4 faceANormalWS = qtRotate(ornA,normal);\0A\09\09\09if (dot3F4(DeltaC2,faceANormalWS)<0)\0A\09\09\09\09faceANormalWS*=-1.f;\0A\09\09\09curPlaneTests++;\0A\09\09\09float d;\0A\09\09\09if(!TestSepAxisLocalA( hullA, hullB, posA,ornA,posB,ornB,&faceANormalWS, verticesA, verticesB,&d))\0A\09\09\09\09return false;\0A\09\09\09if(d<*dmin)\0A\09\09\09{\0A\09\09\09\09*dmin = d;\0A\09\09\09\09*sep = faceANormalWS;\0A\09\09\09}\0A\09\09}\0A\09}\0A\09if((dot3F4(-DeltaC2,*sep))>0.0f)\0A\09{\0A\09\09*sep = -(*sep);\0A\09}\0A\09return true;\0A}\0Abool findSeparatingAxisLocalB(\09__global const ConvexPolyhedronCL* hullA,  const ConvexPolyhedronCL* hullB, \0A\09const float4 posA1,\0A\09const float4 ornA,\0A\09const float4 posB1,\0A\09const float4 ornB,\0A\09const float4 DeltaC2,\0A\09__global const float4* verticesA, \0A\09__global const float4* uniqueEdgesA, \0A\09__global const btGpuFace* facesA,\0A\09__global const int*  indicesA,\0A\09const float4* verticesB,\0A\09const float4* uniqueEdgesB, \0A\09const btGpuFace* facesB,\0A\09const int*  indicesB,\0A\09float4* sep,\0A\09float* dmin)\0A{\0A\09float4 posA = posA1;\0A\09posA.w = 0.f;\0A\09float4 posB = posB1;\0A\09posB.w = 0.f;\0A\09int curPlaneTests=0;\0A\09{\0A\09\09int numFacesA = hullA->m_numFaces;\0A\09\09// Test normals from hullA\0A\09\09for(int i=0;i<numFacesA;i++)\0A\09\09{\0A\09\09\09const float4 normal = facesA[hullA->m_faceOffset+i].m_plane;\0A\09\09\09float4 faceANormalWS = qtRotate(ornA,normal);\0A\09\09\09if (dot3F4(DeltaC2,faceANormalWS)<0)\0A\09\09\09\09faceANormalWS *= -1.f;\0A\09\09\09curPlaneTests++;\0A\09\09\09float d;\0A\09\09\09if(!TestSepAxisLocalA( hullB, hullA, posB,ornB,posA,ornA, &faceANormalWS, verticesB,verticesA, &d))\0A\09\09\09\09return false;\0A\09\09\09if(d<*dmin)\0A\09\09\09{\0A\09\09\09\09*dmin = d;\0A\09\09\09\09*sep = faceANormalWS;\0A\09\09\09}\0A\09\09}\0A\09}\0A\09if((dot3F4(-DeltaC2,*sep))>0.0f)\0A\09{\0A\09\09*sep = -(*sep);\0A\09}\0A\09return true;\0A}\0Abool findSeparatingAxisEdgeEdgeLocalA(\09const ConvexPolyhedronCL* hullA, __global const ConvexPolyhedronCL* hullB, \0A\09const float4 posA1,\0A\09const float4 ornA,\0A\09const float4 posB1,\0A\09const float4 ornB,\0A\09const float4 DeltaC2,\0A\09const float4* verticesA, \0A\09const float4* uniqueEdgesA, \0A\09const btGpuFace* facesA,\0A\09const int*  indicesA,\0A\09__global const float4* verticesB, \0A\09__global const float4* uniqueEdgesB, \0A\09__global const btGpuFace* facesB,\0A\09__global const int*  indicesB,\0A\09\09float4* sep,\0A\09float* dmin)\0A{\0A\09float4 posA = posA1;\0A\09posA.w = 0.f;\0A\09float4 posB = posB1;\0A\09posB.w = 0.f;\0A\09int curPlaneTests=0;\0A\09int curEdgeEdge = 0;\0A\09// Test edges\0A\09for(int e0=0;e0<hullA->m_numUniqueEdges;e0++)\0A\09{\0A\09\09const float4 edge0 = uniqueEdgesA[hullA->m_uniqueEdgesOffset+e0];\0A\09\09float4 edge0World = qtRotate(ornA,edge0);\0A\09\09for(int e1=0;e1<hullB->m_numUniqueEdges;e1++)\0A\09\09{\0A\09\09\09const float4 edge1 = uniqueEdgesB[hullB->m_uniqueEdgesOffset+e1];\0A\09\09\09float4 edge1World = qtRotate(ornB,edge1);\0A\09\09\09float4 crossje = cross3(edge0World,edge1World);\0A\09\09\09curEdgeEdge++;\0A\09\09\09if(!IsAlmostZero(crossje))\0A\09\09\09{\0A\09\09\09\09crossje = normalize3(crossje);\0A\09\09\09\09if (dot3F4(DeltaC2,crossje)<0)\0A\09\09\09\09\09crossje *= -1.f;\0A\09\09\09\09float dist;\0A\09\09\09\09bool result = true;\0A\09\09\09\09{\0A\09\09\09\09\09float Min0,Max0;\0A\09\09\09\09\09float Min1,Max1;\0A\09\09\09\09\09projectLocal(hullA,posA,ornA,&crossje,verticesA, &Min0, &Max0);\0A\09\09\09\09\09project(hullB,posB,ornB,&crossje,verticesB, &Min1, &Max1);\0A\09\09\09\09\0A\09\09\09\09\09if(Max0<Min1 || Max1<Min0)\0A\09\09\09\09\09\09result = false;\0A\09\09\09\09\0A\09\09\09\09\09float d0 = Max0 - Min1;\0A\09\09\09\09\09float d1 = Max1 - Min0;\0A\09\09\09\09\09dist = d0<d1 ? d0:d1;\0A\09\09\09\09\09result = true;\0A\09\09\09\09}\0A\09\09\09\09\0A\09\09\09\09if(dist<*dmin)\0A\09\09\09\09{\0A\09\09\09\09\09*dmin = dist;\0A\09\09\09\09\09*sep = crossje;\0A\09\09\09\09}\0A\09\09\09}\0A\09\09}\0A\09}\0A\09\0A\09if((dot3F4(-DeltaC2,*sep))>0.0f)\0A\09{\0A\09\09*sep = -(*sep);\0A\09}\0A\09return true;\0A}\0Ainline int\09findClippingFaces(const float4 separatingNormal,\0A                      const ConvexPolyhedronCL* hullA, \0A\09\09\09\09\09  __global const ConvexPolyhedronCL* hullB,\0A                      const float4 posA, const Quaternion ornA,const float4 posB, const Quaternion ornB,\0A                       __global float4* worldVertsA1,\0A                      __global float4* worldNormalsA1,\0A                      __global float4* worldVertsB1,\0A                      int capacityWorldVerts,\0A                      const float minDist, float maxDist,\0A\09\09\09\09\09  const float4* verticesA,\0A                      const btGpuFace* facesA,\0A                      const int* indicesA,\0A\09\09\09\09\09  __global const float4* verticesB,\0A                      __global const btGpuFace* facesB,\0A                      __global const int* indicesB,\0A                      __global int4* clippingFaces, int pairIndex)\0A{\0A\09int numContactsOut = 0;\0A\09int numWorldVertsB1= 0;\0A    \0A    \0A\09int closestFaceB=0;\0A\09float dmax = -FLT_MAX;\0A    \0A\09{\0A\09\09for(int face=0;face<hullB->m_numFaces;face++)\0A\09\09{\0A\09\09\09const float4 Normal = make_float4(facesB[hullB->m_faceOffset+face].m_plane.x,\0A                                              facesB[hullB->m_faceOffset+face].m_plane.y, facesB[hullB->m_faceOffset+face].m_plane.z,0.f);\0A\09\09\09const float4 WorldNormal = qtRotate(ornB, Normal);\0A\09\09\09float d = dot3F4(WorldNormal,separatingNormal);\0A\09\09\09if (d > dmax)\0A\09\09\09{\0A\09\09\09\09dmax = d;\0A\09\09\09\09closestFaceB = face;\0A\09\09\09}\0A\09\09}\0A\09}\0A    \0A\09{\0A\09\09const btGpuFace polyB = facesB[hullB->m_faceOffset+closestFaceB];\0A\09\09int numVertices = polyB.m_numIndices;\0A        if (numVertices>capacityWorldVerts)\0A            numVertices = capacityWorldVerts;\0A        if (numVertices<0)\0A            numVertices = 0;\0A        \0A\09\09for(int e0=0;e0<numVertices;e0++)\0A\09\09{\0A            if (e0<capacityWorldVerts)\0A            {\0A                const float4 b = verticesB[hullB->m_vertexOffset+indicesB[polyB.m_indexOffset+e0]];\0A                worldVertsB1[pairIndex*capacityWorldVerts+numWorldVertsB1++] = transform(&b,&posB,&ornB);\0A            }\0A\09\09}\0A\09}\0A    \0A    int closestFaceA=0;\0A\09{\0A\09\09float dmin = FLT_MAX;\0A\09\09for(int face=0;face<hullA->m_numFaces;face++)\0A\09\09{\0A\09\09\09const float4 Normal = make_float4(\0A                                              facesA[hullA->m_faceOffset+face].m_plane.x,\0A                                              facesA[hullA->m_faceOffset+face].m_plane.y,\0A                                              facesA[hullA->m_faceOffset+face].m_plane.z,\0A                                              0.f);\0A\09\09\09const float4 faceANormalWS = qtRotate(ornA,Normal);\0A            \0A\09\09\09float d = dot3F4(faceANormalWS,separatingNormal);\0A\09\09\09if (d < dmin)\0A\09\09\09{\0A\09\09\09\09dmin = d;\0A\09\09\09\09closestFaceA = face;\0A                worldNormalsA1[pairIndex] = faceANormalWS;\0A\09\09\09}\0A\09\09}\0A\09}\0A    \0A    int numVerticesA = facesA[hullA->m_faceOffset+closestFaceA].m_numIndices;\0A    if (numVerticesA>capacityWorldVerts)\0A       numVerticesA = capacityWorldVerts;\0A    if (numVerticesA<0)\0A        numVerticesA=0;\0A    \0A\09for(int e0=0;e0<numVerticesA;e0++)\0A\09{\0A        if (e0<capacityWorldVerts)\0A        {\0A            const float4 a = verticesA[hullA->m_vertexOffset+indicesA[facesA[hullA->m_faceOffset+closestFaceA].m_indexOffset+e0]];\0A            worldVertsA1[pairIndex*capacityWorldVerts+e0] = transform(&a, &posA,&ornA);\0A        }\0A    }\0A    \0A    clippingFaces[pairIndex].x = closestFaceA;\0A    clippingFaces[pairIndex].y = closestFaceB;\0A    clippingFaces[pairIndex].z = numVerticesA;\0A    clippingFaces[pairIndex].w = numWorldVertsB1;\0A    \0A    \0A\09return numContactsOut;\0A}\0A// work-in-progress\0A__kernel void   findConcaveSeparatingAxisVertexFaceKernel( __global int4* concavePairs,\0A                                                __global const BodyData* rigidBodies,\0A                                                __global const btCollidableGpu* collidables,\0A                                                __global const ConvexPolyhedronCL* convexShapes,\0A                                                __global const float4* vertices,\0A                                                __global const float4* uniqueEdges,\0A                                                __global const btGpuFace* faces,\0A                                                __global const int* indices,\0A                                                __global const btGpuChildShape* gpuChildShapes,\0A                                                __global btAabbCL* aabbs,\0A                                                __global float4* concaveSeparatingNormalsOut,\0A                                                __global int* concaveHasSeparatingNormals,\0A                                                __global int4* clippingFacesOut,\0A                                                __global float4* worldVertsA1GPU,\0A                                                __global float4*  worldNormalsAGPU,\0A                                                __global float4* worldVertsB1GPU,\0A                                                __global float* dmins,\0A                                                int vertexFaceCapacity,\0A                                                int numConcavePairs\0A                                                )\0A{\0A    \0A\09int i = get_global_id(0);\0A\09if (i>=numConcavePairs)\0A\09\09return;\0A    \0A\09concaveHasSeparatingNormals[i] = 0;\0A    \0A\09int pairIdx = i;\0A    \0A\09int bodyIndexA = concavePairs[i].x;\0A\09int bodyIndexB = concavePairs[i].y;\0A    \0A\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A    \0A\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A    \0A\09if (collidables[collidableIndexB].m_shapeType!=SHAPE_CONVEX_HULL&&\0A\09\09collidables[collidableIndexB].m_shapeType!=SHAPE_COMPOUND_OF_CONVEX_HULLS)\0A\09{\0A\09\09concavePairs[pairIdx].w = -1;\0A\09\09return;\0A\09}\0A    \0A    \0A    \0A\09int numFacesA = convexShapes[shapeIndexA].m_numFaces;\0A\09int numActualConcaveConvexTests = 0;\0A\09\0A\09int f = concavePairs[i].z;\0A\09\0A\09bool overlap = false;\0A\09\0A\09ConvexPolyhedronCL convexPolyhedronA;\0A    \0A\09//add 3 vertices of the triangle\0A\09convexPolyhedronA.m_numVertices = 3;\0A\09convexPolyhedronA.m_vertexOffset = 0;\0A\09float4\09localCenter = make_float4(0.f,0.f,0.f,0.f);\0A    \0A\09btGpuFace face = faces[convexShapes[shapeIndexA].m_faceOffset+f];\0A\09float4 triMinAabb, triMaxAabb;\0A\09btAabbCL triAabb;\0A\09triAabb.m_min = make_float4(1e30f,1e30f,1e30f,0.f);\0A\09triAabb.m_max = make_float4(-1e30f,-1e30f,-1e30f,0.f);\0A\09\0A\09float4 verticesA[3];\0A\09for (int i=0;i<3;i++)\0A\09{\0A\09\09int index = indices[face.m_indexOffset+i];\0A\09\09float4 vert = vertices[convexShapes[shapeIndexA].m_vertexOffset+index];\0A\09\09verticesA[i] = vert;\0A\09\09localCenter += vert;\0A        \0A\09\09triAabb.m_min = min(triAabb.m_min,vert);\0A\09\09triAabb.m_max = max(triAabb.m_max,vert);\0A        \0A\09}\0A    \0A\09overlap = true;\0A\09overlap = (triAabb.m_min.x > aabbs[bodyIndexB].m_max.x || triAabb.m_max.x < aabbs[bodyIndexB].m_min.x) ? false : overlap;\0A\09overlap = (triAabb.m_min.z > aabbs[bodyIndexB].m_max.z || triAabb.m_max.z < aabbs[bodyIndexB].m_min.z) ? false : overlap;\0A\09overlap = (triAabb.m_min.y > aabbs[bodyIndexB].m_max.y || triAabb.m_max.y < aabbs[bodyIndexB].m_min.y) ? false : overlap;\0A    \0A\09if (overlap)\0A\09{\0A\09\09float dmin = FLT_MAX;\0A\09\09int hasSeparatingAxis=5;\0A\09\09float4 sepAxis=make_float4(1,2,3,4);\0A        \0A\09\09int localCC=0;\0A\09\09numActualConcaveConvexTests++;\0A        \0A\09\09//a triangle has 3 unique edges\0A\09\09convexPolyhedronA.m_numUniqueEdges = 3;\0A\09\09convexPolyhedronA.m_uniqueEdgesOffset = 0;\0A\09\09float4 uniqueEdgesA[3];\0A\09\09\0A\09\09uniqueEdgesA[0] = (verticesA[1]-verticesA[0]);\0A\09\09uniqueEdgesA[1] = (verticesA[2]-verticesA[1]);\0A\09\09uniqueEdgesA[2] = (verticesA[0]-verticesA[2]);\0A        \0A        \0A\09\09convexPolyhedronA.m_faceOffset = 0;\0A        \0A\09\09float4 normal = make_float4(face.m_plane.x,face.m_plane.y,face.m_plane.z,0.f);\0A        \0A\09\09btGpuFace facesA[TRIANGLE_NUM_CONVEX_FACES];\0A\09\09int indicesA[3+3+2+2+2];\0A\09\09int curUsedIndices=0;\0A\09\09int fidx=0;\0A        \0A\09\09//front size of triangle\0A\09\09{\0A\09\09\09facesA[fidx].m_indexOffset=curUsedIndices;\0A\09\09\09indicesA[0] = 0;\0A\09\09\09indicesA[1] = 1;\0A\09\09\09indicesA[2] = 2;\0A\09\09\09curUsedIndices+=3;\0A\09\09\09float c = face.m_plane.w;\0A\09\09\09facesA[fidx].m_plane.x = normal.x;\0A\09\09\09facesA[fidx].m_plane.y = normal.y;\0A\09\09\09facesA[fidx].m_plane.z = normal.z;\0A\09\09\09facesA[fidx].m_plane.w = c;\0A\09\09\09facesA[fidx].m_numIndices=3;\0A\09\09}\0A\09\09fidx++;\0A\09\09//back size of triangle\0A\09\09{\0A\09\09\09facesA[fidx].m_indexOffset=curUsedIndices;\0A\09\09\09indicesA[3]=2;\0A\09\09\09indicesA[4]=1;\0A\09\09\09indicesA[5]=0;\0A\09\09\09curUsedIndices+=3;\0A\09\09\09float c = dot(normal,verticesA[0]);\0A\09\09\09float c1 = -face.m_plane.w;\0A\09\09\09facesA[fidx].m_plane.x = -normal.x;\0A\09\09\09facesA[fidx].m_plane.y = -normal.y;\0A\09\09\09facesA[fidx].m_plane.z = -normal.z;\0A\09\09\09facesA[fidx].m_plane.w = c;\0A\09\09\09facesA[fidx].m_numIndices=3;\0A\09\09}\0A\09\09fidx++;\0A        \0A\09\09bool addEdgePlanes = true;\0A\09\09if (addEdgePlanes)\0A\09\09{\0A\09\09\09int numVertices=3;\0A\09\09\09int prevVertex = numVertices-1;\0A\09\09\09for (int i=0;i<numVertices;i++)\0A\09\09\09{\0A\09\09\09\09float4 v0 = verticesA[i];\0A\09\09\09\09float4 v1 = verticesA[prevVertex];\0A                \0A\09\09\09\09float4 edgeNormal = normalize(cross(normal,v1-v0));\0A\09\09\09\09float c = -dot(edgeNormal,v0);\0A                \0A\09\09\09\09facesA[fidx].m_numIndices = 2;\0A\09\09\09\09facesA[fidx].m_indexOffset=curUsedIndices;\0A\09\09\09\09indicesA[curUsedIndices++]=i;\0A\09\09\09\09indicesA[curUsedIndices++]=prevVertex;\0A                \0A\09\09\09\09facesA[fidx].m_plane.x = edgeNormal.x;\0A\09\09\09\09facesA[fidx].m_plane.y = edgeNormal.y;\0A\09\09\09\09facesA[fidx].m_plane.z = edgeNormal.z;\0A\09\09\09\09facesA[fidx].m_plane.w = c;\0A\09\09\09\09fidx++;\0A\09\09\09\09prevVertex = i;\0A\09\09\09}\0A\09\09}\0A\09\09convexPolyhedronA.m_numFaces = TRIANGLE_NUM_CONVEX_FACES;\0A\09\09convexPolyhedronA.m_localCenter = localCenter*(1.f/3.f);\0A        \0A        \0A\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09posA.w = 0.f;\0A\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09posB.w = 0.f;\0A        \0A\09\09float4 ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09float4 ornB =rigidBodies[bodyIndexB].m_quat;\0A        \0A\09\09\0A        \0A        \0A\09\09///////////////////\0A\09\09///compound shape support\0A        \0A\09\09if (collidables[collidableIndexB].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS)\0A\09\09{\0A\09\09\09int compoundChild = concavePairs[pairIdx].w;\0A\09\09\09int childShapeIndexB = compoundChild;//collidables[collidableIndexB].m_shapeIndex+compoundChild;\0A\09\09\09int childColIndexB = gpuChildShapes[childShapeIndexB].m_shapeIndex;\0A\09\09\09float4 childPosB = gpuChildShapes[childShapeIndexB].m_childPosition;\0A\09\09\09float4 childOrnB = gpuChildShapes[childShapeIndexB].m_childOrientation;\0A\09\09\09float4 newPosB = transform(&childPosB,&posB,&ornB);\0A\09\09\09float4 newOrnB = qtMul(ornB,childOrnB);\0A\09\09\09posB = newPosB;\0A\09\09\09ornB = newOrnB;\0A\09\09\09shapeIndexB = collidables[childColIndexB].m_shapeIndex;\0A\09\09}\0A\09\09//////////////////\0A        \0A\09\09float4 c0local = convexPolyhedronA.m_localCenter;\0A\09\09float4 c0 = transform(&c0local, &posA, &ornA);\0A\09\09float4 c1local = convexShapes[shapeIndexB].m_localCenter;\0A\09\09float4 c1 = transform(&c1local,&posB,&ornB);\0A\09\09const float4 DeltaC2 = c0 - c1;\0A        \0A        \0A\09\09bool sepA = findSeparatingAxisLocalA(\09&convexPolyhedronA, &convexShapes[shapeIndexB],\0A                                             posA,ornA,\0A                                             posB,ornB,\0A                                             DeltaC2,\0A                                             verticesA,uniqueEdgesA,facesA,indicesA,\0A                                             vertices,uniqueEdges,faces,indices,\0A                                             &sepAxis,&dmin);\0A\09\09hasSeparatingAxis = 4;\0A\09\09if (!sepA)\0A\09\09{\0A\09\09\09hasSeparatingAxis = 0;\0A\09\09} else\0A\09\09{\0A\09\09\09bool sepB = findSeparatingAxisLocalB(\09&convexShapes[shapeIndexB],&convexPolyhedronA,\0A                                                 posB,ornB,\0A                                                 posA,ornA,\0A                                                 DeltaC2,\0A                                                 vertices,uniqueEdges,faces,indices,\0A                                                 verticesA,uniqueEdgesA,facesA,indicesA,\0A                                                 &sepAxis,&dmin);\0A            \0A\09\09\09if (!sepB)\0A\09\09\09{\0A\09\09\09\09hasSeparatingAxis = 0;\0A\09\09\09} else\0A\09\09\09{\0A\09\09\09\09hasSeparatingAxis = 1;\0A\09\09\09}\0A\09\09}\09\0A\09\09\0A\09\09if (hasSeparatingAxis)\0A\09\09{\0A            dmins[i] = dmin;\0A\09\09\09concaveSeparatingNormalsOut[pairIdx]=sepAxis;\0A\09\09\09concaveHasSeparatingNormals[i]=1;\0A            \0A\09\09} else\0A\09\09{\09\0A\09\09\09//mark this pair as in-active\0A\09\09\09concavePairs[pairIdx].w = -1;\0A\09\09}\0A\09}\0A\09else\0A\09{\09\0A\09\09//mark this pair as in-active\0A\09\09concavePairs[pairIdx].w = -1;\0A\09}\0A}\0A// work-in-progress\0A__kernel void   findConcaveSeparatingAxisEdgeEdgeKernel( __global int4* concavePairs,\0A                                                          __global const BodyData* rigidBodies,\0A                                                          __global const btCollidableGpu* collidables,\0A                                                          __global const ConvexPolyhedronCL* convexShapes,\0A                                                          __global const float4* vertices,\0A                                                          __global const float4* uniqueEdges,\0A                                                          __global const btGpuFace* faces,\0A                                                          __global const int* indices,\0A                                                          __global const btGpuChildShape* gpuChildShapes,\0A                                                          __global btAabbCL* aabbs,\0A                                                          __global float4* concaveSeparatingNormalsOut,\0A                                                          __global int* concaveHasSeparatingNormals,\0A                                                          __global int4* clippingFacesOut,\0A                                                          __global float4* worldVertsA1GPU,\0A                                                          __global float4*  worldNormalsAGPU,\0A                                                          __global float4* worldVertsB1GPU,\0A                                                          __global float* dmins,\0A                                                          int vertexFaceCapacity,\0A                                                          int numConcavePairs\0A                                                          )\0A{\0A    \0A\09int i = get_global_id(0);\0A\09if (i>=numConcavePairs)\0A\09\09return;\0A    \0A\09if (!concaveHasSeparatingNormals[i])\0A        return;\0A    \0A\09int pairIdx = i;\0A    \0A\09int bodyIndexA = concavePairs[i].x;\0A\09int bodyIndexB = concavePairs[i].y;\0A    \0A\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A    \0A\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A    \0A    \0A\09int numFacesA = convexShapes[shapeIndexA].m_numFaces;\0A\09int numActualConcaveConvexTests = 0;\0A\09\0A\09int f = concavePairs[i].z;\0A\09\0A\09bool overlap = false;\0A\09\0A\09ConvexPolyhedronCL convexPolyhedronA;\0A    \0A\09//add 3 vertices of the triangle\0A\09convexPolyhedronA.m_numVertices = 3;\0A\09convexPolyhedronA.m_vertexOffset = 0;\0A\09float4\09localCenter = make_float4(0.f,0.f,0.f,0.f);\0A    \0A\09btGpuFace face = faces[convexShapes[shapeIndexA].m_faceOffset+f];\0A\09float4 triMinAabb, triMaxAabb;\0A\09btAabbCL triAabb;\0A\09triAabb.m_min = make_float4(1e30f,1e30f,1e30f,0.f);\0A\09triAabb.m_max = make_float4(-1e30f,-1e30f,-1e30f,0.f);\0A\09\0A\09float4 verticesA[3];\0A\09for (int i=0;i<3;i++)\0A\09{\0A\09\09int index = indices[face.m_indexOffset+i];\0A\09\09float4 vert = vertices[convexShapes[shapeIndexA].m_vertexOffset+index];\0A\09\09verticesA[i] = vert;\0A\09\09localCenter += vert;\0A        \0A\09\09triAabb.m_min = min(triAabb.m_min,vert);\0A\09\09triAabb.m_max = max(triAabb.m_max,vert);\0A        \0A\09}\0A    \0A\09overlap = true;\0A\09overlap = (triAabb.m_min.x > aabbs[bodyIndexB].m_max.x || triAabb.m_max.x < aabbs[bodyIndexB].m_min.x) ? false : overlap;\0A\09overlap = (triAabb.m_min.z > aabbs[bodyIndexB].m_max.z || triAabb.m_max.z < aabbs[bodyIndexB].m_min.z) ? false : overlap;\0A\09overlap = (triAabb.m_min.y > aabbs[bodyIndexB].m_max.y || triAabb.m_max.y < aabbs[bodyIndexB].m_min.y) ? false : overlap;\0A    \0A\09if (overlap)\0A\09{\0A\09\09float dmin = dmins[i];\0A\09\09int hasSeparatingAxis=5;\0A\09\09float4 sepAxis=make_float4(1,2,3,4);\0A        sepAxis = concaveSeparatingNormalsOut[pairIdx];\0A        \0A\09\09int localCC=0;\0A\09\09numActualConcaveConvexTests++;\0A        \0A\09\09//a triangle has 3 unique edges\0A\09\09convexPolyhedronA.m_numUniqueEdges = 3;\0A\09\09convexPolyhedronA.m_uniqueEdgesOffset = 0;\0A\09\09float4 uniqueEdgesA[3];\0A\09\09\0A\09\09uniqueEdgesA[0] = (verticesA[1]-verticesA[0]);\0A\09\09uniqueEdgesA[1] = (verticesA[2]-verticesA[1]);\0A\09\09uniqueEdgesA[2] = (verticesA[0]-verticesA[2]);\0A        \0A        \0A\09\09convexPolyhedronA.m_faceOffset = 0;\0A        \0A\09\09float4 normal = make_float4(face.m_plane.x,face.m_plane.y,face.m_plane.z,0.f);\0A        \0A\09\09btGpuFace facesA[TRIANGLE_NUM_CONVEX_FACES];\0A\09\09int indicesA[3+3+2+2+2];\0A\09\09int curUsedIndices=0;\0A\09\09int fidx=0;\0A        \0A\09\09//front size of triangle\0A\09\09{\0A\09\09\09facesA[fidx].m_indexOffset=curUsedIndices;\0A\09\09\09indicesA[0] = 0;\0A\09\09\09indicesA[1] = 1;\0A\09\09\09indicesA[2] = 2;\0A\09\09\09curUsedIndices+=3;\0A\09\09\09float c = face.m_plane.w;\0A\09\09\09facesA[fidx].m_plane.x = normal.x;\0A\09\09\09facesA[fidx].m_plane.y = normal.y;\0A\09\09\09facesA[fidx].m_plane.z = normal.z;\0A\09\09\09facesA[fidx].m_plane.w = c;\0A\09\09\09facesA[fidx].m_numIndices=3;\0A\09\09}\0A\09\09fidx++;\0A\09\09//back size of triangle\0A\09\09{\0A\09\09\09facesA[fidx].m_indexOffset=curUsedIndices;\0A\09\09\09indicesA[3]=2;\0A\09\09\09indicesA[4]=1;\0A\09\09\09indicesA[5]=0;\0A\09\09\09curUsedIndices+=3;\0A\09\09\09float c = dot(normal,verticesA[0]);\0A\09\09\09float c1 = -face.m_plane.w;\0A\09\09\09facesA[fidx].m_plane.x = -normal.x;\0A\09\09\09facesA[fidx].m_plane.y = -normal.y;\0A\09\09\09facesA[fidx].m_plane.z = -normal.z;\0A\09\09\09facesA[fidx].m_plane.w = c;\0A\09\09\09facesA[fidx].m_numIndices=3;\0A\09\09}\0A\09\09fidx++;\0A        \0A\09\09bool addEdgePlanes = true;\0A\09\09if (addEdgePlanes)\0A\09\09{\0A\09\09\09int numVertices=3;\0A\09\09\09int prevVertex = numVertices-1;\0A\09\09\09for (int i=0;i<numVertices;i++)\0A\09\09\09{\0A\09\09\09\09float4 v0 = verticesA[i];\0A\09\09\09\09float4 v1 = verticesA[prevVertex];\0A                \0A\09\09\09\09float4 edgeNormal = normalize(cross(normal,v1-v0));\0A\09\09\09\09float c = -dot(edgeNormal,v0);\0A                \0A\09\09\09\09facesA[fidx].m_numIndices = 2;\0A\09\09\09\09facesA[fidx].m_indexOffset=curUsedIndices;\0A\09\09\09\09indicesA[curUsedIndices++]=i;\0A\09\09\09\09indicesA[curUsedIndices++]=prevVertex;\0A                \0A\09\09\09\09facesA[fidx].m_plane.x = edgeNormal.x;\0A\09\09\09\09facesA[fidx].m_plane.y = edgeNormal.y;\0A\09\09\09\09facesA[fidx].m_plane.z = edgeNormal.z;\0A\09\09\09\09facesA[fidx].m_plane.w = c;\0A\09\09\09\09fidx++;\0A\09\09\09\09prevVertex = i;\0A\09\09\09}\0A\09\09}\0A\09\09convexPolyhedronA.m_numFaces = TRIANGLE_NUM_CONVEX_FACES;\0A\09\09convexPolyhedronA.m_localCenter = localCenter*(1.f/3.f);\0A        \0A        \0A\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09posA.w = 0.f;\0A\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09posB.w = 0.f;\0A        \0A\09\09float4 ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09float4 ornB =rigidBodies[bodyIndexB].m_quat;\0A        \0A\09\09\0A        \0A        \0A\09\09///////////////////\0A\09\09///compound shape support\0A        \0A\09\09if (collidables[collidableIndexB].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS)\0A\09\09{\0A\09\09\09int compoundChild = concavePairs[pairIdx].w;\0A\09\09\09int childShapeIndexB = compoundChild;//collidables[collidableIndexB].m_shapeIndex+compoundChild;\0A\09\09\09int childColIndexB = gpuChildShapes[childShapeIndexB].m_shapeIndex;\0A\09\09\09float4 childPosB = gpuChildShapes[childShapeIndexB].m_childPosition;\0A\09\09\09float4 childOrnB = gpuChildShapes[childShapeIndexB].m_childOrientation;\0A\09\09\09float4 newPosB = transform(&childPosB,&posB,&ornB);\0A\09\09\09float4 newOrnB = qtMul(ornB,childOrnB);\0A\09\09\09posB = newPosB;\0A\09\09\09ornB = newOrnB;\0A\09\09\09shapeIndexB = collidables[childColIndexB].m_shapeIndex;\0A\09\09}\0A\09\09//////////////////\0A        \0A\09\09float4 c0local = convexPolyhedronA.m_localCenter;\0A\09\09float4 c0 = transform(&c0local, &posA, &ornA);\0A\09\09float4 c1local = convexShapes[shapeIndexB].m_localCenter;\0A\09\09float4 c1 = transform(&c1local,&posB,&ornB);\0A\09\09const float4 DeltaC2 = c0 - c1;\0A        \0A        \0A\09\09{\0A\09\09\09bool sepEE = findSeparatingAxisEdgeEdgeLocalA(\09&convexPolyhedronA, &convexShapes[shapeIndexB],\0A                                                              posA,ornA,\0A                                                              posB,ornB,\0A                                                              DeltaC2,\0A                                                              verticesA,uniqueEdgesA,facesA,indicesA,\0A                                                              vertices,uniqueEdges,faces,indices,\0A                                                              &sepAxis,&dmin);\0A                \0A\09\09\09if (!sepEE)\0A\09\09\09{\0A\09\09\09\09hasSeparatingAxis = 0;\0A\09\09\09} else\0A\09\09\09{\0A\09\09\09\09hasSeparatingAxis = 1;\0A\09\09\09}\0A\09\09}\0A\09\09\0A\09\09\0A\09\09if (hasSeparatingAxis)\0A\09\09{\0A\09\09\09sepAxis.w = dmin;\0A            dmins[i] = dmin;\0A\09\09\09concaveSeparatingNormalsOut[pairIdx]=sepAxis;\0A\09\09\09concaveHasSeparatingNormals[i]=1;\0A           \0A \09float minDist = -1e30f;\0A\09\09\09float maxDist = 0.02f;\0A            \0A            findClippingFaces(sepAxis,\0A                              &convexPolyhedronA,\0A                              &convexShapes[shapeIndexB],\0A                              posA,ornA,\0A                              posB,ornB,\0A                              worldVertsA1GPU,\0A                              worldNormalsAGPU,\0A                              worldVertsB1GPU,\0A                              vertexFaceCapacity,\0A                              minDist, maxDist,\0A                              verticesA,\0A                              facesA,\0A                              indicesA,\0A                              vertices,\0A                              faces,\0A                              indices,\0A                              clippingFacesOut, pairIdx);\0A\09           \0A            \0A\09\09} else\0A\09\09{\09\0A\09\09\09//mark this pair as in-active\0A\09\09\09concavePairs[pairIdx].w = -1;\0A\09\09}\0A\09}\0A\09else\0A\09{\09\0A\09\09//mark this pair as in-active\0A\09\09concavePairs[pairIdx].w = -1;\0A\09}\0A\09\0A\09concavePairs[i].z = -1;//for the next stage, z is used to determine existing contact points\0A}\0A\00", align 1
@.str.68 = private unnamed_addr constant [65091 x i8] c"//keep this enum in sync with the CPU version (in btCollidable.h)\0A//written by Erwin Coumans\0A#define SHAPE_CONVEX_HULL 3\0A#define SHAPE_CONCAVE_TRIMESH 5\0A#define TRIANGLE_NUM_CONVEX_FACES 5\0A#define SHAPE_COMPOUND_OF_CONVEX_HULLS 6\0A#define B3_MAX_STACK_DEPTH 256\0Atypedef unsigned int u32;\0A///keep this in sync with btCollidable.h\0Atypedef struct\0A{\0A\09union {\0A\09\09int m_numChildShapes;\0A\09\09int m_bvhIndex;\0A\09};\0A\09union\0A\09{\0A\09\09float m_radius;\0A\09\09int\09m_compoundBvhIndex;\0A\09};\0A\09\0A\09int m_shapeType;\0A\09int m_shapeIndex;\0A\09\0A} btCollidableGpu;\0A#define MAX_NUM_PARTS_IN_BITS 10\0A///b3QuantizedBvhNode is a compressed aabb node, 16 bytes.\0A///Node can be used for leafnode or internal node. Leafnodes can point to 32-bit triangle index (non-negative range).\0Atypedef struct\0A{\0A\09//12 bytes\0A\09unsigned short int\09m_quantizedAabbMin[3];\0A\09unsigned short int\09m_quantizedAabbMax[3];\0A\09//4 bytes\0A\09int\09m_escapeIndexOrTriangleIndex;\0A} b3QuantizedBvhNode;\0Atypedef struct\0A{\0A\09float4\09\09m_aabbMin;\0A\09float4\09\09m_aabbMax;\0A\09float4\09\09m_quantization;\0A\09int\09\09\09m_numNodes;\0A\09int\09\09\09m_numSubTrees;\0A\09int\09\09\09m_nodeOffset;\0A\09int\09\09\09m_subTreeOffset;\0A} b3BvhInfo;\0Aint\09getTriangleIndex(const b3QuantizedBvhNode* rootNode)\0A{\0A\09unsigned int x=0;\0A\09unsigned int y = (~(x&0))<<(31-MAX_NUM_PARTS_IN_BITS);\0A\09// Get only the lower bits where the triangle index is stored\0A\09return (rootNode->m_escapeIndexOrTriangleIndex&~(y));\0A}\0Aint\09getTriangleIndexGlobal(__global const b3QuantizedBvhNode* rootNode)\0A{\0A\09unsigned int x=0;\0A\09unsigned int y = (~(x&0))<<(31-MAX_NUM_PARTS_IN_BITS);\0A\09// Get only the lower bits where the triangle index is stored\0A\09return (rootNode->m_escapeIndexOrTriangleIndex&~(y));\0A}\0Aint isLeafNode(const b3QuantizedBvhNode* rootNode)\0A{\0A\09//skipindex is negative (internal node), triangleindex >=0 (leafnode)\0A\09return (rootNode->m_escapeIndexOrTriangleIndex >= 0)? 1 : 0;\0A}\0Aint isLeafNodeGlobal(__global const b3QuantizedBvhNode* rootNode)\0A{\0A\09//skipindex is negative (internal node), triangleindex >=0 (leafnode)\0A\09return (rootNode->m_escapeIndexOrTriangleIndex >= 0)? 1 : 0;\0A}\0A\09\0Aint getEscapeIndex(const b3QuantizedBvhNode* rootNode)\0A{\0A\09return -rootNode->m_escapeIndexOrTriangleIndex;\0A}\0Aint getEscapeIndexGlobal(__global const b3QuantizedBvhNode* rootNode)\0A{\0A\09return -rootNode->m_escapeIndexOrTriangleIndex;\0A}\0Atypedef struct\0A{\0A\09//12 bytes\0A\09unsigned short int\09m_quantizedAabbMin[3];\0A\09unsigned short int\09m_quantizedAabbMax[3];\0A\09//4 bytes, points to the root of the subtree\0A\09int\09\09\09m_rootNodeIndex;\0A\09//4 bytes\0A\09int\09\09\09m_subtreeSize;\0A\09int\09\09\09m_padding[3];\0A} b3BvhSubtreeInfo;\0Atypedef struct\0A{\0A\09float4\09m_childPosition;\0A\09float4\09m_childOrientation;\0A\09int m_shapeIndex;\0A\09int m_unused0;\0A\09int m_unused1;\0A\09int m_unused2;\0A} btGpuChildShape;\0Atypedef struct\0A{\0A\09float4 m_pos;\0A\09float4 m_quat;\0A\09float4 m_linVel;\0A\09float4 m_angVel;\0A\09u32 m_collidableIdx;\0A\09float m_invMass;\0A\09float m_restituitionCoeff;\0A\09float m_frictionCoeff;\0A} BodyData;\0Atypedef struct  \0A{\0A\09float4\09\09m_localCenter;\0A\09float4\09\09m_extents;\0A\09float4\09\09mC;\0A\09float4\09\09mE;\0A\09\0A\09float\09\09\09m_radius;\0A\09int\09m_faceOffset;\0A\09int m_numFaces;\0A\09int\09m_numVertices;\0A\09int m_vertexOffset;\0A\09int\09m_uniqueEdgesOffset;\0A\09int\09m_numUniqueEdges;\0A\09int m_unused;\0A} ConvexPolyhedronCL;\0Atypedef struct \0A{\0A\09union\0A\09{\0A\09\09float4\09m_min;\0A\09\09float   m_minElems[4];\0A\09\09int\09\09\09m_minIndices[4];\0A\09};\0A\09union\0A\09{\0A\09\09float4\09m_max;\0A\09\09float   m_maxElems[4];\0A\09\09int\09\09\09m_maxIndices[4];\0A\09};\0A} btAabbCL;\0A#ifndef B3_AABB_H\0A#define B3_AABB_H\0A#ifndef B3_FLOAT4_H\0A#define B3_FLOAT4_H\0A#ifndef B3_PLATFORM_DEFINITIONS_H\0A#define B3_PLATFORM_DEFINITIONS_H\0Astruct MyTest\0A{\0A\09int bla;\0A};\0A#ifdef __cplusplus\0A#else\0A//keep B3_LARGE_FLOAT*B3_LARGE_FLOAT < FLT_MAX\0A#define B3_LARGE_FLOAT 1e18f\0A#define B3_INFINITY 1e18f\0A#define b3Assert(a)\0A#define b3ConstArray(a) __global const a*\0A#define b3AtomicInc atomic_inc\0A#define b3AtomicAdd atomic_add\0A#define b3Fabs fabs\0A#define b3Sqrt native_sqrt\0A#define b3Sin native_sin\0A#define b3Cos native_cos\0A#define B3_STATIC\0A#endif\0A#endif\0A#ifdef __cplusplus\0A#else\0A\09typedef float4\09b3Float4;\0A\09#define b3Float4ConstArg const b3Float4\0A\09#define b3MakeFloat4 (float4)\0A\09float b3Dot3F4(b3Float4ConstArg v0,b3Float4ConstArg v1)\0A\09{\0A\09\09float4 a1 = b3MakeFloat4(v0.xyz,0.f);\0A\09\09float4 b1 = b3MakeFloat4(v1.xyz,0.f);\0A\09\09return dot(a1, b1);\0A\09}\0A\09b3Float4 b3Cross3(b3Float4ConstArg v0,b3Float4ConstArg v1)\0A\09{\0A\09\09float4 a1 = b3MakeFloat4(v0.xyz,0.f);\0A\09\09float4 b1 = b3MakeFloat4(v1.xyz,0.f);\0A\09\09return cross(a1, b1);\0A\09}\0A\09#define b3MinFloat4 min\0A\09#define b3MaxFloat4 max\0A\09#define b3Normalized(a) normalize(a)\0A#endif \0A\09\09\0Ainline bool b3IsAlmostZero(b3Float4ConstArg v)\0A{\0A\09if(b3Fabs(v.x)>1e-6 || b3Fabs(v.y)>1e-6 || b3Fabs(v.z)>1e-6)\09\0A\09\09return false;\0A\09return true;\0A}\0Ainline int    b3MaxDot( b3Float4ConstArg vec, __global const b3Float4* vecArray, int vecLen, float* dotOut )\0A{\0A    float maxDot = -B3_INFINITY;\0A    int i = 0;\0A    int ptIndex = -1;\0A    for( i = 0; i < vecLen; i++ )\0A    {\0A        float dot = b3Dot3F4(vecArray[i],vec);\0A            \0A        if( dot > maxDot )\0A        {\0A            maxDot = dot;\0A            ptIndex = i;\0A        }\0A    }\0A\09b3Assert(ptIndex>=0);\0A    if (ptIndex<0)\0A\09{\0A\09\09ptIndex = 0;\0A\09}\0A    *dotOut = maxDot;\0A    return ptIndex;\0A}\0A#endif //B3_FLOAT4_H\0A#ifndef B3_MAT3x3_H\0A#define B3_MAT3x3_H\0A#ifndef B3_QUAT_H\0A#define B3_QUAT_H\0A#ifndef B3_PLATFORM_DEFINITIONS_H\0A#ifdef __cplusplus\0A#else\0A#endif\0A#endif\0A#ifndef B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A\09typedef float4\09b3Quat;\0A\09#define b3QuatConstArg const b3Quat\0A\09\0A\09\0Ainline float4 b3FastNormalize4(float4 v)\0A{\0A\09v = (float4)(v.xyz,0.f);\0A\09return fast_normalize(v);\0A}\0A\09\0Ainline b3Quat b3QuatMul(b3Quat a, b3Quat b);\0Ainline b3Quat b3QuatNormalized(b3QuatConstArg in);\0Ainline b3Quat b3QuatRotate(b3QuatConstArg q, b3QuatConstArg vec);\0Ainline b3Quat b3QuatInvert(b3QuatConstArg q);\0Ainline b3Quat b3QuatInverse(b3QuatConstArg q);\0Ainline b3Quat b3QuatMul(b3QuatConstArg a, b3QuatConstArg b)\0A{\0A\09b3Quat ans;\0A\09ans = b3Cross3( a, b );\0A\09ans += a.w*b+b.w*a;\0A//\09ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);\0A\09ans.w = a.w*b.w - b3Dot3F4(a, b);\0A\09return ans;\0A}\0Ainline b3Quat b3QuatNormalized(b3QuatConstArg in)\0A{\0A\09b3Quat q;\0A\09q=in;\0A\09//return b3FastNormalize4(in);\0A\09float len = native_sqrt(dot(q, q));\0A\09if(len > 0.f)\0A\09{\0A\09\09q *= 1.f / len;\0A\09}\0A\09else\0A\09{\0A\09\09q.x = q.y = q.z = 0.f;\0A\09\09q.w = 1.f;\0A\09}\0A\09return q;\0A}\0Ainline float4 b3QuatRotate(b3QuatConstArg q, b3QuatConstArg vec)\0A{\0A\09b3Quat qInv = b3QuatInvert( q );\0A\09float4 vcpy = vec;\0A\09vcpy.w = 0.f;\0A\09float4 out = b3QuatMul(b3QuatMul(q,vcpy),qInv);\0A\09return out;\0A}\0Ainline b3Quat b3QuatInverse(b3QuatConstArg q)\0A{\0A\09return (b3Quat)(-q.xyz, q.w);\0A}\0Ainline b3Quat b3QuatInvert(b3QuatConstArg q)\0A{\0A\09return (b3Quat)(-q.xyz, q.w);\0A}\0Ainline float4 b3QuatInvRotate(b3QuatConstArg q, b3QuatConstArg vec)\0A{\0A\09return b3QuatRotate( b3QuatInvert( q ), vec );\0A}\0Ainline b3Float4 b3TransformPoint(b3Float4ConstArg point, b3Float4ConstArg translation, b3QuatConstArg  orientation)\0A{\0A\09return b3QuatRotate( orientation, point ) + (translation);\0A}\0A\09\0A#endif \0A#endif //B3_QUAT_H\0A#ifdef __cplusplus\0A#else\0Atypedef struct\0A{\0A\09b3Float4 m_row[3];\0A}b3Mat3x3;\0A#define b3Mat3x3ConstArg const b3Mat3x3\0A#define b3GetRow(m,row) (m.m_row[row])\0Ainline b3Mat3x3 b3QuatGetRotationMatrix(b3Quat quat)\0A{\0A\09b3Float4 quat2 = (b3Float4)(quat.x*quat.x, quat.y*quat.y, quat.z*quat.z, 0.f);\0A\09b3Mat3x3 out;\0A\09out.m_row[0].x=1-2*quat2.y-2*quat2.z;\0A\09out.m_row[0].y=2*quat.x*quat.y-2*quat.w*quat.z;\0A\09out.m_row[0].z=2*quat.x*quat.z+2*quat.w*quat.y;\0A\09out.m_row[0].w = 0.f;\0A\09out.m_row[1].x=2*quat.x*quat.y+2*quat.w*quat.z;\0A\09out.m_row[1].y=1-2*quat2.x-2*quat2.z;\0A\09out.m_row[1].z=2*quat.y*quat.z-2*quat.w*quat.x;\0A\09out.m_row[1].w = 0.f;\0A\09out.m_row[2].x=2*quat.x*quat.z-2*quat.w*quat.y;\0A\09out.m_row[2].y=2*quat.y*quat.z+2*quat.w*quat.x;\0A\09out.m_row[2].z=1-2*quat2.x-2*quat2.y;\0A\09out.m_row[2].w = 0.f;\0A\09return out;\0A}\0Ainline b3Mat3x3 b3AbsoluteMat3x3(b3Mat3x3ConstArg matIn)\0A{\0A\09b3Mat3x3 out;\0A\09out.m_row[0] = fabs(matIn.m_row[0]);\0A\09out.m_row[1] = fabs(matIn.m_row[1]);\0A\09out.m_row[2] = fabs(matIn.m_row[2]);\0A\09return out;\0A}\0A__inline\0Ab3Mat3x3 mtZero();\0A__inline\0Ab3Mat3x3 mtIdentity();\0A__inline\0Ab3Mat3x3 mtTranspose(b3Mat3x3 m);\0A__inline\0Ab3Mat3x3 mtMul(b3Mat3x3 a, b3Mat3x3 b);\0A__inline\0Ab3Float4 mtMul1(b3Mat3x3 a, b3Float4 b);\0A__inline\0Ab3Float4 mtMul3(b3Float4 a, b3Mat3x3 b);\0A__inline\0Ab3Mat3x3 mtZero()\0A{\0A\09b3Mat3x3 m;\0A\09m.m_row[0] = (b3Float4)(0.f);\0A\09m.m_row[1] = (b3Float4)(0.f);\0A\09m.m_row[2] = (b3Float4)(0.f);\0A\09return m;\0A}\0A__inline\0Ab3Mat3x3 mtIdentity()\0A{\0A\09b3Mat3x3 m;\0A\09m.m_row[0] = (b3Float4)(1,0,0,0);\0A\09m.m_row[1] = (b3Float4)(0,1,0,0);\0A\09m.m_row[2] = (b3Float4)(0,0,1,0);\0A\09return m;\0A}\0A__inline\0Ab3Mat3x3 mtTranspose(b3Mat3x3 m)\0A{\0A\09b3Mat3x3 out;\0A\09out.m_row[0] = (b3Float4)(m.m_row[0].x, m.m_row[1].x, m.m_row[2].x, 0.f);\0A\09out.m_row[1] = (b3Float4)(m.m_row[0].y, m.m_row[1].y, m.m_row[2].y, 0.f);\0A\09out.m_row[2] = (b3Float4)(m.m_row[0].z, m.m_row[1].z, m.m_row[2].z, 0.f);\0A\09return out;\0A}\0A__inline\0Ab3Mat3x3 mtMul(b3Mat3x3 a, b3Mat3x3 b)\0A{\0A\09b3Mat3x3 transB;\0A\09transB = mtTranspose( b );\0A\09b3Mat3x3 ans;\0A\09//\09why this doesn't run when 0ing in the for{}\0A\09a.m_row[0].w = 0.f;\0A\09a.m_row[1].w = 0.f;\0A\09a.m_row[2].w = 0.f;\0A\09for(int i=0; i<3; i++)\0A\09{\0A//\09a.m_row[i].w = 0.f;\0A\09\09ans.m_row[i].x = b3Dot3F4(a.m_row[i],transB.m_row[0]);\0A\09\09ans.m_row[i].y = b3Dot3F4(a.m_row[i],transB.m_row[1]);\0A\09\09ans.m_row[i].z = b3Dot3F4(a.m_row[i],transB.m_row[2]);\0A\09\09ans.m_row[i].w = 0.f;\0A\09}\0A\09return ans;\0A}\0A__inline\0Ab3Float4 mtMul1(b3Mat3x3 a, b3Float4 b)\0A{\0A\09b3Float4 ans;\0A\09ans.x = b3Dot3F4( a.m_row[0], b );\0A\09ans.y = b3Dot3F4( a.m_row[1], b );\0A\09ans.z = b3Dot3F4( a.m_row[2], b );\0A\09ans.w = 0.f;\0A\09return ans;\0A}\0A__inline\0Ab3Float4 mtMul3(b3Float4 a, b3Mat3x3 b)\0A{\0A\09b3Float4 colx = b3MakeFloat4(b.m_row[0].x, b.m_row[1].x, b.m_row[2].x, 0);\0A\09b3Float4 coly = b3MakeFloat4(b.m_row[0].y, b.m_row[1].y, b.m_row[2].y, 0);\0A\09b3Float4 colz = b3MakeFloat4(b.m_row[0].z, b.m_row[1].z, b.m_row[2].z, 0);\0A\09b3Float4 ans;\0A\09ans.x = b3Dot3F4( a, colx );\0A\09ans.y = b3Dot3F4( a, coly );\0A\09ans.z = b3Dot3F4( a, colz );\0A\09return ans;\0A}\0A#endif\0A#endif //B3_MAT3x3_H\0Atypedef struct b3Aabb b3Aabb_t;\0Astruct b3Aabb\0A{\0A\09union\0A\09{\0A\09\09float m_min[4];\0A\09\09b3Float4 m_minVec;\0A\09\09int m_minIndices[4];\0A\09};\0A\09union\0A\09{\0A\09\09float\09m_max[4];\0A\09\09b3Float4 m_maxVec;\0A\09\09int m_signedMaxIndices[4];\0A\09};\0A};\0Ainline void b3TransformAabb2(b3Float4ConstArg localAabbMin,b3Float4ConstArg localAabbMax, float margin,\0A\09\09\09\09\09\09b3Float4ConstArg pos,\0A\09\09\09\09\09\09b3QuatConstArg orn,\0A\09\09\09\09\09\09b3Float4* aabbMinOut,b3Float4* aabbMaxOut)\0A{\0A\09\09b3Float4 localHalfExtents = 0.5f*(localAabbMax-localAabbMin);\0A\09\09localHalfExtents+=b3MakeFloat4(margin,margin,margin,0.f);\0A\09\09b3Float4 localCenter = 0.5f*(localAabbMax+localAabbMin);\0A\09\09b3Mat3x3 m;\0A\09\09m = b3QuatGetRotationMatrix(orn);\0A\09\09b3Mat3x3 abs_b = b3AbsoluteMat3x3(m);\0A\09\09b3Float4 center = b3TransformPoint(localCenter,pos,orn);\0A\09\09\0A\09\09b3Float4 extent = b3MakeFloat4(b3Dot3F4(localHalfExtents,b3GetRow(abs_b,0)),\0A\09\09\09\09\09\09\09\09\09\09 b3Dot3F4(localHalfExtents,b3GetRow(abs_b,1)),\0A\09\09\09\09\09\09\09\09\09\09 b3Dot3F4(localHalfExtents,b3GetRow(abs_b,2)),\0A\09\09\09\09\09\09\09\09\09\09 0.f);\0A\09\09*aabbMinOut = center-extent;\0A\09\09*aabbMaxOut = center+extent;\0A}\0A/// conservative test for overlap between two aabbs\0Ainline bool b3TestAabbAgainstAabb(b3Float4ConstArg aabbMin1,b3Float4ConstArg aabbMax1,\0A\09\09\09\09\09\09\09\09b3Float4ConstArg aabbMin2, b3Float4ConstArg aabbMax2)\0A{\0A\09bool overlap = true;\0A\09overlap = (aabbMin1.x > aabbMax2.x || aabbMax1.x < aabbMin2.x) ? false : overlap;\0A\09overlap = (aabbMin1.z > aabbMax2.z || aabbMax1.z < aabbMin2.z) ? false : overlap;\0A\09overlap = (aabbMin1.y > aabbMax2.y || aabbMax1.y < aabbMin2.y) ? false : overlap;\0A\09return overlap;\0A}\0A#endif //B3_AABB_H\0A/*\0ABullet Continuous Collision Detection and Physics Library\0ACopyright (c) 2003-2013 Erwin Coumans  http://bulletphysics.org\0AThis software is provided 'as-is', without any express or implied warranty.\0AIn no event will the authors be held liable for any damages arising from the use of this software.\0APermission is granted to anyone to use this software for any purpose,\0Aincluding commercial applications, and to alter it and redistribute it freely,\0Asubject to the following restrictions:\0A1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.\0A2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.\0A3. This notice may not be removed or altered from any source distribution.\0A*/\0A#ifndef B3_INT2_H\0A#define B3_INT2_H\0A#ifdef __cplusplus\0A#else\0A#define b3UnsignedInt2 uint2\0A#define b3Int2 int2\0A#define b3MakeInt2 (int2)\0A#endif //__cplusplus\0A#endif\0Atypedef struct\0A{\0A\09float4 m_plane;\0A\09int m_indexOffset;\0A\09int m_numIndices;\0A} btGpuFace;\0A#define make_float4 (float4)\0A__inline\0Afloat4 cross3(float4 a, float4 b)\0A{\0A\09return cross(a,b);\0A\09\0A//\09float4 a1 = make_float4(a.xyz,0.f);\0A//\09float4 b1 = make_float4(b.xyz,0.f);\0A//\09return cross(a1,b1);\0A//float4 c = make_float4(a.y*b.z - a.z*b.y,a.z*b.x - a.x*b.z,a.x*b.y - a.y*b.x,0.f);\0A\09\0A\09//\09float4 c = make_float4(a.y*b.z - a.z*b.y,1.f,a.x*b.y - a.y*b.x,0.f);\0A\09\0A\09//return c;\0A}\0A__inline\0Afloat dot3F4(float4 a, float4 b)\0A{\0A\09float4 a1 = make_float4(a.xyz,0.f);\0A\09float4 b1 = make_float4(b.xyz,0.f);\0A\09return dot(a1, b1);\0A}\0A__inline\0Afloat4 fastNormalize4(float4 v)\0A{\0A\09v = make_float4(v.xyz,0.f);\0A\09return fast_normalize(v);\0A}\0A///////////////////////////////////////\0A//\09Quaternion\0A///////////////////////////////////////\0Atypedef float4 Quaternion;\0A__inline\0AQuaternion qtMul(Quaternion a, Quaternion b);\0A__inline\0AQuaternion qtNormalize(Quaternion in);\0A__inline\0Afloat4 qtRotate(Quaternion q, float4 vec);\0A__inline\0AQuaternion qtInvert(Quaternion q);\0A__inline\0AQuaternion qtMul(Quaternion a, Quaternion b)\0A{\0A\09Quaternion ans;\0A\09ans = cross3( a, b );\0A\09ans += a.w*b+b.w*a;\0A//\09ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);\0A\09ans.w = a.w*b.w - dot3F4(a, b);\0A\09return ans;\0A}\0A__inline\0AQuaternion qtNormalize(Quaternion in)\0A{\0A\09return fastNormalize4(in);\0A//\09in /= length( in );\0A//\09return in;\0A}\0A__inline\0Afloat4 qtRotate(Quaternion q, float4 vec)\0A{\0A\09Quaternion qInv = qtInvert( q );\0A\09float4 vcpy = vec;\0A\09vcpy.w = 0.f;\0A\09float4 out = qtMul(qtMul(q,vcpy),qInv);\0A\09return out;\0A}\0A__inline\0AQuaternion qtInvert(Quaternion q)\0A{\0A\09return (Quaternion)(-q.xyz, q.w);\0A}\0A__inline\0Afloat4 qtInvRotate(const Quaternion q, float4 vec)\0A{\0A\09return qtRotate( qtInvert( q ), vec );\0A}\0A__inline\0Afloat4 transform(const float4* p, const float4* translation, const Quaternion* orientation)\0A{\0A\09return qtRotate( *orientation, *p ) + (*translation);\0A}\0A__inline\0Afloat4 normalize3(const float4 a)\0A{\0A\09float4 n = make_float4(a.x, a.y, a.z, 0.f);\0A\09return fastNormalize4( n );\0A}\0Ainline void projectLocal(const ConvexPolyhedronCL* hull,  const float4 pos, const float4 orn, \0Aconst float4* dir, const float4* vertices, float* min, float* max)\0A{\0A\09min[0] = FLT_MAX;\0A\09max[0] = -FLT_MAX;\0A\09int numVerts = hull->m_numVertices;\0A\09const float4 localDir = qtInvRotate(orn,*dir);\0A\09float offset = dot(pos,*dir);\0A\09for(int i=0;i<numVerts;i++)\0A\09{\0A\09\09float dp = dot(vertices[hull->m_vertexOffset+i],localDir);\0A\09\09if(dp < min[0])\09\0A\09\09\09min[0] = dp;\0A\09\09if(dp > max[0])\09\0A\09\09\09max[0] = dp;\0A\09}\0A\09if(min[0]>max[0])\0A\09{\0A\09\09float tmp = min[0];\0A\09\09min[0] = max[0];\0A\09\09max[0] = tmp;\0A\09}\0A\09min[0] += offset;\0A\09max[0] += offset;\0A}\0Ainline void project(__global const ConvexPolyhedronCL* hull,  const float4 pos, const float4 orn, \0Aconst float4* dir, __global const float4* vertices, float* min, float* max)\0A{\0A\09min[0] = FLT_MAX;\0A\09max[0] = -FLT_MAX;\0A\09int numVerts = hull->m_numVertices;\0A\09const float4 localDir = qtInvRotate(orn,*dir);\0A\09float offset = dot(pos,*dir);\0A\09for(int i=0;i<numVerts;i++)\0A\09{\0A\09\09float dp = dot(vertices[hull->m_vertexOffset+i],localDir);\0A\09\09if(dp < min[0])\09\0A\09\09\09min[0] = dp;\0A\09\09if(dp > max[0])\09\0A\09\09\09max[0] = dp;\0A\09}\0A\09if(min[0]>max[0])\0A\09{\0A\09\09float tmp = min[0];\0A\09\09min[0] = max[0];\0A\09\09max[0] = tmp;\0A\09}\0A\09min[0] += offset;\0A\09max[0] += offset;\0A}\0Ainline bool TestSepAxisLocalA(const ConvexPolyhedronCL* hullA, __global const ConvexPolyhedronCL* hullB, \0A\09const float4 posA,const float4 ornA,\0A\09const float4 posB,const float4 ornB,\0A\09float4* sep_axis, const float4* verticesA, __global const float4* verticesB,float* depth)\0A{\0A\09float Min0,Max0;\0A\09float Min1,Max1;\0A\09projectLocal(hullA,posA,ornA,sep_axis,verticesA, &Min0, &Max0);\0A\09project(hullB,posB,ornB, sep_axis,verticesB, &Min1, &Max1);\0A\09if(Max0<Min1 || Max1<Min0)\0A\09\09return false;\0A\09float d0 = Max0 - Min1;\0A\09float d1 = Max1 - Min0;\0A\09*depth = d0<d1 ? d0:d1;\0A\09return true;\0A}\0Ainline bool IsAlmostZero(const float4 v)\0A{\0A\09if(fabs(v.x)>1e-6f || fabs(v.y)>1e-6f || fabs(v.z)>1e-6f)\0A\09\09return false;\0A\09return true;\0A}\0Abool findSeparatingAxisLocalA(\09const ConvexPolyhedronCL* hullA, __global const ConvexPolyhedronCL* hullB, \0A\09const float4 posA1,\0A\09const float4 ornA,\0A\09const float4 posB1,\0A\09const float4 ornB,\0A\09const float4 DeltaC2,\0A\09\0A\09const float4* verticesA, \0A\09const float4* uniqueEdgesA, \0A\09const btGpuFace* facesA,\0A\09const int*  indicesA,\0A\09__global const float4* verticesB, \0A\09__global const float4* uniqueEdgesB, \0A\09__global const btGpuFace* facesB,\0A\09__global const int*  indicesB,\0A\09float4* sep,\0A\09float* dmin)\0A{\0A\09\0A\09float4 posA = posA1;\0A\09posA.w = 0.f;\0A\09float4 posB = posB1;\0A\09posB.w = 0.f;\0A\09int curPlaneTests=0;\0A\09{\0A\09\09int numFacesA = hullA->m_numFaces;\0A\09\09// Test normals from hullA\0A\09\09for(int i=0;i<numFacesA;i++)\0A\09\09{\0A\09\09\09const float4 normal = facesA[hullA->m_faceOffset+i].m_plane;\0A\09\09\09float4 faceANormalWS = qtRotate(ornA,normal);\0A\09\09\09if (dot3F4(DeltaC2,faceANormalWS)<0)\0A\09\09\09\09faceANormalWS*=-1.f;\0A\09\09\09curPlaneTests++;\0A\09\09\09float d;\0A\09\09\09if(!TestSepAxisLocalA( hullA, hullB, posA,ornA,posB,ornB,&faceANormalWS, verticesA, verticesB,&d))\0A\09\09\09\09return false;\0A\09\09\09if(d<*dmin)\0A\09\09\09{\0A\09\09\09\09*dmin = d;\0A\09\09\09\09*sep = faceANormalWS;\0A\09\09\09}\0A\09\09}\0A\09}\0A\09if((dot3F4(-DeltaC2,*sep))>0.0f)\0A\09{\0A\09\09*sep = -(*sep);\0A\09}\0A\09return true;\0A}\0Abool findSeparatingAxisLocalB(\09__global const ConvexPolyhedronCL* hullA,  const ConvexPolyhedronCL* hullB, \0A\09const float4 posA1,\0A\09const float4 ornA,\0A\09const float4 posB1,\0A\09const float4 ornB,\0A\09const float4 DeltaC2,\0A\09__global const float4* verticesA, \0A\09__global const float4* uniqueEdgesA, \0A\09__global const btGpuFace* facesA,\0A\09__global const int*  indicesA,\0A\09const float4* verticesB,\0A\09const float4* uniqueEdgesB, \0A\09const btGpuFace* facesB,\0A\09const int*  indicesB,\0A\09float4* sep,\0A\09float* dmin)\0A{\0A\09float4 posA = posA1;\0A\09posA.w = 0.f;\0A\09float4 posB = posB1;\0A\09posB.w = 0.f;\0A\09int curPlaneTests=0;\0A\09{\0A\09\09int numFacesA = hullA->m_numFaces;\0A\09\09// Test normals from hullA\0A\09\09for(int i=0;i<numFacesA;i++)\0A\09\09{\0A\09\09\09const float4 normal = facesA[hullA->m_faceOffset+i].m_plane;\0A\09\09\09float4 faceANormalWS = qtRotate(ornA,normal);\0A\09\09\09if (dot3F4(DeltaC2,faceANormalWS)<0)\0A\09\09\09\09faceANormalWS *= -1.f;\0A\09\09\09curPlaneTests++;\0A\09\09\09float d;\0A\09\09\09if(!TestSepAxisLocalA( hullB, hullA, posB,ornB,posA,ornA, &faceANormalWS, verticesB,verticesA, &d))\0A\09\09\09\09return false;\0A\09\09\09if(d<*dmin)\0A\09\09\09{\0A\09\09\09\09*dmin = d;\0A\09\09\09\09*sep = faceANormalWS;\0A\09\09\09}\0A\09\09}\0A\09}\0A\09if((dot3F4(-DeltaC2,*sep))>0.0f)\0A\09{\0A\09\09*sep = -(*sep);\0A\09}\0A\09return true;\0A}\0Abool findSeparatingAxisEdgeEdgeLocalA(\09const ConvexPolyhedronCL* hullA, __global const ConvexPolyhedronCL* hullB, \0A\09const float4 posA1,\0A\09const float4 ornA,\0A\09const float4 posB1,\0A\09const float4 ornB,\0A\09const float4 DeltaC2,\0A\09const float4* verticesA, \0A\09const float4* uniqueEdgesA, \0A\09const btGpuFace* facesA,\0A\09const int*  indicesA,\0A\09__global const float4* verticesB, \0A\09__global const float4* uniqueEdgesB, \0A\09__global const btGpuFace* facesB,\0A\09__global const int*  indicesB,\0A\09\09float4* sep,\0A\09float* dmin)\0A{\0A\09float4 posA = posA1;\0A\09posA.w = 0.f;\0A\09float4 posB = posB1;\0A\09posB.w = 0.f;\0A\09int curPlaneTests=0;\0A\09int curEdgeEdge = 0;\0A\09// Test edges\0A\09for(int e0=0;e0<hullA->m_numUniqueEdges;e0++)\0A\09{\0A\09\09const float4 edge0 = uniqueEdgesA[hullA->m_uniqueEdgesOffset+e0];\0A\09\09float4 edge0World = qtRotate(ornA,edge0);\0A\09\09for(int e1=0;e1<hullB->m_numUniqueEdges;e1++)\0A\09\09{\0A\09\09\09const float4 edge1 = uniqueEdgesB[hullB->m_uniqueEdgesOffset+e1];\0A\09\09\09float4 edge1World = qtRotate(ornB,edge1);\0A\09\09\09float4 crossje = cross3(edge0World,edge1World);\0A\09\09\09curEdgeEdge++;\0A\09\09\09if(!IsAlmostZero(crossje))\0A\09\09\09{\0A\09\09\09\09crossje = normalize3(crossje);\0A\09\09\09\09if (dot3F4(DeltaC2,crossje)<0)\0A\09\09\09\09\09crossje *= -1.f;\0A\09\09\09\09float dist;\0A\09\09\09\09bool result = true;\0A\09\09\09\09{\0A\09\09\09\09\09float Min0,Max0;\0A\09\09\09\09\09float Min1,Max1;\0A\09\09\09\09\09projectLocal(hullA,posA,ornA,&crossje,verticesA, &Min0, &Max0);\0A\09\09\09\09\09project(hullB,posB,ornB,&crossje,verticesB, &Min1, &Max1);\0A\09\09\09\09\0A\09\09\09\09\09if(Max0<Min1 || Max1<Min0)\0A\09\09\09\09\09\09result = false;\0A\09\09\09\09\0A\09\09\09\09\09float d0 = Max0 - Min1;\0A\09\09\09\09\09float d1 = Max1 - Min0;\0A\09\09\09\09\09dist = d0<d1 ? d0:d1;\0A\09\09\09\09\09result = true;\0A\09\09\09\09}\0A\09\09\09\09\0A\09\09\09\09if(dist<*dmin)\0A\09\09\09\09{\0A\09\09\09\09\09*dmin = dist;\0A\09\09\09\09\09*sep = crossje;\0A\09\09\09\09}\0A\09\09\09}\0A\09\09}\0A\09}\0A\09\0A\09if((dot3F4(-DeltaC2,*sep))>0.0f)\0A\09{\0A\09\09*sep = -(*sep);\0A\09}\0A\09return true;\0A}\0Ainline bool TestSepAxis(__global const ConvexPolyhedronCL* hullA, __global const ConvexPolyhedronCL* hullB, \0A\09const float4 posA,const float4 ornA,\0A\09const float4 posB,const float4 ornB,\0A\09float4* sep_axis, __global const float4* vertices,float* depth)\0A{\0A\09float Min0,Max0;\0A\09float Min1,Max1;\0A\09project(hullA,posA,ornA,sep_axis,vertices, &Min0, &Max0);\0A\09project(hullB,posB,ornB, sep_axis,vertices, &Min1, &Max1);\0A\09if(Max0<Min1 || Max1<Min0)\0A\09\09return false;\0A\09float d0 = Max0 - Min1;\0A\09float d1 = Max1 - Min0;\0A\09*depth = d0<d1 ? d0:d1;\0A\09return true;\0A}\0Abool findSeparatingAxis(\09__global const ConvexPolyhedronCL* hullA, __global const ConvexPolyhedronCL* hullB, \0A\09const float4 posA1,\0A\09const float4 ornA,\0A\09const float4 posB1,\0A\09const float4 ornB,\0A\09const float4 DeltaC2,\0A\09__global const float4* vertices, \0A\09__global const float4* uniqueEdges, \0A\09__global const btGpuFace* faces,\0A\09__global const int*  indices,\0A\09float4* sep,\0A\09float* dmin)\0A{\0A\09\0A\09float4 posA = posA1;\0A\09posA.w = 0.f;\0A\09float4 posB = posB1;\0A\09posB.w = 0.f;\0A\09\0A\09int curPlaneTests=0;\0A\09{\0A\09\09int numFacesA = hullA->m_numFaces;\0A\09\09// Test normals from hullA\0A\09\09for(int i=0;i<numFacesA;i++)\0A\09\09{\0A\09\09\09const float4 normal = faces[hullA->m_faceOffset+i].m_plane;\0A\09\09\09float4 faceANormalWS = qtRotate(ornA,normal);\0A\09\0A\09\09\09if (dot3F4(DeltaC2,faceANormalWS)<0)\0A\09\09\09\09faceANormalWS*=-1.f;\0A\09\09\09\09\0A\09\09\09curPlaneTests++;\0A\09\0A\09\09\09float d;\0A\09\09\09if(!TestSepAxis( hullA, hullB, posA,ornA,posB,ornB,&faceANormalWS, vertices,&d))\0A\09\09\09\09return false;\0A\09\0A\09\09\09if(d<*dmin)\0A\09\09\09{\0A\09\09\09\09*dmin = d;\0A\09\09\09\09*sep = faceANormalWS;\0A\09\09\09}\0A\09\09}\0A\09}\0A\09\09if((dot3F4(-DeltaC2,*sep))>0.0f)\0A\09\09{\0A\09\09\09*sep = -(*sep);\0A\09\09}\0A\09\0A\09return true;\0A}\0Abool findSeparatingAxisUnitSphere(\09__global const ConvexPolyhedronCL* hullA, __global const ConvexPolyhedronCL* hullB, \0A\09const float4 posA1,\0A\09const float4 ornA,\0A\09const float4 posB1,\0A\09const float4 ornB,\0A\09const float4 DeltaC2,\0A\09__global const float4* vertices,\0A\09__global const float4* unitSphereDirections,\0A\09int numUnitSphereDirections,\0A\09float4* sep,\0A\09float* dmin)\0A{\0A\09\0A\09float4 posA = posA1;\0A\09posA.w = 0.f;\0A\09float4 posB = posB1;\0A\09posB.w = 0.f;\0A\09int curPlaneTests=0;\0A\09int curEdgeEdge = 0;\0A\09// Test unit sphere directions\0A\09for (int i=0;i<numUnitSphereDirections;i++)\0A\09{\0A\09\09float4 crossje;\0A\09\09crossje = unitSphereDirections[i];\09\0A\09\09if (dot3F4(DeltaC2,crossje)>0)\0A\09\09\09crossje *= -1.f;\0A\09\09{\0A\09\09\09float dist;\0A\09\09\09bool result = true;\0A\09\09\09float Min0,Max0;\0A\09\09\09float Min1,Max1;\0A\09\09\09project(hullA,posA,ornA,&crossje,vertices, &Min0, &Max0);\0A\09\09\09project(hullB,posB,ornB,&crossje,vertices, &Min1, &Max1);\0A\09\09\0A\09\09\09if(Max0<Min1 || Max1<Min0)\0A\09\09\09\09return false;\0A\09\09\0A\09\09\09float d0 = Max0 - Min1;\0A\09\09\09float d1 = Max1 - Min0;\0A\09\09\09dist = d0<d1 ? d0:d1;\0A\09\09\09result = true;\0A\09\0A\09\09\09if(dist<*dmin)\0A\09\09\09{\0A\09\09\09\09*dmin = dist;\0A\09\09\09\09*sep = crossje;\0A\09\09\09}\0A\09\09}\0A\09}\0A\09\0A\09if((dot3F4(-DeltaC2,*sep))>0.0f)\0A\09{\0A\09\09*sep = -(*sep);\0A\09}\0A\09return true;\0A}\0Abool findSeparatingAxisEdgeEdge(\09__global const ConvexPolyhedronCL* hullA, __global const ConvexPolyhedronCL* hullB, \0A\09const float4 posA1,\0A\09const float4 ornA,\0A\09const float4 posB1,\0A\09const float4 ornB,\0A\09const float4 DeltaC2,\0A\09__global const float4* vertices, \0A\09__global const float4* uniqueEdges, \0A\09__global const btGpuFace* faces,\0A\09__global const int*  indices,\0A\09float4* sep,\0A\09float* dmin)\0A{\0A\09\0A\09float4 posA = posA1;\0A\09posA.w = 0.f;\0A\09float4 posB = posB1;\0A\09posB.w = 0.f;\0A\09int curPlaneTests=0;\0A\09int curEdgeEdge = 0;\0A\09// Test edges\0A\09for(int e0=0;e0<hullA->m_numUniqueEdges;e0++)\0A\09{\0A\09\09const float4 edge0 = uniqueEdges[hullA->m_uniqueEdgesOffset+e0];\0A\09\09float4 edge0World = qtRotate(ornA,edge0);\0A\09\09for(int e1=0;e1<hullB->m_numUniqueEdges;e1++)\0A\09\09{\0A\09\09\09const float4 edge1 = uniqueEdges[hullB->m_uniqueEdgesOffset+e1];\0A\09\09\09float4 edge1World = qtRotate(ornB,edge1);\0A\09\09\09float4 crossje = cross3(edge0World,edge1World);\0A\09\09\09curEdgeEdge++;\0A\09\09\09if(!IsAlmostZero(crossje))\0A\09\09\09{\0A\09\09\09\09crossje = normalize3(crossje);\0A\09\09\09\09if (dot3F4(DeltaC2,crossje)<0)\0A\09\09\09\09\09crossje*=-1.f;\0A\09\09\09\09\09\0A\09\09\09\09float dist;\0A\09\09\09\09bool result = true;\0A\09\09\09\09{\0A\09\09\09\09\09float Min0,Max0;\0A\09\09\09\09\09float Min1,Max1;\0A\09\09\09\09\09project(hullA,posA,ornA,&crossje,vertices, &Min0, &Max0);\0A\09\09\09\09\09project(hullB,posB,ornB,&crossje,vertices, &Min1, &Max1);\0A\09\09\09\09\0A\09\09\09\09\09if(Max0<Min1 || Max1<Min0)\0A\09\09\09\09\09\09return false;\0A\09\09\09\09\0A\09\09\09\09\09float d0 = Max0 - Min1;\0A\09\09\09\09\09float d1 = Max1 - Min0;\0A\09\09\09\09\09dist = d0<d1 ? d0:d1;\0A\09\09\09\09\09result = true;\0A\09\09\09\09}\0A\09\09\09\09\0A\09\09\09\09if(dist<*dmin)\0A\09\09\09\09{\0A\09\09\09\09\09*dmin = dist;\0A\09\09\09\09\09*sep = crossje;\0A\09\09\09\09}\0A\09\09\09}\0A\09\09}\0A\09}\0A\09\0A\09if((dot3F4(-DeltaC2,*sep))>0.0f)\0A\09{\0A\09\09*sep = -(*sep);\0A\09}\0A\09return true;\0A}\0A// work-in-progress\0A__kernel void   processCompoundPairsKernel( __global const int4* gpuCompoundPairs,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const BodyData* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btCollidableGpu* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const ConvexPolyhedronCL* convexShapes, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* vertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* uniqueEdges,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btGpuFace* faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global btAabbCL* aabbs,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btGpuChildShape* gpuChildShapes,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global volatile float4* gpuCompoundSepNormalsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global volatile int* gpuHasCompoundSepNormalsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numCompoundPairs\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09)\0A{\0A\09int i = get_global_id(0);\0A\09if (i<numCompoundPairs)\0A\09{\0A\09\09int bodyIndexA = gpuCompoundPairs[i].x;\0A\09\09int bodyIndexB = gpuCompoundPairs[i].y;\0A\09\09int childShapeIndexA = gpuCompoundPairs[i].z;\0A\09\09int childShapeIndexB = gpuCompoundPairs[i].w;\0A\09\09\0A\09\09int collidableIndexA = -1;\0A\09\09int collidableIndexB = -1;\0A\09\09\0A\09\09float4 ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09\0A\09\09float4 ornB = rigidBodies[bodyIndexB].m_quat;\0A\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09\09\09\09\09\0A\09\09if (childShapeIndexA >= 0)\0A\09\09{\0A\09\09\09collidableIndexA = gpuChildShapes[childShapeIndexA].m_shapeIndex;\0A\09\09\09float4 childPosA = gpuChildShapes[childShapeIndexA].m_childPosition;\0A\09\09\09float4 childOrnA = gpuChildShapes[childShapeIndexA].m_childOrientation;\0A\09\09\09float4 newPosA = qtRotate(ornA,childPosA)+posA;\0A\09\09\09float4 newOrnA = qtMul(ornA,childOrnA);\0A\09\09\09posA = newPosA;\0A\09\09\09ornA = newOrnA;\0A\09\09} else\0A\09\09{\0A\09\09\09collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09}\0A\09\09\0A\09\09if (childShapeIndexB>=0)\0A\09\09{\0A\09\09\09collidableIndexB = gpuChildShapes[childShapeIndexB].m_shapeIndex;\0A\09\09\09float4 childPosB = gpuChildShapes[childShapeIndexB].m_childPosition;\0A\09\09\09float4 childOrnB = gpuChildShapes[childShapeIndexB].m_childOrientation;\0A\09\09\09float4 newPosB = transform(&childPosB,&posB,&ornB);\0A\09\09\09float4 newOrnB = qtMul(ornB,childOrnB);\0A\09\09\09posB = newPosB;\0A\09\09\09ornB = newOrnB;\0A\09\09} else\0A\09\09{\0A\09\09\09collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\09\0A\09\09}\0A\09\0A\09\09gpuHasCompoundSepNormalsOut[i] = 0;\0A\09\0A\09\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09\0A\09\09int shapeTypeA = collidables[collidableIndexA].m_shapeType;\0A\09\09int shapeTypeB = collidables[collidableIndexB].m_shapeType;\0A\09\0A\09\09if ((shapeTypeA != SHAPE_CONVEX_HULL) || (shapeTypeB != SHAPE_CONVEX_HULL))\0A\09\09{\0A\09\09\09return;\0A\09\09}\0A\09\09int hasSeparatingAxis = 5;\0A\09\09\09\09\09\09\09\0A\09\09int numFacesA = convexShapes[shapeIndexA].m_numFaces;\0A\09\09float dmin = FLT_MAX;\0A\09\09posA.w = 0.f;\0A\09\09posB.w = 0.f;\0A\09\09float4 c0local = convexShapes[shapeIndexA].m_localCenter;\0A\09\09float4 c0 = transform(&c0local, &posA, &ornA);\0A\09\09float4 c1local = convexShapes[shapeIndexB].m_localCenter;\0A\09\09float4 c1 = transform(&c1local,&posB,&ornB);\0A\09\09const float4 DeltaC2 = c0 - c1;\0A\09\09float4 sepNormal = make_float4(1,0,0,0);\0A\09\09bool sepA = findSeparatingAxis(\09&convexShapes[shapeIndexA], &convexShapes[shapeIndexB],posA,ornA,posB,ornB,DeltaC2,vertices,uniqueEdges,faces,indices,&sepNormal,&dmin);\0A\09\09hasSeparatingAxis = 4;\0A\09\09if (!sepA)\0A\09\09{\0A\09\09\09hasSeparatingAxis = 0;\0A\09\09} else\0A\09\09{\0A\09\09\09bool sepB = findSeparatingAxis(\09&convexShapes[shapeIndexB],&convexShapes[shapeIndexA],posB,ornB,posA,ornA,DeltaC2,vertices,uniqueEdges,faces,indices,&sepNormal,&dmin);\0A\09\09\09if (!sepB)\0A\09\09\09{\0A\09\09\09\09hasSeparatingAxis = 0;\0A\09\09\09} else//(!sepB)\0A\09\09\09{\0A\09\09\09\09bool sepEE = findSeparatingAxisEdgeEdge(\09&convexShapes[shapeIndexA], &convexShapes[shapeIndexB],posA,ornA,posB,ornB,DeltaC2,vertices,uniqueEdges,faces,indices,&sepNormal,&dmin);\0A\09\09\09\09if (sepEE)\0A\09\09\09\09{\0A\09\09\09\09\09\09gpuCompoundSepNormalsOut[i] = sepNormal;//fastNormalize4(sepNormal);\0A\09\09\09\09\09\09gpuHasCompoundSepNormalsOut[i] = 1;\0A\09\09\09\09}//sepEE\0A\09\09\09}//(!sepB)\0A\09\09}//(!sepA)\0A\09\09\0A\09\09\0A\09}\0A\09\09\0A}\0Ainline b3Float4 MyUnQuantize(const unsigned short* vecIn, b3Float4 quantization, b3Float4 bvhAabbMin)\0A{\0A\09\09b3Float4 vecOut;\0A\09\09vecOut = b3MakeFloat4(\0A\09\09\09(float)(vecIn[0]) / (quantization.x),\0A\09\09\09(float)(vecIn[1]) / (quantization.y),\0A\09\09\09(float)(vecIn[2]) / (quantization.z),\0A\09\09\090.f);\0A\09\09vecOut += bvhAabbMin;\0A\09\09return vecOut;\0A}\0Ainline b3Float4 MyUnQuantizeGlobal(__global const unsigned short* vecIn, b3Float4 quantization, b3Float4 bvhAabbMin)\0A{\0A\09\09b3Float4 vecOut;\0A\09\09vecOut = b3MakeFloat4(\0A\09\09\09(float)(vecIn[0]) / (quantization.x),\0A\09\09\09(float)(vecIn[1]) / (quantization.y),\0A\09\09\09(float)(vecIn[2]) / (quantization.z),\0A\09\09\090.f);\0A\09\09vecOut += bvhAabbMin;\0A\09\09return vecOut;\0A}\0A// work-in-progress\0A__kernel void   findCompoundPairsKernel( __global const int4* pairs, \0A\09__global const BodyData* rigidBodies, \0A\09__global const btCollidableGpu* collidables,\0A\09__global const ConvexPolyhedronCL* convexShapes, \0A\09__global const float4* vertices,\0A\09__global const float4* uniqueEdges,\0A\09__global const btGpuFace* faces,\0A\09__global const int* indices,\0A\09__global b3Aabb_t* aabbLocalSpace,\0A\09__global const btGpuChildShape* gpuChildShapes,\0A\09__global volatile int4* gpuCompoundPairsOut,\0A\09__global volatile int* numCompoundPairsOut,\0A\09__global const b3BvhSubtreeInfo* subtrees,\0A\09__global const b3QuantizedBvhNode* quantizedNodes,\0A\09__global const b3BvhInfo* bvhInfos,\0A\09int numPairs,\0A\09int maxNumCompoundPairsCapacity\0A\09)\0A{\0A\09int i = get_global_id(0);\0A\09if (i<numPairs)\0A\09{\0A\09\09int bodyIndexA = pairs[i].x;\0A\09\09int bodyIndexB = pairs[i].y;\0A\09\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09\09//once the broadphase avoids static-static pairs, we can remove this test\0A\09\09if ((rigidBodies[bodyIndexA].m_invMass==0) &&(rigidBodies[bodyIndexB].m_invMass==0))\0A\09\09{\0A\09\09\09return;\0A\09\09}\0A\09\09if ((collidables[collidableIndexA].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS) &&(collidables[collidableIndexB].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS))\0A\09\09{\0A\09\09\09int bvhA = collidables[collidableIndexA].m_compoundBvhIndex;\0A\09\09\09int bvhB = collidables[collidableIndexB].m_compoundBvhIndex;\0A\09\09\09int numSubTreesA = bvhInfos[bvhA].m_numSubTrees;\0A\09\09\09int subTreesOffsetA = bvhInfos[bvhA].m_subTreeOffset;\0A\09\09\09int subTreesOffsetB = bvhInfos[bvhB].m_subTreeOffset;\0A\09\09\09int numSubTreesB = bvhInfos[bvhB].m_numSubTrees;\0A\09\09\09\0A\09\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09\09b3Quat ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09\09b3Quat ornB = rigidBodies[bodyIndexB].m_quat;\0A\09\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09\0A\09\09\09for (int p=0;p<numSubTreesA;p++)\0A\09\09\09{\0A\09\09\09\09b3BvhSubtreeInfo subtreeA = subtrees[subTreesOffsetA+p];\0A\09\09\09\09//bvhInfos[bvhA].m_quantization\0A\09\09\09\09b3Float4 treeAminLocal = MyUnQuantize(subtreeA.m_quantizedAabbMin,bvhInfos[bvhA].m_quantization,bvhInfos[bvhA].m_aabbMin);\0A\09\09\09\09b3Float4 treeAmaxLocal = MyUnQuantize(subtreeA.m_quantizedAabbMax,bvhInfos[bvhA].m_quantization,bvhInfos[bvhA].m_aabbMin);\0A\09\09\09\09b3Float4 aabbAMinOut,aabbAMaxOut;\0A\09\09\09\09float margin=0.f;\0A\09\09\09\09b3TransformAabb2(treeAminLocal,treeAmaxLocal, margin,posA,ornA,&aabbAMinOut,&aabbAMaxOut);\0A\09\09\09\09\0A\09\09\09\09for (int q=0;q<numSubTreesB;q++)\0A\09\09\09\09{\0A\09\09\09\09\09b3BvhSubtreeInfo subtreeB = subtrees[subTreesOffsetB+q];\0A\09\09\09\09\09b3Float4 treeBminLocal = MyUnQuantize(subtreeB.m_quantizedAabbMin,bvhInfos[bvhB].m_quantization,bvhInfos[bvhB].m_aabbMin);\0A\09\09\09\09\09b3Float4 treeBmaxLocal = MyUnQuantize(subtreeB.m_quantizedAabbMax,bvhInfos[bvhB].m_quantization,bvhInfos[bvhB].m_aabbMin);\0A\09\09\09\09\09b3Float4 aabbBMinOut,aabbBMaxOut;\0A\09\09\09\09\09float margin=0.f;\0A\09\09\09\09\09b3TransformAabb2(treeBminLocal,treeBmaxLocal, margin,posB,ornB,&aabbBMinOut,&aabbBMaxOut);\0A\09\09\09\09\09\0A\09\09\09\09\09\0A\09\09\09\09\09bool aabbOverlap = b3TestAabbAgainstAabb(aabbAMinOut,aabbAMaxOut,aabbBMinOut,aabbBMaxOut);\0A\09\09\09\09\09if (aabbOverlap)\0A\09\09\09\09\09{\0A\09\09\09\09\09\09\0A\09\09\09\09\09\09int startNodeIndexA = subtreeA.m_rootNodeIndex+bvhInfos[bvhA].m_nodeOffset;\0A\09\09\09\09\09\09int endNodeIndexA = startNodeIndexA+subtreeA.m_subtreeSize;\0A\09\09\09\09\09\09int startNodeIndexB = subtreeB.m_rootNodeIndex+bvhInfos[bvhB].m_nodeOffset;\0A\09\09\09\09\09\09int endNodeIndexB = startNodeIndexB+subtreeB.m_subtreeSize;\0A\09\09\09\09\09\09b3Int2 nodeStack[B3_MAX_STACK_DEPTH];\0A\09\09\09\09\09\09b3Int2 node0;\0A\09\09\09\09\09\09node0.x = startNodeIndexA;\0A\09\09\09\09\09\09node0.y = startNodeIndexB;\0A\09\09\09\09\09\09int maxStackDepth = B3_MAX_STACK_DEPTH;\0A\09\09\09\09\09\09int depth=0;\0A\09\09\09\09\09\09nodeStack[depth++]=node0;\0A\09\09\09\09\09\09do\0A\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09b3Int2 node = nodeStack[--depth];\0A\09\09\09\09\09\09\09b3Float4 aMinLocal = MyUnQuantizeGlobal(quantizedNodes[node.x].m_quantizedAabbMin,bvhInfos[bvhA].m_quantization,bvhInfos[bvhA].m_aabbMin);\0A\09\09\09\09\09\09\09b3Float4 aMaxLocal = MyUnQuantizeGlobal(quantizedNodes[node.x].m_quantizedAabbMax,bvhInfos[bvhA].m_quantization,bvhInfos[bvhA].m_aabbMin);\0A\09\09\09\09\09\09\09b3Float4 bMinLocal = MyUnQuantizeGlobal(quantizedNodes[node.y].m_quantizedAabbMin,bvhInfos[bvhB].m_quantization,bvhInfos[bvhB].m_aabbMin);\0A\09\09\09\09\09\09\09b3Float4 bMaxLocal = MyUnQuantizeGlobal(quantizedNodes[node.y].m_quantizedAabbMax,bvhInfos[bvhB].m_quantization,bvhInfos[bvhB].m_aabbMin);\0A\09\09\09\09\09\09\09float margin=0.f;\0A\09\09\09\09\09\09\09b3Float4 aabbAMinOut,aabbAMaxOut;\0A\09\09\09\09\09\09\09b3TransformAabb2(aMinLocal,aMaxLocal, margin,posA,ornA,&aabbAMinOut,&aabbAMaxOut);\0A\09\09\09\09\09\09\09b3Float4 aabbBMinOut,aabbBMaxOut;\0A\09\09\09\09\09\09\09b3TransformAabb2(bMinLocal,bMaxLocal, margin,posB,ornB,&aabbBMinOut,&aabbBMaxOut);\0A\09\09\09\09\09\09\09\0A\09\09\09\09\09\09\09bool nodeOverlap = b3TestAabbAgainstAabb(aabbAMinOut,aabbAMaxOut,aabbBMinOut,aabbBMaxOut);\0A\09\09\09\09\09\09\09if (nodeOverlap)\0A\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09bool isLeafA = isLeafNodeGlobal(&quantizedNodes[node.x]);\0A\09\09\09\09\09\09\09\09bool isLeafB = isLeafNodeGlobal(&quantizedNodes[node.y]);\0A\09\09\09\09\09\09\09\09bool isInternalA = !isLeafA;\0A\09\09\09\09\09\09\09\09bool isInternalB = !isLeafB;\0A\09\09\09\09\09\09\09\09//fail, even though it might hit two leaf nodes\0A\09\09\09\09\09\09\09\09if (depth+4>maxStackDepth && !(isLeafA && isLeafB))\0A\09\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09\09//printf(\22Error: traversal exceeded maxStackDepth\22);\0A\09\09\09\09\09\09\09\09\09continue;\0A\09\09\09\09\09\09\09\09}\0A\09\09\09\09\09\09\09\09if(isInternalA)\0A\09\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09\09int nodeAleftChild = node.x+1;\0A\09\09\09\09\09\09\09\09\09bool isNodeALeftChildLeaf = isLeafNodeGlobal(&quantizedNodes[node.x+1]);\0A\09\09\09\09\09\09\09\09\09int nodeArightChild = isNodeALeftChildLeaf? node.x+2 : node.x+1 + getEscapeIndexGlobal(&quantizedNodes[node.x+1]);\0A\09\09\09\09\09\09\09\09\09if(isInternalB)\0A\09\09\09\09\09\09\09\09\09{\09\09\09\09\09\0A\09\09\09\09\09\09\09\09\09\09int nodeBleftChild = node.y+1;\0A\09\09\09\09\09\09\09\09\09\09bool isNodeBLeftChildLeaf = isLeafNodeGlobal(&quantizedNodes[node.y+1]);\0A\09\09\09\09\09\09\09\09\09\09int nodeBrightChild = isNodeBLeftChildLeaf? node.y+2 : node.y+1 + getEscapeIndexGlobal(&quantizedNodes[node.y+1]);\0A\09\09\09\09\09\09\09\09\09\09nodeStack[depth++] = b3MakeInt2(nodeAleftChild, nodeBleftChild);\0A\09\09\09\09\09\09\09\09\09\09nodeStack[depth++] = b3MakeInt2(nodeArightChild, nodeBleftChild);\0A\09\09\09\09\09\09\09\09\09\09nodeStack[depth++] = b3MakeInt2(nodeAleftChild, nodeBrightChild);\0A\09\09\09\09\09\09\09\09\09\09nodeStack[depth++] = b3MakeInt2(nodeArightChild, nodeBrightChild);\0A\09\09\09\09\09\09\09\09\09}\0A\09\09\09\09\09\09\09\09\09else\0A\09\09\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09\09\09nodeStack[depth++] = b3MakeInt2(nodeAleftChild,node.y);\0A\09\09\09\09\09\09\09\09\09\09nodeStack[depth++] = b3MakeInt2(nodeArightChild,node.y);\0A\09\09\09\09\09\09\09\09\09}\0A\09\09\09\09\09\09\09\09}\0A\09\09\09\09\09\09\09\09else\0A\09\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09\09if(isInternalB)\0A\09\09\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09\09\09int nodeBleftChild = node.y+1;\0A\09\09\09\09\09\09\09\09\09\09bool isNodeBLeftChildLeaf = isLeafNodeGlobal(&quantizedNodes[node.y+1]);\0A\09\09\09\09\09\09\09\09\09\09int nodeBrightChild = isNodeBLeftChildLeaf? node.y+2 : node.y+1 + getEscapeIndexGlobal(&quantizedNodes[node.y+1]);\0A\09\09\09\09\09\09\09\09\09\09nodeStack[depth++] = b3MakeInt2(node.x,nodeBleftChild);\0A\09\09\09\09\09\09\09\09\09\09nodeStack[depth++] = b3MakeInt2(node.x,nodeBrightChild);\0A\09\09\09\09\09\09\09\09\09}\0A\09\09\09\09\09\09\09\09\09else\0A\09\09\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09\09\09int compoundPairIdx = atomic_inc(numCompoundPairsOut);\0A\09\09\09\09\09\09\09\09\09\09if (compoundPairIdx<maxNumCompoundPairsCapacity)\0A\09\09\09\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09\09\09\09int childShapeIndexA = getTriangleIndexGlobal(&quantizedNodes[node.x]);\0A\09\09\09\09\09\09\09\09\09\09\09int childShapeIndexB = getTriangleIndexGlobal(&quantizedNodes[node.y]);\0A\09\09\09\09\09\09\09\09\09\09\09gpuCompoundPairsOut[compoundPairIdx]  = (int4)(bodyIndexA,bodyIndexB,childShapeIndexA,childShapeIndexB);\0A\09\09\09\09\09\09\09\09\09\09}\0A\09\09\09\09\09\09\09\09\09}\0A\09\09\09\09\09\09\09\09}\0A\09\09\09\09\09\09\09}\0A\09\09\09\09\09\09} while (depth);\0A\09\09\09\09\09}\0A\09\09\09\09}\0A\09\09\09}\0A\09\09\09\0A\09\09\09return;\0A\09\09}\0A\09\09if ((collidables[collidableIndexA].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS) ||(collidables[collidableIndexB].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS))\0A\09\09{\0A\09\09\09if (collidables[collidableIndexA].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS) \0A\09\09\09{\0A\09\09\09\09int numChildrenA = collidables[collidableIndexA].m_numChildShapes;\0A\09\09\09\09for (int c=0;c<numChildrenA;c++)\0A\09\09\09\09{\0A\09\09\09\09\09int childShapeIndexA = collidables[collidableIndexA].m_shapeIndex+c;\0A\09\09\09\09\09int childColIndexA = gpuChildShapes[childShapeIndexA].m_shapeIndex;\0A\09\09\09\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09\09\09\09float4 ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09\09\09\09float4 childPosA = gpuChildShapes[childShapeIndexA].m_childPosition;\0A\09\09\09\09\09float4 childOrnA = gpuChildShapes[childShapeIndexA].m_childOrientation;\0A\09\09\09\09\09float4 newPosA = qtRotate(ornA,childPosA)+posA;\0A\09\09\09\09\09float4 newOrnA = qtMul(ornA,childOrnA);\0A\09\09\09\09\09int shapeIndexA = collidables[childColIndexA].m_shapeIndex;\0A\09\09\09\09\09b3Aabb_t aabbAlocal = aabbLocalSpace[shapeIndexA];\0A\09\09\09\09\09float margin = 0.f;\0A\09\09\09\09\09\0A\09\09\09\09\09b3Float4 aabbAMinWS;\0A\09\09\09\09\09b3Float4 aabbAMaxWS;\0A\09\09\09\09\09\0A\09\09\09\09\09b3TransformAabb2(aabbAlocal.m_minVec,aabbAlocal.m_maxVec,margin,\0A\09\09\09\09\09\09newPosA,\0A\09\09\09\09\09\09newOrnA,\0A\09\09\09\09\09\09&aabbAMinWS,&aabbAMaxWS);\0A\09\09\09\09\09\09\0A\09\09\09\09\09\0A\09\09\09\09\09if (collidables[collidableIndexB].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS)\0A\09\09\09\09\09{\0A\09\09\09\09\09\09int numChildrenB = collidables[collidableIndexB].m_numChildShapes;\0A\09\09\09\09\09\09for (int b=0;b<numChildrenB;b++)\0A\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09int childShapeIndexB = collidables[collidableIndexB].m_shapeIndex+b;\0A\09\09\09\09\09\09\09int childColIndexB = gpuChildShapes[childShapeIndexB].m_shapeIndex;\0A\09\09\09\09\09\09\09float4 ornB = rigidBodies[bodyIndexB].m_quat;\0A\09\09\09\09\09\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09\09\09\09\09float4 childPosB = gpuChildShapes[childShapeIndexB].m_childPosition;\0A\09\09\09\09\09\09\09float4 childOrnB = gpuChildShapes[childShapeIndexB].m_childOrientation;\0A\09\09\09\09\09\09\09float4 newPosB = transform(&childPosB,&posB,&ornB);\0A\09\09\09\09\09\09\09float4 newOrnB = qtMul(ornB,childOrnB);\0A\09\09\09\09\09\09\09int shapeIndexB = collidables[childColIndexB].m_shapeIndex;\0A\09\09\09\09\09\09\09b3Aabb_t aabbBlocal = aabbLocalSpace[shapeIndexB];\0A\09\09\09\09\09\09\09\0A\09\09\09\09\09\09\09b3Float4 aabbBMinWS;\0A\09\09\09\09\09\09\09b3Float4 aabbBMaxWS;\0A\09\09\09\09\09\09\09\0A\09\09\09\09\09\09\09b3TransformAabb2(aabbBlocal.m_minVec,aabbBlocal.m_maxVec,margin,\0A\09\09\09\09\09\09\09\09newPosB,\0A\09\09\09\09\09\09\09\09newOrnB,\0A\09\09\09\09\09\09\09\09&aabbBMinWS,&aabbBMaxWS);\0A\09\09\09\09\09\09\09\09\0A\09\09\09\09\09\09\09\09\0A\09\09\09\09\09\09\09\0A\09\09\09\09\09\09\09bool aabbOverlap = b3TestAabbAgainstAabb(aabbAMinWS,aabbAMaxWS,aabbBMinWS,aabbBMaxWS);\0A\09\09\09\09\09\09\09if (aabbOverlap)\0A\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09int numFacesA = convexShapes[shapeIndexA].m_numFaces;\0A\09\09\09\09\09\09\09\09float dmin = FLT_MAX;\0A\09\09\09\09\09\09\09\09float4 posA = newPosA;\0A\09\09\09\09\09\09\09\09posA.w = 0.f;\0A\09\09\09\09\09\09\09\09float4 posB = newPosB;\0A\09\09\09\09\09\09\09\09posB.w = 0.f;\0A\09\09\09\09\09\09\09\09float4 c0local = convexShapes[shapeIndexA].m_localCenter;\0A\09\09\09\09\09\09\09\09float4 ornA = newOrnA;\0A\09\09\09\09\09\09\09\09float4 c0 = transform(&c0local, &posA, &ornA);\0A\09\09\09\09\09\09\09\09float4 c1local = convexShapes[shapeIndexB].m_localCenter;\0A\09\09\09\09\09\09\09\09float4 ornB =newOrnB;\0A\09\09\09\09\09\09\09\09float4 c1 = transform(&c1local,&posB,&ornB);\0A\09\09\09\09\09\09\09\09const float4 DeltaC2 = c0 - c1;\0A\09\09\09\09\09\09\09\09{//\0A\09\09\09\09\09\09\09\09\09int compoundPairIdx = atomic_inc(numCompoundPairsOut);\0A\09\09\09\09\09\09\09\09\09if (compoundPairIdx<maxNumCompoundPairsCapacity)\0A\09\09\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09\09\09gpuCompoundPairsOut[compoundPairIdx]  = (int4)(bodyIndexA,bodyIndexB,childShapeIndexA,childShapeIndexB);\0A\09\09\09\09\09\09\09\09\09}\0A\09\09\09\09\09\09\09\09}//\0A\09\09\09\09\09\09\09}//fi(1)\0A\09\09\09\09\09\09} //for (int b=0\0A\09\09\09\09\09}//if (collidables[collidableIndexB].\0A\09\09\09\09\09else//if (collidables[collidableIndexB].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS)\0A\09\09\09\09\09{\0A\09\09\09\09\09\09if (1)\0A\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09int numFacesA = convexShapes[shapeIndexA].m_numFaces;\0A\09\09\09\09\09\09\09float dmin = FLT_MAX;\0A\09\09\09\09\09\09\09float4 posA = newPosA;\0A\09\09\09\09\09\09\09posA.w = 0.f;\0A\09\09\09\09\09\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09\09\09\09\09posB.w = 0.f;\0A\09\09\09\09\09\09\09float4 c0local = convexShapes[shapeIndexA].m_localCenter;\0A\09\09\09\09\09\09\09float4 ornA = newOrnA;\0A\09\09\09\09\09\09\09float4 c0 = transform(&c0local, &posA, &ornA);\0A\09\09\09\09\09\09\09float4 c1local = convexShapes[shapeIndexB].m_localCenter;\0A\09\09\09\09\09\09\09float4 ornB = rigidBodies[bodyIndexB].m_quat;\0A\09\09\09\09\09\09\09float4 c1 = transform(&c1local,&posB,&ornB);\0A\09\09\09\09\09\09\09const float4 DeltaC2 = c0 - c1;\0A\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09int compoundPairIdx = atomic_inc(numCompoundPairsOut);\0A\09\09\09\09\09\09\09\09if (compoundPairIdx<maxNumCompoundPairsCapacity)\0A\09\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09\09gpuCompoundPairsOut[compoundPairIdx] = (int4)(bodyIndexA,bodyIndexB,childShapeIndexA,-1);\0A\09\09\09\09\09\09\09\09}//if (compoundPairIdx<maxNumCompoundPairsCapacity)\0A\09\09\09\09\09\09\09}//\0A\09\09\09\09\09\09}//fi (1)\0A\09\09\09\09\09}//if (collidables[collidableIndexB].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS)\0A\09\09\09\09}//for (int b=0;b<numChildrenB;b++)\09\0A\09\09\09\09return;\0A\09\09\09}//if (collidables[collidableIndexB].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS)\0A\09\09\09if ((collidables[collidableIndexA].m_shapeType!=SHAPE_CONCAVE_TRIMESH) \0A\09\09\09\09&& (collidables[collidableIndexB].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS))\0A\09\09\09{\0A\09\09\09\09int numChildrenB = collidables[collidableIndexB].m_numChildShapes;\0A\09\09\09\09for (int b=0;b<numChildrenB;b++)\0A\09\09\09\09{\0A\09\09\09\09\09int childShapeIndexB = collidables[collidableIndexB].m_shapeIndex+b;\0A\09\09\09\09\09int childColIndexB = gpuChildShapes[childShapeIndexB].m_shapeIndex;\0A\09\09\09\09\09float4 ornB = rigidBodies[bodyIndexB].m_quat;\0A\09\09\09\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09\09\09float4 childPosB = gpuChildShapes[childShapeIndexB].m_childPosition;\0A\09\09\09\09\09float4 childOrnB = gpuChildShapes[childShapeIndexB].m_childOrientation;\0A\09\09\09\09\09float4 newPosB = qtRotate(ornB,childPosB)+posB;\0A\09\09\09\09\09float4 newOrnB = qtMul(ornB,childOrnB);\0A\09\09\09\09\09int shapeIndexB = collidables[childColIndexB].m_shapeIndex;\0A\09\09\09\09\09//////////////////////////////////////\0A\09\09\09\09\09if (1)\0A\09\09\09\09\09{\0A\09\09\09\09\09\09int numFacesA = convexShapes[shapeIndexA].m_numFaces;\0A\09\09\09\09\09\09float dmin = FLT_MAX;\0A\09\09\09\09\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09\09\09\09\09posA.w = 0.f;\0A\09\09\09\09\09\09float4 posB = newPosB;\0A\09\09\09\09\09\09posB.w = 0.f;\0A\09\09\09\09\09\09float4 c0local = convexShapes[shapeIndexA].m_localCenter;\0A\09\09\09\09\09\09float4 ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09\09\09\09\09float4 c0 = transform(&c0local, &posA, &ornA);\0A\09\09\09\09\09\09float4 c1local = convexShapes[shapeIndexB].m_localCenter;\0A\09\09\09\09\09\09float4 ornB =newOrnB;\0A\09\09\09\09\09\09float4 c1 = transform(&c1local,&posB,&ornB);\0A\09\09\09\09\09\09const float4 DeltaC2 = c0 - c1;\0A\09\09\09\09\09\09{//\0A\09\09\09\09\09\09\09int compoundPairIdx = atomic_inc(numCompoundPairsOut);\0A\09\09\09\09\09\09\09if (compoundPairIdx<maxNumCompoundPairsCapacity)\0A\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09gpuCompoundPairsOut[compoundPairIdx] = (int4)(bodyIndexA,bodyIndexB,-1,childShapeIndexB);\0A\09\09\09\09\09\09\09}//fi (compoundPairIdx<maxNumCompoundPairsCapacity)\0A\09\09\09\09\09\09}//\0A\09\09\09\09\09}//fi (1)\09\0A\09\09\09\09}//for (int b=0;b<numChildrenB;b++)\0A\09\09\09\09return;\0A\09\09\09}//if (collidables[collidableIndexB].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS)\0A\09\09\09return;\0A\09\09}//fi ((collidables[collidableIndexA].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS) ||(collidables[collidableIndexB].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS))\0A\09}//i<numPairs\0A}\0A// work-in-progress\0A__kernel void   findSeparatingAxisKernel( __global const int4* pairs, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const BodyData* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btCollidableGpu* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const ConvexPolyhedronCL* convexShapes, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* vertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* uniqueEdges,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btGpuFace* faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global btAabbCL* aabbs,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global volatile float4* separatingNormals,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global volatile int* hasSeparatingAxis,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numPairs\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09)\0A{\0A\09int i = get_global_id(0);\0A\09\0A\09if (i<numPairs)\0A\09{\0A\09\0A\09\09int bodyIndexA = pairs[i].x;\0A\09\09int bodyIndexB = pairs[i].y;\0A\09\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09\0A\09\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09\09\0A\09\09\0A\09\09//once the broadphase avoids static-static pairs, we can remove this test\0A\09\09if ((rigidBodies[bodyIndexA].m_invMass==0) &&(rigidBodies[bodyIndexB].m_invMass==0))\0A\09\09{\0A\09\09\09hasSeparatingAxis[i] = 0;\0A\09\09\09return;\0A\09\09}\0A\09\09\0A\09\09if ((collidables[collidableIndexA].m_shapeType!=SHAPE_CONVEX_HULL) ||(collidables[collidableIndexB].m_shapeType!=SHAPE_CONVEX_HULL))\0A\09\09{\0A\09\09\09hasSeparatingAxis[i] = 0;\0A\09\09\09return;\0A\09\09}\0A\09\09\09\0A\09\09if ((collidables[collidableIndexA].m_shapeType==SHAPE_CONCAVE_TRIMESH))\0A\09\09{\0A\09\09\09hasSeparatingAxis[i] = 0;\0A\09\09\09return;\0A\09\09}\0A\09\09int numFacesA = convexShapes[shapeIndexA].m_numFaces;\0A\09\09float dmin = FLT_MAX;\0A\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09posA.w = 0.f;\0A\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09posB.w = 0.f;\0A\09\09float4 c0local = convexShapes[shapeIndexA].m_localCenter;\0A\09\09float4 ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09float4 c0 = transform(&c0local, &posA, &ornA);\0A\09\09float4 c1local = convexShapes[shapeIndexB].m_localCenter;\0A\09\09float4 ornB =rigidBodies[bodyIndexB].m_quat;\0A\09\09float4 c1 = transform(&c1local,&posB,&ornB);\0A\09\09const float4 DeltaC2 = c0 - c1;\0A\09\09float4 sepNormal;\0A\09\09\0A\09\09bool sepA = findSeparatingAxis(\09&convexShapes[shapeIndexA], &convexShapes[shapeIndexB],posA,ornA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09posB,ornB,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09DeltaC2,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09vertices,uniqueEdges,faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09indices,&sepNormal,&dmin);\0A\09\09hasSeparatingAxis[i] = 4;\0A\09\09if (!sepA)\0A\09\09{\0A\09\09\09hasSeparatingAxis[i] = 0;\0A\09\09} else\0A\09\09{\0A\09\09\09bool sepB = findSeparatingAxis(\09&convexShapes[shapeIndexB],&convexShapes[shapeIndexA],posB,ornB,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09posA,ornA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09DeltaC2,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09vertices,uniqueEdges,faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09indices,&sepNormal,&dmin);\0A\09\09\09if (!sepB)\0A\09\09\09{\0A\09\09\09\09hasSeparatingAxis[i] = 0;\0A\09\09\09} else\0A\09\09\09{\0A\09\09\09\09bool sepEE = findSeparatingAxisEdgeEdge(\09&convexShapes[shapeIndexA], &convexShapes[shapeIndexB],posA,ornA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09posB,ornB,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09DeltaC2,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09vertices,uniqueEdges,faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09indices,&sepNormal,&dmin);\0A\09\09\09\09if (!sepEE)\0A\09\09\09\09{\0A\09\09\09\09\09hasSeparatingAxis[i] = 0;\0A\09\09\09\09} else\0A\09\09\09\09{\0A\09\09\09\09\09hasSeparatingAxis[i] = 1;\0A\09\09\09\09\09separatingNormals[i] = sepNormal;\0A\09\09\09\09}\0A\09\09\09}\0A\09\09}\0A\09\09\0A\09}\0A}\0A__kernel void   findSeparatingAxisVertexFaceKernel( __global const int4* pairs, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const BodyData* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btCollidableGpu* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const ConvexPolyhedronCL* convexShapes, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* vertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* uniqueEdges,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btGpuFace* faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global btAabbCL* aabbs,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global volatile float4* separatingNormals,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global volatile int* hasSeparatingAxis,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global  float* dmins,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numPairs\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09)\0A{\0A\09int i = get_global_id(0);\0A\09\0A\09if (i<numPairs)\0A\09{\0A\09\0A\09\09int bodyIndexA = pairs[i].x;\0A\09\09int bodyIndexB = pairs[i].y;\0A\09\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09\0A\09\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09\0A\09\09hasSeparatingAxis[i] = 0;\09\0A\09\09\0A\09\09//once the broadphase avoids static-static pairs, we can remove this test\0A\09\09if ((rigidBodies[bodyIndexA].m_invMass==0) &&(rigidBodies[bodyIndexB].m_invMass==0))\0A\09\09{\0A\09\09\09return;\0A\09\09}\0A\09\09\0A\09\09if ((collidables[collidableIndexA].m_shapeType!=SHAPE_CONVEX_HULL) ||(collidables[collidableIndexB].m_shapeType!=SHAPE_CONVEX_HULL))\0A\09\09{\0A\09\09\09return;\0A\09\09}\0A\09\09\09\0A\09\09int numFacesA = convexShapes[shapeIndexA].m_numFaces;\0A\09\09float dmin = FLT_MAX;\0A\09\09dmins[i] = dmin;\0A\09\09\0A\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09posA.w = 0.f;\0A\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09posB.w = 0.f;\0A\09\09float4 c0local = convexShapes[shapeIndexA].m_localCenter;\0A\09\09float4 ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09float4 c0 = transform(&c0local, &posA, &ornA);\0A\09\09float4 c1local = convexShapes[shapeIndexB].m_localCenter;\0A\09\09float4 ornB =rigidBodies[bodyIndexB].m_quat;\0A\09\09float4 c1 = transform(&c1local,&posB,&ornB);\0A\09\09const float4 DeltaC2 = c0 - c1;\0A\09\09float4 sepNormal;\0A\09\09\0A\09\09bool sepA = findSeparatingAxis(\09&convexShapes[shapeIndexA], &convexShapes[shapeIndexB],posA,ornA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09posB,ornB,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09DeltaC2,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09vertices,uniqueEdges,faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09indices,&sepNormal,&dmin);\0A\09\09hasSeparatingAxis[i] = 4;\0A\09\09if (!sepA)\0A\09\09{\0A\09\09\09hasSeparatingAxis[i] = 0;\0A\09\09} else\0A\09\09{\0A\09\09\09bool sepB = findSeparatingAxis(\09&convexShapes[shapeIndexB],&convexShapes[shapeIndexA],posB,ornB,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09posA,ornA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09DeltaC2,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09vertices,uniqueEdges,faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09indices,&sepNormal,&dmin);\0A\09\09\09if (sepB)\0A\09\09\09{\0A\09\09\09\09dmins[i] = dmin;\0A\09\09\09\09hasSeparatingAxis[i] = 1;\0A\09\09\09\09separatingNormals[i] = sepNormal;\0A\09\09\09}\0A\09\09}\0A\09\09\0A\09}\0A}\0A__kernel void   findSeparatingAxisEdgeEdgeKernel( __global const int4* pairs, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const BodyData* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btCollidableGpu* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const ConvexPolyhedronCL* convexShapes, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* vertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* uniqueEdges,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btGpuFace* faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global btAabbCL* aabbs,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global  float4* separatingNormals,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global  int* hasSeparatingAxis,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global  float* dmins,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* unitSphereDirections,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numUnitSphereDirections,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numPairs\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09)\0A{\0A\09int i = get_global_id(0);\0A\09\0A\09if (i<numPairs)\0A\09{\0A\09\09if (hasSeparatingAxis[i])\0A\09\09{\0A\09\0A\09\09\09int bodyIndexA = pairs[i].x;\0A\09\09\09int bodyIndexB = pairs[i].y;\0A\09\0A\09\09\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09\09\0A\09\09\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09\09\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09\09\09\0A\09\09\09\0A\09\09\09int numFacesA = convexShapes[shapeIndexA].m_numFaces;\0A\09\0A\09\09\09float dmin = dmins[i];\0A\09\0A\09\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09\09posA.w = 0.f;\0A\09\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09posB.w = 0.f;\0A\09\09\09float4 c0local = convexShapes[shapeIndexA].m_localCenter;\0A\09\09\09float4 ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09\09float4 c0 = transform(&c0local, &posA, &ornA);\0A\09\09\09float4 c1local = convexShapes[shapeIndexB].m_localCenter;\0A\09\09\09float4 ornB =rigidBodies[bodyIndexB].m_quat;\0A\09\09\09float4 c1 = transform(&c1local,&posB,&ornB);\0A\09\09\09const float4 DeltaC2 = c0 - c1;\0A\09\09\09float4 sepNormal = separatingNormals[i];\0A\09\09\09\0A\09\09\09\0A\09\09\09\0A\09\09\09bool sepEE = false;\0A\09\09\09int numEdgeEdgeDirections = convexShapes[shapeIndexA].m_numUniqueEdges*convexShapes[shapeIndexB].m_numUniqueEdges;\0A\09\09\09if (numEdgeEdgeDirections<=numUnitSphereDirections)\0A\09\09\09{\0A\09\09\09\09sepEE = findSeparatingAxisEdgeEdge(\09&convexShapes[shapeIndexA], &convexShapes[shapeIndexB],posA,ornA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09posB,ornB,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09DeltaC2,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09vertices,uniqueEdges,faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09indices,&sepNormal,&dmin);\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\0A\09\09\09\09\09if (!sepEE)\0A\09\09\09\09\09{\0A\09\09\09\09\09\09hasSeparatingAxis[i] = 0;\0A\09\09\09\09\09} else\0A\09\09\09\09\09{\0A\09\09\09\09\09\09hasSeparatingAxis[i] = 1;\0A\09\09\09\09\09\09separatingNormals[i] = sepNormal;\0A\09\09\09\09\09}\0A\09\09\09}\0A\09\09\09/*\0A\09\09\09///else case is a separate kernel, to make Mac OSX OpenCL compiler happy\0A\09\09\09else\0A\09\09\09{\0A\09\09\09\09sepEE = findSeparatingAxisUnitSphere(&convexShapes[shapeIndexA], &convexShapes[shapeIndexB],posA,ornA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09posB,ornB,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09DeltaC2,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09vertices,unitSphereDirections,numUnitSphereDirections,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09&sepNormal,&dmin);\0A\09\09\09\09\09if (!sepEE)\0A\09\09\09\09\09{\0A\09\09\09\09\09\09hasSeparatingAxis[i] = 0;\0A\09\09\09\09\09} else\0A\09\09\09\09\09{\0A\09\09\09\09\09\09hasSeparatingAxis[i] = 1;\0A\09\09\09\09\09\09separatingNormals[i] = sepNormal;\0A\09\09\09\09\09}\0A\09\09\09}\0A\09\09\09*/\0A\09\09}\09\09//if (hasSeparatingAxis[i])\0A\09}//(i<numPairs)\0A}\0Ainline int\09findClippingFaces(const float4 separatingNormal,\0A                      const ConvexPolyhedronCL* hullA, \0A\09\09\09\09\09  __global const ConvexPolyhedronCL* hullB,\0A                      const float4 posA, const Quaternion ornA,const float4 posB, const Quaternion ornB,\0A                       __global float4* worldVertsA1,\0A                      __global float4* worldNormalsA1,\0A                      __global float4* worldVertsB1,\0A                      int capacityWorldVerts,\0A                      const float minDist, float maxDist,\0A\09\09\09\09\09  const float4* verticesA,\0A                      const btGpuFace* facesA,\0A                      const int* indicesA,\0A\09\09\09\09\09  __global const float4* verticesB,\0A                      __global const btGpuFace* facesB,\0A                      __global const int* indicesB,\0A                      __global int4* clippingFaces, int pairIndex)\0A{\0A\09int numContactsOut = 0;\0A\09int numWorldVertsB1= 0;\0A    \0A    \0A\09int closestFaceB=0;\0A\09float dmax = -FLT_MAX;\0A    \0A\09{\0A\09\09for(int face=0;face<hullB->m_numFaces;face++)\0A\09\09{\0A\09\09\09const float4 Normal = make_float4(facesB[hullB->m_faceOffset+face].m_plane.x,\0A                                              facesB[hullB->m_faceOffset+face].m_plane.y, facesB[hullB->m_faceOffset+face].m_plane.z,0.f);\0A\09\09\09const float4 WorldNormal = qtRotate(ornB, Normal);\0A\09\09\09float d = dot3F4(WorldNormal,separatingNormal);\0A\09\09\09if (d > dmax)\0A\09\09\09{\0A\09\09\09\09dmax = d;\0A\09\09\09\09closestFaceB = face;\0A\09\09\09}\0A\09\09}\0A\09}\0A    \0A\09{\0A\09\09const btGpuFace polyB = facesB[hullB->m_faceOffset+closestFaceB];\0A\09\09int numVertices = polyB.m_numIndices;\0A        if (numVertices>capacityWorldVerts)\0A            numVertices = capacityWorldVerts;\0A        \0A\09\09for(int e0=0;e0<numVertices;e0++)\0A\09\09{\0A            if (e0<capacityWorldVerts)\0A            {\0A                const float4 b = verticesB[hullB->m_vertexOffset+indicesB[polyB.m_indexOffset+e0]];\0A                worldVertsB1[pairIndex*capacityWorldVerts+numWorldVertsB1++] = transform(&b,&posB,&ornB);\0A            }\0A\09\09}\0A\09}\0A    \0A    int closestFaceA=0;\0A\09{\0A\09\09float dmin = FLT_MAX;\0A\09\09for(int face=0;face<hullA->m_numFaces;face++)\0A\09\09{\0A\09\09\09const float4 Normal = make_float4(\0A                                              facesA[hullA->m_faceOffset+face].m_plane.x,\0A                                              facesA[hullA->m_faceOffset+face].m_plane.y,\0A                                              facesA[hullA->m_faceOffset+face].m_plane.z,\0A                                              0.f);\0A\09\09\09const float4 faceANormalWS = qtRotate(ornA,Normal);\0A            \0A\09\09\09float d = dot3F4(faceANormalWS,separatingNormal);\0A\09\09\09if (d < dmin)\0A\09\09\09{\0A\09\09\09\09dmin = d;\0A\09\09\09\09closestFaceA = face;\0A                worldNormalsA1[pairIndex] = faceANormalWS;\0A\09\09\09}\0A\09\09}\0A\09}\0A    \0A    int numVerticesA = facesA[hullA->m_faceOffset+closestFaceA].m_numIndices;\0A    if (numVerticesA>capacityWorldVerts)\0A       numVerticesA = capacityWorldVerts;\0A    \0A\09for(int e0=0;e0<numVerticesA;e0++)\0A\09{\0A        if (e0<capacityWorldVerts)\0A        {\0A            const float4 a = verticesA[hullA->m_vertexOffset+indicesA[facesA[hullA->m_faceOffset+closestFaceA].m_indexOffset+e0]];\0A            worldVertsA1[pairIndex*capacityWorldVerts+e0] = transform(&a, &posA,&ornA);\0A        }\0A    }\0A    \0A    clippingFaces[pairIndex].x = closestFaceA;\0A    clippingFaces[pairIndex].y = closestFaceB;\0A    clippingFaces[pairIndex].z = numVerticesA;\0A    clippingFaces[pairIndex].w = numWorldVertsB1;\0A    \0A    \0A\09return numContactsOut;\0A}\0A// work-in-progress\0A__kernel void   findConcaveSeparatingAxisKernel( __global int4* concavePairs,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const BodyData* rigidBodies,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btCollidableGpu* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const ConvexPolyhedronCL* convexShapes, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* vertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* uniqueEdges,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btGpuFace* faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btGpuChildShape* gpuChildShapes,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global btAabbCL* aabbs,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global float4* concaveSeparatingNormalsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global int* concaveHasSeparatingNormals,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global int4* clippingFacesOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global float4* worldVertsA1GPU,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global float4*  worldNormalsAGPU,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global float4* worldVertsB1GPU,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int vertexFaceCapacity,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numConcavePairs\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09)\0A{\0A\09int i = get_global_id(0);\0A\09if (i>=numConcavePairs)\0A\09\09return;\0A\09concaveHasSeparatingNormals[i] = 0;\0A\09int pairIdx = i;\0A\09int bodyIndexA = concavePairs[i].x;\0A\09int bodyIndexB = concavePairs[i].y;\0A\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09if (collidables[collidableIndexB].m_shapeType!=SHAPE_CONVEX_HULL&&\0A\09\09collidables[collidableIndexB].m_shapeType!=SHAPE_COMPOUND_OF_CONVEX_HULLS)\0A\09{\0A\09\09concavePairs[pairIdx].w = -1;\0A\09\09return;\0A\09}\0A\09int numFacesA = convexShapes[shapeIndexA].m_numFaces;\0A\09int numActualConcaveConvexTests = 0;\0A\09\0A\09int f = concavePairs[i].z;\0A\09\0A\09bool overlap = false;\0A\09\0A\09ConvexPolyhedronCL convexPolyhedronA;\0A\09//add 3 vertices of the triangle\0A\09convexPolyhedronA.m_numVertices = 3;\0A\09convexPolyhedronA.m_vertexOffset = 0;\0A\09float4\09localCenter = make_float4(0.f,0.f,0.f,0.f);\0A\09btGpuFace face = faces[convexShapes[shapeIndexA].m_faceOffset+f];\0A\09float4 triMinAabb, triMaxAabb;\0A\09btAabbCL triAabb;\0A\09triAabb.m_min = make_float4(1e30f,1e30f,1e30f,0.f);\0A\09triAabb.m_max = make_float4(-1e30f,-1e30f,-1e30f,0.f);\0A\09\0A\09float4 verticesA[3];\0A\09for (int i=0;i<3;i++)\0A\09{\0A\09\09int index = indices[face.m_indexOffset+i];\0A\09\09float4 vert = vertices[convexShapes[shapeIndexA].m_vertexOffset+index];\0A\09\09verticesA[i] = vert;\0A\09\09localCenter += vert;\0A\09\09\09\0A\09\09triAabb.m_min = min(triAabb.m_min,vert);\09\09\0A\09\09triAabb.m_max = max(triAabb.m_max,vert);\09\09\0A\09}\0A\09overlap = true;\0A\09overlap = (triAabb.m_min.x > aabbs[bodyIndexB].m_max.x || triAabb.m_max.x < aabbs[bodyIndexB].m_min.x) ? false : overlap;\0A\09overlap = (triAabb.m_min.z > aabbs[bodyIndexB].m_max.z || triAabb.m_max.z < aabbs[bodyIndexB].m_min.z) ? false : overlap;\0A\09overlap = (triAabb.m_min.y > aabbs[bodyIndexB].m_max.y || triAabb.m_max.y < aabbs[bodyIndexB].m_min.y) ? false : overlap;\0A\09\09\0A\09if (overlap)\0A\09{\0A\09\09float dmin = FLT_MAX;\0A\09\09int hasSeparatingAxis=5;\0A\09\09float4 sepAxis=make_float4(1,2,3,4);\0A\09\09int localCC=0;\0A\09\09numActualConcaveConvexTests++;\0A\09\09//a triangle has 3 unique edges\0A\09\09convexPolyhedronA.m_numUniqueEdges = 3;\0A\09\09convexPolyhedronA.m_uniqueEdgesOffset = 0;\0A\09\09float4 uniqueEdgesA[3];\0A\09\09\0A\09\09uniqueEdgesA[0] = (verticesA[1]-verticesA[0]);\0A\09\09uniqueEdgesA[1] = (verticesA[2]-verticesA[1]);\0A\09\09uniqueEdgesA[2] = (verticesA[0]-verticesA[2]);\0A\09\09convexPolyhedronA.m_faceOffset = 0;\0A                                  \0A\09\09float4 normal = make_float4(face.m_plane.x,face.m_plane.y,face.m_plane.z,0.f);\0A                             \0A\09\09btGpuFace facesA[TRIANGLE_NUM_CONVEX_FACES];\0A\09\09int indicesA[3+3+2+2+2];\0A\09\09int curUsedIndices=0;\0A\09\09int fidx=0;\0A\09\09//front size of triangle\0A\09\09{\0A\09\09\09facesA[fidx].m_indexOffset=curUsedIndices;\0A\09\09\09indicesA[0] = 0;\0A\09\09\09indicesA[1] = 1;\0A\09\09\09indicesA[2] = 2;\0A\09\09\09curUsedIndices+=3;\0A\09\09\09float c = face.m_plane.w;\0A\09\09\09facesA[fidx].m_plane.x = normal.x;\0A\09\09\09facesA[fidx].m_plane.y = normal.y;\0A\09\09\09facesA[fidx].m_plane.z = normal.z;\0A\09\09\09facesA[fidx].m_plane.w = c;\0A\09\09\09facesA[fidx].m_numIndices=3;\0A\09\09}\0A\09\09fidx++;\0A\09\09//back size of triangle\0A\09\09{\0A\09\09\09facesA[fidx].m_indexOffset=curUsedIndices;\0A\09\09\09indicesA[3]=2;\0A\09\09\09indicesA[4]=1;\0A\09\09\09indicesA[5]=0;\0A\09\09\09curUsedIndices+=3;\0A\09\09\09float c = dot(normal,verticesA[0]);\0A\09\09\09float c1 = -face.m_plane.w;\0A\09\09\09facesA[fidx].m_plane.x = -normal.x;\0A\09\09\09facesA[fidx].m_plane.y = -normal.y;\0A\09\09\09facesA[fidx].m_plane.z = -normal.z;\0A\09\09\09facesA[fidx].m_plane.w = c;\0A\09\09\09facesA[fidx].m_numIndices=3;\0A\09\09}\0A\09\09fidx++;\0A\09\09bool addEdgePlanes = true;\0A\09\09if (addEdgePlanes)\0A\09\09{\0A\09\09\09int numVertices=3;\0A\09\09\09int prevVertex = numVertices-1;\0A\09\09\09for (int i=0;i<numVertices;i++)\0A\09\09\09{\0A\09\09\09\09float4 v0 = verticesA[i];\0A\09\09\09\09float4 v1 = verticesA[prevVertex];\0A                                            \0A\09\09\09\09float4 edgeNormal = normalize(cross(normal,v1-v0));\0A\09\09\09\09float c = -dot(edgeNormal,v0);\0A\09\09\09\09facesA[fidx].m_numIndices = 2;\0A\09\09\09\09facesA[fidx].m_indexOffset=curUsedIndices;\0A\09\09\09\09indicesA[curUsedIndices++]=i;\0A\09\09\09\09indicesA[curUsedIndices++]=prevVertex;\0A                                            \0A\09\09\09\09facesA[fidx].m_plane.x = edgeNormal.x;\0A\09\09\09\09facesA[fidx].m_plane.y = edgeNormal.y;\0A\09\09\09\09facesA[fidx].m_plane.z = edgeNormal.z;\0A\09\09\09\09facesA[fidx].m_plane.w = c;\0A\09\09\09\09fidx++;\0A\09\09\09\09prevVertex = i;\0A\09\09\09}\0A\09\09}\0A\09\09convexPolyhedronA.m_numFaces = TRIANGLE_NUM_CONVEX_FACES;\0A\09\09convexPolyhedronA.m_localCenter = localCenter*(1.f/3.f);\0A\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09posA.w = 0.f;\0A\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09posB.w = 0.f;\0A\09\09float4 ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09float4 ornB =rigidBodies[bodyIndexB].m_quat;\0A\09\09\0A\09\09///////////////////\0A\09\09///compound shape support\0A\09\09if (collidables[collidableIndexB].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS)\0A\09\09{\0A\09\09\09int compoundChild = concavePairs[pairIdx].w;\0A\09\09\09int childShapeIndexB = compoundChild;//collidables[collidableIndexB].m_shapeIndex+compoundChild;\0A\09\09\09int childColIndexB = gpuChildShapes[childShapeIndexB].m_shapeIndex;\0A\09\09\09float4 childPosB = gpuChildShapes[childShapeIndexB].m_childPosition;\0A\09\09\09float4 childOrnB = gpuChildShapes[childShapeIndexB].m_childOrientation;\0A\09\09\09float4 newPosB = transform(&childPosB,&posB,&ornB);\0A\09\09\09float4 newOrnB = qtMul(ornB,childOrnB);\0A\09\09\09posB = newPosB;\0A\09\09\09ornB = newOrnB;\0A\09\09\09shapeIndexB = collidables[childColIndexB].m_shapeIndex;\0A\09\09}\0A\09\09//////////////////\0A\09\09float4 c0local = convexPolyhedronA.m_localCenter;\0A\09\09float4 c0 = transform(&c0local, &posA, &ornA);\0A\09\09float4 c1local = convexShapes[shapeIndexB].m_localCenter;\0A\09\09float4 c1 = transform(&c1local,&posB,&ornB);\0A\09\09const float4 DeltaC2 = c0 - c1;\0A\09\09bool sepA = findSeparatingAxisLocalA(\09&convexPolyhedronA, &convexShapes[shapeIndexB],\0A\09\09\09\09\09\09\09\09\09\09\09\09posA,ornA,\0A\09\09\09\09\09\09\09\09\09\09\09\09posB,ornB,\0A\09\09\09\09\09\09\09\09\09\09\09\09DeltaC2,\0A\09\09\09\09\09\09\09\09\09\09\09\09verticesA,uniqueEdgesA,facesA,indicesA,\0A\09\09\09\09\09\09\09\09\09\09\09\09vertices,uniqueEdges,faces,indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09&sepAxis,&dmin);\0A\09\09hasSeparatingAxis = 4;\0A\09\09if (!sepA)\0A\09\09{\0A\09\09\09hasSeparatingAxis = 0;\0A\09\09} else\0A\09\09{\0A\09\09\09bool sepB = findSeparatingAxisLocalB(\09&convexShapes[shapeIndexB],&convexPolyhedronA,\0A\09\09\09\09\09\09\09\09\09\09\09\09posB,ornB,\0A\09\09\09\09\09\09\09\09\09\09\09\09posA,ornA,\0A\09\09\09\09\09\09\09\09\09\09\09\09DeltaC2,\0A\09\09\09\09\09\09\09\09\09\09\09\09vertices,uniqueEdges,faces,indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09verticesA,uniqueEdgesA,facesA,indicesA,\0A\09\09\09\09\09\09\09\09\09\09\09\09&sepAxis,&dmin);\0A\09\09\09if (!sepB)\0A\09\09\09{\0A\09\09\09\09hasSeparatingAxis = 0;\0A\09\09\09} else\0A\09\09\09{\0A\09\09\09\09bool sepEE = findSeparatingAxisEdgeEdgeLocalA(\09&convexPolyhedronA, &convexShapes[shapeIndexB],\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09posA,ornA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09posB,ornB,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09DeltaC2,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09verticesA,uniqueEdgesA,facesA,indicesA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09vertices,uniqueEdges,faces,indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09&sepAxis,&dmin);\0A\09\0A\09\09\09\09if (!sepEE)\0A\09\09\09\09{\0A\09\09\09\09\09hasSeparatingAxis = 0;\0A\09\09\09\09} else\0A\09\09\09\09{\0A\09\09\09\09\09hasSeparatingAxis = 1;\0A\09\09\09\09}\0A\09\09\09}\0A\09\09}\09\0A\09\09\0A\09\09if (hasSeparatingAxis)\0A\09\09{\0A\09\09\09sepAxis.w = dmin;\0A\09\09\09concaveSeparatingNormalsOut[pairIdx]=sepAxis;\0A\09\09\09concaveHasSeparatingNormals[i]=1;\0A\09\09\09float minDist = -1e30f;\0A\09\09\09float maxDist = 0.02f;\0A\09\09\0A\09\09\09findClippingFaces(sepAxis,\0A                     &convexPolyhedronA,\0A\09\09\09\09\09 &convexShapes[shapeIndexB],\0A\09\09\09\09\09 posA,ornA,\0A\09\09\09\09\09 posB,ornB,\0A                      worldVertsA1GPU,\0A                      worldNormalsAGPU,\0A                      worldVertsB1GPU,\0A\09\09\09\09\09  vertexFaceCapacity,\0A                      minDist, maxDist,\0A                      verticesA,\0A                      facesA,\0A                      indicesA,\0A \09\09\09\09\09  vertices,\0A                      faces,\0A                      indices,\0A                      clippingFacesOut, pairIdx);\0A\09\09} else\0A\09\09{\09\0A\09\09\09//mark this pair as in-active\0A\09\09\09concavePairs[pairIdx].w = -1;\0A\09\09}\0A\09}\0A\09else\0A\09{\09\0A\09\09//mark this pair as in-active\0A\09\09concavePairs[pairIdx].w = -1;\0A\09}\0A\09\0A\09concavePairs[pairIdx].z = -1;//now z is used for existing/persistent contacts\0A}\0A\00", align 1
@.str.69 = private unnamed_addr constant [65232 x i8] c"#define TRIANGLE_NUM_CONVEX_FACES 5\0A#pragma OPENCL EXTENSION cl_amd_printf : enable\0A#pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable\0A#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\0A#pragma OPENCL EXTENSION cl_khr_local_int32_extended_atomics : enable\0A#pragma OPENCL EXTENSION cl_khr_global_int32_extended_atomics : enable\0A#ifdef cl_ext_atomic_counters_32\0A#pragma OPENCL EXTENSION cl_ext_atomic_counters_32 : enable\0A#else\0A#define counter32_t volatile __global int*\0A#endif\0A#define GET_GROUP_IDX get_group_id(0)\0A#define GET_LOCAL_IDX get_local_id(0)\0A#define GET_GLOBAL_IDX get_global_id(0)\0A#define GET_GROUP_SIZE get_local_size(0)\0A#define GET_NUM_GROUPS get_num_groups(0)\0A#define GROUP_LDS_BARRIER barrier(CLK_LOCAL_MEM_FENCE)\0A#define GROUP_MEM_FENCE mem_fence(CLK_LOCAL_MEM_FENCE)\0A#define AtomInc(x) atom_inc(&(x))\0A#define AtomInc1(x, out) out = atom_inc(&(x))\0A#define AppendInc(x, out) out = atomic_inc(x)\0A#define AtomAdd(x, value) atom_add(&(x), value)\0A#define AtomCmpxhg(x, cmp, value) atom_cmpxchg( &(x), cmp, value )\0A#define AtomXhg(x, value) atom_xchg ( &(x), value )\0A#define max2 max\0A#define min2 min\0Atypedef unsigned int u32;\0A#ifndef B3_CONTACT4DATA_H\0A#define B3_CONTACT4DATA_H\0A#ifndef B3_FLOAT4_H\0A#define B3_FLOAT4_H\0A#ifndef B3_PLATFORM_DEFINITIONS_H\0A#define B3_PLATFORM_DEFINITIONS_H\0Astruct MyTest\0A{\0A\09int bla;\0A};\0A#ifdef __cplusplus\0A#else\0A//keep B3_LARGE_FLOAT*B3_LARGE_FLOAT < FLT_MAX\0A#define B3_LARGE_FLOAT 1e18f\0A#define B3_INFINITY 1e18f\0A#define b3Assert(a)\0A#define b3ConstArray(a) __global const a*\0A#define b3AtomicInc atomic_inc\0A#define b3AtomicAdd atomic_add\0A#define b3Fabs fabs\0A#define b3Sqrt native_sqrt\0A#define b3Sin native_sin\0A#define b3Cos native_cos\0A#define B3_STATIC\0A#endif\0A#endif\0A#ifdef __cplusplus\0A#else\0A\09typedef float4\09b3Float4;\0A\09#define b3Float4ConstArg const b3Float4\0A\09#define b3MakeFloat4 (float4)\0A\09float b3Dot3F4(b3Float4ConstArg v0,b3Float4ConstArg v1)\0A\09{\0A\09\09float4 a1 = b3MakeFloat4(v0.xyz,0.f);\0A\09\09float4 b1 = b3MakeFloat4(v1.xyz,0.f);\0A\09\09return dot(a1, b1);\0A\09}\0A\09b3Float4 b3Cross3(b3Float4ConstArg v0,b3Float4ConstArg v1)\0A\09{\0A\09\09float4 a1 = b3MakeFloat4(v0.xyz,0.f);\0A\09\09float4 b1 = b3MakeFloat4(v1.xyz,0.f);\0A\09\09return cross(a1, b1);\0A\09}\0A\09#define b3MinFloat4 min\0A\09#define b3MaxFloat4 max\0A\09#define b3Normalized(a) normalize(a)\0A#endif \0A\09\09\0Ainline bool b3IsAlmostZero(b3Float4ConstArg v)\0A{\0A\09if(b3Fabs(v.x)>1e-6 || b3Fabs(v.y)>1e-6 || b3Fabs(v.z)>1e-6)\09\0A\09\09return false;\0A\09return true;\0A}\0Ainline int    b3MaxDot( b3Float4ConstArg vec, __global const b3Float4* vecArray, int vecLen, float* dotOut )\0A{\0A    float maxDot = -B3_INFINITY;\0A    int i = 0;\0A    int ptIndex = -1;\0A    for( i = 0; i < vecLen; i++ )\0A    {\0A        float dot = b3Dot3F4(vecArray[i],vec);\0A            \0A        if( dot > maxDot )\0A        {\0A            maxDot = dot;\0A            ptIndex = i;\0A        }\0A    }\0A\09b3Assert(ptIndex>=0);\0A    if (ptIndex<0)\0A\09{\0A\09\09ptIndex = 0;\0A\09}\0A    *dotOut = maxDot;\0A    return ptIndex;\0A}\0A#endif //B3_FLOAT4_H\0Atypedef  struct b3Contact4Data b3Contact4Data_t;\0Astruct b3Contact4Data\0A{\0A\09b3Float4\09m_worldPosB[4];\0A//\09b3Float4\09m_localPosA[4];\0A//\09b3Float4\09m_localPosB[4];\0A\09b3Float4\09m_worldNormalOnB;\09//\09w: m_nPoints\0A\09unsigned short  m_restituitionCoeffCmp;\0A\09unsigned short  m_frictionCoeffCmp;\0A\09int m_batchIdx;\0A\09int m_bodyAPtrAndSignBit;//x:m_bodyAPtr, y:m_bodyBPtr\0A\09int m_bodyBPtrAndSignBit;\0A\09int\09m_childIndexA;\0A\09int\09m_childIndexB;\0A\09int m_unused1;\0A\09int m_unused2;\0A};\0Ainline int b3Contact4Data_getNumPoints(const struct b3Contact4Data* contact)\0A{\0A\09return (int)contact->m_worldNormalOnB.w;\0A};\0Ainline void b3Contact4Data_setNumPoints(struct b3Contact4Data* contact, int numPoints)\0A{\0A\09contact->m_worldNormalOnB.w = (float)numPoints;\0A};\0A#endif //B3_CONTACT4DATA_H\0A#ifndef B3_CONVEX_POLYHEDRON_DATA_H\0A#define B3_CONVEX_POLYHEDRON_DATA_H\0A#ifndef B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_FLOAT4_H\0A#ifndef B3_QUAT_H\0A#define B3_QUAT_H\0A#ifndef B3_PLATFORM_DEFINITIONS_H\0A#ifdef __cplusplus\0A#else\0A#endif\0A#endif\0A#ifndef B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A\09typedef float4\09b3Quat;\0A\09#define b3QuatConstArg const b3Quat\0A\09\0A\09\0Ainline float4 b3FastNormalize4(float4 v)\0A{\0A\09v = (float4)(v.xyz,0.f);\0A\09return fast_normalize(v);\0A}\0A\09\0Ainline b3Quat b3QuatMul(b3Quat a, b3Quat b);\0Ainline b3Quat b3QuatNormalized(b3QuatConstArg in);\0Ainline b3Quat b3QuatRotate(b3QuatConstArg q, b3QuatConstArg vec);\0Ainline b3Quat b3QuatInvert(b3QuatConstArg q);\0Ainline b3Quat b3QuatInverse(b3QuatConstArg q);\0Ainline b3Quat b3QuatMul(b3QuatConstArg a, b3QuatConstArg b)\0A{\0A\09b3Quat ans;\0A\09ans = b3Cross3( a, b );\0A\09ans += a.w*b+b.w*a;\0A//\09ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);\0A\09ans.w = a.w*b.w - b3Dot3F4(a, b);\0A\09return ans;\0A}\0Ainline b3Quat b3QuatNormalized(b3QuatConstArg in)\0A{\0A\09b3Quat q;\0A\09q=in;\0A\09//return b3FastNormalize4(in);\0A\09float len = native_sqrt(dot(q, q));\0A\09if(len > 0.f)\0A\09{\0A\09\09q *= 1.f / len;\0A\09}\0A\09else\0A\09{\0A\09\09q.x = q.y = q.z = 0.f;\0A\09\09q.w = 1.f;\0A\09}\0A\09return q;\0A}\0Ainline float4 b3QuatRotate(b3QuatConstArg q, b3QuatConstArg vec)\0A{\0A\09b3Quat qInv = b3QuatInvert( q );\0A\09float4 vcpy = vec;\0A\09vcpy.w = 0.f;\0A\09float4 out = b3QuatMul(b3QuatMul(q,vcpy),qInv);\0A\09return out;\0A}\0Ainline b3Quat b3QuatInverse(b3QuatConstArg q)\0A{\0A\09return (b3Quat)(-q.xyz, q.w);\0A}\0Ainline b3Quat b3QuatInvert(b3QuatConstArg q)\0A{\0A\09return (b3Quat)(-q.xyz, q.w);\0A}\0Ainline float4 b3QuatInvRotate(b3QuatConstArg q, b3QuatConstArg vec)\0A{\0A\09return b3QuatRotate( b3QuatInvert( q ), vec );\0A}\0Ainline b3Float4 b3TransformPoint(b3Float4ConstArg point, b3Float4ConstArg translation, b3QuatConstArg  orientation)\0A{\0A\09return b3QuatRotate( orientation, point ) + (translation);\0A}\0A\09\0A#endif \0A#endif //B3_QUAT_H\0Atypedef struct b3GpuFace b3GpuFace_t;\0Astruct b3GpuFace\0A{\0A\09b3Float4 m_plane;\0A\09int m_indexOffset;\0A\09int m_numIndices;\0A\09int m_unusedPadding1;\0A\09int m_unusedPadding2;\0A};\0Atypedef struct b3ConvexPolyhedronData b3ConvexPolyhedronData_t;\0Astruct b3ConvexPolyhedronData\0A{\0A\09b3Float4\09\09m_localCenter;\0A\09b3Float4\09\09m_extents;\0A\09b3Float4\09\09mC;\0A\09b3Float4\09\09mE;\0A\09float\09\09\09m_radius;\0A\09int\09m_faceOffset;\0A\09int m_numFaces;\0A\09int\09m_numVertices;\0A\09int m_vertexOffset;\0A\09int\09m_uniqueEdgesOffset;\0A\09int\09m_numUniqueEdges;\0A\09int m_unused;\0A};\0A#endif //B3_CONVEX_POLYHEDRON_DATA_H\0A#ifndef B3_COLLIDABLE_H\0A#define B3_COLLIDABLE_H\0A#ifndef B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_FLOAT4_H\0A#ifndef B3_QUAT_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_QUAT_H\0Aenum b3ShapeTypes\0A{\0A\09SHAPE_HEIGHT_FIELD=1,\0A\09SHAPE_CONVEX_HULL=3,\0A\09SHAPE_PLANE=4,\0A\09SHAPE_CONCAVE_TRIMESH=5,\0A\09SHAPE_COMPOUND_OF_CONVEX_HULLS=6,\0A\09SHAPE_SPHERE=7,\0A\09MAX_NUM_SHAPE_TYPES,\0A};\0Atypedef struct b3Collidable b3Collidable_t;\0Astruct b3Collidable\0A{\0A\09union {\0A\09\09int m_numChildShapes;\0A\09\09int m_bvhIndex;\0A\09};\0A\09union\0A\09{\0A\09\09float m_radius;\0A\09\09int\09m_compoundBvhIndex;\0A\09};\0A\09int m_shapeType;\0A\09int m_shapeIndex;\0A};\0Atypedef struct b3GpuChildShape b3GpuChildShape_t;\0Astruct b3GpuChildShape\0A{\0A\09b3Float4\09m_childPosition;\0A\09b3Quat\09\09m_childOrientation;\0A\09int m_shapeIndex;\0A\09int m_unused0;\0A\09int m_unused1;\0A\09int m_unused2;\0A};\0Astruct b3CompoundOverlappingPair\0A{\0A\09int m_bodyIndexA;\0A\09int m_bodyIndexB;\0A//\09int\09m_pairType;\0A\09int m_childShapeIndexA;\0A\09int m_childShapeIndexB;\0A};\0A#endif //B3_COLLIDABLE_H\0A#ifndef B3_RIGIDBODY_DATA_H\0A#define B3_RIGIDBODY_DATA_H\0A#ifndef B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_FLOAT4_H\0A#ifndef B3_QUAT_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_QUAT_H\0A#ifndef B3_MAT3x3_H\0A#define B3_MAT3x3_H\0A#ifndef B3_QUAT_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_QUAT_H\0A#ifdef __cplusplus\0A#else\0Atypedef struct\0A{\0A\09b3Float4 m_row[3];\0A}b3Mat3x3;\0A#define b3Mat3x3ConstArg const b3Mat3x3\0A#define b3GetRow(m,row) (m.m_row[row])\0Ainline b3Mat3x3 b3QuatGetRotationMatrix(b3Quat quat)\0A{\0A\09b3Float4 quat2 = (b3Float4)(quat.x*quat.x, quat.y*quat.y, quat.z*quat.z, 0.f);\0A\09b3Mat3x3 out;\0A\09out.m_row[0].x=1-2*quat2.y-2*quat2.z;\0A\09out.m_row[0].y=2*quat.x*quat.y-2*quat.w*quat.z;\0A\09out.m_row[0].z=2*quat.x*quat.z+2*quat.w*quat.y;\0A\09out.m_row[0].w = 0.f;\0A\09out.m_row[1].x=2*quat.x*quat.y+2*quat.w*quat.z;\0A\09out.m_row[1].y=1-2*quat2.x-2*quat2.z;\0A\09out.m_row[1].z=2*quat.y*quat.z-2*quat.w*quat.x;\0A\09out.m_row[1].w = 0.f;\0A\09out.m_row[2].x=2*quat.x*quat.z-2*quat.w*quat.y;\0A\09out.m_row[2].y=2*quat.y*quat.z+2*quat.w*quat.x;\0A\09out.m_row[2].z=1-2*quat2.x-2*quat2.y;\0A\09out.m_row[2].w = 0.f;\0A\09return out;\0A}\0Ainline b3Mat3x3 b3AbsoluteMat3x3(b3Mat3x3ConstArg matIn)\0A{\0A\09b3Mat3x3 out;\0A\09out.m_row[0] = fabs(matIn.m_row[0]);\0A\09out.m_row[1] = fabs(matIn.m_row[1]);\0A\09out.m_row[2] = fabs(matIn.m_row[2]);\0A\09return out;\0A}\0A__inline\0Ab3Mat3x3 mtZero();\0A__inline\0Ab3Mat3x3 mtIdentity();\0A__inline\0Ab3Mat3x3 mtTranspose(b3Mat3x3 m);\0A__inline\0Ab3Mat3x3 mtMul(b3Mat3x3 a, b3Mat3x3 b);\0A__inline\0Ab3Float4 mtMul1(b3Mat3x3 a, b3Float4 b);\0A__inline\0Ab3Float4 mtMul3(b3Float4 a, b3Mat3x3 b);\0A__inline\0Ab3Mat3x3 mtZero()\0A{\0A\09b3Mat3x3 m;\0A\09m.m_row[0] = (b3Float4)(0.f);\0A\09m.m_row[1] = (b3Float4)(0.f);\0A\09m.m_row[2] = (b3Float4)(0.f);\0A\09return m;\0A}\0A__inline\0Ab3Mat3x3 mtIdentity()\0A{\0A\09b3Mat3x3 m;\0A\09m.m_row[0] = (b3Float4)(1,0,0,0);\0A\09m.m_row[1] = (b3Float4)(0,1,0,0);\0A\09m.m_row[2] = (b3Float4)(0,0,1,0);\0A\09return m;\0A}\0A__inline\0Ab3Mat3x3 mtTranspose(b3Mat3x3 m)\0A{\0A\09b3Mat3x3 out;\0A\09out.m_row[0] = (b3Float4)(m.m_row[0].x, m.m_row[1].x, m.m_row[2].x, 0.f);\0A\09out.m_row[1] = (b3Float4)(m.m_row[0].y, m.m_row[1].y, m.m_row[2].y, 0.f);\0A\09out.m_row[2] = (b3Float4)(m.m_row[0].z, m.m_row[1].z, m.m_row[2].z, 0.f);\0A\09return out;\0A}\0A__inline\0Ab3Mat3x3 mtMul(b3Mat3x3 a, b3Mat3x3 b)\0A{\0A\09b3Mat3x3 transB;\0A\09transB = mtTranspose( b );\0A\09b3Mat3x3 ans;\0A\09//\09why this doesn't run when 0ing in the for{}\0A\09a.m_row[0].w = 0.f;\0A\09a.m_row[1].w = 0.f;\0A\09a.m_row[2].w = 0.f;\0A\09for(int i=0; i<3; i++)\0A\09{\0A//\09a.m_row[i].w = 0.f;\0A\09\09ans.m_row[i].x = b3Dot3F4(a.m_row[i],transB.m_row[0]);\0A\09\09ans.m_row[i].y = b3Dot3F4(a.m_row[i],transB.m_row[1]);\0A\09\09ans.m_row[i].z = b3Dot3F4(a.m_row[i],transB.m_row[2]);\0A\09\09ans.m_row[i].w = 0.f;\0A\09}\0A\09return ans;\0A}\0A__inline\0Ab3Float4 mtMul1(b3Mat3x3 a, b3Float4 b)\0A{\0A\09b3Float4 ans;\0A\09ans.x = b3Dot3F4( a.m_row[0], b );\0A\09ans.y = b3Dot3F4( a.m_row[1], b );\0A\09ans.z = b3Dot3F4( a.m_row[2], b );\0A\09ans.w = 0.f;\0A\09return ans;\0A}\0A__inline\0Ab3Float4 mtMul3(b3Float4 a, b3Mat3x3 b)\0A{\0A\09b3Float4 colx = b3MakeFloat4(b.m_row[0].x, b.m_row[1].x, b.m_row[2].x, 0);\0A\09b3Float4 coly = b3MakeFloat4(b.m_row[0].y, b.m_row[1].y, b.m_row[2].y, 0);\0A\09b3Float4 colz = b3MakeFloat4(b.m_row[0].z, b.m_row[1].z, b.m_row[2].z, 0);\0A\09b3Float4 ans;\0A\09ans.x = b3Dot3F4( a, colx );\0A\09ans.y = b3Dot3F4( a, coly );\0A\09ans.z = b3Dot3F4( a, colz );\0A\09return ans;\0A}\0A#endif\0A#endif //B3_MAT3x3_H\0Atypedef struct b3RigidBodyData b3RigidBodyData_t;\0Astruct b3RigidBodyData\0A{\0A\09b3Float4\09\09\09\09m_pos;\0A\09b3Quat\09\09\09\09\09m_quat;\0A\09b3Float4\09\09\09\09m_linVel;\0A\09b3Float4\09\09\09\09m_angVel;\0A\09int \09\09\09\09\09m_collidableIdx;\0A\09float \09\09\09\09m_invMass;\0A\09float \09\09\09\09m_restituitionCoeff;\0A\09float \09\09\09\09m_frictionCoeff;\0A};\0Atypedef struct b3InertiaData b3InertiaData_t;\0Astruct b3InertiaData\0A{\0A\09b3Mat3x3 m_invInertiaWorld;\0A\09b3Mat3x3 m_initInvInertia;\0A};\0A#endif //B3_RIGIDBODY_DATA_H\0A\09\0A#define GET_NPOINTS(x) (x).m_worldNormalOnB.w\0A#define SELECT_UINT4( b, a, condition ) select( b,a,condition )\0A#define make_float4 (float4)\0A#define make_float2 (float2)\0A#define make_uint4 (uint4)\0A#define make_int4 (int4)\0A#define make_uint2 (uint2)\0A#define make_int2 (int2)\0A__inline\0Afloat fastDiv(float numerator, float denominator)\0A{\0A\09return native_divide(numerator, denominator);\09\0A//\09return numerator/denominator;\09\0A}\0A__inline\0Afloat4 fastDiv4(float4 numerator, float4 denominator)\0A{\0A\09return native_divide(numerator, denominator);\09\0A}\0A__inline\0Afloat4 cross3(float4 a, float4 b)\0A{\0A\09return cross(a,b);\0A}\0A//#define dot3F4 dot\0A__inline\0Afloat dot3F4(float4 a, float4 b)\0A{\0A\09float4 a1 = make_float4(a.xyz,0.f);\0A\09float4 b1 = make_float4(b.xyz,0.f);\0A\09return dot(a1, b1);\0A}\0A__inline\0Afloat4 fastNormalize4(float4 v)\0A{\0A\09return fast_normalize(v);\0A}\0A///////////////////////////////////////\0A//\09Quaternion\0A///////////////////////////////////////\0Atypedef float4 Quaternion;\0A__inline\0AQuaternion qtMul(Quaternion a, Quaternion b);\0A__inline\0AQuaternion qtNormalize(Quaternion in);\0A__inline\0Afloat4 qtRotate(Quaternion q, float4 vec);\0A__inline\0AQuaternion qtInvert(Quaternion q);\0A__inline\0AQuaternion qtMul(Quaternion a, Quaternion b)\0A{\0A\09Quaternion ans;\0A\09ans = cross3( a, b );\0A\09ans += a.w*b+b.w*a;\0A//\09ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);\0A\09ans.w = a.w*b.w - dot3F4(a, b);\0A\09return ans;\0A}\0A__inline\0AQuaternion qtNormalize(Quaternion in)\0A{\0A\09return fastNormalize4(in);\0A//\09in /= length( in );\0A//\09return in;\0A}\0A__inline\0Afloat4 qtRotate(Quaternion q, float4 vec)\0A{\0A\09Quaternion qInv = qtInvert( q );\0A\09float4 vcpy = vec;\0A\09vcpy.w = 0.f;\0A\09float4 out = qtMul(qtMul(q,vcpy),qInv);\0A\09return out;\0A}\0A__inline\0AQuaternion qtInvert(Quaternion q)\0A{\0A\09return (Quaternion)(-q.xyz, q.w);\0A}\0A__inline\0Afloat4 qtInvRotate(const Quaternion q, float4 vec)\0A{\0A\09return qtRotate( qtInvert( q ), vec );\0A}\0A__inline\0Afloat4 transform(const float4* p, const float4* translation, const Quaternion* orientation)\0A{\0A\09return qtRotate( *orientation, *p ) + (*translation);\0A}\0A__inline\0Afloat4 normalize3(const float4 a)\0A{\0A\09float4 n = make_float4(a.x, a.y, a.z, 0.f);\0A\09return fastNormalize4( n );\0A}\0A__inline float4 lerp3(const float4 a,const float4 b, float  t)\0A{\0A\09return make_float4(\09a.x + (b.x - a.x) * t,\0A\09\09\09\09\09\09a.y + (b.y - a.y) * t,\0A\09\09\09\09\09\09a.z + (b.z - a.z) * t,\0A\09\09\09\09\09\090.f);\0A}\0A// Clips a face to the back of a plane, return the number of vertices out, stored in ppVtxOut\0Aint clipFaceGlobal(__global const float4* pVtxIn, int numVertsIn, float4 planeNormalWS,float planeEqWS, __global float4* ppVtxOut)\0A{\0A\09\0A\09int ve;\0A\09float ds, de;\0A\09int numVertsOut = 0;\0A    //double-check next test\0A    \09if (numVertsIn < 2)\0A    \09\09return 0;\0A    \0A\09float4 firstVertex=pVtxIn[numVertsIn-1];\0A\09float4 endVertex = pVtxIn[0];\0A\09\0A\09ds = dot3F4(planeNormalWS,firstVertex)+planeEqWS;\0A    \0A\09for (ve = 0; ve < numVertsIn; ve++)\0A\09{\0A\09\09endVertex=pVtxIn[ve];\0A\09\09de = dot3F4(planeNormalWS,endVertex)+planeEqWS;\0A\09\09if (ds<0)\0A\09\09{\0A\09\09\09if (de<0)\0A\09\09\09{\0A\09\09\09\09// Start < 0, end < 0, so output endVertex\0A\09\09\09\09ppVtxOut[numVertsOut++] = endVertex;\0A\09\09\09}\0A\09\09\09else\0A\09\09\09{\0A\09\09\09\09// Start < 0, end >= 0, so output intersection\0A\09\09\09\09ppVtxOut[numVertsOut++] = lerp3(firstVertex, endVertex,(ds * 1.f/(ds - de)) );\0A\09\09\09}\0A\09\09}\0A\09\09else\0A\09\09{\0A\09\09\09if (de<0)\0A\09\09\09{\0A\09\09\09\09// Start >= 0, end < 0 so output intersection and end\0A\09\09\09\09ppVtxOut[numVertsOut++] = lerp3(firstVertex, endVertex,(ds * 1.f/(ds - de)) );\0A\09\09\09\09ppVtxOut[numVertsOut++] = endVertex;\0A\09\09\09}\0A\09\09}\0A\09\09firstVertex = endVertex;\0A\09\09ds = de;\0A\09}\0A\09return numVertsOut;\0A}\0A// Clips a face to the back of a plane, return the number of vertices out, stored in ppVtxOut\0Aint clipFace(const float4* pVtxIn, int numVertsIn, float4 planeNormalWS,float planeEqWS, float4* ppVtxOut)\0A{\0A\09\0A\09int ve;\0A\09float ds, de;\0A\09int numVertsOut = 0;\0A//double-check next test\0A\09if (numVertsIn < 2)\0A\09\09return 0;\0A\09float4 firstVertex=pVtxIn[numVertsIn-1];\0A\09float4 endVertex = pVtxIn[0];\0A\09\0A\09ds = dot3F4(planeNormalWS,firstVertex)+planeEqWS;\0A\09for (ve = 0; ve < numVertsIn; ve++)\0A\09{\0A\09\09endVertex=pVtxIn[ve];\0A\09\09de = dot3F4(planeNormalWS,endVertex)+planeEqWS;\0A\09\09if (ds<0)\0A\09\09{\0A\09\09\09if (de<0)\0A\09\09\09{\0A\09\09\09\09// Start < 0, end < 0, so output endVertex\0A\09\09\09\09ppVtxOut[numVertsOut++] = endVertex;\0A\09\09\09}\0A\09\09\09else\0A\09\09\09{\0A\09\09\09\09// Start < 0, end >= 0, so output intersection\0A\09\09\09\09ppVtxOut[numVertsOut++] = lerp3(firstVertex, endVertex,(ds * 1.f/(ds - de)) );\0A\09\09\09}\0A\09\09}\0A\09\09else\0A\09\09{\0A\09\09\09if (de<0)\0A\09\09\09{\0A\09\09\09\09// Start >= 0, end < 0 so output intersection and end\0A\09\09\09\09ppVtxOut[numVertsOut++] = lerp3(firstVertex, endVertex,(ds * 1.f/(ds - de)) );\0A\09\09\09\09ppVtxOut[numVertsOut++] = endVertex;\0A\09\09\09}\0A\09\09}\0A\09\09firstVertex = endVertex;\0A\09\09ds = de;\0A\09}\0A\09return numVertsOut;\0A}\0Aint clipFaceAgainstHull(const float4 separatingNormal, __global const b3ConvexPolyhedronData_t* hullA,  \0A\09const float4 posA, const Quaternion ornA, float4* worldVertsB1, int numWorldVertsB1,\0A\09float4* worldVertsB2, int capacityWorldVertsB2,\0A\09const float minDist, float maxDist,\0A\09__global const float4* vertices,\0A\09__global const b3GpuFace_t* faces,\0A\09__global const int* indices,\0A\09float4* contactsOut,\0A\09int contactCapacity)\0A{\0A\09int numContactsOut = 0;\0A\09float4* pVtxIn = worldVertsB1;\0A\09float4* pVtxOut = worldVertsB2;\0A\09\0A\09int numVertsIn = numWorldVertsB1;\0A\09int numVertsOut = 0;\0A\09int closestFaceA=-1;\0A\09{\0A\09\09float dmin = FLT_MAX;\0A\09\09for(int face=0;face<hullA->m_numFaces;face++)\0A\09\09{\0A\09\09\09const float4 Normal = make_float4(\0A\09\09\09\09faces[hullA->m_faceOffset+face].m_plane.x, \0A\09\09\09\09faces[hullA->m_faceOffset+face].m_plane.y, \0A\09\09\09\09faces[hullA->m_faceOffset+face].m_plane.z,0.f);\0A\09\09\09const float4 faceANormalWS = qtRotate(ornA,Normal);\0A\09\09\0A\09\09\09float d = dot3F4(faceANormalWS,separatingNormal);\0A\09\09\09if (d < dmin)\0A\09\09\09{\0A\09\09\09\09dmin = d;\0A\09\09\09\09closestFaceA = face;\0A\09\09\09}\0A\09\09}\0A\09}\0A\09if (closestFaceA<0)\0A\09\09return numContactsOut;\0A\09b3GpuFace_t polyA = faces[hullA->m_faceOffset+closestFaceA];\0A\09// clip polygon to back of planes of all faces of hull A that are adjacent to witness face\0A\09int numVerticesA = polyA.m_numIndices;\0A\09for(int e0=0;e0<numVerticesA;e0++)\0A\09{\0A\09\09const float4 a = vertices[hullA->m_vertexOffset+indices[polyA.m_indexOffset+e0]];\0A\09\09const float4 b = vertices[hullA->m_vertexOffset+indices[polyA.m_indexOffset+((e0+1)%numVerticesA)]];\0A\09\09const float4 edge0 = a - b;\0A\09\09const float4 WorldEdge0 = qtRotate(ornA,edge0);\0A\09\09float4 planeNormalA = make_float4(polyA.m_plane.x,polyA.m_plane.y,polyA.m_plane.z,0.f);\0A\09\09float4 worldPlaneAnormal1 = qtRotate(ornA,planeNormalA);\0A\09\09float4 planeNormalWS1 = -cross3(WorldEdge0,worldPlaneAnormal1);\0A\09\09float4 worldA1 = transform(&a,&posA,&ornA);\0A\09\09float planeEqWS1 = -dot3F4(worldA1,planeNormalWS1);\0A\09\09\0A\09\09float4 planeNormalWS = planeNormalWS1;\0A\09\09float planeEqWS=planeEqWS1;\0A\09\09\0A\09\09//clip face\0A\09\09//clipFace(*pVtxIn, *pVtxOut,planeNormalWS,planeEqWS);\0A\09\09numVertsOut = clipFace(pVtxIn, numVertsIn, planeNormalWS,planeEqWS, pVtxOut);\0A\09\09//btSwap(pVtxIn,pVtxOut);\0A\09\09float4* tmp = pVtxOut;\0A\09\09pVtxOut = pVtxIn;\0A\09\09pVtxIn = tmp;\0A\09\09numVertsIn = numVertsOut;\0A\09\09numVertsOut = 0;\0A\09}\0A\09\0A\09// only keep points that are behind the witness face\0A\09{\0A\09\09float4 localPlaneNormal  = make_float4(polyA.m_plane.x,polyA.m_plane.y,polyA.m_plane.z,0.f);\0A\09\09float localPlaneEq = polyA.m_plane.w;\0A\09\09float4 planeNormalWS = qtRotate(ornA,localPlaneNormal);\0A\09\09float planeEqWS=localPlaneEq-dot3F4(planeNormalWS,posA);\0A\09\09for (int i=0;i<numVertsIn;i++)\0A\09\09{\0A\09\09\09float depth = dot3F4(planeNormalWS,pVtxIn[i])+planeEqWS;\0A\09\09\09if (depth <=minDist)\0A\09\09\09{\0A\09\09\09\09depth = minDist;\0A\09\09\09}\0A\09\09\09if (depth <=maxDist)\0A\09\09\09{\0A\09\09\09\09float4 pointInWorld = pVtxIn[i];\0A\09\09\09\09//resultOut.addContactPoint(separatingNormal,point,depth);\0A\09\09\09\09contactsOut[numContactsOut++] = make_float4(pointInWorld.x,pointInWorld.y,pointInWorld.z,depth);\0A\09\09\09}\0A\09\09}\0A\09}\0A\09return numContactsOut;\0A}\0Aint clipFaceAgainstHullLocalA(const float4 separatingNormal, const b3ConvexPolyhedronData_t* hullA,  \0A\09const float4 posA, const Quaternion ornA, float4* worldVertsB1, int numWorldVertsB1,\0A\09float4* worldVertsB2, int capacityWorldVertsB2,\0A\09const float minDist, float maxDist,\0A\09const float4* verticesA,\0A\09const b3GpuFace_t* facesA,\0A\09const int* indicesA,\0A\09__global const float4* verticesB,\0A\09__global const b3GpuFace_t* facesB,\0A\09__global const int* indicesB,\0A\09float4* contactsOut,\0A\09int contactCapacity)\0A{\0A\09int numContactsOut = 0;\0A\09float4* pVtxIn = worldVertsB1;\0A\09float4* pVtxOut = worldVertsB2;\0A\09\0A\09int numVertsIn = numWorldVertsB1;\0A\09int numVertsOut = 0;\0A\09int closestFaceA=-1;\0A\09{\0A\09\09float dmin = FLT_MAX;\0A\09\09for(int face=0;face<hullA->m_numFaces;face++)\0A\09\09{\0A\09\09\09const float4 Normal = make_float4(\0A\09\09\09\09facesA[hullA->m_faceOffset+face].m_plane.x, \0A\09\09\09\09facesA[hullA->m_faceOffset+face].m_plane.y, \0A\09\09\09\09facesA[hullA->m_faceOffset+face].m_plane.z,0.f);\0A\09\09\09const float4 faceANormalWS = qtRotate(ornA,Normal);\0A\09\09\0A\09\09\09float d = dot3F4(faceANormalWS,separatingNormal);\0A\09\09\09if (d < dmin)\0A\09\09\09{\0A\09\09\09\09dmin = d;\0A\09\09\09\09closestFaceA = face;\0A\09\09\09}\0A\09\09}\0A\09}\0A\09if (closestFaceA<0)\0A\09\09return numContactsOut;\0A\09b3GpuFace_t polyA = facesA[hullA->m_faceOffset+closestFaceA];\0A\09// clip polygon to back of planes of all faces of hull A that are adjacent to witness face\0A\09int numVerticesA = polyA.m_numIndices;\0A\09for(int e0=0;e0<numVerticesA;e0++)\0A\09{\0A\09\09const float4 a = verticesA[hullA->m_vertexOffset+indicesA[polyA.m_indexOffset+e0]];\0A\09\09const float4 b = verticesA[hullA->m_vertexOffset+indicesA[polyA.m_indexOffset+((e0+1)%numVerticesA)]];\0A\09\09const float4 edge0 = a - b;\0A\09\09const float4 WorldEdge0 = qtRotate(ornA,edge0);\0A\09\09float4 planeNormalA = make_float4(polyA.m_plane.x,polyA.m_plane.y,polyA.m_plane.z,0.f);\0A\09\09float4 worldPlaneAnormal1 = qtRotate(ornA,planeNormalA);\0A\09\09float4 planeNormalWS1 = -cross3(WorldEdge0,worldPlaneAnormal1);\0A\09\09float4 worldA1 = transform(&a,&posA,&ornA);\0A\09\09float planeEqWS1 = -dot3F4(worldA1,planeNormalWS1);\0A\09\09\0A\09\09float4 planeNormalWS = planeNormalWS1;\0A\09\09float planeEqWS=planeEqWS1;\0A\09\09\0A\09\09//clip face\0A\09\09//clipFace(*pVtxIn, *pVtxOut,planeNormalWS,planeEqWS);\0A\09\09numVertsOut = clipFace(pVtxIn, numVertsIn, planeNormalWS,planeEqWS, pVtxOut);\0A\09\09//btSwap(pVtxIn,pVtxOut);\0A\09\09float4* tmp = pVtxOut;\0A\09\09pVtxOut = pVtxIn;\0A\09\09pVtxIn = tmp;\0A\09\09numVertsIn = numVertsOut;\0A\09\09numVertsOut = 0;\0A\09}\0A\09\0A\09// only keep points that are behind the witness face\0A\09{\0A\09\09float4 localPlaneNormal  = make_float4(polyA.m_plane.x,polyA.m_plane.y,polyA.m_plane.z,0.f);\0A\09\09float localPlaneEq = polyA.m_plane.w;\0A\09\09float4 planeNormalWS = qtRotate(ornA,localPlaneNormal);\0A\09\09float planeEqWS=localPlaneEq-dot3F4(planeNormalWS,posA);\0A\09\09for (int i=0;i<numVertsIn;i++)\0A\09\09{\0A\09\09\09float depth = dot3F4(planeNormalWS,pVtxIn[i])+planeEqWS;\0A\09\09\09if (depth <=minDist)\0A\09\09\09{\0A\09\09\09\09depth = minDist;\0A\09\09\09}\0A\09\09\09if (depth <=maxDist)\0A\09\09\09{\0A\09\09\09\09float4 pointInWorld = pVtxIn[i];\0A\09\09\09\09//resultOut.addContactPoint(separatingNormal,point,depth);\0A\09\09\09\09contactsOut[numContactsOut++] = make_float4(pointInWorld.x,pointInWorld.y,pointInWorld.z,depth);\0A\09\09\09}\0A\09\09}\0A\09}\0A\09return numContactsOut;\0A}\0Aint\09clipHullAgainstHull(const float4 separatingNormal,\0A\09__global const b3ConvexPolyhedronData_t* hullA, __global const b3ConvexPolyhedronData_t* hullB, \0A\09const float4 posA, const Quaternion ornA,const float4 posB, const Quaternion ornB, \0A\09float4* worldVertsB1, float4* worldVertsB2, int capacityWorldVerts,\0A\09const float minDist, float maxDist,\0A\09__global const float4* vertices,\0A\09__global const b3GpuFace_t* faces,\0A\09__global const int* indices,\0A\09float4*\09localContactsOut,\0A\09int localContactCapacity)\0A{\0A\09int numContactsOut = 0;\0A\09int numWorldVertsB1= 0;\0A\09int closestFaceB=-1;\0A\09float dmax = -FLT_MAX;\0A\09{\0A\09\09for(int face=0;face<hullB->m_numFaces;face++)\0A\09\09{\0A\09\09\09const float4 Normal = make_float4(faces[hullB->m_faceOffset+face].m_plane.x, \0A\09\09\09\09faces[hullB->m_faceOffset+face].m_plane.y, faces[hullB->m_faceOffset+face].m_plane.z,0.f);\0A\09\09\09const float4 WorldNormal = qtRotate(ornB, Normal);\0A\09\09\09float d = dot3F4(WorldNormal,separatingNormal);\0A\09\09\09if (d > dmax)\0A\09\09\09{\0A\09\09\09\09dmax = d;\0A\09\09\09\09closestFaceB = face;\0A\09\09\09}\0A\09\09}\0A\09}\0A\09{\0A\09\09const b3GpuFace_t polyB = faces[hullB->m_faceOffset+closestFaceB];\0A\09\09const int numVertices = polyB.m_numIndices;\0A\09\09for(int e0=0;e0<numVertices;e0++)\0A\09\09{\0A\09\09\09const float4 b = vertices[hullB->m_vertexOffset+indices[polyB.m_indexOffset+e0]];\0A\09\09\09worldVertsB1[numWorldVertsB1++] = transform(&b,&posB,&ornB);\0A\09\09}\0A\09}\0A\09if (closestFaceB>=0)\0A\09{\0A\09\09numContactsOut = clipFaceAgainstHull(separatingNormal, hullA, \0A\09\09\09\09posA,ornA,\0A\09\09\09\09worldVertsB1,numWorldVertsB1,worldVertsB2,capacityWorldVerts, minDist, maxDist,vertices,\0A\09\09\09\09faces,\0A\09\09\09\09indices,localContactsOut,localContactCapacity);\0A\09}\0A\09return numContactsOut;\0A}\0Aint\09clipHullAgainstHullLocalA(const float4 separatingNormal,\0A\09const b3ConvexPolyhedronData_t* hullA, __global const b3ConvexPolyhedronData_t* hullB, \0A\09const float4 posA, const Quaternion ornA,const float4 posB, const Quaternion ornB, \0A\09float4* worldVertsB1, float4* worldVertsB2, int capacityWorldVerts,\0A\09const float minDist, float maxDist,\0A\09const float4* verticesA,\0A\09const b3GpuFace_t* facesA,\0A\09const int* indicesA,\0A\09__global const float4* verticesB,\0A\09__global const b3GpuFace_t* facesB,\0A\09__global const int* indicesB,\0A\09float4*\09localContactsOut,\0A\09int localContactCapacity)\0A{\0A\09int numContactsOut = 0;\0A\09int numWorldVertsB1= 0;\0A\09int closestFaceB=-1;\0A\09float dmax = -FLT_MAX;\0A\09{\0A\09\09for(int face=0;face<hullB->m_numFaces;face++)\0A\09\09{\0A\09\09\09const float4 Normal = make_float4(facesB[hullB->m_faceOffset+face].m_plane.x, \0A\09\09\09\09facesB[hullB->m_faceOffset+face].m_plane.y, facesB[hullB->m_faceOffset+face].m_plane.z,0.f);\0A\09\09\09const float4 WorldNormal = qtRotate(ornB, Normal);\0A\09\09\09float d = dot3F4(WorldNormal,separatingNormal);\0A\09\09\09if (d > dmax)\0A\09\09\09{\0A\09\09\09\09dmax = d;\0A\09\09\09\09closestFaceB = face;\0A\09\09\09}\0A\09\09}\0A\09}\0A\09{\0A\09\09const b3GpuFace_t polyB = facesB[hullB->m_faceOffset+closestFaceB];\0A\09\09const int numVertices = polyB.m_numIndices;\0A\09\09for(int e0=0;e0<numVertices;e0++)\0A\09\09{\0A\09\09\09const float4 b = verticesB[hullB->m_vertexOffset+indicesB[polyB.m_indexOffset+e0]];\0A\09\09\09worldVertsB1[numWorldVertsB1++] = transform(&b,&posB,&ornB);\0A\09\09}\0A\09}\0A\09if (closestFaceB>=0)\0A\09{\0A\09\09numContactsOut = clipFaceAgainstHullLocalA(separatingNormal, hullA, \0A\09\09\09\09posA,ornA,\0A\09\09\09\09worldVertsB1,numWorldVertsB1,worldVertsB2,capacityWorldVerts, minDist, maxDist,\0A\09\09\09\09verticesA,facesA,indicesA,\0A\09\09\09\09verticesB,facesB,indicesB,\0A\09\09\09\09localContactsOut,localContactCapacity);\0A\09}\0A\09return numContactsOut;\0A}\0A#define PARALLEL_SUM(v, n) for(int j=1; j<n; j++) v[0] += v[j];\0A#define PARALLEL_DO(execution, n) for(int ie=0; ie<n; ie++){execution;}\0A#define REDUCE_MAX(v, n) {int i=0; for(int offset=0; offset<n; offset++) v[i] = (v[i].y > v[i+offset].y)? v[i]: v[i+offset]; }\0A#define REDUCE_MIN(v, n) {int i=0; for(int offset=0; offset<n; offset++) v[i] = (v[i].y < v[i+offset].y)? v[i]: v[i+offset]; }\0Aint extractManifoldSequentialGlobal(__global const float4* p, int nPoints, float4 nearNormal, int4* contactIdx)\0A{\0A\09if( nPoints == 0 )\0A        return 0;\0A    \0A    if (nPoints <=4)\0A        return nPoints;\0A    \0A    \0A    if (nPoints >64)\0A        nPoints = 64;\0A    \0A\09float4 center = make_float4(0.f);\0A\09{\0A\09\09\0A\09\09for (int i=0;i<nPoints;i++)\0A\09\09\09center += p[i];\0A\09\09center /= (float)nPoints;\0A\09}\0A    \0A\09\0A    \0A\09//\09sample 4 directions\0A    \0A    float4 aVector = p[0] - center;\0A    float4 u = cross3( nearNormal, aVector );\0A    float4 v = cross3( nearNormal, u );\0A    u = normalize3( u );\0A    v = normalize3( v );\0A    \0A    \0A    //keep point with deepest penetration\0A    float minW= FLT_MAX;\0A    \0A    int minIndex=-1;\0A    \0A    float4 maxDots;\0A    maxDots.x = FLT_MIN;\0A    maxDots.y = FLT_MIN;\0A    maxDots.z = FLT_MIN;\0A    maxDots.w = FLT_MIN;\0A    \0A    //\09idx, distance\0A    for(int ie = 0; ie<nPoints; ie++ )\0A    {\0A        if (p[ie].w<minW)\0A        {\0A            minW = p[ie].w;\0A            minIndex=ie;\0A        }\0A        float f;\0A        float4 r = p[ie]-center;\0A        f = dot3F4( u, r );\0A        if (f<maxDots.x)\0A        {\0A            maxDots.x = f;\0A            contactIdx[0].x = ie;\0A        }\0A        \0A        f = dot3F4( -u, r );\0A        if (f<maxDots.y)\0A        {\0A            maxDots.y = f;\0A            contactIdx[0].y = ie;\0A        }\0A        \0A        \0A        f = dot3F4( v, r );\0A        if (f<maxDots.z)\0A        {\0A            maxDots.z = f;\0A            contactIdx[0].z = ie;\0A        }\0A        \0A        f = dot3F4( -v, r );\0A        if (f<maxDots.w)\0A        {\0A            maxDots.w = f;\0A            contactIdx[0].w = ie;\0A        }\0A        \0A    }\0A    \0A    if (contactIdx[0].x != minIndex && contactIdx[0].y != minIndex && contactIdx[0].z != minIndex && contactIdx[0].w != minIndex)\0A    {\0A        //replace the first contact with minimum (todo: replace contact with least penetration)\0A        contactIdx[0].x = minIndex;\0A    }\0A    \0A    return 4;\0A    \0A}\0Aint extractManifoldSequentialGlobalFake(__global const float4* p, int nPoints, float4 nearNormal, int* contactIdx)\0A{\0A    contactIdx[0] = 0;\0A    contactIdx[1] = 1;\0A    contactIdx[2] = 2;\0A    contactIdx[3] = 3;\0A    \0A\09if( nPoints == 0 ) return 0;\0A    \0A\09nPoints = min2( nPoints, 4 );\0A    return nPoints;\0A    \0A}\0Aint extractManifoldSequential(const float4* p, int nPoints, float4 nearNormal, int* contactIdx)\0A{\0A\09if( nPoints == 0 ) return 0;\0A\09nPoints = min2( nPoints, 64 );\0A\09float4 center = make_float4(0.f);\0A\09{\0A\09\09float4 v[64];\0A\09\09for (int i=0;i<nPoints;i++)\0A\09\09\09v[i] = p[i];\0A\09\09//memcpy( v, p, nPoints*sizeof(float4) );\0A\09\09PARALLEL_SUM( v, nPoints );\0A\09\09center = v[0]/(float)nPoints;\0A\09}\0A\09\0A\09{\09//\09sample 4 directions\0A\09\09if( nPoints < 4 )\0A\09\09{\0A\09\09\09for(int i=0; i<nPoints; i++) \0A\09\09\09\09contactIdx[i] = i;\0A\09\09\09return nPoints;\0A\09\09}\0A\09\09float4 aVector = p[0] - center;\0A\09\09float4 u = cross3( nearNormal, aVector );\0A\09\09float4 v = cross3( nearNormal, u );\0A\09\09u = normalize3( u );\0A\09\09v = normalize3( v );\0A\09\09int idx[4];\0A\09\09float2 max00 = make_float2(0,FLT_MAX);\0A\09\09{\0A\09\09\09//\09idx, distance\0A\09\09\09{\0A\09\09\09\09{\0A\09\09\09\09\09int4 a[64];\0A\09\09\09\09\09for(int ie = 0; ie<nPoints; ie++ )\0A\09\09\09\09\09{\0A\09\09\09\09\09\09\0A\09\09\09\09\09\09\0A\09\09\09\09\09\09float f;\0A\09\09\09\09\09\09float4 r = p[ie]-center;\0A\09\09\09\09\09\09f = dot3F4( u, r );\0A\09\09\09\09\09\09a[ie].x = ((*(u32*)&f) & 0xffffff00) | (0xff & ie);\0A\09\09\09\09\09\09f = dot3F4( -u, r );\0A\09\09\09\09\09\09a[ie].y = ((*(u32*)&f) & 0xffffff00) | (0xff & ie);\0A\09\09\09\09\09\09f = dot3F4( v, r );\0A\09\09\09\09\09\09a[ie].z = ((*(u32*)&f) & 0xffffff00) | (0xff & ie);\0A\09\09\09\09\09\09f = dot3F4( -v, r );\0A\09\09\09\09\09\09a[ie].w = ((*(u32*)&f) & 0xffffff00) | (0xff & ie);\0A\09\09\09\09\09}\0A\09\09\09\09\09for(int ie=0; ie<nPoints; ie++)\0A\09\09\09\09\09{\0A\09\09\09\09\09\09a[0].x = (a[0].x > a[ie].x )? a[0].x: a[ie].x;\0A\09\09\09\09\09\09a[0].y = (a[0].y > a[ie].y )? a[0].y: a[ie].y;\0A\09\09\09\09\09\09a[0].z = (a[0].z > a[ie].z )? a[0].z: a[ie].z;\0A\09\09\09\09\09\09a[0].w = (a[0].w > a[ie].w )? a[0].w: a[ie].w;\0A\09\09\09\09\09}\0A\09\09\09\09\09idx[0] = (int)a[0].x & 0xff;\0A\09\09\09\09\09idx[1] = (int)a[0].y & 0xff;\0A\09\09\09\09\09idx[2] = (int)a[0].z & 0xff;\0A\09\09\09\09\09idx[3] = (int)a[0].w & 0xff;\0A\09\09\09\09}\0A\09\09\09}\0A\09\09\09{\0A\09\09\09\09float2 h[64];\0A\09\09\09\09PARALLEL_DO( h[ie] = make_float2((float)ie, p[ie].w), nPoints );\0A\09\09\09\09REDUCE_MIN( h, nPoints );\0A\09\09\09\09max00 = h[0];\0A\09\09\09}\0A\09\09}\0A\09\09contactIdx[0] = idx[0];\0A\09\09contactIdx[1] = idx[1];\0A\09\09contactIdx[2] = idx[2];\0A\09\09contactIdx[3] = idx[3];\0A\09\09return 4;\0A\09}\0A}\0A__kernel void   extractManifoldAndAddContactKernel(__global const int4* pairs, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3RigidBodyData_t* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* closestPointsWorld,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* separatingNormalsWorld,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* contactCounts,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* contactOffsets,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global struct b3Contact4Data* restrict contactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09counter32_t nContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int contactCapacity,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numPairs,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int pairIndex\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09)\0A{\0A\09int idx = get_global_id(0);\0A\09\0A\09if (idx<numPairs)\0A\09{\0A\09\09float4 normal = separatingNormalsWorld[idx];\0A\09\09int nPoints = contactCounts[idx];\0A\09\09__global const float4* pointsIn = &closestPointsWorld[contactOffsets[idx]];\0A\09\09float4 localPoints[64];\0A\09\09for (int i=0;i<nPoints;i++)\0A\09\09{\0A\09\09\09localPoints[i] = pointsIn[i];\0A\09\09}\0A\09\09int contactIdx[4];// = {-1,-1,-1,-1};\0A\09\09contactIdx[0] = -1;\0A\09\09contactIdx[1] = -1;\0A\09\09contactIdx[2] = -1;\0A\09\09contactIdx[3] = -1;\0A\09\09int nContacts = extractManifoldSequential(localPoints, nPoints, normal, contactIdx);\0A\09\09int dstIdx;\0A\09\09AppendInc( nContactsOut, dstIdx );\0A\09\09if (dstIdx<contactCapacity)\0A\09\09{\0A\09\09\09__global struct b3Contact4Data* c = contactsOut + dstIdx;\0A\09\09\09c->m_worldNormalOnB = -normal;\0A\09\09\09c->m_restituitionCoeffCmp = (0.f*0xffff);c->m_frictionCoeffCmp = (0.7f*0xffff);\0A\09\09\09c->m_batchIdx = idx;\0A\09\09\09int bodyA = pairs[pairIndex].x;\0A\09\09\09int bodyB = pairs[pairIndex].y;\0A\09\09\09c->m_bodyAPtrAndSignBit = rigidBodies[bodyA].m_invMass==0 ? -bodyA:bodyA;\0A\09\09\09c->m_bodyBPtrAndSignBit = rigidBodies[bodyB].m_invMass==0 ? -bodyB:bodyB;\0A\09\09\09c->m_childIndexA = -1;\0A\09\09\09c->m_childIndexB = -1;\0A\09\09\09for (int i=0;i<nContacts;i++)\0A\09\09\09{\0A\09\09\09\09c->m_worldPosB[i] = localPoints[contactIdx[i]];\0A\09\09\09}\0A\09\09\09GET_NPOINTS(*c) = nContacts;\0A\09\09}\0A\09}\0A}\0Avoid\09trInverse(float4 translationIn, Quaternion orientationIn,\0A\09\09float4* translationOut, Quaternion* orientationOut)\0A{\0A\09*orientationOut = qtInvert(orientationIn);\0A\09*translationOut = qtRotate(*orientationOut, -translationIn);\0A}\0Avoid\09trMul(float4 translationA, Quaternion orientationA,\0A\09\09\09\09\09\09float4 translationB, Quaternion orientationB,\0A\09\09float4* translationOut, Quaternion* orientationOut)\0A{\0A\09*orientationOut = qtMul(orientationA,orientationB);\0A\09*translationOut = transform(&translationB,&translationA,&orientationA);\0A}\0A__kernel void   clipHullHullKernel( __global int4* pairs, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3RigidBodyData_t* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3Collidable_t* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3ConvexPolyhedronData_t* convexShapes, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* vertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* uniqueEdges,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3GpuFace_t* faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* separatingNormals,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* hasSeparatingAxis,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global struct b3Contact4Data* restrict globalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09counter32_t nGlobalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numPairs,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int contactCapacity)\0A{\0A\09int i = get_global_id(0);\0A\09int pairIndex = i;\0A\09\0A\09float4 worldVertsB1[64];\0A\09float4 worldVertsB2[64];\0A\09int capacityWorldVerts = 64;\09\0A\09float4 localContactsOut[64];\0A\09int localContactCapacity=64;\0A\09\0A\09float minDist = -1e30f;\0A\09float maxDist = 0.02f;\0A\09if (i<numPairs)\0A\09{\0A\09\09int bodyIndexA = pairs[i].x;\0A\09\09int bodyIndexB = pairs[i].y;\0A\09\09\09\0A\09\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09\09if (hasSeparatingAxis[i])\0A\09\09{\0A\09\09\09\0A\09\09\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09\09\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09\09\09\0A\09\09\0A\09\09\09int numLocalContactsOut = clipHullAgainstHull(separatingNormals[i],\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09&convexShapes[shapeIndexA], &convexShapes[shapeIndexB],\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09rigidBodies[bodyIndexA].m_pos,rigidBodies[bodyIndexA].m_quat,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09  rigidBodies[bodyIndexB].m_pos,rigidBodies[bodyIndexB].m_quat,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09  worldVertsB1,worldVertsB2,capacityWorldVerts,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09minDist, maxDist,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09vertices,faces,indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09localContactsOut,localContactCapacity);\0A\09\09\09\09\09\09\09\09\09\09\09\09\0A\09\09if (numLocalContactsOut>0)\0A\09\09{\0A\09\09\09\09float4 normal = -separatingNormals[i];\0A\09\09\09\09int nPoints = numLocalContactsOut;\0A\09\09\09\09float4* pointsIn = localContactsOut;\0A\09\09\09\09int contactIdx[4];// = {-1,-1,-1,-1};\0A\09\09\09\09contactIdx[0] = -1;\0A\09\09\09\09contactIdx[1] = -1;\0A\09\09\09\09contactIdx[2] = -1;\0A\09\09\09\09contactIdx[3] = -1;\0A\09\09\0A\09\09\09\09int nReducedContacts = extractManifoldSequential(pointsIn, nPoints, normal, contactIdx);\0A\09\09\0A\09\09\09\09\0A\09\09\09\09int mprContactIndex = pairs[pairIndex].z;\0A\09\09\09\09int dstIdx = mprContactIndex;\0A\09\09\09\09if (dstIdx<0)\0A\09\09\09\09{\0A\09\09\09\09\09AppendInc( nGlobalContactsOut, dstIdx );\0A\09\09\09\09}\0A\09\09\09\09if (dstIdx<contactCapacity)\0A\09\09\09\09{\0A\09\09\09\09\09pairs[pairIndex].z = dstIdx;\0A\09\09\09\09\09__global struct b3Contact4Data* c = globalContactsOut+ dstIdx;\0A\09\09\09\09\09c->m_worldNormalOnB = -normal;\0A\09\09\09\09\09c->m_restituitionCoeffCmp = (0.f*0xffff);c->m_frictionCoeffCmp = (0.7f*0xffff);\0A\09\09\09\09\09c->m_batchIdx = pairIndex;\0A\09\09\09\09\09int bodyA = pairs[pairIndex].x;\0A\09\09\09\09\09int bodyB = pairs[pairIndex].y;\0A\09\09\09\09\09c->m_bodyAPtrAndSignBit = rigidBodies[bodyA].m_invMass==0?-bodyA:bodyA;\0A\09\09\09\09\09c->m_bodyBPtrAndSignBit = rigidBodies[bodyB].m_invMass==0?-bodyB:bodyB;\0A\09\09\09\09\09c->m_childIndexA = -1;\0A\09\09\09\09\09c->m_childIndexB = -1;\0A\09\09\09\09\09for (int i=0;i<nReducedContacts;i++)\0A\09\09\09\09\09{\0A\09\09\09\09\09//this condition means: overwrite contact point, unless at index i==0 we have a valid 'mpr' contact\0A\09\09\09\09\09\09if (i>0||(mprContactIndex<0))\0A\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09c->m_worldPosB[i] = pointsIn[contactIdx[i]];\0A\09\09\09\09\09\09}\0A\09\09\09\09\09}\0A\09\09\09\09\09GET_NPOINTS(*c) = nReducedContacts;\0A\09\09\09\09}\0A\09\09\09\09\0A\09\09\09}//\09\09if (numContactsOut>0)\0A\09\09}//\09\09if (hasSeparatingAxis[i])\0A\09}//\09if (i<numPairs)\0A}\0A__kernel void   clipCompoundsHullHullKernel( __global const int4* gpuCompoundPairs, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3RigidBodyData_t* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3Collidable_t* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3ConvexPolyhedronData_t* convexShapes, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* vertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* uniqueEdges,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3GpuFace_t* faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3GpuChildShape_t* gpuChildShapes,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* gpuCompoundSepNormalsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* gpuHasCompoundSepNormalsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global struct b3Contact4Data* restrict globalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09counter32_t nGlobalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numCompoundPairs, int maxContactCapacity)\0A{\0A\09int i = get_global_id(0);\0A\09int pairIndex = i;\0A\09\0A\09float4 worldVertsB1[64];\0A\09float4 worldVertsB2[64];\0A\09int capacityWorldVerts = 64;\09\0A\09float4 localContactsOut[64];\0A\09int localContactCapacity=64;\0A\09\0A\09float minDist = -1e30f;\0A\09float maxDist = 0.02f;\0A\09if (i<numCompoundPairs)\0A\09{\0A\09\09if (gpuHasCompoundSepNormalsOut[i])\0A\09\09{\0A\09\09\09int bodyIndexA = gpuCompoundPairs[i].x;\0A\09\09\09int bodyIndexB = gpuCompoundPairs[i].y;\0A\09\09\09\0A\09\09\09int childShapeIndexA = gpuCompoundPairs[i].z;\0A\09\09\09int childShapeIndexB = gpuCompoundPairs[i].w;\0A\09\09\09\0A\09\09\09int collidableIndexA = -1;\0A\09\09\09int collidableIndexB = -1;\0A\09\09\09\0A\09\09\09float4 ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09\09\0A\09\09\09float4 ornB = rigidBodies[bodyIndexB].m_quat;\0A\09\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09\09\09\09\09\09\0A\09\09\09if (childShapeIndexA >= 0)\0A\09\09\09{\0A\09\09\09\09collidableIndexA = gpuChildShapes[childShapeIndexA].m_shapeIndex;\0A\09\09\09\09float4 childPosA = gpuChildShapes[childShapeIndexA].m_childPosition;\0A\09\09\09\09float4 childOrnA = gpuChildShapes[childShapeIndexA].m_childOrientation;\0A\09\09\09\09float4 newPosA = qtRotate(ornA,childPosA)+posA;\0A\09\09\09\09float4 newOrnA = qtMul(ornA,childOrnA);\0A\09\09\09\09posA = newPosA;\0A\09\09\09\09ornA = newOrnA;\0A\09\09\09} else\0A\09\09\09{\0A\09\09\09\09collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09\09}\0A\09\09\09\0A\09\09\09if (childShapeIndexB>=0)\0A\09\09\09{\0A\09\09\09\09collidableIndexB = gpuChildShapes[childShapeIndexB].m_shapeIndex;\0A\09\09\09\09float4 childPosB = gpuChildShapes[childShapeIndexB].m_childPosition;\0A\09\09\09\09float4 childOrnB = gpuChildShapes[childShapeIndexB].m_childOrientation;\0A\09\09\09\09float4 newPosB = transform(&childPosB,&posB,&ornB);\0A\09\09\09\09float4 newOrnB = qtMul(ornB,childOrnB);\0A\09\09\09\09posB = newPosB;\0A\09\09\09\09ornB = newOrnB;\0A\09\09\09} else\0A\09\09\09{\0A\09\09\09\09collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\09\0A\09\09\09}\0A\09\09\09\0A\09\09\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09\09\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09\09\0A\09\09\09int numLocalContactsOut = clipHullAgainstHull(gpuCompoundSepNormalsOut[i],\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09&convexShapes[shapeIndexA], &convexShapes[shapeIndexB],\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09posA,ornA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09  posB,ornB,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09  worldVertsB1,worldVertsB2,capacityWorldVerts,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09minDist, maxDist,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09vertices,faces,indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09localContactsOut,localContactCapacity);\0A\09\09\09\09\09\09\09\09\09\09\09\09\0A\09\09if (numLocalContactsOut>0)\0A\09\09{\0A\09\09\09\09float4 normal = -gpuCompoundSepNormalsOut[i];\0A\09\09\09\09int nPoints = numLocalContactsOut;\0A\09\09\09\09float4* pointsIn = localContactsOut;\0A\09\09\09\09int contactIdx[4];// = {-1,-1,-1,-1};\0A\09\09\09\09contactIdx[0] = -1;\0A\09\09\09\09contactIdx[1] = -1;\0A\09\09\09\09contactIdx[2] = -1;\0A\09\09\09\09contactIdx[3] = -1;\0A\09\09\0A\09\09\09\09int nReducedContacts = extractManifoldSequential(pointsIn, nPoints, normal, contactIdx);\0A\09\09\0A\09\09\09\09int dstIdx;\0A\09\09\09\09AppendInc( nGlobalContactsOut, dstIdx );\0A\09\09\09\09if ((dstIdx+nReducedContacts) < maxContactCapacity)\0A\09\09\09\09{\0A\09\09\09\09\09__global struct b3Contact4Data* c = globalContactsOut+ dstIdx;\0A\09\09\09\09\09c->m_worldNormalOnB = -normal;\0A\09\09\09\09\09c->m_restituitionCoeffCmp = (0.f*0xffff);c->m_frictionCoeffCmp = (0.7f*0xffff);\0A\09\09\09\09\09c->m_batchIdx = pairIndex;\0A\09\09\09\09\09int bodyA = gpuCompoundPairs[pairIndex].x;\0A\09\09\09\09\09int bodyB = gpuCompoundPairs[pairIndex].y;\0A\09\09\09\09\09c->m_bodyAPtrAndSignBit = rigidBodies[bodyA].m_invMass==0?-bodyA:bodyA;\0A\09\09\09\09\09c->m_bodyBPtrAndSignBit = rigidBodies[bodyB].m_invMass==0?-bodyB:bodyB;\0A\09\09\09\09\09c->m_childIndexA = childShapeIndexA;\0A\09\09\09\09\09c->m_childIndexB = childShapeIndexB;\0A\09\09\09\09\09for (int i=0;i<nReducedContacts;i++)\0A\09\09\09\09\09{\0A\09\09\09\09\09\09c->m_worldPosB[i] = pointsIn[contactIdx[i]];\0A\09\09\09\09\09}\0A\09\09\09\09\09GET_NPOINTS(*c) = nReducedContacts;\0A\09\09\09\09}\0A\09\09\09\09\0A\09\09\09}//\09\09if (numContactsOut>0)\0A\09\09}//\09\09if (gpuHasCompoundSepNormalsOut[i])\0A\09}//\09if (i<numCompoundPairs)\0A}\0A__kernel void   sphereSphereCollisionKernel( __global const int4* pairs, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3RigidBodyData_t* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3Collidable_t* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* separatingNormals,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* hasSeparatingAxis,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global struct b3Contact4Data* restrict globalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09counter32_t nGlobalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int contactCapacity,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numPairs)\0A{\0A\09int i = get_global_id(0);\0A\09int pairIndex = i;\0A\09\0A\09if (i<numPairs)\0A\09{\0A\09\09int bodyIndexA = pairs[i].x;\0A\09\09int bodyIndexB = pairs[i].y;\0A\09\09\09\0A\09\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09\09if (collidables[collidableIndexA].m_shapeType == SHAPE_SPHERE &&\0A\09\09\09collidables[collidableIndexB].m_shapeType == SHAPE_SPHERE)\0A\09\09{\0A\09\09\09//sphere-sphere\0A\09\09\09float radiusA = collidables[collidableIndexA].m_radius;\0A\09\09\09float radiusB = collidables[collidableIndexB].m_radius;\0A\09\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09float4 diff = posA-posB;\0A\09\09\09float len = length(diff);\0A\09\09\09\0A\09\09\09///iff distance positive, don't generate a new contact\0A\09\09\09if ( len <= (radiusA+radiusB))\0A\09\09\09{\0A\09\09\09\09///distance (negative means penetration)\0A\09\09\09\09float dist = len - (radiusA+radiusB);\0A\09\09\09\09float4 normalOnSurfaceB = make_float4(1.f,0.f,0.f,0.f);\0A\09\09\09\09if (len > 0.00001)\0A\09\09\09\09{\0A\09\09\09\09\09normalOnSurfaceB = diff / len;\0A\09\09\09\09}\0A\09\09\09\09float4 contactPosB = posB + normalOnSurfaceB*radiusB;\0A\09\09\09\09contactPosB.w = dist;\0A\09\09\09\09\09\09\09\09\0A\09\09\09\09int dstIdx;\0A\09\09\09\09AppendInc( nGlobalContactsOut, dstIdx );\0A\09\09\09\09if (dstIdx < contactCapacity)\0A\09\09\09\09{\0A\09\09\09\09\09__global struct b3Contact4Data* c = &globalContactsOut[dstIdx];\0A\09\09\09\09\09c->m_worldNormalOnB = -normalOnSurfaceB;\0A\09\09\09\09\09c->m_restituitionCoeffCmp = (0.f*0xffff);c->m_frictionCoeffCmp = (0.7f*0xffff);\0A\09\09\09\09\09c->m_batchIdx = pairIndex;\0A\09\09\09\09\09int bodyA = pairs[pairIndex].x;\0A\09\09\09\09\09int bodyB = pairs[pairIndex].y;\0A\09\09\09\09\09c->m_bodyAPtrAndSignBit = rigidBodies[bodyA].m_invMass==0?-bodyA:bodyA;\0A\09\09\09\09\09c->m_bodyBPtrAndSignBit = rigidBodies[bodyB].m_invMass==0?-bodyB:bodyB;\0A\09\09\09\09\09c->m_worldPosB[0] = contactPosB;\0A\09\09\09\09\09c->m_childIndexA = -1;\0A\09\09\09\09\09c->m_childIndexB = -1;\0A\09\09\09\09\09GET_NPOINTS(*c) = 1;\0A\09\09\09\09}//if (dstIdx < numPairs)\0A\09\09\09}//if ( len <= (radiusA+radiusB))\0A\09\09}//SHAPE_SPHERE SHAPE_SPHERE\0A\09}//if (i<numPairs)\0A}\09\09\09\09\0A__kernel void   clipHullHullConcaveConvexKernel( __global int4* concavePairsIn,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3RigidBodyData_t* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3Collidable_t* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3ConvexPolyhedronData_t* convexShapes, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* vertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* uniqueEdges,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3GpuFace_t* faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3GpuChildShape_t* gpuChildShapes,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* separatingNormals,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global struct b3Contact4Data* restrict globalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09counter32_t nGlobalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int contactCapacity,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numConcavePairs)\0A{\0A\09int i = get_global_id(0);\0A\09int pairIndex = i;\0A\09\0A\09float4 worldVertsB1[64];\0A\09float4 worldVertsB2[64];\0A\09int capacityWorldVerts = 64;\09\0A\09float4 localContactsOut[64];\0A\09int localContactCapacity=64;\0A\09\0A\09float minDist = -1e30f;\0A\09float maxDist = 0.02f;\0A\09if (i<numConcavePairs)\0A\09{\0A\09\09//negative value means that the pair is invalid\0A\09\09if (concavePairsIn[i].w<0)\0A\09\09\09return;\0A\09\09int bodyIndexA = concavePairsIn[i].x;\0A\09\09int bodyIndexB = concavePairsIn[i].y;\0A\09\09int f = concavePairsIn[i].z;\0A\09\09int childShapeIndexA = f;\0A\09\09\0A\09\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09\09\0A\09\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09\09\0A\09\09///////////////////////////////////////////////////////////////\0A\09\09\0A\09\0A\09\09bool overlap = false;\0A\09\09\0A\09\09b3ConvexPolyhedronData_t convexPolyhedronA;\0A\09//add 3 vertices of the triangle\0A\09\09convexPolyhedronA.m_numVertices = 3;\0A\09\09convexPolyhedronA.m_vertexOffset = 0;\0A\09\09float4\09localCenter = make_float4(0.f,0.f,0.f,0.f);\0A\09\09b3GpuFace_t face = faces[convexShapes[shapeIndexA].m_faceOffset+f];\0A\09\09\0A\09\09float4 verticesA[3];\0A\09\09for (int i=0;i<3;i++)\0A\09\09{\0A\09\09\09int index = indices[face.m_indexOffset+i];\0A\09\09\09float4 vert = vertices[convexShapes[shapeIndexA].m_vertexOffset+index];\0A\09\09\09verticesA[i] = vert;\0A\09\09\09localCenter += vert;\0A\09\09}\0A\09\09float dmin = FLT_MAX;\0A\09\09int localCC=0;\0A\09\09//a triangle has 3 unique edges\0A\09\09convexPolyhedronA.m_numUniqueEdges = 3;\0A\09\09convexPolyhedronA.m_uniqueEdgesOffset = 0;\0A\09\09float4 uniqueEdgesA[3];\0A\09\09\0A\09\09uniqueEdgesA[0] = (verticesA[1]-verticesA[0]);\0A\09\09uniqueEdgesA[1] = (verticesA[2]-verticesA[1]);\0A\09\09uniqueEdgesA[2] = (verticesA[0]-verticesA[2]);\0A\09\09convexPolyhedronA.m_faceOffset = 0;\0A                                  \0A\09\09float4 normal = make_float4(face.m_plane.x,face.m_plane.y,face.m_plane.z,0.f);\0A                             \0A\09\09b3GpuFace_t facesA[TRIANGLE_NUM_CONVEX_FACES];\0A\09\09int indicesA[3+3+2+2+2];\0A\09\09int curUsedIndices=0;\0A\09\09int fidx=0;\0A\09\09//front size of triangle\0A\09\09{\0A\09\09\09facesA[fidx].m_indexOffset=curUsedIndices;\0A\09\09\09indicesA[0] = 0;\0A\09\09\09indicesA[1] = 1;\0A\09\09\09indicesA[2] = 2;\0A\09\09\09curUsedIndices+=3;\0A\09\09\09float c = face.m_plane.w;\0A\09\09\09facesA[fidx].m_plane.x = normal.x;\0A\09\09\09facesA[fidx].m_plane.y = normal.y;\0A\09\09\09facesA[fidx].m_plane.z = normal.z;\0A\09\09\09facesA[fidx].m_plane.w = c;\0A\09\09\09facesA[fidx].m_numIndices=3;\0A\09\09}\0A\09\09fidx++;\0A\09\09//back size of triangle\0A\09\09{\0A\09\09\09facesA[fidx].m_indexOffset=curUsedIndices;\0A\09\09\09indicesA[3]=2;\0A\09\09\09indicesA[4]=1;\0A\09\09\09indicesA[5]=0;\0A\09\09\09curUsedIndices+=3;\0A\09\09\09float c = dot3F4(normal,verticesA[0]);\0A\09\09\09float c1 = -face.m_plane.w;\0A\09\09\09facesA[fidx].m_plane.x = -normal.x;\0A\09\09\09facesA[fidx].m_plane.y = -normal.y;\0A\09\09\09facesA[fidx].m_plane.z = -normal.z;\0A\09\09\09facesA[fidx].m_plane.w = c;\0A\09\09\09facesA[fidx].m_numIndices=3;\0A\09\09}\0A\09\09fidx++;\0A\09\09bool addEdgePlanes = true;\0A\09\09if (addEdgePlanes)\0A\09\09{\0A\09\09\09int numVertices=3;\0A\09\09\09int prevVertex = numVertices-1;\0A\09\09\09for (int i=0;i<numVertices;i++)\0A\09\09\09{\0A\09\09\09\09float4 v0 = verticesA[i];\0A\09\09\09\09float4 v1 = verticesA[prevVertex];\0A                                            \0A\09\09\09\09float4 edgeNormal = normalize(cross(normal,v1-v0));\0A\09\09\09\09float c = -dot3F4(edgeNormal,v0);\0A\09\09\09\09facesA[fidx].m_numIndices = 2;\0A\09\09\09\09facesA[fidx].m_indexOffset=curUsedIndices;\0A\09\09\09\09indicesA[curUsedIndices++]=i;\0A\09\09\09\09indicesA[curUsedIndices++]=prevVertex;\0A                                            \0A\09\09\09\09facesA[fidx].m_plane.x = edgeNormal.x;\0A\09\09\09\09facesA[fidx].m_plane.y = edgeNormal.y;\0A\09\09\09\09facesA[fidx].m_plane.z = edgeNormal.z;\0A\09\09\09\09facesA[fidx].m_plane.w = c;\0A\09\09\09\09fidx++;\0A\09\09\09\09prevVertex = i;\0A\09\09\09}\0A\09\09}\0A\09\09convexPolyhedronA.m_numFaces = TRIANGLE_NUM_CONVEX_FACES;\0A\09\09convexPolyhedronA.m_localCenter = localCenter*(1.f/3.f);\0A\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09posA.w = 0.f;\0A\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09posB.w = 0.f;\0A\09\09float4 ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09float4 ornB =rigidBodies[bodyIndexB].m_quat;\0A\09\09float4 sepAxis = separatingNormals[i];\0A\09\09\0A\09\09int shapeTypeB = collidables[collidableIndexB].m_shapeType;\0A\09\09int childShapeIndexB =-1;\0A\09\09if (shapeTypeB==SHAPE_COMPOUND_OF_CONVEX_HULLS)\0A\09\09{\0A\09\09\09///////////////////\0A\09\09\09///compound shape support\0A\09\09\09\0A\09\09\09childShapeIndexB = concavePairsIn[pairIndex].w;\0A\09\09\09int childColIndexB = gpuChildShapes[childShapeIndexB].m_shapeIndex;\0A\09\09\09shapeIndexB = collidables[childColIndexB].m_shapeIndex;\0A\09\09\09float4 childPosB = gpuChildShapes[childShapeIndexB].m_childPosition;\0A\09\09\09float4 childOrnB = gpuChildShapes[childShapeIndexB].m_childOrientation;\0A\09\09\09float4 newPosB = transform(&childPosB,&posB,&ornB);\0A\09\09\09float4 newOrnB = qtMul(ornB,childOrnB);\0A\09\09\09posB = newPosB;\0A\09\09\09ornB = newOrnB;\0A\09\09\09\0A\09\09}\0A\09\09\0A\09\09////////////////////////////////////////\0A\09\09\0A\09\09\0A\09\09\0A\09\09int numLocalContactsOut = clipHullAgainstHullLocalA(sepAxis,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09&convexPolyhedronA, &convexShapes[shapeIndexB],\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09posA,ornA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09  posB,ornB,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09  worldVertsB1,worldVertsB2,capacityWorldVerts,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09minDist, maxDist,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09&verticesA,&facesA,&indicesA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09vertices,faces,indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09localContactsOut,localContactCapacity);\0A\09\09\09\09\09\09\09\09\09\09\09\09\0A\09\09if (numLocalContactsOut>0)\0A\09\09{\0A\09\09\09float4 normal = -separatingNormals[i];\0A\09\09\09int nPoints = numLocalContactsOut;\0A\09\09\09float4* pointsIn = localContactsOut;\0A\09\09\09int contactIdx[4];// = {-1,-1,-1,-1};\0A\09\09\09contactIdx[0] = -1;\0A\09\09\09contactIdx[1] = -1;\0A\09\09\09contactIdx[2] = -1;\0A\09\09\09contactIdx[3] = -1;\0A\09\0A\09\09\09int nReducedContacts = extractManifoldSequential(pointsIn, nPoints, normal, contactIdx);\0A\09\0A\09\09\09int dstIdx;\0A\09\09\09AppendInc( nGlobalContactsOut, dstIdx );\0A\09\09\09if (dstIdx<contactCapacity)\0A\09\09\09{\0A\09\09\09\09__global struct b3Contact4Data* c = globalContactsOut+ dstIdx;\0A\09\09\09\09c->m_worldNormalOnB = -normal;\0A\09\09\09\09c->m_restituitionCoeffCmp = (0.f*0xffff);c->m_frictionCoeffCmp = (0.7f*0xffff);\0A\09\09\09\09c->m_batchIdx = pairIndex;\0A\09\09\09\09int bodyA = concavePairsIn[pairIndex].x;\0A\09\09\09\09int bodyB = concavePairsIn[pairIndex].y;\0A\09\09\09\09c->m_bodyAPtrAndSignBit = rigidBodies[bodyA].m_invMass==0?-bodyA:bodyA;\0A\09\09\09\09c->m_bodyBPtrAndSignBit = rigidBodies[bodyB].m_invMass==0?-bodyB:bodyB;\0A\09\09\09\09c->m_childIndexA = childShapeIndexA;\0A\09\09\09\09c->m_childIndexB = childShapeIndexB;\0A\09\09\09\09for (int i=0;i<nReducedContacts;i++)\0A\09\09\09\09{\0A\09\09\09\09\09c->m_worldPosB[i] = pointsIn[contactIdx[i]];\0A\09\09\09\09}\0A\09\09\09\09GET_NPOINTS(*c) = nReducedContacts;\0A\09\09\09}\0A\09\09\09\09\0A\09\09}//\09\09if (numContactsOut>0)\0A\09}//\09if (i<numPairs)\0A}\0Aint\09findClippingFaces(const float4 separatingNormal,\0A                      __global const b3ConvexPolyhedronData_t* hullA, __global const b3ConvexPolyhedronData_t* hullB,\0A                      const float4 posA, const Quaternion ornA,const float4 posB, const Quaternion ornB,\0A                       __global float4* worldVertsA1,\0A                      __global float4* worldNormalsA1,\0A                      __global float4* worldVertsB1,\0A                      int capacityWorldVerts,\0A                      const float minDist, float maxDist,\0A                      __global const float4* vertices,\0A                      __global const b3GpuFace_t* faces,\0A                      __global const int* indices,\0A                      __global int4* clippingFaces, int pairIndex)\0A{\0A\09int numContactsOut = 0;\0A\09int numWorldVertsB1= 0;\0A    \0A    \0A\09int closestFaceB=-1;\0A\09float dmax = -FLT_MAX;\0A    \0A\09{\0A\09\09for(int face=0;face<hullB->m_numFaces;face++)\0A\09\09{\0A\09\09\09const float4 Normal = make_float4(faces[hullB->m_faceOffset+face].m_plane.x,\0A                                              faces[hullB->m_faceOffset+face].m_plane.y, faces[hullB->m_faceOffset+face].m_plane.z,0.f);\0A\09\09\09const float4 WorldNormal = qtRotate(ornB, Normal);\0A\09\09\09float d = dot3F4(WorldNormal,separatingNormal);\0A\09\09\09if (d > dmax)\0A\09\09\09{\0A\09\09\09\09dmax = d;\0A\09\09\09\09closestFaceB = face;\0A\09\09\09}\0A\09\09}\0A\09}\0A    \0A\09{\0A\09\09const b3GpuFace_t polyB = faces[hullB->m_faceOffset+closestFaceB];\0A\09\09const int numVertices = polyB.m_numIndices;\0A\09\09for(int e0=0;e0<numVertices;e0++)\0A\09\09{\0A\09\09\09const float4 b = vertices[hullB->m_vertexOffset+indices[polyB.m_indexOffset+e0]];\0A\09\09\09worldVertsB1[pairIndex*capacityWorldVerts+numWorldVertsB1++] = transform(&b,&posB,&ornB);\0A\09\09}\0A\09}\0A    \0A    int closestFaceA=-1;\0A\09{\0A\09\09float dmin = FLT_MAX;\0A\09\09for(int face=0;face<hullA->m_numFaces;face++)\0A\09\09{\0A\09\09\09const float4 Normal = make_float4(\0A                                              faces[hullA->m_faceOffset+face].m_plane.x,\0A                                              faces[hullA->m_faceOffset+face].m_plane.y,\0A                                              faces[hullA->m_faceOffset+face].m_plane.z,\0A                                              0.f);\0A\09\09\09const float4 faceANormalWS = qtRotate(ornA,Normal);\0A            \0A\09\09\09float d = dot3F4(faceANormalWS,separatingNormal);\0A\09\09\09if (d < dmin)\0A\09\09\09{\0A\09\09\09\09dmin = d;\0A\09\09\09\09closestFaceA = face;\0A                worldNormalsA1[pairIndex] = faceANormalWS;\0A\09\09\09}\0A\09\09}\0A\09}\0A    \0A    int numVerticesA = faces[hullA->m_faceOffset+closestFaceA].m_numIndices;\0A\09for(int e0=0;e0<numVerticesA;e0++)\0A\09{\0A        const float4 a = vertices[hullA->m_vertexOffset+indices[faces[hullA->m_faceOffset+closestFaceA].m_indexOffset+e0]];\0A        worldVertsA1[pairIndex*capacityWorldVerts+e0] = transform(&a, &posA,&ornA);\0A    }\0A    \0A    clippingFaces[pairIndex].x = closestFaceA;\0A    clippingFaces[pairIndex].y = closestFaceB;\0A    clippingFaces[pairIndex].z = numVerticesA;\0A    clippingFaces[pairIndex].w = numWorldVertsB1;\0A    \0A    \0A\09return numContactsOut;\0A}\0Aint clipFaces(__global float4* worldVertsA1,\0A              __global float4* worldNormalsA1,\0A              __global float4* worldVertsB1,\0A              __global float4* worldVertsB2, \0A              int capacityWorldVertsB2,\0A              const float minDist, float maxDist,\0A              __global int4* clippingFaces,\0A              int pairIndex)\0A{\0A\09int numContactsOut = 0;\0A    \0A    int closestFaceA = clippingFaces[pairIndex].x;\0A    int closestFaceB = clippingFaces[pairIndex].y;\0A\09int numVertsInA = clippingFaces[pairIndex].z;\0A\09int numVertsInB = clippingFaces[pairIndex].w;\0A    \0A\09int numVertsOut = 0;\0A    \0A\09if (closestFaceA<0)\0A\09\09return numContactsOut;\0A    \0A    __global float4* pVtxIn = &worldVertsB1[pairIndex*capacityWorldVertsB2];\0A    __global float4* pVtxOut = &worldVertsB2[pairIndex*capacityWorldVertsB2];\0A    \0A    \0A\09\0A\09// clip polygon to back of planes of all faces of hull A that are adjacent to witness face\0A    \0A\09for(int e0=0;e0<numVertsInA;e0++)\0A\09{\0A\09\09const float4 aw = worldVertsA1[pairIndex*capacityWorldVertsB2+e0];\0A\09\09const float4 bw = worldVertsA1[pairIndex*capacityWorldVertsB2+((e0+1)%numVertsInA)];\0A\09\09const float4 WorldEdge0 = aw - bw;\0A\09\09float4 worldPlaneAnormal1 = worldNormalsA1[pairIndex];\0A\09\09float4 planeNormalWS1 = -cross3(WorldEdge0,worldPlaneAnormal1);\0A\09\09float4 worldA1 = aw;\0A\09\09float planeEqWS1 = -dot3F4(worldA1,planeNormalWS1);\0A\09\09float4 planeNormalWS = planeNormalWS1;\0A\09\09float planeEqWS=planeEqWS1;\0A\09\09numVertsOut = clipFaceGlobal(pVtxIn, numVertsInB, planeNormalWS,planeEqWS, pVtxOut);\0A\09\09__global float4* tmp = pVtxOut;\0A\09\09pVtxOut = pVtxIn;\0A\09\09pVtxIn = tmp;\0A\09\09numVertsInB = numVertsOut;\0A\09\09numVertsOut = 0;\0A\09}\0A    \0A    //float4 planeNormalWS = worldNormalsA1[pairIndex];\0A    //float planeEqWS=-dot3F4(planeNormalWS,worldVertsA1[pairIndex*capacityWorldVertsB2]);\0A    \0A    /*for (int i=0;i<numVertsInB;i++)\0A    {\0A        pVtxOut[i] = pVtxIn[i];\0A    }*/\0A    \0A    \0A    \0A    \0A    //numVertsInB=0;\0A\09\0A    float4 planeNormalWS = worldNormalsA1[pairIndex];\0A    float planeEqWS=-dot3F4(planeNormalWS,worldVertsA1[pairIndex*capacityWorldVertsB2]);\0A    for (int i=0;i<numVertsInB;i++)\0A    {\0A        float depth = dot3F4(planeNormalWS,pVtxIn[i])+planeEqWS;\0A        if (depth <=minDist)\0A        {\0A            depth = minDist;\0A        }\0A        \0A        if (depth <=maxDist)\0A        {\0A            float4 pointInWorld = pVtxIn[i];\0A            pVtxOut[numContactsOut++] = make_float4(pointInWorld.x,pointInWorld.y,pointInWorld.z,depth);\0A        }\0A    }\0A   \0A    clippingFaces[pairIndex].w =numContactsOut;\0A   \0A    \0A\09return numContactsOut;\0A}\0A__kernel void   findClippingFacesKernel(  __global const int4* pairs,\0A                                        __global const b3RigidBodyData_t* rigidBodies,\0A                                        __global const b3Collidable_t* collidables,\0A                                        __global const b3ConvexPolyhedronData_t* convexShapes,\0A                                        __global const float4* vertices,\0A                                        __global const float4* uniqueEdges,\0A                                        __global const b3GpuFace_t* faces,\0A                                        __global const int* indices,\0A                                        __global const float4* separatingNormals,\0A                                        __global const int* hasSeparatingAxis,\0A                                        __global int4* clippingFacesOut,\0A                                        __global float4* worldVertsA1,\0A                                        __global float4* worldNormalsA1,\0A                                        __global float4* worldVertsB1,\0A                                        int capacityWorldVerts,\0A                                        int numPairs\0A                                        )\0A{\0A    \0A\09int i = get_global_id(0);\0A\09int pairIndex = i;\0A    \0A\09\0A\09float minDist = -1e30f;\0A\09float maxDist = 0.02f;\0A    \0A\09if (i<numPairs)\0A\09{\0A        \0A\09\09if (hasSeparatingAxis[i])\0A\09\09{\0A            \0A\09\09\09int bodyIndexA = pairs[i].x;\0A\09\09\09int bodyIndexB = pairs[i].y;\0A\09\09\09\0A\09\09\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09\09\09\0A\09\09\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09\09\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09\09\09\0A            \0A            \0A\09\09\09int numLocalContactsOut = findClippingFaces(separatingNormals[i],\0A                                                        &convexShapes[shapeIndexA], &convexShapes[shapeIndexB],\0A                                                        rigidBodies[bodyIndexA].m_pos,rigidBodies[bodyIndexA].m_quat,\0A                                                        rigidBodies[bodyIndexB].m_pos,rigidBodies[bodyIndexB].m_quat,\0A                                                        worldVertsA1,\0A                                                        worldNormalsA1,\0A                                                        worldVertsB1,capacityWorldVerts,\0A                                                        minDist, maxDist,\0A                                                        vertices,faces,indices,\0A                                                        clippingFacesOut,i);\0A            \0A            \0A\09\09}//\09\09if (hasSeparatingAxis[i])\0A\09}//\09if (i<numPairs)\0A    \0A}\0A__kernel void   clipFacesAndFindContactsKernel(    __global const float4* separatingNormals,\0A                                                   __global const int* hasSeparatingAxis,\0A                                                   __global int4* clippingFacesOut,\0A                                                   __global float4* worldVertsA1,\0A                                                   __global float4* worldNormalsA1,\0A                                                   __global float4* worldVertsB1,\0A                                                   __global float4* worldVertsB2,\0A                                                    int vertexFaceCapacity,\0A                                                   int numPairs,\0A\09\09\09\09\09                                        int debugMode\0A                                                   )\0A{\0A    int i = get_global_id(0);\0A\09int pairIndex = i;\0A\09\0A    \0A\09float minDist = -1e30f;\0A\09float maxDist = 0.02f;\0A    \0A\09if (i<numPairs)\0A\09{\0A        \0A\09\09if (hasSeparatingAxis[i])\0A\09\09{\0A            \0A//\09\09\09int bodyIndexA = pairs[i].x;\0A\09//\09\09int bodyIndexB = pairs[i].y;\0A\09\09    \0A            int numLocalContactsOut = 0;\0A            int capacityWorldVertsB2 = vertexFaceCapacity;\0A            \0A            __global float4* pVtxIn = &worldVertsB1[pairIndex*capacityWorldVertsB2];\0A            __global float4* pVtxOut = &worldVertsB2[pairIndex*capacityWorldVertsB2];\0A            \0A            {\0A                __global int4* clippingFaces = clippingFacesOut;\0A            \0A                \0A                int closestFaceA = clippingFaces[pairIndex].x;\0A                int closestFaceB = clippingFaces[pairIndex].y;\0A                int numVertsInA = clippingFaces[pairIndex].z;\0A                int numVertsInB = clippingFaces[pairIndex].w;\0A                \0A                int numVertsOut = 0;\0A                \0A                if (closestFaceA>=0)\0A                {\0A                    \0A                    \0A                    \0A                    // clip polygon to back of planes of all faces of hull A that are adjacent to witness face\0A                    \0A                    for(int e0=0;e0<numVertsInA;e0++)\0A                    {\0A                        const float4 aw = worldVertsA1[pairIndex*capacityWorldVertsB2+e0];\0A                        const float4 bw = worldVertsA1[pairIndex*capacityWorldVertsB2+((e0+1)%numVertsInA)];\0A                        const float4 WorldEdge0 = aw - bw;\0A                        float4 worldPlaneAnormal1 = worldNormalsA1[pairIndex];\0A                        float4 planeNormalWS1 = -cross3(WorldEdge0,worldPlaneAnormal1);\0A                        float4 worldA1 = aw;\0A                        float planeEqWS1 = -dot3F4(worldA1,planeNormalWS1);\0A                        float4 planeNormalWS = planeNormalWS1;\0A                        float planeEqWS=planeEqWS1;\0A                        numVertsOut = clipFaceGlobal(pVtxIn, numVertsInB, planeNormalWS,planeEqWS, pVtxOut);\0A                        __global float4* tmp = pVtxOut;\0A                        pVtxOut = pVtxIn;\0A                        pVtxIn = tmp;\0A                        numVertsInB = numVertsOut;\0A                        numVertsOut = 0;\0A                    }\0A                    \0A                    float4 planeNormalWS = worldNormalsA1[pairIndex];\0A                    float planeEqWS=-dot3F4(planeNormalWS,worldVertsA1[pairIndex*capacityWorldVertsB2]);\0A                    \0A                    for (int i=0;i<numVertsInB;i++)\0A                    {\0A                        float depth = dot3F4(planeNormalWS,pVtxIn[i])+planeEqWS;\0A                        if (depth <=minDist)\0A                        {\0A                            depth = minDist;\0A                        }\0A                        \0A                        if (depth <=maxDist)\0A                        {\0A                            float4 pointInWorld = pVtxIn[i];\0A                            pVtxOut[numLocalContactsOut++] = make_float4(pointInWorld.x,pointInWorld.y,pointInWorld.z,depth);\0A                        }\0A                    }\0A                    \0A                }\0A                clippingFaces[pairIndex].w =numLocalContactsOut;\0A                \0A            }\0A            \0A            for (int i=0;i<numLocalContactsOut;i++)\0A                pVtxIn[i] = pVtxOut[i];\0A                \0A\09\09}//\09\09if (hasSeparatingAxis[i])\0A\09}//\09if (i<numPairs)\0A    \0A}\0A__kernel void   newContactReductionKernel( __global int4* pairs,\0A                                                   __global const b3RigidBodyData_t* rigidBodies,\0A                                                   __global const float4* separatingNormals,\0A                                                   __global const int* hasSeparatingAxis,\0A                                                   __global struct b3Contact4Data* globalContactsOut,\0A                                                   __global int4* clippingFaces,\0A                                                   __global float4* worldVertsB2,\0A                                                   volatile __global int* nGlobalContactsOut,\0A                                                   int vertexFaceCapacity,\0A\09\09\09\09\09\09\09\09\09\09\09\09   int contactCapacity,\0A                                                   int numPairs\0A                                                   )\0A{\0A    int i = get_global_id(0);\0A\09int pairIndex = i;\0A\09\0A    int4 contactIdx;\0A    contactIdx=make_int4(0,1,2,3);\0A    \0A\09if (i<numPairs)\0A\09{\0A        \0A\09\09if (hasSeparatingAxis[i])\0A\09\09{\0A            \0A\09\09\09\0A            \0A            \0A\09\09\09int nPoints = clippingFaces[pairIndex].w;\0A           \0A            if (nPoints>0)\0A            {\0A                 __global float4* pointsIn = &worldVertsB2[pairIndex*vertexFaceCapacity];\0A                float4 normal = -separatingNormals[i];\0A                \0A                int nReducedContacts = extractManifoldSequentialGlobal(pointsIn, nPoints, normal, &contactIdx);\0A            \0A\09\09\09\09int mprContactIndex = pairs[pairIndex].z;\0A                int dstIdx = mprContactIndex;\0A\09\09\09\09if (dstIdx<0)\0A\09\09\09\09{\0A\09                AppendInc( nGlobalContactsOut, dstIdx );\0A\09\09\09\09}\0A//#if 0\0A                \0A\09\09\09\09if (dstIdx < contactCapacity)\0A\09\09\09\09{\0A\09\09\09\09\09__global struct b3Contact4Data* c = &globalContactsOut[dstIdx];\0A\09\09\09\09\09c->m_worldNormalOnB = -normal;\0A\09\09\09\09\09c->m_restituitionCoeffCmp = (0.f*0xffff);c->m_frictionCoeffCmp = (0.7f*0xffff);\0A\09\09\09\09\09c->m_batchIdx = pairIndex;\0A\09\09\09\09\09int bodyA = pairs[pairIndex].x;\0A\09\09\09\09\09int bodyB = pairs[pairIndex].y;\0A\09\09\09\09\09pairs[pairIndex].w = dstIdx;\0A\09\09\09\09\09c->m_bodyAPtrAndSignBit = rigidBodies[bodyA].m_invMass==0?-bodyA:bodyA;\0A\09\09\09\09\09c->m_bodyBPtrAndSignBit = rigidBodies[bodyB].m_invMass==0?-bodyB:bodyB;\0A                    c->m_childIndexA =-1;\0A\09\09\09\09\09c->m_childIndexB =-1;\0A                    switch (nReducedContacts)\0A                    {\0A                        case 4:\0A                            c->m_worldPosB[3] = pointsIn[contactIdx.w];\0A                        case 3:\0A                            c->m_worldPosB[2] = pointsIn[contactIdx.z];\0A                        case 2:\0A                            c->m_worldPosB[1] = pointsIn[contactIdx.y];\0A                        case 1:\0A\09\09\09\09\09\09\09if (mprContactIndex<0)//test\0A\09                            c->m_worldPosB[0] = pointsIn[contactIdx.x];\0A                        default:\0A                        {\0A                        }\0A                    };\0A                    \0A\09\09\09\09\09GET_NPOINTS(*c) = nReducedContacts;\0A                    \0A                 }\0A                 \0A                \0A//#endif\0A\09\09\09\09\0A\09\09\09}//\09\09if (numContactsOut>0)\0A\09\09}//\09\09if (hasSeparatingAxis[i])\0A\09}//\09if (i<numPairs)\0A    \0A    \0A}\0A\00", align 1
@.str.70 = private unnamed_addr constant [7792 x i8] c"//keep this enum in sync with the CPU version (in btCollidable.h)\0A//written by Erwin Coumans\0A#define SHAPE_CONVEX_HULL 3\0A#define SHAPE_CONCAVE_TRIMESH 5\0A#define TRIANGLE_NUM_CONVEX_FACES 5\0A#define SHAPE_COMPOUND_OF_CONVEX_HULLS 6\0A#define SHAPE_SPHERE 7\0Atypedef unsigned int u32;\0A#define MAX_NUM_PARTS_IN_BITS 10\0A///btQuantizedBvhNode is a compressed aabb node, 16 bytes.\0A///Node can be used for leafnode or internal node. Leafnodes can point to 32-bit triangle index (non-negative range).\0Atypedef struct\0A{\0A\09//12 bytes\0A\09unsigned short int\09m_quantizedAabbMin[3];\0A\09unsigned short int\09m_quantizedAabbMax[3];\0A\09//4 bytes\0A\09int\09m_escapeIndexOrTriangleIndex;\0A} btQuantizedBvhNode;\0Atypedef struct\0A{\0A\09float4\09\09m_aabbMin;\0A\09float4\09\09m_aabbMax;\0A\09float4\09\09m_quantization;\0A\09int\09\09\09m_numNodes;\0A\09int\09\09\09m_numSubTrees;\0A\09int\09\09\09m_nodeOffset;\0A\09int\09\09\09m_subTreeOffset;\0A} b3BvhInfo;\0Aint\09getTriangleIndex(const btQuantizedBvhNode* rootNode)\0A{\0A\09unsigned int x=0;\0A\09unsigned int y = (~(x&0))<<(31-MAX_NUM_PARTS_IN_BITS);\0A\09// Get only the lower bits where the triangle index is stored\0A\09return (rootNode->m_escapeIndexOrTriangleIndex&~(y));\0A}\0Aint isLeaf(const btQuantizedBvhNode* rootNode)\0A{\0A\09//skipindex is negative (internal node), triangleindex >=0 (leafnode)\0A\09return (rootNode->m_escapeIndexOrTriangleIndex >= 0)? 1 : 0;\0A}\0A\09\0Aint getEscapeIndex(const btQuantizedBvhNode* rootNode)\0A{\0A\09return -rootNode->m_escapeIndexOrTriangleIndex;\0A}\0Atypedef struct\0A{\0A\09//12 bytes\0A\09unsigned short int\09m_quantizedAabbMin[3];\0A\09unsigned short int\09m_quantizedAabbMax[3];\0A\09//4 bytes, points to the root of the subtree\0A\09int\09\09\09m_rootNodeIndex;\0A\09//4 bytes\0A\09int\09\09\09m_subtreeSize;\0A\09int\09\09\09m_padding[3];\0A} btBvhSubtreeInfo;\0A///keep this in sync with btCollidable.h\0Atypedef struct\0A{\0A\09int m_numChildShapes;\0A\09int blaat2;\0A\09int m_shapeType;\0A\09int m_shapeIndex;\0A\09\0A} btCollidableGpu;\0Atypedef struct\0A{\0A\09float4\09m_childPosition;\0A\09float4\09m_childOrientation;\0A\09int m_shapeIndex;\0A\09int m_unused0;\0A\09int m_unused1;\0A\09int m_unused2;\0A} btGpuChildShape;\0Atypedef struct\0A{\0A\09float4 m_pos;\0A\09float4 m_quat;\0A\09float4 m_linVel;\0A\09float4 m_angVel;\0A\09u32 m_collidableIdx;\0A\09float m_invMass;\0A\09float m_restituitionCoeff;\0A\09float m_frictionCoeff;\0A} BodyData;\0Atypedef struct \0A{\0A\09union\0A\09{\0A\09\09float4\09m_min;\0A\09\09float   m_minElems[4];\0A\09\09int\09\09\09m_minIndices[4];\0A\09};\0A\09union\0A\09{\0A\09\09float4\09m_max;\0A\09\09float   m_maxElems[4];\0A\09\09int\09\09\09m_maxIndices[4];\0A\09};\0A} btAabbCL;\0Aint testQuantizedAabbAgainstQuantizedAabb(\0A\09\09\09\09\09\09\09\09const unsigned short int* aabbMin1,\0A\09\09\09\09\09\09\09\09const unsigned short int* aabbMax1,\0A\09\09\09\09\09\09\09\09const unsigned short int* aabbMin2,\0A\09\09\09\09\09\09\09\09const unsigned short int* aabbMax2)\0A{\0A\09//int overlap = 1;\0A\09if (aabbMin1[0] > aabbMax2[0])\0A\09\09return 0;\0A\09if (aabbMax1[0] < aabbMin2[0])\0A\09\09return 0;\0A\09if (aabbMin1[1] > aabbMax2[1])\0A\09\09return 0;\0A\09if (aabbMax1[1] < aabbMin2[1])\0A\09\09return 0;\0A\09if (aabbMin1[2] > aabbMax2[2])\0A\09\09return 0;\0A\09if (aabbMax1[2] < aabbMin2[2])\0A\09\09return 0;\0A\09return 1;\0A\09//overlap = ((aabbMin1[0] > aabbMax2[0]) || (aabbMax1[0] < aabbMin2[0])) ? 0 : overlap;\0A\09//overlap = ((aabbMin1[2] > aabbMax2[2]) || (aabbMax1[2] < aabbMin2[2])) ? 0 : overlap;\0A\09//overlap = ((aabbMin1[1] > aabbMax2[1]) || (aabbMax1[1] < aabbMin2[1])) ? 0 : overlap;\0A\09//return overlap;\0A}\0Avoid quantizeWithClamp(unsigned short* out, float4 point2,int isMax, float4 bvhAabbMin, float4 bvhAabbMax, float4 bvhQuantization)\0A{\0A\09float4 clampedPoint = max(point2,bvhAabbMin);\0A\09clampedPoint = min (clampedPoint, bvhAabbMax);\0A\09float4 v = (clampedPoint - bvhAabbMin) * bvhQuantization;\0A\09if (isMax)\0A\09{\0A\09\09out[0] = (unsigned short) (((unsigned short)(v.x+1.f) | 1));\0A\09\09out[1] = (unsigned short) (((unsigned short)(v.y+1.f) | 1));\0A\09\09out[2] = (unsigned short) (((unsigned short)(v.z+1.f) | 1));\0A\09} else\0A\09{\0A\09\09out[0] = (unsigned short) (((unsigned short)(v.x) & 0xfffe));\0A\09\09out[1] = (unsigned short) (((unsigned short)(v.y) & 0xfffe));\0A\09\09out[2] = (unsigned short) (((unsigned short)(v.z) & 0xfffe));\0A\09}\0A}\0A// work-in-progress\0A__kernel void   bvhTraversalKernel( __global const int4* pairs, \0A\09\09\09\09\09\09\09\09\09__global const BodyData* rigidBodies, \0A\09\09\09\09\09\09\09\09\09__global const btCollidableGpu* collidables,\0A\09\09\09\09\09\09\09\09\09__global btAabbCL* aabbs,\0A\09\09\09\09\09\09\09\09\09__global int4* concavePairsOut,\0A\09\09\09\09\09\09\09\09\09__global volatile int* numConcavePairsOut,\0A\09\09\09\09\09\09\09\09\09__global const btBvhSubtreeInfo* subtreeHeadersRoot,\0A\09\09\09\09\09\09\09\09\09__global const btQuantizedBvhNode* quantizedNodesRoot,\0A\09\09\09\09\09\09\09\09\09__global const b3BvhInfo* bvhInfos,\0A\09\09\09\09\09\09\09\09\09int numPairs,\0A\09\09\09\09\09\09\09\09\09int maxNumConcavePairsCapacity)\0A{\0A\09int id = get_global_id(0);\0A\09if (id>=numPairs)\0A\09\09return;\0A\09\0A\09int bodyIndexA = pairs[id].x;\0A\09int bodyIndexB = pairs[id].y;\0A\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09\0A\09//once the broadphase avoids static-static pairs, we can remove this test\0A\09if ((rigidBodies[bodyIndexA].m_invMass==0) &&(rigidBodies[bodyIndexB].m_invMass==0))\0A\09{\0A\09\09return;\0A\09}\0A\09\09\0A\09if (collidables[collidableIndexA].m_shapeType!=SHAPE_CONCAVE_TRIMESH)\0A\09\09return;\0A\09int shapeTypeB = collidables[collidableIndexB].m_shapeType;\0A\09\09\0A\09if (shapeTypeB!=SHAPE_CONVEX_HULL &&\0A\09\09shapeTypeB!=SHAPE_SPHERE\09&&\0A\09\09shapeTypeB!=SHAPE_COMPOUND_OF_CONVEX_HULLS\0A\09\09)\0A\09\09return;\0A\09b3BvhInfo bvhInfo = bvhInfos[collidables[collidableIndexA].m_numChildShapes];\0A\09float4 bvhAabbMin = bvhInfo.m_aabbMin;\0A\09float4 bvhAabbMax = bvhInfo.m_aabbMax;\0A\09float4 bvhQuantization = bvhInfo.m_quantization;\0A\09int numSubtreeHeaders = bvhInfo.m_numSubTrees;\0A\09__global const btBvhSubtreeInfo* subtreeHeaders = &subtreeHeadersRoot[bvhInfo.m_subTreeOffset];\0A\09__global const btQuantizedBvhNode* quantizedNodes = &quantizedNodesRoot[bvhInfo.m_nodeOffset];\0A\09\0A\09unsigned short int quantizedQueryAabbMin[3];\0A\09unsigned short int quantizedQueryAabbMax[3];\0A\09quantizeWithClamp(quantizedQueryAabbMin,aabbs[bodyIndexB].m_min,false,bvhAabbMin, bvhAabbMax,bvhQuantization);\0A\09quantizeWithClamp(quantizedQueryAabbMax,aabbs[bodyIndexB].m_max,true ,bvhAabbMin, bvhAabbMax,bvhQuantization);\0A\09\0A\09for (int i=0;i<numSubtreeHeaders;i++)\0A\09{\0A\09\09btBvhSubtreeInfo subtree = subtreeHeaders[i];\0A\09\09\09\09\0A\09\09int overlap = testQuantizedAabbAgainstQuantizedAabb(quantizedQueryAabbMin,quantizedQueryAabbMax,subtree.m_quantizedAabbMin,subtree.m_quantizedAabbMax);\0A\09\09if (overlap != 0)\0A\09\09{\0A\09\09\09int startNodeIndex = subtree.m_rootNodeIndex;\0A\09\09\09int endNodeIndex = subtree.m_rootNodeIndex+subtree.m_subtreeSize;\0A\09\09\09int curIndex = startNodeIndex;\0A\09\09\09int escapeIndex;\0A\09\09\09int isLeafNode;\0A\09\09\09int aabbOverlap;\0A\09\09\09while (curIndex < endNodeIndex)\0A\09\09\09{\0A\09\09\09\09btQuantizedBvhNode rootNode = quantizedNodes[curIndex];\0A\09\09\09\09aabbOverlap = testQuantizedAabbAgainstQuantizedAabb(quantizedQueryAabbMin,quantizedQueryAabbMax,rootNode.m_quantizedAabbMin,rootNode.m_quantizedAabbMax);\0A\09\09\09\09isLeafNode = isLeaf(&rootNode);\0A\09\09\09\09if (aabbOverlap)\0A\09\09\09\09{\0A\09\09\09\09\09if (isLeafNode)\0A\09\09\09\09\09{\0A\09\09\09\09\09\09int triangleIndex = getTriangleIndex(&rootNode);\0A\09\09\09\09\09\09if (shapeTypeB==SHAPE_COMPOUND_OF_CONVEX_HULLS)\0A\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09int numChildrenB = collidables[collidableIndexB].m_numChildShapes;\0A\09\09\09\09\09\09\09\09int pairIdx = atomic_add(numConcavePairsOut,numChildrenB);\0A\09\09\09\09\09\09\09\09for (int b=0;b<numChildrenB;b++)\0A\09\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09\09if ((pairIdx+b)<maxNumConcavePairsCapacity)\0A\09\09\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09\09\09int childShapeIndexB = collidables[collidableIndexB].m_shapeIndex+b;\0A\09\09\09\09\09\09\09\09\09\09int4 newPair = (int4)(bodyIndexA,bodyIndexB,triangleIndex,childShapeIndexB);\0A\09\09\09\09\09\09\09\09\09\09concavePairsOut[pairIdx+b] = newPair;\0A\09\09\09\09\09\09\09\09\09}\0A\09\09\09\09\09\09\09\09}\0A\09\09\09\09\09\09} else\0A\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09int pairIdx = atomic_inc(numConcavePairsOut);\0A\09\09\09\09\09\09\09if (pairIdx<maxNumConcavePairsCapacity)\0A\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09int4 newPair = (int4)(bodyIndexA,bodyIndexB,triangleIndex,0);\0A\09\09\09\09\09\09\09\09concavePairsOut[pairIdx] = newPair;\0A\09\09\09\09\09\09\09}\0A\09\09\09\09\09\09}\0A\09\09\09\09\09} \0A\09\09\09\09\09curIndex++;\0A\09\09\09\09} else\0A\09\09\09\09{\0A\09\09\09\09\09if (isLeafNode)\0A\09\09\09\09\09{\0A\09\09\09\09\09\09curIndex++;\0A\09\09\09\09\09} else\0A\09\09\09\09\09{\0A\09\09\09\09\09\09escapeIndex = getEscapeIndex(&rootNode);\0A\09\09\09\09\09\09curIndex += escapeIndex;\0A\09\09\09\09\09}\0A\09\09\09\09}\0A\09\09\09}\0A\09\09}\0A\09}\0A}\0A\00", align 1
@.str.71 = private unnamed_addr constant [38981 x i8] c"#ifndef B3_CONTACT4DATA_H\0A#define B3_CONTACT4DATA_H\0A#ifndef B3_FLOAT4_H\0A#define B3_FLOAT4_H\0A#ifndef B3_PLATFORM_DEFINITIONS_H\0A#define B3_PLATFORM_DEFINITIONS_H\0Astruct MyTest\0A{\0A\09int bla;\0A};\0A#ifdef __cplusplus\0A#else\0A//keep B3_LARGE_FLOAT*B3_LARGE_FLOAT < FLT_MAX\0A#define B3_LARGE_FLOAT 1e18f\0A#define B3_INFINITY 1e18f\0A#define b3Assert(a)\0A#define b3ConstArray(a) __global const a*\0A#define b3AtomicInc atomic_inc\0A#define b3AtomicAdd atomic_add\0A#define b3Fabs fabs\0A#define b3Sqrt native_sqrt\0A#define b3Sin native_sin\0A#define b3Cos native_cos\0A#define B3_STATIC\0A#endif\0A#endif\0A#ifdef __cplusplus\0A#else\0A\09typedef float4\09b3Float4;\0A\09#define b3Float4ConstArg const b3Float4\0A\09#define b3MakeFloat4 (float4)\0A\09float b3Dot3F4(b3Float4ConstArg v0,b3Float4ConstArg v1)\0A\09{\0A\09\09float4 a1 = b3MakeFloat4(v0.xyz,0.f);\0A\09\09float4 b1 = b3MakeFloat4(v1.xyz,0.f);\0A\09\09return dot(a1, b1);\0A\09}\0A\09b3Float4 b3Cross3(b3Float4ConstArg v0,b3Float4ConstArg v1)\0A\09{\0A\09\09float4 a1 = b3MakeFloat4(v0.xyz,0.f);\0A\09\09float4 b1 = b3MakeFloat4(v1.xyz,0.f);\0A\09\09return cross(a1, b1);\0A\09}\0A\09#define b3MinFloat4 min\0A\09#define b3MaxFloat4 max\0A\09#define b3Normalized(a) normalize(a)\0A#endif \0A\09\09\0Ainline bool b3IsAlmostZero(b3Float4ConstArg v)\0A{\0A\09if(b3Fabs(v.x)>1e-6 || b3Fabs(v.y)>1e-6 || b3Fabs(v.z)>1e-6)\09\0A\09\09return false;\0A\09return true;\0A}\0Ainline int    b3MaxDot( b3Float4ConstArg vec, __global const b3Float4* vecArray, int vecLen, float* dotOut )\0A{\0A    float maxDot = -B3_INFINITY;\0A    int i = 0;\0A    int ptIndex = -1;\0A    for( i = 0; i < vecLen; i++ )\0A    {\0A        float dot = b3Dot3F4(vecArray[i],vec);\0A            \0A        if( dot > maxDot )\0A        {\0A            maxDot = dot;\0A            ptIndex = i;\0A        }\0A    }\0A\09b3Assert(ptIndex>=0);\0A    if (ptIndex<0)\0A\09{\0A\09\09ptIndex = 0;\0A\09}\0A    *dotOut = maxDot;\0A    return ptIndex;\0A}\0A#endif //B3_FLOAT4_H\0Atypedef  struct b3Contact4Data b3Contact4Data_t;\0Astruct b3Contact4Data\0A{\0A\09b3Float4\09m_worldPosB[4];\0A//\09b3Float4\09m_localPosA[4];\0A//\09b3Float4\09m_localPosB[4];\0A\09b3Float4\09m_worldNormalOnB;\09//\09w: m_nPoints\0A\09unsigned short  m_restituitionCoeffCmp;\0A\09unsigned short  m_frictionCoeffCmp;\0A\09int m_batchIdx;\0A\09int m_bodyAPtrAndSignBit;//x:m_bodyAPtr, y:m_bodyBPtr\0A\09int m_bodyBPtrAndSignBit;\0A\09int\09m_childIndexA;\0A\09int\09m_childIndexB;\0A\09int m_unused1;\0A\09int m_unused2;\0A};\0Ainline int b3Contact4Data_getNumPoints(const struct b3Contact4Data* contact)\0A{\0A\09return (int)contact->m_worldNormalOnB.w;\0A};\0Ainline void b3Contact4Data_setNumPoints(struct b3Contact4Data* contact, int numPoints)\0A{\0A\09contact->m_worldNormalOnB.w = (float)numPoints;\0A};\0A#endif //B3_CONTACT4DATA_H\0A#define SHAPE_CONVEX_HULL 3\0A#define SHAPE_PLANE 4\0A#define SHAPE_CONCAVE_TRIMESH 5\0A#define SHAPE_COMPOUND_OF_CONVEX_HULLS 6\0A#define SHAPE_SPHERE 7\0A#pragma OPENCL EXTENSION cl_amd_printf : enable\0A#pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable\0A#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\0A#pragma OPENCL EXTENSION cl_khr_local_int32_extended_atomics : enable\0A#pragma OPENCL EXTENSION cl_khr_global_int32_extended_atomics : enable\0A#ifdef cl_ext_atomic_counters_32\0A#pragma OPENCL EXTENSION cl_ext_atomic_counters_32 : enable\0A#else\0A#define counter32_t volatile __global int*\0A#endif\0A#define GET_GROUP_IDX get_group_id(0)\0A#define GET_LOCAL_IDX get_local_id(0)\0A#define GET_GLOBAL_IDX get_global_id(0)\0A#define GET_GROUP_SIZE get_local_size(0)\0A#define GET_NUM_GROUPS get_num_groups(0)\0A#define GROUP_LDS_BARRIER barrier(CLK_LOCAL_MEM_FENCE)\0A#define GROUP_MEM_FENCE mem_fence(CLK_LOCAL_MEM_FENCE)\0A#define AtomInc(x) atom_inc(&(x))\0A#define AtomInc1(x, out) out = atom_inc(&(x))\0A#define AppendInc(x, out) out = atomic_inc(x)\0A#define AtomAdd(x, value) atom_add(&(x), value)\0A#define AtomCmpxhg(x, cmp, value) atom_cmpxchg( &(x), cmp, value )\0A#define AtomXhg(x, value) atom_xchg ( &(x), value )\0A#define max2 max\0A#define min2 min\0Atypedef unsigned int u32;\0Atypedef struct \0A{\0A\09union\0A\09{\0A\09\09float4\09m_min;\0A\09\09float   m_minElems[4];\0A\09\09int\09\09\09m_minIndices[4];\0A\09};\0A\09union\0A\09{\0A\09\09float4\09m_max;\0A\09\09float   m_maxElems[4];\0A\09\09int\09\09\09m_maxIndices[4];\0A\09};\0A} btAabbCL;\0A///keep this in sync with btCollidable.h\0Atypedef struct\0A{\0A\09int m_numChildShapes;\0A\09float m_radius;\0A\09int m_shapeType;\0A\09int m_shapeIndex;\0A\09\0A} btCollidableGpu;\0Atypedef struct\0A{\0A\09float4\09m_childPosition;\0A\09float4\09m_childOrientation;\0A\09int m_shapeIndex;\0A\09int m_unused0;\0A\09int m_unused1;\0A\09int m_unused2;\0A} btGpuChildShape;\0A#define GET_NPOINTS(x) (x).m_worldNormalOnB.w\0Atypedef struct\0A{\0A\09float4 m_pos;\0A\09float4 m_quat;\0A\09float4 m_linVel;\0A\09float4 m_angVel;\0A\09u32 m_collidableIdx;\09\0A\09float m_invMass;\0A\09float m_restituitionCoeff;\0A\09float m_frictionCoeff;\0A} BodyData;\0Atypedef struct  \0A{\0A\09float4\09\09m_localCenter;\0A\09float4\09\09m_extents;\0A\09float4\09\09mC;\0A\09float4\09\09mE;\0A\09\0A\09float\09\09\09m_radius;\0A\09int\09m_faceOffset;\0A\09int m_numFaces;\0A\09int\09m_numVertices;\0A\09\0A\09int m_vertexOffset;\0A\09int\09m_uniqueEdgesOffset;\0A\09int\09m_numUniqueEdges;\0A\09int m_unused;\0A} ConvexPolyhedronCL;\0Atypedef struct\0A{\0A\09float4 m_plane;\0A\09int m_indexOffset;\0A\09int m_numIndices;\0A} btGpuFace;\0A#define SELECT_UINT4( b, a, condition ) select( b,a,condition )\0A#define make_float4 (float4)\0A#define make_float2 (float2)\0A#define make_uint4 (uint4)\0A#define make_int4 (int4)\0A#define make_uint2 (uint2)\0A#define make_int2 (int2)\0A__inline\0Afloat fastDiv(float numerator, float denominator)\0A{\0A\09return native_divide(numerator, denominator);\09\0A//\09return numerator/denominator;\09\0A}\0A__inline\0Afloat4 fastDiv4(float4 numerator, float4 denominator)\0A{\0A\09return native_divide(numerator, denominator);\09\0A}\0A__inline\0Afloat4 cross3(float4 a, float4 b)\0A{\0A\09return cross(a,b);\0A}\0A//#define dot3F4 dot\0A__inline\0Afloat dot3F4(float4 a, float4 b)\0A{\0A\09float4 a1 = make_float4(a.xyz,0.f);\0A\09float4 b1 = make_float4(b.xyz,0.f);\0A\09return dot(a1, b1);\0A}\0A__inline\0Afloat4 fastNormalize4(float4 v)\0A{\0A\09return fast_normalize(v);\0A}\0A///////////////////////////////////////\0A//\09Quaternion\0A///////////////////////////////////////\0Atypedef float4 Quaternion;\0A__inline\0AQuaternion qtMul(Quaternion a, Quaternion b);\0A__inline\0AQuaternion qtNormalize(Quaternion in);\0A__inline\0Afloat4 qtRotate(Quaternion q, float4 vec);\0A__inline\0AQuaternion qtInvert(Quaternion q);\0A__inline\0AQuaternion qtMul(Quaternion a, Quaternion b)\0A{\0A\09Quaternion ans;\0A\09ans = cross3( a, b );\0A\09ans += a.w*b+b.w*a;\0A//\09ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);\0A\09ans.w = a.w*b.w - dot3F4(a, b);\0A\09return ans;\0A}\0A__inline\0AQuaternion qtNormalize(Quaternion in)\0A{\0A\09return fastNormalize4(in);\0A//\09in /= length( in );\0A//\09return in;\0A}\0A__inline\0Afloat4 qtRotate(Quaternion q, float4 vec)\0A{\0A\09Quaternion qInv = qtInvert( q );\0A\09float4 vcpy = vec;\0A\09vcpy.w = 0.f;\0A\09float4 out = qtMul(qtMul(q,vcpy),qInv);\0A\09return out;\0A}\0A__inline\0AQuaternion qtInvert(Quaternion q)\0A{\0A\09return (Quaternion)(-q.xyz, q.w);\0A}\0A__inline\0Afloat4 qtInvRotate(const Quaternion q, float4 vec)\0A{\0A\09return qtRotate( qtInvert( q ), vec );\0A}\0A__inline\0Afloat4 transform(const float4* p, const float4* translation, const Quaternion* orientation)\0A{\0A\09return qtRotate( *orientation, *p ) + (*translation);\0A}\0Avoid\09trInverse(float4 translationIn, Quaternion orientationIn,\0A\09\09float4* translationOut, Quaternion* orientationOut)\0A{\0A\09*orientationOut = qtInvert(orientationIn);\0A\09*translationOut = qtRotate(*orientationOut, -translationIn);\0A}\0Avoid\09trMul(float4 translationA, Quaternion orientationA,\0A\09\09\09\09\09\09float4 translationB, Quaternion orientationB,\0A\09\09float4* translationOut, Quaternion* orientationOut)\0A{\0A\09*orientationOut = qtMul(orientationA,orientationB);\0A\09*translationOut = transform(&translationB,&translationA,&orientationA);\0A}\0A__inline\0Afloat4 normalize3(const float4 a)\0A{\0A\09float4 n = make_float4(a.x, a.y, a.z, 0.f);\0A\09return fastNormalize4( n );\0A}\0A__inline float4 lerp3(const float4 a,const float4 b, float  t)\0A{\0A\09return make_float4(\09a.x + (b.x - a.x) * t,\0A\09\09\09\09\09\09a.y + (b.y - a.y) * t,\0A\09\09\09\09\09\09a.z + (b.z - a.z) * t,\0A\09\09\09\09\09\090.f);\0A}\0Afloat signedDistanceFromPointToPlane(float4 point, float4 planeEqn, float4* closestPointOnFace)\0A{\0A\09float4 n = (float4)(planeEqn.x, planeEqn.y, planeEqn.z, 0);\0A\09float dist = dot3F4(n, point) + planeEqn.w;\0A\09*closestPointOnFace = point - dist * n;\0A\09return dist;\0A}\0Ainline bool IsPointInPolygon(float4 p, \0A\09\09\09\09\09\09\09const btGpuFace* face,\0A\09\09\09\09\09\09\09__global const float4* baseVertex,\0A\09\09\09\09\09\09\09__global const  int* convexIndices,\0A\09\09\09\09\09\09\09float4* out)\0A{\0A    float4 a;\0A    float4 b;\0A    float4 ab;\0A    float4 ap;\0A    float4 v;\0A\09float4 plane = make_float4(face->m_plane.x,face->m_plane.y,face->m_plane.z,0.f);\0A\09\0A\09if (face->m_numIndices<2)\0A\09\09return false;\0A\09\0A\09float4 v0 = baseVertex[convexIndices[face->m_indexOffset + face->m_numIndices-1]];\0A\09\0A\09b = v0;\0A    for(unsigned i=0; i != face->m_numIndices; ++i)\0A    {\0A\09\09a = b;\0A\09\09float4 vi = baseVertex[convexIndices[face->m_indexOffset + i]];\0A\09\09b = vi;\0A        ab = b-a;\0A        ap = p-a;\0A        v = cross3(ab,plane);\0A        if (dot(ap, v) > 0.f)\0A        {\0A            float ab_m2 = dot(ab, ab);\0A            float rt = ab_m2 != 0.f ? dot(ab, ap) / ab_m2 : 0.f;\0A            if (rt <= 0.f)\0A            {\0A                *out = a;\0A            }\0A            else if (rt >= 1.f) \0A            {\0A                *out = b;\0A            }\0A            else\0A            {\0A            \09float s = 1.f - rt;\0A\09\09\09\09out[0].x = s * a.x + rt * b.x;\0A\09\09\09\09out[0].y = s * a.y + rt * b.y;\0A\09\09\09\09out[0].z = s * a.z + rt * b.z;\0A            }\0A            return false;\0A        }\0A    }\0A    return true;\0A}\0Avoid\09computeContactSphereConvex(int pairIndex,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int bodyIndexA, int bodyIndexB, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int collidableIndexA, int collidableIndexB, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const BodyData* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btCollidableGpu* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const ConvexPolyhedronCL* convexShapes,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* convexVertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* convexIndices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btGpuFace* faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global struct b3Contact4Data* restrict globalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09counter32_t nGlobalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int maxContactCapacity,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09float4 spherePos2,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09float radius,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09float4 pos,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09float4 quat\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09)\0A{\0A\09float4 invPos;\0A\09float4 invOrn;\0A\09trInverse(pos,quat, &invPos,&invOrn);\0A\09float4 spherePos = transform(&spherePos2,&invPos,&invOrn);\0A\09int shapeIndex = collidables[collidableIndexB].m_shapeIndex;\0A\09int numFaces = convexShapes[shapeIndex].m_numFaces;\0A\09float4 closestPnt = (float4)(0, 0, 0, 0);\0A\09float4 hitNormalWorld = (float4)(0, 0, 0, 0);\0A\09float minDist = -1000000.f;\0A\09bool bCollide = true;\0A\09for ( int f = 0; f < numFaces; f++ )\0A\09{\0A\09\09btGpuFace face = faces[convexShapes[shapeIndex].m_faceOffset+f];\0A\09\09// set up a plane equation \0A\09\09float4 planeEqn;\0A\09\09float4 n1 = face.m_plane;\0A\09\09n1.w = 0.f;\0A\09\09planeEqn = n1;\0A\09\09planeEqn.w = face.m_plane.w;\0A\09\09\0A\09\0A\09\09// compute a signed distance from the vertex in cloth to the face of rigidbody.\0A\09\09float4 pntReturn;\0A\09\09float dist = signedDistanceFromPointToPlane(spherePos, planeEqn, &pntReturn);\0A\09\09// If the distance is positive, the plane is a separating plane. \0A\09\09if ( dist > radius )\0A\09\09{\0A\09\09\09bCollide = false;\0A\09\09\09break;\0A\09\09}\0A\09\09if (dist>0)\0A\09\09{\0A\09\09\09//might hit an edge or vertex\0A\09\09\09float4 out;\0A\09\09\09float4 zeroPos = make_float4(0,0,0,0);\0A\09\09\09bool isInPoly = IsPointInPolygon(spherePos,\0A\09\09\09\09\09&face,\0A\09\09\09\09\09&convexVertices[convexShapes[shapeIndex].m_vertexOffset],\0A\09\09\09\09\09convexIndices,\0A           &out);\0A\09\09\09if (isInPoly)\0A\09\09\09{\0A\09\09\09\09if (dist>minDist)\0A\09\09\09\09{\0A\09\09\09\09\09minDist = dist;\0A\09\09\09\09\09closestPnt = pntReturn;\0A\09\09\09\09\09hitNormalWorld = planeEqn;\0A\09\09\09\09\09\0A\09\09\09\09}\0A\09\09\09} else\0A\09\09\09{\0A\09\09\09\09float4 tmp = spherePos-out;\0A\09\09\09\09float l2 = dot(tmp,tmp);\0A\09\09\09\09if (l2<radius*radius)\0A\09\09\09\09{\0A\09\09\09\09\09dist  = sqrt(l2);\0A\09\09\09\09\09if (dist>minDist)\0A\09\09\09\09\09{\0A\09\09\09\09\09\09minDist = dist;\0A\09\09\09\09\09\09closestPnt = out;\0A\09\09\09\09\09\09hitNormalWorld = tmp/dist;\0A\09\09\09\09\09\09\0A\09\09\09\09\09}\0A\09\09\09\09\09\0A\09\09\09\09} else\0A\09\09\09\09{\0A\09\09\09\09\09bCollide = false;\0A\09\09\09\09\09break;\0A\09\09\09\09}\0A\09\09\09}\0A\09\09} else\0A\09\09{\0A\09\09\09if ( dist > minDist )\0A\09\09\09{\0A\09\09\09\09minDist = dist;\0A\09\09\09\09closestPnt = pntReturn;\0A\09\09\09\09hitNormalWorld.xyz = planeEqn.xyz;\0A\09\09\09}\0A\09\09}\0A\09\09\0A\09}\0A\09\0A\09if (bCollide && minDist > -10000)\0A\09{\0A\09\09float4 normalOnSurfaceB1 = qtRotate(quat,-hitNormalWorld);\0A\09\09float4 pOnB1 = transform(&closestPnt,&pos,&quat);\0A\09\09\0A\09\09float actualDepth = minDist-radius;\0A\09\09if (actualDepth<=0.f)\0A\09\09{\0A\09\09\09\0A\09\09\09pOnB1.w = actualDepth;\0A\09\09\09int dstIdx;\0A\09\09\09AppendInc( nGlobalContactsOut, dstIdx );\0A\09\09\0A\09\09\09\0A\09\09\09if (1)//dstIdx < maxContactCapacity)\0A\09\09\09{\0A\09\09\09\09__global struct b3Contact4Data* c = &globalContactsOut[dstIdx];\0A\09\09\09\09c->m_worldNormalOnB = -normalOnSurfaceB1;\0A\09\09\09\09c->m_restituitionCoeffCmp = (0.f*0xffff);c->m_frictionCoeffCmp = (0.7f*0xffff);\0A\09\09\09\09c->m_batchIdx = pairIndex;\0A\09\09\09\09c->m_bodyAPtrAndSignBit = rigidBodies[bodyIndexA].m_invMass==0?-bodyIndexA:bodyIndexA;\0A\09\09\09\09c->m_bodyBPtrAndSignBit = rigidBodies[bodyIndexB].m_invMass==0?-bodyIndexB:bodyIndexB;\0A\09\09\09\09c->m_worldPosB[0] = pOnB1;\0A\09\09\09\09c->m_childIndexA = -1;\0A\09\09\09\09c->m_childIndexB = -1;\0A\09\09\09\09GET_NPOINTS(*c) = 1;\0A\09\09\09} \0A\09\09}\0A\09}//if (hasCollision)\0A}\0A\09\09\09\09\09\09\09\0Aint extractManifoldSequential(const float4* p, int nPoints, float4 nearNormal, int4* contactIdx)\0A{\0A\09if( nPoints == 0 )\0A        return 0;\0A    \0A    if (nPoints <=4)\0A        return nPoints;\0A    \0A    \0A    if (nPoints >64)\0A        nPoints = 64;\0A    \0A\09float4 center = make_float4(0.f);\0A\09{\0A\09\09\0A\09\09for (int i=0;i<nPoints;i++)\0A\09\09\09center += p[i];\0A\09\09center /= (float)nPoints;\0A\09}\0A    \0A\09\0A    \0A\09//\09sample 4 directions\0A    \0A    float4 aVector = p[0] - center;\0A    float4 u = cross3( nearNormal, aVector );\0A    float4 v = cross3( nearNormal, u );\0A    u = normalize3( u );\0A    v = normalize3( v );\0A    \0A    \0A    //keep point with deepest penetration\0A    float minW= FLT_MAX;\0A    \0A    int minIndex=-1;\0A    \0A    float4 maxDots;\0A    maxDots.x = FLT_MIN;\0A    maxDots.y = FLT_MIN;\0A    maxDots.z = FLT_MIN;\0A    maxDots.w = FLT_MIN;\0A    \0A    //\09idx, distance\0A    for(int ie = 0; ie<nPoints; ie++ )\0A    {\0A        if (p[ie].w<minW)\0A        {\0A            minW = p[ie].w;\0A            minIndex=ie;\0A        }\0A        float f;\0A        float4 r = p[ie]-center;\0A        f = dot3F4( u, r );\0A        if (f<maxDots.x)\0A        {\0A            maxDots.x = f;\0A            contactIdx[0].x = ie;\0A        }\0A        \0A        f = dot3F4( -u, r );\0A        if (f<maxDots.y)\0A        {\0A            maxDots.y = f;\0A            contactIdx[0].y = ie;\0A        }\0A        \0A        \0A        f = dot3F4( v, r );\0A        if (f<maxDots.z)\0A        {\0A            maxDots.z = f;\0A            contactIdx[0].z = ie;\0A        }\0A        \0A        f = dot3F4( -v, r );\0A        if (f<maxDots.w)\0A        {\0A            maxDots.w = f;\0A            contactIdx[0].w = ie;\0A        }\0A        \0A    }\0A    \0A    if (contactIdx[0].x != minIndex && contactIdx[0].y != minIndex && contactIdx[0].z != minIndex && contactIdx[0].w != minIndex)\0A    {\0A        //replace the first contact with minimum (todo: replace contact with least penetration)\0A        contactIdx[0].x = minIndex;\0A    }\0A    \0A    return 4;\0A    \0A}\0A#define MAX_PLANE_CONVEX_POINTS 64\0Aint computeContactPlaneConvex(int pairIndex,\0A\09\09\09\09\09\09\09\09int bodyIndexA, int bodyIndexB, \0A\09\09\09\09\09\09\09\09int collidableIndexA, int collidableIndexB, \0A\09\09\09\09\09\09\09\09__global const BodyData* rigidBodies, \0A\09\09\09\09\09\09\09\09__global const btCollidableGpu*collidables,\0A\09\09\09\09\09\09\09\09__global const ConvexPolyhedronCL* convexShapes,\0A\09\09\09\09\09\09\09\09__global const float4* convexVertices,\0A\09\09\09\09\09\09\09\09__global const int* convexIndices,\0A\09\09\09\09\09\09\09\09__global const btGpuFace* faces,\0A\09\09\09\09\09\09\09\09__global struct b3Contact4Data* restrict globalContactsOut,\0A\09\09\09\09\09\09\09\09counter32_t nGlobalContactsOut,\0A\09\09\09\09\09\09\09\09int maxContactCapacity,\0A\09\09\09\09\09\09\09\09float4 posB,\0A\09\09\09\09\09\09\09\09Quaternion ornB\0A\09\09\09\09\09\09\09\09)\0A{\0A\09int resultIndex=-1;\0A\09\09int shapeIndex = collidables[collidableIndexB].m_shapeIndex;\0A\09__global const ConvexPolyhedronCL* hullB = &convexShapes[shapeIndex];\0A\09\0A\09float4 posA;\0A\09posA = rigidBodies[bodyIndexA].m_pos;\0A\09Quaternion ornA;\0A\09ornA = rigidBodies[bodyIndexA].m_quat;\0A\09int numContactsOut = 0;\0A\09int numWorldVertsB1= 0;\0A\09float4 planeEq;\0A\09 planeEq = faces[collidables[collidableIndexA].m_shapeIndex].m_plane;\0A\09float4 planeNormal = make_float4(planeEq.x,planeEq.y,planeEq.z,0.f);\0A\09float4 planeNormalWorld;\0A\09planeNormalWorld = qtRotate(ornA,planeNormal);\0A\09float planeConstant = planeEq.w;\0A\09\0A\09float4 invPosA;Quaternion invOrnA;\0A\09float4 convexInPlaneTransPos1; Quaternion convexInPlaneTransOrn1;\0A\09{\0A\09\09\0A\09\09trInverse(posA,ornA,&invPosA,&invOrnA);\0A\09\09trMul(invPosA,invOrnA,posB,ornB,&convexInPlaneTransPos1,&convexInPlaneTransOrn1);\0A\09}\0A\09float4 invPosB;Quaternion invOrnB;\0A\09float4 planeInConvexPos1;\09Quaternion planeInConvexOrn1;\0A\09{\0A\09\09\0A\09\09trInverse(posB,ornB,&invPosB,&invOrnB);\0A\09\09trMul(invPosB,invOrnB,posA,ornA,&planeInConvexPos1,&planeInConvexOrn1);\09\0A\09}\0A\09\0A\09float4 planeNormalInConvex = qtRotate(planeInConvexOrn1,-planeNormal);\0A\09float maxDot = -1e30;\0A\09int hitVertex=-1;\0A\09float4 hitVtx;\0A\09float4 contactPoints[MAX_PLANE_CONVEX_POINTS];\0A\09int numPoints = 0;\0A\09int4 contactIdx;\0A\09contactIdx=make_int4(0,1,2,3);\0A    \0A\09\0A\09for (int i=0;i<hullB->m_numVertices;i++)\0A\09{\0A\09\09float4 vtx = convexVertices[hullB->m_vertexOffset+i];\0A\09\09float curDot = dot(vtx,planeNormalInConvex);\0A\09\09if (curDot>maxDot)\0A\09\09{\0A\09\09\09hitVertex=i;\0A\09\09\09maxDot=curDot;\0A\09\09\09hitVtx = vtx;\0A\09\09\09//make sure the deepest points is always included\0A\09\09\09if (numPoints==MAX_PLANE_CONVEX_POINTS)\0A\09\09\09\09numPoints--;\0A\09\09}\0A\09\09if (numPoints<MAX_PLANE_CONVEX_POINTS)\0A\09\09{\0A\09\09\09float4 vtxWorld = transform(&vtx, &posB, &ornB);\0A\09\09\09float4 vtxInPlane = transform(&vtxWorld, &invPosA, &invOrnA);//oplaneTransform.inverse()*vtxWorld;\0A\09\09\09float dist = dot(planeNormal,vtxInPlane)-planeConstant;\0A\09\09\09if (dist<0.f)\0A\09\09\09{\0A\09\09\09\09vtxWorld.w = dist;\0A\09\09\09\09contactPoints[numPoints] = vtxWorld;\0A\09\09\09\09numPoints++;\0A\09\09\09}\0A\09\09}\0A\09}\0A\09int numReducedPoints  = numPoints;\0A\09if (numPoints>4)\0A\09{\0A\09\09numReducedPoints = extractManifoldSequential( contactPoints, numPoints, planeNormalInConvex, &contactIdx);\0A\09}\0A\09if (numReducedPoints>0)\0A\09{\0A\09\09int dstIdx;\0A\09    AppendInc( nGlobalContactsOut, dstIdx );\0A\09\09if (dstIdx < maxContactCapacity)\0A\09\09{\0A\09\09\09resultIndex = dstIdx;\0A\09\09\09__global struct b3Contact4Data* c = &globalContactsOut[dstIdx];\0A\09\09\09c->m_worldNormalOnB = -planeNormalWorld;\0A\09\09\09//c->setFrictionCoeff(0.7);\0A\09\09\09//c->setRestituitionCoeff(0.f);\0A\09\09\09c->m_restituitionCoeffCmp = (0.f*0xffff);c->m_frictionCoeffCmp = (0.7f*0xffff);\0A\09\09\09c->m_batchIdx = pairIndex;\0A\09\09\09c->m_bodyAPtrAndSignBit = rigidBodies[bodyIndexA].m_invMass==0?-bodyIndexA:bodyIndexA;\0A\09\09\09c->m_bodyBPtrAndSignBit = rigidBodies[bodyIndexB].m_invMass==0?-bodyIndexB:bodyIndexB;\0A\09\09\09c->m_childIndexA = -1;\0A\09\09\09c->m_childIndexB = -1;\0A\09\09\09switch (numReducedPoints)\0A            {\0A                case 4:\0A                    c->m_worldPosB[3] = contactPoints[contactIdx.w];\0A                case 3:\0A                    c->m_worldPosB[2] = contactPoints[contactIdx.z];\0A                case 2:\0A                    c->m_worldPosB[1] = contactPoints[contactIdx.y];\0A                case 1:\0A                    c->m_worldPosB[0] = contactPoints[contactIdx.x];\0A                default:\0A                {\0A                }\0A            };\0A\09\09\09\0A\09\09\09GET_NPOINTS(*c) = numReducedPoints;\0A\09\09}//if (dstIdx < numPairs)\0A\09}\09\0A\09return resultIndex;\0A}\0Avoid\09computeContactPlaneSphere(int pairIndex,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int bodyIndexA, int bodyIndexB, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int collidableIndexA, int collidableIndexB, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const BodyData* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btCollidableGpu* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btGpuFace* faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global struct b3Contact4Data* restrict globalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09counter32_t nGlobalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int maxContactCapacity)\0A{\0A\09float4 planeEq = faces[collidables[collidableIndexA].m_shapeIndex].m_plane;\0A\09float radius = collidables[collidableIndexB].m_radius;\0A\09float4 posA1 = rigidBodies[bodyIndexA].m_pos;\0A\09float4 ornA1 = rigidBodies[bodyIndexA].m_quat;\0A\09float4 posB1 = rigidBodies[bodyIndexB].m_pos;\0A\09float4 ornB1 = rigidBodies[bodyIndexB].m_quat;\0A\09\0A\09bool hasCollision = false;\0A\09float4 planeNormal1 = make_float4(planeEq.x,planeEq.y,planeEq.z,0.f);\0A\09float planeConstant = planeEq.w;\0A\09float4 convexInPlaneTransPos1; Quaternion convexInPlaneTransOrn1;\0A\09{\0A\09\09float4 invPosA;Quaternion invOrnA;\0A\09\09trInverse(posA1,ornA1,&invPosA,&invOrnA);\0A\09\09trMul(invPosA,invOrnA,posB1,ornB1,&convexInPlaneTransPos1,&convexInPlaneTransOrn1);\0A\09}\0A\09float4 planeInConvexPos1;\09Quaternion planeInConvexOrn1;\0A\09{\0A\09\09float4 invPosB;Quaternion invOrnB;\0A\09\09trInverse(posB1,ornB1,&invPosB,&invOrnB);\0A\09\09trMul(invPosB,invOrnB,posA1,ornA1,&planeInConvexPos1,&planeInConvexOrn1);\09\0A\09}\0A\09float4 vtx1 = qtRotate(planeInConvexOrn1,-planeNormal1)*radius;\0A\09float4 vtxInPlane1 = transform(&vtx1,&convexInPlaneTransPos1,&convexInPlaneTransOrn1);\0A\09float distance = dot3F4(planeNormal1,vtxInPlane1) - planeConstant;\0A\09hasCollision = distance < 0.f;//m_manifoldPtr->getContactBreakingThreshold();\0A\09if (hasCollision)\0A\09{\0A\09\09float4 vtxInPlaneProjected1 = vtxInPlane1 -   distance*planeNormal1;\0A\09\09float4 vtxInPlaneWorld1 = transform(&vtxInPlaneProjected1,&posA1,&ornA1);\0A\09\09float4 normalOnSurfaceB1 = qtRotate(ornA1,planeNormal1);\0A\09\09float4 pOnB1 = vtxInPlaneWorld1+normalOnSurfaceB1*distance;\0A\09\09pOnB1.w = distance;\0A\09\09int dstIdx;\0A    AppendInc( nGlobalContactsOut, dstIdx );\0A\09\09\0A\09\09if (dstIdx < maxContactCapacity)\0A\09\09{\0A\09\09\09__global struct b3Contact4Data* c = &globalContactsOut[dstIdx];\0A\09\09\09c->m_worldNormalOnB = -normalOnSurfaceB1;\0A\09\09\09c->m_restituitionCoeffCmp = (0.f*0xffff);c->m_frictionCoeffCmp = (0.7f*0xffff);\0A\09\09\09c->m_batchIdx = pairIndex;\0A\09\09\09c->m_bodyAPtrAndSignBit = rigidBodies[bodyIndexA].m_invMass==0?-bodyIndexA:bodyIndexA;\0A\09\09\09c->m_bodyBPtrAndSignBit = rigidBodies[bodyIndexB].m_invMass==0?-bodyIndexB:bodyIndexB;\0A\09\09\09c->m_worldPosB[0] = pOnB1;\0A\09\09\09c->m_childIndexA = -1;\0A\09\09\09c->m_childIndexB = -1;\0A\09\09\09GET_NPOINTS(*c) = 1;\0A\09\09}//if (dstIdx < numPairs)\0A\09}//if (hasCollision)\0A}\0A__kernel void   primitiveContactsKernel( __global int4* pairs, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const BodyData* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btCollidableGpu* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const ConvexPolyhedronCL* convexShapes, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* vertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* uniqueEdges,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btGpuFace* faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global struct b3Contact4Data* restrict globalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09counter32_t nGlobalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numPairs, int maxContactCapacity)\0A{\0A\09int i = get_global_id(0);\0A\09int pairIndex = i;\0A\09\0A\09float4 worldVertsB1[64];\0A\09float4 worldVertsB2[64];\0A\09int capacityWorldVerts = 64;\09\0A\09float4 localContactsOut[64];\0A\09int localContactCapacity=64;\0A\09\0A\09float minDist = -1e30f;\0A\09float maxDist = 0.02f;\0A\09if (i<numPairs)\0A\09{\0A\09\09int bodyIndexA = pairs[i].x;\0A\09\09int bodyIndexB = pairs[i].y;\0A\09\09\09\0A\09\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09\0A\09\09if (collidables[collidableIndexA].m_shapeType == SHAPE_PLANE &&\0A\09\09\09collidables[collidableIndexB].m_shapeType == SHAPE_CONVEX_HULL)\0A\09\09{\0A\09\09\09float4 posB;\0A\09\09\09posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09Quaternion ornB;\0A\09\09\09ornB = rigidBodies[bodyIndexB].m_quat;\0A\09\09\09int contactIndex = computeContactPlaneConvex(pairIndex, bodyIndexA, bodyIndexB, collidableIndexA, collidableIndexB, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09rigidBodies,collidables,convexShapes,vertices,indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09faces,\09globalContactsOut, nGlobalContactsOut,maxContactCapacity, posB,ornB);\0A\09\09\09if (contactIndex>=0)\0A\09\09\09\09pairs[pairIndex].z = contactIndex;\0A\09\09\09return;\0A\09\09}\0A\09\09if (collidables[collidableIndexA].m_shapeType == SHAPE_CONVEX_HULL &&\0A\09\09\09collidables[collidableIndexB].m_shapeType == SHAPE_PLANE)\0A\09\09{\0A\09\09\09float4 posA;\0A\09\09\09posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09\09Quaternion ornA;\0A\09\09\09ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09\09int contactIndex = computeContactPlaneConvex( pairIndex, bodyIndexB,bodyIndexA,  collidableIndexB,collidableIndexA, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09rigidBodies,collidables,convexShapes,vertices,indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09faces,\09globalContactsOut, nGlobalContactsOut,maxContactCapacity,posA,ornA);\0A\09\09\09if (contactIndex>=0)\0A\09\09\09\09pairs[pairIndex].z = contactIndex;\0A\09\09\09return;\0A\09\09}\0A\09\09if (collidables[collidableIndexA].m_shapeType == SHAPE_PLANE &&\0A\09\09\09collidables[collidableIndexB].m_shapeType == SHAPE_SPHERE)\0A\09\09{\0A\09\09\09computeContactPlaneSphere(pairIndex, bodyIndexA, bodyIndexB, collidableIndexA, collidableIndexB, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09rigidBodies,collidables,faces,\09globalContactsOut, nGlobalContactsOut,maxContactCapacity);\0A\09\09\09return;\0A\09\09}\0A\09\09if (collidables[collidableIndexA].m_shapeType == SHAPE_SPHERE &&\0A\09\09\09collidables[collidableIndexB].m_shapeType == SHAPE_PLANE)\0A\09\09{\0A\09\09\09computeContactPlaneSphere( pairIndex, bodyIndexB,bodyIndexA,  collidableIndexB,collidableIndexA, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09rigidBodies,collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09faces,\09globalContactsOut, nGlobalContactsOut,maxContactCapacity);\0A\09\09\09return;\0A\09\09}\0A\09\09\0A\09\0A\09\09if (collidables[collidableIndexA].m_shapeType == SHAPE_SPHERE &&\0A\09\09\09collidables[collidableIndexB].m_shapeType == SHAPE_CONVEX_HULL)\0A\09\09{\0A\09\09\0A\09\09\09float4 spherePos = rigidBodies[bodyIndexA].m_pos;\0A\09\09\09float sphereRadius = collidables[collidableIndexA].m_radius;\0A\09\09\09float4 convexPos = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09float4 convexOrn = rigidBodies[bodyIndexB].m_quat;\0A\09\09\09computeContactSphereConvex(pairIndex, bodyIndexA, bodyIndexB, collidableIndexA, collidableIndexB, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09rigidBodies,collidables,convexShapes,vertices,indices,faces, globalContactsOut, nGlobalContactsOut,maxContactCapacity,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09spherePos,sphereRadius,convexPos,convexOrn);\0A\09\09\09return;\0A\09\09}\0A\09\09if (collidables[collidableIndexA].m_shapeType == SHAPE_CONVEX_HULL &&\0A\09\09\09collidables[collidableIndexB].m_shapeType == SHAPE_SPHERE)\0A\09\09{\0A\09\09\0A\09\09\09float4 spherePos = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09float sphereRadius = collidables[collidableIndexB].m_radius;\0A\09\09\09float4 convexPos = rigidBodies[bodyIndexA].m_pos;\0A\09\09\09float4 convexOrn = rigidBodies[bodyIndexA].m_quat;\0A\09\09\09computeContactSphereConvex(pairIndex, bodyIndexB, bodyIndexA, collidableIndexB, collidableIndexA, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09rigidBodies,collidables,convexShapes,vertices,indices,faces, globalContactsOut, nGlobalContactsOut,maxContactCapacity,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09spherePos,sphereRadius,convexPos,convexOrn);\0A\09\09\09return;\0A\09\09}\0A\09\0A\09\0A\09\0A\09\09\0A\09\0A\09\0A\09\09if (collidables[collidableIndexA].m_shapeType == SHAPE_SPHERE &&\0A\09\09\09collidables[collidableIndexB].m_shapeType == SHAPE_SPHERE)\0A\09\09{\0A\09\09\09//sphere-sphere\0A\09\09\09float radiusA = collidables[collidableIndexA].m_radius;\0A\09\09\09float radiusB = collidables[collidableIndexB].m_radius;\0A\09\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09float4 diff = posA-posB;\0A\09\09\09float len = length(diff);\0A\09\09\09\0A\09\09\09///iff distance positive, don't generate a new contact\0A\09\09\09if ( len <= (radiusA+radiusB))\0A\09\09\09{\0A\09\09\09\09///distance (negative means penetration)\0A\09\09\09\09float dist = len - (radiusA+radiusB);\0A\09\09\09\09float4 normalOnSurfaceB = make_float4(1.f,0.f,0.f,0.f);\0A\09\09\09\09if (len > 0.00001)\0A\09\09\09\09{\0A\09\09\09\09\09normalOnSurfaceB = diff / len;\0A\09\09\09\09}\0A\09\09\09\09float4 contactPosB = posB + normalOnSurfaceB*radiusB;\0A\09\09\09\09contactPosB.w = dist;\0A\09\09\09\09\09\09\09\09\0A\09\09\09\09int dstIdx;\0A\09\09\09\09 AppendInc( nGlobalContactsOut, dstIdx );\0A\09\09\09\09\0A\09\09\09\09if (dstIdx < maxContactCapacity)\0A\09\09\09\09{\0A\09\09\09\09\09__global struct b3Contact4Data* c = &globalContactsOut[dstIdx];\0A\09\09\09\09\09c->m_worldNormalOnB = normalOnSurfaceB;\0A\09\09\09\09\09c->m_restituitionCoeffCmp = (0.f*0xffff);c->m_frictionCoeffCmp = (0.7f*0xffff);\0A\09\09\09\09\09c->m_batchIdx = pairIndex;\0A\09\09\09\09\09int bodyA = pairs[pairIndex].x;\0A\09\09\09\09\09int bodyB = pairs[pairIndex].y;\0A\09\09\09\09\09c->m_bodyAPtrAndSignBit = rigidBodies[bodyA].m_invMass==0?-bodyA:bodyA;\0A\09\09\09\09\09c->m_bodyBPtrAndSignBit = rigidBodies[bodyB].m_invMass==0?-bodyB:bodyB;\0A\09\09\09\09\09c->m_worldPosB[0] = contactPosB;\0A\09\09\09\09\09c->m_childIndexA = -1;\0A\09\09\09\09\09c->m_childIndexB = -1;\0A\09\09\09\09\09GET_NPOINTS(*c) = 1;\0A\09\09\09\09}//if (dstIdx < numPairs)\0A\09\09\09}//if ( len <= (radiusA+radiusB))\0A\09\09\09return;\0A\09\09}//SHAPE_SPHERE SHAPE_SPHERE\0A\09}//\09if (i<numPairs)\0A}\0A// work-in-progress\0A__kernel void   processCompoundPairsPrimitivesKernel( __global const int4* gpuCompoundPairs,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global const BodyData* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btCollidableGpu* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global const ConvexPolyhedronCL* convexShapes, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* vertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* uniqueEdges,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btGpuFace* faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global btAabbCL* aabbs,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btGpuChildShape* gpuChildShapes,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global struct b3Contact4Data* restrict globalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09counter32_t nGlobalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09int numCompoundPairs, int maxContactCapacity\0A\09\09\09\09\09\09\09\09\09\09\09\09\09)\0A{\0A\09int i = get_global_id(0);\0A\09if (i<numCompoundPairs)\0A\09{\0A\09\09int bodyIndexA = gpuCompoundPairs[i].x;\0A\09\09int bodyIndexB = gpuCompoundPairs[i].y;\0A\09\09int childShapeIndexA = gpuCompoundPairs[i].z;\0A\09\09int childShapeIndexB = gpuCompoundPairs[i].w;\0A\09\09\0A\09\09int collidableIndexA = -1;\0A\09\09int collidableIndexB = -1;\0A\09\09\0A\09\09float4 ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09\0A\09\09float4 ornB = rigidBodies[bodyIndexB].m_quat;\0A\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09\09\09\09\09\0A\09\09if (childShapeIndexA >= 0)\0A\09\09{\0A\09\09\09collidableIndexA = gpuChildShapes[childShapeIndexA].m_shapeIndex;\0A\09\09\09float4 childPosA = gpuChildShapes[childShapeIndexA].m_childPosition;\0A\09\09\09float4 childOrnA = gpuChildShapes[childShapeIndexA].m_childOrientation;\0A\09\09\09float4 newPosA = qtRotate(ornA,childPosA)+posA;\0A\09\09\09float4 newOrnA = qtMul(ornA,childOrnA);\0A\09\09\09posA = newPosA;\0A\09\09\09ornA = newOrnA;\0A\09\09} else\0A\09\09{\0A\09\09\09collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09}\0A\09\09\0A\09\09if (childShapeIndexB>=0)\0A\09\09{\0A\09\09\09collidableIndexB = gpuChildShapes[childShapeIndexB].m_shapeIndex;\0A\09\09\09float4 childPosB = gpuChildShapes[childShapeIndexB].m_childPosition;\0A\09\09\09float4 childOrnB = gpuChildShapes[childShapeIndexB].m_childOrientation;\0A\09\09\09float4 newPosB = transform(&childPosB,&posB,&ornB);\0A\09\09\09float4 newOrnB = qtMul(ornB,childOrnB);\0A\09\09\09posB = newPosB;\0A\09\09\09ornB = newOrnB;\0A\09\09} else\0A\09\09{\0A\09\09\09collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\09\0A\09\09}\0A\09\0A\09\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09\0A\09\09int shapeTypeA = collidables[collidableIndexA].m_shapeType;\0A\09\09int shapeTypeB = collidables[collidableIndexB].m_shapeType;\0A\09\09int pairIndex = i;\0A\09\09if ((shapeTypeA == SHAPE_PLANE) && (shapeTypeB==SHAPE_CONVEX_HULL))\0A\09\09{\0A\09\09\09computeContactPlaneConvex( pairIndex, bodyIndexA,bodyIndexB,  collidableIndexA,collidableIndexB, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09rigidBodies,collidables,convexShapes,vertices,indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09faces,\09globalContactsOut, nGlobalContactsOut,maxContactCapacity,posB,ornB);\0A\09\09\09return;\0A\09\09}\0A\09\09if ((shapeTypeA == SHAPE_CONVEX_HULL) && (shapeTypeB==SHAPE_PLANE))\0A\09\09{\0A\09\09\09computeContactPlaneConvex( pairIndex, bodyIndexB,bodyIndexA,  collidableIndexB,collidableIndexA, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09rigidBodies,collidables,convexShapes,vertices,indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09faces,\09globalContactsOut, nGlobalContactsOut,maxContactCapacity,posA,ornA);\0A\09\09\09return;\0A\09\09}\0A\09\09if ((shapeTypeA == SHAPE_CONVEX_HULL) && (shapeTypeB == SHAPE_SPHERE))\0A\09\09{\0A\09\09\09float4 spherePos = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09float sphereRadius = collidables[collidableIndexB].m_radius;\0A\09\09\09float4 convexPos = posA;\0A\09\09\09float4 convexOrn = ornA;\0A\09\09\09\0A\09\09\09computeContactSphereConvex(pairIndex, bodyIndexB, bodyIndexA , collidableIndexB,collidableIndexA, \0A\09\09\09\09\09\09\09\09\09\09rigidBodies,collidables,convexShapes,vertices,indices,faces, globalContactsOut, nGlobalContactsOut,maxContactCapacity,\0A\09\09\09\09\09\09\09\09\09\09spherePos,sphereRadius,convexPos,convexOrn);\0A\09\0A\09\09\09return;\0A\09\09}\0A\09\09if ((shapeTypeA == SHAPE_SPHERE) && (shapeTypeB == SHAPE_CONVEX_HULL))\0A\09\09{\0A\09\09\09float4 spherePos = rigidBodies[bodyIndexA].m_pos;\0A\09\09\09float sphereRadius = collidables[collidableIndexA].m_radius;\0A\09\09\09float4 convexPos = posB;\0A\09\09\09float4 convexOrn = ornB;\0A\09\09\09\0A\09\09\09computeContactSphereConvex(pairIndex, bodyIndexA, bodyIndexB, collidableIndexA, collidableIndexB, \0A\09\09\09\09\09\09\09\09\09\09rigidBodies,collidables,convexShapes,vertices,indices,faces, globalContactsOut, nGlobalContactsOut,maxContactCapacity,\0A\09\09\09\09\09\09\09\09\09\09spherePos,sphereRadius,convexPos,convexOrn);\0A\09\0A\09\09\09return;\0A\09\09}\0A\09}//\09if (i<numCompoundPairs)\0A}\0Abool pointInTriangle(const float4* vertices, const float4* normal, float4 *p )\0A{\0A\09const float4* p1 = &vertices[0];\0A\09const float4* p2 = &vertices[1];\0A\09const float4* p3 = &vertices[2];\0A\09float4 edge1;\09edge1 = (*p2 - *p1);\0A\09float4 edge2;\09edge2 = ( *p3 - *p2 );\0A\09float4 edge3;\09edge3 = ( *p1 - *p3 );\0A\09\0A\09float4 p1_to_p; p1_to_p = ( *p - *p1 );\0A\09float4 p2_to_p; p2_to_p = ( *p - *p2 );\0A\09float4 p3_to_p; p3_to_p = ( *p - *p3 );\0A\09float4 edge1_normal; edge1_normal = ( cross(edge1,*normal));\0A\09float4 edge2_normal; edge2_normal = ( cross(edge2,*normal));\0A\09float4 edge3_normal; edge3_normal = ( cross(edge3,*normal));\0A\09\0A\09\0A\09float r1, r2, r3;\0A\09r1 = dot(edge1_normal,p1_to_p );\0A\09r2 = dot(edge2_normal,p2_to_p );\0A\09r3 = dot(edge3_normal,p3_to_p );\0A\09\0A\09if ( r1 > 0 && r2 > 0 && r3 > 0 )\0A\09\09return true;\0A    if ( r1 <= 0 && r2 <= 0 && r3 <= 0 ) \0A\09\09return true;\0A\09return false;\0A}\0Afloat segmentSqrDistance(float4 from, float4 to,float4 p, float4* nearest) \0A{\0A\09float4 diff = p - from;\0A\09float4 v = to - from;\0A\09float t = dot(v,diff);\0A\09\0A\09if (t > 0) \0A\09{\0A\09\09float dotVV = dot(v,v);\0A\09\09if (t < dotVV) \0A\09\09{\0A\09\09\09t /= dotVV;\0A\09\09\09diff -= t*v;\0A\09\09} else \0A\09\09{\0A\09\09\09t = 1;\0A\09\09\09diff -= v;\0A\09\09}\0A\09} else\0A\09{\0A\09\09t = 0;\0A\09}\0A\09*nearest = from + t*v;\0A\09return dot(diff,diff);\09\0A}\0Avoid\09computeContactSphereTriangle(int pairIndex,\0A\09\09\09\09\09\09\09\09\09int bodyIndexA, int bodyIndexB,\0A\09\09\09\09\09\09\09\09\09int collidableIndexA, int collidableIndexB, \0A\09\09\09\09\09\09\09\09\09__global const BodyData* rigidBodies, \0A\09\09\09\09\09\09\09\09\09__global const btCollidableGpu* collidables,\0A\09\09\09\09\09\09\09\09\09const float4* triangleVertices,\0A\09\09\09\09\09\09\09\09\09__global struct b3Contact4Data* restrict globalContactsOut,\0A\09\09\09\09\09\09\09\09\09counter32_t nGlobalContactsOut,\0A\09\09\09\09\09\09\09\09\09int maxContactCapacity,\0A\09\09\09\09\09\09\09\09\09float4 spherePos2,\0A\09\09\09\09\09\09\09\09\09float radius,\0A\09\09\09\09\09\09\09\09\09float4 pos,\0A\09\09\09\09\09\09\09\09\09float4 quat,\0A\09\09\09\09\09\09\09\09\09int faceIndex\0A\09\09\09\09\09\09\09\09\09)\0A{\0A\09float4 invPos;\0A\09float4 invOrn;\0A\09trInverse(pos,quat, &invPos,&invOrn);\0A\09float4 spherePos = transform(&spherePos2,&invPos,&invOrn);\0A\09int numFaces = 3;\0A\09float4 closestPnt = (float4)(0, 0, 0, 0);\0A\09float4 hitNormalWorld = (float4)(0, 0, 0, 0);\0A\09float minDist = -1000000.f;\0A\09bool bCollide = false;\0A\09\0A\09//////////////////////////////////////\0A\09float4 sphereCenter;\0A\09sphereCenter = spherePos;\0A\09const float4* vertices = triangleVertices;\0A\09float contactBreakingThreshold = 0.f;//todo?\0A\09float radiusWithThreshold = radius + contactBreakingThreshold;\0A\09float4 edge10;\0A\09edge10 = vertices[1]-vertices[0];\0A\09edge10.w = 0.f;//is this needed?\0A\09float4 edge20;\0A\09edge20 = vertices[2]-vertices[0];\0A\09edge20.w = 0.f;//is this needed?\0A\09float4 normal = cross3(edge10,edge20);\0A\09normal = normalize(normal);\0A\09float4 p1ToCenter;\0A\09p1ToCenter = sphereCenter - vertices[0];\0A\09\0A\09float distanceFromPlane = dot(p1ToCenter,normal);\0A\09if (distanceFromPlane < 0.f)\0A\09{\0A\09\09//triangle facing the other way\0A\09\09distanceFromPlane *= -1.f;\0A\09\09normal *= -1.f;\0A\09}\0A\09hitNormalWorld = normal;\0A\09bool isInsideContactPlane = distanceFromPlane < radiusWithThreshold;\0A\09\0A\09// Check for contact / intersection\0A\09bool hasContact = false;\0A\09float4 contactPoint;\0A\09if (isInsideContactPlane) \0A\09{\0A\09\0A\09\09if (pointInTriangle(vertices,&normal, &sphereCenter)) \0A\09\09{\0A\09\09\09// Inside the contact wedge - touches a point on the shell plane\0A\09\09\09hasContact = true;\0A\09\09\09contactPoint = sphereCenter - normal*distanceFromPlane;\0A\09\09\09\0A\09\09} else {\0A\09\09\09// Could be inside one of the contact capsules\0A\09\09\09float contactCapsuleRadiusSqr = radiusWithThreshold*radiusWithThreshold;\0A\09\09\09float4 nearestOnEdge;\0A\09\09\09int numEdges = 3;\0A\09\09\09for (int i = 0; i < numEdges; i++) \0A\09\09\09{\0A\09\09\09\09float4 pa =vertices[i];\0A\09\09\09\09float4 pb = vertices[(i+1)%3];\0A\09\09\09\09float distanceSqr = segmentSqrDistance(pa,pb,sphereCenter, &nearestOnEdge);\0A\09\09\09\09if (distanceSqr < contactCapsuleRadiusSqr) \0A\09\09\09\09{\0A\09\09\09\09\09// Yep, we're inside a capsule\0A\09\09\09\09\09hasContact = true;\0A\09\09\09\09\09contactPoint = nearestOnEdge;\0A\09\09\09\09\09\0A\09\09\09\09}\0A\09\09\09\09\0A\09\09\09}\0A\09\09}\0A\09}\0A\09if (hasContact) \0A\09{\0A\09\09closestPnt = contactPoint;\0A\09\09float4 contactToCenter = sphereCenter - contactPoint;\0A\09\09minDist = length(contactToCenter);\0A\09\09if (minDist>FLT_EPSILON)\0A\09\09{\0A\09\09\09hitNormalWorld = normalize(contactToCenter);//*(1./minDist);\0A\09\09\09bCollide  = true;\0A\09\09}\0A\09\09\0A\09}\0A\09/////////////////////////////////////\0A\09if (bCollide && minDist > -10000)\0A\09{\0A\09\09\0A\09\09float4 normalOnSurfaceB1 = qtRotate(quat,-hitNormalWorld);\0A\09\09float4 pOnB1 = transform(&closestPnt,&pos,&quat);\0A\09\09float actualDepth = minDist-radius;\0A\09\09\0A\09\09if (actualDepth<=0.f)\0A\09\09{\0A\09\09\09pOnB1.w = actualDepth;\0A\09\09\09int dstIdx;\0A\09\09\09\0A\09\09\09float lenSqr = dot3F4(normalOnSurfaceB1,normalOnSurfaceB1);\0A\09\09\09if (lenSqr>FLT_EPSILON)\0A\09\09\09{\0A\09\09\09\09AppendInc( nGlobalContactsOut, dstIdx );\0A\09\09\09\0A\09\09\09\09if (dstIdx < maxContactCapacity)\0A\09\09\09\09{\0A\09\09\09\09\09__global struct b3Contact4Data* c = &globalContactsOut[dstIdx];\0A\09\09\09\09\09c->m_worldNormalOnB = -normalOnSurfaceB1;\0A\09\09\09\09\09c->m_restituitionCoeffCmp = (0.f*0xffff);c->m_frictionCoeffCmp = (0.7f*0xffff);\0A\09\09\09\09\09c->m_batchIdx = pairIndex;\0A\09\09\09\09\09c->m_bodyAPtrAndSignBit = rigidBodies[bodyIndexA].m_invMass==0?-bodyIndexA:bodyIndexA;\0A\09\09\09\09\09c->m_bodyBPtrAndSignBit = rigidBodies[bodyIndexB].m_invMass==0?-bodyIndexB:bodyIndexB;\0A\09\09\09\09\09c->m_worldPosB[0] = pOnB1;\0A\09\09\09\09\09c->m_childIndexA = -1;\0A\09\09\09\09\09c->m_childIndexB = faceIndex;\0A\09\09\09\09\09GET_NPOINTS(*c) = 1;\0A\09\09\09\09} \0A\09\09\09}\0A\09\09}\0A\09}//if (hasCollision)\0A}\0A// work-in-progress\0A__kernel void   findConcaveSphereContactsKernel( __global int4* concavePairs,\0A\09\09\09\09\09\09\09\09\09\09\09\09__global const BodyData* rigidBodies,\0A\09\09\09\09\09\09\09\09\09\09\09\09__global const btCollidableGpu* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09__global const ConvexPolyhedronCL* convexShapes, \0A\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* vertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* uniqueEdges,\0A\09\09\09\09\09\09\09\09\09\09\09\09__global const btGpuFace* faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09__global const int* indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09__global btAabbCL* aabbs,\0A\09\09\09\09\09\09\09\09\09\09\09\09__global struct b3Contact4Data* restrict globalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09counter32_t nGlobalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09int numConcavePairs, int maxContactCapacity\0A\09\09\09\09\09\09\09\09\09\09\09\09)\0A{\0A\09int i = get_global_id(0);\0A\09if (i>=numConcavePairs)\0A\09\09return;\0A\09int pairIdx = i;\0A\09int bodyIndexA = concavePairs[i].x;\0A\09int bodyIndexB = concavePairs[i].y;\0A\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09if (collidables[collidableIndexB].m_shapeType==SHAPE_SPHERE)\0A\09{\0A\09\09int f = concavePairs[i].z;\0A\09\09btGpuFace face = faces[convexShapes[shapeIndexA].m_faceOffset+f];\0A\09\09\0A\09\09float4 verticesA[3];\0A\09\09for (int i=0;i<3;i++)\0A\09\09{\0A\09\09\09int index = indices[face.m_indexOffset+i];\0A\09\09\09float4 vert = vertices[convexShapes[shapeIndexA].m_vertexOffset+index];\0A\09\09\09verticesA[i] = vert;\0A\09\09}\0A\09\09float4 spherePos = rigidBodies[bodyIndexB].m_pos;\0A\09\09float sphereRadius = collidables[collidableIndexB].m_radius;\0A\09\09float4 convexPos = rigidBodies[bodyIndexA].m_pos;\0A\09\09float4 convexOrn = rigidBodies[bodyIndexA].m_quat;\0A\09\09computeContactSphereTriangle(i, bodyIndexB, bodyIndexA, collidableIndexB, collidableIndexA, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09rigidBodies,collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09verticesA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09globalContactsOut, nGlobalContactsOut,maxContactCapacity,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09spherePos,sphereRadius,convexPos,convexOrn, f);\0A\09\09return;\0A\09}\0A}\0A\00", align 1
@.str.72 = private unnamed_addr constant [20 x i8] c"clipHullAgainstHull\00", align 1
@_ZZL19clipHullAgainstHullRK9b3Vector3RK22b3ConvexPolyhedronDataS4_S1_RK12b3QuaternionS1_S7_PS_S8_iffRK20b3AlignedObjectArrayIS_ERKS9_I9b3GpuFaceERKS9_IiESC_SG_SJ_S8_iE4once = internal global i8 1, align 1
@.str.73 = private unnamed_addr constant [19 x i8] c"findSeparatingAxis\00", align 1
@__const._ZN12b3LauncherCL8launch2DEiiii.gRange = private unnamed_addr constant [3 x i64] [i64 1, i64 1, i64 1], align 16
@__const._ZN12b3LauncherCL8launch2DEiiii.lRange = private unnamed_addr constant [3 x i64] [i64 1, i64 1, i64 1], align 16
@__clewEnqueueNDRangeKernel = external global ptr, align 8
@.str.74 = private unnamed_addr constant [27 x i8] c"Error: OpenCL status = %d\0A\00", align 1
@_ZTV13b3OpenCLArrayI9b3Vector3E = linkonce_odr dso_local unnamed_addr constant { [4 x ptr] } { [4 x ptr] [ptr null, ptr @_ZTI13b3OpenCLArrayI9b3Vector3E, ptr @_ZN13b3OpenCLArrayI9b3Vector3ED2Ev, ptr @_ZN13b3OpenCLArrayI9b3Vector3ED0Ev] }, comdat, align 8
@_ZTS13b3OpenCLArrayI9b3Vector3E = linkonce_odr dso_local constant [28 x i8] c"13b3OpenCLArrayI9b3Vector3E\00", comdat, align 1
@_ZTI13b3OpenCLArrayI9b3Vector3E = linkonce_odr dso_local constant { ptr, ptr } { ptr getelementptr inbounds (ptr, ptr @_ZTVN10__cxxabiv117__class_type_infoE, i64 2), ptr @_ZTS13b3OpenCLArrayI9b3Vector3E }, comdat, align 8
@__clewCreateBuffer = external global ptr, align 8
@.str.75 = private unnamed_addr constant [146 x i8] c"generated/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/bullet3/bullet3/src/Bullet3OpenCL/ParallelPrimitives/b3OpenCLArray.h\00", align 1
@.str.76 = private unnamed_addr constant [22 x i8] c"OpenCL out-of-memory\0A\00", align 1
@__clewEnqueueCopyBuffer = external global ptr, align 8
@__clewReleaseMemObject = external global ptr, align 8
@_ZTV13b3OpenCLArrayIiE = linkonce_odr dso_local unnamed_addr constant { [4 x ptr] } { [4 x ptr] [ptr null, ptr @_ZTI13b3OpenCLArrayIiE, ptr @_ZN13b3OpenCLArrayIiED2Ev, ptr @_ZN13b3OpenCLArrayIiED0Ev] }, comdat, align 8
@_ZTS13b3OpenCLArrayIiE = linkonce_odr dso_local constant [19 x i8] c"13b3OpenCLArrayIiE\00", comdat, align 1
@_ZTI13b3OpenCLArrayIiE = linkonce_odr dso_local constant { ptr, ptr } { ptr getelementptr inbounds (ptr, ptr @_ZTVN10__cxxabiv117__class_type_infoE, i64 2), ptr @_ZTS13b3OpenCLArrayIiE }, comdat, align 8
@_ZTV13b3OpenCLArrayIfE = linkonce_odr dso_local unnamed_addr constant { [4 x ptr] } { [4 x ptr] [ptr null, ptr @_ZTI13b3OpenCLArrayIfE, ptr @_ZN13b3OpenCLArrayIfED2Ev, ptr @_ZN13b3OpenCLArrayIfED0Ev] }, comdat, align 8
@_ZTS13b3OpenCLArrayIfE = linkonce_odr dso_local constant [19 x i8] c"13b3OpenCLArrayIfE\00", comdat, align 1
@_ZTI13b3OpenCLArrayIfE = linkonce_odr dso_local constant { ptr, ptr } { ptr getelementptr inbounds (ptr, ptr @_ZTVN10__cxxabiv117__class_type_infoE, i64 2), ptr @_ZTS13b3OpenCLArrayIfE }, comdat, align 8
@_ZTV13b3OpenCLArrayI25b3CompoundOverlappingPairE = linkonce_odr dso_local unnamed_addr constant { [4 x ptr] } { [4 x ptr] [ptr null, ptr @_ZTI13b3OpenCLArrayI25b3CompoundOverlappingPairE, ptr @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairED2Ev, ptr @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairED0Ev] }, comdat, align 8
@_ZTS13b3OpenCLArrayI25b3CompoundOverlappingPairE = linkonce_odr dso_local constant [45 x i8] c"13b3OpenCLArrayI25b3CompoundOverlappingPairE\00", comdat, align 1
@_ZTI13b3OpenCLArrayI25b3CompoundOverlappingPairE = linkonce_odr dso_local constant { ptr, ptr } { ptr getelementptr inbounds (ptr, ptr @_ZTVN10__cxxabiv117__class_type_infoE, i64 2), ptr @_ZTS13b3OpenCLArrayI25b3CompoundOverlappingPairE }, comdat, align 8
@__clewEnqueueWriteBuffer = external global ptr, align 8
@.str.77 = private unnamed_addr constant [35 x i8] c"copyFromHostPointer invalid range\0A\00", align 1
@.str.78 = private unnamed_addr constant [134 x i8] c"generated/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/bullet3/bullet3/src/Bullet3Common/b3AlignedObjectArray.h\00", align 1
@.str.79 = private unnamed_addr constant [44 x i8] c"b3AlignedObjectArray reserve out-of-memory\0A\00", align 1
@__clewSetKernelArg = external global ptr, align 8
@__clewEnqueueReadBuffer = external global ptr, align 8
@.str.80 = private unnamed_addr constant [33 x i8] c"copyToHostPointer invalid range\0A\00", align 1
@llvm.global_ctors = appending global [1 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 65535, ptr @_GLOBAL__sub_I_b3ConvexHullContact.cpp, ptr null }]

@_ZN15GpuSatCollisionC1EP11_cl_contextP13_cl_device_idP17_cl_command_queue = dso_local unnamed_addr alias void (ptr, ptr, ptr, ptr), ptr @_ZN15GpuSatCollisionC2EP11_cl_contextP13_cl_device_idP17_cl_command_queue
@_ZN15GpuSatCollisionD1Ev = dso_local unnamed_addr alias void (ptr), ptr @_ZN15GpuSatCollisionD2Ev

; Function Attrs: mustprogress uwtable
define dso_local void @_Z14b3BvhTraversalPK6b3Int4PK15b3RigidBodyDataPK12b3CollidableP6b3AabbPS_PViPK16b3BvhSubtreeInfoPK18b3QuantizedBvhNodePK9b3BvhInfoiii(ptr noundef %pairs, ptr noundef %rigidBodies, ptr noundef %collidables, ptr noundef %aabbs, ptr noundef %concavePairsOut, ptr noundef %numConcavePairsOut, ptr noundef %subtreeHeadersRoot, ptr noundef %quantizedNodesRoot, ptr noundef %bvhInfos, i32 noundef %numPairs, i32 noundef %maxNumConcavePairsCapacity, i32 noundef %id) #0 {
entry:
  %pairs.addr = alloca ptr, align 8
  %rigidBodies.addr = alloca ptr, align 8
  %collidables.addr = alloca ptr, align 8
  %aabbs.addr = alloca ptr, align 8
  %concavePairsOut.addr = alloca ptr, align 8
  %numConcavePairsOut.addr = alloca ptr, align 8
  %subtreeHeadersRoot.addr = alloca ptr, align 8
  %quantizedNodesRoot.addr = alloca ptr, align 8
  %bvhInfos.addr = alloca ptr, align 8
  %numPairs.addr = alloca i32, align 4
  %maxNumConcavePairsCapacity.addr = alloca i32, align 4
  %id.addr = alloca i32, align 4
  %bodyIndexA = alloca i32, align 4
  %bodyIndexB = alloca i32, align 4
  %collidableIndexA = alloca i32, align 4
  %collidableIndexB = alloca i32, align 4
  %shapeTypeB = alloca i32, align 4
  %bvhInfo = alloca %struct.b3BvhInfo, align 16
  %bvhAabbMin = alloca %class.b3Vector3, align 16
  %bvhAabbMax = alloca %class.b3Vector3, align 16
  %bvhQuantization = alloca %class.b3Vector3, align 16
  %numSubtreeHeaders = alloca i32, align 4
  %subtreeHeaders = alloca ptr, align 8
  %quantizedNodes = alloca ptr, align 8
  %quantizedQueryAabbMin = alloca [3 x i16], align 2
  %quantizedQueryAabbMax = alloca [3 x i16], align 2
  %i = alloca i32, align 4
  %subtree = alloca %struct.b3BvhSubtreeInfoData, align 4
  %overlap = alloca i32, align 4
  %startNodeIndex = alloca i32, align 4
  %endNodeIndex = alloca i32, align 4
  %curIndex = alloca i32, align 4
  %escapeIndex = alloca i32, align 4
  %isLeafNode = alloca i32, align 4
  %aabbOverlap = alloca i32, align 4
  %rootNode = alloca %struct.b3QuantizedBvhNodeData, align 4
  %triangleIndex = alloca i32, align 4
  %numChildrenB = alloca i32, align 4
  %pairIdx = alloca i32, align 4
  %b = alloca i32, align 4
  %childShapeIndexB = alloca i32, align 4
  %newPair = alloca %struct.b3Int4, align 16
  %pairIdx87 = alloca i32, align 4
  %newPair91 = alloca %struct.b3Int4, align 16
  store ptr %pairs, ptr %pairs.addr, align 8
  store ptr %rigidBodies, ptr %rigidBodies.addr, align 8
  store ptr %collidables, ptr %collidables.addr, align 8
  store ptr %aabbs, ptr %aabbs.addr, align 8
  store ptr %concavePairsOut, ptr %concavePairsOut.addr, align 8
  store ptr %numConcavePairsOut, ptr %numConcavePairsOut.addr, align 8
  store ptr %subtreeHeadersRoot, ptr %subtreeHeadersRoot.addr, align 8
  store ptr %quantizedNodesRoot, ptr %quantizedNodesRoot.addr, align 8
  store ptr %bvhInfos, ptr %bvhInfos.addr, align 8
  store i32 %numPairs, ptr %numPairs.addr, align 4
  store i32 %maxNumConcavePairsCapacity, ptr %maxNumConcavePairsCapacity.addr, align 4
  store i32 %id, ptr %id.addr, align 4
  %0 = load ptr, ptr %pairs.addr, align 8
  %1 = load i32, ptr %id.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3Int4, ptr %0, i64 %idxprom
  %2 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %x, align 16
  store i32 %3, ptr %bodyIndexA, align 4
  %4 = load ptr, ptr %pairs.addr, align 8
  %5 = load i32, ptr %id.addr, align 4
  %idxprom1 = sext i32 %5 to i64
  %arrayidx2 = getelementptr inbounds %struct.b3Int4, ptr %4, i64 %idxprom1
  %6 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx2, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon, ptr %6, i32 0, i32 1
  %7 = load i32, ptr %y, align 4
  store i32 %7, ptr %bodyIndexB, align 4
  %8 = load ptr, ptr %rigidBodies.addr, align 8
  %9 = load i32, ptr %bodyIndexA, align 4
  %idxprom3 = sext i32 %9 to i64
  %arrayidx4 = getelementptr inbounds %struct.b3RigidBodyData, ptr %8, i64 %idxprom3
  %m_collidableIdx = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx4, i32 0, i32 4
  %10 = load i32, ptr %m_collidableIdx, align 16
  store i32 %10, ptr %collidableIndexA, align 4
  %11 = load ptr, ptr %rigidBodies.addr, align 8
  %12 = load i32, ptr %bodyIndexB, align 4
  %idxprom5 = sext i32 %12 to i64
  %arrayidx6 = getelementptr inbounds %struct.b3RigidBodyData, ptr %11, i64 %idxprom5
  %m_collidableIdx7 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx6, i32 0, i32 4
  %13 = load i32, ptr %m_collidableIdx7, align 16
  store i32 %13, ptr %collidableIndexB, align 4
  %14 = load ptr, ptr %rigidBodies.addr, align 8
  %15 = load i32, ptr %bodyIndexA, align 4
  %idxprom8 = sext i32 %15 to i64
  %arrayidx9 = getelementptr inbounds %struct.b3RigidBodyData, ptr %14, i64 %idxprom8
  %m_invMass = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx9, i32 0, i32 5
  %16 = load float, ptr %m_invMass, align 4
  %cmp = fcmp oeq float %16, 0.000000e+00
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %17 = load ptr, ptr %rigidBodies.addr, align 8
  %18 = load i32, ptr %bodyIndexB, align 4
  %idxprom10 = sext i32 %18 to i64
  %arrayidx11 = getelementptr inbounds %struct.b3RigidBodyData, ptr %17, i64 %idxprom10
  %m_invMass12 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx11, i32 0, i32 5
  %19 = load float, ptr %m_invMass12, align 4
  %cmp13 = fcmp oeq float %19, 0.000000e+00
  br i1 %cmp13, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %for.end113

if.end:                                           ; preds = %land.lhs.true, %entry
  %20 = load ptr, ptr %collidables.addr, align 8
  %21 = load i32, ptr %collidableIndexA, align 4
  %idxprom14 = sext i32 %21 to i64
  %arrayidx15 = getelementptr inbounds %struct.b3Collidable, ptr %20, i64 %idxprom14
  %m_shapeType = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx15, i32 0, i32 2
  %22 = load i32, ptr %m_shapeType, align 4
  %cmp16 = icmp ne i32 %22, 5
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end
  br label %for.end113

if.end18:                                         ; preds = %if.end
  %23 = load ptr, ptr %collidables.addr, align 8
  %24 = load i32, ptr %collidableIndexB, align 4
  %idxprom19 = sext i32 %24 to i64
  %arrayidx20 = getelementptr inbounds %struct.b3Collidable, ptr %23, i64 %idxprom19
  %m_shapeType21 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx20, i32 0, i32 2
  %25 = load i32, ptr %m_shapeType21, align 4
  store i32 %25, ptr %shapeTypeB, align 4
  %26 = load i32, ptr %shapeTypeB, align 4
  %cmp22 = icmp ne i32 %26, 3
  br i1 %cmp22, label %land.lhs.true23, label %if.end28

land.lhs.true23:                                  ; preds = %if.end18
  %27 = load i32, ptr %shapeTypeB, align 4
  %cmp24 = icmp ne i32 %27, 7
  br i1 %cmp24, label %land.lhs.true25, label %if.end28

land.lhs.true25:                                  ; preds = %land.lhs.true23
  %28 = load i32, ptr %shapeTypeB, align 4
  %cmp26 = icmp ne i32 %28, 6
  br i1 %cmp26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %land.lhs.true25
  br label %for.end113

if.end28:                                         ; preds = %land.lhs.true25, %land.lhs.true23, %if.end18
  %29 = load ptr, ptr %bvhInfos.addr, align 8
  %30 = load ptr, ptr %collidables.addr, align 8
  %31 = load i32, ptr %collidableIndexA, align 4
  %idxprom29 = sext i32 %31 to i64
  %arrayidx30 = getelementptr inbounds %struct.b3Collidable, ptr %30, i64 %idxprom29
  %32 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx30, i32 0, i32 0
  %33 = load i32, ptr %32, align 4
  %idxprom31 = sext i32 %33 to i64
  %arrayidx32 = getelementptr inbounds %struct.b3BvhInfo, ptr %29, i64 %idxprom31
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %bvhInfo, ptr align 16 %arrayidx32, i64 64, i1 false)
  %m_aabbMin = getelementptr inbounds %struct.b3BvhInfo, ptr %bvhInfo, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %bvhAabbMin, ptr align 16 %m_aabbMin, i64 16, i1 false)
  %m_aabbMax = getelementptr inbounds %struct.b3BvhInfo, ptr %bvhInfo, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %bvhAabbMax, ptr align 16 %m_aabbMax, i64 16, i1 false)
  %m_quantization = getelementptr inbounds %struct.b3BvhInfo, ptr %bvhInfo, i32 0, i32 2
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %bvhQuantization, ptr align 16 %m_quantization, i64 16, i1 false)
  %m_numSubTrees = getelementptr inbounds %struct.b3BvhInfo, ptr %bvhInfo, i32 0, i32 4
  %34 = load i32, ptr %m_numSubTrees, align 4
  store i32 %34, ptr %numSubtreeHeaders, align 4
  %35 = load ptr, ptr %subtreeHeadersRoot.addr, align 8
  %m_subTreeOffset = getelementptr inbounds %struct.b3BvhInfo, ptr %bvhInfo, i32 0, i32 6
  %36 = load i32, ptr %m_subTreeOffset, align 4
  %idxprom33 = sext i32 %36 to i64
  %arrayidx34 = getelementptr inbounds %class.b3BvhSubtreeInfo, ptr %35, i64 %idxprom33
  store ptr %arrayidx34, ptr %subtreeHeaders, align 8
  %37 = load ptr, ptr %quantizedNodesRoot.addr, align 8
  %m_nodeOffset = getelementptr inbounds %struct.b3BvhInfo, ptr %bvhInfo, i32 0, i32 5
  %38 = load i32, ptr %m_nodeOffset, align 8
  %idxprom35 = sext i32 %38 to i64
  %arrayidx36 = getelementptr inbounds %struct.b3QuantizedBvhNode, ptr %37, i64 %idxprom35
  store ptr %arrayidx36, ptr %quantizedNodes, align 8
  %arraydecay = getelementptr inbounds [3 x i16], ptr %quantizedQueryAabbMin, i64 0, i64 0
  %39 = load ptr, ptr %aabbs.addr, align 8
  %40 = load i32, ptr %bodyIndexB, align 4
  %idxprom37 = sext i32 %40 to i64
  %arrayidx38 = getelementptr inbounds %struct.b3Aabb, ptr %39, i64 %idxprom37
  %41 = getelementptr inbounds %struct.b3Aabb, ptr %arrayidx38, i32 0, i32 0
  call void @_Z19b3QuantizeWithClampPtRK9b3Vector3iS2_S2_S2_(ptr noundef %arraydecay, ptr noundef nonnull align 16 dereferenceable(16) %41, i32 noundef 0, ptr noundef nonnull align 16 dereferenceable(16) %bvhAabbMin, ptr noundef nonnull align 16 dereferenceable(16) %bvhAabbMax, ptr noundef nonnull align 16 dereferenceable(16) %bvhQuantization)
  %arraydecay39 = getelementptr inbounds [3 x i16], ptr %quantizedQueryAabbMax, i64 0, i64 0
  %42 = load ptr, ptr %aabbs.addr, align 8
  %43 = load i32, ptr %bodyIndexB, align 4
  %idxprom40 = sext i32 %43 to i64
  %arrayidx41 = getelementptr inbounds %struct.b3Aabb, ptr %42, i64 %idxprom40
  %44 = getelementptr inbounds %struct.b3Aabb, ptr %arrayidx41, i32 0, i32 1
  call void @_Z19b3QuantizeWithClampPtRK9b3Vector3iS2_S2_S2_(ptr noundef %arraydecay39, ptr noundef nonnull align 16 dereferenceable(16) %44, i32 noundef 1, ptr noundef nonnull align 16 dereferenceable(16) %bvhAabbMin, ptr noundef nonnull align 16 dereferenceable(16) %bvhAabbMax, ptr noundef nonnull align 16 dereferenceable(16) %bvhQuantization)
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc111, %if.end28
  %45 = load i32, ptr %i, align 4
  %46 = load i32, ptr %numSubtreeHeaders, align 4
  %cmp42 = icmp slt i32 %45, %46
  br i1 %cmp42, label %for.body, label %for.end113

for.body:                                         ; preds = %for.cond
  %47 = load ptr, ptr %subtreeHeaders, align 8
  %48 = load i32, ptr %i, align 4
  %idxprom43 = sext i32 %48 to i64
  %arrayidx44 = getelementptr inbounds %struct.b3BvhSubtreeInfoData, ptr %47, i64 %idxprom43
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %subtree, ptr align 4 %arrayidx44, i64 32, i1 false)
  %arraydecay45 = getelementptr inbounds [3 x i16], ptr %quantizedQueryAabbMin, i64 0, i64 0
  %arraydecay46 = getelementptr inbounds [3 x i16], ptr %quantizedQueryAabbMax, i64 0, i64 0
  %m_quantizedAabbMin = getelementptr inbounds %struct.b3BvhSubtreeInfoData, ptr %subtree, i32 0, i32 0
  %arraydecay47 = getelementptr inbounds [3 x i16], ptr %m_quantizedAabbMin, i64 0, i64 0
  %m_quantizedAabbMax = getelementptr inbounds %struct.b3BvhSubtreeInfoData, ptr %subtree, i32 0, i32 1
  %arraydecay48 = getelementptr inbounds [3 x i16], ptr %m_quantizedAabbMax, i64 0, i64 0
  %call = call noundef i32 @_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_(ptr noundef %arraydecay45, ptr noundef %arraydecay46, ptr noundef %arraydecay47, ptr noundef %arraydecay48)
  store i32 %call, ptr %overlap, align 4
  %49 = load i32, ptr %overlap, align 4
  %cmp49 = icmp ne i32 %49, 0
  br i1 %cmp49, label %if.then50, label %if.end110

if.then50:                                        ; preds = %for.body
  %m_rootNodeIndex = getelementptr inbounds %struct.b3BvhSubtreeInfoData, ptr %subtree, i32 0, i32 2
  %50 = load i32, ptr %m_rootNodeIndex, align 4
  store i32 %50, ptr %startNodeIndex, align 4
  %m_rootNodeIndex51 = getelementptr inbounds %struct.b3BvhSubtreeInfoData, ptr %subtree, i32 0, i32 2
  %51 = load i32, ptr %m_rootNodeIndex51, align 4
  %m_subtreeSize = getelementptr inbounds %struct.b3BvhSubtreeInfoData, ptr %subtree, i32 0, i32 3
  %52 = load i32, ptr %m_subtreeSize, align 4
  %add = add nsw i32 %51, %52
  store i32 %add, ptr %endNodeIndex, align 4
  %53 = load i32, ptr %startNodeIndex, align 4
  store i32 %53, ptr %curIndex, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end109, %if.then50
  %54 = load i32, ptr %curIndex, align 4
  %55 = load i32, ptr %endNodeIndex, align 4
  %cmp52 = icmp slt i32 %54, %55
  br i1 %cmp52, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %56 = load ptr, ptr %quantizedNodes, align 8
  %57 = load i32, ptr %curIndex, align 4
  %idxprom53 = sext i32 %57 to i64
  %arrayidx54 = getelementptr inbounds %struct.b3QuantizedBvhNodeData, ptr %56, i64 %idxprom53
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %rootNode, ptr align 4 %arrayidx54, i64 16, i1 false)
  %arraydecay55 = getelementptr inbounds [3 x i16], ptr %quantizedQueryAabbMin, i64 0, i64 0
  %arraydecay56 = getelementptr inbounds [3 x i16], ptr %quantizedQueryAabbMax, i64 0, i64 0
  %m_quantizedAabbMin57 = getelementptr inbounds %struct.b3QuantizedBvhNodeData, ptr %rootNode, i32 0, i32 0
  %arraydecay58 = getelementptr inbounds [3 x i16], ptr %m_quantizedAabbMin57, i64 0, i64 0
  %m_quantizedAabbMax59 = getelementptr inbounds %struct.b3QuantizedBvhNodeData, ptr %rootNode, i32 0, i32 1
  %arraydecay60 = getelementptr inbounds [3 x i16], ptr %m_quantizedAabbMax59, i64 0, i64 0
  %call61 = call noundef i32 @_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_(ptr noundef %arraydecay55, ptr noundef %arraydecay56, ptr noundef %arraydecay58, ptr noundef %arraydecay60)
  store i32 %call61, ptr %aabbOverlap, align 4
  %call62 = call noundef i32 @_Z8b3IsLeafPK22b3QuantizedBvhNodeData(ptr noundef %rootNode)
  store i32 %call62, ptr %isLeafNode, align 4
  %58 = load i32, ptr %aabbOverlap, align 4
  %tobool = icmp ne i32 %58, 0
  br i1 %tobool, label %if.then63, label %if.else101

if.then63:                                        ; preds = %while.body
  %59 = load i32, ptr %isLeafNode, align 4
  %tobool64 = icmp ne i32 %59, 0
  br i1 %tobool64, label %if.then65, label %if.end99

if.then65:                                        ; preds = %if.then63
  %call66 = call noundef i32 @_Z18b3GetTriangleIndexPK22b3QuantizedBvhNodeData(ptr noundef %rootNode)
  store i32 %call66, ptr %triangleIndex, align 4
  %60 = load i32, ptr %shapeTypeB, align 4
  %cmp67 = icmp eq i32 %60, 6
  br i1 %cmp67, label %if.then68, label %if.else

if.then68:                                        ; preds = %if.then65
  %61 = load ptr, ptr %collidables.addr, align 8
  %62 = load i32, ptr %collidableIndexB, align 4
  %idxprom69 = sext i32 %62 to i64
  %arrayidx70 = getelementptr inbounds %struct.b3Collidable, ptr %61, i64 %idxprom69
  %63 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx70, i32 0, i32 0
  %64 = load i32, ptr %63, align 4
  store i32 %64, ptr %numChildrenB, align 4
  %65 = load ptr, ptr %numConcavePairsOut.addr, align 8
  %66 = load i32, ptr %numChildrenB, align 4
  %call71 = call noundef i32 @_Z11b3AtomicAddPVii(ptr noundef %65, i32 noundef %66)
  store i32 %call71, ptr %pairIdx, align 4
  store i32 0, ptr %b, align 4
  br label %for.cond72

for.cond72:                                       ; preds = %for.inc, %if.then68
  %67 = load i32, ptr %b, align 4
  %68 = load i32, ptr %numChildrenB, align 4
  %cmp73 = icmp slt i32 %67, %68
  br i1 %cmp73, label %for.body74, label %for.end

for.body74:                                       ; preds = %for.cond72
  %69 = load i32, ptr %pairIdx, align 4
  %70 = load i32, ptr %b, align 4
  %add75 = add nsw i32 %69, %70
  %71 = load i32, ptr %maxNumConcavePairsCapacity.addr, align 4
  %cmp76 = icmp slt i32 %add75, %71
  br i1 %cmp76, label %if.then77, label %if.end86

if.then77:                                        ; preds = %for.body74
  %72 = load ptr, ptr %collidables.addr, align 8
  %73 = load i32, ptr %collidableIndexB, align 4
  %idxprom78 = sext i32 %73 to i64
  %arrayidx79 = getelementptr inbounds %struct.b3Collidable, ptr %72, i64 %idxprom78
  %74 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx79, i32 0, i32 3
  %75 = load i32, ptr %74, align 4
  %76 = load i32, ptr %b, align 4
  %add80 = add nsw i32 %75, %76
  store i32 %add80, ptr %childShapeIndexB, align 4
  %77 = load i32, ptr %bodyIndexA, align 4
  %78 = load i32, ptr %bodyIndexB, align 4
  %79 = load i32, ptr %triangleIndex, align 4
  %80 = load i32, ptr %childShapeIndexB, align 4
  %call81 = call { i64, i64 } @_Z10b3MakeInt4iiii(i32 noundef %77, i32 noundef %78, i32 noundef %79, i32 noundef %80)
  %coerce.dive = getelementptr inbounds %struct.b3Int4, ptr %newPair, i32 0, i32 0
  %coerce.dive82 = getelementptr inbounds %union.anon, ptr %coerce.dive, i32 0, i32 0
  %81 = getelementptr inbounds { i64, i64 }, ptr %coerce.dive82, i32 0, i32 0
  %82 = extractvalue { i64, i64 } %call81, 0
  store i64 %82, ptr %81, align 16
  %83 = getelementptr inbounds { i64, i64 }, ptr %coerce.dive82, i32 0, i32 1
  %84 = extractvalue { i64, i64 } %call81, 1
  store i64 %84, ptr %83, align 8
  %85 = load ptr, ptr %concavePairsOut.addr, align 8
  %86 = load i32, ptr %pairIdx, align 4
  %87 = load i32, ptr %b, align 4
  %add83 = add nsw i32 %86, %87
  %idxprom84 = sext i32 %add83 to i64
  %arrayidx85 = getelementptr inbounds %struct.b3Int4, ptr %85, i64 %idxprom84
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx85, ptr align 16 %newPair, i64 16, i1 false)
  br label %if.end86

if.end86:                                         ; preds = %if.then77, %for.body74
  br label %for.inc

for.inc:                                          ; preds = %if.end86
  %88 = load i32, ptr %b, align 4
  %inc = add nsw i32 %88, 1
  store i32 %inc, ptr %b, align 4
  br label %for.cond72, !llvm.loop !5

for.end:                                          ; preds = %for.cond72
  br label %if.end98

if.else:                                          ; preds = %if.then65
  %89 = load ptr, ptr %numConcavePairsOut.addr, align 8
  %90 = load volatile i32, ptr %89, align 4
  %inc88 = add nsw i32 %90, 1
  store volatile i32 %inc88, ptr %89, align 4
  store i32 %90, ptr %pairIdx87, align 4
  %91 = load i32, ptr %pairIdx87, align 4
  %92 = load i32, ptr %maxNumConcavePairsCapacity.addr, align 4
  %cmp89 = icmp slt i32 %91, %92
  br i1 %cmp89, label %if.then90, label %if.end97

if.then90:                                        ; preds = %if.else
  %93 = load i32, ptr %bodyIndexA, align 4
  %94 = load i32, ptr %bodyIndexB, align 4
  %95 = load i32, ptr %triangleIndex, align 4
  %call92 = call { i64, i64 } @_Z10b3MakeInt4iiii(i32 noundef %93, i32 noundef %94, i32 noundef %95, i32 noundef 0)
  %coerce.dive93 = getelementptr inbounds %struct.b3Int4, ptr %newPair91, i32 0, i32 0
  %coerce.dive94 = getelementptr inbounds %union.anon, ptr %coerce.dive93, i32 0, i32 0
  %96 = getelementptr inbounds { i64, i64 }, ptr %coerce.dive94, i32 0, i32 0
  %97 = extractvalue { i64, i64 } %call92, 0
  store i64 %97, ptr %96, align 16
  %98 = getelementptr inbounds { i64, i64 }, ptr %coerce.dive94, i32 0, i32 1
  %99 = extractvalue { i64, i64 } %call92, 1
  store i64 %99, ptr %98, align 8
  %100 = load ptr, ptr %concavePairsOut.addr, align 8
  %101 = load i32, ptr %pairIdx87, align 4
  %idxprom95 = sext i32 %101 to i64
  %arrayidx96 = getelementptr inbounds %struct.b3Int4, ptr %100, i64 %idxprom95
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx96, ptr align 16 %newPair91, i64 16, i1 false)
  br label %if.end97

if.end97:                                         ; preds = %if.then90, %if.else
  br label %if.end98

if.end98:                                         ; preds = %if.end97, %for.end
  br label %if.end99

if.end99:                                         ; preds = %if.end98, %if.then63
  %102 = load i32, ptr %curIndex, align 4
  %inc100 = add nsw i32 %102, 1
  store i32 %inc100, ptr %curIndex, align 4
  br label %if.end109

if.else101:                                       ; preds = %while.body
  %103 = load i32, ptr %isLeafNode, align 4
  %tobool102 = icmp ne i32 %103, 0
  br i1 %tobool102, label %if.then103, label %if.else105

if.then103:                                       ; preds = %if.else101
  %104 = load i32, ptr %curIndex, align 4
  %inc104 = add nsw i32 %104, 1
  store i32 %inc104, ptr %curIndex, align 4
  br label %if.end108

if.else105:                                       ; preds = %if.else101
  %call106 = call noundef i32 @_Z16b3GetEscapeIndexPK22b3QuantizedBvhNodeData(ptr noundef %rootNode)
  store i32 %call106, ptr %escapeIndex, align 4
  %105 = load i32, ptr %escapeIndex, align 4
  %106 = load i32, ptr %curIndex, align 4
  %add107 = add nsw i32 %106, %105
  store i32 %add107, ptr %curIndex, align 4
  br label %if.end108

if.end108:                                        ; preds = %if.else105, %if.then103
  br label %if.end109

if.end109:                                        ; preds = %if.end108, %if.end99
  br label %while.cond, !llvm.loop !7

while.end:                                        ; preds = %while.cond
  br label %if.end110

if.end110:                                        ; preds = %while.end, %for.body
  br label %for.inc111

for.inc111:                                       ; preds = %if.end110
  %107 = load i32, ptr %i, align 4
  %inc112 = add nsw i32 %107, 1
  store i32 %inc112, ptr %i, align 4
  br label %for.cond, !llvm.loop !8

for.end113:                                       ; preds = %for.cond, %if.then27, %if.then17, %if.then
  ret void
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #1

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z19b3QuantizeWithClampPtRK9b3Vector3iS2_S2_S2_(ptr noundef %out, ptr noundef nonnull align 16 dereferenceable(16) %point2, i32 noundef %isMax, ptr noundef nonnull align 16 dereferenceable(16) %bvhAabbMin, ptr noundef nonnull align 16 dereferenceable(16) %bvhAabbMax, ptr noundef nonnull align 16 dereferenceable(16) %bvhQuantization) #2 comdat {
entry:
  %out.addr = alloca ptr, align 8
  %point2.addr = alloca ptr, align 8
  %isMax.addr = alloca i32, align 4
  %bvhAabbMin.addr = alloca ptr, align 8
  %bvhAabbMax.addr = alloca ptr, align 8
  %bvhQuantization.addr = alloca ptr, align 8
  %clampedPoint = alloca %class.b3Vector3, align 16
  %ref.tmp = alloca %class.b3Vector3, align 16
  %v = alloca %class.b3Vector3, align 16
  %ref.tmp5 = alloca %class.b3Vector3, align 16
  store ptr %out, ptr %out.addr, align 8
  store ptr %point2, ptr %point2.addr, align 8
  store i32 %isMax, ptr %isMax.addr, align 4
  store ptr %bvhAabbMin, ptr %bvhAabbMin.addr, align 8
  store ptr %bvhAabbMax, ptr %bvhAabbMax.addr, align 8
  store ptr %bvhQuantization, ptr %bvhQuantization.addr, align 8
  %0 = load ptr, ptr %point2.addr, align 8
  %1 = load ptr, ptr %bvhAabbMin.addr, align 8
  %call = call { <2 x float>, <2 x float> } @_Z11b3MaxFloat4RK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %0, ptr noundef nonnull align 16 dereferenceable(16) %1)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %clampedPoint, i32 0, i32 0
  %coerce.dive1 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %2 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive1, i32 0, i32 0
  %3 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %3, ptr %2, align 16
  %4 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive1, i32 0, i32 1
  %5 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %5, ptr %4, align 8
  %6 = load ptr, ptr %bvhAabbMax.addr, align 8
  %call2 = call { <2 x float>, <2 x float> } @_Z11b3MinFloat4RK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %clampedPoint, ptr noundef nonnull align 16 dereferenceable(16) %6)
  %coerce.dive3 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive4 = getelementptr inbounds %union.anon.1, ptr %coerce.dive3, i32 0, i32 0
  %7 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive4, i32 0, i32 0
  %8 = extractvalue { <2 x float>, <2 x float> } %call2, 0
  store <2 x float> %8, ptr %7, align 16
  %9 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive4, i32 0, i32 1
  %10 = extractvalue { <2 x float>, <2 x float> } %call2, 1
  store <2 x float> %10, ptr %9, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %clampedPoint, ptr align 16 %ref.tmp, i64 16, i1 false)
  %11 = load ptr, ptr %bvhAabbMin.addr, align 8
  %call6 = call { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %clampedPoint, ptr noundef nonnull align 16 dereferenceable(16) %11)
  %coerce.dive7 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp5, i32 0, i32 0
  %coerce.dive8 = getelementptr inbounds %union.anon.1, ptr %coerce.dive7, i32 0, i32 0
  %12 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive8, i32 0, i32 0
  %13 = extractvalue { <2 x float>, <2 x float> } %call6, 0
  store <2 x float> %13, ptr %12, align 16
  %14 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive8, i32 0, i32 1
  %15 = extractvalue { <2 x float>, <2 x float> } %call6, 1
  store <2 x float> %15, ptr %14, align 8
  %16 = load ptr, ptr %bvhQuantization.addr, align 8
  %call9 = call { <2 x float>, <2 x float> } @_ZmlRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp5, ptr noundef nonnull align 16 dereferenceable(16) %16)
  %coerce.dive10 = getelementptr inbounds %class.b3Vector3, ptr %v, i32 0, i32 0
  %coerce.dive11 = getelementptr inbounds %union.anon.1, ptr %coerce.dive10, i32 0, i32 0
  %17 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive11, i32 0, i32 0
  %18 = extractvalue { <2 x float>, <2 x float> } %call9, 0
  store <2 x float> %18, ptr %17, align 16
  %19 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive11, i32 0, i32 1
  %20 = extractvalue { <2 x float>, <2 x float> } %call9, 1
  store <2 x float> %20, ptr %19, align 8
  %21 = load i32, ptr %isMax.addr, align 4
  %tobool = icmp ne i32 %21, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %22 = getelementptr inbounds %class.b3Vector3, ptr %v, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon.2, ptr %22, i32 0, i32 0
  %23 = load float, ptr %x, align 16
  %add = fadd float %23, 1.000000e+00
  %conv = fptoui float %add to i16
  %conv12 = zext i16 %conv to i32
  %or = or i32 %conv12, 1
  %conv13 = trunc i32 %or to i16
  %24 = load ptr, ptr %out.addr, align 8
  %arrayidx = getelementptr inbounds i16, ptr %24, i64 0
  store i16 %conv13, ptr %arrayidx, align 2
  %25 = getelementptr inbounds %class.b3Vector3, ptr %v, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon.2, ptr %25, i32 0, i32 1
  %26 = load float, ptr %y, align 4
  %add14 = fadd float %26, 1.000000e+00
  %conv15 = fptoui float %add14 to i16
  %conv16 = zext i16 %conv15 to i32
  %or17 = or i32 %conv16, 1
  %conv18 = trunc i32 %or17 to i16
  %27 = load ptr, ptr %out.addr, align 8
  %arrayidx19 = getelementptr inbounds i16, ptr %27, i64 1
  store i16 %conv18, ptr %arrayidx19, align 2
  %28 = getelementptr inbounds %class.b3Vector3, ptr %v, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon.2, ptr %28, i32 0, i32 2
  %29 = load float, ptr %z, align 8
  %add20 = fadd float %29, 1.000000e+00
  %conv21 = fptoui float %add20 to i16
  %conv22 = zext i16 %conv21 to i32
  %or23 = or i32 %conv22, 1
  %conv24 = trunc i32 %or23 to i16
  %30 = load ptr, ptr %out.addr, align 8
  %arrayidx25 = getelementptr inbounds i16, ptr %30, i64 2
  store i16 %conv24, ptr %arrayidx25, align 2
  br label %if.end

if.else:                                          ; preds = %entry
  %31 = getelementptr inbounds %class.b3Vector3, ptr %v, i32 0, i32 0
  %x26 = getelementptr inbounds %struct.anon.2, ptr %31, i32 0, i32 0
  %32 = load float, ptr %x26, align 16
  %conv27 = fptoui float %32 to i16
  %conv28 = zext i16 %conv27 to i32
  %and = and i32 %conv28, 65534
  %conv29 = trunc i32 %and to i16
  %33 = load ptr, ptr %out.addr, align 8
  %arrayidx30 = getelementptr inbounds i16, ptr %33, i64 0
  store i16 %conv29, ptr %arrayidx30, align 2
  %34 = getelementptr inbounds %class.b3Vector3, ptr %v, i32 0, i32 0
  %y31 = getelementptr inbounds %struct.anon.2, ptr %34, i32 0, i32 1
  %35 = load float, ptr %y31, align 4
  %conv32 = fptoui float %35 to i16
  %conv33 = zext i16 %conv32 to i32
  %and34 = and i32 %conv33, 65534
  %conv35 = trunc i32 %and34 to i16
  %36 = load ptr, ptr %out.addr, align 8
  %arrayidx36 = getelementptr inbounds i16, ptr %36, i64 1
  store i16 %conv35, ptr %arrayidx36, align 2
  %37 = getelementptr inbounds %class.b3Vector3, ptr %v, i32 0, i32 0
  %z37 = getelementptr inbounds %struct.anon.2, ptr %37, i32 0, i32 2
  %38 = load float, ptr %z37, align 8
  %conv38 = fptoui float %38 to i16
  %conv39 = zext i16 %conv38 to i32
  %and40 = and i32 %conv39, 65534
  %conv41 = trunc i32 %and40 to i16
  %39 = load ptr, ptr %out.addr, align 8
  %arrayidx42 = getelementptr inbounds i16, ptr %39, i64 2
  store i16 %conv41, ptr %arrayidx42, align 2
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_(ptr noundef %aabbMin1, ptr noundef %aabbMax1, ptr noundef %aabbMin2, ptr noundef %aabbMax2) #3 comdat {
entry:
  %retval = alloca i32, align 4
  %aabbMin1.addr = alloca ptr, align 8
  %aabbMax1.addr = alloca ptr, align 8
  %aabbMin2.addr = alloca ptr, align 8
  %aabbMax2.addr = alloca ptr, align 8
  store ptr %aabbMin1, ptr %aabbMin1.addr, align 8
  store ptr %aabbMax1, ptr %aabbMax1.addr, align 8
  store ptr %aabbMin2, ptr %aabbMin2.addr, align 8
  store ptr %aabbMax2, ptr %aabbMax2.addr, align 8
  %0 = load ptr, ptr %aabbMin1.addr, align 8
  %arrayidx = getelementptr inbounds i16, ptr %0, i64 0
  %1 = load i16, ptr %arrayidx, align 2
  %conv = zext i16 %1 to i32
  %2 = load ptr, ptr %aabbMax2.addr, align 8
  %arrayidx1 = getelementptr inbounds i16, ptr %2, i64 0
  %3 = load i16, ptr %arrayidx1, align 2
  %conv2 = zext i16 %3 to i32
  %cmp = icmp sgt i32 %conv, %conv2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %aabbMax1.addr, align 8
  %arrayidx3 = getelementptr inbounds i16, ptr %4, i64 0
  %5 = load i16, ptr %arrayidx3, align 2
  %conv4 = zext i16 %5 to i32
  %6 = load ptr, ptr %aabbMin2.addr, align 8
  %arrayidx5 = getelementptr inbounds i16, ptr %6, i64 0
  %7 = load i16, ptr %arrayidx5, align 2
  %conv6 = zext i16 %7 to i32
  %cmp7 = icmp slt i32 %conv4, %conv6
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end
  %8 = load ptr, ptr %aabbMin1.addr, align 8
  %arrayidx10 = getelementptr inbounds i16, ptr %8, i64 1
  %9 = load i16, ptr %arrayidx10, align 2
  %conv11 = zext i16 %9 to i32
  %10 = load ptr, ptr %aabbMax2.addr, align 8
  %arrayidx12 = getelementptr inbounds i16, ptr %10, i64 1
  %11 = load i16, ptr %arrayidx12, align 2
  %conv13 = zext i16 %11 to i32
  %cmp14 = icmp sgt i32 %conv11, %conv13
  br i1 %cmp14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end9
  store i32 0, ptr %retval, align 4
  br label %return

if.end16:                                         ; preds = %if.end9
  %12 = load ptr, ptr %aabbMax1.addr, align 8
  %arrayidx17 = getelementptr inbounds i16, ptr %12, i64 1
  %13 = load i16, ptr %arrayidx17, align 2
  %conv18 = zext i16 %13 to i32
  %14 = load ptr, ptr %aabbMin2.addr, align 8
  %arrayidx19 = getelementptr inbounds i16, ptr %14, i64 1
  %15 = load i16, ptr %arrayidx19, align 2
  %conv20 = zext i16 %15 to i32
  %cmp21 = icmp slt i32 %conv18, %conv20
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.end16
  store i32 0, ptr %retval, align 4
  br label %return

if.end23:                                         ; preds = %if.end16
  %16 = load ptr, ptr %aabbMin1.addr, align 8
  %arrayidx24 = getelementptr inbounds i16, ptr %16, i64 2
  %17 = load i16, ptr %arrayidx24, align 2
  %conv25 = zext i16 %17 to i32
  %18 = load ptr, ptr %aabbMax2.addr, align 8
  %arrayidx26 = getelementptr inbounds i16, ptr %18, i64 2
  %19 = load i16, ptr %arrayidx26, align 2
  %conv27 = zext i16 %19 to i32
  %cmp28 = icmp sgt i32 %conv25, %conv27
  br i1 %cmp28, label %if.then29, label %if.end30

if.then29:                                        ; preds = %if.end23
  store i32 0, ptr %retval, align 4
  br label %return

if.end30:                                         ; preds = %if.end23
  %20 = load ptr, ptr %aabbMax1.addr, align 8
  %arrayidx31 = getelementptr inbounds i16, ptr %20, i64 2
  %21 = load i16, ptr %arrayidx31, align 2
  %conv32 = zext i16 %21 to i32
  %22 = load ptr, ptr %aabbMin2.addr, align 8
  %arrayidx33 = getelementptr inbounds i16, ptr %22, i64 2
  %23 = load i16, ptr %arrayidx33, align 2
  %conv34 = zext i16 %23 to i32
  %cmp35 = icmp slt i32 %conv32, %conv34
  br i1 %cmp35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.end30
  store i32 0, ptr %retval, align 4
  br label %return

if.end37:                                         ; preds = %if.end30
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end37, %if.then36, %if.then29, %if.then22, %if.then15, %if.then8, %if.then
  %24 = load i32, ptr %retval, align 4
  ret i32 %24
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_Z8b3IsLeafPK22b3QuantizedBvhNodeData(ptr noundef %rootNode) #3 comdat {
entry:
  %rootNode.addr = alloca ptr, align 8
  store ptr %rootNode, ptr %rootNode.addr, align 8
  %0 = load ptr, ptr %rootNode.addr, align 8
  %m_escapeIndexOrTriangleIndex = getelementptr inbounds %struct.b3QuantizedBvhNodeData, ptr %0, i32 0, i32 2
  %1 = load i32, ptr %m_escapeIndexOrTriangleIndex, align 4
  %cmp = icmp sge i32 %1, 0
  %cond = select i1 %cmp, i32 1, i32 0
  ret i32 %cond
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_Z18b3GetTriangleIndexPK22b3QuantizedBvhNodeData(ptr noundef %rootNode) #3 comdat {
entry:
  %rootNode.addr = alloca ptr, align 8
  %x = alloca i32, align 4
  %y = alloca i32, align 4
  store ptr %rootNode, ptr %rootNode.addr, align 8
  store i32 0, ptr %x, align 4
  %0 = load i32, ptr %x, align 4
  %and = and i32 %0, 0
  %not = xor i32 %and, -1
  %shl = shl i32 %not, 21
  store i32 %shl, ptr %y, align 4
  %1 = load ptr, ptr %rootNode.addr, align 8
  %m_escapeIndexOrTriangleIndex = getelementptr inbounds %struct.b3QuantizedBvhNodeData, ptr %1, i32 0, i32 2
  %2 = load i32, ptr %m_escapeIndexOrTriangleIndex, align 4
  %3 = load i32, ptr %y, align 4
  %not1 = xor i32 %3, -1
  %and2 = and i32 %2, %not1
  ret i32 %and2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_Z11b3AtomicAddPVii(ptr noundef %p, i32 noundef %val) #3 comdat {
entry:
  %p.addr = alloca ptr, align 8
  %val.addr = alloca i32, align 4
  %oldValue = alloca i32, align 4
  %newValue = alloca i32, align 4
  store ptr %p, ptr %p.addr, align 8
  store i32 %val, ptr %val.addr, align 4
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load volatile i32, ptr %0, align 4
  store i32 %1, ptr %oldValue, align 4
  %2 = load i32, ptr %oldValue, align 4
  %3 = load i32, ptr %val.addr, align 4
  %add = add nsw i32 %2, %3
  store i32 %add, ptr %newValue, align 4
  %4 = load i32, ptr %newValue, align 4
  %5 = load ptr, ptr %p.addr, align 8
  store volatile i32 %4, ptr %5, align 4
  %6 = load i32, ptr %oldValue, align 4
  ret i32 %6
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local { i64, i64 } @_Z10b3MakeInt4iiii(i32 noundef %x, i32 noundef %y, i32 noundef %z, i32 noundef %w) #3 comdat {
entry:
  %retval = alloca %struct.b3Int4, align 16
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %z.addr = alloca i32, align 4
  %w.addr = alloca i32, align 4
  store i32 %x, ptr %x.addr, align 4
  store i32 %y, ptr %y.addr, align 4
  store i32 %z, ptr %z.addr, align 4
  store i32 %w, ptr %w.addr, align 4
  %0 = load i32, ptr %x.addr, align 4
  %1 = getelementptr inbounds %struct.b3Int4, ptr %retval, i32 0, i32 0
  %s = getelementptr inbounds %struct.anon.0, ptr %1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x i32], ptr %s, i64 0, i64 0
  store i32 %0, ptr %arrayidx, align 16
  %2 = load i32, ptr %y.addr, align 4
  %3 = getelementptr inbounds %struct.b3Int4, ptr %retval, i32 0, i32 0
  %s1 = getelementptr inbounds %struct.anon.0, ptr %3, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [4 x i32], ptr %s1, i64 0, i64 1
  store i32 %2, ptr %arrayidx2, align 4
  %4 = load i32, ptr %z.addr, align 4
  %5 = getelementptr inbounds %struct.b3Int4, ptr %retval, i32 0, i32 0
  %s3 = getelementptr inbounds %struct.anon.0, ptr %5, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [4 x i32], ptr %s3, i64 0, i64 2
  store i32 %4, ptr %arrayidx4, align 8
  %6 = load i32, ptr %w.addr, align 4
  %7 = getelementptr inbounds %struct.b3Int4, ptr %retval, i32 0, i32 0
  %s5 = getelementptr inbounds %struct.anon.0, ptr %7, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [4 x i32], ptr %s5, i64 0, i64 3
  store i32 %6, ptr %arrayidx6, align 4
  %coerce.dive = getelementptr inbounds %struct.b3Int4, ptr %retval, i32 0, i32 0
  %coerce.dive7 = getelementptr inbounds %union.anon, ptr %coerce.dive, i32 0, i32 0
  %8 = load { i64, i64 }, ptr %coerce.dive7, align 16
  ret { i64, i64 } %8
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_Z16b3GetEscapeIndexPK22b3QuantizedBvhNodeData(ptr noundef %rootNode) #3 comdat {
entry:
  %rootNode.addr = alloca ptr, align 8
  store ptr %rootNode, ptr %rootNode.addr, align 8
  %0 = load ptr, ptr %rootNode.addr, align 8
  %m_escapeIndexOrTriangleIndex = getelementptr inbounds %struct.b3QuantizedBvhNodeData, ptr %0, i32 0, i32 2
  %1 = load i32, ptr %m_escapeIndexOrTriangleIndex, align 4
  %sub = sub nsw i32 0, %1
  ret i32 %sub
}

; Function Attrs: mustprogress uwtable
define dso_local noundef zeroext i1 @_Z20b3FindSeparatingAxisPK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_Pf(ptr noundef %hullA, ptr noundef %hullB, ptr noundef nonnull align 16 dereferenceable(16) %posA1, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB1, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %DeltaC2, ptr noundef %verticesA, ptr noundef %uniqueEdgesA, ptr noundef %facesA, ptr noundef %indicesA, ptr noundef %verticesB, ptr noundef %uniqueEdgesB, ptr noundef %facesB, ptr noundef %indicesB, ptr noundef %sep, ptr noundef %dmin) #2 {
entry:
  %retval = alloca i1, align 1
  %hullA.addr = alloca ptr, align 8
  %hullB.addr = alloca ptr, align 8
  %posA1.addr = alloca ptr, align 8
  %ornA.addr = alloca ptr, align 8
  %posB1.addr = alloca ptr, align 8
  %ornB.addr = alloca ptr, align 8
  %DeltaC2.addr = alloca ptr, align 8
  %verticesA.addr = alloca ptr, align 8
  %uniqueEdgesA.addr = alloca ptr, align 8
  %facesA.addr = alloca ptr, align 8
  %indicesA.addr = alloca ptr, align 8
  %verticesB.addr = alloca ptr, align 8
  %uniqueEdgesB.addr = alloca ptr, align 8
  %facesB.addr = alloca ptr, align 8
  %indicesB.addr = alloca ptr, align 8
  %sep.addr = alloca ptr, align 8
  %dmin.addr = alloca ptr, align 8
  %posA = alloca %class.b3Vector3, align 16
  %posB = alloca %class.b3Vector3, align 16
  %curPlaneTests = alloca i32, align 4
  %numFacesA = alloca i32, align 4
  %i = alloca i32, align 4
  %normal = alloca %class.b3Vector3, align 16
  %faceANormalWS = alloca %class.b3Vector3, align 16
  %ref.tmp = alloca float, align 4
  %d = alloca float, align 4
  %ref.tmp13 = alloca %class.b3Vector3, align 16
  %ref.tmp20 = alloca %class.b3Vector3, align 16
  store ptr %hullA, ptr %hullA.addr, align 8
  store ptr %hullB, ptr %hullB.addr, align 8
  store ptr %posA1, ptr %posA1.addr, align 8
  store ptr %ornA, ptr %ornA.addr, align 8
  store ptr %posB1, ptr %posB1.addr, align 8
  store ptr %ornB, ptr %ornB.addr, align 8
  store ptr %DeltaC2, ptr %DeltaC2.addr, align 8
  store ptr %verticesA, ptr %verticesA.addr, align 8
  store ptr %uniqueEdgesA, ptr %uniqueEdgesA.addr, align 8
  store ptr %facesA, ptr %facesA.addr, align 8
  store ptr %indicesA, ptr %indicesA.addr, align 8
  store ptr %verticesB, ptr %verticesB.addr, align 8
  store ptr %uniqueEdgesB, ptr %uniqueEdgesB.addr, align 8
  store ptr %facesB, ptr %facesB.addr, align 8
  store ptr %indicesB, ptr %indicesB.addr, align 8
  store ptr %sep, ptr %sep.addr, align 8
  store ptr %dmin, ptr %dmin.addr, align 8
  %0 = load ptr, ptr %posA1.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posA, ptr align 16 %0, i64 16, i1 false)
  %1 = getelementptr inbounds %class.b3Vector3, ptr %posA, i32 0, i32 0
  %w = getelementptr inbounds %struct.anon.2, ptr %1, i32 0, i32 3
  store float 0.000000e+00, ptr %w, align 4
  %2 = load ptr, ptr %posB1.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posB, ptr align 16 %2, i64 16, i1 false)
  %3 = getelementptr inbounds %class.b3Vector3, ptr %posB, i32 0, i32 0
  %w1 = getelementptr inbounds %struct.anon.2, ptr %3, i32 0, i32 3
  store float 0.000000e+00, ptr %w1, align 4
  store i32 0, ptr %curPlaneTests, align 4
  %4 = load ptr, ptr %hullA.addr, align 8
  %m_numFaces = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %4, i32 0, i32 6
  %5 = load i32, ptr %m_numFaces, align 8
  store i32 %5, ptr %numFacesA, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load i32, ptr %i, align 4
  %7 = load i32, ptr %numFacesA, align 4
  %cmp = icmp slt i32 %6, %7
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load ptr, ptr %facesA.addr, align 8
  %9 = load ptr, ptr %hullA.addr, align 8
  %m_faceOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %9, i32 0, i32 5
  %10 = load i32, ptr %m_faceOffset, align 4
  %11 = load i32, ptr %i, align 4
  %add = add nsw i32 %10, %11
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr inbounds %struct.b3GpuFace, ptr %8, i64 %idxprom
  %m_plane = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %normal, ptr align 16 %m_plane, i64 16, i1 false)
  %12 = load ptr, ptr %ornA.addr, align 8
  %call = call { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %12, ptr noundef nonnull align 16 dereferenceable(16) %normal)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %faceANormalWS, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %13 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive2, i32 0, i32 0
  %14 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %14, ptr %13, align 16
  %15 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive2, i32 0, i32 1
  %16 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %16, ptr %15, align 8
  %17 = load ptr, ptr %DeltaC2.addr, align 8
  %call3 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %17, ptr noundef nonnull align 16 dereferenceable(16) %faceANormalWS)
  %cmp4 = fcmp olt float %call3, 0.000000e+00
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  store float -1.000000e+00, ptr %ref.tmp, align 4
  %call5 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector3mLERKf(ptr noundef nonnull align 16 dereferenceable(16) %faceANormalWS, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %18 = load i32, ptr %curPlaneTests, align 4
  %inc = add nsw i32 %18, 1
  store i32 %inc, ptr %curPlaneTests, align 4
  %19 = load ptr, ptr %hullA.addr, align 8
  %20 = load ptr, ptr %hullB.addr, align 8
  %21 = load ptr, ptr %ornA.addr, align 8
  %22 = load ptr, ptr %ornB.addr, align 8
  %23 = load ptr, ptr %verticesA.addr, align 8
  %24 = load ptr, ptr %verticesB.addr, align 8
  %call6 = call noundef zeroext i1 @_Z13b3TestSepAxisPK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_PS2_PS3_S9_Pf(ptr noundef %19, ptr noundef %20, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %21, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %22, ptr noundef %faceANormalWS, ptr noundef %23, ptr noundef %24, ptr noundef %d)
  br i1 %call6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end8:                                          ; preds = %if.end
  %25 = load float, ptr %d, align 4
  %26 = load ptr, ptr %dmin.addr, align 8
  %27 = load float, ptr %26, align 4
  %cmp9 = fcmp olt float %25, %27
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end8
  %28 = load float, ptr %d, align 4
  %29 = load ptr, ptr %dmin.addr, align 8
  store float %28, ptr %29, align 4
  %30 = load ptr, ptr %sep.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %30, ptr align 16 %faceANormalWS, i64 16, i1 false)
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %if.end8
  br label %for.inc

for.inc:                                          ; preds = %if.end11
  %31 = load i32, ptr %i, align 4
  %inc12 = add nsw i32 %31, 1
  store i32 %inc12, ptr %i, align 4
  br label %for.cond, !llvm.loop !9

for.end:                                          ; preds = %for.cond
  %32 = load ptr, ptr %DeltaC2.addr, align 8
  %call14 = call { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %32)
  %coerce.dive15 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp13, i32 0, i32 0
  %coerce.dive16 = getelementptr inbounds %union.anon.1, ptr %coerce.dive15, i32 0, i32 0
  %33 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive16, i32 0, i32 0
  %34 = extractvalue { <2 x float>, <2 x float> } %call14, 0
  store <2 x float> %34, ptr %33, align 16
  %35 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive16, i32 0, i32 1
  %36 = extractvalue { <2 x float>, <2 x float> } %call14, 1
  store <2 x float> %36, ptr %35, align 8
  %37 = load ptr, ptr %sep.addr, align 8
  %call17 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp13, ptr noundef nonnull align 16 dereferenceable(16) %37)
  %cmp18 = fcmp ogt float %call17, 0.000000e+00
  br i1 %cmp18, label %if.then19, label %if.end24

if.then19:                                        ; preds = %for.end
  %38 = load ptr, ptr %sep.addr, align 8
  %call21 = call { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %38)
  %coerce.dive22 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp20, i32 0, i32 0
  %coerce.dive23 = getelementptr inbounds %union.anon.1, ptr %coerce.dive22, i32 0, i32 0
  %39 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive23, i32 0, i32 0
  %40 = extractvalue { <2 x float>, <2 x float> } %call21, 0
  store <2 x float> %40, ptr %39, align 16
  %41 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive23, i32 0, i32 1
  %42 = extractvalue { <2 x float>, <2 x float> } %call21, 1
  store <2 x float> %42, ptr %41, align 8
  %43 = load ptr, ptr %sep.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %43, ptr align 16 %ref.tmp20, i64 16, i1 false)
  br label %if.end24

if.end24:                                         ; preds = %if.then19, %for.end
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end24, %if.then7
  %44 = load i1, ptr %retval, align 1
  ret i1 %44
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %rotation, ptr noundef nonnull align 16 dereferenceable(16) %v) #2 comdat {
entry:
  %retval = alloca %class.b3Vector3, align 16
  %rotation.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  %q = alloca %class.b3Quaternion, align 16
  %ref.tmp = alloca %class.b3Quaternion, align 16
  store ptr %rotation, ptr %rotation.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  %0 = load ptr, ptr %rotation.addr, align 8
  %1 = load ptr, ptr %v.addr, align 8
  %call = call { <2 x float>, <2 x float> } @_ZmlRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %0, ptr noundef nonnull align 16 dereferenceable(16) %1)
  %coerce.dive = getelementptr inbounds %class.b3Quaternion, ptr %q, i32 0, i32 0
  %coerce.dive1 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %union.anon.3, ptr %coerce.dive1, i32 0, i32 0
  %2 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive2, i32 0, i32 0
  %3 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %3, ptr %2, align 16
  %4 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive2, i32 0, i32 1
  %5 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %5, ptr %4, align 8
  %6 = load ptr, ptr %rotation.addr, align 8
  %call3 = call { <2 x float>, <2 x float> } @_ZNK12b3Quaternion7inverseEv(ptr noundef nonnull align 16 dereferenceable(16) %6)
  %coerce.dive4 = getelementptr inbounds %class.b3Quaternion, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive5 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive4, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %union.anon.3, ptr %coerce.dive5, i32 0, i32 0
  %7 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive6, i32 0, i32 0
  %8 = extractvalue { <2 x float>, <2 x float> } %call3, 0
  store <2 x float> %8, ptr %7, align 16
  %9 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive6, i32 0, i32 1
  %10 = extractvalue { <2 x float>, <2 x float> } %call3, 1
  store <2 x float> %10, ptr %9, align 8
  %call7 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN12b3QuaternionmLERKS_(ptr noundef nonnull align 16 dereferenceable(16) %q, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp)
  %call8 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getXEv(ptr noundef nonnull align 16 dereferenceable(16) %q)
  %11 = load float, ptr %call8, align 4
  %call9 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getYEv(ptr noundef nonnull align 16 dereferenceable(16) %q)
  %12 = load float, ptr %call9, align 4
  %call10 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getZEv(ptr noundef nonnull align 16 dereferenceable(16) %q)
  %13 = load float, ptr %call10, align 4
  %call11 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef %11, float noundef %12, float noundef %13)
  %coerce.dive12 = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive13 = getelementptr inbounds %union.anon.1, ptr %coerce.dive12, i32 0, i32 0
  %14 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive13, i32 0, i32 0
  %15 = extractvalue { <2 x float>, <2 x float> } %call11, 0
  store <2 x float> %15, ptr %14, align 16
  %16 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive13, i32 0, i32 1
  %17 = extractvalue { <2 x float>, <2 x float> } %call11, 1
  store <2 x float> %17, ptr %16, align 8
  %coerce.dive14 = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive15 = getelementptr inbounds %union.anon.1, ptr %coerce.dive14, i32 0, i32 0
  %18 = load { <2 x float>, <2 x float> }, ptr %coerce.dive15, align 16
  ret { <2 x float>, <2 x float> } %18
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %v1, ptr noundef nonnull align 16 dereferenceable(16) %v2) #0 comdat {
entry:
  %v1.addr = alloca ptr, align 8
  %v2.addr = alloca ptr, align 8
  store ptr %v1, ptr %v1.addr, align 8
  store ptr %v2, ptr %v2.addr, align 8
  %0 = load ptr, ptr %v1.addr, align 8
  %1 = load ptr, ptr %v2.addr, align 8
  %call = call noundef float @_ZNK9b3Vector33dotERKS_(ptr noundef nonnull align 16 dereferenceable(16) %0, ptr noundef nonnull align 16 dereferenceable(16) %1)
  ret float %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector3mLERKf(ptr noundef nonnull align 16 dereferenceable(16) %this, ptr noundef nonnull align 4 dereferenceable(4) %s) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load float, ptr %0, align 4
  %2 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x float], ptr %2, i64 0, i64 0
  %3 = load float, ptr %arrayidx, align 16
  %mul = fmul float %3, %1
  store float %mul, ptr %arrayidx, align 16
  %4 = load ptr, ptr %s.addr, align 8
  %5 = load float, ptr %4, align 4
  %6 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [4 x float], ptr %6, i64 0, i64 1
  %7 = load float, ptr %arrayidx2, align 4
  %mul3 = fmul float %7, %5
  store float %mul3, ptr %arrayidx2, align 4
  %8 = load ptr, ptr %s.addr, align 8
  %9 = load float, ptr %8, align 4
  %10 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [4 x float], ptr %10, i64 0, i64 2
  %11 = load float, ptr %arrayidx4, align 8
  %mul5 = fmul float %11, %9
  store float %mul5, ptr %arrayidx4, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_Z13b3TestSepAxisPK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_PS2_PS3_S9_Pf(ptr noundef %hullA, ptr noundef %hullB, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef %sep_axis, ptr noundef %verticesA, ptr noundef %verticesB, ptr noundef %depth) #0 comdat {
entry:
  %retval = alloca i1, align 1
  %hullA.addr = alloca ptr, align 8
  %hullB.addr = alloca ptr, align 8
  %posA.addr = alloca ptr, align 8
  %ornA.addr = alloca ptr, align 8
  %posB.addr = alloca ptr, align 8
  %ornB.addr = alloca ptr, align 8
  %sep_axis.addr = alloca ptr, align 8
  %verticesA.addr = alloca ptr, align 8
  %verticesB.addr = alloca ptr, align 8
  %depth.addr = alloca ptr, align 8
  %Min0 = alloca float, align 4
  %Max0 = alloca float, align 4
  %Min1 = alloca float, align 4
  %Max1 = alloca float, align 4
  %d0 = alloca float, align 4
  %d1 = alloca float, align 4
  store ptr %hullA, ptr %hullA.addr, align 8
  store ptr %hullB, ptr %hullB.addr, align 8
  store ptr %posA, ptr %posA.addr, align 8
  store ptr %ornA, ptr %ornA.addr, align 8
  store ptr %posB, ptr %posB.addr, align 8
  store ptr %ornB, ptr %ornB.addr, align 8
  store ptr %sep_axis, ptr %sep_axis.addr, align 8
  store ptr %verticesA, ptr %verticesA.addr, align 8
  store ptr %verticesB, ptr %verticesB.addr, align 8
  store ptr %depth, ptr %depth.addr, align 8
  %0 = load ptr, ptr %hullA.addr, align 8
  %1 = load ptr, ptr %posA.addr, align 8
  %2 = load ptr, ptr %ornA.addr, align 8
  %3 = load ptr, ptr %sep_axis.addr, align 8
  %4 = load ptr, ptr %verticesA.addr, align 8
  call void @_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_(ptr noundef %0, ptr noundef nonnull align 16 dereferenceable(16) %1, ptr noundef nonnull align 16 dereferenceable(16) %2, ptr noundef %3, ptr noundef %4, ptr noundef %Min0, ptr noundef %Max0)
  %5 = load ptr, ptr %hullB.addr, align 8
  %6 = load ptr, ptr %posB.addr, align 8
  %7 = load ptr, ptr %ornB.addr, align 8
  %8 = load ptr, ptr %sep_axis.addr, align 8
  %9 = load ptr, ptr %verticesB.addr, align 8
  call void @_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_(ptr noundef %5, ptr noundef nonnull align 16 dereferenceable(16) %6, ptr noundef nonnull align 16 dereferenceable(16) %7, ptr noundef %8, ptr noundef %9, ptr noundef %Min1, ptr noundef %Max1)
  %10 = load float, ptr %Max0, align 4
  %11 = load float, ptr %Min1, align 4
  %cmp = fcmp olt float %10, %11
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %12 = load float, ptr %Max1, align 4
  %13 = load float, ptr %Min0, align 4
  %cmp1 = fcmp olt float %12, %13
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %14 = load float, ptr %Max0, align 4
  %15 = load float, ptr %Min1, align 4
  %sub = fsub float %14, %15
  store float %sub, ptr %d0, align 4
  %16 = load float, ptr %Max1, align 4
  %17 = load float, ptr %Min0, align 4
  %sub2 = fsub float %16, %17
  store float %sub2, ptr %d1, align 4
  %18 = load float, ptr %d0, align 4
  %19 = load float, ptr %d1, align 4
  %cmp3 = fcmp olt float %18, %19
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %20 = load float, ptr %d0, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %21 = load float, ptr %d1, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %20, %cond.true ], [ %21, %cond.false ]
  %22 = load ptr, ptr %depth.addr, align 8
  store float %cond, ptr %22, align 4
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %23 = load i1, ptr %retval, align 1
  ret i1 %23
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %v) #2 comdat {
entry:
  %retval = alloca %class.b3Vector3, align 16
  %v.addr = alloca ptr, align 8
  store ptr %v, ptr %v.addr, align 8
  %0 = load ptr, ptr %v.addr, align 8
  %1 = getelementptr inbounds %class.b3Vector3, ptr %0, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x float], ptr %1, i64 0, i64 0
  %2 = load float, ptr %arrayidx, align 16
  %fneg = fneg float %2
  %3 = load ptr, ptr %v.addr, align 8
  %4 = getelementptr inbounds %class.b3Vector3, ptr %3, i32 0, i32 0
  %arrayidx1 = getelementptr inbounds [4 x float], ptr %4, i64 0, i64 1
  %5 = load float, ptr %arrayidx1, align 4
  %fneg2 = fneg float %5
  %6 = load ptr, ptr %v.addr, align 8
  %7 = getelementptr inbounds %class.b3Vector3, ptr %6, i32 0, i32 0
  %arrayidx3 = getelementptr inbounds [4 x float], ptr %7, i64 0, i64 2
  %8 = load float, ptr %arrayidx3, align 8
  %fneg4 = fneg float %8
  %call = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef %fneg, float noundef %fneg2, float noundef %fneg4)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive5 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %9 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive5, i32 0, i32 0
  %10 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %10, ptr %9, align 16
  %11 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive5, i32 0, i32 1
  %12 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %12, ptr %11, align 8
  %coerce.dive6 = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive7 = getelementptr inbounds %union.anon.1, ptr %coerce.dive6, i32 0, i32 0
  %13 = load { <2 x float>, <2 x float> }, ptr %coerce.dive7, align 16
  ret { <2 x float>, <2 x float> } %13
}

; Function Attrs: uwtable
define internal void @__cxx_global_var_init() #4 section ".text.startup" {
entry:
  %call = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0.000000e+00, float noundef -1.000000e+00, float noundef 0.000000e+00)
  %0 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %0, ptr @unitSphere162, align 16
  %1 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %1, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr @unitSphere162, i32 0, i32 1), align 8
  %call1 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FCA01D5C0000000, float noundef 0xBFEEF97240000000, float noundef 0x3FC2E52580000000)
  %2 = extractvalue { <2 x float>, <2 x float> } %call1, 0
  store <2 x float> %2, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 1), align 16
  %3 = extractvalue { <2 x float>, <2 x float> } %call1, 1
  store <2 x float> %3, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 1), i32 0, i32 1), align 8
  %call2 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFB3DE0D60000000, float noundef 0xBFEEF97240000000, float noundef 0x3FCE92BC20000000)
  %4 = extractvalue { <2 x float>, <2 x float> } %call2, 0
  store <2 x float> %4, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 2), align 16
  %5 = extractvalue { <2 x float>, <2 x float> } %call2, 1
  store <2 x float> %5, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 2), i32 0, i32 1), align 8
  %call3 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FE727C9E0000000, float noundef 0xBFDC9F40A0000000, float noundef 0x3FE0D2BD40000000)
  %6 = extractvalue { <2 x float>, <2 x float> } %call3, 0
  store <2 x float> %6, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 3), align 16
  %7 = extractvalue { <2 x float>, <2 x float> } %call3, 1
  store <2 x float> %7, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 3), i32 0, i32 1), align 8
  %call4 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FE38168C0000000, float noundef 0xBFE50A6540000000, float noundef 0x3FDC57C0C0000000)
  %8 = extractvalue { <2 x float>, <2 x float> } %call4, 0
  store <2 x float> %8, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 4), align 16
  %9 = extractvalue { <2 x float>, <2 x float> } %call4, 1
  store <2 x float> %9, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 4), i32 0, i32 1), align 8
  %call5 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FEA01E040000000, float noundef 0xBFE012D980000000, float noundef 0x3FD2E52DE0000000)
  %10 = extractvalue { <2 x float>, <2 x float> } %call5, 0
  store <2 x float> %10, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 5), align 16
  %11 = extractvalue { <2 x float>, <2 x float> } %call5, 1
  store <2 x float> %11, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 5), i32 0, i32 1), align 8
  %call6 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFD012CAE0000000, float noundef 0xBFEEF97020000000, float noundef 0.000000e+00)
  %12 = extractvalue { <2 x float>, <2 x float> } %call6, 0
  store <2 x float> %12, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 6), align 16
  %13 = extractvalue { <2 x float>, <2 x float> } %call6, 1
  store <2 x float> %13, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 6), i32 0, i32 1), align 8
  %call7 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFB3DE0D60000000, float noundef 0xBFEEF97240000000, float noundef 0xBFCE92BC20000000)
  %14 = extractvalue { <2 x float>, <2 x float> } %call7, 0
  store <2 x float> %14, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 7), align 16
  %15 = extractvalue { <2 x float>, <2 x float> } %call7, 1
  store <2 x float> %15, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 7), i32 0, i32 1), align 8
  %call8 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FCA01D5C0000000, float noundef 0xBFEEF97240000000, float noundef 0xBFC2E52580000000)
  %16 = extractvalue { <2 x float>, <2 x float> } %call8, 0
  store <2 x float> %16, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 8), align 16
  %17 = extractvalue { <2 x float>, <2 x float> } %call8, 1
  store <2 x float> %17, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 8), i32 0, i32 1), align 8
  %call9 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FEB8AD680000000, float noundef 0xBFD012DBA0000000, float noundef 0x3FDC57C920000000)
  %18 = extractvalue { <2 x float>, <2 x float> } %call9, 0
  store <2 x float> %18, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 9), align 16
  %19 = extractvalue { <2 x float>, <2 x float> } %call9, 1
  store <2 x float> %19, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 9), i32 0, i32 1), align 8
  %call10 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFD1B05740000000, float noundef 0xBFDC9F40A0000000, float noundef 0x3FEB388440000000)
  %20 = extractvalue { <2 x float>, <2 x float> } %call10, 0
  store <2 x float> %20, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 10), align 16
  %21 = extractvalue { <2 x float>, <2 x float> } %call10, 1
  store <2 x float> %21, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 10), i32 0, i32 1), align 8
  %call11 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBF9E59AFA0000000, float noundef 0xBFE012DBA0000000, float noundef 0x3FEBA76540000000)
  %22 = extractvalue { <2 x float>, <2 x float> } %call11, 0
  store <2 x float> %22, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 11), align 16
  %23 = extractvalue { <2 x float>, <2 x float> } %call11, 1
  store <2 x float> %23, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 11), i32 0, i32 1), align 8
  %call12 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFC3DE15C0000000, float noundef 0xBFD012DFE0000000, float noundef 0x3FEE92D120000000)
  %24 = extractvalue { <2 x float>, <2 x float> } %call12, 0
  store <2 x float> %24, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 12), align 16
  %25 = extractvalue { <2 x float>, <2 x float> } %call12, 1
  store <2 x float> %25, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 12), i32 0, i32 1), align 8
  %call13 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFEC9F2340000000, float noundef 0xBFDC9F2FE0000000, float noundef 0.000000e+00)
  %26 = extractvalue { <2 x float>, <2 x float> } %call13, 0
  store <2 x float> %26, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 13), align 16
  %27 = extractvalue { <2 x float>, <2 x float> } %call13, 1
  store <2 x float> %27, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 13), i32 0, i32 1), align 8
  %call14 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFEA97F840000000, float noundef 0xBFE012D560000000, float noundef 0x3FCE92BC20000000)
  %28 = extractvalue { <2 x float>, <2 x float> } %call14, 0
  store <2 x float> %28, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 14), align 16
  %29 = extractvalue { <2 x float>, <2 x float> } %call14, 1
  store <2 x float> %29, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 14), i32 0, i32 1), align 8
  %call15 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFEE9CAE20000000, float noundef 0xBFD012D340000000, float noundef 0x3FC2E52580000000)
  %30 = extractvalue { <2 x float>, <2 x float> } %call15, 0
  store <2 x float> %30, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 15), align 16
  %31 = extractvalue { <2 x float>, <2 x float> } %call15, 1
  store <2 x float> %31, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 15), i32 0, i32 1), align 8
  %call16 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFD1B05740000000, float noundef 0xBFDC9F40A0000000, float noundef 0xBFEB388440000000)
  %32 = extractvalue { <2 x float>, <2 x float> } %call16, 0
  store <2 x float> %32, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 16), align 16
  %33 = extractvalue { <2 x float>, <2 x float> } %call16, 1
  store <2 x float> %33, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 16), i32 0, i32 1), align 8
  %call17 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFDEF96180000000, float noundef 0xBFE012DBA0000000, float noundef 0xBFE6EE19C0000000)
  %34 = extractvalue { <2 x float>, <2 x float> } %call17, 0
  store <2 x float> %34, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 17), align 16
  %35 = extractvalue { <2 x float>, <2 x float> } %call17, 1
  store <2 x float> %35, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 17), i32 0, i32 1), align 8
  %call18 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFDBE789E0000000, float noundef 0xBFD012DFE0000000, float noundef 0xBFEBA76DA0000000)
  %36 = extractvalue { <2 x float>, <2 x float> } %call18, 0
  store <2 x float> %36, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 18), align 16
  %37 = extractvalue { <2 x float>, <2 x float> } %call18, 1
  store <2 x float> %37, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 18), i32 0, i32 1), align 8
  %call19 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FE727C9E0000000, float noundef 0xBFDC9F40A0000000, float noundef 0xBFE0D2BD40000000)
  %38 = extractvalue { <2 x float>, <2 x float> } %call19, 0
  store <2 x float> %38, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 19), align 16
  %39 = extractvalue { <2 x float>, <2 x float> } %call19, 1
  store <2 x float> %39, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 19), i32 0, i32 1), align 8
  %call20 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FE105A920000000, float noundef 0xBFE012DBA0000000, float noundef 0xBFE5D095A0000000)
  %40 = extractvalue { <2 x float>, <2 x float> } %call20, 0
  store <2 x float> %40, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 20), align 16
  %41 = extractvalue { <2 x float>, <2 x float> } %call20, 1
  store <2 x float> %41, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 20), i32 0, i32 1), align 8
  %call21 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FE5FD34E0000000, float noundef 0xBFD012DFE0000000, float noundef 0xBFE5D09C00000000)
  %42 = extractvalue { <2 x float>, <2 x float> } %call21, 0
  store <2 x float> %42, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 21), align 16
  %43 = extractvalue { <2 x float>, <2 x float> } %call21, 1
  store <2 x float> %43, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 21), i32 0, i32 1), align 8
  %call22 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FE5FD34E0000000, float noundef 0xBFD012DFE0000000, float noundef 0x3FE5D09C00000000)
  %44 = extractvalue { <2 x float>, <2 x float> } %call22, 0
  store <2 x float> %44, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 22), align 16
  %45 = extractvalue { <2 x float>, <2 x float> } %call22, 1
  store <2 x float> %45, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 22), i32 0, i32 1), align 8
  %call23 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFDBE789E0000000, float noundef 0xBFD012DFE0000000, float noundef 0x3FEBA76DA0000000)
  %46 = extractvalue { <2 x float>, <2 x float> } %call23, 0
  store <2 x float> %46, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 23), align 16
  %47 = extractvalue { <2 x float>, <2 x float> } %call23, 1
  store <2 x float> %47, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 23), i32 0, i32 1), align 8
  %call24 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFEE9CAE20000000, float noundef 0xBFD012D340000000, float noundef 0xBFC2E52580000000)
  %48 = extractvalue { <2 x float>, <2 x float> } %call24, 0
  store <2 x float> %48, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 24), align 16
  %49 = extractvalue { <2 x float>, <2 x float> } %call24, 1
  store <2 x float> %49, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 24), i32 0, i32 1), align 8
  %call25 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFC3DE15C0000000, float noundef 0xBFD012DFE0000000, float noundef 0xBFEE92D120000000)
  %50 = extractvalue { <2 x float>, <2 x float> } %call25, 0
  store <2 x float> %50, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 25), align 16
  %51 = extractvalue { <2 x float>, <2 x float> } %call25, 1
  store <2 x float> %51, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 25), i32 0, i32 1), align 8
  %call26 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FEB8AD680000000, float noundef 0xBFD012DBA0000000, float noundef 0xBFDC57C920000000)
  %52 = extractvalue { <2 x float>, <2 x float> } %call26, 0
  store <2 x float> %52, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 26), align 16
  %53 = extractvalue { <2 x float>, <2 x float> } %call26, 1
  store <2 x float> %53, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 26), i32 0, i32 1), align 8
  %call27 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FD1B05740000000, float noundef 0x3FDC9F40A0000000, float noundef 0x3FEB388440000000)
  %54 = extractvalue { <2 x float>, <2 x float> } %call27, 0
  store <2 x float> %54, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 27), align 16
  %55 = extractvalue { <2 x float>, <2 x float> } %call27, 1
  store <2 x float> %55, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 27), i32 0, i32 1), align 8
  %call28 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FDEF96180000000, float noundef 0x3FE012DBA0000000, float noundef 0x3FE6EE19C0000000)
  %56 = extractvalue { <2 x float>, <2 x float> } %call28, 0
  store <2 x float> %56, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 28), align 16
  %57 = extractvalue { <2 x float>, <2 x float> } %call28, 1
  store <2 x float> %57, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 28), i32 0, i32 1), align 8
  %call29 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FCDCD1C80000000, float noundef 0x3FE50A6540000000, float noundef 0x3FE6EE1580000000)
  %58 = extractvalue { <2 x float>, <2 x float> } %call29, 0
  store <2 x float> %58, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 29), align 16
  %59 = extractvalue { <2 x float>, <2 x float> } %call29, 1
  store <2 x float> %59, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 29), i32 0, i32 1), align 8
  %call30 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFE727C9E0000000, float noundef 0x3FDC9F40A0000000, float noundef 0x3FE0D2BD40000000)
  %60 = extractvalue { <2 x float>, <2 x float> } %call30, 0
  store <2 x float> %60, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 30), align 16
  %61 = extractvalue { <2 x float>, <2 x float> } %call30, 1
  store <2 x float> %61, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 30), i32 0, i32 1), align 8
  %call31 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFE105A920000000, float noundef 0x3FE012DBA0000000, float noundef 0x3FE5D095A0000000)
  %62 = extractvalue { <2 x float>, <2 x float> } %call31, 0
  store <2 x float> %62, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 31), align 16
  %63 = extractvalue { <2 x float>, <2 x float> } %call31, 1
  store <2 x float> %63, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 31), i32 0, i32 1), align 8
  %call32 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFE38168C0000000, float noundef 0x3FE50A6540000000, float noundef 0x3FDC57C0C0000000)
  %64 = extractvalue { <2 x float>, <2 x float> } %call32, 0
  store <2 x float> %64, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 32), align 16
  %65 = extractvalue { <2 x float>, <2 x float> } %call32, 1
  store <2 x float> %65, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 32), i32 0, i32 1), align 8
  %call33 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFE727C9E0000000, float noundef 0x3FDC9F40A0000000, float noundef 0xBFE0D2BD40000000)
  %66 = extractvalue { <2 x float>, <2 x float> } %call33, 0
  store <2 x float> %66, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 33), align 16
  %67 = extractvalue { <2 x float>, <2 x float> } %call33, 1
  store <2 x float> %67, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 33), i32 0, i32 1), align 8
  %call34 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFEA01E040000000, float noundef 0x3FE012D980000000, float noundef 0xBFD2E52DE0000000)
  %68 = extractvalue { <2 x float>, <2 x float> } %call34, 0
  store <2 x float> %68, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 34), align 16
  %69 = extractvalue { <2 x float>, <2 x float> } %call34, 1
  store <2 x float> %69, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 34), i32 0, i32 1), align 8
  %call35 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFE38168C0000000, float noundef 0x3FE50A6540000000, float noundef 0xBFDC57C0C0000000)
  %70 = extractvalue { <2 x float>, <2 x float> } %call35, 0
  store <2 x float> %70, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 35), align 16
  %71 = extractvalue { <2 x float>, <2 x float> } %call35, 1
  store <2 x float> %71, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 35), i32 0, i32 1), align 8
  %call36 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FD1B05740000000, float noundef 0x3FDC9F40A0000000, float noundef 0xBFEB388440000000)
  %72 = extractvalue { <2 x float>, <2 x float> } %call36, 0
  store <2 x float> %72, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 36), align 16
  %73 = extractvalue { <2 x float>, <2 x float> } %call36, 1
  store <2 x float> %73, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 36), i32 0, i32 1), align 8
  %call37 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3F9E59AFA0000000, float noundef 0x3FE012DBA0000000, float noundef 0xBFEBA76540000000)
  %74 = extractvalue { <2 x float>, <2 x float> } %call37, 0
  store <2 x float> %74, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 37), align 16
  %75 = extractvalue { <2 x float>, <2 x float> } %call37, 1
  store <2 x float> %75, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 37), i32 0, i32 1), align 8
  %call38 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FCDCD1C80000000, float noundef 0x3FE50A6540000000, float noundef 0xBFE6EE1580000000)
  %76 = extractvalue { <2 x float>, <2 x float> } %call38, 0
  store <2 x float> %76, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 38), align 16
  %77 = extractvalue { <2 x float>, <2 x float> } %call38, 1
  store <2 x float> %77, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 38), i32 0, i32 1), align 8
  %call39 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FEC9F2340000000, float noundef 0x3FDC9F2FE0000000, float noundef 0.000000e+00)
  %78 = extractvalue { <2 x float>, <2 x float> } %call39, 0
  store <2 x float> %78, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 39), align 16
  %79 = extractvalue { <2 x float>, <2 x float> } %call39, 1
  store <2 x float> %79, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 39), i32 0, i32 1), align 8
  %call40 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FEA97F840000000, float noundef 0x3FE012D560000000, float noundef 0xBFCE92BC20000000)
  %80 = extractvalue { <2 x float>, <2 x float> } %call40, 0
  store <2 x float> %80, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 40), align 16
  %81 = extractvalue { <2 x float>, <2 x float> } %call40, 1
  store <2 x float> %81, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 40), i32 0, i32 1), align 8
  %call41 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FE81C3260000000, float noundef 0x3FE50A5CE0000000, float noundef 0.000000e+00)
  %82 = extractvalue { <2 x float>, <2 x float> } %call41, 0
  store <2 x float> %82, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 41), align 16
  %83 = extractvalue { <2 x float>, <2 x float> } %call41, 1
  store <2 x float> %83, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 41), i32 0, i32 1), align 8
  %call42 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFCDCD1C80000000, float noundef 0xBFE50A6540000000, float noundef 0x3FE6EE1580000000)
  %84 = extractvalue { <2 x float>, <2 x float> } %call42, 0
  store <2 x float> %84, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 42), align 16
  %85 = extractvalue { <2 x float>, <2 x float> } %call42, 1
  store <2 x float> %85, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 42), i32 0, i32 1), align 8
  %call43 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFC4CB5BC0000000, float noundef 0xBFEB388EC0000000, float noundef 0x3FDFFFEB00000000)
  %86 = extractvalue { <2 x float>, <2 x float> } %call43, 0
  store <2 x float> %86, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 43), align 16
  %87 = extractvalue { <2 x float>, <2 x float> } %call43, 1
  store <2 x float> %87, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 43), i32 0, i32 1), align 8
  %call44 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FAB074A80000000, float noundef 0xBFE727D460000000, float noundef 0x3FE6059C80000000)
  %88 = extractvalue { <2 x float>, <2 x float> } %call44, 0
  store <2 x float> %88, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 44), align 16
  %89 = extractvalue { <2 x float>, <2 x float> } %call44, 1
  store <2 x float> %89, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 44), i32 0, i32 1), align 8
  %call45 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FC1B08140000000, float noundef 0xBFEC9F29A0000000, float noundef 0x3FDB3875A0000000)
  %90 = extractvalue { <2 x float>, <2 x float> } %call45, 0
  store <2 x float> %90, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 45), align 16
  %91 = extractvalue { <2 x float>, <2 x float> } %call45, 1
  store <2 x float> %91, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 45), i32 0, i32 1), align 8
  %call46 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FD0D2D880000000, float noundef 0xBFE0D2D880000000, float noundef 0x3FE9E36D20000000)
  %92 = extractvalue { <2 x float>, <2 x float> } %call46, 0
  store <2 x float> %92, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 46), align 16
  %93 = extractvalue { <2 x float>, <2 x float> } %call46, 1
  store <2 x float> %93, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 46), i32 0, i32 1), align 8
  %call47 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FD727D020000000, float noundef 0xBFE727D240000000, float noundef 0x3FE2CF15E0000000)
  %94 = extractvalue { <2 x float>, <2 x float> } %call47, 0
  store <2 x float> %94, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 47), align 16
  %95 = extractvalue { <2 x float>, <2 x float> } %call47, 1
  store <2 x float> %95, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 47), i32 0, i32 1), align 8
  %call48 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FE105A920000000, float noundef 0xBFE012DBA0000000, float noundef 0x3FE5D095A0000000)
  %96 = extractvalue { <2 x float>, <2 x float> } %call48, 0
  store <2 x float> %96, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 48), align 16
  %97 = extractvalue { <2 x float>, <2 x float> } %call48, 1
  store <2 x float> %97, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 48), i32 0, i32 1), align 8
  %call49 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FDB387E00000000, float noundef 0xBFEB388EC0000000, float noundef 0x3FD3C6D620000000)
  %98 = extractvalue { <2 x float>, <2 x float> } %call49, 0
  store <2 x float> %98, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 49), align 16
  %99 = extractvalue { <2 x float>, <2 x float> } %call49, 1
  store <2 x float> %99, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 49), i32 0, i32 1), align 8
  %call50 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FEA01E040000000, float noundef 0xBFE012D980000000, float noundef 0xBFD2E52DE0000000)
  %100 = extractvalue { <2 x float>, <2 x float> } %call50, 0
  store <2 x float> %100, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 50), align 16
  %101 = extractvalue { <2 x float>, <2 x float> } %call50, 1
  store <2 x float> %101, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 50), i32 0, i32 1), align 8
  %call51 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FE38168C0000000, float noundef 0xBFE50A6540000000, float noundef 0xBFDC57C0C0000000)
  %102 = extractvalue { <2 x float>, <2 x float> } %call51, 0
  store <2 x float> %102, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 51), align 16
  %103 = extractvalue { <2 x float>, <2 x float> } %call51, 1
  store <2 x float> %103, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 51), i32 0, i32 1), align 8
  %call52 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FEB388220000000, float noundef 0xBFE0D2D440000000, float noundef 0.000000e+00)
  %104 = extractvalue { <2 x float>, <2 x float> } %call52, 0
  store <2 x float> %104, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 52), align 16
  %105 = extractvalue { <2 x float>, <2 x float> } %call52, 1
  store <2 x float> %105, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 52), i32 0, i32 1), align 8
  %call53 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FE5775540000000, float noundef 0xBFE727D240000000, float noundef 0xBFC4CB6420000000)
  %106 = extractvalue { <2 x float>, <2 x float> } %call53, 0
  store <2 x float> %106, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 53), align 16
  %107 = extractvalue { <2 x float>, <2 x float> } %call53, 1
  store <2 x float> %107, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 53), i32 0, i32 1), align 8
  %call54 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FE5775540000000, float noundef 0xBFE727D020000000, float noundef 0x3FC4CB6C80000000)
  %108 = extractvalue { <2 x float>, <2 x float> } %call54, 0
  store <2 x float> %108, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 54), align 16
  %109 = extractvalue { <2 x float>, <2 x float> } %call54, 1
  store <2 x float> %109, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 54), i32 0, i32 1), align 8
  %call55 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FDB387E00000000, float noundef 0xBFEB388EC0000000, float noundef 0xBFD3C6D620000000)
  %110 = extractvalue { <2 x float>, <2 x float> } %call55, 0
  store <2 x float> %110, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 55), align 16
  %111 = extractvalue { <2 x float>, <2 x float> } %call55, 1
  store <2 x float> %111, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 55), i32 0, i32 1), align 8
  %call56 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FDC9F1AE0000000, float noundef 0xBFEC9F2780000000, float noundef 0x3EB0C6F7A0000000)
  %112 = extractvalue { <2 x float>, <2 x float> } %call56, 0
  store <2 x float> %112, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 56), align 16
  %113 = extractvalue { <2 x float>, <2 x float> } %call56, 1
  store <2 x float> %113, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 56), i32 0, i32 1), align 8
  %call57 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFE81C3260000000, float noundef 0xBFE50A5CE0000000, float noundef 0.000000e+00)
  %114 = extractvalue { <2 x float>, <2 x float> } %call57, 0
  store <2 x float> %114, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 57), align 16
  %115 = extractvalue { <2 x float>, <2 x float> } %call57, 1
  store <2 x float> %115, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 57), i32 0, i32 1), align 8
  %call58 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFE0D2C7C0000000, float noundef 0xBFEB388A80000000, float noundef 0.000000e+00)
  %116 = extractvalue { <2 x float>, <2 x float> } %call58, 0
  store <2 x float> %116, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 58), align 16
  %117 = extractvalue { <2 x float>, <2 x float> } %call58, 1
  store <2 x float> %117, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 58), i32 0, i32 1), align 8
  %call59 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFE46C17E0000000, float noundef 0xBFE727CE00000000, float noundef 0x3FD0D2C380000000)
  %118 = extractvalue { <2 x float>, <2 x float> } %call59, 0
  store <2 x float> %118, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 59), align 16
  %119 = extractvalue { <2 x float>, <2 x float> } %call59, 1
  store <2 x float> %119, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 59), i32 0, i32 1), align 8
  %call60 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFD727BF60000000, float noundef 0xBFEC9F2780000000, float noundef 0x3FD0D2C380000000)
  %120 = extractvalue { <2 x float>, <2 x float> } %call60, 0
  store <2 x float> %120, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 60), align 16
  %121 = extractvalue { <2 x float>, <2 x float> } %call60, 1
  store <2 x float> %121, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 60), i32 0, i32 1), align 8
  %call61 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFE605A500000000, float noundef 0xBFE0D2D440000000, float noundef 0x3FDFFFF360000000)
  %122 = extractvalue { <2 x float>, <2 x float> } %call61, 0
  store <2 x float> %122, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 61), align 16
  %123 = extractvalue { <2 x float>, <2 x float> } %call61, 1
  store <2 x float> %123, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 61), i32 0, i32 1), align 8
  %call62 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFDC9F1AE0000000, float noundef 0xBFE727D020000000, float noundef 0x3FE0D2C5A0000000)
  %124 = extractvalue { <2 x float>, <2 x float> } %call62, 0
  store <2 x float> %124, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 62), align 16
  %125 = extractvalue { <2 x float>, <2 x float> } %call62, 1
  store <2 x float> %125, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 62), i32 0, i32 1), align 8
  %call63 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFDEF96180000000, float noundef 0xBFE012DBA0000000, float noundef 0x3FE6EE19C0000000)
  %126 = extractvalue { <2 x float>, <2 x float> } %call63, 0
  store <2 x float> %126, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 63), align 16
  %127 = extractvalue { <2 x float>, <2 x float> } %call63, 1
  store <2 x float> %127, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 63), i32 0, i32 1), align 8
  %call64 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFCDCD1C80000000, float noundef 0xBFE50A6540000000, float noundef 0xBFE6EE1580000000)
  %128 = extractvalue { <2 x float>, <2 x float> } %call64, 0
  store <2 x float> %128, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 64), align 16
  %129 = extractvalue { <2 x float>, <2 x float> } %call64, 1
  store <2 x float> %129, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 64), i32 0, i32 1), align 8
  %call65 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFC4CB5BC0000000, float noundef 0xBFEB388EC0000000, float noundef 0xBFDFFFEB00000000)
  %130 = extractvalue { <2 x float>, <2 x float> } %call65, 0
  store <2 x float> %130, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 65), align 16
  %131 = extractvalue { <2 x float>, <2 x float> } %call65, 1
  store <2 x float> %131, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 65), i32 0, i32 1), align 8
  %call66 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFDC9F1AE0000000, float noundef 0xBFE727D240000000, float noundef 0xBFE0D2C160000000)
  %132 = extractvalue { <2 x float>, <2 x float> } %call66, 0
  store <2 x float> %132, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 66), align 16
  %133 = extractvalue { <2 x float>, <2 x float> } %call66, 1
  store <2 x float> %133, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 66), i32 0, i32 1), align 8
  %call67 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFD727BF60000000, float noundef 0xBFEC9F29A0000000, float noundef 0xBFD0D2BF60000000)
  %134 = extractvalue { <2 x float>, <2 x float> } %call67, 0
  store <2 x float> %134, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 67), align 16
  %135 = extractvalue { <2 x float>, <2 x float> } %call67, 1
  store <2 x float> %135, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 67), i32 0, i32 1), align 8
  %call68 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFE605A500000000, float noundef 0xBFE0D2D440000000, float noundef 0xBFDFFFF360000000)
  %136 = extractvalue { <2 x float>, <2 x float> } %call68, 0
  store <2 x float> %136, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 68), align 16
  %137 = extractvalue { <2 x float>, <2 x float> } %call68, 1
  store <2 x float> %137, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 68), i32 0, i32 1), align 8
  %call69 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFE46C17E0000000, float noundef 0xBFE727CE00000000, float noundef 0xBFD0D2BF60000000)
  %138 = extractvalue { <2 x float>, <2 x float> } %call69, 0
  store <2 x float> %138, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 69), align 16
  %139 = extractvalue { <2 x float>, <2 x float> } %call69, 1
  store <2 x float> %139, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 69), i32 0, i32 1), align 8
  %call70 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFEA97F840000000, float noundef 0xBFE012D560000000, float noundef 0xBFCE92BC20000000)
  %140 = extractvalue { <2 x float>, <2 x float> } %call70, 0
  store <2 x float> %140, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 70), align 16
  %141 = extractvalue { <2 x float>, <2 x float> } %call70, 1
  store <2 x float> %141, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 70), i32 0, i32 1), align 8
  %call71 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FD727CC00000000, float noundef 0xBFE727D460000000, float noundef 0xBFE2CF15E0000000)
  %142 = extractvalue { <2 x float>, <2 x float> } %call71, 0
  store <2 x float> %142, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 71), align 16
  %143 = extractvalue { <2 x float>, <2 x float> } %call71, 1
  store <2 x float> %143, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 71), i32 0, i32 1), align 8
  %call72 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FC1B07080000000, float noundef 0xBFEC9F29A0000000, float noundef 0xBFDB3875A0000000)
  %144 = extractvalue { <2 x float>, <2 x float> } %call72, 0
  store <2 x float> %144, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 72), align 16
  %145 = extractvalue { <2 x float>, <2 x float> } %call72, 1
  store <2 x float> %145, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 72), i32 0, i32 1), align 8
  %call73 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FD0D2D880000000, float noundef 0xBFE0D2D880000000, float noundef 0xBFE9E36D20000000)
  %146 = extractvalue { <2 x float>, <2 x float> } %call73, 0
  store <2 x float> %146, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 73), align 16
  %147 = extractvalue { <2 x float>, <2 x float> } %call73, 1
  store <2 x float> %147, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 73), i32 0, i32 1), align 8
  %call74 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FAB0728E0000000, float noundef 0xBFE727D240000000, float noundef 0xBFE6059EA0000000)
  %148 = extractvalue { <2 x float>, <2 x float> } %call74, 0
  store <2 x float> %148, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 74), align 16
  %149 = extractvalue { <2 x float>, <2 x float> } %call74, 1
  store <2 x float> %149, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 74), i32 0, i32 1), align 8
  %call75 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBF9E59AFA0000000, float noundef 0xBFE012DBA0000000, float noundef 0xBFEBA76540000000)
  %150 = extractvalue { <2 x float>, <2 x float> } %call75, 0
  store <2 x float> %150, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 75), align 16
  %151 = extractvalue { <2 x float>, <2 x float> } %call75, 1
  store <2 x float> %151, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 75), i32 0, i32 1), align 8
  %call76 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FEE9CAE20000000, float noundef 0x3FD012D340000000, float noundef 0x3FC2E52580000000)
  %152 = extractvalue { <2 x float>, <2 x float> } %call76, 0
  store <2 x float> %152, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 76), align 16
  %153 = extractvalue { <2 x float>, <2 x float> } %call76, 1
  store <2 x float> %153, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 76), i32 0, i32 1), align 8
  %call77 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FEE9CAE20000000, float noundef 0x3FD012D340000000, float noundef 0xBFC2E52580000000)
  %154 = extractvalue { <2 x float>, <2 x float> } %call77, 0
  store <2 x float> %154, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 77), align 16
  %155 = extractvalue { <2 x float>, <2 x float> } %call77, 1
  store <2 x float> %155, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 77), i32 0, i32 1), align 8
  %call78 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FEE6F1120000000, float noundef -0.000000e+00, float noundef 0x3FD3C6DE80000000)
  %156 = extractvalue { <2 x float>, <2 x float> } %call78, 0
  store <2 x float> %156, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 78), align 16
  %157 = extractvalue { <2 x float>, <2 x float> } %call78, 1
  store <2 x float> %157, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 78), i32 0, i32 1), align 8
  %call79 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 1.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %158 = extractvalue { <2 x float>, <2 x float> } %call79, 0
  store <2 x float> %158, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 79), align 16
  %159 = extractvalue { <2 x float>, <2 x float> } %call79, 1
  store <2 x float> %159, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 79), i32 0, i32 1), align 8
  %call80 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FEE4F91A0000000, float noundef 0xBFD1B078E0000000, float noundef 0x3FC4CB6C80000000)
  %160 = extractvalue { <2 x float>, <2 x float> } %call80, 0
  store <2 x float> %160, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 80), align 16
  %161 = extractvalue { <2 x float>, <2 x float> } %call80, 1
  store <2 x float> %161, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 80), i32 0, i32 1), align 8
  %call81 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FEE6F1120000000, float noundef 0.000000e+00, float noundef 0xBFD3C6DE80000000)
  %162 = extractvalue { <2 x float>, <2 x float> } %call81, 0
  store <2 x float> %162, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 81), align 16
  %163 = extractvalue { <2 x float>, <2 x float> } %call81, 1
  store <2 x float> %163, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 81), i32 0, i32 1), align 8
  %call82 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FEE4F91A0000000, float noundef 0xBFD1B078E0000000, float noundef 0xBFC4CB6C80000000)
  %164 = extractvalue { <2 x float>, <2 x float> } %call82, 0
  store <2 x float> %164, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 82), align 16
  %165 = extractvalue { <2 x float>, <2 x float> } %call82, 1
  store <2 x float> %165, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 82), i32 0, i32 1), align 8
  %call83 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FC3DE15C0000000, float noundef 0x3FD012DFE0000000, float noundef 0x3FEE92D120000000)
  %166 = extractvalue { <2 x float>, <2 x float> } %call83, 0
  store <2 x float> %166, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 83), align 16
  %167 = extractvalue { <2 x float>, <2 x float> } %call83, 1
  store <2 x float> %167, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 83), i32 0, i32 1), align 8
  %call84 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FDBE789E0000000, float noundef 0x3FD012DFE0000000, float noundef 0x3FEBA76DA0000000)
  %168 = extractvalue { <2 x float>, <2 x float> } %call84, 0
  store <2 x float> %168, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 84), align 16
  %169 = extractvalue { <2 x float>, <2 x float> } %call84, 1
  store <2 x float> %169, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 84), i32 0, i32 1), align 8
  %call85 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef -0.000000e+00, float noundef -0.000000e+00, float noundef 1.000000e+00)
  %170 = extractvalue { <2 x float>, <2 x float> } %call85, 0
  store <2 x float> %170, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 85), align 16
  %171 = extractvalue { <2 x float>, <2 x float> } %call85, 1
  store <2 x float> %171, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 85), i32 0, i32 1), align 8
  %call86 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FD3C6EF40000000, float noundef 0.000000e+00, float noundef 0x3FEE6F0D00000000)
  %172 = extractvalue { <2 x float>, <2 x float> } %call86, 0
  store <2 x float> %172, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 86), align 16
  %173 = extractvalue { <2 x float>, <2 x float> } %call86, 1
  store <2 x float> %173, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 86), i32 0, i32 1), align 8
  %call87 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FC1B08140000000, float noundef 0xBFD1B08140000000, float noundef 0x3FEE6F0AE0000000)
  %174 = extractvalue { <2 x float>, <2 x float> } %call87, 0
  store <2 x float> %174, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 87), align 16
  %175 = extractvalue { <2 x float>, <2 x float> } %call87, 1
  store <2 x float> %175, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 87), i32 0, i32 1), align 8
  %call88 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FE2CF24A0000000, float noundef 0.000000e+00, float noundef 0x3FE9E377A0000000)
  %176 = extractvalue { <2 x float>, <2 x float> } %call88, 0
  store <2 x float> %176, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 88), align 16
  %177 = extractvalue { <2 x float>, <2 x float> } %call88, 1
  store <2 x float> %177, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 88), i32 0, i32 1), align 8
  %call89 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FDC9F2FE0000000, float noundef 0xBFD1B08140000000, float noundef 0x3FEB388220000000)
  %178 = extractvalue { <2 x float>, <2 x float> } %call89, 0
  store <2 x float> %178, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 89), align 16
  %179 = extractvalue { <2 x float>, <2 x float> } %call89, 1
  store <2 x float> %179, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 89), i32 0, i32 1), align 8
  %call90 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFEB8AD680000000, float noundef 0x3FD012DBA0000000, float noundef 0x3FDC57C920000000)
  %180 = extractvalue { <2 x float>, <2 x float> } %call90, 0
  store <2 x float> %180, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 90), align 16
  %181 = extractvalue { <2 x float>, <2 x float> } %call90, 1
  store <2 x float> %181, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 90), i32 0, i32 1), align 8
  %call91 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFE5FD34E0000000, float noundef 0x3FD012DFE0000000, float noundef 0x3FE5D09C00000000)
  %182 = extractvalue { <2 x float>, <2 x float> } %call91, 0
  store <2 x float> %182, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 91), align 16
  %183 = extractvalue { <2 x float>, <2 x float> } %call91, 1
  store <2 x float> %183, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 91), i32 0, i32 1), align 8
  %call92 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFEE6F1120000000, float noundef -0.000000e+00, float noundef 0x3FD3C6DE80000000)
  %184 = extractvalue { <2 x float>, <2 x float> } %call92, 0
  store <2 x float> %184, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 92), align 16
  %185 = extractvalue { <2 x float>, <2 x float> } %call92, 1
  store <2 x float> %185, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 92), i32 0, i32 1), align 8
  %call93 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFE9E379C0000000, float noundef 0.000000e+00, float noundef 0x3FE2CF1E40000000)
  %186 = extractvalue { <2 x float>, <2 x float> } %call93, 0
  store <2 x float> %186, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 93), align 16
  %187 = extractvalue { <2 x float>, <2 x float> } %call93, 1
  store <2 x float> %187, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 93), i32 0, i32 1), align 8
  %call94 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFEB93E3E0000000, float noundef 0xBFD1B078E0000000, float noundef 0x3FDB388220000000)
  %188 = extractvalue { <2 x float>, <2 x float> } %call94, 0
  store <2 x float> %188, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 94), align 16
  %189 = extractvalue { <2 x float>, <2 x float> } %call94, 1
  store <2 x float> %189, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 94), i32 0, i32 1), align 8
  %call95 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFE2CF24A0000000, float noundef 0.000000e+00, float noundef 0x3FE9E377A0000000)
  %190 = extractvalue { <2 x float>, <2 x float> } %call95, 0
  store <2 x float> %190, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 95), align 16
  %191 = extractvalue { <2 x float>, <2 x float> } %call95, 1
  store <2 x float> %191, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 95), i32 0, i32 1), align 8
  %call96 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFE5775960000000, float noundef 0xBFD1B07D00000000, float noundef 0x3FE605A920000000)
  %192 = extractvalue { <2 x float>, <2 x float> } %call96, 0
  store <2 x float> %192, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 96), align 16
  %193 = extractvalue { <2 x float>, <2 x float> } %call96, 1
  store <2 x float> %193, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 96), i32 0, i32 1), align 8
  %call97 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFE5FD34E0000000, float noundef 0x3FD012DFE0000000, float noundef 0xBFE5D09C00000000)
  %194 = extractvalue { <2 x float>, <2 x float> } %call97, 0
  store <2 x float> %194, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 97), align 16
  %195 = extractvalue { <2 x float>, <2 x float> } %call97, 1
  store <2 x float> %195, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 97), i32 0, i32 1), align 8
  %call98 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFEB8AD680000000, float noundef 0x3FD012DBA0000000, float noundef 0xBFDC57C920000000)
  %196 = extractvalue { <2 x float>, <2 x float> } %call98, 0
  store <2 x float> %196, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 98), align 16
  %197 = extractvalue { <2 x float>, <2 x float> } %call98, 1
  store <2 x float> %197, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 98), i32 0, i32 1), align 8
  %call99 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFE2CF24A0000000, float noundef -0.000000e+00, float noundef 0xBFE9E377A0000000)
  %198 = extractvalue { <2 x float>, <2 x float> } %call99, 0
  store <2 x float> %198, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 99), align 16
  %199 = extractvalue { <2 x float>, <2 x float> } %call99, 1
  store <2 x float> %199, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 99), i32 0, i32 1), align 8
  %call100 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFE9E379C0000000, float noundef -0.000000e+00, float noundef 0xBFE2CF1E40000000)
  %200 = extractvalue { <2 x float>, <2 x float> } %call100, 0
  store <2 x float> %200, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 100), align 16
  %201 = extractvalue { <2 x float>, <2 x float> } %call100, 1
  store <2 x float> %201, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 100), i32 0, i32 1), align 8
  %call101 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFE5775960000000, float noundef 0xBFD1B07D00000000, float noundef 0xBFE605A920000000)
  %202 = extractvalue { <2 x float>, <2 x float> } %call101, 0
  store <2 x float> %202, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 101), align 16
  %203 = extractvalue { <2 x float>, <2 x float> } %call101, 1
  store <2 x float> %203, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 101), i32 0, i32 1), align 8
  %call102 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFEE6F1120000000, float noundef 0.000000e+00, float noundef 0xBFD3C6DE80000000)
  %204 = extractvalue { <2 x float>, <2 x float> } %call102, 0
  store <2 x float> %204, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 102), align 16
  %205 = extractvalue { <2 x float>, <2 x float> } %call102, 1
  store <2 x float> %205, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 102), i32 0, i32 1), align 8
  %call103 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFEB93E3E0000000, float noundef 0xBFD1B078E0000000, float noundef 0xBFDB388220000000)
  %206 = extractvalue { <2 x float>, <2 x float> } %call103, 0
  store <2 x float> %206, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 103), align 16
  %207 = extractvalue { <2 x float>, <2 x float> } %call103, 1
  store <2 x float> %207, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 103), i32 0, i32 1), align 8
  %call104 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FDBE789E0000000, float noundef 0x3FD012DFE0000000, float noundef 0xBFEBA76DA0000000)
  %208 = extractvalue { <2 x float>, <2 x float> } %call104, 0
  store <2 x float> %208, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 104), align 16
  %209 = extractvalue { <2 x float>, <2 x float> } %call104, 1
  store <2 x float> %209, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 104), i32 0, i32 1), align 8
  %call105 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FC3DE15C0000000, float noundef 0x3FD012DFE0000000, float noundef 0xBFEE92D120000000)
  %210 = extractvalue { <2 x float>, <2 x float> } %call105, 0
  store <2 x float> %210, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 105), align 16
  %211 = extractvalue { <2 x float>, <2 x float> } %call105, 1
  store <2 x float> %211, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 105), i32 0, i32 1), align 8
  %call106 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FE2CF24A0000000, float noundef -0.000000e+00, float noundef 0xBFE9E377A0000000)
  %212 = extractvalue { <2 x float>, <2 x float> } %call106, 0
  store <2 x float> %212, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 106), align 16
  %213 = extractvalue { <2 x float>, <2 x float> } %call106, 1
  store <2 x float> %213, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 106), i32 0, i32 1), align 8
  %call107 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FD3C6EF40000000, float noundef -0.000000e+00, float noundef 0xBFEE6F0D00000000)
  %214 = extractvalue { <2 x float>, <2 x float> } %call107, 0
  store <2 x float> %214, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 107), align 16
  %215 = extractvalue { <2 x float>, <2 x float> } %call107, 1
  store <2 x float> %215, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 107), i32 0, i32 1), align 8
  %call108 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FDC9F2FE0000000, float noundef 0xBFD1B08140000000, float noundef 0xBFEB388220000000)
  %216 = extractvalue { <2 x float>, <2 x float> } %call108, 0
  store <2 x float> %216, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 108), align 16
  %217 = extractvalue { <2 x float>, <2 x float> } %call108, 1
  store <2 x float> %217, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 108), i32 0, i32 1), align 8
  %call109 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef -1.000000e+00)
  %218 = extractvalue { <2 x float>, <2 x float> } %call109, 0
  store <2 x float> %218, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 109), align 16
  %219 = extractvalue { <2 x float>, <2 x float> } %call109, 1
  store <2 x float> %219, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 109), i32 0, i32 1), align 8
  %call110 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FC1B08140000000, float noundef 0xBFD1B08140000000, float noundef 0xBFEE6F0AE0000000)
  %220 = extractvalue { <2 x float>, <2 x float> } %call110, 0
  store <2 x float> %220, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 110), align 16
  %221 = extractvalue { <2 x float>, <2 x float> } %call110, 1
  store <2 x float> %221, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 110), i32 0, i32 1), align 8
  %call111 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FE5775B80000000, float noundef 0x3FD1B078E0000000, float noundef 0x3FE605A700000000)
  %222 = extractvalue { <2 x float>, <2 x float> } %call111, 0
  store <2 x float> %222, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 111), align 16
  %223 = extractvalue { <2 x float>, <2 x float> } %call111, 1
  store <2 x float> %223, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 111), i32 0, i32 1), align 8
  %call112 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FE9E37BE0000000, float noundef 0xBEC0C6F7A0000000, float noundef 0x3FE2CF1E40000000)
  %224 = extractvalue { <2 x float>, <2 x float> } %call112, 0
  store <2 x float> %224, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 112), align 16
  %225 = extractvalue { <2 x float>, <2 x float> } %call112, 1
  store <2 x float> %225, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 112), i32 0, i32 1), align 8
  %call113 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FE605A500000000, float noundef 0x3FE0D2D440000000, float noundef 0x3FDFFFF360000000)
  %226 = extractvalue { <2 x float>, <2 x float> } %call113, 0
  store <2 x float> %226, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 113), align 16
  %227 = extractvalue { <2 x float>, <2 x float> } %call113, 1
  store <2 x float> %227, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 113), i32 0, i32 1), align 8
  %call114 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FEB93E600000000, float noundef 0x3FD1B07080000000, float noundef 0x3FDB387E00000000)
  %228 = extractvalue { <2 x float>, <2 x float> } %call114, 0
  store <2 x float> %228, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 114), align 16
  %229 = extractvalue { <2 x float>, <2 x float> } %call114, 1
  store <2 x float> %229, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 114), i32 0, i32 1), align 8
  %call115 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FEA97F840000000, float noundef 0x3FE012D560000000, float noundef 0x3FCE92BC20000000)
  %230 = extractvalue { <2 x float>, <2 x float> } %call115, 0
  store <2 x float> %230, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 115), align 16
  %231 = extractvalue { <2 x float>, <2 x float> } %call115, 1
  store <2 x float> %231, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 115), i32 0, i32 1), align 8
  %call116 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFDC9F2FE0000000, float noundef 0x3FD1B07D00000000, float noundef 0x3FEB388440000000)
  %232 = extractvalue { <2 x float>, <2 x float> } %call116, 0
  store <2 x float> %232, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 116), align 16
  %233 = extractvalue { <2 x float>, <2 x float> } %call116, 1
  store <2 x float> %233, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 116), i32 0, i32 1), align 8
  %call117 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFD3C6EF40000000, float noundef 0xBEB0C6F7A0000000, float noundef 0x3FEE6F0D00000000)
  %234 = extractvalue { <2 x float>, <2 x float> } %call117, 0
  store <2 x float> %234, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 117), align 16
  %235 = extractvalue { <2 x float>, <2 x float> } %call117, 1
  store <2 x float> %235, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 117), i32 0, i32 1), align 8
  %call118 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFD0D2D880000000, float noundef 0x3FE0D2D880000000, float noundef 0x3FE9E36D20000000)
  %236 = extractvalue { <2 x float>, <2 x float> } %call118, 0
  store <2 x float> %236, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 118), align 16
  %237 = extractvalue { <2 x float>, <2 x float> } %call118, 1
  store <2 x float> %237, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 118), i32 0, i32 1), align 8
  %call119 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFC1B08140000000, float noundef 0x3FD1B07D00000000, float noundef 0x3FEE6F0AE0000000)
  %238 = extractvalue { <2 x float>, <2 x float> } %call119, 0
  store <2 x float> %238, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 119), align 16
  %239 = extractvalue { <2 x float>, <2 x float> } %call119, 1
  store <2 x float> %239, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 119), i32 0, i32 1), align 8
  %call120 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3F9E59AFA0000000, float noundef 0x3FE012DBA0000000, float noundef 0x3FEBA76540000000)
  %240 = extractvalue { <2 x float>, <2 x float> } %call120, 0
  store <2 x float> %240, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 120), align 16
  %241 = extractvalue { <2 x float>, <2 x float> } %call120, 1
  store <2 x float> %241, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 120), i32 0, i32 1), align 8
  %call121 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFEE4F91A0000000, float noundef 0x3FD1B078E0000000, float noundef 0xBFC4CB6C80000000)
  %242 = extractvalue { <2 x float>, <2 x float> } %call121, 0
  store <2 x float> %242, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 121), align 16
  %243 = extractvalue { <2 x float>, <2 x float> } %call121, 1
  store <2 x float> %243, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 121), i32 0, i32 1), align 8
  %call122 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef -1.000000e+00, float noundef 0x3EB0C6F7A0000000, float noundef 0.000000e+00)
  %244 = extractvalue { <2 x float>, <2 x float> } %call122, 0
  store <2 x float> %244, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 122), align 16
  %245 = extractvalue { <2 x float>, <2 x float> } %call122, 1
  store <2 x float> %245, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 122), i32 0, i32 1), align 8
  %call123 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFEB388220000000, float noundef 0x3FE0D2D440000000, float noundef -0.000000e+00)
  %246 = extractvalue { <2 x float>, <2 x float> } %call123, 0
  store <2 x float> %246, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 123), align 16
  %247 = extractvalue { <2 x float>, <2 x float> } %call123, 1
  store <2 x float> %247, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 123), i32 0, i32 1), align 8
  %call124 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFEE4F91A0000000, float noundef 0x3FD1B07D00000000, float noundef 0x3FC4CB6C80000000)
  %248 = extractvalue { <2 x float>, <2 x float> } %call124, 0
  store <2 x float> %248, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 124), align 16
  %249 = extractvalue { <2 x float>, <2 x float> } %call124, 1
  store <2 x float> %249, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 124), i32 0, i32 1), align 8
  %call125 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFEA01E040000000, float noundef 0x3FE012D980000000, float noundef 0x3FD2E52DE0000000)
  %250 = extractvalue { <2 x float>, <2 x float> } %call125, 0
  store <2 x float> %250, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 125), align 16
  %251 = extractvalue { <2 x float>, <2 x float> } %call125, 1
  store <2 x float> %251, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 125), i32 0, i32 1), align 8
  %call126 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFC1B08140000000, float noundef 0x3FD1B07D00000000, float noundef 0xBFEE6F0AE0000000)
  %252 = extractvalue { <2 x float>, <2 x float> } %call126, 0
  store <2 x float> %252, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 126), align 16
  %253 = extractvalue { <2 x float>, <2 x float> } %call126, 1
  store <2 x float> %253, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 126), i32 0, i32 1), align 8
  %call127 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFD3C6EB00000000, float noundef -0.000000e+00, float noundef 0xBFEE6F0F20000000)
  %254 = extractvalue { <2 x float>, <2 x float> } %call127, 0
  store <2 x float> %254, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 127), align 16
  %255 = extractvalue { <2 x float>, <2 x float> } %call127, 1
  store <2 x float> %255, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 127), i32 0, i32 1), align 8
  %call128 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFD0D2D880000000, float noundef 0x3FE0D2D880000000, float noundef 0xBFE9E36D20000000)
  %256 = extractvalue { <2 x float>, <2 x float> } %call128, 0
  store <2 x float> %256, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 128), align 16
  %257 = extractvalue { <2 x float>, <2 x float> } %call128, 1
  store <2 x float> %257, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 128), i32 0, i32 1), align 8
  %call129 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFDC9F2BA0000000, float noundef 0x3FD1B07D00000000, float noundef 0xBFEB388440000000)
  %258 = extractvalue { <2 x float>, <2 x float> } %call129, 0
  store <2 x float> %258, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 129), align 16
  %259 = extractvalue { <2 x float>, <2 x float> } %call129, 1
  store <2 x float> %259, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 129), i32 0, i32 1), align 8
  %call130 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFE105A920000000, float noundef 0x3FE012DBA0000000, float noundef 0xBFE5D095A0000000)
  %260 = extractvalue { <2 x float>, <2 x float> } %call130, 0
  store <2 x float> %260, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 130), align 16
  %261 = extractvalue { <2 x float>, <2 x float> } %call130, 1
  store <2 x float> %261, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 130), i32 0, i32 1), align 8
  %call131 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FEB93E600000000, float noundef 0x3FD1B078E0000000, float noundef 0xBFDB3879C0000000)
  %262 = extractvalue { <2 x float>, <2 x float> } %call131, 0
  store <2 x float> %262, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 131), align 16
  %263 = extractvalue { <2 x float>, <2 x float> } %call131, 1
  store <2 x float> %263, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 131), i32 0, i32 1), align 8
  %call132 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FE9E37BE0000000, float noundef 0.000000e+00, float noundef 0xBFE2CF1C40000000)
  %264 = extractvalue { <2 x float>, <2 x float> } %call132, 0
  store <2 x float> %264, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 132), align 16
  %265 = extractvalue { <2 x float>, <2 x float> } %call132, 1
  store <2 x float> %265, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 132), i32 0, i32 1), align 8
  %call133 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FE605A500000000, float noundef 0x3FE0D2D440000000, float noundef 0xBFDFFFF360000000)
  %266 = extractvalue { <2 x float>, <2 x float> } %call133, 0
  store <2 x float> %266, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 133), align 16
  %267 = extractvalue { <2 x float>, <2 x float> } %call133, 1
  store <2 x float> %267, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 133), i32 0, i32 1), align 8
  %call134 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FE5775DA0000000, float noundef 0x3FD1B07D00000000, float noundef 0xBFE605A500000000)
  %268 = extractvalue { <2 x float>, <2 x float> } %call134, 0
  store <2 x float> %268, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 134), align 16
  %269 = extractvalue { <2 x float>, <2 x float> } %call134, 1
  store <2 x float> %269, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 134), i32 0, i32 1), align 8
  %call135 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FDEF96180000000, float noundef 0x3FE012DBA0000000, float noundef 0xBFE6EE19C0000000)
  %270 = extractvalue { <2 x float>, <2 x float> } %call135, 0
  store <2 x float> %270, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 135), align 16
  %271 = extractvalue { <2 x float>, <2 x float> } %call135, 1
  store <2 x float> %271, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 135), i32 0, i32 1), align 8
  %call136 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FB3DE0D60000000, float noundef 0x3FEEF97240000000, float noundef 0x3FCE92BC20000000)
  %272 = extractvalue { <2 x float>, <2 x float> } %call136, 0
  store <2 x float> %272, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 136), align 16
  %273 = extractvalue { <2 x float>, <2 x float> } %call136, 1
  store <2 x float> %273, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 136), i32 0, i32 1), align 8
  %call137 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FD012CAE0000000, float noundef 0x3FEEF97020000000, float noundef 0.000000e+00)
  %274 = extractvalue { <2 x float>, <2 x float> } %call137, 0
  store <2 x float> %274, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 137), align 16
  %275 = extractvalue { <2 x float>, <2 x float> } %call137, 1
  store <2 x float> %275, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 137), i32 0, i32 1), align 8
  %call138 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0.000000e+00, float noundef 1.000000e+00, float noundef 0.000000e+00)
  %276 = extractvalue { <2 x float>, <2 x float> } %call138, 0
  store <2 x float> %276, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 138), align 16
  %277 = extractvalue { <2 x float>, <2 x float> } %call138, 1
  store <2 x float> %277, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 138), i32 0, i32 1), align 8
  %call139 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FC4CB5BC0000000, float noundef 0x3FEB388EC0000000, float noundef 0x3FDFFFEB00000000)
  %278 = extractvalue { <2 x float>, <2 x float> } %call139, 0
  store <2 x float> %278, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 139), align 16
  %279 = extractvalue { <2 x float>, <2 x float> } %call139, 1
  store <2 x float> %279, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 139), i32 0, i32 1), align 8
  %call140 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FD727BB20000000, float noundef 0x3FEC9F29A0000000, float noundef 0x3FD0D2BF60000000)
  %280 = extractvalue { <2 x float>, <2 x float> } %call140, 0
  store <2 x float> %280, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 140), align 16
  %281 = extractvalue { <2 x float>, <2 x float> } %call140, 1
  store <2 x float> %281, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 140), i32 0, i32 1), align 8
  %call141 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FDC9F1280000000, float noundef 0x3FE727D460000000, float noundef 0x3FE0D2C380000000)
  %282 = extractvalue { <2 x float>, <2 x float> } %call141, 0
  store <2 x float> %282, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 141), align 16
  %283 = extractvalue { <2 x float>, <2 x float> } %call141, 1
  store <2 x float> %283, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 141), i32 0, i32 1), align 8
  %call142 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FE0D2C7C0000000, float noundef 0x3FEB388A80000000, float noundef 0.000000e+00)
  %284 = extractvalue { <2 x float>, <2 x float> } %call142, 0
  store <2 x float> %284, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 142), align 16
  %285 = extractvalue { <2 x float>, <2 x float> } %call142, 1
  store <2 x float> %285, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 142), i32 0, i32 1), align 8
  %call143 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FE46C15E0000000, float noundef 0x3FE727D020000000, float noundef 0x3FD0D2C380000000)
  %286 = extractvalue { <2 x float>, <2 x float> } %call143, 0
  store <2 x float> %286, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 143), align 16
  %287 = extractvalue { <2 x float>, <2 x float> } %call143, 1
  store <2 x float> %287, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 143), i32 0, i32 1), align 8
  %call144 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFCA01D5C0000000, float noundef 0x3FEEF97240000000, float noundef 0x3FC2E52580000000)
  %288 = extractvalue { <2 x float>, <2 x float> } %call144, 0
  store <2 x float> %288, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 144), align 16
  %289 = extractvalue { <2 x float>, <2 x float> } %call144, 1
  store <2 x float> %289, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 144), i32 0, i32 1), align 8
  %call145 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFDB387E00000000, float noundef 0x3FEB388EC0000000, float noundef 0x3FD3C6D620000000)
  %290 = extractvalue { <2 x float>, <2 x float> } %call145, 0
  store <2 x float> %290, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 145), align 16
  %291 = extractvalue { <2 x float>, <2 x float> } %call145, 1
  store <2 x float> %291, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 145), i32 0, i32 1), align 8
  %call146 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFC1B07080000000, float noundef 0x3FEC9F2BA0000000, float noundef 0x3FDB387160000000)
  %292 = extractvalue { <2 x float>, <2 x float> } %call146, 0
  store <2 x float> %292, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 146), align 16
  %293 = extractvalue { <2 x float>, <2 x float> } %call146, 1
  store <2 x float> %293, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 146), i32 0, i32 1), align 8
  %call147 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFD727CC00000000, float noundef 0x3FE727D460000000, float noundef 0x3FE2CF13C0000000)
  %294 = extractvalue { <2 x float>, <2 x float> } %call147, 0
  store <2 x float> %294, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 147), align 16
  %295 = extractvalue { <2 x float>, <2 x float> } %call147, 1
  store <2 x float> %295, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 147), i32 0, i32 1), align 8
  %call148 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFAB074A80000000, float noundef 0x3FE727D460000000, float noundef 0x3FE6059C80000000)
  %296 = extractvalue { <2 x float>, <2 x float> } %call148, 0
  store <2 x float> %296, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 148), align 16
  %297 = extractvalue { <2 x float>, <2 x float> } %call148, 1
  store <2 x float> %297, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 148), i32 0, i32 1), align 8
  %call149 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFCA01D5C0000000, float noundef 0x3FEEF97240000000, float noundef 0xBFC2E52580000000)
  %298 = extractvalue { <2 x float>, <2 x float> } %call149, 0
  store <2 x float> %298, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 149), align 16
  %299 = extractvalue { <2 x float>, <2 x float> } %call149, 1
  store <2 x float> %299, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 149), i32 0, i32 1), align 8
  %call150 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFDB387E00000000, float noundef 0x3FEB388EC0000000, float noundef 0xBFD3C6D620000000)
  %300 = extractvalue { <2 x float>, <2 x float> } %call150, 0
  store <2 x float> %300, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 150), align 16
  %301 = extractvalue { <2 x float>, <2 x float> } %call150, 1
  store <2 x float> %301, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 150), i32 0, i32 1), align 8
  %call151 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFDC9F16C0000000, float noundef 0x3FEC9F29A0000000, float noundef 0.000000e+00)
  %302 = extractvalue { <2 x float>, <2 x float> } %call151, 0
  store <2 x float> %302, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 151), align 16
  %303 = extractvalue { <2 x float>, <2 x float> } %call151, 1
  store <2 x float> %303, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 151), i32 0, i32 1), align 8
  %call152 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFE5775540000000, float noundef 0x3FE727D240000000, float noundef 0xBFC4CB6420000000)
  %304 = extractvalue { <2 x float>, <2 x float> } %call152, 0
  store <2 x float> %304, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 152), align 16
  %305 = extractvalue { <2 x float>, <2 x float> } %call152, 1
  store <2 x float> %305, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 152), i32 0, i32 1), align 8
  %call153 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFE5775540000000, float noundef 0x3FE727D240000000, float noundef 0x3FC4CB6420000000)
  %306 = extractvalue { <2 x float>, <2 x float> } %call153, 0
  store <2 x float> %306, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 153), align 16
  %307 = extractvalue { <2 x float>, <2 x float> } %call153, 1
  store <2 x float> %307, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 153), i32 0, i32 1), align 8
  %call154 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FB3DE0D60000000, float noundef 0x3FEEF97240000000, float noundef 0xBFCE92BC20000000)
  %308 = extractvalue { <2 x float>, <2 x float> } %call154, 0
  store <2 x float> %308, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 154), align 16
  %309 = extractvalue { <2 x float>, <2 x float> } %call154, 1
  store <2 x float> %309, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 154), i32 0, i32 1), align 8
  %call155 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FC4CB5BC0000000, float noundef 0x3FEB388EC0000000, float noundef 0xBFDFFFEB00000000)
  %310 = extractvalue { <2 x float>, <2 x float> } %call155, 0
  store <2 x float> %310, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 155), align 16
  %311 = extractvalue { <2 x float>, <2 x float> } %call155, 1
  store <2 x float> %311, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 155), i32 0, i32 1), align 8
  %call156 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFC1B07080000000, float noundef 0x3FEC9F2BA0000000, float noundef 0xBFDB387160000000)
  %312 = extractvalue { <2 x float>, <2 x float> } %call156, 0
  store <2 x float> %312, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 156), align 16
  %313 = extractvalue { <2 x float>, <2 x float> } %call156, 1
  store <2 x float> %313, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 156), i32 0, i32 1), align 8
  %call157 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFAB074A80000000, float noundef 0x3FE727D460000000, float noundef 0xBFE6059C80000000)
  %314 = extractvalue { <2 x float>, <2 x float> } %call157, 0
  store <2 x float> %314, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 157), align 16
  %315 = extractvalue { <2 x float>, <2 x float> } %call157, 1
  store <2 x float> %315, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 157), i32 0, i32 1), align 8
  %call158 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0xBFD727CC00000000, float noundef 0x3FE727D460000000, float noundef 0xBFE2CF13C0000000)
  %316 = extractvalue { <2 x float>, <2 x float> } %call158, 0
  store <2 x float> %316, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 158), align 16
  %317 = extractvalue { <2 x float>, <2 x float> } %call158, 1
  store <2 x float> %317, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 158), i32 0, i32 1), align 8
  %call159 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FD727BB20000000, float noundef 0x3FEC9F29A0000000, float noundef 0xBFD0D2BF60000000)
  %318 = extractvalue { <2 x float>, <2 x float> } %call159, 0
  store <2 x float> %318, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 159), align 16
  %319 = extractvalue { <2 x float>, <2 x float> } %call159, 1
  store <2 x float> %319, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 159), i32 0, i32 1), align 8
  %call160 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FE46C15E0000000, float noundef 0x3FE727D020000000, float noundef 0xBFD0D2C380000000)
  %320 = extractvalue { <2 x float>, <2 x float> } %call160, 0
  store <2 x float> %320, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 160), align 16
  %321 = extractvalue { <2 x float>, <2 x float> } %call160, 1
  store <2 x float> %321, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 160), i32 0, i32 1), align 8
  %call161 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0x3FDC9F1280000000, float noundef 0x3FE727D460000000, float noundef 0xBFE0D2C380000000)
  %322 = extractvalue { <2 x float>, <2 x float> } %call161, 0
  store <2 x float> %322, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 161), align 16
  %323 = extractvalue { <2 x float>, <2 x float> } %call161, 1
  store <2 x float> %323, ptr getelementptr inbounds ({ <2 x float>, <2 x float> }, ptr getelementptr inbounds (%class.b3Vector3, ptr @unitSphere162, i64 161), i32 0, i32 1), align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef %x, float noundef %y, float noundef %z) #0 comdat {
entry:
  %retval = alloca %class.b3Vector3, align 16
  %x.addr = alloca float, align 4
  %y.addr = alloca float, align 4
  %z.addr = alloca float, align 4
  store float %x, ptr %x.addr, align 4
  store float %y, ptr %y.addr, align 4
  store float %z, ptr %z.addr, align 4
  call void @_ZN9b3Vector38setValueERKfS1_S1_(ptr noundef nonnull align 16 dereferenceable(16) %retval, ptr noundef nonnull align 4 dereferenceable(4) %x.addr, ptr noundef nonnull align 4 dereferenceable(4) %y.addr, ptr noundef nonnull align 4 dereferenceable(4) %z.addr)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive1 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %0 = load { <2 x float>, <2 x float> }, ptr %coerce.dive1, align 16
  ret { <2 x float>, <2 x float> } %0
}

; Function Attrs: mustprogress uwtable
define dso_local noundef zeroext i1 @_Z28b3FindSeparatingAxisEdgeEdgePK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_Pfb(ptr noundef %hullA, ptr noundef %hullB, ptr noundef nonnull align 16 dereferenceable(16) %posA1, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB1, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %DeltaC2, ptr noundef %verticesA, ptr noundef %uniqueEdgesA, ptr noundef %facesA, ptr noundef %indicesA, ptr noundef %verticesB, ptr noundef %uniqueEdgesB, ptr noundef %facesB, ptr noundef %indicesB, ptr noundef %sep, ptr noundef %dmin, i1 noundef zeroext %searchAllEdgeEdge) #2 {
entry:
  %retval = alloca i1, align 1
  %hullA.addr = alloca ptr, align 8
  %hullB.addr = alloca ptr, align 8
  %posA1.addr = alloca ptr, align 8
  %ornA.addr = alloca ptr, align 8
  %posB1.addr = alloca ptr, align 8
  %ornB.addr = alloca ptr, align 8
  %DeltaC2.addr = alloca ptr, align 8
  %verticesA.addr = alloca ptr, align 8
  %uniqueEdgesA.addr = alloca ptr, align 8
  %facesA.addr = alloca ptr, align 8
  %indicesA.addr = alloca ptr, align 8
  %verticesB.addr = alloca ptr, align 8
  %uniqueEdgesB.addr = alloca ptr, align 8
  %facesB.addr = alloca ptr, align 8
  %indicesB.addr = alloca ptr, align 8
  %sep.addr = alloca ptr, align 8
  %dmin.addr = alloca ptr, align 8
  %searchAllEdgeEdge.addr = alloca i8, align 1
  %posA = alloca %class.b3Vector3, align 16
  %posB = alloca %class.b3Vector3, align 16
  %curEdgeEdge = alloca i32, align 4
  %curEdgeTests = alloca i32, align 4
  %e0 = alloca i32, align 4
  %edge0 = alloca %class.b3Vector3, align 16
  %edge0World = alloca %class.b3Vector3, align 16
  %e1 = alloca i32, align 4
  %edge1 = alloca %class.b3Vector3, align 16
  %edge1World = alloca %class.b3Vector3, align 16
  %crossje = alloca %class.b3Vector3, align 16
  %ref.tmp = alloca %class.b3Vector3, align 16
  %ref.tmp34 = alloca float, align 4
  %dist = alloca float, align 4
  %result = alloca i8, align 1
  %Min0 = alloca float, align 4
  %Max0 = alloca float, align 4
  %Min1 = alloca float, align 4
  %Max1 = alloca float, align 4
  %d0 = alloca float, align 4
  %d1 = alloca float, align 4
  %numDirections = alloca i32, align 4
  %i = alloca i32, align 4
  %crossje54 = alloca %class.b3Vector3, align 16
  %dist57 = alloca float, align 4
  %result58 = alloca i8, align 1
  %Min059 = alloca float, align 4
  %Max060 = alloca float, align 4
  %Min161 = alloca float, align 4
  %Max162 = alloca float, align 4
  %d068 = alloca float, align 4
  %d170 = alloca float, align 4
  %ref.tmp84 = alloca %class.b3Vector3, align 16
  %ref.tmp91 = alloca %class.b3Vector3, align 16
  store ptr %hullA, ptr %hullA.addr, align 8
  store ptr %hullB, ptr %hullB.addr, align 8
  store ptr %posA1, ptr %posA1.addr, align 8
  store ptr %ornA, ptr %ornA.addr, align 8
  store ptr %posB1, ptr %posB1.addr, align 8
  store ptr %ornB, ptr %ornB.addr, align 8
  store ptr %DeltaC2, ptr %DeltaC2.addr, align 8
  store ptr %verticesA, ptr %verticesA.addr, align 8
  store ptr %uniqueEdgesA, ptr %uniqueEdgesA.addr, align 8
  store ptr %facesA, ptr %facesA.addr, align 8
  store ptr %indicesA, ptr %indicesA.addr, align 8
  store ptr %verticesB, ptr %verticesB.addr, align 8
  store ptr %uniqueEdgesB, ptr %uniqueEdgesB.addr, align 8
  store ptr %facesB, ptr %facesB.addr, align 8
  store ptr %indicesB, ptr %indicesB.addr, align 8
  store ptr %sep, ptr %sep.addr, align 8
  store ptr %dmin, ptr %dmin.addr, align 8
  %frombool = zext i1 %searchAllEdgeEdge to i8
  store i8 %frombool, ptr %searchAllEdgeEdge.addr, align 1
  %0 = load ptr, ptr %posA1.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posA, ptr align 16 %0, i64 16, i1 false)
  %1 = getelementptr inbounds %class.b3Vector3, ptr %posA, i32 0, i32 0
  %w = getelementptr inbounds %struct.anon.2, ptr %1, i32 0, i32 3
  store float 0.000000e+00, ptr %w, align 4
  %2 = load ptr, ptr %posB1.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posB, ptr align 16 %2, i64 16, i1 false)
  %3 = getelementptr inbounds %class.b3Vector3, ptr %posB, i32 0, i32 0
  %w1 = getelementptr inbounds %struct.anon.2, ptr %3, i32 0, i32 3
  store float 0.000000e+00, ptr %w1, align 4
  store i32 0, ptr %curEdgeEdge, align 4
  %4 = load ptr, ptr %hullA.addr, align 8
  %m_numUniqueEdges = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %4, i32 0, i32 10
  %5 = load i32, ptr %m_numUniqueEdges, align 8
  %6 = load ptr, ptr %hullB.addr, align 8
  %m_numUniqueEdges2 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %6, i32 0, i32 10
  %7 = load i32, ptr %m_numUniqueEdges2, align 8
  %mul = mul nsw i32 %5, %7
  store i32 %mul, ptr %curEdgeTests, align 4
  %8 = load i32, ptr %curEdgeTests, align 4
  %9 = load i32, ptr @_ZZ28b3FindSeparatingAxisEdgeEdgePK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_PfbE12maxEdgeTests, align 4
  %cmp = icmp sgt i32 %8, %9
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load i32, ptr %curEdgeTests, align 4
  store i32 %10, ptr @_ZZ28b3FindSeparatingAxisEdgeEdgePK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_PfbE12maxEdgeTests, align 4
  %11 = load i32, ptr @_ZZ28b3FindSeparatingAxisEdgeEdgePK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_PfbE12maxEdgeTests, align 4
  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %11)
  %12 = load ptr, ptr %hullA.addr, align 8
  %m_numUniqueEdges3 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %12, i32 0, i32 10
  %13 = load i32, ptr %m_numUniqueEdges3, align 8
  %call4 = call i32 (ptr, ...) @printf(ptr noundef @.str.1, i32 noundef %13)
  %14 = load ptr, ptr %hullB.addr, align 8
  %m_numUniqueEdges5 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %14, i32 0, i32 10
  %15 = load i32, ptr %m_numUniqueEdges5, align 8
  %call6 = call i32 (ptr, ...) @printf(ptr noundef @.str.2, i32 noundef %15)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %16 = load i8, ptr %searchAllEdgeEdge.addr, align 1
  %tobool = trunc i8 %16 to i1
  br i1 %tobool, label %if.then7, label %if.else

if.then7:                                         ; preds = %if.end
  store i32 0, ptr %e0, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc48, %if.then7
  %17 = load i32, ptr %e0, align 4
  %18 = load ptr, ptr %hullA.addr, align 8
  %m_numUniqueEdges8 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %18, i32 0, i32 10
  %19 = load i32, ptr %m_numUniqueEdges8, align 8
  %cmp9 = icmp slt i32 %17, %19
  br i1 %cmp9, label %for.body, label %for.end50

for.body:                                         ; preds = %for.cond
  %20 = load ptr, ptr %uniqueEdgesA.addr, align 8
  %21 = load ptr, ptr %hullA.addr, align 8
  %m_uniqueEdgesOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %21, i32 0, i32 9
  %22 = load i32, ptr %m_uniqueEdgesOffset, align 4
  %23 = load i32, ptr %e0, align 4
  %add = add nsw i32 %22, %23
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr inbounds %class.b3Vector3, ptr %20, i64 %idxprom
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %edge0, ptr align 16 %arrayidx, i64 16, i1 false)
  %24 = load ptr, ptr %ornA.addr, align 8
  %call10 = call { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %24, ptr noundef nonnull align 16 dereferenceable(16) %edge0)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %edge0World, i32 0, i32 0
  %coerce.dive11 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %25 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive11, i32 0, i32 0
  %26 = extractvalue { <2 x float>, <2 x float> } %call10, 0
  store <2 x float> %26, ptr %25, align 16
  %27 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive11, i32 0, i32 1
  %28 = extractvalue { <2 x float>, <2 x float> } %call10, 1
  store <2 x float> %28, ptr %27, align 8
  store i32 0, ptr %e1, align 4
  br label %for.cond12

for.cond12:                                       ; preds = %for.inc, %for.body
  %29 = load i32, ptr %e1, align 4
  %30 = load ptr, ptr %hullB.addr, align 8
  %m_numUniqueEdges13 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %30, i32 0, i32 10
  %31 = load i32, ptr %m_numUniqueEdges13, align 8
  %cmp14 = icmp slt i32 %29, %31
  br i1 %cmp14, label %for.body15, label %for.end

for.body15:                                       ; preds = %for.cond12
  %32 = load ptr, ptr %uniqueEdgesB.addr, align 8
  %33 = load ptr, ptr %hullB.addr, align 8
  %m_uniqueEdgesOffset16 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %33, i32 0, i32 9
  %34 = load i32, ptr %m_uniqueEdgesOffset16, align 4
  %35 = load i32, ptr %e1, align 4
  %add17 = add nsw i32 %34, %35
  %idxprom18 = sext i32 %add17 to i64
  %arrayidx19 = getelementptr inbounds %class.b3Vector3, ptr %32, i64 %idxprom18
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %edge1, ptr align 16 %arrayidx19, i64 16, i1 false)
  %36 = load ptr, ptr %ornB.addr, align 8
  %call20 = call { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %36, ptr noundef nonnull align 16 dereferenceable(16) %edge1)
  %coerce.dive21 = getelementptr inbounds %class.b3Vector3, ptr %edge1World, i32 0, i32 0
  %coerce.dive22 = getelementptr inbounds %union.anon.1, ptr %coerce.dive21, i32 0, i32 0
  %37 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive22, i32 0, i32 0
  %38 = extractvalue { <2 x float>, <2 x float> } %call20, 0
  store <2 x float> %38, ptr %37, align 16
  %39 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive22, i32 0, i32 1
  %40 = extractvalue { <2 x float>, <2 x float> } %call20, 1
  store <2 x float> %40, ptr %39, align 8
  %call23 = call { <2 x float>, <2 x float> } @_Z7b3CrossRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %edge0World, ptr noundef nonnull align 16 dereferenceable(16) %edge1World)
  %coerce.dive24 = getelementptr inbounds %class.b3Vector3, ptr %crossje, i32 0, i32 0
  %coerce.dive25 = getelementptr inbounds %union.anon.1, ptr %coerce.dive24, i32 0, i32 0
  %41 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive25, i32 0, i32 0
  %42 = extractvalue { <2 x float>, <2 x float> } %call23, 0
  store <2 x float> %42, ptr %41, align 16
  %43 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive25, i32 0, i32 1
  %44 = extractvalue { <2 x float>, <2 x float> } %call23, 1
  store <2 x float> %44, ptr %43, align 8
  %45 = load i32, ptr %curEdgeEdge, align 4
  %inc = add nsw i32 %45, 1
  store i32 %inc, ptr %curEdgeEdge, align 4
  %call26 = call noundef zeroext i1 @_Z14b3IsAlmostZeroRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %crossje)
  br i1 %call26, label %if.end46, label %if.then27

if.then27:                                        ; preds = %for.body15
  %call28 = call { <2 x float>, <2 x float> } @_Z12b3NormalizedRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %crossje)
  %coerce.dive29 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive30 = getelementptr inbounds %union.anon.1, ptr %coerce.dive29, i32 0, i32 0
  %46 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive30, i32 0, i32 0
  %47 = extractvalue { <2 x float>, <2 x float> } %call28, 0
  store <2 x float> %47, ptr %46, align 16
  %48 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive30, i32 0, i32 1
  %49 = extractvalue { <2 x float>, <2 x float> } %call28, 1
  store <2 x float> %49, ptr %48, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %crossje, ptr align 16 %ref.tmp, i64 16, i1 false)
  %50 = load ptr, ptr %DeltaC2.addr, align 8
  %call31 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %50, ptr noundef nonnull align 16 dereferenceable(16) %crossje)
  %cmp32 = fcmp olt float %call31, 0.000000e+00
  br i1 %cmp32, label %if.then33, label %if.end36

if.then33:                                        ; preds = %if.then27
  store float -1.000000e+00, ptr %ref.tmp34, align 4
  %call35 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector3mLERKf(ptr noundef nonnull align 16 dereferenceable(16) %crossje, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp34)
  br label %if.end36

if.end36:                                         ; preds = %if.then33, %if.then27
  store i8 1, ptr %result, align 1
  %51 = load ptr, ptr %hullA.addr, align 8
  %52 = load ptr, ptr %ornA.addr, align 8
  %53 = load ptr, ptr %verticesA.addr, align 8
  call void @_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_(ptr noundef %51, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %52, ptr noundef %crossje, ptr noundef %53, ptr noundef %Min0, ptr noundef %Max0)
  %54 = load ptr, ptr %hullB.addr, align 8
  %55 = load ptr, ptr %ornB.addr, align 8
  %56 = load ptr, ptr %verticesB.addr, align 8
  call void @_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_(ptr noundef %54, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %55, ptr noundef %crossje, ptr noundef %56, ptr noundef %Min1, ptr noundef %Max1)
  %57 = load float, ptr %Max0, align 4
  %58 = load float, ptr %Min1, align 4
  %cmp37 = fcmp olt float %57, %58
  br i1 %cmp37, label %if.then39, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end36
  %59 = load float, ptr %Max1, align 4
  %60 = load float, ptr %Min0, align 4
  %cmp38 = fcmp olt float %59, %60
  br i1 %cmp38, label %if.then39, label %if.end40

if.then39:                                        ; preds = %lor.lhs.false, %if.end36
  store i1 false, ptr %retval, align 1
  br label %return

if.end40:                                         ; preds = %lor.lhs.false
  %61 = load float, ptr %Max0, align 4
  %62 = load float, ptr %Min1, align 4
  %sub = fsub float %61, %62
  store float %sub, ptr %d0, align 4
  %63 = load float, ptr %Max1, align 4
  %64 = load float, ptr %Min0, align 4
  %sub41 = fsub float %63, %64
  store float %sub41, ptr %d1, align 4
  %65 = load float, ptr %d0, align 4
  %66 = load float, ptr %d1, align 4
  %cmp42 = fcmp olt float %65, %66
  br i1 %cmp42, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end40
  %67 = load float, ptr %d0, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end40
  %68 = load float, ptr %d1, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %67, %cond.true ], [ %68, %cond.false ]
  store float %cond, ptr %dist, align 4
  store i8 1, ptr %result, align 1
  %69 = load float, ptr %dist, align 4
  %70 = load ptr, ptr %dmin.addr, align 8
  %71 = load float, ptr %70, align 4
  %cmp43 = fcmp olt float %69, %71
  br i1 %cmp43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %cond.end
  %72 = load float, ptr %dist, align 4
  %73 = load ptr, ptr %dmin.addr, align 8
  store float %72, ptr %73, align 4
  %74 = load ptr, ptr %sep.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %74, ptr align 16 %crossje, i64 16, i1 false)
  br label %if.end45

if.end45:                                         ; preds = %if.then44, %cond.end
  br label %if.end46

if.end46:                                         ; preds = %if.end45, %for.body15
  br label %for.inc

for.inc:                                          ; preds = %if.end46
  %75 = load i32, ptr %e1, align 4
  %inc47 = add nsw i32 %75, 1
  store i32 %inc47, ptr %e1, align 4
  br label %for.cond12, !llvm.loop !10

for.end:                                          ; preds = %for.cond12
  br label %for.inc48

for.inc48:                                        ; preds = %for.end
  %76 = load i32, ptr %e0, align 4
  %inc49 = add nsw i32 %76, 1
  store i32 %inc49, ptr %e0, align 4
  br label %for.cond, !llvm.loop !11

for.end50:                                        ; preds = %for.cond
  br label %if.end83

if.else:                                          ; preds = %if.end
  store i32 162, ptr %numDirections, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond51

for.cond51:                                       ; preds = %for.inc80, %if.else
  %77 = load i32, ptr %i, align 4
  %78 = load i32, ptr %numDirections, align 4
  %cmp52 = icmp slt i32 %77, %78
  br i1 %cmp52, label %for.body53, label %for.end82

for.body53:                                       ; preds = %for.cond51
  %79 = load i32, ptr %i, align 4
  %idxprom55 = sext i32 %79 to i64
  %arrayidx56 = getelementptr inbounds [162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 %idxprom55
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %crossje54, ptr align 16 %arrayidx56, i64 16, i1 false)
  store i8 1, ptr %result58, align 1
  %80 = load ptr, ptr %hullA.addr, align 8
  %81 = load ptr, ptr %ornA.addr, align 8
  %82 = load ptr, ptr %verticesA.addr, align 8
  call void @_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_(ptr noundef %80, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %81, ptr noundef %crossje54, ptr noundef %82, ptr noundef %Min059, ptr noundef %Max060)
  %83 = load ptr, ptr %hullB.addr, align 8
  %84 = load ptr, ptr %ornB.addr, align 8
  %85 = load ptr, ptr %verticesB.addr, align 8
  call void @_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_(ptr noundef %83, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %84, ptr noundef %crossje54, ptr noundef %85, ptr noundef %Min161, ptr noundef %Max162)
  %86 = load float, ptr %Max060, align 4
  %87 = load float, ptr %Min161, align 4
  %cmp63 = fcmp olt float %86, %87
  br i1 %cmp63, label %if.then66, label %lor.lhs.false64

lor.lhs.false64:                                  ; preds = %for.body53
  %88 = load float, ptr %Max162, align 4
  %89 = load float, ptr %Min059, align 4
  %cmp65 = fcmp olt float %88, %89
  br i1 %cmp65, label %if.then66, label %if.end67

if.then66:                                        ; preds = %lor.lhs.false64, %for.body53
  store i1 false, ptr %retval, align 1
  br label %return

if.end67:                                         ; preds = %lor.lhs.false64
  %90 = load float, ptr %Max060, align 4
  %91 = load float, ptr %Min161, align 4
  %sub69 = fsub float %90, %91
  store float %sub69, ptr %d068, align 4
  %92 = load float, ptr %Max162, align 4
  %93 = load float, ptr %Min059, align 4
  %sub71 = fsub float %92, %93
  store float %sub71, ptr %d170, align 4
  %94 = load float, ptr %d068, align 4
  %95 = load float, ptr %d170, align 4
  %cmp72 = fcmp olt float %94, %95
  br i1 %cmp72, label %cond.true73, label %cond.false74

cond.true73:                                      ; preds = %if.end67
  %96 = load float, ptr %d068, align 4
  br label %cond.end75

cond.false74:                                     ; preds = %if.end67
  %97 = load float, ptr %d170, align 4
  br label %cond.end75

cond.end75:                                       ; preds = %cond.false74, %cond.true73
  %cond76 = phi float [ %96, %cond.true73 ], [ %97, %cond.false74 ]
  store float %cond76, ptr %dist57, align 4
  store i8 1, ptr %result58, align 1
  %98 = load float, ptr %dist57, align 4
  %99 = load ptr, ptr %dmin.addr, align 8
  %100 = load float, ptr %99, align 4
  %cmp77 = fcmp olt float %98, %100
  br i1 %cmp77, label %if.then78, label %if.end79

if.then78:                                        ; preds = %cond.end75
  %101 = load float, ptr %dist57, align 4
  %102 = load ptr, ptr %dmin.addr, align 8
  store float %101, ptr %102, align 4
  %103 = load ptr, ptr %sep.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %103, ptr align 16 %crossje54, i64 16, i1 false)
  br label %if.end79

if.end79:                                         ; preds = %if.then78, %cond.end75
  br label %for.inc80

for.inc80:                                        ; preds = %if.end79
  %104 = load i32, ptr %i, align 4
  %inc81 = add nsw i32 %104, 1
  store i32 %inc81, ptr %i, align 4
  br label %for.cond51, !llvm.loop !12

for.end82:                                        ; preds = %for.cond51
  br label %if.end83

if.end83:                                         ; preds = %for.end82, %for.end50
  %105 = load ptr, ptr %DeltaC2.addr, align 8
  %call85 = call { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %105)
  %coerce.dive86 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp84, i32 0, i32 0
  %coerce.dive87 = getelementptr inbounds %union.anon.1, ptr %coerce.dive86, i32 0, i32 0
  %106 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive87, i32 0, i32 0
  %107 = extractvalue { <2 x float>, <2 x float> } %call85, 0
  store <2 x float> %107, ptr %106, align 16
  %108 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive87, i32 0, i32 1
  %109 = extractvalue { <2 x float>, <2 x float> } %call85, 1
  store <2 x float> %109, ptr %108, align 8
  %110 = load ptr, ptr %sep.addr, align 8
  %call88 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp84, ptr noundef nonnull align 16 dereferenceable(16) %110)
  %cmp89 = fcmp ogt float %call88, 0.000000e+00
  br i1 %cmp89, label %if.then90, label %if.end95

if.then90:                                        ; preds = %if.end83
  %111 = load ptr, ptr %sep.addr, align 8
  %call92 = call { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %111)
  %coerce.dive93 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp91, i32 0, i32 0
  %coerce.dive94 = getelementptr inbounds %union.anon.1, ptr %coerce.dive93, i32 0, i32 0
  %112 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive94, i32 0, i32 0
  %113 = extractvalue { <2 x float>, <2 x float> } %call92, 0
  store <2 x float> %113, ptr %112, align 16
  %114 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive94, i32 0, i32 1
  %115 = extractvalue { <2 x float>, <2 x float> } %call92, 1
  store <2 x float> %115, ptr %114, align 8
  %116 = load ptr, ptr %sep.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %116, ptr align 16 %ref.tmp91, i64 16, i1 false)
  br label %if.end95

if.end95:                                         ; preds = %if.then90, %if.end83
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end95, %if.then66, %if.then39
  %117 = load i1, ptr %retval, align 1
  ret i1 %117
}

declare i32 @printf(ptr noundef, ...) #5

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_Z7b3CrossRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %v1, ptr noundef nonnull align 16 dereferenceable(16) %v2) #2 comdat {
entry:
  %retval = alloca %class.b3Vector3, align 16
  %v1.addr = alloca ptr, align 8
  %v2.addr = alloca ptr, align 8
  store ptr %v1, ptr %v1.addr, align 8
  store ptr %v2, ptr %v2.addr, align 8
  %0 = load ptr, ptr %v1.addr, align 8
  %1 = load ptr, ptr %v2.addr, align 8
  %call = call { <2 x float>, <2 x float> } @_ZNK9b3Vector35crossERKS_(ptr noundef nonnull align 16 dereferenceable(16) %0, ptr noundef nonnull align 16 dereferenceable(16) %1)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive1 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %2 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive1, i32 0, i32 0
  %3 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %3, ptr %2, align 16
  %4 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive1, i32 0, i32 1
  %5 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %5, ptr %4, align 8
  %coerce.dive2 = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %union.anon.1, ptr %coerce.dive2, i32 0, i32 0
  %6 = load { <2 x float>, <2 x float> }, ptr %coerce.dive3, align 16
  ret { <2 x float>, <2 x float> } %6
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_Z14b3IsAlmostZeroRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %v) #0 comdat {
entry:
  %retval = alloca i1, align 1
  %v.addr = alloca ptr, align 8
  store ptr %v, ptr %v.addr, align 8
  %0 = load ptr, ptr %v.addr, align 8
  %1 = getelementptr inbounds %class.b3Vector3, ptr %0, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon.2, ptr %1, i32 0, i32 0
  %2 = load float, ptr %x, align 16
  %call = call noundef float @_Z6b3Fabsf(float noundef %2)
  %conv = fpext float %call to double
  %cmp = fcmp ogt double %conv, 0x3EB0C6F7A0B5ED8D
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load ptr, ptr %v.addr, align 8
  %4 = getelementptr inbounds %class.b3Vector3, ptr %3, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon.2, ptr %4, i32 0, i32 1
  %5 = load float, ptr %y, align 4
  %call1 = call noundef float @_Z6b3Fabsf(float noundef %5)
  %conv2 = fpext float %call1 to double
  %cmp3 = fcmp ogt double %conv2, 0x3EB0C6F7A0B5ED8D
  br i1 %cmp3, label %if.then, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false
  %6 = load ptr, ptr %v.addr, align 8
  %7 = getelementptr inbounds %class.b3Vector3, ptr %6, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon.2, ptr %7, i32 0, i32 2
  %8 = load float, ptr %z, align 8
  %call5 = call noundef float @_Z6b3Fabsf(float noundef %8)
  %conv6 = fpext float %call5 to double
  %cmp7 = fcmp ogt double %conv6, 0x3EB0C6F7A0B5ED8D
  br i1 %cmp7, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false4, %lor.lhs.false, %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false4
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %9 = load i1, ptr %retval, align 1
  ret i1 %9
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_Z12b3NormalizedRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %vec) #2 comdat {
entry:
  %retval = alloca %class.b3Vector3, align 16
  %vec.addr = alloca ptr, align 8
  store ptr %vec, ptr %vec.addr, align 8
  %0 = load ptr, ptr %vec.addr, align 8
  %call = call { <2 x float>, <2 x float> } @_ZNK9b3Vector310normalizedEv(ptr noundef nonnull align 16 dereferenceable(16) %0)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive1 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %1 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive1, i32 0, i32 0
  %2 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %2, ptr %1, align 16
  %3 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive1, i32 0, i32 1
  %4 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %4, ptr %3, align 8
  %coerce.dive2 = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %union.anon.1, ptr %coerce.dive2, i32 0, i32 0
  %5 = load { <2 x float>, <2 x float> }, ptr %coerce.dive3, align 16
  ret { <2 x float>, <2 x float> } %5
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_(ptr noundef %hull, ptr noundef nonnull align 16 dereferenceable(16) %pos, ptr noundef nonnull align 16 dereferenceable(16) %orn, ptr noundef %dir, ptr noundef %vertices, ptr noundef %min, ptr noundef %max) #2 comdat {
entry:
  %hull.addr = alloca ptr, align 8
  %pos.addr = alloca ptr, align 8
  %orn.addr = alloca ptr, align 8
  %dir.addr = alloca ptr, align 8
  %vertices.addr = alloca ptr, align 8
  %min.addr = alloca ptr, align 8
  %max.addr = alloca ptr, align 8
  %numVerts = alloca i32, align 4
  %localDir = alloca %class.b3Vector3, align 16
  %ref.tmp = alloca %class.b3Quaternion, align 16
  %offset = alloca float, align 4
  %i = alloca i32, align 4
  %dp = alloca float, align 4
  %tmp = alloca float, align 4
  store ptr %hull, ptr %hull.addr, align 8
  store ptr %pos, ptr %pos.addr, align 8
  store ptr %orn, ptr %orn.addr, align 8
  store ptr %dir, ptr %dir.addr, align 8
  store ptr %vertices, ptr %vertices.addr, align 8
  store ptr %min, ptr %min.addr, align 8
  store ptr %max, ptr %max.addr, align 8
  %0 = load ptr, ptr %min.addr, align 8
  %arrayidx = getelementptr inbounds float, ptr %0, i64 0
  store float 0x47EFFFFFE0000000, ptr %arrayidx, align 4
  %1 = load ptr, ptr %max.addr, align 8
  %arrayidx1 = getelementptr inbounds float, ptr %1, i64 0
  store float 0xC7EFFFFFE0000000, ptr %arrayidx1, align 4
  %2 = load ptr, ptr %hull.addr, align 8
  %m_numVertices = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %2, i32 0, i32 7
  %3 = load i32, ptr %m_numVertices, align 4
  store i32 %3, ptr %numVerts, align 4
  %4 = load ptr, ptr %orn.addr, align 8
  %call = call { <2 x float>, <2 x float> } @_Z13b3QuatInverseRK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(16) %4)
  %coerce.dive = getelementptr inbounds %class.b3Quaternion, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %union.anon.3, ptr %coerce.dive2, i32 0, i32 0
  %5 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive3, i32 0, i32 0
  %6 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %6, ptr %5, align 16
  %7 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive3, i32 0, i32 1
  %8 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %8, ptr %7, align 8
  %9 = load ptr, ptr %dir.addr, align 8
  %call4 = call { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp, ptr noundef nonnull align 16 dereferenceable(16) %9)
  %coerce.dive5 = getelementptr inbounds %class.b3Vector3, ptr %localDir, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %union.anon.1, ptr %coerce.dive5, i32 0, i32 0
  %10 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive6, i32 0, i32 0
  %11 = extractvalue { <2 x float>, <2 x float> } %call4, 0
  store <2 x float> %11, ptr %10, align 16
  %12 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive6, i32 0, i32 1
  %13 = extractvalue { <2 x float>, <2 x float> } %call4, 1
  store <2 x float> %13, ptr %12, align 8
  %14 = load ptr, ptr %pos.addr, align 8
  %15 = load ptr, ptr %dir.addr, align 8
  %call7 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %14, ptr noundef nonnull align 16 dereferenceable(16) %15)
  store float %call7, ptr %offset, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %16 = load i32, ptr %i, align 4
  %17 = load i32, ptr %numVerts, align 4
  %cmp = icmp slt i32 %16, %17
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %18 = load ptr, ptr %vertices.addr, align 8
  %19 = load ptr, ptr %hull.addr, align 8
  %m_vertexOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %19, i32 0, i32 8
  %20 = load i32, ptr %m_vertexOffset, align 16
  %21 = load i32, ptr %i, align 4
  %add = add nsw i32 %20, %21
  %idxprom = sext i32 %add to i64
  %arrayidx8 = getelementptr inbounds %class.b3Vector3, ptr %18, i64 %idxprom
  %call9 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx8, ptr noundef nonnull align 16 dereferenceable(16) %localDir)
  store float %call9, ptr %dp, align 4
  %22 = load float, ptr %dp, align 4
  %23 = load ptr, ptr %min.addr, align 8
  %arrayidx10 = getelementptr inbounds float, ptr %23, i64 0
  %24 = load float, ptr %arrayidx10, align 4
  %cmp11 = fcmp olt float %22, %24
  br i1 %cmp11, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %25 = load float, ptr %dp, align 4
  %26 = load ptr, ptr %min.addr, align 8
  %arrayidx12 = getelementptr inbounds float, ptr %26, i64 0
  store float %25, ptr %arrayidx12, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %27 = load float, ptr %dp, align 4
  %28 = load ptr, ptr %max.addr, align 8
  %arrayidx13 = getelementptr inbounds float, ptr %28, i64 0
  %29 = load float, ptr %arrayidx13, align 4
  %cmp14 = fcmp ogt float %27, %29
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end
  %30 = load float, ptr %dp, align 4
  %31 = load ptr, ptr %max.addr, align 8
  %arrayidx16 = getelementptr inbounds float, ptr %31, i64 0
  store float %30, ptr %arrayidx16, align 4
  br label %if.end17

if.end17:                                         ; preds = %if.then15, %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end17
  %32 = load i32, ptr %i, align 4
  %inc = add nsw i32 %32, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !13

for.end:                                          ; preds = %for.cond
  %33 = load ptr, ptr %min.addr, align 8
  %arrayidx18 = getelementptr inbounds float, ptr %33, i64 0
  %34 = load float, ptr %arrayidx18, align 4
  %35 = load ptr, ptr %max.addr, align 8
  %arrayidx19 = getelementptr inbounds float, ptr %35, i64 0
  %36 = load float, ptr %arrayidx19, align 4
  %cmp20 = fcmp ogt float %34, %36
  br i1 %cmp20, label %if.then21, label %if.end26

if.then21:                                        ; preds = %for.end
  %37 = load ptr, ptr %min.addr, align 8
  %arrayidx22 = getelementptr inbounds float, ptr %37, i64 0
  %38 = load float, ptr %arrayidx22, align 4
  store float %38, ptr %tmp, align 4
  %39 = load ptr, ptr %max.addr, align 8
  %arrayidx23 = getelementptr inbounds float, ptr %39, i64 0
  %40 = load float, ptr %arrayidx23, align 4
  %41 = load ptr, ptr %min.addr, align 8
  %arrayidx24 = getelementptr inbounds float, ptr %41, i64 0
  store float %40, ptr %arrayidx24, align 4
  %42 = load float, ptr %tmp, align 4
  %43 = load ptr, ptr %max.addr, align 8
  %arrayidx25 = getelementptr inbounds float, ptr %43, i64 0
  store float %42, ptr %arrayidx25, align 4
  br label %if.end26

if.end26:                                         ; preds = %if.then21, %for.end
  %44 = load float, ptr %offset, align 4
  %45 = load ptr, ptr %min.addr, align 8
  %arrayidx27 = getelementptr inbounds float, ptr %45, i64 0
  %46 = load float, ptr %arrayidx27, align 4
  %add28 = fadd float %46, %44
  store float %add28, ptr %arrayidx27, align 4
  %47 = load float, ptr %offset, align 4
  %48 = load ptr, ptr %max.addr, align 8
  %arrayidx29 = getelementptr inbounds float, ptr %48, i64 0
  %49 = load float, ptr %arrayidx29, align 4
  %add30 = fadd float %49, %47
  store float %add30, ptr %arrayidx29, align 4
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local void @_Z33b3FindConcaveSeparatingAxisKernelP6b3Int4PK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataPK9b3Vector3SC_PK9b3GpuFacePKiPK15b3GpuChildShapeP6b3AabbPSA_S0_SN_SN_SN_Piiii(ptr noundef %concavePairs, ptr noundef %rigidBodies, ptr noundef %collidables, ptr noundef %convexShapes, ptr noundef %vertices, ptr noundef %uniqueEdges, ptr noundef %faces, ptr noundef %indices, ptr noundef %gpuChildShapes, ptr noundef %aabbs, ptr noundef %concaveSeparatingNormalsOut, ptr noundef %clippingFacesOut, ptr noundef %worldVertsA1Out, ptr noundef %worldNormalsA1Out, ptr noundef %worldVertsB1Out, ptr noundef %hasSeparatingNormals, i32 noundef %vertexFaceCapacity, i32 noundef %numConcavePairs, i32 noundef %pairIdx) #2 {
entry:
  %concavePairs.addr = alloca ptr, align 8
  %rigidBodies.addr = alloca ptr, align 8
  %collidables.addr = alloca ptr, align 8
  %convexShapes.addr = alloca ptr, align 8
  %vertices.addr = alloca ptr, align 8
  %uniqueEdges.addr = alloca ptr, align 8
  %faces.addr = alloca ptr, align 8
  %indices.addr = alloca ptr, align 8
  %gpuChildShapes.addr = alloca ptr, align 8
  %aabbs.addr = alloca ptr, align 8
  %concaveSeparatingNormalsOut.addr = alloca ptr, align 8
  %clippingFacesOut.addr = alloca ptr, align 8
  %worldVertsA1Out.addr = alloca ptr, align 8
  %worldNormalsA1Out.addr = alloca ptr, align 8
  %worldVertsB1Out.addr = alloca ptr, align 8
  %hasSeparatingNormals.addr = alloca ptr, align 8
  %vertexFaceCapacity.addr = alloca i32, align 4
  %numConcavePairs.addr = alloca i32, align 4
  %pairIdx.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %bodyIndexA = alloca i32, align 4
  %bodyIndexB = alloca i32, align 4
  %collidableIndexA = alloca i32, align 4
  %collidableIndexB = alloca i32, align 4
  %shapeIndexA = alloca i32, align 4
  %shapeIndexB = alloca i32, align 4
  %numActualConcaveConvexTests = alloca i32, align 4
  %f = alloca i32, align 4
  %overlap = alloca i8, align 1
  %convexPolyhedronA = alloca %struct.b3ConvexPolyhedronData, align 16
  %localCenter = alloca %class.b3Vector3, align 16
  %face = alloca %struct.b3GpuFace, align 16
  %triAabb = alloca %struct.b3Aabb, align 16
  %ref.tmp = alloca %class.b3Vector3, align 16
  %ref.tmp32 = alloca %class.b3Vector3, align 16
  %verticesA = alloca [3 x %class.b3Vector3], align 16
  %i36 = alloca i32, align 4
  %index = alloca i32, align 4
  %vert = alloca %class.b3Vector3, align 16
  %ref.tmp50 = alloca %class.b3Vector3, align 16
  %ref.tmp54 = alloca %class.b3Vector3, align 16
  %dmin = alloca float, align 4
  %hasSeparatingAxis = alloca i32, align 4
  %sepAxis = alloca %class.b3Vector3, align 16
  %uniqueEdgesA = alloca [3 x %class.b3Vector3], align 16
  %ref.tmp108 = alloca %class.b3Vector3, align 16
  %ref.tmp115 = alloca %class.b3Vector3, align 16
  %ref.tmp122 = alloca %class.b3Vector3, align 16
  %normal = alloca %class.b3Vector3, align 16
  %facesA = alloca [5 x %struct.b3GpuFace], align 16
  %indicesA = alloca [12 x i32], align 16
  %curUsedIndices = alloca i32, align 4
  %fidx = alloca i32, align 4
  %c = alloca float, align 4
  %c176 = alloca float, align 4
  %addEdgePlanes = alloca i8, align 1
  %numVertices = alloca i32, align 4
  %prevVertex = alloca i32, align 4
  %i206 = alloca i32, align 4
  %v0 = alloca %class.b3Vector3, align 16
  %v1 = alloca %class.b3Vector3, align 16
  %edgeNormal = alloca %class.b3Vector3, align 16
  %ref.tmp214 = alloca %class.b3Vector3, align 16
  %ref.tmp215 = alloca %class.b3Vector3, align 16
  %c225 = alloca float, align 4
  %ref.tmp264 = alloca %class.b3Vector3, align 16
  %ref.tmp265 = alloca float, align 4
  %posA = alloca %class.b3Vector3, align 16
  %posB = alloca %class.b3Vector3, align 16
  %ornA = alloca %class.b3Quaternion, align 16
  %ornB = alloca %class.b3Quaternion, align 16
  %compoundChild = alloca i32, align 4
  %childShapeIndexB = alloca i32, align 4
  %childColIndexB = alloca i32, align 4
  %childPosB = alloca %class.b3Vector3, align 16
  %childOrnB = alloca %class.b3Quaternion, align 16
  %newPosB = alloca %class.b3Vector3, align 16
  %newOrnB = alloca %class.b3Quaternion, align 16
  %c0local = alloca %class.b3Vector3, align 16
  %c0 = alloca %class.b3Vector3, align 16
  %c1local = alloca %class.b3Vector3, align 16
  %c1 = alloca %class.b3Vector3, align 16
  %DeltaC2 = alloca %class.b3Vector3, align 16
  %sepA = alloca i8, align 1
  %sepB = alloca i8, align 1
  %sepEE = alloca i8, align 1
  %minDist = alloca float, align 4
  %maxDist = alloca float, align 4
  store ptr %concavePairs, ptr %concavePairs.addr, align 8
  store ptr %rigidBodies, ptr %rigidBodies.addr, align 8
  store ptr %collidables, ptr %collidables.addr, align 8
  store ptr %convexShapes, ptr %convexShapes.addr, align 8
  store ptr %vertices, ptr %vertices.addr, align 8
  store ptr %uniqueEdges, ptr %uniqueEdges.addr, align 8
  store ptr %faces, ptr %faces.addr, align 8
  store ptr %indices, ptr %indices.addr, align 8
  store ptr %gpuChildShapes, ptr %gpuChildShapes.addr, align 8
  store ptr %aabbs, ptr %aabbs.addr, align 8
  store ptr %concaveSeparatingNormalsOut, ptr %concaveSeparatingNormalsOut.addr, align 8
  store ptr %clippingFacesOut, ptr %clippingFacesOut.addr, align 8
  store ptr %worldVertsA1Out, ptr %worldVertsA1Out.addr, align 8
  store ptr %worldNormalsA1Out, ptr %worldNormalsA1Out.addr, align 8
  store ptr %worldVertsB1Out, ptr %worldVertsB1Out.addr, align 8
  store ptr %hasSeparatingNormals, ptr %hasSeparatingNormals.addr, align 8
  store i32 %vertexFaceCapacity, ptr %vertexFaceCapacity.addr, align 4
  store i32 %numConcavePairs, ptr %numConcavePairs.addr, align 4
  store i32 %pairIdx, ptr %pairIdx.addr, align 4
  %0 = load i32, ptr %pairIdx.addr, align 4
  store i32 %0, ptr %i, align 4
  %1 = load ptr, ptr %concavePairs.addr, align 8
  %2 = load i32, ptr %i, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds %struct.b3Int4, ptr %1, i64 %idxprom
  %3 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %x, align 16
  store i32 %4, ptr %bodyIndexA, align 4
  %5 = load ptr, ptr %concavePairs.addr, align 8
  %6 = load i32, ptr %i, align 4
  %idxprom1 = sext i32 %6 to i64
  %arrayidx2 = getelementptr inbounds %struct.b3Int4, ptr %5, i64 %idxprom1
  %7 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx2, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon, ptr %7, i32 0, i32 1
  %8 = load i32, ptr %y, align 4
  store i32 %8, ptr %bodyIndexB, align 4
  %9 = load ptr, ptr %rigidBodies.addr, align 8
  %10 = load i32, ptr %bodyIndexA, align 4
  %idxprom3 = sext i32 %10 to i64
  %arrayidx4 = getelementptr inbounds %struct.b3RigidBodyData, ptr %9, i64 %idxprom3
  %m_collidableIdx = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx4, i32 0, i32 4
  %11 = load i32, ptr %m_collidableIdx, align 16
  store i32 %11, ptr %collidableIndexA, align 4
  %12 = load ptr, ptr %rigidBodies.addr, align 8
  %13 = load i32, ptr %bodyIndexB, align 4
  %idxprom5 = sext i32 %13 to i64
  %arrayidx6 = getelementptr inbounds %struct.b3RigidBodyData, ptr %12, i64 %idxprom5
  %m_collidableIdx7 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx6, i32 0, i32 4
  %14 = load i32, ptr %m_collidableIdx7, align 16
  store i32 %14, ptr %collidableIndexB, align 4
  %15 = load ptr, ptr %collidables.addr, align 8
  %16 = load i32, ptr %collidableIndexA, align 4
  %idxprom8 = sext i32 %16 to i64
  %arrayidx9 = getelementptr inbounds %struct.b3Collidable, ptr %15, i64 %idxprom8
  %17 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx9, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  store i32 %18, ptr %shapeIndexA, align 4
  %19 = load ptr, ptr %collidables.addr, align 8
  %20 = load i32, ptr %collidableIndexB, align 4
  %idxprom10 = sext i32 %20 to i64
  %arrayidx11 = getelementptr inbounds %struct.b3Collidable, ptr %19, i64 %idxprom10
  %21 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx11, i32 0, i32 3
  %22 = load i32, ptr %21, align 4
  store i32 %22, ptr %shapeIndexB, align 4
  %23 = load ptr, ptr %collidables.addr, align 8
  %24 = load i32, ptr %collidableIndexB, align 4
  %idxprom12 = sext i32 %24 to i64
  %arrayidx13 = getelementptr inbounds %struct.b3Collidable, ptr %23, i64 %idxprom12
  %m_shapeType = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx13, i32 0, i32 2
  %25 = load i32, ptr %m_shapeType, align 4
  %cmp = icmp ne i32 %25, 3
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %26 = load ptr, ptr %collidables.addr, align 8
  %27 = load i32, ptr %collidableIndexB, align 4
  %idxprom14 = sext i32 %27 to i64
  %arrayidx15 = getelementptr inbounds %struct.b3Collidable, ptr %26, i64 %idxprom14
  %m_shapeType16 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx15, i32 0, i32 2
  %28 = load i32, ptr %m_shapeType16, align 4
  %cmp17 = icmp ne i32 %28, 6
  br i1 %cmp17, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %29 = load ptr, ptr %concavePairs.addr, align 8
  %30 = load i32, ptr %pairIdx.addr, align 4
  %idxprom18 = sext i32 %30 to i64
  %arrayidx19 = getelementptr inbounds %struct.b3Int4, ptr %29, i64 %idxprom18
  %31 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx19, i32 0, i32 0
  %w = getelementptr inbounds %struct.anon, ptr %31, i32 0, i32 3
  store i32 -1, ptr %w, align 4
  br label %if.end374

if.end:                                           ; preds = %land.lhs.true, %entry
  %32 = load ptr, ptr %hasSeparatingNormals.addr, align 8
  %33 = load i32, ptr %i, align 4
  %idxprom20 = sext i32 %33 to i64
  %arrayidx21 = getelementptr inbounds i32, ptr %32, i64 %idxprom20
  store i32 0, ptr %arrayidx21, align 4
  store i32 0, ptr %numActualConcaveConvexTests, align 4
  %34 = load ptr, ptr %concavePairs.addr, align 8
  %35 = load i32, ptr %i, align 4
  %idxprom22 = sext i32 %35 to i64
  %arrayidx23 = getelementptr inbounds %struct.b3Int4, ptr %34, i64 %idxprom22
  %36 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx23, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon, ptr %36, i32 0, i32 2
  %37 = load i32, ptr %z, align 8
  store i32 %37, ptr %f, align 4
  store i8 0, ptr %overlap, align 1
  %m_numVertices = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexPolyhedronA, i32 0, i32 7
  store i32 3, ptr %m_numVertices, align 4
  %m_vertexOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexPolyhedronA, i32 0, i32 8
  store i32 0, ptr %m_vertexOffset, align 16
  %call = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %localCenter, i32 0, i32 0
  %coerce.dive24 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %38 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive24, i32 0, i32 0
  %39 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %39, ptr %38, align 16
  %40 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive24, i32 0, i32 1
  %41 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %41, ptr %40, align 8
  %42 = load ptr, ptr %faces.addr, align 8
  %43 = load ptr, ptr %convexShapes.addr, align 8
  %44 = load i32, ptr %shapeIndexA, align 4
  %idxprom25 = sext i32 %44 to i64
  %arrayidx26 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %43, i64 %idxprom25
  %m_faceOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %arrayidx26, i32 0, i32 5
  %45 = load i32, ptr %m_faceOffset, align 4
  %46 = load i32, ptr %f, align 4
  %add = add nsw i32 %45, %46
  %idxprom27 = sext i32 %add to i64
  %arrayidx28 = getelementptr inbounds %struct.b3GpuFace, ptr %42, i64 %idxprom27
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %face, ptr align 16 %arrayidx28, i64 32, i1 false)
  %call29 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef 0x46293E5940000000, float noundef 0x46293E5940000000, float noundef 0x46293E5940000000, float noundef 0.000000e+00)
  %coerce.dive30 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive31 = getelementptr inbounds %union.anon.1, ptr %coerce.dive30, i32 0, i32 0
  %47 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive31, i32 0, i32 0
  %48 = extractvalue { <2 x float>, <2 x float> } %call29, 0
  store <2 x float> %48, ptr %47, align 16
  %49 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive31, i32 0, i32 1
  %50 = extractvalue { <2 x float>, <2 x float> } %call29, 1
  store <2 x float> %50, ptr %49, align 8
  %51 = getelementptr inbounds %struct.b3Aabb, ptr %triAabb, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %51, ptr align 16 %ref.tmp, i64 16, i1 false)
  %call33 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef 0xC6293E5940000000, float noundef 0xC6293E5940000000, float noundef 0xC6293E5940000000, float noundef 0.000000e+00)
  %coerce.dive34 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp32, i32 0, i32 0
  %coerce.dive35 = getelementptr inbounds %union.anon.1, ptr %coerce.dive34, i32 0, i32 0
  %52 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive35, i32 0, i32 0
  %53 = extractvalue { <2 x float>, <2 x float> } %call33, 0
  store <2 x float> %53, ptr %52, align 16
  %54 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive35, i32 0, i32 1
  %55 = extractvalue { <2 x float>, <2 x float> } %call33, 1
  store <2 x float> %55, ptr %54, align 8
  %56 = getelementptr inbounds %struct.b3Aabb, ptr %triAabb, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %56, ptr align 16 %ref.tmp32, i64 16, i1 false)
  store i32 0, ptr %i36, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %57 = load i32, ptr %i36, align 4
  %cmp37 = icmp slt i32 %57, 3
  br i1 %cmp37, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %58 = load ptr, ptr %indices.addr, align 8
  %m_indexOffset = getelementptr inbounds %struct.b3GpuFace, ptr %face, i32 0, i32 1
  %59 = load i32, ptr %m_indexOffset, align 16
  %60 = load i32, ptr %i36, align 4
  %add38 = add nsw i32 %59, %60
  %idxprom39 = sext i32 %add38 to i64
  %arrayidx40 = getelementptr inbounds i32, ptr %58, i64 %idxprom39
  %61 = load i32, ptr %arrayidx40, align 4
  store i32 %61, ptr %index, align 4
  %62 = load ptr, ptr %vertices.addr, align 8
  %63 = load ptr, ptr %convexShapes.addr, align 8
  %64 = load i32, ptr %shapeIndexA, align 4
  %idxprom41 = sext i32 %64 to i64
  %arrayidx42 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %63, i64 %idxprom41
  %m_vertexOffset43 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %arrayidx42, i32 0, i32 8
  %65 = load i32, ptr %m_vertexOffset43, align 16
  %66 = load i32, ptr %index, align 4
  %add44 = add nsw i32 %65, %66
  %idxprom45 = sext i32 %add44 to i64
  %arrayidx46 = getelementptr inbounds %class.b3Vector3, ptr %62, i64 %idxprom45
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %vert, ptr align 16 %arrayidx46, i64 16, i1 false)
  %67 = load i32, ptr %i36, align 4
  %idxprom47 = sext i32 %67 to i64
  %arrayidx48 = getelementptr inbounds [3 x %class.b3Vector3], ptr %verticesA, i64 0, i64 %idxprom47
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx48, ptr align 16 %vert, i64 16, i1 false)
  %call49 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector3pLERKS_(ptr noundef nonnull align 16 dereferenceable(16) %localCenter, ptr noundef nonnull align 16 dereferenceable(16) %vert)
  %68 = getelementptr inbounds %struct.b3Aabb, ptr %triAabb, i32 0, i32 0
  %call51 = call { <2 x float>, <2 x float> } @_Z11b3MinFloat4RK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %68, ptr noundef nonnull align 16 dereferenceable(16) %vert)
  %coerce.dive52 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp50, i32 0, i32 0
  %coerce.dive53 = getelementptr inbounds %union.anon.1, ptr %coerce.dive52, i32 0, i32 0
  %69 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive53, i32 0, i32 0
  %70 = extractvalue { <2 x float>, <2 x float> } %call51, 0
  store <2 x float> %70, ptr %69, align 16
  %71 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive53, i32 0, i32 1
  %72 = extractvalue { <2 x float>, <2 x float> } %call51, 1
  store <2 x float> %72, ptr %71, align 8
  %73 = getelementptr inbounds %struct.b3Aabb, ptr %triAabb, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %73, ptr align 16 %ref.tmp50, i64 16, i1 false)
  %74 = getelementptr inbounds %struct.b3Aabb, ptr %triAabb, i32 0, i32 1
  %call55 = call { <2 x float>, <2 x float> } @_Z11b3MaxFloat4RK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %74, ptr noundef nonnull align 16 dereferenceable(16) %vert)
  %coerce.dive56 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp54, i32 0, i32 0
  %coerce.dive57 = getelementptr inbounds %union.anon.1, ptr %coerce.dive56, i32 0, i32 0
  %75 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive57, i32 0, i32 0
  %76 = extractvalue { <2 x float>, <2 x float> } %call55, 0
  store <2 x float> %76, ptr %75, align 16
  %77 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive57, i32 0, i32 1
  %78 = extractvalue { <2 x float>, <2 x float> } %call55, 1
  store <2 x float> %78, ptr %77, align 8
  %79 = getelementptr inbounds %struct.b3Aabb, ptr %triAabb, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %79, ptr align 16 %ref.tmp54, i64 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %80 = load i32, ptr %i36, align 4
  %inc = add nsw i32 %80, 1
  store i32 %inc, ptr %i36, align 4
  br label %for.cond, !llvm.loop !14

for.end:                                          ; preds = %for.cond
  store i8 1, ptr %overlap, align 1
  %81 = getelementptr inbounds %struct.b3Aabb, ptr %triAabb, i32 0, i32 0
  %82 = getelementptr inbounds %class.b3Vector3, ptr %81, i32 0, i32 0
  %x58 = getelementptr inbounds %struct.anon.2, ptr %82, i32 0, i32 0
  %83 = load float, ptr %x58, align 16
  %84 = load ptr, ptr %aabbs.addr, align 8
  %85 = load i32, ptr %bodyIndexB, align 4
  %idxprom59 = sext i32 %85 to i64
  %arrayidx60 = getelementptr inbounds %struct.b3Aabb, ptr %84, i64 %idxprom59
  %86 = getelementptr inbounds %struct.b3Aabb, ptr %arrayidx60, i32 0, i32 1
  %87 = getelementptr inbounds %class.b3Vector3, ptr %86, i32 0, i32 0
  %x61 = getelementptr inbounds %struct.anon.2, ptr %87, i32 0, i32 0
  %88 = load float, ptr %x61, align 16
  %cmp62 = fcmp ogt float %83, %88
  br i1 %cmp62, label %cond.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end
  %89 = getelementptr inbounds %struct.b3Aabb, ptr %triAabb, i32 0, i32 1
  %90 = getelementptr inbounds %class.b3Vector3, ptr %89, i32 0, i32 0
  %x63 = getelementptr inbounds %struct.anon.2, ptr %90, i32 0, i32 0
  %91 = load float, ptr %x63, align 16
  %92 = load ptr, ptr %aabbs.addr, align 8
  %93 = load i32, ptr %bodyIndexB, align 4
  %idxprom64 = sext i32 %93 to i64
  %arrayidx65 = getelementptr inbounds %struct.b3Aabb, ptr %92, i64 %idxprom64
  %94 = getelementptr inbounds %struct.b3Aabb, ptr %arrayidx65, i32 0, i32 0
  %95 = getelementptr inbounds %class.b3Vector3, ptr %94, i32 0, i32 0
  %x66 = getelementptr inbounds %struct.anon.2, ptr %95, i32 0, i32 0
  %96 = load float, ptr %x66, align 16
  %cmp67 = fcmp olt float %91, %96
  br i1 %cmp67, label %cond.true, label %cond.false

cond.true:                                        ; preds = %lor.lhs.false, %for.end
  br label %cond.end

cond.false:                                       ; preds = %lor.lhs.false
  %97 = load i8, ptr %overlap, align 1
  %tobool = trunc i8 %97 to i1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i1 [ false, %cond.true ], [ %tobool, %cond.false ]
  %frombool = zext i1 %cond to i8
  store i8 %frombool, ptr %overlap, align 1
  %98 = getelementptr inbounds %struct.b3Aabb, ptr %triAabb, i32 0, i32 0
  %99 = getelementptr inbounds %class.b3Vector3, ptr %98, i32 0, i32 0
  %z68 = getelementptr inbounds %struct.anon.2, ptr %99, i32 0, i32 2
  %100 = load float, ptr %z68, align 8
  %101 = load ptr, ptr %aabbs.addr, align 8
  %102 = load i32, ptr %bodyIndexB, align 4
  %idxprom69 = sext i32 %102 to i64
  %arrayidx70 = getelementptr inbounds %struct.b3Aabb, ptr %101, i64 %idxprom69
  %103 = getelementptr inbounds %struct.b3Aabb, ptr %arrayidx70, i32 0, i32 1
  %104 = getelementptr inbounds %class.b3Vector3, ptr %103, i32 0, i32 0
  %z71 = getelementptr inbounds %struct.anon.2, ptr %104, i32 0, i32 2
  %105 = load float, ptr %z71, align 8
  %cmp72 = fcmp ogt float %100, %105
  br i1 %cmp72, label %cond.true79, label %lor.lhs.false73

lor.lhs.false73:                                  ; preds = %cond.end
  %106 = getelementptr inbounds %struct.b3Aabb, ptr %triAabb, i32 0, i32 1
  %107 = getelementptr inbounds %class.b3Vector3, ptr %106, i32 0, i32 0
  %z74 = getelementptr inbounds %struct.anon.2, ptr %107, i32 0, i32 2
  %108 = load float, ptr %z74, align 8
  %109 = load ptr, ptr %aabbs.addr, align 8
  %110 = load i32, ptr %bodyIndexB, align 4
  %idxprom75 = sext i32 %110 to i64
  %arrayidx76 = getelementptr inbounds %struct.b3Aabb, ptr %109, i64 %idxprom75
  %111 = getelementptr inbounds %struct.b3Aabb, ptr %arrayidx76, i32 0, i32 0
  %112 = getelementptr inbounds %class.b3Vector3, ptr %111, i32 0, i32 0
  %z77 = getelementptr inbounds %struct.anon.2, ptr %112, i32 0, i32 2
  %113 = load float, ptr %z77, align 8
  %cmp78 = fcmp olt float %108, %113
  br i1 %cmp78, label %cond.true79, label %cond.false80

cond.true79:                                      ; preds = %lor.lhs.false73, %cond.end
  br label %cond.end82

cond.false80:                                     ; preds = %lor.lhs.false73
  %114 = load i8, ptr %overlap, align 1
  %tobool81 = trunc i8 %114 to i1
  br label %cond.end82

cond.end82:                                       ; preds = %cond.false80, %cond.true79
  %cond83 = phi i1 [ false, %cond.true79 ], [ %tobool81, %cond.false80 ]
  %frombool84 = zext i1 %cond83 to i8
  store i8 %frombool84, ptr %overlap, align 1
  %115 = getelementptr inbounds %struct.b3Aabb, ptr %triAabb, i32 0, i32 0
  %116 = getelementptr inbounds %class.b3Vector3, ptr %115, i32 0, i32 0
  %y85 = getelementptr inbounds %struct.anon.2, ptr %116, i32 0, i32 1
  %117 = load float, ptr %y85, align 4
  %118 = load ptr, ptr %aabbs.addr, align 8
  %119 = load i32, ptr %bodyIndexB, align 4
  %idxprom86 = sext i32 %119 to i64
  %arrayidx87 = getelementptr inbounds %struct.b3Aabb, ptr %118, i64 %idxprom86
  %120 = getelementptr inbounds %struct.b3Aabb, ptr %arrayidx87, i32 0, i32 1
  %121 = getelementptr inbounds %class.b3Vector3, ptr %120, i32 0, i32 0
  %y88 = getelementptr inbounds %struct.anon.2, ptr %121, i32 0, i32 1
  %122 = load float, ptr %y88, align 4
  %cmp89 = fcmp ogt float %117, %122
  br i1 %cmp89, label %cond.true96, label %lor.lhs.false90

lor.lhs.false90:                                  ; preds = %cond.end82
  %123 = getelementptr inbounds %struct.b3Aabb, ptr %triAabb, i32 0, i32 1
  %124 = getelementptr inbounds %class.b3Vector3, ptr %123, i32 0, i32 0
  %y91 = getelementptr inbounds %struct.anon.2, ptr %124, i32 0, i32 1
  %125 = load float, ptr %y91, align 4
  %126 = load ptr, ptr %aabbs.addr, align 8
  %127 = load i32, ptr %bodyIndexB, align 4
  %idxprom92 = sext i32 %127 to i64
  %arrayidx93 = getelementptr inbounds %struct.b3Aabb, ptr %126, i64 %idxprom92
  %128 = getelementptr inbounds %struct.b3Aabb, ptr %arrayidx93, i32 0, i32 0
  %129 = getelementptr inbounds %class.b3Vector3, ptr %128, i32 0, i32 0
  %y94 = getelementptr inbounds %struct.anon.2, ptr %129, i32 0, i32 1
  %130 = load float, ptr %y94, align 4
  %cmp95 = fcmp olt float %125, %130
  br i1 %cmp95, label %cond.true96, label %cond.false97

cond.true96:                                      ; preds = %lor.lhs.false90, %cond.end82
  br label %cond.end99

cond.false97:                                     ; preds = %lor.lhs.false90
  %131 = load i8, ptr %overlap, align 1
  %tobool98 = trunc i8 %131 to i1
  br label %cond.end99

cond.end99:                                       ; preds = %cond.false97, %cond.true96
  %cond100 = phi i1 [ false, %cond.true96 ], [ %tobool98, %cond.false97 ]
  %frombool101 = zext i1 %cond100 to i8
  store i8 %frombool101, ptr %overlap, align 1
  %132 = load i8, ptr %overlap, align 1
  %tobool102 = trunc i8 %132 to i1
  br i1 %tobool102, label %if.then103, label %if.else370

if.then103:                                       ; preds = %cond.end99
  store float 0x47EFFFFFE0000000, ptr %dmin, align 4
  store i32 5, ptr %hasSeparatingAxis, align 4
  %call104 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef 1.000000e+00, float noundef 2.000000e+00, float noundef 3.000000e+00, float noundef 4.000000e+00)
  %coerce.dive105 = getelementptr inbounds %class.b3Vector3, ptr %sepAxis, i32 0, i32 0
  %coerce.dive106 = getelementptr inbounds %union.anon.1, ptr %coerce.dive105, i32 0, i32 0
  %133 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive106, i32 0, i32 0
  %134 = extractvalue { <2 x float>, <2 x float> } %call104, 0
  store <2 x float> %134, ptr %133, align 16
  %135 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive106, i32 0, i32 1
  %136 = extractvalue { <2 x float>, <2 x float> } %call104, 1
  store <2 x float> %136, ptr %135, align 8
  %137 = load i32, ptr %numActualConcaveConvexTests, align 4
  %inc107 = add nsw i32 %137, 1
  store i32 %inc107, ptr %numActualConcaveConvexTests, align 4
  %m_numUniqueEdges = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexPolyhedronA, i32 0, i32 10
  store i32 3, ptr %m_numUniqueEdges, align 8
  %m_uniqueEdgesOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexPolyhedronA, i32 0, i32 9
  store i32 0, ptr %m_uniqueEdgesOffset, align 4
  %arrayidx109 = getelementptr inbounds [3 x %class.b3Vector3], ptr %verticesA, i64 0, i64 1
  %arrayidx110 = getelementptr inbounds [3 x %class.b3Vector3], ptr %verticesA, i64 0, i64 0
  %call111 = call { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx109, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx110)
  %coerce.dive112 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp108, i32 0, i32 0
  %coerce.dive113 = getelementptr inbounds %union.anon.1, ptr %coerce.dive112, i32 0, i32 0
  %138 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive113, i32 0, i32 0
  %139 = extractvalue { <2 x float>, <2 x float> } %call111, 0
  store <2 x float> %139, ptr %138, align 16
  %140 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive113, i32 0, i32 1
  %141 = extractvalue { <2 x float>, <2 x float> } %call111, 1
  store <2 x float> %141, ptr %140, align 8
  %arrayidx114 = getelementptr inbounds [3 x %class.b3Vector3], ptr %uniqueEdgesA, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx114, ptr align 16 %ref.tmp108, i64 16, i1 false)
  %arrayidx116 = getelementptr inbounds [3 x %class.b3Vector3], ptr %verticesA, i64 0, i64 2
  %arrayidx117 = getelementptr inbounds [3 x %class.b3Vector3], ptr %verticesA, i64 0, i64 1
  %call118 = call { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx116, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx117)
  %coerce.dive119 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp115, i32 0, i32 0
  %coerce.dive120 = getelementptr inbounds %union.anon.1, ptr %coerce.dive119, i32 0, i32 0
  %142 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive120, i32 0, i32 0
  %143 = extractvalue { <2 x float>, <2 x float> } %call118, 0
  store <2 x float> %143, ptr %142, align 16
  %144 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive120, i32 0, i32 1
  %145 = extractvalue { <2 x float>, <2 x float> } %call118, 1
  store <2 x float> %145, ptr %144, align 8
  %arrayidx121 = getelementptr inbounds [3 x %class.b3Vector3], ptr %uniqueEdgesA, i64 0, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx121, ptr align 16 %ref.tmp115, i64 16, i1 false)
  %arrayidx123 = getelementptr inbounds [3 x %class.b3Vector3], ptr %verticesA, i64 0, i64 0
  %arrayidx124 = getelementptr inbounds [3 x %class.b3Vector3], ptr %verticesA, i64 0, i64 2
  %call125 = call { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx123, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx124)
  %coerce.dive126 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp122, i32 0, i32 0
  %coerce.dive127 = getelementptr inbounds %union.anon.1, ptr %coerce.dive126, i32 0, i32 0
  %146 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive127, i32 0, i32 0
  %147 = extractvalue { <2 x float>, <2 x float> } %call125, 0
  store <2 x float> %147, ptr %146, align 16
  %148 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive127, i32 0, i32 1
  %149 = extractvalue { <2 x float>, <2 x float> } %call125, 1
  store <2 x float> %149, ptr %148, align 8
  %arrayidx128 = getelementptr inbounds [3 x %class.b3Vector3], ptr %uniqueEdgesA, i64 0, i64 2
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx128, ptr align 16 %ref.tmp122, i64 16, i1 false)
  %m_faceOffset129 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexPolyhedronA, i32 0, i32 5
  store i32 0, ptr %m_faceOffset129, align 4
  %m_plane = getelementptr inbounds %struct.b3GpuFace, ptr %face, i32 0, i32 0
  %150 = getelementptr inbounds %class.b3Vector3, ptr %m_plane, i32 0, i32 0
  %x130 = getelementptr inbounds %struct.anon.2, ptr %150, i32 0, i32 0
  %151 = load float, ptr %x130, align 16
  %m_plane131 = getelementptr inbounds %struct.b3GpuFace, ptr %face, i32 0, i32 0
  %152 = getelementptr inbounds %class.b3Vector3, ptr %m_plane131, i32 0, i32 0
  %y132 = getelementptr inbounds %struct.anon.2, ptr %152, i32 0, i32 1
  %153 = load float, ptr %y132, align 4
  %m_plane133 = getelementptr inbounds %struct.b3GpuFace, ptr %face, i32 0, i32 0
  %154 = getelementptr inbounds %class.b3Vector3, ptr %m_plane133, i32 0, i32 0
  %z134 = getelementptr inbounds %struct.anon.2, ptr %154, i32 0, i32 2
  %155 = load float, ptr %z134, align 8
  %call135 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef %151, float noundef %153, float noundef %155, float noundef 0.000000e+00)
  %coerce.dive136 = getelementptr inbounds %class.b3Vector3, ptr %normal, i32 0, i32 0
  %coerce.dive137 = getelementptr inbounds %union.anon.1, ptr %coerce.dive136, i32 0, i32 0
  %156 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive137, i32 0, i32 0
  %157 = extractvalue { <2 x float>, <2 x float> } %call135, 0
  store <2 x float> %157, ptr %156, align 16
  %158 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive137, i32 0, i32 1
  %159 = extractvalue { <2 x float>, <2 x float> } %call135, 1
  store <2 x float> %159, ptr %158, align 8
  store i32 0, ptr %curUsedIndices, align 4
  store i32 0, ptr %fidx, align 4
  %160 = load i32, ptr %curUsedIndices, align 4
  %161 = load i32, ptr %fidx, align 4
  %idxprom138 = sext i32 %161 to i64
  %arrayidx139 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 %idxprom138
  %m_indexOffset140 = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx139, i32 0, i32 1
  store i32 %160, ptr %m_indexOffset140, align 16
  %arrayidx141 = getelementptr inbounds [12 x i32], ptr %indicesA, i64 0, i64 0
  store i32 0, ptr %arrayidx141, align 16
  %arrayidx142 = getelementptr inbounds [12 x i32], ptr %indicesA, i64 0, i64 1
  store i32 1, ptr %arrayidx142, align 4
  %arrayidx143 = getelementptr inbounds [12 x i32], ptr %indicesA, i64 0, i64 2
  store i32 2, ptr %arrayidx143, align 8
  %162 = load i32, ptr %curUsedIndices, align 4
  %add144 = add nsw i32 %162, 3
  store i32 %add144, ptr %curUsedIndices, align 4
  %m_plane145 = getelementptr inbounds %struct.b3GpuFace, ptr %face, i32 0, i32 0
  %163 = getelementptr inbounds %class.b3Vector3, ptr %m_plane145, i32 0, i32 0
  %w146 = getelementptr inbounds %struct.anon.2, ptr %163, i32 0, i32 3
  %164 = load float, ptr %w146, align 4
  store float %164, ptr %c, align 4
  %165 = getelementptr inbounds %class.b3Vector3, ptr %normal, i32 0, i32 0
  %x147 = getelementptr inbounds %struct.anon.2, ptr %165, i32 0, i32 0
  %166 = load float, ptr %x147, align 16
  %167 = load i32, ptr %fidx, align 4
  %idxprom148 = sext i32 %167 to i64
  %arrayidx149 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 %idxprom148
  %m_plane150 = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx149, i32 0, i32 0
  %168 = getelementptr inbounds %class.b3Vector3, ptr %m_plane150, i32 0, i32 0
  %x151 = getelementptr inbounds %struct.anon.2, ptr %168, i32 0, i32 0
  store float %166, ptr %x151, align 16
  %169 = getelementptr inbounds %class.b3Vector3, ptr %normal, i32 0, i32 0
  %y152 = getelementptr inbounds %struct.anon.2, ptr %169, i32 0, i32 1
  %170 = load float, ptr %y152, align 4
  %171 = load i32, ptr %fidx, align 4
  %idxprom153 = sext i32 %171 to i64
  %arrayidx154 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 %idxprom153
  %m_plane155 = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx154, i32 0, i32 0
  %172 = getelementptr inbounds %class.b3Vector3, ptr %m_plane155, i32 0, i32 0
  %y156 = getelementptr inbounds %struct.anon.2, ptr %172, i32 0, i32 1
  store float %170, ptr %y156, align 4
  %173 = getelementptr inbounds %class.b3Vector3, ptr %normal, i32 0, i32 0
  %z157 = getelementptr inbounds %struct.anon.2, ptr %173, i32 0, i32 2
  %174 = load float, ptr %z157, align 8
  %175 = load i32, ptr %fidx, align 4
  %idxprom158 = sext i32 %175 to i64
  %arrayidx159 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 %idxprom158
  %m_plane160 = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx159, i32 0, i32 0
  %176 = getelementptr inbounds %class.b3Vector3, ptr %m_plane160, i32 0, i32 0
  %z161 = getelementptr inbounds %struct.anon.2, ptr %176, i32 0, i32 2
  store float %174, ptr %z161, align 8
  %177 = load float, ptr %c, align 4
  %178 = load i32, ptr %fidx, align 4
  %idxprom162 = sext i32 %178 to i64
  %arrayidx163 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 %idxprom162
  %m_plane164 = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx163, i32 0, i32 0
  %179 = getelementptr inbounds %class.b3Vector3, ptr %m_plane164, i32 0, i32 0
  %w165 = getelementptr inbounds %struct.anon.2, ptr %179, i32 0, i32 3
  store float %177, ptr %w165, align 4
  %180 = load i32, ptr %fidx, align 4
  %idxprom166 = sext i32 %180 to i64
  %arrayidx167 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 %idxprom166
  %m_numIndices = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx167, i32 0, i32 2
  store i32 3, ptr %m_numIndices, align 4
  %181 = load i32, ptr %fidx, align 4
  %inc168 = add nsw i32 %181, 1
  store i32 %inc168, ptr %fidx, align 4
  %182 = load i32, ptr %curUsedIndices, align 4
  %183 = load i32, ptr %fidx, align 4
  %idxprom169 = sext i32 %183 to i64
  %arrayidx170 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 %idxprom169
  %m_indexOffset171 = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx170, i32 0, i32 1
  store i32 %182, ptr %m_indexOffset171, align 16
  %arrayidx172 = getelementptr inbounds [12 x i32], ptr %indicesA, i64 0, i64 3
  store i32 2, ptr %arrayidx172, align 4
  %arrayidx173 = getelementptr inbounds [12 x i32], ptr %indicesA, i64 0, i64 4
  store i32 1, ptr %arrayidx173, align 16
  %arrayidx174 = getelementptr inbounds [12 x i32], ptr %indicesA, i64 0, i64 5
  store i32 0, ptr %arrayidx174, align 4
  %184 = load i32, ptr %curUsedIndices, align 4
  %add175 = add nsw i32 %184, 3
  store i32 %add175, ptr %curUsedIndices, align 4
  %arrayidx177 = getelementptr inbounds [3 x %class.b3Vector3], ptr %verticesA, i64 0, i64 0
  %call178 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %normal, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx177)
  store float %call178, ptr %c176, align 4
  %185 = getelementptr inbounds %class.b3Vector3, ptr %normal, i32 0, i32 0
  %x179 = getelementptr inbounds %struct.anon.2, ptr %185, i32 0, i32 0
  %186 = load float, ptr %x179, align 16
  %fneg = fneg float %186
  %187 = load i32, ptr %fidx, align 4
  %idxprom180 = sext i32 %187 to i64
  %arrayidx181 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 %idxprom180
  %m_plane182 = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx181, i32 0, i32 0
  %188 = getelementptr inbounds %class.b3Vector3, ptr %m_plane182, i32 0, i32 0
  %x183 = getelementptr inbounds %struct.anon.2, ptr %188, i32 0, i32 0
  store float %fneg, ptr %x183, align 16
  %189 = getelementptr inbounds %class.b3Vector3, ptr %normal, i32 0, i32 0
  %y184 = getelementptr inbounds %struct.anon.2, ptr %189, i32 0, i32 1
  %190 = load float, ptr %y184, align 4
  %fneg185 = fneg float %190
  %191 = load i32, ptr %fidx, align 4
  %idxprom186 = sext i32 %191 to i64
  %arrayidx187 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 %idxprom186
  %m_plane188 = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx187, i32 0, i32 0
  %192 = getelementptr inbounds %class.b3Vector3, ptr %m_plane188, i32 0, i32 0
  %y189 = getelementptr inbounds %struct.anon.2, ptr %192, i32 0, i32 1
  store float %fneg185, ptr %y189, align 4
  %193 = getelementptr inbounds %class.b3Vector3, ptr %normal, i32 0, i32 0
  %z190 = getelementptr inbounds %struct.anon.2, ptr %193, i32 0, i32 2
  %194 = load float, ptr %z190, align 8
  %fneg191 = fneg float %194
  %195 = load i32, ptr %fidx, align 4
  %idxprom192 = sext i32 %195 to i64
  %arrayidx193 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 %idxprom192
  %m_plane194 = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx193, i32 0, i32 0
  %196 = getelementptr inbounds %class.b3Vector3, ptr %m_plane194, i32 0, i32 0
  %z195 = getelementptr inbounds %struct.anon.2, ptr %196, i32 0, i32 2
  store float %fneg191, ptr %z195, align 8
  %197 = load float, ptr %c176, align 4
  %198 = load i32, ptr %fidx, align 4
  %idxprom196 = sext i32 %198 to i64
  %arrayidx197 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 %idxprom196
  %m_plane198 = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx197, i32 0, i32 0
  %199 = getelementptr inbounds %class.b3Vector3, ptr %m_plane198, i32 0, i32 0
  %w199 = getelementptr inbounds %struct.anon.2, ptr %199, i32 0, i32 3
  store float %197, ptr %w199, align 4
  %200 = load i32, ptr %fidx, align 4
  %idxprom200 = sext i32 %200 to i64
  %arrayidx201 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 %idxprom200
  %m_numIndices202 = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx201, i32 0, i32 2
  store i32 3, ptr %m_numIndices202, align 4
  %201 = load i32, ptr %fidx, align 4
  %inc203 = add nsw i32 %201, 1
  store i32 %inc203, ptr %fidx, align 4
  store i8 1, ptr %addEdgePlanes, align 1
  %202 = load i8, ptr %addEdgePlanes, align 1
  %tobool204 = trunc i8 %202 to i1
  br i1 %tobool204, label %if.then205, label %if.end263

if.then205:                                       ; preds = %if.then103
  store i32 3, ptr %numVertices, align 4
  %203 = load i32, ptr %numVertices, align 4
  %sub = sub nsw i32 %203, 1
  store i32 %sub, ptr %prevVertex, align 4
  store i32 0, ptr %i206, align 4
  br label %for.cond207

for.cond207:                                      ; preds = %for.inc260, %if.then205
  %204 = load i32, ptr %i206, align 4
  %205 = load i32, ptr %numVertices, align 4
  %cmp208 = icmp slt i32 %204, %205
  br i1 %cmp208, label %for.body209, label %for.end262

for.body209:                                      ; preds = %for.cond207
  %206 = load i32, ptr %i206, align 4
  %idxprom210 = sext i32 %206 to i64
  %arrayidx211 = getelementptr inbounds [3 x %class.b3Vector3], ptr %verticesA, i64 0, i64 %idxprom210
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %v0, ptr align 16 %arrayidx211, i64 16, i1 false)
  %207 = load i32, ptr %prevVertex, align 4
  %idxprom212 = sext i32 %207 to i64
  %arrayidx213 = getelementptr inbounds [3 x %class.b3Vector3], ptr %verticesA, i64 0, i64 %idxprom212
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %v1, ptr align 16 %arrayidx213, i64 16, i1 false)
  %call216 = call { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %v1, ptr noundef nonnull align 16 dereferenceable(16) %v0)
  %coerce.dive217 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp215, i32 0, i32 0
  %coerce.dive218 = getelementptr inbounds %union.anon.1, ptr %coerce.dive217, i32 0, i32 0
  %208 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive218, i32 0, i32 0
  %209 = extractvalue { <2 x float>, <2 x float> } %call216, 0
  store <2 x float> %209, ptr %208, align 16
  %210 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive218, i32 0, i32 1
  %211 = extractvalue { <2 x float>, <2 x float> } %call216, 1
  store <2 x float> %211, ptr %210, align 8
  %call219 = call { <2 x float>, <2 x float> } @_Z7b3CrossRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %normal, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp215)
  %coerce.dive220 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp214, i32 0, i32 0
  %coerce.dive221 = getelementptr inbounds %union.anon.1, ptr %coerce.dive220, i32 0, i32 0
  %212 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive221, i32 0, i32 0
  %213 = extractvalue { <2 x float>, <2 x float> } %call219, 0
  store <2 x float> %213, ptr %212, align 16
  %214 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive221, i32 0, i32 1
  %215 = extractvalue { <2 x float>, <2 x float> } %call219, 1
  store <2 x float> %215, ptr %214, align 8
  %call222 = call { <2 x float>, <2 x float> } @_Z12b3NormalizedRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp214)
  %coerce.dive223 = getelementptr inbounds %class.b3Vector3, ptr %edgeNormal, i32 0, i32 0
  %coerce.dive224 = getelementptr inbounds %union.anon.1, ptr %coerce.dive223, i32 0, i32 0
  %216 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive224, i32 0, i32 0
  %217 = extractvalue { <2 x float>, <2 x float> } %call222, 0
  store <2 x float> %217, ptr %216, align 16
  %218 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive224, i32 0, i32 1
  %219 = extractvalue { <2 x float>, <2 x float> } %call222, 1
  store <2 x float> %219, ptr %218, align 8
  %call226 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %edgeNormal, ptr noundef nonnull align 16 dereferenceable(16) %v0)
  %fneg227 = fneg float %call226
  store float %fneg227, ptr %c225, align 4
  %220 = load i32, ptr %fidx, align 4
  %idxprom228 = sext i32 %220 to i64
  %arrayidx229 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 %idxprom228
  %m_numIndices230 = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx229, i32 0, i32 2
  store i32 2, ptr %m_numIndices230, align 4
  %221 = load i32, ptr %curUsedIndices, align 4
  %222 = load i32, ptr %fidx, align 4
  %idxprom231 = sext i32 %222 to i64
  %arrayidx232 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 %idxprom231
  %m_indexOffset233 = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx232, i32 0, i32 1
  store i32 %221, ptr %m_indexOffset233, align 16
  %223 = load i32, ptr %i206, align 4
  %224 = load i32, ptr %curUsedIndices, align 4
  %inc234 = add nsw i32 %224, 1
  store i32 %inc234, ptr %curUsedIndices, align 4
  %idxprom235 = sext i32 %224 to i64
  %arrayidx236 = getelementptr inbounds [12 x i32], ptr %indicesA, i64 0, i64 %idxprom235
  store i32 %223, ptr %arrayidx236, align 4
  %225 = load i32, ptr %prevVertex, align 4
  %226 = load i32, ptr %curUsedIndices, align 4
  %inc237 = add nsw i32 %226, 1
  store i32 %inc237, ptr %curUsedIndices, align 4
  %idxprom238 = sext i32 %226 to i64
  %arrayidx239 = getelementptr inbounds [12 x i32], ptr %indicesA, i64 0, i64 %idxprom238
  store i32 %225, ptr %arrayidx239, align 4
  %227 = getelementptr inbounds %class.b3Vector3, ptr %edgeNormal, i32 0, i32 0
  %x240 = getelementptr inbounds %struct.anon.2, ptr %227, i32 0, i32 0
  %228 = load float, ptr %x240, align 16
  %229 = load i32, ptr %fidx, align 4
  %idxprom241 = sext i32 %229 to i64
  %arrayidx242 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 %idxprom241
  %m_plane243 = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx242, i32 0, i32 0
  %230 = getelementptr inbounds %class.b3Vector3, ptr %m_plane243, i32 0, i32 0
  %x244 = getelementptr inbounds %struct.anon.2, ptr %230, i32 0, i32 0
  store float %228, ptr %x244, align 16
  %231 = getelementptr inbounds %class.b3Vector3, ptr %edgeNormal, i32 0, i32 0
  %y245 = getelementptr inbounds %struct.anon.2, ptr %231, i32 0, i32 1
  %232 = load float, ptr %y245, align 4
  %233 = load i32, ptr %fidx, align 4
  %idxprom246 = sext i32 %233 to i64
  %arrayidx247 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 %idxprom246
  %m_plane248 = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx247, i32 0, i32 0
  %234 = getelementptr inbounds %class.b3Vector3, ptr %m_plane248, i32 0, i32 0
  %y249 = getelementptr inbounds %struct.anon.2, ptr %234, i32 0, i32 1
  store float %232, ptr %y249, align 4
  %235 = getelementptr inbounds %class.b3Vector3, ptr %edgeNormal, i32 0, i32 0
  %z250 = getelementptr inbounds %struct.anon.2, ptr %235, i32 0, i32 2
  %236 = load float, ptr %z250, align 8
  %237 = load i32, ptr %fidx, align 4
  %idxprom251 = sext i32 %237 to i64
  %arrayidx252 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 %idxprom251
  %m_plane253 = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx252, i32 0, i32 0
  %238 = getelementptr inbounds %class.b3Vector3, ptr %m_plane253, i32 0, i32 0
  %z254 = getelementptr inbounds %struct.anon.2, ptr %238, i32 0, i32 2
  store float %236, ptr %z254, align 8
  %239 = load float, ptr %c225, align 4
  %240 = load i32, ptr %fidx, align 4
  %idxprom255 = sext i32 %240 to i64
  %arrayidx256 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 %idxprom255
  %m_plane257 = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx256, i32 0, i32 0
  %241 = getelementptr inbounds %class.b3Vector3, ptr %m_plane257, i32 0, i32 0
  %w258 = getelementptr inbounds %struct.anon.2, ptr %241, i32 0, i32 3
  store float %239, ptr %w258, align 4
  %242 = load i32, ptr %fidx, align 4
  %inc259 = add nsw i32 %242, 1
  store i32 %inc259, ptr %fidx, align 4
  %243 = load i32, ptr %i206, align 4
  store i32 %243, ptr %prevVertex, align 4
  br label %for.inc260

for.inc260:                                       ; preds = %for.body209
  %244 = load i32, ptr %i206, align 4
  %inc261 = add nsw i32 %244, 1
  store i32 %inc261, ptr %i206, align 4
  br label %for.cond207, !llvm.loop !15

for.end262:                                       ; preds = %for.cond207
  br label %if.end263

if.end263:                                        ; preds = %for.end262, %if.then103
  %m_numFaces = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexPolyhedronA, i32 0, i32 6
  store i32 5, ptr %m_numFaces, align 8
  store float 0x3FD5555560000000, ptr %ref.tmp265, align 4
  %call266 = call { <2 x float>, <2 x float> } @_ZmlRK9b3Vector3RKf(ptr noundef nonnull align 16 dereferenceable(16) %localCenter, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp265)
  %coerce.dive267 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp264, i32 0, i32 0
  %coerce.dive268 = getelementptr inbounds %union.anon.1, ptr %coerce.dive267, i32 0, i32 0
  %245 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive268, i32 0, i32 0
  %246 = extractvalue { <2 x float>, <2 x float> } %call266, 0
  store <2 x float> %246, ptr %245, align 16
  %247 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive268, i32 0, i32 1
  %248 = extractvalue { <2 x float>, <2 x float> } %call266, 1
  store <2 x float> %248, ptr %247, align 8
  %m_localCenter = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexPolyhedronA, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %m_localCenter, ptr align 16 %ref.tmp264, i64 16, i1 false)
  %249 = load ptr, ptr %rigidBodies.addr, align 8
  %250 = load i32, ptr %bodyIndexA, align 4
  %idxprom269 = sext i32 %250 to i64
  %arrayidx270 = getelementptr inbounds %struct.b3RigidBodyData, ptr %249, i64 %idxprom269
  %m_pos = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx270, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posA, ptr align 16 %m_pos, i64 16, i1 false)
  %251 = getelementptr inbounds %class.b3Vector3, ptr %posA, i32 0, i32 0
  %w271 = getelementptr inbounds %struct.anon.2, ptr %251, i32 0, i32 3
  store float 0.000000e+00, ptr %w271, align 4
  %252 = load ptr, ptr %rigidBodies.addr, align 8
  %253 = load i32, ptr %bodyIndexB, align 4
  %idxprom272 = sext i32 %253 to i64
  %arrayidx273 = getelementptr inbounds %struct.b3RigidBodyData, ptr %252, i64 %idxprom272
  %m_pos274 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx273, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posB, ptr align 16 %m_pos274, i64 16, i1 false)
  %254 = getelementptr inbounds %class.b3Vector3, ptr %posB, i32 0, i32 0
  %w275 = getelementptr inbounds %struct.anon.2, ptr %254, i32 0, i32 3
  store float 0.000000e+00, ptr %w275, align 4
  %255 = load ptr, ptr %rigidBodies.addr, align 8
  %256 = load i32, ptr %bodyIndexA, align 4
  %idxprom276 = sext i32 %256 to i64
  %arrayidx277 = getelementptr inbounds %struct.b3RigidBodyData, ptr %255, i64 %idxprom276
  %m_quat = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx277, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornA, ptr align 16 %m_quat, i64 16, i1 false)
  %257 = load ptr, ptr %rigidBodies.addr, align 8
  %258 = load i32, ptr %bodyIndexB, align 4
  %idxprom278 = sext i32 %258 to i64
  %arrayidx279 = getelementptr inbounds %struct.b3RigidBodyData, ptr %257, i64 %idxprom278
  %m_quat280 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx279, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornB, ptr align 16 %m_quat280, i64 16, i1 false)
  %259 = load ptr, ptr %collidables.addr, align 8
  %260 = load i32, ptr %collidableIndexB, align 4
  %idxprom281 = sext i32 %260 to i64
  %arrayidx282 = getelementptr inbounds %struct.b3Collidable, ptr %259, i64 %idxprom281
  %m_shapeType283 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx282, i32 0, i32 2
  %261 = load i32, ptr %m_shapeType283, align 4
  %cmp284 = icmp eq i32 %261, 6
  br i1 %cmp284, label %if.then285, label %if.end304

if.then285:                                       ; preds = %if.end263
  %262 = load ptr, ptr %concavePairs.addr, align 8
  %263 = load i32, ptr %pairIdx.addr, align 4
  %idxprom286 = sext i32 %263 to i64
  %arrayidx287 = getelementptr inbounds %struct.b3Int4, ptr %262, i64 %idxprom286
  %264 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx287, i32 0, i32 0
  %w288 = getelementptr inbounds %struct.anon, ptr %264, i32 0, i32 3
  %265 = load i32, ptr %w288, align 4
  store i32 %265, ptr %compoundChild, align 4
  %266 = load i32, ptr %compoundChild, align 4
  store i32 %266, ptr %childShapeIndexB, align 4
  %267 = load ptr, ptr %gpuChildShapes.addr, align 8
  %268 = load i32, ptr %childShapeIndexB, align 4
  %idxprom289 = sext i32 %268 to i64
  %arrayidx290 = getelementptr inbounds %struct.b3GpuChildShape, ptr %267, i64 %idxprom289
  %269 = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx290, i32 0, i32 2
  %270 = load i32, ptr %269, align 16
  store i32 %270, ptr %childColIndexB, align 4
  %271 = load ptr, ptr %gpuChildShapes.addr, align 8
  %272 = load i32, ptr %childShapeIndexB, align 4
  %idxprom291 = sext i32 %272 to i64
  %arrayidx292 = getelementptr inbounds %struct.b3GpuChildShape, ptr %271, i64 %idxprom291
  %m_childPosition = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx292, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %childPosB, ptr align 16 %m_childPosition, i64 16, i1 false)
  %273 = load ptr, ptr %gpuChildShapes.addr, align 8
  %274 = load i32, ptr %childShapeIndexB, align 4
  %idxprom293 = sext i32 %274 to i64
  %arrayidx294 = getelementptr inbounds %struct.b3GpuChildShape, ptr %273, i64 %idxprom293
  %m_childOrientation = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx294, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %childOrnB, ptr align 16 %m_childOrientation, i64 16, i1 false)
  %call295 = call { <2 x float>, <2 x float> } @_Z16b3TransformPointRK9b3Vector3S1_RK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(16) %childPosB, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB)
  %coerce.dive296 = getelementptr inbounds %class.b3Vector3, ptr %newPosB, i32 0, i32 0
  %coerce.dive297 = getelementptr inbounds %union.anon.1, ptr %coerce.dive296, i32 0, i32 0
  %275 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive297, i32 0, i32 0
  %276 = extractvalue { <2 x float>, <2 x float> } %call295, 0
  store <2 x float> %276, ptr %275, align 16
  %277 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive297, i32 0, i32 1
  %278 = extractvalue { <2 x float>, <2 x float> } %call295, 1
  store <2 x float> %278, ptr %277, align 8
  %call298 = call { <2 x float>, <2 x float> } @_Z9b3QuatMulRK12b3QuaternionS1_(ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %childOrnB)
  %coerce.dive299 = getelementptr inbounds %class.b3Quaternion, ptr %newOrnB, i32 0, i32 0
  %coerce.dive300 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive299, i32 0, i32 0
  %coerce.dive301 = getelementptr inbounds %union.anon.3, ptr %coerce.dive300, i32 0, i32 0
  %279 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive301, i32 0, i32 0
  %280 = extractvalue { <2 x float>, <2 x float> } %call298, 0
  store <2 x float> %280, ptr %279, align 16
  %281 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive301, i32 0, i32 1
  %282 = extractvalue { <2 x float>, <2 x float> } %call298, 1
  store <2 x float> %282, ptr %281, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posB, ptr align 16 %newPosB, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornB, ptr align 16 %newOrnB, i64 16, i1 false)
  %283 = load ptr, ptr %collidables.addr, align 8
  %284 = load i32, ptr %childColIndexB, align 4
  %idxprom302 = sext i32 %284 to i64
  %arrayidx303 = getelementptr inbounds %struct.b3Collidable, ptr %283, i64 %idxprom302
  %285 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx303, i32 0, i32 3
  %286 = load i32, ptr %285, align 4
  store i32 %286, ptr %shapeIndexB, align 4
  br label %if.end304

if.end304:                                        ; preds = %if.then285, %if.end263
  %m_localCenter305 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexPolyhedronA, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %c0local, ptr align 16 %m_localCenter305, i64 16, i1 false)
  %call306 = call { <2 x float>, <2 x float> } @_Z16b3TransformPointRK9b3Vector3S1_RK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(16) %c0local, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA)
  %coerce.dive307 = getelementptr inbounds %class.b3Vector3, ptr %c0, i32 0, i32 0
  %coerce.dive308 = getelementptr inbounds %union.anon.1, ptr %coerce.dive307, i32 0, i32 0
  %287 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive308, i32 0, i32 0
  %288 = extractvalue { <2 x float>, <2 x float> } %call306, 0
  store <2 x float> %288, ptr %287, align 16
  %289 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive308, i32 0, i32 1
  %290 = extractvalue { <2 x float>, <2 x float> } %call306, 1
  store <2 x float> %290, ptr %289, align 8
  %291 = load ptr, ptr %convexShapes.addr, align 8
  %292 = load i32, ptr %shapeIndexB, align 4
  %idxprom309 = sext i32 %292 to i64
  %arrayidx310 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %291, i64 %idxprom309
  %m_localCenter311 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %arrayidx310, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %c1local, ptr align 16 %m_localCenter311, i64 16, i1 false)
  %call312 = call { <2 x float>, <2 x float> } @_Z16b3TransformPointRK9b3Vector3S1_RK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(16) %c1local, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB)
  %coerce.dive313 = getelementptr inbounds %class.b3Vector3, ptr %c1, i32 0, i32 0
  %coerce.dive314 = getelementptr inbounds %union.anon.1, ptr %coerce.dive313, i32 0, i32 0
  %293 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive314, i32 0, i32 0
  %294 = extractvalue { <2 x float>, <2 x float> } %call312, 0
  store <2 x float> %294, ptr %293, align 16
  %295 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive314, i32 0, i32 1
  %296 = extractvalue { <2 x float>, <2 x float> } %call312, 1
  store <2 x float> %296, ptr %295, align 8
  %call315 = call { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %c0, ptr noundef nonnull align 16 dereferenceable(16) %c1)
  %coerce.dive316 = getelementptr inbounds %class.b3Vector3, ptr %DeltaC2, i32 0, i32 0
  %coerce.dive317 = getelementptr inbounds %union.anon.1, ptr %coerce.dive316, i32 0, i32 0
  %297 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive317, i32 0, i32 0
  %298 = extractvalue { <2 x float>, <2 x float> } %call315, 0
  store <2 x float> %298, ptr %297, align 16
  %299 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive317, i32 0, i32 1
  %300 = extractvalue { <2 x float>, <2 x float> } %call315, 1
  store <2 x float> %300, ptr %299, align 8
  %301 = load ptr, ptr %convexShapes.addr, align 8
  %302 = load i32, ptr %shapeIndexB, align 4
  %idxprom318 = sext i32 %302 to i64
  %arrayidx319 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %301, i64 %idxprom318
  %arraydecay = getelementptr inbounds [3 x %class.b3Vector3], ptr %verticesA, i64 0, i64 0
  %arraydecay320 = getelementptr inbounds [3 x %class.b3Vector3], ptr %uniqueEdgesA, i64 0, i64 0
  %arraydecay321 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 0
  %arraydecay322 = getelementptr inbounds [12 x i32], ptr %indicesA, i64 0, i64 0
  %303 = load ptr, ptr %vertices.addr, align 8
  %304 = load ptr, ptr %uniqueEdges.addr, align 8
  %305 = load ptr, ptr %faces.addr, align 8
  %306 = load ptr, ptr %indices.addr, align 8
  %call323 = call noundef zeroext i1 @_Z20b3FindSeparatingAxisPK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_Pf(ptr noundef %convexPolyhedronA, ptr noundef %arrayidx319, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %DeltaC2, ptr noundef %arraydecay, ptr noundef %arraydecay320, ptr noundef %arraydecay321, ptr noundef %arraydecay322, ptr noundef %303, ptr noundef %304, ptr noundef %305, ptr noundef %306, ptr noundef %sepAxis, ptr noundef %dmin)
  %frombool324 = zext i1 %call323 to i8
  store i8 %frombool324, ptr %sepA, align 1
  store i32 4, ptr %hasSeparatingAxis, align 4
  %307 = load i8, ptr %sepA, align 1
  %tobool325 = trunc i8 %307 to i1
  br i1 %tobool325, label %if.else, label %if.then326

if.then326:                                       ; preds = %if.end304
  store i32 0, ptr %hasSeparatingAxis, align 4
  br label %if.end351

if.else:                                          ; preds = %if.end304
  %308 = load ptr, ptr %convexShapes.addr, align 8
  %309 = load i32, ptr %shapeIndexB, align 4
  %idxprom327 = sext i32 %309 to i64
  %arrayidx328 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %308, i64 %idxprom327
  %310 = load ptr, ptr %vertices.addr, align 8
  %311 = load ptr, ptr %uniqueEdges.addr, align 8
  %312 = load ptr, ptr %faces.addr, align 8
  %313 = load ptr, ptr %indices.addr, align 8
  %arraydecay329 = getelementptr inbounds [3 x %class.b3Vector3], ptr %verticesA, i64 0, i64 0
  %arraydecay330 = getelementptr inbounds [3 x %class.b3Vector3], ptr %uniqueEdgesA, i64 0, i64 0
  %arraydecay331 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 0
  %arraydecay332 = getelementptr inbounds [12 x i32], ptr %indicesA, i64 0, i64 0
  %call333 = call noundef zeroext i1 @_Z20b3FindSeparatingAxisPK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_Pf(ptr noundef %arrayidx328, ptr noundef %convexPolyhedronA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %DeltaC2, ptr noundef %310, ptr noundef %311, ptr noundef %312, ptr noundef %313, ptr noundef %arraydecay329, ptr noundef %arraydecay330, ptr noundef %arraydecay331, ptr noundef %arraydecay332, ptr noundef %sepAxis, ptr noundef %dmin)
  %frombool334 = zext i1 %call333 to i8
  store i8 %frombool334, ptr %sepB, align 1
  %314 = load i8, ptr %sepB, align 1
  %tobool335 = trunc i8 %314 to i1
  br i1 %tobool335, label %if.else337, label %if.then336

if.then336:                                       ; preds = %if.else
  store i32 0, ptr %hasSeparatingAxis, align 4
  br label %if.end350

if.else337:                                       ; preds = %if.else
  %315 = load ptr, ptr %convexShapes.addr, align 8
  %316 = load i32, ptr %shapeIndexB, align 4
  %idxprom338 = sext i32 %316 to i64
  %arrayidx339 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %315, i64 %idxprom338
  %arraydecay340 = getelementptr inbounds [3 x %class.b3Vector3], ptr %verticesA, i64 0, i64 0
  %arraydecay341 = getelementptr inbounds [3 x %class.b3Vector3], ptr %uniqueEdgesA, i64 0, i64 0
  %arraydecay342 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 0
  %arraydecay343 = getelementptr inbounds [12 x i32], ptr %indicesA, i64 0, i64 0
  %317 = load ptr, ptr %vertices.addr, align 8
  %318 = load ptr, ptr %uniqueEdges.addr, align 8
  %319 = load ptr, ptr %faces.addr, align 8
  %320 = load ptr, ptr %indices.addr, align 8
  %call344 = call noundef zeroext i1 @_Z28b3FindSeparatingAxisEdgeEdgePK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_Pfb(ptr noundef %convexPolyhedronA, ptr noundef %arrayidx339, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %DeltaC2, ptr noundef %arraydecay340, ptr noundef %arraydecay341, ptr noundef %arraydecay342, ptr noundef %arraydecay343, ptr noundef %317, ptr noundef %318, ptr noundef %319, ptr noundef %320, ptr noundef %sepAxis, ptr noundef %dmin, i1 noundef zeroext true)
  %frombool345 = zext i1 %call344 to i8
  store i8 %frombool345, ptr %sepEE, align 1
  %321 = load i8, ptr %sepEE, align 1
  %tobool346 = trunc i8 %321 to i1
  br i1 %tobool346, label %if.else348, label %if.then347

if.then347:                                       ; preds = %if.else337
  store i32 0, ptr %hasSeparatingAxis, align 4
  br label %if.end349

if.else348:                                       ; preds = %if.else337
  store i32 1, ptr %hasSeparatingAxis, align 4
  br label %if.end349

if.end349:                                        ; preds = %if.else348, %if.then347
  br label %if.end350

if.end350:                                        ; preds = %if.end349, %if.then336
  br label %if.end351

if.end351:                                        ; preds = %if.end350, %if.then326
  %322 = load i32, ptr %hasSeparatingAxis, align 4
  %tobool352 = icmp ne i32 %322, 0
  br i1 %tobool352, label %if.then353, label %if.else365

if.then353:                                       ; preds = %if.end351
  %323 = load ptr, ptr %hasSeparatingNormals.addr, align 8
  %324 = load i32, ptr %i, align 4
  %idxprom354 = sext i32 %324 to i64
  %arrayidx355 = getelementptr inbounds i32, ptr %323, i64 %idxprom354
  store i32 1, ptr %arrayidx355, align 4
  %325 = load float, ptr %dmin, align 4
  %326 = getelementptr inbounds %class.b3Vector3, ptr %sepAxis, i32 0, i32 0
  %w356 = getelementptr inbounds %struct.anon.2, ptr %326, i32 0, i32 3
  store float %325, ptr %w356, align 4
  %327 = load ptr, ptr %concaveSeparatingNormalsOut.addr, align 8
  %328 = load i32, ptr %pairIdx.addr, align 4
  %idxprom357 = sext i32 %328 to i64
  %arrayidx358 = getelementptr inbounds %class.b3Vector3, ptr %327, i64 %idxprom357
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx358, ptr align 16 %sepAxis, i64 16, i1 false)
  store float 0xC6293E5940000000, ptr %minDist, align 4
  store float 0x3F947AE140000000, ptr %maxDist, align 4
  %329 = load ptr, ptr %convexShapes.addr, align 8
  %330 = load i32, ptr %shapeIndexB, align 4
  %idxprom359 = sext i32 %330 to i64
  %arrayidx360 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %329, i64 %idxprom359
  %331 = load ptr, ptr %worldVertsA1Out.addr, align 8
  %332 = load ptr, ptr %worldNormalsA1Out.addr, align 8
  %333 = load ptr, ptr %worldVertsB1Out.addr, align 8
  %334 = load i32, ptr %vertexFaceCapacity.addr, align 4
  %335 = load float, ptr %minDist, align 4
  %336 = load float, ptr %maxDist, align 4
  %arraydecay361 = getelementptr inbounds [3 x %class.b3Vector3], ptr %verticesA, i64 0, i64 0
  %arraydecay362 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 0
  %arraydecay363 = getelementptr inbounds [12 x i32], ptr %indicesA, i64 0, i64 0
  %337 = load ptr, ptr %vertices.addr, align 8
  %338 = load ptr, ptr %faces.addr, align 8
  %339 = load ptr, ptr %indices.addr, align 8
  %340 = load ptr, ptr %clippingFacesOut.addr, align 8
  %341 = load i32, ptr %pairIdx.addr, align 4
  %call364 = call noundef i32 @_Z19b3FindClippingFacesRK9b3Vector3PK22b3ConvexPolyhedronDataS4_S1_RK12b3QuaternionS1_S7_PS_S8_S8_iffPS0_PK9b3GpuFacePKiS9_SC_SE_P6b3Int4i(ptr noundef nonnull align 16 dereferenceable(16) %sepAxis, ptr noundef %convexPolyhedronA, ptr noundef %arrayidx360, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef %331, ptr noundef %332, ptr noundef %333, i32 noundef %334, float noundef %335, float noundef %336, ptr noundef %arraydecay361, ptr noundef %arraydecay362, ptr noundef %arraydecay363, ptr noundef %337, ptr noundef %338, ptr noundef %339, ptr noundef %340, i32 noundef %341)
  br label %if.end369

if.else365:                                       ; preds = %if.end351
  %342 = load ptr, ptr %concavePairs.addr, align 8
  %343 = load i32, ptr %pairIdx.addr, align 4
  %idxprom366 = sext i32 %343 to i64
  %arrayidx367 = getelementptr inbounds %struct.b3Int4, ptr %342, i64 %idxprom366
  %344 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx367, i32 0, i32 0
  %w368 = getelementptr inbounds %struct.anon, ptr %344, i32 0, i32 3
  store i32 -1, ptr %w368, align 4
  br label %if.end369

if.end369:                                        ; preds = %if.else365, %if.then353
  br label %if.end374

if.else370:                                       ; preds = %cond.end99
  %345 = load ptr, ptr %concavePairs.addr, align 8
  %346 = load i32, ptr %pairIdx.addr, align 4
  %idxprom371 = sext i32 %346 to i64
  %arrayidx372 = getelementptr inbounds %struct.b3Int4, ptr %345, i64 %idxprom371
  %347 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx372, i32 0, i32 0
  %w373 = getelementptr inbounds %struct.anon, ptr %347, i32 0, i32 3
  store i32 -1, ptr %w373, align 4
  br label %if.end374

if.end374:                                        ; preds = %if.else370, %if.end369, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef %x, float noundef %y, float noundef %z, float noundef %w) #3 comdat {
entry:
  %retval = alloca %class.b3Vector3, align 16
  %x.addr = alloca float, align 4
  %y.addr = alloca float, align 4
  %z.addr = alloca float, align 4
  %w.addr = alloca float, align 4
  store float %x, ptr %x.addr, align 4
  store float %y, ptr %y.addr, align 4
  store float %z, ptr %z.addr, align 4
  store float %w, ptr %w.addr, align 4
  call void @_ZN9b3Vector38setValueERKfS1_S1_(ptr noundef nonnull align 16 dereferenceable(16) %retval, ptr noundef nonnull align 4 dereferenceable(4) %x.addr, ptr noundef nonnull align 4 dereferenceable(4) %y.addr, ptr noundef nonnull align 4 dereferenceable(4) %z.addr)
  %0 = load float, ptr %w.addr, align 4
  %1 = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %w1 = getelementptr inbounds %struct.anon.2, ptr %1, i32 0, i32 3
  store float %0, ptr %w1, align 4
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %2 = load { <2 x float>, <2 x float> }, ptr %coerce.dive2, align 16
  ret { <2 x float>, <2 x float> } %2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector3pLERKS_(ptr noundef nonnull align 16 dereferenceable(16) %this, ptr noundef nonnull align 16 dereferenceable(16) %v) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %v.addr, align 8
  %1 = getelementptr inbounds %class.b3Vector3, ptr %0, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x float], ptr %1, i64 0, i64 0
  %2 = load float, ptr %arrayidx, align 16
  %3 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [4 x float], ptr %3, i64 0, i64 0
  %4 = load float, ptr %arrayidx2, align 16
  %add = fadd float %4, %2
  store float %add, ptr %arrayidx2, align 16
  %5 = load ptr, ptr %v.addr, align 8
  %6 = getelementptr inbounds %class.b3Vector3, ptr %5, i32 0, i32 0
  %arrayidx3 = getelementptr inbounds [4 x float], ptr %6, i64 0, i64 1
  %7 = load float, ptr %arrayidx3, align 4
  %8 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [4 x float], ptr %8, i64 0, i64 1
  %9 = load float, ptr %arrayidx4, align 4
  %add5 = fadd float %9, %7
  store float %add5, ptr %arrayidx4, align 4
  %10 = load ptr, ptr %v.addr, align 8
  %11 = getelementptr inbounds %class.b3Vector3, ptr %10, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [4 x float], ptr %11, i64 0, i64 2
  %12 = load float, ptr %arrayidx6, align 8
  %13 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx7 = getelementptr inbounds [4 x float], ptr %13, i64 0, i64 2
  %14 = load float, ptr %arrayidx7, align 8
  %add8 = fadd float %14, %12
  store float %add8, ptr %arrayidx7, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_Z11b3MinFloat4RK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %a, ptr noundef nonnull align 16 dereferenceable(16) %b) #0 comdat {
entry:
  %retval = alloca %class.b3Vector3, align 16
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %retval, ptr align 16 %0, i64 16, i1 false)
  %1 = load ptr, ptr %b.addr, align 8
  call void @_ZN9b3Vector36setMinERKS_(ptr noundef nonnull align 16 dereferenceable(16) %retval, ptr noundef nonnull align 16 dereferenceable(16) %1)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive1 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %2 = load { <2 x float>, <2 x float> }, ptr %coerce.dive1, align 16
  ret { <2 x float>, <2 x float> } %2
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_Z11b3MaxFloat4RK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %a, ptr noundef nonnull align 16 dereferenceable(16) %b) #0 comdat {
entry:
  %retval = alloca %class.b3Vector3, align 16
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %retval, ptr align 16 %0, i64 16, i1 false)
  %1 = load ptr, ptr %b.addr, align 8
  call void @_ZN9b3Vector36setMaxERKS_(ptr noundef nonnull align 16 dereferenceable(16) %retval, ptr noundef nonnull align 16 dereferenceable(16) %1)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive1 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %2 = load { <2 x float>, <2 x float> }, ptr %coerce.dive1, align 16
  ret { <2 x float>, <2 x float> } %2
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %v1, ptr noundef nonnull align 16 dereferenceable(16) %v2) #2 comdat {
entry:
  %retval = alloca %class.b3Vector3, align 16
  %v1.addr = alloca ptr, align 8
  %v2.addr = alloca ptr, align 8
  store ptr %v1, ptr %v1.addr, align 8
  store ptr %v2, ptr %v2.addr, align 8
  %0 = load ptr, ptr %v1.addr, align 8
  %1 = getelementptr inbounds %class.b3Vector3, ptr %0, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x float], ptr %1, i64 0, i64 0
  %2 = load float, ptr %arrayidx, align 16
  %3 = load ptr, ptr %v2.addr, align 8
  %4 = getelementptr inbounds %class.b3Vector3, ptr %3, i32 0, i32 0
  %arrayidx1 = getelementptr inbounds [4 x float], ptr %4, i64 0, i64 0
  %5 = load float, ptr %arrayidx1, align 16
  %sub = fsub float %2, %5
  %6 = load ptr, ptr %v1.addr, align 8
  %7 = getelementptr inbounds %class.b3Vector3, ptr %6, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [4 x float], ptr %7, i64 0, i64 1
  %8 = load float, ptr %arrayidx2, align 4
  %9 = load ptr, ptr %v2.addr, align 8
  %10 = getelementptr inbounds %class.b3Vector3, ptr %9, i32 0, i32 0
  %arrayidx3 = getelementptr inbounds [4 x float], ptr %10, i64 0, i64 1
  %11 = load float, ptr %arrayidx3, align 4
  %sub4 = fsub float %8, %11
  %12 = load ptr, ptr %v1.addr, align 8
  %13 = getelementptr inbounds %class.b3Vector3, ptr %12, i32 0, i32 0
  %arrayidx5 = getelementptr inbounds [4 x float], ptr %13, i64 0, i64 2
  %14 = load float, ptr %arrayidx5, align 8
  %15 = load ptr, ptr %v2.addr, align 8
  %16 = getelementptr inbounds %class.b3Vector3, ptr %15, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [4 x float], ptr %16, i64 0, i64 2
  %17 = load float, ptr %arrayidx6, align 8
  %sub7 = fsub float %14, %17
  %call = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef %sub, float noundef %sub4, float noundef %sub7)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive8 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %18 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive8, i32 0, i32 0
  %19 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %19, ptr %18, align 16
  %20 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive8, i32 0, i32 1
  %21 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %21, ptr %20, align 8
  %coerce.dive9 = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive10 = getelementptr inbounds %union.anon.1, ptr %coerce.dive9, i32 0, i32 0
  %22 = load { <2 x float>, <2 x float> }, ptr %coerce.dive10, align 16
  ret { <2 x float>, <2 x float> } %22
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_ZmlRK9b3Vector3RKf(ptr noundef nonnull align 16 dereferenceable(16) %v, ptr noundef nonnull align 4 dereferenceable(4) %s) #2 comdat {
entry:
  %retval = alloca %class.b3Vector3, align 16
  %v.addr = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  store ptr %v, ptr %v.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %v.addr, align 8
  %1 = getelementptr inbounds %class.b3Vector3, ptr %0, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x float], ptr %1, i64 0, i64 0
  %2 = load float, ptr %arrayidx, align 16
  %3 = load ptr, ptr %s.addr, align 8
  %4 = load float, ptr %3, align 4
  %mul = fmul float %2, %4
  %5 = load ptr, ptr %v.addr, align 8
  %6 = getelementptr inbounds %class.b3Vector3, ptr %5, i32 0, i32 0
  %arrayidx1 = getelementptr inbounds [4 x float], ptr %6, i64 0, i64 1
  %7 = load float, ptr %arrayidx1, align 4
  %8 = load ptr, ptr %s.addr, align 8
  %9 = load float, ptr %8, align 4
  %mul2 = fmul float %7, %9
  %10 = load ptr, ptr %v.addr, align 8
  %11 = getelementptr inbounds %class.b3Vector3, ptr %10, i32 0, i32 0
  %arrayidx3 = getelementptr inbounds [4 x float], ptr %11, i64 0, i64 2
  %12 = load float, ptr %arrayidx3, align 8
  %13 = load ptr, ptr %s.addr, align 8
  %14 = load float, ptr %13, align 4
  %mul4 = fmul float %12, %14
  %call = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef %mul, float noundef %mul2, float noundef %mul4)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive5 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %15 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive5, i32 0, i32 0
  %16 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %16, ptr %15, align 16
  %17 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive5, i32 0, i32 1
  %18 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %18, ptr %17, align 8
  %coerce.dive6 = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive7 = getelementptr inbounds %union.anon.1, ptr %coerce.dive6, i32 0, i32 0
  %19 = load { <2 x float>, <2 x float> }, ptr %coerce.dive7, align 16
  ret { <2 x float>, <2 x float> } %19
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_Z16b3TransformPointRK9b3Vector3S1_RK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(16) %point, ptr noundef nonnull align 16 dereferenceable(16) %translation, ptr noundef nonnull align 16 dereferenceable(16) %orientation) #2 comdat {
entry:
  %retval = alloca %class.b3Vector3, align 16
  %point.addr = alloca ptr, align 8
  %translation.addr = alloca ptr, align 8
  %orientation.addr = alloca ptr, align 8
  %tr = alloca %class.b3Transform, align 16
  store ptr %point, ptr %point.addr, align 8
  store ptr %translation, ptr %translation.addr, align 8
  store ptr %orientation, ptr %orientation.addr, align 8
  call void @_ZN11b3TransformC2Ev(ptr noundef nonnull align 16 dereferenceable(64) %tr)
  %0 = load ptr, ptr %translation.addr, align 8
  call void @_ZN11b3Transform9setOriginERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %tr, ptr noundef nonnull align 16 dereferenceable(16) %0)
  %1 = load ptr, ptr %orientation.addr, align 8
  call void @_ZN11b3Transform11setRotationERK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(64) %tr, ptr noundef nonnull align 16 dereferenceable(16) %1)
  %2 = load ptr, ptr %point.addr, align 8
  %call = call { <2 x float>, <2 x float> } @_ZNK11b3TransformclERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %tr, ptr noundef nonnull align 16 dereferenceable(16) %2)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive1 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %3 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive1, i32 0, i32 0
  %4 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %4, ptr %3, align 16
  %5 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive1, i32 0, i32 1
  %6 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %6, ptr %5, align 8
  %coerce.dive2 = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %union.anon.1, ptr %coerce.dive2, i32 0, i32 0
  %7 = load { <2 x float>, <2 x float> }, ptr %coerce.dive3, align 16
  ret { <2 x float>, <2 x float> } %7
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_Z9b3QuatMulRK12b3QuaternionS1_(ptr noundef nonnull align 16 dereferenceable(16) %rot0, ptr noundef nonnull align 16 dereferenceable(16) %rot1) #2 comdat {
entry:
  %retval = alloca %class.b3Quaternion, align 16
  %rot0.addr = alloca ptr, align 8
  %rot1.addr = alloca ptr, align 8
  store ptr %rot0, ptr %rot0.addr, align 8
  store ptr %rot1, ptr %rot1.addr, align 8
  %0 = load ptr, ptr %rot0.addr, align 8
  %1 = load ptr, ptr %rot1.addr, align 8
  %call = call { <2 x float>, <2 x float> } @_ZmlRK12b3QuaternionS1_(ptr noundef nonnull align 16 dereferenceable(16) %0, ptr noundef nonnull align 16 dereferenceable(16) %1)
  %coerce.dive = getelementptr inbounds %class.b3Quaternion, ptr %retval, i32 0, i32 0
  %coerce.dive1 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %union.anon.3, ptr %coerce.dive1, i32 0, i32 0
  %2 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive2, i32 0, i32 0
  %3 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %3, ptr %2, align 16
  %4 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive2, i32 0, i32 1
  %5 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %5, ptr %4, align 8
  %coerce.dive3 = getelementptr inbounds %class.b3Quaternion, ptr %retval, i32 0, i32 0
  %coerce.dive4 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive3, i32 0, i32 0
  %coerce.dive5 = getelementptr inbounds %union.anon.3, ptr %coerce.dive4, i32 0, i32 0
  %6 = load { <2 x float>, <2 x float> }, ptr %coerce.dive5, align 16
  ret { <2 x float>, <2 x float> } %6
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i32 @_Z19b3FindClippingFacesRK9b3Vector3PK22b3ConvexPolyhedronDataS4_S1_RK12b3QuaternionS1_S7_PS_S8_S8_iffPS0_PK9b3GpuFacePKiS9_SC_SE_P6b3Int4i(ptr noundef nonnull align 16 dereferenceable(16) %separatingNormal, ptr noundef %hullA, ptr noundef %hullB, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef %worldVertsA1, ptr noundef %worldNormalsA1, ptr noundef %worldVertsB1, i32 noundef %capacityWorldVerts, float noundef %minDist, float noundef %maxDist, ptr noundef %verticesA, ptr noundef %facesA, ptr noundef %indicesA, ptr noundef %verticesB, ptr noundef %facesB, ptr noundef %indicesB, ptr noundef %clippingFaces, i32 noundef %pairIndex) #2 comdat {
entry:
  %separatingNormal.addr = alloca ptr, align 8
  %hullA.addr = alloca ptr, align 8
  %hullB.addr = alloca ptr, align 8
  %posA.addr = alloca ptr, align 8
  %ornA.addr = alloca ptr, align 8
  %posB.addr = alloca ptr, align 8
  %ornB.addr = alloca ptr, align 8
  %worldVertsA1.addr = alloca ptr, align 8
  %worldNormalsA1.addr = alloca ptr, align 8
  %worldVertsB1.addr = alloca ptr, align 8
  %capacityWorldVerts.addr = alloca i32, align 4
  %minDist.addr = alloca float, align 4
  %maxDist.addr = alloca float, align 4
  %verticesA.addr = alloca ptr, align 8
  %facesA.addr = alloca ptr, align 8
  %indicesA.addr = alloca ptr, align 8
  %verticesB.addr = alloca ptr, align 8
  %facesB.addr = alloca ptr, align 8
  %indicesB.addr = alloca ptr, align 8
  %clippingFaces.addr = alloca ptr, align 8
  %pairIndex.addr = alloca i32, align 4
  %numContactsOut = alloca i32, align 4
  %numWorldVertsB1 = alloca i32, align 4
  %closestFaceB = alloca i32, align 4
  %dmax = alloca float, align 4
  %face = alloca i32, align 4
  %Normal = alloca %class.b3Vector3, align 16
  %WorldNormal = alloca %class.b3Vector3, align 16
  %d = alloca float, align 4
  %polyB = alloca %struct.b3GpuFace, align 16
  %numVertices = alloca i32, align 4
  %e0 = alloca i32, align 4
  %b = alloca %class.b3Vector3, align 16
  %ref.tmp = alloca %class.b3Vector3, align 16
  %closestFaceA = alloca i32, align 4
  %dmin = alloca float, align 4
  %face40 = alloca i32, align 4
  %Normal45 = alloca %class.b3Vector3, align 16
  %faceANormalWS = alloca %class.b3Vector3, align 16
  %d70 = alloca float, align 4
  %numVerticesA = alloca i32, align 4
  %e085 = alloca i32, align 4
  %a = alloca %class.b3Vector3, align 16
  %ref.tmp101 = alloca %class.b3Vector3, align 16
  store ptr %separatingNormal, ptr %separatingNormal.addr, align 8
  store ptr %hullA, ptr %hullA.addr, align 8
  store ptr %hullB, ptr %hullB.addr, align 8
  store ptr %posA, ptr %posA.addr, align 8
  store ptr %ornA, ptr %ornA.addr, align 8
  store ptr %posB, ptr %posB.addr, align 8
  store ptr %ornB, ptr %ornB.addr, align 8
  store ptr %worldVertsA1, ptr %worldVertsA1.addr, align 8
  store ptr %worldNormalsA1, ptr %worldNormalsA1.addr, align 8
  store ptr %worldVertsB1, ptr %worldVertsB1.addr, align 8
  store i32 %capacityWorldVerts, ptr %capacityWorldVerts.addr, align 4
  store float %minDist, ptr %minDist.addr, align 4
  store float %maxDist, ptr %maxDist.addr, align 4
  store ptr %verticesA, ptr %verticesA.addr, align 8
  store ptr %facesA, ptr %facesA.addr, align 8
  store ptr %indicesA, ptr %indicesA.addr, align 8
  store ptr %verticesB, ptr %verticesB.addr, align 8
  store ptr %facesB, ptr %facesB.addr, align 8
  store ptr %indicesB, ptr %indicesB.addr, align 8
  store ptr %clippingFaces, ptr %clippingFaces.addr, align 8
  store i32 %pairIndex, ptr %pairIndex.addr, align 4
  store i32 0, ptr %numContactsOut, align 4
  store i32 0, ptr %numWorldVertsB1, align 4
  store i32 -1, ptr %closestFaceB, align 4
  store float 0xC7EFFFFFE0000000, ptr %dmax, align 4
  store i32 0, ptr %face, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %face, align 4
  %1 = load ptr, ptr %hullB.addr, align 8
  %m_numFaces = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %1, i32 0, i32 6
  %2 = load i32, ptr %m_numFaces, align 8
  %cmp = icmp slt i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %facesB.addr, align 8
  %4 = load ptr, ptr %hullB.addr, align 8
  %m_faceOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %4, i32 0, i32 5
  %5 = load i32, ptr %m_faceOffset, align 4
  %6 = load i32, ptr %face, align 4
  %add = add nsw i32 %5, %6
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr inbounds %struct.b3GpuFace, ptr %3, i64 %idxprom
  %m_plane = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx, i32 0, i32 0
  %7 = getelementptr inbounds %class.b3Vector3, ptr %m_plane, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon.2, ptr %7, i32 0, i32 0
  %8 = load float, ptr %x, align 16
  %9 = load ptr, ptr %facesB.addr, align 8
  %10 = load ptr, ptr %hullB.addr, align 8
  %m_faceOffset1 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %10, i32 0, i32 5
  %11 = load i32, ptr %m_faceOffset1, align 4
  %12 = load i32, ptr %face, align 4
  %add2 = add nsw i32 %11, %12
  %idxprom3 = sext i32 %add2 to i64
  %arrayidx4 = getelementptr inbounds %struct.b3GpuFace, ptr %9, i64 %idxprom3
  %m_plane5 = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx4, i32 0, i32 0
  %13 = getelementptr inbounds %class.b3Vector3, ptr %m_plane5, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon.2, ptr %13, i32 0, i32 1
  %14 = load float, ptr %y, align 4
  %15 = load ptr, ptr %facesB.addr, align 8
  %16 = load ptr, ptr %hullB.addr, align 8
  %m_faceOffset6 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %16, i32 0, i32 5
  %17 = load i32, ptr %m_faceOffset6, align 4
  %18 = load i32, ptr %face, align 4
  %add7 = add nsw i32 %17, %18
  %idxprom8 = sext i32 %add7 to i64
  %arrayidx9 = getelementptr inbounds %struct.b3GpuFace, ptr %15, i64 %idxprom8
  %m_plane10 = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx9, i32 0, i32 0
  %19 = getelementptr inbounds %class.b3Vector3, ptr %m_plane10, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon.2, ptr %19, i32 0, i32 2
  %20 = load float, ptr %z, align 8
  %call = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef %8, float noundef %14, float noundef %20, float noundef 0.000000e+00)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %Normal, i32 0, i32 0
  %coerce.dive11 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %21 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive11, i32 0, i32 0
  %22 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %22, ptr %21, align 16
  %23 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive11, i32 0, i32 1
  %24 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %24, ptr %23, align 8
  %25 = load ptr, ptr %ornB.addr, align 8
  %call12 = call { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %25, ptr noundef nonnull align 16 dereferenceable(16) %Normal)
  %coerce.dive13 = getelementptr inbounds %class.b3Vector3, ptr %WorldNormal, i32 0, i32 0
  %coerce.dive14 = getelementptr inbounds %union.anon.1, ptr %coerce.dive13, i32 0, i32 0
  %26 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive14, i32 0, i32 0
  %27 = extractvalue { <2 x float>, <2 x float> } %call12, 0
  store <2 x float> %27, ptr %26, align 16
  %28 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive14, i32 0, i32 1
  %29 = extractvalue { <2 x float>, <2 x float> } %call12, 1
  store <2 x float> %29, ptr %28, align 8
  %30 = load ptr, ptr %separatingNormal.addr, align 8
  %call15 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %WorldNormal, ptr noundef nonnull align 16 dereferenceable(16) %30)
  store float %call15, ptr %d, align 4
  %31 = load float, ptr %d, align 4
  %32 = load float, ptr %dmax, align 4
  %cmp16 = fcmp ogt float %31, %32
  br i1 %cmp16, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %33 = load float, ptr %d, align 4
  store float %33, ptr %dmax, align 4
  %34 = load i32, ptr %face, align 4
  store i32 %34, ptr %closestFaceB, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %35 = load i32, ptr %face, align 4
  %inc = add nsw i32 %35, 1
  store i32 %inc, ptr %face, align 4
  br label %for.cond, !llvm.loop !16

for.end:                                          ; preds = %for.cond
  %36 = load ptr, ptr %facesB.addr, align 8
  %37 = load ptr, ptr %hullB.addr, align 8
  %m_faceOffset17 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %37, i32 0, i32 5
  %38 = load i32, ptr %m_faceOffset17, align 4
  %39 = load i32, ptr %closestFaceB, align 4
  %add18 = add nsw i32 %38, %39
  %idxprom19 = sext i32 %add18 to i64
  %arrayidx20 = getelementptr inbounds %struct.b3GpuFace, ptr %36, i64 %idxprom19
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %polyB, ptr align 16 %arrayidx20, i64 32, i1 false)
  %m_numIndices = getelementptr inbounds %struct.b3GpuFace, ptr %polyB, i32 0, i32 2
  %40 = load i32, ptr %m_numIndices, align 4
  store i32 %40, ptr %numVertices, align 4
  store i32 0, ptr %e0, align 4
  br label %for.cond21

for.cond21:                                       ; preds = %for.inc37, %for.end
  %41 = load i32, ptr %e0, align 4
  %42 = load i32, ptr %numVertices, align 4
  %cmp22 = icmp slt i32 %41, %42
  br i1 %cmp22, label %for.body23, label %for.end39

for.body23:                                       ; preds = %for.cond21
  %43 = load ptr, ptr %verticesB.addr, align 8
  %44 = load ptr, ptr %hullB.addr, align 8
  %m_vertexOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %44, i32 0, i32 8
  %45 = load i32, ptr %m_vertexOffset, align 16
  %46 = load ptr, ptr %indicesB.addr, align 8
  %m_indexOffset = getelementptr inbounds %struct.b3GpuFace, ptr %polyB, i32 0, i32 1
  %47 = load i32, ptr %m_indexOffset, align 16
  %48 = load i32, ptr %e0, align 4
  %add24 = add nsw i32 %47, %48
  %idxprom25 = sext i32 %add24 to i64
  %arrayidx26 = getelementptr inbounds i32, ptr %46, i64 %idxprom25
  %49 = load i32, ptr %arrayidx26, align 4
  %add27 = add nsw i32 %45, %49
  %idxprom28 = sext i32 %add27 to i64
  %arrayidx29 = getelementptr inbounds %class.b3Vector3, ptr %43, i64 %idxprom28
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %b, ptr align 16 %arrayidx29, i64 16, i1 false)
  %50 = load ptr, ptr %posB.addr, align 8
  %51 = load ptr, ptr %ornB.addr, align 8
  %call30 = call { <2 x float>, <2 x float> } @_Z16b3TransformPointRK9b3Vector3S1_RK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(16) %b, ptr noundef nonnull align 16 dereferenceable(16) %50, ptr noundef nonnull align 16 dereferenceable(16) %51)
  %coerce.dive31 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive32 = getelementptr inbounds %union.anon.1, ptr %coerce.dive31, i32 0, i32 0
  %52 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive32, i32 0, i32 0
  %53 = extractvalue { <2 x float>, <2 x float> } %call30, 0
  store <2 x float> %53, ptr %52, align 16
  %54 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive32, i32 0, i32 1
  %55 = extractvalue { <2 x float>, <2 x float> } %call30, 1
  store <2 x float> %55, ptr %54, align 8
  %56 = load ptr, ptr %worldVertsB1.addr, align 8
  %57 = load i32, ptr %pairIndex.addr, align 4
  %58 = load i32, ptr %capacityWorldVerts.addr, align 4
  %mul = mul nsw i32 %57, %58
  %59 = load i32, ptr %numWorldVertsB1, align 4
  %inc33 = add nsw i32 %59, 1
  store i32 %inc33, ptr %numWorldVertsB1, align 4
  %add34 = add nsw i32 %mul, %59
  %idxprom35 = sext i32 %add34 to i64
  %arrayidx36 = getelementptr inbounds %class.b3Vector3, ptr %56, i64 %idxprom35
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx36, ptr align 16 %ref.tmp, i64 16, i1 false)
  br label %for.inc37

for.inc37:                                        ; preds = %for.body23
  %60 = load i32, ptr %e0, align 4
  %inc38 = add nsw i32 %60, 1
  store i32 %inc38, ptr %e0, align 4
  br label %for.cond21, !llvm.loop !17

for.end39:                                        ; preds = %for.cond21
  store i32 -1, ptr %closestFaceA, align 4
  store float 0x47EFFFFFE0000000, ptr %dmin, align 4
  store i32 0, ptr %face40, align 4
  br label %for.cond41

for.cond41:                                       ; preds = %for.inc77, %for.end39
  %61 = load i32, ptr %face40, align 4
  %62 = load ptr, ptr %hullA.addr, align 8
  %m_numFaces42 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %62, i32 0, i32 6
  %63 = load i32, ptr %m_numFaces42, align 8
  %cmp43 = icmp slt i32 %61, %63
  br i1 %cmp43, label %for.body44, label %for.end79

for.body44:                                       ; preds = %for.cond41
  %64 = load ptr, ptr %facesA.addr, align 8
  %65 = load ptr, ptr %hullA.addr, align 8
  %m_faceOffset46 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %65, i32 0, i32 5
  %66 = load i32, ptr %m_faceOffset46, align 4
  %67 = load i32, ptr %face40, align 4
  %add47 = add nsw i32 %66, %67
  %idxprom48 = sext i32 %add47 to i64
  %arrayidx49 = getelementptr inbounds %struct.b3GpuFace, ptr %64, i64 %idxprom48
  %m_plane50 = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx49, i32 0, i32 0
  %68 = getelementptr inbounds %class.b3Vector3, ptr %m_plane50, i32 0, i32 0
  %x51 = getelementptr inbounds %struct.anon.2, ptr %68, i32 0, i32 0
  %69 = load float, ptr %x51, align 16
  %70 = load ptr, ptr %facesA.addr, align 8
  %71 = load ptr, ptr %hullA.addr, align 8
  %m_faceOffset52 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %71, i32 0, i32 5
  %72 = load i32, ptr %m_faceOffset52, align 4
  %73 = load i32, ptr %face40, align 4
  %add53 = add nsw i32 %72, %73
  %idxprom54 = sext i32 %add53 to i64
  %arrayidx55 = getelementptr inbounds %struct.b3GpuFace, ptr %70, i64 %idxprom54
  %m_plane56 = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx55, i32 0, i32 0
  %74 = getelementptr inbounds %class.b3Vector3, ptr %m_plane56, i32 0, i32 0
  %y57 = getelementptr inbounds %struct.anon.2, ptr %74, i32 0, i32 1
  %75 = load float, ptr %y57, align 4
  %76 = load ptr, ptr %facesA.addr, align 8
  %77 = load ptr, ptr %hullA.addr, align 8
  %m_faceOffset58 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %77, i32 0, i32 5
  %78 = load i32, ptr %m_faceOffset58, align 4
  %79 = load i32, ptr %face40, align 4
  %add59 = add nsw i32 %78, %79
  %idxprom60 = sext i32 %add59 to i64
  %arrayidx61 = getelementptr inbounds %struct.b3GpuFace, ptr %76, i64 %idxprom60
  %m_plane62 = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx61, i32 0, i32 0
  %80 = getelementptr inbounds %class.b3Vector3, ptr %m_plane62, i32 0, i32 0
  %z63 = getelementptr inbounds %struct.anon.2, ptr %80, i32 0, i32 2
  %81 = load float, ptr %z63, align 8
  %call64 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef %69, float noundef %75, float noundef %81, float noundef 0.000000e+00)
  %coerce.dive65 = getelementptr inbounds %class.b3Vector3, ptr %Normal45, i32 0, i32 0
  %coerce.dive66 = getelementptr inbounds %union.anon.1, ptr %coerce.dive65, i32 0, i32 0
  %82 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive66, i32 0, i32 0
  %83 = extractvalue { <2 x float>, <2 x float> } %call64, 0
  store <2 x float> %83, ptr %82, align 16
  %84 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive66, i32 0, i32 1
  %85 = extractvalue { <2 x float>, <2 x float> } %call64, 1
  store <2 x float> %85, ptr %84, align 8
  %86 = load ptr, ptr %ornA.addr, align 8
  %call67 = call { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %86, ptr noundef nonnull align 16 dereferenceable(16) %Normal45)
  %coerce.dive68 = getelementptr inbounds %class.b3Vector3, ptr %faceANormalWS, i32 0, i32 0
  %coerce.dive69 = getelementptr inbounds %union.anon.1, ptr %coerce.dive68, i32 0, i32 0
  %87 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive69, i32 0, i32 0
  %88 = extractvalue { <2 x float>, <2 x float> } %call67, 0
  store <2 x float> %88, ptr %87, align 16
  %89 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive69, i32 0, i32 1
  %90 = extractvalue { <2 x float>, <2 x float> } %call67, 1
  store <2 x float> %90, ptr %89, align 8
  %91 = load ptr, ptr %separatingNormal.addr, align 8
  %call71 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %faceANormalWS, ptr noundef nonnull align 16 dereferenceable(16) %91)
  store float %call71, ptr %d70, align 4
  %92 = load float, ptr %d70, align 4
  %93 = load float, ptr %dmin, align 4
  %cmp72 = fcmp olt float %92, %93
  br i1 %cmp72, label %if.then73, label %if.end76

if.then73:                                        ; preds = %for.body44
  %94 = load float, ptr %d70, align 4
  store float %94, ptr %dmin, align 4
  %95 = load i32, ptr %face40, align 4
  store i32 %95, ptr %closestFaceA, align 4
  %96 = load ptr, ptr %worldNormalsA1.addr, align 8
  %97 = load i32, ptr %pairIndex.addr, align 4
  %idxprom74 = sext i32 %97 to i64
  %arrayidx75 = getelementptr inbounds %class.b3Vector3, ptr %96, i64 %idxprom74
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx75, ptr align 16 %faceANormalWS, i64 16, i1 false)
  br label %if.end76

if.end76:                                         ; preds = %if.then73, %for.body44
  br label %for.inc77

for.inc77:                                        ; preds = %if.end76
  %98 = load i32, ptr %face40, align 4
  %inc78 = add nsw i32 %98, 1
  store i32 %inc78, ptr %face40, align 4
  br label %for.cond41, !llvm.loop !18

for.end79:                                        ; preds = %for.cond41
  %99 = load ptr, ptr %facesA.addr, align 8
  %100 = load ptr, ptr %hullA.addr, align 8
  %m_faceOffset80 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %100, i32 0, i32 5
  %101 = load i32, ptr %m_faceOffset80, align 4
  %102 = load i32, ptr %closestFaceA, align 4
  %add81 = add nsw i32 %101, %102
  %idxprom82 = sext i32 %add81 to i64
  %arrayidx83 = getelementptr inbounds %struct.b3GpuFace, ptr %99, i64 %idxprom82
  %m_numIndices84 = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx83, i32 0, i32 2
  %103 = load i32, ptr %m_numIndices84, align 4
  store i32 %103, ptr %numVerticesA, align 4
  store i32 0, ptr %e085, align 4
  br label %for.cond86

for.cond86:                                       ; preds = %for.inc109, %for.end79
  %104 = load i32, ptr %e085, align 4
  %105 = load i32, ptr %numVerticesA, align 4
  %cmp87 = icmp slt i32 %104, %105
  br i1 %cmp87, label %for.body88, label %for.end111

for.body88:                                       ; preds = %for.cond86
  %106 = load ptr, ptr %verticesA.addr, align 8
  %107 = load ptr, ptr %hullA.addr, align 8
  %m_vertexOffset89 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %107, i32 0, i32 8
  %108 = load i32, ptr %m_vertexOffset89, align 16
  %109 = load ptr, ptr %indicesA.addr, align 8
  %110 = load ptr, ptr %facesA.addr, align 8
  %111 = load ptr, ptr %hullA.addr, align 8
  %m_faceOffset90 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %111, i32 0, i32 5
  %112 = load i32, ptr %m_faceOffset90, align 4
  %113 = load i32, ptr %closestFaceA, align 4
  %add91 = add nsw i32 %112, %113
  %idxprom92 = sext i32 %add91 to i64
  %arrayidx93 = getelementptr inbounds %struct.b3GpuFace, ptr %110, i64 %idxprom92
  %m_indexOffset94 = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx93, i32 0, i32 1
  %114 = load i32, ptr %m_indexOffset94, align 16
  %115 = load i32, ptr %e085, align 4
  %add95 = add nsw i32 %114, %115
  %idxprom96 = sext i32 %add95 to i64
  %arrayidx97 = getelementptr inbounds i32, ptr %109, i64 %idxprom96
  %116 = load i32, ptr %arrayidx97, align 4
  %add98 = add nsw i32 %108, %116
  %idxprom99 = sext i32 %add98 to i64
  %arrayidx100 = getelementptr inbounds %class.b3Vector3, ptr %106, i64 %idxprom99
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %a, ptr align 16 %arrayidx100, i64 16, i1 false)
  %117 = load ptr, ptr %posA.addr, align 8
  %118 = load ptr, ptr %ornA.addr, align 8
  %call102 = call { <2 x float>, <2 x float> } @_Z16b3TransformPointRK9b3Vector3S1_RK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(16) %a, ptr noundef nonnull align 16 dereferenceable(16) %117, ptr noundef nonnull align 16 dereferenceable(16) %118)
  %coerce.dive103 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp101, i32 0, i32 0
  %coerce.dive104 = getelementptr inbounds %union.anon.1, ptr %coerce.dive103, i32 0, i32 0
  %119 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive104, i32 0, i32 0
  %120 = extractvalue { <2 x float>, <2 x float> } %call102, 0
  store <2 x float> %120, ptr %119, align 16
  %121 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive104, i32 0, i32 1
  %122 = extractvalue { <2 x float>, <2 x float> } %call102, 1
  store <2 x float> %122, ptr %121, align 8
  %123 = load ptr, ptr %worldVertsA1.addr, align 8
  %124 = load i32, ptr %pairIndex.addr, align 4
  %125 = load i32, ptr %capacityWorldVerts.addr, align 4
  %mul105 = mul nsw i32 %124, %125
  %126 = load i32, ptr %e085, align 4
  %add106 = add nsw i32 %mul105, %126
  %idxprom107 = sext i32 %add106 to i64
  %arrayidx108 = getelementptr inbounds %class.b3Vector3, ptr %123, i64 %idxprom107
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx108, ptr align 16 %ref.tmp101, i64 16, i1 false)
  br label %for.inc109

for.inc109:                                       ; preds = %for.body88
  %127 = load i32, ptr %e085, align 4
  %inc110 = add nsw i32 %127, 1
  store i32 %inc110, ptr %e085, align 4
  br label %for.cond86, !llvm.loop !19

for.end111:                                       ; preds = %for.cond86
  %128 = load i32, ptr %closestFaceA, align 4
  %129 = load ptr, ptr %clippingFaces.addr, align 8
  %130 = load i32, ptr %pairIndex.addr, align 4
  %idxprom112 = sext i32 %130 to i64
  %arrayidx113 = getelementptr inbounds %struct.b3Int4, ptr %129, i64 %idxprom112
  %131 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx113, i32 0, i32 0
  %x114 = getelementptr inbounds %struct.anon, ptr %131, i32 0, i32 0
  store i32 %128, ptr %x114, align 16
  %132 = load i32, ptr %closestFaceB, align 4
  %133 = load ptr, ptr %clippingFaces.addr, align 8
  %134 = load i32, ptr %pairIndex.addr, align 4
  %idxprom115 = sext i32 %134 to i64
  %arrayidx116 = getelementptr inbounds %struct.b3Int4, ptr %133, i64 %idxprom115
  %135 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx116, i32 0, i32 0
  %y117 = getelementptr inbounds %struct.anon, ptr %135, i32 0, i32 1
  store i32 %132, ptr %y117, align 4
  %136 = load i32, ptr %numVerticesA, align 4
  %137 = load ptr, ptr %clippingFaces.addr, align 8
  %138 = load i32, ptr %pairIndex.addr, align 4
  %idxprom118 = sext i32 %138 to i64
  %arrayidx119 = getelementptr inbounds %struct.b3Int4, ptr %137, i64 %idxprom118
  %139 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx119, i32 0, i32 0
  %z120 = getelementptr inbounds %struct.anon, ptr %139, i32 0, i32 2
  store i32 %136, ptr %z120, align 8
  %140 = load i32, ptr %numWorldVertsB1, align 4
  %141 = load ptr, ptr %clippingFaces.addr, align 8
  %142 = load i32, ptr %pairIndex.addr, align 4
  %idxprom121 = sext i32 %142 to i64
  %arrayidx122 = getelementptr inbounds %struct.b3Int4, ptr %141, i64 %idxprom121
  %143 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx122, i32 0, i32 0
  %w = getelementptr inbounds %struct.anon, ptr %143, i32 0, i32 3
  store i32 %140, ptr %w, align 4
  %144 = load i32, ptr %numContactsOut, align 4
  ret i32 %144
}

; Function Attrs: mustprogress uwtable
define dso_local noundef i32 @_Z14clipFaceGlobalPK9b3Vector3iRS0_fPS_(ptr noundef %pVtxIn, i32 noundef %numVertsIn, ptr noundef nonnull align 16 dereferenceable(16) %planeNormalWS, float noundef %planeEqWS, ptr noundef %ppVtxOut) #2 {
entry:
  %pVtxIn.addr = alloca ptr, align 8
  %numVertsIn.addr = alloca i32, align 4
  %planeNormalWS.addr = alloca ptr, align 8
  %planeEqWS.addr = alloca float, align 4
  %ppVtxOut.addr = alloca ptr, align 8
  %ve = alloca i32, align 4
  %ds = alloca float, align 4
  %de = alloca float, align 4
  %numVertsOut = alloca i32, align 4
  %firstVertex = alloca %class.b3Vector3, align 16
  %endVertex = alloca %class.b3Vector3, align 16
  %ref.tmp = alloca %class.b3Vector3, align 16
  %ref.tmp20 = alloca %class.b3Vector3, align 16
  store ptr %pVtxIn, ptr %pVtxIn.addr, align 8
  store i32 %numVertsIn, ptr %numVertsIn.addr, align 4
  store ptr %planeNormalWS, ptr %planeNormalWS.addr, align 8
  store float %planeEqWS, ptr %planeEqWS.addr, align 4
  store ptr %ppVtxOut, ptr %ppVtxOut.addr, align 8
  store i32 0, ptr %numVertsOut, align 4
  %0 = load ptr, ptr %pVtxIn.addr, align 8
  %1 = load i32, ptr %numVertsIn.addr, align 4
  %sub = sub nsw i32 %1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %class.b3Vector3, ptr %0, i64 %idxprom
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %firstVertex, ptr align 16 %arrayidx, i64 16, i1 false)
  %2 = load ptr, ptr %pVtxIn.addr, align 8
  %arrayidx1 = getelementptr inbounds %class.b3Vector3, ptr %2, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %endVertex, ptr align 16 %arrayidx1, i64 16, i1 false)
  %3 = load ptr, ptr %planeNormalWS.addr, align 8
  %call = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %3, ptr noundef nonnull align 16 dereferenceable(16) %firstVertex)
  %4 = load float, ptr %planeEqWS.addr, align 4
  %add = fadd float %call, %4
  store float %add, ptr %ds, align 4
  store i32 0, ptr %ve, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %5 = load i32, ptr %ve, align 4
  %6 = load i32, ptr %numVertsIn.addr, align 4
  %cmp = icmp slt i32 %5, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load ptr, ptr %pVtxIn.addr, align 8
  %8 = load i32, ptr %ve, align 4
  %idxprom2 = sext i32 %8 to i64
  %arrayidx3 = getelementptr inbounds %class.b3Vector3, ptr %7, i64 %idxprom2
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %endVertex, ptr align 16 %arrayidx3, i64 16, i1 false)
  %9 = load ptr, ptr %planeNormalWS.addr, align 8
  %call4 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %9, ptr noundef nonnull align 16 dereferenceable(16) %endVertex)
  %10 = load float, ptr %planeEqWS.addr, align 4
  %add5 = fadd float %call4, %10
  store float %add5, ptr %de, align 4
  %11 = load float, ptr %ds, align 4
  %cmp6 = fcmp olt float %11, 0.000000e+00
  br i1 %cmp6, label %if.then, label %if.else17

if.then:                                          ; preds = %for.body
  %12 = load float, ptr %de, align 4
  %cmp7 = fcmp olt float %12, 0.000000e+00
  br i1 %cmp7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %13 = load ptr, ptr %ppVtxOut.addr, align 8
  %14 = load i32, ptr %numVertsOut, align 4
  %inc = add nsw i32 %14, 1
  store i32 %inc, ptr %numVertsOut, align 4
  %idxprom9 = sext i32 %14 to i64
  %arrayidx10 = getelementptr inbounds %class.b3Vector3, ptr %13, i64 %idxprom9
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx10, ptr align 16 %endVertex, i64 16, i1 false)
  br label %if.end

if.else:                                          ; preds = %if.then
  %15 = load float, ptr %ds, align 4
  %mul = fmul float %15, 1.000000e+00
  %16 = load float, ptr %ds, align 4
  %17 = load float, ptr %de, align 4
  %sub11 = fsub float %16, %17
  %div = fdiv float %mul, %sub11
  %call12 = call { <2 x float>, <2 x float> } @_Z7b3Lerp3RK9b3Vector3S1_f(ptr noundef nonnull align 16 dereferenceable(16) %firstVertex, ptr noundef nonnull align 16 dereferenceable(16) %endVertex, float noundef %div)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive13 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %18 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive13, i32 0, i32 0
  %19 = extractvalue { <2 x float>, <2 x float> } %call12, 0
  store <2 x float> %19, ptr %18, align 16
  %20 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive13, i32 0, i32 1
  %21 = extractvalue { <2 x float>, <2 x float> } %call12, 1
  store <2 x float> %21, ptr %20, align 8
  %22 = load ptr, ptr %ppVtxOut.addr, align 8
  %23 = load i32, ptr %numVertsOut, align 4
  %inc14 = add nsw i32 %23, 1
  store i32 %inc14, ptr %numVertsOut, align 4
  %idxprom15 = sext i32 %23 to i64
  %arrayidx16 = getelementptr inbounds %class.b3Vector3, ptr %22, i64 %idxprom15
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx16, ptr align 16 %ref.tmp, i64 16, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end34

if.else17:                                        ; preds = %for.body
  %24 = load float, ptr %de, align 4
  %cmp18 = fcmp olt float %24, 0.000000e+00
  br i1 %cmp18, label %if.then19, label %if.end33

if.then19:                                        ; preds = %if.else17
  %25 = load float, ptr %ds, align 4
  %mul21 = fmul float %25, 1.000000e+00
  %26 = load float, ptr %ds, align 4
  %27 = load float, ptr %de, align 4
  %sub22 = fsub float %26, %27
  %div23 = fdiv float %mul21, %sub22
  %call24 = call { <2 x float>, <2 x float> } @_Z7b3Lerp3RK9b3Vector3S1_f(ptr noundef nonnull align 16 dereferenceable(16) %firstVertex, ptr noundef nonnull align 16 dereferenceable(16) %endVertex, float noundef %div23)
  %coerce.dive25 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp20, i32 0, i32 0
  %coerce.dive26 = getelementptr inbounds %union.anon.1, ptr %coerce.dive25, i32 0, i32 0
  %28 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive26, i32 0, i32 0
  %29 = extractvalue { <2 x float>, <2 x float> } %call24, 0
  store <2 x float> %29, ptr %28, align 16
  %30 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive26, i32 0, i32 1
  %31 = extractvalue { <2 x float>, <2 x float> } %call24, 1
  store <2 x float> %31, ptr %30, align 8
  %32 = load ptr, ptr %ppVtxOut.addr, align 8
  %33 = load i32, ptr %numVertsOut, align 4
  %inc27 = add nsw i32 %33, 1
  store i32 %inc27, ptr %numVertsOut, align 4
  %idxprom28 = sext i32 %33 to i64
  %arrayidx29 = getelementptr inbounds %class.b3Vector3, ptr %32, i64 %idxprom28
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx29, ptr align 16 %ref.tmp20, i64 16, i1 false)
  %34 = load ptr, ptr %ppVtxOut.addr, align 8
  %35 = load i32, ptr %numVertsOut, align 4
  %inc30 = add nsw i32 %35, 1
  store i32 %inc30, ptr %numVertsOut, align 4
  %idxprom31 = sext i32 %35 to i64
  %arrayidx32 = getelementptr inbounds %class.b3Vector3, ptr %34, i64 %idxprom31
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx32, ptr align 16 %endVertex, i64 16, i1 false)
  br label %if.end33

if.end33:                                         ; preds = %if.then19, %if.else17
  br label %if.end34

if.end34:                                         ; preds = %if.end33, %if.end
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %firstVertex, ptr align 16 %endVertex, i64 16, i1 false)
  %36 = load float, ptr %de, align 4
  store float %36, ptr %ds, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end34
  %37 = load i32, ptr %ve, align 4
  %inc35 = add nsw i32 %37, 1
  store i32 %inc35, ptr %ve, align 4
  br label %for.cond, !llvm.loop !20

for.end:                                          ; preds = %for.cond
  %38 = load i32, ptr %numVertsOut, align 4
  ret i32 %38
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_Z7b3Lerp3RK9b3Vector3S1_f(ptr noundef nonnull align 16 dereferenceable(16) %a, ptr noundef nonnull align 16 dereferenceable(16) %b, float noundef %t) #6 comdat {
entry:
  %retval = alloca %class.b3Vector3, align 16
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %t.addr = alloca float, align 4
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  store float %t, ptr %t.addr, align 4
  %0 = load ptr, ptr %a.addr, align 8
  %1 = getelementptr inbounds %class.b3Vector3, ptr %0, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon.2, ptr %1, i32 0, i32 0
  %2 = load float, ptr %x, align 16
  %3 = load ptr, ptr %b.addr, align 8
  %4 = getelementptr inbounds %class.b3Vector3, ptr %3, i32 0, i32 0
  %x1 = getelementptr inbounds %struct.anon.2, ptr %4, i32 0, i32 0
  %5 = load float, ptr %x1, align 16
  %6 = load ptr, ptr %a.addr, align 8
  %7 = getelementptr inbounds %class.b3Vector3, ptr %6, i32 0, i32 0
  %x2 = getelementptr inbounds %struct.anon.2, ptr %7, i32 0, i32 0
  %8 = load float, ptr %x2, align 16
  %sub = fsub float %5, %8
  %9 = load float, ptr %t.addr, align 4
  %10 = call float @llvm.fmuladd.f32(float %sub, float %9, float %2)
  %11 = load ptr, ptr %a.addr, align 8
  %12 = getelementptr inbounds %class.b3Vector3, ptr %11, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon.2, ptr %12, i32 0, i32 1
  %13 = load float, ptr %y, align 4
  %14 = load ptr, ptr %b.addr, align 8
  %15 = getelementptr inbounds %class.b3Vector3, ptr %14, i32 0, i32 0
  %y3 = getelementptr inbounds %struct.anon.2, ptr %15, i32 0, i32 1
  %16 = load float, ptr %y3, align 4
  %17 = load ptr, ptr %a.addr, align 8
  %18 = getelementptr inbounds %class.b3Vector3, ptr %17, i32 0, i32 0
  %y4 = getelementptr inbounds %struct.anon.2, ptr %18, i32 0, i32 1
  %19 = load float, ptr %y4, align 4
  %sub5 = fsub float %16, %19
  %20 = load float, ptr %t.addr, align 4
  %21 = call float @llvm.fmuladd.f32(float %sub5, float %20, float %13)
  %22 = load ptr, ptr %a.addr, align 8
  %23 = getelementptr inbounds %class.b3Vector3, ptr %22, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon.2, ptr %23, i32 0, i32 2
  %24 = load float, ptr %z, align 8
  %25 = load ptr, ptr %b.addr, align 8
  %26 = getelementptr inbounds %class.b3Vector3, ptr %25, i32 0, i32 0
  %z6 = getelementptr inbounds %struct.anon.2, ptr %26, i32 0, i32 2
  %27 = load float, ptr %z6, align 8
  %28 = load ptr, ptr %a.addr, align 8
  %29 = getelementptr inbounds %class.b3Vector3, ptr %28, i32 0, i32 0
  %z7 = getelementptr inbounds %struct.anon.2, ptr %29, i32 0, i32 2
  %30 = load float, ptr %z7, align 8
  %sub8 = fsub float %27, %30
  %31 = load float, ptr %t.addr, align 4
  %32 = call float @llvm.fmuladd.f32(float %sub8, float %31, float %24)
  %call = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef %10, float noundef %21, float noundef %32, float noundef 0.000000e+00)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive9 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %33 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive9, i32 0, i32 0
  %34 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %34, ptr %33, align 16
  %35 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive9, i32 0, i32 1
  %36 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %36, ptr %35, align 8
  %coerce.dive10 = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive11 = getelementptr inbounds %union.anon.1, ptr %coerce.dive10, i32 0, i32 0
  %37 = load { <2 x float>, <2 x float> }, ptr %coerce.dive11, align 16
  ret { <2 x float>, <2 x float> } %37
}

; Function Attrs: mustprogress uwtable
define dso_local void @_Z30clipFacesAndFindContactsKernelPK9b3Vector3PKiP6b3Int4PS_S6_S6_S6_ii(ptr noundef %separatingNormals, ptr noundef %hasSeparatingAxis, ptr noundef %clippingFacesOut, ptr noundef %worldVertsA1, ptr noundef %worldNormalsA1, ptr noundef %worldVertsB1, ptr noundef %worldVertsB2, i32 noundef %vertexFaceCapacity, i32 noundef %pairIndex) #2 {
entry:
  %separatingNormals.addr = alloca ptr, align 8
  %hasSeparatingAxis.addr = alloca ptr, align 8
  %clippingFacesOut.addr = alloca ptr, align 8
  %worldVertsA1.addr = alloca ptr, align 8
  %worldNormalsA1.addr = alloca ptr, align 8
  %worldVertsB1.addr = alloca ptr, align 8
  %worldVertsB2.addr = alloca ptr, align 8
  %vertexFaceCapacity.addr = alloca i32, align 4
  %pairIndex.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %minDist = alloca float, align 4
  %maxDist = alloca float, align 4
  %numLocalContactsOut = alloca i32, align 4
  %capacityWorldVertsB2 = alloca i32, align 4
  %pVtxIn = alloca ptr, align 8
  %pVtxOut = alloca ptr, align 8
  %clippingFaces = alloca ptr, align 8
  %closestFaceA = alloca i32, align 4
  %numVertsInA = alloca i32, align 4
  %numVertsInB = alloca i32, align 4
  %numVertsOut = alloca i32, align 4
  %e0 = alloca i32, align 4
  %aw = alloca %class.b3Vector3, align 16
  %bw = alloca %class.b3Vector3, align 16
  %WorldEdge0 = alloca %class.b3Vector3, align 16
  %worldPlaneAnormal1 = alloca %class.b3Vector3, align 16
  %planeNormalWS1 = alloca %class.b3Vector3, align 16
  %ref.tmp = alloca %class.b3Vector3, align 16
  %worldA1 = alloca %class.b3Vector3, align 16
  %planeEqWS1 = alloca float, align 4
  %planeNormalWS = alloca %class.b3Vector3, align 16
  %planeEqWS = alloca float, align 4
  %tmp = alloca ptr, align 8
  %planeNormalWS33 = alloca %class.b3Vector3, align 16
  %planeEqWS36 = alloca float, align 4
  %i42 = alloca i32, align 4
  %depth = alloca float, align 4
  %pointInWorld = alloca %class.b3Vector3, align 16
  %ref.tmp56 = alloca %class.b3Vector3, align 16
  %i73 = alloca i32, align 4
  store ptr %separatingNormals, ptr %separatingNormals.addr, align 8
  store ptr %hasSeparatingAxis, ptr %hasSeparatingAxis.addr, align 8
  store ptr %clippingFacesOut, ptr %clippingFacesOut.addr, align 8
  store ptr %worldVertsA1, ptr %worldVertsA1.addr, align 8
  store ptr %worldNormalsA1, ptr %worldNormalsA1.addr, align 8
  store ptr %worldVertsB1, ptr %worldVertsB1.addr, align 8
  store ptr %worldVertsB2, ptr %worldVertsB2.addr, align 8
  store i32 %vertexFaceCapacity, ptr %vertexFaceCapacity.addr, align 4
  store i32 %pairIndex, ptr %pairIndex.addr, align 4
  %0 = load i32, ptr %pairIndex.addr, align 4
  store i32 %0, ptr %i, align 4
  store float 0xC6293E5940000000, ptr %minDist, align 4
  store float 0x3F947AE140000000, ptr %maxDist, align 4
  %1 = load ptr, ptr %hasSeparatingAxis.addr, align 8
  %2 = load i32, ptr %i, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds i32, ptr %1, i64 %idxprom
  %3 = load i32, ptr %arrayidx, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then, label %if.end84

if.then:                                          ; preds = %entry
  store i32 0, ptr %numLocalContactsOut, align 4
  %4 = load i32, ptr %vertexFaceCapacity.addr, align 4
  store i32 %4, ptr %capacityWorldVertsB2, align 4
  %5 = load ptr, ptr %worldVertsB1.addr, align 8
  %6 = load i32, ptr %pairIndex.addr, align 4
  %7 = load i32, ptr %capacityWorldVertsB2, align 4
  %mul = mul nsw i32 %6, %7
  %idxprom1 = sext i32 %mul to i64
  %arrayidx2 = getelementptr inbounds %class.b3Vector3, ptr %5, i64 %idxprom1
  store ptr %arrayidx2, ptr %pVtxIn, align 8
  %8 = load ptr, ptr %worldVertsB2.addr, align 8
  %9 = load i32, ptr %pairIndex.addr, align 4
  %10 = load i32, ptr %capacityWorldVertsB2, align 4
  %mul3 = mul nsw i32 %9, %10
  %idxprom4 = sext i32 %mul3 to i64
  %arrayidx5 = getelementptr inbounds %class.b3Vector3, ptr %8, i64 %idxprom4
  store ptr %arrayidx5, ptr %pVtxOut, align 8
  %11 = load ptr, ptr %clippingFacesOut.addr, align 8
  store ptr %11, ptr %clippingFaces, align 8
  %12 = load ptr, ptr %clippingFaces, align 8
  %13 = load i32, ptr %pairIndex.addr, align 4
  %idxprom6 = sext i32 %13 to i64
  %arrayidx7 = getelementptr inbounds %struct.b3Int4, ptr %12, i64 %idxprom6
  %14 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx7, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon, ptr %14, i32 0, i32 0
  %15 = load i32, ptr %x, align 16
  store i32 %15, ptr %closestFaceA, align 4
  %16 = load ptr, ptr %clippingFaces, align 8
  %17 = load i32, ptr %pairIndex.addr, align 4
  %idxprom8 = sext i32 %17 to i64
  %arrayidx9 = getelementptr inbounds %struct.b3Int4, ptr %16, i64 %idxprom8
  %18 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx9, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon, ptr %18, i32 0, i32 2
  %19 = load i32, ptr %z, align 8
  store i32 %19, ptr %numVertsInA, align 4
  %20 = load ptr, ptr %clippingFaces, align 8
  %21 = load i32, ptr %pairIndex.addr, align 4
  %idxprom10 = sext i32 %21 to i64
  %arrayidx11 = getelementptr inbounds %struct.b3Int4, ptr %20, i64 %idxprom10
  %22 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx11, i32 0, i32 0
  %w = getelementptr inbounds %struct.anon, ptr %22, i32 0, i32 3
  %23 = load i32, ptr %w, align 4
  store i32 %23, ptr %numVertsInB, align 4
  store i32 0, ptr %numVertsOut, align 4
  %24 = load i32, ptr %closestFaceA, align 4
  %cmp = icmp sge i32 %24, 0
  br i1 %cmp, label %if.then12, label %if.end69

if.then12:                                        ; preds = %if.then
  store i32 0, ptr %e0, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then12
  %25 = load i32, ptr %e0, align 4
  %26 = load i32, ptr %numVertsInA, align 4
  %cmp13 = icmp slt i32 %25, %26
  br i1 %cmp13, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %27 = load ptr, ptr %worldVertsA1.addr, align 8
  %28 = load i32, ptr %pairIndex.addr, align 4
  %29 = load i32, ptr %capacityWorldVertsB2, align 4
  %mul14 = mul nsw i32 %28, %29
  %30 = load i32, ptr %e0, align 4
  %add = add nsw i32 %mul14, %30
  %idxprom15 = sext i32 %add to i64
  %arrayidx16 = getelementptr inbounds %class.b3Vector3, ptr %27, i64 %idxprom15
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %aw, ptr align 16 %arrayidx16, i64 16, i1 false)
  %31 = load ptr, ptr %worldVertsA1.addr, align 8
  %32 = load i32, ptr %pairIndex.addr, align 4
  %33 = load i32, ptr %capacityWorldVertsB2, align 4
  %mul17 = mul nsw i32 %32, %33
  %34 = load i32, ptr %e0, align 4
  %add18 = add nsw i32 %34, 1
  %35 = load i32, ptr %numVertsInA, align 4
  %rem = srem i32 %add18, %35
  %add19 = add nsw i32 %mul17, %rem
  %idxprom20 = sext i32 %add19 to i64
  %arrayidx21 = getelementptr inbounds %class.b3Vector3, ptr %31, i64 %idxprom20
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %bw, ptr align 16 %arrayidx21, i64 16, i1 false)
  %call = call { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %aw, ptr noundef nonnull align 16 dereferenceable(16) %bw)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %WorldEdge0, i32 0, i32 0
  %coerce.dive22 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %36 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive22, i32 0, i32 0
  %37 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %37, ptr %36, align 16
  %38 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive22, i32 0, i32 1
  %39 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %39, ptr %38, align 8
  %40 = load ptr, ptr %worldNormalsA1.addr, align 8
  %41 = load i32, ptr %pairIndex.addr, align 4
  %idxprom23 = sext i32 %41 to i64
  %arrayidx24 = getelementptr inbounds %class.b3Vector3, ptr %40, i64 %idxprom23
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %worldPlaneAnormal1, ptr align 16 %arrayidx24, i64 16, i1 false)
  %call25 = call { <2 x float>, <2 x float> } @_Z7b3CrossRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %WorldEdge0, ptr noundef nonnull align 16 dereferenceable(16) %worldPlaneAnormal1)
  %coerce.dive26 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive27 = getelementptr inbounds %union.anon.1, ptr %coerce.dive26, i32 0, i32 0
  %42 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive27, i32 0, i32 0
  %43 = extractvalue { <2 x float>, <2 x float> } %call25, 0
  store <2 x float> %43, ptr %42, align 16
  %44 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive27, i32 0, i32 1
  %45 = extractvalue { <2 x float>, <2 x float> } %call25, 1
  store <2 x float> %45, ptr %44, align 8
  %call28 = call { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp)
  %coerce.dive29 = getelementptr inbounds %class.b3Vector3, ptr %planeNormalWS1, i32 0, i32 0
  %coerce.dive30 = getelementptr inbounds %union.anon.1, ptr %coerce.dive29, i32 0, i32 0
  %46 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive30, i32 0, i32 0
  %47 = extractvalue { <2 x float>, <2 x float> } %call28, 0
  store <2 x float> %47, ptr %46, align 16
  %48 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive30, i32 0, i32 1
  %49 = extractvalue { <2 x float>, <2 x float> } %call28, 1
  store <2 x float> %49, ptr %48, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %worldA1, ptr align 16 %aw, i64 16, i1 false)
  %call31 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %worldA1, ptr noundef nonnull align 16 dereferenceable(16) %planeNormalWS1)
  %fneg = fneg float %call31
  store float %fneg, ptr %planeEqWS1, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %planeNormalWS, ptr align 16 %planeNormalWS1, i64 16, i1 false)
  %50 = load float, ptr %planeEqWS1, align 4
  store float %50, ptr %planeEqWS, align 4
  %51 = load ptr, ptr %pVtxIn, align 8
  %52 = load i32, ptr %numVertsInB, align 4
  %53 = load float, ptr %planeEqWS, align 4
  %54 = load ptr, ptr %pVtxOut, align 8
  %call32 = call noundef i32 @_Z14clipFaceGlobalPK9b3Vector3iRS0_fPS_(ptr noundef %51, i32 noundef %52, ptr noundef nonnull align 16 dereferenceable(16) %planeNormalWS, float noundef %53, ptr noundef %54)
  store i32 %call32, ptr %numVertsOut, align 4
  %55 = load ptr, ptr %pVtxOut, align 8
  store ptr %55, ptr %tmp, align 8
  %56 = load ptr, ptr %pVtxIn, align 8
  store ptr %56, ptr %pVtxOut, align 8
  %57 = load ptr, ptr %tmp, align 8
  store ptr %57, ptr %pVtxIn, align 8
  %58 = load i32, ptr %numVertsOut, align 4
  store i32 %58, ptr %numVertsInB, align 4
  store i32 0, ptr %numVertsOut, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %59 = load i32, ptr %e0, align 4
  %inc = add nsw i32 %59, 1
  store i32 %inc, ptr %e0, align 4
  br label %for.cond, !llvm.loop !21

for.end:                                          ; preds = %for.cond
  %60 = load ptr, ptr %worldNormalsA1.addr, align 8
  %61 = load i32, ptr %pairIndex.addr, align 4
  %idxprom34 = sext i32 %61 to i64
  %arrayidx35 = getelementptr inbounds %class.b3Vector3, ptr %60, i64 %idxprom34
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %planeNormalWS33, ptr align 16 %arrayidx35, i64 16, i1 false)
  %62 = load ptr, ptr %worldVertsA1.addr, align 8
  %63 = load i32, ptr %pairIndex.addr, align 4
  %64 = load i32, ptr %capacityWorldVertsB2, align 4
  %mul37 = mul nsw i32 %63, %64
  %idxprom38 = sext i32 %mul37 to i64
  %arrayidx39 = getelementptr inbounds %class.b3Vector3, ptr %62, i64 %idxprom38
  %call40 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %planeNormalWS33, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx39)
  %fneg41 = fneg float %call40
  store float %fneg41, ptr %planeEqWS36, align 4
  store i32 0, ptr %i42, align 4
  br label %for.cond43

for.cond43:                                       ; preds = %for.inc66, %for.end
  %65 = load i32, ptr %i42, align 4
  %66 = load i32, ptr %numVertsInB, align 4
  %cmp44 = icmp slt i32 %65, %66
  br i1 %cmp44, label %for.body45, label %for.end68

for.body45:                                       ; preds = %for.cond43
  %67 = load ptr, ptr %pVtxIn, align 8
  %68 = load i32, ptr %i42, align 4
  %idxprom46 = sext i32 %68 to i64
  %arrayidx47 = getelementptr inbounds %class.b3Vector3, ptr %67, i64 %idxprom46
  %call48 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %planeNormalWS33, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx47)
  %69 = load float, ptr %planeEqWS36, align 4
  %add49 = fadd float %call48, %69
  store float %add49, ptr %depth, align 4
  %70 = load float, ptr %depth, align 4
  %71 = load float, ptr %minDist, align 4
  %cmp50 = fcmp ole float %70, %71
  br i1 %cmp50, label %if.then51, label %if.end

if.then51:                                        ; preds = %for.body45
  %72 = load float, ptr %minDist, align 4
  store float %72, ptr %depth, align 4
  br label %if.end

if.end:                                           ; preds = %if.then51, %for.body45
  %73 = load float, ptr %depth, align 4
  %74 = load float, ptr %maxDist, align 4
  %cmp52 = fcmp ole float %73, %74
  br i1 %cmp52, label %if.then53, label %if.end65

if.then53:                                        ; preds = %if.end
  %75 = load ptr, ptr %pVtxIn, align 8
  %76 = load i32, ptr %i42, align 4
  %idxprom54 = sext i32 %76 to i64
  %arrayidx55 = getelementptr inbounds %class.b3Vector3, ptr %75, i64 %idxprom54
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %pointInWorld, ptr align 16 %arrayidx55, i64 16, i1 false)
  %77 = getelementptr inbounds %class.b3Vector3, ptr %pointInWorld, i32 0, i32 0
  %x57 = getelementptr inbounds %struct.anon.2, ptr %77, i32 0, i32 0
  %78 = load float, ptr %x57, align 16
  %79 = getelementptr inbounds %class.b3Vector3, ptr %pointInWorld, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon.2, ptr %79, i32 0, i32 1
  %80 = load float, ptr %y, align 4
  %81 = getelementptr inbounds %class.b3Vector3, ptr %pointInWorld, i32 0, i32 0
  %z58 = getelementptr inbounds %struct.anon.2, ptr %81, i32 0, i32 2
  %82 = load float, ptr %z58, align 8
  %83 = load float, ptr %depth, align 4
  %call59 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef %78, float noundef %80, float noundef %82, float noundef %83)
  %coerce.dive60 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp56, i32 0, i32 0
  %coerce.dive61 = getelementptr inbounds %union.anon.1, ptr %coerce.dive60, i32 0, i32 0
  %84 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive61, i32 0, i32 0
  %85 = extractvalue { <2 x float>, <2 x float> } %call59, 0
  store <2 x float> %85, ptr %84, align 16
  %86 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive61, i32 0, i32 1
  %87 = extractvalue { <2 x float>, <2 x float> } %call59, 1
  store <2 x float> %87, ptr %86, align 8
  %88 = load ptr, ptr %pVtxOut, align 8
  %89 = load i32, ptr %numLocalContactsOut, align 4
  %inc62 = add nsw i32 %89, 1
  store i32 %inc62, ptr %numLocalContactsOut, align 4
  %idxprom63 = sext i32 %89 to i64
  %arrayidx64 = getelementptr inbounds %class.b3Vector3, ptr %88, i64 %idxprom63
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx64, ptr align 16 %ref.tmp56, i64 16, i1 false)
  br label %if.end65

if.end65:                                         ; preds = %if.then53, %if.end
  br label %for.inc66

for.inc66:                                        ; preds = %if.end65
  %90 = load i32, ptr %i42, align 4
  %inc67 = add nsw i32 %90, 1
  store i32 %inc67, ptr %i42, align 4
  br label %for.cond43, !llvm.loop !22

for.end68:                                        ; preds = %for.cond43
  br label %if.end69

if.end69:                                         ; preds = %for.end68, %if.then
  %91 = load i32, ptr %numLocalContactsOut, align 4
  %92 = load ptr, ptr %clippingFaces, align 8
  %93 = load i32, ptr %pairIndex.addr, align 4
  %idxprom70 = sext i32 %93 to i64
  %arrayidx71 = getelementptr inbounds %struct.b3Int4, ptr %92, i64 %idxprom70
  %94 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx71, i32 0, i32 0
  %w72 = getelementptr inbounds %struct.anon, ptr %94, i32 0, i32 3
  store i32 %91, ptr %w72, align 4
  store i32 0, ptr %i73, align 4
  br label %for.cond74

for.cond74:                                       ; preds = %for.inc81, %if.end69
  %95 = load i32, ptr %i73, align 4
  %96 = load i32, ptr %numLocalContactsOut, align 4
  %cmp75 = icmp slt i32 %95, %96
  br i1 %cmp75, label %for.body76, label %for.end83

for.body76:                                       ; preds = %for.cond74
  %97 = load ptr, ptr %pVtxOut, align 8
  %98 = load i32, ptr %i73, align 4
  %idxprom77 = sext i32 %98 to i64
  %arrayidx78 = getelementptr inbounds %class.b3Vector3, ptr %97, i64 %idxprom77
  %99 = load ptr, ptr %pVtxIn, align 8
  %100 = load i32, ptr %i73, align 4
  %idxprom79 = sext i32 %100 to i64
  %arrayidx80 = getelementptr inbounds %class.b3Vector3, ptr %99, i64 %idxprom79
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx80, ptr align 16 %arrayidx78, i64 16, i1 false)
  br label %for.inc81

for.inc81:                                        ; preds = %for.body76
  %101 = load i32, ptr %i73, align 4
  %inc82 = add nsw i32 %101, 1
  store i32 %inc82, ptr %i73, align 4
  br label %for.cond74, !llvm.loop !23

for.end83:                                        ; preds = %for.cond74
  br label %if.end84

if.end84:                                         ; preds = %for.end83, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local noundef i32 @_Z33b3ExtractManifoldSequentialGlobalPK9b3Vector3iRS0_P6b3Int4(ptr noundef %p, i32 noundef %nPoints, ptr noundef nonnull align 16 dereferenceable(16) %nearNormal, ptr noundef %contactIdx) #2 {
entry:
  %retval = alloca i32, align 4
  %p.addr = alloca ptr, align 8
  %nPoints.addr = alloca i32, align 4
  %nearNormal.addr = alloca ptr, align 8
  %contactIdx.addr = alloca ptr, align 8
  %center = alloca %class.b3Vector3, align 16
  %i = alloca i32, align 4
  %ref.tmp = alloca float, align 4
  %aVector = alloca %class.b3Vector3, align 16
  %u = alloca %class.b3Vector3, align 16
  %v = alloca %class.b3Vector3, align 16
  %ref.tmp21 = alloca %class.b3Vector3, align 16
  %ref.tmp25 = alloca %class.b3Vector3, align 16
  %minW = alloca float, align 4
  %minIndex = alloca i32, align 4
  %maxDots = alloca %class.b3Vector3, align 16
  %ie = alloca i32, align 4
  %f = alloca float, align 4
  %r = alloca %class.b3Vector3, align 16
  %ref.tmp54 = alloca %class.b3Vector3, align 16
  %ref.tmp74 = alloca %class.b3Vector3, align 16
  store ptr %p, ptr %p.addr, align 8
  store i32 %nPoints, ptr %nPoints.addr, align 4
  store ptr %nearNormal, ptr %nearNormal.addr, align 8
  store ptr %contactIdx, ptr %contactIdx.addr, align 8
  %0 = load i32, ptr %nPoints.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, ptr %nPoints.addr, align 4
  %cmp1 = icmp sle i32 %1, 4
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %2 = load i32, ptr %nPoints.addr, align 4
  store i32 %2, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %3 = load i32, ptr %nPoints.addr, align 4
  %cmp4 = icmp sgt i32 %3, 64
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  store i32 64, ptr %nPoints.addr, align 4
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.end3
  %call = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %center, i32 0, i32 0
  %coerce.dive7 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %4 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive7, i32 0, i32 0
  %5 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %5, ptr %4, align 16
  %6 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive7, i32 0, i32 1
  %7 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %7, ptr %6, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %nPoints.addr, align 4
  %cmp8 = icmp slt i32 %8, %9
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %p.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idxprom = sext i32 %11 to i64
  %arrayidx = getelementptr inbounds %class.b3Vector3, ptr %10, i64 %idxprom
  %call9 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector3pLERKS_(ptr noundef nonnull align 16 dereferenceable(16) %center, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, ptr %i, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !24

for.end:                                          ; preds = %for.cond
  %13 = load i32, ptr %nPoints.addr, align 4
  %conv = sitofp i32 %13 to float
  store float %conv, ptr %ref.tmp, align 4
  %call10 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector3dVERKf(ptr noundef nonnull align 16 dereferenceable(16) %center, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp)
  %14 = load ptr, ptr %p.addr, align 8
  %arrayidx11 = getelementptr inbounds %class.b3Vector3, ptr %14, i64 0
  %call12 = call { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx11, ptr noundef nonnull align 16 dereferenceable(16) %center)
  %coerce.dive13 = getelementptr inbounds %class.b3Vector3, ptr %aVector, i32 0, i32 0
  %coerce.dive14 = getelementptr inbounds %union.anon.1, ptr %coerce.dive13, i32 0, i32 0
  %15 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive14, i32 0, i32 0
  %16 = extractvalue { <2 x float>, <2 x float> } %call12, 0
  store <2 x float> %16, ptr %15, align 16
  %17 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive14, i32 0, i32 1
  %18 = extractvalue { <2 x float>, <2 x float> } %call12, 1
  store <2 x float> %18, ptr %17, align 8
  %19 = load ptr, ptr %nearNormal.addr, align 8
  %call15 = call { <2 x float>, <2 x float> } @_Z7b3CrossRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %19, ptr noundef nonnull align 16 dereferenceable(16) %aVector)
  %coerce.dive16 = getelementptr inbounds %class.b3Vector3, ptr %u, i32 0, i32 0
  %coerce.dive17 = getelementptr inbounds %union.anon.1, ptr %coerce.dive16, i32 0, i32 0
  %20 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive17, i32 0, i32 0
  %21 = extractvalue { <2 x float>, <2 x float> } %call15, 0
  store <2 x float> %21, ptr %20, align 16
  %22 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive17, i32 0, i32 1
  %23 = extractvalue { <2 x float>, <2 x float> } %call15, 1
  store <2 x float> %23, ptr %22, align 8
  %24 = load ptr, ptr %nearNormal.addr, align 8
  %call18 = call { <2 x float>, <2 x float> } @_Z7b3CrossRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %24, ptr noundef nonnull align 16 dereferenceable(16) %u)
  %coerce.dive19 = getelementptr inbounds %class.b3Vector3, ptr %v, i32 0, i32 0
  %coerce.dive20 = getelementptr inbounds %union.anon.1, ptr %coerce.dive19, i32 0, i32 0
  %25 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive20, i32 0, i32 0
  %26 = extractvalue { <2 x float>, <2 x float> } %call18, 0
  store <2 x float> %26, ptr %25, align 16
  %27 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive20, i32 0, i32 1
  %28 = extractvalue { <2 x float>, <2 x float> } %call18, 1
  store <2 x float> %28, ptr %27, align 8
  %call22 = call { <2 x float>, <2 x float> } @_Z12b3NormalizedRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %u)
  %coerce.dive23 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp21, i32 0, i32 0
  %coerce.dive24 = getelementptr inbounds %union.anon.1, ptr %coerce.dive23, i32 0, i32 0
  %29 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive24, i32 0, i32 0
  %30 = extractvalue { <2 x float>, <2 x float> } %call22, 0
  store <2 x float> %30, ptr %29, align 16
  %31 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive24, i32 0, i32 1
  %32 = extractvalue { <2 x float>, <2 x float> } %call22, 1
  store <2 x float> %32, ptr %31, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %u, ptr align 16 %ref.tmp21, i64 16, i1 false)
  %call26 = call { <2 x float>, <2 x float> } @_Z12b3NormalizedRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %v)
  %coerce.dive27 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp25, i32 0, i32 0
  %coerce.dive28 = getelementptr inbounds %union.anon.1, ptr %coerce.dive27, i32 0, i32 0
  %33 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive28, i32 0, i32 0
  %34 = extractvalue { <2 x float>, <2 x float> } %call26, 0
  store <2 x float> %34, ptr %33, align 16
  %35 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive28, i32 0, i32 1
  %36 = extractvalue { <2 x float>, <2 x float> } %call26, 1
  store <2 x float> %36, ptr %35, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %v, ptr align 16 %ref.tmp25, i64 16, i1 false)
  store float 0x47EFFFFFE0000000, ptr %minW, align 4
  store i32 -1, ptr %minIndex, align 4
  %37 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon.2, ptr %37, i32 0, i32 0
  store float 0x3810000000000000, ptr %x, align 16
  %38 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon.2, ptr %38, i32 0, i32 1
  store float 0x3810000000000000, ptr %y, align 4
  %39 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon.2, ptr %39, i32 0, i32 2
  store float 0x3810000000000000, ptr %z, align 8
  %40 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %w = getelementptr inbounds %struct.anon.2, ptr %40, i32 0, i32 3
  store float 0x3810000000000000, ptr %w, align 4
  store i32 0, ptr %ie, align 4
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc86, %for.end
  %41 = load i32, ptr %ie, align 4
  %42 = load i32, ptr %nPoints.addr, align 4
  %cmp30 = icmp slt i32 %41, %42
  br i1 %cmp30, label %for.body31, label %for.end88

for.body31:                                       ; preds = %for.cond29
  %43 = load ptr, ptr %p.addr, align 8
  %44 = load i32, ptr %ie, align 4
  %idxprom32 = sext i32 %44 to i64
  %arrayidx33 = getelementptr inbounds %class.b3Vector3, ptr %43, i64 %idxprom32
  %45 = getelementptr inbounds %class.b3Vector3, ptr %arrayidx33, i32 0, i32 0
  %w34 = getelementptr inbounds %struct.anon.2, ptr %45, i32 0, i32 3
  %46 = load float, ptr %w34, align 4
  %47 = load float, ptr %minW, align 4
  %cmp35 = fcmp olt float %46, %47
  br i1 %cmp35, label %if.then36, label %if.end40

if.then36:                                        ; preds = %for.body31
  %48 = load ptr, ptr %p.addr, align 8
  %49 = load i32, ptr %ie, align 4
  %idxprom37 = sext i32 %49 to i64
  %arrayidx38 = getelementptr inbounds %class.b3Vector3, ptr %48, i64 %idxprom37
  %50 = getelementptr inbounds %class.b3Vector3, ptr %arrayidx38, i32 0, i32 0
  %w39 = getelementptr inbounds %struct.anon.2, ptr %50, i32 0, i32 3
  %51 = load float, ptr %w39, align 4
  store float %51, ptr %minW, align 4
  %52 = load i32, ptr %ie, align 4
  store i32 %52, ptr %minIndex, align 4
  br label %if.end40

if.end40:                                         ; preds = %if.then36, %for.body31
  %53 = load ptr, ptr %p.addr, align 8
  %54 = load i32, ptr %ie, align 4
  %idxprom41 = sext i32 %54 to i64
  %arrayidx42 = getelementptr inbounds %class.b3Vector3, ptr %53, i64 %idxprom41
  %call43 = call { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx42, ptr noundef nonnull align 16 dereferenceable(16) %center)
  %coerce.dive44 = getelementptr inbounds %class.b3Vector3, ptr %r, i32 0, i32 0
  %coerce.dive45 = getelementptr inbounds %union.anon.1, ptr %coerce.dive44, i32 0, i32 0
  %55 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive45, i32 0, i32 0
  %56 = extractvalue { <2 x float>, <2 x float> } %call43, 0
  store <2 x float> %56, ptr %55, align 16
  %57 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive45, i32 0, i32 1
  %58 = extractvalue { <2 x float>, <2 x float> } %call43, 1
  store <2 x float> %58, ptr %57, align 8
  %call46 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %u, ptr noundef nonnull align 16 dereferenceable(16) %r)
  store float %call46, ptr %f, align 4
  %59 = load float, ptr %f, align 4
  %60 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %x47 = getelementptr inbounds %struct.anon.2, ptr %60, i32 0, i32 0
  %61 = load float, ptr %x47, align 16
  %cmp48 = fcmp olt float %59, %61
  br i1 %cmp48, label %if.then49, label %if.end53

if.then49:                                        ; preds = %if.end40
  %62 = load float, ptr %f, align 4
  %63 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %x50 = getelementptr inbounds %struct.anon.2, ptr %63, i32 0, i32 0
  store float %62, ptr %x50, align 16
  %64 = load i32, ptr %ie, align 4
  %65 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx51 = getelementptr inbounds %struct.b3Int4, ptr %65, i64 0
  %66 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx51, i32 0, i32 0
  %x52 = getelementptr inbounds %struct.anon, ptr %66, i32 0, i32 0
  store i32 %64, ptr %x52, align 16
  br label %if.end53

if.end53:                                         ; preds = %if.then49, %if.end40
  %call55 = call { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %u)
  %coerce.dive56 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp54, i32 0, i32 0
  %coerce.dive57 = getelementptr inbounds %union.anon.1, ptr %coerce.dive56, i32 0, i32 0
  %67 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive57, i32 0, i32 0
  %68 = extractvalue { <2 x float>, <2 x float> } %call55, 0
  store <2 x float> %68, ptr %67, align 16
  %69 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive57, i32 0, i32 1
  %70 = extractvalue { <2 x float>, <2 x float> } %call55, 1
  store <2 x float> %70, ptr %69, align 8
  %call58 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp54, ptr noundef nonnull align 16 dereferenceable(16) %r)
  store float %call58, ptr %f, align 4
  %71 = load float, ptr %f, align 4
  %72 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %y59 = getelementptr inbounds %struct.anon.2, ptr %72, i32 0, i32 1
  %73 = load float, ptr %y59, align 4
  %cmp60 = fcmp olt float %71, %73
  br i1 %cmp60, label %if.then61, label %if.end65

if.then61:                                        ; preds = %if.end53
  %74 = load float, ptr %f, align 4
  %75 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %y62 = getelementptr inbounds %struct.anon.2, ptr %75, i32 0, i32 1
  store float %74, ptr %y62, align 4
  %76 = load i32, ptr %ie, align 4
  %77 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx63 = getelementptr inbounds %struct.b3Int4, ptr %77, i64 0
  %78 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx63, i32 0, i32 0
  %y64 = getelementptr inbounds %struct.anon, ptr %78, i32 0, i32 1
  store i32 %76, ptr %y64, align 4
  br label %if.end65

if.end65:                                         ; preds = %if.then61, %if.end53
  %call66 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %v, ptr noundef nonnull align 16 dereferenceable(16) %r)
  store float %call66, ptr %f, align 4
  %79 = load float, ptr %f, align 4
  %80 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %z67 = getelementptr inbounds %struct.anon.2, ptr %80, i32 0, i32 2
  %81 = load float, ptr %z67, align 8
  %cmp68 = fcmp olt float %79, %81
  br i1 %cmp68, label %if.then69, label %if.end73

if.then69:                                        ; preds = %if.end65
  %82 = load float, ptr %f, align 4
  %83 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %z70 = getelementptr inbounds %struct.anon.2, ptr %83, i32 0, i32 2
  store float %82, ptr %z70, align 8
  %84 = load i32, ptr %ie, align 4
  %85 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx71 = getelementptr inbounds %struct.b3Int4, ptr %85, i64 0
  %86 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx71, i32 0, i32 0
  %z72 = getelementptr inbounds %struct.anon, ptr %86, i32 0, i32 2
  store i32 %84, ptr %z72, align 8
  br label %if.end73

if.end73:                                         ; preds = %if.then69, %if.end65
  %call75 = call { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %v)
  %coerce.dive76 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp74, i32 0, i32 0
  %coerce.dive77 = getelementptr inbounds %union.anon.1, ptr %coerce.dive76, i32 0, i32 0
  %87 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive77, i32 0, i32 0
  %88 = extractvalue { <2 x float>, <2 x float> } %call75, 0
  store <2 x float> %88, ptr %87, align 16
  %89 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive77, i32 0, i32 1
  %90 = extractvalue { <2 x float>, <2 x float> } %call75, 1
  store <2 x float> %90, ptr %89, align 8
  %call78 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp74, ptr noundef nonnull align 16 dereferenceable(16) %r)
  store float %call78, ptr %f, align 4
  %91 = load float, ptr %f, align 4
  %92 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %w79 = getelementptr inbounds %struct.anon.2, ptr %92, i32 0, i32 3
  %93 = load float, ptr %w79, align 4
  %cmp80 = fcmp olt float %91, %93
  br i1 %cmp80, label %if.then81, label %if.end85

if.then81:                                        ; preds = %if.end73
  %94 = load float, ptr %f, align 4
  %95 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %w82 = getelementptr inbounds %struct.anon.2, ptr %95, i32 0, i32 3
  store float %94, ptr %w82, align 4
  %96 = load i32, ptr %ie, align 4
  %97 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx83 = getelementptr inbounds %struct.b3Int4, ptr %97, i64 0
  %98 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx83, i32 0, i32 0
  %w84 = getelementptr inbounds %struct.anon, ptr %98, i32 0, i32 3
  store i32 %96, ptr %w84, align 4
  br label %if.end85

if.end85:                                         ; preds = %if.then81, %if.end73
  br label %for.inc86

for.inc86:                                        ; preds = %if.end85
  %99 = load i32, ptr %ie, align 4
  %inc87 = add nsw i32 %99, 1
  store i32 %inc87, ptr %ie, align 4
  br label %for.cond29, !llvm.loop !25

for.end88:                                        ; preds = %for.cond29
  %100 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx89 = getelementptr inbounds %struct.b3Int4, ptr %100, i64 0
  %101 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx89, i32 0, i32 0
  %x90 = getelementptr inbounds %struct.anon, ptr %101, i32 0, i32 0
  %102 = load i32, ptr %x90, align 16
  %103 = load i32, ptr %minIndex, align 4
  %cmp91 = icmp ne i32 %102, %103
  br i1 %cmp91, label %land.lhs.true, label %if.end106

land.lhs.true:                                    ; preds = %for.end88
  %104 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx92 = getelementptr inbounds %struct.b3Int4, ptr %104, i64 0
  %105 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx92, i32 0, i32 0
  %y93 = getelementptr inbounds %struct.anon, ptr %105, i32 0, i32 1
  %106 = load i32, ptr %y93, align 4
  %107 = load i32, ptr %minIndex, align 4
  %cmp94 = icmp ne i32 %106, %107
  br i1 %cmp94, label %land.lhs.true95, label %if.end106

land.lhs.true95:                                  ; preds = %land.lhs.true
  %108 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx96 = getelementptr inbounds %struct.b3Int4, ptr %108, i64 0
  %109 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx96, i32 0, i32 0
  %z97 = getelementptr inbounds %struct.anon, ptr %109, i32 0, i32 2
  %110 = load i32, ptr %z97, align 8
  %111 = load i32, ptr %minIndex, align 4
  %cmp98 = icmp ne i32 %110, %111
  br i1 %cmp98, label %land.lhs.true99, label %if.end106

land.lhs.true99:                                  ; preds = %land.lhs.true95
  %112 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx100 = getelementptr inbounds %struct.b3Int4, ptr %112, i64 0
  %113 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx100, i32 0, i32 0
  %w101 = getelementptr inbounds %struct.anon, ptr %113, i32 0, i32 3
  %114 = load i32, ptr %w101, align 4
  %115 = load i32, ptr %minIndex, align 4
  %cmp102 = icmp ne i32 %114, %115
  br i1 %cmp102, label %if.then103, label %if.end106

if.then103:                                       ; preds = %land.lhs.true99
  %116 = load i32, ptr %minIndex, align 4
  %117 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx104 = getelementptr inbounds %struct.b3Int4, ptr %117, i64 0
  %118 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx104, i32 0, i32 0
  %x105 = getelementptr inbounds %struct.anon, ptr %118, i32 0, i32 0
  store i32 %116, ptr %x105, align 16
  br label %if.end106

if.end106:                                        ; preds = %if.then103, %land.lhs.true99, %land.lhs.true95, %land.lhs.true, %for.end88
  store i32 4, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end106, %if.then2, %if.then
  %119 = load i32, ptr %retval, align 4
  ret i32 %119
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector3dVERKf(ptr noundef nonnull align 16 dereferenceable(16) %this, ptr noundef nonnull align 4 dereferenceable(4) %s) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %ref.tmp = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load float, ptr %0, align 4
  %div = fdiv float 1.000000e+00, %1
  store float %div, ptr %ref.tmp, align 4
  %call = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector3mLERKf(ptr noundef nonnull align 16 dereferenceable(16) %this1, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define dso_local void @_Z27b3NewContactReductionKernelP6b3Int4PK15b3RigidBodyDataPK9b3Vector3PKiP14b3Contact4DataS0_PS4_PViiiii(ptr noundef %pairs, ptr noundef %rigidBodies, ptr noundef %separatingNormals, ptr noundef %hasSeparatingAxis, ptr noundef %globalContactsOut, ptr noundef %clippingFaces, ptr noundef %worldVertsB2, ptr noundef %nGlobalContactsOut, i32 noundef %vertexFaceCapacity, i32 noundef %contactCapacity, i32 noundef %numPairs, i32 noundef %pairIndex) #2 {
entry:
  %pairs.addr = alloca ptr, align 8
  %rigidBodies.addr = alloca ptr, align 8
  %separatingNormals.addr = alloca ptr, align 8
  %hasSeparatingAxis.addr = alloca ptr, align 8
  %globalContactsOut.addr = alloca ptr, align 8
  %clippingFaces.addr = alloca ptr, align 8
  %worldVertsB2.addr = alloca ptr, align 8
  %nGlobalContactsOut.addr = alloca ptr, align 8
  %vertexFaceCapacity.addr = alloca i32, align 4
  %contactCapacity.addr = alloca i32, align 4
  %numPairs.addr = alloca i32, align 4
  %pairIndex.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %contactIdx = alloca %struct.b3Int4, align 16
  %ref.tmp = alloca %struct.b3Int4, align 16
  %nPoints = alloca i32, align 4
  %pointsIn = alloca ptr, align 8
  %normal = alloca %class.b3Vector3, align 16
  %nReducedContacts = alloca i32, align 4
  %dstIdx = alloca i32, align 4
  %c = alloca ptr, align 8
  %ref.tmp19 = alloca %class.b3Vector3, align 16
  %bodyA = alloca i32, align 4
  %bodyB = alloca i32, align 4
  store ptr %pairs, ptr %pairs.addr, align 8
  store ptr %rigidBodies, ptr %rigidBodies.addr, align 8
  store ptr %separatingNormals, ptr %separatingNormals.addr, align 8
  store ptr %hasSeparatingAxis, ptr %hasSeparatingAxis.addr, align 8
  store ptr %globalContactsOut, ptr %globalContactsOut.addr, align 8
  store ptr %clippingFaces, ptr %clippingFaces.addr, align 8
  store ptr %worldVertsB2, ptr %worldVertsB2.addr, align 8
  store ptr %nGlobalContactsOut, ptr %nGlobalContactsOut.addr, align 8
  store i32 %vertexFaceCapacity, ptr %vertexFaceCapacity.addr, align 4
  store i32 %contactCapacity, ptr %contactCapacity.addr, align 4
  store i32 %numPairs, ptr %numPairs.addr, align 4
  store i32 %pairIndex, ptr %pairIndex.addr, align 4
  %0 = load i32, ptr %pairIndex.addr, align 4
  store i32 %0, ptr %i, align 4
  %call = call { i64, i64 } @_Z10b3MakeInt4iiii(i32 noundef 0, i32 noundef 1, i32 noundef 2, i32 noundef 3)
  %coerce.dive = getelementptr inbounds %struct.b3Int4, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive1 = getelementptr inbounds %union.anon, ptr %coerce.dive, i32 0, i32 0
  %1 = getelementptr inbounds { i64, i64 }, ptr %coerce.dive1, i32 0, i32 0
  %2 = extractvalue { i64, i64 } %call, 0
  store i64 %2, ptr %1, align 16
  %3 = getelementptr inbounds { i64, i64 }, ptr %coerce.dive1, i32 0, i32 1
  %4 = extractvalue { i64, i64 } %call, 1
  store i64 %4, ptr %3, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %contactIdx, ptr align 16 %ref.tmp, i64 16, i1 false)
  %5 = load i32, ptr %i, align 4
  %6 = load i32, ptr %numPairs.addr, align 4
  %cmp = icmp slt i32 %5, %6
  br i1 %cmp, label %if.then, label %if.end67

if.then:                                          ; preds = %entry
  %7 = load ptr, ptr %hasSeparatingAxis.addr, align 8
  %8 = load i32, ptr %i, align 4
  %idxprom = sext i32 %8 to i64
  %arrayidx = getelementptr inbounds i32, ptr %7, i64 %idxprom
  %9 = load i32, ptr %arrayidx, align 4
  %tobool = icmp ne i32 %9, 0
  br i1 %tobool, label %if.then2, label %if.end66

if.then2:                                         ; preds = %if.then
  %10 = load ptr, ptr %clippingFaces.addr, align 8
  %11 = load i32, ptr %pairIndex.addr, align 4
  %idxprom3 = sext i32 %11 to i64
  %arrayidx4 = getelementptr inbounds %struct.b3Int4, ptr %10, i64 %idxprom3
  %12 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx4, i32 0, i32 0
  %w = getelementptr inbounds %struct.anon, ptr %12, i32 0, i32 3
  %13 = load i32, ptr %w, align 4
  store i32 %13, ptr %nPoints, align 4
  %14 = load i32, ptr %nPoints, align 4
  %cmp5 = icmp sgt i32 %14, 0
  br i1 %cmp5, label %if.then6, label %if.end65

if.then6:                                         ; preds = %if.then2
  %15 = load ptr, ptr %worldVertsB2.addr, align 8
  %16 = load i32, ptr %pairIndex.addr, align 4
  %17 = load i32, ptr %vertexFaceCapacity.addr, align 4
  %mul = mul nsw i32 %16, %17
  %idxprom7 = sext i32 %mul to i64
  %arrayidx8 = getelementptr inbounds %class.b3Vector3, ptr %15, i64 %idxprom7
  store ptr %arrayidx8, ptr %pointsIn, align 8
  %18 = load ptr, ptr %separatingNormals.addr, align 8
  %19 = load i32, ptr %i, align 4
  %idxprom9 = sext i32 %19 to i64
  %arrayidx10 = getelementptr inbounds %class.b3Vector3, ptr %18, i64 %idxprom9
  %call11 = call { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx10)
  %coerce.dive12 = getelementptr inbounds %class.b3Vector3, ptr %normal, i32 0, i32 0
  %coerce.dive13 = getelementptr inbounds %union.anon.1, ptr %coerce.dive12, i32 0, i32 0
  %20 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive13, i32 0, i32 0
  %21 = extractvalue { <2 x float>, <2 x float> } %call11, 0
  store <2 x float> %21, ptr %20, align 16
  %22 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive13, i32 0, i32 1
  %23 = extractvalue { <2 x float>, <2 x float> } %call11, 1
  store <2 x float> %23, ptr %22, align 8
  %24 = load ptr, ptr %pointsIn, align 8
  %25 = load i32, ptr %nPoints, align 4
  %call14 = call noundef i32 @_Z33b3ExtractManifoldSequentialGlobalPK9b3Vector3iRS0_P6b3Int4(ptr noundef %24, i32 noundef %25, ptr noundef nonnull align 16 dereferenceable(16) %normal, ptr noundef %contactIdx)
  store i32 %call14, ptr %nReducedContacts, align 4
  %26 = load ptr, ptr %nGlobalContactsOut.addr, align 8
  %27 = load volatile i32, ptr %26, align 4
  %inc = add nsw i32 %27, 1
  store volatile i32 %inc, ptr %26, align 4
  store i32 %27, ptr %dstIdx, align 4
  %28 = load i32, ptr %dstIdx, align 4
  %29 = load i32, ptr %contactCapacity.addr, align 4
  %cmp15 = icmp slt i32 %28, %29
  br i1 %cmp15, label %if.then16, label %if.end

if.then16:                                        ; preds = %if.then6
  %30 = load ptr, ptr %globalContactsOut.addr, align 8
  %31 = load i32, ptr %dstIdx, align 4
  %idxprom17 = sext i32 %31 to i64
  %arrayidx18 = getelementptr inbounds %struct.b3Contact4Data, ptr %30, i64 %idxprom17
  store ptr %arrayidx18, ptr %c, align 8
  %call20 = call { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %normal)
  %coerce.dive21 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp19, i32 0, i32 0
  %coerce.dive22 = getelementptr inbounds %union.anon.1, ptr %coerce.dive21, i32 0, i32 0
  %32 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive22, i32 0, i32 0
  %33 = extractvalue { <2 x float>, <2 x float> } %call20, 0
  store <2 x float> %33, ptr %32, align 16
  %34 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive22, i32 0, i32 1
  %35 = extractvalue { <2 x float>, <2 x float> } %call20, 1
  store <2 x float> %35, ptr %34, align 8
  %36 = load ptr, ptr %c, align 8
  %m_worldNormalOnB = getelementptr inbounds %struct.b3Contact4Data, ptr %36, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %m_worldNormalOnB, ptr align 16 %ref.tmp19, i64 16, i1 false)
  %37 = load ptr, ptr %c, align 8
  %m_restituitionCoeffCmp = getelementptr inbounds %struct.b3Contact4Data, ptr %37, i32 0, i32 2
  store i16 0, ptr %m_restituitionCoeffCmp, align 16
  %38 = load ptr, ptr %c, align 8
  %m_frictionCoeffCmp = getelementptr inbounds %struct.b3Contact4Data, ptr %38, i32 0, i32 3
  store i16 -19662, ptr %m_frictionCoeffCmp, align 2
  %39 = load i32, ptr %pairIndex.addr, align 4
  %40 = load ptr, ptr %c, align 8
  %m_batchIdx = getelementptr inbounds %struct.b3Contact4Data, ptr %40, i32 0, i32 4
  store i32 %39, ptr %m_batchIdx, align 4
  %41 = load ptr, ptr %pairs.addr, align 8
  %42 = load i32, ptr %pairIndex.addr, align 4
  %idxprom23 = sext i32 %42 to i64
  %arrayidx24 = getelementptr inbounds %struct.b3Int4, ptr %41, i64 %idxprom23
  %43 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx24, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon, ptr %43, i32 0, i32 0
  %44 = load i32, ptr %x, align 16
  store i32 %44, ptr %bodyA, align 4
  %45 = load ptr, ptr %pairs.addr, align 8
  %46 = load i32, ptr %pairIndex.addr, align 4
  %idxprom25 = sext i32 %46 to i64
  %arrayidx26 = getelementptr inbounds %struct.b3Int4, ptr %45, i64 %idxprom25
  %47 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx26, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon, ptr %47, i32 0, i32 1
  %48 = load i32, ptr %y, align 4
  store i32 %48, ptr %bodyB, align 4
  %49 = load i32, ptr %dstIdx, align 4
  %50 = load ptr, ptr %pairs.addr, align 8
  %51 = load i32, ptr %pairIndex.addr, align 4
  %idxprom27 = sext i32 %51 to i64
  %arrayidx28 = getelementptr inbounds %struct.b3Int4, ptr %50, i64 %idxprom27
  %52 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx28, i32 0, i32 0
  %w29 = getelementptr inbounds %struct.anon, ptr %52, i32 0, i32 3
  store i32 %49, ptr %w29, align 4
  %53 = load ptr, ptr %rigidBodies.addr, align 8
  %54 = load i32, ptr %bodyA, align 4
  %idxprom30 = sext i32 %54 to i64
  %arrayidx31 = getelementptr inbounds %struct.b3RigidBodyData, ptr %53, i64 %idxprom30
  %m_invMass = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx31, i32 0, i32 5
  %55 = load float, ptr %m_invMass, align 4
  %cmp32 = fcmp oeq float %55, 0.000000e+00
  br i1 %cmp32, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then16
  %56 = load i32, ptr %bodyA, align 4
  %sub = sub nsw i32 0, %56
  br label %cond.end

cond.false:                                       ; preds = %if.then16
  %57 = load i32, ptr %bodyA, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %sub, %cond.true ], [ %57, %cond.false ]
  %58 = load ptr, ptr %c, align 8
  %m_bodyAPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %58, i32 0, i32 5
  store i32 %cond, ptr %m_bodyAPtrAndSignBit, align 8
  %59 = load ptr, ptr %rigidBodies.addr, align 8
  %60 = load i32, ptr %bodyB, align 4
  %idxprom33 = sext i32 %60 to i64
  %arrayidx34 = getelementptr inbounds %struct.b3RigidBodyData, ptr %59, i64 %idxprom33
  %m_invMass35 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx34, i32 0, i32 5
  %61 = load float, ptr %m_invMass35, align 4
  %cmp36 = fcmp oeq float %61, 0.000000e+00
  br i1 %cmp36, label %cond.true37, label %cond.false39

cond.true37:                                      ; preds = %cond.end
  %62 = load i32, ptr %bodyB, align 4
  %sub38 = sub nsw i32 0, %62
  br label %cond.end40

cond.false39:                                     ; preds = %cond.end
  %63 = load i32, ptr %bodyB, align 4
  br label %cond.end40

cond.end40:                                       ; preds = %cond.false39, %cond.true37
  %cond41 = phi i32 [ %sub38, %cond.true37 ], [ %63, %cond.false39 ]
  %64 = load ptr, ptr %c, align 8
  %m_bodyBPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %64, i32 0, i32 6
  store i32 %cond41, ptr %m_bodyBPtrAndSignBit, align 4
  %65 = load ptr, ptr %c, align 8
  %m_childIndexA = getelementptr inbounds %struct.b3Contact4Data, ptr %65, i32 0, i32 7
  store i32 -1, ptr %m_childIndexA, align 16
  %66 = load ptr, ptr %c, align 8
  %m_childIndexB = getelementptr inbounds %struct.b3Contact4Data, ptr %66, i32 0, i32 8
  store i32 -1, ptr %m_childIndexB, align 4
  %67 = load i32, ptr %nReducedContacts, align 4
  switch i32 %67, label %sw.default [
    i32 4, label %sw.bb
    i32 3, label %sw.bb46
    i32 2, label %sw.bb51
    i32 1, label %sw.bb57
  ]

sw.bb:                                            ; preds = %cond.end40
  %68 = load ptr, ptr %pointsIn, align 8
  %69 = getelementptr inbounds %struct.b3Int4, ptr %contactIdx, i32 0, i32 0
  %w42 = getelementptr inbounds %struct.anon, ptr %69, i32 0, i32 3
  %70 = load i32, ptr %w42, align 4
  %idxprom43 = sext i32 %70 to i64
  %arrayidx44 = getelementptr inbounds %class.b3Vector3, ptr %68, i64 %idxprom43
  %71 = load ptr, ptr %c, align 8
  %m_worldPosB = getelementptr inbounds %struct.b3Contact4Data, ptr %71, i32 0, i32 0
  %arrayidx45 = getelementptr inbounds [4 x %class.b3Vector3], ptr %m_worldPosB, i64 0, i64 3
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx45, ptr align 16 %arrayidx44, i64 16, i1 false)
  br label %sw.bb46

sw.bb46:                                          ; preds = %sw.bb, %cond.end40
  %72 = load ptr, ptr %pointsIn, align 8
  %73 = getelementptr inbounds %struct.b3Int4, ptr %contactIdx, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon, ptr %73, i32 0, i32 2
  %74 = load i32, ptr %z, align 8
  %idxprom47 = sext i32 %74 to i64
  %arrayidx48 = getelementptr inbounds %class.b3Vector3, ptr %72, i64 %idxprom47
  %75 = load ptr, ptr %c, align 8
  %m_worldPosB49 = getelementptr inbounds %struct.b3Contact4Data, ptr %75, i32 0, i32 0
  %arrayidx50 = getelementptr inbounds [4 x %class.b3Vector3], ptr %m_worldPosB49, i64 0, i64 2
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx50, ptr align 16 %arrayidx48, i64 16, i1 false)
  br label %sw.bb51

sw.bb51:                                          ; preds = %sw.bb46, %cond.end40
  %76 = load ptr, ptr %pointsIn, align 8
  %77 = getelementptr inbounds %struct.b3Int4, ptr %contactIdx, i32 0, i32 0
  %y52 = getelementptr inbounds %struct.anon, ptr %77, i32 0, i32 1
  %78 = load i32, ptr %y52, align 4
  %idxprom53 = sext i32 %78 to i64
  %arrayidx54 = getelementptr inbounds %class.b3Vector3, ptr %76, i64 %idxprom53
  %79 = load ptr, ptr %c, align 8
  %m_worldPosB55 = getelementptr inbounds %struct.b3Contact4Data, ptr %79, i32 0, i32 0
  %arrayidx56 = getelementptr inbounds [4 x %class.b3Vector3], ptr %m_worldPosB55, i64 0, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx56, ptr align 16 %arrayidx54, i64 16, i1 false)
  br label %sw.bb57

sw.bb57:                                          ; preds = %sw.bb51, %cond.end40
  %80 = load ptr, ptr %pointsIn, align 8
  %81 = getelementptr inbounds %struct.b3Int4, ptr %contactIdx, i32 0, i32 0
  %x58 = getelementptr inbounds %struct.anon, ptr %81, i32 0, i32 0
  %82 = load i32, ptr %x58, align 16
  %idxprom59 = sext i32 %82 to i64
  %arrayidx60 = getelementptr inbounds %class.b3Vector3, ptr %80, i64 %idxprom59
  %83 = load ptr, ptr %c, align 8
  %m_worldPosB61 = getelementptr inbounds %struct.b3Contact4Data, ptr %83, i32 0, i32 0
  %arrayidx62 = getelementptr inbounds [4 x %class.b3Vector3], ptr %m_worldPosB61, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx62, ptr align 16 %arrayidx60, i64 16, i1 false)
  br label %sw.default

sw.default:                                       ; preds = %sw.bb57, %cond.end40
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default
  %84 = load i32, ptr %nReducedContacts, align 4
  %conv = sitofp i32 %84 to float
  %85 = load ptr, ptr %c, align 8
  %m_worldNormalOnB63 = getelementptr inbounds %struct.b3Contact4Data, ptr %85, i32 0, i32 1
  %86 = getelementptr inbounds %class.b3Vector3, ptr %m_worldNormalOnB63, i32 0, i32 0
  %w64 = getelementptr inbounds %struct.anon.2, ptr %86, i32 0, i32 3
  store float %conv, ptr %w64, align 4
  br label %if.end

if.end:                                           ; preds = %sw.epilog, %if.then6
  br label %if.end65

if.end65:                                         ; preds = %if.end, %if.then2
  br label %if.end66

if.end66:                                         ; preds = %if.end65, %if.then
  br label %if.end67

if.end67:                                         ; preds = %if.end66, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN15GpuSatCollisionC2EP11_cl_contextP13_cl_device_idP17_cl_command_queue(ptr noundef nonnull align 8 dereferenceable(864) %this, ptr noundef %ctx, ptr noundef %device, ptr noundef %q) unnamed_addr #0 align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %device.addr = alloca ptr, align 8
  %q.addr = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %ref.tmp = alloca i32, align 4
  %errNum = alloca i32, align 4
  %mprSrc = alloca ptr, align 8
  %srcConcave = alloca ptr, align 8
  %flags = alloca [1024 x i8], align 16
  %mprProg = alloca ptr, align 8
  %numDirections = alloca i32, align 4
  %satProg = alloca ptr, align 8
  %satConcaveProg = alloca ptr, align 8
  %srcClip = alloca ptr, align 8
  %flags114 = alloca [1024 x i8], align 16
  %satClipContactsProg = alloca ptr, align 8
  %srcBvh = alloca ptr, align 8
  %bvhTraversalProg = alloca ptr, align 8
  %primitiveContactsSrc = alloca ptr, align 8
  %primitiveContactsProg = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %device, ptr %device.addr, align 8
  store ptr %q, ptr %q.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV15GpuSatCollision, i32 0, inrange i32 0, i32 2), ptr %this1, align 8
  %m_context = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %ctx.addr, align 8
  store ptr %0, ptr %m_context, align 8
  %m_device = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %device.addr, align 8
  store ptr %1, ptr %m_device, align 8
  %m_queue = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %2 = load ptr, ptr %q.addr, align 8
  store ptr %2, ptr %m_queue, align 8
  %m_findSeparatingAxisKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 4
  store ptr null, ptr %m_findSeparatingAxisKernel, align 8
  %m_findSeparatingAxisVertexFaceKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 7
  store ptr null, ptr %m_findSeparatingAxisVertexFaceKernel, align 8
  %m_findSeparatingAxisEdgeEdgeKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 8
  store ptr null, ptr %m_findSeparatingAxisEdgeEdgeKernel, align 8
  %m_unitSphereDirections = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 24
  %m_context2 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %m_context2, align 8
  %m_queue3 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %4 = load ptr, ptr %m_queue3, align 8
  call void @_ZN13b3OpenCLArrayI9b3Vector3EC2EP11_cl_contextP17_cl_command_queuemb(ptr noundef nonnull align 8 dereferenceable(50) %m_unitSphereDirections, ptr noundef %3, ptr noundef %4, i64 noundef 0, i1 noundef zeroext true)
  %m_totalContactsOut = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %m_context4 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %5 = load ptr, ptr %m_context4, align 8
  %m_queue5 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %6 = load ptr, ptr %m_queue5, align 8
  invoke void @_ZN13b3OpenCLArrayIiEC2EP11_cl_contextP17_cl_command_queuemb(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut, ptr noundef %5, ptr noundef %6, i64 noundef 0, i1 noundef zeroext true)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  %m_sepNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 26
  %m_context6 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %7 = load ptr, ptr %m_context6, align 8
  %m_queue7 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %8 = load ptr, ptr %m_queue7, align 8
  invoke void @_ZN13b3OpenCLArrayI9b3Vector3EC2EP11_cl_contextP17_cl_command_queuemb(ptr noundef nonnull align 8 dereferenceable(50) %m_sepNormals, ptr noundef %7, ptr noundef %8, i64 noundef 0, i1 noundef zeroext true)
          to label %invoke.cont9 unwind label %lpad8

invoke.cont9:                                     ; preds = %invoke.cont
  %m_dmins = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 27
  %m_context10 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %9 = load ptr, ptr %m_context10, align 8
  %m_queue11 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %10 = load ptr, ptr %m_queue11, align 8
  invoke void @_ZN13b3OpenCLArrayIfEC2EP11_cl_contextP17_cl_command_queuemb(ptr noundef nonnull align 8 dereferenceable(50) %m_dmins, ptr noundef %9, ptr noundef %10, i64 noundef 0, i1 noundef zeroext true)
          to label %invoke.cont13 unwind label %lpad12

invoke.cont13:                                    ; preds = %invoke.cont9
  %m_hasSeparatingNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 28
  %m_context14 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %11 = load ptr, ptr %m_context14, align 8
  %m_queue15 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %12 = load ptr, ptr %m_queue15, align 8
  invoke void @_ZN13b3OpenCLArrayIiEC2EP11_cl_contextP17_cl_command_queuemb(ptr noundef nonnull align 8 dereferenceable(50) %m_hasSeparatingNormals, ptr noundef %11, ptr noundef %12, i64 noundef 0, i1 noundef zeroext true)
          to label %invoke.cont17 unwind label %lpad16

invoke.cont17:                                    ; preds = %invoke.cont13
  %m_concaveSepNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 29
  %m_context18 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %13 = load ptr, ptr %m_context18, align 8
  %m_queue19 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %14 = load ptr, ptr %m_queue19, align 8
  invoke void @_ZN13b3OpenCLArrayI9b3Vector3EC2EP11_cl_contextP17_cl_command_queuemb(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveSepNormals, ptr noundef %13, ptr noundef %14, i64 noundef 0, i1 noundef zeroext true)
          to label %invoke.cont21 unwind label %lpad20

invoke.cont21:                                    ; preds = %invoke.cont17
  %m_concaveHasSeparatingNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 30
  %m_context22 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %15 = load ptr, ptr %m_context22, align 8
  %m_queue23 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %16 = load ptr, ptr %m_queue23, align 8
  invoke void @_ZN13b3OpenCLArrayIiEC2EP11_cl_contextP17_cl_command_queuemb(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveHasSeparatingNormals, ptr noundef %15, ptr noundef %16, i64 noundef 0, i1 noundef zeroext true)
          to label %invoke.cont25 unwind label %lpad24

invoke.cont25:                                    ; preds = %invoke.cont21
  %m_numConcavePairsOut = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 31
  %m_context26 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %17 = load ptr, ptr %m_context26, align 8
  %m_queue27 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %18 = load ptr, ptr %m_queue27, align 8
  invoke void @_ZN13b3OpenCLArrayIiEC2EP11_cl_contextP17_cl_command_queuemb(ptr noundef nonnull align 8 dereferenceable(50) %m_numConcavePairsOut, ptr noundef %17, ptr noundef %18, i64 noundef 0, i1 noundef zeroext true)
          to label %invoke.cont29 unwind label %lpad28

invoke.cont29:                                    ; preds = %invoke.cont25
  %m_gpuCompoundPairs = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 32
  %m_context30 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %19 = load ptr, ptr %m_context30, align 8
  %m_queue31 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %20 = load ptr, ptr %m_queue31, align 8
  invoke void @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairEC2EP11_cl_contextP17_cl_command_queuemb(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuCompoundPairs, ptr noundef %19, ptr noundef %20, i64 noundef 0, i1 noundef zeroext true)
          to label %invoke.cont33 unwind label %lpad32

invoke.cont33:                                    ; preds = %invoke.cont29
  %m_gpuCompoundSepNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 33
  %m_context34 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %21 = load ptr, ptr %m_context34, align 8
  %m_queue35 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %22 = load ptr, ptr %m_queue35, align 8
  invoke void @_ZN13b3OpenCLArrayI9b3Vector3EC2EP11_cl_contextP17_cl_command_queuemb(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuCompoundSepNormals, ptr noundef %21, ptr noundef %22, i64 noundef 0, i1 noundef zeroext true)
          to label %invoke.cont37 unwind label %lpad36

invoke.cont37:                                    ; preds = %invoke.cont33
  %m_gpuHasCompoundSepNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 34
  %m_context38 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %23 = load ptr, ptr %m_context38, align 8
  %m_queue39 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %24 = load ptr, ptr %m_queue39, align 8
  invoke void @_ZN13b3OpenCLArrayIiEC2EP11_cl_contextP17_cl_command_queuemb(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuHasCompoundSepNormals, ptr noundef %23, ptr noundef %24, i64 noundef 0, i1 noundef zeroext true)
          to label %invoke.cont41 unwind label %lpad40

invoke.cont41:                                    ; preds = %invoke.cont37
  %m_numCompoundPairsOut = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 35
  %m_context42 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %25 = load ptr, ptr %m_context42, align 8
  %m_queue43 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %26 = load ptr, ptr %m_queue43, align 8
  invoke void @_ZN13b3OpenCLArrayIiEC2EP11_cl_contextP17_cl_command_queuemb(ptr noundef nonnull align 8 dereferenceable(50) %m_numCompoundPairsOut, ptr noundef %25, ptr noundef %26, i64 noundef 0, i1 noundef zeroext true)
          to label %invoke.cont45 unwind label %lpad44

invoke.cont45:                                    ; preds = %invoke.cont41
  %m_totalContactsOut46 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  store i32 0, ptr %ref.tmp, align 4
  %call = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayIiE9push_backERKib(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut46, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp, i1 noundef zeroext true)
          to label %invoke.cont48 unwind label %lpad47

invoke.cont48:                                    ; preds = %invoke.cont45
  store i32 0, ptr %errNum, align 4
  %27 = load ptr, ptr @_ZL12mprKernelsCL, align 8
  store ptr %27, ptr %mprSrc, align 8
  %28 = load ptr, ptr @_ZL19satConcaveKernelsCL, align 8
  store ptr %28, ptr %srcConcave, align 8
  call void @llvm.memset.p0.i64(ptr align 16 %flags, i8 0, i64 1024, i1 false)
  %m_mprPenetrationKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_mprPenetrationKernel, align 8
  %m_findSeparatingAxisUnitSphereKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 6
  store ptr null, ptr %m_findSeparatingAxisUnitSphereKernel, align 8
  %29 = load i8, ptr @useMprGpu, align 1
  %tobool = trunc i8 %29 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %invoke.cont48
  %m_context49 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %30 = load ptr, ptr %m_context49, align 8
  %m_device50 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %31 = load ptr, ptr %m_device50, align 8
  %32 = load ptr, ptr %mprSrc, align 8
  %arraydecay = getelementptr inbounds [1024 x i8], ptr %flags, i64 0, i64 0
  %call52 = invoke noundef ptr @_ZN13b3OpenCLUtils26compileCLProgramFromStringEP11_cl_contextP13_cl_device_idPKcPiS5_S5_b(ptr noundef %30, ptr noundef %31, ptr noundef %32, ptr noundef %errNum, ptr noundef %arraydecay, ptr noundef @.str.3, i1 noundef zeroext false)
          to label %invoke.cont51 unwind label %lpad47

invoke.cont51:                                    ; preds = %if.then
  store ptr %call52, ptr %mprProg, align 8
  %m_context53 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %33 = load ptr, ptr %m_context53, align 8
  %m_device54 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %34 = load ptr, ptr %m_device54, align 8
  %35 = load ptr, ptr %mprSrc, align 8
  %36 = load ptr, ptr %mprProg, align 8
  %call56 = invoke noundef ptr @_ZN13b3OpenCLUtils25compileCLKernelFromStringEP11_cl_contextP13_cl_device_idPKcS5_PiP11_cl_programS5_(ptr noundef %33, ptr noundef %34, ptr noundef %35, ptr noundef @.str.4, ptr noundef %errNum, ptr noundef %36, ptr noundef @.str.5)
          to label %invoke.cont55 unwind label %lpad47

invoke.cont55:                                    ; preds = %invoke.cont51
  %m_mprPenetrationKernel57 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 5
  store ptr %call56, ptr %m_mprPenetrationKernel57, align 8
  %m_context58 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %37 = load ptr, ptr %m_context58, align 8
  %m_device59 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %38 = load ptr, ptr %m_device59, align 8
  %39 = load ptr, ptr %mprSrc, align 8
  %40 = load ptr, ptr %mprProg, align 8
  %call61 = invoke noundef ptr @_ZN13b3OpenCLUtils25compileCLKernelFromStringEP11_cl_contextP13_cl_device_idPKcS5_PiP11_cl_programS5_(ptr noundef %37, ptr noundef %38, ptr noundef %39, ptr noundef @.str.6, ptr noundef %errNum, ptr noundef %40, ptr noundef @.str.5)
          to label %invoke.cont60 unwind label %lpad47

invoke.cont60:                                    ; preds = %invoke.cont55
  %m_findSeparatingAxisUnitSphereKernel62 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 6
  store ptr %call61, ptr %m_findSeparatingAxisUnitSphereKernel62, align 8
  store i32 162, ptr %numDirections, align 4
  %m_unitSphereDirections63 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 24
  %41 = load i32, ptr %numDirections, align 4
  %conv = sext i32 %41 to i64
  %call65 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_unitSphereDirections63, i64 noundef %conv, i1 noundef zeroext true)
          to label %invoke.cont64 unwind label %lpad47

invoke.cont64:                                    ; preds = %invoke.cont60
  %m_unitSphereDirections66 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 24
  %42 = load i32, ptr %numDirections, align 4
  %conv67 = sext i32 %42 to i64
  invoke void @_ZN13b3OpenCLArrayI9b3Vector3E19copyFromHostPointerEPKS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %m_unitSphereDirections66, ptr noundef @unitSphere162, i64 noundef %conv67, i64 noundef 0, i1 noundef zeroext true)
          to label %invoke.cont68 unwind label %lpad47

invoke.cont68:                                    ; preds = %invoke.cont64
  br label %if.end

lpad:                                             ; preds = %entry
  %43 = landingpad { ptr, i32 }
          cleanup
  %44 = extractvalue { ptr, i32 } %43, 0
  store ptr %44, ptr %exn.slot, align 8
  %45 = extractvalue { ptr, i32 } %43, 1
  store i32 %45, ptr %ehselector.slot, align 4
  br label %ehcleanup177

lpad8:                                            ; preds = %invoke.cont
  %46 = landingpad { ptr, i32 }
          cleanup
  %47 = extractvalue { ptr, i32 } %46, 0
  store ptr %47, ptr %exn.slot, align 8
  %48 = extractvalue { ptr, i32 } %46, 1
  store i32 %48, ptr %ehselector.slot, align 4
  br label %ehcleanup176

lpad12:                                           ; preds = %invoke.cont9
  %49 = landingpad { ptr, i32 }
          cleanup
  %50 = extractvalue { ptr, i32 } %49, 0
  store ptr %50, ptr %exn.slot, align 8
  %51 = extractvalue { ptr, i32 } %49, 1
  store i32 %51, ptr %ehselector.slot, align 4
  br label %ehcleanup175

lpad16:                                           ; preds = %invoke.cont13
  %52 = landingpad { ptr, i32 }
          cleanup
  %53 = extractvalue { ptr, i32 } %52, 0
  store ptr %53, ptr %exn.slot, align 8
  %54 = extractvalue { ptr, i32 } %52, 1
  store i32 %54, ptr %ehselector.slot, align 4
  br label %ehcleanup174

lpad20:                                           ; preds = %invoke.cont17
  %55 = landingpad { ptr, i32 }
          cleanup
  %56 = extractvalue { ptr, i32 } %55, 0
  store ptr %56, ptr %exn.slot, align 8
  %57 = extractvalue { ptr, i32 } %55, 1
  store i32 %57, ptr %ehselector.slot, align 4
  br label %ehcleanup173

lpad24:                                           ; preds = %invoke.cont21
  %58 = landingpad { ptr, i32 }
          cleanup
  %59 = extractvalue { ptr, i32 } %58, 0
  store ptr %59, ptr %exn.slot, align 8
  %60 = extractvalue { ptr, i32 } %58, 1
  store i32 %60, ptr %ehselector.slot, align 4
  br label %ehcleanup172

lpad28:                                           ; preds = %invoke.cont25
  %61 = landingpad { ptr, i32 }
          cleanup
  %62 = extractvalue { ptr, i32 } %61, 0
  store ptr %62, ptr %exn.slot, align 8
  %63 = extractvalue { ptr, i32 } %61, 1
  store i32 %63, ptr %ehselector.slot, align 4
  br label %ehcleanup171

lpad32:                                           ; preds = %invoke.cont29
  %64 = landingpad { ptr, i32 }
          cleanup
  %65 = extractvalue { ptr, i32 } %64, 0
  store ptr %65, ptr %exn.slot, align 8
  %66 = extractvalue { ptr, i32 } %64, 1
  store i32 %66, ptr %ehselector.slot, align 4
  br label %ehcleanup170

lpad36:                                           ; preds = %invoke.cont33
  %67 = landingpad { ptr, i32 }
          cleanup
  %68 = extractvalue { ptr, i32 } %67, 0
  store ptr %68, ptr %exn.slot, align 8
  %69 = extractvalue { ptr, i32 } %67, 1
  store i32 %69, ptr %ehselector.slot, align 4
  br label %ehcleanup169

lpad40:                                           ; preds = %invoke.cont37
  %70 = landingpad { ptr, i32 }
          cleanup
  %71 = extractvalue { ptr, i32 } %70, 0
  store ptr %71, ptr %exn.slot, align 8
  %72 = extractvalue { ptr, i32 } %70, 1
  store i32 %72, ptr %ehselector.slot, align 4
  br label %ehcleanup168

lpad44:                                           ; preds = %invoke.cont41
  %73 = landingpad { ptr, i32 }
          cleanup
  %74 = extractvalue { ptr, i32 } %73, 0
  store ptr %74, ptr %exn.slot, align 8
  %75 = extractvalue { ptr, i32 } %73, 1
  store i32 %75, ptr %ehselector.slot, align 4
  br label %ehcleanup

lpad47:                                           ; preds = %invoke.cont162, %invoke.cont158, %invoke.cont154, %invoke.cont150, %invoke.cont146, %invoke.cont142, %invoke.cont138, %invoke.cont134, %invoke.cont130, %invoke.cont126, %invoke.cont122, %invoke.cont118, %invoke.cont112, %invoke.cont108, %invoke.cont104, %invoke.cont100, %invoke.cont96, %invoke.cont91, %invoke.cont86, %invoke.cont81, %invoke.cont77, %invoke.cont72, %if.end, %invoke.cont64, %invoke.cont60, %invoke.cont55, %invoke.cont51, %if.then, %invoke.cont45
  %76 = landingpad { ptr, i32 }
          cleanup
  %77 = extractvalue { ptr, i32 } %76, 0
  store ptr %77, ptr %exn.slot, align 8
  %78 = extractvalue { ptr, i32 } %76, 1
  store i32 %78, ptr %ehselector.slot, align 4
  call void @_ZN13b3OpenCLArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_numCompoundPairsOut) #13
  br label %ehcleanup

if.end:                                           ; preds = %invoke.cont68, %invoke.cont48
  %m_context69 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %79 = load ptr, ptr %m_context69, align 8
  %m_device70 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %80 = load ptr, ptr %m_device70, align 8
  %81 = load ptr, ptr @_ZL12satKernelsCL, align 8
  %arraydecay71 = getelementptr inbounds [1024 x i8], ptr %flags, i64 0, i64 0
  %call73 = invoke noundef ptr @_ZN13b3OpenCLUtils26compileCLProgramFromStringEP11_cl_contextP13_cl_device_idPKcPiS5_S5_b(ptr noundef %79, ptr noundef %80, ptr noundef %81, ptr noundef %errNum, ptr noundef %arraydecay71, ptr noundef @.str.7, i1 noundef zeroext false)
          to label %invoke.cont72 unwind label %lpad47

invoke.cont72:                                    ; preds = %if.end
  store ptr %call73, ptr %satProg, align 8
  %m_context74 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %82 = load ptr, ptr %m_context74, align 8
  %m_device75 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %83 = load ptr, ptr %m_device75, align 8
  %84 = load ptr, ptr %srcConcave, align 8
  %arraydecay76 = getelementptr inbounds [1024 x i8], ptr %flags, i64 0, i64 0
  %call78 = invoke noundef ptr @_ZN13b3OpenCLUtils26compileCLProgramFromStringEP11_cl_contextP13_cl_device_idPKcPiS5_S5_b(ptr noundef %82, ptr noundef %83, ptr noundef %84, ptr noundef %errNum, ptr noundef %arraydecay76, ptr noundef @.str.8, i1 noundef zeroext false)
          to label %invoke.cont77 unwind label %lpad47

invoke.cont77:                                    ; preds = %invoke.cont72
  store ptr %call78, ptr %satConcaveProg, align 8
  %m_context79 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %85 = load ptr, ptr %m_context79, align 8
  %m_device80 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %86 = load ptr, ptr %m_device80, align 8
  %87 = load ptr, ptr @_ZL12satKernelsCL, align 8
  %88 = load ptr, ptr %satProg, align 8
  %call82 = invoke noundef ptr @_ZN13b3OpenCLUtils25compileCLKernelFromStringEP11_cl_contextP13_cl_device_idPKcS5_PiP11_cl_programS5_(ptr noundef %85, ptr noundef %86, ptr noundef %87, ptr noundef @.str.9, ptr noundef %errNum, ptr noundef %88, ptr noundef @.str.5)
          to label %invoke.cont81 unwind label %lpad47

invoke.cont81:                                    ; preds = %invoke.cont77
  %m_findSeparatingAxisKernel83 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 4
  store ptr %call82, ptr %m_findSeparatingAxisKernel83, align 8
  %m_context84 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %89 = load ptr, ptr %m_context84, align 8
  %m_device85 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %90 = load ptr, ptr %m_device85, align 8
  %91 = load ptr, ptr @_ZL12satKernelsCL, align 8
  %92 = load ptr, ptr %satProg, align 8
  %call87 = invoke noundef ptr @_ZN13b3OpenCLUtils25compileCLKernelFromStringEP11_cl_contextP13_cl_device_idPKcS5_PiP11_cl_programS5_(ptr noundef %89, ptr noundef %90, ptr noundef %91, ptr noundef @.str.10, ptr noundef %errNum, ptr noundef %92, ptr noundef @.str.5)
          to label %invoke.cont86 unwind label %lpad47

invoke.cont86:                                    ; preds = %invoke.cont81
  %m_findSeparatingAxisVertexFaceKernel88 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 7
  store ptr %call87, ptr %m_findSeparatingAxisVertexFaceKernel88, align 8
  %m_context89 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %93 = load ptr, ptr %m_context89, align 8
  %m_device90 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %94 = load ptr, ptr %m_device90, align 8
  %95 = load ptr, ptr @_ZL12satKernelsCL, align 8
  %96 = load ptr, ptr %satProg, align 8
  %call92 = invoke noundef ptr @_ZN13b3OpenCLUtils25compileCLKernelFromStringEP11_cl_contextP13_cl_device_idPKcS5_PiP11_cl_programS5_(ptr noundef %93, ptr noundef %94, ptr noundef %95, ptr noundef @.str.11, ptr noundef %errNum, ptr noundef %96, ptr noundef @.str.5)
          to label %invoke.cont91 unwind label %lpad47

invoke.cont91:                                    ; preds = %invoke.cont86
  %m_findSeparatingAxisEdgeEdgeKernel93 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 8
  store ptr %call92, ptr %m_findSeparatingAxisEdgeEdgeKernel93, align 8
  %m_context94 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %97 = load ptr, ptr %m_context94, align 8
  %m_device95 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %98 = load ptr, ptr %m_device95, align 8
  %99 = load ptr, ptr @_ZL12satKernelsCL, align 8
  %100 = load ptr, ptr %satProg, align 8
  %call97 = invoke noundef ptr @_ZN13b3OpenCLUtils25compileCLKernelFromStringEP11_cl_contextP13_cl_device_idPKcS5_PiP11_cl_programS5_(ptr noundef %97, ptr noundef %98, ptr noundef %99, ptr noundef @.str.12, ptr noundef %errNum, ptr noundef %100, ptr noundef @.str.5)
          to label %invoke.cont96 unwind label %lpad47

invoke.cont96:                                    ; preds = %invoke.cont91
  %m_findConcaveSeparatingAxisKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 9
  store ptr %call97, ptr %m_findConcaveSeparatingAxisKernel, align 8
  %m_context98 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %101 = load ptr, ptr %m_context98, align 8
  %m_device99 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %102 = load ptr, ptr %m_device99, align 8
  %103 = load ptr, ptr %srcConcave, align 8
  %104 = load ptr, ptr %satConcaveProg, align 8
  %call101 = invoke noundef ptr @_ZN13b3OpenCLUtils25compileCLKernelFromStringEP11_cl_contextP13_cl_device_idPKcS5_PiP11_cl_programS5_(ptr noundef %101, ptr noundef %102, ptr noundef %103, ptr noundef @.str.13, ptr noundef %errNum, ptr noundef %104, ptr noundef @.str.5)
          to label %invoke.cont100 unwind label %lpad47

invoke.cont100:                                   ; preds = %invoke.cont96
  %m_findConcaveSeparatingAxisVertexFaceKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 10
  store ptr %call101, ptr %m_findConcaveSeparatingAxisVertexFaceKernel, align 8
  %m_context102 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %105 = load ptr, ptr %m_context102, align 8
  %m_device103 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %106 = load ptr, ptr %m_device103, align 8
  %107 = load ptr, ptr %srcConcave, align 8
  %108 = load ptr, ptr %satConcaveProg, align 8
  %call105 = invoke noundef ptr @_ZN13b3OpenCLUtils25compileCLKernelFromStringEP11_cl_contextP13_cl_device_idPKcS5_PiP11_cl_programS5_(ptr noundef %105, ptr noundef %106, ptr noundef %107, ptr noundef @.str.14, ptr noundef %errNum, ptr noundef %108, ptr noundef @.str.5)
          to label %invoke.cont104 unwind label %lpad47

invoke.cont104:                                   ; preds = %invoke.cont100
  %m_findConcaveSeparatingAxisEdgeEdgeKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 11
  store ptr %call105, ptr %m_findConcaveSeparatingAxisEdgeEdgeKernel, align 8
  %m_context106 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %109 = load ptr, ptr %m_context106, align 8
  %m_device107 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %110 = load ptr, ptr %m_device107, align 8
  %111 = load ptr, ptr @_ZL12satKernelsCL, align 8
  %112 = load ptr, ptr %satProg, align 8
  %call109 = invoke noundef ptr @_ZN13b3OpenCLUtils25compileCLKernelFromStringEP11_cl_contextP13_cl_device_idPKcS5_PiP11_cl_programS5_(ptr noundef %109, ptr noundef %110, ptr noundef %111, ptr noundef @.str.15, ptr noundef %errNum, ptr noundef %112, ptr noundef @.str.5)
          to label %invoke.cont108 unwind label %lpad47

invoke.cont108:                                   ; preds = %invoke.cont104
  %m_findCompoundPairsKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 12
  store ptr %call109, ptr %m_findCompoundPairsKernel, align 8
  %m_context110 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %113 = load ptr, ptr %m_context110, align 8
  %m_device111 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %114 = load ptr, ptr %m_device111, align 8
  %115 = load ptr, ptr @_ZL12satKernelsCL, align 8
  %116 = load ptr, ptr %satProg, align 8
  %call113 = invoke noundef ptr @_ZN13b3OpenCLUtils25compileCLKernelFromStringEP11_cl_contextP13_cl_device_idPKcS5_PiP11_cl_programS5_(ptr noundef %113, ptr noundef %114, ptr noundef %115, ptr noundef @.str.16, ptr noundef %errNum, ptr noundef %116, ptr noundef @.str.5)
          to label %invoke.cont112 unwind label %lpad47

invoke.cont112:                                   ; preds = %invoke.cont108
  %m_processCompoundPairsKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 13
  store ptr %call113, ptr %m_processCompoundPairsKernel, align 8
  %117 = load ptr, ptr @_ZL16satClipKernelsCL, align 8
  store ptr %117, ptr %srcClip, align 8
  call void @llvm.memset.p0.i64(ptr align 16 %flags114, i8 0, i64 1024, i1 false)
  %m_context115 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %118 = load ptr, ptr %m_context115, align 8
  %m_device116 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %119 = load ptr, ptr %m_device116, align 8
  %120 = load ptr, ptr %srcClip, align 8
  %arraydecay117 = getelementptr inbounds [1024 x i8], ptr %flags114, i64 0, i64 0
  %call119 = invoke noundef ptr @_ZN13b3OpenCLUtils26compileCLProgramFromStringEP11_cl_contextP13_cl_device_idPKcPiS5_S5_b(ptr noundef %118, ptr noundef %119, ptr noundef %120, ptr noundef %errNum, ptr noundef %arraydecay117, ptr noundef @.str.17, i1 noundef zeroext false)
          to label %invoke.cont118 unwind label %lpad47

invoke.cont118:                                   ; preds = %invoke.cont112
  store ptr %call119, ptr %satClipContactsProg, align 8
  %m_context120 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %121 = load ptr, ptr %m_context120, align 8
  %m_device121 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %122 = load ptr, ptr %m_device121, align 8
  %123 = load ptr, ptr %srcClip, align 8
  %124 = load ptr, ptr %satClipContactsProg, align 8
  %call123 = invoke noundef ptr @_ZN13b3OpenCLUtils25compileCLKernelFromStringEP11_cl_contextP13_cl_device_idPKcS5_PiP11_cl_programS5_(ptr noundef %121, ptr noundef %122, ptr noundef %123, ptr noundef @.str.18, ptr noundef %errNum, ptr noundef %124, ptr noundef @.str.5)
          to label %invoke.cont122 unwind label %lpad47

invoke.cont122:                                   ; preds = %invoke.cont118
  %m_clipHullHullKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 14
  store ptr %call123, ptr %m_clipHullHullKernel, align 8
  %m_context124 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %125 = load ptr, ptr %m_context124, align 8
  %m_device125 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %126 = load ptr, ptr %m_device125, align 8
  %127 = load ptr, ptr %srcClip, align 8
  %128 = load ptr, ptr %satClipContactsProg, align 8
  %call127 = invoke noundef ptr @_ZN13b3OpenCLUtils25compileCLKernelFromStringEP11_cl_contextP13_cl_device_idPKcS5_PiP11_cl_programS5_(ptr noundef %125, ptr noundef %126, ptr noundef %127, ptr noundef @.str.19, ptr noundef %errNum, ptr noundef %128, ptr noundef @.str.5)
          to label %invoke.cont126 unwind label %lpad47

invoke.cont126:                                   ; preds = %invoke.cont122
  %m_clipCompoundsHullHullKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 15
  store ptr %call127, ptr %m_clipCompoundsHullHullKernel, align 8
  %m_context128 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %129 = load ptr, ptr %m_context128, align 8
  %m_device129 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %130 = load ptr, ptr %m_device129, align 8
  %131 = load ptr, ptr %srcClip, align 8
  %132 = load ptr, ptr %satClipContactsProg, align 8
  %call131 = invoke noundef ptr @_ZN13b3OpenCLUtils25compileCLKernelFromStringEP11_cl_contextP13_cl_device_idPKcS5_PiP11_cl_programS5_(ptr noundef %129, ptr noundef %130, ptr noundef %131, ptr noundef @.str.20, ptr noundef %errNum, ptr noundef %132, ptr noundef @.str.5)
          to label %invoke.cont130 unwind label %lpad47

invoke.cont130:                                   ; preds = %invoke.cont126
  %m_findClippingFacesKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 17
  store ptr %call131, ptr %m_findClippingFacesKernel, align 8
  %m_context132 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %133 = load ptr, ptr %m_context132, align 8
  %m_device133 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %134 = load ptr, ptr %m_device133, align 8
  %135 = load ptr, ptr %srcClip, align 8
  %136 = load ptr, ptr %satClipContactsProg, align 8
  %call135 = invoke noundef ptr @_ZN13b3OpenCLUtils25compileCLKernelFromStringEP11_cl_contextP13_cl_device_idPKcS5_PiP11_cl_programS5_(ptr noundef %133, ptr noundef %134, ptr noundef %135, ptr noundef @.str.21, ptr noundef %errNum, ptr noundef %136, ptr noundef @.str.5)
          to label %invoke.cont134 unwind label %lpad47

invoke.cont134:                                   ; preds = %invoke.cont130
  %m_clipFacesAndFindContacts = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 16
  store ptr %call135, ptr %m_clipFacesAndFindContacts, align 8
  %m_context136 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %137 = load ptr, ptr %m_context136, align 8
  %m_device137 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %138 = load ptr, ptr %m_device137, align 8
  %139 = load ptr, ptr %srcClip, align 8
  %140 = load ptr, ptr %satClipContactsProg, align 8
  %call139 = invoke noundef ptr @_ZN13b3OpenCLUtils25compileCLKernelFromStringEP11_cl_contextP13_cl_device_idPKcS5_PiP11_cl_programS5_(ptr noundef %137, ptr noundef %138, ptr noundef %139, ptr noundef @.str.22, ptr noundef %errNum, ptr noundef %140, ptr noundef @.str.5)
          to label %invoke.cont138 unwind label %lpad47

invoke.cont138:                                   ; preds = %invoke.cont134
  %m_clipHullHullConcaveConvexKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 18
  store ptr %call139, ptr %m_clipHullHullConcaveConvexKernel, align 8
  %m_context140 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %141 = load ptr, ptr %m_context140, align 8
  %m_device141 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %142 = load ptr, ptr %m_device141, align 8
  %143 = load ptr, ptr %srcClip, align 8
  %144 = load ptr, ptr %satClipContactsProg, align 8
  %call143 = invoke noundef ptr @_ZN13b3OpenCLUtils25compileCLKernelFromStringEP11_cl_contextP13_cl_device_idPKcS5_PiP11_cl_programS5_(ptr noundef %141, ptr noundef %142, ptr noundef %143, ptr noundef @.str.23, ptr noundef %errNum, ptr noundef %144, ptr noundef @.str.5)
          to label %invoke.cont142 unwind label %lpad47

invoke.cont142:                                   ; preds = %invoke.cont138
  %m_newContactReductionKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 19
  store ptr %call143, ptr %m_newContactReductionKernel, align 8
  %145 = load ptr, ptr @_ZL20bvhTraversalKernelCL, align 8
  store ptr %145, ptr %srcBvh, align 8
  %m_context144 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %146 = load ptr, ptr %m_context144, align 8
  %m_device145 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %147 = load ptr, ptr %m_device145, align 8
  %148 = load ptr, ptr %srcBvh, align 8
  %call147 = invoke noundef ptr @_ZN13b3OpenCLUtils26compileCLProgramFromStringEP11_cl_contextP13_cl_device_idPKcPiS5_S5_b(ptr noundef %146, ptr noundef %147, ptr noundef %148, ptr noundef %errNum, ptr noundef @.str.5, ptr noundef @.str.24, i1 noundef zeroext false)
          to label %invoke.cont146 unwind label %lpad47

invoke.cont146:                                   ; preds = %invoke.cont142
  store ptr %call147, ptr %bvhTraversalProg, align 8
  %m_context148 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %149 = load ptr, ptr %m_context148, align 8
  %m_device149 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %150 = load ptr, ptr %m_device149, align 8
  %151 = load ptr, ptr %srcBvh, align 8
  %152 = load ptr, ptr %bvhTraversalProg, align 8
  %call151 = invoke noundef ptr @_ZN13b3OpenCLUtils25compileCLKernelFromStringEP11_cl_contextP13_cl_device_idPKcS5_PiP11_cl_programS5_(ptr noundef %149, ptr noundef %150, ptr noundef %151, ptr noundef @.str.25, ptr noundef %errNum, ptr noundef %152, ptr noundef @.str.5)
          to label %invoke.cont150 unwind label %lpad47

invoke.cont150:                                   ; preds = %invoke.cont146
  %m_bvhTraversalKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 20
  store ptr %call151, ptr %m_bvhTraversalKernel, align 8
  %153 = load ptr, ptr @_ZL26primitiveContactsKernelsCL, align 8
  store ptr %153, ptr %primitiveContactsSrc, align 8
  %m_context152 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %154 = load ptr, ptr %m_context152, align 8
  %m_device153 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %155 = load ptr, ptr %m_device153, align 8
  %156 = load ptr, ptr %primitiveContactsSrc, align 8
  %call155 = invoke noundef ptr @_ZN13b3OpenCLUtils26compileCLProgramFromStringEP11_cl_contextP13_cl_device_idPKcPiS5_S5_b(ptr noundef %154, ptr noundef %155, ptr noundef %156, ptr noundef %errNum, ptr noundef @.str.5, ptr noundef @.str.26, i1 noundef zeroext false)
          to label %invoke.cont154 unwind label %lpad47

invoke.cont154:                                   ; preds = %invoke.cont150
  store ptr %call155, ptr %primitiveContactsProg, align 8
  %m_context156 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %157 = load ptr, ptr %m_context156, align 8
  %m_device157 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %158 = load ptr, ptr %m_device157, align 8
  %159 = load ptr, ptr %primitiveContactsSrc, align 8
  %160 = load ptr, ptr %primitiveContactsProg, align 8
  %call159 = invoke noundef ptr @_ZN13b3OpenCLUtils25compileCLKernelFromStringEP11_cl_contextP13_cl_device_idPKcS5_PiP11_cl_programS5_(ptr noundef %157, ptr noundef %158, ptr noundef %159, ptr noundef @.str.27, ptr noundef %errNum, ptr noundef %160, ptr noundef @.str.5)
          to label %invoke.cont158 unwind label %lpad47

invoke.cont158:                                   ; preds = %invoke.cont154
  %m_primitiveContactsKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 21
  store ptr %call159, ptr %m_primitiveContactsKernel, align 8
  %m_context160 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %161 = load ptr, ptr %m_context160, align 8
  %m_device161 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %162 = load ptr, ptr %m_device161, align 8
  %163 = load ptr, ptr %primitiveContactsSrc, align 8
  %164 = load ptr, ptr %primitiveContactsProg, align 8
  %call163 = invoke noundef ptr @_ZN13b3OpenCLUtils25compileCLKernelFromStringEP11_cl_contextP13_cl_device_idPKcS5_PiP11_cl_programS5_(ptr noundef %161, ptr noundef %162, ptr noundef %163, ptr noundef @.str.28, ptr noundef %errNum, ptr noundef %164, ptr noundef @.str.5)
          to label %invoke.cont162 unwind label %lpad47

invoke.cont162:                                   ; preds = %invoke.cont158
  %m_findConcaveSphereContactsKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 22
  store ptr %call163, ptr %m_findConcaveSphereContactsKernel, align 8
  %m_context164 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 1
  %165 = load ptr, ptr %m_context164, align 8
  %m_device165 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 2
  %166 = load ptr, ptr %m_device165, align 8
  %167 = load ptr, ptr %primitiveContactsSrc, align 8
  %168 = load ptr, ptr %primitiveContactsProg, align 8
  %call167 = invoke noundef ptr @_ZN13b3OpenCLUtils25compileCLKernelFromStringEP11_cl_contextP13_cl_device_idPKcS5_PiP11_cl_programS5_(ptr noundef %165, ptr noundef %166, ptr noundef %167, ptr noundef @.str.29, ptr noundef %errNum, ptr noundef %168, ptr noundef @.str.5)
          to label %invoke.cont166 unwind label %lpad47

invoke.cont166:                                   ; preds = %invoke.cont162
  %m_processCompoundPairsPrimitivesKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 23
  store ptr %call167, ptr %m_processCompoundPairsPrimitivesKernel, align 8
  ret void

ehcleanup:                                        ; preds = %lpad47, %lpad44
  call void @_ZN13b3OpenCLArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuHasCompoundSepNormals) #13
  br label %ehcleanup168

ehcleanup168:                                     ; preds = %ehcleanup, %lpad40
  call void @_ZN13b3OpenCLArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuCompoundSepNormals) #13
  br label %ehcleanup169

ehcleanup169:                                     ; preds = %ehcleanup168, %lpad36
  call void @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuCompoundPairs) #13
  br label %ehcleanup170

ehcleanup170:                                     ; preds = %ehcleanup169, %lpad32
  call void @_ZN13b3OpenCLArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_numConcavePairsOut) #13
  br label %ehcleanup171

ehcleanup171:                                     ; preds = %ehcleanup170, %lpad28
  call void @_ZN13b3OpenCLArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveHasSeparatingNormals) #13
  br label %ehcleanup172

ehcleanup172:                                     ; preds = %ehcleanup171, %lpad24
  call void @_ZN13b3OpenCLArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveSepNormals) #13
  br label %ehcleanup173

ehcleanup173:                                     ; preds = %ehcleanup172, %lpad20
  call void @_ZN13b3OpenCLArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_hasSeparatingNormals) #13
  br label %ehcleanup174

ehcleanup174:                                     ; preds = %ehcleanup173, %lpad16
  call void @_ZN13b3OpenCLArrayIfED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_dmins) #13
  br label %ehcleanup175

ehcleanup175:                                     ; preds = %ehcleanup174, %lpad12
  call void @_ZN13b3OpenCLArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_sepNormals) #13
  br label %ehcleanup176

ehcleanup176:                                     ; preds = %ehcleanup175, %lpad8
  call void @_ZN13b3OpenCLArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut) #13
  br label %ehcleanup177

ehcleanup177:                                     ; preds = %ehcleanup176, %lpad
  call void @_ZN13b3OpenCLArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_unitSphereDirections) #13
  br label %eh.resume

eh.resume:                                        ; preds = %ehcleanup177
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val178 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val178
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayI9b3Vector3EC2EP11_cl_contextP17_cl_command_queuemb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %ctx, ptr noundef %queue, i64 noundef %initialCapacity, i1 noundef zeroext %allowGrowingCapacity) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %queue.addr = alloca ptr, align 8
  %initialCapacity.addr = alloca i64, align 8
  %allowGrowingCapacity.addr = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %queue, ptr %queue.addr, align 8
  store i64 %initialCapacity, ptr %initialCapacity.addr, align 8
  %frombool = zext i1 %allowGrowingCapacity to i8
  store i8 %frombool, ptr %allowGrowingCapacity.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayI9b3Vector3E, i32 0, inrange i32 0, i32 2), ptr %this1, align 8
  %m_size = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 1
  store i64 0, ptr %m_size, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 2
  store i64 0, ptr %m_capacity, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 3
  store ptr null, ptr %m_clBuffer, align 8
  %m_clContext = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 4
  %0 = load ptr, ptr %ctx.addr, align 8
  store ptr %0, ptr %m_clContext, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 5
  %1 = load ptr, ptr %queue.addr, align 8
  store ptr %1, ptr %m_commandQueue, align 8
  %m_ownsMemory = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %m_allowGrowingCapacity = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 7
  store i8 1, ptr %m_allowGrowingCapacity, align 1
  %2 = load i64, ptr %initialCapacity.addr, align 8
  %tobool = icmp ne i64 %2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %initialCapacity.addr, align 8
  %call = call noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, i64 noundef %3, i1 noundef zeroext true)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load i8, ptr %allowGrowingCapacity.addr, align 1
  %tobool2 = trunc i8 %4 to i1
  %m_allowGrowingCapacity3 = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 7
  %frombool4 = zext i1 %tobool2 to i8
  store i8 %frombool4, ptr %m_allowGrowingCapacity3, align 1
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayIiEC2EP11_cl_contextP17_cl_command_queuemb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %ctx, ptr noundef %queue, i64 noundef %initialCapacity, i1 noundef zeroext %allowGrowingCapacity) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %queue.addr = alloca ptr, align 8
  %initialCapacity.addr = alloca i64, align 8
  %allowGrowingCapacity.addr = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %queue, ptr %queue.addr, align 8
  store i64 %initialCapacity, ptr %initialCapacity.addr, align 8
  %frombool = zext i1 %allowGrowingCapacity to i8
  store i8 %frombool, ptr %allowGrowingCapacity.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayIiE, i32 0, inrange i32 0, i32 2), ptr %this1, align 8
  %m_size = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 1
  store i64 0, ptr %m_size, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 2
  store i64 0, ptr %m_capacity, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 3
  store ptr null, ptr %m_clBuffer, align 8
  %m_clContext = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 4
  %0 = load ptr, ptr %ctx.addr, align 8
  store ptr %0, ptr %m_clContext, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 5
  %1 = load ptr, ptr %queue.addr, align 8
  store ptr %1, ptr %m_commandQueue, align 8
  %m_ownsMemory = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %m_allowGrowingCapacity = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 7
  store i8 1, ptr %m_allowGrowingCapacity, align 1
  %2 = load i64, ptr %initialCapacity.addr, align 8
  %tobool = icmp ne i64 %2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %initialCapacity.addr, align 8
  %call = call noundef zeroext i1 @_ZN13b3OpenCLArrayIiE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, i64 noundef %3, i1 noundef zeroext true)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load i8, ptr %allowGrowingCapacity.addr, align 1
  %tobool2 = trunc i8 %4 to i1
  %m_allowGrowingCapacity3 = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 7
  %frombool4 = zext i1 %tobool2 to i8
  store i8 %frombool4, ptr %m_allowGrowingCapacity3, align 1
  ret void
}

declare i32 @__gxx_personality_v0(...)

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayIfEC2EP11_cl_contextP17_cl_command_queuemb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %ctx, ptr noundef %queue, i64 noundef %initialCapacity, i1 noundef zeroext %allowGrowingCapacity) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %queue.addr = alloca ptr, align 8
  %initialCapacity.addr = alloca i64, align 8
  %allowGrowingCapacity.addr = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %queue, ptr %queue.addr, align 8
  store i64 %initialCapacity, ptr %initialCapacity.addr, align 8
  %frombool = zext i1 %allowGrowingCapacity to i8
  store i8 %frombool, ptr %allowGrowingCapacity.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayIfE, i32 0, inrange i32 0, i32 2), ptr %this1, align 8
  %m_size = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this1, i32 0, i32 1
  store i64 0, ptr %m_size, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this1, i32 0, i32 2
  store i64 0, ptr %m_capacity, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this1, i32 0, i32 3
  store ptr null, ptr %m_clBuffer, align 8
  %m_clContext = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this1, i32 0, i32 4
  %0 = load ptr, ptr %ctx.addr, align 8
  store ptr %0, ptr %m_clContext, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this1, i32 0, i32 5
  %1 = load ptr, ptr %queue.addr, align 8
  store ptr %1, ptr %m_commandQueue, align 8
  %m_ownsMemory = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %m_allowGrowingCapacity = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this1, i32 0, i32 7
  store i8 1, ptr %m_allowGrowingCapacity, align 1
  %2 = load i64, ptr %initialCapacity.addr, align 8
  %tobool = icmp ne i64 %2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %initialCapacity.addr, align 8
  %call = call noundef zeroext i1 @_ZN13b3OpenCLArrayIfE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, i64 noundef %3, i1 noundef zeroext true)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load i8, ptr %allowGrowingCapacity.addr, align 1
  %tobool2 = trunc i8 %4 to i1
  %m_allowGrowingCapacity3 = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this1, i32 0, i32 7
  %frombool4 = zext i1 %tobool2 to i8
  store i8 %frombool4, ptr %m_allowGrowingCapacity3, align 1
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairEC2EP11_cl_contextP17_cl_command_queuemb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %ctx, ptr noundef %queue, i64 noundef %initialCapacity, i1 noundef zeroext %allowGrowingCapacity) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %queue.addr = alloca ptr, align 8
  %initialCapacity.addr = alloca i64, align 8
  %allowGrowingCapacity.addr = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %queue, ptr %queue.addr, align 8
  store i64 %initialCapacity, ptr %initialCapacity.addr, align 8
  %frombool = zext i1 %allowGrowingCapacity to i8
  store i8 %frombool, ptr %allowGrowingCapacity.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayI25b3CompoundOverlappingPairE, i32 0, inrange i32 0, i32 2), ptr %this1, align 8
  %m_size = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 1
  store i64 0, ptr %m_size, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 2
  store i64 0, ptr %m_capacity, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 3
  store ptr null, ptr %m_clBuffer, align 8
  %m_clContext = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 4
  %0 = load ptr, ptr %ctx.addr, align 8
  store ptr %0, ptr %m_clContext, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 5
  %1 = load ptr, ptr %queue.addr, align 8
  store ptr %1, ptr %m_commandQueue, align 8
  %m_ownsMemory = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %m_allowGrowingCapacity = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 7
  store i8 1, ptr %m_allowGrowingCapacity, align 1
  %2 = load i64, ptr %initialCapacity.addr, align 8
  %tobool = icmp ne i64 %2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %initialCapacity.addr, align 8
  %call = call noundef zeroext i1 @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, i64 noundef %3, i1 noundef zeroext true)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load i8, ptr %allowGrowingCapacity.addr, align 1
  %tobool2 = trunc i8 %4 to i1
  %m_allowGrowingCapacity3 = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 7
  %frombool4 = zext i1 %tobool2 to i8
  store i8 %frombool4, ptr %m_allowGrowingCapacity3, align 1
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN13b3OpenCLArrayIiE9push_backERKib(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 4 dereferenceable(4) %_Val, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_Val.addr = alloca ptr, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %result = alloca i8, align 1
  %sz = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %_Val, ptr %_Val.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  store i8 1, ptr %result, align 1
  %call = call noundef i64 @_ZNK13b3OpenCLArrayIiE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  store i64 %call, ptr %sz, align 8
  %0 = load i64, ptr %sz, align 8
  %call2 = call noundef i64 @_ZNK13b3OpenCLArrayIiE8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %cmp = icmp eq i64 %0, %call2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call3 = call noundef i64 @_ZNK13b3OpenCLArrayIiE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %call4 = call noundef i64 @_ZN13b3OpenCLArrayIiE9allocSizeEm(ptr noundef nonnull align 8 dereferenceable(50) %this1, i64 noundef %call3)
  %call5 = call noundef zeroext i1 @_ZN13b3OpenCLArrayIiE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, i64 noundef %call4, i1 noundef zeroext true)
  %frombool6 = zext i1 %call5 to i8
  store i8 %frombool6, ptr %result, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load ptr, ptr %_Val.addr, align 8
  %2 = load i64, ptr %sz, align 8
  %3 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool = trunc i8 %3 to i1
  call void @_ZN13b3OpenCLArrayIiE19copyFromHostPointerEPKimmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, ptr noundef %1, i64 noundef 1, i64 noundef %2, i1 noundef zeroext %tobool)
  %m_size = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 1
  %4 = load i64, ptr %m_size, align 8
  %inc = add i64 %4, 1
  store i64 %inc, ptr %m_size, align 8
  %5 = load i8, ptr %result, align 1
  %tobool7 = trunc i8 %5 to i1
  ret i1 %tobool7
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #7

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN13b3OpenCLUtils26compileCLProgramFromStringEP11_cl_contextP13_cl_device_idPKcPiS5_S5_b(ptr noundef %clContext, ptr noundef %device, ptr noundef %kernelSource, ptr noundef %pErrNum, ptr noundef %additionalMacros, ptr noundef %srcFileNameForCaching, i1 noundef zeroext %disableBinaryCaching) #0 comdat align 2 {
entry:
  %clContext.addr = alloca ptr, align 8
  %device.addr = alloca ptr, align 8
  %kernelSource.addr = alloca ptr, align 8
  %pErrNum.addr = alloca ptr, align 8
  %additionalMacros.addr = alloca ptr, align 8
  %srcFileNameForCaching.addr = alloca ptr, align 8
  %disableBinaryCaching.addr = alloca i8, align 1
  store ptr %clContext, ptr %clContext.addr, align 8
  store ptr %device, ptr %device.addr, align 8
  store ptr %kernelSource, ptr %kernelSource.addr, align 8
  store ptr %pErrNum, ptr %pErrNum.addr, align 8
  store ptr %additionalMacros, ptr %additionalMacros.addr, align 8
  store ptr %srcFileNameForCaching, ptr %srcFileNameForCaching.addr, align 8
  %frombool = zext i1 %disableBinaryCaching to i8
  store i8 %frombool, ptr %disableBinaryCaching.addr, align 1
  %0 = load ptr, ptr %clContext.addr, align 8
  %1 = load ptr, ptr %device.addr, align 8
  %2 = load ptr, ptr %kernelSource.addr, align 8
  %3 = load ptr, ptr %pErrNum.addr, align 8
  %4 = load ptr, ptr %additionalMacros.addr, align 8
  %5 = load ptr, ptr %srcFileNameForCaching.addr, align 8
  %6 = load i8, ptr %disableBinaryCaching.addr, align 1
  %tobool = trunc i8 %6 to i1
  %call = call ptr @b3OpenCLUtils_compileCLProgramFromString(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, ptr noundef %5, i1 noundef zeroext %tobool)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN13b3OpenCLUtils25compileCLKernelFromStringEP11_cl_contextP13_cl_device_idPKcS5_PiP11_cl_programS5_(ptr noundef %clContext, ptr noundef %device, ptr noundef %kernelSource, ptr noundef %kernelName, ptr noundef %pErrNum, ptr noundef %prog, ptr noundef %additionalMacros) #0 comdat align 2 {
entry:
  %clContext.addr = alloca ptr, align 8
  %device.addr = alloca ptr, align 8
  %kernelSource.addr = alloca ptr, align 8
  %kernelName.addr = alloca ptr, align 8
  %pErrNum.addr = alloca ptr, align 8
  %prog.addr = alloca ptr, align 8
  %additionalMacros.addr = alloca ptr, align 8
  store ptr %clContext, ptr %clContext.addr, align 8
  store ptr %device, ptr %device.addr, align 8
  store ptr %kernelSource, ptr %kernelSource.addr, align 8
  store ptr %kernelName, ptr %kernelName.addr, align 8
  store ptr %pErrNum, ptr %pErrNum.addr, align 8
  store ptr %prog, ptr %prog.addr, align 8
  store ptr %additionalMacros, ptr %additionalMacros.addr, align 8
  %0 = load ptr, ptr %clContext.addr, align 8
  %1 = load ptr, ptr %device.addr, align 8
  %2 = load ptr, ptr %kernelSource.addr, align 8
  %3 = load ptr, ptr %kernelName.addr, align 8
  %4 = load ptr, ptr %pErrNum.addr, align 8
  %5 = load ptr, ptr %prog.addr, align 8
  %6 = load ptr, ptr %additionalMacros.addr, align 8
  %call = call ptr @b3OpenCLUtils_compileCLKernelFromString(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, ptr noundef %5, ptr noundef %6)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %this, i64 noundef %newsize, i1 noundef zeroext %copyOldContents) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  %copyOldContents.addr = alloca i8, align 1
  %result = alloca i8, align 1
  %curSize = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  %frombool = zext i1 %copyOldContents to i8
  store i8 %frombool, ptr %copyOldContents.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  store i8 1, ptr %result, align 1
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI9b3Vector3E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  store i64 %call, ptr %curSize, align 8
  %0 = load i64, ptr %newsize.addr, align 8
  %1 = load i64, ptr %curSize, align 8
  %cmp = icmp ult i64 %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end7

if.else:                                          ; preds = %entry
  %2 = load i64, ptr %newsize.addr, align 8
  %call2 = call noundef i64 @_ZNK13b3OpenCLArrayI9b3Vector3E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %cmp3 = icmp ugt i64 %2, %call2
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %3 = load i64, ptr %newsize.addr, align 8
  %4 = load i8, ptr %copyOldContents.addr, align 1
  %tobool = trunc i8 %4 to i1
  %call5 = call noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, i64 noundef %3, i1 noundef zeroext %tobool)
  %frombool6 = zext i1 %call5 to i8
  store i8 %frombool6, ptr %result, align 1
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.else
  br label %if.end7

if.end7:                                          ; preds = %if.end, %if.then
  %5 = load i8, ptr %result, align 1
  %tobool8 = trunc i8 %5 to i1
  br i1 %tobool8, label %if.then9, label %if.else10

if.then9:                                         ; preds = %if.end7
  %6 = load i64, ptr %newsize.addr, align 8
  %m_size = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 1
  store i64 %6, ptr %m_size, align 8
  br label %if.end12

if.else10:                                        ; preds = %if.end7
  %m_size11 = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 1
  store i64 0, ptr %m_size11, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.else10, %if.then9
  %7 = load i8, ptr %result, align 1
  %tobool13 = trunc i8 %7 to i1
  ret i1 %tobool13
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayI9b3Vector3E19copyFromHostPointerEPKS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %src, i64 noundef %numElems, i64 noundef %destFirstElem, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %src.addr = alloca ptr, align 8
  %numElems.addr = alloca i64, align 8
  %destFirstElem.addr = alloca i64, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %status = alloca i32, align 4
  %sizeInBytes = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %src, ptr %src.addr, align 8
  store i64 %numElems, ptr %numElems.addr, align 8
  store i64 %destFirstElem, ptr %destFirstElem.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %numElems.addr, align 8
  %1 = load i64, ptr %destFirstElem.addr, align 8
  %add = add i64 %0, %1
  %tobool = icmp ne i64 %add, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, ptr %status, align 4
  %2 = load i64, ptr %numElems.addr, align 8
  %mul = mul i64 16, %2
  store i64 %mul, ptr %sizeInBytes, align 8
  %3 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 5
  %4 = load ptr, ptr %m_commandQueue, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 3
  %5 = load ptr, ptr %m_clBuffer, align 8
  %6 = load i64, ptr %destFirstElem.addr, align 8
  %mul2 = mul i64 16, %6
  %7 = load i64, ptr %sizeInBytes, align 8
  %8 = load ptr, ptr %src.addr, align 8
  %call = call i32 %3(ptr noundef %4, ptr noundef %5, i32 noundef 0, i64 noundef %mul2, i64 noundef %7, ptr noundef %8, i32 noundef 0, ptr noundef null, ptr noundef null)
  store i32 %call, ptr %status, align 4
  %9 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool3 = trunc i8 %9 to i1
  br i1 %tobool3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %10 = load ptr, ptr @__clewFinish, align 8
  %m_commandQueue5 = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 5
  %11 = load ptr, ptr %m_commandQueue5, align 8
  %call6 = call i32 %10(ptr noundef %11)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  br label %if.end7

if.else:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.else
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.75, i32 noundef 258)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.77)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %if.end7

if.end7:                                          ; preds = %do.end, %if.end
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %this) unnamed_addr #3 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayIiE, i32 0, inrange i32 0, i32 2), ptr %this1, align 8
  invoke void @_ZN13b3OpenCLArrayIiE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %m_size = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 1
  store i64 0, ptr %m_size, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 2
  store i64 0, ptr %m_capacity, align 8
  ret void

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #14
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %this) unnamed_addr #3 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayI9b3Vector3E, i32 0, inrange i32 0, i32 2), ptr %this1, align 8
  invoke void @_ZN13b3OpenCLArrayI9b3Vector3E10deallocateEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %m_size = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 1
  store i64 0, ptr %m_size, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 2
  store i64 0, ptr %m_capacity, align 8
  ret void

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #14
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %this) unnamed_addr #3 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayI25b3CompoundOverlappingPairE, i32 0, inrange i32 0, i32 2), ptr %this1, align 8
  invoke void @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %m_size = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 1
  store i64 0, ptr %m_size, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 2
  store i64 0, ptr %m_capacity, align 8
  ret void

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #14
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayIfED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %this) unnamed_addr #3 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayIfE, i32 0, inrange i32 0, i32 2), ptr %this1, align 8
  invoke void @_ZN13b3OpenCLArrayIfE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %m_size = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this1, i32 0, i32 1
  store i64 0, ptr %m_size, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this1, i32 0, i32 2
  store i64 0, ptr %m_capacity, align 8
  ret void

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #14
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define dso_local void @_ZN15GpuSatCollisionD2Ev(ptr noundef nonnull align 8 dereferenceable(864) %this) unnamed_addr #3 align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV15GpuSatCollision, i32 0, inrange i32 0, i32 2), ptr %this1, align 8
  %m_findSeparatingAxisVertexFaceKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 7
  %0 = load ptr, ptr %m_findSeparatingAxisVertexFaceKernel, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @__clewReleaseKernel, align 8
  %m_findSeparatingAxisVertexFaceKernel2 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 7
  %2 = load ptr, ptr %m_findSeparatingAxisVertexFaceKernel2, align 8
  %call = invoke i32 %1(ptr noundef %2)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %invoke.cont, %entry
  %m_findSeparatingAxisEdgeEdgeKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 8
  %3 = load ptr, ptr %m_findSeparatingAxisEdgeEdgeKernel, align 8
  %tobool3 = icmp ne ptr %3, null
  br i1 %tobool3, label %if.then4, label %if.end8

if.then4:                                         ; preds = %if.end
  %4 = load ptr, ptr @__clewReleaseKernel, align 8
  %m_findSeparatingAxisEdgeEdgeKernel5 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 8
  %5 = load ptr, ptr %m_findSeparatingAxisEdgeEdgeKernel5, align 8
  %call7 = invoke i32 %4(ptr noundef %5)
          to label %invoke.cont6 unwind label %terminate.lpad

invoke.cont6:                                     ; preds = %if.then4
  br label %if.end8

if.end8:                                          ; preds = %invoke.cont6, %if.end
  %m_findSeparatingAxisUnitSphereKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 6
  %6 = load ptr, ptr %m_findSeparatingAxisUnitSphereKernel, align 8
  %tobool9 = icmp ne ptr %6, null
  br i1 %tobool9, label %if.then10, label %if.end14

if.then10:                                        ; preds = %if.end8
  %7 = load ptr, ptr @__clewReleaseKernel, align 8
  %m_findSeparatingAxisUnitSphereKernel11 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 6
  %8 = load ptr, ptr %m_findSeparatingAxisUnitSphereKernel11, align 8
  %call13 = invoke i32 %7(ptr noundef %8)
          to label %invoke.cont12 unwind label %terminate.lpad

invoke.cont12:                                    ; preds = %if.then10
  br label %if.end14

if.end14:                                         ; preds = %invoke.cont12, %if.end8
  %m_mprPenetrationKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 5
  %9 = load ptr, ptr %m_mprPenetrationKernel, align 8
  %tobool15 = icmp ne ptr %9, null
  br i1 %tobool15, label %if.then16, label %if.end20

if.then16:                                        ; preds = %if.end14
  %10 = load ptr, ptr @__clewReleaseKernel, align 8
  %m_mprPenetrationKernel17 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 5
  %11 = load ptr, ptr %m_mprPenetrationKernel17, align 8
  %call19 = invoke i32 %10(ptr noundef %11)
          to label %invoke.cont18 unwind label %terminate.lpad

invoke.cont18:                                    ; preds = %if.then16
  br label %if.end20

if.end20:                                         ; preds = %invoke.cont18, %if.end14
  %m_findSeparatingAxisKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 4
  %12 = load ptr, ptr %m_findSeparatingAxisKernel, align 8
  %tobool21 = icmp ne ptr %12, null
  br i1 %tobool21, label %if.then22, label %if.end26

if.then22:                                        ; preds = %if.end20
  %13 = load ptr, ptr @__clewReleaseKernel, align 8
  %m_findSeparatingAxisKernel23 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 4
  %14 = load ptr, ptr %m_findSeparatingAxisKernel23, align 8
  %call25 = invoke i32 %13(ptr noundef %14)
          to label %invoke.cont24 unwind label %terminate.lpad

invoke.cont24:                                    ; preds = %if.then22
  br label %if.end26

if.end26:                                         ; preds = %invoke.cont24, %if.end20
  %m_findConcaveSeparatingAxisVertexFaceKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 10
  %15 = load ptr, ptr %m_findConcaveSeparatingAxisVertexFaceKernel, align 8
  %tobool27 = icmp ne ptr %15, null
  br i1 %tobool27, label %if.then28, label %if.end32

if.then28:                                        ; preds = %if.end26
  %16 = load ptr, ptr @__clewReleaseKernel, align 8
  %m_findConcaveSeparatingAxisVertexFaceKernel29 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 10
  %17 = load ptr, ptr %m_findConcaveSeparatingAxisVertexFaceKernel29, align 8
  %call31 = invoke i32 %16(ptr noundef %17)
          to label %invoke.cont30 unwind label %terminate.lpad

invoke.cont30:                                    ; preds = %if.then28
  br label %if.end32

if.end32:                                         ; preds = %invoke.cont30, %if.end26
  %m_findConcaveSeparatingAxisEdgeEdgeKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 11
  %18 = load ptr, ptr %m_findConcaveSeparatingAxisEdgeEdgeKernel, align 8
  %tobool33 = icmp ne ptr %18, null
  br i1 %tobool33, label %if.then34, label %if.end38

if.then34:                                        ; preds = %if.end32
  %19 = load ptr, ptr @__clewReleaseKernel, align 8
  %m_findConcaveSeparatingAxisEdgeEdgeKernel35 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 11
  %20 = load ptr, ptr %m_findConcaveSeparatingAxisEdgeEdgeKernel35, align 8
  %call37 = invoke i32 %19(ptr noundef %20)
          to label %invoke.cont36 unwind label %terminate.lpad

invoke.cont36:                                    ; preds = %if.then34
  br label %if.end38

if.end38:                                         ; preds = %invoke.cont36, %if.end32
  %m_findConcaveSeparatingAxisKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 9
  %21 = load ptr, ptr %m_findConcaveSeparatingAxisKernel, align 8
  %tobool39 = icmp ne ptr %21, null
  br i1 %tobool39, label %if.then40, label %if.end44

if.then40:                                        ; preds = %if.end38
  %22 = load ptr, ptr @__clewReleaseKernel, align 8
  %m_findConcaveSeparatingAxisKernel41 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 9
  %23 = load ptr, ptr %m_findConcaveSeparatingAxisKernel41, align 8
  %call43 = invoke i32 %22(ptr noundef %23)
          to label %invoke.cont42 unwind label %terminate.lpad

invoke.cont42:                                    ; preds = %if.then40
  br label %if.end44

if.end44:                                         ; preds = %invoke.cont42, %if.end38
  %m_findCompoundPairsKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 12
  %24 = load ptr, ptr %m_findCompoundPairsKernel, align 8
  %tobool45 = icmp ne ptr %24, null
  br i1 %tobool45, label %if.then46, label %if.end50

if.then46:                                        ; preds = %if.end44
  %25 = load ptr, ptr @__clewReleaseKernel, align 8
  %m_findCompoundPairsKernel47 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 12
  %26 = load ptr, ptr %m_findCompoundPairsKernel47, align 8
  %call49 = invoke i32 %25(ptr noundef %26)
          to label %invoke.cont48 unwind label %terminate.lpad

invoke.cont48:                                    ; preds = %if.then46
  br label %if.end50

if.end50:                                         ; preds = %invoke.cont48, %if.end44
  %m_processCompoundPairsKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 13
  %27 = load ptr, ptr %m_processCompoundPairsKernel, align 8
  %tobool51 = icmp ne ptr %27, null
  br i1 %tobool51, label %if.then52, label %if.end56

if.then52:                                        ; preds = %if.end50
  %28 = load ptr, ptr @__clewReleaseKernel, align 8
  %m_processCompoundPairsKernel53 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 13
  %29 = load ptr, ptr %m_processCompoundPairsKernel53, align 8
  %call55 = invoke i32 %28(ptr noundef %29)
          to label %invoke.cont54 unwind label %terminate.lpad

invoke.cont54:                                    ; preds = %if.then52
  br label %if.end56

if.end56:                                         ; preds = %invoke.cont54, %if.end50
  %m_findClippingFacesKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 17
  %30 = load ptr, ptr %m_findClippingFacesKernel, align 8
  %tobool57 = icmp ne ptr %30, null
  br i1 %tobool57, label %if.then58, label %if.end62

if.then58:                                        ; preds = %if.end56
  %31 = load ptr, ptr @__clewReleaseKernel, align 8
  %m_findClippingFacesKernel59 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 17
  %32 = load ptr, ptr %m_findClippingFacesKernel59, align 8
  %call61 = invoke i32 %31(ptr noundef %32)
          to label %invoke.cont60 unwind label %terminate.lpad

invoke.cont60:                                    ; preds = %if.then58
  br label %if.end62

if.end62:                                         ; preds = %invoke.cont60, %if.end56
  %m_clipFacesAndFindContacts = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 16
  %33 = load ptr, ptr %m_clipFacesAndFindContacts, align 8
  %tobool63 = icmp ne ptr %33, null
  br i1 %tobool63, label %if.then64, label %if.end68

if.then64:                                        ; preds = %if.end62
  %34 = load ptr, ptr @__clewReleaseKernel, align 8
  %m_clipFacesAndFindContacts65 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 16
  %35 = load ptr, ptr %m_clipFacesAndFindContacts65, align 8
  %call67 = invoke i32 %34(ptr noundef %35)
          to label %invoke.cont66 unwind label %terminate.lpad

invoke.cont66:                                    ; preds = %if.then64
  br label %if.end68

if.end68:                                         ; preds = %invoke.cont66, %if.end62
  %m_newContactReductionKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 19
  %36 = load ptr, ptr %m_newContactReductionKernel, align 8
  %tobool69 = icmp ne ptr %36, null
  br i1 %tobool69, label %if.then70, label %if.end74

if.then70:                                        ; preds = %if.end68
  %37 = load ptr, ptr @__clewReleaseKernel, align 8
  %m_newContactReductionKernel71 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 19
  %38 = load ptr, ptr %m_newContactReductionKernel71, align 8
  %call73 = invoke i32 %37(ptr noundef %38)
          to label %invoke.cont72 unwind label %terminate.lpad

invoke.cont72:                                    ; preds = %if.then70
  br label %if.end74

if.end74:                                         ; preds = %invoke.cont72, %if.end68
  %m_primitiveContactsKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 21
  %39 = load ptr, ptr %m_primitiveContactsKernel, align 8
  %tobool75 = icmp ne ptr %39, null
  br i1 %tobool75, label %if.then76, label %if.end80

if.then76:                                        ; preds = %if.end74
  %40 = load ptr, ptr @__clewReleaseKernel, align 8
  %m_primitiveContactsKernel77 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 21
  %41 = load ptr, ptr %m_primitiveContactsKernel77, align 8
  %call79 = invoke i32 %40(ptr noundef %41)
          to label %invoke.cont78 unwind label %terminate.lpad

invoke.cont78:                                    ; preds = %if.then76
  br label %if.end80

if.end80:                                         ; preds = %invoke.cont78, %if.end74
  %m_findConcaveSphereContactsKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 22
  %42 = load ptr, ptr %m_findConcaveSphereContactsKernel, align 8
  %tobool81 = icmp ne ptr %42, null
  br i1 %tobool81, label %if.then82, label %if.end86

if.then82:                                        ; preds = %if.end80
  %43 = load ptr, ptr @__clewReleaseKernel, align 8
  %m_findConcaveSphereContactsKernel83 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 22
  %44 = load ptr, ptr %m_findConcaveSphereContactsKernel83, align 8
  %call85 = invoke i32 %43(ptr noundef %44)
          to label %invoke.cont84 unwind label %terminate.lpad

invoke.cont84:                                    ; preds = %if.then82
  br label %if.end86

if.end86:                                         ; preds = %invoke.cont84, %if.end80
  %m_processCompoundPairsPrimitivesKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 23
  %45 = load ptr, ptr %m_processCompoundPairsPrimitivesKernel, align 8
  %tobool87 = icmp ne ptr %45, null
  br i1 %tobool87, label %if.then88, label %if.end92

if.then88:                                        ; preds = %if.end86
  %46 = load ptr, ptr @__clewReleaseKernel, align 8
  %m_processCompoundPairsPrimitivesKernel89 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 23
  %47 = load ptr, ptr %m_processCompoundPairsPrimitivesKernel89, align 8
  %call91 = invoke i32 %46(ptr noundef %47)
          to label %invoke.cont90 unwind label %terminate.lpad

invoke.cont90:                                    ; preds = %if.then88
  br label %if.end92

if.end92:                                         ; preds = %invoke.cont90, %if.end86
  %m_clipHullHullKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 14
  %48 = load ptr, ptr %m_clipHullHullKernel, align 8
  %tobool93 = icmp ne ptr %48, null
  br i1 %tobool93, label %if.then94, label %if.end98

if.then94:                                        ; preds = %if.end92
  %49 = load ptr, ptr @__clewReleaseKernel, align 8
  %m_clipHullHullKernel95 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 14
  %50 = load ptr, ptr %m_clipHullHullKernel95, align 8
  %call97 = invoke i32 %49(ptr noundef %50)
          to label %invoke.cont96 unwind label %terminate.lpad

invoke.cont96:                                    ; preds = %if.then94
  br label %if.end98

if.end98:                                         ; preds = %invoke.cont96, %if.end92
  %m_clipCompoundsHullHullKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 15
  %51 = load ptr, ptr %m_clipCompoundsHullHullKernel, align 8
  %tobool99 = icmp ne ptr %51, null
  br i1 %tobool99, label %if.then100, label %if.end104

if.then100:                                       ; preds = %if.end98
  %52 = load ptr, ptr @__clewReleaseKernel, align 8
  %m_clipCompoundsHullHullKernel101 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 15
  %53 = load ptr, ptr %m_clipCompoundsHullHullKernel101, align 8
  %call103 = invoke i32 %52(ptr noundef %53)
          to label %invoke.cont102 unwind label %terminate.lpad

invoke.cont102:                                   ; preds = %if.then100
  br label %if.end104

if.end104:                                        ; preds = %invoke.cont102, %if.end98
  %m_clipHullHullConcaveConvexKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 18
  %54 = load ptr, ptr %m_clipHullHullConcaveConvexKernel, align 8
  %tobool105 = icmp ne ptr %54, null
  br i1 %tobool105, label %if.then106, label %if.end110

if.then106:                                       ; preds = %if.end104
  %55 = load ptr, ptr @__clewReleaseKernel, align 8
  %m_clipHullHullConcaveConvexKernel107 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 18
  %56 = load ptr, ptr %m_clipHullHullConcaveConvexKernel107, align 8
  %call109 = invoke i32 %55(ptr noundef %56)
          to label %invoke.cont108 unwind label %terminate.lpad

invoke.cont108:                                   ; preds = %if.then106
  br label %if.end110

if.end110:                                        ; preds = %invoke.cont108, %if.end104
  %m_bvhTraversalKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 20
  %57 = load ptr, ptr %m_bvhTraversalKernel, align 8
  %tobool111 = icmp ne ptr %57, null
  br i1 %tobool111, label %if.then112, label %if.end116

if.then112:                                       ; preds = %if.end110
  %58 = load ptr, ptr @__clewReleaseKernel, align 8
  %m_bvhTraversalKernel113 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 20
  %59 = load ptr, ptr %m_bvhTraversalKernel113, align 8
  %call115 = invoke i32 %58(ptr noundef %59)
          to label %invoke.cont114 unwind label %terminate.lpad

invoke.cont114:                                   ; preds = %if.then112
  br label %if.end116

if.end116:                                        ; preds = %invoke.cont114, %if.end110
  %m_numCompoundPairsOut = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 35
  call void @_ZN13b3OpenCLArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_numCompoundPairsOut) #13
  %m_gpuHasCompoundSepNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 34
  call void @_ZN13b3OpenCLArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuHasCompoundSepNormals) #13
  %m_gpuCompoundSepNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 33
  call void @_ZN13b3OpenCLArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuCompoundSepNormals) #13
  %m_gpuCompoundPairs = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 32
  call void @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuCompoundPairs) #13
  %m_numConcavePairsOut = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 31
  call void @_ZN13b3OpenCLArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_numConcavePairsOut) #13
  %m_concaveHasSeparatingNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 30
  call void @_ZN13b3OpenCLArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveHasSeparatingNormals) #13
  %m_concaveSepNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 29
  call void @_ZN13b3OpenCLArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveSepNormals) #13
  %m_hasSeparatingNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 28
  call void @_ZN13b3OpenCLArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_hasSeparatingNormals) #13
  %m_dmins = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 27
  call void @_ZN13b3OpenCLArrayIfED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_dmins) #13
  %m_sepNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 26
  call void @_ZN13b3OpenCLArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_sepNormals) #13
  %m_totalContactsOut = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  call void @_ZN13b3OpenCLArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut) #13
  %m_unitSphereDirections = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 24
  call void @_ZN13b3OpenCLArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_unitSphereDirections) #13
  ret void

terminate.lpad:                                   ; preds = %if.then112, %if.then106, %if.then100, %if.then94, %if.then88, %if.then82, %if.then76, %if.then70, %if.then64, %if.then58, %if.then52, %if.then46, %if.then40, %if.then34, %if.then28, %if.then22, %if.then16, %if.then10, %if.then4, %if.then
  %60 = landingpad { ptr, i32 }
          catch ptr null
  %61 = extractvalue { ptr, i32 } %60, 0
  call void @__clang_call_terminate(ptr %61) #14
  unreachable
}

; Function Attrs: noreturn nounwind uwtable
define linkonce_odr hidden void @__clang_call_terminate(ptr noundef %0) #8 comdat {
  %2 = call ptr @__cxa_begin_catch(ptr %0) #13
  call void @_ZSt9terminatev() #14
  unreachable
}

declare ptr @__cxa_begin_catch(ptr)

declare void @_ZSt9terminatev()

; Function Attrs: mustprogress nounwind uwtable
define dso_local void @_ZN15GpuSatCollisionD0Ev(ptr noundef nonnull align 8 dereferenceable(864) %this) unnamed_addr #3 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN15GpuSatCollisionD1Ev(ptr noundef nonnull align 8 dereferenceable(864) %this1) #13
  call void @_ZdlPv(ptr noundef %this1) #15
  ret void
}

; Function Attrs: nobuiltin nounwind
declare void @_ZdlPv(ptr noundef) #9

; Function Attrs: mustprogress uwtable
define dso_local noundef float @_Z30signedDistanceFromPointToPlaneRK9b3Vector3S1_PS_(ptr noundef nonnull align 16 dereferenceable(16) %point, ptr noundef nonnull align 16 dereferenceable(16) %planeEqn, ptr noundef %closestPointOnFace) #2 {
entry:
  %point.addr = alloca ptr, align 8
  %planeEqn.addr = alloca ptr, align 8
  %closestPointOnFace.addr = alloca ptr, align 8
  %n = alloca %class.b3Vector3, align 16
  %dist = alloca float, align 4
  %ref.tmp = alloca %class.b3Vector3, align 16
  %ref.tmp4 = alloca %class.b3Vector3, align 16
  store ptr %point, ptr %point.addr, align 8
  store ptr %planeEqn, ptr %planeEqn.addr, align 8
  store ptr %closestPointOnFace, ptr %closestPointOnFace.addr, align 8
  %0 = load ptr, ptr %planeEqn.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %n, ptr align 16 %0, i64 16, i1 false)
  %call = call noundef ptr @_ZN9b3Vector3cvPfEv(ptr noundef nonnull align 16 dereferenceable(16) %n)
  %arrayidx = getelementptr inbounds float, ptr %call, i64 3
  store float 0.000000e+00, ptr %arrayidx, align 4
  %1 = load ptr, ptr %point.addr, align 8
  %call1 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %n, ptr noundef nonnull align 16 dereferenceable(16) %1)
  %2 = load ptr, ptr %planeEqn.addr, align 8
  %call2 = call noundef ptr @_ZNK9b3Vector3cvPKfEv(ptr noundef nonnull align 16 dereferenceable(16) %2)
  %arrayidx3 = getelementptr inbounds float, ptr %call2, i64 3
  %3 = load float, ptr %arrayidx3, align 4
  %add = fadd float %call1, %3
  store float %add, ptr %dist, align 4
  %4 = load ptr, ptr %point.addr, align 8
  %call5 = call { <2 x float>, <2 x float> } @_ZmlRKfRK9b3Vector3(ptr noundef nonnull align 4 dereferenceable(4) %dist, ptr noundef nonnull align 16 dereferenceable(16) %n)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp4, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %5 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive6, i32 0, i32 0
  %6 = extractvalue { <2 x float>, <2 x float> } %call5, 0
  store <2 x float> %6, ptr %5, align 16
  %7 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive6, i32 0, i32 1
  %8 = extractvalue { <2 x float>, <2 x float> } %call5, 1
  store <2 x float> %8, ptr %7, align 8
  %call7 = call { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %4, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp4)
  %coerce.dive8 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive9 = getelementptr inbounds %union.anon.1, ptr %coerce.dive8, i32 0, i32 0
  %9 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive9, i32 0, i32 0
  %10 = extractvalue { <2 x float>, <2 x float> } %call7, 0
  store <2 x float> %10, ptr %9, align 16
  %11 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive9, i32 0, i32 1
  %12 = extractvalue { <2 x float>, <2 x float> } %call7, 1
  store <2 x float> %12, ptr %11, align 8
  %13 = load ptr, ptr %closestPointOnFace.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %13, ptr align 16 %ref.tmp, i64 16, i1 false)
  %14 = load float, ptr %dist, align 4
  ret float %14
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN9b3Vector3cvPfEv(ptr noundef nonnull align 16 dereferenceable(16) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x float], ptr %0, i64 0, i64 0
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK9b3Vector3cvPKfEv(ptr noundef nonnull align 16 dereferenceable(16) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x float], ptr %0, i64 0, i64 0
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_ZmlRKfRK9b3Vector3(ptr noundef nonnull align 4 dereferenceable(4) %s, ptr noundef nonnull align 16 dereferenceable(16) %v) #2 comdat {
entry:
  %retval = alloca %class.b3Vector3, align 16
  %s.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  %0 = load ptr, ptr %v.addr, align 8
  %1 = load ptr, ptr %s.addr, align 8
  %call = call { <2 x float>, <2 x float> } @_ZmlRK9b3Vector3RKf(ptr noundef nonnull align 16 dereferenceable(16) %0, ptr noundef nonnull align 4 dereferenceable(4) %1)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive1 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %2 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive1, i32 0, i32 0
  %3 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %3, ptr %2, align 16
  %4 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive1, i32 0, i32 1
  %5 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %5, ptr %4, align 8
  %coerce.dive2 = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %union.anon.1, ptr %coerce.dive2, i32 0, i32 0
  %6 = load { <2 x float>, <2 x float> }, ptr %coerce.dive3, align 16
  ret { <2 x float>, <2 x float> } %6
}

; Function Attrs: mustprogress uwtable
define dso_local { <2 x float>, <2 x float> } @_Z9transformPK9b3Vector3S1_PK12b3Quaternion(ptr noundef %v, ptr noundef %pos, ptr noundef %orn) #2 {
entry:
  %retval = alloca %class.b3Vector3, align 16
  %v.addr = alloca ptr, align 8
  %pos.addr = alloca ptr, align 8
  %orn.addr = alloca ptr, align 8
  %tr = alloca %class.b3Transform, align 16
  store ptr %v, ptr %v.addr, align 8
  store ptr %pos, ptr %pos.addr, align 8
  store ptr %orn, ptr %orn.addr, align 8
  call void @_ZN11b3TransformC2Ev(ptr noundef nonnull align 16 dereferenceable(64) %tr)
  call void @_ZN11b3Transform11setIdentityEv(ptr noundef nonnull align 16 dereferenceable(64) %tr)
  %0 = load ptr, ptr %pos.addr, align 8
  call void @_ZN11b3Transform9setOriginERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %tr, ptr noundef nonnull align 16 dereferenceable(16) %0)
  %1 = load ptr, ptr %orn.addr, align 8
  call void @_ZN11b3Transform11setRotationERK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(64) %tr, ptr noundef nonnull align 16 dereferenceable(16) %1)
  %2 = load ptr, ptr %v.addr, align 8
  %call = call { <2 x float>, <2 x float> } @_ZNK11b3TransformclERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %tr, ptr noundef nonnull align 16 dereferenceable(16) %2)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive1 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %3 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive1, i32 0, i32 0
  %4 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %4, ptr %3, align 16
  %5 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive1, i32 0, i32 1
  %6 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %6, ptr %5, align 8
  %coerce.dive2 = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %union.anon.1, ptr %coerce.dive2, i32 0, i32 0
  %7 = load { <2 x float>, <2 x float> }, ptr %coerce.dive3, align 16
  ret { <2 x float>, <2 x float> } %7
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN11b3TransformC2Ev(ptr noundef nonnull align 16 dereferenceable(64) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_basis = getelementptr inbounds %class.b3Transform, ptr %this1, i32 0, i32 0
  call void @_ZN11b3Matrix3x3C2Ev(ptr noundef nonnull align 16 dereferenceable(48) %m_basis)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN11b3Transform11setIdentityEv(ptr noundef nonnull align 16 dereferenceable(64) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca float, align 4
  %ref.tmp2 = alloca float, align 4
  %ref.tmp3 = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_basis = getelementptr inbounds %class.b3Transform, ptr %this1, i32 0, i32 0
  call void @_ZN11b3Matrix3x311setIdentityEv(ptr noundef nonnull align 16 dereferenceable(48) %m_basis)
  %m_origin = getelementptr inbounds %class.b3Transform, ptr %this1, i32 0, i32 1
  store float 0.000000e+00, ptr %ref.tmp, align 4
  store float 0.000000e+00, ptr %ref.tmp2, align 4
  store float 0.000000e+00, ptr %ref.tmp3, align 4
  call void @_ZN9b3Vector38setValueERKfS1_S1_(ptr noundef nonnull align 16 dereferenceable(16) %m_origin, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp2, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp3)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN11b3Transform9setOriginERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %this, ptr noundef nonnull align 16 dereferenceable(16) %origin) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %origin.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %origin, ptr %origin.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %origin.addr, align 8
  %m_origin = getelementptr inbounds %class.b3Transform, ptr %this1, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %m_origin, ptr align 16 %0, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN11b3Transform11setRotationERK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(64) %this, ptr noundef nonnull align 16 dereferenceable(16) %q) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %q.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %q, ptr %q.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_basis = getelementptr inbounds %class.b3Transform, ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %q.addr, align 8
  call void @_ZN11b3Matrix3x311setRotationERK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(48) %m_basis, ptr noundef nonnull align 16 dereferenceable(16) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_ZNK11b3TransformclERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %this, ptr noundef nonnull align 16 dereferenceable(16) %x) #2 comdat align 2 {
entry:
  %retval = alloca %class.b3Vector3, align 16
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  %ref.tmp = alloca %class.b3Vector3, align 16
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %m_basis = getelementptr inbounds %class.b3Transform, ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK11b3Matrix3x3ixEi(ptr noundef nonnull align 16 dereferenceable(48) %m_basis, i32 noundef 0)
  %m_basis2 = getelementptr inbounds %class.b3Transform, ptr %this1, i32 0, i32 0
  %call3 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK11b3Matrix3x3ixEi(ptr noundef nonnull align 16 dereferenceable(48) %m_basis2, i32 noundef 1)
  %m_basis4 = getelementptr inbounds %class.b3Transform, ptr %this1, i32 0, i32 0
  %call5 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK11b3Matrix3x3ixEi(ptr noundef nonnull align 16 dereferenceable(48) %m_basis4, i32 noundef 2)
  %call6 = call { <2 x float>, <2 x float> } @_ZNK9b3Vector34dot3ERKS_S1_S1_(ptr noundef nonnull align 16 dereferenceable(16) %0, ptr noundef nonnull align 16 dereferenceable(16) %call, ptr noundef nonnull align 16 dereferenceable(16) %call3, ptr noundef nonnull align 16 dereferenceable(16) %call5)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive7 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %1 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive7, i32 0, i32 0
  %2 = extractvalue { <2 x float>, <2 x float> } %call6, 0
  store <2 x float> %2, ptr %1, align 16
  %3 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive7, i32 0, i32 1
  %4 = extractvalue { <2 x float>, <2 x float> } %call6, 1
  store <2 x float> %4, ptr %3, align 8
  %m_origin = getelementptr inbounds %class.b3Transform, ptr %this1, i32 0, i32 1
  %call8 = call { <2 x float>, <2 x float> } @_ZplRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp, ptr noundef nonnull align 16 dereferenceable(16) %m_origin)
  %coerce.dive9 = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive10 = getelementptr inbounds %union.anon.1, ptr %coerce.dive9, i32 0, i32 0
  %5 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive10, i32 0, i32 0
  %6 = extractvalue { <2 x float>, <2 x float> } %call8, 0
  store <2 x float> %6, ptr %5, align 16
  %7 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive10, i32 0, i32 1
  %8 = extractvalue { <2 x float>, <2 x float> } %call8, 1
  store <2 x float> %8, ptr %7, align 8
  %coerce.dive11 = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive12 = getelementptr inbounds %union.anon.1, ptr %coerce.dive11, i32 0, i32 0
  %9 = load { <2 x float>, <2 x float> }, ptr %coerce.dive12, align 16
  ret { <2 x float>, <2 x float> } %9
}

; Function Attrs: mustprogress uwtable
define dso_local noundef i32 @_Z31extractManifoldSequentialGlobalPK9b3Vector3iRS0_P6b3Int4(ptr noundef %p, i32 noundef %nPoints, ptr noundef nonnull align 16 dereferenceable(16) %nearNormal, ptr noundef %contactIdx) #2 {
entry:
  %retval = alloca i32, align 4
  %p.addr = alloca ptr, align 8
  %nPoints.addr = alloca i32, align 4
  %nearNormal.addr = alloca ptr, align 8
  %contactIdx.addr = alloca ptr, align 8
  %center = alloca %class.b3Vector3, align 16
  %i = alloca i32, align 4
  %ref.tmp = alloca float, align 4
  %aVector = alloca %class.b3Vector3, align 16
  %u = alloca %class.b3Vector3, align 16
  %v = alloca %class.b3Vector3, align 16
  %minW = alloca float, align 4
  %minIndex = alloca i32, align 4
  %maxDots = alloca %class.b3Vector3, align 16
  %ie = alloca i32, align 4
  %f = alloca float, align 4
  %r = alloca %class.b3Vector3, align 16
  %ref.tmp48 = alloca %class.b3Vector3, align 16
  %ref.tmp68 = alloca %class.b3Vector3, align 16
  store ptr %p, ptr %p.addr, align 8
  store i32 %nPoints, ptr %nPoints.addr, align 4
  store ptr %nearNormal, ptr %nearNormal.addr, align 8
  store ptr %contactIdx, ptr %contactIdx.addr, align 8
  %0 = load i32, ptr %nPoints.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, ptr %nPoints.addr, align 4
  %cmp1 = icmp sle i32 %1, 4
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %2 = load i32, ptr %nPoints.addr, align 4
  store i32 %2, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %3 = load i32, ptr %nPoints.addr, align 4
  %cmp4 = icmp sgt i32 %3, 64
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  store i32 64, ptr %nPoints.addr, align 4
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.end3
  %call = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %center, i32 0, i32 0
  %coerce.dive7 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %4 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive7, i32 0, i32 0
  %5 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %5, ptr %4, align 16
  %6 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive7, i32 0, i32 1
  %7 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %7, ptr %6, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %nPoints.addr, align 4
  %cmp8 = icmp slt i32 %8, %9
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %p.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idxprom = sext i32 %11 to i64
  %arrayidx = getelementptr inbounds %class.b3Vector3, ptr %10, i64 %idxprom
  %call9 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector3pLERKS_(ptr noundef nonnull align 16 dereferenceable(16) %center, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, ptr %i, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !26

for.end:                                          ; preds = %for.cond
  %13 = load i32, ptr %nPoints.addr, align 4
  %conv = sitofp i32 %13 to float
  store float %conv, ptr %ref.tmp, align 4
  %call10 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector3dVERKf(ptr noundef nonnull align 16 dereferenceable(16) %center, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp)
  %14 = load ptr, ptr %p.addr, align 8
  %arrayidx11 = getelementptr inbounds %class.b3Vector3, ptr %14, i64 0
  %call12 = call { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx11, ptr noundef nonnull align 16 dereferenceable(16) %center)
  %coerce.dive13 = getelementptr inbounds %class.b3Vector3, ptr %aVector, i32 0, i32 0
  %coerce.dive14 = getelementptr inbounds %union.anon.1, ptr %coerce.dive13, i32 0, i32 0
  %15 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive14, i32 0, i32 0
  %16 = extractvalue { <2 x float>, <2 x float> } %call12, 0
  store <2 x float> %16, ptr %15, align 16
  %17 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive14, i32 0, i32 1
  %18 = extractvalue { <2 x float>, <2 x float> } %call12, 1
  store <2 x float> %18, ptr %17, align 8
  %19 = load ptr, ptr %nearNormal.addr, align 8
  %call15 = call { <2 x float>, <2 x float> } @_ZNK9b3Vector35crossERKS_(ptr noundef nonnull align 16 dereferenceable(16) %19, ptr noundef nonnull align 16 dereferenceable(16) %aVector)
  %coerce.dive16 = getelementptr inbounds %class.b3Vector3, ptr %u, i32 0, i32 0
  %coerce.dive17 = getelementptr inbounds %union.anon.1, ptr %coerce.dive16, i32 0, i32 0
  %20 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive17, i32 0, i32 0
  %21 = extractvalue { <2 x float>, <2 x float> } %call15, 0
  store <2 x float> %21, ptr %20, align 16
  %22 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive17, i32 0, i32 1
  %23 = extractvalue { <2 x float>, <2 x float> } %call15, 1
  store <2 x float> %23, ptr %22, align 8
  %24 = load ptr, ptr %nearNormal.addr, align 8
  %call18 = call { <2 x float>, <2 x float> } @_ZNK9b3Vector35crossERKS_(ptr noundef nonnull align 16 dereferenceable(16) %24, ptr noundef nonnull align 16 dereferenceable(16) %u)
  %coerce.dive19 = getelementptr inbounds %class.b3Vector3, ptr %v, i32 0, i32 0
  %coerce.dive20 = getelementptr inbounds %union.anon.1, ptr %coerce.dive19, i32 0, i32 0
  %25 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive20, i32 0, i32 0
  %26 = extractvalue { <2 x float>, <2 x float> } %call18, 0
  store <2 x float> %26, ptr %25, align 16
  %27 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive20, i32 0, i32 1
  %28 = extractvalue { <2 x float>, <2 x float> } %call18, 1
  store <2 x float> %28, ptr %27, align 8
  %call21 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector39normalizeEv(ptr noundef nonnull align 16 dereferenceable(16) %u)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %u, ptr align 16 %call21, i64 16, i1 false)
  %call22 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector39normalizeEv(ptr noundef nonnull align 16 dereferenceable(16) %v)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %v, ptr align 16 %call22, i64 16, i1 false)
  store float 0x47EFFFFFE0000000, ptr %minW, align 4
  store i32 -1, ptr %minIndex, align 4
  %29 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon.2, ptr %29, i32 0, i32 0
  store float 0x3810000000000000, ptr %x, align 16
  %30 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon.2, ptr %30, i32 0, i32 1
  store float 0x3810000000000000, ptr %y, align 4
  %31 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon.2, ptr %31, i32 0, i32 2
  store float 0x3810000000000000, ptr %z, align 8
  %32 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %w = getelementptr inbounds %struct.anon.2, ptr %32, i32 0, i32 3
  store float 0x3810000000000000, ptr %w, align 4
  store i32 0, ptr %ie, align 4
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc80, %for.end
  %33 = load i32, ptr %ie, align 4
  %34 = load i32, ptr %nPoints.addr, align 4
  %cmp24 = icmp slt i32 %33, %34
  br i1 %cmp24, label %for.body25, label %for.end82

for.body25:                                       ; preds = %for.cond23
  %35 = load ptr, ptr %p.addr, align 8
  %36 = load i32, ptr %ie, align 4
  %idxprom26 = sext i32 %36 to i64
  %arrayidx27 = getelementptr inbounds %class.b3Vector3, ptr %35, i64 %idxprom26
  %37 = getelementptr inbounds %class.b3Vector3, ptr %arrayidx27, i32 0, i32 0
  %w28 = getelementptr inbounds %struct.anon.2, ptr %37, i32 0, i32 3
  %38 = load float, ptr %w28, align 4
  %39 = load float, ptr %minW, align 4
  %cmp29 = fcmp olt float %38, %39
  br i1 %cmp29, label %if.then30, label %if.end34

if.then30:                                        ; preds = %for.body25
  %40 = load ptr, ptr %p.addr, align 8
  %41 = load i32, ptr %ie, align 4
  %idxprom31 = sext i32 %41 to i64
  %arrayidx32 = getelementptr inbounds %class.b3Vector3, ptr %40, i64 %idxprom31
  %42 = getelementptr inbounds %class.b3Vector3, ptr %arrayidx32, i32 0, i32 0
  %w33 = getelementptr inbounds %struct.anon.2, ptr %42, i32 0, i32 3
  %43 = load float, ptr %w33, align 4
  store float %43, ptr %minW, align 4
  %44 = load i32, ptr %ie, align 4
  store i32 %44, ptr %minIndex, align 4
  br label %if.end34

if.end34:                                         ; preds = %if.then30, %for.body25
  %45 = load ptr, ptr %p.addr, align 8
  %46 = load i32, ptr %ie, align 4
  %idxprom35 = sext i32 %46 to i64
  %arrayidx36 = getelementptr inbounds %class.b3Vector3, ptr %45, i64 %idxprom35
  %call37 = call { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx36, ptr noundef nonnull align 16 dereferenceable(16) %center)
  %coerce.dive38 = getelementptr inbounds %class.b3Vector3, ptr %r, i32 0, i32 0
  %coerce.dive39 = getelementptr inbounds %union.anon.1, ptr %coerce.dive38, i32 0, i32 0
  %47 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive39, i32 0, i32 0
  %48 = extractvalue { <2 x float>, <2 x float> } %call37, 0
  store <2 x float> %48, ptr %47, align 16
  %49 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive39, i32 0, i32 1
  %50 = extractvalue { <2 x float>, <2 x float> } %call37, 1
  store <2 x float> %50, ptr %49, align 8
  %call40 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %u, ptr noundef nonnull align 16 dereferenceable(16) %r)
  store float %call40, ptr %f, align 4
  %51 = load float, ptr %f, align 4
  %52 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %x41 = getelementptr inbounds %struct.anon.2, ptr %52, i32 0, i32 0
  %53 = load float, ptr %x41, align 16
  %cmp42 = fcmp olt float %51, %53
  br i1 %cmp42, label %if.then43, label %if.end47

if.then43:                                        ; preds = %if.end34
  %54 = load float, ptr %f, align 4
  %55 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %x44 = getelementptr inbounds %struct.anon.2, ptr %55, i32 0, i32 0
  store float %54, ptr %x44, align 16
  %56 = load i32, ptr %ie, align 4
  %57 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx45 = getelementptr inbounds %struct.b3Int4, ptr %57, i64 0
  %58 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx45, i32 0, i32 0
  %x46 = getelementptr inbounds %struct.anon, ptr %58, i32 0, i32 0
  store i32 %56, ptr %x46, align 16
  br label %if.end47

if.end47:                                         ; preds = %if.then43, %if.end34
  %call49 = call { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %u)
  %coerce.dive50 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp48, i32 0, i32 0
  %coerce.dive51 = getelementptr inbounds %union.anon.1, ptr %coerce.dive50, i32 0, i32 0
  %59 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive51, i32 0, i32 0
  %60 = extractvalue { <2 x float>, <2 x float> } %call49, 0
  store <2 x float> %60, ptr %59, align 16
  %61 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive51, i32 0, i32 1
  %62 = extractvalue { <2 x float>, <2 x float> } %call49, 1
  store <2 x float> %62, ptr %61, align 8
  %call52 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp48, ptr noundef nonnull align 16 dereferenceable(16) %r)
  store float %call52, ptr %f, align 4
  %63 = load float, ptr %f, align 4
  %64 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %y53 = getelementptr inbounds %struct.anon.2, ptr %64, i32 0, i32 1
  %65 = load float, ptr %y53, align 4
  %cmp54 = fcmp olt float %63, %65
  br i1 %cmp54, label %if.then55, label %if.end59

if.then55:                                        ; preds = %if.end47
  %66 = load float, ptr %f, align 4
  %67 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %y56 = getelementptr inbounds %struct.anon.2, ptr %67, i32 0, i32 1
  store float %66, ptr %y56, align 4
  %68 = load i32, ptr %ie, align 4
  %69 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx57 = getelementptr inbounds %struct.b3Int4, ptr %69, i64 0
  %70 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx57, i32 0, i32 0
  %y58 = getelementptr inbounds %struct.anon, ptr %70, i32 0, i32 1
  store i32 %68, ptr %y58, align 4
  br label %if.end59

if.end59:                                         ; preds = %if.then55, %if.end47
  %call60 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %v, ptr noundef nonnull align 16 dereferenceable(16) %r)
  store float %call60, ptr %f, align 4
  %71 = load float, ptr %f, align 4
  %72 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %z61 = getelementptr inbounds %struct.anon.2, ptr %72, i32 0, i32 2
  %73 = load float, ptr %z61, align 8
  %cmp62 = fcmp olt float %71, %73
  br i1 %cmp62, label %if.then63, label %if.end67

if.then63:                                        ; preds = %if.end59
  %74 = load float, ptr %f, align 4
  %75 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %z64 = getelementptr inbounds %struct.anon.2, ptr %75, i32 0, i32 2
  store float %74, ptr %z64, align 8
  %76 = load i32, ptr %ie, align 4
  %77 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx65 = getelementptr inbounds %struct.b3Int4, ptr %77, i64 0
  %78 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx65, i32 0, i32 0
  %z66 = getelementptr inbounds %struct.anon, ptr %78, i32 0, i32 2
  store i32 %76, ptr %z66, align 8
  br label %if.end67

if.end67:                                         ; preds = %if.then63, %if.end59
  %call69 = call { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %v)
  %coerce.dive70 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp68, i32 0, i32 0
  %coerce.dive71 = getelementptr inbounds %union.anon.1, ptr %coerce.dive70, i32 0, i32 0
  %79 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive71, i32 0, i32 0
  %80 = extractvalue { <2 x float>, <2 x float> } %call69, 0
  store <2 x float> %80, ptr %79, align 16
  %81 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive71, i32 0, i32 1
  %82 = extractvalue { <2 x float>, <2 x float> } %call69, 1
  store <2 x float> %82, ptr %81, align 8
  %call72 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp68, ptr noundef nonnull align 16 dereferenceable(16) %r)
  store float %call72, ptr %f, align 4
  %83 = load float, ptr %f, align 4
  %84 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %w73 = getelementptr inbounds %struct.anon.2, ptr %84, i32 0, i32 3
  %85 = load float, ptr %w73, align 4
  %cmp74 = fcmp olt float %83, %85
  br i1 %cmp74, label %if.then75, label %if.end79

if.then75:                                        ; preds = %if.end67
  %86 = load float, ptr %f, align 4
  %87 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %w76 = getelementptr inbounds %struct.anon.2, ptr %87, i32 0, i32 3
  store float %86, ptr %w76, align 4
  %88 = load i32, ptr %ie, align 4
  %89 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx77 = getelementptr inbounds %struct.b3Int4, ptr %89, i64 0
  %90 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx77, i32 0, i32 0
  %w78 = getelementptr inbounds %struct.anon, ptr %90, i32 0, i32 3
  store i32 %88, ptr %w78, align 4
  br label %if.end79

if.end79:                                         ; preds = %if.then75, %if.end67
  br label %for.inc80

for.inc80:                                        ; preds = %if.end79
  %91 = load i32, ptr %ie, align 4
  %inc81 = add nsw i32 %91, 1
  store i32 %inc81, ptr %ie, align 4
  br label %for.cond23, !llvm.loop !27

for.end82:                                        ; preds = %for.cond23
  %92 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx83 = getelementptr inbounds %struct.b3Int4, ptr %92, i64 0
  %93 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx83, i32 0, i32 0
  %x84 = getelementptr inbounds %struct.anon, ptr %93, i32 0, i32 0
  %94 = load i32, ptr %x84, align 16
  %95 = load i32, ptr %minIndex, align 4
  %cmp85 = icmp ne i32 %94, %95
  br i1 %cmp85, label %land.lhs.true, label %if.end100

land.lhs.true:                                    ; preds = %for.end82
  %96 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx86 = getelementptr inbounds %struct.b3Int4, ptr %96, i64 0
  %97 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx86, i32 0, i32 0
  %y87 = getelementptr inbounds %struct.anon, ptr %97, i32 0, i32 1
  %98 = load i32, ptr %y87, align 4
  %99 = load i32, ptr %minIndex, align 4
  %cmp88 = icmp ne i32 %98, %99
  br i1 %cmp88, label %land.lhs.true89, label %if.end100

land.lhs.true89:                                  ; preds = %land.lhs.true
  %100 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx90 = getelementptr inbounds %struct.b3Int4, ptr %100, i64 0
  %101 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx90, i32 0, i32 0
  %z91 = getelementptr inbounds %struct.anon, ptr %101, i32 0, i32 2
  %102 = load i32, ptr %z91, align 8
  %103 = load i32, ptr %minIndex, align 4
  %cmp92 = icmp ne i32 %102, %103
  br i1 %cmp92, label %land.lhs.true93, label %if.end100

land.lhs.true93:                                  ; preds = %land.lhs.true89
  %104 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx94 = getelementptr inbounds %struct.b3Int4, ptr %104, i64 0
  %105 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx94, i32 0, i32 0
  %w95 = getelementptr inbounds %struct.anon, ptr %105, i32 0, i32 3
  %106 = load i32, ptr %w95, align 4
  %107 = load i32, ptr %minIndex, align 4
  %cmp96 = icmp ne i32 %106, %107
  br i1 %cmp96, label %if.then97, label %if.end100

if.then97:                                        ; preds = %land.lhs.true93
  %108 = load i32, ptr %minIndex, align 4
  %109 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx98 = getelementptr inbounds %struct.b3Int4, ptr %109, i64 0
  %110 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx98, i32 0, i32 0
  %x99 = getelementptr inbounds %struct.anon, ptr %110, i32 0, i32 0
  store i32 %108, ptr %x99, align 16
  br label %if.end100

if.end100:                                        ; preds = %if.then97, %land.lhs.true93, %land.lhs.true89, %land.lhs.true, %for.end82
  store i32 4, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end100, %if.then2, %if.then
  %111 = load i32, ptr %retval, align 4
  ret i32 %111
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_ZNK9b3Vector35crossERKS_(ptr noundef nonnull align 16 dereferenceable(16) %this, ptr noundef nonnull align 16 dereferenceable(16) %v) #2 comdat align 2 {
entry:
  %retval = alloca %class.b3Vector3, align 16
  %this.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x float], ptr %0, i64 0, i64 1
  %1 = load float, ptr %arrayidx, align 4
  %2 = load ptr, ptr %v.addr, align 8
  %3 = getelementptr inbounds %class.b3Vector3, ptr %2, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [4 x float], ptr %3, i64 0, i64 2
  %4 = load float, ptr %arrayidx2, align 8
  %5 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx3 = getelementptr inbounds [4 x float], ptr %5, i64 0, i64 2
  %6 = load float, ptr %arrayidx3, align 8
  %7 = load ptr, ptr %v.addr, align 8
  %8 = getelementptr inbounds %class.b3Vector3, ptr %7, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [4 x float], ptr %8, i64 0, i64 1
  %9 = load float, ptr %arrayidx4, align 4
  %mul5 = fmul float %6, %9
  %neg = fneg float %mul5
  %10 = call float @llvm.fmuladd.f32(float %1, float %4, float %neg)
  %11 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [4 x float], ptr %11, i64 0, i64 2
  %12 = load float, ptr %arrayidx6, align 8
  %13 = load ptr, ptr %v.addr, align 8
  %14 = getelementptr inbounds %class.b3Vector3, ptr %13, i32 0, i32 0
  %arrayidx7 = getelementptr inbounds [4 x float], ptr %14, i64 0, i64 0
  %15 = load float, ptr %arrayidx7, align 16
  %16 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx8 = getelementptr inbounds [4 x float], ptr %16, i64 0, i64 0
  %17 = load float, ptr %arrayidx8, align 16
  %18 = load ptr, ptr %v.addr, align 8
  %19 = getelementptr inbounds %class.b3Vector3, ptr %18, i32 0, i32 0
  %arrayidx9 = getelementptr inbounds [4 x float], ptr %19, i64 0, i64 2
  %20 = load float, ptr %arrayidx9, align 8
  %mul10 = fmul float %17, %20
  %neg11 = fneg float %mul10
  %21 = call float @llvm.fmuladd.f32(float %12, float %15, float %neg11)
  %22 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx12 = getelementptr inbounds [4 x float], ptr %22, i64 0, i64 0
  %23 = load float, ptr %arrayidx12, align 16
  %24 = load ptr, ptr %v.addr, align 8
  %25 = getelementptr inbounds %class.b3Vector3, ptr %24, i32 0, i32 0
  %arrayidx13 = getelementptr inbounds [4 x float], ptr %25, i64 0, i64 1
  %26 = load float, ptr %arrayidx13, align 4
  %27 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx14 = getelementptr inbounds [4 x float], ptr %27, i64 0, i64 1
  %28 = load float, ptr %arrayidx14, align 4
  %29 = load ptr, ptr %v.addr, align 8
  %30 = getelementptr inbounds %class.b3Vector3, ptr %29, i32 0, i32 0
  %arrayidx15 = getelementptr inbounds [4 x float], ptr %30, i64 0, i64 0
  %31 = load float, ptr %arrayidx15, align 16
  %mul16 = fmul float %28, %31
  %neg17 = fneg float %mul16
  %32 = call float @llvm.fmuladd.f32(float %23, float %26, float %neg17)
  %call = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef %10, float noundef %21, float noundef %32)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive18 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %33 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive18, i32 0, i32 0
  %34 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %34, ptr %33, align 16
  %35 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive18, i32 0, i32 1
  %36 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %36, ptr %35, align 8
  %coerce.dive19 = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive20 = getelementptr inbounds %union.anon.1, ptr %coerce.dive19, i32 0, i32 0
  %37 = load { <2 x float>, <2 x float> }, ptr %coerce.dive20, align 16
  ret { <2 x float>, <2 x float> } %37
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector39normalizeEv(ptr noundef nonnull align 16 dereferenceable(16) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef float @_ZNK9b3Vector36lengthEv(ptr noundef nonnull align 16 dereferenceable(16) %this1)
  store float %call, ptr %ref.tmp, align 4
  %call2 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector3dVERKf(ptr noundef nonnull align 16 dereferenceable(16) %this1, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp)
  ret ptr %call2
}

; Function Attrs: mustprogress uwtable
define dso_local noundef zeroext i1 @_Z26findSeparatingAxisEdgeEdgePK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_RK20b3AlignedObjectArrayIS2_ESB_RKS8_I9b3GpuFaceERKS8_IiEPS2_Pf(ptr noundef %hullA, ptr noundef %hullB, ptr noundef nonnull align 16 dereferenceable(16) %posA1, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB1, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %DeltaC2, ptr noundef nonnull align 8 dereferenceable(25) %vertices, ptr noundef nonnull align 8 dereferenceable(25) %uniqueEdges, ptr noundef nonnull align 8 dereferenceable(25) %faces, ptr noundef nonnull align 1 %indices, ptr noundef %sep, ptr noundef %dmin) #2 {
entry:
  %hullA.addr = alloca ptr, align 8
  %hullB.addr = alloca ptr, align 8
  %posA1.addr = alloca ptr, align 8
  %ornA.addr = alloca ptr, align 8
  %posB1.addr = alloca ptr, align 8
  %ornB.addr = alloca ptr, align 8
  %DeltaC2.addr = alloca ptr, align 8
  %vertices.addr = alloca ptr, align 8
  %uniqueEdges.addr = alloca ptr, align 8
  %faces.addr = alloca ptr, align 8
  %indices.addr = alloca ptr, align 8
  %sep.addr = alloca ptr, align 8
  %dmin.addr = alloca ptr, align 8
  %posA = alloca %class.b3Vector3, align 16
  %posB = alloca %class.b3Vector3, align 16
  %curEdgeEdge = alloca i32, align 4
  %e0 = alloca i32, align 4
  %edge0 = alloca %class.b3Vector3, align 16
  %edge0World = alloca %class.b3Vector3, align 16
  %e1 = alloca i32, align 4
  %edge1 = alloca %class.b3Vector3, align 16
  %edge1World = alloca %class.b3Vector3, align 16
  %crossje = alloca %class.b3Vector3, align 16
  %ref.tmp = alloca float, align 4
  %dist = alloca float, align 4
  %result = alloca i8, align 1
  %Min0 = alloca float, align 4
  %Max0 = alloca float, align 4
  %Min1 = alloca float, align 4
  %Max1 = alloca float, align 4
  %d0 = alloca float, align 4
  %d1 = alloca float, align 4
  %ref.tmp37 = alloca %class.b3Vector3, align 16
  %ref.tmp44 = alloca %class.b3Vector3, align 16
  store ptr %hullA, ptr %hullA.addr, align 8
  store ptr %hullB, ptr %hullB.addr, align 8
  store ptr %posA1, ptr %posA1.addr, align 8
  store ptr %ornA, ptr %ornA.addr, align 8
  store ptr %posB1, ptr %posB1.addr, align 8
  store ptr %ornB, ptr %ornB.addr, align 8
  store ptr %DeltaC2, ptr %DeltaC2.addr, align 8
  store ptr %vertices, ptr %vertices.addr, align 8
  store ptr %uniqueEdges, ptr %uniqueEdges.addr, align 8
  store ptr %faces, ptr %faces.addr, align 8
  store ptr %indices, ptr %indices.addr, align 8
  store ptr %sep, ptr %sep.addr, align 8
  store ptr %dmin, ptr %dmin.addr, align 8
  %0 = load ptr, ptr %posA1.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posA, ptr align 16 %0, i64 16, i1 false)
  %1 = getelementptr inbounds %class.b3Vector3, ptr %posA, i32 0, i32 0
  %w = getelementptr inbounds %struct.anon.2, ptr %1, i32 0, i32 3
  store float 0.000000e+00, ptr %w, align 4
  %2 = load ptr, ptr %posB1.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posB, ptr align 16 %2, i64 16, i1 false)
  %3 = getelementptr inbounds %class.b3Vector3, ptr %posB, i32 0, i32 0
  %w1 = getelementptr inbounds %struct.anon.2, ptr %3, i32 0, i32 3
  store float 0.000000e+00, ptr %w1, align 4
  store i32 0, ptr %curEdgeEdge, align 4
  store i32 0, ptr %e0, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc34, %entry
  %4 = load i32, ptr %e0, align 4
  %5 = load ptr, ptr %hullA.addr, align 8
  %m_numUniqueEdges = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %5, i32 0, i32 10
  %6 = load i32, ptr %m_numUniqueEdges, align 8
  %cmp = icmp slt i32 %4, %6
  br i1 %cmp, label %for.body, label %for.end36

for.body:                                         ; preds = %for.cond
  %7 = load ptr, ptr %uniqueEdges.addr, align 8
  %8 = load ptr, ptr %hullA.addr, align 8
  %m_uniqueEdgesOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %8, i32 0, i32 9
  %9 = load i32, ptr %m_uniqueEdgesOffset, align 4
  %10 = load i32, ptr %e0, align 4
  %add = add nsw i32 %9, %10
  %call = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK20b3AlignedObjectArrayI9b3Vector3EixEi(ptr noundef nonnull align 8 dereferenceable(25) %7, i32 noundef %add)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %edge0, ptr align 16 %call, i64 16, i1 false)
  %11 = load ptr, ptr %ornA.addr, align 8
  %call2 = call { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %11, ptr noundef nonnull align 16 dereferenceable(16) %edge0)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %edge0World, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %12 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive3, i32 0, i32 0
  %13 = extractvalue { <2 x float>, <2 x float> } %call2, 0
  store <2 x float> %13, ptr %12, align 16
  %14 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive3, i32 0, i32 1
  %15 = extractvalue { <2 x float>, <2 x float> } %call2, 1
  store <2 x float> %15, ptr %14, align 8
  store i32 0, ptr %e1, align 4
  br label %for.cond4

for.cond4:                                        ; preds = %for.inc, %for.body
  %16 = load i32, ptr %e1, align 4
  %17 = load ptr, ptr %hullB.addr, align 8
  %m_numUniqueEdges5 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %17, i32 0, i32 10
  %18 = load i32, ptr %m_numUniqueEdges5, align 8
  %cmp6 = icmp slt i32 %16, %18
  br i1 %cmp6, label %for.body7, label %for.end

for.body7:                                        ; preds = %for.cond4
  %19 = load ptr, ptr %uniqueEdges.addr, align 8
  %20 = load ptr, ptr %hullB.addr, align 8
  %m_uniqueEdgesOffset8 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %20, i32 0, i32 9
  %21 = load i32, ptr %m_uniqueEdgesOffset8, align 4
  %22 = load i32, ptr %e1, align 4
  %add9 = add nsw i32 %21, %22
  %call10 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK20b3AlignedObjectArrayI9b3Vector3EixEi(ptr noundef nonnull align 8 dereferenceable(25) %19, i32 noundef %add9)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %edge1, ptr align 16 %call10, i64 16, i1 false)
  %23 = load ptr, ptr %ornB.addr, align 8
  %call11 = call { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %23, ptr noundef nonnull align 16 dereferenceable(16) %edge1)
  %coerce.dive12 = getelementptr inbounds %class.b3Vector3, ptr %edge1World, i32 0, i32 0
  %coerce.dive13 = getelementptr inbounds %union.anon.1, ptr %coerce.dive12, i32 0, i32 0
  %24 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive13, i32 0, i32 0
  %25 = extractvalue { <2 x float>, <2 x float> } %call11, 0
  store <2 x float> %25, ptr %24, align 16
  %26 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive13, i32 0, i32 1
  %27 = extractvalue { <2 x float>, <2 x float> } %call11, 1
  store <2 x float> %27, ptr %26, align 8
  %call14 = call { <2 x float>, <2 x float> } @_ZNK9b3Vector35crossERKS_(ptr noundef nonnull align 16 dereferenceable(16) %edge0World, ptr noundef nonnull align 16 dereferenceable(16) %edge1World)
  %coerce.dive15 = getelementptr inbounds %class.b3Vector3, ptr %crossje, i32 0, i32 0
  %coerce.dive16 = getelementptr inbounds %union.anon.1, ptr %coerce.dive15, i32 0, i32 0
  %28 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive16, i32 0, i32 0
  %29 = extractvalue { <2 x float>, <2 x float> } %call14, 0
  store <2 x float> %29, ptr %28, align 16
  %30 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive16, i32 0, i32 1
  %31 = extractvalue { <2 x float>, <2 x float> } %call14, 1
  store <2 x float> %31, ptr %30, align 8
  %32 = load i32, ptr %curEdgeEdge, align 4
  %inc = add nsw i32 %32, 1
  store i32 %inc, ptr %curEdgeEdge, align 4
  %call17 = call noundef zeroext i1 @_Z12IsAlmostZeroRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %crossje)
  br i1 %call17, label %if.end32, label %if.then

if.then:                                          ; preds = %for.body7
  %call18 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector39normalizeEv(ptr noundef nonnull align 16 dereferenceable(16) %crossje)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %crossje, ptr align 16 %call18, i64 16, i1 false)
  %33 = load ptr, ptr %DeltaC2.addr, align 8
  %call19 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %33, ptr noundef nonnull align 16 dereferenceable(16) %crossje)
  %cmp20 = fcmp olt float %call19, 0.000000e+00
  br i1 %cmp20, label %if.then21, label %if.end

if.then21:                                        ; preds = %if.then
  store float -1.000000e+00, ptr %ref.tmp, align 4
  %call22 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector3mLERKf(ptr noundef nonnull align 16 dereferenceable(16) %crossje, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp)
  br label %if.end

if.end:                                           ; preds = %if.then21, %if.then
  store i8 1, ptr %result, align 1
  %34 = load ptr, ptr %hullA.addr, align 8
  %35 = load ptr, ptr %ornA.addr, align 8
  %36 = load ptr, ptr %vertices.addr, align 8
  call void @_Z7projectRK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionS4_RK20b3AlignedObjectArrayIS2_ERfSC_(ptr noundef nonnull align 16 dereferenceable(96) %34, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %35, ptr noundef nonnull align 16 dereferenceable(16) %crossje, ptr noundef nonnull align 8 dereferenceable(25) %36, ptr noundef nonnull align 4 dereferenceable(4) %Min0, ptr noundef nonnull align 4 dereferenceable(4) %Max0)
  %37 = load ptr, ptr %hullB.addr, align 8
  %38 = load ptr, ptr %ornB.addr, align 8
  %39 = load ptr, ptr %vertices.addr, align 8
  call void @_Z7projectRK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionS4_RK20b3AlignedObjectArrayIS2_ERfSC_(ptr noundef nonnull align 16 dereferenceable(96) %37, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %38, ptr noundef nonnull align 16 dereferenceable(16) %crossje, ptr noundef nonnull align 8 dereferenceable(25) %39, ptr noundef nonnull align 4 dereferenceable(4) %Min1, ptr noundef nonnull align 4 dereferenceable(4) %Max1)
  %40 = load float, ptr %Max0, align 4
  %41 = load float, ptr %Min1, align 4
  %cmp23 = fcmp olt float %40, %41
  br i1 %cmp23, label %if.then25, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %42 = load float, ptr %Max1, align 4
  %43 = load float, ptr %Min0, align 4
  %cmp24 = fcmp olt float %42, %43
  br i1 %cmp24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %lor.lhs.false, %if.end
  store i8 0, ptr %result, align 1
  br label %if.end26

if.end26:                                         ; preds = %if.then25, %lor.lhs.false
  %44 = load float, ptr %Max0, align 4
  %45 = load float, ptr %Min1, align 4
  %sub = fsub float %44, %45
  store float %sub, ptr %d0, align 4
  %46 = load float, ptr %Max1, align 4
  %47 = load float, ptr %Min0, align 4
  %sub27 = fsub float %46, %47
  store float %sub27, ptr %d1, align 4
  %48 = load float, ptr %d0, align 4
  %49 = load float, ptr %d1, align 4
  %cmp28 = fcmp olt float %48, %49
  br i1 %cmp28, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end26
  %50 = load float, ptr %d0, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end26
  %51 = load float, ptr %d1, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %50, %cond.true ], [ %51, %cond.false ]
  store float %cond, ptr %dist, align 4
  store i8 1, ptr %result, align 1
  %52 = load float, ptr %dist, align 4
  %53 = load ptr, ptr %dmin.addr, align 8
  %54 = load float, ptr %53, align 4
  %cmp29 = fcmp olt float %52, %54
  br i1 %cmp29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %cond.end
  %55 = load float, ptr %dist, align 4
  %56 = load ptr, ptr %dmin.addr, align 8
  store float %55, ptr %56, align 4
  %57 = load ptr, ptr %sep.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %57, ptr align 16 %crossje, i64 16, i1 false)
  br label %if.end31

if.end31:                                         ; preds = %if.then30, %cond.end
  br label %if.end32

if.end32:                                         ; preds = %if.end31, %for.body7
  br label %for.inc

for.inc:                                          ; preds = %if.end32
  %58 = load i32, ptr %e1, align 4
  %inc33 = add nsw i32 %58, 1
  store i32 %inc33, ptr %e1, align 4
  br label %for.cond4, !llvm.loop !28

for.end:                                          ; preds = %for.cond4
  br label %for.inc34

for.inc34:                                        ; preds = %for.end
  %59 = load i32, ptr %e0, align 4
  %inc35 = add nsw i32 %59, 1
  store i32 %inc35, ptr %e0, align 4
  br label %for.cond, !llvm.loop !29

for.end36:                                        ; preds = %for.cond
  %60 = load ptr, ptr %DeltaC2.addr, align 8
  %call38 = call { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %60)
  %coerce.dive39 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp37, i32 0, i32 0
  %coerce.dive40 = getelementptr inbounds %union.anon.1, ptr %coerce.dive39, i32 0, i32 0
  %61 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive40, i32 0, i32 0
  %62 = extractvalue { <2 x float>, <2 x float> } %call38, 0
  store <2 x float> %62, ptr %61, align 16
  %63 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive40, i32 0, i32 1
  %64 = extractvalue { <2 x float>, <2 x float> } %call38, 1
  store <2 x float> %64, ptr %63, align 8
  %65 = load ptr, ptr %sep.addr, align 8
  %call41 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp37, ptr noundef nonnull align 16 dereferenceable(16) %65)
  %cmp42 = fcmp ogt float %call41, 0.000000e+00
  br i1 %cmp42, label %if.then43, label %if.end48

if.then43:                                        ; preds = %for.end36
  %66 = load ptr, ptr %sep.addr, align 8
  %call45 = call { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %66)
  %coerce.dive46 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp44, i32 0, i32 0
  %coerce.dive47 = getelementptr inbounds %union.anon.1, ptr %coerce.dive46, i32 0, i32 0
  %67 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive47, i32 0, i32 0
  %68 = extractvalue { <2 x float>, <2 x float> } %call45, 0
  store <2 x float> %68, ptr %67, align 16
  %69 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive47, i32 0, i32 1
  %70 = extractvalue { <2 x float>, <2 x float> } %call45, 1
  store <2 x float> %70, ptr %69, align 8
  %71 = load ptr, ptr %sep.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %71, ptr align 16 %ref.tmp44, i64 16, i1 false)
  br label %if.end48

if.end48:                                         ; preds = %if.then43, %for.end36
  ret i1 true
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(16) ptr @_ZNK20b3AlignedObjectArrayI9b3Vector3EixEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %class.b3Vector3, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_Z12IsAlmostZeroRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %v) #3 comdat {
entry:
  %retval = alloca i1, align 1
  %v.addr = alloca ptr, align 8
  store ptr %v, ptr %v.addr, align 8
  %0 = load ptr, ptr %v.addr, align 8
  %1 = getelementptr inbounds %class.b3Vector3, ptr %0, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon.2, ptr %1, i32 0, i32 0
  %2 = load float, ptr %x, align 16
  %3 = call float @llvm.fabs.f32(float %2)
  %conv = fpext float %3 to double
  %cmp = fcmp ogt double %conv, 0x3EB0C6F7A0B5ED8D
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load ptr, ptr %v.addr, align 8
  %5 = getelementptr inbounds %class.b3Vector3, ptr %4, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon.2, ptr %5, i32 0, i32 1
  %6 = load float, ptr %y, align 4
  %7 = call float @llvm.fabs.f32(float %6)
  %conv1 = fpext float %7 to double
  %cmp2 = fcmp ogt double %conv1, 0x3EB0C6F7A0B5ED8D
  br i1 %cmp2, label %if.then, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %lor.lhs.false
  %8 = load ptr, ptr %v.addr, align 8
  %9 = getelementptr inbounds %class.b3Vector3, ptr %8, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon.2, ptr %9, i32 0, i32 2
  %10 = load float, ptr %z, align 8
  %11 = call float @llvm.fabs.f32(float %10)
  %conv4 = fpext float %11 to double
  %cmp5 = fcmp ogt double %conv4, 0x3EB0C6F7A0B5ED8D
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false3, %lor.lhs.false, %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false3
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i1, ptr %retval, align 1
  ret i1 %12
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z7projectRK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionS4_RK20b3AlignedObjectArrayIS2_ERfSC_(ptr noundef nonnull align 16 dereferenceable(96) %hull, ptr noundef nonnull align 16 dereferenceable(16) %pos, ptr noundef nonnull align 16 dereferenceable(16) %orn, ptr noundef nonnull align 16 dereferenceable(16) %dir, ptr noundef nonnull align 8 dereferenceable(25) %vertices, ptr noundef nonnull align 4 dereferenceable(4) %min, ptr noundef nonnull align 4 dereferenceable(4) %max) #2 comdat {
entry:
  %hull.addr = alloca ptr, align 8
  %pos.addr = alloca ptr, align 8
  %orn.addr = alloca ptr, align 8
  %dir.addr = alloca ptr, align 8
  %vertices.addr = alloca ptr, align 8
  %min.addr = alloca ptr, align 8
  %max.addr = alloca ptr, align 8
  %numVerts = alloca i32, align 4
  %localDir = alloca %class.b3Vector3, align 16
  %ref.tmp = alloca %class.b3Quaternion, align 16
  %offset = alloca float, align 4
  %i = alloca i32, align 4
  %dp = alloca float, align 4
  %tmp = alloca float, align 4
  store ptr %hull, ptr %hull.addr, align 8
  store ptr %pos, ptr %pos.addr, align 8
  store ptr %orn, ptr %orn.addr, align 8
  store ptr %dir, ptr %dir.addr, align 8
  store ptr %vertices, ptr %vertices.addr, align 8
  store ptr %min, ptr %min.addr, align 8
  store ptr %max, ptr %max.addr, align 8
  %0 = load ptr, ptr %min.addr, align 8
  store float 0x47EFFFFFE0000000, ptr %0, align 4
  %1 = load ptr, ptr %max.addr, align 8
  store float 0xC7EFFFFFE0000000, ptr %1, align 4
  %2 = load ptr, ptr %hull.addr, align 8
  %m_numVertices = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %2, i32 0, i32 7
  %3 = load i32, ptr %m_numVertices, align 4
  store i32 %3, ptr %numVerts, align 4
  %4 = load ptr, ptr %orn.addr, align 8
  %call = call { <2 x float>, <2 x float> } @_ZNK12b3Quaternion7inverseEv(ptr noundef nonnull align 16 dereferenceable(16) %4)
  %coerce.dive = getelementptr inbounds %class.b3Quaternion, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive1 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %union.anon.3, ptr %coerce.dive1, i32 0, i32 0
  %5 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive2, i32 0, i32 0
  %6 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %6, ptr %5, align 16
  %7 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive2, i32 0, i32 1
  %8 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %8, ptr %7, align 8
  %9 = load ptr, ptr %dir.addr, align 8
  %call3 = call { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp, ptr noundef nonnull align 16 dereferenceable(16) %9)
  %coerce.dive4 = getelementptr inbounds %class.b3Vector3, ptr %localDir, i32 0, i32 0
  %coerce.dive5 = getelementptr inbounds %union.anon.1, ptr %coerce.dive4, i32 0, i32 0
  %10 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive5, i32 0, i32 0
  %11 = extractvalue { <2 x float>, <2 x float> } %call3, 0
  store <2 x float> %11, ptr %10, align 16
  %12 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive5, i32 0, i32 1
  %13 = extractvalue { <2 x float>, <2 x float> } %call3, 1
  store <2 x float> %13, ptr %12, align 8
  %14 = load ptr, ptr %pos.addr, align 8
  %15 = load ptr, ptr %dir.addr, align 8
  %call6 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %14, ptr noundef nonnull align 16 dereferenceable(16) %15)
  store float %call6, ptr %offset, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %16 = load i32, ptr %i, align 4
  %17 = load i32, ptr %numVerts, align 4
  %cmp = icmp slt i32 %16, %17
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %18 = load ptr, ptr %vertices.addr, align 8
  %19 = load ptr, ptr %hull.addr, align 8
  %m_vertexOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %19, i32 0, i32 8
  %20 = load i32, ptr %m_vertexOffset, align 16
  %21 = load i32, ptr %i, align 4
  %add = add nsw i32 %20, %21
  %call7 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK20b3AlignedObjectArrayI9b3Vector3EixEi(ptr noundef nonnull align 8 dereferenceable(25) %18, i32 noundef %add)
  %call8 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %call7, ptr noundef nonnull align 16 dereferenceable(16) %localDir)
  store float %call8, ptr %dp, align 4
  %22 = load float, ptr %dp, align 4
  %23 = load ptr, ptr %min.addr, align 8
  %24 = load float, ptr %23, align 4
  %cmp9 = fcmp olt float %22, %24
  br i1 %cmp9, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %25 = load float, ptr %dp, align 4
  %26 = load ptr, ptr %min.addr, align 8
  store float %25, ptr %26, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %27 = load float, ptr %dp, align 4
  %28 = load ptr, ptr %max.addr, align 8
  %29 = load float, ptr %28, align 4
  %cmp10 = fcmp ogt float %27, %29
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end
  %30 = load float, ptr %dp, align 4
  %31 = load ptr, ptr %max.addr, align 8
  store float %30, ptr %31, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %32 = load i32, ptr %i, align 4
  %inc = add nsw i32 %32, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !30

for.end:                                          ; preds = %for.cond
  %33 = load ptr, ptr %min.addr, align 8
  %34 = load float, ptr %33, align 4
  %35 = load ptr, ptr %max.addr, align 8
  %36 = load float, ptr %35, align 4
  %cmp13 = fcmp ogt float %34, %36
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %for.end
  %37 = load ptr, ptr %min.addr, align 8
  %38 = load float, ptr %37, align 4
  store float %38, ptr %tmp, align 4
  %39 = load ptr, ptr %max.addr, align 8
  %40 = load float, ptr %39, align 4
  %41 = load ptr, ptr %min.addr, align 8
  store float %40, ptr %41, align 4
  %42 = load float, ptr %tmp, align 4
  %43 = load ptr, ptr %max.addr, align 8
  store float %42, ptr %43, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %for.end
  %44 = load float, ptr %offset, align 4
  %45 = load ptr, ptr %min.addr, align 8
  %46 = load float, ptr %45, align 4
  %add16 = fadd float %46, %44
  store float %add16, ptr %45, align 4
  %47 = load float, ptr %offset, align 4
  %48 = load ptr, ptr %max.addr, align 8
  %49 = load float, ptr %48, align 4
  %add17 = fadd float %49, %47
  store float %add17, ptr %48, align 4
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local noundef i32 @_Z8clipFacePK9b3Vector3iRS_fPS_(ptr noundef %pVtxIn, i32 noundef %numVertsIn, ptr noundef nonnull align 16 dereferenceable(16) %planeNormalWS, float noundef %planeEqWS, ptr noundef %ppVtxOut) #2 {
entry:
  %retval = alloca i32, align 4
  %pVtxIn.addr = alloca ptr, align 8
  %numVertsIn.addr = alloca i32, align 4
  %planeNormalWS.addr = alloca ptr, align 8
  %planeEqWS.addr = alloca float, align 4
  %ppVtxOut.addr = alloca ptr, align 8
  %ve = alloca i32, align 4
  %ds = alloca float, align 4
  %de = alloca float, align 4
  %numVertsOut = alloca i32, align 4
  %firstVertex = alloca %class.b3Vector3, align 16
  %endVertex = alloca %class.b3Vector3, align 16
  %ref.tmp = alloca %class.b3Vector3, align 16
  %ref.tmp23 = alloca %class.b3Vector3, align 16
  store ptr %pVtxIn, ptr %pVtxIn.addr, align 8
  store i32 %numVertsIn, ptr %numVertsIn.addr, align 4
  store ptr %planeNormalWS, ptr %planeNormalWS.addr, align 8
  store float %planeEqWS, ptr %planeEqWS.addr, align 4
  store ptr %ppVtxOut, ptr %ppVtxOut.addr, align 8
  store i32 0, ptr %numVertsOut, align 4
  %0 = load i32, ptr %numVertsIn.addr, align 4
  %cmp = icmp slt i32 %0, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %pVtxIn.addr, align 8
  %2 = load i32, ptr %numVertsIn.addr, align 4
  %sub = sub nsw i32 %2, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %class.b3Vector3, ptr %1, i64 %idxprom
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %firstVertex, ptr align 16 %arrayidx, i64 16, i1 false)
  %3 = load ptr, ptr %pVtxIn.addr, align 8
  %arrayidx1 = getelementptr inbounds %class.b3Vector3, ptr %3, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %endVertex, ptr align 16 %arrayidx1, i64 16, i1 false)
  %4 = load ptr, ptr %planeNormalWS.addr, align 8
  %call = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %4, ptr noundef nonnull align 16 dereferenceable(16) %firstVertex)
  %5 = load float, ptr %planeEqWS.addr, align 4
  %add = fadd float %call, %5
  store float %add, ptr %ds, align 4
  store i32 0, ptr %ve, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %6 = load i32, ptr %ve, align 4
  %7 = load i32, ptr %numVertsIn.addr, align 4
  %cmp2 = icmp slt i32 %6, %7
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load ptr, ptr %pVtxIn.addr, align 8
  %9 = load i32, ptr %ve, align 4
  %idxprom3 = sext i32 %9 to i64
  %arrayidx4 = getelementptr inbounds %class.b3Vector3, ptr %8, i64 %idxprom3
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %endVertex, ptr align 16 %arrayidx4, i64 16, i1 false)
  %10 = load ptr, ptr %planeNormalWS.addr, align 8
  %call5 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %10, ptr noundef nonnull align 16 dereferenceable(16) %endVertex)
  %11 = load float, ptr %planeEqWS.addr, align 4
  %add6 = fadd float %call5, %11
  store float %add6, ptr %de, align 4
  %12 = load float, ptr %ds, align 4
  %cmp7 = fcmp olt float %12, 0.000000e+00
  br i1 %cmp7, label %if.then8, label %if.else20

if.then8:                                         ; preds = %for.body
  %13 = load float, ptr %de, align 4
  %cmp9 = fcmp olt float %13, 0.000000e+00
  br i1 %cmp9, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.then8
  %14 = load ptr, ptr %ppVtxOut.addr, align 8
  %15 = load i32, ptr %numVertsOut, align 4
  %inc = add nsw i32 %15, 1
  store i32 %inc, ptr %numVertsOut, align 4
  %idxprom11 = sext i32 %15 to i64
  %arrayidx12 = getelementptr inbounds %class.b3Vector3, ptr %14, i64 %idxprom11
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx12, ptr align 16 %endVertex, i64 16, i1 false)
  br label %if.end19

if.else:                                          ; preds = %if.then8
  %16 = load float, ptr %ds, align 4
  %mul = fmul float %16, 1.000000e+00
  %17 = load float, ptr %ds, align 4
  %18 = load float, ptr %de, align 4
  %sub13 = fsub float %17, %18
  %div = fdiv float %mul, %sub13
  %call14 = call { <2 x float>, <2 x float> } @_Z5lerp3RK9b3Vector3S1_f(ptr noundef nonnull align 16 dereferenceable(16) %firstVertex, ptr noundef nonnull align 16 dereferenceable(16) %endVertex, float noundef %div)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive15 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %19 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive15, i32 0, i32 0
  %20 = extractvalue { <2 x float>, <2 x float> } %call14, 0
  store <2 x float> %20, ptr %19, align 16
  %21 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive15, i32 0, i32 1
  %22 = extractvalue { <2 x float>, <2 x float> } %call14, 1
  store <2 x float> %22, ptr %21, align 8
  %23 = load ptr, ptr %ppVtxOut.addr, align 8
  %24 = load i32, ptr %numVertsOut, align 4
  %inc16 = add nsw i32 %24, 1
  store i32 %inc16, ptr %numVertsOut, align 4
  %idxprom17 = sext i32 %24 to i64
  %arrayidx18 = getelementptr inbounds %class.b3Vector3, ptr %23, i64 %idxprom17
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx18, ptr align 16 %ref.tmp, i64 16, i1 false)
  br label %if.end19

if.end19:                                         ; preds = %if.else, %if.then10
  br label %if.end37

if.else20:                                        ; preds = %for.body
  %25 = load float, ptr %de, align 4
  %cmp21 = fcmp olt float %25, 0.000000e+00
  br i1 %cmp21, label %if.then22, label %if.end36

if.then22:                                        ; preds = %if.else20
  %26 = load float, ptr %ds, align 4
  %mul24 = fmul float %26, 1.000000e+00
  %27 = load float, ptr %ds, align 4
  %28 = load float, ptr %de, align 4
  %sub25 = fsub float %27, %28
  %div26 = fdiv float %mul24, %sub25
  %call27 = call { <2 x float>, <2 x float> } @_Z5lerp3RK9b3Vector3S1_f(ptr noundef nonnull align 16 dereferenceable(16) %firstVertex, ptr noundef nonnull align 16 dereferenceable(16) %endVertex, float noundef %div26)
  %coerce.dive28 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp23, i32 0, i32 0
  %coerce.dive29 = getelementptr inbounds %union.anon.1, ptr %coerce.dive28, i32 0, i32 0
  %29 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive29, i32 0, i32 0
  %30 = extractvalue { <2 x float>, <2 x float> } %call27, 0
  store <2 x float> %30, ptr %29, align 16
  %31 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive29, i32 0, i32 1
  %32 = extractvalue { <2 x float>, <2 x float> } %call27, 1
  store <2 x float> %32, ptr %31, align 8
  %33 = load ptr, ptr %ppVtxOut.addr, align 8
  %34 = load i32, ptr %numVertsOut, align 4
  %inc30 = add nsw i32 %34, 1
  store i32 %inc30, ptr %numVertsOut, align 4
  %idxprom31 = sext i32 %34 to i64
  %arrayidx32 = getelementptr inbounds %class.b3Vector3, ptr %33, i64 %idxprom31
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx32, ptr align 16 %ref.tmp23, i64 16, i1 false)
  %35 = load ptr, ptr %ppVtxOut.addr, align 8
  %36 = load i32, ptr %numVertsOut, align 4
  %inc33 = add nsw i32 %36, 1
  store i32 %inc33, ptr %numVertsOut, align 4
  %idxprom34 = sext i32 %36 to i64
  %arrayidx35 = getelementptr inbounds %class.b3Vector3, ptr %35, i64 %idxprom34
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx35, ptr align 16 %endVertex, i64 16, i1 false)
  br label %if.end36

if.end36:                                         ; preds = %if.then22, %if.else20
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.end19
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %firstVertex, ptr align 16 %endVertex, i64 16, i1 false)
  %37 = load float, ptr %de, align 4
  store float %37, ptr %ds, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end37
  %38 = load i32, ptr %ve, align 4
  %inc38 = add nsw i32 %38, 1
  store i32 %inc38, ptr %ve, align 4
  br label %for.cond, !llvm.loop !31

for.end:                                          ; preds = %for.cond
  %39 = load i32, ptr %numVertsOut, align 4
  store i32 %39, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %40 = load i32, ptr %retval, align 4
  ret i32 %40
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_Z5lerp3RK9b3Vector3S1_f(ptr noundef nonnull align 16 dereferenceable(16) %a, ptr noundef nonnull align 16 dereferenceable(16) %b, float noundef %t) #6 comdat {
entry:
  %retval = alloca %class.b3Vector3, align 16
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %t.addr = alloca float, align 4
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  store float %t, ptr %t.addr, align 4
  %0 = load ptr, ptr %a.addr, align 8
  %1 = getelementptr inbounds %class.b3Vector3, ptr %0, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon.2, ptr %1, i32 0, i32 0
  %2 = load float, ptr %x, align 16
  %3 = load ptr, ptr %b.addr, align 8
  %4 = getelementptr inbounds %class.b3Vector3, ptr %3, i32 0, i32 0
  %x1 = getelementptr inbounds %struct.anon.2, ptr %4, i32 0, i32 0
  %5 = load float, ptr %x1, align 16
  %6 = load ptr, ptr %a.addr, align 8
  %7 = getelementptr inbounds %class.b3Vector3, ptr %6, i32 0, i32 0
  %x2 = getelementptr inbounds %struct.anon.2, ptr %7, i32 0, i32 0
  %8 = load float, ptr %x2, align 16
  %sub = fsub float %5, %8
  %9 = load float, ptr %t.addr, align 4
  %10 = call float @llvm.fmuladd.f32(float %sub, float %9, float %2)
  %11 = load ptr, ptr %a.addr, align 8
  %12 = getelementptr inbounds %class.b3Vector3, ptr %11, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon.2, ptr %12, i32 0, i32 1
  %13 = load float, ptr %y, align 4
  %14 = load ptr, ptr %b.addr, align 8
  %15 = getelementptr inbounds %class.b3Vector3, ptr %14, i32 0, i32 0
  %y3 = getelementptr inbounds %struct.anon.2, ptr %15, i32 0, i32 1
  %16 = load float, ptr %y3, align 4
  %17 = load ptr, ptr %a.addr, align 8
  %18 = getelementptr inbounds %class.b3Vector3, ptr %17, i32 0, i32 0
  %y4 = getelementptr inbounds %struct.anon.2, ptr %18, i32 0, i32 1
  %19 = load float, ptr %y4, align 4
  %sub5 = fsub float %16, %19
  %20 = load float, ptr %t.addr, align 4
  %21 = call float @llvm.fmuladd.f32(float %sub5, float %20, float %13)
  %22 = load ptr, ptr %a.addr, align 8
  %23 = getelementptr inbounds %class.b3Vector3, ptr %22, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon.2, ptr %23, i32 0, i32 2
  %24 = load float, ptr %z, align 8
  %25 = load ptr, ptr %b.addr, align 8
  %26 = getelementptr inbounds %class.b3Vector3, ptr %25, i32 0, i32 0
  %z6 = getelementptr inbounds %struct.anon.2, ptr %26, i32 0, i32 2
  %27 = load float, ptr %z6, align 8
  %28 = load ptr, ptr %a.addr, align 8
  %29 = getelementptr inbounds %class.b3Vector3, ptr %28, i32 0, i32 0
  %z7 = getelementptr inbounds %struct.anon.2, ptr %29, i32 0, i32 2
  %30 = load float, ptr %z7, align 8
  %sub8 = fsub float %27, %30
  %31 = load float, ptr %t.addr, align 4
  %32 = call float @llvm.fmuladd.f32(float %sub8, float %31, float %24)
  %call = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef %10, float noundef %21, float noundef %32, float noundef 0.000000e+00)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive9 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %33 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive9, i32 0, i32 0
  %34 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %34, ptr %33, align 16
  %35 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive9, i32 0, i32 1
  %36 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %36, ptr %35, align 8
  %coerce.dive10 = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive11 = getelementptr inbounds %union.anon.1, ptr %coerce.dive10, i32 0, i32 0
  %37 = load { <2 x float>, <2 x float> }, ptr %coerce.dive11, align 16
  ret { <2 x float>, <2 x float> } %37
}

; Function Attrs: mustprogress uwtable
define dso_local noundef i32 @_Z19clipFaceAgainstHullRK9b3Vector3PK22b3ConvexPolyhedronDataS1_RK12b3QuaternionPS_iS8_iffRK20b3AlignedObjectArrayIS_ERKS9_I9b3GpuFaceERKS9_IiES8_i(ptr noundef nonnull align 16 dereferenceable(16) %separatingNormal, ptr noundef %hullA, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef %worldVertsB1, i32 noundef %numWorldVertsB1, ptr noundef %worldVertsB2, i32 noundef %capacityWorldVertsB2, float noundef %minDist, float noundef %maxDist, ptr noundef nonnull align 8 dereferenceable(25) %verticesA, ptr noundef nonnull align 8 dereferenceable(25) %facesA, ptr noundef nonnull align 8 dereferenceable(25) %indicesA, ptr noundef %contactsOut, i32 noundef %contactCapacity) #2 {
entry:
  %retval = alloca i32, align 4
  %separatingNormal.addr = alloca ptr, align 8
  %hullA.addr = alloca ptr, align 8
  %posA.addr = alloca ptr, align 8
  %ornA.addr = alloca ptr, align 8
  %worldVertsB1.addr = alloca ptr, align 8
  %numWorldVertsB1.addr = alloca i32, align 4
  %worldVertsB2.addr = alloca ptr, align 8
  %capacityWorldVertsB2.addr = alloca i32, align 4
  %minDist.addr = alloca float, align 4
  %maxDist.addr = alloca float, align 4
  %verticesA.addr = alloca ptr, align 8
  %facesA.addr = alloca ptr, align 8
  %indicesA.addr = alloca ptr, align 8
  %contactsOut.addr = alloca ptr, align 8
  %contactCapacity.addr = alloca i32, align 4
  %numContactsOut = alloca i32, align 4
  %pVtxIn = alloca ptr, align 8
  %pVtxOut = alloca ptr, align 8
  %numVertsIn = alloca i32, align 4
  %numVertsOut = alloca i32, align 4
  %closestFaceA = alloca i32, align 4
  %dmin = alloca float, align 4
  %face = alloca i32, align 4
  %Normal = alloca %class.b3Vector3, align 16
  %faceANormalWS = alloca %class.b3Vector3, align 16
  %d = alloca float, align 4
  %polyA = alloca %struct.b3GpuFace, align 16
  %numVerticesA = alloca i32, align 4
  %e0 = alloca i32, align 4
  %a = alloca %class.b3Vector3, align 16
  %b = alloca %class.b3Vector3, align 16
  %edge0 = alloca %class.b3Vector3, align 16
  %WorldEdge0 = alloca %class.b3Vector3, align 16
  %planeNormalA = alloca %class.b3Vector3, align 16
  %worldPlaneAnormal1 = alloca %class.b3Vector3, align 16
  %planeNormalWS1 = alloca %class.b3Vector3, align 16
  %ref.tmp = alloca %class.b3Vector3, align 16
  %worldA1 = alloca %class.b3Vector3, align 16
  %planeEqWS1 = alloca float, align 4
  %planeNormalWS = alloca %class.b3Vector3, align 16
  %planeEqWS = alloca float, align 4
  %tmp = alloca ptr, align 8
  %localPlaneNormal = alloca %class.b3Vector3, align 16
  %localPlaneEq = alloca float, align 4
  %planeNormalWS78 = alloca %class.b3Vector3, align 16
  %planeEqWS82 = alloca float, align 4
  %i = alloca i32, align 4
  %depth = alloca float, align 4
  %pointInWorld = alloca %class.b3Vector3, align 16
  %ref.tmp98 = alloca %class.b3Vector3, align 16
  store ptr %separatingNormal, ptr %separatingNormal.addr, align 8
  store ptr %hullA, ptr %hullA.addr, align 8
  store ptr %posA, ptr %posA.addr, align 8
  store ptr %ornA, ptr %ornA.addr, align 8
  store ptr %worldVertsB1, ptr %worldVertsB1.addr, align 8
  store i32 %numWorldVertsB1, ptr %numWorldVertsB1.addr, align 4
  store ptr %worldVertsB2, ptr %worldVertsB2.addr, align 8
  store i32 %capacityWorldVertsB2, ptr %capacityWorldVertsB2.addr, align 4
  store float %minDist, ptr %minDist.addr, align 4
  store float %maxDist, ptr %maxDist.addr, align 4
  store ptr %verticesA, ptr %verticesA.addr, align 8
  store ptr %facesA, ptr %facesA.addr, align 8
  store ptr %indicesA, ptr %indicesA.addr, align 8
  store ptr %contactsOut, ptr %contactsOut.addr, align 8
  store i32 %contactCapacity, ptr %contactCapacity.addr, align 4
  store i32 0, ptr %numContactsOut, align 4
  %0 = load ptr, ptr %worldVertsB1.addr, align 8
  store ptr %0, ptr %pVtxIn, align 8
  %1 = load ptr, ptr %worldVertsB2.addr, align 8
  store ptr %1, ptr %pVtxOut, align 8
  %2 = load i32, ptr %numWorldVertsB1.addr, align 4
  store i32 %2, ptr %numVertsIn, align 4
  store i32 0, ptr %numVertsOut, align 4
  store i32 -1, ptr %closestFaceA, align 4
  store float 0x47EFFFFFE0000000, ptr %dmin, align 4
  store i32 0, ptr %face, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i32, ptr %face, align 4
  %4 = load ptr, ptr %hullA.addr, align 8
  %m_numFaces = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %4, i32 0, i32 6
  %5 = load i32, ptr %m_numFaces, align 8
  %cmp = icmp slt i32 %3, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load ptr, ptr %facesA.addr, align 8
  %7 = load ptr, ptr %hullA.addr, align 8
  %m_faceOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %7, i32 0, i32 5
  %8 = load i32, ptr %m_faceOffset, align 4
  %9 = load i32, ptr %face, align 4
  %add = add nsw i32 %8, %9
  %call = call noundef nonnull align 16 dereferenceable(32) ptr @_ZNK20b3AlignedObjectArrayI9b3GpuFaceEixEi(ptr noundef nonnull align 8 dereferenceable(25) %6, i32 noundef %add)
  %m_plane = getelementptr inbounds %struct.b3GpuFace, ptr %call, i32 0, i32 0
  %10 = getelementptr inbounds %class.b3Vector3, ptr %m_plane, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon.2, ptr %10, i32 0, i32 0
  %11 = load float, ptr %x, align 16
  %12 = load ptr, ptr %facesA.addr, align 8
  %13 = load ptr, ptr %hullA.addr, align 8
  %m_faceOffset1 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %13, i32 0, i32 5
  %14 = load i32, ptr %m_faceOffset1, align 4
  %15 = load i32, ptr %face, align 4
  %add2 = add nsw i32 %14, %15
  %call3 = call noundef nonnull align 16 dereferenceable(32) ptr @_ZNK20b3AlignedObjectArrayI9b3GpuFaceEixEi(ptr noundef nonnull align 8 dereferenceable(25) %12, i32 noundef %add2)
  %m_plane4 = getelementptr inbounds %struct.b3GpuFace, ptr %call3, i32 0, i32 0
  %16 = getelementptr inbounds %class.b3Vector3, ptr %m_plane4, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon.2, ptr %16, i32 0, i32 1
  %17 = load float, ptr %y, align 4
  %18 = load ptr, ptr %facesA.addr, align 8
  %19 = load ptr, ptr %hullA.addr, align 8
  %m_faceOffset5 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %19, i32 0, i32 5
  %20 = load i32, ptr %m_faceOffset5, align 4
  %21 = load i32, ptr %face, align 4
  %add6 = add nsw i32 %20, %21
  %call7 = call noundef nonnull align 16 dereferenceable(32) ptr @_ZNK20b3AlignedObjectArrayI9b3GpuFaceEixEi(ptr noundef nonnull align 8 dereferenceable(25) %18, i32 noundef %add6)
  %m_plane8 = getelementptr inbounds %struct.b3GpuFace, ptr %call7, i32 0, i32 0
  %22 = getelementptr inbounds %class.b3Vector3, ptr %m_plane8, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon.2, ptr %22, i32 0, i32 2
  %23 = load float, ptr %z, align 8
  %call9 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef %11, float noundef %17, float noundef %23, float noundef 0.000000e+00)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %Normal, i32 0, i32 0
  %coerce.dive10 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %24 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive10, i32 0, i32 0
  %25 = extractvalue { <2 x float>, <2 x float> } %call9, 0
  store <2 x float> %25, ptr %24, align 16
  %26 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive10, i32 0, i32 1
  %27 = extractvalue { <2 x float>, <2 x float> } %call9, 1
  store <2 x float> %27, ptr %26, align 8
  %28 = load ptr, ptr %ornA.addr, align 8
  %call11 = call { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %28, ptr noundef nonnull align 16 dereferenceable(16) %Normal)
  %coerce.dive12 = getelementptr inbounds %class.b3Vector3, ptr %faceANormalWS, i32 0, i32 0
  %coerce.dive13 = getelementptr inbounds %union.anon.1, ptr %coerce.dive12, i32 0, i32 0
  %29 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive13, i32 0, i32 0
  %30 = extractvalue { <2 x float>, <2 x float> } %call11, 0
  store <2 x float> %30, ptr %29, align 16
  %31 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive13, i32 0, i32 1
  %32 = extractvalue { <2 x float>, <2 x float> } %call11, 1
  store <2 x float> %32, ptr %31, align 8
  %33 = load ptr, ptr %separatingNormal.addr, align 8
  %call14 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %faceANormalWS, ptr noundef nonnull align 16 dereferenceable(16) %33)
  store float %call14, ptr %d, align 4
  %34 = load float, ptr %d, align 4
  %35 = load float, ptr %dmin, align 4
  %cmp15 = fcmp olt float %34, %35
  br i1 %cmp15, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %36 = load float, ptr %d, align 4
  store float %36, ptr %dmin, align 4
  %37 = load i32, ptr %face, align 4
  store i32 %37, ptr %closestFaceA, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %38 = load i32, ptr %face, align 4
  %inc = add nsw i32 %38, 1
  store i32 %inc, ptr %face, align 4
  br label %for.cond, !llvm.loop !32

for.end:                                          ; preds = %for.cond
  %39 = load i32, ptr %closestFaceA, align 4
  %cmp16 = icmp slt i32 %39, 0
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %for.end
  %40 = load i32, ptr %numContactsOut, align 4
  store i32 %40, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %for.end
  %41 = load ptr, ptr %facesA.addr, align 8
  %42 = load ptr, ptr %hullA.addr, align 8
  %m_faceOffset19 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %42, i32 0, i32 5
  %43 = load i32, ptr %m_faceOffset19, align 4
  %44 = load i32, ptr %closestFaceA, align 4
  %add20 = add nsw i32 %43, %44
  %call21 = call noundef nonnull align 16 dereferenceable(32) ptr @_ZNK20b3AlignedObjectArrayI9b3GpuFaceEixEi(ptr noundef nonnull align 8 dereferenceable(25) %41, i32 noundef %add20)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %polyA, ptr align 16 %call21, i64 32, i1 false)
  %m_numIndices = getelementptr inbounds %struct.b3GpuFace, ptr %polyA, i32 0, i32 2
  %45 = load i32, ptr %m_numIndices, align 4
  store i32 %45, ptr %numVerticesA, align 4
  store i32 0, ptr %e0, align 4
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc65, %if.end18
  %46 = load i32, ptr %e0, align 4
  %47 = load i32, ptr %numVerticesA, align 4
  %cmp23 = icmp slt i32 %46, %47
  br i1 %cmp23, label %for.body24, label %for.end67

for.body24:                                       ; preds = %for.cond22
  %48 = load ptr, ptr %verticesA.addr, align 8
  %49 = load ptr, ptr %hullA.addr, align 8
  %m_vertexOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %49, i32 0, i32 8
  %50 = load i32, ptr %m_vertexOffset, align 16
  %51 = load ptr, ptr %indicesA.addr, align 8
  %m_indexOffset = getelementptr inbounds %struct.b3GpuFace, ptr %polyA, i32 0, i32 1
  %52 = load i32, ptr %m_indexOffset, align 16
  %53 = load i32, ptr %e0, align 4
  %add25 = add nsw i32 %52, %53
  %call26 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK20b3AlignedObjectArrayIiEixEi(ptr noundef nonnull align 8 dereferenceable(25) %51, i32 noundef %add25)
  %54 = load i32, ptr %call26, align 4
  %add27 = add nsw i32 %50, %54
  %call28 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK20b3AlignedObjectArrayI9b3Vector3EixEi(ptr noundef nonnull align 8 dereferenceable(25) %48, i32 noundef %add27)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %a, ptr align 16 %call28, i64 16, i1 false)
  %55 = load ptr, ptr %verticesA.addr, align 8
  %56 = load ptr, ptr %hullA.addr, align 8
  %m_vertexOffset29 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %56, i32 0, i32 8
  %57 = load i32, ptr %m_vertexOffset29, align 16
  %58 = load ptr, ptr %indicesA.addr, align 8
  %m_indexOffset30 = getelementptr inbounds %struct.b3GpuFace, ptr %polyA, i32 0, i32 1
  %59 = load i32, ptr %m_indexOffset30, align 16
  %60 = load i32, ptr %e0, align 4
  %add31 = add nsw i32 %60, 1
  %61 = load i32, ptr %numVerticesA, align 4
  %rem = srem i32 %add31, %61
  %add32 = add nsw i32 %59, %rem
  %call33 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK20b3AlignedObjectArrayIiEixEi(ptr noundef nonnull align 8 dereferenceable(25) %58, i32 noundef %add32)
  %62 = load i32, ptr %call33, align 4
  %add34 = add nsw i32 %57, %62
  %call35 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK20b3AlignedObjectArrayI9b3Vector3EixEi(ptr noundef nonnull align 8 dereferenceable(25) %55, i32 noundef %add34)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %b, ptr align 16 %call35, i64 16, i1 false)
  %call36 = call { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %a, ptr noundef nonnull align 16 dereferenceable(16) %b)
  %coerce.dive37 = getelementptr inbounds %class.b3Vector3, ptr %edge0, i32 0, i32 0
  %coerce.dive38 = getelementptr inbounds %union.anon.1, ptr %coerce.dive37, i32 0, i32 0
  %63 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive38, i32 0, i32 0
  %64 = extractvalue { <2 x float>, <2 x float> } %call36, 0
  store <2 x float> %64, ptr %63, align 16
  %65 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive38, i32 0, i32 1
  %66 = extractvalue { <2 x float>, <2 x float> } %call36, 1
  store <2 x float> %66, ptr %65, align 8
  %67 = load ptr, ptr %ornA.addr, align 8
  %call39 = call { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %67, ptr noundef nonnull align 16 dereferenceable(16) %edge0)
  %coerce.dive40 = getelementptr inbounds %class.b3Vector3, ptr %WorldEdge0, i32 0, i32 0
  %coerce.dive41 = getelementptr inbounds %union.anon.1, ptr %coerce.dive40, i32 0, i32 0
  %68 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive41, i32 0, i32 0
  %69 = extractvalue { <2 x float>, <2 x float> } %call39, 0
  store <2 x float> %69, ptr %68, align 16
  %70 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive41, i32 0, i32 1
  %71 = extractvalue { <2 x float>, <2 x float> } %call39, 1
  store <2 x float> %71, ptr %70, align 8
  %m_plane42 = getelementptr inbounds %struct.b3GpuFace, ptr %polyA, i32 0, i32 0
  %72 = getelementptr inbounds %class.b3Vector3, ptr %m_plane42, i32 0, i32 0
  %x43 = getelementptr inbounds %struct.anon.2, ptr %72, i32 0, i32 0
  %73 = load float, ptr %x43, align 16
  %m_plane44 = getelementptr inbounds %struct.b3GpuFace, ptr %polyA, i32 0, i32 0
  %74 = getelementptr inbounds %class.b3Vector3, ptr %m_plane44, i32 0, i32 0
  %y45 = getelementptr inbounds %struct.anon.2, ptr %74, i32 0, i32 1
  %75 = load float, ptr %y45, align 4
  %m_plane46 = getelementptr inbounds %struct.b3GpuFace, ptr %polyA, i32 0, i32 0
  %76 = getelementptr inbounds %class.b3Vector3, ptr %m_plane46, i32 0, i32 0
  %z47 = getelementptr inbounds %struct.anon.2, ptr %76, i32 0, i32 2
  %77 = load float, ptr %z47, align 8
  %call48 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef %73, float noundef %75, float noundef %77, float noundef 0.000000e+00)
  %coerce.dive49 = getelementptr inbounds %class.b3Vector3, ptr %planeNormalA, i32 0, i32 0
  %coerce.dive50 = getelementptr inbounds %union.anon.1, ptr %coerce.dive49, i32 0, i32 0
  %78 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive50, i32 0, i32 0
  %79 = extractvalue { <2 x float>, <2 x float> } %call48, 0
  store <2 x float> %79, ptr %78, align 16
  %80 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive50, i32 0, i32 1
  %81 = extractvalue { <2 x float>, <2 x float> } %call48, 1
  store <2 x float> %81, ptr %80, align 8
  %82 = load ptr, ptr %ornA.addr, align 8
  %call51 = call { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %82, ptr noundef nonnull align 16 dereferenceable(16) %planeNormalA)
  %coerce.dive52 = getelementptr inbounds %class.b3Vector3, ptr %worldPlaneAnormal1, i32 0, i32 0
  %coerce.dive53 = getelementptr inbounds %union.anon.1, ptr %coerce.dive52, i32 0, i32 0
  %83 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive53, i32 0, i32 0
  %84 = extractvalue { <2 x float>, <2 x float> } %call51, 0
  store <2 x float> %84, ptr %83, align 16
  %85 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive53, i32 0, i32 1
  %86 = extractvalue { <2 x float>, <2 x float> } %call51, 1
  store <2 x float> %86, ptr %85, align 8
  %call54 = call { <2 x float>, <2 x float> } @_ZNK9b3Vector35crossERKS_(ptr noundef nonnull align 16 dereferenceable(16) %WorldEdge0, ptr noundef nonnull align 16 dereferenceable(16) %worldPlaneAnormal1)
  %coerce.dive55 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive56 = getelementptr inbounds %union.anon.1, ptr %coerce.dive55, i32 0, i32 0
  %87 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive56, i32 0, i32 0
  %88 = extractvalue { <2 x float>, <2 x float> } %call54, 0
  store <2 x float> %88, ptr %87, align 16
  %89 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive56, i32 0, i32 1
  %90 = extractvalue { <2 x float>, <2 x float> } %call54, 1
  store <2 x float> %90, ptr %89, align 8
  %call57 = call { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp)
  %coerce.dive58 = getelementptr inbounds %class.b3Vector3, ptr %planeNormalWS1, i32 0, i32 0
  %coerce.dive59 = getelementptr inbounds %union.anon.1, ptr %coerce.dive58, i32 0, i32 0
  %91 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive59, i32 0, i32 0
  %92 = extractvalue { <2 x float>, <2 x float> } %call57, 0
  store <2 x float> %92, ptr %91, align 16
  %93 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive59, i32 0, i32 1
  %94 = extractvalue { <2 x float>, <2 x float> } %call57, 1
  store <2 x float> %94, ptr %93, align 8
  %95 = load ptr, ptr %posA.addr, align 8
  %96 = load ptr, ptr %ornA.addr, align 8
  %call60 = call { <2 x float>, <2 x float> } @_Z9transformPK9b3Vector3S1_PK12b3Quaternion(ptr noundef %a, ptr noundef %95, ptr noundef %96)
  %coerce.dive61 = getelementptr inbounds %class.b3Vector3, ptr %worldA1, i32 0, i32 0
  %coerce.dive62 = getelementptr inbounds %union.anon.1, ptr %coerce.dive61, i32 0, i32 0
  %97 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive62, i32 0, i32 0
  %98 = extractvalue { <2 x float>, <2 x float> } %call60, 0
  store <2 x float> %98, ptr %97, align 16
  %99 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive62, i32 0, i32 1
  %100 = extractvalue { <2 x float>, <2 x float> } %call60, 1
  store <2 x float> %100, ptr %99, align 8
  %call63 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %worldA1, ptr noundef nonnull align 16 dereferenceable(16) %planeNormalWS1)
  %fneg = fneg float %call63
  store float %fneg, ptr %planeEqWS1, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %planeNormalWS, ptr align 16 %planeNormalWS1, i64 16, i1 false)
  %101 = load float, ptr %planeEqWS1, align 4
  store float %101, ptr %planeEqWS, align 4
  %102 = load ptr, ptr %pVtxIn, align 8
  %103 = load i32, ptr %numVertsIn, align 4
  %104 = load float, ptr %planeEqWS, align 4
  %105 = load ptr, ptr %pVtxOut, align 8
  %call64 = call noundef i32 @_Z8clipFacePK9b3Vector3iRS_fPS_(ptr noundef %102, i32 noundef %103, ptr noundef nonnull align 16 dereferenceable(16) %planeNormalWS, float noundef %104, ptr noundef %105)
  store i32 %call64, ptr %numVertsOut, align 4
  %106 = load ptr, ptr %pVtxOut, align 8
  store ptr %106, ptr %tmp, align 8
  %107 = load ptr, ptr %pVtxIn, align 8
  store ptr %107, ptr %pVtxOut, align 8
  %108 = load ptr, ptr %tmp, align 8
  store ptr %108, ptr %pVtxIn, align 8
  %109 = load i32, ptr %numVertsOut, align 4
  store i32 %109, ptr %numVertsIn, align 4
  store i32 0, ptr %numVertsOut, align 4
  br label %for.inc65

for.inc65:                                        ; preds = %for.body24
  %110 = load i32, ptr %e0, align 4
  %inc66 = add nsw i32 %110, 1
  store i32 %inc66, ptr %e0, align 4
  br label %for.cond22, !llvm.loop !33

for.end67:                                        ; preds = %for.cond22
  %m_plane68 = getelementptr inbounds %struct.b3GpuFace, ptr %polyA, i32 0, i32 0
  %111 = getelementptr inbounds %class.b3Vector3, ptr %m_plane68, i32 0, i32 0
  %x69 = getelementptr inbounds %struct.anon.2, ptr %111, i32 0, i32 0
  %112 = load float, ptr %x69, align 16
  %m_plane70 = getelementptr inbounds %struct.b3GpuFace, ptr %polyA, i32 0, i32 0
  %113 = getelementptr inbounds %class.b3Vector3, ptr %m_plane70, i32 0, i32 0
  %y71 = getelementptr inbounds %struct.anon.2, ptr %113, i32 0, i32 1
  %114 = load float, ptr %y71, align 4
  %m_plane72 = getelementptr inbounds %struct.b3GpuFace, ptr %polyA, i32 0, i32 0
  %115 = getelementptr inbounds %class.b3Vector3, ptr %m_plane72, i32 0, i32 0
  %z73 = getelementptr inbounds %struct.anon.2, ptr %115, i32 0, i32 2
  %116 = load float, ptr %z73, align 8
  %call74 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef %112, float noundef %114, float noundef %116, float noundef 0.000000e+00)
  %coerce.dive75 = getelementptr inbounds %class.b3Vector3, ptr %localPlaneNormal, i32 0, i32 0
  %coerce.dive76 = getelementptr inbounds %union.anon.1, ptr %coerce.dive75, i32 0, i32 0
  %117 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive76, i32 0, i32 0
  %118 = extractvalue { <2 x float>, <2 x float> } %call74, 0
  store <2 x float> %118, ptr %117, align 16
  %119 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive76, i32 0, i32 1
  %120 = extractvalue { <2 x float>, <2 x float> } %call74, 1
  store <2 x float> %120, ptr %119, align 8
  %m_plane77 = getelementptr inbounds %struct.b3GpuFace, ptr %polyA, i32 0, i32 0
  %121 = getelementptr inbounds %class.b3Vector3, ptr %m_plane77, i32 0, i32 0
  %w = getelementptr inbounds %struct.anon.2, ptr %121, i32 0, i32 3
  %122 = load float, ptr %w, align 4
  store float %122, ptr %localPlaneEq, align 4
  %123 = load ptr, ptr %ornA.addr, align 8
  %call79 = call { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %123, ptr noundef nonnull align 16 dereferenceable(16) %localPlaneNormal)
  %coerce.dive80 = getelementptr inbounds %class.b3Vector3, ptr %planeNormalWS78, i32 0, i32 0
  %coerce.dive81 = getelementptr inbounds %union.anon.1, ptr %coerce.dive80, i32 0, i32 0
  %124 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive81, i32 0, i32 0
  %125 = extractvalue { <2 x float>, <2 x float> } %call79, 0
  store <2 x float> %125, ptr %124, align 16
  %126 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive81, i32 0, i32 1
  %127 = extractvalue { <2 x float>, <2 x float> } %call79, 1
  store <2 x float> %127, ptr %126, align 8
  %128 = load float, ptr %localPlaneEq, align 4
  %129 = load ptr, ptr %posA.addr, align 8
  %call83 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %planeNormalWS78, ptr noundef nonnull align 16 dereferenceable(16) %129)
  %sub = fsub float %128, %call83
  store float %sub, ptr %planeEqWS82, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond84

for.cond84:                                       ; preds = %for.inc110, %for.end67
  %130 = load i32, ptr %i, align 4
  %131 = load i32, ptr %numVertsIn, align 4
  %cmp85 = icmp slt i32 %130, %131
  br i1 %cmp85, label %for.body86, label %for.end112

for.body86:                                       ; preds = %for.cond84
  %132 = load ptr, ptr %pVtxIn, align 8
  %133 = load i32, ptr %i, align 4
  %idxprom = sext i32 %133 to i64
  %arrayidx = getelementptr inbounds %class.b3Vector3, ptr %132, i64 %idxprom
  %call87 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %planeNormalWS78, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx)
  %134 = load float, ptr %planeEqWS82, align 4
  %add88 = fadd float %call87, %134
  store float %add88, ptr %depth, align 4
  %135 = load float, ptr %depth, align 4
  %136 = load float, ptr %minDist.addr, align 4
  %cmp89 = fcmp ole float %135, %136
  br i1 %cmp89, label %if.then90, label %if.end91

if.then90:                                        ; preds = %for.body86
  %137 = load float, ptr %minDist.addr, align 4
  store float %137, ptr %depth, align 4
  br label %if.end91

if.end91:                                         ; preds = %if.then90, %for.body86
  %138 = load i32, ptr %numContactsOut, align 4
  %139 = load i32, ptr %contactCapacity.addr, align 4
  %cmp92 = icmp slt i32 %138, %139
  br i1 %cmp92, label %if.then93, label %if.else

if.then93:                                        ; preds = %if.end91
  %140 = load float, ptr %depth, align 4
  %141 = load float, ptr %maxDist.addr, align 4
  %cmp94 = fcmp ole float %140, %141
  br i1 %cmp94, label %if.then95, label %if.end108

if.then95:                                        ; preds = %if.then93
  %142 = load ptr, ptr %pVtxIn, align 8
  %143 = load i32, ptr %i, align 4
  %idxprom96 = sext i32 %143 to i64
  %arrayidx97 = getelementptr inbounds %class.b3Vector3, ptr %142, i64 %idxprom96
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %pointInWorld, ptr align 16 %arrayidx97, i64 16, i1 false)
  %144 = getelementptr inbounds %class.b3Vector3, ptr %pointInWorld, i32 0, i32 0
  %x99 = getelementptr inbounds %struct.anon.2, ptr %144, i32 0, i32 0
  %145 = load float, ptr %x99, align 16
  %146 = getelementptr inbounds %class.b3Vector3, ptr %pointInWorld, i32 0, i32 0
  %y100 = getelementptr inbounds %struct.anon.2, ptr %146, i32 0, i32 1
  %147 = load float, ptr %y100, align 4
  %148 = getelementptr inbounds %class.b3Vector3, ptr %pointInWorld, i32 0, i32 0
  %z101 = getelementptr inbounds %struct.anon.2, ptr %148, i32 0, i32 2
  %149 = load float, ptr %z101, align 8
  %150 = load float, ptr %depth, align 4
  %call102 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef %145, float noundef %147, float noundef %149, float noundef %150)
  %coerce.dive103 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp98, i32 0, i32 0
  %coerce.dive104 = getelementptr inbounds %union.anon.1, ptr %coerce.dive103, i32 0, i32 0
  %151 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive104, i32 0, i32 0
  %152 = extractvalue { <2 x float>, <2 x float> } %call102, 0
  store <2 x float> %152, ptr %151, align 16
  %153 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive104, i32 0, i32 1
  %154 = extractvalue { <2 x float>, <2 x float> } %call102, 1
  store <2 x float> %154, ptr %153, align 8
  %155 = load ptr, ptr %contactsOut.addr, align 8
  %156 = load i32, ptr %numContactsOut, align 4
  %inc105 = add nsw i32 %156, 1
  store i32 %inc105, ptr %numContactsOut, align 4
  %idxprom106 = sext i32 %156 to i64
  %arrayidx107 = getelementptr inbounds %class.b3Vector3, ptr %155, i64 %idxprom106
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx107, ptr align 16 %ref.tmp98, i64 16, i1 false)
  br label %if.end108

if.end108:                                        ; preds = %if.then95, %if.then93
  br label %if.end109

if.else:                                          ; preds = %if.end91
  br label %do.body

do.body:                                          ; preds = %if.else
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.31, i32 noundef 931)
  %157 = load i32, ptr %numContactsOut, align 4
  %158 = load i32, ptr %contactCapacity.addr, align 4
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.32, i32 noundef %157, i32 noundef %158)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %if.end109

if.end109:                                        ; preds = %do.end, %if.end108
  br label %for.inc110

for.inc110:                                       ; preds = %if.end109
  %159 = load i32, ptr %i, align 4
  %inc111 = add nsw i32 %159, 1
  store i32 %inc111, ptr %i, align 4
  br label %for.cond84, !llvm.loop !34

for.end112:                                       ; preds = %for.cond84
  %160 = load i32, ptr %numContactsOut, align 4
  store i32 %160, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end112, %if.then17
  %161 = load i32, ptr %retval, align 4
  ret i32 %161
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(32) ptr @_ZNK20b3AlignedObjectArrayI9b3GpuFaceEixEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3GpuFace, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 4 dereferenceable(4) ptr @_ZNK20b3AlignedObjectArrayIiEixEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds i32, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

declare void @b3OutputErrorMessageVarArgsInternal(ptr noundef, ...) #5

; Function Attrs: mustprogress uwtable
define dso_local noundef i32 @_Z15extractManifoldPK9b3Vector3iRS0_P6b3Int4(ptr noundef %p, i32 noundef %nPoints, ptr noundef nonnull align 16 dereferenceable(16) %nearNormal, ptr noundef %contactIdx) #2 {
entry:
  %retval = alloca i32, align 4
  %p.addr = alloca ptr, align 8
  %nPoints.addr = alloca i32, align 4
  %nearNormal.addr = alloca ptr, align 8
  %contactIdx.addr = alloca ptr, align 8
  %center = alloca %class.b3Vector3, align 16
  %i = alloca i32, align 4
  %ref.tmp = alloca float, align 4
  %aVector = alloca %class.b3Vector3, align 16
  %u = alloca %class.b3Vector3, align 16
  %v = alloca %class.b3Vector3, align 16
  %minW = alloca float, align 4
  %minIndex = alloca i32, align 4
  %maxDots = alloca %class.b3Vector3, align 16
  %ie = alloca i32, align 4
  %f = alloca float, align 4
  %r = alloca %class.b3Vector3, align 16
  %ref.tmp48 = alloca %class.b3Vector3, align 16
  %ref.tmp68 = alloca %class.b3Vector3, align 16
  store ptr %p, ptr %p.addr, align 8
  store i32 %nPoints, ptr %nPoints.addr, align 4
  store ptr %nearNormal, ptr %nearNormal.addr, align 8
  store ptr %contactIdx, ptr %contactIdx.addr, align 8
  %0 = load i32, ptr %nPoints.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, ptr %nPoints.addr, align 4
  %cmp1 = icmp sle i32 %1, 4
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %2 = load i32, ptr %nPoints.addr, align 4
  store i32 %2, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %3 = load i32, ptr %nPoints.addr, align 4
  %cmp4 = icmp sgt i32 %3, 64
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  store i32 64, ptr %nPoints.addr, align 4
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.end3
  %call = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %center, i32 0, i32 0
  %coerce.dive7 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %4 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive7, i32 0, i32 0
  %5 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %5, ptr %4, align 16
  %6 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive7, i32 0, i32 1
  %7 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %7, ptr %6, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %nPoints.addr, align 4
  %cmp8 = icmp slt i32 %8, %9
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %p.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idxprom = sext i32 %11 to i64
  %arrayidx = getelementptr inbounds %class.b3Vector3, ptr %10, i64 %idxprom
  %call9 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector3pLERKS_(ptr noundef nonnull align 16 dereferenceable(16) %center, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, ptr %i, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !35

for.end:                                          ; preds = %for.cond
  %13 = load i32, ptr %nPoints.addr, align 4
  %conv = sitofp i32 %13 to float
  store float %conv, ptr %ref.tmp, align 4
  %call10 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector3dVERKf(ptr noundef nonnull align 16 dereferenceable(16) %center, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp)
  %14 = load ptr, ptr %p.addr, align 8
  %arrayidx11 = getelementptr inbounds %class.b3Vector3, ptr %14, i64 0
  %call12 = call { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx11, ptr noundef nonnull align 16 dereferenceable(16) %center)
  %coerce.dive13 = getelementptr inbounds %class.b3Vector3, ptr %aVector, i32 0, i32 0
  %coerce.dive14 = getelementptr inbounds %union.anon.1, ptr %coerce.dive13, i32 0, i32 0
  %15 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive14, i32 0, i32 0
  %16 = extractvalue { <2 x float>, <2 x float> } %call12, 0
  store <2 x float> %16, ptr %15, align 16
  %17 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive14, i32 0, i32 1
  %18 = extractvalue { <2 x float>, <2 x float> } %call12, 1
  store <2 x float> %18, ptr %17, align 8
  %19 = load ptr, ptr %nearNormal.addr, align 8
  %call15 = call { <2 x float>, <2 x float> } @_ZNK9b3Vector35crossERKS_(ptr noundef nonnull align 16 dereferenceable(16) %19, ptr noundef nonnull align 16 dereferenceable(16) %aVector)
  %coerce.dive16 = getelementptr inbounds %class.b3Vector3, ptr %u, i32 0, i32 0
  %coerce.dive17 = getelementptr inbounds %union.anon.1, ptr %coerce.dive16, i32 0, i32 0
  %20 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive17, i32 0, i32 0
  %21 = extractvalue { <2 x float>, <2 x float> } %call15, 0
  store <2 x float> %21, ptr %20, align 16
  %22 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive17, i32 0, i32 1
  %23 = extractvalue { <2 x float>, <2 x float> } %call15, 1
  store <2 x float> %23, ptr %22, align 8
  %24 = load ptr, ptr %nearNormal.addr, align 8
  %call18 = call { <2 x float>, <2 x float> } @_ZNK9b3Vector35crossERKS_(ptr noundef nonnull align 16 dereferenceable(16) %24, ptr noundef nonnull align 16 dereferenceable(16) %u)
  %coerce.dive19 = getelementptr inbounds %class.b3Vector3, ptr %v, i32 0, i32 0
  %coerce.dive20 = getelementptr inbounds %union.anon.1, ptr %coerce.dive19, i32 0, i32 0
  %25 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive20, i32 0, i32 0
  %26 = extractvalue { <2 x float>, <2 x float> } %call18, 0
  store <2 x float> %26, ptr %25, align 16
  %27 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive20, i32 0, i32 1
  %28 = extractvalue { <2 x float>, <2 x float> } %call18, 1
  store <2 x float> %28, ptr %27, align 8
  %call21 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector39normalizeEv(ptr noundef nonnull align 16 dereferenceable(16) %u)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %u, ptr align 16 %call21, i64 16, i1 false)
  %call22 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector39normalizeEv(ptr noundef nonnull align 16 dereferenceable(16) %v)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %v, ptr align 16 %call22, i64 16, i1 false)
  store float 0x47EFFFFFE0000000, ptr %minW, align 4
  store i32 -1, ptr %minIndex, align 4
  %29 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon.2, ptr %29, i32 0, i32 0
  store float 0x3810000000000000, ptr %x, align 16
  %30 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon.2, ptr %30, i32 0, i32 1
  store float 0x3810000000000000, ptr %y, align 4
  %31 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon.2, ptr %31, i32 0, i32 2
  store float 0x3810000000000000, ptr %z, align 8
  %32 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %w = getelementptr inbounds %struct.anon.2, ptr %32, i32 0, i32 3
  store float 0x3810000000000000, ptr %w, align 4
  store i32 0, ptr %ie, align 4
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc80, %for.end
  %33 = load i32, ptr %ie, align 4
  %34 = load i32, ptr %nPoints.addr, align 4
  %cmp24 = icmp slt i32 %33, %34
  br i1 %cmp24, label %for.body25, label %for.end82

for.body25:                                       ; preds = %for.cond23
  %35 = load ptr, ptr %p.addr, align 8
  %36 = load i32, ptr %ie, align 4
  %idxprom26 = sext i32 %36 to i64
  %arrayidx27 = getelementptr inbounds %class.b3Vector3, ptr %35, i64 %idxprom26
  %37 = getelementptr inbounds %class.b3Vector3, ptr %arrayidx27, i32 0, i32 0
  %w28 = getelementptr inbounds %struct.anon.2, ptr %37, i32 0, i32 3
  %38 = load float, ptr %w28, align 4
  %39 = load float, ptr %minW, align 4
  %cmp29 = fcmp olt float %38, %39
  br i1 %cmp29, label %if.then30, label %if.end34

if.then30:                                        ; preds = %for.body25
  %40 = load ptr, ptr %p.addr, align 8
  %41 = load i32, ptr %ie, align 4
  %idxprom31 = sext i32 %41 to i64
  %arrayidx32 = getelementptr inbounds %class.b3Vector3, ptr %40, i64 %idxprom31
  %42 = getelementptr inbounds %class.b3Vector3, ptr %arrayidx32, i32 0, i32 0
  %w33 = getelementptr inbounds %struct.anon.2, ptr %42, i32 0, i32 3
  %43 = load float, ptr %w33, align 4
  store float %43, ptr %minW, align 4
  %44 = load i32, ptr %ie, align 4
  store i32 %44, ptr %minIndex, align 4
  br label %if.end34

if.end34:                                         ; preds = %if.then30, %for.body25
  %45 = load ptr, ptr %p.addr, align 8
  %46 = load i32, ptr %ie, align 4
  %idxprom35 = sext i32 %46 to i64
  %arrayidx36 = getelementptr inbounds %class.b3Vector3, ptr %45, i64 %idxprom35
  %call37 = call { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx36, ptr noundef nonnull align 16 dereferenceable(16) %center)
  %coerce.dive38 = getelementptr inbounds %class.b3Vector3, ptr %r, i32 0, i32 0
  %coerce.dive39 = getelementptr inbounds %union.anon.1, ptr %coerce.dive38, i32 0, i32 0
  %47 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive39, i32 0, i32 0
  %48 = extractvalue { <2 x float>, <2 x float> } %call37, 0
  store <2 x float> %48, ptr %47, align 16
  %49 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive39, i32 0, i32 1
  %50 = extractvalue { <2 x float>, <2 x float> } %call37, 1
  store <2 x float> %50, ptr %49, align 8
  %call40 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %u, ptr noundef nonnull align 16 dereferenceable(16) %r)
  store float %call40, ptr %f, align 4
  %51 = load float, ptr %f, align 4
  %52 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %x41 = getelementptr inbounds %struct.anon.2, ptr %52, i32 0, i32 0
  %53 = load float, ptr %x41, align 16
  %cmp42 = fcmp olt float %51, %53
  br i1 %cmp42, label %if.then43, label %if.end47

if.then43:                                        ; preds = %if.end34
  %54 = load float, ptr %f, align 4
  %55 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %x44 = getelementptr inbounds %struct.anon.2, ptr %55, i32 0, i32 0
  store float %54, ptr %x44, align 16
  %56 = load i32, ptr %ie, align 4
  %57 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx45 = getelementptr inbounds %struct.b3Int4, ptr %57, i64 0
  %58 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx45, i32 0, i32 0
  %x46 = getelementptr inbounds %struct.anon, ptr %58, i32 0, i32 0
  store i32 %56, ptr %x46, align 16
  br label %if.end47

if.end47:                                         ; preds = %if.then43, %if.end34
  %call49 = call { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %u)
  %coerce.dive50 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp48, i32 0, i32 0
  %coerce.dive51 = getelementptr inbounds %union.anon.1, ptr %coerce.dive50, i32 0, i32 0
  %59 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive51, i32 0, i32 0
  %60 = extractvalue { <2 x float>, <2 x float> } %call49, 0
  store <2 x float> %60, ptr %59, align 16
  %61 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive51, i32 0, i32 1
  %62 = extractvalue { <2 x float>, <2 x float> } %call49, 1
  store <2 x float> %62, ptr %61, align 8
  %call52 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp48, ptr noundef nonnull align 16 dereferenceable(16) %r)
  store float %call52, ptr %f, align 4
  %63 = load float, ptr %f, align 4
  %64 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %y53 = getelementptr inbounds %struct.anon.2, ptr %64, i32 0, i32 1
  %65 = load float, ptr %y53, align 4
  %cmp54 = fcmp olt float %63, %65
  br i1 %cmp54, label %if.then55, label %if.end59

if.then55:                                        ; preds = %if.end47
  %66 = load float, ptr %f, align 4
  %67 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %y56 = getelementptr inbounds %struct.anon.2, ptr %67, i32 0, i32 1
  store float %66, ptr %y56, align 4
  %68 = load i32, ptr %ie, align 4
  %69 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx57 = getelementptr inbounds %struct.b3Int4, ptr %69, i64 0
  %70 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx57, i32 0, i32 0
  %y58 = getelementptr inbounds %struct.anon, ptr %70, i32 0, i32 1
  store i32 %68, ptr %y58, align 4
  br label %if.end59

if.end59:                                         ; preds = %if.then55, %if.end47
  %call60 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %v, ptr noundef nonnull align 16 dereferenceable(16) %r)
  store float %call60, ptr %f, align 4
  %71 = load float, ptr %f, align 4
  %72 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %z61 = getelementptr inbounds %struct.anon.2, ptr %72, i32 0, i32 2
  %73 = load float, ptr %z61, align 8
  %cmp62 = fcmp olt float %71, %73
  br i1 %cmp62, label %if.then63, label %if.end67

if.then63:                                        ; preds = %if.end59
  %74 = load float, ptr %f, align 4
  %75 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %z64 = getelementptr inbounds %struct.anon.2, ptr %75, i32 0, i32 2
  store float %74, ptr %z64, align 8
  %76 = load i32, ptr %ie, align 4
  %77 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx65 = getelementptr inbounds %struct.b3Int4, ptr %77, i64 0
  %78 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx65, i32 0, i32 0
  %z66 = getelementptr inbounds %struct.anon, ptr %78, i32 0, i32 2
  store i32 %76, ptr %z66, align 8
  br label %if.end67

if.end67:                                         ; preds = %if.then63, %if.end59
  %call69 = call { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %v)
  %coerce.dive70 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp68, i32 0, i32 0
  %coerce.dive71 = getelementptr inbounds %union.anon.1, ptr %coerce.dive70, i32 0, i32 0
  %79 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive71, i32 0, i32 0
  %80 = extractvalue { <2 x float>, <2 x float> } %call69, 0
  store <2 x float> %80, ptr %79, align 16
  %81 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive71, i32 0, i32 1
  %82 = extractvalue { <2 x float>, <2 x float> } %call69, 1
  store <2 x float> %82, ptr %81, align 8
  %call72 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp68, ptr noundef nonnull align 16 dereferenceable(16) %r)
  store float %call72, ptr %f, align 4
  %83 = load float, ptr %f, align 4
  %84 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %w73 = getelementptr inbounds %struct.anon.2, ptr %84, i32 0, i32 3
  %85 = load float, ptr %w73, align 4
  %cmp74 = fcmp olt float %83, %85
  br i1 %cmp74, label %if.then75, label %if.end79

if.then75:                                        ; preds = %if.end67
  %86 = load float, ptr %f, align 4
  %87 = getelementptr inbounds %class.b3Vector3, ptr %maxDots, i32 0, i32 0
  %w76 = getelementptr inbounds %struct.anon.2, ptr %87, i32 0, i32 3
  store float %86, ptr %w76, align 4
  %88 = load i32, ptr %ie, align 4
  %89 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx77 = getelementptr inbounds %struct.b3Int4, ptr %89, i64 0
  %90 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx77, i32 0, i32 0
  %w78 = getelementptr inbounds %struct.anon, ptr %90, i32 0, i32 3
  store i32 %88, ptr %w78, align 4
  br label %if.end79

if.end79:                                         ; preds = %if.then75, %if.end67
  br label %for.inc80

for.inc80:                                        ; preds = %if.end79
  %91 = load i32, ptr %ie, align 4
  %inc81 = add nsw i32 %91, 1
  store i32 %inc81, ptr %ie, align 4
  br label %for.cond23, !llvm.loop !36

for.end82:                                        ; preds = %for.cond23
  %92 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx83 = getelementptr inbounds %struct.b3Int4, ptr %92, i64 0
  %93 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx83, i32 0, i32 0
  %x84 = getelementptr inbounds %struct.anon, ptr %93, i32 0, i32 0
  %94 = load i32, ptr %x84, align 16
  %95 = load i32, ptr %minIndex, align 4
  %cmp85 = icmp ne i32 %94, %95
  br i1 %cmp85, label %land.lhs.true, label %if.end100

land.lhs.true:                                    ; preds = %for.end82
  %96 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx86 = getelementptr inbounds %struct.b3Int4, ptr %96, i64 0
  %97 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx86, i32 0, i32 0
  %y87 = getelementptr inbounds %struct.anon, ptr %97, i32 0, i32 1
  %98 = load i32, ptr %y87, align 4
  %99 = load i32, ptr %minIndex, align 4
  %cmp88 = icmp ne i32 %98, %99
  br i1 %cmp88, label %land.lhs.true89, label %if.end100

land.lhs.true89:                                  ; preds = %land.lhs.true
  %100 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx90 = getelementptr inbounds %struct.b3Int4, ptr %100, i64 0
  %101 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx90, i32 0, i32 0
  %z91 = getelementptr inbounds %struct.anon, ptr %101, i32 0, i32 2
  %102 = load i32, ptr %z91, align 8
  %103 = load i32, ptr %minIndex, align 4
  %cmp92 = icmp ne i32 %102, %103
  br i1 %cmp92, label %land.lhs.true93, label %if.end100

land.lhs.true93:                                  ; preds = %land.lhs.true89
  %104 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx94 = getelementptr inbounds %struct.b3Int4, ptr %104, i64 0
  %105 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx94, i32 0, i32 0
  %w95 = getelementptr inbounds %struct.anon, ptr %105, i32 0, i32 3
  %106 = load i32, ptr %w95, align 4
  %107 = load i32, ptr %minIndex, align 4
  %cmp96 = icmp ne i32 %106, %107
  br i1 %cmp96, label %if.then97, label %if.end100

if.then97:                                        ; preds = %land.lhs.true93
  %108 = load i32, ptr %minIndex, align 4
  %109 = load ptr, ptr %contactIdx.addr, align 8
  %arrayidx98 = getelementptr inbounds %struct.b3Int4, ptr %109, i64 0
  %110 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx98, i32 0, i32 0
  %x99 = getelementptr inbounds %struct.anon, ptr %110, i32 0, i32 0
  store i32 %108, ptr %x99, align 16
  br label %if.end100

if.end100:                                        ; preds = %if.then97, %land.lhs.true93, %land.lhs.true89, %land.lhs.true, %for.end82
  store i32 4, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end100, %if.then2, %if.then
  %111 = load i32, ptr %retval, align 4
  ret i32 %111
}

; Function Attrs: mustprogress uwtable
define dso_local noundef i32 @_Z18clipHullHullSingleiiRK9b3Vector3RK12b3QuaternionS1_S4_iiPK20b3AlignedObjectArrayI15b3RigidBodyDataEPS5_I10b3Contact4ERiRKS5_I22b3ConvexPolyhedronDataESH_RKS5_IS_ESK_RKS5_I9b3GpuFaceERKS5_IiESK_SK_SO_SR_RKS5_I12b3CollidableESV_S1_i(i32 noundef %bodyIndexA, i32 noundef %bodyIndexB, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, i32 noundef %collidableIndexA, i32 noundef %collidableIndexB, ptr noundef %bodyBuf, ptr noundef %globalContactOut, ptr noundef nonnull align 4 dereferenceable(4) %nContacts, ptr noundef nonnull align 8 dereferenceable(25) %hostConvexDataA, ptr noundef nonnull align 8 dereferenceable(25) %hostConvexDataB, ptr noundef nonnull align 8 dereferenceable(25) %verticesA, ptr noundef nonnull align 8 dereferenceable(25) %uniqueEdgesA, ptr noundef nonnull align 8 dereferenceable(25) %facesA, ptr noundef nonnull align 8 dereferenceable(25) %indicesA, ptr noundef nonnull align 8 dereferenceable(25) %verticesB, ptr noundef nonnull align 8 dereferenceable(25) %uniqueEdgesB, ptr noundef nonnull align 8 dereferenceable(25) %facesB, ptr noundef nonnull align 8 dereferenceable(25) %indicesB, ptr noundef nonnull align 8 dereferenceable(25) %hostCollidablesA, ptr noundef nonnull align 8 dereferenceable(25) %hostCollidablesB, ptr noundef nonnull align 16 dereferenceable(16) %sepNormalWorldSpace, i32 noundef %maxContactCapacity) #2 personality ptr @__gxx_personality_v0 {
entry:
  %bodyIndexA.addr = alloca i32, align 4
  %bodyIndexB.addr = alloca i32, align 4
  %posA.addr = alloca ptr, align 8
  %ornA.addr = alloca ptr, align 8
  %posB.addr = alloca ptr, align 8
  %ornB.addr = alloca ptr, align 8
  %collidableIndexA.addr = alloca i32, align 4
  %collidableIndexB.addr = alloca i32, align 4
  %bodyBuf.addr = alloca ptr, align 8
  %globalContactOut.addr = alloca ptr, align 8
  %nContacts.addr = alloca ptr, align 8
  %hostConvexDataA.addr = alloca ptr, align 8
  %hostConvexDataB.addr = alloca ptr, align 8
  %verticesA.addr = alloca ptr, align 8
  %uniqueEdgesA.addr = alloca ptr, align 8
  %facesA.addr = alloca ptr, align 8
  %indicesA.addr = alloca ptr, align 8
  %verticesB.addr = alloca ptr, align 8
  %uniqueEdgesB.addr = alloca ptr, align 8
  %facesB.addr = alloca ptr, align 8
  %indicesB.addr = alloca ptr, align 8
  %hostCollidablesA.addr = alloca ptr, align 8
  %hostCollidablesB.addr = alloca ptr, align 8
  %sepNormalWorldSpace.addr = alloca ptr, align 8
  %maxContactCapacity.addr = alloca i32, align 4
  %contactIndex = alloca i32, align 4
  %hullA = alloca %struct.b3ConvexPolyhedronData, align 16
  %hullB = alloca %struct.b3ConvexPolyhedronData, align 16
  %colA = alloca %struct.b3Collidable, align 4
  %colB = alloca %struct.b3Collidable, align 4
  %contactsOut = alloca [1024 x %class.b3Vector3], align 16
  %localContactCapacity = alloca i32, align 4
  %worldVertsB1 = alloca [1024 x %class.b3Vector3], align 16
  %worldVertsB2 = alloca [1024 x %class.b3Vector3], align 16
  %capacityWorldVerts = alloca i32, align 4
  %hostNormal = alloca %class.b3Vector3, align 16
  %shapeA = alloca i32, align 4
  %shapeB = alloca i32, align 4
  %minDist = alloca float, align 4
  %maxDist = alloca float, align 4
  %trA = alloca %class.b3Transform, align 16
  %trB = alloca %class.b3Transform, align 16
  %ref.tmp = alloca %class.b3Vector3, align 16
  %ref.tmp14 = alloca %class.b3Quaternion, align 16
  %ref.tmp18 = alloca %class.b3Vector3, align 16
  %ref.tmp25 = alloca %class.b3Quaternion, align 16
  %trAorn = alloca %class.b3Quaternion, align 16
  %trBorn = alloca %class.b3Quaternion, align 16
  %numContactsOut = alloca i32, align 4
  %__profile = alloca %class.b3ProfileZone, align 1
  %normalOnSurfaceB = alloca %class.b3Vector3, align 16
  %contactIdx = alloca %struct.b3Int4, align 16
  %numPoints = alloca i32, align 4
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %ref.tmp53 = alloca %struct.b3Contact4, align 16
  %contact = alloca ptr, align 8
  %p = alloca i32, align 4
  store i32 %bodyIndexA, ptr %bodyIndexA.addr, align 4
  store i32 %bodyIndexB, ptr %bodyIndexB.addr, align 4
  store ptr %posA, ptr %posA.addr, align 8
  store ptr %ornA, ptr %ornA.addr, align 8
  store ptr %posB, ptr %posB.addr, align 8
  store ptr %ornB, ptr %ornB.addr, align 8
  store i32 %collidableIndexA, ptr %collidableIndexA.addr, align 4
  store i32 %collidableIndexB, ptr %collidableIndexB.addr, align 4
  store ptr %bodyBuf, ptr %bodyBuf.addr, align 8
  store ptr %globalContactOut, ptr %globalContactOut.addr, align 8
  store ptr %nContacts, ptr %nContacts.addr, align 8
  store ptr %hostConvexDataA, ptr %hostConvexDataA.addr, align 8
  store ptr %hostConvexDataB, ptr %hostConvexDataB.addr, align 8
  store ptr %verticesA, ptr %verticesA.addr, align 8
  store ptr %uniqueEdgesA, ptr %uniqueEdgesA.addr, align 8
  store ptr %facesA, ptr %facesA.addr, align 8
  store ptr %indicesA, ptr %indicesA.addr, align 8
  store ptr %verticesB, ptr %verticesB.addr, align 8
  store ptr %uniqueEdgesB, ptr %uniqueEdgesB.addr, align 8
  store ptr %facesB, ptr %facesB.addr, align 8
  store ptr %indicesB, ptr %indicesB.addr, align 8
  store ptr %hostCollidablesA, ptr %hostCollidablesA.addr, align 8
  store ptr %hostCollidablesB, ptr %hostCollidablesB.addr, align 8
  store ptr %sepNormalWorldSpace, ptr %sepNormalWorldSpace.addr, align 8
  store i32 %maxContactCapacity, ptr %maxContactCapacity.addr, align 4
  store i32 -1, ptr %contactIndex, align 4
  %0 = load ptr, ptr %hostCollidablesA.addr, align 8
  %1 = load i32, ptr %collidableIndexA.addr, align 4
  %call = call noundef nonnull align 4 dereferenceable(16) ptr @_ZNK20b3AlignedObjectArrayI12b3CollidableEixEi(ptr noundef nonnull align 8 dereferenceable(25) %0, i32 noundef %1)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %colA, ptr align 4 %call, i64 16, i1 false)
  %2 = load ptr, ptr %hostConvexDataA.addr, align 8
  %3 = getelementptr inbounds %struct.b3Collidable, ptr %colA, i32 0, i32 3
  %4 = load i32, ptr %3, align 4
  %call1 = call noundef nonnull align 16 dereferenceable(96) ptr @_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %2, i32 noundef %4)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %hullA, ptr align 16 %call1, i64 96, i1 false)
  %5 = load ptr, ptr %hostCollidablesB.addr, align 8
  %6 = load i32, ptr %collidableIndexB.addr, align 4
  %call2 = call noundef nonnull align 4 dereferenceable(16) ptr @_ZNK20b3AlignedObjectArrayI12b3CollidableEixEi(ptr noundef nonnull align 8 dereferenceable(25) %5, i32 noundef %6)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %colB, ptr align 4 %call2, i64 16, i1 false)
  %7 = load ptr, ptr %hostConvexDataB.addr, align 8
  %8 = getelementptr inbounds %struct.b3Collidable, ptr %colB, i32 0, i32 3
  %9 = load i32, ptr %8, align 4
  %call3 = call noundef nonnull align 16 dereferenceable(96) ptr @_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %7, i32 noundef %9)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %hullB, ptr align 16 %call3, i64 96, i1 false)
  store i32 1024, ptr %localContactCapacity, align 4
  store i32 1024, ptr %capacityWorldVerts, align 4
  %10 = load ptr, ptr %sepNormalWorldSpace.addr, align 8
  %11 = getelementptr inbounds %class.b3Vector3, ptr %10, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon.2, ptr %11, i32 0, i32 0
  %12 = load float, ptr %x, align 16
  %13 = load ptr, ptr %sepNormalWorldSpace.addr, align 8
  %14 = getelementptr inbounds %class.b3Vector3, ptr %13, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon.2, ptr %14, i32 0, i32 1
  %15 = load float, ptr %y, align 4
  %16 = load ptr, ptr %sepNormalWorldSpace.addr, align 8
  %17 = getelementptr inbounds %class.b3Vector3, ptr %16, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon.2, ptr %17, i32 0, i32 2
  %18 = load float, ptr %z, align 8
  %call4 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef %12, float noundef %15, float noundef %18, float noundef 0.000000e+00)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %hostNormal, i32 0, i32 0
  %coerce.dive5 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %19 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive5, i32 0, i32 0
  %20 = extractvalue { <2 x float>, <2 x float> } %call4, 0
  store <2 x float> %20, ptr %19, align 16
  %21 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive5, i32 0, i32 1
  %22 = extractvalue { <2 x float>, <2 x float> } %call4, 1
  store <2 x float> %22, ptr %21, align 8
  %23 = load ptr, ptr %hostCollidablesA.addr, align 8
  %24 = load i32, ptr %collidableIndexA.addr, align 4
  %call6 = call noundef nonnull align 4 dereferenceable(16) ptr @_ZNK20b3AlignedObjectArrayI12b3CollidableEixEi(ptr noundef nonnull align 8 dereferenceable(25) %23, i32 noundef %24)
  %25 = getelementptr inbounds %struct.b3Collidable, ptr %call6, i32 0, i32 3
  %26 = load i32, ptr %25, align 4
  store i32 %26, ptr %shapeA, align 4
  %27 = load ptr, ptr %hostCollidablesB.addr, align 8
  %28 = load i32, ptr %collidableIndexB.addr, align 4
  %call7 = call noundef nonnull align 4 dereferenceable(16) ptr @_ZNK20b3AlignedObjectArrayI12b3CollidableEixEi(ptr noundef nonnull align 8 dereferenceable(25) %27, i32 noundef %28)
  %29 = getelementptr inbounds %struct.b3Collidable, ptr %call7, i32 0, i32 3
  %30 = load i32, ptr %29, align 4
  store i32 %30, ptr %shapeB, align 4
  store float -1.000000e+00, ptr %minDist, align 4
  store float 0.000000e+00, ptr %maxDist, align 4
  call void @_ZN11b3TransformC2Ev(ptr noundef nonnull align 16 dereferenceable(64) %trA)
  call void @_ZN11b3TransformC2Ev(ptr noundef nonnull align 16 dereferenceable(64) %trB)
  %31 = load ptr, ptr %posA.addr, align 8
  %32 = getelementptr inbounds %class.b3Vector3, ptr %31, i32 0, i32 0
  %x8 = getelementptr inbounds %struct.anon.2, ptr %32, i32 0, i32 0
  %33 = load float, ptr %x8, align 16
  %34 = load ptr, ptr %posA.addr, align 8
  %35 = getelementptr inbounds %class.b3Vector3, ptr %34, i32 0, i32 0
  %y9 = getelementptr inbounds %struct.anon.2, ptr %35, i32 0, i32 1
  %36 = load float, ptr %y9, align 4
  %37 = load ptr, ptr %posA.addr, align 8
  %38 = getelementptr inbounds %class.b3Vector3, ptr %37, i32 0, i32 0
  %z10 = getelementptr inbounds %struct.anon.2, ptr %38, i32 0, i32 2
  %39 = load float, ptr %z10, align 8
  %call11 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef %33, float noundef %36, float noundef %39)
  %coerce.dive12 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive13 = getelementptr inbounds %union.anon.1, ptr %coerce.dive12, i32 0, i32 0
  %40 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive13, i32 0, i32 0
  %41 = extractvalue { <2 x float>, <2 x float> } %call11, 0
  store <2 x float> %41, ptr %40, align 16
  %42 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive13, i32 0, i32 1
  %43 = extractvalue { <2 x float>, <2 x float> } %call11, 1
  store <2 x float> %43, ptr %42, align 8
  call void @_ZN11b3Transform9setOriginERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %trA, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp)
  %44 = load ptr, ptr %ornA.addr, align 8
  %45 = getelementptr inbounds %class.b3QuadWord, ptr %44, i32 0, i32 0
  %x15 = getelementptr inbounds %struct.anon.4, ptr %45, i32 0, i32 0
  %46 = load ptr, ptr %ornA.addr, align 8
  %47 = getelementptr inbounds %class.b3QuadWord, ptr %46, i32 0, i32 0
  %y16 = getelementptr inbounds %struct.anon.4, ptr %47, i32 0, i32 1
  %48 = load ptr, ptr %ornA.addr, align 8
  %49 = getelementptr inbounds %class.b3QuadWord, ptr %48, i32 0, i32 0
  %z17 = getelementptr inbounds %struct.anon.4, ptr %49, i32 0, i32 2
  %50 = load ptr, ptr %ornA.addr, align 8
  %51 = getelementptr inbounds %class.b3QuadWord, ptr %50, i32 0, i32 0
  %w = getelementptr inbounds %struct.anon.4, ptr %51, i32 0, i32 3
  call void @_ZN12b3QuaternionC2ERKfS1_S1_S1_(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp14, ptr noundef nonnull align 4 dereferenceable(4) %x15, ptr noundef nonnull align 4 dereferenceable(4) %y16, ptr noundef nonnull align 4 dereferenceable(4) %z17, ptr noundef nonnull align 4 dereferenceable(4) %w)
  call void @_ZN11b3Transform11setRotationERK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(64) %trA, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp14)
  %52 = load ptr, ptr %posB.addr, align 8
  %53 = getelementptr inbounds %class.b3Vector3, ptr %52, i32 0, i32 0
  %x19 = getelementptr inbounds %struct.anon.2, ptr %53, i32 0, i32 0
  %54 = load float, ptr %x19, align 16
  %55 = load ptr, ptr %posB.addr, align 8
  %56 = getelementptr inbounds %class.b3Vector3, ptr %55, i32 0, i32 0
  %y20 = getelementptr inbounds %struct.anon.2, ptr %56, i32 0, i32 1
  %57 = load float, ptr %y20, align 4
  %58 = load ptr, ptr %posB.addr, align 8
  %59 = getelementptr inbounds %class.b3Vector3, ptr %58, i32 0, i32 0
  %z21 = getelementptr inbounds %struct.anon.2, ptr %59, i32 0, i32 2
  %60 = load float, ptr %z21, align 8
  %call22 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef %54, float noundef %57, float noundef %60)
  %coerce.dive23 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp18, i32 0, i32 0
  %coerce.dive24 = getelementptr inbounds %union.anon.1, ptr %coerce.dive23, i32 0, i32 0
  %61 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive24, i32 0, i32 0
  %62 = extractvalue { <2 x float>, <2 x float> } %call22, 0
  store <2 x float> %62, ptr %61, align 16
  %63 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive24, i32 0, i32 1
  %64 = extractvalue { <2 x float>, <2 x float> } %call22, 1
  store <2 x float> %64, ptr %63, align 8
  call void @_ZN11b3Transform9setOriginERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %trB, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp18)
  %65 = load ptr, ptr %ornB.addr, align 8
  %66 = getelementptr inbounds %class.b3QuadWord, ptr %65, i32 0, i32 0
  %x26 = getelementptr inbounds %struct.anon.4, ptr %66, i32 0, i32 0
  %67 = load ptr, ptr %ornB.addr, align 8
  %68 = getelementptr inbounds %class.b3QuadWord, ptr %67, i32 0, i32 0
  %y27 = getelementptr inbounds %struct.anon.4, ptr %68, i32 0, i32 1
  %69 = load ptr, ptr %ornB.addr, align 8
  %70 = getelementptr inbounds %class.b3QuadWord, ptr %69, i32 0, i32 0
  %z28 = getelementptr inbounds %struct.anon.4, ptr %70, i32 0, i32 2
  %71 = load ptr, ptr %ornB.addr, align 8
  %72 = getelementptr inbounds %class.b3QuadWord, ptr %71, i32 0, i32 0
  %w29 = getelementptr inbounds %struct.anon.4, ptr %72, i32 0, i32 3
  call void @_ZN12b3QuaternionC2ERKfS1_S1_S1_(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp25, ptr noundef nonnull align 4 dereferenceable(4) %x26, ptr noundef nonnull align 4 dereferenceable(4) %y27, ptr noundef nonnull align 4 dereferenceable(4) %z28, ptr noundef nonnull align 4 dereferenceable(4) %w29)
  call void @_ZN11b3Transform11setRotationERK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(64) %trB, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp25)
  %call30 = call { <2 x float>, <2 x float> } @_ZNK11b3Transform11getRotationEv(ptr noundef nonnull align 16 dereferenceable(64) %trA)
  %coerce.dive31 = getelementptr inbounds %class.b3Quaternion, ptr %trAorn, i32 0, i32 0
  %coerce.dive32 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive31, i32 0, i32 0
  %coerce.dive33 = getelementptr inbounds %union.anon.3, ptr %coerce.dive32, i32 0, i32 0
  %73 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive33, i32 0, i32 0
  %74 = extractvalue { <2 x float>, <2 x float> } %call30, 0
  store <2 x float> %74, ptr %73, align 16
  %75 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive33, i32 0, i32 1
  %76 = extractvalue { <2 x float>, <2 x float> } %call30, 1
  store <2 x float> %76, ptr %75, align 8
  %call34 = call { <2 x float>, <2 x float> } @_ZNK11b3Transform11getRotationEv(ptr noundef nonnull align 16 dereferenceable(64) %trB)
  %coerce.dive35 = getelementptr inbounds %class.b3Quaternion, ptr %trBorn, i32 0, i32 0
  %coerce.dive36 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive35, i32 0, i32 0
  %coerce.dive37 = getelementptr inbounds %union.anon.3, ptr %coerce.dive36, i32 0, i32 0
  %77 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive37, i32 0, i32 0
  %78 = extractvalue { <2 x float>, <2 x float> } %call34, 0
  store <2 x float> %78, ptr %77, align 16
  %79 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive37, i32 0, i32 1
  %80 = extractvalue { <2 x float>, <2 x float> } %call34, 1
  store <2 x float> %80, ptr %79, align 8
  %81 = load ptr, ptr %hostConvexDataA.addr, align 8
  %82 = load i32, ptr %shapeA, align 4
  %call38 = call noundef nonnull align 16 dereferenceable(96) ptr @_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %81, i32 noundef %82)
  %83 = load ptr, ptr %hostConvexDataB.addr, align 8
  %84 = load i32, ptr %shapeB, align 4
  %call39 = call noundef nonnull align 16 dereferenceable(96) ptr @_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %83, i32 noundef %84)
  %call40 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN11b3Transform9getOriginEv(ptr noundef nonnull align 16 dereferenceable(64) %trA)
  %call41 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN11b3Transform9getOriginEv(ptr noundef nonnull align 16 dereferenceable(64) %trB)
  %arraydecay = getelementptr inbounds [1024 x %class.b3Vector3], ptr %worldVertsB1, i64 0, i64 0
  %arraydecay42 = getelementptr inbounds [1024 x %class.b3Vector3], ptr %worldVertsB2, i64 0, i64 0
  %85 = load i32, ptr %capacityWorldVerts, align 4
  %86 = load float, ptr %minDist, align 4
  %87 = load float, ptr %maxDist, align 4
  %88 = load ptr, ptr %verticesA.addr, align 8
  %89 = load ptr, ptr %facesA.addr, align 8
  %90 = load ptr, ptr %indicesA.addr, align 8
  %91 = load ptr, ptr %verticesB.addr, align 8
  %92 = load ptr, ptr %facesB.addr, align 8
  %93 = load ptr, ptr %indicesB.addr, align 8
  %arraydecay43 = getelementptr inbounds [1024 x %class.b3Vector3], ptr %contactsOut, i64 0, i64 0
  %94 = load i32, ptr %localContactCapacity, align 4
  %call44 = call noundef i32 @_ZL19clipHullAgainstHullRK9b3Vector3RK22b3ConvexPolyhedronDataS4_S1_RK12b3QuaternionS1_S7_PS_S8_iffRK20b3AlignedObjectArrayIS_ERKS9_I9b3GpuFaceERKS9_IiESC_SG_SJ_S8_i(ptr noundef nonnull align 16 dereferenceable(16) %hostNormal, ptr noundef nonnull align 16 dereferenceable(96) %call38, ptr noundef nonnull align 16 dereferenceable(96) %call39, ptr noundef nonnull align 16 dereferenceable(16) %call40, ptr noundef nonnull align 16 dereferenceable(16) %trAorn, ptr noundef nonnull align 16 dereferenceable(16) %call41, ptr noundef nonnull align 16 dereferenceable(16) %trBorn, ptr noundef %arraydecay, ptr noundef %arraydecay42, i32 noundef %85, float noundef %86, float noundef %87, ptr noundef nonnull align 8 dereferenceable(25) %88, ptr noundef nonnull align 8 dereferenceable(25) %89, ptr noundef nonnull align 8 dereferenceable(25) %90, ptr noundef nonnull align 8 dereferenceable(25) %91, ptr noundef nonnull align 8 dereferenceable(25) %92, ptr noundef nonnull align 8 dereferenceable(25) %93, ptr noundef %arraydecay43, i32 noundef %94)
  store i32 %call44, ptr %numContactsOut, align 4
  %95 = load i32, ptr %numContactsOut, align 4
  %cmp = icmp sgt i32 %95, 0
  br i1 %cmp, label %if.then, label %if.end80

if.then:                                          ; preds = %entry
  call void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %__profile, ptr noundef @.str.33)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %normalOnSurfaceB, ptr align 16 %hostNormal, i64 16, i1 false)
  %96 = getelementptr inbounds %struct.b3Int4, ptr %contactIdx, i32 0, i32 0
  %x45 = getelementptr inbounds %struct.anon, ptr %96, i32 0, i32 0
  store i32 0, ptr %x45, align 16
  %97 = getelementptr inbounds %struct.b3Int4, ptr %contactIdx, i32 0, i32 0
  %y46 = getelementptr inbounds %struct.anon, ptr %97, i32 0, i32 1
  store i32 1, ptr %y46, align 4
  %98 = getelementptr inbounds %struct.b3Int4, ptr %contactIdx, i32 0, i32 0
  %z47 = getelementptr inbounds %struct.anon, ptr %98, i32 0, i32 2
  store i32 2, ptr %z47, align 8
  %99 = getelementptr inbounds %struct.b3Int4, ptr %contactIdx, i32 0, i32 0
  %w48 = getelementptr inbounds %struct.anon, ptr %99, i32 0, i32 3
  store i32 3, ptr %w48, align 4
  store i32 0, ptr %numPoints, align 4
  %arraydecay49 = getelementptr inbounds [1024 x %class.b3Vector3], ptr %contactsOut, i64 0, i64 0
  %100 = load i32, ptr %numContactsOut, align 4
  %call50 = invoke noundef i32 @_Z15extractManifoldPK9b3Vector3iRS0_P6b3Int4(ptr noundef %arraydecay49, i32 noundef %100, ptr noundef nonnull align 16 dereferenceable(16) %normalOnSurfaceB, ptr noundef %contactIdx)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %if.then
  store i32 %call50, ptr %numPoints, align 4
  %101 = load ptr, ptr %nContacts.addr, align 8
  %102 = load i32, ptr %101, align 4
  %103 = load i32, ptr %maxContactCapacity.addr, align 4
  %cmp51 = icmp slt i32 %102, %103
  br i1 %cmp51, label %if.then52, label %if.else

if.then52:                                        ; preds = %invoke.cont
  %104 = load ptr, ptr %nContacts.addr, align 8
  %105 = load i32, ptr %104, align 4
  store i32 %105, ptr %contactIndex, align 4
  %106 = load ptr, ptr %globalContactOut.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp53, i8 0, i64 112, i1 false)
  %call55 = invoke noundef nonnull align 16 dereferenceable(112) ptr @_ZN20b3AlignedObjectArrayI10b3Contact4E6expandERKS0_(ptr noundef nonnull align 8 dereferenceable(25) %106, ptr noundef nonnull align 16 dereferenceable(112) %ref.tmp53)
          to label %invoke.cont54 unwind label %lpad

invoke.cont54:                                    ; preds = %if.then52
  %107 = load ptr, ptr %globalContactOut.addr, align 8
  %108 = load ptr, ptr %nContacts.addr, align 8
  %109 = load i32, ptr %108, align 4
  %call57 = invoke noundef nonnull align 16 dereferenceable(112) ptr @_ZN20b3AlignedObjectArrayI10b3Contact4E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %107, i32 noundef %109)
          to label %invoke.cont56 unwind label %lpad

invoke.cont56:                                    ; preds = %invoke.cont54
  store ptr %call57, ptr %contact, align 8
  %110 = load ptr, ptr %contact, align 8
  %m_batchIdx = getelementptr inbounds %struct.b3Contact4Data, ptr %110, i32 0, i32 4
  store i32 0, ptr %m_batchIdx, align 4
  %111 = load ptr, ptr %bodyBuf.addr, align 8
  %112 = load i32, ptr %bodyIndexA.addr, align 4
  %call59 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %111, i32 noundef %112)
          to label %invoke.cont58 unwind label %lpad

invoke.cont58:                                    ; preds = %invoke.cont56
  %m_invMass = getelementptr inbounds %struct.b3RigidBodyData, ptr %call59, i32 0, i32 5
  %113 = load float, ptr %m_invMass, align 4
  %cmp60 = fcmp oeq float %113, 0.000000e+00
  br i1 %cmp60, label %cond.true, label %cond.false

cond.true:                                        ; preds = %invoke.cont58
  %114 = load i32, ptr %bodyIndexA.addr, align 4
  %sub = sub nsw i32 0, %114
  br label %cond.end

cond.false:                                       ; preds = %invoke.cont58
  %115 = load i32, ptr %bodyIndexA.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %sub, %cond.true ], [ %115, %cond.false ]
  %116 = load ptr, ptr %contact, align 8
  %m_bodyAPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %116, i32 0, i32 5
  store i32 %cond, ptr %m_bodyAPtrAndSignBit, align 8
  %117 = load ptr, ptr %bodyBuf.addr, align 8
  %118 = load i32, ptr %bodyIndexB.addr, align 4
  %call62 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %117, i32 noundef %118)
          to label %invoke.cont61 unwind label %lpad

invoke.cont61:                                    ; preds = %cond.end
  %m_invMass63 = getelementptr inbounds %struct.b3RigidBodyData, ptr %call62, i32 0, i32 5
  %119 = load float, ptr %m_invMass63, align 4
  %cmp64 = fcmp oeq float %119, 0.000000e+00
  br i1 %cmp64, label %cond.true65, label %cond.false67

cond.true65:                                      ; preds = %invoke.cont61
  %120 = load i32, ptr %bodyIndexB.addr, align 4
  %sub66 = sub nsw i32 0, %120
  br label %cond.end68

cond.false67:                                     ; preds = %invoke.cont61
  %121 = load i32, ptr %bodyIndexB.addr, align 4
  br label %cond.end68

cond.end68:                                       ; preds = %cond.false67, %cond.true65
  %cond69 = phi i32 [ %sub66, %cond.true65 ], [ %121, %cond.false67 ]
  %122 = load ptr, ptr %contact, align 8
  %m_bodyBPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %122, i32 0, i32 6
  store i32 %cond69, ptr %m_bodyBPtrAndSignBit, align 4
  %123 = load ptr, ptr %contact, align 8
  %m_frictionCoeffCmp = getelementptr inbounds %struct.b3Contact4Data, ptr %123, i32 0, i32 3
  store i16 -19662, ptr %m_frictionCoeffCmp, align 2
  %124 = load ptr, ptr %contact, align 8
  %m_restituitionCoeffCmp = getelementptr inbounds %struct.b3Contact4Data, ptr %124, i32 0, i32 2
  store i16 0, ptr %m_restituitionCoeffCmp, align 16
  store i32 0, ptr %p, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end68
  %125 = load i32, ptr %p, align 4
  %126 = load i32, ptr %numPoints, align 4
  %cmp70 = icmp slt i32 %125, %126
  br i1 %cmp70, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %127 = getelementptr inbounds %struct.b3Int4, ptr %contactIdx, i32 0, i32 0
  %s = getelementptr inbounds %struct.anon.0, ptr %127, i32 0, i32 0
  %128 = load i32, ptr %p, align 4
  %idxprom = sext i32 %128 to i64
  %arrayidx = getelementptr inbounds [4 x i32], ptr %s, i64 0, i64 %idxprom
  %129 = load i32, ptr %arrayidx, align 4
  %idxprom71 = sext i32 %129 to i64
  %arrayidx72 = getelementptr inbounds [1024 x %class.b3Vector3], ptr %contactsOut, i64 0, i64 %idxprom71
  %130 = load ptr, ptr %contact, align 8
  %m_worldPosB = getelementptr inbounds %struct.b3Contact4Data, ptr %130, i32 0, i32 0
  %131 = load i32, ptr %p, align 4
  %idxprom73 = sext i32 %131 to i64
  %arrayidx74 = getelementptr inbounds [4 x %class.b3Vector3], ptr %m_worldPosB, i64 0, i64 %idxprom73
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx74, ptr align 16 %arrayidx72, i64 16, i1 false)
  %132 = load ptr, ptr %contact, align 8
  %m_worldNormalOnB = getelementptr inbounds %struct.b3Contact4Data, ptr %132, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %m_worldNormalOnB, ptr align 16 %normalOnSurfaceB, i64 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %133 = load i32, ptr %p, align 4
  %inc = add nsw i32 %133, 1
  store i32 %inc, ptr %p, align 4
  br label %for.cond, !llvm.loop !37

lpad:                                             ; preds = %invoke.cont78, %do.body, %cond.end, %invoke.cont56, %invoke.cont54, %if.then52, %if.then
  %134 = landingpad { ptr, i32 }
          cleanup
  %135 = extractvalue { ptr, i32 } %134, 0
  store ptr %135, ptr %exn.slot, align 8
  %136 = extractvalue { ptr, i32 } %134, 1
  store i32 %136, ptr %ehselector.slot, align 4
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile) #13
  br label %eh.resume

for.end:                                          ; preds = %for.cond
  %137 = load i32, ptr %numPoints, align 4
  %conv = sitofp i32 %137 to float
  %138 = load ptr, ptr %contact, align 8
  %m_worldNormalOnB75 = getelementptr inbounds %struct.b3Contact4Data, ptr %138, i32 0, i32 1
  %139 = getelementptr inbounds %class.b3Vector3, ptr %m_worldNormalOnB75, i32 0, i32 0
  %w76 = getelementptr inbounds %struct.anon.2, ptr %139, i32 0, i32 3
  store float %conv, ptr %w76, align 4
  %140 = load ptr, ptr %nContacts.addr, align 8
  %141 = load i32, ptr %140, align 4
  %inc77 = add nsw i32 %141, 1
  store i32 %inc77, ptr %140, align 4
  br label %if.end

if.else:                                          ; preds = %invoke.cont
  br label %do.body

do.body:                                          ; preds = %if.else
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.31, i32 noundef 1265)
          to label %invoke.cont78 unwind label %lpad

invoke.cont78:                                    ; preds = %do.body
  %142 = load ptr, ptr %nContacts.addr, align 8
  %143 = load i32, ptr %142, align 4
  %144 = load i32, ptr %maxContactCapacity.addr, align 4
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.34, i32 noundef %143, i32 noundef %144)
          to label %invoke.cont79 unwind label %lpad

invoke.cont79:                                    ; preds = %invoke.cont78
  br label %do.cond

do.cond:                                          ; preds = %invoke.cont79
  br label %do.end

do.end:                                           ; preds = %do.cond
  br label %if.end

if.end:                                           ; preds = %do.end, %for.end
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile) #13
  br label %if.end80

if.end80:                                         ; preds = %if.end, %entry
  %145 = load i32, ptr %contactIndex, align 4
  ret i32 %145

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val81 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val81
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 4 dereferenceable(16) ptr @_ZNK20b3AlignedObjectArrayI12b3CollidableEixEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3Collidable, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(96) ptr @_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN12b3QuaternionC2ERKfS1_S1_S1_(ptr noundef nonnull align 16 dereferenceable(16) %this, ptr noundef nonnull align 4 dereferenceable(4) %_x, ptr noundef nonnull align 4 dereferenceable(4) %_y, ptr noundef nonnull align 4 dereferenceable(4) %_z, ptr noundef nonnull align 4 dereferenceable(4) %_w) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_x.addr = alloca ptr, align 8
  %_y.addr = alloca ptr, align 8
  %_z.addr = alloca ptr, align 8
  %_w.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %_x, ptr %_x.addr, align 8
  store ptr %_y, ptr %_y.addr, align 8
  store ptr %_z, ptr %_z.addr, align 8
  store ptr %_w, ptr %_w.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %_x.addr, align 8
  %1 = load ptr, ptr %_y.addr, align 8
  %2 = load ptr, ptr %_z.addr, align 8
  %3 = load ptr, ptr %_w.addr, align 8
  call void @_ZN10b3QuadWordC2ERKfS1_S1_S1_(ptr noundef nonnull align 16 dereferenceable(16) %this1, ptr noundef nonnull align 4 dereferenceable(4) %0, ptr noundef nonnull align 4 dereferenceable(4) %1, ptr noundef nonnull align 4 dereferenceable(4) %2, ptr noundef nonnull align 4 dereferenceable(4) %3)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_ZNK11b3Transform11getRotationEv(ptr noundef nonnull align 16 dereferenceable(64) %this) #0 comdat align 2 {
entry:
  %retval = alloca %class.b3Quaternion, align 16
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN12b3QuaternionC2Ev(ptr noundef nonnull align 16 dereferenceable(16) %retval)
  %m_basis = getelementptr inbounds %class.b3Transform, ptr %this1, i32 0, i32 0
  call void @_ZNK11b3Matrix3x311getRotationER12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(48) %m_basis, ptr noundef nonnull align 16 dereferenceable(16) %retval)
  %coerce.dive = getelementptr inbounds %class.b3Quaternion, ptr %retval, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %union.anon.3, ptr %coerce.dive2, i32 0, i32 0
  %0 = load { <2 x float>, <2 x float> }, ptr %coerce.dive3, align 16
  ret { <2 x float>, <2 x float> } %0
}

; Function Attrs: mustprogress uwtable
define internal noundef i32 @_ZL19clipHullAgainstHullRK9b3Vector3RK22b3ConvexPolyhedronDataS4_S1_RK12b3QuaternionS1_S7_PS_S8_iffRK20b3AlignedObjectArrayIS_ERKS9_I9b3GpuFaceERKS9_IiESC_SG_SJ_S8_i(ptr noundef nonnull align 16 dereferenceable(16) %separatingNormal, ptr noundef nonnull align 16 dereferenceable(96) %hullA, ptr noundef nonnull align 16 dereferenceable(96) %hullB, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef %worldVertsB1, ptr noundef %worldVertsB2, i32 noundef %capacityWorldVerts, float noundef %minDist, float noundef %maxDist, ptr noundef nonnull align 8 dereferenceable(25) %verticesA, ptr noundef nonnull align 8 dereferenceable(25) %facesA, ptr noundef nonnull align 8 dereferenceable(25) %indicesA, ptr noundef nonnull align 8 dereferenceable(25) %verticesB, ptr noundef nonnull align 8 dereferenceable(25) %facesB, ptr noundef nonnull align 8 dereferenceable(25) %indicesB, ptr noundef %contactsOut, i32 noundef %contactCapacity) #2 personality ptr @__gxx_personality_v0 {
entry:
  %separatingNormal.addr = alloca ptr, align 8
  %hullA.addr = alloca ptr, align 8
  %hullB.addr = alloca ptr, align 8
  %posA.addr = alloca ptr, align 8
  %ornA.addr = alloca ptr, align 8
  %posB.addr = alloca ptr, align 8
  %ornB.addr = alloca ptr, align 8
  %worldVertsB1.addr = alloca ptr, align 8
  %worldVertsB2.addr = alloca ptr, align 8
  %capacityWorldVerts.addr = alloca i32, align 4
  %minDist.addr = alloca float, align 4
  %maxDist.addr = alloca float, align 4
  %verticesA.addr = alloca ptr, align 8
  %facesA.addr = alloca ptr, align 8
  %indicesA.addr = alloca ptr, align 8
  %verticesB.addr = alloca ptr, align 8
  %facesB.addr = alloca ptr, align 8
  %indicesB.addr = alloca ptr, align 8
  %contactsOut.addr = alloca ptr, align 8
  %contactCapacity.addr = alloca i32, align 4
  %numContactsOut = alloca i32, align 4
  %numWorldVertsB1 = alloca i32, align 4
  %__profile = alloca %class.b3ProfileZone, align 1
  %closestFaceB = alloca i32, align 4
  %dmax = alloca float, align 4
  %face = alloca i32, align 4
  %Normal = alloca %class.b3Vector3, align 16
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %WorldNormal = alloca %class.b3Vector3, align 16
  %d = alloca float, align 4
  %polyB = alloca ptr, align 8
  %numVertices = alloca i32, align 4
  %e0 = alloca i32, align 4
  %b = alloca ptr, align 8
  %ref.tmp = alloca %class.b3Vector3, align 16
  store ptr %separatingNormal, ptr %separatingNormal.addr, align 8
  store ptr %hullA, ptr %hullA.addr, align 8
  store ptr %hullB, ptr %hullB.addr, align 8
  store ptr %posA, ptr %posA.addr, align 8
  store ptr %ornA, ptr %ornA.addr, align 8
  store ptr %posB, ptr %posB.addr, align 8
  store ptr %ornB, ptr %ornB.addr, align 8
  store ptr %worldVertsB1, ptr %worldVertsB1.addr, align 8
  store ptr %worldVertsB2, ptr %worldVertsB2.addr, align 8
  store i32 %capacityWorldVerts, ptr %capacityWorldVerts.addr, align 4
  store float %minDist, ptr %minDist.addr, align 4
  store float %maxDist, ptr %maxDist.addr, align 4
  store ptr %verticesA, ptr %verticesA.addr, align 8
  store ptr %facesA, ptr %facesA.addr, align 8
  store ptr %indicesA, ptr %indicesA.addr, align 8
  store ptr %verticesB, ptr %verticesB.addr, align 8
  store ptr %facesB, ptr %facesB.addr, align 8
  store ptr %indicesB, ptr %indicesB.addr, align 8
  store ptr %contactsOut, ptr %contactsOut.addr, align 8
  store i32 %contactCapacity, ptr %contactCapacity.addr, align 4
  store i32 0, ptr %numContactsOut, align 4
  store i32 0, ptr %numWorldVertsB1, align 4
  call void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %__profile, ptr noundef @.str.72)
  store i32 -1, ptr %closestFaceB, align 4
  store float 0xC7EFFFFFE0000000, ptr %dmax, align 4
  %0 = load ptr, ptr %hullB.addr, align 8
  %m_numFaces = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %0, i32 0, i32 6
  %1 = load i32, ptr %m_numFaces, align 8
  %cmp = icmp ne i32 %1, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  store i32 0, ptr %face, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %2 = load i32, ptr %face, align 4
  %3 = load ptr, ptr %hullB.addr, align 8
  %m_numFaces1 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %3, i32 0, i32 6
  %4 = load i32, ptr %m_numFaces1, align 8
  %cmp2 = icmp slt i32 %2, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %facesB.addr, align 8
  %6 = load ptr, ptr %hullB.addr, align 8
  %m_faceOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %6, i32 0, i32 5
  %7 = load i32, ptr %m_faceOffset, align 4
  %8 = load i32, ptr %face, align 4
  %add = add nsw i32 %7, %8
  %call = invoke noundef nonnull align 16 dereferenceable(32) ptr @_ZNK20b3AlignedObjectArrayI9b3GpuFaceEixEi(ptr noundef nonnull align 8 dereferenceable(25) %5, i32 noundef %add)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %for.body
  %m_plane = getelementptr inbounds %struct.b3GpuFace, ptr %call, i32 0, i32 0
  %9 = getelementptr inbounds %class.b3Vector3, ptr %m_plane, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon.2, ptr %9, i32 0, i32 0
  %10 = load float, ptr %x, align 16
  %11 = load ptr, ptr %facesB.addr, align 8
  %12 = load ptr, ptr %hullB.addr, align 8
  %m_faceOffset3 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %12, i32 0, i32 5
  %13 = load i32, ptr %m_faceOffset3, align 4
  %14 = load i32, ptr %face, align 4
  %add4 = add nsw i32 %13, %14
  %call6 = invoke noundef nonnull align 16 dereferenceable(32) ptr @_ZNK20b3AlignedObjectArrayI9b3GpuFaceEixEi(ptr noundef nonnull align 8 dereferenceable(25) %11, i32 noundef %add4)
          to label %invoke.cont5 unwind label %lpad

invoke.cont5:                                     ; preds = %invoke.cont
  %m_plane7 = getelementptr inbounds %struct.b3GpuFace, ptr %call6, i32 0, i32 0
  %15 = getelementptr inbounds %class.b3Vector3, ptr %m_plane7, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon.2, ptr %15, i32 0, i32 1
  %16 = load float, ptr %y, align 4
  %17 = load ptr, ptr %facesB.addr, align 8
  %18 = load ptr, ptr %hullB.addr, align 8
  %m_faceOffset8 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %18, i32 0, i32 5
  %19 = load i32, ptr %m_faceOffset8, align 4
  %20 = load i32, ptr %face, align 4
  %add9 = add nsw i32 %19, %20
  %call11 = invoke noundef nonnull align 16 dereferenceable(32) ptr @_ZNK20b3AlignedObjectArrayI9b3GpuFaceEixEi(ptr noundef nonnull align 8 dereferenceable(25) %17, i32 noundef %add9)
          to label %invoke.cont10 unwind label %lpad

invoke.cont10:                                    ; preds = %invoke.cont5
  %m_plane12 = getelementptr inbounds %struct.b3GpuFace, ptr %call11, i32 0, i32 0
  %21 = getelementptr inbounds %class.b3Vector3, ptr %m_plane12, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon.2, ptr %21, i32 0, i32 2
  %22 = load float, ptr %z, align 8
  %call13 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef %10, float noundef %16, float noundef %22, float noundef 0.000000e+00)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %Normal, i32 0, i32 0
  %coerce.dive14 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %23 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive14, i32 0, i32 0
  %24 = extractvalue { <2 x float>, <2 x float> } %call13, 0
  store <2 x float> %24, ptr %23, align 16
  %25 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive14, i32 0, i32 1
  %26 = extractvalue { <2 x float>, <2 x float> } %call13, 1
  store <2 x float> %26, ptr %25, align 8
  %27 = load ptr, ptr %ornB.addr, align 8
  %call16 = invoke { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %27, ptr noundef nonnull align 16 dereferenceable(16) %Normal)
          to label %invoke.cont15 unwind label %lpad

invoke.cont15:                                    ; preds = %invoke.cont10
  %coerce.dive17 = getelementptr inbounds %class.b3Vector3, ptr %WorldNormal, i32 0, i32 0
  %coerce.dive18 = getelementptr inbounds %union.anon.1, ptr %coerce.dive17, i32 0, i32 0
  %28 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive18, i32 0, i32 0
  %29 = extractvalue { <2 x float>, <2 x float> } %call16, 0
  store <2 x float> %29, ptr %28, align 16
  %30 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive18, i32 0, i32 1
  %31 = extractvalue { <2 x float>, <2 x float> } %call16, 1
  store <2 x float> %31, ptr %30, align 8
  %32 = load ptr, ptr %separatingNormal.addr, align 8
  %call20 = invoke noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %WorldNormal, ptr noundef nonnull align 16 dereferenceable(16) %32)
          to label %invoke.cont19 unwind label %lpad

invoke.cont19:                                    ; preds = %invoke.cont15
  store float %call20, ptr %d, align 4
  %33 = load float, ptr %d, align 4
  %34 = load float, ptr %dmax, align 4
  %cmp21 = fcmp ogt float %33, %34
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %invoke.cont19
  %35 = load float, ptr %d, align 4
  store float %35, ptr %dmax, align 4
  %36 = load i32, ptr %face, align 4
  store i32 %36, ptr %closestFaceB, align 4
  br label %if.end23

lpad:                                             ; preds = %if.then46, %invoke.cont35, %invoke.cont32, %for.body30, %for.end, %invoke.cont15, %invoke.cont10, %invoke.cont5, %invoke.cont, %for.body
  %37 = landingpad { ptr, i32 }
          cleanup
  %38 = extractvalue { ptr, i32 } %37, 0
  store ptr %38, ptr %exn.slot, align 8
  %39 = extractvalue { ptr, i32 } %37, 1
  store i32 %39, ptr %ehselector.slot, align 4
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile) #13
  br label %eh.resume

if.end23:                                         ; preds = %if.then22, %invoke.cont19
  br label %for.inc

for.inc:                                          ; preds = %if.end23
  %40 = load i32, ptr %face, align 4
  %inc = add nsw i32 %40, 1
  store i32 %inc, ptr %face, align 4
  br label %for.cond, !llvm.loop !38

for.end:                                          ; preds = %for.cond
  store i8 0, ptr @_ZZL19clipHullAgainstHullRK9b3Vector3RK22b3ConvexPolyhedronDataS4_S1_RK12b3QuaternionS1_S7_PS_S8_iffRK20b3AlignedObjectArrayIS_ERKS9_I9b3GpuFaceERKS9_IiESC_SG_SJ_S8_iE4once, align 1
  %41 = load ptr, ptr %facesB.addr, align 8
  %42 = load ptr, ptr %hullB.addr, align 8
  %m_faceOffset24 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %42, i32 0, i32 5
  %43 = load i32, ptr %m_faceOffset24, align 4
  %44 = load i32, ptr %closestFaceB, align 4
  %add25 = add nsw i32 %43, %44
  %call27 = invoke noundef nonnull align 16 dereferenceable(32) ptr @_ZNK20b3AlignedObjectArrayI9b3GpuFaceEixEi(ptr noundef nonnull align 8 dereferenceable(25) %41, i32 noundef %add25)
          to label %invoke.cont26 unwind label %lpad

invoke.cont26:                                    ; preds = %for.end
  store ptr %call27, ptr %polyB, align 8
  %45 = load ptr, ptr %polyB, align 8
  %m_numIndices = getelementptr inbounds %struct.b3GpuFace, ptr %45, i32 0, i32 2
  %46 = load i32, ptr %m_numIndices, align 4
  store i32 %46, ptr %numVertices, align 4
  store i32 0, ptr %e0, align 4
  br label %for.cond28

for.cond28:                                       ; preds = %for.inc42, %invoke.cont26
  %47 = load i32, ptr %e0, align 4
  %48 = load i32, ptr %numVertices, align 4
  %cmp29 = icmp slt i32 %47, %48
  br i1 %cmp29, label %for.body30, label %for.end44

for.body30:                                       ; preds = %for.cond28
  %49 = load ptr, ptr %verticesB.addr, align 8
  %50 = load ptr, ptr %hullB.addr, align 8
  %m_vertexOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %50, i32 0, i32 8
  %51 = load i32, ptr %m_vertexOffset, align 16
  %52 = load ptr, ptr %indicesB.addr, align 8
  %53 = load ptr, ptr %polyB, align 8
  %m_indexOffset = getelementptr inbounds %struct.b3GpuFace, ptr %53, i32 0, i32 1
  %54 = load i32, ptr %m_indexOffset, align 16
  %55 = load i32, ptr %e0, align 4
  %add31 = add nsw i32 %54, %55
  %call33 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZNK20b3AlignedObjectArrayIiEixEi(ptr noundef nonnull align 8 dereferenceable(25) %52, i32 noundef %add31)
          to label %invoke.cont32 unwind label %lpad

invoke.cont32:                                    ; preds = %for.body30
  %56 = load i32, ptr %call33, align 4
  %add34 = add nsw i32 %51, %56
  %call36 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZNK20b3AlignedObjectArrayI9b3Vector3EixEi(ptr noundef nonnull align 8 dereferenceable(25) %49, i32 noundef %add34)
          to label %invoke.cont35 unwind label %lpad

invoke.cont35:                                    ; preds = %invoke.cont32
  store ptr %call36, ptr %b, align 8
  %57 = load ptr, ptr %b, align 8
  %58 = load ptr, ptr %posB.addr, align 8
  %59 = load ptr, ptr %ornB.addr, align 8
  %call38 = invoke { <2 x float>, <2 x float> } @_Z9transformPK9b3Vector3S1_PK12b3Quaternion(ptr noundef %57, ptr noundef %58, ptr noundef %59)
          to label %invoke.cont37 unwind label %lpad

invoke.cont37:                                    ; preds = %invoke.cont35
  %coerce.dive39 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive40 = getelementptr inbounds %union.anon.1, ptr %coerce.dive39, i32 0, i32 0
  %60 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive40, i32 0, i32 0
  %61 = extractvalue { <2 x float>, <2 x float> } %call38, 0
  store <2 x float> %61, ptr %60, align 16
  %62 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive40, i32 0, i32 1
  %63 = extractvalue { <2 x float>, <2 x float> } %call38, 1
  store <2 x float> %63, ptr %62, align 8
  %64 = load ptr, ptr %worldVertsB1.addr, align 8
  %65 = load i32, ptr %numWorldVertsB1, align 4
  %inc41 = add nsw i32 %65, 1
  store i32 %inc41, ptr %numWorldVertsB1, align 4
  %idxprom = sext i32 %65 to i64
  %arrayidx = getelementptr inbounds %class.b3Vector3, ptr %64, i64 %idxprom
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx, ptr align 16 %ref.tmp, i64 16, i1 false)
  br label %for.inc42

for.inc42:                                        ; preds = %invoke.cont37
  %66 = load i32, ptr %e0, align 4
  %inc43 = add nsw i32 %66, 1
  store i32 %inc43, ptr %e0, align 4
  br label %for.cond28, !llvm.loop !39

for.end44:                                        ; preds = %for.cond28
  %67 = load i32, ptr %closestFaceB, align 4
  %cmp45 = icmp sge i32 %67, 0
  br i1 %cmp45, label %if.then46, label %if.end49

if.then46:                                        ; preds = %for.end44
  %68 = load ptr, ptr %separatingNormal.addr, align 8
  %69 = load ptr, ptr %hullA.addr, align 8
  %70 = load ptr, ptr %posA.addr, align 8
  %71 = load ptr, ptr %ornA.addr, align 8
  %72 = load ptr, ptr %worldVertsB1.addr, align 8
  %73 = load i32, ptr %numWorldVertsB1, align 4
  %74 = load ptr, ptr %worldVertsB2.addr, align 8
  %75 = load i32, ptr %capacityWorldVerts.addr, align 4
  %76 = load float, ptr %minDist.addr, align 4
  %77 = load float, ptr %maxDist.addr, align 4
  %78 = load ptr, ptr %verticesA.addr, align 8
  %79 = load ptr, ptr %facesA.addr, align 8
  %80 = load ptr, ptr %indicesA.addr, align 8
  %81 = load ptr, ptr %contactsOut.addr, align 8
  %82 = load i32, ptr %contactCapacity.addr, align 4
  %call48 = invoke noundef i32 @_Z19clipFaceAgainstHullRK9b3Vector3PK22b3ConvexPolyhedronDataS1_RK12b3QuaternionPS_iS8_iffRK20b3AlignedObjectArrayIS_ERKS9_I9b3GpuFaceERKS9_IiES8_i(ptr noundef nonnull align 16 dereferenceable(16) %68, ptr noundef %69, ptr noundef nonnull align 16 dereferenceable(16) %70, ptr noundef nonnull align 16 dereferenceable(16) %71, ptr noundef %72, i32 noundef %73, ptr noundef %74, i32 noundef %75, float noundef %76, float noundef %77, ptr noundef nonnull align 8 dereferenceable(25) %78, ptr noundef nonnull align 8 dereferenceable(25) %79, ptr noundef nonnull align 8 dereferenceable(25) %80, ptr noundef %81, i32 noundef %82)
          to label %invoke.cont47 unwind label %lpad

invoke.cont47:                                    ; preds = %if.then46
  store i32 %call48, ptr %numContactsOut, align 4
  br label %if.end49

if.end49:                                         ; preds = %invoke.cont47, %for.end44
  %83 = load i32, ptr %numContactsOut, align 4
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile) #13
  ret i32 %83

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val50 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val50
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(96) ptr @_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(16) ptr @_ZN11b3Transform9getOriginEv(ptr noundef nonnull align 16 dereferenceable(64) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_origin = getelementptr inbounds %class.b3Transform, ptr %this1, i32 0, i32 1
  ret ptr %m_origin
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %this, ptr noundef %name) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  %0 = load ptr, ptr %name.addr, align 8
  call void @b3EnterProfileZone(ptr noundef %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(112) ptr @_ZN20b3AlignedObjectArrayI10b3Contact4E6expandERKS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, ptr noundef nonnull align 16 dereferenceable(112) %fillValue) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %fillValue.addr = alloca ptr, align 8
  %sz = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %fillValue, ptr %fillValue.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI10b3Contact4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  store i32 %call, ptr %sz, align 4
  %0 = load i32, ptr %sz, align 4
  %call2 = call noundef i32 @_ZNK20b3AlignedObjectArrayI10b3Contact4E8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %cmp = icmp eq i32 %0, %call2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call3 = call noundef i32 @_ZNK20b3AlignedObjectArrayI10b3Contact4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %call4 = call noundef i32 @_ZN20b3AlignedObjectArrayI10b3Contact4E9allocSizeEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %call3)
  call void @_ZN20b3AlignedObjectArrayI10b3Contact4E7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %call4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this1, i32 0, i32 2
  %1 = load i32, ptr %m_size, align 4
  %inc = add nsw i32 %1, 1
  store i32 %inc, ptr %m_size, align 4
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this1, i32 0, i32 5
  %2 = load ptr, ptr %m_data, align 8
  %3 = load i32, ptr %sz, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds %struct.b3Contact4, ptr %2, i64 %idxprom
  %call5 = call noundef ptr @_ZN10b3Contact4nwEmPv(i64 noundef 112, ptr noundef %arrayidx)
  %4 = load ptr, ptr %fillValue.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %call5, ptr align 16 %4, i64 112, i1 false)
  %m_data6 = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this1, i32 0, i32 5
  %5 = load ptr, ptr %m_data6, align 8
  %6 = load i32, ptr %sz, align 4
  %idxprom7 = sext i32 %6 to i64
  %arrayidx8 = getelementptr inbounds %struct.b3Contact4, ptr %5, i64 %idxprom7
  ret ptr %arrayidx8
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(112) ptr @_ZN20b3AlignedObjectArrayI10b3Contact4E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3Contact4, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(80) ptr @_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3RigidBodyData, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %this) unnamed_addr #3 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  invoke void @b3LeaveProfileZone()
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #14
  unreachable
}

; Function Attrs: mustprogress uwtable
define dso_local void @_Z25computeContactPlaneConvexiiiiiPK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataPK9b3Vector3PKiPK9b3GpuFaceP10b3Contact4Rii(i32 noundef %pairIndex, i32 noundef %bodyIndexA, i32 noundef %bodyIndexB, i32 noundef %collidableIndexA, i32 noundef %collidableIndexB, ptr noundef %rigidBodies, ptr noundef %collidables, ptr noundef %convexShapes, ptr noundef %convexVertices, ptr noundef %convexIndices, ptr noundef %faces, ptr noundef %globalContactsOut, ptr noundef nonnull align 4 dereferenceable(4) %nGlobalContactsOut, i32 noundef %maxContactCapacity) #2 {
entry:
  %pairIndex.addr = alloca i32, align 4
  %bodyIndexA.addr = alloca i32, align 4
  %bodyIndexB.addr = alloca i32, align 4
  %collidableIndexA.addr = alloca i32, align 4
  %collidableIndexB.addr = alloca i32, align 4
  %rigidBodies.addr = alloca ptr, align 8
  %collidables.addr = alloca ptr, align 8
  %convexShapes.addr = alloca ptr, align 8
  %convexVertices.addr = alloca ptr, align 8
  %convexIndices.addr = alloca ptr, align 8
  %faces.addr = alloca ptr, align 8
  %globalContactsOut.addr = alloca ptr, align 8
  %nGlobalContactsOut.addr = alloca ptr, align 8
  %maxContactCapacity.addr = alloca i32, align 4
  %shapeIndex = alloca i32, align 4
  %hullB = alloca ptr, align 8
  %posB = alloca %class.b3Vector3, align 16
  %ornB = alloca %class.b3Quaternion, align 16
  %posA = alloca %class.b3Vector3, align 16
  %ornA = alloca %class.b3Quaternion, align 16
  %planeEq = alloca %class.b3Vector3, align 16
  %planeNormal = alloca %class.b3Vector3, align 16
  %planeNormalWorld = alloca %class.b3Vector3, align 16
  %planeConstant = alloca float, align 4
  %convexWorldTransform = alloca %class.b3Transform, align 16
  %planeTransform = alloca %class.b3Transform, align 16
  %planeInConvex = alloca %class.b3Transform, align 16
  %ref.tmp = alloca %class.b3Transform, align 16
  %ref.tmp21 = alloca %class.b3Transform, align 16
  %convexInPlane = alloca %class.b3Transform, align 16
  %ref.tmp23 = alloca %class.b3Transform, align 16
  %ref.tmp24 = alloca %class.b3Transform, align 16
  %planeNormalInConvex = alloca %class.b3Vector3, align 16
  %ref.tmp27 = alloca %class.b3Vector3, align 16
  %maxDot = alloca float, align 4
  %hitVertex = alloca i32, align 4
  %hitVtx = alloca %class.b3Vector3, align 16
  %contactPoints = alloca [64 x %class.b3Vector3], align 16
  %numPoints = alloca i32, align 4
  %contactIdx = alloca %struct.b3Int4, align 16
  %i = alloca i32, align 4
  %vtx = alloca %class.b3Vector3, align 16
  %curDot = alloca float, align 4
  %vtxWorld = alloca %class.b3Vector3, align 16
  %vtxInPlane = alloca %class.b3Vector3, align 16
  %ref.tmp53 = alloca %class.b3Transform, align 16
  %dist = alloca float, align 4
  %numReducedPoints = alloca i32, align 4
  %dstIdx = alloca i32, align 4
  %c = alloca ptr, align 8
  %ref.tmp77 = alloca %class.b3Vector3, align 16
  %i94 = alloca i32, align 4
  %pOnB1 = alloca %class.b3Vector3, align 16
  store i32 %pairIndex, ptr %pairIndex.addr, align 4
  store i32 %bodyIndexA, ptr %bodyIndexA.addr, align 4
  store i32 %bodyIndexB, ptr %bodyIndexB.addr, align 4
  store i32 %collidableIndexA, ptr %collidableIndexA.addr, align 4
  store i32 %collidableIndexB, ptr %collidableIndexB.addr, align 4
  store ptr %rigidBodies, ptr %rigidBodies.addr, align 8
  store ptr %collidables, ptr %collidables.addr, align 8
  store ptr %convexShapes, ptr %convexShapes.addr, align 8
  store ptr %convexVertices, ptr %convexVertices.addr, align 8
  store ptr %convexIndices, ptr %convexIndices.addr, align 8
  store ptr %faces, ptr %faces.addr, align 8
  store ptr %globalContactsOut, ptr %globalContactsOut.addr, align 8
  store ptr %nGlobalContactsOut, ptr %nGlobalContactsOut.addr, align 8
  store i32 %maxContactCapacity, ptr %maxContactCapacity.addr, align 4
  %0 = load ptr, ptr %collidables.addr, align 8
  %1 = load i32, ptr %collidableIndexB.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3Collidable, ptr %0, i64 %idxprom
  %2 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx, i32 0, i32 3
  %3 = load i32, ptr %2, align 4
  store i32 %3, ptr %shapeIndex, align 4
  %4 = load ptr, ptr %convexShapes.addr, align 8
  %5 = load i32, ptr %shapeIndex, align 4
  %idxprom1 = sext i32 %5 to i64
  %arrayidx2 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %4, i64 %idxprom1
  store ptr %arrayidx2, ptr %hullB, align 8
  %6 = load ptr, ptr %rigidBodies.addr, align 8
  %7 = load i32, ptr %bodyIndexB.addr, align 4
  %idxprom3 = sext i32 %7 to i64
  %arrayidx4 = getelementptr inbounds %struct.b3RigidBodyData, ptr %6, i64 %idxprom3
  %m_pos = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx4, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posB, ptr align 16 %m_pos, i64 16, i1 false)
  %8 = load ptr, ptr %rigidBodies.addr, align 8
  %9 = load i32, ptr %bodyIndexB.addr, align 4
  %idxprom5 = sext i32 %9 to i64
  %arrayidx6 = getelementptr inbounds %struct.b3RigidBodyData, ptr %8, i64 %idxprom5
  %m_quat = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx6, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornB, ptr align 16 %m_quat, i64 16, i1 false)
  %10 = load ptr, ptr %rigidBodies.addr, align 8
  %11 = load i32, ptr %bodyIndexA.addr, align 4
  %idxprom7 = sext i32 %11 to i64
  %arrayidx8 = getelementptr inbounds %struct.b3RigidBodyData, ptr %10, i64 %idxprom7
  %m_pos9 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx8, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posA, ptr align 16 %m_pos9, i64 16, i1 false)
  %12 = load ptr, ptr %rigidBodies.addr, align 8
  %13 = load i32, ptr %bodyIndexA.addr, align 4
  %idxprom10 = sext i32 %13 to i64
  %arrayidx11 = getelementptr inbounds %struct.b3RigidBodyData, ptr %12, i64 %idxprom10
  %m_quat12 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx11, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornA, ptr align 16 %m_quat12, i64 16, i1 false)
  %14 = load ptr, ptr %faces.addr, align 8
  %15 = load ptr, ptr %collidables.addr, align 8
  %16 = load i32, ptr %collidableIndexA.addr, align 4
  %idxprom13 = sext i32 %16 to i64
  %arrayidx14 = getelementptr inbounds %struct.b3Collidable, ptr %15, i64 %idxprom13
  %17 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx14, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  %idxprom15 = sext i32 %18 to i64
  %arrayidx16 = getelementptr inbounds %struct.b3GpuFace, ptr %14, i64 %idxprom15
  %m_plane = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx16, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %planeEq, ptr align 16 %m_plane, i64 16, i1 false)
  %19 = getelementptr inbounds %class.b3Vector3, ptr %planeEq, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon.2, ptr %19, i32 0, i32 0
  %20 = load float, ptr %x, align 16
  %21 = getelementptr inbounds %class.b3Vector3, ptr %planeEq, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon.2, ptr %21, i32 0, i32 1
  %22 = load float, ptr %y, align 4
  %23 = getelementptr inbounds %class.b3Vector3, ptr %planeEq, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon.2, ptr %23, i32 0, i32 2
  %24 = load float, ptr %z, align 8
  %call = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef %20, float noundef %22, float noundef %24)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %planeNormal, i32 0, i32 0
  %coerce.dive17 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %25 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive17, i32 0, i32 0
  %26 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %26, ptr %25, align 16
  %27 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive17, i32 0, i32 1
  %28 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %28, ptr %27, align 8
  %call18 = call { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %planeNormal)
  %coerce.dive19 = getelementptr inbounds %class.b3Vector3, ptr %planeNormalWorld, i32 0, i32 0
  %coerce.dive20 = getelementptr inbounds %union.anon.1, ptr %coerce.dive19, i32 0, i32 0
  %29 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive20, i32 0, i32 0
  %30 = extractvalue { <2 x float>, <2 x float> } %call18, 0
  store <2 x float> %30, ptr %29, align 16
  %31 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive20, i32 0, i32 1
  %32 = extractvalue { <2 x float>, <2 x float> } %call18, 1
  store <2 x float> %32, ptr %31, align 8
  %33 = getelementptr inbounds %class.b3Vector3, ptr %planeEq, i32 0, i32 0
  %w = getelementptr inbounds %struct.anon.2, ptr %33, i32 0, i32 3
  %34 = load float, ptr %w, align 4
  store float %34, ptr %planeConstant, align 4
  call void @_ZN11b3TransformC2Ev(ptr noundef nonnull align 16 dereferenceable(64) %convexWorldTransform)
  call void @_ZN11b3Transform11setIdentityEv(ptr noundef nonnull align 16 dereferenceable(64) %convexWorldTransform)
  call void @_ZN11b3Transform9setOriginERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %convexWorldTransform, ptr noundef nonnull align 16 dereferenceable(16) %posB)
  call void @_ZN11b3Transform11setRotationERK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(64) %convexWorldTransform, ptr noundef nonnull align 16 dereferenceable(16) %ornB)
  call void @_ZN11b3TransformC2Ev(ptr noundef nonnull align 16 dereferenceable(64) %planeTransform)
  call void @_ZN11b3Transform11setIdentityEv(ptr noundef nonnull align 16 dereferenceable(64) %planeTransform)
  call void @_ZN11b3Transform9setOriginERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %planeTransform, ptr noundef nonnull align 16 dereferenceable(16) %posA)
  call void @_ZN11b3Transform11setRotationERK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(64) %planeTransform, ptr noundef nonnull align 16 dereferenceable(16) %ornA)
  call void @_ZN11b3TransformC2Ev(ptr noundef nonnull align 16 dereferenceable(64) %planeInConvex)
  call void @_ZNK11b3Transform7inverseEv(ptr sret(%class.b3Transform) align 16 %ref.tmp21, ptr noundef nonnull align 16 dereferenceable(64) %convexWorldTransform)
  call void @_ZNK11b3TransformmlERKS_(ptr sret(%class.b3Transform) align 16 %ref.tmp, ptr noundef nonnull align 16 dereferenceable(64) %ref.tmp21, ptr noundef nonnull align 16 dereferenceable(64) %planeTransform)
  %call22 = call noundef nonnull align 16 dereferenceable(64) ptr @_ZN11b3TransformaSERKS_(ptr noundef nonnull align 16 dereferenceable(64) %planeInConvex, ptr noundef nonnull align 16 dereferenceable(64) %ref.tmp)
  call void @_ZN11b3TransformC2Ev(ptr noundef nonnull align 16 dereferenceable(64) %convexInPlane)
  call void @_ZNK11b3Transform7inverseEv(ptr sret(%class.b3Transform) align 16 %ref.tmp24, ptr noundef nonnull align 16 dereferenceable(64) %planeTransform)
  call void @_ZNK11b3TransformmlERKS_(ptr sret(%class.b3Transform) align 16 %ref.tmp23, ptr noundef nonnull align 16 dereferenceable(64) %ref.tmp24, ptr noundef nonnull align 16 dereferenceable(64) %convexWorldTransform)
  %call25 = call noundef nonnull align 16 dereferenceable(64) ptr @_ZN11b3TransformaSERKS_(ptr noundef nonnull align 16 dereferenceable(64) %convexInPlane, ptr noundef nonnull align 16 dereferenceable(64) %ref.tmp23)
  %call26 = call noundef nonnull align 16 dereferenceable(48) ptr @_ZN11b3Transform8getBasisEv(ptr noundef nonnull align 16 dereferenceable(64) %planeInConvex)
  %call28 = call { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %planeNormal)
  %coerce.dive29 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp27, i32 0, i32 0
  %coerce.dive30 = getelementptr inbounds %union.anon.1, ptr %coerce.dive29, i32 0, i32 0
  %35 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive30, i32 0, i32 0
  %36 = extractvalue { <2 x float>, <2 x float> } %call28, 0
  store <2 x float> %36, ptr %35, align 16
  %37 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive30, i32 0, i32 1
  %38 = extractvalue { <2 x float>, <2 x float> } %call28, 1
  store <2 x float> %38, ptr %37, align 8
  %call31 = call { <2 x float>, <2 x float> } @_ZmlRK11b3Matrix3x3RK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(48) %call26, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp27)
  %coerce.dive32 = getelementptr inbounds %class.b3Vector3, ptr %planeNormalInConvex, i32 0, i32 0
  %coerce.dive33 = getelementptr inbounds %union.anon.1, ptr %coerce.dive32, i32 0, i32 0
  %39 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive33, i32 0, i32 0
  %40 = extractvalue { <2 x float>, <2 x float> } %call31, 0
  store <2 x float> %40, ptr %39, align 16
  %41 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive33, i32 0, i32 1
  %42 = extractvalue { <2 x float>, <2 x float> } %call31, 1
  store <2 x float> %42, ptr %41, align 8
  store float 0xC6293E5940000000, ptr %maxDot, align 4
  store i32 -1, ptr %hitVertex, align 4
  store i32 0, ptr %numPoints, align 4
  %43 = getelementptr inbounds %struct.b3Int4, ptr %contactIdx, i32 0, i32 0
  %s = getelementptr inbounds %struct.anon.0, ptr %43, i32 0, i32 0
  %arrayidx34 = getelementptr inbounds [4 x i32], ptr %s, i64 0, i64 0
  store i32 0, ptr %arrayidx34, align 16
  %44 = getelementptr inbounds %struct.b3Int4, ptr %contactIdx, i32 0, i32 0
  %s35 = getelementptr inbounds %struct.anon.0, ptr %44, i32 0, i32 0
  %arrayidx36 = getelementptr inbounds [4 x i32], ptr %s35, i64 0, i64 1
  store i32 1, ptr %arrayidx36, align 4
  %45 = getelementptr inbounds %struct.b3Int4, ptr %contactIdx, i32 0, i32 0
  %s37 = getelementptr inbounds %struct.anon.0, ptr %45, i32 0, i32 0
  %arrayidx38 = getelementptr inbounds [4 x i32], ptr %s37, i64 0, i64 2
  store i32 2, ptr %arrayidx38, align 8
  %46 = getelementptr inbounds %struct.b3Int4, ptr %contactIdx, i32 0, i32 0
  %s39 = getelementptr inbounds %struct.anon.0, ptr %46, i32 0, i32 0
  %arrayidx40 = getelementptr inbounds [4 x i32], ptr %s39, i64 0, i64 3
  store i32 3, ptr %arrayidx40, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %47 = load i32, ptr %i, align 4
  %48 = load ptr, ptr %hullB, align 8
  %m_numVertices = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %48, i32 0, i32 7
  %49 = load i32, ptr %m_numVertices, align 4
  %cmp = icmp slt i32 %47, %49
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %50 = load ptr, ptr %convexVertices.addr, align 8
  %51 = load ptr, ptr %hullB, align 8
  %m_vertexOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %51, i32 0, i32 8
  %52 = load i32, ptr %m_vertexOffset, align 16
  %53 = load i32, ptr %i, align 4
  %add = add nsw i32 %52, %53
  %idxprom41 = sext i32 %add to i64
  %arrayidx42 = getelementptr inbounds %class.b3Vector3, ptr %50, i64 %idxprom41
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %vtx, ptr align 16 %arrayidx42, i64 16, i1 false)
  %call43 = call noundef float @_ZNK9b3Vector33dotERKS_(ptr noundef nonnull align 16 dereferenceable(16) %vtx, ptr noundef nonnull align 16 dereferenceable(16) %planeNormalInConvex)
  store float %call43, ptr %curDot, align 4
  %54 = load float, ptr %curDot, align 4
  %55 = load float, ptr %maxDot, align 4
  %cmp44 = fcmp ogt float %54, %55
  br i1 %cmp44, label %if.then, label %if.end47

if.then:                                          ; preds = %for.body
  %56 = load i32, ptr %i, align 4
  store i32 %56, ptr %hitVertex, align 4
  %57 = load float, ptr %curDot, align 4
  store float %57, ptr %maxDot, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %hitVtx, ptr align 16 %vtx, i64 16, i1 false)
  %58 = load i32, ptr %numPoints, align 4
  %cmp45 = icmp eq i32 %58, 64
  br i1 %cmp45, label %if.then46, label %if.end

if.then46:                                        ; preds = %if.then
  %59 = load i32, ptr %numPoints, align 4
  %dec = add nsw i32 %59, -1
  store i32 %dec, ptr %numPoints, align 4
  br label %if.end

if.end:                                           ; preds = %if.then46, %if.then
  br label %if.end47

if.end47:                                         ; preds = %if.end, %for.body
  %60 = load i32, ptr %numPoints, align 4
  %cmp48 = icmp slt i32 %60, 64
  br i1 %cmp48, label %if.then49, label %if.end64

if.then49:                                        ; preds = %if.end47
  %call50 = call { <2 x float>, <2 x float> } @_ZNK11b3TransformmlERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %convexWorldTransform, ptr noundef nonnull align 16 dereferenceable(16) %vtx)
  %coerce.dive51 = getelementptr inbounds %class.b3Vector3, ptr %vtxWorld, i32 0, i32 0
  %coerce.dive52 = getelementptr inbounds %union.anon.1, ptr %coerce.dive51, i32 0, i32 0
  %61 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive52, i32 0, i32 0
  %62 = extractvalue { <2 x float>, <2 x float> } %call50, 0
  store <2 x float> %62, ptr %61, align 16
  %63 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive52, i32 0, i32 1
  %64 = extractvalue { <2 x float>, <2 x float> } %call50, 1
  store <2 x float> %64, ptr %63, align 8
  call void @_ZNK11b3Transform7inverseEv(ptr sret(%class.b3Transform) align 16 %ref.tmp53, ptr noundef nonnull align 16 dereferenceable(64) %planeTransform)
  %call54 = call { <2 x float>, <2 x float> } @_ZNK11b3TransformmlERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %ref.tmp53, ptr noundef nonnull align 16 dereferenceable(16) %vtxWorld)
  %coerce.dive55 = getelementptr inbounds %class.b3Vector3, ptr %vtxInPlane, i32 0, i32 0
  %coerce.dive56 = getelementptr inbounds %union.anon.1, ptr %coerce.dive55, i32 0, i32 0
  %65 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive56, i32 0, i32 0
  %66 = extractvalue { <2 x float>, <2 x float> } %call54, 0
  store <2 x float> %66, ptr %65, align 16
  %67 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive56, i32 0, i32 1
  %68 = extractvalue { <2 x float>, <2 x float> } %call54, 1
  store <2 x float> %68, ptr %67, align 8
  %call57 = call noundef float @_ZNK9b3Vector33dotERKS_(ptr noundef nonnull align 16 dereferenceable(16) %planeNormal, ptr noundef nonnull align 16 dereferenceable(16) %vtxInPlane)
  %69 = load float, ptr %planeConstant, align 4
  %sub = fsub float %call57, %69
  store float %sub, ptr %dist, align 4
  %70 = load float, ptr %dist, align 4
  %cmp58 = fcmp olt float %70, 0.000000e+00
  br i1 %cmp58, label %if.then59, label %if.end63

if.then59:                                        ; preds = %if.then49
  %71 = load float, ptr %dist, align 4
  %72 = getelementptr inbounds %class.b3Vector3, ptr %vtxWorld, i32 0, i32 0
  %w60 = getelementptr inbounds %struct.anon.2, ptr %72, i32 0, i32 3
  store float %71, ptr %w60, align 4
  %73 = load i32, ptr %numPoints, align 4
  %idxprom61 = sext i32 %73 to i64
  %arrayidx62 = getelementptr inbounds [64 x %class.b3Vector3], ptr %contactPoints, i64 0, i64 %idxprom61
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx62, ptr align 16 %vtxWorld, i64 16, i1 false)
  %74 = load i32, ptr %numPoints, align 4
  %inc = add nsw i32 %74, 1
  store i32 %inc, ptr %numPoints, align 4
  br label %if.end63

if.end63:                                         ; preds = %if.then59, %if.then49
  br label %if.end64

if.end64:                                         ; preds = %if.end63, %if.end47
  br label %for.inc

for.inc:                                          ; preds = %if.end64
  %75 = load i32, ptr %i, align 4
  %inc65 = add nsw i32 %75, 1
  store i32 %inc65, ptr %i, align 4
  br label %for.cond, !llvm.loop !40

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %numReducedPoints, align 4
  %76 = load i32, ptr %numPoints, align 4
  store i32 %76, ptr %numReducedPoints, align 4
  %77 = load i32, ptr %numPoints, align 4
  %cmp66 = icmp sgt i32 %77, 4
  br i1 %cmp66, label %if.then67, label %if.end69

if.then67:                                        ; preds = %for.end
  %arraydecay = getelementptr inbounds [64 x %class.b3Vector3], ptr %contactPoints, i64 0, i64 0
  %78 = load i32, ptr %numPoints, align 4
  %call68 = call noundef i32 @_Z31extractManifoldSequentialGlobalPK9b3Vector3iRS0_P6b3Int4(ptr noundef %arraydecay, i32 noundef %78, ptr noundef nonnull align 16 dereferenceable(16) %planeNormalInConvex, ptr noundef %contactIdx)
  store i32 %call68, ptr %numReducedPoints, align 4
  br label %if.end69

if.end69:                                         ; preds = %if.then67, %for.end
  %79 = load i32, ptr %numReducedPoints, align 4
  %cmp70 = icmp sgt i32 %79, 0
  br i1 %cmp70, label %if.then71, label %if.end111

if.then71:                                        ; preds = %if.end69
  %80 = load ptr, ptr %nGlobalContactsOut.addr, align 8
  %81 = load i32, ptr %80, align 4
  %82 = load i32, ptr %maxContactCapacity.addr, align 4
  %cmp72 = icmp slt i32 %81, %82
  br i1 %cmp72, label %if.then73, label %if.end110

if.then73:                                        ; preds = %if.then71
  %83 = load ptr, ptr %nGlobalContactsOut.addr, align 8
  %84 = load i32, ptr %83, align 4
  store i32 %84, ptr %dstIdx, align 4
  %85 = load ptr, ptr %nGlobalContactsOut.addr, align 8
  %86 = load i32, ptr %85, align 4
  %inc74 = add nsw i32 %86, 1
  store i32 %inc74, ptr %85, align 4
  %87 = load ptr, ptr %globalContactsOut.addr, align 8
  %88 = load i32, ptr %dstIdx, align 4
  %idxprom75 = sext i32 %88 to i64
  %arrayidx76 = getelementptr inbounds %struct.b3Contact4, ptr %87, i64 %idxprom75
  store ptr %arrayidx76, ptr %c, align 8
  %call78 = call { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %planeNormalWorld)
  %coerce.dive79 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp77, i32 0, i32 0
  %coerce.dive80 = getelementptr inbounds %union.anon.1, ptr %coerce.dive79, i32 0, i32 0
  %89 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive80, i32 0, i32 0
  %90 = extractvalue { <2 x float>, <2 x float> } %call78, 0
  store <2 x float> %90, ptr %89, align 16
  %91 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive80, i32 0, i32 1
  %92 = extractvalue { <2 x float>, <2 x float> } %call78, 1
  store <2 x float> %92, ptr %91, align 8
  %93 = load ptr, ptr %c, align 8
  %m_worldNormalOnB = getelementptr inbounds %struct.b3Contact4Data, ptr %93, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %m_worldNormalOnB, ptr align 16 %ref.tmp77, i64 16, i1 false)
  %94 = load ptr, ptr %c, align 8
  call void @_ZN10b3Contact416setFrictionCoeffEf(ptr noundef nonnull align 16 dereferenceable(112) %94, float noundef 0x3FE6666660000000)
  %95 = load ptr, ptr %c, align 8
  call void @_ZN10b3Contact420setRestituitionCoeffEf(ptr noundef nonnull align 16 dereferenceable(112) %95, float noundef 0.000000e+00)
  %96 = load i32, ptr %pairIndex.addr, align 4
  %97 = load ptr, ptr %c, align 8
  %m_batchIdx = getelementptr inbounds %struct.b3Contact4Data, ptr %97, i32 0, i32 4
  store i32 %96, ptr %m_batchIdx, align 4
  %98 = load ptr, ptr %rigidBodies.addr, align 8
  %99 = load i32, ptr %bodyIndexA.addr, align 4
  %idxprom81 = sext i32 %99 to i64
  %arrayidx82 = getelementptr inbounds %struct.b3RigidBodyData, ptr %98, i64 %idxprom81
  %m_invMass = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx82, i32 0, i32 5
  %100 = load float, ptr %m_invMass, align 4
  %cmp83 = fcmp oeq float %100, 0.000000e+00
  br i1 %cmp83, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then73
  %101 = load i32, ptr %bodyIndexA.addr, align 4
  %sub84 = sub nsw i32 0, %101
  br label %cond.end

cond.false:                                       ; preds = %if.then73
  %102 = load i32, ptr %bodyIndexA.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %sub84, %cond.true ], [ %102, %cond.false ]
  %103 = load ptr, ptr %c, align 8
  %m_bodyAPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %103, i32 0, i32 5
  store i32 %cond, ptr %m_bodyAPtrAndSignBit, align 8
  %104 = load ptr, ptr %rigidBodies.addr, align 8
  %105 = load i32, ptr %bodyIndexB.addr, align 4
  %idxprom85 = sext i32 %105 to i64
  %arrayidx86 = getelementptr inbounds %struct.b3RigidBodyData, ptr %104, i64 %idxprom85
  %m_invMass87 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx86, i32 0, i32 5
  %106 = load float, ptr %m_invMass87, align 4
  %cmp88 = fcmp oeq float %106, 0.000000e+00
  br i1 %cmp88, label %cond.true89, label %cond.false91

cond.true89:                                      ; preds = %cond.end
  %107 = load i32, ptr %bodyIndexB.addr, align 4
  %sub90 = sub nsw i32 0, %107
  br label %cond.end92

cond.false91:                                     ; preds = %cond.end
  %108 = load i32, ptr %bodyIndexB.addr, align 4
  br label %cond.end92

cond.end92:                                       ; preds = %cond.false91, %cond.true89
  %cond93 = phi i32 [ %sub90, %cond.true89 ], [ %108, %cond.false91 ]
  %109 = load ptr, ptr %c, align 8
  %m_bodyBPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %109, i32 0, i32 6
  store i32 %cond93, ptr %m_bodyBPtrAndSignBit, align 4
  store i32 0, ptr %i94, align 4
  br label %for.cond95

for.cond95:                                       ; preds = %for.inc105, %cond.end92
  %110 = load i32, ptr %i94, align 4
  %111 = load i32, ptr %numReducedPoints, align 4
  %cmp96 = icmp slt i32 %110, %111
  br i1 %cmp96, label %for.body97, label %for.end107

for.body97:                                       ; preds = %for.cond95
  %112 = getelementptr inbounds %struct.b3Int4, ptr %contactIdx, i32 0, i32 0
  %s98 = getelementptr inbounds %struct.anon.0, ptr %112, i32 0, i32 0
  %113 = load i32, ptr %i94, align 4
  %idxprom99 = sext i32 %113 to i64
  %arrayidx100 = getelementptr inbounds [4 x i32], ptr %s98, i64 0, i64 %idxprom99
  %114 = load i32, ptr %arrayidx100, align 4
  %idxprom101 = sext i32 %114 to i64
  %arrayidx102 = getelementptr inbounds [64 x %class.b3Vector3], ptr %contactPoints, i64 0, i64 %idxprom101
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %pOnB1, ptr align 16 %arrayidx102, i64 16, i1 false)
  %115 = load ptr, ptr %c, align 8
  %m_worldPosB = getelementptr inbounds %struct.b3Contact4Data, ptr %115, i32 0, i32 0
  %116 = load i32, ptr %i94, align 4
  %idxprom103 = sext i32 %116 to i64
  %arrayidx104 = getelementptr inbounds [4 x %class.b3Vector3], ptr %m_worldPosB, i64 0, i64 %idxprom103
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx104, ptr align 16 %pOnB1, i64 16, i1 false)
  br label %for.inc105

for.inc105:                                       ; preds = %for.body97
  %117 = load i32, ptr %i94, align 4
  %inc106 = add nsw i32 %117, 1
  store i32 %inc106, ptr %i94, align 4
  br label %for.cond95, !llvm.loop !41

for.end107:                                       ; preds = %for.cond95
  %118 = load i32, ptr %numReducedPoints, align 4
  %conv = sitofp i32 %118 to float
  %119 = load ptr, ptr %c, align 8
  %m_worldNormalOnB108 = getelementptr inbounds %struct.b3Contact4Data, ptr %119, i32 0, i32 1
  %120 = getelementptr inbounds %class.b3Vector3, ptr %m_worldNormalOnB108, i32 0, i32 0
  %w109 = getelementptr inbounds %struct.anon.2, ptr %120, i32 0, i32 3
  store float %conv, ptr %w109, align 4
  br label %if.end110

if.end110:                                        ; preds = %for.end107, %if.then71
  br label %if.end111

if.end111:                                        ; preds = %if.end110, %if.end69
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK11b3Transform7inverseEv(ptr noalias sret(%class.b3Transform) align 16 %agg.result, ptr noundef nonnull align 16 dereferenceable(64) %this) #2 comdat align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %inv = alloca %class.b3Matrix3x3, align 16
  %ref.tmp = alloca %class.b3Vector3, align 16
  %ref.tmp2 = alloca %class.b3Vector3, align 16
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_basis = getelementptr inbounds %class.b3Transform, ptr %this1, i32 0, i32 0
  call void @_ZNK11b3Matrix3x39transposeEv(ptr sret(%class.b3Matrix3x3) align 16 %inv, ptr noundef nonnull align 16 dereferenceable(48) %m_basis)
  %m_origin = getelementptr inbounds %class.b3Transform, ptr %this1, i32 0, i32 1
  %call = call { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %m_origin)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp2, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive3, i32 0, i32 0
  %1 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %1, ptr %0, align 16
  %2 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive3, i32 0, i32 1
  %3 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %3, ptr %2, align 8
  %call4 = call { <2 x float>, <2 x float> } @_ZmlRK11b3Matrix3x3RK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(48) %inv, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp2)
  %coerce.dive5 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %union.anon.1, ptr %coerce.dive5, i32 0, i32 0
  %4 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive6, i32 0, i32 0
  %5 = extractvalue { <2 x float>, <2 x float> } %call4, 0
  store <2 x float> %5, ptr %4, align 16
  %6 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive6, i32 0, i32 1
  %7 = extractvalue { <2 x float>, <2 x float> } %call4, 1
  store <2 x float> %7, ptr %6, align 8
  call void @_ZN11b3TransformC2ERK11b3Matrix3x3RK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %agg.result, ptr noundef nonnull align 16 dereferenceable(48) %inv, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK11b3TransformmlERKS_(ptr noalias sret(%class.b3Transform) align 16 %agg.result, ptr noundef nonnull align 16 dereferenceable(64) %this, ptr noundef nonnull align 16 dereferenceable(64) %t) #2 comdat align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %t.addr = alloca ptr, align 8
  %ref.tmp = alloca %class.b3Matrix3x3, align 16
  %ref.tmp3 = alloca %class.b3Vector3, align 16
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %t, ptr %t.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_basis = getelementptr inbounds %class.b3Transform, ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %t.addr, align 8
  %m_basis2 = getelementptr inbounds %class.b3Transform, ptr %0, i32 0, i32 0
  call void @_ZmlRK11b3Matrix3x3S1_(ptr sret(%class.b3Matrix3x3) align 16 %ref.tmp, ptr noundef nonnull align 16 dereferenceable(48) %m_basis, ptr noundef nonnull align 16 dereferenceable(48) %m_basis2)
  %1 = load ptr, ptr %t.addr, align 8
  %m_origin = getelementptr inbounds %class.b3Transform, ptr %1, i32 0, i32 1
  %call = call { <2 x float>, <2 x float> } @_ZNK11b3TransformclERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %this1, ptr noundef nonnull align 16 dereferenceable(16) %m_origin)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp3, i32 0, i32 0
  %coerce.dive4 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %2 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive4, i32 0, i32 0
  %3 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %3, ptr %2, align 16
  %4 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive4, i32 0, i32 1
  %5 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %5, ptr %4, align 8
  call void @_ZN11b3TransformC2ERK11b3Matrix3x3RK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %agg.result, ptr noundef nonnull align 16 dereferenceable(48) %ref.tmp, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp3)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(64) ptr @_ZN11b3TransformaSERKS_(ptr noundef nonnull align 16 dereferenceable(64) %this, ptr noundef nonnull align 16 dereferenceable(64) %other) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %other.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %other, ptr %other.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %other.addr, align 8
  %m_basis = getelementptr inbounds %class.b3Transform, ptr %0, i32 0, i32 0
  %m_basis2 = getelementptr inbounds %class.b3Transform, ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 16 dereferenceable(48) ptr @_ZN11b3Matrix3x3aSERKS_(ptr noundef nonnull align 16 dereferenceable(48) %m_basis2, ptr noundef nonnull align 16 dereferenceable(48) %m_basis)
  %1 = load ptr, ptr %other.addr, align 8
  %m_origin = getelementptr inbounds %class.b3Transform, ptr %1, i32 0, i32 1
  %m_origin3 = getelementptr inbounds %class.b3Transform, ptr %this1, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %m_origin3, ptr align 16 %m_origin, i64 16, i1 false)
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_ZmlRK11b3Matrix3x3RK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(48) %m, ptr noundef nonnull align 16 dereferenceable(16) %v) #2 comdat {
entry:
  %retval = alloca %class.b3Vector3, align 16
  %m.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  store ptr %m, ptr %m.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  %0 = load ptr, ptr %m.addr, align 8
  %call = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK11b3Matrix3x3ixEi(ptr noundef nonnull align 16 dereferenceable(48) %0, i32 noundef 0)
  %1 = load ptr, ptr %v.addr, align 8
  %call1 = call noundef float @_ZNK9b3Vector33dotERKS_(ptr noundef nonnull align 16 dereferenceable(16) %call, ptr noundef nonnull align 16 dereferenceable(16) %1)
  %2 = load ptr, ptr %m.addr, align 8
  %call2 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK11b3Matrix3x3ixEi(ptr noundef nonnull align 16 dereferenceable(48) %2, i32 noundef 1)
  %3 = load ptr, ptr %v.addr, align 8
  %call3 = call noundef float @_ZNK9b3Vector33dotERKS_(ptr noundef nonnull align 16 dereferenceable(16) %call2, ptr noundef nonnull align 16 dereferenceable(16) %3)
  %4 = load ptr, ptr %m.addr, align 8
  %call4 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK11b3Matrix3x3ixEi(ptr noundef nonnull align 16 dereferenceable(48) %4, i32 noundef 2)
  %5 = load ptr, ptr %v.addr, align 8
  %call5 = call noundef float @_ZNK9b3Vector33dotERKS_(ptr noundef nonnull align 16 dereferenceable(16) %call4, ptr noundef nonnull align 16 dereferenceable(16) %5)
  %call6 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef %call1, float noundef %call3, float noundef %call5)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive7 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %6 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive7, i32 0, i32 0
  %7 = extractvalue { <2 x float>, <2 x float> } %call6, 0
  store <2 x float> %7, ptr %6, align 16
  %8 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive7, i32 0, i32 1
  %9 = extractvalue { <2 x float>, <2 x float> } %call6, 1
  store <2 x float> %9, ptr %8, align 8
  %coerce.dive8 = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive9 = getelementptr inbounds %union.anon.1, ptr %coerce.dive8, i32 0, i32 0
  %10 = load { <2 x float>, <2 x float> }, ptr %coerce.dive9, align 16
  ret { <2 x float>, <2 x float> } %10
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(48) ptr @_ZN11b3Transform8getBasisEv(ptr noundef nonnull align 16 dereferenceable(64) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_basis = getelementptr inbounds %class.b3Transform, ptr %this1, i32 0, i32 0
  ret ptr %m_basis
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef float @_ZNK9b3Vector33dotERKS_(ptr noundef nonnull align 16 dereferenceable(16) %this, ptr noundef nonnull align 16 dereferenceable(16) %v) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x float], ptr %0, i64 0, i64 0
  %1 = load float, ptr %arrayidx, align 16
  %2 = load ptr, ptr %v.addr, align 8
  %3 = getelementptr inbounds %class.b3Vector3, ptr %2, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [4 x float], ptr %3, i64 0, i64 0
  %4 = load float, ptr %arrayidx2, align 16
  %5 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx3 = getelementptr inbounds [4 x float], ptr %5, i64 0, i64 1
  %6 = load float, ptr %arrayidx3, align 4
  %7 = load ptr, ptr %v.addr, align 8
  %8 = getelementptr inbounds %class.b3Vector3, ptr %7, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [4 x float], ptr %8, i64 0, i64 1
  %9 = load float, ptr %arrayidx4, align 4
  %mul5 = fmul float %6, %9
  %10 = call float @llvm.fmuladd.f32(float %1, float %4, float %mul5)
  %11 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [4 x float], ptr %11, i64 0, i64 2
  %12 = load float, ptr %arrayidx6, align 8
  %13 = load ptr, ptr %v.addr, align 8
  %14 = getelementptr inbounds %class.b3Vector3, ptr %13, i32 0, i32 0
  %arrayidx7 = getelementptr inbounds [4 x float], ptr %14, i64 0, i64 2
  %15 = load float, ptr %arrayidx7, align 8
  %16 = call float @llvm.fmuladd.f32(float %12, float %15, float %10)
  ret float %16
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_ZNK11b3TransformmlERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %this, ptr noundef nonnull align 16 dereferenceable(16) %x) #2 comdat align 2 {
entry:
  %retval = alloca %class.b3Vector3, align 16
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %call = call { <2 x float>, <2 x float> } @_ZNK11b3TransformclERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %this1, ptr noundef nonnull align 16 dereferenceable(16) %0)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %1 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive2, i32 0, i32 0
  %2 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %2, ptr %1, align 16
  %3 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive2, i32 0, i32 1
  %4 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %4, ptr %3, align 8
  %coerce.dive3 = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive4 = getelementptr inbounds %union.anon.1, ptr %coerce.dive3, i32 0, i32 0
  %5 = load { <2 x float>, <2 x float> }, ptr %coerce.dive4, align 16
  ret { <2 x float>, <2 x float> } %5
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN10b3Contact416setFrictionCoeffEf(ptr noundef nonnull align 16 dereferenceable(112) %this, float noundef %c) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %c.addr = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  store float %c, ptr %c.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load float, ptr %c.addr, align 4
  %mul = fmul float %0, 6.553500e+04
  %conv = fptoui float %mul to i16
  %m_frictionCoeffCmp = getelementptr inbounds %struct.b3Contact4Data, ptr %this1, i32 0, i32 3
  store i16 %conv, ptr %m_frictionCoeffCmp, align 2
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN10b3Contact420setRestituitionCoeffEf(ptr noundef nonnull align 16 dereferenceable(112) %this, float noundef %c) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %c.addr = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  store float %c, ptr %c.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load float, ptr %c.addr, align 4
  %mul = fmul float %0, 6.553500e+04
  %conv = fptoui float %mul to i16
  %m_restituitionCoeffCmp = getelementptr inbounds %struct.b3Contact4Data, ptr %this1, i32 0, i32 2
  store i16 %conv, ptr %m_restituitionCoeffCmp, align 16
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define dso_local void @_Z16traverseTreeTreev() #3 {
entry:
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local void @_Z23findCompoundPairsKerneliiiiiPK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataRK20b3AlignedObjectArrayI9b3Vector3ERKS8_I6b3AabbESG_PK15b3GpuChildShapeP6b3Int4PiiRS8_I18b3QuantizedBvhNodeERS8_I16b3BvhSubtreeInfoERS8_I9b3BvhInfoE(i32 noundef %pairIndex, i32 noundef %bodyIndexA, i32 noundef %bodyIndexB, i32 noundef %collidableIndexA, i32 noundef %collidableIndexB, ptr noundef %rigidBodies, ptr noundef %collidables, ptr noundef %convexShapes, ptr noundef nonnull align 8 dereferenceable(25) %vertices, ptr noundef nonnull align 8 dereferenceable(25) %aabbsWorldSpace, ptr noundef nonnull align 8 dereferenceable(25) %aabbsLocalSpace, ptr noundef %gpuChildShapes, ptr noundef %gpuCompoundPairsOut, ptr noundef %numCompoundPairsOut, i32 noundef %maxNumCompoundPairsCapacity, ptr noundef nonnull align 8 dereferenceable(25) %treeNodesCPU, ptr noundef nonnull align 8 dereferenceable(25) %subTreesCPU, ptr noundef nonnull align 8 dereferenceable(25) %bvhInfoCPU) #2 personality ptr @__gxx_personality_v0 {
entry:
  %pairIndex.addr = alloca i32, align 4
  %bodyIndexA.addr = alloca i32, align 4
  %bodyIndexB.addr = alloca i32, align 4
  %collidableIndexA.addr = alloca i32, align 4
  %collidableIndexB.addr = alloca i32, align 4
  %rigidBodies.addr = alloca ptr, align 8
  %collidables.addr = alloca ptr, align 8
  %convexShapes.addr = alloca ptr, align 8
  %vertices.addr = alloca ptr, align 8
  %aabbsWorldSpace.addr = alloca ptr, align 8
  %aabbsLocalSpace.addr = alloca ptr, align 8
  %gpuChildShapes.addr = alloca ptr, align 8
  %gpuCompoundPairsOut.addr = alloca ptr, align 8
  %numCompoundPairsOut.addr = alloca ptr, align 8
  %maxNumCompoundPairsCapacity.addr = alloca i32, align 4
  %treeNodesCPU.addr = alloca ptr, align 8
  %subTreesCPU.addr = alloca ptr, align 8
  %bvhInfoCPU.addr = alloca ptr, align 8
  %shapeIndexA = alloca i32, align 4
  %shapeIndexB = alloca i32, align 4
  %bvhA = alloca i32, align 4
  %bvhB = alloca i32, align 4
  %numSubTreesA = alloca i32, align 4
  %subTreesOffsetA = alloca i32, align 4
  %subTreesOffsetB = alloca i32, align 4
  %numSubTreesB = alloca i32, align 4
  %posA = alloca %class.b3Vector3, align 16
  %ornA = alloca %class.b3Quaternion, align 16
  %transA = alloca %class.b3Transform, align 16
  %ornB = alloca %class.b3Quaternion, align 16
  %posB = alloca %class.b3Vector3, align 16
  %transB = alloca %class.b3Transform, align 16
  %p = alloca i32, align 4
  %subtreeA = alloca %class.b3BvhSubtreeInfo, align 16
  %treeAminLocal = alloca %class.b3Vector3, align 16
  %treeAmaxLocal = alloca %class.b3Vector3, align 16
  %aabbAMinOut = alloca %class.b3Vector3, align 16
  %aabbAMaxOut = alloca %class.b3Vector3, align 16
  %margin = alloca float, align 4
  %ref.tmp = alloca %class.b3Quaternion, align 16
  %q = alloca i32, align 4
  %subtreeB = alloca %class.b3BvhSubtreeInfo, align 16
  %treeBminLocal = alloca %class.b3Vector3, align 16
  %treeBmaxLocal = alloca %class.b3Vector3, align 16
  %aabbBMinOut = alloca %class.b3Vector3, align 16
  %aabbBMaxOut = alloca %class.b3Vector3, align 16
  %margin79 = alloca float, align 4
  %ref.tmp81 = alloca %class.b3Quaternion, align 16
  %aabbOverlap = alloca i8, align 1
  %startNodeIndexA = alloca i32, align 4
  %startNodeIndexB = alloca i32, align 4
  %nodeStack = alloca %class.b3AlignedObjectArray.51, align 8
  %node0 = alloca %struct.b3Int2, align 4
  %maxStackDepth = alloca i32, align 4
  %ref.tmp94 = alloca %struct.b3Int2, align 4
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %depth = alloca i32, align 4
  %node = alloca %struct.b3Int2, align 4
  %aMinLocal = alloca %class.b3Vector3, align 16
  %aMaxLocal = alloca %class.b3Vector3, align 16
  %bMinLocal = alloca %class.b3Vector3, align 16
  %bMaxLocal = alloca %class.b3Vector3, align 16
  %margin164 = alloca float, align 4
  %aabbAMinOut165 = alloca %class.b3Vector3, align 16
  %aabbAMaxOut166 = alloca %class.b3Vector3, align 16
  %ref.tmp169 = alloca %class.b3Quaternion, align 16
  %aabbBMinOut176 = alloca %class.b3Vector3, align 16
  %aabbBMaxOut177 = alloca %class.b3Vector3, align 16
  %ref.tmp180 = alloca %class.b3Quaternion, align 16
  %nodeOverlap = alloca i8, align 1
  %isLeafA = alloca i8, align 1
  %isLeafB = alloca i8, align 1
  %isInternalA = alloca i8, align 1
  %isInternalB = alloca i8, align 1
  %nodeAleftChild = alloca i32, align 4
  %isNodeALeftChildLeaf = alloca i8, align 1
  %nodeArightChild = alloca i32, align 4
  %nodeBleftChild = alloca i32, align 4
  %isNodeBLeftChildLeaf = alloca i8, align 1
  %nodeBrightChild = alloca i32, align 4
  %ref.tmp271 = alloca %struct.b3Int2, align 4
  %ref.tmp279 = alloca %struct.b3Int2, align 4
  %ref.tmp287 = alloca %struct.b3Int2, align 4
  %ref.tmp295 = alloca %struct.b3Int2, align 4
  %ref.tmp303 = alloca %struct.b3Int2, align 4
  %ref.tmp312 = alloca %struct.b3Int2, align 4
  %nodeBleftChild325 = alloca i32, align 4
  %isNodeBLeftChildLeaf328 = alloca i8, align 1
  %nodeBrightChild336 = alloca i32, align 4
  %ref.tmp353 = alloca %struct.b3Int2, align 4
  %ref.tmp362 = alloca %struct.b3Int2, align 4
  %compoundPairIdx = alloca i32, align 4
  %childShapeIndexA = alloca i32, align 4
  %childShapeIndexB = alloca i32, align 4
  %ref.tmp385 = alloca %struct.b3Int4, align 16
  %numChildrenA = alloca i32, align 4
  %c = alloca i32, align 4
  %childShapeIndexA426 = alloca i32, align 4
  %childColIndexA = alloca i32, align 4
  %posA432 = alloca %class.b3Vector3, align 16
  %ornA436 = alloca %class.b3Quaternion, align 16
  %childPosA = alloca %class.b3Vector3, align 16
  %childOrnA = alloca %class.b3Quaternion, align 16
  %newPosA = alloca %class.b3Vector3, align 16
  %ref.tmp444 = alloca %class.b3Vector3, align 16
  %newOrnA = alloca %class.b3Quaternion, align 16
  %aabbA = alloca %struct.b3Aabb, align 16
  %transA456 = alloca %class.b3Transform, align 16
  %margin457 = alloca float, align 4
  %aabbAMinOut458 = alloca %class.b3Vector3, align 16
  %aabbAMaxOut459 = alloca %class.b3Vector3, align 16
  %ref.tmp461 = alloca %class.b3Quaternion, align 16
  %numChildrenB = alloca i32, align 4
  %b = alloca i32, align 4
  %childShapeIndexB476 = alloca i32, align 4
  %childColIndexB = alloca i32, align 4
  %ornB482 = alloca %class.b3Quaternion, align 16
  %posB486 = alloca %class.b3Vector3, align 16
  %childPosB = alloca %class.b3Vector3, align 16
  %childOrnB = alloca %class.b3Quaternion, align 16
  %newPosB = alloca %class.b3Vector3, align 16
  %newOrnB = alloca %class.b3Quaternion, align 16
  %aabbB = alloca %struct.b3Aabb, align 16
  %transB504 = alloca %class.b3Transform, align 16
  %aabbBMinOut505 = alloca %class.b3Vector3, align 16
  %aabbBMaxOut506 = alloca %class.b3Vector3, align 16
  %ref.tmp508 = alloca %class.b3Quaternion, align 16
  %aabbOverlap514 = alloca i8, align 1
  %compoundPairIdx519 = alloca i32, align 4
  %ref.tmp523 = alloca %struct.b3Int4, align 16
  %posA535 = alloca %class.b3Vector3, align 16
  %posB536 = alloca %class.b3Vector3, align 16
  %c0local = alloca %class.b3Vector3, align 16
  %ornA543 = alloca %class.b3Quaternion, align 16
  %c0 = alloca %class.b3Vector3, align 16
  %ref.tmp544 = alloca %class.b3Vector3, align 16
  %c1local = alloca %class.b3Vector3, align 16
  %ornB551 = alloca %class.b3Quaternion, align 16
  %c1 = alloca %class.b3Vector3, align 16
  %ref.tmp555 = alloca %class.b3Vector3, align 16
  %compoundPairIdx559 = alloca i32, align 4
  %ref.tmp563 = alloca %struct.b3Int4, align 16
  %numChildrenB585 = alloca i32, align 4
  %b588 = alloca i32, align 4
  %childShapeIndexB592 = alloca i32, align 4
  %childColIndexB596 = alloca i32, align 4
  %ornB599 = alloca %class.b3Quaternion, align 16
  %posB603 = alloca %class.b3Vector3, align 16
  %childPosB607 = alloca %class.b3Vector3, align 16
  %childOrnB611 = alloca %class.b3Quaternion, align 16
  %newPosB615 = alloca %class.b3Vector3, align 16
  %ref.tmp616 = alloca %class.b3Vector3, align 16
  %newOrnB623 = alloca %class.b3Quaternion, align 16
  %shapeIndexB628 = alloca i32, align 4
  %posA631 = alloca %class.b3Vector3, align 16
  %posB636 = alloca %class.b3Vector3, align 16
  %c0local638 = alloca %class.b3Vector3, align 16
  %ornA642 = alloca %class.b3Quaternion, align 16
  %c0646 = alloca %class.b3Vector3, align 16
  %ref.tmp647 = alloca %class.b3Vector3, align 16
  %c1local651 = alloca %class.b3Vector3, align 16
  %ornB655 = alloca %class.b3Quaternion, align 16
  %c1656 = alloca %class.b3Vector3, align 16
  %ref.tmp657 = alloca %class.b3Vector3, align 16
  %compoundPairIdx661 = alloca i32, align 4
  %ref.tmp665 = alloca %struct.b3Int4, align 16
  store i32 %pairIndex, ptr %pairIndex.addr, align 4
  store i32 %bodyIndexA, ptr %bodyIndexA.addr, align 4
  store i32 %bodyIndexB, ptr %bodyIndexB.addr, align 4
  store i32 %collidableIndexA, ptr %collidableIndexA.addr, align 4
  store i32 %collidableIndexB, ptr %collidableIndexB.addr, align 4
  store ptr %rigidBodies, ptr %rigidBodies.addr, align 8
  store ptr %collidables, ptr %collidables.addr, align 8
  store ptr %convexShapes, ptr %convexShapes.addr, align 8
  store ptr %vertices, ptr %vertices.addr, align 8
  store ptr %aabbsWorldSpace, ptr %aabbsWorldSpace.addr, align 8
  store ptr %aabbsLocalSpace, ptr %aabbsLocalSpace.addr, align 8
  store ptr %gpuChildShapes, ptr %gpuChildShapes.addr, align 8
  store ptr %gpuCompoundPairsOut, ptr %gpuCompoundPairsOut.addr, align 8
  store ptr %numCompoundPairsOut, ptr %numCompoundPairsOut.addr, align 8
  store i32 %maxNumCompoundPairsCapacity, ptr %maxNumCompoundPairsCapacity.addr, align 4
  store ptr %treeNodesCPU, ptr %treeNodesCPU.addr, align 8
  store ptr %subTreesCPU, ptr %subTreesCPU.addr, align 8
  store ptr %bvhInfoCPU, ptr %bvhInfoCPU.addr, align 8
  store i32 0, ptr @numAabbChecks, align 4
  store i32 0, ptr @maxNumAabbChecks, align 4
  %0 = load ptr, ptr %collidables.addr, align 8
  %1 = load i32, ptr %collidableIndexA.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3Collidable, ptr %0, i64 %idxprom
  %2 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx, i32 0, i32 3
  %3 = load i32, ptr %2, align 4
  store i32 %3, ptr %shapeIndexA, align 4
  %4 = load ptr, ptr %collidables.addr, align 8
  %5 = load i32, ptr %collidableIndexB.addr, align 4
  %idxprom1 = sext i32 %5 to i64
  %arrayidx2 = getelementptr inbounds %struct.b3Collidable, ptr %4, i64 %idxprom1
  %6 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx2, i32 0, i32 3
  %7 = load i32, ptr %6, align 4
  store i32 %7, ptr %shapeIndexB, align 4
  %8 = load ptr, ptr %rigidBodies.addr, align 8
  %9 = load i32, ptr %bodyIndexA.addr, align 4
  %idxprom3 = sext i32 %9 to i64
  %arrayidx4 = getelementptr inbounds %struct.b3RigidBodyData, ptr %8, i64 %idxprom3
  %m_invMass = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx4, i32 0, i32 5
  %10 = load float, ptr %m_invMass, align 4
  %cmp = fcmp oeq float %10, 0.000000e+00
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %11 = load ptr, ptr %rigidBodies.addr, align 8
  %12 = load i32, ptr %bodyIndexB.addr, align 4
  %idxprom5 = sext i32 %12 to i64
  %arrayidx6 = getelementptr inbounds %struct.b3RigidBodyData, ptr %11, i64 %idxprom5
  %m_invMass7 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx6, i32 0, i32 5
  %13 = load float, ptr %m_invMass7, align 4
  %cmp8 = fcmp oeq float %13, 0.000000e+00
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %if.end676

if.end:                                           ; preds = %land.lhs.true, %entry
  %14 = load ptr, ptr %collidables.addr, align 8
  %15 = load i32, ptr %collidableIndexA.addr, align 4
  %idxprom9 = sext i32 %15 to i64
  %arrayidx10 = getelementptr inbounds %struct.b3Collidable, ptr %14, i64 %idxprom9
  %m_shapeType = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx10, i32 0, i32 2
  %16 = load i32, ptr %m_shapeType, align 4
  %cmp11 = icmp eq i32 %16, 6
  br i1 %cmp11, label %land.lhs.true12, label %if.end406

land.lhs.true12:                                  ; preds = %if.end
  %17 = load ptr, ptr %collidables.addr, align 8
  %18 = load i32, ptr %collidableIndexB.addr, align 4
  %idxprom13 = sext i32 %18 to i64
  %arrayidx14 = getelementptr inbounds %struct.b3Collidable, ptr %17, i64 %idxprom13
  %m_shapeType15 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx14, i32 0, i32 2
  %19 = load i32, ptr %m_shapeType15, align 4
  %cmp16 = icmp eq i32 %19, 6
  br i1 %cmp16, label %if.then17, label %if.end406

if.then17:                                        ; preds = %land.lhs.true12
  %20 = load ptr, ptr %collidables.addr, align 8
  %21 = load i32, ptr %collidableIndexA.addr, align 4
  %idxprom18 = sext i32 %21 to i64
  %arrayidx19 = getelementptr inbounds %struct.b3Collidable, ptr %20, i64 %idxprom18
  %22 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx19, i32 0, i32 1
  %23 = load i32, ptr %22, align 4
  store i32 %23, ptr %bvhA, align 4
  %24 = load ptr, ptr %collidables.addr, align 8
  %25 = load i32, ptr %collidableIndexB.addr, align 4
  %idxprom20 = sext i32 %25 to i64
  %arrayidx21 = getelementptr inbounds %struct.b3Collidable, ptr %24, i64 %idxprom20
  %26 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx21, i32 0, i32 1
  %27 = load i32, ptr %26, align 4
  store i32 %27, ptr %bvhB, align 4
  %28 = load ptr, ptr %bvhInfoCPU.addr, align 8
  %29 = load i32, ptr %bvhA, align 4
  %call = call noundef nonnull align 16 dereferenceable(64) ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %28, i32 noundef %29)
  %m_numSubTrees = getelementptr inbounds %struct.b3BvhInfo, ptr %call, i32 0, i32 4
  %30 = load i32, ptr %m_numSubTrees, align 4
  store i32 %30, ptr %numSubTreesA, align 4
  %31 = load ptr, ptr %bvhInfoCPU.addr, align 8
  %32 = load i32, ptr %bvhA, align 4
  %call22 = call noundef nonnull align 16 dereferenceable(64) ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %31, i32 noundef %32)
  %m_subTreeOffset = getelementptr inbounds %struct.b3BvhInfo, ptr %call22, i32 0, i32 6
  %33 = load i32, ptr %m_subTreeOffset, align 4
  store i32 %33, ptr %subTreesOffsetA, align 4
  %34 = load ptr, ptr %bvhInfoCPU.addr, align 8
  %35 = load i32, ptr %bvhB, align 4
  %call23 = call noundef nonnull align 16 dereferenceable(64) ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %34, i32 noundef %35)
  %m_subTreeOffset24 = getelementptr inbounds %struct.b3BvhInfo, ptr %call23, i32 0, i32 6
  %36 = load i32, ptr %m_subTreeOffset24, align 4
  store i32 %36, ptr %subTreesOffsetB, align 4
  %37 = load ptr, ptr %bvhInfoCPU.addr, align 8
  %38 = load i32, ptr %bvhB, align 4
  %call25 = call noundef nonnull align 16 dereferenceable(64) ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %37, i32 noundef %38)
  %m_numSubTrees26 = getelementptr inbounds %struct.b3BvhInfo, ptr %call25, i32 0, i32 4
  %39 = load i32, ptr %m_numSubTrees26, align 4
  store i32 %39, ptr %numSubTreesB, align 4
  %40 = load ptr, ptr %rigidBodies.addr, align 8
  %41 = load i32, ptr %bodyIndexA.addr, align 4
  %idxprom27 = sext i32 %41 to i64
  %arrayidx28 = getelementptr inbounds %struct.b3RigidBodyData, ptr %40, i64 %idxprom27
  %m_pos = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx28, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posA, ptr align 16 %m_pos, i64 16, i1 false)
  %42 = load ptr, ptr %rigidBodies.addr, align 8
  %43 = load i32, ptr %bodyIndexA.addr, align 4
  %idxprom29 = sext i32 %43 to i64
  %arrayidx30 = getelementptr inbounds %struct.b3RigidBodyData, ptr %42, i64 %idxprom29
  %m_quat = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx30, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornA, ptr align 16 %m_quat, i64 16, i1 false)
  call void @_ZN11b3TransformC2Ev(ptr noundef nonnull align 16 dereferenceable(64) %transA)
  call void @_ZN11b3Transform11setIdentityEv(ptr noundef nonnull align 16 dereferenceable(64) %transA)
  call void @_ZN11b3Transform9setOriginERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %transA, ptr noundef nonnull align 16 dereferenceable(16) %posA)
  call void @_ZN11b3Transform11setRotationERK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(64) %transA, ptr noundef nonnull align 16 dereferenceable(16) %ornA)
  %44 = load ptr, ptr %rigidBodies.addr, align 8
  %45 = load i32, ptr %bodyIndexB.addr, align 4
  %idxprom31 = sext i32 %45 to i64
  %arrayidx32 = getelementptr inbounds %struct.b3RigidBodyData, ptr %44, i64 %idxprom31
  %m_quat33 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx32, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornB, ptr align 16 %m_quat33, i64 16, i1 false)
  %46 = load ptr, ptr %rigidBodies.addr, align 8
  %47 = load i32, ptr %bodyIndexB.addr, align 4
  %idxprom34 = sext i32 %47 to i64
  %arrayidx35 = getelementptr inbounds %struct.b3RigidBodyData, ptr %46, i64 %idxprom34
  %m_pos36 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx35, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posB, ptr align 16 %m_pos36, i64 16, i1 false)
  call void @_ZN11b3TransformC2Ev(ptr noundef nonnull align 16 dereferenceable(64) %transB)
  call void @_ZN11b3Transform11setIdentityEv(ptr noundef nonnull align 16 dereferenceable(64) %transB)
  call void @_ZN11b3Transform9setOriginERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %transB, ptr noundef nonnull align 16 dereferenceable(16) %posB)
  call void @_ZN11b3Transform11setRotationERK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(64) %transB, ptr noundef nonnull align 16 dereferenceable(16) %ornB)
  store i32 0, ptr %p, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc403, %if.then17
  %48 = load i32, ptr %p, align 4
  %49 = load i32, ptr %numSubTreesA, align 4
  %cmp37 = icmp slt i32 %48, %49
  br i1 %cmp37, label %for.body, label %for.end405

for.body:                                         ; preds = %for.cond
  %50 = load ptr, ptr %subTreesCPU.addr, align 8
  %51 = load i32, ptr %subTreesOffsetA, align 4
  %52 = load i32, ptr %p, align 4
  %add = add nsw i32 %51, %52
  %call38 = call noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %50, i32 noundef %add)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %subtreeA, ptr align 16 %call38, i64 32, i1 false)
  %m_quantizedAabbMin = getelementptr inbounds %struct.b3BvhSubtreeInfoData, ptr %subtreeA, i32 0, i32 0
  %arraydecay = getelementptr inbounds [3 x i16], ptr %m_quantizedAabbMin, i64 0, i64 0
  %53 = load ptr, ptr %bvhInfoCPU.addr, align 8
  %54 = load i32, ptr %bvhA, align 4
  %call39 = call noundef nonnull align 16 dereferenceable(64) ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %53, i32 noundef %54)
  %m_quantization = getelementptr inbounds %struct.b3BvhInfo, ptr %call39, i32 0, i32 2
  %55 = load ptr, ptr %bvhInfoCPU.addr, align 8
  %56 = load i32, ptr %bvhA, align 4
  %call40 = call noundef nonnull align 16 dereferenceable(64) ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %55, i32 noundef %56)
  %m_aabbMin = getelementptr inbounds %struct.b3BvhInfo, ptr %call40, i32 0, i32 0
  %call41 = call { <2 x float>, <2 x float> } @_Z12MyUnQuantizePKtRK9b3Vector3S3_(ptr noundef %arraydecay, ptr noundef nonnull align 16 dereferenceable(16) %m_quantization, ptr noundef nonnull align 16 dereferenceable(16) %m_aabbMin)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %treeAminLocal, i32 0, i32 0
  %coerce.dive42 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %57 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive42, i32 0, i32 0
  %58 = extractvalue { <2 x float>, <2 x float> } %call41, 0
  store <2 x float> %58, ptr %57, align 16
  %59 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive42, i32 0, i32 1
  %60 = extractvalue { <2 x float>, <2 x float> } %call41, 1
  store <2 x float> %60, ptr %59, align 8
  %m_quantizedAabbMax = getelementptr inbounds %struct.b3BvhSubtreeInfoData, ptr %subtreeA, i32 0, i32 1
  %arraydecay43 = getelementptr inbounds [3 x i16], ptr %m_quantizedAabbMax, i64 0, i64 0
  %61 = load ptr, ptr %bvhInfoCPU.addr, align 8
  %62 = load i32, ptr %bvhA, align 4
  %call44 = call noundef nonnull align 16 dereferenceable(64) ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %61, i32 noundef %62)
  %m_quantization45 = getelementptr inbounds %struct.b3BvhInfo, ptr %call44, i32 0, i32 2
  %63 = load ptr, ptr %bvhInfoCPU.addr, align 8
  %64 = load i32, ptr %bvhA, align 4
  %call46 = call noundef nonnull align 16 dereferenceable(64) ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %63, i32 noundef %64)
  %m_aabbMin47 = getelementptr inbounds %struct.b3BvhInfo, ptr %call46, i32 0, i32 0
  %call48 = call { <2 x float>, <2 x float> } @_Z12MyUnQuantizePKtRK9b3Vector3S3_(ptr noundef %arraydecay43, ptr noundef nonnull align 16 dereferenceable(16) %m_quantization45, ptr noundef nonnull align 16 dereferenceable(16) %m_aabbMin47)
  %coerce.dive49 = getelementptr inbounds %class.b3Vector3, ptr %treeAmaxLocal, i32 0, i32 0
  %coerce.dive50 = getelementptr inbounds %union.anon.1, ptr %coerce.dive49, i32 0, i32 0
  %65 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive50, i32 0, i32 0
  %66 = extractvalue { <2 x float>, <2 x float> } %call48, 0
  store <2 x float> %66, ptr %65, align 16
  %67 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive50, i32 0, i32 1
  %68 = extractvalue { <2 x float>, <2 x float> } %call48, 1
  store <2 x float> %68, ptr %67, align 8
  store float 0.000000e+00, ptr %margin, align 4
  %69 = load float, ptr %margin, align 4
  %call51 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN11b3Transform9getOriginEv(ptr noundef nonnull align 16 dereferenceable(64) %transA)
  %call52 = call { <2 x float>, <2 x float> } @_ZNK11b3Transform11getRotationEv(ptr noundef nonnull align 16 dereferenceable(64) %transA)
  %coerce.dive53 = getelementptr inbounds %class.b3Quaternion, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive54 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive53, i32 0, i32 0
  %coerce.dive55 = getelementptr inbounds %union.anon.3, ptr %coerce.dive54, i32 0, i32 0
  %70 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive55, i32 0, i32 0
  %71 = extractvalue { <2 x float>, <2 x float> } %call52, 0
  store <2 x float> %71, ptr %70, align 16
  %72 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive55, i32 0, i32 1
  %73 = extractvalue { <2 x float>, <2 x float> } %call52, 1
  store <2 x float> %73, ptr %72, align 8
  call void @_Z16b3TransformAabb2RK9b3Vector3S1_fS1_RK12b3QuaternionPS_S5_(ptr noundef nonnull align 16 dereferenceable(16) %treeAminLocal, ptr noundef nonnull align 16 dereferenceable(16) %treeAmaxLocal, float noundef %69, ptr noundef nonnull align 16 dereferenceable(16) %call51, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp, ptr noundef %aabbAMinOut, ptr noundef %aabbAMaxOut)
  store i32 0, ptr %q, align 4
  br label %for.cond56

for.cond56:                                       ; preds = %for.inc, %for.body
  %74 = load i32, ptr %q, align 4
  %75 = load i32, ptr %numSubTreesB, align 4
  %cmp57 = icmp slt i32 %74, %75
  br i1 %cmp57, label %for.body58, label %for.end

for.body58:                                       ; preds = %for.cond56
  %76 = load ptr, ptr %subTreesCPU.addr, align 8
  %77 = load i32, ptr %subTreesOffsetB, align 4
  %78 = load i32, ptr %q, align 4
  %add59 = add nsw i32 %77, %78
  %call60 = call noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %76, i32 noundef %add59)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %subtreeB, ptr align 16 %call60, i64 32, i1 false)
  %m_quantizedAabbMin61 = getelementptr inbounds %struct.b3BvhSubtreeInfoData, ptr %subtreeB, i32 0, i32 0
  %arraydecay62 = getelementptr inbounds [3 x i16], ptr %m_quantizedAabbMin61, i64 0, i64 0
  %79 = load ptr, ptr %bvhInfoCPU.addr, align 8
  %80 = load i32, ptr %bvhB, align 4
  %call63 = call noundef nonnull align 16 dereferenceable(64) ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %79, i32 noundef %80)
  %m_quantization64 = getelementptr inbounds %struct.b3BvhInfo, ptr %call63, i32 0, i32 2
  %81 = load ptr, ptr %bvhInfoCPU.addr, align 8
  %82 = load i32, ptr %bvhB, align 4
  %call65 = call noundef nonnull align 16 dereferenceable(64) ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %81, i32 noundef %82)
  %m_aabbMin66 = getelementptr inbounds %struct.b3BvhInfo, ptr %call65, i32 0, i32 0
  %call67 = call { <2 x float>, <2 x float> } @_Z12MyUnQuantizePKtRK9b3Vector3S3_(ptr noundef %arraydecay62, ptr noundef nonnull align 16 dereferenceable(16) %m_quantization64, ptr noundef nonnull align 16 dereferenceable(16) %m_aabbMin66)
  %coerce.dive68 = getelementptr inbounds %class.b3Vector3, ptr %treeBminLocal, i32 0, i32 0
  %coerce.dive69 = getelementptr inbounds %union.anon.1, ptr %coerce.dive68, i32 0, i32 0
  %83 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive69, i32 0, i32 0
  %84 = extractvalue { <2 x float>, <2 x float> } %call67, 0
  store <2 x float> %84, ptr %83, align 16
  %85 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive69, i32 0, i32 1
  %86 = extractvalue { <2 x float>, <2 x float> } %call67, 1
  store <2 x float> %86, ptr %85, align 8
  %m_quantizedAabbMax70 = getelementptr inbounds %struct.b3BvhSubtreeInfoData, ptr %subtreeB, i32 0, i32 1
  %arraydecay71 = getelementptr inbounds [3 x i16], ptr %m_quantizedAabbMax70, i64 0, i64 0
  %87 = load ptr, ptr %bvhInfoCPU.addr, align 8
  %88 = load i32, ptr %bvhB, align 4
  %call72 = call noundef nonnull align 16 dereferenceable(64) ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %87, i32 noundef %88)
  %m_quantization73 = getelementptr inbounds %struct.b3BvhInfo, ptr %call72, i32 0, i32 2
  %89 = load ptr, ptr %bvhInfoCPU.addr, align 8
  %90 = load i32, ptr %bvhB, align 4
  %call74 = call noundef nonnull align 16 dereferenceable(64) ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %89, i32 noundef %90)
  %m_aabbMin75 = getelementptr inbounds %struct.b3BvhInfo, ptr %call74, i32 0, i32 0
  %call76 = call { <2 x float>, <2 x float> } @_Z12MyUnQuantizePKtRK9b3Vector3S3_(ptr noundef %arraydecay71, ptr noundef nonnull align 16 dereferenceable(16) %m_quantization73, ptr noundef nonnull align 16 dereferenceable(16) %m_aabbMin75)
  %coerce.dive77 = getelementptr inbounds %class.b3Vector3, ptr %treeBmaxLocal, i32 0, i32 0
  %coerce.dive78 = getelementptr inbounds %union.anon.1, ptr %coerce.dive77, i32 0, i32 0
  %91 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive78, i32 0, i32 0
  %92 = extractvalue { <2 x float>, <2 x float> } %call76, 0
  store <2 x float> %92, ptr %91, align 16
  %93 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive78, i32 0, i32 1
  %94 = extractvalue { <2 x float>, <2 x float> } %call76, 1
  store <2 x float> %94, ptr %93, align 8
  store float 0.000000e+00, ptr %margin79, align 4
  %95 = load float, ptr %margin79, align 4
  %call80 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN11b3Transform9getOriginEv(ptr noundef nonnull align 16 dereferenceable(64) %transB)
  %call82 = call { <2 x float>, <2 x float> } @_ZNK11b3Transform11getRotationEv(ptr noundef nonnull align 16 dereferenceable(64) %transB)
  %coerce.dive83 = getelementptr inbounds %class.b3Quaternion, ptr %ref.tmp81, i32 0, i32 0
  %coerce.dive84 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive83, i32 0, i32 0
  %coerce.dive85 = getelementptr inbounds %union.anon.3, ptr %coerce.dive84, i32 0, i32 0
  %96 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive85, i32 0, i32 0
  %97 = extractvalue { <2 x float>, <2 x float> } %call82, 0
  store <2 x float> %97, ptr %96, align 16
  %98 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive85, i32 0, i32 1
  %99 = extractvalue { <2 x float>, <2 x float> } %call82, 1
  store <2 x float> %99, ptr %98, align 8
  call void @_Z16b3TransformAabb2RK9b3Vector3S1_fS1_RK12b3QuaternionPS_S5_(ptr noundef nonnull align 16 dereferenceable(16) %treeBminLocal, ptr noundef nonnull align 16 dereferenceable(16) %treeBmaxLocal, float noundef %95, ptr noundef nonnull align 16 dereferenceable(16) %call80, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp81, ptr noundef %aabbBMinOut, ptr noundef %aabbBMaxOut)
  store i32 0, ptr @numAabbChecks, align 4
  %call86 = call noundef zeroext i1 @_Z21b3TestAabbAgainstAabbRK9b3Vector3S1_S1_S1_(ptr noundef nonnull align 16 dereferenceable(16) %aabbAMinOut, ptr noundef nonnull align 16 dereferenceable(16) %aabbAMaxOut, ptr noundef nonnull align 16 dereferenceable(16) %aabbBMinOut, ptr noundef nonnull align 16 dereferenceable(16) %aabbBMaxOut)
  %frombool = zext i1 %call86 to i8
  store i8 %frombool, ptr %aabbOverlap, align 1
  %100 = load i8, ptr %aabbOverlap, align 1
  %tobool = trunc i8 %100 to i1
  br i1 %tobool, label %if.then87, label %if.end401

if.then87:                                        ; preds = %for.body58
  %m_rootNodeIndex = getelementptr inbounds %struct.b3BvhSubtreeInfoData, ptr %subtreeA, i32 0, i32 2
  %101 = load i32, ptr %m_rootNodeIndex, align 4
  %102 = load ptr, ptr %bvhInfoCPU.addr, align 8
  %103 = load i32, ptr %bvhA, align 4
  %call88 = call noundef nonnull align 16 dereferenceable(64) ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %102, i32 noundef %103)
  %m_nodeOffset = getelementptr inbounds %struct.b3BvhInfo, ptr %call88, i32 0, i32 5
  %104 = load i32, ptr %m_nodeOffset, align 8
  %add89 = add nsw i32 %101, %104
  store i32 %add89, ptr %startNodeIndexA, align 4
  %m_rootNodeIndex90 = getelementptr inbounds %struct.b3BvhSubtreeInfoData, ptr %subtreeB, i32 0, i32 2
  %105 = load i32, ptr %m_rootNodeIndex90, align 4
  %106 = load ptr, ptr %bvhInfoCPU.addr, align 8
  %107 = load i32, ptr %bvhB, align 4
  %call91 = call noundef nonnull align 16 dereferenceable(64) ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %106, i32 noundef %107)
  %m_nodeOffset92 = getelementptr inbounds %struct.b3BvhInfo, ptr %call91, i32 0, i32 5
  %108 = load i32, ptr %m_nodeOffset92, align 8
  %add93 = add nsw i32 %105, %108
  store i32 %add93, ptr %startNodeIndexB, align 4
  call void @_ZN20b3AlignedObjectArrayI6b3Int2EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %nodeStack)
  %109 = load i32, ptr %startNodeIndexA, align 4
  %110 = getelementptr inbounds %struct.b3Int2, ptr %node0, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon.56, ptr %110, i32 0, i32 0
  store i32 %109, ptr %x, align 4
  %111 = load i32, ptr %startNodeIndexB, align 4
  %112 = getelementptr inbounds %struct.b3Int2, ptr %node0, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon.56, ptr %112, i32 0, i32 1
  store i32 %111, ptr %y, align 4
  store i32 1024, ptr %maxStackDepth, align 4
  %113 = load i32, ptr %maxStackDepth, align 4
  call void @llvm.memset.p0.i64(ptr align 4 %ref.tmp94, i8 0, i64 8, i1 false)
  invoke void @_ZN20b3AlignedObjectArrayI6b3Int2E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %nodeStack, i32 noundef %113, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp94)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %if.then87
  store i32 0, ptr %depth, align 4
  %114 = load i32, ptr %depth, align 4
  %inc = add nsw i32 %114, 1
  store i32 %inc, ptr %depth, align 4
  %call96 = invoke noundef nonnull align 4 dereferenceable(8) ptr @_ZN20b3AlignedObjectArrayI6b3Int2EixEi(ptr noundef nonnull align 8 dereferenceable(25) %nodeStack, i32 noundef %114)
          to label %invoke.cont95 unwind label %lpad

invoke.cont95:                                    ; preds = %invoke.cont
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %call96, ptr align 4 %node0, i64 8, i1 false)
  br label %do.body

do.body:                                          ; preds = %do.cond396, %invoke.cont95
  %115 = load i32, ptr %depth, align 4
  %116 = load i32, ptr @maxDepth, align 4
  %cmp97 = icmp sgt i32 %115, %116
  br i1 %cmp97, label %if.then98, label %if.end101

if.then98:                                        ; preds = %do.body
  %117 = load i32, ptr %depth, align 4
  store i32 %117, ptr @maxDepth, align 4
  %118 = load i32, ptr @maxDepth, align 4
  %call100 = invoke i32 (ptr, ...) @printf(ptr noundef @.str.35, i32 noundef %118)
          to label %invoke.cont99 unwind label %lpad

invoke.cont99:                                    ; preds = %if.then98
  br label %if.end101

lpad:                                             ; preds = %do.end398, %invoke.cont383, %invoke.cont381, %invoke.cont378, %invoke.cont376, %if.then374, %invoke.cont364, %invoke.cont360, %invoke.cont355, %cond.end351, %invoke.cont346, %cond.false341, %invoke.cont331, %if.then324, %invoke.cont314, %invoke.cont310, %invoke.cont305, %if.else, %invoke.cont296, %invoke.cont293, %invoke.cont288, %invoke.cont285, %invoke.cont280, %invoke.cont277, %invoke.cont272, %cond.end269, %invoke.cont264, %cond.false259, %invoke.cont250, %if.then245, %invoke.cont239, %cond.false, %invoke.cont227, %if.then222, %invoke.cont218, %do.body217, %invoke.cont200, %invoke.cont196, %invoke.cont194, %if.then192, %invoke.cont186, %invoke.cont181, %invoke.cont178, %invoke.cont175, %invoke.cont170, %invoke.cont167, %invoke.cont160, %invoke.cont157, %invoke.cont154, %invoke.cont150, %invoke.cont145, %invoke.cont142, %invoke.cont139, %invoke.cont135, %invoke.cont130, %invoke.cont127, %invoke.cont124, %invoke.cont120, %invoke.cont115, %invoke.cont112, %invoke.cont109, %invoke.cont105, %invoke.cont102, %if.end101, %if.then98, %invoke.cont, %if.then87
  %119 = landingpad { ptr, i32 }
          cleanup
  %120 = extractvalue { ptr, i32 } %119, 0
  store ptr %120, ptr %exn.slot, align 8
  %121 = extractvalue { ptr, i32 } %119, 1
  store i32 %121, ptr %ehselector.slot, align 4
  call void @_ZN20b3AlignedObjectArrayI6b3Int2ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %nodeStack) #13
  br label %eh.resume

if.end101:                                        ; preds = %invoke.cont99, %do.body
  %122 = load i32, ptr %depth, align 4
  %dec = add nsw i32 %122, -1
  store i32 %dec, ptr %depth, align 4
  %call103 = invoke noundef nonnull align 4 dereferenceable(8) ptr @_ZN20b3AlignedObjectArrayI6b3Int2EixEi(ptr noundef nonnull align 8 dereferenceable(25) %nodeStack, i32 noundef %dec)
          to label %invoke.cont102 unwind label %lpad

invoke.cont102:                                   ; preds = %if.end101
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %node, ptr align 4 %call103, i64 8, i1 false)
  %123 = load ptr, ptr %treeNodesCPU.addr, align 8
  %124 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %x104 = getelementptr inbounds %struct.anon.56, ptr %124, i32 0, i32 0
  %125 = load i32, ptr %x104, align 4
  %call106 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeEixEi(ptr noundef nonnull align 8 dereferenceable(25) %123, i32 noundef %125)
          to label %invoke.cont105 unwind label %lpad

invoke.cont105:                                   ; preds = %invoke.cont102
  %m_quantizedAabbMin107 = getelementptr inbounds %struct.b3QuantizedBvhNodeData, ptr %call106, i32 0, i32 0
  %arraydecay108 = getelementptr inbounds [3 x i16], ptr %m_quantizedAabbMin107, i64 0, i64 0
  %126 = load ptr, ptr %bvhInfoCPU.addr, align 8
  %127 = load i32, ptr %bvhA, align 4
  %call110 = invoke noundef nonnull align 16 dereferenceable(64) ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %126, i32 noundef %127)
          to label %invoke.cont109 unwind label %lpad

invoke.cont109:                                   ; preds = %invoke.cont105
  %m_quantization111 = getelementptr inbounds %struct.b3BvhInfo, ptr %call110, i32 0, i32 2
  %128 = load ptr, ptr %bvhInfoCPU.addr, align 8
  %129 = load i32, ptr %bvhA, align 4
  %call113 = invoke noundef nonnull align 16 dereferenceable(64) ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %128, i32 noundef %129)
          to label %invoke.cont112 unwind label %lpad

invoke.cont112:                                   ; preds = %invoke.cont109
  %m_aabbMin114 = getelementptr inbounds %struct.b3BvhInfo, ptr %call113, i32 0, i32 0
  %call116 = invoke { <2 x float>, <2 x float> } @_Z12MyUnQuantizePKtRK9b3Vector3S3_(ptr noundef %arraydecay108, ptr noundef nonnull align 16 dereferenceable(16) %m_quantization111, ptr noundef nonnull align 16 dereferenceable(16) %m_aabbMin114)
          to label %invoke.cont115 unwind label %lpad

invoke.cont115:                                   ; preds = %invoke.cont112
  %coerce.dive117 = getelementptr inbounds %class.b3Vector3, ptr %aMinLocal, i32 0, i32 0
  %coerce.dive118 = getelementptr inbounds %union.anon.1, ptr %coerce.dive117, i32 0, i32 0
  %130 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive118, i32 0, i32 0
  %131 = extractvalue { <2 x float>, <2 x float> } %call116, 0
  store <2 x float> %131, ptr %130, align 16
  %132 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive118, i32 0, i32 1
  %133 = extractvalue { <2 x float>, <2 x float> } %call116, 1
  store <2 x float> %133, ptr %132, align 8
  %134 = load ptr, ptr %treeNodesCPU.addr, align 8
  %135 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %x119 = getelementptr inbounds %struct.anon.56, ptr %135, i32 0, i32 0
  %136 = load i32, ptr %x119, align 4
  %call121 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeEixEi(ptr noundef nonnull align 8 dereferenceable(25) %134, i32 noundef %136)
          to label %invoke.cont120 unwind label %lpad

invoke.cont120:                                   ; preds = %invoke.cont115
  %m_quantizedAabbMax122 = getelementptr inbounds %struct.b3QuantizedBvhNodeData, ptr %call121, i32 0, i32 1
  %arraydecay123 = getelementptr inbounds [3 x i16], ptr %m_quantizedAabbMax122, i64 0, i64 0
  %137 = load ptr, ptr %bvhInfoCPU.addr, align 8
  %138 = load i32, ptr %bvhA, align 4
  %call125 = invoke noundef nonnull align 16 dereferenceable(64) ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %137, i32 noundef %138)
          to label %invoke.cont124 unwind label %lpad

invoke.cont124:                                   ; preds = %invoke.cont120
  %m_quantization126 = getelementptr inbounds %struct.b3BvhInfo, ptr %call125, i32 0, i32 2
  %139 = load ptr, ptr %bvhInfoCPU.addr, align 8
  %140 = load i32, ptr %bvhA, align 4
  %call128 = invoke noundef nonnull align 16 dereferenceable(64) ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %139, i32 noundef %140)
          to label %invoke.cont127 unwind label %lpad

invoke.cont127:                                   ; preds = %invoke.cont124
  %m_aabbMin129 = getelementptr inbounds %struct.b3BvhInfo, ptr %call128, i32 0, i32 0
  %call131 = invoke { <2 x float>, <2 x float> } @_Z12MyUnQuantizePKtRK9b3Vector3S3_(ptr noundef %arraydecay123, ptr noundef nonnull align 16 dereferenceable(16) %m_quantization126, ptr noundef nonnull align 16 dereferenceable(16) %m_aabbMin129)
          to label %invoke.cont130 unwind label %lpad

invoke.cont130:                                   ; preds = %invoke.cont127
  %coerce.dive132 = getelementptr inbounds %class.b3Vector3, ptr %aMaxLocal, i32 0, i32 0
  %coerce.dive133 = getelementptr inbounds %union.anon.1, ptr %coerce.dive132, i32 0, i32 0
  %141 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive133, i32 0, i32 0
  %142 = extractvalue { <2 x float>, <2 x float> } %call131, 0
  store <2 x float> %142, ptr %141, align 16
  %143 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive133, i32 0, i32 1
  %144 = extractvalue { <2 x float>, <2 x float> } %call131, 1
  store <2 x float> %144, ptr %143, align 8
  %145 = load ptr, ptr %treeNodesCPU.addr, align 8
  %146 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %y134 = getelementptr inbounds %struct.anon.56, ptr %146, i32 0, i32 1
  %147 = load i32, ptr %y134, align 4
  %call136 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeEixEi(ptr noundef nonnull align 8 dereferenceable(25) %145, i32 noundef %147)
          to label %invoke.cont135 unwind label %lpad

invoke.cont135:                                   ; preds = %invoke.cont130
  %m_quantizedAabbMin137 = getelementptr inbounds %struct.b3QuantizedBvhNodeData, ptr %call136, i32 0, i32 0
  %arraydecay138 = getelementptr inbounds [3 x i16], ptr %m_quantizedAabbMin137, i64 0, i64 0
  %148 = load ptr, ptr %bvhInfoCPU.addr, align 8
  %149 = load i32, ptr %bvhB, align 4
  %call140 = invoke noundef nonnull align 16 dereferenceable(64) ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %148, i32 noundef %149)
          to label %invoke.cont139 unwind label %lpad

invoke.cont139:                                   ; preds = %invoke.cont135
  %m_quantization141 = getelementptr inbounds %struct.b3BvhInfo, ptr %call140, i32 0, i32 2
  %150 = load ptr, ptr %bvhInfoCPU.addr, align 8
  %151 = load i32, ptr %bvhB, align 4
  %call143 = invoke noundef nonnull align 16 dereferenceable(64) ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %150, i32 noundef %151)
          to label %invoke.cont142 unwind label %lpad

invoke.cont142:                                   ; preds = %invoke.cont139
  %m_aabbMin144 = getelementptr inbounds %struct.b3BvhInfo, ptr %call143, i32 0, i32 0
  %call146 = invoke { <2 x float>, <2 x float> } @_Z12MyUnQuantizePKtRK9b3Vector3S3_(ptr noundef %arraydecay138, ptr noundef nonnull align 16 dereferenceable(16) %m_quantization141, ptr noundef nonnull align 16 dereferenceable(16) %m_aabbMin144)
          to label %invoke.cont145 unwind label %lpad

invoke.cont145:                                   ; preds = %invoke.cont142
  %coerce.dive147 = getelementptr inbounds %class.b3Vector3, ptr %bMinLocal, i32 0, i32 0
  %coerce.dive148 = getelementptr inbounds %union.anon.1, ptr %coerce.dive147, i32 0, i32 0
  %152 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive148, i32 0, i32 0
  %153 = extractvalue { <2 x float>, <2 x float> } %call146, 0
  store <2 x float> %153, ptr %152, align 16
  %154 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive148, i32 0, i32 1
  %155 = extractvalue { <2 x float>, <2 x float> } %call146, 1
  store <2 x float> %155, ptr %154, align 8
  %156 = load ptr, ptr %treeNodesCPU.addr, align 8
  %157 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %y149 = getelementptr inbounds %struct.anon.56, ptr %157, i32 0, i32 1
  %158 = load i32, ptr %y149, align 4
  %call151 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeEixEi(ptr noundef nonnull align 8 dereferenceable(25) %156, i32 noundef %158)
          to label %invoke.cont150 unwind label %lpad

invoke.cont150:                                   ; preds = %invoke.cont145
  %m_quantizedAabbMax152 = getelementptr inbounds %struct.b3QuantizedBvhNodeData, ptr %call151, i32 0, i32 1
  %arraydecay153 = getelementptr inbounds [3 x i16], ptr %m_quantizedAabbMax152, i64 0, i64 0
  %159 = load ptr, ptr %bvhInfoCPU.addr, align 8
  %160 = load i32, ptr %bvhB, align 4
  %call155 = invoke noundef nonnull align 16 dereferenceable(64) ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %159, i32 noundef %160)
          to label %invoke.cont154 unwind label %lpad

invoke.cont154:                                   ; preds = %invoke.cont150
  %m_quantization156 = getelementptr inbounds %struct.b3BvhInfo, ptr %call155, i32 0, i32 2
  %161 = load ptr, ptr %bvhInfoCPU.addr, align 8
  %162 = load i32, ptr %bvhB, align 4
  %call158 = invoke noundef nonnull align 16 dereferenceable(64) ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %161, i32 noundef %162)
          to label %invoke.cont157 unwind label %lpad

invoke.cont157:                                   ; preds = %invoke.cont154
  %m_aabbMin159 = getelementptr inbounds %struct.b3BvhInfo, ptr %call158, i32 0, i32 0
  %call161 = invoke { <2 x float>, <2 x float> } @_Z12MyUnQuantizePKtRK9b3Vector3S3_(ptr noundef %arraydecay153, ptr noundef nonnull align 16 dereferenceable(16) %m_quantization156, ptr noundef nonnull align 16 dereferenceable(16) %m_aabbMin159)
          to label %invoke.cont160 unwind label %lpad

invoke.cont160:                                   ; preds = %invoke.cont157
  %coerce.dive162 = getelementptr inbounds %class.b3Vector3, ptr %bMaxLocal, i32 0, i32 0
  %coerce.dive163 = getelementptr inbounds %union.anon.1, ptr %coerce.dive162, i32 0, i32 0
  %163 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive163, i32 0, i32 0
  %164 = extractvalue { <2 x float>, <2 x float> } %call161, 0
  store <2 x float> %164, ptr %163, align 16
  %165 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive163, i32 0, i32 1
  %166 = extractvalue { <2 x float>, <2 x float> } %call161, 1
  store <2 x float> %166, ptr %165, align 8
  store float 0.000000e+00, ptr %margin164, align 4
  %167 = load float, ptr %margin164, align 4
  %call168 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN11b3Transform9getOriginEv(ptr noundef nonnull align 16 dereferenceable(64) %transA)
          to label %invoke.cont167 unwind label %lpad

invoke.cont167:                                   ; preds = %invoke.cont160
  %call171 = invoke { <2 x float>, <2 x float> } @_ZNK11b3Transform11getRotationEv(ptr noundef nonnull align 16 dereferenceable(64) %transA)
          to label %invoke.cont170 unwind label %lpad

invoke.cont170:                                   ; preds = %invoke.cont167
  %coerce.dive172 = getelementptr inbounds %class.b3Quaternion, ptr %ref.tmp169, i32 0, i32 0
  %coerce.dive173 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive172, i32 0, i32 0
  %coerce.dive174 = getelementptr inbounds %union.anon.3, ptr %coerce.dive173, i32 0, i32 0
  %168 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive174, i32 0, i32 0
  %169 = extractvalue { <2 x float>, <2 x float> } %call171, 0
  store <2 x float> %169, ptr %168, align 16
  %170 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive174, i32 0, i32 1
  %171 = extractvalue { <2 x float>, <2 x float> } %call171, 1
  store <2 x float> %171, ptr %170, align 8
  invoke void @_Z16b3TransformAabb2RK9b3Vector3S1_fS1_RK12b3QuaternionPS_S5_(ptr noundef nonnull align 16 dereferenceable(16) %aMinLocal, ptr noundef nonnull align 16 dereferenceable(16) %aMaxLocal, float noundef %167, ptr noundef nonnull align 16 dereferenceable(16) %call168, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp169, ptr noundef %aabbAMinOut165, ptr noundef %aabbAMaxOut166)
          to label %invoke.cont175 unwind label %lpad

invoke.cont175:                                   ; preds = %invoke.cont170
  %172 = load float, ptr %margin164, align 4
  %call179 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN11b3Transform9getOriginEv(ptr noundef nonnull align 16 dereferenceable(64) %transB)
          to label %invoke.cont178 unwind label %lpad

invoke.cont178:                                   ; preds = %invoke.cont175
  %call182 = invoke { <2 x float>, <2 x float> } @_ZNK11b3Transform11getRotationEv(ptr noundef nonnull align 16 dereferenceable(64) %transB)
          to label %invoke.cont181 unwind label %lpad

invoke.cont181:                                   ; preds = %invoke.cont178
  %coerce.dive183 = getelementptr inbounds %class.b3Quaternion, ptr %ref.tmp180, i32 0, i32 0
  %coerce.dive184 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive183, i32 0, i32 0
  %coerce.dive185 = getelementptr inbounds %union.anon.3, ptr %coerce.dive184, i32 0, i32 0
  %173 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive185, i32 0, i32 0
  %174 = extractvalue { <2 x float>, <2 x float> } %call182, 0
  store <2 x float> %174, ptr %173, align 16
  %175 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive185, i32 0, i32 1
  %176 = extractvalue { <2 x float>, <2 x float> } %call182, 1
  store <2 x float> %176, ptr %175, align 8
  invoke void @_Z16b3TransformAabb2RK9b3Vector3S1_fS1_RK12b3QuaternionPS_S5_(ptr noundef nonnull align 16 dereferenceable(16) %bMinLocal, ptr noundef nonnull align 16 dereferenceable(16) %bMaxLocal, float noundef %172, ptr noundef nonnull align 16 dereferenceable(16) %call179, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp180, ptr noundef %aabbBMinOut176, ptr noundef %aabbBMaxOut177)
          to label %invoke.cont186 unwind label %lpad

invoke.cont186:                                   ; preds = %invoke.cont181
  %177 = load i32, ptr @numAabbChecks, align 4
  %inc187 = add nsw i32 %177, 1
  store i32 %inc187, ptr @numAabbChecks, align 4
  %call189 = invoke noundef zeroext i1 @_Z21b3TestAabbAgainstAabbRK9b3Vector3S1_S1_S1_(ptr noundef nonnull align 16 dereferenceable(16) %aabbAMinOut165, ptr noundef nonnull align 16 dereferenceable(16) %aabbAMaxOut166, ptr noundef nonnull align 16 dereferenceable(16) %aabbBMinOut176, ptr noundef nonnull align 16 dereferenceable(16) %aabbBMaxOut177)
          to label %invoke.cont188 unwind label %lpad

invoke.cont188:                                   ; preds = %invoke.cont186
  %frombool190 = zext i1 %call189 to i8
  store i8 %frombool190, ptr %nodeOverlap, align 1
  %178 = load i8, ptr %nodeOverlap, align 1
  %tobool191 = trunc i8 %178 to i1
  br i1 %tobool191, label %if.then192, label %if.end395

if.then192:                                       ; preds = %invoke.cont188
  %179 = load ptr, ptr %treeNodesCPU.addr, align 8
  %180 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %x193 = getelementptr inbounds %struct.anon.56, ptr %180, i32 0, i32 0
  %181 = load i32, ptr %x193, align 4
  %call195 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeEixEi(ptr noundef nonnull align 8 dereferenceable(25) %179, i32 noundef %181)
          to label %invoke.cont194 unwind label %lpad

invoke.cont194:                                   ; preds = %if.then192
  %call197 = invoke noundef zeroext i1 @_ZNK18b3QuantizedBvhNode10isLeafNodeEv(ptr noundef nonnull align 16 dereferenceable(16) %call195)
          to label %invoke.cont196 unwind label %lpad

invoke.cont196:                                   ; preds = %invoke.cont194
  %frombool198 = zext i1 %call197 to i8
  store i8 %frombool198, ptr %isLeafA, align 1
  %182 = load ptr, ptr %treeNodesCPU.addr, align 8
  %183 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %y199 = getelementptr inbounds %struct.anon.56, ptr %183, i32 0, i32 1
  %184 = load i32, ptr %y199, align 4
  %call201 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeEixEi(ptr noundef nonnull align 8 dereferenceable(25) %182, i32 noundef %184)
          to label %invoke.cont200 unwind label %lpad

invoke.cont200:                                   ; preds = %invoke.cont196
  %call203 = invoke noundef zeroext i1 @_ZNK18b3QuantizedBvhNode10isLeafNodeEv(ptr noundef nonnull align 16 dereferenceable(16) %call201)
          to label %invoke.cont202 unwind label %lpad

invoke.cont202:                                   ; preds = %invoke.cont200
  %frombool204 = zext i1 %call203 to i8
  store i8 %frombool204, ptr %isLeafB, align 1
  %185 = load i8, ptr %isLeafA, align 1
  %tobool205 = trunc i8 %185 to i1
  %lnot = xor i1 %tobool205, true
  %frombool206 = zext i1 %lnot to i8
  store i8 %frombool206, ptr %isInternalA, align 1
  %186 = load i8, ptr %isLeafB, align 1
  %tobool207 = trunc i8 %186 to i1
  %lnot208 = xor i1 %tobool207, true
  %frombool209 = zext i1 %lnot208 to i8
  store i8 %frombool209, ptr %isInternalB, align 1
  %187 = load i32, ptr %depth, align 4
  %add210 = add nsw i32 %187, 4
  %188 = load i32, ptr %maxStackDepth, align 4
  %cmp211 = icmp sgt i32 %add210, %188
  br i1 %cmp211, label %land.lhs.true212, label %if.end220

land.lhs.true212:                                 ; preds = %invoke.cont202
  %189 = load i8, ptr %isLeafA, align 1
  %tobool213 = trunc i8 %189 to i1
  br i1 %tobool213, label %land.lhs.true214, label %if.then216

land.lhs.true214:                                 ; preds = %land.lhs.true212
  %190 = load i8, ptr %isLeafB, align 1
  %tobool215 = trunc i8 %190 to i1
  br i1 %tobool215, label %if.end220, label %if.then216

if.then216:                                       ; preds = %land.lhs.true214, %land.lhs.true212
  br label %do.body217

do.body217:                                       ; preds = %if.then216
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.31, i32 noundef 1554)
          to label %invoke.cont218 unwind label %lpad

invoke.cont218:                                   ; preds = %do.body217
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.36)
          to label %invoke.cont219 unwind label %lpad

invoke.cont219:                                   ; preds = %invoke.cont218
  br label %do.cond

do.cond:                                          ; preds = %invoke.cont219
  br label %do.end

do.end:                                           ; preds = %do.cond
  br label %do.cond396

if.end220:                                        ; preds = %land.lhs.true214, %invoke.cont202
  %191 = load i8, ptr %isInternalA, align 1
  %tobool221 = trunc i8 %191 to i1
  br i1 %tobool221, label %if.then222, label %if.else322

if.then222:                                       ; preds = %if.end220
  %192 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %x223 = getelementptr inbounds %struct.anon.56, ptr %192, i32 0, i32 0
  %193 = load i32, ptr %x223, align 4
  %add224 = add nsw i32 %193, 1
  store i32 %add224, ptr %nodeAleftChild, align 4
  %194 = load ptr, ptr %treeNodesCPU.addr, align 8
  %195 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %x225 = getelementptr inbounds %struct.anon.56, ptr %195, i32 0, i32 0
  %196 = load i32, ptr %x225, align 4
  %add226 = add nsw i32 %196, 1
  %call228 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeEixEi(ptr noundef nonnull align 8 dereferenceable(25) %194, i32 noundef %add226)
          to label %invoke.cont227 unwind label %lpad

invoke.cont227:                                   ; preds = %if.then222
  %call230 = invoke noundef zeroext i1 @_ZNK18b3QuantizedBvhNode10isLeafNodeEv(ptr noundef nonnull align 16 dereferenceable(16) %call228)
          to label %invoke.cont229 unwind label %lpad

invoke.cont229:                                   ; preds = %invoke.cont227
  %frombool231 = zext i1 %call230 to i8
  store i8 %frombool231, ptr %isNodeALeftChildLeaf, align 1
  %197 = load i8, ptr %isNodeALeftChildLeaf, align 1
  %tobool232 = trunc i8 %197 to i1
  br i1 %tobool232, label %cond.true, label %cond.false

cond.true:                                        ; preds = %invoke.cont229
  %198 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %x233 = getelementptr inbounds %struct.anon.56, ptr %198, i32 0, i32 0
  %199 = load i32, ptr %x233, align 4
  %add234 = add nsw i32 %199, 2
  br label %cond.end

cond.false:                                       ; preds = %invoke.cont229
  %200 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %x235 = getelementptr inbounds %struct.anon.56, ptr %200, i32 0, i32 0
  %201 = load i32, ptr %x235, align 4
  %add236 = add nsw i32 %201, 1
  %202 = load ptr, ptr %treeNodesCPU.addr, align 8
  %203 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %x237 = getelementptr inbounds %struct.anon.56, ptr %203, i32 0, i32 0
  %204 = load i32, ptr %x237, align 4
  %add238 = add nsw i32 %204, 1
  %call240 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeEixEi(ptr noundef nonnull align 8 dereferenceable(25) %202, i32 noundef %add238)
          to label %invoke.cont239 unwind label %lpad

invoke.cont239:                                   ; preds = %cond.false
  %call242 = invoke noundef i32 @_ZNK18b3QuantizedBvhNode14getEscapeIndexEv(ptr noundef nonnull align 16 dereferenceable(16) %call240)
          to label %invoke.cont241 unwind label %lpad

invoke.cont241:                                   ; preds = %invoke.cont239
  %add243 = add nsw i32 %add236, %call242
  br label %cond.end

cond.end:                                         ; preds = %invoke.cont241, %cond.true
  %cond = phi i32 [ %add234, %cond.true ], [ %add243, %invoke.cont241 ]
  store i32 %cond, ptr %nodeArightChild, align 4
  %205 = load i8, ptr %isInternalB, align 1
  %tobool244 = trunc i8 %205 to i1
  br i1 %tobool244, label %if.then245, label %if.else

if.then245:                                       ; preds = %cond.end
  %206 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %y246 = getelementptr inbounds %struct.anon.56, ptr %206, i32 0, i32 1
  %207 = load i32, ptr %y246, align 4
  %add247 = add nsw i32 %207, 1
  store i32 %add247, ptr %nodeBleftChild, align 4
  %208 = load ptr, ptr %treeNodesCPU.addr, align 8
  %209 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %y248 = getelementptr inbounds %struct.anon.56, ptr %209, i32 0, i32 1
  %210 = load i32, ptr %y248, align 4
  %add249 = add nsw i32 %210, 1
  %call251 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeEixEi(ptr noundef nonnull align 8 dereferenceable(25) %208, i32 noundef %add249)
          to label %invoke.cont250 unwind label %lpad

invoke.cont250:                                   ; preds = %if.then245
  %call253 = invoke noundef zeroext i1 @_ZNK18b3QuantizedBvhNode10isLeafNodeEv(ptr noundef nonnull align 16 dereferenceable(16) %call251)
          to label %invoke.cont252 unwind label %lpad

invoke.cont252:                                   ; preds = %invoke.cont250
  %frombool254 = zext i1 %call253 to i8
  store i8 %frombool254, ptr %isNodeBLeftChildLeaf, align 1
  %211 = load i8, ptr %isNodeBLeftChildLeaf, align 1
  %tobool255 = trunc i8 %211 to i1
  br i1 %tobool255, label %cond.true256, label %cond.false259

cond.true256:                                     ; preds = %invoke.cont252
  %212 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %y257 = getelementptr inbounds %struct.anon.56, ptr %212, i32 0, i32 1
  %213 = load i32, ptr %y257, align 4
  %add258 = add nsw i32 %213, 2
  br label %cond.end269

cond.false259:                                    ; preds = %invoke.cont252
  %214 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %y260 = getelementptr inbounds %struct.anon.56, ptr %214, i32 0, i32 1
  %215 = load i32, ptr %y260, align 4
  %add261 = add nsw i32 %215, 1
  %216 = load ptr, ptr %treeNodesCPU.addr, align 8
  %217 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %y262 = getelementptr inbounds %struct.anon.56, ptr %217, i32 0, i32 1
  %218 = load i32, ptr %y262, align 4
  %add263 = add nsw i32 %218, 1
  %call265 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeEixEi(ptr noundef nonnull align 8 dereferenceable(25) %216, i32 noundef %add263)
          to label %invoke.cont264 unwind label %lpad

invoke.cont264:                                   ; preds = %cond.false259
  %call267 = invoke noundef i32 @_ZNK18b3QuantizedBvhNode14getEscapeIndexEv(ptr noundef nonnull align 16 dereferenceable(16) %call265)
          to label %invoke.cont266 unwind label %lpad

invoke.cont266:                                   ; preds = %invoke.cont264
  %add268 = add nsw i32 %add261, %call267
  br label %cond.end269

cond.end269:                                      ; preds = %invoke.cont266, %cond.true256
  %cond270 = phi i32 [ %add258, %cond.true256 ], [ %add268, %invoke.cont266 ]
  store i32 %cond270, ptr %nodeBrightChild, align 4
  %219 = load i32, ptr %nodeAleftChild, align 4
  %220 = load i32, ptr %nodeBleftChild, align 4
  %call273 = invoke i64 @_Z10b3MakeInt2ii(i32 noundef %219, i32 noundef %220)
          to label %invoke.cont272 unwind label %lpad

invoke.cont272:                                   ; preds = %cond.end269
  %coerce.dive274 = getelementptr inbounds %struct.b3Int2, ptr %ref.tmp271, i32 0, i32 0
  %coerce.dive275 = getelementptr inbounds %union.anon.55, ptr %coerce.dive274, i32 0, i32 0
  store i64 %call273, ptr %coerce.dive275, align 4
  %221 = load i32, ptr %depth, align 4
  %inc276 = add nsw i32 %221, 1
  store i32 %inc276, ptr %depth, align 4
  %call278 = invoke noundef nonnull align 4 dereferenceable(8) ptr @_ZN20b3AlignedObjectArrayI6b3Int2EixEi(ptr noundef nonnull align 8 dereferenceable(25) %nodeStack, i32 noundef %221)
          to label %invoke.cont277 unwind label %lpad

invoke.cont277:                                   ; preds = %invoke.cont272
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %call278, ptr align 4 %ref.tmp271, i64 8, i1 false)
  %222 = load i32, ptr %nodeArightChild, align 4
  %223 = load i32, ptr %nodeBleftChild, align 4
  %call281 = invoke i64 @_Z10b3MakeInt2ii(i32 noundef %222, i32 noundef %223)
          to label %invoke.cont280 unwind label %lpad

invoke.cont280:                                   ; preds = %invoke.cont277
  %coerce.dive282 = getelementptr inbounds %struct.b3Int2, ptr %ref.tmp279, i32 0, i32 0
  %coerce.dive283 = getelementptr inbounds %union.anon.55, ptr %coerce.dive282, i32 0, i32 0
  store i64 %call281, ptr %coerce.dive283, align 4
  %224 = load i32, ptr %depth, align 4
  %inc284 = add nsw i32 %224, 1
  store i32 %inc284, ptr %depth, align 4
  %call286 = invoke noundef nonnull align 4 dereferenceable(8) ptr @_ZN20b3AlignedObjectArrayI6b3Int2EixEi(ptr noundef nonnull align 8 dereferenceable(25) %nodeStack, i32 noundef %224)
          to label %invoke.cont285 unwind label %lpad

invoke.cont285:                                   ; preds = %invoke.cont280
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %call286, ptr align 4 %ref.tmp279, i64 8, i1 false)
  %225 = load i32, ptr %nodeAleftChild, align 4
  %226 = load i32, ptr %nodeBrightChild, align 4
  %call289 = invoke i64 @_Z10b3MakeInt2ii(i32 noundef %225, i32 noundef %226)
          to label %invoke.cont288 unwind label %lpad

invoke.cont288:                                   ; preds = %invoke.cont285
  %coerce.dive290 = getelementptr inbounds %struct.b3Int2, ptr %ref.tmp287, i32 0, i32 0
  %coerce.dive291 = getelementptr inbounds %union.anon.55, ptr %coerce.dive290, i32 0, i32 0
  store i64 %call289, ptr %coerce.dive291, align 4
  %227 = load i32, ptr %depth, align 4
  %inc292 = add nsw i32 %227, 1
  store i32 %inc292, ptr %depth, align 4
  %call294 = invoke noundef nonnull align 4 dereferenceable(8) ptr @_ZN20b3AlignedObjectArrayI6b3Int2EixEi(ptr noundef nonnull align 8 dereferenceable(25) %nodeStack, i32 noundef %227)
          to label %invoke.cont293 unwind label %lpad

invoke.cont293:                                   ; preds = %invoke.cont288
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %call294, ptr align 4 %ref.tmp287, i64 8, i1 false)
  %228 = load i32, ptr %nodeArightChild, align 4
  %229 = load i32, ptr %nodeBrightChild, align 4
  %call297 = invoke i64 @_Z10b3MakeInt2ii(i32 noundef %228, i32 noundef %229)
          to label %invoke.cont296 unwind label %lpad

invoke.cont296:                                   ; preds = %invoke.cont293
  %coerce.dive298 = getelementptr inbounds %struct.b3Int2, ptr %ref.tmp295, i32 0, i32 0
  %coerce.dive299 = getelementptr inbounds %union.anon.55, ptr %coerce.dive298, i32 0, i32 0
  store i64 %call297, ptr %coerce.dive299, align 4
  %230 = load i32, ptr %depth, align 4
  %inc300 = add nsw i32 %230, 1
  store i32 %inc300, ptr %depth, align 4
  %call302 = invoke noundef nonnull align 4 dereferenceable(8) ptr @_ZN20b3AlignedObjectArrayI6b3Int2EixEi(ptr noundef nonnull align 8 dereferenceable(25) %nodeStack, i32 noundef %230)
          to label %invoke.cont301 unwind label %lpad

invoke.cont301:                                   ; preds = %invoke.cont296
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %call302, ptr align 4 %ref.tmp295, i64 8, i1 false)
  br label %if.end321

if.else:                                          ; preds = %cond.end
  %231 = load i32, ptr %nodeAleftChild, align 4
  %232 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %y304 = getelementptr inbounds %struct.anon.56, ptr %232, i32 0, i32 1
  %233 = load i32, ptr %y304, align 4
  %call306 = invoke i64 @_Z10b3MakeInt2ii(i32 noundef %231, i32 noundef %233)
          to label %invoke.cont305 unwind label %lpad

invoke.cont305:                                   ; preds = %if.else
  %coerce.dive307 = getelementptr inbounds %struct.b3Int2, ptr %ref.tmp303, i32 0, i32 0
  %coerce.dive308 = getelementptr inbounds %union.anon.55, ptr %coerce.dive307, i32 0, i32 0
  store i64 %call306, ptr %coerce.dive308, align 4
  %234 = load i32, ptr %depth, align 4
  %inc309 = add nsw i32 %234, 1
  store i32 %inc309, ptr %depth, align 4
  %call311 = invoke noundef nonnull align 4 dereferenceable(8) ptr @_ZN20b3AlignedObjectArrayI6b3Int2EixEi(ptr noundef nonnull align 8 dereferenceable(25) %nodeStack, i32 noundef %234)
          to label %invoke.cont310 unwind label %lpad

invoke.cont310:                                   ; preds = %invoke.cont305
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %call311, ptr align 4 %ref.tmp303, i64 8, i1 false)
  %235 = load i32, ptr %nodeArightChild, align 4
  %236 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %y313 = getelementptr inbounds %struct.anon.56, ptr %236, i32 0, i32 1
  %237 = load i32, ptr %y313, align 4
  %call315 = invoke i64 @_Z10b3MakeInt2ii(i32 noundef %235, i32 noundef %237)
          to label %invoke.cont314 unwind label %lpad

invoke.cont314:                                   ; preds = %invoke.cont310
  %coerce.dive316 = getelementptr inbounds %struct.b3Int2, ptr %ref.tmp312, i32 0, i32 0
  %coerce.dive317 = getelementptr inbounds %union.anon.55, ptr %coerce.dive316, i32 0, i32 0
  store i64 %call315, ptr %coerce.dive317, align 4
  %238 = load i32, ptr %depth, align 4
  %inc318 = add nsw i32 %238, 1
  store i32 %inc318, ptr %depth, align 4
  %call320 = invoke noundef nonnull align 4 dereferenceable(8) ptr @_ZN20b3AlignedObjectArrayI6b3Int2EixEi(ptr noundef nonnull align 8 dereferenceable(25) %nodeStack, i32 noundef %238)
          to label %invoke.cont319 unwind label %lpad

invoke.cont319:                                   ; preds = %invoke.cont314
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %call320, ptr align 4 %ref.tmp312, i64 8, i1 false)
  br label %if.end321

if.end321:                                        ; preds = %invoke.cont319, %invoke.cont301
  br label %if.end394

if.else322:                                       ; preds = %if.end220
  %239 = load i8, ptr %isInternalB, align 1
  %tobool323 = trunc i8 %239 to i1
  br i1 %tobool323, label %if.then324, label %if.else371

if.then324:                                       ; preds = %if.else322
  %240 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %y326 = getelementptr inbounds %struct.anon.56, ptr %240, i32 0, i32 1
  %241 = load i32, ptr %y326, align 4
  %add327 = add nsw i32 %241, 1
  store i32 %add327, ptr %nodeBleftChild325, align 4
  %242 = load ptr, ptr %treeNodesCPU.addr, align 8
  %243 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %y329 = getelementptr inbounds %struct.anon.56, ptr %243, i32 0, i32 1
  %244 = load i32, ptr %y329, align 4
  %add330 = add nsw i32 %244, 1
  %call332 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeEixEi(ptr noundef nonnull align 8 dereferenceable(25) %242, i32 noundef %add330)
          to label %invoke.cont331 unwind label %lpad

invoke.cont331:                                   ; preds = %if.then324
  %call334 = invoke noundef zeroext i1 @_ZNK18b3QuantizedBvhNode10isLeafNodeEv(ptr noundef nonnull align 16 dereferenceable(16) %call332)
          to label %invoke.cont333 unwind label %lpad

invoke.cont333:                                   ; preds = %invoke.cont331
  %frombool335 = zext i1 %call334 to i8
  store i8 %frombool335, ptr %isNodeBLeftChildLeaf328, align 1
  %245 = load i8, ptr %isNodeBLeftChildLeaf328, align 1
  %tobool337 = trunc i8 %245 to i1
  br i1 %tobool337, label %cond.true338, label %cond.false341

cond.true338:                                     ; preds = %invoke.cont333
  %246 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %y339 = getelementptr inbounds %struct.anon.56, ptr %246, i32 0, i32 1
  %247 = load i32, ptr %y339, align 4
  %add340 = add nsw i32 %247, 2
  br label %cond.end351

cond.false341:                                    ; preds = %invoke.cont333
  %248 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %y342 = getelementptr inbounds %struct.anon.56, ptr %248, i32 0, i32 1
  %249 = load i32, ptr %y342, align 4
  %add343 = add nsw i32 %249, 1
  %250 = load ptr, ptr %treeNodesCPU.addr, align 8
  %251 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %y344 = getelementptr inbounds %struct.anon.56, ptr %251, i32 0, i32 1
  %252 = load i32, ptr %y344, align 4
  %add345 = add nsw i32 %252, 1
  %call347 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeEixEi(ptr noundef nonnull align 8 dereferenceable(25) %250, i32 noundef %add345)
          to label %invoke.cont346 unwind label %lpad

invoke.cont346:                                   ; preds = %cond.false341
  %call349 = invoke noundef i32 @_ZNK18b3QuantizedBvhNode14getEscapeIndexEv(ptr noundef nonnull align 16 dereferenceable(16) %call347)
          to label %invoke.cont348 unwind label %lpad

invoke.cont348:                                   ; preds = %invoke.cont346
  %add350 = add nsw i32 %add343, %call349
  br label %cond.end351

cond.end351:                                      ; preds = %invoke.cont348, %cond.true338
  %cond352 = phi i32 [ %add340, %cond.true338 ], [ %add350, %invoke.cont348 ]
  store i32 %cond352, ptr %nodeBrightChild336, align 4
  %253 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %x354 = getelementptr inbounds %struct.anon.56, ptr %253, i32 0, i32 0
  %254 = load i32, ptr %x354, align 4
  %255 = load i32, ptr %nodeBleftChild325, align 4
  %call356 = invoke i64 @_Z10b3MakeInt2ii(i32 noundef %254, i32 noundef %255)
          to label %invoke.cont355 unwind label %lpad

invoke.cont355:                                   ; preds = %cond.end351
  %coerce.dive357 = getelementptr inbounds %struct.b3Int2, ptr %ref.tmp353, i32 0, i32 0
  %coerce.dive358 = getelementptr inbounds %union.anon.55, ptr %coerce.dive357, i32 0, i32 0
  store i64 %call356, ptr %coerce.dive358, align 4
  %256 = load i32, ptr %depth, align 4
  %inc359 = add nsw i32 %256, 1
  store i32 %inc359, ptr %depth, align 4
  %call361 = invoke noundef nonnull align 4 dereferenceable(8) ptr @_ZN20b3AlignedObjectArrayI6b3Int2EixEi(ptr noundef nonnull align 8 dereferenceable(25) %nodeStack, i32 noundef %256)
          to label %invoke.cont360 unwind label %lpad

invoke.cont360:                                   ; preds = %invoke.cont355
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %call361, ptr align 4 %ref.tmp353, i64 8, i1 false)
  %257 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %x363 = getelementptr inbounds %struct.anon.56, ptr %257, i32 0, i32 0
  %258 = load i32, ptr %x363, align 4
  %259 = load i32, ptr %nodeBrightChild336, align 4
  %call365 = invoke i64 @_Z10b3MakeInt2ii(i32 noundef %258, i32 noundef %259)
          to label %invoke.cont364 unwind label %lpad

invoke.cont364:                                   ; preds = %invoke.cont360
  %coerce.dive366 = getelementptr inbounds %struct.b3Int2, ptr %ref.tmp362, i32 0, i32 0
  %coerce.dive367 = getelementptr inbounds %union.anon.55, ptr %coerce.dive366, i32 0, i32 0
  store i64 %call365, ptr %coerce.dive367, align 4
  %260 = load i32, ptr %depth, align 4
  %inc368 = add nsw i32 %260, 1
  store i32 %inc368, ptr %depth, align 4
  %call370 = invoke noundef nonnull align 4 dereferenceable(8) ptr @_ZN20b3AlignedObjectArrayI6b3Int2EixEi(ptr noundef nonnull align 8 dereferenceable(25) %nodeStack, i32 noundef %260)
          to label %invoke.cont369 unwind label %lpad

invoke.cont369:                                   ; preds = %invoke.cont364
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %call370, ptr align 4 %ref.tmp362, i64 8, i1 false)
  br label %if.end393

if.else371:                                       ; preds = %if.else322
  %261 = load ptr, ptr %numCompoundPairsOut.addr, align 8
  %262 = load i32, ptr %261, align 4
  %inc372 = add nsw i32 %262, 1
  store i32 %inc372, ptr %261, align 4
  store i32 %262, ptr %compoundPairIdx, align 4
  %263 = load i32, ptr %compoundPairIdx, align 4
  %264 = load i32, ptr %maxNumCompoundPairsCapacity.addr, align 4
  %cmp373 = icmp slt i32 %263, %264
  br i1 %cmp373, label %if.then374, label %if.end392

if.then374:                                       ; preds = %if.else371
  %265 = load ptr, ptr %treeNodesCPU.addr, align 8
  %266 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %x375 = getelementptr inbounds %struct.anon.56, ptr %266, i32 0, i32 0
  %267 = load i32, ptr %x375, align 4
  %call377 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeEixEi(ptr noundef nonnull align 8 dereferenceable(25) %265, i32 noundef %267)
          to label %invoke.cont376 unwind label %lpad

invoke.cont376:                                   ; preds = %if.then374
  %call379 = invoke noundef i32 @_ZNK18b3QuantizedBvhNode16getTriangleIndexEv(ptr noundef nonnull align 16 dereferenceable(16) %call377)
          to label %invoke.cont378 unwind label %lpad

invoke.cont378:                                   ; preds = %invoke.cont376
  store i32 %call379, ptr %childShapeIndexA, align 4
  %268 = load ptr, ptr %treeNodesCPU.addr, align 8
  %269 = getelementptr inbounds %struct.b3Int2, ptr %node, i32 0, i32 0
  %y380 = getelementptr inbounds %struct.anon.56, ptr %269, i32 0, i32 1
  %270 = load i32, ptr %y380, align 4
  %call382 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeEixEi(ptr noundef nonnull align 8 dereferenceable(25) %268, i32 noundef %270)
          to label %invoke.cont381 unwind label %lpad

invoke.cont381:                                   ; preds = %invoke.cont378
  %call384 = invoke noundef i32 @_ZNK18b3QuantizedBvhNode16getTriangleIndexEv(ptr noundef nonnull align 16 dereferenceable(16) %call382)
          to label %invoke.cont383 unwind label %lpad

invoke.cont383:                                   ; preds = %invoke.cont381
  store i32 %call384, ptr %childShapeIndexB, align 4
  %271 = load i32, ptr %bodyIndexA.addr, align 4
  %272 = load i32, ptr %bodyIndexB.addr, align 4
  %273 = load i32, ptr %childShapeIndexA, align 4
  %274 = load i32, ptr %childShapeIndexB, align 4
  %call387 = invoke { i64, i64 } @_Z10b3MakeInt4iiii(i32 noundef %271, i32 noundef %272, i32 noundef %273, i32 noundef %274)
          to label %invoke.cont386 unwind label %lpad

invoke.cont386:                                   ; preds = %invoke.cont383
  %coerce.dive388 = getelementptr inbounds %struct.b3Int4, ptr %ref.tmp385, i32 0, i32 0
  %coerce.dive389 = getelementptr inbounds %union.anon, ptr %coerce.dive388, i32 0, i32 0
  %275 = getelementptr inbounds { i64, i64 }, ptr %coerce.dive389, i32 0, i32 0
  %276 = extractvalue { i64, i64 } %call387, 0
  store i64 %276, ptr %275, align 16
  %277 = getelementptr inbounds { i64, i64 }, ptr %coerce.dive389, i32 0, i32 1
  %278 = extractvalue { i64, i64 } %call387, 1
  store i64 %278, ptr %277, align 8
  %279 = load ptr, ptr %gpuCompoundPairsOut.addr, align 8
  %280 = load i32, ptr %compoundPairIdx, align 4
  %idxprom390 = sext i32 %280 to i64
  %arrayidx391 = getelementptr inbounds %struct.b3Int4, ptr %279, i64 %idxprom390
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx391, ptr align 16 %ref.tmp385, i64 16, i1 false)
  br label %if.end392

if.end392:                                        ; preds = %invoke.cont386, %if.else371
  br label %if.end393

if.end393:                                        ; preds = %if.end392, %invoke.cont369
  br label %if.end394

if.end394:                                        ; preds = %if.end393, %if.end321
  br label %if.end395

if.end395:                                        ; preds = %if.end394, %invoke.cont188
  br label %do.cond396

do.cond396:                                       ; preds = %if.end395, %do.end
  %281 = load i32, ptr %depth, align 4
  %tobool397 = icmp ne i32 %281, 0
  br i1 %tobool397, label %do.body, label %do.end398, !llvm.loop !42

do.end398:                                        ; preds = %do.cond396
  %call400 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_Z5b3MaxIiERKT_S2_S2_(ptr noundef nonnull align 4 dereferenceable(4) @numAabbChecks, ptr noundef nonnull align 4 dereferenceable(4) @maxNumAabbChecks)
          to label %invoke.cont399 unwind label %lpad

invoke.cont399:                                   ; preds = %do.end398
  %282 = load i32, ptr %call400, align 4
  store i32 %282, ptr @maxNumAabbChecks, align 4
  call void @_ZN20b3AlignedObjectArrayI6b3Int2ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %nodeStack) #13
  br label %if.end401

if.end401:                                        ; preds = %invoke.cont399, %for.body58
  br label %for.inc

for.inc:                                          ; preds = %if.end401
  %283 = load i32, ptr %q, align 4
  %inc402 = add nsw i32 %283, 1
  store i32 %inc402, ptr %q, align 4
  br label %for.cond56, !llvm.loop !43

for.end:                                          ; preds = %for.cond56
  br label %for.inc403

for.inc403:                                       ; preds = %for.end
  %284 = load i32, ptr %p, align 4
  %inc404 = add nsw i32 %284, 1
  store i32 %inc404, ptr %p, align 4
  br label %for.cond, !llvm.loop !44

for.end405:                                       ; preds = %for.cond
  br label %if.end676

if.end406:                                        ; preds = %land.lhs.true12, %if.end
  %285 = load ptr, ptr %collidables.addr, align 8
  %286 = load i32, ptr %collidableIndexA.addr, align 4
  %idxprom407 = sext i32 %286 to i64
  %arrayidx408 = getelementptr inbounds %struct.b3Collidable, ptr %285, i64 %idxprom407
  %m_shapeType409 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx408, i32 0, i32 2
  %287 = load i32, ptr %m_shapeType409, align 4
  %cmp410 = icmp eq i32 %287, 6
  br i1 %cmp410, label %if.then415, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end406
  %288 = load ptr, ptr %collidables.addr, align 8
  %289 = load i32, ptr %collidableIndexB.addr, align 4
  %idxprom411 = sext i32 %289 to i64
  %arrayidx412 = getelementptr inbounds %struct.b3Collidable, ptr %288, i64 %idxprom411
  %m_shapeType413 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx412, i32 0, i32 2
  %290 = load i32, ptr %m_shapeType413, align 4
  %cmp414 = icmp eq i32 %290, 6
  br i1 %cmp414, label %if.then415, label %if.end676

if.then415:                                       ; preds = %lor.lhs.false, %if.end406
  %291 = load ptr, ptr %collidables.addr, align 8
  %292 = load i32, ptr %collidableIndexA.addr, align 4
  %idxprom416 = sext i32 %292 to i64
  %arrayidx417 = getelementptr inbounds %struct.b3Collidable, ptr %291, i64 %idxprom416
  %m_shapeType418 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx417, i32 0, i32 2
  %293 = load i32, ptr %m_shapeType418, align 4
  %cmp419 = icmp eq i32 %293, 6
  br i1 %cmp419, label %if.then420, label %if.end574

if.then420:                                       ; preds = %if.then415
  %294 = load ptr, ptr %collidables.addr, align 8
  %295 = load i32, ptr %collidableIndexA.addr, align 4
  %idxprom421 = sext i32 %295 to i64
  %arrayidx422 = getelementptr inbounds %struct.b3Collidable, ptr %294, i64 %idxprom421
  %296 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx422, i32 0, i32 0
  %297 = load i32, ptr %296, align 4
  store i32 %297, ptr %numChildrenA, align 4
  store i32 0, ptr %c, align 4
  br label %for.cond423

for.cond423:                                      ; preds = %for.inc571, %if.then420
  %298 = load i32, ptr %c, align 4
  %299 = load i32, ptr %numChildrenA, align 4
  %cmp424 = icmp slt i32 %298, %299
  br i1 %cmp424, label %for.body425, label %for.end573

for.body425:                                      ; preds = %for.cond423
  %300 = load ptr, ptr %collidables.addr, align 8
  %301 = load i32, ptr %collidableIndexA.addr, align 4
  %idxprom427 = sext i32 %301 to i64
  %arrayidx428 = getelementptr inbounds %struct.b3Collidable, ptr %300, i64 %idxprom427
  %302 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx428, i32 0, i32 3
  %303 = load i32, ptr %302, align 4
  %304 = load i32, ptr %c, align 4
  %add429 = add nsw i32 %303, %304
  store i32 %add429, ptr %childShapeIndexA426, align 4
  %305 = load ptr, ptr %gpuChildShapes.addr, align 8
  %306 = load i32, ptr %childShapeIndexA426, align 4
  %idxprom430 = sext i32 %306 to i64
  %arrayidx431 = getelementptr inbounds %struct.b3GpuChildShape, ptr %305, i64 %idxprom430
  %307 = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx431, i32 0, i32 2
  %308 = load i32, ptr %307, align 16
  store i32 %308, ptr %childColIndexA, align 4
  %309 = load ptr, ptr %rigidBodies.addr, align 8
  %310 = load i32, ptr %bodyIndexA.addr, align 4
  %idxprom433 = sext i32 %310 to i64
  %arrayidx434 = getelementptr inbounds %struct.b3RigidBodyData, ptr %309, i64 %idxprom433
  %m_pos435 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx434, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posA432, ptr align 16 %m_pos435, i64 16, i1 false)
  %311 = load ptr, ptr %rigidBodies.addr, align 8
  %312 = load i32, ptr %bodyIndexA.addr, align 4
  %idxprom437 = sext i32 %312 to i64
  %arrayidx438 = getelementptr inbounds %struct.b3RigidBodyData, ptr %311, i64 %idxprom437
  %m_quat439 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx438, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornA436, ptr align 16 %m_quat439, i64 16, i1 false)
  %313 = load ptr, ptr %gpuChildShapes.addr, align 8
  %314 = load i32, ptr %childShapeIndexA426, align 4
  %idxprom440 = sext i32 %314 to i64
  %arrayidx441 = getelementptr inbounds %struct.b3GpuChildShape, ptr %313, i64 %idxprom440
  %m_childPosition = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx441, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %childPosA, ptr align 16 %m_childPosition, i64 16, i1 false)
  %315 = load ptr, ptr %gpuChildShapes.addr, align 8
  %316 = load i32, ptr %childShapeIndexA426, align 4
  %idxprom442 = sext i32 %316 to i64
  %arrayidx443 = getelementptr inbounds %struct.b3GpuChildShape, ptr %315, i64 %idxprom442
  %m_childOrientation = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx443, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %childOrnA, ptr align 16 %m_childOrientation, i64 16, i1 false)
  %call445 = call { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %ornA436, ptr noundef nonnull align 16 dereferenceable(16) %childPosA)
  %coerce.dive446 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp444, i32 0, i32 0
  %coerce.dive447 = getelementptr inbounds %union.anon.1, ptr %coerce.dive446, i32 0, i32 0
  %317 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive447, i32 0, i32 0
  %318 = extractvalue { <2 x float>, <2 x float> } %call445, 0
  store <2 x float> %318, ptr %317, align 16
  %319 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive447, i32 0, i32 1
  %320 = extractvalue { <2 x float>, <2 x float> } %call445, 1
  store <2 x float> %320, ptr %319, align 8
  %call448 = call { <2 x float>, <2 x float> } @_ZplRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp444, ptr noundef nonnull align 16 dereferenceable(16) %posA432)
  %coerce.dive449 = getelementptr inbounds %class.b3Vector3, ptr %newPosA, i32 0, i32 0
  %coerce.dive450 = getelementptr inbounds %union.anon.1, ptr %coerce.dive449, i32 0, i32 0
  %321 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive450, i32 0, i32 0
  %322 = extractvalue { <2 x float>, <2 x float> } %call448, 0
  store <2 x float> %322, ptr %321, align 16
  %323 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive450, i32 0, i32 1
  %324 = extractvalue { <2 x float>, <2 x float> } %call448, 1
  store <2 x float> %324, ptr %323, align 8
  %call451 = call { <2 x float>, <2 x float> } @_Z9b3QuatMulRK12b3QuaternionS1_(ptr noundef nonnull align 16 dereferenceable(16) %ornA436, ptr noundef nonnull align 16 dereferenceable(16) %childOrnA)
  %coerce.dive452 = getelementptr inbounds %class.b3Quaternion, ptr %newOrnA, i32 0, i32 0
  %coerce.dive453 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive452, i32 0, i32 0
  %coerce.dive454 = getelementptr inbounds %union.anon.3, ptr %coerce.dive453, i32 0, i32 0
  %325 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive454, i32 0, i32 0
  %326 = extractvalue { <2 x float>, <2 x float> } %call451, 0
  store <2 x float> %326, ptr %325, align 16
  %327 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive454, i32 0, i32 1
  %328 = extractvalue { <2 x float>, <2 x float> } %call451, 1
  store <2 x float> %328, ptr %327, align 8
  %329 = load ptr, ptr %aabbsLocalSpace.addr, align 8
  %330 = load i32, ptr %childColIndexA, align 4
  %call455 = call noundef nonnull align 16 dereferenceable(32) ptr @_ZNK20b3AlignedObjectArrayI6b3AabbEixEi(ptr noundef nonnull align 8 dereferenceable(25) %329, i32 noundef %330)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %aabbA, ptr align 16 %call455, i64 32, i1 false)
  call void @_ZN11b3TransformC2Ev(ptr noundef nonnull align 16 dereferenceable(64) %transA456)
  call void @_ZN11b3Transform11setIdentityEv(ptr noundef nonnull align 16 dereferenceable(64) %transA456)
  call void @_ZN11b3Transform9setOriginERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %transA456, ptr noundef nonnull align 16 dereferenceable(16) %newPosA)
  call void @_ZN11b3Transform11setRotationERK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(64) %transA456, ptr noundef nonnull align 16 dereferenceable(16) %newOrnA)
  store float 0.000000e+00, ptr %margin457, align 4
  %331 = getelementptr inbounds %struct.b3Aabb, ptr %aabbA, i32 0, i32 0
  %332 = getelementptr inbounds %struct.b3Aabb, ptr %aabbA, i32 0, i32 1
  %333 = load float, ptr %margin457, align 4
  %call460 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN11b3Transform9getOriginEv(ptr noundef nonnull align 16 dereferenceable(64) %transA456)
  %call462 = call { <2 x float>, <2 x float> } @_ZNK11b3Transform11getRotationEv(ptr noundef nonnull align 16 dereferenceable(64) %transA456)
  %coerce.dive463 = getelementptr inbounds %class.b3Quaternion, ptr %ref.tmp461, i32 0, i32 0
  %coerce.dive464 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive463, i32 0, i32 0
  %coerce.dive465 = getelementptr inbounds %union.anon.3, ptr %coerce.dive464, i32 0, i32 0
  %334 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive465, i32 0, i32 0
  %335 = extractvalue { <2 x float>, <2 x float> } %call462, 0
  store <2 x float> %335, ptr %334, align 16
  %336 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive465, i32 0, i32 1
  %337 = extractvalue { <2 x float>, <2 x float> } %call462, 1
  store <2 x float> %337, ptr %336, align 8
  call void @_Z16b3TransformAabb2RK9b3Vector3S1_fS1_RK12b3QuaternionPS_S5_(ptr noundef nonnull align 16 dereferenceable(16) %331, ptr noundef nonnull align 16 dereferenceable(16) %332, float noundef %333, ptr noundef nonnull align 16 dereferenceable(16) %call460, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp461, ptr noundef %aabbAMinOut458, ptr noundef %aabbAMaxOut459)
  %338 = load ptr, ptr %collidables.addr, align 8
  %339 = load i32, ptr %collidableIndexB.addr, align 4
  %idxprom466 = sext i32 %339 to i64
  %arrayidx467 = getelementptr inbounds %struct.b3Collidable, ptr %338, i64 %idxprom466
  %m_shapeType468 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx467, i32 0, i32 2
  %340 = load i32, ptr %m_shapeType468, align 4
  %cmp469 = icmp eq i32 %340, 6
  br i1 %cmp469, label %if.then470, label %if.else534

if.then470:                                       ; preds = %for.body425
  %341 = load ptr, ptr %collidables.addr, align 8
  %342 = load i32, ptr %collidableIndexB.addr, align 4
  %idxprom471 = sext i32 %342 to i64
  %arrayidx472 = getelementptr inbounds %struct.b3Collidable, ptr %341, i64 %idxprom471
  %343 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx472, i32 0, i32 0
  %344 = load i32, ptr %343, align 4
  store i32 %344, ptr %numChildrenB, align 4
  store i32 0, ptr %b, align 4
  br label %for.cond473

for.cond473:                                      ; preds = %for.inc531, %if.then470
  %345 = load i32, ptr %b, align 4
  %346 = load i32, ptr %numChildrenB, align 4
  %cmp474 = icmp slt i32 %345, %346
  br i1 %cmp474, label %for.body475, label %for.end533

for.body475:                                      ; preds = %for.cond473
  %347 = load ptr, ptr %collidables.addr, align 8
  %348 = load i32, ptr %collidableIndexB.addr, align 4
  %idxprom477 = sext i32 %348 to i64
  %arrayidx478 = getelementptr inbounds %struct.b3Collidable, ptr %347, i64 %idxprom477
  %349 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx478, i32 0, i32 3
  %350 = load i32, ptr %349, align 4
  %351 = load i32, ptr %b, align 4
  %add479 = add nsw i32 %350, %351
  store i32 %add479, ptr %childShapeIndexB476, align 4
  %352 = load ptr, ptr %gpuChildShapes.addr, align 8
  %353 = load i32, ptr %childShapeIndexB476, align 4
  %idxprom480 = sext i32 %353 to i64
  %arrayidx481 = getelementptr inbounds %struct.b3GpuChildShape, ptr %352, i64 %idxprom480
  %354 = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx481, i32 0, i32 2
  %355 = load i32, ptr %354, align 16
  store i32 %355, ptr %childColIndexB, align 4
  %356 = load ptr, ptr %rigidBodies.addr, align 8
  %357 = load i32, ptr %bodyIndexB.addr, align 4
  %idxprom483 = sext i32 %357 to i64
  %arrayidx484 = getelementptr inbounds %struct.b3RigidBodyData, ptr %356, i64 %idxprom483
  %m_quat485 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx484, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornB482, ptr align 16 %m_quat485, i64 16, i1 false)
  %358 = load ptr, ptr %rigidBodies.addr, align 8
  %359 = load i32, ptr %bodyIndexB.addr, align 4
  %idxprom487 = sext i32 %359 to i64
  %arrayidx488 = getelementptr inbounds %struct.b3RigidBodyData, ptr %358, i64 %idxprom487
  %m_pos489 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx488, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posB486, ptr align 16 %m_pos489, i64 16, i1 false)
  %360 = load ptr, ptr %gpuChildShapes.addr, align 8
  %361 = load i32, ptr %childShapeIndexB476, align 4
  %idxprom490 = sext i32 %361 to i64
  %arrayidx491 = getelementptr inbounds %struct.b3GpuChildShape, ptr %360, i64 %idxprom490
  %m_childPosition492 = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx491, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %childPosB, ptr align 16 %m_childPosition492, i64 16, i1 false)
  %362 = load ptr, ptr %gpuChildShapes.addr, align 8
  %363 = load i32, ptr %childShapeIndexB476, align 4
  %idxprom493 = sext i32 %363 to i64
  %arrayidx494 = getelementptr inbounds %struct.b3GpuChildShape, ptr %362, i64 %idxprom493
  %m_childOrientation495 = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx494, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %childOrnB, ptr align 16 %m_childOrientation495, i64 16, i1 false)
  %call496 = call { <2 x float>, <2 x float> } @_Z9transformPK9b3Vector3S1_PK12b3Quaternion(ptr noundef %childPosB, ptr noundef %posB486, ptr noundef %ornB482)
  %coerce.dive497 = getelementptr inbounds %class.b3Vector3, ptr %newPosB, i32 0, i32 0
  %coerce.dive498 = getelementptr inbounds %union.anon.1, ptr %coerce.dive497, i32 0, i32 0
  %364 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive498, i32 0, i32 0
  %365 = extractvalue { <2 x float>, <2 x float> } %call496, 0
  store <2 x float> %365, ptr %364, align 16
  %366 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive498, i32 0, i32 1
  %367 = extractvalue { <2 x float>, <2 x float> } %call496, 1
  store <2 x float> %367, ptr %366, align 8
  %call499 = call { <2 x float>, <2 x float> } @_Z9b3QuatMulRK12b3QuaternionS1_(ptr noundef nonnull align 16 dereferenceable(16) %ornB482, ptr noundef nonnull align 16 dereferenceable(16) %childOrnB)
  %coerce.dive500 = getelementptr inbounds %class.b3Quaternion, ptr %newOrnB, i32 0, i32 0
  %coerce.dive501 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive500, i32 0, i32 0
  %coerce.dive502 = getelementptr inbounds %union.anon.3, ptr %coerce.dive501, i32 0, i32 0
  %368 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive502, i32 0, i32 0
  %369 = extractvalue { <2 x float>, <2 x float> } %call499, 0
  store <2 x float> %369, ptr %368, align 16
  %370 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive502, i32 0, i32 1
  %371 = extractvalue { <2 x float>, <2 x float> } %call499, 1
  store <2 x float> %371, ptr %370, align 8
  %372 = load ptr, ptr %aabbsLocalSpace.addr, align 8
  %373 = load i32, ptr %childColIndexB, align 4
  %call503 = call noundef nonnull align 16 dereferenceable(32) ptr @_ZNK20b3AlignedObjectArrayI6b3AabbEixEi(ptr noundef nonnull align 8 dereferenceable(25) %372, i32 noundef %373)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %aabbB, ptr align 16 %call503, i64 32, i1 false)
  call void @_ZN11b3TransformC2Ev(ptr noundef nonnull align 16 dereferenceable(64) %transB504)
  call void @_ZN11b3Transform11setIdentityEv(ptr noundef nonnull align 16 dereferenceable(64) %transB504)
  call void @_ZN11b3Transform9setOriginERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %transB504, ptr noundef nonnull align 16 dereferenceable(16) %newPosB)
  call void @_ZN11b3Transform11setRotationERK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(64) %transB504, ptr noundef nonnull align 16 dereferenceable(16) %newOrnB)
  %374 = getelementptr inbounds %struct.b3Aabb, ptr %aabbB, i32 0, i32 0
  %375 = getelementptr inbounds %struct.b3Aabb, ptr %aabbB, i32 0, i32 1
  %376 = load float, ptr %margin457, align 4
  %call507 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN11b3Transform9getOriginEv(ptr noundef nonnull align 16 dereferenceable(64) %transB504)
  %call509 = call { <2 x float>, <2 x float> } @_ZNK11b3Transform11getRotationEv(ptr noundef nonnull align 16 dereferenceable(64) %transB504)
  %coerce.dive510 = getelementptr inbounds %class.b3Quaternion, ptr %ref.tmp508, i32 0, i32 0
  %coerce.dive511 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive510, i32 0, i32 0
  %coerce.dive512 = getelementptr inbounds %union.anon.3, ptr %coerce.dive511, i32 0, i32 0
  %377 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive512, i32 0, i32 0
  %378 = extractvalue { <2 x float>, <2 x float> } %call509, 0
  store <2 x float> %378, ptr %377, align 16
  %379 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive512, i32 0, i32 1
  %380 = extractvalue { <2 x float>, <2 x float> } %call509, 1
  store <2 x float> %380, ptr %379, align 8
  call void @_Z16b3TransformAabb2RK9b3Vector3S1_fS1_RK12b3QuaternionPS_S5_(ptr noundef nonnull align 16 dereferenceable(16) %374, ptr noundef nonnull align 16 dereferenceable(16) %375, float noundef %376, ptr noundef nonnull align 16 dereferenceable(16) %call507, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp508, ptr noundef %aabbBMinOut505, ptr noundef %aabbBMaxOut506)
  %381 = load i32, ptr @numAabbChecks, align 4
  %inc513 = add nsw i32 %381, 1
  store i32 %inc513, ptr @numAabbChecks, align 4
  %call515 = call noundef zeroext i1 @_Z21b3TestAabbAgainstAabbRK9b3Vector3S1_S1_S1_(ptr noundef nonnull align 16 dereferenceable(16) %aabbAMinOut458, ptr noundef nonnull align 16 dereferenceable(16) %aabbAMaxOut459, ptr noundef nonnull align 16 dereferenceable(16) %aabbBMinOut505, ptr noundef nonnull align 16 dereferenceable(16) %aabbBMaxOut506)
  %frombool516 = zext i1 %call515 to i8
  store i8 %frombool516, ptr %aabbOverlap514, align 1
  %382 = load i8, ptr %aabbOverlap514, align 1
  %tobool517 = trunc i8 %382 to i1
  br i1 %tobool517, label %if.then518, label %if.end530

if.then518:                                       ; preds = %for.body475
  %383 = load ptr, ptr %numCompoundPairsOut.addr, align 8
  %384 = load i32, ptr %383, align 4
  %inc520 = add nsw i32 %384, 1
  store i32 %inc520, ptr %383, align 4
  store i32 %384, ptr %compoundPairIdx519, align 4
  %385 = load i32, ptr %compoundPairIdx519, align 4
  %386 = load i32, ptr %maxNumCompoundPairsCapacity.addr, align 4
  %cmp521 = icmp slt i32 %385, %386
  br i1 %cmp521, label %if.then522, label %if.end529

if.then522:                                       ; preds = %if.then518
  %387 = load i32, ptr %bodyIndexA.addr, align 4
  %388 = load i32, ptr %bodyIndexB.addr, align 4
  %389 = load i32, ptr %childShapeIndexA426, align 4
  %390 = load i32, ptr %childShapeIndexB476, align 4
  %call524 = call { i64, i64 } @_Z10b3MakeInt4iiii(i32 noundef %387, i32 noundef %388, i32 noundef %389, i32 noundef %390)
  %coerce.dive525 = getelementptr inbounds %struct.b3Int4, ptr %ref.tmp523, i32 0, i32 0
  %coerce.dive526 = getelementptr inbounds %union.anon, ptr %coerce.dive525, i32 0, i32 0
  %391 = getelementptr inbounds { i64, i64 }, ptr %coerce.dive526, i32 0, i32 0
  %392 = extractvalue { i64, i64 } %call524, 0
  store i64 %392, ptr %391, align 16
  %393 = getelementptr inbounds { i64, i64 }, ptr %coerce.dive526, i32 0, i32 1
  %394 = extractvalue { i64, i64 } %call524, 1
  store i64 %394, ptr %393, align 8
  %395 = load ptr, ptr %gpuCompoundPairsOut.addr, align 8
  %396 = load i32, ptr %compoundPairIdx519, align 4
  %idxprom527 = sext i32 %396 to i64
  %arrayidx528 = getelementptr inbounds %struct.b3Int4, ptr %395, i64 %idxprom527
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx528, ptr align 16 %ref.tmp523, i64 16, i1 false)
  br label %if.end529

if.end529:                                        ; preds = %if.then522, %if.then518
  br label %if.end530

if.end530:                                        ; preds = %if.end529, %for.body475
  br label %for.inc531

for.inc531:                                       ; preds = %if.end530
  %397 = load i32, ptr %b, align 4
  %inc532 = add nsw i32 %397, 1
  store i32 %inc532, ptr %b, align 4
  br label %for.cond473, !llvm.loop !45

for.end533:                                       ; preds = %for.cond473
  br label %if.end570

if.else534:                                       ; preds = %for.body425
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posA535, ptr align 16 %newPosA, i64 16, i1 false)
  %398 = getelementptr inbounds %class.b3Vector3, ptr %posA535, i32 0, i32 0
  %w = getelementptr inbounds %struct.anon.2, ptr %398, i32 0, i32 3
  store float 0.000000e+00, ptr %w, align 4
  %399 = load ptr, ptr %rigidBodies.addr, align 8
  %400 = load i32, ptr %bodyIndexB.addr, align 4
  %idxprom537 = sext i32 %400 to i64
  %arrayidx538 = getelementptr inbounds %struct.b3RigidBodyData, ptr %399, i64 %idxprom537
  %m_pos539 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx538, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posB536, ptr align 16 %m_pos539, i64 16, i1 false)
  %401 = getelementptr inbounds %class.b3Vector3, ptr %posB536, i32 0, i32 0
  %w540 = getelementptr inbounds %struct.anon.2, ptr %401, i32 0, i32 3
  store float 0.000000e+00, ptr %w540, align 4
  %402 = load ptr, ptr %convexShapes.addr, align 8
  %403 = load i32, ptr %shapeIndexA, align 4
  %idxprom541 = sext i32 %403 to i64
  %arrayidx542 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %402, i64 %idxprom541
  %m_localCenter = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %arrayidx542, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %c0local, ptr align 16 %m_localCenter, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornA543, ptr align 16 %newOrnA, i64 16, i1 false)
  %call545 = call { <2 x float>, <2 x float> } @_Z9transformPK9b3Vector3S1_PK12b3Quaternion(ptr noundef %c0local, ptr noundef %posA535, ptr noundef %ornA543)
  %coerce.dive546 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp544, i32 0, i32 0
  %coerce.dive547 = getelementptr inbounds %union.anon.1, ptr %coerce.dive546, i32 0, i32 0
  %404 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive547, i32 0, i32 0
  %405 = extractvalue { <2 x float>, <2 x float> } %call545, 0
  store <2 x float> %405, ptr %404, align 16
  %406 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive547, i32 0, i32 1
  %407 = extractvalue { <2 x float>, <2 x float> } %call545, 1
  store <2 x float> %407, ptr %406, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %c0, ptr align 16 %ref.tmp544, i64 16, i1 false)
  %408 = load ptr, ptr %convexShapes.addr, align 8
  %409 = load i32, ptr %shapeIndexB, align 4
  %idxprom548 = sext i32 %409 to i64
  %arrayidx549 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %408, i64 %idxprom548
  %m_localCenter550 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %arrayidx549, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %c1local, ptr align 16 %m_localCenter550, i64 16, i1 false)
  %410 = load ptr, ptr %rigidBodies.addr, align 8
  %411 = load i32, ptr %bodyIndexB.addr, align 4
  %idxprom552 = sext i32 %411 to i64
  %arrayidx553 = getelementptr inbounds %struct.b3RigidBodyData, ptr %410, i64 %idxprom552
  %m_quat554 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx553, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornB551, ptr align 16 %m_quat554, i64 16, i1 false)
  %call556 = call { <2 x float>, <2 x float> } @_Z9transformPK9b3Vector3S1_PK12b3Quaternion(ptr noundef %c1local, ptr noundef %posB536, ptr noundef %ornB551)
  %coerce.dive557 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp555, i32 0, i32 0
  %coerce.dive558 = getelementptr inbounds %union.anon.1, ptr %coerce.dive557, i32 0, i32 0
  %412 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive558, i32 0, i32 0
  %413 = extractvalue { <2 x float>, <2 x float> } %call556, 0
  store <2 x float> %413, ptr %412, align 16
  %414 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive558, i32 0, i32 1
  %415 = extractvalue { <2 x float>, <2 x float> } %call556, 1
  store <2 x float> %415, ptr %414, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %c1, ptr align 16 %ref.tmp555, i64 16, i1 false)
  %416 = load ptr, ptr %numCompoundPairsOut.addr, align 8
  %417 = load i32, ptr %416, align 4
  %inc560 = add nsw i32 %417, 1
  store i32 %inc560, ptr %416, align 4
  store i32 %417, ptr %compoundPairIdx559, align 4
  %418 = load i32, ptr %compoundPairIdx559, align 4
  %419 = load i32, ptr %maxNumCompoundPairsCapacity.addr, align 4
  %cmp561 = icmp slt i32 %418, %419
  br i1 %cmp561, label %if.then562, label %if.end569

if.then562:                                       ; preds = %if.else534
  %420 = load i32, ptr %bodyIndexA.addr, align 4
  %421 = load i32, ptr %bodyIndexB.addr, align 4
  %422 = load i32, ptr %childShapeIndexA426, align 4
  %call564 = call { i64, i64 } @_Z10b3MakeInt4iiii(i32 noundef %420, i32 noundef %421, i32 noundef %422, i32 noundef -1)
  %coerce.dive565 = getelementptr inbounds %struct.b3Int4, ptr %ref.tmp563, i32 0, i32 0
  %coerce.dive566 = getelementptr inbounds %union.anon, ptr %coerce.dive565, i32 0, i32 0
  %423 = getelementptr inbounds { i64, i64 }, ptr %coerce.dive566, i32 0, i32 0
  %424 = extractvalue { i64, i64 } %call564, 0
  store i64 %424, ptr %423, align 16
  %425 = getelementptr inbounds { i64, i64 }, ptr %coerce.dive566, i32 0, i32 1
  %426 = extractvalue { i64, i64 } %call564, 1
  store i64 %426, ptr %425, align 8
  %427 = load ptr, ptr %gpuCompoundPairsOut.addr, align 8
  %428 = load i32, ptr %compoundPairIdx559, align 4
  %idxprom567 = sext i32 %428 to i64
  %arrayidx568 = getelementptr inbounds %struct.b3Int4, ptr %427, i64 %idxprom567
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx568, ptr align 16 %ref.tmp563, i64 16, i1 false)
  br label %if.end569

if.end569:                                        ; preds = %if.then562, %if.else534
  br label %if.end570

if.end570:                                        ; preds = %if.end569, %for.end533
  br label %for.inc571

for.inc571:                                       ; preds = %if.end570
  %429 = load i32, ptr %c, align 4
  %inc572 = add nsw i32 %429, 1
  store i32 %inc572, ptr %c, align 4
  br label %for.cond423, !llvm.loop !46

for.end573:                                       ; preds = %for.cond423
  br label %if.end676

if.end574:                                        ; preds = %if.then415
  %430 = load ptr, ptr %collidables.addr, align 8
  %431 = load i32, ptr %collidableIndexA.addr, align 4
  %idxprom575 = sext i32 %431 to i64
  %arrayidx576 = getelementptr inbounds %struct.b3Collidable, ptr %430, i64 %idxprom575
  %m_shapeType577 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx576, i32 0, i32 2
  %432 = load i32, ptr %m_shapeType577, align 4
  %cmp578 = icmp ne i32 %432, 5
  br i1 %cmp578, label %land.lhs.true579, label %if.end675

land.lhs.true579:                                 ; preds = %if.end574
  %433 = load ptr, ptr %collidables.addr, align 8
  %434 = load i32, ptr %collidableIndexB.addr, align 4
  %idxprom580 = sext i32 %434 to i64
  %arrayidx581 = getelementptr inbounds %struct.b3Collidable, ptr %433, i64 %idxprom580
  %m_shapeType582 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx581, i32 0, i32 2
  %435 = load i32, ptr %m_shapeType582, align 4
  %cmp583 = icmp eq i32 %435, 6
  br i1 %cmp583, label %if.then584, label %if.end675

if.then584:                                       ; preds = %land.lhs.true579
  %436 = load ptr, ptr %collidables.addr, align 8
  %437 = load i32, ptr %collidableIndexB.addr, align 4
  %idxprom586 = sext i32 %437 to i64
  %arrayidx587 = getelementptr inbounds %struct.b3Collidable, ptr %436, i64 %idxprom586
  %438 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx587, i32 0, i32 0
  %439 = load i32, ptr %438, align 4
  store i32 %439, ptr %numChildrenB585, align 4
  store i32 0, ptr %b588, align 4
  br label %for.cond589

for.cond589:                                      ; preds = %for.inc672, %if.then584
  %440 = load i32, ptr %b588, align 4
  %441 = load i32, ptr %numChildrenB585, align 4
  %cmp590 = icmp slt i32 %440, %441
  br i1 %cmp590, label %for.body591, label %for.end674

for.body591:                                      ; preds = %for.cond589
  %442 = load ptr, ptr %collidables.addr, align 8
  %443 = load i32, ptr %collidableIndexB.addr, align 4
  %idxprom593 = sext i32 %443 to i64
  %arrayidx594 = getelementptr inbounds %struct.b3Collidable, ptr %442, i64 %idxprom593
  %444 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx594, i32 0, i32 3
  %445 = load i32, ptr %444, align 4
  %446 = load i32, ptr %b588, align 4
  %add595 = add nsw i32 %445, %446
  store i32 %add595, ptr %childShapeIndexB592, align 4
  %447 = load ptr, ptr %gpuChildShapes.addr, align 8
  %448 = load i32, ptr %childShapeIndexB592, align 4
  %idxprom597 = sext i32 %448 to i64
  %arrayidx598 = getelementptr inbounds %struct.b3GpuChildShape, ptr %447, i64 %idxprom597
  %449 = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx598, i32 0, i32 2
  %450 = load i32, ptr %449, align 16
  store i32 %450, ptr %childColIndexB596, align 4
  %451 = load ptr, ptr %rigidBodies.addr, align 8
  %452 = load i32, ptr %bodyIndexB.addr, align 4
  %idxprom600 = sext i32 %452 to i64
  %arrayidx601 = getelementptr inbounds %struct.b3RigidBodyData, ptr %451, i64 %idxprom600
  %m_quat602 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx601, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornB599, ptr align 16 %m_quat602, i64 16, i1 false)
  %453 = load ptr, ptr %rigidBodies.addr, align 8
  %454 = load i32, ptr %bodyIndexB.addr, align 4
  %idxprom604 = sext i32 %454 to i64
  %arrayidx605 = getelementptr inbounds %struct.b3RigidBodyData, ptr %453, i64 %idxprom604
  %m_pos606 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx605, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posB603, ptr align 16 %m_pos606, i64 16, i1 false)
  %455 = load ptr, ptr %gpuChildShapes.addr, align 8
  %456 = load i32, ptr %childShapeIndexB592, align 4
  %idxprom608 = sext i32 %456 to i64
  %arrayidx609 = getelementptr inbounds %struct.b3GpuChildShape, ptr %455, i64 %idxprom608
  %m_childPosition610 = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx609, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %childPosB607, ptr align 16 %m_childPosition610, i64 16, i1 false)
  %457 = load ptr, ptr %gpuChildShapes.addr, align 8
  %458 = load i32, ptr %childShapeIndexB592, align 4
  %idxprom612 = sext i32 %458 to i64
  %arrayidx613 = getelementptr inbounds %struct.b3GpuChildShape, ptr %457, i64 %idxprom612
  %m_childOrientation614 = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx613, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %childOrnB611, ptr align 16 %m_childOrientation614, i64 16, i1 false)
  %call617 = call { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %ornB599, ptr noundef nonnull align 16 dereferenceable(16) %childPosB607)
  %coerce.dive618 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp616, i32 0, i32 0
  %coerce.dive619 = getelementptr inbounds %union.anon.1, ptr %coerce.dive618, i32 0, i32 0
  %459 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive619, i32 0, i32 0
  %460 = extractvalue { <2 x float>, <2 x float> } %call617, 0
  store <2 x float> %460, ptr %459, align 16
  %461 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive619, i32 0, i32 1
  %462 = extractvalue { <2 x float>, <2 x float> } %call617, 1
  store <2 x float> %462, ptr %461, align 8
  %call620 = call { <2 x float>, <2 x float> } @_ZplRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp616, ptr noundef nonnull align 16 dereferenceable(16) %posB603)
  %coerce.dive621 = getelementptr inbounds %class.b3Vector3, ptr %newPosB615, i32 0, i32 0
  %coerce.dive622 = getelementptr inbounds %union.anon.1, ptr %coerce.dive621, i32 0, i32 0
  %463 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive622, i32 0, i32 0
  %464 = extractvalue { <2 x float>, <2 x float> } %call620, 0
  store <2 x float> %464, ptr %463, align 16
  %465 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive622, i32 0, i32 1
  %466 = extractvalue { <2 x float>, <2 x float> } %call620, 1
  store <2 x float> %466, ptr %465, align 8
  %call624 = call { <2 x float>, <2 x float> } @_Z9b3QuatMulRK12b3QuaternionS1_(ptr noundef nonnull align 16 dereferenceable(16) %ornB599, ptr noundef nonnull align 16 dereferenceable(16) %childOrnB611)
  %coerce.dive625 = getelementptr inbounds %class.b3Quaternion, ptr %newOrnB623, i32 0, i32 0
  %coerce.dive626 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive625, i32 0, i32 0
  %coerce.dive627 = getelementptr inbounds %union.anon.3, ptr %coerce.dive626, i32 0, i32 0
  %467 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive627, i32 0, i32 0
  %468 = extractvalue { <2 x float>, <2 x float> } %call624, 0
  store <2 x float> %468, ptr %467, align 16
  %469 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive627, i32 0, i32 1
  %470 = extractvalue { <2 x float>, <2 x float> } %call624, 1
  store <2 x float> %470, ptr %469, align 8
  %471 = load ptr, ptr %collidables.addr, align 8
  %472 = load i32, ptr %childColIndexB596, align 4
  %idxprom629 = sext i32 %472 to i64
  %arrayidx630 = getelementptr inbounds %struct.b3Collidable, ptr %471, i64 %idxprom629
  %473 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx630, i32 0, i32 3
  %474 = load i32, ptr %473, align 4
  store i32 %474, ptr %shapeIndexB628, align 4
  %475 = load ptr, ptr %rigidBodies.addr, align 8
  %476 = load i32, ptr %bodyIndexA.addr, align 4
  %idxprom632 = sext i32 %476 to i64
  %arrayidx633 = getelementptr inbounds %struct.b3RigidBodyData, ptr %475, i64 %idxprom632
  %m_pos634 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx633, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posA631, ptr align 16 %m_pos634, i64 16, i1 false)
  %477 = getelementptr inbounds %class.b3Vector3, ptr %posA631, i32 0, i32 0
  %w635 = getelementptr inbounds %struct.anon.2, ptr %477, i32 0, i32 3
  store float 0.000000e+00, ptr %w635, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posB636, ptr align 16 %newPosB615, i64 16, i1 false)
  %478 = getelementptr inbounds %class.b3Vector3, ptr %posB636, i32 0, i32 0
  %w637 = getelementptr inbounds %struct.anon.2, ptr %478, i32 0, i32 3
  store float 0.000000e+00, ptr %w637, align 4
  %479 = load ptr, ptr %convexShapes.addr, align 8
  %480 = load i32, ptr %shapeIndexA, align 4
  %idxprom639 = sext i32 %480 to i64
  %arrayidx640 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %479, i64 %idxprom639
  %m_localCenter641 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %arrayidx640, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %c0local638, ptr align 16 %m_localCenter641, i64 16, i1 false)
  %481 = load ptr, ptr %rigidBodies.addr, align 8
  %482 = load i32, ptr %bodyIndexA.addr, align 4
  %idxprom643 = sext i32 %482 to i64
  %arrayidx644 = getelementptr inbounds %struct.b3RigidBodyData, ptr %481, i64 %idxprom643
  %m_quat645 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx644, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornA642, ptr align 16 %m_quat645, i64 16, i1 false)
  %call648 = call { <2 x float>, <2 x float> } @_Z9transformPK9b3Vector3S1_PK12b3Quaternion(ptr noundef %c0local638, ptr noundef %posA631, ptr noundef %ornA642)
  %coerce.dive649 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp647, i32 0, i32 0
  %coerce.dive650 = getelementptr inbounds %union.anon.1, ptr %coerce.dive649, i32 0, i32 0
  %483 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive650, i32 0, i32 0
  %484 = extractvalue { <2 x float>, <2 x float> } %call648, 0
  store <2 x float> %484, ptr %483, align 16
  %485 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive650, i32 0, i32 1
  %486 = extractvalue { <2 x float>, <2 x float> } %call648, 1
  store <2 x float> %486, ptr %485, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %c0646, ptr align 16 %ref.tmp647, i64 16, i1 false)
  %487 = load ptr, ptr %convexShapes.addr, align 8
  %488 = load i32, ptr %shapeIndexB628, align 4
  %idxprom652 = sext i32 %488 to i64
  %arrayidx653 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %487, i64 %idxprom652
  %m_localCenter654 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %arrayidx653, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %c1local651, ptr align 16 %m_localCenter654, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornB655, ptr align 16 %newOrnB623, i64 16, i1 false)
  %call658 = call { <2 x float>, <2 x float> } @_Z9transformPK9b3Vector3S1_PK12b3Quaternion(ptr noundef %c1local651, ptr noundef %posB636, ptr noundef %ornB655)
  %coerce.dive659 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp657, i32 0, i32 0
  %coerce.dive660 = getelementptr inbounds %union.anon.1, ptr %coerce.dive659, i32 0, i32 0
  %489 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive660, i32 0, i32 0
  %490 = extractvalue { <2 x float>, <2 x float> } %call658, 0
  store <2 x float> %490, ptr %489, align 16
  %491 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive660, i32 0, i32 1
  %492 = extractvalue { <2 x float>, <2 x float> } %call658, 1
  store <2 x float> %492, ptr %491, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %c1656, ptr align 16 %ref.tmp657, i64 16, i1 false)
  %493 = load ptr, ptr %numCompoundPairsOut.addr, align 8
  %494 = load i32, ptr %493, align 4
  %inc662 = add nsw i32 %494, 1
  store i32 %inc662, ptr %493, align 4
  store i32 %494, ptr %compoundPairIdx661, align 4
  %495 = load i32, ptr %compoundPairIdx661, align 4
  %496 = load i32, ptr %maxNumCompoundPairsCapacity.addr, align 4
  %cmp663 = icmp slt i32 %495, %496
  br i1 %cmp663, label %if.then664, label %if.end671

if.then664:                                       ; preds = %for.body591
  %497 = load i32, ptr %bodyIndexA.addr, align 4
  %498 = load i32, ptr %bodyIndexB.addr, align 4
  %499 = load i32, ptr %childShapeIndexB592, align 4
  %call666 = call { i64, i64 } @_Z10b3MakeInt4iiii(i32 noundef %497, i32 noundef %498, i32 noundef -1, i32 noundef %499)
  %coerce.dive667 = getelementptr inbounds %struct.b3Int4, ptr %ref.tmp665, i32 0, i32 0
  %coerce.dive668 = getelementptr inbounds %union.anon, ptr %coerce.dive667, i32 0, i32 0
  %500 = getelementptr inbounds { i64, i64 }, ptr %coerce.dive668, i32 0, i32 0
  %501 = extractvalue { i64, i64 } %call666, 0
  store i64 %501, ptr %500, align 16
  %502 = getelementptr inbounds { i64, i64 }, ptr %coerce.dive668, i32 0, i32 1
  %503 = extractvalue { i64, i64 } %call666, 1
  store i64 %503, ptr %502, align 8
  %504 = load ptr, ptr %gpuCompoundPairsOut.addr, align 8
  %505 = load i32, ptr %compoundPairIdx661, align 4
  %idxprom669 = sext i32 %505 to i64
  %arrayidx670 = getelementptr inbounds %struct.b3Int4, ptr %504, i64 %idxprom669
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx670, ptr align 16 %ref.tmp665, i64 16, i1 false)
  br label %if.end671

if.end671:                                        ; preds = %if.then664, %for.body591
  br label %for.inc672

for.inc672:                                       ; preds = %if.end671
  %506 = load i32, ptr %b588, align 4
  %inc673 = add nsw i32 %506, 1
  store i32 %inc673, ptr %b588, align 4
  br label %for.cond589, !llvm.loop !47

for.end674:                                       ; preds = %for.cond589
  br label %if.end676

if.end675:                                        ; preds = %land.lhs.true579, %if.end574
  br label %if.end676

if.end676:                                        ; preds = %if.end675, %for.end674, %for.end573, %lor.lhs.false, %for.end405, %if.then
  ret void

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val677 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val677
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(64) ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3BvhInfo, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %class.b3BvhSubtreeInfo, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_Z12MyUnQuantizePKtRK9b3Vector3S3_(ptr noundef %vecIn, ptr noundef nonnull align 16 dereferenceable(16) %quantization, ptr noundef nonnull align 16 dereferenceable(16) %bvhAabbMin) #3 comdat {
entry:
  %retval = alloca %class.b3Vector3, align 16
  %vecIn.addr = alloca ptr, align 8
  %quantization.addr = alloca ptr, align 8
  %bvhAabbMin.addr = alloca ptr, align 8
  %ref.tmp = alloca float, align 4
  %ref.tmp1 = alloca float, align 4
  %ref.tmp5 = alloca float, align 4
  store ptr %vecIn, ptr %vecIn.addr, align 8
  store ptr %quantization, ptr %quantization.addr, align 8
  store ptr %bvhAabbMin, ptr %bvhAabbMin.addr, align 8
  %0 = load ptr, ptr %vecIn.addr, align 8
  %arrayidx = getelementptr inbounds i16, ptr %0, i64 0
  %1 = load i16, ptr %arrayidx, align 2
  %conv = uitofp i16 %1 to float
  %2 = load ptr, ptr %quantization.addr, align 8
  %3 = getelementptr inbounds %class.b3Vector3, ptr %2, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon.2, ptr %3, i32 0, i32 0
  %4 = load float, ptr %x, align 16
  %div = fdiv float %conv, %4
  store float %div, ptr %ref.tmp, align 4
  %5 = load ptr, ptr %vecIn.addr, align 8
  %arrayidx2 = getelementptr inbounds i16, ptr %5, i64 1
  %6 = load i16, ptr %arrayidx2, align 2
  %conv3 = uitofp i16 %6 to float
  %7 = load ptr, ptr %quantization.addr, align 8
  %8 = getelementptr inbounds %class.b3Vector3, ptr %7, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon.2, ptr %8, i32 0, i32 1
  %9 = load float, ptr %y, align 4
  %div4 = fdiv float %conv3, %9
  store float %div4, ptr %ref.tmp1, align 4
  %10 = load ptr, ptr %vecIn.addr, align 8
  %arrayidx6 = getelementptr inbounds i16, ptr %10, i64 2
  %11 = load i16, ptr %arrayidx6, align 2
  %conv7 = uitofp i16 %11 to float
  %12 = load ptr, ptr %quantization.addr, align 8
  %13 = getelementptr inbounds %class.b3Vector3, ptr %12, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon.2, ptr %13, i32 0, i32 2
  %14 = load float, ptr %z, align 8
  %div8 = fdiv float %conv7, %14
  store float %div8, ptr %ref.tmp5, align 4
  call void @_ZN9b3Vector38setValueERKfS1_S1_(ptr noundef nonnull align 16 dereferenceable(16) %retval, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp1, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp5)
  %15 = load ptr, ptr %bvhAabbMin.addr, align 8
  %call = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector3pLERKS_(ptr noundef nonnull align 16 dereferenceable(16) %retval, ptr noundef nonnull align 16 dereferenceable(16) %15)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive9 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %16 = load { <2 x float>, <2 x float> }, ptr %coerce.dive9, align 16
  ret { <2 x float>, <2 x float> } %16
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z16b3TransformAabb2RK9b3Vector3S1_fS1_RK12b3QuaternionPS_S5_(ptr noundef nonnull align 16 dereferenceable(16) %localAabbMin, ptr noundef nonnull align 16 dereferenceable(16) %localAabbMax, float noundef %margin, ptr noundef nonnull align 16 dereferenceable(16) %pos, ptr noundef nonnull align 16 dereferenceable(16) %orn, ptr noundef %aabbMinOut, ptr noundef %aabbMaxOut) #2 comdat {
entry:
  %localAabbMin.addr = alloca ptr, align 8
  %localAabbMax.addr = alloca ptr, align 8
  %margin.addr = alloca float, align 4
  %pos.addr = alloca ptr, align 8
  %orn.addr = alloca ptr, align 8
  %aabbMinOut.addr = alloca ptr, align 8
  %aabbMaxOut.addr = alloca ptr, align 8
  %localHalfExtents = alloca %class.b3Vector3, align 16
  %ref.tmp = alloca float, align 4
  %ref.tmp1 = alloca %class.b3Vector3, align 16
  %ref.tmp6 = alloca %class.b3Vector3, align 16
  %localCenter = alloca %class.b3Vector3, align 16
  %ref.tmp11 = alloca float, align 4
  %ref.tmp12 = alloca %class.b3Vector3, align 16
  %m = alloca %class.b3Matrix3x3, align 16
  %ref.tmp19 = alloca %class.b3Matrix3x3, align 16
  %abs_b = alloca %class.b3Matrix3x3, align 16
  %center = alloca %class.b3Vector3, align 16
  %extent = alloca %class.b3Vector3, align 16
  %ref.tmp33 = alloca %class.b3Vector3, align 16
  %ref.tmp37 = alloca %class.b3Vector3, align 16
  store ptr %localAabbMin, ptr %localAabbMin.addr, align 8
  store ptr %localAabbMax, ptr %localAabbMax.addr, align 8
  store float %margin, ptr %margin.addr, align 4
  store ptr %pos, ptr %pos.addr, align 8
  store ptr %orn, ptr %orn.addr, align 8
  store ptr %aabbMinOut, ptr %aabbMinOut.addr, align 8
  store ptr %aabbMaxOut, ptr %aabbMaxOut.addr, align 8
  store float 5.000000e-01, ptr %ref.tmp, align 4
  %0 = load ptr, ptr %localAabbMax.addr, align 8
  %1 = load ptr, ptr %localAabbMin.addr, align 8
  %call = call { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %0, ptr noundef nonnull align 16 dereferenceable(16) %1)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp1, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %2 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive2, i32 0, i32 0
  %3 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %3, ptr %2, align 16
  %4 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive2, i32 0, i32 1
  %5 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %5, ptr %4, align 8
  %call3 = call { <2 x float>, <2 x float> } @_ZmlRKfRK9b3Vector3(ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp1)
  %coerce.dive4 = getelementptr inbounds %class.b3Vector3, ptr %localHalfExtents, i32 0, i32 0
  %coerce.dive5 = getelementptr inbounds %union.anon.1, ptr %coerce.dive4, i32 0, i32 0
  %6 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive5, i32 0, i32 0
  %7 = extractvalue { <2 x float>, <2 x float> } %call3, 0
  store <2 x float> %7, ptr %6, align 16
  %8 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive5, i32 0, i32 1
  %9 = extractvalue { <2 x float>, <2 x float> } %call3, 1
  store <2 x float> %9, ptr %8, align 8
  %10 = load float, ptr %margin.addr, align 4
  %11 = load float, ptr %margin.addr, align 4
  %12 = load float, ptr %margin.addr, align 4
  %call7 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef %10, float noundef %11, float noundef %12, float noundef 0.000000e+00)
  %coerce.dive8 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp6, i32 0, i32 0
  %coerce.dive9 = getelementptr inbounds %union.anon.1, ptr %coerce.dive8, i32 0, i32 0
  %13 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive9, i32 0, i32 0
  %14 = extractvalue { <2 x float>, <2 x float> } %call7, 0
  store <2 x float> %14, ptr %13, align 16
  %15 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive9, i32 0, i32 1
  %16 = extractvalue { <2 x float>, <2 x float> } %call7, 1
  store <2 x float> %16, ptr %15, align 8
  %call10 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector3pLERKS_(ptr noundef nonnull align 16 dereferenceable(16) %localHalfExtents, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp6)
  store float 5.000000e-01, ptr %ref.tmp11, align 4
  %17 = load ptr, ptr %localAabbMax.addr, align 8
  %18 = load ptr, ptr %localAabbMin.addr, align 8
  %call13 = call { <2 x float>, <2 x float> } @_ZplRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %17, ptr noundef nonnull align 16 dereferenceable(16) %18)
  %coerce.dive14 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp12, i32 0, i32 0
  %coerce.dive15 = getelementptr inbounds %union.anon.1, ptr %coerce.dive14, i32 0, i32 0
  %19 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive15, i32 0, i32 0
  %20 = extractvalue { <2 x float>, <2 x float> } %call13, 0
  store <2 x float> %20, ptr %19, align 16
  %21 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive15, i32 0, i32 1
  %22 = extractvalue { <2 x float>, <2 x float> } %call13, 1
  store <2 x float> %22, ptr %21, align 8
  %call16 = call { <2 x float>, <2 x float> } @_ZmlRKfRK9b3Vector3(ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp11, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp12)
  %coerce.dive17 = getelementptr inbounds %class.b3Vector3, ptr %localCenter, i32 0, i32 0
  %coerce.dive18 = getelementptr inbounds %union.anon.1, ptr %coerce.dive17, i32 0, i32 0
  %23 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive18, i32 0, i32 0
  %24 = extractvalue { <2 x float>, <2 x float> } %call16, 0
  store <2 x float> %24, ptr %23, align 16
  %25 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive18, i32 0, i32 1
  %26 = extractvalue { <2 x float>, <2 x float> } %call16, 1
  store <2 x float> %26, ptr %25, align 8
  call void @_ZN11b3Matrix3x3C2Ev(ptr noundef nonnull align 16 dereferenceable(48) %m)
  %27 = load ptr, ptr %orn.addr, align 8
  call void @_Z23b3QuatGetRotationMatrixRK12b3Quaternion(ptr sret(%class.b3Matrix3x3) align 16 %ref.tmp19, ptr noundef nonnull align 16 dereferenceable(16) %27)
  %call20 = call noundef nonnull align 16 dereferenceable(48) ptr @_ZN11b3Matrix3x3aSERKS_(ptr noundef nonnull align 16 dereferenceable(48) %m, ptr noundef nonnull align 16 dereferenceable(48) %ref.tmp19)
  call void @_Z16b3AbsoluteMat3x3RK11b3Matrix3x3(ptr sret(%class.b3Matrix3x3) align 16 %abs_b, ptr noundef nonnull align 16 dereferenceable(48) %m)
  %28 = load ptr, ptr %pos.addr, align 8
  %29 = load ptr, ptr %orn.addr, align 8
  %call21 = call { <2 x float>, <2 x float> } @_Z16b3TransformPointRK9b3Vector3S1_RK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(16) %localCenter, ptr noundef nonnull align 16 dereferenceable(16) %28, ptr noundef nonnull align 16 dereferenceable(16) %29)
  %coerce.dive22 = getelementptr inbounds %class.b3Vector3, ptr %center, i32 0, i32 0
  %coerce.dive23 = getelementptr inbounds %union.anon.1, ptr %coerce.dive22, i32 0, i32 0
  %30 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive23, i32 0, i32 0
  %31 = extractvalue { <2 x float>, <2 x float> } %call21, 0
  store <2 x float> %31, ptr %30, align 16
  %32 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive23, i32 0, i32 1
  %33 = extractvalue { <2 x float>, <2 x float> } %call21, 1
  store <2 x float> %33, ptr %32, align 8
  %call24 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK11b3Matrix3x36getRowEi(ptr noundef nonnull align 16 dereferenceable(48) %abs_b, i32 noundef 0)
  %call25 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %localHalfExtents, ptr noundef nonnull align 16 dereferenceable(16) %call24)
  %call26 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK11b3Matrix3x36getRowEi(ptr noundef nonnull align 16 dereferenceable(48) %abs_b, i32 noundef 1)
  %call27 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %localHalfExtents, ptr noundef nonnull align 16 dereferenceable(16) %call26)
  %call28 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK11b3Matrix3x36getRowEi(ptr noundef nonnull align 16 dereferenceable(48) %abs_b, i32 noundef 2)
  %call29 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %localHalfExtents, ptr noundef nonnull align 16 dereferenceable(16) %call28)
  %call30 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef %call25, float noundef %call27, float noundef %call29, float noundef 0.000000e+00)
  %coerce.dive31 = getelementptr inbounds %class.b3Vector3, ptr %extent, i32 0, i32 0
  %coerce.dive32 = getelementptr inbounds %union.anon.1, ptr %coerce.dive31, i32 0, i32 0
  %34 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive32, i32 0, i32 0
  %35 = extractvalue { <2 x float>, <2 x float> } %call30, 0
  store <2 x float> %35, ptr %34, align 16
  %36 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive32, i32 0, i32 1
  %37 = extractvalue { <2 x float>, <2 x float> } %call30, 1
  store <2 x float> %37, ptr %36, align 8
  %call34 = call { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %center, ptr noundef nonnull align 16 dereferenceable(16) %extent)
  %coerce.dive35 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp33, i32 0, i32 0
  %coerce.dive36 = getelementptr inbounds %union.anon.1, ptr %coerce.dive35, i32 0, i32 0
  %38 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive36, i32 0, i32 0
  %39 = extractvalue { <2 x float>, <2 x float> } %call34, 0
  store <2 x float> %39, ptr %38, align 16
  %40 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive36, i32 0, i32 1
  %41 = extractvalue { <2 x float>, <2 x float> } %call34, 1
  store <2 x float> %41, ptr %40, align 8
  %42 = load ptr, ptr %aabbMinOut.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %42, ptr align 16 %ref.tmp33, i64 16, i1 false)
  %call38 = call { <2 x float>, <2 x float> } @_ZplRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %center, ptr noundef nonnull align 16 dereferenceable(16) %extent)
  %coerce.dive39 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp37, i32 0, i32 0
  %coerce.dive40 = getelementptr inbounds %union.anon.1, ptr %coerce.dive39, i32 0, i32 0
  %43 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive40, i32 0, i32 0
  %44 = extractvalue { <2 x float>, <2 x float> } %call38, 0
  store <2 x float> %44, ptr %43, align 16
  %45 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive40, i32 0, i32 1
  %46 = extractvalue { <2 x float>, <2 x float> } %call38, 1
  store <2 x float> %46, ptr %45, align 8
  %47 = load ptr, ptr %aabbMaxOut.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %47, ptr align 16 %ref.tmp37, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_Z21b3TestAabbAgainstAabbRK9b3Vector3S1_S1_S1_(ptr noundef nonnull align 16 dereferenceable(16) %aabbMin1, ptr noundef nonnull align 16 dereferenceable(16) %aabbMax1, ptr noundef nonnull align 16 dereferenceable(16) %aabbMin2, ptr noundef nonnull align 16 dereferenceable(16) %aabbMax2) #3 comdat {
entry:
  %aabbMin1.addr = alloca ptr, align 8
  %aabbMax1.addr = alloca ptr, align 8
  %aabbMin2.addr = alloca ptr, align 8
  %aabbMax2.addr = alloca ptr, align 8
  %overlap = alloca i8, align 1
  store ptr %aabbMin1, ptr %aabbMin1.addr, align 8
  store ptr %aabbMax1, ptr %aabbMax1.addr, align 8
  store ptr %aabbMin2, ptr %aabbMin2.addr, align 8
  store ptr %aabbMax2, ptr %aabbMax2.addr, align 8
  store i8 1, ptr %overlap, align 1
  %0 = load ptr, ptr %aabbMin1.addr, align 8
  %1 = getelementptr inbounds %class.b3Vector3, ptr %0, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon.2, ptr %1, i32 0, i32 0
  %2 = load float, ptr %x, align 16
  %3 = load ptr, ptr %aabbMax2.addr, align 8
  %4 = getelementptr inbounds %class.b3Vector3, ptr %3, i32 0, i32 0
  %x1 = getelementptr inbounds %struct.anon.2, ptr %4, i32 0, i32 0
  %5 = load float, ptr %x1, align 16
  %cmp = fcmp ogt float %2, %5
  br i1 %cmp, label %cond.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %6 = load ptr, ptr %aabbMax1.addr, align 8
  %7 = getelementptr inbounds %class.b3Vector3, ptr %6, i32 0, i32 0
  %x2 = getelementptr inbounds %struct.anon.2, ptr %7, i32 0, i32 0
  %8 = load float, ptr %x2, align 16
  %9 = load ptr, ptr %aabbMin2.addr, align 8
  %10 = getelementptr inbounds %class.b3Vector3, ptr %9, i32 0, i32 0
  %x3 = getelementptr inbounds %struct.anon.2, ptr %10, i32 0, i32 0
  %11 = load float, ptr %x3, align 16
  %cmp4 = fcmp olt float %8, %11
  br i1 %cmp4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %lor.lhs.false, %entry
  br label %cond.end

cond.false:                                       ; preds = %lor.lhs.false
  %12 = load i8, ptr %overlap, align 1
  %tobool = trunc i8 %12 to i1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i1 [ false, %cond.true ], [ %tobool, %cond.false ]
  %frombool = zext i1 %cond to i8
  store i8 %frombool, ptr %overlap, align 1
  %13 = load ptr, ptr %aabbMin1.addr, align 8
  %14 = getelementptr inbounds %class.b3Vector3, ptr %13, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon.2, ptr %14, i32 0, i32 2
  %15 = load float, ptr %z, align 8
  %16 = load ptr, ptr %aabbMax2.addr, align 8
  %17 = getelementptr inbounds %class.b3Vector3, ptr %16, i32 0, i32 0
  %z5 = getelementptr inbounds %struct.anon.2, ptr %17, i32 0, i32 2
  %18 = load float, ptr %z5, align 8
  %cmp6 = fcmp ogt float %15, %18
  br i1 %cmp6, label %cond.true11, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %cond.end
  %19 = load ptr, ptr %aabbMax1.addr, align 8
  %20 = getelementptr inbounds %class.b3Vector3, ptr %19, i32 0, i32 0
  %z8 = getelementptr inbounds %struct.anon.2, ptr %20, i32 0, i32 2
  %21 = load float, ptr %z8, align 8
  %22 = load ptr, ptr %aabbMin2.addr, align 8
  %23 = getelementptr inbounds %class.b3Vector3, ptr %22, i32 0, i32 0
  %z9 = getelementptr inbounds %struct.anon.2, ptr %23, i32 0, i32 2
  %24 = load float, ptr %z9, align 8
  %cmp10 = fcmp olt float %21, %24
  br i1 %cmp10, label %cond.true11, label %cond.false12

cond.true11:                                      ; preds = %lor.lhs.false7, %cond.end
  br label %cond.end14

cond.false12:                                     ; preds = %lor.lhs.false7
  %25 = load i8, ptr %overlap, align 1
  %tobool13 = trunc i8 %25 to i1
  br label %cond.end14

cond.end14:                                       ; preds = %cond.false12, %cond.true11
  %cond15 = phi i1 [ false, %cond.true11 ], [ %tobool13, %cond.false12 ]
  %frombool16 = zext i1 %cond15 to i8
  store i8 %frombool16, ptr %overlap, align 1
  %26 = load ptr, ptr %aabbMin1.addr, align 8
  %27 = getelementptr inbounds %class.b3Vector3, ptr %26, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon.2, ptr %27, i32 0, i32 1
  %28 = load float, ptr %y, align 4
  %29 = load ptr, ptr %aabbMax2.addr, align 8
  %30 = getelementptr inbounds %class.b3Vector3, ptr %29, i32 0, i32 0
  %y17 = getelementptr inbounds %struct.anon.2, ptr %30, i32 0, i32 1
  %31 = load float, ptr %y17, align 4
  %cmp18 = fcmp ogt float %28, %31
  br i1 %cmp18, label %cond.true23, label %lor.lhs.false19

lor.lhs.false19:                                  ; preds = %cond.end14
  %32 = load ptr, ptr %aabbMax1.addr, align 8
  %33 = getelementptr inbounds %class.b3Vector3, ptr %32, i32 0, i32 0
  %y20 = getelementptr inbounds %struct.anon.2, ptr %33, i32 0, i32 1
  %34 = load float, ptr %y20, align 4
  %35 = load ptr, ptr %aabbMin2.addr, align 8
  %36 = getelementptr inbounds %class.b3Vector3, ptr %35, i32 0, i32 0
  %y21 = getelementptr inbounds %struct.anon.2, ptr %36, i32 0, i32 1
  %37 = load float, ptr %y21, align 4
  %cmp22 = fcmp olt float %34, %37
  br i1 %cmp22, label %cond.true23, label %cond.false24

cond.true23:                                      ; preds = %lor.lhs.false19, %cond.end14
  br label %cond.end26

cond.false24:                                     ; preds = %lor.lhs.false19
  %38 = load i8, ptr %overlap, align 1
  %tobool25 = trunc i8 %38 to i1
  br label %cond.end26

cond.end26:                                       ; preds = %cond.false24, %cond.true23
  %cond27 = phi i1 [ false, %cond.true23 ], [ %tobool25, %cond.false24 ]
  %frombool28 = zext i1 %cond27 to i8
  store i8 %frombool28, ptr %overlap, align 1
  %39 = load i8, ptr %overlap, align 1
  %tobool29 = trunc i8 %39 to i1
  ret i1 %tobool29
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3Int2EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %this1, i32 0, i32 0
  call void @_ZN18b3AlignedAllocatorI6b3Int2Lj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator)
  call void @_ZN20b3AlignedObjectArrayI6b3Int2E4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3Int2E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %newsize, ptr noundef nonnull align 4 dereferenceable(8) %fillData) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %newsize.addr = alloca i32, align 4
  %fillData.addr = alloca ptr, align 8
  %curSize = alloca i32, align 4
  %i = alloca i32, align 4
  %i6 = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %newsize, ptr %newsize.addr, align 4
  store ptr %fillData, ptr %fillData.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI6b3Int2E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  store i32 %call, ptr %curSize, align 4
  %0 = load i32, ptr %newsize.addr, align 4
  %1 = load i32, ptr %curSize, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %newsize.addr, align 4
  store i32 %2, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i32, ptr %i, align 4
  %4 = load i32, ptr %curSize, align 4
  %cmp2 = icmp slt i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, ptr %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !48

for.end:                                          ; preds = %for.cond
  br label %if.end16

if.else:                                          ; preds = %entry
  %6 = load i32, ptr %newsize.addr, align 4
  %call3 = call noundef i32 @_ZNK20b3AlignedObjectArrayI6b3Int2E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %cmp4 = icmp sgt i32 %6, %call3
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  %7 = load i32, ptr %newsize.addr, align 4
  call void @_ZN20b3AlignedObjectArrayI6b3Int2E7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %7)
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.else
  %8 = load i32, ptr %curSize, align 4
  store i32 %8, ptr %i6, align 4
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc13, %if.end
  %9 = load i32, ptr %i6, align 4
  %10 = load i32, ptr %newsize.addr, align 4
  %cmp8 = icmp slt i32 %9, %10
  br i1 %cmp8, label %for.body9, label %for.end15

for.body9:                                        ; preds = %for.cond7
  %m_data10 = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %this1, i32 0, i32 5
  %11 = load ptr, ptr %m_data10, align 8
  %12 = load i32, ptr %i6, align 4
  %idxprom11 = sext i32 %12 to i64
  %arrayidx12 = getelementptr inbounds %struct.b3Int2, ptr %11, i64 %idxprom11
  %13 = load ptr, ptr %fillData.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx12, ptr align 4 %13, i64 8, i1 false)
  br label %for.inc13

for.inc13:                                        ; preds = %for.body9
  %14 = load i32, ptr %i6, align 4
  %inc14 = add nsw i32 %14, 1
  store i32 %inc14, ptr %i6, align 4
  br label %for.cond7, !llvm.loop !49

for.end15:                                        ; preds = %for.cond7
  br label %if.end16

if.end16:                                         ; preds = %for.end15, %for.end
  %15 = load i32, ptr %newsize.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %this1, i32 0, i32 2
  store i32 %15, ptr %m_size, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 4 dereferenceable(8) ptr @_ZN20b3AlignedObjectArrayI6b3Int2EixEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3Int2, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeEixEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3QuantizedBvhNode, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK18b3QuantizedBvhNode10isLeafNodeEv(ptr noundef nonnull align 16 dereferenceable(16) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_escapeIndexOrTriangleIndex = getelementptr inbounds %struct.b3QuantizedBvhNodeData, ptr %this1, i32 0, i32 2
  %0 = load i32, ptr %m_escapeIndexOrTriangleIndex, align 4
  %cmp = icmp sge i32 %0, 0
  ret i1 %cmp
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK18b3QuantizedBvhNode14getEscapeIndexEv(ptr noundef nonnull align 16 dereferenceable(16) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_escapeIndexOrTriangleIndex = getelementptr inbounds %struct.b3QuantizedBvhNodeData, ptr %this1, i32 0, i32 2
  %0 = load i32, ptr %m_escapeIndexOrTriangleIndex, align 4
  %sub = sub nsw i32 0, %0
  ret i32 %sub
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local i64 @_Z10b3MakeInt2ii(i32 noundef %x, i32 noundef %y) #3 comdat {
entry:
  %retval = alloca %struct.b3Int2, align 4
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  store i32 %x, ptr %x.addr, align 4
  store i32 %y, ptr %y.addr, align 4
  %0 = load i32, ptr %x.addr, align 4
  %1 = getelementptr inbounds %struct.b3Int2, ptr %retval, i32 0, i32 0
  %s = getelementptr inbounds %struct.anon.57, ptr %1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [2 x i32], ptr %s, i64 0, i64 0
  store i32 %0, ptr %arrayidx, align 4
  %2 = load i32, ptr %y.addr, align 4
  %3 = getelementptr inbounds %struct.b3Int2, ptr %retval, i32 0, i32 0
  %s1 = getelementptr inbounds %struct.anon.57, ptr %3, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [2 x i32], ptr %s1, i64 0, i64 1
  store i32 %2, ptr %arrayidx2, align 4
  %coerce.dive = getelementptr inbounds %struct.b3Int2, ptr %retval, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %union.anon.55, ptr %coerce.dive, i32 0, i32 0
  %4 = load i64, ptr %coerce.dive3, align 4
  ret i64 %4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK18b3QuantizedBvhNode16getTriangleIndexEv(ptr noundef nonnull align 16 dereferenceable(16) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x = alloca i32, align 4
  %y = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store i32 0, ptr %x, align 4
  %0 = load i32, ptr %x, align 4
  %and = and i32 %0, 0
  %not = xor i32 %and, -1
  %shl = shl i32 %not, 21
  store i32 %shl, ptr %y, align 4
  %m_escapeIndexOrTriangleIndex = getelementptr inbounds %struct.b3QuantizedBvhNodeData, ptr %this1, i32 0, i32 2
  %1 = load i32, ptr %m_escapeIndexOrTriangleIndex, align 4
  %2 = load i32, ptr %y, align 4
  %not2 = xor i32 %2, -1
  %and3 = and i32 %1, %not2
  ret i32 %and3
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 4 dereferenceable(4) ptr @_Z5b3MaxIiERKT_S2_S2_(ptr noundef nonnull align 4 dereferenceable(4) %a, ptr noundef nonnull align 4 dereferenceable(4) %b) #3 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %1 = load i32, ptr %0, align 4
  %2 = load ptr, ptr %b.addr, align 8
  %3 = load i32, ptr %2, align 4
  %cmp = icmp sgt i32 %1, %3
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load ptr, ptr %a.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load ptr, ptr %b.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond-lvalue = phi ptr [ %4, %cond.true ], [ %5, %cond.false ]
  ret ptr %cond-lvalue
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3Int2ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #3 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  invoke void @_ZN20b3AlignedObjectArrayI6b3Int2E5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #14
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_ZplRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %v1, ptr noundef nonnull align 16 dereferenceable(16) %v2) #2 comdat {
entry:
  %retval = alloca %class.b3Vector3, align 16
  %v1.addr = alloca ptr, align 8
  %v2.addr = alloca ptr, align 8
  store ptr %v1, ptr %v1.addr, align 8
  store ptr %v2, ptr %v2.addr, align 8
  %0 = load ptr, ptr %v1.addr, align 8
  %1 = getelementptr inbounds %class.b3Vector3, ptr %0, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x float], ptr %1, i64 0, i64 0
  %2 = load float, ptr %arrayidx, align 16
  %3 = load ptr, ptr %v2.addr, align 8
  %4 = getelementptr inbounds %class.b3Vector3, ptr %3, i32 0, i32 0
  %arrayidx1 = getelementptr inbounds [4 x float], ptr %4, i64 0, i64 0
  %5 = load float, ptr %arrayidx1, align 16
  %add = fadd float %2, %5
  %6 = load ptr, ptr %v1.addr, align 8
  %7 = getelementptr inbounds %class.b3Vector3, ptr %6, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [4 x float], ptr %7, i64 0, i64 1
  %8 = load float, ptr %arrayidx2, align 4
  %9 = load ptr, ptr %v2.addr, align 8
  %10 = getelementptr inbounds %class.b3Vector3, ptr %9, i32 0, i32 0
  %arrayidx3 = getelementptr inbounds [4 x float], ptr %10, i64 0, i64 1
  %11 = load float, ptr %arrayidx3, align 4
  %add4 = fadd float %8, %11
  %12 = load ptr, ptr %v1.addr, align 8
  %13 = getelementptr inbounds %class.b3Vector3, ptr %12, i32 0, i32 0
  %arrayidx5 = getelementptr inbounds [4 x float], ptr %13, i64 0, i64 2
  %14 = load float, ptr %arrayidx5, align 8
  %15 = load ptr, ptr %v2.addr, align 8
  %16 = getelementptr inbounds %class.b3Vector3, ptr %15, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [4 x float], ptr %16, i64 0, i64 2
  %17 = load float, ptr %arrayidx6, align 8
  %add7 = fadd float %14, %17
  %call = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef %add, float noundef %add4, float noundef %add7)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive8 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %18 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive8, i32 0, i32 0
  %19 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %19, ptr %18, align 16
  %20 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive8, i32 0, i32 1
  %21 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %21, ptr %20, align 8
  %coerce.dive9 = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive10 = getelementptr inbounds %union.anon.1, ptr %coerce.dive9, i32 0, i32 0
  %22 = load { <2 x float>, <2 x float> }, ptr %coerce.dive10, align 16
  ret { <2 x float>, <2 x float> } %22
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(32) ptr @_ZNK20b3AlignedObjectArrayI6b3AabbEixEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3Aabb, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define dso_local void @_Z26processCompoundPairsKernelPK6b3Int4PK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataRK20b3AlignedObjectArrayI9b3Vector3ESF_RKSB_I9b3GpuFaceERKSB_IiEP6b3AabbPK15b3GpuChildShapeRSD_RSK_ii(ptr noundef %gpuCompoundPairs, ptr noundef %rigidBodies, ptr noundef %collidables, ptr noundef %convexShapes, ptr noundef nonnull align 8 dereferenceable(25) %vertices, ptr noundef nonnull align 8 dereferenceable(25) %uniqueEdges, ptr noundef nonnull align 8 dereferenceable(25) %faces, ptr noundef nonnull align 8 dereferenceable(25) %indices, ptr noundef %aabbs, ptr noundef %gpuChildShapes, ptr noundef nonnull align 8 dereferenceable(25) %gpuCompoundSepNormalsOut, ptr noundef nonnull align 8 dereferenceable(25) %gpuHasCompoundSepNormalsOut, i32 noundef %numCompoundPairs, i32 noundef %i) #2 {
entry:
  %gpuCompoundPairs.addr = alloca ptr, align 8
  %rigidBodies.addr = alloca ptr, align 8
  %collidables.addr = alloca ptr, align 8
  %convexShapes.addr = alloca ptr, align 8
  %vertices.addr = alloca ptr, align 8
  %uniqueEdges.addr = alloca ptr, align 8
  %faces.addr = alloca ptr, align 8
  %indices.addr = alloca ptr, align 8
  %aabbs.addr = alloca ptr, align 8
  %gpuChildShapes.addr = alloca ptr, align 8
  %gpuCompoundSepNormalsOut.addr = alloca ptr, align 8
  %gpuHasCompoundSepNormalsOut.addr = alloca ptr, align 8
  %numCompoundPairs.addr = alloca i32, align 4
  %i.addr = alloca i32, align 4
  %bodyIndexA = alloca i32, align 4
  %bodyIndexB = alloca i32, align 4
  %childShapeIndexA = alloca i32, align 4
  %childShapeIndexB = alloca i32, align 4
  %collidableIndexA = alloca i32, align 4
  %collidableIndexB = alloca i32, align 4
  %ornA = alloca %class.b3Quaternion, align 16
  %posA = alloca %class.b3Vector3, align 16
  %ornB = alloca %class.b3Quaternion, align 16
  %posB = alloca %class.b3Vector3, align 16
  %childPosA = alloca %class.b3Vector3, align 16
  %childOrnA = alloca %class.b3Quaternion, align 16
  %newPosA = alloca %class.b3Vector3, align 16
  %ref.tmp = alloca %class.b3Vector3, align 16
  %newOrnA = alloca %class.b3Quaternion, align 16
  %childPosB = alloca %class.b3Vector3, align 16
  %childOrnB = alloca %class.b3Quaternion, align 16
  %newPosB = alloca %class.b3Vector3, align 16
  %ref.tmp45 = alloca %class.b3Vector3, align 16
  %newOrnB = alloca %class.b3Quaternion, align 16
  %shapeIndexA = alloca i32, align 4
  %shapeIndexB = alloca i32, align 4
  %shapeTypeA = alloca i32, align 4
  %shapeTypeB = alloca i32, align 4
  %hasSeparatingAxis = alloca i32, align 4
  %dmin = alloca float, align 4
  %c0local = alloca %class.b3Vector3, align 16
  %c0 = alloca %class.b3Vector3, align 16
  %c1local = alloca %class.b3Vector3, align 16
  %c1 = alloca %class.b3Vector3, align 16
  %DeltaC2 = alloca %class.b3Vector3, align 16
  %sepNormal = alloca %class.b3Vector3, align 16
  %sepA = alloca i8, align 1
  %sepB = alloca i8, align 1
  %sepEE = alloca i8, align 1
  store ptr %gpuCompoundPairs, ptr %gpuCompoundPairs.addr, align 8
  store ptr %rigidBodies, ptr %rigidBodies.addr, align 8
  store ptr %collidables, ptr %collidables.addr, align 8
  store ptr %convexShapes, ptr %convexShapes.addr, align 8
  store ptr %vertices, ptr %vertices.addr, align 8
  store ptr %uniqueEdges, ptr %uniqueEdges.addr, align 8
  store ptr %faces, ptr %faces.addr, align 8
  store ptr %indices, ptr %indices.addr, align 8
  store ptr %aabbs, ptr %aabbs.addr, align 8
  store ptr %gpuChildShapes, ptr %gpuChildShapes.addr, align 8
  store ptr %gpuCompoundSepNormalsOut, ptr %gpuCompoundSepNormalsOut.addr, align 8
  store ptr %gpuHasCompoundSepNormalsOut, ptr %gpuHasCompoundSepNormalsOut.addr, align 8
  store i32 %numCompoundPairs, ptr %numCompoundPairs.addr, align 4
  store i32 %i, ptr %i.addr, align 4
  %0 = load i32, ptr %i.addr, align 4
  %1 = load i32, ptr %numCompoundPairs.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end123

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %gpuCompoundPairs.addr, align 8
  %3 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds %struct.b3Int4, ptr %2, i64 %idxprom
  %4 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %x, align 16
  store i32 %5, ptr %bodyIndexA, align 4
  %6 = load ptr, ptr %gpuCompoundPairs.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idxprom1 = sext i32 %7 to i64
  %arrayidx2 = getelementptr inbounds %struct.b3Int4, ptr %6, i64 %idxprom1
  %8 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx2, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon, ptr %8, i32 0, i32 1
  %9 = load i32, ptr %y, align 4
  store i32 %9, ptr %bodyIndexB, align 4
  %10 = load ptr, ptr %gpuCompoundPairs.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idxprom3 = sext i32 %11 to i64
  %arrayidx4 = getelementptr inbounds %struct.b3Int4, ptr %10, i64 %idxprom3
  %12 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx4, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon, ptr %12, i32 0, i32 2
  %13 = load i32, ptr %z, align 8
  store i32 %13, ptr %childShapeIndexA, align 4
  %14 = load ptr, ptr %gpuCompoundPairs.addr, align 8
  %15 = load i32, ptr %i.addr, align 4
  %idxprom5 = sext i32 %15 to i64
  %arrayidx6 = getelementptr inbounds %struct.b3Int4, ptr %14, i64 %idxprom5
  %16 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx6, i32 0, i32 0
  %w = getelementptr inbounds %struct.anon, ptr %16, i32 0, i32 3
  %17 = load i32, ptr %w, align 4
  store i32 %17, ptr %childShapeIndexB, align 4
  store i32 -1, ptr %collidableIndexA, align 4
  store i32 -1, ptr %collidableIndexB, align 4
  %18 = load ptr, ptr %rigidBodies.addr, align 8
  %19 = load i32, ptr %bodyIndexA, align 4
  %idxprom7 = sext i32 %19 to i64
  %arrayidx8 = getelementptr inbounds %struct.b3RigidBodyData, ptr %18, i64 %idxprom7
  %m_quat = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx8, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornA, ptr align 16 %m_quat, i64 16, i1 false)
  %20 = load ptr, ptr %rigidBodies.addr, align 8
  %21 = load i32, ptr %bodyIndexA, align 4
  %idxprom9 = sext i32 %21 to i64
  %arrayidx10 = getelementptr inbounds %struct.b3RigidBodyData, ptr %20, i64 %idxprom9
  %m_pos = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx10, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posA, ptr align 16 %m_pos, i64 16, i1 false)
  %22 = load ptr, ptr %rigidBodies.addr, align 8
  %23 = load i32, ptr %bodyIndexB, align 4
  %idxprom11 = sext i32 %23 to i64
  %arrayidx12 = getelementptr inbounds %struct.b3RigidBodyData, ptr %22, i64 %idxprom11
  %m_quat13 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx12, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornB, ptr align 16 %m_quat13, i64 16, i1 false)
  %24 = load ptr, ptr %rigidBodies.addr, align 8
  %25 = load i32, ptr %bodyIndexB, align 4
  %idxprom14 = sext i32 %25 to i64
  %arrayidx15 = getelementptr inbounds %struct.b3RigidBodyData, ptr %24, i64 %idxprom14
  %m_pos16 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx15, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posB, ptr align 16 %m_pos16, i64 16, i1 false)
  %26 = load i32, ptr %childShapeIndexA, align 4
  %cmp17 = icmp sge i32 %26, 0
  br i1 %cmp17, label %if.then18, label %if.else

if.then18:                                        ; preds = %if.then
  %27 = load ptr, ptr %gpuChildShapes.addr, align 8
  %28 = load i32, ptr %childShapeIndexA, align 4
  %idxprom19 = sext i32 %28 to i64
  %arrayidx20 = getelementptr inbounds %struct.b3GpuChildShape, ptr %27, i64 %idxprom19
  %29 = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx20, i32 0, i32 2
  %30 = load i32, ptr %29, align 16
  store i32 %30, ptr %collidableIndexA, align 4
  %31 = load ptr, ptr %gpuChildShapes.addr, align 8
  %32 = load i32, ptr %childShapeIndexA, align 4
  %idxprom21 = sext i32 %32 to i64
  %arrayidx22 = getelementptr inbounds %struct.b3GpuChildShape, ptr %31, i64 %idxprom21
  %m_childPosition = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx22, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %childPosA, ptr align 16 %m_childPosition, i64 16, i1 false)
  %33 = load ptr, ptr %gpuChildShapes.addr, align 8
  %34 = load i32, ptr %childShapeIndexA, align 4
  %idxprom23 = sext i32 %34 to i64
  %arrayidx24 = getelementptr inbounds %struct.b3GpuChildShape, ptr %33, i64 %idxprom23
  %m_childOrientation = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx24, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %childOrnA, ptr align 16 %m_childOrientation, i64 16, i1 false)
  %call = call { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %childPosA)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive25 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %35 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive25, i32 0, i32 0
  %36 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %36, ptr %35, align 16
  %37 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive25, i32 0, i32 1
  %38 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %38, ptr %37, align 8
  %call26 = call { <2 x float>, <2 x float> } @_ZplRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp, ptr noundef nonnull align 16 dereferenceable(16) %posA)
  %coerce.dive27 = getelementptr inbounds %class.b3Vector3, ptr %newPosA, i32 0, i32 0
  %coerce.dive28 = getelementptr inbounds %union.anon.1, ptr %coerce.dive27, i32 0, i32 0
  %39 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive28, i32 0, i32 0
  %40 = extractvalue { <2 x float>, <2 x float> } %call26, 0
  store <2 x float> %40, ptr %39, align 16
  %41 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive28, i32 0, i32 1
  %42 = extractvalue { <2 x float>, <2 x float> } %call26, 1
  store <2 x float> %42, ptr %41, align 8
  %call29 = call { <2 x float>, <2 x float> } @_Z9b3QuatMulRK12b3QuaternionS1_(ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %childOrnA)
  %coerce.dive30 = getelementptr inbounds %class.b3Quaternion, ptr %newOrnA, i32 0, i32 0
  %coerce.dive31 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive30, i32 0, i32 0
  %coerce.dive32 = getelementptr inbounds %union.anon.3, ptr %coerce.dive31, i32 0, i32 0
  %43 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive32, i32 0, i32 0
  %44 = extractvalue { <2 x float>, <2 x float> } %call29, 0
  store <2 x float> %44, ptr %43, align 16
  %45 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive32, i32 0, i32 1
  %46 = extractvalue { <2 x float>, <2 x float> } %call29, 1
  store <2 x float> %46, ptr %45, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posA, ptr align 16 %newPosA, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornA, ptr align 16 %newOrnA, i64 16, i1 false)
  br label %if.end

if.else:                                          ; preds = %if.then
  %47 = load ptr, ptr %rigidBodies.addr, align 8
  %48 = load i32, ptr %bodyIndexA, align 4
  %idxprom33 = sext i32 %48 to i64
  %arrayidx34 = getelementptr inbounds %struct.b3RigidBodyData, ptr %47, i64 %idxprom33
  %m_collidableIdx = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx34, i32 0, i32 4
  %49 = load i32, ptr %m_collidableIdx, align 16
  store i32 %49, ptr %collidableIndexA, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then18
  %50 = load i32, ptr %childShapeIndexB, align 4
  %cmp35 = icmp sge i32 %50, 0
  br i1 %cmp35, label %if.then36, label %if.else56

if.then36:                                        ; preds = %if.end
  %51 = load ptr, ptr %gpuChildShapes.addr, align 8
  %52 = load i32, ptr %childShapeIndexB, align 4
  %idxprom37 = sext i32 %52 to i64
  %arrayidx38 = getelementptr inbounds %struct.b3GpuChildShape, ptr %51, i64 %idxprom37
  %53 = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx38, i32 0, i32 2
  %54 = load i32, ptr %53, align 16
  store i32 %54, ptr %collidableIndexB, align 4
  %55 = load ptr, ptr %gpuChildShapes.addr, align 8
  %56 = load i32, ptr %childShapeIndexB, align 4
  %idxprom39 = sext i32 %56 to i64
  %arrayidx40 = getelementptr inbounds %struct.b3GpuChildShape, ptr %55, i64 %idxprom39
  %m_childPosition41 = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx40, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %childPosB, ptr align 16 %m_childPosition41, i64 16, i1 false)
  %57 = load ptr, ptr %gpuChildShapes.addr, align 8
  %58 = load i32, ptr %childShapeIndexB, align 4
  %idxprom42 = sext i32 %58 to i64
  %arrayidx43 = getelementptr inbounds %struct.b3GpuChildShape, ptr %57, i64 %idxprom42
  %m_childOrientation44 = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx43, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %childOrnB, ptr align 16 %m_childOrientation44, i64 16, i1 false)
  %call46 = call { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %childPosB)
  %coerce.dive47 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp45, i32 0, i32 0
  %coerce.dive48 = getelementptr inbounds %union.anon.1, ptr %coerce.dive47, i32 0, i32 0
  %59 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive48, i32 0, i32 0
  %60 = extractvalue { <2 x float>, <2 x float> } %call46, 0
  store <2 x float> %60, ptr %59, align 16
  %61 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive48, i32 0, i32 1
  %62 = extractvalue { <2 x float>, <2 x float> } %call46, 1
  store <2 x float> %62, ptr %61, align 8
  %call49 = call { <2 x float>, <2 x float> } @_ZplRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp45, ptr noundef nonnull align 16 dereferenceable(16) %posB)
  %coerce.dive50 = getelementptr inbounds %class.b3Vector3, ptr %newPosB, i32 0, i32 0
  %coerce.dive51 = getelementptr inbounds %union.anon.1, ptr %coerce.dive50, i32 0, i32 0
  %63 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive51, i32 0, i32 0
  %64 = extractvalue { <2 x float>, <2 x float> } %call49, 0
  store <2 x float> %64, ptr %63, align 16
  %65 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive51, i32 0, i32 1
  %66 = extractvalue { <2 x float>, <2 x float> } %call49, 1
  store <2 x float> %66, ptr %65, align 8
  %call52 = call { <2 x float>, <2 x float> } @_Z9b3QuatMulRK12b3QuaternionS1_(ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %childOrnB)
  %coerce.dive53 = getelementptr inbounds %class.b3Quaternion, ptr %newOrnB, i32 0, i32 0
  %coerce.dive54 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive53, i32 0, i32 0
  %coerce.dive55 = getelementptr inbounds %union.anon.3, ptr %coerce.dive54, i32 0, i32 0
  %67 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive55, i32 0, i32 0
  %68 = extractvalue { <2 x float>, <2 x float> } %call52, 0
  store <2 x float> %68, ptr %67, align 16
  %69 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive55, i32 0, i32 1
  %70 = extractvalue { <2 x float>, <2 x float> } %call52, 1
  store <2 x float> %70, ptr %69, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posB, ptr align 16 %newPosB, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornB, ptr align 16 %newOrnB, i64 16, i1 false)
  br label %if.end60

if.else56:                                        ; preds = %if.end
  %71 = load ptr, ptr %rigidBodies.addr, align 8
  %72 = load i32, ptr %bodyIndexB, align 4
  %idxprom57 = sext i32 %72 to i64
  %arrayidx58 = getelementptr inbounds %struct.b3RigidBodyData, ptr %71, i64 %idxprom57
  %m_collidableIdx59 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx58, i32 0, i32 4
  %73 = load i32, ptr %m_collidableIdx59, align 16
  store i32 %73, ptr %collidableIndexB, align 4
  br label %if.end60

if.end60:                                         ; preds = %if.else56, %if.then36
  %74 = load ptr, ptr %gpuHasCompoundSepNormalsOut.addr, align 8
  %75 = load i32, ptr %i.addr, align 4
  %call61 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiEixEi(ptr noundef nonnull align 8 dereferenceable(25) %74, i32 noundef %75)
  store i32 0, ptr %call61, align 4
  %76 = load ptr, ptr %collidables.addr, align 8
  %77 = load i32, ptr %collidableIndexA, align 4
  %idxprom62 = sext i32 %77 to i64
  %arrayidx63 = getelementptr inbounds %struct.b3Collidable, ptr %76, i64 %idxprom62
  %78 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx63, i32 0, i32 3
  %79 = load i32, ptr %78, align 4
  store i32 %79, ptr %shapeIndexA, align 4
  %80 = load ptr, ptr %collidables.addr, align 8
  %81 = load i32, ptr %collidableIndexB, align 4
  %idxprom64 = sext i32 %81 to i64
  %arrayidx65 = getelementptr inbounds %struct.b3Collidable, ptr %80, i64 %idxprom64
  %82 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx65, i32 0, i32 3
  %83 = load i32, ptr %82, align 4
  store i32 %83, ptr %shapeIndexB, align 4
  %84 = load ptr, ptr %collidables.addr, align 8
  %85 = load i32, ptr %collidableIndexA, align 4
  %idxprom66 = sext i32 %85 to i64
  %arrayidx67 = getelementptr inbounds %struct.b3Collidable, ptr %84, i64 %idxprom66
  %m_shapeType = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx67, i32 0, i32 2
  %86 = load i32, ptr %m_shapeType, align 4
  store i32 %86, ptr %shapeTypeA, align 4
  %87 = load ptr, ptr %collidables.addr, align 8
  %88 = load i32, ptr %collidableIndexB, align 4
  %idxprom68 = sext i32 %88 to i64
  %arrayidx69 = getelementptr inbounds %struct.b3Collidable, ptr %87, i64 %idxprom68
  %m_shapeType70 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx69, i32 0, i32 2
  %89 = load i32, ptr %m_shapeType70, align 4
  store i32 %89, ptr %shapeTypeB, align 4
  %90 = load i32, ptr %shapeTypeA, align 4
  %cmp71 = icmp ne i32 %90, 3
  br i1 %cmp71, label %if.then73, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end60
  %91 = load i32, ptr %shapeTypeB, align 4
  %cmp72 = icmp ne i32 %91, 3
  br i1 %cmp72, label %if.then73, label %if.end74

if.then73:                                        ; preds = %lor.lhs.false, %if.end60
  br label %if.end123

if.end74:                                         ; preds = %lor.lhs.false
  store i32 5, ptr %hasSeparatingAxis, align 4
  store float 0x47EFFFFFE0000000, ptr %dmin, align 4
  %92 = getelementptr inbounds %class.b3Vector3, ptr %posA, i32 0, i32 0
  %w75 = getelementptr inbounds %struct.anon.2, ptr %92, i32 0, i32 3
  store float 0.000000e+00, ptr %w75, align 4
  %93 = getelementptr inbounds %class.b3Vector3, ptr %posB, i32 0, i32 0
  %w76 = getelementptr inbounds %struct.anon.2, ptr %93, i32 0, i32 3
  store float 0.000000e+00, ptr %w76, align 4
  %94 = load ptr, ptr %convexShapes.addr, align 8
  %95 = load i32, ptr %shapeIndexA, align 4
  %idxprom77 = sext i32 %95 to i64
  %arrayidx78 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %94, i64 %idxprom77
  %m_localCenter = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %arrayidx78, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %c0local, ptr align 16 %m_localCenter, i64 16, i1 false)
  %call79 = call { <2 x float>, <2 x float> } @_Z9transformPK9b3Vector3S1_PK12b3Quaternion(ptr noundef %c0local, ptr noundef %posA, ptr noundef %ornA)
  %coerce.dive80 = getelementptr inbounds %class.b3Vector3, ptr %c0, i32 0, i32 0
  %coerce.dive81 = getelementptr inbounds %union.anon.1, ptr %coerce.dive80, i32 0, i32 0
  %96 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive81, i32 0, i32 0
  %97 = extractvalue { <2 x float>, <2 x float> } %call79, 0
  store <2 x float> %97, ptr %96, align 16
  %98 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive81, i32 0, i32 1
  %99 = extractvalue { <2 x float>, <2 x float> } %call79, 1
  store <2 x float> %99, ptr %98, align 8
  %100 = load ptr, ptr %convexShapes.addr, align 8
  %101 = load i32, ptr %shapeIndexB, align 4
  %idxprom82 = sext i32 %101 to i64
  %arrayidx83 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %100, i64 %idxprom82
  %m_localCenter84 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %arrayidx83, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %c1local, ptr align 16 %m_localCenter84, i64 16, i1 false)
  %call85 = call { <2 x float>, <2 x float> } @_Z9transformPK9b3Vector3S1_PK12b3Quaternion(ptr noundef %c1local, ptr noundef %posB, ptr noundef %ornB)
  %coerce.dive86 = getelementptr inbounds %class.b3Vector3, ptr %c1, i32 0, i32 0
  %coerce.dive87 = getelementptr inbounds %union.anon.1, ptr %coerce.dive86, i32 0, i32 0
  %102 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive87, i32 0, i32 0
  %103 = extractvalue { <2 x float>, <2 x float> } %call85, 0
  store <2 x float> %103, ptr %102, align 16
  %104 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive87, i32 0, i32 1
  %105 = extractvalue { <2 x float>, <2 x float> } %call85, 1
  store <2 x float> %105, ptr %104, align 8
  %call88 = call { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %c0, ptr noundef nonnull align 16 dereferenceable(16) %c1)
  %coerce.dive89 = getelementptr inbounds %class.b3Vector3, ptr %DeltaC2, i32 0, i32 0
  %coerce.dive90 = getelementptr inbounds %union.anon.1, ptr %coerce.dive89, i32 0, i32 0
  %106 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive90, i32 0, i32 0
  %107 = extractvalue { <2 x float>, <2 x float> } %call88, 0
  store <2 x float> %107, ptr %106, align 16
  %108 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive90, i32 0, i32 1
  %109 = extractvalue { <2 x float>, <2 x float> } %call88, 1
  store <2 x float> %109, ptr %108, align 8
  %call91 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef 1.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %coerce.dive92 = getelementptr inbounds %class.b3Vector3, ptr %sepNormal, i32 0, i32 0
  %coerce.dive93 = getelementptr inbounds %union.anon.1, ptr %coerce.dive92, i32 0, i32 0
  %110 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive93, i32 0, i32 0
  %111 = extractvalue { <2 x float>, <2 x float> } %call91, 0
  store <2 x float> %111, ptr %110, align 16
  %112 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive93, i32 0, i32 1
  %113 = extractvalue { <2 x float>, <2 x float> } %call91, 1
  store <2 x float> %113, ptr %112, align 8
  %114 = load ptr, ptr %convexShapes.addr, align 8
  %115 = load i32, ptr %shapeIndexA, align 4
  %idxprom94 = sext i32 %115 to i64
  %arrayidx95 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %114, i64 %idxprom94
  %116 = load ptr, ptr %convexShapes.addr, align 8
  %117 = load i32, ptr %shapeIndexB, align 4
  %idxprom96 = sext i32 %117 to i64
  %arrayidx97 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %116, i64 %idxprom96
  %118 = load ptr, ptr %vertices.addr, align 8
  %119 = load ptr, ptr %uniqueEdges.addr, align 8
  %120 = load ptr, ptr %faces.addr, align 8
  %121 = load ptr, ptr %indices.addr, align 8
  %122 = load ptr, ptr %vertices.addr, align 8
  %123 = load ptr, ptr %uniqueEdges.addr, align 8
  %124 = load ptr, ptr %faces.addr, align 8
  %125 = load ptr, ptr %indices.addr, align 8
  %call98 = call noundef zeroext i1 @_ZL18findSeparatingAxisRK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_RK20b3AlignedObjectArrayIS2_ESB_RKS8_I9b3GpuFaceERKS8_IiESB_SB_SF_SI_RS2_(ptr noundef nonnull align 16 dereferenceable(96) %arrayidx95, ptr noundef nonnull align 16 dereferenceable(96) %arrayidx97, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 8 dereferenceable(25) %118, ptr noundef nonnull align 8 dereferenceable(25) %119, ptr noundef nonnull align 8 dereferenceable(25) %120, ptr noundef nonnull align 8 dereferenceable(25) %121, ptr noundef nonnull align 8 dereferenceable(25) %122, ptr noundef nonnull align 8 dereferenceable(25) %123, ptr noundef nonnull align 8 dereferenceable(25) %124, ptr noundef nonnull align 8 dereferenceable(25) %125, ptr noundef nonnull align 16 dereferenceable(16) %sepNormal)
  %frombool = zext i1 %call98 to i8
  store i8 %frombool, ptr %sepA, align 1
  store i32 4, ptr %hasSeparatingAxis, align 4
  %126 = load i8, ptr %sepA, align 1
  %tobool = trunc i8 %126 to i1
  br i1 %tobool, label %if.else100, label %if.then99

if.then99:                                        ; preds = %if.end74
  store i32 0, ptr %hasSeparatingAxis, align 4
  br label %if.end122

if.else100:                                       ; preds = %if.end74
  %127 = load ptr, ptr %convexShapes.addr, align 8
  %128 = load i32, ptr %shapeIndexB, align 4
  %idxprom101 = sext i32 %128 to i64
  %arrayidx102 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %127, i64 %idxprom101
  %129 = load ptr, ptr %convexShapes.addr, align 8
  %130 = load i32, ptr %shapeIndexA, align 4
  %idxprom103 = sext i32 %130 to i64
  %arrayidx104 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %129, i64 %idxprom103
  %131 = load ptr, ptr %vertices.addr, align 8
  %132 = load ptr, ptr %uniqueEdges.addr, align 8
  %133 = load ptr, ptr %faces.addr, align 8
  %134 = load ptr, ptr %indices.addr, align 8
  %135 = load ptr, ptr %vertices.addr, align 8
  %136 = load ptr, ptr %uniqueEdges.addr, align 8
  %137 = load ptr, ptr %faces.addr, align 8
  %138 = load ptr, ptr %indices.addr, align 8
  %call105 = call noundef zeroext i1 @_ZL18findSeparatingAxisRK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_RK20b3AlignedObjectArrayIS2_ESB_RKS8_I9b3GpuFaceERKS8_IiESB_SB_SF_SI_RS2_(ptr noundef nonnull align 16 dereferenceable(96) %arrayidx102, ptr noundef nonnull align 16 dereferenceable(96) %arrayidx104, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 8 dereferenceable(25) %131, ptr noundef nonnull align 8 dereferenceable(25) %132, ptr noundef nonnull align 8 dereferenceable(25) %133, ptr noundef nonnull align 8 dereferenceable(25) %134, ptr noundef nonnull align 8 dereferenceable(25) %135, ptr noundef nonnull align 8 dereferenceable(25) %136, ptr noundef nonnull align 8 dereferenceable(25) %137, ptr noundef nonnull align 8 dereferenceable(25) %138, ptr noundef nonnull align 16 dereferenceable(16) %sepNormal)
  %frombool106 = zext i1 %call105 to i8
  store i8 %frombool106, ptr %sepB, align 1
  %139 = load i8, ptr %sepB, align 1
  %tobool107 = trunc i8 %139 to i1
  br i1 %tobool107, label %if.else109, label %if.then108

if.then108:                                       ; preds = %if.else100
  store i32 0, ptr %hasSeparatingAxis, align 4
  br label %if.end121

if.else109:                                       ; preds = %if.else100
  %140 = load ptr, ptr %convexShapes.addr, align 8
  %141 = load i32, ptr %shapeIndexA, align 4
  %idxprom110 = sext i32 %141 to i64
  %arrayidx111 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %140, i64 %idxprom110
  %142 = load ptr, ptr %convexShapes.addr, align 8
  %143 = load i32, ptr %shapeIndexB, align 4
  %idxprom112 = sext i32 %143 to i64
  %arrayidx113 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %142, i64 %idxprom112
  %144 = load ptr, ptr %vertices.addr, align 8
  %145 = load ptr, ptr %uniqueEdges.addr, align 8
  %146 = load ptr, ptr %faces.addr, align 8
  %147 = load ptr, ptr %indices.addr, align 8
  %call114 = call noundef zeroext i1 @_Z26findSeparatingAxisEdgeEdgePK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_RK20b3AlignedObjectArrayIS2_ESB_RKS8_I9b3GpuFaceERKS8_IiEPS2_Pf(ptr noundef %arrayidx111, ptr noundef %arrayidx113, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %DeltaC2, ptr noundef nonnull align 8 dereferenceable(25) %144, ptr noundef nonnull align 8 dereferenceable(25) %145, ptr noundef nonnull align 8 dereferenceable(25) %146, ptr noundef nonnull align 8 dereferenceable(25) %147, ptr noundef %sepNormal, ptr noundef %dmin)
  %frombool115 = zext i1 %call114 to i8
  store i8 %frombool115, ptr %sepEE, align 1
  %148 = load i8, ptr %sepEE, align 1
  %tobool116 = trunc i8 %148 to i1
  br i1 %tobool116, label %if.then117, label %if.end120

if.then117:                                       ; preds = %if.else109
  %149 = load ptr, ptr %gpuCompoundSepNormalsOut.addr, align 8
  %150 = load i32, ptr %i.addr, align 4
  %call118 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3EixEi(ptr noundef nonnull align 8 dereferenceable(25) %149, i32 noundef %150)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %call118, ptr align 16 %sepNormal, i64 16, i1 false)
  %151 = load ptr, ptr %gpuHasCompoundSepNormalsOut.addr, align 8
  %152 = load i32, ptr %i.addr, align 4
  %call119 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiEixEi(ptr noundef nonnull align 8 dereferenceable(25) %151, i32 noundef %152)
  store i32 1, ptr %call119, align 4
  br label %if.end120

if.end120:                                        ; preds = %if.then117, %if.else109
  br label %if.end121

if.end121:                                        ; preds = %if.end120, %if.then108
  br label %if.end122

if.end122:                                        ; preds = %if.end121, %if.then99
  br label %if.end123

if.end123:                                        ; preds = %if.end122, %if.then73, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiEixEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds i32, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define internal noundef zeroext i1 @_ZL18findSeparatingAxisRK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_RK20b3AlignedObjectArrayIS2_ESB_RKS8_I9b3GpuFaceERKS8_IiESB_SB_SF_SI_RS2_(ptr noundef nonnull align 16 dereferenceable(96) %hullA, ptr noundef nonnull align 16 dereferenceable(96) %hullB, ptr noundef nonnull align 16 dereferenceable(16) %posA1, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB1, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 8 dereferenceable(25) %verticesA, ptr noundef nonnull align 8 dereferenceable(25) %uniqueEdgesA, ptr noundef nonnull align 8 dereferenceable(25) %facesA, ptr noundef nonnull align 8 dereferenceable(25) %indicesA, ptr noundef nonnull align 8 dereferenceable(25) %verticesB, ptr noundef nonnull align 8 dereferenceable(25) %uniqueEdgesB, ptr noundef nonnull align 8 dereferenceable(25) %facesB, ptr noundef nonnull align 8 dereferenceable(25) %indicesB, ptr noundef nonnull align 16 dereferenceable(16) %sep) #2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca i1, align 1
  %hullA.addr = alloca ptr, align 8
  %hullB.addr = alloca ptr, align 8
  %posA1.addr = alloca ptr, align 8
  %ornA.addr = alloca ptr, align 8
  %posB1.addr = alloca ptr, align 8
  %ornB.addr = alloca ptr, align 8
  %verticesA.addr = alloca ptr, align 8
  %uniqueEdgesA.addr = alloca ptr, align 8
  %facesA.addr = alloca ptr, align 8
  %indicesA.addr = alloca ptr, align 8
  %verticesB.addr = alloca ptr, align 8
  %uniqueEdgesB.addr = alloca ptr, align 8
  %facesB.addr = alloca ptr, align 8
  %indicesB.addr = alloca ptr, align 8
  %sep.addr = alloca ptr, align 8
  %__profile = alloca %class.b3ProfileZone, align 1
  %posA = alloca %class.b3Vector3, align 16
  %posB = alloca %class.b3Vector3, align 16
  %c0local = alloca %class.b3Vector3, align 16
  %c0 = alloca %class.b3Vector3, align 16
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %c1local = alloca %class.b3Vector3, align 16
  %c1 = alloca %class.b3Vector3, align 16
  %deltaC2 = alloca %class.b3Vector3, align 16
  %dmin = alloca float, align 4
  %curPlaneTests = alloca i32, align 4
  %numFacesA = alloca i32, align 4
  %i = alloca i32, align 4
  %normal = alloca ptr, align 8
  %faceANormalWS = alloca %class.b3Vector3, align 16
  %ref.tmp = alloca float, align 4
  %d = alloca float, align 4
  %cleanup.dest.slot = alloca i32, align 4
  %numFacesB = alloca i32, align 4
  %i32 = alloca i32, align 4
  %normal36 = alloca %class.b3Vector3, align 16
  %WorldNormal = alloca %class.b3Vector3, align 16
  %ref.tmp50 = alloca float, align 4
  %d54 = alloca float, align 4
  %curEdgeEdge = alloca i32, align 4
  %e0 = alloca i32, align 4
  %edge0 = alloca ptr, align 8
  %edge0World = alloca %class.b3Vector3, align 16
  %e1 = alloca i32, align 4
  %edge1 = alloca %class.b3Vector3, align 16
  %edge1World = alloca %class.b3Vector3, align 16
  %crossje = alloca %class.b3Vector3, align 16
  %ref.tmp100 = alloca float, align 4
  %dist = alloca float, align 4
  %ref.tmp117 = alloca %class.b3Vector3, align 16
  %ref.tmp126 = alloca %class.b3Vector3, align 16
  store ptr %hullA, ptr %hullA.addr, align 8
  store ptr %hullB, ptr %hullB.addr, align 8
  store ptr %posA1, ptr %posA1.addr, align 8
  store ptr %ornA, ptr %ornA.addr, align 8
  store ptr %posB1, ptr %posB1.addr, align 8
  store ptr %ornB, ptr %ornB.addr, align 8
  store ptr %verticesA, ptr %verticesA.addr, align 8
  store ptr %uniqueEdgesA, ptr %uniqueEdgesA.addr, align 8
  store ptr %facesA, ptr %facesA.addr, align 8
  store ptr %indicesA, ptr %indicesA.addr, align 8
  store ptr %verticesB, ptr %verticesB.addr, align 8
  store ptr %uniqueEdgesB, ptr %uniqueEdgesB.addr, align 8
  store ptr %facesB, ptr %facesB.addr, align 8
  store ptr %indicesB, ptr %indicesB.addr, align 8
  store ptr %sep, ptr %sep.addr, align 8
  call void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %__profile, ptr noundef @.str.73)
  %0 = load i32, ptr @b3g_actualSATPairTests, align 4
  %inc = add nsw i32 %0, 1
  store i32 %inc, ptr @b3g_actualSATPairTests, align 4
  %1 = load ptr, ptr %posA1.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posA, ptr align 16 %1, i64 16, i1 false)
  %2 = getelementptr inbounds %class.b3Vector3, ptr %posA, i32 0, i32 0
  %w = getelementptr inbounds %struct.anon.2, ptr %2, i32 0, i32 3
  store float 0.000000e+00, ptr %w, align 4
  %3 = load ptr, ptr %posB1.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posB, ptr align 16 %3, i64 16, i1 false)
  %4 = getelementptr inbounds %class.b3Vector3, ptr %posB, i32 0, i32 0
  %w1 = getelementptr inbounds %struct.anon.2, ptr %4, i32 0, i32 3
  store float 0.000000e+00, ptr %w1, align 4
  %5 = load ptr, ptr %hullA.addr, align 8
  %m_localCenter = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %5, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %c0local, ptr align 16 %m_localCenter, i64 16, i1 false)
  %6 = load ptr, ptr %ornA.addr, align 8
  %call = invoke { <2 x float>, <2 x float> } @_Z9transformPK9b3Vector3S1_PK12b3Quaternion(ptr noundef %c0local, ptr noundef %posA, ptr noundef %6)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %c0, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %7 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive2, i32 0, i32 0
  %8 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %8, ptr %7, align 16
  %9 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive2, i32 0, i32 1
  %10 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %10, ptr %9, align 8
  %11 = load ptr, ptr %hullB.addr, align 8
  %m_localCenter3 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %11, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %c1local, ptr align 16 %m_localCenter3, i64 16, i1 false)
  %12 = load ptr, ptr %ornB.addr, align 8
  %call5 = invoke { <2 x float>, <2 x float> } @_Z9transformPK9b3Vector3S1_PK12b3Quaternion(ptr noundef %c1local, ptr noundef %posB, ptr noundef %12)
          to label %invoke.cont4 unwind label %lpad

invoke.cont4:                                     ; preds = %invoke.cont
  %coerce.dive6 = getelementptr inbounds %class.b3Vector3, ptr %c1, i32 0, i32 0
  %coerce.dive7 = getelementptr inbounds %union.anon.1, ptr %coerce.dive6, i32 0, i32 0
  %13 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive7, i32 0, i32 0
  %14 = extractvalue { <2 x float>, <2 x float> } %call5, 0
  store <2 x float> %14, ptr %13, align 16
  %15 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive7, i32 0, i32 1
  %16 = extractvalue { <2 x float>, <2 x float> } %call5, 1
  store <2 x float> %16, ptr %15, align 8
  %call9 = invoke { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %c0, ptr noundef nonnull align 16 dereferenceable(16) %c1)
          to label %invoke.cont8 unwind label %lpad

invoke.cont8:                                     ; preds = %invoke.cont4
  %coerce.dive10 = getelementptr inbounds %class.b3Vector3, ptr %deltaC2, i32 0, i32 0
  %coerce.dive11 = getelementptr inbounds %union.anon.1, ptr %coerce.dive10, i32 0, i32 0
  %17 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive11, i32 0, i32 0
  %18 = extractvalue { <2 x float>, <2 x float> } %call9, 0
  store <2 x float> %18, ptr %17, align 16
  %19 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive11, i32 0, i32 1
  %20 = extractvalue { <2 x float>, <2 x float> } %call9, 1
  store <2 x float> %20, ptr %19, align 8
  store float 0x47EFFFFFE0000000, ptr %dmin, align 4
  store i32 0, ptr %curPlaneTests, align 4
  %21 = load ptr, ptr %hullA.addr, align 8
  %m_numFaces = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %21, i32 0, i32 6
  %22 = load i32, ptr %m_numFaces, align 8
  store i32 %22, ptr %numFacesA, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %invoke.cont8
  %23 = load i32, ptr %i, align 4
  %24 = load i32, ptr %numFacesA, align 4
  %cmp = icmp slt i32 %23, %24
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %25 = load ptr, ptr %facesA.addr, align 8
  %26 = load ptr, ptr %hullA.addr, align 8
  %m_faceOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %26, i32 0, i32 5
  %27 = load i32, ptr %m_faceOffset, align 4
  %28 = load i32, ptr %i, align 4
  %add = add nsw i32 %27, %28
  %call13 = invoke noundef nonnull align 16 dereferenceable(32) ptr @_ZNK20b3AlignedObjectArrayI9b3GpuFaceEixEi(ptr noundef nonnull align 8 dereferenceable(25) %25, i32 noundef %add)
          to label %invoke.cont12 unwind label %lpad

invoke.cont12:                                    ; preds = %for.body
  %m_plane = getelementptr inbounds %struct.b3GpuFace, ptr %call13, i32 0, i32 0
  store ptr %m_plane, ptr %normal, align 8
  %29 = load ptr, ptr %ornA.addr, align 8
  %30 = load ptr, ptr %normal, align 8
  %call15 = invoke { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %29, ptr noundef nonnull align 16 dereferenceable(16) %30)
          to label %invoke.cont14 unwind label %lpad

invoke.cont14:                                    ; preds = %invoke.cont12
  %coerce.dive16 = getelementptr inbounds %class.b3Vector3, ptr %faceANormalWS, i32 0, i32 0
  %coerce.dive17 = getelementptr inbounds %union.anon.1, ptr %coerce.dive16, i32 0, i32 0
  %31 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive17, i32 0, i32 0
  %32 = extractvalue { <2 x float>, <2 x float> } %call15, 0
  store <2 x float> %32, ptr %31, align 16
  %33 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive17, i32 0, i32 1
  %34 = extractvalue { <2 x float>, <2 x float> } %call15, 1
  store <2 x float> %34, ptr %33, align 8
  %call19 = invoke noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %deltaC2, ptr noundef nonnull align 16 dereferenceable(16) %faceANormalWS)
          to label %invoke.cont18 unwind label %lpad

invoke.cont18:                                    ; preds = %invoke.cont14
  %cmp20 = fcmp olt float %call19, 0.000000e+00
  br i1 %cmp20, label %if.then, label %if.end

if.then:                                          ; preds = %invoke.cont18
  store float -1.000000e+00, ptr %ref.tmp, align 4
  %call21 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector3mLERKf(ptr noundef nonnull align 16 dereferenceable(16) %faceANormalWS, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp)
  br label %if.end

lpad:                                             ; preds = %if.then125, %invoke.cont118, %for.end116, %if.end102, %invoke.cont94, %if.then93, %invoke.cont83, %invoke.cont81, %for.body78, %invoke.cont69, %for.body67, %if.end52, %invoke.cont42, %invoke.cont39, %for.body35, %if.end, %invoke.cont14, %invoke.cont12, %for.body, %invoke.cont4, %invoke.cont, %entry
  %35 = landingpad { ptr, i32 }
          cleanup
  %36 = extractvalue { ptr, i32 } %35, 0
  store ptr %36, ptr %exn.slot, align 8
  %37 = extractvalue { ptr, i32 } %35, 1
  store i32 %37, ptr %ehselector.slot, align 4
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile) #13
  br label %eh.resume

if.end:                                           ; preds = %if.then, %invoke.cont18
  %38 = load i32, ptr %curPlaneTests, align 4
  %inc22 = add nsw i32 %38, 1
  store i32 %inc22, ptr %curPlaneTests, align 4
  %39 = load ptr, ptr %hullA.addr, align 8
  %40 = load ptr, ptr %hullB.addr, align 8
  %41 = load ptr, ptr %ornA.addr, align 8
  %42 = load ptr, ptr %ornB.addr, align 8
  %43 = load ptr, ptr %verticesA.addr, align 8
  %44 = load ptr, ptr %verticesB.addr, align 8
  %call24 = invoke noundef zeroext i1 @_ZL11TestSepAxisRK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_RK20b3AlignedObjectArrayIS2_ESB_Rf(ptr noundef nonnull align 16 dereferenceable(96) %39, ptr noundef nonnull align 16 dereferenceable(96) %40, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %41, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %42, ptr noundef nonnull align 16 dereferenceable(16) %faceANormalWS, ptr noundef nonnull align 8 dereferenceable(25) %43, ptr noundef nonnull align 8 dereferenceable(25) %44, ptr noundef nonnull align 4 dereferenceable(4) %d)
          to label %invoke.cont23 unwind label %lpad

invoke.cont23:                                    ; preds = %if.end
  br i1 %call24, label %if.end26, label %if.then25

if.then25:                                        ; preds = %invoke.cont23
  store i1 false, ptr %retval, align 1
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end26:                                         ; preds = %invoke.cont23
  %45 = load float, ptr %d, align 4
  %46 = load float, ptr %dmin, align 4
  %cmp27 = fcmp olt float %45, %46
  br i1 %cmp27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.end26
  %47 = load float, ptr %d, align 4
  store float %47, ptr %dmin, align 4
  %48 = load ptr, ptr %sep.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %48, ptr align 16 %faceANormalWS, i64 16, i1 false)
  br label %if.end29

if.end29:                                         ; preds = %if.then28, %if.end26
  br label %for.inc

for.inc:                                          ; preds = %if.end29
  %49 = load i32, ptr %i, align 4
  %inc30 = add nsw i32 %49, 1
  store i32 %inc30, ptr %i, align 4
  br label %for.cond, !llvm.loop !50

for.end:                                          ; preds = %for.cond
  %50 = load ptr, ptr %hullB.addr, align 8
  %m_numFaces31 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %50, i32 0, i32 6
  %51 = load i32, ptr %m_numFaces31, align 8
  store i32 %51, ptr %numFacesB, align 4
  store i32 0, ptr %i32, align 4
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc62, %for.end
  %52 = load i32, ptr %i32, align 4
  %53 = load i32, ptr %numFacesB, align 4
  %cmp34 = icmp slt i32 %52, %53
  br i1 %cmp34, label %for.body35, label %for.end64

for.body35:                                       ; preds = %for.cond33
  %54 = load ptr, ptr %facesB.addr, align 8
  %55 = load ptr, ptr %hullB.addr, align 8
  %m_faceOffset37 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %55, i32 0, i32 5
  %56 = load i32, ptr %m_faceOffset37, align 4
  %57 = load i32, ptr %i32, align 4
  %add38 = add nsw i32 %56, %57
  %call40 = invoke noundef nonnull align 16 dereferenceable(32) ptr @_ZNK20b3AlignedObjectArrayI9b3GpuFaceEixEi(ptr noundef nonnull align 8 dereferenceable(25) %54, i32 noundef %add38)
          to label %invoke.cont39 unwind label %lpad

invoke.cont39:                                    ; preds = %for.body35
  %m_plane41 = getelementptr inbounds %struct.b3GpuFace, ptr %call40, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %normal36, ptr align 16 %m_plane41, i64 16, i1 false)
  %58 = load ptr, ptr %ornB.addr, align 8
  %call43 = invoke { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %58, ptr noundef nonnull align 16 dereferenceable(16) %normal36)
          to label %invoke.cont42 unwind label %lpad

invoke.cont42:                                    ; preds = %invoke.cont39
  %coerce.dive44 = getelementptr inbounds %class.b3Vector3, ptr %WorldNormal, i32 0, i32 0
  %coerce.dive45 = getelementptr inbounds %union.anon.1, ptr %coerce.dive44, i32 0, i32 0
  %59 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive45, i32 0, i32 0
  %60 = extractvalue { <2 x float>, <2 x float> } %call43, 0
  store <2 x float> %60, ptr %59, align 16
  %61 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive45, i32 0, i32 1
  %62 = extractvalue { <2 x float>, <2 x float> } %call43, 1
  store <2 x float> %62, ptr %61, align 8
  %call47 = invoke noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %deltaC2, ptr noundef nonnull align 16 dereferenceable(16) %WorldNormal)
          to label %invoke.cont46 unwind label %lpad

invoke.cont46:                                    ; preds = %invoke.cont42
  %cmp48 = fcmp olt float %call47, 0.000000e+00
  br i1 %cmp48, label %if.then49, label %if.end52

if.then49:                                        ; preds = %invoke.cont46
  store float -1.000000e+00, ptr %ref.tmp50, align 4
  %call51 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector3mLERKf(ptr noundef nonnull align 16 dereferenceable(16) %WorldNormal, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp50)
  br label %if.end52

if.end52:                                         ; preds = %if.then49, %invoke.cont46
  %63 = load i32, ptr %curPlaneTests, align 4
  %inc53 = add nsw i32 %63, 1
  store i32 %inc53, ptr %curPlaneTests, align 4
  %64 = load ptr, ptr %hullA.addr, align 8
  %65 = load ptr, ptr %hullB.addr, align 8
  %66 = load ptr, ptr %ornA.addr, align 8
  %67 = load ptr, ptr %ornB.addr, align 8
  %68 = load ptr, ptr %verticesA.addr, align 8
  %69 = load ptr, ptr %verticesB.addr, align 8
  %call56 = invoke noundef zeroext i1 @_ZL11TestSepAxisRK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_RK20b3AlignedObjectArrayIS2_ESB_Rf(ptr noundef nonnull align 16 dereferenceable(96) %64, ptr noundef nonnull align 16 dereferenceable(96) %65, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %66, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %67, ptr noundef nonnull align 16 dereferenceable(16) %WorldNormal, ptr noundef nonnull align 8 dereferenceable(25) %68, ptr noundef nonnull align 8 dereferenceable(25) %69, ptr noundef nonnull align 4 dereferenceable(4) %d54)
          to label %invoke.cont55 unwind label %lpad

invoke.cont55:                                    ; preds = %if.end52
  br i1 %call56, label %if.end58, label %if.then57

if.then57:                                        ; preds = %invoke.cont55
  store i1 false, ptr %retval, align 1
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end58:                                         ; preds = %invoke.cont55
  %70 = load float, ptr %d54, align 4
  %71 = load float, ptr %dmin, align 4
  %cmp59 = fcmp olt float %70, %71
  br i1 %cmp59, label %if.then60, label %if.end61

if.then60:                                        ; preds = %if.end58
  %72 = load float, ptr %d54, align 4
  store float %72, ptr %dmin, align 4
  %73 = load ptr, ptr %sep.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %73, ptr align 16 %WorldNormal, i64 16, i1 false)
  br label %if.end61

if.end61:                                         ; preds = %if.then60, %if.end58
  br label %for.inc62

for.inc62:                                        ; preds = %if.end61
  %74 = load i32, ptr %i32, align 4
  %inc63 = add nsw i32 %74, 1
  store i32 %inc63, ptr %i32, align 4
  br label %for.cond33, !llvm.loop !51

for.end64:                                        ; preds = %for.cond33
  store i32 0, ptr %curEdgeEdge, align 4
  store i32 0, ptr %e0, align 4
  br label %for.cond65

for.cond65:                                       ; preds = %for.inc114, %for.end64
  %75 = load i32, ptr %e0, align 4
  %76 = load ptr, ptr %hullA.addr, align 8
  %m_numUniqueEdges = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %76, i32 0, i32 10
  %77 = load i32, ptr %m_numUniqueEdges, align 8
  %cmp66 = icmp slt i32 %75, %77
  br i1 %cmp66, label %for.body67, label %for.end116

for.body67:                                       ; preds = %for.cond65
  %78 = load ptr, ptr %uniqueEdgesA.addr, align 8
  %79 = load ptr, ptr %hullA.addr, align 8
  %m_uniqueEdgesOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %79, i32 0, i32 9
  %80 = load i32, ptr %m_uniqueEdgesOffset, align 4
  %81 = load i32, ptr %e0, align 4
  %add68 = add nsw i32 %80, %81
  %call70 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZNK20b3AlignedObjectArrayI9b3Vector3EixEi(ptr noundef nonnull align 8 dereferenceable(25) %78, i32 noundef %add68)
          to label %invoke.cont69 unwind label %lpad

invoke.cont69:                                    ; preds = %for.body67
  store ptr %call70, ptr %edge0, align 8
  %82 = load ptr, ptr %ornA.addr, align 8
  %83 = load ptr, ptr %edge0, align 8
  %call72 = invoke { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %82, ptr noundef nonnull align 16 dereferenceable(16) %83)
          to label %invoke.cont71 unwind label %lpad

invoke.cont71:                                    ; preds = %invoke.cont69
  %coerce.dive73 = getelementptr inbounds %class.b3Vector3, ptr %edge0World, i32 0, i32 0
  %coerce.dive74 = getelementptr inbounds %union.anon.1, ptr %coerce.dive73, i32 0, i32 0
  %84 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive74, i32 0, i32 0
  %85 = extractvalue { <2 x float>, <2 x float> } %call72, 0
  store <2 x float> %85, ptr %84, align 16
  %86 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive74, i32 0, i32 1
  %87 = extractvalue { <2 x float>, <2 x float> } %call72, 1
  store <2 x float> %87, ptr %86, align 8
  store i32 0, ptr %e1, align 4
  br label %for.cond75

for.cond75:                                       ; preds = %for.inc111, %invoke.cont71
  %88 = load i32, ptr %e1, align 4
  %89 = load ptr, ptr %hullB.addr, align 8
  %m_numUniqueEdges76 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %89, i32 0, i32 10
  %90 = load i32, ptr %m_numUniqueEdges76, align 8
  %cmp77 = icmp slt i32 %88, %90
  br i1 %cmp77, label %for.body78, label %for.end113

for.body78:                                       ; preds = %for.cond75
  %91 = load ptr, ptr %uniqueEdgesB.addr, align 8
  %92 = load ptr, ptr %hullB.addr, align 8
  %m_uniqueEdgesOffset79 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %92, i32 0, i32 9
  %93 = load i32, ptr %m_uniqueEdgesOffset79, align 4
  %94 = load i32, ptr %e1, align 4
  %add80 = add nsw i32 %93, %94
  %call82 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZNK20b3AlignedObjectArrayI9b3Vector3EixEi(ptr noundef nonnull align 8 dereferenceable(25) %91, i32 noundef %add80)
          to label %invoke.cont81 unwind label %lpad

invoke.cont81:                                    ; preds = %for.body78
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %edge1, ptr align 16 %call82, i64 16, i1 false)
  %95 = load ptr, ptr %ornB.addr, align 8
  %call84 = invoke { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %95, ptr noundef nonnull align 16 dereferenceable(16) %edge1)
          to label %invoke.cont83 unwind label %lpad

invoke.cont83:                                    ; preds = %invoke.cont81
  %coerce.dive85 = getelementptr inbounds %class.b3Vector3, ptr %edge1World, i32 0, i32 0
  %coerce.dive86 = getelementptr inbounds %union.anon.1, ptr %coerce.dive85, i32 0, i32 0
  %96 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive86, i32 0, i32 0
  %97 = extractvalue { <2 x float>, <2 x float> } %call84, 0
  store <2 x float> %97, ptr %96, align 16
  %98 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive86, i32 0, i32 1
  %99 = extractvalue { <2 x float>, <2 x float> } %call84, 1
  store <2 x float> %99, ptr %98, align 8
  %call88 = invoke { <2 x float>, <2 x float> } @_ZNK9b3Vector35crossERKS_(ptr noundef nonnull align 16 dereferenceable(16) %edge0World, ptr noundef nonnull align 16 dereferenceable(16) %edge1World)
          to label %invoke.cont87 unwind label %lpad

invoke.cont87:                                    ; preds = %invoke.cont83
  %coerce.dive89 = getelementptr inbounds %class.b3Vector3, ptr %crossje, i32 0, i32 0
  %coerce.dive90 = getelementptr inbounds %union.anon.1, ptr %coerce.dive89, i32 0, i32 0
  %100 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive90, i32 0, i32 0
  %101 = extractvalue { <2 x float>, <2 x float> } %call88, 0
  store <2 x float> %101, ptr %100, align 16
  %102 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive90, i32 0, i32 1
  %103 = extractvalue { <2 x float>, <2 x float> } %call88, 1
  store <2 x float> %103, ptr %102, align 8
  %104 = load i32, ptr %curEdgeEdge, align 4
  %inc91 = add nsw i32 %104, 1
  store i32 %inc91, ptr %curEdgeEdge, align 4
  %call92 = call noundef zeroext i1 @_Z12IsAlmostZeroRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %crossje)
  br i1 %call92, label %if.end110, label %if.then93

if.then93:                                        ; preds = %invoke.cont87
  %call95 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector39normalizeEv(ptr noundef nonnull align 16 dereferenceable(16) %crossje)
          to label %invoke.cont94 unwind label %lpad

invoke.cont94:                                    ; preds = %if.then93
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %crossje, ptr align 16 %call95, i64 16, i1 false)
  %call97 = invoke noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %deltaC2, ptr noundef nonnull align 16 dereferenceable(16) %crossje)
          to label %invoke.cont96 unwind label %lpad

invoke.cont96:                                    ; preds = %invoke.cont94
  %cmp98 = fcmp olt float %call97, 0.000000e+00
  br i1 %cmp98, label %if.then99, label %if.end102

if.then99:                                        ; preds = %invoke.cont96
  store float -1.000000e+00, ptr %ref.tmp100, align 4
  %call101 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector3mLERKf(ptr noundef nonnull align 16 dereferenceable(16) %crossje, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp100)
  br label %if.end102

if.end102:                                        ; preds = %if.then99, %invoke.cont96
  %105 = load ptr, ptr %hullA.addr, align 8
  %106 = load ptr, ptr %hullB.addr, align 8
  %107 = load ptr, ptr %ornA.addr, align 8
  %108 = load ptr, ptr %ornB.addr, align 8
  %109 = load ptr, ptr %verticesA.addr, align 8
  %110 = load ptr, ptr %verticesB.addr, align 8
  %call104 = invoke noundef zeroext i1 @_ZL11TestSepAxisRK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_RK20b3AlignedObjectArrayIS2_ESB_Rf(ptr noundef nonnull align 16 dereferenceable(96) %105, ptr noundef nonnull align 16 dereferenceable(96) %106, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %107, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %108, ptr noundef nonnull align 16 dereferenceable(16) %crossje, ptr noundef nonnull align 8 dereferenceable(25) %109, ptr noundef nonnull align 8 dereferenceable(25) %110, ptr noundef nonnull align 4 dereferenceable(4) %dist)
          to label %invoke.cont103 unwind label %lpad

invoke.cont103:                                   ; preds = %if.end102
  br i1 %call104, label %if.end106, label %if.then105

if.then105:                                       ; preds = %invoke.cont103
  store i1 false, ptr %retval, align 1
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end106:                                        ; preds = %invoke.cont103
  %111 = load float, ptr %dist, align 4
  %112 = load float, ptr %dmin, align 4
  %cmp107 = fcmp olt float %111, %112
  br i1 %cmp107, label %if.then108, label %if.end109

if.then108:                                       ; preds = %if.end106
  %113 = load float, ptr %dist, align 4
  store float %113, ptr %dmin, align 4
  %114 = load ptr, ptr %sep.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %114, ptr align 16 %crossje, i64 16, i1 false)
  br label %if.end109

if.end109:                                        ; preds = %if.then108, %if.end106
  br label %if.end110

if.end110:                                        ; preds = %if.end109, %invoke.cont87
  br label %for.inc111

for.inc111:                                       ; preds = %if.end110
  %115 = load i32, ptr %e1, align 4
  %inc112 = add nsw i32 %115, 1
  store i32 %inc112, ptr %e1, align 4
  br label %for.cond75, !llvm.loop !52

for.end113:                                       ; preds = %for.cond75
  br label %for.inc114

for.inc114:                                       ; preds = %for.end113
  %116 = load i32, ptr %e0, align 4
  %inc115 = add nsw i32 %116, 1
  store i32 %inc115, ptr %e0, align 4
  br label %for.cond65, !llvm.loop !53

for.end116:                                       ; preds = %for.cond65
  %call119 = invoke { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %deltaC2)
          to label %invoke.cont118 unwind label %lpad

invoke.cont118:                                   ; preds = %for.end116
  %coerce.dive120 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp117, i32 0, i32 0
  %coerce.dive121 = getelementptr inbounds %union.anon.1, ptr %coerce.dive120, i32 0, i32 0
  %117 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive121, i32 0, i32 0
  %118 = extractvalue { <2 x float>, <2 x float> } %call119, 0
  store <2 x float> %118, ptr %117, align 16
  %119 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive121, i32 0, i32 1
  %120 = extractvalue { <2 x float>, <2 x float> } %call119, 1
  store <2 x float> %120, ptr %119, align 8
  %121 = load ptr, ptr %sep.addr, align 8
  %call123 = invoke noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp117, ptr noundef nonnull align 16 dereferenceable(16) %121)
          to label %invoke.cont122 unwind label %lpad

invoke.cont122:                                   ; preds = %invoke.cont118
  %cmp124 = fcmp ogt float %call123, 0.000000e+00
  br i1 %cmp124, label %if.then125, label %if.end131

if.then125:                                       ; preds = %invoke.cont122
  %122 = load ptr, ptr %sep.addr, align 8
  %call128 = invoke { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %122)
          to label %invoke.cont127 unwind label %lpad

invoke.cont127:                                   ; preds = %if.then125
  %coerce.dive129 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp126, i32 0, i32 0
  %coerce.dive130 = getelementptr inbounds %union.anon.1, ptr %coerce.dive129, i32 0, i32 0
  %123 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive130, i32 0, i32 0
  %124 = extractvalue { <2 x float>, <2 x float> } %call128, 0
  store <2 x float> %124, ptr %123, align 16
  %125 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive130, i32 0, i32 1
  %126 = extractvalue { <2 x float>, <2 x float> } %call128, 1
  store <2 x float> %126, ptr %125, align 8
  %127 = load ptr, ptr %sep.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %127, ptr align 16 %ref.tmp126, i64 16, i1 false)
  br label %if.end131

if.end131:                                        ; preds = %invoke.cont127, %invoke.cont122
  store i1 true, ptr %retval, align 1
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end131, %if.then105, %if.then57, %if.then25
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile) #13
  %128 = load i1, ptr %retval, align 1
  ret i1 %128

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val132 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val132
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3EixEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %class.b3Vector3, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define dso_local void @_Z27clipCompoundsHullHullKernelPK6b3Int4PK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataRK20b3AlignedObjectArrayI9b3Vector3ESF_RKSB_I9b3GpuFaceERKSB_IiEPK15b3GpuChildShapeSF_SM_P14b3Contact4DataPiiii(ptr noundef %gpuCompoundPairs, ptr noundef %rigidBodies, ptr noundef %collidables, ptr noundef %convexShapes, ptr noundef nonnull align 8 dereferenceable(25) %vertices, ptr noundef nonnull align 8 dereferenceable(25) %uniqueEdges, ptr noundef nonnull align 8 dereferenceable(25) %faces, ptr noundef nonnull align 8 dereferenceable(25) %indices, ptr noundef %gpuChildShapes, ptr noundef nonnull align 8 dereferenceable(25) %gpuCompoundSepNormalsOut, ptr noundef nonnull align 8 dereferenceable(25) %gpuHasCompoundSepNormalsOut, ptr noundef %globalContactsOut, ptr noundef %nGlobalContactsOut, i32 noundef %numCompoundPairs, i32 noundef %maxContactCapacity, i32 noundef %i) #2 {
entry:
  %gpuCompoundPairs.addr = alloca ptr, align 8
  %rigidBodies.addr = alloca ptr, align 8
  %collidables.addr = alloca ptr, align 8
  %convexShapes.addr = alloca ptr, align 8
  %vertices.addr = alloca ptr, align 8
  %uniqueEdges.addr = alloca ptr, align 8
  %faces.addr = alloca ptr, align 8
  %indices.addr = alloca ptr, align 8
  %gpuChildShapes.addr = alloca ptr, align 8
  %gpuCompoundSepNormalsOut.addr = alloca ptr, align 8
  %gpuHasCompoundSepNormalsOut.addr = alloca ptr, align 8
  %globalContactsOut.addr = alloca ptr, align 8
  %nGlobalContactsOut.addr = alloca ptr, align 8
  %numCompoundPairs.addr = alloca i32, align 4
  %maxContactCapacity.addr = alloca i32, align 4
  %i.addr = alloca i32, align 4
  %pairIndex = alloca i32, align 4
  %worldVertsB1 = alloca [64 x %class.b3Vector3], align 16
  %worldVertsB2 = alloca [64 x %class.b3Vector3], align 16
  %capacityWorldVerts = alloca i32, align 4
  %localContactsOut = alloca [64 x %class.b3Vector3], align 16
  %localContactCapacity = alloca i32, align 4
  %minDist = alloca float, align 4
  %maxDist = alloca float, align 4
  %bodyIndexA = alloca i32, align 4
  %bodyIndexB = alloca i32, align 4
  %childShapeIndexA = alloca i32, align 4
  %childShapeIndexB = alloca i32, align 4
  %collidableIndexA = alloca i32, align 4
  %collidableIndexB = alloca i32, align 4
  %ornA = alloca %class.b3Quaternion, align 16
  %posA = alloca %class.b3Vector3, align 16
  %ornB = alloca %class.b3Quaternion, align 16
  %posB = alloca %class.b3Vector3, align 16
  %childPosA = alloca %class.b3Vector3, align 16
  %childOrnA = alloca %class.b3Quaternion, align 16
  %newPosA = alloca %class.b3Vector3, align 16
  %ref.tmp = alloca %class.b3Vector3, align 16
  %newOrnA = alloca %class.b3Quaternion, align 16
  %childPosB = alloca %class.b3Vector3, align 16
  %childOrnB = alloca %class.b3Quaternion, align 16
  %newPosB = alloca %class.b3Vector3, align 16
  %ref.tmp47 = alloca %class.b3Vector3, align 16
  %newOrnB = alloca %class.b3Quaternion, align 16
  %shapeIndexA = alloca i32, align 4
  %shapeIndexB = alloca i32, align 4
  %numLocalContactsOut = alloca i32, align 4
  %normal = alloca %class.b3Vector3, align 16
  %nPoints = alloca i32, align 4
  %pointsIn = alloca ptr, align 8
  %contactIdx = alloca %struct.b3Int4, align 16
  %nReducedContacts = alloca i32, align 4
  %dstIdx = alloca i32, align 4
  %c = alloca ptr, align 8
  %ref.tmp92 = alloca %class.b3Vector3, align 16
  %bodyA = alloca i32, align 4
  %bodyB = alloca i32, align 4
  %i114 = alloca i32, align 4
  store ptr %gpuCompoundPairs, ptr %gpuCompoundPairs.addr, align 8
  store ptr %rigidBodies, ptr %rigidBodies.addr, align 8
  store ptr %collidables, ptr %collidables.addr, align 8
  store ptr %convexShapes, ptr %convexShapes.addr, align 8
  store ptr %vertices, ptr %vertices.addr, align 8
  store ptr %uniqueEdges, ptr %uniqueEdges.addr, align 8
  store ptr %faces, ptr %faces.addr, align 8
  store ptr %indices, ptr %indices.addr, align 8
  store ptr %gpuChildShapes, ptr %gpuChildShapes.addr, align 8
  store ptr %gpuCompoundSepNormalsOut, ptr %gpuCompoundSepNormalsOut.addr, align 8
  store ptr %gpuHasCompoundSepNormalsOut, ptr %gpuHasCompoundSepNormalsOut.addr, align 8
  store ptr %globalContactsOut, ptr %globalContactsOut.addr, align 8
  store ptr %nGlobalContactsOut, ptr %nGlobalContactsOut.addr, align 8
  store i32 %numCompoundPairs, ptr %numCompoundPairs.addr, align 4
  store i32 %maxContactCapacity, ptr %maxContactCapacity.addr, align 4
  store i32 %i, ptr %i.addr, align 4
  %0 = load i32, ptr %i.addr, align 4
  store i32 %0, ptr %pairIndex, align 4
  store i32 64, ptr %capacityWorldVerts, align 4
  store i32 64, ptr %localContactCapacity, align 4
  store float 0xC6293E5940000000, ptr %minDist, align 4
  store float 0.000000e+00, ptr %maxDist, align 4
  %1 = load i32, ptr %i.addr, align 4
  %2 = load i32, ptr %numCompoundPairs.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %if.then, label %if.end127

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %gpuHasCompoundSepNormalsOut.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %call = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK20b3AlignedObjectArrayIiEixEi(ptr noundef nonnull align 8 dereferenceable(25) %3, i32 noundef %4)
  %5 = load i32, ptr %call, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then1, label %if.end126

if.then1:                                         ; preds = %if.then
  %6 = load ptr, ptr %gpuCompoundPairs.addr, align 8
  %7 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr inbounds %struct.b3Int4, ptr %6, i64 %idxprom
  %8 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon, ptr %8, i32 0, i32 0
  %9 = load i32, ptr %x, align 16
  store i32 %9, ptr %bodyIndexA, align 4
  %10 = load ptr, ptr %gpuCompoundPairs.addr, align 8
  %11 = load i32, ptr %i.addr, align 4
  %idxprom2 = sext i32 %11 to i64
  %arrayidx3 = getelementptr inbounds %struct.b3Int4, ptr %10, i64 %idxprom2
  %12 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx3, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon, ptr %12, i32 0, i32 1
  %13 = load i32, ptr %y, align 4
  store i32 %13, ptr %bodyIndexB, align 4
  %14 = load ptr, ptr %gpuCompoundPairs.addr, align 8
  %15 = load i32, ptr %i.addr, align 4
  %idxprom4 = sext i32 %15 to i64
  %arrayidx5 = getelementptr inbounds %struct.b3Int4, ptr %14, i64 %idxprom4
  %16 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx5, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon, ptr %16, i32 0, i32 2
  %17 = load i32, ptr %z, align 8
  store i32 %17, ptr %childShapeIndexA, align 4
  %18 = load ptr, ptr %gpuCompoundPairs.addr, align 8
  %19 = load i32, ptr %i.addr, align 4
  %idxprom6 = sext i32 %19 to i64
  %arrayidx7 = getelementptr inbounds %struct.b3Int4, ptr %18, i64 %idxprom6
  %20 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx7, i32 0, i32 0
  %w = getelementptr inbounds %struct.anon, ptr %20, i32 0, i32 3
  %21 = load i32, ptr %w, align 4
  store i32 %21, ptr %childShapeIndexB, align 4
  store i32 -1, ptr %collidableIndexA, align 4
  store i32 -1, ptr %collidableIndexB, align 4
  %22 = load ptr, ptr %rigidBodies.addr, align 8
  %23 = load i32, ptr %bodyIndexA, align 4
  %idxprom8 = sext i32 %23 to i64
  %arrayidx9 = getelementptr inbounds %struct.b3RigidBodyData, ptr %22, i64 %idxprom8
  %m_quat = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx9, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornA, ptr align 16 %m_quat, i64 16, i1 false)
  %24 = load ptr, ptr %rigidBodies.addr, align 8
  %25 = load i32, ptr %bodyIndexA, align 4
  %idxprom10 = sext i32 %25 to i64
  %arrayidx11 = getelementptr inbounds %struct.b3RigidBodyData, ptr %24, i64 %idxprom10
  %m_pos = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx11, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posA, ptr align 16 %m_pos, i64 16, i1 false)
  %26 = load ptr, ptr %rigidBodies.addr, align 8
  %27 = load i32, ptr %bodyIndexB, align 4
  %idxprom12 = sext i32 %27 to i64
  %arrayidx13 = getelementptr inbounds %struct.b3RigidBodyData, ptr %26, i64 %idxprom12
  %m_quat14 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx13, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornB, ptr align 16 %m_quat14, i64 16, i1 false)
  %28 = load ptr, ptr %rigidBodies.addr, align 8
  %29 = load i32, ptr %bodyIndexB, align 4
  %idxprom15 = sext i32 %29 to i64
  %arrayidx16 = getelementptr inbounds %struct.b3RigidBodyData, ptr %28, i64 %idxprom15
  %m_pos17 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx16, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posB, ptr align 16 %m_pos17, i64 16, i1 false)
  %30 = load i32, ptr %childShapeIndexA, align 4
  %cmp18 = icmp sge i32 %30, 0
  br i1 %cmp18, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.then1
  %31 = load ptr, ptr %gpuChildShapes.addr, align 8
  %32 = load i32, ptr %childShapeIndexA, align 4
  %idxprom20 = sext i32 %32 to i64
  %arrayidx21 = getelementptr inbounds %struct.b3GpuChildShape, ptr %31, i64 %idxprom20
  %33 = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx21, i32 0, i32 2
  %34 = load i32, ptr %33, align 16
  store i32 %34, ptr %collidableIndexA, align 4
  %35 = load ptr, ptr %gpuChildShapes.addr, align 8
  %36 = load i32, ptr %childShapeIndexA, align 4
  %idxprom22 = sext i32 %36 to i64
  %arrayidx23 = getelementptr inbounds %struct.b3GpuChildShape, ptr %35, i64 %idxprom22
  %m_childPosition = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx23, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %childPosA, ptr align 16 %m_childPosition, i64 16, i1 false)
  %37 = load ptr, ptr %gpuChildShapes.addr, align 8
  %38 = load i32, ptr %childShapeIndexA, align 4
  %idxprom24 = sext i32 %38 to i64
  %arrayidx25 = getelementptr inbounds %struct.b3GpuChildShape, ptr %37, i64 %idxprom24
  %m_childOrientation = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx25, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %childOrnA, ptr align 16 %m_childOrientation, i64 16, i1 false)
  %call26 = call { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %childPosA)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive27 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %39 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive27, i32 0, i32 0
  %40 = extractvalue { <2 x float>, <2 x float> } %call26, 0
  store <2 x float> %40, ptr %39, align 16
  %41 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive27, i32 0, i32 1
  %42 = extractvalue { <2 x float>, <2 x float> } %call26, 1
  store <2 x float> %42, ptr %41, align 8
  %call28 = call { <2 x float>, <2 x float> } @_ZplRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp, ptr noundef nonnull align 16 dereferenceable(16) %posA)
  %coerce.dive29 = getelementptr inbounds %class.b3Vector3, ptr %newPosA, i32 0, i32 0
  %coerce.dive30 = getelementptr inbounds %union.anon.1, ptr %coerce.dive29, i32 0, i32 0
  %43 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive30, i32 0, i32 0
  %44 = extractvalue { <2 x float>, <2 x float> } %call28, 0
  store <2 x float> %44, ptr %43, align 16
  %45 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive30, i32 0, i32 1
  %46 = extractvalue { <2 x float>, <2 x float> } %call28, 1
  store <2 x float> %46, ptr %45, align 8
  %call31 = call { <2 x float>, <2 x float> } @_Z9b3QuatMulRK12b3QuaternionS1_(ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %childOrnA)
  %coerce.dive32 = getelementptr inbounds %class.b3Quaternion, ptr %newOrnA, i32 0, i32 0
  %coerce.dive33 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive32, i32 0, i32 0
  %coerce.dive34 = getelementptr inbounds %union.anon.3, ptr %coerce.dive33, i32 0, i32 0
  %47 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive34, i32 0, i32 0
  %48 = extractvalue { <2 x float>, <2 x float> } %call31, 0
  store <2 x float> %48, ptr %47, align 16
  %49 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive34, i32 0, i32 1
  %50 = extractvalue { <2 x float>, <2 x float> } %call31, 1
  store <2 x float> %50, ptr %49, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posA, ptr align 16 %newPosA, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornA, ptr align 16 %newOrnA, i64 16, i1 false)
  br label %if.end

if.else:                                          ; preds = %if.then1
  %51 = load ptr, ptr %rigidBodies.addr, align 8
  %52 = load i32, ptr %bodyIndexA, align 4
  %idxprom35 = sext i32 %52 to i64
  %arrayidx36 = getelementptr inbounds %struct.b3RigidBodyData, ptr %51, i64 %idxprom35
  %m_collidableIdx = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx36, i32 0, i32 4
  %53 = load i32, ptr %m_collidableIdx, align 16
  store i32 %53, ptr %collidableIndexA, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then19
  %54 = load i32, ptr %childShapeIndexB, align 4
  %cmp37 = icmp sge i32 %54, 0
  br i1 %cmp37, label %if.then38, label %if.else58

if.then38:                                        ; preds = %if.end
  %55 = load ptr, ptr %gpuChildShapes.addr, align 8
  %56 = load i32, ptr %childShapeIndexB, align 4
  %idxprom39 = sext i32 %56 to i64
  %arrayidx40 = getelementptr inbounds %struct.b3GpuChildShape, ptr %55, i64 %idxprom39
  %57 = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx40, i32 0, i32 2
  %58 = load i32, ptr %57, align 16
  store i32 %58, ptr %collidableIndexB, align 4
  %59 = load ptr, ptr %gpuChildShapes.addr, align 8
  %60 = load i32, ptr %childShapeIndexB, align 4
  %idxprom41 = sext i32 %60 to i64
  %arrayidx42 = getelementptr inbounds %struct.b3GpuChildShape, ptr %59, i64 %idxprom41
  %m_childPosition43 = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx42, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %childPosB, ptr align 16 %m_childPosition43, i64 16, i1 false)
  %61 = load ptr, ptr %gpuChildShapes.addr, align 8
  %62 = load i32, ptr %childShapeIndexB, align 4
  %idxprom44 = sext i32 %62 to i64
  %arrayidx45 = getelementptr inbounds %struct.b3GpuChildShape, ptr %61, i64 %idxprom44
  %m_childOrientation46 = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx45, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %childOrnB, ptr align 16 %m_childOrientation46, i64 16, i1 false)
  %call48 = call { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %childPosB)
  %coerce.dive49 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp47, i32 0, i32 0
  %coerce.dive50 = getelementptr inbounds %union.anon.1, ptr %coerce.dive49, i32 0, i32 0
  %63 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive50, i32 0, i32 0
  %64 = extractvalue { <2 x float>, <2 x float> } %call48, 0
  store <2 x float> %64, ptr %63, align 16
  %65 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive50, i32 0, i32 1
  %66 = extractvalue { <2 x float>, <2 x float> } %call48, 1
  store <2 x float> %66, ptr %65, align 8
  %call51 = call { <2 x float>, <2 x float> } @_ZplRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp47, ptr noundef nonnull align 16 dereferenceable(16) %posB)
  %coerce.dive52 = getelementptr inbounds %class.b3Vector3, ptr %newPosB, i32 0, i32 0
  %coerce.dive53 = getelementptr inbounds %union.anon.1, ptr %coerce.dive52, i32 0, i32 0
  %67 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive53, i32 0, i32 0
  %68 = extractvalue { <2 x float>, <2 x float> } %call51, 0
  store <2 x float> %68, ptr %67, align 16
  %69 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive53, i32 0, i32 1
  %70 = extractvalue { <2 x float>, <2 x float> } %call51, 1
  store <2 x float> %70, ptr %69, align 8
  %call54 = call { <2 x float>, <2 x float> } @_Z9b3QuatMulRK12b3QuaternionS1_(ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %childOrnB)
  %coerce.dive55 = getelementptr inbounds %class.b3Quaternion, ptr %newOrnB, i32 0, i32 0
  %coerce.dive56 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive55, i32 0, i32 0
  %coerce.dive57 = getelementptr inbounds %union.anon.3, ptr %coerce.dive56, i32 0, i32 0
  %71 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive57, i32 0, i32 0
  %72 = extractvalue { <2 x float>, <2 x float> } %call54, 0
  store <2 x float> %72, ptr %71, align 16
  %73 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive57, i32 0, i32 1
  %74 = extractvalue { <2 x float>, <2 x float> } %call54, 1
  store <2 x float> %74, ptr %73, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posB, ptr align 16 %newPosB, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornB, ptr align 16 %newOrnB, i64 16, i1 false)
  br label %if.end62

if.else58:                                        ; preds = %if.end
  %75 = load ptr, ptr %rigidBodies.addr, align 8
  %76 = load i32, ptr %bodyIndexB, align 4
  %idxprom59 = sext i32 %76 to i64
  %arrayidx60 = getelementptr inbounds %struct.b3RigidBodyData, ptr %75, i64 %idxprom59
  %m_collidableIdx61 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx60, i32 0, i32 4
  %77 = load i32, ptr %m_collidableIdx61, align 16
  store i32 %77, ptr %collidableIndexB, align 4
  br label %if.end62

if.end62:                                         ; preds = %if.else58, %if.then38
  %78 = load ptr, ptr %collidables.addr, align 8
  %79 = load i32, ptr %collidableIndexA, align 4
  %idxprom63 = sext i32 %79 to i64
  %arrayidx64 = getelementptr inbounds %struct.b3Collidable, ptr %78, i64 %idxprom63
  %80 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx64, i32 0, i32 3
  %81 = load i32, ptr %80, align 4
  store i32 %81, ptr %shapeIndexA, align 4
  %82 = load ptr, ptr %collidables.addr, align 8
  %83 = load i32, ptr %collidableIndexB, align 4
  %idxprom65 = sext i32 %83 to i64
  %arrayidx66 = getelementptr inbounds %struct.b3Collidable, ptr %82, i64 %idxprom65
  %84 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx66, i32 0, i32 3
  %85 = load i32, ptr %84, align 4
  store i32 %85, ptr %shapeIndexB, align 4
  %86 = load ptr, ptr %gpuCompoundSepNormalsOut.addr, align 8
  %87 = load i32, ptr %i.addr, align 4
  %call67 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK20b3AlignedObjectArrayI9b3Vector3EixEi(ptr noundef nonnull align 8 dereferenceable(25) %86, i32 noundef %87)
  %88 = load ptr, ptr %convexShapes.addr, align 8
  %89 = load i32, ptr %shapeIndexA, align 4
  %idxprom68 = sext i32 %89 to i64
  %arrayidx69 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %88, i64 %idxprom68
  %90 = load ptr, ptr %convexShapes.addr, align 8
  %91 = load i32, ptr %shapeIndexB, align 4
  %idxprom70 = sext i32 %91 to i64
  %arrayidx71 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %90, i64 %idxprom70
  %arraydecay = getelementptr inbounds [64 x %class.b3Vector3], ptr %worldVertsB1, i64 0, i64 0
  %arraydecay72 = getelementptr inbounds [64 x %class.b3Vector3], ptr %worldVertsB2, i64 0, i64 0
  %92 = load i32, ptr %capacityWorldVerts, align 4
  %93 = load float, ptr %minDist, align 4
  %94 = load float, ptr %maxDist, align 4
  %95 = load ptr, ptr %vertices.addr, align 8
  %96 = load ptr, ptr %faces.addr, align 8
  %97 = load ptr, ptr %indices.addr, align 8
  %98 = load ptr, ptr %vertices.addr, align 8
  %99 = load ptr, ptr %faces.addr, align 8
  %100 = load ptr, ptr %indices.addr, align 8
  %arraydecay73 = getelementptr inbounds [64 x %class.b3Vector3], ptr %localContactsOut, i64 0, i64 0
  %101 = load i32, ptr %localContactCapacity, align 4
  %call74 = call noundef i32 @_ZL19clipHullAgainstHullRK9b3Vector3RK22b3ConvexPolyhedronDataS4_S1_RK12b3QuaternionS1_S7_PS_S8_iffRK20b3AlignedObjectArrayIS_ERKS9_I9b3GpuFaceERKS9_IiESC_SG_SJ_S8_i(ptr noundef nonnull align 16 dereferenceable(16) %call67, ptr noundef nonnull align 16 dereferenceable(96) %arrayidx69, ptr noundef nonnull align 16 dereferenceable(96) %arrayidx71, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef %arraydecay, ptr noundef %arraydecay72, i32 noundef %92, float noundef %93, float noundef %94, ptr noundef nonnull align 8 dereferenceable(25) %95, ptr noundef nonnull align 8 dereferenceable(25) %96, ptr noundef nonnull align 8 dereferenceable(25) %97, ptr noundef nonnull align 8 dereferenceable(25) %98, ptr noundef nonnull align 8 dereferenceable(25) %99, ptr noundef nonnull align 8 dereferenceable(25) %100, ptr noundef %arraydecay73, i32 noundef %101)
  store i32 %call74, ptr %numLocalContactsOut, align 4
  %102 = load i32, ptr %numLocalContactsOut, align 4
  %cmp75 = icmp sgt i32 %102, 0
  br i1 %cmp75, label %if.then76, label %if.end125

if.then76:                                        ; preds = %if.end62
  %103 = load ptr, ptr %gpuCompoundSepNormalsOut.addr, align 8
  %104 = load i32, ptr %i.addr, align 4
  %call77 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK20b3AlignedObjectArrayI9b3Vector3EixEi(ptr noundef nonnull align 8 dereferenceable(25) %103, i32 noundef %104)
  %call78 = call { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %call77)
  %coerce.dive79 = getelementptr inbounds %class.b3Vector3, ptr %normal, i32 0, i32 0
  %coerce.dive80 = getelementptr inbounds %union.anon.1, ptr %coerce.dive79, i32 0, i32 0
  %105 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive80, i32 0, i32 0
  %106 = extractvalue { <2 x float>, <2 x float> } %call78, 0
  store <2 x float> %106, ptr %105, align 16
  %107 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive80, i32 0, i32 1
  %108 = extractvalue { <2 x float>, <2 x float> } %call78, 1
  store <2 x float> %108, ptr %107, align 8
  %109 = load i32, ptr %numLocalContactsOut, align 4
  store i32 %109, ptr %nPoints, align 4
  %arraydecay81 = getelementptr inbounds [64 x %class.b3Vector3], ptr %localContactsOut, i64 0, i64 0
  store ptr %arraydecay81, ptr %pointsIn, align 8
  %110 = getelementptr inbounds %struct.b3Int4, ptr %contactIdx, i32 0, i32 0
  %s = getelementptr inbounds %struct.anon.0, ptr %110, i32 0, i32 0
  %arrayidx82 = getelementptr inbounds [4 x i32], ptr %s, i64 0, i64 0
  store i32 0, ptr %arrayidx82, align 16
  %111 = getelementptr inbounds %struct.b3Int4, ptr %contactIdx, i32 0, i32 0
  %s83 = getelementptr inbounds %struct.anon.0, ptr %111, i32 0, i32 0
  %arrayidx84 = getelementptr inbounds [4 x i32], ptr %s83, i64 0, i64 1
  store i32 1, ptr %arrayidx84, align 4
  %112 = getelementptr inbounds %struct.b3Int4, ptr %contactIdx, i32 0, i32 0
  %s85 = getelementptr inbounds %struct.anon.0, ptr %112, i32 0, i32 0
  %arrayidx86 = getelementptr inbounds [4 x i32], ptr %s85, i64 0, i64 2
  store i32 2, ptr %arrayidx86, align 8
  %113 = getelementptr inbounds %struct.b3Int4, ptr %contactIdx, i32 0, i32 0
  %s87 = getelementptr inbounds %struct.anon.0, ptr %113, i32 0, i32 0
  %arrayidx88 = getelementptr inbounds [4 x i32], ptr %s87, i64 0, i64 3
  store i32 3, ptr %arrayidx88, align 4
  %114 = load ptr, ptr %pointsIn, align 8
  %115 = load i32, ptr %nPoints, align 4
  %call89 = call noundef i32 @_Z31extractManifoldSequentialGlobalPK9b3Vector3iRS0_P6b3Int4(ptr noundef %114, i32 noundef %115, ptr noundef nonnull align 16 dereferenceable(16) %normal, ptr noundef %contactIdx)
  store i32 %call89, ptr %nReducedContacts, align 4
  %116 = load ptr, ptr %nGlobalContactsOut.addr, align 8
  %117 = load i32, ptr %116, align 4
  %inc = add nsw i32 %117, 1
  store i32 %inc, ptr %116, align 4
  store i32 %117, ptr %dstIdx, align 4
  %118 = load i32, ptr %dstIdx, align 4
  %119 = load i32, ptr %nReducedContacts, align 4
  %add = add nsw i32 %118, %119
  %120 = load i32, ptr %maxContactCapacity.addr, align 4
  %cmp90 = icmp slt i32 %add, %120
  br i1 %cmp90, label %if.then91, label %if.end124

if.then91:                                        ; preds = %if.then76
  %121 = load ptr, ptr %globalContactsOut.addr, align 8
  %122 = load i32, ptr %dstIdx, align 4
  %idx.ext = sext i32 %122 to i64
  %add.ptr = getelementptr inbounds %struct.b3Contact4Data, ptr %121, i64 %idx.ext
  store ptr %add.ptr, ptr %c, align 8
  %call93 = call { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %normal)
  %coerce.dive94 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp92, i32 0, i32 0
  %coerce.dive95 = getelementptr inbounds %union.anon.1, ptr %coerce.dive94, i32 0, i32 0
  %123 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive95, i32 0, i32 0
  %124 = extractvalue { <2 x float>, <2 x float> } %call93, 0
  store <2 x float> %124, ptr %123, align 16
  %125 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive95, i32 0, i32 1
  %126 = extractvalue { <2 x float>, <2 x float> } %call93, 1
  store <2 x float> %126, ptr %125, align 8
  %127 = load ptr, ptr %c, align 8
  %m_worldNormalOnB = getelementptr inbounds %struct.b3Contact4Data, ptr %127, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %m_worldNormalOnB, ptr align 16 %ref.tmp92, i64 16, i1 false)
  %128 = load ptr, ptr %c, align 8
  %m_restituitionCoeffCmp = getelementptr inbounds %struct.b3Contact4Data, ptr %128, i32 0, i32 2
  store i16 0, ptr %m_restituitionCoeffCmp, align 16
  %129 = load ptr, ptr %c, align 8
  %m_frictionCoeffCmp = getelementptr inbounds %struct.b3Contact4Data, ptr %129, i32 0, i32 3
  store i16 -19662, ptr %m_frictionCoeffCmp, align 2
  %130 = load i32, ptr %pairIndex, align 4
  %131 = load ptr, ptr %c, align 8
  %m_batchIdx = getelementptr inbounds %struct.b3Contact4Data, ptr %131, i32 0, i32 4
  store i32 %130, ptr %m_batchIdx, align 4
  %132 = load ptr, ptr %gpuCompoundPairs.addr, align 8
  %133 = load i32, ptr %pairIndex, align 4
  %idxprom96 = sext i32 %133 to i64
  %arrayidx97 = getelementptr inbounds %struct.b3Int4, ptr %132, i64 %idxprom96
  %134 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx97, i32 0, i32 0
  %x98 = getelementptr inbounds %struct.anon, ptr %134, i32 0, i32 0
  %135 = load i32, ptr %x98, align 16
  store i32 %135, ptr %bodyA, align 4
  %136 = load ptr, ptr %gpuCompoundPairs.addr, align 8
  %137 = load i32, ptr %pairIndex, align 4
  %idxprom99 = sext i32 %137 to i64
  %arrayidx100 = getelementptr inbounds %struct.b3Int4, ptr %136, i64 %idxprom99
  %138 = getelementptr inbounds %struct.b3Int4, ptr %arrayidx100, i32 0, i32 0
  %y101 = getelementptr inbounds %struct.anon, ptr %138, i32 0, i32 1
  %139 = load i32, ptr %y101, align 4
  store i32 %139, ptr %bodyB, align 4
  %140 = load ptr, ptr %rigidBodies.addr, align 8
  %141 = load i32, ptr %bodyA, align 4
  %idxprom102 = sext i32 %141 to i64
  %arrayidx103 = getelementptr inbounds %struct.b3RigidBodyData, ptr %140, i64 %idxprom102
  %m_invMass = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx103, i32 0, i32 5
  %142 = load float, ptr %m_invMass, align 4
  %cmp104 = fcmp oeq float %142, 0.000000e+00
  br i1 %cmp104, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then91
  %143 = load i32, ptr %bodyA, align 4
  %sub = sub nsw i32 0, %143
  br label %cond.end

cond.false:                                       ; preds = %if.then91
  %144 = load i32, ptr %bodyA, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %sub, %cond.true ], [ %144, %cond.false ]
  %145 = load ptr, ptr %c, align 8
  %m_bodyAPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %145, i32 0, i32 5
  store i32 %cond, ptr %m_bodyAPtrAndSignBit, align 8
  %146 = load ptr, ptr %rigidBodies.addr, align 8
  %147 = load i32, ptr %bodyB, align 4
  %idxprom105 = sext i32 %147 to i64
  %arrayidx106 = getelementptr inbounds %struct.b3RigidBodyData, ptr %146, i64 %idxprom105
  %m_invMass107 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx106, i32 0, i32 5
  %148 = load float, ptr %m_invMass107, align 4
  %cmp108 = fcmp oeq float %148, 0.000000e+00
  br i1 %cmp108, label %cond.true109, label %cond.false111

cond.true109:                                     ; preds = %cond.end
  %149 = load i32, ptr %bodyB, align 4
  %sub110 = sub nsw i32 0, %149
  br label %cond.end112

cond.false111:                                    ; preds = %cond.end
  %150 = load i32, ptr %bodyB, align 4
  br label %cond.end112

cond.end112:                                      ; preds = %cond.false111, %cond.true109
  %cond113 = phi i32 [ %sub110, %cond.true109 ], [ %150, %cond.false111 ]
  %151 = load ptr, ptr %c, align 8
  %m_bodyBPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %151, i32 0, i32 6
  store i32 %cond113, ptr %m_bodyBPtrAndSignBit, align 4
  %152 = load i32, ptr %childShapeIndexA, align 4
  %153 = load ptr, ptr %c, align 8
  %m_childIndexA = getelementptr inbounds %struct.b3Contact4Data, ptr %153, i32 0, i32 7
  store i32 %152, ptr %m_childIndexA, align 16
  %154 = load i32, ptr %childShapeIndexB, align 4
  %155 = load ptr, ptr %c, align 8
  %m_childIndexB = getelementptr inbounds %struct.b3Contact4Data, ptr %155, i32 0, i32 8
  store i32 %154, ptr %m_childIndexB, align 4
  store i32 0, ptr %i114, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end112
  %156 = load i32, ptr %i114, align 4
  %157 = load i32, ptr %nReducedContacts, align 4
  %cmp115 = icmp slt i32 %156, %157
  br i1 %cmp115, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %158 = load ptr, ptr %pointsIn, align 8
  %159 = getelementptr inbounds %struct.b3Int4, ptr %contactIdx, i32 0, i32 0
  %s116 = getelementptr inbounds %struct.anon.0, ptr %159, i32 0, i32 0
  %160 = load i32, ptr %i114, align 4
  %idxprom117 = sext i32 %160 to i64
  %arrayidx118 = getelementptr inbounds [4 x i32], ptr %s116, i64 0, i64 %idxprom117
  %161 = load i32, ptr %arrayidx118, align 4
  %idxprom119 = sext i32 %161 to i64
  %arrayidx120 = getelementptr inbounds %class.b3Vector3, ptr %158, i64 %idxprom119
  %162 = load ptr, ptr %c, align 8
  %m_worldPosB = getelementptr inbounds %struct.b3Contact4Data, ptr %162, i32 0, i32 0
  %163 = load i32, ptr %i114, align 4
  %idxprom121 = sext i32 %163 to i64
  %arrayidx122 = getelementptr inbounds [4 x %class.b3Vector3], ptr %m_worldPosB, i64 0, i64 %idxprom121
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx122, ptr align 16 %arrayidx120, i64 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %164 = load i32, ptr %i114, align 4
  %inc123 = add nsw i32 %164, 1
  store i32 %inc123, ptr %i114, align 4
  br label %for.cond, !llvm.loop !54

for.end:                                          ; preds = %for.cond
  %165 = load ptr, ptr %c, align 8
  %166 = load i32, ptr %nReducedContacts, align 4
  call void @_Z27b3Contact4Data_setNumPointsP14b3Contact4Datai(ptr noundef %165, i32 noundef %166)
  br label %if.end124

if.end124:                                        ; preds = %for.end, %if.then76
  br label %if.end125

if.end125:                                        ; preds = %if.end124, %if.end62
  br label %if.end126

if.end126:                                        ; preds = %if.end125, %if.then
  br label %if.end127

if.end127:                                        ; preds = %if.end126, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_Z27b3Contact4Data_setNumPointsP14b3Contact4Datai(ptr noundef %contact, i32 noundef %numPoints) #3 comdat {
entry:
  %contact.addr = alloca ptr, align 8
  %numPoints.addr = alloca i32, align 4
  store ptr %contact, ptr %contact.addr, align 8
  store i32 %numPoints, ptr %numPoints.addr, align 4
  %0 = load i32, ptr %numPoints.addr, align 4
  %conv = sitofp i32 %0 to float
  %1 = load ptr, ptr %contact.addr, align 8
  %m_worldNormalOnB = getelementptr inbounds %struct.b3Contact4Data, ptr %1, i32 0, i32 1
  %2 = getelementptr inbounds %class.b3Vector3, ptr %m_worldNormalOnB, i32 0, i32 0
  %w = getelementptr inbounds %struct.anon.2, ptr %2, i32 0, i32 3
  store float %conv, ptr %w, align 4
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local void @_Z30computeContactCompoundCompoundiiiiiPK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataPK15b3GpuChildShapeRK20b3AlignedObjectArrayI6b3AabbESF_RKSB_I9b3Vector3ESJ_RKSB_IiERKSB_I9b3GpuFaceEP10b3Contact4RiiRSB_I18b3QuantizedBvhNodeERSB_I16b3BvhSubtreeInfoERSB_I9b3BvhInfoE(i32 noundef %pairIndex, i32 noundef %bodyIndexA, i32 noundef %bodyIndexB, i32 noundef %collidableIndexA, i32 noundef %collidableIndexB, ptr noundef %rigidBodies, ptr noundef %collidables, ptr noundef %convexShapes, ptr noundef %cpuChildShapes, ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsWorldSpace, ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsLocalSpace, ptr noundef nonnull align 8 dereferenceable(25) %convexVertices, ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges, ptr noundef nonnull align 8 dereferenceable(25) %convexIndices, ptr noundef nonnull align 8 dereferenceable(25) %faces, ptr noundef %globalContactsOut, ptr noundef nonnull align 4 dereferenceable(4) %nGlobalContactsOut, i32 noundef %maxContactCapacity, ptr noundef nonnull align 8 dereferenceable(25) %treeNodesCPU, ptr noundef nonnull align 8 dereferenceable(25) %subTreesCPU, ptr noundef nonnull align 8 dereferenceable(25) %bvhInfoCPU) #0 personality ptr @__gxx_personality_v0 {
entry:
  %pairIndex.addr = alloca i32, align 4
  %bodyIndexA.addr = alloca i32, align 4
  %bodyIndexB.addr = alloca i32, align 4
  %collidableIndexA.addr = alloca i32, align 4
  %collidableIndexB.addr = alloca i32, align 4
  %rigidBodies.addr = alloca ptr, align 8
  %collidables.addr = alloca ptr, align 8
  %convexShapes.addr = alloca ptr, align 8
  %cpuChildShapes.addr = alloca ptr, align 8
  %hostAabbsWorldSpace.addr = alloca ptr, align 8
  %hostAabbsLocalSpace.addr = alloca ptr, align 8
  %convexVertices.addr = alloca ptr, align 8
  %hostUniqueEdges.addr = alloca ptr, align 8
  %convexIndices.addr = alloca ptr, align 8
  %faces.addr = alloca ptr, align 8
  %globalContactsOut.addr = alloca ptr, align 8
  %nGlobalContactsOut.addr = alloca ptr, align 8
  %maxContactCapacity.addr = alloca i32, align 4
  %treeNodesCPU.addr = alloca ptr, align 8
  %subTreesCPU.addr = alloca ptr, align 8
  %bvhInfoCPU.addr = alloca ptr, align 8
  %shapeTypeB = alloca i32, align 4
  %cpuCompoundPairsOut = alloca %class.b3AlignedObjectArray.66, align 8
  %numCompoundPairsOut = alloca i32, align 4
  %maxNumCompoundPairsCapacity = alloca i32, align 4
  %ref.tmp = alloca %struct.b3Int4, align 16
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %cpuCompoundSepNormalsOut = alloca %class.b3AlignedObjectArray, align 8
  %cpuHasCompoundSepNormalsOut = alloca %class.b3AlignedObjectArray.23, align 8
  %ref.tmp10 = alloca %class.b3Vector3, align 16
  %ref.tmp13 = alloca i32, align 4
  %i = alloca i32, align 4
  %i19 = alloca i32, align 4
  store i32 %pairIndex, ptr %pairIndex.addr, align 4
  store i32 %bodyIndexA, ptr %bodyIndexA.addr, align 4
  store i32 %bodyIndexB, ptr %bodyIndexB.addr, align 4
  store i32 %collidableIndexA, ptr %collidableIndexA.addr, align 4
  store i32 %collidableIndexB, ptr %collidableIndexB.addr, align 4
  store ptr %rigidBodies, ptr %rigidBodies.addr, align 8
  store ptr %collidables, ptr %collidables.addr, align 8
  store ptr %convexShapes, ptr %convexShapes.addr, align 8
  store ptr %cpuChildShapes, ptr %cpuChildShapes.addr, align 8
  store ptr %hostAabbsWorldSpace, ptr %hostAabbsWorldSpace.addr, align 8
  store ptr %hostAabbsLocalSpace, ptr %hostAabbsLocalSpace.addr, align 8
  store ptr %convexVertices, ptr %convexVertices.addr, align 8
  store ptr %hostUniqueEdges, ptr %hostUniqueEdges.addr, align 8
  store ptr %convexIndices, ptr %convexIndices.addr, align 8
  store ptr %faces, ptr %faces.addr, align 8
  store ptr %globalContactsOut, ptr %globalContactsOut.addr, align 8
  store ptr %nGlobalContactsOut, ptr %nGlobalContactsOut.addr, align 8
  store i32 %maxContactCapacity, ptr %maxContactCapacity.addr, align 4
  store ptr %treeNodesCPU, ptr %treeNodesCPU.addr, align 8
  store ptr %subTreesCPU, ptr %subTreesCPU.addr, align 8
  store ptr %bvhInfoCPU, ptr %bvhInfoCPU.addr, align 8
  %0 = load ptr, ptr %collidables.addr, align 8
  %1 = load i32, ptr %collidableIndexB.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3Collidable, ptr %0, i64 %idxprom
  %m_shapeType = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx, i32 0, i32 2
  %2 = load i32, ptr %m_shapeType, align 4
  store i32 %2, ptr %shapeTypeB, align 4
  call void @_ZN20b3AlignedObjectArrayI6b3Int4EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuCompoundPairsOut)
  store i32 0, ptr %numCompoundPairsOut, align 4
  store i32 8192, ptr %maxNumCompoundPairsCapacity, align 4
  %3 = load i32, ptr %maxNumCompoundPairsCapacity, align 4
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp, i8 0, i64 16, i1 false)
  invoke void @_ZN20b3AlignedObjectArrayI6b3Int4E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %cpuCompoundPairsOut, i32 noundef %3, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  %4 = load i32, ptr %pairIndex.addr, align 4
  %5 = load i32, ptr %bodyIndexA.addr, align 4
  %6 = load i32, ptr %bodyIndexB.addr, align 4
  %7 = load i32, ptr %collidableIndexA.addr, align 4
  %8 = load i32, ptr %collidableIndexB.addr, align 4
  %9 = load ptr, ptr %rigidBodies.addr, align 8
  %10 = load ptr, ptr %collidables.addr, align 8
  %11 = load ptr, ptr %convexShapes.addr, align 8
  %12 = load ptr, ptr %convexVertices.addr, align 8
  %13 = load ptr, ptr %hostAabbsWorldSpace.addr, align 8
  %14 = load ptr, ptr %hostAabbsLocalSpace.addr, align 8
  %15 = load ptr, ptr %cpuChildShapes.addr, align 8
  %call = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI6b3Int4EixEi(ptr noundef nonnull align 8 dereferenceable(25) %cpuCompoundPairsOut, i32 noundef 0)
          to label %invoke.cont1 unwind label %lpad

invoke.cont1:                                     ; preds = %invoke.cont
  %16 = load i32, ptr %maxNumCompoundPairsCapacity, align 4
  %17 = load ptr, ptr %treeNodesCPU.addr, align 8
  %18 = load ptr, ptr %subTreesCPU.addr, align 8
  %19 = load ptr, ptr %bvhInfoCPU.addr, align 8
  invoke void @_Z23findCompoundPairsKerneliiiiiPK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataRK20b3AlignedObjectArrayI9b3Vector3ERKS8_I6b3AabbESG_PK15b3GpuChildShapeP6b3Int4PiiRS8_I18b3QuantizedBvhNodeERS8_I16b3BvhSubtreeInfoERS8_I9b3BvhInfoE(i32 noundef %4, i32 noundef %5, i32 noundef %6, i32 noundef %7, i32 noundef %8, ptr noundef %9, ptr noundef %10, ptr noundef %11, ptr noundef nonnull align 8 dereferenceable(25) %12, ptr noundef nonnull align 8 dereferenceable(25) %13, ptr noundef nonnull align 8 dereferenceable(25) %14, ptr noundef %15, ptr noundef %call, ptr noundef %numCompoundPairsOut, i32 noundef %16, ptr noundef nonnull align 8 dereferenceable(25) %17, ptr noundef nonnull align 8 dereferenceable(25) %18, ptr noundef nonnull align 8 dereferenceable(25) %19)
          to label %invoke.cont2 unwind label %lpad

invoke.cont2:                                     ; preds = %invoke.cont1
  %20 = load i32, ptr @maxNumAabbChecks, align 4
  %call4 = invoke i32 (ptr, ...) @printf(ptr noundef @.str.37, i32 noundef %20)
          to label %invoke.cont3 unwind label %lpad

invoke.cont3:                                     ; preds = %invoke.cont2
  %21 = load i32, ptr %numCompoundPairsOut, align 4
  %22 = load i32, ptr %maxNumCompoundPairsCapacity, align 4
  %cmp = icmp sgt i32 %21, %22
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %invoke.cont3
  br label %do.body

do.body:                                          ; preds = %if.then
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.31, i32 noundef 2077)
          to label %invoke.cont5 unwind label %lpad

invoke.cont5:                                     ; preds = %do.body
  %23 = load i32, ptr %maxNumCompoundPairsCapacity, align 4
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.38, i32 noundef %23)
          to label %invoke.cont6 unwind label %lpad

invoke.cont6:                                     ; preds = %invoke.cont5
  br label %do.cond

do.cond:                                          ; preds = %invoke.cont6
  br label %do.end

do.end:                                           ; preds = %do.cond
  %24 = load i32, ptr %maxNumCompoundPairsCapacity, align 4
  store i32 %24, ptr %numCompoundPairsOut, align 4
  br label %if.end

lpad:                                             ; preds = %if.end, %invoke.cont5, %do.body, %invoke.cont2, %invoke.cont1, %invoke.cont, %entry
  %25 = landingpad { ptr, i32 }
          cleanup
  %26 = extractvalue { ptr, i32 } %25, 0
  store ptr %26, ptr %exn.slot, align 8
  %27 = extractvalue { ptr, i32 } %25, 1
  store i32 %27, ptr %ehselector.slot, align 4
  br label %ehcleanup29

if.end:                                           ; preds = %do.end, %invoke.cont3
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuCompoundSepNormalsOut)
          to label %invoke.cont7 unwind label %lpad

invoke.cont7:                                     ; preds = %if.end
  invoke void @_ZN20b3AlignedObjectArrayIiEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuHasCompoundSepNormalsOut)
          to label %invoke.cont9 unwind label %lpad8

invoke.cont9:                                     ; preds = %invoke.cont7
  %28 = load i32, ptr %numCompoundPairsOut, align 4
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp10, i8 0, i64 16, i1 false)
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %cpuCompoundSepNormalsOut, i32 noundef %28, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp10)
          to label %invoke.cont12 unwind label %lpad11

invoke.cont12:                                    ; preds = %invoke.cont9
  %29 = load i32, ptr %numCompoundPairsOut, align 4
  store i32 0, ptr %ref.tmp13, align 4
  invoke void @_ZN20b3AlignedObjectArrayIiE6resizeEiRKi(ptr noundef nonnull align 8 dereferenceable(25) %cpuHasCompoundSepNormalsOut, i32 noundef %29, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp13)
          to label %invoke.cont14 unwind label %lpad11

invoke.cont14:                                    ; preds = %invoke.cont12
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %invoke.cont14
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %numCompoundPairsOut, align 4
  %cmp15 = icmp slt i32 %30, %31
  br i1 %cmp15, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call17 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI6b3Int4EixEi(ptr noundef nonnull align 8 dereferenceable(25) %cpuCompoundPairsOut, i32 noundef 0)
          to label %invoke.cont16 unwind label %lpad11

invoke.cont16:                                    ; preds = %for.body
  %32 = load ptr, ptr %rigidBodies.addr, align 8
  %33 = load ptr, ptr %collidables.addr, align 8
  %34 = load ptr, ptr %convexShapes.addr, align 8
  %35 = load ptr, ptr %convexVertices.addr, align 8
  %36 = load ptr, ptr %hostUniqueEdges.addr, align 8
  %37 = load ptr, ptr %faces.addr, align 8
  %38 = load ptr, ptr %convexIndices.addr, align 8
  %39 = load ptr, ptr %cpuChildShapes.addr, align 8
  %40 = load i32, ptr %numCompoundPairsOut, align 4
  %41 = load i32, ptr %i, align 4
  invoke void @_Z26processCompoundPairsKernelPK6b3Int4PK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataRK20b3AlignedObjectArrayI9b3Vector3ESF_RKSB_I9b3GpuFaceERKSB_IiEP6b3AabbPK15b3GpuChildShapeRSD_RSK_ii(ptr noundef %call17, ptr noundef %32, ptr noundef %33, ptr noundef %34, ptr noundef nonnull align 8 dereferenceable(25) %35, ptr noundef nonnull align 8 dereferenceable(25) %36, ptr noundef nonnull align 8 dereferenceable(25) %37, ptr noundef nonnull align 8 dereferenceable(25) %38, ptr noundef null, ptr noundef %39, ptr noundef nonnull align 8 dereferenceable(25) %cpuCompoundSepNormalsOut, ptr noundef nonnull align 8 dereferenceable(25) %cpuHasCompoundSepNormalsOut, i32 noundef %40, i32 noundef %41)
          to label %invoke.cont18 unwind label %lpad11

invoke.cont18:                                    ; preds = %invoke.cont16
  br label %for.inc

for.inc:                                          ; preds = %invoke.cont18
  %42 = load i32, ptr %i, align 4
  %inc = add nsw i32 %42, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !55

lpad8:                                            ; preds = %invoke.cont7
  %43 = landingpad { ptr, i32 }
          cleanup
  %44 = extractvalue { ptr, i32 } %43, 0
  store ptr %44, ptr %exn.slot, align 8
  %45 = extractvalue { ptr, i32 } %43, 1
  store i32 %45, ptr %ehselector.slot, align 4
  br label %ehcleanup

lpad11:                                           ; preds = %invoke.cont23, %for.body22, %invoke.cont16, %for.body, %invoke.cont12, %invoke.cont9
  %46 = landingpad { ptr, i32 }
          cleanup
  %47 = extractvalue { ptr, i32 } %46, 0
  store ptr %47, ptr %exn.slot, align 8
  %48 = extractvalue { ptr, i32 } %46, 1
  store i32 %48, ptr %ehselector.slot, align 4
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuHasCompoundSepNormalsOut) #13
  br label %ehcleanup

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %i19, align 4
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc26, %for.end
  %49 = load i32, ptr %i19, align 4
  %50 = load i32, ptr %numCompoundPairsOut, align 4
  %cmp21 = icmp slt i32 %49, %50
  br i1 %cmp21, label %for.body22, label %for.end28

for.body22:                                       ; preds = %for.cond20
  %call24 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI6b3Int4EixEi(ptr noundef nonnull align 8 dereferenceable(25) %cpuCompoundPairsOut, i32 noundef 0)
          to label %invoke.cont23 unwind label %lpad11

invoke.cont23:                                    ; preds = %for.body22
  %51 = load ptr, ptr %rigidBodies.addr, align 8
  %52 = load ptr, ptr %collidables.addr, align 8
  %53 = load ptr, ptr %convexShapes.addr, align 8
  %54 = load ptr, ptr %convexVertices.addr, align 8
  %55 = load ptr, ptr %hostUniqueEdges.addr, align 8
  %56 = load ptr, ptr %faces.addr, align 8
  %57 = load ptr, ptr %convexIndices.addr, align 8
  %58 = load ptr, ptr %cpuChildShapes.addr, align 8
  %59 = load ptr, ptr %globalContactsOut.addr, align 8
  %60 = load ptr, ptr %nGlobalContactsOut.addr, align 8
  %61 = load i32, ptr %numCompoundPairsOut, align 4
  %62 = load i32, ptr %maxContactCapacity.addr, align 4
  %63 = load i32, ptr %i19, align 4
  invoke void @_Z27clipCompoundsHullHullKernelPK6b3Int4PK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataRK20b3AlignedObjectArrayI9b3Vector3ESF_RKSB_I9b3GpuFaceERKSB_IiEPK15b3GpuChildShapeSF_SM_P14b3Contact4DataPiiii(ptr noundef %call24, ptr noundef %51, ptr noundef %52, ptr noundef %53, ptr noundef nonnull align 8 dereferenceable(25) %54, ptr noundef nonnull align 8 dereferenceable(25) %55, ptr noundef nonnull align 8 dereferenceable(25) %56, ptr noundef nonnull align 8 dereferenceable(25) %57, ptr noundef %58, ptr noundef nonnull align 8 dereferenceable(25) %cpuCompoundSepNormalsOut, ptr noundef nonnull align 8 dereferenceable(25) %cpuHasCompoundSepNormalsOut, ptr noundef %59, ptr noundef %60, i32 noundef %61, i32 noundef %62, i32 noundef %63)
          to label %invoke.cont25 unwind label %lpad11

invoke.cont25:                                    ; preds = %invoke.cont23
  br label %for.inc26

for.inc26:                                        ; preds = %invoke.cont25
  %64 = load i32, ptr %i19, align 4
  %inc27 = add nsw i32 %64, 1
  store i32 %inc27, ptr %i19, align 4
  br label %for.cond20, !llvm.loop !56

for.end28:                                        ; preds = %for.cond20
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuHasCompoundSepNormalsOut) #13
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuCompoundSepNormalsOut) #13
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuCompoundPairsOut) #13
  ret void

ehcleanup:                                        ; preds = %lpad11, %lpad8
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuCompoundSepNormalsOut) #13
  br label %ehcleanup29

ehcleanup29:                                      ; preds = %ehcleanup, %lpad
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuCompoundPairsOut) #13
  br label %eh.resume

eh.resume:                                        ; preds = %ehcleanup29
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val30 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val30
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3Int4EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this1, i32 0, i32 0
  call void @_ZN18b3AlignedAllocatorI6b3Int4Lj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator)
  call void @_ZN20b3AlignedObjectArrayI6b3Int4E4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3Int4E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %newsize, ptr noundef nonnull align 16 dereferenceable(16) %fillData) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %newsize.addr = alloca i32, align 4
  %fillData.addr = alloca ptr, align 8
  %curSize = alloca i32, align 4
  %i = alloca i32, align 4
  %i6 = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %newsize, ptr %newsize.addr, align 4
  store ptr %fillData, ptr %fillData.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI6b3Int4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  store i32 %call, ptr %curSize, align 4
  %0 = load i32, ptr %newsize.addr, align 4
  %1 = load i32, ptr %curSize, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %newsize.addr, align 4
  store i32 %2, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i32, ptr %i, align 4
  %4 = load i32, ptr %curSize, align 4
  %cmp2 = icmp slt i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, ptr %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !57

for.end:                                          ; preds = %for.cond
  br label %if.end17

if.else:                                          ; preds = %entry
  %6 = load i32, ptr %newsize.addr, align 4
  %call3 = call noundef i32 @_ZNK20b3AlignedObjectArrayI6b3Int4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %cmp4 = icmp sgt i32 %6, %call3
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  %7 = load i32, ptr %newsize.addr, align 4
  call void @_ZN20b3AlignedObjectArrayI6b3Int4E7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %7)
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.else
  %8 = load i32, ptr %curSize, align 4
  store i32 %8, ptr %i6, align 4
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc14, %if.end
  %9 = load i32, ptr %i6, align 4
  %10 = load i32, ptr %newsize.addr, align 4
  %cmp8 = icmp slt i32 %9, %10
  br i1 %cmp8, label %for.body9, label %for.end16

for.body9:                                        ; preds = %for.cond7
  %m_data10 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this1, i32 0, i32 5
  %11 = load ptr, ptr %m_data10, align 8
  %12 = load i32, ptr %i6, align 4
  %idxprom11 = sext i32 %12 to i64
  %arrayidx12 = getelementptr inbounds %struct.b3Int4, ptr %11, i64 %idxprom11
  %call13 = call noundef ptr @_ZN6b3Int4nwEmPv(i64 noundef 16, ptr noundef %arrayidx12)
  %13 = load ptr, ptr %fillData.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %call13, ptr align 16 %13, i64 16, i1 false)
  br label %for.inc14

for.inc14:                                        ; preds = %for.body9
  %14 = load i32, ptr %i6, align 4
  %inc15 = add nsw i32 %14, 1
  store i32 %inc15, ptr %i6, align 4
  br label %for.cond7, !llvm.loop !58

for.end16:                                        ; preds = %for.cond7
  br label %if.end17

if.end17:                                         ; preds = %for.end16, %for.end
  %15 = load i32, ptr %newsize.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this1, i32 0, i32 2
  store i32 %15, ptr %m_size, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI6b3Int4EixEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3Int4, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this1, i32 0, i32 0
  call void @_ZN18b3AlignedAllocatorI9b3Vector3Lj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator)
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3E4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayIiEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this1, i32 0, i32 0
  call void @_ZN18b3AlignedAllocatorIiLj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator)
  call void @_ZN20b3AlignedObjectArrayIiE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %newsize, ptr noundef nonnull align 16 dereferenceable(16) %fillData) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %newsize.addr = alloca i32, align 4
  %fillData.addr = alloca ptr, align 8
  %curSize = alloca i32, align 4
  %i = alloca i32, align 4
  %i6 = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %newsize, ptr %newsize.addr, align 4
  store ptr %fillData, ptr %fillData.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI9b3Vector3E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  store i32 %call, ptr %curSize, align 4
  %0 = load i32, ptr %newsize.addr, align 4
  %1 = load i32, ptr %curSize, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %newsize.addr, align 4
  store i32 %2, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i32, ptr %i, align 4
  %4 = load i32, ptr %curSize, align 4
  %cmp2 = icmp slt i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, ptr %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !59

for.end:                                          ; preds = %for.cond
  br label %if.end17

if.else:                                          ; preds = %entry
  %6 = load i32, ptr %newsize.addr, align 4
  %call3 = call noundef i32 @_ZNK20b3AlignedObjectArrayI9b3Vector3E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %cmp4 = icmp sgt i32 %6, %call3
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  %7 = load i32, ptr %newsize.addr, align 4
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3E7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %7)
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.else
  %8 = load i32, ptr %curSize, align 4
  store i32 %8, ptr %i6, align 4
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc14, %if.end
  %9 = load i32, ptr %i6, align 4
  %10 = load i32, ptr %newsize.addr, align 4
  %cmp8 = icmp slt i32 %9, %10
  br i1 %cmp8, label %for.body9, label %for.end16

for.body9:                                        ; preds = %for.cond7
  %m_data10 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this1, i32 0, i32 5
  %11 = load ptr, ptr %m_data10, align 8
  %12 = load i32, ptr %i6, align 4
  %idxprom11 = sext i32 %12 to i64
  %arrayidx12 = getelementptr inbounds %class.b3Vector3, ptr %11, i64 %idxprom11
  %call13 = call noundef ptr @_ZN9b3Vector3nwEmPv(i64 noundef 16, ptr noundef %arrayidx12)
  %13 = load ptr, ptr %fillData.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %call13, ptr align 16 %13, i64 16, i1 false)
  br label %for.inc14

for.inc14:                                        ; preds = %for.body9
  %14 = load i32, ptr %i6, align 4
  %inc15 = add nsw i32 %14, 1
  store i32 %inc15, ptr %i6, align 4
  br label %for.cond7, !llvm.loop !60

for.end16:                                        ; preds = %for.cond7
  br label %if.end17

if.end17:                                         ; preds = %for.end16, %for.end
  %15 = load i32, ptr %newsize.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this1, i32 0, i32 2
  store i32 %15, ptr %m_size, align 4
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayIiE6resizeEiRKi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %newsize, ptr noundef nonnull align 4 dereferenceable(4) %fillData) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %newsize.addr = alloca i32, align 4
  %fillData.addr = alloca ptr, align 8
  %curSize = alloca i32, align 4
  %i = alloca i32, align 4
  %i6 = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %newsize, ptr %newsize.addr, align 4
  store ptr %fillData, ptr %fillData.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayIiE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  store i32 %call, ptr %curSize, align 4
  %0 = load i32, ptr %newsize.addr, align 4
  %1 = load i32, ptr %curSize, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %newsize.addr, align 4
  store i32 %2, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i32, ptr %i, align 4
  %4 = load i32, ptr %curSize, align 4
  %cmp2 = icmp slt i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, ptr %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !61

for.end:                                          ; preds = %for.cond
  br label %if.end16

if.else:                                          ; preds = %entry
  %6 = load i32, ptr %newsize.addr, align 4
  %call3 = call noundef i32 @_ZNK20b3AlignedObjectArrayIiE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %cmp4 = icmp sgt i32 %6, %call3
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  %7 = load i32, ptr %newsize.addr, align 4
  call void @_ZN20b3AlignedObjectArrayIiE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %7)
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.else
  %8 = load i32, ptr %curSize, align 4
  store i32 %8, ptr %i6, align 4
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc13, %if.end
  %9 = load i32, ptr %i6, align 4
  %10 = load i32, ptr %newsize.addr, align 4
  %cmp8 = icmp slt i32 %9, %10
  br i1 %cmp8, label %for.body9, label %for.end15

for.body9:                                        ; preds = %for.cond7
  %m_data10 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this1, i32 0, i32 5
  %11 = load ptr, ptr %m_data10, align 8
  %12 = load i32, ptr %i6, align 4
  %idxprom11 = sext i32 %12 to i64
  %arrayidx12 = getelementptr inbounds i32, ptr %11, i64 %idxprom11
  %13 = load ptr, ptr %fillData.addr, align 8
  %14 = load i32, ptr %13, align 4
  store i32 %14, ptr %arrayidx12, align 4
  br label %for.inc13

for.inc13:                                        ; preds = %for.body9
  %15 = load i32, ptr %i6, align 4
  %inc14 = add nsw i32 %15, 1
  store i32 %inc14, ptr %i6, align 4
  br label %for.cond7, !llvm.loop !62

for.end15:                                        ; preds = %for.cond7
  br label %if.end16

if.end16:                                         ; preds = %for.end15, %for.end
  %16 = load i32, ptr %newsize.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this1, i32 0, i32 2
  store i32 %16, ptr %m_size, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #3 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  invoke void @_ZN20b3AlignedObjectArrayIiE5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #14
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #3 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3E5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #14
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #3 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  invoke void @_ZN20b3AlignedObjectArrayI6b3Int4E5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #14
  unreachable
}

; Function Attrs: mustprogress uwtable
define dso_local void @_Z27computeContactPlaneCompoundiiiiiPK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataPK15b3GpuChildShapePK9b3Vector3PKiPK9b3GpuFaceP10b3Contact4Rii(i32 noundef %pairIndex, i32 noundef %bodyIndexA, i32 noundef %bodyIndexB, i32 noundef %collidableIndexA, i32 noundef %collidableIndexB, ptr noundef %rigidBodies, ptr noundef %collidables, ptr noundef %convexShapes, ptr noundef %cpuChildShapes, ptr noundef %convexVertices, ptr noundef %convexIndices, ptr noundef %faces, ptr noundef %globalContactsOut, ptr noundef nonnull align 4 dereferenceable(4) %nGlobalContactsOut, i32 noundef %maxContactCapacity) #2 {
entry:
  %pairIndex.addr = alloca i32, align 4
  %bodyIndexA.addr = alloca i32, align 4
  %bodyIndexB.addr = alloca i32, align 4
  %collidableIndexA.addr = alloca i32, align 4
  %collidableIndexB.addr = alloca i32, align 4
  %rigidBodies.addr = alloca ptr, align 8
  %collidables.addr = alloca ptr, align 8
  %convexShapes.addr = alloca ptr, align 8
  %cpuChildShapes.addr = alloca ptr, align 8
  %convexVertices.addr = alloca ptr, align 8
  %convexIndices.addr = alloca ptr, align 8
  %faces.addr = alloca ptr, align 8
  %globalContactsOut.addr = alloca ptr, align 8
  %nGlobalContactsOut.addr = alloca ptr, align 8
  %maxContactCapacity.addr = alloca i32, align 4
  %shapeTypeB = alloca i32, align 4
  %numChildrenB = alloca i32, align 4
  %c = alloca i32, align 4
  %childShapeIndexB = alloca i32, align 4
  %childColIndexB = alloca i32, align 4
  %rootPosB = alloca %class.b3Vector3, align 16
  %rootOrnB = alloca %class.b3Quaternion, align 16
  %childPosB = alloca %class.b3Vector3, align 16
  %childOrnB = alloca %class.b3Quaternion, align 16
  %posB = alloca %class.b3Vector3, align 16
  %ref.tmp = alloca %class.b3Vector3, align 16
  %ornB = alloca %class.b3Quaternion, align 16
  %shapeIndexB = alloca i32, align 4
  %hullB = alloca ptr, align 8
  %posA = alloca %class.b3Vector3, align 16
  %ornA = alloca %class.b3Quaternion, align 16
  %planeEq = alloca %class.b3Vector3, align 16
  %planeNormal = alloca %class.b3Vector3, align 16
  %planeNormalWorld = alloca %class.b3Vector3, align 16
  %planeConstant = alloca float, align 4
  %convexWorldTransform = alloca %class.b3Transform, align 16
  %planeTransform = alloca %class.b3Transform, align 16
  %planeInConvex = alloca %class.b3Transform, align 16
  %ref.tmp43 = alloca %class.b3Transform, align 16
  %ref.tmp44 = alloca %class.b3Transform, align 16
  %convexInPlane = alloca %class.b3Transform, align 16
  %ref.tmp46 = alloca %class.b3Transform, align 16
  %ref.tmp47 = alloca %class.b3Transform, align 16
  %planeNormalInConvex = alloca %class.b3Vector3, align 16
  %ref.tmp50 = alloca %class.b3Vector3, align 16
  %maxDot = alloca float, align 4
  %hitVertex = alloca i32, align 4
  %hitVtx = alloca %class.b3Vector3, align 16
  %contactPoints = alloca [64 x %class.b3Vector3], align 16
  %numPoints = alloca i32, align 4
  %contactIdx = alloca %struct.b3Int4, align 16
  %i = alloca i32, align 4
  %vtx = alloca %class.b3Vector3, align 16
  %curDot = alloca float, align 4
  %vtxWorld = alloca %class.b3Vector3, align 16
  %vtxInPlane = alloca %class.b3Vector3, align 16
  %ref.tmp80 = alloca %class.b3Transform, align 16
  %dist = alloca float, align 4
  %numReducedPoints = alloca i32, align 4
  %dstIdx = alloca i32, align 4
  %c102 = alloca ptr, align 8
  %ref.tmp105 = alloca %class.b3Vector3, align 16
  %i122 = alloca i32, align 4
  %pOnB1 = alloca %class.b3Vector3, align 16
  store i32 %pairIndex, ptr %pairIndex.addr, align 4
  store i32 %bodyIndexA, ptr %bodyIndexA.addr, align 4
  store i32 %bodyIndexB, ptr %bodyIndexB.addr, align 4
  store i32 %collidableIndexA, ptr %collidableIndexA.addr, align 4
  store i32 %collidableIndexB, ptr %collidableIndexB.addr, align 4
  store ptr %rigidBodies, ptr %rigidBodies.addr, align 8
  store ptr %collidables, ptr %collidables.addr, align 8
  store ptr %convexShapes, ptr %convexShapes.addr, align 8
  store ptr %cpuChildShapes, ptr %cpuChildShapes.addr, align 8
  store ptr %convexVertices, ptr %convexVertices.addr, align 8
  store ptr %convexIndices, ptr %convexIndices.addr, align 8
  store ptr %faces, ptr %faces.addr, align 8
  store ptr %globalContactsOut, ptr %globalContactsOut.addr, align 8
  store ptr %nGlobalContactsOut, ptr %nGlobalContactsOut.addr, align 8
  store i32 %maxContactCapacity, ptr %maxContactCapacity.addr, align 4
  %0 = load ptr, ptr %collidables.addr, align 8
  %1 = load i32, ptr %collidableIndexB.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3Collidable, ptr %0, i64 %idxprom
  %m_shapeType = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx, i32 0, i32 2
  %2 = load i32, ptr %m_shapeType, align 4
  store i32 %2, ptr %shapeTypeB, align 4
  %3 = load ptr, ptr %collidables.addr, align 8
  %4 = load i32, ptr %collidableIndexB.addr, align 4
  %idxprom1 = sext i32 %4 to i64
  %arrayidx2 = getelementptr inbounds %struct.b3Collidable, ptr %3, i64 %idxprom1
  %5 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx2, i32 0, i32 0
  %6 = load i32, ptr %5, align 4
  store i32 %6, ptr %numChildrenB, align 4
  store i32 0, ptr %c, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc140, %entry
  %7 = load i32, ptr %c, align 4
  %8 = load i32, ptr %numChildrenB, align 4
  %cmp = icmp slt i32 %7, %8
  br i1 %cmp, label %for.body, label %for.end142

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr %collidables.addr, align 8
  %10 = load i32, ptr %collidableIndexB.addr, align 4
  %idxprom3 = sext i32 %10 to i64
  %arrayidx4 = getelementptr inbounds %struct.b3Collidable, ptr %9, i64 %idxprom3
  %11 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx4, i32 0, i32 3
  %12 = load i32, ptr %11, align 4
  %13 = load i32, ptr %c, align 4
  %add = add nsw i32 %12, %13
  store i32 %add, ptr %childShapeIndexB, align 4
  %14 = load ptr, ptr %cpuChildShapes.addr, align 8
  %15 = load i32, ptr %childShapeIndexB, align 4
  %idxprom5 = sext i32 %15 to i64
  %arrayidx6 = getelementptr inbounds %struct.b3GpuChildShape, ptr %14, i64 %idxprom5
  %16 = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx6, i32 0, i32 2
  %17 = load i32, ptr %16, align 16
  store i32 %17, ptr %childColIndexB, align 4
  %18 = load ptr, ptr %rigidBodies.addr, align 8
  %19 = load i32, ptr %bodyIndexB.addr, align 4
  %idxprom7 = sext i32 %19 to i64
  %arrayidx8 = getelementptr inbounds %struct.b3RigidBodyData, ptr %18, i64 %idxprom7
  %m_pos = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx8, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %rootPosB, ptr align 16 %m_pos, i64 16, i1 false)
  %20 = load ptr, ptr %rigidBodies.addr, align 8
  %21 = load i32, ptr %bodyIndexB.addr, align 4
  %idxprom9 = sext i32 %21 to i64
  %arrayidx10 = getelementptr inbounds %struct.b3RigidBodyData, ptr %20, i64 %idxprom9
  %m_quat = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx10, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %rootOrnB, ptr align 16 %m_quat, i64 16, i1 false)
  %22 = load ptr, ptr %cpuChildShapes.addr, align 8
  %23 = load i32, ptr %childShapeIndexB, align 4
  %idxprom11 = sext i32 %23 to i64
  %arrayidx12 = getelementptr inbounds %struct.b3GpuChildShape, ptr %22, i64 %idxprom11
  %m_childPosition = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx12, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %childPosB, ptr align 16 %m_childPosition, i64 16, i1 false)
  %24 = load ptr, ptr %cpuChildShapes.addr, align 8
  %25 = load i32, ptr %childShapeIndexB, align 4
  %idxprom13 = sext i32 %25 to i64
  %arrayidx14 = getelementptr inbounds %struct.b3GpuChildShape, ptr %24, i64 %idxprom13
  %m_childOrientation = getelementptr inbounds %struct.b3GpuChildShape, ptr %arrayidx14, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %childOrnB, ptr align 16 %m_childOrientation, i64 16, i1 false)
  %call = call { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %rootOrnB, ptr noundef nonnull align 16 dereferenceable(16) %childPosB)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive15 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %26 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive15, i32 0, i32 0
  %27 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %27, ptr %26, align 16
  %28 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive15, i32 0, i32 1
  %29 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %29, ptr %28, align 8
  %call16 = call { <2 x float>, <2 x float> } @_ZplRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp, ptr noundef nonnull align 16 dereferenceable(16) %rootPosB)
  %coerce.dive17 = getelementptr inbounds %class.b3Vector3, ptr %posB, i32 0, i32 0
  %coerce.dive18 = getelementptr inbounds %union.anon.1, ptr %coerce.dive17, i32 0, i32 0
  %30 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive18, i32 0, i32 0
  %31 = extractvalue { <2 x float>, <2 x float> } %call16, 0
  store <2 x float> %31, ptr %30, align 16
  %32 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive18, i32 0, i32 1
  %33 = extractvalue { <2 x float>, <2 x float> } %call16, 1
  store <2 x float> %33, ptr %32, align 8
  %call19 = call { <2 x float>, <2 x float> } @_ZmlRK12b3QuaternionS1_(ptr noundef nonnull align 16 dereferenceable(16) %rootOrnB, ptr noundef nonnull align 16 dereferenceable(16) %childOrnB)
  %coerce.dive20 = getelementptr inbounds %class.b3Quaternion, ptr %ornB, i32 0, i32 0
  %coerce.dive21 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive20, i32 0, i32 0
  %coerce.dive22 = getelementptr inbounds %union.anon.3, ptr %coerce.dive21, i32 0, i32 0
  %34 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive22, i32 0, i32 0
  %35 = extractvalue { <2 x float>, <2 x float> } %call19, 0
  store <2 x float> %35, ptr %34, align 16
  %36 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive22, i32 0, i32 1
  %37 = extractvalue { <2 x float>, <2 x float> } %call19, 1
  store <2 x float> %37, ptr %36, align 8
  %38 = load ptr, ptr %collidables.addr, align 8
  %39 = load i32, ptr %childColIndexB, align 4
  %idxprom23 = sext i32 %39 to i64
  %arrayidx24 = getelementptr inbounds %struct.b3Collidable, ptr %38, i64 %idxprom23
  %40 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx24, i32 0, i32 3
  %41 = load i32, ptr %40, align 4
  store i32 %41, ptr %shapeIndexB, align 4
  %42 = load ptr, ptr %convexShapes.addr, align 8
  %43 = load i32, ptr %shapeIndexB, align 4
  %idxprom25 = sext i32 %43 to i64
  %arrayidx26 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %42, i64 %idxprom25
  store ptr %arrayidx26, ptr %hullB, align 8
  %44 = load ptr, ptr %rigidBodies.addr, align 8
  %45 = load i32, ptr %bodyIndexA.addr, align 4
  %idxprom27 = sext i32 %45 to i64
  %arrayidx28 = getelementptr inbounds %struct.b3RigidBodyData, ptr %44, i64 %idxprom27
  %m_pos29 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx28, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posA, ptr align 16 %m_pos29, i64 16, i1 false)
  %46 = load ptr, ptr %rigidBodies.addr, align 8
  %47 = load i32, ptr %bodyIndexA.addr, align 4
  %idxprom30 = sext i32 %47 to i64
  %arrayidx31 = getelementptr inbounds %struct.b3RigidBodyData, ptr %46, i64 %idxprom30
  %m_quat32 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx31, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornA, ptr align 16 %m_quat32, i64 16, i1 false)
  %48 = load ptr, ptr %faces.addr, align 8
  %49 = load ptr, ptr %collidables.addr, align 8
  %50 = load i32, ptr %collidableIndexA.addr, align 4
  %idxprom33 = sext i32 %50 to i64
  %arrayidx34 = getelementptr inbounds %struct.b3Collidable, ptr %49, i64 %idxprom33
  %51 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx34, i32 0, i32 3
  %52 = load i32, ptr %51, align 4
  %idxprom35 = sext i32 %52 to i64
  %arrayidx36 = getelementptr inbounds %struct.b3GpuFace, ptr %48, i64 %idxprom35
  %m_plane = getelementptr inbounds %struct.b3GpuFace, ptr %arrayidx36, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %planeEq, ptr align 16 %m_plane, i64 16, i1 false)
  %53 = getelementptr inbounds %class.b3Vector3, ptr %planeEq, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon.2, ptr %53, i32 0, i32 0
  %54 = load float, ptr %x, align 16
  %55 = getelementptr inbounds %class.b3Vector3, ptr %planeEq, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon.2, ptr %55, i32 0, i32 1
  %56 = load float, ptr %y, align 4
  %57 = getelementptr inbounds %class.b3Vector3, ptr %planeEq, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon.2, ptr %57, i32 0, i32 2
  %58 = load float, ptr %z, align 8
  %call37 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef %54, float noundef %56, float noundef %58)
  %coerce.dive38 = getelementptr inbounds %class.b3Vector3, ptr %planeNormal, i32 0, i32 0
  %coerce.dive39 = getelementptr inbounds %union.anon.1, ptr %coerce.dive38, i32 0, i32 0
  %59 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive39, i32 0, i32 0
  %60 = extractvalue { <2 x float>, <2 x float> } %call37, 0
  store <2 x float> %60, ptr %59, align 16
  %61 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive39, i32 0, i32 1
  %62 = extractvalue { <2 x float>, <2 x float> } %call37, 1
  store <2 x float> %62, ptr %61, align 8
  %call40 = call { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %planeNormal)
  %coerce.dive41 = getelementptr inbounds %class.b3Vector3, ptr %planeNormalWorld, i32 0, i32 0
  %coerce.dive42 = getelementptr inbounds %union.anon.1, ptr %coerce.dive41, i32 0, i32 0
  %63 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive42, i32 0, i32 0
  %64 = extractvalue { <2 x float>, <2 x float> } %call40, 0
  store <2 x float> %64, ptr %63, align 16
  %65 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive42, i32 0, i32 1
  %66 = extractvalue { <2 x float>, <2 x float> } %call40, 1
  store <2 x float> %66, ptr %65, align 8
  %67 = getelementptr inbounds %class.b3Vector3, ptr %planeEq, i32 0, i32 0
  %w = getelementptr inbounds %struct.anon.2, ptr %67, i32 0, i32 3
  %68 = load float, ptr %w, align 4
  store float %68, ptr %planeConstant, align 4
  call void @_ZN11b3TransformC2Ev(ptr noundef nonnull align 16 dereferenceable(64) %convexWorldTransform)
  call void @_ZN11b3Transform11setIdentityEv(ptr noundef nonnull align 16 dereferenceable(64) %convexWorldTransform)
  call void @_ZN11b3Transform9setOriginERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %convexWorldTransform, ptr noundef nonnull align 16 dereferenceable(16) %posB)
  call void @_ZN11b3Transform11setRotationERK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(64) %convexWorldTransform, ptr noundef nonnull align 16 dereferenceable(16) %ornB)
  call void @_ZN11b3TransformC2Ev(ptr noundef nonnull align 16 dereferenceable(64) %planeTransform)
  call void @_ZN11b3Transform11setIdentityEv(ptr noundef nonnull align 16 dereferenceable(64) %planeTransform)
  call void @_ZN11b3Transform9setOriginERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %planeTransform, ptr noundef nonnull align 16 dereferenceable(16) %posA)
  call void @_ZN11b3Transform11setRotationERK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(64) %planeTransform, ptr noundef nonnull align 16 dereferenceable(16) %ornA)
  call void @_ZN11b3TransformC2Ev(ptr noundef nonnull align 16 dereferenceable(64) %planeInConvex)
  call void @_ZNK11b3Transform7inverseEv(ptr sret(%class.b3Transform) align 16 %ref.tmp44, ptr noundef nonnull align 16 dereferenceable(64) %convexWorldTransform)
  call void @_ZNK11b3TransformmlERKS_(ptr sret(%class.b3Transform) align 16 %ref.tmp43, ptr noundef nonnull align 16 dereferenceable(64) %ref.tmp44, ptr noundef nonnull align 16 dereferenceable(64) %planeTransform)
  %call45 = call noundef nonnull align 16 dereferenceable(64) ptr @_ZN11b3TransformaSERKS_(ptr noundef nonnull align 16 dereferenceable(64) %planeInConvex, ptr noundef nonnull align 16 dereferenceable(64) %ref.tmp43)
  call void @_ZN11b3TransformC2Ev(ptr noundef nonnull align 16 dereferenceable(64) %convexInPlane)
  call void @_ZNK11b3Transform7inverseEv(ptr sret(%class.b3Transform) align 16 %ref.tmp47, ptr noundef nonnull align 16 dereferenceable(64) %planeTransform)
  call void @_ZNK11b3TransformmlERKS_(ptr sret(%class.b3Transform) align 16 %ref.tmp46, ptr noundef nonnull align 16 dereferenceable(64) %ref.tmp47, ptr noundef nonnull align 16 dereferenceable(64) %convexWorldTransform)
  %call48 = call noundef nonnull align 16 dereferenceable(64) ptr @_ZN11b3TransformaSERKS_(ptr noundef nonnull align 16 dereferenceable(64) %convexInPlane, ptr noundef nonnull align 16 dereferenceable(64) %ref.tmp46)
  %call49 = call noundef nonnull align 16 dereferenceable(48) ptr @_ZN11b3Transform8getBasisEv(ptr noundef nonnull align 16 dereferenceable(64) %planeInConvex)
  %call51 = call { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %planeNormal)
  %coerce.dive52 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp50, i32 0, i32 0
  %coerce.dive53 = getelementptr inbounds %union.anon.1, ptr %coerce.dive52, i32 0, i32 0
  %69 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive53, i32 0, i32 0
  %70 = extractvalue { <2 x float>, <2 x float> } %call51, 0
  store <2 x float> %70, ptr %69, align 16
  %71 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive53, i32 0, i32 1
  %72 = extractvalue { <2 x float>, <2 x float> } %call51, 1
  store <2 x float> %72, ptr %71, align 8
  %call54 = call { <2 x float>, <2 x float> } @_ZmlRK11b3Matrix3x3RK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(48) %call49, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp50)
  %coerce.dive55 = getelementptr inbounds %class.b3Vector3, ptr %planeNormalInConvex, i32 0, i32 0
  %coerce.dive56 = getelementptr inbounds %union.anon.1, ptr %coerce.dive55, i32 0, i32 0
  %73 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive56, i32 0, i32 0
  %74 = extractvalue { <2 x float>, <2 x float> } %call54, 0
  store <2 x float> %74, ptr %73, align 16
  %75 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive56, i32 0, i32 1
  %76 = extractvalue { <2 x float>, <2 x float> } %call54, 1
  store <2 x float> %76, ptr %75, align 8
  store float 0xC6293E5940000000, ptr %maxDot, align 4
  store i32 -1, ptr %hitVertex, align 4
  store i32 0, ptr %numPoints, align 4
  %77 = getelementptr inbounds %struct.b3Int4, ptr %contactIdx, i32 0, i32 0
  %s = getelementptr inbounds %struct.anon.0, ptr %77, i32 0, i32 0
  %arrayidx57 = getelementptr inbounds [4 x i32], ptr %s, i64 0, i64 0
  store i32 0, ptr %arrayidx57, align 16
  %78 = getelementptr inbounds %struct.b3Int4, ptr %contactIdx, i32 0, i32 0
  %s58 = getelementptr inbounds %struct.anon.0, ptr %78, i32 0, i32 0
  %arrayidx59 = getelementptr inbounds [4 x i32], ptr %s58, i64 0, i64 1
  store i32 1, ptr %arrayidx59, align 4
  %79 = getelementptr inbounds %struct.b3Int4, ptr %contactIdx, i32 0, i32 0
  %s60 = getelementptr inbounds %struct.anon.0, ptr %79, i32 0, i32 0
  %arrayidx61 = getelementptr inbounds [4 x i32], ptr %s60, i64 0, i64 2
  store i32 2, ptr %arrayidx61, align 8
  %80 = getelementptr inbounds %struct.b3Int4, ptr %contactIdx, i32 0, i32 0
  %s62 = getelementptr inbounds %struct.anon.0, ptr %80, i32 0, i32 0
  %arrayidx63 = getelementptr inbounds [4 x i32], ptr %s62, i64 0, i64 3
  store i32 3, ptr %arrayidx63, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond64

for.cond64:                                       ; preds = %for.inc, %for.body
  %81 = load i32, ptr %i, align 4
  %82 = load ptr, ptr %hullB, align 8
  %m_numVertices = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %82, i32 0, i32 7
  %83 = load i32, ptr %m_numVertices, align 4
  %cmp65 = icmp slt i32 %81, %83
  br i1 %cmp65, label %for.body66, label %for.end

for.body66:                                       ; preds = %for.cond64
  %84 = load ptr, ptr %convexVertices.addr, align 8
  %85 = load ptr, ptr %hullB, align 8
  %m_vertexOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %85, i32 0, i32 8
  %86 = load i32, ptr %m_vertexOffset, align 16
  %87 = load i32, ptr %i, align 4
  %add67 = add nsw i32 %86, %87
  %idxprom68 = sext i32 %add67 to i64
  %arrayidx69 = getelementptr inbounds %class.b3Vector3, ptr %84, i64 %idxprom68
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %vtx, ptr align 16 %arrayidx69, i64 16, i1 false)
  %call70 = call noundef float @_ZNK9b3Vector33dotERKS_(ptr noundef nonnull align 16 dereferenceable(16) %vtx, ptr noundef nonnull align 16 dereferenceable(16) %planeNormalInConvex)
  store float %call70, ptr %curDot, align 4
  %88 = load float, ptr %curDot, align 4
  %89 = load float, ptr %maxDot, align 4
  %cmp71 = fcmp ogt float %88, %89
  br i1 %cmp71, label %if.then, label %if.end74

if.then:                                          ; preds = %for.body66
  %90 = load i32, ptr %i, align 4
  store i32 %90, ptr %hitVertex, align 4
  %91 = load float, ptr %curDot, align 4
  store float %91, ptr %maxDot, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %hitVtx, ptr align 16 %vtx, i64 16, i1 false)
  %92 = load i32, ptr %numPoints, align 4
  %cmp72 = icmp eq i32 %92, 64
  br i1 %cmp72, label %if.then73, label %if.end

if.then73:                                        ; preds = %if.then
  %93 = load i32, ptr %numPoints, align 4
  %dec = add nsw i32 %93, -1
  store i32 %dec, ptr %numPoints, align 4
  br label %if.end

if.end:                                           ; preds = %if.then73, %if.then
  br label %if.end74

if.end74:                                         ; preds = %if.end, %for.body66
  %94 = load i32, ptr %numPoints, align 4
  %cmp75 = icmp slt i32 %94, 64
  br i1 %cmp75, label %if.then76, label %if.end91

if.then76:                                        ; preds = %if.end74
  %call77 = call { <2 x float>, <2 x float> } @_ZNK11b3TransformmlERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %convexWorldTransform, ptr noundef nonnull align 16 dereferenceable(16) %vtx)
  %coerce.dive78 = getelementptr inbounds %class.b3Vector3, ptr %vtxWorld, i32 0, i32 0
  %coerce.dive79 = getelementptr inbounds %union.anon.1, ptr %coerce.dive78, i32 0, i32 0
  %95 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive79, i32 0, i32 0
  %96 = extractvalue { <2 x float>, <2 x float> } %call77, 0
  store <2 x float> %96, ptr %95, align 16
  %97 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive79, i32 0, i32 1
  %98 = extractvalue { <2 x float>, <2 x float> } %call77, 1
  store <2 x float> %98, ptr %97, align 8
  call void @_ZNK11b3Transform7inverseEv(ptr sret(%class.b3Transform) align 16 %ref.tmp80, ptr noundef nonnull align 16 dereferenceable(64) %planeTransform)
  %call81 = call { <2 x float>, <2 x float> } @_ZNK11b3TransformmlERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %ref.tmp80, ptr noundef nonnull align 16 dereferenceable(16) %vtxWorld)
  %coerce.dive82 = getelementptr inbounds %class.b3Vector3, ptr %vtxInPlane, i32 0, i32 0
  %coerce.dive83 = getelementptr inbounds %union.anon.1, ptr %coerce.dive82, i32 0, i32 0
  %99 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive83, i32 0, i32 0
  %100 = extractvalue { <2 x float>, <2 x float> } %call81, 0
  store <2 x float> %100, ptr %99, align 16
  %101 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive83, i32 0, i32 1
  %102 = extractvalue { <2 x float>, <2 x float> } %call81, 1
  store <2 x float> %102, ptr %101, align 8
  %call84 = call noundef float @_ZNK9b3Vector33dotERKS_(ptr noundef nonnull align 16 dereferenceable(16) %planeNormal, ptr noundef nonnull align 16 dereferenceable(16) %vtxInPlane)
  %103 = load float, ptr %planeConstant, align 4
  %sub = fsub float %call84, %103
  store float %sub, ptr %dist, align 4
  %104 = load float, ptr %dist, align 4
  %cmp85 = fcmp olt float %104, 0.000000e+00
  br i1 %cmp85, label %if.then86, label %if.end90

if.then86:                                        ; preds = %if.then76
  %105 = load float, ptr %dist, align 4
  %106 = getelementptr inbounds %class.b3Vector3, ptr %vtxWorld, i32 0, i32 0
  %w87 = getelementptr inbounds %struct.anon.2, ptr %106, i32 0, i32 3
  store float %105, ptr %w87, align 4
  %107 = load i32, ptr %numPoints, align 4
  %idxprom88 = sext i32 %107 to i64
  %arrayidx89 = getelementptr inbounds [64 x %class.b3Vector3], ptr %contactPoints, i64 0, i64 %idxprom88
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx89, ptr align 16 %vtxWorld, i64 16, i1 false)
  %108 = load i32, ptr %numPoints, align 4
  %inc = add nsw i32 %108, 1
  store i32 %inc, ptr %numPoints, align 4
  br label %if.end90

if.end90:                                         ; preds = %if.then86, %if.then76
  br label %if.end91

if.end91:                                         ; preds = %if.end90, %if.end74
  br label %for.inc

for.inc:                                          ; preds = %if.end91
  %109 = load i32, ptr %i, align 4
  %inc92 = add nsw i32 %109, 1
  store i32 %inc92, ptr %i, align 4
  br label %for.cond64, !llvm.loop !63

for.end:                                          ; preds = %for.cond64
  store i32 0, ptr %numReducedPoints, align 4
  %110 = load i32, ptr %numPoints, align 4
  store i32 %110, ptr %numReducedPoints, align 4
  %111 = load i32, ptr %numPoints, align 4
  %cmp93 = icmp sgt i32 %111, 4
  br i1 %cmp93, label %if.then94, label %if.end96

if.then94:                                        ; preds = %for.end
  %arraydecay = getelementptr inbounds [64 x %class.b3Vector3], ptr %contactPoints, i64 0, i64 0
  %112 = load i32, ptr %numPoints, align 4
  %call95 = call noundef i32 @_Z31extractManifoldSequentialGlobalPK9b3Vector3iRS0_P6b3Int4(ptr noundef %arraydecay, i32 noundef %112, ptr noundef nonnull align 16 dereferenceable(16) %planeNormalInConvex, ptr noundef %contactIdx)
  store i32 %call95, ptr %numReducedPoints, align 4
  br label %if.end96

if.end96:                                         ; preds = %if.then94, %for.end
  %113 = load i32, ptr %numReducedPoints, align 4
  %cmp97 = icmp sgt i32 %113, 0
  br i1 %cmp97, label %if.then98, label %if.end139

if.then98:                                        ; preds = %if.end96
  %114 = load ptr, ptr %nGlobalContactsOut.addr, align 8
  %115 = load i32, ptr %114, align 4
  %116 = load i32, ptr %maxContactCapacity.addr, align 4
  %cmp99 = icmp slt i32 %115, %116
  br i1 %cmp99, label %if.then100, label %if.end138

if.then100:                                       ; preds = %if.then98
  %117 = load ptr, ptr %nGlobalContactsOut.addr, align 8
  %118 = load i32, ptr %117, align 4
  store i32 %118, ptr %dstIdx, align 4
  %119 = load ptr, ptr %nGlobalContactsOut.addr, align 8
  %120 = load i32, ptr %119, align 4
  %inc101 = add nsw i32 %120, 1
  store i32 %inc101, ptr %119, align 4
  %121 = load ptr, ptr %globalContactsOut.addr, align 8
  %122 = load i32, ptr %dstIdx, align 4
  %idxprom103 = sext i32 %122 to i64
  %arrayidx104 = getelementptr inbounds %struct.b3Contact4, ptr %121, i64 %idxprom103
  store ptr %arrayidx104, ptr %c102, align 8
  %call106 = call { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %planeNormalWorld)
  %coerce.dive107 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp105, i32 0, i32 0
  %coerce.dive108 = getelementptr inbounds %union.anon.1, ptr %coerce.dive107, i32 0, i32 0
  %123 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive108, i32 0, i32 0
  %124 = extractvalue { <2 x float>, <2 x float> } %call106, 0
  store <2 x float> %124, ptr %123, align 16
  %125 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive108, i32 0, i32 1
  %126 = extractvalue { <2 x float>, <2 x float> } %call106, 1
  store <2 x float> %126, ptr %125, align 8
  %127 = load ptr, ptr %c102, align 8
  %m_worldNormalOnB = getelementptr inbounds %struct.b3Contact4Data, ptr %127, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %m_worldNormalOnB, ptr align 16 %ref.tmp105, i64 16, i1 false)
  %128 = load ptr, ptr %c102, align 8
  call void @_ZN10b3Contact416setFrictionCoeffEf(ptr noundef nonnull align 16 dereferenceable(112) %128, float noundef 0x3FE6666660000000)
  %129 = load ptr, ptr %c102, align 8
  call void @_ZN10b3Contact420setRestituitionCoeffEf(ptr noundef nonnull align 16 dereferenceable(112) %129, float noundef 0.000000e+00)
  %130 = load i32, ptr %pairIndex.addr, align 4
  %131 = load ptr, ptr %c102, align 8
  %m_batchIdx = getelementptr inbounds %struct.b3Contact4Data, ptr %131, i32 0, i32 4
  store i32 %130, ptr %m_batchIdx, align 4
  %132 = load ptr, ptr %rigidBodies.addr, align 8
  %133 = load i32, ptr %bodyIndexA.addr, align 4
  %idxprom109 = sext i32 %133 to i64
  %arrayidx110 = getelementptr inbounds %struct.b3RigidBodyData, ptr %132, i64 %idxprom109
  %m_invMass = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx110, i32 0, i32 5
  %134 = load float, ptr %m_invMass, align 4
  %cmp111 = fcmp oeq float %134, 0.000000e+00
  br i1 %cmp111, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then100
  %135 = load i32, ptr %bodyIndexA.addr, align 4
  %sub112 = sub nsw i32 0, %135
  br label %cond.end

cond.false:                                       ; preds = %if.then100
  %136 = load i32, ptr %bodyIndexA.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %sub112, %cond.true ], [ %136, %cond.false ]
  %137 = load ptr, ptr %c102, align 8
  %m_bodyAPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %137, i32 0, i32 5
  store i32 %cond, ptr %m_bodyAPtrAndSignBit, align 8
  %138 = load ptr, ptr %rigidBodies.addr, align 8
  %139 = load i32, ptr %bodyIndexB.addr, align 4
  %idxprom113 = sext i32 %139 to i64
  %arrayidx114 = getelementptr inbounds %struct.b3RigidBodyData, ptr %138, i64 %idxprom113
  %m_invMass115 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx114, i32 0, i32 5
  %140 = load float, ptr %m_invMass115, align 4
  %cmp116 = fcmp oeq float %140, 0.000000e+00
  br i1 %cmp116, label %cond.true117, label %cond.false119

cond.true117:                                     ; preds = %cond.end
  %141 = load i32, ptr %bodyIndexB.addr, align 4
  %sub118 = sub nsw i32 0, %141
  br label %cond.end120

cond.false119:                                    ; preds = %cond.end
  %142 = load i32, ptr %bodyIndexB.addr, align 4
  br label %cond.end120

cond.end120:                                      ; preds = %cond.false119, %cond.true117
  %cond121 = phi i32 [ %sub118, %cond.true117 ], [ %142, %cond.false119 ]
  %143 = load ptr, ptr %c102, align 8
  %m_bodyBPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %143, i32 0, i32 6
  store i32 %cond121, ptr %m_bodyBPtrAndSignBit, align 4
  store i32 0, ptr %i122, align 4
  br label %for.cond123

for.cond123:                                      ; preds = %for.inc133, %cond.end120
  %144 = load i32, ptr %i122, align 4
  %145 = load i32, ptr %numReducedPoints, align 4
  %cmp124 = icmp slt i32 %144, %145
  br i1 %cmp124, label %for.body125, label %for.end135

for.body125:                                      ; preds = %for.cond123
  %146 = getelementptr inbounds %struct.b3Int4, ptr %contactIdx, i32 0, i32 0
  %s126 = getelementptr inbounds %struct.anon.0, ptr %146, i32 0, i32 0
  %147 = load i32, ptr %i122, align 4
  %idxprom127 = sext i32 %147 to i64
  %arrayidx128 = getelementptr inbounds [4 x i32], ptr %s126, i64 0, i64 %idxprom127
  %148 = load i32, ptr %arrayidx128, align 4
  %idxprom129 = sext i32 %148 to i64
  %arrayidx130 = getelementptr inbounds [64 x %class.b3Vector3], ptr %contactPoints, i64 0, i64 %idxprom129
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %pOnB1, ptr align 16 %arrayidx130, i64 16, i1 false)
  %149 = load ptr, ptr %c102, align 8
  %m_worldPosB = getelementptr inbounds %struct.b3Contact4Data, ptr %149, i32 0, i32 0
  %150 = load i32, ptr %i122, align 4
  %idxprom131 = sext i32 %150 to i64
  %arrayidx132 = getelementptr inbounds [4 x %class.b3Vector3], ptr %m_worldPosB, i64 0, i64 %idxprom131
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx132, ptr align 16 %pOnB1, i64 16, i1 false)
  br label %for.inc133

for.inc133:                                       ; preds = %for.body125
  %151 = load i32, ptr %i122, align 4
  %inc134 = add nsw i32 %151, 1
  store i32 %inc134, ptr %i122, align 4
  br label %for.cond123, !llvm.loop !64

for.end135:                                       ; preds = %for.cond123
  %152 = load i32, ptr %numReducedPoints, align 4
  %conv = sitofp i32 %152 to float
  %153 = load ptr, ptr %c102, align 8
  %m_worldNormalOnB136 = getelementptr inbounds %struct.b3Contact4Data, ptr %153, i32 0, i32 1
  %154 = getelementptr inbounds %class.b3Vector3, ptr %m_worldNormalOnB136, i32 0, i32 0
  %w137 = getelementptr inbounds %struct.anon.2, ptr %154, i32 0, i32 3
  store float %conv, ptr %w137, align 4
  br label %if.end138

if.end138:                                        ; preds = %for.end135, %if.then98
  br label %if.end139

if.end139:                                        ; preds = %if.end138, %if.end96
  br label %for.inc140

for.inc140:                                       ; preds = %if.end139
  %155 = load i32, ptr %c, align 4
  %inc141 = add nsw i32 %155, 1
  store i32 %inc141, ptr %c, align 4
  br label %for.cond, !llvm.loop !65

for.end142:                                       ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_ZmlRK12b3QuaternionS1_(ptr noundef nonnull align 16 dereferenceable(16) %q1, ptr noundef nonnull align 16 dereferenceable(16) %q2) #0 comdat {
entry:
  %retval = alloca %class.b3Quaternion, align 16
  %q1.addr = alloca ptr, align 8
  %q2.addr = alloca ptr, align 8
  %ref.tmp = alloca float, align 4
  %ref.tmp9 = alloca float, align 4
  %ref.tmp20 = alloca float, align 4
  %ref.tmp31 = alloca float, align 4
  store ptr %q1, ptr %q1.addr, align 8
  store ptr %q2, ptr %q2.addr, align 8
  %0 = load ptr, ptr %q1.addr, align 8
  %call = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK12b3Quaternion4getWEv(ptr noundef nonnull align 16 dereferenceable(16) %0)
  %1 = load float, ptr %call, align 4
  %2 = load ptr, ptr %q2.addr, align 8
  %call1 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getXEv(ptr noundef nonnull align 16 dereferenceable(16) %2)
  %3 = load float, ptr %call1, align 4
  %4 = load ptr, ptr %q1.addr, align 8
  %call2 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getXEv(ptr noundef nonnull align 16 dereferenceable(16) %4)
  %5 = load float, ptr %call2, align 4
  %6 = load ptr, ptr %q2.addr, align 8
  %call3 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK12b3Quaternion4getWEv(ptr noundef nonnull align 16 dereferenceable(16) %6)
  %7 = load float, ptr %call3, align 4
  %mul4 = fmul float %5, %7
  %8 = call float @llvm.fmuladd.f32(float %1, float %3, float %mul4)
  %9 = load ptr, ptr %q1.addr, align 8
  %call5 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getYEv(ptr noundef nonnull align 16 dereferenceable(16) %9)
  %10 = load float, ptr %call5, align 4
  %11 = load ptr, ptr %q2.addr, align 8
  %call6 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getZEv(ptr noundef nonnull align 16 dereferenceable(16) %11)
  %12 = load float, ptr %call6, align 4
  %13 = call float @llvm.fmuladd.f32(float %10, float %12, float %8)
  %14 = load ptr, ptr %q1.addr, align 8
  %call7 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getZEv(ptr noundef nonnull align 16 dereferenceable(16) %14)
  %15 = load float, ptr %call7, align 4
  %16 = load ptr, ptr %q2.addr, align 8
  %call8 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getYEv(ptr noundef nonnull align 16 dereferenceable(16) %16)
  %17 = load float, ptr %call8, align 4
  %neg = fneg float %15
  %18 = call float @llvm.fmuladd.f32(float %neg, float %17, float %13)
  store float %18, ptr %ref.tmp, align 4
  %19 = load ptr, ptr %q1.addr, align 8
  %call10 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK12b3Quaternion4getWEv(ptr noundef nonnull align 16 dereferenceable(16) %19)
  %20 = load float, ptr %call10, align 4
  %21 = load ptr, ptr %q2.addr, align 8
  %call11 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getYEv(ptr noundef nonnull align 16 dereferenceable(16) %21)
  %22 = load float, ptr %call11, align 4
  %23 = load ptr, ptr %q1.addr, align 8
  %call12 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getYEv(ptr noundef nonnull align 16 dereferenceable(16) %23)
  %24 = load float, ptr %call12, align 4
  %25 = load ptr, ptr %q2.addr, align 8
  %call13 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK12b3Quaternion4getWEv(ptr noundef nonnull align 16 dereferenceable(16) %25)
  %26 = load float, ptr %call13, align 4
  %mul14 = fmul float %24, %26
  %27 = call float @llvm.fmuladd.f32(float %20, float %22, float %mul14)
  %28 = load ptr, ptr %q1.addr, align 8
  %call15 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getZEv(ptr noundef nonnull align 16 dereferenceable(16) %28)
  %29 = load float, ptr %call15, align 4
  %30 = load ptr, ptr %q2.addr, align 8
  %call16 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getXEv(ptr noundef nonnull align 16 dereferenceable(16) %30)
  %31 = load float, ptr %call16, align 4
  %32 = call float @llvm.fmuladd.f32(float %29, float %31, float %27)
  %33 = load ptr, ptr %q1.addr, align 8
  %call17 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getXEv(ptr noundef nonnull align 16 dereferenceable(16) %33)
  %34 = load float, ptr %call17, align 4
  %35 = load ptr, ptr %q2.addr, align 8
  %call18 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getZEv(ptr noundef nonnull align 16 dereferenceable(16) %35)
  %36 = load float, ptr %call18, align 4
  %neg19 = fneg float %34
  %37 = call float @llvm.fmuladd.f32(float %neg19, float %36, float %32)
  store float %37, ptr %ref.tmp9, align 4
  %38 = load ptr, ptr %q1.addr, align 8
  %call21 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK12b3Quaternion4getWEv(ptr noundef nonnull align 16 dereferenceable(16) %38)
  %39 = load float, ptr %call21, align 4
  %40 = load ptr, ptr %q2.addr, align 8
  %call22 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getZEv(ptr noundef nonnull align 16 dereferenceable(16) %40)
  %41 = load float, ptr %call22, align 4
  %42 = load ptr, ptr %q1.addr, align 8
  %call23 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getZEv(ptr noundef nonnull align 16 dereferenceable(16) %42)
  %43 = load float, ptr %call23, align 4
  %44 = load ptr, ptr %q2.addr, align 8
  %call24 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK12b3Quaternion4getWEv(ptr noundef nonnull align 16 dereferenceable(16) %44)
  %45 = load float, ptr %call24, align 4
  %mul25 = fmul float %43, %45
  %46 = call float @llvm.fmuladd.f32(float %39, float %41, float %mul25)
  %47 = load ptr, ptr %q1.addr, align 8
  %call26 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getXEv(ptr noundef nonnull align 16 dereferenceable(16) %47)
  %48 = load float, ptr %call26, align 4
  %49 = load ptr, ptr %q2.addr, align 8
  %call27 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getYEv(ptr noundef nonnull align 16 dereferenceable(16) %49)
  %50 = load float, ptr %call27, align 4
  %51 = call float @llvm.fmuladd.f32(float %48, float %50, float %46)
  %52 = load ptr, ptr %q1.addr, align 8
  %call28 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getYEv(ptr noundef nonnull align 16 dereferenceable(16) %52)
  %53 = load float, ptr %call28, align 4
  %54 = load ptr, ptr %q2.addr, align 8
  %call29 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getXEv(ptr noundef nonnull align 16 dereferenceable(16) %54)
  %55 = load float, ptr %call29, align 4
  %neg30 = fneg float %53
  %56 = call float @llvm.fmuladd.f32(float %neg30, float %55, float %51)
  store float %56, ptr %ref.tmp20, align 4
  %57 = load ptr, ptr %q1.addr, align 8
  %call32 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK12b3Quaternion4getWEv(ptr noundef nonnull align 16 dereferenceable(16) %57)
  %58 = load float, ptr %call32, align 4
  %59 = load ptr, ptr %q2.addr, align 8
  %call33 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK12b3Quaternion4getWEv(ptr noundef nonnull align 16 dereferenceable(16) %59)
  %60 = load float, ptr %call33, align 4
  %61 = load ptr, ptr %q1.addr, align 8
  %call34 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getXEv(ptr noundef nonnull align 16 dereferenceable(16) %61)
  %62 = load float, ptr %call34, align 4
  %63 = load ptr, ptr %q2.addr, align 8
  %call35 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getXEv(ptr noundef nonnull align 16 dereferenceable(16) %63)
  %64 = load float, ptr %call35, align 4
  %mul36 = fmul float %62, %64
  %neg37 = fneg float %mul36
  %65 = call float @llvm.fmuladd.f32(float %58, float %60, float %neg37)
  %66 = load ptr, ptr %q1.addr, align 8
  %call38 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getYEv(ptr noundef nonnull align 16 dereferenceable(16) %66)
  %67 = load float, ptr %call38, align 4
  %68 = load ptr, ptr %q2.addr, align 8
  %call39 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getYEv(ptr noundef nonnull align 16 dereferenceable(16) %68)
  %69 = load float, ptr %call39, align 4
  %neg40 = fneg float %67
  %70 = call float @llvm.fmuladd.f32(float %neg40, float %69, float %65)
  %71 = load ptr, ptr %q1.addr, align 8
  %call41 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getZEv(ptr noundef nonnull align 16 dereferenceable(16) %71)
  %72 = load float, ptr %call41, align 4
  %73 = load ptr, ptr %q2.addr, align 8
  %call42 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getZEv(ptr noundef nonnull align 16 dereferenceable(16) %73)
  %74 = load float, ptr %call42, align 4
  %neg43 = fneg float %72
  %75 = call float @llvm.fmuladd.f32(float %neg43, float %74, float %70)
  store float %75, ptr %ref.tmp31, align 4
  call void @_ZN12b3QuaternionC2ERKfS1_S1_S1_(ptr noundef nonnull align 16 dereferenceable(16) %retval, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp9, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp20, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp31)
  %coerce.dive = getelementptr inbounds %class.b3Quaternion, ptr %retval, i32 0, i32 0
  %coerce.dive44 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive, i32 0, i32 0
  %coerce.dive45 = getelementptr inbounds %union.anon.3, ptr %coerce.dive44, i32 0, i32 0
  %76 = load { <2 x float>, <2 x float> }, ptr %coerce.dive45, align 16
  ret { <2 x float>, <2 x float> } %76
}

; Function Attrs: mustprogress uwtable
define dso_local void @_Z26computeContactSphereConvexiiiiiPK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataPK9b3Vector3PKiPK9b3GpuFaceP10b3Contact4Rii(i32 noundef %pairIndex, i32 noundef %bodyIndexA, i32 noundef %bodyIndexB, i32 noundef %collidableIndexA, i32 noundef %collidableIndexB, ptr noundef %rigidBodies, ptr noundef %collidables, ptr noundef %convexShapes, ptr noundef %convexVertices, ptr noundef %convexIndices, ptr noundef %faces, ptr noundef %globalContactsOut, ptr noundef nonnull align 4 dereferenceable(4) %nGlobalContactsOut, i32 noundef %maxContactCapacity) #2 {
entry:
  %pairIndex.addr = alloca i32, align 4
  %bodyIndexA.addr = alloca i32, align 4
  %bodyIndexB.addr = alloca i32, align 4
  %collidableIndexA.addr = alloca i32, align 4
  %collidableIndexB.addr = alloca i32, align 4
  %rigidBodies.addr = alloca ptr, align 8
  %collidables.addr = alloca ptr, align 8
  %convexShapes.addr = alloca ptr, align 8
  %convexVertices.addr = alloca ptr, align 8
  %convexIndices.addr = alloca ptr, align 8
  %faces.addr = alloca ptr, align 8
  %globalContactsOut.addr = alloca ptr, align 8
  %nGlobalContactsOut.addr = alloca ptr, align 8
  %maxContactCapacity.addr = alloca i32, align 4
  %radius = alloca float, align 4
  %spherePos1 = alloca %class.b3Vector3, align 16
  %sphereOrn = alloca %class.b3Quaternion, align 16
  %pos = alloca %class.b3Vector3, align 16
  %quat = alloca %class.b3Quaternion, align 16
  %tr = alloca %class.b3Transform, align 16
  %trInv = alloca %class.b3Transform, align 16
  %spherePos = alloca %class.b3Vector3, align 16
  %collidableIndex = alloca i32, align 4
  %shapeIndex = alloca i32, align 4
  %numFaces = alloca i32, align 4
  %closestPnt = alloca %class.b3Vector3, align 16
  %minDist = alloca float, align 4
  %bCollide = alloca i8, align 1
  %region = alloca i32, align 4
  %localHitNormal = alloca %class.b3Vector3, align 16
  %f = alloca i32, align 4
  %face = alloca %struct.b3GpuFace, align 16
  %planeEqn = alloca %class.b3Vector3, align 16
  %localPlaneNormal = alloca %class.b3Vector3, align 16
  %n1 = alloca %class.b3Vector3, align 16
  %pntReturn = alloca %class.b3Vector3, align 16
  %dist = alloca float, align 4
  %out = alloca %class.b3Vector3, align 16
  %isInPoly = alloca i8, align 1
  %tmp = alloca %class.b3Vector3, align 16
  %l2 = alloca float, align 4
  %ref.tmp = alloca %class.b3Vector3, align 16
  %normalOnSurfaceB1 = alloca %class.b3Vector3, align 16
  %pOnB1 = alloca %class.b3Vector3, align 16
  %actualDepth = alloca float, align 4
  %dstIdx = alloca i32, align 4
  %c = alloca ptr, align 8
  %numPoints = alloca i32, align 4
  store i32 %pairIndex, ptr %pairIndex.addr, align 4
  store i32 %bodyIndexA, ptr %bodyIndexA.addr, align 4
  store i32 %bodyIndexB, ptr %bodyIndexB.addr, align 4
  store i32 %collidableIndexA, ptr %collidableIndexA.addr, align 4
  store i32 %collidableIndexB, ptr %collidableIndexB.addr, align 4
  store ptr %rigidBodies, ptr %rigidBodies.addr, align 8
  store ptr %collidables, ptr %collidables.addr, align 8
  store ptr %convexShapes, ptr %convexShapes.addr, align 8
  store ptr %convexVertices, ptr %convexVertices.addr, align 8
  store ptr %convexIndices, ptr %convexIndices.addr, align 8
  store ptr %faces, ptr %faces.addr, align 8
  store ptr %globalContactsOut, ptr %globalContactsOut.addr, align 8
  store ptr %nGlobalContactsOut, ptr %nGlobalContactsOut.addr, align 8
  store i32 %maxContactCapacity, ptr %maxContactCapacity.addr, align 4
  %0 = load ptr, ptr %collidables.addr, align 8
  %1 = load i32, ptr %collidableIndexA.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3Collidable, ptr %0, i64 %idxprom
  %2 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx, i32 0, i32 1
  %3 = load float, ptr %2, align 4
  store float %3, ptr %radius, align 4
  %4 = load ptr, ptr %rigidBodies.addr, align 8
  %5 = load i32, ptr %bodyIndexA.addr, align 4
  %idxprom1 = sext i32 %5 to i64
  %arrayidx2 = getelementptr inbounds %struct.b3RigidBodyData, ptr %4, i64 %idxprom1
  %m_pos = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx2, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %spherePos1, ptr align 16 %m_pos, i64 16, i1 false)
  %6 = load ptr, ptr %rigidBodies.addr, align 8
  %7 = load i32, ptr %bodyIndexA.addr, align 4
  %idxprom3 = sext i32 %7 to i64
  %arrayidx4 = getelementptr inbounds %struct.b3RigidBodyData, ptr %6, i64 %idxprom3
  %m_quat = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx4, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %sphereOrn, ptr align 16 %m_quat, i64 16, i1 false)
  %8 = load ptr, ptr %rigidBodies.addr, align 8
  %9 = load i32, ptr %bodyIndexB.addr, align 4
  %idxprom5 = sext i32 %9 to i64
  %arrayidx6 = getelementptr inbounds %struct.b3RigidBodyData, ptr %8, i64 %idxprom5
  %m_pos7 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx6, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %pos, ptr align 16 %m_pos7, i64 16, i1 false)
  %10 = load ptr, ptr %rigidBodies.addr, align 8
  %11 = load i32, ptr %bodyIndexB.addr, align 4
  %idxprom8 = sext i32 %11 to i64
  %arrayidx9 = getelementptr inbounds %struct.b3RigidBodyData, ptr %10, i64 %idxprom8
  %m_quat10 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx9, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %quat, ptr align 16 %m_quat10, i64 16, i1 false)
  call void @_ZN11b3TransformC2Ev(ptr noundef nonnull align 16 dereferenceable(64) %tr)
  call void @_ZN11b3Transform11setIdentityEv(ptr noundef nonnull align 16 dereferenceable(64) %tr)
  call void @_ZN11b3Transform9setOriginERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %tr, ptr noundef nonnull align 16 dereferenceable(16) %pos)
  call void @_ZN11b3Transform11setRotationERK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(64) %tr, ptr noundef nonnull align 16 dereferenceable(16) %quat)
  call void @_ZNK11b3Transform7inverseEv(ptr sret(%class.b3Transform) align 16 %trInv, ptr noundef nonnull align 16 dereferenceable(64) %tr)
  %call = call { <2 x float>, <2 x float> } @_ZNK11b3TransformclERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %trInv, ptr noundef nonnull align 16 dereferenceable(16) %spherePos1)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %spherePos, i32 0, i32 0
  %coerce.dive11 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %12 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive11, i32 0, i32 0
  %13 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %13, ptr %12, align 16
  %14 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive11, i32 0, i32 1
  %15 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %15, ptr %14, align 8
  %16 = load ptr, ptr %rigidBodies.addr, align 8
  %17 = load i32, ptr %bodyIndexB.addr, align 4
  %idxprom12 = sext i32 %17 to i64
  %arrayidx13 = getelementptr inbounds %struct.b3RigidBodyData, ptr %16, i64 %idxprom12
  %m_collidableIdx = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx13, i32 0, i32 4
  %18 = load i32, ptr %m_collidableIdx, align 16
  store i32 %18, ptr %collidableIndex, align 4
  %19 = load ptr, ptr %collidables.addr, align 8
  %20 = load i32, ptr %collidableIndex, align 4
  %idxprom14 = sext i32 %20 to i64
  %arrayidx15 = getelementptr inbounds %struct.b3Collidable, ptr %19, i64 %idxprom14
  %21 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx15, i32 0, i32 3
  %22 = load i32, ptr %21, align 4
  store i32 %22, ptr %shapeIndex, align 4
  %23 = load ptr, ptr %convexShapes.addr, align 8
  %24 = load i32, ptr %shapeIndex, align 4
  %idxprom16 = sext i32 %24 to i64
  %arrayidx17 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %23, i64 %idxprom16
  %m_numFaces = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %arrayidx17, i32 0, i32 6
  %25 = load i32, ptr %m_numFaces, align 8
  store i32 %25, ptr %numFaces, align 4
  %call18 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %coerce.dive19 = getelementptr inbounds %class.b3Vector3, ptr %closestPnt, i32 0, i32 0
  %coerce.dive20 = getelementptr inbounds %union.anon.1, ptr %coerce.dive19, i32 0, i32 0
  %26 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive20, i32 0, i32 0
  %27 = extractvalue { <2 x float>, <2 x float> } %call18, 0
  store <2 x float> %27, ptr %26, align 16
  %28 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive20, i32 0, i32 1
  %29 = extractvalue { <2 x float>, <2 x float> } %call18, 1
  store <2 x float> %29, ptr %28, align 8
  store float -1.000000e+06, ptr %minDist, align 4
  store i8 1, ptr %bCollide, align 1
  store i32 -1, ptr %region, align 4
  store i32 0, ptr %f, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %30 = load i32, ptr %f, align 4
  %31 = load i32, ptr %numFaces, align 4
  %cmp = icmp slt i32 %30, %31
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %32 = load ptr, ptr %faces.addr, align 8
  %33 = load ptr, ptr %convexShapes.addr, align 8
  %34 = load i32, ptr %shapeIndex, align 4
  %idxprom21 = sext i32 %34 to i64
  %arrayidx22 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %33, i64 %idxprom21
  %m_faceOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %arrayidx22, i32 0, i32 5
  %35 = load i32, ptr %m_faceOffset, align 4
  %36 = load i32, ptr %f, align 4
  %add = add nsw i32 %35, %36
  %idxprom23 = sext i32 %add to i64
  %arrayidx24 = getelementptr inbounds %struct.b3GpuFace, ptr %32, i64 %idxprom23
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %face, ptr align 16 %arrayidx24, i64 32, i1 false)
  %m_plane = getelementptr inbounds %struct.b3GpuFace, ptr %face, i32 0, i32 0
  %37 = getelementptr inbounds %class.b3Vector3, ptr %m_plane, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon.2, ptr %37, i32 0, i32 0
  %38 = load float, ptr %x, align 16
  %m_plane25 = getelementptr inbounds %struct.b3GpuFace, ptr %face, i32 0, i32 0
  %39 = getelementptr inbounds %class.b3Vector3, ptr %m_plane25, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon.2, ptr %39, i32 0, i32 1
  %40 = load float, ptr %y, align 4
  %m_plane26 = getelementptr inbounds %struct.b3GpuFace, ptr %face, i32 0, i32 0
  %41 = getelementptr inbounds %class.b3Vector3, ptr %m_plane26, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon.2, ptr %41, i32 0, i32 2
  %42 = load float, ptr %z, align 8
  %call27 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef %38, float noundef %40, float noundef %42, float noundef 0.000000e+00)
  %coerce.dive28 = getelementptr inbounds %class.b3Vector3, ptr %localPlaneNormal, i32 0, i32 0
  %coerce.dive29 = getelementptr inbounds %union.anon.1, ptr %coerce.dive28, i32 0, i32 0
  %43 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive29, i32 0, i32 0
  %44 = extractvalue { <2 x float>, <2 x float> } %call27, 0
  store <2 x float> %44, ptr %43, align 16
  %45 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive29, i32 0, i32 1
  %46 = extractvalue { <2 x float>, <2 x float> } %call27, 1
  store <2 x float> %46, ptr %45, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %n1, ptr align 16 %localPlaneNormal, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %planeEqn, ptr align 16 %n1, i64 16, i1 false)
  %m_plane30 = getelementptr inbounds %struct.b3GpuFace, ptr %face, i32 0, i32 0
  %47 = getelementptr inbounds %class.b3Vector3, ptr %m_plane30, i32 0, i32 0
  %w = getelementptr inbounds %struct.anon.2, ptr %47, i32 0, i32 3
  %48 = load float, ptr %w, align 4
  %call31 = call noundef ptr @_ZN9b3Vector3cvPfEv(ptr noundef nonnull align 16 dereferenceable(16) %planeEqn)
  %arrayidx32 = getelementptr inbounds float, ptr %call31, i64 3
  store float %48, ptr %arrayidx32, align 4
  %call33 = call noundef float @_Z30signedDistanceFromPointToPlaneRK9b3Vector3S1_PS_(ptr noundef nonnull align 16 dereferenceable(16) %spherePos, ptr noundef nonnull align 16 dereferenceable(16) %planeEqn, ptr noundef %pntReturn)
  store float %call33, ptr %dist, align 4
  %49 = load float, ptr %dist, align 4
  %50 = load float, ptr %radius, align 4
  %cmp34 = fcmp ogt float %49, %50
  br i1 %cmp34, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  store i8 0, ptr %bCollide, align 1
  br label %for.end

if.end:                                           ; preds = %for.body
  %51 = load float, ptr %dist, align 4
  %cmp35 = fcmp ogt float %51, 0.000000e+00
  br i1 %cmp35, label %if.then36, label %if.else62

if.then36:                                        ; preds = %if.end
  %52 = load ptr, ptr %convexVertices.addr, align 8
  %53 = load ptr, ptr %convexShapes.addr, align 8
  %54 = load i32, ptr %shapeIndex, align 4
  %idxprom37 = sext i32 %54 to i64
  %arrayidx38 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %53, i64 %idxprom37
  %m_vertexOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %arrayidx38, i32 0, i32 8
  %55 = load i32, ptr %m_vertexOffset, align 16
  %idxprom39 = sext i32 %55 to i64
  %arrayidx40 = getelementptr inbounds %class.b3Vector3, ptr %52, i64 %idxprom39
  %56 = load ptr, ptr %convexIndices.addr, align 8
  %call41 = call noundef zeroext i1 @_Z16IsPointInPolygonRK9b3Vector3PK9b3GpuFacePS0_PKiPS_(ptr noundef nonnull align 16 dereferenceable(16) %spherePos, ptr noundef %face, ptr noundef %arrayidx40, ptr noundef %56, ptr noundef %out)
  %frombool = zext i1 %call41 to i8
  store i8 %frombool, ptr %isInPoly, align 1
  %57 = load i8, ptr %isInPoly, align 1
  %tobool = trunc i8 %57 to i1
  br i1 %tobool, label %if.then42, label %if.else

if.then42:                                        ; preds = %if.then36
  %58 = load float, ptr %dist, align 4
  %59 = load float, ptr %minDist, align 4
  %cmp43 = fcmp ogt float %58, %59
  br i1 %cmp43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %if.then42
  %60 = load float, ptr %dist, align 4
  store float %60, ptr %minDist, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %closestPnt, ptr align 16 %pntReturn, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %localHitNormal, ptr align 16 %planeEqn, i64 16, i1 false)
  store i32 1, ptr %region, align 4
  br label %if.end45

if.end45:                                         ; preds = %if.then44, %if.then42
  br label %if.end61

if.else:                                          ; preds = %if.then36
  %call46 = call { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %spherePos, ptr noundef nonnull align 16 dereferenceable(16) %out)
  %coerce.dive47 = getelementptr inbounds %class.b3Vector3, ptr %tmp, i32 0, i32 0
  %coerce.dive48 = getelementptr inbounds %union.anon.1, ptr %coerce.dive47, i32 0, i32 0
  %61 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive48, i32 0, i32 0
  %62 = extractvalue { <2 x float>, <2 x float> } %call46, 0
  store <2 x float> %62, ptr %61, align 16
  %63 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive48, i32 0, i32 1
  %64 = extractvalue { <2 x float>, <2 x float> } %call46, 1
  store <2 x float> %64, ptr %63, align 8
  %call49 = call noundef float @_ZNK9b3Vector37length2Ev(ptr noundef nonnull align 16 dereferenceable(16) %tmp)
  store float %call49, ptr %l2, align 4
  %65 = load float, ptr %l2, align 4
  %66 = load float, ptr %radius, align 4
  %67 = load float, ptr %radius, align 4
  %mul = fmul float %66, %67
  %cmp50 = fcmp olt float %65, %mul
  br i1 %cmp50, label %if.then51, label %if.else59

if.then51:                                        ; preds = %if.else
  %68 = load float, ptr %l2, align 4
  %call52 = call noundef float @_Z6b3Sqrtf(float noundef %68)
  store float %call52, ptr %dist, align 4
  %69 = load float, ptr %dist, align 4
  %70 = load float, ptr %minDist, align 4
  %cmp53 = fcmp ogt float %69, %70
  br i1 %cmp53, label %if.then54, label %if.end58

if.then54:                                        ; preds = %if.then51
  %71 = load float, ptr %dist, align 4
  store float %71, ptr %minDist, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %closestPnt, ptr align 16 %out, i64 16, i1 false)
  %call55 = call { <2 x float>, <2 x float> } @_ZdvRK9b3Vector3RKf(ptr noundef nonnull align 16 dereferenceable(16) %tmp, ptr noundef nonnull align 4 dereferenceable(4) %dist)
  %coerce.dive56 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive57 = getelementptr inbounds %union.anon.1, ptr %coerce.dive56, i32 0, i32 0
  %72 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive57, i32 0, i32 0
  %73 = extractvalue { <2 x float>, <2 x float> } %call55, 0
  store <2 x float> %73, ptr %72, align 16
  %74 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive57, i32 0, i32 1
  %75 = extractvalue { <2 x float>, <2 x float> } %call55, 1
  store <2 x float> %75, ptr %74, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %localHitNormal, ptr align 16 %ref.tmp, i64 16, i1 false)
  store i32 2, ptr %region, align 4
  br label %if.end58

if.end58:                                         ; preds = %if.then54, %if.then51
  br label %if.end60

if.else59:                                        ; preds = %if.else
  store i8 0, ptr %bCollide, align 1
  br label %for.end

if.end60:                                         ; preds = %if.end58
  br label %if.end61

if.end61:                                         ; preds = %if.end60, %if.end45
  br label %if.end66

if.else62:                                        ; preds = %if.end
  %76 = load float, ptr %dist, align 4
  %77 = load float, ptr %minDist, align 4
  %cmp63 = fcmp ogt float %76, %77
  br i1 %cmp63, label %if.then64, label %if.end65

if.then64:                                        ; preds = %if.else62
  %78 = load float, ptr %dist, align 4
  store float %78, ptr %minDist, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %closestPnt, ptr align 16 %pntReturn, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %localHitNormal, ptr align 16 %planeEqn, i64 16, i1 false)
  store i32 3, ptr %region, align 4
  br label %if.end65

if.end65:                                         ; preds = %if.then64, %if.else62
  br label %if.end66

if.end66:                                         ; preds = %if.end65, %if.end61
  br label %for.inc

for.inc:                                          ; preds = %if.end66
  %79 = load i32, ptr %f, align 4
  %inc = add nsw i32 %79, 1
  store i32 %inc, ptr %f, align 4
  br label %for.cond, !llvm.loop !66

for.end:                                          ; preds = %if.else59, %if.then, %for.cond
  %80 = load i32, ptr @_ZZ26computeContactSphereConvexiiiiiPK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataPK9b3Vector3PKiPK9b3GpuFaceP10b3Contact4RiiE9numChecks, align 4
  %inc67 = add nsw i32 %80, 1
  store i32 %inc67, ptr @_ZZ26computeContactSphereConvexiiiiiPK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataPK9b3Vector3PKiPK9b3GpuFaceP10b3Contact4RiiE9numChecks, align 4
  %81 = load i8, ptr %bCollide, align 1
  %tobool68 = trunc i8 %81 to i1
  br i1 %tobool68, label %land.lhs.true, label %if.end105

land.lhs.true:                                    ; preds = %for.end
  %82 = load float, ptr %minDist, align 4
  %cmp69 = fcmp ogt float %82, -1.000000e+04
  br i1 %cmp69, label %if.then70, label %if.end105

if.then70:                                        ; preds = %land.lhs.true
  %call71 = call noundef nonnull align 16 dereferenceable(48) ptr @_ZN11b3Transform8getBasisEv(ptr noundef nonnull align 16 dereferenceable(64) %tr)
  %call72 = call { <2 x float>, <2 x float> } @_ZmlRK11b3Matrix3x3RK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(48) %call71, ptr noundef nonnull align 16 dereferenceable(16) %localHitNormal)
  %coerce.dive73 = getelementptr inbounds %class.b3Vector3, ptr %normalOnSurfaceB1, i32 0, i32 0
  %coerce.dive74 = getelementptr inbounds %union.anon.1, ptr %coerce.dive73, i32 0, i32 0
  %83 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive74, i32 0, i32 0
  %84 = extractvalue { <2 x float>, <2 x float> } %call72, 0
  store <2 x float> %84, ptr %83, align 16
  %85 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive74, i32 0, i32 1
  %86 = extractvalue { <2 x float>, <2 x float> } %call72, 1
  store <2 x float> %86, ptr %85, align 8
  %call75 = call { <2 x float>, <2 x float> } @_ZNK11b3TransformclERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %tr, ptr noundef nonnull align 16 dereferenceable(16) %closestPnt)
  %coerce.dive76 = getelementptr inbounds %class.b3Vector3, ptr %pOnB1, i32 0, i32 0
  %coerce.dive77 = getelementptr inbounds %union.anon.1, ptr %coerce.dive76, i32 0, i32 0
  %87 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive77, i32 0, i32 0
  %88 = extractvalue { <2 x float>, <2 x float> } %call75, 0
  store <2 x float> %88, ptr %87, align 16
  %89 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive77, i32 0, i32 1
  %90 = extractvalue { <2 x float>, <2 x float> } %call75, 1
  store <2 x float> %90, ptr %89, align 8
  %91 = load float, ptr %minDist, align 4
  %92 = load float, ptr %radius, align 4
  %sub = fsub float %91, %92
  store float %sub, ptr %actualDepth, align 4
  %93 = load float, ptr %actualDepth, align 4
  %cmp78 = fcmp olt float %93, 0.000000e+00
  br i1 %cmp78, label %if.then79, label %if.end104

if.then79:                                        ; preds = %if.then70
  %94 = load float, ptr %actualDepth, align 4
  %call80 = call noundef ptr @_ZN9b3Vector3cvPfEv(ptr noundef nonnull align 16 dereferenceable(16) %pOnB1)
  %arrayidx81 = getelementptr inbounds float, ptr %call80, i64 3
  store float %94, ptr %arrayidx81, align 4
  %95 = load ptr, ptr %nGlobalContactsOut.addr, align 8
  %96 = load i32, ptr %95, align 4
  %97 = load i32, ptr %maxContactCapacity.addr, align 4
  %cmp82 = icmp slt i32 %96, %97
  br i1 %cmp82, label %if.then83, label %if.end103

if.then83:                                        ; preds = %if.then79
  %98 = load ptr, ptr %nGlobalContactsOut.addr, align 8
  %99 = load i32, ptr %98, align 4
  store i32 %99, ptr %dstIdx, align 4
  %100 = load ptr, ptr %nGlobalContactsOut.addr, align 8
  %101 = load i32, ptr %100, align 4
  %inc84 = add nsw i32 %101, 1
  store i32 %inc84, ptr %100, align 4
  %102 = load ptr, ptr %globalContactsOut.addr, align 8
  %103 = load i32, ptr %dstIdx, align 4
  %idxprom85 = sext i32 %103 to i64
  %arrayidx86 = getelementptr inbounds %struct.b3Contact4, ptr %102, i64 %idxprom85
  store ptr %arrayidx86, ptr %c, align 8
  %104 = load ptr, ptr %c, align 8
  %m_worldNormalOnB = getelementptr inbounds %struct.b3Contact4Data, ptr %104, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %m_worldNormalOnB, ptr align 16 %normalOnSurfaceB1, i64 16, i1 false)
  %105 = load ptr, ptr %c, align 8
  call void @_ZN10b3Contact416setFrictionCoeffEf(ptr noundef nonnull align 16 dereferenceable(112) %105, float noundef 0x3FE6666660000000)
  %106 = load ptr, ptr %c, align 8
  call void @_ZN10b3Contact420setRestituitionCoeffEf(ptr noundef nonnull align 16 dereferenceable(112) %106, float noundef 0.000000e+00)
  %107 = load i32, ptr %pairIndex.addr, align 4
  %108 = load ptr, ptr %c, align 8
  %m_batchIdx = getelementptr inbounds %struct.b3Contact4Data, ptr %108, i32 0, i32 4
  store i32 %107, ptr %m_batchIdx, align 4
  %109 = load ptr, ptr %rigidBodies.addr, align 8
  %110 = load i32, ptr %bodyIndexA.addr, align 4
  %idxprom87 = sext i32 %110 to i64
  %arrayidx88 = getelementptr inbounds %struct.b3RigidBodyData, ptr %109, i64 %idxprom87
  %m_invMass = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx88, i32 0, i32 5
  %111 = load float, ptr %m_invMass, align 4
  %cmp89 = fcmp oeq float %111, 0.000000e+00
  br i1 %cmp89, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then83
  %112 = load i32, ptr %bodyIndexA.addr, align 4
  %sub90 = sub nsw i32 0, %112
  br label %cond.end

cond.false:                                       ; preds = %if.then83
  %113 = load i32, ptr %bodyIndexA.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %sub90, %cond.true ], [ %113, %cond.false ]
  %114 = load ptr, ptr %c, align 8
  %m_bodyAPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %114, i32 0, i32 5
  store i32 %cond, ptr %m_bodyAPtrAndSignBit, align 8
  %115 = load ptr, ptr %rigidBodies.addr, align 8
  %116 = load i32, ptr %bodyIndexB.addr, align 4
  %idxprom91 = sext i32 %116 to i64
  %arrayidx92 = getelementptr inbounds %struct.b3RigidBodyData, ptr %115, i64 %idxprom91
  %m_invMass93 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx92, i32 0, i32 5
  %117 = load float, ptr %m_invMass93, align 4
  %cmp94 = fcmp oeq float %117, 0.000000e+00
  br i1 %cmp94, label %cond.true95, label %cond.false97

cond.true95:                                      ; preds = %cond.end
  %118 = load i32, ptr %bodyIndexB.addr, align 4
  %sub96 = sub nsw i32 0, %118
  br label %cond.end98

cond.false97:                                     ; preds = %cond.end
  %119 = load i32, ptr %bodyIndexB.addr, align 4
  br label %cond.end98

cond.end98:                                       ; preds = %cond.false97, %cond.true95
  %cond99 = phi i32 [ %sub96, %cond.true95 ], [ %119, %cond.false97 ]
  %120 = load ptr, ptr %c, align 8
  %m_bodyBPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %120, i32 0, i32 6
  store i32 %cond99, ptr %m_bodyBPtrAndSignBit, align 4
  %121 = load ptr, ptr %c, align 8
  %m_worldPosB = getelementptr inbounds %struct.b3Contact4Data, ptr %121, i32 0, i32 0
  %arrayidx100 = getelementptr inbounds [4 x %class.b3Vector3], ptr %m_worldPosB, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx100, ptr align 16 %pOnB1, i64 16, i1 false)
  store i32 1, ptr %numPoints, align 4
  %122 = load i32, ptr %numPoints, align 4
  %conv = sitofp i32 %122 to float
  %123 = load ptr, ptr %c, align 8
  %m_worldNormalOnB101 = getelementptr inbounds %struct.b3Contact4Data, ptr %123, i32 0, i32 1
  %124 = getelementptr inbounds %class.b3Vector3, ptr %m_worldNormalOnB101, i32 0, i32 0
  %w102 = getelementptr inbounds %struct.anon.2, ptr %124, i32 0, i32 3
  store float %conv, ptr %w102, align 4
  br label %if.end103

if.end103:                                        ; preds = %cond.end98, %if.then79
  br label %if.end104

if.end104:                                        ; preds = %if.end103, %if.then70
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %land.lhs.true, %for.end
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_Z16IsPointInPolygonRK9b3Vector3PK9b3GpuFacePS0_PKiPS_(ptr noundef nonnull align 16 dereferenceable(16) %p, ptr noundef %face, ptr noundef %baseVertex, ptr noundef %convexIndices, ptr noundef %out) #2 comdat {
entry:
  %retval = alloca i1, align 1
  %p.addr = alloca ptr, align 8
  %face.addr = alloca ptr, align 8
  %baseVertex.addr = alloca ptr, align 8
  %convexIndices.addr = alloca ptr, align 8
  %out.addr = alloca ptr, align 8
  %a = alloca %class.b3Vector3, align 16
  %b = alloca %class.b3Vector3, align 16
  %ab = alloca %class.b3Vector3, align 16
  %ap = alloca %class.b3Vector3, align 16
  %v = alloca %class.b3Vector3, align 16
  %plane = alloca %class.b3Vector3, align 16
  %v0 = alloca %class.b3Vector3, align 16
  %i = alloca i32, align 4
  %vi = alloca %class.b3Vector3, align 16
  %ref.tmp = alloca %class.b3Vector3, align 16
  %ref.tmp18 = alloca %class.b3Vector3, align 16
  %ref.tmp22 = alloca %class.b3Vector3, align 16
  %ab_m2 = alloca float, align 4
  %rt = alloca float, align 4
  %s = alloca float, align 4
  store ptr %p, ptr %p.addr, align 8
  store ptr %face, ptr %face.addr, align 8
  store ptr %baseVertex, ptr %baseVertex.addr, align 8
  store ptr %convexIndices, ptr %convexIndices.addr, align 8
  store ptr %out, ptr %out.addr, align 8
  %0 = load ptr, ptr %face.addr, align 8
  %m_plane = getelementptr inbounds %struct.b3GpuFace, ptr %0, i32 0, i32 0
  %1 = getelementptr inbounds %class.b3Vector3, ptr %m_plane, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon.2, ptr %1, i32 0, i32 0
  %2 = load float, ptr %x, align 16
  %3 = load ptr, ptr %face.addr, align 8
  %m_plane1 = getelementptr inbounds %struct.b3GpuFace, ptr %3, i32 0, i32 0
  %4 = getelementptr inbounds %class.b3Vector3, ptr %m_plane1, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon.2, ptr %4, i32 0, i32 1
  %5 = load float, ptr %y, align 4
  %6 = load ptr, ptr %face.addr, align 8
  %m_plane2 = getelementptr inbounds %struct.b3GpuFace, ptr %6, i32 0, i32 0
  %7 = getelementptr inbounds %class.b3Vector3, ptr %m_plane2, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon.2, ptr %7, i32 0, i32 2
  %8 = load float, ptr %z, align 8
  %call = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef %2, float noundef %5, float noundef %8, float noundef 0.000000e+00)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %plane, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %9 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive3, i32 0, i32 0
  %10 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %10, ptr %9, align 16
  %11 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive3, i32 0, i32 1
  %12 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %12, ptr %11, align 8
  %13 = load ptr, ptr %face.addr, align 8
  %m_numIndices = getelementptr inbounds %struct.b3GpuFace, ptr %13, i32 0, i32 2
  %14 = load i32, ptr %m_numIndices, align 4
  %cmp = icmp slt i32 %14, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %15 = load ptr, ptr %baseVertex.addr, align 8
  %16 = load ptr, ptr %convexIndices.addr, align 8
  %17 = load ptr, ptr %face.addr, align 8
  %m_indexOffset = getelementptr inbounds %struct.b3GpuFace, ptr %17, i32 0, i32 1
  %18 = load i32, ptr %m_indexOffset, align 16
  %19 = load ptr, ptr %face.addr, align 8
  %m_numIndices4 = getelementptr inbounds %struct.b3GpuFace, ptr %19, i32 0, i32 2
  %20 = load i32, ptr %m_numIndices4, align 4
  %add = add nsw i32 %18, %20
  %sub = sub nsw i32 %add, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds i32, ptr %16, i64 %idxprom
  %21 = load i32, ptr %arrayidx, align 4
  %idxprom5 = sext i32 %21 to i64
  %arrayidx6 = getelementptr inbounds %class.b3Vector3, ptr %15, i64 %idxprom5
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %v0, ptr align 16 %arrayidx6, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %b, ptr align 16 %v0, i64 16, i1 false)
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %22 = load i32, ptr %i, align 4
  %23 = load ptr, ptr %face.addr, align 8
  %m_numIndices7 = getelementptr inbounds %struct.b3GpuFace, ptr %23, i32 0, i32 2
  %24 = load i32, ptr %m_numIndices7, align 4
  %cmp8 = icmp ne i32 %22, %24
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %a, ptr align 16 %b, i64 16, i1 false)
  %25 = load ptr, ptr %baseVertex.addr, align 8
  %26 = load ptr, ptr %convexIndices.addr, align 8
  %27 = load ptr, ptr %face.addr, align 8
  %m_indexOffset9 = getelementptr inbounds %struct.b3GpuFace, ptr %27, i32 0, i32 1
  %28 = load i32, ptr %m_indexOffset9, align 16
  %29 = load i32, ptr %i, align 4
  %add10 = add i32 %28, %29
  %idxprom11 = zext i32 %add10 to i64
  %arrayidx12 = getelementptr inbounds i32, ptr %26, i64 %idxprom11
  %30 = load i32, ptr %arrayidx12, align 4
  %idxprom13 = sext i32 %30 to i64
  %arrayidx14 = getelementptr inbounds %class.b3Vector3, ptr %25, i64 %idxprom13
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %vi, ptr align 16 %arrayidx14, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %b, ptr align 16 %vi, i64 16, i1 false)
  %call15 = call { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %b, ptr noundef nonnull align 16 dereferenceable(16) %a)
  %coerce.dive16 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive17 = getelementptr inbounds %union.anon.1, ptr %coerce.dive16, i32 0, i32 0
  %31 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive17, i32 0, i32 0
  %32 = extractvalue { <2 x float>, <2 x float> } %call15, 0
  store <2 x float> %32, ptr %31, align 16
  %33 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive17, i32 0, i32 1
  %34 = extractvalue { <2 x float>, <2 x float> } %call15, 1
  store <2 x float> %34, ptr %33, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ab, ptr align 16 %ref.tmp, i64 16, i1 false)
  %35 = load ptr, ptr %p.addr, align 8
  %call19 = call { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %35, ptr noundef nonnull align 16 dereferenceable(16) %a)
  %coerce.dive20 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp18, i32 0, i32 0
  %coerce.dive21 = getelementptr inbounds %union.anon.1, ptr %coerce.dive20, i32 0, i32 0
  %36 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive21, i32 0, i32 0
  %37 = extractvalue { <2 x float>, <2 x float> } %call19, 0
  store <2 x float> %37, ptr %36, align 16
  %38 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive21, i32 0, i32 1
  %39 = extractvalue { <2 x float>, <2 x float> } %call19, 1
  store <2 x float> %39, ptr %38, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ap, ptr align 16 %ref.tmp18, i64 16, i1 false)
  %call23 = call { <2 x float>, <2 x float> } @_ZNK9b3Vector35crossERKS_(ptr noundef nonnull align 16 dereferenceable(16) %ab, ptr noundef nonnull align 16 dereferenceable(16) %plane)
  %coerce.dive24 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp22, i32 0, i32 0
  %coerce.dive25 = getelementptr inbounds %union.anon.1, ptr %coerce.dive24, i32 0, i32 0
  %40 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive25, i32 0, i32 0
  %41 = extractvalue { <2 x float>, <2 x float> } %call23, 0
  store <2 x float> %41, ptr %40, align 16
  %42 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive25, i32 0, i32 1
  %43 = extractvalue { <2 x float>, <2 x float> } %call23, 1
  store <2 x float> %43, ptr %42, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %v, ptr align 16 %ref.tmp22, i64 16, i1 false)
  %call26 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %ap, ptr noundef nonnull align 16 dereferenceable(16) %v)
  %cmp27 = fcmp ogt float %call26, 0.000000e+00
  br i1 %cmp27, label %if.then28, label %if.end55

if.then28:                                        ; preds = %for.body
  %call29 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %ab, ptr noundef nonnull align 16 dereferenceable(16) %ab)
  store float %call29, ptr %ab_m2, align 4
  %44 = load float, ptr %ab_m2, align 4
  %cmp30 = fcmp une float %44, 0.000000e+00
  br i1 %cmp30, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then28
  %call31 = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %ab, ptr noundef nonnull align 16 dereferenceable(16) %ap)
  %45 = load float, ptr %ab_m2, align 4
  %div = fdiv float %call31, %45
  br label %cond.end

cond.false:                                       ; preds = %if.then28
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %div, %cond.true ], [ 0.000000e+00, %cond.false ]
  store float %cond, ptr %rt, align 4
  %46 = load float, ptr %rt, align 4
  %cmp32 = fcmp ole float %46, 0.000000e+00
  br i1 %cmp32, label %if.then33, label %if.else

if.then33:                                        ; preds = %cond.end
  %47 = load ptr, ptr %out.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %47, ptr align 16 %a, i64 16, i1 false)
  br label %if.end54

if.else:                                          ; preds = %cond.end
  %48 = load float, ptr %rt, align 4
  %cmp34 = fcmp oge float %48, 1.000000e+00
  br i1 %cmp34, label %if.then35, label %if.else36

if.then35:                                        ; preds = %if.else
  %49 = load ptr, ptr %out.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %49, ptr align 16 %b, i64 16, i1 false)
  br label %if.end53

if.else36:                                        ; preds = %if.else
  %50 = load float, ptr %rt, align 4
  %sub37 = fsub float 1.000000e+00, %50
  store float %sub37, ptr %s, align 4
  %51 = load float, ptr %s, align 4
  %52 = getelementptr inbounds %class.b3Vector3, ptr %a, i32 0, i32 0
  %x38 = getelementptr inbounds %struct.anon.2, ptr %52, i32 0, i32 0
  %53 = load float, ptr %x38, align 16
  %54 = load float, ptr %rt, align 4
  %55 = getelementptr inbounds %class.b3Vector3, ptr %b, i32 0, i32 0
  %x39 = getelementptr inbounds %struct.anon.2, ptr %55, i32 0, i32 0
  %56 = load float, ptr %x39, align 16
  %mul40 = fmul float %54, %56
  %57 = call float @llvm.fmuladd.f32(float %51, float %53, float %mul40)
  %58 = load ptr, ptr %out.addr, align 8
  %arrayidx41 = getelementptr inbounds %class.b3Vector3, ptr %58, i64 0
  %59 = getelementptr inbounds %class.b3Vector3, ptr %arrayidx41, i32 0, i32 0
  %x42 = getelementptr inbounds %struct.anon.2, ptr %59, i32 0, i32 0
  store float %57, ptr %x42, align 16
  %60 = load float, ptr %s, align 4
  %61 = getelementptr inbounds %class.b3Vector3, ptr %a, i32 0, i32 0
  %y43 = getelementptr inbounds %struct.anon.2, ptr %61, i32 0, i32 1
  %62 = load float, ptr %y43, align 4
  %63 = load float, ptr %rt, align 4
  %64 = getelementptr inbounds %class.b3Vector3, ptr %b, i32 0, i32 0
  %y44 = getelementptr inbounds %struct.anon.2, ptr %64, i32 0, i32 1
  %65 = load float, ptr %y44, align 4
  %mul45 = fmul float %63, %65
  %66 = call float @llvm.fmuladd.f32(float %60, float %62, float %mul45)
  %67 = load ptr, ptr %out.addr, align 8
  %arrayidx46 = getelementptr inbounds %class.b3Vector3, ptr %67, i64 0
  %68 = getelementptr inbounds %class.b3Vector3, ptr %arrayidx46, i32 0, i32 0
  %y47 = getelementptr inbounds %struct.anon.2, ptr %68, i32 0, i32 1
  store float %66, ptr %y47, align 4
  %69 = load float, ptr %s, align 4
  %70 = getelementptr inbounds %class.b3Vector3, ptr %a, i32 0, i32 0
  %z48 = getelementptr inbounds %struct.anon.2, ptr %70, i32 0, i32 2
  %71 = load float, ptr %z48, align 8
  %72 = load float, ptr %rt, align 4
  %73 = getelementptr inbounds %class.b3Vector3, ptr %b, i32 0, i32 0
  %z49 = getelementptr inbounds %struct.anon.2, ptr %73, i32 0, i32 2
  %74 = load float, ptr %z49, align 8
  %mul50 = fmul float %72, %74
  %75 = call float @llvm.fmuladd.f32(float %69, float %71, float %mul50)
  %76 = load ptr, ptr %out.addr, align 8
  %arrayidx51 = getelementptr inbounds %class.b3Vector3, ptr %76, i64 0
  %77 = getelementptr inbounds %class.b3Vector3, ptr %arrayidx51, i32 0, i32 0
  %z52 = getelementptr inbounds %struct.anon.2, ptr %77, i32 0, i32 2
  store float %75, ptr %z52, align 8
  br label %if.end53

if.end53:                                         ; preds = %if.else36, %if.then35
  br label %if.end54

if.end54:                                         ; preds = %if.end53, %if.then33
  store i1 false, ptr %retval, align 1
  br label %return

if.end55:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end55
  %78 = load i32, ptr %i, align 4
  %inc = add i32 %78, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !67

for.end:                                          ; preds = %for.cond
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.end54, %if.then
  %79 = load i1, ptr %retval, align 1
  ret i1 %79
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef float @_ZNK9b3Vector37length2Ev(ptr noundef nonnull align 16 dereferenceable(16) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef float @_ZNK9b3Vector33dotERKS_(ptr noundef nonnull align 16 dereferenceable(16) %this1, ptr noundef nonnull align 16 dereferenceable(16) %this1)
  ret float %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef float @_Z6b3Sqrtf(float noundef %y) #3 comdat {
entry:
  %y.addr = alloca float, align 4
  store float %y, ptr %y.addr, align 4
  %0 = load float, ptr %y.addr, align 4
  %call = call float @sqrtf(float noundef %0) #13
  ret float %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_ZdvRK9b3Vector3RKf(ptr noundef nonnull align 16 dereferenceable(16) %v, ptr noundef nonnull align 4 dereferenceable(4) %s) #2 comdat {
entry:
  %retval = alloca %class.b3Vector3, align 16
  %v.addr = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %ref.tmp = alloca float, align 4
  store ptr %v, ptr %v.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %v.addr, align 8
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load float, ptr %1, align 4
  %div = fdiv float 1.000000e+00, %2
  store float %div, ptr %ref.tmp, align 4
  %call = call { <2 x float>, <2 x float> } @_ZmlRK9b3Vector3RKf(ptr noundef nonnull align 16 dereferenceable(16) %0, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive1 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %3 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive1, i32 0, i32 0
  %4 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %4, ptr %3, align 16
  %5 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive1, i32 0, i32 1
  %6 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %6, ptr %5, align 8
  %coerce.dive2 = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %union.anon.1, ptr %coerce.dive2, i32 0, i32 0
  %7 = load { <2 x float>, <2 x float> }, ptr %coerce.dive3, align 16
  ret { <2 x float>, <2 x float> } %7
}

; Function Attrs: mustprogress uwtable
define dso_local noundef i32 @_Z27computeContactConvexConvex2iiiiiRK20b3AlignedObjectArrayI15b3RigidBodyDataERKS_I12b3CollidableERKS_I22b3ConvexPolyhedronDataERKS_I9b3Vector3ESF_RKS_IiERKS_I9b3GpuFaceERS_I10b3Contact4ERiiRKSO_(i32 noundef %pairIndex, i32 noundef %bodyIndexA, i32 noundef %bodyIndexB, i32 noundef %collidableIndexA, i32 noundef %collidableIndexB, ptr noundef nonnull align 8 dereferenceable(25) %rigidBodies, ptr noundef nonnull align 8 dereferenceable(25) %collidables, ptr noundef nonnull align 8 dereferenceable(25) %convexShapes, ptr noundef nonnull align 8 dereferenceable(25) %convexVertices, ptr noundef nonnull align 8 dereferenceable(25) %uniqueEdges, ptr noundef nonnull align 8 dereferenceable(25) %convexIndices, ptr noundef nonnull align 8 dereferenceable(25) %faces, ptr noundef nonnull align 8 dereferenceable(25) %globalContactsOut, ptr noundef nonnull align 4 dereferenceable(4) %nGlobalContactsOut, i32 noundef %maxContactCapacity, ptr noundef nonnull align 8 dereferenceable(25) %oldContacts) #0 {
entry:
  %pairIndex.addr = alloca i32, align 4
  %bodyIndexA.addr = alloca i32, align 4
  %bodyIndexB.addr = alloca i32, align 4
  %collidableIndexA.addr = alloca i32, align 4
  %collidableIndexB.addr = alloca i32, align 4
  %rigidBodies.addr = alloca ptr, align 8
  %collidables.addr = alloca ptr, align 8
  %convexShapes.addr = alloca ptr, align 8
  %convexVertices.addr = alloca ptr, align 8
  %uniqueEdges.addr = alloca ptr, align 8
  %convexIndices.addr = alloca ptr, align 8
  %faces.addr = alloca ptr, align 8
  %globalContactsOut.addr = alloca ptr, align 8
  %nGlobalContactsOut.addr = alloca ptr, align 8
  %maxContactCapacity.addr = alloca i32, align 4
  %oldContacts.addr = alloca ptr, align 8
  %contactIndex = alloca i32, align 4
  %posA = alloca %class.b3Vector3, align 16
  %ornA = alloca %class.b3Quaternion, align 16
  %posB = alloca %class.b3Vector3, align 16
  %ornB = alloca %class.b3Quaternion, align 16
  %hullA = alloca %struct.b3ConvexPolyhedronData, align 16
  %hullB = alloca %struct.b3ConvexPolyhedronData, align 16
  %sepNormalWorldSpace = alloca %class.b3Vector3, align 16
  %colA = alloca %struct.b3Collidable, align 4
  %colB = alloca %struct.b3Collidable, align 4
  %foundSepAxis = alloca i8, align 1
  store i32 %pairIndex, ptr %pairIndex.addr, align 4
  store i32 %bodyIndexA, ptr %bodyIndexA.addr, align 4
  store i32 %bodyIndexB, ptr %bodyIndexB.addr, align 4
  store i32 %collidableIndexA, ptr %collidableIndexA.addr, align 4
  store i32 %collidableIndexB, ptr %collidableIndexB.addr, align 4
  store ptr %rigidBodies, ptr %rigidBodies.addr, align 8
  store ptr %collidables, ptr %collidables.addr, align 8
  store ptr %convexShapes, ptr %convexShapes.addr, align 8
  store ptr %convexVertices, ptr %convexVertices.addr, align 8
  store ptr %uniqueEdges, ptr %uniqueEdges.addr, align 8
  store ptr %convexIndices, ptr %convexIndices.addr, align 8
  store ptr %faces, ptr %faces.addr, align 8
  store ptr %globalContactsOut, ptr %globalContactsOut.addr, align 8
  store ptr %nGlobalContactsOut, ptr %nGlobalContactsOut.addr, align 8
  store i32 %maxContactCapacity, ptr %maxContactCapacity.addr, align 4
  store ptr %oldContacts, ptr %oldContacts.addr, align 8
  store i32 -1, ptr %contactIndex, align 4
  %0 = load ptr, ptr %rigidBodies.addr, align 8
  %1 = load i32, ptr %bodyIndexA.addr, align 4
  %call = call noundef nonnull align 16 dereferenceable(80) ptr @_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %0, i32 noundef %1)
  %m_pos = getelementptr inbounds %struct.b3RigidBodyData, ptr %call, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posA, ptr align 16 %m_pos, i64 16, i1 false)
  %2 = load ptr, ptr %rigidBodies.addr, align 8
  %3 = load i32, ptr %bodyIndexA.addr, align 4
  %call1 = call noundef nonnull align 16 dereferenceable(80) ptr @_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %2, i32 noundef %3)
  %m_quat = getelementptr inbounds %struct.b3RigidBodyData, ptr %call1, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornA, ptr align 16 %m_quat, i64 16, i1 false)
  %4 = load ptr, ptr %rigidBodies.addr, align 8
  %5 = load i32, ptr %bodyIndexB.addr, align 4
  %call2 = call noundef nonnull align 16 dereferenceable(80) ptr @_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %4, i32 noundef %5)
  %m_pos3 = getelementptr inbounds %struct.b3RigidBodyData, ptr %call2, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posB, ptr align 16 %m_pos3, i64 16, i1 false)
  %6 = load ptr, ptr %rigidBodies.addr, align 8
  %7 = load i32, ptr %bodyIndexB.addr, align 4
  %call4 = call noundef nonnull align 16 dereferenceable(80) ptr @_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %6, i32 noundef %7)
  %m_quat5 = getelementptr inbounds %struct.b3RigidBodyData, ptr %call4, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornB, ptr align 16 %m_quat5, i64 16, i1 false)
  %8 = load ptr, ptr %collidables.addr, align 8
  %9 = load i32, ptr %collidableIndexA.addr, align 4
  %call6 = call noundef nonnull align 4 dereferenceable(16) ptr @_ZNK20b3AlignedObjectArrayI12b3CollidableEixEi(ptr noundef nonnull align 8 dereferenceable(25) %8, i32 noundef %9)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %colA, ptr align 4 %call6, i64 16, i1 false)
  %10 = load ptr, ptr %convexShapes.addr, align 8
  %11 = getelementptr inbounds %struct.b3Collidable, ptr %colA, i32 0, i32 3
  %12 = load i32, ptr %11, align 4
  %call7 = call noundef nonnull align 16 dereferenceable(96) ptr @_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %10, i32 noundef %12)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %hullA, ptr align 16 %call7, i64 96, i1 false)
  %13 = load ptr, ptr %collidables.addr, align 8
  %14 = load i32, ptr %collidableIndexB.addr, align 4
  %call8 = call noundef nonnull align 4 dereferenceable(16) ptr @_ZNK20b3AlignedObjectArrayI12b3CollidableEixEi(ptr noundef nonnull align 8 dereferenceable(25) %13, i32 noundef %14)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %colB, ptr align 4 %call8, i64 16, i1 false)
  %15 = load ptr, ptr %convexShapes.addr, align 8
  %16 = getelementptr inbounds %struct.b3Collidable, ptr %colB, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  %call9 = call noundef nonnull align 16 dereferenceable(96) ptr @_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %15, i32 noundef %17)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %hullB, ptr align 16 %call9, i64 96, i1 false)
  %18 = load ptr, ptr %convexVertices.addr, align 8
  %19 = load ptr, ptr %uniqueEdges.addr, align 8
  %20 = load ptr, ptr %faces.addr, align 8
  %21 = load ptr, ptr %convexIndices.addr, align 8
  %22 = load ptr, ptr %convexVertices.addr, align 8
  %23 = load ptr, ptr %uniqueEdges.addr, align 8
  %24 = load ptr, ptr %faces.addr, align 8
  %25 = load ptr, ptr %convexIndices.addr, align 8
  %call10 = call noundef zeroext i1 @_ZL18findSeparatingAxisRK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_RK20b3AlignedObjectArrayIS2_ESB_RKS8_I9b3GpuFaceERKS8_IiESB_SB_SF_SI_RS2_(ptr noundef nonnull align 16 dereferenceable(96) %hullA, ptr noundef nonnull align 16 dereferenceable(96) %hullB, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 8 dereferenceable(25) %18, ptr noundef nonnull align 8 dereferenceable(25) %19, ptr noundef nonnull align 8 dereferenceable(25) %20, ptr noundef nonnull align 8 dereferenceable(25) %21, ptr noundef nonnull align 8 dereferenceable(25) %22, ptr noundef nonnull align 8 dereferenceable(25) %23, ptr noundef nonnull align 8 dereferenceable(25) %24, ptr noundef nonnull align 8 dereferenceable(25) %25, ptr noundef nonnull align 16 dereferenceable(16) %sepNormalWorldSpace)
  %frombool = zext i1 %call10 to i8
  store i8 %frombool, ptr %foundSepAxis, align 1
  %26 = load i8, ptr %foundSepAxis, align 1
  %tobool = trunc i8 %26 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %27 = load i32, ptr %bodyIndexA.addr, align 4
  %28 = load i32, ptr %bodyIndexB.addr, align 4
  %29 = load i32, ptr %collidableIndexA.addr, align 4
  %30 = load i32, ptr %collidableIndexB.addr, align 4
  %31 = load ptr, ptr %rigidBodies.addr, align 8
  %32 = load ptr, ptr %globalContactsOut.addr, align 8
  %33 = load ptr, ptr %nGlobalContactsOut.addr, align 8
  %34 = load ptr, ptr %convexShapes.addr, align 8
  %35 = load ptr, ptr %convexShapes.addr, align 8
  %36 = load ptr, ptr %convexVertices.addr, align 8
  %37 = load ptr, ptr %uniqueEdges.addr, align 8
  %38 = load ptr, ptr %faces.addr, align 8
  %39 = load ptr, ptr %convexIndices.addr, align 8
  %40 = load ptr, ptr %convexVertices.addr, align 8
  %41 = load ptr, ptr %uniqueEdges.addr, align 8
  %42 = load ptr, ptr %faces.addr, align 8
  %43 = load ptr, ptr %convexIndices.addr, align 8
  %44 = load ptr, ptr %collidables.addr, align 8
  %45 = load ptr, ptr %collidables.addr, align 8
  %46 = load i32, ptr %maxContactCapacity.addr, align 4
  %call11 = call noundef i32 @_Z18clipHullHullSingleiiRK9b3Vector3RK12b3QuaternionS1_S4_iiPK20b3AlignedObjectArrayI15b3RigidBodyDataEPS5_I10b3Contact4ERiRKS5_I22b3ConvexPolyhedronDataESH_RKS5_IS_ESK_RKS5_I9b3GpuFaceERKS5_IiESK_SK_SO_SR_RKS5_I12b3CollidableESV_S1_i(i32 noundef %27, i32 noundef %28, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, i32 noundef %29, i32 noundef %30, ptr noundef %31, ptr noundef %32, ptr noundef nonnull align 4 dereferenceable(4) %33, ptr noundef nonnull align 8 dereferenceable(25) %34, ptr noundef nonnull align 8 dereferenceable(25) %35, ptr noundef nonnull align 8 dereferenceable(25) %36, ptr noundef nonnull align 8 dereferenceable(25) %37, ptr noundef nonnull align 8 dereferenceable(25) %38, ptr noundef nonnull align 8 dereferenceable(25) %39, ptr noundef nonnull align 8 dereferenceable(25) %40, ptr noundef nonnull align 8 dereferenceable(25) %41, ptr noundef nonnull align 8 dereferenceable(25) %42, ptr noundef nonnull align 8 dereferenceable(25) %43, ptr noundef nonnull align 8 dereferenceable(25) %44, ptr noundef nonnull align 8 dereferenceable(25) %45, ptr noundef nonnull align 16 dereferenceable(16) %sepNormalWorldSpace, i32 noundef %46)
  store i32 %call11, ptr %contactIndex, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %47 = load i32, ptr %contactIndex, align 4
  ret i32 %47
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(80) ptr @_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3RigidBodyData, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_(ptr noundef nonnull align 8 dereferenceable(864) %this, ptr noundef %pairs, i32 noundef %nPairs, ptr noundef %bodyBuf, ptr noundef %contactOut, ptr noundef nonnull align 4 dereferenceable(4) %nContacts, ptr noundef %oldContacts, i32 noundef %maxContactCapacity, i32 noundef %compoundPairCapacity, ptr noundef nonnull align 8 dereferenceable(50) %convexData, ptr noundef nonnull align 8 dereferenceable(50) %gpuVertices, ptr noundef nonnull align 8 dereferenceable(50) %gpuUniqueEdges, ptr noundef nonnull align 8 dereferenceable(50) %gpuFaces, ptr noundef nonnull align 8 dereferenceable(50) %gpuIndices, ptr noundef nonnull align 8 dereferenceable(50) %gpuCollidables, ptr noundef nonnull align 8 dereferenceable(50) %gpuChildShapes, ptr noundef nonnull align 8 dereferenceable(50) %clAabbsWorldSpace, ptr noundef nonnull align 8 dereferenceable(50) %clAabbsLocalSpace, ptr noundef nonnull align 8 dereferenceable(50) %worldVertsB1GPU, ptr noundef nonnull align 8 dereferenceable(50) %clippingFacesOutGPU, ptr noundef nonnull align 8 dereferenceable(50) %worldNormalsAGPU, ptr noundef nonnull align 8 dereferenceable(50) %worldVertsA1GPU, ptr noundef nonnull align 8 dereferenceable(50) %worldVertsB2GPU, ptr noundef nonnull align 1 %bvhDataUnused, ptr noundef %treeNodesGPU, ptr noundef %subTreesGPU, ptr noundef %bvhInfo, i32 noundef %numObjects, i32 noundef %maxTriConvexPairCapacity, ptr noundef nonnull align 8 dereferenceable(50) %triangleConvexPairsOut, ptr noundef nonnull align 4 dereferenceable(4) %numTriConvexPairsOut) #2 align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %pairs.addr = alloca ptr, align 8
  %nPairs.addr = alloca i32, align 4
  %bodyBuf.addr = alloca ptr, align 8
  %contactOut.addr = alloca ptr, align 8
  %nContacts.addr = alloca ptr, align 8
  %oldContacts.addr = alloca ptr, align 8
  %maxContactCapacity.addr = alloca i32, align 4
  %compoundPairCapacity.addr = alloca i32, align 4
  %convexData.addr = alloca ptr, align 8
  %gpuVertices.addr = alloca ptr, align 8
  %gpuUniqueEdges.addr = alloca ptr, align 8
  %gpuFaces.addr = alloca ptr, align 8
  %gpuIndices.addr = alloca ptr, align 8
  %gpuCollidables.addr = alloca ptr, align 8
  %gpuChildShapes.addr = alloca ptr, align 8
  %clAabbsWorldSpace.addr = alloca ptr, align 8
  %clAabbsLocalSpace.addr = alloca ptr, align 8
  %worldVertsB1GPU.addr = alloca ptr, align 8
  %clippingFacesOutGPU.addr = alloca ptr, align 8
  %worldNormalsAGPU.addr = alloca ptr, align 8
  %worldVertsA1GPU.addr = alloca ptr, align 8
  %worldVertsB2GPU.addr = alloca ptr, align 8
  %bvhDataUnused.addr = alloca ptr, align 8
  %treeNodesGPU.addr = alloca ptr, align 8
  %subTreesGPU.addr = alloca ptr, align 8
  %bvhInfo.addr = alloca ptr, align 8
  %numObjects.addr = alloca i32, align 4
  %maxTriConvexPairCapacity.addr = alloca i32, align 4
  %triangleConvexPairsOut.addr = alloca ptr, align 8
  %numTriConvexPairsOut.addr = alloca ptr, align 8
  %__profile = alloca %class.b3ProfileZone, align 1
  %bInfo = alloca [10 x %struct.b3BufferInfoCL], align 16
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %launcher = alloca %class.b3LauncherCL, align 8
  %num = alloca i32, align 4
  %__profile56 = alloca %class.b3ProfileZone, align 1
  %concaveCapacity = alloca i32, align 4
  %ref.tmp = alloca i32, align 4
  %ref.tmp87 = alloca i32, align 4
  %numCompoundPairs = alloca i32, align 4
  %numConcavePairs = alloca i32, align 4
  %__profile105 = alloca %class.b3ProfileZone, align 1
  %bInfo107 = alloca [9 x %struct.b3BufferInfoCL], align 16
  %launcher148 = alloca %class.b3LauncherCL, align 8
  %num156 = alloca i32, align 4
  %__profile174 = alloca %class.b3ProfileZone, align 1
  %bInfo176 = alloca [12 x %struct.b3BufferInfoCL], align 16
  %launcher229 = alloca %class.b3LauncherCL, align 8
  %num236 = alloca i32, align 4
  %numDirections = alloca i32, align 4
  %__profile243 = alloca %class.b3ProfileZone, align 1
  %bInfo245 = alloca [13 x %struct.b3BufferInfoCL], align 16
  %launcher302 = alloca %class.b3LauncherCL, align 8
  %num310 = alloca i32, align 4
  %__profile319 = alloca %class.b3ProfileZone, align 1
  %bInfo321 = alloca [9 x %struct.b3BufferInfoCL], align 16
  %launcher363 = alloca %class.b3LauncherCL, align 8
  %numDirections369 = alloca i32, align 4
  %num372 = alloca i32, align 4
  %__profile380 = alloca %class.b3ProfileZone, align 1
  %bInfo382 = alloca [11 x %struct.b3BufferInfoCL], align 16
  %launcher430 = alloca %class.b3LauncherCL, align 8
  %num437 = alloca i32, align 4
  %__profile446 = alloca %class.b3ProfileZone, align 1
  %hostPairs = alloca %class.b3AlignedObjectArray.66, align 8
  %hostBodyBuf = alloca %class.b3AlignedObjectArray.39, align 8
  %hostCollidables = alloca %class.b3AlignedObjectArray.27, align 8
  %cpuChildShapes = alloca %class.b3AlignedObjectArray.92, align 8
  %hostConvexShapeData = alloca %class.b3AlignedObjectArray.31, align 8
  %hostVertices = alloca %class.b3AlignedObjectArray, align 8
  %hostHasSepAxis = alloca %class.b3AlignedObjectArray.23, align 8
  %ref.tmp468 = alloca i32, align 4
  %hostSepAxis = alloca %class.b3AlignedObjectArray, align 8
  %ref.tmp472 = alloca %class.b3Vector3, align 16
  %hostUniqueEdges = alloca %class.b3AlignedObjectArray, align 8
  %hostFaces = alloca %class.b3AlignedObjectArray.19, align 8
  %hostIndices = alloca %class.b3AlignedObjectArray.23, align 8
  %hostContacts = alloca %class.b3AlignedObjectArray.35, align 8
  %ref.tmp490 = alloca %struct.b3Contact4, align 16
  %nGlobalContactsOut = alloca i32, align 4
  %i = alloca i32, align 4
  %bodyIndexA = alloca i32, align 4
  %bodyIndexB = alloca i32, align 4
  %collidableIndexA = alloca i32, align 4
  %collidableIndexB = alloca i32, align 4
  %shapeIndexA = alloca i32, align 4
  %shapeIndexB = alloca i32, align 4
  %dmin = alloca float, align 4
  %convexShapeA = alloca ptr, align 8
  %convexShapeB = alloca ptr, align 8
  %posA = alloca %class.b3Vector3, align 16
  %posB = alloca %class.b3Vector3, align 16
  %ornA = alloca %class.b3Quaternion, align 16
  %ornB = alloca %class.b3Quaternion, align 16
  %c0local = alloca %class.b3Vector3, align 16
  %c0 = alloca %class.b3Vector3, align 16
  %c1local = alloca %class.b3Vector3, align 16
  %c1 = alloca %class.b3Vector3, align 16
  %DeltaC2 = alloca %class.b3Vector3, align 16
  %sepAxis = alloca %class.b3Vector3, align 16
  %hasSepAxisA = alloca i8, align 1
  %hasSepAxisB = alloca i8, align 1
  %hasEdgeEdge = alloca i8, align 1
  %pairIndex = alloca i32, align 4
  %useMpr = alloca i8, align 1
  %res = alloca i32, align 4
  %depth = alloca float, align 4
  %sepAxis2 = alloca %class.b3Vector3, align 16
  %resultPointOnBWorld = alloca %class.b3Vector3, align 16
  %depthOut = alloca float, align 4
  %dirOut = alloca %class.b3Vector3, align 16
  %posOut = alloca %class.b3Vector3, align 16
  %ref.tmp657 = alloca %class.b3Vector3, align 16
  %dist = alloca float, align 4
  %hullA = alloca ptr, align 8
  %hullB = alloca ptr, align 8
  %diff = alloca float, align 4
  %oldAxis = alloca %class.b3Vector3, align 16
  %diff713 = alloca float, align 4
  %newContact = alloca ptr, align 8
  %oldHostContacts = alloca %class.b3AlignedObjectArray.35, align 8
  %result = alloca i32, align 4
  %c0local763 = alloca %class.b3Vector3, align 16
  %c0767 = alloca %class.b3Vector3, align 16
  %c1local772 = alloca %class.b3Vector3, align 16
  %c1776 = alloca %class.b3Vector3, align 16
  %DeltaC2781 = alloca %class.b3Vector3, align 16
  %sepAxis786 = alloca %class.b3Vector3, align 16
  %hasSepAxisA787 = alloca i8, align 1
  %hasSepAxisB809 = alloca i8, align 1
  %hasEdgeEdge831 = alloca i8, align 1
  %useGpuFindCompoundPairs = alloca i8, align 1
  %__profile891 = alloca %class.b3ProfileZone, align 1
  %bInfo893 = alloca [15 x %struct.b3BufferInfoCL], align 16
  %launcher957 = alloca %class.b3LauncherCL, align 8
  %num965 = alloca i32, align 4
  %treeNodesCPU = alloca %class.b3AlignedObjectArray.58, align 8
  %subTreesCPU = alloca %class.b3AlignedObjectArray.47, align 8
  %bvhInfoCPU = alloca %class.b3AlignedObjectArray.43, align 8
  %hostAabbsWorldSpace = alloca %class.b3AlignedObjectArray.62, align 8
  %hostAabbsLocalSpace = alloca %class.b3AlignedObjectArray.62, align 8
  %hostPairs994 = alloca %class.b3AlignedObjectArray.66, align 8
  %hostBodyBuf998 = alloca %class.b3AlignedObjectArray.39, align 8
  %cpuCompoundPairsOut = alloca %class.b3AlignedObjectArray.66, align 8
  %ref.tmp1003 = alloca %struct.b3Int4, align 16
  %hostCollidables1006 = alloca %class.b3AlignedObjectArray.27, align 8
  %cpuChildShapes1010 = alloca %class.b3AlignedObjectArray.92, align 8
  %hostConvexData = alloca %class.b3AlignedObjectArray.31, align 8
  %hostVertices1017 = alloca %class.b3AlignedObjectArray, align 8
  %pairIndex1021 = alloca i32, align 4
  %bodyIndexA1025 = alloca i32, align 4
  %bodyIndexB1029 = alloca i32, align 4
  %collidableIndexA1033 = alloca i32, align 4
  %collidableIndexB1037 = alloca i32, align 4
  %ptr = alloca ptr, align 8
  %__profile1110 = alloca %class.b3ProfileZone, align 1
  %bInfo1112 = alloca [12 x %struct.b3BufferInfoCL], align 16
  %launcher1164 = alloca %class.b3LauncherCL, align 8
  %num1172 = alloca i32, align 4
  %__profile1193 = alloca %class.b3ProfileZone, align 1
  %bInfo1195 = alloca [12 x %struct.b3BufferInfoCL], align 16
  %launcher1248 = alloca %class.b3LauncherCL, align 8
  %num1255 = alloca i32, align 4
  %vertexFaceCapacity = alloca i32, align 4
  %__profile1273 = alloca %class.b3ProfileZone, align 1
  %launcher1279 = alloca %class.b3LauncherCL, align 8
  %num1313 = alloca i32, align 4
  %hostPairs1324 = alloca %class.b3AlignedObjectArray.66, align 8
  %hostBodyBuf1328 = alloca %class.b3AlignedObjectArray.39, align 8
  %hostCollidables1332 = alloca %class.b3AlignedObjectArray.27, align 8
  %hostAabbsWorldSpace1336 = alloca %class.b3AlignedObjectArray.62, align 8
  %triangleConvexPairsOutHost = alloca %class.b3AlignedObjectArray.66, align 8
  %ref.tmp1341 = alloca %struct.b3Int4, align 16
  %treeNodesCPU1344 = alloca %class.b3AlignedObjectArray.58, align 8
  %subTreesCPU1348 = alloca %class.b3AlignedObjectArray.47, align 8
  %bvhInfoCPU1352 = alloca %class.b3AlignedObjectArray.43, align 8
  %hostNumConcavePairsOut = alloca i32, align 4
  %i1356 = alloca i32, align 4
  %ref.tmp1382 = alloca %struct.b3Int4, align 16
  %__profile1436 = alloca %class.b3ProfileZone, align 1
  %bInfo1438 = alloca [17 x %struct.b3BufferInfoCL], align 16
  %launcher1511 = alloca %class.b3LauncherCL, align 8
  %num1519 = alloca i32, align 4
  %__profile1526 = alloca %class.b3ProfileZone, align 1
  %bInfo1528 = alloca [17 x %struct.b3BufferInfoCL], align 16
  %launcher1601 = alloca %class.b3LauncherCL, align 8
  %num1609 = alloca i32, align 4
  %__profile1617 = alloca %class.b3ProfileZone, align 1
  %bInfo1619 = alloca [16 x %struct.b3BufferInfoCL], align 16
  %launcher1687 = alloca %class.b3LauncherCL, align 8
  %num1695 = alloca i32, align 4
  %clippingFacesOutCPU = alloca %class.b3AlignedObjectArray.66, align 8
  %worldVertsA1CPU = alloca %class.b3AlignedObjectArray, align 8
  %worldNormalsACPU = alloca %class.b3AlignedObjectArray, align 8
  %worldVertsB1CPU = alloca %class.b3AlignedObjectArray, align 8
  %concaveHasSeparatingNormalsCPU = alloca %class.b3AlignedObjectArray.23, align 8
  %triangleConvexPairsOutHost1713 = alloca %class.b3AlignedObjectArray.66, align 8
  %hostBodyBuf1718 = alloca %class.b3AlignedObjectArray.39, align 8
  %hostCollidables1722 = alloca %class.b3AlignedObjectArray.27, align 8
  %hostAabbsWorldSpace1726 = alloca %class.b3AlignedObjectArray.62, align 8
  %hostConvexData1730 = alloca %class.b3AlignedObjectArray.31, align 8
  %hostVertices1734 = alloca %class.b3AlignedObjectArray, align 8
  %hostUniqueEdges1738 = alloca %class.b3AlignedObjectArray, align 8
  %hostFaces1742 = alloca %class.b3AlignedObjectArray.19, align 8
  %hostIndices1746 = alloca %class.b3AlignedObjectArray.23, align 8
  %cpuChildShapes1750 = alloca %class.b3AlignedObjectArray.92, align 8
  %concaveSepNormalsHost = alloca %class.b3AlignedObjectArray, align 8
  %ref.tmp1760 = alloca i32, align 4
  %childShapePointerCPU = alloca ptr, align 8
  %ref.tmp1772 = alloca %struct.b3Int4, align 16
  %ref.tmp1777 = alloca %class.b3Vector3, align 16
  %ref.tmp1782 = alloca %class.b3Vector3, align 16
  %ref.tmp1787 = alloca %class.b3Vector3, align 16
  %i1789 = alloca i32, align 4
  %__profile1858 = alloca %class.b3ProfileZone, align 1
  %bInfo1864 = alloca [11 x %struct.b3BufferInfoCL], align 16
  %launcher1910 = alloca %class.b3LauncherCL, align 8
  %num1918 = alloca i32, align 4
  %contactClippingOnGpu = alloca i8, align 1
  %breakupConcaveConvexKernel = alloca i8, align 1
  %clippingFacesOutCPU1952 = alloca %class.b3AlignedObjectArray.66, align 8
  %worldVertsA1CPU1954 = alloca %class.b3AlignedObjectArray, align 8
  %worldNormalsACPU1957 = alloca %class.b3AlignedObjectArray, align 8
  %worldVertsB1CPU1960 = alloca %class.b3AlignedObjectArray, align 8
  %concaveHasSeparatingNormalsCPU1968 = alloca %class.b3AlignedObjectArray.23, align 8
  %concaveSepNormalsHost1973 = alloca %class.b3AlignedObjectArray, align 8
  %worldVertsB2CPU = alloca %class.b3AlignedObjectArray, align 8
  %ref.tmp1983 = alloca %class.b3Vector3, align 16
  %i1985 = alloca i32, align 4
  %__profile2017 = alloca %class.b3ProfileZone, align 1
  %bInfo2019 = alloca [7 x %struct.b3BufferInfoCL], align 16
  %launcher2051 = alloca %class.b3LauncherCL, align 8
  %debugMode = alloca i32, align 4
  %num2060 = alloca i32, align 4
  %newContactCapacity = alloca i32, align 4
  %__profile2073 = alloca %class.b3ProfileZone, align 1
  %bInfo2075 = alloca [8 x %struct.b3BufferInfoCL], align 16
  %launcher2112 = alloca %class.b3LauncherCL, align 8
  %num2121 = alloca i32, align 4
  %nGlobalContactsOut2132 = alloca i32, align 4
  %triangleConvexPairsOutHost2133 = alloca %class.b3AlignedObjectArray.66, align 8
  %hostBodyBuf2137 = alloca %class.b3AlignedObjectArray.39, align 8
  %concaveHasSeparatingNormalsCPU2141 = alloca %class.b3AlignedObjectArray.23, align 8
  %concaveSepNormalsHost2146 = alloca %class.b3AlignedObjectArray, align 8
  %hostContacts2151 = alloca %class.b3AlignedObjectArray.35, align 8
  %ref.tmp2158 = alloca %struct.b3Contact4, align 16
  %clippingFacesOutCPU2160 = alloca %class.b3AlignedObjectArray.66, align 8
  %worldVertsB2CPU2162 = alloca %class.b3AlignedObjectArray, align 8
  %i2168 = alloca i32, align 4
  %ref.tmp2192 = alloca %struct.b3Contact4, align 16
  %__profile2204 = alloca %class.b3ProfileZone, align 1
  %newContactCapacity2210 = alloca i32, align 4
  %bInfo2214 = alloca [12 x %struct.b3BufferInfoCL], align 16
  %launcher2265 = alloca %class.b3LauncherCL, align 8
  %num2273 = alloca i32, align 4
  %cpuContacts = alloca %class.b3AlignedObjectArray.35, align 8
  %breakupKernel = alloca i8, align 1
  %computeConvexConvex = alloca i8, align 1
  %__profile2294 = alloca %class.b3ProfileZone, align 1
  %__profile2319 = alloca %class.b3ProfileZone, align 1
  %bInfo2321 = alloca [14 x %struct.b3BufferInfoCL], align 16
  %launcher2381 = alloca %class.b3LauncherCL, align 8
  %num2389 = alloca i32, align 4
  %minDist = alloca float, align 4
  %maxDist = alloca float, align 4
  %hostConvexData2397 = alloca %class.b3AlignedObjectArray.31, align 8
  %hostCollidables2401 = alloca %class.b3AlignedObjectArray.27, align 8
  %hostHasSepNormals = alloca %class.b3AlignedObjectArray.23, align 8
  %cpuSepNormals = alloca %class.b3AlignedObjectArray, align 8
  %hostPairs2413 = alloca %class.b3AlignedObjectArray.66, align 8
  %hostBodyBuf2417 = alloca %class.b3AlignedObjectArray.39, align 8
  %worldVertsB1CPU2421 = alloca %class.b3AlignedObjectArray, align 8
  %clippingFacesOutCPU2425 = alloca %class.b3AlignedObjectArray.66, align 8
  %worldNormalsACPU2429 = alloca %class.b3AlignedObjectArray, align 8
  %ref.tmp2431 = alloca %class.b3Vector3, align 16
  %worldVertsA1CPU2434 = alloca %class.b3AlignedObjectArray, align 8
  %ref.tmp2440 = alloca %class.b3Vector3, align 16
  %hostVertices2442 = alloca %class.b3AlignedObjectArray, align 8
  %hostFaces2446 = alloca %class.b3AlignedObjectArray.19, align 8
  %hostIndices2450 = alloca %class.b3AlignedObjectArray.23, align 8
  %i2454 = alloca i32, align 4
  %bodyIndexA2458 = alloca i32, align 4
  %bodyIndexB2462 = alloca i32, align 4
  %collidableIndexA2466 = alloca i32, align 4
  %collidableIndexB2470 = alloca i32, align 4
  %shapeIndexA2474 = alloca i32, align 4
  %shapeIndexB2477 = alloca i32, align 4
  %hostSepNormals = alloca %class.b3AlignedObjectArray, align 8
  %hostHasSepAxis2552 = alloca %class.b3AlignedObjectArray.23, align 8
  %hostClippingFaces = alloca %class.b3AlignedObjectArray.66, align 8
  %worldVertsB2CPU2560 = alloca %class.b3AlignedObjectArray, align 8
  %ref.tmp2563 = alloca %class.b3Vector3, align 16
  %worldVertsA1CPU2566 = alloca %class.b3AlignedObjectArray, align 8
  %worldNormalsACPU2570 = alloca %class.b3AlignedObjectArray, align 8
  %worldVertsB1CPU2574 = alloca %class.b3AlignedObjectArray, align 8
  %i2578 = alloca i32, align 4
  %__profile2610 = alloca %class.b3ProfileZone, align 1
  %bInfo2612 = alloca [7 x %struct.b3BufferInfoCL], align 16
  %launcher2644 = alloca %class.b3LauncherCL, align 8
  %debugMode2653 = alloca i32, align 4
  %num2655 = alloca i32, align 4
  %newContactCapacity2666 = alloca i32, align 4
  %__profile2673 = alloca %class.b3ProfileZone, align 1
  %bInfo2675 = alloca [8 x %struct.b3BufferInfoCL], align 16
  %launcher2712 = alloca %class.b3LauncherCL, align 8
  %num2722 = alloca i32, align 4
  %nGlobalContactsOut2733 = alloca i32, align 4
  %hostPairs2734 = alloca %class.b3AlignedObjectArray.66, align 8
  %hostBodyBuf2738 = alloca %class.b3AlignedObjectArray.39, align 8
  %hostSepNormals2742 = alloca %class.b3AlignedObjectArray, align 8
  %hostHasSepAxis2747 = alloca %class.b3AlignedObjectArray.23, align 8
  %hostContactsOut = alloca %class.b3AlignedObjectArray.35, align 8
  %ref.tmp2755 = alloca %struct.b3Contact4, align 16
  %hostClippingFaces2757 = alloca %class.b3AlignedObjectArray.66, align 8
  %worldVertsB2CPU2761 = alloca %class.b3AlignedObjectArray, align 8
  %i2765 = alloca i32, align 4
  %ref.tmp2789 = alloca %struct.b3Contact4, align 16
  %bInfo2803 = alloca [12 x %struct.b3BufferInfoCL], align 16
  %launcher2855 = alloca %class.b3LauncherCL, align 8
  %num2863 = alloca i32, align 4
  %nCompoundsPairs = alloca i32, align 4
  %bInfo2891 = alloca [13 x %struct.b3BufferInfoCL], align 16
  %launcher2948 = alloca %class.b3LauncherCL, align 8
  %num2956 = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %pairs, ptr %pairs.addr, align 8
  store i32 %nPairs, ptr %nPairs.addr, align 4
  store ptr %bodyBuf, ptr %bodyBuf.addr, align 8
  store ptr %contactOut, ptr %contactOut.addr, align 8
  store ptr %nContacts, ptr %nContacts.addr, align 8
  store ptr %oldContacts, ptr %oldContacts.addr, align 8
  store i32 %maxContactCapacity, ptr %maxContactCapacity.addr, align 4
  store i32 %compoundPairCapacity, ptr %compoundPairCapacity.addr, align 4
  store ptr %convexData, ptr %convexData.addr, align 8
  store ptr %gpuVertices, ptr %gpuVertices.addr, align 8
  store ptr %gpuUniqueEdges, ptr %gpuUniqueEdges.addr, align 8
  store ptr %gpuFaces, ptr %gpuFaces.addr, align 8
  store ptr %gpuIndices, ptr %gpuIndices.addr, align 8
  store ptr %gpuCollidables, ptr %gpuCollidables.addr, align 8
  store ptr %gpuChildShapes, ptr %gpuChildShapes.addr, align 8
  store ptr %clAabbsWorldSpace, ptr %clAabbsWorldSpace.addr, align 8
  store ptr %clAabbsLocalSpace, ptr %clAabbsLocalSpace.addr, align 8
  store ptr %worldVertsB1GPU, ptr %worldVertsB1GPU.addr, align 8
  store ptr %clippingFacesOutGPU, ptr %clippingFacesOutGPU.addr, align 8
  store ptr %worldNormalsAGPU, ptr %worldNormalsAGPU.addr, align 8
  store ptr %worldVertsA1GPU, ptr %worldVertsA1GPU.addr, align 8
  store ptr %worldVertsB2GPU, ptr %worldVertsB2GPU.addr, align 8
  store ptr %bvhDataUnused, ptr %bvhDataUnused.addr, align 8
  store ptr %treeNodesGPU, ptr %treeNodesGPU.addr, align 8
  store ptr %subTreesGPU, ptr %subTreesGPU.addr, align 8
  store ptr %bvhInfo, ptr %bvhInfo.addr, align 8
  store i32 %numObjects, ptr %numObjects.addr, align 4
  store i32 %maxTriConvexPairCapacity, ptr %maxTriConvexPairCapacity.addr, align 4
  store ptr %triangleConvexPairsOut, ptr %triangleConvexPairsOut.addr, align 8
  store ptr %numTriConvexPairsOut, ptr %numTriConvexPairsOut.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr @_ZL12myframecount, align 4
  %inc = add nsw i32 %0, 1
  store i32 %inc, ptr @_ZL12myframecount, align 4
  %1 = load i32, ptr %nPairs.addr, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %nPairs.addr, align 4
  %tobool2 = icmp ne i32 %2, 0
  br i1 %tobool2, label %if.then3, label %if.end55

if.then3:                                         ; preds = %if.end
  %m_totalContactsOut = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %3 = load ptr, ptr %nContacts.addr, align 8
  call void @_ZN13b3OpenCLArrayIiE19copyFromHostPointerEPKimmb(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut, ptr noundef %3, i64 noundef 1, i64 noundef 0, i1 noundef zeroext true)
  call void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %__profile, ptr noundef @.str.27)
  %arrayinit.begin = getelementptr inbounds [10 x %struct.b3BufferInfoCL], ptr %bInfo, i64 0, i64 0
  %4 = load ptr, ptr %pairs.addr, align 8
  %call = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %4)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %if.then3
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.begin, ptr noundef %call, i1 noundef zeroext true)
          to label %invoke.cont4 unwind label %lpad

invoke.cont4:                                     ; preds = %invoke.cont
  %arrayinit.element = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.begin, i64 1
  %5 = load ptr, ptr %bodyBuf.addr, align 8
  %call6 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %5)
          to label %invoke.cont5 unwind label %lpad

invoke.cont5:                                     ; preds = %invoke.cont4
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element, ptr noundef %call6, i1 noundef zeroext true)
          to label %invoke.cont7 unwind label %lpad

invoke.cont7:                                     ; preds = %invoke.cont5
  %arrayinit.element8 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element, i64 1
  %6 = load ptr, ptr %gpuCollidables.addr, align 8
  %call10 = invoke noundef ptr @_ZNK13b3OpenCLArrayI12b3CollidableE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %6)
          to label %invoke.cont9 unwind label %lpad

invoke.cont9:                                     ; preds = %invoke.cont7
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element8, ptr noundef %call10, i1 noundef zeroext true)
          to label %invoke.cont11 unwind label %lpad

invoke.cont11:                                    ; preds = %invoke.cont9
  %arrayinit.element12 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element8, i64 1
  %7 = load ptr, ptr %convexData.addr, align 8
  %call14 = invoke noundef ptr @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %7)
          to label %invoke.cont13 unwind label %lpad

invoke.cont13:                                    ; preds = %invoke.cont11
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element12, ptr noundef %call14, i1 noundef zeroext true)
          to label %invoke.cont15 unwind label %lpad

invoke.cont15:                                    ; preds = %invoke.cont13
  %arrayinit.element16 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element12, i64 1
  %8 = load ptr, ptr %gpuVertices.addr, align 8
  %call18 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %8)
          to label %invoke.cont17 unwind label %lpad

invoke.cont17:                                    ; preds = %invoke.cont15
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element16, ptr noundef %call18, i1 noundef zeroext true)
          to label %invoke.cont19 unwind label %lpad

invoke.cont19:                                    ; preds = %invoke.cont17
  %arrayinit.element20 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element16, i64 1
  %9 = load ptr, ptr %gpuUniqueEdges.addr, align 8
  %call22 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %9)
          to label %invoke.cont21 unwind label %lpad

invoke.cont21:                                    ; preds = %invoke.cont19
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element20, ptr noundef %call22, i1 noundef zeroext true)
          to label %invoke.cont23 unwind label %lpad

invoke.cont23:                                    ; preds = %invoke.cont21
  %arrayinit.element24 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element20, i64 1
  %10 = load ptr, ptr %gpuFaces.addr, align 8
  %call26 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3GpuFaceE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %10)
          to label %invoke.cont25 unwind label %lpad

invoke.cont25:                                    ; preds = %invoke.cont23
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element24, ptr noundef %call26, i1 noundef zeroext true)
          to label %invoke.cont27 unwind label %lpad

invoke.cont27:                                    ; preds = %invoke.cont25
  %arrayinit.element28 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element24, i64 1
  %11 = load ptr, ptr %gpuIndices.addr, align 8
  %call30 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %11)
          to label %invoke.cont29 unwind label %lpad

invoke.cont29:                                    ; preds = %invoke.cont27
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element28, ptr noundef %call30, i1 noundef zeroext true)
          to label %invoke.cont31 unwind label %lpad

invoke.cont31:                                    ; preds = %invoke.cont29
  %arrayinit.element32 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element28, i64 1
  %12 = load ptr, ptr %contactOut.addr, align 8
  %call34 = invoke noundef ptr @_ZNK13b3OpenCLArrayI10b3Contact4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %12)
          to label %invoke.cont33 unwind label %lpad

invoke.cont33:                                    ; preds = %invoke.cont31
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element32, ptr noundef %call34, i1 noundef zeroext false)
          to label %invoke.cont35 unwind label %lpad

invoke.cont35:                                    ; preds = %invoke.cont33
  %arrayinit.element36 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element32, i64 1
  %m_totalContactsOut37 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %call39 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut37)
          to label %invoke.cont38 unwind label %lpad

invoke.cont38:                                    ; preds = %invoke.cont35
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element36, ptr noundef %call39, i1 noundef zeroext false)
          to label %invoke.cont40 unwind label %lpad

invoke.cont40:                                    ; preds = %invoke.cont38
  %m_queue = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %13 = load ptr, ptr %m_queue, align 8
  %m_primitiveContactsKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 21
  %14 = load ptr, ptr %m_primitiveContactsKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher, ptr noundef %13, ptr noundef %14, ptr noundef @.str.39)
          to label %invoke.cont41 unwind label %lpad

invoke.cont41:                                    ; preds = %invoke.cont40
  %arraydecay = getelementptr inbounds [10 x %struct.b3BufferInfoCL], ptr %bInfo, i64 0, i64 0
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher, ptr noundef %arraydecay, i32 noundef 10)
          to label %invoke.cont43 unwind label %lpad42

invoke.cont43:                                    ; preds = %invoke.cont41
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher, ptr noundef nonnull align 4 dereferenceable(4) %nPairs.addr)
          to label %invoke.cont44 unwind label %lpad42

invoke.cont44:                                    ; preds = %invoke.cont43
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher, ptr noundef nonnull align 4 dereferenceable(4) %maxContactCapacity.addr)
          to label %invoke.cont45 unwind label %lpad42

invoke.cont45:                                    ; preds = %invoke.cont44
  %15 = load i32, ptr %nPairs.addr, align 4
  store i32 %15, ptr %num, align 4
  %16 = load i32, ptr %num, align 4
  invoke void @_ZN12b3LauncherCL8launch1DEii(ptr noundef nonnull align 8 dereferenceable(112) %launcher, i32 noundef %16, i32 noundef 64)
          to label %invoke.cont46 unwind label %lpad42

invoke.cont46:                                    ; preds = %invoke.cont45
  %17 = load ptr, ptr @__clewFinish, align 8
  %m_queue47 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %18 = load ptr, ptr %m_queue47, align 8
  %call49 = invoke i32 %17(ptr noundef %18)
          to label %invoke.cont48 unwind label %lpad42

invoke.cont48:                                    ; preds = %invoke.cont46
  %m_totalContactsOut50 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %call52 = invoke noundef i32 @_ZNK13b3OpenCLArrayIiE2atEm(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut50, i64 noundef 0)
          to label %invoke.cont51 unwind label %lpad42

invoke.cont51:                                    ; preds = %invoke.cont48
  %19 = load ptr, ptr %nContacts.addr, align 8
  store i32 %call52, ptr %19, align 4
  %20 = load ptr, ptr %contactOut.addr, align 8
  %21 = load ptr, ptr %nContacts.addr, align 8
  %22 = load i32, ptr %21, align 4
  %conv = sext i32 %22 to i64
  %call54 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI10b3Contact4E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %20, i64 noundef %conv, i1 noundef zeroext true)
          to label %invoke.cont53 unwind label %lpad42

invoke.cont53:                                    ; preds = %invoke.cont51
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher) #13
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile) #13
  br label %if.end55

lpad:                                             ; preds = %invoke.cont40, %invoke.cont38, %invoke.cont35, %invoke.cont33, %invoke.cont31, %invoke.cont29, %invoke.cont27, %invoke.cont25, %invoke.cont23, %invoke.cont21, %invoke.cont19, %invoke.cont17, %invoke.cont15, %invoke.cont13, %invoke.cont11, %invoke.cont9, %invoke.cont7, %invoke.cont5, %invoke.cont4, %invoke.cont, %if.then3
  %23 = landingpad { ptr, i32 }
          cleanup
  %24 = extractvalue { ptr, i32 } %23, 0
  store ptr %24, ptr %exn.slot, align 8
  %25 = extractvalue { ptr, i32 } %23, 1
  store i32 %25, ptr %ehselector.slot, align 4
  br label %ehcleanup

lpad42:                                           ; preds = %invoke.cont51, %invoke.cont48, %invoke.cont46, %invoke.cont45, %invoke.cont44, %invoke.cont43, %invoke.cont41
  %26 = landingpad { ptr, i32 }
          cleanup
  %27 = extractvalue { ptr, i32 } %26, 0
  store ptr %27, ptr %exn.slot, align 8
  %28 = extractvalue { ptr, i32 } %26, 1
  store i32 %28, ptr %ehselector.slot, align 4
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher) #13
  br label %ehcleanup

ehcleanup:                                        ; preds = %lpad42, %lpad
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile) #13
  br label %eh.resume

if.end55:                                         ; preds = %invoke.cont53, %if.end
  call void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %__profile56, ptr noundef @.str.40)
  %m_sepNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 26
  %29 = load i32, ptr %nPairs.addr, align 4
  %conv57 = sext i32 %29 to i64
  %call60 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_sepNormals, i64 noundef %conv57, i1 noundef zeroext true)
          to label %invoke.cont59 unwind label %lpad58

invoke.cont59:                                    ; preds = %if.end55
  %m_hasSeparatingNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 28
  %30 = load i32, ptr %nPairs.addr, align 4
  %conv61 = sext i32 %30 to i64
  %call63 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayIiE6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_hasSeparatingNormals, i64 noundef %conv61, i1 noundef zeroext true)
          to label %invoke.cont62 unwind label %lpad58

invoke.cont62:                                    ; preds = %invoke.cont59
  %31 = load i32, ptr %maxTriConvexPairCapacity.addr, align 4
  store i32 %31, ptr %concaveCapacity, align 4
  %m_concaveSepNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 29
  %32 = load i32, ptr %concaveCapacity, align 4
  %conv64 = sext i32 %32 to i64
  %call66 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveSepNormals, i64 noundef %conv64, i1 noundef zeroext true)
          to label %invoke.cont65 unwind label %lpad58

invoke.cont65:                                    ; preds = %invoke.cont62
  %m_concaveHasSeparatingNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 30
  %33 = load i32, ptr %concaveCapacity, align 4
  %conv67 = sext i32 %33 to i64
  %call69 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayIiE6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveHasSeparatingNormals, i64 noundef %conv67, i1 noundef zeroext true)
          to label %invoke.cont68 unwind label %lpad58

invoke.cont68:                                    ; preds = %invoke.cont65
  %m_numConcavePairsOut = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 31
  %call71 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayIiE6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_numConcavePairsOut, i64 noundef 0, i1 noundef zeroext true)
          to label %invoke.cont70 unwind label %lpad58

invoke.cont70:                                    ; preds = %invoke.cont68
  %m_numConcavePairsOut72 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 31
  store i32 0, ptr %ref.tmp, align 4
  %call74 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayIiE9push_backERKib(ptr noundef nonnull align 8 dereferenceable(50) %m_numConcavePairsOut72, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp, i1 noundef zeroext true)
          to label %invoke.cont73 unwind label %lpad58

invoke.cont73:                                    ; preds = %invoke.cont70
  %m_gpuCompoundPairs = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 32
  %34 = load i32, ptr %compoundPairCapacity.addr, align 4
  %conv75 = sext i32 %34 to i64
  %call77 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuCompoundPairs, i64 noundef %conv75, i1 noundef zeroext true)
          to label %invoke.cont76 unwind label %lpad58

invoke.cont76:                                    ; preds = %invoke.cont73
  %m_gpuCompoundSepNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 33
  %35 = load i32, ptr %compoundPairCapacity.addr, align 4
  %conv78 = sext i32 %35 to i64
  %call80 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuCompoundSepNormals, i64 noundef %conv78, i1 noundef zeroext true)
          to label %invoke.cont79 unwind label %lpad58

invoke.cont79:                                    ; preds = %invoke.cont76
  %m_gpuHasCompoundSepNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 34
  %36 = load i32, ptr %compoundPairCapacity.addr, align 4
  %conv81 = sext i32 %36 to i64
  %call83 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayIiE6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuHasCompoundSepNormals, i64 noundef %conv81, i1 noundef zeroext true)
          to label %invoke.cont82 unwind label %lpad58

invoke.cont82:                                    ; preds = %invoke.cont79
  %m_numCompoundPairsOut = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 35
  %call85 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayIiE6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_numCompoundPairsOut, i64 noundef 0, i1 noundef zeroext true)
          to label %invoke.cont84 unwind label %lpad58

invoke.cont84:                                    ; preds = %invoke.cont82
  %m_numCompoundPairsOut86 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 35
  store i32 0, ptr %ref.tmp87, align 4
  %call89 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayIiE9push_backERKib(ptr noundef nonnull align 8 dereferenceable(50) %m_numCompoundPairsOut86, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp87, i1 noundef zeroext true)
          to label %invoke.cont88 unwind label %lpad58

invoke.cont88:                                    ; preds = %invoke.cont84
  store i32 0, ptr %numCompoundPairs, align 4
  store i32 0, ptr %numConcavePairs, align 4
  %37 = load ptr, ptr @__clewFinish, align 8
  %m_queue90 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %38 = load ptr, ptr %m_queue90, align 8
  %call92 = invoke i32 %37(ptr noundef %38)
          to label %invoke.cont91 unwind label %lpad58

invoke.cont91:                                    ; preds = %invoke.cont88
  %39 = load i8, ptr @findSeparatingAxisOnGpu, align 1
  %tobool93 = trunc i8 %39 to i1
  br i1 %tobool93, label %if.then94, label %if.else445

if.then94:                                        ; preds = %invoke.cont91
  %m_dmins = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 27
  %40 = load i32, ptr %nPairs.addr, align 4
  %conv95 = sext i32 %40 to i64
  %call97 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayIfE6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_dmins, i64 noundef %conv95, i1 noundef zeroext true)
          to label %invoke.cont96 unwind label %lpad58

invoke.cont96:                                    ; preds = %if.then94
  %41 = load i8, ptr @splitSearchSepAxisConvex, align 1
  %tobool98 = trunc i8 %41 to i1
  br i1 %tobool98, label %if.then99, label %if.else

if.then99:                                        ; preds = %invoke.cont96
  %42 = load i8, ptr @useMprGpu, align 1
  %tobool100 = trunc i8 %42 to i1
  br i1 %tobool100, label %if.then101, label %if.end173

if.then101:                                       ; preds = %if.then99
  %m_totalContactsOut102 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %call104 = invoke noundef i32 @_ZNK13b3OpenCLArrayIiE2atEm(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut102, i64 noundef 0)
          to label %invoke.cont103 unwind label %lpad58

invoke.cont103:                                   ; preds = %if.then101
  %43 = load ptr, ptr %nContacts.addr, align 8
  store i32 %call104, ptr %43, align 4
  invoke void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %__profile105, ptr noundef @.str.4)
          to label %invoke.cont106 unwind label %lpad58

invoke.cont106:                                   ; preds = %invoke.cont103
  %arrayinit.begin108 = getelementptr inbounds [9 x %struct.b3BufferInfoCL], ptr %bInfo107, i64 0, i64 0
  %44 = load ptr, ptr %pairs.addr, align 8
  %call111 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %44)
          to label %invoke.cont110 unwind label %lpad109

invoke.cont110:                                   ; preds = %invoke.cont106
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.begin108, ptr noundef %call111, i1 noundef zeroext true)
          to label %invoke.cont112 unwind label %lpad109

invoke.cont112:                                   ; preds = %invoke.cont110
  %arrayinit.element113 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.begin108, i64 1
  %45 = load ptr, ptr %bodyBuf.addr, align 8
  %call115 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %45)
          to label %invoke.cont114 unwind label %lpad109

invoke.cont114:                                   ; preds = %invoke.cont112
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element113, ptr noundef %call115, i1 noundef zeroext true)
          to label %invoke.cont116 unwind label %lpad109

invoke.cont116:                                   ; preds = %invoke.cont114
  %arrayinit.element117 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element113, i64 1
  %46 = load ptr, ptr %gpuCollidables.addr, align 8
  %call119 = invoke noundef ptr @_ZNK13b3OpenCLArrayI12b3CollidableE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %46)
          to label %invoke.cont118 unwind label %lpad109

invoke.cont118:                                   ; preds = %invoke.cont116
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element117, ptr noundef %call119, i1 noundef zeroext true)
          to label %invoke.cont120 unwind label %lpad109

invoke.cont120:                                   ; preds = %invoke.cont118
  %arrayinit.element121 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element117, i64 1
  %47 = load ptr, ptr %convexData.addr, align 8
  %call123 = invoke noundef ptr @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %47)
          to label %invoke.cont122 unwind label %lpad109

invoke.cont122:                                   ; preds = %invoke.cont120
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element121, ptr noundef %call123, i1 noundef zeroext true)
          to label %invoke.cont124 unwind label %lpad109

invoke.cont124:                                   ; preds = %invoke.cont122
  %arrayinit.element125 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element121, i64 1
  %48 = load ptr, ptr %gpuVertices.addr, align 8
  %call127 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %48)
          to label %invoke.cont126 unwind label %lpad109

invoke.cont126:                                   ; preds = %invoke.cont124
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element125, ptr noundef %call127, i1 noundef zeroext true)
          to label %invoke.cont128 unwind label %lpad109

invoke.cont128:                                   ; preds = %invoke.cont126
  %arrayinit.element129 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element125, i64 1
  %m_sepNormals130 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 26
  %call132 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_sepNormals130)
          to label %invoke.cont131 unwind label %lpad109

invoke.cont131:                                   ; preds = %invoke.cont128
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element129, ptr noundef %call132, i1 noundef zeroext false)
          to label %invoke.cont133 unwind label %lpad109

invoke.cont133:                                   ; preds = %invoke.cont131
  %arrayinit.element134 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element129, i64 1
  %m_hasSeparatingNormals135 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 28
  %call137 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_hasSeparatingNormals135)
          to label %invoke.cont136 unwind label %lpad109

invoke.cont136:                                   ; preds = %invoke.cont133
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element134, ptr noundef %call137, i1 noundef zeroext false)
          to label %invoke.cont138 unwind label %lpad109

invoke.cont138:                                   ; preds = %invoke.cont136
  %arrayinit.element139 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element134, i64 1
  %49 = load ptr, ptr %contactOut.addr, align 8
  %call141 = invoke noundef ptr @_ZNK13b3OpenCLArrayI10b3Contact4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %49)
          to label %invoke.cont140 unwind label %lpad109

invoke.cont140:                                   ; preds = %invoke.cont138
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element139, ptr noundef %call141, i1 noundef zeroext false)
          to label %invoke.cont142 unwind label %lpad109

invoke.cont142:                                   ; preds = %invoke.cont140
  %arrayinit.element143 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element139, i64 1
  %m_totalContactsOut144 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %call146 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut144)
          to label %invoke.cont145 unwind label %lpad109

invoke.cont145:                                   ; preds = %invoke.cont142
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element143, ptr noundef %call146, i1 noundef zeroext false)
          to label %invoke.cont147 unwind label %lpad109

invoke.cont147:                                   ; preds = %invoke.cont145
  %m_queue149 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %50 = load ptr, ptr %m_queue149, align 8
  %m_mprPenetrationKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 5
  %51 = load ptr, ptr %m_mprPenetrationKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher148, ptr noundef %50, ptr noundef %51, ptr noundef @.str.4)
          to label %invoke.cont150 unwind label %lpad109

invoke.cont150:                                   ; preds = %invoke.cont147
  %arraydecay151 = getelementptr inbounds [9 x %struct.b3BufferInfoCL], ptr %bInfo107, i64 0, i64 0
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher148, ptr noundef %arraydecay151, i32 noundef 9)
          to label %invoke.cont153 unwind label %lpad152

invoke.cont153:                                   ; preds = %invoke.cont150
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher148, ptr noundef nonnull align 4 dereferenceable(4) %maxContactCapacity.addr)
          to label %invoke.cont154 unwind label %lpad152

invoke.cont154:                                   ; preds = %invoke.cont153
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher148, ptr noundef nonnull align 4 dereferenceable(4) %nPairs.addr)
          to label %invoke.cont155 unwind label %lpad152

invoke.cont155:                                   ; preds = %invoke.cont154
  %52 = load i32, ptr %nPairs.addr, align 4
  store i32 %52, ptr %num156, align 4
  %53 = load i32, ptr %num156, align 4
  invoke void @_ZN12b3LauncherCL8launch1DEii(ptr noundef nonnull align 8 dereferenceable(112) %launcher148, i32 noundef %53, i32 noundef 64)
          to label %invoke.cont157 unwind label %lpad152

invoke.cont157:                                   ; preds = %invoke.cont155
  %54 = load ptr, ptr @__clewFinish, align 8
  %m_queue158 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %55 = load ptr, ptr %m_queue158, align 8
  %call160 = invoke i32 %54(ptr noundef %55)
          to label %invoke.cont159 unwind label %lpad152

invoke.cont159:                                   ; preds = %invoke.cont157
  %m_totalContactsOut161 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %call163 = invoke noundef i32 @_ZNK13b3OpenCLArrayIiE2atEm(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut161, i64 noundef 0)
          to label %invoke.cont162 unwind label %lpad152

invoke.cont162:                                   ; preds = %invoke.cont159
  %56 = load ptr, ptr %nContacts.addr, align 8
  store i32 %call163, ptr %56, align 4
  %57 = load ptr, ptr %contactOut.addr, align 8
  %58 = load ptr, ptr %nContacts.addr, align 8
  %59 = load i32, ptr %58, align 4
  %conv164 = sext i32 %59 to i64
  %call166 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI10b3Contact4E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %57, i64 noundef %conv164, i1 noundef zeroext true)
          to label %invoke.cont165 unwind label %lpad152

invoke.cont165:                                   ; preds = %invoke.cont162
  %60 = load ptr, ptr %nContacts.addr, align 8
  %61 = load i32, ptr %60, align 4
  %62 = load i32, ptr %maxContactCapacity.addr, align 4
  %cmp = icmp sgt i32 %61, %62
  br i1 %cmp, label %if.then167, label %if.end170

if.then167:                                       ; preds = %invoke.cont165
  br label %do.body

do.body:                                          ; preds = %if.then167
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.31, i32 noundef 2853)
          to label %invoke.cont168 unwind label %lpad152

invoke.cont168:                                   ; preds = %do.body
  %63 = load ptr, ptr %nContacts.addr, align 8
  %64 = load i32, ptr %63, align 4
  %65 = load i32, ptr %maxContactCapacity.addr, align 4
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.41, i32 noundef %64, i32 noundef %65)
          to label %invoke.cont169 unwind label %lpad152

invoke.cont169:                                   ; preds = %invoke.cont168
  br label %do.cond

do.cond:                                          ; preds = %invoke.cont169
  br label %do.end

do.end:                                           ; preds = %do.cond
  %66 = load i32, ptr %maxContactCapacity.addr, align 4
  %67 = load ptr, ptr %nContacts.addr, align 8
  store i32 %66, ptr %67, align 4
  br label %if.end170

lpad58:                                           ; preds = %if.then2293, %if.else2203, %if.else2131, %invoke.cont2126, %invoke.cont2122, %if.then2072, %if.end2067, %if.else2016, %if.then1951, %if.then1945, %if.then1939, %if.then1857, %if.else1703, %if.else1616, %invoke.cont1522, %invoke.cont1434, %if.then1431, %invoke.cont1422, %invoke.cont1419, %invoke.cont1416, %if.then1414, %if.end1409, %invoke.cont1404, %do.body1403, %if.else1323, %if.then1272, %land.lhs.true1266, %if.end1262, %if.then1192, %if.then1109, %invoke.cont1102, %invoke.cont1098, %if.end1095, %invoke.cont1091, %do.body1090, %if.then1084, %if.else978, %if.then890, %if.end885, %if.else445, %if.else, %if.then318, %invoke.cont239, %if.end173, %invoke.cont103, %if.then101, %if.then94, %invoke.cont88, %invoke.cont84, %invoke.cont82, %invoke.cont79, %invoke.cont76, %invoke.cont73, %invoke.cont70, %invoke.cont68, %invoke.cont65, %invoke.cont62, %invoke.cont59, %if.end55
  %68 = landingpad { ptr, i32 }
          cleanup
  %69 = extractvalue { ptr, i32 } %68, 0
  store ptr %69, ptr %exn.slot, align 8
  %70 = extractvalue { ptr, i32 } %68, 1
  store i32 %70, ptr %ehselector.slot, align 4
  br label %ehcleanup2980

lpad109:                                          ; preds = %invoke.cont147, %invoke.cont145, %invoke.cont142, %invoke.cont140, %invoke.cont138, %invoke.cont136, %invoke.cont133, %invoke.cont131, %invoke.cont128, %invoke.cont126, %invoke.cont124, %invoke.cont122, %invoke.cont120, %invoke.cont118, %invoke.cont116, %invoke.cont114, %invoke.cont112, %invoke.cont110, %invoke.cont106
  %71 = landingpad { ptr, i32 }
          cleanup
  %72 = extractvalue { ptr, i32 } %71, 0
  store ptr %72, ptr %exn.slot, align 8
  %73 = extractvalue { ptr, i32 } %71, 1
  store i32 %73, ptr %ehselector.slot, align 4
  br label %ehcleanup172

lpad152:                                          ; preds = %invoke.cont168, %do.body, %invoke.cont162, %invoke.cont159, %invoke.cont157, %invoke.cont155, %invoke.cont154, %invoke.cont153, %invoke.cont150
  %74 = landingpad { ptr, i32 }
          cleanup
  %75 = extractvalue { ptr, i32 } %74, 0
  store ptr %75, ptr %exn.slot, align 8
  %76 = extractvalue { ptr, i32 } %74, 1
  store i32 %76, ptr %ehselector.slot, align 4
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher148) #13
  br label %ehcleanup172

if.end170:                                        ; preds = %do.end, %invoke.cont165
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher148) #13
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile105) #13
  br label %if.end173

ehcleanup172:                                     ; preds = %lpad152, %lpad109
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile105) #13
  br label %ehcleanup2980

if.end173:                                        ; preds = %if.end170, %if.then99
  invoke void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %__profile174, ptr noundef @.str.10)
          to label %invoke.cont175 unwind label %lpad58

invoke.cont175:                                   ; preds = %if.end173
  %arrayinit.begin177 = getelementptr inbounds [12 x %struct.b3BufferInfoCL], ptr %bInfo176, i64 0, i64 0
  %77 = load ptr, ptr %pairs.addr, align 8
  %call180 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %77)
          to label %invoke.cont179 unwind label %lpad178

invoke.cont179:                                   ; preds = %invoke.cont175
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.begin177, ptr noundef %call180, i1 noundef zeroext true)
          to label %invoke.cont181 unwind label %lpad178

invoke.cont181:                                   ; preds = %invoke.cont179
  %arrayinit.element182 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.begin177, i64 1
  %78 = load ptr, ptr %bodyBuf.addr, align 8
  %call184 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %78)
          to label %invoke.cont183 unwind label %lpad178

invoke.cont183:                                   ; preds = %invoke.cont181
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element182, ptr noundef %call184, i1 noundef zeroext true)
          to label %invoke.cont185 unwind label %lpad178

invoke.cont185:                                   ; preds = %invoke.cont183
  %arrayinit.element186 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element182, i64 1
  %79 = load ptr, ptr %gpuCollidables.addr, align 8
  %call188 = invoke noundef ptr @_ZNK13b3OpenCLArrayI12b3CollidableE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %79)
          to label %invoke.cont187 unwind label %lpad178

invoke.cont187:                                   ; preds = %invoke.cont185
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element186, ptr noundef %call188, i1 noundef zeroext true)
          to label %invoke.cont189 unwind label %lpad178

invoke.cont189:                                   ; preds = %invoke.cont187
  %arrayinit.element190 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element186, i64 1
  %80 = load ptr, ptr %convexData.addr, align 8
  %call192 = invoke noundef ptr @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %80)
          to label %invoke.cont191 unwind label %lpad178

invoke.cont191:                                   ; preds = %invoke.cont189
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element190, ptr noundef %call192, i1 noundef zeroext true)
          to label %invoke.cont193 unwind label %lpad178

invoke.cont193:                                   ; preds = %invoke.cont191
  %arrayinit.element194 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element190, i64 1
  %81 = load ptr, ptr %gpuVertices.addr, align 8
  %call196 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %81)
          to label %invoke.cont195 unwind label %lpad178

invoke.cont195:                                   ; preds = %invoke.cont193
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element194, ptr noundef %call196, i1 noundef zeroext true)
          to label %invoke.cont197 unwind label %lpad178

invoke.cont197:                                   ; preds = %invoke.cont195
  %arrayinit.element198 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element194, i64 1
  %82 = load ptr, ptr %gpuUniqueEdges.addr, align 8
  %call200 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %82)
          to label %invoke.cont199 unwind label %lpad178

invoke.cont199:                                   ; preds = %invoke.cont197
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element198, ptr noundef %call200, i1 noundef zeroext true)
          to label %invoke.cont201 unwind label %lpad178

invoke.cont201:                                   ; preds = %invoke.cont199
  %arrayinit.element202 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element198, i64 1
  %83 = load ptr, ptr %gpuFaces.addr, align 8
  %call204 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3GpuFaceE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %83)
          to label %invoke.cont203 unwind label %lpad178

invoke.cont203:                                   ; preds = %invoke.cont201
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element202, ptr noundef %call204, i1 noundef zeroext true)
          to label %invoke.cont205 unwind label %lpad178

invoke.cont205:                                   ; preds = %invoke.cont203
  %arrayinit.element206 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element202, i64 1
  %84 = load ptr, ptr %gpuIndices.addr, align 8
  %call208 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %84)
          to label %invoke.cont207 unwind label %lpad178

invoke.cont207:                                   ; preds = %invoke.cont205
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element206, ptr noundef %call208, i1 noundef zeroext true)
          to label %invoke.cont209 unwind label %lpad178

invoke.cont209:                                   ; preds = %invoke.cont207
  %arrayinit.element210 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element206, i64 1
  %85 = load ptr, ptr %clAabbsWorldSpace.addr, align 8
  %call212 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3AabbE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %85)
          to label %invoke.cont211 unwind label %lpad178

invoke.cont211:                                   ; preds = %invoke.cont209
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element210, ptr noundef %call212, i1 noundef zeroext true)
          to label %invoke.cont213 unwind label %lpad178

invoke.cont213:                                   ; preds = %invoke.cont211
  %arrayinit.element214 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element210, i64 1
  %m_sepNormals215 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 26
  %call217 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_sepNormals215)
          to label %invoke.cont216 unwind label %lpad178

invoke.cont216:                                   ; preds = %invoke.cont213
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element214, ptr noundef %call217, i1 noundef zeroext false)
          to label %invoke.cont218 unwind label %lpad178

invoke.cont218:                                   ; preds = %invoke.cont216
  %arrayinit.element219 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element214, i64 1
  %m_hasSeparatingNormals220 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 28
  %call222 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_hasSeparatingNormals220)
          to label %invoke.cont221 unwind label %lpad178

invoke.cont221:                                   ; preds = %invoke.cont218
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element219, ptr noundef %call222, i1 noundef zeroext false)
          to label %invoke.cont223 unwind label %lpad178

invoke.cont223:                                   ; preds = %invoke.cont221
  %arrayinit.element224 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element219, i64 1
  %m_dmins225 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 27
  %call227 = invoke noundef ptr @_ZNK13b3OpenCLArrayIfE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_dmins225)
          to label %invoke.cont226 unwind label %lpad178

invoke.cont226:                                   ; preds = %invoke.cont223
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element224, ptr noundef %call227, i1 noundef zeroext false)
          to label %invoke.cont228 unwind label %lpad178

invoke.cont228:                                   ; preds = %invoke.cont226
  %m_queue230 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %86 = load ptr, ptr %m_queue230, align 8
  %m_findSeparatingAxisVertexFaceKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 7
  %87 = load ptr, ptr %m_findSeparatingAxisVertexFaceKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher229, ptr noundef %86, ptr noundef %87, ptr noundef @.str.10)
          to label %invoke.cont231 unwind label %lpad178

invoke.cont231:                                   ; preds = %invoke.cont228
  %arraydecay232 = getelementptr inbounds [12 x %struct.b3BufferInfoCL], ptr %bInfo176, i64 0, i64 0
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher229, ptr noundef %arraydecay232, i32 noundef 12)
          to label %invoke.cont234 unwind label %lpad233

invoke.cont234:                                   ; preds = %invoke.cont231
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher229, ptr noundef nonnull align 4 dereferenceable(4) %nPairs.addr)
          to label %invoke.cont235 unwind label %lpad233

invoke.cont235:                                   ; preds = %invoke.cont234
  %88 = load i32, ptr %nPairs.addr, align 4
  store i32 %88, ptr %num236, align 4
  %89 = load i32, ptr %num236, align 4
  invoke void @_ZN12b3LauncherCL8launch1DEii(ptr noundef nonnull align 8 dereferenceable(112) %launcher229, i32 noundef %89, i32 noundef 64)
          to label %invoke.cont237 unwind label %lpad233

invoke.cont237:                                   ; preds = %invoke.cont235
  %90 = load ptr, ptr @__clewFinish, align 8
  %m_queue238 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %91 = load ptr, ptr %m_queue238, align 8
  %call240 = invoke i32 %90(ptr noundef %91)
          to label %invoke.cont239 unwind label %lpad233

invoke.cont239:                                   ; preds = %invoke.cont237
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher229) #13
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile174) #13
  store i32 162, ptr %numDirections, align 4
  invoke void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %__profile243, ptr noundef @.str.11)
          to label %invoke.cont244 unwind label %lpad58

invoke.cont244:                                   ; preds = %invoke.cont239
  %arrayinit.begin246 = getelementptr inbounds [13 x %struct.b3BufferInfoCL], ptr %bInfo245, i64 0, i64 0
  %92 = load ptr, ptr %pairs.addr, align 8
  %call249 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %92)
          to label %invoke.cont248 unwind label %lpad247

invoke.cont248:                                   ; preds = %invoke.cont244
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.begin246, ptr noundef %call249, i1 noundef zeroext true)
          to label %invoke.cont250 unwind label %lpad247

invoke.cont250:                                   ; preds = %invoke.cont248
  %arrayinit.element251 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.begin246, i64 1
  %93 = load ptr, ptr %bodyBuf.addr, align 8
  %call253 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %93)
          to label %invoke.cont252 unwind label %lpad247

invoke.cont252:                                   ; preds = %invoke.cont250
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element251, ptr noundef %call253, i1 noundef zeroext true)
          to label %invoke.cont254 unwind label %lpad247

invoke.cont254:                                   ; preds = %invoke.cont252
  %arrayinit.element255 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element251, i64 1
  %94 = load ptr, ptr %gpuCollidables.addr, align 8
  %call257 = invoke noundef ptr @_ZNK13b3OpenCLArrayI12b3CollidableE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %94)
          to label %invoke.cont256 unwind label %lpad247

invoke.cont256:                                   ; preds = %invoke.cont254
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element255, ptr noundef %call257, i1 noundef zeroext true)
          to label %invoke.cont258 unwind label %lpad247

invoke.cont258:                                   ; preds = %invoke.cont256
  %arrayinit.element259 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element255, i64 1
  %95 = load ptr, ptr %convexData.addr, align 8
  %call261 = invoke noundef ptr @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %95)
          to label %invoke.cont260 unwind label %lpad247

invoke.cont260:                                   ; preds = %invoke.cont258
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element259, ptr noundef %call261, i1 noundef zeroext true)
          to label %invoke.cont262 unwind label %lpad247

invoke.cont262:                                   ; preds = %invoke.cont260
  %arrayinit.element263 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element259, i64 1
  %96 = load ptr, ptr %gpuVertices.addr, align 8
  %call265 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %96)
          to label %invoke.cont264 unwind label %lpad247

invoke.cont264:                                   ; preds = %invoke.cont262
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element263, ptr noundef %call265, i1 noundef zeroext true)
          to label %invoke.cont266 unwind label %lpad247

invoke.cont266:                                   ; preds = %invoke.cont264
  %arrayinit.element267 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element263, i64 1
  %97 = load ptr, ptr %gpuUniqueEdges.addr, align 8
  %call269 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %97)
          to label %invoke.cont268 unwind label %lpad247

invoke.cont268:                                   ; preds = %invoke.cont266
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element267, ptr noundef %call269, i1 noundef zeroext true)
          to label %invoke.cont270 unwind label %lpad247

invoke.cont270:                                   ; preds = %invoke.cont268
  %arrayinit.element271 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element267, i64 1
  %98 = load ptr, ptr %gpuFaces.addr, align 8
  %call273 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3GpuFaceE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %98)
          to label %invoke.cont272 unwind label %lpad247

invoke.cont272:                                   ; preds = %invoke.cont270
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element271, ptr noundef %call273, i1 noundef zeroext true)
          to label %invoke.cont274 unwind label %lpad247

invoke.cont274:                                   ; preds = %invoke.cont272
  %arrayinit.element275 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element271, i64 1
  %99 = load ptr, ptr %gpuIndices.addr, align 8
  %call277 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %99)
          to label %invoke.cont276 unwind label %lpad247

invoke.cont276:                                   ; preds = %invoke.cont274
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element275, ptr noundef %call277, i1 noundef zeroext true)
          to label %invoke.cont278 unwind label %lpad247

invoke.cont278:                                   ; preds = %invoke.cont276
  %arrayinit.element279 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element275, i64 1
  %100 = load ptr, ptr %clAabbsWorldSpace.addr, align 8
  %call281 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3AabbE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %100)
          to label %invoke.cont280 unwind label %lpad247

invoke.cont280:                                   ; preds = %invoke.cont278
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element279, ptr noundef %call281, i1 noundef zeroext true)
          to label %invoke.cont282 unwind label %lpad247

invoke.cont282:                                   ; preds = %invoke.cont280
  %arrayinit.element283 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element279, i64 1
  %m_sepNormals284 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 26
  %call286 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_sepNormals284)
          to label %invoke.cont285 unwind label %lpad247

invoke.cont285:                                   ; preds = %invoke.cont282
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element283, ptr noundef %call286, i1 noundef zeroext false)
          to label %invoke.cont287 unwind label %lpad247

invoke.cont287:                                   ; preds = %invoke.cont285
  %arrayinit.element288 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element283, i64 1
  %m_hasSeparatingNormals289 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 28
  %call291 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_hasSeparatingNormals289)
          to label %invoke.cont290 unwind label %lpad247

invoke.cont290:                                   ; preds = %invoke.cont287
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element288, ptr noundef %call291, i1 noundef zeroext false)
          to label %invoke.cont292 unwind label %lpad247

invoke.cont292:                                   ; preds = %invoke.cont290
  %arrayinit.element293 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element288, i64 1
  %m_dmins294 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 27
  %call296 = invoke noundef ptr @_ZNK13b3OpenCLArrayIfE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_dmins294)
          to label %invoke.cont295 unwind label %lpad247

invoke.cont295:                                   ; preds = %invoke.cont292
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element293, ptr noundef %call296, i1 noundef zeroext false)
          to label %invoke.cont297 unwind label %lpad247

invoke.cont297:                                   ; preds = %invoke.cont295
  %arrayinit.element298 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element293, i64 1
  %m_unitSphereDirections = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 24
  %call300 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_unitSphereDirections)
          to label %invoke.cont299 unwind label %lpad247

invoke.cont299:                                   ; preds = %invoke.cont297
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element298, ptr noundef %call300, i1 noundef zeroext true)
          to label %invoke.cont301 unwind label %lpad247

invoke.cont301:                                   ; preds = %invoke.cont299
  %m_queue303 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %101 = load ptr, ptr %m_queue303, align 8
  %m_findSeparatingAxisEdgeEdgeKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 8
  %102 = load ptr, ptr %m_findSeparatingAxisEdgeEdgeKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher302, ptr noundef %101, ptr noundef %102, ptr noundef @.str.11)
          to label %invoke.cont304 unwind label %lpad247

invoke.cont304:                                   ; preds = %invoke.cont301
  %arraydecay305 = getelementptr inbounds [13 x %struct.b3BufferInfoCL], ptr %bInfo245, i64 0, i64 0
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher302, ptr noundef %arraydecay305, i32 noundef 13)
          to label %invoke.cont307 unwind label %lpad306

invoke.cont307:                                   ; preds = %invoke.cont304
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher302, ptr noundef nonnull align 4 dereferenceable(4) %numDirections)
          to label %invoke.cont308 unwind label %lpad306

invoke.cont308:                                   ; preds = %invoke.cont307
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher302, ptr noundef nonnull align 4 dereferenceable(4) %nPairs.addr)
          to label %invoke.cont309 unwind label %lpad306

invoke.cont309:                                   ; preds = %invoke.cont308
  %103 = load i32, ptr %nPairs.addr, align 4
  store i32 %103, ptr %num310, align 4
  %104 = load i32, ptr %num310, align 4
  invoke void @_ZN12b3LauncherCL8launch1DEii(ptr noundef nonnull align 8 dereferenceable(112) %launcher302, i32 noundef %104, i32 noundef 64)
          to label %invoke.cont311 unwind label %lpad306

invoke.cont311:                                   ; preds = %invoke.cont309
  %105 = load ptr, ptr @__clewFinish, align 8
  %m_queue312 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %106 = load ptr, ptr %m_queue312, align 8
  %call314 = invoke i32 %105(ptr noundef %106)
          to label %invoke.cont313 unwind label %lpad306

invoke.cont313:                                   ; preds = %invoke.cont311
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher302) #13
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile243) #13
  %107 = load i8, ptr @useMprGpu, align 1
  %tobool317 = trunc i8 %107 to i1
  br i1 %tobool317, label %if.then318, label %if.end379

if.then318:                                       ; preds = %invoke.cont313
  invoke void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %__profile319, ptr noundef @.str.6)
          to label %invoke.cont320 unwind label %lpad58

invoke.cont320:                                   ; preds = %if.then318
  %arrayinit.begin322 = getelementptr inbounds [9 x %struct.b3BufferInfoCL], ptr %bInfo321, i64 0, i64 0
  %108 = load ptr, ptr %pairs.addr, align 8
  %call325 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %108)
          to label %invoke.cont324 unwind label %lpad323

invoke.cont324:                                   ; preds = %invoke.cont320
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.begin322, ptr noundef %call325, i1 noundef zeroext true)
          to label %invoke.cont326 unwind label %lpad323

invoke.cont326:                                   ; preds = %invoke.cont324
  %arrayinit.element327 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.begin322, i64 1
  %109 = load ptr, ptr %bodyBuf.addr, align 8
  %call329 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %109)
          to label %invoke.cont328 unwind label %lpad323

invoke.cont328:                                   ; preds = %invoke.cont326
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element327, ptr noundef %call329, i1 noundef zeroext true)
          to label %invoke.cont330 unwind label %lpad323

invoke.cont330:                                   ; preds = %invoke.cont328
  %arrayinit.element331 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element327, i64 1
  %110 = load ptr, ptr %gpuCollidables.addr, align 8
  %call333 = invoke noundef ptr @_ZNK13b3OpenCLArrayI12b3CollidableE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %110)
          to label %invoke.cont332 unwind label %lpad323

invoke.cont332:                                   ; preds = %invoke.cont330
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element331, ptr noundef %call333, i1 noundef zeroext true)
          to label %invoke.cont334 unwind label %lpad323

invoke.cont334:                                   ; preds = %invoke.cont332
  %arrayinit.element335 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element331, i64 1
  %111 = load ptr, ptr %convexData.addr, align 8
  %call337 = invoke noundef ptr @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %111)
          to label %invoke.cont336 unwind label %lpad323

invoke.cont336:                                   ; preds = %invoke.cont334
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element335, ptr noundef %call337, i1 noundef zeroext true)
          to label %invoke.cont338 unwind label %lpad323

invoke.cont338:                                   ; preds = %invoke.cont336
  %arrayinit.element339 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element335, i64 1
  %112 = load ptr, ptr %gpuVertices.addr, align 8
  %call341 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %112)
          to label %invoke.cont340 unwind label %lpad323

invoke.cont340:                                   ; preds = %invoke.cont338
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element339, ptr noundef %call341, i1 noundef zeroext true)
          to label %invoke.cont342 unwind label %lpad323

invoke.cont342:                                   ; preds = %invoke.cont340
  %arrayinit.element343 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element339, i64 1
  %m_unitSphereDirections344 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 24
  %call346 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_unitSphereDirections344)
          to label %invoke.cont345 unwind label %lpad323

invoke.cont345:                                   ; preds = %invoke.cont342
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element343, ptr noundef %call346, i1 noundef zeroext true)
          to label %invoke.cont347 unwind label %lpad323

invoke.cont347:                                   ; preds = %invoke.cont345
  %arrayinit.element348 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element343, i64 1
  %m_sepNormals349 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 26
  %call351 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_sepNormals349)
          to label %invoke.cont350 unwind label %lpad323

invoke.cont350:                                   ; preds = %invoke.cont347
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element348, ptr noundef %call351, i1 noundef zeroext false)
          to label %invoke.cont352 unwind label %lpad323

invoke.cont352:                                   ; preds = %invoke.cont350
  %arrayinit.element353 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element348, i64 1
  %m_hasSeparatingNormals354 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 28
  %call356 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_hasSeparatingNormals354)
          to label %invoke.cont355 unwind label %lpad323

invoke.cont355:                                   ; preds = %invoke.cont352
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element353, ptr noundef %call356, i1 noundef zeroext false)
          to label %invoke.cont357 unwind label %lpad323

invoke.cont357:                                   ; preds = %invoke.cont355
  %arrayinit.element358 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element353, i64 1
  %m_dmins359 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 27
  %call361 = invoke noundef ptr @_ZNK13b3OpenCLArrayIfE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_dmins359)
          to label %invoke.cont360 unwind label %lpad323

invoke.cont360:                                   ; preds = %invoke.cont357
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element358, ptr noundef %call361, i1 noundef zeroext false)
          to label %invoke.cont362 unwind label %lpad323

invoke.cont362:                                   ; preds = %invoke.cont360
  %m_queue364 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %113 = load ptr, ptr %m_queue364, align 8
  %m_findSeparatingAxisUnitSphereKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 6
  %114 = load ptr, ptr %m_findSeparatingAxisUnitSphereKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher363, ptr noundef %113, ptr noundef %114, ptr noundef @.str.6)
          to label %invoke.cont365 unwind label %lpad323

invoke.cont365:                                   ; preds = %invoke.cont362
  %arraydecay366 = getelementptr inbounds [9 x %struct.b3BufferInfoCL], ptr %bInfo321, i64 0, i64 0
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher363, ptr noundef %arraydecay366, i32 noundef 9)
          to label %invoke.cont368 unwind label %lpad367

invoke.cont368:                                   ; preds = %invoke.cont365
  store i32 162, ptr %numDirections369, align 4
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher363, ptr noundef nonnull align 4 dereferenceable(4) %numDirections369)
          to label %invoke.cont370 unwind label %lpad367

invoke.cont370:                                   ; preds = %invoke.cont368
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher363, ptr noundef nonnull align 4 dereferenceable(4) %nPairs.addr)
          to label %invoke.cont371 unwind label %lpad367

invoke.cont371:                                   ; preds = %invoke.cont370
  %115 = load i32, ptr %nPairs.addr, align 4
  store i32 %115, ptr %num372, align 4
  %116 = load i32, ptr %num372, align 4
  invoke void @_ZN12b3LauncherCL8launch1DEii(ptr noundef nonnull align 8 dereferenceable(112) %launcher363, i32 noundef %116, i32 noundef 64)
          to label %invoke.cont373 unwind label %lpad367

invoke.cont373:                                   ; preds = %invoke.cont371
  %117 = load ptr, ptr @__clewFinish, align 8
  %m_queue374 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %118 = load ptr, ptr %m_queue374, align 8
  %call376 = invoke i32 %117(ptr noundef %118)
          to label %invoke.cont375 unwind label %lpad367

invoke.cont375:                                   ; preds = %invoke.cont373
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher363) #13
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile319) #13
  br label %if.end379

lpad178:                                          ; preds = %invoke.cont228, %invoke.cont226, %invoke.cont223, %invoke.cont221, %invoke.cont218, %invoke.cont216, %invoke.cont213, %invoke.cont211, %invoke.cont209, %invoke.cont207, %invoke.cont205, %invoke.cont203, %invoke.cont201, %invoke.cont199, %invoke.cont197, %invoke.cont195, %invoke.cont193, %invoke.cont191, %invoke.cont189, %invoke.cont187, %invoke.cont185, %invoke.cont183, %invoke.cont181, %invoke.cont179, %invoke.cont175
  %119 = landingpad { ptr, i32 }
          cleanup
  %120 = extractvalue { ptr, i32 } %119, 0
  store ptr %120, ptr %exn.slot, align 8
  %121 = extractvalue { ptr, i32 } %119, 1
  store i32 %121, ptr %ehselector.slot, align 4
  br label %ehcleanup242

lpad233:                                          ; preds = %invoke.cont237, %invoke.cont235, %invoke.cont234, %invoke.cont231
  %122 = landingpad { ptr, i32 }
          cleanup
  %123 = extractvalue { ptr, i32 } %122, 0
  store ptr %123, ptr %exn.slot, align 8
  %124 = extractvalue { ptr, i32 } %122, 1
  store i32 %124, ptr %ehselector.slot, align 4
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher229) #13
  br label %ehcleanup242

ehcleanup242:                                     ; preds = %lpad233, %lpad178
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile174) #13
  br label %ehcleanup2980

lpad247:                                          ; preds = %invoke.cont301, %invoke.cont299, %invoke.cont297, %invoke.cont295, %invoke.cont292, %invoke.cont290, %invoke.cont287, %invoke.cont285, %invoke.cont282, %invoke.cont280, %invoke.cont278, %invoke.cont276, %invoke.cont274, %invoke.cont272, %invoke.cont270, %invoke.cont268, %invoke.cont266, %invoke.cont264, %invoke.cont262, %invoke.cont260, %invoke.cont258, %invoke.cont256, %invoke.cont254, %invoke.cont252, %invoke.cont250, %invoke.cont248, %invoke.cont244
  %125 = landingpad { ptr, i32 }
          cleanup
  %126 = extractvalue { ptr, i32 } %125, 0
  store ptr %126, ptr %exn.slot, align 8
  %127 = extractvalue { ptr, i32 } %125, 1
  store i32 %127, ptr %ehselector.slot, align 4
  br label %ehcleanup316

lpad306:                                          ; preds = %invoke.cont311, %invoke.cont309, %invoke.cont308, %invoke.cont307, %invoke.cont304
  %128 = landingpad { ptr, i32 }
          cleanup
  %129 = extractvalue { ptr, i32 } %128, 0
  store ptr %129, ptr %exn.slot, align 8
  %130 = extractvalue { ptr, i32 } %128, 1
  store i32 %130, ptr %ehselector.slot, align 4
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher302) #13
  br label %ehcleanup316

ehcleanup316:                                     ; preds = %lpad306, %lpad247
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile243) #13
  br label %ehcleanup2980

lpad323:                                          ; preds = %invoke.cont362, %invoke.cont360, %invoke.cont357, %invoke.cont355, %invoke.cont352, %invoke.cont350, %invoke.cont347, %invoke.cont345, %invoke.cont342, %invoke.cont340, %invoke.cont338, %invoke.cont336, %invoke.cont334, %invoke.cont332, %invoke.cont330, %invoke.cont328, %invoke.cont326, %invoke.cont324, %invoke.cont320
  %131 = landingpad { ptr, i32 }
          cleanup
  %132 = extractvalue { ptr, i32 } %131, 0
  store ptr %132, ptr %exn.slot, align 8
  %133 = extractvalue { ptr, i32 } %131, 1
  store i32 %133, ptr %ehselector.slot, align 4
  br label %ehcleanup378

lpad367:                                          ; preds = %invoke.cont373, %invoke.cont371, %invoke.cont370, %invoke.cont368, %invoke.cont365
  %134 = landingpad { ptr, i32 }
          cleanup
  %135 = extractvalue { ptr, i32 } %134, 0
  store ptr %135, ptr %exn.slot, align 8
  %136 = extractvalue { ptr, i32 } %134, 1
  store i32 %136, ptr %ehselector.slot, align 4
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher363) #13
  br label %ehcleanup378

ehcleanup378:                                     ; preds = %lpad367, %lpad323
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile319) #13
  br label %ehcleanup2980

if.end379:                                        ; preds = %invoke.cont375, %invoke.cont313
  br label %if.end444

if.else:                                          ; preds = %invoke.cont96
  invoke void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %__profile380, ptr noundef @.str.9)
          to label %invoke.cont381 unwind label %lpad58

invoke.cont381:                                   ; preds = %if.else
  %arrayinit.begin383 = getelementptr inbounds [11 x %struct.b3BufferInfoCL], ptr %bInfo382, i64 0, i64 0
  %137 = load ptr, ptr %pairs.addr, align 8
  %call386 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %137)
          to label %invoke.cont385 unwind label %lpad384

invoke.cont385:                                   ; preds = %invoke.cont381
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.begin383, ptr noundef %call386, i1 noundef zeroext true)
          to label %invoke.cont387 unwind label %lpad384

invoke.cont387:                                   ; preds = %invoke.cont385
  %arrayinit.element388 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.begin383, i64 1
  %138 = load ptr, ptr %bodyBuf.addr, align 8
  %call390 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %138)
          to label %invoke.cont389 unwind label %lpad384

invoke.cont389:                                   ; preds = %invoke.cont387
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element388, ptr noundef %call390, i1 noundef zeroext true)
          to label %invoke.cont391 unwind label %lpad384

invoke.cont391:                                   ; preds = %invoke.cont389
  %arrayinit.element392 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element388, i64 1
  %139 = load ptr, ptr %gpuCollidables.addr, align 8
  %call394 = invoke noundef ptr @_ZNK13b3OpenCLArrayI12b3CollidableE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %139)
          to label %invoke.cont393 unwind label %lpad384

invoke.cont393:                                   ; preds = %invoke.cont391
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element392, ptr noundef %call394, i1 noundef zeroext true)
          to label %invoke.cont395 unwind label %lpad384

invoke.cont395:                                   ; preds = %invoke.cont393
  %arrayinit.element396 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element392, i64 1
  %140 = load ptr, ptr %convexData.addr, align 8
  %call398 = invoke noundef ptr @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %140)
          to label %invoke.cont397 unwind label %lpad384

invoke.cont397:                                   ; preds = %invoke.cont395
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element396, ptr noundef %call398, i1 noundef zeroext true)
          to label %invoke.cont399 unwind label %lpad384

invoke.cont399:                                   ; preds = %invoke.cont397
  %arrayinit.element400 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element396, i64 1
  %141 = load ptr, ptr %gpuVertices.addr, align 8
  %call402 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %141)
          to label %invoke.cont401 unwind label %lpad384

invoke.cont401:                                   ; preds = %invoke.cont399
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element400, ptr noundef %call402, i1 noundef zeroext true)
          to label %invoke.cont403 unwind label %lpad384

invoke.cont403:                                   ; preds = %invoke.cont401
  %arrayinit.element404 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element400, i64 1
  %142 = load ptr, ptr %gpuUniqueEdges.addr, align 8
  %call406 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %142)
          to label %invoke.cont405 unwind label %lpad384

invoke.cont405:                                   ; preds = %invoke.cont403
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element404, ptr noundef %call406, i1 noundef zeroext true)
          to label %invoke.cont407 unwind label %lpad384

invoke.cont407:                                   ; preds = %invoke.cont405
  %arrayinit.element408 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element404, i64 1
  %143 = load ptr, ptr %gpuFaces.addr, align 8
  %call410 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3GpuFaceE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %143)
          to label %invoke.cont409 unwind label %lpad384

invoke.cont409:                                   ; preds = %invoke.cont407
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element408, ptr noundef %call410, i1 noundef zeroext true)
          to label %invoke.cont411 unwind label %lpad384

invoke.cont411:                                   ; preds = %invoke.cont409
  %arrayinit.element412 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element408, i64 1
  %144 = load ptr, ptr %gpuIndices.addr, align 8
  %call414 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %144)
          to label %invoke.cont413 unwind label %lpad384

invoke.cont413:                                   ; preds = %invoke.cont411
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element412, ptr noundef %call414, i1 noundef zeroext true)
          to label %invoke.cont415 unwind label %lpad384

invoke.cont415:                                   ; preds = %invoke.cont413
  %arrayinit.element416 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element412, i64 1
  %145 = load ptr, ptr %clAabbsWorldSpace.addr, align 8
  %call418 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3AabbE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %145)
          to label %invoke.cont417 unwind label %lpad384

invoke.cont417:                                   ; preds = %invoke.cont415
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element416, ptr noundef %call418, i1 noundef zeroext true)
          to label %invoke.cont419 unwind label %lpad384

invoke.cont419:                                   ; preds = %invoke.cont417
  %arrayinit.element420 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element416, i64 1
  %m_sepNormals421 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 26
  %call423 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_sepNormals421)
          to label %invoke.cont422 unwind label %lpad384

invoke.cont422:                                   ; preds = %invoke.cont419
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element420, ptr noundef %call423, i1 noundef zeroext false)
          to label %invoke.cont424 unwind label %lpad384

invoke.cont424:                                   ; preds = %invoke.cont422
  %arrayinit.element425 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element420, i64 1
  %m_hasSeparatingNormals426 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 28
  %call428 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_hasSeparatingNormals426)
          to label %invoke.cont427 unwind label %lpad384

invoke.cont427:                                   ; preds = %invoke.cont424
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element425, ptr noundef %call428, i1 noundef zeroext false)
          to label %invoke.cont429 unwind label %lpad384

invoke.cont429:                                   ; preds = %invoke.cont427
  %m_queue431 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %146 = load ptr, ptr %m_queue431, align 8
  %m_findSeparatingAxisKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 4
  %147 = load ptr, ptr %m_findSeparatingAxisKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher430, ptr noundef %146, ptr noundef %147, ptr noundef @.str.42)
          to label %invoke.cont432 unwind label %lpad384

invoke.cont432:                                   ; preds = %invoke.cont429
  %arraydecay433 = getelementptr inbounds [11 x %struct.b3BufferInfoCL], ptr %bInfo382, i64 0, i64 0
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher430, ptr noundef %arraydecay433, i32 noundef 11)
          to label %invoke.cont435 unwind label %lpad434

invoke.cont435:                                   ; preds = %invoke.cont432
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher430, ptr noundef nonnull align 4 dereferenceable(4) %nPairs.addr)
          to label %invoke.cont436 unwind label %lpad434

invoke.cont436:                                   ; preds = %invoke.cont435
  %148 = load i32, ptr %nPairs.addr, align 4
  store i32 %148, ptr %num437, align 4
  %149 = load i32, ptr %num437, align 4
  invoke void @_ZN12b3LauncherCL8launch1DEii(ptr noundef nonnull align 8 dereferenceable(112) %launcher430, i32 noundef %149, i32 noundef 64)
          to label %invoke.cont438 unwind label %lpad434

invoke.cont438:                                   ; preds = %invoke.cont436
  %150 = load ptr, ptr @__clewFinish, align 8
  %m_queue439 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %151 = load ptr, ptr %m_queue439, align 8
  %call441 = invoke i32 %150(ptr noundef %151)
          to label %invoke.cont440 unwind label %lpad434

invoke.cont440:                                   ; preds = %invoke.cont438
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher430) #13
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile380) #13
  br label %if.end444

lpad384:                                          ; preds = %invoke.cont429, %invoke.cont427, %invoke.cont424, %invoke.cont422, %invoke.cont419, %invoke.cont417, %invoke.cont415, %invoke.cont413, %invoke.cont411, %invoke.cont409, %invoke.cont407, %invoke.cont405, %invoke.cont403, %invoke.cont401, %invoke.cont399, %invoke.cont397, %invoke.cont395, %invoke.cont393, %invoke.cont391, %invoke.cont389, %invoke.cont387, %invoke.cont385, %invoke.cont381
  %152 = landingpad { ptr, i32 }
          cleanup
  %153 = extractvalue { ptr, i32 } %152, 0
  store ptr %153, ptr %exn.slot, align 8
  %154 = extractvalue { ptr, i32 } %152, 1
  store i32 %154, ptr %ehselector.slot, align 4
  br label %ehcleanup443

lpad434:                                          ; preds = %invoke.cont438, %invoke.cont436, %invoke.cont435, %invoke.cont432
  %155 = landingpad { ptr, i32 }
          cleanup
  %156 = extractvalue { ptr, i32 } %155, 0
  store ptr %156, ptr %exn.slot, align 8
  %157 = extractvalue { ptr, i32 } %155, 1
  store i32 %157, ptr %ehselector.slot, align 4
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher430) #13
  br label %ehcleanup443

ehcleanup443:                                     ; preds = %lpad434, %lpad384
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile380) #13
  br label %ehcleanup2980

if.end444:                                        ; preds = %invoke.cont440, %if.end379
  br label %if.end885

if.else445:                                       ; preds = %invoke.cont91
  invoke void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %__profile446, ptr noundef @.str.43)
          to label %invoke.cont447 unwind label %lpad58

invoke.cont447:                                   ; preds = %if.else445
  invoke void @_ZN20b3AlignedObjectArrayI6b3Int4EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostPairs)
          to label %invoke.cont449 unwind label %lpad448

invoke.cont449:                                   ; preds = %invoke.cont447
  %158 = load ptr, ptr %pairs.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI6b3Int4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %158, ptr noundef nonnull align 8 dereferenceable(25) %hostPairs, i1 noundef zeroext true)
          to label %invoke.cont451 unwind label %lpad450

invoke.cont451:                                   ; preds = %invoke.cont449
  invoke void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf)
          to label %invoke.cont452 unwind label %lpad450

invoke.cont452:                                   ; preds = %invoke.cont451
  %159 = load ptr, ptr %bodyBuf.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %159, ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf, i1 noundef zeroext true)
          to label %invoke.cont454 unwind label %lpad453

invoke.cont454:                                   ; preds = %invoke.cont452
  invoke void @_ZN20b3AlignedObjectArrayI12b3CollidableEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables)
          to label %invoke.cont455 unwind label %lpad453

invoke.cont455:                                   ; preds = %invoke.cont454
  %160 = load ptr, ptr %gpuCollidables.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI12b3CollidableE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %160, ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables, i1 noundef zeroext true)
          to label %invoke.cont457 unwind label %lpad456

invoke.cont457:                                   ; preds = %invoke.cont455
  invoke void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuChildShapes)
          to label %invoke.cont458 unwind label %lpad456

invoke.cont458:                                   ; preds = %invoke.cont457
  %161 = load ptr, ptr %gpuChildShapes.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI15b3GpuChildShapeE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %161, ptr noundef nonnull align 8 dereferenceable(25) %cpuChildShapes, i1 noundef zeroext true)
          to label %invoke.cont460 unwind label %lpad459

invoke.cont460:                                   ; preds = %invoke.cont458
  invoke void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexShapeData)
          to label %invoke.cont461 unwind label %lpad459

invoke.cont461:                                   ; preds = %invoke.cont460
  %162 = load ptr, ptr %convexData.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %162, ptr noundef nonnull align 8 dereferenceable(25) %hostConvexShapeData, i1 noundef zeroext true)
          to label %invoke.cont463 unwind label %lpad462

invoke.cont463:                                   ; preds = %invoke.cont461
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices)
          to label %invoke.cont464 unwind label %lpad462

invoke.cont464:                                   ; preds = %invoke.cont463
  %163 = load ptr, ptr %gpuVertices.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %163, ptr noundef nonnull align 8 dereferenceable(25) %hostVertices, i1 noundef zeroext true)
          to label %invoke.cont466 unwind label %lpad465

invoke.cont466:                                   ; preds = %invoke.cont464
  invoke void @_ZN20b3AlignedObjectArrayIiEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostHasSepAxis)
          to label %invoke.cont467 unwind label %lpad465

invoke.cont467:                                   ; preds = %invoke.cont466
  %164 = load i32, ptr %nPairs.addr, align 4
  store i32 0, ptr %ref.tmp468, align 4
  invoke void @_ZN20b3AlignedObjectArrayIiE6resizeEiRKi(ptr noundef nonnull align 8 dereferenceable(25) %hostHasSepAxis, i32 noundef %164, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp468)
          to label %invoke.cont470 unwind label %lpad469

invoke.cont470:                                   ; preds = %invoke.cont467
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostSepAxis)
          to label %invoke.cont471 unwind label %lpad469

invoke.cont471:                                   ; preds = %invoke.cont470
  %165 = load i32, ptr %nPairs.addr, align 4
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp472, i8 0, i64 16, i1 false)
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %hostSepAxis, i32 noundef %165, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp472)
          to label %invoke.cont474 unwind label %lpad473

invoke.cont474:                                   ; preds = %invoke.cont471
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges)
          to label %invoke.cont475 unwind label %lpad473

invoke.cont475:                                   ; preds = %invoke.cont474
  %166 = load ptr, ptr %gpuUniqueEdges.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %166, ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges, i1 noundef zeroext true)
          to label %invoke.cont477 unwind label %lpad476

invoke.cont477:                                   ; preds = %invoke.cont475
  invoke void @_ZN20b3AlignedObjectArrayI9b3GpuFaceEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostFaces)
          to label %invoke.cont478 unwind label %lpad476

invoke.cont478:                                   ; preds = %invoke.cont477
  %167 = load ptr, ptr %gpuFaces.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3GpuFaceE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %167, ptr noundef nonnull align 8 dereferenceable(25) %hostFaces, i1 noundef zeroext true)
          to label %invoke.cont480 unwind label %lpad479

invoke.cont480:                                   ; preds = %invoke.cont478
  invoke void @_ZN20b3AlignedObjectArrayIiEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostIndices)
          to label %invoke.cont481 unwind label %lpad479

invoke.cont481:                                   ; preds = %invoke.cont480
  %168 = load ptr, ptr %gpuIndices.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayIiE10copyToHostER20b3AlignedObjectArrayIiEb(ptr noundef nonnull align 8 dereferenceable(50) %168, ptr noundef nonnull align 8 dereferenceable(25) %hostIndices, i1 noundef zeroext true)
          to label %invoke.cont483 unwind label %lpad482

invoke.cont483:                                   ; preds = %invoke.cont481
  invoke void @_ZN20b3AlignedObjectArrayI10b3Contact4EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostContacts)
          to label %invoke.cont484 unwind label %lpad482

invoke.cont484:                                   ; preds = %invoke.cont483
  %169 = load ptr, ptr %nContacts.addr, align 8
  %170 = load i32, ptr %169, align 4
  %tobool485 = icmp ne i32 %170, 0
  br i1 %tobool485, label %if.then486, label %if.end489

if.then486:                                       ; preds = %invoke.cont484
  %171 = load ptr, ptr %contactOut.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI10b3Contact4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %171, ptr noundef nonnull align 8 dereferenceable(25) %hostContacts, i1 noundef zeroext true)
          to label %invoke.cont488 unwind label %lpad487

invoke.cont488:                                   ; preds = %if.then486
  br label %if.end489

lpad448:                                          ; preds = %invoke.cont447
  %172 = landingpad { ptr, i32 }
          cleanup
  %173 = extractvalue { ptr, i32 } %172, 0
  store ptr %173, ptr %exn.slot, align 8
  %174 = extractvalue { ptr, i32 } %172, 1
  store i32 %174, ptr %ehselector.slot, align 4
  br label %ehcleanup884

lpad450:                                          ; preds = %invoke.cont451, %invoke.cont449
  %175 = landingpad { ptr, i32 }
          cleanup
  %176 = extractvalue { ptr, i32 } %175, 0
  store ptr %176, ptr %exn.slot, align 8
  %177 = extractvalue { ptr, i32 } %175, 1
  store i32 %177, ptr %ehselector.slot, align 4
  br label %ehcleanup883

lpad453:                                          ; preds = %invoke.cont454, %invoke.cont452
  %178 = landingpad { ptr, i32 }
          cleanup
  %179 = extractvalue { ptr, i32 } %178, 0
  store ptr %179, ptr %exn.slot, align 8
  %180 = extractvalue { ptr, i32 } %178, 1
  store i32 %180, ptr %ehselector.slot, align 4
  br label %ehcleanup882

lpad456:                                          ; preds = %invoke.cont457, %invoke.cont455
  %181 = landingpad { ptr, i32 }
          cleanup
  %182 = extractvalue { ptr, i32 } %181, 0
  store ptr %182, ptr %exn.slot, align 8
  %183 = extractvalue { ptr, i32 } %181, 1
  store i32 %183, ptr %ehselector.slot, align 4
  br label %ehcleanup881

lpad459:                                          ; preds = %invoke.cont460, %invoke.cont458
  %184 = landingpad { ptr, i32 }
          cleanup
  %185 = extractvalue { ptr, i32 } %184, 0
  store ptr %185, ptr %exn.slot, align 8
  %186 = extractvalue { ptr, i32 } %184, 1
  store i32 %186, ptr %ehselector.slot, align 4
  br label %ehcleanup880

lpad462:                                          ; preds = %invoke.cont463, %invoke.cont461
  %187 = landingpad { ptr, i32 }
          cleanup
  %188 = extractvalue { ptr, i32 } %187, 0
  store ptr %188, ptr %exn.slot, align 8
  %189 = extractvalue { ptr, i32 } %187, 1
  store i32 %189, ptr %ehselector.slot, align 4
  br label %ehcleanup879

lpad465:                                          ; preds = %invoke.cont466, %invoke.cont464
  %190 = landingpad { ptr, i32 }
          cleanup
  %191 = extractvalue { ptr, i32 } %190, 0
  store ptr %191, ptr %exn.slot, align 8
  %192 = extractvalue { ptr, i32 } %190, 1
  store i32 %192, ptr %ehselector.slot, align 4
  br label %ehcleanup878

lpad469:                                          ; preds = %invoke.cont470, %invoke.cont467
  %193 = landingpad { ptr, i32 }
          cleanup
  %194 = extractvalue { ptr, i32 } %193, 0
  store ptr %194, ptr %exn.slot, align 8
  %195 = extractvalue { ptr, i32 } %193, 1
  store i32 %195, ptr %ehselector.slot, align 4
  br label %ehcleanup877

lpad473:                                          ; preds = %invoke.cont474, %invoke.cont471
  %196 = landingpad { ptr, i32 }
          cleanup
  %197 = extractvalue { ptr, i32 } %196, 0
  store ptr %197, ptr %exn.slot, align 8
  %198 = extractvalue { ptr, i32 } %196, 1
  store i32 %198, ptr %ehselector.slot, align 4
  br label %ehcleanup876

lpad476:                                          ; preds = %invoke.cont477, %invoke.cont475
  %199 = landingpad { ptr, i32 }
          cleanup
  %200 = extractvalue { ptr, i32 } %199, 0
  store ptr %200, ptr %exn.slot, align 8
  %201 = extractvalue { ptr, i32 } %199, 1
  store i32 %201, ptr %ehselector.slot, align 4
  br label %ehcleanup875

lpad479:                                          ; preds = %invoke.cont480, %invoke.cont478
  %202 = landingpad { ptr, i32 }
          cleanup
  %203 = extractvalue { ptr, i32 } %202, 0
  store ptr %203, ptr %exn.slot, align 8
  %204 = extractvalue { ptr, i32 } %202, 1
  store i32 %204, ptr %ehselector.slot, align 4
  br label %ehcleanup874

lpad482:                                          ; preds = %invoke.cont483, %invoke.cont481
  %205 = landingpad { ptr, i32 }
          cleanup
  %206 = extractvalue { ptr, i32 } %205, 0
  store ptr %206, ptr %exn.slot, align 8
  %207 = extractvalue { ptr, i32 } %205, 1
  store i32 %207, ptr %ehselector.slot, align 4
  br label %ehcleanup873

lpad487:                                          ; preds = %invoke.cont869, %if.end867, %invoke.cont864, %if.then863, %invoke.cont853, %if.then852, %invoke.cont846, %invoke.cont844, %invoke.cont842, %invoke.cont840, %invoke.cont838, %invoke.cont836, %invoke.cont834, %invoke.cont832, %if.then830, %invoke.cont824, %invoke.cont822, %invoke.cont820, %invoke.cont818, %invoke.cont816, %invoke.cont814, %invoke.cont812, %invoke.cont810, %if.then808, %invoke.cont802, %invoke.cont800, %invoke.cont798, %invoke.cont796, %invoke.cont794, %invoke.cont792, %invoke.cont790, %invoke.cont788, %invoke.cont782, %invoke.cont777, %invoke.cont773, %invoke.cont768, %invoke.cont764, %if.else762, %if.else754, %if.else749, %if.then740, %cond.end, %invoke.cont722, %if.end721, %if.then716, %invoke.cont706, %invoke.cont704, %if.end703, %if.then700, %if.then692, %invoke.cont684, %invoke.cont682, %invoke.cont680, %invoke.cont678, %invoke.cont675, %invoke.cont673, %invoke.cont671, %invoke.cont668, %if.then667, %invoke.cont655, %invoke.cont653, %invoke.cont651, %invoke.cont649, %invoke.cont647, %invoke.cont645, %invoke.cont643, %invoke.cont639, %invoke.cont635, %if.then634, %if.end628, %invoke.cont622, %invoke.cont620, %if.then619, %invoke.cont613, %invoke.cont611, %invoke.cont609, %invoke.cont607, %invoke.cont605, %invoke.cont603, %invoke.cont601, %invoke.cont599, %if.then598, %invoke.cont592, %invoke.cont590, %invoke.cont588, %invoke.cont586, %invoke.cont584, %invoke.cont582, %invoke.cont580, %invoke.cont578, %if.then577, %invoke.cont572, %invoke.cont570, %invoke.cont568, %invoke.cont566, %invoke.cont564, %invoke.cont562, %invoke.cont560, %invoke.cont558, %invoke.cont554, %invoke.cont550, %invoke.cont547, %invoke.cont544, %invoke.cont542, %if.then541, %invoke.cont535, %invoke.cont532, %invoke.cont530, %invoke.cont528, %invoke.cont526, %if.end525, %lor.lhs.false, %if.end516, %land.lhs.true, %invoke.cont506, %invoke.cont504, %invoke.cont502, %invoke.cont499, %invoke.cont497, %invoke.cont495, %invoke.cont493, %for.body, %if.end489, %if.then486
  %208 = landingpad { ptr, i32 }
          cleanup
  %209 = extractvalue { ptr, i32 } %208, 0
  store ptr %209, ptr %exn.slot, align 8
  %210 = extractvalue { ptr, i32 } %208, 1
  store i32 %210, ptr %ehselector.slot, align 4
  br label %ehcleanup872

if.end489:                                        ; preds = %invoke.cont488, %invoke.cont484
  %211 = load i32, ptr %maxContactCapacity.addr, align 4
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp490, i8 0, i64 112, i1 false)
  invoke void @_ZN20b3AlignedObjectArrayI10b3Contact4E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %hostContacts, i32 noundef %211, ptr noundef nonnull align 16 dereferenceable(112) %ref.tmp490)
          to label %invoke.cont491 unwind label %lpad487

invoke.cont491:                                   ; preds = %if.end489
  %212 = load ptr, ptr %nContacts.addr, align 8
  %213 = load i32, ptr %212, align 4
  store i32 %213, ptr %nGlobalContactsOut, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %invoke.cont491
  %214 = load i32, ptr %i, align 4
  %215 = load i32, ptr %nPairs.addr, align 4
  %cmp492 = icmp slt i32 %214, %215
  br i1 %cmp492, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %216 = load i32, ptr %i, align 4
  %call494 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI6b3Int4EixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostPairs, i32 noundef %216)
          to label %invoke.cont493 unwind label %lpad487

invoke.cont493:                                   ; preds = %for.body
  %217 = getelementptr inbounds %struct.b3Int4, ptr %call494, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon, ptr %217, i32 0, i32 0
  %218 = load i32, ptr %x, align 16
  store i32 %218, ptr %bodyIndexA, align 4
  %219 = load i32, ptr %i, align 4
  %call496 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI6b3Int4EixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostPairs, i32 noundef %219)
          to label %invoke.cont495 unwind label %lpad487

invoke.cont495:                                   ; preds = %invoke.cont493
  %220 = getelementptr inbounds %struct.b3Int4, ptr %call496, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon, ptr %220, i32 0, i32 1
  %221 = load i32, ptr %y, align 4
  store i32 %221, ptr %bodyIndexB, align 4
  %222 = load i32, ptr %bodyIndexA, align 4
  %call498 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf, i32 noundef %222)
          to label %invoke.cont497 unwind label %lpad487

invoke.cont497:                                   ; preds = %invoke.cont495
  %m_collidableIdx = getelementptr inbounds %struct.b3RigidBodyData, ptr %call498, i32 0, i32 4
  %223 = load i32, ptr %m_collidableIdx, align 16
  store i32 %223, ptr %collidableIndexA, align 4
  %224 = load i32, ptr %bodyIndexB, align 4
  %call500 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf, i32 noundef %224)
          to label %invoke.cont499 unwind label %lpad487

invoke.cont499:                                   ; preds = %invoke.cont497
  %m_collidableIdx501 = getelementptr inbounds %struct.b3RigidBodyData, ptr %call500, i32 0, i32 4
  %225 = load i32, ptr %m_collidableIdx501, align 16
  store i32 %225, ptr %collidableIndexB, align 4
  %226 = load i32, ptr %collidableIndexA, align 4
  %call503 = invoke noundef nonnull align 4 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI12b3CollidableEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables, i32 noundef %226)
          to label %invoke.cont502 unwind label %lpad487

invoke.cont502:                                   ; preds = %invoke.cont499
  %227 = getelementptr inbounds %struct.b3Collidable, ptr %call503, i32 0, i32 3
  %228 = load i32, ptr %227, align 4
  store i32 %228, ptr %shapeIndexA, align 4
  %229 = load i32, ptr %collidableIndexB, align 4
  %call505 = invoke noundef nonnull align 4 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI12b3CollidableEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables, i32 noundef %229)
          to label %invoke.cont504 unwind label %lpad487

invoke.cont504:                                   ; preds = %invoke.cont502
  %230 = getelementptr inbounds %struct.b3Collidable, ptr %call505, i32 0, i32 3
  %231 = load i32, ptr %230, align 4
  store i32 %231, ptr %shapeIndexB, align 4
  %232 = load i32, ptr %i, align 4
  %call507 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostHasSepAxis, i32 noundef %232)
          to label %invoke.cont506 unwind label %lpad487

invoke.cont506:                                   ; preds = %invoke.cont504
  store i32 0, ptr %call507, align 4
  %233 = load i32, ptr %bodyIndexA, align 4
  %call509 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf, i32 noundef %233)
          to label %invoke.cont508 unwind label %lpad487

invoke.cont508:                                   ; preds = %invoke.cont506
  %m_invMass = getelementptr inbounds %struct.b3RigidBodyData, ptr %call509, i32 0, i32 5
  %234 = load float, ptr %m_invMass, align 4
  %cmp510 = fcmp oeq float %234, 0.000000e+00
  br i1 %cmp510, label %land.lhs.true, label %if.end516

land.lhs.true:                                    ; preds = %invoke.cont508
  %235 = load i32, ptr %bodyIndexB, align 4
  %call512 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf, i32 noundef %235)
          to label %invoke.cont511 unwind label %lpad487

invoke.cont511:                                   ; preds = %land.lhs.true
  %m_invMass513 = getelementptr inbounds %struct.b3RigidBodyData, ptr %call512, i32 0, i32 5
  %236 = load float, ptr %m_invMass513, align 4
  %cmp514 = fcmp oeq float %236, 0.000000e+00
  br i1 %cmp514, label %if.then515, label %if.end516

if.then515:                                       ; preds = %invoke.cont511
  br label %for.inc

if.end516:                                        ; preds = %invoke.cont511, %invoke.cont508
  %237 = load i32, ptr %collidableIndexA, align 4
  %call518 = invoke noundef nonnull align 4 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI12b3CollidableEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables, i32 noundef %237)
          to label %invoke.cont517 unwind label %lpad487

invoke.cont517:                                   ; preds = %if.end516
  %m_shapeType = getelementptr inbounds %struct.b3Collidable, ptr %call518, i32 0, i32 2
  %238 = load i32, ptr %m_shapeType, align 4
  %cmp519 = icmp ne i32 %238, 3
  br i1 %cmp519, label %if.then524, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %invoke.cont517
  %239 = load i32, ptr %collidableIndexB, align 4
  %call521 = invoke noundef nonnull align 4 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI12b3CollidableEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables, i32 noundef %239)
          to label %invoke.cont520 unwind label %lpad487

invoke.cont520:                                   ; preds = %lor.lhs.false
  %m_shapeType522 = getelementptr inbounds %struct.b3Collidable, ptr %call521, i32 0, i32 2
  %240 = load i32, ptr %m_shapeType522, align 4
  %cmp523 = icmp ne i32 %240, 3
  br i1 %cmp523, label %if.then524, label %if.end525

if.then524:                                       ; preds = %invoke.cont520, %invoke.cont517
  br label %for.inc

if.end525:                                        ; preds = %invoke.cont520
  store float 0x47EFFFFFE0000000, ptr %dmin, align 4
  %241 = load i32, ptr %shapeIndexA, align 4
  %call527 = invoke noundef nonnull align 16 dereferenceable(96) ptr @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexShapeData, i32 noundef %241)
          to label %invoke.cont526 unwind label %lpad487

invoke.cont526:                                   ; preds = %if.end525
  store ptr %call527, ptr %convexShapeA, align 8
  %242 = load i32, ptr %shapeIndexB, align 4
  %call529 = invoke noundef nonnull align 16 dereferenceable(96) ptr @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexShapeData, i32 noundef %242)
          to label %invoke.cont528 unwind label %lpad487

invoke.cont528:                                   ; preds = %invoke.cont526
  store ptr %call529, ptr %convexShapeB, align 8
  %243 = load i32, ptr %bodyIndexA, align 4
  %call531 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf, i32 noundef %243)
          to label %invoke.cont530 unwind label %lpad487

invoke.cont530:                                   ; preds = %invoke.cont528
  %m_pos = getelementptr inbounds %struct.b3RigidBodyData, ptr %call531, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posA, ptr align 16 %m_pos, i64 16, i1 false)
  %244 = load i32, ptr %bodyIndexB, align 4
  %call533 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf, i32 noundef %244)
          to label %invoke.cont532 unwind label %lpad487

invoke.cont532:                                   ; preds = %invoke.cont530
  %m_pos534 = getelementptr inbounds %struct.b3RigidBodyData, ptr %call533, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %posB, ptr align 16 %m_pos534, i64 16, i1 false)
  %245 = load i32, ptr %bodyIndexA, align 4
  %call536 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf, i32 noundef %245)
          to label %invoke.cont535 unwind label %lpad487

invoke.cont535:                                   ; preds = %invoke.cont532
  %m_quat = getelementptr inbounds %struct.b3RigidBodyData, ptr %call536, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornA, ptr align 16 %m_quat, i64 16, i1 false)
  %246 = load i32, ptr %bodyIndexB, align 4
  %call538 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf, i32 noundef %246)
          to label %invoke.cont537 unwind label %lpad487

invoke.cont537:                                   ; preds = %invoke.cont535
  %m_quat539 = getelementptr inbounds %struct.b3RigidBodyData, ptr %call538, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %ornB, ptr align 16 %m_quat539, i64 16, i1 false)
  %247 = load i8, ptr @useGjk, align 1
  %tobool540 = trunc i8 %247 to i1
  br i1 %tobool540, label %if.then541, label %if.else762

if.then541:                                       ; preds = %invoke.cont537
  %248 = load i32, ptr %shapeIndexA, align 4
  %call543 = invoke noundef nonnull align 16 dereferenceable(96) ptr @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexShapeData, i32 noundef %248)
          to label %invoke.cont542 unwind label %lpad487

invoke.cont542:                                   ; preds = %if.then541
  %m_localCenter = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %call543, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %c0local, ptr align 16 %m_localCenter, i64 16, i1 false)
  %call545 = invoke { <2 x float>, <2 x float> } @_Z16b3TransformPointRK9b3Vector3S1_RK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(16) %c0local, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA)
          to label %invoke.cont544 unwind label %lpad487

invoke.cont544:                                   ; preds = %invoke.cont542
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %c0, i32 0, i32 0
  %coerce.dive546 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %249 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive546, i32 0, i32 0
  %250 = extractvalue { <2 x float>, <2 x float> } %call545, 0
  store <2 x float> %250, ptr %249, align 16
  %251 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive546, i32 0, i32 1
  %252 = extractvalue { <2 x float>, <2 x float> } %call545, 1
  store <2 x float> %252, ptr %251, align 8
  %253 = load i32, ptr %shapeIndexB, align 4
  %call548 = invoke noundef nonnull align 16 dereferenceable(96) ptr @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexShapeData, i32 noundef %253)
          to label %invoke.cont547 unwind label %lpad487

invoke.cont547:                                   ; preds = %invoke.cont544
  %m_localCenter549 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %call548, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %c1local, ptr align 16 %m_localCenter549, i64 16, i1 false)
  %call551 = invoke { <2 x float>, <2 x float> } @_Z16b3TransformPointRK9b3Vector3S1_RK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(16) %c1local, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB)
          to label %invoke.cont550 unwind label %lpad487

invoke.cont550:                                   ; preds = %invoke.cont547
  %coerce.dive552 = getelementptr inbounds %class.b3Vector3, ptr %c1, i32 0, i32 0
  %coerce.dive553 = getelementptr inbounds %union.anon.1, ptr %coerce.dive552, i32 0, i32 0
  %254 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive553, i32 0, i32 0
  %255 = extractvalue { <2 x float>, <2 x float> } %call551, 0
  store <2 x float> %255, ptr %254, align 16
  %256 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive553, i32 0, i32 1
  %257 = extractvalue { <2 x float>, <2 x float> } %call551, 1
  store <2 x float> %257, ptr %256, align 8
  %call555 = invoke { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %c0, ptr noundef nonnull align 16 dereferenceable(16) %c1)
          to label %invoke.cont554 unwind label %lpad487

invoke.cont554:                                   ; preds = %invoke.cont550
  %coerce.dive556 = getelementptr inbounds %class.b3Vector3, ptr %DeltaC2, i32 0, i32 0
  %coerce.dive557 = getelementptr inbounds %union.anon.1, ptr %coerce.dive556, i32 0, i32 0
  %258 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive557, i32 0, i32 0
  %259 = extractvalue { <2 x float>, <2 x float> } %call555, 0
  store <2 x float> %259, ptr %258, align 16
  %260 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive557, i32 0, i32 1
  %261 = extractvalue { <2 x float>, <2 x float> } %call555, 1
  store <2 x float> %261, ptr %260, align 8
  %262 = load ptr, ptr %convexShapeA, align 8
  %263 = load ptr, ptr %convexShapeB, align 8
  %call559 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices, i32 noundef 0)
          to label %invoke.cont558 unwind label %lpad487

invoke.cont558:                                   ; preds = %invoke.cont554
  %call561 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges, i32 noundef 0)
          to label %invoke.cont560 unwind label %lpad487

invoke.cont560:                                   ; preds = %invoke.cont558
  %call563 = invoke noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI9b3GpuFaceE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostFaces, i32 noundef 0)
          to label %invoke.cont562 unwind label %lpad487

invoke.cont562:                                   ; preds = %invoke.cont560
  %call565 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostIndices, i32 noundef 0)
          to label %invoke.cont564 unwind label %lpad487

invoke.cont564:                                   ; preds = %invoke.cont562
  %call567 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices, i32 noundef 0)
          to label %invoke.cont566 unwind label %lpad487

invoke.cont566:                                   ; preds = %invoke.cont564
  %call569 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges, i32 noundef 0)
          to label %invoke.cont568 unwind label %lpad487

invoke.cont568:                                   ; preds = %invoke.cont566
  %call571 = invoke noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI9b3GpuFaceE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostFaces, i32 noundef 0)
          to label %invoke.cont570 unwind label %lpad487

invoke.cont570:                                   ; preds = %invoke.cont568
  %call573 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostIndices, i32 noundef 0)
          to label %invoke.cont572 unwind label %lpad487

invoke.cont572:                                   ; preds = %invoke.cont570
  %call575 = invoke noundef zeroext i1 @_Z20b3FindSeparatingAxisPK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_Pf(ptr noundef %262, ptr noundef %263, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %DeltaC2, ptr noundef %call559, ptr noundef %call561, ptr noundef %call563, ptr noundef %call565, ptr noundef %call567, ptr noundef %call569, ptr noundef %call571, ptr noundef %call573, ptr noundef %sepAxis, ptr noundef %dmin)
          to label %invoke.cont574 unwind label %lpad487

invoke.cont574:                                   ; preds = %invoke.cont572
  %frombool = zext i1 %call575 to i8
  store i8 %frombool, ptr %hasSepAxisA, align 1
  %264 = load i8, ptr %hasSepAxisA, align 1
  %tobool576 = trunc i8 %264 to i1
  br i1 %tobool576, label %if.then577, label %if.end628

if.then577:                                       ; preds = %invoke.cont574
  %265 = load ptr, ptr %convexShapeB, align 8
  %266 = load ptr, ptr %convexShapeA, align 8
  %call579 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices, i32 noundef 0)
          to label %invoke.cont578 unwind label %lpad487

invoke.cont578:                                   ; preds = %if.then577
  %call581 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges, i32 noundef 0)
          to label %invoke.cont580 unwind label %lpad487

invoke.cont580:                                   ; preds = %invoke.cont578
  %call583 = invoke noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI9b3GpuFaceE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostFaces, i32 noundef 0)
          to label %invoke.cont582 unwind label %lpad487

invoke.cont582:                                   ; preds = %invoke.cont580
  %call585 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostIndices, i32 noundef 0)
          to label %invoke.cont584 unwind label %lpad487

invoke.cont584:                                   ; preds = %invoke.cont582
  %call587 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices, i32 noundef 0)
          to label %invoke.cont586 unwind label %lpad487

invoke.cont586:                                   ; preds = %invoke.cont584
  %call589 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges, i32 noundef 0)
          to label %invoke.cont588 unwind label %lpad487

invoke.cont588:                                   ; preds = %invoke.cont586
  %call591 = invoke noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI9b3GpuFaceE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostFaces, i32 noundef 0)
          to label %invoke.cont590 unwind label %lpad487

invoke.cont590:                                   ; preds = %invoke.cont588
  %call593 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostIndices, i32 noundef 0)
          to label %invoke.cont592 unwind label %lpad487

invoke.cont592:                                   ; preds = %invoke.cont590
  %call595 = invoke noundef zeroext i1 @_Z20b3FindSeparatingAxisPK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_Pf(ptr noundef %265, ptr noundef %266, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %DeltaC2, ptr noundef %call579, ptr noundef %call581, ptr noundef %call583, ptr noundef %call585, ptr noundef %call587, ptr noundef %call589, ptr noundef %call591, ptr noundef %call593, ptr noundef %sepAxis, ptr noundef %dmin)
          to label %invoke.cont594 unwind label %lpad487

invoke.cont594:                                   ; preds = %invoke.cont592
  %frombool596 = zext i1 %call595 to i8
  store i8 %frombool596, ptr %hasSepAxisB, align 1
  %267 = load i8, ptr %hasSepAxisB, align 1
  %tobool597 = trunc i8 %267 to i1
  br i1 %tobool597, label %if.then598, label %if.end627

if.then598:                                       ; preds = %invoke.cont594
  %268 = load ptr, ptr %convexShapeA, align 8
  %269 = load ptr, ptr %convexShapeB, align 8
  %call600 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices, i32 noundef 0)
          to label %invoke.cont599 unwind label %lpad487

invoke.cont599:                                   ; preds = %if.then598
  %call602 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges, i32 noundef 0)
          to label %invoke.cont601 unwind label %lpad487

invoke.cont601:                                   ; preds = %invoke.cont599
  %call604 = invoke noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI9b3GpuFaceE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostFaces, i32 noundef 0)
          to label %invoke.cont603 unwind label %lpad487

invoke.cont603:                                   ; preds = %invoke.cont601
  %call606 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostIndices, i32 noundef 0)
          to label %invoke.cont605 unwind label %lpad487

invoke.cont605:                                   ; preds = %invoke.cont603
  %call608 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices, i32 noundef 0)
          to label %invoke.cont607 unwind label %lpad487

invoke.cont607:                                   ; preds = %invoke.cont605
  %call610 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges, i32 noundef 0)
          to label %invoke.cont609 unwind label %lpad487

invoke.cont609:                                   ; preds = %invoke.cont607
  %call612 = invoke noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI9b3GpuFaceE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostFaces, i32 noundef 0)
          to label %invoke.cont611 unwind label %lpad487

invoke.cont611:                                   ; preds = %invoke.cont609
  %call614 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostIndices, i32 noundef 0)
          to label %invoke.cont613 unwind label %lpad487

invoke.cont613:                                   ; preds = %invoke.cont611
  %call616 = invoke noundef zeroext i1 @_Z28b3FindSeparatingAxisEdgeEdgePK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_Pfb(ptr noundef %268, ptr noundef %269, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %DeltaC2, ptr noundef %call600, ptr noundef %call602, ptr noundef %call604, ptr noundef %call606, ptr noundef %call608, ptr noundef %call610, ptr noundef %call612, ptr noundef %call614, ptr noundef %sepAxis, ptr noundef %dmin, i1 noundef zeroext false)
          to label %invoke.cont615 unwind label %lpad487

invoke.cont615:                                   ; preds = %invoke.cont613
  %frombool617 = zext i1 %call616 to i8
  store i8 %frombool617, ptr %hasEdgeEdge, align 1
  %270 = load i8, ptr %hasEdgeEdge, align 1
  %tobool618 = trunc i8 %270 to i1
  br i1 %tobool618, label %if.then619, label %if.end626

if.then619:                                       ; preds = %invoke.cont615
  %271 = load i32, ptr %i, align 4
  %call621 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostHasSepAxis, i32 noundef %271)
          to label %invoke.cont620 unwind label %lpad487

invoke.cont620:                                   ; preds = %if.then619
  store i32 1, ptr %call621, align 4
  %272 = load i32, ptr %i, align 4
  %call623 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3EixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostSepAxis, i32 noundef %272)
          to label %invoke.cont622 unwind label %lpad487

invoke.cont622:                                   ; preds = %invoke.cont620
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %call623, ptr align 16 %sepAxis, i64 16, i1 false)
  %273 = load float, ptr %dmin, align 4
  %274 = load i32, ptr %i, align 4
  %call625 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3EixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostSepAxis, i32 noundef %274)
          to label %invoke.cont624 unwind label %lpad487

invoke.cont624:                                   ; preds = %invoke.cont622
  %275 = getelementptr inbounds %class.b3Vector3, ptr %call625, i32 0, i32 0
  %w = getelementptr inbounds %struct.anon.2, ptr %275, i32 0, i32 3
  store float %273, ptr %w, align 4
  br label %if.end626

if.end626:                                        ; preds = %invoke.cont624, %invoke.cont615
  br label %if.end627

if.end627:                                        ; preds = %if.end626, %invoke.cont594
  br label %if.end628

if.end628:                                        ; preds = %if.end627, %invoke.cont574
  %276 = load i32, ptr %i, align 4
  %call630 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostHasSepAxis, i32 noundef %276)
          to label %invoke.cont629 unwind label %lpad487

invoke.cont629:                                   ; preds = %if.end628
  %277 = load i32, ptr %call630, align 4
  %tobool631 = icmp ne i32 %277, 0
  br i1 %tobool631, label %if.then632, label %if.end761

if.then632:                                       ; preds = %invoke.cont629
  %278 = load i32, ptr %i, align 4
  store i32 %278, ptr %pairIndex, align 4
  store i8 1, ptr %useMpr, align 1
  %279 = load i8, ptr %useMpr, align 1
  %tobool633 = trunc i8 %279 to i1
  br i1 %tobool633, label %if.then634, label %if.else754

if.then634:                                       ; preds = %if.then632
  store i32 0, ptr %res, align 4
  store float 0.000000e+00, ptr %depth, align 4
  %call636 = invoke { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 1.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00)
          to label %invoke.cont635 unwind label %lpad487

invoke.cont635:                                   ; preds = %if.then634
  %coerce.dive637 = getelementptr inbounds %class.b3Vector3, ptr %sepAxis2, i32 0, i32 0
  %coerce.dive638 = getelementptr inbounds %union.anon.1, ptr %coerce.dive637, i32 0, i32 0
  %280 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive638, i32 0, i32 0
  %281 = extractvalue { <2 x float>, <2 x float> } %call636, 0
  store <2 x float> %281, ptr %280, align 16
  %282 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive638, i32 0, i32 1
  %283 = extractvalue { <2 x float>, <2 x float> } %call636, 1
  store <2 x float> %283, ptr %282, align 8
  %call640 = invoke { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00)
          to label %invoke.cont639 unwind label %lpad487

invoke.cont639:                                   ; preds = %invoke.cont635
  %coerce.dive641 = getelementptr inbounds %class.b3Vector3, ptr %resultPointOnBWorld, i32 0, i32 0
  %coerce.dive642 = getelementptr inbounds %union.anon.1, ptr %coerce.dive641, i32 0, i32 0
  %284 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive642, i32 0, i32 0
  %285 = extractvalue { <2 x float>, <2 x float> } %call640, 0
  store <2 x float> %285, ptr %284, align 16
  %286 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive642, i32 0, i32 1
  %287 = extractvalue { <2 x float>, <2 x float> } %call640, 1
  store <2 x float> %287, ptr %286, align 8
  %288 = load i32, ptr %pairIndex, align 4
  %289 = load i32, ptr %bodyIndexA, align 4
  %290 = load i32, ptr %bodyIndexB, align 4
  %call644 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf, i32 noundef 0)
          to label %invoke.cont643 unwind label %lpad487

invoke.cont643:                                   ; preds = %invoke.cont639
  %call646 = invoke noundef nonnull align 16 dereferenceable(96) ptr @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexShapeData, i32 noundef 0)
          to label %invoke.cont645 unwind label %lpad487

invoke.cont645:                                   ; preds = %invoke.cont643
  %call648 = invoke noundef nonnull align 4 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI12b3CollidableEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables, i32 noundef 0)
          to label %invoke.cont647 unwind label %lpad487

invoke.cont647:                                   ; preds = %invoke.cont645
  %call650 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3EixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices, i32 noundef 0)
          to label %invoke.cont649 unwind label %lpad487

invoke.cont649:                                   ; preds = %invoke.cont647
  %call652 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3EixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostSepAxis, i32 noundef 0)
          to label %invoke.cont651 unwind label %lpad487

invoke.cont651:                                   ; preds = %invoke.cont649
  %call654 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostHasSepAxis, i32 noundef 0)
          to label %invoke.cont653 unwind label %lpad487

invoke.cont653:                                   ; preds = %invoke.cont651
  %call656 = invoke noundef i32 @_Z16b3MprPenetrationiiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_PiPfSB_SB_(i32 noundef %288, i32 noundef %289, i32 noundef %290, ptr noundef %call644, ptr noundef %call646, ptr noundef %call648, ptr noundef %call650, ptr noundef %call652, ptr noundef %call654, ptr noundef %depthOut, ptr noundef %dirOut, ptr noundef %posOut)
          to label %invoke.cont655 unwind label %lpad487

invoke.cont655:                                   ; preds = %invoke.cont653
  store i32 %call656, ptr %res, align 4
  %291 = load float, ptr %depthOut, align 4
  store float %291, ptr %depth, align 4
  %292 = getelementptr inbounds %class.b3Vector3, ptr %dirOut, i32 0, i32 0
  %x658 = getelementptr inbounds %struct.anon.2, ptr %292, i32 0, i32 0
  %293 = load float, ptr %x658, align 16
  %fneg = fneg float %293
  %294 = getelementptr inbounds %class.b3Vector3, ptr %dirOut, i32 0, i32 0
  %y659 = getelementptr inbounds %struct.anon.2, ptr %294, i32 0, i32 1
  %295 = load float, ptr %y659, align 4
  %fneg660 = fneg float %295
  %296 = getelementptr inbounds %class.b3Vector3, ptr %dirOut, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon.2, ptr %296, i32 0, i32 2
  %297 = load float, ptr %z, align 8
  %fneg661 = fneg float %297
  %call663 = invoke { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef %fneg, float noundef %fneg660, float noundef %fneg661)
          to label %invoke.cont662 unwind label %lpad487

invoke.cont662:                                   ; preds = %invoke.cont655
  %coerce.dive664 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp657, i32 0, i32 0
  %coerce.dive665 = getelementptr inbounds %union.anon.1, ptr %coerce.dive664, i32 0, i32 0
  %298 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive665, i32 0, i32 0
  %299 = extractvalue { <2 x float>, <2 x float> } %call663, 0
  store <2 x float> %299, ptr %298, align 16
  %300 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive665, i32 0, i32 1
  %301 = extractvalue { <2 x float>, <2 x float> } %call663, 1
  store <2 x float> %301, ptr %300, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %sepAxis2, ptr align 16 %ref.tmp657, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %resultPointOnBWorld, ptr align 16 %posOut, i64 16, i1 false)
  %302 = load i32, ptr %res, align 4
  %cmp666 = icmp eq i32 %302, 0
  br i1 %cmp666, label %if.then667, label %if.end753

if.then667:                                       ; preds = %invoke.cont662
  store float 0.000000e+00, ptr %dist, align 4
  %303 = load i32, ptr %bodyIndexA, align 4
  %call669 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf, i32 noundef %303)
          to label %invoke.cont668 unwind label %lpad487

invoke.cont668:                                   ; preds = %if.then667
  %m_collidableIdx670 = getelementptr inbounds %struct.b3RigidBodyData, ptr %call669, i32 0, i32 4
  %304 = load i32, ptr %m_collidableIdx670, align 16
  %call672 = invoke noundef nonnull align 4 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI12b3CollidableEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables, i32 noundef %304)
          to label %invoke.cont671 unwind label %lpad487

invoke.cont671:                                   ; preds = %invoke.cont668
  %305 = getelementptr inbounds %struct.b3Collidable, ptr %call672, i32 0, i32 3
  %306 = load i32, ptr %305, align 4
  %call674 = invoke noundef nonnull align 16 dereferenceable(96) ptr @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexShapeData, i32 noundef %306)
          to label %invoke.cont673 unwind label %lpad487

invoke.cont673:                                   ; preds = %invoke.cont671
  store ptr %call674, ptr %hullA, align 8
  %307 = load i32, ptr %bodyIndexB, align 4
  %call676 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf, i32 noundef %307)
          to label %invoke.cont675 unwind label %lpad487

invoke.cont675:                                   ; preds = %invoke.cont673
  %m_collidableIdx677 = getelementptr inbounds %struct.b3RigidBodyData, ptr %call676, i32 0, i32 4
  %308 = load i32, ptr %m_collidableIdx677, align 16
  %call679 = invoke noundef nonnull align 4 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI12b3CollidableEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables, i32 noundef %308)
          to label %invoke.cont678 unwind label %lpad487

invoke.cont678:                                   ; preds = %invoke.cont675
  %309 = getelementptr inbounds %struct.b3Collidable, ptr %call679, i32 0, i32 3
  %310 = load i32, ptr %309, align 4
  %call681 = invoke noundef nonnull align 16 dereferenceable(96) ptr @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexShapeData, i32 noundef %310)
          to label %invoke.cont680 unwind label %lpad487

invoke.cont680:                                   ; preds = %invoke.cont678
  store ptr %call681, ptr %hullB, align 8
  %311 = load ptr, ptr %hullA, align 8
  %312 = load ptr, ptr %hullB, align 8
  %call683 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3EixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices, i32 noundef 0)
          to label %invoke.cont682 unwind label %lpad487

invoke.cont682:                                   ; preds = %invoke.cont680
  %call685 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3EixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices, i32 noundef 0)
          to label %invoke.cont684 unwind label %lpad487

invoke.cont684:                                   ; preds = %invoke.cont682
  %call687 = invoke noundef zeroext i1 @_Z13b3TestSepAxisPK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_PS2_PS3_S9_Pf(ptr noundef %311, ptr noundef %312, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef %sepAxis2, ptr noundef %call683, ptr noundef %call685, ptr noundef %dist)
          to label %invoke.cont686 unwind label %lpad487

invoke.cont686:                                   ; preds = %invoke.cont684
  br i1 %call687, label %if.then688, label %if.end698

if.then688:                                       ; preds = %invoke.cont686
  %313 = load float, ptr %depth, align 4
  %314 = load float, ptr %dist, align 4
  %cmp689 = fcmp ogt float %313, %314
  br i1 %cmp689, label %if.then690, label %if.end697

if.then690:                                       ; preds = %if.then688
  %315 = load float, ptr %depth, align 4
  %316 = load float, ptr %dist, align 4
  %sub = fsub float %315, %316
  store float %sub, ptr %diff, align 4
  %317 = load float, ptr @_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E7maxdiff, align 4
  %318 = load float, ptr %diff, align 4
  %cmp691 = fcmp olt float %317, %318
  br i1 %cmp691, label %if.then692, label %if.end696

if.then692:                                       ; preds = %if.then690
  %319 = load float, ptr %diff, align 4
  store float %319, ptr @_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E7maxdiff, align 4
  %320 = load float, ptr @_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E7maxdiff, align 4
  %conv693 = fpext float %320 to double
  %call695 = invoke i32 (ptr, ...) @printf(ptr noundef @.str.44, double noundef %conv693)
          to label %invoke.cont694 unwind label %lpad487

invoke.cont694:                                   ; preds = %if.then692
  br label %if.end696

if.end696:                                        ; preds = %invoke.cont694, %if.then690
  br label %if.end697

if.end697:                                        ; preds = %if.end696, %if.then688
  br label %if.end698

if.end698:                                        ; preds = %if.end697, %invoke.cont686
  %321 = load float, ptr %depth, align 4
  %322 = load float, ptr %dmin, align 4
  %cmp699 = fcmp ogt float %321, %322
  br i1 %cmp699, label %if.then700, label %if.end703

if.then700:                                       ; preds = %if.end698
  %323 = load i32, ptr %i, align 4
  %call702 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3EixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostSepAxis, i32 noundef %323)
          to label %invoke.cont701 unwind label %lpad487

invoke.cont701:                                   ; preds = %if.then700
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %oldAxis, ptr align 16 %call702, i64 16, i1 false)
  %324 = load float, ptr %dmin, align 4
  store float %324, ptr %depth, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %sepAxis2, ptr align 16 %oldAxis, i64 16, i1 false)
  br label %if.end703

if.end703:                                        ; preds = %invoke.cont701, %if.end698
  %325 = load ptr, ptr %hullA, align 8
  %326 = load ptr, ptr %hullB, align 8
  %call705 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3EixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices, i32 noundef 0)
          to label %invoke.cont704 unwind label %lpad487

invoke.cont704:                                   ; preds = %if.end703
  %call707 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3EixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices, i32 noundef 0)
          to label %invoke.cont706 unwind label %lpad487

invoke.cont706:                                   ; preds = %invoke.cont704
  %call709 = invoke noundef zeroext i1 @_Z13b3TestSepAxisPK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_PS2_PS3_S9_Pf(ptr noundef %325, ptr noundef %326, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef %sepAxis2, ptr noundef %call705, ptr noundef %call707, ptr noundef %dist)
          to label %invoke.cont708 unwind label %lpad487

invoke.cont708:                                   ; preds = %invoke.cont706
  br i1 %call709, label %if.then710, label %if.else749

if.then710:                                       ; preds = %invoke.cont708
  %327 = load float, ptr %depth, align 4
  %328 = load float, ptr %dist, align 4
  %cmp711 = fcmp ogt float %327, %328
  br i1 %cmp711, label %if.then712, label %if.end721

if.then712:                                       ; preds = %if.then710
  %329 = load float, ptr %depth, align 4
  %330 = load float, ptr %dist, align 4
  %sub714 = fsub float %329, %330
  store float %sub714, ptr %diff713, align 4
  %331 = load float, ptr @_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E7maxdiff_0, align 4
  %332 = load float, ptr %diff713, align 4
  %cmp715 = fcmp olt float %331, %332
  br i1 %cmp715, label %if.then716, label %if.end720

if.then716:                                       ; preds = %if.then712
  %333 = load float, ptr %diff713, align 4
  store float %333, ptr @_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E7maxdiff_0, align 4
  %334 = load float, ptr @_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E7maxdiff_0, align 4
  %conv717 = fpext float %334 to double
  %call719 = invoke i32 (ptr, ...) @printf(ptr noundef @.str.44, double noundef %conv717)
          to label %invoke.cont718 unwind label %lpad487

invoke.cont718:                                   ; preds = %if.then716
  br label %if.end720

if.end720:                                        ; preds = %invoke.cont718, %if.then712
  br label %if.end721

if.end721:                                        ; preds = %if.end720, %if.then710
  %335 = load i32, ptr %nGlobalContactsOut, align 4
  %call723 = invoke noundef nonnull align 16 dereferenceable(112) ptr @_ZN20b3AlignedObjectArrayI10b3Contact4E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostContacts, i32 noundef %335)
          to label %invoke.cont722 unwind label %lpad487

invoke.cont722:                                   ; preds = %if.end721
  store ptr %call723, ptr %newContact, align 8
  %336 = load i32, ptr %nGlobalContactsOut, align 4
  %inc724 = add nsw i32 %336, 1
  store i32 %inc724, ptr %nGlobalContactsOut, align 4
  %337 = load ptr, ptr %newContact, align 8
  %m_batchIdx = getelementptr inbounds %struct.b3Contact4Data, ptr %337, i32 0, i32 4
  store i32 0, ptr %m_batchIdx, align 4
  %338 = load i32, ptr %bodyIndexA, align 4
  %call726 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf, i32 noundef %338)
          to label %invoke.cont725 unwind label %lpad487

invoke.cont725:                                   ; preds = %invoke.cont722
  %m_invMass727 = getelementptr inbounds %struct.b3RigidBodyData, ptr %call726, i32 0, i32 5
  %339 = load float, ptr %m_invMass727, align 4
  %cmp728 = fcmp oeq float %339, 0.000000e+00
  br i1 %cmp728, label %cond.true, label %cond.false

cond.true:                                        ; preds = %invoke.cont725
  %340 = load i32, ptr %bodyIndexA, align 4
  %sub729 = sub nsw i32 0, %340
  br label %cond.end

cond.false:                                       ; preds = %invoke.cont725
  %341 = load i32, ptr %bodyIndexA, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %sub729, %cond.true ], [ %341, %cond.false ]
  %342 = load ptr, ptr %newContact, align 8
  %m_bodyAPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %342, i32 0, i32 5
  store i32 %cond, ptr %m_bodyAPtrAndSignBit, align 8
  %343 = load i32, ptr %bodyIndexB, align 4
  %call731 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf, i32 noundef %343)
          to label %invoke.cont730 unwind label %lpad487

invoke.cont730:                                   ; preds = %cond.end
  %m_invMass732 = getelementptr inbounds %struct.b3RigidBodyData, ptr %call731, i32 0, i32 5
  %344 = load float, ptr %m_invMass732, align 4
  %cmp733 = fcmp oeq float %344, 0.000000e+00
  br i1 %cmp733, label %cond.true734, label %cond.false736

cond.true734:                                     ; preds = %invoke.cont730
  %345 = load i32, ptr %bodyIndexB, align 4
  %sub735 = sub nsw i32 0, %345
  br label %cond.end737

cond.false736:                                    ; preds = %invoke.cont730
  %346 = load i32, ptr %bodyIndexB, align 4
  br label %cond.end737

cond.end737:                                      ; preds = %cond.false736, %cond.true734
  %cond738 = phi i32 [ %sub735, %cond.true734 ], [ %346, %cond.false736 ]
  %347 = load ptr, ptr %newContact, align 8
  %m_bodyBPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %347, i32 0, i32 6
  store i32 %cond738, ptr %m_bodyBPtrAndSignBit, align 4
  %348 = load ptr, ptr %newContact, align 8
  %m_frictionCoeffCmp = getelementptr inbounds %struct.b3Contact4Data, ptr %348, i32 0, i32 3
  store i16 -19662, ptr %m_frictionCoeffCmp, align 2
  %349 = load ptr, ptr %newContact, align 8
  %m_restituitionCoeffCmp = getelementptr inbounds %struct.b3Contact4Data, ptr %349, i32 0, i32 2
  store i16 0, ptr %m_restituitionCoeffCmp, align 16
  %350 = load float, ptr %depth, align 4
  %351 = load float, ptr @_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E8maxDepth, align 4
  %cmp739 = fcmp ogt float %350, %351
  br i1 %cmp739, label %if.then740, label %if.end744

if.then740:                                       ; preds = %cond.end737
  %352 = load float, ptr %depth, align 4
  store float %352, ptr @_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E8maxDepth, align 4
  %353 = load float, ptr @_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E8maxDepth, align 4
  %conv741 = fpext float %353 to double
  %call743 = invoke i32 (ptr, ...) @printf(ptr noundef @.str.45, double noundef %conv741)
          to label %invoke.cont742 unwind label %lpad487

invoke.cont742:                                   ; preds = %if.then740
  br label %if.end744

if.end744:                                        ; preds = %invoke.cont742, %cond.end737
  %354 = load float, ptr %depth, align 4
  %fneg745 = fneg float %354
  %355 = getelementptr inbounds %class.b3Vector3, ptr %resultPointOnBWorld, i32 0, i32 0
  %w746 = getelementptr inbounds %struct.anon.2, ptr %355, i32 0, i32 3
  store float %fneg745, ptr %w746, align 4
  %356 = load ptr, ptr %newContact, align 8
  %m_worldPosB = getelementptr inbounds %struct.b3Contact4Data, ptr %356, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x %class.b3Vector3], ptr %m_worldPosB, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx, ptr align 16 %resultPointOnBWorld, i64 16, i1 false)
  %357 = load ptr, ptr %newContact, align 8
  %m_worldNormalOnB = getelementptr inbounds %struct.b3Contact4Data, ptr %357, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %m_worldNormalOnB, ptr align 16 %sepAxis2, i64 16, i1 false)
  %358 = load ptr, ptr %newContact, align 8
  %m_worldNormalOnB747 = getelementptr inbounds %struct.b3Contact4Data, ptr %358, i32 0, i32 1
  %359 = getelementptr inbounds %class.b3Vector3, ptr %m_worldNormalOnB747, i32 0, i32 0
  %w748 = getelementptr inbounds %struct.anon.2, ptr %359, i32 0, i32 3
  store float 1.000000e+00, ptr %w748, align 4
  br label %if.end752

if.else749:                                       ; preds = %invoke.cont708
  %call751 = invoke i32 (ptr, ...) @printf(ptr noundef @.str.46)
          to label %invoke.cont750 unwind label %lpad487

invoke.cont750:                                   ; preds = %if.else749
  br label %if.end752

if.end752:                                        ; preds = %invoke.cont750, %if.end744
  br label %if.end753

if.end753:                                        ; preds = %if.end752, %invoke.cont662
  br label %if.end760

if.else754:                                       ; preds = %if.then632
  invoke void @_ZN20b3AlignedObjectArrayI10b3Contact4EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %oldHostContacts)
          to label %invoke.cont755 unwind label %lpad487

invoke.cont755:                                   ; preds = %if.else754
  %360 = load i32, ptr %pairIndex, align 4
  %361 = load i32, ptr %bodyIndexA, align 4
  %362 = load i32, ptr %bodyIndexB, align 4
  %363 = load i32, ptr %collidableIndexA, align 4
  %364 = load i32, ptr %collidableIndexB, align 4
  %365 = load i32, ptr %maxContactCapacity.addr, align 4
  %call758 = invoke noundef i32 @_Z27computeContactConvexConvex2iiiiiRK20b3AlignedObjectArrayI15b3RigidBodyDataERKS_I12b3CollidableERKS_I22b3ConvexPolyhedronDataERKS_I9b3Vector3ESF_RKS_IiERKS_I9b3GpuFaceERS_I10b3Contact4ERiiRKSO_(i32 noundef %360, i32 noundef %361, i32 noundef %362, i32 noundef %363, i32 noundef %364, ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf, ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables, ptr noundef nonnull align 8 dereferenceable(25) %hostConvexShapeData, ptr noundef nonnull align 8 dereferenceable(25) %hostVertices, ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges, ptr noundef nonnull align 8 dereferenceable(25) %hostIndices, ptr noundef nonnull align 8 dereferenceable(25) %hostFaces, ptr noundef nonnull align 8 dereferenceable(25) %hostContacts, ptr noundef nonnull align 4 dereferenceable(4) %nGlobalContactsOut, i32 noundef %365, ptr noundef nonnull align 8 dereferenceable(25) %oldHostContacts)
          to label %invoke.cont757 unwind label %lpad756

invoke.cont757:                                   ; preds = %invoke.cont755
  store i32 %call758, ptr %result, align 4
  call void @_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %oldHostContacts) #13
  br label %if.end760

lpad756:                                          ; preds = %invoke.cont755
  %366 = landingpad { ptr, i32 }
          cleanup
  %367 = extractvalue { ptr, i32 } %366, 0
  store ptr %367, ptr %exn.slot, align 8
  %368 = extractvalue { ptr, i32 } %366, 1
  store i32 %368, ptr %ehselector.slot, align 4
  call void @_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %oldHostContacts) #13
  br label %ehcleanup872

if.end760:                                        ; preds = %invoke.cont757, %if.end753
  br label %if.end761

if.end761:                                        ; preds = %if.end760, %invoke.cont629
  br label %if.end860

if.else762:                                       ; preds = %invoke.cont537
  %369 = load i32, ptr %shapeIndexA, align 4
  %call765 = invoke noundef nonnull align 16 dereferenceable(96) ptr @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexShapeData, i32 noundef %369)
          to label %invoke.cont764 unwind label %lpad487

invoke.cont764:                                   ; preds = %if.else762
  %m_localCenter766 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %call765, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %c0local763, ptr align 16 %m_localCenter766, i64 16, i1 false)
  %call769 = invoke { <2 x float>, <2 x float> } @_Z16b3TransformPointRK9b3Vector3S1_RK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(16) %c0local763, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA)
          to label %invoke.cont768 unwind label %lpad487

invoke.cont768:                                   ; preds = %invoke.cont764
  %coerce.dive770 = getelementptr inbounds %class.b3Vector3, ptr %c0767, i32 0, i32 0
  %coerce.dive771 = getelementptr inbounds %union.anon.1, ptr %coerce.dive770, i32 0, i32 0
  %370 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive771, i32 0, i32 0
  %371 = extractvalue { <2 x float>, <2 x float> } %call769, 0
  store <2 x float> %371, ptr %370, align 16
  %372 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive771, i32 0, i32 1
  %373 = extractvalue { <2 x float>, <2 x float> } %call769, 1
  store <2 x float> %373, ptr %372, align 8
  %374 = load i32, ptr %shapeIndexB, align 4
  %call774 = invoke noundef nonnull align 16 dereferenceable(96) ptr @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexShapeData, i32 noundef %374)
          to label %invoke.cont773 unwind label %lpad487

invoke.cont773:                                   ; preds = %invoke.cont768
  %m_localCenter775 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %call774, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %c1local772, ptr align 16 %m_localCenter775, i64 16, i1 false)
  %call778 = invoke { <2 x float>, <2 x float> } @_Z16b3TransformPointRK9b3Vector3S1_RK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(16) %c1local772, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB)
          to label %invoke.cont777 unwind label %lpad487

invoke.cont777:                                   ; preds = %invoke.cont773
  %coerce.dive779 = getelementptr inbounds %class.b3Vector3, ptr %c1776, i32 0, i32 0
  %coerce.dive780 = getelementptr inbounds %union.anon.1, ptr %coerce.dive779, i32 0, i32 0
  %375 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive780, i32 0, i32 0
  %376 = extractvalue { <2 x float>, <2 x float> } %call778, 0
  store <2 x float> %376, ptr %375, align 16
  %377 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive780, i32 0, i32 1
  %378 = extractvalue { <2 x float>, <2 x float> } %call778, 1
  store <2 x float> %378, ptr %377, align 8
  %call783 = invoke { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %c0767, ptr noundef nonnull align 16 dereferenceable(16) %c1776)
          to label %invoke.cont782 unwind label %lpad487

invoke.cont782:                                   ; preds = %invoke.cont777
  %coerce.dive784 = getelementptr inbounds %class.b3Vector3, ptr %DeltaC2781, i32 0, i32 0
  %coerce.dive785 = getelementptr inbounds %union.anon.1, ptr %coerce.dive784, i32 0, i32 0
  %379 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive785, i32 0, i32 0
  %380 = extractvalue { <2 x float>, <2 x float> } %call783, 0
  store <2 x float> %380, ptr %379, align 16
  %381 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive785, i32 0, i32 1
  %382 = extractvalue { <2 x float>, <2 x float> } %call783, 1
  store <2 x float> %382, ptr %381, align 8
  %383 = load ptr, ptr %convexShapeA, align 8
  %384 = load ptr, ptr %convexShapeB, align 8
  %call789 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices, i32 noundef 0)
          to label %invoke.cont788 unwind label %lpad487

invoke.cont788:                                   ; preds = %invoke.cont782
  %call791 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges, i32 noundef 0)
          to label %invoke.cont790 unwind label %lpad487

invoke.cont790:                                   ; preds = %invoke.cont788
  %call793 = invoke noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI9b3GpuFaceE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostFaces, i32 noundef 0)
          to label %invoke.cont792 unwind label %lpad487

invoke.cont792:                                   ; preds = %invoke.cont790
  %call795 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostIndices, i32 noundef 0)
          to label %invoke.cont794 unwind label %lpad487

invoke.cont794:                                   ; preds = %invoke.cont792
  %call797 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices, i32 noundef 0)
          to label %invoke.cont796 unwind label %lpad487

invoke.cont796:                                   ; preds = %invoke.cont794
  %call799 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges, i32 noundef 0)
          to label %invoke.cont798 unwind label %lpad487

invoke.cont798:                                   ; preds = %invoke.cont796
  %call801 = invoke noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI9b3GpuFaceE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostFaces, i32 noundef 0)
          to label %invoke.cont800 unwind label %lpad487

invoke.cont800:                                   ; preds = %invoke.cont798
  %call803 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostIndices, i32 noundef 0)
          to label %invoke.cont802 unwind label %lpad487

invoke.cont802:                                   ; preds = %invoke.cont800
  %call805 = invoke noundef zeroext i1 @_Z20b3FindSeparatingAxisPK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_Pf(ptr noundef %383, ptr noundef %384, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %DeltaC2781, ptr noundef %call789, ptr noundef %call791, ptr noundef %call793, ptr noundef %call795, ptr noundef %call797, ptr noundef %call799, ptr noundef %call801, ptr noundef %call803, ptr noundef %sepAxis786, ptr noundef %dmin)
          to label %invoke.cont804 unwind label %lpad487

invoke.cont804:                                   ; preds = %invoke.cont802
  %frombool806 = zext i1 %call805 to i8
  store i8 %frombool806, ptr %hasSepAxisA787, align 1
  %385 = load i8, ptr %hasSepAxisA787, align 1
  %tobool807 = trunc i8 %385 to i1
  br i1 %tobool807, label %if.then808, label %if.end859

if.then808:                                       ; preds = %invoke.cont804
  %386 = load ptr, ptr %convexShapeB, align 8
  %387 = load ptr, ptr %convexShapeA, align 8
  %call811 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices, i32 noundef 0)
          to label %invoke.cont810 unwind label %lpad487

invoke.cont810:                                   ; preds = %if.then808
  %call813 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges, i32 noundef 0)
          to label %invoke.cont812 unwind label %lpad487

invoke.cont812:                                   ; preds = %invoke.cont810
  %call815 = invoke noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI9b3GpuFaceE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostFaces, i32 noundef 0)
          to label %invoke.cont814 unwind label %lpad487

invoke.cont814:                                   ; preds = %invoke.cont812
  %call817 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostIndices, i32 noundef 0)
          to label %invoke.cont816 unwind label %lpad487

invoke.cont816:                                   ; preds = %invoke.cont814
  %call819 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices, i32 noundef 0)
          to label %invoke.cont818 unwind label %lpad487

invoke.cont818:                                   ; preds = %invoke.cont816
  %call821 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges, i32 noundef 0)
          to label %invoke.cont820 unwind label %lpad487

invoke.cont820:                                   ; preds = %invoke.cont818
  %call823 = invoke noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI9b3GpuFaceE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostFaces, i32 noundef 0)
          to label %invoke.cont822 unwind label %lpad487

invoke.cont822:                                   ; preds = %invoke.cont820
  %call825 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostIndices, i32 noundef 0)
          to label %invoke.cont824 unwind label %lpad487

invoke.cont824:                                   ; preds = %invoke.cont822
  %call827 = invoke noundef zeroext i1 @_Z20b3FindSeparatingAxisPK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_Pf(ptr noundef %386, ptr noundef %387, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %DeltaC2781, ptr noundef %call811, ptr noundef %call813, ptr noundef %call815, ptr noundef %call817, ptr noundef %call819, ptr noundef %call821, ptr noundef %call823, ptr noundef %call825, ptr noundef %sepAxis786, ptr noundef %dmin)
          to label %invoke.cont826 unwind label %lpad487

invoke.cont826:                                   ; preds = %invoke.cont824
  %frombool828 = zext i1 %call827 to i8
  store i8 %frombool828, ptr %hasSepAxisB809, align 1
  %388 = load i8, ptr %hasSepAxisB809, align 1
  %tobool829 = trunc i8 %388 to i1
  br i1 %tobool829, label %if.then830, label %if.end858

if.then830:                                       ; preds = %invoke.cont826
  %389 = load ptr, ptr %convexShapeA, align 8
  %390 = load ptr, ptr %convexShapeB, align 8
  %call833 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices, i32 noundef 0)
          to label %invoke.cont832 unwind label %lpad487

invoke.cont832:                                   ; preds = %if.then830
  %call835 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges, i32 noundef 0)
          to label %invoke.cont834 unwind label %lpad487

invoke.cont834:                                   ; preds = %invoke.cont832
  %call837 = invoke noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI9b3GpuFaceE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostFaces, i32 noundef 0)
          to label %invoke.cont836 unwind label %lpad487

invoke.cont836:                                   ; preds = %invoke.cont834
  %call839 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostIndices, i32 noundef 0)
          to label %invoke.cont838 unwind label %lpad487

invoke.cont838:                                   ; preds = %invoke.cont836
  %call841 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices, i32 noundef 0)
          to label %invoke.cont840 unwind label %lpad487

invoke.cont840:                                   ; preds = %invoke.cont838
  %call843 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges, i32 noundef 0)
          to label %invoke.cont842 unwind label %lpad487

invoke.cont842:                                   ; preds = %invoke.cont840
  %call845 = invoke noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI9b3GpuFaceE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostFaces, i32 noundef 0)
          to label %invoke.cont844 unwind label %lpad487

invoke.cont844:                                   ; preds = %invoke.cont842
  %call847 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostIndices, i32 noundef 0)
          to label %invoke.cont846 unwind label %lpad487

invoke.cont846:                                   ; preds = %invoke.cont844
  %call849 = invoke noundef zeroext i1 @_Z28b3FindSeparatingAxisEdgeEdgePK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_Pfb(ptr noundef %389, ptr noundef %390, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %DeltaC2781, ptr noundef %call833, ptr noundef %call835, ptr noundef %call837, ptr noundef %call839, ptr noundef %call841, ptr noundef %call843, ptr noundef %call845, ptr noundef %call847, ptr noundef %sepAxis786, ptr noundef %dmin, i1 noundef zeroext true)
          to label %invoke.cont848 unwind label %lpad487

invoke.cont848:                                   ; preds = %invoke.cont846
  %frombool850 = zext i1 %call849 to i8
  store i8 %frombool850, ptr %hasEdgeEdge831, align 1
  %391 = load i8, ptr %hasEdgeEdge831, align 1
  %tobool851 = trunc i8 %391 to i1
  br i1 %tobool851, label %if.then852, label %if.end857

if.then852:                                       ; preds = %invoke.cont848
  %392 = load i32, ptr %i, align 4
  %call854 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostHasSepAxis, i32 noundef %392)
          to label %invoke.cont853 unwind label %lpad487

invoke.cont853:                                   ; preds = %if.then852
  store i32 1, ptr %call854, align 4
  %393 = load i32, ptr %i, align 4
  %call856 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3EixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostSepAxis, i32 noundef %393)
          to label %invoke.cont855 unwind label %lpad487

invoke.cont855:                                   ; preds = %invoke.cont853
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %call856, ptr align 16 %sepAxis786, i64 16, i1 false)
  br label %if.end857

if.end857:                                        ; preds = %invoke.cont855, %invoke.cont848
  br label %if.end858

if.end858:                                        ; preds = %if.end857, %invoke.cont826
  br label %if.end859

if.end859:                                        ; preds = %if.end858, %invoke.cont804
  br label %if.end860

if.end860:                                        ; preds = %if.end859, %if.end761
  br label %for.inc

for.inc:                                          ; preds = %if.end860, %if.then524, %if.then515
  %394 = load i32, ptr %i, align 4
  %inc861 = add nsw i32 %394, 1
  store i32 %inc861, ptr %i, align 4
  br label %for.cond, !llvm.loop !68

for.end:                                          ; preds = %for.cond
  %395 = load i8, ptr @useGjkContacts, align 1
  %tobool862 = trunc i8 %395 to i1
  br i1 %tobool862, label %if.then863, label %if.end867

if.then863:                                       ; preds = %for.end
  %396 = load i32, ptr %nGlobalContactsOut, align 4
  %397 = load ptr, ptr %nContacts.addr, align 8
  store i32 %396, ptr %397, align 4
  %398 = load ptr, ptr %contactOut.addr, align 8
  invoke void @_ZN13b3OpenCLArrayI10b3Contact4E12copyFromHostERK20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %398, ptr noundef nonnull align 8 dereferenceable(25) %hostContacts, i1 noundef zeroext true)
          to label %invoke.cont864 unwind label %lpad487

invoke.cont864:                                   ; preds = %if.then863
  %m_totalContactsOut865 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %399 = load ptr, ptr %nContacts.addr, align 8
  invoke void @_ZN13b3OpenCLArrayIiE19copyFromHostPointerEPKimmb(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut865, ptr noundef %399, i64 noundef 1, i64 noundef 0, i1 noundef zeroext true)
          to label %invoke.cont866 unwind label %lpad487

invoke.cont866:                                   ; preds = %invoke.cont864
  br label %if.end867

if.end867:                                        ; preds = %invoke.cont866, %for.end
  %m_hasSeparatingNormals868 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 28
  invoke void @_ZN13b3OpenCLArrayIiE12copyFromHostERK20b3AlignedObjectArrayIiEb(ptr noundef nonnull align 8 dereferenceable(50) %m_hasSeparatingNormals868, ptr noundef nonnull align 8 dereferenceable(25) %hostHasSepAxis, i1 noundef zeroext true)
          to label %invoke.cont869 unwind label %lpad487

invoke.cont869:                                   ; preds = %if.end867
  %m_sepNormals870 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 26
  invoke void @_ZN13b3OpenCLArrayI9b3Vector3E12copyFromHostERK20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %m_sepNormals870, ptr noundef nonnull align 8 dereferenceable(25) %hostSepAxis, i1 noundef zeroext true)
          to label %invoke.cont871 unwind label %lpad487

invoke.cont871:                                   ; preds = %invoke.cont869
  call void @_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostContacts) #13
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostIndices) #13
  call void @_ZN20b3AlignedObjectArrayI9b3GpuFaceED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostFaces) #13
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges) #13
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostSepAxis) #13
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostHasSepAxis) #13
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices) #13
  call void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexShapeData) #13
  call void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuChildShapes) #13
  call void @_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables) #13
  call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf) #13
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostPairs) #13
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile446) #13
  br label %if.end885

ehcleanup872:                                     ; preds = %lpad756, %lpad487
  call void @_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostContacts) #13
  br label %ehcleanup873

ehcleanup873:                                     ; preds = %ehcleanup872, %lpad482
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostIndices) #13
  br label %ehcleanup874

ehcleanup874:                                     ; preds = %ehcleanup873, %lpad479
  call void @_ZN20b3AlignedObjectArrayI9b3GpuFaceED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostFaces) #13
  br label %ehcleanup875

ehcleanup875:                                     ; preds = %ehcleanup874, %lpad476
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges) #13
  br label %ehcleanup876

ehcleanup876:                                     ; preds = %ehcleanup875, %lpad473
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostSepAxis) #13
  br label %ehcleanup877

ehcleanup877:                                     ; preds = %ehcleanup876, %lpad469
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostHasSepAxis) #13
  br label %ehcleanup878

ehcleanup878:                                     ; preds = %ehcleanup877, %lpad465
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices) #13
  br label %ehcleanup879

ehcleanup879:                                     ; preds = %ehcleanup878, %lpad462
  call void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexShapeData) #13
  br label %ehcleanup880

ehcleanup880:                                     ; preds = %ehcleanup879, %lpad459
  call void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuChildShapes) #13
  br label %ehcleanup881

ehcleanup881:                                     ; preds = %ehcleanup880, %lpad456
  call void @_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables) #13
  br label %ehcleanup882

ehcleanup882:                                     ; preds = %ehcleanup881, %lpad453
  call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf) #13
  br label %ehcleanup883

ehcleanup883:                                     ; preds = %ehcleanup882, %lpad450
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostPairs) #13
  br label %ehcleanup884

ehcleanup884:                                     ; preds = %ehcleanup883, %lpad448
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile446) #13
  br label %ehcleanup2980

if.end885:                                        ; preds = %invoke.cont871, %if.end444
  %m_numCompoundPairsOut886 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 35
  %call888 = invoke noundef i32 @_ZNK13b3OpenCLArrayIiE2atEm(ptr noundef nonnull align 8 dereferenceable(50) %m_numCompoundPairsOut886, i64 noundef 0)
          to label %invoke.cont887 unwind label %lpad58

invoke.cont887:                                   ; preds = %if.end885
  store i32 %call888, ptr %numCompoundPairs, align 4
  store i8 1, ptr %useGpuFindCompoundPairs, align 1
  %400 = load i8, ptr %useGpuFindCompoundPairs, align 1
  %tobool889 = trunc i8 %400 to i1
  br i1 %tobool889, label %if.then890, label %if.else978

if.then890:                                       ; preds = %invoke.cont887
  invoke void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %__profile891, ptr noundef @.str.15)
          to label %invoke.cont892 unwind label %lpad58

invoke.cont892:                                   ; preds = %if.then890
  %arrayinit.begin894 = getelementptr inbounds [15 x %struct.b3BufferInfoCL], ptr %bInfo893, i64 0, i64 0
  %401 = load ptr, ptr %pairs.addr, align 8
  %call897 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %401)
          to label %invoke.cont896 unwind label %lpad895

invoke.cont896:                                   ; preds = %invoke.cont892
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.begin894, ptr noundef %call897, i1 noundef zeroext true)
          to label %invoke.cont898 unwind label %lpad895

invoke.cont898:                                   ; preds = %invoke.cont896
  %arrayinit.element899 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.begin894, i64 1
  %402 = load ptr, ptr %bodyBuf.addr, align 8
  %call901 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %402)
          to label %invoke.cont900 unwind label %lpad895

invoke.cont900:                                   ; preds = %invoke.cont898
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element899, ptr noundef %call901, i1 noundef zeroext true)
          to label %invoke.cont902 unwind label %lpad895

invoke.cont902:                                   ; preds = %invoke.cont900
  %arrayinit.element903 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element899, i64 1
  %403 = load ptr, ptr %gpuCollidables.addr, align 8
  %call905 = invoke noundef ptr @_ZNK13b3OpenCLArrayI12b3CollidableE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %403)
          to label %invoke.cont904 unwind label %lpad895

invoke.cont904:                                   ; preds = %invoke.cont902
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element903, ptr noundef %call905, i1 noundef zeroext true)
          to label %invoke.cont906 unwind label %lpad895

invoke.cont906:                                   ; preds = %invoke.cont904
  %arrayinit.element907 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element903, i64 1
  %404 = load ptr, ptr %convexData.addr, align 8
  %call909 = invoke noundef ptr @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %404)
          to label %invoke.cont908 unwind label %lpad895

invoke.cont908:                                   ; preds = %invoke.cont906
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element907, ptr noundef %call909, i1 noundef zeroext true)
          to label %invoke.cont910 unwind label %lpad895

invoke.cont910:                                   ; preds = %invoke.cont908
  %arrayinit.element911 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element907, i64 1
  %405 = load ptr, ptr %gpuVertices.addr, align 8
  %call913 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %405)
          to label %invoke.cont912 unwind label %lpad895

invoke.cont912:                                   ; preds = %invoke.cont910
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element911, ptr noundef %call913, i1 noundef zeroext true)
          to label %invoke.cont914 unwind label %lpad895

invoke.cont914:                                   ; preds = %invoke.cont912
  %arrayinit.element915 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element911, i64 1
  %406 = load ptr, ptr %gpuUniqueEdges.addr, align 8
  %call917 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %406)
          to label %invoke.cont916 unwind label %lpad895

invoke.cont916:                                   ; preds = %invoke.cont914
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element915, ptr noundef %call917, i1 noundef zeroext true)
          to label %invoke.cont918 unwind label %lpad895

invoke.cont918:                                   ; preds = %invoke.cont916
  %arrayinit.element919 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element915, i64 1
  %407 = load ptr, ptr %gpuFaces.addr, align 8
  %call921 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3GpuFaceE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %407)
          to label %invoke.cont920 unwind label %lpad895

invoke.cont920:                                   ; preds = %invoke.cont918
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element919, ptr noundef %call921, i1 noundef zeroext true)
          to label %invoke.cont922 unwind label %lpad895

invoke.cont922:                                   ; preds = %invoke.cont920
  %arrayinit.element923 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element919, i64 1
  %408 = load ptr, ptr %gpuIndices.addr, align 8
  %call925 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %408)
          to label %invoke.cont924 unwind label %lpad895

invoke.cont924:                                   ; preds = %invoke.cont922
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element923, ptr noundef %call925, i1 noundef zeroext true)
          to label %invoke.cont926 unwind label %lpad895

invoke.cont926:                                   ; preds = %invoke.cont924
  %arrayinit.element927 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element923, i64 1
  %409 = load ptr, ptr %clAabbsLocalSpace.addr, align 8
  %call929 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3AabbE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %409)
          to label %invoke.cont928 unwind label %lpad895

invoke.cont928:                                   ; preds = %invoke.cont926
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element927, ptr noundef %call929, i1 noundef zeroext true)
          to label %invoke.cont930 unwind label %lpad895

invoke.cont930:                                   ; preds = %invoke.cont928
  %arrayinit.element931 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element927, i64 1
  %410 = load ptr, ptr %gpuChildShapes.addr, align 8
  %call933 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3GpuChildShapeE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %410)
          to label %invoke.cont932 unwind label %lpad895

invoke.cont932:                                   ; preds = %invoke.cont930
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element931, ptr noundef %call933, i1 noundef zeroext true)
          to label %invoke.cont934 unwind label %lpad895

invoke.cont934:                                   ; preds = %invoke.cont932
  %arrayinit.element935 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element931, i64 1
  %m_gpuCompoundPairs936 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 32
  %call938 = invoke noundef ptr @_ZNK13b3OpenCLArrayI25b3CompoundOverlappingPairE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuCompoundPairs936)
          to label %invoke.cont937 unwind label %lpad895

invoke.cont937:                                   ; preds = %invoke.cont934
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element935, ptr noundef %call938, i1 noundef zeroext false)
          to label %invoke.cont939 unwind label %lpad895

invoke.cont939:                                   ; preds = %invoke.cont937
  %arrayinit.element940 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element935, i64 1
  %m_numCompoundPairsOut941 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 35
  %call943 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_numCompoundPairsOut941)
          to label %invoke.cont942 unwind label %lpad895

invoke.cont942:                                   ; preds = %invoke.cont939
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element940, ptr noundef %call943, i1 noundef zeroext false)
          to label %invoke.cont944 unwind label %lpad895

invoke.cont944:                                   ; preds = %invoke.cont942
  %arrayinit.element945 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element940, i64 1
  %411 = load ptr, ptr %subTreesGPU.addr, align 8
  %call947 = invoke noundef ptr @_ZNK13b3OpenCLArrayI16b3BvhSubtreeInfoE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %411)
          to label %invoke.cont946 unwind label %lpad895

invoke.cont946:                                   ; preds = %invoke.cont944
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element945, ptr noundef %call947, i1 noundef zeroext false)
          to label %invoke.cont948 unwind label %lpad895

invoke.cont948:                                   ; preds = %invoke.cont946
  %arrayinit.element949 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element945, i64 1
  %412 = load ptr, ptr %treeNodesGPU.addr, align 8
  %call951 = invoke noundef ptr @_ZNK13b3OpenCLArrayI18b3QuantizedBvhNodeE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %412)
          to label %invoke.cont950 unwind label %lpad895

invoke.cont950:                                   ; preds = %invoke.cont948
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element949, ptr noundef %call951, i1 noundef zeroext false)
          to label %invoke.cont952 unwind label %lpad895

invoke.cont952:                                   ; preds = %invoke.cont950
  %arrayinit.element953 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element949, i64 1
  %413 = load ptr, ptr %bvhInfo.addr, align 8
  %call955 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3BvhInfoE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %413)
          to label %invoke.cont954 unwind label %lpad895

invoke.cont954:                                   ; preds = %invoke.cont952
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element953, ptr noundef %call955, i1 noundef zeroext false)
          to label %invoke.cont956 unwind label %lpad895

invoke.cont956:                                   ; preds = %invoke.cont954
  %m_queue958 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %414 = load ptr, ptr %m_queue958, align 8
  %m_findCompoundPairsKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 12
  %415 = load ptr, ptr %m_findCompoundPairsKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher957, ptr noundef %414, ptr noundef %415, ptr noundef @.str.47)
          to label %invoke.cont959 unwind label %lpad895

invoke.cont959:                                   ; preds = %invoke.cont956
  %arraydecay960 = getelementptr inbounds [15 x %struct.b3BufferInfoCL], ptr %bInfo893, i64 0, i64 0
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher957, ptr noundef %arraydecay960, i32 noundef 15)
          to label %invoke.cont962 unwind label %lpad961

invoke.cont962:                                   ; preds = %invoke.cont959
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher957, ptr noundef nonnull align 4 dereferenceable(4) %nPairs.addr)
          to label %invoke.cont963 unwind label %lpad961

invoke.cont963:                                   ; preds = %invoke.cont962
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher957, ptr noundef nonnull align 4 dereferenceable(4) %compoundPairCapacity.addr)
          to label %invoke.cont964 unwind label %lpad961

invoke.cont964:                                   ; preds = %invoke.cont963
  %416 = load i32, ptr %nPairs.addr, align 4
  store i32 %416, ptr %num965, align 4
  %417 = load i32, ptr %num965, align 4
  invoke void @_ZN12b3LauncherCL8launch1DEii(ptr noundef nonnull align 8 dereferenceable(112) %launcher957, i32 noundef %417, i32 noundef 64)
          to label %invoke.cont966 unwind label %lpad961

invoke.cont966:                                   ; preds = %invoke.cont964
  %418 = load ptr, ptr @__clewFinish, align 8
  %m_queue967 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %419 = load ptr, ptr %m_queue967, align 8
  %call969 = invoke i32 %418(ptr noundef %419)
          to label %invoke.cont968 unwind label %lpad961

invoke.cont968:                                   ; preds = %invoke.cont966
  %m_numCompoundPairsOut970 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 35
  %call972 = invoke noundef i32 @_ZNK13b3OpenCLArrayIiE2atEm(ptr noundef nonnull align 8 dereferenceable(50) %m_numCompoundPairsOut970, i64 noundef 0)
          to label %invoke.cont971 unwind label %lpad961

invoke.cont971:                                   ; preds = %invoke.cont968
  store i32 %call972, ptr %numCompoundPairs, align 4
  %420 = load i32, ptr %numCompoundPairs, align 4
  %tobool973 = icmp ne i32 %420, 0
  br i1 %tobool973, label %if.then974, label %if.end975

if.then974:                                       ; preds = %invoke.cont971
  br label %if.end975

lpad895:                                          ; preds = %invoke.cont956, %invoke.cont954, %invoke.cont952, %invoke.cont950, %invoke.cont948, %invoke.cont946, %invoke.cont944, %invoke.cont942, %invoke.cont939, %invoke.cont937, %invoke.cont934, %invoke.cont932, %invoke.cont930, %invoke.cont928, %invoke.cont926, %invoke.cont924, %invoke.cont922, %invoke.cont920, %invoke.cont918, %invoke.cont916, %invoke.cont914, %invoke.cont912, %invoke.cont910, %invoke.cont908, %invoke.cont906, %invoke.cont904, %invoke.cont902, %invoke.cont900, %invoke.cont898, %invoke.cont896, %invoke.cont892
  %421 = landingpad { ptr, i32 }
          cleanup
  %422 = extractvalue { ptr, i32 } %421, 0
  store ptr %422, ptr %exn.slot, align 8
  %423 = extractvalue { ptr, i32 } %421, 1
  store i32 %423, ptr %ehselector.slot, align 4
  br label %ehcleanup977

lpad961:                                          ; preds = %invoke.cont968, %invoke.cont966, %invoke.cont964, %invoke.cont963, %invoke.cont962, %invoke.cont959
  %424 = landingpad { ptr, i32 }
          cleanup
  %425 = extractvalue { ptr, i32 } %424, 0
  store ptr %425, ptr %exn.slot, align 8
  %426 = extractvalue { ptr, i32 } %424, 1
  store i32 %426, ptr %ehselector.slot, align 4
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher957) #13
  br label %ehcleanup977

if.end975:                                        ; preds = %if.then974, %invoke.cont971
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher957) #13
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile891) #13
  br label %if.end1082

ehcleanup977:                                     ; preds = %lpad961, %lpad895
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile891) #13
  br label %ehcleanup2980

if.else978:                                       ; preds = %invoke.cont887
  invoke void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %treeNodesCPU)
          to label %invoke.cont979 unwind label %lpad58

invoke.cont979:                                   ; preds = %if.else978
  %427 = load ptr, ptr %treeNodesGPU.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI18b3QuantizedBvhNodeE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %427, ptr noundef nonnull align 8 dereferenceable(25) %treeNodesCPU, i1 noundef zeroext true)
          to label %invoke.cont981 unwind label %lpad980

invoke.cont981:                                   ; preds = %invoke.cont979
  invoke void @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %subTreesCPU)
          to label %invoke.cont982 unwind label %lpad980

invoke.cont982:                                   ; preds = %invoke.cont981
  %428 = load ptr, ptr %subTreesGPU.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI16b3BvhSubtreeInfoE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %428, ptr noundef nonnull align 8 dereferenceable(25) %subTreesCPU, i1 noundef zeroext true)
          to label %invoke.cont984 unwind label %lpad983

invoke.cont984:                                   ; preds = %invoke.cont982
  invoke void @_ZN20b3AlignedObjectArrayI9b3BvhInfoEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %bvhInfoCPU)
          to label %invoke.cont985 unwind label %lpad983

invoke.cont985:                                   ; preds = %invoke.cont984
  %429 = load ptr, ptr %bvhInfo.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3BvhInfoE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %429, ptr noundef nonnull align 8 dereferenceable(25) %bvhInfoCPU, i1 noundef zeroext true)
          to label %invoke.cont987 unwind label %lpad986

invoke.cont987:                                   ; preds = %invoke.cont985
  invoke void @_ZN20b3AlignedObjectArrayI6b3AabbEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsWorldSpace)
          to label %invoke.cont988 unwind label %lpad986

invoke.cont988:                                   ; preds = %invoke.cont987
  %430 = load ptr, ptr %clAabbsWorldSpace.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI6b3AabbE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %430, ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsWorldSpace, i1 noundef zeroext true)
          to label %invoke.cont990 unwind label %lpad989

invoke.cont990:                                   ; preds = %invoke.cont988
  invoke void @_ZN20b3AlignedObjectArrayI6b3AabbEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsLocalSpace)
          to label %invoke.cont991 unwind label %lpad989

invoke.cont991:                                   ; preds = %invoke.cont990
  %431 = load ptr, ptr %clAabbsLocalSpace.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI6b3AabbE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %431, ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsLocalSpace, i1 noundef zeroext true)
          to label %invoke.cont993 unwind label %lpad992

invoke.cont993:                                   ; preds = %invoke.cont991
  invoke void @_ZN20b3AlignedObjectArrayI6b3Int4EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostPairs994)
          to label %invoke.cont995 unwind label %lpad992

invoke.cont995:                                   ; preds = %invoke.cont993
  %432 = load ptr, ptr %pairs.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI6b3Int4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %432, ptr noundef nonnull align 8 dereferenceable(25) %hostPairs994, i1 noundef zeroext true)
          to label %invoke.cont997 unwind label %lpad996

invoke.cont997:                                   ; preds = %invoke.cont995
  invoke void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf998)
          to label %invoke.cont999 unwind label %lpad996

invoke.cont999:                                   ; preds = %invoke.cont997
  %433 = load ptr, ptr %bodyBuf.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %433, ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf998, i1 noundef zeroext true)
          to label %invoke.cont1001 unwind label %lpad1000

invoke.cont1001:                                  ; preds = %invoke.cont999
  invoke void @_ZN20b3AlignedObjectArrayI6b3Int4EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuCompoundPairsOut)
          to label %invoke.cont1002 unwind label %lpad1000

invoke.cont1002:                                  ; preds = %invoke.cont1001
  %434 = load i32, ptr %compoundPairCapacity.addr, align 4
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp1003, i8 0, i64 16, i1 false)
  invoke void @_ZN20b3AlignedObjectArrayI6b3Int4E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %cpuCompoundPairsOut, i32 noundef %434, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp1003)
          to label %invoke.cont1005 unwind label %lpad1004

invoke.cont1005:                                  ; preds = %invoke.cont1002
  invoke void @_ZN20b3AlignedObjectArrayI12b3CollidableEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables1006)
          to label %invoke.cont1007 unwind label %lpad1004

invoke.cont1007:                                  ; preds = %invoke.cont1005
  %435 = load ptr, ptr %gpuCollidables.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI12b3CollidableE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %435, ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables1006, i1 noundef zeroext true)
          to label %invoke.cont1009 unwind label %lpad1008

invoke.cont1009:                                  ; preds = %invoke.cont1007
  invoke void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuChildShapes1010)
          to label %invoke.cont1011 unwind label %lpad1008

invoke.cont1011:                                  ; preds = %invoke.cont1009
  %436 = load ptr, ptr %gpuChildShapes.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI15b3GpuChildShapeE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %436, ptr noundef nonnull align 8 dereferenceable(25) %cpuChildShapes1010, i1 noundef zeroext true)
          to label %invoke.cont1013 unwind label %lpad1012

invoke.cont1013:                                  ; preds = %invoke.cont1011
  invoke void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexData)
          to label %invoke.cont1014 unwind label %lpad1012

invoke.cont1014:                                  ; preds = %invoke.cont1013
  %437 = load ptr, ptr %convexData.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %437, ptr noundef nonnull align 8 dereferenceable(25) %hostConvexData, i1 noundef zeroext true)
          to label %invoke.cont1016 unwind label %lpad1015

invoke.cont1016:                                  ; preds = %invoke.cont1014
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices1017)
          to label %invoke.cont1018 unwind label %lpad1015

invoke.cont1018:                                  ; preds = %invoke.cont1016
  %438 = load ptr, ptr %gpuVertices.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %438, ptr noundef nonnull align 8 dereferenceable(25) %hostVertices1017, i1 noundef zeroext true)
          to label %invoke.cont1020 unwind label %lpad1019

invoke.cont1020:                                  ; preds = %invoke.cont1018
  store i32 0, ptr %pairIndex1021, align 4
  br label %for.cond1022

for.cond1022:                                     ; preds = %for.inc1057, %invoke.cont1020
  %439 = load i32, ptr %pairIndex1021, align 4
  %440 = load i32, ptr %nPairs.addr, align 4
  %cmp1023 = icmp slt i32 %439, %440
  br i1 %cmp1023, label %for.body1024, label %for.end1059

for.body1024:                                     ; preds = %for.cond1022
  %441 = load i32, ptr %pairIndex1021, align 4
  %call1027 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI6b3Int4EixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostPairs994, i32 noundef %441)
          to label %invoke.cont1026 unwind label %lpad1019

invoke.cont1026:                                  ; preds = %for.body1024
  %442 = getelementptr inbounds %struct.b3Int4, ptr %call1027, i32 0, i32 0
  %x1028 = getelementptr inbounds %struct.anon, ptr %442, i32 0, i32 0
  %443 = load i32, ptr %x1028, align 16
  store i32 %443, ptr %bodyIndexA1025, align 4
  %444 = load i32, ptr %pairIndex1021, align 4
  %call1031 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI6b3Int4EixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostPairs994, i32 noundef %444)
          to label %invoke.cont1030 unwind label %lpad1019

invoke.cont1030:                                  ; preds = %invoke.cont1026
  %445 = getelementptr inbounds %struct.b3Int4, ptr %call1031, i32 0, i32 0
  %y1032 = getelementptr inbounds %struct.anon, ptr %445, i32 0, i32 1
  %446 = load i32, ptr %y1032, align 4
  store i32 %446, ptr %bodyIndexB1029, align 4
  %447 = load i32, ptr %bodyIndexA1025, align 4
  %call1035 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf998, i32 noundef %447)
          to label %invoke.cont1034 unwind label %lpad1019

invoke.cont1034:                                  ; preds = %invoke.cont1030
  %m_collidableIdx1036 = getelementptr inbounds %struct.b3RigidBodyData, ptr %call1035, i32 0, i32 4
  %448 = load i32, ptr %m_collidableIdx1036, align 16
  store i32 %448, ptr %collidableIndexA1033, align 4
  %449 = load i32, ptr %bodyIndexB1029, align 4
  %call1039 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf998, i32 noundef %449)
          to label %invoke.cont1038 unwind label %lpad1019

invoke.cont1038:                                  ; preds = %invoke.cont1034
  %m_collidableIdx1040 = getelementptr inbounds %struct.b3RigidBodyData, ptr %call1039, i32 0, i32 4
  %450 = load i32, ptr %m_collidableIdx1040, align 16
  store i32 %450, ptr %collidableIndexB1037, align 4
  %call1042 = invoke noundef i32 @_ZNK20b3AlignedObjectArrayI15b3GpuChildShapeE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %cpuChildShapes1010)
          to label %invoke.cont1041 unwind label %lpad1019

invoke.cont1041:                                  ; preds = %invoke.cont1038
  %tobool1043 = icmp ne i32 %call1042, 0
  br i1 %tobool1043, label %if.then1044, label %if.end1056

if.then1044:                                      ; preds = %invoke.cont1041
  %451 = load i32, ptr %pairIndex1021, align 4
  %452 = load i32, ptr %bodyIndexA1025, align 4
  %453 = load i32, ptr %bodyIndexB1029, align 4
  %454 = load i32, ptr %collidableIndexA1033, align 4
  %455 = load i32, ptr %collidableIndexB1037, align 4
  %call1046 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf998, i32 noundef 0)
          to label %invoke.cont1045 unwind label %lpad1019

invoke.cont1045:                                  ; preds = %if.then1044
  %call1048 = invoke noundef nonnull align 4 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI12b3CollidableEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables1006, i32 noundef 0)
          to label %invoke.cont1047 unwind label %lpad1019

invoke.cont1047:                                  ; preds = %invoke.cont1045
  %call1050 = invoke noundef nonnull align 16 dereferenceable(96) ptr @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexData, i32 noundef 0)
          to label %invoke.cont1049 unwind label %lpad1019

invoke.cont1049:                                  ; preds = %invoke.cont1047
  %call1052 = invoke noundef nonnull align 16 dereferenceable(48) ptr @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeEixEi(ptr noundef nonnull align 8 dereferenceable(25) %cpuChildShapes1010, i32 noundef 0)
          to label %invoke.cont1051 unwind label %lpad1019

invoke.cont1051:                                  ; preds = %invoke.cont1049
  %call1054 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI6b3Int4EixEi(ptr noundef nonnull align 8 dereferenceable(25) %cpuCompoundPairsOut, i32 noundef 0)
          to label %invoke.cont1053 unwind label %lpad1019

invoke.cont1053:                                  ; preds = %invoke.cont1051
  %456 = load i32, ptr %compoundPairCapacity.addr, align 4
  invoke void @_Z23findCompoundPairsKerneliiiiiPK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataRK20b3AlignedObjectArrayI9b3Vector3ERKS8_I6b3AabbESG_PK15b3GpuChildShapeP6b3Int4PiiRS8_I18b3QuantizedBvhNodeERS8_I16b3BvhSubtreeInfoERS8_I9b3BvhInfoE(i32 noundef %451, i32 noundef %452, i32 noundef %453, i32 noundef %454, i32 noundef %455, ptr noundef %call1046, ptr noundef %call1048, ptr noundef %call1050, ptr noundef nonnull align 8 dereferenceable(25) %hostVertices1017, ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsWorldSpace, ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsLocalSpace, ptr noundef %call1052, ptr noundef %call1054, ptr noundef %numCompoundPairs, i32 noundef %456, ptr noundef nonnull align 8 dereferenceable(25) %treeNodesCPU, ptr noundef nonnull align 8 dereferenceable(25) %subTreesCPU, ptr noundef nonnull align 8 dereferenceable(25) %bvhInfoCPU)
          to label %invoke.cont1055 unwind label %lpad1019

invoke.cont1055:                                  ; preds = %invoke.cont1053
  br label %if.end1056

lpad980:                                          ; preds = %invoke.cont981, %invoke.cont979
  %457 = landingpad { ptr, i32 }
          cleanup
  %458 = extractvalue { ptr, i32 } %457, 0
  store ptr %458, ptr %exn.slot, align 8
  %459 = extractvalue { ptr, i32 } %457, 1
  store i32 %459, ptr %ehselector.slot, align 4
  br label %ehcleanup1081

lpad983:                                          ; preds = %invoke.cont984, %invoke.cont982
  %460 = landingpad { ptr, i32 }
          cleanup
  %461 = extractvalue { ptr, i32 } %460, 0
  store ptr %461, ptr %exn.slot, align 8
  %462 = extractvalue { ptr, i32 } %460, 1
  store i32 %462, ptr %ehselector.slot, align 4
  br label %ehcleanup1080

lpad986:                                          ; preds = %invoke.cont987, %invoke.cont985
  %463 = landingpad { ptr, i32 }
          cleanup
  %464 = extractvalue { ptr, i32 } %463, 0
  store ptr %464, ptr %exn.slot, align 8
  %465 = extractvalue { ptr, i32 } %463, 1
  store i32 %465, ptr %ehselector.slot, align 4
  br label %ehcleanup1079

lpad989:                                          ; preds = %invoke.cont990, %invoke.cont988
  %466 = landingpad { ptr, i32 }
          cleanup
  %467 = extractvalue { ptr, i32 } %466, 0
  store ptr %467, ptr %exn.slot, align 8
  %468 = extractvalue { ptr, i32 } %466, 1
  store i32 %468, ptr %ehselector.slot, align 4
  br label %ehcleanup1078

lpad992:                                          ; preds = %invoke.cont993, %invoke.cont991
  %469 = landingpad { ptr, i32 }
          cleanup
  %470 = extractvalue { ptr, i32 } %469, 0
  store ptr %470, ptr %exn.slot, align 8
  %471 = extractvalue { ptr, i32 } %469, 1
  store i32 %471, ptr %ehselector.slot, align 4
  br label %ehcleanup1077

lpad996:                                          ; preds = %invoke.cont997, %invoke.cont995
  %472 = landingpad { ptr, i32 }
          cleanup
  %473 = extractvalue { ptr, i32 } %472, 0
  store ptr %473, ptr %exn.slot, align 8
  %474 = extractvalue { ptr, i32 } %472, 1
  store i32 %474, ptr %ehselector.slot, align 4
  br label %ehcleanup1076

lpad1000:                                         ; preds = %invoke.cont1001, %invoke.cont999
  %475 = landingpad { ptr, i32 }
          cleanup
  %476 = extractvalue { ptr, i32 } %475, 0
  store ptr %476, ptr %exn.slot, align 8
  %477 = extractvalue { ptr, i32 } %475, 1
  store i32 %477, ptr %ehselector.slot, align 4
  br label %ehcleanup1075

lpad1004:                                         ; preds = %invoke.cont1005, %invoke.cont1002
  %478 = landingpad { ptr, i32 }
          cleanup
  %479 = extractvalue { ptr, i32 } %478, 0
  store ptr %479, ptr %exn.slot, align 8
  %480 = extractvalue { ptr, i32 } %478, 1
  store i32 %480, ptr %ehselector.slot, align 4
  br label %ehcleanup1074

lpad1008:                                         ; preds = %invoke.cont1009, %invoke.cont1007
  %481 = landingpad { ptr, i32 }
          cleanup
  %482 = extractvalue { ptr, i32 } %481, 0
  store ptr %482, ptr %exn.slot, align 8
  %483 = extractvalue { ptr, i32 } %481, 1
  store i32 %483, ptr %ehselector.slot, align 4
  br label %ehcleanup1073

lpad1012:                                         ; preds = %invoke.cont1013, %invoke.cont1011
  %484 = landingpad { ptr, i32 }
          cleanup
  %485 = extractvalue { ptr, i32 } %484, 0
  store ptr %485, ptr %exn.slot, align 8
  %486 = extractvalue { ptr, i32 } %484, 1
  store i32 %486, ptr %ehselector.slot, align 4
  br label %ehcleanup1072

lpad1015:                                         ; preds = %invoke.cont1016, %invoke.cont1014
  %487 = landingpad { ptr, i32 }
          cleanup
  %488 = extractvalue { ptr, i32 } %487, 0
  store ptr %488, ptr %exn.slot, align 8
  %489 = extractvalue { ptr, i32 } %487, 1
  store i32 %489, ptr %ehselector.slot, align 4
  br label %ehcleanup1071

lpad1019:                                         ; preds = %invoke.cont1064, %if.then1063, %for.end1059, %invoke.cont1053, %invoke.cont1051, %invoke.cont1049, %invoke.cont1047, %invoke.cont1045, %if.then1044, %invoke.cont1038, %invoke.cont1034, %invoke.cont1030, %invoke.cont1026, %for.body1024, %invoke.cont1018
  %490 = landingpad { ptr, i32 }
          cleanup
  %491 = extractvalue { ptr, i32 } %490, 0
  store ptr %491, ptr %exn.slot, align 8
  %492 = extractvalue { ptr, i32 } %490, 1
  store i32 %492, ptr %ehselector.slot, align 4
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices1017) #13
  br label %ehcleanup1071

if.end1056:                                       ; preds = %invoke.cont1055, %invoke.cont1041
  br label %for.inc1057

for.inc1057:                                      ; preds = %if.end1056
  %493 = load i32, ptr %pairIndex1021, align 4
  %inc1058 = add nsw i32 %493, 1
  store i32 %inc1058, ptr %pairIndex1021, align 4
  br label %for.cond1022, !llvm.loop !69

for.end1059:                                      ; preds = %for.cond1022
  %m_numCompoundPairsOut1060 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 35
  invoke void @_ZN13b3OpenCLArrayIiE19copyFromHostPointerEPKimmb(ptr noundef nonnull align 8 dereferenceable(50) %m_numCompoundPairsOut1060, ptr noundef %numCompoundPairs, i64 noundef 1, i64 noundef 0, i1 noundef zeroext true)
          to label %invoke.cont1061 unwind label %lpad1019

invoke.cont1061:                                  ; preds = %for.end1059
  %494 = load i32, ptr %numCompoundPairs, align 4
  %tobool1062 = icmp ne i32 %494, 0
  br i1 %tobool1062, label %if.then1063, label %if.end1069

if.then1063:                                      ; preds = %invoke.cont1061
  %call1065 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI6b3Int4EixEi(ptr noundef nonnull align 8 dereferenceable(25) %cpuCompoundPairsOut, i32 noundef 0)
          to label %invoke.cont1064 unwind label %lpad1019

invoke.cont1064:                                  ; preds = %if.then1063
  store ptr %call1065, ptr %ptr, align 8
  %m_gpuCompoundPairs1066 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 32
  %495 = load ptr, ptr %ptr, align 8
  %496 = load i32, ptr %numCompoundPairs, align 4
  %conv1067 = sext i32 %496 to i64
  invoke void @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE19copyFromHostPointerEPKS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuCompoundPairs1066, ptr noundef %495, i64 noundef %conv1067, i64 noundef 0, i1 noundef zeroext true)
          to label %invoke.cont1068 unwind label %lpad1019

invoke.cont1068:                                  ; preds = %invoke.cont1064
  br label %if.end1069

if.end1069:                                       ; preds = %invoke.cont1068, %invoke.cont1061
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices1017) #13
  call void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexData) #13
  call void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuChildShapes1010) #13
  call void @_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables1006) #13
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuCompoundPairsOut) #13
  call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf998) #13
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostPairs994) #13
  call void @_ZN20b3AlignedObjectArrayI6b3AabbED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsLocalSpace) #13
  call void @_ZN20b3AlignedObjectArrayI6b3AabbED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsWorldSpace) #13
  call void @_ZN20b3AlignedObjectArrayI9b3BvhInfoED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %bvhInfoCPU) #13
  call void @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %subTreesCPU) #13
  call void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %treeNodesCPU) #13
  br label %if.end1082

ehcleanup1071:                                    ; preds = %lpad1019, %lpad1015
  call void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexData) #13
  br label %ehcleanup1072

ehcleanup1072:                                    ; preds = %ehcleanup1071, %lpad1012
  call void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuChildShapes1010) #13
  br label %ehcleanup1073

ehcleanup1073:                                    ; preds = %ehcleanup1072, %lpad1008
  call void @_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables1006) #13
  br label %ehcleanup1074

ehcleanup1074:                                    ; preds = %ehcleanup1073, %lpad1004
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuCompoundPairsOut) #13
  br label %ehcleanup1075

ehcleanup1075:                                    ; preds = %ehcleanup1074, %lpad1000
  call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf998) #13
  br label %ehcleanup1076

ehcleanup1076:                                    ; preds = %ehcleanup1075, %lpad996
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostPairs994) #13
  br label %ehcleanup1077

ehcleanup1077:                                    ; preds = %ehcleanup1076, %lpad992
  call void @_ZN20b3AlignedObjectArrayI6b3AabbED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsLocalSpace) #13
  br label %ehcleanup1078

ehcleanup1078:                                    ; preds = %ehcleanup1077, %lpad989
  call void @_ZN20b3AlignedObjectArrayI6b3AabbED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsWorldSpace) #13
  br label %ehcleanup1079

ehcleanup1079:                                    ; preds = %ehcleanup1078, %lpad986
  call void @_ZN20b3AlignedObjectArrayI9b3BvhInfoED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %bvhInfoCPU) #13
  br label %ehcleanup1080

ehcleanup1080:                                    ; preds = %ehcleanup1079, %lpad983
  call void @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %subTreesCPU) #13
  br label %ehcleanup1081

ehcleanup1081:                                    ; preds = %ehcleanup1080, %lpad980
  call void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %treeNodesCPU) #13
  br label %ehcleanup2980

if.end1082:                                       ; preds = %if.end1069, %if.end975
  %497 = load i32, ptr %numCompoundPairs, align 4
  %tobool1083 = icmp ne i32 %497, 0
  br i1 %tobool1083, label %if.then1084, label %if.end1087

if.then1084:                                      ; preds = %if.end1082
  %498 = load i32, ptr %numCompoundPairs, align 4
  %call1086 = invoke i32 (ptr, ...) @printf(ptr noundef @.str.48, i32 noundef %498)
          to label %invoke.cont1085 unwind label %lpad58

invoke.cont1085:                                  ; preds = %if.then1084
  br label %if.end1087

if.end1087:                                       ; preds = %invoke.cont1085, %if.end1082
  %499 = load i32, ptr %numCompoundPairs, align 4
  %500 = load i32, ptr %compoundPairCapacity.addr, align 4
  %cmp1088 = icmp sgt i32 %499, %500
  br i1 %cmp1088, label %if.then1089, label %if.end1095

if.then1089:                                      ; preds = %if.end1087
  br label %do.body1090

do.body1090:                                      ; preds = %if.then1089
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.31, i32 noundef 3407)
          to label %invoke.cont1091 unwind label %lpad58

invoke.cont1091:                                  ; preds = %do.body1090
  %501 = load i32, ptr %numCompoundPairs, align 4
  %502 = load i32, ptr %compoundPairCapacity.addr, align 4
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.49, i32 noundef %501, i32 noundef %502)
          to label %invoke.cont1092 unwind label %lpad58

invoke.cont1092:                                  ; preds = %invoke.cont1091
  br label %do.cond1093

do.cond1093:                                      ; preds = %invoke.cont1092
  br label %do.end1094

do.end1094:                                       ; preds = %do.cond1093
  %503 = load i32, ptr %compoundPairCapacity.addr, align 4
  store i32 %503, ptr %numCompoundPairs, align 4
  br label %if.end1095

if.end1095:                                       ; preds = %do.end1094, %if.end1087
  %m_gpuCompoundPairs1096 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 32
  %504 = load i32, ptr %numCompoundPairs, align 4
  %conv1097 = sext i32 %504 to i64
  %call1099 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuCompoundPairs1096, i64 noundef %conv1097, i1 noundef zeroext true)
          to label %invoke.cont1098 unwind label %lpad58

invoke.cont1098:                                  ; preds = %if.end1095
  %m_gpuHasCompoundSepNormals1100 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 34
  %505 = load i32, ptr %numCompoundPairs, align 4
  %conv1101 = sext i32 %505 to i64
  %call1103 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayIiE6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuHasCompoundSepNormals1100, i64 noundef %conv1101, i1 noundef zeroext true)
          to label %invoke.cont1102 unwind label %lpad58

invoke.cont1102:                                  ; preds = %invoke.cont1098
  %m_gpuCompoundSepNormals1104 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 33
  %506 = load i32, ptr %numCompoundPairs, align 4
  %conv1105 = sext i32 %506 to i64
  %call1107 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuCompoundSepNormals1104, i64 noundef %conv1105, i1 noundef zeroext true)
          to label %invoke.cont1106 unwind label %lpad58

invoke.cont1106:                                  ; preds = %invoke.cont1102
  %507 = load i32, ptr %numCompoundPairs, align 4
  %tobool1108 = icmp ne i32 %507, 0
  br i1 %tobool1108, label %if.then1109, label %if.end1190

if.then1109:                                      ; preds = %invoke.cont1106
  invoke void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %__profile1110, ptr noundef @.str.29)
          to label %invoke.cont1111 unwind label %lpad58

invoke.cont1111:                                  ; preds = %if.then1109
  %arrayinit.begin1113 = getelementptr inbounds [12 x %struct.b3BufferInfoCL], ptr %bInfo1112, i64 0, i64 0
  %m_gpuCompoundPairs1114 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 32
  %call1117 = invoke noundef ptr @_ZNK13b3OpenCLArrayI25b3CompoundOverlappingPairE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuCompoundPairs1114)
          to label %invoke.cont1116 unwind label %lpad1115

invoke.cont1116:                                  ; preds = %invoke.cont1111
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.begin1113, ptr noundef %call1117, i1 noundef zeroext true)
          to label %invoke.cont1118 unwind label %lpad1115

invoke.cont1118:                                  ; preds = %invoke.cont1116
  %arrayinit.element1119 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.begin1113, i64 1
  %508 = load ptr, ptr %bodyBuf.addr, align 8
  %call1121 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %508)
          to label %invoke.cont1120 unwind label %lpad1115

invoke.cont1120:                                  ; preds = %invoke.cont1118
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1119, ptr noundef %call1121, i1 noundef zeroext true)
          to label %invoke.cont1122 unwind label %lpad1115

invoke.cont1122:                                  ; preds = %invoke.cont1120
  %arrayinit.element1123 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1119, i64 1
  %509 = load ptr, ptr %gpuCollidables.addr, align 8
  %call1125 = invoke noundef ptr @_ZNK13b3OpenCLArrayI12b3CollidableE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %509)
          to label %invoke.cont1124 unwind label %lpad1115

invoke.cont1124:                                  ; preds = %invoke.cont1122
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1123, ptr noundef %call1125, i1 noundef zeroext true)
          to label %invoke.cont1126 unwind label %lpad1115

invoke.cont1126:                                  ; preds = %invoke.cont1124
  %arrayinit.element1127 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1123, i64 1
  %510 = load ptr, ptr %convexData.addr, align 8
  %call1129 = invoke noundef ptr @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %510)
          to label %invoke.cont1128 unwind label %lpad1115

invoke.cont1128:                                  ; preds = %invoke.cont1126
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1127, ptr noundef %call1129, i1 noundef zeroext true)
          to label %invoke.cont1130 unwind label %lpad1115

invoke.cont1130:                                  ; preds = %invoke.cont1128
  %arrayinit.element1131 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1127, i64 1
  %511 = load ptr, ptr %gpuVertices.addr, align 8
  %call1133 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %511)
          to label %invoke.cont1132 unwind label %lpad1115

invoke.cont1132:                                  ; preds = %invoke.cont1130
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1131, ptr noundef %call1133, i1 noundef zeroext true)
          to label %invoke.cont1134 unwind label %lpad1115

invoke.cont1134:                                  ; preds = %invoke.cont1132
  %arrayinit.element1135 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1131, i64 1
  %512 = load ptr, ptr %gpuUniqueEdges.addr, align 8
  %call1137 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %512)
          to label %invoke.cont1136 unwind label %lpad1115

invoke.cont1136:                                  ; preds = %invoke.cont1134
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1135, ptr noundef %call1137, i1 noundef zeroext true)
          to label %invoke.cont1138 unwind label %lpad1115

invoke.cont1138:                                  ; preds = %invoke.cont1136
  %arrayinit.element1139 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1135, i64 1
  %513 = load ptr, ptr %gpuFaces.addr, align 8
  %call1141 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3GpuFaceE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %513)
          to label %invoke.cont1140 unwind label %lpad1115

invoke.cont1140:                                  ; preds = %invoke.cont1138
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1139, ptr noundef %call1141, i1 noundef zeroext true)
          to label %invoke.cont1142 unwind label %lpad1115

invoke.cont1142:                                  ; preds = %invoke.cont1140
  %arrayinit.element1143 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1139, i64 1
  %514 = load ptr, ptr %gpuIndices.addr, align 8
  %call1145 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %514)
          to label %invoke.cont1144 unwind label %lpad1115

invoke.cont1144:                                  ; preds = %invoke.cont1142
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1143, ptr noundef %call1145, i1 noundef zeroext true)
          to label %invoke.cont1146 unwind label %lpad1115

invoke.cont1146:                                  ; preds = %invoke.cont1144
  %arrayinit.element1147 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1143, i64 1
  %515 = load ptr, ptr %clAabbsWorldSpace.addr, align 8
  %call1149 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3AabbE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %515)
          to label %invoke.cont1148 unwind label %lpad1115

invoke.cont1148:                                  ; preds = %invoke.cont1146
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1147, ptr noundef %call1149, i1 noundef zeroext true)
          to label %invoke.cont1150 unwind label %lpad1115

invoke.cont1150:                                  ; preds = %invoke.cont1148
  %arrayinit.element1151 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1147, i64 1
  %516 = load ptr, ptr %gpuChildShapes.addr, align 8
  %call1153 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3GpuChildShapeE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %516)
          to label %invoke.cont1152 unwind label %lpad1115

invoke.cont1152:                                  ; preds = %invoke.cont1150
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1151, ptr noundef %call1153, i1 noundef zeroext true)
          to label %invoke.cont1154 unwind label %lpad1115

invoke.cont1154:                                  ; preds = %invoke.cont1152
  %arrayinit.element1155 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1151, i64 1
  %517 = load ptr, ptr %contactOut.addr, align 8
  %call1157 = invoke noundef ptr @_ZNK13b3OpenCLArrayI10b3Contact4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %517)
          to label %invoke.cont1156 unwind label %lpad1115

invoke.cont1156:                                  ; preds = %invoke.cont1154
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1155, ptr noundef %call1157, i1 noundef zeroext false)
          to label %invoke.cont1158 unwind label %lpad1115

invoke.cont1158:                                  ; preds = %invoke.cont1156
  %arrayinit.element1159 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1155, i64 1
  %m_totalContactsOut1160 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %call1162 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut1160)
          to label %invoke.cont1161 unwind label %lpad1115

invoke.cont1161:                                  ; preds = %invoke.cont1158
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1159, ptr noundef %call1162, i1 noundef zeroext false)
          to label %invoke.cont1163 unwind label %lpad1115

invoke.cont1163:                                  ; preds = %invoke.cont1161
  %m_queue1165 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %518 = load ptr, ptr %m_queue1165, align 8
  %m_processCompoundPairsPrimitivesKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 23
  %519 = load ptr, ptr %m_processCompoundPairsPrimitivesKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher1164, ptr noundef %518, ptr noundef %519, ptr noundef @.str.50)
          to label %invoke.cont1166 unwind label %lpad1115

invoke.cont1166:                                  ; preds = %invoke.cont1163
  %arraydecay1167 = getelementptr inbounds [12 x %struct.b3BufferInfoCL], ptr %bInfo1112, i64 0, i64 0
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher1164, ptr noundef %arraydecay1167, i32 noundef 12)
          to label %invoke.cont1169 unwind label %lpad1168

invoke.cont1169:                                  ; preds = %invoke.cont1166
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher1164, ptr noundef nonnull align 4 dereferenceable(4) %numCompoundPairs)
          to label %invoke.cont1170 unwind label %lpad1168

invoke.cont1170:                                  ; preds = %invoke.cont1169
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher1164, ptr noundef nonnull align 4 dereferenceable(4) %maxContactCapacity.addr)
          to label %invoke.cont1171 unwind label %lpad1168

invoke.cont1171:                                  ; preds = %invoke.cont1170
  %520 = load i32, ptr %numCompoundPairs, align 4
  store i32 %520, ptr %num1172, align 4
  %521 = load i32, ptr %num1172, align 4
  invoke void @_ZN12b3LauncherCL8launch1DEii(ptr noundef nonnull align 8 dereferenceable(112) %launcher1164, i32 noundef %521, i32 noundef 64)
          to label %invoke.cont1173 unwind label %lpad1168

invoke.cont1173:                                  ; preds = %invoke.cont1171
  %522 = load ptr, ptr @__clewFinish, align 8
  %m_queue1174 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %523 = load ptr, ptr %m_queue1174, align 8
  %call1176 = invoke i32 %522(ptr noundef %523)
          to label %invoke.cont1175 unwind label %lpad1168

invoke.cont1175:                                  ; preds = %invoke.cont1173
  %m_totalContactsOut1177 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %call1179 = invoke noundef i32 @_ZNK13b3OpenCLArrayIiE2atEm(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut1177, i64 noundef 0)
          to label %invoke.cont1178 unwind label %lpad1168

invoke.cont1178:                                  ; preds = %invoke.cont1175
  %524 = load ptr, ptr %nContacts.addr, align 8
  store i32 %call1179, ptr %524, align 4
  %525 = load ptr, ptr %nContacts.addr, align 8
  %526 = load i32, ptr %525, align 4
  %527 = load i32, ptr %maxContactCapacity.addr, align 4
  %cmp1180 = icmp sgt i32 %526, %527
  br i1 %cmp1180, label %if.then1181, label %if.end1187

if.then1181:                                      ; preds = %invoke.cont1178
  br label %do.body1182

do.body1182:                                      ; preds = %if.then1181
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.31, i32 noundef 3445)
          to label %invoke.cont1183 unwind label %lpad1168

invoke.cont1183:                                  ; preds = %do.body1182
  %528 = load ptr, ptr %nContacts.addr, align 8
  %529 = load i32, ptr %528, align 4
  %530 = load i32, ptr %maxContactCapacity.addr, align 4
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.41, i32 noundef %529, i32 noundef %530)
          to label %invoke.cont1184 unwind label %lpad1168

invoke.cont1184:                                  ; preds = %invoke.cont1183
  br label %do.cond1185

do.cond1185:                                      ; preds = %invoke.cont1184
  br label %do.end1186

do.end1186:                                       ; preds = %do.cond1185
  %531 = load i32, ptr %maxContactCapacity.addr, align 4
  %532 = load ptr, ptr %nContacts.addr, align 8
  store i32 %531, ptr %532, align 4
  br label %if.end1187

lpad1115:                                         ; preds = %invoke.cont1163, %invoke.cont1161, %invoke.cont1158, %invoke.cont1156, %invoke.cont1154, %invoke.cont1152, %invoke.cont1150, %invoke.cont1148, %invoke.cont1146, %invoke.cont1144, %invoke.cont1142, %invoke.cont1140, %invoke.cont1138, %invoke.cont1136, %invoke.cont1134, %invoke.cont1132, %invoke.cont1130, %invoke.cont1128, %invoke.cont1126, %invoke.cont1124, %invoke.cont1122, %invoke.cont1120, %invoke.cont1118, %invoke.cont1116, %invoke.cont1111
  %533 = landingpad { ptr, i32 }
          cleanup
  %534 = extractvalue { ptr, i32 } %533, 0
  store ptr %534, ptr %exn.slot, align 8
  %535 = extractvalue { ptr, i32 } %533, 1
  store i32 %535, ptr %ehselector.slot, align 4
  br label %ehcleanup1189

lpad1168:                                         ; preds = %invoke.cont1183, %do.body1182, %invoke.cont1175, %invoke.cont1173, %invoke.cont1171, %invoke.cont1170, %invoke.cont1169, %invoke.cont1166
  %536 = landingpad { ptr, i32 }
          cleanup
  %537 = extractvalue { ptr, i32 } %536, 0
  store ptr %537, ptr %exn.slot, align 8
  %538 = extractvalue { ptr, i32 } %536, 1
  store i32 %538, ptr %ehselector.slot, align 4
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1164) #13
  br label %ehcleanup1189

if.end1187:                                       ; preds = %do.end1186, %invoke.cont1178
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1164) #13
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile1110) #13
  br label %if.end1190

ehcleanup1189:                                    ; preds = %lpad1168, %lpad1115
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile1110) #13
  br label %ehcleanup2980

if.end1190:                                       ; preds = %if.end1187, %invoke.cont1106
  %539 = load i32, ptr %numCompoundPairs, align 4
  %tobool1191 = icmp ne i32 %539, 0
  br i1 %tobool1191, label %if.then1192, label %if.end1262

if.then1192:                                      ; preds = %if.end1190
  invoke void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %__profile1193, ptr noundef @.str.16)
          to label %invoke.cont1194 unwind label %lpad58

invoke.cont1194:                                  ; preds = %if.then1192
  %arrayinit.begin1196 = getelementptr inbounds [12 x %struct.b3BufferInfoCL], ptr %bInfo1195, i64 0, i64 0
  %m_gpuCompoundPairs1197 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 32
  %call1200 = invoke noundef ptr @_ZNK13b3OpenCLArrayI25b3CompoundOverlappingPairE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuCompoundPairs1197)
          to label %invoke.cont1199 unwind label %lpad1198

invoke.cont1199:                                  ; preds = %invoke.cont1194
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.begin1196, ptr noundef %call1200, i1 noundef zeroext true)
          to label %invoke.cont1201 unwind label %lpad1198

invoke.cont1201:                                  ; preds = %invoke.cont1199
  %arrayinit.element1202 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.begin1196, i64 1
  %540 = load ptr, ptr %bodyBuf.addr, align 8
  %call1204 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %540)
          to label %invoke.cont1203 unwind label %lpad1198

invoke.cont1203:                                  ; preds = %invoke.cont1201
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1202, ptr noundef %call1204, i1 noundef zeroext true)
          to label %invoke.cont1205 unwind label %lpad1198

invoke.cont1205:                                  ; preds = %invoke.cont1203
  %arrayinit.element1206 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1202, i64 1
  %541 = load ptr, ptr %gpuCollidables.addr, align 8
  %call1208 = invoke noundef ptr @_ZNK13b3OpenCLArrayI12b3CollidableE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %541)
          to label %invoke.cont1207 unwind label %lpad1198

invoke.cont1207:                                  ; preds = %invoke.cont1205
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1206, ptr noundef %call1208, i1 noundef zeroext true)
          to label %invoke.cont1209 unwind label %lpad1198

invoke.cont1209:                                  ; preds = %invoke.cont1207
  %arrayinit.element1210 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1206, i64 1
  %542 = load ptr, ptr %convexData.addr, align 8
  %call1212 = invoke noundef ptr @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %542)
          to label %invoke.cont1211 unwind label %lpad1198

invoke.cont1211:                                  ; preds = %invoke.cont1209
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1210, ptr noundef %call1212, i1 noundef zeroext true)
          to label %invoke.cont1213 unwind label %lpad1198

invoke.cont1213:                                  ; preds = %invoke.cont1211
  %arrayinit.element1214 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1210, i64 1
  %543 = load ptr, ptr %gpuVertices.addr, align 8
  %call1216 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %543)
          to label %invoke.cont1215 unwind label %lpad1198

invoke.cont1215:                                  ; preds = %invoke.cont1213
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1214, ptr noundef %call1216, i1 noundef zeroext true)
          to label %invoke.cont1217 unwind label %lpad1198

invoke.cont1217:                                  ; preds = %invoke.cont1215
  %arrayinit.element1218 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1214, i64 1
  %544 = load ptr, ptr %gpuUniqueEdges.addr, align 8
  %call1220 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %544)
          to label %invoke.cont1219 unwind label %lpad1198

invoke.cont1219:                                  ; preds = %invoke.cont1217
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1218, ptr noundef %call1220, i1 noundef zeroext true)
          to label %invoke.cont1221 unwind label %lpad1198

invoke.cont1221:                                  ; preds = %invoke.cont1219
  %arrayinit.element1222 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1218, i64 1
  %545 = load ptr, ptr %gpuFaces.addr, align 8
  %call1224 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3GpuFaceE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %545)
          to label %invoke.cont1223 unwind label %lpad1198

invoke.cont1223:                                  ; preds = %invoke.cont1221
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1222, ptr noundef %call1224, i1 noundef zeroext true)
          to label %invoke.cont1225 unwind label %lpad1198

invoke.cont1225:                                  ; preds = %invoke.cont1223
  %arrayinit.element1226 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1222, i64 1
  %546 = load ptr, ptr %gpuIndices.addr, align 8
  %call1228 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %546)
          to label %invoke.cont1227 unwind label %lpad1198

invoke.cont1227:                                  ; preds = %invoke.cont1225
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1226, ptr noundef %call1228, i1 noundef zeroext true)
          to label %invoke.cont1229 unwind label %lpad1198

invoke.cont1229:                                  ; preds = %invoke.cont1227
  %arrayinit.element1230 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1226, i64 1
  %547 = load ptr, ptr %clAabbsWorldSpace.addr, align 8
  %call1232 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3AabbE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %547)
          to label %invoke.cont1231 unwind label %lpad1198

invoke.cont1231:                                  ; preds = %invoke.cont1229
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1230, ptr noundef %call1232, i1 noundef zeroext true)
          to label %invoke.cont1233 unwind label %lpad1198

invoke.cont1233:                                  ; preds = %invoke.cont1231
  %arrayinit.element1234 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1230, i64 1
  %548 = load ptr, ptr %gpuChildShapes.addr, align 8
  %call1236 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3GpuChildShapeE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %548)
          to label %invoke.cont1235 unwind label %lpad1198

invoke.cont1235:                                  ; preds = %invoke.cont1233
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1234, ptr noundef %call1236, i1 noundef zeroext true)
          to label %invoke.cont1237 unwind label %lpad1198

invoke.cont1237:                                  ; preds = %invoke.cont1235
  %arrayinit.element1238 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1234, i64 1
  %m_gpuCompoundSepNormals1239 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 33
  %call1241 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuCompoundSepNormals1239)
          to label %invoke.cont1240 unwind label %lpad1198

invoke.cont1240:                                  ; preds = %invoke.cont1237
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1238, ptr noundef %call1241, i1 noundef zeroext false)
          to label %invoke.cont1242 unwind label %lpad1198

invoke.cont1242:                                  ; preds = %invoke.cont1240
  %arrayinit.element1243 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1238, i64 1
  %m_gpuHasCompoundSepNormals1244 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 34
  %call1246 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuHasCompoundSepNormals1244)
          to label %invoke.cont1245 unwind label %lpad1198

invoke.cont1245:                                  ; preds = %invoke.cont1242
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1243, ptr noundef %call1246, i1 noundef zeroext false)
          to label %invoke.cont1247 unwind label %lpad1198

invoke.cont1247:                                  ; preds = %invoke.cont1245
  %m_queue1249 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %549 = load ptr, ptr %m_queue1249, align 8
  %m_processCompoundPairsKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 13
  %550 = load ptr, ptr %m_processCompoundPairsKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher1248, ptr noundef %549, ptr noundef %550, ptr noundef @.str.51)
          to label %invoke.cont1250 unwind label %lpad1198

invoke.cont1250:                                  ; preds = %invoke.cont1247
  %arraydecay1251 = getelementptr inbounds [12 x %struct.b3BufferInfoCL], ptr %bInfo1195, i64 0, i64 0
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher1248, ptr noundef %arraydecay1251, i32 noundef 12)
          to label %invoke.cont1253 unwind label %lpad1252

invoke.cont1253:                                  ; preds = %invoke.cont1250
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher1248, ptr noundef nonnull align 4 dereferenceable(4) %numCompoundPairs)
          to label %invoke.cont1254 unwind label %lpad1252

invoke.cont1254:                                  ; preds = %invoke.cont1253
  %551 = load i32, ptr %numCompoundPairs, align 4
  store i32 %551, ptr %num1255, align 4
  %552 = load i32, ptr %num1255, align 4
  invoke void @_ZN12b3LauncherCL8launch1DEii(ptr noundef nonnull align 8 dereferenceable(112) %launcher1248, i32 noundef %552, i32 noundef 64)
          to label %invoke.cont1256 unwind label %lpad1252

invoke.cont1256:                                  ; preds = %invoke.cont1254
  %553 = load ptr, ptr @__clewFinish, align 8
  %m_queue1257 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %554 = load ptr, ptr %m_queue1257, align 8
  %call1259 = invoke i32 %553(ptr noundef %554)
          to label %invoke.cont1258 unwind label %lpad1252

invoke.cont1258:                                  ; preds = %invoke.cont1256
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1248) #13
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile1193) #13
  br label %if.end1262

lpad1198:                                         ; preds = %invoke.cont1247, %invoke.cont1245, %invoke.cont1242, %invoke.cont1240, %invoke.cont1237, %invoke.cont1235, %invoke.cont1233, %invoke.cont1231, %invoke.cont1229, %invoke.cont1227, %invoke.cont1225, %invoke.cont1223, %invoke.cont1221, %invoke.cont1219, %invoke.cont1217, %invoke.cont1215, %invoke.cont1213, %invoke.cont1211, %invoke.cont1209, %invoke.cont1207, %invoke.cont1205, %invoke.cont1203, %invoke.cont1201, %invoke.cont1199, %invoke.cont1194
  %555 = landingpad { ptr, i32 }
          cleanup
  %556 = extractvalue { ptr, i32 } %555, 0
  store ptr %556, ptr %exn.slot, align 8
  %557 = extractvalue { ptr, i32 } %555, 1
  store i32 %557, ptr %ehselector.slot, align 4
  br label %ehcleanup1261

lpad1252:                                         ; preds = %invoke.cont1256, %invoke.cont1254, %invoke.cont1253, %invoke.cont1250
  %558 = landingpad { ptr, i32 }
          cleanup
  %559 = extractvalue { ptr, i32 } %558, 0
  store ptr %559, ptr %exn.slot, align 8
  %560 = extractvalue { ptr, i32 } %558, 1
  store i32 %560, ptr %ehselector.slot, align 4
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1248) #13
  br label %ehcleanup1261

ehcleanup1261:                                    ; preds = %lpad1252, %lpad1198
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile1193) #13
  br label %ehcleanup2980

if.end1262:                                       ; preds = %invoke.cont1258, %if.end1190
  store i32 64, ptr %vertexFaceCapacity, align 4
  %561 = load ptr, ptr %treeNodesGPU.addr, align 8
  %call1264 = invoke noundef i64 @_ZNK13b3OpenCLArrayI18b3QuantizedBvhNodeE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %561)
          to label %invoke.cont1263 unwind label %lpad58

invoke.cont1263:                                  ; preds = %if.end1262
  %tobool1265 = icmp ne i64 %call1264, 0
  br i1 %tobool1265, label %land.lhs.true1266, label %if.end1853

land.lhs.true1266:                                ; preds = %invoke.cont1263
  %562 = load ptr, ptr %treeNodesGPU.addr, align 8
  %call1268 = invoke noundef i64 @_ZNK13b3OpenCLArrayI18b3QuantizedBvhNodeE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %562)
          to label %invoke.cont1267 unwind label %lpad58

invoke.cont1267:                                  ; preds = %land.lhs.true1266
  %tobool1269 = icmp ne i64 %call1268, 0
  br i1 %tobool1269, label %if.then1270, label %if.end1853

if.then1270:                                      ; preds = %invoke.cont1267
  %563 = load i8, ptr @bvhTraversalKernelGPU, align 1
  %tobool1271 = trunc i8 %563 to i1
  br i1 %tobool1271, label %if.then1272, label %if.else1323

if.then1272:                                      ; preds = %if.then1270
  invoke void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %__profile1273, ptr noundef @.str.52)
          to label %invoke.cont1274 unwind label %lpad58

invoke.cont1274:                                  ; preds = %if.then1272
  %m_numConcavePairsOut1275 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 31
  %call1278 = invoke noundef i32 @_ZNK13b3OpenCLArrayIiE2atEm(ptr noundef nonnull align 8 dereferenceable(50) %m_numConcavePairsOut1275, i64 noundef 0)
          to label %invoke.cont1277 unwind label %lpad1276

invoke.cont1277:                                  ; preds = %invoke.cont1274
  store i32 %call1278, ptr %numConcavePairs, align 4
  %m_queue1280 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %564 = load ptr, ptr %m_queue1280, align 8
  %m_bvhTraversalKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 20
  %565 = load ptr, ptr %m_bvhTraversalKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279, ptr noundef %564, ptr noundef %565, ptr noundef @.str.52)
          to label %invoke.cont1281 unwind label %lpad1276

invoke.cont1281:                                  ; preds = %invoke.cont1277
  %566 = load ptr, ptr %pairs.addr, align 8
  %call1284 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %566)
          to label %invoke.cont1283 unwind label %lpad1282

invoke.cont1283:                                  ; preds = %invoke.cont1281
  invoke void @_ZN12b3LauncherCL9setBufferEP7_cl_mem(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279, ptr noundef %call1284)
          to label %invoke.cont1285 unwind label %lpad1282

invoke.cont1285:                                  ; preds = %invoke.cont1283
  %567 = load ptr, ptr %bodyBuf.addr, align 8
  %call1287 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %567)
          to label %invoke.cont1286 unwind label %lpad1282

invoke.cont1286:                                  ; preds = %invoke.cont1285
  invoke void @_ZN12b3LauncherCL9setBufferEP7_cl_mem(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279, ptr noundef %call1287)
          to label %invoke.cont1288 unwind label %lpad1282

invoke.cont1288:                                  ; preds = %invoke.cont1286
  %568 = load ptr, ptr %gpuCollidables.addr, align 8
  %call1290 = invoke noundef ptr @_ZNK13b3OpenCLArrayI12b3CollidableE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %568)
          to label %invoke.cont1289 unwind label %lpad1282

invoke.cont1289:                                  ; preds = %invoke.cont1288
  invoke void @_ZN12b3LauncherCL9setBufferEP7_cl_mem(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279, ptr noundef %call1290)
          to label %invoke.cont1291 unwind label %lpad1282

invoke.cont1291:                                  ; preds = %invoke.cont1289
  %569 = load ptr, ptr %clAabbsWorldSpace.addr, align 8
  %call1293 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3AabbE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %569)
          to label %invoke.cont1292 unwind label %lpad1282

invoke.cont1292:                                  ; preds = %invoke.cont1291
  invoke void @_ZN12b3LauncherCL9setBufferEP7_cl_mem(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279, ptr noundef %call1293)
          to label %invoke.cont1294 unwind label %lpad1282

invoke.cont1294:                                  ; preds = %invoke.cont1292
  %570 = load ptr, ptr %triangleConvexPairsOut.addr, align 8
  %call1296 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %570)
          to label %invoke.cont1295 unwind label %lpad1282

invoke.cont1295:                                  ; preds = %invoke.cont1294
  invoke void @_ZN12b3LauncherCL9setBufferEP7_cl_mem(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279, ptr noundef %call1296)
          to label %invoke.cont1297 unwind label %lpad1282

invoke.cont1297:                                  ; preds = %invoke.cont1295
  %m_numConcavePairsOut1298 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 31
  %call1300 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_numConcavePairsOut1298)
          to label %invoke.cont1299 unwind label %lpad1282

invoke.cont1299:                                  ; preds = %invoke.cont1297
  invoke void @_ZN12b3LauncherCL9setBufferEP7_cl_mem(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279, ptr noundef %call1300)
          to label %invoke.cont1301 unwind label %lpad1282

invoke.cont1301:                                  ; preds = %invoke.cont1299
  %571 = load ptr, ptr %subTreesGPU.addr, align 8
  %call1303 = invoke noundef ptr @_ZNK13b3OpenCLArrayI16b3BvhSubtreeInfoE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %571)
          to label %invoke.cont1302 unwind label %lpad1282

invoke.cont1302:                                  ; preds = %invoke.cont1301
  invoke void @_ZN12b3LauncherCL9setBufferEP7_cl_mem(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279, ptr noundef %call1303)
          to label %invoke.cont1304 unwind label %lpad1282

invoke.cont1304:                                  ; preds = %invoke.cont1302
  %572 = load ptr, ptr %treeNodesGPU.addr, align 8
  %call1306 = invoke noundef ptr @_ZNK13b3OpenCLArrayI18b3QuantizedBvhNodeE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %572)
          to label %invoke.cont1305 unwind label %lpad1282

invoke.cont1305:                                  ; preds = %invoke.cont1304
  invoke void @_ZN12b3LauncherCL9setBufferEP7_cl_mem(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279, ptr noundef %call1306)
          to label %invoke.cont1307 unwind label %lpad1282

invoke.cont1307:                                  ; preds = %invoke.cont1305
  %573 = load ptr, ptr %bvhInfo.addr, align 8
  %call1309 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3BvhInfoE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %573)
          to label %invoke.cont1308 unwind label %lpad1282

invoke.cont1308:                                  ; preds = %invoke.cont1307
  invoke void @_ZN12b3LauncherCL9setBufferEP7_cl_mem(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279, ptr noundef %call1309)
          to label %invoke.cont1310 unwind label %lpad1282

invoke.cont1310:                                  ; preds = %invoke.cont1308
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279, ptr noundef nonnull align 4 dereferenceable(4) %nPairs.addr)
          to label %invoke.cont1311 unwind label %lpad1282

invoke.cont1311:                                  ; preds = %invoke.cont1310
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279, ptr noundef nonnull align 4 dereferenceable(4) %maxTriConvexPairCapacity.addr)
          to label %invoke.cont1312 unwind label %lpad1282

invoke.cont1312:                                  ; preds = %invoke.cont1311
  %574 = load i32, ptr %nPairs.addr, align 4
  store i32 %574, ptr %num1313, align 4
  %575 = load i32, ptr %num1313, align 4
  invoke void @_ZN12b3LauncherCL8launch1DEii(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279, i32 noundef %575, i32 noundef 64)
          to label %invoke.cont1314 unwind label %lpad1282

invoke.cont1314:                                  ; preds = %invoke.cont1312
  %576 = load ptr, ptr @__clewFinish, align 8
  %m_queue1315 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %577 = load ptr, ptr %m_queue1315, align 8
  %call1317 = invoke i32 %576(ptr noundef %577)
          to label %invoke.cont1316 unwind label %lpad1282

invoke.cont1316:                                  ; preds = %invoke.cont1314
  %m_numConcavePairsOut1318 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 31
  %call1320 = invoke noundef i32 @_ZNK13b3OpenCLArrayIiE2atEm(ptr noundef nonnull align 8 dereferenceable(50) %m_numConcavePairsOut1318, i64 noundef 0)
          to label %invoke.cont1319 unwind label %lpad1282

invoke.cont1319:                                  ; preds = %invoke.cont1316
  store i32 %call1320, ptr %numConcavePairs, align 4
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279) #13
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile1273) #13
  br label %if.end1400

lpad1276:                                         ; preds = %invoke.cont1277, %invoke.cont1274
  %578 = landingpad { ptr, i32 }
          cleanup
  %579 = extractvalue { ptr, i32 } %578, 0
  store ptr %579, ptr %exn.slot, align 8
  %580 = extractvalue { ptr, i32 } %578, 1
  store i32 %580, ptr %ehselector.slot, align 4
  br label %ehcleanup1322

lpad1282:                                         ; preds = %invoke.cont1316, %invoke.cont1314, %invoke.cont1312, %invoke.cont1311, %invoke.cont1310, %invoke.cont1308, %invoke.cont1307, %invoke.cont1305, %invoke.cont1304, %invoke.cont1302, %invoke.cont1301, %invoke.cont1299, %invoke.cont1297, %invoke.cont1295, %invoke.cont1294, %invoke.cont1292, %invoke.cont1291, %invoke.cont1289, %invoke.cont1288, %invoke.cont1286, %invoke.cont1285, %invoke.cont1283, %invoke.cont1281
  %581 = landingpad { ptr, i32 }
          cleanup
  %582 = extractvalue { ptr, i32 } %581, 0
  store ptr %582, ptr %exn.slot, align 8
  %583 = extractvalue { ptr, i32 } %581, 1
  store i32 %583, ptr %ehselector.slot, align 4
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279) #13
  br label %ehcleanup1322

ehcleanup1322:                                    ; preds = %lpad1282, %lpad1276
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile1273) #13
  br label %ehcleanup2980

if.else1323:                                      ; preds = %if.then1270
  invoke void @_ZN20b3AlignedObjectArrayI6b3Int4EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostPairs1324)
          to label %invoke.cont1325 unwind label %lpad58

invoke.cont1325:                                  ; preds = %if.else1323
  %584 = load ptr, ptr %pairs.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI6b3Int4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %584, ptr noundef nonnull align 8 dereferenceable(25) %hostPairs1324, i1 noundef zeroext true)
          to label %invoke.cont1327 unwind label %lpad1326

invoke.cont1327:                                  ; preds = %invoke.cont1325
  invoke void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf1328)
          to label %invoke.cont1329 unwind label %lpad1326

invoke.cont1329:                                  ; preds = %invoke.cont1327
  %585 = load ptr, ptr %bodyBuf.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %585, ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf1328, i1 noundef zeroext true)
          to label %invoke.cont1331 unwind label %lpad1330

invoke.cont1331:                                  ; preds = %invoke.cont1329
  invoke void @_ZN20b3AlignedObjectArrayI12b3CollidableEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables1332)
          to label %invoke.cont1333 unwind label %lpad1330

invoke.cont1333:                                  ; preds = %invoke.cont1331
  %586 = load ptr, ptr %gpuCollidables.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI12b3CollidableE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %586, ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables1332, i1 noundef zeroext true)
          to label %invoke.cont1335 unwind label %lpad1334

invoke.cont1335:                                  ; preds = %invoke.cont1333
  invoke void @_ZN20b3AlignedObjectArrayI6b3AabbEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsWorldSpace1336)
          to label %invoke.cont1337 unwind label %lpad1334

invoke.cont1337:                                  ; preds = %invoke.cont1335
  %587 = load ptr, ptr %clAabbsWorldSpace.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI6b3AabbE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %587, ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsWorldSpace1336, i1 noundef zeroext true)
          to label %invoke.cont1339 unwind label %lpad1338

invoke.cont1339:                                  ; preds = %invoke.cont1337
  invoke void @_ZN20b3AlignedObjectArrayI6b3Int4EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %triangleConvexPairsOutHost)
          to label %invoke.cont1340 unwind label %lpad1338

invoke.cont1340:                                  ; preds = %invoke.cont1339
  %588 = load i32, ptr %maxTriConvexPairCapacity.addr, align 4
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp1341, i8 0, i64 16, i1 false)
  invoke void @_ZN20b3AlignedObjectArrayI6b3Int4E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %triangleConvexPairsOutHost, i32 noundef %588, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp1341)
          to label %invoke.cont1343 unwind label %lpad1342

invoke.cont1343:                                  ; preds = %invoke.cont1340
  store i32 0, ptr %numConcavePairs, align 4
  invoke void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %treeNodesCPU1344)
          to label %invoke.cont1345 unwind label %lpad1342

invoke.cont1345:                                  ; preds = %invoke.cont1343
  %589 = load ptr, ptr %treeNodesGPU.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI18b3QuantizedBvhNodeE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %589, ptr noundef nonnull align 8 dereferenceable(25) %treeNodesCPU1344, i1 noundef zeroext true)
          to label %invoke.cont1347 unwind label %lpad1346

invoke.cont1347:                                  ; preds = %invoke.cont1345
  invoke void @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %subTreesCPU1348)
          to label %invoke.cont1349 unwind label %lpad1346

invoke.cont1349:                                  ; preds = %invoke.cont1347
  %590 = load ptr, ptr %subTreesGPU.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI16b3BvhSubtreeInfoE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %590, ptr noundef nonnull align 8 dereferenceable(25) %subTreesCPU1348, i1 noundef zeroext true)
          to label %invoke.cont1351 unwind label %lpad1350

invoke.cont1351:                                  ; preds = %invoke.cont1349
  invoke void @_ZN20b3AlignedObjectArrayI9b3BvhInfoEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %bvhInfoCPU1352)
          to label %invoke.cont1353 unwind label %lpad1350

invoke.cont1353:                                  ; preds = %invoke.cont1351
  %591 = load ptr, ptr %bvhInfo.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3BvhInfoE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %591, ptr noundef nonnull align 8 dereferenceable(25) %bvhInfoCPU1352, i1 noundef zeroext true)
          to label %invoke.cont1355 unwind label %lpad1354

invoke.cont1355:                                  ; preds = %invoke.cont1353
  store volatile i32 0, ptr %hostNumConcavePairsOut, align 4
  store i32 0, ptr %i1356, align 4
  br label %for.cond1357

for.cond1357:                                     ; preds = %for.inc1377, %invoke.cont1355
  %592 = load i32, ptr %i1356, align 4
  %593 = load i32, ptr %nPairs.addr, align 4
  %cmp1358 = icmp slt i32 %592, %593
  br i1 %cmp1358, label %for.body1359, label %for.end1379

for.body1359:                                     ; preds = %for.cond1357
  %call1361 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI6b3Int4E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostPairs1324, i32 noundef 0)
          to label %invoke.cont1360 unwind label %lpad1354

invoke.cont1360:                                  ; preds = %for.body1359
  %call1363 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf1328, i32 noundef 0)
          to label %invoke.cont1362 unwind label %lpad1354

invoke.cont1362:                                  ; preds = %invoke.cont1360
  %call1365 = invoke noundef nonnull align 4 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI12b3CollidableE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables1332, i32 noundef 0)
          to label %invoke.cont1364 unwind label %lpad1354

invoke.cont1364:                                  ; preds = %invoke.cont1362
  %call1367 = invoke noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI6b3AabbE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsWorldSpace1336, i32 noundef 0)
          to label %invoke.cont1366 unwind label %lpad1354

invoke.cont1366:                                  ; preds = %invoke.cont1364
  %call1369 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI6b3Int4E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %triangleConvexPairsOutHost, i32 noundef 0)
          to label %invoke.cont1368 unwind label %lpad1354

invoke.cont1368:                                  ; preds = %invoke.cont1366
  %call1371 = invoke noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %subTreesCPU1348, i32 noundef 0)
          to label %invoke.cont1370 unwind label %lpad1354

invoke.cont1370:                                  ; preds = %invoke.cont1368
  %call1373 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %treeNodesCPU1344, i32 noundef 0)
          to label %invoke.cont1372 unwind label %lpad1354

invoke.cont1372:                                  ; preds = %invoke.cont1370
  %call1375 = invoke noundef nonnull align 16 dereferenceable(64) ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %bvhInfoCPU1352, i32 noundef 0)
          to label %invoke.cont1374 unwind label %lpad1354

invoke.cont1374:                                  ; preds = %invoke.cont1372
  %594 = load i32, ptr %nPairs.addr, align 4
  %595 = load i32, ptr %maxTriConvexPairCapacity.addr, align 4
  %596 = load i32, ptr %i1356, align 4
  invoke void @_Z14b3BvhTraversalPK6b3Int4PK15b3RigidBodyDataPK12b3CollidableP6b3AabbPS_PViPK16b3BvhSubtreeInfoPK18b3QuantizedBvhNodePK9b3BvhInfoiii(ptr noundef %call1361, ptr noundef %call1363, ptr noundef %call1365, ptr noundef %call1367, ptr noundef %call1369, ptr noundef %hostNumConcavePairsOut, ptr noundef %call1371, ptr noundef %call1373, ptr noundef %call1375, i32 noundef %594, i32 noundef %595, i32 noundef %596)
          to label %invoke.cont1376 unwind label %lpad1354

invoke.cont1376:                                  ; preds = %invoke.cont1374
  br label %for.inc1377

for.inc1377:                                      ; preds = %invoke.cont1376
  %597 = load i32, ptr %i1356, align 4
  %inc1378 = add nsw i32 %597, 1
  store i32 %inc1378, ptr %i1356, align 4
  br label %for.cond1357, !llvm.loop !70

lpad1326:                                         ; preds = %invoke.cont1327, %invoke.cont1325
  %598 = landingpad { ptr, i32 }
          cleanup
  %599 = extractvalue { ptr, i32 } %598, 0
  store ptr %599, ptr %exn.slot, align 8
  %600 = extractvalue { ptr, i32 } %598, 1
  store i32 %600, ptr %ehselector.slot, align 4
  br label %ehcleanup1399

lpad1330:                                         ; preds = %invoke.cont1331, %invoke.cont1329
  %601 = landingpad { ptr, i32 }
          cleanup
  %602 = extractvalue { ptr, i32 } %601, 0
  store ptr %602, ptr %exn.slot, align 8
  %603 = extractvalue { ptr, i32 } %601, 1
  store i32 %603, ptr %ehselector.slot, align 4
  br label %ehcleanup1398

lpad1334:                                         ; preds = %invoke.cont1335, %invoke.cont1333
  %604 = landingpad { ptr, i32 }
          cleanup
  %605 = extractvalue { ptr, i32 } %604, 0
  store ptr %605, ptr %exn.slot, align 8
  %606 = extractvalue { ptr, i32 } %604, 1
  store i32 %606, ptr %ehselector.slot, align 4
  br label %ehcleanup1397

lpad1338:                                         ; preds = %invoke.cont1339, %invoke.cont1337
  %607 = landingpad { ptr, i32 }
          cleanup
  %608 = extractvalue { ptr, i32 } %607, 0
  store ptr %608, ptr %exn.slot, align 8
  %609 = extractvalue { ptr, i32 } %607, 1
  store i32 %609, ptr %ehselector.slot, align 4
  br label %ehcleanup1396

lpad1342:                                         ; preds = %invoke.cont1343, %invoke.cont1340
  %610 = landingpad { ptr, i32 }
          cleanup
  %611 = extractvalue { ptr, i32 } %610, 0
  store ptr %611, ptr %exn.slot, align 8
  %612 = extractvalue { ptr, i32 } %610, 1
  store i32 %612, ptr %ehselector.slot, align 4
  br label %ehcleanup1395

lpad1346:                                         ; preds = %invoke.cont1347, %invoke.cont1345
  %613 = landingpad { ptr, i32 }
          cleanup
  %614 = extractvalue { ptr, i32 } %613, 0
  store ptr %614, ptr %exn.slot, align 8
  %615 = extractvalue { ptr, i32 } %613, 1
  store i32 %615, ptr %ehselector.slot, align 4
  br label %ehcleanup1394

lpad1350:                                         ; preds = %invoke.cont1351, %invoke.cont1349
  %616 = landingpad { ptr, i32 }
          cleanup
  %617 = extractvalue { ptr, i32 } %616, 0
  store ptr %617, ptr %exn.slot, align 8
  %618 = extractvalue { ptr, i32 } %616, 1
  store i32 %618, ptr %ehselector.slot, align 4
  br label %ehcleanup1393

lpad1354:                                         ; preds = %invoke.cont1387, %if.end1385, %invoke.cont1383, %if.then1381, %invoke.cont1374, %invoke.cont1372, %invoke.cont1370, %invoke.cont1368, %invoke.cont1366, %invoke.cont1364, %invoke.cont1362, %invoke.cont1360, %for.body1359, %invoke.cont1353
  %619 = landingpad { ptr, i32 }
          cleanup
  %620 = extractvalue { ptr, i32 } %619, 0
  store ptr %620, ptr %exn.slot, align 8
  %621 = extractvalue { ptr, i32 } %619, 1
  store i32 %621, ptr %ehselector.slot, align 4
  call void @_ZN20b3AlignedObjectArrayI9b3BvhInfoED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %bvhInfoCPU1352) #13
  br label %ehcleanup1393

for.end1379:                                      ; preds = %for.cond1357
  %622 = load volatile i32, ptr %hostNumConcavePairsOut, align 4
  store i32 %622, ptr %numConcavePairs, align 4
  %623 = load volatile i32, ptr %hostNumConcavePairsOut, align 4
  %tobool1380 = icmp ne i32 %623, 0
  br i1 %tobool1380, label %if.then1381, label %if.end1385

if.then1381:                                      ; preds = %for.end1379
  %624 = load volatile i32, ptr %hostNumConcavePairsOut, align 4
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp1382, i8 0, i64 16, i1 false)
  invoke void @_ZN20b3AlignedObjectArrayI6b3Int4E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %triangleConvexPairsOutHost, i32 noundef %624, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp1382)
          to label %invoke.cont1383 unwind label %lpad1354

invoke.cont1383:                                  ; preds = %if.then1381
  %625 = load ptr, ptr %triangleConvexPairsOut.addr, align 8
  invoke void @_ZN13b3OpenCLArrayI6b3Int4E12copyFromHostERK20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %625, ptr noundef nonnull align 8 dereferenceable(25) %triangleConvexPairsOutHost, i1 noundef zeroext true)
          to label %invoke.cont1384 unwind label %lpad1354

invoke.cont1384:                                  ; preds = %invoke.cont1383
  br label %if.end1385

if.end1385:                                       ; preds = %invoke.cont1384, %for.end1379
  %m_numConcavePairsOut1386 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 31
  %call1388 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayIiE6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_numConcavePairsOut1386, i64 noundef 0, i1 noundef zeroext true)
          to label %invoke.cont1387 unwind label %lpad1354

invoke.cont1387:                                  ; preds = %if.end1385
  %m_numConcavePairsOut1389 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 31
  %call1391 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayIiE9push_backERKib(ptr noundef nonnull align 8 dereferenceable(50) %m_numConcavePairsOut1389, ptr noundef nonnull align 4 dereferenceable(4) %numConcavePairs, i1 noundef zeroext true)
          to label %invoke.cont1390 unwind label %lpad1354

invoke.cont1390:                                  ; preds = %invoke.cont1387
  call void @_ZN20b3AlignedObjectArrayI9b3BvhInfoED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %bvhInfoCPU1352) #13
  call void @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %subTreesCPU1348) #13
  call void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %treeNodesCPU1344) #13
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %triangleConvexPairsOutHost) #13
  call void @_ZN20b3AlignedObjectArrayI6b3AabbED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsWorldSpace1336) #13
  call void @_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables1332) #13
  call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf1328) #13
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostPairs1324) #13
  br label %if.end1400

ehcleanup1393:                                    ; preds = %lpad1354, %lpad1350
  call void @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %subTreesCPU1348) #13
  br label %ehcleanup1394

ehcleanup1394:                                    ; preds = %ehcleanup1393, %lpad1346
  call void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %treeNodesCPU1344) #13
  br label %ehcleanup1395

ehcleanup1395:                                    ; preds = %ehcleanup1394, %lpad1342
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %triangleConvexPairsOutHost) #13
  br label %ehcleanup1396

ehcleanup1396:                                    ; preds = %ehcleanup1395, %lpad1338
  call void @_ZN20b3AlignedObjectArrayI6b3AabbED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsWorldSpace1336) #13
  br label %ehcleanup1397

ehcleanup1397:                                    ; preds = %ehcleanup1396, %lpad1334
  call void @_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables1332) #13
  br label %ehcleanup1398

ehcleanup1398:                                    ; preds = %ehcleanup1397, %lpad1330
  call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf1328) #13
  br label %ehcleanup1399

ehcleanup1399:                                    ; preds = %ehcleanup1398, %lpad1326
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostPairs1324) #13
  br label %ehcleanup2980

if.end1400:                                       ; preds = %invoke.cont1390, %invoke.cont1319
  %626 = load i32, ptr %numConcavePairs, align 4
  %627 = load i32, ptr %maxTriConvexPairCapacity.addr, align 4
  %cmp1401 = icmp sgt i32 %626, %627
  br i1 %cmp1401, label %if.then1402, label %if.end1409

if.then1402:                                      ; preds = %if.end1400
  br label %do.body1403

do.body1403:                                      ; preds = %if.then1402
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.31, i32 noundef 3577)
          to label %invoke.cont1404 unwind label %lpad58

invoke.cont1404:                                  ; preds = %do.body1403
  %628 = load i32, ptr %numConcavePairs, align 4
  %629 = load i32, ptr %maxTriConvexPairCapacity.addr, align 4
  %630 = load i32, ptr @_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E39exceeded_maxTriConvexPairCapacity_count, align 4
  %inc1405 = add nsw i32 %630, 1
  store i32 %inc1405, ptr @_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E39exceeded_maxTriConvexPairCapacity_count, align 4
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.53, i32 noundef %628, i32 noundef %629, i32 noundef %630)
          to label %invoke.cont1406 unwind label %lpad58

invoke.cont1406:                                  ; preds = %invoke.cont1404
  br label %do.cond1407

do.cond1407:                                      ; preds = %invoke.cont1406
  br label %do.end1408

do.end1408:                                       ; preds = %do.cond1407
  %631 = load i32, ptr %maxTriConvexPairCapacity.addr, align 4
  store i32 %631, ptr %numConcavePairs, align 4
  br label %if.end1409

if.end1409:                                       ; preds = %do.end1408, %if.end1400
  %632 = load ptr, ptr %triangleConvexPairsOut.addr, align 8
  %633 = load i32, ptr %numConcavePairs, align 4
  %conv1410 = sext i32 %633 to i64
  %call1412 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI6b3Int4E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %632, i64 noundef %conv1410, i1 noundef zeroext true)
          to label %invoke.cont1411 unwind label %lpad58

invoke.cont1411:                                  ; preds = %if.end1409
  %634 = load i32, ptr %numConcavePairs, align 4
  %tobool1413 = icmp ne i32 %634, 0
  br i1 %tobool1413, label %if.then1414, label %if.end1852

if.then1414:                                      ; preds = %invoke.cont1411
  %635 = load ptr, ptr %clippingFacesOutGPU.addr, align 8
  %636 = load i32, ptr %numConcavePairs, align 4
  %conv1415 = sext i32 %636 to i64
  %call1417 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI6b3Int4E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %635, i64 noundef %conv1415, i1 noundef zeroext true)
          to label %invoke.cont1416 unwind label %lpad58

invoke.cont1416:                                  ; preds = %if.then1414
  %637 = load ptr, ptr %worldNormalsAGPU.addr, align 8
  %638 = load i32, ptr %numConcavePairs, align 4
  %conv1418 = sext i32 %638 to i64
  %call1420 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %637, i64 noundef %conv1418, i1 noundef zeroext true)
          to label %invoke.cont1419 unwind label %lpad58

invoke.cont1419:                                  ; preds = %invoke.cont1416
  %639 = load ptr, ptr %worldVertsA1GPU.addr, align 8
  %640 = load i32, ptr %vertexFaceCapacity, align 4
  %641 = load i32, ptr %numConcavePairs, align 4
  %mul = mul nsw i32 %640, %641
  %conv1421 = sext i32 %mul to i64
  %call1423 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %639, i64 noundef %conv1421, i1 noundef zeroext true)
          to label %invoke.cont1422 unwind label %lpad58

invoke.cont1422:                                  ; preds = %invoke.cont1419
  %642 = load ptr, ptr %worldVertsB1GPU.addr, align 8
  %643 = load i32, ptr %vertexFaceCapacity, align 4
  %644 = load i32, ptr %numConcavePairs, align 4
  %mul1424 = mul nsw i32 %643, %644
  %conv1425 = sext i32 %mul1424 to i64
  %call1427 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %642, i64 noundef %conv1425, i1 noundef zeroext true)
          to label %invoke.cont1426 unwind label %lpad58

invoke.cont1426:                                  ; preds = %invoke.cont1422
  %645 = load i8, ptr @findConcaveSeparatingAxisKernelGPU, align 1
  %tobool1428 = trunc i8 %645 to i1
  br i1 %tobool1428, label %if.then1429, label %if.else1703

if.then1429:                                      ; preds = %invoke.cont1426
  %646 = load i8, ptr @splitSearchSepAxisConcave, align 1
  %tobool1430 = trunc i8 %646 to i1
  br i1 %tobool1430, label %if.then1431, label %if.else1616

if.then1431:                                      ; preds = %if.then1429
  %m_dmins1432 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 27
  %647 = load i32, ptr %numConcavePairs, align 4
  %conv1433 = sext i32 %647 to i64
  %call1435 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayIfE6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_dmins1432, i64 noundef %conv1433, i1 noundef zeroext true)
          to label %invoke.cont1434 unwind label %lpad58

invoke.cont1434:                                  ; preds = %if.then1431
  invoke void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %__profile1436, ptr noundef @.str.13)
          to label %invoke.cont1437 unwind label %lpad58

invoke.cont1437:                                  ; preds = %invoke.cont1434
  %arrayinit.begin1439 = getelementptr inbounds [17 x %struct.b3BufferInfoCL], ptr %bInfo1438, i64 0, i64 0
  %648 = load ptr, ptr %triangleConvexPairsOut.addr, align 8
  %call1442 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %648)
          to label %invoke.cont1441 unwind label %lpad1440

invoke.cont1441:                                  ; preds = %invoke.cont1437
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.begin1439, ptr noundef %call1442, i1 noundef zeroext false)
          to label %invoke.cont1443 unwind label %lpad1440

invoke.cont1443:                                  ; preds = %invoke.cont1441
  %arrayinit.element1444 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.begin1439, i64 1
  %649 = load ptr, ptr %bodyBuf.addr, align 8
  %call1446 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %649)
          to label %invoke.cont1445 unwind label %lpad1440

invoke.cont1445:                                  ; preds = %invoke.cont1443
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1444, ptr noundef %call1446, i1 noundef zeroext true)
          to label %invoke.cont1447 unwind label %lpad1440

invoke.cont1447:                                  ; preds = %invoke.cont1445
  %arrayinit.element1448 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1444, i64 1
  %650 = load ptr, ptr %gpuCollidables.addr, align 8
  %call1450 = invoke noundef ptr @_ZNK13b3OpenCLArrayI12b3CollidableE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %650)
          to label %invoke.cont1449 unwind label %lpad1440

invoke.cont1449:                                  ; preds = %invoke.cont1447
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1448, ptr noundef %call1450, i1 noundef zeroext true)
          to label %invoke.cont1451 unwind label %lpad1440

invoke.cont1451:                                  ; preds = %invoke.cont1449
  %arrayinit.element1452 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1448, i64 1
  %651 = load ptr, ptr %convexData.addr, align 8
  %call1454 = invoke noundef ptr @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %651)
          to label %invoke.cont1453 unwind label %lpad1440

invoke.cont1453:                                  ; preds = %invoke.cont1451
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1452, ptr noundef %call1454, i1 noundef zeroext true)
          to label %invoke.cont1455 unwind label %lpad1440

invoke.cont1455:                                  ; preds = %invoke.cont1453
  %arrayinit.element1456 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1452, i64 1
  %652 = load ptr, ptr %gpuVertices.addr, align 8
  %call1458 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %652)
          to label %invoke.cont1457 unwind label %lpad1440

invoke.cont1457:                                  ; preds = %invoke.cont1455
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1456, ptr noundef %call1458, i1 noundef zeroext true)
          to label %invoke.cont1459 unwind label %lpad1440

invoke.cont1459:                                  ; preds = %invoke.cont1457
  %arrayinit.element1460 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1456, i64 1
  %653 = load ptr, ptr %gpuUniqueEdges.addr, align 8
  %call1462 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %653)
          to label %invoke.cont1461 unwind label %lpad1440

invoke.cont1461:                                  ; preds = %invoke.cont1459
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1460, ptr noundef %call1462, i1 noundef zeroext true)
          to label %invoke.cont1463 unwind label %lpad1440

invoke.cont1463:                                  ; preds = %invoke.cont1461
  %arrayinit.element1464 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1460, i64 1
  %654 = load ptr, ptr %gpuFaces.addr, align 8
  %call1466 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3GpuFaceE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %654)
          to label %invoke.cont1465 unwind label %lpad1440

invoke.cont1465:                                  ; preds = %invoke.cont1463
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1464, ptr noundef %call1466, i1 noundef zeroext true)
          to label %invoke.cont1467 unwind label %lpad1440

invoke.cont1467:                                  ; preds = %invoke.cont1465
  %arrayinit.element1468 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1464, i64 1
  %655 = load ptr, ptr %gpuIndices.addr, align 8
  %call1470 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %655)
          to label %invoke.cont1469 unwind label %lpad1440

invoke.cont1469:                                  ; preds = %invoke.cont1467
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1468, ptr noundef %call1470, i1 noundef zeroext true)
          to label %invoke.cont1471 unwind label %lpad1440

invoke.cont1471:                                  ; preds = %invoke.cont1469
  %arrayinit.element1472 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1468, i64 1
  %656 = load ptr, ptr %gpuChildShapes.addr, align 8
  %call1474 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3GpuChildShapeE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %656)
          to label %invoke.cont1473 unwind label %lpad1440

invoke.cont1473:                                  ; preds = %invoke.cont1471
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1472, ptr noundef %call1474, i1 noundef zeroext true)
          to label %invoke.cont1475 unwind label %lpad1440

invoke.cont1475:                                  ; preds = %invoke.cont1473
  %arrayinit.element1476 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1472, i64 1
  %657 = load ptr, ptr %clAabbsWorldSpace.addr, align 8
  %call1478 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3AabbE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %657)
          to label %invoke.cont1477 unwind label %lpad1440

invoke.cont1477:                                  ; preds = %invoke.cont1475
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1476, ptr noundef %call1478, i1 noundef zeroext true)
          to label %invoke.cont1479 unwind label %lpad1440

invoke.cont1479:                                  ; preds = %invoke.cont1477
  %arrayinit.element1480 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1476, i64 1
  %m_concaveSepNormals1481 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 29
  %call1483 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveSepNormals1481)
          to label %invoke.cont1482 unwind label %lpad1440

invoke.cont1482:                                  ; preds = %invoke.cont1479
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1480, ptr noundef %call1483, i1 noundef zeroext false)
          to label %invoke.cont1484 unwind label %lpad1440

invoke.cont1484:                                  ; preds = %invoke.cont1482
  %arrayinit.element1485 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1480, i64 1
  %m_concaveHasSeparatingNormals1486 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 30
  %call1488 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveHasSeparatingNormals1486)
          to label %invoke.cont1487 unwind label %lpad1440

invoke.cont1487:                                  ; preds = %invoke.cont1484
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1485, ptr noundef %call1488, i1 noundef zeroext false)
          to label %invoke.cont1489 unwind label %lpad1440

invoke.cont1489:                                  ; preds = %invoke.cont1487
  %arrayinit.element1490 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1485, i64 1
  %658 = load ptr, ptr %clippingFacesOutGPU.addr, align 8
  %call1492 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %658)
          to label %invoke.cont1491 unwind label %lpad1440

invoke.cont1491:                                  ; preds = %invoke.cont1489
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1490, ptr noundef %call1492, i1 noundef zeroext false)
          to label %invoke.cont1493 unwind label %lpad1440

invoke.cont1493:                                  ; preds = %invoke.cont1491
  %arrayinit.element1494 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1490, i64 1
  %659 = load ptr, ptr %worldVertsA1GPU.addr, align 8
  %call1496 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %659)
          to label %invoke.cont1495 unwind label %lpad1440

invoke.cont1495:                                  ; preds = %invoke.cont1493
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1494, ptr noundef %call1496, i1 noundef zeroext false)
          to label %invoke.cont1497 unwind label %lpad1440

invoke.cont1497:                                  ; preds = %invoke.cont1495
  %arrayinit.element1498 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1494, i64 1
  %660 = load ptr, ptr %worldNormalsAGPU.addr, align 8
  %call1500 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %660)
          to label %invoke.cont1499 unwind label %lpad1440

invoke.cont1499:                                  ; preds = %invoke.cont1497
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1498, ptr noundef %call1500, i1 noundef zeroext false)
          to label %invoke.cont1501 unwind label %lpad1440

invoke.cont1501:                                  ; preds = %invoke.cont1499
  %arrayinit.element1502 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1498, i64 1
  %661 = load ptr, ptr %worldVertsB1GPU.addr, align 8
  %call1504 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %661)
          to label %invoke.cont1503 unwind label %lpad1440

invoke.cont1503:                                  ; preds = %invoke.cont1501
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1502, ptr noundef %call1504, i1 noundef zeroext false)
          to label %invoke.cont1505 unwind label %lpad1440

invoke.cont1505:                                  ; preds = %invoke.cont1503
  %arrayinit.element1506 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1502, i64 1
  %m_dmins1507 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 27
  %call1509 = invoke noundef ptr @_ZNK13b3OpenCLArrayIfE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_dmins1507)
          to label %invoke.cont1508 unwind label %lpad1440

invoke.cont1508:                                  ; preds = %invoke.cont1505
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1506, ptr noundef %call1509, i1 noundef zeroext false)
          to label %invoke.cont1510 unwind label %lpad1440

invoke.cont1510:                                  ; preds = %invoke.cont1508
  %m_queue1512 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %662 = load ptr, ptr %m_queue1512, align 8
  %m_findConcaveSeparatingAxisVertexFaceKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 10
  %663 = load ptr, ptr %m_findConcaveSeparatingAxisVertexFaceKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher1511, ptr noundef %662, ptr noundef %663, ptr noundef @.str.54)
          to label %invoke.cont1513 unwind label %lpad1440

invoke.cont1513:                                  ; preds = %invoke.cont1510
  %arraydecay1514 = getelementptr inbounds [17 x %struct.b3BufferInfoCL], ptr %bInfo1438, i64 0, i64 0
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher1511, ptr noundef %arraydecay1514, i32 noundef 17)
          to label %invoke.cont1516 unwind label %lpad1515

invoke.cont1516:                                  ; preds = %invoke.cont1513
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher1511, ptr noundef nonnull align 4 dereferenceable(4) %vertexFaceCapacity)
          to label %invoke.cont1517 unwind label %lpad1515

invoke.cont1517:                                  ; preds = %invoke.cont1516
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher1511, ptr noundef nonnull align 4 dereferenceable(4) %numConcavePairs)
          to label %invoke.cont1518 unwind label %lpad1515

invoke.cont1518:                                  ; preds = %invoke.cont1517
  %664 = load i32, ptr %numConcavePairs, align 4
  store i32 %664, ptr %num1519, align 4
  %665 = load i32, ptr %num1519, align 4
  invoke void @_ZN12b3LauncherCL8launch1DEii(ptr noundef nonnull align 8 dereferenceable(112) %launcher1511, i32 noundef %665, i32 noundef 64)
          to label %invoke.cont1520 unwind label %lpad1515

invoke.cont1520:                                  ; preds = %invoke.cont1518
  %666 = load ptr, ptr @__clewFinish, align 8
  %m_queue1521 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %667 = load ptr, ptr %m_queue1521, align 8
  %call1523 = invoke i32 %666(ptr noundef %667)
          to label %invoke.cont1522 unwind label %lpad1515

invoke.cont1522:                                  ; preds = %invoke.cont1520
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1511) #13
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile1436) #13
  invoke void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %__profile1526, ptr noundef @.str.14)
          to label %invoke.cont1527 unwind label %lpad58

invoke.cont1527:                                  ; preds = %invoke.cont1522
  %arrayinit.begin1529 = getelementptr inbounds [17 x %struct.b3BufferInfoCL], ptr %bInfo1528, i64 0, i64 0
  %668 = load ptr, ptr %triangleConvexPairsOut.addr, align 8
  %call1532 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %668)
          to label %invoke.cont1531 unwind label %lpad1530

invoke.cont1531:                                  ; preds = %invoke.cont1527
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.begin1529, ptr noundef %call1532, i1 noundef zeroext false)
          to label %invoke.cont1533 unwind label %lpad1530

invoke.cont1533:                                  ; preds = %invoke.cont1531
  %arrayinit.element1534 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.begin1529, i64 1
  %669 = load ptr, ptr %bodyBuf.addr, align 8
  %call1536 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %669)
          to label %invoke.cont1535 unwind label %lpad1530

invoke.cont1535:                                  ; preds = %invoke.cont1533
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1534, ptr noundef %call1536, i1 noundef zeroext true)
          to label %invoke.cont1537 unwind label %lpad1530

invoke.cont1537:                                  ; preds = %invoke.cont1535
  %arrayinit.element1538 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1534, i64 1
  %670 = load ptr, ptr %gpuCollidables.addr, align 8
  %call1540 = invoke noundef ptr @_ZNK13b3OpenCLArrayI12b3CollidableE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %670)
          to label %invoke.cont1539 unwind label %lpad1530

invoke.cont1539:                                  ; preds = %invoke.cont1537
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1538, ptr noundef %call1540, i1 noundef zeroext true)
          to label %invoke.cont1541 unwind label %lpad1530

invoke.cont1541:                                  ; preds = %invoke.cont1539
  %arrayinit.element1542 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1538, i64 1
  %671 = load ptr, ptr %convexData.addr, align 8
  %call1544 = invoke noundef ptr @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %671)
          to label %invoke.cont1543 unwind label %lpad1530

invoke.cont1543:                                  ; preds = %invoke.cont1541
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1542, ptr noundef %call1544, i1 noundef zeroext true)
          to label %invoke.cont1545 unwind label %lpad1530

invoke.cont1545:                                  ; preds = %invoke.cont1543
  %arrayinit.element1546 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1542, i64 1
  %672 = load ptr, ptr %gpuVertices.addr, align 8
  %call1548 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %672)
          to label %invoke.cont1547 unwind label %lpad1530

invoke.cont1547:                                  ; preds = %invoke.cont1545
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1546, ptr noundef %call1548, i1 noundef zeroext true)
          to label %invoke.cont1549 unwind label %lpad1530

invoke.cont1549:                                  ; preds = %invoke.cont1547
  %arrayinit.element1550 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1546, i64 1
  %673 = load ptr, ptr %gpuUniqueEdges.addr, align 8
  %call1552 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %673)
          to label %invoke.cont1551 unwind label %lpad1530

invoke.cont1551:                                  ; preds = %invoke.cont1549
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1550, ptr noundef %call1552, i1 noundef zeroext true)
          to label %invoke.cont1553 unwind label %lpad1530

invoke.cont1553:                                  ; preds = %invoke.cont1551
  %arrayinit.element1554 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1550, i64 1
  %674 = load ptr, ptr %gpuFaces.addr, align 8
  %call1556 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3GpuFaceE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %674)
          to label %invoke.cont1555 unwind label %lpad1530

invoke.cont1555:                                  ; preds = %invoke.cont1553
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1554, ptr noundef %call1556, i1 noundef zeroext true)
          to label %invoke.cont1557 unwind label %lpad1530

invoke.cont1557:                                  ; preds = %invoke.cont1555
  %arrayinit.element1558 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1554, i64 1
  %675 = load ptr, ptr %gpuIndices.addr, align 8
  %call1560 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %675)
          to label %invoke.cont1559 unwind label %lpad1530

invoke.cont1559:                                  ; preds = %invoke.cont1557
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1558, ptr noundef %call1560, i1 noundef zeroext true)
          to label %invoke.cont1561 unwind label %lpad1530

invoke.cont1561:                                  ; preds = %invoke.cont1559
  %arrayinit.element1562 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1558, i64 1
  %676 = load ptr, ptr %gpuChildShapes.addr, align 8
  %call1564 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3GpuChildShapeE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %676)
          to label %invoke.cont1563 unwind label %lpad1530

invoke.cont1563:                                  ; preds = %invoke.cont1561
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1562, ptr noundef %call1564, i1 noundef zeroext true)
          to label %invoke.cont1565 unwind label %lpad1530

invoke.cont1565:                                  ; preds = %invoke.cont1563
  %arrayinit.element1566 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1562, i64 1
  %677 = load ptr, ptr %clAabbsWorldSpace.addr, align 8
  %call1568 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3AabbE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %677)
          to label %invoke.cont1567 unwind label %lpad1530

invoke.cont1567:                                  ; preds = %invoke.cont1565
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1566, ptr noundef %call1568, i1 noundef zeroext true)
          to label %invoke.cont1569 unwind label %lpad1530

invoke.cont1569:                                  ; preds = %invoke.cont1567
  %arrayinit.element1570 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1566, i64 1
  %m_concaveSepNormals1571 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 29
  %call1573 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveSepNormals1571)
          to label %invoke.cont1572 unwind label %lpad1530

invoke.cont1572:                                  ; preds = %invoke.cont1569
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1570, ptr noundef %call1573, i1 noundef zeroext false)
          to label %invoke.cont1574 unwind label %lpad1530

invoke.cont1574:                                  ; preds = %invoke.cont1572
  %arrayinit.element1575 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1570, i64 1
  %m_concaveHasSeparatingNormals1576 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 30
  %call1578 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveHasSeparatingNormals1576)
          to label %invoke.cont1577 unwind label %lpad1530

invoke.cont1577:                                  ; preds = %invoke.cont1574
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1575, ptr noundef %call1578, i1 noundef zeroext false)
          to label %invoke.cont1579 unwind label %lpad1530

invoke.cont1579:                                  ; preds = %invoke.cont1577
  %arrayinit.element1580 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1575, i64 1
  %678 = load ptr, ptr %clippingFacesOutGPU.addr, align 8
  %call1582 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %678)
          to label %invoke.cont1581 unwind label %lpad1530

invoke.cont1581:                                  ; preds = %invoke.cont1579
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1580, ptr noundef %call1582, i1 noundef zeroext false)
          to label %invoke.cont1583 unwind label %lpad1530

invoke.cont1583:                                  ; preds = %invoke.cont1581
  %arrayinit.element1584 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1580, i64 1
  %679 = load ptr, ptr %worldVertsA1GPU.addr, align 8
  %call1586 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %679)
          to label %invoke.cont1585 unwind label %lpad1530

invoke.cont1585:                                  ; preds = %invoke.cont1583
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1584, ptr noundef %call1586, i1 noundef zeroext false)
          to label %invoke.cont1587 unwind label %lpad1530

invoke.cont1587:                                  ; preds = %invoke.cont1585
  %arrayinit.element1588 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1584, i64 1
  %680 = load ptr, ptr %worldNormalsAGPU.addr, align 8
  %call1590 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %680)
          to label %invoke.cont1589 unwind label %lpad1530

invoke.cont1589:                                  ; preds = %invoke.cont1587
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1588, ptr noundef %call1590, i1 noundef zeroext false)
          to label %invoke.cont1591 unwind label %lpad1530

invoke.cont1591:                                  ; preds = %invoke.cont1589
  %arrayinit.element1592 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1588, i64 1
  %681 = load ptr, ptr %worldVertsB1GPU.addr, align 8
  %call1594 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %681)
          to label %invoke.cont1593 unwind label %lpad1530

invoke.cont1593:                                  ; preds = %invoke.cont1591
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1592, ptr noundef %call1594, i1 noundef zeroext false)
          to label %invoke.cont1595 unwind label %lpad1530

invoke.cont1595:                                  ; preds = %invoke.cont1593
  %arrayinit.element1596 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1592, i64 1
  %m_dmins1597 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 27
  %call1599 = invoke noundef ptr @_ZNK13b3OpenCLArrayIfE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_dmins1597)
          to label %invoke.cont1598 unwind label %lpad1530

invoke.cont1598:                                  ; preds = %invoke.cont1595
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1596, ptr noundef %call1599, i1 noundef zeroext false)
          to label %invoke.cont1600 unwind label %lpad1530

invoke.cont1600:                                  ; preds = %invoke.cont1598
  %m_queue1602 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %682 = load ptr, ptr %m_queue1602, align 8
  %m_findConcaveSeparatingAxisEdgeEdgeKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 11
  %683 = load ptr, ptr %m_findConcaveSeparatingAxisEdgeEdgeKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher1601, ptr noundef %682, ptr noundef %683, ptr noundef @.str.55)
          to label %invoke.cont1603 unwind label %lpad1530

invoke.cont1603:                                  ; preds = %invoke.cont1600
  %arraydecay1604 = getelementptr inbounds [17 x %struct.b3BufferInfoCL], ptr %bInfo1528, i64 0, i64 0
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher1601, ptr noundef %arraydecay1604, i32 noundef 17)
          to label %invoke.cont1606 unwind label %lpad1605

invoke.cont1606:                                  ; preds = %invoke.cont1603
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher1601, ptr noundef nonnull align 4 dereferenceable(4) %vertexFaceCapacity)
          to label %invoke.cont1607 unwind label %lpad1605

invoke.cont1607:                                  ; preds = %invoke.cont1606
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher1601, ptr noundef nonnull align 4 dereferenceable(4) %numConcavePairs)
          to label %invoke.cont1608 unwind label %lpad1605

invoke.cont1608:                                  ; preds = %invoke.cont1607
  %684 = load i32, ptr %numConcavePairs, align 4
  store i32 %684, ptr %num1609, align 4
  %685 = load i32, ptr %num1609, align 4
  invoke void @_ZN12b3LauncherCL8launch1DEii(ptr noundef nonnull align 8 dereferenceable(112) %launcher1601, i32 noundef %685, i32 noundef 64)
          to label %invoke.cont1610 unwind label %lpad1605

invoke.cont1610:                                  ; preds = %invoke.cont1608
  %686 = load ptr, ptr @__clewFinish, align 8
  %m_queue1611 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %687 = load ptr, ptr %m_queue1611, align 8
  %call1613 = invoke i32 %686(ptr noundef %687)
          to label %invoke.cont1612 unwind label %lpad1605

invoke.cont1612:                                  ; preds = %invoke.cont1610
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1601) #13
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile1526) #13
  br label %if.end1702

lpad1440:                                         ; preds = %invoke.cont1510, %invoke.cont1508, %invoke.cont1505, %invoke.cont1503, %invoke.cont1501, %invoke.cont1499, %invoke.cont1497, %invoke.cont1495, %invoke.cont1493, %invoke.cont1491, %invoke.cont1489, %invoke.cont1487, %invoke.cont1484, %invoke.cont1482, %invoke.cont1479, %invoke.cont1477, %invoke.cont1475, %invoke.cont1473, %invoke.cont1471, %invoke.cont1469, %invoke.cont1467, %invoke.cont1465, %invoke.cont1463, %invoke.cont1461, %invoke.cont1459, %invoke.cont1457, %invoke.cont1455, %invoke.cont1453, %invoke.cont1451, %invoke.cont1449, %invoke.cont1447, %invoke.cont1445, %invoke.cont1443, %invoke.cont1441, %invoke.cont1437
  %688 = landingpad { ptr, i32 }
          cleanup
  %689 = extractvalue { ptr, i32 } %688, 0
  store ptr %689, ptr %exn.slot, align 8
  %690 = extractvalue { ptr, i32 } %688, 1
  store i32 %690, ptr %ehselector.slot, align 4
  br label %ehcleanup1525

lpad1515:                                         ; preds = %invoke.cont1520, %invoke.cont1518, %invoke.cont1517, %invoke.cont1516, %invoke.cont1513
  %691 = landingpad { ptr, i32 }
          cleanup
  %692 = extractvalue { ptr, i32 } %691, 0
  store ptr %692, ptr %exn.slot, align 8
  %693 = extractvalue { ptr, i32 } %691, 1
  store i32 %693, ptr %ehselector.slot, align 4
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1511) #13
  br label %ehcleanup1525

ehcleanup1525:                                    ; preds = %lpad1515, %lpad1440
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile1436) #13
  br label %ehcleanup2980

lpad1530:                                         ; preds = %invoke.cont1600, %invoke.cont1598, %invoke.cont1595, %invoke.cont1593, %invoke.cont1591, %invoke.cont1589, %invoke.cont1587, %invoke.cont1585, %invoke.cont1583, %invoke.cont1581, %invoke.cont1579, %invoke.cont1577, %invoke.cont1574, %invoke.cont1572, %invoke.cont1569, %invoke.cont1567, %invoke.cont1565, %invoke.cont1563, %invoke.cont1561, %invoke.cont1559, %invoke.cont1557, %invoke.cont1555, %invoke.cont1553, %invoke.cont1551, %invoke.cont1549, %invoke.cont1547, %invoke.cont1545, %invoke.cont1543, %invoke.cont1541, %invoke.cont1539, %invoke.cont1537, %invoke.cont1535, %invoke.cont1533, %invoke.cont1531, %invoke.cont1527
  %694 = landingpad { ptr, i32 }
          cleanup
  %695 = extractvalue { ptr, i32 } %694, 0
  store ptr %695, ptr %exn.slot, align 8
  %696 = extractvalue { ptr, i32 } %694, 1
  store i32 %696, ptr %ehselector.slot, align 4
  br label %ehcleanup1615

lpad1605:                                         ; preds = %invoke.cont1610, %invoke.cont1608, %invoke.cont1607, %invoke.cont1606, %invoke.cont1603
  %697 = landingpad { ptr, i32 }
          cleanup
  %698 = extractvalue { ptr, i32 } %697, 0
  store ptr %698, ptr %exn.slot, align 8
  %699 = extractvalue { ptr, i32 } %697, 1
  store i32 %699, ptr %ehselector.slot, align 4
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1601) #13
  br label %ehcleanup1615

ehcleanup1615:                                    ; preds = %lpad1605, %lpad1530
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile1526) #13
  br label %ehcleanup2980

if.else1616:                                      ; preds = %if.then1429
  invoke void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %__profile1617, ptr noundef @.str.12)
          to label %invoke.cont1618 unwind label %lpad58

invoke.cont1618:                                  ; preds = %if.else1616
  %arrayinit.begin1620 = getelementptr inbounds [16 x %struct.b3BufferInfoCL], ptr %bInfo1619, i64 0, i64 0
  %700 = load ptr, ptr %triangleConvexPairsOut.addr, align 8
  %call1623 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %700)
          to label %invoke.cont1622 unwind label %lpad1621

invoke.cont1622:                                  ; preds = %invoke.cont1618
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.begin1620, ptr noundef %call1623, i1 noundef zeroext false)
          to label %invoke.cont1624 unwind label %lpad1621

invoke.cont1624:                                  ; preds = %invoke.cont1622
  %arrayinit.element1625 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.begin1620, i64 1
  %701 = load ptr, ptr %bodyBuf.addr, align 8
  %call1627 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %701)
          to label %invoke.cont1626 unwind label %lpad1621

invoke.cont1626:                                  ; preds = %invoke.cont1624
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1625, ptr noundef %call1627, i1 noundef zeroext true)
          to label %invoke.cont1628 unwind label %lpad1621

invoke.cont1628:                                  ; preds = %invoke.cont1626
  %arrayinit.element1629 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1625, i64 1
  %702 = load ptr, ptr %gpuCollidables.addr, align 8
  %call1631 = invoke noundef ptr @_ZNK13b3OpenCLArrayI12b3CollidableE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %702)
          to label %invoke.cont1630 unwind label %lpad1621

invoke.cont1630:                                  ; preds = %invoke.cont1628
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1629, ptr noundef %call1631, i1 noundef zeroext true)
          to label %invoke.cont1632 unwind label %lpad1621

invoke.cont1632:                                  ; preds = %invoke.cont1630
  %arrayinit.element1633 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1629, i64 1
  %703 = load ptr, ptr %convexData.addr, align 8
  %call1635 = invoke noundef ptr @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %703)
          to label %invoke.cont1634 unwind label %lpad1621

invoke.cont1634:                                  ; preds = %invoke.cont1632
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1633, ptr noundef %call1635, i1 noundef zeroext true)
          to label %invoke.cont1636 unwind label %lpad1621

invoke.cont1636:                                  ; preds = %invoke.cont1634
  %arrayinit.element1637 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1633, i64 1
  %704 = load ptr, ptr %gpuVertices.addr, align 8
  %call1639 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %704)
          to label %invoke.cont1638 unwind label %lpad1621

invoke.cont1638:                                  ; preds = %invoke.cont1636
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1637, ptr noundef %call1639, i1 noundef zeroext true)
          to label %invoke.cont1640 unwind label %lpad1621

invoke.cont1640:                                  ; preds = %invoke.cont1638
  %arrayinit.element1641 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1637, i64 1
  %705 = load ptr, ptr %gpuUniqueEdges.addr, align 8
  %call1643 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %705)
          to label %invoke.cont1642 unwind label %lpad1621

invoke.cont1642:                                  ; preds = %invoke.cont1640
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1641, ptr noundef %call1643, i1 noundef zeroext true)
          to label %invoke.cont1644 unwind label %lpad1621

invoke.cont1644:                                  ; preds = %invoke.cont1642
  %arrayinit.element1645 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1641, i64 1
  %706 = load ptr, ptr %gpuFaces.addr, align 8
  %call1647 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3GpuFaceE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %706)
          to label %invoke.cont1646 unwind label %lpad1621

invoke.cont1646:                                  ; preds = %invoke.cont1644
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1645, ptr noundef %call1647, i1 noundef zeroext true)
          to label %invoke.cont1648 unwind label %lpad1621

invoke.cont1648:                                  ; preds = %invoke.cont1646
  %arrayinit.element1649 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1645, i64 1
  %707 = load ptr, ptr %gpuIndices.addr, align 8
  %call1651 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %707)
          to label %invoke.cont1650 unwind label %lpad1621

invoke.cont1650:                                  ; preds = %invoke.cont1648
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1649, ptr noundef %call1651, i1 noundef zeroext true)
          to label %invoke.cont1652 unwind label %lpad1621

invoke.cont1652:                                  ; preds = %invoke.cont1650
  %arrayinit.element1653 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1649, i64 1
  %708 = load ptr, ptr %gpuChildShapes.addr, align 8
  %call1655 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3GpuChildShapeE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %708)
          to label %invoke.cont1654 unwind label %lpad1621

invoke.cont1654:                                  ; preds = %invoke.cont1652
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1653, ptr noundef %call1655, i1 noundef zeroext true)
          to label %invoke.cont1656 unwind label %lpad1621

invoke.cont1656:                                  ; preds = %invoke.cont1654
  %arrayinit.element1657 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1653, i64 1
  %709 = load ptr, ptr %clAabbsWorldSpace.addr, align 8
  %call1659 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3AabbE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %709)
          to label %invoke.cont1658 unwind label %lpad1621

invoke.cont1658:                                  ; preds = %invoke.cont1656
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1657, ptr noundef %call1659, i1 noundef zeroext true)
          to label %invoke.cont1660 unwind label %lpad1621

invoke.cont1660:                                  ; preds = %invoke.cont1658
  %arrayinit.element1661 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1657, i64 1
  %m_concaveSepNormals1662 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 29
  %call1664 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveSepNormals1662)
          to label %invoke.cont1663 unwind label %lpad1621

invoke.cont1663:                                  ; preds = %invoke.cont1660
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1661, ptr noundef %call1664, i1 noundef zeroext false)
          to label %invoke.cont1665 unwind label %lpad1621

invoke.cont1665:                                  ; preds = %invoke.cont1663
  %arrayinit.element1666 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1661, i64 1
  %m_concaveHasSeparatingNormals1667 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 30
  %call1669 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveHasSeparatingNormals1667)
          to label %invoke.cont1668 unwind label %lpad1621

invoke.cont1668:                                  ; preds = %invoke.cont1665
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1666, ptr noundef %call1669, i1 noundef zeroext false)
          to label %invoke.cont1670 unwind label %lpad1621

invoke.cont1670:                                  ; preds = %invoke.cont1668
  %arrayinit.element1671 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1666, i64 1
  %710 = load ptr, ptr %clippingFacesOutGPU.addr, align 8
  %call1673 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %710)
          to label %invoke.cont1672 unwind label %lpad1621

invoke.cont1672:                                  ; preds = %invoke.cont1670
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1671, ptr noundef %call1673, i1 noundef zeroext false)
          to label %invoke.cont1674 unwind label %lpad1621

invoke.cont1674:                                  ; preds = %invoke.cont1672
  %arrayinit.element1675 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1671, i64 1
  %711 = load ptr, ptr %worldVertsA1GPU.addr, align 8
  %call1677 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %711)
          to label %invoke.cont1676 unwind label %lpad1621

invoke.cont1676:                                  ; preds = %invoke.cont1674
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1675, ptr noundef %call1677, i1 noundef zeroext false)
          to label %invoke.cont1678 unwind label %lpad1621

invoke.cont1678:                                  ; preds = %invoke.cont1676
  %arrayinit.element1679 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1675, i64 1
  %712 = load ptr, ptr %worldNormalsAGPU.addr, align 8
  %call1681 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %712)
          to label %invoke.cont1680 unwind label %lpad1621

invoke.cont1680:                                  ; preds = %invoke.cont1678
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1679, ptr noundef %call1681, i1 noundef zeroext false)
          to label %invoke.cont1682 unwind label %lpad1621

invoke.cont1682:                                  ; preds = %invoke.cont1680
  %arrayinit.element1683 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1679, i64 1
  %713 = load ptr, ptr %worldVertsB1GPU.addr, align 8
  %call1685 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %713)
          to label %invoke.cont1684 unwind label %lpad1621

invoke.cont1684:                                  ; preds = %invoke.cont1682
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1683, ptr noundef %call1685, i1 noundef zeroext false)
          to label %invoke.cont1686 unwind label %lpad1621

invoke.cont1686:                                  ; preds = %invoke.cont1684
  %m_queue1688 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %714 = load ptr, ptr %m_queue1688, align 8
  %m_findConcaveSeparatingAxisKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 9
  %715 = load ptr, ptr %m_findConcaveSeparatingAxisKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher1687, ptr noundef %714, ptr noundef %715, ptr noundef @.str.56)
          to label %invoke.cont1689 unwind label %lpad1621

invoke.cont1689:                                  ; preds = %invoke.cont1686
  %arraydecay1690 = getelementptr inbounds [16 x %struct.b3BufferInfoCL], ptr %bInfo1619, i64 0, i64 0
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher1687, ptr noundef %arraydecay1690, i32 noundef 16)
          to label %invoke.cont1692 unwind label %lpad1691

invoke.cont1692:                                  ; preds = %invoke.cont1689
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher1687, ptr noundef nonnull align 4 dereferenceable(4) %vertexFaceCapacity)
          to label %invoke.cont1693 unwind label %lpad1691

invoke.cont1693:                                  ; preds = %invoke.cont1692
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher1687, ptr noundef nonnull align 4 dereferenceable(4) %numConcavePairs)
          to label %invoke.cont1694 unwind label %lpad1691

invoke.cont1694:                                  ; preds = %invoke.cont1693
  %716 = load i32, ptr %numConcavePairs, align 4
  store i32 %716, ptr %num1695, align 4
  %717 = load i32, ptr %num1695, align 4
  invoke void @_ZN12b3LauncherCL8launch1DEii(ptr noundef nonnull align 8 dereferenceable(112) %launcher1687, i32 noundef %717, i32 noundef 64)
          to label %invoke.cont1696 unwind label %lpad1691

invoke.cont1696:                                  ; preds = %invoke.cont1694
  %718 = load ptr, ptr @__clewFinish, align 8
  %m_queue1697 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %719 = load ptr, ptr %m_queue1697, align 8
  %call1699 = invoke i32 %718(ptr noundef %719)
          to label %invoke.cont1698 unwind label %lpad1691

invoke.cont1698:                                  ; preds = %invoke.cont1696
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1687) #13
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile1617) #13
  br label %if.end1702

lpad1621:                                         ; preds = %invoke.cont1686, %invoke.cont1684, %invoke.cont1682, %invoke.cont1680, %invoke.cont1678, %invoke.cont1676, %invoke.cont1674, %invoke.cont1672, %invoke.cont1670, %invoke.cont1668, %invoke.cont1665, %invoke.cont1663, %invoke.cont1660, %invoke.cont1658, %invoke.cont1656, %invoke.cont1654, %invoke.cont1652, %invoke.cont1650, %invoke.cont1648, %invoke.cont1646, %invoke.cont1644, %invoke.cont1642, %invoke.cont1640, %invoke.cont1638, %invoke.cont1636, %invoke.cont1634, %invoke.cont1632, %invoke.cont1630, %invoke.cont1628, %invoke.cont1626, %invoke.cont1624, %invoke.cont1622, %invoke.cont1618
  %720 = landingpad { ptr, i32 }
          cleanup
  %721 = extractvalue { ptr, i32 } %720, 0
  store ptr %721, ptr %exn.slot, align 8
  %722 = extractvalue { ptr, i32 } %720, 1
  store i32 %722, ptr %ehselector.slot, align 4
  br label %ehcleanup1701

lpad1691:                                         ; preds = %invoke.cont1696, %invoke.cont1694, %invoke.cont1693, %invoke.cont1692, %invoke.cont1689
  %723 = landingpad { ptr, i32 }
          cleanup
  %724 = extractvalue { ptr, i32 } %723, 0
  store ptr %724, ptr %exn.slot, align 8
  %725 = extractvalue { ptr, i32 } %723, 1
  store i32 %725, ptr %ehselector.slot, align 4
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1687) #13
  br label %ehcleanup1701

ehcleanup1701:                                    ; preds = %lpad1691, %lpad1621
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile1617) #13
  br label %ehcleanup2980

if.end1702:                                       ; preds = %invoke.cont1698, %invoke.cont1612
  br label %if.end1851

if.else1703:                                      ; preds = %invoke.cont1426
  invoke void @_ZN20b3AlignedObjectArrayI6b3Int4EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU)
          to label %invoke.cont1704 unwind label %lpad58

invoke.cont1704:                                  ; preds = %if.else1703
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsA1CPU)
          to label %invoke.cont1706 unwind label %lpad1705

invoke.cont1706:                                  ; preds = %invoke.cont1704
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldNormalsACPU)
          to label %invoke.cont1708 unwind label %lpad1707

invoke.cont1708:                                  ; preds = %invoke.cont1706
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB1CPU)
          to label %invoke.cont1710 unwind label %lpad1709

invoke.cont1710:                                  ; preds = %invoke.cont1708
  invoke void @_ZN20b3AlignedObjectArrayIiEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %concaveHasSeparatingNormalsCPU)
          to label %invoke.cont1712 unwind label %lpad1711

invoke.cont1712:                                  ; preds = %invoke.cont1710
  invoke void @_ZN20b3AlignedObjectArrayI6b3Int4EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %triangleConvexPairsOutHost1713)
          to label %invoke.cont1715 unwind label %lpad1714

invoke.cont1715:                                  ; preds = %invoke.cont1712
  %726 = load ptr, ptr %triangleConvexPairsOut.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI6b3Int4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %726, ptr noundef nonnull align 8 dereferenceable(25) %triangleConvexPairsOutHost1713, i1 noundef zeroext true)
          to label %invoke.cont1717 unwind label %lpad1716

invoke.cont1717:                                  ; preds = %invoke.cont1715
  invoke void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf1718)
          to label %invoke.cont1719 unwind label %lpad1716

invoke.cont1719:                                  ; preds = %invoke.cont1717
  %727 = load ptr, ptr %bodyBuf.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %727, ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf1718, i1 noundef zeroext true)
          to label %invoke.cont1721 unwind label %lpad1720

invoke.cont1721:                                  ; preds = %invoke.cont1719
  invoke void @_ZN20b3AlignedObjectArrayI12b3CollidableEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables1722)
          to label %invoke.cont1723 unwind label %lpad1720

invoke.cont1723:                                  ; preds = %invoke.cont1721
  %728 = load ptr, ptr %gpuCollidables.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI12b3CollidableE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %728, ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables1722, i1 noundef zeroext true)
          to label %invoke.cont1725 unwind label %lpad1724

invoke.cont1725:                                  ; preds = %invoke.cont1723
  invoke void @_ZN20b3AlignedObjectArrayI6b3AabbEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsWorldSpace1726)
          to label %invoke.cont1727 unwind label %lpad1724

invoke.cont1727:                                  ; preds = %invoke.cont1725
  %729 = load ptr, ptr %clAabbsWorldSpace.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI6b3AabbE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %729, ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsWorldSpace1726, i1 noundef zeroext true)
          to label %invoke.cont1729 unwind label %lpad1728

invoke.cont1729:                                  ; preds = %invoke.cont1727
  invoke void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexData1730)
          to label %invoke.cont1731 unwind label %lpad1728

invoke.cont1731:                                  ; preds = %invoke.cont1729
  %730 = load ptr, ptr %convexData.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %730, ptr noundef nonnull align 8 dereferenceable(25) %hostConvexData1730, i1 noundef zeroext true)
          to label %invoke.cont1733 unwind label %lpad1732

invoke.cont1733:                                  ; preds = %invoke.cont1731
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices1734)
          to label %invoke.cont1735 unwind label %lpad1732

invoke.cont1735:                                  ; preds = %invoke.cont1733
  %731 = load ptr, ptr %gpuVertices.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %731, ptr noundef nonnull align 8 dereferenceable(25) %hostVertices1734, i1 noundef zeroext true)
          to label %invoke.cont1737 unwind label %lpad1736

invoke.cont1737:                                  ; preds = %invoke.cont1735
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges1738)
          to label %invoke.cont1739 unwind label %lpad1736

invoke.cont1739:                                  ; preds = %invoke.cont1737
  %732 = load ptr, ptr %gpuUniqueEdges.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %732, ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges1738, i1 noundef zeroext true)
          to label %invoke.cont1741 unwind label %lpad1740

invoke.cont1741:                                  ; preds = %invoke.cont1739
  invoke void @_ZN20b3AlignedObjectArrayI9b3GpuFaceEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostFaces1742)
          to label %invoke.cont1743 unwind label %lpad1740

invoke.cont1743:                                  ; preds = %invoke.cont1741
  %733 = load ptr, ptr %gpuFaces.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3GpuFaceE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %733, ptr noundef nonnull align 8 dereferenceable(25) %hostFaces1742, i1 noundef zeroext true)
          to label %invoke.cont1745 unwind label %lpad1744

invoke.cont1745:                                  ; preds = %invoke.cont1743
  invoke void @_ZN20b3AlignedObjectArrayIiEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostIndices1746)
          to label %invoke.cont1747 unwind label %lpad1744

invoke.cont1747:                                  ; preds = %invoke.cont1745
  %734 = load ptr, ptr %gpuIndices.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayIiE10copyToHostER20b3AlignedObjectArrayIiEb(ptr noundef nonnull align 8 dereferenceable(50) %734, ptr noundef nonnull align 8 dereferenceable(25) %hostIndices1746, i1 noundef zeroext true)
          to label %invoke.cont1749 unwind label %lpad1748

invoke.cont1749:                                  ; preds = %invoke.cont1747
  invoke void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuChildShapes1750)
          to label %invoke.cont1751 unwind label %lpad1748

invoke.cont1751:                                  ; preds = %invoke.cont1749
  %735 = load ptr, ptr %gpuChildShapes.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI15b3GpuChildShapeE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %735, ptr noundef nonnull align 8 dereferenceable(25) %cpuChildShapes1750, i1 noundef zeroext true)
          to label %invoke.cont1753 unwind label %lpad1752

invoke.cont1753:                                  ; preds = %invoke.cont1751
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %concaveSepNormalsHost)
          to label %invoke.cont1754 unwind label %lpad1752

invoke.cont1754:                                  ; preds = %invoke.cont1753
  %m_concaveSepNormals1755 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 29
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveSepNormals1755, ptr noundef nonnull align 8 dereferenceable(25) %concaveSepNormalsHost, i1 noundef zeroext true)
          to label %invoke.cont1757 unwind label %lpad1756

invoke.cont1757:                                  ; preds = %invoke.cont1754
  %call1759 = invoke noundef i32 @_ZNK20b3AlignedObjectArrayI9b3Vector3E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %concaveSepNormalsHost)
          to label %invoke.cont1758 unwind label %lpad1756

invoke.cont1758:                                  ; preds = %invoke.cont1757
  store i32 0, ptr %ref.tmp1760, align 4
  invoke void @_ZN20b3AlignedObjectArrayIiE6resizeEiRKi(ptr noundef nonnull align 8 dereferenceable(25) %concaveHasSeparatingNormalsCPU, i32 noundef %call1759, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp1760)
          to label %invoke.cont1761 unwind label %lpad1756

invoke.cont1761:                                  ; preds = %invoke.cont1758
  store ptr null, ptr %childShapePointerCPU, align 8
  %call1763 = invoke noundef i32 @_ZNK20b3AlignedObjectArrayI15b3GpuChildShapeE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %cpuChildShapes1750)
          to label %invoke.cont1762 unwind label %lpad1756

invoke.cont1762:                                  ; preds = %invoke.cont1761
  %tobool1764 = icmp ne i32 %call1763, 0
  br i1 %tobool1764, label %if.then1765, label %if.end1768

if.then1765:                                      ; preds = %invoke.cont1762
  %call1767 = invoke noundef nonnull align 16 dereferenceable(48) ptr @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %cpuChildShapes1750, i32 noundef 0)
          to label %invoke.cont1766 unwind label %lpad1756

invoke.cont1766:                                  ; preds = %if.then1765
  store ptr %call1767, ptr %childShapePointerCPU, align 8
  br label %if.end1768

lpad1705:                                         ; preds = %invoke.cont1704
  %736 = landingpad { ptr, i32 }
          cleanup
  %737 = extractvalue { ptr, i32 } %736, 0
  store ptr %737, ptr %exn.slot, align 8
  %738 = extractvalue { ptr, i32 } %736, 1
  store i32 %738, ptr %ehselector.slot, align 4
  br label %ehcleanup1850

lpad1707:                                         ; preds = %invoke.cont1706
  %739 = landingpad { ptr, i32 }
          cleanup
  %740 = extractvalue { ptr, i32 } %739, 0
  store ptr %740, ptr %exn.slot, align 8
  %741 = extractvalue { ptr, i32 } %739, 1
  store i32 %741, ptr %ehselector.slot, align 4
  br label %ehcleanup1849

lpad1709:                                         ; preds = %invoke.cont1708
  %742 = landingpad { ptr, i32 }
          cleanup
  %743 = extractvalue { ptr, i32 } %742, 0
  store ptr %743, ptr %exn.slot, align 8
  %744 = extractvalue { ptr, i32 } %742, 1
  store i32 %744, ptr %ehselector.slot, align 4
  br label %ehcleanup1848

lpad1711:                                         ; preds = %invoke.cont1710
  %745 = landingpad { ptr, i32 }
          cleanup
  %746 = extractvalue { ptr, i32 } %745, 0
  store ptr %746, ptr %exn.slot, align 8
  %747 = extractvalue { ptr, i32 } %745, 1
  store i32 %747, ptr %ehselector.slot, align 4
  br label %ehcleanup1847

lpad1714:                                         ; preds = %invoke.cont1712
  %748 = landingpad { ptr, i32 }
          cleanup
  %749 = extractvalue { ptr, i32 } %748, 0
  store ptr %749, ptr %exn.slot, align 8
  %750 = extractvalue { ptr, i32 } %748, 1
  store i32 %750, ptr %ehselector.slot, align 4
  br label %ehcleanup1846

lpad1716:                                         ; preds = %invoke.cont1717, %invoke.cont1715
  %751 = landingpad { ptr, i32 }
          cleanup
  %752 = extractvalue { ptr, i32 } %751, 0
  store ptr %752, ptr %exn.slot, align 8
  %753 = extractvalue { ptr, i32 } %751, 1
  store i32 %753, ptr %ehselector.slot, align 4
  br label %ehcleanup1845

lpad1720:                                         ; preds = %invoke.cont1721, %invoke.cont1719
  %754 = landingpad { ptr, i32 }
          cleanup
  %755 = extractvalue { ptr, i32 } %754, 0
  store ptr %755, ptr %exn.slot, align 8
  %756 = extractvalue { ptr, i32 } %754, 1
  store i32 %756, ptr %ehselector.slot, align 4
  br label %ehcleanup1844

lpad1724:                                         ; preds = %invoke.cont1725, %invoke.cont1723
  %757 = landingpad { ptr, i32 }
          cleanup
  %758 = extractvalue { ptr, i32 } %757, 0
  store ptr %758, ptr %exn.slot, align 8
  %759 = extractvalue { ptr, i32 } %757, 1
  store i32 %759, ptr %ehselector.slot, align 4
  br label %ehcleanup1843

lpad1728:                                         ; preds = %invoke.cont1729, %invoke.cont1727
  %760 = landingpad { ptr, i32 }
          cleanup
  %761 = extractvalue { ptr, i32 } %760, 0
  store ptr %761, ptr %exn.slot, align 8
  %762 = extractvalue { ptr, i32 } %760, 1
  store i32 %762, ptr %ehselector.slot, align 4
  br label %ehcleanup1842

lpad1732:                                         ; preds = %invoke.cont1733, %invoke.cont1731
  %763 = landingpad { ptr, i32 }
          cleanup
  %764 = extractvalue { ptr, i32 } %763, 0
  store ptr %764, ptr %exn.slot, align 8
  %765 = extractvalue { ptr, i32 } %763, 1
  store i32 %765, ptr %ehselector.slot, align 4
  br label %ehcleanup1841

lpad1736:                                         ; preds = %invoke.cont1737, %invoke.cont1735
  %766 = landingpad { ptr, i32 }
          cleanup
  %767 = extractvalue { ptr, i32 } %766, 0
  store ptr %767, ptr %exn.slot, align 8
  %768 = extractvalue { ptr, i32 } %766, 1
  store i32 %768, ptr %ehselector.slot, align 4
  br label %ehcleanup1840

lpad1740:                                         ; preds = %invoke.cont1741, %invoke.cont1739
  %769 = landingpad { ptr, i32 }
          cleanup
  %770 = extractvalue { ptr, i32 } %769, 0
  store ptr %770, ptr %exn.slot, align 8
  %771 = extractvalue { ptr, i32 } %769, 1
  store i32 %771, ptr %ehselector.slot, align 4
  br label %ehcleanup1839

lpad1744:                                         ; preds = %invoke.cont1745, %invoke.cont1743
  %772 = landingpad { ptr, i32 }
          cleanup
  %773 = extractvalue { ptr, i32 } %772, 0
  store ptr %773, ptr %exn.slot, align 8
  %774 = extractvalue { ptr, i32 } %772, 1
  store i32 %774, ptr %ehselector.slot, align 4
  br label %ehcleanup1838

lpad1748:                                         ; preds = %invoke.cont1749, %invoke.cont1747
  %775 = landingpad { ptr, i32 }
          cleanup
  %776 = extractvalue { ptr, i32 } %775, 0
  store ptr %776, ptr %exn.slot, align 8
  %777 = extractvalue { ptr, i32 } %775, 1
  store i32 %777, ptr %ehselector.slot, align 4
  br label %ehcleanup1837

lpad1752:                                         ; preds = %invoke.cont1753, %invoke.cont1751
  %778 = landingpad { ptr, i32 }
          cleanup
  %779 = extractvalue { ptr, i32 } %778, 0
  store ptr %779, ptr %exn.slot, align 8
  %780 = extractvalue { ptr, i32 } %778, 1
  store i32 %780, ptr %ehselector.slot, align 4
  br label %ehcleanup1836

lpad1756:                                         ; preds = %invoke.cont1833, %invoke.cont1832, %invoke.cont1831, %invoke.cont1830, %invoke.cont1828, %for.end1826, %invoke.cont1821, %invoke.cont1819, %invoke.cont1817, %invoke.cont1815, %invoke.cont1813, %invoke.cont1811, %invoke.cont1809, %invoke.cont1807, %invoke.cont1805, %invoke.cont1803, %invoke.cont1801, %invoke.cont1799, %invoke.cont1797, %invoke.cont1795, %invoke.cont1793, %for.body1792, %invoke.cont1784, %invoke.cont1783, %invoke.cont1779, %invoke.cont1778, %invoke.cont1774, %invoke.cont1773, %invoke.cont1769, %if.end1768, %if.then1765, %invoke.cont1761, %invoke.cont1758, %invoke.cont1757, %invoke.cont1754
  %781 = landingpad { ptr, i32 }
          cleanup
  %782 = extractvalue { ptr, i32 } %781, 0
  store ptr %782, ptr %exn.slot, align 8
  %783 = extractvalue { ptr, i32 } %781, 1
  store i32 %783, ptr %ehselector.slot, align 4
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %concaveSepNormalsHost) #13
  br label %ehcleanup1836

if.end1768:                                       ; preds = %invoke.cont1766, %invoke.cont1762
  %784 = load ptr, ptr %clippingFacesOutGPU.addr, align 8
  %call1770 = invoke noundef i64 @_ZNK13b3OpenCLArrayI6b3Int4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %784)
          to label %invoke.cont1769 unwind label %lpad1756

invoke.cont1769:                                  ; preds = %if.end1768
  %conv1771 = trunc i64 %call1770 to i32
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp1772, i8 0, i64 16, i1 false)
  invoke void @_ZN20b3AlignedObjectArrayI6b3Int4E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU, i32 noundef %conv1771, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp1772)
          to label %invoke.cont1773 unwind label %lpad1756

invoke.cont1773:                                  ; preds = %invoke.cont1769
  %785 = load ptr, ptr %worldVertsA1GPU.addr, align 8
  %call1775 = invoke noundef i64 @_ZNK13b3OpenCLArrayI9b3Vector3E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %785)
          to label %invoke.cont1774 unwind label %lpad1756

invoke.cont1774:                                  ; preds = %invoke.cont1773
  %conv1776 = trunc i64 %call1775 to i32
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp1777, i8 0, i64 16, i1 false)
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsA1CPU, i32 noundef %conv1776, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp1777)
          to label %invoke.cont1778 unwind label %lpad1756

invoke.cont1778:                                  ; preds = %invoke.cont1774
  %786 = load ptr, ptr %worldNormalsAGPU.addr, align 8
  %call1780 = invoke noundef i64 @_ZNK13b3OpenCLArrayI9b3Vector3E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %786)
          to label %invoke.cont1779 unwind label %lpad1756

invoke.cont1779:                                  ; preds = %invoke.cont1778
  %conv1781 = trunc i64 %call1780 to i32
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp1782, i8 0, i64 16, i1 false)
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %worldNormalsACPU, i32 noundef %conv1781, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp1782)
          to label %invoke.cont1783 unwind label %lpad1756

invoke.cont1783:                                  ; preds = %invoke.cont1779
  %787 = load ptr, ptr %worldVertsB1GPU.addr, align 8
  %call1785 = invoke noundef i64 @_ZNK13b3OpenCLArrayI9b3Vector3E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %787)
          to label %invoke.cont1784 unwind label %lpad1756

invoke.cont1784:                                  ; preds = %invoke.cont1783
  %conv1786 = trunc i64 %call1785 to i32
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp1787, i8 0, i64 16, i1 false)
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB1CPU, i32 noundef %conv1786, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp1787)
          to label %invoke.cont1788 unwind label %lpad1756

invoke.cont1788:                                  ; preds = %invoke.cont1784
  store i32 0, ptr %i1789, align 4
  br label %for.cond1790

for.cond1790:                                     ; preds = %for.inc1824, %invoke.cont1788
  %788 = load i32, ptr %i1789, align 4
  %789 = load i32, ptr %numConcavePairs, align 4
  %cmp1791 = icmp slt i32 %788, %789
  br i1 %cmp1791, label %for.body1792, label %for.end1826

for.body1792:                                     ; preds = %for.cond1790
  %call1794 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI6b3Int4E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %triangleConvexPairsOutHost1713, i32 noundef 0)
          to label %invoke.cont1793 unwind label %lpad1756

invoke.cont1793:                                  ; preds = %for.body1792
  %call1796 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf1718, i32 noundef 0)
          to label %invoke.cont1795 unwind label %lpad1756

invoke.cont1795:                                  ; preds = %invoke.cont1793
  %call1798 = invoke noundef nonnull align 4 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI12b3CollidableE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables1722, i32 noundef 0)
          to label %invoke.cont1797 unwind label %lpad1756

invoke.cont1797:                                  ; preds = %invoke.cont1795
  %call1800 = invoke noundef nonnull align 16 dereferenceable(96) ptr @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexData1730, i32 noundef 0)
          to label %invoke.cont1799 unwind label %lpad1756

invoke.cont1799:                                  ; preds = %invoke.cont1797
  %call1802 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices1734, i32 noundef 0)
          to label %invoke.cont1801 unwind label %lpad1756

invoke.cont1801:                                  ; preds = %invoke.cont1799
  %call1804 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges1738, i32 noundef 0)
          to label %invoke.cont1803 unwind label %lpad1756

invoke.cont1803:                                  ; preds = %invoke.cont1801
  %call1806 = invoke noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI9b3GpuFaceE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostFaces1742, i32 noundef 0)
          to label %invoke.cont1805 unwind label %lpad1756

invoke.cont1805:                                  ; preds = %invoke.cont1803
  %call1808 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostIndices1746, i32 noundef 0)
          to label %invoke.cont1807 unwind label %lpad1756

invoke.cont1807:                                  ; preds = %invoke.cont1805
  %790 = load ptr, ptr %childShapePointerCPU, align 8
  %call1810 = invoke noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI6b3AabbE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsWorldSpace1726, i32 noundef 0)
          to label %invoke.cont1809 unwind label %lpad1756

invoke.cont1809:                                  ; preds = %invoke.cont1807
  %call1812 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %concaveSepNormalsHost, i32 noundef 0)
          to label %invoke.cont1811 unwind label %lpad1756

invoke.cont1811:                                  ; preds = %invoke.cont1809
  %call1814 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI6b3Int4E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU, i32 noundef 0)
          to label %invoke.cont1813 unwind label %lpad1756

invoke.cont1813:                                  ; preds = %invoke.cont1811
  %call1816 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsA1CPU, i32 noundef 0)
          to label %invoke.cont1815 unwind label %lpad1756

invoke.cont1815:                                  ; preds = %invoke.cont1813
  %call1818 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %worldNormalsACPU, i32 noundef 0)
          to label %invoke.cont1817 unwind label %lpad1756

invoke.cont1817:                                  ; preds = %invoke.cont1815
  %call1820 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB1CPU, i32 noundef 0)
          to label %invoke.cont1819 unwind label %lpad1756

invoke.cont1819:                                  ; preds = %invoke.cont1817
  %call1822 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %concaveHasSeparatingNormalsCPU, i32 noundef 0)
          to label %invoke.cont1821 unwind label %lpad1756

invoke.cont1821:                                  ; preds = %invoke.cont1819
  %791 = load i32, ptr %vertexFaceCapacity, align 4
  %792 = load i32, ptr %numConcavePairs, align 4
  %793 = load i32, ptr %i1789, align 4
  invoke void @_Z33b3FindConcaveSeparatingAxisKernelP6b3Int4PK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataPK9b3Vector3SC_PK9b3GpuFacePKiPK15b3GpuChildShapeP6b3AabbPSA_S0_SN_SN_SN_Piiii(ptr noundef %call1794, ptr noundef %call1796, ptr noundef %call1798, ptr noundef %call1800, ptr noundef %call1802, ptr noundef %call1804, ptr noundef %call1806, ptr noundef %call1808, ptr noundef %790, ptr noundef %call1810, ptr noundef %call1812, ptr noundef %call1814, ptr noundef %call1816, ptr noundef %call1818, ptr noundef %call1820, ptr noundef %call1822, i32 noundef %791, i32 noundef %792, i32 noundef %793)
          to label %invoke.cont1823 unwind label %lpad1756

invoke.cont1823:                                  ; preds = %invoke.cont1821
  br label %for.inc1824

for.inc1824:                                      ; preds = %invoke.cont1823
  %794 = load i32, ptr %i1789, align 4
  %inc1825 = add nsw i32 %794, 1
  store i32 %inc1825, ptr %i1789, align 4
  br label %for.cond1790, !llvm.loop !71

for.end1826:                                      ; preds = %for.cond1790
  %m_concaveSepNormals1827 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 29
  invoke void @_ZN13b3OpenCLArrayI9b3Vector3E12copyFromHostERK20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveSepNormals1827, ptr noundef nonnull align 8 dereferenceable(25) %concaveSepNormalsHost, i1 noundef zeroext true)
          to label %invoke.cont1828 unwind label %lpad1756

invoke.cont1828:                                  ; preds = %for.end1826
  %m_concaveHasSeparatingNormals1829 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 30
  invoke void @_ZN13b3OpenCLArrayIiE12copyFromHostERK20b3AlignedObjectArrayIiEb(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveHasSeparatingNormals1829, ptr noundef nonnull align 8 dereferenceable(25) %concaveHasSeparatingNormalsCPU, i1 noundef zeroext true)
          to label %invoke.cont1830 unwind label %lpad1756

invoke.cont1830:                                  ; preds = %invoke.cont1828
  %795 = load ptr, ptr %clippingFacesOutGPU.addr, align 8
  invoke void @_ZN13b3OpenCLArrayI6b3Int4E12copyFromHostERK20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %795, ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU, i1 noundef zeroext true)
          to label %invoke.cont1831 unwind label %lpad1756

invoke.cont1831:                                  ; preds = %invoke.cont1830
  %796 = load ptr, ptr %worldVertsA1GPU.addr, align 8
  invoke void @_ZN13b3OpenCLArrayI9b3Vector3E12copyFromHostERK20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %796, ptr noundef nonnull align 8 dereferenceable(25) %worldVertsA1CPU, i1 noundef zeroext true)
          to label %invoke.cont1832 unwind label %lpad1756

invoke.cont1832:                                  ; preds = %invoke.cont1831
  %797 = load ptr, ptr %worldNormalsAGPU.addr, align 8
  invoke void @_ZN13b3OpenCLArrayI9b3Vector3E12copyFromHostERK20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %797, ptr noundef nonnull align 8 dereferenceable(25) %worldNormalsACPU, i1 noundef zeroext true)
          to label %invoke.cont1833 unwind label %lpad1756

invoke.cont1833:                                  ; preds = %invoke.cont1832
  %798 = load ptr, ptr %worldVertsB1GPU.addr, align 8
  invoke void @_ZN13b3OpenCLArrayI9b3Vector3E12copyFromHostERK20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %798, ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB1CPU, i1 noundef zeroext true)
          to label %invoke.cont1834 unwind label %lpad1756

invoke.cont1834:                                  ; preds = %invoke.cont1833
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %concaveSepNormalsHost) #13
  call void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuChildShapes1750) #13
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostIndices1746) #13
  call void @_ZN20b3AlignedObjectArrayI9b3GpuFaceED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostFaces1742) #13
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges1738) #13
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices1734) #13
  call void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexData1730) #13
  call void @_ZN20b3AlignedObjectArrayI6b3AabbED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsWorldSpace1726) #13
  call void @_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables1722) #13
  call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf1718) #13
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %triangleConvexPairsOutHost1713) #13
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %concaveHasSeparatingNormalsCPU) #13
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB1CPU) #13
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldNormalsACPU) #13
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsA1CPU) #13
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU) #13
  br label %if.end1851

ehcleanup1836:                                    ; preds = %lpad1756, %lpad1752
  call void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuChildShapes1750) #13
  br label %ehcleanup1837

ehcleanup1837:                                    ; preds = %ehcleanup1836, %lpad1748
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostIndices1746) #13
  br label %ehcleanup1838

ehcleanup1838:                                    ; preds = %ehcleanup1837, %lpad1744
  call void @_ZN20b3AlignedObjectArrayI9b3GpuFaceED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostFaces1742) #13
  br label %ehcleanup1839

ehcleanup1839:                                    ; preds = %ehcleanup1838, %lpad1740
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges1738) #13
  br label %ehcleanup1840

ehcleanup1840:                                    ; preds = %ehcleanup1839, %lpad1736
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices1734) #13
  br label %ehcleanup1841

ehcleanup1841:                                    ; preds = %ehcleanup1840, %lpad1732
  call void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexData1730) #13
  br label %ehcleanup1842

ehcleanup1842:                                    ; preds = %ehcleanup1841, %lpad1728
  call void @_ZN20b3AlignedObjectArrayI6b3AabbED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsWorldSpace1726) #13
  br label %ehcleanup1843

ehcleanup1843:                                    ; preds = %ehcleanup1842, %lpad1724
  call void @_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables1722) #13
  br label %ehcleanup1844

ehcleanup1844:                                    ; preds = %ehcleanup1843, %lpad1720
  call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf1718) #13
  br label %ehcleanup1845

ehcleanup1845:                                    ; preds = %ehcleanup1844, %lpad1716
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %triangleConvexPairsOutHost1713) #13
  br label %ehcleanup1846

ehcleanup1846:                                    ; preds = %ehcleanup1845, %lpad1714
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %concaveHasSeparatingNormalsCPU) #13
  br label %ehcleanup1847

ehcleanup1847:                                    ; preds = %ehcleanup1846, %lpad1711
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB1CPU) #13
  br label %ehcleanup1848

ehcleanup1848:                                    ; preds = %ehcleanup1847, %lpad1709
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldNormalsACPU) #13
  br label %ehcleanup1849

ehcleanup1849:                                    ; preds = %ehcleanup1848, %lpad1707
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsA1CPU) #13
  br label %ehcleanup1850

ehcleanup1850:                                    ; preds = %ehcleanup1849, %lpad1705
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU) #13
  br label %ehcleanup2980

if.end1851:                                       ; preds = %invoke.cont1834, %if.end1702
  br label %if.end1852

if.end1852:                                       ; preds = %if.end1851, %invoke.cont1411
  br label %if.end1853

if.end1853:                                       ; preds = %if.end1852, %invoke.cont1267, %invoke.cont1263
  %799 = load i32, ptr %numConcavePairs, align 4
  %tobool1854 = icmp ne i32 %799, 0
  br i1 %tobool1854, label %if.then1855, label %if.end1937

if.then1855:                                      ; preds = %if.end1853
  %800 = load i32, ptr %numConcavePairs, align 4
  %tobool1856 = icmp ne i32 %800, 0
  br i1 %tobool1856, label %if.then1857, label %if.end1936

if.then1857:                                      ; preds = %if.then1855
  invoke void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %__profile1858, ptr noundef @.str.28)
          to label %invoke.cont1859 unwind label %lpad58

invoke.cont1859:                                  ; preds = %if.then1857
  %m_totalContactsOut1860 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %call1863 = invoke noundef i32 @_ZNK13b3OpenCLArrayIiE2atEm(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut1860, i64 noundef 0)
          to label %invoke.cont1862 unwind label %lpad1861

invoke.cont1862:                                  ; preds = %invoke.cont1859
  %801 = load ptr, ptr %nContacts.addr, align 8
  store i32 %call1863, ptr %801, align 4
  %arrayinit.begin1865 = getelementptr inbounds [11 x %struct.b3BufferInfoCL], ptr %bInfo1864, i64 0, i64 0
  %802 = load ptr, ptr %triangleConvexPairsOut.addr, align 8
  %call1867 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %802)
          to label %invoke.cont1866 unwind label %lpad1861

invoke.cont1866:                                  ; preds = %invoke.cont1862
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.begin1865, ptr noundef %call1867, i1 noundef zeroext false)
          to label %invoke.cont1868 unwind label %lpad1861

invoke.cont1868:                                  ; preds = %invoke.cont1866
  %arrayinit.element1869 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.begin1865, i64 1
  %803 = load ptr, ptr %bodyBuf.addr, align 8
  %call1871 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %803)
          to label %invoke.cont1870 unwind label %lpad1861

invoke.cont1870:                                  ; preds = %invoke.cont1868
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1869, ptr noundef %call1871, i1 noundef zeroext true)
          to label %invoke.cont1872 unwind label %lpad1861

invoke.cont1872:                                  ; preds = %invoke.cont1870
  %arrayinit.element1873 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1869, i64 1
  %804 = load ptr, ptr %gpuCollidables.addr, align 8
  %call1875 = invoke noundef ptr @_ZNK13b3OpenCLArrayI12b3CollidableE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %804)
          to label %invoke.cont1874 unwind label %lpad1861

invoke.cont1874:                                  ; preds = %invoke.cont1872
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1873, ptr noundef %call1875, i1 noundef zeroext true)
          to label %invoke.cont1876 unwind label %lpad1861

invoke.cont1876:                                  ; preds = %invoke.cont1874
  %arrayinit.element1877 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1873, i64 1
  %805 = load ptr, ptr %convexData.addr, align 8
  %call1879 = invoke noundef ptr @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %805)
          to label %invoke.cont1878 unwind label %lpad1861

invoke.cont1878:                                  ; preds = %invoke.cont1876
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1877, ptr noundef %call1879, i1 noundef zeroext true)
          to label %invoke.cont1880 unwind label %lpad1861

invoke.cont1880:                                  ; preds = %invoke.cont1878
  %arrayinit.element1881 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1877, i64 1
  %806 = load ptr, ptr %gpuVertices.addr, align 8
  %call1883 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %806)
          to label %invoke.cont1882 unwind label %lpad1861

invoke.cont1882:                                  ; preds = %invoke.cont1880
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1881, ptr noundef %call1883, i1 noundef zeroext true)
          to label %invoke.cont1884 unwind label %lpad1861

invoke.cont1884:                                  ; preds = %invoke.cont1882
  %arrayinit.element1885 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1881, i64 1
  %807 = load ptr, ptr %gpuUniqueEdges.addr, align 8
  %call1887 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %807)
          to label %invoke.cont1886 unwind label %lpad1861

invoke.cont1886:                                  ; preds = %invoke.cont1884
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1885, ptr noundef %call1887, i1 noundef zeroext true)
          to label %invoke.cont1888 unwind label %lpad1861

invoke.cont1888:                                  ; preds = %invoke.cont1886
  %arrayinit.element1889 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1885, i64 1
  %808 = load ptr, ptr %gpuFaces.addr, align 8
  %call1891 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3GpuFaceE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %808)
          to label %invoke.cont1890 unwind label %lpad1861

invoke.cont1890:                                  ; preds = %invoke.cont1888
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1889, ptr noundef %call1891, i1 noundef zeroext true)
          to label %invoke.cont1892 unwind label %lpad1861

invoke.cont1892:                                  ; preds = %invoke.cont1890
  %arrayinit.element1893 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1889, i64 1
  %809 = load ptr, ptr %gpuIndices.addr, align 8
  %call1895 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %809)
          to label %invoke.cont1894 unwind label %lpad1861

invoke.cont1894:                                  ; preds = %invoke.cont1892
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1893, ptr noundef %call1895, i1 noundef zeroext true)
          to label %invoke.cont1896 unwind label %lpad1861

invoke.cont1896:                                  ; preds = %invoke.cont1894
  %arrayinit.element1897 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1893, i64 1
  %810 = load ptr, ptr %clAabbsWorldSpace.addr, align 8
  %call1899 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3AabbE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %810)
          to label %invoke.cont1898 unwind label %lpad1861

invoke.cont1898:                                  ; preds = %invoke.cont1896
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1897, ptr noundef %call1899, i1 noundef zeroext true)
          to label %invoke.cont1900 unwind label %lpad1861

invoke.cont1900:                                  ; preds = %invoke.cont1898
  %arrayinit.element1901 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1897, i64 1
  %811 = load ptr, ptr %contactOut.addr, align 8
  %call1903 = invoke noundef ptr @_ZNK13b3OpenCLArrayI10b3Contact4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %811)
          to label %invoke.cont1902 unwind label %lpad1861

invoke.cont1902:                                  ; preds = %invoke.cont1900
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1901, ptr noundef %call1903, i1 noundef zeroext false)
          to label %invoke.cont1904 unwind label %lpad1861

invoke.cont1904:                                  ; preds = %invoke.cont1902
  %arrayinit.element1905 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element1901, i64 1
  %m_totalContactsOut1906 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %call1908 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut1906)
          to label %invoke.cont1907 unwind label %lpad1861

invoke.cont1907:                                  ; preds = %invoke.cont1904
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element1905, ptr noundef %call1908, i1 noundef zeroext false)
          to label %invoke.cont1909 unwind label %lpad1861

invoke.cont1909:                                  ; preds = %invoke.cont1907
  %m_queue1911 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %812 = load ptr, ptr %m_queue1911, align 8
  %m_findConcaveSphereContactsKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 22
  %813 = load ptr, ptr %m_findConcaveSphereContactsKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher1910, ptr noundef %812, ptr noundef %813, ptr noundef @.str.57)
          to label %invoke.cont1912 unwind label %lpad1861

invoke.cont1912:                                  ; preds = %invoke.cont1909
  %arraydecay1913 = getelementptr inbounds [11 x %struct.b3BufferInfoCL], ptr %bInfo1864, i64 0, i64 0
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher1910, ptr noundef %arraydecay1913, i32 noundef 11)
          to label %invoke.cont1915 unwind label %lpad1914

invoke.cont1915:                                  ; preds = %invoke.cont1912
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher1910, ptr noundef nonnull align 4 dereferenceable(4) %numConcavePairs)
          to label %invoke.cont1916 unwind label %lpad1914

invoke.cont1916:                                  ; preds = %invoke.cont1915
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher1910, ptr noundef nonnull align 4 dereferenceable(4) %maxContactCapacity.addr)
          to label %invoke.cont1917 unwind label %lpad1914

invoke.cont1917:                                  ; preds = %invoke.cont1916
  %814 = load i32, ptr %numConcavePairs, align 4
  store i32 %814, ptr %num1918, align 4
  %815 = load i32, ptr %num1918, align 4
  invoke void @_ZN12b3LauncherCL8launch1DEii(ptr noundef nonnull align 8 dereferenceable(112) %launcher1910, i32 noundef %815, i32 noundef 64)
          to label %invoke.cont1919 unwind label %lpad1914

invoke.cont1919:                                  ; preds = %invoke.cont1917
  %816 = load ptr, ptr @__clewFinish, align 8
  %m_queue1920 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %817 = load ptr, ptr %m_queue1920, align 8
  %call1922 = invoke i32 %816(ptr noundef %817)
          to label %invoke.cont1921 unwind label %lpad1914

invoke.cont1921:                                  ; preds = %invoke.cont1919
  %m_totalContactsOut1923 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %call1925 = invoke noundef i32 @_ZNK13b3OpenCLArrayIiE2atEm(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut1923, i64 noundef 0)
          to label %invoke.cont1924 unwind label %lpad1914

invoke.cont1924:                                  ; preds = %invoke.cont1921
  %818 = load ptr, ptr %nContacts.addr, align 8
  store i32 %call1925, ptr %818, align 4
  %819 = load ptr, ptr %nContacts.addr, align 8
  %820 = load i32, ptr %819, align 4
  %821 = load i32, ptr %maxContactCapacity.addr, align 4
  %cmp1926 = icmp sge i32 %820, %821
  br i1 %cmp1926, label %if.then1927, label %if.end1933

if.then1927:                                      ; preds = %invoke.cont1924
  br label %do.body1928

do.body1928:                                      ; preds = %if.then1927
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.31, i32 noundef 3815)
          to label %invoke.cont1929 unwind label %lpad1914

invoke.cont1929:                                  ; preds = %do.body1928
  %822 = load ptr, ptr %nContacts.addr, align 8
  %823 = load i32, ptr %822, align 4
  %824 = load i32, ptr %maxContactCapacity.addr, align 4
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.41, i32 noundef %823, i32 noundef %824)
          to label %invoke.cont1930 unwind label %lpad1914

invoke.cont1930:                                  ; preds = %invoke.cont1929
  br label %do.cond1931

do.cond1931:                                      ; preds = %invoke.cont1930
  br label %do.end1932

do.end1932:                                       ; preds = %do.cond1931
  %825 = load i32, ptr %maxContactCapacity.addr, align 4
  %826 = load ptr, ptr %nContacts.addr, align 8
  store i32 %825, ptr %826, align 4
  br label %if.end1933

lpad1861:                                         ; preds = %invoke.cont1909, %invoke.cont1907, %invoke.cont1904, %invoke.cont1902, %invoke.cont1900, %invoke.cont1898, %invoke.cont1896, %invoke.cont1894, %invoke.cont1892, %invoke.cont1890, %invoke.cont1888, %invoke.cont1886, %invoke.cont1884, %invoke.cont1882, %invoke.cont1880, %invoke.cont1878, %invoke.cont1876, %invoke.cont1874, %invoke.cont1872, %invoke.cont1870, %invoke.cont1868, %invoke.cont1866, %invoke.cont1862, %invoke.cont1859
  %827 = landingpad { ptr, i32 }
          cleanup
  %828 = extractvalue { ptr, i32 } %827, 0
  store ptr %828, ptr %exn.slot, align 8
  %829 = extractvalue { ptr, i32 } %827, 1
  store i32 %829, ptr %ehselector.slot, align 4
  br label %ehcleanup1935

lpad1914:                                         ; preds = %invoke.cont1929, %do.body1928, %invoke.cont1921, %invoke.cont1919, %invoke.cont1917, %invoke.cont1916, %invoke.cont1915, %invoke.cont1912
  %830 = landingpad { ptr, i32 }
          cleanup
  %831 = extractvalue { ptr, i32 } %830, 0
  store ptr %831, ptr %exn.slot, align 8
  %832 = extractvalue { ptr, i32 } %830, 1
  store i32 %832, ptr %ehselector.slot, align 4
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1910) #13
  br label %ehcleanup1935

if.end1933:                                       ; preds = %do.end1932, %invoke.cont1924
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1910) #13
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile1858) #13
  br label %if.end1936

ehcleanup1935:                                    ; preds = %lpad1914, %lpad1861
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile1858) #13
  br label %ehcleanup2980

if.end1936:                                       ; preds = %if.end1933, %if.then1855
  br label %if.end1937

if.end1937:                                       ; preds = %if.end1936, %if.end1853
  store i8 1, ptr %contactClippingOnGpu, align 1
  %833 = load i8, ptr %contactClippingOnGpu, align 1
  %tobool1938 = trunc i8 %833 to i1
  br i1 %tobool1938, label %if.then1939, label %if.end2979

if.then1939:                                      ; preds = %if.end1937
  %m_totalContactsOut1940 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %834 = load ptr, ptr %nContacts.addr, align 8
  invoke void @_ZN13b3OpenCLArrayIiE19copyFromHostPointerEPKimmb(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut1940, ptr noundef %834, i64 noundef 1, i64 noundef 0, i1 noundef zeroext true)
          to label %invoke.cont1941 unwind label %lpad58

invoke.cont1941:                                  ; preds = %if.then1939
  store i8 1, ptr %breakupConcaveConvexKernel, align 1
  %835 = load i32, ptr %numConcavePairs, align 4
  %tobool1942 = icmp ne i32 %835, 0
  br i1 %tobool1942, label %if.then1943, label %if.end2291

if.then1943:                                      ; preds = %invoke.cont1941
  %836 = load i8, ptr %breakupConcaveConvexKernel, align 1
  %tobool1944 = trunc i8 %836 to i1
  br i1 %tobool1944, label %if.then1945, label %if.else2203

if.then1945:                                      ; preds = %if.then1943
  %837 = load ptr, ptr %worldVertsB2GPU.addr, align 8
  %838 = load i32, ptr %vertexFaceCapacity, align 4
  %839 = load i32, ptr %numConcavePairs, align 4
  %mul1946 = mul nsw i32 %838, %839
  %conv1947 = sext i32 %mul1946 to i64
  %call1949 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %837, i64 noundef %conv1947, i1 noundef zeroext true)
          to label %invoke.cont1948 unwind label %lpad58

invoke.cont1948:                                  ; preds = %if.then1945
  %840 = load i8, ptr @clipConcaveFacesAndFindContactsCPU, align 1
  %tobool1950 = trunc i8 %840 to i1
  br i1 %tobool1950, label %if.then1951, label %if.else2016

if.then1951:                                      ; preds = %invoke.cont1948
  invoke void @_ZN20b3AlignedObjectArrayI6b3Int4EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU1952)
          to label %invoke.cont1953 unwind label %lpad58

invoke.cont1953:                                  ; preds = %if.then1951
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsA1CPU1954)
          to label %invoke.cont1956 unwind label %lpad1955

invoke.cont1956:                                  ; preds = %invoke.cont1953
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldNormalsACPU1957)
          to label %invoke.cont1959 unwind label %lpad1958

invoke.cont1959:                                  ; preds = %invoke.cont1956
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB1CPU1960)
          to label %invoke.cont1962 unwind label %lpad1961

invoke.cont1962:                                  ; preds = %invoke.cont1959
  %841 = load ptr, ptr %clippingFacesOutGPU.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI6b3Int4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %841, ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU1952, i1 noundef zeroext true)
          to label %invoke.cont1964 unwind label %lpad1963

invoke.cont1964:                                  ; preds = %invoke.cont1962
  %842 = load ptr, ptr %worldVertsA1GPU.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %842, ptr noundef nonnull align 8 dereferenceable(25) %worldVertsA1CPU1954, i1 noundef zeroext true)
          to label %invoke.cont1965 unwind label %lpad1963

invoke.cont1965:                                  ; preds = %invoke.cont1964
  %843 = load ptr, ptr %worldNormalsAGPU.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %843, ptr noundef nonnull align 8 dereferenceable(25) %worldNormalsACPU1957, i1 noundef zeroext true)
          to label %invoke.cont1966 unwind label %lpad1963

invoke.cont1966:                                  ; preds = %invoke.cont1965
  %844 = load ptr, ptr %worldVertsB1GPU.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %844, ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB1CPU1960, i1 noundef zeroext true)
          to label %invoke.cont1967 unwind label %lpad1963

invoke.cont1967:                                  ; preds = %invoke.cont1966
  invoke void @_ZN20b3AlignedObjectArrayIiEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %concaveHasSeparatingNormalsCPU1968)
          to label %invoke.cont1969 unwind label %lpad1963

invoke.cont1969:                                  ; preds = %invoke.cont1967
  %m_concaveHasSeparatingNormals1970 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 30
  invoke void @_ZNK13b3OpenCLArrayIiE10copyToHostER20b3AlignedObjectArrayIiEb(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveHasSeparatingNormals1970, ptr noundef nonnull align 8 dereferenceable(25) %concaveHasSeparatingNormalsCPU1968, i1 noundef zeroext true)
          to label %invoke.cont1972 unwind label %lpad1971

invoke.cont1972:                                  ; preds = %invoke.cont1969
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %concaveSepNormalsHost1973)
          to label %invoke.cont1974 unwind label %lpad1971

invoke.cont1974:                                  ; preds = %invoke.cont1972
  %m_concaveSepNormals1975 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 29
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveSepNormals1975, ptr noundef nonnull align 8 dereferenceable(25) %concaveSepNormalsHost1973, i1 noundef zeroext true)
          to label %invoke.cont1977 unwind label %lpad1976

invoke.cont1977:                                  ; preds = %invoke.cont1974
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB2CPU)
          to label %invoke.cont1978 unwind label %lpad1976

invoke.cont1978:                                  ; preds = %invoke.cont1977
  %845 = load ptr, ptr %worldVertsB2GPU.addr, align 8
  %call1981 = invoke noundef i64 @_ZNK13b3OpenCLArrayI9b3Vector3E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %845)
          to label %invoke.cont1980 unwind label %lpad1979

invoke.cont1980:                                  ; preds = %invoke.cont1978
  %conv1982 = trunc i64 %call1981 to i32
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp1983, i8 0, i64 16, i1 false)
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB2CPU, i32 noundef %conv1982, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp1983)
          to label %invoke.cont1984 unwind label %lpad1979

invoke.cont1984:                                  ; preds = %invoke.cont1980
  store i32 0, ptr %i1985, align 4
  br label %for.cond1986

for.cond1986:                                     ; preds = %for.inc2004, %invoke.cont1984
  %846 = load i32, ptr %i1985, align 4
  %847 = load i32, ptr %numConcavePairs, align 4
  %cmp1987 = icmp slt i32 %846, %847
  br i1 %cmp1987, label %for.body1988, label %for.end2006

for.body1988:                                     ; preds = %for.cond1986
  %call1990 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %concaveSepNormalsHost1973, i32 noundef 0)
          to label %invoke.cont1989 unwind label %lpad1979

invoke.cont1989:                                  ; preds = %for.body1988
  %call1992 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %concaveHasSeparatingNormalsCPU1968, i32 noundef 0)
          to label %invoke.cont1991 unwind label %lpad1979

invoke.cont1991:                                  ; preds = %invoke.cont1989
  %call1994 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI6b3Int4E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU1952, i32 noundef 0)
          to label %invoke.cont1993 unwind label %lpad1979

invoke.cont1993:                                  ; preds = %invoke.cont1991
  %call1996 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsA1CPU1954, i32 noundef 0)
          to label %invoke.cont1995 unwind label %lpad1979

invoke.cont1995:                                  ; preds = %invoke.cont1993
  %call1998 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %worldNormalsACPU1957, i32 noundef 0)
          to label %invoke.cont1997 unwind label %lpad1979

invoke.cont1997:                                  ; preds = %invoke.cont1995
  %call2000 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB1CPU1960, i32 noundef 0)
          to label %invoke.cont1999 unwind label %lpad1979

invoke.cont1999:                                  ; preds = %invoke.cont1997
  %call2002 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB2CPU, i32 noundef 0)
          to label %invoke.cont2001 unwind label %lpad1979

invoke.cont2001:                                  ; preds = %invoke.cont1999
  %848 = load i32, ptr %vertexFaceCapacity, align 4
  %849 = load i32, ptr %i1985, align 4
  invoke void @_Z30clipFacesAndFindContactsKernelPK9b3Vector3PKiP6b3Int4PS_S6_S6_S6_ii(ptr noundef %call1990, ptr noundef %call1992, ptr noundef %call1994, ptr noundef %call1996, ptr noundef %call1998, ptr noundef %call2000, ptr noundef %call2002, i32 noundef %848, i32 noundef %849)
          to label %invoke.cont2003 unwind label %lpad1979

invoke.cont2003:                                  ; preds = %invoke.cont2001
  br label %for.inc2004

for.inc2004:                                      ; preds = %invoke.cont2003
  %850 = load i32, ptr %i1985, align 4
  %inc2005 = add nsw i32 %850, 1
  store i32 %inc2005, ptr %i1985, align 4
  br label %for.cond1986, !llvm.loop !72

lpad1955:                                         ; preds = %invoke.cont1953
  %851 = landingpad { ptr, i32 }
          cleanup
  %852 = extractvalue { ptr, i32 } %851, 0
  store ptr %852, ptr %exn.slot, align 8
  %853 = extractvalue { ptr, i32 } %851, 1
  store i32 %853, ptr %ehselector.slot, align 4
  br label %ehcleanup2015

lpad1958:                                         ; preds = %invoke.cont1956
  %854 = landingpad { ptr, i32 }
          cleanup
  %855 = extractvalue { ptr, i32 } %854, 0
  store ptr %855, ptr %exn.slot, align 8
  %856 = extractvalue { ptr, i32 } %854, 1
  store i32 %856, ptr %ehselector.slot, align 4
  br label %ehcleanup2014

lpad1961:                                         ; preds = %invoke.cont1959
  %857 = landingpad { ptr, i32 }
          cleanup
  %858 = extractvalue { ptr, i32 } %857, 0
  store ptr %858, ptr %exn.slot, align 8
  %859 = extractvalue { ptr, i32 } %857, 1
  store i32 %859, ptr %ehselector.slot, align 4
  br label %ehcleanup2013

lpad1963:                                         ; preds = %invoke.cont1967, %invoke.cont1966, %invoke.cont1965, %invoke.cont1964, %invoke.cont1962
  %860 = landingpad { ptr, i32 }
          cleanup
  %861 = extractvalue { ptr, i32 } %860, 0
  store ptr %861, ptr %exn.slot, align 8
  %862 = extractvalue { ptr, i32 } %860, 1
  store i32 %862, ptr %ehselector.slot, align 4
  br label %ehcleanup2012

lpad1971:                                         ; preds = %invoke.cont1972, %invoke.cont1969
  %863 = landingpad { ptr, i32 }
          cleanup
  %864 = extractvalue { ptr, i32 } %863, 0
  store ptr %864, ptr %exn.slot, align 8
  %865 = extractvalue { ptr, i32 } %863, 1
  store i32 %865, ptr %ehselector.slot, align 4
  br label %ehcleanup2011

lpad1976:                                         ; preds = %invoke.cont1977, %invoke.cont1974
  %866 = landingpad { ptr, i32 }
          cleanup
  %867 = extractvalue { ptr, i32 } %866, 0
  store ptr %867, ptr %exn.slot, align 8
  %868 = extractvalue { ptr, i32 } %866, 1
  store i32 %868, ptr %ehselector.slot, align 4
  br label %ehcleanup2010

lpad1979:                                         ; preds = %invoke.cont2007, %for.end2006, %invoke.cont2001, %invoke.cont1999, %invoke.cont1997, %invoke.cont1995, %invoke.cont1993, %invoke.cont1991, %invoke.cont1989, %for.body1988, %invoke.cont1980, %invoke.cont1978
  %869 = landingpad { ptr, i32 }
          cleanup
  %870 = extractvalue { ptr, i32 } %869, 0
  store ptr %870, ptr %exn.slot, align 8
  %871 = extractvalue { ptr, i32 } %869, 1
  store i32 %871, ptr %ehselector.slot, align 4
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB2CPU) #13
  br label %ehcleanup2010

for.end2006:                                      ; preds = %for.cond1986
  %872 = load ptr, ptr %clippingFacesOutGPU.addr, align 8
  invoke void @_ZN13b3OpenCLArrayI6b3Int4E12copyFromHostERK20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %872, ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU1952, i1 noundef zeroext true)
          to label %invoke.cont2007 unwind label %lpad1979

invoke.cont2007:                                  ; preds = %for.end2006
  %873 = load ptr, ptr %worldVertsB2GPU.addr, align 8
  invoke void @_ZN13b3OpenCLArrayI9b3Vector3E12copyFromHostERK20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %873, ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB2CPU, i1 noundef zeroext true)
          to label %invoke.cont2008 unwind label %lpad1979

invoke.cont2008:                                  ; preds = %invoke.cont2007
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB2CPU) #13
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %concaveSepNormalsHost1973) #13
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %concaveHasSeparatingNormalsCPU1968) #13
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB1CPU1960) #13
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldNormalsACPU1957) #13
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsA1CPU1954) #13
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU1952) #13
  br label %if.end2067

ehcleanup2010:                                    ; preds = %lpad1979, %lpad1976
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %concaveSepNormalsHost1973) #13
  br label %ehcleanup2011

ehcleanup2011:                                    ; preds = %ehcleanup2010, %lpad1971
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %concaveHasSeparatingNormalsCPU1968) #13
  br label %ehcleanup2012

ehcleanup2012:                                    ; preds = %ehcleanup2011, %lpad1963
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB1CPU1960) #13
  br label %ehcleanup2013

ehcleanup2013:                                    ; preds = %ehcleanup2012, %lpad1961
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldNormalsACPU1957) #13
  br label %ehcleanup2014

ehcleanup2014:                                    ; preds = %ehcleanup2013, %lpad1958
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsA1CPU1954) #13
  br label %ehcleanup2015

ehcleanup2015:                                    ; preds = %ehcleanup2014, %lpad1955
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU1952) #13
  br label %ehcleanup2980

if.else2016:                                      ; preds = %invoke.cont1948
  invoke void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %__profile2017, ptr noundef @.str.58)
          to label %invoke.cont2018 unwind label %lpad58

invoke.cont2018:                                  ; preds = %if.else2016
  %arrayinit.begin2020 = getelementptr inbounds [7 x %struct.b3BufferInfoCL], ptr %bInfo2019, i64 0, i64 0
  %m_concaveSepNormals2021 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 29
  %call2024 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveSepNormals2021)
          to label %invoke.cont2023 unwind label %lpad2022

invoke.cont2023:                                  ; preds = %invoke.cont2018
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.begin2020, ptr noundef %call2024, i1 noundef zeroext false)
          to label %invoke.cont2025 unwind label %lpad2022

invoke.cont2025:                                  ; preds = %invoke.cont2023
  %arrayinit.element2026 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.begin2020, i64 1
  %m_concaveHasSeparatingNormals2027 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 30
  %call2029 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveHasSeparatingNormals2027)
          to label %invoke.cont2028 unwind label %lpad2022

invoke.cont2028:                                  ; preds = %invoke.cont2025
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2026, ptr noundef %call2029, i1 noundef zeroext false)
          to label %invoke.cont2030 unwind label %lpad2022

invoke.cont2030:                                  ; preds = %invoke.cont2028
  %arrayinit.element2031 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2026, i64 1
  %874 = load ptr, ptr %clippingFacesOutGPU.addr, align 8
  %call2033 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %874)
          to label %invoke.cont2032 unwind label %lpad2022

invoke.cont2032:                                  ; preds = %invoke.cont2030
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2031, ptr noundef %call2033, i1 noundef zeroext false)
          to label %invoke.cont2034 unwind label %lpad2022

invoke.cont2034:                                  ; preds = %invoke.cont2032
  %arrayinit.element2035 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2031, i64 1
  %875 = load ptr, ptr %worldVertsA1GPU.addr, align 8
  %call2037 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %875)
          to label %invoke.cont2036 unwind label %lpad2022

invoke.cont2036:                                  ; preds = %invoke.cont2034
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2035, ptr noundef %call2037, i1 noundef zeroext false)
          to label %invoke.cont2038 unwind label %lpad2022

invoke.cont2038:                                  ; preds = %invoke.cont2036
  %arrayinit.element2039 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2035, i64 1
  %876 = load ptr, ptr %worldNormalsAGPU.addr, align 8
  %call2041 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %876)
          to label %invoke.cont2040 unwind label %lpad2022

invoke.cont2040:                                  ; preds = %invoke.cont2038
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2039, ptr noundef %call2041, i1 noundef zeroext false)
          to label %invoke.cont2042 unwind label %lpad2022

invoke.cont2042:                                  ; preds = %invoke.cont2040
  %arrayinit.element2043 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2039, i64 1
  %877 = load ptr, ptr %worldVertsB1GPU.addr, align 8
  %call2045 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %877)
          to label %invoke.cont2044 unwind label %lpad2022

invoke.cont2044:                                  ; preds = %invoke.cont2042
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2043, ptr noundef %call2045, i1 noundef zeroext false)
          to label %invoke.cont2046 unwind label %lpad2022

invoke.cont2046:                                  ; preds = %invoke.cont2044
  %arrayinit.element2047 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2043, i64 1
  %878 = load ptr, ptr %worldVertsB2GPU.addr, align 8
  %call2049 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %878)
          to label %invoke.cont2048 unwind label %lpad2022

invoke.cont2048:                                  ; preds = %invoke.cont2046
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2047, ptr noundef %call2049, i1 noundef zeroext false)
          to label %invoke.cont2050 unwind label %lpad2022

invoke.cont2050:                                  ; preds = %invoke.cont2048
  %m_queue2052 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %879 = load ptr, ptr %m_queue2052, align 8
  %m_clipFacesAndFindContacts = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 16
  %880 = load ptr, ptr %m_clipFacesAndFindContacts, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher2051, ptr noundef %879, ptr noundef %880, ptr noundef @.str.59)
          to label %invoke.cont2053 unwind label %lpad2022

invoke.cont2053:                                  ; preds = %invoke.cont2050
  %arraydecay2054 = getelementptr inbounds [7 x %struct.b3BufferInfoCL], ptr %bInfo2019, i64 0, i64 0
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher2051, ptr noundef %arraydecay2054, i32 noundef 7)
          to label %invoke.cont2056 unwind label %lpad2055

invoke.cont2056:                                  ; preds = %invoke.cont2053
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher2051, ptr noundef nonnull align 4 dereferenceable(4) %vertexFaceCapacity)
          to label %invoke.cont2057 unwind label %lpad2055

invoke.cont2057:                                  ; preds = %invoke.cont2056
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher2051, ptr noundef nonnull align 4 dereferenceable(4) %numConcavePairs)
          to label %invoke.cont2058 unwind label %lpad2055

invoke.cont2058:                                  ; preds = %invoke.cont2057
  store i32 0, ptr %debugMode, align 4
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher2051, ptr noundef nonnull align 4 dereferenceable(4) %debugMode)
          to label %invoke.cont2059 unwind label %lpad2055

invoke.cont2059:                                  ; preds = %invoke.cont2058
  %881 = load i32, ptr %numConcavePairs, align 4
  store i32 %881, ptr %num2060, align 4
  %882 = load i32, ptr %num2060, align 4
  invoke void @_ZN12b3LauncherCL8launch1DEii(ptr noundef nonnull align 8 dereferenceable(112) %launcher2051, i32 noundef %882, i32 noundef 64)
          to label %invoke.cont2061 unwind label %lpad2055

invoke.cont2061:                                  ; preds = %invoke.cont2059
  %883 = load ptr, ptr @__clewFinish, align 8
  %m_queue2062 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %884 = load ptr, ptr %m_queue2062, align 8
  %call2064 = invoke i32 %883(ptr noundef %884)
          to label %invoke.cont2063 unwind label %lpad2055

invoke.cont2063:                                  ; preds = %invoke.cont2061
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher2051) #13
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile2017) #13
  br label %if.end2067

lpad2022:                                         ; preds = %invoke.cont2050, %invoke.cont2048, %invoke.cont2046, %invoke.cont2044, %invoke.cont2042, %invoke.cont2040, %invoke.cont2038, %invoke.cont2036, %invoke.cont2034, %invoke.cont2032, %invoke.cont2030, %invoke.cont2028, %invoke.cont2025, %invoke.cont2023, %invoke.cont2018
  %885 = landingpad { ptr, i32 }
          cleanup
  %886 = extractvalue { ptr, i32 } %885, 0
  store ptr %886, ptr %exn.slot, align 8
  %887 = extractvalue { ptr, i32 } %885, 1
  store i32 %887, ptr %ehselector.slot, align 4
  br label %ehcleanup2066

lpad2055:                                         ; preds = %invoke.cont2061, %invoke.cont2059, %invoke.cont2058, %invoke.cont2057, %invoke.cont2056, %invoke.cont2053
  %888 = landingpad { ptr, i32 }
          cleanup
  %889 = extractvalue { ptr, i32 } %888, 0
  store ptr %889, ptr %exn.slot, align 8
  %890 = extractvalue { ptr, i32 } %888, 1
  store i32 %890, ptr %ehselector.slot, align 4
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher2051) #13
  br label %ehcleanup2066

ehcleanup2066:                                    ; preds = %lpad2055, %lpad2022
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile2017) #13
  br label %ehcleanup2980

if.end2067:                                       ; preds = %invoke.cont2063, %invoke.cont2008
  %891 = load ptr, ptr %nContacts.addr, align 8
  %892 = load i32, ptr %891, align 4
  %893 = load i32, ptr %numConcavePairs, align 4
  %add = add nsw i32 %892, %893
  store i32 %add, ptr %newContactCapacity, align 4
  %894 = load ptr, ptr %contactOut.addr, align 8
  %895 = load i32, ptr %newContactCapacity, align 4
  %conv2068 = sext i32 %895 to i64
  %call2070 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI10b3Contact4E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %894, i64 noundef %conv2068, i1 noundef zeroext true)
          to label %invoke.cont2069 unwind label %lpad58

invoke.cont2069:                                  ; preds = %if.end2067
  %896 = load i8, ptr @reduceConcaveContactsOnGPU, align 1
  %tobool2071 = trunc i8 %896 to i1
  br i1 %tobool2071, label %if.then2072, label %if.else2131

if.then2072:                                      ; preds = %invoke.cont2069
  invoke void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %__profile2073, ptr noundef @.str.23)
          to label %invoke.cont2074 unwind label %lpad58

invoke.cont2074:                                  ; preds = %if.then2072
  %arrayinit.begin2076 = getelementptr inbounds [8 x %struct.b3BufferInfoCL], ptr %bInfo2075, i64 0, i64 0
  %897 = load ptr, ptr %triangleConvexPairsOut.addr, align 8
  %call2079 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %897)
          to label %invoke.cont2078 unwind label %lpad2077

invoke.cont2078:                                  ; preds = %invoke.cont2074
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.begin2076, ptr noundef %call2079, i1 noundef zeroext true)
          to label %invoke.cont2080 unwind label %lpad2077

invoke.cont2080:                                  ; preds = %invoke.cont2078
  %arrayinit.element2081 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.begin2076, i64 1
  %898 = load ptr, ptr %bodyBuf.addr, align 8
  %call2083 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %898)
          to label %invoke.cont2082 unwind label %lpad2077

invoke.cont2082:                                  ; preds = %invoke.cont2080
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2081, ptr noundef %call2083, i1 noundef zeroext true)
          to label %invoke.cont2084 unwind label %lpad2077

invoke.cont2084:                                  ; preds = %invoke.cont2082
  %arrayinit.element2085 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2081, i64 1
  %m_concaveSepNormals2086 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 29
  %call2088 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveSepNormals2086)
          to label %invoke.cont2087 unwind label %lpad2077

invoke.cont2087:                                  ; preds = %invoke.cont2084
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2085, ptr noundef %call2088, i1 noundef zeroext false)
          to label %invoke.cont2089 unwind label %lpad2077

invoke.cont2089:                                  ; preds = %invoke.cont2087
  %arrayinit.element2090 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2085, i64 1
  %m_concaveHasSeparatingNormals2091 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 30
  %call2093 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveHasSeparatingNormals2091)
          to label %invoke.cont2092 unwind label %lpad2077

invoke.cont2092:                                  ; preds = %invoke.cont2089
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2090, ptr noundef %call2093, i1 noundef zeroext false)
          to label %invoke.cont2094 unwind label %lpad2077

invoke.cont2094:                                  ; preds = %invoke.cont2092
  %arrayinit.element2095 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2090, i64 1
  %899 = load ptr, ptr %contactOut.addr, align 8
  %call2097 = invoke noundef ptr @_ZNK13b3OpenCLArrayI10b3Contact4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %899)
          to label %invoke.cont2096 unwind label %lpad2077

invoke.cont2096:                                  ; preds = %invoke.cont2094
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2095, ptr noundef %call2097, i1 noundef zeroext false)
          to label %invoke.cont2098 unwind label %lpad2077

invoke.cont2098:                                  ; preds = %invoke.cont2096
  %arrayinit.element2099 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2095, i64 1
  %900 = load ptr, ptr %clippingFacesOutGPU.addr, align 8
  %call2101 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %900)
          to label %invoke.cont2100 unwind label %lpad2077

invoke.cont2100:                                  ; preds = %invoke.cont2098
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2099, ptr noundef %call2101, i1 noundef zeroext false)
          to label %invoke.cont2102 unwind label %lpad2077

invoke.cont2102:                                  ; preds = %invoke.cont2100
  %arrayinit.element2103 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2099, i64 1
  %901 = load ptr, ptr %worldVertsB2GPU.addr, align 8
  %call2105 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %901)
          to label %invoke.cont2104 unwind label %lpad2077

invoke.cont2104:                                  ; preds = %invoke.cont2102
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2103, ptr noundef %call2105, i1 noundef zeroext false)
          to label %invoke.cont2106 unwind label %lpad2077

invoke.cont2106:                                  ; preds = %invoke.cont2104
  %arrayinit.element2107 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2103, i64 1
  %m_totalContactsOut2108 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %call2110 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut2108)
          to label %invoke.cont2109 unwind label %lpad2077

invoke.cont2109:                                  ; preds = %invoke.cont2106
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2107, ptr noundef %call2110, i1 noundef zeroext false)
          to label %invoke.cont2111 unwind label %lpad2077

invoke.cont2111:                                  ; preds = %invoke.cont2109
  %m_queue2113 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %902 = load ptr, ptr %m_queue2113, align 8
  %m_newContactReductionKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 19
  %903 = load ptr, ptr %m_newContactReductionKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher2112, ptr noundef %902, ptr noundef %903, ptr noundef @.str.60)
          to label %invoke.cont2114 unwind label %lpad2077

invoke.cont2114:                                  ; preds = %invoke.cont2111
  %arraydecay2115 = getelementptr inbounds [8 x %struct.b3BufferInfoCL], ptr %bInfo2075, i64 0, i64 0
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher2112, ptr noundef %arraydecay2115, i32 noundef 8)
          to label %invoke.cont2117 unwind label %lpad2116

invoke.cont2117:                                  ; preds = %invoke.cont2114
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher2112, ptr noundef nonnull align 4 dereferenceable(4) %vertexFaceCapacity)
          to label %invoke.cont2118 unwind label %lpad2116

invoke.cont2118:                                  ; preds = %invoke.cont2117
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher2112, ptr noundef nonnull align 4 dereferenceable(4) %newContactCapacity)
          to label %invoke.cont2119 unwind label %lpad2116

invoke.cont2119:                                  ; preds = %invoke.cont2118
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher2112, ptr noundef nonnull align 4 dereferenceable(4) %numConcavePairs)
          to label %invoke.cont2120 unwind label %lpad2116

invoke.cont2120:                                  ; preds = %invoke.cont2119
  %904 = load i32, ptr %numConcavePairs, align 4
  store i32 %904, ptr %num2121, align 4
  %905 = load i32, ptr %num2121, align 4
  invoke void @_ZN12b3LauncherCL8launch1DEii(ptr noundef nonnull align 8 dereferenceable(112) %launcher2112, i32 noundef %905, i32 noundef 64)
          to label %invoke.cont2122 unwind label %lpad2116

invoke.cont2122:                                  ; preds = %invoke.cont2120
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher2112) #13
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile2073) #13
  %m_totalContactsOut2125 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %call2127 = invoke noundef i32 @_ZNK13b3OpenCLArrayIiE2atEm(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut2125, i64 noundef 0)
          to label %invoke.cont2126 unwind label %lpad58

invoke.cont2126:                                  ; preds = %invoke.cont2122
  %906 = load ptr, ptr %nContacts.addr, align 8
  store i32 %call2127, ptr %906, align 4
  %907 = load ptr, ptr %contactOut.addr, align 8
  %908 = load ptr, ptr %nContacts.addr, align 8
  %909 = load i32, ptr %908, align 4
  %conv2128 = sext i32 %909 to i64
  %call2130 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI10b3Contact4E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %907, i64 noundef %conv2128, i1 noundef zeroext true)
          to label %invoke.cont2129 unwind label %lpad58

invoke.cont2129:                                  ; preds = %invoke.cont2126
  br label %if.end2202

lpad2077:                                         ; preds = %invoke.cont2111, %invoke.cont2109, %invoke.cont2106, %invoke.cont2104, %invoke.cont2102, %invoke.cont2100, %invoke.cont2098, %invoke.cont2096, %invoke.cont2094, %invoke.cont2092, %invoke.cont2089, %invoke.cont2087, %invoke.cont2084, %invoke.cont2082, %invoke.cont2080, %invoke.cont2078, %invoke.cont2074
  %910 = landingpad { ptr, i32 }
          cleanup
  %911 = extractvalue { ptr, i32 } %910, 0
  store ptr %911, ptr %exn.slot, align 8
  %912 = extractvalue { ptr, i32 } %910, 1
  store i32 %912, ptr %ehselector.slot, align 4
  br label %ehcleanup2124

lpad2116:                                         ; preds = %invoke.cont2120, %invoke.cont2119, %invoke.cont2118, %invoke.cont2117, %invoke.cont2114
  %913 = landingpad { ptr, i32 }
          cleanup
  %914 = extractvalue { ptr, i32 } %913, 0
  store ptr %914, ptr %exn.slot, align 8
  %915 = extractvalue { ptr, i32 } %913, 1
  store i32 %915, ptr %ehselector.slot, align 4
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher2112) #13
  br label %ehcleanup2124

ehcleanup2124:                                    ; preds = %lpad2116, %lpad2077
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile2073) #13
  br label %ehcleanup2980

if.else2131:                                      ; preds = %invoke.cont2069
  %916 = load ptr, ptr %nContacts.addr, align 8
  %917 = load i32, ptr %916, align 4
  store volatile i32 %917, ptr %nGlobalContactsOut2132, align 4
  invoke void @_ZN20b3AlignedObjectArrayI6b3Int4EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %triangleConvexPairsOutHost2133)
          to label %invoke.cont2134 unwind label %lpad58

invoke.cont2134:                                  ; preds = %if.else2131
  %918 = load ptr, ptr %triangleConvexPairsOut.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI6b3Int4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %918, ptr noundef nonnull align 8 dereferenceable(25) %triangleConvexPairsOutHost2133, i1 noundef zeroext true)
          to label %invoke.cont2136 unwind label %lpad2135

invoke.cont2136:                                  ; preds = %invoke.cont2134
  invoke void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf2137)
          to label %invoke.cont2138 unwind label %lpad2135

invoke.cont2138:                                  ; preds = %invoke.cont2136
  %919 = load ptr, ptr %bodyBuf.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %919, ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf2137, i1 noundef zeroext true)
          to label %invoke.cont2140 unwind label %lpad2139

invoke.cont2140:                                  ; preds = %invoke.cont2138
  invoke void @_ZN20b3AlignedObjectArrayIiEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %concaveHasSeparatingNormalsCPU2141)
          to label %invoke.cont2142 unwind label %lpad2139

invoke.cont2142:                                  ; preds = %invoke.cont2140
  %m_concaveHasSeparatingNormals2143 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 30
  invoke void @_ZNK13b3OpenCLArrayIiE10copyToHostER20b3AlignedObjectArrayIiEb(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveHasSeparatingNormals2143, ptr noundef nonnull align 8 dereferenceable(25) %concaveHasSeparatingNormalsCPU2141, i1 noundef zeroext true)
          to label %invoke.cont2145 unwind label %lpad2144

invoke.cont2145:                                  ; preds = %invoke.cont2142
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %concaveSepNormalsHost2146)
          to label %invoke.cont2147 unwind label %lpad2144

invoke.cont2147:                                  ; preds = %invoke.cont2145
  %m_concaveSepNormals2148 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 29
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveSepNormals2148, ptr noundef nonnull align 8 dereferenceable(25) %concaveSepNormalsHost2146, i1 noundef zeroext true)
          to label %invoke.cont2150 unwind label %lpad2149

invoke.cont2150:                                  ; preds = %invoke.cont2147
  invoke void @_ZN20b3AlignedObjectArrayI10b3Contact4EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostContacts2151)
          to label %invoke.cont2152 unwind label %lpad2149

invoke.cont2152:                                  ; preds = %invoke.cont2150
  %920 = load ptr, ptr %nContacts.addr, align 8
  %921 = load i32, ptr %920, align 4
  %tobool2153 = icmp ne i32 %921, 0
  br i1 %tobool2153, label %if.then2154, label %if.end2157

if.then2154:                                      ; preds = %invoke.cont2152
  %922 = load ptr, ptr %contactOut.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI10b3Contact4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %922, ptr noundef nonnull align 8 dereferenceable(25) %hostContacts2151, i1 noundef zeroext true)
          to label %invoke.cont2156 unwind label %lpad2155

invoke.cont2156:                                  ; preds = %if.then2154
  br label %if.end2157

lpad2135:                                         ; preds = %invoke.cont2136, %invoke.cont2134
  %923 = landingpad { ptr, i32 }
          cleanup
  %924 = extractvalue { ptr, i32 } %923, 0
  store ptr %924, ptr %exn.slot, align 8
  %925 = extractvalue { ptr, i32 } %923, 1
  store i32 %925, ptr %ehselector.slot, align 4
  br label %ehcleanup2201

lpad2139:                                         ; preds = %invoke.cont2140, %invoke.cont2138
  %926 = landingpad { ptr, i32 }
          cleanup
  %927 = extractvalue { ptr, i32 } %926, 0
  store ptr %927, ptr %exn.slot, align 8
  %928 = extractvalue { ptr, i32 } %926, 1
  store i32 %928, ptr %ehselector.slot, align 4
  br label %ehcleanup2200

lpad2144:                                         ; preds = %invoke.cont2145, %invoke.cont2142
  %929 = landingpad { ptr, i32 }
          cleanup
  %930 = extractvalue { ptr, i32 } %929, 0
  store ptr %930, ptr %exn.slot, align 8
  %931 = extractvalue { ptr, i32 } %929, 1
  store i32 %931, ptr %ehselector.slot, align 4
  br label %ehcleanup2199

lpad2149:                                         ; preds = %invoke.cont2150, %invoke.cont2147
  %932 = landingpad { ptr, i32 }
          cleanup
  %933 = extractvalue { ptr, i32 } %932, 0
  store ptr %933, ptr %exn.slot, align 8
  %934 = extractvalue { ptr, i32 } %932, 1
  store i32 %934, ptr %ehselector.slot, align 4
  br label %ehcleanup2198

lpad2155:                                         ; preds = %invoke.cont2159, %if.end2157, %if.then2154
  %935 = landingpad { ptr, i32 }
          cleanup
  %936 = extractvalue { ptr, i32 } %935, 0
  store ptr %936, ptr %exn.slot, align 8
  %937 = extractvalue { ptr, i32 } %935, 1
  store i32 %937, ptr %ehselector.slot, align 4
  br label %ehcleanup2197

if.end2157:                                       ; preds = %invoke.cont2156, %invoke.cont2152
  %938 = load i32, ptr %newContactCapacity, align 4
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp2158, i8 0, i64 112, i1 false)
  invoke void @_ZN20b3AlignedObjectArrayI10b3Contact4E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %hostContacts2151, i32 noundef %938, ptr noundef nonnull align 16 dereferenceable(112) %ref.tmp2158)
          to label %invoke.cont2159 unwind label %lpad2155

invoke.cont2159:                                  ; preds = %if.end2157
  invoke void @_ZN20b3AlignedObjectArrayI6b3Int4EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU2160)
          to label %invoke.cont2161 unwind label %lpad2155

invoke.cont2161:                                  ; preds = %invoke.cont2159
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB2CPU2162)
          to label %invoke.cont2164 unwind label %lpad2163

invoke.cont2164:                                  ; preds = %invoke.cont2161
  %939 = load ptr, ptr %clippingFacesOutGPU.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI6b3Int4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %939, ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU2160, i1 noundef zeroext true)
          to label %invoke.cont2166 unwind label %lpad2165

invoke.cont2166:                                  ; preds = %invoke.cont2164
  %940 = load ptr, ptr %worldVertsB2GPU.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %940, ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB2CPU2162, i1 noundef zeroext true)
          to label %invoke.cont2167 unwind label %lpad2165

invoke.cont2167:                                  ; preds = %invoke.cont2166
  store i32 0, ptr %i2168, align 4
  br label %for.cond2169

for.cond2169:                                     ; preds = %for.inc2187, %invoke.cont2167
  %941 = load i32, ptr %i2168, align 4
  %942 = load i32, ptr %numConcavePairs, align 4
  %cmp2170 = icmp slt i32 %941, %942
  br i1 %cmp2170, label %for.body2171, label %for.end2189

for.body2171:                                     ; preds = %for.cond2169
  %call2173 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI6b3Int4E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %triangleConvexPairsOutHost2133, i32 noundef 0)
          to label %invoke.cont2172 unwind label %lpad2165

invoke.cont2172:                                  ; preds = %for.body2171
  %call2175 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf2137, i32 noundef 0)
          to label %invoke.cont2174 unwind label %lpad2165

invoke.cont2174:                                  ; preds = %invoke.cont2172
  %call2177 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %concaveSepNormalsHost2146, i32 noundef 0)
          to label %invoke.cont2176 unwind label %lpad2165

invoke.cont2176:                                  ; preds = %invoke.cont2174
  %call2179 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %concaveHasSeparatingNormalsCPU2141, i32 noundef 0)
          to label %invoke.cont2178 unwind label %lpad2165

invoke.cont2178:                                  ; preds = %invoke.cont2176
  %call2181 = invoke noundef nonnull align 16 dereferenceable(112) ptr @_ZN20b3AlignedObjectArrayI10b3Contact4E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostContacts2151, i32 noundef 0)
          to label %invoke.cont2180 unwind label %lpad2165

invoke.cont2180:                                  ; preds = %invoke.cont2178
  %call2183 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI6b3Int4E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU2160, i32 noundef 0)
          to label %invoke.cont2182 unwind label %lpad2165

invoke.cont2182:                                  ; preds = %invoke.cont2180
  %call2185 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB2CPU2162, i32 noundef 0)
          to label %invoke.cont2184 unwind label %lpad2165

invoke.cont2184:                                  ; preds = %invoke.cont2182
  %943 = load i32, ptr %vertexFaceCapacity, align 4
  %944 = load i32, ptr %newContactCapacity, align 4
  %945 = load i32, ptr %numConcavePairs, align 4
  %946 = load i32, ptr %i2168, align 4
  invoke void @_Z27b3NewContactReductionKernelP6b3Int4PK15b3RigidBodyDataPK9b3Vector3PKiP14b3Contact4DataS0_PS4_PViiiii(ptr noundef %call2173, ptr noundef %call2175, ptr noundef %call2177, ptr noundef %call2179, ptr noundef %call2181, ptr noundef %call2183, ptr noundef %call2185, ptr noundef %nGlobalContactsOut2132, i32 noundef %943, i32 noundef %944, i32 noundef %945, i32 noundef %946)
          to label %invoke.cont2186 unwind label %lpad2165

invoke.cont2186:                                  ; preds = %invoke.cont2184
  br label %for.inc2187

for.inc2187:                                      ; preds = %invoke.cont2186
  %947 = load i32, ptr %i2168, align 4
  %inc2188 = add nsw i32 %947, 1
  store i32 %inc2188, ptr %i2168, align 4
  br label %for.cond2169, !llvm.loop !73

lpad2163:                                         ; preds = %invoke.cont2161
  %948 = landingpad { ptr, i32 }
          cleanup
  %949 = extractvalue { ptr, i32 } %948, 0
  store ptr %949, ptr %exn.slot, align 8
  %950 = extractvalue { ptr, i32 } %948, 1
  store i32 %950, ptr %ehselector.slot, align 4
  br label %ehcleanup2196

lpad2165:                                         ; preds = %invoke.cont2193, %invoke.cont2191, %for.end2189, %invoke.cont2184, %invoke.cont2182, %invoke.cont2180, %invoke.cont2178, %invoke.cont2176, %invoke.cont2174, %invoke.cont2172, %for.body2171, %invoke.cont2166, %invoke.cont2164
  %951 = landingpad { ptr, i32 }
          cleanup
  %952 = extractvalue { ptr, i32 } %951, 0
  store ptr %952, ptr %exn.slot, align 8
  %953 = extractvalue { ptr, i32 } %951, 1
  store i32 %953, ptr %ehselector.slot, align 4
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB2CPU2162) #13
  br label %ehcleanup2196

for.end2189:                                      ; preds = %for.cond2169
  %954 = load volatile i32, ptr %nGlobalContactsOut2132, align 4
  %955 = load ptr, ptr %nContacts.addr, align 8
  store i32 %954, ptr %955, align 4
  %m_totalContactsOut2190 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %956 = load ptr, ptr %nContacts.addr, align 8
  invoke void @_ZN13b3OpenCLArrayIiE19copyFromHostPointerEPKimmb(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut2190, ptr noundef %956, i64 noundef 1, i64 noundef 0, i1 noundef zeroext true)
          to label %invoke.cont2191 unwind label %lpad2165

invoke.cont2191:                                  ; preds = %for.end2189
  %957 = load ptr, ptr %nContacts.addr, align 8
  %958 = load i32, ptr %957, align 4
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp2192, i8 0, i64 112, i1 false)
  invoke void @_ZN20b3AlignedObjectArrayI10b3Contact4E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %hostContacts2151, i32 noundef %958, ptr noundef nonnull align 16 dereferenceable(112) %ref.tmp2192)
          to label %invoke.cont2193 unwind label %lpad2165

invoke.cont2193:                                  ; preds = %invoke.cont2191
  %959 = load ptr, ptr %contactOut.addr, align 8
  invoke void @_ZN13b3OpenCLArrayI10b3Contact4E12copyFromHostERK20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %959, ptr noundef nonnull align 8 dereferenceable(25) %hostContacts2151, i1 noundef zeroext true)
          to label %invoke.cont2194 unwind label %lpad2165

invoke.cont2194:                                  ; preds = %invoke.cont2193
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB2CPU2162) #13
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU2160) #13
  call void @_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostContacts2151) #13
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %concaveSepNormalsHost2146) #13
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %concaveHasSeparatingNormalsCPU2141) #13
  call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf2137) #13
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %triangleConvexPairsOutHost2133) #13
  br label %if.end2202

ehcleanup2196:                                    ; preds = %lpad2165, %lpad2163
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU2160) #13
  br label %ehcleanup2197

ehcleanup2197:                                    ; preds = %ehcleanup2196, %lpad2155
  call void @_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostContacts2151) #13
  br label %ehcleanup2198

ehcleanup2198:                                    ; preds = %ehcleanup2197, %lpad2149
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %concaveSepNormalsHost2146) #13
  br label %ehcleanup2199

ehcleanup2199:                                    ; preds = %ehcleanup2198, %lpad2144
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %concaveHasSeparatingNormalsCPU2141) #13
  br label %ehcleanup2200

ehcleanup2200:                                    ; preds = %ehcleanup2199, %lpad2139
  call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf2137) #13
  br label %ehcleanup2201

ehcleanup2201:                                    ; preds = %ehcleanup2200, %lpad2135
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %triangleConvexPairsOutHost2133) #13
  br label %ehcleanup2980

if.end2202:                                       ; preds = %invoke.cont2194, %invoke.cont2129
  br label %if.end2290

if.else2203:                                      ; preds = %if.then1943
  invoke void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %__profile2204, ptr noundef @.str.22)
          to label %invoke.cont2205 unwind label %lpad58

invoke.cont2205:                                  ; preds = %if.else2203
  %m_totalContactsOut2206 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %call2209 = invoke noundef i32 @_ZNK13b3OpenCLArrayIiE2atEm(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut2206, i64 noundef 0)
          to label %invoke.cont2208 unwind label %lpad2207

invoke.cont2208:                                  ; preds = %invoke.cont2205
  %960 = load ptr, ptr %nContacts.addr, align 8
  store i32 %call2209, ptr %960, align 4
  %961 = load ptr, ptr %contactOut.addr, align 8
  %call2212 = invoke noundef i64 @_ZNK13b3OpenCLArrayI10b3Contact4E8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %961)
          to label %invoke.cont2211 unwind label %lpad2207

invoke.cont2211:                                  ; preds = %invoke.cont2208
  %conv2213 = trunc i64 %call2212 to i32
  store i32 %conv2213, ptr %newContactCapacity2210, align 4
  %arrayinit.begin2215 = getelementptr inbounds [12 x %struct.b3BufferInfoCL], ptr %bInfo2214, i64 0, i64 0
  %962 = load ptr, ptr %triangleConvexPairsOut.addr, align 8
  %call2217 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %962)
          to label %invoke.cont2216 unwind label %lpad2207

invoke.cont2216:                                  ; preds = %invoke.cont2211
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.begin2215, ptr noundef %call2217, i1 noundef zeroext true)
          to label %invoke.cont2218 unwind label %lpad2207

invoke.cont2218:                                  ; preds = %invoke.cont2216
  %arrayinit.element2219 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.begin2215, i64 1
  %963 = load ptr, ptr %bodyBuf.addr, align 8
  %call2221 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %963)
          to label %invoke.cont2220 unwind label %lpad2207

invoke.cont2220:                                  ; preds = %invoke.cont2218
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2219, ptr noundef %call2221, i1 noundef zeroext true)
          to label %invoke.cont2222 unwind label %lpad2207

invoke.cont2222:                                  ; preds = %invoke.cont2220
  %arrayinit.element2223 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2219, i64 1
  %964 = load ptr, ptr %gpuCollidables.addr, align 8
  %call2225 = invoke noundef ptr @_ZNK13b3OpenCLArrayI12b3CollidableE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %964)
          to label %invoke.cont2224 unwind label %lpad2207

invoke.cont2224:                                  ; preds = %invoke.cont2222
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2223, ptr noundef %call2225, i1 noundef zeroext true)
          to label %invoke.cont2226 unwind label %lpad2207

invoke.cont2226:                                  ; preds = %invoke.cont2224
  %arrayinit.element2227 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2223, i64 1
  %965 = load ptr, ptr %convexData.addr, align 8
  %call2229 = invoke noundef ptr @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %965)
          to label %invoke.cont2228 unwind label %lpad2207

invoke.cont2228:                                  ; preds = %invoke.cont2226
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2227, ptr noundef %call2229, i1 noundef zeroext true)
          to label %invoke.cont2230 unwind label %lpad2207

invoke.cont2230:                                  ; preds = %invoke.cont2228
  %arrayinit.element2231 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2227, i64 1
  %966 = load ptr, ptr %gpuVertices.addr, align 8
  %call2233 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %966)
          to label %invoke.cont2232 unwind label %lpad2207

invoke.cont2232:                                  ; preds = %invoke.cont2230
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2231, ptr noundef %call2233, i1 noundef zeroext true)
          to label %invoke.cont2234 unwind label %lpad2207

invoke.cont2234:                                  ; preds = %invoke.cont2232
  %arrayinit.element2235 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2231, i64 1
  %967 = load ptr, ptr %gpuUniqueEdges.addr, align 8
  %call2237 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %967)
          to label %invoke.cont2236 unwind label %lpad2207

invoke.cont2236:                                  ; preds = %invoke.cont2234
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2235, ptr noundef %call2237, i1 noundef zeroext true)
          to label %invoke.cont2238 unwind label %lpad2207

invoke.cont2238:                                  ; preds = %invoke.cont2236
  %arrayinit.element2239 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2235, i64 1
  %968 = load ptr, ptr %gpuFaces.addr, align 8
  %call2241 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3GpuFaceE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %968)
          to label %invoke.cont2240 unwind label %lpad2207

invoke.cont2240:                                  ; preds = %invoke.cont2238
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2239, ptr noundef %call2241, i1 noundef zeroext true)
          to label %invoke.cont2242 unwind label %lpad2207

invoke.cont2242:                                  ; preds = %invoke.cont2240
  %arrayinit.element2243 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2239, i64 1
  %969 = load ptr, ptr %gpuIndices.addr, align 8
  %call2245 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %969)
          to label %invoke.cont2244 unwind label %lpad2207

invoke.cont2244:                                  ; preds = %invoke.cont2242
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2243, ptr noundef %call2245, i1 noundef zeroext true)
          to label %invoke.cont2246 unwind label %lpad2207

invoke.cont2246:                                  ; preds = %invoke.cont2244
  %arrayinit.element2247 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2243, i64 1
  %970 = load ptr, ptr %gpuChildShapes.addr, align 8
  %call2249 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3GpuChildShapeE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %970)
          to label %invoke.cont2248 unwind label %lpad2207

invoke.cont2248:                                  ; preds = %invoke.cont2246
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2247, ptr noundef %call2249, i1 noundef zeroext true)
          to label %invoke.cont2250 unwind label %lpad2207

invoke.cont2250:                                  ; preds = %invoke.cont2248
  %arrayinit.element2251 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2247, i64 1
  %m_concaveSepNormals2252 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 29
  %call2254 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveSepNormals2252)
          to label %invoke.cont2253 unwind label %lpad2207

invoke.cont2253:                                  ; preds = %invoke.cont2250
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2251, ptr noundef %call2254, i1 noundef zeroext false)
          to label %invoke.cont2255 unwind label %lpad2207

invoke.cont2255:                                  ; preds = %invoke.cont2253
  %arrayinit.element2256 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2251, i64 1
  %971 = load ptr, ptr %contactOut.addr, align 8
  %call2258 = invoke noundef ptr @_ZNK13b3OpenCLArrayI10b3Contact4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %971)
          to label %invoke.cont2257 unwind label %lpad2207

invoke.cont2257:                                  ; preds = %invoke.cont2255
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2256, ptr noundef %call2258, i1 noundef zeroext false)
          to label %invoke.cont2259 unwind label %lpad2207

invoke.cont2259:                                  ; preds = %invoke.cont2257
  %arrayinit.element2260 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2256, i64 1
  %m_totalContactsOut2261 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %call2263 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut2261)
          to label %invoke.cont2262 unwind label %lpad2207

invoke.cont2262:                                  ; preds = %invoke.cont2259
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2260, ptr noundef %call2263, i1 noundef zeroext false)
          to label %invoke.cont2264 unwind label %lpad2207

invoke.cont2264:                                  ; preds = %invoke.cont2262
  %m_queue2266 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %972 = load ptr, ptr %m_queue2266, align 8
  %m_clipHullHullConcaveConvexKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 18
  %973 = load ptr, ptr %m_clipHullHullConcaveConvexKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher2265, ptr noundef %972, ptr noundef %973, ptr noundef @.str.61)
          to label %invoke.cont2267 unwind label %lpad2207

invoke.cont2267:                                  ; preds = %invoke.cont2264
  %arraydecay2268 = getelementptr inbounds [12 x %struct.b3BufferInfoCL], ptr %bInfo2214, i64 0, i64 0
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher2265, ptr noundef %arraydecay2268, i32 noundef 12)
          to label %invoke.cont2270 unwind label %lpad2269

invoke.cont2270:                                  ; preds = %invoke.cont2267
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher2265, ptr noundef nonnull align 4 dereferenceable(4) %newContactCapacity2210)
          to label %invoke.cont2271 unwind label %lpad2269

invoke.cont2271:                                  ; preds = %invoke.cont2270
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher2265, ptr noundef nonnull align 4 dereferenceable(4) %numConcavePairs)
          to label %invoke.cont2272 unwind label %lpad2269

invoke.cont2272:                                  ; preds = %invoke.cont2271
  %974 = load i32, ptr %numConcavePairs, align 4
  store i32 %974, ptr %num2273, align 4
  %975 = load i32, ptr %num2273, align 4
  invoke void @_ZN12b3LauncherCL8launch1DEii(ptr noundef nonnull align 8 dereferenceable(112) %launcher2265, i32 noundef %975, i32 noundef 64)
          to label %invoke.cont2274 unwind label %lpad2269

invoke.cont2274:                                  ; preds = %invoke.cont2272
  %976 = load ptr, ptr @__clewFinish, align 8
  %m_queue2275 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %977 = load ptr, ptr %m_queue2275, align 8
  %call2277 = invoke i32 %976(ptr noundef %977)
          to label %invoke.cont2276 unwind label %lpad2269

invoke.cont2276:                                  ; preds = %invoke.cont2274
  %m_totalContactsOut2278 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %call2280 = invoke noundef i32 @_ZNK13b3OpenCLArrayIiE2atEm(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut2278, i64 noundef 0)
          to label %invoke.cont2279 unwind label %lpad2269

invoke.cont2279:                                  ; preds = %invoke.cont2276
  %978 = load ptr, ptr %nContacts.addr, align 8
  store i32 %call2280, ptr %978, align 4
  %979 = load ptr, ptr %contactOut.addr, align 8
  %980 = load ptr, ptr %nContacts.addr, align 8
  %981 = load i32, ptr %980, align 4
  %conv2281 = sext i32 %981 to i64
  %call2283 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI10b3Contact4E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %979, i64 noundef %conv2281, i1 noundef zeroext true)
          to label %invoke.cont2282 unwind label %lpad2269

invoke.cont2282:                                  ; preds = %invoke.cont2279
  invoke void @_ZN20b3AlignedObjectArrayI10b3Contact4EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuContacts)
          to label %invoke.cont2284 unwind label %lpad2269

invoke.cont2284:                                  ; preds = %invoke.cont2282
  %982 = load ptr, ptr %contactOut.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI10b3Contact4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %982, ptr noundef nonnull align 8 dereferenceable(25) %cpuContacts, i1 noundef zeroext true)
          to label %invoke.cont2286 unwind label %lpad2285

invoke.cont2286:                                  ; preds = %invoke.cont2284
  call void @_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuContacts) #13
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher2265) #13
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile2204) #13
  br label %if.end2290

lpad2207:                                         ; preds = %invoke.cont2264, %invoke.cont2262, %invoke.cont2259, %invoke.cont2257, %invoke.cont2255, %invoke.cont2253, %invoke.cont2250, %invoke.cont2248, %invoke.cont2246, %invoke.cont2244, %invoke.cont2242, %invoke.cont2240, %invoke.cont2238, %invoke.cont2236, %invoke.cont2234, %invoke.cont2232, %invoke.cont2230, %invoke.cont2228, %invoke.cont2226, %invoke.cont2224, %invoke.cont2222, %invoke.cont2220, %invoke.cont2218, %invoke.cont2216, %invoke.cont2211, %invoke.cont2208, %invoke.cont2205
  %983 = landingpad { ptr, i32 }
          cleanup
  %984 = extractvalue { ptr, i32 } %983, 0
  store ptr %984, ptr %exn.slot, align 8
  %985 = extractvalue { ptr, i32 } %983, 1
  store i32 %985, ptr %ehselector.slot, align 4
  br label %ehcleanup2289

lpad2269:                                         ; preds = %invoke.cont2282, %invoke.cont2279, %invoke.cont2276, %invoke.cont2274, %invoke.cont2272, %invoke.cont2271, %invoke.cont2270, %invoke.cont2267
  %986 = landingpad { ptr, i32 }
          cleanup
  %987 = extractvalue { ptr, i32 } %986, 0
  store ptr %987, ptr %exn.slot, align 8
  %988 = extractvalue { ptr, i32 } %986, 1
  store i32 %988, ptr %ehselector.slot, align 4
  br label %ehcleanup2288

lpad2285:                                         ; preds = %invoke.cont2284
  %989 = landingpad { ptr, i32 }
          cleanup
  %990 = extractvalue { ptr, i32 } %989, 0
  store ptr %990, ptr %exn.slot, align 8
  %991 = extractvalue { ptr, i32 } %989, 1
  store i32 %991, ptr %ehselector.slot, align 4
  call void @_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuContacts) #13
  br label %ehcleanup2288

ehcleanup2288:                                    ; preds = %lpad2285, %lpad2269
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher2265) #13
  br label %ehcleanup2289

ehcleanup2289:                                    ; preds = %ehcleanup2288, %lpad2207
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile2204) #13
  br label %ehcleanup2980

if.end2290:                                       ; preds = %invoke.cont2286, %if.end2202
  br label %if.end2291

if.end2291:                                       ; preds = %if.end2290, %invoke.cont1941
  store i8 0, ptr %breakupKernel, align 1
  store i8 1, ptr %computeConvexConvex, align 1
  %992 = load i8, ptr %computeConvexConvex, align 1
  %tobool2292 = trunc i8 %992 to i1
  br i1 %tobool2292, label %if.then2293, label %if.end2978

if.then2293:                                      ; preds = %if.end2291
  invoke void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %__profile2294, ptr noundef @.str.18)
          to label %invoke.cont2295 unwind label %lpad58

invoke.cont2295:                                  ; preds = %if.then2293
  %993 = load i8, ptr %breakupKernel, align 1
  %tobool2296 = trunc i8 %993 to i1
  br i1 %tobool2296, label %if.then2297, label %if.else2800

if.then2297:                                      ; preds = %invoke.cont2295
  %994 = load ptr, ptr %worldVertsB1GPU.addr, align 8
  %995 = load i32, ptr %vertexFaceCapacity, align 4
  %996 = load i32, ptr %nPairs.addr, align 4
  %mul2298 = mul nsw i32 %995, %996
  %conv2299 = sext i32 %mul2298 to i64
  %call2302 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %994, i64 noundef %conv2299, i1 noundef zeroext true)
          to label %invoke.cont2301 unwind label %lpad2300

invoke.cont2301:                                  ; preds = %if.then2297
  %997 = load ptr, ptr %clippingFacesOutGPU.addr, align 8
  %998 = load i32, ptr %nPairs.addr, align 4
  %conv2303 = sext i32 %998 to i64
  %call2305 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI6b3Int4E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %997, i64 noundef %conv2303, i1 noundef zeroext true)
          to label %invoke.cont2304 unwind label %lpad2300

invoke.cont2304:                                  ; preds = %invoke.cont2301
  %999 = load ptr, ptr %worldNormalsAGPU.addr, align 8
  %1000 = load i32, ptr %nPairs.addr, align 4
  %conv2306 = sext i32 %1000 to i64
  %call2308 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %999, i64 noundef %conv2306, i1 noundef zeroext true)
          to label %invoke.cont2307 unwind label %lpad2300

invoke.cont2307:                                  ; preds = %invoke.cont2304
  %1001 = load ptr, ptr %worldVertsA1GPU.addr, align 8
  %1002 = load i32, ptr %vertexFaceCapacity, align 4
  %1003 = load i32, ptr %nPairs.addr, align 4
  %mul2309 = mul nsw i32 %1002, %1003
  %conv2310 = sext i32 %mul2309 to i64
  %call2312 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %1001, i64 noundef %conv2310, i1 noundef zeroext true)
          to label %invoke.cont2311 unwind label %lpad2300

invoke.cont2311:                                  ; preds = %invoke.cont2307
  %1004 = load ptr, ptr %worldVertsB2GPU.addr, align 8
  %1005 = load i32, ptr %vertexFaceCapacity, align 4
  %1006 = load i32, ptr %nPairs.addr, align 4
  %mul2313 = mul nsw i32 %1005, %1006
  %conv2314 = sext i32 %mul2313 to i64
  %call2316 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %1004, i64 noundef %conv2314, i1 noundef zeroext true)
          to label %invoke.cont2315 unwind label %lpad2300

invoke.cont2315:                                  ; preds = %invoke.cont2311
  %1007 = load i8, ptr @findConvexClippingFacesGPU, align 1
  %tobool2317 = trunc i8 %1007 to i1
  br i1 %tobool2317, label %if.then2318, label %if.else2396

if.then2318:                                      ; preds = %invoke.cont2315
  invoke void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %__profile2319, ptr noundef @.str.20)
          to label %invoke.cont2320 unwind label %lpad2300

invoke.cont2320:                                  ; preds = %if.then2318
  %arrayinit.begin2322 = getelementptr inbounds [14 x %struct.b3BufferInfoCL], ptr %bInfo2321, i64 0, i64 0
  %1008 = load ptr, ptr %pairs.addr, align 8
  %call2325 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1008)
          to label %invoke.cont2324 unwind label %lpad2323

invoke.cont2324:                                  ; preds = %invoke.cont2320
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.begin2322, ptr noundef %call2325, i1 noundef zeroext true)
          to label %invoke.cont2326 unwind label %lpad2323

invoke.cont2326:                                  ; preds = %invoke.cont2324
  %arrayinit.element2327 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.begin2322, i64 1
  %1009 = load ptr, ptr %bodyBuf.addr, align 8
  %call2329 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1009)
          to label %invoke.cont2328 unwind label %lpad2323

invoke.cont2328:                                  ; preds = %invoke.cont2326
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2327, ptr noundef %call2329, i1 noundef zeroext true)
          to label %invoke.cont2330 unwind label %lpad2323

invoke.cont2330:                                  ; preds = %invoke.cont2328
  %arrayinit.element2331 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2327, i64 1
  %1010 = load ptr, ptr %gpuCollidables.addr, align 8
  %call2333 = invoke noundef ptr @_ZNK13b3OpenCLArrayI12b3CollidableE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1010)
          to label %invoke.cont2332 unwind label %lpad2323

invoke.cont2332:                                  ; preds = %invoke.cont2330
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2331, ptr noundef %call2333, i1 noundef zeroext true)
          to label %invoke.cont2334 unwind label %lpad2323

invoke.cont2334:                                  ; preds = %invoke.cont2332
  %arrayinit.element2335 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2331, i64 1
  %1011 = load ptr, ptr %convexData.addr, align 8
  %call2337 = invoke noundef ptr @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1011)
          to label %invoke.cont2336 unwind label %lpad2323

invoke.cont2336:                                  ; preds = %invoke.cont2334
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2335, ptr noundef %call2337, i1 noundef zeroext true)
          to label %invoke.cont2338 unwind label %lpad2323

invoke.cont2338:                                  ; preds = %invoke.cont2336
  %arrayinit.element2339 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2335, i64 1
  %1012 = load ptr, ptr %gpuVertices.addr, align 8
  %call2341 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1012)
          to label %invoke.cont2340 unwind label %lpad2323

invoke.cont2340:                                  ; preds = %invoke.cont2338
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2339, ptr noundef %call2341, i1 noundef zeroext true)
          to label %invoke.cont2342 unwind label %lpad2323

invoke.cont2342:                                  ; preds = %invoke.cont2340
  %arrayinit.element2343 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2339, i64 1
  %1013 = load ptr, ptr %gpuUniqueEdges.addr, align 8
  %call2345 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1013)
          to label %invoke.cont2344 unwind label %lpad2323

invoke.cont2344:                                  ; preds = %invoke.cont2342
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2343, ptr noundef %call2345, i1 noundef zeroext true)
          to label %invoke.cont2346 unwind label %lpad2323

invoke.cont2346:                                  ; preds = %invoke.cont2344
  %arrayinit.element2347 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2343, i64 1
  %1014 = load ptr, ptr %gpuFaces.addr, align 8
  %call2349 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3GpuFaceE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1014)
          to label %invoke.cont2348 unwind label %lpad2323

invoke.cont2348:                                  ; preds = %invoke.cont2346
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2347, ptr noundef %call2349, i1 noundef zeroext true)
          to label %invoke.cont2350 unwind label %lpad2323

invoke.cont2350:                                  ; preds = %invoke.cont2348
  %arrayinit.element2351 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2347, i64 1
  %1015 = load ptr, ptr %gpuIndices.addr, align 8
  %call2353 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1015)
          to label %invoke.cont2352 unwind label %lpad2323

invoke.cont2352:                                  ; preds = %invoke.cont2350
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2351, ptr noundef %call2353, i1 noundef zeroext true)
          to label %invoke.cont2354 unwind label %lpad2323

invoke.cont2354:                                  ; preds = %invoke.cont2352
  %arrayinit.element2355 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2351, i64 1
  %m_sepNormals2356 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 26
  %call2358 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_sepNormals2356)
          to label %invoke.cont2357 unwind label %lpad2323

invoke.cont2357:                                  ; preds = %invoke.cont2354
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2355, ptr noundef %call2358, i1 noundef zeroext false)
          to label %invoke.cont2359 unwind label %lpad2323

invoke.cont2359:                                  ; preds = %invoke.cont2357
  %arrayinit.element2360 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2355, i64 1
  %m_hasSeparatingNormals2361 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 28
  %call2363 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_hasSeparatingNormals2361)
          to label %invoke.cont2362 unwind label %lpad2323

invoke.cont2362:                                  ; preds = %invoke.cont2359
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2360, ptr noundef %call2363, i1 noundef zeroext false)
          to label %invoke.cont2364 unwind label %lpad2323

invoke.cont2364:                                  ; preds = %invoke.cont2362
  %arrayinit.element2365 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2360, i64 1
  %1016 = load ptr, ptr %clippingFacesOutGPU.addr, align 8
  %call2367 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1016)
          to label %invoke.cont2366 unwind label %lpad2323

invoke.cont2366:                                  ; preds = %invoke.cont2364
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2365, ptr noundef %call2367, i1 noundef zeroext false)
          to label %invoke.cont2368 unwind label %lpad2323

invoke.cont2368:                                  ; preds = %invoke.cont2366
  %arrayinit.element2369 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2365, i64 1
  %1017 = load ptr, ptr %worldVertsA1GPU.addr, align 8
  %call2371 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1017)
          to label %invoke.cont2370 unwind label %lpad2323

invoke.cont2370:                                  ; preds = %invoke.cont2368
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2369, ptr noundef %call2371, i1 noundef zeroext false)
          to label %invoke.cont2372 unwind label %lpad2323

invoke.cont2372:                                  ; preds = %invoke.cont2370
  %arrayinit.element2373 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2369, i64 1
  %1018 = load ptr, ptr %worldNormalsAGPU.addr, align 8
  %call2375 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1018)
          to label %invoke.cont2374 unwind label %lpad2323

invoke.cont2374:                                  ; preds = %invoke.cont2372
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2373, ptr noundef %call2375, i1 noundef zeroext false)
          to label %invoke.cont2376 unwind label %lpad2323

invoke.cont2376:                                  ; preds = %invoke.cont2374
  %arrayinit.element2377 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2373, i64 1
  %1019 = load ptr, ptr %worldVertsB1GPU.addr, align 8
  %call2379 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1019)
          to label %invoke.cont2378 unwind label %lpad2323

invoke.cont2378:                                  ; preds = %invoke.cont2376
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2377, ptr noundef %call2379, i1 noundef zeroext false)
          to label %invoke.cont2380 unwind label %lpad2323

invoke.cont2380:                                  ; preds = %invoke.cont2378
  %m_queue2382 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %1020 = load ptr, ptr %m_queue2382, align 8
  %m_findClippingFacesKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 17
  %1021 = load ptr, ptr %m_findClippingFacesKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher2381, ptr noundef %1020, ptr noundef %1021, ptr noundef @.str.62)
          to label %invoke.cont2383 unwind label %lpad2323

invoke.cont2383:                                  ; preds = %invoke.cont2380
  %arraydecay2384 = getelementptr inbounds [14 x %struct.b3BufferInfoCL], ptr %bInfo2321, i64 0, i64 0
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher2381, ptr noundef %arraydecay2384, i32 noundef 14)
          to label %invoke.cont2386 unwind label %lpad2385

invoke.cont2386:                                  ; preds = %invoke.cont2383
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher2381, ptr noundef nonnull align 4 dereferenceable(4) %vertexFaceCapacity)
          to label %invoke.cont2387 unwind label %lpad2385

invoke.cont2387:                                  ; preds = %invoke.cont2386
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher2381, ptr noundef nonnull align 4 dereferenceable(4) %nPairs.addr)
          to label %invoke.cont2388 unwind label %lpad2385

invoke.cont2388:                                  ; preds = %invoke.cont2387
  %1022 = load i32, ptr %nPairs.addr, align 4
  store i32 %1022, ptr %num2389, align 4
  %1023 = load i32, ptr %num2389, align 4
  invoke void @_ZN12b3LauncherCL8launch1DEii(ptr noundef nonnull align 8 dereferenceable(112) %launcher2381, i32 noundef %1023, i32 noundef 64)
          to label %invoke.cont2390 unwind label %lpad2385

invoke.cont2390:                                  ; preds = %invoke.cont2388
  %1024 = load ptr, ptr @__clewFinish, align 8
  %m_queue2391 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %1025 = load ptr, ptr %m_queue2391, align 8
  %call2393 = invoke i32 %1024(ptr noundef %1025)
          to label %invoke.cont2392 unwind label %lpad2385

invoke.cont2392:                                  ; preds = %invoke.cont2390
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher2381) #13
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile2319) #13
  br label %if.end2545

lpad2300:                                         ; preds = %invoke.cont2947, %invoke.cont2945, %invoke.cont2942, %invoke.cont2940, %invoke.cont2938, %invoke.cont2936, %invoke.cont2933, %invoke.cont2931, %invoke.cont2928, %invoke.cont2926, %invoke.cont2924, %invoke.cont2922, %invoke.cont2920, %invoke.cont2918, %invoke.cont2916, %invoke.cont2914, %invoke.cont2912, %invoke.cont2910, %invoke.cont2908, %invoke.cont2906, %invoke.cont2904, %invoke.cont2902, %invoke.cont2900, %invoke.cont2898, %invoke.cont2896, %invoke.cont2894, %if.then2890, %if.end2884, %invoke.cont2854, %invoke.cont2852, %invoke.cont2849, %invoke.cont2847, %invoke.cont2845, %invoke.cont2843, %invoke.cont2840, %invoke.cont2838, %invoke.cont2835, %invoke.cont2833, %invoke.cont2831, %invoke.cont2829, %invoke.cont2827, %invoke.cont2825, %invoke.cont2823, %invoke.cont2821, %invoke.cont2819, %invoke.cont2817, %invoke.cont2815, %invoke.cont2813, %invoke.cont2811, %invoke.cont2809, %invoke.cont2807, %invoke.cont2805, %if.then2802, %if.else2732, %invoke.cont2727, %invoke.cont2723, %if.then2672, %invoke.cont2664, %if.end2662, %if.else2609, %if.then2547, %if.else2396, %if.then2318, %invoke.cont2311, %invoke.cont2307, %invoke.cont2304, %invoke.cont2301, %if.then2297
  %1026 = landingpad { ptr, i32 }
          cleanup
  %1027 = extractvalue { ptr, i32 } %1026, 0
  store ptr %1027, ptr %exn.slot, align 8
  %1028 = extractvalue { ptr, i32 } %1026, 1
  store i32 %1028, ptr %ehselector.slot, align 4
  br label %ehcleanup2977

lpad2323:                                         ; preds = %invoke.cont2380, %invoke.cont2378, %invoke.cont2376, %invoke.cont2374, %invoke.cont2372, %invoke.cont2370, %invoke.cont2368, %invoke.cont2366, %invoke.cont2364, %invoke.cont2362, %invoke.cont2359, %invoke.cont2357, %invoke.cont2354, %invoke.cont2352, %invoke.cont2350, %invoke.cont2348, %invoke.cont2346, %invoke.cont2344, %invoke.cont2342, %invoke.cont2340, %invoke.cont2338, %invoke.cont2336, %invoke.cont2334, %invoke.cont2332, %invoke.cont2330, %invoke.cont2328, %invoke.cont2326, %invoke.cont2324, %invoke.cont2320
  %1029 = landingpad { ptr, i32 }
          cleanup
  %1030 = extractvalue { ptr, i32 } %1029, 0
  store ptr %1030, ptr %exn.slot, align 8
  %1031 = extractvalue { ptr, i32 } %1029, 1
  store i32 %1031, ptr %ehselector.slot, align 4
  br label %ehcleanup2395

lpad2385:                                         ; preds = %invoke.cont2390, %invoke.cont2388, %invoke.cont2387, %invoke.cont2386, %invoke.cont2383
  %1032 = landingpad { ptr, i32 }
          cleanup
  %1033 = extractvalue { ptr, i32 } %1032, 0
  store ptr %1033, ptr %exn.slot, align 8
  %1034 = extractvalue { ptr, i32 } %1032, 1
  store i32 %1034, ptr %ehselector.slot, align 4
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher2381) #13
  br label %ehcleanup2395

ehcleanup2395:                                    ; preds = %lpad2385, %lpad2323
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile2319) #13
  br label %ehcleanup2977

if.else2396:                                      ; preds = %invoke.cont2315
  store float 0xC6293E5940000000, ptr %minDist, align 4
  store float 0x3F947AE140000000, ptr %maxDist, align 4
  invoke void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexData2397)
          to label %invoke.cont2398 unwind label %lpad2300

invoke.cont2398:                                  ; preds = %if.else2396
  %1035 = load ptr, ptr %convexData.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %1035, ptr noundef nonnull align 8 dereferenceable(25) %hostConvexData2397, i1 noundef zeroext true)
          to label %invoke.cont2400 unwind label %lpad2399

invoke.cont2400:                                  ; preds = %invoke.cont2398
  invoke void @_ZN20b3AlignedObjectArrayI12b3CollidableEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables2401)
          to label %invoke.cont2402 unwind label %lpad2399

invoke.cont2402:                                  ; preds = %invoke.cont2400
  %1036 = load ptr, ptr %gpuCollidables.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI12b3CollidableE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %1036, ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables2401, i1 noundef zeroext true)
          to label %invoke.cont2404 unwind label %lpad2403

invoke.cont2404:                                  ; preds = %invoke.cont2402
  invoke void @_ZN20b3AlignedObjectArrayIiEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostHasSepNormals)
          to label %invoke.cont2405 unwind label %lpad2403

invoke.cont2405:                                  ; preds = %invoke.cont2404
  %m_hasSeparatingNormals2406 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 28
  invoke void @_ZNK13b3OpenCLArrayIiE10copyToHostER20b3AlignedObjectArrayIiEb(ptr noundef nonnull align 8 dereferenceable(50) %m_hasSeparatingNormals2406, ptr noundef nonnull align 8 dereferenceable(25) %hostHasSepNormals, i1 noundef zeroext true)
          to label %invoke.cont2408 unwind label %lpad2407

invoke.cont2408:                                  ; preds = %invoke.cont2405
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuSepNormals)
          to label %invoke.cont2409 unwind label %lpad2407

invoke.cont2409:                                  ; preds = %invoke.cont2408
  %m_sepNormals2410 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 26
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %m_sepNormals2410, ptr noundef nonnull align 8 dereferenceable(25) %cpuSepNormals, i1 noundef zeroext true)
          to label %invoke.cont2412 unwind label %lpad2411

invoke.cont2412:                                  ; preds = %invoke.cont2409
  invoke void @_ZN20b3AlignedObjectArrayI6b3Int4EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostPairs2413)
          to label %invoke.cont2414 unwind label %lpad2411

invoke.cont2414:                                  ; preds = %invoke.cont2412
  %1037 = load ptr, ptr %pairs.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI6b3Int4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %1037, ptr noundef nonnull align 8 dereferenceable(25) %hostPairs2413, i1 noundef zeroext true)
          to label %invoke.cont2416 unwind label %lpad2415

invoke.cont2416:                                  ; preds = %invoke.cont2414
  invoke void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf2417)
          to label %invoke.cont2418 unwind label %lpad2415

invoke.cont2418:                                  ; preds = %invoke.cont2416
  %1038 = load ptr, ptr %bodyBuf.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %1038, ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf2417, i1 noundef zeroext true)
          to label %invoke.cont2420 unwind label %lpad2419

invoke.cont2420:                                  ; preds = %invoke.cont2418
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB1CPU2421)
          to label %invoke.cont2422 unwind label %lpad2419

invoke.cont2422:                                  ; preds = %invoke.cont2420
  %1039 = load ptr, ptr %worldVertsB1GPU.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %1039, ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB1CPU2421, i1 noundef zeroext true)
          to label %invoke.cont2424 unwind label %lpad2423

invoke.cont2424:                                  ; preds = %invoke.cont2422
  invoke void @_ZN20b3AlignedObjectArrayI6b3Int4EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU2425)
          to label %invoke.cont2426 unwind label %lpad2423

invoke.cont2426:                                  ; preds = %invoke.cont2424
  %1040 = load ptr, ptr %clippingFacesOutGPU.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI6b3Int4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %1040, ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU2425, i1 noundef zeroext true)
          to label %invoke.cont2428 unwind label %lpad2427

invoke.cont2428:                                  ; preds = %invoke.cont2426
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldNormalsACPU2429)
          to label %invoke.cont2430 unwind label %lpad2427

invoke.cont2430:                                  ; preds = %invoke.cont2428
  %1041 = load i32, ptr %nPairs.addr, align 4
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp2431, i8 0, i64 16, i1 false)
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %worldNormalsACPU2429, i32 noundef %1041, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp2431)
          to label %invoke.cont2433 unwind label %lpad2432

invoke.cont2433:                                  ; preds = %invoke.cont2430
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsA1CPU2434)
          to label %invoke.cont2435 unwind label %lpad2432

invoke.cont2435:                                  ; preds = %invoke.cont2433
  %1042 = load ptr, ptr %worldVertsA1GPU.addr, align 8
  %call2438 = invoke noundef i64 @_ZNK13b3OpenCLArrayI9b3Vector3E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %1042)
          to label %invoke.cont2437 unwind label %lpad2436

invoke.cont2437:                                  ; preds = %invoke.cont2435
  %conv2439 = trunc i64 %call2438 to i32
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp2440, i8 0, i64 16, i1 false)
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsA1CPU2434, i32 noundef %conv2439, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp2440)
          to label %invoke.cont2441 unwind label %lpad2436

invoke.cont2441:                                  ; preds = %invoke.cont2437
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices2442)
          to label %invoke.cont2443 unwind label %lpad2436

invoke.cont2443:                                  ; preds = %invoke.cont2441
  %1043 = load ptr, ptr %gpuVertices.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %1043, ptr noundef nonnull align 8 dereferenceable(25) %hostVertices2442, i1 noundef zeroext true)
          to label %invoke.cont2445 unwind label %lpad2444

invoke.cont2445:                                  ; preds = %invoke.cont2443
  invoke void @_ZN20b3AlignedObjectArrayI9b3GpuFaceEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostFaces2446)
          to label %invoke.cont2447 unwind label %lpad2444

invoke.cont2447:                                  ; preds = %invoke.cont2445
  %1044 = load ptr, ptr %gpuFaces.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3GpuFaceE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %1044, ptr noundef nonnull align 8 dereferenceable(25) %hostFaces2446, i1 noundef zeroext true)
          to label %invoke.cont2449 unwind label %lpad2448

invoke.cont2449:                                  ; preds = %invoke.cont2447
  invoke void @_ZN20b3AlignedObjectArrayIiEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostIndices2450)
          to label %invoke.cont2451 unwind label %lpad2448

invoke.cont2451:                                  ; preds = %invoke.cont2449
  %1045 = load ptr, ptr %gpuIndices.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayIiE10copyToHostER20b3AlignedObjectArrayIiEb(ptr noundef nonnull align 8 dereferenceable(50) %1045, ptr noundef nonnull align 8 dereferenceable(25) %hostIndices2450, i1 noundef zeroext true)
          to label %invoke.cont2453 unwind label %lpad2452

invoke.cont2453:                                  ; preds = %invoke.cont2451
  store i32 0, ptr %i2454, align 4
  br label %for.cond2455

for.cond2455:                                     ; preds = %for.inc2525, %invoke.cont2453
  %1046 = load i32, ptr %i2454, align 4
  %1047 = load i32, ptr %nPairs.addr, align 4
  %cmp2456 = icmp slt i32 %1046, %1047
  br i1 %cmp2456, label %for.body2457, label %for.end2527

for.body2457:                                     ; preds = %for.cond2455
  %1048 = load i32, ptr %i2454, align 4
  %call2460 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI6b3Int4EixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostPairs2413, i32 noundef %1048)
          to label %invoke.cont2459 unwind label %lpad2452

invoke.cont2459:                                  ; preds = %for.body2457
  %1049 = getelementptr inbounds %struct.b3Int4, ptr %call2460, i32 0, i32 0
  %x2461 = getelementptr inbounds %struct.anon, ptr %1049, i32 0, i32 0
  %1050 = load i32, ptr %x2461, align 16
  store i32 %1050, ptr %bodyIndexA2458, align 4
  %1051 = load i32, ptr %i2454, align 4
  %call2464 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI6b3Int4EixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostPairs2413, i32 noundef %1051)
          to label %invoke.cont2463 unwind label %lpad2452

invoke.cont2463:                                  ; preds = %invoke.cont2459
  %1052 = getelementptr inbounds %struct.b3Int4, ptr %call2464, i32 0, i32 0
  %y2465 = getelementptr inbounds %struct.anon, ptr %1052, i32 0, i32 1
  %1053 = load i32, ptr %y2465, align 4
  store i32 %1053, ptr %bodyIndexB2462, align 4
  %1054 = load i32, ptr %bodyIndexA2458, align 4
  %call2468 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf2417, i32 noundef %1054)
          to label %invoke.cont2467 unwind label %lpad2452

invoke.cont2467:                                  ; preds = %invoke.cont2463
  %m_collidableIdx2469 = getelementptr inbounds %struct.b3RigidBodyData, ptr %call2468, i32 0, i32 4
  %1055 = load i32, ptr %m_collidableIdx2469, align 16
  store i32 %1055, ptr %collidableIndexA2466, align 4
  %1056 = load i32, ptr %bodyIndexB2462, align 4
  %call2472 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf2417, i32 noundef %1056)
          to label %invoke.cont2471 unwind label %lpad2452

invoke.cont2471:                                  ; preds = %invoke.cont2467
  %m_collidableIdx2473 = getelementptr inbounds %struct.b3RigidBodyData, ptr %call2472, i32 0, i32 4
  %1057 = load i32, ptr %m_collidableIdx2473, align 16
  store i32 %1057, ptr %collidableIndexB2470, align 4
  %1058 = load i32, ptr %collidableIndexA2466, align 4
  %call2476 = invoke noundef nonnull align 4 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI12b3CollidableEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables2401, i32 noundef %1058)
          to label %invoke.cont2475 unwind label %lpad2452

invoke.cont2475:                                  ; preds = %invoke.cont2471
  %1059 = getelementptr inbounds %struct.b3Collidable, ptr %call2476, i32 0, i32 3
  %1060 = load i32, ptr %1059, align 4
  store i32 %1060, ptr %shapeIndexA2474, align 4
  %1061 = load i32, ptr %collidableIndexB2470, align 4
  %call2479 = invoke noundef nonnull align 4 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI12b3CollidableEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables2401, i32 noundef %1061)
          to label %invoke.cont2478 unwind label %lpad2452

invoke.cont2478:                                  ; preds = %invoke.cont2475
  %1062 = getelementptr inbounds %struct.b3Collidable, ptr %call2479, i32 0, i32 3
  %1063 = load i32, ptr %1062, align 4
  store i32 %1063, ptr %shapeIndexB2477, align 4
  %1064 = load i32, ptr %i2454, align 4
  %call2481 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostHasSepNormals, i32 noundef %1064)
          to label %invoke.cont2480 unwind label %lpad2452

invoke.cont2480:                                  ; preds = %invoke.cont2478
  %1065 = load i32, ptr %call2481, align 4
  %tobool2482 = icmp ne i32 %1065, 0
  br i1 %tobool2482, label %if.then2483, label %if.end2524

if.then2483:                                      ; preds = %invoke.cont2480
  %1066 = load i32, ptr %i2454, align 4
  %call2485 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3EixEi(ptr noundef nonnull align 8 dereferenceable(25) %cpuSepNormals, i32 noundef %1066)
          to label %invoke.cont2484 unwind label %lpad2452

invoke.cont2484:                                  ; preds = %if.then2483
  %1067 = load i32, ptr %shapeIndexA2474, align 4
  %call2487 = invoke noundef nonnull align 16 dereferenceable(96) ptr @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexData2397, i32 noundef %1067)
          to label %invoke.cont2486 unwind label %lpad2452

invoke.cont2486:                                  ; preds = %invoke.cont2484
  %1068 = load i32, ptr %shapeIndexB2477, align 4
  %call2489 = invoke noundef nonnull align 16 dereferenceable(96) ptr @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexData2397, i32 noundef %1068)
          to label %invoke.cont2488 unwind label %lpad2452

invoke.cont2488:                                  ; preds = %invoke.cont2486
  %1069 = load i32, ptr %bodyIndexA2458, align 4
  %call2491 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf2417, i32 noundef %1069)
          to label %invoke.cont2490 unwind label %lpad2452

invoke.cont2490:                                  ; preds = %invoke.cont2488
  %m_pos2492 = getelementptr inbounds %struct.b3RigidBodyData, ptr %call2491, i32 0, i32 0
  %1070 = load i32, ptr %bodyIndexA2458, align 4
  %call2494 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf2417, i32 noundef %1070)
          to label %invoke.cont2493 unwind label %lpad2452

invoke.cont2493:                                  ; preds = %invoke.cont2490
  %m_quat2495 = getelementptr inbounds %struct.b3RigidBodyData, ptr %call2494, i32 0, i32 1
  %1071 = load i32, ptr %bodyIndexB2462, align 4
  %call2497 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf2417, i32 noundef %1071)
          to label %invoke.cont2496 unwind label %lpad2452

invoke.cont2496:                                  ; preds = %invoke.cont2493
  %m_pos2498 = getelementptr inbounds %struct.b3RigidBodyData, ptr %call2497, i32 0, i32 0
  %1072 = load i32, ptr %bodyIndexB2462, align 4
  %call2500 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf2417, i32 noundef %1072)
          to label %invoke.cont2499 unwind label %lpad2452

invoke.cont2499:                                  ; preds = %invoke.cont2496
  %m_quat2501 = getelementptr inbounds %struct.b3RigidBodyData, ptr %call2500, i32 0, i32 1
  %call2503 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsA1CPU2434, i32 noundef 0)
          to label %invoke.cont2502 unwind label %lpad2452

invoke.cont2502:                                  ; preds = %invoke.cont2499
  %call2505 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %worldNormalsACPU2429, i32 noundef 0)
          to label %invoke.cont2504 unwind label %lpad2452

invoke.cont2504:                                  ; preds = %invoke.cont2502
  %call2507 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB1CPU2421, i32 noundef 0)
          to label %invoke.cont2506 unwind label %lpad2452

invoke.cont2506:                                  ; preds = %invoke.cont2504
  %1073 = load i32, ptr %vertexFaceCapacity, align 4
  %1074 = load float, ptr %minDist, align 4
  %1075 = load float, ptr %maxDist, align 4
  %call2509 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices2442, i32 noundef 0)
          to label %invoke.cont2508 unwind label %lpad2452

invoke.cont2508:                                  ; preds = %invoke.cont2506
  %call2511 = invoke noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI9b3GpuFaceE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostFaces2446, i32 noundef 0)
          to label %invoke.cont2510 unwind label %lpad2452

invoke.cont2510:                                  ; preds = %invoke.cont2508
  %call2513 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostIndices2450, i32 noundef 0)
          to label %invoke.cont2512 unwind label %lpad2452

invoke.cont2512:                                  ; preds = %invoke.cont2510
  %call2515 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices2442, i32 noundef 0)
          to label %invoke.cont2514 unwind label %lpad2452

invoke.cont2514:                                  ; preds = %invoke.cont2512
  %call2517 = invoke noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI9b3GpuFaceE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostFaces2446, i32 noundef 0)
          to label %invoke.cont2516 unwind label %lpad2452

invoke.cont2516:                                  ; preds = %invoke.cont2514
  %call2519 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostIndices2450, i32 noundef 0)
          to label %invoke.cont2518 unwind label %lpad2452

invoke.cont2518:                                  ; preds = %invoke.cont2516
  %call2521 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI6b3Int4E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU2425, i32 noundef 0)
          to label %invoke.cont2520 unwind label %lpad2452

invoke.cont2520:                                  ; preds = %invoke.cont2518
  %1076 = load i32, ptr %i2454, align 4
  %call2523 = invoke noundef i32 @_Z19b3FindClippingFacesRK9b3Vector3PK22b3ConvexPolyhedronDataS4_S1_RK12b3QuaternionS1_S7_PS_S8_S8_iffPS0_PK9b3GpuFacePKiS9_SC_SE_P6b3Int4i(ptr noundef nonnull align 16 dereferenceable(16) %call2485, ptr noundef %call2487, ptr noundef %call2489, ptr noundef nonnull align 16 dereferenceable(16) %m_pos2492, ptr noundef nonnull align 16 dereferenceable(16) %m_quat2495, ptr noundef nonnull align 16 dereferenceable(16) %m_pos2498, ptr noundef nonnull align 16 dereferenceable(16) %m_quat2501, ptr noundef %call2503, ptr noundef %call2505, ptr noundef %call2507, i32 noundef %1073, float noundef %1074, float noundef %1075, ptr noundef %call2509, ptr noundef %call2511, ptr noundef %call2513, ptr noundef %call2515, ptr noundef %call2517, ptr noundef %call2519, ptr noundef %call2521, i32 noundef %1076)
          to label %invoke.cont2522 unwind label %lpad2452

invoke.cont2522:                                  ; preds = %invoke.cont2520
  br label %if.end2524

lpad2399:                                         ; preds = %invoke.cont2400, %invoke.cont2398
  %1077 = landingpad { ptr, i32 }
          cleanup
  %1078 = extractvalue { ptr, i32 } %1077, 0
  store ptr %1078, ptr %exn.slot, align 8
  %1079 = extractvalue { ptr, i32 } %1077, 1
  store i32 %1079, ptr %ehselector.slot, align 4
  br label %ehcleanup2544

lpad2403:                                         ; preds = %invoke.cont2404, %invoke.cont2402
  %1080 = landingpad { ptr, i32 }
          cleanup
  %1081 = extractvalue { ptr, i32 } %1080, 0
  store ptr %1081, ptr %exn.slot, align 8
  %1082 = extractvalue { ptr, i32 } %1080, 1
  store i32 %1082, ptr %ehselector.slot, align 4
  br label %ehcleanup2543

lpad2407:                                         ; preds = %invoke.cont2408, %invoke.cont2405
  %1083 = landingpad { ptr, i32 }
          cleanup
  %1084 = extractvalue { ptr, i32 } %1083, 0
  store ptr %1084, ptr %exn.slot, align 8
  %1085 = extractvalue { ptr, i32 } %1083, 1
  store i32 %1085, ptr %ehselector.slot, align 4
  br label %ehcleanup2542

lpad2411:                                         ; preds = %invoke.cont2412, %invoke.cont2409
  %1086 = landingpad { ptr, i32 }
          cleanup
  %1087 = extractvalue { ptr, i32 } %1086, 0
  store ptr %1087, ptr %exn.slot, align 8
  %1088 = extractvalue { ptr, i32 } %1086, 1
  store i32 %1088, ptr %ehselector.slot, align 4
  br label %ehcleanup2541

lpad2415:                                         ; preds = %invoke.cont2416, %invoke.cont2414
  %1089 = landingpad { ptr, i32 }
          cleanup
  %1090 = extractvalue { ptr, i32 } %1089, 0
  store ptr %1090, ptr %exn.slot, align 8
  %1091 = extractvalue { ptr, i32 } %1089, 1
  store i32 %1091, ptr %ehselector.slot, align 4
  br label %ehcleanup2540

lpad2419:                                         ; preds = %invoke.cont2420, %invoke.cont2418
  %1092 = landingpad { ptr, i32 }
          cleanup
  %1093 = extractvalue { ptr, i32 } %1092, 0
  store ptr %1093, ptr %exn.slot, align 8
  %1094 = extractvalue { ptr, i32 } %1092, 1
  store i32 %1094, ptr %ehselector.slot, align 4
  br label %ehcleanup2539

lpad2423:                                         ; preds = %invoke.cont2424, %invoke.cont2422
  %1095 = landingpad { ptr, i32 }
          cleanup
  %1096 = extractvalue { ptr, i32 } %1095, 0
  store ptr %1096, ptr %exn.slot, align 8
  %1097 = extractvalue { ptr, i32 } %1095, 1
  store i32 %1097, ptr %ehselector.slot, align 4
  br label %ehcleanup2538

lpad2427:                                         ; preds = %invoke.cont2428, %invoke.cont2426
  %1098 = landingpad { ptr, i32 }
          cleanup
  %1099 = extractvalue { ptr, i32 } %1098, 0
  store ptr %1099, ptr %exn.slot, align 8
  %1100 = extractvalue { ptr, i32 } %1098, 1
  store i32 %1100, ptr %ehselector.slot, align 4
  br label %ehcleanup2537

lpad2432:                                         ; preds = %invoke.cont2433, %invoke.cont2430
  %1101 = landingpad { ptr, i32 }
          cleanup
  %1102 = extractvalue { ptr, i32 } %1101, 0
  store ptr %1102, ptr %exn.slot, align 8
  %1103 = extractvalue { ptr, i32 } %1101, 1
  store i32 %1103, ptr %ehselector.slot, align 4
  br label %ehcleanup2536

lpad2436:                                         ; preds = %invoke.cont2441, %invoke.cont2437, %invoke.cont2435
  %1104 = landingpad { ptr, i32 }
          cleanup
  %1105 = extractvalue { ptr, i32 } %1104, 0
  store ptr %1105, ptr %exn.slot, align 8
  %1106 = extractvalue { ptr, i32 } %1104, 1
  store i32 %1106, ptr %ehselector.slot, align 4
  br label %ehcleanup2535

lpad2444:                                         ; preds = %invoke.cont2445, %invoke.cont2443
  %1107 = landingpad { ptr, i32 }
          cleanup
  %1108 = extractvalue { ptr, i32 } %1107, 0
  store ptr %1108, ptr %exn.slot, align 8
  %1109 = extractvalue { ptr, i32 } %1107, 1
  store i32 %1109, ptr %ehselector.slot, align 4
  br label %ehcleanup2534

lpad2448:                                         ; preds = %invoke.cont2449, %invoke.cont2447
  %1110 = landingpad { ptr, i32 }
          cleanup
  %1111 = extractvalue { ptr, i32 } %1110, 0
  store ptr %1111, ptr %exn.slot, align 8
  %1112 = extractvalue { ptr, i32 } %1110, 1
  store i32 %1112, ptr %ehselector.slot, align 4
  br label %ehcleanup2533

lpad2452:                                         ; preds = %invoke.cont2530, %invoke.cont2529, %invoke.cont2528, %for.end2527, %invoke.cont2520, %invoke.cont2518, %invoke.cont2516, %invoke.cont2514, %invoke.cont2512, %invoke.cont2510, %invoke.cont2508, %invoke.cont2506, %invoke.cont2504, %invoke.cont2502, %invoke.cont2499, %invoke.cont2496, %invoke.cont2493, %invoke.cont2490, %invoke.cont2488, %invoke.cont2486, %invoke.cont2484, %if.then2483, %invoke.cont2478, %invoke.cont2475, %invoke.cont2471, %invoke.cont2467, %invoke.cont2463, %invoke.cont2459, %for.body2457, %invoke.cont2451
  %1113 = landingpad { ptr, i32 }
          cleanup
  %1114 = extractvalue { ptr, i32 } %1113, 0
  store ptr %1114, ptr %exn.slot, align 8
  %1115 = extractvalue { ptr, i32 } %1113, 1
  store i32 %1115, ptr %ehselector.slot, align 4
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostIndices2450) #13
  br label %ehcleanup2533

if.end2524:                                       ; preds = %invoke.cont2522, %invoke.cont2480
  br label %for.inc2525

for.inc2525:                                      ; preds = %if.end2524
  %1116 = load i32, ptr %i2454, align 4
  %inc2526 = add nsw i32 %1116, 1
  store i32 %inc2526, ptr %i2454, align 4
  br label %for.cond2455, !llvm.loop !74

for.end2527:                                      ; preds = %for.cond2455
  %1117 = load ptr, ptr %clippingFacesOutGPU.addr, align 8
  invoke void @_ZN13b3OpenCLArrayI6b3Int4E12copyFromHostERK20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %1117, ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU2425, i1 noundef zeroext true)
          to label %invoke.cont2528 unwind label %lpad2452

invoke.cont2528:                                  ; preds = %for.end2527
  %1118 = load ptr, ptr %worldVertsA1GPU.addr, align 8
  invoke void @_ZN13b3OpenCLArrayI9b3Vector3E12copyFromHostERK20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %1118, ptr noundef nonnull align 8 dereferenceable(25) %worldVertsA1CPU2434, i1 noundef zeroext true)
          to label %invoke.cont2529 unwind label %lpad2452

invoke.cont2529:                                  ; preds = %invoke.cont2528
  %1119 = load ptr, ptr %worldNormalsAGPU.addr, align 8
  invoke void @_ZN13b3OpenCLArrayI9b3Vector3E12copyFromHostERK20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %1119, ptr noundef nonnull align 8 dereferenceable(25) %worldNormalsACPU2429, i1 noundef zeroext true)
          to label %invoke.cont2530 unwind label %lpad2452

invoke.cont2530:                                  ; preds = %invoke.cont2529
  %1120 = load ptr, ptr %worldVertsB1GPU.addr, align 8
  invoke void @_ZN13b3OpenCLArrayI9b3Vector3E12copyFromHostERK20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %1120, ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB1CPU2421, i1 noundef zeroext true)
          to label %invoke.cont2531 unwind label %lpad2452

invoke.cont2531:                                  ; preds = %invoke.cont2530
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostIndices2450) #13
  call void @_ZN20b3AlignedObjectArrayI9b3GpuFaceED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostFaces2446) #13
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices2442) #13
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsA1CPU2434) #13
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldNormalsACPU2429) #13
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU2425) #13
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB1CPU2421) #13
  call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf2417) #13
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostPairs2413) #13
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuSepNormals) #13
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostHasSepNormals) #13
  call void @_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables2401) #13
  call void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexData2397) #13
  br label %if.end2545

ehcleanup2533:                                    ; preds = %lpad2452, %lpad2448
  call void @_ZN20b3AlignedObjectArrayI9b3GpuFaceED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostFaces2446) #13
  br label %ehcleanup2534

ehcleanup2534:                                    ; preds = %ehcleanup2533, %lpad2444
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices2442) #13
  br label %ehcleanup2535

ehcleanup2535:                                    ; preds = %ehcleanup2534, %lpad2436
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsA1CPU2434) #13
  br label %ehcleanup2536

ehcleanup2536:                                    ; preds = %ehcleanup2535, %lpad2432
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldNormalsACPU2429) #13
  br label %ehcleanup2537

ehcleanup2537:                                    ; preds = %ehcleanup2536, %lpad2427
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU2425) #13
  br label %ehcleanup2538

ehcleanup2538:                                    ; preds = %ehcleanup2537, %lpad2423
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB1CPU2421) #13
  br label %ehcleanup2539

ehcleanup2539:                                    ; preds = %ehcleanup2538, %lpad2419
  call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf2417) #13
  br label %ehcleanup2540

ehcleanup2540:                                    ; preds = %ehcleanup2539, %lpad2415
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostPairs2413) #13
  br label %ehcleanup2541

ehcleanup2541:                                    ; preds = %ehcleanup2540, %lpad2411
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuSepNormals) #13
  br label %ehcleanup2542

ehcleanup2542:                                    ; preds = %ehcleanup2541, %lpad2407
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostHasSepNormals) #13
  br label %ehcleanup2543

ehcleanup2543:                                    ; preds = %ehcleanup2542, %lpad2403
  call void @_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables2401) #13
  br label %ehcleanup2544

ehcleanup2544:                                    ; preds = %ehcleanup2543, %lpad2399
  call void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexData2397) #13
  br label %ehcleanup2977

if.end2545:                                       ; preds = %invoke.cont2531, %invoke.cont2392
  %1121 = load i8, ptr @clipConvexFacesAndFindContactsCPU, align 1
  %tobool2546 = trunc i8 %1121 to i1
  br i1 %tobool2546, label %if.then2547, label %if.else2609

if.then2547:                                      ; preds = %if.end2545
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostSepNormals)
          to label %invoke.cont2548 unwind label %lpad2300

invoke.cont2548:                                  ; preds = %if.then2547
  %m_sepNormals2549 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 26
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %m_sepNormals2549, ptr noundef nonnull align 8 dereferenceable(25) %hostSepNormals, i1 noundef zeroext true)
          to label %invoke.cont2551 unwind label %lpad2550

invoke.cont2551:                                  ; preds = %invoke.cont2548
  invoke void @_ZN20b3AlignedObjectArrayIiEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostHasSepAxis2552)
          to label %invoke.cont2553 unwind label %lpad2550

invoke.cont2553:                                  ; preds = %invoke.cont2551
  %m_hasSeparatingNormals2554 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 28
  invoke void @_ZNK13b3OpenCLArrayIiE10copyToHostER20b3AlignedObjectArrayIiEb(ptr noundef nonnull align 8 dereferenceable(50) %m_hasSeparatingNormals2554, ptr noundef nonnull align 8 dereferenceable(25) %hostHasSepAxis2552, i1 noundef zeroext true)
          to label %invoke.cont2556 unwind label %lpad2555

invoke.cont2556:                                  ; preds = %invoke.cont2553
  invoke void @_ZN20b3AlignedObjectArrayI6b3Int4EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostClippingFaces)
          to label %invoke.cont2557 unwind label %lpad2555

invoke.cont2557:                                  ; preds = %invoke.cont2556
  %1122 = load ptr, ptr %clippingFacesOutGPU.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI6b3Int4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %1122, ptr noundef nonnull align 8 dereferenceable(25) %hostClippingFaces, i1 noundef zeroext true)
          to label %invoke.cont2559 unwind label %lpad2558

invoke.cont2559:                                  ; preds = %invoke.cont2557
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB2CPU2560)
          to label %invoke.cont2561 unwind label %lpad2558

invoke.cont2561:                                  ; preds = %invoke.cont2559
  %1123 = load i32, ptr %vertexFaceCapacity, align 4
  %1124 = load i32, ptr %nPairs.addr, align 4
  %mul2562 = mul nsw i32 %1123, %1124
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp2563, i8 0, i64 16, i1 false)
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB2CPU2560, i32 noundef %mul2562, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp2563)
          to label %invoke.cont2565 unwind label %lpad2564

invoke.cont2565:                                  ; preds = %invoke.cont2561
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsA1CPU2566)
          to label %invoke.cont2567 unwind label %lpad2564

invoke.cont2567:                                  ; preds = %invoke.cont2565
  %1125 = load ptr, ptr %worldVertsA1GPU.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %1125, ptr noundef nonnull align 8 dereferenceable(25) %worldVertsA1CPU2566, i1 noundef zeroext true)
          to label %invoke.cont2569 unwind label %lpad2568

invoke.cont2569:                                  ; preds = %invoke.cont2567
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldNormalsACPU2570)
          to label %invoke.cont2571 unwind label %lpad2568

invoke.cont2571:                                  ; preds = %invoke.cont2569
  %1126 = load ptr, ptr %worldNormalsAGPU.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %1126, ptr noundef nonnull align 8 dereferenceable(25) %worldNormalsACPU2570, i1 noundef zeroext true)
          to label %invoke.cont2573 unwind label %lpad2572

invoke.cont2573:                                  ; preds = %invoke.cont2571
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB1CPU2574)
          to label %invoke.cont2575 unwind label %lpad2572

invoke.cont2575:                                  ; preds = %invoke.cont2573
  %1127 = load ptr, ptr %worldVertsB1GPU.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %1127, ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB1CPU2574, i1 noundef zeroext true)
          to label %invoke.cont2577 unwind label %lpad2576

invoke.cont2577:                                  ; preds = %invoke.cont2575
  store i32 0, ptr %i2578, align 4
  br label %for.cond2579

for.cond2579:                                     ; preds = %for.inc2597, %invoke.cont2577
  %1128 = load i32, ptr %i2578, align 4
  %1129 = load i32, ptr %nPairs.addr, align 4
  %cmp2580 = icmp slt i32 %1128, %1129
  br i1 %cmp2580, label %for.body2581, label %for.end2599

for.body2581:                                     ; preds = %for.cond2579
  %call2583 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostSepNormals, i32 noundef 0)
          to label %invoke.cont2582 unwind label %lpad2576

invoke.cont2582:                                  ; preds = %for.body2581
  %call2585 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostHasSepAxis2552, i32 noundef 0)
          to label %invoke.cont2584 unwind label %lpad2576

invoke.cont2584:                                  ; preds = %invoke.cont2582
  %call2587 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI6b3Int4E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostClippingFaces, i32 noundef 0)
          to label %invoke.cont2586 unwind label %lpad2576

invoke.cont2586:                                  ; preds = %invoke.cont2584
  %call2589 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsA1CPU2566, i32 noundef 0)
          to label %invoke.cont2588 unwind label %lpad2576

invoke.cont2588:                                  ; preds = %invoke.cont2586
  %call2591 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %worldNormalsACPU2570, i32 noundef 0)
          to label %invoke.cont2590 unwind label %lpad2576

invoke.cont2590:                                  ; preds = %invoke.cont2588
  %call2593 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB1CPU2574, i32 noundef 0)
          to label %invoke.cont2592 unwind label %lpad2576

invoke.cont2592:                                  ; preds = %invoke.cont2590
  %call2595 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB2CPU2560, i32 noundef 0)
          to label %invoke.cont2594 unwind label %lpad2576

invoke.cont2594:                                  ; preds = %invoke.cont2592
  %1130 = load i32, ptr %vertexFaceCapacity, align 4
  %1131 = load i32, ptr %i2578, align 4
  invoke void @_Z30clipFacesAndFindContactsKernelPK9b3Vector3PKiP6b3Int4PS_S6_S6_S6_ii(ptr noundef %call2583, ptr noundef %call2585, ptr noundef %call2587, ptr noundef %call2589, ptr noundef %call2591, ptr noundef %call2593, ptr noundef %call2595, i32 noundef %1130, i32 noundef %1131)
          to label %invoke.cont2596 unwind label %lpad2576

invoke.cont2596:                                  ; preds = %invoke.cont2594
  br label %for.inc2597

for.inc2597:                                      ; preds = %invoke.cont2596
  %1132 = load i32, ptr %i2578, align 4
  %inc2598 = add nsw i32 %1132, 1
  store i32 %inc2598, ptr %i2578, align 4
  br label %for.cond2579, !llvm.loop !75

lpad2550:                                         ; preds = %invoke.cont2551, %invoke.cont2548
  %1133 = landingpad { ptr, i32 }
          cleanup
  %1134 = extractvalue { ptr, i32 } %1133, 0
  store ptr %1134, ptr %exn.slot, align 8
  %1135 = extractvalue { ptr, i32 } %1133, 1
  store i32 %1135, ptr %ehselector.slot, align 4
  br label %ehcleanup2608

lpad2555:                                         ; preds = %invoke.cont2556, %invoke.cont2553
  %1136 = landingpad { ptr, i32 }
          cleanup
  %1137 = extractvalue { ptr, i32 } %1136, 0
  store ptr %1137, ptr %exn.slot, align 8
  %1138 = extractvalue { ptr, i32 } %1136, 1
  store i32 %1138, ptr %ehselector.slot, align 4
  br label %ehcleanup2607

lpad2558:                                         ; preds = %invoke.cont2559, %invoke.cont2557
  %1139 = landingpad { ptr, i32 }
          cleanup
  %1140 = extractvalue { ptr, i32 } %1139, 0
  store ptr %1140, ptr %exn.slot, align 8
  %1141 = extractvalue { ptr, i32 } %1139, 1
  store i32 %1141, ptr %ehselector.slot, align 4
  br label %ehcleanup2606

lpad2564:                                         ; preds = %invoke.cont2565, %invoke.cont2561
  %1142 = landingpad { ptr, i32 }
          cleanup
  %1143 = extractvalue { ptr, i32 } %1142, 0
  store ptr %1143, ptr %exn.slot, align 8
  %1144 = extractvalue { ptr, i32 } %1142, 1
  store i32 %1144, ptr %ehselector.slot, align 4
  br label %ehcleanup2605

lpad2568:                                         ; preds = %invoke.cont2569, %invoke.cont2567
  %1145 = landingpad { ptr, i32 }
          cleanup
  %1146 = extractvalue { ptr, i32 } %1145, 0
  store ptr %1146, ptr %exn.slot, align 8
  %1147 = extractvalue { ptr, i32 } %1145, 1
  store i32 %1147, ptr %ehselector.slot, align 4
  br label %ehcleanup2604

lpad2572:                                         ; preds = %invoke.cont2573, %invoke.cont2571
  %1148 = landingpad { ptr, i32 }
          cleanup
  %1149 = extractvalue { ptr, i32 } %1148, 0
  store ptr %1149, ptr %exn.slot, align 8
  %1150 = extractvalue { ptr, i32 } %1148, 1
  store i32 %1150, ptr %ehselector.slot, align 4
  br label %ehcleanup2603

lpad2576:                                         ; preds = %invoke.cont2600, %for.end2599, %invoke.cont2594, %invoke.cont2592, %invoke.cont2590, %invoke.cont2588, %invoke.cont2586, %invoke.cont2584, %invoke.cont2582, %for.body2581, %invoke.cont2575
  %1151 = landingpad { ptr, i32 }
          cleanup
  %1152 = extractvalue { ptr, i32 } %1151, 0
  store ptr %1152, ptr %exn.slot, align 8
  %1153 = extractvalue { ptr, i32 } %1151, 1
  store i32 %1153, ptr %ehselector.slot, align 4
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB1CPU2574) #13
  br label %ehcleanup2603

for.end2599:                                      ; preds = %for.cond2579
  %1154 = load ptr, ptr %clippingFacesOutGPU.addr, align 8
  invoke void @_ZN13b3OpenCLArrayI6b3Int4E12copyFromHostERK20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %1154, ptr noundef nonnull align 8 dereferenceable(25) %hostClippingFaces, i1 noundef zeroext true)
          to label %invoke.cont2600 unwind label %lpad2576

invoke.cont2600:                                  ; preds = %for.end2599
  %1155 = load ptr, ptr %worldVertsB2GPU.addr, align 8
  invoke void @_ZN13b3OpenCLArrayI9b3Vector3E12copyFromHostERK20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %1155, ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB2CPU2560, i1 noundef zeroext true)
          to label %invoke.cont2601 unwind label %lpad2576

invoke.cont2601:                                  ; preds = %invoke.cont2600
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB1CPU2574) #13
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldNormalsACPU2570) #13
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsA1CPU2566) #13
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB2CPU2560) #13
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostClippingFaces) #13
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostHasSepAxis2552) #13
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostSepNormals) #13
  br label %if.end2662

ehcleanup2603:                                    ; preds = %lpad2576, %lpad2572
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldNormalsACPU2570) #13
  br label %ehcleanup2604

ehcleanup2604:                                    ; preds = %ehcleanup2603, %lpad2568
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsA1CPU2566) #13
  br label %ehcleanup2605

ehcleanup2605:                                    ; preds = %ehcleanup2604, %lpad2564
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB2CPU2560) #13
  br label %ehcleanup2606

ehcleanup2606:                                    ; preds = %ehcleanup2605, %lpad2558
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostClippingFaces) #13
  br label %ehcleanup2607

ehcleanup2607:                                    ; preds = %ehcleanup2606, %lpad2555
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostHasSepAxis2552) #13
  br label %ehcleanup2608

ehcleanup2608:                                    ; preds = %ehcleanup2607, %lpad2550
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostSepNormals) #13
  br label %ehcleanup2977

if.else2609:                                      ; preds = %if.end2545
  invoke void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %__profile2610, ptr noundef @.str.58)
          to label %invoke.cont2611 unwind label %lpad2300

invoke.cont2611:                                  ; preds = %if.else2609
  %arrayinit.begin2613 = getelementptr inbounds [7 x %struct.b3BufferInfoCL], ptr %bInfo2612, i64 0, i64 0
  %m_sepNormals2614 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 26
  %call2617 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_sepNormals2614)
          to label %invoke.cont2616 unwind label %lpad2615

invoke.cont2616:                                  ; preds = %invoke.cont2611
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.begin2613, ptr noundef %call2617, i1 noundef zeroext false)
          to label %invoke.cont2618 unwind label %lpad2615

invoke.cont2618:                                  ; preds = %invoke.cont2616
  %arrayinit.element2619 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.begin2613, i64 1
  %m_hasSeparatingNormals2620 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 28
  %call2622 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_hasSeparatingNormals2620)
          to label %invoke.cont2621 unwind label %lpad2615

invoke.cont2621:                                  ; preds = %invoke.cont2618
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2619, ptr noundef %call2622, i1 noundef zeroext false)
          to label %invoke.cont2623 unwind label %lpad2615

invoke.cont2623:                                  ; preds = %invoke.cont2621
  %arrayinit.element2624 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2619, i64 1
  %1156 = load ptr, ptr %clippingFacesOutGPU.addr, align 8
  %call2626 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1156)
          to label %invoke.cont2625 unwind label %lpad2615

invoke.cont2625:                                  ; preds = %invoke.cont2623
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2624, ptr noundef %call2626, i1 noundef zeroext false)
          to label %invoke.cont2627 unwind label %lpad2615

invoke.cont2627:                                  ; preds = %invoke.cont2625
  %arrayinit.element2628 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2624, i64 1
  %1157 = load ptr, ptr %worldVertsA1GPU.addr, align 8
  %call2630 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1157)
          to label %invoke.cont2629 unwind label %lpad2615

invoke.cont2629:                                  ; preds = %invoke.cont2627
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2628, ptr noundef %call2630, i1 noundef zeroext false)
          to label %invoke.cont2631 unwind label %lpad2615

invoke.cont2631:                                  ; preds = %invoke.cont2629
  %arrayinit.element2632 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2628, i64 1
  %1158 = load ptr, ptr %worldNormalsAGPU.addr, align 8
  %call2634 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1158)
          to label %invoke.cont2633 unwind label %lpad2615

invoke.cont2633:                                  ; preds = %invoke.cont2631
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2632, ptr noundef %call2634, i1 noundef zeroext false)
          to label %invoke.cont2635 unwind label %lpad2615

invoke.cont2635:                                  ; preds = %invoke.cont2633
  %arrayinit.element2636 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2632, i64 1
  %1159 = load ptr, ptr %worldVertsB1GPU.addr, align 8
  %call2638 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1159)
          to label %invoke.cont2637 unwind label %lpad2615

invoke.cont2637:                                  ; preds = %invoke.cont2635
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2636, ptr noundef %call2638, i1 noundef zeroext false)
          to label %invoke.cont2639 unwind label %lpad2615

invoke.cont2639:                                  ; preds = %invoke.cont2637
  %arrayinit.element2640 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2636, i64 1
  %1160 = load ptr, ptr %worldVertsB2GPU.addr, align 8
  %call2642 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1160)
          to label %invoke.cont2641 unwind label %lpad2615

invoke.cont2641:                                  ; preds = %invoke.cont2639
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2640, ptr noundef %call2642, i1 noundef zeroext false)
          to label %invoke.cont2643 unwind label %lpad2615

invoke.cont2643:                                  ; preds = %invoke.cont2641
  %m_queue2645 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %1161 = load ptr, ptr %m_queue2645, align 8
  %m_clipFacesAndFindContacts2646 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 16
  %1162 = load ptr, ptr %m_clipFacesAndFindContacts2646, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher2644, ptr noundef %1161, ptr noundef %1162, ptr noundef @.str.59)
          to label %invoke.cont2647 unwind label %lpad2615

invoke.cont2647:                                  ; preds = %invoke.cont2643
  %arraydecay2648 = getelementptr inbounds [7 x %struct.b3BufferInfoCL], ptr %bInfo2612, i64 0, i64 0
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher2644, ptr noundef %arraydecay2648, i32 noundef 7)
          to label %invoke.cont2650 unwind label %lpad2649

invoke.cont2650:                                  ; preds = %invoke.cont2647
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher2644, ptr noundef nonnull align 4 dereferenceable(4) %vertexFaceCapacity)
          to label %invoke.cont2651 unwind label %lpad2649

invoke.cont2651:                                  ; preds = %invoke.cont2650
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher2644, ptr noundef nonnull align 4 dereferenceable(4) %nPairs.addr)
          to label %invoke.cont2652 unwind label %lpad2649

invoke.cont2652:                                  ; preds = %invoke.cont2651
  store i32 0, ptr %debugMode2653, align 4
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher2644, ptr noundef nonnull align 4 dereferenceable(4) %debugMode2653)
          to label %invoke.cont2654 unwind label %lpad2649

invoke.cont2654:                                  ; preds = %invoke.cont2652
  %1163 = load i32, ptr %nPairs.addr, align 4
  store i32 %1163, ptr %num2655, align 4
  %1164 = load i32, ptr %num2655, align 4
  invoke void @_ZN12b3LauncherCL8launch1DEii(ptr noundef nonnull align 8 dereferenceable(112) %launcher2644, i32 noundef %1164, i32 noundef 64)
          to label %invoke.cont2656 unwind label %lpad2649

invoke.cont2656:                                  ; preds = %invoke.cont2654
  %1165 = load ptr, ptr @__clewFinish, align 8
  %m_queue2657 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %1166 = load ptr, ptr %m_queue2657, align 8
  %call2659 = invoke i32 %1165(ptr noundef %1166)
          to label %invoke.cont2658 unwind label %lpad2649

invoke.cont2658:                                  ; preds = %invoke.cont2656
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher2644) #13
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile2610) #13
  br label %if.end2662

lpad2615:                                         ; preds = %invoke.cont2643, %invoke.cont2641, %invoke.cont2639, %invoke.cont2637, %invoke.cont2635, %invoke.cont2633, %invoke.cont2631, %invoke.cont2629, %invoke.cont2627, %invoke.cont2625, %invoke.cont2623, %invoke.cont2621, %invoke.cont2618, %invoke.cont2616, %invoke.cont2611
  %1167 = landingpad { ptr, i32 }
          cleanup
  %1168 = extractvalue { ptr, i32 } %1167, 0
  store ptr %1168, ptr %exn.slot, align 8
  %1169 = extractvalue { ptr, i32 } %1167, 1
  store i32 %1169, ptr %ehselector.slot, align 4
  br label %ehcleanup2661

lpad2649:                                         ; preds = %invoke.cont2656, %invoke.cont2654, %invoke.cont2652, %invoke.cont2651, %invoke.cont2650, %invoke.cont2647
  %1170 = landingpad { ptr, i32 }
          cleanup
  %1171 = extractvalue { ptr, i32 } %1170, 0
  store ptr %1171, ptr %exn.slot, align 8
  %1172 = extractvalue { ptr, i32 } %1170, 1
  store i32 %1172, ptr %ehselector.slot, align 4
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher2644) #13
  br label %ehcleanup2661

ehcleanup2661:                                    ; preds = %lpad2649, %lpad2615
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile2610) #13
  br label %ehcleanup2977

if.end2662:                                       ; preds = %invoke.cont2658, %invoke.cont2601
  %m_totalContactsOut2663 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %call2665 = invoke noundef i32 @_ZNK13b3OpenCLArrayIiE2atEm(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut2663, i64 noundef 0)
          to label %invoke.cont2664 unwind label %lpad2300

invoke.cont2664:                                  ; preds = %if.end2662
  %1173 = load ptr, ptr %nContacts.addr, align 8
  store i32 %call2665, ptr %1173, align 4
  %1174 = load ptr, ptr %nContacts.addr, align 8
  %1175 = load i32, ptr %1174, align 4
  %1176 = load i32, ptr %nPairs.addr, align 4
  %add2667 = add nsw i32 %1175, %1176
  store i32 %add2667, ptr %newContactCapacity2666, align 4
  %1177 = load ptr, ptr %contactOut.addr, align 8
  %1178 = load i32, ptr %newContactCapacity2666, align 4
  %conv2668 = sext i32 %1178 to i64
  %call2670 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI10b3Contact4E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %1177, i64 noundef %conv2668, i1 noundef zeroext true)
          to label %invoke.cont2669 unwind label %lpad2300

invoke.cont2669:                                  ; preds = %invoke.cont2664
  %1179 = load i8, ptr @reduceConvexContactsOnGPU, align 1
  %tobool2671 = trunc i8 %1179 to i1
  br i1 %tobool2671, label %if.then2672, label %if.else2732

if.then2672:                                      ; preds = %invoke.cont2669
  invoke void @_ZN13b3ProfileZoneC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %__profile2673, ptr noundef @.str.23)
          to label %invoke.cont2674 unwind label %lpad2300

invoke.cont2674:                                  ; preds = %if.then2672
  %arrayinit.begin2676 = getelementptr inbounds [8 x %struct.b3BufferInfoCL], ptr %bInfo2675, i64 0, i64 0
  %1180 = load ptr, ptr %pairs.addr, align 8
  %call2679 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1180)
          to label %invoke.cont2678 unwind label %lpad2677

invoke.cont2678:                                  ; preds = %invoke.cont2674
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.begin2676, ptr noundef %call2679, i1 noundef zeroext true)
          to label %invoke.cont2680 unwind label %lpad2677

invoke.cont2680:                                  ; preds = %invoke.cont2678
  %arrayinit.element2681 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.begin2676, i64 1
  %1181 = load ptr, ptr %bodyBuf.addr, align 8
  %call2683 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1181)
          to label %invoke.cont2682 unwind label %lpad2677

invoke.cont2682:                                  ; preds = %invoke.cont2680
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2681, ptr noundef %call2683, i1 noundef zeroext true)
          to label %invoke.cont2684 unwind label %lpad2677

invoke.cont2684:                                  ; preds = %invoke.cont2682
  %arrayinit.element2685 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2681, i64 1
  %m_sepNormals2686 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 26
  %call2688 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_sepNormals2686)
          to label %invoke.cont2687 unwind label %lpad2677

invoke.cont2687:                                  ; preds = %invoke.cont2684
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2685, ptr noundef %call2688, i1 noundef zeroext false)
          to label %invoke.cont2689 unwind label %lpad2677

invoke.cont2689:                                  ; preds = %invoke.cont2687
  %arrayinit.element2690 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2685, i64 1
  %m_hasSeparatingNormals2691 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 28
  %call2693 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_hasSeparatingNormals2691)
          to label %invoke.cont2692 unwind label %lpad2677

invoke.cont2692:                                  ; preds = %invoke.cont2689
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2690, ptr noundef %call2693, i1 noundef zeroext false)
          to label %invoke.cont2694 unwind label %lpad2677

invoke.cont2694:                                  ; preds = %invoke.cont2692
  %arrayinit.element2695 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2690, i64 1
  %1182 = load ptr, ptr %contactOut.addr, align 8
  %call2697 = invoke noundef ptr @_ZNK13b3OpenCLArrayI10b3Contact4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1182)
          to label %invoke.cont2696 unwind label %lpad2677

invoke.cont2696:                                  ; preds = %invoke.cont2694
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2695, ptr noundef %call2697, i1 noundef zeroext false)
          to label %invoke.cont2698 unwind label %lpad2677

invoke.cont2698:                                  ; preds = %invoke.cont2696
  %arrayinit.element2699 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2695, i64 1
  %1183 = load ptr, ptr %clippingFacesOutGPU.addr, align 8
  %call2701 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1183)
          to label %invoke.cont2700 unwind label %lpad2677

invoke.cont2700:                                  ; preds = %invoke.cont2698
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2699, ptr noundef %call2701, i1 noundef zeroext false)
          to label %invoke.cont2702 unwind label %lpad2677

invoke.cont2702:                                  ; preds = %invoke.cont2700
  %arrayinit.element2703 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2699, i64 1
  %1184 = load ptr, ptr %worldVertsB2GPU.addr, align 8
  %call2705 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1184)
          to label %invoke.cont2704 unwind label %lpad2677

invoke.cont2704:                                  ; preds = %invoke.cont2702
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2703, ptr noundef %call2705, i1 noundef zeroext false)
          to label %invoke.cont2706 unwind label %lpad2677

invoke.cont2706:                                  ; preds = %invoke.cont2704
  %arrayinit.element2707 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2703, i64 1
  %m_totalContactsOut2708 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %call2710 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut2708)
          to label %invoke.cont2709 unwind label %lpad2677

invoke.cont2709:                                  ; preds = %invoke.cont2706
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2707, ptr noundef %call2710, i1 noundef zeroext false)
          to label %invoke.cont2711 unwind label %lpad2677

invoke.cont2711:                                  ; preds = %invoke.cont2709
  %m_queue2713 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %1185 = load ptr, ptr %m_queue2713, align 8
  %m_newContactReductionKernel2714 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 19
  %1186 = load ptr, ptr %m_newContactReductionKernel2714, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher2712, ptr noundef %1185, ptr noundef %1186, ptr noundef @.str.60)
          to label %invoke.cont2715 unwind label %lpad2677

invoke.cont2715:                                  ; preds = %invoke.cont2711
  %arraydecay2716 = getelementptr inbounds [8 x %struct.b3BufferInfoCL], ptr %bInfo2675, i64 0, i64 0
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher2712, ptr noundef %arraydecay2716, i32 noundef 8)
          to label %invoke.cont2718 unwind label %lpad2717

invoke.cont2718:                                  ; preds = %invoke.cont2715
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher2712, ptr noundef nonnull align 4 dereferenceable(4) %vertexFaceCapacity)
          to label %invoke.cont2719 unwind label %lpad2717

invoke.cont2719:                                  ; preds = %invoke.cont2718
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher2712, ptr noundef nonnull align 4 dereferenceable(4) %newContactCapacity2666)
          to label %invoke.cont2720 unwind label %lpad2717

invoke.cont2720:                                  ; preds = %invoke.cont2719
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher2712, ptr noundef nonnull align 4 dereferenceable(4) %nPairs.addr)
          to label %invoke.cont2721 unwind label %lpad2717

invoke.cont2721:                                  ; preds = %invoke.cont2720
  %1187 = load i32, ptr %nPairs.addr, align 4
  store i32 %1187, ptr %num2722, align 4
  %1188 = load i32, ptr %num2722, align 4
  invoke void @_ZN12b3LauncherCL8launch1DEii(ptr noundef nonnull align 8 dereferenceable(112) %launcher2712, i32 noundef %1188, i32 noundef 64)
          to label %invoke.cont2723 unwind label %lpad2717

invoke.cont2723:                                  ; preds = %invoke.cont2721
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher2712) #13
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile2673) #13
  %m_totalContactsOut2726 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %call2728 = invoke noundef i32 @_ZNK13b3OpenCLArrayIiE2atEm(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut2726, i64 noundef 0)
          to label %invoke.cont2727 unwind label %lpad2300

invoke.cont2727:                                  ; preds = %invoke.cont2723
  %1189 = load ptr, ptr %nContacts.addr, align 8
  store i32 %call2728, ptr %1189, align 4
  %1190 = load ptr, ptr %contactOut.addr, align 8
  %1191 = load ptr, ptr %nContacts.addr, align 8
  %1192 = load i32, ptr %1191, align 4
  %conv2729 = sext i32 %1192 to i64
  %call2731 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI10b3Contact4E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %1190, i64 noundef %conv2729, i1 noundef zeroext true)
          to label %invoke.cont2730 unwind label %lpad2300

invoke.cont2730:                                  ; preds = %invoke.cont2727
  br label %if.end2799

lpad2677:                                         ; preds = %invoke.cont2711, %invoke.cont2709, %invoke.cont2706, %invoke.cont2704, %invoke.cont2702, %invoke.cont2700, %invoke.cont2698, %invoke.cont2696, %invoke.cont2694, %invoke.cont2692, %invoke.cont2689, %invoke.cont2687, %invoke.cont2684, %invoke.cont2682, %invoke.cont2680, %invoke.cont2678, %invoke.cont2674
  %1193 = landingpad { ptr, i32 }
          cleanup
  %1194 = extractvalue { ptr, i32 } %1193, 0
  store ptr %1194, ptr %exn.slot, align 8
  %1195 = extractvalue { ptr, i32 } %1193, 1
  store i32 %1195, ptr %ehselector.slot, align 4
  br label %ehcleanup2725

lpad2717:                                         ; preds = %invoke.cont2721, %invoke.cont2720, %invoke.cont2719, %invoke.cont2718, %invoke.cont2715
  %1196 = landingpad { ptr, i32 }
          cleanup
  %1197 = extractvalue { ptr, i32 } %1196, 0
  store ptr %1197, ptr %exn.slot, align 8
  %1198 = extractvalue { ptr, i32 } %1196, 1
  store i32 %1198, ptr %ehselector.slot, align 4
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher2712) #13
  br label %ehcleanup2725

ehcleanup2725:                                    ; preds = %lpad2717, %lpad2677
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile2673) #13
  br label %ehcleanup2977

if.else2732:                                      ; preds = %invoke.cont2669
  %1199 = load ptr, ptr %nContacts.addr, align 8
  %1200 = load i32, ptr %1199, align 4
  store volatile i32 %1200, ptr %nGlobalContactsOut2733, align 4
  invoke void @_ZN20b3AlignedObjectArrayI6b3Int4EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostPairs2734)
          to label %invoke.cont2735 unwind label %lpad2300

invoke.cont2735:                                  ; preds = %if.else2732
  %1201 = load ptr, ptr %pairs.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI6b3Int4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %1201, ptr noundef nonnull align 8 dereferenceable(25) %hostPairs2734, i1 noundef zeroext true)
          to label %invoke.cont2737 unwind label %lpad2736

invoke.cont2737:                                  ; preds = %invoke.cont2735
  invoke void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf2738)
          to label %invoke.cont2739 unwind label %lpad2736

invoke.cont2739:                                  ; preds = %invoke.cont2737
  %1202 = load ptr, ptr %bodyBuf.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %1202, ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf2738, i1 noundef zeroext true)
          to label %invoke.cont2741 unwind label %lpad2740

invoke.cont2741:                                  ; preds = %invoke.cont2739
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostSepNormals2742)
          to label %invoke.cont2743 unwind label %lpad2740

invoke.cont2743:                                  ; preds = %invoke.cont2741
  %m_sepNormals2744 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 26
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %m_sepNormals2744, ptr noundef nonnull align 8 dereferenceable(25) %hostSepNormals2742, i1 noundef zeroext true)
          to label %invoke.cont2746 unwind label %lpad2745

invoke.cont2746:                                  ; preds = %invoke.cont2743
  invoke void @_ZN20b3AlignedObjectArrayIiEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostHasSepAxis2747)
          to label %invoke.cont2748 unwind label %lpad2745

invoke.cont2748:                                  ; preds = %invoke.cont2746
  %m_hasSeparatingNormals2749 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 28
  invoke void @_ZNK13b3OpenCLArrayIiE10copyToHostER20b3AlignedObjectArrayIiEb(ptr noundef nonnull align 8 dereferenceable(50) %m_hasSeparatingNormals2749, ptr noundef nonnull align 8 dereferenceable(25) %hostHasSepAxis2747, i1 noundef zeroext true)
          to label %invoke.cont2751 unwind label %lpad2750

invoke.cont2751:                                  ; preds = %invoke.cont2748
  invoke void @_ZN20b3AlignedObjectArrayI10b3Contact4EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostContactsOut)
          to label %invoke.cont2752 unwind label %lpad2750

invoke.cont2752:                                  ; preds = %invoke.cont2751
  %1203 = load ptr, ptr %contactOut.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI10b3Contact4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %1203, ptr noundef nonnull align 8 dereferenceable(25) %hostContactsOut, i1 noundef zeroext true)
          to label %invoke.cont2754 unwind label %lpad2753

invoke.cont2754:                                  ; preds = %invoke.cont2752
  %1204 = load i32, ptr %newContactCapacity2666, align 4
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp2755, i8 0, i64 112, i1 false)
  invoke void @_ZN20b3AlignedObjectArrayI10b3Contact4E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %hostContactsOut, i32 noundef %1204, ptr noundef nonnull align 16 dereferenceable(112) %ref.tmp2755)
          to label %invoke.cont2756 unwind label %lpad2753

invoke.cont2756:                                  ; preds = %invoke.cont2754
  invoke void @_ZN20b3AlignedObjectArrayI6b3Int4EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostClippingFaces2757)
          to label %invoke.cont2758 unwind label %lpad2753

invoke.cont2758:                                  ; preds = %invoke.cont2756
  %1205 = load ptr, ptr %clippingFacesOutGPU.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI6b3Int4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %1205, ptr noundef nonnull align 8 dereferenceable(25) %hostClippingFaces2757, i1 noundef zeroext true)
          to label %invoke.cont2760 unwind label %lpad2759

invoke.cont2760:                                  ; preds = %invoke.cont2758
  invoke void @_ZN20b3AlignedObjectArrayI9b3Vector3EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB2CPU2761)
          to label %invoke.cont2762 unwind label %lpad2759

invoke.cont2762:                                  ; preds = %invoke.cont2760
  %1206 = load ptr, ptr %worldVertsB2GPU.addr, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %1206, ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB2CPU2761, i1 noundef zeroext true)
          to label %invoke.cont2764 unwind label %lpad2763

invoke.cont2764:                                  ; preds = %invoke.cont2762
  store i32 0, ptr %i2765, align 4
  br label %for.cond2766

for.cond2766:                                     ; preds = %for.inc2784, %invoke.cont2764
  %1207 = load i32, ptr %i2765, align 4
  %1208 = load i32, ptr %nPairs.addr, align 4
  %cmp2767 = icmp slt i32 %1207, %1208
  br i1 %cmp2767, label %for.body2768, label %for.end2786

for.body2768:                                     ; preds = %for.cond2766
  %call2770 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI6b3Int4E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostPairs2734, i32 noundef 0)
          to label %invoke.cont2769 unwind label %lpad2763

invoke.cont2769:                                  ; preds = %for.body2768
  %call2772 = invoke noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf2738, i32 noundef 0)
          to label %invoke.cont2771 unwind label %lpad2763

invoke.cont2771:                                  ; preds = %invoke.cont2769
  %call2774 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostSepNormals2742, i32 noundef 0)
          to label %invoke.cont2773 unwind label %lpad2763

invoke.cont2773:                                  ; preds = %invoke.cont2771
  %call2776 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostHasSepAxis2747, i32 noundef 0)
          to label %invoke.cont2775 unwind label %lpad2763

invoke.cont2775:                                  ; preds = %invoke.cont2773
  %call2778 = invoke noundef nonnull align 16 dereferenceable(112) ptr @_ZN20b3AlignedObjectArrayI10b3Contact4E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostContactsOut, i32 noundef 0)
          to label %invoke.cont2777 unwind label %lpad2763

invoke.cont2777:                                  ; preds = %invoke.cont2775
  %call2780 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI6b3Int4E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %hostClippingFaces2757, i32 noundef 0)
          to label %invoke.cont2779 unwind label %lpad2763

invoke.cont2779:                                  ; preds = %invoke.cont2777
  %call2782 = invoke noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB2CPU2761, i32 noundef 0)
          to label %invoke.cont2781 unwind label %lpad2763

invoke.cont2781:                                  ; preds = %invoke.cont2779
  %1209 = load i32, ptr %vertexFaceCapacity, align 4
  %1210 = load i32, ptr %newContactCapacity2666, align 4
  %1211 = load i32, ptr %nPairs.addr, align 4
  %1212 = load i32, ptr %i2765, align 4
  invoke void @_Z27b3NewContactReductionKernelP6b3Int4PK15b3RigidBodyDataPK9b3Vector3PKiP14b3Contact4DataS0_PS4_PViiiii(ptr noundef %call2770, ptr noundef %call2772, ptr noundef %call2774, ptr noundef %call2776, ptr noundef %call2778, ptr noundef %call2780, ptr noundef %call2782, ptr noundef %nGlobalContactsOut2733, i32 noundef %1209, i32 noundef %1210, i32 noundef %1211, i32 noundef %1212)
          to label %invoke.cont2783 unwind label %lpad2763

invoke.cont2783:                                  ; preds = %invoke.cont2781
  br label %for.inc2784

for.inc2784:                                      ; preds = %invoke.cont2783
  %1213 = load i32, ptr %i2765, align 4
  %inc2785 = add nsw i32 %1213, 1
  store i32 %inc2785, ptr %i2765, align 4
  br label %for.cond2766, !llvm.loop !76

lpad2736:                                         ; preds = %invoke.cont2737, %invoke.cont2735
  %1214 = landingpad { ptr, i32 }
          cleanup
  %1215 = extractvalue { ptr, i32 } %1214, 0
  store ptr %1215, ptr %exn.slot, align 8
  %1216 = extractvalue { ptr, i32 } %1214, 1
  store i32 %1216, ptr %ehselector.slot, align 4
  br label %ehcleanup2798

lpad2740:                                         ; preds = %invoke.cont2741, %invoke.cont2739
  %1217 = landingpad { ptr, i32 }
          cleanup
  %1218 = extractvalue { ptr, i32 } %1217, 0
  store ptr %1218, ptr %exn.slot, align 8
  %1219 = extractvalue { ptr, i32 } %1217, 1
  store i32 %1219, ptr %ehselector.slot, align 4
  br label %ehcleanup2797

lpad2745:                                         ; preds = %invoke.cont2746, %invoke.cont2743
  %1220 = landingpad { ptr, i32 }
          cleanup
  %1221 = extractvalue { ptr, i32 } %1220, 0
  store ptr %1221, ptr %exn.slot, align 8
  %1222 = extractvalue { ptr, i32 } %1220, 1
  store i32 %1222, ptr %ehselector.slot, align 4
  br label %ehcleanup2796

lpad2750:                                         ; preds = %invoke.cont2751, %invoke.cont2748
  %1223 = landingpad { ptr, i32 }
          cleanup
  %1224 = extractvalue { ptr, i32 } %1223, 0
  store ptr %1224, ptr %exn.slot, align 8
  %1225 = extractvalue { ptr, i32 } %1223, 1
  store i32 %1225, ptr %ehselector.slot, align 4
  br label %ehcleanup2795

lpad2753:                                         ; preds = %invoke.cont2756, %invoke.cont2754, %invoke.cont2752
  %1226 = landingpad { ptr, i32 }
          cleanup
  %1227 = extractvalue { ptr, i32 } %1226, 0
  store ptr %1227, ptr %exn.slot, align 8
  %1228 = extractvalue { ptr, i32 } %1226, 1
  store i32 %1228, ptr %ehselector.slot, align 4
  br label %ehcleanup2794

lpad2759:                                         ; preds = %invoke.cont2760, %invoke.cont2758
  %1229 = landingpad { ptr, i32 }
          cleanup
  %1230 = extractvalue { ptr, i32 } %1229, 0
  store ptr %1230, ptr %exn.slot, align 8
  %1231 = extractvalue { ptr, i32 } %1229, 1
  store i32 %1231, ptr %ehselector.slot, align 4
  br label %ehcleanup2793

lpad2763:                                         ; preds = %invoke.cont2790, %invoke.cont2788, %for.end2786, %invoke.cont2781, %invoke.cont2779, %invoke.cont2777, %invoke.cont2775, %invoke.cont2773, %invoke.cont2771, %invoke.cont2769, %for.body2768, %invoke.cont2762
  %1232 = landingpad { ptr, i32 }
          cleanup
  %1233 = extractvalue { ptr, i32 } %1232, 0
  store ptr %1233, ptr %exn.slot, align 8
  %1234 = extractvalue { ptr, i32 } %1232, 1
  store i32 %1234, ptr %ehselector.slot, align 4
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB2CPU2761) #13
  br label %ehcleanup2793

for.end2786:                                      ; preds = %for.cond2766
  %1235 = load volatile i32, ptr %nGlobalContactsOut2733, align 4
  %1236 = load ptr, ptr %nContacts.addr, align 8
  store i32 %1235, ptr %1236, align 4
  %m_totalContactsOut2787 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %1237 = load ptr, ptr %nContacts.addr, align 8
  invoke void @_ZN13b3OpenCLArrayIiE19copyFromHostPointerEPKimmb(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut2787, ptr noundef %1237, i64 noundef 1, i64 noundef 0, i1 noundef zeroext true)
          to label %invoke.cont2788 unwind label %lpad2763

invoke.cont2788:                                  ; preds = %for.end2786
  %1238 = load ptr, ptr %nContacts.addr, align 8
  %1239 = load i32, ptr %1238, align 4
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp2789, i8 0, i64 112, i1 false)
  invoke void @_ZN20b3AlignedObjectArrayI10b3Contact4E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %hostContactsOut, i32 noundef %1239, ptr noundef nonnull align 16 dereferenceable(112) %ref.tmp2789)
          to label %invoke.cont2790 unwind label %lpad2763

invoke.cont2790:                                  ; preds = %invoke.cont2788
  %1240 = load ptr, ptr %contactOut.addr, align 8
  invoke void @_ZN13b3OpenCLArrayI10b3Contact4E12copyFromHostERK20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %1240, ptr noundef nonnull align 8 dereferenceable(25) %hostContactsOut, i1 noundef zeroext true)
          to label %invoke.cont2791 unwind label %lpad2763

invoke.cont2791:                                  ; preds = %invoke.cont2790
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB2CPU2761) #13
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostClippingFaces2757) #13
  call void @_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostContactsOut) #13
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostHasSepAxis2747) #13
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostSepNormals2742) #13
  call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf2738) #13
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostPairs2734) #13
  br label %if.end2799

ehcleanup2793:                                    ; preds = %lpad2763, %lpad2759
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostClippingFaces2757) #13
  br label %ehcleanup2794

ehcleanup2794:                                    ; preds = %ehcleanup2793, %lpad2753
  call void @_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostContactsOut) #13
  br label %ehcleanup2795

ehcleanup2795:                                    ; preds = %ehcleanup2794, %lpad2750
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostHasSepAxis2747) #13
  br label %ehcleanup2796

ehcleanup2796:                                    ; preds = %ehcleanup2795, %lpad2745
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostSepNormals2742) #13
  br label %ehcleanup2797

ehcleanup2797:                                    ; preds = %ehcleanup2796, %lpad2740
  call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf2738) #13
  br label %ehcleanup2798

ehcleanup2798:                                    ; preds = %ehcleanup2797, %lpad2736
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostPairs2734) #13
  br label %ehcleanup2977

if.end2799:                                       ; preds = %invoke.cont2791, %invoke.cont2730
  br label %if.end2884

if.else2800:                                      ; preds = %invoke.cont2295
  %1241 = load i32, ptr %nPairs.addr, align 4
  %tobool2801 = icmp ne i32 %1241, 0
  br i1 %tobool2801, label %if.then2802, label %if.end2883

if.then2802:                                      ; preds = %if.else2800
  %arrayinit.begin2804 = getelementptr inbounds [12 x %struct.b3BufferInfoCL], ptr %bInfo2803, i64 0, i64 0
  %1242 = load ptr, ptr %pairs.addr, align 8
  %call2806 = invoke noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1242)
          to label %invoke.cont2805 unwind label %lpad2300

invoke.cont2805:                                  ; preds = %if.then2802
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.begin2804, ptr noundef %call2806, i1 noundef zeroext true)
          to label %invoke.cont2807 unwind label %lpad2300

invoke.cont2807:                                  ; preds = %invoke.cont2805
  %arrayinit.element2808 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.begin2804, i64 1
  %1243 = load ptr, ptr %bodyBuf.addr, align 8
  %call2810 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1243)
          to label %invoke.cont2809 unwind label %lpad2300

invoke.cont2809:                                  ; preds = %invoke.cont2807
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2808, ptr noundef %call2810, i1 noundef zeroext true)
          to label %invoke.cont2811 unwind label %lpad2300

invoke.cont2811:                                  ; preds = %invoke.cont2809
  %arrayinit.element2812 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2808, i64 1
  %1244 = load ptr, ptr %gpuCollidables.addr, align 8
  %call2814 = invoke noundef ptr @_ZNK13b3OpenCLArrayI12b3CollidableE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1244)
          to label %invoke.cont2813 unwind label %lpad2300

invoke.cont2813:                                  ; preds = %invoke.cont2811
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2812, ptr noundef %call2814, i1 noundef zeroext true)
          to label %invoke.cont2815 unwind label %lpad2300

invoke.cont2815:                                  ; preds = %invoke.cont2813
  %arrayinit.element2816 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2812, i64 1
  %1245 = load ptr, ptr %convexData.addr, align 8
  %call2818 = invoke noundef ptr @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1245)
          to label %invoke.cont2817 unwind label %lpad2300

invoke.cont2817:                                  ; preds = %invoke.cont2815
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2816, ptr noundef %call2818, i1 noundef zeroext true)
          to label %invoke.cont2819 unwind label %lpad2300

invoke.cont2819:                                  ; preds = %invoke.cont2817
  %arrayinit.element2820 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2816, i64 1
  %1246 = load ptr, ptr %gpuVertices.addr, align 8
  %call2822 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1246)
          to label %invoke.cont2821 unwind label %lpad2300

invoke.cont2821:                                  ; preds = %invoke.cont2819
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2820, ptr noundef %call2822, i1 noundef zeroext true)
          to label %invoke.cont2823 unwind label %lpad2300

invoke.cont2823:                                  ; preds = %invoke.cont2821
  %arrayinit.element2824 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2820, i64 1
  %1247 = load ptr, ptr %gpuUniqueEdges.addr, align 8
  %call2826 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1247)
          to label %invoke.cont2825 unwind label %lpad2300

invoke.cont2825:                                  ; preds = %invoke.cont2823
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2824, ptr noundef %call2826, i1 noundef zeroext true)
          to label %invoke.cont2827 unwind label %lpad2300

invoke.cont2827:                                  ; preds = %invoke.cont2825
  %arrayinit.element2828 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2824, i64 1
  %1248 = load ptr, ptr %gpuFaces.addr, align 8
  %call2830 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3GpuFaceE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1248)
          to label %invoke.cont2829 unwind label %lpad2300

invoke.cont2829:                                  ; preds = %invoke.cont2827
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2828, ptr noundef %call2830, i1 noundef zeroext true)
          to label %invoke.cont2831 unwind label %lpad2300

invoke.cont2831:                                  ; preds = %invoke.cont2829
  %arrayinit.element2832 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2828, i64 1
  %1249 = load ptr, ptr %gpuIndices.addr, align 8
  %call2834 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1249)
          to label %invoke.cont2833 unwind label %lpad2300

invoke.cont2833:                                  ; preds = %invoke.cont2831
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2832, ptr noundef %call2834, i1 noundef zeroext true)
          to label %invoke.cont2835 unwind label %lpad2300

invoke.cont2835:                                  ; preds = %invoke.cont2833
  %arrayinit.element2836 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2832, i64 1
  %m_sepNormals2837 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 26
  %call2839 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_sepNormals2837)
          to label %invoke.cont2838 unwind label %lpad2300

invoke.cont2838:                                  ; preds = %invoke.cont2835
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2836, ptr noundef %call2839, i1 noundef zeroext false)
          to label %invoke.cont2840 unwind label %lpad2300

invoke.cont2840:                                  ; preds = %invoke.cont2838
  %arrayinit.element2841 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2836, i64 1
  %m_hasSeparatingNormals2842 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 28
  %call2844 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_hasSeparatingNormals2842)
          to label %invoke.cont2843 unwind label %lpad2300

invoke.cont2843:                                  ; preds = %invoke.cont2840
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2841, ptr noundef %call2844, i1 noundef zeroext false)
          to label %invoke.cont2845 unwind label %lpad2300

invoke.cont2845:                                  ; preds = %invoke.cont2843
  %arrayinit.element2846 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2841, i64 1
  %1250 = load ptr, ptr %contactOut.addr, align 8
  %call2848 = invoke noundef ptr @_ZNK13b3OpenCLArrayI10b3Contact4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1250)
          to label %invoke.cont2847 unwind label %lpad2300

invoke.cont2847:                                  ; preds = %invoke.cont2845
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2846, ptr noundef %call2848, i1 noundef zeroext false)
          to label %invoke.cont2849 unwind label %lpad2300

invoke.cont2849:                                  ; preds = %invoke.cont2847
  %arrayinit.element2850 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2846, i64 1
  %m_totalContactsOut2851 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %call2853 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut2851)
          to label %invoke.cont2852 unwind label %lpad2300

invoke.cont2852:                                  ; preds = %invoke.cont2849
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2850, ptr noundef %call2853, i1 noundef zeroext false)
          to label %invoke.cont2854 unwind label %lpad2300

invoke.cont2854:                                  ; preds = %invoke.cont2852
  %m_queue2856 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %1251 = load ptr, ptr %m_queue2856, align 8
  %m_clipHullHullKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 14
  %1252 = load ptr, ptr %m_clipHullHullKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher2855, ptr noundef %1251, ptr noundef %1252, ptr noundef @.str.63)
          to label %invoke.cont2857 unwind label %lpad2300

invoke.cont2857:                                  ; preds = %invoke.cont2854
  %arraydecay2858 = getelementptr inbounds [12 x %struct.b3BufferInfoCL], ptr %bInfo2803, i64 0, i64 0
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher2855, ptr noundef %arraydecay2858, i32 noundef 12)
          to label %invoke.cont2860 unwind label %lpad2859

invoke.cont2860:                                  ; preds = %invoke.cont2857
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher2855, ptr noundef nonnull align 4 dereferenceable(4) %nPairs.addr)
          to label %invoke.cont2861 unwind label %lpad2859

invoke.cont2861:                                  ; preds = %invoke.cont2860
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher2855, ptr noundef nonnull align 4 dereferenceable(4) %maxContactCapacity.addr)
          to label %invoke.cont2862 unwind label %lpad2859

invoke.cont2862:                                  ; preds = %invoke.cont2861
  %1253 = load i32, ptr %nPairs.addr, align 4
  store i32 %1253, ptr %num2863, align 4
  %1254 = load i32, ptr %num2863, align 4
  invoke void @_ZN12b3LauncherCL8launch1DEii(ptr noundef nonnull align 8 dereferenceable(112) %launcher2855, i32 noundef %1254, i32 noundef 64)
          to label %invoke.cont2864 unwind label %lpad2859

invoke.cont2864:                                  ; preds = %invoke.cont2862
  %1255 = load ptr, ptr @__clewFinish, align 8
  %m_queue2865 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %1256 = load ptr, ptr %m_queue2865, align 8
  %call2867 = invoke i32 %1255(ptr noundef %1256)
          to label %invoke.cont2866 unwind label %lpad2859

invoke.cont2866:                                  ; preds = %invoke.cont2864
  %m_totalContactsOut2868 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %call2870 = invoke noundef i32 @_ZNK13b3OpenCLArrayIiE2atEm(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut2868, i64 noundef 0)
          to label %invoke.cont2869 unwind label %lpad2859

invoke.cont2869:                                  ; preds = %invoke.cont2866
  %1257 = load ptr, ptr %nContacts.addr, align 8
  store i32 %call2870, ptr %1257, align 4
  %1258 = load ptr, ptr %nContacts.addr, align 8
  %1259 = load i32, ptr %1258, align 4
  %1260 = load i32, ptr %maxContactCapacity.addr, align 4
  %cmp2871 = icmp sge i32 %1259, %1260
  br i1 %cmp2871, label %if.then2872, label %if.end2878

if.then2872:                                      ; preds = %invoke.cont2869
  br label %do.body2873

do.body2873:                                      ; preds = %if.then2872
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.31, i32 noundef 4360)
          to label %invoke.cont2874 unwind label %lpad2859

invoke.cont2874:                                  ; preds = %do.body2873
  %1261 = load ptr, ptr %nContacts.addr, align 8
  %1262 = load i32, ptr %1261, align 4
  %1263 = load i32, ptr %maxContactCapacity.addr, align 4
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.64, i32 noundef %1262, i32 noundef %1263)
          to label %invoke.cont2875 unwind label %lpad2859

invoke.cont2875:                                  ; preds = %invoke.cont2874
  br label %do.cond2876

do.cond2876:                                      ; preds = %invoke.cont2875
  br label %do.end2877

do.end2877:                                       ; preds = %do.cond2876
  %1264 = load i32, ptr %maxContactCapacity.addr, align 4
  %1265 = load ptr, ptr %nContacts.addr, align 8
  store i32 %1264, ptr %1265, align 4
  br label %if.end2878

lpad2859:                                         ; preds = %if.end2878, %invoke.cont2874, %do.body2873, %invoke.cont2866, %invoke.cont2864, %invoke.cont2862, %invoke.cont2861, %invoke.cont2860, %invoke.cont2857
  %1266 = landingpad { ptr, i32 }
          cleanup
  %1267 = extractvalue { ptr, i32 } %1266, 0
  store ptr %1267, ptr %exn.slot, align 8
  %1268 = extractvalue { ptr, i32 } %1266, 1
  store i32 %1268, ptr %ehselector.slot, align 4
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher2855) #13
  br label %ehcleanup2977

if.end2878:                                       ; preds = %do.end2877, %invoke.cont2869
  %1269 = load ptr, ptr %contactOut.addr, align 8
  %1270 = load ptr, ptr %nContacts.addr, align 8
  %1271 = load i32, ptr %1270, align 4
  %conv2879 = sext i32 %1271 to i64
  %call2881 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI10b3Contact4E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %1269, i64 noundef %conv2879, i1 noundef zeroext true)
          to label %invoke.cont2880 unwind label %lpad2859

invoke.cont2880:                                  ; preds = %if.end2878
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher2855) #13
  br label %if.end2883

if.end2883:                                       ; preds = %invoke.cont2880, %if.else2800
  br label %if.end2884

if.end2884:                                       ; preds = %if.end2883, %if.end2799
  %m_gpuCompoundPairs2885 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 32
  %call2887 = invoke noundef i64 @_ZNK13b3OpenCLArrayI25b3CompoundOverlappingPairE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuCompoundPairs2885)
          to label %invoke.cont2886 unwind label %lpad2300

invoke.cont2886:                                  ; preds = %if.end2884
  %conv2888 = trunc i64 %call2887 to i32
  store i32 %conv2888, ptr %nCompoundsPairs, align 4
  %1272 = load i32, ptr %nCompoundsPairs, align 4
  %tobool2889 = icmp ne i32 %1272, 0
  br i1 %tobool2889, label %if.then2890, label %if.end2976

if.then2890:                                      ; preds = %invoke.cont2886
  %arrayinit.begin2892 = getelementptr inbounds [13 x %struct.b3BufferInfoCL], ptr %bInfo2891, i64 0, i64 0
  %m_gpuCompoundPairs2893 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 32
  %call2895 = invoke noundef ptr @_ZNK13b3OpenCLArrayI25b3CompoundOverlappingPairE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuCompoundPairs2893)
          to label %invoke.cont2894 unwind label %lpad2300

invoke.cont2894:                                  ; preds = %if.then2890
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.begin2892, ptr noundef %call2895, i1 noundef zeroext true)
          to label %invoke.cont2896 unwind label %lpad2300

invoke.cont2896:                                  ; preds = %invoke.cont2894
  %arrayinit.element2897 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.begin2892, i64 1
  %1273 = load ptr, ptr %bodyBuf.addr, align 8
  %call2899 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1273)
          to label %invoke.cont2898 unwind label %lpad2300

invoke.cont2898:                                  ; preds = %invoke.cont2896
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2897, ptr noundef %call2899, i1 noundef zeroext true)
          to label %invoke.cont2900 unwind label %lpad2300

invoke.cont2900:                                  ; preds = %invoke.cont2898
  %arrayinit.element2901 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2897, i64 1
  %1274 = load ptr, ptr %gpuCollidables.addr, align 8
  %call2903 = invoke noundef ptr @_ZNK13b3OpenCLArrayI12b3CollidableE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1274)
          to label %invoke.cont2902 unwind label %lpad2300

invoke.cont2902:                                  ; preds = %invoke.cont2900
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2901, ptr noundef %call2903, i1 noundef zeroext true)
          to label %invoke.cont2904 unwind label %lpad2300

invoke.cont2904:                                  ; preds = %invoke.cont2902
  %arrayinit.element2905 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2901, i64 1
  %1275 = load ptr, ptr %convexData.addr, align 8
  %call2907 = invoke noundef ptr @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1275)
          to label %invoke.cont2906 unwind label %lpad2300

invoke.cont2906:                                  ; preds = %invoke.cont2904
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2905, ptr noundef %call2907, i1 noundef zeroext true)
          to label %invoke.cont2908 unwind label %lpad2300

invoke.cont2908:                                  ; preds = %invoke.cont2906
  %arrayinit.element2909 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2905, i64 1
  %1276 = load ptr, ptr %gpuVertices.addr, align 8
  %call2911 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1276)
          to label %invoke.cont2910 unwind label %lpad2300

invoke.cont2910:                                  ; preds = %invoke.cont2908
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2909, ptr noundef %call2911, i1 noundef zeroext true)
          to label %invoke.cont2912 unwind label %lpad2300

invoke.cont2912:                                  ; preds = %invoke.cont2910
  %arrayinit.element2913 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2909, i64 1
  %1277 = load ptr, ptr %gpuUniqueEdges.addr, align 8
  %call2915 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1277)
          to label %invoke.cont2914 unwind label %lpad2300

invoke.cont2914:                                  ; preds = %invoke.cont2912
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2913, ptr noundef %call2915, i1 noundef zeroext true)
          to label %invoke.cont2916 unwind label %lpad2300

invoke.cont2916:                                  ; preds = %invoke.cont2914
  %arrayinit.element2917 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2913, i64 1
  %1278 = load ptr, ptr %gpuFaces.addr, align 8
  %call2919 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3GpuFaceE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1278)
          to label %invoke.cont2918 unwind label %lpad2300

invoke.cont2918:                                  ; preds = %invoke.cont2916
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2917, ptr noundef %call2919, i1 noundef zeroext true)
          to label %invoke.cont2920 unwind label %lpad2300

invoke.cont2920:                                  ; preds = %invoke.cont2918
  %arrayinit.element2921 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2917, i64 1
  %1279 = load ptr, ptr %gpuIndices.addr, align 8
  %call2923 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1279)
          to label %invoke.cont2922 unwind label %lpad2300

invoke.cont2922:                                  ; preds = %invoke.cont2920
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2921, ptr noundef %call2923, i1 noundef zeroext true)
          to label %invoke.cont2924 unwind label %lpad2300

invoke.cont2924:                                  ; preds = %invoke.cont2922
  %arrayinit.element2925 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2921, i64 1
  %1280 = load ptr, ptr %gpuChildShapes.addr, align 8
  %call2927 = invoke noundef ptr @_ZNK13b3OpenCLArrayI15b3GpuChildShapeE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1280)
          to label %invoke.cont2926 unwind label %lpad2300

invoke.cont2926:                                  ; preds = %invoke.cont2924
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2925, ptr noundef %call2927, i1 noundef zeroext true)
          to label %invoke.cont2928 unwind label %lpad2300

invoke.cont2928:                                  ; preds = %invoke.cont2926
  %arrayinit.element2929 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2925, i64 1
  %m_gpuCompoundSepNormals2930 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 33
  %call2932 = invoke noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuCompoundSepNormals2930)
          to label %invoke.cont2931 unwind label %lpad2300

invoke.cont2931:                                  ; preds = %invoke.cont2928
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2929, ptr noundef %call2932, i1 noundef zeroext true)
          to label %invoke.cont2933 unwind label %lpad2300

invoke.cont2933:                                  ; preds = %invoke.cont2931
  %arrayinit.element2934 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2929, i64 1
  %m_gpuHasCompoundSepNormals2935 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 34
  %call2937 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuHasCompoundSepNormals2935)
          to label %invoke.cont2936 unwind label %lpad2300

invoke.cont2936:                                  ; preds = %invoke.cont2933
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2934, ptr noundef %call2937, i1 noundef zeroext true)
          to label %invoke.cont2938 unwind label %lpad2300

invoke.cont2938:                                  ; preds = %invoke.cont2936
  %arrayinit.element2939 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2934, i64 1
  %1281 = load ptr, ptr %contactOut.addr, align 8
  %call2941 = invoke noundef ptr @_ZNK13b3OpenCLArrayI10b3Contact4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %1281)
          to label %invoke.cont2940 unwind label %lpad2300

invoke.cont2940:                                  ; preds = %invoke.cont2938
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2939, ptr noundef %call2941, i1 noundef zeroext false)
          to label %invoke.cont2942 unwind label %lpad2300

invoke.cont2942:                                  ; preds = %invoke.cont2940
  %arrayinit.element2943 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %arrayinit.element2939, i64 1
  %m_totalContactsOut2944 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %call2946 = invoke noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut2944)
          to label %invoke.cont2945 unwind label %lpad2300

invoke.cont2945:                                  ; preds = %invoke.cont2942
  invoke void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %arrayinit.element2943, ptr noundef %call2946, i1 noundef zeroext false)
          to label %invoke.cont2947 unwind label %lpad2300

invoke.cont2947:                                  ; preds = %invoke.cont2945
  %m_queue2949 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %1282 = load ptr, ptr %m_queue2949, align 8
  %m_clipCompoundsHullHullKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 15
  %1283 = load ptr, ptr %m_clipCompoundsHullHullKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher2948, ptr noundef %1282, ptr noundef %1283, ptr noundef @.str.65)
          to label %invoke.cont2950 unwind label %lpad2300

invoke.cont2950:                                  ; preds = %invoke.cont2947
  %arraydecay2951 = getelementptr inbounds [13 x %struct.b3BufferInfoCL], ptr %bInfo2891, i64 0, i64 0
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher2948, ptr noundef %arraydecay2951, i32 noundef 13)
          to label %invoke.cont2953 unwind label %lpad2952

invoke.cont2953:                                  ; preds = %invoke.cont2950
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher2948, ptr noundef nonnull align 4 dereferenceable(4) %nCompoundsPairs)
          to label %invoke.cont2954 unwind label %lpad2952

invoke.cont2954:                                  ; preds = %invoke.cont2953
  invoke void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %launcher2948, ptr noundef nonnull align 4 dereferenceable(4) %maxContactCapacity.addr)
          to label %invoke.cont2955 unwind label %lpad2952

invoke.cont2955:                                  ; preds = %invoke.cont2954
  %1284 = load i32, ptr %nCompoundsPairs, align 4
  store i32 %1284, ptr %num2956, align 4
  %1285 = load i32, ptr %num2956, align 4
  invoke void @_ZN12b3LauncherCL8launch1DEii(ptr noundef nonnull align 8 dereferenceable(112) %launcher2948, i32 noundef %1285, i32 noundef 64)
          to label %invoke.cont2957 unwind label %lpad2952

invoke.cont2957:                                  ; preds = %invoke.cont2955
  %1286 = load ptr, ptr @__clewFinish, align 8
  %m_queue2958 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 3
  %1287 = load ptr, ptr %m_queue2958, align 8
  %call2960 = invoke i32 %1286(ptr noundef %1287)
          to label %invoke.cont2959 unwind label %lpad2952

invoke.cont2959:                                  ; preds = %invoke.cont2957
  %m_totalContactsOut2961 = getelementptr inbounds %struct.GpuSatCollision, ptr %this1, i32 0, i32 25
  %call2963 = invoke noundef i32 @_ZNK13b3OpenCLArrayIiE2atEm(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut2961, i64 noundef 0)
          to label %invoke.cont2962 unwind label %lpad2952

invoke.cont2962:                                  ; preds = %invoke.cont2959
  %1288 = load ptr, ptr %nContacts.addr, align 8
  store i32 %call2963, ptr %1288, align 4
  %1289 = load ptr, ptr %nContacts.addr, align 8
  %1290 = load i32, ptr %1289, align 4
  %1291 = load i32, ptr %maxContactCapacity.addr, align 4
  %cmp2964 = icmp sgt i32 %1290, %1291
  br i1 %cmp2964, label %if.then2965, label %if.end2971

if.then2965:                                      ; preds = %invoke.cont2962
  br label %do.body2966

do.body2966:                                      ; preds = %if.then2965
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.31, i32 noundef 4397)
          to label %invoke.cont2967 unwind label %lpad2952

invoke.cont2967:                                  ; preds = %do.body2966
  %1292 = load ptr, ptr %nContacts.addr, align 8
  %1293 = load i32, ptr %1292, align 4
  %1294 = load i32, ptr %maxContactCapacity.addr, align 4
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.41, i32 noundef %1293, i32 noundef %1294)
          to label %invoke.cont2968 unwind label %lpad2952

invoke.cont2968:                                  ; preds = %invoke.cont2967
  br label %do.cond2969

do.cond2969:                                      ; preds = %invoke.cont2968
  br label %do.end2970

do.end2970:                                       ; preds = %do.cond2969
  %1295 = load i32, ptr %maxContactCapacity.addr, align 4
  %1296 = load ptr, ptr %nContacts.addr, align 8
  store i32 %1295, ptr %1296, align 4
  br label %if.end2971

lpad2952:                                         ; preds = %if.end2971, %invoke.cont2967, %do.body2966, %invoke.cont2959, %invoke.cont2957, %invoke.cont2955, %invoke.cont2954, %invoke.cont2953, %invoke.cont2950
  %1297 = landingpad { ptr, i32 }
          cleanup
  %1298 = extractvalue { ptr, i32 } %1297, 0
  store ptr %1298, ptr %exn.slot, align 8
  %1299 = extractvalue { ptr, i32 } %1297, 1
  store i32 %1299, ptr %ehselector.slot, align 4
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher2948) #13
  br label %ehcleanup2977

if.end2971:                                       ; preds = %do.end2970, %invoke.cont2962
  %1300 = load ptr, ptr %contactOut.addr, align 8
  %1301 = load ptr, ptr %nContacts.addr, align 8
  %1302 = load i32, ptr %1301, align 4
  %conv2972 = sext i32 %1302 to i64
  %call2974 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI10b3Contact4E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %1300, i64 noundef %conv2972, i1 noundef zeroext true)
          to label %invoke.cont2973 unwind label %lpad2952

invoke.cont2973:                                  ; preds = %if.end2971
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher2948) #13
  br label %if.end2976

if.end2976:                                       ; preds = %invoke.cont2973, %invoke.cont2886
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile2294) #13
  br label %if.end2978

ehcleanup2977:                                    ; preds = %lpad2952, %lpad2859, %ehcleanup2798, %ehcleanup2725, %ehcleanup2661, %ehcleanup2608, %ehcleanup2544, %ehcleanup2395, %lpad2300
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile2294) #13
  br label %ehcleanup2980

if.end2978:                                       ; preds = %if.end2976, %if.end2291
  br label %if.end2979

if.end2979:                                       ; preds = %if.end2978, %if.end1937
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile56) #13
  br label %return

return:                                           ; preds = %if.end2979, %if.then
  ret void

ehcleanup2980:                                    ; preds = %ehcleanup2977, %ehcleanup2289, %ehcleanup2201, %ehcleanup2124, %ehcleanup2066, %ehcleanup2015, %ehcleanup1935, %ehcleanup1850, %ehcleanup1701, %ehcleanup1615, %ehcleanup1525, %ehcleanup1399, %ehcleanup1322, %ehcleanup1261, %ehcleanup1189, %ehcleanup1081, %ehcleanup977, %ehcleanup884, %ehcleanup443, %ehcleanup378, %ehcleanup316, %ehcleanup242, %ehcleanup172, %lpad58
  call void @_ZN13b3ProfileZoneD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %__profile56) #13
  br label %eh.resume

eh.resume:                                        ; preds = %ehcleanup2980, %ehcleanup
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val2981 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val2981
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayIiE19copyFromHostPointerEPKimmb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %src, i64 noundef %numElems, i64 noundef %destFirstElem, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %src.addr = alloca ptr, align 8
  %numElems.addr = alloca i64, align 8
  %destFirstElem.addr = alloca i64, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %status = alloca i32, align 4
  %sizeInBytes = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %src, ptr %src.addr, align 8
  store i64 %numElems, ptr %numElems.addr, align 8
  store i64 %destFirstElem, ptr %destFirstElem.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %numElems.addr, align 8
  %1 = load i64, ptr %destFirstElem.addr, align 8
  %add = add i64 %0, %1
  %tobool = icmp ne i64 %add, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, ptr %status, align 4
  %2 = load i64, ptr %numElems.addr, align 8
  %mul = mul i64 4, %2
  store i64 %mul, ptr %sizeInBytes, align 8
  %3 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 5
  %4 = load ptr, ptr %m_commandQueue, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 3
  %5 = load ptr, ptr %m_clBuffer, align 8
  %6 = load i64, ptr %destFirstElem.addr, align 8
  %mul2 = mul i64 4, %6
  %7 = load i64, ptr %sizeInBytes, align 8
  %8 = load ptr, ptr %src.addr, align 8
  %call = call i32 %3(ptr noundef %4, ptr noundef %5, i32 noundef 0, i64 noundef %mul2, i64 noundef %7, ptr noundef %8, i32 noundef 0, ptr noundef null, ptr noundef null)
  store i32 %call, ptr %status, align 4
  %9 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool3 = trunc i8 %9 to i1
  br i1 %tobool3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %10 = load ptr, ptr @__clewFinish, align 8
  %m_commandQueue5 = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 5
  %11 = load ptr, ptr %m_commandQueue5, align 8
  %call6 = call i32 %10(ptr noundef %11)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  br label %if.end7

if.else:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.else
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.75, i32 noundef 258)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.77)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %if.end7

if.end7:                                          ; preds = %do.end, %if.end
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK13b3OpenCLArrayI6b3Int4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this1, i32 0, i32 3
  %0 = load ptr, ptr %m_clBuffer, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN14b3BufferInfoCLC2EP7_cl_memb(ptr noundef nonnull align 8 dereferenceable(9) %this, ptr noundef %buff, i1 noundef zeroext %isReadOnly) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %buff.addr = alloca ptr, align 8
  %isReadOnly.addr = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  store ptr %buff, ptr %buff.addr, align 8
  %frombool = zext i1 %isReadOnly to i8
  store i8 %frombool, ptr %isReadOnly.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %m_clBuffer = getelementptr inbounds %struct.b3BufferInfoCL, ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %buff.addr, align 8
  store ptr %0, ptr %m_clBuffer, align 8
  %m_isReadOnly = getelementptr inbounds %struct.b3BufferInfoCL, ptr %this1, i32 0, i32 1
  %1 = load i8, ptr %isReadOnly.addr, align 1
  %tobool = trunc i8 %1 to i1
  %frombool2 = zext i1 %tobool to i8
  store i8 %frombool2, ptr %m_isReadOnly, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.72, ptr %this1, i32 0, i32 3
  %0 = load ptr, ptr %m_clBuffer, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK13b3OpenCLArrayI12b3CollidableE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.74, ptr %this1, i32 0, i32 3
  %0 = load ptr, ptr %m_clBuffer, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.76, ptr %this1, i32 0, i32 3
  %0 = load ptr, ptr %m_clBuffer, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK13b3OpenCLArrayI9b3Vector3E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 3
  %0 = load ptr, ptr %m_clBuffer, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK13b3OpenCLArrayI9b3GpuFaceE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.78, ptr %this1, i32 0, i32 3
  %0 = load ptr, ptr %m_clBuffer, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK13b3OpenCLArrayIiE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 3
  %0 = load ptr, ptr %m_clBuffer, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK13b3OpenCLArrayI10b3Contact4E11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this1, i32 0, i32 3
  %0 = load ptr, ptr %m_clBuffer, align 8
  ret ptr %0
}

declare void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112), ptr noundef, ptr noundef, ptr noundef) unnamed_addr #5

declare void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112), ptr noundef, i32 noundef) #5

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN12b3LauncherCL8setConstIiEEvRKT_(ptr noundef nonnull align 8 dereferenceable(112) %this, ptr noundef nonnull align 4 dereferenceable(4) %consts) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %consts.addr = alloca ptr, align 8
  %sz = alloca i32, align 4
  %kernelArg = alloca %struct.b3KernelArgData, align 16
  %destArg = alloca ptr, align 8
  %status = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %consts, ptr %consts.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store i32 4, ptr %sz, align 4
  %m_enableSerialization = getelementptr inbounds %class.b3LauncherCL, ptr %this1, i32 0, i32 7
  %0 = load i8, ptr %m_enableSerialization, align 4
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %m_idx = getelementptr inbounds %class.b3LauncherCL, ptr %this1, i32 0, i32 3
  %1 = load i32, ptr %m_idx, align 8
  %m_argIndex = getelementptr inbounds %struct.b3KernelArgData, ptr %kernelArg, i32 0, i32 1
  store i32 %1, ptr %m_argIndex, align 4
  %m_isBuffer = getelementptr inbounds %struct.b3KernelArgData, ptr %kernelArg, i32 0, i32 0
  store i32 0, ptr %m_isBuffer, align 16
  %2 = getelementptr inbounds %struct.b3KernelArgData, ptr %kernelArg, i32 0, i32 4
  %arraydecay = getelementptr inbounds [16 x i8], ptr %2, i64 0, i64 0
  store ptr %arraydecay, ptr %destArg, align 8
  %3 = load ptr, ptr %consts.addr, align 8
  %4 = load i32, ptr %3, align 4
  %5 = load ptr, ptr %destArg, align 8
  store i32 %4, ptr %5, align 4
  %m_argSizeInBytes = getelementptr inbounds %struct.b3KernelArgData, ptr %kernelArg, i32 0, i32 2
  store i32 4, ptr %m_argSizeInBytes, align 8
  %m_kernelArguments = getelementptr inbounds %class.b3LauncherCL, ptr %this1, i32 0, i32 5
  call void @_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(25) %m_kernelArguments, ptr noundef nonnull align 16 dereferenceable(32) %kernelArg)
  %m_serializationSizeInBytes = getelementptr inbounds %class.b3LauncherCL, ptr %this1, i32 0, i32 6
  %6 = load i32, ptr %m_serializationSizeInBytes, align 8
  %conv = sext i32 %6 to i64
  %add = add i64 %conv, 32
  %conv2 = trunc i64 %add to i32
  store i32 %conv2, ptr %m_serializationSizeInBytes, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load ptr, ptr @__clewSetKernelArg, align 8
  %m_kernel = getelementptr inbounds %class.b3LauncherCL, ptr %this1, i32 0, i32 2
  %8 = load ptr, ptr %m_kernel, align 8
  %m_idx3 = getelementptr inbounds %class.b3LauncherCL, ptr %this1, i32 0, i32 3
  %9 = load i32, ptr %m_idx3, align 8
  %inc = add nsw i32 %9, 1
  store i32 %inc, ptr %m_idx3, align 8
  %10 = load i32, ptr %sz, align 4
  %conv4 = sext i32 %10 to i64
  %11 = load ptr, ptr %consts.addr, align 8
  %call = call i32 %7(ptr noundef %8, i32 noundef %9, i64 noundef %conv4, ptr noundef %11)
  store i32 %call, ptr %status, align 4
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN12b3LauncherCL8launch1DEii(ptr noundef nonnull align 8 dereferenceable(112) %this, i32 noundef %numThreads, i32 noundef %localSize) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %numThreads.addr = alloca i32, align 4
  %localSize.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %numThreads, ptr %numThreads.addr, align 4
  store i32 %localSize, ptr %localSize.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %numThreads.addr, align 4
  %1 = load i32, ptr %localSize.addr, align 4
  call void @_ZN12b3LauncherCL8launch2DEiiii(ptr noundef nonnull align 8 dereferenceable(112) %this1, i32 noundef %0, i32 noundef 1, i32 noundef %1, i32 noundef 1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i32 @_ZNK13b3OpenCLArrayIiE2atEm(ptr noundef nonnull align 8 dereferenceable(50) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %elem = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  call void @_ZNK13b3OpenCLArrayIiE17copyToHostPointerEPimmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, ptr noundef %elem, i64 noundef 1, i64 noundef %0, i1 noundef zeroext true)
  %1 = load i32, ptr %elem, align 4
  ret i32 %1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN13b3OpenCLArrayI10b3Contact4E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %this, i64 noundef %newsize, i1 noundef zeroext %copyOldContents) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  %copyOldContents.addr = alloca i8, align 1
  %result = alloca i8, align 1
  %curSize = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  %frombool = zext i1 %copyOldContents to i8
  store i8 %frombool, ptr %copyOldContents.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  store i8 1, ptr %result, align 1
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI10b3Contact4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  store i64 %call, ptr %curSize, align 8
  %0 = load i64, ptr %newsize.addr, align 8
  %1 = load i64, ptr %curSize, align 8
  %cmp = icmp ult i64 %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end7

if.else:                                          ; preds = %entry
  %2 = load i64, ptr %newsize.addr, align 8
  %call2 = call noundef i64 @_ZNK13b3OpenCLArrayI10b3Contact4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %cmp3 = icmp ugt i64 %2, %call2
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %3 = load i64, ptr %newsize.addr, align 8
  %4 = load i8, ptr %copyOldContents.addr, align 1
  %tobool = trunc i8 %4 to i1
  %call5 = call noundef zeroext i1 @_ZN13b3OpenCLArrayI10b3Contact4E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, i64 noundef %3, i1 noundef zeroext %tobool)
  %frombool6 = zext i1 %call5 to i8
  store i8 %frombool6, ptr %result, align 1
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.else
  br label %if.end7

if.end7:                                          ; preds = %if.end, %if.then
  %5 = load i8, ptr %result, align 1
  %tobool8 = trunc i8 %5 to i1
  br i1 %tobool8, label %if.then9, label %if.else10

if.then9:                                         ; preds = %if.end7
  %6 = load i64, ptr %newsize.addr, align 8
  %m_size = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this1, i32 0, i32 1
  store i64 %6, ptr %m_size, align 8
  br label %if.end12

if.else10:                                        ; preds = %if.end7
  %m_size11 = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this1, i32 0, i32 1
  store i64 0, ptr %m_size11, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.else10, %if.then9
  %7 = load i8, ptr %result, align 1
  %tobool13 = trunc i8 %7 to i1
  ret i1 %tobool13
}

; Function Attrs: nounwind
declare void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112)) unnamed_addr #10

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN13b3OpenCLArrayIiE6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %this, i64 noundef %newsize, i1 noundef zeroext %copyOldContents) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  %copyOldContents.addr = alloca i8, align 1
  %result = alloca i8, align 1
  %curSize = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  %frombool = zext i1 %copyOldContents to i8
  store i8 %frombool, ptr %copyOldContents.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  store i8 1, ptr %result, align 1
  %call = call noundef i64 @_ZNK13b3OpenCLArrayIiE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  store i64 %call, ptr %curSize, align 8
  %0 = load i64, ptr %newsize.addr, align 8
  %1 = load i64, ptr %curSize, align 8
  %cmp = icmp ult i64 %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end7

if.else:                                          ; preds = %entry
  %2 = load i64, ptr %newsize.addr, align 8
  %call2 = call noundef i64 @_ZNK13b3OpenCLArrayIiE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %cmp3 = icmp ugt i64 %2, %call2
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %3 = load i64, ptr %newsize.addr, align 8
  %4 = load i8, ptr %copyOldContents.addr, align 1
  %tobool = trunc i8 %4 to i1
  %call5 = call noundef zeroext i1 @_ZN13b3OpenCLArrayIiE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, i64 noundef %3, i1 noundef zeroext %tobool)
  %frombool6 = zext i1 %call5 to i8
  store i8 %frombool6, ptr %result, align 1
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.else
  br label %if.end7

if.end7:                                          ; preds = %if.end, %if.then
  %5 = load i8, ptr %result, align 1
  %tobool8 = trunc i8 %5 to i1
  br i1 %tobool8, label %if.then9, label %if.else10

if.then9:                                         ; preds = %if.end7
  %6 = load i64, ptr %newsize.addr, align 8
  %m_size = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 1
  store i64 %6, ptr %m_size, align 8
  br label %if.end12

if.else10:                                        ; preds = %if.end7
  %m_size11 = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 1
  store i64 0, ptr %m_size11, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.else10, %if.then9
  %7 = load i8, ptr %result, align 1
  %tobool13 = trunc i8 %7 to i1
  ret i1 %tobool13
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %this, i64 noundef %newsize, i1 noundef zeroext %copyOldContents) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  %copyOldContents.addr = alloca i8, align 1
  %result = alloca i8, align 1
  %curSize = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  %frombool = zext i1 %copyOldContents to i8
  store i8 %frombool, ptr %copyOldContents.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  store i8 1, ptr %result, align 1
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI25b3CompoundOverlappingPairE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  store i64 %call, ptr %curSize, align 8
  %0 = load i64, ptr %newsize.addr, align 8
  %1 = load i64, ptr %curSize, align 8
  %cmp = icmp ult i64 %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end7

if.else:                                          ; preds = %entry
  %2 = load i64, ptr %newsize.addr, align 8
  %call2 = call noundef i64 @_ZNK13b3OpenCLArrayI25b3CompoundOverlappingPairE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %cmp3 = icmp ugt i64 %2, %call2
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %3 = load i64, ptr %newsize.addr, align 8
  %4 = load i8, ptr %copyOldContents.addr, align 1
  %tobool = trunc i8 %4 to i1
  %call5 = call noundef zeroext i1 @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, i64 noundef %3, i1 noundef zeroext %tobool)
  %frombool6 = zext i1 %call5 to i8
  store i8 %frombool6, ptr %result, align 1
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.else
  br label %if.end7

if.end7:                                          ; preds = %if.end, %if.then
  %5 = load i8, ptr %result, align 1
  %tobool8 = trunc i8 %5 to i1
  br i1 %tobool8, label %if.then9, label %if.else10

if.then9:                                         ; preds = %if.end7
  %6 = load i64, ptr %newsize.addr, align 8
  %m_size = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 1
  store i64 %6, ptr %m_size, align 8
  br label %if.end12

if.else10:                                        ; preds = %if.end7
  %m_size11 = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 1
  store i64 0, ptr %m_size11, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.else10, %if.then9
  %7 = load i8, ptr %result, align 1
  %tobool13 = trunc i8 %7 to i1
  ret i1 %tobool13
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN13b3OpenCLArrayIfE6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %this, i64 noundef %newsize, i1 noundef zeroext %copyOldContents) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  %copyOldContents.addr = alloca i8, align 1
  %result = alloca i8, align 1
  %curSize = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  %frombool = zext i1 %copyOldContents to i8
  store i8 %frombool, ptr %copyOldContents.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  store i8 1, ptr %result, align 1
  %call = call noundef i64 @_ZNK13b3OpenCLArrayIfE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  store i64 %call, ptr %curSize, align 8
  %0 = load i64, ptr %newsize.addr, align 8
  %1 = load i64, ptr %curSize, align 8
  %cmp = icmp ult i64 %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end7

if.else:                                          ; preds = %entry
  %2 = load i64, ptr %newsize.addr, align 8
  %call2 = call noundef i64 @_ZNK13b3OpenCLArrayIfE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %cmp3 = icmp ugt i64 %2, %call2
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %3 = load i64, ptr %newsize.addr, align 8
  %4 = load i8, ptr %copyOldContents.addr, align 1
  %tobool = trunc i8 %4 to i1
  %call5 = call noundef zeroext i1 @_ZN13b3OpenCLArrayIfE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, i64 noundef %3, i1 noundef zeroext %tobool)
  %frombool6 = zext i1 %call5 to i8
  store i8 %frombool6, ptr %result, align 1
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.else
  br label %if.end7

if.end7:                                          ; preds = %if.end, %if.then
  %5 = load i8, ptr %result, align 1
  %tobool8 = trunc i8 %5 to i1
  br i1 %tobool8, label %if.then9, label %if.else10

if.then9:                                         ; preds = %if.end7
  %6 = load i64, ptr %newsize.addr, align 8
  %m_size = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this1, i32 0, i32 1
  store i64 %6, ptr %m_size, align 8
  br label %if.end12

if.else10:                                        ; preds = %if.end7
  %m_size11 = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this1, i32 0, i32 1
  store i64 0, ptr %m_size11, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.else10, %if.then9
  %7 = load i8, ptr %result, align 1
  %tobool13 = trunc i8 %7 to i1
  ret i1 %tobool13
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK13b3OpenCLArrayI6b3AabbE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.90, ptr %this1, i32 0, i32 3
  %0 = load ptr, ptr %m_clBuffer, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK13b3OpenCLArrayIfE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this1, i32 0, i32 3
  %0 = load ptr, ptr %m_clBuffer, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI6b3Int4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %destArray, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destArray.addr = alloca ptr, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %ref.tmp = alloca %struct.b3Int4, align 16
  store ptr %this, ptr %this.addr, align 8
  store ptr %destArray, ptr %destArray.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %destArray.addr, align 8
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI6b3Int4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %conv = trunc i64 %call to i32
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp, i8 0, i64 16, i1 false)
  call void @_ZN20b3AlignedObjectArrayI6b3Int4E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %0, i32 noundef %conv, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp)
  %call2 = call noundef i64 @_ZNK13b3OpenCLArrayI6b3Int4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %tobool = icmp ne i64 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %destArray.addr, align 8
  %call3 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI6b3Int4EixEi(ptr noundef nonnull align 8 dereferenceable(25) %1, i32 noundef 0)
  %call4 = call noundef i64 @_ZNK13b3OpenCLArrayI6b3Int4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %2 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool5 = trunc i8 %2 to i1
  call void @_ZNK13b3OpenCLArrayI6b3Int4E17copyToHostPointerEPS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, ptr noundef %call3, i64 noundef %call4, i64 noundef 0, i1 noundef zeroext %tobool5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this1, i32 0, i32 0
  call void @_ZN18b3AlignedAllocatorI15b3RigidBodyDataLj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator)
  call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %destArray, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destArray.addr = alloca ptr, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %ref.tmp = alloca %struct.b3RigidBodyData, align 16
  store ptr %this, ptr %this.addr, align 8
  store ptr %destArray, ptr %destArray.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %destArray.addr, align 8
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %conv = trunc i64 %call to i32
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp, i8 0, i64 80, i1 false)
  call void @_ZN15b3RigidBodyDataC2Ev(ptr noundef nonnull align 16 dereferenceable(80) %ref.tmp)
  call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %0, i32 noundef %conv, ptr noundef nonnull align 16 dereferenceable(80) %ref.tmp)
  %call2 = call noundef i64 @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %tobool = icmp ne i64 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %destArray.addr, align 8
  %call3 = call noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %1, i32 noundef 0)
  %call4 = call noundef i64 @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %2 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool5 = trunc i8 %2 to i1
  call void @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE17copyToHostPointerEPS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, ptr noundef %call3, i64 noundef %call4, i64 noundef 0, i1 noundef zeroext %tobool5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI12b3CollidableEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this1, i32 0, i32 0
  call void @_ZN18b3AlignedAllocatorI12b3CollidableLj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator)
  call void @_ZN20b3AlignedObjectArrayI12b3CollidableE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI12b3CollidableE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %destArray, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destArray.addr = alloca ptr, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %ref.tmp = alloca %struct.b3Collidable, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %destArray, ptr %destArray.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %destArray.addr, align 8
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI12b3CollidableE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %conv = trunc i64 %call to i32
  call void @llvm.memset.p0.i64(ptr align 4 %ref.tmp, i8 0, i64 16, i1 false)
  call void @_ZN20b3AlignedObjectArrayI12b3CollidableE6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %0, i32 noundef %conv, ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp)
  %call2 = call noundef i64 @_ZNK13b3OpenCLArrayI12b3CollidableE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %tobool = icmp ne i64 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %destArray.addr, align 8
  %call3 = call noundef nonnull align 4 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI12b3CollidableEixEi(ptr noundef nonnull align 8 dereferenceable(25) %1, i32 noundef 0)
  %call4 = call noundef i64 @_ZNK13b3OpenCLArrayI12b3CollidableE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %2 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool5 = trunc i8 %2 to i1
  call void @_ZNK13b3OpenCLArrayI12b3CollidableE17copyToHostPointerEPS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, ptr noundef %call3, i64 noundef %call4, i64 noundef 0, i1 noundef zeroext %tobool5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this1, i32 0, i32 0
  call void @_ZN18b3AlignedAllocatorI15b3GpuChildShapeLj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator)
  call void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI15b3GpuChildShapeE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %destArray, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destArray.addr = alloca ptr, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %ref.tmp = alloca %struct.b3GpuChildShape, align 16
  store ptr %this, ptr %this.addr, align 8
  store ptr %destArray, ptr %destArray.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %destArray.addr, align 8
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI15b3GpuChildShapeE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %conv = trunc i64 %call to i32
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp, i8 0, i64 48, i1 false)
  call void @_ZN15b3GpuChildShapeC2Ev(ptr noundef nonnull align 16 dereferenceable(48) %ref.tmp)
  call void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %0, i32 noundef %conv, ptr noundef nonnull align 16 dereferenceable(48) %ref.tmp)
  %call2 = call noundef i64 @_ZNK13b3OpenCLArrayI15b3GpuChildShapeE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %tobool = icmp ne i64 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %destArray.addr, align 8
  %call3 = call noundef nonnull align 16 dereferenceable(48) ptr @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeEixEi(ptr noundef nonnull align 8 dereferenceable(25) %1, i32 noundef 0)
  %call4 = call noundef i64 @_ZNK13b3OpenCLArrayI15b3GpuChildShapeE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %2 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool5 = trunc i8 %2 to i1
  call void @_ZNK13b3OpenCLArrayI15b3GpuChildShapeE17copyToHostPointerEPS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, ptr noundef %call3, i64 noundef %call4, i64 noundef 0, i1 noundef zeroext %tobool5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this1, i32 0, i32 0
  call void @_ZN18b3AlignedAllocatorI22b3ConvexPolyhedronDataLj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator)
  call void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %destArray, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destArray.addr = alloca ptr, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %ref.tmp = alloca %struct.b3ConvexPolyhedronData, align 16
  store ptr %this, ptr %this.addr, align 8
  store ptr %destArray, ptr %destArray.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %destArray.addr, align 8
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %conv = trunc i64 %call to i32
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp, i8 0, i64 96, i1 false)
  call void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %0, i32 noundef %conv, ptr noundef nonnull align 16 dereferenceable(96) %ref.tmp)
  %call2 = call noundef i64 @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %tobool = icmp ne i64 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %destArray.addr, align 8
  %call3 = call noundef nonnull align 16 dereferenceable(96) ptr @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %1, i32 noundef 0)
  %call4 = call noundef i64 @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %2 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool5 = trunc i8 %2 to i1
  call void @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE17copyToHostPointerEPS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, ptr noundef %call3, i64 noundef %call4, i64 noundef 0, i1 noundef zeroext %tobool5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %destArray, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destArray.addr = alloca ptr, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %ref.tmp = alloca %class.b3Vector3, align 16
  store ptr %this, ptr %this.addr, align 8
  store ptr %destArray, ptr %destArray.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %destArray.addr, align 8
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI9b3Vector3E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %conv = trunc i64 %call to i32
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp, i8 0, i64 16, i1 false)
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %0, i32 noundef %conv, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp)
  %call2 = call noundef i64 @_ZNK13b3OpenCLArrayI9b3Vector3E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %tobool = icmp ne i64 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %destArray.addr, align 8
  %call3 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3EixEi(ptr noundef nonnull align 8 dereferenceable(25) %1, i32 noundef 0)
  %call4 = call noundef i64 @_ZNK13b3OpenCLArrayI9b3Vector3E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %2 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool5 = trunc i8 %2 to i1
  call void @_ZNK13b3OpenCLArrayI9b3Vector3E17copyToHostPointerEPS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, ptr noundef %call3, i64 noundef %call4, i64 noundef 0, i1 noundef zeroext %tobool5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3GpuFaceEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this1, i32 0, i32 0
  call void @_ZN18b3AlignedAllocatorI9b3GpuFaceLj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator)
  call void @_ZN20b3AlignedObjectArrayI9b3GpuFaceE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI9b3GpuFaceE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %destArray, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destArray.addr = alloca ptr, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %ref.tmp = alloca %struct.b3GpuFace, align 16
  store ptr %this, ptr %this.addr, align 8
  store ptr %destArray, ptr %destArray.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %destArray.addr, align 8
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI9b3GpuFaceE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %conv = trunc i64 %call to i32
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp, i8 0, i64 32, i1 false)
  call void @_ZN20b3AlignedObjectArrayI9b3GpuFaceE6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %0, i32 noundef %conv, ptr noundef nonnull align 16 dereferenceable(32) %ref.tmp)
  %call2 = call noundef i64 @_ZNK13b3OpenCLArrayI9b3GpuFaceE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %tobool = icmp ne i64 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %destArray.addr, align 8
  %call3 = call noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI9b3GpuFaceEixEi(ptr noundef nonnull align 8 dereferenceable(25) %1, i32 noundef 0)
  %call4 = call noundef i64 @_ZNK13b3OpenCLArrayI9b3GpuFaceE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %2 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool5 = trunc i8 %2 to i1
  call void @_ZNK13b3OpenCLArrayI9b3GpuFaceE17copyToHostPointerEPS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, ptr noundef %call3, i64 noundef %call4, i64 noundef 0, i1 noundef zeroext %tobool5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayIiE10copyToHostER20b3AlignedObjectArrayIiEb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %destArray, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destArray.addr = alloca ptr, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %ref.tmp = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %destArray, ptr %destArray.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %destArray.addr, align 8
  %call = call noundef i64 @_ZNK13b3OpenCLArrayIiE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %conv = trunc i64 %call to i32
  store i32 0, ptr %ref.tmp, align 4
  call void @_ZN20b3AlignedObjectArrayIiE6resizeEiRKi(ptr noundef nonnull align 8 dereferenceable(25) %0, i32 noundef %conv, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp)
  %call2 = call noundef i64 @_ZNK13b3OpenCLArrayIiE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %tobool = icmp ne i64 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %destArray.addr, align 8
  %call3 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiEixEi(ptr noundef nonnull align 8 dereferenceable(25) %1, i32 noundef 0)
  %call4 = call noundef i64 @_ZNK13b3OpenCLArrayIiE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %2 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool5 = trunc i8 %2 to i1
  call void @_ZNK13b3OpenCLArrayIiE17copyToHostPointerEPimmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, ptr noundef %call3, i64 noundef %call4, i64 noundef 0, i1 noundef zeroext %tobool5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI10b3Contact4EC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this1, i32 0, i32 0
  call void @_ZN18b3AlignedAllocatorI10b3Contact4Lj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator)
  call void @_ZN20b3AlignedObjectArrayI10b3Contact4E4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI10b3Contact4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %destArray, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destArray.addr = alloca ptr, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %ref.tmp = alloca %struct.b3Contact4, align 16
  store ptr %this, ptr %this.addr, align 8
  store ptr %destArray, ptr %destArray.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %destArray.addr, align 8
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI10b3Contact4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %conv = trunc i64 %call to i32
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp, i8 0, i64 112, i1 false)
  call void @_ZN20b3AlignedObjectArrayI10b3Contact4E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %0, i32 noundef %conv, ptr noundef nonnull align 16 dereferenceable(112) %ref.tmp)
  %call2 = call noundef i64 @_ZNK13b3OpenCLArrayI10b3Contact4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %tobool = icmp ne i64 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %destArray.addr, align 8
  %call3 = call noundef nonnull align 16 dereferenceable(112) ptr @_ZN20b3AlignedObjectArrayI10b3Contact4EixEi(ptr noundef nonnull align 8 dereferenceable(25) %1, i32 noundef 0)
  %call4 = call noundef i64 @_ZNK13b3OpenCLArrayI10b3Contact4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %2 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool5 = trunc i8 %2 to i1
  call void @_ZNK13b3OpenCLArrayI10b3Contact4E17copyToHostPointerEPS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, ptr noundef %call3, i64 noundef %call4, i64 noundef 0, i1 noundef zeroext %tobool5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI10b3Contact4E6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %newsize, ptr noundef nonnull align 16 dereferenceable(112) %fillData) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %newsize.addr = alloca i32, align 4
  %fillData.addr = alloca ptr, align 8
  %curSize = alloca i32, align 4
  %i = alloca i32, align 4
  %i6 = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %newsize, ptr %newsize.addr, align 4
  store ptr %fillData, ptr %fillData.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI10b3Contact4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  store i32 %call, ptr %curSize, align 4
  %0 = load i32, ptr %newsize.addr, align 4
  %1 = load i32, ptr %curSize, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %newsize.addr, align 4
  store i32 %2, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i32, ptr %i, align 4
  %4 = load i32, ptr %curSize, align 4
  %cmp2 = icmp slt i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, ptr %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !77

for.end:                                          ; preds = %for.cond
  br label %if.end17

if.else:                                          ; preds = %entry
  %6 = load i32, ptr %newsize.addr, align 4
  %call3 = call noundef i32 @_ZNK20b3AlignedObjectArrayI10b3Contact4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %cmp4 = icmp sgt i32 %6, %call3
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  %7 = load i32, ptr %newsize.addr, align 4
  call void @_ZN20b3AlignedObjectArrayI10b3Contact4E7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %7)
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.else
  %8 = load i32, ptr %curSize, align 4
  store i32 %8, ptr %i6, align 4
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc14, %if.end
  %9 = load i32, ptr %i6, align 4
  %10 = load i32, ptr %newsize.addr, align 4
  %cmp8 = icmp slt i32 %9, %10
  br i1 %cmp8, label %for.body9, label %for.end16

for.body9:                                        ; preds = %for.cond7
  %m_data10 = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this1, i32 0, i32 5
  %11 = load ptr, ptr %m_data10, align 8
  %12 = load i32, ptr %i6, align 4
  %idxprom11 = sext i32 %12 to i64
  %arrayidx12 = getelementptr inbounds %struct.b3Contact4, ptr %11, i64 %idxprom11
  %call13 = call noundef ptr @_ZN10b3Contact4nwEmPv(i64 noundef 112, ptr noundef %arrayidx12)
  %13 = load ptr, ptr %fillData.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %call13, ptr align 16 %13, i64 112, i1 false)
  br label %for.inc14

for.inc14:                                        ; preds = %for.body9
  %14 = load i32, ptr %i6, align 4
  %inc15 = add nsw i32 %14, 1
  store i32 %inc15, ptr %i6, align 4
  br label %for.cond7, !llvm.loop !78

for.end16:                                        ; preds = %for.cond7
  br label %if.end17

if.end17:                                         ; preds = %for.end16, %for.end
  %15 = load i32, ptr %newsize.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this1, i32 0, i32 2
  store i32 %15, ptr %m_size, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3RigidBodyData, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 4 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI12b3CollidableEixEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3Collidable, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(96) ptr @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataEixEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %class.b3Vector3, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI9b3GpuFaceE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3GpuFace, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 4 dereferenceable(4) ptr @_ZN20b3AlignedObjectArrayIiE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds i32, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i32 @_Z16b3MprPenetrationiiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_PiPfSB_SB_(i32 noundef %pairIndex, i32 noundef %bodyIndexA, i32 noundef %bodyIndexB, ptr noundef %cpuBodyBuf, ptr noundef %cpuConvexData, ptr noundef %cpuCollidables, ptr noundef %cpuVertices, ptr noundef %sepAxis, ptr noundef %hasSepAxis, ptr noundef %depthOut, ptr noundef %dirOut, ptr noundef %posOut) #2 comdat {
entry:
  %retval = alloca i32, align 4
  %pairIndex.addr = alloca i32, align 4
  %bodyIndexA.addr = alloca i32, align 4
  %bodyIndexB.addr = alloca i32, align 4
  %cpuBodyBuf.addr = alloca ptr, align 8
  %cpuConvexData.addr = alloca ptr, align 8
  %cpuCollidables.addr = alloca ptr, align 8
  %cpuVertices.addr = alloca ptr, align 8
  %sepAxis.addr = alloca ptr, align 8
  %hasSepAxis.addr = alloca ptr, align 8
  %depthOut.addr = alloca ptr, align 8
  %dirOut.addr = alloca ptr, align 8
  %posOut.addr = alloca ptr, align 8
  %portal = alloca %struct._b3MprSimplex_t, align 16
  %res = alloca i32, align 4
  %ref.tmp = alloca %class.b3Vector3, align 16
  store i32 %pairIndex, ptr %pairIndex.addr, align 4
  store i32 %bodyIndexA, ptr %bodyIndexA.addr, align 4
  store i32 %bodyIndexB, ptr %bodyIndexB.addr, align 4
  store ptr %cpuBodyBuf, ptr %cpuBodyBuf.addr, align 8
  store ptr %cpuConvexData, ptr %cpuConvexData.addr, align 8
  store ptr %cpuCollidables, ptr %cpuCollidables.addr, align 8
  store ptr %cpuVertices, ptr %cpuVertices.addr, align 8
  store ptr %sepAxis, ptr %sepAxis.addr, align 8
  store ptr %hasSepAxis, ptr %hasSepAxis.addr, align 8
  store ptr %depthOut, ptr %depthOut.addr, align 8
  store ptr %dirOut, ptr %dirOut.addr, align 8
  store ptr %posOut, ptr %posOut.addr, align 8
  %0 = load ptr, ptr %hasSepAxis.addr, align 8
  %1 = load i32, ptr %pairIndex.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds i32, ptr %0, i64 %idxprom
  store i32 0, ptr %arrayidx, align 4
  %2 = load i32, ptr %pairIndex.addr, align 4
  %3 = load i32, ptr %bodyIndexA.addr, align 4
  %4 = load i32, ptr %bodyIndexB.addr, align 4
  %5 = load ptr, ptr %cpuBodyBuf.addr, align 8
  %6 = load ptr, ptr %cpuConvexData.addr, align 8
  %7 = load ptr, ptr %cpuCollidables.addr, align 8
  %8 = load ptr, ptr %cpuVertices.addr, align 8
  %9 = load ptr, ptr %sepAxis.addr, align 8
  %10 = load ptr, ptr %hasSepAxis.addr, align 8
  %call = call noundef i32 @_ZL16b3DiscoverPortaliiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_PiP15_b3MprSimplex_t(i32 noundef %2, i32 noundef %3, i32 noundef %4, ptr noundef %5, ptr noundef %6, ptr noundef %7, ptr noundef %8, ptr noundef %9, ptr noundef %10, ptr noundef %portal)
  store i32 %call, ptr %res, align 4
  %11 = load i32, ptr %res, align 4
  switch i32 %11, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb8
    i32 2, label %sw.bb9
  ]

sw.bb:                                            ; preds = %entry
  %12 = load i32, ptr %pairIndex.addr, align 4
  %13 = load i32, ptr %bodyIndexA.addr, align 4
  %14 = load i32, ptr %bodyIndexB.addr, align 4
  %15 = load ptr, ptr %cpuBodyBuf.addr, align 8
  %16 = load ptr, ptr %cpuConvexData.addr, align 8
  %17 = load ptr, ptr %cpuCollidables.addr, align 8
  %18 = load ptr, ptr %cpuVertices.addr, align 8
  %19 = load ptr, ptr %sepAxis.addr, align 8
  %call1 = call noundef i32 @_ZL14b3RefinePortaliiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_P15_b3MprSimplex_t(i32 noundef %12, i32 noundef %13, i32 noundef %14, ptr noundef %15, ptr noundef %16, ptr noundef %17, ptr noundef %18, ptr noundef %19, ptr noundef %portal)
  store i32 %call1, ptr %res, align 4
  %20 = load i32, ptr %res, align 4
  %cmp = icmp slt i32 %20, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %sw.bb
  %21 = load i32, ptr %pairIndex.addr, align 4
  %22 = load i32, ptr %bodyIndexA.addr, align 4
  %23 = load i32, ptr %bodyIndexB.addr, align 4
  %24 = load ptr, ptr %cpuBodyBuf.addr, align 8
  %25 = load ptr, ptr %cpuConvexData.addr, align 8
  %26 = load ptr, ptr %cpuCollidables.addr, align 8
  %27 = load ptr, ptr %cpuVertices.addr, align 8
  %28 = load ptr, ptr %sepAxis.addr, align 8
  %29 = load ptr, ptr %depthOut.addr, align 8
  %30 = load ptr, ptr %dirOut.addr, align 8
  %31 = load ptr, ptr %posOut.addr, align 8
  call void @_ZL12b3FindPenetriiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_P15_b3MprSimplex_tPfSB_SB_(i32 noundef %21, i32 noundef %22, i32 noundef %23, ptr noundef %24, ptr noundef %25, ptr noundef %26, ptr noundef %27, ptr noundef %28, ptr noundef %portal, ptr noundef %29, ptr noundef %30, ptr noundef %31)
  %32 = load ptr, ptr %hasSepAxis.addr, align 8
  %33 = load i32, ptr %pairIndex.addr, align 4
  %idxprom2 = sext i32 %33 to i64
  %arrayidx3 = getelementptr inbounds i32, ptr %32, i64 %idxprom2
  store i32 1, ptr %arrayidx3, align 4
  %34 = load ptr, ptr %dirOut.addr, align 8
  %call4 = call { <2 x float>, <2 x float> } @_ZngRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %34)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive5 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %35 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive5, i32 0, i32 0
  %36 = extractvalue { <2 x float>, <2 x float> } %call4, 0
  store <2 x float> %36, ptr %35, align 16
  %37 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive5, i32 0, i32 1
  %38 = extractvalue { <2 x float>, <2 x float> } %call4, 1
  store <2 x float> %38, ptr %37, align 8
  %39 = load ptr, ptr %sepAxis.addr, align 8
  %40 = load i32, ptr %pairIndex.addr, align 4
  %idxprom6 = sext i32 %40 to i64
  %arrayidx7 = getelementptr inbounds %class.b3Vector3, ptr %39, i64 %idxprom6
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx7, ptr align 16 %ref.tmp, i64 16, i1 false)
  br label %sw.epilog

sw.bb8:                                           ; preds = %entry
  %41 = load ptr, ptr %depthOut.addr, align 8
  %42 = load ptr, ptr %dirOut.addr, align 8
  %43 = load ptr, ptr %posOut.addr, align 8
  call void @_ZL17b3FindPenetrTouchP15_b3MprSimplex_tPfP9b3Vector3S3_(ptr noundef %portal, ptr noundef %41, ptr noundef %42, ptr noundef %43)
  br label %sw.epilog

sw.bb9:                                           ; preds = %entry
  %44 = load ptr, ptr %depthOut.addr, align 8
  %45 = load ptr, ptr %dirOut.addr, align 8
  %46 = load ptr, ptr %posOut.addr, align 8
  call void @_ZL19b3FindPenetrSegmentP15_b3MprSimplex_tPfP9b3Vector3S3_(ptr noundef %portal, ptr noundef %44, ptr noundef %45, ptr noundef %46)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %47 = load ptr, ptr %hasSepAxis.addr, align 8
  %48 = load i32, ptr %pairIndex.addr, align 4
  %idxprom10 = sext i32 %48 to i64
  %arrayidx11 = getelementptr inbounds i32, ptr %47, i64 %idxprom10
  store i32 0, ptr %arrayidx11, align 4
  store i32 -1, ptr %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %sw.bb9, %sw.bb8, %if.end
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %sw.default, %if.then
  %49 = load i32, ptr %retval, align 4
  ret i32 %49
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(80) ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3RigidBodyData, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #3 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  invoke void @_ZN20b3AlignedObjectArrayI10b3Contact4E5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #14
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayI10b3Contact4E12copyFromHostERK20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %srcArray, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %srcArray.addr = alloca ptr, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %newSize = alloca i64, align 8
  %copyOldContents = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  store ptr %srcArray, ptr %srcArray.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %srcArray.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI10b3Contact4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %0)
  %conv = sext i32 %call to i64
  store i64 %conv, ptr %newSize, align 8
  store i8 0, ptr %copyOldContents, align 1
  %1 = load i64, ptr %newSize, align 8
  %2 = load i8, ptr %copyOldContents, align 1
  %tobool = trunc i8 %2 to i1
  %call2 = call noundef zeroext i1 @_ZN13b3OpenCLArrayI10b3Contact4E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, i64 noundef %1, i1 noundef zeroext %tobool)
  %3 = load i64, ptr %newSize, align 8
  %tobool3 = icmp ne i64 %3, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %srcArray.addr, align 8
  %call4 = call noundef nonnull align 16 dereferenceable(112) ptr @_ZNK20b3AlignedObjectArrayI10b3Contact4EixEi(ptr noundef nonnull align 8 dereferenceable(25) %4, i32 noundef 0)
  %5 = load i64, ptr %newSize, align 8
  %6 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool5 = trunc i8 %6 to i1
  call void @_ZN13b3OpenCLArrayI10b3Contact4E19copyFromHostPointerEPKS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, ptr noundef %call4, i64 noundef %5, i64 noundef 0, i1 noundef zeroext %tobool5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayIiE12copyFromHostERK20b3AlignedObjectArrayIiEb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %srcArray, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %srcArray.addr = alloca ptr, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %newSize = alloca i64, align 8
  %copyOldContents = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  store ptr %srcArray, ptr %srcArray.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %srcArray.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayIiE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %0)
  %conv = sext i32 %call to i64
  store i64 %conv, ptr %newSize, align 8
  store i8 0, ptr %copyOldContents, align 1
  %1 = load i64, ptr %newSize, align 8
  %2 = load i8, ptr %copyOldContents, align 1
  %tobool = trunc i8 %2 to i1
  %call2 = call noundef zeroext i1 @_ZN13b3OpenCLArrayIiE6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, i64 noundef %1, i1 noundef zeroext %tobool)
  %3 = load i64, ptr %newSize, align 8
  %tobool3 = icmp ne i64 %3, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %srcArray.addr, align 8
  %call4 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK20b3AlignedObjectArrayIiEixEi(ptr noundef nonnull align 8 dereferenceable(25) %4, i32 noundef 0)
  %5 = load i64, ptr %newSize, align 8
  %6 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool5 = trunc i8 %6 to i1
  call void @_ZN13b3OpenCLArrayIiE19copyFromHostPointerEPKimmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, ptr noundef %call4, i64 noundef %5, i64 noundef 0, i1 noundef zeroext %tobool5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayI9b3Vector3E12copyFromHostERK20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %srcArray, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %srcArray.addr = alloca ptr, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %newSize = alloca i64, align 8
  %copyOldContents = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  store ptr %srcArray, ptr %srcArray.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %srcArray.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI9b3Vector3E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %0)
  %conv = sext i32 %call to i64
  store i64 %conv, ptr %newSize, align 8
  store i8 0, ptr %copyOldContents, align 1
  %1 = load i64, ptr %newSize, align 8
  %2 = load i8, ptr %copyOldContents, align 1
  %tobool = trunc i8 %2 to i1
  %call2 = call noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, i64 noundef %1, i1 noundef zeroext %tobool)
  %3 = load i64, ptr %newSize, align 8
  %tobool3 = icmp ne i64 %3, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %srcArray.addr, align 8
  %call4 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK20b3AlignedObjectArrayI9b3Vector3EixEi(ptr noundef nonnull align 8 dereferenceable(25) %4, i32 noundef 0)
  %5 = load i64, ptr %newSize, align 8
  %6 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool5 = trunc i8 %6 to i1
  call void @_ZN13b3OpenCLArrayI9b3Vector3E19copyFromHostPointerEPKS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, ptr noundef %call4, i64 noundef %5, i64 noundef 0, i1 noundef zeroext %tobool5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3GpuFaceED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #3 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  invoke void @_ZN20b3AlignedObjectArrayI9b3GpuFaceE5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #14
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #3 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  invoke void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #14
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #3 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  invoke void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #14
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #3 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  invoke void @_ZN20b3AlignedObjectArrayI12b3CollidableE5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #14
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #3 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  invoke void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #14
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK13b3OpenCLArrayI15b3GpuChildShapeE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.96, ptr %this1, i32 0, i32 3
  %0 = load ptr, ptr %m_clBuffer, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK13b3OpenCLArrayI25b3CompoundOverlappingPairE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 3
  %0 = load ptr, ptr %m_clBuffer, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK13b3OpenCLArrayI16b3BvhSubtreeInfoE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.98, ptr %this1, i32 0, i32 3
  %0 = load ptr, ptr %m_clBuffer, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK13b3OpenCLArrayI18b3QuantizedBvhNodeE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.100, ptr %this1, i32 0, i32 3
  %0 = load ptr, ptr %m_clBuffer, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK13b3OpenCLArrayI9b3BvhInfoE11getBufferCLEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.102, ptr %this1, i32 0, i32 3
  %0 = load ptr, ptr %m_clBuffer, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this1, i32 0, i32 0
  call void @_ZN18b3AlignedAllocatorI18b3QuantizedBvhNodeLj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator)
  call void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI18b3QuantizedBvhNodeE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %destArray, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destArray.addr = alloca ptr, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %ref.tmp = alloca %struct.b3QuantizedBvhNode, align 16
  store ptr %this, ptr %this.addr, align 8
  store ptr %destArray, ptr %destArray.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %destArray.addr, align 8
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI18b3QuantizedBvhNodeE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %conv = trunc i64 %call to i32
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp, i8 0, i64 16, i1 false)
  call void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %0, i32 noundef %conv, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp)
  %call2 = call noundef i64 @_ZNK13b3OpenCLArrayI18b3QuantizedBvhNodeE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %tobool = icmp ne i64 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %destArray.addr, align 8
  %call3 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeEixEi(ptr noundef nonnull align 8 dereferenceable(25) %1, i32 noundef 0)
  %call4 = call noundef i64 @_ZNK13b3OpenCLArrayI18b3QuantizedBvhNodeE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %2 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool5 = trunc i8 %2 to i1
  call void @_ZNK13b3OpenCLArrayI18b3QuantizedBvhNodeE17copyToHostPointerEPS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, ptr noundef %call3, i64 noundef %call4, i64 noundef 0, i1 noundef zeroext %tobool5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this1, i32 0, i32 0
  call void @_ZN18b3AlignedAllocatorI16b3BvhSubtreeInfoLj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator)
  call void @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI16b3BvhSubtreeInfoE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %destArray, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destArray.addr = alloca ptr, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %ref.tmp = alloca %class.b3BvhSubtreeInfo, align 16
  store ptr %this, ptr %this.addr, align 8
  store ptr %destArray, ptr %destArray.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %destArray.addr, align 8
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI16b3BvhSubtreeInfoE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %conv = trunc i64 %call to i32
  call void @_ZN16b3BvhSubtreeInfoC2Ev(ptr noundef nonnull align 16 dereferenceable(32) %ref.tmp)
  call void @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %0, i32 noundef %conv, ptr noundef nonnull align 16 dereferenceable(32) %ref.tmp)
  %call2 = call noundef i64 @_ZNK13b3OpenCLArrayI16b3BvhSubtreeInfoE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %tobool = icmp ne i64 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %destArray.addr, align 8
  %call3 = call noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %1, i32 noundef 0)
  %call4 = call noundef i64 @_ZNK13b3OpenCLArrayI16b3BvhSubtreeInfoE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %2 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool5 = trunc i8 %2 to i1
  call void @_ZNK13b3OpenCLArrayI16b3BvhSubtreeInfoE17copyToHostPointerEPS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, ptr noundef %call3, i64 noundef %call4, i64 noundef 0, i1 noundef zeroext %tobool5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3BvhInfoEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this1, i32 0, i32 0
  call void @_ZN18b3AlignedAllocatorI9b3BvhInfoLj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator)
  call void @_ZN20b3AlignedObjectArrayI9b3BvhInfoE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI9b3BvhInfoE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %destArray, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destArray.addr = alloca ptr, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %ref.tmp = alloca %struct.b3BvhInfo, align 16
  store ptr %this, ptr %this.addr, align 8
  store ptr %destArray, ptr %destArray.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %destArray.addr, align 8
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI9b3BvhInfoE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %conv = trunc i64 %call to i32
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp, i8 0, i64 64, i1 false)
  call void @_ZN20b3AlignedObjectArrayI9b3BvhInfoE6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %0, i32 noundef %conv, ptr noundef nonnull align 16 dereferenceable(64) %ref.tmp)
  %call2 = call noundef i64 @_ZNK13b3OpenCLArrayI9b3BvhInfoE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %tobool = icmp ne i64 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %destArray.addr, align 8
  %call3 = call noundef nonnull align 16 dereferenceable(64) ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoEixEi(ptr noundef nonnull align 8 dereferenceable(25) %1, i32 noundef 0)
  %call4 = call noundef i64 @_ZNK13b3OpenCLArrayI9b3BvhInfoE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %2 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool5 = trunc i8 %2 to i1
  call void @_ZNK13b3OpenCLArrayI9b3BvhInfoE17copyToHostPointerEPS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, ptr noundef %call3, i64 noundef %call4, i64 noundef 0, i1 noundef zeroext %tobool5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3AabbEC2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this1, i32 0, i32 0
  call void @_ZN18b3AlignedAllocatorI6b3AabbLj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator)
  call void @_ZN20b3AlignedObjectArrayI6b3AabbE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI6b3AabbE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %destArray, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destArray.addr = alloca ptr, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %ref.tmp = alloca %struct.b3Aabb, align 16
  store ptr %this, ptr %this.addr, align 8
  store ptr %destArray, ptr %destArray.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %destArray.addr, align 8
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI6b3AabbE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %conv = trunc i64 %call to i32
  call void @llvm.memset.p0.i64(ptr align 16 %ref.tmp, i8 0, i64 32, i1 false)
  call void @_ZN20b3AlignedObjectArrayI6b3AabbE6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %0, i32 noundef %conv, ptr noundef nonnull align 16 dereferenceable(32) %ref.tmp)
  %call2 = call noundef i64 @_ZNK13b3OpenCLArrayI6b3AabbE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %tobool = icmp ne i64 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %destArray.addr, align 8
  %call3 = call noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI6b3AabbEixEi(ptr noundef nonnull align 8 dereferenceable(25) %1, i32 noundef 0)
  %call4 = call noundef i64 @_ZNK13b3OpenCLArrayI6b3AabbE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %2 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool5 = trunc i8 %2 to i1
  call void @_ZNK13b3OpenCLArrayI6b3AabbE17copyToHostPointerEPS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, ptr noundef %call3, i64 noundef %call4, i64 noundef 0, i1 noundef zeroext %tobool5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI15b3GpuChildShapeE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this1, i32 0, i32 2
  %0 = load i32, ptr %m_size, align 4
  ret i32 %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(48) ptr @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeEixEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3GpuChildShape, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE19copyFromHostPointerEPKS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %src, i64 noundef %numElems, i64 noundef %destFirstElem, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %src.addr = alloca ptr, align 8
  %numElems.addr = alloca i64, align 8
  %destFirstElem.addr = alloca i64, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %status = alloca i32, align 4
  %sizeInBytes = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %src, ptr %src.addr, align 8
  store i64 %numElems, ptr %numElems.addr, align 8
  store i64 %destFirstElem, ptr %destFirstElem.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %numElems.addr, align 8
  %1 = load i64, ptr %destFirstElem.addr, align 8
  %add = add i64 %0, %1
  %tobool = icmp ne i64 %add, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, ptr %status, align 4
  %2 = load i64, ptr %numElems.addr, align 8
  %mul = mul i64 16, %2
  store i64 %mul, ptr %sizeInBytes, align 8
  %3 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 5
  %4 = load ptr, ptr %m_commandQueue, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 3
  %5 = load ptr, ptr %m_clBuffer, align 8
  %6 = load i64, ptr %destFirstElem.addr, align 8
  %mul2 = mul i64 16, %6
  %7 = load i64, ptr %sizeInBytes, align 8
  %8 = load ptr, ptr %src.addr, align 8
  %call = call i32 %3(ptr noundef %4, ptr noundef %5, i32 noundef 0, i64 noundef %mul2, i64 noundef %7, ptr noundef %8, i32 noundef 0, ptr noundef null, ptr noundef null)
  store i32 %call, ptr %status, align 4
  %9 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool3 = trunc i8 %9 to i1
  br i1 %tobool3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %10 = load ptr, ptr @__clewFinish, align 8
  %m_commandQueue5 = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 5
  %11 = load ptr, ptr %m_commandQueue5, align 8
  %call6 = call i32 %10(ptr noundef %11)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  br label %if.end7

if.else:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.else
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.75, i32 noundef 258)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.77)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %if.end7

if.end7:                                          ; preds = %do.end, %if.end
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3AabbED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #3 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  invoke void @_ZN20b3AlignedObjectArrayI6b3AabbE5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #14
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3BvhInfoED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #3 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  invoke void @_ZN20b3AlignedObjectArrayI9b3BvhInfoE5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #14
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #3 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  invoke void @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #14
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #3 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  invoke void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #14
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayI18b3QuantizedBvhNodeE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3OpenCLArray.100, ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %m_size, align 8
  ret i64 %0
}

declare void @_ZN12b3LauncherCL9setBufferEP7_cl_mem(ptr noundef nonnull align 8 dereferenceable(112), ptr noundef) #5

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI6b3Int4E2atEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3Int4, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 4 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI12b3CollidableE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3Collidable, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI6b3AabbE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3Aabb, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %class.b3BvhSubtreeInfo, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(16) ptr @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3QuantizedBvhNode, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(64) ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3BvhInfo, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayI6b3Int4E12copyFromHostERK20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %srcArray, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %srcArray.addr = alloca ptr, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %newSize = alloca i64, align 8
  %copyOldContents = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  store ptr %srcArray, ptr %srcArray.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %srcArray.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI6b3Int4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %0)
  %conv = sext i32 %call to i64
  store i64 %conv, ptr %newSize, align 8
  store i8 0, ptr %copyOldContents, align 1
  %1 = load i64, ptr %newSize, align 8
  %2 = load i8, ptr %copyOldContents, align 1
  %tobool = trunc i8 %2 to i1
  %call2 = call noundef zeroext i1 @_ZN13b3OpenCLArrayI6b3Int4E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, i64 noundef %1, i1 noundef zeroext %tobool)
  %3 = load i64, ptr %newSize, align 8
  %tobool3 = icmp ne i64 %3, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %srcArray.addr, align 8
  %call4 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK20b3AlignedObjectArrayI6b3Int4EixEi(ptr noundef nonnull align 8 dereferenceable(25) %4, i32 noundef 0)
  %5 = load i64, ptr %newSize, align 8
  %6 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool5 = trunc i8 %6 to i1
  call void @_ZN13b3OpenCLArrayI6b3Int4E19copyFromHostPointerEPKS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, ptr noundef %call4, i64 noundef %5, i64 noundef 0, i1 noundef zeroext %tobool5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN13b3OpenCLArrayI6b3Int4E6resizeEmb(ptr noundef nonnull align 8 dereferenceable(50) %this, i64 noundef %newsize, i1 noundef zeroext %copyOldContents) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %newsize.addr = alloca i64, align 8
  %copyOldContents.addr = alloca i8, align 1
  %result = alloca i8, align 1
  %curSize = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %newsize, ptr %newsize.addr, align 8
  %frombool = zext i1 %copyOldContents to i8
  store i8 %frombool, ptr %copyOldContents.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  store i8 1, ptr %result, align 1
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI6b3Int4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  store i64 %call, ptr %curSize, align 8
  %0 = load i64, ptr %newsize.addr, align 8
  %1 = load i64, ptr %curSize, align 8
  %cmp = icmp ult i64 %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end7

if.else:                                          ; preds = %entry
  %2 = load i64, ptr %newsize.addr, align 8
  %call2 = call noundef i64 @_ZNK13b3OpenCLArrayI6b3Int4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %cmp3 = icmp ugt i64 %2, %call2
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %3 = load i64, ptr %newsize.addr, align 8
  %4 = load i8, ptr %copyOldContents.addr, align 1
  %tobool = trunc i8 %4 to i1
  %call5 = call noundef zeroext i1 @_ZN13b3OpenCLArrayI6b3Int4E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %this1, i64 noundef %3, i1 noundef zeroext %tobool)
  %frombool6 = zext i1 %call5 to i8
  store i8 %frombool6, ptr %result, align 1
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.else
  br label %if.end7

if.end7:                                          ; preds = %if.end, %if.then
  %5 = load i8, ptr %result, align 1
  %tobool8 = trunc i8 %5 to i1
  br i1 %tobool8, label %if.then9, label %if.else10

if.then9:                                         ; preds = %if.end7
  %6 = load i64, ptr %newsize.addr, align 8
  %m_size = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this1, i32 0, i32 1
  store i64 %6, ptr %m_size, align 8
  br label %if.end12

if.else10:                                        ; preds = %if.end7
  %m_size11 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this1, i32 0, i32 1
  store i64 0, ptr %m_size11, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.else10, %if.then9
  %7 = load i8, ptr %result, align 1
  %tobool13 = trunc i8 %7 to i1
  ret i1 %tobool13
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI9b3Vector3E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this1, i32 0, i32 2
  %0 = load i32, ptr %m_size, align 4
  ret i32 %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(48) ptr @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3GpuChildShape, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayI6b3Int4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %m_size, align 8
  ret i64 %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayI9b3Vector3E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %m_size, align 8
  ret i64 %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(96) ptr @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE2atEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN13b3OpenCLArrayI10b3Contact4E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %this, i64 noundef %_Count, i1 noundef zeroext %copyOldContents) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_Count.addr = alloca i64, align 8
  %copyOldContents.addr = alloca i8, align 1
  %result = alloca i8, align 1
  %ciErrNum = alloca i32, align 4
  %memSizeInBytes = alloca i64, align 8
  %buf = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %_Count, ptr %_Count.addr, align 8
  %frombool = zext i1 %copyOldContents to i8
  store i8 %frombool, ptr %copyOldContents.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  store i8 1, ptr %result, align 1
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI10b3Contact4E8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %0 = load i64, ptr %_Count.addr, align 8
  %cmp = icmp ult i64 %call, %0
  br i1 %cmp, label %if.then, label %if.end14

if.then:                                          ; preds = %entry
  %m_allowGrowingCapacity = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this1, i32 0, i32 7
  %1 = load i8, ptr %m_allowGrowingCapacity, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %2 = load i64, ptr %_Count.addr, align 8
  %mul = mul i64 112, %2
  store i64 %mul, ptr %memSizeInBytes, align 8
  %3 = load ptr, ptr @__clewCreateBuffer, align 8
  %m_clContext = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this1, i32 0, i32 4
  %4 = load ptr, ptr %m_clContext, align 8
  %5 = load i64, ptr %memSizeInBytes, align 8
  %call3 = call ptr %3(ptr noundef %4, i64 noundef 1, i64 noundef %5, ptr noundef null, ptr noundef %ciErrNum)
  store ptr %call3, ptr %buf, align 8
  %6 = load i32, ptr %ciErrNum, align 4
  %cmp4 = icmp ne i32 %6, 0
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then2
  br label %do.body

do.body:                                          ; preds = %if.then5
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.75, i32 noundef 166)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.76)
  br label %do.end

do.end:                                           ; preds = %do.body
  store i64 0, ptr %_Count.addr, align 8
  store i8 0, ptr %result, align 1
  br label %if.end

if.end:                                           ; preds = %do.end, %if.then2
  %7 = load i8, ptr %result, align 1
  %tobool6 = trunc i8 %7 to i1
  br i1 %tobool6, label %if.then7, label %if.end12

if.then7:                                         ; preds = %if.end
  %8 = load i8, ptr %copyOldContents.addr, align 1
  %tobool8 = trunc i8 %8 to i1
  br i1 %tobool8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.then7
  %9 = load ptr, ptr %buf, align 8
  %call10 = call noundef i64 @_ZNK13b3OpenCLArrayI10b3Contact4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  call void @_ZNK13b3OpenCLArrayI10b3Contact4E8copyToCLEP7_cl_memmmm(ptr noundef nonnull align 8 dereferenceable(50) %this1, ptr noundef %9, i64 noundef %call10, i64 noundef 0, i64 noundef 0)
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.then7
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %if.end
  call void @_ZN13b3OpenCLArrayI10b3Contact4E10deallocateEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %10 = load ptr, ptr %buf, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this1, i32 0, i32 3
  store ptr %10, ptr %m_clBuffer, align 8
  %11 = load i64, ptr %_Count.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this1, i32 0, i32 2
  store i64 %11, ptr %m_capacity, align 8
  br label %if.end13

if.else:                                          ; preds = %if.then
  call void @_ZN13b3OpenCLArrayI10b3Contact4E10deallocateEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  store i8 0, ptr %result, align 1
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.end12
  br label %if.end14

if.end14:                                         ; preds = %if.end13, %entry
  %12 = load i8, ptr %result, align 1
  %tobool15 = trunc i8 %12 to i1
  ret i1 %tobool15
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayI10b3Contact4E8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this1, i32 0, i32 2
  %0 = load i64, ptr %m_capacity, align 8
  ret i64 %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayI25b3CompoundOverlappingPairE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %m_size, align 8
  ret i64 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_ZmlRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %v1, ptr noundef nonnull align 16 dereferenceable(16) %v2) #2 comdat {
entry:
  %retval = alloca %class.b3Vector3, align 16
  %v1.addr = alloca ptr, align 8
  %v2.addr = alloca ptr, align 8
  store ptr %v1, ptr %v1.addr, align 8
  store ptr %v2, ptr %v2.addr, align 8
  %0 = load ptr, ptr %v1.addr, align 8
  %1 = getelementptr inbounds %class.b3Vector3, ptr %0, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x float], ptr %1, i64 0, i64 0
  %2 = load float, ptr %arrayidx, align 16
  %3 = load ptr, ptr %v2.addr, align 8
  %4 = getelementptr inbounds %class.b3Vector3, ptr %3, i32 0, i32 0
  %arrayidx1 = getelementptr inbounds [4 x float], ptr %4, i64 0, i64 0
  %5 = load float, ptr %arrayidx1, align 16
  %mul = fmul float %2, %5
  %6 = load ptr, ptr %v1.addr, align 8
  %7 = getelementptr inbounds %class.b3Vector3, ptr %6, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [4 x float], ptr %7, i64 0, i64 1
  %8 = load float, ptr %arrayidx2, align 4
  %9 = load ptr, ptr %v2.addr, align 8
  %10 = getelementptr inbounds %class.b3Vector3, ptr %9, i32 0, i32 0
  %arrayidx3 = getelementptr inbounds [4 x float], ptr %10, i64 0, i64 1
  %11 = load float, ptr %arrayidx3, align 4
  %mul4 = fmul float %8, %11
  %12 = load ptr, ptr %v1.addr, align 8
  %13 = getelementptr inbounds %class.b3Vector3, ptr %12, i32 0, i32 0
  %arrayidx5 = getelementptr inbounds [4 x float], ptr %13, i64 0, i64 2
  %14 = load float, ptr %arrayidx5, align 8
  %15 = load ptr, ptr %v2.addr, align 8
  %16 = getelementptr inbounds %class.b3Vector3, ptr %15, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [4 x float], ptr %16, i64 0, i64 2
  %17 = load float, ptr %arrayidx6, align 8
  %mul7 = fmul float %14, %17
  %call = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef %mul, float noundef %mul4, float noundef %mul7)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive8 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %18 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive8, i32 0, i32 0
  %19 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %19, ptr %18, align 16
  %20 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive8, i32 0, i32 1
  %21 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %21, ptr %20, align 8
  %coerce.dive9 = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive10 = getelementptr inbounds %union.anon.1, ptr %coerce.dive9, i32 0, i32 0
  %22 = load { <2 x float>, <2 x float> }, ptr %coerce.dive10, align 16
  ret { <2 x float>, <2 x float> } %22
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_ZmlRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %q, ptr noundef nonnull align 16 dereferenceable(16) %w) #0 comdat {
entry:
  %retval = alloca %class.b3Quaternion, align 16
  %q.addr = alloca ptr, align 8
  %w.addr = alloca ptr, align 8
  %ref.tmp = alloca float, align 4
  %ref.tmp7 = alloca float, align 4
  %ref.tmp16 = alloca float, align 4
  %ref.tmp25 = alloca float, align 4
  store ptr %q, ptr %q.addr, align 8
  store ptr %w, ptr %w.addr, align 8
  %0 = load ptr, ptr %q.addr, align 8
  %call = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK12b3Quaternion4getWEv(ptr noundef nonnull align 16 dereferenceable(16) %0)
  %1 = load float, ptr %call, align 4
  %2 = load ptr, ptr %w.addr, align 8
  %call1 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getXEv(ptr noundef nonnull align 16 dereferenceable(16) %2)
  %3 = load float, ptr %call1, align 4
  %4 = load ptr, ptr %q.addr, align 8
  %call2 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getYEv(ptr noundef nonnull align 16 dereferenceable(16) %4)
  %5 = load float, ptr %call2, align 4
  %6 = load ptr, ptr %w.addr, align 8
  %call3 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getZEv(ptr noundef nonnull align 16 dereferenceable(16) %6)
  %7 = load float, ptr %call3, align 4
  %mul4 = fmul float %5, %7
  %8 = call float @llvm.fmuladd.f32(float %1, float %3, float %mul4)
  %9 = load ptr, ptr %q.addr, align 8
  %call5 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getZEv(ptr noundef nonnull align 16 dereferenceable(16) %9)
  %10 = load float, ptr %call5, align 4
  %11 = load ptr, ptr %w.addr, align 8
  %call6 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getYEv(ptr noundef nonnull align 16 dereferenceable(16) %11)
  %12 = load float, ptr %call6, align 4
  %neg = fneg float %10
  %13 = call float @llvm.fmuladd.f32(float %neg, float %12, float %8)
  store float %13, ptr %ref.tmp, align 4
  %14 = load ptr, ptr %q.addr, align 8
  %call8 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK12b3Quaternion4getWEv(ptr noundef nonnull align 16 dereferenceable(16) %14)
  %15 = load float, ptr %call8, align 4
  %16 = load ptr, ptr %w.addr, align 8
  %call9 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getYEv(ptr noundef nonnull align 16 dereferenceable(16) %16)
  %17 = load float, ptr %call9, align 4
  %18 = load ptr, ptr %q.addr, align 8
  %call10 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getZEv(ptr noundef nonnull align 16 dereferenceable(16) %18)
  %19 = load float, ptr %call10, align 4
  %20 = load ptr, ptr %w.addr, align 8
  %call11 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getXEv(ptr noundef nonnull align 16 dereferenceable(16) %20)
  %21 = load float, ptr %call11, align 4
  %mul12 = fmul float %19, %21
  %22 = call float @llvm.fmuladd.f32(float %15, float %17, float %mul12)
  %23 = load ptr, ptr %q.addr, align 8
  %call13 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getXEv(ptr noundef nonnull align 16 dereferenceable(16) %23)
  %24 = load float, ptr %call13, align 4
  %25 = load ptr, ptr %w.addr, align 8
  %call14 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getZEv(ptr noundef nonnull align 16 dereferenceable(16) %25)
  %26 = load float, ptr %call14, align 4
  %neg15 = fneg float %24
  %27 = call float @llvm.fmuladd.f32(float %neg15, float %26, float %22)
  store float %27, ptr %ref.tmp7, align 4
  %28 = load ptr, ptr %q.addr, align 8
  %call17 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK12b3Quaternion4getWEv(ptr noundef nonnull align 16 dereferenceable(16) %28)
  %29 = load float, ptr %call17, align 4
  %30 = load ptr, ptr %w.addr, align 8
  %call18 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getZEv(ptr noundef nonnull align 16 dereferenceable(16) %30)
  %31 = load float, ptr %call18, align 4
  %32 = load ptr, ptr %q.addr, align 8
  %call19 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getXEv(ptr noundef nonnull align 16 dereferenceable(16) %32)
  %33 = load float, ptr %call19, align 4
  %34 = load ptr, ptr %w.addr, align 8
  %call20 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getYEv(ptr noundef nonnull align 16 dereferenceable(16) %34)
  %35 = load float, ptr %call20, align 4
  %mul21 = fmul float %33, %35
  %36 = call float @llvm.fmuladd.f32(float %29, float %31, float %mul21)
  %37 = load ptr, ptr %q.addr, align 8
  %call22 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getYEv(ptr noundef nonnull align 16 dereferenceable(16) %37)
  %38 = load float, ptr %call22, align 4
  %39 = load ptr, ptr %w.addr, align 8
  %call23 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getXEv(ptr noundef nonnull align 16 dereferenceable(16) %39)
  %40 = load float, ptr %call23, align 4
  %neg24 = fneg float %38
  %41 = call float @llvm.fmuladd.f32(float %neg24, float %40, float %36)
  store float %41, ptr %ref.tmp16, align 4
  %42 = load ptr, ptr %q.addr, align 8
  %call26 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getXEv(ptr noundef nonnull align 16 dereferenceable(16) %42)
  %43 = load float, ptr %call26, align 4
  %fneg = fneg float %43
  %44 = load ptr, ptr %w.addr, align 8
  %call27 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getXEv(ptr noundef nonnull align 16 dereferenceable(16) %44)
  %45 = load float, ptr %call27, align 4
  %46 = load ptr, ptr %q.addr, align 8
  %call28 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getYEv(ptr noundef nonnull align 16 dereferenceable(16) %46)
  %47 = load float, ptr %call28, align 4
  %48 = load ptr, ptr %w.addr, align 8
  %call29 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getYEv(ptr noundef nonnull align 16 dereferenceable(16) %48)
  %49 = load float, ptr %call29, align 4
  %mul30 = fmul float %47, %49
  %neg31 = fneg float %mul30
  %50 = call float @llvm.fmuladd.f32(float %fneg, float %45, float %neg31)
  %51 = load ptr, ptr %q.addr, align 8
  %call32 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getZEv(ptr noundef nonnull align 16 dereferenceable(16) %51)
  %52 = load float, ptr %call32, align 4
  %53 = load ptr, ptr %w.addr, align 8
  %call33 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getZEv(ptr noundef nonnull align 16 dereferenceable(16) %53)
  %54 = load float, ptr %call33, align 4
  %neg34 = fneg float %52
  %55 = call float @llvm.fmuladd.f32(float %neg34, float %54, float %50)
  store float %55, ptr %ref.tmp25, align 4
  call void @_ZN12b3QuaternionC2ERKfS1_S1_S1_(ptr noundef nonnull align 16 dereferenceable(16) %retval, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp7, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp16, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp25)
  %coerce.dive = getelementptr inbounds %class.b3Quaternion, ptr %retval, i32 0, i32 0
  %coerce.dive35 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive, i32 0, i32 0
  %coerce.dive36 = getelementptr inbounds %union.anon.3, ptr %coerce.dive35, i32 0, i32 0
  %56 = load { <2 x float>, <2 x float> }, ptr %coerce.dive36, align 16
  ret { <2 x float>, <2 x float> } %56
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_ZNK12b3Quaternion7inverseEv(ptr noundef nonnull align 16 dereferenceable(16) %this) #0 comdat align 2 {
entry:
  %retval = alloca %class.b3Quaternion, align 16
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca float, align 4
  %ref.tmp2 = alloca float, align 4
  %ref.tmp5 = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x float], ptr %0, i64 0, i64 0
  %1 = load float, ptr %arrayidx, align 16
  %fneg = fneg float %1
  store float %fneg, ptr %ref.tmp, align 4
  %2 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx3 = getelementptr inbounds [4 x float], ptr %2, i64 0, i64 1
  %3 = load float, ptr %arrayidx3, align 4
  %fneg4 = fneg float %3
  store float %fneg4, ptr %ref.tmp2, align 4
  %4 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [4 x float], ptr %4, i64 0, i64 2
  %5 = load float, ptr %arrayidx6, align 8
  %fneg7 = fneg float %5
  store float %fneg7, ptr %ref.tmp5, align 4
  %6 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx8 = getelementptr inbounds [4 x float], ptr %6, i64 0, i64 3
  call void @_ZN12b3QuaternionC2ERKfS1_S1_S1_(ptr noundef nonnull align 16 dereferenceable(16) %retval, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp2, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp5, ptr noundef nonnull align 4 dereferenceable(4) %arrayidx8)
  %coerce.dive = getelementptr inbounds %class.b3Quaternion, ptr %retval, i32 0, i32 0
  %coerce.dive9 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive, i32 0, i32 0
  %coerce.dive10 = getelementptr inbounds %union.anon.3, ptr %coerce.dive9, i32 0, i32 0
  %7 = load { <2 x float>, <2 x float> }, ptr %coerce.dive10, align 16
  ret { <2 x float>, <2 x float> } %7
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(16) ptr @_ZN12b3QuaternionmLERKS_(ptr noundef nonnull align 16 dereferenceable(16) %this, ptr noundef nonnull align 16 dereferenceable(16) %q) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %q.addr = alloca ptr, align 8
  %ref.tmp = alloca float, align 4
  %ref.tmp9 = alloca float, align 4
  %ref.tmp20 = alloca float, align 4
  %ref.tmp31 = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %q, ptr %q.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x float], ptr %0, i64 0, i64 3
  %1 = load float, ptr %arrayidx, align 4
  %2 = load ptr, ptr %q.addr, align 8
  %call = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getXEv(ptr noundef nonnull align 16 dereferenceable(16) %2)
  %3 = load float, ptr %call, align 4
  %4 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [4 x float], ptr %4, i64 0, i64 0
  %5 = load float, ptr %arrayidx2, align 16
  %6 = load ptr, ptr %q.addr, align 8
  %7 = getelementptr inbounds %class.b3QuadWord, ptr %6, i32 0, i32 0
  %arrayidx3 = getelementptr inbounds [4 x float], ptr %7, i64 0, i64 3
  %8 = load float, ptr %arrayidx3, align 4
  %mul4 = fmul float %5, %8
  %9 = call float @llvm.fmuladd.f32(float %1, float %3, float %mul4)
  %10 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx5 = getelementptr inbounds [4 x float], ptr %10, i64 0, i64 1
  %11 = load float, ptr %arrayidx5, align 4
  %12 = load ptr, ptr %q.addr, align 8
  %call6 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getZEv(ptr noundef nonnull align 16 dereferenceable(16) %12)
  %13 = load float, ptr %call6, align 4
  %14 = call float @llvm.fmuladd.f32(float %11, float %13, float %9)
  %15 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx7 = getelementptr inbounds [4 x float], ptr %15, i64 0, i64 2
  %16 = load float, ptr %arrayidx7, align 8
  %17 = load ptr, ptr %q.addr, align 8
  %call8 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getYEv(ptr noundef nonnull align 16 dereferenceable(16) %17)
  %18 = load float, ptr %call8, align 4
  %neg = fneg float %16
  %19 = call float @llvm.fmuladd.f32(float %neg, float %18, float %14)
  store float %19, ptr %ref.tmp, align 4
  %20 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx10 = getelementptr inbounds [4 x float], ptr %20, i64 0, i64 3
  %21 = load float, ptr %arrayidx10, align 4
  %22 = load ptr, ptr %q.addr, align 8
  %call11 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getYEv(ptr noundef nonnull align 16 dereferenceable(16) %22)
  %23 = load float, ptr %call11, align 4
  %24 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx12 = getelementptr inbounds [4 x float], ptr %24, i64 0, i64 1
  %25 = load float, ptr %arrayidx12, align 4
  %26 = load ptr, ptr %q.addr, align 8
  %27 = getelementptr inbounds %class.b3QuadWord, ptr %26, i32 0, i32 0
  %arrayidx13 = getelementptr inbounds [4 x float], ptr %27, i64 0, i64 3
  %28 = load float, ptr %arrayidx13, align 4
  %mul14 = fmul float %25, %28
  %29 = call float @llvm.fmuladd.f32(float %21, float %23, float %mul14)
  %30 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx15 = getelementptr inbounds [4 x float], ptr %30, i64 0, i64 2
  %31 = load float, ptr %arrayidx15, align 8
  %32 = load ptr, ptr %q.addr, align 8
  %call16 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getXEv(ptr noundef nonnull align 16 dereferenceable(16) %32)
  %33 = load float, ptr %call16, align 4
  %34 = call float @llvm.fmuladd.f32(float %31, float %33, float %29)
  %35 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx17 = getelementptr inbounds [4 x float], ptr %35, i64 0, i64 0
  %36 = load float, ptr %arrayidx17, align 16
  %37 = load ptr, ptr %q.addr, align 8
  %call18 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getZEv(ptr noundef nonnull align 16 dereferenceable(16) %37)
  %38 = load float, ptr %call18, align 4
  %neg19 = fneg float %36
  %39 = call float @llvm.fmuladd.f32(float %neg19, float %38, float %34)
  store float %39, ptr %ref.tmp9, align 4
  %40 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx21 = getelementptr inbounds [4 x float], ptr %40, i64 0, i64 3
  %41 = load float, ptr %arrayidx21, align 4
  %42 = load ptr, ptr %q.addr, align 8
  %call22 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getZEv(ptr noundef nonnull align 16 dereferenceable(16) %42)
  %43 = load float, ptr %call22, align 4
  %44 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx23 = getelementptr inbounds [4 x float], ptr %44, i64 0, i64 2
  %45 = load float, ptr %arrayidx23, align 8
  %46 = load ptr, ptr %q.addr, align 8
  %47 = getelementptr inbounds %class.b3QuadWord, ptr %46, i32 0, i32 0
  %arrayidx24 = getelementptr inbounds [4 x float], ptr %47, i64 0, i64 3
  %48 = load float, ptr %arrayidx24, align 4
  %mul25 = fmul float %45, %48
  %49 = call float @llvm.fmuladd.f32(float %41, float %43, float %mul25)
  %50 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx26 = getelementptr inbounds [4 x float], ptr %50, i64 0, i64 0
  %51 = load float, ptr %arrayidx26, align 16
  %52 = load ptr, ptr %q.addr, align 8
  %call27 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getYEv(ptr noundef nonnull align 16 dereferenceable(16) %52)
  %53 = load float, ptr %call27, align 4
  %54 = call float @llvm.fmuladd.f32(float %51, float %53, float %49)
  %55 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx28 = getelementptr inbounds [4 x float], ptr %55, i64 0, i64 1
  %56 = load float, ptr %arrayidx28, align 4
  %57 = load ptr, ptr %q.addr, align 8
  %call29 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getXEv(ptr noundef nonnull align 16 dereferenceable(16) %57)
  %58 = load float, ptr %call29, align 4
  %neg30 = fneg float %56
  %59 = call float @llvm.fmuladd.f32(float %neg30, float %58, float %54)
  store float %59, ptr %ref.tmp20, align 4
  %60 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx32 = getelementptr inbounds [4 x float], ptr %60, i64 0, i64 3
  %61 = load float, ptr %arrayidx32, align 4
  %62 = load ptr, ptr %q.addr, align 8
  %63 = getelementptr inbounds %class.b3QuadWord, ptr %62, i32 0, i32 0
  %arrayidx33 = getelementptr inbounds [4 x float], ptr %63, i64 0, i64 3
  %64 = load float, ptr %arrayidx33, align 4
  %65 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx34 = getelementptr inbounds [4 x float], ptr %65, i64 0, i64 0
  %66 = load float, ptr %arrayidx34, align 16
  %67 = load ptr, ptr %q.addr, align 8
  %call35 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getXEv(ptr noundef nonnull align 16 dereferenceable(16) %67)
  %68 = load float, ptr %call35, align 4
  %mul36 = fmul float %66, %68
  %neg37 = fneg float %mul36
  %69 = call float @llvm.fmuladd.f32(float %61, float %64, float %neg37)
  %70 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx38 = getelementptr inbounds [4 x float], ptr %70, i64 0, i64 1
  %71 = load float, ptr %arrayidx38, align 4
  %72 = load ptr, ptr %q.addr, align 8
  %call39 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getYEv(ptr noundef nonnull align 16 dereferenceable(16) %72)
  %73 = load float, ptr %call39, align 4
  %neg40 = fneg float %71
  %74 = call float @llvm.fmuladd.f32(float %neg40, float %73, float %69)
  %75 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx41 = getelementptr inbounds [4 x float], ptr %75, i64 0, i64 2
  %76 = load float, ptr %arrayidx41, align 8
  %77 = load ptr, ptr %q.addr, align 8
  %call42 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getZEv(ptr noundef nonnull align 16 dereferenceable(16) %77)
  %78 = load float, ptr %call42, align 4
  %neg43 = fneg float %76
  %79 = call float @llvm.fmuladd.f32(float %neg43, float %78, float %74)
  store float %79, ptr %ref.tmp31, align 4
  call void @_ZN10b3QuadWord8setValueERKfS1_S1_S1_(ptr noundef nonnull align 16 dereferenceable(16) %this1, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp9, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp20, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp31)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getXEv(ptr noundef nonnull align 16 dereferenceable(16) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x float], ptr %0, i64 0, i64 0
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getYEv(ptr noundef nonnull align 16 dereferenceable(16) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x float], ptr %0, i64 0, i64 1
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getZEv(ptr noundef nonnull align 16 dereferenceable(16) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x float], ptr %0, i64 0, i64 2
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 4 dereferenceable(4) ptr @_ZNK12b3Quaternion4getWEv(ptr noundef nonnull align 16 dereferenceable(16) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x float], ptr %0, i64 0, i64 3
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getXEv(ptr noundef nonnull align 16 dereferenceable(16) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x float], ptr %0, i64 0, i64 0
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getZEv(ptr noundef nonnull align 16 dereferenceable(16) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x float], ptr %0, i64 0, i64 2
  ret ptr %arrayidx
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.fmuladd.f32(float, float, float) #11

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getYEv(ptr noundef nonnull align 16 dereferenceable(16) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x float], ptr %0, i64 0, i64 1
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN10b3QuadWord8setValueERKfS1_S1_S1_(ptr noundef nonnull align 16 dereferenceable(16) %this, ptr noundef nonnull align 4 dereferenceable(4) %_x, ptr noundef nonnull align 4 dereferenceable(4) %_y, ptr noundef nonnull align 4 dereferenceable(4) %_z, ptr noundef nonnull align 4 dereferenceable(4) %_w) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_x.addr = alloca ptr, align 8
  %_y.addr = alloca ptr, align 8
  %_z.addr = alloca ptr, align 8
  %_w.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %_x, ptr %_x.addr, align 8
  store ptr %_y, ptr %_y.addr, align 8
  store ptr %_z, ptr %_z.addr, align 8
  store ptr %_w, ptr %_w.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %_x.addr, align 8
  %1 = load float, ptr %0, align 4
  %2 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x float], ptr %2, i64 0, i64 0
  store float %1, ptr %arrayidx, align 16
  %3 = load ptr, ptr %_y.addr, align 8
  %4 = load float, ptr %3, align 4
  %5 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [4 x float], ptr %5, i64 0, i64 1
  store float %4, ptr %arrayidx2, align 4
  %6 = load ptr, ptr %_z.addr, align 8
  %7 = load float, ptr %6, align 4
  %8 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx3 = getelementptr inbounds [4 x float], ptr %8, i64 0, i64 2
  store float %7, ptr %arrayidx3, align 8
  %9 = load ptr, ptr %_w.addr, align 8
  %10 = load float, ptr %9, align 4
  %11 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [4 x float], ptr %11, i64 0, i64 3
  store float %10, ptr %arrayidx4, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN9b3Vector38setValueERKfS1_S1_(ptr noundef nonnull align 16 dereferenceable(16) %this, ptr noundef nonnull align 4 dereferenceable(4) %_x, ptr noundef nonnull align 4 dereferenceable(4) %_y, ptr noundef nonnull align 4 dereferenceable(4) %_z) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_x.addr = alloca ptr, align 8
  %_y.addr = alloca ptr, align 8
  %_z.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %_x, ptr %_x.addr, align 8
  store ptr %_y, ptr %_y.addr, align 8
  store ptr %_z, ptr %_z.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %_x.addr, align 8
  %1 = load float, ptr %0, align 4
  %2 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x float], ptr %2, i64 0, i64 0
  store float %1, ptr %arrayidx, align 16
  %3 = load ptr, ptr %_y.addr, align 8
  %4 = load float, ptr %3, align 4
  %5 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [4 x float], ptr %5, i64 0, i64 1
  store float %4, ptr %arrayidx2, align 4
  %6 = load ptr, ptr %_z.addr, align 8
  %7 = load float, ptr %6, align 4
  %8 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx3 = getelementptr inbounds [4 x float], ptr %8, i64 0, i64 2
  store float %7, ptr %arrayidx3, align 8
  %9 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [4 x float], ptr %9, i64 0, i64 3
  store float 0.000000e+00, ptr %arrayidx4, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef float @_Z6b3Fabsf(float noundef %x) #3 comdat {
entry:
  %x.addr = alloca float, align 4
  store float %x, ptr %x.addr, align 4
  %0 = load float, ptr %x.addr, align 4
  %1 = call float @llvm.fabs.f32(float %0)
  ret float %1
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.fabs.f32(float) #11

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_ZNK9b3Vector310normalizedEv(ptr noundef nonnull align 16 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %retval = alloca %class.b3Vector3, align 16
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef float @_ZNK9b3Vector36lengthEv(ptr noundef nonnull align 16 dereferenceable(16) %this1)
  store float %call, ptr %ref.tmp, align 4
  %call2 = call { <2 x float>, <2 x float> } @_ZdvRK9b3Vector3RKf(ptr noundef nonnull align 16 dereferenceable(16) %this1, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive3, i32 0, i32 0
  %1 = extractvalue { <2 x float>, <2 x float> } %call2, 0
  store <2 x float> %1, ptr %0, align 16
  %2 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive3, i32 0, i32 1
  %3 = extractvalue { <2 x float>, <2 x float> } %call2, 1
  store <2 x float> %3, ptr %2, align 8
  %coerce.dive4 = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive5 = getelementptr inbounds %union.anon.1, ptr %coerce.dive4, i32 0, i32 0
  %4 = load { <2 x float>, <2 x float> }, ptr %coerce.dive5, align 16
  ret { <2 x float>, <2 x float> } %4
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef float @_ZNK9b3Vector36lengthEv(ptr noundef nonnull align 16 dereferenceable(16) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef float @_ZNK9b3Vector37length2Ev(ptr noundef nonnull align 16 dereferenceable(16) %this1)
  %call2 = call noundef float @_Z6b3Sqrtf(float noundef %call)
  ret float %call2
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_Z13b3QuatInverseRK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(16) %orn) #2 comdat {
entry:
  %retval = alloca %class.b3Quaternion, align 16
  %orn.addr = alloca ptr, align 8
  store ptr %orn, ptr %orn.addr, align 8
  %0 = load ptr, ptr %orn.addr, align 8
  %call = call { <2 x float>, <2 x float> } @_ZNK12b3Quaternion7inverseEv(ptr noundef nonnull align 16 dereferenceable(16) %0)
  %coerce.dive = getelementptr inbounds %class.b3Quaternion, ptr %retval, i32 0, i32 0
  %coerce.dive1 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %union.anon.3, ptr %coerce.dive1, i32 0, i32 0
  %1 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive2, i32 0, i32 0
  %2 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %2, ptr %1, align 16
  %3 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive2, i32 0, i32 1
  %4 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %4, ptr %3, align 8
  %coerce.dive3 = getelementptr inbounds %class.b3Quaternion, ptr %retval, i32 0, i32 0
  %coerce.dive4 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive3, i32 0, i32 0
  %coerce.dive5 = getelementptr inbounds %union.anon.3, ptr %coerce.dive4, i32 0, i32 0
  %5 = load { <2 x float>, <2 x float> }, ptr %coerce.dive5, align 16
  ret { <2 x float>, <2 x float> } %5
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN9b3Vector36setMinERKS_(ptr noundef nonnull align 16 dereferenceable(16) %this, ptr noundef nonnull align 16 dereferenceable(16) %other) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %other.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %other, ptr %other.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x float], ptr %0, i64 0, i64 0
  %1 = load ptr, ptr %other.addr, align 8
  %2 = getelementptr inbounds %class.b3Vector3, ptr %1, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [4 x float], ptr %2, i64 0, i64 0
  call void @_Z8b3SetMinIfEvRT_RKS0_(ptr noundef nonnull align 4 dereferenceable(4) %arrayidx, ptr noundef nonnull align 4 dereferenceable(4) %arrayidx2)
  %3 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx3 = getelementptr inbounds [4 x float], ptr %3, i64 0, i64 1
  %4 = load ptr, ptr %other.addr, align 8
  %5 = getelementptr inbounds %class.b3Vector3, ptr %4, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [4 x float], ptr %5, i64 0, i64 1
  call void @_Z8b3SetMinIfEvRT_RKS0_(ptr noundef nonnull align 4 dereferenceable(4) %arrayidx3, ptr noundef nonnull align 4 dereferenceable(4) %arrayidx4)
  %6 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx5 = getelementptr inbounds [4 x float], ptr %6, i64 0, i64 2
  %7 = load ptr, ptr %other.addr, align 8
  %8 = getelementptr inbounds %class.b3Vector3, ptr %7, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [4 x float], ptr %8, i64 0, i64 2
  call void @_Z8b3SetMinIfEvRT_RKS0_(ptr noundef nonnull align 4 dereferenceable(4) %arrayidx5, ptr noundef nonnull align 4 dereferenceable(4) %arrayidx6)
  %9 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx7 = getelementptr inbounds [4 x float], ptr %9, i64 0, i64 3
  %10 = load ptr, ptr %other.addr, align 8
  %11 = getelementptr inbounds %class.b3Vector3, ptr %10, i32 0, i32 0
  %arrayidx8 = getelementptr inbounds [4 x float], ptr %11, i64 0, i64 3
  call void @_Z8b3SetMinIfEvRT_RKS0_(ptr noundef nonnull align 4 dereferenceable(4) %arrayidx7, ptr noundef nonnull align 4 dereferenceable(4) %arrayidx8)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_Z8b3SetMinIfEvRT_RKS0_(ptr noundef nonnull align 4 dereferenceable(4) %a, ptr noundef nonnull align 4 dereferenceable(4) %b) #3 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %b.addr, align 8
  %1 = load float, ptr %0, align 4
  %2 = load ptr, ptr %a.addr, align 8
  %3 = load float, ptr %2, align 4
  %cmp = fcmp olt float %1, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %b.addr, align 8
  %5 = load float, ptr %4, align 4
  %6 = load ptr, ptr %a.addr, align 8
  store float %5, ptr %6, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN9b3Vector36setMaxERKS_(ptr noundef nonnull align 16 dereferenceable(16) %this, ptr noundef nonnull align 16 dereferenceable(16) %other) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %other.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %other, ptr %other.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x float], ptr %0, i64 0, i64 0
  %1 = load ptr, ptr %other.addr, align 8
  %2 = getelementptr inbounds %class.b3Vector3, ptr %1, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [4 x float], ptr %2, i64 0, i64 0
  call void @_Z8b3SetMaxIfEvRT_RKS0_(ptr noundef nonnull align 4 dereferenceable(4) %arrayidx, ptr noundef nonnull align 4 dereferenceable(4) %arrayidx2)
  %3 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx3 = getelementptr inbounds [4 x float], ptr %3, i64 0, i64 1
  %4 = load ptr, ptr %other.addr, align 8
  %5 = getelementptr inbounds %class.b3Vector3, ptr %4, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [4 x float], ptr %5, i64 0, i64 1
  call void @_Z8b3SetMaxIfEvRT_RKS0_(ptr noundef nonnull align 4 dereferenceable(4) %arrayidx3, ptr noundef nonnull align 4 dereferenceable(4) %arrayidx4)
  %6 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx5 = getelementptr inbounds [4 x float], ptr %6, i64 0, i64 2
  %7 = load ptr, ptr %other.addr, align 8
  %8 = getelementptr inbounds %class.b3Vector3, ptr %7, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [4 x float], ptr %8, i64 0, i64 2
  call void @_Z8b3SetMaxIfEvRT_RKS0_(ptr noundef nonnull align 4 dereferenceable(4) %arrayidx5, ptr noundef nonnull align 4 dereferenceable(4) %arrayidx6)
  %9 = getelementptr inbounds %class.b3Vector3, ptr %this1, i32 0, i32 0
  %arrayidx7 = getelementptr inbounds [4 x float], ptr %9, i64 0, i64 3
  %10 = load ptr, ptr %other.addr, align 8
  %11 = getelementptr inbounds %class.b3Vector3, ptr %10, i32 0, i32 0
  %arrayidx8 = getelementptr inbounds [4 x float], ptr %11, i64 0, i64 3
  call void @_Z8b3SetMaxIfEvRT_RKS0_(ptr noundef nonnull align 4 dereferenceable(4) %arrayidx7, ptr noundef nonnull align 4 dereferenceable(4) %arrayidx8)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_Z8b3SetMaxIfEvRT_RKS0_(ptr noundef nonnull align 4 dereferenceable(4) %a, ptr noundef nonnull align 4 dereferenceable(4) %b) #3 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %1 = load float, ptr %0, align 4
  %2 = load ptr, ptr %b.addr, align 8
  %3 = load float, ptr %2, align 4
  %cmp = fcmp olt float %1, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %b.addr, align 8
  %5 = load float, ptr %4, align 4
  %6 = load ptr, ptr %a.addr, align 8
  store float %5, ptr %6, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare ptr @b3OpenCLUtils_compileCLProgramFromString(ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, i1 noundef zeroext) #5

declare ptr @b3OpenCLUtils_compileCLKernelFromString(ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef) #5

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN11b3Matrix3x3C2Ev(ptr noundef nonnull align 16 dereferenceable(48) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN11b3Matrix3x311setIdentityEv(ptr noundef nonnull align 16 dereferenceable(48) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca float, align 4
  %ref.tmp2 = alloca float, align 4
  %ref.tmp3 = alloca float, align 4
  %ref.tmp4 = alloca float, align 4
  %ref.tmp5 = alloca float, align 4
  %ref.tmp6 = alloca float, align 4
  %ref.tmp7 = alloca float, align 4
  %ref.tmp8 = alloca float, align 4
  %ref.tmp9 = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store float 1.000000e+00, ptr %ref.tmp, align 4
  store float 0.000000e+00, ptr %ref.tmp2, align 4
  store float 0.000000e+00, ptr %ref.tmp3, align 4
  store float 0.000000e+00, ptr %ref.tmp4, align 4
  store float 1.000000e+00, ptr %ref.tmp5, align 4
  store float 0.000000e+00, ptr %ref.tmp6, align 4
  store float 0.000000e+00, ptr %ref.tmp7, align 4
  store float 0.000000e+00, ptr %ref.tmp8, align 4
  store float 1.000000e+00, ptr %ref.tmp9, align 4
  call void @_ZN11b3Matrix3x38setValueERKfS1_S1_S1_S1_S1_S1_S1_S1_(ptr noundef nonnull align 16 dereferenceable(48) %this1, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp2, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp3, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp4, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp5, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp6, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp7, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp8, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp9)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN11b3Matrix3x38setValueERKfS1_S1_S1_S1_S1_S1_S1_S1_(ptr noundef nonnull align 16 dereferenceable(48) %this, ptr noundef nonnull align 4 dereferenceable(4) %xx, ptr noundef nonnull align 4 dereferenceable(4) %xy, ptr noundef nonnull align 4 dereferenceable(4) %xz, ptr noundef nonnull align 4 dereferenceable(4) %yx, ptr noundef nonnull align 4 dereferenceable(4) %yy, ptr noundef nonnull align 4 dereferenceable(4) %yz, ptr noundef nonnull align 4 dereferenceable(4) %zx, ptr noundef nonnull align 4 dereferenceable(4) %zy, ptr noundef nonnull align 4 dereferenceable(4) %zz) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %xx.addr = alloca ptr, align 8
  %xy.addr = alloca ptr, align 8
  %xz.addr = alloca ptr, align 8
  %yx.addr = alloca ptr, align 8
  %yy.addr = alloca ptr, align 8
  %yz.addr = alloca ptr, align 8
  %zx.addr = alloca ptr, align 8
  %zy.addr = alloca ptr, align 8
  %zz.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %xx, ptr %xx.addr, align 8
  store ptr %xy, ptr %xy.addr, align 8
  store ptr %xz, ptr %xz.addr, align 8
  store ptr %yx, ptr %yx.addr, align 8
  store ptr %yy, ptr %yy.addr, align 8
  store ptr %yz, ptr %yz.addr, align 8
  store ptr %zx, ptr %zx.addr, align 8
  store ptr %zy, ptr %zy.addr, align 8
  store ptr %zz, ptr %zz.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_el = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el, i64 0, i64 0
  %0 = load ptr, ptr %xx.addr, align 8
  %1 = load ptr, ptr %xy.addr, align 8
  %2 = load ptr, ptr %xz.addr, align 8
  call void @_ZN9b3Vector38setValueERKfS1_S1_(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx, ptr noundef nonnull align 4 dereferenceable(4) %0, ptr noundef nonnull align 4 dereferenceable(4) %1, ptr noundef nonnull align 4 dereferenceable(4) %2)
  %m_el2 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx3 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el2, i64 0, i64 1
  %3 = load ptr, ptr %yx.addr, align 8
  %4 = load ptr, ptr %yy.addr, align 8
  %5 = load ptr, ptr %yz.addr, align 8
  call void @_ZN9b3Vector38setValueERKfS1_S1_(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx3, ptr noundef nonnull align 4 dereferenceable(4) %3, ptr noundef nonnull align 4 dereferenceable(4) %4, ptr noundef nonnull align 4 dereferenceable(4) %5)
  %m_el4 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx5 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el4, i64 0, i64 2
  %6 = load ptr, ptr %zx.addr, align 8
  %7 = load ptr, ptr %zy.addr, align 8
  %8 = load ptr, ptr %zz.addr, align 8
  call void @_ZN9b3Vector38setValueERKfS1_S1_(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx5, ptr noundef nonnull align 4 dereferenceable(4) %6, ptr noundef nonnull align 4 dereferenceable(4) %7, ptr noundef nonnull align 4 dereferenceable(4) %8)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN11b3Matrix3x311setRotationERK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(48) %this, ptr noundef nonnull align 16 dereferenceable(16) %q) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %q.addr = alloca ptr, align 8
  %d = alloca float, align 4
  %s = alloca float, align 4
  %xs = alloca float, align 4
  %ys = alloca float, align 4
  %zs = alloca float, align 4
  %wx = alloca float, align 4
  %wy = alloca float, align 4
  %wz = alloca float, align 4
  %xx = alloca float, align 4
  %xy = alloca float, align 4
  %xz = alloca float, align 4
  %yy = alloca float, align 4
  %yz = alloca float, align 4
  %zz = alloca float, align 4
  %ref.tmp = alloca float, align 4
  %ref.tmp25 = alloca float, align 4
  %ref.tmp27 = alloca float, align 4
  %ref.tmp29 = alloca float, align 4
  %ref.tmp31 = alloca float, align 4
  %ref.tmp34 = alloca float, align 4
  %ref.tmp36 = alloca float, align 4
  %ref.tmp38 = alloca float, align 4
  %ref.tmp40 = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %q, ptr %q.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %q.addr, align 8
  %call = call noundef float @_ZNK12b3Quaternion7length2Ev(ptr noundef nonnull align 16 dereferenceable(16) %0)
  store float %call, ptr %d, align 4
  %1 = load float, ptr %d, align 4
  %div = fdiv float 2.000000e+00, %1
  store float %div, ptr %s, align 4
  %2 = load ptr, ptr %q.addr, align 8
  %call2 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getXEv(ptr noundef nonnull align 16 dereferenceable(16) %2)
  %3 = load float, ptr %call2, align 4
  %4 = load float, ptr %s, align 4
  %mul = fmul float %3, %4
  store float %mul, ptr %xs, align 4
  %5 = load ptr, ptr %q.addr, align 8
  %call3 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getYEv(ptr noundef nonnull align 16 dereferenceable(16) %5)
  %6 = load float, ptr %call3, align 4
  %7 = load float, ptr %s, align 4
  %mul4 = fmul float %6, %7
  store float %mul4, ptr %ys, align 4
  %8 = load ptr, ptr %q.addr, align 8
  %call5 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getZEv(ptr noundef nonnull align 16 dereferenceable(16) %8)
  %9 = load float, ptr %call5, align 4
  %10 = load float, ptr %s, align 4
  %mul6 = fmul float %9, %10
  store float %mul6, ptr %zs, align 4
  %11 = load ptr, ptr %q.addr, align 8
  %call7 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK12b3Quaternion4getWEv(ptr noundef nonnull align 16 dereferenceable(16) %11)
  %12 = load float, ptr %call7, align 4
  %13 = load float, ptr %xs, align 4
  %mul8 = fmul float %12, %13
  store float %mul8, ptr %wx, align 4
  %14 = load ptr, ptr %q.addr, align 8
  %call9 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK12b3Quaternion4getWEv(ptr noundef nonnull align 16 dereferenceable(16) %14)
  %15 = load float, ptr %call9, align 4
  %16 = load float, ptr %ys, align 4
  %mul10 = fmul float %15, %16
  store float %mul10, ptr %wy, align 4
  %17 = load ptr, ptr %q.addr, align 8
  %call11 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK12b3Quaternion4getWEv(ptr noundef nonnull align 16 dereferenceable(16) %17)
  %18 = load float, ptr %call11, align 4
  %19 = load float, ptr %zs, align 4
  %mul12 = fmul float %18, %19
  store float %mul12, ptr %wz, align 4
  %20 = load ptr, ptr %q.addr, align 8
  %call13 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getXEv(ptr noundef nonnull align 16 dereferenceable(16) %20)
  %21 = load float, ptr %call13, align 4
  %22 = load float, ptr %xs, align 4
  %mul14 = fmul float %21, %22
  store float %mul14, ptr %xx, align 4
  %23 = load ptr, ptr %q.addr, align 8
  %call15 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getXEv(ptr noundef nonnull align 16 dereferenceable(16) %23)
  %24 = load float, ptr %call15, align 4
  %25 = load float, ptr %ys, align 4
  %mul16 = fmul float %24, %25
  store float %mul16, ptr %xy, align 4
  %26 = load ptr, ptr %q.addr, align 8
  %call17 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getXEv(ptr noundef nonnull align 16 dereferenceable(16) %26)
  %27 = load float, ptr %call17, align 4
  %28 = load float, ptr %zs, align 4
  %mul18 = fmul float %27, %28
  store float %mul18, ptr %xz, align 4
  %29 = load ptr, ptr %q.addr, align 8
  %call19 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getYEv(ptr noundef nonnull align 16 dereferenceable(16) %29)
  %30 = load float, ptr %call19, align 4
  %31 = load float, ptr %ys, align 4
  %mul20 = fmul float %30, %31
  store float %mul20, ptr %yy, align 4
  %32 = load ptr, ptr %q.addr, align 8
  %call21 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getYEv(ptr noundef nonnull align 16 dereferenceable(16) %32)
  %33 = load float, ptr %call21, align 4
  %34 = load float, ptr %zs, align 4
  %mul22 = fmul float %33, %34
  store float %mul22, ptr %yz, align 4
  %35 = load ptr, ptr %q.addr, align 8
  %call23 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getZEv(ptr noundef nonnull align 16 dereferenceable(16) %35)
  %36 = load float, ptr %call23, align 4
  %37 = load float, ptr %zs, align 4
  %mul24 = fmul float %36, %37
  store float %mul24, ptr %zz, align 4
  %38 = load float, ptr %yy, align 4
  %39 = load float, ptr %zz, align 4
  %add = fadd float %38, %39
  %sub = fsub float 1.000000e+00, %add
  store float %sub, ptr %ref.tmp, align 4
  %40 = load float, ptr %xy, align 4
  %41 = load float, ptr %wz, align 4
  %sub26 = fsub float %40, %41
  store float %sub26, ptr %ref.tmp25, align 4
  %42 = load float, ptr %xz, align 4
  %43 = load float, ptr %wy, align 4
  %add28 = fadd float %42, %43
  store float %add28, ptr %ref.tmp27, align 4
  %44 = load float, ptr %xy, align 4
  %45 = load float, ptr %wz, align 4
  %add30 = fadd float %44, %45
  store float %add30, ptr %ref.tmp29, align 4
  %46 = load float, ptr %xx, align 4
  %47 = load float, ptr %zz, align 4
  %add32 = fadd float %46, %47
  %sub33 = fsub float 1.000000e+00, %add32
  store float %sub33, ptr %ref.tmp31, align 4
  %48 = load float, ptr %yz, align 4
  %49 = load float, ptr %wx, align 4
  %sub35 = fsub float %48, %49
  store float %sub35, ptr %ref.tmp34, align 4
  %50 = load float, ptr %xz, align 4
  %51 = load float, ptr %wy, align 4
  %sub37 = fsub float %50, %51
  store float %sub37, ptr %ref.tmp36, align 4
  %52 = load float, ptr %yz, align 4
  %53 = load float, ptr %wx, align 4
  %add39 = fadd float %52, %53
  store float %add39, ptr %ref.tmp38, align 4
  %54 = load float, ptr %xx, align 4
  %55 = load float, ptr %yy, align 4
  %add41 = fadd float %54, %55
  %sub42 = fsub float 1.000000e+00, %add41
  store float %sub42, ptr %ref.tmp40, align 4
  call void @_ZN11b3Matrix3x38setValueERKfS1_S1_S1_S1_S1_S1_S1_S1_(ptr noundef nonnull align 16 dereferenceable(48) %this1, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp25, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp27, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp29, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp31, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp34, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp36, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp38, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp40)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef float @_ZNK12b3Quaternion7length2Ev(ptr noundef nonnull align 16 dereferenceable(16) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef float @_ZNK12b3Quaternion3dotERKS_(ptr noundef nonnull align 16 dereferenceable(16) %this1, ptr noundef nonnull align 16 dereferenceable(16) %this1)
  ret float %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef float @_ZNK12b3Quaternion3dotERKS_(ptr noundef nonnull align 16 dereferenceable(16) %this, ptr noundef nonnull align 16 dereferenceable(16) %q) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %q.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %q, ptr %q.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x float], ptr %0, i64 0, i64 0
  %1 = load float, ptr %arrayidx, align 16
  %2 = load ptr, ptr %q.addr, align 8
  %call = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getXEv(ptr noundef nonnull align 16 dereferenceable(16) %2)
  %3 = load float, ptr %call, align 4
  %4 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [4 x float], ptr %4, i64 0, i64 1
  %5 = load float, ptr %arrayidx2, align 4
  %6 = load ptr, ptr %q.addr, align 8
  %call3 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getYEv(ptr noundef nonnull align 16 dereferenceable(16) %6)
  %7 = load float, ptr %call3, align 4
  %mul4 = fmul float %5, %7
  %8 = call float @llvm.fmuladd.f32(float %1, float %3, float %mul4)
  %9 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx5 = getelementptr inbounds [4 x float], ptr %9, i64 0, i64 2
  %10 = load float, ptr %arrayidx5, align 8
  %11 = load ptr, ptr %q.addr, align 8
  %call6 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK10b3QuadWord4getZEv(ptr noundef nonnull align 16 dereferenceable(16) %11)
  %12 = load float, ptr %call6, align 4
  %13 = call float @llvm.fmuladd.f32(float %10, float %12, float %8)
  %14 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx7 = getelementptr inbounds [4 x float], ptr %14, i64 0, i64 3
  %15 = load float, ptr %arrayidx7, align 4
  %16 = load ptr, ptr %q.addr, align 8
  %17 = getelementptr inbounds %class.b3QuadWord, ptr %16, i32 0, i32 0
  %arrayidx8 = getelementptr inbounds [4 x float], ptr %17, i64 0, i64 3
  %18 = load float, ptr %arrayidx8, align 4
  %19 = call float @llvm.fmuladd.f32(float %15, float %18, float %13)
  ret float %19
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_ZNK9b3Vector34dot3ERKS_S1_S1_(ptr noundef nonnull align 16 dereferenceable(16) %this, ptr noundef nonnull align 16 dereferenceable(16) %v0, ptr noundef nonnull align 16 dereferenceable(16) %v1, ptr noundef nonnull align 16 dereferenceable(16) %v2) #2 comdat align 2 {
entry:
  %retval = alloca %class.b3Vector3, align 16
  %this.addr = alloca ptr, align 8
  %v0.addr = alloca ptr, align 8
  %v1.addr = alloca ptr, align 8
  %v2.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %v1, ptr %v1.addr, align 8
  store ptr %v2, ptr %v2.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %v0.addr, align 8
  %call = call noundef float @_ZNK9b3Vector33dotERKS_(ptr noundef nonnull align 16 dereferenceable(16) %this1, ptr noundef nonnull align 16 dereferenceable(16) %0)
  %1 = load ptr, ptr %v1.addr, align 8
  %call2 = call noundef float @_ZNK9b3Vector33dotERKS_(ptr noundef nonnull align 16 dereferenceable(16) %this1, ptr noundef nonnull align 16 dereferenceable(16) %1)
  %2 = load ptr, ptr %v2.addr, align 8
  %call3 = call noundef float @_ZNK9b3Vector33dotERKS_(ptr noundef nonnull align 16 dereferenceable(16) %this1, ptr noundef nonnull align 16 dereferenceable(16) %2)
  %call4 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3fff(float noundef %call, float noundef %call2, float noundef %call3)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive5 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %3 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive5, i32 0, i32 0
  %4 = extractvalue { <2 x float>, <2 x float> } %call4, 0
  store <2 x float> %4, ptr %3, align 16
  %5 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive5, i32 0, i32 1
  %6 = extractvalue { <2 x float>, <2 x float> } %call4, 1
  store <2 x float> %6, ptr %5, align 8
  %coerce.dive6 = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive7 = getelementptr inbounds %union.anon.1, ptr %coerce.dive6, i32 0, i32 0
  %7 = load { <2 x float>, <2 x float> }, ptr %coerce.dive7, align 16
  ret { <2 x float>, <2 x float> } %7
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(16) ptr @_ZNK11b3Matrix3x3ixEi(ptr noundef nonnull align 16 dereferenceable(48) %this, i32 noundef %i) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_el = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %0 to i64
  %arrayidx = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el, i64 0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN10b3QuadWordC2ERKfS1_S1_S1_(ptr noundef nonnull align 16 dereferenceable(16) %this, ptr noundef nonnull align 4 dereferenceable(4) %_x, ptr noundef nonnull align 4 dereferenceable(4) %_y, ptr noundef nonnull align 4 dereferenceable(4) %_z, ptr noundef nonnull align 4 dereferenceable(4) %_w) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_x.addr = alloca ptr, align 8
  %_y.addr = alloca ptr, align 8
  %_z.addr = alloca ptr, align 8
  %_w.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %_x, ptr %_x.addr, align 8
  store ptr %_y, ptr %_y.addr, align 8
  store ptr %_z, ptr %_z.addr, align 8
  store ptr %_w, ptr %_w.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %_x.addr, align 8
  %1 = load float, ptr %0, align 4
  %2 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x float], ptr %2, i64 0, i64 0
  store float %1, ptr %arrayidx, align 16
  %3 = load ptr, ptr %_y.addr, align 8
  %4 = load float, ptr %3, align 4
  %5 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [4 x float], ptr %5, i64 0, i64 1
  store float %4, ptr %arrayidx2, align 4
  %6 = load ptr, ptr %_z.addr, align 8
  %7 = load float, ptr %6, align 4
  %8 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx3 = getelementptr inbounds [4 x float], ptr %8, i64 0, i64 2
  store float %7, ptr %arrayidx3, align 8
  %9 = load ptr, ptr %_w.addr, align 8
  %10 = load float, ptr %9, align 4
  %11 = getelementptr inbounds %class.b3QuadWord, ptr %this1, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [4 x float], ptr %11, i64 0, i64 3
  store float %10, ptr %arrayidx4, align 4
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN12b3QuaternionC2Ev(ptr noundef nonnull align 16 dereferenceable(16) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN10b3QuadWordC2Ev(ptr noundef nonnull align 16 dereferenceable(16) %this1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK11b3Matrix3x311getRotationER12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(48) %this, ptr noundef nonnull align 16 dereferenceable(16) %q) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %q.addr = alloca ptr, align 8
  %trace = alloca float, align 4
  %temp = alloca [4 x float], align 16
  %s = alloca float, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %k = alloca i32, align 4
  %s64 = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %q, ptr %q.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_el = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el, i64 0, i64 0
  %call = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getXEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx)
  %0 = load float, ptr %call, align 4
  %m_el2 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx3 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el2, i64 0, i64 1
  %call4 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getYEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx3)
  %1 = load float, ptr %call4, align 4
  %add = fadd float %0, %1
  %m_el5 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el5, i64 0, i64 2
  %call7 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getZEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx6)
  %2 = load float, ptr %call7, align 4
  %add8 = fadd float %add, %2
  store float %add8, ptr %trace, align 4
  %3 = load float, ptr %trace, align 4
  %cmp = fcmp ogt float %3, 0.000000e+00
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load float, ptr %trace, align 4
  %add9 = fadd float %4, 1.000000e+00
  %call10 = call noundef float @_Z6b3Sqrtf(float noundef %add9)
  store float %call10, ptr %s, align 4
  %5 = load float, ptr %s, align 4
  %mul = fmul float %5, 5.000000e-01
  %arrayidx11 = getelementptr inbounds [4 x float], ptr %temp, i64 0, i64 3
  store float %mul, ptr %arrayidx11, align 4
  %6 = load float, ptr %s, align 4
  %div = fdiv float 5.000000e-01, %6
  store float %div, ptr %s, align 4
  %m_el12 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx13 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el12, i64 0, i64 2
  %call14 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getYEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx13)
  %7 = load float, ptr %call14, align 4
  %m_el15 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx16 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el15, i64 0, i64 1
  %call17 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getZEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx16)
  %8 = load float, ptr %call17, align 4
  %sub = fsub float %7, %8
  %9 = load float, ptr %s, align 4
  %mul18 = fmul float %sub, %9
  %arrayidx19 = getelementptr inbounds [4 x float], ptr %temp, i64 0, i64 0
  store float %mul18, ptr %arrayidx19, align 16
  %m_el20 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx21 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el20, i64 0, i64 0
  %call22 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getZEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx21)
  %10 = load float, ptr %call22, align 4
  %m_el23 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx24 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el23, i64 0, i64 2
  %call25 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getXEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx24)
  %11 = load float, ptr %call25, align 4
  %sub26 = fsub float %10, %11
  %12 = load float, ptr %s, align 4
  %mul27 = fmul float %sub26, %12
  %arrayidx28 = getelementptr inbounds [4 x float], ptr %temp, i64 0, i64 1
  store float %mul27, ptr %arrayidx28, align 4
  %m_el29 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx30 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el29, i64 0, i64 1
  %call31 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getXEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx30)
  %13 = load float, ptr %call31, align 4
  %m_el32 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx33 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el32, i64 0, i64 0
  %call34 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getYEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx33)
  %14 = load float, ptr %call34, align 4
  %sub35 = fsub float %13, %14
  %15 = load float, ptr %s, align 4
  %mul36 = fmul float %sub35, %15
  %arrayidx37 = getelementptr inbounds [4 x float], ptr %temp, i64 0, i64 2
  store float %mul36, ptr %arrayidx37, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %m_el38 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx39 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el38, i64 0, i64 0
  %call40 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getXEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx39)
  %16 = load float, ptr %call40, align 4
  %m_el41 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx42 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el41, i64 0, i64 1
  %call43 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getYEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx42)
  %17 = load float, ptr %call43, align 4
  %cmp44 = fcmp olt float %16, %17
  br i1 %cmp44, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else
  %m_el45 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx46 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el45, i64 0, i64 1
  %call47 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getYEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx46)
  %18 = load float, ptr %call47, align 4
  %m_el48 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx49 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el48, i64 0, i64 2
  %call50 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getZEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx49)
  %19 = load float, ptr %call50, align 4
  %cmp51 = fcmp olt float %18, %19
  %cond = select i1 %cmp51, i32 2, i32 1
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %m_el52 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx53 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el52, i64 0, i64 0
  %call54 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getXEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx53)
  %20 = load float, ptr %call54, align 4
  %m_el55 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx56 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el55, i64 0, i64 2
  %call57 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getZEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx56)
  %21 = load float, ptr %call57, align 4
  %cmp58 = fcmp olt float %20, %21
  %cond59 = select i1 %cmp58, i32 2, i32 0
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond60 = phi i32 [ %cond, %cond.true ], [ %cond59, %cond.false ]
  store i32 %cond60, ptr %i, align 4
  %22 = load i32, ptr %i, align 4
  %add61 = add nsw i32 %22, 1
  %rem = srem i32 %add61, 3
  store i32 %rem, ptr %j, align 4
  %23 = load i32, ptr %i, align 4
  %add62 = add nsw i32 %23, 2
  %rem63 = srem i32 %add62, 3
  store i32 %rem63, ptr %k, align 4
  %m_el65 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %24 = load i32, ptr %i, align 4
  %idxprom = sext i32 %24 to i64
  %arrayidx66 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el65, i64 0, i64 %idxprom
  %call67 = call noundef ptr @_ZNK9b3Vector3cvPKfEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx66)
  %25 = load i32, ptr %i, align 4
  %idxprom68 = sext i32 %25 to i64
  %arrayidx69 = getelementptr inbounds float, ptr %call67, i64 %idxprom68
  %26 = load float, ptr %arrayidx69, align 4
  %m_el70 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %27 = load i32, ptr %j, align 4
  %idxprom71 = sext i32 %27 to i64
  %arrayidx72 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el70, i64 0, i64 %idxprom71
  %call73 = call noundef ptr @_ZNK9b3Vector3cvPKfEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx72)
  %28 = load i32, ptr %j, align 4
  %idxprom74 = sext i32 %28 to i64
  %arrayidx75 = getelementptr inbounds float, ptr %call73, i64 %idxprom74
  %29 = load float, ptr %arrayidx75, align 4
  %sub76 = fsub float %26, %29
  %m_el77 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %30 = load i32, ptr %k, align 4
  %idxprom78 = sext i32 %30 to i64
  %arrayidx79 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el77, i64 0, i64 %idxprom78
  %call80 = call noundef ptr @_ZNK9b3Vector3cvPKfEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx79)
  %31 = load i32, ptr %k, align 4
  %idxprom81 = sext i32 %31 to i64
  %arrayidx82 = getelementptr inbounds float, ptr %call80, i64 %idxprom81
  %32 = load float, ptr %arrayidx82, align 4
  %sub83 = fsub float %sub76, %32
  %add84 = fadd float %sub83, 1.000000e+00
  %call85 = call noundef float @_Z6b3Sqrtf(float noundef %add84)
  store float %call85, ptr %s64, align 4
  %33 = load float, ptr %s64, align 4
  %mul86 = fmul float %33, 5.000000e-01
  %34 = load i32, ptr %i, align 4
  %idxprom87 = sext i32 %34 to i64
  %arrayidx88 = getelementptr inbounds [4 x float], ptr %temp, i64 0, i64 %idxprom87
  store float %mul86, ptr %arrayidx88, align 4
  %35 = load float, ptr %s64, align 4
  %div89 = fdiv float 5.000000e-01, %35
  store float %div89, ptr %s64, align 4
  %m_el90 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %36 = load i32, ptr %k, align 4
  %idxprom91 = sext i32 %36 to i64
  %arrayidx92 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el90, i64 0, i64 %idxprom91
  %call93 = call noundef ptr @_ZNK9b3Vector3cvPKfEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx92)
  %37 = load i32, ptr %j, align 4
  %idxprom94 = sext i32 %37 to i64
  %arrayidx95 = getelementptr inbounds float, ptr %call93, i64 %idxprom94
  %38 = load float, ptr %arrayidx95, align 4
  %m_el96 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %39 = load i32, ptr %j, align 4
  %idxprom97 = sext i32 %39 to i64
  %arrayidx98 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el96, i64 0, i64 %idxprom97
  %call99 = call noundef ptr @_ZNK9b3Vector3cvPKfEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx98)
  %40 = load i32, ptr %k, align 4
  %idxprom100 = sext i32 %40 to i64
  %arrayidx101 = getelementptr inbounds float, ptr %call99, i64 %idxprom100
  %41 = load float, ptr %arrayidx101, align 4
  %sub102 = fsub float %38, %41
  %42 = load float, ptr %s64, align 4
  %mul103 = fmul float %sub102, %42
  %arrayidx104 = getelementptr inbounds [4 x float], ptr %temp, i64 0, i64 3
  store float %mul103, ptr %arrayidx104, align 4
  %m_el105 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %43 = load i32, ptr %j, align 4
  %idxprom106 = sext i32 %43 to i64
  %arrayidx107 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el105, i64 0, i64 %idxprom106
  %call108 = call noundef ptr @_ZNK9b3Vector3cvPKfEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx107)
  %44 = load i32, ptr %i, align 4
  %idxprom109 = sext i32 %44 to i64
  %arrayidx110 = getelementptr inbounds float, ptr %call108, i64 %idxprom109
  %45 = load float, ptr %arrayidx110, align 4
  %m_el111 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %46 = load i32, ptr %i, align 4
  %idxprom112 = sext i32 %46 to i64
  %arrayidx113 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el111, i64 0, i64 %idxprom112
  %call114 = call noundef ptr @_ZNK9b3Vector3cvPKfEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx113)
  %47 = load i32, ptr %j, align 4
  %idxprom115 = sext i32 %47 to i64
  %arrayidx116 = getelementptr inbounds float, ptr %call114, i64 %idxprom115
  %48 = load float, ptr %arrayidx116, align 4
  %add117 = fadd float %45, %48
  %49 = load float, ptr %s64, align 4
  %mul118 = fmul float %add117, %49
  %50 = load i32, ptr %j, align 4
  %idxprom119 = sext i32 %50 to i64
  %arrayidx120 = getelementptr inbounds [4 x float], ptr %temp, i64 0, i64 %idxprom119
  store float %mul118, ptr %arrayidx120, align 4
  %m_el121 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %51 = load i32, ptr %k, align 4
  %idxprom122 = sext i32 %51 to i64
  %arrayidx123 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el121, i64 0, i64 %idxprom122
  %call124 = call noundef ptr @_ZNK9b3Vector3cvPKfEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx123)
  %52 = load i32, ptr %i, align 4
  %idxprom125 = sext i32 %52 to i64
  %arrayidx126 = getelementptr inbounds float, ptr %call124, i64 %idxprom125
  %53 = load float, ptr %arrayidx126, align 4
  %m_el127 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %54 = load i32, ptr %i, align 4
  %idxprom128 = sext i32 %54 to i64
  %arrayidx129 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el127, i64 0, i64 %idxprom128
  %call130 = call noundef ptr @_ZNK9b3Vector3cvPKfEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx129)
  %55 = load i32, ptr %k, align 4
  %idxprom131 = sext i32 %55 to i64
  %arrayidx132 = getelementptr inbounds float, ptr %call130, i64 %idxprom131
  %56 = load float, ptr %arrayidx132, align 4
  %add133 = fadd float %53, %56
  %57 = load float, ptr %s64, align 4
  %mul134 = fmul float %add133, %57
  %58 = load i32, ptr %k, align 4
  %idxprom135 = sext i32 %58 to i64
  %arrayidx136 = getelementptr inbounds [4 x float], ptr %temp, i64 0, i64 %idxprom135
  store float %mul134, ptr %arrayidx136, align 4
  br label %if.end

if.end:                                           ; preds = %cond.end, %if.then
  %59 = load ptr, ptr %q.addr, align 8
  %arrayidx137 = getelementptr inbounds [4 x float], ptr %temp, i64 0, i64 0
  %arrayidx138 = getelementptr inbounds [4 x float], ptr %temp, i64 0, i64 1
  %arrayidx139 = getelementptr inbounds [4 x float], ptr %temp, i64 0, i64 2
  %arrayidx140 = getelementptr inbounds [4 x float], ptr %temp, i64 0, i64 3
  call void @_ZN10b3QuadWord8setValueERKfS1_S1_S1_(ptr noundef nonnull align 16 dereferenceable(16) %59, ptr noundef nonnull align 4 dereferenceable(4) %arrayidx137, ptr noundef nonnull align 4 dereferenceable(4) %arrayidx138, ptr noundef nonnull align 4 dereferenceable(4) %arrayidx139, ptr noundef nonnull align 4 dereferenceable(4) %arrayidx140)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN10b3QuadWordC2Ev(ptr noundef nonnull align 16 dereferenceable(16) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret void
}

declare void @b3EnterProfileZone(ptr noundef) #5

declare void @b3LeaveProfileZone() #5

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK11b3Matrix3x39transposeEv(ptr noalias sret(%class.b3Matrix3x3) align 16 %agg.result, ptr noundef nonnull align 16 dereferenceable(48) %this) #0 comdat align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_el = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el, i64 0, i64 0
  %call = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getXEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx)
  %m_el2 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx3 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el2, i64 0, i64 1
  %call4 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getXEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx3)
  %m_el5 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el5, i64 0, i64 2
  %call7 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getXEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx6)
  %m_el8 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx9 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el8, i64 0, i64 0
  %call10 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getYEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx9)
  %m_el11 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx12 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el11, i64 0, i64 1
  %call13 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getYEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx12)
  %m_el14 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx15 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el14, i64 0, i64 2
  %call16 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getYEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx15)
  %m_el17 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx18 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el17, i64 0, i64 0
  %call19 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getZEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx18)
  %m_el20 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx21 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el20, i64 0, i64 1
  %call22 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getZEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx21)
  %m_el23 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx24 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el23, i64 0, i64 2
  %call25 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getZEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx24)
  call void @_ZN11b3Matrix3x3C2ERKfS1_S1_S1_S1_S1_S1_S1_S1_(ptr noundef nonnull align 16 dereferenceable(48) %agg.result, ptr noundef nonnull align 4 dereferenceable(4) %call, ptr noundef nonnull align 4 dereferenceable(4) %call4, ptr noundef nonnull align 4 dereferenceable(4) %call7, ptr noundef nonnull align 4 dereferenceable(4) %call10, ptr noundef nonnull align 4 dereferenceable(4) %call13, ptr noundef nonnull align 4 dereferenceable(4) %call16, ptr noundef nonnull align 4 dereferenceable(4) %call19, ptr noundef nonnull align 4 dereferenceable(4) %call22, ptr noundef nonnull align 4 dereferenceable(4) %call25)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN11b3TransformC2ERK11b3Matrix3x3RK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(64) %this, ptr noundef nonnull align 16 dereferenceable(48) %b, ptr noundef nonnull align 16 dereferenceable(16) %c) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %c.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  store ptr %c, ptr %c.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_basis = getelementptr inbounds %class.b3Transform, ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %b.addr, align 8
  call void @_ZN11b3Matrix3x3C2ERKS_(ptr noundef nonnull align 16 dereferenceable(48) %m_basis, ptr noundef nonnull align 16 dereferenceable(48) %0)
  %m_origin = getelementptr inbounds %class.b3Transform, ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %c.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %m_origin, ptr align 16 %1, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN11b3Matrix3x3C2ERKfS1_S1_S1_S1_S1_S1_S1_S1_(ptr noundef nonnull align 16 dereferenceable(48) %this, ptr noundef nonnull align 4 dereferenceable(4) %xx, ptr noundef nonnull align 4 dereferenceable(4) %xy, ptr noundef nonnull align 4 dereferenceable(4) %xz, ptr noundef nonnull align 4 dereferenceable(4) %yx, ptr noundef nonnull align 4 dereferenceable(4) %yy, ptr noundef nonnull align 4 dereferenceable(4) %yz, ptr noundef nonnull align 4 dereferenceable(4) %zx, ptr noundef nonnull align 4 dereferenceable(4) %zy, ptr noundef nonnull align 4 dereferenceable(4) %zz) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %xx.addr = alloca ptr, align 8
  %xy.addr = alloca ptr, align 8
  %xz.addr = alloca ptr, align 8
  %yx.addr = alloca ptr, align 8
  %yy.addr = alloca ptr, align 8
  %yz.addr = alloca ptr, align 8
  %zx.addr = alloca ptr, align 8
  %zy.addr = alloca ptr, align 8
  %zz.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %xx, ptr %xx.addr, align 8
  store ptr %xy, ptr %xy.addr, align 8
  store ptr %xz, ptr %xz.addr, align 8
  store ptr %yx, ptr %yx.addr, align 8
  store ptr %yy, ptr %yy.addr, align 8
  store ptr %yz, ptr %yz.addr, align 8
  store ptr %zx, ptr %zx.addr, align 8
  store ptr %zy, ptr %zy.addr, align 8
  store ptr %zz, ptr %zz.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %xx.addr, align 8
  %1 = load ptr, ptr %xy.addr, align 8
  %2 = load ptr, ptr %xz.addr, align 8
  %3 = load ptr, ptr %yx.addr, align 8
  %4 = load ptr, ptr %yy.addr, align 8
  %5 = load ptr, ptr %yz.addr, align 8
  %6 = load ptr, ptr %zx.addr, align 8
  %7 = load ptr, ptr %zy.addr, align 8
  %8 = load ptr, ptr %zz.addr, align 8
  call void @_ZN11b3Matrix3x38setValueERKfS1_S1_S1_S1_S1_S1_S1_S1_(ptr noundef nonnull align 16 dereferenceable(48) %this1, ptr noundef nonnull align 4 dereferenceable(4) %0, ptr noundef nonnull align 4 dereferenceable(4) %1, ptr noundef nonnull align 4 dereferenceable(4) %2, ptr noundef nonnull align 4 dereferenceable(4) %3, ptr noundef nonnull align 4 dereferenceable(4) %4, ptr noundef nonnull align 4 dereferenceable(4) %5, ptr noundef nonnull align 4 dereferenceable(4) %6, ptr noundef nonnull align 4 dereferenceable(4) %7, ptr noundef nonnull align 4 dereferenceable(4) %8)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN11b3Matrix3x3C2ERKS_(ptr noundef nonnull align 16 dereferenceable(48) %this, ptr noundef nonnull align 16 dereferenceable(48) %other) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %other.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %other, ptr %other.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %other.addr, align 8
  %m_el2 = getelementptr inbounds %class.b3Matrix3x3, ptr %0, i32 0, i32 0
  %arrayidx = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el2, i64 0, i64 0
  %m_el3 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el3, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx4, ptr align 16 %arrayidx, i64 16, i1 false)
  %1 = load ptr, ptr %other.addr, align 8
  %m_el5 = getelementptr inbounds %class.b3Matrix3x3, ptr %1, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el5, i64 0, i64 1
  %m_el7 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx8 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el7, i64 0, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx8, ptr align 16 %arrayidx6, i64 16, i1 false)
  %2 = load ptr, ptr %other.addr, align 8
  %m_el9 = getelementptr inbounds %class.b3Matrix3x3, ptr %2, i32 0, i32 0
  %arrayidx10 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el9, i64 0, i64 2
  %m_el11 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx12 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el11, i64 0, i64 2
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx12, ptr align 16 %arrayidx10, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZmlRK11b3Matrix3x3S1_(ptr noalias sret(%class.b3Matrix3x3) align 16 %agg.result, ptr noundef nonnull align 16 dereferenceable(48) %m1, ptr noundef nonnull align 16 dereferenceable(48) %m2) #0 comdat {
entry:
  %result.ptr = alloca ptr, align 8
  %m1.addr = alloca ptr, align 8
  %m2.addr = alloca ptr, align 8
  %ref.tmp = alloca float, align 4
  %ref.tmp2 = alloca float, align 4
  %ref.tmp5 = alloca float, align 4
  %ref.tmp8 = alloca float, align 4
  %ref.tmp11 = alloca float, align 4
  %ref.tmp14 = alloca float, align 4
  %ref.tmp17 = alloca float, align 4
  %ref.tmp20 = alloca float, align 4
  %ref.tmp23 = alloca float, align 4
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %m1, ptr %m1.addr, align 8
  store ptr %m2, ptr %m2.addr, align 8
  %0 = load ptr, ptr %m2.addr, align 8
  %1 = load ptr, ptr %m1.addr, align 8
  %call = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK11b3Matrix3x3ixEi(ptr noundef nonnull align 16 dereferenceable(48) %1, i32 noundef 0)
  %call1 = call noundef float @_ZNK11b3Matrix3x35tdotxERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(48) %0, ptr noundef nonnull align 16 dereferenceable(16) %call)
  store float %call1, ptr %ref.tmp, align 4
  %2 = load ptr, ptr %m2.addr, align 8
  %3 = load ptr, ptr %m1.addr, align 8
  %call3 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK11b3Matrix3x3ixEi(ptr noundef nonnull align 16 dereferenceable(48) %3, i32 noundef 0)
  %call4 = call noundef float @_ZNK11b3Matrix3x35tdotyERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(48) %2, ptr noundef nonnull align 16 dereferenceable(16) %call3)
  store float %call4, ptr %ref.tmp2, align 4
  %4 = load ptr, ptr %m2.addr, align 8
  %5 = load ptr, ptr %m1.addr, align 8
  %call6 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK11b3Matrix3x3ixEi(ptr noundef nonnull align 16 dereferenceable(48) %5, i32 noundef 0)
  %call7 = call noundef float @_ZNK11b3Matrix3x35tdotzERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(48) %4, ptr noundef nonnull align 16 dereferenceable(16) %call6)
  store float %call7, ptr %ref.tmp5, align 4
  %6 = load ptr, ptr %m2.addr, align 8
  %7 = load ptr, ptr %m1.addr, align 8
  %call9 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK11b3Matrix3x3ixEi(ptr noundef nonnull align 16 dereferenceable(48) %7, i32 noundef 1)
  %call10 = call noundef float @_ZNK11b3Matrix3x35tdotxERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(48) %6, ptr noundef nonnull align 16 dereferenceable(16) %call9)
  store float %call10, ptr %ref.tmp8, align 4
  %8 = load ptr, ptr %m2.addr, align 8
  %9 = load ptr, ptr %m1.addr, align 8
  %call12 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK11b3Matrix3x3ixEi(ptr noundef nonnull align 16 dereferenceable(48) %9, i32 noundef 1)
  %call13 = call noundef float @_ZNK11b3Matrix3x35tdotyERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(48) %8, ptr noundef nonnull align 16 dereferenceable(16) %call12)
  store float %call13, ptr %ref.tmp11, align 4
  %10 = load ptr, ptr %m2.addr, align 8
  %11 = load ptr, ptr %m1.addr, align 8
  %call15 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK11b3Matrix3x3ixEi(ptr noundef nonnull align 16 dereferenceable(48) %11, i32 noundef 1)
  %call16 = call noundef float @_ZNK11b3Matrix3x35tdotzERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(48) %10, ptr noundef nonnull align 16 dereferenceable(16) %call15)
  store float %call16, ptr %ref.tmp14, align 4
  %12 = load ptr, ptr %m2.addr, align 8
  %13 = load ptr, ptr %m1.addr, align 8
  %call18 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK11b3Matrix3x3ixEi(ptr noundef nonnull align 16 dereferenceable(48) %13, i32 noundef 2)
  %call19 = call noundef float @_ZNK11b3Matrix3x35tdotxERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(48) %12, ptr noundef nonnull align 16 dereferenceable(16) %call18)
  store float %call19, ptr %ref.tmp17, align 4
  %14 = load ptr, ptr %m2.addr, align 8
  %15 = load ptr, ptr %m1.addr, align 8
  %call21 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK11b3Matrix3x3ixEi(ptr noundef nonnull align 16 dereferenceable(48) %15, i32 noundef 2)
  %call22 = call noundef float @_ZNK11b3Matrix3x35tdotyERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(48) %14, ptr noundef nonnull align 16 dereferenceable(16) %call21)
  store float %call22, ptr %ref.tmp20, align 4
  %16 = load ptr, ptr %m2.addr, align 8
  %17 = load ptr, ptr %m1.addr, align 8
  %call24 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZNK11b3Matrix3x3ixEi(ptr noundef nonnull align 16 dereferenceable(48) %17, i32 noundef 2)
  %call25 = call noundef float @_ZNK11b3Matrix3x35tdotzERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(48) %16, ptr noundef nonnull align 16 dereferenceable(16) %call24)
  store float %call25, ptr %ref.tmp23, align 4
  call void @_ZN11b3Matrix3x3C2ERKfS1_S1_S1_S1_S1_S1_S1_S1_(ptr noundef nonnull align 16 dereferenceable(48) %agg.result, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp2, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp5, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp8, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp11, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp14, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp17, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp20, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp23)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef float @_ZNK11b3Matrix3x35tdotxERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(48) %this, ptr noundef nonnull align 16 dereferenceable(16) %v) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_el = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el, i64 0, i64 0
  %call = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getXEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx)
  %0 = load float, ptr %call, align 4
  %1 = load ptr, ptr %v.addr, align 8
  %call2 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getXEv(ptr noundef nonnull align 16 dereferenceable(16) %1)
  %2 = load float, ptr %call2, align 4
  %m_el3 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el3, i64 0, i64 1
  %call5 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getXEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx4)
  %3 = load float, ptr %call5, align 4
  %4 = load ptr, ptr %v.addr, align 8
  %call6 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getYEv(ptr noundef nonnull align 16 dereferenceable(16) %4)
  %5 = load float, ptr %call6, align 4
  %mul7 = fmul float %3, %5
  %6 = call float @llvm.fmuladd.f32(float %0, float %2, float %mul7)
  %m_el8 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx9 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el8, i64 0, i64 2
  %call10 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getXEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx9)
  %7 = load float, ptr %call10, align 4
  %8 = load ptr, ptr %v.addr, align 8
  %call11 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getZEv(ptr noundef nonnull align 16 dereferenceable(16) %8)
  %9 = load float, ptr %call11, align 4
  %10 = call float @llvm.fmuladd.f32(float %7, float %9, float %6)
  ret float %10
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef float @_ZNK11b3Matrix3x35tdotyERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(48) %this, ptr noundef nonnull align 16 dereferenceable(16) %v) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_el = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el, i64 0, i64 0
  %call = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getYEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx)
  %0 = load float, ptr %call, align 4
  %1 = load ptr, ptr %v.addr, align 8
  %call2 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getXEv(ptr noundef nonnull align 16 dereferenceable(16) %1)
  %2 = load float, ptr %call2, align 4
  %m_el3 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el3, i64 0, i64 1
  %call5 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getYEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx4)
  %3 = load float, ptr %call5, align 4
  %4 = load ptr, ptr %v.addr, align 8
  %call6 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getYEv(ptr noundef nonnull align 16 dereferenceable(16) %4)
  %5 = load float, ptr %call6, align 4
  %mul7 = fmul float %3, %5
  %6 = call float @llvm.fmuladd.f32(float %0, float %2, float %mul7)
  %m_el8 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx9 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el8, i64 0, i64 2
  %call10 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getYEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx9)
  %7 = load float, ptr %call10, align 4
  %8 = load ptr, ptr %v.addr, align 8
  %call11 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getZEv(ptr noundef nonnull align 16 dereferenceable(16) %8)
  %9 = load float, ptr %call11, align 4
  %10 = call float @llvm.fmuladd.f32(float %7, float %9, float %6)
  ret float %10
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef float @_ZNK11b3Matrix3x35tdotzERK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(48) %this, ptr noundef nonnull align 16 dereferenceable(16) %v) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_el = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el, i64 0, i64 0
  %call = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getZEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx)
  %0 = load float, ptr %call, align 4
  %1 = load ptr, ptr %v.addr, align 8
  %call2 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getXEv(ptr noundef nonnull align 16 dereferenceable(16) %1)
  %2 = load float, ptr %call2, align 4
  %m_el3 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el3, i64 0, i64 1
  %call5 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getZEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx4)
  %3 = load float, ptr %call5, align 4
  %4 = load ptr, ptr %v.addr, align 8
  %call6 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getYEv(ptr noundef nonnull align 16 dereferenceable(16) %4)
  %5 = load float, ptr %call6, align 4
  %mul7 = fmul float %3, %5
  %6 = call float @llvm.fmuladd.f32(float %0, float %2, float %mul7)
  %m_el8 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx9 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el8, i64 0, i64 2
  %call10 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getZEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx9)
  %7 = load float, ptr %call10, align 4
  %8 = load ptr, ptr %v.addr, align 8
  %call11 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getZEv(ptr noundef nonnull align 16 dereferenceable(16) %8)
  %9 = load float, ptr %call11, align 4
  %10 = call float @llvm.fmuladd.f32(float %7, float %9, float %6)
  ret float %10
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(48) ptr @_ZN11b3Matrix3x3aSERKS_(ptr noundef nonnull align 16 dereferenceable(48) %this, ptr noundef nonnull align 16 dereferenceable(48) %other) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %other.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %other, ptr %other.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %other.addr, align 8
  %m_el = getelementptr inbounds %class.b3Matrix3x3, ptr %0, i32 0, i32 0
  %arrayidx = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el, i64 0, i64 0
  %m_el2 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx3 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el2, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx3, ptr align 16 %arrayidx, i64 16, i1 false)
  %1 = load ptr, ptr %other.addr, align 8
  %m_el4 = getelementptr inbounds %class.b3Matrix3x3, ptr %1, i32 0, i32 0
  %arrayidx5 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el4, i64 0, i64 1
  %m_el6 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx7 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el6, i64 0, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx7, ptr align 16 %arrayidx5, i64 16, i1 false)
  %2 = load ptr, ptr %other.addr, align 8
  %m_el8 = getelementptr inbounds %class.b3Matrix3x3, ptr %2, i32 0, i32 0
  %arrayidx9 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el8, i64 0, i64 2
  %m_el10 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx11 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el10, i64 0, i64 2
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx11, ptr align 16 %arrayidx9, i64 16, i1 false)
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z23b3QuatGetRotationMatrixRK12b3Quaternion(ptr noalias sret(%class.b3Matrix3x3) align 16 %agg.result, ptr noundef nonnull align 16 dereferenceable(16) %quat) #0 comdat {
entry:
  %result.ptr = alloca ptr, align 8
  %quat.addr = alloca ptr, align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %quat, ptr %quat.addr, align 8
  %0 = load ptr, ptr %quat.addr, align 8
  call void @_ZN11b3Matrix3x3C2ERK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(48) %agg.result, ptr noundef nonnull align 16 dereferenceable(16) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z16b3AbsoluteMat3x3RK11b3Matrix3x3(ptr noalias sret(%class.b3Matrix3x3) align 16 %agg.result, ptr noundef nonnull align 16 dereferenceable(48) %mat) #0 comdat {
entry:
  %result.ptr = alloca ptr, align 8
  %mat.addr = alloca ptr, align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %mat, ptr %mat.addr, align 8
  %0 = load ptr, ptr %mat.addr, align 8
  call void @_ZNK11b3Matrix3x38absoluteEv(ptr sret(%class.b3Matrix3x3) align 16 %agg.result, ptr noundef nonnull align 16 dereferenceable(48) %0)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(16) ptr @_ZNK11b3Matrix3x36getRowEi(ptr noundef nonnull align 16 dereferenceable(48) %this, i32 noundef %i) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_el = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %0 to i64
  %arrayidx = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el, i64 0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN11b3Matrix3x3C2ERK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(48) %this, ptr noundef nonnull align 16 dereferenceable(16) %q) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %q.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %q, ptr %q.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %q.addr, align 8
  call void @_ZN11b3Matrix3x311setRotationERK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(48) %this1, ptr noundef nonnull align 16 dereferenceable(16) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK11b3Matrix3x38absoluteEv(ptr noalias sret(%class.b3Matrix3x3) align 16 %agg.result, ptr noundef nonnull align 16 dereferenceable(48) %this) #0 comdat align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca float, align 4
  %ref.tmp3 = alloca float, align 4
  %ref.tmp8 = alloca float, align 4
  %ref.tmp13 = alloca float, align 4
  %ref.tmp18 = alloca float, align 4
  %ref.tmp23 = alloca float, align 4
  %ref.tmp28 = alloca float, align 4
  %ref.tmp33 = alloca float, align 4
  %ref.tmp38 = alloca float, align 4
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_el = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el, i64 0, i64 0
  %call = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getXEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx)
  %0 = load float, ptr %call, align 4
  %call2 = call noundef float @_Z6b3Fabsf(float noundef %0)
  store float %call2, ptr %ref.tmp, align 4
  %m_el4 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx5 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el4, i64 0, i64 0
  %call6 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getYEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx5)
  %1 = load float, ptr %call6, align 4
  %call7 = call noundef float @_Z6b3Fabsf(float noundef %1)
  store float %call7, ptr %ref.tmp3, align 4
  %m_el9 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx10 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el9, i64 0, i64 0
  %call11 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getZEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx10)
  %2 = load float, ptr %call11, align 4
  %call12 = call noundef float @_Z6b3Fabsf(float noundef %2)
  store float %call12, ptr %ref.tmp8, align 4
  %m_el14 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx15 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el14, i64 0, i64 1
  %call16 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getXEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx15)
  %3 = load float, ptr %call16, align 4
  %call17 = call noundef float @_Z6b3Fabsf(float noundef %3)
  store float %call17, ptr %ref.tmp13, align 4
  %m_el19 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx20 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el19, i64 0, i64 1
  %call21 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getYEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx20)
  %4 = load float, ptr %call21, align 4
  %call22 = call noundef float @_Z6b3Fabsf(float noundef %4)
  store float %call22, ptr %ref.tmp18, align 4
  %m_el24 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx25 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el24, i64 0, i64 1
  %call26 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getZEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx25)
  %5 = load float, ptr %call26, align 4
  %call27 = call noundef float @_Z6b3Fabsf(float noundef %5)
  store float %call27, ptr %ref.tmp23, align 4
  %m_el29 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx30 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el29, i64 0, i64 2
  %call31 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getXEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx30)
  %6 = load float, ptr %call31, align 4
  %call32 = call noundef float @_Z6b3Fabsf(float noundef %6)
  store float %call32, ptr %ref.tmp28, align 4
  %m_el34 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx35 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el34, i64 0, i64 2
  %call36 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getYEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx35)
  %7 = load float, ptr %call36, align 4
  %call37 = call noundef float @_Z6b3Fabsf(float noundef %7)
  store float %call37, ptr %ref.tmp33, align 4
  %m_el39 = getelementptr inbounds %class.b3Matrix3x3, ptr %this1, i32 0, i32 0
  %arrayidx40 = getelementptr inbounds [3 x %class.b3Vector3], ptr %m_el39, i64 0, i64 2
  %call41 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK9b3Vector34getZEv(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx40)
  %8 = load float, ptr %call41, align 4
  %call42 = call noundef float @_Z6b3Fabsf(float noundef %8)
  store float %call42, ptr %ref.tmp38, align 4
  call void @_ZN11b3Matrix3x3C2ERKfS1_S1_S1_S1_S1_S1_S1_S1_(ptr noundef nonnull align 16 dereferenceable(48) %agg.result, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp3, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp8, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp13, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp18, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp23, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp28, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp33, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp38)
  ret void
}

; Function Attrs: mustprogress uwtable
define internal noundef zeroext i1 @_ZL11TestSepAxisRK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_RK20b3AlignedObjectArrayIS2_ESB_Rf(ptr noundef nonnull align 16 dereferenceable(96) %hullA, ptr noundef nonnull align 16 dereferenceable(96) %hullB, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %sep_axis, ptr noundef nonnull align 8 dereferenceable(25) %verticesA, ptr noundef nonnull align 8 dereferenceable(25) %verticesB, ptr noundef nonnull align 4 dereferenceable(4) %depth) #0 {
entry:
  %retval = alloca i1, align 1
  %hullA.addr = alloca ptr, align 8
  %hullB.addr = alloca ptr, align 8
  %posA.addr = alloca ptr, align 8
  %ornA.addr = alloca ptr, align 8
  %posB.addr = alloca ptr, align 8
  %ornB.addr = alloca ptr, align 8
  %sep_axis.addr = alloca ptr, align 8
  %verticesA.addr = alloca ptr, align 8
  %verticesB.addr = alloca ptr, align 8
  %depth.addr = alloca ptr, align 8
  %Min0 = alloca float, align 4
  %Max0 = alloca float, align 4
  %Min1 = alloca float, align 4
  %Max1 = alloca float, align 4
  %d0 = alloca float, align 4
  %d1 = alloca float, align 4
  store ptr %hullA, ptr %hullA.addr, align 8
  store ptr %hullB, ptr %hullB.addr, align 8
  store ptr %posA, ptr %posA.addr, align 8
  store ptr %ornA, ptr %ornA.addr, align 8
  store ptr %posB, ptr %posB.addr, align 8
  store ptr %ornB, ptr %ornB.addr, align 8
  store ptr %sep_axis, ptr %sep_axis.addr, align 8
  store ptr %verticesA, ptr %verticesA.addr, align 8
  store ptr %verticesB, ptr %verticesB.addr, align 8
  store ptr %depth, ptr %depth.addr, align 8
  %0 = load ptr, ptr %hullA.addr, align 8
  %1 = load ptr, ptr %posA.addr, align 8
  %2 = load ptr, ptr %ornA.addr, align 8
  %3 = load ptr, ptr %sep_axis.addr, align 8
  %4 = load ptr, ptr %verticesA.addr, align 8
  call void @_Z7projectRK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionS4_RK20b3AlignedObjectArrayIS2_ERfSC_(ptr noundef nonnull align 16 dereferenceable(96) %0, ptr noundef nonnull align 16 dereferenceable(16) %1, ptr noundef nonnull align 16 dereferenceable(16) %2, ptr noundef nonnull align 16 dereferenceable(16) %3, ptr noundef nonnull align 8 dereferenceable(25) %4, ptr noundef nonnull align 4 dereferenceable(4) %Min0, ptr noundef nonnull align 4 dereferenceable(4) %Max0)
  %5 = load ptr, ptr %hullB.addr, align 8
  %6 = load ptr, ptr %posB.addr, align 8
  %7 = load ptr, ptr %ornB.addr, align 8
  %8 = load ptr, ptr %sep_axis.addr, align 8
  %9 = load ptr, ptr %verticesB.addr, align 8
  call void @_Z7projectRK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionS4_RK20b3AlignedObjectArrayIS2_ERfSC_(ptr noundef nonnull align 16 dereferenceable(96) %5, ptr noundef nonnull align 16 dereferenceable(16) %6, ptr noundef nonnull align 16 dereferenceable(16) %7, ptr noundef nonnull align 16 dereferenceable(16) %8, ptr noundef nonnull align 8 dereferenceable(25) %9, ptr noundef nonnull align 4 dereferenceable(4) %Min1, ptr noundef nonnull align 4 dereferenceable(4) %Max1)
  %10 = load float, ptr %Max0, align 4
  %11 = load float, ptr %Min1, align 4
  %cmp = fcmp olt float %10, %11
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %12 = load float, ptr %Max1, align 4
  %13 = load float, ptr %Min0, align 4
  %cmp1 = fcmp olt float %12, %13
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %14 = load float, ptr %Max0, align 4
  %15 = load float, ptr %Min1, align 4
  %sub = fsub float %14, %15
  store float %sub, ptr %d0, align 4
  %16 = load float, ptr %Max1, align 4
  %17 = load float, ptr %Min0, align 4
  %sub2 = fsub float %16, %17
  store float %sub2, ptr %d1, align 4
  %18 = load float, ptr %d0, align 4
  %19 = load float, ptr %d1, align 4
  %cmp3 = fcmp olt float %18, %19
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %20 = load float, ptr %d0, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %21 = load float, ptr %d1, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %20, %cond.true ], [ %21, %cond.false ]
  %22 = load ptr, ptr %depth.addr, align 8
  store float %cond, ptr %22, align 4
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %23 = load i1, ptr %retval, align 1
  ret i1 %23
}

; Function Attrs: nounwind
declare float @sqrtf(float noundef) #10

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN12b3LauncherCL8launch2DEiiii(ptr noundef nonnull align 8 dereferenceable(112) %this, i32 noundef %numThreadsX, i32 noundef %numThreadsY, i32 noundef %localSizeX, i32 noundef %localSizeY) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %numThreadsX.addr = alloca i32, align 4
  %numThreadsY.addr = alloca i32, align 4
  %localSizeX.addr = alloca i32, align 4
  %localSizeY.addr = alloca i32, align 4
  %gRange = alloca [3 x i64], align 16
  %lRange = alloca [3 x i64], align 16
  %ref.tmp = alloca i64, align 8
  %ref.tmp4 = alloca i64, align 8
  %ref.tmp13 = alloca i64, align 8
  %ref.tmp14 = alloca i64, align 8
  %status = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %numThreadsX, ptr %numThreadsX.addr, align 4
  store i32 %numThreadsY, ptr %numThreadsY.addr, align 4
  store i32 %localSizeX, ptr %localSizeX.addr, align 4
  store i32 %localSizeY, ptr %localSizeY.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %gRange, ptr align 16 @__const._ZN12b3LauncherCL8launch2DEiiii.gRange, i64 24, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %lRange, ptr align 16 @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  %0 = load i32, ptr %localSizeX.addr, align 4
  %conv = sext i32 %0 to i64
  %arrayidx = getelementptr inbounds [3 x i64], ptr %lRange, i64 0, i64 0
  store i64 %conv, ptr %arrayidx, align 16
  %1 = load i32, ptr %localSizeY.addr, align 4
  %conv2 = sext i32 %1 to i64
  %arrayidx3 = getelementptr inbounds [3 x i64], ptr %lRange, i64 0, i64 1
  store i64 %conv2, ptr %arrayidx3, align 8
  store i64 1, ptr %ref.tmp, align 8
  %2 = load i32, ptr %numThreadsX.addr, align 4
  %conv5 = sext i32 %2 to i64
  %arrayidx6 = getelementptr inbounds [3 x i64], ptr %lRange, i64 0, i64 0
  %3 = load i64, ptr %arrayidx6, align 16
  %div = udiv i64 %conv5, %3
  %4 = load i32, ptr %numThreadsX.addr, align 4
  %conv7 = sext i32 %4 to i64
  %arrayidx8 = getelementptr inbounds [3 x i64], ptr %lRange, i64 0, i64 0
  %5 = load i64, ptr %arrayidx8, align 16
  %rem = urem i64 %conv7, %5
  %tobool = icmp ne i64 %rem, 0
  %lnot = xor i1 %tobool, true
  %cond = select i1 %lnot, i32 0, i32 1
  %conv9 = sext i32 %cond to i64
  %add = add i64 %div, %conv9
  store i64 %add, ptr %ref.tmp4, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_Z5b3MaxImERKT_S2_S2_(ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp4)
  %6 = load i64, ptr %call, align 8
  %arrayidx10 = getelementptr inbounds [3 x i64], ptr %gRange, i64 0, i64 0
  store i64 %6, ptr %arrayidx10, align 16
  %arrayidx11 = getelementptr inbounds [3 x i64], ptr %lRange, i64 0, i64 0
  %7 = load i64, ptr %arrayidx11, align 16
  %arrayidx12 = getelementptr inbounds [3 x i64], ptr %gRange, i64 0, i64 0
  %8 = load i64, ptr %arrayidx12, align 16
  %mul = mul i64 %8, %7
  store i64 %mul, ptr %arrayidx12, align 16
  store i64 1, ptr %ref.tmp13, align 8
  %9 = load i32, ptr %numThreadsY.addr, align 4
  %conv15 = sext i32 %9 to i64
  %arrayidx16 = getelementptr inbounds [3 x i64], ptr %lRange, i64 0, i64 1
  %10 = load i64, ptr %arrayidx16, align 8
  %div17 = udiv i64 %conv15, %10
  %11 = load i32, ptr %numThreadsY.addr, align 4
  %conv18 = sext i32 %11 to i64
  %arrayidx19 = getelementptr inbounds [3 x i64], ptr %lRange, i64 0, i64 1
  %12 = load i64, ptr %arrayidx19, align 8
  %rem20 = urem i64 %conv18, %12
  %tobool21 = icmp ne i64 %rem20, 0
  %lnot22 = xor i1 %tobool21, true
  %cond23 = select i1 %lnot22, i32 0, i32 1
  %conv24 = sext i32 %cond23 to i64
  %add25 = add i64 %div17, %conv24
  store i64 %add25, ptr %ref.tmp14, align 8
  %call26 = call noundef nonnull align 8 dereferenceable(8) ptr @_Z5b3MaxImERKT_S2_S2_(ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp13, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp14)
  %13 = load i64, ptr %call26, align 8
  %arrayidx27 = getelementptr inbounds [3 x i64], ptr %gRange, i64 0, i64 1
  store i64 %13, ptr %arrayidx27, align 8
  %arrayidx28 = getelementptr inbounds [3 x i64], ptr %lRange, i64 0, i64 1
  %14 = load i64, ptr %arrayidx28, align 8
  %arrayidx29 = getelementptr inbounds [3 x i64], ptr %gRange, i64 0, i64 1
  %15 = load i64, ptr %arrayidx29, align 8
  %mul30 = mul i64 %15, %14
  store i64 %mul30, ptr %arrayidx29, align 8
  %16 = load ptr, ptr @__clewEnqueueNDRangeKernel, align 8
  %m_commandQueue = getelementptr inbounds %class.b3LauncherCL, ptr %this1, i32 0, i32 1
  %17 = load ptr, ptr %m_commandQueue, align 8
  %m_kernel = getelementptr inbounds %class.b3LauncherCL, ptr %this1, i32 0, i32 2
  %18 = load ptr, ptr %m_kernel, align 8
  %arraydecay = getelementptr inbounds [3 x i64], ptr %gRange, i64 0, i64 0
  %arraydecay31 = getelementptr inbounds [3 x i64], ptr %lRange, i64 0, i64 0
  %call32 = call i32 %16(ptr noundef %17, ptr noundef %18, i32 noundef 2, ptr noundef null, ptr noundef %arraydecay, ptr noundef %arraydecay31, i32 noundef 0, ptr noundef null, ptr noundef null)
  store i32 %call32, ptr %status, align 4
  %19 = load i32, ptr %status, align 4
  %cmp = icmp ne i32 %19, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %20 = load i32, ptr %status, align 4
  %call33 = call i32 (ptr, ...) @printf(ptr noundef @.str.74, i32 noundef %20)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_Z5b3MaxImERKT_S2_S2_(ptr noundef nonnull align 8 dereferenceable(8) %a, ptr noundef nonnull align 8 dereferenceable(8) %b) #3 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %1 = load i64, ptr %0, align 8
  %2 = load ptr, ptr %b.addr, align 8
  %3 = load i64, ptr %2, align 8
  %cmp = icmp ugt i64 %1, %3
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load ptr, ptr %a.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load ptr, ptr %b.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond-lvalue = phi ptr [ %4, %cond.true ], [ %5, %cond.false ]
  ret ptr %cond-lvalue
}

; Function Attrs: mustprogress uwtable
define internal noundef i32 @_ZL16b3DiscoverPortaliiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_PiP15_b3MprSimplex_t(i32 noundef %pairIndex, i32 noundef %bodyIndexA, i32 noundef %bodyIndexB, ptr noundef %cpuBodyBuf, ptr noundef %cpuConvexData, ptr noundef %cpuCollidables, ptr noundef %cpuVertices, ptr noundef %sepAxis, ptr noundef %hasSepAxis, ptr noundef %portal) #2 {
entry:
  %retval = alloca i32, align 4
  %pairIndex.addr = alloca i32, align 4
  %bodyIndexA.addr = alloca i32, align 4
  %bodyIndexB.addr = alloca i32, align 4
  %cpuBodyBuf.addr = alloca ptr, align 8
  %cpuConvexData.addr = alloca ptr, align 8
  %cpuCollidables.addr = alloca ptr, align 8
  %cpuVertices.addr = alloca ptr, align 8
  %sepAxis.addr = alloca ptr, align 8
  %hasSepAxis.addr = alloca ptr, align 8
  %portal.addr = alloca ptr, align 8
  %dir = alloca %class.b3Vector3, align 16
  %va = alloca %class.b3Vector3, align 16
  %vb = alloca %class.b3Vector3, align 16
  %dot = alloca float, align 4
  %cont = alloca i32, align 4
  %zero = alloca %class.b3Vector3, align 16
  %b3mpr_vec3_origin = alloca ptr, align 8
  store i32 %pairIndex, ptr %pairIndex.addr, align 4
  store i32 %bodyIndexA, ptr %bodyIndexA.addr, align 4
  store i32 %bodyIndexB, ptr %bodyIndexB.addr, align 4
  store ptr %cpuBodyBuf, ptr %cpuBodyBuf.addr, align 8
  store ptr %cpuConvexData, ptr %cpuConvexData.addr, align 8
  store ptr %cpuCollidables, ptr %cpuCollidables.addr, align 8
  store ptr %cpuVertices, ptr %cpuVertices.addr, align 8
  store ptr %sepAxis, ptr %sepAxis.addr, align 8
  store ptr %hasSepAxis, ptr %hasSepAxis.addr, align 8
  store ptr %portal, ptr %portal.addr, align 8
  %0 = load i32, ptr %bodyIndexA.addr, align 4
  %1 = load i32, ptr %bodyIndexB.addr, align 4
  %2 = load ptr, ptr %cpuBodyBuf.addr, align 8
  %3 = load ptr, ptr %portal.addr, align 8
  %call = call noundef ptr @_Z18b3MprSimplexPointWP15_b3MprSimplex_ti(ptr noundef %3, i32 noundef 0)
  call void @_Z12b3FindOriginiiPK15b3RigidBodyDataP15_b3MprSupport_t(i32 noundef %0, i32 noundef %1, ptr noundef %2, ptr noundef %call)
  %4 = load ptr, ptr %portal.addr, align 8
  call void @_Z19b3MprSimplexSetSizeP15_b3MprSimplex_ti(ptr noundef %4, i32 noundef 1)
  %call1 = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %zero, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %5 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive2, i32 0, i32 0
  %6 = extractvalue { <2 x float>, <2 x float> } %call1, 0
  store <2 x float> %6, ptr %5, align 16
  %7 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive2, i32 0, i32 1
  %8 = extractvalue { <2 x float>, <2 x float> } %call1, 1
  store <2 x float> %8, ptr %7, align 8
  store ptr %zero, ptr %b3mpr_vec3_origin, align 8
  %9 = load ptr, ptr %portal.addr, align 8
  %call3 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %9, i32 noundef 0)
  %v = getelementptr inbounds %struct._b3MprSupport_t, ptr %call3, i32 0, i32 0
  %10 = load ptr, ptr %b3mpr_vec3_origin, align 8
  %call4 = call noundef i32 @_Z11b3MprVec3EqPK9b3Vector3S1_(ptr noundef %v, ptr noundef %10)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @_Z12b3MprVec3SetP9b3Vector3fff(ptr noundef %va, float noundef 0x3EB4000000000000, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %11 = load ptr, ptr %portal.addr, align 8
  %call5 = call noundef ptr @_Z18b3MprSimplexPointWP15_b3MprSimplex_ti(ptr noundef %11, i32 noundef 0)
  %v6 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call5, i32 0, i32 0
  call void @_Z12b3MprVec3AddP9b3Vector3PKS_(ptr noundef %v6, ptr noundef %va)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %12 = load ptr, ptr %portal.addr, align 8
  %call7 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %12, i32 noundef 0)
  %v8 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call7, i32 0, i32 0
  call void @_Z13b3MprVec3CopyP9b3Vector3PKS_(ptr noundef %dir, ptr noundef %v8)
  call void @_Z14b3MprVec3ScaleP9b3Vector3f(ptr noundef %dir, float noundef -1.000000e+00)
  call void @_Z18b3MprVec3NormalizeP9b3Vector3(ptr noundef %dir)
  %13 = load i32, ptr %pairIndex.addr, align 4
  %14 = load i32, ptr %bodyIndexA.addr, align 4
  %15 = load i32, ptr %bodyIndexB.addr, align 4
  %16 = load ptr, ptr %cpuBodyBuf.addr, align 8
  %17 = load ptr, ptr %cpuConvexData.addr, align 8
  %18 = load ptr, ptr %cpuCollidables.addr, align 8
  %19 = load ptr, ptr %cpuVertices.addr, align 8
  %20 = load ptr, ptr %sepAxis.addr, align 8
  %21 = load ptr, ptr %portal.addr, align 8
  %call9 = call noundef ptr @_Z18b3MprSimplexPointWP15_b3MprSimplex_ti(ptr noundef %21, i32 noundef 1)
  call void @_Z12b3MprSupportiiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_SA_P15_b3MprSupport_t(i32 noundef %13, i32 noundef %14, i32 noundef %15, ptr noundef %16, ptr noundef %17, ptr noundef %18, ptr noundef %19, ptr noundef %20, ptr noundef %dir, ptr noundef %call9)
  %22 = load ptr, ptr %portal.addr, align 8
  call void @_Z19b3MprSimplexSetSizeP15_b3MprSimplex_ti(ptr noundef %22, i32 noundef 2)
  %23 = load ptr, ptr %portal.addr, align 8
  %call10 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %23, i32 noundef 1)
  %v11 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call10, i32 0, i32 0
  %call12 = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %v11, ptr noundef %dir)
  store float %call12, ptr %dot, align 4
  %24 = load float, ptr %dot, align 4
  %call13 = call noundef i32 @_Z11b3MprIsZerof(float noundef %24)
  %tobool14 = icmp ne i32 %call13, 0
  br i1 %tobool14, label %if.then15, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %25 = load float, ptr %dot, align 4
  %cmp = fcmp olt float %25, 0.000000e+00
  br i1 %cmp, label %if.then15, label %if.end16

if.then15:                                        ; preds = %lor.lhs.false, %if.end
  store i32 -1, ptr %retval, align 4
  br label %return

if.end16:                                         ; preds = %lor.lhs.false
  %26 = load ptr, ptr %portal.addr, align 8
  %call17 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %26, i32 noundef 0)
  %v18 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call17, i32 0, i32 0
  %27 = load ptr, ptr %portal.addr, align 8
  %call19 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %27, i32 noundef 1)
  %v20 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call19, i32 0, i32 0
  call void @_Z14b3MprVec3CrossP9b3Vector3PKS_S2_(ptr noundef %dir, ptr noundef %v18, ptr noundef %v20)
  %call21 = call noundef float @_Z13b3MprVec3Len2PK9b3Vector3(ptr noundef %dir)
  %call22 = call noundef i32 @_Z11b3MprIsZerof(float noundef %call21)
  %tobool23 = icmp ne i32 %call22, 0
  br i1 %tobool23, label %if.then24, label %if.end30

if.then24:                                        ; preds = %if.end16
  %28 = load ptr, ptr %portal.addr, align 8
  %call25 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %28, i32 noundef 1)
  %v26 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call25, i32 0, i32 0
  %29 = load ptr, ptr %b3mpr_vec3_origin, align 8
  %call27 = call noundef i32 @_Z11b3MprVec3EqPK9b3Vector3S1_(ptr noundef %v26, ptr noundef %29)
  %tobool28 = icmp ne i32 %call27, 0
  br i1 %tobool28, label %if.then29, label %if.else

if.then29:                                        ; preds = %if.then24
  store i32 1, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %if.then24
  store i32 2, ptr %retval, align 4
  br label %return

if.end30:                                         ; preds = %if.end16
  call void @_Z18b3MprVec3NormalizeP9b3Vector3(ptr noundef %dir)
  %30 = load i32, ptr %pairIndex.addr, align 4
  %31 = load i32, ptr %bodyIndexA.addr, align 4
  %32 = load i32, ptr %bodyIndexB.addr, align 4
  %33 = load ptr, ptr %cpuBodyBuf.addr, align 8
  %34 = load ptr, ptr %cpuConvexData.addr, align 8
  %35 = load ptr, ptr %cpuCollidables.addr, align 8
  %36 = load ptr, ptr %cpuVertices.addr, align 8
  %37 = load ptr, ptr %sepAxis.addr, align 8
  %38 = load ptr, ptr %portal.addr, align 8
  %call31 = call noundef ptr @_Z18b3MprSimplexPointWP15_b3MprSimplex_ti(ptr noundef %38, i32 noundef 2)
  call void @_Z12b3MprSupportiiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_SA_P15_b3MprSupport_t(i32 noundef %30, i32 noundef %31, i32 noundef %32, ptr noundef %33, ptr noundef %34, ptr noundef %35, ptr noundef %36, ptr noundef %37, ptr noundef %dir, ptr noundef %call31)
  %39 = load ptr, ptr %portal.addr, align 8
  %call32 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %39, i32 noundef 2)
  %v33 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call32, i32 0, i32 0
  %call34 = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %v33, ptr noundef %dir)
  store float %call34, ptr %dot, align 4
  %40 = load float, ptr %dot, align 4
  %call35 = call noundef i32 @_Z11b3MprIsZerof(float noundef %40)
  %tobool36 = icmp ne i32 %call35, 0
  br i1 %tobool36, label %if.then39, label %lor.lhs.false37

lor.lhs.false37:                                  ; preds = %if.end30
  %41 = load float, ptr %dot, align 4
  %cmp38 = fcmp olt float %41, 0.000000e+00
  br i1 %cmp38, label %if.then39, label %if.end40

if.then39:                                        ; preds = %lor.lhs.false37, %if.end30
  store i32 -1, ptr %retval, align 4
  br label %return

if.end40:                                         ; preds = %lor.lhs.false37
  %42 = load ptr, ptr %portal.addr, align 8
  call void @_Z19b3MprSimplexSetSizeP15_b3MprSimplex_ti(ptr noundef %42, i32 noundef 3)
  %43 = load ptr, ptr %portal.addr, align 8
  %call41 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %43, i32 noundef 1)
  %v42 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call41, i32 0, i32 0
  %44 = load ptr, ptr %portal.addr, align 8
  %call43 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %44, i32 noundef 0)
  %v44 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call43, i32 0, i32 0
  call void @_Z13b3MprVec3Sub2P9b3Vector3PKS_S2_(ptr noundef %va, ptr noundef %v42, ptr noundef %v44)
  %45 = load ptr, ptr %portal.addr, align 8
  %call45 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %45, i32 noundef 2)
  %v46 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call45, i32 0, i32 0
  %46 = load ptr, ptr %portal.addr, align 8
  %call47 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %46, i32 noundef 0)
  %v48 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call47, i32 0, i32 0
  call void @_Z13b3MprVec3Sub2P9b3Vector3PKS_S2_(ptr noundef %vb, ptr noundef %v46, ptr noundef %v48)
  call void @_Z14b3MprVec3CrossP9b3Vector3PKS_S2_(ptr noundef %dir, ptr noundef %va, ptr noundef %vb)
  call void @_Z18b3MprVec3NormalizeP9b3Vector3(ptr noundef %dir)
  %47 = load ptr, ptr %portal.addr, align 8
  %call49 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %47, i32 noundef 0)
  %v50 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call49, i32 0, i32 0
  %call51 = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %dir, ptr noundef %v50)
  store float %call51, ptr %dot, align 4
  %48 = load float, ptr %dot, align 4
  %cmp52 = fcmp ogt float %48, 0.000000e+00
  br i1 %cmp52, label %if.then53, label %if.end54

if.then53:                                        ; preds = %if.end40
  %49 = load ptr, ptr %portal.addr, align 8
  call void @_Z16b3MprSimplexSwapP15_b3MprSimplex_tmm(ptr noundef %49, i64 noundef 1, i64 noundef 2)
  call void @_Z14b3MprVec3ScaleP9b3Vector3f(ptr noundef %dir, float noundef -1.000000e+00)
  br label %if.end54

if.end54:                                         ; preds = %if.then53, %if.end40
  br label %while.cond

while.cond:                                       ; preds = %if.end108, %if.end54
  %50 = load ptr, ptr %portal.addr, align 8
  %call55 = call noundef i32 @_Z16b3MprSimplexSizePK15_b3MprSimplex_t(ptr noundef %50)
  %cmp56 = icmp slt i32 %call55, 4
  br i1 %cmp56, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %51 = load i32, ptr %pairIndex.addr, align 4
  %52 = load i32, ptr %bodyIndexA.addr, align 4
  %53 = load i32, ptr %bodyIndexB.addr, align 4
  %54 = load ptr, ptr %cpuBodyBuf.addr, align 8
  %55 = load ptr, ptr %cpuConvexData.addr, align 8
  %56 = load ptr, ptr %cpuCollidables.addr, align 8
  %57 = load ptr, ptr %cpuVertices.addr, align 8
  %58 = load ptr, ptr %sepAxis.addr, align 8
  %59 = load ptr, ptr %portal.addr, align 8
  %call57 = call noundef ptr @_Z18b3MprSimplexPointWP15_b3MprSimplex_ti(ptr noundef %59, i32 noundef 3)
  call void @_Z12b3MprSupportiiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_SA_P15_b3MprSupport_t(i32 noundef %51, i32 noundef %52, i32 noundef %53, ptr noundef %54, ptr noundef %55, ptr noundef %56, ptr noundef %57, ptr noundef %58, ptr noundef %dir, ptr noundef %call57)
  %60 = load ptr, ptr %portal.addr, align 8
  %call58 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %60, i32 noundef 3)
  %v59 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call58, i32 0, i32 0
  %call60 = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %v59, ptr noundef %dir)
  store float %call60, ptr %dot, align 4
  %61 = load float, ptr %dot, align 4
  %call61 = call noundef i32 @_Z11b3MprIsZerof(float noundef %61)
  %tobool62 = icmp ne i32 %call61, 0
  br i1 %tobool62, label %if.then65, label %lor.lhs.false63

lor.lhs.false63:                                  ; preds = %while.body
  %62 = load float, ptr %dot, align 4
  %cmp64 = fcmp olt float %62, 0.000000e+00
  br i1 %cmp64, label %if.then65, label %if.end66

if.then65:                                        ; preds = %lor.lhs.false63, %while.body
  store i32 -1, ptr %retval, align 4
  br label %return

if.end66:                                         ; preds = %lor.lhs.false63
  store i32 0, ptr %cont, align 4
  %63 = load ptr, ptr %portal.addr, align 8
  %call67 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %63, i32 noundef 1)
  %v68 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call67, i32 0, i32 0
  %64 = load ptr, ptr %portal.addr, align 8
  %call69 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %64, i32 noundef 3)
  %v70 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call69, i32 0, i32 0
  call void @_Z14b3MprVec3CrossP9b3Vector3PKS_S2_(ptr noundef %va, ptr noundef %v68, ptr noundef %v70)
  %65 = load ptr, ptr %portal.addr, align 8
  %call71 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %65, i32 noundef 0)
  %v72 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call71, i32 0, i32 0
  %call73 = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %va, ptr noundef %v72)
  store float %call73, ptr %dot, align 4
  %66 = load float, ptr %dot, align 4
  %cmp74 = fcmp olt float %66, 0.000000e+00
  br i1 %cmp74, label %land.lhs.true, label %if.end79

land.lhs.true:                                    ; preds = %if.end66
  %67 = load float, ptr %dot, align 4
  %call75 = call noundef i32 @_Z11b3MprIsZerof(float noundef %67)
  %tobool76 = icmp ne i32 %call75, 0
  br i1 %tobool76, label %if.end79, label %if.then77

if.then77:                                        ; preds = %land.lhs.true
  %68 = load ptr, ptr %portal.addr, align 8
  %69 = load ptr, ptr %portal.addr, align 8
  %call78 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %69, i32 noundef 3)
  call void @_Z15b3MprSimplexSetP15_b3MprSimplex_tmPK15_b3MprSupport_t(ptr noundef %68, i64 noundef 2, ptr noundef %call78)
  store i32 1, ptr %cont, align 4
  br label %if.end79

if.end79:                                         ; preds = %if.then77, %land.lhs.true, %if.end66
  %70 = load i32, ptr %cont, align 4
  %tobool80 = icmp ne i32 %70, 0
  br i1 %tobool80, label %if.end96, label %if.then81

if.then81:                                        ; preds = %if.end79
  %71 = load ptr, ptr %portal.addr, align 8
  %call82 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %71, i32 noundef 3)
  %v83 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call82, i32 0, i32 0
  %72 = load ptr, ptr %portal.addr, align 8
  %call84 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %72, i32 noundef 2)
  %v85 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call84, i32 0, i32 0
  call void @_Z14b3MprVec3CrossP9b3Vector3PKS_S2_(ptr noundef %va, ptr noundef %v83, ptr noundef %v85)
  %73 = load ptr, ptr %portal.addr, align 8
  %call86 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %73, i32 noundef 0)
  %v87 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call86, i32 0, i32 0
  %call88 = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %va, ptr noundef %v87)
  store float %call88, ptr %dot, align 4
  %74 = load float, ptr %dot, align 4
  %cmp89 = fcmp olt float %74, 0.000000e+00
  br i1 %cmp89, label %land.lhs.true90, label %if.end95

land.lhs.true90:                                  ; preds = %if.then81
  %75 = load float, ptr %dot, align 4
  %call91 = call noundef i32 @_Z11b3MprIsZerof(float noundef %75)
  %tobool92 = icmp ne i32 %call91, 0
  br i1 %tobool92, label %if.end95, label %if.then93

if.then93:                                        ; preds = %land.lhs.true90
  %76 = load ptr, ptr %portal.addr, align 8
  %77 = load ptr, ptr %portal.addr, align 8
  %call94 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %77, i32 noundef 3)
  call void @_Z15b3MprSimplexSetP15_b3MprSimplex_tmPK15_b3MprSupport_t(ptr noundef %76, i64 noundef 1, ptr noundef %call94)
  store i32 1, ptr %cont, align 4
  br label %if.end95

if.end95:                                         ; preds = %if.then93, %land.lhs.true90, %if.then81
  br label %if.end96

if.end96:                                         ; preds = %if.end95, %if.end79
  %78 = load i32, ptr %cont, align 4
  %tobool97 = icmp ne i32 %78, 0
  br i1 %tobool97, label %if.then98, label %if.else107

if.then98:                                        ; preds = %if.end96
  %79 = load ptr, ptr %portal.addr, align 8
  %call99 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %79, i32 noundef 1)
  %v100 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call99, i32 0, i32 0
  %80 = load ptr, ptr %portal.addr, align 8
  %call101 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %80, i32 noundef 0)
  %v102 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call101, i32 0, i32 0
  call void @_Z13b3MprVec3Sub2P9b3Vector3PKS_S2_(ptr noundef %va, ptr noundef %v100, ptr noundef %v102)
  %81 = load ptr, ptr %portal.addr, align 8
  %call103 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %81, i32 noundef 2)
  %v104 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call103, i32 0, i32 0
  %82 = load ptr, ptr %portal.addr, align 8
  %call105 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %82, i32 noundef 0)
  %v106 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call105, i32 0, i32 0
  call void @_Z13b3MprVec3Sub2P9b3Vector3PKS_S2_(ptr noundef %vb, ptr noundef %v104, ptr noundef %v106)
  call void @_Z14b3MprVec3CrossP9b3Vector3PKS_S2_(ptr noundef %dir, ptr noundef %va, ptr noundef %vb)
  call void @_Z18b3MprVec3NormalizeP9b3Vector3(ptr noundef %dir)
  br label %if.end108

if.else107:                                       ; preds = %if.end96
  %83 = load ptr, ptr %portal.addr, align 8
  call void @_Z19b3MprSimplexSetSizeP15_b3MprSimplex_ti(ptr noundef %83, i32 noundef 4)
  br label %if.end108

if.end108:                                        ; preds = %if.else107, %if.then98
  br label %while.cond, !llvm.loop !79

while.end:                                        ; preds = %while.cond
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %while.end, %if.then65, %if.then39, %if.else, %if.then29, %if.then15
  %84 = load i32, ptr %retval, align 4
  ret i32 %84
}

; Function Attrs: mustprogress uwtable
define internal noundef i32 @_ZL14b3RefinePortaliiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_P15_b3MprSimplex_t(i32 noundef %pairIndex, i32 noundef %bodyIndexA, i32 noundef %bodyIndexB, ptr noundef %cpuBodyBuf, ptr noundef %cpuConvexData, ptr noundef %cpuCollidables, ptr noundef %cpuVertices, ptr noundef %sepAxis, ptr noundef %portal) #0 {
entry:
  %retval = alloca i32, align 4
  %pairIndex.addr = alloca i32, align 4
  %bodyIndexA.addr = alloca i32, align 4
  %bodyIndexB.addr = alloca i32, align 4
  %cpuBodyBuf.addr = alloca ptr, align 8
  %cpuConvexData.addr = alloca ptr, align 8
  %cpuCollidables.addr = alloca ptr, align 8
  %cpuVertices.addr = alloca ptr, align 8
  %sepAxis.addr = alloca ptr, align 8
  %portal.addr = alloca ptr, align 8
  %dir = alloca %class.b3Vector3, align 16
  %v4 = alloca %struct._b3MprSupport_t, align 16
  %i = alloca i32, align 4
  store i32 %pairIndex, ptr %pairIndex.addr, align 4
  store i32 %bodyIndexA, ptr %bodyIndexA.addr, align 4
  store i32 %bodyIndexB, ptr %bodyIndexB.addr, align 4
  store ptr %cpuBodyBuf, ptr %cpuBodyBuf.addr, align 8
  store ptr %cpuConvexData, ptr %cpuConvexData.addr, align 8
  store ptr %cpuCollidables, ptr %cpuCollidables.addr, align 8
  store ptr %cpuVertices, ptr %cpuVertices.addr, align 8
  store ptr %sepAxis, ptr %sepAxis.addr, align 8
  store ptr %portal, ptr %portal.addr, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %cmp = icmp slt i32 %0, 1000
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %portal.addr, align 8
  call void @_Z11b3PortalDirPK15_b3MprSimplex_tP9b3Vector3(ptr noundef %1, ptr noundef %dir)
  %2 = load ptr, ptr %portal.addr, align 8
  %call = call noundef i32 @_Z22portalEncapsulesOriginPK15_b3MprSimplex_tPK9b3Vector3(ptr noundef %2, ptr noundef %dir)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  %3 = load i32, ptr %pairIndex.addr, align 4
  %4 = load i32, ptr %bodyIndexA.addr, align 4
  %5 = load i32, ptr %bodyIndexB.addr, align 4
  %6 = load ptr, ptr %cpuBodyBuf.addr, align 8
  %7 = load ptr, ptr %cpuConvexData.addr, align 8
  %8 = load ptr, ptr %cpuCollidables.addr, align 8
  %9 = load ptr, ptr %cpuVertices.addr, align 8
  %10 = load ptr, ptr %sepAxis.addr, align 8
  call void @_Z12b3MprSupportiiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_SA_P15_b3MprSupport_t(i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6, ptr noundef %7, ptr noundef %8, ptr noundef %9, ptr noundef %10, ptr noundef %dir, ptr noundef %v4)
  %11 = load ptr, ptr %portal.addr, align 8
  %call1 = call noundef i32 @_Z24portalCanEncapsuleOriginPK15_b3MprSimplex_tPK15_b3MprSupport_tPK9b3Vector3(ptr noundef %11, ptr noundef %v4, ptr noundef %dir)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %lor.lhs.false, label %if.then5

lor.lhs.false:                                    ; preds = %if.end
  %12 = load ptr, ptr %portal.addr, align 8
  %call3 = call noundef i32 @_Z20portalReachTolerancePK15_b3MprSimplex_tPK15_b3MprSupport_tPK9b3Vector3(ptr noundef %12, ptr noundef %v4, ptr noundef %dir)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %lor.lhs.false, %if.end
  store i32 -1, ptr %retval, align 4
  br label %return

if.end6:                                          ; preds = %lor.lhs.false
  %13 = load ptr, ptr %portal.addr, align 8
  call void @_Z14b3ExpandPortalP15_b3MprSimplex_tPK15_b3MprSupport_t(ptr noundef %13, ptr noundef %v4)
  br label %for.inc

for.inc:                                          ; preds = %if.end6
  %14 = load i32, ptr %i, align 4
  %inc = add nsw i32 %14, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !80

for.end:                                          ; preds = %for.cond
  store i32 -1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then5, %if.then
  %15 = load i32, ptr %retval, align 4
  ret i32 %15
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL12b3FindPenetriiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_P15_b3MprSimplex_tPfSB_SB_(i32 noundef %pairIndex, i32 noundef %bodyIndexA, i32 noundef %bodyIndexB, ptr noundef %cpuBodyBuf, ptr noundef %cpuConvexData, ptr noundef %cpuCollidables, ptr noundef %cpuVertices, ptr noundef %sepAxis, ptr noundef %portal, ptr noundef %depth, ptr noundef %pdir, ptr noundef %pos) #2 {
entry:
  %pairIndex.addr = alloca i32, align 4
  %bodyIndexA.addr = alloca i32, align 4
  %bodyIndexB.addr = alloca i32, align 4
  %cpuBodyBuf.addr = alloca ptr, align 8
  %cpuConvexData.addr = alloca ptr, align 8
  %cpuCollidables.addr = alloca ptr, align 8
  %cpuVertices.addr = alloca ptr, align 8
  %sepAxis.addr = alloca ptr, align 8
  %portal.addr = alloca ptr, align 8
  %depth.addr = alloca ptr, align 8
  %pdir.addr = alloca ptr, align 8
  %pos.addr = alloca ptr, align 8
  %dir = alloca %class.b3Vector3, align 16
  %v4 = alloca %struct._b3MprSupport_t, align 16
  %iterations = alloca i64, align 8
  %zero = alloca %class.b3Vector3, align 16
  %b3mpr_vec3_origin = alloca ptr, align 8
  %i = alloca i32, align 4
  store i32 %pairIndex, ptr %pairIndex.addr, align 4
  store i32 %bodyIndexA, ptr %bodyIndexA.addr, align 4
  store i32 %bodyIndexB, ptr %bodyIndexB.addr, align 4
  store ptr %cpuBodyBuf, ptr %cpuBodyBuf.addr, align 8
  store ptr %cpuConvexData, ptr %cpuConvexData.addr, align 8
  store ptr %cpuCollidables, ptr %cpuCollidables.addr, align 8
  store ptr %cpuVertices, ptr %cpuVertices.addr, align 8
  store ptr %sepAxis, ptr %sepAxis.addr, align 8
  store ptr %portal, ptr %portal.addr, align 8
  store ptr %depth, ptr %depth.addr, align 8
  store ptr %pdir, ptr %pdir.addr, align 8
  store ptr %pos, ptr %pos.addr, align 8
  %call = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %zero, i32 0, i32 0
  %coerce.dive1 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive1, i32 0, i32 0
  %1 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %1, ptr %0, align 16
  %2 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive1, i32 0, i32 1
  %3 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %3, ptr %2, align 8
  store ptr %zero, ptr %b3mpr_vec3_origin, align 8
  store i64 1, ptr %iterations, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load i32, ptr %i, align 4
  %cmp = icmp slt i32 %4, 1000
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %portal.addr, align 8
  call void @_Z11b3PortalDirPK15_b3MprSimplex_tP9b3Vector3(ptr noundef %5, ptr noundef %dir)
  %6 = load i32, ptr %pairIndex.addr, align 4
  %7 = load i32, ptr %bodyIndexA.addr, align 4
  %8 = load i32, ptr %bodyIndexB.addr, align 4
  %9 = load ptr, ptr %cpuBodyBuf.addr, align 8
  %10 = load ptr, ptr %cpuConvexData.addr, align 8
  %11 = load ptr, ptr %cpuCollidables.addr, align 8
  %12 = load ptr, ptr %cpuVertices.addr, align 8
  %13 = load ptr, ptr %sepAxis.addr, align 8
  call void @_Z12b3MprSupportiiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_SA_P15_b3MprSupport_t(i32 noundef %6, i32 noundef %7, i32 noundef %8, ptr noundef %9, ptr noundef %10, ptr noundef %11, ptr noundef %12, ptr noundef %13, ptr noundef %dir, ptr noundef %v4)
  %14 = load ptr, ptr %portal.addr, align 8
  %call2 = call noundef i32 @_Z20portalReachTolerancePK15_b3MprSimplex_tPK15_b3MprSupport_tPK9b3Vector3(ptr noundef %14, ptr noundef %v4, ptr noundef %dir)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %15 = load i64, ptr %iterations, align 8
  %cmp3 = icmp eq i64 %15, 1000
  br i1 %cmp3, label %if.then, label %if.end19

if.then:                                          ; preds = %lor.lhs.false, %for.body
  %16 = load ptr, ptr %b3mpr_vec3_origin, align 8
  %17 = load ptr, ptr %portal.addr, align 8
  %call4 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %17, i32 noundef 1)
  %v = getelementptr inbounds %struct._b3MprSupport_t, ptr %call4, i32 0, i32 0
  %18 = load ptr, ptr %portal.addr, align 8
  %call5 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %18, i32 noundef 2)
  %v6 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call5, i32 0, i32 0
  %19 = load ptr, ptr %portal.addr, align 8
  %call7 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %19, i32 noundef 3)
  %v8 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call7, i32 0, i32 0
  %20 = load ptr, ptr %pdir.addr, align 8
  %call9 = call noundef float @_Z22b3MprVec3PointTriDist2PK9b3Vector3S1_S1_S1_PS_(ptr noundef %16, ptr noundef %v, ptr noundef %v6, ptr noundef %v8, ptr noundef %20)
  %21 = load ptr, ptr %depth.addr, align 8
  store float %call9, ptr %21, align 4
  %22 = load ptr, ptr %depth.addr, align 8
  %23 = load float, ptr %22, align 4
  %call10 = call float @sqrtf(float noundef %23) #13
  %24 = load ptr, ptr %depth.addr, align 8
  store float %call10, ptr %24, align 4
  %25 = load ptr, ptr %pdir.addr, align 8
  %26 = getelementptr inbounds %class.b3Vector3, ptr %25, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon.2, ptr %26, i32 0, i32 0
  %27 = load float, ptr %x, align 16
  %call11 = call noundef i32 @_Z11b3MprIsZerof(float noundef %27)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %28 = load ptr, ptr %pdir.addr, align 8
  %29 = getelementptr inbounds %class.b3Vector3, ptr %28, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon.2, ptr %29, i32 0, i32 1
  %30 = load float, ptr %y, align 4
  %call13 = call noundef i32 @_Z11b3MprIsZerof(float noundef %30)
  %tobool14 = icmp ne i32 %call13, 0
  br i1 %tobool14, label %land.lhs.true15, label %if.end

land.lhs.true15:                                  ; preds = %land.lhs.true
  %31 = load ptr, ptr %pdir.addr, align 8
  %32 = getelementptr inbounds %class.b3Vector3, ptr %31, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon.2, ptr %32, i32 0, i32 2
  %33 = load float, ptr %z, align 8
  %call16 = call noundef i32 @_Z11b3MprIsZerof(float noundef %33)
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %if.then18, label %if.end

if.then18:                                        ; preds = %land.lhs.true15
  %34 = load ptr, ptr %pdir.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %34, ptr align 16 %dir, i64 16, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then18, %land.lhs.true15, %land.lhs.true, %if.then
  %35 = load ptr, ptr %pdir.addr, align 8
  call void @_Z18b3MprVec3NormalizeP9b3Vector3(ptr noundef %35)
  %36 = load ptr, ptr %portal.addr, align 8
  %37 = load ptr, ptr %pos.addr, align 8
  call void @_ZL9b3FindPosPK15_b3MprSimplex_tP9b3Vector3(ptr noundef %36, ptr noundef %37)
  br label %for.end

if.end19:                                         ; preds = %lor.lhs.false
  %38 = load ptr, ptr %portal.addr, align 8
  call void @_Z14b3ExpandPortalP15_b3MprSimplex_tPK15_b3MprSupport_t(ptr noundef %38, ptr noundef %v4)
  %39 = load i64, ptr %iterations, align 8
  %inc = add i64 %39, 1
  store i64 %inc, ptr %iterations, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end19
  %40 = load i32, ptr %i, align 4
  %inc20 = add nsw i32 %40, 1
  store i32 %inc20, ptr %i, align 4
  br label %for.cond, !llvm.loop !81

for.end:                                          ; preds = %if.end, %for.cond
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZL17b3FindPenetrTouchP15_b3MprSimplex_tPfP9b3Vector3S3_(ptr noundef %portal, ptr noundef %depth, ptr noundef %dir, ptr noundef %pos) #6 {
entry:
  %portal.addr = alloca ptr, align 8
  %depth.addr = alloca ptr, align 8
  %dir.addr = alloca ptr, align 8
  %pos.addr = alloca ptr, align 8
  %zero = alloca %class.b3Vector3, align 16
  %b3mpr_vec3_origin = alloca ptr, align 8
  store ptr %portal, ptr %portal.addr, align 8
  store ptr %depth, ptr %depth.addr, align 8
  store ptr %dir, ptr %dir.addr, align 8
  store ptr %pos, ptr %pos.addr, align 8
  %0 = load ptr, ptr %depth.addr, align 8
  store float 0.000000e+00, ptr %0, align 4
  %call = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %zero, i32 0, i32 0
  %coerce.dive1 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %1 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive1, i32 0, i32 0
  %2 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %2, ptr %1, align 16
  %3 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive1, i32 0, i32 1
  %4 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %4, ptr %3, align 8
  store ptr %zero, ptr %b3mpr_vec3_origin, align 8
  %5 = load ptr, ptr %dir.addr, align 8
  %6 = load ptr, ptr %b3mpr_vec3_origin, align 8
  call void @_Z13b3MprVec3CopyP9b3Vector3PKS_(ptr noundef %5, ptr noundef %6)
  %7 = load ptr, ptr %pos.addr, align 8
  %8 = load ptr, ptr %portal.addr, align 8
  %call2 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %8, i32 noundef 1)
  %v1 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call2, i32 0, i32 1
  call void @_Z13b3MprVec3CopyP9b3Vector3PKS_(ptr noundef %7, ptr noundef %v1)
  %9 = load ptr, ptr %pos.addr, align 8
  %10 = load ptr, ptr %portal.addr, align 8
  %call3 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %10, i32 noundef 1)
  %v2 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call3, i32 0, i32 2
  call void @_Z12b3MprVec3AddP9b3Vector3PKS_(ptr noundef %9, ptr noundef %v2)
  %11 = load ptr, ptr %pos.addr, align 8
  call void @_Z14b3MprVec3ScaleP9b3Vector3f(ptr noundef %11, float noundef 5.000000e-01)
  ret void
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL19b3FindPenetrSegmentP15_b3MprSimplex_tPfP9b3Vector3S3_(ptr noundef %portal, ptr noundef %depth, ptr noundef %dir, ptr noundef %pos) #0 {
entry:
  %portal.addr = alloca ptr, align 8
  %depth.addr = alloca ptr, align 8
  %dir.addr = alloca ptr, align 8
  %pos.addr = alloca ptr, align 8
  store ptr %portal, ptr %portal.addr, align 8
  store ptr %depth, ptr %depth.addr, align 8
  store ptr %dir, ptr %dir.addr, align 8
  store ptr %pos, ptr %pos.addr, align 8
  %0 = load ptr, ptr %pos.addr, align 8
  %1 = load ptr, ptr %portal.addr, align 8
  %call = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %1, i32 noundef 1)
  %v1 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call, i32 0, i32 1
  call void @_Z13b3MprVec3CopyP9b3Vector3PKS_(ptr noundef %0, ptr noundef %v1)
  %2 = load ptr, ptr %pos.addr, align 8
  %3 = load ptr, ptr %portal.addr, align 8
  %call1 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %3, i32 noundef 1)
  %v2 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call1, i32 0, i32 2
  call void @_Z12b3MprVec3AddP9b3Vector3PKS_(ptr noundef %2, ptr noundef %v2)
  %4 = load ptr, ptr %pos.addr, align 8
  call void @_Z14b3MprVec3ScaleP9b3Vector3f(ptr noundef %4, float noundef 5.000000e-01)
  %5 = load ptr, ptr %dir.addr, align 8
  %6 = load ptr, ptr %portal.addr, align 8
  %call2 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %6, i32 noundef 1)
  %v = getelementptr inbounds %struct._b3MprSupport_t, ptr %call2, i32 0, i32 0
  call void @_Z13b3MprVec3CopyP9b3Vector3PKS_(ptr noundef %5, ptr noundef %v)
  %7 = load ptr, ptr %dir.addr, align 8
  %call3 = call noundef float @_Z13b3MprVec3Len2PK9b3Vector3(ptr noundef %7)
  %call4 = call float @sqrtf(float noundef %call3) #13
  %8 = load ptr, ptr %depth.addr, align 8
  store float %call4, ptr %8, align 4
  %9 = load ptr, ptr %dir.addr, align 8
  call void @_Z18b3MprVec3NormalizeP9b3Vector3(ptr noundef %9)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z12b3FindOriginiiPK15b3RigidBodyDataP15_b3MprSupport_t(i32 noundef %bodyIndexA, i32 noundef %bodyIndexB, ptr noundef %cpuBodyBuf, ptr noundef %center) #2 comdat {
entry:
  %bodyIndexA.addr = alloca i32, align 4
  %bodyIndexB.addr = alloca i32, align 4
  %cpuBodyBuf.addr = alloca ptr, align 8
  %center.addr = alloca ptr, align 8
  %ref.tmp = alloca %class.b3Vector3, align 16
  store i32 %bodyIndexA, ptr %bodyIndexA.addr, align 4
  store i32 %bodyIndexB, ptr %bodyIndexB.addr, align 4
  store ptr %cpuBodyBuf, ptr %cpuBodyBuf.addr, align 8
  store ptr %center, ptr %center.addr, align 8
  %0 = load ptr, ptr %cpuBodyBuf.addr, align 8
  %1 = load i32, ptr %bodyIndexA.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3RigidBodyData, ptr %0, i64 %idxprom
  %m_pos = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx, i32 0, i32 0
  %2 = load ptr, ptr %center.addr, align 8
  %v1 = getelementptr inbounds %struct._b3MprSupport_t, ptr %2, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %v1, ptr align 16 %m_pos, i64 16, i1 false)
  %3 = load ptr, ptr %cpuBodyBuf.addr, align 8
  %4 = load i32, ptr %bodyIndexB.addr, align 4
  %idxprom1 = sext i32 %4 to i64
  %arrayidx2 = getelementptr inbounds %struct.b3RigidBodyData, ptr %3, i64 %idxprom1
  %m_pos3 = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx2, i32 0, i32 0
  %5 = load ptr, ptr %center.addr, align 8
  %v2 = getelementptr inbounds %struct._b3MprSupport_t, ptr %5, i32 0, i32 2
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %v2, ptr align 16 %m_pos3, i64 16, i1 false)
  %6 = load ptr, ptr %center.addr, align 8
  %v14 = getelementptr inbounds %struct._b3MprSupport_t, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %center.addr, align 8
  %v25 = getelementptr inbounds %struct._b3MprSupport_t, ptr %7, i32 0, i32 2
  %call = call { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %v14, ptr noundef nonnull align 16 dereferenceable(16) %v25)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %8 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive6, i32 0, i32 0
  %9 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %9, ptr %8, align 16
  %10 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive6, i32 0, i32 1
  %11 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %11, ptr %10, align 8
  %12 = load ptr, ptr %center.addr, align 8
  %v = getelementptr inbounds %struct._b3MprSupport_t, ptr %12, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %v, ptr align 16 %ref.tmp, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_Z18b3MprSimplexPointWP15_b3MprSimplex_ti(ptr noundef %s, i32 noundef %idx) #3 comdat {
entry:
  %s.addr = alloca ptr, align 8
  %idx.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %idx, ptr %idx.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %ps = getelementptr inbounds %struct._b3MprSimplex_t, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %idx.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %ps, i64 0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_Z19b3MprSimplexSetSizeP15_b3MprSimplex_ti(ptr noundef %s, i32 noundef %size) #3 comdat {
entry:
  %s.addr = alloca ptr, align 8
  %size.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %0 = load i32, ptr %size.addr, align 4
  %sub = sub nsw i32 %0, 1
  %1 = load ptr, ptr %s.addr, align 8
  %last = getelementptr inbounds %struct._b3MprSimplex_t, ptr %1, i32 0, i32 1
  store i32 %sub, ptr %last, align 16
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i32 @_Z11b3MprVec3EqPK9b3Vector3S1_(ptr noundef %a, ptr noundef %b) #0 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %1 = getelementptr inbounds %class.b3Vector3, ptr %0, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon.2, ptr %1, i32 0, i32 0
  %2 = load float, ptr %x, align 16
  %3 = load ptr, ptr %b.addr, align 8
  %4 = getelementptr inbounds %class.b3Vector3, ptr %3, i32 0, i32 0
  %x1 = getelementptr inbounds %struct.anon.2, ptr %4, i32 0, i32 0
  %5 = load float, ptr %x1, align 16
  %call = call noundef i32 @_Z7b3MprEqff(float noundef %2, float noundef %5)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %6 = load ptr, ptr %a.addr, align 8
  %7 = getelementptr inbounds %class.b3Vector3, ptr %6, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon.2, ptr %7, i32 0, i32 1
  %8 = load float, ptr %y, align 4
  %9 = load ptr, ptr %b.addr, align 8
  %10 = getelementptr inbounds %class.b3Vector3, ptr %9, i32 0, i32 0
  %y2 = getelementptr inbounds %struct.anon.2, ptr %10, i32 0, i32 1
  %11 = load float, ptr %y2, align 4
  %call3 = call noundef i32 @_Z7b3MprEqff(float noundef %8, float noundef %11)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %12 = load ptr, ptr %a.addr, align 8
  %13 = getelementptr inbounds %class.b3Vector3, ptr %12, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon.2, ptr %13, i32 0, i32 2
  %14 = load float, ptr %z, align 8
  %15 = load ptr, ptr %b.addr, align 8
  %16 = getelementptr inbounds %class.b3Vector3, ptr %15, i32 0, i32 0
  %z5 = getelementptr inbounds %struct.anon.2, ptr %16, i32 0, i32 2
  %17 = load float, ptr %z5, align 8
  %call6 = call noundef i32 @_Z7b3MprEqff(float noundef %14, float noundef %17)
  %tobool7 = icmp ne i32 %call6, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %18 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %tobool7, %land.rhs ]
  %conv = zext i1 %18 to i32
  ret i32 %conv
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %s, i32 noundef %idx) #3 comdat {
entry:
  %s.addr = alloca ptr, align 8
  %idx.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %idx, ptr %idx.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %ps = getelementptr inbounds %struct._b3MprSimplex_t, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %idx.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %ps, i64 0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_Z12b3MprVec3SetP9b3Vector3fff(ptr noundef %v, float noundef %x, float noundef %y, float noundef %z) #3 comdat {
entry:
  %v.addr = alloca ptr, align 8
  %x.addr = alloca float, align 4
  %y.addr = alloca float, align 4
  %z.addr = alloca float, align 4
  store ptr %v, ptr %v.addr, align 8
  store float %x, ptr %x.addr, align 4
  store float %y, ptr %y.addr, align 4
  store float %z, ptr %z.addr, align 4
  %0 = load float, ptr %x.addr, align 4
  %1 = load ptr, ptr %v.addr, align 8
  %2 = getelementptr inbounds %class.b3Vector3, ptr %1, i32 0, i32 0
  %x1 = getelementptr inbounds %struct.anon.2, ptr %2, i32 0, i32 0
  store float %0, ptr %x1, align 16
  %3 = load float, ptr %y.addr, align 4
  %4 = load ptr, ptr %v.addr, align 8
  %5 = getelementptr inbounds %class.b3Vector3, ptr %4, i32 0, i32 0
  %y2 = getelementptr inbounds %struct.anon.2, ptr %5, i32 0, i32 1
  store float %3, ptr %y2, align 4
  %6 = load float, ptr %z.addr, align 4
  %7 = load ptr, ptr %v.addr, align 8
  %8 = getelementptr inbounds %class.b3Vector3, ptr %7, i32 0, i32 0
  %z3 = getelementptr inbounds %struct.anon.2, ptr %8, i32 0, i32 2
  store float %6, ptr %z3, align 8
  %9 = load ptr, ptr %v.addr, align 8
  %10 = getelementptr inbounds %class.b3Vector3, ptr %9, i32 0, i32 0
  %w = getelementptr inbounds %struct.anon.2, ptr %10, i32 0, i32 3
  store float 0.000000e+00, ptr %w, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_Z12b3MprVec3AddP9b3Vector3PKS_(ptr noundef %v, ptr noundef %w) #3 comdat {
entry:
  %v.addr = alloca ptr, align 8
  %w.addr = alloca ptr, align 8
  store ptr %v, ptr %v.addr, align 8
  store ptr %w, ptr %w.addr, align 8
  %0 = load ptr, ptr %w.addr, align 8
  %1 = getelementptr inbounds %class.b3Vector3, ptr %0, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon.2, ptr %1, i32 0, i32 0
  %2 = load float, ptr %x, align 16
  %3 = load ptr, ptr %v.addr, align 8
  %4 = getelementptr inbounds %class.b3Vector3, ptr %3, i32 0, i32 0
  %x1 = getelementptr inbounds %struct.anon.2, ptr %4, i32 0, i32 0
  %5 = load float, ptr %x1, align 16
  %add = fadd float %5, %2
  store float %add, ptr %x1, align 16
  %6 = load ptr, ptr %w.addr, align 8
  %7 = getelementptr inbounds %class.b3Vector3, ptr %6, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon.2, ptr %7, i32 0, i32 1
  %8 = load float, ptr %y, align 4
  %9 = load ptr, ptr %v.addr, align 8
  %10 = getelementptr inbounds %class.b3Vector3, ptr %9, i32 0, i32 0
  %y2 = getelementptr inbounds %struct.anon.2, ptr %10, i32 0, i32 1
  %11 = load float, ptr %y2, align 4
  %add3 = fadd float %11, %8
  store float %add3, ptr %y2, align 4
  %12 = load ptr, ptr %w.addr, align 8
  %13 = getelementptr inbounds %class.b3Vector3, ptr %12, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon.2, ptr %13, i32 0, i32 2
  %14 = load float, ptr %z, align 8
  %15 = load ptr, ptr %v.addr, align 8
  %16 = getelementptr inbounds %class.b3Vector3, ptr %15, i32 0, i32 0
  %z4 = getelementptr inbounds %struct.anon.2, ptr %16, i32 0, i32 2
  %17 = load float, ptr %z4, align 8
  %add5 = fadd float %17, %14
  store float %add5, ptr %z4, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_Z13b3MprVec3CopyP9b3Vector3PKS_(ptr noundef %v, ptr noundef %w) #3 comdat {
entry:
  %v.addr = alloca ptr, align 8
  %w.addr = alloca ptr, align 8
  store ptr %v, ptr %v.addr, align 8
  store ptr %w, ptr %w.addr, align 8
  %0 = load ptr, ptr %w.addr, align 8
  %1 = load ptr, ptr %v.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %1, ptr align 16 %0, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_Z14b3MprVec3ScaleP9b3Vector3f(ptr noundef %d, float noundef %k) #3 comdat {
entry:
  %d.addr = alloca ptr, align 8
  %k.addr = alloca float, align 4
  store ptr %d, ptr %d.addr, align 8
  store float %k, ptr %k.addr, align 4
  %0 = load ptr, ptr %d.addr, align 8
  %call = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN9b3Vector3mLERKf(ptr noundef nonnull align 16 dereferenceable(16) %0, ptr noundef nonnull align 4 dereferenceable(4) %k.addr)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z18b3MprVec3NormalizeP9b3Vector3(ptr noundef %d) #0 comdat {
entry:
  %d.addr = alloca ptr, align 8
  %k = alloca float, align 4
  store ptr %d, ptr %d.addr, align 8
  %0 = load ptr, ptr %d.addr, align 8
  %call = call noundef float @_Z13b3MprVec3Len2PK9b3Vector3(ptr noundef %0)
  %call1 = call float @sqrtf(float noundef %call) #13
  %div = fdiv float 1.000000e+00, %call1
  store float %div, ptr %k, align 4
  %1 = load ptr, ptr %d.addr, align 8
  %2 = load float, ptr %k, align 4
  call void @_Z14b3MprVec3ScaleP9b3Vector3f(ptr noundef %1, float noundef %2)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z12b3MprSupportiiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_SA_P15_b3MprSupport_t(i32 noundef %pairIndex, i32 noundef %bodyIndexA, i32 noundef %bodyIndexB, ptr noundef %cpuBodyBuf, ptr noundef %cpuConvexData, ptr noundef %cpuCollidables, ptr noundef %cpuVertices, ptr noundef %sepAxis, ptr noundef %_dir, ptr noundef %supp) #2 comdat {
entry:
  %pairIndex.addr = alloca i32, align 4
  %bodyIndexA.addr = alloca i32, align 4
  %bodyIndexB.addr = alloca i32, align 4
  %cpuBodyBuf.addr = alloca ptr, align 8
  %cpuConvexData.addr = alloca ptr, align 8
  %cpuCollidables.addr = alloca ptr, align 8
  %cpuVertices.addr = alloca ptr, align 8
  %sepAxis.addr = alloca ptr, align 8
  %_dir.addr = alloca ptr, align 8
  %supp.addr = alloca ptr, align 8
  %dir = alloca %class.b3Vector3, align 16
  %ref.tmp = alloca %class.b3Vector3, align 16
  %ref.tmp1 = alloca float, align 4
  %ref.tmp3 = alloca %class.b3Vector3, align 16
  store i32 %pairIndex, ptr %pairIndex.addr, align 4
  store i32 %bodyIndexA, ptr %bodyIndexA.addr, align 4
  store i32 %bodyIndexB, ptr %bodyIndexB.addr, align 4
  store ptr %cpuBodyBuf, ptr %cpuBodyBuf.addr, align 8
  store ptr %cpuConvexData, ptr %cpuConvexData.addr, align 8
  store ptr %cpuCollidables, ptr %cpuCollidables.addr, align 8
  store ptr %cpuVertices, ptr %cpuVertices.addr, align 8
  store ptr %sepAxis, ptr %sepAxis.addr, align 8
  store ptr %_dir, ptr %_dir.addr, align 8
  store ptr %supp, ptr %supp.addr, align 8
  %0 = load ptr, ptr %_dir.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %dir, ptr align 16 %0, i64 16, i1 false)
  %1 = load i32, ptr %pairIndex.addr, align 4
  %2 = load i32, ptr %bodyIndexA.addr, align 4
  %3 = load ptr, ptr %cpuBodyBuf.addr, align 8
  %4 = load ptr, ptr %cpuConvexData.addr, align 8
  %5 = load ptr, ptr %cpuCollidables.addr, align 8
  %6 = load ptr, ptr %cpuVertices.addr, align 8
  %7 = load ptr, ptr %sepAxis.addr, align 8
  %8 = load ptr, ptr %supp.addr, align 8
  %v1 = getelementptr inbounds %struct._b3MprSupport_t, ptr %8, i32 0, i32 1
  call void @_ZL18b3MprConvexSupportiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_SA_SB_i(i32 noundef %1, i32 noundef %2, ptr noundef %3, ptr noundef %4, ptr noundef %5, ptr noundef %6, ptr noundef %7, ptr noundef %dir, ptr noundef %v1, i32 noundef 0)
  %9 = load ptr, ptr %_dir.addr, align 8
  store float -1.000000e+00, ptr %ref.tmp1, align 4
  %call = call { <2 x float>, <2 x float> } @_ZmlRK9b3Vector3RKf(ptr noundef nonnull align 16 dereferenceable(16) %9, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp1)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %10 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive2, i32 0, i32 0
  %11 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %11, ptr %10, align 16
  %12 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive2, i32 0, i32 1
  %13 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %13, ptr %12, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %dir, ptr align 16 %ref.tmp, i64 16, i1 false)
  %14 = load i32, ptr %pairIndex.addr, align 4
  %15 = load i32, ptr %bodyIndexB.addr, align 4
  %16 = load ptr, ptr %cpuBodyBuf.addr, align 8
  %17 = load ptr, ptr %cpuConvexData.addr, align 8
  %18 = load ptr, ptr %cpuCollidables.addr, align 8
  %19 = load ptr, ptr %cpuVertices.addr, align 8
  %20 = load ptr, ptr %sepAxis.addr, align 8
  %21 = load ptr, ptr %supp.addr, align 8
  %v2 = getelementptr inbounds %struct._b3MprSupport_t, ptr %21, i32 0, i32 2
  call void @_ZL18b3MprConvexSupportiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_SA_SB_i(i32 noundef %14, i32 noundef %15, ptr noundef %16, ptr noundef %17, ptr noundef %18, ptr noundef %19, ptr noundef %20, ptr noundef %dir, ptr noundef %v2, i32 noundef 0)
  %22 = load ptr, ptr %supp.addr, align 8
  %v14 = getelementptr inbounds %struct._b3MprSupport_t, ptr %22, i32 0, i32 1
  %23 = load ptr, ptr %supp.addr, align 8
  %v25 = getelementptr inbounds %struct._b3MprSupport_t, ptr %23, i32 0, i32 2
  %call6 = call { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %v14, ptr noundef nonnull align 16 dereferenceable(16) %v25)
  %coerce.dive7 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp3, i32 0, i32 0
  %coerce.dive8 = getelementptr inbounds %union.anon.1, ptr %coerce.dive7, i32 0, i32 0
  %24 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive8, i32 0, i32 0
  %25 = extractvalue { <2 x float>, <2 x float> } %call6, 0
  store <2 x float> %25, ptr %24, align 16
  %26 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive8, i32 0, i32 1
  %27 = extractvalue { <2 x float>, <2 x float> } %call6, 1
  store <2 x float> %27, ptr %26, align 8
  %28 = load ptr, ptr %supp.addr, align 8
  %v = getelementptr inbounds %struct._b3MprSupport_t, ptr %28, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %v, ptr align 16 %ref.tmp3, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %a, ptr noundef %b) #0 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %dot = alloca float, align 4
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %1 = load ptr, ptr %b.addr, align 8
  %call = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %0, ptr noundef nonnull align 16 dereferenceable(16) %1)
  store float %call, ptr %dot, align 4
  %2 = load float, ptr %dot, align 4
  ret float %2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_Z11b3MprIsZerof(float noundef %val) #3 comdat {
entry:
  %val.addr = alloca float, align 4
  store float %val, ptr %val.addr, align 4
  %0 = load float, ptr %val.addr, align 4
  %call = call noundef float @_ZSt4fabsf(float noundef %0)
  %cmp = fcmp olt float %call, 0x3E80000000000000
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14b3MprVec3CrossP9b3Vector3PKS_S2_(ptr noundef %d, ptr noundef %a, ptr noundef %b) #2 comdat {
entry:
  %d.addr = alloca ptr, align 8
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %ref.tmp = alloca %class.b3Vector3, align 16
  store ptr %d, ptr %d.addr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %1 = load ptr, ptr %b.addr, align 8
  %call = call { <2 x float>, <2 x float> } @_Z7b3CrossRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %0, ptr noundef nonnull align 16 dereferenceable(16) %1)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive1 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %2 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive1, i32 0, i32 0
  %3 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %3, ptr %2, align 16
  %4 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive1, i32 0, i32 1
  %5 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %5, ptr %4, align 8
  %6 = load ptr, ptr %d.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %6, ptr align 16 %ref.tmp, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef float @_Z13b3MprVec3Len2PK9b3Vector3(ptr noundef %v) #0 comdat {
entry:
  %v.addr = alloca ptr, align 8
  store ptr %v, ptr %v.addr, align 8
  %0 = load ptr, ptr %v.addr, align 8
  %1 = load ptr, ptr %v.addr, align 8
  %call = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %0, ptr noundef %1)
  ret float %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z13b3MprVec3Sub2P9b3Vector3PKS_S2_(ptr noundef %d, ptr noundef %v, ptr noundef %w) #2 comdat {
entry:
  %d.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  %w.addr = alloca ptr, align 8
  %ref.tmp = alloca %class.b3Vector3, align 16
  store ptr %d, ptr %d.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  store ptr %w, ptr %w.addr, align 8
  %0 = load ptr, ptr %v.addr, align 8
  %1 = load ptr, ptr %w.addr, align 8
  %call = call { <2 x float>, <2 x float> } @_ZmiRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %0, ptr noundef nonnull align 16 dereferenceable(16) %1)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive1 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %2 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive1, i32 0, i32 0
  %3 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %3, ptr %2, align 16
  %4 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive1, i32 0, i32 1
  %5 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %5, ptr %4, align 8
  %6 = load ptr, ptr %d.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %6, ptr align 16 %ref.tmp, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z16b3MprSimplexSwapP15_b3MprSimplex_tmm(ptr noundef %s, i64 noundef %pos1, i64 noundef %pos2) #0 comdat {
entry:
  %s.addr = alloca ptr, align 8
  %pos1.addr = alloca i64, align 8
  %pos2.addr = alloca i64, align 8
  %supp = alloca %struct._b3MprSupport_t, align 16
  store ptr %s, ptr %s.addr, align 8
  store i64 %pos1, ptr %pos1.addr, align 8
  store i64 %pos2, ptr %pos2.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %ps = getelementptr inbounds %struct._b3MprSimplex_t, ptr %0, i32 0, i32 0
  %1 = load i64, ptr %pos1.addr, align 8
  %arrayidx = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %ps, i64 0, i64 %1
  call void @_Z16b3MprSupportCopyP15_b3MprSupport_tPKS_(ptr noundef %supp, ptr noundef %arrayidx)
  %2 = load ptr, ptr %s.addr, align 8
  %ps1 = getelementptr inbounds %struct._b3MprSimplex_t, ptr %2, i32 0, i32 0
  %3 = load i64, ptr %pos1.addr, align 8
  %arrayidx2 = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %ps1, i64 0, i64 %3
  %4 = load ptr, ptr %s.addr, align 8
  %ps3 = getelementptr inbounds %struct._b3MprSimplex_t, ptr %4, i32 0, i32 0
  %5 = load i64, ptr %pos2.addr, align 8
  %arrayidx4 = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %ps3, i64 0, i64 %5
  call void @_Z16b3MprSupportCopyP15_b3MprSupport_tPKS_(ptr noundef %arrayidx2, ptr noundef %arrayidx4)
  %6 = load ptr, ptr %s.addr, align 8
  %ps5 = getelementptr inbounds %struct._b3MprSimplex_t, ptr %6, i32 0, i32 0
  %7 = load i64, ptr %pos2.addr, align 8
  %arrayidx6 = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %ps5, i64 0, i64 %7
  call void @_Z16b3MprSupportCopyP15_b3MprSupport_tPKS_(ptr noundef %arrayidx6, ptr noundef %supp)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_Z16b3MprSimplexSizePK15_b3MprSimplex_t(ptr noundef %s) #3 comdat {
entry:
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %last = getelementptr inbounds %struct._b3MprSimplex_t, ptr %0, i32 0, i32 1
  %1 = load i32, ptr %last, align 16
  %add = add nsw i32 %1, 1
  ret i32 %add
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_Z15b3MprSimplexSetP15_b3MprSimplex_tmPK15_b3MprSupport_t(ptr noundef %s, i64 noundef %pos, ptr noundef %a) #3 comdat {
entry:
  %s.addr = alloca ptr, align 8
  %pos.addr = alloca i64, align 8
  %a.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %pos, ptr %pos.addr, align 8
  store ptr %a, ptr %a.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %ps = getelementptr inbounds %struct._b3MprSimplex_t, ptr %0, i32 0, i32 0
  %arraydecay = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %ps, i64 0, i64 0
  %1 = load i64, ptr %pos.addr, align 8
  %add.ptr = getelementptr inbounds %struct._b3MprSupport_t, ptr %arraydecay, i64 %1
  %2 = load ptr, ptr %a.addr, align 8
  call void @_Z16b3MprSupportCopyP15_b3MprSupport_tPKS_(ptr noundef %add.ptr, ptr noundef %2)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i32 @_Z7b3MprEqff(float noundef %_a, float noundef %_b) #0 comdat {
entry:
  %retval = alloca i32, align 4
  %_a.addr = alloca float, align 4
  %_b.addr = alloca float, align 4
  %ab = alloca float, align 4
  %a = alloca float, align 4
  %b = alloca float, align 4
  store float %_a, ptr %_a.addr, align 4
  store float %_b, ptr %_b.addr, align 4
  %0 = load float, ptr %_a.addr, align 4
  %1 = load float, ptr %_b.addr, align 4
  %sub = fsub float %0, %1
  %call = call noundef float @_ZSt4fabsf(float noundef %sub)
  store float %call, ptr %ab, align 4
  %2 = load float, ptr %ab, align 4
  %call1 = call noundef float @_ZSt4fabsf(float noundef %2)
  %cmp = fcmp olt float %call1, 0x3E80000000000000
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load float, ptr %_a.addr, align 4
  %call2 = call noundef float @_ZSt4fabsf(float noundef %3)
  store float %call2, ptr %a, align 4
  %4 = load float, ptr %_b.addr, align 4
  %call3 = call noundef float @_ZSt4fabsf(float noundef %4)
  store float %call3, ptr %b, align 4
  %5 = load float, ptr %b, align 4
  %6 = load float, ptr %a, align 4
  %cmp4 = fcmp ogt float %5, %6
  br i1 %cmp4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.end
  %7 = load float, ptr %ab, align 4
  %8 = load float, ptr %b, align 4
  %mul = fmul float 0x3E80000000000000, %8
  %cmp6 = fcmp olt float %7, %mul
  %conv = zext i1 %cmp6 to i32
  store i32 %conv, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %if.end
  %9 = load float, ptr %ab, align 4
  %10 = load float, ptr %a, align 4
  %mul7 = fmul float 0x3E80000000000000, %10
  %cmp8 = fcmp olt float %9, %mul7
  %conv9 = zext i1 %cmp8 to i32
  store i32 %conv9, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %if.then5, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef float @_ZSt4fabsf(float noundef %__x) #3 comdat {
entry:
  %__x.addr = alloca float, align 4
  store float %__x, ptr %__x.addr, align 4
  %0 = load float, ptr %__x.addr, align 4
  %1 = call float @llvm.fabs.f32(float %0)
  ret float %1
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL18b3MprConvexSupportiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_SA_SB_i(i32 noundef %pairIndex, i32 noundef %bodyIndex, ptr noundef %cpuBodyBuf, ptr noundef %cpuConvexData, ptr noundef %cpuCollidables, ptr noundef %cpuVertices, ptr noundef %sepAxis, ptr noundef %_dir, ptr noundef %outp, i32 noundef %logme) #2 {
entry:
  %pairIndex.addr = alloca i32, align 4
  %bodyIndex.addr = alloca i32, align 4
  %cpuBodyBuf.addr = alloca ptr, align 8
  %cpuConvexData.addr = alloca ptr, align 8
  %cpuCollidables.addr = alloca ptr, align 8
  %cpuVertices.addr = alloca ptr, align 8
  %sepAxis.addr = alloca ptr, align 8
  %_dir.addr = alloca ptr, align 8
  %outp.addr = alloca ptr, align 8
  %logme.addr = alloca i32, align 4
  %pos = alloca %class.b3Vector3, align 16
  %orn = alloca %class.b3Quaternion, align 16
  %dir = alloca %class.b3Vector3, align 16
  %localDir = alloca %class.b3Vector3, align 16
  %ref.tmp = alloca %class.b3Quaternion, align 16
  %colIndex = alloca i32, align 4
  %hull = alloca ptr, align 8
  %pInA = alloca %class.b3Vector3, align 16
  %maxDot = alloca float, align 4
  %scaled = alloca %class.b3Vector3, align 16
  %index = alloca i32, align 4
  %ref.tmp25 = alloca %class.b3Vector3, align 16
  %ref.tmp30 = alloca %class.b3Vector3, align 16
  store i32 %pairIndex, ptr %pairIndex.addr, align 4
  store i32 %bodyIndex, ptr %bodyIndex.addr, align 4
  store ptr %cpuBodyBuf, ptr %cpuBodyBuf.addr, align 8
  store ptr %cpuConvexData, ptr %cpuConvexData.addr, align 8
  store ptr %cpuCollidables, ptr %cpuCollidables.addr, align 8
  store ptr %cpuVertices, ptr %cpuVertices.addr, align 8
  store ptr %sepAxis, ptr %sepAxis.addr, align 8
  store ptr %_dir, ptr %_dir.addr, align 8
  store ptr %outp, ptr %outp.addr, align 8
  store i32 %logme, ptr %logme.addr, align 4
  %0 = load ptr, ptr %cpuBodyBuf.addr, align 8
  %1 = load i32, ptr %bodyIndex.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3RigidBodyData, ptr %0, i64 %idxprom
  %m_pos = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %pos, ptr align 16 %m_pos, i64 16, i1 false)
  %2 = load ptr, ptr %cpuBodyBuf.addr, align 8
  %3 = load i32, ptr %bodyIndex.addr, align 4
  %idxprom1 = sext i32 %3 to i64
  %arrayidx2 = getelementptr inbounds %struct.b3RigidBodyData, ptr %2, i64 %idxprom1
  %m_quat = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx2, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %orn, ptr align 16 %m_quat, i64 16, i1 false)
  %4 = load ptr, ptr %_dir.addr, align 8
  %5 = getelementptr inbounds %class.b3Vector3, ptr %4, i32 0, i32 0
  %x = getelementptr inbounds %struct.anon.2, ptr %5, i32 0, i32 0
  %6 = load float, ptr %x, align 16
  %7 = load ptr, ptr %_dir.addr, align 8
  %8 = getelementptr inbounds %class.b3Vector3, ptr %7, i32 0, i32 0
  %y = getelementptr inbounds %struct.anon.2, ptr %8, i32 0, i32 1
  %9 = load float, ptr %y, align 4
  %10 = load ptr, ptr %_dir.addr, align 8
  %11 = getelementptr inbounds %class.b3Vector3, ptr %10, i32 0, i32 0
  %z = getelementptr inbounds %struct.anon.2, ptr %11, i32 0, i32 2
  %12 = load float, ptr %z, align 8
  %call = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef %6, float noundef %9, float noundef %12, float noundef 0.000000e+00)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %dir, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %13 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive3, i32 0, i32 0
  %14 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %14, ptr %13, align 16
  %15 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive3, i32 0, i32 1
  %16 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %16, ptr %15, align 8
  %call4 = call { <2 x float>, <2 x float> } @_Z13b3QuatInverseRK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(16) %orn)
  %coerce.dive5 = getelementptr inbounds %class.b3Quaternion, ptr %ref.tmp, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %class.b3QuadWord, ptr %coerce.dive5, i32 0, i32 0
  %coerce.dive7 = getelementptr inbounds %union.anon.3, ptr %coerce.dive6, i32 0, i32 0
  %17 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive7, i32 0, i32 0
  %18 = extractvalue { <2 x float>, <2 x float> } %call4, 0
  store <2 x float> %18, ptr %17, align 16
  %19 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive7, i32 0, i32 1
  %20 = extractvalue { <2 x float>, <2 x float> } %call4, 1
  store <2 x float> %20, ptr %19, align 8
  %call8 = call { <2 x float>, <2 x float> } @_Z12b3QuatRotateRK12b3QuaternionRK9b3Vector3(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp, ptr noundef nonnull align 16 dereferenceable(16) %dir)
  %coerce.dive9 = getelementptr inbounds %class.b3Vector3, ptr %localDir, i32 0, i32 0
  %coerce.dive10 = getelementptr inbounds %union.anon.1, ptr %coerce.dive9, i32 0, i32 0
  %21 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive10, i32 0, i32 0
  %22 = extractvalue { <2 x float>, <2 x float> } %call8, 0
  store <2 x float> %22, ptr %21, align 16
  %23 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive10, i32 0, i32 1
  %24 = extractvalue { <2 x float>, <2 x float> } %call8, 1
  store <2 x float> %24, ptr %23, align 8
  %25 = load ptr, ptr %cpuBodyBuf.addr, align 8
  %26 = load i32, ptr %bodyIndex.addr, align 4
  %idxprom11 = sext i32 %26 to i64
  %arrayidx12 = getelementptr inbounds %struct.b3RigidBodyData, ptr %25, i64 %idxprom11
  %m_collidableIdx = getelementptr inbounds %struct.b3RigidBodyData, ptr %arrayidx12, i32 0, i32 4
  %27 = load i32, ptr %m_collidableIdx, align 16
  store i32 %27, ptr %colIndex, align 4
  %28 = load ptr, ptr %cpuConvexData.addr, align 8
  %29 = load ptr, ptr %cpuCollidables.addr, align 8
  %30 = load i32, ptr %colIndex, align 4
  %idxprom13 = sext i32 %30 to i64
  %arrayidx14 = getelementptr inbounds %struct.b3Collidable, ptr %29, i64 %idxprom13
  %31 = getelementptr inbounds %struct.b3Collidable, ptr %arrayidx14, i32 0, i32 3
  %32 = load i32, ptr %31, align 4
  %idxprom15 = sext i32 %32 to i64
  %arrayidx16 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %28, i64 %idxprom15
  store ptr %arrayidx16, ptr %hull, align 8
  %33 = load i32, ptr %logme.addr, align 4
  %tobool = icmp ne i32 %33, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store float 0xC3ABC16D60000000, ptr %maxDot, align 4
  %34 = load ptr, ptr %hull, align 8
  %m_numVertices = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %34, i32 0, i32 7
  %35 = load i32, ptr %m_numVertices, align 4
  %cmp = icmp slt i32 0, %35
  br i1 %cmp, label %if.then17, label %if.end

if.then17:                                        ; preds = %if.then
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %scaled, ptr align 16 %localDir, i64 16, i1 false)
  %36 = load ptr, ptr %cpuVertices.addr, align 8
  %37 = load ptr, ptr %hull, align 8
  %m_vertexOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %37, i32 0, i32 8
  %38 = load i32, ptr %m_vertexOffset, align 16
  %idxprom18 = sext i32 %38 to i64
  %arrayidx19 = getelementptr inbounds %class.b3Vector3, ptr %36, i64 %idxprom18
  %39 = load ptr, ptr %hull, align 8
  %m_numVertices20 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %39, i32 0, i32 7
  %40 = load i32, ptr %m_numVertices20, align 4
  %call21 = call noundef i32 @_Z8b3MaxDotRK9b3Vector3PS0_iPf(ptr noundef nonnull align 16 dereferenceable(16) %scaled, ptr noundef %arrayidx19, i32 noundef %40, ptr noundef %maxDot)
  store i32 %call21, ptr %index, align 4
  %41 = load ptr, ptr %cpuVertices.addr, align 8
  %42 = load ptr, ptr %hull, align 8
  %m_vertexOffset22 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %42, i32 0, i32 8
  %43 = load i32, ptr %m_vertexOffset22, align 16
  %44 = load i32, ptr %index, align 4
  %add = add nsw i32 %43, %44
  %idxprom23 = sext i32 %add to i64
  %arrayidx24 = getelementptr inbounds %class.b3Vector3, ptr %41, i64 %idxprom23
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %pInA, ptr align 16 %arrayidx24, i64 16, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then17, %if.then
  br label %if.end29

if.else:                                          ; preds = %entry
  %45 = load ptr, ptr %hull, align 8
  %46 = load ptr, ptr %cpuVertices.addr, align 8
  %call26 = call { <2 x float>, <2 x float> } @_Z23b3LocalGetSupportVertexRK9b3Vector3PK22b3ConvexPolyhedronDataPS0_(ptr noundef nonnull align 16 dereferenceable(16) %localDir, ptr noundef %45, ptr noundef %46)
  %coerce.dive27 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp25, i32 0, i32 0
  %coerce.dive28 = getelementptr inbounds %union.anon.1, ptr %coerce.dive27, i32 0, i32 0
  %47 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive28, i32 0, i32 0
  %48 = extractvalue { <2 x float>, <2 x float> } %call26, 0
  store <2 x float> %48, ptr %47, align 16
  %49 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive28, i32 0, i32 1
  %50 = extractvalue { <2 x float>, <2 x float> } %call26, 1
  store <2 x float> %50, ptr %49, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %pInA, ptr align 16 %ref.tmp25, i64 16, i1 false)
  br label %if.end29

if.end29:                                         ; preds = %if.else, %if.end
  %call31 = call { <2 x float>, <2 x float> } @_Z16b3TransformPointRK9b3Vector3S1_RK12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(16) %pInA, ptr noundef nonnull align 16 dereferenceable(16) %pos, ptr noundef nonnull align 16 dereferenceable(16) %orn)
  %coerce.dive32 = getelementptr inbounds %class.b3Vector3, ptr %ref.tmp30, i32 0, i32 0
  %coerce.dive33 = getelementptr inbounds %union.anon.1, ptr %coerce.dive32, i32 0, i32 0
  %51 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive33, i32 0, i32 0
  %52 = extractvalue { <2 x float>, <2 x float> } %call31, 0
  store <2 x float> %52, ptr %51, align 16
  %53 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive33, i32 0, i32 1
  %54 = extractvalue { <2 x float>, <2 x float> } %call31, 1
  store <2 x float> %54, ptr %53, align 8
  %55 = load ptr, ptr %outp.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %55, ptr align 16 %ref.tmp30, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i32 @_Z8b3MaxDotRK9b3Vector3PS0_iPf(ptr noundef nonnull align 16 dereferenceable(16) %vec, ptr noundef %vecArray, i32 noundef %vecLen, ptr noundef %dotOut) #0 comdat {
entry:
  %vec.addr = alloca ptr, align 8
  %vecArray.addr = alloca ptr, align 8
  %vecLen.addr = alloca i32, align 4
  %dotOut.addr = alloca ptr, align 8
  %maxDot = alloca float, align 4
  %i = alloca i32, align 4
  %ptIndex = alloca i32, align 4
  %dot = alloca float, align 4
  store ptr %vec, ptr %vec.addr, align 8
  store ptr %vecArray, ptr %vecArray.addr, align 8
  store i32 %vecLen, ptr %vecLen.addr, align 4
  store ptr %dotOut, ptr %dotOut.addr, align 8
  store float 0xC7EFFFFFE0000000, ptr %maxDot, align 4
  store i32 0, ptr %i, align 4
  store i32 -1, ptr %ptIndex, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %1 = load i32, ptr %vecLen.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %vecArray.addr, align 8
  %3 = load i32, ptr %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds %class.b3Vector3, ptr %2, i64 %idxprom
  %4 = load ptr, ptr %vec.addr, align 8
  %call = call noundef float @_Z5b3DotRK9b3Vector3S1_(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx, ptr noundef nonnull align 16 dereferenceable(16) %4)
  store float %call, ptr %dot, align 4
  %5 = load float, ptr %dot, align 4
  %6 = load float, ptr %maxDot, align 4
  %cmp1 = fcmp ogt float %5, %6
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %7 = load float, ptr %dot, align 4
  store float %7, ptr %maxDot, align 4
  %8 = load i32, ptr %i, align 4
  store i32 %8, ptr %ptIndex, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, ptr %i, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !82

for.end:                                          ; preds = %for.cond
  %10 = load i32, ptr %ptIndex, align 4
  %cmp2 = icmp slt i32 %10, 0
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %for.end
  store i32 0, ptr %ptIndex, align 4
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %for.end
  %11 = load float, ptr %maxDot, align 4
  %12 = load ptr, ptr %dotOut.addr, align 8
  store float %11, ptr %12, align 4
  %13 = load i32, ptr %ptIndex, align 4
  ret i32 %13
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { <2 x float>, <2 x float> } @_Z23b3LocalGetSupportVertexRK9b3Vector3PK22b3ConvexPolyhedronDataPS0_(ptr noundef nonnull align 16 dereferenceable(16) %supportVec, ptr noundef %hull, ptr noundef %verticesA) #2 comdat {
entry:
  %retval = alloca %class.b3Vector3, align 16
  %supportVec.addr = alloca ptr, align 8
  %hull.addr = alloca ptr, align 8
  %verticesA.addr = alloca ptr, align 8
  %supVec = alloca %class.b3Vector3, align 16
  %maxDot = alloca float, align 4
  %scaled = alloca %class.b3Vector3, align 16
  %index = alloca i32, align 4
  store ptr %supportVec, ptr %supportVec.addr, align 8
  store ptr %hull, ptr %hull.addr, align 8
  store ptr %verticesA, ptr %verticesA.addr, align 8
  %call = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %supVec, i32 0, i32 0
  %coerce.dive1 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive1, i32 0, i32 0
  %1 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %1, ptr %0, align 16
  %2 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive1, i32 0, i32 1
  %3 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %3, ptr %2, align 8
  store float 0xC3ABC16D60000000, ptr %maxDot, align 4
  %4 = load ptr, ptr %hull.addr, align 8
  %m_numVertices = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %4, i32 0, i32 7
  %5 = load i32, ptr %m_numVertices, align 4
  %cmp = icmp slt i32 0, %5
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load ptr, ptr %supportVec.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %scaled, ptr align 16 %6, i64 16, i1 false)
  %7 = load ptr, ptr %verticesA.addr, align 8
  %8 = load ptr, ptr %hull.addr, align 8
  %m_vertexOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %8, i32 0, i32 8
  %9 = load i32, ptr %m_vertexOffset, align 16
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr inbounds %class.b3Vector3, ptr %7, i64 %idxprom
  %10 = load ptr, ptr %hull.addr, align 8
  %m_numVertices2 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %10, i32 0, i32 7
  %11 = load i32, ptr %m_numVertices2, align 4
  %call3 = call noundef i32 @_Z8b3MaxDotRK9b3Vector3PS0_iPf(ptr noundef nonnull align 16 dereferenceable(16) %scaled, ptr noundef %arrayidx, i32 noundef %11, ptr noundef %maxDot)
  store i32 %call3, ptr %index, align 4
  %12 = load ptr, ptr %verticesA.addr, align 8
  %13 = load ptr, ptr %hull.addr, align 8
  %m_vertexOffset4 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %13, i32 0, i32 8
  %14 = load i32, ptr %m_vertexOffset4, align 16
  %15 = load i32, ptr %index, align 4
  %add = add nsw i32 %14, %15
  %idxprom5 = sext i32 %add to i64
  %arrayidx6 = getelementptr inbounds %class.b3Vector3, ptr %12, i64 %idxprom5
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %retval, ptr align 16 %arrayidx6, i64 16, i1 false)
  br label %return

if.end:                                           ; preds = %entry
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %retval, ptr align 16 %supVec, i64 16, i1 false)
  br label %return

return:                                           ; preds = %if.end, %if.then
  %coerce.dive7 = getelementptr inbounds %class.b3Vector3, ptr %retval, i32 0, i32 0
  %coerce.dive8 = getelementptr inbounds %union.anon.1, ptr %coerce.dive7, i32 0, i32 0
  %16 = load { <2 x float>, <2 x float> }, ptr %coerce.dive8, align 16
  ret { <2 x float>, <2 x float> } %16
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_Z16b3MprSupportCopyP15_b3MprSupport_tPKS_(ptr noundef %d, ptr noundef %s) #3 comdat {
entry:
  %d.addr = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load ptr, ptr %d.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %1, ptr align 16 %0, i64 48, i1 false)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z11b3PortalDirPK15_b3MprSimplex_tP9b3Vector3(ptr noundef %portal, ptr noundef %dir) #0 comdat {
entry:
  %portal.addr = alloca ptr, align 8
  %dir.addr = alloca ptr, align 8
  %v2v1 = alloca %class.b3Vector3, align 16
  %v3v1 = alloca %class.b3Vector3, align 16
  store ptr %portal, ptr %portal.addr, align 8
  store ptr %dir, ptr %dir.addr, align 8
  %0 = load ptr, ptr %portal.addr, align 8
  %call = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %0, i32 noundef 2)
  %v = getelementptr inbounds %struct._b3MprSupport_t, ptr %call, i32 0, i32 0
  %1 = load ptr, ptr %portal.addr, align 8
  %call1 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %1, i32 noundef 1)
  %v2 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call1, i32 0, i32 0
  call void @_Z13b3MprVec3Sub2P9b3Vector3PKS_S2_(ptr noundef %v2v1, ptr noundef %v, ptr noundef %v2)
  %2 = load ptr, ptr %portal.addr, align 8
  %call3 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %2, i32 noundef 3)
  %v4 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call3, i32 0, i32 0
  %3 = load ptr, ptr %portal.addr, align 8
  %call5 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %3, i32 noundef 1)
  %v6 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call5, i32 0, i32 0
  call void @_Z13b3MprVec3Sub2P9b3Vector3PKS_S2_(ptr noundef %v3v1, ptr noundef %v4, ptr noundef %v6)
  %4 = load ptr, ptr %dir.addr, align 8
  call void @_Z14b3MprVec3CrossP9b3Vector3PKS_S2_(ptr noundef %4, ptr noundef %v2v1, ptr noundef %v3v1)
  %5 = load ptr, ptr %dir.addr, align 8
  call void @_Z18b3MprVec3NormalizeP9b3Vector3(ptr noundef %5)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i32 @_Z22portalEncapsulesOriginPK15_b3MprSimplex_tPK9b3Vector3(ptr noundef %portal, ptr noundef %dir) #0 comdat {
entry:
  %portal.addr = alloca ptr, align 8
  %dir.addr = alloca ptr, align 8
  %dot = alloca float, align 4
  store ptr %portal, ptr %portal.addr, align 8
  store ptr %dir, ptr %dir.addr, align 8
  %0 = load ptr, ptr %dir.addr, align 8
  %1 = load ptr, ptr %portal.addr, align 8
  %call = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %1, i32 noundef 1)
  %v = getelementptr inbounds %struct._b3MprSupport_t, ptr %call, i32 0, i32 0
  %call1 = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %0, ptr noundef %v)
  store float %call1, ptr %dot, align 4
  %2 = load float, ptr %dot, align 4
  %call2 = call noundef i32 @_Z11b3MprIsZerof(float noundef %2)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %3 = load float, ptr %dot, align 4
  %cmp = fcmp ogt float %3, 0.000000e+00
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %4 = phi i1 [ true, %entry ], [ %cmp, %lor.rhs ]
  %conv = zext i1 %4 to i32
  ret i32 %conv
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i32 @_Z24portalCanEncapsuleOriginPK15_b3MprSimplex_tPK15_b3MprSupport_tPK9b3Vector3(ptr noundef %portal, ptr noundef %v4, ptr noundef %dir) #0 comdat {
entry:
  %portal.addr = alloca ptr, align 8
  %v4.addr = alloca ptr, align 8
  %dir.addr = alloca ptr, align 8
  %dot = alloca float, align 4
  store ptr %portal, ptr %portal.addr, align 8
  store ptr %v4, ptr %v4.addr, align 8
  store ptr %dir, ptr %dir.addr, align 8
  %0 = load ptr, ptr %v4.addr, align 8
  %v = getelementptr inbounds %struct._b3MprSupport_t, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %dir.addr, align 8
  %call = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %v, ptr noundef %1)
  store float %call, ptr %dot, align 4
  %2 = load float, ptr %dot, align 4
  %call1 = call noundef i32 @_Z11b3MprIsZerof(float noundef %2)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %3 = load float, ptr %dot, align 4
  %cmp = fcmp ogt float %3, 0.000000e+00
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %4 = phi i1 [ true, %entry ], [ %cmp, %lor.rhs ]
  %conv = zext i1 %4 to i32
  ret i32 %conv
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i32 @_Z20portalReachTolerancePK15_b3MprSimplex_tPK15_b3MprSupport_tPK9b3Vector3(ptr noundef %portal, ptr noundef %v4, ptr noundef %dir) #0 comdat {
entry:
  %portal.addr = alloca ptr, align 8
  %v4.addr = alloca ptr, align 8
  %dir.addr = alloca ptr, align 8
  %dv1 = alloca float, align 4
  %dv2 = alloca float, align 4
  %dv3 = alloca float, align 4
  %dv4 = alloca float, align 4
  %dot1 = alloca float, align 4
  %dot2 = alloca float, align 4
  %dot3 = alloca float, align 4
  store ptr %portal, ptr %portal.addr, align 8
  store ptr %v4, ptr %v4.addr, align 8
  store ptr %dir, ptr %dir.addr, align 8
  %0 = load ptr, ptr %portal.addr, align 8
  %call = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %0, i32 noundef 1)
  %v = getelementptr inbounds %struct._b3MprSupport_t, ptr %call, i32 0, i32 0
  %1 = load ptr, ptr %dir.addr, align 8
  %call1 = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %v, ptr noundef %1)
  store float %call1, ptr %dv1, align 4
  %2 = load ptr, ptr %portal.addr, align 8
  %call2 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %2, i32 noundef 2)
  %v3 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call2, i32 0, i32 0
  %3 = load ptr, ptr %dir.addr, align 8
  %call4 = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %v3, ptr noundef %3)
  store float %call4, ptr %dv2, align 4
  %4 = load ptr, ptr %portal.addr, align 8
  %call5 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %4, i32 noundef 3)
  %v6 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call5, i32 0, i32 0
  %5 = load ptr, ptr %dir.addr, align 8
  %call7 = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %v6, ptr noundef %5)
  store float %call7, ptr %dv3, align 4
  %6 = load ptr, ptr %v4.addr, align 8
  %v8 = getelementptr inbounds %struct._b3MprSupport_t, ptr %6, i32 0, i32 0
  %7 = load ptr, ptr %dir.addr, align 8
  %call9 = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %v8, ptr noundef %7)
  store float %call9, ptr %dv4, align 4
  %8 = load float, ptr %dv4, align 4
  %9 = load float, ptr %dv1, align 4
  %sub = fsub float %8, %9
  store float %sub, ptr %dot1, align 4
  %10 = load float, ptr %dv4, align 4
  %11 = load float, ptr %dv2, align 4
  %sub10 = fsub float %10, %11
  store float %sub10, ptr %dot2, align 4
  %12 = load float, ptr %dv4, align 4
  %13 = load float, ptr %dv3, align 4
  %sub11 = fsub float %12, %13
  store float %sub11, ptr %dot3, align 4
  %14 = load float, ptr %dot1, align 4
  %15 = load float, ptr %dot2, align 4
  %cmp = fcmp olt float %14, %15
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %16 = load float, ptr %dot1, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %17 = load float, ptr %dot2, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %16, %cond.true ], [ %17, %cond.false ]
  store float %cond, ptr %dot1, align 4
  %18 = load float, ptr %dot1, align 4
  %19 = load float, ptr %dot3, align 4
  %cmp12 = fcmp olt float %18, %19
  br i1 %cmp12, label %cond.true13, label %cond.false14

cond.true13:                                      ; preds = %cond.end
  %20 = load float, ptr %dot1, align 4
  br label %cond.end15

cond.false14:                                     ; preds = %cond.end
  %21 = load float, ptr %dot3, align 4
  br label %cond.end15

cond.end15:                                       ; preds = %cond.false14, %cond.true13
  %cond16 = phi float [ %20, %cond.true13 ], [ %21, %cond.false14 ]
  store float %cond16, ptr %dot1, align 4
  %22 = load float, ptr %dot1, align 4
  %call17 = call noundef i32 @_Z7b3MprEqff(float noundef %22, float noundef 0x3EB0C6F7A0000000)
  %tobool = icmp ne i32 %call17, 0
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %cond.end15
  %23 = load float, ptr %dot1, align 4
  %cmp18 = fcmp olt float %23, 0x3EB0C6F7A0000000
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %cond.end15
  %24 = phi i1 [ true, %cond.end15 ], [ %cmp18, %lor.rhs ]
  %conv = zext i1 %24 to i32
  ret i32 %conv
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14b3ExpandPortalP15_b3MprSimplex_tPK15_b3MprSupport_t(ptr noundef %portal, ptr noundef %v4) #0 comdat {
entry:
  %portal.addr = alloca ptr, align 8
  %v4.addr = alloca ptr, align 8
  %dot = alloca float, align 4
  %v4v0 = alloca %class.b3Vector3, align 16
  store ptr %portal, ptr %portal.addr, align 8
  store ptr %v4, ptr %v4.addr, align 8
  %0 = load ptr, ptr %v4.addr, align 8
  %v = getelementptr inbounds %struct._b3MprSupport_t, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %portal.addr, align 8
  %call = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %1, i32 noundef 0)
  %v1 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call, i32 0, i32 0
  call void @_Z14b3MprVec3CrossP9b3Vector3PKS_S2_(ptr noundef %v4v0, ptr noundef %v, ptr noundef %v1)
  %2 = load ptr, ptr %portal.addr, align 8
  %call2 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %2, i32 noundef 1)
  %v3 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call2, i32 0, i32 0
  %call4 = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %v3, ptr noundef %v4v0)
  store float %call4, ptr %dot, align 4
  %3 = load float, ptr %dot, align 4
  %cmp = fcmp ogt float %3, 0.000000e+00
  br i1 %cmp, label %if.then, label %if.else10

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %portal.addr, align 8
  %call5 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %4, i32 noundef 2)
  %v6 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call5, i32 0, i32 0
  %call7 = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %v6, ptr noundef %v4v0)
  store float %call7, ptr %dot, align 4
  %5 = load float, ptr %dot, align 4
  %cmp8 = fcmp ogt float %5, 0.000000e+00
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.then
  %6 = load ptr, ptr %portal.addr, align 8
  %7 = load ptr, ptr %v4.addr, align 8
  call void @_Z15b3MprSimplexSetP15_b3MprSimplex_tmPK15_b3MprSupport_t(ptr noundef %6, i64 noundef 1, ptr noundef %7)
  br label %if.end

if.else:                                          ; preds = %if.then
  %8 = load ptr, ptr %portal.addr, align 8
  %9 = load ptr, ptr %v4.addr, align 8
  call void @_Z15b3MprSimplexSetP15_b3MprSimplex_tmPK15_b3MprSupport_t(ptr noundef %8, i64 noundef 3, ptr noundef %9)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then9
  br label %if.end18

if.else10:                                        ; preds = %entry
  %10 = load ptr, ptr %portal.addr, align 8
  %call11 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %10, i32 noundef 3)
  %v12 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call11, i32 0, i32 0
  %call13 = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %v12, ptr noundef %v4v0)
  store float %call13, ptr %dot, align 4
  %11 = load float, ptr %dot, align 4
  %cmp14 = fcmp ogt float %11, 0.000000e+00
  br i1 %cmp14, label %if.then15, label %if.else16

if.then15:                                        ; preds = %if.else10
  %12 = load ptr, ptr %portal.addr, align 8
  %13 = load ptr, ptr %v4.addr, align 8
  call void @_Z15b3MprSimplexSetP15_b3MprSimplex_tmPK15_b3MprSupport_t(ptr noundef %12, i64 noundef 2, ptr noundef %13)
  br label %if.end17

if.else16:                                        ; preds = %if.else10
  %14 = load ptr, ptr %portal.addr, align 8
  %15 = load ptr, ptr %v4.addr, align 8
  call void @_Z15b3MprSimplexSetP15_b3MprSimplex_tmPK15_b3MprSupport_t(ptr noundef %14, i64 noundef 1, ptr noundef %15)
  br label %if.end17

if.end17:                                         ; preds = %if.else16, %if.then15
  br label %if.end18

if.end18:                                         ; preds = %if.end17, %if.end
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef float @_Z22b3MprVec3PointTriDist2PK9b3Vector3S1_S1_S1_PS_(ptr noundef %P, ptr noundef %x0, ptr noundef %B, ptr noundef %C, ptr noundef %witness) #0 comdat {
entry:
  %P.addr = alloca ptr, align 8
  %x0.addr = alloca ptr, align 8
  %B.addr = alloca ptr, align 8
  %C.addr = alloca ptr, align 8
  %witness.addr = alloca ptr, align 8
  %d1 = alloca %class.b3Vector3, align 16
  %d2 = alloca %class.b3Vector3, align 16
  %a = alloca %class.b3Vector3, align 16
  %u = alloca float, align 4
  %v = alloca float, align 4
  %w = alloca float, align 4
  %p = alloca float, align 4
  %q = alloca float, align 4
  %r = alloca float, align 4
  %s = alloca float, align 4
  %t = alloca float, align 4
  %dist = alloca float, align 4
  %dist2 = alloca float, align 4
  %witness2 = alloca %class.b3Vector3, align 16
  store ptr %P, ptr %P.addr, align 8
  store ptr %x0, ptr %x0.addr, align 8
  store ptr %B, ptr %B.addr, align 8
  store ptr %C, ptr %C.addr, align 8
  store ptr %witness, ptr %witness.addr, align 8
  %0 = load ptr, ptr %B.addr, align 8
  %1 = load ptr, ptr %x0.addr, align 8
  call void @_Z13b3MprVec3Sub2P9b3Vector3PKS_S2_(ptr noundef %d1, ptr noundef %0, ptr noundef %1)
  %2 = load ptr, ptr %C.addr, align 8
  %3 = load ptr, ptr %x0.addr, align 8
  call void @_Z13b3MprVec3Sub2P9b3Vector3PKS_S2_(ptr noundef %d2, ptr noundef %2, ptr noundef %3)
  %4 = load ptr, ptr %x0.addr, align 8
  %5 = load ptr, ptr %P.addr, align 8
  call void @_Z13b3MprVec3Sub2P9b3Vector3PKS_S2_(ptr noundef %a, ptr noundef %4, ptr noundef %5)
  %call = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %a, ptr noundef %a)
  store float %call, ptr %u, align 4
  %call1 = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %d1, ptr noundef %d1)
  store float %call1, ptr %v, align 4
  %call2 = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %d2, ptr noundef %d2)
  store float %call2, ptr %w, align 4
  %call3 = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %a, ptr noundef %d1)
  store float %call3, ptr %p, align 4
  %call4 = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %a, ptr noundef %d2)
  store float %call4, ptr %q, align 4
  %call5 = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %d1, ptr noundef %d2)
  store float %call5, ptr %r, align 4
  %6 = load float, ptr %q, align 4
  %7 = load float, ptr %r, align 4
  %8 = load float, ptr %w, align 4
  %9 = load float, ptr %p, align 4
  %mul6 = fmul float %8, %9
  %neg = fneg float %mul6
  %10 = call float @llvm.fmuladd.f32(float %6, float %7, float %neg)
  %11 = load float, ptr %w, align 4
  %12 = load float, ptr %v, align 4
  %13 = load float, ptr %r, align 4
  %14 = load float, ptr %r, align 4
  %mul7 = fmul float %13, %14
  %neg8 = fneg float %mul7
  %15 = call float @llvm.fmuladd.f32(float %11, float %12, float %neg8)
  %div = fdiv float %10, %15
  store float %div, ptr %s, align 4
  %16 = load float, ptr %s, align 4
  %fneg = fneg float %16
  %17 = load float, ptr %r, align 4
  %18 = load float, ptr %q, align 4
  %neg9 = fneg float %18
  %19 = call float @llvm.fmuladd.f32(float %fneg, float %17, float %neg9)
  %20 = load float, ptr %w, align 4
  %div10 = fdiv float %19, %20
  store float %div10, ptr %t, align 4
  %21 = load float, ptr %s, align 4
  %call11 = call noundef i32 @_Z11b3MprIsZerof(float noundef %21)
  %tobool = icmp ne i32 %call11, 0
  br i1 %tobool, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %22 = load float, ptr %s, align 4
  %cmp = fcmp ogt float %22, 0.000000e+00
  br i1 %cmp, label %land.lhs.true, label %if.else46

land.lhs.true:                                    ; preds = %lor.lhs.false, %entry
  %23 = load float, ptr %s, align 4
  %call12 = call noundef i32 @_Z7b3MprEqff(float noundef %23, float noundef 1.000000e+00)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %land.lhs.true16, label %lor.lhs.false14

lor.lhs.false14:                                  ; preds = %land.lhs.true
  %24 = load float, ptr %s, align 4
  %cmp15 = fcmp olt float %24, 1.000000e+00
  br i1 %cmp15, label %land.lhs.true16, label %if.else46

land.lhs.true16:                                  ; preds = %lor.lhs.false14, %land.lhs.true
  %25 = load float, ptr %t, align 4
  %call17 = call noundef i32 @_Z11b3MprIsZerof(float noundef %25)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %land.lhs.true21, label %lor.lhs.false19

lor.lhs.false19:                                  ; preds = %land.lhs.true16
  %26 = load float, ptr %t, align 4
  %cmp20 = fcmp ogt float %26, 0.000000e+00
  br i1 %cmp20, label %land.lhs.true21, label %if.else46

land.lhs.true21:                                  ; preds = %lor.lhs.false19, %land.lhs.true16
  %27 = load float, ptr %t, align 4
  %call22 = call noundef i32 @_Z7b3MprEqff(float noundef %27, float noundef 1.000000e+00)
  %tobool23 = icmp ne i32 %call22, 0
  br i1 %tobool23, label %land.lhs.true26, label %lor.lhs.false24

lor.lhs.false24:                                  ; preds = %land.lhs.true21
  %28 = load float, ptr %t, align 4
  %cmp25 = fcmp olt float %28, 1.000000e+00
  br i1 %cmp25, label %land.lhs.true26, label %if.else46

land.lhs.true26:                                  ; preds = %lor.lhs.false24, %land.lhs.true21
  %29 = load float, ptr %t, align 4
  %30 = load float, ptr %s, align 4
  %add = fadd float %29, %30
  %call27 = call noundef i32 @_Z7b3MprEqff(float noundef %add, float noundef 1.000000e+00)
  %tobool28 = icmp ne i32 %call27, 0
  br i1 %tobool28, label %if.then, label %lor.lhs.false29

lor.lhs.false29:                                  ; preds = %land.lhs.true26
  %31 = load float, ptr %t, align 4
  %32 = load float, ptr %s, align 4
  %add30 = fadd float %31, %32
  %cmp31 = fcmp olt float %add30, 1.000000e+00
  br i1 %cmp31, label %if.then, label %if.else46

if.then:                                          ; preds = %lor.lhs.false29, %land.lhs.true26
  %33 = load ptr, ptr %witness.addr, align 8
  %tobool32 = icmp ne ptr %33, null
  br i1 %tobool32, label %if.then33, label %if.else

if.then33:                                        ; preds = %if.then
  %34 = load float, ptr %s, align 4
  call void @_Z14b3MprVec3ScaleP9b3Vector3f(ptr noundef %d1, float noundef %34)
  %35 = load float, ptr %t, align 4
  call void @_Z14b3MprVec3ScaleP9b3Vector3f(ptr noundef %d2, float noundef %35)
  %36 = load ptr, ptr %witness.addr, align 8
  %37 = load ptr, ptr %x0.addr, align 8
  call void @_Z13b3MprVec3CopyP9b3Vector3PKS_(ptr noundef %36, ptr noundef %37)
  %38 = load ptr, ptr %witness.addr, align 8
  call void @_Z12b3MprVec3AddP9b3Vector3PKS_(ptr noundef %38, ptr noundef %d1)
  %39 = load ptr, ptr %witness.addr, align 8
  call void @_Z12b3MprVec3AddP9b3Vector3PKS_(ptr noundef %39, ptr noundef %d2)
  %40 = load ptr, ptr %witness.addr, align 8
  %41 = load ptr, ptr %P.addr, align 8
  %call34 = call noundef float @_Z14b3MprVec3Dist2PK9b3Vector3S1_(ptr noundef %40, ptr noundef %41)
  store float %call34, ptr %dist, align 4
  br label %if.end

if.else:                                          ; preds = %if.then
  %42 = load float, ptr %s, align 4
  %43 = load float, ptr %s, align 4
  %mul = fmul float %42, %43
  %44 = load float, ptr %v, align 4
  %mul35 = fmul float %mul, %44
  store float %mul35, ptr %dist, align 4
  %45 = load float, ptr %t, align 4
  %46 = load float, ptr %t, align 4
  %mul36 = fmul float %45, %46
  %47 = load float, ptr %w, align 4
  %48 = load float, ptr %dist, align 4
  %49 = call float @llvm.fmuladd.f32(float %mul36, float %47, float %48)
  store float %49, ptr %dist, align 4
  %50 = load float, ptr %s, align 4
  %mul38 = fmul float 2.000000e+00, %50
  %51 = load float, ptr %t, align 4
  %mul39 = fmul float %mul38, %51
  %52 = load float, ptr %r, align 4
  %53 = load float, ptr %dist, align 4
  %54 = call float @llvm.fmuladd.f32(float %mul39, float %52, float %53)
  store float %54, ptr %dist, align 4
  %55 = load float, ptr %s, align 4
  %mul41 = fmul float 2.000000e+00, %55
  %56 = load float, ptr %p, align 4
  %57 = load float, ptr %dist, align 4
  %58 = call float @llvm.fmuladd.f32(float %mul41, float %56, float %57)
  store float %58, ptr %dist, align 4
  %59 = load float, ptr %t, align 4
  %mul43 = fmul float 2.000000e+00, %59
  %60 = load float, ptr %q, align 4
  %61 = load float, ptr %dist, align 4
  %62 = call float @llvm.fmuladd.f32(float %mul43, float %60, float %61)
  store float %62, ptr %dist, align 4
  %63 = load float, ptr %u, align 4
  %64 = load float, ptr %dist, align 4
  %add45 = fadd float %64, %63
  store float %add45, ptr %dist, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then33
  br label %if.end62

if.else46:                                        ; preds = %lor.lhs.false29, %lor.lhs.false24, %lor.lhs.false19, %lor.lhs.false14, %lor.lhs.false
  %65 = load ptr, ptr %P.addr, align 8
  %66 = load ptr, ptr %x0.addr, align 8
  %67 = load ptr, ptr %B.addr, align 8
  %68 = load ptr, ptr %witness.addr, align 8
  %call47 = call noundef float @_Z27_b3MprVec3PointSegmentDist2PK9b3Vector3S1_S1_PS_(ptr noundef %65, ptr noundef %66, ptr noundef %67, ptr noundef %68)
  store float %call47, ptr %dist, align 4
  %69 = load ptr, ptr %P.addr, align 8
  %70 = load ptr, ptr %x0.addr, align 8
  %71 = load ptr, ptr %C.addr, align 8
  %call48 = call noundef float @_Z27_b3MprVec3PointSegmentDist2PK9b3Vector3S1_S1_PS_(ptr noundef %69, ptr noundef %70, ptr noundef %71, ptr noundef %witness2)
  store float %call48, ptr %dist2, align 4
  %72 = load float, ptr %dist2, align 4
  %73 = load float, ptr %dist, align 4
  %cmp49 = fcmp olt float %72, %73
  br i1 %cmp49, label %if.then50, label %if.end54

if.then50:                                        ; preds = %if.else46
  %74 = load float, ptr %dist2, align 4
  store float %74, ptr %dist, align 4
  %75 = load ptr, ptr %witness.addr, align 8
  %tobool51 = icmp ne ptr %75, null
  br i1 %tobool51, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.then50
  %76 = load ptr, ptr %witness.addr, align 8
  call void @_Z13b3MprVec3CopyP9b3Vector3PKS_(ptr noundef %76, ptr noundef %witness2)
  br label %if.end53

if.end53:                                         ; preds = %if.then52, %if.then50
  br label %if.end54

if.end54:                                         ; preds = %if.end53, %if.else46
  %77 = load ptr, ptr %P.addr, align 8
  %78 = load ptr, ptr %B.addr, align 8
  %79 = load ptr, ptr %C.addr, align 8
  %call55 = call noundef float @_Z27_b3MprVec3PointSegmentDist2PK9b3Vector3S1_S1_PS_(ptr noundef %77, ptr noundef %78, ptr noundef %79, ptr noundef %witness2)
  store float %call55, ptr %dist2, align 4
  %80 = load float, ptr %dist2, align 4
  %81 = load float, ptr %dist, align 4
  %cmp56 = fcmp olt float %80, %81
  br i1 %cmp56, label %if.then57, label %if.end61

if.then57:                                        ; preds = %if.end54
  %82 = load float, ptr %dist2, align 4
  store float %82, ptr %dist, align 4
  %83 = load ptr, ptr %witness.addr, align 8
  %tobool58 = icmp ne ptr %83, null
  br i1 %tobool58, label %if.then59, label %if.end60

if.then59:                                        ; preds = %if.then57
  %84 = load ptr, ptr %witness.addr, align 8
  call void @_Z13b3MprVec3CopyP9b3Vector3PKS_(ptr noundef %84, ptr noundef %witness2)
  br label %if.end60

if.end60:                                         ; preds = %if.then59, %if.then57
  br label %if.end61

if.end61:                                         ; preds = %if.end60, %if.end54
  br label %if.end62

if.end62:                                         ; preds = %if.end61, %if.end
  %85 = load float, ptr %dist, align 4
  ret float %85
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL9b3FindPosPK15_b3MprSimplex_tP9b3Vector3(ptr noundef %portal, ptr noundef %pos) #2 {
entry:
  %portal.addr = alloca ptr, align 8
  %pos.addr = alloca ptr, align 8
  %zero = alloca %class.b3Vector3, align 16
  %b3mpr_vec3_origin = alloca ptr, align 8
  %dir = alloca %class.b3Vector3, align 16
  %i = alloca i64, align 8
  %b = alloca [4 x float], align 16
  %sum = alloca float, align 4
  %inv = alloca float, align 4
  %vec = alloca %class.b3Vector3, align 16
  %p1 = alloca %class.b3Vector3, align 16
  %p2 = alloca %class.b3Vector3, align 16
  store ptr %portal, ptr %portal.addr, align 8
  store ptr %pos, ptr %pos.addr, align 8
  %call = call { <2 x float>, <2 x float> } @_Z13b3MakeVector3ffff(float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %coerce.dive = getelementptr inbounds %class.b3Vector3, ptr %zero, i32 0, i32 0
  %coerce.dive1 = getelementptr inbounds %union.anon.1, ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive1, i32 0, i32 0
  %1 = extractvalue { <2 x float>, <2 x float> } %call, 0
  store <2 x float> %1, ptr %0, align 16
  %2 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %coerce.dive1, i32 0, i32 1
  %3 = extractvalue { <2 x float>, <2 x float> } %call, 1
  store <2 x float> %3, ptr %2, align 8
  store ptr %zero, ptr %b3mpr_vec3_origin, align 8
  %4 = load ptr, ptr %portal.addr, align 8
  call void @_Z11b3PortalDirPK15_b3MprSimplex_tP9b3Vector3(ptr noundef %4, ptr noundef %dir)
  %5 = load ptr, ptr %portal.addr, align 8
  %call2 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %5, i32 noundef 1)
  %v = getelementptr inbounds %struct._b3MprSupport_t, ptr %call2, i32 0, i32 0
  %6 = load ptr, ptr %portal.addr, align 8
  %call3 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %6, i32 noundef 2)
  %v4 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call3, i32 0, i32 0
  call void @_Z14b3MprVec3CrossP9b3Vector3PKS_S2_(ptr noundef %vec, ptr noundef %v, ptr noundef %v4)
  %7 = load ptr, ptr %portal.addr, align 8
  %call5 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %7, i32 noundef 3)
  %v6 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call5, i32 0, i32 0
  %call7 = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %vec, ptr noundef %v6)
  %arrayidx = getelementptr inbounds [4 x float], ptr %b, i64 0, i64 0
  store float %call7, ptr %arrayidx, align 16
  %8 = load ptr, ptr %portal.addr, align 8
  %call8 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %8, i32 noundef 3)
  %v9 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call8, i32 0, i32 0
  %9 = load ptr, ptr %portal.addr, align 8
  %call10 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %9, i32 noundef 2)
  %v11 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call10, i32 0, i32 0
  call void @_Z14b3MprVec3CrossP9b3Vector3PKS_S2_(ptr noundef %vec, ptr noundef %v9, ptr noundef %v11)
  %10 = load ptr, ptr %portal.addr, align 8
  %call12 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %10, i32 noundef 0)
  %v13 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call12, i32 0, i32 0
  %call14 = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %vec, ptr noundef %v13)
  %arrayidx15 = getelementptr inbounds [4 x float], ptr %b, i64 0, i64 1
  store float %call14, ptr %arrayidx15, align 4
  %11 = load ptr, ptr %portal.addr, align 8
  %call16 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %11, i32 noundef 0)
  %v17 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call16, i32 0, i32 0
  %12 = load ptr, ptr %portal.addr, align 8
  %call18 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %12, i32 noundef 1)
  %v19 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call18, i32 0, i32 0
  call void @_Z14b3MprVec3CrossP9b3Vector3PKS_S2_(ptr noundef %vec, ptr noundef %v17, ptr noundef %v19)
  %13 = load ptr, ptr %portal.addr, align 8
  %call20 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %13, i32 noundef 3)
  %v21 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call20, i32 0, i32 0
  %call22 = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %vec, ptr noundef %v21)
  %arrayidx23 = getelementptr inbounds [4 x float], ptr %b, i64 0, i64 2
  store float %call22, ptr %arrayidx23, align 8
  %14 = load ptr, ptr %portal.addr, align 8
  %call24 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %14, i32 noundef 2)
  %v25 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call24, i32 0, i32 0
  %15 = load ptr, ptr %portal.addr, align 8
  %call26 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %15, i32 noundef 1)
  %v27 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call26, i32 0, i32 0
  call void @_Z14b3MprVec3CrossP9b3Vector3PKS_S2_(ptr noundef %vec, ptr noundef %v25, ptr noundef %v27)
  %16 = load ptr, ptr %portal.addr, align 8
  %call28 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %16, i32 noundef 0)
  %v29 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call28, i32 0, i32 0
  %call30 = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %vec, ptr noundef %v29)
  %arrayidx31 = getelementptr inbounds [4 x float], ptr %b, i64 0, i64 3
  store float %call30, ptr %arrayidx31, align 4
  %arrayidx32 = getelementptr inbounds [4 x float], ptr %b, i64 0, i64 0
  %17 = load float, ptr %arrayidx32, align 16
  %arrayidx33 = getelementptr inbounds [4 x float], ptr %b, i64 0, i64 1
  %18 = load float, ptr %arrayidx33, align 4
  %add = fadd float %17, %18
  %arrayidx34 = getelementptr inbounds [4 x float], ptr %b, i64 0, i64 2
  %19 = load float, ptr %arrayidx34, align 8
  %add35 = fadd float %add, %19
  %arrayidx36 = getelementptr inbounds [4 x float], ptr %b, i64 0, i64 3
  %20 = load float, ptr %arrayidx36, align 4
  %add37 = fadd float %add35, %20
  store float %add37, ptr %sum, align 4
  %21 = load float, ptr %sum, align 4
  %call38 = call noundef i32 @_Z11b3MprIsZerof(float noundef %21)
  %tobool = icmp ne i32 %call38, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %22 = load float, ptr %sum, align 4
  %cmp = fcmp olt float %22, 0.000000e+00
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %arrayidx39 = getelementptr inbounds [4 x float], ptr %b, i64 0, i64 0
  store float 0.000000e+00, ptr %arrayidx39, align 16
  %23 = load ptr, ptr %portal.addr, align 8
  %call40 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %23, i32 noundef 2)
  %v41 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call40, i32 0, i32 0
  %24 = load ptr, ptr %portal.addr, align 8
  %call42 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %24, i32 noundef 3)
  %v43 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call42, i32 0, i32 0
  call void @_Z14b3MprVec3CrossP9b3Vector3PKS_S2_(ptr noundef %vec, ptr noundef %v41, ptr noundef %v43)
  %call44 = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %vec, ptr noundef %dir)
  %arrayidx45 = getelementptr inbounds [4 x float], ptr %b, i64 0, i64 1
  store float %call44, ptr %arrayidx45, align 4
  %25 = load ptr, ptr %portal.addr, align 8
  %call46 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %25, i32 noundef 3)
  %v47 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call46, i32 0, i32 0
  %26 = load ptr, ptr %portal.addr, align 8
  %call48 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %26, i32 noundef 1)
  %v49 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call48, i32 0, i32 0
  call void @_Z14b3MprVec3CrossP9b3Vector3PKS_S2_(ptr noundef %vec, ptr noundef %v47, ptr noundef %v49)
  %call50 = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %vec, ptr noundef %dir)
  %arrayidx51 = getelementptr inbounds [4 x float], ptr %b, i64 0, i64 2
  store float %call50, ptr %arrayidx51, align 8
  %27 = load ptr, ptr %portal.addr, align 8
  %call52 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %27, i32 noundef 1)
  %v53 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call52, i32 0, i32 0
  %28 = load ptr, ptr %portal.addr, align 8
  %call54 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %28, i32 noundef 2)
  %v55 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call54, i32 0, i32 0
  call void @_Z14b3MprVec3CrossP9b3Vector3PKS_S2_(ptr noundef %vec, ptr noundef %v53, ptr noundef %v55)
  %call56 = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %vec, ptr noundef %dir)
  %arrayidx57 = getelementptr inbounds [4 x float], ptr %b, i64 0, i64 3
  store float %call56, ptr %arrayidx57, align 4
  %arrayidx58 = getelementptr inbounds [4 x float], ptr %b, i64 0, i64 1
  %29 = load float, ptr %arrayidx58, align 4
  %arrayidx59 = getelementptr inbounds [4 x float], ptr %b, i64 0, i64 2
  %30 = load float, ptr %arrayidx59, align 8
  %add60 = fadd float %29, %30
  %arrayidx61 = getelementptr inbounds [4 x float], ptr %b, i64 0, i64 3
  %31 = load float, ptr %arrayidx61, align 4
  %add62 = fadd float %add60, %31
  store float %add62, ptr %sum, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %32 = load float, ptr %sum, align 4
  %div = fdiv float 1.000000e+00, %32
  store float %div, ptr %inv, align 4
  %33 = load ptr, ptr %b3mpr_vec3_origin, align 8
  call void @_Z13b3MprVec3CopyP9b3Vector3PKS_(ptr noundef %p1, ptr noundef %33)
  %34 = load ptr, ptr %b3mpr_vec3_origin, align 8
  call void @_Z13b3MprVec3CopyP9b3Vector3PKS_(ptr noundef %p2, ptr noundef %34)
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %35 = load i64, ptr %i, align 8
  %cmp63 = icmp ult i64 %35, 4
  br i1 %cmp63, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %36 = load ptr, ptr %portal.addr, align 8
  %37 = load i64, ptr %i, align 8
  %conv = trunc i64 %37 to i32
  %call64 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %36, i32 noundef %conv)
  %v1 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call64, i32 0, i32 1
  call void @_Z13b3MprVec3CopyP9b3Vector3PKS_(ptr noundef %vec, ptr noundef %v1)
  %38 = load i64, ptr %i, align 8
  %arrayidx65 = getelementptr inbounds [4 x float], ptr %b, i64 0, i64 %38
  %39 = load float, ptr %arrayidx65, align 4
  call void @_Z14b3MprVec3ScaleP9b3Vector3f(ptr noundef %vec, float noundef %39)
  call void @_Z12b3MprVec3AddP9b3Vector3PKS_(ptr noundef %p1, ptr noundef %vec)
  %40 = load ptr, ptr %portal.addr, align 8
  %41 = load i64, ptr %i, align 8
  %conv66 = trunc i64 %41 to i32
  %call67 = call noundef ptr @_Z17b3MprSimplexPointPK15_b3MprSimplex_ti(ptr noundef %40, i32 noundef %conv66)
  %v2 = getelementptr inbounds %struct._b3MprSupport_t, ptr %call67, i32 0, i32 2
  call void @_Z13b3MprVec3CopyP9b3Vector3PKS_(ptr noundef %vec, ptr noundef %v2)
  %42 = load i64, ptr %i, align 8
  %arrayidx68 = getelementptr inbounds [4 x float], ptr %b, i64 0, i64 %42
  %43 = load float, ptr %arrayidx68, align 4
  call void @_Z14b3MprVec3ScaleP9b3Vector3f(ptr noundef %vec, float noundef %43)
  call void @_Z12b3MprVec3AddP9b3Vector3PKS_(ptr noundef %p2, ptr noundef %vec)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %44 = load i64, ptr %i, align 8
  %inc = add i64 %44, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !83

for.end:                                          ; preds = %for.cond
  %45 = load float, ptr %inv, align 4
  call void @_Z14b3MprVec3ScaleP9b3Vector3f(ptr noundef %p1, float noundef %45)
  %46 = load float, ptr %inv, align 4
  call void @_Z14b3MprVec3ScaleP9b3Vector3f(ptr noundef %p2, float noundef %46)
  %47 = load ptr, ptr %pos.addr, align 8
  call void @_Z13b3MprVec3CopyP9b3Vector3PKS_(ptr noundef %47, ptr noundef %p1)
  %48 = load ptr, ptr %pos.addr, align 8
  call void @_Z12b3MprVec3AddP9b3Vector3PKS_(ptr noundef %48, ptr noundef %p2)
  %49 = load ptr, ptr %pos.addr, align 8
  call void @_Z14b3MprVec3ScaleP9b3Vector3f(ptr noundef %49, float noundef 5.000000e-01)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef float @_Z14b3MprVec3Dist2PK9b3Vector3S1_(ptr noundef %a, ptr noundef %b) #0 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %ab = alloca %class.b3Vector3, align 16
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %1 = load ptr, ptr %b.addr, align 8
  call void @_Z13b3MprVec3Sub2P9b3Vector3PKS_S2_(ptr noundef %ab, ptr noundef %0, ptr noundef %1)
  %call = call noundef float @_Z13b3MprVec3Len2PK9b3Vector3(ptr noundef %ab)
  ret float %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef float @_Z27_b3MprVec3PointSegmentDist2PK9b3Vector3S1_S1_PS_(ptr noundef %P, ptr noundef %x0, ptr noundef %b, ptr noundef %witness) #0 comdat {
entry:
  %P.addr = alloca ptr, align 8
  %x0.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %witness.addr = alloca ptr, align 8
  %dist = alloca float, align 4
  %t = alloca float, align 4
  %d = alloca %class.b3Vector3, align 16
  %a = alloca %class.b3Vector3, align 16
  store ptr %P, ptr %P.addr, align 8
  store ptr %x0, ptr %x0.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  store ptr %witness, ptr %witness.addr, align 8
  %0 = load ptr, ptr %b.addr, align 8
  %1 = load ptr, ptr %x0.addr, align 8
  call void @_Z13b3MprVec3Sub2P9b3Vector3PKS_S2_(ptr noundef %d, ptr noundef %0, ptr noundef %1)
  %2 = load ptr, ptr %x0.addr, align 8
  %3 = load ptr, ptr %P.addr, align 8
  call void @_Z13b3MprVec3Sub2P9b3Vector3PKS_S2_(ptr noundef %a, ptr noundef %2, ptr noundef %3)
  %call = call noundef float @_Z12b3MprVec3DotPK9b3Vector3S1_(ptr noundef %a, ptr noundef %d)
  %mul = fmul float -1.000000e+00, %call
  store float %mul, ptr %t, align 4
  %call1 = call noundef float @_Z13b3MprVec3Len2PK9b3Vector3(ptr noundef %d)
  %4 = load float, ptr %t, align 4
  %div = fdiv float %4, %call1
  store float %div, ptr %t, align 4
  %5 = load float, ptr %t, align 4
  %cmp = fcmp olt float %5, 0.000000e+00
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %6 = load float, ptr %t, align 4
  %call2 = call noundef i32 @_Z11b3MprIsZerof(float noundef %6)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %7 = load ptr, ptr %x0.addr, align 8
  %8 = load ptr, ptr %P.addr, align 8
  %call3 = call noundef float @_Z14b3MprVec3Dist2PK9b3Vector3S1_(ptr noundef %7, ptr noundef %8)
  store float %call3, ptr %dist, align 4
  %9 = load ptr, ptr %witness.addr, align 8
  %tobool4 = icmp ne ptr %9, null
  br i1 %tobool4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then
  %10 = load ptr, ptr %witness.addr, align 8
  %11 = load ptr, ptr %x0.addr, align 8
  call void @_Z13b3MprVec3CopyP9b3Vector3PKS_(ptr noundef %10, ptr noundef %11)
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.then
  br label %if.end23

if.else:                                          ; preds = %lor.lhs.false
  %12 = load float, ptr %t, align 4
  %cmp6 = fcmp ogt float %12, 1.000000e+00
  br i1 %cmp6, label %if.then10, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %if.else
  %13 = load float, ptr %t, align 4
  %call8 = call noundef i32 @_Z7b3MprEqff(float noundef %13, float noundef 1.000000e+00)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then10, label %if.else15

if.then10:                                        ; preds = %lor.lhs.false7, %if.else
  %14 = load ptr, ptr %b.addr, align 8
  %15 = load ptr, ptr %P.addr, align 8
  %call11 = call noundef float @_Z14b3MprVec3Dist2PK9b3Vector3S1_(ptr noundef %14, ptr noundef %15)
  store float %call11, ptr %dist, align 4
  %16 = load ptr, ptr %witness.addr, align 8
  %tobool12 = icmp ne ptr %16, null
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.then10
  %17 = load ptr, ptr %witness.addr, align 8
  %18 = load ptr, ptr %b.addr, align 8
  call void @_Z13b3MprVec3CopyP9b3Vector3PKS_(ptr noundef %17, ptr noundef %18)
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.then10
  br label %if.end22

if.else15:                                        ; preds = %lor.lhs.false7
  %19 = load ptr, ptr %witness.addr, align 8
  %tobool16 = icmp ne ptr %19, null
  br i1 %tobool16, label %if.then17, label %if.else19

if.then17:                                        ; preds = %if.else15
  %20 = load ptr, ptr %witness.addr, align 8
  call void @_Z13b3MprVec3CopyP9b3Vector3PKS_(ptr noundef %20, ptr noundef %d)
  %21 = load ptr, ptr %witness.addr, align 8
  %22 = load float, ptr %t, align 4
  call void @_Z14b3MprVec3ScaleP9b3Vector3f(ptr noundef %21, float noundef %22)
  %23 = load ptr, ptr %witness.addr, align 8
  %24 = load ptr, ptr %x0.addr, align 8
  call void @_Z12b3MprVec3AddP9b3Vector3PKS_(ptr noundef %23, ptr noundef %24)
  %25 = load ptr, ptr %witness.addr, align 8
  %26 = load ptr, ptr %P.addr, align 8
  %call18 = call noundef float @_Z14b3MprVec3Dist2PK9b3Vector3S1_(ptr noundef %25, ptr noundef %26)
  store float %call18, ptr %dist, align 4
  br label %if.end21

if.else19:                                        ; preds = %if.else15
  %27 = load float, ptr %t, align 4
  call void @_Z14b3MprVec3ScaleP9b3Vector3f(ptr noundef %d, float noundef %27)
  call void @_Z12b3MprVec3AddP9b3Vector3PKS_(ptr noundef %d, ptr noundef %a)
  %call20 = call noundef float @_Z13b3MprVec3Len2PK9b3Vector3(ptr noundef %d)
  store float %call20, ptr %dist, align 4
  br label %if.end21

if.end21:                                         ; preds = %if.else19, %if.then17
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %if.end14
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %if.end
  %28 = load float, ptr %dist, align 4
  ret float %28
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %this, i64 noundef %_Count, i1 noundef zeroext %copyOldContents) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_Count.addr = alloca i64, align 8
  %copyOldContents.addr = alloca i8, align 1
  %result = alloca i8, align 1
  %ciErrNum = alloca i32, align 4
  %memSizeInBytes = alloca i64, align 8
  %buf = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %_Count, ptr %_Count.addr, align 8
  %frombool = zext i1 %copyOldContents to i8
  store i8 %frombool, ptr %copyOldContents.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  store i8 1, ptr %result, align 1
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI9b3Vector3E8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %0 = load i64, ptr %_Count.addr, align 8
  %cmp = icmp ult i64 %call, %0
  br i1 %cmp, label %if.then, label %if.end14

if.then:                                          ; preds = %entry
  %m_allowGrowingCapacity = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 7
  %1 = load i8, ptr %m_allowGrowingCapacity, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %2 = load i64, ptr %_Count.addr, align 8
  %mul = mul i64 16, %2
  store i64 %mul, ptr %memSizeInBytes, align 8
  %3 = load ptr, ptr @__clewCreateBuffer, align 8
  %m_clContext = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 4
  %4 = load ptr, ptr %m_clContext, align 8
  %5 = load i64, ptr %memSizeInBytes, align 8
  %call3 = call ptr %3(ptr noundef %4, i64 noundef 1, i64 noundef %5, ptr noundef null, ptr noundef %ciErrNum)
  store ptr %call3, ptr %buf, align 8
  %6 = load i32, ptr %ciErrNum, align 4
  %cmp4 = icmp ne i32 %6, 0
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then2
  br label %do.body

do.body:                                          ; preds = %if.then5
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.75, i32 noundef 166)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.76)
  br label %do.end

do.end:                                           ; preds = %do.body
  store i64 0, ptr %_Count.addr, align 8
  store i8 0, ptr %result, align 1
  br label %if.end

if.end:                                           ; preds = %do.end, %if.then2
  %7 = load i8, ptr %result, align 1
  %tobool6 = trunc i8 %7 to i1
  br i1 %tobool6, label %if.then7, label %if.end12

if.then7:                                         ; preds = %if.end
  %8 = load i8, ptr %copyOldContents.addr, align 1
  %tobool8 = trunc i8 %8 to i1
  br i1 %tobool8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.then7
  %9 = load ptr, ptr %buf, align 8
  %call10 = call noundef i64 @_ZNK13b3OpenCLArrayI9b3Vector3E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  call void @_ZNK13b3OpenCLArrayI9b3Vector3E8copyToCLEP7_cl_memmmm(ptr noundef nonnull align 8 dereferenceable(50) %this1, ptr noundef %9, i64 noundef %call10, i64 noundef 0, i64 noundef 0)
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.then7
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %if.end
  call void @_ZN13b3OpenCLArrayI9b3Vector3E10deallocateEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %10 = load ptr, ptr %buf, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 3
  store ptr %10, ptr %m_clBuffer, align 8
  %11 = load i64, ptr %_Count.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 2
  store i64 %11, ptr %m_capacity, align 8
  br label %if.end13

if.else:                                          ; preds = %if.then
  call void @_ZN13b3OpenCLArrayI9b3Vector3E10deallocateEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  store i8 0, ptr %result, align 1
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.end12
  br label %if.end14

if.end14:                                         ; preds = %if.end13, %entry
  %12 = load i8, ptr %result, align 1
  %tobool15 = trunc i8 %12 to i1
  ret i1 %tobool15
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayI9b3Vector3ED0Ev(ptr noundef nonnull align 8 dereferenceable(50) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN13b3OpenCLArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %this1) #13
  call void @_ZdlPv(ptr noundef %this1) #15
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayI9b3Vector3E8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 2
  %0 = load i64, ptr %m_capacity, align 8
  ret i64 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI9b3Vector3E8copyToCLEP7_cl_memmmm(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %destination, i64 noundef %numElements, i64 noundef %firstElem, i64 noundef %dstOffsetInElems) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destination.addr = alloca ptr, align 8
  %numElements.addr = alloca i64, align 8
  %firstElem.addr = alloca i64, align 8
  %dstOffsetInElems.addr = alloca i64, align 8
  %status = alloca i32, align 4
  %srcOffsetBytes = alloca i64, align 8
  %dstOffsetInBytes = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %destination, ptr %destination.addr, align 8
  store i64 %numElements, ptr %numElements.addr, align 8
  store i64 %firstElem, ptr %firstElem.addr, align 8
  store i64 %dstOffsetInElems, ptr %dstOffsetInElems.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %numElements.addr, align 8
  %cmp = icmp ule i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %status, align 4
  %1 = load i64, ptr %firstElem.addr, align 8
  %mul = mul i64 16, %1
  store i64 %mul, ptr %srcOffsetBytes, align 8
  %2 = load i64, ptr %dstOffsetInElems.addr, align 8
  %mul2 = mul i64 16, %2
  store i64 %mul2, ptr %dstOffsetInBytes, align 8
  %3 = load ptr, ptr @__clewEnqueueCopyBuffer, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 5
  %4 = load ptr, ptr %m_commandQueue, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 3
  %5 = load ptr, ptr %m_clBuffer, align 8
  %6 = load ptr, ptr %destination.addr, align 8
  %7 = load i64, ptr %srcOffsetBytes, align 8
  %8 = load i64, ptr %dstOffsetInBytes, align 8
  %9 = load i64, ptr %numElements.addr, align 8
  %mul3 = mul i64 16, %9
  %call = call i32 %3(ptr noundef %4, ptr noundef %5, ptr noundef %6, i64 noundef %7, i64 noundef %8, i64 noundef %mul3, i32 noundef 0, ptr noundef null, ptr noundef null)
  store i32 %call, ptr %status, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayI9b3Vector3E10deallocateEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 3
  %0 = load ptr, ptr %m_clBuffer, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %m_ownsMemory = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 6
  %1 = load i8, ptr %m_ownsMemory, align 8
  %tobool2 = trunc i8 %1 to i1
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %2 = load ptr, ptr @__clewReleaseMemObject, align 8
  %m_clBuffer3 = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 3
  %3 = load ptr, ptr %m_clBuffer3, align 8
  %call = call i32 %2(ptr noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %m_clBuffer4 = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 3
  store ptr null, ptr %m_clBuffer4, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 2
  store i64 0, ptr %m_capacity, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN13b3OpenCLArrayIiE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %this, i64 noundef %_Count, i1 noundef zeroext %copyOldContents) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_Count.addr = alloca i64, align 8
  %copyOldContents.addr = alloca i8, align 1
  %result = alloca i8, align 1
  %ciErrNum = alloca i32, align 4
  %memSizeInBytes = alloca i64, align 8
  %buf = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %_Count, ptr %_Count.addr, align 8
  %frombool = zext i1 %copyOldContents to i8
  store i8 %frombool, ptr %copyOldContents.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  store i8 1, ptr %result, align 1
  %call = call noundef i64 @_ZNK13b3OpenCLArrayIiE8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %0 = load i64, ptr %_Count.addr, align 8
  %cmp = icmp ult i64 %call, %0
  br i1 %cmp, label %if.then, label %if.end14

if.then:                                          ; preds = %entry
  %m_allowGrowingCapacity = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 7
  %1 = load i8, ptr %m_allowGrowingCapacity, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %2 = load i64, ptr %_Count.addr, align 8
  %mul = mul i64 4, %2
  store i64 %mul, ptr %memSizeInBytes, align 8
  %3 = load ptr, ptr @__clewCreateBuffer, align 8
  %m_clContext = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 4
  %4 = load ptr, ptr %m_clContext, align 8
  %5 = load i64, ptr %memSizeInBytes, align 8
  %call3 = call ptr %3(ptr noundef %4, i64 noundef 1, i64 noundef %5, ptr noundef null, ptr noundef %ciErrNum)
  store ptr %call3, ptr %buf, align 8
  %6 = load i32, ptr %ciErrNum, align 4
  %cmp4 = icmp ne i32 %6, 0
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then2
  br label %do.body

do.body:                                          ; preds = %if.then5
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.75, i32 noundef 166)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.76)
  br label %do.end

do.end:                                           ; preds = %do.body
  store i64 0, ptr %_Count.addr, align 8
  store i8 0, ptr %result, align 1
  br label %if.end

if.end:                                           ; preds = %do.end, %if.then2
  %7 = load i8, ptr %result, align 1
  %tobool6 = trunc i8 %7 to i1
  br i1 %tobool6, label %if.then7, label %if.end12

if.then7:                                         ; preds = %if.end
  %8 = load i8, ptr %copyOldContents.addr, align 1
  %tobool8 = trunc i8 %8 to i1
  br i1 %tobool8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.then7
  %9 = load ptr, ptr %buf, align 8
  %call10 = call noundef i64 @_ZNK13b3OpenCLArrayIiE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  call void @_ZNK13b3OpenCLArrayIiE8copyToCLEP7_cl_memmmm(ptr noundef nonnull align 8 dereferenceable(50) %this1, ptr noundef %9, i64 noundef %call10, i64 noundef 0, i64 noundef 0)
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.then7
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %if.end
  call void @_ZN13b3OpenCLArrayIiE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %10 = load ptr, ptr %buf, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 3
  store ptr %10, ptr %m_clBuffer, align 8
  %11 = load i64, ptr %_Count.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 2
  store i64 %11, ptr %m_capacity, align 8
  br label %if.end13

if.else:                                          ; preds = %if.then
  call void @_ZN13b3OpenCLArrayIiE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  store i8 0, ptr %result, align 1
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.end12
  br label %if.end14

if.end14:                                         ; preds = %if.end13, %entry
  %12 = load i8, ptr %result, align 1
  %tobool15 = trunc i8 %12 to i1
  ret i1 %tobool15
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayIiED0Ev(ptr noundef nonnull align 8 dereferenceable(50) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN13b3OpenCLArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %this1) #13
  call void @_ZdlPv(ptr noundef %this1) #15
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayIiE8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 2
  %0 = load i64, ptr %m_capacity, align 8
  ret i64 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayIiE8copyToCLEP7_cl_memmmm(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %destination, i64 noundef %numElements, i64 noundef %firstElem, i64 noundef %dstOffsetInElems) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destination.addr = alloca ptr, align 8
  %numElements.addr = alloca i64, align 8
  %firstElem.addr = alloca i64, align 8
  %dstOffsetInElems.addr = alloca i64, align 8
  %status = alloca i32, align 4
  %srcOffsetBytes = alloca i64, align 8
  %dstOffsetInBytes = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %destination, ptr %destination.addr, align 8
  store i64 %numElements, ptr %numElements.addr, align 8
  store i64 %firstElem, ptr %firstElem.addr, align 8
  store i64 %dstOffsetInElems, ptr %dstOffsetInElems.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %numElements.addr, align 8
  %cmp = icmp ule i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %status, align 4
  %1 = load i64, ptr %firstElem.addr, align 8
  %mul = mul i64 4, %1
  store i64 %mul, ptr %srcOffsetBytes, align 8
  %2 = load i64, ptr %dstOffsetInElems.addr, align 8
  %mul2 = mul i64 4, %2
  store i64 %mul2, ptr %dstOffsetInBytes, align 8
  %3 = load ptr, ptr @__clewEnqueueCopyBuffer, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 5
  %4 = load ptr, ptr %m_commandQueue, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 3
  %5 = load ptr, ptr %m_clBuffer, align 8
  %6 = load ptr, ptr %destination.addr, align 8
  %7 = load i64, ptr %srcOffsetBytes, align 8
  %8 = load i64, ptr %dstOffsetInBytes, align 8
  %9 = load i64, ptr %numElements.addr, align 8
  %mul3 = mul i64 4, %9
  %call = call i32 %3(ptr noundef %4, ptr noundef %5, ptr noundef %6, i64 noundef %7, i64 noundef %8, i64 noundef %mul3, i32 noundef 0, ptr noundef null, ptr noundef null)
  store i32 %call, ptr %status, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayIiE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %m_size, align 8
  ret i64 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayIiE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 3
  %0 = load ptr, ptr %m_clBuffer, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %m_ownsMemory = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 6
  %1 = load i8, ptr %m_ownsMemory, align 8
  %tobool2 = trunc i8 %1 to i1
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %2 = load ptr, ptr @__clewReleaseMemObject, align 8
  %m_clBuffer3 = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 3
  %3 = load ptr, ptr %m_clBuffer3, align 8
  %call = call i32 %2(ptr noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %m_clBuffer4 = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 3
  store ptr null, ptr %m_clBuffer4, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 2
  store i64 0, ptr %m_capacity, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN13b3OpenCLArrayIfE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %this, i64 noundef %_Count, i1 noundef zeroext %copyOldContents) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_Count.addr = alloca i64, align 8
  %copyOldContents.addr = alloca i8, align 1
  %result = alloca i8, align 1
  %ciErrNum = alloca i32, align 4
  %memSizeInBytes = alloca i64, align 8
  %buf = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %_Count, ptr %_Count.addr, align 8
  %frombool = zext i1 %copyOldContents to i8
  store i8 %frombool, ptr %copyOldContents.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  store i8 1, ptr %result, align 1
  %call = call noundef i64 @_ZNK13b3OpenCLArrayIfE8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %0 = load i64, ptr %_Count.addr, align 8
  %cmp = icmp ult i64 %call, %0
  br i1 %cmp, label %if.then, label %if.end14

if.then:                                          ; preds = %entry
  %m_allowGrowingCapacity = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this1, i32 0, i32 7
  %1 = load i8, ptr %m_allowGrowingCapacity, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %2 = load i64, ptr %_Count.addr, align 8
  %mul = mul i64 4, %2
  store i64 %mul, ptr %memSizeInBytes, align 8
  %3 = load ptr, ptr @__clewCreateBuffer, align 8
  %m_clContext = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this1, i32 0, i32 4
  %4 = load ptr, ptr %m_clContext, align 8
  %5 = load i64, ptr %memSizeInBytes, align 8
  %call3 = call ptr %3(ptr noundef %4, i64 noundef 1, i64 noundef %5, ptr noundef null, ptr noundef %ciErrNum)
  store ptr %call3, ptr %buf, align 8
  %6 = load i32, ptr %ciErrNum, align 4
  %cmp4 = icmp ne i32 %6, 0
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then2
  br label %do.body

do.body:                                          ; preds = %if.then5
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.75, i32 noundef 166)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.76)
  br label %do.end

do.end:                                           ; preds = %do.body
  store i64 0, ptr %_Count.addr, align 8
  store i8 0, ptr %result, align 1
  br label %if.end

if.end:                                           ; preds = %do.end, %if.then2
  %7 = load i8, ptr %result, align 1
  %tobool6 = trunc i8 %7 to i1
  br i1 %tobool6, label %if.then7, label %if.end12

if.then7:                                         ; preds = %if.end
  %8 = load i8, ptr %copyOldContents.addr, align 1
  %tobool8 = trunc i8 %8 to i1
  br i1 %tobool8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.then7
  %9 = load ptr, ptr %buf, align 8
  %call10 = call noundef i64 @_ZNK13b3OpenCLArrayIfE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  call void @_ZNK13b3OpenCLArrayIfE8copyToCLEP7_cl_memmmm(ptr noundef nonnull align 8 dereferenceable(50) %this1, ptr noundef %9, i64 noundef %call10, i64 noundef 0, i64 noundef 0)
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.then7
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %if.end
  call void @_ZN13b3OpenCLArrayIfE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %10 = load ptr, ptr %buf, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this1, i32 0, i32 3
  store ptr %10, ptr %m_clBuffer, align 8
  %11 = load i64, ptr %_Count.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this1, i32 0, i32 2
  store i64 %11, ptr %m_capacity, align 8
  br label %if.end13

if.else:                                          ; preds = %if.then
  call void @_ZN13b3OpenCLArrayIfE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  store i8 0, ptr %result, align 1
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.end12
  br label %if.end14

if.end14:                                         ; preds = %if.end13, %entry
  %12 = load i8, ptr %result, align 1
  %tobool15 = trunc i8 %12 to i1
  ret i1 %tobool15
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayIfED0Ev(ptr noundef nonnull align 8 dereferenceable(50) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN13b3OpenCLArrayIfED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %this1) #13
  call void @_ZdlPv(ptr noundef %this1) #15
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayIfE8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this1, i32 0, i32 2
  %0 = load i64, ptr %m_capacity, align 8
  ret i64 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayIfE8copyToCLEP7_cl_memmmm(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %destination, i64 noundef %numElements, i64 noundef %firstElem, i64 noundef %dstOffsetInElems) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destination.addr = alloca ptr, align 8
  %numElements.addr = alloca i64, align 8
  %firstElem.addr = alloca i64, align 8
  %dstOffsetInElems.addr = alloca i64, align 8
  %status = alloca i32, align 4
  %srcOffsetBytes = alloca i64, align 8
  %dstOffsetInBytes = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %destination, ptr %destination.addr, align 8
  store i64 %numElements, ptr %numElements.addr, align 8
  store i64 %firstElem, ptr %firstElem.addr, align 8
  store i64 %dstOffsetInElems, ptr %dstOffsetInElems.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %numElements.addr, align 8
  %cmp = icmp ule i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %status, align 4
  %1 = load i64, ptr %firstElem.addr, align 8
  %mul = mul i64 4, %1
  store i64 %mul, ptr %srcOffsetBytes, align 8
  %2 = load i64, ptr %dstOffsetInElems.addr, align 8
  %mul2 = mul i64 4, %2
  store i64 %mul2, ptr %dstOffsetInBytes, align 8
  %3 = load ptr, ptr @__clewEnqueueCopyBuffer, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this1, i32 0, i32 5
  %4 = load ptr, ptr %m_commandQueue, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this1, i32 0, i32 3
  %5 = load ptr, ptr %m_clBuffer, align 8
  %6 = load ptr, ptr %destination.addr, align 8
  %7 = load i64, ptr %srcOffsetBytes, align 8
  %8 = load i64, ptr %dstOffsetInBytes, align 8
  %9 = load i64, ptr %numElements.addr, align 8
  %mul3 = mul i64 4, %9
  %call = call i32 %3(ptr noundef %4, ptr noundef %5, ptr noundef %6, i64 noundef %7, i64 noundef %8, i64 noundef %mul3, i32 noundef 0, ptr noundef null, ptr noundef null)
  store i32 %call, ptr %status, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayIfE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %m_size, align 8
  ret i64 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayIfE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this1, i32 0, i32 3
  %0 = load ptr, ptr %m_clBuffer, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %m_ownsMemory = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this1, i32 0, i32 6
  %1 = load i8, ptr %m_ownsMemory, align 8
  %tobool2 = trunc i8 %1 to i1
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %2 = load ptr, ptr @__clewReleaseMemObject, align 8
  %m_clBuffer3 = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this1, i32 0, i32 3
  %3 = load ptr, ptr %m_clBuffer3, align 8
  %call = call i32 %2(ptr noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %m_clBuffer4 = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this1, i32 0, i32 3
  store ptr null, ptr %m_clBuffer4, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this1, i32 0, i32 2
  store i64 0, ptr %m_capacity, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %this, i64 noundef %_Count, i1 noundef zeroext %copyOldContents) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_Count.addr = alloca i64, align 8
  %copyOldContents.addr = alloca i8, align 1
  %result = alloca i8, align 1
  %ciErrNum = alloca i32, align 4
  %memSizeInBytes = alloca i64, align 8
  %buf = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %_Count, ptr %_Count.addr, align 8
  %frombool = zext i1 %copyOldContents to i8
  store i8 %frombool, ptr %copyOldContents.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  store i8 1, ptr %result, align 1
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI25b3CompoundOverlappingPairE8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %0 = load i64, ptr %_Count.addr, align 8
  %cmp = icmp ult i64 %call, %0
  br i1 %cmp, label %if.then, label %if.end14

if.then:                                          ; preds = %entry
  %m_allowGrowingCapacity = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 7
  %1 = load i8, ptr %m_allowGrowingCapacity, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %2 = load i64, ptr %_Count.addr, align 8
  %mul = mul i64 16, %2
  store i64 %mul, ptr %memSizeInBytes, align 8
  %3 = load ptr, ptr @__clewCreateBuffer, align 8
  %m_clContext = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 4
  %4 = load ptr, ptr %m_clContext, align 8
  %5 = load i64, ptr %memSizeInBytes, align 8
  %call3 = call ptr %3(ptr noundef %4, i64 noundef 1, i64 noundef %5, ptr noundef null, ptr noundef %ciErrNum)
  store ptr %call3, ptr %buf, align 8
  %6 = load i32, ptr %ciErrNum, align 4
  %cmp4 = icmp ne i32 %6, 0
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then2
  br label %do.body

do.body:                                          ; preds = %if.then5
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.75, i32 noundef 166)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.76)
  br label %do.end

do.end:                                           ; preds = %do.body
  store i64 0, ptr %_Count.addr, align 8
  store i8 0, ptr %result, align 1
  br label %if.end

if.end:                                           ; preds = %do.end, %if.then2
  %7 = load i8, ptr %result, align 1
  %tobool6 = trunc i8 %7 to i1
  br i1 %tobool6, label %if.then7, label %if.end12

if.then7:                                         ; preds = %if.end
  %8 = load i8, ptr %copyOldContents.addr, align 1
  %tobool8 = trunc i8 %8 to i1
  br i1 %tobool8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.then7
  %9 = load ptr, ptr %buf, align 8
  %call10 = call noundef i64 @_ZNK13b3OpenCLArrayI25b3CompoundOverlappingPairE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  call void @_ZNK13b3OpenCLArrayI25b3CompoundOverlappingPairE8copyToCLEP7_cl_memmmm(ptr noundef nonnull align 8 dereferenceable(50) %this1, ptr noundef %9, i64 noundef %call10, i64 noundef 0, i64 noundef 0)
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.then7
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %if.end
  call void @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %10 = load ptr, ptr %buf, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 3
  store ptr %10, ptr %m_clBuffer, align 8
  %11 = load i64, ptr %_Count.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 2
  store i64 %11, ptr %m_capacity, align 8
  br label %if.end13

if.else:                                          ; preds = %if.then
  call void @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  store i8 0, ptr %result, align 1
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.end12
  br label %if.end14

if.end14:                                         ; preds = %if.end13, %entry
  %12 = load i8, ptr %result, align 1
  %tobool15 = trunc i8 %12 to i1
  ret i1 %tobool15
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairED0Ev(ptr noundef nonnull align 8 dereferenceable(50) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %this1) #13
  call void @_ZdlPv(ptr noundef %this1) #15
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayI25b3CompoundOverlappingPairE8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 2
  %0 = load i64, ptr %m_capacity, align 8
  ret i64 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI25b3CompoundOverlappingPairE8copyToCLEP7_cl_memmmm(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %destination, i64 noundef %numElements, i64 noundef %firstElem, i64 noundef %dstOffsetInElems) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destination.addr = alloca ptr, align 8
  %numElements.addr = alloca i64, align 8
  %firstElem.addr = alloca i64, align 8
  %dstOffsetInElems.addr = alloca i64, align 8
  %status = alloca i32, align 4
  %srcOffsetBytes = alloca i64, align 8
  %dstOffsetInBytes = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %destination, ptr %destination.addr, align 8
  store i64 %numElements, ptr %numElements.addr, align 8
  store i64 %firstElem, ptr %firstElem.addr, align 8
  store i64 %dstOffsetInElems, ptr %dstOffsetInElems.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %numElements.addr, align 8
  %cmp = icmp ule i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %status, align 4
  %1 = load i64, ptr %firstElem.addr, align 8
  %mul = mul i64 16, %1
  store i64 %mul, ptr %srcOffsetBytes, align 8
  %2 = load i64, ptr %dstOffsetInElems.addr, align 8
  %mul2 = mul i64 16, %2
  store i64 %mul2, ptr %dstOffsetInBytes, align 8
  %3 = load ptr, ptr @__clewEnqueueCopyBuffer, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 5
  %4 = load ptr, ptr %m_commandQueue, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 3
  %5 = load ptr, ptr %m_clBuffer, align 8
  %6 = load ptr, ptr %destination.addr, align 8
  %7 = load i64, ptr %srcOffsetBytes, align 8
  %8 = load i64, ptr %dstOffsetInBytes, align 8
  %9 = load i64, ptr %numElements.addr, align 8
  %mul3 = mul i64 16, %9
  %call = call i32 %3(ptr noundef %4, ptr noundef %5, ptr noundef %6, i64 noundef %7, i64 noundef %8, i64 noundef %mul3, i32 noundef 0, ptr noundef null, ptr noundef null)
  store i32 %call, ptr %status, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 3
  %0 = load ptr, ptr %m_clBuffer, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %m_ownsMemory = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 6
  %1 = load i8, ptr %m_ownsMemory, align 8
  %tobool2 = trunc i8 %1 to i1
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %2 = load ptr, ptr @__clewReleaseMemObject, align 8
  %m_clBuffer3 = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 3
  %3 = load ptr, ptr %m_clBuffer3, align 8
  %call = call i32 %2(ptr noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %m_clBuffer4 = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 3
  store ptr null, ptr %m_clBuffer4, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this1, i32 0, i32 2
  store i64 0, ptr %m_capacity, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZN13b3OpenCLArrayIiE9allocSizeEm(ptr noundef nonnull align 8 dereferenceable(50) %this, i64 noundef %size) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i64, ptr %size.addr, align 8
  %mul = mul i64 %1, 2
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %mul, %cond.true ], [ 1, %cond.false ]
  ret i64 %cond
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI10b3Contact4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this1, i32 0, i32 2
  %0 = load i32, ptr %m_size, align 4
  ret i32 %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI10b3Contact4E8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this1, i32 0, i32 3
  %0 = load i32, ptr %m_capacity, align 8
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI10b3Contact4E7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_Count.addr = alloca i32, align 4
  %s = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %_Count, ptr %_Count.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI10b3Contact4E8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %0 = load i32, ptr %_Count.addr, align 4
  %cmp = icmp slt i32 %call, %0
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %_Count.addr, align 4
  %call2 = call noundef ptr @_ZN20b3AlignedObjectArrayI10b3Contact4E8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %1)
  store ptr %call2, ptr %s, align 8
  %2 = load ptr, ptr %s, align 8
  %cmp3 = icmp eq ptr %2, null
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then4
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.78, i32 noundef 301)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.79)
  br label %do.end

do.end:                                           ; preds = %do.body
  store i32 0, ptr %_Count.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %do.end, %if.then
  %call5 = call noundef i32 @_ZNK20b3AlignedObjectArrayI10b3Contact4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %3 = load ptr, ptr %s, align 8
  call void @_ZNK20b3AlignedObjectArrayI10b3Contact4E4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call5, ptr noundef %3)
  %call6 = call noundef i32 @_ZNK20b3AlignedObjectArrayI10b3Contact4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI10b3Contact4E7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call6)
  call void @_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %4 = load ptr, ptr %s, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this1, i32 0, i32 5
  store ptr %4, ptr %m_data, align 8
  %5 = load i32, ptr %_Count.addr, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this1, i32 0, i32 3
  store i32 %5, ptr %m_capacity, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZN20b3AlignedObjectArrayI10b3Contact4E9allocSizeEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %size) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %0 = load i32, ptr %size.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i32, ptr %size.addr, align 4
  %mul = mul nsw i32 %1, 2
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %mul, %cond.true ], [ 1, %cond.false ]
  ret i32 %cond
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN10b3Contact4nwEmPv(i64 noundef %0, ptr noundef %ptr) #3 comdat align 2 {
entry:
  %.addr = alloca i64, align 8
  %ptr.addr = alloca ptr, align 8
  store i64 %0, ptr %.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %1 = load ptr, ptr %ptr.addr, align 8
  ret ptr %1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN20b3AlignedObjectArrayI10b3Contact4E8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %size) #0 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %size.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %size.addr, align 4
  %call = call noundef ptr @_ZN18b3AlignedAllocatorI10b3Contact4Lj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, i32 noundef %1, ptr noundef null)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK20b3AlignedObjectArrayI10b3Contact4E4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %start, i32 noundef %end, ptr noundef %dest) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %start.addr = alloca i32, align 4
  %end.addr = alloca i32, align 4
  %dest.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %start, ptr %start.addr, align 4
  store i32 %end, ptr %end.addr, align 4
  store ptr %dest, ptr %dest.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %start.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %end.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %dest.addr, align 8
  %4 = load i32, ptr %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds %struct.b3Contact4, ptr %3, i64 %idxprom
  %call = call noundef ptr @_ZN10b3Contact4nwEmPv(i64 noundef 112, ptr noundef %arrayidx)
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this1, i32 0, i32 5
  %5 = load ptr, ptr %m_data, align 8
  %6 = load i32, ptr %i, align 4
  %idxprom2 = sext i32 %6 to i64
  %arrayidx3 = getelementptr inbounds %struct.b3Contact4, ptr %5, i64 %idxprom2
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %call, ptr align 16 %arrayidx3, i64 112, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i32, ptr %i, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !84

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI10b3Contact4E7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %first, i32 noundef %last) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %first.addr = alloca i32, align 4
  %last.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %first, ptr %first.addr, align 4
  store i32 %last, ptr %last.addr, align 4
  %0 = load i32, ptr %first.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %last.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %3 = load i32, ptr %i, align 4
  %inc = add nsw i32 %3, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !85

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this1, i32 0, i32 6
  %1 = load i8, ptr %m_ownsMemory, align 8
  %tobool2 = trunc i8 %1 to i1
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this1, i32 0, i32 0
  %m_data4 = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this1, i32 0, i32 5
  %2 = load ptr, ptr %m_data4, align 8
  call void @_ZN18b3AlignedAllocatorI10b3Contact4Lj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, ptr noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %m_data5 = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data5, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN18b3AlignedAllocatorI10b3Contact4Lj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, i32 noundef %n, ptr noundef %hint) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %hint.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  store ptr %hint, ptr %hint.addr, align 8
  %0 = load i32, ptr %n.addr, align 4
  %conv = sext i32 %0 to i64
  %mul = mul i64 112, %conv
  %call = call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul, i32 noundef 16)
  ret ptr %call
}

declare noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef, i32 noundef) #5

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI10b3Contact4Lj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, ptr noundef %ptr) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @_Z21b3AlignedFreeInternalPv(ptr noundef %0)
  ret void
}

declare void @_Z21b3AlignedFreeInternalPv(ptr noundef) #5

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI6b3Int2Lj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3Int2E4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %this1, i32 0, i32 3
  store i32 0, ptr %m_capacity, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3Int2E5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI6b3Int2E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI6b3Int2E7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call)
  call void @_ZN20b3AlignedObjectArrayI6b3Int2E10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI6b3Int2E4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3Int2E7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %first, i32 noundef %last) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %first.addr = alloca i32, align 4
  %last.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %first, ptr %first.addr, align 4
  store i32 %last, ptr %last.addr, align 4
  %0 = load i32, ptr %first.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %last.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %3 = load i32, ptr %i, align 4
  %inc = add nsw i32 %3, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !86

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI6b3Int2E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %this1, i32 0, i32 2
  %0 = load i32, ptr %m_size, align 4
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3Int2E10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %this1, i32 0, i32 6
  %1 = load i8, ptr %m_ownsMemory, align 8
  %tobool2 = trunc i8 %1 to i1
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %this1, i32 0, i32 0
  %m_data4 = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %this1, i32 0, i32 5
  %2 = load ptr, ptr %m_data4, align 8
  call void @_ZN18b3AlignedAllocatorI6b3Int2Lj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, ptr noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %m_data5 = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data5, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI6b3Int2Lj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, ptr noundef %ptr) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @_Z21b3AlignedFreeInternalPv(ptr noundef %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3Int2E7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_Count.addr = alloca i32, align 4
  %s = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %_Count, ptr %_Count.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI6b3Int2E8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %0 = load i32, ptr %_Count.addr, align 4
  %cmp = icmp slt i32 %call, %0
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %_Count.addr, align 4
  %call2 = call noundef ptr @_ZN20b3AlignedObjectArrayI6b3Int2E8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %1)
  store ptr %call2, ptr %s, align 8
  %2 = load ptr, ptr %s, align 8
  %cmp3 = icmp eq ptr %2, null
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then4
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.78, i32 noundef 301)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.79)
  br label %do.end

do.end:                                           ; preds = %do.body
  store i32 0, ptr %_Count.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %do.end, %if.then
  %call5 = call noundef i32 @_ZNK20b3AlignedObjectArrayI6b3Int2E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %3 = load ptr, ptr %s, align 8
  call void @_ZNK20b3AlignedObjectArrayI6b3Int2E4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call5, ptr noundef %3)
  %call6 = call noundef i32 @_ZNK20b3AlignedObjectArrayI6b3Int2E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI6b3Int2E7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call6)
  call void @_ZN20b3AlignedObjectArrayI6b3Int2E10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %4 = load ptr, ptr %s, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %this1, i32 0, i32 5
  store ptr %4, ptr %m_data, align 8
  %5 = load i32, ptr %_Count.addr, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %this1, i32 0, i32 3
  store i32 %5, ptr %m_capacity, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI6b3Int2E8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %this1, i32 0, i32 3
  %0 = load i32, ptr %m_capacity, align 8
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN20b3AlignedObjectArrayI6b3Int2E8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %size) #0 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %size.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %size.addr, align 4
  %call = call noundef ptr @_ZN18b3AlignedAllocatorI6b3Int2Lj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, i32 noundef %1, ptr noundef null)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZNK20b3AlignedObjectArrayI6b3Int2E4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %start, i32 noundef %end, ptr noundef %dest) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %start.addr = alloca i32, align 4
  %end.addr = alloca i32, align 4
  %dest.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %start, ptr %start.addr, align 4
  store i32 %end, ptr %end.addr, align 4
  store ptr %dest, ptr %dest.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %start.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %end.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %dest.addr, align 8
  %4 = load i32, ptr %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds %struct.b3Int2, ptr %3, i64 %idxprom
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %this1, i32 0, i32 5
  %5 = load ptr, ptr %m_data, align 8
  %6 = load i32, ptr %i, align 4
  %idxprom2 = sext i32 %6 to i64
  %arrayidx3 = getelementptr inbounds %struct.b3Int2, ptr %5, i64 %idxprom2
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx, ptr align 4 %arrayidx3, i64 8, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i32, ptr %i, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !87

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN18b3AlignedAllocatorI6b3Int2Lj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, i32 noundef %n, ptr noundef %hint) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %hint.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  store ptr %hint, ptr %hint.addr, align 8
  %0 = load i32, ptr %n.addr, align 4
  %conv = sext i32 %0 to i64
  %mul = mul i64 8, %conv
  %call = call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul, i32 noundef 16)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI6b3Int4Lj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3Int4E4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this1, i32 0, i32 3
  store i32 0, ptr %m_capacity, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3Int4E5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI6b3Int4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI6b3Int4E7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call)
  call void @_ZN20b3AlignedObjectArrayI6b3Int4E10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI6b3Int4E4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3Int4E7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %first, i32 noundef %last) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %first.addr = alloca i32, align 4
  %last.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %first, ptr %first.addr, align 4
  store i32 %last, ptr %last.addr, align 4
  %0 = load i32, ptr %first.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %last.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %3 = load i32, ptr %i, align 4
  %inc = add nsw i32 %3, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !88

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI6b3Int4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this1, i32 0, i32 2
  %0 = load i32, ptr %m_size, align 4
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3Int4E10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this1, i32 0, i32 6
  %1 = load i8, ptr %m_ownsMemory, align 8
  %tobool2 = trunc i8 %1 to i1
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this1, i32 0, i32 0
  %m_data4 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this1, i32 0, i32 5
  %2 = load ptr, ptr %m_data4, align 8
  call void @_ZN18b3AlignedAllocatorI6b3Int4Lj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, ptr noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %m_data5 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data5, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI6b3Int4Lj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, ptr noundef %ptr) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @_Z21b3AlignedFreeInternalPv(ptr noundef %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3Int4E7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_Count.addr = alloca i32, align 4
  %s = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %_Count, ptr %_Count.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI6b3Int4E8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %0 = load i32, ptr %_Count.addr, align 4
  %cmp = icmp slt i32 %call, %0
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %_Count.addr, align 4
  %call2 = call noundef ptr @_ZN20b3AlignedObjectArrayI6b3Int4E8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %1)
  store ptr %call2, ptr %s, align 8
  %2 = load ptr, ptr %s, align 8
  %cmp3 = icmp eq ptr %2, null
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then4
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.78, i32 noundef 301)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.79)
  br label %do.end

do.end:                                           ; preds = %do.body
  store i32 0, ptr %_Count.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %do.end, %if.then
  %call5 = call noundef i32 @_ZNK20b3AlignedObjectArrayI6b3Int4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %3 = load ptr, ptr %s, align 8
  call void @_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call5, ptr noundef %3)
  %call6 = call noundef i32 @_ZNK20b3AlignedObjectArrayI6b3Int4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI6b3Int4E7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call6)
  call void @_ZN20b3AlignedObjectArrayI6b3Int4E10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %4 = load ptr, ptr %s, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this1, i32 0, i32 5
  store ptr %4, ptr %m_data, align 8
  %5 = load i32, ptr %_Count.addr, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this1, i32 0, i32 3
  store i32 %5, ptr %m_capacity, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN6b3Int4nwEmPv(i64 noundef %0, ptr noundef %ptr) #3 comdat align 2 {
entry:
  %.addr = alloca i64, align 8
  %ptr.addr = alloca ptr, align 8
  store i64 %0, ptr %.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %1 = load ptr, ptr %ptr.addr, align 8
  ret ptr %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI6b3Int4E8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this1, i32 0, i32 3
  %0 = load i32, ptr %m_capacity, align 8
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN20b3AlignedObjectArrayI6b3Int4E8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %size) #0 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %size.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %size.addr, align 4
  %call = call noundef ptr @_ZN18b3AlignedAllocatorI6b3Int4Lj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, i32 noundef %1, ptr noundef null)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %start, i32 noundef %end, ptr noundef %dest) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %start.addr = alloca i32, align 4
  %end.addr = alloca i32, align 4
  %dest.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %start, ptr %start.addr, align 4
  store i32 %end, ptr %end.addr, align 4
  store ptr %dest, ptr %dest.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %start.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %end.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %dest.addr, align 8
  %4 = load i32, ptr %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds %struct.b3Int4, ptr %3, i64 %idxprom
  %call = call noundef ptr @_ZN6b3Int4nwEmPv(i64 noundef 16, ptr noundef %arrayidx)
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this1, i32 0, i32 5
  %5 = load ptr, ptr %m_data, align 8
  %6 = load i32, ptr %i, align 4
  %idxprom2 = sext i32 %6 to i64
  %arrayidx3 = getelementptr inbounds %struct.b3Int4, ptr %5, i64 %idxprom2
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %call, ptr align 16 %arrayidx3, i64 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i32, ptr %i, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !89

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN18b3AlignedAllocatorI6b3Int4Lj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, i32 noundef %n, ptr noundef %hint) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %hint.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  store ptr %hint, ptr %hint.addr, align 8
  %0 = load i32, ptr %n.addr, align 4
  %conv = sext i32 %0 to i64
  %mul = mul i64 16, %conv
  %call = call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul, i32 noundef 16)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI9b3Vector3Lj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3Vector3E4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this1, i32 0, i32 3
  store i32 0, ptr %m_capacity, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3Vector3E5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI9b3Vector3E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3E7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call)
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3E4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3Vector3E7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %first, i32 noundef %last) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %first.addr = alloca i32, align 4
  %last.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %first, ptr %first.addr, align 4
  store i32 %last, ptr %last.addr, align 4
  %0 = load i32, ptr %first.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %last.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %3 = load i32, ptr %i, align 4
  %inc = add nsw i32 %3, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !90

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this1, i32 0, i32 6
  %1 = load i8, ptr %m_ownsMemory, align 8
  %tobool2 = trunc i8 %1 to i1
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this1, i32 0, i32 0
  %m_data4 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this1, i32 0, i32 5
  %2 = load ptr, ptr %m_data4, align 8
  call void @_ZN18b3AlignedAllocatorI9b3Vector3Lj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, ptr noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %m_data5 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data5, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI9b3Vector3Lj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, ptr noundef %ptr) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @_Z21b3AlignedFreeInternalPv(ptr noundef %0)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorIiLj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayIiE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this1, i32 0, i32 3
  store i32 0, ptr %m_capacity, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayIiE5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayIiE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayIiE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call)
  call void @_ZN20b3AlignedObjectArrayIiE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayIiE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayIiE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %first, i32 noundef %last) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %first.addr = alloca i32, align 4
  %last.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %first, ptr %first.addr, align 4
  store i32 %last, ptr %last.addr, align 4
  %0 = load i32, ptr %first.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %last.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %3 = load i32, ptr %i, align 4
  %inc = add nsw i32 %3, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !91

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayIiE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this1, i32 0, i32 2
  %0 = load i32, ptr %m_size, align 4
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayIiE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this1, i32 0, i32 6
  %1 = load i8, ptr %m_ownsMemory, align 8
  %tobool2 = trunc i8 %1 to i1
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this1, i32 0, i32 0
  %m_data4 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this1, i32 0, i32 5
  %2 = load ptr, ptr %m_data4, align 8
  call void @_ZN18b3AlignedAllocatorIiLj16EE10deallocateEPi(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, ptr noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %m_data5 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data5, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorIiLj16EE10deallocateEPi(ptr noundef nonnull align 1 dereferenceable(1) %this, ptr noundef %ptr) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @_Z21b3AlignedFreeInternalPv(ptr noundef %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3Vector3E7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_Count.addr = alloca i32, align 4
  %s = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %_Count, ptr %_Count.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI9b3Vector3E8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %0 = load i32, ptr %_Count.addr, align 4
  %cmp = icmp slt i32 %call, %0
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %_Count.addr, align 4
  %call2 = call noundef ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %1)
  store ptr %call2, ptr %s, align 8
  %2 = load ptr, ptr %s, align 8
  %cmp3 = icmp eq ptr %2, null
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then4
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.78, i32 noundef 301)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.79)
  br label %do.end

do.end:                                           ; preds = %do.body
  store i32 0, ptr %_Count.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %do.end, %if.then
  %call5 = call noundef i32 @_ZNK20b3AlignedObjectArrayI9b3Vector3E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %3 = load ptr, ptr %s, align 8
  call void @_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call5, ptr noundef %3)
  %call6 = call noundef i32 @_ZNK20b3AlignedObjectArrayI9b3Vector3E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3E7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call6)
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %4 = load ptr, ptr %s, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this1, i32 0, i32 5
  store ptr %4, ptr %m_data, align 8
  %5 = load i32, ptr %_Count.addr, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this1, i32 0, i32 3
  store i32 %5, ptr %m_capacity, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN9b3Vector3nwEmPv(i64 noundef %0, ptr noundef %ptr) #3 comdat align 2 {
entry:
  %.addr = alloca i64, align 8
  %ptr.addr = alloca ptr, align 8
  store i64 %0, ptr %.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %1 = load ptr, ptr %ptr.addr, align 8
  ret ptr %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI9b3Vector3E8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this1, i32 0, i32 3
  %0 = load i32, ptr %m_capacity, align 8
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %size) #0 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %size.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %size.addr, align 4
  %call = call noundef ptr @_ZN18b3AlignedAllocatorI9b3Vector3Lj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, i32 noundef %1, ptr noundef null)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %start, i32 noundef %end, ptr noundef %dest) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %start.addr = alloca i32, align 4
  %end.addr = alloca i32, align 4
  %dest.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %start, ptr %start.addr, align 4
  store i32 %end, ptr %end.addr, align 4
  store ptr %dest, ptr %dest.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %start.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %end.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %dest.addr, align 8
  %4 = load i32, ptr %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds %class.b3Vector3, ptr %3, i64 %idxprom
  %call = call noundef ptr @_ZN9b3Vector3nwEmPv(i64 noundef 16, ptr noundef %arrayidx)
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this1, i32 0, i32 5
  %5 = load ptr, ptr %m_data, align 8
  %6 = load i32, ptr %i, align 4
  %idxprom2 = sext i32 %6 to i64
  %arrayidx3 = getelementptr inbounds %class.b3Vector3, ptr %5, i64 %idxprom2
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %call, ptr align 16 %arrayidx3, i64 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i32, ptr %i, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !92

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN18b3AlignedAllocatorI9b3Vector3Lj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, i32 noundef %n, ptr noundef %hint) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %hint.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  store ptr %hint, ptr %hint.addr, align 8
  %0 = load i32, ptr %n.addr, align 4
  %conv = sext i32 %0 to i64
  %mul = mul i64 16, %conv
  %call = call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul, i32 noundef 16)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayIiE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_Count.addr = alloca i32, align 4
  %s = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %_Count, ptr %_Count.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayIiE8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %0 = load i32, ptr %_Count.addr, align 4
  %cmp = icmp slt i32 %call, %0
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %_Count.addr, align 4
  %call2 = call noundef ptr @_ZN20b3AlignedObjectArrayIiE8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %1)
  store ptr %call2, ptr %s, align 8
  %2 = load ptr, ptr %s, align 8
  %cmp3 = icmp eq ptr %2, null
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then4
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.78, i32 noundef 301)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.79)
  br label %do.end

do.end:                                           ; preds = %do.body
  store i32 0, ptr %_Count.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %do.end, %if.then
  %call5 = call noundef i32 @_ZNK20b3AlignedObjectArrayIiE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %3 = load ptr, ptr %s, align 8
  call void @_ZNK20b3AlignedObjectArrayIiE4copyEiiPi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call5, ptr noundef %3)
  %call6 = call noundef i32 @_ZNK20b3AlignedObjectArrayIiE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayIiE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call6)
  call void @_ZN20b3AlignedObjectArrayIiE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %4 = load ptr, ptr %s, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this1, i32 0, i32 5
  store ptr %4, ptr %m_data, align 8
  %5 = load i32, ptr %_Count.addr, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this1, i32 0, i32 3
  store i32 %5, ptr %m_capacity, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayIiE8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this1, i32 0, i32 3
  %0 = load i32, ptr %m_capacity, align 8
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN20b3AlignedObjectArrayIiE8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %size) #0 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %size.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %size.addr, align 4
  %call = call noundef ptr @_ZN18b3AlignedAllocatorIiLj16EE8allocateEiPPKi(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, i32 noundef %1, ptr noundef null)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZNK20b3AlignedObjectArrayIiE4copyEiiPi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %start, i32 noundef %end, ptr noundef %dest) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %start.addr = alloca i32, align 4
  %end.addr = alloca i32, align 4
  %dest.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %start, ptr %start.addr, align 4
  store i32 %end, ptr %end.addr, align 4
  store ptr %dest, ptr %dest.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %start.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %end.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %dest.addr, align 8
  %4 = load i32, ptr %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds i32, ptr %3, i64 %idxprom
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this1, i32 0, i32 5
  %5 = load ptr, ptr %m_data, align 8
  %6 = load i32, ptr %i, align 4
  %idxprom2 = sext i32 %6 to i64
  %arrayidx3 = getelementptr inbounds i32, ptr %5, i64 %idxprom2
  %7 = load i32, ptr %arrayidx3, align 4
  store i32 %7, ptr %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, ptr %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !93

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN18b3AlignedAllocatorIiLj16EE8allocateEiPPKi(ptr noundef nonnull align 1 dereferenceable(1) %this, i32 noundef %n, ptr noundef %hint) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %hint.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  store ptr %hint, ptr %hint.addr, align 8
  %0 = load i32, ptr %n.addr, align 4
  %conv = sext i32 %0 to i64
  %mul = mul i64 4, %conv
  %call = call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul, i32 noundef 16)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, ptr noundef nonnull align 16 dereferenceable(32) %_Val) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_Val.addr = alloca ptr, align 8
  %sz = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %_Val, ptr %_Val.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  store i32 %call, ptr %sz, align 4
  %0 = load i32, ptr %sz, align 4
  %call2 = call noundef i32 @_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %cmp = icmp eq i32 %0, %call2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call3 = call noundef i32 @_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %call4 = call noundef i32 @_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9allocSizeEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %call3)
  call void @_ZN20b3AlignedObjectArrayI15b3KernelArgDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %call4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.82, ptr %this1, i32 0, i32 5
  %1 = load ptr, ptr %m_data, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.82, ptr %this1, i32 0, i32 2
  %2 = load i32, ptr %m_size, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds %struct.b3KernelArgData, ptr %1, i64 %idxprom
  %3 = load ptr, ptr %_Val.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx, ptr align 16 %3, i64 32, i1 false)
  %m_size5 = getelementptr inbounds %class.b3AlignedObjectArray.82, ptr %this1, i32 0, i32 2
  %4 = load i32, ptr %m_size5, align 4
  %inc = add nsw i32 %4, 1
  store i32 %inc, ptr %m_size5, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.82, ptr %this1, i32 0, i32 2
  %0 = load i32, ptr %m_size, align 4
  ret i32 %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.82, ptr %this1, i32 0, i32 3
  %0 = load i32, ptr %m_capacity, align 8
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI15b3KernelArgDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_Count.addr = alloca i32, align 4
  %s = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %_Count, ptr %_Count.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %0 = load i32, ptr %_Count.addr, align 4
  %cmp = icmp slt i32 %call, %0
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %_Count.addr, align 4
  %call2 = call noundef ptr @_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %1)
  store ptr %call2, ptr %s, align 8
  %2 = load ptr, ptr %s, align 8
  %cmp3 = icmp eq ptr %2, null
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then4
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.78, i32 noundef 301)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.79)
  br label %do.end

do.end:                                           ; preds = %do.body
  store i32 0, ptr %_Count.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.82, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %do.end, %if.then
  %call5 = call noundef i32 @_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %3 = load ptr, ptr %s, align 8
  call void @_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call5, ptr noundef %3)
  %call6 = call noundef i32 @_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI15b3KernelArgDataE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call6)
  call void @_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.82, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %4 = load ptr, ptr %s, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.82, ptr %this1, i32 0, i32 5
  store ptr %4, ptr %m_data, align 8
  %5 = load i32, ptr %_Count.addr, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.82, ptr %this1, i32 0, i32 3
  store i32 %5, ptr %m_capacity, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9allocSizeEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %size) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %0 = load i32, ptr %size.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i32, ptr %size.addr, align 4
  %mul = mul nsw i32 %1, 2
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %mul, %cond.true ], [ 1, %cond.false ]
  ret i32 %cond
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %size) #0 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %size.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.82, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %size.addr, align 4
  %call = call noundef ptr @_ZN18b3AlignedAllocatorI15b3KernelArgDataLj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, i32 noundef %1, ptr noundef null)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %start, i32 noundef %end, ptr noundef %dest) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %start.addr = alloca i32, align 4
  %end.addr = alloca i32, align 4
  %dest.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %start, ptr %start.addr, align 4
  store i32 %end, ptr %end.addr, align 4
  store ptr %dest, ptr %dest.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %start.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %end.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %dest.addr, align 8
  %4 = load i32, ptr %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds %struct.b3KernelArgData, ptr %3, i64 %idxprom
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.82, ptr %this1, i32 0, i32 5
  %5 = load ptr, ptr %m_data, align 8
  %6 = load i32, ptr %i, align 4
  %idxprom2 = sext i32 %6 to i64
  %arrayidx3 = getelementptr inbounds %struct.b3KernelArgData, ptr %5, i64 %idxprom2
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx, ptr align 16 %arrayidx3, i64 32, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i32, ptr %i, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !94

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI15b3KernelArgDataE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %first, i32 noundef %last) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %first.addr = alloca i32, align 4
  %last.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %first, ptr %first.addr, align 4
  store i32 %last, ptr %last.addr, align 4
  %0 = load i32, ptr %first.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %last.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %3 = load i32, ptr %i, align 4
  %inc = add nsw i32 %3, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !95

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.82, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.82, ptr %this1, i32 0, i32 6
  %1 = load i8, ptr %m_ownsMemory, align 8
  %tobool2 = trunc i8 %1 to i1
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.82, ptr %this1, i32 0, i32 0
  %m_data4 = getelementptr inbounds %class.b3AlignedObjectArray.82, ptr %this1, i32 0, i32 5
  %2 = load ptr, ptr %m_data4, align 8
  call void @_ZN18b3AlignedAllocatorI15b3KernelArgDataLj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, ptr noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %m_data5 = getelementptr inbounds %class.b3AlignedObjectArray.82, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data5, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN18b3AlignedAllocatorI15b3KernelArgDataLj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, i32 noundef %n, ptr noundef %hint) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %hint.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  store ptr %hint, ptr %hint.addr, align 8
  %0 = load i32, ptr %n.addr, align 4
  %conv = sext i32 %0 to i64
  %mul = mul i64 32, %conv
  %call = call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul, i32 noundef 16)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI15b3KernelArgDataLj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, ptr noundef %ptr) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @_Z21b3AlignedFreeInternalPv(ptr noundef %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayIiE17copyToHostPointerEPimmb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %destPtr, i64 noundef %numElem, i64 noundef %srcFirstElem, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destPtr.addr = alloca ptr, align 8
  %numElem.addr = alloca i64, align 8
  %srcFirstElem.addr = alloca i64, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %status = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %destPtr, ptr %destPtr.addr, align 8
  store i64 %numElem, ptr %numElem.addr, align 8
  store i64 %srcFirstElem, ptr %srcFirstElem.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %numElem.addr, align 8
  %1 = load i64, ptr %srcFirstElem.addr, align 8
  %add = add i64 %0, %1
  %call = call noundef i64 @_ZNK13b3OpenCLArrayIiE8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %cmp = icmp ule i64 %add, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, ptr %status, align 4
  %2 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 5
  %3 = load ptr, ptr %m_commandQueue, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 3
  %4 = load ptr, ptr %m_clBuffer, align 8
  %5 = load i64, ptr %srcFirstElem.addr, align 8
  %mul = mul i64 4, %5
  %6 = load i64, ptr %numElem.addr, align 8
  %mul2 = mul i64 4, %6
  %7 = load ptr, ptr %destPtr.addr, align 8
  %call3 = call i32 %2(ptr noundef %3, ptr noundef %4, i32 noundef 0, i64 noundef %mul, i64 noundef %mul2, ptr noundef %7, i32 noundef 0, ptr noundef null, ptr noundef null)
  store i32 %call3, ptr %status, align 4
  %8 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool = trunc i8 %8 to i1
  br i1 %tobool, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %9 = load ptr, ptr @__clewFinish, align 8
  %m_commandQueue5 = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this1, i32 0, i32 5
  %10 = load ptr, ptr %m_commandQueue5, align 8
  %call6 = call i32 %9(ptr noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  br label %if.end7

if.else:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.else
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.75, i32 noundef 285)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.80)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %if.end7

if.end7:                                          ; preds = %do.end, %if.end
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayI10b3Contact4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %m_size, align 8
  ret i64 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI6b3Int4E17copyToHostPointerEPS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %destPtr, i64 noundef %numElem, i64 noundef %srcFirstElem, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destPtr.addr = alloca ptr, align 8
  %numElem.addr = alloca i64, align 8
  %srcFirstElem.addr = alloca i64, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %status = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %destPtr, ptr %destPtr.addr, align 8
  store i64 %numElem, ptr %numElem.addr, align 8
  store i64 %srcFirstElem, ptr %srcFirstElem.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %numElem.addr, align 8
  %1 = load i64, ptr %srcFirstElem.addr, align 8
  %add = add i64 %0, %1
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI6b3Int4E8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %cmp = icmp ule i64 %add, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, ptr %status, align 4
  %2 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this1, i32 0, i32 5
  %3 = load ptr, ptr %m_commandQueue, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this1, i32 0, i32 3
  %4 = load ptr, ptr %m_clBuffer, align 8
  %5 = load i64, ptr %srcFirstElem.addr, align 8
  %mul = mul i64 16, %5
  %6 = load i64, ptr %numElem.addr, align 8
  %mul2 = mul i64 16, %6
  %7 = load ptr, ptr %destPtr.addr, align 8
  %call3 = call i32 %2(ptr noundef %3, ptr noundef %4, i32 noundef 0, i64 noundef %mul, i64 noundef %mul2, ptr noundef %7, i32 noundef 0, ptr noundef null, ptr noundef null)
  store i32 %call3, ptr %status, align 4
  %8 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool = trunc i8 %8 to i1
  br i1 %tobool, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %9 = load ptr, ptr @__clewFinish, align 8
  %m_commandQueue5 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this1, i32 0, i32 5
  %10 = load ptr, ptr %m_commandQueue5, align 8
  %call6 = call i32 %9(ptr noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  br label %if.end7

if.else:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.else
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.75, i32 noundef 285)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.80)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %if.end7

if.end7:                                          ; preds = %do.end, %if.end
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayI6b3Int4E8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this1, i32 0, i32 2
  %0 = load i64, ptr %m_capacity, align 8
  ret i64 %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI15b3RigidBodyDataLj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this1, i32 0, i32 3
  store i32 0, ptr %m_capacity, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call)
  call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %first, i32 noundef %last) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %first.addr = alloca i32, align 4
  %last.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %first, ptr %first.addr, align 4
  store i32 %last, ptr %last.addr, align 4
  %0 = load i32, ptr %first.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %last.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %3 = load i32, ptr %i, align 4
  %inc = add nsw i32 %3, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !96

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this1, i32 0, i32 2
  %0 = load i32, ptr %m_size, align 4
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this1, i32 0, i32 6
  %1 = load i8, ptr %m_ownsMemory, align 8
  %tobool2 = trunc i8 %1 to i1
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this1, i32 0, i32 0
  %m_data4 = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this1, i32 0, i32 5
  %2 = load ptr, ptr %m_data4, align 8
  call void @_ZN18b3AlignedAllocatorI15b3RigidBodyDataLj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, ptr noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %m_data5 = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data5, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI15b3RigidBodyDataLj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, ptr noundef %ptr) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @_Z21b3AlignedFreeInternalPv(ptr noundef %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %newsize, ptr noundef nonnull align 16 dereferenceable(80) %fillData) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %newsize.addr = alloca i32, align 4
  %fillData.addr = alloca ptr, align 8
  %curSize = alloca i32, align 4
  %i = alloca i32, align 4
  %i6 = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %newsize, ptr %newsize.addr, align 4
  store ptr %fillData, ptr %fillData.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  store i32 %call, ptr %curSize, align 4
  %0 = load i32, ptr %newsize.addr, align 4
  %1 = load i32, ptr %curSize, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %newsize.addr, align 4
  store i32 %2, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i32, ptr %i, align 4
  %4 = load i32, ptr %curSize, align 4
  %cmp2 = icmp slt i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, ptr %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !97

for.end:                                          ; preds = %for.cond
  br label %if.end16

if.else:                                          ; preds = %entry
  %6 = load i32, ptr %newsize.addr, align 4
  %call3 = call noundef i32 @_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %cmp4 = icmp sgt i32 %6, %call3
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  %7 = load i32, ptr %newsize.addr, align 4
  call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %7)
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.else
  %8 = load i32, ptr %curSize, align 4
  store i32 %8, ptr %i6, align 4
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc13, %if.end
  %9 = load i32, ptr %i6, align 4
  %10 = load i32, ptr %newsize.addr, align 4
  %cmp8 = icmp slt i32 %9, %10
  br i1 %cmp8, label %for.body9, label %for.end15

for.body9:                                        ; preds = %for.cond7
  %m_data10 = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this1, i32 0, i32 5
  %11 = load ptr, ptr %m_data10, align 8
  %12 = load i32, ptr %i6, align 4
  %idxprom11 = sext i32 %12 to i64
  %arrayidx12 = getelementptr inbounds %struct.b3RigidBodyData, ptr %11, i64 %idxprom11
  %13 = load ptr, ptr %fillData.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx12, ptr align 16 %13, i64 80, i1 false)
  br label %for.inc13

for.inc13:                                        ; preds = %for.body9
  %14 = load i32, ptr %i6, align 4
  %inc14 = add nsw i32 %14, 1
  store i32 %inc14, ptr %i6, align 4
  br label %for.cond7, !llvm.loop !98

for.end15:                                        ; preds = %for.cond7
  br label %if.end16

if.end16:                                         ; preds = %for.end15, %for.end
  %15 = load i32, ptr %newsize.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this1, i32 0, i32 2
  store i32 %15, ptr %m_size, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3OpenCLArray.72, ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %m_size, align 8
  ret i64 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN15b3RigidBodyDataC2Ev(ptr noundef nonnull align 16 dereferenceable(80) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_quat = getelementptr inbounds %struct.b3RigidBodyData, ptr %this1, i32 0, i32 1
  call void @_ZN12b3QuaternionC2Ev(ptr noundef nonnull align 16 dereferenceable(16) %m_quat)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE17copyToHostPointerEPS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %destPtr, i64 noundef %numElem, i64 noundef %srcFirstElem, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destPtr.addr = alloca ptr, align 8
  %numElem.addr = alloca i64, align 8
  %srcFirstElem.addr = alloca i64, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %status = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %destPtr, ptr %destPtr.addr, align 8
  store i64 %numElem, ptr %numElem.addr, align 8
  store i64 %srcFirstElem, ptr %srcFirstElem.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %numElem.addr, align 8
  %1 = load i64, ptr %srcFirstElem.addr, align 8
  %add = add i64 %0, %1
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %cmp = icmp ule i64 %add, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, ptr %status, align 4
  %2 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray.72, ptr %this1, i32 0, i32 5
  %3 = load ptr, ptr %m_commandQueue, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.72, ptr %this1, i32 0, i32 3
  %4 = load ptr, ptr %m_clBuffer, align 8
  %5 = load i64, ptr %srcFirstElem.addr, align 8
  %mul = mul i64 80, %5
  %6 = load i64, ptr %numElem.addr, align 8
  %mul2 = mul i64 80, %6
  %7 = load ptr, ptr %destPtr.addr, align 8
  %call3 = call i32 %2(ptr noundef %3, ptr noundef %4, i32 noundef 0, i64 noundef %mul, i64 noundef %mul2, ptr noundef %7, i32 noundef 0, ptr noundef null, ptr noundef null)
  store i32 %call3, ptr %status, align 4
  %8 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool = trunc i8 %8 to i1
  br i1 %tobool, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %9 = load ptr, ptr @__clewFinish, align 8
  %m_commandQueue5 = getelementptr inbounds %class.b3OpenCLArray.72, ptr %this1, i32 0, i32 5
  %10 = load ptr, ptr %m_commandQueue5, align 8
  %call6 = call i32 %9(ptr noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  br label %if.end7

if.else:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.else
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.75, i32 noundef 285)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.80)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %if.end7

if.end7:                                          ; preds = %do.end, %if.end
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_Count.addr = alloca i32, align 4
  %s = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %_Count, ptr %_Count.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataE8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %0 = load i32, ptr %_Count.addr, align 4
  %cmp = icmp slt i32 %call, %0
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %_Count.addr, align 4
  %call2 = call noundef ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %1)
  store ptr %call2, ptr %s, align 8
  %2 = load ptr, ptr %s, align 8
  %cmp3 = icmp eq ptr %2, null
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then4
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.78, i32 noundef 301)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.79)
  br label %do.end

do.end:                                           ; preds = %do.body
  store i32 0, ptr %_Count.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %do.end, %if.then
  %call5 = call noundef i32 @_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %3 = load ptr, ptr %s, align 8
  call void @_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataE4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call5, ptr noundef %3)
  %call6 = call noundef i32 @_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call6)
  call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %4 = load ptr, ptr %s, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this1, i32 0, i32 5
  store ptr %4, ptr %m_data, align 8
  %5 = load i32, ptr %_Count.addr, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this1, i32 0, i32 3
  store i32 %5, ptr %m_capacity, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataE8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this1, i32 0, i32 3
  %0 = load i32, ptr %m_capacity, align 8
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %size) #0 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %size.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %size.addr, align 4
  %call = call noundef ptr @_ZN18b3AlignedAllocatorI15b3RigidBodyDataLj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, i32 noundef %1, ptr noundef null)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataE4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %start, i32 noundef %end, ptr noundef %dest) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %start.addr = alloca i32, align 4
  %end.addr = alloca i32, align 4
  %dest.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %start, ptr %start.addr, align 4
  store i32 %end, ptr %end.addr, align 4
  store ptr %dest, ptr %dest.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %start.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %end.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %dest.addr, align 8
  %4 = load i32, ptr %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds %struct.b3RigidBodyData, ptr %3, i64 %idxprom
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this1, i32 0, i32 5
  %5 = load ptr, ptr %m_data, align 8
  %6 = load i32, ptr %i, align 4
  %idxprom2 = sext i32 %6 to i64
  %arrayidx3 = getelementptr inbounds %struct.b3RigidBodyData, ptr %5, i64 %idxprom2
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx, ptr align 16 %arrayidx3, i64 80, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i32, ptr %i, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !99

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN18b3AlignedAllocatorI15b3RigidBodyDataLj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, i32 noundef %n, ptr noundef %hint) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %hint.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  store ptr %hint, ptr %hint.addr, align 8
  %0 = load i32, ptr %n.addr, align 4
  %conv = sext i32 %0 to i64
  %mul = mul i64 80, %conv
  %call = call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul, i32 noundef 16)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.72, ptr %this1, i32 0, i32 2
  %0 = load i64, ptr %m_capacity, align 8
  ret i64 %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI12b3CollidableLj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI12b3CollidableE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this1, i32 0, i32 3
  store i32 0, ptr %m_capacity, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI12b3CollidableE5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI12b3CollidableE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI12b3CollidableE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call)
  call void @_ZN20b3AlignedObjectArrayI12b3CollidableE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI12b3CollidableE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI12b3CollidableE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %first, i32 noundef %last) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %first.addr = alloca i32, align 4
  %last.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %first, ptr %first.addr, align 4
  store i32 %last, ptr %last.addr, align 4
  %0 = load i32, ptr %first.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %last.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %3 = load i32, ptr %i, align 4
  %inc = add nsw i32 %3, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !100

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI12b3CollidableE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this1, i32 0, i32 2
  %0 = load i32, ptr %m_size, align 4
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI12b3CollidableE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this1, i32 0, i32 6
  %1 = load i8, ptr %m_ownsMemory, align 8
  %tobool2 = trunc i8 %1 to i1
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this1, i32 0, i32 0
  %m_data4 = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this1, i32 0, i32 5
  %2 = load ptr, ptr %m_data4, align 8
  call void @_ZN18b3AlignedAllocatorI12b3CollidableLj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, ptr noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %m_data5 = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data5, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI12b3CollidableLj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, ptr noundef %ptr) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @_Z21b3AlignedFreeInternalPv(ptr noundef %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI12b3CollidableE6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %newsize, ptr noundef nonnull align 4 dereferenceable(16) %fillData) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %newsize.addr = alloca i32, align 4
  %fillData.addr = alloca ptr, align 8
  %curSize = alloca i32, align 4
  %i = alloca i32, align 4
  %i6 = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %newsize, ptr %newsize.addr, align 4
  store ptr %fillData, ptr %fillData.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI12b3CollidableE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  store i32 %call, ptr %curSize, align 4
  %0 = load i32, ptr %newsize.addr, align 4
  %1 = load i32, ptr %curSize, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %newsize.addr, align 4
  store i32 %2, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i32, ptr %i, align 4
  %4 = load i32, ptr %curSize, align 4
  %cmp2 = icmp slt i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, ptr %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !101

for.end:                                          ; preds = %for.cond
  br label %if.end16

if.else:                                          ; preds = %entry
  %6 = load i32, ptr %newsize.addr, align 4
  %call3 = call noundef i32 @_ZNK20b3AlignedObjectArrayI12b3CollidableE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %cmp4 = icmp sgt i32 %6, %call3
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  %7 = load i32, ptr %newsize.addr, align 4
  call void @_ZN20b3AlignedObjectArrayI12b3CollidableE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %7)
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.else
  %8 = load i32, ptr %curSize, align 4
  store i32 %8, ptr %i6, align 4
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc13, %if.end
  %9 = load i32, ptr %i6, align 4
  %10 = load i32, ptr %newsize.addr, align 4
  %cmp8 = icmp slt i32 %9, %10
  br i1 %cmp8, label %for.body9, label %for.end15

for.body9:                                        ; preds = %for.cond7
  %m_data10 = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this1, i32 0, i32 5
  %11 = load ptr, ptr %m_data10, align 8
  %12 = load i32, ptr %i6, align 4
  %idxprom11 = sext i32 %12 to i64
  %arrayidx12 = getelementptr inbounds %struct.b3Collidable, ptr %11, i64 %idxprom11
  %13 = load ptr, ptr %fillData.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx12, ptr align 4 %13, i64 16, i1 false)
  br label %for.inc13

for.inc13:                                        ; preds = %for.body9
  %14 = load i32, ptr %i6, align 4
  %inc14 = add nsw i32 %14, 1
  store i32 %inc14, ptr %i6, align 4
  br label %for.cond7, !llvm.loop !102

for.end15:                                        ; preds = %for.cond7
  br label %if.end16

if.end16:                                         ; preds = %for.end15, %for.end
  %15 = load i32, ptr %newsize.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this1, i32 0, i32 2
  store i32 %15, ptr %m_size, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayI12b3CollidableE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3OpenCLArray.74, ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %m_size, align 8
  ret i64 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI12b3CollidableE17copyToHostPointerEPS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %destPtr, i64 noundef %numElem, i64 noundef %srcFirstElem, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destPtr.addr = alloca ptr, align 8
  %numElem.addr = alloca i64, align 8
  %srcFirstElem.addr = alloca i64, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %status = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %destPtr, ptr %destPtr.addr, align 8
  store i64 %numElem, ptr %numElem.addr, align 8
  store i64 %srcFirstElem, ptr %srcFirstElem.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %numElem.addr, align 8
  %1 = load i64, ptr %srcFirstElem.addr, align 8
  %add = add i64 %0, %1
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI12b3CollidableE8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %cmp = icmp ule i64 %add, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, ptr %status, align 4
  %2 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray.74, ptr %this1, i32 0, i32 5
  %3 = load ptr, ptr %m_commandQueue, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.74, ptr %this1, i32 0, i32 3
  %4 = load ptr, ptr %m_clBuffer, align 8
  %5 = load i64, ptr %srcFirstElem.addr, align 8
  %mul = mul i64 16, %5
  %6 = load i64, ptr %numElem.addr, align 8
  %mul2 = mul i64 16, %6
  %7 = load ptr, ptr %destPtr.addr, align 8
  %call3 = call i32 %2(ptr noundef %3, ptr noundef %4, i32 noundef 0, i64 noundef %mul, i64 noundef %mul2, ptr noundef %7, i32 noundef 0, ptr noundef null, ptr noundef null)
  store i32 %call3, ptr %status, align 4
  %8 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool = trunc i8 %8 to i1
  br i1 %tobool, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %9 = load ptr, ptr @__clewFinish, align 8
  %m_commandQueue5 = getelementptr inbounds %class.b3OpenCLArray.74, ptr %this1, i32 0, i32 5
  %10 = load ptr, ptr %m_commandQueue5, align 8
  %call6 = call i32 %9(ptr noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  br label %if.end7

if.else:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.else
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.75, i32 noundef 285)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.80)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %if.end7

if.end7:                                          ; preds = %do.end, %if.end
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI12b3CollidableE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_Count.addr = alloca i32, align 4
  %s = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %_Count, ptr %_Count.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI12b3CollidableE8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %0 = load i32, ptr %_Count.addr, align 4
  %cmp = icmp slt i32 %call, %0
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %_Count.addr, align 4
  %call2 = call noundef ptr @_ZN20b3AlignedObjectArrayI12b3CollidableE8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %1)
  store ptr %call2, ptr %s, align 8
  %2 = load ptr, ptr %s, align 8
  %cmp3 = icmp eq ptr %2, null
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then4
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.78, i32 noundef 301)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.79)
  br label %do.end

do.end:                                           ; preds = %do.body
  store i32 0, ptr %_Count.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %do.end, %if.then
  %call5 = call noundef i32 @_ZNK20b3AlignedObjectArrayI12b3CollidableE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %3 = load ptr, ptr %s, align 8
  call void @_ZNK20b3AlignedObjectArrayI12b3CollidableE4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call5, ptr noundef %3)
  %call6 = call noundef i32 @_ZNK20b3AlignedObjectArrayI12b3CollidableE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI12b3CollidableE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call6)
  call void @_ZN20b3AlignedObjectArrayI12b3CollidableE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %4 = load ptr, ptr %s, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this1, i32 0, i32 5
  store ptr %4, ptr %m_data, align 8
  %5 = load i32, ptr %_Count.addr, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this1, i32 0, i32 3
  store i32 %5, ptr %m_capacity, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI12b3CollidableE8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this1, i32 0, i32 3
  %0 = load i32, ptr %m_capacity, align 8
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN20b3AlignedObjectArrayI12b3CollidableE8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %size) #0 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %size.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %size.addr, align 4
  %call = call noundef ptr @_ZN18b3AlignedAllocatorI12b3CollidableLj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, i32 noundef %1, ptr noundef null)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZNK20b3AlignedObjectArrayI12b3CollidableE4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %start, i32 noundef %end, ptr noundef %dest) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %start.addr = alloca i32, align 4
  %end.addr = alloca i32, align 4
  %dest.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %start, ptr %start.addr, align 4
  store i32 %end, ptr %end.addr, align 4
  store ptr %dest, ptr %dest.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %start.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %end.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %dest.addr, align 8
  %4 = load i32, ptr %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds %struct.b3Collidable, ptr %3, i64 %idxprom
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this1, i32 0, i32 5
  %5 = load ptr, ptr %m_data, align 8
  %6 = load i32, ptr %i, align 4
  %idxprom2 = sext i32 %6 to i64
  %arrayidx3 = getelementptr inbounds %struct.b3Collidable, ptr %5, i64 %idxprom2
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx, ptr align 4 %arrayidx3, i64 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i32, ptr %i, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !103

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN18b3AlignedAllocatorI12b3CollidableLj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, i32 noundef %n, ptr noundef %hint) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %hint.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  store ptr %hint, ptr %hint.addr, align 8
  %0 = load i32, ptr %n.addr, align 4
  %conv = sext i32 %0 to i64
  %mul = mul i64 16, %conv
  %call = call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul, i32 noundef 16)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayI12b3CollidableE8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.74, ptr %this1, i32 0, i32 2
  %0 = load i64, ptr %m_capacity, align 8
  ret i64 %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI15b3GpuChildShapeLj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this1, i32 0, i32 3
  store i32 0, ptr %m_capacity, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI15b3GpuChildShapeE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call)
  call void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %first, i32 noundef %last) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %first.addr = alloca i32, align 4
  %last.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %first, ptr %first.addr, align 4
  store i32 %last, ptr %last.addr, align 4
  %0 = load i32, ptr %first.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %last.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %3 = load i32, ptr %i, align 4
  %inc = add nsw i32 %3, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !104

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this1, i32 0, i32 6
  %1 = load i8, ptr %m_ownsMemory, align 8
  %tobool2 = trunc i8 %1 to i1
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this1, i32 0, i32 0
  %m_data4 = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this1, i32 0, i32 5
  %2 = load ptr, ptr %m_data4, align 8
  call void @_ZN18b3AlignedAllocatorI15b3GpuChildShapeLj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, ptr noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %m_data5 = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data5, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI15b3GpuChildShapeLj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, ptr noundef %ptr) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @_Z21b3AlignedFreeInternalPv(ptr noundef %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %newsize, ptr noundef nonnull align 16 dereferenceable(48) %fillData) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %newsize.addr = alloca i32, align 4
  %fillData.addr = alloca ptr, align 8
  %curSize = alloca i32, align 4
  %i = alloca i32, align 4
  %i6 = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %newsize, ptr %newsize.addr, align 4
  store ptr %fillData, ptr %fillData.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI15b3GpuChildShapeE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  store i32 %call, ptr %curSize, align 4
  %0 = load i32, ptr %newsize.addr, align 4
  %1 = load i32, ptr %curSize, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %newsize.addr, align 4
  store i32 %2, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i32, ptr %i, align 4
  %4 = load i32, ptr %curSize, align 4
  %cmp2 = icmp slt i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, ptr %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !105

for.end:                                          ; preds = %for.cond
  br label %if.end16

if.else:                                          ; preds = %entry
  %6 = load i32, ptr %newsize.addr, align 4
  %call3 = call noundef i32 @_ZNK20b3AlignedObjectArrayI15b3GpuChildShapeE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %cmp4 = icmp sgt i32 %6, %call3
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  %7 = load i32, ptr %newsize.addr, align 4
  call void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %7)
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.else
  %8 = load i32, ptr %curSize, align 4
  store i32 %8, ptr %i6, align 4
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc13, %if.end
  %9 = load i32, ptr %i6, align 4
  %10 = load i32, ptr %newsize.addr, align 4
  %cmp8 = icmp slt i32 %9, %10
  br i1 %cmp8, label %for.body9, label %for.end15

for.body9:                                        ; preds = %for.cond7
  %m_data10 = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this1, i32 0, i32 5
  %11 = load ptr, ptr %m_data10, align 8
  %12 = load i32, ptr %i6, align 4
  %idxprom11 = sext i32 %12 to i64
  %arrayidx12 = getelementptr inbounds %struct.b3GpuChildShape, ptr %11, i64 %idxprom11
  %13 = load ptr, ptr %fillData.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx12, ptr align 16 %13, i64 48, i1 false)
  br label %for.inc13

for.inc13:                                        ; preds = %for.body9
  %14 = load i32, ptr %i6, align 4
  %inc14 = add nsw i32 %14, 1
  store i32 %inc14, ptr %i6, align 4
  br label %for.cond7, !llvm.loop !106

for.end15:                                        ; preds = %for.cond7
  br label %if.end16

if.end16:                                         ; preds = %for.end15, %for.end
  %15 = load i32, ptr %newsize.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this1, i32 0, i32 2
  store i32 %15, ptr %m_size, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayI15b3GpuChildShapeE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3OpenCLArray.96, ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %m_size, align 8
  ret i64 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN15b3GpuChildShapeC2Ev(ptr noundef nonnull align 16 dereferenceable(48) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_childOrientation = getelementptr inbounds %struct.b3GpuChildShape, ptr %this1, i32 0, i32 1
  call void @_ZN12b3QuaternionC2Ev(ptr noundef nonnull align 16 dereferenceable(16) %m_childOrientation)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI15b3GpuChildShapeE17copyToHostPointerEPS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %destPtr, i64 noundef %numElem, i64 noundef %srcFirstElem, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destPtr.addr = alloca ptr, align 8
  %numElem.addr = alloca i64, align 8
  %srcFirstElem.addr = alloca i64, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %status = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %destPtr, ptr %destPtr.addr, align 8
  store i64 %numElem, ptr %numElem.addr, align 8
  store i64 %srcFirstElem, ptr %srcFirstElem.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %numElem.addr, align 8
  %1 = load i64, ptr %srcFirstElem.addr, align 8
  %add = add i64 %0, %1
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI15b3GpuChildShapeE8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %cmp = icmp ule i64 %add, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, ptr %status, align 4
  %2 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray.96, ptr %this1, i32 0, i32 5
  %3 = load ptr, ptr %m_commandQueue, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.96, ptr %this1, i32 0, i32 3
  %4 = load ptr, ptr %m_clBuffer, align 8
  %5 = load i64, ptr %srcFirstElem.addr, align 8
  %mul = mul i64 48, %5
  %6 = load i64, ptr %numElem.addr, align 8
  %mul2 = mul i64 48, %6
  %7 = load ptr, ptr %destPtr.addr, align 8
  %call3 = call i32 %2(ptr noundef %3, ptr noundef %4, i32 noundef 0, i64 noundef %mul, i64 noundef %mul2, ptr noundef %7, i32 noundef 0, ptr noundef null, ptr noundef null)
  store i32 %call3, ptr %status, align 4
  %8 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool = trunc i8 %8 to i1
  br i1 %tobool, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %9 = load ptr, ptr @__clewFinish, align 8
  %m_commandQueue5 = getelementptr inbounds %class.b3OpenCLArray.96, ptr %this1, i32 0, i32 5
  %10 = load ptr, ptr %m_commandQueue5, align 8
  %call6 = call i32 %9(ptr noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  br label %if.end7

if.else:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.else
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.75, i32 noundef 285)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.80)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %if.end7

if.end7:                                          ; preds = %do.end, %if.end
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_Count.addr = alloca i32, align 4
  %s = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %_Count, ptr %_Count.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI15b3GpuChildShapeE8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %0 = load i32, ptr %_Count.addr, align 4
  %cmp = icmp slt i32 %call, %0
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %_Count.addr, align 4
  %call2 = call noundef ptr @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %1)
  store ptr %call2, ptr %s, align 8
  %2 = load ptr, ptr %s, align 8
  %cmp3 = icmp eq ptr %2, null
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then4
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.78, i32 noundef 301)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.79)
  br label %do.end

do.end:                                           ; preds = %do.body
  store i32 0, ptr %_Count.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %do.end, %if.then
  %call5 = call noundef i32 @_ZNK20b3AlignedObjectArrayI15b3GpuChildShapeE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %3 = load ptr, ptr %s, align 8
  call void @_ZNK20b3AlignedObjectArrayI15b3GpuChildShapeE4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call5, ptr noundef %3)
  %call6 = call noundef i32 @_ZNK20b3AlignedObjectArrayI15b3GpuChildShapeE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call6)
  call void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %4 = load ptr, ptr %s, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this1, i32 0, i32 5
  store ptr %4, ptr %m_data, align 8
  %5 = load i32, ptr %_Count.addr, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this1, i32 0, i32 3
  store i32 %5, ptr %m_capacity, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI15b3GpuChildShapeE8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this1, i32 0, i32 3
  %0 = load i32, ptr %m_capacity, align 8
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %size) #0 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %size.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %size.addr, align 4
  %call = call noundef ptr @_ZN18b3AlignedAllocatorI15b3GpuChildShapeLj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, i32 noundef %1, ptr noundef null)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZNK20b3AlignedObjectArrayI15b3GpuChildShapeE4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %start, i32 noundef %end, ptr noundef %dest) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %start.addr = alloca i32, align 4
  %end.addr = alloca i32, align 4
  %dest.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %start, ptr %start.addr, align 4
  store i32 %end, ptr %end.addr, align 4
  store ptr %dest, ptr %dest.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %start.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %end.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %dest.addr, align 8
  %4 = load i32, ptr %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds %struct.b3GpuChildShape, ptr %3, i64 %idxprom
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this1, i32 0, i32 5
  %5 = load ptr, ptr %m_data, align 8
  %6 = load i32, ptr %i, align 4
  %idxprom2 = sext i32 %6 to i64
  %arrayidx3 = getelementptr inbounds %struct.b3GpuChildShape, ptr %5, i64 %idxprom2
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx, ptr align 16 %arrayidx3, i64 48, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i32, ptr %i, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !107

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN18b3AlignedAllocatorI15b3GpuChildShapeLj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, i32 noundef %n, ptr noundef %hint) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %hint.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  store ptr %hint, ptr %hint.addr, align 8
  %0 = load i32, ptr %n.addr, align 4
  %conv = sext i32 %0 to i64
  %mul = mul i64 48, %conv
  %call = call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul, i32 noundef 16)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayI15b3GpuChildShapeE8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.96, ptr %this1, i32 0, i32 2
  %0 = load i64, ptr %m_capacity, align 8
  ret i64 %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI22b3ConvexPolyhedronDataLj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this1, i32 0, i32 3
  store i32 0, ptr %m_capacity, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call)
  call void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %first, i32 noundef %last) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %first.addr = alloca i32, align 4
  %last.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %first, ptr %first.addr, align 4
  store i32 %last, ptr %last.addr, align 4
  %0 = load i32, ptr %first.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %last.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %3 = load i32, ptr %i, align 4
  %inc = add nsw i32 %3, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !108

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this1, i32 0, i32 2
  %0 = load i32, ptr %m_size, align 4
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this1, i32 0, i32 6
  %1 = load i8, ptr %m_ownsMemory, align 8
  %tobool2 = trunc i8 %1 to i1
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this1, i32 0, i32 0
  %m_data4 = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this1, i32 0, i32 5
  %2 = load ptr, ptr %m_data4, align 8
  call void @_ZN18b3AlignedAllocatorI22b3ConvexPolyhedronDataLj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, ptr noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %m_data5 = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data5, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI22b3ConvexPolyhedronDataLj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, ptr noundef %ptr) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @_Z21b3AlignedFreeInternalPv(ptr noundef %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %newsize, ptr noundef nonnull align 16 dereferenceable(96) %fillData) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %newsize.addr = alloca i32, align 4
  %fillData.addr = alloca ptr, align 8
  %curSize = alloca i32, align 4
  %i = alloca i32, align 4
  %i6 = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %newsize, ptr %newsize.addr, align 4
  store ptr %fillData, ptr %fillData.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  store i32 %call, ptr %curSize, align 4
  %0 = load i32, ptr %newsize.addr, align 4
  %1 = load i32, ptr %curSize, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %newsize.addr, align 4
  store i32 %2, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i32, ptr %i, align 4
  %4 = load i32, ptr %curSize, align 4
  %cmp2 = icmp slt i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, ptr %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !109

for.end:                                          ; preds = %for.cond
  br label %if.end16

if.else:                                          ; preds = %entry
  %6 = load i32, ptr %newsize.addr, align 4
  %call3 = call noundef i32 @_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %cmp4 = icmp sgt i32 %6, %call3
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  %7 = load i32, ptr %newsize.addr, align 4
  call void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %7)
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.else
  %8 = load i32, ptr %curSize, align 4
  store i32 %8, ptr %i6, align 4
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc13, %if.end
  %9 = load i32, ptr %i6, align 4
  %10 = load i32, ptr %newsize.addr, align 4
  %cmp8 = icmp slt i32 %9, %10
  br i1 %cmp8, label %for.body9, label %for.end15

for.body9:                                        ; preds = %for.cond7
  %m_data10 = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this1, i32 0, i32 5
  %11 = load ptr, ptr %m_data10, align 8
  %12 = load i32, ptr %i6, align 4
  %idxprom11 = sext i32 %12 to i64
  %arrayidx12 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %11, i64 %idxprom11
  %13 = load ptr, ptr %fillData.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx12, ptr align 16 %13, i64 96, i1 false)
  br label %for.inc13

for.inc13:                                        ; preds = %for.body9
  %14 = load i32, ptr %i6, align 4
  %inc14 = add nsw i32 %14, 1
  store i32 %inc14, ptr %i6, align 4
  br label %for.cond7, !llvm.loop !110

for.end15:                                        ; preds = %for.cond7
  br label %if.end16

if.end16:                                         ; preds = %for.end15, %for.end
  %15 = load i32, ptr %newsize.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this1, i32 0, i32 2
  store i32 %15, ptr %m_size, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3OpenCLArray.76, ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %m_size, align 8
  ret i64 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE17copyToHostPointerEPS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %destPtr, i64 noundef %numElem, i64 noundef %srcFirstElem, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destPtr.addr = alloca ptr, align 8
  %numElem.addr = alloca i64, align 8
  %srcFirstElem.addr = alloca i64, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %status = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %destPtr, ptr %destPtr.addr, align 8
  store i64 %numElem, ptr %numElem.addr, align 8
  store i64 %srcFirstElem, ptr %srcFirstElem.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %numElem.addr, align 8
  %1 = load i64, ptr %srcFirstElem.addr, align 8
  %add = add i64 %0, %1
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %cmp = icmp ule i64 %add, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, ptr %status, align 4
  %2 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray.76, ptr %this1, i32 0, i32 5
  %3 = load ptr, ptr %m_commandQueue, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.76, ptr %this1, i32 0, i32 3
  %4 = load ptr, ptr %m_clBuffer, align 8
  %5 = load i64, ptr %srcFirstElem.addr, align 8
  %mul = mul i64 96, %5
  %6 = load i64, ptr %numElem.addr, align 8
  %mul2 = mul i64 96, %6
  %7 = load ptr, ptr %destPtr.addr, align 8
  %call3 = call i32 %2(ptr noundef %3, ptr noundef %4, i32 noundef 0, i64 noundef %mul, i64 noundef %mul2, ptr noundef %7, i32 noundef 0, ptr noundef null, ptr noundef null)
  store i32 %call3, ptr %status, align 4
  %8 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool = trunc i8 %8 to i1
  br i1 %tobool, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %9 = load ptr, ptr @__clewFinish, align 8
  %m_commandQueue5 = getelementptr inbounds %class.b3OpenCLArray.76, ptr %this1, i32 0, i32 5
  %10 = load ptr, ptr %m_commandQueue5, align 8
  %call6 = call i32 %9(ptr noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  br label %if.end7

if.else:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.else
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.75, i32 noundef 285)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.80)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %if.end7

if.end7:                                          ; preds = %do.end, %if.end
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_Count.addr = alloca i32, align 4
  %s = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %_Count, ptr %_Count.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %0 = load i32, ptr %_Count.addr, align 4
  %cmp = icmp slt i32 %call, %0
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %_Count.addr, align 4
  %call2 = call noundef ptr @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %1)
  store ptr %call2, ptr %s, align 8
  %2 = load ptr, ptr %s, align 8
  %cmp3 = icmp eq ptr %2, null
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then4
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.78, i32 noundef 301)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.79)
  br label %do.end

do.end:                                           ; preds = %do.body
  store i32 0, ptr %_Count.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %do.end, %if.then
  %call5 = call noundef i32 @_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %3 = load ptr, ptr %s, align 8
  call void @_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call5, ptr noundef %3)
  %call6 = call noundef i32 @_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call6)
  call void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %4 = load ptr, ptr %s, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this1, i32 0, i32 5
  store ptr %4, ptr %m_data, align 8
  %5 = load i32, ptr %_Count.addr, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this1, i32 0, i32 3
  store i32 %5, ptr %m_capacity, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this1, i32 0, i32 3
  %0 = load i32, ptr %m_capacity, align 8
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %size) #0 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %size.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %size.addr, align 4
  %call = call noundef ptr @_ZN18b3AlignedAllocatorI22b3ConvexPolyhedronDataLj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, i32 noundef %1, ptr noundef null)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %start, i32 noundef %end, ptr noundef %dest) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %start.addr = alloca i32, align 4
  %end.addr = alloca i32, align 4
  %dest.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %start, ptr %start.addr, align 4
  store i32 %end, ptr %end.addr, align 4
  store ptr %dest, ptr %dest.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %start.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %end.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %dest.addr, align 8
  %4 = load i32, ptr %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %3, i64 %idxprom
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this1, i32 0, i32 5
  %5 = load ptr, ptr %m_data, align 8
  %6 = load i32, ptr %i, align 4
  %idxprom2 = sext i32 %6 to i64
  %arrayidx3 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %5, i64 %idxprom2
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx, ptr align 16 %arrayidx3, i64 96, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i32, ptr %i, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !111

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN18b3AlignedAllocatorI22b3ConvexPolyhedronDataLj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, i32 noundef %n, ptr noundef %hint) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %hint.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  store ptr %hint, ptr %hint.addr, align 8
  %0 = load i32, ptr %n.addr, align 4
  %conv = sext i32 %0 to i64
  %mul = mul i64 96, %conv
  %call = call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul, i32 noundef 16)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.76, ptr %this1, i32 0, i32 2
  %0 = load i64, ptr %m_capacity, align 8
  ret i64 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI9b3Vector3E17copyToHostPointerEPS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %destPtr, i64 noundef %numElem, i64 noundef %srcFirstElem, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destPtr.addr = alloca ptr, align 8
  %numElem.addr = alloca i64, align 8
  %srcFirstElem.addr = alloca i64, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %status = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %destPtr, ptr %destPtr.addr, align 8
  store i64 %numElem, ptr %numElem.addr, align 8
  store i64 %srcFirstElem, ptr %srcFirstElem.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %numElem.addr, align 8
  %1 = load i64, ptr %srcFirstElem.addr, align 8
  %add = add i64 %0, %1
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI9b3Vector3E8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %cmp = icmp ule i64 %add, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, ptr %status, align 4
  %2 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 5
  %3 = load ptr, ptr %m_commandQueue, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 3
  %4 = load ptr, ptr %m_clBuffer, align 8
  %5 = load i64, ptr %srcFirstElem.addr, align 8
  %mul = mul i64 16, %5
  %6 = load i64, ptr %numElem.addr, align 8
  %mul2 = mul i64 16, %6
  %7 = load ptr, ptr %destPtr.addr, align 8
  %call3 = call i32 %2(ptr noundef %3, ptr noundef %4, i32 noundef 0, i64 noundef %mul, i64 noundef %mul2, ptr noundef %7, i32 noundef 0, ptr noundef null, ptr noundef null)
  store i32 %call3, ptr %status, align 4
  %8 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool = trunc i8 %8 to i1
  br i1 %tobool, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %9 = load ptr, ptr @__clewFinish, align 8
  %m_commandQueue5 = getelementptr inbounds %class.b3OpenCLArray, ptr %this1, i32 0, i32 5
  %10 = load ptr, ptr %m_commandQueue5, align 8
  %call6 = call i32 %9(ptr noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  br label %if.end7

if.else:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.else
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.75, i32 noundef 285)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.80)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %if.end7

if.end7:                                          ; preds = %do.end, %if.end
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI9b3GpuFaceLj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3GpuFaceE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this1, i32 0, i32 3
  store i32 0, ptr %m_capacity, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3GpuFaceE5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI9b3GpuFaceE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI9b3GpuFaceE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call)
  call void @_ZN20b3AlignedObjectArrayI9b3GpuFaceE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI9b3GpuFaceE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3GpuFaceE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %first, i32 noundef %last) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %first.addr = alloca i32, align 4
  %last.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %first, ptr %first.addr, align 4
  store i32 %last, ptr %last.addr, align 4
  %0 = load i32, ptr %first.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %last.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %3 = load i32, ptr %i, align 4
  %inc = add nsw i32 %3, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !112

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI9b3GpuFaceE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this1, i32 0, i32 2
  %0 = load i32, ptr %m_size, align 4
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3GpuFaceE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this1, i32 0, i32 6
  %1 = load i8, ptr %m_ownsMemory, align 8
  %tobool2 = trunc i8 %1 to i1
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this1, i32 0, i32 0
  %m_data4 = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this1, i32 0, i32 5
  %2 = load ptr, ptr %m_data4, align 8
  call void @_ZN18b3AlignedAllocatorI9b3GpuFaceLj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, ptr noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %m_data5 = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data5, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI9b3GpuFaceLj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, ptr noundef %ptr) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @_Z21b3AlignedFreeInternalPv(ptr noundef %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3GpuFaceE6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %newsize, ptr noundef nonnull align 16 dereferenceable(32) %fillData) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %newsize.addr = alloca i32, align 4
  %fillData.addr = alloca ptr, align 8
  %curSize = alloca i32, align 4
  %i = alloca i32, align 4
  %i6 = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %newsize, ptr %newsize.addr, align 4
  store ptr %fillData, ptr %fillData.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI9b3GpuFaceE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  store i32 %call, ptr %curSize, align 4
  %0 = load i32, ptr %newsize.addr, align 4
  %1 = load i32, ptr %curSize, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %newsize.addr, align 4
  store i32 %2, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i32, ptr %i, align 4
  %4 = load i32, ptr %curSize, align 4
  %cmp2 = icmp slt i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, ptr %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !113

for.end:                                          ; preds = %for.cond
  br label %if.end16

if.else:                                          ; preds = %entry
  %6 = load i32, ptr %newsize.addr, align 4
  %call3 = call noundef i32 @_ZNK20b3AlignedObjectArrayI9b3GpuFaceE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %cmp4 = icmp sgt i32 %6, %call3
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  %7 = load i32, ptr %newsize.addr, align 4
  call void @_ZN20b3AlignedObjectArrayI9b3GpuFaceE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %7)
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.else
  %8 = load i32, ptr %curSize, align 4
  store i32 %8, ptr %i6, align 4
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc13, %if.end
  %9 = load i32, ptr %i6, align 4
  %10 = load i32, ptr %newsize.addr, align 4
  %cmp8 = icmp slt i32 %9, %10
  br i1 %cmp8, label %for.body9, label %for.end15

for.body9:                                        ; preds = %for.cond7
  %m_data10 = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this1, i32 0, i32 5
  %11 = load ptr, ptr %m_data10, align 8
  %12 = load i32, ptr %i6, align 4
  %idxprom11 = sext i32 %12 to i64
  %arrayidx12 = getelementptr inbounds %struct.b3GpuFace, ptr %11, i64 %idxprom11
  %13 = load ptr, ptr %fillData.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx12, ptr align 16 %13, i64 32, i1 false)
  br label %for.inc13

for.inc13:                                        ; preds = %for.body9
  %14 = load i32, ptr %i6, align 4
  %inc14 = add nsw i32 %14, 1
  store i32 %inc14, ptr %i6, align 4
  br label %for.cond7, !llvm.loop !114

for.end15:                                        ; preds = %for.cond7
  br label %if.end16

if.end16:                                         ; preds = %for.end15, %for.end
  %15 = load i32, ptr %newsize.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this1, i32 0, i32 2
  store i32 %15, ptr %m_size, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayI9b3GpuFaceE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3OpenCLArray.78, ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %m_size, align 8
  ret i64 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI9b3GpuFaceE17copyToHostPointerEPS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %destPtr, i64 noundef %numElem, i64 noundef %srcFirstElem, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destPtr.addr = alloca ptr, align 8
  %numElem.addr = alloca i64, align 8
  %srcFirstElem.addr = alloca i64, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %status = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %destPtr, ptr %destPtr.addr, align 8
  store i64 %numElem, ptr %numElem.addr, align 8
  store i64 %srcFirstElem, ptr %srcFirstElem.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %numElem.addr, align 8
  %1 = load i64, ptr %srcFirstElem.addr, align 8
  %add = add i64 %0, %1
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI9b3GpuFaceE8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %cmp = icmp ule i64 %add, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, ptr %status, align 4
  %2 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray.78, ptr %this1, i32 0, i32 5
  %3 = load ptr, ptr %m_commandQueue, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.78, ptr %this1, i32 0, i32 3
  %4 = load ptr, ptr %m_clBuffer, align 8
  %5 = load i64, ptr %srcFirstElem.addr, align 8
  %mul = mul i64 32, %5
  %6 = load i64, ptr %numElem.addr, align 8
  %mul2 = mul i64 32, %6
  %7 = load ptr, ptr %destPtr.addr, align 8
  %call3 = call i32 %2(ptr noundef %3, ptr noundef %4, i32 noundef 0, i64 noundef %mul, i64 noundef %mul2, ptr noundef %7, i32 noundef 0, ptr noundef null, ptr noundef null)
  store i32 %call3, ptr %status, align 4
  %8 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool = trunc i8 %8 to i1
  br i1 %tobool, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %9 = load ptr, ptr @__clewFinish, align 8
  %m_commandQueue5 = getelementptr inbounds %class.b3OpenCLArray.78, ptr %this1, i32 0, i32 5
  %10 = load ptr, ptr %m_commandQueue5, align 8
  %call6 = call i32 %9(ptr noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  br label %if.end7

if.else:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.else
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.75, i32 noundef 285)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.80)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %if.end7

if.end7:                                          ; preds = %do.end, %if.end
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI9b3GpuFaceEixEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3GpuFace, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3GpuFaceE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_Count.addr = alloca i32, align 4
  %s = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %_Count, ptr %_Count.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI9b3GpuFaceE8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %0 = load i32, ptr %_Count.addr, align 4
  %cmp = icmp slt i32 %call, %0
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %_Count.addr, align 4
  %call2 = call noundef ptr @_ZN20b3AlignedObjectArrayI9b3GpuFaceE8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %1)
  store ptr %call2, ptr %s, align 8
  %2 = load ptr, ptr %s, align 8
  %cmp3 = icmp eq ptr %2, null
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then4
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.78, i32 noundef 301)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.79)
  br label %do.end

do.end:                                           ; preds = %do.body
  store i32 0, ptr %_Count.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %do.end, %if.then
  %call5 = call noundef i32 @_ZNK20b3AlignedObjectArrayI9b3GpuFaceE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %3 = load ptr, ptr %s, align 8
  call void @_ZNK20b3AlignedObjectArrayI9b3GpuFaceE4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call5, ptr noundef %3)
  %call6 = call noundef i32 @_ZNK20b3AlignedObjectArrayI9b3GpuFaceE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI9b3GpuFaceE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call6)
  call void @_ZN20b3AlignedObjectArrayI9b3GpuFaceE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %4 = load ptr, ptr %s, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this1, i32 0, i32 5
  store ptr %4, ptr %m_data, align 8
  %5 = load i32, ptr %_Count.addr, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this1, i32 0, i32 3
  store i32 %5, ptr %m_capacity, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI9b3GpuFaceE8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this1, i32 0, i32 3
  %0 = load i32, ptr %m_capacity, align 8
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN20b3AlignedObjectArrayI9b3GpuFaceE8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %size) #0 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %size.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %size.addr, align 4
  %call = call noundef ptr @_ZN18b3AlignedAllocatorI9b3GpuFaceLj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, i32 noundef %1, ptr noundef null)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZNK20b3AlignedObjectArrayI9b3GpuFaceE4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %start, i32 noundef %end, ptr noundef %dest) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %start.addr = alloca i32, align 4
  %end.addr = alloca i32, align 4
  %dest.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %start, ptr %start.addr, align 4
  store i32 %end, ptr %end.addr, align 4
  store ptr %dest, ptr %dest.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %start.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %end.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %dest.addr, align 8
  %4 = load i32, ptr %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds %struct.b3GpuFace, ptr %3, i64 %idxprom
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this1, i32 0, i32 5
  %5 = load ptr, ptr %m_data, align 8
  %6 = load i32, ptr %i, align 4
  %idxprom2 = sext i32 %6 to i64
  %arrayidx3 = getelementptr inbounds %struct.b3GpuFace, ptr %5, i64 %idxprom2
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx, ptr align 16 %arrayidx3, i64 32, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i32, ptr %i, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !115

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN18b3AlignedAllocatorI9b3GpuFaceLj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, i32 noundef %n, ptr noundef %hint) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %hint.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  store ptr %hint, ptr %hint.addr, align 8
  %0 = load i32, ptr %n.addr, align 4
  %conv = sext i32 %0 to i64
  %mul = mul i64 32, %conv
  %call = call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul, i32 noundef 16)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayI9b3GpuFaceE8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.78, ptr %this1, i32 0, i32 2
  %0 = load i64, ptr %m_capacity, align 8
  ret i64 %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI10b3Contact4Lj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI10b3Contact4E4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this1, i32 0, i32 3
  store i32 0, ptr %m_capacity, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI10b3Contact4E5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI10b3Contact4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI10b3Contact4E7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call)
  call void @_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI10b3Contact4E4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI10b3Contact4E17copyToHostPointerEPS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %destPtr, i64 noundef %numElem, i64 noundef %srcFirstElem, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destPtr.addr = alloca ptr, align 8
  %numElem.addr = alloca i64, align 8
  %srcFirstElem.addr = alloca i64, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %status = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %destPtr, ptr %destPtr.addr, align 8
  store i64 %numElem, ptr %numElem.addr, align 8
  store i64 %srcFirstElem, ptr %srcFirstElem.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %numElem.addr, align 8
  %1 = load i64, ptr %srcFirstElem.addr, align 8
  %add = add i64 %0, %1
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI10b3Contact4E8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %cmp = icmp ule i64 %add, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, ptr %status, align 4
  %2 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this1, i32 0, i32 5
  %3 = load ptr, ptr %m_commandQueue, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this1, i32 0, i32 3
  %4 = load ptr, ptr %m_clBuffer, align 8
  %5 = load i64, ptr %srcFirstElem.addr, align 8
  %mul = mul i64 112, %5
  %6 = load i64, ptr %numElem.addr, align 8
  %mul2 = mul i64 112, %6
  %7 = load ptr, ptr %destPtr.addr, align 8
  %call3 = call i32 %2(ptr noundef %3, ptr noundef %4, i32 noundef 0, i64 noundef %mul, i64 noundef %mul2, ptr noundef %7, i32 noundef 0, ptr noundef null, ptr noundef null)
  store i32 %call3, ptr %status, align 4
  %8 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool = trunc i8 %8 to i1
  br i1 %tobool, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %9 = load ptr, ptr @__clewFinish, align 8
  %m_commandQueue5 = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this1, i32 0, i32 5
  %10 = load ptr, ptr %m_commandQueue5, align 8
  %call6 = call i32 %9(ptr noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  br label %if.end7

if.else:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.else
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.75, i32 noundef 285)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.80)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %if.end7

if.end7:                                          ; preds = %do.end, %if.end
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(112) ptr @_ZN20b3AlignedObjectArrayI10b3Contact4EixEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3Contact4, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayI10b3Contact4E19copyFromHostPointerEPKS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %src, i64 noundef %numElems, i64 noundef %destFirstElem, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %src.addr = alloca ptr, align 8
  %numElems.addr = alloca i64, align 8
  %destFirstElem.addr = alloca i64, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %status = alloca i32, align 4
  %sizeInBytes = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %src, ptr %src.addr, align 8
  store i64 %numElems, ptr %numElems.addr, align 8
  store i64 %destFirstElem, ptr %destFirstElem.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %numElems.addr, align 8
  %1 = load i64, ptr %destFirstElem.addr, align 8
  %add = add i64 %0, %1
  %tobool = icmp ne i64 %add, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, ptr %status, align 4
  %2 = load i64, ptr %numElems.addr, align 8
  %mul = mul i64 112, %2
  store i64 %mul, ptr %sizeInBytes, align 8
  %3 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this1, i32 0, i32 5
  %4 = load ptr, ptr %m_commandQueue, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this1, i32 0, i32 3
  %5 = load ptr, ptr %m_clBuffer, align 8
  %6 = load i64, ptr %destFirstElem.addr, align 8
  %mul2 = mul i64 112, %6
  %7 = load i64, ptr %sizeInBytes, align 8
  %8 = load ptr, ptr %src.addr, align 8
  %call = call i32 %3(ptr noundef %4, ptr noundef %5, i32 noundef 0, i64 noundef %mul2, i64 noundef %7, ptr noundef %8, i32 noundef 0, ptr noundef null, ptr noundef null)
  store i32 %call, ptr %status, align 4
  %9 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool3 = trunc i8 %9 to i1
  br i1 %tobool3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %10 = load ptr, ptr @__clewFinish, align 8
  %m_commandQueue5 = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this1, i32 0, i32 5
  %11 = load ptr, ptr %m_commandQueue5, align 8
  %call6 = call i32 %10(ptr noundef %11)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  br label %if.end7

if.else:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.else
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.75, i32 noundef 258)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.77)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %if.end7

if.end7:                                          ; preds = %do.end, %if.end
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(112) ptr @_ZNK20b3AlignedObjectArrayI10b3Contact4EixEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3Contact4, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI18b3QuantizedBvhNodeLj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this1, i32 0, i32 3
  store i32 0, ptr %m_capacity, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI18b3QuantizedBvhNodeE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call)
  call void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %first, i32 noundef %last) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %first.addr = alloca i32, align 4
  %last.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %first, ptr %first.addr, align 4
  store i32 %last, ptr %last.addr, align 4
  %0 = load i32, ptr %first.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %last.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %3 = load i32, ptr %i, align 4
  %inc = add nsw i32 %3, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !116

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI18b3QuantizedBvhNodeE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this1, i32 0, i32 2
  %0 = load i32, ptr %m_size, align 4
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this1, i32 0, i32 6
  %1 = load i8, ptr %m_ownsMemory, align 8
  %tobool2 = trunc i8 %1 to i1
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this1, i32 0, i32 0
  %m_data4 = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this1, i32 0, i32 5
  %2 = load ptr, ptr %m_data4, align 8
  call void @_ZN18b3AlignedAllocatorI18b3QuantizedBvhNodeLj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, ptr noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %m_data5 = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data5, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI18b3QuantizedBvhNodeLj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, ptr noundef %ptr) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @_Z21b3AlignedFreeInternalPv(ptr noundef %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %newsize, ptr noundef nonnull align 16 dereferenceable(16) %fillData) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %newsize.addr = alloca i32, align 4
  %fillData.addr = alloca ptr, align 8
  %curSize = alloca i32, align 4
  %i = alloca i32, align 4
  %i6 = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %newsize, ptr %newsize.addr, align 4
  store ptr %fillData, ptr %fillData.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI18b3QuantizedBvhNodeE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  store i32 %call, ptr %curSize, align 4
  %0 = load i32, ptr %newsize.addr, align 4
  %1 = load i32, ptr %curSize, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %newsize.addr, align 4
  store i32 %2, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i32, ptr %i, align 4
  %4 = load i32, ptr %curSize, align 4
  %cmp2 = icmp slt i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, ptr %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !117

for.end:                                          ; preds = %for.cond
  br label %if.end17

if.else:                                          ; preds = %entry
  %6 = load i32, ptr %newsize.addr, align 4
  %call3 = call noundef i32 @_ZNK20b3AlignedObjectArrayI18b3QuantizedBvhNodeE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %cmp4 = icmp sgt i32 %6, %call3
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  %7 = load i32, ptr %newsize.addr, align 4
  call void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %7)
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.else
  %8 = load i32, ptr %curSize, align 4
  store i32 %8, ptr %i6, align 4
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc14, %if.end
  %9 = load i32, ptr %i6, align 4
  %10 = load i32, ptr %newsize.addr, align 4
  %cmp8 = icmp slt i32 %9, %10
  br i1 %cmp8, label %for.body9, label %for.end16

for.body9:                                        ; preds = %for.cond7
  %m_data10 = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this1, i32 0, i32 5
  %11 = load ptr, ptr %m_data10, align 8
  %12 = load i32, ptr %i6, align 4
  %idxprom11 = sext i32 %12 to i64
  %arrayidx12 = getelementptr inbounds %struct.b3QuantizedBvhNode, ptr %11, i64 %idxprom11
  %call13 = call noundef ptr @_ZN18b3QuantizedBvhNodenwEmPv(i64 noundef 16, ptr noundef %arrayidx12)
  %13 = load ptr, ptr %fillData.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %call13, ptr align 16 %13, i64 16, i1 false)
  br label %for.inc14

for.inc14:                                        ; preds = %for.body9
  %14 = load i32, ptr %i6, align 4
  %inc15 = add nsw i32 %14, 1
  store i32 %inc15, ptr %i6, align 4
  br label %for.cond7, !llvm.loop !118

for.end16:                                        ; preds = %for.cond7
  br label %if.end17

if.end17:                                         ; preds = %for.end16, %for.end
  %15 = load i32, ptr %newsize.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this1, i32 0, i32 2
  store i32 %15, ptr %m_size, align 4
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI18b3QuantizedBvhNodeE17copyToHostPointerEPS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %destPtr, i64 noundef %numElem, i64 noundef %srcFirstElem, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destPtr.addr = alloca ptr, align 8
  %numElem.addr = alloca i64, align 8
  %srcFirstElem.addr = alloca i64, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %status = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %destPtr, ptr %destPtr.addr, align 8
  store i64 %numElem, ptr %numElem.addr, align 8
  store i64 %srcFirstElem, ptr %srcFirstElem.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %numElem.addr, align 8
  %1 = load i64, ptr %srcFirstElem.addr, align 8
  %add = add i64 %0, %1
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI18b3QuantizedBvhNodeE8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %cmp = icmp ule i64 %add, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, ptr %status, align 4
  %2 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray.100, ptr %this1, i32 0, i32 5
  %3 = load ptr, ptr %m_commandQueue, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.100, ptr %this1, i32 0, i32 3
  %4 = load ptr, ptr %m_clBuffer, align 8
  %5 = load i64, ptr %srcFirstElem.addr, align 8
  %mul = mul i64 16, %5
  %6 = load i64, ptr %numElem.addr, align 8
  %mul2 = mul i64 16, %6
  %7 = load ptr, ptr %destPtr.addr, align 8
  %call3 = call i32 %2(ptr noundef %3, ptr noundef %4, i32 noundef 0, i64 noundef %mul, i64 noundef %mul2, ptr noundef %7, i32 noundef 0, ptr noundef null, ptr noundef null)
  store i32 %call3, ptr %status, align 4
  %8 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool = trunc i8 %8 to i1
  br i1 %tobool, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %9 = load ptr, ptr @__clewFinish, align 8
  %m_commandQueue5 = getelementptr inbounds %class.b3OpenCLArray.100, ptr %this1, i32 0, i32 5
  %10 = load ptr, ptr %m_commandQueue5, align 8
  %call6 = call i32 %9(ptr noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  br label %if.end7

if.else:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.else
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.75, i32 noundef 285)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.80)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %if.end7

if.end7:                                          ; preds = %do.end, %if.end
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_Count.addr = alloca i32, align 4
  %s = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %_Count, ptr %_Count.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI18b3QuantizedBvhNodeE8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %0 = load i32, ptr %_Count.addr, align 4
  %cmp = icmp slt i32 %call, %0
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %_Count.addr, align 4
  %call2 = call noundef ptr @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %1)
  store ptr %call2, ptr %s, align 8
  %2 = load ptr, ptr %s, align 8
  %cmp3 = icmp eq ptr %2, null
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then4
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.78, i32 noundef 301)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.79)
  br label %do.end

do.end:                                           ; preds = %do.body
  store i32 0, ptr %_Count.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %do.end, %if.then
  %call5 = call noundef i32 @_ZNK20b3AlignedObjectArrayI18b3QuantizedBvhNodeE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %3 = load ptr, ptr %s, align 8
  call void @_ZNK20b3AlignedObjectArrayI18b3QuantizedBvhNodeE4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call5, ptr noundef %3)
  %call6 = call noundef i32 @_ZNK20b3AlignedObjectArrayI18b3QuantizedBvhNodeE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call6)
  call void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %4 = load ptr, ptr %s, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this1, i32 0, i32 5
  store ptr %4, ptr %m_data, align 8
  %5 = load i32, ptr %_Count.addr, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this1, i32 0, i32 3
  store i32 %5, ptr %m_capacity, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN18b3QuantizedBvhNodenwEmPv(i64 noundef %0, ptr noundef %ptr) #3 comdat align 2 {
entry:
  %.addr = alloca i64, align 8
  %ptr.addr = alloca ptr, align 8
  store i64 %0, ptr %.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %1 = load ptr, ptr %ptr.addr, align 8
  ret ptr %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI18b3QuantizedBvhNodeE8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this1, i32 0, i32 3
  %0 = load i32, ptr %m_capacity, align 8
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %size) #0 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %size.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %size.addr, align 4
  %call = call noundef ptr @_ZN18b3AlignedAllocatorI18b3QuantizedBvhNodeLj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, i32 noundef %1, ptr noundef null)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK20b3AlignedObjectArrayI18b3QuantizedBvhNodeE4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %start, i32 noundef %end, ptr noundef %dest) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %start.addr = alloca i32, align 4
  %end.addr = alloca i32, align 4
  %dest.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %start, ptr %start.addr, align 4
  store i32 %end, ptr %end.addr, align 4
  store ptr %dest, ptr %dest.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %start.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %end.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %dest.addr, align 8
  %4 = load i32, ptr %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds %struct.b3QuantizedBvhNode, ptr %3, i64 %idxprom
  %call = call noundef ptr @_ZN18b3QuantizedBvhNodenwEmPv(i64 noundef 16, ptr noundef %arrayidx)
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this1, i32 0, i32 5
  %5 = load ptr, ptr %m_data, align 8
  %6 = load i32, ptr %i, align 4
  %idxprom2 = sext i32 %6 to i64
  %arrayidx3 = getelementptr inbounds %struct.b3QuantizedBvhNode, ptr %5, i64 %idxprom2
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %call, ptr align 16 %arrayidx3, i64 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i32, ptr %i, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !119

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN18b3AlignedAllocatorI18b3QuantizedBvhNodeLj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, i32 noundef %n, ptr noundef %hint) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %hint.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  store ptr %hint, ptr %hint.addr, align 8
  %0 = load i32, ptr %n.addr, align 4
  %conv = sext i32 %0 to i64
  %mul = mul i64 16, %conv
  %call = call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul, i32 noundef 16)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayI18b3QuantizedBvhNodeE8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.100, ptr %this1, i32 0, i32 2
  %0 = load i64, ptr %m_capacity, align 8
  ret i64 %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI16b3BvhSubtreeInfoLj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this1, i32 0, i32 3
  store i32 0, ptr %m_capacity, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI16b3BvhSubtreeInfoE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call)
  call void @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %first, i32 noundef %last) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %first.addr = alloca i32, align 4
  %last.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %first, ptr %first.addr, align 4
  store i32 %last, ptr %last.addr, align 4
  %0 = load i32, ptr %first.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %last.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %3 = load i32, ptr %i, align 4
  %inc = add nsw i32 %3, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !120

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI16b3BvhSubtreeInfoE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this1, i32 0, i32 2
  %0 = load i32, ptr %m_size, align 4
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this1, i32 0, i32 6
  %1 = load i8, ptr %m_ownsMemory, align 8
  %tobool2 = trunc i8 %1 to i1
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this1, i32 0, i32 0
  %m_data4 = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this1, i32 0, i32 5
  %2 = load ptr, ptr %m_data4, align 8
  call void @_ZN18b3AlignedAllocatorI16b3BvhSubtreeInfoLj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, ptr noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %m_data5 = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data5, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI16b3BvhSubtreeInfoLj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, ptr noundef %ptr) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @_Z21b3AlignedFreeInternalPv(ptr noundef %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %newsize, ptr noundef nonnull align 16 dereferenceable(32) %fillData) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %newsize.addr = alloca i32, align 4
  %fillData.addr = alloca ptr, align 8
  %curSize = alloca i32, align 4
  %i = alloca i32, align 4
  %i6 = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %newsize, ptr %newsize.addr, align 4
  store ptr %fillData, ptr %fillData.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI16b3BvhSubtreeInfoE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  store i32 %call, ptr %curSize, align 4
  %0 = load i32, ptr %newsize.addr, align 4
  %1 = load i32, ptr %curSize, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %newsize.addr, align 4
  store i32 %2, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i32, ptr %i, align 4
  %4 = load i32, ptr %curSize, align 4
  %cmp2 = icmp slt i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, ptr %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !121

for.end:                                          ; preds = %for.cond
  br label %if.end17

if.else:                                          ; preds = %entry
  %6 = load i32, ptr %newsize.addr, align 4
  %call3 = call noundef i32 @_ZNK20b3AlignedObjectArrayI16b3BvhSubtreeInfoE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %cmp4 = icmp sgt i32 %6, %call3
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  %7 = load i32, ptr %newsize.addr, align 4
  call void @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %7)
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.else
  %8 = load i32, ptr %curSize, align 4
  store i32 %8, ptr %i6, align 4
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc14, %if.end
  %9 = load i32, ptr %i6, align 4
  %10 = load i32, ptr %newsize.addr, align 4
  %cmp8 = icmp slt i32 %9, %10
  br i1 %cmp8, label %for.body9, label %for.end16

for.body9:                                        ; preds = %for.cond7
  %m_data10 = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this1, i32 0, i32 5
  %11 = load ptr, ptr %m_data10, align 8
  %12 = load i32, ptr %i6, align 4
  %idxprom11 = sext i32 %12 to i64
  %arrayidx12 = getelementptr inbounds %class.b3BvhSubtreeInfo, ptr %11, i64 %idxprom11
  %call13 = call noundef ptr @_ZN16b3BvhSubtreeInfonwEmPv(i64 noundef 32, ptr noundef %arrayidx12)
  %13 = load ptr, ptr %fillData.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %call13, ptr align 16 %13, i64 32, i1 false)
  br label %for.inc14

for.inc14:                                        ; preds = %for.body9
  %14 = load i32, ptr %i6, align 4
  %inc15 = add nsw i32 %14, 1
  store i32 %inc15, ptr %i6, align 4
  br label %for.cond7, !llvm.loop !122

for.end16:                                        ; preds = %for.cond7
  br label %if.end17

if.end17:                                         ; preds = %for.end16, %for.end
  %15 = load i32, ptr %newsize.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this1, i32 0, i32 2
  store i32 %15, ptr %m_size, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayI16b3BvhSubtreeInfoE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3OpenCLArray.98, ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %m_size, align 8
  ret i64 %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN16b3BvhSubtreeInfoC2Ev(ptr noundef nonnull align 16 dereferenceable(32) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI16b3BvhSubtreeInfoE17copyToHostPointerEPS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %destPtr, i64 noundef %numElem, i64 noundef %srcFirstElem, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destPtr.addr = alloca ptr, align 8
  %numElem.addr = alloca i64, align 8
  %srcFirstElem.addr = alloca i64, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %status = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %destPtr, ptr %destPtr.addr, align 8
  store i64 %numElem, ptr %numElem.addr, align 8
  store i64 %srcFirstElem, ptr %srcFirstElem.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %numElem.addr, align 8
  %1 = load i64, ptr %srcFirstElem.addr, align 8
  %add = add i64 %0, %1
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI16b3BvhSubtreeInfoE8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %cmp = icmp ule i64 %add, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, ptr %status, align 4
  %2 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray.98, ptr %this1, i32 0, i32 5
  %3 = load ptr, ptr %m_commandQueue, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.98, ptr %this1, i32 0, i32 3
  %4 = load ptr, ptr %m_clBuffer, align 8
  %5 = load i64, ptr %srcFirstElem.addr, align 8
  %mul = mul i64 32, %5
  %6 = load i64, ptr %numElem.addr, align 8
  %mul2 = mul i64 32, %6
  %7 = load ptr, ptr %destPtr.addr, align 8
  %call3 = call i32 %2(ptr noundef %3, ptr noundef %4, i32 noundef 0, i64 noundef %mul, i64 noundef %mul2, ptr noundef %7, i32 noundef 0, ptr noundef null, ptr noundef null)
  store i32 %call3, ptr %status, align 4
  %8 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool = trunc i8 %8 to i1
  br i1 %tobool, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %9 = load ptr, ptr @__clewFinish, align 8
  %m_commandQueue5 = getelementptr inbounds %class.b3OpenCLArray.98, ptr %this1, i32 0, i32 5
  %10 = load ptr, ptr %m_commandQueue5, align 8
  %call6 = call i32 %9(ptr noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  br label %if.end7

if.else:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.else
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.75, i32 noundef 285)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.80)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %if.end7

if.end7:                                          ; preds = %do.end, %if.end
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_Count.addr = alloca i32, align 4
  %s = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %_Count, ptr %_Count.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI16b3BvhSubtreeInfoE8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %0 = load i32, ptr %_Count.addr, align 4
  %cmp = icmp slt i32 %call, %0
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %_Count.addr, align 4
  %call2 = call noundef ptr @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %1)
  store ptr %call2, ptr %s, align 8
  %2 = load ptr, ptr %s, align 8
  %cmp3 = icmp eq ptr %2, null
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then4
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.78, i32 noundef 301)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.79)
  br label %do.end

do.end:                                           ; preds = %do.body
  store i32 0, ptr %_Count.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %do.end, %if.then
  %call5 = call noundef i32 @_ZNK20b3AlignedObjectArrayI16b3BvhSubtreeInfoE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %3 = load ptr, ptr %s, align 8
  call void @_ZNK20b3AlignedObjectArrayI16b3BvhSubtreeInfoE4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call5, ptr noundef %3)
  %call6 = call noundef i32 @_ZNK20b3AlignedObjectArrayI16b3BvhSubtreeInfoE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call6)
  call void @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %4 = load ptr, ptr %s, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this1, i32 0, i32 5
  store ptr %4, ptr %m_data, align 8
  %5 = load i32, ptr %_Count.addr, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this1, i32 0, i32 3
  store i32 %5, ptr %m_capacity, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN16b3BvhSubtreeInfonwEmPv(i64 noundef %0, ptr noundef %ptr) #3 comdat align 2 {
entry:
  %.addr = alloca i64, align 8
  %ptr.addr = alloca ptr, align 8
  store i64 %0, ptr %.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %1 = load ptr, ptr %ptr.addr, align 8
  ret ptr %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI16b3BvhSubtreeInfoE8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this1, i32 0, i32 3
  %0 = load i32, ptr %m_capacity, align 8
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %size) #0 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %size.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %size.addr, align 4
  %call = call noundef ptr @_ZN18b3AlignedAllocatorI16b3BvhSubtreeInfoLj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, i32 noundef %1, ptr noundef null)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK20b3AlignedObjectArrayI16b3BvhSubtreeInfoE4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %start, i32 noundef %end, ptr noundef %dest) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %start.addr = alloca i32, align 4
  %end.addr = alloca i32, align 4
  %dest.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %start, ptr %start.addr, align 4
  store i32 %end, ptr %end.addr, align 4
  store ptr %dest, ptr %dest.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %start.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %end.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %dest.addr, align 8
  %4 = load i32, ptr %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds %class.b3BvhSubtreeInfo, ptr %3, i64 %idxprom
  %call = call noundef ptr @_ZN16b3BvhSubtreeInfonwEmPv(i64 noundef 32, ptr noundef %arrayidx)
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this1, i32 0, i32 5
  %5 = load ptr, ptr %m_data, align 8
  %6 = load i32, ptr %i, align 4
  %idxprom2 = sext i32 %6 to i64
  %arrayidx3 = getelementptr inbounds %class.b3BvhSubtreeInfo, ptr %5, i64 %idxprom2
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %call, ptr align 16 %arrayidx3, i64 32, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i32, ptr %i, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !123

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN18b3AlignedAllocatorI16b3BvhSubtreeInfoLj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, i32 noundef %n, ptr noundef %hint) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %hint.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  store ptr %hint, ptr %hint.addr, align 8
  %0 = load i32, ptr %n.addr, align 4
  %conv = sext i32 %0 to i64
  %mul = mul i64 32, %conv
  %call = call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul, i32 noundef 16)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayI16b3BvhSubtreeInfoE8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.98, ptr %this1, i32 0, i32 2
  %0 = load i64, ptr %m_capacity, align 8
  ret i64 %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI9b3BvhInfoLj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3BvhInfoE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this1, i32 0, i32 3
  store i32 0, ptr %m_capacity, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3BvhInfoE5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI9b3BvhInfoE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI9b3BvhInfoE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call)
  call void @_ZN20b3AlignedObjectArrayI9b3BvhInfoE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI9b3BvhInfoE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3BvhInfoE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %first, i32 noundef %last) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %first.addr = alloca i32, align 4
  %last.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %first, ptr %first.addr, align 4
  store i32 %last, ptr %last.addr, align 4
  %0 = load i32, ptr %first.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %last.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %3 = load i32, ptr %i, align 4
  %inc = add nsw i32 %3, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !124

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI9b3BvhInfoE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this1, i32 0, i32 2
  %0 = load i32, ptr %m_size, align 4
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3BvhInfoE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this1, i32 0, i32 6
  %1 = load i8, ptr %m_ownsMemory, align 8
  %tobool2 = trunc i8 %1 to i1
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this1, i32 0, i32 0
  %m_data4 = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this1, i32 0, i32 5
  %2 = load ptr, ptr %m_data4, align 8
  call void @_ZN18b3AlignedAllocatorI9b3BvhInfoLj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, ptr noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %m_data5 = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data5, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI9b3BvhInfoLj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, ptr noundef %ptr) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @_Z21b3AlignedFreeInternalPv(ptr noundef %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3BvhInfoE6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %newsize, ptr noundef nonnull align 16 dereferenceable(64) %fillData) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %newsize.addr = alloca i32, align 4
  %fillData.addr = alloca ptr, align 8
  %curSize = alloca i32, align 4
  %i = alloca i32, align 4
  %i6 = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %newsize, ptr %newsize.addr, align 4
  store ptr %fillData, ptr %fillData.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI9b3BvhInfoE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  store i32 %call, ptr %curSize, align 4
  %0 = load i32, ptr %newsize.addr, align 4
  %1 = load i32, ptr %curSize, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %newsize.addr, align 4
  store i32 %2, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i32, ptr %i, align 4
  %4 = load i32, ptr %curSize, align 4
  %cmp2 = icmp slt i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, ptr %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !125

for.end:                                          ; preds = %for.cond
  br label %if.end16

if.else:                                          ; preds = %entry
  %6 = load i32, ptr %newsize.addr, align 4
  %call3 = call noundef i32 @_ZNK20b3AlignedObjectArrayI9b3BvhInfoE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %cmp4 = icmp sgt i32 %6, %call3
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  %7 = load i32, ptr %newsize.addr, align 4
  call void @_ZN20b3AlignedObjectArrayI9b3BvhInfoE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %7)
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.else
  %8 = load i32, ptr %curSize, align 4
  store i32 %8, ptr %i6, align 4
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc13, %if.end
  %9 = load i32, ptr %i6, align 4
  %10 = load i32, ptr %newsize.addr, align 4
  %cmp8 = icmp slt i32 %9, %10
  br i1 %cmp8, label %for.body9, label %for.end15

for.body9:                                        ; preds = %for.cond7
  %m_data10 = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this1, i32 0, i32 5
  %11 = load ptr, ptr %m_data10, align 8
  %12 = load i32, ptr %i6, align 4
  %idxprom11 = sext i32 %12 to i64
  %arrayidx12 = getelementptr inbounds %struct.b3BvhInfo, ptr %11, i64 %idxprom11
  %13 = load ptr, ptr %fillData.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx12, ptr align 16 %13, i64 64, i1 false)
  br label %for.inc13

for.inc13:                                        ; preds = %for.body9
  %14 = load i32, ptr %i6, align 4
  %inc14 = add nsw i32 %14, 1
  store i32 %inc14, ptr %i6, align 4
  br label %for.cond7, !llvm.loop !126

for.end15:                                        ; preds = %for.cond7
  br label %if.end16

if.end16:                                         ; preds = %for.end15, %for.end
  %15 = load i32, ptr %newsize.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this1, i32 0, i32 2
  store i32 %15, ptr %m_size, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayI9b3BvhInfoE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3OpenCLArray.102, ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %m_size, align 8
  ret i64 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI9b3BvhInfoE17copyToHostPointerEPS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %destPtr, i64 noundef %numElem, i64 noundef %srcFirstElem, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destPtr.addr = alloca ptr, align 8
  %numElem.addr = alloca i64, align 8
  %srcFirstElem.addr = alloca i64, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %status = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %destPtr, ptr %destPtr.addr, align 8
  store i64 %numElem, ptr %numElem.addr, align 8
  store i64 %srcFirstElem, ptr %srcFirstElem.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %numElem.addr, align 8
  %1 = load i64, ptr %srcFirstElem.addr, align 8
  %add = add i64 %0, %1
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI9b3BvhInfoE8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %cmp = icmp ule i64 %add, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, ptr %status, align 4
  %2 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray.102, ptr %this1, i32 0, i32 5
  %3 = load ptr, ptr %m_commandQueue, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.102, ptr %this1, i32 0, i32 3
  %4 = load ptr, ptr %m_clBuffer, align 8
  %5 = load i64, ptr %srcFirstElem.addr, align 8
  %mul = mul i64 64, %5
  %6 = load i64, ptr %numElem.addr, align 8
  %mul2 = mul i64 64, %6
  %7 = load ptr, ptr %destPtr.addr, align 8
  %call3 = call i32 %2(ptr noundef %3, ptr noundef %4, i32 noundef 0, i64 noundef %mul, i64 noundef %mul2, ptr noundef %7, i32 noundef 0, ptr noundef null, ptr noundef null)
  store i32 %call3, ptr %status, align 4
  %8 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool = trunc i8 %8 to i1
  br i1 %tobool, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %9 = load ptr, ptr @__clewFinish, align 8
  %m_commandQueue5 = getelementptr inbounds %class.b3OpenCLArray.102, ptr %this1, i32 0, i32 5
  %10 = load ptr, ptr %m_commandQueue5, align 8
  %call6 = call i32 %9(ptr noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  br label %if.end7

if.else:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.else
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.75, i32 noundef 285)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.80)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %if.end7

if.end7:                                          ; preds = %do.end, %if.end
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3BvhInfoE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_Count.addr = alloca i32, align 4
  %s = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %_Count, ptr %_Count.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI9b3BvhInfoE8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %0 = load i32, ptr %_Count.addr, align 4
  %cmp = icmp slt i32 %call, %0
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %_Count.addr, align 4
  %call2 = call noundef ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoE8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %1)
  store ptr %call2, ptr %s, align 8
  %2 = load ptr, ptr %s, align 8
  %cmp3 = icmp eq ptr %2, null
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then4
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.78, i32 noundef 301)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.79)
  br label %do.end

do.end:                                           ; preds = %do.body
  store i32 0, ptr %_Count.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %do.end, %if.then
  %call5 = call noundef i32 @_ZNK20b3AlignedObjectArrayI9b3BvhInfoE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %3 = load ptr, ptr %s, align 8
  call void @_ZNK20b3AlignedObjectArrayI9b3BvhInfoE4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call5, ptr noundef %3)
  %call6 = call noundef i32 @_ZNK20b3AlignedObjectArrayI9b3BvhInfoE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI9b3BvhInfoE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call6)
  call void @_ZN20b3AlignedObjectArrayI9b3BvhInfoE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %4 = load ptr, ptr %s, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this1, i32 0, i32 5
  store ptr %4, ptr %m_data, align 8
  %5 = load i32, ptr %_Count.addr, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this1, i32 0, i32 3
  store i32 %5, ptr %m_capacity, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI9b3BvhInfoE8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this1, i32 0, i32 3
  %0 = load i32, ptr %m_capacity, align 8
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN20b3AlignedObjectArrayI9b3BvhInfoE8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %size) #0 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %size.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %size.addr, align 4
  %call = call noundef ptr @_ZN18b3AlignedAllocatorI9b3BvhInfoLj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, i32 noundef %1, ptr noundef null)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZNK20b3AlignedObjectArrayI9b3BvhInfoE4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %start, i32 noundef %end, ptr noundef %dest) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %start.addr = alloca i32, align 4
  %end.addr = alloca i32, align 4
  %dest.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %start, ptr %start.addr, align 4
  store i32 %end, ptr %end.addr, align 4
  store ptr %dest, ptr %dest.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %start.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %end.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %dest.addr, align 8
  %4 = load i32, ptr %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds %struct.b3BvhInfo, ptr %3, i64 %idxprom
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this1, i32 0, i32 5
  %5 = load ptr, ptr %m_data, align 8
  %6 = load i32, ptr %i, align 4
  %idxprom2 = sext i32 %6 to i64
  %arrayidx3 = getelementptr inbounds %struct.b3BvhInfo, ptr %5, i64 %idxprom2
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx, ptr align 16 %arrayidx3, i64 64, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i32, ptr %i, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !127

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN18b3AlignedAllocatorI9b3BvhInfoLj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, i32 noundef %n, ptr noundef %hint) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %hint.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  store ptr %hint, ptr %hint.addr, align 8
  %0 = load i32, ptr %n.addr, align 4
  %conv = sext i32 %0 to i64
  %mul = mul i64 64, %conv
  %call = call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul, i32 noundef 16)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayI9b3BvhInfoE8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.102, ptr %this1, i32 0, i32 2
  %0 = load i64, ptr %m_capacity, align 8
  ret i64 %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI6b3AabbLj16EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %this) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3AabbE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this1, i32 0, i32 3
  store i32 0, ptr %m_capacity, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3AabbE5clearEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI6b3AabbE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI6b3AabbE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call)
  call void @_ZN20b3AlignedObjectArrayI6b3AabbE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI6b3AabbE4initEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3AabbE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %first, i32 noundef %last) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %first.addr = alloca i32, align 4
  %last.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %first, ptr %first.addr, align 4
  store i32 %last, ptr %last.addr, align 4
  %0 = load i32, ptr %first.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %last.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %3 = load i32, ptr %i, align 4
  %inc = add nsw i32 %3, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !128

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI6b3AabbE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this1, i32 0, i32 2
  %0 = load i32, ptr %m_size, align 4
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3AabbE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this1, i32 0, i32 6
  %1 = load i8, ptr %m_ownsMemory, align 8
  %tobool2 = trunc i8 %1 to i1
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this1, i32 0, i32 0
  %m_data4 = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this1, i32 0, i32 5
  %2 = load ptr, ptr %m_data4, align 8
  call void @_ZN18b3AlignedAllocatorI6b3AabbLj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, ptr noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %m_data5 = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this1, i32 0, i32 5
  store ptr null, ptr %m_data5, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN18b3AlignedAllocatorI6b3AabbLj16EE10deallocateEPS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, ptr noundef %ptr) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @_Z21b3AlignedFreeInternalPv(ptr noundef %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3AabbE6resizeEiRKS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %newsize, ptr noundef nonnull align 16 dereferenceable(32) %fillData) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %newsize.addr = alloca i32, align 4
  %fillData.addr = alloca ptr, align 8
  %curSize = alloca i32, align 4
  %i = alloca i32, align 4
  %i6 = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %newsize, ptr %newsize.addr, align 4
  store ptr %fillData, ptr %fillData.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI6b3AabbE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  store i32 %call, ptr %curSize, align 4
  %0 = load i32, ptr %newsize.addr, align 4
  %1 = load i32, ptr %curSize, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %newsize.addr, align 4
  store i32 %2, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i32, ptr %i, align 4
  %4 = load i32, ptr %curSize, align 4
  %cmp2 = icmp slt i32 %3, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, ptr %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !129

for.end:                                          ; preds = %for.cond
  br label %if.end16

if.else:                                          ; preds = %entry
  %6 = load i32, ptr %newsize.addr, align 4
  %call3 = call noundef i32 @_ZNK20b3AlignedObjectArrayI6b3AabbE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %cmp4 = icmp sgt i32 %6, %call3
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  %7 = load i32, ptr %newsize.addr, align 4
  call void @_ZN20b3AlignedObjectArrayI6b3AabbE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %7)
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.else
  %8 = load i32, ptr %curSize, align 4
  store i32 %8, ptr %i6, align 4
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc13, %if.end
  %9 = load i32, ptr %i6, align 4
  %10 = load i32, ptr %newsize.addr, align 4
  %cmp8 = icmp slt i32 %9, %10
  br i1 %cmp8, label %for.body9, label %for.end15

for.body9:                                        ; preds = %for.cond7
  %m_data10 = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this1, i32 0, i32 5
  %11 = load ptr, ptr %m_data10, align 8
  %12 = load i32, ptr %i6, align 4
  %idxprom11 = sext i32 %12 to i64
  %arrayidx12 = getelementptr inbounds %struct.b3Aabb, ptr %11, i64 %idxprom11
  %13 = load ptr, ptr %fillData.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx12, ptr align 16 %13, i64 32, i1 false)
  br label %for.inc13

for.inc13:                                        ; preds = %for.body9
  %14 = load i32, ptr %i6, align 4
  %inc14 = add nsw i32 %14, 1
  store i32 %inc14, ptr %i6, align 4
  br label %for.cond7, !llvm.loop !130

for.end15:                                        ; preds = %for.cond7
  br label %if.end16

if.end16:                                         ; preds = %for.end15, %for.end
  %15 = load i32, ptr %newsize.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this1, i32 0, i32 2
  store i32 %15, ptr %m_size, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayI6b3AabbE4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_size = getelementptr inbounds %class.b3OpenCLArray.90, ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %m_size, align 8
  ret i64 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI6b3AabbE17copyToHostPointerEPS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %destPtr, i64 noundef %numElem, i64 noundef %srcFirstElem, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destPtr.addr = alloca ptr, align 8
  %numElem.addr = alloca i64, align 8
  %srcFirstElem.addr = alloca i64, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %status = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %destPtr, ptr %destPtr.addr, align 8
  store i64 %numElem, ptr %numElem.addr, align 8
  store i64 %srcFirstElem, ptr %srcFirstElem.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %numElem.addr, align 8
  %1 = load i64, ptr %srcFirstElem.addr, align 8
  %add = add i64 %0, %1
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI6b3AabbE8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %cmp = icmp ule i64 %add, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, ptr %status, align 4
  %2 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray.90, ptr %this1, i32 0, i32 5
  %3 = load ptr, ptr %m_commandQueue, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.90, ptr %this1, i32 0, i32 3
  %4 = load ptr, ptr %m_clBuffer, align 8
  %5 = load i64, ptr %srcFirstElem.addr, align 8
  %mul = mul i64 32, %5
  %6 = load i64, ptr %numElem.addr, align 8
  %mul2 = mul i64 32, %6
  %7 = load ptr, ptr %destPtr.addr, align 8
  %call3 = call i32 %2(ptr noundef %3, ptr noundef %4, i32 noundef 0, i64 noundef %mul, i64 noundef %mul2, ptr noundef %7, i32 noundef 0, ptr noundef null, ptr noundef null)
  store i32 %call3, ptr %status, align 4
  %8 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool = trunc i8 %8 to i1
  br i1 %tobool, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %9 = load ptr, ptr @__clewFinish, align 8
  %m_commandQueue5 = getelementptr inbounds %class.b3OpenCLArray.90, ptr %this1, i32 0, i32 5
  %10 = load ptr, ptr %m_commandQueue5, align 8
  %call6 = call i32 %9(ptr noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  br label %if.end7

if.else:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.else
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.75, i32 noundef 285)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.80)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %if.end7

if.end7:                                          ; preds = %do.end, %if.end
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(32) ptr @_ZN20b3AlignedObjectArrayI6b3AabbEixEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3Aabb, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3AabbE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_Count.addr = alloca i32, align 4
  %s = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %_Count, ptr %_Count.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK20b3AlignedObjectArrayI6b3AabbE8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %0 = load i32, ptr %_Count.addr, align 4
  %cmp = icmp slt i32 %call, %0
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %_Count.addr, align 4
  %call2 = call noundef ptr @_ZN20b3AlignedObjectArrayI6b3AabbE8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef %1)
  store ptr %call2, ptr %s, align 8
  %2 = load ptr, ptr %s, align 8
  %cmp3 = icmp eq ptr %2, null
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then4
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.78, i32 noundef 301)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.79)
  br label %do.end

do.end:                                           ; preds = %do.body
  store i32 0, ptr %_Count.addr, align 4
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this1, i32 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %do.end, %if.then
  %call5 = call noundef i32 @_ZNK20b3AlignedObjectArrayI6b3AabbE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %3 = load ptr, ptr %s, align 8
  call void @_ZNK20b3AlignedObjectArrayI6b3AabbE4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call5, ptr noundef %3)
  %call6 = call noundef i32 @_ZNK20b3AlignedObjectArrayI6b3AabbE4sizeEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  call void @_ZN20b3AlignedObjectArrayI6b3AabbE7destroyEii(ptr noundef nonnull align 8 dereferenceable(25) %this1, i32 noundef 0, i32 noundef %call6)
  call void @_ZN20b3AlignedObjectArrayI6b3AabbE10deallocateEv(ptr noundef nonnull align 8 dereferenceable(25) %this1)
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this1, i32 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  %4 = load ptr, ptr %s, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this1, i32 0, i32 5
  store ptr %4, ptr %m_data, align 8
  %5 = load i32, ptr %_Count.addr, align 4
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this1, i32 0, i32 3
  store i32 %5, ptr %m_capacity, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK20b3AlignedObjectArrayI6b3AabbE8capacityEv(ptr noundef nonnull align 8 dereferenceable(25) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this1, i32 0, i32 3
  %0 = load i32, ptr %m_capacity, align 8
  ret i32 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN20b3AlignedObjectArrayI6b3AabbE8allocateEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %size) #0 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %size.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %m_allocator = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %size.addr, align 4
  %call = call noundef ptr @_ZN18b3AlignedAllocatorI6b3AabbLj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %m_allocator, i32 noundef %1, ptr noundef null)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZNK20b3AlignedObjectArrayI6b3AabbE4copyEiiPS0_(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %start, i32 noundef %end, ptr noundef %dest) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %start.addr = alloca i32, align 4
  %end.addr = alloca i32, align 4
  %dest.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %start, ptr %start.addr, align 4
  store i32 %end, ptr %end.addr, align 4
  store ptr %dest, ptr %dest.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %start.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %end.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %dest.addr, align 8
  %4 = load i32, ptr %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds %struct.b3Aabb, ptr %3, i64 %idxprom
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this1, i32 0, i32 5
  %5 = load ptr, ptr %m_data, align 8
  %6 = load i32, ptr %i, align 4
  %idxprom2 = sext i32 %6 to i64
  %arrayidx3 = getelementptr inbounds %struct.b3Aabb, ptr %5, i64 %idxprom2
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx, ptr align 16 %arrayidx3, i64 32, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i32, ptr %i, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !131

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN18b3AlignedAllocatorI6b3AabbLj16EE8allocateEiPPKS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, i32 noundef %n, ptr noundef %hint) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %hint.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  store ptr %hint, ptr %hint.addr, align 8
  %0 = load i32, ptr %n.addr, align 4
  %conv = sext i32 %0 to i64
  %mul = mul i64 32, %conv
  %call = call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul, i32 noundef 16)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK13b3OpenCLArrayI6b3AabbE8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.90, ptr %this1, i32 0, i32 2
  %0 = load i64, ptr %m_capacity, align 8
  ret i64 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayI6b3Int4E19copyFromHostPointerEPKS0_mmb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %src, i64 noundef %numElems, i64 noundef %destFirstElem, i1 noundef zeroext %waitForCompletion) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %src.addr = alloca ptr, align 8
  %numElems.addr = alloca i64, align 8
  %destFirstElem.addr = alloca i64, align 8
  %waitForCompletion.addr = alloca i8, align 1
  %status = alloca i32, align 4
  %sizeInBytes = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %src, ptr %src.addr, align 8
  store i64 %numElems, ptr %numElems.addr, align 8
  store i64 %destFirstElem, ptr %destFirstElem.addr, align 8
  %frombool = zext i1 %waitForCompletion to i8
  store i8 %frombool, ptr %waitForCompletion.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %numElems.addr, align 8
  %1 = load i64, ptr %destFirstElem.addr, align 8
  %add = add i64 %0, %1
  %tobool = icmp ne i64 %add, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, ptr %status, align 4
  %2 = load i64, ptr %numElems.addr, align 8
  %mul = mul i64 16, %2
  store i64 %mul, ptr %sizeInBytes, align 8
  %3 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this1, i32 0, i32 5
  %4 = load ptr, ptr %m_commandQueue, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this1, i32 0, i32 3
  %5 = load ptr, ptr %m_clBuffer, align 8
  %6 = load i64, ptr %destFirstElem.addr, align 8
  %mul2 = mul i64 16, %6
  %7 = load i64, ptr %sizeInBytes, align 8
  %8 = load ptr, ptr %src.addr, align 8
  %call = call i32 %3(ptr noundef %4, ptr noundef %5, i32 noundef 0, i64 noundef %mul2, i64 noundef %7, ptr noundef %8, i32 noundef 0, ptr noundef null, ptr noundef null)
  store i32 %call, ptr %status, align 4
  %9 = load i8, ptr %waitForCompletion.addr, align 1
  %tobool3 = trunc i8 %9 to i1
  br i1 %tobool3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %10 = load ptr, ptr @__clewFinish, align 8
  %m_commandQueue5 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this1, i32 0, i32 5
  %11 = load ptr, ptr %m_commandQueue5, align 8
  %call6 = call i32 %10(ptr noundef %11)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  br label %if.end7

if.else:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.else
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.75, i32 noundef 258)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.77)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %if.end7

if.end7:                                          ; preds = %do.end, %if.end
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(16) ptr @_ZNK20b3AlignedObjectArrayI6b3Int4EixEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %n) #3 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %m_data = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %m_data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.b3Int4, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN13b3OpenCLArrayI6b3Int4E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %this, i64 noundef %_Count, i1 noundef zeroext %copyOldContents) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_Count.addr = alloca i64, align 8
  %copyOldContents.addr = alloca i8, align 1
  %result = alloca i8, align 1
  %ciErrNum = alloca i32, align 4
  %memSizeInBytes = alloca i64, align 8
  %buf = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %_Count, ptr %_Count.addr, align 8
  %frombool = zext i1 %copyOldContents to i8
  store i8 %frombool, ptr %copyOldContents.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  store i8 1, ptr %result, align 1
  %call = call noundef i64 @_ZNK13b3OpenCLArrayI6b3Int4E8capacityEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %0 = load i64, ptr %_Count.addr, align 8
  %cmp = icmp ult i64 %call, %0
  br i1 %cmp, label %if.then, label %if.end14

if.then:                                          ; preds = %entry
  %m_allowGrowingCapacity = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this1, i32 0, i32 7
  %1 = load i8, ptr %m_allowGrowingCapacity, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %2 = load i64, ptr %_Count.addr, align 8
  %mul = mul i64 16, %2
  store i64 %mul, ptr %memSizeInBytes, align 8
  %3 = load ptr, ptr @__clewCreateBuffer, align 8
  %m_clContext = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this1, i32 0, i32 4
  %4 = load ptr, ptr %m_clContext, align 8
  %5 = load i64, ptr %memSizeInBytes, align 8
  %call3 = call ptr %3(ptr noundef %4, i64 noundef 1, i64 noundef %5, ptr noundef null, ptr noundef %ciErrNum)
  store ptr %call3, ptr %buf, align 8
  %6 = load i32, ptr %ciErrNum, align 4
  %cmp4 = icmp ne i32 %6, 0
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then2
  br label %do.body

do.body:                                          ; preds = %if.then5
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.30, ptr noundef @.str.75, i32 noundef 166)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef @.str.76)
  br label %do.end

do.end:                                           ; preds = %do.body
  store i64 0, ptr %_Count.addr, align 8
  store i8 0, ptr %result, align 1
  br label %if.end

if.end:                                           ; preds = %do.end, %if.then2
  %7 = load i8, ptr %result, align 1
  %tobool6 = trunc i8 %7 to i1
  br i1 %tobool6, label %if.then7, label %if.end12

if.then7:                                         ; preds = %if.end
  %8 = load i8, ptr %copyOldContents.addr, align 1
  %tobool8 = trunc i8 %8 to i1
  br i1 %tobool8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.then7
  %9 = load ptr, ptr %buf, align 8
  %call10 = call noundef i64 @_ZNK13b3OpenCLArrayI6b3Int4E4sizeEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  call void @_ZNK13b3OpenCLArrayI6b3Int4E8copyToCLEP7_cl_memmmm(ptr noundef nonnull align 8 dereferenceable(50) %this1, ptr noundef %9, i64 noundef %call10, i64 noundef 0, i64 noundef 0)
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.then7
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %if.end
  call void @_ZN13b3OpenCLArrayI6b3Int4E10deallocateEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  %10 = load ptr, ptr %buf, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this1, i32 0, i32 3
  store ptr %10, ptr %m_clBuffer, align 8
  %11 = load i64, ptr %_Count.addr, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this1, i32 0, i32 2
  store i64 %11, ptr %m_capacity, align 8
  br label %if.end13

if.else:                                          ; preds = %if.then
  call void @_ZN13b3OpenCLArrayI6b3Int4E10deallocateEv(ptr noundef nonnull align 8 dereferenceable(50) %this1)
  store i8 0, ptr %result, align 1
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.end12
  br label %if.end14

if.end14:                                         ; preds = %if.end13, %entry
  %12 = load i8, ptr %result, align 1
  %tobool15 = trunc i8 %12 to i1
  ret i1 %tobool15
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI6b3Int4E8copyToCLEP7_cl_memmmm(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %destination, i64 noundef %numElements, i64 noundef %firstElem, i64 noundef %dstOffsetInElems) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destination.addr = alloca ptr, align 8
  %numElements.addr = alloca i64, align 8
  %firstElem.addr = alloca i64, align 8
  %dstOffsetInElems.addr = alloca i64, align 8
  %status = alloca i32, align 4
  %srcOffsetBytes = alloca i64, align 8
  %dstOffsetInBytes = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %destination, ptr %destination.addr, align 8
  store i64 %numElements, ptr %numElements.addr, align 8
  store i64 %firstElem, ptr %firstElem.addr, align 8
  store i64 %dstOffsetInElems, ptr %dstOffsetInElems.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %numElements.addr, align 8
  %cmp = icmp ule i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %status, align 4
  %1 = load i64, ptr %firstElem.addr, align 8
  %mul = mul i64 16, %1
  store i64 %mul, ptr %srcOffsetBytes, align 8
  %2 = load i64, ptr %dstOffsetInElems.addr, align 8
  %mul2 = mul i64 16, %2
  store i64 %mul2, ptr %dstOffsetInBytes, align 8
  %3 = load ptr, ptr @__clewEnqueueCopyBuffer, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this1, i32 0, i32 5
  %4 = load ptr, ptr %m_commandQueue, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this1, i32 0, i32 3
  %5 = load ptr, ptr %m_clBuffer, align 8
  %6 = load ptr, ptr %destination.addr, align 8
  %7 = load i64, ptr %srcOffsetBytes, align 8
  %8 = load i64, ptr %dstOffsetInBytes, align 8
  %9 = load i64, ptr %numElements.addr, align 8
  %mul3 = mul i64 16, %9
  %call = call i32 %3(ptr noundef %4, ptr noundef %5, ptr noundef %6, i64 noundef %7, i64 noundef %8, i64 noundef %mul3, i32 noundef 0, ptr noundef null, ptr noundef null)
  store i32 %call, ptr %status, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayI6b3Int4E10deallocateEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this1, i32 0, i32 3
  %0 = load ptr, ptr %m_clBuffer, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %m_ownsMemory = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this1, i32 0, i32 6
  %1 = load i8, ptr %m_ownsMemory, align 8
  %tobool2 = trunc i8 %1 to i1
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %2 = load ptr, ptr @__clewReleaseMemObject, align 8
  %m_clBuffer3 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this1, i32 0, i32 3
  %3 = load ptr, ptr %m_clBuffer3, align 8
  %call = call i32 %2(ptr noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %m_clBuffer4 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this1, i32 0, i32 3
  store ptr null, ptr %m_clBuffer4, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this1, i32 0, i32 2
  store i64 0, ptr %m_capacity, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI10b3Contact4E8copyToCLEP7_cl_memmmm(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef %destination, i64 noundef %numElements, i64 noundef %firstElem, i64 noundef %dstOffsetInElems) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %destination.addr = alloca ptr, align 8
  %numElements.addr = alloca i64, align 8
  %firstElem.addr = alloca i64, align 8
  %dstOffsetInElems.addr = alloca i64, align 8
  %status = alloca i32, align 4
  %srcOffsetBytes = alloca i64, align 8
  %dstOffsetInBytes = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %destination, ptr %destination.addr, align 8
  store i64 %numElements, ptr %numElements.addr, align 8
  store i64 %firstElem, ptr %firstElem.addr, align 8
  store i64 %dstOffsetInElems, ptr %dstOffsetInElems.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %numElements.addr, align 8
  %cmp = icmp ule i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %status, align 4
  %1 = load i64, ptr %firstElem.addr, align 8
  %mul = mul i64 112, %1
  store i64 %mul, ptr %srcOffsetBytes, align 8
  %2 = load i64, ptr %dstOffsetInElems.addr, align 8
  %mul2 = mul i64 112, %2
  store i64 %mul2, ptr %dstOffsetInBytes, align 8
  %3 = load ptr, ptr @__clewEnqueueCopyBuffer, align 8
  %m_commandQueue = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this1, i32 0, i32 5
  %4 = load ptr, ptr %m_commandQueue, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this1, i32 0, i32 3
  %5 = load ptr, ptr %m_clBuffer, align 8
  %6 = load ptr, ptr %destination.addr, align 8
  %7 = load i64, ptr %srcOffsetBytes, align 8
  %8 = load i64, ptr %dstOffsetInBytes, align 8
  %9 = load i64, ptr %numElements.addr, align 8
  %mul3 = mul i64 112, %9
  %call = call i32 %3(ptr noundef %4, ptr noundef %5, ptr noundef %6, i64 noundef %7, i64 noundef %8, i64 noundef %mul3, i32 noundef 0, ptr noundef null, ptr noundef null)
  store i32 %call, ptr %status, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayI10b3Contact4E10deallocateEv(ptr noundef nonnull align 8 dereferenceable(50) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %m_clBuffer = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this1, i32 0, i32 3
  %0 = load ptr, ptr %m_clBuffer, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %m_ownsMemory = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this1, i32 0, i32 6
  %1 = load i8, ptr %m_ownsMemory, align 8
  %tobool2 = trunc i8 %1 to i1
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %2 = load ptr, ptr @__clewReleaseMemObject, align 8
  %m_clBuffer3 = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this1, i32 0, i32 3
  %3 = load ptr, ptr %m_clBuffer3, align 8
  %call = call i32 %2(ptr noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %m_clBuffer4 = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this1, i32 0, i32 3
  store ptr null, ptr %m_clBuffer4, align 8
  %m_capacity = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this1, i32 0, i32 2
  store i64 0, ptr %m_capacity, align 8
  ret void
}

; Function Attrs: uwtable
define internal void @_GLOBAL__sub_I_b3ConvexHullContact.cpp() #12 section ".text.startup" {
entry:
  call void @__cxx_global_var_init()
  ret void
}

attributes #0 = { mustprogress uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { mustprogress uwtable "frame-pointer"="all" "min-legal-vector-width"="64" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { mustprogress nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { uwtable "frame-pointer"="all" "min-legal-vector-width"="64" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #6 = { mustprogress nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="64" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #7 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #8 = { noreturn nounwind uwtable "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #9 = { nobuiltin nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #11 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #12 = { uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #13 = { nounwind }
attributes #14 = { noreturn nounwind }
attributes #15 = { builtin nounwind }

!llvm.module.flags = !{!0, !1, !2, !3, !4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = distinct !{!5, !6}
!6 = !{!"llvm.loop.mustprogress"}
!7 = distinct !{!7, !6}
!8 = distinct !{!8, !6}
!9 = distinct !{!9, !6}
!10 = distinct !{!10, !6}
!11 = distinct !{!11, !6}
!12 = distinct !{!12, !6}
!13 = distinct !{!13, !6}
!14 = distinct !{!14, !6}
!15 = distinct !{!15, !6}
!16 = distinct !{!16, !6}
!17 = distinct !{!17, !6}
!18 = distinct !{!18, !6}
!19 = distinct !{!19, !6}
!20 = distinct !{!20, !6}
!21 = distinct !{!21, !6}
!22 = distinct !{!22, !6}
!23 = distinct !{!23, !6}
!24 = distinct !{!24, !6}
!25 = distinct !{!25, !6}
!26 = distinct !{!26, !6}
!27 = distinct !{!27, !6}
!28 = distinct !{!28, !6}
!29 = distinct !{!29, !6}
!30 = distinct !{!30, !6}
!31 = distinct !{!31, !6}
!32 = distinct !{!32, !6}
!33 = distinct !{!33, !6}
!34 = distinct !{!34, !6}
!35 = distinct !{!35, !6}
!36 = distinct !{!36, !6}
!37 = distinct !{!37, !6}
!38 = distinct !{!38, !6}
!39 = distinct !{!39, !6}
!40 = distinct !{!40, !6}
!41 = distinct !{!41, !6}
!42 = distinct !{!42, !6}
!43 = distinct !{!43, !6}
!44 = distinct !{!44, !6}
!45 = distinct !{!45, !6}
!46 = distinct !{!46, !6}
!47 = distinct !{!47, !6}
!48 = distinct !{!48, !6}
!49 = distinct !{!49, !6}
!50 = distinct !{!50, !6}
!51 = distinct !{!51, !6}
!52 = distinct !{!52, !6}
!53 = distinct !{!53, !6}
!54 = distinct !{!54, !6}
!55 = distinct !{!55, !6}
!56 = distinct !{!56, !6}
!57 = distinct !{!57, !6}
!58 = distinct !{!58, !6}
!59 = distinct !{!59, !6}
!60 = distinct !{!60, !6}
!61 = distinct !{!61, !6}
!62 = distinct !{!62, !6}
!63 = distinct !{!63, !6}
!64 = distinct !{!64, !6}
!65 = distinct !{!65, !6}
!66 = distinct !{!66, !6}
!67 = distinct !{!67, !6}
!68 = distinct !{!68, !6}
!69 = distinct !{!69, !6}
!70 = distinct !{!70, !6}
!71 = distinct !{!71, !6}
!72 = distinct !{!72, !6}
!73 = distinct !{!73, !6}
!74 = distinct !{!74, !6}
!75 = distinct !{!75, !6}
!76 = distinct !{!76, !6}
!77 = distinct !{!77, !6}
!78 = distinct !{!78, !6}
!79 = distinct !{!79, !6}
!80 = distinct !{!80, !6}
!81 = distinct !{!81, !6}
!82 = distinct !{!82, !6}
!83 = distinct !{!83, !6}
!84 = distinct !{!84, !6}
!85 = distinct !{!85, !6}
!86 = distinct !{!86, !6}
!87 = distinct !{!87, !6}
!88 = distinct !{!88, !6}
!89 = distinct !{!89, !6}
!90 = distinct !{!90, !6}
!91 = distinct !{!91, !6}
!92 = distinct !{!92, !6}
!93 = distinct !{!93, !6}
!94 = distinct !{!94, !6}
!95 = distinct !{!95, !6}
!96 = distinct !{!96, !6}
!97 = distinct !{!97, !6}
!98 = distinct !{!98, !6}
!99 = distinct !{!99, !6}
!100 = distinct !{!100, !6}
!101 = distinct !{!101, !6}
!102 = distinct !{!102, !6}
!103 = distinct !{!103, !6}
!104 = distinct !{!104, !6}
!105 = distinct !{!105, !6}
!106 = distinct !{!106, !6}
!107 = distinct !{!107, !6}
!108 = distinct !{!108, !6}
!109 = distinct !{!109, !6}
!110 = distinct !{!110, !6}
!111 = distinct !{!111, !6}
!112 = distinct !{!112, !6}
!113 = distinct !{!113, !6}
!114 = distinct !{!114, !6}
!115 = distinct !{!115, !6}
!116 = distinct !{!116, !6}
!117 = distinct !{!117, !6}
!118 = distinct !{!118, !6}
!119 = distinct !{!119, !6}
!120 = distinct !{!120, !6}
!121 = distinct !{!121, !6}
!122 = distinct !{!122, !6}
!123 = distinct !{!123, !6}
!124 = distinct !{!124, !6}
!125 = distinct !{!125, !6}
!126 = distinct !{!126, !6}
!127 = distinct !{!127, !6}
!128 = distinct !{!128, !6}
!129 = distinct !{!129, !6}
!130 = distinct !{!130, !6}
!131 = distinct !{!131, !6}
