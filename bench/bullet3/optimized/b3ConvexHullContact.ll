; ModuleID = 'bench/bullet3/original/b3ConvexHullContact.ll'
source_filename = "bench/bullet3/original/b3ConvexHullContact.ll"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%class.b3Vector3 = type { %union.anon.1 }
%union.anon.1 = type { [4 x float] }
%struct.b3Int4 = type { %union.anon }
%union.anon = type { %struct.anon }
%struct.anon = type { i32, i32, i32, i32 }
%struct.b3RigidBodyData = type { %class.b3Vector3, %class.b3Quaternion, %class.b3Vector3, %class.b3Vector3, i32, float, float, float }
%class.b3Quaternion = type { %class.b3QuadWord }
%class.b3QuadWord = type { %union.anon.3 }
%union.anon.3 = type { [4 x float] }
%struct.b3Collidable = type { %union.anon.5, %union.anon.6, i32, %union.anon.7 }
%union.anon.5 = type { i32 }
%union.anon.6 = type { float }
%union.anon.7 = type { i32 }
%struct.b3BvhInfo = type { %class.b3Vector3, %class.b3Vector3, %class.b3Vector3, i32, i32, i32, i32 }
%class.b3BvhSubtreeInfo = type { %struct.b3BvhSubtreeInfoData }
%struct.b3BvhSubtreeInfoData = type { [3 x i16], [3 x i16], i32, i32, [3 x i32] }
%struct.b3QuantizedBvhNode = type { %struct.b3QuantizedBvhNodeData }
%struct.b3QuantizedBvhNodeData = type { [3 x i16], [3 x i16], i32 }
%struct.b3Aabb = type { %union.anon.8, %union.anon.9 }
%union.anon.8 = type { [4 x float] }
%union.anon.9 = type { [4 x float] }
%struct.b3ConvexPolyhedronData = type { %class.b3Vector3, %class.b3Vector3, %class.b3Vector3, %class.b3Vector3, float, i32, i32, i32, i32, i32, i32, i32 }
%struct.b3GpuFace = type { %class.b3Vector3, i32, i32, i32, i32 }
%struct.anon.2 = type { float, float, float, float }
%struct.b3GpuChildShape = type { %class.b3Vector3, %class.b3Quaternion, %union.anon.10, %union.anon.11, %union.anon.12, i32 }
%union.anon.10 = type { i32 }
%union.anon.11 = type { float }
%union.anon.12 = type { float }
%struct.b3Contact4Data = type { [4 x %class.b3Vector3], %class.b3Vector3, i16, i16, i32, i32, i32, i32, i32, i32, i32 }
%struct.GpuSatCollision = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, %class.b3OpenCLArray, %class.b3OpenCLArray.13, %class.b3OpenCLArray, %class.b3OpenCLArray.15, %class.b3OpenCLArray.13, %class.b3OpenCLArray, %class.b3OpenCLArray.13, %class.b3OpenCLArray.13, %class.b3OpenCLArray.17, %class.b3OpenCLArray, %class.b3OpenCLArray.13, %class.b3OpenCLArray.13 }
%class.b3OpenCLArray.15 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%class.b3OpenCLArray.17 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%class.b3OpenCLArray = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%class.b3OpenCLArray.13 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%class.b3AlignedObjectArray = type <{ %class.b3AlignedAllocator, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator = type { i8 }
%class.b3AlignedObjectArray.19 = type <{ %class.b3AlignedAllocator.20, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.20 = type { i8 }
%class.b3AlignedObjectArray.23 = type <{ %class.b3AlignedAllocator.24, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.24 = type { i8 }
%class.b3Transform = type { %class.b3Matrix3x3, %class.b3Vector3 }
%class.b3Matrix3x3 = type { [3 x %class.b3Vector3] }
%class.b3AlignedObjectArray.27 = type <{ %class.b3AlignedAllocator.28, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.28 = type { i8 }
%class.b3AlignedObjectArray.31 = type <{ %class.b3AlignedAllocator.32, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.32 = type { i8 }
%struct.anon.4 = type { float, float, float, float }
%class.b3AlignedObjectArray.35 = type <{ %class.b3AlignedAllocator.36, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.36 = type { i8 }
%struct.b3Contact4 = type { %struct.b3Contact4Data }
%class.b3AlignedObjectArray.39 = type <{ %class.b3AlignedAllocator.40, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.40 = type { i8 }
%class.b3AlignedObjectArray.51 = type <{ %class.b3AlignedAllocator.52, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.52 = type { i8 }
%class.b3AlignedObjectArray.43 = type <{ %class.b3AlignedAllocator.44, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.44 = type { i8 }
%class.b3AlignedObjectArray.47 = type <{ %class.b3AlignedAllocator.48, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.48 = type { i8 }
%class.b3AlignedObjectArray.58 = type <{ %class.b3AlignedAllocator.59, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.59 = type { i8 }
%struct.b3Int2 = type { %union.anon.55 }
%union.anon.55 = type { %struct.anon.56 }
%struct.anon.56 = type { i32, i32 }
%class.b3AlignedObjectArray.62 = type <{ %class.b3AlignedAllocator.63, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.63 = type { i8 }
%class.b3AlignedObjectArray.66 = type <{ %class.b3AlignedAllocator.67, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.67 = type { i8 }
%struct.b3BufferInfoCL = type <{ ptr, i8, [7 x i8] }>
%class.b3LauncherCL = type { ptr, ptr, ptr, i32, [4 x i8], %class.b3AlignedObjectArray.82, i32, i8, ptr, %class.b3AlignedObjectArray.86 }
%class.b3AlignedObjectArray.82 = type <{ %class.b3AlignedAllocator.83, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.83 = type { i8 }
%class.b3AlignedObjectArray.86 = type <{ %class.b3AlignedAllocator.87, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.87 = type { i8 }
%class.b3AlignedObjectArray.92 = type <{ %class.b3AlignedAllocator.93, [3 x i8], i32, i32, [4 x i8], ptr, i8, [7 x i8] }>
%class.b3AlignedAllocator.93 = type { i8 }
%class.b3OpenCLArray.70 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%class.b3OpenCLArray.72 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%class.b3OpenCLArray.74 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%class.b3OpenCLArray.76 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%class.b3OpenCLArray.78 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%class.b3OpenCLArray.80 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%struct.b3KernelArgData = type { i32, i32, i32, i32, %union.anon.104 }
%union.anon.104 = type { ptr, [8 x i8] }
%class.b3OpenCLArray.90 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%class.b3OpenCLArray.96 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%class.b3OpenCLArray.98 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%class.b3OpenCLArray.100 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%class.b3OpenCLArray.102 = type <{ ptr, i64, i64, ptr, ptr, ptr, i8, i8, [6 x i8] }>
%struct._b3MprSupport_t = type { %class.b3Vector3, %class.b3Vector3, %class.b3Vector3 }
%struct._b3MprSimplex_t = type { [4 x %struct._b3MprSupport_t], i32, [12 x i8] }

$_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_ = comdat any

$_Z19b3FindClippingFacesRK9b3Vector3PK22b3ConvexPolyhedronDataS4_S1_RK12b3QuaternionS1_S7_PS_S8_S8_iffPS0_PK9b3GpuFacePKiS9_SC_SE_P6b3Int4i = comdat any

$_ZN13b3OpenCLArrayIiED2Ev = comdat any

$_ZN13b3OpenCLArrayI9b3Vector3ED2Ev = comdat any

$_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairED2Ev = comdat any

$_ZN13b3OpenCLArrayIfED2Ev = comdat any

$__clang_call_terminate = comdat any

$_Z7projectRK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionS4_RK20b3AlignedObjectArrayIS2_ERfSC_ = comdat any

$_ZN20b3AlignedObjectArrayI6b3Int2ED2Ev = comdat any

$_ZN20b3AlignedObjectArrayIiED2Ev = comdat any

$_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev = comdat any

$_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev = comdat any

$_ZNK13b3OpenCLArrayI6b3Int4E10copyToHostER20b3AlignedObjectArrayIS0_Eb = comdat any

$_ZNK13b3OpenCLArrayI15b3RigidBodyDataE10copyToHostER20b3AlignedObjectArrayIS0_Eb = comdat any

$_ZNK13b3OpenCLArrayI12b3CollidableE10copyToHostER20b3AlignedObjectArrayIS0_Eb = comdat any

$_ZNK13b3OpenCLArrayI15b3GpuChildShapeE10copyToHostER20b3AlignedObjectArrayIS0_Eb = comdat any

$_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE10copyToHostER20b3AlignedObjectArrayIS0_Eb = comdat any

$_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb = comdat any

$_ZNK13b3OpenCLArrayI9b3GpuFaceE10copyToHostER20b3AlignedObjectArrayIS0_Eb = comdat any

$_ZNK13b3OpenCLArrayIiE10copyToHostER20b3AlignedObjectArrayIiEb = comdat any

$_ZNK13b3OpenCLArrayI10b3Contact4E10copyToHostER20b3AlignedObjectArrayIS0_Eb = comdat any

$_Z16b3MprPenetrationiiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_PiPfSB_SB_ = comdat any

$_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev = comdat any

$_ZN20b3AlignedObjectArrayI9b3GpuFaceED2Ev = comdat any

$_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataED2Ev = comdat any

$_ZN20b3AlignedObjectArrayI15b3GpuChildShapeED2Ev = comdat any

$_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev = comdat any

$_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev = comdat any

$_ZNK13b3OpenCLArrayI18b3QuantizedBvhNodeE10copyToHostER20b3AlignedObjectArrayIS0_Eb = comdat any

$_ZNK13b3OpenCLArrayI9b3BvhInfoE10copyToHostER20b3AlignedObjectArrayIS0_Eb = comdat any

$_ZNK13b3OpenCLArrayI6b3AabbE10copyToHostER20b3AlignedObjectArrayIS0_Eb = comdat any

$_ZN20b3AlignedObjectArrayI6b3AabbED2Ev = comdat any

$_ZN20b3AlignedObjectArrayI9b3BvhInfoED2Ev = comdat any

$_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoED2Ev = comdat any

$_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeED2Ev = comdat any

$_ZN13b3OpenCLArrayI10b3Contact4E7reserveEmb = comdat any

$_ZNK11b3Matrix3x311getRotationER12b3Quaternion = comdat any

$_Z22b3MprVec3PointTriDist2PK9b3Vector3S1_S1_S1_PS_ = comdat any

$_Z27_b3MprVec3PointSegmentDist2PK9b3Vector3S1_S1_PS_ = comdat any

$_ZN13b3OpenCLArrayI9b3Vector3E7reserveEmb = comdat any

$_ZN13b3OpenCLArrayI9b3Vector3ED0Ev = comdat any

$_ZN13b3OpenCLArrayIiE7reserveEmb = comdat any

$_ZN13b3OpenCLArrayIiED0Ev = comdat any

$_ZN13b3OpenCLArrayIfE7reserveEmb = comdat any

$_ZN13b3OpenCLArrayIfED0Ev = comdat any

$_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE7reserveEmb = comdat any

$_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairED0Ev = comdat any

$_ZN20b3AlignedObjectArrayI10b3Contact4E7reserveEi = comdat any

$_ZN20b3AlignedObjectArrayI6b3Int4E7reserveEi = comdat any

$_ZN20b3AlignedObjectArrayI9b3Vector3E7reserveEi = comdat any

$_ZN20b3AlignedObjectArrayIiE7reserveEi = comdat any

$_ZN20b3AlignedObjectArrayI15b3KernelArgDataE7reserveEi = comdat any

$_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE7reserveEi = comdat any

$_ZN20b3AlignedObjectArrayI12b3CollidableE7reserveEi = comdat any

$_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE7reserveEi = comdat any

$_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE7reserveEi = comdat any

$_ZN20b3AlignedObjectArrayI9b3GpuFaceE7reserveEi = comdat any

$_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE7reserveEi = comdat any

$_ZN20b3AlignedObjectArrayI9b3BvhInfoE7reserveEi = comdat any

$_ZN20b3AlignedObjectArrayI6b3AabbE7reserveEi = comdat any

$_ZN13b3OpenCLArrayI6b3Int4E7reserveEmb = comdat any

$_ZTV13b3OpenCLArrayI9b3Vector3E = comdat any

$_ZTS13b3OpenCLArrayI9b3Vector3E = comdat any

$_ZTI13b3OpenCLArrayI9b3Vector3E = comdat any

$_ZTV13b3OpenCLArrayIiE = comdat any

$_ZTS13b3OpenCLArrayIiE = comdat any

$_ZTI13b3OpenCLArrayIiE = comdat any

$_ZTV13b3OpenCLArrayIfE = comdat any

$_ZTS13b3OpenCLArrayIfE = comdat any

$_ZTI13b3OpenCLArrayIfE = comdat any

$_ZTV13b3OpenCLArrayI25b3CompoundOverlappingPairE = comdat any

$_ZTS13b3OpenCLArrayI25b3CompoundOverlappingPairE = comdat any

$_ZTI13b3OpenCLArrayI25b3CompoundOverlappingPairE = comdat any

@findSeparatingAxisOnGpu = dso_local local_unnamed_addr global i8 1, align 1
@splitSearchSepAxisConcave = dso_local local_unnamed_addr global i8 0, align 1
@splitSearchSepAxisConvex = dso_local local_unnamed_addr global i8 1, align 1
@useMprGpu = dso_local local_unnamed_addr global i8 1, align 1
@bvhTraversalKernelGPU = dso_local local_unnamed_addr global i8 1, align 1
@findConcaveSeparatingAxisKernelGPU = dso_local local_unnamed_addr global i8 1, align 1
@clipConcaveFacesAndFindContactsCPU = dso_local local_unnamed_addr global i8 0, align 1
@clipConvexFacesAndFindContactsCPU = dso_local local_unnamed_addr global i8 0, align 1
@reduceConcaveContactsOnGPU = dso_local local_unnamed_addr global i8 1, align 1
@reduceConvexContactsOnGPU = dso_local local_unnamed_addr global i8 1, align 1
@findConvexClippingFacesGPU = dso_local local_unnamed_addr global i8 1, align 1
@useGjk = dso_local local_unnamed_addr global i8 0, align 1
@useGjkContacts = dso_local local_unnamed_addr global i8 0, align 1
@b3g_actualSATPairTests = dso_local local_unnamed_addr global i32 0, align 4
@unitSphere162 = dso_local global [162 x %class.b3Vector3] zeroinitializer, align 16
@_ZZ28b3FindSeparatingAxisEdgeEdgePK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_PfbE12maxEdgeTests = internal unnamed_addr global i32 0, align 4
@.str = private unnamed_addr constant [19 x i8] c"maxEdgeTests = %d\0A\00", align 1
@.str.1 = private unnamed_addr constant [30 x i8] c"hullA->m_numUniqueEdges = %d\0A\00", align 1
@.str.2 = private unnamed_addr constant [30 x i8] c"hullB->m_numUniqueEdges = %d\0A\00", align 1
@_ZTV15GpuSatCollision = dso_local unnamed_addr constant { [4 x ptr] } { [4 x ptr] [ptr null, ptr @_ZTI15GpuSatCollision, ptr @_ZN15GpuSatCollisionD2Ev, ptr @_ZN15GpuSatCollisionD0Ev] }, align 8
@.str.3 = private unnamed_addr constant [54 x i8] c"src/Bullet3OpenCL/NarrowphaseCollision/kernels/mpr.cl\00", align 1
@.str.4 = private unnamed_addr constant [21 x i8] c"mprPenetrationKernel\00", align 1
@.str.5 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.6 = private unnamed_addr constant [35 x i8] c"findSeparatingAxisUnitSphereKernel\00", align 1
@.str.7 = private unnamed_addr constant [54 x i8] c"src/Bullet3OpenCL/NarrowphaseCollision/kernels/sat.cl\00", align 1
@.str.8 = private unnamed_addr constant [61 x i8] c"src/Bullet3OpenCL/NarrowphaseCollision/kernels/satConcave.cl\00", align 1
@.str.9 = private unnamed_addr constant [25 x i8] c"findSeparatingAxisKernel\00", align 1
@.str.10 = private unnamed_addr constant [35 x i8] c"findSeparatingAxisVertexFaceKernel\00", align 1
@.str.11 = private unnamed_addr constant [33 x i8] c"findSeparatingAxisEdgeEdgeKernel\00", align 1
@.str.12 = private unnamed_addr constant [32 x i8] c"findConcaveSeparatingAxisKernel\00", align 1
@.str.13 = private unnamed_addr constant [42 x i8] c"findConcaveSeparatingAxisVertexFaceKernel\00", align 1
@.str.14 = private unnamed_addr constant [40 x i8] c"findConcaveSeparatingAxisEdgeEdgeKernel\00", align 1
@.str.15 = private unnamed_addr constant [24 x i8] c"findCompoundPairsKernel\00", align 1
@.str.16 = private unnamed_addr constant [27 x i8] c"processCompoundPairsKernel\00", align 1
@.str.17 = private unnamed_addr constant [70 x i8] c"src/Bullet3OpenCL/NarrowphaseCollision/kernels/satClipHullContacts.cl\00", align 1
@.str.18 = private unnamed_addr constant [19 x i8] c"clipHullHullKernel\00", align 1
@.str.19 = private unnamed_addr constant [28 x i8] c"clipCompoundsHullHullKernel\00", align 1
@.str.20 = private unnamed_addr constant [24 x i8] c"findClippingFacesKernel\00", align 1
@.str.21 = private unnamed_addr constant [31 x i8] c"clipFacesAndFindContactsKernel\00", align 1
@.str.22 = private unnamed_addr constant [32 x i8] c"clipHullHullConcaveConvexKernel\00", align 1
@.str.23 = private unnamed_addr constant [26 x i8] c"newContactReductionKernel\00", align 1
@.str.24 = private unnamed_addr constant [63 x i8] c"src/Bullet3OpenCL/NarrowphaseCollision/kernels/bvhTraversal.cl\00", align 1
@.str.25 = private unnamed_addr constant [19 x i8] c"bvhTraversalKernel\00", align 1
@.str.26 = private unnamed_addr constant [68 x i8] c"src/Bullet3OpenCL/NarrowphaseCollision/kernels/primitiveContacts.cl\00", align 1
@.str.27 = private unnamed_addr constant [24 x i8] c"primitiveContactsKernel\00", align 1
@.str.28 = private unnamed_addr constant [32 x i8] c"findConcaveSphereContactsKernel\00", align 1
@.str.29 = private unnamed_addr constant [37 x i8] c"processCompoundPairsPrimitivesKernel\00", align 1
@__clewReleaseKernel = external local_unnamed_addr global ptr, align 8
@.str.30 = private unnamed_addr constant [17 x i8] c"b3Error[%s,%d]:\0A\00", align 1
@.str.31 = private unnamed_addr constant [156 x i8] c"generated/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/bullet3/bullet3/src/Bullet3OpenCL/NarrowphaseCollision/b3ConvexHullContact.cpp\00", align 1
@.str.32 = private unnamed_addr constant [37 x i8] c"exceeding contact capacity (%d,%df)\0A\00", align 1
@.str.33 = private unnamed_addr constant [8 x i8] c"overlap\00", align 1
@.str.34 = private unnamed_addr constant [43 x i8] c"Error: exceeding contact capacity (%d/%d)\0A\00", align 1
@numAabbChecks = dso_local local_unnamed_addr global i32 0, align 4
@maxNumAabbChecks = dso_local local_unnamed_addr global i32 0, align 4
@maxDepth = dso_local local_unnamed_addr global i32 0, align 4
@.str.35 = private unnamed_addr constant [13 x i8] c"maxDepth=%d\0A\00", align 1
@.str.36 = private unnamed_addr constant [41 x i8] c"Error: traversal exceeded maxStackDepth\0A\00", align 1
@.str.37 = private unnamed_addr constant [21 x i8] c"maxNumAabbChecks=%d\0A\00", align 1
@.str.38 = private unnamed_addr constant [63 x i8] c"numCompoundPairsOut exceeded maxNumCompoundPairsCapacity (%d)\0A\00", align 1
@_ZZ26computeContactSphereConvexiiiiiPK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataPK9b3Vector3PKiPK9b3GpuFaceP10b3Contact4RiiE9numChecks = internal unnamed_addr global i32 0, align 4
@_ZL12myframecount = internal unnamed_addr global i32 0, align 4
@.str.39 = private unnamed_addr constant [26 x i8] c"m_primitiveContactsKernel\00", align 1
@__clewFinish = external local_unnamed_addr global ptr, align 8
@.str.40 = private unnamed_addr constant [34 x i8] c"computeConvexConvexContactsGPUSAT\00", align 1
@.str.41 = private unnamed_addr constant [42 x i8] c"Error: contacts exceeds capacity (%d/%d)\0A\00", align 1
@.str.42 = private unnamed_addr constant [27 x i8] c"m_findSeparatingAxisKernel\00", align 1
@.str.43 = private unnamed_addr constant [29 x i8] c"findSeparatingAxisKernel CPU\00", align 1
@_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E7maxdiff = internal unnamed_addr global float 0.000000e+00, align 4
@.str.44 = private unnamed_addr constant [19 x i8] c"maxdiff = %20.10f\0A\00", align 1
@_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E7maxdiff_0 = internal unnamed_addr global float 0.000000e+00, align 4
@_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E8maxDepth = internal unnamed_addr global float 0.000000e+00, align 4
@.str.45 = private unnamed_addr constant [19 x i8] c"MPR maxdepth = %f\0A\00", align 1
@.str.47 = private unnamed_addr constant [26 x i8] c"m_findCompoundPairsKernel\00", align 1
@.str.48 = private unnamed_addr constant [21 x i8] c"numCompoundPairs=%d\0A\00", align 1
@.str.49 = private unnamed_addr constant [41 x i8] c"Exceeded compound pair capacity (%d/%d)\0A\00", align 1
@.str.50 = private unnamed_addr constant [39 x i8] c"m_processCompoundPairsPrimitivesKernel\00", align 1
@.str.51 = private unnamed_addr constant [29 x i8] c"m_processCompoundPairsKernel\00", align 1
@.str.52 = private unnamed_addr constant [21 x i8] c"m_bvhTraversalKernel\00", align 1
@_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E39exceeded_maxTriConvexPairCapacity_count = internal unnamed_addr global i32 0, align 4
@.str.53 = private unnamed_addr constant [86 x i8] c"Exceeded the maxTriConvexPairCapacity (found %d but max is %d, it happened %d times)\0A\00", align 1
@.str.54 = private unnamed_addr constant [44 x i8] c"m_findConcaveSeparatingAxisVertexFaceKernel\00", align 1
@.str.55 = private unnamed_addr constant [42 x i8] c"m_findConcaveSeparatingAxisEdgeEdgeKernel\00", align 1
@.str.56 = private unnamed_addr constant [34 x i8] c"m_findConcaveSeparatingAxisKernel\00", align 1
@.str.57 = private unnamed_addr constant [34 x i8] c"m_findConcaveSphereContactsKernel\00", align 1
@.str.58 = private unnamed_addr constant [25 x i8] c"clipFacesAndFindContacts\00", align 1
@.str.59 = private unnamed_addr constant [27 x i8] c"m_clipFacesAndFindContacts\00", align 1
@.str.60 = private unnamed_addr constant [28 x i8] c"m_newContactReductionKernel\00", align 1
@.str.63 = private unnamed_addr constant [21 x i8] c"m_clipHullHullKernel\00", align 1
@.str.64 = private unnamed_addr constant [35 x i8] c"Exceeded contact capacity (%d/%d)\0A\00", align 1
@.str.65 = private unnamed_addr constant [30 x i8] c"m_clipCompoundsHullHullKernel\00", align 1
@_ZTVN10__cxxabiv117__class_type_infoE = external global [0 x ptr]
@_ZTS15GpuSatCollision = dso_local constant [18 x i8] c"15GpuSatCollision\00", align 1
@_ZTI15GpuSatCollision = dso_local constant { ptr, ptr } { ptr getelementptr inbounds (ptr, ptr @_ZTVN10__cxxabiv117__class_type_infoE, i64 2), ptr @_ZTS15GpuSatCollision }, align 8
@.str.66 = private unnamed_addr constant [43628 x i8] c"/***\0A * ---------------------------------\0A * Copyright (c)2012 Daniel Fiser <danfis@danfis.cz>\0A *\0A *  This file was ported from mpr.c file, part of libccd.\0A *  The Minkoski Portal Refinement implementation was ported \0A *  to OpenCL by Erwin Coumans for the Bullet 3 Physics library.\0A *  at http://github.com/erwincoumans/bullet3\0A *\0A *  Distributed under the OSI-approved BSD License (the \22License\22);\0A *  see <http://www.opensource.org/licenses/bsd-license.php>.\0A *  This software is distributed WITHOUT ANY WARRANTY; without even the\0A *  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\0A *  See the License for more information.\0A */\0A#ifndef B3_MPR_PENETRATION_H\0A#define B3_MPR_PENETRATION_H\0A#ifndef B3_PLATFORM_DEFINITIONS_H\0A#define B3_PLATFORM_DEFINITIONS_H\0Astruct MyTest\0A{\0A\09int bla;\0A};\0A#ifdef __cplusplus\0A#else\0A//keep B3_LARGE_FLOAT*B3_LARGE_FLOAT < FLT_MAX\0A#define B3_LARGE_FLOAT 1e18f\0A#define B3_INFINITY 1e18f\0A#define b3Assert(a)\0A#define b3ConstArray(a) __global const a*\0A#define b3AtomicInc atomic_inc\0A#define b3AtomicAdd atomic_add\0A#define b3Fabs fabs\0A#define b3Sqrt native_sqrt\0A#define b3Sin native_sin\0A#define b3Cos native_cos\0A#define B3_STATIC\0A#endif\0A#endif\0A#ifndef B3_FLOAT4_H\0A#define B3_FLOAT4_H\0A#ifndef B3_PLATFORM_DEFINITIONS_H\0A#ifdef __cplusplus\0A#else\0A#endif\0A#endif\0A#ifdef __cplusplus\0A#else\0A\09typedef float4\09b3Float4;\0A\09#define b3Float4ConstArg const b3Float4\0A\09#define b3MakeFloat4 (float4)\0A\09float b3Dot3F4(b3Float4ConstArg v0,b3Float4ConstArg v1)\0A\09{\0A\09\09float4 a1 = b3MakeFloat4(v0.xyz,0.f);\0A\09\09float4 b1 = b3MakeFloat4(v1.xyz,0.f);\0A\09\09return dot(a1, b1);\0A\09}\0A\09b3Float4 b3Cross3(b3Float4ConstArg v0,b3Float4ConstArg v1)\0A\09{\0A\09\09float4 a1 = b3MakeFloat4(v0.xyz,0.f);\0A\09\09float4 b1 = b3MakeFloat4(v1.xyz,0.f);\0A\09\09return cross(a1, b1);\0A\09}\0A\09#define b3MinFloat4 min\0A\09#define b3MaxFloat4 max\0A\09#define b3Normalized(a) normalize(a)\0A#endif \0A\09\09\0Ainline bool b3IsAlmostZero(b3Float4ConstArg v)\0A{\0A\09if(b3Fabs(v.x)>1e-6 || b3Fabs(v.y)>1e-6 || b3Fabs(v.z)>1e-6)\09\0A\09\09return false;\0A\09return true;\0A}\0Ainline int    b3MaxDot( b3Float4ConstArg vec, __global const b3Float4* vecArray, int vecLen, float* dotOut )\0A{\0A    float maxDot = -B3_INFINITY;\0A    int i = 0;\0A    int ptIndex = -1;\0A    for( i = 0; i < vecLen; i++ )\0A    {\0A        float dot = b3Dot3F4(vecArray[i],vec);\0A            \0A        if( dot > maxDot )\0A        {\0A            maxDot = dot;\0A            ptIndex = i;\0A        }\0A    }\0A\09b3Assert(ptIndex>=0);\0A    if (ptIndex<0)\0A\09{\0A\09\09ptIndex = 0;\0A\09}\0A    *dotOut = maxDot;\0A    return ptIndex;\0A}\0A#endif //B3_FLOAT4_H\0A#ifndef B3_RIGIDBODY_DATA_H\0A#define B3_RIGIDBODY_DATA_H\0A#ifndef B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_FLOAT4_H\0A#ifndef B3_QUAT_H\0A#define B3_QUAT_H\0A#ifndef B3_PLATFORM_DEFINITIONS_H\0A#ifdef __cplusplus\0A#else\0A#endif\0A#endif\0A#ifndef B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A\09typedef float4\09b3Quat;\0A\09#define b3QuatConstArg const b3Quat\0A\09\0A\09\0Ainline float4 b3FastNormalize4(float4 v)\0A{\0A\09v = (float4)(v.xyz,0.f);\0A\09return fast_normalize(v);\0A}\0A\09\0Ainline b3Quat b3QuatMul(b3Quat a, b3Quat b);\0Ainline b3Quat b3QuatNormalized(b3QuatConstArg in);\0Ainline b3Quat b3QuatRotate(b3QuatConstArg q, b3QuatConstArg vec);\0Ainline b3Quat b3QuatInvert(b3QuatConstArg q);\0Ainline b3Quat b3QuatInverse(b3QuatConstArg q);\0Ainline b3Quat b3QuatMul(b3QuatConstArg a, b3QuatConstArg b)\0A{\0A\09b3Quat ans;\0A\09ans = b3Cross3( a, b );\0A\09ans += a.w*b+b.w*a;\0A//\09ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);\0A\09ans.w = a.w*b.w - b3Dot3F4(a, b);\0A\09return ans;\0A}\0Ainline b3Quat b3QuatNormalized(b3QuatConstArg in)\0A{\0A\09b3Quat q;\0A\09q=in;\0A\09//return b3FastNormalize4(in);\0A\09float len = native_sqrt(dot(q, q));\0A\09if(len > 0.f)\0A\09{\0A\09\09q *= 1.f / len;\0A\09}\0A\09else\0A\09{\0A\09\09q.x = q.y = q.z = 0.f;\0A\09\09q.w = 1.f;\0A\09}\0A\09return q;\0A}\0Ainline float4 b3QuatRotate(b3QuatConstArg q, b3QuatConstArg vec)\0A{\0A\09b3Quat qInv = b3QuatInvert( q );\0A\09float4 vcpy = vec;\0A\09vcpy.w = 0.f;\0A\09float4 out = b3QuatMul(b3QuatMul(q,vcpy),qInv);\0A\09return out;\0A}\0Ainline b3Quat b3QuatInverse(b3QuatConstArg q)\0A{\0A\09return (b3Quat)(-q.xyz, q.w);\0A}\0Ainline b3Quat b3QuatInvert(b3QuatConstArg q)\0A{\0A\09return (b3Quat)(-q.xyz, q.w);\0A}\0Ainline float4 b3QuatInvRotate(b3QuatConstArg q, b3QuatConstArg vec)\0A{\0A\09return b3QuatRotate( b3QuatInvert( q ), vec );\0A}\0Ainline b3Float4 b3TransformPoint(b3Float4ConstArg point, b3Float4ConstArg translation, b3QuatConstArg  orientation)\0A{\0A\09return b3QuatRotate( orientation, point ) + (translation);\0A}\0A\09\0A#endif \0A#endif //B3_QUAT_H\0A#ifndef B3_MAT3x3_H\0A#define B3_MAT3x3_H\0A#ifndef B3_QUAT_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_QUAT_H\0A#ifdef __cplusplus\0A#else\0Atypedef struct\0A{\0A\09b3Float4 m_row[3];\0A}b3Mat3x3;\0A#define b3Mat3x3ConstArg const b3Mat3x3\0A#define b3GetRow(m,row) (m.m_row[row])\0Ainline b3Mat3x3 b3QuatGetRotationMatrix(b3Quat quat)\0A{\0A\09b3Float4 quat2 = (b3Float4)(quat.x*quat.x, quat.y*quat.y, quat.z*quat.z, 0.f);\0A\09b3Mat3x3 out;\0A\09out.m_row[0].x=1-2*quat2.y-2*quat2.z;\0A\09out.m_row[0].y=2*quat.x*quat.y-2*quat.w*quat.z;\0A\09out.m_row[0].z=2*quat.x*quat.z+2*quat.w*quat.y;\0A\09out.m_row[0].w = 0.f;\0A\09out.m_row[1].x=2*quat.x*quat.y+2*quat.w*quat.z;\0A\09out.m_row[1].y=1-2*quat2.x-2*quat2.z;\0A\09out.m_row[1].z=2*quat.y*quat.z-2*quat.w*quat.x;\0A\09out.m_row[1].w = 0.f;\0A\09out.m_row[2].x=2*quat.x*quat.z-2*quat.w*quat.y;\0A\09out.m_row[2].y=2*quat.y*quat.z+2*quat.w*quat.x;\0A\09out.m_row[2].z=1-2*quat2.x-2*quat2.y;\0A\09out.m_row[2].w = 0.f;\0A\09return out;\0A}\0Ainline b3Mat3x3 b3AbsoluteMat3x3(b3Mat3x3ConstArg matIn)\0A{\0A\09b3Mat3x3 out;\0A\09out.m_row[0] = fabs(matIn.m_row[0]);\0A\09out.m_row[1] = fabs(matIn.m_row[1]);\0A\09out.m_row[2] = fabs(matIn.m_row[2]);\0A\09return out;\0A}\0A__inline\0Ab3Mat3x3 mtZero();\0A__inline\0Ab3Mat3x3 mtIdentity();\0A__inline\0Ab3Mat3x3 mtTranspose(b3Mat3x3 m);\0A__inline\0Ab3Mat3x3 mtMul(b3Mat3x3 a, b3Mat3x3 b);\0A__inline\0Ab3Float4 mtMul1(b3Mat3x3 a, b3Float4 b);\0A__inline\0Ab3Float4 mtMul3(b3Float4 a, b3Mat3x3 b);\0A__inline\0Ab3Mat3x3 mtZero()\0A{\0A\09b3Mat3x3 m;\0A\09m.m_row[0] = (b3Float4)(0.f);\0A\09m.m_row[1] = (b3Float4)(0.f);\0A\09m.m_row[2] = (b3Float4)(0.f);\0A\09return m;\0A}\0A__inline\0Ab3Mat3x3 mtIdentity()\0A{\0A\09b3Mat3x3 m;\0A\09m.m_row[0] = (b3Float4)(1,0,0,0);\0A\09m.m_row[1] = (b3Float4)(0,1,0,0);\0A\09m.m_row[2] = (b3Float4)(0,0,1,0);\0A\09return m;\0A}\0A__inline\0Ab3Mat3x3 mtTranspose(b3Mat3x3 m)\0A{\0A\09b3Mat3x3 out;\0A\09out.m_row[0] = (b3Float4)(m.m_row[0].x, m.m_row[1].x, m.m_row[2].x, 0.f);\0A\09out.m_row[1] = (b3Float4)(m.m_row[0].y, m.m_row[1].y, m.m_row[2].y, 0.f);\0A\09out.m_row[2] = (b3Float4)(m.m_row[0].z, m.m_row[1].z, m.m_row[2].z, 0.f);\0A\09return out;\0A}\0A__inline\0Ab3Mat3x3 mtMul(b3Mat3x3 a, b3Mat3x3 b)\0A{\0A\09b3Mat3x3 transB;\0A\09transB = mtTranspose( b );\0A\09b3Mat3x3 ans;\0A\09//\09why this doesn't run when 0ing in the for{}\0A\09a.m_row[0].w = 0.f;\0A\09a.m_row[1].w = 0.f;\0A\09a.m_row[2].w = 0.f;\0A\09for(int i=0; i<3; i++)\0A\09{\0A//\09a.m_row[i].w = 0.f;\0A\09\09ans.m_row[i].x = b3Dot3F4(a.m_row[i],transB.m_row[0]);\0A\09\09ans.m_row[i].y = b3Dot3F4(a.m_row[i],transB.m_row[1]);\0A\09\09ans.m_row[i].z = b3Dot3F4(a.m_row[i],transB.m_row[2]);\0A\09\09ans.m_row[i].w = 0.f;\0A\09}\0A\09return ans;\0A}\0A__inline\0Ab3Float4 mtMul1(b3Mat3x3 a, b3Float4 b)\0A{\0A\09b3Float4 ans;\0A\09ans.x = b3Dot3F4( a.m_row[0], b );\0A\09ans.y = b3Dot3F4( a.m_row[1], b );\0A\09ans.z = b3Dot3F4( a.m_row[2], b );\0A\09ans.w = 0.f;\0A\09return ans;\0A}\0A__inline\0Ab3Float4 mtMul3(b3Float4 a, b3Mat3x3 b)\0A{\0A\09b3Float4 colx = b3MakeFloat4(b.m_row[0].x, b.m_row[1].x, b.m_row[2].x, 0);\0A\09b3Float4 coly = b3MakeFloat4(b.m_row[0].y, b.m_row[1].y, b.m_row[2].y, 0);\0A\09b3Float4 colz = b3MakeFloat4(b.m_row[0].z, b.m_row[1].z, b.m_row[2].z, 0);\0A\09b3Float4 ans;\0A\09ans.x = b3Dot3F4( a, colx );\0A\09ans.y = b3Dot3F4( a, coly );\0A\09ans.z = b3Dot3F4( a, colz );\0A\09return ans;\0A}\0A#endif\0A#endif //B3_MAT3x3_H\0Atypedef struct b3RigidBodyData b3RigidBodyData_t;\0Astruct b3RigidBodyData\0A{\0A\09b3Float4\09\09\09\09m_pos;\0A\09b3Quat\09\09\09\09\09m_quat;\0A\09b3Float4\09\09\09\09m_linVel;\0A\09b3Float4\09\09\09\09m_angVel;\0A\09int \09\09\09\09\09m_collidableIdx;\0A\09float \09\09\09\09m_invMass;\0A\09float \09\09\09\09m_restituitionCoeff;\0A\09float \09\09\09\09m_frictionCoeff;\0A};\0Atypedef struct b3InertiaData b3InertiaData_t;\0Astruct b3InertiaData\0A{\0A\09b3Mat3x3 m_invInertiaWorld;\0A\09b3Mat3x3 m_initInvInertia;\0A};\0A#endif //B3_RIGIDBODY_DATA_H\0A\09\0A#ifndef B3_CONVEX_POLYHEDRON_DATA_H\0A#define B3_CONVEX_POLYHEDRON_DATA_H\0A#ifndef B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_FLOAT4_H\0A#ifndef B3_QUAT_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_QUAT_H\0Atypedef struct b3GpuFace b3GpuFace_t;\0Astruct b3GpuFace\0A{\0A\09b3Float4 m_plane;\0A\09int m_indexOffset;\0A\09int m_numIndices;\0A\09int m_unusedPadding1;\0A\09int m_unusedPadding2;\0A};\0Atypedef struct b3ConvexPolyhedronData b3ConvexPolyhedronData_t;\0Astruct b3ConvexPolyhedronData\0A{\0A\09b3Float4\09\09m_localCenter;\0A\09b3Float4\09\09m_extents;\0A\09b3Float4\09\09mC;\0A\09b3Float4\09\09mE;\0A\09float\09\09\09m_radius;\0A\09int\09m_faceOffset;\0A\09int m_numFaces;\0A\09int\09m_numVertices;\0A\09int m_vertexOffset;\0A\09int\09m_uniqueEdgesOffset;\0A\09int\09m_numUniqueEdges;\0A\09int m_unused;\0A};\0A#endif //B3_CONVEX_POLYHEDRON_DATA_H\0A#ifndef B3_COLLIDABLE_H\0A#define B3_COLLIDABLE_H\0A#ifndef B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_FLOAT4_H\0A#ifndef B3_QUAT_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_QUAT_H\0Aenum b3ShapeTypes\0A{\0A\09SHAPE_HEIGHT_FIELD=1,\0A\09SHAPE_CONVEX_HULL=3,\0A\09SHAPE_PLANE=4,\0A\09SHAPE_CONCAVE_TRIMESH=5,\0A\09SHAPE_COMPOUND_OF_CONVEX_HULLS=6,\0A\09SHAPE_SPHERE=7,\0A\09MAX_NUM_SHAPE_TYPES,\0A};\0Atypedef struct b3Collidable b3Collidable_t;\0Astruct b3Collidable\0A{\0A\09union {\0A\09\09int m_numChildShapes;\0A\09\09int m_bvhIndex;\0A\09};\0A\09union\0A\09{\0A\09\09float m_radius;\0A\09\09int\09m_compoundBvhIndex;\0A\09};\0A\09int m_shapeType;\0A\09int m_shapeIndex;\0A};\0Atypedef struct b3GpuChildShape b3GpuChildShape_t;\0Astruct b3GpuChildShape\0A{\0A\09b3Float4\09m_childPosition;\0A\09b3Quat\09\09m_childOrientation;\0A\09int m_shapeIndex;\0A\09int m_unused0;\0A\09int m_unused1;\0A\09int m_unused2;\0A};\0Astruct b3CompoundOverlappingPair\0A{\0A\09int m_bodyIndexA;\0A\09int m_bodyIndexB;\0A//\09int\09m_pairType;\0A\09int m_childShapeIndexA;\0A\09int m_childShapeIndexB;\0A};\0A#endif //B3_COLLIDABLE_H\0A#ifdef __cplusplus\0A#else\0A#define B3_MPR_SQRT sqrt\0A#endif\0A#define B3_MPR_FMIN(x, y) ((x) < (y) ? (x) : (y))\0A#define B3_MPR_FABS fabs\0A#define B3_MPR_TOLERANCE 1E-6f\0A#define B3_MPR_MAX_ITERATIONS 1000\0Astruct _b3MprSupport_t \0A{\0A    b3Float4 v;  //!< Support point in minkowski sum\0A    b3Float4 v1; //!< Support point in obj1\0A    b3Float4 v2; //!< Support point in obj2\0A};\0Atypedef struct _b3MprSupport_t b3MprSupport_t;\0Astruct _b3MprSimplex_t \0A{\0A    b3MprSupport_t ps[4];\0A    int last; //!< index of last added point\0A};\0Atypedef struct _b3MprSimplex_t b3MprSimplex_t;\0Ainline b3MprSupport_t* b3MprSimplexPointW(b3MprSimplex_t *s, int idx)\0A{\0A    return &s->ps[idx];\0A}\0Ainline void b3MprSimplexSetSize(b3MprSimplex_t *s, int size)\0A{\0A    s->last = size - 1;\0A}\0Ainline int b3MprSimplexSize(const b3MprSimplex_t *s)\0A{\0A    return s->last + 1;\0A}\0Ainline const b3MprSupport_t* b3MprSimplexPoint(const b3MprSimplex_t* s, int idx)\0A{\0A    // here is no check on boundaries\0A    return &s->ps[idx];\0A}\0Ainline void b3MprSupportCopy(b3MprSupport_t *d, const b3MprSupport_t *s)\0A{\0A    *d = *s;\0A}\0Ainline void b3MprSimplexSet(b3MprSimplex_t *s, size_t pos, const b3MprSupport_t *a)\0A{\0A    b3MprSupportCopy(s->ps + pos, a);\0A}\0Ainline void b3MprSimplexSwap(b3MprSimplex_t *s, size_t pos1, size_t pos2)\0A{\0A    b3MprSupport_t supp;\0A    b3MprSupportCopy(&supp, &s->ps[pos1]);\0A    b3MprSupportCopy(&s->ps[pos1], &s->ps[pos2]);\0A    b3MprSupportCopy(&s->ps[pos2], &supp);\0A}\0Ainline int b3MprIsZero(float val)\0A{\0A    return B3_MPR_FABS(val) < FLT_EPSILON;\0A}\0Ainline int b3MprEq(float _a, float _b)\0A{\0A    float ab;\0A    float a, b;\0A    ab = B3_MPR_FABS(_a - _b);\0A    if (B3_MPR_FABS(ab) < FLT_EPSILON)\0A        return 1;\0A    a = B3_MPR_FABS(_a);\0A    b = B3_MPR_FABS(_b);\0A    if (b > a){\0A        return ab < FLT_EPSILON * b;\0A    }else{\0A        return ab < FLT_EPSILON * a;\0A    }\0A}\0Ainline int b3MprVec3Eq(const b3Float4* a, const b3Float4 *b)\0A{\0A    return b3MprEq((*a).x, (*b).x)\0A            && b3MprEq((*a).y, (*b).y)\0A            && b3MprEq((*a).z, (*b).z);\0A}\0Ainline b3Float4 b3LocalGetSupportVertex(b3Float4ConstArg supportVec,__global const b3ConvexPolyhedronData_t* hull, \09b3ConstArray(b3Float4) verticesA)\0A{\0A\09b3Float4 supVec = b3MakeFloat4(0,0,0,0);\0A\09float maxDot = -B3_LARGE_FLOAT;\0A    if( 0 < hull->m_numVertices )\0A    {\0A        const b3Float4 scaled = supportVec;\0A\09\09int index = b3MaxDot(scaled, &verticesA[hull->m_vertexOffset], hull->m_numVertices, &maxDot);\0A        return verticesA[hull->m_vertexOffset+index];\0A    }\0A    return supVec;\0A}\0AB3_STATIC void b3MprConvexSupport(int pairIndex,int bodyIndex,  b3ConstArray(b3RigidBodyData_t) cpuBodyBuf, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3ConvexPolyhedronData_t) cpuConvexData, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3Collidable_t)\09\09\09\09cpuCollidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3Float4)\09\09\09\09\09cpuVertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global b3Float4* sepAxis,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09const b3Float4* _dir, b3Float4* outp, int logme)\0A{\0A\09//dir is in worldspace, move to local space\0A\09\0A\09b3Float4 pos = cpuBodyBuf[bodyIndex].m_pos;\0A\09b3Quat orn = cpuBodyBuf[bodyIndex].m_quat;\0A\09\0A\09b3Float4 dir = b3MakeFloat4((*_dir).x,(*_dir).y,(*_dir).z,0.f);\0A\09\0A\09const b3Float4 localDir = b3QuatRotate(b3QuatInverse(orn),dir);\0A\09\0A\09//find local support vertex\0A\09int colIndex = cpuBodyBuf[bodyIndex].m_collidableIdx;\0A\09\0A\09b3Assert(cpuCollidables[colIndex].m_shapeType==SHAPE_CONVEX_HULL);\0A\09__global const b3ConvexPolyhedronData_t* hull = &cpuConvexData[cpuCollidables[colIndex].m_shapeIndex];\0A\09\0A\09b3Float4 pInA;\0A\09if (logme)\0A\09{\0A\09\09b3Float4 supVec = b3MakeFloat4(0,0,0,0);\0A\09\09float maxDot = -B3_LARGE_FLOAT;\0A\09\09if( 0 < hull->m_numVertices )\0A\09\09{\0A\09\09\09const b3Float4 scaled = localDir;\0A\09\09\09int index = b3MaxDot(scaled, &cpuVertices[hull->m_vertexOffset], hull->m_numVertices, &maxDot);\0A\09\09\09pInA = cpuVertices[hull->m_vertexOffset+index];\0A\09\09\09\0A\09\09}\0A\09} else\0A\09{\0A\09\09pInA = b3LocalGetSupportVertex(localDir,hull,cpuVertices);\0A\09}\0A\09//move vertex to world space\0A\09*outp = b3TransformPoint(pInA,pos,orn);\0A\09\0A}\0Ainline void b3MprSupport(int pairIndex,int bodyIndexA, int bodyIndexB,   b3ConstArray(b3RigidBodyData_t) cpuBodyBuf, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3ConvexPolyhedronData_t) cpuConvexData, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3Collidable_t)\09\09\09\09cpuCollidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3Float4)\09\09\09\09\09cpuVertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global b3Float4* sepAxis,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09const b3Float4* _dir, b3MprSupport_t *supp)\0A{\0A    b3Float4 dir;\0A\09dir = *_dir;\0A\09b3MprConvexSupport(pairIndex,bodyIndexA,cpuBodyBuf,cpuConvexData,cpuCollidables,cpuVertices,sepAxis,&dir, &supp->v1,0);\0A    dir = *_dir*-1.f;\0A\09b3MprConvexSupport(pairIndex,bodyIndexB,cpuBodyBuf,cpuConvexData,cpuCollidables,cpuVertices,sepAxis,&dir, &supp->v2,0);\0A    supp->v = supp->v1 - supp->v2;\0A}\0Ainline void b3FindOrigin(int bodyIndexA, int bodyIndexB, b3ConstArray(b3RigidBodyData_t) cpuBodyBuf, b3MprSupport_t *center)\0A{\0A    center->v1 = cpuBodyBuf[bodyIndexA].m_pos;\0A\09center->v2 = cpuBodyBuf[bodyIndexB].m_pos;\0A    center->v = center->v1 - center->v2;\0A}\0Ainline void b3MprVec3Set(b3Float4 *v, float x, float y, float z)\0A{\0A\09(*v).x = x;\0A\09(*v).y = y;\0A\09(*v).z = z;\0A\09(*v).w = 0.f;\0A}\0Ainline void b3MprVec3Add(b3Float4 *v, const b3Float4 *w)\0A{\0A    (*v).x += (*w).x;\0A    (*v).y += (*w).y;\0A    (*v).z += (*w).z;\0A}\0Ainline void b3MprVec3Copy(b3Float4 *v, const b3Float4 *w)\0A{\0A    *v = *w;\0A}\0Ainline void b3MprVec3Scale(b3Float4 *d, float k)\0A{\0A    *d *= k;\0A}\0Ainline float b3MprVec3Dot(const b3Float4 *a, const b3Float4 *b)\0A{\0A    float dot;\0A\09dot = b3Dot3F4(*a,*b);\0A    return dot;\0A}\0Ainline float b3MprVec3Len2(const b3Float4 *v)\0A{\0A    return b3MprVec3Dot(v, v);\0A}\0Ainline void b3MprVec3Normalize(b3Float4 *d)\0A{\0A    float k = 1.f / B3_MPR_SQRT(b3MprVec3Len2(d));\0A    b3MprVec3Scale(d, k);\0A}\0Ainline void b3MprVec3Cross(b3Float4 *d, const b3Float4 *a, const b3Float4 *b)\0A{\0A\09*d = b3Cross3(*a,*b);\0A\09\0A}\0Ainline void b3MprVec3Sub2(b3Float4 *d, const b3Float4 *v, const b3Float4 *w)\0A{\0A\09*d = *v - *w;\0A}\0Ainline void b3PortalDir(const b3MprSimplex_t *portal, b3Float4 *dir)\0A{\0A    b3Float4 v2v1, v3v1;\0A    b3MprVec3Sub2(&v2v1, &b3MprSimplexPoint(portal, 2)->v,\0A                       &b3MprSimplexPoint(portal, 1)->v);\0A    b3MprVec3Sub2(&v3v1, &b3MprSimplexPoint(portal, 3)->v,\0A                       &b3MprSimplexPoint(portal, 1)->v);\0A    b3MprVec3Cross(dir, &v2v1, &v3v1);\0A    b3MprVec3Normalize(dir);\0A}\0Ainline int portalEncapsulesOrigin(const b3MprSimplex_t *portal,\0A                                       const b3Float4 *dir)\0A{\0A    float dot;\0A    dot = b3MprVec3Dot(dir, &b3MprSimplexPoint(portal, 1)->v);\0A    return b3MprIsZero(dot) || dot > 0.f;\0A}\0Ainline int portalReachTolerance(const b3MprSimplex_t *portal,\0A                                     const b3MprSupport_t *v4,\0A                                     const b3Float4 *dir)\0A{\0A    float dv1, dv2, dv3, dv4;\0A    float dot1, dot2, dot3;\0A    // find the smallest dot product of dir and {v1-v4, v2-v4, v3-v4}\0A    dv1 = b3MprVec3Dot(&b3MprSimplexPoint(portal, 1)->v, dir);\0A    dv2 = b3MprVec3Dot(&b3MprSimplexPoint(portal, 2)->v, dir);\0A    dv3 = b3MprVec3Dot(&b3MprSimplexPoint(portal, 3)->v, dir);\0A    dv4 = b3MprVec3Dot(&v4->v, dir);\0A    dot1 = dv4 - dv1;\0A    dot2 = dv4 - dv2;\0A    dot3 = dv4 - dv3;\0A    dot1 = B3_MPR_FMIN(dot1, dot2);\0A    dot1 = B3_MPR_FMIN(dot1, dot3);\0A    return b3MprEq(dot1, B3_MPR_TOLERANCE) || dot1 < B3_MPR_TOLERANCE;\0A}\0Ainline int portalCanEncapsuleOrigin(const b3MprSimplex_t *portal,   \0A                                         const b3MprSupport_t *v4,\0A                                         const b3Float4 *dir)\0A{\0A    float dot;\0A    dot = b3MprVec3Dot(&v4->v, dir);\0A    return b3MprIsZero(dot) || dot > 0.f;\0A}\0Ainline void b3ExpandPortal(b3MprSimplex_t *portal,\0A                              const b3MprSupport_t *v4)\0A{\0A    float dot;\0A    b3Float4 v4v0;\0A    b3MprVec3Cross(&v4v0, &v4->v, &b3MprSimplexPoint(portal, 0)->v);\0A    dot = b3MprVec3Dot(&b3MprSimplexPoint(portal, 1)->v, &v4v0);\0A    if (dot > 0.f){\0A        dot = b3MprVec3Dot(&b3MprSimplexPoint(portal, 2)->v, &v4v0);\0A        if (dot > 0.f){\0A            b3MprSimplexSet(portal, 1, v4);\0A        }else{\0A            b3MprSimplexSet(portal, 3, v4);\0A        }\0A    }else{\0A        dot = b3MprVec3Dot(&b3MprSimplexPoint(portal, 3)->v, &v4v0);\0A        if (dot > 0.f){\0A            b3MprSimplexSet(portal, 2, v4);\0A        }else{\0A            b3MprSimplexSet(portal, 1, v4);\0A        }\0A    }\0A}\0AB3_STATIC int b3DiscoverPortal(int pairIndex, int bodyIndexA, int bodyIndexB,  b3ConstArray(b3RigidBodyData_t) cpuBodyBuf, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3ConvexPolyhedronData_t) cpuConvexData, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3Collidable_t)\09\09\09\09cpuCollidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3Float4)\09\09\09\09\09cpuVertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global b3Float4* sepAxis,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global int*\09hasSepAxis,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3MprSimplex_t *portal)\0A{\0A    b3Float4 dir, va, vb;\0A    float dot;\0A    int cont;\0A\09\0A\09\0A    // vertex 0 is center of portal\0A    b3FindOrigin(bodyIndexA,bodyIndexB,cpuBodyBuf, b3MprSimplexPointW(portal, 0));\0A    // vertex 0 is center of portal\0A    b3MprSimplexSetSize(portal, 1);\0A\09\0A\09b3Float4 zero = b3MakeFloat4(0,0,0,0);\0A\09b3Float4* b3mpr_vec3_origin = &zero;\0A    if (b3MprVec3Eq(&b3MprSimplexPoint(portal, 0)->v, b3mpr_vec3_origin)){\0A        // Portal's center lies on origin (0,0,0) => we know that objects\0A        // intersect but we would need to know penetration info.\0A        // So move center little bit...\0A        b3MprVec3Set(&va, FLT_EPSILON * 10.f, 0.f, 0.f);\0A        b3MprVec3Add(&b3MprSimplexPointW(portal, 0)->v, &va);\0A    }\0A    // vertex 1 = support in direction of origin\0A    b3MprVec3Copy(&dir, &b3MprSimplexPoint(portal, 0)->v);\0A    b3MprVec3Scale(&dir, -1.f);\0A    b3MprVec3Normalize(&dir);\0A    b3MprSupport(pairIndex,bodyIndexA,bodyIndexB,cpuBodyBuf,cpuConvexData,cpuCollidables,cpuVertices, sepAxis,&dir, b3MprSimplexPointW(portal, 1));\0A    b3MprSimplexSetSize(portal, 2);\0A    // test if origin isn't outside of v1\0A    dot = b3MprVec3Dot(&b3MprSimplexPoint(portal, 1)->v, &dir);\0A\09\0A    if (b3MprIsZero(dot) || dot < 0.f)\0A        return -1;\0A    // vertex 2\0A    b3MprVec3Cross(&dir, &b3MprSimplexPoint(portal, 0)->v,\0A                       &b3MprSimplexPoint(portal, 1)->v);\0A    if (b3MprIsZero(b3MprVec3Len2(&dir))){\0A        if (b3MprVec3Eq(&b3MprSimplexPoint(portal, 1)->v, b3mpr_vec3_origin)){\0A            // origin lies on v1\0A            return 1;\0A        }else{\0A            // origin lies on v0-v1 segment\0A            return 2;\0A        }\0A    }\0A    b3MprVec3Normalize(&dir);\0A\09 b3MprSupport(pairIndex,bodyIndexA,bodyIndexB,cpuBodyBuf,cpuConvexData,cpuCollidables,cpuVertices, sepAxis,&dir, b3MprSimplexPointW(portal, 2));\0A    \0A    dot = b3MprVec3Dot(&b3MprSimplexPoint(portal, 2)->v, &dir);\0A    if (b3MprIsZero(dot) || dot < 0.f)\0A        return -1;\0A    b3MprSimplexSetSize(portal, 3);\0A    // vertex 3 direction\0A    b3MprVec3Sub2(&va, &b3MprSimplexPoint(portal, 1)->v,\0A                     &b3MprSimplexPoint(portal, 0)->v);\0A    b3MprVec3Sub2(&vb, &b3MprSimplexPoint(portal, 2)->v,\0A                     &b3MprSimplexPoint(portal, 0)->v);\0A    b3MprVec3Cross(&dir, &va, &vb);\0A    b3MprVec3Normalize(&dir);\0A    // it is better to form portal faces to be oriented \22outside\22 origin\0A    dot = b3MprVec3Dot(&dir, &b3MprSimplexPoint(portal, 0)->v);\0A    if (dot > 0.f){\0A        b3MprSimplexSwap(portal, 1, 2);\0A        b3MprVec3Scale(&dir, -1.f);\0A    }\0A    while (b3MprSimplexSize(portal) < 4){\0A\09\09 b3MprSupport(pairIndex,bodyIndexA,bodyIndexB,cpuBodyBuf,cpuConvexData,cpuCollidables,cpuVertices, sepAxis,&dir, b3MprSimplexPointW(portal, 3));\0A        \0A        dot = b3MprVec3Dot(&b3MprSimplexPoint(portal, 3)->v, &dir);\0A        if (b3MprIsZero(dot) || dot < 0.f)\0A            return -1;\0A        cont = 0;\0A        // test if origin is outside (v1, v0, v3) - set v2 as v3 and\0A        // continue\0A        b3MprVec3Cross(&va, &b3MprSimplexPoint(portal, 1)->v,\0A                          &b3MprSimplexPoint(portal, 3)->v);\0A        dot = b3MprVec3Dot(&va, &b3MprSimplexPoint(portal, 0)->v);\0A        if (dot < 0.f && !b3MprIsZero(dot)){\0A            b3MprSimplexSet(portal, 2, b3MprSimplexPoint(portal, 3));\0A            cont = 1;\0A        }\0A        if (!cont){\0A            // test if origin is outside (v3, v0, v2) - set v1 as v3 and\0A            // continue\0A            b3MprVec3Cross(&va, &b3MprSimplexPoint(portal, 3)->v,\0A                              &b3MprSimplexPoint(portal, 2)->v);\0A            dot = b3MprVec3Dot(&va, &b3MprSimplexPoint(portal, 0)->v);\0A            if (dot < 0.f && !b3MprIsZero(dot)){\0A                b3MprSimplexSet(portal, 1, b3MprSimplexPoint(portal, 3));\0A                cont = 1;\0A            }\0A        }\0A        if (cont){\0A            b3MprVec3Sub2(&va, &b3MprSimplexPoint(portal, 1)->v,\0A                             &b3MprSimplexPoint(portal, 0)->v);\0A            b3MprVec3Sub2(&vb, &b3MprSimplexPoint(portal, 2)->v,\0A                             &b3MprSimplexPoint(portal, 0)->v);\0A            b3MprVec3Cross(&dir, &va, &vb);\0A            b3MprVec3Normalize(&dir);\0A        }else{\0A            b3MprSimplexSetSize(portal, 4);\0A        }\0A    }\0A    return 0;\0A}\0AB3_STATIC int b3RefinePortal(int pairIndex,int bodyIndexA, int bodyIndexB,  b3ConstArray(b3RigidBodyData_t) cpuBodyBuf, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3ConvexPolyhedronData_t) cpuConvexData, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3Collidable_t)\09\09\09\09cpuCollidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3Float4)\09\09\09\09\09cpuVertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global b3Float4* sepAxis,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3MprSimplex_t *portal)\0A{\0A    b3Float4 dir;\0A    b3MprSupport_t v4;\0A\09for (int i=0;i<B3_MPR_MAX_ITERATIONS;i++)\0A    //while (1)\0A\09{\0A        // compute direction outside the portal (from v0 throught v1,v2,v3\0A        // face)\0A        b3PortalDir(portal, &dir);\0A        // test if origin is inside the portal\0A        if (portalEncapsulesOrigin(portal, &dir))\0A            return 0;\0A        // get next support point\0A        \0A\09\09 b3MprSupport(pairIndex,bodyIndexA,bodyIndexB,cpuBodyBuf,cpuConvexData,cpuCollidables,cpuVertices, sepAxis,&dir, &v4);\0A        // test if v4 can expand portal to contain origin and if portal\0A        // expanding doesn't reach given tolerance\0A        if (!portalCanEncapsuleOrigin(portal, &v4, &dir)\0A                || portalReachTolerance(portal, &v4, &dir))\0A\09\09{\0A            return -1;\0A        }\0A        // v1-v2-v3 triangle must be rearranged to face outside Minkowski\0A        // difference (direction from v0).\0A        b3ExpandPortal(portal, &v4);\0A    }\0A    return -1;\0A}\0AB3_STATIC void b3FindPos(const b3MprSimplex_t *portal, b3Float4 *pos)\0A{\0A\09b3Float4 zero = b3MakeFloat4(0,0,0,0);\0A\09b3Float4* b3mpr_vec3_origin = &zero;\0A    b3Float4 dir;\0A    size_t i;\0A    float b[4], sum, inv;\0A    b3Float4 vec, p1, p2;\0A    b3PortalDir(portal, &dir);\0A    // use barycentric coordinates of tetrahedron to find origin\0A    b3MprVec3Cross(&vec, &b3MprSimplexPoint(portal, 1)->v,\0A                       &b3MprSimplexPoint(portal, 2)->v);\0A    b[0] = b3MprVec3Dot(&vec, &b3MprSimplexPoint(portal, 3)->v);\0A    b3MprVec3Cross(&vec, &b3MprSimplexPoint(portal, 3)->v,\0A                       &b3MprSimplexPoint(portal, 2)->v);\0A    b[1] = b3MprVec3Dot(&vec, &b3MprSimplexPoint(portal, 0)->v);\0A    b3MprVec3Cross(&vec, &b3MprSimplexPoint(portal, 0)->v,\0A                       &b3MprSimplexPoint(portal, 1)->v);\0A    b[2] = b3MprVec3Dot(&vec, &b3MprSimplexPoint(portal, 3)->v);\0A    b3MprVec3Cross(&vec, &b3MprSimplexPoint(portal, 2)->v,\0A                       &b3MprSimplexPoint(portal, 1)->v);\0A    b[3] = b3MprVec3Dot(&vec, &b3MprSimplexPoint(portal, 0)->v);\0A\09sum = b[0] + b[1] + b[2] + b[3];\0A    if (b3MprIsZero(sum) || sum < 0.f){\0A\09\09b[0] = 0.f;\0A        b3MprVec3Cross(&vec, &b3MprSimplexPoint(portal, 2)->v,\0A                           &b3MprSimplexPoint(portal, 3)->v);\0A        b[1] = b3MprVec3Dot(&vec, &dir);\0A        b3MprVec3Cross(&vec, &b3MprSimplexPoint(portal, 3)->v,\0A                           &b3MprSimplexPoint(portal, 1)->v);\0A        b[2] = b3MprVec3Dot(&vec, &dir);\0A        b3MprVec3Cross(&vec, &b3MprSimplexPoint(portal, 1)->v,\0A                           &b3MprSimplexPoint(portal, 2)->v);\0A        b[3] = b3MprVec3Dot(&vec, &dir);\0A\09\09sum = b[1] + b[2] + b[3];\0A\09}\0A\09inv = 1.f / sum;\0A    b3MprVec3Copy(&p1, b3mpr_vec3_origin);\0A    b3MprVec3Copy(&p2, b3mpr_vec3_origin);\0A    for (i = 0; i < 4; i++){\0A        b3MprVec3Copy(&vec, &b3MprSimplexPoint(portal, i)->v1);\0A        b3MprVec3Scale(&vec, b[i]);\0A        b3MprVec3Add(&p1, &vec);\0A        b3MprVec3Copy(&vec, &b3MprSimplexPoint(portal, i)->v2);\0A        b3MprVec3Scale(&vec, b[i]);\0A        b3MprVec3Add(&p2, &vec);\0A    }\0A    b3MprVec3Scale(&p1, inv);\0A    b3MprVec3Scale(&p2, inv);\0A    b3MprVec3Copy(pos, &p1);\0A    b3MprVec3Add(pos, &p2);\0A    b3MprVec3Scale(pos, 0.5);\0A}\0Ainline float b3MprVec3Dist2(const b3Float4 *a, const b3Float4 *b)\0A{\0A    b3Float4 ab;\0A    b3MprVec3Sub2(&ab, a, b);\0A    return b3MprVec3Len2(&ab);\0A}\0Ainline float _b3MprVec3PointSegmentDist2(const b3Float4 *P,\0A                                                  const b3Float4 *x0,\0A                                                  const b3Float4 *b,\0A                                                  b3Float4 *witness)\0A{\0A    // The computation comes from solving equation of segment:\0A    //      S(t) = x0 + t.d\0A    //          where - x0 is initial point of segment\0A    //                - d is direction of segment from x0 (|d| > 0)\0A    //                - t belongs to <0, 1> interval\0A    // \0A    // Than, distance from a segment to some point P can be expressed:\0A    //      D(t) = |x0 + t.d - P|^2\0A    //          which is distance from any point on segment. Minimization\0A    //          of this function brings distance from P to segment.\0A    // Minimization of D(t) leads to simple quadratic equation that's\0A    // solving is straightforward.\0A    //\0A    // Bonus of this method is witness point for free.\0A    float dist, t;\0A    b3Float4 d, a;\0A    // direction of segment\0A    b3MprVec3Sub2(&d, b, x0);\0A    // precompute vector from P to x0\0A    b3MprVec3Sub2(&a, x0, P);\0A    t  = -1.f * b3MprVec3Dot(&a, &d);\0A    t /= b3MprVec3Len2(&d);\0A    if (t < 0.f || b3MprIsZero(t)){\0A        dist = b3MprVec3Dist2(x0, P);\0A        if (witness)\0A            b3MprVec3Copy(witness, x0);\0A    }else if (t > 1.f || b3MprEq(t, 1.f)){\0A        dist = b3MprVec3Dist2(b, P);\0A        if (witness)\0A            b3MprVec3Copy(witness, b);\0A    }else{\0A        if (witness){\0A            b3MprVec3Copy(witness, &d);\0A            b3MprVec3Scale(witness, t);\0A            b3MprVec3Add(witness, x0);\0A            dist = b3MprVec3Dist2(witness, P);\0A        }else{\0A            // recycling variables\0A            b3MprVec3Scale(&d, t);\0A            b3MprVec3Add(&d, &a);\0A            dist = b3MprVec3Len2(&d);\0A        }\0A    }\0A    return dist;\0A}\0Ainline float b3MprVec3PointTriDist2(const b3Float4 *P,\0A                                const b3Float4 *x0, const b3Float4 *B,\0A                                const b3Float4 *C,\0A                                b3Float4 *witness)\0A{\0A    // Computation comes from analytic expression for triangle (x0, B, C)\0A    //      T(s, t) = x0 + s.d1 + t.d2, where d1 = B - x0 and d2 = C - x0 and\0A    // Then equation for distance is:\0A    //      D(s, t) = | T(s, t) - P |^2\0A    // This leads to minimization of quadratic function of two variables.\0A    // The solution from is taken only if s is between 0 and 1, t is\0A    // between 0 and 1 and t + s < 1, otherwise distance from segment is\0A    // computed.\0A    b3Float4 d1, d2, a;\0A    float u, v, w, p, q, r;\0A    float s, t, dist, dist2;\0A    b3Float4 witness2;\0A    b3MprVec3Sub2(&d1, B, x0);\0A    b3MprVec3Sub2(&d2, C, x0);\0A    b3MprVec3Sub2(&a, x0, P);\0A    u = b3MprVec3Dot(&a, &a);\0A    v = b3MprVec3Dot(&d1, &d1);\0A    w = b3MprVec3Dot(&d2, &d2);\0A    p = b3MprVec3Dot(&a, &d1);\0A    q = b3MprVec3Dot(&a, &d2);\0A    r = b3MprVec3Dot(&d1, &d2);\0A    s = (q * r - w * p) / (w * v - r * r);\0A    t = (-s * r - q) / w;\0A    if ((b3MprIsZero(s) || s > 0.f)\0A            && (b3MprEq(s, 1.f) || s < 1.f)\0A            && (b3MprIsZero(t) || t > 0.f)\0A            && (b3MprEq(t, 1.f) || t < 1.f)\0A            && (b3MprEq(t + s, 1.f) || t + s < 1.f)){\0A        if (witness){\0A            b3MprVec3Scale(&d1, s);\0A            b3MprVec3Scale(&d2, t);\0A            b3MprVec3Copy(witness, x0);\0A            b3MprVec3Add(witness, &d1);\0A            b3MprVec3Add(witness, &d2);\0A            dist = b3MprVec3Dist2(witness, P);\0A        }else{\0A            dist  = s * s * v;\0A            dist += t * t * w;\0A            dist += 2.f * s * t * r;\0A            dist += 2.f * s * p;\0A            dist += 2.f * t * q;\0A            dist += u;\0A        }\0A    }else{\0A        dist = _b3MprVec3PointSegmentDist2(P, x0, B, witness);\0A        dist2 = _b3MprVec3PointSegmentDist2(P, x0, C, &witness2);\0A        if (dist2 < dist){\0A            dist = dist2;\0A            if (witness)\0A                b3MprVec3Copy(witness, &witness2);\0A        }\0A        dist2 = _b3MprVec3PointSegmentDist2(P, B, C, &witness2);\0A        if (dist2 < dist){\0A            dist = dist2;\0A            if (witness)\0A                b3MprVec3Copy(witness, &witness2);\0A        }\0A    }\0A    return dist;\0A}\0AB3_STATIC void b3FindPenetr(int pairIndex,int bodyIndexA, int bodyIndexB,  b3ConstArray(b3RigidBodyData_t) cpuBodyBuf, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3ConvexPolyhedronData_t) cpuConvexData, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3Collidable_t)\09\09\09\09cpuCollidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09b3ConstArray(b3Float4)\09\09\09\09\09cpuVertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global b3Float4* sepAxis,\0A                       b3MprSimplex_t *portal,\0A                       float *depth, b3Float4 *pdir, b3Float4 *pos)\0A{\0A    b3Float4 dir;\0A    b3MprSupport_t v4;\0A    unsigned long iterations;\0A\09b3Float4 zero = b3MakeFloat4(0,0,0,0);\0A\09b3Float4* b3mpr_vec3_origin = &zero;\0A    iterations = 1UL;\0A\09for (int i=0;i<B3_MPR_MAX_ITERATIONS;i++)\0A    //while (1)\0A\09{\0A        // compute portal direction and obtain next support point\0A        b3PortalDir(portal, &dir);\0A        \0A\09\09 b3MprSupport(pairIndex,bodyIndexA,bodyIndexB,cpuBodyBuf,cpuConvexData,cpuCollidables,cpuVertices, sepAxis,&dir, &v4);\0A        // reached tolerance -> find penetration info\0A        if (portalReachTolerance(portal, &v4, &dir)\0A                || iterations ==B3_MPR_MAX_ITERATIONS)\0A\09\09{\0A            *depth = b3MprVec3PointTriDist2(b3mpr_vec3_origin,&b3MprSimplexPoint(portal, 1)->v,&b3MprSimplexPoint(portal, 2)->v,&b3MprSimplexPoint(portal, 3)->v,pdir);\0A            *depth = B3_MPR_SQRT(*depth);\0A\09\09\09\0A\09\09\09if (b3MprIsZero((*pdir).x) && b3MprIsZero((*pdir).y) && b3MprIsZero((*pdir).z))\0A\09\09\09{\0A\09\09\09\09\0A\09\09\09\09*pdir = dir;\0A\09\09\09} \0A\09\09\09b3MprVec3Normalize(pdir);\0A\09\09\09\0A            // barycentric coordinates:\0A            b3FindPos(portal, pos);\0A            return;\0A        }\0A        b3ExpandPortal(portal, &v4);\0A        iterations++;\0A    }\0A}\0AB3_STATIC void b3FindPenetrTouch(b3MprSimplex_t *portal,float *depth, b3Float4 *dir, b3Float4 *pos)\0A{\0A    // Touching contact on portal's v1 - so depth is zero and direction\0A    // is unimportant and pos can be guessed\0A    *depth = 0.f;\0A    b3Float4 zero = b3MakeFloat4(0,0,0,0);\0A\09b3Float4* b3mpr_vec3_origin = &zero;\0A\09b3MprVec3Copy(dir, b3mpr_vec3_origin);\0A    b3MprVec3Copy(pos, &b3MprSimplexPoint(portal, 1)->v1);\0A    b3MprVec3Add(pos, &b3MprSimplexPoint(portal, 1)->v2);\0A    b3MprVec3Scale(pos, 0.5);\0A}\0AB3_STATIC void b3FindPenetrSegment(b3MprSimplex_t *portal,\0A                              float *depth, b3Float4 *dir, b3Float4 *pos)\0A{\0A    \0A    // Origin lies on v0-v1 segment.\0A    // Depth is distance to v1, direction also and position must be\0A    // computed\0A    b3MprVec3Copy(pos, &b3MprSimplexPoint(portal, 1)->v1);\0A    b3MprVec3Add(pos, &b3MprSimplexPoint(portal, 1)->v2);\0A    b3MprVec3Scale(pos, 0.5f);\0A    \0A    b3MprVec3Copy(dir, &b3MprSimplexPoint(portal, 1)->v);\0A    *depth = B3_MPR_SQRT(b3MprVec3Len2(dir));\0A    b3MprVec3Normalize(dir);\0A}\0Ainline int b3MprPenetration(int pairIndex, int bodyIndexA, int bodyIndexB,\0A\09\09\09\09\09b3ConstArray(b3RigidBodyData_t) cpuBodyBuf,\0A\09\09\09\09\09b3ConstArray(b3ConvexPolyhedronData_t) cpuConvexData, \0A\09\09\09\09\09b3ConstArray(b3Collidable_t)\09cpuCollidables,\0A\09\09\09\09\09b3ConstArray(b3Float4)\09cpuVertices,\0A\09\09\09\09\09__global b3Float4* sepAxis,\0A\09\09\09\09\09__global int*\09hasSepAxis,\0A\09\09\09\09\09float *depthOut, b3Float4* dirOut, b3Float4* posOut)\0A{\0A\09\0A\09 b3MprSimplex_t portal;\0A\09 \0A//\09if (!hasSepAxis[pairIndex])\0A\09//\09return -1;\0A\09\0A\09hasSepAxis[pairIndex] = 0;\0A\09 int res;\0A    // Phase 1: Portal discovery\0A    res = b3DiscoverPortal(pairIndex,bodyIndexA,bodyIndexB,cpuBodyBuf,cpuConvexData,cpuCollidables,cpuVertices,sepAxis,hasSepAxis, &portal);\0A\09\0A\09  \0A\09//sepAxis[pairIndex] = *pdir;//or -dir?\0A\09switch (res)\0A\09{\0A\09case 0:\0A\09\09{\0A\09\09\09// Phase 2: Portal refinement\0A\09\09\0A\09\09\09res = b3RefinePortal(pairIndex,bodyIndexA,bodyIndexB,cpuBodyBuf,cpuConvexData,cpuCollidables,cpuVertices, sepAxis,&portal);\0A\09\09\09if (res < 0)\0A\09\09\09\09return -1;\0A\09\09\09// Phase 3. Penetration info\0A\09\09\09b3FindPenetr(pairIndex,bodyIndexA,bodyIndexB,cpuBodyBuf,cpuConvexData,cpuCollidables,cpuVertices, sepAxis,&portal, depthOut, dirOut, posOut);\0A\09\09\09hasSepAxis[pairIndex] = 1;\0A\09\09\09sepAxis[pairIndex] = -*dirOut;\0A\09\09\09break;\0A\09\09}\0A\09case 1:\0A\09\09{\0A\09\09\09 // Touching contact on portal's v1.\0A\09\09\09b3FindPenetrTouch(&portal, depthOut, dirOut, posOut);\0A\09\09\09break;\0A\09\09}\0A\09case 2:\0A\09\09{\0A\09\09\09\0A\09\09\09b3FindPenetrSegment( &portal, depthOut, dirOut, posOut);\0A\09\09\09break;\0A\09\09}\0A\09default:\0A\09\09{\0A\09\09\09hasSepAxis[pairIndex]=0;\0A\09\09\09//if (res < 0)\0A\09\09\09//{\0A\09\09\09\09// Origin isn't inside portal - no collision.\0A\09\09\09\09return -1;\0A\09\09\09//}\0A\09\09}\0A\09};\0A\09\0A\09return 0;\0A};\0A#endif //B3_MPR_PENETRATION_H\0A#ifndef B3_CONTACT4DATA_H\0A#define B3_CONTACT4DATA_H\0A#ifndef B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_FLOAT4_H\0Atypedef  struct b3Contact4Data b3Contact4Data_t;\0Astruct b3Contact4Data\0A{\0A\09b3Float4\09m_worldPosB[4];\0A//\09b3Float4\09m_localPosA[4];\0A//\09b3Float4\09m_localPosB[4];\0A\09b3Float4\09m_worldNormalOnB;\09//\09w: m_nPoints\0A\09unsigned short  m_restituitionCoeffCmp;\0A\09unsigned short  m_frictionCoeffCmp;\0A\09int m_batchIdx;\0A\09int m_bodyAPtrAndSignBit;//x:m_bodyAPtr, y:m_bodyBPtr\0A\09int m_bodyBPtrAndSignBit;\0A\09int\09m_childIndexA;\0A\09int\09m_childIndexB;\0A\09int m_unused1;\0A\09int m_unused2;\0A};\0Ainline int b3Contact4Data_getNumPoints(const struct b3Contact4Data* contact)\0A{\0A\09return (int)contact->m_worldNormalOnB.w;\0A};\0Ainline void b3Contact4Data_setNumPoints(struct b3Contact4Data* contact, int numPoints)\0A{\0A\09contact->m_worldNormalOnB.w = (float)numPoints;\0A};\0A#endif //B3_CONTACT4DATA_H\0A#define AppendInc(x, out) out = atomic_inc(x)\0A#define GET_NPOINTS(x) (x).m_worldNormalOnB.w\0A#ifdef cl_ext_atomic_counters_32\0A\09#pragma OPENCL EXTENSION cl_ext_atomic_counters_32 : enable\0A#else\0A\09#define counter32_t volatile __global int*\0A#endif\0A__kernel void   mprPenetrationKernel( __global int4* pairs,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3RigidBodyData_t* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3Collidable_t* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3ConvexPolyhedronData_t* convexShapes, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* vertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global float4* separatingNormals,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global int* hasSeparatingAxis,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global struct b3Contact4Data* restrict globalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09counter32_t nGlobalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int contactCapacity,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numPairs)\0A{\0A\09int i = get_global_id(0);\0A\09int pairIndex = i;\0A\09if (i<numPairs)\0A\09{\0A\09\09int bodyIndexA = pairs[i].x;\0A\09\09int bodyIndexB = pairs[i].y;\0A\09\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09\0A\09\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09\09\0A\09\09\0A\09\09//once the broadphase avoids static-static pairs, we can remove this test\0A\09\09if ((rigidBodies[bodyIndexA].m_invMass==0) &&(rigidBodies[bodyIndexB].m_invMass==0))\0A\09\09{\0A\09\09\09return;\0A\09\09}\0A\09\09\0A\09\09if ((collidables[collidableIndexA].m_shapeType!=SHAPE_CONVEX_HULL) ||(collidables[collidableIndexB].m_shapeType!=SHAPE_CONVEX_HULL))\0A\09\09{\0A\09\09\09return;\0A\09\09}\0A\09\09float depthOut;\0A\09\09b3Float4 dirOut;\0A\09\09b3Float4 posOut;\0A\09\09int res = b3MprPenetration(pairIndex, bodyIndexA, bodyIndexB,rigidBodies,convexShapes,collidables,vertices,separatingNormals,hasSeparatingAxis,&depthOut, &dirOut, &posOut);\0A\09\09\0A\09\09\0A\09\09\0A\09\09\0A\09\09if (res==0)\0A\09\09{\0A\09\09\09//add a contact\0A\09\09\09int dstIdx;\0A\09\09\09AppendInc( nGlobalContactsOut, dstIdx );\0A\09\09\09if (dstIdx<contactCapacity)\0A\09\09\09{\0A\09\09\09\09pairs[pairIndex].z = dstIdx;\0A\09\09\09\09__global struct b3Contact4Data* c = globalContactsOut + dstIdx;\0A\09\09\09\09c->m_worldNormalOnB = -dirOut;//normal;\0A\09\09\09\09c->m_restituitionCoeffCmp = (0.f*0xffff);c->m_frictionCoeffCmp = (0.7f*0xffff);\0A\09\09\09\09c->m_batchIdx = pairIndex;\0A\09\09\09\09int bodyA = pairs[pairIndex].x;\0A\09\09\09\09int bodyB = pairs[pairIndex].y;\0A\09\09\09\09c->m_bodyAPtrAndSignBit = rigidBodies[bodyA].m_invMass==0 ? -bodyA:bodyA;\0A\09\09\09\09c->m_bodyBPtrAndSignBit = rigidBodies[bodyB].m_invMass==0 ? -bodyB:bodyB;\0A\09\09\09\09c->m_childIndexA = -1;\0A\09\09\09\09c->m_childIndexB = -1;\0A\09\09\09\09//for (int i=0;i<nContacts;i++)\0A\09\09\09\09posOut.w = -depthOut;\0A\09\09\09\09c->m_worldPosB[0] = posOut;//localPoints[contactIdx[i]];\0A\09\09\09\09GET_NPOINTS(*c) = 1;//nContacts;\0A\09\09\09}\0A\09\09}\0A\09}\0A}\0Atypedef float4 Quaternion;\0A#define make_float4 (float4)\0A__inline\0Afloat dot3F4(float4 a, float4 b)\0A{\0A\09float4 a1 = make_float4(a.xyz,0.f);\0A\09float4 b1 = make_float4(b.xyz,0.f);\0A\09return dot(a1, b1);\0A}\0A__inline\0Afloat4 cross3(float4 a, float4 b)\0A{\0A\09return cross(a,b);\0A}\0A__inline\0AQuaternion qtMul(Quaternion a, Quaternion b)\0A{\0A\09Quaternion ans;\0A\09ans = cross3( a, b );\0A\09ans += a.w*b+b.w*a;\0A//\09ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);\0A\09ans.w = a.w*b.w - dot3F4(a, b);\0A\09return ans;\0A}\0A__inline\0AQuaternion qtInvert(Quaternion q)\0A{\0A\09return (Quaternion)(-q.xyz, q.w);\0A}\0A__inline\0Afloat4 qtRotate(Quaternion q, float4 vec)\0A{\0A\09Quaternion qInv = qtInvert( q );\0A\09float4 vcpy = vec;\0A\09vcpy.w = 0.f;\0A\09float4 out = qtMul(qtMul(q,vcpy),qInv);\0A\09return out;\0A}\0A__inline\0Afloat4 transform(const float4* p, const float4* translation, const Quaternion* orientation)\0A{\0A\09return qtRotate( *orientation, *p ) + (*translation);\0A}\0A__inline\0Afloat4 qtInvRotate(const Quaternion q, float4 vec)\0A{\0A\09return qtRotate( qtInvert( q ), vec );\0A}\0Ainline void project(__global const b3ConvexPolyhedronData_t* hull,  const float4 pos, const float4 orn, \0Aconst float4* dir, __global const float4* vertices, float* min, float* max)\0A{\0A\09min[0] = FLT_MAX;\0A\09max[0] = -FLT_MAX;\0A\09int numVerts = hull->m_numVertices;\0A\09const float4 localDir = qtInvRotate(orn,*dir);\0A\09float offset = dot(pos,*dir);\0A\09for(int i=0;i<numVerts;i++)\0A\09{\0A\09\09float dp = dot(vertices[hull->m_vertexOffset+i],localDir);\0A\09\09if(dp < min[0])\09\0A\09\09\09min[0] = dp;\0A\09\09if(dp > max[0])\09\0A\09\09\09max[0] = dp;\0A\09}\0A\09if(min[0]>max[0])\0A\09{\0A\09\09float tmp = min[0];\0A\09\09min[0] = max[0];\0A\09\09max[0] = tmp;\0A\09}\0A\09min[0] += offset;\0A\09max[0] += offset;\0A}\0Abool findSeparatingAxisUnitSphere(\09__global const b3ConvexPolyhedronData_t* hullA, __global const b3ConvexPolyhedronData_t* hullB, \0A\09const float4 posA1,\0A\09const float4 ornA,\0A\09const float4 posB1,\0A\09const float4 ornB,\0A\09const float4 DeltaC2,\0A\09__global const float4* vertices,\0A\09__global const float4* unitSphereDirections,\0A\09int numUnitSphereDirections,\0A\09float4* sep,\0A\09float* dmin)\0A{\0A\09\0A\09float4 posA = posA1;\0A\09posA.w = 0.f;\0A\09float4 posB = posB1;\0A\09posB.w = 0.f;\0A\09int curPlaneTests=0;\0A\09int curEdgeEdge = 0;\0A\09// Test unit sphere directions\0A\09for (int i=0;i<numUnitSphereDirections;i++)\0A\09{\0A\09\09float4 crossje;\0A\09\09crossje = unitSphereDirections[i];\09\0A\09\09if (dot3F4(DeltaC2,crossje)>0)\0A\09\09\09crossje *= -1.f;\0A\09\09{\0A\09\09\09float dist;\0A\09\09\09bool result = true;\0A\09\09\09float Min0,Max0;\0A\09\09\09float Min1,Max1;\0A\09\09\09project(hullA,posA,ornA,&crossje,vertices, &Min0, &Max0);\0A\09\09\09project(hullB,posB,ornB,&crossje,vertices, &Min1, &Max1);\0A\09\09\0A\09\09\09if(Max0<Min1 || Max1<Min0)\0A\09\09\09\09return false;\0A\09\09\0A\09\09\09float d0 = Max0 - Min1;\0A\09\09\09float d1 = Max1 - Min0;\0A\09\09\09dist = d0<d1 ? d0:d1;\0A\09\09\09result = true;\0A\09\0A\09\09\09if(dist<*dmin)\0A\09\09\09{\0A\09\09\09\09*dmin = dist;\0A\09\09\09\09*sep = crossje;\0A\09\09\09}\0A\09\09}\0A\09}\0A\09\0A\09if((dot3F4(-DeltaC2,*sep))>0.0f)\0A\09{\0A\09\09*sep = -(*sep);\0A\09}\0A\09return true;\0A}\0A__kernel void   findSeparatingAxisUnitSphereKernel( __global const int4* pairs, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3RigidBodyData_t* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3Collidable_t* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3ConvexPolyhedronData_t* convexShapes, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* vertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* unitSphereDirections,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global  float4* separatingNormals,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global  int* hasSeparatingAxis,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global  float* dmins,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numUnitSphereDirections,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numPairs\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09)\0A{\0A\09int i = get_global_id(0);\0A\09\0A\09if (i<numPairs)\0A\09{\0A\09\09if (hasSeparatingAxis[i])\0A\09\09{\0A\09\0A\09\09\09int bodyIndexA = pairs[i].x;\0A\09\09\09int bodyIndexB = pairs[i].y;\0A\09\0A\09\09\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09\09\0A\09\09\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09\09\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09\09\09\0A\09\09\09\0A\09\09\09int numFacesA = convexShapes[shapeIndexA].m_numFaces;\0A\09\0A\09\09\09float dmin = dmins[i];\0A\09\0A\09\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09\09posA.w = 0.f;\0A\09\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09posB.w = 0.f;\0A\09\09\09float4 c0local = convexShapes[shapeIndexA].m_localCenter;\0A\09\09\09float4 ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09\09float4 c0 = transform(&c0local, &posA, &ornA);\0A\09\09\09float4 c1local = convexShapes[shapeIndexB].m_localCenter;\0A\09\09\09float4 ornB =rigidBodies[bodyIndexB].m_quat;\0A\09\09\09float4 c1 = transform(&c1local,&posB,&ornB);\0A\09\09\09const float4 DeltaC2 = c0 - c1;\0A\09\09\09float4 sepNormal = separatingNormals[i];\0A\09\09\09\0A\09\09\09int numEdgeEdgeDirections = convexShapes[shapeIndexA].m_numUniqueEdges*convexShapes[shapeIndexB].m_numUniqueEdges;\0A\09\09\09if (numEdgeEdgeDirections>numUnitSphereDirections)\0A\09\09\09{\0A\09\09\09\09bool sepEE = findSeparatingAxisUnitSphere(\09&convexShapes[shapeIndexA], &convexShapes[shapeIndexB],posA,ornA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09posB,ornB,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09DeltaC2,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09vertices,unitSphereDirections,numUnitSphereDirections,&sepNormal,&dmin);\0A\09\09\09\09if (!sepEE)\0A\09\09\09\09{\0A\09\09\09\09\09hasSeparatingAxis[i] = 0;\0A\09\09\09\09} else\0A\09\09\09\09{\0A\09\09\09\09\09hasSeparatingAxis[i] = 1;\0A\09\09\09\09\09separatingNormals[i] = sepNormal;\0A\09\09\09\09}\0A\09\09\09}\0A\09\09}\09\09//if (hasSeparatingAxis[i])\0A\09}//(i<numPairs)\0A}\0A\00", align 1
@.str.67 = private unnamed_addr constant [42233 x i8] c"//keep this enum in sync with the CPU version (in btCollidable.h)\0A//written by Erwin Coumans\0A#define SHAPE_CONVEX_HULL 3\0A#define SHAPE_CONCAVE_TRIMESH 5\0A#define TRIANGLE_NUM_CONVEX_FACES 5\0A#define SHAPE_COMPOUND_OF_CONVEX_HULLS 6\0A#define B3_MAX_STACK_DEPTH 256\0Atypedef unsigned int u32;\0A///keep this in sync with btCollidable.h\0Atypedef struct\0A{\0A\09union {\0A\09\09int m_numChildShapes;\0A\09\09int m_bvhIndex;\0A\09};\0A\09union\0A\09{\0A\09\09float m_radius;\0A\09\09int\09m_compoundBvhIndex;\0A\09};\0A\09\0A\09int m_shapeType;\0A\09int m_shapeIndex;\0A\09\0A} btCollidableGpu;\0A#define MAX_NUM_PARTS_IN_BITS 10\0A///b3QuantizedBvhNode is a compressed aabb node, 16 bytes.\0A///Node can be used for leafnode or internal node. Leafnodes can point to 32-bit triangle index (non-negative range).\0Atypedef struct\0A{\0A\09//12 bytes\0A\09unsigned short int\09m_quantizedAabbMin[3];\0A\09unsigned short int\09m_quantizedAabbMax[3];\0A\09//4 bytes\0A\09int\09m_escapeIndexOrTriangleIndex;\0A} b3QuantizedBvhNode;\0Atypedef struct\0A{\0A\09float4\09\09m_aabbMin;\0A\09float4\09\09m_aabbMax;\0A\09float4\09\09m_quantization;\0A\09int\09\09\09m_numNodes;\0A\09int\09\09\09m_numSubTrees;\0A\09int\09\09\09m_nodeOffset;\0A\09int\09\09\09m_subTreeOffset;\0A} b3BvhInfo;\0Aint\09getTriangleIndex(const b3QuantizedBvhNode* rootNode)\0A{\0A\09unsigned int x=0;\0A\09unsigned int y = (~(x&0))<<(31-MAX_NUM_PARTS_IN_BITS);\0A\09// Get only the lower bits where the triangle index is stored\0A\09return (rootNode->m_escapeIndexOrTriangleIndex&~(y));\0A}\0Aint\09getTriangleIndexGlobal(__global const b3QuantizedBvhNode* rootNode)\0A{\0A\09unsigned int x=0;\0A\09unsigned int y = (~(x&0))<<(31-MAX_NUM_PARTS_IN_BITS);\0A\09// Get only the lower bits where the triangle index is stored\0A\09return (rootNode->m_escapeIndexOrTriangleIndex&~(y));\0A}\0Aint isLeafNode(const b3QuantizedBvhNode* rootNode)\0A{\0A\09//skipindex is negative (internal node), triangleindex >=0 (leafnode)\0A\09return (rootNode->m_escapeIndexOrTriangleIndex >= 0)? 1 : 0;\0A}\0Aint isLeafNodeGlobal(__global const b3QuantizedBvhNode* rootNode)\0A{\0A\09//skipindex is negative (internal node), triangleindex >=0 (leafnode)\0A\09return (rootNode->m_escapeIndexOrTriangleIndex >= 0)? 1 : 0;\0A}\0A\09\0Aint getEscapeIndex(const b3QuantizedBvhNode* rootNode)\0A{\0A\09return -rootNode->m_escapeIndexOrTriangleIndex;\0A}\0Aint getEscapeIndexGlobal(__global const b3QuantizedBvhNode* rootNode)\0A{\0A\09return -rootNode->m_escapeIndexOrTriangleIndex;\0A}\0Atypedef struct\0A{\0A\09//12 bytes\0A\09unsigned short int\09m_quantizedAabbMin[3];\0A\09unsigned short int\09m_quantizedAabbMax[3];\0A\09//4 bytes, points to the root of the subtree\0A\09int\09\09\09m_rootNodeIndex;\0A\09//4 bytes\0A\09int\09\09\09m_subtreeSize;\0A\09int\09\09\09m_padding[3];\0A} b3BvhSubtreeInfo;\0Atypedef struct\0A{\0A\09float4\09m_childPosition;\0A\09float4\09m_childOrientation;\0A\09int m_shapeIndex;\0A\09int m_unused0;\0A\09int m_unused1;\0A\09int m_unused2;\0A} btGpuChildShape;\0Atypedef struct\0A{\0A\09float4 m_pos;\0A\09float4 m_quat;\0A\09float4 m_linVel;\0A\09float4 m_angVel;\0A\09u32 m_collidableIdx;\0A\09float m_invMass;\0A\09float m_restituitionCoeff;\0A\09float m_frictionCoeff;\0A} BodyData;\0Atypedef struct  \0A{\0A\09float4\09\09m_localCenter;\0A\09float4\09\09m_extents;\0A\09float4\09\09mC;\0A\09float4\09\09mE;\0A\09\0A\09float\09\09\09m_radius;\0A\09int\09m_faceOffset;\0A\09int m_numFaces;\0A\09int\09m_numVertices;\0A\09int m_vertexOffset;\0A\09int\09m_uniqueEdgesOffset;\0A\09int\09m_numUniqueEdges;\0A\09int m_unused;\0A} ConvexPolyhedronCL;\0Atypedef struct \0A{\0A\09union\0A\09{\0A\09\09float4\09m_min;\0A\09\09float   m_minElems[4];\0A\09\09int\09\09\09m_minIndices[4];\0A\09};\0A\09union\0A\09{\0A\09\09float4\09m_max;\0A\09\09float   m_maxElems[4];\0A\09\09int\09\09\09m_maxIndices[4];\0A\09};\0A} btAabbCL;\0A#ifndef B3_AABB_H\0A#define B3_AABB_H\0A#ifndef B3_FLOAT4_H\0A#define B3_FLOAT4_H\0A#ifndef B3_PLATFORM_DEFINITIONS_H\0A#define B3_PLATFORM_DEFINITIONS_H\0Astruct MyTest\0A{\0A\09int bla;\0A};\0A#ifdef __cplusplus\0A#else\0A//keep B3_LARGE_FLOAT*B3_LARGE_FLOAT < FLT_MAX\0A#define B3_LARGE_FLOAT 1e18f\0A#define B3_INFINITY 1e18f\0A#define b3Assert(a)\0A#define b3ConstArray(a) __global const a*\0A#define b3AtomicInc atomic_inc\0A#define b3AtomicAdd atomic_add\0A#define b3Fabs fabs\0A#define b3Sqrt native_sqrt\0A#define b3Sin native_sin\0A#define b3Cos native_cos\0A#define B3_STATIC\0A#endif\0A#endif\0A#ifdef __cplusplus\0A#else\0A\09typedef float4\09b3Float4;\0A\09#define b3Float4ConstArg const b3Float4\0A\09#define b3MakeFloat4 (float4)\0A\09float b3Dot3F4(b3Float4ConstArg v0,b3Float4ConstArg v1)\0A\09{\0A\09\09float4 a1 = b3MakeFloat4(v0.xyz,0.f);\0A\09\09float4 b1 = b3MakeFloat4(v1.xyz,0.f);\0A\09\09return dot(a1, b1);\0A\09}\0A\09b3Float4 b3Cross3(b3Float4ConstArg v0,b3Float4ConstArg v1)\0A\09{\0A\09\09float4 a1 = b3MakeFloat4(v0.xyz,0.f);\0A\09\09float4 b1 = b3MakeFloat4(v1.xyz,0.f);\0A\09\09return cross(a1, b1);\0A\09}\0A\09#define b3MinFloat4 min\0A\09#define b3MaxFloat4 max\0A\09#define b3Normalized(a) normalize(a)\0A#endif \0A\09\09\0Ainline bool b3IsAlmostZero(b3Float4ConstArg v)\0A{\0A\09if(b3Fabs(v.x)>1e-6 || b3Fabs(v.y)>1e-6 || b3Fabs(v.z)>1e-6)\09\0A\09\09return false;\0A\09return true;\0A}\0Ainline int    b3MaxDot( b3Float4ConstArg vec, __global const b3Float4* vecArray, int vecLen, float* dotOut )\0A{\0A    float maxDot = -B3_INFINITY;\0A    int i = 0;\0A    int ptIndex = -1;\0A    for( i = 0; i < vecLen; i++ )\0A    {\0A        float dot = b3Dot3F4(vecArray[i],vec);\0A            \0A        if( dot > maxDot )\0A        {\0A            maxDot = dot;\0A            ptIndex = i;\0A        }\0A    }\0A\09b3Assert(ptIndex>=0);\0A    if (ptIndex<0)\0A\09{\0A\09\09ptIndex = 0;\0A\09}\0A    *dotOut = maxDot;\0A    return ptIndex;\0A}\0A#endif //B3_FLOAT4_H\0A#ifndef B3_MAT3x3_H\0A#define B3_MAT3x3_H\0A#ifndef B3_QUAT_H\0A#define B3_QUAT_H\0A#ifndef B3_PLATFORM_DEFINITIONS_H\0A#ifdef __cplusplus\0A#else\0A#endif\0A#endif\0A#ifndef B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A\09typedef float4\09b3Quat;\0A\09#define b3QuatConstArg const b3Quat\0A\09\0A\09\0Ainline float4 b3FastNormalize4(float4 v)\0A{\0A\09v = (float4)(v.xyz,0.f);\0A\09return fast_normalize(v);\0A}\0A\09\0Ainline b3Quat b3QuatMul(b3Quat a, b3Quat b);\0Ainline b3Quat b3QuatNormalized(b3QuatConstArg in);\0Ainline b3Quat b3QuatRotate(b3QuatConstArg q, b3QuatConstArg vec);\0Ainline b3Quat b3QuatInvert(b3QuatConstArg q);\0Ainline b3Quat b3QuatInverse(b3QuatConstArg q);\0Ainline b3Quat b3QuatMul(b3QuatConstArg a, b3QuatConstArg b)\0A{\0A\09b3Quat ans;\0A\09ans = b3Cross3( a, b );\0A\09ans += a.w*b+b.w*a;\0A//\09ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);\0A\09ans.w = a.w*b.w - b3Dot3F4(a, b);\0A\09return ans;\0A}\0Ainline b3Quat b3QuatNormalized(b3QuatConstArg in)\0A{\0A\09b3Quat q;\0A\09q=in;\0A\09//return b3FastNormalize4(in);\0A\09float len = native_sqrt(dot(q, q));\0A\09if(len > 0.f)\0A\09{\0A\09\09q *= 1.f / len;\0A\09}\0A\09else\0A\09{\0A\09\09q.x = q.y = q.z = 0.f;\0A\09\09q.w = 1.f;\0A\09}\0A\09return q;\0A}\0Ainline float4 b3QuatRotate(b3QuatConstArg q, b3QuatConstArg vec)\0A{\0A\09b3Quat qInv = b3QuatInvert( q );\0A\09float4 vcpy = vec;\0A\09vcpy.w = 0.f;\0A\09float4 out = b3QuatMul(b3QuatMul(q,vcpy),qInv);\0A\09return out;\0A}\0Ainline b3Quat b3QuatInverse(b3QuatConstArg q)\0A{\0A\09return (b3Quat)(-q.xyz, q.w);\0A}\0Ainline b3Quat b3QuatInvert(b3QuatConstArg q)\0A{\0A\09return (b3Quat)(-q.xyz, q.w);\0A}\0Ainline float4 b3QuatInvRotate(b3QuatConstArg q, b3QuatConstArg vec)\0A{\0A\09return b3QuatRotate( b3QuatInvert( q ), vec );\0A}\0Ainline b3Float4 b3TransformPoint(b3Float4ConstArg point, b3Float4ConstArg translation, b3QuatConstArg  orientation)\0A{\0A\09return b3QuatRotate( orientation, point ) + (translation);\0A}\0A\09\0A#endif \0A#endif //B3_QUAT_H\0A#ifdef __cplusplus\0A#else\0Atypedef struct\0A{\0A\09b3Float4 m_row[3];\0A}b3Mat3x3;\0A#define b3Mat3x3ConstArg const b3Mat3x3\0A#define b3GetRow(m,row) (m.m_row[row])\0Ainline b3Mat3x3 b3QuatGetRotationMatrix(b3Quat quat)\0A{\0A\09b3Float4 quat2 = (b3Float4)(quat.x*quat.x, quat.y*quat.y, quat.z*quat.z, 0.f);\0A\09b3Mat3x3 out;\0A\09out.m_row[0].x=1-2*quat2.y-2*quat2.z;\0A\09out.m_row[0].y=2*quat.x*quat.y-2*quat.w*quat.z;\0A\09out.m_row[0].z=2*quat.x*quat.z+2*quat.w*quat.y;\0A\09out.m_row[0].w = 0.f;\0A\09out.m_row[1].x=2*quat.x*quat.y+2*quat.w*quat.z;\0A\09out.m_row[1].y=1-2*quat2.x-2*quat2.z;\0A\09out.m_row[1].z=2*quat.y*quat.z-2*quat.w*quat.x;\0A\09out.m_row[1].w = 0.f;\0A\09out.m_row[2].x=2*quat.x*quat.z-2*quat.w*quat.y;\0A\09out.m_row[2].y=2*quat.y*quat.z+2*quat.w*quat.x;\0A\09out.m_row[2].z=1-2*quat2.x-2*quat2.y;\0A\09out.m_row[2].w = 0.f;\0A\09return out;\0A}\0Ainline b3Mat3x3 b3AbsoluteMat3x3(b3Mat3x3ConstArg matIn)\0A{\0A\09b3Mat3x3 out;\0A\09out.m_row[0] = fabs(matIn.m_row[0]);\0A\09out.m_row[1] = fabs(matIn.m_row[1]);\0A\09out.m_row[2] = fabs(matIn.m_row[2]);\0A\09return out;\0A}\0A__inline\0Ab3Mat3x3 mtZero();\0A__inline\0Ab3Mat3x3 mtIdentity();\0A__inline\0Ab3Mat3x3 mtTranspose(b3Mat3x3 m);\0A__inline\0Ab3Mat3x3 mtMul(b3Mat3x3 a, b3Mat3x3 b);\0A__inline\0Ab3Float4 mtMul1(b3Mat3x3 a, b3Float4 b);\0A__inline\0Ab3Float4 mtMul3(b3Float4 a, b3Mat3x3 b);\0A__inline\0Ab3Mat3x3 mtZero()\0A{\0A\09b3Mat3x3 m;\0A\09m.m_row[0] = (b3Float4)(0.f);\0A\09m.m_row[1] = (b3Float4)(0.f);\0A\09m.m_row[2] = (b3Float4)(0.f);\0A\09return m;\0A}\0A__inline\0Ab3Mat3x3 mtIdentity()\0A{\0A\09b3Mat3x3 m;\0A\09m.m_row[0] = (b3Float4)(1,0,0,0);\0A\09m.m_row[1] = (b3Float4)(0,1,0,0);\0A\09m.m_row[2] = (b3Float4)(0,0,1,0);\0A\09return m;\0A}\0A__inline\0Ab3Mat3x3 mtTranspose(b3Mat3x3 m)\0A{\0A\09b3Mat3x3 out;\0A\09out.m_row[0] = (b3Float4)(m.m_row[0].x, m.m_row[1].x, m.m_row[2].x, 0.f);\0A\09out.m_row[1] = (b3Float4)(m.m_row[0].y, m.m_row[1].y, m.m_row[2].y, 0.f);\0A\09out.m_row[2] = (b3Float4)(m.m_row[0].z, m.m_row[1].z, m.m_row[2].z, 0.f);\0A\09return out;\0A}\0A__inline\0Ab3Mat3x3 mtMul(b3Mat3x3 a, b3Mat3x3 b)\0A{\0A\09b3Mat3x3 transB;\0A\09transB = mtTranspose( b );\0A\09b3Mat3x3 ans;\0A\09//\09why this doesn't run when 0ing in the for{}\0A\09a.m_row[0].w = 0.f;\0A\09a.m_row[1].w = 0.f;\0A\09a.m_row[2].w = 0.f;\0A\09for(int i=0; i<3; i++)\0A\09{\0A//\09a.m_row[i].w = 0.f;\0A\09\09ans.m_row[i].x = b3Dot3F4(a.m_row[i],transB.m_row[0]);\0A\09\09ans.m_row[i].y = b3Dot3F4(a.m_row[i],transB.m_row[1]);\0A\09\09ans.m_row[i].z = b3Dot3F4(a.m_row[i],transB.m_row[2]);\0A\09\09ans.m_row[i].w = 0.f;\0A\09}\0A\09return ans;\0A}\0A__inline\0Ab3Float4 mtMul1(b3Mat3x3 a, b3Float4 b)\0A{\0A\09b3Float4 ans;\0A\09ans.x = b3Dot3F4( a.m_row[0], b );\0A\09ans.y = b3Dot3F4( a.m_row[1], b );\0A\09ans.z = b3Dot3F4( a.m_row[2], b );\0A\09ans.w = 0.f;\0A\09return ans;\0A}\0A__inline\0Ab3Float4 mtMul3(b3Float4 a, b3Mat3x3 b)\0A{\0A\09b3Float4 colx = b3MakeFloat4(b.m_row[0].x, b.m_row[1].x, b.m_row[2].x, 0);\0A\09b3Float4 coly = b3MakeFloat4(b.m_row[0].y, b.m_row[1].y, b.m_row[2].y, 0);\0A\09b3Float4 colz = b3MakeFloat4(b.m_row[0].z, b.m_row[1].z, b.m_row[2].z, 0);\0A\09b3Float4 ans;\0A\09ans.x = b3Dot3F4( a, colx );\0A\09ans.y = b3Dot3F4( a, coly );\0A\09ans.z = b3Dot3F4( a, colz );\0A\09return ans;\0A}\0A#endif\0A#endif //B3_MAT3x3_H\0Atypedef struct b3Aabb b3Aabb_t;\0Astruct b3Aabb\0A{\0A\09union\0A\09{\0A\09\09float m_min[4];\0A\09\09b3Float4 m_minVec;\0A\09\09int m_minIndices[4];\0A\09};\0A\09union\0A\09{\0A\09\09float\09m_max[4];\0A\09\09b3Float4 m_maxVec;\0A\09\09int m_signedMaxIndices[4];\0A\09};\0A};\0Ainline void b3TransformAabb2(b3Float4ConstArg localAabbMin,b3Float4ConstArg localAabbMax, float margin,\0A\09\09\09\09\09\09b3Float4ConstArg pos,\0A\09\09\09\09\09\09b3QuatConstArg orn,\0A\09\09\09\09\09\09b3Float4* aabbMinOut,b3Float4* aabbMaxOut)\0A{\0A\09\09b3Float4 localHalfExtents = 0.5f*(localAabbMax-localAabbMin);\0A\09\09localHalfExtents+=b3MakeFloat4(margin,margin,margin,0.f);\0A\09\09b3Float4 localCenter = 0.5f*(localAabbMax+localAabbMin);\0A\09\09b3Mat3x3 m;\0A\09\09m = b3QuatGetRotationMatrix(orn);\0A\09\09b3Mat3x3 abs_b = b3AbsoluteMat3x3(m);\0A\09\09b3Float4 center = b3TransformPoint(localCenter,pos,orn);\0A\09\09\0A\09\09b3Float4 extent = b3MakeFloat4(b3Dot3F4(localHalfExtents,b3GetRow(abs_b,0)),\0A\09\09\09\09\09\09\09\09\09\09 b3Dot3F4(localHalfExtents,b3GetRow(abs_b,1)),\0A\09\09\09\09\09\09\09\09\09\09 b3Dot3F4(localHalfExtents,b3GetRow(abs_b,2)),\0A\09\09\09\09\09\09\09\09\09\09 0.f);\0A\09\09*aabbMinOut = center-extent;\0A\09\09*aabbMaxOut = center+extent;\0A}\0A/// conservative test for overlap between two aabbs\0Ainline bool b3TestAabbAgainstAabb(b3Float4ConstArg aabbMin1,b3Float4ConstArg aabbMax1,\0A\09\09\09\09\09\09\09\09b3Float4ConstArg aabbMin2, b3Float4ConstArg aabbMax2)\0A{\0A\09bool overlap = true;\0A\09overlap = (aabbMin1.x > aabbMax2.x || aabbMax1.x < aabbMin2.x) ? false : overlap;\0A\09overlap = (aabbMin1.z > aabbMax2.z || aabbMax1.z < aabbMin2.z) ? false : overlap;\0A\09overlap = (aabbMin1.y > aabbMax2.y || aabbMax1.y < aabbMin2.y) ? false : overlap;\0A\09return overlap;\0A}\0A#endif //B3_AABB_H\0A/*\0ABullet Continuous Collision Detection and Physics Library\0ACopyright (c) 2003-2013 Erwin Coumans  http://bulletphysics.org\0AThis software is provided 'as-is', without any express or implied warranty.\0AIn no event will the authors be held liable for any damages arising from the use of this software.\0APermission is granted to anyone to use this software for any purpose,\0Aincluding commercial applications, and to alter it and redistribute it freely,\0Asubject to the following restrictions:\0A1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.\0A2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.\0A3. This notice may not be removed or altered from any source distribution.\0A*/\0A#ifndef B3_INT2_H\0A#define B3_INT2_H\0A#ifdef __cplusplus\0A#else\0A#define b3UnsignedInt2 uint2\0A#define b3Int2 int2\0A#define b3MakeInt2 (int2)\0A#endif //__cplusplus\0A#endif\0Atypedef struct\0A{\0A\09float4 m_plane;\0A\09int m_indexOffset;\0A\09int m_numIndices;\0A} btGpuFace;\0A#define make_float4 (float4)\0A__inline\0Afloat4 cross3(float4 a, float4 b)\0A{\0A\09return cross(a,b);\0A\09\0A//\09float4 a1 = make_float4(a.xyz,0.f);\0A//\09float4 b1 = make_float4(b.xyz,0.f);\0A//\09return cross(a1,b1);\0A//float4 c = make_float4(a.y*b.z - a.z*b.y,a.z*b.x - a.x*b.z,a.x*b.y - a.y*b.x,0.f);\0A\09\0A\09//\09float4 c = make_float4(a.y*b.z - a.z*b.y,1.f,a.x*b.y - a.y*b.x,0.f);\0A\09\0A\09//return c;\0A}\0A__inline\0Afloat dot3F4(float4 a, float4 b)\0A{\0A\09float4 a1 = make_float4(a.xyz,0.f);\0A\09float4 b1 = make_float4(b.xyz,0.f);\0A\09return dot(a1, b1);\0A}\0A__inline\0Afloat4 fastNormalize4(float4 v)\0A{\0A\09v = make_float4(v.xyz,0.f);\0A\09return fast_normalize(v);\0A}\0A///////////////////////////////////////\0A//\09Quaternion\0A///////////////////////////////////////\0Atypedef float4 Quaternion;\0A__inline\0AQuaternion qtMul(Quaternion a, Quaternion b);\0A__inline\0AQuaternion qtNormalize(Quaternion in);\0A__inline\0Afloat4 qtRotate(Quaternion q, float4 vec);\0A__inline\0AQuaternion qtInvert(Quaternion q);\0A__inline\0AQuaternion qtMul(Quaternion a, Quaternion b)\0A{\0A\09Quaternion ans;\0A\09ans = cross3( a, b );\0A\09ans += a.w*b+b.w*a;\0A//\09ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);\0A\09ans.w = a.w*b.w - dot3F4(a, b);\0A\09return ans;\0A}\0A__inline\0AQuaternion qtNormalize(Quaternion in)\0A{\0A\09return fastNormalize4(in);\0A//\09in /= length( in );\0A//\09return in;\0A}\0A__inline\0Afloat4 qtRotate(Quaternion q, float4 vec)\0A{\0A\09Quaternion qInv = qtInvert( q );\0A\09float4 vcpy = vec;\0A\09vcpy.w = 0.f;\0A\09float4 out = qtMul(qtMul(q,vcpy),qInv);\0A\09return out;\0A}\0A__inline\0AQuaternion qtInvert(Quaternion q)\0A{\0A\09return (Quaternion)(-q.xyz, q.w);\0A}\0A__inline\0Afloat4 qtInvRotate(const Quaternion q, float4 vec)\0A{\0A\09return qtRotate( qtInvert( q ), vec );\0A}\0A__inline\0Afloat4 transform(const float4* p, const float4* translation, const Quaternion* orientation)\0A{\0A\09return qtRotate( *orientation, *p ) + (*translation);\0A}\0A__inline\0Afloat4 normalize3(const float4 a)\0A{\0A\09float4 n = make_float4(a.x, a.y, a.z, 0.f);\0A\09return fastNormalize4( n );\0A}\0Ainline void projectLocal(const ConvexPolyhedronCL* hull,  const float4 pos, const float4 orn, \0Aconst float4* dir, const float4* vertices, float* min, float* max)\0A{\0A\09min[0] = FLT_MAX;\0A\09max[0] = -FLT_MAX;\0A\09int numVerts = hull->m_numVertices;\0A\09const float4 localDir = qtInvRotate(orn,*dir);\0A\09float offset = dot(pos,*dir);\0A\09for(int i=0;i<numVerts;i++)\0A\09{\0A\09\09float dp = dot(vertices[hull->m_vertexOffset+i],localDir);\0A\09\09if(dp < min[0])\09\0A\09\09\09min[0] = dp;\0A\09\09if(dp > max[0])\09\0A\09\09\09max[0] = dp;\0A\09}\0A\09if(min[0]>max[0])\0A\09{\0A\09\09float tmp = min[0];\0A\09\09min[0] = max[0];\0A\09\09max[0] = tmp;\0A\09}\0A\09min[0] += offset;\0A\09max[0] += offset;\0A}\0Ainline void project(__global const ConvexPolyhedronCL* hull,  const float4 pos, const float4 orn, \0Aconst float4* dir, __global const float4* vertices, float* min, float* max)\0A{\0A\09min[0] = FLT_MAX;\0A\09max[0] = -FLT_MAX;\0A\09int numVerts = hull->m_numVertices;\0A\09const float4 localDir = qtInvRotate(orn,*dir);\0A\09float offset = dot(pos,*dir);\0A\09for(int i=0;i<numVerts;i++)\0A\09{\0A\09\09float dp = dot(vertices[hull->m_vertexOffset+i],localDir);\0A\09\09if(dp < min[0])\09\0A\09\09\09min[0] = dp;\0A\09\09if(dp > max[0])\09\0A\09\09\09max[0] = dp;\0A\09}\0A\09if(min[0]>max[0])\0A\09{\0A\09\09float tmp = min[0];\0A\09\09min[0] = max[0];\0A\09\09max[0] = tmp;\0A\09}\0A\09min[0] += offset;\0A\09max[0] += offset;\0A}\0Ainline bool TestSepAxisLocalA(const ConvexPolyhedronCL* hullA, __global const ConvexPolyhedronCL* hullB, \0A\09const float4 posA,const float4 ornA,\0A\09const float4 posB,const float4 ornB,\0A\09float4* sep_axis, const float4* verticesA, __global const float4* verticesB,float* depth)\0A{\0A\09float Min0,Max0;\0A\09float Min1,Max1;\0A\09projectLocal(hullA,posA,ornA,sep_axis,verticesA, &Min0, &Max0);\0A\09project(hullB,posB,ornB, sep_axis,verticesB, &Min1, &Max1);\0A\09if(Max0<Min1 || Max1<Min0)\0A\09\09return false;\0A\09float d0 = Max0 - Min1;\0A\09float d1 = Max1 - Min0;\0A\09*depth = d0<d1 ? d0:d1;\0A\09return true;\0A}\0Ainline bool IsAlmostZero(const float4 v)\0A{\0A\09if(fabs(v.x)>1e-6f || fabs(v.y)>1e-6f || fabs(v.z)>1e-6f)\0A\09\09return false;\0A\09return true;\0A}\0Abool findSeparatingAxisLocalA(\09const ConvexPolyhedronCL* hullA, __global const ConvexPolyhedronCL* hullB, \0A\09const float4 posA1,\0A\09const float4 ornA,\0A\09const float4 posB1,\0A\09const float4 ornB,\0A\09const float4 DeltaC2,\0A\09\0A\09const float4* verticesA, \0A\09const float4* uniqueEdgesA, \0A\09const btGpuFace* facesA,\0A\09const int*  indicesA,\0A\09__global const float4* verticesB, \0A\09__global const float4* uniqueEdgesB, \0A\09__global const btGpuFace* facesB,\0A\09__global const int*  indicesB,\0A\09float4* sep,\0A\09float* dmin)\0A{\0A\09\0A\09float4 posA = posA1;\0A\09posA.w = 0.f;\0A\09float4 posB = posB1;\0A\09posB.w = 0.f;\0A\09int curPlaneTests=0;\0A\09{\0A\09\09int numFacesA = hullA->m_numFaces;\0A\09\09// Test normals from hullA\0A\09\09for(int i=0;i<numFacesA;i++)\0A\09\09{\0A\09\09\09const float4 normal = facesA[hullA->m_faceOffset+i].m_plane;\0A\09\09\09float4 faceANormalWS = qtRotate(ornA,normal);\0A\09\09\09if (dot3F4(DeltaC2,faceANormalWS)<0)\0A\09\09\09\09faceANormalWS*=-1.f;\0A\09\09\09curPlaneTests++;\0A\09\09\09float d;\0A\09\09\09if(!TestSepAxisLocalA( hullA, hullB, posA,ornA,posB,ornB,&faceANormalWS, verticesA, verticesB,&d))\0A\09\09\09\09return false;\0A\09\09\09if(d<*dmin)\0A\09\09\09{\0A\09\09\09\09*dmin = d;\0A\09\09\09\09*sep = faceANormalWS;\0A\09\09\09}\0A\09\09}\0A\09}\0A\09if((dot3F4(-DeltaC2,*sep))>0.0f)\0A\09{\0A\09\09*sep = -(*sep);\0A\09}\0A\09return true;\0A}\0Abool findSeparatingAxisLocalB(\09__global const ConvexPolyhedronCL* hullA,  const ConvexPolyhedronCL* hullB, \0A\09const float4 posA1,\0A\09const float4 ornA,\0A\09const float4 posB1,\0A\09const float4 ornB,\0A\09const float4 DeltaC2,\0A\09__global const float4* verticesA, \0A\09__global const float4* uniqueEdgesA, \0A\09__global const btGpuFace* facesA,\0A\09__global const int*  indicesA,\0A\09const float4* verticesB,\0A\09const float4* uniqueEdgesB, \0A\09const btGpuFace* facesB,\0A\09const int*  indicesB,\0A\09float4* sep,\0A\09float* dmin)\0A{\0A\09float4 posA = posA1;\0A\09posA.w = 0.f;\0A\09float4 posB = posB1;\0A\09posB.w = 0.f;\0A\09int curPlaneTests=0;\0A\09{\0A\09\09int numFacesA = hullA->m_numFaces;\0A\09\09// Test normals from hullA\0A\09\09for(int i=0;i<numFacesA;i++)\0A\09\09{\0A\09\09\09const float4 normal = facesA[hullA->m_faceOffset+i].m_plane;\0A\09\09\09float4 faceANormalWS = qtRotate(ornA,normal);\0A\09\09\09if (dot3F4(DeltaC2,faceANormalWS)<0)\0A\09\09\09\09faceANormalWS *= -1.f;\0A\09\09\09curPlaneTests++;\0A\09\09\09float d;\0A\09\09\09if(!TestSepAxisLocalA( hullB, hullA, posB,ornB,posA,ornA, &faceANormalWS, verticesB,verticesA, &d))\0A\09\09\09\09return false;\0A\09\09\09if(d<*dmin)\0A\09\09\09{\0A\09\09\09\09*dmin = d;\0A\09\09\09\09*sep = faceANormalWS;\0A\09\09\09}\0A\09\09}\0A\09}\0A\09if((dot3F4(-DeltaC2,*sep))>0.0f)\0A\09{\0A\09\09*sep = -(*sep);\0A\09}\0A\09return true;\0A}\0Abool findSeparatingAxisEdgeEdgeLocalA(\09const ConvexPolyhedronCL* hullA, __global const ConvexPolyhedronCL* hullB, \0A\09const float4 posA1,\0A\09const float4 ornA,\0A\09const float4 posB1,\0A\09const float4 ornB,\0A\09const float4 DeltaC2,\0A\09const float4* verticesA, \0A\09const float4* uniqueEdgesA, \0A\09const btGpuFace* facesA,\0A\09const int*  indicesA,\0A\09__global const float4* verticesB, \0A\09__global const float4* uniqueEdgesB, \0A\09__global const btGpuFace* facesB,\0A\09__global const int*  indicesB,\0A\09\09float4* sep,\0A\09float* dmin)\0A{\0A\09float4 posA = posA1;\0A\09posA.w = 0.f;\0A\09float4 posB = posB1;\0A\09posB.w = 0.f;\0A\09int curPlaneTests=0;\0A\09int curEdgeEdge = 0;\0A\09// Test edges\0A\09for(int e0=0;e0<hullA->m_numUniqueEdges;e0++)\0A\09{\0A\09\09const float4 edge0 = uniqueEdgesA[hullA->m_uniqueEdgesOffset+e0];\0A\09\09float4 edge0World = qtRotate(ornA,edge0);\0A\09\09for(int e1=0;e1<hullB->m_numUniqueEdges;e1++)\0A\09\09{\0A\09\09\09const float4 edge1 = uniqueEdgesB[hullB->m_uniqueEdgesOffset+e1];\0A\09\09\09float4 edge1World = qtRotate(ornB,edge1);\0A\09\09\09float4 crossje = cross3(edge0World,edge1World);\0A\09\09\09curEdgeEdge++;\0A\09\09\09if(!IsAlmostZero(crossje))\0A\09\09\09{\0A\09\09\09\09crossje = normalize3(crossje);\0A\09\09\09\09if (dot3F4(DeltaC2,crossje)<0)\0A\09\09\09\09\09crossje *= -1.f;\0A\09\09\09\09float dist;\0A\09\09\09\09bool result = true;\0A\09\09\09\09{\0A\09\09\09\09\09float Min0,Max0;\0A\09\09\09\09\09float Min1,Max1;\0A\09\09\09\09\09projectLocal(hullA,posA,ornA,&crossje,verticesA, &Min0, &Max0);\0A\09\09\09\09\09project(hullB,posB,ornB,&crossje,verticesB, &Min1, &Max1);\0A\09\09\09\09\0A\09\09\09\09\09if(Max0<Min1 || Max1<Min0)\0A\09\09\09\09\09\09result = false;\0A\09\09\09\09\0A\09\09\09\09\09float d0 = Max0 - Min1;\0A\09\09\09\09\09float d1 = Max1 - Min0;\0A\09\09\09\09\09dist = d0<d1 ? d0:d1;\0A\09\09\09\09\09result = true;\0A\09\09\09\09}\0A\09\09\09\09\0A\09\09\09\09if(dist<*dmin)\0A\09\09\09\09{\0A\09\09\09\09\09*dmin = dist;\0A\09\09\09\09\09*sep = crossje;\0A\09\09\09\09}\0A\09\09\09}\0A\09\09}\0A\09}\0A\09\0A\09if((dot3F4(-DeltaC2,*sep))>0.0f)\0A\09{\0A\09\09*sep = -(*sep);\0A\09}\0A\09return true;\0A}\0Ainline int\09findClippingFaces(const float4 separatingNormal,\0A                      const ConvexPolyhedronCL* hullA, \0A\09\09\09\09\09  __global const ConvexPolyhedronCL* hullB,\0A                      const float4 posA, const Quaternion ornA,const float4 posB, const Quaternion ornB,\0A                       __global float4* worldVertsA1,\0A                      __global float4* worldNormalsA1,\0A                      __global float4* worldVertsB1,\0A                      int capacityWorldVerts,\0A                      const float minDist, float maxDist,\0A\09\09\09\09\09  const float4* verticesA,\0A                      const btGpuFace* facesA,\0A                      const int* indicesA,\0A\09\09\09\09\09  __global const float4* verticesB,\0A                      __global const btGpuFace* facesB,\0A                      __global const int* indicesB,\0A                      __global int4* clippingFaces, int pairIndex)\0A{\0A\09int numContactsOut = 0;\0A\09int numWorldVertsB1= 0;\0A    \0A    \0A\09int closestFaceB=0;\0A\09float dmax = -FLT_MAX;\0A    \0A\09{\0A\09\09for(int face=0;face<hullB->m_numFaces;face++)\0A\09\09{\0A\09\09\09const float4 Normal = make_float4(facesB[hullB->m_faceOffset+face].m_plane.x,\0A                                              facesB[hullB->m_faceOffset+face].m_plane.y, facesB[hullB->m_faceOffset+face].m_plane.z,0.f);\0A\09\09\09const float4 WorldNormal = qtRotate(ornB, Normal);\0A\09\09\09float d = dot3F4(WorldNormal,separatingNormal);\0A\09\09\09if (d > dmax)\0A\09\09\09{\0A\09\09\09\09dmax = d;\0A\09\09\09\09closestFaceB = face;\0A\09\09\09}\0A\09\09}\0A\09}\0A    \0A\09{\0A\09\09const btGpuFace polyB = facesB[hullB->m_faceOffset+closestFaceB];\0A\09\09int numVertices = polyB.m_numIndices;\0A        if (numVertices>capacityWorldVerts)\0A            numVertices = capacityWorldVerts;\0A        if (numVertices<0)\0A            numVertices = 0;\0A        \0A\09\09for(int e0=0;e0<numVertices;e0++)\0A\09\09{\0A            if (e0<capacityWorldVerts)\0A            {\0A                const float4 b = verticesB[hullB->m_vertexOffset+indicesB[polyB.m_indexOffset+e0]];\0A                worldVertsB1[pairIndex*capacityWorldVerts+numWorldVertsB1++] = transform(&b,&posB,&ornB);\0A            }\0A\09\09}\0A\09}\0A    \0A    int closestFaceA=0;\0A\09{\0A\09\09float dmin = FLT_MAX;\0A\09\09for(int face=0;face<hullA->m_numFaces;face++)\0A\09\09{\0A\09\09\09const float4 Normal = make_float4(\0A                                              facesA[hullA->m_faceOffset+face].m_plane.x,\0A                                              facesA[hullA->m_faceOffset+face].m_plane.y,\0A                                              facesA[hullA->m_faceOffset+face].m_plane.z,\0A                                              0.f);\0A\09\09\09const float4 faceANormalWS = qtRotate(ornA,Normal);\0A            \0A\09\09\09float d = dot3F4(faceANormalWS,separatingNormal);\0A\09\09\09if (d < dmin)\0A\09\09\09{\0A\09\09\09\09dmin = d;\0A\09\09\09\09closestFaceA = face;\0A                worldNormalsA1[pairIndex] = faceANormalWS;\0A\09\09\09}\0A\09\09}\0A\09}\0A    \0A    int numVerticesA = facesA[hullA->m_faceOffset+closestFaceA].m_numIndices;\0A    if (numVerticesA>capacityWorldVerts)\0A       numVerticesA = capacityWorldVerts;\0A    if (numVerticesA<0)\0A        numVerticesA=0;\0A    \0A\09for(int e0=0;e0<numVerticesA;e0++)\0A\09{\0A        if (e0<capacityWorldVerts)\0A        {\0A            const float4 a = verticesA[hullA->m_vertexOffset+indicesA[facesA[hullA->m_faceOffset+closestFaceA].m_indexOffset+e0]];\0A            worldVertsA1[pairIndex*capacityWorldVerts+e0] = transform(&a, &posA,&ornA);\0A        }\0A    }\0A    \0A    clippingFaces[pairIndex].x = closestFaceA;\0A    clippingFaces[pairIndex].y = closestFaceB;\0A    clippingFaces[pairIndex].z = numVerticesA;\0A    clippingFaces[pairIndex].w = numWorldVertsB1;\0A    \0A    \0A\09return numContactsOut;\0A}\0A// work-in-progress\0A__kernel void   findConcaveSeparatingAxisVertexFaceKernel( __global int4* concavePairs,\0A                                                __global const BodyData* rigidBodies,\0A                                                __global const btCollidableGpu* collidables,\0A                                                __global const ConvexPolyhedronCL* convexShapes,\0A                                                __global const float4* vertices,\0A                                                __global const float4* uniqueEdges,\0A                                                __global const btGpuFace* faces,\0A                                                __global const int* indices,\0A                                                __global const btGpuChildShape* gpuChildShapes,\0A                                                __global btAabbCL* aabbs,\0A                                                __global float4* concaveSeparatingNormalsOut,\0A                                                __global int* concaveHasSeparatingNormals,\0A                                                __global int4* clippingFacesOut,\0A                                                __global float4* worldVertsA1GPU,\0A                                                __global float4*  worldNormalsAGPU,\0A                                                __global float4* worldVertsB1GPU,\0A                                                __global float* dmins,\0A                                                int vertexFaceCapacity,\0A                                                int numConcavePairs\0A                                                )\0A{\0A    \0A\09int i = get_global_id(0);\0A\09if (i>=numConcavePairs)\0A\09\09return;\0A    \0A\09concaveHasSeparatingNormals[i] = 0;\0A    \0A\09int pairIdx = i;\0A    \0A\09int bodyIndexA = concavePairs[i].x;\0A\09int bodyIndexB = concavePairs[i].y;\0A    \0A\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A    \0A\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A    \0A\09if (collidables[collidableIndexB].m_shapeType!=SHAPE_CONVEX_HULL&&\0A\09\09collidables[collidableIndexB].m_shapeType!=SHAPE_COMPOUND_OF_CONVEX_HULLS)\0A\09{\0A\09\09concavePairs[pairIdx].w = -1;\0A\09\09return;\0A\09}\0A    \0A    \0A    \0A\09int numFacesA = convexShapes[shapeIndexA].m_numFaces;\0A\09int numActualConcaveConvexTests = 0;\0A\09\0A\09int f = concavePairs[i].z;\0A\09\0A\09bool overlap = false;\0A\09\0A\09ConvexPolyhedronCL convexPolyhedronA;\0A    \0A\09//add 3 vertices of the triangle\0A\09convexPolyhedronA.m_numVertices = 3;\0A\09convexPolyhedronA.m_vertexOffset = 0;\0A\09float4\09localCenter = make_float4(0.f,0.f,0.f,0.f);\0A    \0A\09btGpuFace face = faces[convexShapes[shapeIndexA].m_faceOffset+f];\0A\09float4 triMinAabb, triMaxAabb;\0A\09btAabbCL triAabb;\0A\09triAabb.m_min = make_float4(1e30f,1e30f,1e30f,0.f);\0A\09triAabb.m_max = make_float4(-1e30f,-1e30f,-1e30f,0.f);\0A\09\0A\09float4 verticesA[3];\0A\09for (int i=0;i<3;i++)\0A\09{\0A\09\09int index = indices[face.m_indexOffset+i];\0A\09\09float4 vert = vertices[convexShapes[shapeIndexA].m_vertexOffset+index];\0A\09\09verticesA[i] = vert;\0A\09\09localCenter += vert;\0A        \0A\09\09triAabb.m_min = min(triAabb.m_min,vert);\0A\09\09triAabb.m_max = max(triAabb.m_max,vert);\0A        \0A\09}\0A    \0A\09overlap = true;\0A\09overlap = (triAabb.m_min.x > aabbs[bodyIndexB].m_max.x || triAabb.m_max.x < aabbs[bodyIndexB].m_min.x) ? false : overlap;\0A\09overlap = (triAabb.m_min.z > aabbs[bodyIndexB].m_max.z || triAabb.m_max.z < aabbs[bodyIndexB].m_min.z) ? false : overlap;\0A\09overlap = (triAabb.m_min.y > aabbs[bodyIndexB].m_max.y || triAabb.m_max.y < aabbs[bodyIndexB].m_min.y) ? false : overlap;\0A    \0A\09if (overlap)\0A\09{\0A\09\09float dmin = FLT_MAX;\0A\09\09int hasSeparatingAxis=5;\0A\09\09float4 sepAxis=make_float4(1,2,3,4);\0A        \0A\09\09int localCC=0;\0A\09\09numActualConcaveConvexTests++;\0A        \0A\09\09//a triangle has 3 unique edges\0A\09\09convexPolyhedronA.m_numUniqueEdges = 3;\0A\09\09convexPolyhedronA.m_uniqueEdgesOffset = 0;\0A\09\09float4 uniqueEdgesA[3];\0A\09\09\0A\09\09uniqueEdgesA[0] = (verticesA[1]-verticesA[0]);\0A\09\09uniqueEdgesA[1] = (verticesA[2]-verticesA[1]);\0A\09\09uniqueEdgesA[2] = (verticesA[0]-verticesA[2]);\0A        \0A        \0A\09\09convexPolyhedronA.m_faceOffset = 0;\0A        \0A\09\09float4 normal = make_float4(face.m_plane.x,face.m_plane.y,face.m_plane.z,0.f);\0A        \0A\09\09btGpuFace facesA[TRIANGLE_NUM_CONVEX_FACES];\0A\09\09int indicesA[3+3+2+2+2];\0A\09\09int curUsedIndices=0;\0A\09\09int fidx=0;\0A        \0A\09\09//front size of triangle\0A\09\09{\0A\09\09\09facesA[fidx].m_indexOffset=curUsedIndices;\0A\09\09\09indicesA[0] = 0;\0A\09\09\09indicesA[1] = 1;\0A\09\09\09indicesA[2] = 2;\0A\09\09\09curUsedIndices+=3;\0A\09\09\09float c = face.m_plane.w;\0A\09\09\09facesA[fidx].m_plane.x = normal.x;\0A\09\09\09facesA[fidx].m_plane.y = normal.y;\0A\09\09\09facesA[fidx].m_plane.z = normal.z;\0A\09\09\09facesA[fidx].m_plane.w = c;\0A\09\09\09facesA[fidx].m_numIndices=3;\0A\09\09}\0A\09\09fidx++;\0A\09\09//back size of triangle\0A\09\09{\0A\09\09\09facesA[fidx].m_indexOffset=curUsedIndices;\0A\09\09\09indicesA[3]=2;\0A\09\09\09indicesA[4]=1;\0A\09\09\09indicesA[5]=0;\0A\09\09\09curUsedIndices+=3;\0A\09\09\09float c = dot(normal,verticesA[0]);\0A\09\09\09float c1 = -face.m_plane.w;\0A\09\09\09facesA[fidx].m_plane.x = -normal.x;\0A\09\09\09facesA[fidx].m_plane.y = -normal.y;\0A\09\09\09facesA[fidx].m_plane.z = -normal.z;\0A\09\09\09facesA[fidx].m_plane.w = c;\0A\09\09\09facesA[fidx].m_numIndices=3;\0A\09\09}\0A\09\09fidx++;\0A        \0A\09\09bool addEdgePlanes = true;\0A\09\09if (addEdgePlanes)\0A\09\09{\0A\09\09\09int numVertices=3;\0A\09\09\09int prevVertex = numVertices-1;\0A\09\09\09for (int i=0;i<numVertices;i++)\0A\09\09\09{\0A\09\09\09\09float4 v0 = verticesA[i];\0A\09\09\09\09float4 v1 = verticesA[prevVertex];\0A                \0A\09\09\09\09float4 edgeNormal = normalize(cross(normal,v1-v0));\0A\09\09\09\09float c = -dot(edgeNormal,v0);\0A                \0A\09\09\09\09facesA[fidx].m_numIndices = 2;\0A\09\09\09\09facesA[fidx].m_indexOffset=curUsedIndices;\0A\09\09\09\09indicesA[curUsedIndices++]=i;\0A\09\09\09\09indicesA[curUsedIndices++]=prevVertex;\0A                \0A\09\09\09\09facesA[fidx].m_plane.x = edgeNormal.x;\0A\09\09\09\09facesA[fidx].m_plane.y = edgeNormal.y;\0A\09\09\09\09facesA[fidx].m_plane.z = edgeNormal.z;\0A\09\09\09\09facesA[fidx].m_plane.w = c;\0A\09\09\09\09fidx++;\0A\09\09\09\09prevVertex = i;\0A\09\09\09}\0A\09\09}\0A\09\09convexPolyhedronA.m_numFaces = TRIANGLE_NUM_CONVEX_FACES;\0A\09\09convexPolyhedronA.m_localCenter = localCenter*(1.f/3.f);\0A        \0A        \0A\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09posA.w = 0.f;\0A\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09posB.w = 0.f;\0A        \0A\09\09float4 ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09float4 ornB =rigidBodies[bodyIndexB].m_quat;\0A        \0A\09\09\0A        \0A        \0A\09\09///////////////////\0A\09\09///compound shape support\0A        \0A\09\09if (collidables[collidableIndexB].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS)\0A\09\09{\0A\09\09\09int compoundChild = concavePairs[pairIdx].w;\0A\09\09\09int childShapeIndexB = compoundChild;//collidables[collidableIndexB].m_shapeIndex+compoundChild;\0A\09\09\09int childColIndexB = gpuChildShapes[childShapeIndexB].m_shapeIndex;\0A\09\09\09float4 childPosB = gpuChildShapes[childShapeIndexB].m_childPosition;\0A\09\09\09float4 childOrnB = gpuChildShapes[childShapeIndexB].m_childOrientation;\0A\09\09\09float4 newPosB = transform(&childPosB,&posB,&ornB);\0A\09\09\09float4 newOrnB = qtMul(ornB,childOrnB);\0A\09\09\09posB = newPosB;\0A\09\09\09ornB = newOrnB;\0A\09\09\09shapeIndexB = collidables[childColIndexB].m_shapeIndex;\0A\09\09}\0A\09\09//////////////////\0A        \0A\09\09float4 c0local = convexPolyhedronA.m_localCenter;\0A\09\09float4 c0 = transform(&c0local, &posA, &ornA);\0A\09\09float4 c1local = convexShapes[shapeIndexB].m_localCenter;\0A\09\09float4 c1 = transform(&c1local,&posB,&ornB);\0A\09\09const float4 DeltaC2 = c0 - c1;\0A        \0A        \0A\09\09bool sepA = findSeparatingAxisLocalA(\09&convexPolyhedronA, &convexShapes[shapeIndexB],\0A                                             posA,ornA,\0A                                             posB,ornB,\0A                                             DeltaC2,\0A                                             verticesA,uniqueEdgesA,facesA,indicesA,\0A                                             vertices,uniqueEdges,faces,indices,\0A                                             &sepAxis,&dmin);\0A\09\09hasSeparatingAxis = 4;\0A\09\09if (!sepA)\0A\09\09{\0A\09\09\09hasSeparatingAxis = 0;\0A\09\09} else\0A\09\09{\0A\09\09\09bool sepB = findSeparatingAxisLocalB(\09&convexShapes[shapeIndexB],&convexPolyhedronA,\0A                                                 posB,ornB,\0A                                                 posA,ornA,\0A                                                 DeltaC2,\0A                                                 vertices,uniqueEdges,faces,indices,\0A                                                 verticesA,uniqueEdgesA,facesA,indicesA,\0A                                                 &sepAxis,&dmin);\0A            \0A\09\09\09if (!sepB)\0A\09\09\09{\0A\09\09\09\09hasSeparatingAxis = 0;\0A\09\09\09} else\0A\09\09\09{\0A\09\09\09\09hasSeparatingAxis = 1;\0A\09\09\09}\0A\09\09}\09\0A\09\09\0A\09\09if (hasSeparatingAxis)\0A\09\09{\0A            dmins[i] = dmin;\0A\09\09\09concaveSeparatingNormalsOut[pairIdx]=sepAxis;\0A\09\09\09concaveHasSeparatingNormals[i]=1;\0A            \0A\09\09} else\0A\09\09{\09\0A\09\09\09//mark this pair as in-active\0A\09\09\09concavePairs[pairIdx].w = -1;\0A\09\09}\0A\09}\0A\09else\0A\09{\09\0A\09\09//mark this pair as in-active\0A\09\09concavePairs[pairIdx].w = -1;\0A\09}\0A}\0A// work-in-progress\0A__kernel void   findConcaveSeparatingAxisEdgeEdgeKernel( __global int4* concavePairs,\0A                                                          __global const BodyData* rigidBodies,\0A                                                          __global const btCollidableGpu* collidables,\0A                                                          __global const ConvexPolyhedronCL* convexShapes,\0A                                                          __global const float4* vertices,\0A                                                          __global const float4* uniqueEdges,\0A                                                          __global const btGpuFace* faces,\0A                                                          __global const int* indices,\0A                                                          __global const btGpuChildShape* gpuChildShapes,\0A                                                          __global btAabbCL* aabbs,\0A                                                          __global float4* concaveSeparatingNormalsOut,\0A                                                          __global int* concaveHasSeparatingNormals,\0A                                                          __global int4* clippingFacesOut,\0A                                                          __global float4* worldVertsA1GPU,\0A                                                          __global float4*  worldNormalsAGPU,\0A                                                          __global float4* worldVertsB1GPU,\0A                                                          __global float* dmins,\0A                                                          int vertexFaceCapacity,\0A                                                          int numConcavePairs\0A                                                          )\0A{\0A    \0A\09int i = get_global_id(0);\0A\09if (i>=numConcavePairs)\0A\09\09return;\0A    \0A\09if (!concaveHasSeparatingNormals[i])\0A        return;\0A    \0A\09int pairIdx = i;\0A    \0A\09int bodyIndexA = concavePairs[i].x;\0A\09int bodyIndexB = concavePairs[i].y;\0A    \0A\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A    \0A\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A    \0A    \0A\09int numFacesA = convexShapes[shapeIndexA].m_numFaces;\0A\09int numActualConcaveConvexTests = 0;\0A\09\0A\09int f = concavePairs[i].z;\0A\09\0A\09bool overlap = false;\0A\09\0A\09ConvexPolyhedronCL convexPolyhedronA;\0A    \0A\09//add 3 vertices of the triangle\0A\09convexPolyhedronA.m_numVertices = 3;\0A\09convexPolyhedronA.m_vertexOffset = 0;\0A\09float4\09localCenter = make_float4(0.f,0.f,0.f,0.f);\0A    \0A\09btGpuFace face = faces[convexShapes[shapeIndexA].m_faceOffset+f];\0A\09float4 triMinAabb, triMaxAabb;\0A\09btAabbCL triAabb;\0A\09triAabb.m_min = make_float4(1e30f,1e30f,1e30f,0.f);\0A\09triAabb.m_max = make_float4(-1e30f,-1e30f,-1e30f,0.f);\0A\09\0A\09float4 verticesA[3];\0A\09for (int i=0;i<3;i++)\0A\09{\0A\09\09int index = indices[face.m_indexOffset+i];\0A\09\09float4 vert = vertices[convexShapes[shapeIndexA].m_vertexOffset+index];\0A\09\09verticesA[i] = vert;\0A\09\09localCenter += vert;\0A        \0A\09\09triAabb.m_min = min(triAabb.m_min,vert);\0A\09\09triAabb.m_max = max(triAabb.m_max,vert);\0A        \0A\09}\0A    \0A\09overlap = true;\0A\09overlap = (triAabb.m_min.x > aabbs[bodyIndexB].m_max.x || triAabb.m_max.x < aabbs[bodyIndexB].m_min.x) ? false : overlap;\0A\09overlap = (triAabb.m_min.z > aabbs[bodyIndexB].m_max.z || triAabb.m_max.z < aabbs[bodyIndexB].m_min.z) ? false : overlap;\0A\09overlap = (triAabb.m_min.y > aabbs[bodyIndexB].m_max.y || triAabb.m_max.y < aabbs[bodyIndexB].m_min.y) ? false : overlap;\0A    \0A\09if (overlap)\0A\09{\0A\09\09float dmin = dmins[i];\0A\09\09int hasSeparatingAxis=5;\0A\09\09float4 sepAxis=make_float4(1,2,3,4);\0A        sepAxis = concaveSeparatingNormalsOut[pairIdx];\0A        \0A\09\09int localCC=0;\0A\09\09numActualConcaveConvexTests++;\0A        \0A\09\09//a triangle has 3 unique edges\0A\09\09convexPolyhedronA.m_numUniqueEdges = 3;\0A\09\09convexPolyhedronA.m_uniqueEdgesOffset = 0;\0A\09\09float4 uniqueEdgesA[3];\0A\09\09\0A\09\09uniqueEdgesA[0] = (verticesA[1]-verticesA[0]);\0A\09\09uniqueEdgesA[1] = (verticesA[2]-verticesA[1]);\0A\09\09uniqueEdgesA[2] = (verticesA[0]-verticesA[2]);\0A        \0A        \0A\09\09convexPolyhedronA.m_faceOffset = 0;\0A        \0A\09\09float4 normal = make_float4(face.m_plane.x,face.m_plane.y,face.m_plane.z,0.f);\0A        \0A\09\09btGpuFace facesA[TRIANGLE_NUM_CONVEX_FACES];\0A\09\09int indicesA[3+3+2+2+2];\0A\09\09int curUsedIndices=0;\0A\09\09int fidx=0;\0A        \0A\09\09//front size of triangle\0A\09\09{\0A\09\09\09facesA[fidx].m_indexOffset=curUsedIndices;\0A\09\09\09indicesA[0] = 0;\0A\09\09\09indicesA[1] = 1;\0A\09\09\09indicesA[2] = 2;\0A\09\09\09curUsedIndices+=3;\0A\09\09\09float c = face.m_plane.w;\0A\09\09\09facesA[fidx].m_plane.x = normal.x;\0A\09\09\09facesA[fidx].m_plane.y = normal.y;\0A\09\09\09facesA[fidx].m_plane.z = normal.z;\0A\09\09\09facesA[fidx].m_plane.w = c;\0A\09\09\09facesA[fidx].m_numIndices=3;\0A\09\09}\0A\09\09fidx++;\0A\09\09//back size of triangle\0A\09\09{\0A\09\09\09facesA[fidx].m_indexOffset=curUsedIndices;\0A\09\09\09indicesA[3]=2;\0A\09\09\09indicesA[4]=1;\0A\09\09\09indicesA[5]=0;\0A\09\09\09curUsedIndices+=3;\0A\09\09\09float c = dot(normal,verticesA[0]);\0A\09\09\09float c1 = -face.m_plane.w;\0A\09\09\09facesA[fidx].m_plane.x = -normal.x;\0A\09\09\09facesA[fidx].m_plane.y = -normal.y;\0A\09\09\09facesA[fidx].m_plane.z = -normal.z;\0A\09\09\09facesA[fidx].m_plane.w = c;\0A\09\09\09facesA[fidx].m_numIndices=3;\0A\09\09}\0A\09\09fidx++;\0A        \0A\09\09bool addEdgePlanes = true;\0A\09\09if (addEdgePlanes)\0A\09\09{\0A\09\09\09int numVertices=3;\0A\09\09\09int prevVertex = numVertices-1;\0A\09\09\09for (int i=0;i<numVertices;i++)\0A\09\09\09{\0A\09\09\09\09float4 v0 = verticesA[i];\0A\09\09\09\09float4 v1 = verticesA[prevVertex];\0A                \0A\09\09\09\09float4 edgeNormal = normalize(cross(normal,v1-v0));\0A\09\09\09\09float c = -dot(edgeNormal,v0);\0A                \0A\09\09\09\09facesA[fidx].m_numIndices = 2;\0A\09\09\09\09facesA[fidx].m_indexOffset=curUsedIndices;\0A\09\09\09\09indicesA[curUsedIndices++]=i;\0A\09\09\09\09indicesA[curUsedIndices++]=prevVertex;\0A                \0A\09\09\09\09facesA[fidx].m_plane.x = edgeNormal.x;\0A\09\09\09\09facesA[fidx].m_plane.y = edgeNormal.y;\0A\09\09\09\09facesA[fidx].m_plane.z = edgeNormal.z;\0A\09\09\09\09facesA[fidx].m_plane.w = c;\0A\09\09\09\09fidx++;\0A\09\09\09\09prevVertex = i;\0A\09\09\09}\0A\09\09}\0A\09\09convexPolyhedronA.m_numFaces = TRIANGLE_NUM_CONVEX_FACES;\0A\09\09convexPolyhedronA.m_localCenter = localCenter*(1.f/3.f);\0A        \0A        \0A\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09posA.w = 0.f;\0A\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09posB.w = 0.f;\0A        \0A\09\09float4 ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09float4 ornB =rigidBodies[bodyIndexB].m_quat;\0A        \0A\09\09\0A        \0A        \0A\09\09///////////////////\0A\09\09///compound shape support\0A        \0A\09\09if (collidables[collidableIndexB].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS)\0A\09\09{\0A\09\09\09int compoundChild = concavePairs[pairIdx].w;\0A\09\09\09int childShapeIndexB = compoundChild;//collidables[collidableIndexB].m_shapeIndex+compoundChild;\0A\09\09\09int childColIndexB = gpuChildShapes[childShapeIndexB].m_shapeIndex;\0A\09\09\09float4 childPosB = gpuChildShapes[childShapeIndexB].m_childPosition;\0A\09\09\09float4 childOrnB = gpuChildShapes[childShapeIndexB].m_childOrientation;\0A\09\09\09float4 newPosB = transform(&childPosB,&posB,&ornB);\0A\09\09\09float4 newOrnB = qtMul(ornB,childOrnB);\0A\09\09\09posB = newPosB;\0A\09\09\09ornB = newOrnB;\0A\09\09\09shapeIndexB = collidables[childColIndexB].m_shapeIndex;\0A\09\09}\0A\09\09//////////////////\0A        \0A\09\09float4 c0local = convexPolyhedronA.m_localCenter;\0A\09\09float4 c0 = transform(&c0local, &posA, &ornA);\0A\09\09float4 c1local = convexShapes[shapeIndexB].m_localCenter;\0A\09\09float4 c1 = transform(&c1local,&posB,&ornB);\0A\09\09const float4 DeltaC2 = c0 - c1;\0A        \0A        \0A\09\09{\0A\09\09\09bool sepEE = findSeparatingAxisEdgeEdgeLocalA(\09&convexPolyhedronA, &convexShapes[shapeIndexB],\0A                                                              posA,ornA,\0A                                                              posB,ornB,\0A                                                              DeltaC2,\0A                                                              verticesA,uniqueEdgesA,facesA,indicesA,\0A                                                              vertices,uniqueEdges,faces,indices,\0A                                                              &sepAxis,&dmin);\0A                \0A\09\09\09if (!sepEE)\0A\09\09\09{\0A\09\09\09\09hasSeparatingAxis = 0;\0A\09\09\09} else\0A\09\09\09{\0A\09\09\09\09hasSeparatingAxis = 1;\0A\09\09\09}\0A\09\09}\0A\09\09\0A\09\09\0A\09\09if (hasSeparatingAxis)\0A\09\09{\0A\09\09\09sepAxis.w = dmin;\0A            dmins[i] = dmin;\0A\09\09\09concaveSeparatingNormalsOut[pairIdx]=sepAxis;\0A\09\09\09concaveHasSeparatingNormals[i]=1;\0A           \0A \09float minDist = -1e30f;\0A\09\09\09float maxDist = 0.02f;\0A            \0A            findClippingFaces(sepAxis,\0A                              &convexPolyhedronA,\0A                              &convexShapes[shapeIndexB],\0A                              posA,ornA,\0A                              posB,ornB,\0A                              worldVertsA1GPU,\0A                              worldNormalsAGPU,\0A                              worldVertsB1GPU,\0A                              vertexFaceCapacity,\0A                              minDist, maxDist,\0A                              verticesA,\0A                              facesA,\0A                              indicesA,\0A                              vertices,\0A                              faces,\0A                              indices,\0A                              clippingFacesOut, pairIdx);\0A\09           \0A            \0A\09\09} else\0A\09\09{\09\0A\09\09\09//mark this pair as in-active\0A\09\09\09concavePairs[pairIdx].w = -1;\0A\09\09}\0A\09}\0A\09else\0A\09{\09\0A\09\09//mark this pair as in-active\0A\09\09concavePairs[pairIdx].w = -1;\0A\09}\0A\09\0A\09concavePairs[i].z = -1;//for the next stage, z is used to determine existing contact points\0A}\0A\00", align 1
@.str.68 = private unnamed_addr constant [65091 x i8] c"//keep this enum in sync with the CPU version (in btCollidable.h)\0A//written by Erwin Coumans\0A#define SHAPE_CONVEX_HULL 3\0A#define SHAPE_CONCAVE_TRIMESH 5\0A#define TRIANGLE_NUM_CONVEX_FACES 5\0A#define SHAPE_COMPOUND_OF_CONVEX_HULLS 6\0A#define B3_MAX_STACK_DEPTH 256\0Atypedef unsigned int u32;\0A///keep this in sync with btCollidable.h\0Atypedef struct\0A{\0A\09union {\0A\09\09int m_numChildShapes;\0A\09\09int m_bvhIndex;\0A\09};\0A\09union\0A\09{\0A\09\09float m_radius;\0A\09\09int\09m_compoundBvhIndex;\0A\09};\0A\09\0A\09int m_shapeType;\0A\09int m_shapeIndex;\0A\09\0A} btCollidableGpu;\0A#define MAX_NUM_PARTS_IN_BITS 10\0A///b3QuantizedBvhNode is a compressed aabb node, 16 bytes.\0A///Node can be used for leafnode or internal node. Leafnodes can point to 32-bit triangle index (non-negative range).\0Atypedef struct\0A{\0A\09//12 bytes\0A\09unsigned short int\09m_quantizedAabbMin[3];\0A\09unsigned short int\09m_quantizedAabbMax[3];\0A\09//4 bytes\0A\09int\09m_escapeIndexOrTriangleIndex;\0A} b3QuantizedBvhNode;\0Atypedef struct\0A{\0A\09float4\09\09m_aabbMin;\0A\09float4\09\09m_aabbMax;\0A\09float4\09\09m_quantization;\0A\09int\09\09\09m_numNodes;\0A\09int\09\09\09m_numSubTrees;\0A\09int\09\09\09m_nodeOffset;\0A\09int\09\09\09m_subTreeOffset;\0A} b3BvhInfo;\0Aint\09getTriangleIndex(const b3QuantizedBvhNode* rootNode)\0A{\0A\09unsigned int x=0;\0A\09unsigned int y = (~(x&0))<<(31-MAX_NUM_PARTS_IN_BITS);\0A\09// Get only the lower bits where the triangle index is stored\0A\09return (rootNode->m_escapeIndexOrTriangleIndex&~(y));\0A}\0Aint\09getTriangleIndexGlobal(__global const b3QuantizedBvhNode* rootNode)\0A{\0A\09unsigned int x=0;\0A\09unsigned int y = (~(x&0))<<(31-MAX_NUM_PARTS_IN_BITS);\0A\09// Get only the lower bits where the triangle index is stored\0A\09return (rootNode->m_escapeIndexOrTriangleIndex&~(y));\0A}\0Aint isLeafNode(const b3QuantizedBvhNode* rootNode)\0A{\0A\09//skipindex is negative (internal node), triangleindex >=0 (leafnode)\0A\09return (rootNode->m_escapeIndexOrTriangleIndex >= 0)? 1 : 0;\0A}\0Aint isLeafNodeGlobal(__global const b3QuantizedBvhNode* rootNode)\0A{\0A\09//skipindex is negative (internal node), triangleindex >=0 (leafnode)\0A\09return (rootNode->m_escapeIndexOrTriangleIndex >= 0)? 1 : 0;\0A}\0A\09\0Aint getEscapeIndex(const b3QuantizedBvhNode* rootNode)\0A{\0A\09return -rootNode->m_escapeIndexOrTriangleIndex;\0A}\0Aint getEscapeIndexGlobal(__global const b3QuantizedBvhNode* rootNode)\0A{\0A\09return -rootNode->m_escapeIndexOrTriangleIndex;\0A}\0Atypedef struct\0A{\0A\09//12 bytes\0A\09unsigned short int\09m_quantizedAabbMin[3];\0A\09unsigned short int\09m_quantizedAabbMax[3];\0A\09//4 bytes, points to the root of the subtree\0A\09int\09\09\09m_rootNodeIndex;\0A\09//4 bytes\0A\09int\09\09\09m_subtreeSize;\0A\09int\09\09\09m_padding[3];\0A} b3BvhSubtreeInfo;\0Atypedef struct\0A{\0A\09float4\09m_childPosition;\0A\09float4\09m_childOrientation;\0A\09int m_shapeIndex;\0A\09int m_unused0;\0A\09int m_unused1;\0A\09int m_unused2;\0A} btGpuChildShape;\0Atypedef struct\0A{\0A\09float4 m_pos;\0A\09float4 m_quat;\0A\09float4 m_linVel;\0A\09float4 m_angVel;\0A\09u32 m_collidableIdx;\0A\09float m_invMass;\0A\09float m_restituitionCoeff;\0A\09float m_frictionCoeff;\0A} BodyData;\0Atypedef struct  \0A{\0A\09float4\09\09m_localCenter;\0A\09float4\09\09m_extents;\0A\09float4\09\09mC;\0A\09float4\09\09mE;\0A\09\0A\09float\09\09\09m_radius;\0A\09int\09m_faceOffset;\0A\09int m_numFaces;\0A\09int\09m_numVertices;\0A\09int m_vertexOffset;\0A\09int\09m_uniqueEdgesOffset;\0A\09int\09m_numUniqueEdges;\0A\09int m_unused;\0A} ConvexPolyhedronCL;\0Atypedef struct \0A{\0A\09union\0A\09{\0A\09\09float4\09m_min;\0A\09\09float   m_minElems[4];\0A\09\09int\09\09\09m_minIndices[4];\0A\09};\0A\09union\0A\09{\0A\09\09float4\09m_max;\0A\09\09float   m_maxElems[4];\0A\09\09int\09\09\09m_maxIndices[4];\0A\09};\0A} btAabbCL;\0A#ifndef B3_AABB_H\0A#define B3_AABB_H\0A#ifndef B3_FLOAT4_H\0A#define B3_FLOAT4_H\0A#ifndef B3_PLATFORM_DEFINITIONS_H\0A#define B3_PLATFORM_DEFINITIONS_H\0Astruct MyTest\0A{\0A\09int bla;\0A};\0A#ifdef __cplusplus\0A#else\0A//keep B3_LARGE_FLOAT*B3_LARGE_FLOAT < FLT_MAX\0A#define B3_LARGE_FLOAT 1e18f\0A#define B3_INFINITY 1e18f\0A#define b3Assert(a)\0A#define b3ConstArray(a) __global const a*\0A#define b3AtomicInc atomic_inc\0A#define b3AtomicAdd atomic_add\0A#define b3Fabs fabs\0A#define b3Sqrt native_sqrt\0A#define b3Sin native_sin\0A#define b3Cos native_cos\0A#define B3_STATIC\0A#endif\0A#endif\0A#ifdef __cplusplus\0A#else\0A\09typedef float4\09b3Float4;\0A\09#define b3Float4ConstArg const b3Float4\0A\09#define b3MakeFloat4 (float4)\0A\09float b3Dot3F4(b3Float4ConstArg v0,b3Float4ConstArg v1)\0A\09{\0A\09\09float4 a1 = b3MakeFloat4(v0.xyz,0.f);\0A\09\09float4 b1 = b3MakeFloat4(v1.xyz,0.f);\0A\09\09return dot(a1, b1);\0A\09}\0A\09b3Float4 b3Cross3(b3Float4ConstArg v0,b3Float4ConstArg v1)\0A\09{\0A\09\09float4 a1 = b3MakeFloat4(v0.xyz,0.f);\0A\09\09float4 b1 = b3MakeFloat4(v1.xyz,0.f);\0A\09\09return cross(a1, b1);\0A\09}\0A\09#define b3MinFloat4 min\0A\09#define b3MaxFloat4 max\0A\09#define b3Normalized(a) normalize(a)\0A#endif \0A\09\09\0Ainline bool b3IsAlmostZero(b3Float4ConstArg v)\0A{\0A\09if(b3Fabs(v.x)>1e-6 || b3Fabs(v.y)>1e-6 || b3Fabs(v.z)>1e-6)\09\0A\09\09return false;\0A\09return true;\0A}\0Ainline int    b3MaxDot( b3Float4ConstArg vec, __global const b3Float4* vecArray, int vecLen, float* dotOut )\0A{\0A    float maxDot = -B3_INFINITY;\0A    int i = 0;\0A    int ptIndex = -1;\0A    for( i = 0; i < vecLen; i++ )\0A    {\0A        float dot = b3Dot3F4(vecArray[i],vec);\0A            \0A        if( dot > maxDot )\0A        {\0A            maxDot = dot;\0A            ptIndex = i;\0A        }\0A    }\0A\09b3Assert(ptIndex>=0);\0A    if (ptIndex<0)\0A\09{\0A\09\09ptIndex = 0;\0A\09}\0A    *dotOut = maxDot;\0A    return ptIndex;\0A}\0A#endif //B3_FLOAT4_H\0A#ifndef B3_MAT3x3_H\0A#define B3_MAT3x3_H\0A#ifndef B3_QUAT_H\0A#define B3_QUAT_H\0A#ifndef B3_PLATFORM_DEFINITIONS_H\0A#ifdef __cplusplus\0A#else\0A#endif\0A#endif\0A#ifndef B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A\09typedef float4\09b3Quat;\0A\09#define b3QuatConstArg const b3Quat\0A\09\0A\09\0Ainline float4 b3FastNormalize4(float4 v)\0A{\0A\09v = (float4)(v.xyz,0.f);\0A\09return fast_normalize(v);\0A}\0A\09\0Ainline b3Quat b3QuatMul(b3Quat a, b3Quat b);\0Ainline b3Quat b3QuatNormalized(b3QuatConstArg in);\0Ainline b3Quat b3QuatRotate(b3QuatConstArg q, b3QuatConstArg vec);\0Ainline b3Quat b3QuatInvert(b3QuatConstArg q);\0Ainline b3Quat b3QuatInverse(b3QuatConstArg q);\0Ainline b3Quat b3QuatMul(b3QuatConstArg a, b3QuatConstArg b)\0A{\0A\09b3Quat ans;\0A\09ans = b3Cross3( a, b );\0A\09ans += a.w*b+b.w*a;\0A//\09ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);\0A\09ans.w = a.w*b.w - b3Dot3F4(a, b);\0A\09return ans;\0A}\0Ainline b3Quat b3QuatNormalized(b3QuatConstArg in)\0A{\0A\09b3Quat q;\0A\09q=in;\0A\09//return b3FastNormalize4(in);\0A\09float len = native_sqrt(dot(q, q));\0A\09if(len > 0.f)\0A\09{\0A\09\09q *= 1.f / len;\0A\09}\0A\09else\0A\09{\0A\09\09q.x = q.y = q.z = 0.f;\0A\09\09q.w = 1.f;\0A\09}\0A\09return q;\0A}\0Ainline float4 b3QuatRotate(b3QuatConstArg q, b3QuatConstArg vec)\0A{\0A\09b3Quat qInv = b3QuatInvert( q );\0A\09float4 vcpy = vec;\0A\09vcpy.w = 0.f;\0A\09float4 out = b3QuatMul(b3QuatMul(q,vcpy),qInv);\0A\09return out;\0A}\0Ainline b3Quat b3QuatInverse(b3QuatConstArg q)\0A{\0A\09return (b3Quat)(-q.xyz, q.w);\0A}\0Ainline b3Quat b3QuatInvert(b3QuatConstArg q)\0A{\0A\09return (b3Quat)(-q.xyz, q.w);\0A}\0Ainline float4 b3QuatInvRotate(b3QuatConstArg q, b3QuatConstArg vec)\0A{\0A\09return b3QuatRotate( b3QuatInvert( q ), vec );\0A}\0Ainline b3Float4 b3TransformPoint(b3Float4ConstArg point, b3Float4ConstArg translation, b3QuatConstArg  orientation)\0A{\0A\09return b3QuatRotate( orientation, point ) + (translation);\0A}\0A\09\0A#endif \0A#endif //B3_QUAT_H\0A#ifdef __cplusplus\0A#else\0Atypedef struct\0A{\0A\09b3Float4 m_row[3];\0A}b3Mat3x3;\0A#define b3Mat3x3ConstArg const b3Mat3x3\0A#define b3GetRow(m,row) (m.m_row[row])\0Ainline b3Mat3x3 b3QuatGetRotationMatrix(b3Quat quat)\0A{\0A\09b3Float4 quat2 = (b3Float4)(quat.x*quat.x, quat.y*quat.y, quat.z*quat.z, 0.f);\0A\09b3Mat3x3 out;\0A\09out.m_row[0].x=1-2*quat2.y-2*quat2.z;\0A\09out.m_row[0].y=2*quat.x*quat.y-2*quat.w*quat.z;\0A\09out.m_row[0].z=2*quat.x*quat.z+2*quat.w*quat.y;\0A\09out.m_row[0].w = 0.f;\0A\09out.m_row[1].x=2*quat.x*quat.y+2*quat.w*quat.z;\0A\09out.m_row[1].y=1-2*quat2.x-2*quat2.z;\0A\09out.m_row[1].z=2*quat.y*quat.z-2*quat.w*quat.x;\0A\09out.m_row[1].w = 0.f;\0A\09out.m_row[2].x=2*quat.x*quat.z-2*quat.w*quat.y;\0A\09out.m_row[2].y=2*quat.y*quat.z+2*quat.w*quat.x;\0A\09out.m_row[2].z=1-2*quat2.x-2*quat2.y;\0A\09out.m_row[2].w = 0.f;\0A\09return out;\0A}\0Ainline b3Mat3x3 b3AbsoluteMat3x3(b3Mat3x3ConstArg matIn)\0A{\0A\09b3Mat3x3 out;\0A\09out.m_row[0] = fabs(matIn.m_row[0]);\0A\09out.m_row[1] = fabs(matIn.m_row[1]);\0A\09out.m_row[2] = fabs(matIn.m_row[2]);\0A\09return out;\0A}\0A__inline\0Ab3Mat3x3 mtZero();\0A__inline\0Ab3Mat3x3 mtIdentity();\0A__inline\0Ab3Mat3x3 mtTranspose(b3Mat3x3 m);\0A__inline\0Ab3Mat3x3 mtMul(b3Mat3x3 a, b3Mat3x3 b);\0A__inline\0Ab3Float4 mtMul1(b3Mat3x3 a, b3Float4 b);\0A__inline\0Ab3Float4 mtMul3(b3Float4 a, b3Mat3x3 b);\0A__inline\0Ab3Mat3x3 mtZero()\0A{\0A\09b3Mat3x3 m;\0A\09m.m_row[0] = (b3Float4)(0.f);\0A\09m.m_row[1] = (b3Float4)(0.f);\0A\09m.m_row[2] = (b3Float4)(0.f);\0A\09return m;\0A}\0A__inline\0Ab3Mat3x3 mtIdentity()\0A{\0A\09b3Mat3x3 m;\0A\09m.m_row[0] = (b3Float4)(1,0,0,0);\0A\09m.m_row[1] = (b3Float4)(0,1,0,0);\0A\09m.m_row[2] = (b3Float4)(0,0,1,0);\0A\09return m;\0A}\0A__inline\0Ab3Mat3x3 mtTranspose(b3Mat3x3 m)\0A{\0A\09b3Mat3x3 out;\0A\09out.m_row[0] = (b3Float4)(m.m_row[0].x, m.m_row[1].x, m.m_row[2].x, 0.f);\0A\09out.m_row[1] = (b3Float4)(m.m_row[0].y, m.m_row[1].y, m.m_row[2].y, 0.f);\0A\09out.m_row[2] = (b3Float4)(m.m_row[0].z, m.m_row[1].z, m.m_row[2].z, 0.f);\0A\09return out;\0A}\0A__inline\0Ab3Mat3x3 mtMul(b3Mat3x3 a, b3Mat3x3 b)\0A{\0A\09b3Mat3x3 transB;\0A\09transB = mtTranspose( b );\0A\09b3Mat3x3 ans;\0A\09//\09why this doesn't run when 0ing in the for{}\0A\09a.m_row[0].w = 0.f;\0A\09a.m_row[1].w = 0.f;\0A\09a.m_row[2].w = 0.f;\0A\09for(int i=0; i<3; i++)\0A\09{\0A//\09a.m_row[i].w = 0.f;\0A\09\09ans.m_row[i].x = b3Dot3F4(a.m_row[i],transB.m_row[0]);\0A\09\09ans.m_row[i].y = b3Dot3F4(a.m_row[i],transB.m_row[1]);\0A\09\09ans.m_row[i].z = b3Dot3F4(a.m_row[i],transB.m_row[2]);\0A\09\09ans.m_row[i].w = 0.f;\0A\09}\0A\09return ans;\0A}\0A__inline\0Ab3Float4 mtMul1(b3Mat3x3 a, b3Float4 b)\0A{\0A\09b3Float4 ans;\0A\09ans.x = b3Dot3F4( a.m_row[0], b );\0A\09ans.y = b3Dot3F4( a.m_row[1], b );\0A\09ans.z = b3Dot3F4( a.m_row[2], b );\0A\09ans.w = 0.f;\0A\09return ans;\0A}\0A__inline\0Ab3Float4 mtMul3(b3Float4 a, b3Mat3x3 b)\0A{\0A\09b3Float4 colx = b3MakeFloat4(b.m_row[0].x, b.m_row[1].x, b.m_row[2].x, 0);\0A\09b3Float4 coly = b3MakeFloat4(b.m_row[0].y, b.m_row[1].y, b.m_row[2].y, 0);\0A\09b3Float4 colz = b3MakeFloat4(b.m_row[0].z, b.m_row[1].z, b.m_row[2].z, 0);\0A\09b3Float4 ans;\0A\09ans.x = b3Dot3F4( a, colx );\0A\09ans.y = b3Dot3F4( a, coly );\0A\09ans.z = b3Dot3F4( a, colz );\0A\09return ans;\0A}\0A#endif\0A#endif //B3_MAT3x3_H\0Atypedef struct b3Aabb b3Aabb_t;\0Astruct b3Aabb\0A{\0A\09union\0A\09{\0A\09\09float m_min[4];\0A\09\09b3Float4 m_minVec;\0A\09\09int m_minIndices[4];\0A\09};\0A\09union\0A\09{\0A\09\09float\09m_max[4];\0A\09\09b3Float4 m_maxVec;\0A\09\09int m_signedMaxIndices[4];\0A\09};\0A};\0Ainline void b3TransformAabb2(b3Float4ConstArg localAabbMin,b3Float4ConstArg localAabbMax, float margin,\0A\09\09\09\09\09\09b3Float4ConstArg pos,\0A\09\09\09\09\09\09b3QuatConstArg orn,\0A\09\09\09\09\09\09b3Float4* aabbMinOut,b3Float4* aabbMaxOut)\0A{\0A\09\09b3Float4 localHalfExtents = 0.5f*(localAabbMax-localAabbMin);\0A\09\09localHalfExtents+=b3MakeFloat4(margin,margin,margin,0.f);\0A\09\09b3Float4 localCenter = 0.5f*(localAabbMax+localAabbMin);\0A\09\09b3Mat3x3 m;\0A\09\09m = b3QuatGetRotationMatrix(orn);\0A\09\09b3Mat3x3 abs_b = b3AbsoluteMat3x3(m);\0A\09\09b3Float4 center = b3TransformPoint(localCenter,pos,orn);\0A\09\09\0A\09\09b3Float4 extent = b3MakeFloat4(b3Dot3F4(localHalfExtents,b3GetRow(abs_b,0)),\0A\09\09\09\09\09\09\09\09\09\09 b3Dot3F4(localHalfExtents,b3GetRow(abs_b,1)),\0A\09\09\09\09\09\09\09\09\09\09 b3Dot3F4(localHalfExtents,b3GetRow(abs_b,2)),\0A\09\09\09\09\09\09\09\09\09\09 0.f);\0A\09\09*aabbMinOut = center-extent;\0A\09\09*aabbMaxOut = center+extent;\0A}\0A/// conservative test for overlap between two aabbs\0Ainline bool b3TestAabbAgainstAabb(b3Float4ConstArg aabbMin1,b3Float4ConstArg aabbMax1,\0A\09\09\09\09\09\09\09\09b3Float4ConstArg aabbMin2, b3Float4ConstArg aabbMax2)\0A{\0A\09bool overlap = true;\0A\09overlap = (aabbMin1.x > aabbMax2.x || aabbMax1.x < aabbMin2.x) ? false : overlap;\0A\09overlap = (aabbMin1.z > aabbMax2.z || aabbMax1.z < aabbMin2.z) ? false : overlap;\0A\09overlap = (aabbMin1.y > aabbMax2.y || aabbMax1.y < aabbMin2.y) ? false : overlap;\0A\09return overlap;\0A}\0A#endif //B3_AABB_H\0A/*\0ABullet Continuous Collision Detection and Physics Library\0ACopyright (c) 2003-2013 Erwin Coumans  http://bulletphysics.org\0AThis software is provided 'as-is', without any express or implied warranty.\0AIn no event will the authors be held liable for any damages arising from the use of this software.\0APermission is granted to anyone to use this software for any purpose,\0Aincluding commercial applications, and to alter it and redistribute it freely,\0Asubject to the following restrictions:\0A1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.\0A2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.\0A3. This notice may not be removed or altered from any source distribution.\0A*/\0A#ifndef B3_INT2_H\0A#define B3_INT2_H\0A#ifdef __cplusplus\0A#else\0A#define b3UnsignedInt2 uint2\0A#define b3Int2 int2\0A#define b3MakeInt2 (int2)\0A#endif //__cplusplus\0A#endif\0Atypedef struct\0A{\0A\09float4 m_plane;\0A\09int m_indexOffset;\0A\09int m_numIndices;\0A} btGpuFace;\0A#define make_float4 (float4)\0A__inline\0Afloat4 cross3(float4 a, float4 b)\0A{\0A\09return cross(a,b);\0A\09\0A//\09float4 a1 = make_float4(a.xyz,0.f);\0A//\09float4 b1 = make_float4(b.xyz,0.f);\0A//\09return cross(a1,b1);\0A//float4 c = make_float4(a.y*b.z - a.z*b.y,a.z*b.x - a.x*b.z,a.x*b.y - a.y*b.x,0.f);\0A\09\0A\09//\09float4 c = make_float4(a.y*b.z - a.z*b.y,1.f,a.x*b.y - a.y*b.x,0.f);\0A\09\0A\09//return c;\0A}\0A__inline\0Afloat dot3F4(float4 a, float4 b)\0A{\0A\09float4 a1 = make_float4(a.xyz,0.f);\0A\09float4 b1 = make_float4(b.xyz,0.f);\0A\09return dot(a1, b1);\0A}\0A__inline\0Afloat4 fastNormalize4(float4 v)\0A{\0A\09v = make_float4(v.xyz,0.f);\0A\09return fast_normalize(v);\0A}\0A///////////////////////////////////////\0A//\09Quaternion\0A///////////////////////////////////////\0Atypedef float4 Quaternion;\0A__inline\0AQuaternion qtMul(Quaternion a, Quaternion b);\0A__inline\0AQuaternion qtNormalize(Quaternion in);\0A__inline\0Afloat4 qtRotate(Quaternion q, float4 vec);\0A__inline\0AQuaternion qtInvert(Quaternion q);\0A__inline\0AQuaternion qtMul(Quaternion a, Quaternion b)\0A{\0A\09Quaternion ans;\0A\09ans = cross3( a, b );\0A\09ans += a.w*b+b.w*a;\0A//\09ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);\0A\09ans.w = a.w*b.w - dot3F4(a, b);\0A\09return ans;\0A}\0A__inline\0AQuaternion qtNormalize(Quaternion in)\0A{\0A\09return fastNormalize4(in);\0A//\09in /= length( in );\0A//\09return in;\0A}\0A__inline\0Afloat4 qtRotate(Quaternion q, float4 vec)\0A{\0A\09Quaternion qInv = qtInvert( q );\0A\09float4 vcpy = vec;\0A\09vcpy.w = 0.f;\0A\09float4 out = qtMul(qtMul(q,vcpy),qInv);\0A\09return out;\0A}\0A__inline\0AQuaternion qtInvert(Quaternion q)\0A{\0A\09return (Quaternion)(-q.xyz, q.w);\0A}\0A__inline\0Afloat4 qtInvRotate(const Quaternion q, float4 vec)\0A{\0A\09return qtRotate( qtInvert( q ), vec );\0A}\0A__inline\0Afloat4 transform(const float4* p, const float4* translation, const Quaternion* orientation)\0A{\0A\09return qtRotate( *orientation, *p ) + (*translation);\0A}\0A__inline\0Afloat4 normalize3(const float4 a)\0A{\0A\09float4 n = make_float4(a.x, a.y, a.z, 0.f);\0A\09return fastNormalize4( n );\0A}\0Ainline void projectLocal(const ConvexPolyhedronCL* hull,  const float4 pos, const float4 orn, \0Aconst float4* dir, const float4* vertices, float* min, float* max)\0A{\0A\09min[0] = FLT_MAX;\0A\09max[0] = -FLT_MAX;\0A\09int numVerts = hull->m_numVertices;\0A\09const float4 localDir = qtInvRotate(orn,*dir);\0A\09float offset = dot(pos,*dir);\0A\09for(int i=0;i<numVerts;i++)\0A\09{\0A\09\09float dp = dot(vertices[hull->m_vertexOffset+i],localDir);\0A\09\09if(dp < min[0])\09\0A\09\09\09min[0] = dp;\0A\09\09if(dp > max[0])\09\0A\09\09\09max[0] = dp;\0A\09}\0A\09if(min[0]>max[0])\0A\09{\0A\09\09float tmp = min[0];\0A\09\09min[0] = max[0];\0A\09\09max[0] = tmp;\0A\09}\0A\09min[0] += offset;\0A\09max[0] += offset;\0A}\0Ainline void project(__global const ConvexPolyhedronCL* hull,  const float4 pos, const float4 orn, \0Aconst float4* dir, __global const float4* vertices, float* min, float* max)\0A{\0A\09min[0] = FLT_MAX;\0A\09max[0] = -FLT_MAX;\0A\09int numVerts = hull->m_numVertices;\0A\09const float4 localDir = qtInvRotate(orn,*dir);\0A\09float offset = dot(pos,*dir);\0A\09for(int i=0;i<numVerts;i++)\0A\09{\0A\09\09float dp = dot(vertices[hull->m_vertexOffset+i],localDir);\0A\09\09if(dp < min[0])\09\0A\09\09\09min[0] = dp;\0A\09\09if(dp > max[0])\09\0A\09\09\09max[0] = dp;\0A\09}\0A\09if(min[0]>max[0])\0A\09{\0A\09\09float tmp = min[0];\0A\09\09min[0] = max[0];\0A\09\09max[0] = tmp;\0A\09}\0A\09min[0] += offset;\0A\09max[0] += offset;\0A}\0Ainline bool TestSepAxisLocalA(const ConvexPolyhedronCL* hullA, __global const ConvexPolyhedronCL* hullB, \0A\09const float4 posA,const float4 ornA,\0A\09const float4 posB,const float4 ornB,\0A\09float4* sep_axis, const float4* verticesA, __global const float4* verticesB,float* depth)\0A{\0A\09float Min0,Max0;\0A\09float Min1,Max1;\0A\09projectLocal(hullA,posA,ornA,sep_axis,verticesA, &Min0, &Max0);\0A\09project(hullB,posB,ornB, sep_axis,verticesB, &Min1, &Max1);\0A\09if(Max0<Min1 || Max1<Min0)\0A\09\09return false;\0A\09float d0 = Max0 - Min1;\0A\09float d1 = Max1 - Min0;\0A\09*depth = d0<d1 ? d0:d1;\0A\09return true;\0A}\0Ainline bool IsAlmostZero(const float4 v)\0A{\0A\09if(fabs(v.x)>1e-6f || fabs(v.y)>1e-6f || fabs(v.z)>1e-6f)\0A\09\09return false;\0A\09return true;\0A}\0Abool findSeparatingAxisLocalA(\09const ConvexPolyhedronCL* hullA, __global const ConvexPolyhedronCL* hullB, \0A\09const float4 posA1,\0A\09const float4 ornA,\0A\09const float4 posB1,\0A\09const float4 ornB,\0A\09const float4 DeltaC2,\0A\09\0A\09const float4* verticesA, \0A\09const float4* uniqueEdgesA, \0A\09const btGpuFace* facesA,\0A\09const int*  indicesA,\0A\09__global const float4* verticesB, \0A\09__global const float4* uniqueEdgesB, \0A\09__global const btGpuFace* facesB,\0A\09__global const int*  indicesB,\0A\09float4* sep,\0A\09float* dmin)\0A{\0A\09\0A\09float4 posA = posA1;\0A\09posA.w = 0.f;\0A\09float4 posB = posB1;\0A\09posB.w = 0.f;\0A\09int curPlaneTests=0;\0A\09{\0A\09\09int numFacesA = hullA->m_numFaces;\0A\09\09// Test normals from hullA\0A\09\09for(int i=0;i<numFacesA;i++)\0A\09\09{\0A\09\09\09const float4 normal = facesA[hullA->m_faceOffset+i].m_plane;\0A\09\09\09float4 faceANormalWS = qtRotate(ornA,normal);\0A\09\09\09if (dot3F4(DeltaC2,faceANormalWS)<0)\0A\09\09\09\09faceANormalWS*=-1.f;\0A\09\09\09curPlaneTests++;\0A\09\09\09float d;\0A\09\09\09if(!TestSepAxisLocalA( hullA, hullB, posA,ornA,posB,ornB,&faceANormalWS, verticesA, verticesB,&d))\0A\09\09\09\09return false;\0A\09\09\09if(d<*dmin)\0A\09\09\09{\0A\09\09\09\09*dmin = d;\0A\09\09\09\09*sep = faceANormalWS;\0A\09\09\09}\0A\09\09}\0A\09}\0A\09if((dot3F4(-DeltaC2,*sep))>0.0f)\0A\09{\0A\09\09*sep = -(*sep);\0A\09}\0A\09return true;\0A}\0Abool findSeparatingAxisLocalB(\09__global const ConvexPolyhedronCL* hullA,  const ConvexPolyhedronCL* hullB, \0A\09const float4 posA1,\0A\09const float4 ornA,\0A\09const float4 posB1,\0A\09const float4 ornB,\0A\09const float4 DeltaC2,\0A\09__global const float4* verticesA, \0A\09__global const float4* uniqueEdgesA, \0A\09__global const btGpuFace* facesA,\0A\09__global const int*  indicesA,\0A\09const float4* verticesB,\0A\09const float4* uniqueEdgesB, \0A\09const btGpuFace* facesB,\0A\09const int*  indicesB,\0A\09float4* sep,\0A\09float* dmin)\0A{\0A\09float4 posA = posA1;\0A\09posA.w = 0.f;\0A\09float4 posB = posB1;\0A\09posB.w = 0.f;\0A\09int curPlaneTests=0;\0A\09{\0A\09\09int numFacesA = hullA->m_numFaces;\0A\09\09// Test normals from hullA\0A\09\09for(int i=0;i<numFacesA;i++)\0A\09\09{\0A\09\09\09const float4 normal = facesA[hullA->m_faceOffset+i].m_plane;\0A\09\09\09float4 faceANormalWS = qtRotate(ornA,normal);\0A\09\09\09if (dot3F4(DeltaC2,faceANormalWS)<0)\0A\09\09\09\09faceANormalWS *= -1.f;\0A\09\09\09curPlaneTests++;\0A\09\09\09float d;\0A\09\09\09if(!TestSepAxisLocalA( hullB, hullA, posB,ornB,posA,ornA, &faceANormalWS, verticesB,verticesA, &d))\0A\09\09\09\09return false;\0A\09\09\09if(d<*dmin)\0A\09\09\09{\0A\09\09\09\09*dmin = d;\0A\09\09\09\09*sep = faceANormalWS;\0A\09\09\09}\0A\09\09}\0A\09}\0A\09if((dot3F4(-DeltaC2,*sep))>0.0f)\0A\09{\0A\09\09*sep = -(*sep);\0A\09}\0A\09return true;\0A}\0Abool findSeparatingAxisEdgeEdgeLocalA(\09const ConvexPolyhedronCL* hullA, __global const ConvexPolyhedronCL* hullB, \0A\09const float4 posA1,\0A\09const float4 ornA,\0A\09const float4 posB1,\0A\09const float4 ornB,\0A\09const float4 DeltaC2,\0A\09const float4* verticesA, \0A\09const float4* uniqueEdgesA, \0A\09const btGpuFace* facesA,\0A\09const int*  indicesA,\0A\09__global const float4* verticesB, \0A\09__global const float4* uniqueEdgesB, \0A\09__global const btGpuFace* facesB,\0A\09__global const int*  indicesB,\0A\09\09float4* sep,\0A\09float* dmin)\0A{\0A\09float4 posA = posA1;\0A\09posA.w = 0.f;\0A\09float4 posB = posB1;\0A\09posB.w = 0.f;\0A\09int curPlaneTests=0;\0A\09int curEdgeEdge = 0;\0A\09// Test edges\0A\09for(int e0=0;e0<hullA->m_numUniqueEdges;e0++)\0A\09{\0A\09\09const float4 edge0 = uniqueEdgesA[hullA->m_uniqueEdgesOffset+e0];\0A\09\09float4 edge0World = qtRotate(ornA,edge0);\0A\09\09for(int e1=0;e1<hullB->m_numUniqueEdges;e1++)\0A\09\09{\0A\09\09\09const float4 edge1 = uniqueEdgesB[hullB->m_uniqueEdgesOffset+e1];\0A\09\09\09float4 edge1World = qtRotate(ornB,edge1);\0A\09\09\09float4 crossje = cross3(edge0World,edge1World);\0A\09\09\09curEdgeEdge++;\0A\09\09\09if(!IsAlmostZero(crossje))\0A\09\09\09{\0A\09\09\09\09crossje = normalize3(crossje);\0A\09\09\09\09if (dot3F4(DeltaC2,crossje)<0)\0A\09\09\09\09\09crossje *= -1.f;\0A\09\09\09\09float dist;\0A\09\09\09\09bool result = true;\0A\09\09\09\09{\0A\09\09\09\09\09float Min0,Max0;\0A\09\09\09\09\09float Min1,Max1;\0A\09\09\09\09\09projectLocal(hullA,posA,ornA,&crossje,verticesA, &Min0, &Max0);\0A\09\09\09\09\09project(hullB,posB,ornB,&crossje,verticesB, &Min1, &Max1);\0A\09\09\09\09\0A\09\09\09\09\09if(Max0<Min1 || Max1<Min0)\0A\09\09\09\09\09\09result = false;\0A\09\09\09\09\0A\09\09\09\09\09float d0 = Max0 - Min1;\0A\09\09\09\09\09float d1 = Max1 - Min0;\0A\09\09\09\09\09dist = d0<d1 ? d0:d1;\0A\09\09\09\09\09result = true;\0A\09\09\09\09}\0A\09\09\09\09\0A\09\09\09\09if(dist<*dmin)\0A\09\09\09\09{\0A\09\09\09\09\09*dmin = dist;\0A\09\09\09\09\09*sep = crossje;\0A\09\09\09\09}\0A\09\09\09}\0A\09\09}\0A\09}\0A\09\0A\09if((dot3F4(-DeltaC2,*sep))>0.0f)\0A\09{\0A\09\09*sep = -(*sep);\0A\09}\0A\09return true;\0A}\0Ainline bool TestSepAxis(__global const ConvexPolyhedronCL* hullA, __global const ConvexPolyhedronCL* hullB, \0A\09const float4 posA,const float4 ornA,\0A\09const float4 posB,const float4 ornB,\0A\09float4* sep_axis, __global const float4* vertices,float* depth)\0A{\0A\09float Min0,Max0;\0A\09float Min1,Max1;\0A\09project(hullA,posA,ornA,sep_axis,vertices, &Min0, &Max0);\0A\09project(hullB,posB,ornB, sep_axis,vertices, &Min1, &Max1);\0A\09if(Max0<Min1 || Max1<Min0)\0A\09\09return false;\0A\09float d0 = Max0 - Min1;\0A\09float d1 = Max1 - Min0;\0A\09*depth = d0<d1 ? d0:d1;\0A\09return true;\0A}\0Abool findSeparatingAxis(\09__global const ConvexPolyhedronCL* hullA, __global const ConvexPolyhedronCL* hullB, \0A\09const float4 posA1,\0A\09const float4 ornA,\0A\09const float4 posB1,\0A\09const float4 ornB,\0A\09const float4 DeltaC2,\0A\09__global const float4* vertices, \0A\09__global const float4* uniqueEdges, \0A\09__global const btGpuFace* faces,\0A\09__global const int*  indices,\0A\09float4* sep,\0A\09float* dmin)\0A{\0A\09\0A\09float4 posA = posA1;\0A\09posA.w = 0.f;\0A\09float4 posB = posB1;\0A\09posB.w = 0.f;\0A\09\0A\09int curPlaneTests=0;\0A\09{\0A\09\09int numFacesA = hullA->m_numFaces;\0A\09\09// Test normals from hullA\0A\09\09for(int i=0;i<numFacesA;i++)\0A\09\09{\0A\09\09\09const float4 normal = faces[hullA->m_faceOffset+i].m_plane;\0A\09\09\09float4 faceANormalWS = qtRotate(ornA,normal);\0A\09\0A\09\09\09if (dot3F4(DeltaC2,faceANormalWS)<0)\0A\09\09\09\09faceANormalWS*=-1.f;\0A\09\09\09\09\0A\09\09\09curPlaneTests++;\0A\09\0A\09\09\09float d;\0A\09\09\09if(!TestSepAxis( hullA, hullB, posA,ornA,posB,ornB,&faceANormalWS, vertices,&d))\0A\09\09\09\09return false;\0A\09\0A\09\09\09if(d<*dmin)\0A\09\09\09{\0A\09\09\09\09*dmin = d;\0A\09\09\09\09*sep = faceANormalWS;\0A\09\09\09}\0A\09\09}\0A\09}\0A\09\09if((dot3F4(-DeltaC2,*sep))>0.0f)\0A\09\09{\0A\09\09\09*sep = -(*sep);\0A\09\09}\0A\09\0A\09return true;\0A}\0Abool findSeparatingAxisUnitSphere(\09__global const ConvexPolyhedronCL* hullA, __global const ConvexPolyhedronCL* hullB, \0A\09const float4 posA1,\0A\09const float4 ornA,\0A\09const float4 posB1,\0A\09const float4 ornB,\0A\09const float4 DeltaC2,\0A\09__global const float4* vertices,\0A\09__global const float4* unitSphereDirections,\0A\09int numUnitSphereDirections,\0A\09float4* sep,\0A\09float* dmin)\0A{\0A\09\0A\09float4 posA = posA1;\0A\09posA.w = 0.f;\0A\09float4 posB = posB1;\0A\09posB.w = 0.f;\0A\09int curPlaneTests=0;\0A\09int curEdgeEdge = 0;\0A\09// Test unit sphere directions\0A\09for (int i=0;i<numUnitSphereDirections;i++)\0A\09{\0A\09\09float4 crossje;\0A\09\09crossje = unitSphereDirections[i];\09\0A\09\09if (dot3F4(DeltaC2,crossje)>0)\0A\09\09\09crossje *= -1.f;\0A\09\09{\0A\09\09\09float dist;\0A\09\09\09bool result = true;\0A\09\09\09float Min0,Max0;\0A\09\09\09float Min1,Max1;\0A\09\09\09project(hullA,posA,ornA,&crossje,vertices, &Min0, &Max0);\0A\09\09\09project(hullB,posB,ornB,&crossje,vertices, &Min1, &Max1);\0A\09\09\0A\09\09\09if(Max0<Min1 || Max1<Min0)\0A\09\09\09\09return false;\0A\09\09\0A\09\09\09float d0 = Max0 - Min1;\0A\09\09\09float d1 = Max1 - Min0;\0A\09\09\09dist = d0<d1 ? d0:d1;\0A\09\09\09result = true;\0A\09\0A\09\09\09if(dist<*dmin)\0A\09\09\09{\0A\09\09\09\09*dmin = dist;\0A\09\09\09\09*sep = crossje;\0A\09\09\09}\0A\09\09}\0A\09}\0A\09\0A\09if((dot3F4(-DeltaC2,*sep))>0.0f)\0A\09{\0A\09\09*sep = -(*sep);\0A\09}\0A\09return true;\0A}\0Abool findSeparatingAxisEdgeEdge(\09__global const ConvexPolyhedronCL* hullA, __global const ConvexPolyhedronCL* hullB, \0A\09const float4 posA1,\0A\09const float4 ornA,\0A\09const float4 posB1,\0A\09const float4 ornB,\0A\09const float4 DeltaC2,\0A\09__global const float4* vertices, \0A\09__global const float4* uniqueEdges, \0A\09__global const btGpuFace* faces,\0A\09__global const int*  indices,\0A\09float4* sep,\0A\09float* dmin)\0A{\0A\09\0A\09float4 posA = posA1;\0A\09posA.w = 0.f;\0A\09float4 posB = posB1;\0A\09posB.w = 0.f;\0A\09int curPlaneTests=0;\0A\09int curEdgeEdge = 0;\0A\09// Test edges\0A\09for(int e0=0;e0<hullA->m_numUniqueEdges;e0++)\0A\09{\0A\09\09const float4 edge0 = uniqueEdges[hullA->m_uniqueEdgesOffset+e0];\0A\09\09float4 edge0World = qtRotate(ornA,edge0);\0A\09\09for(int e1=0;e1<hullB->m_numUniqueEdges;e1++)\0A\09\09{\0A\09\09\09const float4 edge1 = uniqueEdges[hullB->m_uniqueEdgesOffset+e1];\0A\09\09\09float4 edge1World = qtRotate(ornB,edge1);\0A\09\09\09float4 crossje = cross3(edge0World,edge1World);\0A\09\09\09curEdgeEdge++;\0A\09\09\09if(!IsAlmostZero(crossje))\0A\09\09\09{\0A\09\09\09\09crossje = normalize3(crossje);\0A\09\09\09\09if (dot3F4(DeltaC2,crossje)<0)\0A\09\09\09\09\09crossje*=-1.f;\0A\09\09\09\09\09\0A\09\09\09\09float dist;\0A\09\09\09\09bool result = true;\0A\09\09\09\09{\0A\09\09\09\09\09float Min0,Max0;\0A\09\09\09\09\09float Min1,Max1;\0A\09\09\09\09\09project(hullA,posA,ornA,&crossje,vertices, &Min0, &Max0);\0A\09\09\09\09\09project(hullB,posB,ornB,&crossje,vertices, &Min1, &Max1);\0A\09\09\09\09\0A\09\09\09\09\09if(Max0<Min1 || Max1<Min0)\0A\09\09\09\09\09\09return false;\0A\09\09\09\09\0A\09\09\09\09\09float d0 = Max0 - Min1;\0A\09\09\09\09\09float d1 = Max1 - Min0;\0A\09\09\09\09\09dist = d0<d1 ? d0:d1;\0A\09\09\09\09\09result = true;\0A\09\09\09\09}\0A\09\09\09\09\0A\09\09\09\09if(dist<*dmin)\0A\09\09\09\09{\0A\09\09\09\09\09*dmin = dist;\0A\09\09\09\09\09*sep = crossje;\0A\09\09\09\09}\0A\09\09\09}\0A\09\09}\0A\09}\0A\09\0A\09if((dot3F4(-DeltaC2,*sep))>0.0f)\0A\09{\0A\09\09*sep = -(*sep);\0A\09}\0A\09return true;\0A}\0A// work-in-progress\0A__kernel void   processCompoundPairsKernel( __global const int4* gpuCompoundPairs,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const BodyData* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btCollidableGpu* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const ConvexPolyhedronCL* convexShapes, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* vertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* uniqueEdges,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btGpuFace* faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global btAabbCL* aabbs,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btGpuChildShape* gpuChildShapes,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global volatile float4* gpuCompoundSepNormalsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global volatile int* gpuHasCompoundSepNormalsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numCompoundPairs\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09)\0A{\0A\09int i = get_global_id(0);\0A\09if (i<numCompoundPairs)\0A\09{\0A\09\09int bodyIndexA = gpuCompoundPairs[i].x;\0A\09\09int bodyIndexB = gpuCompoundPairs[i].y;\0A\09\09int childShapeIndexA = gpuCompoundPairs[i].z;\0A\09\09int childShapeIndexB = gpuCompoundPairs[i].w;\0A\09\09\0A\09\09int collidableIndexA = -1;\0A\09\09int collidableIndexB = -1;\0A\09\09\0A\09\09float4 ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09\0A\09\09float4 ornB = rigidBodies[bodyIndexB].m_quat;\0A\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09\09\09\09\09\0A\09\09if (childShapeIndexA >= 0)\0A\09\09{\0A\09\09\09collidableIndexA = gpuChildShapes[childShapeIndexA].m_shapeIndex;\0A\09\09\09float4 childPosA = gpuChildShapes[childShapeIndexA].m_childPosition;\0A\09\09\09float4 childOrnA = gpuChildShapes[childShapeIndexA].m_childOrientation;\0A\09\09\09float4 newPosA = qtRotate(ornA,childPosA)+posA;\0A\09\09\09float4 newOrnA = qtMul(ornA,childOrnA);\0A\09\09\09posA = newPosA;\0A\09\09\09ornA = newOrnA;\0A\09\09} else\0A\09\09{\0A\09\09\09collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09}\0A\09\09\0A\09\09if (childShapeIndexB>=0)\0A\09\09{\0A\09\09\09collidableIndexB = gpuChildShapes[childShapeIndexB].m_shapeIndex;\0A\09\09\09float4 childPosB = gpuChildShapes[childShapeIndexB].m_childPosition;\0A\09\09\09float4 childOrnB = gpuChildShapes[childShapeIndexB].m_childOrientation;\0A\09\09\09float4 newPosB = transform(&childPosB,&posB,&ornB);\0A\09\09\09float4 newOrnB = qtMul(ornB,childOrnB);\0A\09\09\09posB = newPosB;\0A\09\09\09ornB = newOrnB;\0A\09\09} else\0A\09\09{\0A\09\09\09collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\09\0A\09\09}\0A\09\0A\09\09gpuHasCompoundSepNormalsOut[i] = 0;\0A\09\0A\09\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09\0A\09\09int shapeTypeA = collidables[collidableIndexA].m_shapeType;\0A\09\09int shapeTypeB = collidables[collidableIndexB].m_shapeType;\0A\09\0A\09\09if ((shapeTypeA != SHAPE_CONVEX_HULL) || (shapeTypeB != SHAPE_CONVEX_HULL))\0A\09\09{\0A\09\09\09return;\0A\09\09}\0A\09\09int hasSeparatingAxis = 5;\0A\09\09\09\09\09\09\09\0A\09\09int numFacesA = convexShapes[shapeIndexA].m_numFaces;\0A\09\09float dmin = FLT_MAX;\0A\09\09posA.w = 0.f;\0A\09\09posB.w = 0.f;\0A\09\09float4 c0local = convexShapes[shapeIndexA].m_localCenter;\0A\09\09float4 c0 = transform(&c0local, &posA, &ornA);\0A\09\09float4 c1local = convexShapes[shapeIndexB].m_localCenter;\0A\09\09float4 c1 = transform(&c1local,&posB,&ornB);\0A\09\09const float4 DeltaC2 = c0 - c1;\0A\09\09float4 sepNormal = make_float4(1,0,0,0);\0A\09\09bool sepA = findSeparatingAxis(\09&convexShapes[shapeIndexA], &convexShapes[shapeIndexB],posA,ornA,posB,ornB,DeltaC2,vertices,uniqueEdges,faces,indices,&sepNormal,&dmin);\0A\09\09hasSeparatingAxis = 4;\0A\09\09if (!sepA)\0A\09\09{\0A\09\09\09hasSeparatingAxis = 0;\0A\09\09} else\0A\09\09{\0A\09\09\09bool sepB = findSeparatingAxis(\09&convexShapes[shapeIndexB],&convexShapes[shapeIndexA],posB,ornB,posA,ornA,DeltaC2,vertices,uniqueEdges,faces,indices,&sepNormal,&dmin);\0A\09\09\09if (!sepB)\0A\09\09\09{\0A\09\09\09\09hasSeparatingAxis = 0;\0A\09\09\09} else//(!sepB)\0A\09\09\09{\0A\09\09\09\09bool sepEE = findSeparatingAxisEdgeEdge(\09&convexShapes[shapeIndexA], &convexShapes[shapeIndexB],posA,ornA,posB,ornB,DeltaC2,vertices,uniqueEdges,faces,indices,&sepNormal,&dmin);\0A\09\09\09\09if (sepEE)\0A\09\09\09\09{\0A\09\09\09\09\09\09gpuCompoundSepNormalsOut[i] = sepNormal;//fastNormalize4(sepNormal);\0A\09\09\09\09\09\09gpuHasCompoundSepNormalsOut[i] = 1;\0A\09\09\09\09}//sepEE\0A\09\09\09}//(!sepB)\0A\09\09}//(!sepA)\0A\09\09\0A\09\09\0A\09}\0A\09\09\0A}\0Ainline b3Float4 MyUnQuantize(const unsigned short* vecIn, b3Float4 quantization, b3Float4 bvhAabbMin)\0A{\0A\09\09b3Float4 vecOut;\0A\09\09vecOut = b3MakeFloat4(\0A\09\09\09(float)(vecIn[0]) / (quantization.x),\0A\09\09\09(float)(vecIn[1]) / (quantization.y),\0A\09\09\09(float)(vecIn[2]) / (quantization.z),\0A\09\09\090.f);\0A\09\09vecOut += bvhAabbMin;\0A\09\09return vecOut;\0A}\0Ainline b3Float4 MyUnQuantizeGlobal(__global const unsigned short* vecIn, b3Float4 quantization, b3Float4 bvhAabbMin)\0A{\0A\09\09b3Float4 vecOut;\0A\09\09vecOut = b3MakeFloat4(\0A\09\09\09(float)(vecIn[0]) / (quantization.x),\0A\09\09\09(float)(vecIn[1]) / (quantization.y),\0A\09\09\09(float)(vecIn[2]) / (quantization.z),\0A\09\09\090.f);\0A\09\09vecOut += bvhAabbMin;\0A\09\09return vecOut;\0A}\0A// work-in-progress\0A__kernel void   findCompoundPairsKernel( __global const int4* pairs, \0A\09__global const BodyData* rigidBodies, \0A\09__global const btCollidableGpu* collidables,\0A\09__global const ConvexPolyhedronCL* convexShapes, \0A\09__global const float4* vertices,\0A\09__global const float4* uniqueEdges,\0A\09__global const btGpuFace* faces,\0A\09__global const int* indices,\0A\09__global b3Aabb_t* aabbLocalSpace,\0A\09__global const btGpuChildShape* gpuChildShapes,\0A\09__global volatile int4* gpuCompoundPairsOut,\0A\09__global volatile int* numCompoundPairsOut,\0A\09__global const b3BvhSubtreeInfo* subtrees,\0A\09__global const b3QuantizedBvhNode* quantizedNodes,\0A\09__global const b3BvhInfo* bvhInfos,\0A\09int numPairs,\0A\09int maxNumCompoundPairsCapacity\0A\09)\0A{\0A\09int i = get_global_id(0);\0A\09if (i<numPairs)\0A\09{\0A\09\09int bodyIndexA = pairs[i].x;\0A\09\09int bodyIndexB = pairs[i].y;\0A\09\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09\09//once the broadphase avoids static-static pairs, we can remove this test\0A\09\09if ((rigidBodies[bodyIndexA].m_invMass==0) &&(rigidBodies[bodyIndexB].m_invMass==0))\0A\09\09{\0A\09\09\09return;\0A\09\09}\0A\09\09if ((collidables[collidableIndexA].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS) &&(collidables[collidableIndexB].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS))\0A\09\09{\0A\09\09\09int bvhA = collidables[collidableIndexA].m_compoundBvhIndex;\0A\09\09\09int bvhB = collidables[collidableIndexB].m_compoundBvhIndex;\0A\09\09\09int numSubTreesA = bvhInfos[bvhA].m_numSubTrees;\0A\09\09\09int subTreesOffsetA = bvhInfos[bvhA].m_subTreeOffset;\0A\09\09\09int subTreesOffsetB = bvhInfos[bvhB].m_subTreeOffset;\0A\09\09\09int numSubTreesB = bvhInfos[bvhB].m_numSubTrees;\0A\09\09\09\0A\09\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09\09b3Quat ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09\09b3Quat ornB = rigidBodies[bodyIndexB].m_quat;\0A\09\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09\0A\09\09\09for (int p=0;p<numSubTreesA;p++)\0A\09\09\09{\0A\09\09\09\09b3BvhSubtreeInfo subtreeA = subtrees[subTreesOffsetA+p];\0A\09\09\09\09//bvhInfos[bvhA].m_quantization\0A\09\09\09\09b3Float4 treeAminLocal = MyUnQuantize(subtreeA.m_quantizedAabbMin,bvhInfos[bvhA].m_quantization,bvhInfos[bvhA].m_aabbMin);\0A\09\09\09\09b3Float4 treeAmaxLocal = MyUnQuantize(subtreeA.m_quantizedAabbMax,bvhInfos[bvhA].m_quantization,bvhInfos[bvhA].m_aabbMin);\0A\09\09\09\09b3Float4 aabbAMinOut,aabbAMaxOut;\0A\09\09\09\09float margin=0.f;\0A\09\09\09\09b3TransformAabb2(treeAminLocal,treeAmaxLocal, margin,posA,ornA,&aabbAMinOut,&aabbAMaxOut);\0A\09\09\09\09\0A\09\09\09\09for (int q=0;q<numSubTreesB;q++)\0A\09\09\09\09{\0A\09\09\09\09\09b3BvhSubtreeInfo subtreeB = subtrees[subTreesOffsetB+q];\0A\09\09\09\09\09b3Float4 treeBminLocal = MyUnQuantize(subtreeB.m_quantizedAabbMin,bvhInfos[bvhB].m_quantization,bvhInfos[bvhB].m_aabbMin);\0A\09\09\09\09\09b3Float4 treeBmaxLocal = MyUnQuantize(subtreeB.m_quantizedAabbMax,bvhInfos[bvhB].m_quantization,bvhInfos[bvhB].m_aabbMin);\0A\09\09\09\09\09b3Float4 aabbBMinOut,aabbBMaxOut;\0A\09\09\09\09\09float margin=0.f;\0A\09\09\09\09\09b3TransformAabb2(treeBminLocal,treeBmaxLocal, margin,posB,ornB,&aabbBMinOut,&aabbBMaxOut);\0A\09\09\09\09\09\0A\09\09\09\09\09\0A\09\09\09\09\09bool aabbOverlap = b3TestAabbAgainstAabb(aabbAMinOut,aabbAMaxOut,aabbBMinOut,aabbBMaxOut);\0A\09\09\09\09\09if (aabbOverlap)\0A\09\09\09\09\09{\0A\09\09\09\09\09\09\0A\09\09\09\09\09\09int startNodeIndexA = subtreeA.m_rootNodeIndex+bvhInfos[bvhA].m_nodeOffset;\0A\09\09\09\09\09\09int endNodeIndexA = startNodeIndexA+subtreeA.m_subtreeSize;\0A\09\09\09\09\09\09int startNodeIndexB = subtreeB.m_rootNodeIndex+bvhInfos[bvhB].m_nodeOffset;\0A\09\09\09\09\09\09int endNodeIndexB = startNodeIndexB+subtreeB.m_subtreeSize;\0A\09\09\09\09\09\09b3Int2 nodeStack[B3_MAX_STACK_DEPTH];\0A\09\09\09\09\09\09b3Int2 node0;\0A\09\09\09\09\09\09node0.x = startNodeIndexA;\0A\09\09\09\09\09\09node0.y = startNodeIndexB;\0A\09\09\09\09\09\09int maxStackDepth = B3_MAX_STACK_DEPTH;\0A\09\09\09\09\09\09int depth=0;\0A\09\09\09\09\09\09nodeStack[depth++]=node0;\0A\09\09\09\09\09\09do\0A\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09b3Int2 node = nodeStack[--depth];\0A\09\09\09\09\09\09\09b3Float4 aMinLocal = MyUnQuantizeGlobal(quantizedNodes[node.x].m_quantizedAabbMin,bvhInfos[bvhA].m_quantization,bvhInfos[bvhA].m_aabbMin);\0A\09\09\09\09\09\09\09b3Float4 aMaxLocal = MyUnQuantizeGlobal(quantizedNodes[node.x].m_quantizedAabbMax,bvhInfos[bvhA].m_quantization,bvhInfos[bvhA].m_aabbMin);\0A\09\09\09\09\09\09\09b3Float4 bMinLocal = MyUnQuantizeGlobal(quantizedNodes[node.y].m_quantizedAabbMin,bvhInfos[bvhB].m_quantization,bvhInfos[bvhB].m_aabbMin);\0A\09\09\09\09\09\09\09b3Float4 bMaxLocal = MyUnQuantizeGlobal(quantizedNodes[node.y].m_quantizedAabbMax,bvhInfos[bvhB].m_quantization,bvhInfos[bvhB].m_aabbMin);\0A\09\09\09\09\09\09\09float margin=0.f;\0A\09\09\09\09\09\09\09b3Float4 aabbAMinOut,aabbAMaxOut;\0A\09\09\09\09\09\09\09b3TransformAabb2(aMinLocal,aMaxLocal, margin,posA,ornA,&aabbAMinOut,&aabbAMaxOut);\0A\09\09\09\09\09\09\09b3Float4 aabbBMinOut,aabbBMaxOut;\0A\09\09\09\09\09\09\09b3TransformAabb2(bMinLocal,bMaxLocal, margin,posB,ornB,&aabbBMinOut,&aabbBMaxOut);\0A\09\09\09\09\09\09\09\0A\09\09\09\09\09\09\09bool nodeOverlap = b3TestAabbAgainstAabb(aabbAMinOut,aabbAMaxOut,aabbBMinOut,aabbBMaxOut);\0A\09\09\09\09\09\09\09if (nodeOverlap)\0A\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09bool isLeafA = isLeafNodeGlobal(&quantizedNodes[node.x]);\0A\09\09\09\09\09\09\09\09bool isLeafB = isLeafNodeGlobal(&quantizedNodes[node.y]);\0A\09\09\09\09\09\09\09\09bool isInternalA = !isLeafA;\0A\09\09\09\09\09\09\09\09bool isInternalB = !isLeafB;\0A\09\09\09\09\09\09\09\09//fail, even though it might hit two leaf nodes\0A\09\09\09\09\09\09\09\09if (depth+4>maxStackDepth && !(isLeafA && isLeafB))\0A\09\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09\09//printf(\22Error: traversal exceeded maxStackDepth\22);\0A\09\09\09\09\09\09\09\09\09continue;\0A\09\09\09\09\09\09\09\09}\0A\09\09\09\09\09\09\09\09if(isInternalA)\0A\09\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09\09int nodeAleftChild = node.x+1;\0A\09\09\09\09\09\09\09\09\09bool isNodeALeftChildLeaf = isLeafNodeGlobal(&quantizedNodes[node.x+1]);\0A\09\09\09\09\09\09\09\09\09int nodeArightChild = isNodeALeftChildLeaf? node.x+2 : node.x+1 + getEscapeIndexGlobal(&quantizedNodes[node.x+1]);\0A\09\09\09\09\09\09\09\09\09if(isInternalB)\0A\09\09\09\09\09\09\09\09\09{\09\09\09\09\09\0A\09\09\09\09\09\09\09\09\09\09int nodeBleftChild = node.y+1;\0A\09\09\09\09\09\09\09\09\09\09bool isNodeBLeftChildLeaf = isLeafNodeGlobal(&quantizedNodes[node.y+1]);\0A\09\09\09\09\09\09\09\09\09\09int nodeBrightChild = isNodeBLeftChildLeaf? node.y+2 : node.y+1 + getEscapeIndexGlobal(&quantizedNodes[node.y+1]);\0A\09\09\09\09\09\09\09\09\09\09nodeStack[depth++] = b3MakeInt2(nodeAleftChild, nodeBleftChild);\0A\09\09\09\09\09\09\09\09\09\09nodeStack[depth++] = b3MakeInt2(nodeArightChild, nodeBleftChild);\0A\09\09\09\09\09\09\09\09\09\09nodeStack[depth++] = b3MakeInt2(nodeAleftChild, nodeBrightChild);\0A\09\09\09\09\09\09\09\09\09\09nodeStack[depth++] = b3MakeInt2(nodeArightChild, nodeBrightChild);\0A\09\09\09\09\09\09\09\09\09}\0A\09\09\09\09\09\09\09\09\09else\0A\09\09\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09\09\09nodeStack[depth++] = b3MakeInt2(nodeAleftChild,node.y);\0A\09\09\09\09\09\09\09\09\09\09nodeStack[depth++] = b3MakeInt2(nodeArightChild,node.y);\0A\09\09\09\09\09\09\09\09\09}\0A\09\09\09\09\09\09\09\09}\0A\09\09\09\09\09\09\09\09else\0A\09\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09\09if(isInternalB)\0A\09\09\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09\09\09int nodeBleftChild = node.y+1;\0A\09\09\09\09\09\09\09\09\09\09bool isNodeBLeftChildLeaf = isLeafNodeGlobal(&quantizedNodes[node.y+1]);\0A\09\09\09\09\09\09\09\09\09\09int nodeBrightChild = isNodeBLeftChildLeaf? node.y+2 : node.y+1 + getEscapeIndexGlobal(&quantizedNodes[node.y+1]);\0A\09\09\09\09\09\09\09\09\09\09nodeStack[depth++] = b3MakeInt2(node.x,nodeBleftChild);\0A\09\09\09\09\09\09\09\09\09\09nodeStack[depth++] = b3MakeInt2(node.x,nodeBrightChild);\0A\09\09\09\09\09\09\09\09\09}\0A\09\09\09\09\09\09\09\09\09else\0A\09\09\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09\09\09int compoundPairIdx = atomic_inc(numCompoundPairsOut);\0A\09\09\09\09\09\09\09\09\09\09if (compoundPairIdx<maxNumCompoundPairsCapacity)\0A\09\09\09\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09\09\09\09int childShapeIndexA = getTriangleIndexGlobal(&quantizedNodes[node.x]);\0A\09\09\09\09\09\09\09\09\09\09\09int childShapeIndexB = getTriangleIndexGlobal(&quantizedNodes[node.y]);\0A\09\09\09\09\09\09\09\09\09\09\09gpuCompoundPairsOut[compoundPairIdx]  = (int4)(bodyIndexA,bodyIndexB,childShapeIndexA,childShapeIndexB);\0A\09\09\09\09\09\09\09\09\09\09}\0A\09\09\09\09\09\09\09\09\09}\0A\09\09\09\09\09\09\09\09}\0A\09\09\09\09\09\09\09}\0A\09\09\09\09\09\09} while (depth);\0A\09\09\09\09\09}\0A\09\09\09\09}\0A\09\09\09}\0A\09\09\09\0A\09\09\09return;\0A\09\09}\0A\09\09if ((collidables[collidableIndexA].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS) ||(collidables[collidableIndexB].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS))\0A\09\09{\0A\09\09\09if (collidables[collidableIndexA].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS) \0A\09\09\09{\0A\09\09\09\09int numChildrenA = collidables[collidableIndexA].m_numChildShapes;\0A\09\09\09\09for (int c=0;c<numChildrenA;c++)\0A\09\09\09\09{\0A\09\09\09\09\09int childShapeIndexA = collidables[collidableIndexA].m_shapeIndex+c;\0A\09\09\09\09\09int childColIndexA = gpuChildShapes[childShapeIndexA].m_shapeIndex;\0A\09\09\09\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09\09\09\09float4 ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09\09\09\09float4 childPosA = gpuChildShapes[childShapeIndexA].m_childPosition;\0A\09\09\09\09\09float4 childOrnA = gpuChildShapes[childShapeIndexA].m_childOrientation;\0A\09\09\09\09\09float4 newPosA = qtRotate(ornA,childPosA)+posA;\0A\09\09\09\09\09float4 newOrnA = qtMul(ornA,childOrnA);\0A\09\09\09\09\09int shapeIndexA = collidables[childColIndexA].m_shapeIndex;\0A\09\09\09\09\09b3Aabb_t aabbAlocal = aabbLocalSpace[shapeIndexA];\0A\09\09\09\09\09float margin = 0.f;\0A\09\09\09\09\09\0A\09\09\09\09\09b3Float4 aabbAMinWS;\0A\09\09\09\09\09b3Float4 aabbAMaxWS;\0A\09\09\09\09\09\0A\09\09\09\09\09b3TransformAabb2(aabbAlocal.m_minVec,aabbAlocal.m_maxVec,margin,\0A\09\09\09\09\09\09newPosA,\0A\09\09\09\09\09\09newOrnA,\0A\09\09\09\09\09\09&aabbAMinWS,&aabbAMaxWS);\0A\09\09\09\09\09\09\0A\09\09\09\09\09\0A\09\09\09\09\09if (collidables[collidableIndexB].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS)\0A\09\09\09\09\09{\0A\09\09\09\09\09\09int numChildrenB = collidables[collidableIndexB].m_numChildShapes;\0A\09\09\09\09\09\09for (int b=0;b<numChildrenB;b++)\0A\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09int childShapeIndexB = collidables[collidableIndexB].m_shapeIndex+b;\0A\09\09\09\09\09\09\09int childColIndexB = gpuChildShapes[childShapeIndexB].m_shapeIndex;\0A\09\09\09\09\09\09\09float4 ornB = rigidBodies[bodyIndexB].m_quat;\0A\09\09\09\09\09\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09\09\09\09\09float4 childPosB = gpuChildShapes[childShapeIndexB].m_childPosition;\0A\09\09\09\09\09\09\09float4 childOrnB = gpuChildShapes[childShapeIndexB].m_childOrientation;\0A\09\09\09\09\09\09\09float4 newPosB = transform(&childPosB,&posB,&ornB);\0A\09\09\09\09\09\09\09float4 newOrnB = qtMul(ornB,childOrnB);\0A\09\09\09\09\09\09\09int shapeIndexB = collidables[childColIndexB].m_shapeIndex;\0A\09\09\09\09\09\09\09b3Aabb_t aabbBlocal = aabbLocalSpace[shapeIndexB];\0A\09\09\09\09\09\09\09\0A\09\09\09\09\09\09\09b3Float4 aabbBMinWS;\0A\09\09\09\09\09\09\09b3Float4 aabbBMaxWS;\0A\09\09\09\09\09\09\09\0A\09\09\09\09\09\09\09b3TransformAabb2(aabbBlocal.m_minVec,aabbBlocal.m_maxVec,margin,\0A\09\09\09\09\09\09\09\09newPosB,\0A\09\09\09\09\09\09\09\09newOrnB,\0A\09\09\09\09\09\09\09\09&aabbBMinWS,&aabbBMaxWS);\0A\09\09\09\09\09\09\09\09\0A\09\09\09\09\09\09\09\09\0A\09\09\09\09\09\09\09\0A\09\09\09\09\09\09\09bool aabbOverlap = b3TestAabbAgainstAabb(aabbAMinWS,aabbAMaxWS,aabbBMinWS,aabbBMaxWS);\0A\09\09\09\09\09\09\09if (aabbOverlap)\0A\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09int numFacesA = convexShapes[shapeIndexA].m_numFaces;\0A\09\09\09\09\09\09\09\09float dmin = FLT_MAX;\0A\09\09\09\09\09\09\09\09float4 posA = newPosA;\0A\09\09\09\09\09\09\09\09posA.w = 0.f;\0A\09\09\09\09\09\09\09\09float4 posB = newPosB;\0A\09\09\09\09\09\09\09\09posB.w = 0.f;\0A\09\09\09\09\09\09\09\09float4 c0local = convexShapes[shapeIndexA].m_localCenter;\0A\09\09\09\09\09\09\09\09float4 ornA = newOrnA;\0A\09\09\09\09\09\09\09\09float4 c0 = transform(&c0local, &posA, &ornA);\0A\09\09\09\09\09\09\09\09float4 c1local = convexShapes[shapeIndexB].m_localCenter;\0A\09\09\09\09\09\09\09\09float4 ornB =newOrnB;\0A\09\09\09\09\09\09\09\09float4 c1 = transform(&c1local,&posB,&ornB);\0A\09\09\09\09\09\09\09\09const float4 DeltaC2 = c0 - c1;\0A\09\09\09\09\09\09\09\09{//\0A\09\09\09\09\09\09\09\09\09int compoundPairIdx = atomic_inc(numCompoundPairsOut);\0A\09\09\09\09\09\09\09\09\09if (compoundPairIdx<maxNumCompoundPairsCapacity)\0A\09\09\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09\09\09gpuCompoundPairsOut[compoundPairIdx]  = (int4)(bodyIndexA,bodyIndexB,childShapeIndexA,childShapeIndexB);\0A\09\09\09\09\09\09\09\09\09}\0A\09\09\09\09\09\09\09\09}//\0A\09\09\09\09\09\09\09}//fi(1)\0A\09\09\09\09\09\09} //for (int b=0\0A\09\09\09\09\09}//if (collidables[collidableIndexB].\0A\09\09\09\09\09else//if (collidables[collidableIndexB].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS)\0A\09\09\09\09\09{\0A\09\09\09\09\09\09if (1)\0A\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09int numFacesA = convexShapes[shapeIndexA].m_numFaces;\0A\09\09\09\09\09\09\09float dmin = FLT_MAX;\0A\09\09\09\09\09\09\09float4 posA = newPosA;\0A\09\09\09\09\09\09\09posA.w = 0.f;\0A\09\09\09\09\09\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09\09\09\09\09posB.w = 0.f;\0A\09\09\09\09\09\09\09float4 c0local = convexShapes[shapeIndexA].m_localCenter;\0A\09\09\09\09\09\09\09float4 ornA = newOrnA;\0A\09\09\09\09\09\09\09float4 c0 = transform(&c0local, &posA, &ornA);\0A\09\09\09\09\09\09\09float4 c1local = convexShapes[shapeIndexB].m_localCenter;\0A\09\09\09\09\09\09\09float4 ornB = rigidBodies[bodyIndexB].m_quat;\0A\09\09\09\09\09\09\09float4 c1 = transform(&c1local,&posB,&ornB);\0A\09\09\09\09\09\09\09const float4 DeltaC2 = c0 - c1;\0A\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09int compoundPairIdx = atomic_inc(numCompoundPairsOut);\0A\09\09\09\09\09\09\09\09if (compoundPairIdx<maxNumCompoundPairsCapacity)\0A\09\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09\09gpuCompoundPairsOut[compoundPairIdx] = (int4)(bodyIndexA,bodyIndexB,childShapeIndexA,-1);\0A\09\09\09\09\09\09\09\09}//if (compoundPairIdx<maxNumCompoundPairsCapacity)\0A\09\09\09\09\09\09\09}//\0A\09\09\09\09\09\09}//fi (1)\0A\09\09\09\09\09}//if (collidables[collidableIndexB].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS)\0A\09\09\09\09}//for (int b=0;b<numChildrenB;b++)\09\0A\09\09\09\09return;\0A\09\09\09}//if (collidables[collidableIndexB].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS)\0A\09\09\09if ((collidables[collidableIndexA].m_shapeType!=SHAPE_CONCAVE_TRIMESH) \0A\09\09\09\09&& (collidables[collidableIndexB].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS))\0A\09\09\09{\0A\09\09\09\09int numChildrenB = collidables[collidableIndexB].m_numChildShapes;\0A\09\09\09\09for (int b=0;b<numChildrenB;b++)\0A\09\09\09\09{\0A\09\09\09\09\09int childShapeIndexB = collidables[collidableIndexB].m_shapeIndex+b;\0A\09\09\09\09\09int childColIndexB = gpuChildShapes[childShapeIndexB].m_shapeIndex;\0A\09\09\09\09\09float4 ornB = rigidBodies[bodyIndexB].m_quat;\0A\09\09\09\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09\09\09float4 childPosB = gpuChildShapes[childShapeIndexB].m_childPosition;\0A\09\09\09\09\09float4 childOrnB = gpuChildShapes[childShapeIndexB].m_childOrientation;\0A\09\09\09\09\09float4 newPosB = qtRotate(ornB,childPosB)+posB;\0A\09\09\09\09\09float4 newOrnB = qtMul(ornB,childOrnB);\0A\09\09\09\09\09int shapeIndexB = collidables[childColIndexB].m_shapeIndex;\0A\09\09\09\09\09//////////////////////////////////////\0A\09\09\09\09\09if (1)\0A\09\09\09\09\09{\0A\09\09\09\09\09\09int numFacesA = convexShapes[shapeIndexA].m_numFaces;\0A\09\09\09\09\09\09float dmin = FLT_MAX;\0A\09\09\09\09\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09\09\09\09\09posA.w = 0.f;\0A\09\09\09\09\09\09float4 posB = newPosB;\0A\09\09\09\09\09\09posB.w = 0.f;\0A\09\09\09\09\09\09float4 c0local = convexShapes[shapeIndexA].m_localCenter;\0A\09\09\09\09\09\09float4 ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09\09\09\09\09float4 c0 = transform(&c0local, &posA, &ornA);\0A\09\09\09\09\09\09float4 c1local = convexShapes[shapeIndexB].m_localCenter;\0A\09\09\09\09\09\09float4 ornB =newOrnB;\0A\09\09\09\09\09\09float4 c1 = transform(&c1local,&posB,&ornB);\0A\09\09\09\09\09\09const float4 DeltaC2 = c0 - c1;\0A\09\09\09\09\09\09{//\0A\09\09\09\09\09\09\09int compoundPairIdx = atomic_inc(numCompoundPairsOut);\0A\09\09\09\09\09\09\09if (compoundPairIdx<maxNumCompoundPairsCapacity)\0A\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09gpuCompoundPairsOut[compoundPairIdx] = (int4)(bodyIndexA,bodyIndexB,-1,childShapeIndexB);\0A\09\09\09\09\09\09\09}//fi (compoundPairIdx<maxNumCompoundPairsCapacity)\0A\09\09\09\09\09\09}//\0A\09\09\09\09\09}//fi (1)\09\0A\09\09\09\09}//for (int b=0;b<numChildrenB;b++)\0A\09\09\09\09return;\0A\09\09\09}//if (collidables[collidableIndexB].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS)\0A\09\09\09return;\0A\09\09}//fi ((collidables[collidableIndexA].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS) ||(collidables[collidableIndexB].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS))\0A\09}//i<numPairs\0A}\0A// work-in-progress\0A__kernel void   findSeparatingAxisKernel( __global const int4* pairs, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const BodyData* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btCollidableGpu* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const ConvexPolyhedronCL* convexShapes, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* vertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* uniqueEdges,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btGpuFace* faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global btAabbCL* aabbs,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global volatile float4* separatingNormals,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global volatile int* hasSeparatingAxis,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numPairs\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09)\0A{\0A\09int i = get_global_id(0);\0A\09\0A\09if (i<numPairs)\0A\09{\0A\09\0A\09\09int bodyIndexA = pairs[i].x;\0A\09\09int bodyIndexB = pairs[i].y;\0A\09\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09\0A\09\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09\09\0A\09\09\0A\09\09//once the broadphase avoids static-static pairs, we can remove this test\0A\09\09if ((rigidBodies[bodyIndexA].m_invMass==0) &&(rigidBodies[bodyIndexB].m_invMass==0))\0A\09\09{\0A\09\09\09hasSeparatingAxis[i] = 0;\0A\09\09\09return;\0A\09\09}\0A\09\09\0A\09\09if ((collidables[collidableIndexA].m_shapeType!=SHAPE_CONVEX_HULL) ||(collidables[collidableIndexB].m_shapeType!=SHAPE_CONVEX_HULL))\0A\09\09{\0A\09\09\09hasSeparatingAxis[i] = 0;\0A\09\09\09return;\0A\09\09}\0A\09\09\09\0A\09\09if ((collidables[collidableIndexA].m_shapeType==SHAPE_CONCAVE_TRIMESH))\0A\09\09{\0A\09\09\09hasSeparatingAxis[i] = 0;\0A\09\09\09return;\0A\09\09}\0A\09\09int numFacesA = convexShapes[shapeIndexA].m_numFaces;\0A\09\09float dmin = FLT_MAX;\0A\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09posA.w = 0.f;\0A\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09posB.w = 0.f;\0A\09\09float4 c0local = convexShapes[shapeIndexA].m_localCenter;\0A\09\09float4 ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09float4 c0 = transform(&c0local, &posA, &ornA);\0A\09\09float4 c1local = convexShapes[shapeIndexB].m_localCenter;\0A\09\09float4 ornB =rigidBodies[bodyIndexB].m_quat;\0A\09\09float4 c1 = transform(&c1local,&posB,&ornB);\0A\09\09const float4 DeltaC2 = c0 - c1;\0A\09\09float4 sepNormal;\0A\09\09\0A\09\09bool sepA = findSeparatingAxis(\09&convexShapes[shapeIndexA], &convexShapes[shapeIndexB],posA,ornA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09posB,ornB,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09DeltaC2,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09vertices,uniqueEdges,faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09indices,&sepNormal,&dmin);\0A\09\09hasSeparatingAxis[i] = 4;\0A\09\09if (!sepA)\0A\09\09{\0A\09\09\09hasSeparatingAxis[i] = 0;\0A\09\09} else\0A\09\09{\0A\09\09\09bool sepB = findSeparatingAxis(\09&convexShapes[shapeIndexB],&convexShapes[shapeIndexA],posB,ornB,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09posA,ornA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09DeltaC2,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09vertices,uniqueEdges,faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09indices,&sepNormal,&dmin);\0A\09\09\09if (!sepB)\0A\09\09\09{\0A\09\09\09\09hasSeparatingAxis[i] = 0;\0A\09\09\09} else\0A\09\09\09{\0A\09\09\09\09bool sepEE = findSeparatingAxisEdgeEdge(\09&convexShapes[shapeIndexA], &convexShapes[shapeIndexB],posA,ornA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09posB,ornB,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09DeltaC2,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09vertices,uniqueEdges,faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09indices,&sepNormal,&dmin);\0A\09\09\09\09if (!sepEE)\0A\09\09\09\09{\0A\09\09\09\09\09hasSeparatingAxis[i] = 0;\0A\09\09\09\09} else\0A\09\09\09\09{\0A\09\09\09\09\09hasSeparatingAxis[i] = 1;\0A\09\09\09\09\09separatingNormals[i] = sepNormal;\0A\09\09\09\09}\0A\09\09\09}\0A\09\09}\0A\09\09\0A\09}\0A}\0A__kernel void   findSeparatingAxisVertexFaceKernel( __global const int4* pairs, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const BodyData* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btCollidableGpu* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const ConvexPolyhedronCL* convexShapes, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* vertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* uniqueEdges,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btGpuFace* faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global btAabbCL* aabbs,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global volatile float4* separatingNormals,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global volatile int* hasSeparatingAxis,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global  float* dmins,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numPairs\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09)\0A{\0A\09int i = get_global_id(0);\0A\09\0A\09if (i<numPairs)\0A\09{\0A\09\0A\09\09int bodyIndexA = pairs[i].x;\0A\09\09int bodyIndexB = pairs[i].y;\0A\09\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09\0A\09\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09\0A\09\09hasSeparatingAxis[i] = 0;\09\0A\09\09\0A\09\09//once the broadphase avoids static-static pairs, we can remove this test\0A\09\09if ((rigidBodies[bodyIndexA].m_invMass==0) &&(rigidBodies[bodyIndexB].m_invMass==0))\0A\09\09{\0A\09\09\09return;\0A\09\09}\0A\09\09\0A\09\09if ((collidables[collidableIndexA].m_shapeType!=SHAPE_CONVEX_HULL) ||(collidables[collidableIndexB].m_shapeType!=SHAPE_CONVEX_HULL))\0A\09\09{\0A\09\09\09return;\0A\09\09}\0A\09\09\09\0A\09\09int numFacesA = convexShapes[shapeIndexA].m_numFaces;\0A\09\09float dmin = FLT_MAX;\0A\09\09dmins[i] = dmin;\0A\09\09\0A\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09posA.w = 0.f;\0A\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09posB.w = 0.f;\0A\09\09float4 c0local = convexShapes[shapeIndexA].m_localCenter;\0A\09\09float4 ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09float4 c0 = transform(&c0local, &posA, &ornA);\0A\09\09float4 c1local = convexShapes[shapeIndexB].m_localCenter;\0A\09\09float4 ornB =rigidBodies[bodyIndexB].m_quat;\0A\09\09float4 c1 = transform(&c1local,&posB,&ornB);\0A\09\09const float4 DeltaC2 = c0 - c1;\0A\09\09float4 sepNormal;\0A\09\09\0A\09\09bool sepA = findSeparatingAxis(\09&convexShapes[shapeIndexA], &convexShapes[shapeIndexB],posA,ornA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09posB,ornB,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09DeltaC2,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09vertices,uniqueEdges,faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09indices,&sepNormal,&dmin);\0A\09\09hasSeparatingAxis[i] = 4;\0A\09\09if (!sepA)\0A\09\09{\0A\09\09\09hasSeparatingAxis[i] = 0;\0A\09\09} else\0A\09\09{\0A\09\09\09bool sepB = findSeparatingAxis(\09&convexShapes[shapeIndexB],&convexShapes[shapeIndexA],posB,ornB,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09posA,ornA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09DeltaC2,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09vertices,uniqueEdges,faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09indices,&sepNormal,&dmin);\0A\09\09\09if (sepB)\0A\09\09\09{\0A\09\09\09\09dmins[i] = dmin;\0A\09\09\09\09hasSeparatingAxis[i] = 1;\0A\09\09\09\09separatingNormals[i] = sepNormal;\0A\09\09\09}\0A\09\09}\0A\09\09\0A\09}\0A}\0A__kernel void   findSeparatingAxisEdgeEdgeKernel( __global const int4* pairs, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const BodyData* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btCollidableGpu* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const ConvexPolyhedronCL* convexShapes, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* vertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* uniqueEdges,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btGpuFace* faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global btAabbCL* aabbs,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global  float4* separatingNormals,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global  int* hasSeparatingAxis,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global  float* dmins,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* unitSphereDirections,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numUnitSphereDirections,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numPairs\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09)\0A{\0A\09int i = get_global_id(0);\0A\09\0A\09if (i<numPairs)\0A\09{\0A\09\09if (hasSeparatingAxis[i])\0A\09\09{\0A\09\0A\09\09\09int bodyIndexA = pairs[i].x;\0A\09\09\09int bodyIndexB = pairs[i].y;\0A\09\0A\09\09\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09\09\0A\09\09\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09\09\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09\09\09\0A\09\09\09\0A\09\09\09int numFacesA = convexShapes[shapeIndexA].m_numFaces;\0A\09\0A\09\09\09float dmin = dmins[i];\0A\09\0A\09\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09\09posA.w = 0.f;\0A\09\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09posB.w = 0.f;\0A\09\09\09float4 c0local = convexShapes[shapeIndexA].m_localCenter;\0A\09\09\09float4 ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09\09float4 c0 = transform(&c0local, &posA, &ornA);\0A\09\09\09float4 c1local = convexShapes[shapeIndexB].m_localCenter;\0A\09\09\09float4 ornB =rigidBodies[bodyIndexB].m_quat;\0A\09\09\09float4 c1 = transform(&c1local,&posB,&ornB);\0A\09\09\09const float4 DeltaC2 = c0 - c1;\0A\09\09\09float4 sepNormal = separatingNormals[i];\0A\09\09\09\0A\09\09\09\0A\09\09\09\0A\09\09\09bool sepEE = false;\0A\09\09\09int numEdgeEdgeDirections = convexShapes[shapeIndexA].m_numUniqueEdges*convexShapes[shapeIndexB].m_numUniqueEdges;\0A\09\09\09if (numEdgeEdgeDirections<=numUnitSphereDirections)\0A\09\09\09{\0A\09\09\09\09sepEE = findSeparatingAxisEdgeEdge(\09&convexShapes[shapeIndexA], &convexShapes[shapeIndexB],posA,ornA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09posB,ornB,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09DeltaC2,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09vertices,uniqueEdges,faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09indices,&sepNormal,&dmin);\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\0A\09\09\09\09\09if (!sepEE)\0A\09\09\09\09\09{\0A\09\09\09\09\09\09hasSeparatingAxis[i] = 0;\0A\09\09\09\09\09} else\0A\09\09\09\09\09{\0A\09\09\09\09\09\09hasSeparatingAxis[i] = 1;\0A\09\09\09\09\09\09separatingNormals[i] = sepNormal;\0A\09\09\09\09\09}\0A\09\09\09}\0A\09\09\09/*\0A\09\09\09///else case is a separate kernel, to make Mac OSX OpenCL compiler happy\0A\09\09\09else\0A\09\09\09{\0A\09\09\09\09sepEE = findSeparatingAxisUnitSphere(&convexShapes[shapeIndexA], &convexShapes[shapeIndexB],posA,ornA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09posB,ornB,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09DeltaC2,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09vertices,unitSphereDirections,numUnitSphereDirections,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09&sepNormal,&dmin);\0A\09\09\09\09\09if (!sepEE)\0A\09\09\09\09\09{\0A\09\09\09\09\09\09hasSeparatingAxis[i] = 0;\0A\09\09\09\09\09} else\0A\09\09\09\09\09{\0A\09\09\09\09\09\09hasSeparatingAxis[i] = 1;\0A\09\09\09\09\09\09separatingNormals[i] = sepNormal;\0A\09\09\09\09\09}\0A\09\09\09}\0A\09\09\09*/\0A\09\09}\09\09//if (hasSeparatingAxis[i])\0A\09}//(i<numPairs)\0A}\0Ainline int\09findClippingFaces(const float4 separatingNormal,\0A                      const ConvexPolyhedronCL* hullA, \0A\09\09\09\09\09  __global const ConvexPolyhedronCL* hullB,\0A                      const float4 posA, const Quaternion ornA,const float4 posB, const Quaternion ornB,\0A                       __global float4* worldVertsA1,\0A                      __global float4* worldNormalsA1,\0A                      __global float4* worldVertsB1,\0A                      int capacityWorldVerts,\0A                      const float minDist, float maxDist,\0A\09\09\09\09\09  const float4* verticesA,\0A                      const btGpuFace* facesA,\0A                      const int* indicesA,\0A\09\09\09\09\09  __global const float4* verticesB,\0A                      __global const btGpuFace* facesB,\0A                      __global const int* indicesB,\0A                      __global int4* clippingFaces, int pairIndex)\0A{\0A\09int numContactsOut = 0;\0A\09int numWorldVertsB1= 0;\0A    \0A    \0A\09int closestFaceB=0;\0A\09float dmax = -FLT_MAX;\0A    \0A\09{\0A\09\09for(int face=0;face<hullB->m_numFaces;face++)\0A\09\09{\0A\09\09\09const float4 Normal = make_float4(facesB[hullB->m_faceOffset+face].m_plane.x,\0A                                              facesB[hullB->m_faceOffset+face].m_plane.y, facesB[hullB->m_faceOffset+face].m_plane.z,0.f);\0A\09\09\09const float4 WorldNormal = qtRotate(ornB, Normal);\0A\09\09\09float d = dot3F4(WorldNormal,separatingNormal);\0A\09\09\09if (d > dmax)\0A\09\09\09{\0A\09\09\09\09dmax = d;\0A\09\09\09\09closestFaceB = face;\0A\09\09\09}\0A\09\09}\0A\09}\0A    \0A\09{\0A\09\09const btGpuFace polyB = facesB[hullB->m_faceOffset+closestFaceB];\0A\09\09int numVertices = polyB.m_numIndices;\0A        if (numVertices>capacityWorldVerts)\0A            numVertices = capacityWorldVerts;\0A        \0A\09\09for(int e0=0;e0<numVertices;e0++)\0A\09\09{\0A            if (e0<capacityWorldVerts)\0A            {\0A                const float4 b = verticesB[hullB->m_vertexOffset+indicesB[polyB.m_indexOffset+e0]];\0A                worldVertsB1[pairIndex*capacityWorldVerts+numWorldVertsB1++] = transform(&b,&posB,&ornB);\0A            }\0A\09\09}\0A\09}\0A    \0A    int closestFaceA=0;\0A\09{\0A\09\09float dmin = FLT_MAX;\0A\09\09for(int face=0;face<hullA->m_numFaces;face++)\0A\09\09{\0A\09\09\09const float4 Normal = make_float4(\0A                                              facesA[hullA->m_faceOffset+face].m_plane.x,\0A                                              facesA[hullA->m_faceOffset+face].m_plane.y,\0A                                              facesA[hullA->m_faceOffset+face].m_plane.z,\0A                                              0.f);\0A\09\09\09const float4 faceANormalWS = qtRotate(ornA,Normal);\0A            \0A\09\09\09float d = dot3F4(faceANormalWS,separatingNormal);\0A\09\09\09if (d < dmin)\0A\09\09\09{\0A\09\09\09\09dmin = d;\0A\09\09\09\09closestFaceA = face;\0A                worldNormalsA1[pairIndex] = faceANormalWS;\0A\09\09\09}\0A\09\09}\0A\09}\0A    \0A    int numVerticesA = facesA[hullA->m_faceOffset+closestFaceA].m_numIndices;\0A    if (numVerticesA>capacityWorldVerts)\0A       numVerticesA = capacityWorldVerts;\0A    \0A\09for(int e0=0;e0<numVerticesA;e0++)\0A\09{\0A        if (e0<capacityWorldVerts)\0A        {\0A            const float4 a = verticesA[hullA->m_vertexOffset+indicesA[facesA[hullA->m_faceOffset+closestFaceA].m_indexOffset+e0]];\0A            worldVertsA1[pairIndex*capacityWorldVerts+e0] = transform(&a, &posA,&ornA);\0A        }\0A    }\0A    \0A    clippingFaces[pairIndex].x = closestFaceA;\0A    clippingFaces[pairIndex].y = closestFaceB;\0A    clippingFaces[pairIndex].z = numVerticesA;\0A    clippingFaces[pairIndex].w = numWorldVertsB1;\0A    \0A    \0A\09return numContactsOut;\0A}\0A// work-in-progress\0A__kernel void   findConcaveSeparatingAxisKernel( __global int4* concavePairs,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const BodyData* rigidBodies,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btCollidableGpu* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const ConvexPolyhedronCL* convexShapes, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* vertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* uniqueEdges,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btGpuFace* faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btGpuChildShape* gpuChildShapes,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global btAabbCL* aabbs,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global float4* concaveSeparatingNormalsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global int* concaveHasSeparatingNormals,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global int4* clippingFacesOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global float4* worldVertsA1GPU,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global float4*  worldNormalsAGPU,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global float4* worldVertsB1GPU,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int vertexFaceCapacity,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numConcavePairs\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09)\0A{\0A\09int i = get_global_id(0);\0A\09if (i>=numConcavePairs)\0A\09\09return;\0A\09concaveHasSeparatingNormals[i] = 0;\0A\09int pairIdx = i;\0A\09int bodyIndexA = concavePairs[i].x;\0A\09int bodyIndexB = concavePairs[i].y;\0A\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09if (collidables[collidableIndexB].m_shapeType!=SHAPE_CONVEX_HULL&&\0A\09\09collidables[collidableIndexB].m_shapeType!=SHAPE_COMPOUND_OF_CONVEX_HULLS)\0A\09{\0A\09\09concavePairs[pairIdx].w = -1;\0A\09\09return;\0A\09}\0A\09int numFacesA = convexShapes[shapeIndexA].m_numFaces;\0A\09int numActualConcaveConvexTests = 0;\0A\09\0A\09int f = concavePairs[i].z;\0A\09\0A\09bool overlap = false;\0A\09\0A\09ConvexPolyhedronCL convexPolyhedronA;\0A\09//add 3 vertices of the triangle\0A\09convexPolyhedronA.m_numVertices = 3;\0A\09convexPolyhedronA.m_vertexOffset = 0;\0A\09float4\09localCenter = make_float4(0.f,0.f,0.f,0.f);\0A\09btGpuFace face = faces[convexShapes[shapeIndexA].m_faceOffset+f];\0A\09float4 triMinAabb, triMaxAabb;\0A\09btAabbCL triAabb;\0A\09triAabb.m_min = make_float4(1e30f,1e30f,1e30f,0.f);\0A\09triAabb.m_max = make_float4(-1e30f,-1e30f,-1e30f,0.f);\0A\09\0A\09float4 verticesA[3];\0A\09for (int i=0;i<3;i++)\0A\09{\0A\09\09int index = indices[face.m_indexOffset+i];\0A\09\09float4 vert = vertices[convexShapes[shapeIndexA].m_vertexOffset+index];\0A\09\09verticesA[i] = vert;\0A\09\09localCenter += vert;\0A\09\09\09\0A\09\09triAabb.m_min = min(triAabb.m_min,vert);\09\09\0A\09\09triAabb.m_max = max(triAabb.m_max,vert);\09\09\0A\09}\0A\09overlap = true;\0A\09overlap = (triAabb.m_min.x > aabbs[bodyIndexB].m_max.x || triAabb.m_max.x < aabbs[bodyIndexB].m_min.x) ? false : overlap;\0A\09overlap = (triAabb.m_min.z > aabbs[bodyIndexB].m_max.z || triAabb.m_max.z < aabbs[bodyIndexB].m_min.z) ? false : overlap;\0A\09overlap = (triAabb.m_min.y > aabbs[bodyIndexB].m_max.y || triAabb.m_max.y < aabbs[bodyIndexB].m_min.y) ? false : overlap;\0A\09\09\0A\09if (overlap)\0A\09{\0A\09\09float dmin = FLT_MAX;\0A\09\09int hasSeparatingAxis=5;\0A\09\09float4 sepAxis=make_float4(1,2,3,4);\0A\09\09int localCC=0;\0A\09\09numActualConcaveConvexTests++;\0A\09\09//a triangle has 3 unique edges\0A\09\09convexPolyhedronA.m_numUniqueEdges = 3;\0A\09\09convexPolyhedronA.m_uniqueEdgesOffset = 0;\0A\09\09float4 uniqueEdgesA[3];\0A\09\09\0A\09\09uniqueEdgesA[0] = (verticesA[1]-verticesA[0]);\0A\09\09uniqueEdgesA[1] = (verticesA[2]-verticesA[1]);\0A\09\09uniqueEdgesA[2] = (verticesA[0]-verticesA[2]);\0A\09\09convexPolyhedronA.m_faceOffset = 0;\0A                                  \0A\09\09float4 normal = make_float4(face.m_plane.x,face.m_plane.y,face.m_plane.z,0.f);\0A                             \0A\09\09btGpuFace facesA[TRIANGLE_NUM_CONVEX_FACES];\0A\09\09int indicesA[3+3+2+2+2];\0A\09\09int curUsedIndices=0;\0A\09\09int fidx=0;\0A\09\09//front size of triangle\0A\09\09{\0A\09\09\09facesA[fidx].m_indexOffset=curUsedIndices;\0A\09\09\09indicesA[0] = 0;\0A\09\09\09indicesA[1] = 1;\0A\09\09\09indicesA[2] = 2;\0A\09\09\09curUsedIndices+=3;\0A\09\09\09float c = face.m_plane.w;\0A\09\09\09facesA[fidx].m_plane.x = normal.x;\0A\09\09\09facesA[fidx].m_plane.y = normal.y;\0A\09\09\09facesA[fidx].m_plane.z = normal.z;\0A\09\09\09facesA[fidx].m_plane.w = c;\0A\09\09\09facesA[fidx].m_numIndices=3;\0A\09\09}\0A\09\09fidx++;\0A\09\09//back size of triangle\0A\09\09{\0A\09\09\09facesA[fidx].m_indexOffset=curUsedIndices;\0A\09\09\09indicesA[3]=2;\0A\09\09\09indicesA[4]=1;\0A\09\09\09indicesA[5]=0;\0A\09\09\09curUsedIndices+=3;\0A\09\09\09float c = dot(normal,verticesA[0]);\0A\09\09\09float c1 = -face.m_plane.w;\0A\09\09\09facesA[fidx].m_plane.x = -normal.x;\0A\09\09\09facesA[fidx].m_plane.y = -normal.y;\0A\09\09\09facesA[fidx].m_plane.z = -normal.z;\0A\09\09\09facesA[fidx].m_plane.w = c;\0A\09\09\09facesA[fidx].m_numIndices=3;\0A\09\09}\0A\09\09fidx++;\0A\09\09bool addEdgePlanes = true;\0A\09\09if (addEdgePlanes)\0A\09\09{\0A\09\09\09int numVertices=3;\0A\09\09\09int prevVertex = numVertices-1;\0A\09\09\09for (int i=0;i<numVertices;i++)\0A\09\09\09{\0A\09\09\09\09float4 v0 = verticesA[i];\0A\09\09\09\09float4 v1 = verticesA[prevVertex];\0A                                            \0A\09\09\09\09float4 edgeNormal = normalize(cross(normal,v1-v0));\0A\09\09\09\09float c = -dot(edgeNormal,v0);\0A\09\09\09\09facesA[fidx].m_numIndices = 2;\0A\09\09\09\09facesA[fidx].m_indexOffset=curUsedIndices;\0A\09\09\09\09indicesA[curUsedIndices++]=i;\0A\09\09\09\09indicesA[curUsedIndices++]=prevVertex;\0A                                            \0A\09\09\09\09facesA[fidx].m_plane.x = edgeNormal.x;\0A\09\09\09\09facesA[fidx].m_plane.y = edgeNormal.y;\0A\09\09\09\09facesA[fidx].m_plane.z = edgeNormal.z;\0A\09\09\09\09facesA[fidx].m_plane.w = c;\0A\09\09\09\09fidx++;\0A\09\09\09\09prevVertex = i;\0A\09\09\09}\0A\09\09}\0A\09\09convexPolyhedronA.m_numFaces = TRIANGLE_NUM_CONVEX_FACES;\0A\09\09convexPolyhedronA.m_localCenter = localCenter*(1.f/3.f);\0A\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09posA.w = 0.f;\0A\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09posB.w = 0.f;\0A\09\09float4 ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09float4 ornB =rigidBodies[bodyIndexB].m_quat;\0A\09\09\0A\09\09///////////////////\0A\09\09///compound shape support\0A\09\09if (collidables[collidableIndexB].m_shapeType==SHAPE_COMPOUND_OF_CONVEX_HULLS)\0A\09\09{\0A\09\09\09int compoundChild = concavePairs[pairIdx].w;\0A\09\09\09int childShapeIndexB = compoundChild;//collidables[collidableIndexB].m_shapeIndex+compoundChild;\0A\09\09\09int childColIndexB = gpuChildShapes[childShapeIndexB].m_shapeIndex;\0A\09\09\09float4 childPosB = gpuChildShapes[childShapeIndexB].m_childPosition;\0A\09\09\09float4 childOrnB = gpuChildShapes[childShapeIndexB].m_childOrientation;\0A\09\09\09float4 newPosB = transform(&childPosB,&posB,&ornB);\0A\09\09\09float4 newOrnB = qtMul(ornB,childOrnB);\0A\09\09\09posB = newPosB;\0A\09\09\09ornB = newOrnB;\0A\09\09\09shapeIndexB = collidables[childColIndexB].m_shapeIndex;\0A\09\09}\0A\09\09//////////////////\0A\09\09float4 c0local = convexPolyhedronA.m_localCenter;\0A\09\09float4 c0 = transform(&c0local, &posA, &ornA);\0A\09\09float4 c1local = convexShapes[shapeIndexB].m_localCenter;\0A\09\09float4 c1 = transform(&c1local,&posB,&ornB);\0A\09\09const float4 DeltaC2 = c0 - c1;\0A\09\09bool sepA = findSeparatingAxisLocalA(\09&convexPolyhedronA, &convexShapes[shapeIndexB],\0A\09\09\09\09\09\09\09\09\09\09\09\09posA,ornA,\0A\09\09\09\09\09\09\09\09\09\09\09\09posB,ornB,\0A\09\09\09\09\09\09\09\09\09\09\09\09DeltaC2,\0A\09\09\09\09\09\09\09\09\09\09\09\09verticesA,uniqueEdgesA,facesA,indicesA,\0A\09\09\09\09\09\09\09\09\09\09\09\09vertices,uniqueEdges,faces,indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09&sepAxis,&dmin);\0A\09\09hasSeparatingAxis = 4;\0A\09\09if (!sepA)\0A\09\09{\0A\09\09\09hasSeparatingAxis = 0;\0A\09\09} else\0A\09\09{\0A\09\09\09bool sepB = findSeparatingAxisLocalB(\09&convexShapes[shapeIndexB],&convexPolyhedronA,\0A\09\09\09\09\09\09\09\09\09\09\09\09posB,ornB,\0A\09\09\09\09\09\09\09\09\09\09\09\09posA,ornA,\0A\09\09\09\09\09\09\09\09\09\09\09\09DeltaC2,\0A\09\09\09\09\09\09\09\09\09\09\09\09vertices,uniqueEdges,faces,indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09verticesA,uniqueEdgesA,facesA,indicesA,\0A\09\09\09\09\09\09\09\09\09\09\09\09&sepAxis,&dmin);\0A\09\09\09if (!sepB)\0A\09\09\09{\0A\09\09\09\09hasSeparatingAxis = 0;\0A\09\09\09} else\0A\09\09\09{\0A\09\09\09\09bool sepEE = findSeparatingAxisEdgeEdgeLocalA(\09&convexPolyhedronA, &convexShapes[shapeIndexB],\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09posA,ornA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09posB,ornB,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09DeltaC2,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09verticesA,uniqueEdgesA,facesA,indicesA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09vertices,uniqueEdges,faces,indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09&sepAxis,&dmin);\0A\09\0A\09\09\09\09if (!sepEE)\0A\09\09\09\09{\0A\09\09\09\09\09hasSeparatingAxis = 0;\0A\09\09\09\09} else\0A\09\09\09\09{\0A\09\09\09\09\09hasSeparatingAxis = 1;\0A\09\09\09\09}\0A\09\09\09}\0A\09\09}\09\0A\09\09\0A\09\09if (hasSeparatingAxis)\0A\09\09{\0A\09\09\09sepAxis.w = dmin;\0A\09\09\09concaveSeparatingNormalsOut[pairIdx]=sepAxis;\0A\09\09\09concaveHasSeparatingNormals[i]=1;\0A\09\09\09float minDist = -1e30f;\0A\09\09\09float maxDist = 0.02f;\0A\09\09\0A\09\09\09findClippingFaces(sepAxis,\0A                     &convexPolyhedronA,\0A\09\09\09\09\09 &convexShapes[shapeIndexB],\0A\09\09\09\09\09 posA,ornA,\0A\09\09\09\09\09 posB,ornB,\0A                      worldVertsA1GPU,\0A                      worldNormalsAGPU,\0A                      worldVertsB1GPU,\0A\09\09\09\09\09  vertexFaceCapacity,\0A                      minDist, maxDist,\0A                      verticesA,\0A                      facesA,\0A                      indicesA,\0A \09\09\09\09\09  vertices,\0A                      faces,\0A                      indices,\0A                      clippingFacesOut, pairIdx);\0A\09\09} else\0A\09\09{\09\0A\09\09\09//mark this pair as in-active\0A\09\09\09concavePairs[pairIdx].w = -1;\0A\09\09}\0A\09}\0A\09else\0A\09{\09\0A\09\09//mark this pair as in-active\0A\09\09concavePairs[pairIdx].w = -1;\0A\09}\0A\09\0A\09concavePairs[pairIdx].z = -1;//now z is used for existing/persistent contacts\0A}\0A\00", align 1
@.str.69 = private unnamed_addr constant [65232 x i8] c"#define TRIANGLE_NUM_CONVEX_FACES 5\0A#pragma OPENCL EXTENSION cl_amd_printf : enable\0A#pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable\0A#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\0A#pragma OPENCL EXTENSION cl_khr_local_int32_extended_atomics : enable\0A#pragma OPENCL EXTENSION cl_khr_global_int32_extended_atomics : enable\0A#ifdef cl_ext_atomic_counters_32\0A#pragma OPENCL EXTENSION cl_ext_atomic_counters_32 : enable\0A#else\0A#define counter32_t volatile __global int*\0A#endif\0A#define GET_GROUP_IDX get_group_id(0)\0A#define GET_LOCAL_IDX get_local_id(0)\0A#define GET_GLOBAL_IDX get_global_id(0)\0A#define GET_GROUP_SIZE get_local_size(0)\0A#define GET_NUM_GROUPS get_num_groups(0)\0A#define GROUP_LDS_BARRIER barrier(CLK_LOCAL_MEM_FENCE)\0A#define GROUP_MEM_FENCE mem_fence(CLK_LOCAL_MEM_FENCE)\0A#define AtomInc(x) atom_inc(&(x))\0A#define AtomInc1(x, out) out = atom_inc(&(x))\0A#define AppendInc(x, out) out = atomic_inc(x)\0A#define AtomAdd(x, value) atom_add(&(x), value)\0A#define AtomCmpxhg(x, cmp, value) atom_cmpxchg( &(x), cmp, value )\0A#define AtomXhg(x, value) atom_xchg ( &(x), value )\0A#define max2 max\0A#define min2 min\0Atypedef unsigned int u32;\0A#ifndef B3_CONTACT4DATA_H\0A#define B3_CONTACT4DATA_H\0A#ifndef B3_FLOAT4_H\0A#define B3_FLOAT4_H\0A#ifndef B3_PLATFORM_DEFINITIONS_H\0A#define B3_PLATFORM_DEFINITIONS_H\0Astruct MyTest\0A{\0A\09int bla;\0A};\0A#ifdef __cplusplus\0A#else\0A//keep B3_LARGE_FLOAT*B3_LARGE_FLOAT < FLT_MAX\0A#define B3_LARGE_FLOAT 1e18f\0A#define B3_INFINITY 1e18f\0A#define b3Assert(a)\0A#define b3ConstArray(a) __global const a*\0A#define b3AtomicInc atomic_inc\0A#define b3AtomicAdd atomic_add\0A#define b3Fabs fabs\0A#define b3Sqrt native_sqrt\0A#define b3Sin native_sin\0A#define b3Cos native_cos\0A#define B3_STATIC\0A#endif\0A#endif\0A#ifdef __cplusplus\0A#else\0A\09typedef float4\09b3Float4;\0A\09#define b3Float4ConstArg const b3Float4\0A\09#define b3MakeFloat4 (float4)\0A\09float b3Dot3F4(b3Float4ConstArg v0,b3Float4ConstArg v1)\0A\09{\0A\09\09float4 a1 = b3MakeFloat4(v0.xyz,0.f);\0A\09\09float4 b1 = b3MakeFloat4(v1.xyz,0.f);\0A\09\09return dot(a1, b1);\0A\09}\0A\09b3Float4 b3Cross3(b3Float4ConstArg v0,b3Float4ConstArg v1)\0A\09{\0A\09\09float4 a1 = b3MakeFloat4(v0.xyz,0.f);\0A\09\09float4 b1 = b3MakeFloat4(v1.xyz,0.f);\0A\09\09return cross(a1, b1);\0A\09}\0A\09#define b3MinFloat4 min\0A\09#define b3MaxFloat4 max\0A\09#define b3Normalized(a) normalize(a)\0A#endif \0A\09\09\0Ainline bool b3IsAlmostZero(b3Float4ConstArg v)\0A{\0A\09if(b3Fabs(v.x)>1e-6 || b3Fabs(v.y)>1e-6 || b3Fabs(v.z)>1e-6)\09\0A\09\09return false;\0A\09return true;\0A}\0Ainline int    b3MaxDot( b3Float4ConstArg vec, __global const b3Float4* vecArray, int vecLen, float* dotOut )\0A{\0A    float maxDot = -B3_INFINITY;\0A    int i = 0;\0A    int ptIndex = -1;\0A    for( i = 0; i < vecLen; i++ )\0A    {\0A        float dot = b3Dot3F4(vecArray[i],vec);\0A            \0A        if( dot > maxDot )\0A        {\0A            maxDot = dot;\0A            ptIndex = i;\0A        }\0A    }\0A\09b3Assert(ptIndex>=0);\0A    if (ptIndex<0)\0A\09{\0A\09\09ptIndex = 0;\0A\09}\0A    *dotOut = maxDot;\0A    return ptIndex;\0A}\0A#endif //B3_FLOAT4_H\0Atypedef  struct b3Contact4Data b3Contact4Data_t;\0Astruct b3Contact4Data\0A{\0A\09b3Float4\09m_worldPosB[4];\0A//\09b3Float4\09m_localPosA[4];\0A//\09b3Float4\09m_localPosB[4];\0A\09b3Float4\09m_worldNormalOnB;\09//\09w: m_nPoints\0A\09unsigned short  m_restituitionCoeffCmp;\0A\09unsigned short  m_frictionCoeffCmp;\0A\09int m_batchIdx;\0A\09int m_bodyAPtrAndSignBit;//x:m_bodyAPtr, y:m_bodyBPtr\0A\09int m_bodyBPtrAndSignBit;\0A\09int\09m_childIndexA;\0A\09int\09m_childIndexB;\0A\09int m_unused1;\0A\09int m_unused2;\0A};\0Ainline int b3Contact4Data_getNumPoints(const struct b3Contact4Data* contact)\0A{\0A\09return (int)contact->m_worldNormalOnB.w;\0A};\0Ainline void b3Contact4Data_setNumPoints(struct b3Contact4Data* contact, int numPoints)\0A{\0A\09contact->m_worldNormalOnB.w = (float)numPoints;\0A};\0A#endif //B3_CONTACT4DATA_H\0A#ifndef B3_CONVEX_POLYHEDRON_DATA_H\0A#define B3_CONVEX_POLYHEDRON_DATA_H\0A#ifndef B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_FLOAT4_H\0A#ifndef B3_QUAT_H\0A#define B3_QUAT_H\0A#ifndef B3_PLATFORM_DEFINITIONS_H\0A#ifdef __cplusplus\0A#else\0A#endif\0A#endif\0A#ifndef B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A\09typedef float4\09b3Quat;\0A\09#define b3QuatConstArg const b3Quat\0A\09\0A\09\0Ainline float4 b3FastNormalize4(float4 v)\0A{\0A\09v = (float4)(v.xyz,0.f);\0A\09return fast_normalize(v);\0A}\0A\09\0Ainline b3Quat b3QuatMul(b3Quat a, b3Quat b);\0Ainline b3Quat b3QuatNormalized(b3QuatConstArg in);\0Ainline b3Quat b3QuatRotate(b3QuatConstArg q, b3QuatConstArg vec);\0Ainline b3Quat b3QuatInvert(b3QuatConstArg q);\0Ainline b3Quat b3QuatInverse(b3QuatConstArg q);\0Ainline b3Quat b3QuatMul(b3QuatConstArg a, b3QuatConstArg b)\0A{\0A\09b3Quat ans;\0A\09ans = b3Cross3( a, b );\0A\09ans += a.w*b+b.w*a;\0A//\09ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);\0A\09ans.w = a.w*b.w - b3Dot3F4(a, b);\0A\09return ans;\0A}\0Ainline b3Quat b3QuatNormalized(b3QuatConstArg in)\0A{\0A\09b3Quat q;\0A\09q=in;\0A\09//return b3FastNormalize4(in);\0A\09float len = native_sqrt(dot(q, q));\0A\09if(len > 0.f)\0A\09{\0A\09\09q *= 1.f / len;\0A\09}\0A\09else\0A\09{\0A\09\09q.x = q.y = q.z = 0.f;\0A\09\09q.w = 1.f;\0A\09}\0A\09return q;\0A}\0Ainline float4 b3QuatRotate(b3QuatConstArg q, b3QuatConstArg vec)\0A{\0A\09b3Quat qInv = b3QuatInvert( q );\0A\09float4 vcpy = vec;\0A\09vcpy.w = 0.f;\0A\09float4 out = b3QuatMul(b3QuatMul(q,vcpy),qInv);\0A\09return out;\0A}\0Ainline b3Quat b3QuatInverse(b3QuatConstArg q)\0A{\0A\09return (b3Quat)(-q.xyz, q.w);\0A}\0Ainline b3Quat b3QuatInvert(b3QuatConstArg q)\0A{\0A\09return (b3Quat)(-q.xyz, q.w);\0A}\0Ainline float4 b3QuatInvRotate(b3QuatConstArg q, b3QuatConstArg vec)\0A{\0A\09return b3QuatRotate( b3QuatInvert( q ), vec );\0A}\0Ainline b3Float4 b3TransformPoint(b3Float4ConstArg point, b3Float4ConstArg translation, b3QuatConstArg  orientation)\0A{\0A\09return b3QuatRotate( orientation, point ) + (translation);\0A}\0A\09\0A#endif \0A#endif //B3_QUAT_H\0Atypedef struct b3GpuFace b3GpuFace_t;\0Astruct b3GpuFace\0A{\0A\09b3Float4 m_plane;\0A\09int m_indexOffset;\0A\09int m_numIndices;\0A\09int m_unusedPadding1;\0A\09int m_unusedPadding2;\0A};\0Atypedef struct b3ConvexPolyhedronData b3ConvexPolyhedronData_t;\0Astruct b3ConvexPolyhedronData\0A{\0A\09b3Float4\09\09m_localCenter;\0A\09b3Float4\09\09m_extents;\0A\09b3Float4\09\09mC;\0A\09b3Float4\09\09mE;\0A\09float\09\09\09m_radius;\0A\09int\09m_faceOffset;\0A\09int m_numFaces;\0A\09int\09m_numVertices;\0A\09int m_vertexOffset;\0A\09int\09m_uniqueEdgesOffset;\0A\09int\09m_numUniqueEdges;\0A\09int m_unused;\0A};\0A#endif //B3_CONVEX_POLYHEDRON_DATA_H\0A#ifndef B3_COLLIDABLE_H\0A#define B3_COLLIDABLE_H\0A#ifndef B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_FLOAT4_H\0A#ifndef B3_QUAT_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_QUAT_H\0Aenum b3ShapeTypes\0A{\0A\09SHAPE_HEIGHT_FIELD=1,\0A\09SHAPE_CONVEX_HULL=3,\0A\09SHAPE_PLANE=4,\0A\09SHAPE_CONCAVE_TRIMESH=5,\0A\09SHAPE_COMPOUND_OF_CONVEX_HULLS=6,\0A\09SHAPE_SPHERE=7,\0A\09MAX_NUM_SHAPE_TYPES,\0A};\0Atypedef struct b3Collidable b3Collidable_t;\0Astruct b3Collidable\0A{\0A\09union {\0A\09\09int m_numChildShapes;\0A\09\09int m_bvhIndex;\0A\09};\0A\09union\0A\09{\0A\09\09float m_radius;\0A\09\09int\09m_compoundBvhIndex;\0A\09};\0A\09int m_shapeType;\0A\09int m_shapeIndex;\0A};\0Atypedef struct b3GpuChildShape b3GpuChildShape_t;\0Astruct b3GpuChildShape\0A{\0A\09b3Float4\09m_childPosition;\0A\09b3Quat\09\09m_childOrientation;\0A\09int m_shapeIndex;\0A\09int m_unused0;\0A\09int m_unused1;\0A\09int m_unused2;\0A};\0Astruct b3CompoundOverlappingPair\0A{\0A\09int m_bodyIndexA;\0A\09int m_bodyIndexB;\0A//\09int\09m_pairType;\0A\09int m_childShapeIndexA;\0A\09int m_childShapeIndexB;\0A};\0A#endif //B3_COLLIDABLE_H\0A#ifndef B3_RIGIDBODY_DATA_H\0A#define B3_RIGIDBODY_DATA_H\0A#ifndef B3_FLOAT4_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_FLOAT4_H\0A#ifndef B3_QUAT_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_QUAT_H\0A#ifndef B3_MAT3x3_H\0A#define B3_MAT3x3_H\0A#ifndef B3_QUAT_H\0A#ifdef __cplusplus\0A#else\0A#endif \0A#endif //B3_QUAT_H\0A#ifdef __cplusplus\0A#else\0Atypedef struct\0A{\0A\09b3Float4 m_row[3];\0A}b3Mat3x3;\0A#define b3Mat3x3ConstArg const b3Mat3x3\0A#define b3GetRow(m,row) (m.m_row[row])\0Ainline b3Mat3x3 b3QuatGetRotationMatrix(b3Quat quat)\0A{\0A\09b3Float4 quat2 = (b3Float4)(quat.x*quat.x, quat.y*quat.y, quat.z*quat.z, 0.f);\0A\09b3Mat3x3 out;\0A\09out.m_row[0].x=1-2*quat2.y-2*quat2.z;\0A\09out.m_row[0].y=2*quat.x*quat.y-2*quat.w*quat.z;\0A\09out.m_row[0].z=2*quat.x*quat.z+2*quat.w*quat.y;\0A\09out.m_row[0].w = 0.f;\0A\09out.m_row[1].x=2*quat.x*quat.y+2*quat.w*quat.z;\0A\09out.m_row[1].y=1-2*quat2.x-2*quat2.z;\0A\09out.m_row[1].z=2*quat.y*quat.z-2*quat.w*quat.x;\0A\09out.m_row[1].w = 0.f;\0A\09out.m_row[2].x=2*quat.x*quat.z-2*quat.w*quat.y;\0A\09out.m_row[2].y=2*quat.y*quat.z+2*quat.w*quat.x;\0A\09out.m_row[2].z=1-2*quat2.x-2*quat2.y;\0A\09out.m_row[2].w = 0.f;\0A\09return out;\0A}\0Ainline b3Mat3x3 b3AbsoluteMat3x3(b3Mat3x3ConstArg matIn)\0A{\0A\09b3Mat3x3 out;\0A\09out.m_row[0] = fabs(matIn.m_row[0]);\0A\09out.m_row[1] = fabs(matIn.m_row[1]);\0A\09out.m_row[2] = fabs(matIn.m_row[2]);\0A\09return out;\0A}\0A__inline\0Ab3Mat3x3 mtZero();\0A__inline\0Ab3Mat3x3 mtIdentity();\0A__inline\0Ab3Mat3x3 mtTranspose(b3Mat3x3 m);\0A__inline\0Ab3Mat3x3 mtMul(b3Mat3x3 a, b3Mat3x3 b);\0A__inline\0Ab3Float4 mtMul1(b3Mat3x3 a, b3Float4 b);\0A__inline\0Ab3Float4 mtMul3(b3Float4 a, b3Mat3x3 b);\0A__inline\0Ab3Mat3x3 mtZero()\0A{\0A\09b3Mat3x3 m;\0A\09m.m_row[0] = (b3Float4)(0.f);\0A\09m.m_row[1] = (b3Float4)(0.f);\0A\09m.m_row[2] = (b3Float4)(0.f);\0A\09return m;\0A}\0A__inline\0Ab3Mat3x3 mtIdentity()\0A{\0A\09b3Mat3x3 m;\0A\09m.m_row[0] = (b3Float4)(1,0,0,0);\0A\09m.m_row[1] = (b3Float4)(0,1,0,0);\0A\09m.m_row[2] = (b3Float4)(0,0,1,0);\0A\09return m;\0A}\0A__inline\0Ab3Mat3x3 mtTranspose(b3Mat3x3 m)\0A{\0A\09b3Mat3x3 out;\0A\09out.m_row[0] = (b3Float4)(m.m_row[0].x, m.m_row[1].x, m.m_row[2].x, 0.f);\0A\09out.m_row[1] = (b3Float4)(m.m_row[0].y, m.m_row[1].y, m.m_row[2].y, 0.f);\0A\09out.m_row[2] = (b3Float4)(m.m_row[0].z, m.m_row[1].z, m.m_row[2].z, 0.f);\0A\09return out;\0A}\0A__inline\0Ab3Mat3x3 mtMul(b3Mat3x3 a, b3Mat3x3 b)\0A{\0A\09b3Mat3x3 transB;\0A\09transB = mtTranspose( b );\0A\09b3Mat3x3 ans;\0A\09//\09why this doesn't run when 0ing in the for{}\0A\09a.m_row[0].w = 0.f;\0A\09a.m_row[1].w = 0.f;\0A\09a.m_row[2].w = 0.f;\0A\09for(int i=0; i<3; i++)\0A\09{\0A//\09a.m_row[i].w = 0.f;\0A\09\09ans.m_row[i].x = b3Dot3F4(a.m_row[i],transB.m_row[0]);\0A\09\09ans.m_row[i].y = b3Dot3F4(a.m_row[i],transB.m_row[1]);\0A\09\09ans.m_row[i].z = b3Dot3F4(a.m_row[i],transB.m_row[2]);\0A\09\09ans.m_row[i].w = 0.f;\0A\09}\0A\09return ans;\0A}\0A__inline\0Ab3Float4 mtMul1(b3Mat3x3 a, b3Float4 b)\0A{\0A\09b3Float4 ans;\0A\09ans.x = b3Dot3F4( a.m_row[0], b );\0A\09ans.y = b3Dot3F4( a.m_row[1], b );\0A\09ans.z = b3Dot3F4( a.m_row[2], b );\0A\09ans.w = 0.f;\0A\09return ans;\0A}\0A__inline\0Ab3Float4 mtMul3(b3Float4 a, b3Mat3x3 b)\0A{\0A\09b3Float4 colx = b3MakeFloat4(b.m_row[0].x, b.m_row[1].x, b.m_row[2].x, 0);\0A\09b3Float4 coly = b3MakeFloat4(b.m_row[0].y, b.m_row[1].y, b.m_row[2].y, 0);\0A\09b3Float4 colz = b3MakeFloat4(b.m_row[0].z, b.m_row[1].z, b.m_row[2].z, 0);\0A\09b3Float4 ans;\0A\09ans.x = b3Dot3F4( a, colx );\0A\09ans.y = b3Dot3F4( a, coly );\0A\09ans.z = b3Dot3F4( a, colz );\0A\09return ans;\0A}\0A#endif\0A#endif //B3_MAT3x3_H\0Atypedef struct b3RigidBodyData b3RigidBodyData_t;\0Astruct b3RigidBodyData\0A{\0A\09b3Float4\09\09\09\09m_pos;\0A\09b3Quat\09\09\09\09\09m_quat;\0A\09b3Float4\09\09\09\09m_linVel;\0A\09b3Float4\09\09\09\09m_angVel;\0A\09int \09\09\09\09\09m_collidableIdx;\0A\09float \09\09\09\09m_invMass;\0A\09float \09\09\09\09m_restituitionCoeff;\0A\09float \09\09\09\09m_frictionCoeff;\0A};\0Atypedef struct b3InertiaData b3InertiaData_t;\0Astruct b3InertiaData\0A{\0A\09b3Mat3x3 m_invInertiaWorld;\0A\09b3Mat3x3 m_initInvInertia;\0A};\0A#endif //B3_RIGIDBODY_DATA_H\0A\09\0A#define GET_NPOINTS(x) (x).m_worldNormalOnB.w\0A#define SELECT_UINT4( b, a, condition ) select( b,a,condition )\0A#define make_float4 (float4)\0A#define make_float2 (float2)\0A#define make_uint4 (uint4)\0A#define make_int4 (int4)\0A#define make_uint2 (uint2)\0A#define make_int2 (int2)\0A__inline\0Afloat fastDiv(float numerator, float denominator)\0A{\0A\09return native_divide(numerator, denominator);\09\0A//\09return numerator/denominator;\09\0A}\0A__inline\0Afloat4 fastDiv4(float4 numerator, float4 denominator)\0A{\0A\09return native_divide(numerator, denominator);\09\0A}\0A__inline\0Afloat4 cross3(float4 a, float4 b)\0A{\0A\09return cross(a,b);\0A}\0A//#define dot3F4 dot\0A__inline\0Afloat dot3F4(float4 a, float4 b)\0A{\0A\09float4 a1 = make_float4(a.xyz,0.f);\0A\09float4 b1 = make_float4(b.xyz,0.f);\0A\09return dot(a1, b1);\0A}\0A__inline\0Afloat4 fastNormalize4(float4 v)\0A{\0A\09return fast_normalize(v);\0A}\0A///////////////////////////////////////\0A//\09Quaternion\0A///////////////////////////////////////\0Atypedef float4 Quaternion;\0A__inline\0AQuaternion qtMul(Quaternion a, Quaternion b);\0A__inline\0AQuaternion qtNormalize(Quaternion in);\0A__inline\0Afloat4 qtRotate(Quaternion q, float4 vec);\0A__inline\0AQuaternion qtInvert(Quaternion q);\0A__inline\0AQuaternion qtMul(Quaternion a, Quaternion b)\0A{\0A\09Quaternion ans;\0A\09ans = cross3( a, b );\0A\09ans += a.w*b+b.w*a;\0A//\09ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);\0A\09ans.w = a.w*b.w - dot3F4(a, b);\0A\09return ans;\0A}\0A__inline\0AQuaternion qtNormalize(Quaternion in)\0A{\0A\09return fastNormalize4(in);\0A//\09in /= length( in );\0A//\09return in;\0A}\0A__inline\0Afloat4 qtRotate(Quaternion q, float4 vec)\0A{\0A\09Quaternion qInv = qtInvert( q );\0A\09float4 vcpy = vec;\0A\09vcpy.w = 0.f;\0A\09float4 out = qtMul(qtMul(q,vcpy),qInv);\0A\09return out;\0A}\0A__inline\0AQuaternion qtInvert(Quaternion q)\0A{\0A\09return (Quaternion)(-q.xyz, q.w);\0A}\0A__inline\0Afloat4 qtInvRotate(const Quaternion q, float4 vec)\0A{\0A\09return qtRotate( qtInvert( q ), vec );\0A}\0A__inline\0Afloat4 transform(const float4* p, const float4* translation, const Quaternion* orientation)\0A{\0A\09return qtRotate( *orientation, *p ) + (*translation);\0A}\0A__inline\0Afloat4 normalize3(const float4 a)\0A{\0A\09float4 n = make_float4(a.x, a.y, a.z, 0.f);\0A\09return fastNormalize4( n );\0A}\0A__inline float4 lerp3(const float4 a,const float4 b, float  t)\0A{\0A\09return make_float4(\09a.x + (b.x - a.x) * t,\0A\09\09\09\09\09\09a.y + (b.y - a.y) * t,\0A\09\09\09\09\09\09a.z + (b.z - a.z) * t,\0A\09\09\09\09\09\090.f);\0A}\0A// Clips a face to the back of a plane, return the number of vertices out, stored in ppVtxOut\0Aint clipFaceGlobal(__global const float4* pVtxIn, int numVertsIn, float4 planeNormalWS,float planeEqWS, __global float4* ppVtxOut)\0A{\0A\09\0A\09int ve;\0A\09float ds, de;\0A\09int numVertsOut = 0;\0A    //double-check next test\0A    \09if (numVertsIn < 2)\0A    \09\09return 0;\0A    \0A\09float4 firstVertex=pVtxIn[numVertsIn-1];\0A\09float4 endVertex = pVtxIn[0];\0A\09\0A\09ds = dot3F4(planeNormalWS,firstVertex)+planeEqWS;\0A    \0A\09for (ve = 0; ve < numVertsIn; ve++)\0A\09{\0A\09\09endVertex=pVtxIn[ve];\0A\09\09de = dot3F4(planeNormalWS,endVertex)+planeEqWS;\0A\09\09if (ds<0)\0A\09\09{\0A\09\09\09if (de<0)\0A\09\09\09{\0A\09\09\09\09// Start < 0, end < 0, so output endVertex\0A\09\09\09\09ppVtxOut[numVertsOut++] = endVertex;\0A\09\09\09}\0A\09\09\09else\0A\09\09\09{\0A\09\09\09\09// Start < 0, end >= 0, so output intersection\0A\09\09\09\09ppVtxOut[numVertsOut++] = lerp3(firstVertex, endVertex,(ds * 1.f/(ds - de)) );\0A\09\09\09}\0A\09\09}\0A\09\09else\0A\09\09{\0A\09\09\09if (de<0)\0A\09\09\09{\0A\09\09\09\09// Start >= 0, end < 0 so output intersection and end\0A\09\09\09\09ppVtxOut[numVertsOut++] = lerp3(firstVertex, endVertex,(ds * 1.f/(ds - de)) );\0A\09\09\09\09ppVtxOut[numVertsOut++] = endVertex;\0A\09\09\09}\0A\09\09}\0A\09\09firstVertex = endVertex;\0A\09\09ds = de;\0A\09}\0A\09return numVertsOut;\0A}\0A// Clips a face to the back of a plane, return the number of vertices out, stored in ppVtxOut\0Aint clipFace(const float4* pVtxIn, int numVertsIn, float4 planeNormalWS,float planeEqWS, float4* ppVtxOut)\0A{\0A\09\0A\09int ve;\0A\09float ds, de;\0A\09int numVertsOut = 0;\0A//double-check next test\0A\09if (numVertsIn < 2)\0A\09\09return 0;\0A\09float4 firstVertex=pVtxIn[numVertsIn-1];\0A\09float4 endVertex = pVtxIn[0];\0A\09\0A\09ds = dot3F4(planeNormalWS,firstVertex)+planeEqWS;\0A\09for (ve = 0; ve < numVertsIn; ve++)\0A\09{\0A\09\09endVertex=pVtxIn[ve];\0A\09\09de = dot3F4(planeNormalWS,endVertex)+planeEqWS;\0A\09\09if (ds<0)\0A\09\09{\0A\09\09\09if (de<0)\0A\09\09\09{\0A\09\09\09\09// Start < 0, end < 0, so output endVertex\0A\09\09\09\09ppVtxOut[numVertsOut++] = endVertex;\0A\09\09\09}\0A\09\09\09else\0A\09\09\09{\0A\09\09\09\09// Start < 0, end >= 0, so output intersection\0A\09\09\09\09ppVtxOut[numVertsOut++] = lerp3(firstVertex, endVertex,(ds * 1.f/(ds - de)) );\0A\09\09\09}\0A\09\09}\0A\09\09else\0A\09\09{\0A\09\09\09if (de<0)\0A\09\09\09{\0A\09\09\09\09// Start >= 0, end < 0 so output intersection and end\0A\09\09\09\09ppVtxOut[numVertsOut++] = lerp3(firstVertex, endVertex,(ds * 1.f/(ds - de)) );\0A\09\09\09\09ppVtxOut[numVertsOut++] = endVertex;\0A\09\09\09}\0A\09\09}\0A\09\09firstVertex = endVertex;\0A\09\09ds = de;\0A\09}\0A\09return numVertsOut;\0A}\0Aint clipFaceAgainstHull(const float4 separatingNormal, __global const b3ConvexPolyhedronData_t* hullA,  \0A\09const float4 posA, const Quaternion ornA, float4* worldVertsB1, int numWorldVertsB1,\0A\09float4* worldVertsB2, int capacityWorldVertsB2,\0A\09const float minDist, float maxDist,\0A\09__global const float4* vertices,\0A\09__global const b3GpuFace_t* faces,\0A\09__global const int* indices,\0A\09float4* contactsOut,\0A\09int contactCapacity)\0A{\0A\09int numContactsOut = 0;\0A\09float4* pVtxIn = worldVertsB1;\0A\09float4* pVtxOut = worldVertsB2;\0A\09\0A\09int numVertsIn = numWorldVertsB1;\0A\09int numVertsOut = 0;\0A\09int closestFaceA=-1;\0A\09{\0A\09\09float dmin = FLT_MAX;\0A\09\09for(int face=0;face<hullA->m_numFaces;face++)\0A\09\09{\0A\09\09\09const float4 Normal = make_float4(\0A\09\09\09\09faces[hullA->m_faceOffset+face].m_plane.x, \0A\09\09\09\09faces[hullA->m_faceOffset+face].m_plane.y, \0A\09\09\09\09faces[hullA->m_faceOffset+face].m_plane.z,0.f);\0A\09\09\09const float4 faceANormalWS = qtRotate(ornA,Normal);\0A\09\09\0A\09\09\09float d = dot3F4(faceANormalWS,separatingNormal);\0A\09\09\09if (d < dmin)\0A\09\09\09{\0A\09\09\09\09dmin = d;\0A\09\09\09\09closestFaceA = face;\0A\09\09\09}\0A\09\09}\0A\09}\0A\09if (closestFaceA<0)\0A\09\09return numContactsOut;\0A\09b3GpuFace_t polyA = faces[hullA->m_faceOffset+closestFaceA];\0A\09// clip polygon to back of planes of all faces of hull A that are adjacent to witness face\0A\09int numVerticesA = polyA.m_numIndices;\0A\09for(int e0=0;e0<numVerticesA;e0++)\0A\09{\0A\09\09const float4 a = vertices[hullA->m_vertexOffset+indices[polyA.m_indexOffset+e0]];\0A\09\09const float4 b = vertices[hullA->m_vertexOffset+indices[polyA.m_indexOffset+((e0+1)%numVerticesA)]];\0A\09\09const float4 edge0 = a - b;\0A\09\09const float4 WorldEdge0 = qtRotate(ornA,edge0);\0A\09\09float4 planeNormalA = make_float4(polyA.m_plane.x,polyA.m_plane.y,polyA.m_plane.z,0.f);\0A\09\09float4 worldPlaneAnormal1 = qtRotate(ornA,planeNormalA);\0A\09\09float4 planeNormalWS1 = -cross3(WorldEdge0,worldPlaneAnormal1);\0A\09\09float4 worldA1 = transform(&a,&posA,&ornA);\0A\09\09float planeEqWS1 = -dot3F4(worldA1,planeNormalWS1);\0A\09\09\0A\09\09float4 planeNormalWS = planeNormalWS1;\0A\09\09float planeEqWS=planeEqWS1;\0A\09\09\0A\09\09//clip face\0A\09\09//clipFace(*pVtxIn, *pVtxOut,planeNormalWS,planeEqWS);\0A\09\09numVertsOut = clipFace(pVtxIn, numVertsIn, planeNormalWS,planeEqWS, pVtxOut);\0A\09\09//btSwap(pVtxIn,pVtxOut);\0A\09\09float4* tmp = pVtxOut;\0A\09\09pVtxOut = pVtxIn;\0A\09\09pVtxIn = tmp;\0A\09\09numVertsIn = numVertsOut;\0A\09\09numVertsOut = 0;\0A\09}\0A\09\0A\09// only keep points that are behind the witness face\0A\09{\0A\09\09float4 localPlaneNormal  = make_float4(polyA.m_plane.x,polyA.m_plane.y,polyA.m_plane.z,0.f);\0A\09\09float localPlaneEq = polyA.m_plane.w;\0A\09\09float4 planeNormalWS = qtRotate(ornA,localPlaneNormal);\0A\09\09float planeEqWS=localPlaneEq-dot3F4(planeNormalWS,posA);\0A\09\09for (int i=0;i<numVertsIn;i++)\0A\09\09{\0A\09\09\09float depth = dot3F4(planeNormalWS,pVtxIn[i])+planeEqWS;\0A\09\09\09if (depth <=minDist)\0A\09\09\09{\0A\09\09\09\09depth = minDist;\0A\09\09\09}\0A\09\09\09if (depth <=maxDist)\0A\09\09\09{\0A\09\09\09\09float4 pointInWorld = pVtxIn[i];\0A\09\09\09\09//resultOut.addContactPoint(separatingNormal,point,depth);\0A\09\09\09\09contactsOut[numContactsOut++] = make_float4(pointInWorld.x,pointInWorld.y,pointInWorld.z,depth);\0A\09\09\09}\0A\09\09}\0A\09}\0A\09return numContactsOut;\0A}\0Aint clipFaceAgainstHullLocalA(const float4 separatingNormal, const b3ConvexPolyhedronData_t* hullA,  \0A\09const float4 posA, const Quaternion ornA, float4* worldVertsB1, int numWorldVertsB1,\0A\09float4* worldVertsB2, int capacityWorldVertsB2,\0A\09const float minDist, float maxDist,\0A\09const float4* verticesA,\0A\09const b3GpuFace_t* facesA,\0A\09const int* indicesA,\0A\09__global const float4* verticesB,\0A\09__global const b3GpuFace_t* facesB,\0A\09__global const int* indicesB,\0A\09float4* contactsOut,\0A\09int contactCapacity)\0A{\0A\09int numContactsOut = 0;\0A\09float4* pVtxIn = worldVertsB1;\0A\09float4* pVtxOut = worldVertsB2;\0A\09\0A\09int numVertsIn = numWorldVertsB1;\0A\09int numVertsOut = 0;\0A\09int closestFaceA=-1;\0A\09{\0A\09\09float dmin = FLT_MAX;\0A\09\09for(int face=0;face<hullA->m_numFaces;face++)\0A\09\09{\0A\09\09\09const float4 Normal = make_float4(\0A\09\09\09\09facesA[hullA->m_faceOffset+face].m_plane.x, \0A\09\09\09\09facesA[hullA->m_faceOffset+face].m_plane.y, \0A\09\09\09\09facesA[hullA->m_faceOffset+face].m_plane.z,0.f);\0A\09\09\09const float4 faceANormalWS = qtRotate(ornA,Normal);\0A\09\09\0A\09\09\09float d = dot3F4(faceANormalWS,separatingNormal);\0A\09\09\09if (d < dmin)\0A\09\09\09{\0A\09\09\09\09dmin = d;\0A\09\09\09\09closestFaceA = face;\0A\09\09\09}\0A\09\09}\0A\09}\0A\09if (closestFaceA<0)\0A\09\09return numContactsOut;\0A\09b3GpuFace_t polyA = facesA[hullA->m_faceOffset+closestFaceA];\0A\09// clip polygon to back of planes of all faces of hull A that are adjacent to witness face\0A\09int numVerticesA = polyA.m_numIndices;\0A\09for(int e0=0;e0<numVerticesA;e0++)\0A\09{\0A\09\09const float4 a = verticesA[hullA->m_vertexOffset+indicesA[polyA.m_indexOffset+e0]];\0A\09\09const float4 b = verticesA[hullA->m_vertexOffset+indicesA[polyA.m_indexOffset+((e0+1)%numVerticesA)]];\0A\09\09const float4 edge0 = a - b;\0A\09\09const float4 WorldEdge0 = qtRotate(ornA,edge0);\0A\09\09float4 planeNormalA = make_float4(polyA.m_plane.x,polyA.m_plane.y,polyA.m_plane.z,0.f);\0A\09\09float4 worldPlaneAnormal1 = qtRotate(ornA,planeNormalA);\0A\09\09float4 planeNormalWS1 = -cross3(WorldEdge0,worldPlaneAnormal1);\0A\09\09float4 worldA1 = transform(&a,&posA,&ornA);\0A\09\09float planeEqWS1 = -dot3F4(worldA1,planeNormalWS1);\0A\09\09\0A\09\09float4 planeNormalWS = planeNormalWS1;\0A\09\09float planeEqWS=planeEqWS1;\0A\09\09\0A\09\09//clip face\0A\09\09//clipFace(*pVtxIn, *pVtxOut,planeNormalWS,planeEqWS);\0A\09\09numVertsOut = clipFace(pVtxIn, numVertsIn, planeNormalWS,planeEqWS, pVtxOut);\0A\09\09//btSwap(pVtxIn,pVtxOut);\0A\09\09float4* tmp = pVtxOut;\0A\09\09pVtxOut = pVtxIn;\0A\09\09pVtxIn = tmp;\0A\09\09numVertsIn = numVertsOut;\0A\09\09numVertsOut = 0;\0A\09}\0A\09\0A\09// only keep points that are behind the witness face\0A\09{\0A\09\09float4 localPlaneNormal  = make_float4(polyA.m_plane.x,polyA.m_plane.y,polyA.m_plane.z,0.f);\0A\09\09float localPlaneEq = polyA.m_plane.w;\0A\09\09float4 planeNormalWS = qtRotate(ornA,localPlaneNormal);\0A\09\09float planeEqWS=localPlaneEq-dot3F4(planeNormalWS,posA);\0A\09\09for (int i=0;i<numVertsIn;i++)\0A\09\09{\0A\09\09\09float depth = dot3F4(planeNormalWS,pVtxIn[i])+planeEqWS;\0A\09\09\09if (depth <=minDist)\0A\09\09\09{\0A\09\09\09\09depth = minDist;\0A\09\09\09}\0A\09\09\09if (depth <=maxDist)\0A\09\09\09{\0A\09\09\09\09float4 pointInWorld = pVtxIn[i];\0A\09\09\09\09//resultOut.addContactPoint(separatingNormal,point,depth);\0A\09\09\09\09contactsOut[numContactsOut++] = make_float4(pointInWorld.x,pointInWorld.y,pointInWorld.z,depth);\0A\09\09\09}\0A\09\09}\0A\09}\0A\09return numContactsOut;\0A}\0Aint\09clipHullAgainstHull(const float4 separatingNormal,\0A\09__global const b3ConvexPolyhedronData_t* hullA, __global const b3ConvexPolyhedronData_t* hullB, \0A\09const float4 posA, const Quaternion ornA,const float4 posB, const Quaternion ornB, \0A\09float4* worldVertsB1, float4* worldVertsB2, int capacityWorldVerts,\0A\09const float minDist, float maxDist,\0A\09__global const float4* vertices,\0A\09__global const b3GpuFace_t* faces,\0A\09__global const int* indices,\0A\09float4*\09localContactsOut,\0A\09int localContactCapacity)\0A{\0A\09int numContactsOut = 0;\0A\09int numWorldVertsB1= 0;\0A\09int closestFaceB=-1;\0A\09float dmax = -FLT_MAX;\0A\09{\0A\09\09for(int face=0;face<hullB->m_numFaces;face++)\0A\09\09{\0A\09\09\09const float4 Normal = make_float4(faces[hullB->m_faceOffset+face].m_plane.x, \0A\09\09\09\09faces[hullB->m_faceOffset+face].m_plane.y, faces[hullB->m_faceOffset+face].m_plane.z,0.f);\0A\09\09\09const float4 WorldNormal = qtRotate(ornB, Normal);\0A\09\09\09float d = dot3F4(WorldNormal,separatingNormal);\0A\09\09\09if (d > dmax)\0A\09\09\09{\0A\09\09\09\09dmax = d;\0A\09\09\09\09closestFaceB = face;\0A\09\09\09}\0A\09\09}\0A\09}\0A\09{\0A\09\09const b3GpuFace_t polyB = faces[hullB->m_faceOffset+closestFaceB];\0A\09\09const int numVertices = polyB.m_numIndices;\0A\09\09for(int e0=0;e0<numVertices;e0++)\0A\09\09{\0A\09\09\09const float4 b = vertices[hullB->m_vertexOffset+indices[polyB.m_indexOffset+e0]];\0A\09\09\09worldVertsB1[numWorldVertsB1++] = transform(&b,&posB,&ornB);\0A\09\09}\0A\09}\0A\09if (closestFaceB>=0)\0A\09{\0A\09\09numContactsOut = clipFaceAgainstHull(separatingNormal, hullA, \0A\09\09\09\09posA,ornA,\0A\09\09\09\09worldVertsB1,numWorldVertsB1,worldVertsB2,capacityWorldVerts, minDist, maxDist,vertices,\0A\09\09\09\09faces,\0A\09\09\09\09indices,localContactsOut,localContactCapacity);\0A\09}\0A\09return numContactsOut;\0A}\0Aint\09clipHullAgainstHullLocalA(const float4 separatingNormal,\0A\09const b3ConvexPolyhedronData_t* hullA, __global const b3ConvexPolyhedronData_t* hullB, \0A\09const float4 posA, const Quaternion ornA,const float4 posB, const Quaternion ornB, \0A\09float4* worldVertsB1, float4* worldVertsB2, int capacityWorldVerts,\0A\09const float minDist, float maxDist,\0A\09const float4* verticesA,\0A\09const b3GpuFace_t* facesA,\0A\09const int* indicesA,\0A\09__global const float4* verticesB,\0A\09__global const b3GpuFace_t* facesB,\0A\09__global const int* indicesB,\0A\09float4*\09localContactsOut,\0A\09int localContactCapacity)\0A{\0A\09int numContactsOut = 0;\0A\09int numWorldVertsB1= 0;\0A\09int closestFaceB=-1;\0A\09float dmax = -FLT_MAX;\0A\09{\0A\09\09for(int face=0;face<hullB->m_numFaces;face++)\0A\09\09{\0A\09\09\09const float4 Normal = make_float4(facesB[hullB->m_faceOffset+face].m_plane.x, \0A\09\09\09\09facesB[hullB->m_faceOffset+face].m_plane.y, facesB[hullB->m_faceOffset+face].m_plane.z,0.f);\0A\09\09\09const float4 WorldNormal = qtRotate(ornB, Normal);\0A\09\09\09float d = dot3F4(WorldNormal,separatingNormal);\0A\09\09\09if (d > dmax)\0A\09\09\09{\0A\09\09\09\09dmax = d;\0A\09\09\09\09closestFaceB = face;\0A\09\09\09}\0A\09\09}\0A\09}\0A\09{\0A\09\09const b3GpuFace_t polyB = facesB[hullB->m_faceOffset+closestFaceB];\0A\09\09const int numVertices = polyB.m_numIndices;\0A\09\09for(int e0=0;e0<numVertices;e0++)\0A\09\09{\0A\09\09\09const float4 b = verticesB[hullB->m_vertexOffset+indicesB[polyB.m_indexOffset+e0]];\0A\09\09\09worldVertsB1[numWorldVertsB1++] = transform(&b,&posB,&ornB);\0A\09\09}\0A\09}\0A\09if (closestFaceB>=0)\0A\09{\0A\09\09numContactsOut = clipFaceAgainstHullLocalA(separatingNormal, hullA, \0A\09\09\09\09posA,ornA,\0A\09\09\09\09worldVertsB1,numWorldVertsB1,worldVertsB2,capacityWorldVerts, minDist, maxDist,\0A\09\09\09\09verticesA,facesA,indicesA,\0A\09\09\09\09verticesB,facesB,indicesB,\0A\09\09\09\09localContactsOut,localContactCapacity);\0A\09}\0A\09return numContactsOut;\0A}\0A#define PARALLEL_SUM(v, n) for(int j=1; j<n; j++) v[0] += v[j];\0A#define PARALLEL_DO(execution, n) for(int ie=0; ie<n; ie++){execution;}\0A#define REDUCE_MAX(v, n) {int i=0; for(int offset=0; offset<n; offset++) v[i] = (v[i].y > v[i+offset].y)? v[i]: v[i+offset]; }\0A#define REDUCE_MIN(v, n) {int i=0; for(int offset=0; offset<n; offset++) v[i] = (v[i].y < v[i+offset].y)? v[i]: v[i+offset]; }\0Aint extractManifoldSequentialGlobal(__global const float4* p, int nPoints, float4 nearNormal, int4* contactIdx)\0A{\0A\09if( nPoints == 0 )\0A        return 0;\0A    \0A    if (nPoints <=4)\0A        return nPoints;\0A    \0A    \0A    if (nPoints >64)\0A        nPoints = 64;\0A    \0A\09float4 center = make_float4(0.f);\0A\09{\0A\09\09\0A\09\09for (int i=0;i<nPoints;i++)\0A\09\09\09center += p[i];\0A\09\09center /= (float)nPoints;\0A\09}\0A    \0A\09\0A    \0A\09//\09sample 4 directions\0A    \0A    float4 aVector = p[0] - center;\0A    float4 u = cross3( nearNormal, aVector );\0A    float4 v = cross3( nearNormal, u );\0A    u = normalize3( u );\0A    v = normalize3( v );\0A    \0A    \0A    //keep point with deepest penetration\0A    float minW= FLT_MAX;\0A    \0A    int minIndex=-1;\0A    \0A    float4 maxDots;\0A    maxDots.x = FLT_MIN;\0A    maxDots.y = FLT_MIN;\0A    maxDots.z = FLT_MIN;\0A    maxDots.w = FLT_MIN;\0A    \0A    //\09idx, distance\0A    for(int ie = 0; ie<nPoints; ie++ )\0A    {\0A        if (p[ie].w<minW)\0A        {\0A            minW = p[ie].w;\0A            minIndex=ie;\0A        }\0A        float f;\0A        float4 r = p[ie]-center;\0A        f = dot3F4( u, r );\0A        if (f<maxDots.x)\0A        {\0A            maxDots.x = f;\0A            contactIdx[0].x = ie;\0A        }\0A        \0A        f = dot3F4( -u, r );\0A        if (f<maxDots.y)\0A        {\0A            maxDots.y = f;\0A            contactIdx[0].y = ie;\0A        }\0A        \0A        \0A        f = dot3F4( v, r );\0A        if (f<maxDots.z)\0A        {\0A            maxDots.z = f;\0A            contactIdx[0].z = ie;\0A        }\0A        \0A        f = dot3F4( -v, r );\0A        if (f<maxDots.w)\0A        {\0A            maxDots.w = f;\0A            contactIdx[0].w = ie;\0A        }\0A        \0A    }\0A    \0A    if (contactIdx[0].x != minIndex && contactIdx[0].y != minIndex && contactIdx[0].z != minIndex && contactIdx[0].w != minIndex)\0A    {\0A        //replace the first contact with minimum (todo: replace contact with least penetration)\0A        contactIdx[0].x = minIndex;\0A    }\0A    \0A    return 4;\0A    \0A}\0Aint extractManifoldSequentialGlobalFake(__global const float4* p, int nPoints, float4 nearNormal, int* contactIdx)\0A{\0A    contactIdx[0] = 0;\0A    contactIdx[1] = 1;\0A    contactIdx[2] = 2;\0A    contactIdx[3] = 3;\0A    \0A\09if( nPoints == 0 ) return 0;\0A    \0A\09nPoints = min2( nPoints, 4 );\0A    return nPoints;\0A    \0A}\0Aint extractManifoldSequential(const float4* p, int nPoints, float4 nearNormal, int* contactIdx)\0A{\0A\09if( nPoints == 0 ) return 0;\0A\09nPoints = min2( nPoints, 64 );\0A\09float4 center = make_float4(0.f);\0A\09{\0A\09\09float4 v[64];\0A\09\09for (int i=0;i<nPoints;i++)\0A\09\09\09v[i] = p[i];\0A\09\09//memcpy( v, p, nPoints*sizeof(float4) );\0A\09\09PARALLEL_SUM( v, nPoints );\0A\09\09center = v[0]/(float)nPoints;\0A\09}\0A\09\0A\09{\09//\09sample 4 directions\0A\09\09if( nPoints < 4 )\0A\09\09{\0A\09\09\09for(int i=0; i<nPoints; i++) \0A\09\09\09\09contactIdx[i] = i;\0A\09\09\09return nPoints;\0A\09\09}\0A\09\09float4 aVector = p[0] - center;\0A\09\09float4 u = cross3( nearNormal, aVector );\0A\09\09float4 v = cross3( nearNormal, u );\0A\09\09u = normalize3( u );\0A\09\09v = normalize3( v );\0A\09\09int idx[4];\0A\09\09float2 max00 = make_float2(0,FLT_MAX);\0A\09\09{\0A\09\09\09//\09idx, distance\0A\09\09\09{\0A\09\09\09\09{\0A\09\09\09\09\09int4 a[64];\0A\09\09\09\09\09for(int ie = 0; ie<nPoints; ie++ )\0A\09\09\09\09\09{\0A\09\09\09\09\09\09\0A\09\09\09\09\09\09\0A\09\09\09\09\09\09float f;\0A\09\09\09\09\09\09float4 r = p[ie]-center;\0A\09\09\09\09\09\09f = dot3F4( u, r );\0A\09\09\09\09\09\09a[ie].x = ((*(u32*)&f) & 0xffffff00) | (0xff & ie);\0A\09\09\09\09\09\09f = dot3F4( -u, r );\0A\09\09\09\09\09\09a[ie].y = ((*(u32*)&f) & 0xffffff00) | (0xff & ie);\0A\09\09\09\09\09\09f = dot3F4( v, r );\0A\09\09\09\09\09\09a[ie].z = ((*(u32*)&f) & 0xffffff00) | (0xff & ie);\0A\09\09\09\09\09\09f = dot3F4( -v, r );\0A\09\09\09\09\09\09a[ie].w = ((*(u32*)&f) & 0xffffff00) | (0xff & ie);\0A\09\09\09\09\09}\0A\09\09\09\09\09for(int ie=0; ie<nPoints; ie++)\0A\09\09\09\09\09{\0A\09\09\09\09\09\09a[0].x = (a[0].x > a[ie].x )? a[0].x: a[ie].x;\0A\09\09\09\09\09\09a[0].y = (a[0].y > a[ie].y )? a[0].y: a[ie].y;\0A\09\09\09\09\09\09a[0].z = (a[0].z > a[ie].z )? a[0].z: a[ie].z;\0A\09\09\09\09\09\09a[0].w = (a[0].w > a[ie].w )? a[0].w: a[ie].w;\0A\09\09\09\09\09}\0A\09\09\09\09\09idx[0] = (int)a[0].x & 0xff;\0A\09\09\09\09\09idx[1] = (int)a[0].y & 0xff;\0A\09\09\09\09\09idx[2] = (int)a[0].z & 0xff;\0A\09\09\09\09\09idx[3] = (int)a[0].w & 0xff;\0A\09\09\09\09}\0A\09\09\09}\0A\09\09\09{\0A\09\09\09\09float2 h[64];\0A\09\09\09\09PARALLEL_DO( h[ie] = make_float2((float)ie, p[ie].w), nPoints );\0A\09\09\09\09REDUCE_MIN( h, nPoints );\0A\09\09\09\09max00 = h[0];\0A\09\09\09}\0A\09\09}\0A\09\09contactIdx[0] = idx[0];\0A\09\09contactIdx[1] = idx[1];\0A\09\09contactIdx[2] = idx[2];\0A\09\09contactIdx[3] = idx[3];\0A\09\09return 4;\0A\09}\0A}\0A__kernel void   extractManifoldAndAddContactKernel(__global const int4* pairs, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3RigidBodyData_t* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* closestPointsWorld,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* separatingNormalsWorld,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* contactCounts,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* contactOffsets,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global struct b3Contact4Data* restrict contactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09counter32_t nContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int contactCapacity,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numPairs,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int pairIndex\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09)\0A{\0A\09int idx = get_global_id(0);\0A\09\0A\09if (idx<numPairs)\0A\09{\0A\09\09float4 normal = separatingNormalsWorld[idx];\0A\09\09int nPoints = contactCounts[idx];\0A\09\09__global const float4* pointsIn = &closestPointsWorld[contactOffsets[idx]];\0A\09\09float4 localPoints[64];\0A\09\09for (int i=0;i<nPoints;i++)\0A\09\09{\0A\09\09\09localPoints[i] = pointsIn[i];\0A\09\09}\0A\09\09int contactIdx[4];// = {-1,-1,-1,-1};\0A\09\09contactIdx[0] = -1;\0A\09\09contactIdx[1] = -1;\0A\09\09contactIdx[2] = -1;\0A\09\09contactIdx[3] = -1;\0A\09\09int nContacts = extractManifoldSequential(localPoints, nPoints, normal, contactIdx);\0A\09\09int dstIdx;\0A\09\09AppendInc( nContactsOut, dstIdx );\0A\09\09if (dstIdx<contactCapacity)\0A\09\09{\0A\09\09\09__global struct b3Contact4Data* c = contactsOut + dstIdx;\0A\09\09\09c->m_worldNormalOnB = -normal;\0A\09\09\09c->m_restituitionCoeffCmp = (0.f*0xffff);c->m_frictionCoeffCmp = (0.7f*0xffff);\0A\09\09\09c->m_batchIdx = idx;\0A\09\09\09int bodyA = pairs[pairIndex].x;\0A\09\09\09int bodyB = pairs[pairIndex].y;\0A\09\09\09c->m_bodyAPtrAndSignBit = rigidBodies[bodyA].m_invMass==0 ? -bodyA:bodyA;\0A\09\09\09c->m_bodyBPtrAndSignBit = rigidBodies[bodyB].m_invMass==0 ? -bodyB:bodyB;\0A\09\09\09c->m_childIndexA = -1;\0A\09\09\09c->m_childIndexB = -1;\0A\09\09\09for (int i=0;i<nContacts;i++)\0A\09\09\09{\0A\09\09\09\09c->m_worldPosB[i] = localPoints[contactIdx[i]];\0A\09\09\09}\0A\09\09\09GET_NPOINTS(*c) = nContacts;\0A\09\09}\0A\09}\0A}\0Avoid\09trInverse(float4 translationIn, Quaternion orientationIn,\0A\09\09float4* translationOut, Quaternion* orientationOut)\0A{\0A\09*orientationOut = qtInvert(orientationIn);\0A\09*translationOut = qtRotate(*orientationOut, -translationIn);\0A}\0Avoid\09trMul(float4 translationA, Quaternion orientationA,\0A\09\09\09\09\09\09float4 translationB, Quaternion orientationB,\0A\09\09float4* translationOut, Quaternion* orientationOut)\0A{\0A\09*orientationOut = qtMul(orientationA,orientationB);\0A\09*translationOut = transform(&translationB,&translationA,&orientationA);\0A}\0A__kernel void   clipHullHullKernel( __global int4* pairs, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3RigidBodyData_t* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3Collidable_t* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3ConvexPolyhedronData_t* convexShapes, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* vertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* uniqueEdges,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3GpuFace_t* faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* separatingNormals,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* hasSeparatingAxis,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global struct b3Contact4Data* restrict globalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09counter32_t nGlobalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numPairs,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int contactCapacity)\0A{\0A\09int i = get_global_id(0);\0A\09int pairIndex = i;\0A\09\0A\09float4 worldVertsB1[64];\0A\09float4 worldVertsB2[64];\0A\09int capacityWorldVerts = 64;\09\0A\09float4 localContactsOut[64];\0A\09int localContactCapacity=64;\0A\09\0A\09float minDist = -1e30f;\0A\09float maxDist = 0.02f;\0A\09if (i<numPairs)\0A\09{\0A\09\09int bodyIndexA = pairs[i].x;\0A\09\09int bodyIndexB = pairs[i].y;\0A\09\09\09\0A\09\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09\09if (hasSeparatingAxis[i])\0A\09\09{\0A\09\09\09\0A\09\09\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09\09\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09\09\09\0A\09\09\0A\09\09\09int numLocalContactsOut = clipHullAgainstHull(separatingNormals[i],\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09&convexShapes[shapeIndexA], &convexShapes[shapeIndexB],\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09rigidBodies[bodyIndexA].m_pos,rigidBodies[bodyIndexA].m_quat,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09  rigidBodies[bodyIndexB].m_pos,rigidBodies[bodyIndexB].m_quat,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09  worldVertsB1,worldVertsB2,capacityWorldVerts,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09minDist, maxDist,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09vertices,faces,indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09localContactsOut,localContactCapacity);\0A\09\09\09\09\09\09\09\09\09\09\09\09\0A\09\09if (numLocalContactsOut>0)\0A\09\09{\0A\09\09\09\09float4 normal = -separatingNormals[i];\0A\09\09\09\09int nPoints = numLocalContactsOut;\0A\09\09\09\09float4* pointsIn = localContactsOut;\0A\09\09\09\09int contactIdx[4];// = {-1,-1,-1,-1};\0A\09\09\09\09contactIdx[0] = -1;\0A\09\09\09\09contactIdx[1] = -1;\0A\09\09\09\09contactIdx[2] = -1;\0A\09\09\09\09contactIdx[3] = -1;\0A\09\09\0A\09\09\09\09int nReducedContacts = extractManifoldSequential(pointsIn, nPoints, normal, contactIdx);\0A\09\09\0A\09\09\09\09\0A\09\09\09\09int mprContactIndex = pairs[pairIndex].z;\0A\09\09\09\09int dstIdx = mprContactIndex;\0A\09\09\09\09if (dstIdx<0)\0A\09\09\09\09{\0A\09\09\09\09\09AppendInc( nGlobalContactsOut, dstIdx );\0A\09\09\09\09}\0A\09\09\09\09if (dstIdx<contactCapacity)\0A\09\09\09\09{\0A\09\09\09\09\09pairs[pairIndex].z = dstIdx;\0A\09\09\09\09\09__global struct b3Contact4Data* c = globalContactsOut+ dstIdx;\0A\09\09\09\09\09c->m_worldNormalOnB = -normal;\0A\09\09\09\09\09c->m_restituitionCoeffCmp = (0.f*0xffff);c->m_frictionCoeffCmp = (0.7f*0xffff);\0A\09\09\09\09\09c->m_batchIdx = pairIndex;\0A\09\09\09\09\09int bodyA = pairs[pairIndex].x;\0A\09\09\09\09\09int bodyB = pairs[pairIndex].y;\0A\09\09\09\09\09c->m_bodyAPtrAndSignBit = rigidBodies[bodyA].m_invMass==0?-bodyA:bodyA;\0A\09\09\09\09\09c->m_bodyBPtrAndSignBit = rigidBodies[bodyB].m_invMass==0?-bodyB:bodyB;\0A\09\09\09\09\09c->m_childIndexA = -1;\0A\09\09\09\09\09c->m_childIndexB = -1;\0A\09\09\09\09\09for (int i=0;i<nReducedContacts;i++)\0A\09\09\09\09\09{\0A\09\09\09\09\09//this condition means: overwrite contact point, unless at index i==0 we have a valid 'mpr' contact\0A\09\09\09\09\09\09if (i>0||(mprContactIndex<0))\0A\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09c->m_worldPosB[i] = pointsIn[contactIdx[i]];\0A\09\09\09\09\09\09}\0A\09\09\09\09\09}\0A\09\09\09\09\09GET_NPOINTS(*c) = nReducedContacts;\0A\09\09\09\09}\0A\09\09\09\09\0A\09\09\09}//\09\09if (numContactsOut>0)\0A\09\09}//\09\09if (hasSeparatingAxis[i])\0A\09}//\09if (i<numPairs)\0A}\0A__kernel void   clipCompoundsHullHullKernel( __global const int4* gpuCompoundPairs, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3RigidBodyData_t* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3Collidable_t* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3ConvexPolyhedronData_t* convexShapes, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* vertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* uniqueEdges,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3GpuFace_t* faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3GpuChildShape_t* gpuChildShapes,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* gpuCompoundSepNormalsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* gpuHasCompoundSepNormalsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global struct b3Contact4Data* restrict globalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09counter32_t nGlobalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numCompoundPairs, int maxContactCapacity)\0A{\0A\09int i = get_global_id(0);\0A\09int pairIndex = i;\0A\09\0A\09float4 worldVertsB1[64];\0A\09float4 worldVertsB2[64];\0A\09int capacityWorldVerts = 64;\09\0A\09float4 localContactsOut[64];\0A\09int localContactCapacity=64;\0A\09\0A\09float minDist = -1e30f;\0A\09float maxDist = 0.02f;\0A\09if (i<numCompoundPairs)\0A\09{\0A\09\09if (gpuHasCompoundSepNormalsOut[i])\0A\09\09{\0A\09\09\09int bodyIndexA = gpuCompoundPairs[i].x;\0A\09\09\09int bodyIndexB = gpuCompoundPairs[i].y;\0A\09\09\09\0A\09\09\09int childShapeIndexA = gpuCompoundPairs[i].z;\0A\09\09\09int childShapeIndexB = gpuCompoundPairs[i].w;\0A\09\09\09\0A\09\09\09int collidableIndexA = -1;\0A\09\09\09int collidableIndexB = -1;\0A\09\09\09\0A\09\09\09float4 ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09\09\0A\09\09\09float4 ornB = rigidBodies[bodyIndexB].m_quat;\0A\09\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09\09\09\09\09\09\0A\09\09\09if (childShapeIndexA >= 0)\0A\09\09\09{\0A\09\09\09\09collidableIndexA = gpuChildShapes[childShapeIndexA].m_shapeIndex;\0A\09\09\09\09float4 childPosA = gpuChildShapes[childShapeIndexA].m_childPosition;\0A\09\09\09\09float4 childOrnA = gpuChildShapes[childShapeIndexA].m_childOrientation;\0A\09\09\09\09float4 newPosA = qtRotate(ornA,childPosA)+posA;\0A\09\09\09\09float4 newOrnA = qtMul(ornA,childOrnA);\0A\09\09\09\09posA = newPosA;\0A\09\09\09\09ornA = newOrnA;\0A\09\09\09} else\0A\09\09\09{\0A\09\09\09\09collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09\09}\0A\09\09\09\0A\09\09\09if (childShapeIndexB>=0)\0A\09\09\09{\0A\09\09\09\09collidableIndexB = gpuChildShapes[childShapeIndexB].m_shapeIndex;\0A\09\09\09\09float4 childPosB = gpuChildShapes[childShapeIndexB].m_childPosition;\0A\09\09\09\09float4 childOrnB = gpuChildShapes[childShapeIndexB].m_childOrientation;\0A\09\09\09\09float4 newPosB = transform(&childPosB,&posB,&ornB);\0A\09\09\09\09float4 newOrnB = qtMul(ornB,childOrnB);\0A\09\09\09\09posB = newPosB;\0A\09\09\09\09ornB = newOrnB;\0A\09\09\09} else\0A\09\09\09{\0A\09\09\09\09collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\09\0A\09\09\09}\0A\09\09\09\0A\09\09\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09\09\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09\09\0A\09\09\09int numLocalContactsOut = clipHullAgainstHull(gpuCompoundSepNormalsOut[i],\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09&convexShapes[shapeIndexA], &convexShapes[shapeIndexB],\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09posA,ornA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09  posB,ornB,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09  worldVertsB1,worldVertsB2,capacityWorldVerts,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09minDist, maxDist,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09vertices,faces,indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09localContactsOut,localContactCapacity);\0A\09\09\09\09\09\09\09\09\09\09\09\09\0A\09\09if (numLocalContactsOut>0)\0A\09\09{\0A\09\09\09\09float4 normal = -gpuCompoundSepNormalsOut[i];\0A\09\09\09\09int nPoints = numLocalContactsOut;\0A\09\09\09\09float4* pointsIn = localContactsOut;\0A\09\09\09\09int contactIdx[4];// = {-1,-1,-1,-1};\0A\09\09\09\09contactIdx[0] = -1;\0A\09\09\09\09contactIdx[1] = -1;\0A\09\09\09\09contactIdx[2] = -1;\0A\09\09\09\09contactIdx[3] = -1;\0A\09\09\0A\09\09\09\09int nReducedContacts = extractManifoldSequential(pointsIn, nPoints, normal, contactIdx);\0A\09\09\0A\09\09\09\09int dstIdx;\0A\09\09\09\09AppendInc( nGlobalContactsOut, dstIdx );\0A\09\09\09\09if ((dstIdx+nReducedContacts) < maxContactCapacity)\0A\09\09\09\09{\0A\09\09\09\09\09__global struct b3Contact4Data* c = globalContactsOut+ dstIdx;\0A\09\09\09\09\09c->m_worldNormalOnB = -normal;\0A\09\09\09\09\09c->m_restituitionCoeffCmp = (0.f*0xffff);c->m_frictionCoeffCmp = (0.7f*0xffff);\0A\09\09\09\09\09c->m_batchIdx = pairIndex;\0A\09\09\09\09\09int bodyA = gpuCompoundPairs[pairIndex].x;\0A\09\09\09\09\09int bodyB = gpuCompoundPairs[pairIndex].y;\0A\09\09\09\09\09c->m_bodyAPtrAndSignBit = rigidBodies[bodyA].m_invMass==0?-bodyA:bodyA;\0A\09\09\09\09\09c->m_bodyBPtrAndSignBit = rigidBodies[bodyB].m_invMass==0?-bodyB:bodyB;\0A\09\09\09\09\09c->m_childIndexA = childShapeIndexA;\0A\09\09\09\09\09c->m_childIndexB = childShapeIndexB;\0A\09\09\09\09\09for (int i=0;i<nReducedContacts;i++)\0A\09\09\09\09\09{\0A\09\09\09\09\09\09c->m_worldPosB[i] = pointsIn[contactIdx[i]];\0A\09\09\09\09\09}\0A\09\09\09\09\09GET_NPOINTS(*c) = nReducedContacts;\0A\09\09\09\09}\0A\09\09\09\09\0A\09\09\09}//\09\09if (numContactsOut>0)\0A\09\09}//\09\09if (gpuHasCompoundSepNormalsOut[i])\0A\09}//\09if (i<numCompoundPairs)\0A}\0A__kernel void   sphereSphereCollisionKernel( __global const int4* pairs, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3RigidBodyData_t* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3Collidable_t* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* separatingNormals,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* hasSeparatingAxis,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global struct b3Contact4Data* restrict globalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09counter32_t nGlobalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int contactCapacity,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numPairs)\0A{\0A\09int i = get_global_id(0);\0A\09int pairIndex = i;\0A\09\0A\09if (i<numPairs)\0A\09{\0A\09\09int bodyIndexA = pairs[i].x;\0A\09\09int bodyIndexB = pairs[i].y;\0A\09\09\09\0A\09\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09\09if (collidables[collidableIndexA].m_shapeType == SHAPE_SPHERE &&\0A\09\09\09collidables[collidableIndexB].m_shapeType == SHAPE_SPHERE)\0A\09\09{\0A\09\09\09//sphere-sphere\0A\09\09\09float radiusA = collidables[collidableIndexA].m_radius;\0A\09\09\09float radiusB = collidables[collidableIndexB].m_radius;\0A\09\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09float4 diff = posA-posB;\0A\09\09\09float len = length(diff);\0A\09\09\09\0A\09\09\09///iff distance positive, don't generate a new contact\0A\09\09\09if ( len <= (radiusA+radiusB))\0A\09\09\09{\0A\09\09\09\09///distance (negative means penetration)\0A\09\09\09\09float dist = len - (radiusA+radiusB);\0A\09\09\09\09float4 normalOnSurfaceB = make_float4(1.f,0.f,0.f,0.f);\0A\09\09\09\09if (len > 0.00001)\0A\09\09\09\09{\0A\09\09\09\09\09normalOnSurfaceB = diff / len;\0A\09\09\09\09}\0A\09\09\09\09float4 contactPosB = posB + normalOnSurfaceB*radiusB;\0A\09\09\09\09contactPosB.w = dist;\0A\09\09\09\09\09\09\09\09\0A\09\09\09\09int dstIdx;\0A\09\09\09\09AppendInc( nGlobalContactsOut, dstIdx );\0A\09\09\09\09if (dstIdx < contactCapacity)\0A\09\09\09\09{\0A\09\09\09\09\09__global struct b3Contact4Data* c = &globalContactsOut[dstIdx];\0A\09\09\09\09\09c->m_worldNormalOnB = -normalOnSurfaceB;\0A\09\09\09\09\09c->m_restituitionCoeffCmp = (0.f*0xffff);c->m_frictionCoeffCmp = (0.7f*0xffff);\0A\09\09\09\09\09c->m_batchIdx = pairIndex;\0A\09\09\09\09\09int bodyA = pairs[pairIndex].x;\0A\09\09\09\09\09int bodyB = pairs[pairIndex].y;\0A\09\09\09\09\09c->m_bodyAPtrAndSignBit = rigidBodies[bodyA].m_invMass==0?-bodyA:bodyA;\0A\09\09\09\09\09c->m_bodyBPtrAndSignBit = rigidBodies[bodyB].m_invMass==0?-bodyB:bodyB;\0A\09\09\09\09\09c->m_worldPosB[0] = contactPosB;\0A\09\09\09\09\09c->m_childIndexA = -1;\0A\09\09\09\09\09c->m_childIndexB = -1;\0A\09\09\09\09\09GET_NPOINTS(*c) = 1;\0A\09\09\09\09}//if (dstIdx < numPairs)\0A\09\09\09}//if ( len <= (radiusA+radiusB))\0A\09\09}//SHAPE_SPHERE SHAPE_SPHERE\0A\09}//if (i<numPairs)\0A}\09\09\09\09\0A__kernel void   clipHullHullConcaveConvexKernel( __global int4* concavePairsIn,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3RigidBodyData_t* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3Collidable_t* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3ConvexPolyhedronData_t* convexShapes, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* vertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* uniqueEdges,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3GpuFace_t* faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const b3GpuChildShape_t* gpuChildShapes,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* separatingNormals,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global struct b3Contact4Data* restrict globalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09counter32_t nGlobalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int contactCapacity,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numConcavePairs)\0A{\0A\09int i = get_global_id(0);\0A\09int pairIndex = i;\0A\09\0A\09float4 worldVertsB1[64];\0A\09float4 worldVertsB2[64];\0A\09int capacityWorldVerts = 64;\09\0A\09float4 localContactsOut[64];\0A\09int localContactCapacity=64;\0A\09\0A\09float minDist = -1e30f;\0A\09float maxDist = 0.02f;\0A\09if (i<numConcavePairs)\0A\09{\0A\09\09//negative value means that the pair is invalid\0A\09\09if (concavePairsIn[i].w<0)\0A\09\09\09return;\0A\09\09int bodyIndexA = concavePairsIn[i].x;\0A\09\09int bodyIndexB = concavePairsIn[i].y;\0A\09\09int f = concavePairsIn[i].z;\0A\09\09int childShapeIndexA = f;\0A\09\09\0A\09\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09\09\0A\09\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09\09\0A\09\09///////////////////////////////////////////////////////////////\0A\09\09\0A\09\0A\09\09bool overlap = false;\0A\09\09\0A\09\09b3ConvexPolyhedronData_t convexPolyhedronA;\0A\09//add 3 vertices of the triangle\0A\09\09convexPolyhedronA.m_numVertices = 3;\0A\09\09convexPolyhedronA.m_vertexOffset = 0;\0A\09\09float4\09localCenter = make_float4(0.f,0.f,0.f,0.f);\0A\09\09b3GpuFace_t face = faces[convexShapes[shapeIndexA].m_faceOffset+f];\0A\09\09\0A\09\09float4 verticesA[3];\0A\09\09for (int i=0;i<3;i++)\0A\09\09{\0A\09\09\09int index = indices[face.m_indexOffset+i];\0A\09\09\09float4 vert = vertices[convexShapes[shapeIndexA].m_vertexOffset+index];\0A\09\09\09verticesA[i] = vert;\0A\09\09\09localCenter += vert;\0A\09\09}\0A\09\09float dmin = FLT_MAX;\0A\09\09int localCC=0;\0A\09\09//a triangle has 3 unique edges\0A\09\09convexPolyhedronA.m_numUniqueEdges = 3;\0A\09\09convexPolyhedronA.m_uniqueEdgesOffset = 0;\0A\09\09float4 uniqueEdgesA[3];\0A\09\09\0A\09\09uniqueEdgesA[0] = (verticesA[1]-verticesA[0]);\0A\09\09uniqueEdgesA[1] = (verticesA[2]-verticesA[1]);\0A\09\09uniqueEdgesA[2] = (verticesA[0]-verticesA[2]);\0A\09\09convexPolyhedronA.m_faceOffset = 0;\0A                                  \0A\09\09float4 normal = make_float4(face.m_plane.x,face.m_plane.y,face.m_plane.z,0.f);\0A                             \0A\09\09b3GpuFace_t facesA[TRIANGLE_NUM_CONVEX_FACES];\0A\09\09int indicesA[3+3+2+2+2];\0A\09\09int curUsedIndices=0;\0A\09\09int fidx=0;\0A\09\09//front size of triangle\0A\09\09{\0A\09\09\09facesA[fidx].m_indexOffset=curUsedIndices;\0A\09\09\09indicesA[0] = 0;\0A\09\09\09indicesA[1] = 1;\0A\09\09\09indicesA[2] = 2;\0A\09\09\09curUsedIndices+=3;\0A\09\09\09float c = face.m_plane.w;\0A\09\09\09facesA[fidx].m_plane.x = normal.x;\0A\09\09\09facesA[fidx].m_plane.y = normal.y;\0A\09\09\09facesA[fidx].m_plane.z = normal.z;\0A\09\09\09facesA[fidx].m_plane.w = c;\0A\09\09\09facesA[fidx].m_numIndices=3;\0A\09\09}\0A\09\09fidx++;\0A\09\09//back size of triangle\0A\09\09{\0A\09\09\09facesA[fidx].m_indexOffset=curUsedIndices;\0A\09\09\09indicesA[3]=2;\0A\09\09\09indicesA[4]=1;\0A\09\09\09indicesA[5]=0;\0A\09\09\09curUsedIndices+=3;\0A\09\09\09float c = dot3F4(normal,verticesA[0]);\0A\09\09\09float c1 = -face.m_plane.w;\0A\09\09\09facesA[fidx].m_plane.x = -normal.x;\0A\09\09\09facesA[fidx].m_plane.y = -normal.y;\0A\09\09\09facesA[fidx].m_plane.z = -normal.z;\0A\09\09\09facesA[fidx].m_plane.w = c;\0A\09\09\09facesA[fidx].m_numIndices=3;\0A\09\09}\0A\09\09fidx++;\0A\09\09bool addEdgePlanes = true;\0A\09\09if (addEdgePlanes)\0A\09\09{\0A\09\09\09int numVertices=3;\0A\09\09\09int prevVertex = numVertices-1;\0A\09\09\09for (int i=0;i<numVertices;i++)\0A\09\09\09{\0A\09\09\09\09float4 v0 = verticesA[i];\0A\09\09\09\09float4 v1 = verticesA[prevVertex];\0A                                            \0A\09\09\09\09float4 edgeNormal = normalize(cross(normal,v1-v0));\0A\09\09\09\09float c = -dot3F4(edgeNormal,v0);\0A\09\09\09\09facesA[fidx].m_numIndices = 2;\0A\09\09\09\09facesA[fidx].m_indexOffset=curUsedIndices;\0A\09\09\09\09indicesA[curUsedIndices++]=i;\0A\09\09\09\09indicesA[curUsedIndices++]=prevVertex;\0A                                            \0A\09\09\09\09facesA[fidx].m_plane.x = edgeNormal.x;\0A\09\09\09\09facesA[fidx].m_plane.y = edgeNormal.y;\0A\09\09\09\09facesA[fidx].m_plane.z = edgeNormal.z;\0A\09\09\09\09facesA[fidx].m_plane.w = c;\0A\09\09\09\09fidx++;\0A\09\09\09\09prevVertex = i;\0A\09\09\09}\0A\09\09}\0A\09\09convexPolyhedronA.m_numFaces = TRIANGLE_NUM_CONVEX_FACES;\0A\09\09convexPolyhedronA.m_localCenter = localCenter*(1.f/3.f);\0A\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09posA.w = 0.f;\0A\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09posB.w = 0.f;\0A\09\09float4 ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09float4 ornB =rigidBodies[bodyIndexB].m_quat;\0A\09\09float4 sepAxis = separatingNormals[i];\0A\09\09\0A\09\09int shapeTypeB = collidables[collidableIndexB].m_shapeType;\0A\09\09int childShapeIndexB =-1;\0A\09\09if (shapeTypeB==SHAPE_COMPOUND_OF_CONVEX_HULLS)\0A\09\09{\0A\09\09\09///////////////////\0A\09\09\09///compound shape support\0A\09\09\09\0A\09\09\09childShapeIndexB = concavePairsIn[pairIndex].w;\0A\09\09\09int childColIndexB = gpuChildShapes[childShapeIndexB].m_shapeIndex;\0A\09\09\09shapeIndexB = collidables[childColIndexB].m_shapeIndex;\0A\09\09\09float4 childPosB = gpuChildShapes[childShapeIndexB].m_childPosition;\0A\09\09\09float4 childOrnB = gpuChildShapes[childShapeIndexB].m_childOrientation;\0A\09\09\09float4 newPosB = transform(&childPosB,&posB,&ornB);\0A\09\09\09float4 newOrnB = qtMul(ornB,childOrnB);\0A\09\09\09posB = newPosB;\0A\09\09\09ornB = newOrnB;\0A\09\09\09\0A\09\09}\0A\09\09\0A\09\09////////////////////////////////////////\0A\09\09\0A\09\09\0A\09\09\0A\09\09int numLocalContactsOut = clipHullAgainstHullLocalA(sepAxis,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09&convexPolyhedronA, &convexShapes[shapeIndexB],\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09posA,ornA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09  posB,ornB,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09  worldVertsB1,worldVertsB2,capacityWorldVerts,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09minDist, maxDist,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09&verticesA,&facesA,&indicesA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09vertices,faces,indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09localContactsOut,localContactCapacity);\0A\09\09\09\09\09\09\09\09\09\09\09\09\0A\09\09if (numLocalContactsOut>0)\0A\09\09{\0A\09\09\09float4 normal = -separatingNormals[i];\0A\09\09\09int nPoints = numLocalContactsOut;\0A\09\09\09float4* pointsIn = localContactsOut;\0A\09\09\09int contactIdx[4];// = {-1,-1,-1,-1};\0A\09\09\09contactIdx[0] = -1;\0A\09\09\09contactIdx[1] = -1;\0A\09\09\09contactIdx[2] = -1;\0A\09\09\09contactIdx[3] = -1;\0A\09\0A\09\09\09int nReducedContacts = extractManifoldSequential(pointsIn, nPoints, normal, contactIdx);\0A\09\0A\09\09\09int dstIdx;\0A\09\09\09AppendInc( nGlobalContactsOut, dstIdx );\0A\09\09\09if (dstIdx<contactCapacity)\0A\09\09\09{\0A\09\09\09\09__global struct b3Contact4Data* c = globalContactsOut+ dstIdx;\0A\09\09\09\09c->m_worldNormalOnB = -normal;\0A\09\09\09\09c->m_restituitionCoeffCmp = (0.f*0xffff);c->m_frictionCoeffCmp = (0.7f*0xffff);\0A\09\09\09\09c->m_batchIdx = pairIndex;\0A\09\09\09\09int bodyA = concavePairsIn[pairIndex].x;\0A\09\09\09\09int bodyB = concavePairsIn[pairIndex].y;\0A\09\09\09\09c->m_bodyAPtrAndSignBit = rigidBodies[bodyA].m_invMass==0?-bodyA:bodyA;\0A\09\09\09\09c->m_bodyBPtrAndSignBit = rigidBodies[bodyB].m_invMass==0?-bodyB:bodyB;\0A\09\09\09\09c->m_childIndexA = childShapeIndexA;\0A\09\09\09\09c->m_childIndexB = childShapeIndexB;\0A\09\09\09\09for (int i=0;i<nReducedContacts;i++)\0A\09\09\09\09{\0A\09\09\09\09\09c->m_worldPosB[i] = pointsIn[contactIdx[i]];\0A\09\09\09\09}\0A\09\09\09\09GET_NPOINTS(*c) = nReducedContacts;\0A\09\09\09}\0A\09\09\09\09\0A\09\09}//\09\09if (numContactsOut>0)\0A\09}//\09if (i<numPairs)\0A}\0Aint\09findClippingFaces(const float4 separatingNormal,\0A                      __global const b3ConvexPolyhedronData_t* hullA, __global const b3ConvexPolyhedronData_t* hullB,\0A                      const float4 posA, const Quaternion ornA,const float4 posB, const Quaternion ornB,\0A                       __global float4* worldVertsA1,\0A                      __global float4* worldNormalsA1,\0A                      __global float4* worldVertsB1,\0A                      int capacityWorldVerts,\0A                      const float minDist, float maxDist,\0A                      __global const float4* vertices,\0A                      __global const b3GpuFace_t* faces,\0A                      __global const int* indices,\0A                      __global int4* clippingFaces, int pairIndex)\0A{\0A\09int numContactsOut = 0;\0A\09int numWorldVertsB1= 0;\0A    \0A    \0A\09int closestFaceB=-1;\0A\09float dmax = -FLT_MAX;\0A    \0A\09{\0A\09\09for(int face=0;face<hullB->m_numFaces;face++)\0A\09\09{\0A\09\09\09const float4 Normal = make_float4(faces[hullB->m_faceOffset+face].m_plane.x,\0A                                              faces[hullB->m_faceOffset+face].m_plane.y, faces[hullB->m_faceOffset+face].m_plane.z,0.f);\0A\09\09\09const float4 WorldNormal = qtRotate(ornB, Normal);\0A\09\09\09float d = dot3F4(WorldNormal,separatingNormal);\0A\09\09\09if (d > dmax)\0A\09\09\09{\0A\09\09\09\09dmax = d;\0A\09\09\09\09closestFaceB = face;\0A\09\09\09}\0A\09\09}\0A\09}\0A    \0A\09{\0A\09\09const b3GpuFace_t polyB = faces[hullB->m_faceOffset+closestFaceB];\0A\09\09const int numVertices = polyB.m_numIndices;\0A\09\09for(int e0=0;e0<numVertices;e0++)\0A\09\09{\0A\09\09\09const float4 b = vertices[hullB->m_vertexOffset+indices[polyB.m_indexOffset+e0]];\0A\09\09\09worldVertsB1[pairIndex*capacityWorldVerts+numWorldVertsB1++] = transform(&b,&posB,&ornB);\0A\09\09}\0A\09}\0A    \0A    int closestFaceA=-1;\0A\09{\0A\09\09float dmin = FLT_MAX;\0A\09\09for(int face=0;face<hullA->m_numFaces;face++)\0A\09\09{\0A\09\09\09const float4 Normal = make_float4(\0A                                              faces[hullA->m_faceOffset+face].m_plane.x,\0A                                              faces[hullA->m_faceOffset+face].m_plane.y,\0A                                              faces[hullA->m_faceOffset+face].m_plane.z,\0A                                              0.f);\0A\09\09\09const float4 faceANormalWS = qtRotate(ornA,Normal);\0A            \0A\09\09\09float d = dot3F4(faceANormalWS,separatingNormal);\0A\09\09\09if (d < dmin)\0A\09\09\09{\0A\09\09\09\09dmin = d;\0A\09\09\09\09closestFaceA = face;\0A                worldNormalsA1[pairIndex] = faceANormalWS;\0A\09\09\09}\0A\09\09}\0A\09}\0A    \0A    int numVerticesA = faces[hullA->m_faceOffset+closestFaceA].m_numIndices;\0A\09for(int e0=0;e0<numVerticesA;e0++)\0A\09{\0A        const float4 a = vertices[hullA->m_vertexOffset+indices[faces[hullA->m_faceOffset+closestFaceA].m_indexOffset+e0]];\0A        worldVertsA1[pairIndex*capacityWorldVerts+e0] = transform(&a, &posA,&ornA);\0A    }\0A    \0A    clippingFaces[pairIndex].x = closestFaceA;\0A    clippingFaces[pairIndex].y = closestFaceB;\0A    clippingFaces[pairIndex].z = numVerticesA;\0A    clippingFaces[pairIndex].w = numWorldVertsB1;\0A    \0A    \0A\09return numContactsOut;\0A}\0Aint clipFaces(__global float4* worldVertsA1,\0A              __global float4* worldNormalsA1,\0A              __global float4* worldVertsB1,\0A              __global float4* worldVertsB2, \0A              int capacityWorldVertsB2,\0A              const float minDist, float maxDist,\0A              __global int4* clippingFaces,\0A              int pairIndex)\0A{\0A\09int numContactsOut = 0;\0A    \0A    int closestFaceA = clippingFaces[pairIndex].x;\0A    int closestFaceB = clippingFaces[pairIndex].y;\0A\09int numVertsInA = clippingFaces[pairIndex].z;\0A\09int numVertsInB = clippingFaces[pairIndex].w;\0A    \0A\09int numVertsOut = 0;\0A    \0A\09if (closestFaceA<0)\0A\09\09return numContactsOut;\0A    \0A    __global float4* pVtxIn = &worldVertsB1[pairIndex*capacityWorldVertsB2];\0A    __global float4* pVtxOut = &worldVertsB2[pairIndex*capacityWorldVertsB2];\0A    \0A    \0A\09\0A\09// clip polygon to back of planes of all faces of hull A that are adjacent to witness face\0A    \0A\09for(int e0=0;e0<numVertsInA;e0++)\0A\09{\0A\09\09const float4 aw = worldVertsA1[pairIndex*capacityWorldVertsB2+e0];\0A\09\09const float4 bw = worldVertsA1[pairIndex*capacityWorldVertsB2+((e0+1)%numVertsInA)];\0A\09\09const float4 WorldEdge0 = aw - bw;\0A\09\09float4 worldPlaneAnormal1 = worldNormalsA1[pairIndex];\0A\09\09float4 planeNormalWS1 = -cross3(WorldEdge0,worldPlaneAnormal1);\0A\09\09float4 worldA1 = aw;\0A\09\09float planeEqWS1 = -dot3F4(worldA1,planeNormalWS1);\0A\09\09float4 planeNormalWS = planeNormalWS1;\0A\09\09float planeEqWS=planeEqWS1;\0A\09\09numVertsOut = clipFaceGlobal(pVtxIn, numVertsInB, planeNormalWS,planeEqWS, pVtxOut);\0A\09\09__global float4* tmp = pVtxOut;\0A\09\09pVtxOut = pVtxIn;\0A\09\09pVtxIn = tmp;\0A\09\09numVertsInB = numVertsOut;\0A\09\09numVertsOut = 0;\0A\09}\0A    \0A    //float4 planeNormalWS = worldNormalsA1[pairIndex];\0A    //float planeEqWS=-dot3F4(planeNormalWS,worldVertsA1[pairIndex*capacityWorldVertsB2]);\0A    \0A    /*for (int i=0;i<numVertsInB;i++)\0A    {\0A        pVtxOut[i] = pVtxIn[i];\0A    }*/\0A    \0A    \0A    \0A    \0A    //numVertsInB=0;\0A\09\0A    float4 planeNormalWS = worldNormalsA1[pairIndex];\0A    float planeEqWS=-dot3F4(planeNormalWS,worldVertsA1[pairIndex*capacityWorldVertsB2]);\0A    for (int i=0;i<numVertsInB;i++)\0A    {\0A        float depth = dot3F4(planeNormalWS,pVtxIn[i])+planeEqWS;\0A        if (depth <=minDist)\0A        {\0A            depth = minDist;\0A        }\0A        \0A        if (depth <=maxDist)\0A        {\0A            float4 pointInWorld = pVtxIn[i];\0A            pVtxOut[numContactsOut++] = make_float4(pointInWorld.x,pointInWorld.y,pointInWorld.z,depth);\0A        }\0A    }\0A   \0A    clippingFaces[pairIndex].w =numContactsOut;\0A   \0A    \0A\09return numContactsOut;\0A}\0A__kernel void   findClippingFacesKernel(  __global const int4* pairs,\0A                                        __global const b3RigidBodyData_t* rigidBodies,\0A                                        __global const b3Collidable_t* collidables,\0A                                        __global const b3ConvexPolyhedronData_t* convexShapes,\0A                                        __global const float4* vertices,\0A                                        __global const float4* uniqueEdges,\0A                                        __global const b3GpuFace_t* faces,\0A                                        __global const int* indices,\0A                                        __global const float4* separatingNormals,\0A                                        __global const int* hasSeparatingAxis,\0A                                        __global int4* clippingFacesOut,\0A                                        __global float4* worldVertsA1,\0A                                        __global float4* worldNormalsA1,\0A                                        __global float4* worldVertsB1,\0A                                        int capacityWorldVerts,\0A                                        int numPairs\0A                                        )\0A{\0A    \0A\09int i = get_global_id(0);\0A\09int pairIndex = i;\0A    \0A\09\0A\09float minDist = -1e30f;\0A\09float maxDist = 0.02f;\0A    \0A\09if (i<numPairs)\0A\09{\0A        \0A\09\09if (hasSeparatingAxis[i])\0A\09\09{\0A            \0A\09\09\09int bodyIndexA = pairs[i].x;\0A\09\09\09int bodyIndexB = pairs[i].y;\0A\09\09\09\0A\09\09\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09\09\09\0A\09\09\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09\09\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09\09\09\0A            \0A            \0A\09\09\09int numLocalContactsOut = findClippingFaces(separatingNormals[i],\0A                                                        &convexShapes[shapeIndexA], &convexShapes[shapeIndexB],\0A                                                        rigidBodies[bodyIndexA].m_pos,rigidBodies[bodyIndexA].m_quat,\0A                                                        rigidBodies[bodyIndexB].m_pos,rigidBodies[bodyIndexB].m_quat,\0A                                                        worldVertsA1,\0A                                                        worldNormalsA1,\0A                                                        worldVertsB1,capacityWorldVerts,\0A                                                        minDist, maxDist,\0A                                                        vertices,faces,indices,\0A                                                        clippingFacesOut,i);\0A            \0A            \0A\09\09}//\09\09if (hasSeparatingAxis[i])\0A\09}//\09if (i<numPairs)\0A    \0A}\0A__kernel void   clipFacesAndFindContactsKernel(    __global const float4* separatingNormals,\0A                                                   __global const int* hasSeparatingAxis,\0A                                                   __global int4* clippingFacesOut,\0A                                                   __global float4* worldVertsA1,\0A                                                   __global float4* worldNormalsA1,\0A                                                   __global float4* worldVertsB1,\0A                                                   __global float4* worldVertsB2,\0A                                                    int vertexFaceCapacity,\0A                                                   int numPairs,\0A\09\09\09\09\09                                        int debugMode\0A                                                   )\0A{\0A    int i = get_global_id(0);\0A\09int pairIndex = i;\0A\09\0A    \0A\09float minDist = -1e30f;\0A\09float maxDist = 0.02f;\0A    \0A\09if (i<numPairs)\0A\09{\0A        \0A\09\09if (hasSeparatingAxis[i])\0A\09\09{\0A            \0A//\09\09\09int bodyIndexA = pairs[i].x;\0A\09//\09\09int bodyIndexB = pairs[i].y;\0A\09\09    \0A            int numLocalContactsOut = 0;\0A            int capacityWorldVertsB2 = vertexFaceCapacity;\0A            \0A            __global float4* pVtxIn = &worldVertsB1[pairIndex*capacityWorldVertsB2];\0A            __global float4* pVtxOut = &worldVertsB2[pairIndex*capacityWorldVertsB2];\0A            \0A            {\0A                __global int4* clippingFaces = clippingFacesOut;\0A            \0A                \0A                int closestFaceA = clippingFaces[pairIndex].x;\0A                int closestFaceB = clippingFaces[pairIndex].y;\0A                int numVertsInA = clippingFaces[pairIndex].z;\0A                int numVertsInB = clippingFaces[pairIndex].w;\0A                \0A                int numVertsOut = 0;\0A                \0A                if (closestFaceA>=0)\0A                {\0A                    \0A                    \0A                    \0A                    // clip polygon to back of planes of all faces of hull A that are adjacent to witness face\0A                    \0A                    for(int e0=0;e0<numVertsInA;e0++)\0A                    {\0A                        const float4 aw = worldVertsA1[pairIndex*capacityWorldVertsB2+e0];\0A                        const float4 bw = worldVertsA1[pairIndex*capacityWorldVertsB2+((e0+1)%numVertsInA)];\0A                        const float4 WorldEdge0 = aw - bw;\0A                        float4 worldPlaneAnormal1 = worldNormalsA1[pairIndex];\0A                        float4 planeNormalWS1 = -cross3(WorldEdge0,worldPlaneAnormal1);\0A                        float4 worldA1 = aw;\0A                        float planeEqWS1 = -dot3F4(worldA1,planeNormalWS1);\0A                        float4 planeNormalWS = planeNormalWS1;\0A                        float planeEqWS=planeEqWS1;\0A                        numVertsOut = clipFaceGlobal(pVtxIn, numVertsInB, planeNormalWS,planeEqWS, pVtxOut);\0A                        __global float4* tmp = pVtxOut;\0A                        pVtxOut = pVtxIn;\0A                        pVtxIn = tmp;\0A                        numVertsInB = numVertsOut;\0A                        numVertsOut = 0;\0A                    }\0A                    \0A                    float4 planeNormalWS = worldNormalsA1[pairIndex];\0A                    float planeEqWS=-dot3F4(planeNormalWS,worldVertsA1[pairIndex*capacityWorldVertsB2]);\0A                    \0A                    for (int i=0;i<numVertsInB;i++)\0A                    {\0A                        float depth = dot3F4(planeNormalWS,pVtxIn[i])+planeEqWS;\0A                        if (depth <=minDist)\0A                        {\0A                            depth = minDist;\0A                        }\0A                        \0A                        if (depth <=maxDist)\0A                        {\0A                            float4 pointInWorld = pVtxIn[i];\0A                            pVtxOut[numLocalContactsOut++] = make_float4(pointInWorld.x,pointInWorld.y,pointInWorld.z,depth);\0A                        }\0A                    }\0A                    \0A                }\0A                clippingFaces[pairIndex].w =numLocalContactsOut;\0A                \0A            }\0A            \0A            for (int i=0;i<numLocalContactsOut;i++)\0A                pVtxIn[i] = pVtxOut[i];\0A                \0A\09\09}//\09\09if (hasSeparatingAxis[i])\0A\09}//\09if (i<numPairs)\0A    \0A}\0A__kernel void   newContactReductionKernel( __global int4* pairs,\0A                                                   __global const b3RigidBodyData_t* rigidBodies,\0A                                                   __global const float4* separatingNormals,\0A                                                   __global const int* hasSeparatingAxis,\0A                                                   __global struct b3Contact4Data* globalContactsOut,\0A                                                   __global int4* clippingFaces,\0A                                                   __global float4* worldVertsB2,\0A                                                   volatile __global int* nGlobalContactsOut,\0A                                                   int vertexFaceCapacity,\0A\09\09\09\09\09\09\09\09\09\09\09\09   int contactCapacity,\0A                                                   int numPairs\0A                                                   )\0A{\0A    int i = get_global_id(0);\0A\09int pairIndex = i;\0A\09\0A    int4 contactIdx;\0A    contactIdx=make_int4(0,1,2,3);\0A    \0A\09if (i<numPairs)\0A\09{\0A        \0A\09\09if (hasSeparatingAxis[i])\0A\09\09{\0A            \0A\09\09\09\0A            \0A            \0A\09\09\09int nPoints = clippingFaces[pairIndex].w;\0A           \0A            if (nPoints>0)\0A            {\0A                 __global float4* pointsIn = &worldVertsB2[pairIndex*vertexFaceCapacity];\0A                float4 normal = -separatingNormals[i];\0A                \0A                int nReducedContacts = extractManifoldSequentialGlobal(pointsIn, nPoints, normal, &contactIdx);\0A            \0A\09\09\09\09int mprContactIndex = pairs[pairIndex].z;\0A                int dstIdx = mprContactIndex;\0A\09\09\09\09if (dstIdx<0)\0A\09\09\09\09{\0A\09                AppendInc( nGlobalContactsOut, dstIdx );\0A\09\09\09\09}\0A//#if 0\0A                \0A\09\09\09\09if (dstIdx < contactCapacity)\0A\09\09\09\09{\0A\09\09\09\09\09__global struct b3Contact4Data* c = &globalContactsOut[dstIdx];\0A\09\09\09\09\09c->m_worldNormalOnB = -normal;\0A\09\09\09\09\09c->m_restituitionCoeffCmp = (0.f*0xffff);c->m_frictionCoeffCmp = (0.7f*0xffff);\0A\09\09\09\09\09c->m_batchIdx = pairIndex;\0A\09\09\09\09\09int bodyA = pairs[pairIndex].x;\0A\09\09\09\09\09int bodyB = pairs[pairIndex].y;\0A\09\09\09\09\09pairs[pairIndex].w = dstIdx;\0A\09\09\09\09\09c->m_bodyAPtrAndSignBit = rigidBodies[bodyA].m_invMass==0?-bodyA:bodyA;\0A\09\09\09\09\09c->m_bodyBPtrAndSignBit = rigidBodies[bodyB].m_invMass==0?-bodyB:bodyB;\0A                    c->m_childIndexA =-1;\0A\09\09\09\09\09c->m_childIndexB =-1;\0A                    switch (nReducedContacts)\0A                    {\0A                        case 4:\0A                            c->m_worldPosB[3] = pointsIn[contactIdx.w];\0A                        case 3:\0A                            c->m_worldPosB[2] = pointsIn[contactIdx.z];\0A                        case 2:\0A                            c->m_worldPosB[1] = pointsIn[contactIdx.y];\0A                        case 1:\0A\09\09\09\09\09\09\09if (mprContactIndex<0)//test\0A\09                            c->m_worldPosB[0] = pointsIn[contactIdx.x];\0A                        default:\0A                        {\0A                        }\0A                    };\0A                    \0A\09\09\09\09\09GET_NPOINTS(*c) = nReducedContacts;\0A                    \0A                 }\0A                 \0A                \0A//#endif\0A\09\09\09\09\0A\09\09\09}//\09\09if (numContactsOut>0)\0A\09\09}//\09\09if (hasSeparatingAxis[i])\0A\09}//\09if (i<numPairs)\0A    \0A    \0A}\0A\00", align 1
@.str.70 = private unnamed_addr constant [7792 x i8] c"//keep this enum in sync with the CPU version (in btCollidable.h)\0A//written by Erwin Coumans\0A#define SHAPE_CONVEX_HULL 3\0A#define SHAPE_CONCAVE_TRIMESH 5\0A#define TRIANGLE_NUM_CONVEX_FACES 5\0A#define SHAPE_COMPOUND_OF_CONVEX_HULLS 6\0A#define SHAPE_SPHERE 7\0Atypedef unsigned int u32;\0A#define MAX_NUM_PARTS_IN_BITS 10\0A///btQuantizedBvhNode is a compressed aabb node, 16 bytes.\0A///Node can be used for leafnode or internal node. Leafnodes can point to 32-bit triangle index (non-negative range).\0Atypedef struct\0A{\0A\09//12 bytes\0A\09unsigned short int\09m_quantizedAabbMin[3];\0A\09unsigned short int\09m_quantizedAabbMax[3];\0A\09//4 bytes\0A\09int\09m_escapeIndexOrTriangleIndex;\0A} btQuantizedBvhNode;\0Atypedef struct\0A{\0A\09float4\09\09m_aabbMin;\0A\09float4\09\09m_aabbMax;\0A\09float4\09\09m_quantization;\0A\09int\09\09\09m_numNodes;\0A\09int\09\09\09m_numSubTrees;\0A\09int\09\09\09m_nodeOffset;\0A\09int\09\09\09m_subTreeOffset;\0A} b3BvhInfo;\0Aint\09getTriangleIndex(const btQuantizedBvhNode* rootNode)\0A{\0A\09unsigned int x=0;\0A\09unsigned int y = (~(x&0))<<(31-MAX_NUM_PARTS_IN_BITS);\0A\09// Get only the lower bits where the triangle index is stored\0A\09return (rootNode->m_escapeIndexOrTriangleIndex&~(y));\0A}\0Aint isLeaf(const btQuantizedBvhNode* rootNode)\0A{\0A\09//skipindex is negative (internal node), triangleindex >=0 (leafnode)\0A\09return (rootNode->m_escapeIndexOrTriangleIndex >= 0)? 1 : 0;\0A}\0A\09\0Aint getEscapeIndex(const btQuantizedBvhNode* rootNode)\0A{\0A\09return -rootNode->m_escapeIndexOrTriangleIndex;\0A}\0Atypedef struct\0A{\0A\09//12 bytes\0A\09unsigned short int\09m_quantizedAabbMin[3];\0A\09unsigned short int\09m_quantizedAabbMax[3];\0A\09//4 bytes, points to the root of the subtree\0A\09int\09\09\09m_rootNodeIndex;\0A\09//4 bytes\0A\09int\09\09\09m_subtreeSize;\0A\09int\09\09\09m_padding[3];\0A} btBvhSubtreeInfo;\0A///keep this in sync with btCollidable.h\0Atypedef struct\0A{\0A\09int m_numChildShapes;\0A\09int blaat2;\0A\09int m_shapeType;\0A\09int m_shapeIndex;\0A\09\0A} btCollidableGpu;\0Atypedef struct\0A{\0A\09float4\09m_childPosition;\0A\09float4\09m_childOrientation;\0A\09int m_shapeIndex;\0A\09int m_unused0;\0A\09int m_unused1;\0A\09int m_unused2;\0A} btGpuChildShape;\0Atypedef struct\0A{\0A\09float4 m_pos;\0A\09float4 m_quat;\0A\09float4 m_linVel;\0A\09float4 m_angVel;\0A\09u32 m_collidableIdx;\0A\09float m_invMass;\0A\09float m_restituitionCoeff;\0A\09float m_frictionCoeff;\0A} BodyData;\0Atypedef struct \0A{\0A\09union\0A\09{\0A\09\09float4\09m_min;\0A\09\09float   m_minElems[4];\0A\09\09int\09\09\09m_minIndices[4];\0A\09};\0A\09union\0A\09{\0A\09\09float4\09m_max;\0A\09\09float   m_maxElems[4];\0A\09\09int\09\09\09m_maxIndices[4];\0A\09};\0A} btAabbCL;\0Aint testQuantizedAabbAgainstQuantizedAabb(\0A\09\09\09\09\09\09\09\09const unsigned short int* aabbMin1,\0A\09\09\09\09\09\09\09\09const unsigned short int* aabbMax1,\0A\09\09\09\09\09\09\09\09const unsigned short int* aabbMin2,\0A\09\09\09\09\09\09\09\09const unsigned short int* aabbMax2)\0A{\0A\09//int overlap = 1;\0A\09if (aabbMin1[0] > aabbMax2[0])\0A\09\09return 0;\0A\09if (aabbMax1[0] < aabbMin2[0])\0A\09\09return 0;\0A\09if (aabbMin1[1] > aabbMax2[1])\0A\09\09return 0;\0A\09if (aabbMax1[1] < aabbMin2[1])\0A\09\09return 0;\0A\09if (aabbMin1[2] > aabbMax2[2])\0A\09\09return 0;\0A\09if (aabbMax1[2] < aabbMin2[2])\0A\09\09return 0;\0A\09return 1;\0A\09//overlap = ((aabbMin1[0] > aabbMax2[0]) || (aabbMax1[0] < aabbMin2[0])) ? 0 : overlap;\0A\09//overlap = ((aabbMin1[2] > aabbMax2[2]) || (aabbMax1[2] < aabbMin2[2])) ? 0 : overlap;\0A\09//overlap = ((aabbMin1[1] > aabbMax2[1]) || (aabbMax1[1] < aabbMin2[1])) ? 0 : overlap;\0A\09//return overlap;\0A}\0Avoid quantizeWithClamp(unsigned short* out, float4 point2,int isMax, float4 bvhAabbMin, float4 bvhAabbMax, float4 bvhQuantization)\0A{\0A\09float4 clampedPoint = max(point2,bvhAabbMin);\0A\09clampedPoint = min (clampedPoint, bvhAabbMax);\0A\09float4 v = (clampedPoint - bvhAabbMin) * bvhQuantization;\0A\09if (isMax)\0A\09{\0A\09\09out[0] = (unsigned short) (((unsigned short)(v.x+1.f) | 1));\0A\09\09out[1] = (unsigned short) (((unsigned short)(v.y+1.f) | 1));\0A\09\09out[2] = (unsigned short) (((unsigned short)(v.z+1.f) | 1));\0A\09} else\0A\09{\0A\09\09out[0] = (unsigned short) (((unsigned short)(v.x) & 0xfffe));\0A\09\09out[1] = (unsigned short) (((unsigned short)(v.y) & 0xfffe));\0A\09\09out[2] = (unsigned short) (((unsigned short)(v.z) & 0xfffe));\0A\09}\0A}\0A// work-in-progress\0A__kernel void   bvhTraversalKernel( __global const int4* pairs, \0A\09\09\09\09\09\09\09\09\09__global const BodyData* rigidBodies, \0A\09\09\09\09\09\09\09\09\09__global const btCollidableGpu* collidables,\0A\09\09\09\09\09\09\09\09\09__global btAabbCL* aabbs,\0A\09\09\09\09\09\09\09\09\09__global int4* concavePairsOut,\0A\09\09\09\09\09\09\09\09\09__global volatile int* numConcavePairsOut,\0A\09\09\09\09\09\09\09\09\09__global const btBvhSubtreeInfo* subtreeHeadersRoot,\0A\09\09\09\09\09\09\09\09\09__global const btQuantizedBvhNode* quantizedNodesRoot,\0A\09\09\09\09\09\09\09\09\09__global const b3BvhInfo* bvhInfos,\0A\09\09\09\09\09\09\09\09\09int numPairs,\0A\09\09\09\09\09\09\09\09\09int maxNumConcavePairsCapacity)\0A{\0A\09int id = get_global_id(0);\0A\09if (id>=numPairs)\0A\09\09return;\0A\09\0A\09int bodyIndexA = pairs[id].x;\0A\09int bodyIndexB = pairs[id].y;\0A\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09\0A\09//once the broadphase avoids static-static pairs, we can remove this test\0A\09if ((rigidBodies[bodyIndexA].m_invMass==0) &&(rigidBodies[bodyIndexB].m_invMass==0))\0A\09{\0A\09\09return;\0A\09}\0A\09\09\0A\09if (collidables[collidableIndexA].m_shapeType!=SHAPE_CONCAVE_TRIMESH)\0A\09\09return;\0A\09int shapeTypeB = collidables[collidableIndexB].m_shapeType;\0A\09\09\0A\09if (shapeTypeB!=SHAPE_CONVEX_HULL &&\0A\09\09shapeTypeB!=SHAPE_SPHERE\09&&\0A\09\09shapeTypeB!=SHAPE_COMPOUND_OF_CONVEX_HULLS\0A\09\09)\0A\09\09return;\0A\09b3BvhInfo bvhInfo = bvhInfos[collidables[collidableIndexA].m_numChildShapes];\0A\09float4 bvhAabbMin = bvhInfo.m_aabbMin;\0A\09float4 bvhAabbMax = bvhInfo.m_aabbMax;\0A\09float4 bvhQuantization = bvhInfo.m_quantization;\0A\09int numSubtreeHeaders = bvhInfo.m_numSubTrees;\0A\09__global const btBvhSubtreeInfo* subtreeHeaders = &subtreeHeadersRoot[bvhInfo.m_subTreeOffset];\0A\09__global const btQuantizedBvhNode* quantizedNodes = &quantizedNodesRoot[bvhInfo.m_nodeOffset];\0A\09\0A\09unsigned short int quantizedQueryAabbMin[3];\0A\09unsigned short int quantizedQueryAabbMax[3];\0A\09quantizeWithClamp(quantizedQueryAabbMin,aabbs[bodyIndexB].m_min,false,bvhAabbMin, bvhAabbMax,bvhQuantization);\0A\09quantizeWithClamp(quantizedQueryAabbMax,aabbs[bodyIndexB].m_max,true ,bvhAabbMin, bvhAabbMax,bvhQuantization);\0A\09\0A\09for (int i=0;i<numSubtreeHeaders;i++)\0A\09{\0A\09\09btBvhSubtreeInfo subtree = subtreeHeaders[i];\0A\09\09\09\09\0A\09\09int overlap = testQuantizedAabbAgainstQuantizedAabb(quantizedQueryAabbMin,quantizedQueryAabbMax,subtree.m_quantizedAabbMin,subtree.m_quantizedAabbMax);\0A\09\09if (overlap != 0)\0A\09\09{\0A\09\09\09int startNodeIndex = subtree.m_rootNodeIndex;\0A\09\09\09int endNodeIndex = subtree.m_rootNodeIndex+subtree.m_subtreeSize;\0A\09\09\09int curIndex = startNodeIndex;\0A\09\09\09int escapeIndex;\0A\09\09\09int isLeafNode;\0A\09\09\09int aabbOverlap;\0A\09\09\09while (curIndex < endNodeIndex)\0A\09\09\09{\0A\09\09\09\09btQuantizedBvhNode rootNode = quantizedNodes[curIndex];\0A\09\09\09\09aabbOverlap = testQuantizedAabbAgainstQuantizedAabb(quantizedQueryAabbMin,quantizedQueryAabbMax,rootNode.m_quantizedAabbMin,rootNode.m_quantizedAabbMax);\0A\09\09\09\09isLeafNode = isLeaf(&rootNode);\0A\09\09\09\09if (aabbOverlap)\0A\09\09\09\09{\0A\09\09\09\09\09if (isLeafNode)\0A\09\09\09\09\09{\0A\09\09\09\09\09\09int triangleIndex = getTriangleIndex(&rootNode);\0A\09\09\09\09\09\09if (shapeTypeB==SHAPE_COMPOUND_OF_CONVEX_HULLS)\0A\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09int numChildrenB = collidables[collidableIndexB].m_numChildShapes;\0A\09\09\09\09\09\09\09\09int pairIdx = atomic_add(numConcavePairsOut,numChildrenB);\0A\09\09\09\09\09\09\09\09for (int b=0;b<numChildrenB;b++)\0A\09\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09\09if ((pairIdx+b)<maxNumConcavePairsCapacity)\0A\09\09\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09\09\09int childShapeIndexB = collidables[collidableIndexB].m_shapeIndex+b;\0A\09\09\09\09\09\09\09\09\09\09int4 newPair = (int4)(bodyIndexA,bodyIndexB,triangleIndex,childShapeIndexB);\0A\09\09\09\09\09\09\09\09\09\09concavePairsOut[pairIdx+b] = newPair;\0A\09\09\09\09\09\09\09\09\09}\0A\09\09\09\09\09\09\09\09}\0A\09\09\09\09\09\09} else\0A\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09int pairIdx = atomic_inc(numConcavePairsOut);\0A\09\09\09\09\09\09\09if (pairIdx<maxNumConcavePairsCapacity)\0A\09\09\09\09\09\09\09{\0A\09\09\09\09\09\09\09\09int4 newPair = (int4)(bodyIndexA,bodyIndexB,triangleIndex,0);\0A\09\09\09\09\09\09\09\09concavePairsOut[pairIdx] = newPair;\0A\09\09\09\09\09\09\09}\0A\09\09\09\09\09\09}\0A\09\09\09\09\09} \0A\09\09\09\09\09curIndex++;\0A\09\09\09\09} else\0A\09\09\09\09{\0A\09\09\09\09\09if (isLeafNode)\0A\09\09\09\09\09{\0A\09\09\09\09\09\09curIndex++;\0A\09\09\09\09\09} else\0A\09\09\09\09\09{\0A\09\09\09\09\09\09escapeIndex = getEscapeIndex(&rootNode);\0A\09\09\09\09\09\09curIndex += escapeIndex;\0A\09\09\09\09\09}\0A\09\09\09\09}\0A\09\09\09}\0A\09\09}\0A\09}\0A}\0A\00", align 1
@.str.71 = private unnamed_addr constant [38981 x i8] c"#ifndef B3_CONTACT4DATA_H\0A#define B3_CONTACT4DATA_H\0A#ifndef B3_FLOAT4_H\0A#define B3_FLOAT4_H\0A#ifndef B3_PLATFORM_DEFINITIONS_H\0A#define B3_PLATFORM_DEFINITIONS_H\0Astruct MyTest\0A{\0A\09int bla;\0A};\0A#ifdef __cplusplus\0A#else\0A//keep B3_LARGE_FLOAT*B3_LARGE_FLOAT < FLT_MAX\0A#define B3_LARGE_FLOAT 1e18f\0A#define B3_INFINITY 1e18f\0A#define b3Assert(a)\0A#define b3ConstArray(a) __global const a*\0A#define b3AtomicInc atomic_inc\0A#define b3AtomicAdd atomic_add\0A#define b3Fabs fabs\0A#define b3Sqrt native_sqrt\0A#define b3Sin native_sin\0A#define b3Cos native_cos\0A#define B3_STATIC\0A#endif\0A#endif\0A#ifdef __cplusplus\0A#else\0A\09typedef float4\09b3Float4;\0A\09#define b3Float4ConstArg const b3Float4\0A\09#define b3MakeFloat4 (float4)\0A\09float b3Dot3F4(b3Float4ConstArg v0,b3Float4ConstArg v1)\0A\09{\0A\09\09float4 a1 = b3MakeFloat4(v0.xyz,0.f);\0A\09\09float4 b1 = b3MakeFloat4(v1.xyz,0.f);\0A\09\09return dot(a1, b1);\0A\09}\0A\09b3Float4 b3Cross3(b3Float4ConstArg v0,b3Float4ConstArg v1)\0A\09{\0A\09\09float4 a1 = b3MakeFloat4(v0.xyz,0.f);\0A\09\09float4 b1 = b3MakeFloat4(v1.xyz,0.f);\0A\09\09return cross(a1, b1);\0A\09}\0A\09#define b3MinFloat4 min\0A\09#define b3MaxFloat4 max\0A\09#define b3Normalized(a) normalize(a)\0A#endif \0A\09\09\0Ainline bool b3IsAlmostZero(b3Float4ConstArg v)\0A{\0A\09if(b3Fabs(v.x)>1e-6 || b3Fabs(v.y)>1e-6 || b3Fabs(v.z)>1e-6)\09\0A\09\09return false;\0A\09return true;\0A}\0Ainline int    b3MaxDot( b3Float4ConstArg vec, __global const b3Float4* vecArray, int vecLen, float* dotOut )\0A{\0A    float maxDot = -B3_INFINITY;\0A    int i = 0;\0A    int ptIndex = -1;\0A    for( i = 0; i < vecLen; i++ )\0A    {\0A        float dot = b3Dot3F4(vecArray[i],vec);\0A            \0A        if( dot > maxDot )\0A        {\0A            maxDot = dot;\0A            ptIndex = i;\0A        }\0A    }\0A\09b3Assert(ptIndex>=0);\0A    if (ptIndex<0)\0A\09{\0A\09\09ptIndex = 0;\0A\09}\0A    *dotOut = maxDot;\0A    return ptIndex;\0A}\0A#endif //B3_FLOAT4_H\0Atypedef  struct b3Contact4Data b3Contact4Data_t;\0Astruct b3Contact4Data\0A{\0A\09b3Float4\09m_worldPosB[4];\0A//\09b3Float4\09m_localPosA[4];\0A//\09b3Float4\09m_localPosB[4];\0A\09b3Float4\09m_worldNormalOnB;\09//\09w: m_nPoints\0A\09unsigned short  m_restituitionCoeffCmp;\0A\09unsigned short  m_frictionCoeffCmp;\0A\09int m_batchIdx;\0A\09int m_bodyAPtrAndSignBit;//x:m_bodyAPtr, y:m_bodyBPtr\0A\09int m_bodyBPtrAndSignBit;\0A\09int\09m_childIndexA;\0A\09int\09m_childIndexB;\0A\09int m_unused1;\0A\09int m_unused2;\0A};\0Ainline int b3Contact4Data_getNumPoints(const struct b3Contact4Data* contact)\0A{\0A\09return (int)contact->m_worldNormalOnB.w;\0A};\0Ainline void b3Contact4Data_setNumPoints(struct b3Contact4Data* contact, int numPoints)\0A{\0A\09contact->m_worldNormalOnB.w = (float)numPoints;\0A};\0A#endif //B3_CONTACT4DATA_H\0A#define SHAPE_CONVEX_HULL 3\0A#define SHAPE_PLANE 4\0A#define SHAPE_CONCAVE_TRIMESH 5\0A#define SHAPE_COMPOUND_OF_CONVEX_HULLS 6\0A#define SHAPE_SPHERE 7\0A#pragma OPENCL EXTENSION cl_amd_printf : enable\0A#pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable\0A#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\0A#pragma OPENCL EXTENSION cl_khr_local_int32_extended_atomics : enable\0A#pragma OPENCL EXTENSION cl_khr_global_int32_extended_atomics : enable\0A#ifdef cl_ext_atomic_counters_32\0A#pragma OPENCL EXTENSION cl_ext_atomic_counters_32 : enable\0A#else\0A#define counter32_t volatile __global int*\0A#endif\0A#define GET_GROUP_IDX get_group_id(0)\0A#define GET_LOCAL_IDX get_local_id(0)\0A#define GET_GLOBAL_IDX get_global_id(0)\0A#define GET_GROUP_SIZE get_local_size(0)\0A#define GET_NUM_GROUPS get_num_groups(0)\0A#define GROUP_LDS_BARRIER barrier(CLK_LOCAL_MEM_FENCE)\0A#define GROUP_MEM_FENCE mem_fence(CLK_LOCAL_MEM_FENCE)\0A#define AtomInc(x) atom_inc(&(x))\0A#define AtomInc1(x, out) out = atom_inc(&(x))\0A#define AppendInc(x, out) out = atomic_inc(x)\0A#define AtomAdd(x, value) atom_add(&(x), value)\0A#define AtomCmpxhg(x, cmp, value) atom_cmpxchg( &(x), cmp, value )\0A#define AtomXhg(x, value) atom_xchg ( &(x), value )\0A#define max2 max\0A#define min2 min\0Atypedef unsigned int u32;\0Atypedef struct \0A{\0A\09union\0A\09{\0A\09\09float4\09m_min;\0A\09\09float   m_minElems[4];\0A\09\09int\09\09\09m_minIndices[4];\0A\09};\0A\09union\0A\09{\0A\09\09float4\09m_max;\0A\09\09float   m_maxElems[4];\0A\09\09int\09\09\09m_maxIndices[4];\0A\09};\0A} btAabbCL;\0A///keep this in sync with btCollidable.h\0Atypedef struct\0A{\0A\09int m_numChildShapes;\0A\09float m_radius;\0A\09int m_shapeType;\0A\09int m_shapeIndex;\0A\09\0A} btCollidableGpu;\0Atypedef struct\0A{\0A\09float4\09m_childPosition;\0A\09float4\09m_childOrientation;\0A\09int m_shapeIndex;\0A\09int m_unused0;\0A\09int m_unused1;\0A\09int m_unused2;\0A} btGpuChildShape;\0A#define GET_NPOINTS(x) (x).m_worldNormalOnB.w\0Atypedef struct\0A{\0A\09float4 m_pos;\0A\09float4 m_quat;\0A\09float4 m_linVel;\0A\09float4 m_angVel;\0A\09u32 m_collidableIdx;\09\0A\09float m_invMass;\0A\09float m_restituitionCoeff;\0A\09float m_frictionCoeff;\0A} BodyData;\0Atypedef struct  \0A{\0A\09float4\09\09m_localCenter;\0A\09float4\09\09m_extents;\0A\09float4\09\09mC;\0A\09float4\09\09mE;\0A\09\0A\09float\09\09\09m_radius;\0A\09int\09m_faceOffset;\0A\09int m_numFaces;\0A\09int\09m_numVertices;\0A\09\0A\09int m_vertexOffset;\0A\09int\09m_uniqueEdgesOffset;\0A\09int\09m_numUniqueEdges;\0A\09int m_unused;\0A} ConvexPolyhedronCL;\0Atypedef struct\0A{\0A\09float4 m_plane;\0A\09int m_indexOffset;\0A\09int m_numIndices;\0A} btGpuFace;\0A#define SELECT_UINT4( b, a, condition ) select( b,a,condition )\0A#define make_float4 (float4)\0A#define make_float2 (float2)\0A#define make_uint4 (uint4)\0A#define make_int4 (int4)\0A#define make_uint2 (uint2)\0A#define make_int2 (int2)\0A__inline\0Afloat fastDiv(float numerator, float denominator)\0A{\0A\09return native_divide(numerator, denominator);\09\0A//\09return numerator/denominator;\09\0A}\0A__inline\0Afloat4 fastDiv4(float4 numerator, float4 denominator)\0A{\0A\09return native_divide(numerator, denominator);\09\0A}\0A__inline\0Afloat4 cross3(float4 a, float4 b)\0A{\0A\09return cross(a,b);\0A}\0A//#define dot3F4 dot\0A__inline\0Afloat dot3F4(float4 a, float4 b)\0A{\0A\09float4 a1 = make_float4(a.xyz,0.f);\0A\09float4 b1 = make_float4(b.xyz,0.f);\0A\09return dot(a1, b1);\0A}\0A__inline\0Afloat4 fastNormalize4(float4 v)\0A{\0A\09return fast_normalize(v);\0A}\0A///////////////////////////////////////\0A//\09Quaternion\0A///////////////////////////////////////\0Atypedef float4 Quaternion;\0A__inline\0AQuaternion qtMul(Quaternion a, Quaternion b);\0A__inline\0AQuaternion qtNormalize(Quaternion in);\0A__inline\0Afloat4 qtRotate(Quaternion q, float4 vec);\0A__inline\0AQuaternion qtInvert(Quaternion q);\0A__inline\0AQuaternion qtMul(Quaternion a, Quaternion b)\0A{\0A\09Quaternion ans;\0A\09ans = cross3( a, b );\0A\09ans += a.w*b+b.w*a;\0A//\09ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);\0A\09ans.w = a.w*b.w - dot3F4(a, b);\0A\09return ans;\0A}\0A__inline\0AQuaternion qtNormalize(Quaternion in)\0A{\0A\09return fastNormalize4(in);\0A//\09in /= length( in );\0A//\09return in;\0A}\0A__inline\0Afloat4 qtRotate(Quaternion q, float4 vec)\0A{\0A\09Quaternion qInv = qtInvert( q );\0A\09float4 vcpy = vec;\0A\09vcpy.w = 0.f;\0A\09float4 out = qtMul(qtMul(q,vcpy),qInv);\0A\09return out;\0A}\0A__inline\0AQuaternion qtInvert(Quaternion q)\0A{\0A\09return (Quaternion)(-q.xyz, q.w);\0A}\0A__inline\0Afloat4 qtInvRotate(const Quaternion q, float4 vec)\0A{\0A\09return qtRotate( qtInvert( q ), vec );\0A}\0A__inline\0Afloat4 transform(const float4* p, const float4* translation, const Quaternion* orientation)\0A{\0A\09return qtRotate( *orientation, *p ) + (*translation);\0A}\0Avoid\09trInverse(float4 translationIn, Quaternion orientationIn,\0A\09\09float4* translationOut, Quaternion* orientationOut)\0A{\0A\09*orientationOut = qtInvert(orientationIn);\0A\09*translationOut = qtRotate(*orientationOut, -translationIn);\0A}\0Avoid\09trMul(float4 translationA, Quaternion orientationA,\0A\09\09\09\09\09\09float4 translationB, Quaternion orientationB,\0A\09\09float4* translationOut, Quaternion* orientationOut)\0A{\0A\09*orientationOut = qtMul(orientationA,orientationB);\0A\09*translationOut = transform(&translationB,&translationA,&orientationA);\0A}\0A__inline\0Afloat4 normalize3(const float4 a)\0A{\0A\09float4 n = make_float4(a.x, a.y, a.z, 0.f);\0A\09return fastNormalize4( n );\0A}\0A__inline float4 lerp3(const float4 a,const float4 b, float  t)\0A{\0A\09return make_float4(\09a.x + (b.x - a.x) * t,\0A\09\09\09\09\09\09a.y + (b.y - a.y) * t,\0A\09\09\09\09\09\09a.z + (b.z - a.z) * t,\0A\09\09\09\09\09\090.f);\0A}\0Afloat signedDistanceFromPointToPlane(float4 point, float4 planeEqn, float4* closestPointOnFace)\0A{\0A\09float4 n = (float4)(planeEqn.x, planeEqn.y, planeEqn.z, 0);\0A\09float dist = dot3F4(n, point) + planeEqn.w;\0A\09*closestPointOnFace = point - dist * n;\0A\09return dist;\0A}\0Ainline bool IsPointInPolygon(float4 p, \0A\09\09\09\09\09\09\09const btGpuFace* face,\0A\09\09\09\09\09\09\09__global const float4* baseVertex,\0A\09\09\09\09\09\09\09__global const  int* convexIndices,\0A\09\09\09\09\09\09\09float4* out)\0A{\0A    float4 a;\0A    float4 b;\0A    float4 ab;\0A    float4 ap;\0A    float4 v;\0A\09float4 plane = make_float4(face->m_plane.x,face->m_plane.y,face->m_plane.z,0.f);\0A\09\0A\09if (face->m_numIndices<2)\0A\09\09return false;\0A\09\0A\09float4 v0 = baseVertex[convexIndices[face->m_indexOffset + face->m_numIndices-1]];\0A\09\0A\09b = v0;\0A    for(unsigned i=0; i != face->m_numIndices; ++i)\0A    {\0A\09\09a = b;\0A\09\09float4 vi = baseVertex[convexIndices[face->m_indexOffset + i]];\0A\09\09b = vi;\0A        ab = b-a;\0A        ap = p-a;\0A        v = cross3(ab,plane);\0A        if (dot(ap, v) > 0.f)\0A        {\0A            float ab_m2 = dot(ab, ab);\0A            float rt = ab_m2 != 0.f ? dot(ab, ap) / ab_m2 : 0.f;\0A            if (rt <= 0.f)\0A            {\0A                *out = a;\0A            }\0A            else if (rt >= 1.f) \0A            {\0A                *out = b;\0A            }\0A            else\0A            {\0A            \09float s = 1.f - rt;\0A\09\09\09\09out[0].x = s * a.x + rt * b.x;\0A\09\09\09\09out[0].y = s * a.y + rt * b.y;\0A\09\09\09\09out[0].z = s * a.z + rt * b.z;\0A            }\0A            return false;\0A        }\0A    }\0A    return true;\0A}\0Avoid\09computeContactSphereConvex(int pairIndex,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int bodyIndexA, int bodyIndexB, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int collidableIndexA, int collidableIndexB, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const BodyData* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btCollidableGpu* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const ConvexPolyhedronCL* convexShapes,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* convexVertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* convexIndices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btGpuFace* faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global struct b3Contact4Data* restrict globalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09counter32_t nGlobalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int maxContactCapacity,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09float4 spherePos2,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09float radius,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09float4 pos,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09float4 quat\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09)\0A{\0A\09float4 invPos;\0A\09float4 invOrn;\0A\09trInverse(pos,quat, &invPos,&invOrn);\0A\09float4 spherePos = transform(&spherePos2,&invPos,&invOrn);\0A\09int shapeIndex = collidables[collidableIndexB].m_shapeIndex;\0A\09int numFaces = convexShapes[shapeIndex].m_numFaces;\0A\09float4 closestPnt = (float4)(0, 0, 0, 0);\0A\09float4 hitNormalWorld = (float4)(0, 0, 0, 0);\0A\09float minDist = -1000000.f;\0A\09bool bCollide = true;\0A\09for ( int f = 0; f < numFaces; f++ )\0A\09{\0A\09\09btGpuFace face = faces[convexShapes[shapeIndex].m_faceOffset+f];\0A\09\09// set up a plane equation \0A\09\09float4 planeEqn;\0A\09\09float4 n1 = face.m_plane;\0A\09\09n1.w = 0.f;\0A\09\09planeEqn = n1;\0A\09\09planeEqn.w = face.m_plane.w;\0A\09\09\0A\09\0A\09\09// compute a signed distance from the vertex in cloth to the face of rigidbody.\0A\09\09float4 pntReturn;\0A\09\09float dist = signedDistanceFromPointToPlane(spherePos, planeEqn, &pntReturn);\0A\09\09// If the distance is positive, the plane is a separating plane. \0A\09\09if ( dist > radius )\0A\09\09{\0A\09\09\09bCollide = false;\0A\09\09\09break;\0A\09\09}\0A\09\09if (dist>0)\0A\09\09{\0A\09\09\09//might hit an edge or vertex\0A\09\09\09float4 out;\0A\09\09\09float4 zeroPos = make_float4(0,0,0,0);\0A\09\09\09bool isInPoly = IsPointInPolygon(spherePos,\0A\09\09\09\09\09&face,\0A\09\09\09\09\09&convexVertices[convexShapes[shapeIndex].m_vertexOffset],\0A\09\09\09\09\09convexIndices,\0A           &out);\0A\09\09\09if (isInPoly)\0A\09\09\09{\0A\09\09\09\09if (dist>minDist)\0A\09\09\09\09{\0A\09\09\09\09\09minDist = dist;\0A\09\09\09\09\09closestPnt = pntReturn;\0A\09\09\09\09\09hitNormalWorld = planeEqn;\0A\09\09\09\09\09\0A\09\09\09\09}\0A\09\09\09} else\0A\09\09\09{\0A\09\09\09\09float4 tmp = spherePos-out;\0A\09\09\09\09float l2 = dot(tmp,tmp);\0A\09\09\09\09if (l2<radius*radius)\0A\09\09\09\09{\0A\09\09\09\09\09dist  = sqrt(l2);\0A\09\09\09\09\09if (dist>minDist)\0A\09\09\09\09\09{\0A\09\09\09\09\09\09minDist = dist;\0A\09\09\09\09\09\09closestPnt = out;\0A\09\09\09\09\09\09hitNormalWorld = tmp/dist;\0A\09\09\09\09\09\09\0A\09\09\09\09\09}\0A\09\09\09\09\09\0A\09\09\09\09} else\0A\09\09\09\09{\0A\09\09\09\09\09bCollide = false;\0A\09\09\09\09\09break;\0A\09\09\09\09}\0A\09\09\09}\0A\09\09} else\0A\09\09{\0A\09\09\09if ( dist > minDist )\0A\09\09\09{\0A\09\09\09\09minDist = dist;\0A\09\09\09\09closestPnt = pntReturn;\0A\09\09\09\09hitNormalWorld.xyz = planeEqn.xyz;\0A\09\09\09}\0A\09\09}\0A\09\09\0A\09}\0A\09\0A\09if (bCollide && minDist > -10000)\0A\09{\0A\09\09float4 normalOnSurfaceB1 = qtRotate(quat,-hitNormalWorld);\0A\09\09float4 pOnB1 = transform(&closestPnt,&pos,&quat);\0A\09\09\0A\09\09float actualDepth = minDist-radius;\0A\09\09if (actualDepth<=0.f)\0A\09\09{\0A\09\09\09\0A\09\09\09pOnB1.w = actualDepth;\0A\09\09\09int dstIdx;\0A\09\09\09AppendInc( nGlobalContactsOut, dstIdx );\0A\09\09\0A\09\09\09\0A\09\09\09if (1)//dstIdx < maxContactCapacity)\0A\09\09\09{\0A\09\09\09\09__global struct b3Contact4Data* c = &globalContactsOut[dstIdx];\0A\09\09\09\09c->m_worldNormalOnB = -normalOnSurfaceB1;\0A\09\09\09\09c->m_restituitionCoeffCmp = (0.f*0xffff);c->m_frictionCoeffCmp = (0.7f*0xffff);\0A\09\09\09\09c->m_batchIdx = pairIndex;\0A\09\09\09\09c->m_bodyAPtrAndSignBit = rigidBodies[bodyIndexA].m_invMass==0?-bodyIndexA:bodyIndexA;\0A\09\09\09\09c->m_bodyBPtrAndSignBit = rigidBodies[bodyIndexB].m_invMass==0?-bodyIndexB:bodyIndexB;\0A\09\09\09\09c->m_worldPosB[0] = pOnB1;\0A\09\09\09\09c->m_childIndexA = -1;\0A\09\09\09\09c->m_childIndexB = -1;\0A\09\09\09\09GET_NPOINTS(*c) = 1;\0A\09\09\09} \0A\09\09}\0A\09}//if (hasCollision)\0A}\0A\09\09\09\09\09\09\09\0Aint extractManifoldSequential(const float4* p, int nPoints, float4 nearNormal, int4* contactIdx)\0A{\0A\09if( nPoints == 0 )\0A        return 0;\0A    \0A    if (nPoints <=4)\0A        return nPoints;\0A    \0A    \0A    if (nPoints >64)\0A        nPoints = 64;\0A    \0A\09float4 center = make_float4(0.f);\0A\09{\0A\09\09\0A\09\09for (int i=0;i<nPoints;i++)\0A\09\09\09center += p[i];\0A\09\09center /= (float)nPoints;\0A\09}\0A    \0A\09\0A    \0A\09//\09sample 4 directions\0A    \0A    float4 aVector = p[0] - center;\0A    float4 u = cross3( nearNormal, aVector );\0A    float4 v = cross3( nearNormal, u );\0A    u = normalize3( u );\0A    v = normalize3( v );\0A    \0A    \0A    //keep point with deepest penetration\0A    float minW= FLT_MAX;\0A    \0A    int minIndex=-1;\0A    \0A    float4 maxDots;\0A    maxDots.x = FLT_MIN;\0A    maxDots.y = FLT_MIN;\0A    maxDots.z = FLT_MIN;\0A    maxDots.w = FLT_MIN;\0A    \0A    //\09idx, distance\0A    for(int ie = 0; ie<nPoints; ie++ )\0A    {\0A        if (p[ie].w<minW)\0A        {\0A            minW = p[ie].w;\0A            minIndex=ie;\0A        }\0A        float f;\0A        float4 r = p[ie]-center;\0A        f = dot3F4( u, r );\0A        if (f<maxDots.x)\0A        {\0A            maxDots.x = f;\0A            contactIdx[0].x = ie;\0A        }\0A        \0A        f = dot3F4( -u, r );\0A        if (f<maxDots.y)\0A        {\0A            maxDots.y = f;\0A            contactIdx[0].y = ie;\0A        }\0A        \0A        \0A        f = dot3F4( v, r );\0A        if (f<maxDots.z)\0A        {\0A            maxDots.z = f;\0A            contactIdx[0].z = ie;\0A        }\0A        \0A        f = dot3F4( -v, r );\0A        if (f<maxDots.w)\0A        {\0A            maxDots.w = f;\0A            contactIdx[0].w = ie;\0A        }\0A        \0A    }\0A    \0A    if (contactIdx[0].x != minIndex && contactIdx[0].y != minIndex && contactIdx[0].z != minIndex && contactIdx[0].w != minIndex)\0A    {\0A        //replace the first contact with minimum (todo: replace contact with least penetration)\0A        contactIdx[0].x = minIndex;\0A    }\0A    \0A    return 4;\0A    \0A}\0A#define MAX_PLANE_CONVEX_POINTS 64\0Aint computeContactPlaneConvex(int pairIndex,\0A\09\09\09\09\09\09\09\09int bodyIndexA, int bodyIndexB, \0A\09\09\09\09\09\09\09\09int collidableIndexA, int collidableIndexB, \0A\09\09\09\09\09\09\09\09__global const BodyData* rigidBodies, \0A\09\09\09\09\09\09\09\09__global const btCollidableGpu*collidables,\0A\09\09\09\09\09\09\09\09__global const ConvexPolyhedronCL* convexShapes,\0A\09\09\09\09\09\09\09\09__global const float4* convexVertices,\0A\09\09\09\09\09\09\09\09__global const int* convexIndices,\0A\09\09\09\09\09\09\09\09__global const btGpuFace* faces,\0A\09\09\09\09\09\09\09\09__global struct b3Contact4Data* restrict globalContactsOut,\0A\09\09\09\09\09\09\09\09counter32_t nGlobalContactsOut,\0A\09\09\09\09\09\09\09\09int maxContactCapacity,\0A\09\09\09\09\09\09\09\09float4 posB,\0A\09\09\09\09\09\09\09\09Quaternion ornB\0A\09\09\09\09\09\09\09\09)\0A{\0A\09int resultIndex=-1;\0A\09\09int shapeIndex = collidables[collidableIndexB].m_shapeIndex;\0A\09__global const ConvexPolyhedronCL* hullB = &convexShapes[shapeIndex];\0A\09\0A\09float4 posA;\0A\09posA = rigidBodies[bodyIndexA].m_pos;\0A\09Quaternion ornA;\0A\09ornA = rigidBodies[bodyIndexA].m_quat;\0A\09int numContactsOut = 0;\0A\09int numWorldVertsB1= 0;\0A\09float4 planeEq;\0A\09 planeEq = faces[collidables[collidableIndexA].m_shapeIndex].m_plane;\0A\09float4 planeNormal = make_float4(planeEq.x,planeEq.y,planeEq.z,0.f);\0A\09float4 planeNormalWorld;\0A\09planeNormalWorld = qtRotate(ornA,planeNormal);\0A\09float planeConstant = planeEq.w;\0A\09\0A\09float4 invPosA;Quaternion invOrnA;\0A\09float4 convexInPlaneTransPos1; Quaternion convexInPlaneTransOrn1;\0A\09{\0A\09\09\0A\09\09trInverse(posA,ornA,&invPosA,&invOrnA);\0A\09\09trMul(invPosA,invOrnA,posB,ornB,&convexInPlaneTransPos1,&convexInPlaneTransOrn1);\0A\09}\0A\09float4 invPosB;Quaternion invOrnB;\0A\09float4 planeInConvexPos1;\09Quaternion planeInConvexOrn1;\0A\09{\0A\09\09\0A\09\09trInverse(posB,ornB,&invPosB,&invOrnB);\0A\09\09trMul(invPosB,invOrnB,posA,ornA,&planeInConvexPos1,&planeInConvexOrn1);\09\0A\09}\0A\09\0A\09float4 planeNormalInConvex = qtRotate(planeInConvexOrn1,-planeNormal);\0A\09float maxDot = -1e30;\0A\09int hitVertex=-1;\0A\09float4 hitVtx;\0A\09float4 contactPoints[MAX_PLANE_CONVEX_POINTS];\0A\09int numPoints = 0;\0A\09int4 contactIdx;\0A\09contactIdx=make_int4(0,1,2,3);\0A    \0A\09\0A\09for (int i=0;i<hullB->m_numVertices;i++)\0A\09{\0A\09\09float4 vtx = convexVertices[hullB->m_vertexOffset+i];\0A\09\09float curDot = dot(vtx,planeNormalInConvex);\0A\09\09if (curDot>maxDot)\0A\09\09{\0A\09\09\09hitVertex=i;\0A\09\09\09maxDot=curDot;\0A\09\09\09hitVtx = vtx;\0A\09\09\09//make sure the deepest points is always included\0A\09\09\09if (numPoints==MAX_PLANE_CONVEX_POINTS)\0A\09\09\09\09numPoints--;\0A\09\09}\0A\09\09if (numPoints<MAX_PLANE_CONVEX_POINTS)\0A\09\09{\0A\09\09\09float4 vtxWorld = transform(&vtx, &posB, &ornB);\0A\09\09\09float4 vtxInPlane = transform(&vtxWorld, &invPosA, &invOrnA);//oplaneTransform.inverse()*vtxWorld;\0A\09\09\09float dist = dot(planeNormal,vtxInPlane)-planeConstant;\0A\09\09\09if (dist<0.f)\0A\09\09\09{\0A\09\09\09\09vtxWorld.w = dist;\0A\09\09\09\09contactPoints[numPoints] = vtxWorld;\0A\09\09\09\09numPoints++;\0A\09\09\09}\0A\09\09}\0A\09}\0A\09int numReducedPoints  = numPoints;\0A\09if (numPoints>4)\0A\09{\0A\09\09numReducedPoints = extractManifoldSequential( contactPoints, numPoints, planeNormalInConvex, &contactIdx);\0A\09}\0A\09if (numReducedPoints>0)\0A\09{\0A\09\09int dstIdx;\0A\09    AppendInc( nGlobalContactsOut, dstIdx );\0A\09\09if (dstIdx < maxContactCapacity)\0A\09\09{\0A\09\09\09resultIndex = dstIdx;\0A\09\09\09__global struct b3Contact4Data* c = &globalContactsOut[dstIdx];\0A\09\09\09c->m_worldNormalOnB = -planeNormalWorld;\0A\09\09\09//c->setFrictionCoeff(0.7);\0A\09\09\09//c->setRestituitionCoeff(0.f);\0A\09\09\09c->m_restituitionCoeffCmp = (0.f*0xffff);c->m_frictionCoeffCmp = (0.7f*0xffff);\0A\09\09\09c->m_batchIdx = pairIndex;\0A\09\09\09c->m_bodyAPtrAndSignBit = rigidBodies[bodyIndexA].m_invMass==0?-bodyIndexA:bodyIndexA;\0A\09\09\09c->m_bodyBPtrAndSignBit = rigidBodies[bodyIndexB].m_invMass==0?-bodyIndexB:bodyIndexB;\0A\09\09\09c->m_childIndexA = -1;\0A\09\09\09c->m_childIndexB = -1;\0A\09\09\09switch (numReducedPoints)\0A            {\0A                case 4:\0A                    c->m_worldPosB[3] = contactPoints[contactIdx.w];\0A                case 3:\0A                    c->m_worldPosB[2] = contactPoints[contactIdx.z];\0A                case 2:\0A                    c->m_worldPosB[1] = contactPoints[contactIdx.y];\0A                case 1:\0A                    c->m_worldPosB[0] = contactPoints[contactIdx.x];\0A                default:\0A                {\0A                }\0A            };\0A\09\09\09\0A\09\09\09GET_NPOINTS(*c) = numReducedPoints;\0A\09\09}//if (dstIdx < numPairs)\0A\09}\09\0A\09return resultIndex;\0A}\0Avoid\09computeContactPlaneSphere(int pairIndex,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int bodyIndexA, int bodyIndexB, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int collidableIndexA, int collidableIndexB, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const BodyData* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btCollidableGpu* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btGpuFace* faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global struct b3Contact4Data* restrict globalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09counter32_t nGlobalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int maxContactCapacity)\0A{\0A\09float4 planeEq = faces[collidables[collidableIndexA].m_shapeIndex].m_plane;\0A\09float radius = collidables[collidableIndexB].m_radius;\0A\09float4 posA1 = rigidBodies[bodyIndexA].m_pos;\0A\09float4 ornA1 = rigidBodies[bodyIndexA].m_quat;\0A\09float4 posB1 = rigidBodies[bodyIndexB].m_pos;\0A\09float4 ornB1 = rigidBodies[bodyIndexB].m_quat;\0A\09\0A\09bool hasCollision = false;\0A\09float4 planeNormal1 = make_float4(planeEq.x,planeEq.y,planeEq.z,0.f);\0A\09float planeConstant = planeEq.w;\0A\09float4 convexInPlaneTransPos1; Quaternion convexInPlaneTransOrn1;\0A\09{\0A\09\09float4 invPosA;Quaternion invOrnA;\0A\09\09trInverse(posA1,ornA1,&invPosA,&invOrnA);\0A\09\09trMul(invPosA,invOrnA,posB1,ornB1,&convexInPlaneTransPos1,&convexInPlaneTransOrn1);\0A\09}\0A\09float4 planeInConvexPos1;\09Quaternion planeInConvexOrn1;\0A\09{\0A\09\09float4 invPosB;Quaternion invOrnB;\0A\09\09trInverse(posB1,ornB1,&invPosB,&invOrnB);\0A\09\09trMul(invPosB,invOrnB,posA1,ornA1,&planeInConvexPos1,&planeInConvexOrn1);\09\0A\09}\0A\09float4 vtx1 = qtRotate(planeInConvexOrn1,-planeNormal1)*radius;\0A\09float4 vtxInPlane1 = transform(&vtx1,&convexInPlaneTransPos1,&convexInPlaneTransOrn1);\0A\09float distance = dot3F4(planeNormal1,vtxInPlane1) - planeConstant;\0A\09hasCollision = distance < 0.f;//m_manifoldPtr->getContactBreakingThreshold();\0A\09if (hasCollision)\0A\09{\0A\09\09float4 vtxInPlaneProjected1 = vtxInPlane1 -   distance*planeNormal1;\0A\09\09float4 vtxInPlaneWorld1 = transform(&vtxInPlaneProjected1,&posA1,&ornA1);\0A\09\09float4 normalOnSurfaceB1 = qtRotate(ornA1,planeNormal1);\0A\09\09float4 pOnB1 = vtxInPlaneWorld1+normalOnSurfaceB1*distance;\0A\09\09pOnB1.w = distance;\0A\09\09int dstIdx;\0A    AppendInc( nGlobalContactsOut, dstIdx );\0A\09\09\0A\09\09if (dstIdx < maxContactCapacity)\0A\09\09{\0A\09\09\09__global struct b3Contact4Data* c = &globalContactsOut[dstIdx];\0A\09\09\09c->m_worldNormalOnB = -normalOnSurfaceB1;\0A\09\09\09c->m_restituitionCoeffCmp = (0.f*0xffff);c->m_frictionCoeffCmp = (0.7f*0xffff);\0A\09\09\09c->m_batchIdx = pairIndex;\0A\09\09\09c->m_bodyAPtrAndSignBit = rigidBodies[bodyIndexA].m_invMass==0?-bodyIndexA:bodyIndexA;\0A\09\09\09c->m_bodyBPtrAndSignBit = rigidBodies[bodyIndexB].m_invMass==0?-bodyIndexB:bodyIndexB;\0A\09\09\09c->m_worldPosB[0] = pOnB1;\0A\09\09\09c->m_childIndexA = -1;\0A\09\09\09c->m_childIndexB = -1;\0A\09\09\09GET_NPOINTS(*c) = 1;\0A\09\09}//if (dstIdx < numPairs)\0A\09}//if (hasCollision)\0A}\0A__kernel void   primitiveContactsKernel( __global int4* pairs, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const BodyData* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btCollidableGpu* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const ConvexPolyhedronCL* convexShapes, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* vertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* uniqueEdges,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btGpuFace* faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09__global struct b3Contact4Data* restrict globalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09counter32_t nGlobalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09int numPairs, int maxContactCapacity)\0A{\0A\09int i = get_global_id(0);\0A\09int pairIndex = i;\0A\09\0A\09float4 worldVertsB1[64];\0A\09float4 worldVertsB2[64];\0A\09int capacityWorldVerts = 64;\09\0A\09float4 localContactsOut[64];\0A\09int localContactCapacity=64;\0A\09\0A\09float minDist = -1e30f;\0A\09float maxDist = 0.02f;\0A\09if (i<numPairs)\0A\09{\0A\09\09int bodyIndexA = pairs[i].x;\0A\09\09int bodyIndexB = pairs[i].y;\0A\09\09\09\0A\09\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09\0A\09\09if (collidables[collidableIndexA].m_shapeType == SHAPE_PLANE &&\0A\09\09\09collidables[collidableIndexB].m_shapeType == SHAPE_CONVEX_HULL)\0A\09\09{\0A\09\09\09float4 posB;\0A\09\09\09posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09Quaternion ornB;\0A\09\09\09ornB = rigidBodies[bodyIndexB].m_quat;\0A\09\09\09int contactIndex = computeContactPlaneConvex(pairIndex, bodyIndexA, bodyIndexB, collidableIndexA, collidableIndexB, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09rigidBodies,collidables,convexShapes,vertices,indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09faces,\09globalContactsOut, nGlobalContactsOut,maxContactCapacity, posB,ornB);\0A\09\09\09if (contactIndex>=0)\0A\09\09\09\09pairs[pairIndex].z = contactIndex;\0A\09\09\09return;\0A\09\09}\0A\09\09if (collidables[collidableIndexA].m_shapeType == SHAPE_CONVEX_HULL &&\0A\09\09\09collidables[collidableIndexB].m_shapeType == SHAPE_PLANE)\0A\09\09{\0A\09\09\09float4 posA;\0A\09\09\09posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09\09Quaternion ornA;\0A\09\09\09ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09\09int contactIndex = computeContactPlaneConvex( pairIndex, bodyIndexB,bodyIndexA,  collidableIndexB,collidableIndexA, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09rigidBodies,collidables,convexShapes,vertices,indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09faces,\09globalContactsOut, nGlobalContactsOut,maxContactCapacity,posA,ornA);\0A\09\09\09if (contactIndex>=0)\0A\09\09\09\09pairs[pairIndex].z = contactIndex;\0A\09\09\09return;\0A\09\09}\0A\09\09if (collidables[collidableIndexA].m_shapeType == SHAPE_PLANE &&\0A\09\09\09collidables[collidableIndexB].m_shapeType == SHAPE_SPHERE)\0A\09\09{\0A\09\09\09computeContactPlaneSphere(pairIndex, bodyIndexA, bodyIndexB, collidableIndexA, collidableIndexB, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09rigidBodies,collidables,faces,\09globalContactsOut, nGlobalContactsOut,maxContactCapacity);\0A\09\09\09return;\0A\09\09}\0A\09\09if (collidables[collidableIndexA].m_shapeType == SHAPE_SPHERE &&\0A\09\09\09collidables[collidableIndexB].m_shapeType == SHAPE_PLANE)\0A\09\09{\0A\09\09\09computeContactPlaneSphere( pairIndex, bodyIndexB,bodyIndexA,  collidableIndexB,collidableIndexA, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09rigidBodies,collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09faces,\09globalContactsOut, nGlobalContactsOut,maxContactCapacity);\0A\09\09\09return;\0A\09\09}\0A\09\09\0A\09\0A\09\09if (collidables[collidableIndexA].m_shapeType == SHAPE_SPHERE &&\0A\09\09\09collidables[collidableIndexB].m_shapeType == SHAPE_CONVEX_HULL)\0A\09\09{\0A\09\09\0A\09\09\09float4 spherePos = rigidBodies[bodyIndexA].m_pos;\0A\09\09\09float sphereRadius = collidables[collidableIndexA].m_radius;\0A\09\09\09float4 convexPos = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09float4 convexOrn = rigidBodies[bodyIndexB].m_quat;\0A\09\09\09computeContactSphereConvex(pairIndex, bodyIndexA, bodyIndexB, collidableIndexA, collidableIndexB, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09rigidBodies,collidables,convexShapes,vertices,indices,faces, globalContactsOut, nGlobalContactsOut,maxContactCapacity,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09spherePos,sphereRadius,convexPos,convexOrn);\0A\09\09\09return;\0A\09\09}\0A\09\09if (collidables[collidableIndexA].m_shapeType == SHAPE_CONVEX_HULL &&\0A\09\09\09collidables[collidableIndexB].m_shapeType == SHAPE_SPHERE)\0A\09\09{\0A\09\09\0A\09\09\09float4 spherePos = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09float sphereRadius = collidables[collidableIndexB].m_radius;\0A\09\09\09float4 convexPos = rigidBodies[bodyIndexA].m_pos;\0A\09\09\09float4 convexOrn = rigidBodies[bodyIndexA].m_quat;\0A\09\09\09computeContactSphereConvex(pairIndex, bodyIndexB, bodyIndexA, collidableIndexB, collidableIndexA, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09rigidBodies,collidables,convexShapes,vertices,indices,faces, globalContactsOut, nGlobalContactsOut,maxContactCapacity,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09spherePos,sphereRadius,convexPos,convexOrn);\0A\09\09\09return;\0A\09\09}\0A\09\0A\09\0A\09\0A\09\09\0A\09\0A\09\0A\09\09if (collidables[collidableIndexA].m_shapeType == SHAPE_SPHERE &&\0A\09\09\09collidables[collidableIndexB].m_shapeType == SHAPE_SPHERE)\0A\09\09{\0A\09\09\09//sphere-sphere\0A\09\09\09float radiusA = collidables[collidableIndexA].m_radius;\0A\09\09\09float radiusB = collidables[collidableIndexB].m_radius;\0A\09\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09float4 diff = posA-posB;\0A\09\09\09float len = length(diff);\0A\09\09\09\0A\09\09\09///iff distance positive, don't generate a new contact\0A\09\09\09if ( len <= (radiusA+radiusB))\0A\09\09\09{\0A\09\09\09\09///distance (negative means penetration)\0A\09\09\09\09float dist = len - (radiusA+radiusB);\0A\09\09\09\09float4 normalOnSurfaceB = make_float4(1.f,0.f,0.f,0.f);\0A\09\09\09\09if (len > 0.00001)\0A\09\09\09\09{\0A\09\09\09\09\09normalOnSurfaceB = diff / len;\0A\09\09\09\09}\0A\09\09\09\09float4 contactPosB = posB + normalOnSurfaceB*radiusB;\0A\09\09\09\09contactPosB.w = dist;\0A\09\09\09\09\09\09\09\09\0A\09\09\09\09int dstIdx;\0A\09\09\09\09 AppendInc( nGlobalContactsOut, dstIdx );\0A\09\09\09\09\0A\09\09\09\09if (dstIdx < maxContactCapacity)\0A\09\09\09\09{\0A\09\09\09\09\09__global struct b3Contact4Data* c = &globalContactsOut[dstIdx];\0A\09\09\09\09\09c->m_worldNormalOnB = normalOnSurfaceB;\0A\09\09\09\09\09c->m_restituitionCoeffCmp = (0.f*0xffff);c->m_frictionCoeffCmp = (0.7f*0xffff);\0A\09\09\09\09\09c->m_batchIdx = pairIndex;\0A\09\09\09\09\09int bodyA = pairs[pairIndex].x;\0A\09\09\09\09\09int bodyB = pairs[pairIndex].y;\0A\09\09\09\09\09c->m_bodyAPtrAndSignBit = rigidBodies[bodyA].m_invMass==0?-bodyA:bodyA;\0A\09\09\09\09\09c->m_bodyBPtrAndSignBit = rigidBodies[bodyB].m_invMass==0?-bodyB:bodyB;\0A\09\09\09\09\09c->m_worldPosB[0] = contactPosB;\0A\09\09\09\09\09c->m_childIndexA = -1;\0A\09\09\09\09\09c->m_childIndexB = -1;\0A\09\09\09\09\09GET_NPOINTS(*c) = 1;\0A\09\09\09\09}//if (dstIdx < numPairs)\0A\09\09\09}//if ( len <= (radiusA+radiusB))\0A\09\09\09return;\0A\09\09}//SHAPE_SPHERE SHAPE_SPHERE\0A\09}//\09if (i<numPairs)\0A}\0A// work-in-progress\0A__kernel void   processCompoundPairsPrimitivesKernel( __global const int4* gpuCompoundPairs,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global const BodyData* rigidBodies, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btCollidableGpu* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global const ConvexPolyhedronCL* convexShapes, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* vertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* uniqueEdges,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btGpuFace* faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global const int* indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global btAabbCL* aabbs,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global const btGpuChildShape* gpuChildShapes,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09__global struct b3Contact4Data* restrict globalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09counter32_t nGlobalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09int numCompoundPairs, int maxContactCapacity\0A\09\09\09\09\09\09\09\09\09\09\09\09\09)\0A{\0A\09int i = get_global_id(0);\0A\09if (i<numCompoundPairs)\0A\09{\0A\09\09int bodyIndexA = gpuCompoundPairs[i].x;\0A\09\09int bodyIndexB = gpuCompoundPairs[i].y;\0A\09\09int childShapeIndexA = gpuCompoundPairs[i].z;\0A\09\09int childShapeIndexB = gpuCompoundPairs[i].w;\0A\09\09\0A\09\09int collidableIndexA = -1;\0A\09\09int collidableIndexB = -1;\0A\09\09\0A\09\09float4 ornA = rigidBodies[bodyIndexA].m_quat;\0A\09\09float4 posA = rigidBodies[bodyIndexA].m_pos;\0A\09\09\0A\09\09float4 ornB = rigidBodies[bodyIndexB].m_quat;\0A\09\09float4 posB = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09\09\09\09\09\0A\09\09if (childShapeIndexA >= 0)\0A\09\09{\0A\09\09\09collidableIndexA = gpuChildShapes[childShapeIndexA].m_shapeIndex;\0A\09\09\09float4 childPosA = gpuChildShapes[childShapeIndexA].m_childPosition;\0A\09\09\09float4 childOrnA = gpuChildShapes[childShapeIndexA].m_childOrientation;\0A\09\09\09float4 newPosA = qtRotate(ornA,childPosA)+posA;\0A\09\09\09float4 newOrnA = qtMul(ornA,childOrnA);\0A\09\09\09posA = newPosA;\0A\09\09\09ornA = newOrnA;\0A\09\09} else\0A\09\09{\0A\09\09\09collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09\09}\0A\09\09\0A\09\09if (childShapeIndexB>=0)\0A\09\09{\0A\09\09\09collidableIndexB = gpuChildShapes[childShapeIndexB].m_shapeIndex;\0A\09\09\09float4 childPosB = gpuChildShapes[childShapeIndexB].m_childPosition;\0A\09\09\09float4 childOrnB = gpuChildShapes[childShapeIndexB].m_childOrientation;\0A\09\09\09float4 newPosB = transform(&childPosB,&posB,&ornB);\0A\09\09\09float4 newOrnB = qtMul(ornB,childOrnB);\0A\09\09\09posB = newPosB;\0A\09\09\09ornB = newOrnB;\0A\09\09} else\0A\09\09{\0A\09\09\09collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\09\0A\09\09}\0A\09\0A\09\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09\0A\09\09int shapeTypeA = collidables[collidableIndexA].m_shapeType;\0A\09\09int shapeTypeB = collidables[collidableIndexB].m_shapeType;\0A\09\09int pairIndex = i;\0A\09\09if ((shapeTypeA == SHAPE_PLANE) && (shapeTypeB==SHAPE_CONVEX_HULL))\0A\09\09{\0A\09\09\09computeContactPlaneConvex( pairIndex, bodyIndexA,bodyIndexB,  collidableIndexA,collidableIndexB, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09rigidBodies,collidables,convexShapes,vertices,indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09faces,\09globalContactsOut, nGlobalContactsOut,maxContactCapacity,posB,ornB);\0A\09\09\09return;\0A\09\09}\0A\09\09if ((shapeTypeA == SHAPE_CONVEX_HULL) && (shapeTypeB==SHAPE_PLANE))\0A\09\09{\0A\09\09\09computeContactPlaneConvex( pairIndex, bodyIndexB,bodyIndexA,  collidableIndexB,collidableIndexA, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09rigidBodies,collidables,convexShapes,vertices,indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09faces,\09globalContactsOut, nGlobalContactsOut,maxContactCapacity,posA,ornA);\0A\09\09\09return;\0A\09\09}\0A\09\09if ((shapeTypeA == SHAPE_CONVEX_HULL) && (shapeTypeB == SHAPE_SPHERE))\0A\09\09{\0A\09\09\09float4 spherePos = rigidBodies[bodyIndexB].m_pos;\0A\09\09\09float sphereRadius = collidables[collidableIndexB].m_radius;\0A\09\09\09float4 convexPos = posA;\0A\09\09\09float4 convexOrn = ornA;\0A\09\09\09\0A\09\09\09computeContactSphereConvex(pairIndex, bodyIndexB, bodyIndexA , collidableIndexB,collidableIndexA, \0A\09\09\09\09\09\09\09\09\09\09rigidBodies,collidables,convexShapes,vertices,indices,faces, globalContactsOut, nGlobalContactsOut,maxContactCapacity,\0A\09\09\09\09\09\09\09\09\09\09spherePos,sphereRadius,convexPos,convexOrn);\0A\09\0A\09\09\09return;\0A\09\09}\0A\09\09if ((shapeTypeA == SHAPE_SPHERE) && (shapeTypeB == SHAPE_CONVEX_HULL))\0A\09\09{\0A\09\09\09float4 spherePos = rigidBodies[bodyIndexA].m_pos;\0A\09\09\09float sphereRadius = collidables[collidableIndexA].m_radius;\0A\09\09\09float4 convexPos = posB;\0A\09\09\09float4 convexOrn = ornB;\0A\09\09\09\0A\09\09\09computeContactSphereConvex(pairIndex, bodyIndexA, bodyIndexB, collidableIndexA, collidableIndexB, \0A\09\09\09\09\09\09\09\09\09\09rigidBodies,collidables,convexShapes,vertices,indices,faces, globalContactsOut, nGlobalContactsOut,maxContactCapacity,\0A\09\09\09\09\09\09\09\09\09\09spherePos,sphereRadius,convexPos,convexOrn);\0A\09\0A\09\09\09return;\0A\09\09}\0A\09}//\09if (i<numCompoundPairs)\0A}\0Abool pointInTriangle(const float4* vertices, const float4* normal, float4 *p )\0A{\0A\09const float4* p1 = &vertices[0];\0A\09const float4* p2 = &vertices[1];\0A\09const float4* p3 = &vertices[2];\0A\09float4 edge1;\09edge1 = (*p2 - *p1);\0A\09float4 edge2;\09edge2 = ( *p3 - *p2 );\0A\09float4 edge3;\09edge3 = ( *p1 - *p3 );\0A\09\0A\09float4 p1_to_p; p1_to_p = ( *p - *p1 );\0A\09float4 p2_to_p; p2_to_p = ( *p - *p2 );\0A\09float4 p3_to_p; p3_to_p = ( *p - *p3 );\0A\09float4 edge1_normal; edge1_normal = ( cross(edge1,*normal));\0A\09float4 edge2_normal; edge2_normal = ( cross(edge2,*normal));\0A\09float4 edge3_normal; edge3_normal = ( cross(edge3,*normal));\0A\09\0A\09\0A\09float r1, r2, r3;\0A\09r1 = dot(edge1_normal,p1_to_p );\0A\09r2 = dot(edge2_normal,p2_to_p );\0A\09r3 = dot(edge3_normal,p3_to_p );\0A\09\0A\09if ( r1 > 0 && r2 > 0 && r3 > 0 )\0A\09\09return true;\0A    if ( r1 <= 0 && r2 <= 0 && r3 <= 0 ) \0A\09\09return true;\0A\09return false;\0A}\0Afloat segmentSqrDistance(float4 from, float4 to,float4 p, float4* nearest) \0A{\0A\09float4 diff = p - from;\0A\09float4 v = to - from;\0A\09float t = dot(v,diff);\0A\09\0A\09if (t > 0) \0A\09{\0A\09\09float dotVV = dot(v,v);\0A\09\09if (t < dotVV) \0A\09\09{\0A\09\09\09t /= dotVV;\0A\09\09\09diff -= t*v;\0A\09\09} else \0A\09\09{\0A\09\09\09t = 1;\0A\09\09\09diff -= v;\0A\09\09}\0A\09} else\0A\09{\0A\09\09t = 0;\0A\09}\0A\09*nearest = from + t*v;\0A\09return dot(diff,diff);\09\0A}\0Avoid\09computeContactSphereTriangle(int pairIndex,\0A\09\09\09\09\09\09\09\09\09int bodyIndexA, int bodyIndexB,\0A\09\09\09\09\09\09\09\09\09int collidableIndexA, int collidableIndexB, \0A\09\09\09\09\09\09\09\09\09__global const BodyData* rigidBodies, \0A\09\09\09\09\09\09\09\09\09__global const btCollidableGpu* collidables,\0A\09\09\09\09\09\09\09\09\09const float4* triangleVertices,\0A\09\09\09\09\09\09\09\09\09__global struct b3Contact4Data* restrict globalContactsOut,\0A\09\09\09\09\09\09\09\09\09counter32_t nGlobalContactsOut,\0A\09\09\09\09\09\09\09\09\09int maxContactCapacity,\0A\09\09\09\09\09\09\09\09\09float4 spherePos2,\0A\09\09\09\09\09\09\09\09\09float radius,\0A\09\09\09\09\09\09\09\09\09float4 pos,\0A\09\09\09\09\09\09\09\09\09float4 quat,\0A\09\09\09\09\09\09\09\09\09int faceIndex\0A\09\09\09\09\09\09\09\09\09)\0A{\0A\09float4 invPos;\0A\09float4 invOrn;\0A\09trInverse(pos,quat, &invPos,&invOrn);\0A\09float4 spherePos = transform(&spherePos2,&invPos,&invOrn);\0A\09int numFaces = 3;\0A\09float4 closestPnt = (float4)(0, 0, 0, 0);\0A\09float4 hitNormalWorld = (float4)(0, 0, 0, 0);\0A\09float minDist = -1000000.f;\0A\09bool bCollide = false;\0A\09\0A\09//////////////////////////////////////\0A\09float4 sphereCenter;\0A\09sphereCenter = spherePos;\0A\09const float4* vertices = triangleVertices;\0A\09float contactBreakingThreshold = 0.f;//todo?\0A\09float radiusWithThreshold = radius + contactBreakingThreshold;\0A\09float4 edge10;\0A\09edge10 = vertices[1]-vertices[0];\0A\09edge10.w = 0.f;//is this needed?\0A\09float4 edge20;\0A\09edge20 = vertices[2]-vertices[0];\0A\09edge20.w = 0.f;//is this needed?\0A\09float4 normal = cross3(edge10,edge20);\0A\09normal = normalize(normal);\0A\09float4 p1ToCenter;\0A\09p1ToCenter = sphereCenter - vertices[0];\0A\09\0A\09float distanceFromPlane = dot(p1ToCenter,normal);\0A\09if (distanceFromPlane < 0.f)\0A\09{\0A\09\09//triangle facing the other way\0A\09\09distanceFromPlane *= -1.f;\0A\09\09normal *= -1.f;\0A\09}\0A\09hitNormalWorld = normal;\0A\09bool isInsideContactPlane = distanceFromPlane < radiusWithThreshold;\0A\09\0A\09// Check for contact / intersection\0A\09bool hasContact = false;\0A\09float4 contactPoint;\0A\09if (isInsideContactPlane) \0A\09{\0A\09\0A\09\09if (pointInTriangle(vertices,&normal, &sphereCenter)) \0A\09\09{\0A\09\09\09// Inside the contact wedge - touches a point on the shell plane\0A\09\09\09hasContact = true;\0A\09\09\09contactPoint = sphereCenter - normal*distanceFromPlane;\0A\09\09\09\0A\09\09} else {\0A\09\09\09// Could be inside one of the contact capsules\0A\09\09\09float contactCapsuleRadiusSqr = radiusWithThreshold*radiusWithThreshold;\0A\09\09\09float4 nearestOnEdge;\0A\09\09\09int numEdges = 3;\0A\09\09\09for (int i = 0; i < numEdges; i++) \0A\09\09\09{\0A\09\09\09\09float4 pa =vertices[i];\0A\09\09\09\09float4 pb = vertices[(i+1)%3];\0A\09\09\09\09float distanceSqr = segmentSqrDistance(pa,pb,sphereCenter, &nearestOnEdge);\0A\09\09\09\09if (distanceSqr < contactCapsuleRadiusSqr) \0A\09\09\09\09{\0A\09\09\09\09\09// Yep, we're inside a capsule\0A\09\09\09\09\09hasContact = true;\0A\09\09\09\09\09contactPoint = nearestOnEdge;\0A\09\09\09\09\09\0A\09\09\09\09}\0A\09\09\09\09\0A\09\09\09}\0A\09\09}\0A\09}\0A\09if (hasContact) \0A\09{\0A\09\09closestPnt = contactPoint;\0A\09\09float4 contactToCenter = sphereCenter - contactPoint;\0A\09\09minDist = length(contactToCenter);\0A\09\09if (minDist>FLT_EPSILON)\0A\09\09{\0A\09\09\09hitNormalWorld = normalize(contactToCenter);//*(1./minDist);\0A\09\09\09bCollide  = true;\0A\09\09}\0A\09\09\0A\09}\0A\09/////////////////////////////////////\0A\09if (bCollide && minDist > -10000)\0A\09{\0A\09\09\0A\09\09float4 normalOnSurfaceB1 = qtRotate(quat,-hitNormalWorld);\0A\09\09float4 pOnB1 = transform(&closestPnt,&pos,&quat);\0A\09\09float actualDepth = minDist-radius;\0A\09\09\0A\09\09if (actualDepth<=0.f)\0A\09\09{\0A\09\09\09pOnB1.w = actualDepth;\0A\09\09\09int dstIdx;\0A\09\09\09\0A\09\09\09float lenSqr = dot3F4(normalOnSurfaceB1,normalOnSurfaceB1);\0A\09\09\09if (lenSqr>FLT_EPSILON)\0A\09\09\09{\0A\09\09\09\09AppendInc( nGlobalContactsOut, dstIdx );\0A\09\09\09\0A\09\09\09\09if (dstIdx < maxContactCapacity)\0A\09\09\09\09{\0A\09\09\09\09\09__global struct b3Contact4Data* c = &globalContactsOut[dstIdx];\0A\09\09\09\09\09c->m_worldNormalOnB = -normalOnSurfaceB1;\0A\09\09\09\09\09c->m_restituitionCoeffCmp = (0.f*0xffff);c->m_frictionCoeffCmp = (0.7f*0xffff);\0A\09\09\09\09\09c->m_batchIdx = pairIndex;\0A\09\09\09\09\09c->m_bodyAPtrAndSignBit = rigidBodies[bodyIndexA].m_invMass==0?-bodyIndexA:bodyIndexA;\0A\09\09\09\09\09c->m_bodyBPtrAndSignBit = rigidBodies[bodyIndexB].m_invMass==0?-bodyIndexB:bodyIndexB;\0A\09\09\09\09\09c->m_worldPosB[0] = pOnB1;\0A\09\09\09\09\09c->m_childIndexA = -1;\0A\09\09\09\09\09c->m_childIndexB = faceIndex;\0A\09\09\09\09\09GET_NPOINTS(*c) = 1;\0A\09\09\09\09} \0A\09\09\09}\0A\09\09}\0A\09}//if (hasCollision)\0A}\0A// work-in-progress\0A__kernel void   findConcaveSphereContactsKernel( __global int4* concavePairs,\0A\09\09\09\09\09\09\09\09\09\09\09\09__global const BodyData* rigidBodies,\0A\09\09\09\09\09\09\09\09\09\09\09\09__global const btCollidableGpu* collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09__global const ConvexPolyhedronCL* convexShapes, \0A\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* vertices,\0A\09\09\09\09\09\09\09\09\09\09\09\09__global const float4* uniqueEdges,\0A\09\09\09\09\09\09\09\09\09\09\09\09__global const btGpuFace* faces,\0A\09\09\09\09\09\09\09\09\09\09\09\09__global const int* indices,\0A\09\09\09\09\09\09\09\09\09\09\09\09__global btAabbCL* aabbs,\0A\09\09\09\09\09\09\09\09\09\09\09\09__global struct b3Contact4Data* restrict globalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09counter32_t nGlobalContactsOut,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09int numConcavePairs, int maxContactCapacity\0A\09\09\09\09\09\09\09\09\09\09\09\09)\0A{\0A\09int i = get_global_id(0);\0A\09if (i>=numConcavePairs)\0A\09\09return;\0A\09int pairIdx = i;\0A\09int bodyIndexA = concavePairs[i].x;\0A\09int bodyIndexB = concavePairs[i].y;\0A\09int collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\0A\09int collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\0A\09int shapeIndexA = collidables[collidableIndexA].m_shapeIndex;\0A\09int shapeIndexB = collidables[collidableIndexB].m_shapeIndex;\0A\09if (collidables[collidableIndexB].m_shapeType==SHAPE_SPHERE)\0A\09{\0A\09\09int f = concavePairs[i].z;\0A\09\09btGpuFace face = faces[convexShapes[shapeIndexA].m_faceOffset+f];\0A\09\09\0A\09\09float4 verticesA[3];\0A\09\09for (int i=0;i<3;i++)\0A\09\09{\0A\09\09\09int index = indices[face.m_indexOffset+i];\0A\09\09\09float4 vert = vertices[convexShapes[shapeIndexA].m_vertexOffset+index];\0A\09\09\09verticesA[i] = vert;\0A\09\09}\0A\09\09float4 spherePos = rigidBodies[bodyIndexB].m_pos;\0A\09\09float sphereRadius = collidables[collidableIndexB].m_radius;\0A\09\09float4 convexPos = rigidBodies[bodyIndexA].m_pos;\0A\09\09float4 convexOrn = rigidBodies[bodyIndexA].m_quat;\0A\09\09computeContactSphereTriangle(i, bodyIndexB, bodyIndexA, collidableIndexB, collidableIndexA, \0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09rigidBodies,collidables,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09verticesA,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09globalContactsOut, nGlobalContactsOut,maxContactCapacity,\0A\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09spherePos,sphereRadius,convexPos,convexOrn, f);\0A\09\09return;\0A\09}\0A}\0A\00", align 1
@.str.72 = private unnamed_addr constant [20 x i8] c"clipHullAgainstHull\00", align 1
@.str.73 = private unnamed_addr constant [19 x i8] c"findSeparatingAxis\00", align 1
@__const._ZN12b3LauncherCL8launch2DEiiii.lRange = private unnamed_addr constant [3 x i64] [i64 1, i64 1, i64 1], align 16
@__clewEnqueueNDRangeKernel = external local_unnamed_addr global ptr, align 8
@.str.74 = private unnamed_addr constant [27 x i8] c"Error: OpenCL status = %d\0A\00", align 1
@_ZTV13b3OpenCLArrayI9b3Vector3E = linkonce_odr dso_local unnamed_addr constant { [4 x ptr] } { [4 x ptr] [ptr null, ptr @_ZTI13b3OpenCLArrayI9b3Vector3E, ptr @_ZN13b3OpenCLArrayI9b3Vector3ED2Ev, ptr @_ZN13b3OpenCLArrayI9b3Vector3ED0Ev] }, comdat, align 8
@_ZTS13b3OpenCLArrayI9b3Vector3E = linkonce_odr dso_local constant [28 x i8] c"13b3OpenCLArrayI9b3Vector3E\00", comdat, align 1
@_ZTI13b3OpenCLArrayI9b3Vector3E = linkonce_odr dso_local constant { ptr, ptr } { ptr getelementptr inbounds (ptr, ptr @_ZTVN10__cxxabiv117__class_type_infoE, i64 2), ptr @_ZTS13b3OpenCLArrayI9b3Vector3E }, comdat, align 8
@__clewCreateBuffer = external local_unnamed_addr global ptr, align 8
@.str.75 = private unnamed_addr constant [146 x i8] c"generated/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/bullet3/bullet3/src/Bullet3OpenCL/ParallelPrimitives/b3OpenCLArray.h\00", align 1
@.str.76 = private unnamed_addr constant [22 x i8] c"OpenCL out-of-memory\0A\00", align 1
@__clewEnqueueCopyBuffer = external local_unnamed_addr global ptr, align 8
@__clewReleaseMemObject = external local_unnamed_addr global ptr, align 8
@_ZTV13b3OpenCLArrayIiE = linkonce_odr dso_local unnamed_addr constant { [4 x ptr] } { [4 x ptr] [ptr null, ptr @_ZTI13b3OpenCLArrayIiE, ptr @_ZN13b3OpenCLArrayIiED2Ev, ptr @_ZN13b3OpenCLArrayIiED0Ev] }, comdat, align 8
@_ZTS13b3OpenCLArrayIiE = linkonce_odr dso_local constant [19 x i8] c"13b3OpenCLArrayIiE\00", comdat, align 1
@_ZTI13b3OpenCLArrayIiE = linkonce_odr dso_local constant { ptr, ptr } { ptr getelementptr inbounds (ptr, ptr @_ZTVN10__cxxabiv117__class_type_infoE, i64 2), ptr @_ZTS13b3OpenCLArrayIiE }, comdat, align 8
@_ZTV13b3OpenCLArrayIfE = linkonce_odr dso_local unnamed_addr constant { [4 x ptr] } { [4 x ptr] [ptr null, ptr @_ZTI13b3OpenCLArrayIfE, ptr @_ZN13b3OpenCLArrayIfED2Ev, ptr @_ZN13b3OpenCLArrayIfED0Ev] }, comdat, align 8
@_ZTS13b3OpenCLArrayIfE = linkonce_odr dso_local constant [19 x i8] c"13b3OpenCLArrayIfE\00", comdat, align 1
@_ZTI13b3OpenCLArrayIfE = linkonce_odr dso_local constant { ptr, ptr } { ptr getelementptr inbounds (ptr, ptr @_ZTVN10__cxxabiv117__class_type_infoE, i64 2), ptr @_ZTS13b3OpenCLArrayIfE }, comdat, align 8
@_ZTV13b3OpenCLArrayI25b3CompoundOverlappingPairE = linkonce_odr dso_local unnamed_addr constant { [4 x ptr] } { [4 x ptr] [ptr null, ptr @_ZTI13b3OpenCLArrayI25b3CompoundOverlappingPairE, ptr @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairED2Ev, ptr @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairED0Ev] }, comdat, align 8
@_ZTS13b3OpenCLArrayI25b3CompoundOverlappingPairE = linkonce_odr dso_local constant [45 x i8] c"13b3OpenCLArrayI25b3CompoundOverlappingPairE\00", comdat, align 1
@_ZTI13b3OpenCLArrayI25b3CompoundOverlappingPairE = linkonce_odr dso_local constant { ptr, ptr } { ptr getelementptr inbounds (ptr, ptr @_ZTVN10__cxxabiv117__class_type_infoE, i64 2), ptr @_ZTS13b3OpenCLArrayI25b3CompoundOverlappingPairE }, comdat, align 8
@__clewEnqueueWriteBuffer = external local_unnamed_addr global ptr, align 8
@.str.77 = private unnamed_addr constant [35 x i8] c"copyFromHostPointer invalid range\0A\00", align 1
@.str.78 = private unnamed_addr constant [134 x i8] c"generated/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/bullet3/bullet3/src/Bullet3Common/b3AlignedObjectArray.h\00", align 1
@.str.79 = private unnamed_addr constant [44 x i8] c"b3AlignedObjectArray reserve out-of-memory\0A\00", align 1
@__clewSetKernelArg = external local_unnamed_addr global ptr, align 8
@__clewEnqueueReadBuffer = external local_unnamed_addr global ptr, align 8
@.str.80 = private unnamed_addr constant [33 x i8] c"copyToHostPointer invalid range\0A\00", align 1
@llvm.global_ctors = appending global [1 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 65535, ptr @_GLOBAL__sub_I_b3ConvexHullContact.cpp, ptr null }]
@str = private unnamed_addr constant [9 x i8] c"rejected\00", align 1

@_ZN15GpuSatCollisionC1EP11_cl_contextP13_cl_device_idP17_cl_command_queue = dso_local unnamed_addr alias void (ptr, ptr, ptr, ptr), ptr @_ZN15GpuSatCollisionC2EP11_cl_contextP13_cl_device_idP17_cl_command_queue
@_ZN15GpuSatCollisionD1Ev = dso_local unnamed_addr alias void (ptr), ptr @_ZN15GpuSatCollisionD2Ev

; Function Attrs: mustprogress nofree norecurse nounwind memory(argmem: readwrite, inaccessiblemem: readwrite) uwtable
define dso_local void @_Z14b3BvhTraversalPK6b3Int4PK15b3RigidBodyDataPK12b3CollidableP6b3AabbPS_PViPK16b3BvhSubtreeInfoPK18b3QuantizedBvhNodePK9b3BvhInfoiii(ptr nocapture noundef readonly %pairs, ptr nocapture noundef readonly %rigidBodies, ptr nocapture noundef readonly %collidables, ptr nocapture noundef readonly %aabbs, ptr nocapture noundef writeonly %concavePairsOut, ptr noundef %numConcavePairsOut, ptr nocapture noundef readonly %subtreeHeadersRoot, ptr nocapture noundef readonly %quantizedNodesRoot, ptr nocapture noundef readonly %bvhInfos, i32 %numPairs, i32 noundef %maxNumConcavePairsCapacity, i32 noundef %id) local_unnamed_addr #0 {
entry:
  %idxprom = sext i32 %id to i64
  %arrayidx = getelementptr inbounds %struct.b3Int4, ptr %pairs, i64 %idxprom
  %0 = load i32, ptr %arrayidx, align 16
  %y = getelementptr inbounds %struct.anon, ptr %arrayidx, i64 0, i32 1
  %1 = load i32, ptr %y, align 4
  %idxprom3 = sext i32 %0 to i64
  %m_collidableIdx = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom3, i32 4
  %2 = load i32, ptr %m_collidableIdx, align 16
  %idxprom5 = sext i32 %1 to i64
  %m_collidableIdx7 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom5, i32 4
  %3 = load i32, ptr %m_collidableIdx7, align 16
  %m_invMass = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom3, i32 5
  %4 = load float, ptr %m_invMass, align 4
  %cmp = fcmp oeq float %4, 0.000000e+00
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %m_invMass12 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom5, i32 5
  %5 = load float, ptr %m_invMass12, align 4
  %cmp13 = fcmp oeq float %5, 0.000000e+00
  br i1 %cmp13, label %for.end113, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %idxprom14 = sext i32 %2 to i64
  %arrayidx15 = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom14
  %m_shapeType = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom14, i32 2
  %6 = load i32, ptr %m_shapeType, align 4
  %cmp16.not = icmp eq i32 %6, 5
  br i1 %cmp16.not, label %if.end18, label %for.end113

if.end18:                                         ; preds = %if.end
  %idxprom19 = sext i32 %3 to i64
  %arrayidx20 = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom19
  %m_shapeType21 = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom19, i32 2
  %7 = load i32, ptr %m_shapeType21, align 4
  switch i32 %7, label %for.end113 [
    i32 7, label %if.end28
    i32 6, label %if.end28
    i32 3, label %if.end28
  ]

if.end28:                                         ; preds = %if.end18, %if.end18, %if.end18
  %8 = load i32, ptr %arrayidx15, align 4
  %idxprom31 = sext i32 %8 to i64
  %arrayidx32 = getelementptr inbounds %struct.b3BvhInfo, ptr %bvhInfos, i64 %idxprom31
  %bvhInfo.sroa.0.sroa.3.0.arrayidx32.sroa_idx = getelementptr inbounds i8, ptr %arrayidx32, i64 8
  %bvhInfo.sroa.0.sroa.3.0.copyload = load float, ptr %bvhInfo.sroa.0.sroa.3.0.arrayidx32.sroa_idx, align 8
  %bvhInfo.sroa.0.sroa.4.0.arrayidx32.sroa_idx = getelementptr inbounds i8, ptr %arrayidx32, i64 12
  %bvhInfo.sroa.0.sroa.4.0.copyload = load float, ptr %bvhInfo.sroa.0.sroa.4.0.arrayidx32.sroa_idx, align 4
  %bvhInfo.sroa.0.sroa.5.0.arrayidx32.sroa_idx = getelementptr inbounds i8, ptr %arrayidx32, i64 16
  %bvhInfo.sroa.0.sroa.5.0.copyload = load float, ptr %bvhInfo.sroa.0.sroa.5.0.arrayidx32.sroa_idx, align 16
  %bvhInfo.sroa.0.sroa.6.0.arrayidx32.sroa_idx = getelementptr inbounds i8, ptr %arrayidx32, i64 20
  %bvhInfo.sroa.0.sroa.6.0.copyload = load float, ptr %bvhInfo.sroa.0.sroa.6.0.arrayidx32.sroa_idx, align 4
  %bvhInfo.sroa.0.sroa.7.0.arrayidx32.sroa_idx = getelementptr inbounds i8, ptr %arrayidx32, i64 24
  %bvhInfo.sroa.0.sroa.7.0.copyload = load float, ptr %bvhInfo.sroa.0.sroa.7.0.arrayidx32.sroa_idx, align 8
  %bvhInfo.sroa.0.sroa.9.0.arrayidx32.sroa_idx = getelementptr inbounds i8, ptr %arrayidx32, i64 32
  %bvhInfo.sroa.0.sroa.9.0.copyload = load float, ptr %bvhInfo.sroa.0.sroa.9.0.arrayidx32.sroa_idx, align 16
  %bvhInfo.sroa.0.sroa.10.0.arrayidx32.sroa_idx = getelementptr inbounds i8, ptr %arrayidx32, i64 36
  %9 = load <2 x float>, ptr %bvhInfo.sroa.0.sroa.10.0.arrayidx32.sroa_idx, align 4
  %bvhInfo.sroa.4.0.arrayidx32.sroa_idx = getelementptr inbounds i8, ptr %arrayidx32, i64 52
  %bvhInfo.sroa.4.0.copyload = load i32, ptr %bvhInfo.sroa.4.0.arrayidx32.sroa_idx, align 4
  %bvhInfo.sroa.5.0.arrayidx32.sroa_idx = getelementptr inbounds i8, ptr %arrayidx32, i64 56
  %bvhInfo.sroa.5.0.copyload = load i32, ptr %bvhInfo.sroa.5.0.arrayidx32.sroa_idx, align 8
  %bvhInfo.sroa.6.0.arrayidx32.sroa_idx = getelementptr inbounds i8, ptr %arrayidx32, i64 60
  %bvhInfo.sroa.6.0.copyload = load i32, ptr %bvhInfo.sroa.6.0.arrayidx32.sroa_idx, align 4
  %idxprom33 = sext i32 %bvhInfo.sroa.6.0.copyload to i64
  %arrayidx34 = getelementptr inbounds %class.b3BvhSubtreeInfo, ptr %subtreeHeadersRoot, i64 %idxprom33
  %idxprom35 = sext i32 %bvhInfo.sroa.5.0.copyload to i64
  %arrayidx36 = getelementptr inbounds %struct.b3QuantizedBvhNode, ptr %quantizedNodesRoot, i64 %idxprom35
  %arrayidx38 = getelementptr inbounds %struct.b3Aabb, ptr %aabbs, i64 %idxprom5
  %retval.sroa.0.0.copyload.i.i = load <2 x float>, ptr %arrayidx38, align 16
  %retval.sroa.6.0.a.sroa_idx.i.i = getelementptr inbounds i8, ptr %arrayidx38, i64 8
  %retval.sroa.6.0.copyload.i.i = load <2 x float>, ptr %retval.sroa.6.0.a.sroa_idx.i.i, align 8
  %retval.sroa.0.0.vec.extract.i.i = extractelement <2 x float> %retval.sroa.0.0.copyload.i.i, i64 0
  %retval.sroa.6.8.vec.extract.i.i = extractelement <2 x float> %retval.sroa.6.0.copyload.i.i, i64 0
  %cmp.i7.i.i.i = fcmp olt float %retval.sroa.6.8.vec.extract.i.i, %bvhInfo.sroa.0.sroa.3.0.copyload
  %retval.sroa.6.8.vec.insert.i.i = insertelement <2 x float> %retval.sroa.6.0.copyload.i.i, float %bvhInfo.sroa.0.sroa.3.0.copyload, i64 0
  %retval.sroa.6.0.i.i = select i1 %cmp.i7.i.i.i, <2 x float> %retval.sroa.6.8.vec.insert.i.i, <2 x float> %retval.sroa.6.0.copyload.i.i
  %retval.sroa.6.12.vec.extract.i.i = extractelement <2 x float> %retval.sroa.6.0.i.i, i64 1
  %cmp.i10.i.i.i = fcmp olt float %retval.sroa.6.12.vec.extract.i.i, %bvhInfo.sroa.0.sroa.4.0.copyload
  %retval.sroa.6.12.vec.insert.i.i = insertelement <2 x float> %retval.sroa.6.0.i.i, float %bvhInfo.sroa.0.sroa.4.0.copyload, i64 1
  %retval.sroa.6.1.i.i = select i1 %cmp.i10.i.i.i, <2 x float> %retval.sroa.6.12.vec.insert.i.i, <2 x float> %retval.sroa.6.0.i.i
  %retval.sroa.6.8.vec.extract.i26.i = extractelement <2 x float> %retval.sroa.6.1.i.i, i64 0
  %cmp.i7.i.i27.i = fcmp olt float %bvhInfo.sroa.0.sroa.7.0.copyload, %retval.sroa.6.8.vec.extract.i26.i
  %retval.sroa.6.8.vec.insert.i28.i = insertelement <2 x float> poison, float %bvhInfo.sroa.0.sroa.7.0.copyload, i64 0
  %retval.sroa.6.0.i29.i = select i1 %cmp.i7.i.i27.i, <2 x float> %retval.sroa.6.8.vec.insert.i28.i, <2 x float> %retval.sroa.6.1.i.i
  %10 = getelementptr inbounds %struct.b3Aabb, ptr %aabbs, i64 %idxprom5, i32 1
  %retval.sroa.0.0.copyload.i.i44 = load <2 x float>, ptr %10, align 16
  %retval.sroa.6.0.a.sroa_idx.i.i45 = getelementptr inbounds i8, ptr %10, i64 8
  %retval.sroa.6.0.copyload.i.i46 = load <2 x float>, ptr %retval.sroa.6.0.a.sroa_idx.i.i45, align 8
  %retval.sroa.0.0.vec.extract.i.i47 = extractelement <2 x float> %retval.sroa.0.0.copyload.i.i44, i64 0
  %retval.sroa.6.8.vec.extract.i.i57 = extractelement <2 x float> %retval.sroa.6.0.copyload.i.i46, i64 0
  %cmp.i7.i.i.i58 = fcmp olt float %retval.sroa.6.8.vec.extract.i.i57, %bvhInfo.sroa.0.sroa.3.0.copyload
  %retval.sroa.6.8.vec.insert.i.i59 = insertelement <2 x float> %retval.sroa.6.0.copyload.i.i46, float %bvhInfo.sroa.0.sroa.3.0.copyload, i64 0
  %retval.sroa.6.0.i.i60 = select i1 %cmp.i7.i.i.i58, <2 x float> %retval.sroa.6.8.vec.insert.i.i59, <2 x float> %retval.sroa.6.0.copyload.i.i46
  %retval.sroa.6.12.vec.extract.i.i62 = extractelement <2 x float> %retval.sroa.6.0.i.i60, i64 1
  %cmp.i10.i.i.i63 = fcmp olt float %retval.sroa.6.12.vec.extract.i.i62, %bvhInfo.sroa.0.sroa.4.0.copyload
  %retval.sroa.6.12.vec.insert.i.i64 = insertelement <2 x float> %retval.sroa.6.0.i.i60, float %bvhInfo.sroa.0.sroa.4.0.copyload, i64 1
  %retval.sroa.6.1.i.i65 = select i1 %cmp.i10.i.i.i63, <2 x float> %retval.sroa.6.12.vec.insert.i.i64, <2 x float> %retval.sroa.6.0.i.i60
  %retval.sroa.6.8.vec.extract.i26.i76 = extractelement <2 x float> %retval.sroa.6.1.i.i65, i64 0
  %cmp.i7.i.i27.i77 = fcmp olt float %bvhInfo.sroa.0.sroa.7.0.copyload, %retval.sroa.6.8.vec.extract.i26.i76
  %retval.sroa.6.0.i29.i79 = select i1 %cmp.i7.i.i27.i77, <2 x float> %retval.sroa.6.8.vec.insert.i28.i, <2 x float> %retval.sroa.6.1.i.i65
  %11 = load <2 x float>, ptr %arrayidx32, align 16
  %12 = extractelement <2 x float> %11, i64 0
  %cmp.i.i.i.i = fcmp olt float %retval.sroa.0.0.vec.extract.i.i, %12
  %sel = select i1 %cmp.i.i.i.i, <2 x float> %11, <2 x float> %retval.sroa.0.0.copyload.i.i
  %retval.sroa.0.0.i.i = shufflevector <2 x float> %sel, <2 x float> %retval.sroa.0.0.copyload.i.i, <2 x i32> <i32 0, i32 3>
  %retval.sroa.0.4.vec.extract.i.i = extractelement <2 x float> %retval.sroa.0.0.copyload.i.i, i64 1
  %13 = extractelement <2 x float> %11, i64 1
  %cmp.i4.i.i.i = fcmp olt float %retval.sroa.0.4.vec.extract.i.i, %13
  %sel177 = select i1 %cmp.i4.i.i.i, <2 x float> %11, <2 x float> %retval.sroa.0.0.i.i
  %retval.sroa.0.1.i.i = shufflevector <2 x float> %retval.sroa.0.0.i.i, <2 x float> %sel177, <2 x i32> <i32 0, i32 3>
  %retval.sroa.0.0.vec.extract.i16.i = extractelement <2 x float> %sel, i64 0
  %cmp.i.i.i17.i = fcmp olt float %bvhInfo.sroa.0.sroa.5.0.copyload, %retval.sroa.0.0.vec.extract.i16.i
  %retval.sroa.0.0.vec.insert.i18.i = insertelement <2 x float> %retval.sroa.0.1.i.i, float %bvhInfo.sroa.0.sroa.5.0.copyload, i64 0
  %retval.sroa.0.0.i19.i = select i1 %cmp.i.i.i17.i, <2 x float> %retval.sroa.0.0.vec.insert.i18.i, <2 x float> %retval.sroa.0.1.i.i
  %retval.sroa.0.4.vec.extract.i21.i = extractelement <2 x float> %retval.sroa.0.0.i19.i, i64 1
  %cmp.i4.i.i22.i = fcmp olt float %bvhInfo.sroa.0.sroa.6.0.copyload, %retval.sroa.0.4.vec.extract.i21.i
  %retval.sroa.0.4.vec.insert.i23.i = insertelement <2 x float> %retval.sroa.0.0.i19.i, float %bvhInfo.sroa.0.sroa.6.0.copyload, i64 1
  %retval.sroa.0.1.i24.i = select i1 %cmp.i4.i.i22.i, <2 x float> %retval.sroa.0.4.vec.insert.i23.i, <2 x float> %retval.sroa.0.0.i19.i
  %14 = fsub <2 x float> %retval.sroa.0.1.i24.i, %11
  %sub.i.i = extractelement <2 x float> %14, i64 0
  %mul.i.i = fmul float %bvhInfo.sroa.0.sroa.9.0.copyload, %sub.i.i
  %conv27.i = fptoui float %mul.i.i to i16
  %15 = and i16 %conv27.i, -2
  %cmp.i.i.i.i48 = fcmp olt float %retval.sroa.0.0.vec.extract.i.i47, %12
  %sel178 = select i1 %cmp.i.i.i.i48, <2 x float> %11, <2 x float> %retval.sroa.0.0.copyload.i.i44
  %retval.sroa.0.0.i.i50 = shufflevector <2 x float> %sel178, <2 x float> %retval.sroa.0.0.copyload.i.i44, <2 x i32> <i32 0, i32 3>
  %retval.sroa.0.4.vec.extract.i.i52 = extractelement <2 x float> %retval.sroa.0.0.copyload.i.i44, i64 1
  %cmp.i4.i.i.i53 = fcmp olt float %retval.sroa.0.4.vec.extract.i.i52, %13
  %sel179 = select i1 %cmp.i4.i.i.i53, <2 x float> %11, <2 x float> %retval.sroa.0.0.i.i50
  %retval.sroa.0.1.i.i55 = shufflevector <2 x float> %retval.sroa.0.0.i.i50, <2 x float> %sel179, <2 x i32> <i32 0, i32 3>
  %retval.sroa.0.0.vec.extract.i16.i66 = extractelement <2 x float> %sel178, i64 0
  %cmp.i.i.i17.i67 = fcmp olt float %bvhInfo.sroa.0.sroa.5.0.copyload, %retval.sroa.0.0.vec.extract.i16.i66
  %retval.sroa.0.0.vec.insert.i18.i68 = insertelement <2 x float> %retval.sroa.0.1.i.i55, float %bvhInfo.sroa.0.sroa.5.0.copyload, i64 0
  %retval.sroa.0.0.i19.i69 = select i1 %cmp.i.i.i17.i67, <2 x float> %retval.sroa.0.0.vec.insert.i18.i68, <2 x float> %retval.sroa.0.1.i.i55
  %retval.sroa.0.4.vec.extract.i21.i71 = extractelement <2 x float> %retval.sroa.0.0.i19.i69, i64 1
  %cmp.i4.i.i22.i72 = fcmp olt float %bvhInfo.sroa.0.sroa.6.0.copyload, %retval.sroa.0.4.vec.extract.i21.i71
  %retval.sroa.0.4.vec.insert.i23.i73 = insertelement <2 x float> %retval.sroa.0.0.i19.i69, float %bvhInfo.sroa.0.sroa.6.0.copyload, i64 1
  %retval.sroa.0.1.i24.i74 = select i1 %cmp.i4.i.i22.i72, <2 x float> %retval.sroa.0.4.vec.insert.i23.i73, <2 x float> %retval.sroa.0.0.i19.i69
  %16 = fsub <2 x float> %retval.sroa.0.1.i24.i74, %11
  %clampedPoint.sroa.5.8.vec.extract.i84 = extractelement <2 x float> %retval.sroa.6.0.i29.i79, i64 0
  %sub7.i.i85 = fsub float %clampedPoint.sroa.5.8.vec.extract.i84, %bvhInfo.sroa.0.sroa.3.0.copyload
  %17 = extractelement <2 x float> %9, i64 1
  %mul7.i.i90 = fmul float %17, %sub7.i.i85
  %18 = shufflevector <2 x float> %retval.sroa.0.1.i24.i, <2 x float> %retval.sroa.6.0.i29.i, <4 x i32> <i32 1, i32 2, i32 poison, i32 poison>
  %19 = shufflevector <2 x float> %16, <2 x float> poison, <4 x i32> <i32 0, i32 1, i32 poison, i32 poison>
  %20 = shufflevector <4 x float> %18, <4 x float> %19, <4 x i32> <i32 0, i32 1, i32 4, i32 5>
  %21 = shufflevector <2 x float> %11, <2 x float> poison, <4 x i32> <i32 1, i32 poison, i32 poison, i32 poison>
  %22 = insertelement <4 x float> %21, float %bvhInfo.sroa.0.sroa.3.0.copyload, i64 1
  %23 = insertelement <4 x float> %22, float %bvhInfo.sroa.0.sroa.9.0.copyload, i64 2
  %24 = shufflevector <2 x float> %9, <2 x float> poison, <4 x i32> <i32 0, i32 1, i32 poison, i32 poison>
  %25 = shufflevector <4 x float> %23, <4 x float> %24, <4 x i32> <i32 0, i32 1, i32 2, i32 4>
  %26 = fsub <4 x float> %20, %25
  %27 = fmul <4 x float> %20, %25
  %28 = shufflevector <4 x float> %26, <4 x float> %27, <4 x i32> <i32 0, i32 1, i32 6, i32 7>
  %29 = shufflevector <4 x float> %24, <4 x float> <float poison, float poison, float 1.000000e+00, float 1.000000e+00>, <4 x i32> <i32 0, i32 1, i32 6, i32 7>
  %30 = fmul <4 x float> %29, %28
  %31 = fadd <4 x float> %29, %28
  %32 = shufflevector <4 x float> %30, <4 x float> %31, <4 x i32> <i32 0, i32 1, i32 6, i32 7>
  %33 = fptoui <4 x float> %32 to <4 x i16>
  %34 = and <4 x i16> %33, <i16 -2, i16 -2, i16 poison, i16 poison>
  %35 = or <4 x i16> %33, <i16 poison, i16 poison, i16 1, i16 1>
  %36 = shufflevector <4 x i16> %34, <4 x i16> %35, <4 x i32> <i32 0, i32 1, i32 6, i32 7>
  %add20.i = fadd float %mul7.i.i90, 1.000000e+00
  %conv21.i = fptoui float %add20.i to i16
  %37 = or i16 %conv21.i, 1
  %cmp42160 = icmp sgt i32 %bvhInfo.sroa.4.0.copyload, 0
  br i1 %cmp42160, label %for.body.lr.ph, label %for.end113

for.body.lr.ph:                                   ; preds = %if.end28
  %cmp67 = icmp eq i32 %7, 6
  %retval.sroa.2.0.insert.ext.i116 = zext i32 %1 to i64
  %retval.sroa.2.0.insert.shift.i117 = shl nuw i64 %retval.sroa.2.0.insert.ext.i116, 32
  %retval.sroa.0.0.insert.ext.i118 = zext i32 %0 to i64
  %retval.sroa.0.0.insert.insert.i119 = or disjoint i64 %retval.sroa.2.0.insert.shift.i117, %retval.sroa.0.0.insert.ext.i118
  %38 = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom19, i32 3
  br i1 %cmp67, label %for.body.us.preheader, label %for.body.preheader

for.body.preheader:                               ; preds = %for.body.lr.ph
  %wide.trip.count = zext nneg i32 %bvhInfo.sroa.4.0.copyload to i64
  %39 = extractelement <4 x i16> %34, i64 0
  %40 = extractelement <4 x i16> %34, i64 1
  %41 = extractelement <4 x i16> %35, i64 2
  %42 = extractelement <4 x i16> %35, i64 3
  br label %for.body

for.body.us.preheader:                            ; preds = %for.body.lr.ph
  %43 = sext i32 %maxNumConcavePairsCapacity to i64
  %wide.trip.count173 = zext nneg i32 %bvhInfo.sroa.4.0.copyload to i64
  %44 = extractelement <4 x i16> %34, i64 0
  %45 = extractelement <4 x i16> %34, i64 1
  %46 = extractelement <4 x i16> %35, i64 2
  %47 = extractelement <4 x i16> %35, i64 3
  br label %for.body.us

for.body.us:                                      ; preds = %for.body.us.preheader, %for.inc111.us
  %indvars.iv170 = phi i64 [ 0, %for.body.us.preheader ], [ %indvars.iv.next171, %for.inc111.us ]
  %arrayidx44.us = getelementptr inbounds %struct.b3BvhSubtreeInfoData, ptr %arrayidx34, i64 %indvars.iv170
  %subtree.sroa.0.0.copyload.us = load i16, ptr %arrayidx44.us, align 4
  %subtree.sroa.2.0.arrayidx44.sroa_idx.us = getelementptr inbounds i8, ptr %arrayidx44.us, i64 2
  %subtree.sroa.2.0.copyload.us = load i16, ptr %subtree.sroa.2.0.arrayidx44.sroa_idx.us, align 2
  %subtree.sroa.4.0.arrayidx44.sroa_idx.us = getelementptr inbounds i8, ptr %arrayidx44.us, i64 6
  %subtree.sroa.4.0.copyload.us = load i16, ptr %subtree.sroa.4.0.arrayidx44.sroa_idx.us, align 2
  %subtree.sroa.5.0.arrayidx44.sroa_idx.us = getelementptr inbounds i8, ptr %arrayidx44.us, i64 8
  %subtree.sroa.5.0.copyload.us = load i16, ptr %subtree.sroa.5.0.arrayidx44.sroa_idx.us, align 4
  %subtree.sroa.6.0.arrayidx44.sroa_idx.us = getelementptr inbounds i8, ptr %arrayidx44.us, i64 10
  %subtree.sroa.6.0.copyload.us = load i16, ptr %subtree.sroa.6.0.arrayidx44.sroa_idx.us, align 2
  %subtree.sroa.7.0.arrayidx44.sroa_idx.us = getelementptr inbounds i8, ptr %arrayidx44.us, i64 12
  %subtree.sroa.7.0.copyload.us = load i32, ptr %subtree.sroa.7.0.arrayidx44.sroa_idx.us, align 4
  %subtree.sroa.8.0.arrayidx44.sroa_idx.us = getelementptr inbounds i8, ptr %arrayidx44.us, i64 16
  %subtree.sroa.8.0.copyload.us = load i32, ptr %subtree.sroa.8.0.arrayidx44.sroa_idx.us, align 4
  %cmp.i.us = icmp ugt i16 %15, %subtree.sroa.4.0.copyload.us
  %cmp7.i.us = icmp ult i16 %46, %subtree.sroa.0.0.copyload.us
  %or.cond.us = select i1 %cmp.i.us, i1 true, i1 %cmp7.i.us
  %cmp14.i.us = icmp ugt i16 %44, %subtree.sroa.5.0.copyload.us
  %or.cond149.us = select i1 %or.cond.us, i1 true, i1 %cmp14.i.us
  %cmp21.i.us = icmp ult i16 %47, %subtree.sroa.2.0.copyload.us
  %or.cond150.us = select i1 %or.cond149.us, i1 true, i1 %cmp21.i.us
  %cmp28.i.us = icmp ugt i16 %45, %subtree.sroa.6.0.copyload.us
  %or.cond151.us = select i1 %or.cond150.us, i1 true, i1 %cmp28.i.us
  br i1 %or.cond151.us, label %for.inc111.us, label %_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_.exit.us

_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_.exit.us: ; preds = %for.body.us
  %subtree.sroa.3.0.arrayidx44.sroa_idx.us = getelementptr inbounds i8, ptr %arrayidx44.us, i64 4
  %subtree.sroa.3.0.copyload.us = load i16, ptr %subtree.sroa.3.0.arrayidx44.sroa_idx.us, align 4
  %cmp35.i.not.us = icmp ult i16 %37, %subtree.sroa.3.0.copyload.us
  br i1 %cmp35.i.not.us, label %for.inc111.us, label %if.then50.us

if.then50.us:                                     ; preds = %_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_.exit.us
  %add.us = add nsw i32 %subtree.sroa.8.0.copyload.us, %subtree.sroa.7.0.copyload.us
  %cmp52158.us = icmp sgt i32 %subtree.sroa.8.0.copyload.us, 0
  br i1 %cmp52158.us, label %while.body.us.us, label %for.inc111.us

for.inc111.us:                                    ; preds = %if.end109.us.us, %if.then50.us, %_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_.exit.us, %for.body.us
  %indvars.iv.next171 = add nuw nsw i64 %indvars.iv170, 1
  %exitcond174.not = icmp eq i64 %indvars.iv.next171, %wide.trip.count173
  br i1 %exitcond174.not, label %for.end113, label %for.body.us, !llvm.loop !5

while.body.us.us:                                 ; preds = %if.then50.us, %if.end109.us.us
  %curIndex.0159.us.us = phi i32 [ %curIndex.1.us.us, %if.end109.us.us ], [ %subtree.sroa.7.0.copyload.us, %if.then50.us ]
  %idxprom53.us.us = sext i32 %curIndex.0159.us.us to i64
  %arrayidx54.us.us = getelementptr inbounds %struct.b3QuantizedBvhNodeData, ptr %arrayidx36, i64 %idxprom53.us.us
  %48 = load <2 x i16>, ptr %arrayidx54.us.us, align 4
  %rootNode.sroa.4.0.arrayidx54.sroa_idx.us.us = getelementptr inbounds i8, ptr %arrayidx54.us.us, i64 6
  %rootNode.sroa.4.0.copyload.us.us = load i16, ptr %rootNode.sroa.4.0.arrayidx54.sroa_idx.us.us, align 2
  %rootNode.sroa.5.0.arrayidx54.sroa_idx.us.us = getelementptr inbounds i8, ptr %arrayidx54.us.us, i64 8
  %49 = load <2 x i16>, ptr %rootNode.sroa.5.0.arrayidx54.sroa_idx.us.us, align 4
  %rootNode.sroa.7.0.arrayidx54.sroa_idx.us.us = getelementptr inbounds i8, ptr %arrayidx54.us.us, i64 12
  %rootNode.sroa.7.0.copyload.us.us = load i32, ptr %rootNode.sroa.7.0.arrayidx54.sroa_idx.us.us, align 4
  %cmp.i91.us.us = icmp ugt i16 %15, %rootNode.sroa.4.0.copyload.us.us
  %50 = shufflevector <2 x i16> %49, <2 x i16> %48, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %51 = icmp ugt <4 x i16> %36, %50
  %52 = icmp ult <4 x i16> %36, %50
  %53 = shufflevector <4 x i1> %51, <4 x i1> %52, <4 x i32> <i32 0, i32 1, i32 6, i32 7>
  %54 = freeze <4 x i1> %53
  %55 = bitcast <4 x i1> %54 to i4
  %56 = icmp ne i4 %55, 0
  %op.rdx = or i1 %cmp.i91.us.us, %56
  br i1 %op.rdx, label %_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_.exit112.thread.us.us, label %_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_.exit112.us.us

_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_.exit112.us.us: ; preds = %while.body.us.us
  %rootNode.sroa.3.0.arrayidx54.sroa_idx.us.us = getelementptr inbounds i8, ptr %arrayidx54.us.us, i64 4
  %rootNode.sroa.3.0.copyload.us.us = load i16, ptr %rootNode.sroa.3.0.arrayidx54.sroa_idx.us.us, align 4
  %cmp35.i109.not.us.us = icmp ult i16 %37, %rootNode.sroa.3.0.copyload.us.us
  %cmp.i113.us.us = icmp sgt i32 %rootNode.sroa.7.0.copyload.us.us, -1
  br i1 %cmp35.i109.not.us.us, label %if.else101.us.us, label %if.then63.us.us

if.then63.us.us:                                  ; preds = %_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_.exit112.us.us
  br i1 %cmp.i113.us.us, label %if.then65.us.us, label %if.end99.us.us

if.then65.us.us:                                  ; preds = %if.then63.us.us
  %57 = load i32, ptr %arrayidx20, align 4
  %58 = load volatile i32, ptr %numConcavePairsOut, align 4
  %add.i115.us.us = add nsw i32 %58, %57
  store volatile i32 %add.i115.us.us, ptr %numConcavePairsOut, align 4
  %cmp73156.us.us = icmp sgt i32 %57, 0
  br i1 %cmp73156.us.us, label %for.body74.lr.ph.us.us, label %if.end99.us.us

if.end99.us.us:                                   ; preds = %for.inc.us.us, %if.then65.us.us, %if.then63.us.us
  %inc100.us.us = add nsw i32 %curIndex.0159.us.us, 1
  br label %if.end109.us.us

for.body74.us.us:                                 ; preds = %for.body74.lr.ph.us.us, %for.inc.us.us
  %indvars.iv164 = phi i64 [ 0, %for.body74.lr.ph.us.us ], [ %indvars.iv.next165, %for.inc.us.us ]
  %59 = add nsw i64 %indvars.iv164, %62
  %cmp76.us.us = icmp slt i64 %59, %43
  br i1 %cmp76.us.us, label %if.then77.us.us, label %for.inc.us.us

if.then77.us.us:                                  ; preds = %for.body74.us.us
  %60 = load i32, ptr %38, align 4
  %61 = trunc i64 %indvars.iv164 to i32
  %add80.us.us = add nsw i32 %60, %61
  %retval.sroa.5.8.insert.ext.i.us.us = zext i32 %add80.us.us to i64
  %retval.sroa.5.8.insert.shift.i.us.us = shl nuw i64 %retval.sroa.5.8.insert.ext.i.us.us, 32
  %retval.sroa.3.8.insert.insert.i.us.us = or disjoint i64 %retval.sroa.5.8.insert.shift.i.us.us, %retval.sroa.3.8.insert.ext.i.us.us
  %arrayidx85.us.us = getelementptr inbounds %struct.b3Int4, ptr %concavePairsOut, i64 %59
  store i64 %retval.sroa.0.0.insert.insert.i119, ptr %arrayidx85.us.us, align 16
  %newPair.sroa.2.0.arrayidx85.sroa_idx.us.us = getelementptr inbounds i8, ptr %arrayidx85.us.us, i64 8
  store i64 %retval.sroa.3.8.insert.insert.i.us.us, ptr %newPair.sroa.2.0.arrayidx85.sroa_idx.us.us, align 8
  br label %for.inc.us.us

for.inc.us.us:                                    ; preds = %if.then77.us.us, %for.body74.us.us
  %indvars.iv.next165 = add nuw nsw i64 %indvars.iv164, 1
  %exitcond169.not = icmp eq i64 %indvars.iv.next165, %wide.trip.count168
  br i1 %exitcond169.not, label %if.end99.us.us, label %for.body74.us.us, !llvm.loop !7

_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_.exit112.thread.us.us: ; preds = %while.body.us.us
  %cmp.i113145.us.us = icmp sgt i32 %rootNode.sroa.7.0.copyload.us.us, -1
  br i1 %cmp.i113145.us.us, label %if.then103.us.us, label %if.else105.us.us

if.else101.us.us:                                 ; preds = %_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_.exit112.us.us
  br i1 %cmp.i113.us.us, label %if.then103.us.us, label %if.else105.us.us

if.else105.us.us:                                 ; preds = %_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_.exit112.thread.us.us, %if.else101.us.us
  %add107.us.us = sub i32 %curIndex.0159.us.us, %rootNode.sroa.7.0.copyload.us.us
  br label %if.end109.us.us

if.then103.us.us:                                 ; preds = %_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_.exit112.thread.us.us, %if.else101.us.us
  %inc104.us.us = add nsw i32 %curIndex.0159.us.us, 1
  br label %if.end109.us.us

if.end109.us.us:                                  ; preds = %if.then103.us.us, %if.else105.us.us, %if.end99.us.us
  %curIndex.1.us.us = phi i32 [ %inc100.us.us, %if.end99.us.us ], [ %inc104.us.us, %if.then103.us.us ], [ %add107.us.us, %if.else105.us.us ]
  %cmp52.us.us = icmp slt i32 %curIndex.1.us.us, %add.us
  br i1 %cmp52.us.us, label %while.body.us.us, label %for.inc111.us, !llvm.loop !8

for.body74.lr.ph.us.us:                           ; preds = %if.then65.us.us
  %and2.i.us.us = and i32 %rootNode.sroa.7.0.copyload.us.us, 2097151
  %retval.sroa.3.8.insert.ext.i.us.us = zext nneg i32 %and2.i.us.us to i64
  %62 = sext i32 %58 to i64
  %wide.trip.count168 = zext nneg i32 %57 to i64
  br label %for.body74.us.us

for.body:                                         ; preds = %for.body.preheader, %for.inc111
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc111 ]
  %arrayidx44 = getelementptr inbounds %struct.b3BvhSubtreeInfoData, ptr %arrayidx34, i64 %indvars.iv
  %subtree.sroa.0.0.copyload = load i16, ptr %arrayidx44, align 4
  %subtree.sroa.2.0.arrayidx44.sroa_idx = getelementptr inbounds i8, ptr %arrayidx44, i64 2
  %subtree.sroa.2.0.copyload = load i16, ptr %subtree.sroa.2.0.arrayidx44.sroa_idx, align 2
  %subtree.sroa.4.0.arrayidx44.sroa_idx = getelementptr inbounds i8, ptr %arrayidx44, i64 6
  %subtree.sroa.4.0.copyload = load i16, ptr %subtree.sroa.4.0.arrayidx44.sroa_idx, align 2
  %subtree.sroa.5.0.arrayidx44.sroa_idx = getelementptr inbounds i8, ptr %arrayidx44, i64 8
  %subtree.sroa.5.0.copyload = load i16, ptr %subtree.sroa.5.0.arrayidx44.sroa_idx, align 4
  %subtree.sroa.6.0.arrayidx44.sroa_idx = getelementptr inbounds i8, ptr %arrayidx44, i64 10
  %subtree.sroa.6.0.copyload = load i16, ptr %subtree.sroa.6.0.arrayidx44.sroa_idx, align 2
  %subtree.sroa.7.0.arrayidx44.sroa_idx = getelementptr inbounds i8, ptr %arrayidx44, i64 12
  %subtree.sroa.7.0.copyload = load i32, ptr %subtree.sroa.7.0.arrayidx44.sroa_idx, align 4
  %subtree.sroa.8.0.arrayidx44.sroa_idx = getelementptr inbounds i8, ptr %arrayidx44, i64 16
  %subtree.sroa.8.0.copyload = load i32, ptr %subtree.sroa.8.0.arrayidx44.sroa_idx, align 4
  %cmp.i = icmp ugt i16 %15, %subtree.sroa.4.0.copyload
  %cmp7.i = icmp ult i16 %41, %subtree.sroa.0.0.copyload
  %or.cond = select i1 %cmp.i, i1 true, i1 %cmp7.i
  %cmp14.i = icmp ugt i16 %39, %subtree.sroa.5.0.copyload
  %or.cond149 = select i1 %or.cond, i1 true, i1 %cmp14.i
  %cmp21.i = icmp ult i16 %42, %subtree.sroa.2.0.copyload
  %or.cond150 = select i1 %or.cond149, i1 true, i1 %cmp21.i
  %cmp28.i = icmp ugt i16 %40, %subtree.sroa.6.0.copyload
  %or.cond151 = select i1 %or.cond150, i1 true, i1 %cmp28.i
  br i1 %or.cond151, label %for.inc111, label %_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_.exit

_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_.exit: ; preds = %for.body
  %subtree.sroa.3.0.arrayidx44.sroa_idx = getelementptr inbounds i8, ptr %arrayidx44, i64 4
  %subtree.sroa.3.0.copyload = load i16, ptr %subtree.sroa.3.0.arrayidx44.sroa_idx, align 4
  %cmp35.i.not = icmp ult i16 %37, %subtree.sroa.3.0.copyload
  br i1 %cmp35.i.not, label %for.inc111, label %if.then50

if.then50:                                        ; preds = %_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_.exit
  %add = add nsw i32 %subtree.sroa.8.0.copyload, %subtree.sroa.7.0.copyload
  %cmp52158 = icmp sgt i32 %subtree.sroa.8.0.copyload, 0
  br i1 %cmp52158, label %while.body, label %for.inc111

while.body:                                       ; preds = %if.then50, %if.end109
  %curIndex.0159 = phi i32 [ %curIndex.1, %if.end109 ], [ %subtree.sroa.7.0.copyload, %if.then50 ]
  %idxprom53 = sext i32 %curIndex.0159 to i64
  %arrayidx54 = getelementptr inbounds %struct.b3QuantizedBvhNodeData, ptr %arrayidx36, i64 %idxprom53
  %rootNode.sroa.0.0.copyload = load i16, ptr %arrayidx54, align 4
  %rootNode.sroa.2.0.arrayidx54.sroa_idx = getelementptr inbounds i8, ptr %arrayidx54, i64 2
  %rootNode.sroa.2.0.copyload = load i16, ptr %rootNode.sroa.2.0.arrayidx54.sroa_idx, align 2
  %rootNode.sroa.4.0.arrayidx54.sroa_idx = getelementptr inbounds i8, ptr %arrayidx54, i64 6
  %rootNode.sroa.4.0.copyload = load i16, ptr %rootNode.sroa.4.0.arrayidx54.sroa_idx, align 2
  %rootNode.sroa.5.0.arrayidx54.sroa_idx = getelementptr inbounds i8, ptr %arrayidx54, i64 8
  %rootNode.sroa.5.0.copyload = load i16, ptr %rootNode.sroa.5.0.arrayidx54.sroa_idx, align 4
  %rootNode.sroa.6.0.arrayidx54.sroa_idx = getelementptr inbounds i8, ptr %arrayidx54, i64 10
  %rootNode.sroa.6.0.copyload = load i16, ptr %rootNode.sroa.6.0.arrayidx54.sroa_idx, align 2
  %rootNode.sroa.7.0.arrayidx54.sroa_idx = getelementptr inbounds i8, ptr %arrayidx54, i64 12
  %rootNode.sroa.7.0.copyload = load i32, ptr %rootNode.sroa.7.0.arrayidx54.sroa_idx, align 4
  %cmp.i91 = icmp ugt i16 %15, %rootNode.sroa.4.0.copyload
  %cmp7.i93 = icmp ult i16 %41, %rootNode.sroa.0.0.copyload
  %or.cond152 = select i1 %cmp.i91, i1 true, i1 %cmp7.i93
  %cmp14.i97 = icmp ugt i16 %39, %rootNode.sroa.5.0.copyload
  %or.cond153 = select i1 %or.cond152, i1 true, i1 %cmp14.i97
  %cmp21.i101 = icmp ult i16 %42, %rootNode.sroa.2.0.copyload
  %or.cond154 = select i1 %or.cond153, i1 true, i1 %cmp21.i101
  %cmp28.i105 = icmp ugt i16 %40, %rootNode.sroa.6.0.copyload
  %or.cond155 = select i1 %or.cond154, i1 true, i1 %cmp28.i105
  br i1 %or.cond155, label %_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_.exit112.thread, label %_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_.exit112

_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_.exit112.thread: ; preds = %while.body
  %cmp.i113145 = icmp sgt i32 %rootNode.sroa.7.0.copyload, -1
  br i1 %cmp.i113145, label %if.then103, label %if.else105

_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_.exit112: ; preds = %while.body
  %rootNode.sroa.3.0.arrayidx54.sroa_idx = getelementptr inbounds i8, ptr %arrayidx54, i64 4
  %rootNode.sroa.3.0.copyload = load i16, ptr %rootNode.sroa.3.0.arrayidx54.sroa_idx, align 4
  %cmp35.i109.not = icmp ult i16 %37, %rootNode.sroa.3.0.copyload
  %cmp.i113 = icmp sgt i32 %rootNode.sroa.7.0.copyload, -1
  br i1 %cmp35.i109.not, label %if.else101, label %if.then63

if.then63:                                        ; preds = %_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_.exit112
  br i1 %cmp.i113, label %if.then65, label %if.end99

if.then65:                                        ; preds = %if.then63
  %63 = load volatile i32, ptr %numConcavePairsOut, align 4
  %inc88 = add nsw i32 %63, 1
  store volatile i32 %inc88, ptr %numConcavePairsOut, align 4
  %cmp89 = icmp slt i32 %63, %maxNumConcavePairsCapacity
  br i1 %cmp89, label %if.then90, label %if.end99

if.then90:                                        ; preds = %if.then65
  %and2.i = and i32 %rootNode.sroa.7.0.copyload, 2097151
  %retval.sroa.3.8.insert.ext.i121 = zext nneg i32 %and2.i to i64
  %idxprom95 = sext i32 %63 to i64
  %arrayidx96 = getelementptr inbounds %struct.b3Int4, ptr %concavePairsOut, i64 %idxprom95
  store i64 %retval.sroa.0.0.insert.insert.i119, ptr %arrayidx96, align 16
  %newPair91.sroa.2.0.arrayidx96.sroa_idx = getelementptr inbounds i8, ptr %arrayidx96, i64 8
  store i64 %retval.sroa.3.8.insert.ext.i121, ptr %newPair91.sroa.2.0.arrayidx96.sroa_idx, align 8
  br label %if.end99

if.end99:                                         ; preds = %if.then90, %if.then65, %if.then63
  %inc100 = add nsw i32 %curIndex.0159, 1
  br label %if.end109

if.else101:                                       ; preds = %_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_.exit112
  br i1 %cmp.i113, label %if.then103, label %if.else105

if.then103:                                       ; preds = %_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_.exit112.thread, %if.else101
  %inc104 = add nsw i32 %curIndex.0159, 1
  br label %if.end109

if.else105:                                       ; preds = %_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_.exit112.thread, %if.else101
  %add107 = sub i32 %curIndex.0159, %rootNode.sroa.7.0.copyload
  br label %if.end109

if.end109:                                        ; preds = %if.then103, %if.else105, %if.end99
  %curIndex.1 = phi i32 [ %inc100, %if.end99 ], [ %inc104, %if.then103 ], [ %add107, %if.else105 ]
  %cmp52 = icmp slt i32 %curIndex.1, %add
  br i1 %cmp52, label %while.body, label %for.inc111, !llvm.loop !8

for.inc111:                                       ; preds = %if.end109, %if.then50, %for.body, %_Z43b3TestQuantizedAabbAgainstQuantizedAabbSlowPKtS0_S0_S0_.exit
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end113, label %for.body, !llvm.loop !5

for.end113:                                       ; preds = %for.inc111, %for.inc111.us, %if.end28, %if.end18, %if.end, %land.lhs.true
  ret void
}

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #1

; Function Attrs: mustprogress nofree nosync nounwind memory(argmem: readwrite) uwtable
define dso_local noundef zeroext i1 @_Z20b3FindSeparatingAxisPK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_Pf(ptr nocapture noundef readonly %hullA, ptr nocapture noundef readonly %hullB, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %posA1, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %ornA, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %posB1, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %ornB, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %DeltaC2, ptr nocapture noundef readonly %verticesA, ptr nocapture readnone %uniqueEdgesA, ptr nocapture noundef readonly %facesA, ptr nocapture readnone %indicesA, ptr nocapture noundef readonly %verticesB, ptr nocapture readnone %uniqueEdgesB, ptr nocapture readnone %facesB, ptr nocapture readnone %indicesB, ptr nocapture noundef %sep, ptr nocapture noundef %dmin) local_unnamed_addr #2 {
entry:
  %posA.sroa.0.0.copyload = load float, ptr %posA1, align 16
  %posA.sroa.2.0.posA1.sroa_idx = getelementptr inbounds i8, ptr %posA1, i64 4
  %posA.sroa.2.0.copyload = load float, ptr %posA.sroa.2.0.posA1.sroa_idx, align 4
  %posA.sroa.3.0.posA1.sroa_idx = getelementptr inbounds i8, ptr %posA1, i64 8
  %posA.sroa.3.0.copyload = load float, ptr %posA.sroa.3.0.posA1.sroa_idx, align 8
  %posB.sroa.0.0.copyload = load float, ptr %posB1, align 16
  %posB.sroa.2.0.posB1.sroa_idx = getelementptr inbounds i8, ptr %posB1, i64 4
  %posB.sroa.2.0.copyload = load float, ptr %posB.sroa.2.0.posB1.sroa_idx, align 4
  %posB.sroa.3.0.posB1.sroa_idx = getelementptr inbounds i8, ptr %posB1, i64 8
  %posB.sroa.3.0.copyload = load float, ptr %posB.sroa.3.0.posB1.sroa_idx, align 8
  %m_numFaces = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 6
  %0 = load i32, ptr %m_numFaces, align 8
  %cmp115 = icmp slt i32 %0, 1
  br i1 %cmp115, label %for.end, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %entry
  %m_faceOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 5
  %arrayidx.i.i.i = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 3
  %arrayidx.i23.i.i = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 1
  %arrayidx3.i.i = getelementptr inbounds [4 x float], ptr %DeltaC2, i64 0, i64 1
  %arrayidx6.i.i = getelementptr inbounds [4 x float], ptr %DeltaC2, i64 0, i64 2
  %m_numVertices.i27 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 7
  %m_vertexOffset.i54 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 8
  %m_numVertices.i = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullB, i64 0, i32 7
  %arrayidx3.i.i.i = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 1
  %arrayidx6.i.i.i = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 2
  %arrayidx8.i.i.i = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 3
  %m_vertexOffset.i = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullB, i64 0, i32 8
  %faceANormalWS.sroa.12.0.sep.sroa_idx = getelementptr inbounds i8, ptr %sep, i64 8
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %cmp117 = phi i1 [ false, %for.body.lr.ph ], [ %cmp, %for.inc ]
  %i.0116 = phi i32 [ 0, %for.body.lr.ph ], [ %inc12, %for.inc ]
  %1 = load i32, ptr %m_faceOffset, align 4
  %add = add nsw i32 %1, %i.0116
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr inbounds %struct.b3GpuFace, ptr %facesA, i64 %idxprom
  %normal.sroa.3.0.arrayidx.sroa_idx = getelementptr inbounds i8, ptr %arrayidx, i64 8
  %normal.sroa.3.0.copyload = load float, ptr %normal.sroa.3.0.arrayidx.sroa_idx, align 8
  %2 = load float, ptr %arrayidx.i.i.i, align 4
  %3 = load float, ptr %ornA, align 16
  %neg15.i.i = fneg float %3
  %4 = load <2 x float>, ptr %arrayidx, align 16
  %5 = load <2 x float>, ptr %arrayidx.i23.i.i, align 4
  %6 = extractelement <2 x float> %5, i64 1
  %7 = extractelement <2 x float> %4, i64 0
  %mul12.i.i = fmul float %7, %6
  %8 = extractelement <2 x float> %4, i64 1
  %9 = tail call float @llvm.fmuladd.f32(float %2, float %8, float %mul12.i.i)
  %10 = tail call float @llvm.fmuladd.f32(float %neg15.i.i, float %normal.sroa.3.0.copyload, float %9)
  %11 = insertelement <2 x float> %4, float %normal.sroa.3.0.copyload, i64 0
  %12 = insertelement <2 x float> %5, float %3, i64 1
  %13 = fmul <2 x float> %11, %12
  %14 = insertelement <2 x float> poison, float %2, i64 0
  %15 = shufflevector <2 x float> %14, <2 x float> poison, <2 x i32> zeroinitializer
  %16 = insertelement <2 x float> %4, float %normal.sroa.3.0.copyload, i64 1
  %17 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %15, <2 x float> %16, <2 x float> %13)
  %18 = shufflevector <2 x float> %17, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %19 = fneg <2 x float> %5
  %20 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %19, <2 x float> %4, <2 x float> %18)
  %21 = extractelement <2 x float> %19, i64 0
  %neg31.i.i = fmul float %8, %21
  %22 = tail call float @llvm.fmuladd.f32(float %neg15.i.i, float %7, float %neg31.i.i)
  %23 = extractelement <2 x float> %19, i64 1
  %24 = tail call float @llvm.fmuladd.f32(float %23, float %normal.sroa.3.0.copyload, float %22)
  %25 = shufflevector <2 x float> %20, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %26 = insertelement <2 x float> %25, float %10, i64 1
  %27 = fmul <2 x float> %15, %26
  %28 = insertelement <2 x float> poison, float %24, i64 0
  %29 = shufflevector <2 x float> %28, <2 x float> poison, <2 x i32> zeroinitializer
  %30 = shufflevector <2 x float> %19, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %31 = insertelement <2 x float> %30, float %neg15.i.i, i64 0
  %32 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %29, <2 x float> %31, <2 x float> %27)
  %33 = shufflevector <2 x float> %26, <2 x float> %20, <2 x i32> <i32 1, i32 2>
  %34 = shufflevector <2 x float> %19, <2 x float> %31, <2 x i32> <i32 1, i32 2>
  %35 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %33, <2 x float> %34, <2 x float> %32)
  %36 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %20, <2 x float> %5, <2 x float> %35)
  %37 = extractelement <2 x float> %20, i64 0
  %mul25.i.i = fmul float %2, %37
  %38 = tail call float @llvm.fmuladd.f32(float %24, float %23, float %mul25.i.i)
  %39 = extractelement <2 x float> %20, i64 1
  %40 = tail call float @llvm.fmuladd.f32(float %39, float %21, float %38)
  %41 = tail call float @llvm.fmuladd.f32(float %10, float %3, float %40)
  %retval.sroa.3.12.vec.insert.i16.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %41, i64 0
  %42 = load float, ptr %DeltaC2, align 16
  %43 = load float, ptr %arrayidx3.i.i, align 4
  %44 = extractelement <2 x float> %36, i64 1
  %mul5.i.i = fmul float %43, %44
  %45 = extractelement <2 x float> %36, i64 0
  %46 = tail call float @llvm.fmuladd.f32(float %42, float %45, float %mul5.i.i)
  %47 = load float, ptr %arrayidx6.i.i, align 8
  %48 = tail call noundef float @llvm.fmuladd.f32(float %47, float %41, float %46)
  %cmp4 = fcmp olt float %48, 0.000000e+00
  %49 = fneg <2 x float> %36
  %mul5.i = fneg float %41
  %faceANormalWS.sroa.12.8.vec.insert = insertelement <2 x float> %retval.sroa.3.12.vec.insert.i16.i, float %mul5.i, i64 0
  %faceANormalWS.sroa.12.0 = select i1 %cmp4, <2 x float> %faceANormalWS.sroa.12.8.vec.insert, <2 x float> %retval.sroa.3.12.vec.insert.i16.i
  %faceANormalWS.sroa.0.0 = select i1 %cmp4, <2 x float> %49, <2 x float> %36
  %50 = load i32, ptr %m_numVertices.i27, align 4
  %faceANormalWS.sroa.0.0.vec.extract81 = extractelement <2 x float> %faceANormalWS.sroa.0.0, i64 0
  %faceANormalWS.sroa.12.8.vec.extract95 = extractelement <2 x float> %faceANormalWS.sroa.12.0, i64 0
  %51 = fmul <2 x float> %faceANormalWS.sroa.12.0, %19
  %mul4.i.i.i35 = extractelement <2 x float> %51, i64 0
  %52 = tail call float @llvm.fmuladd.f32(float %2, float %faceANormalWS.sroa.0.0.vec.extract81, float %mul4.i.i.i35)
  %faceANormalWS.sroa.0.4.vec.extract88 = extractelement <2 x float> %faceANormalWS.sroa.0.0, i64 1
  %53 = tail call float @llvm.fmuladd.f32(float %6, float %faceANormalWS.sroa.0.4.vec.extract88, float %52)
  %mul12.i.i.i37 = fmul float %faceANormalWS.sroa.0.0.vec.extract81, %23
  %54 = tail call float @llvm.fmuladd.f32(float %2, float %faceANormalWS.sroa.0.4.vec.extract88, float %mul12.i.i.i37)
  %55 = tail call float @llvm.fmuladd.f32(float %3, float %faceANormalWS.sroa.12.8.vec.extract95, float %54)
  %mul21.i.i.i38 = fmul float %faceANormalWS.sroa.0.4.vec.extract88, %neg15.i.i
  %56 = tail call float @llvm.fmuladd.f32(float %2, float %faceANormalWS.sroa.12.8.vec.extract95, float %mul21.i.i.i38)
  %57 = extractelement <2 x float> %5, i64 0
  %58 = tail call float @llvm.fmuladd.f32(float %57, float %faceANormalWS.sroa.0.0.vec.extract81, float %56)
  %neg31.i.i.i39 = fmul float %57, %faceANormalWS.sroa.0.4.vec.extract88
  %59 = tail call float @llvm.fmuladd.f32(float %3, float %faceANormalWS.sroa.0.0.vec.extract81, float %neg31.i.i.i39)
  %60 = tail call float @llvm.fmuladd.f32(float %6, float %faceANormalWS.sroa.12.8.vec.extract95, float %59)
  %mul4.i9.i.i40 = fmul float %2, %53
  %61 = tail call float @llvm.fmuladd.f32(float %60, float %3, float %mul4.i9.i.i40)
  %62 = tail call float @llvm.fmuladd.f32(float %55, float %6, float %61)
  %63 = tail call float @llvm.fmuladd.f32(float %58, float %21, float %62)
  %mul14.i.i.i41 = fmul float %2, %55
  %64 = tail call float @llvm.fmuladd.f32(float %60, float %57, float %mul14.i.i.i41)
  %65 = tail call float @llvm.fmuladd.f32(float %58, float %3, float %64)
  %66 = tail call float @llvm.fmuladd.f32(float %53, float %23, float %65)
  %mul25.i.i.i42 = fmul float %2, %58
  %67 = tail call float @llvm.fmuladd.f32(float %60, float %6, float %mul25.i.i.i42)
  %68 = tail call float @llvm.fmuladd.f32(float %53, float %57, float %67)
  %69 = tail call float @llvm.fmuladd.f32(float %55, float %neg15.i.i, float %68)
  %cmp29.i45 = icmp sgt i32 %50, 0
  br i1 %cmp29.i45, label %for.body.lr.ph.i53, label %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit72

for.body.lr.ph.i53:                               ; preds = %for.body
  %70 = load i32, ptr %m_vertexOffset.i54, align 16
  %71 = sext i32 %70 to i64
  %72 = zext nneg i32 %50 to i64
  %invariant.gep = getelementptr %class.b3Vector3, ptr %verticesA, i64 %71
  br label %for.body.i55

for.body.i55:                                     ; preds = %for.body.i55, %for.body.lr.ph.i53
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body.i55 ], [ 0, %for.body.lr.ph.i53 ]
  %Max0.i.0 = phi float [ %Max0.i.1, %for.body.i55 ], [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i53 ]
  %Min0.i.0 = phi float [ %Min0.i.1, %for.body.i55 ], [ 0x47EFFFFFE0000000, %for.body.lr.ph.i53 ]
  %73 = phi float [ %80, %for.body.i55 ], [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i53 ]
  %gep = getelementptr %class.b3Vector3, ptr %invariant.gep, i64 %indvars.iv
  %74 = load float, ptr %gep, align 16
  %arrayidx3.i.i24.i60 = getelementptr inbounds [4 x float], ptr %gep, i64 0, i64 1
  %75 = load float, ptr %arrayidx3.i.i24.i60, align 4
  %mul5.i.i26.i61 = fmul float %66, %75
  %76 = tail call float @llvm.fmuladd.f32(float %74, float %63, float %mul5.i.i26.i61)
  %arrayidx6.i.i27.i62 = getelementptr inbounds [4 x float], ptr %gep, i64 0, i64 2
  %77 = load float, ptr %arrayidx6.i.i27.i62, align 8
  %78 = tail call noundef float @llvm.fmuladd.f32(float %77, float %69, float %76)
  %cmp11.i63 = fcmp olt float %78, %Min0.i.0
  %Min0.i.1 = select i1 %cmp11.i63, float %78, float %Min0.i.0
  %79 = select i1 %cmp11.i63, float %Max0.i.0, float %73
  %cmp14.i65 = fcmp ogt float %78, %79
  %Max0.i.1 = select i1 %cmp14.i65, float %78, float %Max0.i.0
  %80 = select i1 %cmp14.i65, float %78, float %79
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not.i68 = icmp eq i64 %indvars.iv.next, %72
  br i1 %exitcond.not.i68, label %for.end.i46, label %for.body.i55, !llvm.loop !9

for.end.i46:                                      ; preds = %for.body.i55
  %cmp20.i47 = fcmp ogt float %Min0.i.1, %80
  br i1 %cmp20.i47, label %if.then21.i51, label %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit72

if.then21.i51:                                    ; preds = %for.end.i46
  br label %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit72

_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit72: ; preds = %for.body, %for.end.i46, %if.then21.i51
  %Max0.i.3 = phi float [ %Max0.i.1, %for.end.i46 ], [ %Min0.i.1, %if.then21.i51 ], [ 0x47EFFFFFE0000000, %for.body ]
  %81 = phi float [ %Min0.i.1, %for.end.i46 ], [ %80, %if.then21.i51 ], [ 0xC7EFFFFFE0000000, %for.body ]
  %mul5.i.i.i48 = fmul float %posA.sroa.2.0.copyload, %faceANormalWS.sroa.0.4.vec.extract88
  %82 = tail call float @llvm.fmuladd.f32(float %posA.sroa.0.0.copyload, float %faceANormalWS.sroa.0.0.vec.extract81, float %mul5.i.i.i48)
  %83 = tail call noundef float @llvm.fmuladd.f32(float %posA.sroa.3.0.copyload, float %faceANormalWS.sroa.12.8.vec.extract95, float %82)
  %add28.i49 = fadd float %83, %81
  %add30.i50 = fadd float %83, %Max0.i.3
  %84 = load i32, ptr %m_numVertices.i, align 4
  %85 = load float, ptr %ornB, align 16
  %fneg.i.i.i = fneg float %85
  %86 = load float, ptr %arrayidx3.i.i.i, align 4
  %fneg4.i.i.i = fneg float %86
  %87 = load float, ptr %arrayidx6.i.i.i, align 8
  %fneg7.i.i.i = fneg float %87
  %88 = load float, ptr %arrayidx8.i.i.i, align 4
  %mul4.i.i.i = fmul float %faceANormalWS.sroa.12.8.vec.extract95, %fneg4.i.i.i
  %89 = tail call float @llvm.fmuladd.f32(float %88, float %faceANormalWS.sroa.0.0.vec.extract81, float %mul4.i.i.i)
  %90 = tail call float @llvm.fmuladd.f32(float %87, float %faceANormalWS.sroa.0.4.vec.extract88, float %89)
  %mul12.i.i.i = fmul float %faceANormalWS.sroa.0.0.vec.extract81, %fneg7.i.i.i
  %91 = tail call float @llvm.fmuladd.f32(float %88, float %faceANormalWS.sroa.0.4.vec.extract88, float %mul12.i.i.i)
  %92 = tail call float @llvm.fmuladd.f32(float %85, float %faceANormalWS.sroa.12.8.vec.extract95, float %91)
  %mul21.i.i.i = fmul float %faceANormalWS.sroa.0.4.vec.extract88, %fneg.i.i.i
  %93 = tail call float @llvm.fmuladd.f32(float %88, float %faceANormalWS.sroa.12.8.vec.extract95, float %mul21.i.i.i)
  %94 = tail call float @llvm.fmuladd.f32(float %86, float %faceANormalWS.sroa.0.0.vec.extract81, float %93)
  %neg31.i.i.i = fmul float %faceANormalWS.sroa.0.4.vec.extract88, %86
  %95 = tail call float @llvm.fmuladd.f32(float %85, float %faceANormalWS.sroa.0.0.vec.extract81, float %neg31.i.i.i)
  %96 = tail call float @llvm.fmuladd.f32(float %87, float %faceANormalWS.sroa.12.8.vec.extract95, float %95)
  %mul4.i9.i.i = fmul float %88, %90
  %97 = tail call float @llvm.fmuladd.f32(float %96, float %85, float %mul4.i9.i.i)
  %98 = tail call float @llvm.fmuladd.f32(float %92, float %87, float %97)
  %99 = tail call float @llvm.fmuladd.f32(float %94, float %fneg4.i.i.i, float %98)
  %mul14.i.i.i = fmul float %88, %92
  %100 = tail call float @llvm.fmuladd.f32(float %96, float %86, float %mul14.i.i.i)
  %101 = tail call float @llvm.fmuladd.f32(float %94, float %85, float %100)
  %102 = tail call float @llvm.fmuladd.f32(float %90, float %fneg7.i.i.i, float %101)
  %mul25.i.i.i = fmul float %88, %94
  %103 = tail call float @llvm.fmuladd.f32(float %96, float %87, float %mul25.i.i.i)
  %104 = tail call float @llvm.fmuladd.f32(float %90, float %86, float %103)
  %105 = tail call float @llvm.fmuladd.f32(float %92, float %fneg.i.i.i, float %104)
  %cmp29.i = icmp sgt i32 %84, 0
  br i1 %cmp29.i, label %for.body.lr.ph.i, label %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit

for.body.lr.ph.i:                                 ; preds = %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit72
  %106 = load i32, ptr %m_vertexOffset.i, align 16
  %107 = sext i32 %106 to i64
  %108 = zext nneg i32 %84 to i64
  %invariant.gep130 = getelementptr %class.b3Vector3, ptr %verticesB, i64 %107
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %for.body.lr.ph.i
  %indvars.iv123 = phi i64 [ %indvars.iv.next124, %for.body.i ], [ 0, %for.body.lr.ph.i ]
  %Max1.i.0 = phi float [ %Max1.i.1, %for.body.i ], [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i ]
  %Min1.i.0 = phi float [ %Min1.i.1, %for.body.i ], [ 0x47EFFFFFE0000000, %for.body.lr.ph.i ]
  %109 = phi float [ %116, %for.body.i ], [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i ]
  %gep131 = getelementptr %class.b3Vector3, ptr %invariant.gep130, i64 %indvars.iv123
  %110 = load float, ptr %gep131, align 16
  %arrayidx3.i.i24.i = getelementptr inbounds [4 x float], ptr %gep131, i64 0, i64 1
  %111 = load float, ptr %arrayidx3.i.i24.i, align 4
  %mul5.i.i26.i = fmul float %102, %111
  %112 = tail call float @llvm.fmuladd.f32(float %110, float %99, float %mul5.i.i26.i)
  %arrayidx6.i.i27.i = getelementptr inbounds [4 x float], ptr %gep131, i64 0, i64 2
  %113 = load float, ptr %arrayidx6.i.i27.i, align 8
  %114 = tail call noundef float @llvm.fmuladd.f32(float %113, float %105, float %112)
  %cmp11.i = fcmp olt float %114, %Min1.i.0
  %Min1.i.1 = select i1 %cmp11.i, float %114, float %Min1.i.0
  %115 = select i1 %cmp11.i, float %Max1.i.0, float %109
  %cmp14.i = fcmp ogt float %114, %115
  %Max1.i.1 = select i1 %cmp14.i, float %114, float %Max1.i.0
  %116 = select i1 %cmp14.i, float %114, float %115
  %indvars.iv.next124 = add nuw nsw i64 %indvars.iv123, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next124, %108
  br i1 %exitcond.not.i, label %for.end.i, label %for.body.i, !llvm.loop !9

for.end.i:                                        ; preds = %for.body.i
  %cmp20.i = fcmp ogt float %Min1.i.1, %116
  br i1 %cmp20.i, label %if.then21.i, label %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit

if.then21.i:                                      ; preds = %for.end.i
  br label %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit

_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit: ; preds = %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit72, %for.end.i, %if.then21.i
  %Max1.i.3 = phi float [ %Max1.i.1, %for.end.i ], [ %Min1.i.1, %if.then21.i ], [ 0x47EFFFFFE0000000, %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit72 ]
  %117 = phi float [ %Min1.i.1, %for.end.i ], [ %116, %if.then21.i ], [ 0xC7EFFFFFE0000000, %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit72 ]
  %mul5.i.i.i = fmul float %posB.sroa.2.0.copyload, %faceANormalWS.sroa.0.4.vec.extract88
  %118 = tail call float @llvm.fmuladd.f32(float %posB.sroa.0.0.copyload, float %faceANormalWS.sroa.0.0.vec.extract81, float %mul5.i.i.i)
  %119 = tail call noundef float @llvm.fmuladd.f32(float %posB.sroa.3.0.copyload, float %faceANormalWS.sroa.12.8.vec.extract95, float %118)
  %add28.i = fadd float %119, %117
  %add30.i = fadd float %119, %Max1.i.3
  %cmp.i = fcmp olt float %add30.i50, %add28.i
  %cmp1.i = fcmp olt float %add30.i, %add28.i49
  %or.cond = select i1 %cmp.i, i1 true, i1 %cmp1.i
  br i1 %or.cond, label %return, label %if.end8

if.end8:                                          ; preds = %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit
  %sub.i = fsub float %add30.i50, %add28.i
  %sub2.i = fsub float %add30.i, %add28.i49
  %cmp3.i = fcmp olt float %sub.i, %sub2.i
  %cond.i = select i1 %cmp3.i, float %sub.i, float %sub2.i
  %120 = load float, ptr %dmin, align 4
  %cmp9 = fcmp olt float %cond.i, %120
  br i1 %cmp9, label %if.then10, label %for.inc

if.then10:                                        ; preds = %if.end8
  store float %cond.i, ptr %dmin, align 4
  store <2 x float> %faceANormalWS.sroa.0.0, ptr %sep, align 16
  store <2 x float> %faceANormalWS.sroa.12.0, ptr %faceANormalWS.sroa.12.0.sep.sroa_idx, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end8, %if.then10
  %inc12 = add nuw nsw i32 %i.0116, 1
  %cmp = icmp sge i32 %inc12, %0
  %exitcond = icmp eq i32 %inc12, %0
  br i1 %exitcond, label %for.end, label %for.body, !llvm.loop !10

for.end:                                          ; preds = %for.inc, %entry
  %cmp.lcssa = phi i1 [ true, %entry ], [ %cmp, %for.inc ]
  %121 = load float, ptr %DeltaC2, align 16
  %fneg.i = fneg float %121
  %arrayidx1.i = getelementptr inbounds [4 x float], ptr %DeltaC2, i64 0, i64 1
  %122 = load float, ptr %arrayidx1.i, align 4
  %fneg2.i = fneg float %122
  %arrayidx3.i = getelementptr inbounds [4 x float], ptr %DeltaC2, i64 0, i64 2
  %123 = load float, ptr %arrayidx3.i, align 8
  %fneg4.i = fneg float %123
  %124 = load <2 x float>, ptr %sep, align 16
  %125 = extractelement <2 x float> %124, i64 1
  %mul5.i.i13 = fmul float %125, %fneg2.i
  %126 = extractelement <2 x float> %124, i64 0
  %127 = tail call float @llvm.fmuladd.f32(float %fneg.i, float %126, float %mul5.i.i13)
  %arrayidx7.i.i15 = getelementptr inbounds [4 x float], ptr %sep, i64 0, i64 2
  %128 = load float, ptr %arrayidx7.i.i15, align 8
  %129 = tail call noundef float @llvm.fmuladd.f32(float %fneg4.i, float %128, float %127)
  %cmp18 = fcmp ogt float %129, 0.000000e+00
  br i1 %cmp18, label %if.then19, label %return

if.then19:                                        ; preds = %for.end
  %130 = fneg <2 x float> %124
  %fneg4.i20 = fneg float %128
  %retval.sroa.3.12.vec.insert.i.i23 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %fneg4.i20, i64 0
  store <2 x float> %130, ptr %sep, align 16
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i23, ptr %arrayidx7.i.i15, align 8
  br label %return

return:                                           ; preds = %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit, %for.end, %if.then19
  %cmp114 = phi i1 [ %cmp.lcssa, %for.end ], [ %cmp.lcssa, %if.then19 ], [ %cmp117, %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit ]
  ret i1 %cmp114
}

; Function Attrs: mustprogress nofree nounwind uwtable
define dso_local noundef zeroext i1 @_Z28b3FindSeparatingAxisEdgeEdgePK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_Pfb(ptr nocapture noundef readonly %hullA, ptr nocapture noundef readonly %hullB, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %posA1, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %ornA, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %posB1, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %ornB, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %DeltaC2, ptr nocapture noundef readonly %verticesA, ptr nocapture noundef readonly %uniqueEdgesA, ptr nocapture readnone %facesA, ptr nocapture readnone %indicesA, ptr nocapture noundef readonly %verticesB, ptr nocapture noundef readonly %uniqueEdgesB, ptr nocapture readnone %facesB, ptr nocapture readnone %indicesB, ptr nocapture noundef %sep, ptr nocapture noundef %dmin, i1 noundef zeroext %searchAllEdgeEdge) local_unnamed_addr #3 {
entry:
  %posA.sroa.0.0.copyload = load float, ptr %posA1, align 16
  %posA.sroa.3.0.posA1.sroa_idx = getelementptr inbounds i8, ptr %posA1, i64 4
  %posA.sroa.3.0.copyload = load float, ptr %posA.sroa.3.0.posA1.sroa_idx, align 4
  %posA.sroa.5.0.posA1.sroa_idx = getelementptr inbounds i8, ptr %posA1, i64 8
  %posA.sroa.5.0.copyload = load float, ptr %posA.sroa.5.0.posA1.sroa_idx, align 8
  %posB.sroa.0.0.copyload = load float, ptr %posB1, align 16
  %posB.sroa.3.0.posB1.sroa_idx = getelementptr inbounds i8, ptr %posB1, i64 4
  %posB.sroa.3.0.copyload = load float, ptr %posB.sroa.3.0.posB1.sroa_idx, align 4
  %posB.sroa.5.0.posB1.sroa_idx = getelementptr inbounds i8, ptr %posB1, i64 8
  %posB.sroa.5.0.copyload = load float, ptr %posB.sroa.5.0.posB1.sroa_idx, align 8
  %m_numUniqueEdges = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 10
  %0 = load i32, ptr %m_numUniqueEdges, align 8
  %m_numUniqueEdges2 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullB, i64 0, i32 10
  %1 = load i32, ptr %m_numUniqueEdges2, align 8
  %mul = mul nsw i32 %1, %0
  %2 = load i32, ptr @_ZZ28b3FindSeparatingAxisEdgeEdgePK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_PfbE12maxEdgeTests, align 4
  %cmp = icmp sgt i32 %mul, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 %mul, ptr @_ZZ28b3FindSeparatingAxisEdgeEdgePK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_PfbE12maxEdgeTests, align 4
  %call = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %mul)
  %3 = load i32, ptr %m_numUniqueEdges, align 8
  %call4 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i32 noundef %3)
  %4 = load i32, ptr %m_numUniqueEdges2, align 8
  %call6 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.2, i32 noundef %4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br i1 %searchAllEdgeEdge, label %for.cond.preheader, label %for.cond51.preheader

for.cond51.preheader:                             ; preds = %if.end
  %m_numVertices.i115 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 7
  %arrayidx3.i.i.i117 = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 1
  %arrayidx6.i.i.i119 = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 2
  %arrayidx8.i.i.i121 = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 3
  %m_numVertices.i161 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullB, i64 0, i32 7
  %arrayidx3.i.i.i163 = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 1
  %arrayidx6.i.i.i165 = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 2
  %arrayidx8.i.i.i167 = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 3
  %m_vertexOffset.i142 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 8
  %m_vertexOffset.i188 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullB, i64 0, i32 8
  br label %for.body53

for.cond.preheader:                               ; preds = %if.end
  %5 = load i32, ptr %m_numUniqueEdges, align 8
  %cmp9310 = icmp sgt i32 %5, 0
  br i1 %cmp9310, label %for.body.lr.ph, label %if.end83

for.body.lr.ph:                                   ; preds = %for.cond.preheader
  %m_uniqueEdgesOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 9
  %arrayidx.i.i.i = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 3
  %arrayidx.i23.i.i = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 1
  %arrayidx.i25.i.i = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 2
  %m_uniqueEdgesOffset16 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullB, i64 0, i32 9
  %arrayidx.i.i.i45 = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 3
  %arrayidx.i25.i.i49 = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 2
  %arrayidx3.i.i66 = getelementptr inbounds [4 x float], ptr %DeltaC2, i64 0, i64 1
  %arrayidx6.i.i = getelementptr inbounds [4 x float], ptr %DeltaC2, i64 0, i64 2
  %m_numVertices.i = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 7
  %m_vertexOffset.i = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 8
  %m_numVertices.i69 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullB, i64 0, i32 7
  %m_vertexOffset.i96 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullB, i64 0, i32 8
  %crossje.sroa.17.0.sep.sroa_idx = getelementptr inbounds i8, ptr %sep, i64 8
  %.pre = load i32, ptr %m_numUniqueEdges2, align 8
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc48
  %6 = phi i32 [ %5, %for.body.lr.ph ], [ %199, %for.inc48 ]
  %7 = phi i32 [ %.pre, %for.body.lr.ph ], [ %200, %for.inc48 ]
  %8 = phi i32 [ %.pre, %for.body.lr.ph ], [ %201, %for.inc48 ]
  %e0.0311 = phi i32 [ 0, %for.body.lr.ph ], [ %inc49, %for.inc48 ]
  %9 = load i32, ptr %m_uniqueEdgesOffset, align 4
  %add = add nsw i32 %9, %e0.0311
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr inbounds %class.b3Vector3, ptr %uniqueEdgesA, i64 %idxprom
  %edge0.sroa.0.0.copyload = load float, ptr %arrayidx, align 16
  %edge0.sroa.2.0.arrayidx.sroa_idx = getelementptr inbounds i8, ptr %arrayidx, i64 4
  %10 = load float, ptr %arrayidx.i.i.i, align 4
  %11 = load float, ptr %ornA, align 16
  %12 = load <2 x float>, ptr %edge0.sroa.2.0.arrayidx.sroa_idx, align 4
  %13 = shufflevector <2 x float> %12, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %14 = load <2 x float>, ptr %arrayidx.i23.i.i, align 4
  %15 = shufflevector <2 x float> %14, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %16 = insertelement <2 x float> %12, float %edge0.sroa.0.0.copyload, i64 0
  %17 = fmul <2 x float> %16, %15
  %18 = insertelement <2 x float> poison, float %10, i64 0
  %19 = shufflevector <2 x float> %18, <2 x float> poison, <2 x i32> zeroinitializer
  %20 = insertelement <2 x float> %12, float %edge0.sroa.0.0.copyload, i64 1
  %21 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %19, <2 x float> %20, <2 x float> %17)
  %22 = insertelement <2 x float> %14, float %11, i64 0
  %23 = fneg <2 x float> %22
  %24 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %23, <2 x float> %13, <2 x float> %21)
  %25 = extractelement <2 x float> %12, i64 0
  %mul21.i.i = fmul float %25, %11
  %26 = extractelement <2 x float> %12, i64 1
  %27 = tail call float @llvm.fmuladd.f32(float %10, float %26, float %mul21.i.i)
  %28 = extractelement <2 x float> %14, i64 0
  %neg24.i.i = fneg float %28
  %29 = tail call float @llvm.fmuladd.f32(float %neg24.i.i, float %edge0.sroa.0.0.copyload, float %27)
  %neg31.i.i = fmul float %25, %neg24.i.i
  %30 = extractelement <2 x float> %23, i64 0
  %31 = tail call float @llvm.fmuladd.f32(float %30, float %edge0.sroa.0.0.copyload, float %neg31.i.i)
  %32 = extractelement <2 x float> %23, i64 1
  %33 = tail call float @llvm.fmuladd.f32(float %32, float %26, float %31)
  %34 = extractelement <2 x float> %24, i64 1
  %mul4.i9.i = fmul float %10, %34
  %35 = tail call float @llvm.fmuladd.f32(float %33, float %30, float %mul4.i9.i)
  %36 = extractelement <2 x float> %24, i64 0
  %37 = tail call float @llvm.fmuladd.f32(float %36, float %32, float %35)
  %38 = tail call float @llvm.fmuladd.f32(float %29, float %28, float %37)
  %39 = shufflevector <2 x float> %24, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %40 = insertelement <2 x float> %39, float %29, i64 0
  %41 = fmul <2 x float> %19, %40
  %42 = insertelement <2 x float> poison, float %33, i64 0
  %43 = shufflevector <2 x float> %42, <2 x float> poison, <2 x i32> zeroinitializer
  %44 = shufflevector <2 x float> %23, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %45 = insertelement <2 x float> %44, float %neg24.i.i, i64 1
  %46 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %43, <2 x float> %45, <2 x float> %41)
  %47 = shufflevector <2 x float> %24, <2 x float> %40, <2 x i32> <i32 1, i32 2>
  %48 = shufflevector <2 x float> %45, <2 x float> %23, <2 x i32> <i32 1, i32 2>
  %49 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %47, <2 x float> %48, <2 x float> %46)
  %50 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %24, <2 x float> %22, <2 x float> %49)
  %cmp14307 = icmp sgt i32 %8, 0
  br i1 %cmp14307, label %for.body15.lr.ph, label %for.inc48

for.body15.lr.ph:                                 ; preds = %for.body
  %51 = shufflevector <2 x float> %50, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %52 = insertelement <2 x float> %51, float %38, i64 0
  %53 = fneg <2 x float> %52
  %54 = extractelement <2 x float> %50, i64 1
  %55 = fneg float %54
  br label %for.body15

for.body15:                                       ; preds = %for.body15.lr.ph, %for.inc
  %56 = phi i32 [ %7, %for.body15.lr.ph ], [ %198, %for.inc ]
  %e1.0308 = phi i32 [ 0, %for.body15.lr.ph ], [ %inc47, %for.inc ]
  %57 = load i32, ptr %m_uniqueEdgesOffset16, align 4
  %add17 = add nsw i32 %57, %e1.0308
  %idxprom18 = sext i32 %add17 to i64
  %arrayidx19 = getelementptr inbounds %class.b3Vector3, ptr %uniqueEdgesB, i64 %idxprom18
  %edge1.sroa.0.0.copyload = load float, ptr %arrayidx19, align 16
  %edge1.sroa.2.0.arrayidx19.sroa_idx = getelementptr inbounds i8, ptr %arrayidx19, i64 4
  %58 = load float, ptr %arrayidx.i.i.i45, align 4
  %59 = load float, ptr %arrayidx.i25.i.i49, align 8
  %neg.i.i51 = fneg float %59
  %60 = load <2 x float>, ptr %edge1.sroa.2.0.arrayidx19.sroa_idx, align 4
  %61 = shufflevector <2 x float> %60, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %62 = load <2 x float>, ptr %ornB, align 16
  %63 = shufflevector <2 x float> %62, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %64 = extractelement <2 x float> %62, i64 1
  %65 = extractelement <2 x float> %60, i64 1
  %66 = fmul <2 x float> %61, %63
  %mul4.i.i48 = extractelement <2 x float> %66, i64 0
  %67 = tail call float @llvm.fmuladd.f32(float %58, float %edge1.sroa.0.0.copyload, float %mul4.i.i48)
  %68 = extractelement <2 x float> %60, i64 0
  %69 = tail call float @llvm.fmuladd.f32(float %neg.i.i51, float %68, float %67)
  %70 = insertelement <2 x float> %60, float %edge1.sroa.0.0.copyload, i64 1
  %71 = insertelement <2 x float> %62, float %59, i64 1
  %72 = fmul <2 x float> %70, %71
  %73 = insertelement <2 x float> poison, float %58, i64 0
  %74 = shufflevector <2 x float> %73, <2 x float> poison, <2 x i32> zeroinitializer
  %75 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %74, <2 x float> %61, <2 x float> %72)
  %76 = fneg <2 x float> %63
  %77 = insertelement <2 x float> %60, float %edge1.sroa.0.0.copyload, i64 0
  %78 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %76, <2 x float> %77, <2 x float> %75)
  %79 = extractelement <2 x float> %76, i64 0
  %neg31.i.i56 = fmul float %68, %79
  %80 = extractelement <2 x float> %76, i64 1
  %81 = tail call float @llvm.fmuladd.f32(float %80, float %edge1.sroa.0.0.copyload, float %neg31.i.i56)
  %82 = tail call float @llvm.fmuladd.f32(float %neg.i.i51, float %65, float %81)
  %83 = extractelement <2 x float> %78, i64 1
  %mul14.i.i58 = fmul float %58, %83
  %84 = tail call float @llvm.fmuladd.f32(float %82, float %79, float %mul14.i.i58)
  %85 = extractelement <2 x float> %78, i64 0
  %86 = tail call float @llvm.fmuladd.f32(float %85, float %80, float %84)
  %87 = tail call float @llvm.fmuladd.f32(float %69, float %59, float %86)
  %88 = shufflevector <2 x float> %78, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %89 = insertelement <2 x float> %88, float %69, i64 0
  %90 = fmul <2 x float> %74, %89
  %91 = insertelement <2 x float> poison, float %82, i64 0
  %92 = shufflevector <2 x float> %91, <2 x float> poison, <2 x i32> zeroinitializer
  %93 = shufflevector <2 x float> %76, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %94 = insertelement <2 x float> %93, float %neg.i.i51, i64 1
  %95 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %92, <2 x float> %94, <2 x float> %90)
  %96 = shufflevector <2 x float> %78, <2 x float> %89, <2 x i32> <i32 1, i32 2>
  %97 = shufflevector <2 x float> %94, <2 x float> %76, <2 x i32> <i32 1, i32 2>
  %98 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %96, <2 x float> %97, <2 x float> %95)
  %99 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %78, <2 x float> %63, <2 x float> %98)
  %100 = shufflevector <2 x float> %99, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %101 = insertelement <2 x float> %100, float %87, i64 1
  %102 = fmul <2 x float> %101, %53
  %103 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %50, <2 x float> %99, <2 x float> %102)
  %104 = extractelement <2 x float> %99, i64 0
  %neg17.i.i = fmul float %104, %55
  %105 = tail call float @llvm.fmuladd.f32(float %38, float %87, float %neg17.i.i)
  %106 = extractelement <2 x float> %103, i64 1
  %107 = tail call noundef float @llvm.fabs.f32(float %106)
  %conv.i = fpext float %107 to double
  %cmp.i = fcmp ogt double %conv.i, 0x3EB0C6F7A0B5ED8D
  %108 = extractelement <2 x float> %103, i64 0
  %109 = tail call float @llvm.fabs.f32(float %108)
  %conv2.i = fpext float %109 to double
  %cmp3.i = fcmp ogt double %conv2.i, 0x3EB0C6F7A0B5ED8D
  %or.cond367 = select i1 %cmp.i, i1 true, i1 %cmp3.i
  br i1 %or.cond367, label %if.then27, label %lor.lhs.false4.i

lor.lhs.false4.i:                                 ; preds = %for.body15
  %110 = tail call noundef float @llvm.fabs.f32(float %105)
  %conv6.i = fpext float %110 to double
  %cmp7.i = fcmp ogt double %conv6.i, 0x3EB0C6F7A0B5ED8D
  br i1 %cmp7.i, label %if.then27, label %for.inc

if.then27:                                        ; preds = %lor.lhs.false4.i, %for.body15
  %111 = fmul <2 x float> %103, %103
  %mul5.i.i.i.i.i = extractelement <2 x float> %111, i64 0
  %112 = tail call float @llvm.fmuladd.f32(float %106, float %106, float %mul5.i.i.i.i.i)
  %113 = tail call noundef float @llvm.fmuladd.f32(float %105, float %105, float %112)
  %sqrt.i.i.i = tail call noundef float @llvm.sqrt.f32(float %113)
  %div.i.i.i = fdiv float 1.000000e+00, %sqrt.i.i.i
  %114 = insertelement <2 x float> poison, float %div.i.i.i, i64 0
  %115 = shufflevector <2 x float> %114, <2 x float> poison, <2 x i32> zeroinitializer
  %116 = fmul <2 x float> %103, %115
  %mul4.i.i.i.i = fmul float %105, %div.i.i.i
  %117 = shufflevector <2 x float> %116, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %retval.sroa.3.12.vec.insert.i.i.i.i.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %mul4.i.i.i.i, i64 0
  %118 = load float, ptr %DeltaC2, align 16
  %119 = load float, ptr %arrayidx3.i.i66, align 4
  %120 = extractelement <2 x float> %116, i64 0
  %mul5.i.i = fmul float %120, %119
  %121 = extractelement <2 x float> %116, i64 1
  %122 = tail call float @llvm.fmuladd.f32(float %118, float %121, float %mul5.i.i)
  %123 = load float, ptr %arrayidx6.i.i, align 8
  %124 = tail call noundef float @llvm.fmuladd.f32(float %123, float %mul4.i.i.i.i, float %122)
  %cmp32 = fcmp olt float %124, 0.000000e+00
  br i1 %cmp32, label %if.then33, label %if.end36

if.then33:                                        ; preds = %if.then27
  %125 = shufflevector <2 x float> %116, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %126 = fneg <2 x float> %125
  %mul5.i = fneg float %mul4.i.i.i.i
  %crossje.sroa.17.8.vec.insert = insertelement <2 x float> %retval.sroa.3.12.vec.insert.i.i.i.i.i, float %mul5.i, i64 0
  br label %if.end36

if.end36:                                         ; preds = %if.then33, %if.then27
  %crossje.sroa.0.0 = phi <2 x float> [ %126, %if.then33 ], [ %117, %if.then27 ]
  %crossje.sroa.17.0 = phi <2 x float> [ %crossje.sroa.17.8.vec.insert, %if.then33 ], [ %retval.sroa.3.12.vec.insert.i.i.i.i.i, %if.then27 ]
  %127 = load i32, ptr %m_numVertices.i, align 4
  %128 = load float, ptr %ornA, align 16
  %fneg.i.i.i = fneg float %128
  %129 = load float, ptr %arrayidx.i23.i.i, align 4
  %fneg4.i.i.i = fneg float %129
  %130 = load float, ptr %arrayidx.i25.i.i, align 8
  %fneg7.i.i.i = fneg float %130
  %131 = load float, ptr %arrayidx.i.i.i, align 4
  %crossje.sroa.0.0.vec.extract251 = extractelement <2 x float> %crossje.sroa.0.0, i64 0
  %crossje.sroa.17.8.vec.extract273 = extractelement <2 x float> %crossje.sroa.17.0, i64 0
  %mul4.i.i.i = fmul float %crossje.sroa.17.8.vec.extract273, %fneg4.i.i.i
  %132 = tail call float @llvm.fmuladd.f32(float %131, float %crossje.sroa.0.0.vec.extract251, float %mul4.i.i.i)
  %crossje.sroa.0.4.vec.extract262 = extractelement <2 x float> %crossje.sroa.0.0, i64 1
  %133 = tail call float @llvm.fmuladd.f32(float %130, float %crossje.sroa.0.4.vec.extract262, float %132)
  %mul12.i.i.i = fmul float %crossje.sroa.0.0.vec.extract251, %fneg7.i.i.i
  %134 = tail call float @llvm.fmuladd.f32(float %131, float %crossje.sroa.0.4.vec.extract262, float %mul12.i.i.i)
  %135 = tail call float @llvm.fmuladd.f32(float %128, float %crossje.sroa.17.8.vec.extract273, float %134)
  %mul21.i.i.i = fmul float %crossje.sroa.0.4.vec.extract262, %fneg.i.i.i
  %136 = tail call float @llvm.fmuladd.f32(float %131, float %crossje.sroa.17.8.vec.extract273, float %mul21.i.i.i)
  %137 = tail call float @llvm.fmuladd.f32(float %129, float %crossje.sroa.0.0.vec.extract251, float %136)
  %neg31.i.i.i = fmul float %crossje.sroa.0.4.vec.extract262, %129
  %138 = tail call float @llvm.fmuladd.f32(float %128, float %crossje.sroa.0.0.vec.extract251, float %neg31.i.i.i)
  %139 = tail call float @llvm.fmuladd.f32(float %130, float %crossje.sroa.17.8.vec.extract273, float %138)
  %mul4.i9.i.i = fmul float %131, %133
  %140 = tail call float @llvm.fmuladd.f32(float %139, float %128, float %mul4.i9.i.i)
  %141 = tail call float @llvm.fmuladd.f32(float %135, float %130, float %140)
  %142 = tail call float @llvm.fmuladd.f32(float %137, float %fneg4.i.i.i, float %141)
  %mul14.i.i.i = fmul float %131, %135
  %143 = tail call float @llvm.fmuladd.f32(float %139, float %129, float %mul14.i.i.i)
  %144 = tail call float @llvm.fmuladd.f32(float %137, float %128, float %143)
  %145 = tail call float @llvm.fmuladd.f32(float %133, float %fneg7.i.i.i, float %144)
  %mul25.i.i.i = fmul float %131, %137
  %146 = tail call float @llvm.fmuladd.f32(float %139, float %130, float %mul25.i.i.i)
  %147 = tail call float @llvm.fmuladd.f32(float %133, float %129, float %146)
  %148 = tail call float @llvm.fmuladd.f32(float %135, float %fneg.i.i.i, float %147)
  %cmp29.i = icmp sgt i32 %127, 0
  br i1 %cmp29.i, label %for.body.lr.ph.i, label %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit

for.body.lr.ph.i:                                 ; preds = %if.end36
  %149 = load i32, ptr %m_vertexOffset.i, align 16
  %150 = sext i32 %149 to i64
  %151 = zext nneg i32 %127 to i64
  %invariant.gep346 = getelementptr %class.b3Vector3, ptr %verticesA, i64 %150
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %for.body.lr.ph.i
  %indvars.iv328 = phi i64 [ %indvars.iv.next329, %for.body.i ], [ 0, %for.body.lr.ph.i ]
  %Max0.0 = phi float [ %Max0.1, %for.body.i ], [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i ]
  %Min0.0 = phi float [ %Min0.1, %for.body.i ], [ 0x47EFFFFFE0000000, %for.body.lr.ph.i ]
  %152 = phi float [ %159, %for.body.i ], [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i ]
  %gep347 = getelementptr %class.b3Vector3, ptr %invariant.gep346, i64 %indvars.iv328
  %153 = load float, ptr %gep347, align 16
  %arrayidx3.i.i24.i = getelementptr inbounds [4 x float], ptr %gep347, i64 0, i64 1
  %154 = load float, ptr %arrayidx3.i.i24.i, align 4
  %mul5.i.i26.i = fmul float %145, %154
  %155 = tail call float @llvm.fmuladd.f32(float %153, float %142, float %mul5.i.i26.i)
  %arrayidx6.i.i27.i = getelementptr inbounds [4 x float], ptr %gep347, i64 0, i64 2
  %156 = load float, ptr %arrayidx6.i.i27.i, align 8
  %157 = tail call noundef float @llvm.fmuladd.f32(float %156, float %148, float %155)
  %cmp11.i = fcmp olt float %157, %Min0.0
  %Min0.1 = select i1 %cmp11.i, float %157, float %Min0.0
  %158 = select i1 %cmp11.i, float %Max0.0, float %152
  %cmp14.i = fcmp ogt float %157, %158
  %Max0.1 = select i1 %cmp14.i, float %157, float %Max0.0
  %159 = select i1 %cmp14.i, float %157, float %158
  %indvars.iv.next329 = add nuw nsw i64 %indvars.iv328, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next329, %151
  br i1 %exitcond.not.i, label %for.end.i, label %for.body.i, !llvm.loop !9

for.end.i:                                        ; preds = %for.body.i
  %cmp20.i = fcmp ogt float %Min0.1, %159
  br i1 %cmp20.i, label %if.then21.i, label %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit

if.then21.i:                                      ; preds = %for.end.i
  br label %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit

_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit: ; preds = %if.end36, %for.end.i, %if.then21.i
  %Max0.3 = phi float [ %Max0.1, %for.end.i ], [ %Min0.1, %if.then21.i ], [ 0x47EFFFFFE0000000, %if.end36 ]
  %160 = phi float [ %Min0.1, %for.end.i ], [ %159, %if.then21.i ], [ 0xC7EFFFFFE0000000, %if.end36 ]
  %mul5.i.i.i = fmul float %posA.sroa.3.0.copyload, %crossje.sroa.0.4.vec.extract262
  %161 = tail call float @llvm.fmuladd.f32(float %posA.sroa.0.0.copyload, float %crossje.sroa.0.0.vec.extract251, float %mul5.i.i.i)
  %162 = tail call noundef float @llvm.fmuladd.f32(float %posA.sroa.5.0.copyload, float %crossje.sroa.17.8.vec.extract273, float %161)
  %add28.i = fadd float %162, %160
  %add30.i = fadd float %162, %Max0.3
  %163 = load i32, ptr %m_numVertices.i69, align 4
  %164 = fmul <2 x float> %crossje.sroa.17.0, %76
  %mul4.i.i.i77 = extractelement <2 x float> %164, i64 0
  %165 = tail call float @llvm.fmuladd.f32(float %58, float %crossje.sroa.0.0.vec.extract251, float %mul4.i.i.i77)
  %166 = tail call float @llvm.fmuladd.f32(float %59, float %crossje.sroa.0.4.vec.extract262, float %165)
  %mul12.i.i.i79 = fmul float %crossje.sroa.0.0.vec.extract251, %neg.i.i51
  %167 = tail call float @llvm.fmuladd.f32(float %58, float %crossje.sroa.0.4.vec.extract262, float %mul12.i.i.i79)
  %168 = extractelement <2 x float> %62, i64 0
  %169 = tail call float @llvm.fmuladd.f32(float %168, float %crossje.sroa.17.8.vec.extract273, float %167)
  %mul21.i.i.i80 = fmul float %crossje.sroa.0.4.vec.extract262, %80
  %170 = tail call float @llvm.fmuladd.f32(float %58, float %crossje.sroa.17.8.vec.extract273, float %mul21.i.i.i80)
  %171 = tail call float @llvm.fmuladd.f32(float %64, float %crossje.sroa.0.0.vec.extract251, float %170)
  %neg31.i.i.i81 = fmul float %64, %crossje.sroa.0.4.vec.extract262
  %172 = tail call float @llvm.fmuladd.f32(float %168, float %crossje.sroa.0.0.vec.extract251, float %neg31.i.i.i81)
  %173 = tail call float @llvm.fmuladd.f32(float %59, float %crossje.sroa.17.8.vec.extract273, float %172)
  %mul4.i9.i.i82 = fmul float %58, %166
  %174 = tail call float @llvm.fmuladd.f32(float %173, float %168, float %mul4.i9.i.i82)
  %175 = tail call float @llvm.fmuladd.f32(float %169, float %59, float %174)
  %176 = tail call float @llvm.fmuladd.f32(float %171, float %79, float %175)
  %mul14.i.i.i83 = fmul float %58, %169
  %177 = tail call float @llvm.fmuladd.f32(float %173, float %64, float %mul14.i.i.i83)
  %178 = tail call float @llvm.fmuladd.f32(float %171, float %168, float %177)
  %179 = tail call float @llvm.fmuladd.f32(float %166, float %neg.i.i51, float %178)
  %mul25.i.i.i84 = fmul float %58, %171
  %180 = tail call float @llvm.fmuladd.f32(float %173, float %59, float %mul25.i.i.i84)
  %181 = tail call float @llvm.fmuladd.f32(float %166, float %64, float %180)
  %182 = tail call float @llvm.fmuladd.f32(float %169, float %80, float %181)
  %cmp29.i87 = icmp sgt i32 %163, 0
  br i1 %cmp29.i87, label %for.body.lr.ph.i95, label %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit114

for.body.lr.ph.i95:                               ; preds = %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit
  %183 = load i32, ptr %m_vertexOffset.i96, align 16
  %184 = sext i32 %183 to i64
  %185 = zext nneg i32 %163 to i64
  %invariant.gep348 = getelementptr %class.b3Vector3, ptr %verticesB, i64 %184
  br label %for.body.i97

for.body.i97:                                     ; preds = %for.body.i97, %for.body.lr.ph.i95
  %indvars.iv332 = phi i64 [ %indvars.iv.next333, %for.body.i97 ], [ 0, %for.body.lr.ph.i95 ]
  %Max1.0 = phi float [ %Max1.1, %for.body.i97 ], [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i95 ]
  %Min1.0 = phi float [ %Min1.1, %for.body.i97 ], [ 0x47EFFFFFE0000000, %for.body.lr.ph.i95 ]
  %186 = phi float [ %193, %for.body.i97 ], [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i95 ]
  %gep349 = getelementptr %class.b3Vector3, ptr %invariant.gep348, i64 %indvars.iv332
  %187 = load float, ptr %gep349, align 16
  %arrayidx3.i.i24.i102 = getelementptr inbounds [4 x float], ptr %gep349, i64 0, i64 1
  %188 = load float, ptr %arrayidx3.i.i24.i102, align 4
  %mul5.i.i26.i103 = fmul float %179, %188
  %189 = tail call float @llvm.fmuladd.f32(float %187, float %176, float %mul5.i.i26.i103)
  %arrayidx6.i.i27.i104 = getelementptr inbounds [4 x float], ptr %gep349, i64 0, i64 2
  %190 = load float, ptr %arrayidx6.i.i27.i104, align 8
  %191 = tail call noundef float @llvm.fmuladd.f32(float %190, float %182, float %189)
  %cmp11.i105 = fcmp olt float %191, %Min1.0
  %Min1.1 = select i1 %cmp11.i105, float %191, float %Min1.0
  %192 = select i1 %cmp11.i105, float %Max1.0, float %186
  %cmp14.i107 = fcmp ogt float %191, %192
  %Max1.1 = select i1 %cmp14.i107, float %191, float %Max1.0
  %193 = select i1 %cmp14.i107, float %191, float %192
  %indvars.iv.next333 = add nuw nsw i64 %indvars.iv332, 1
  %exitcond.not.i110 = icmp eq i64 %indvars.iv.next333, %185
  br i1 %exitcond.not.i110, label %for.end.i88, label %for.body.i97, !llvm.loop !9

for.end.i88:                                      ; preds = %for.body.i97
  %cmp20.i89 = fcmp ogt float %Min1.1, %193
  br i1 %cmp20.i89, label %if.then21.i93, label %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit114

if.then21.i93:                                    ; preds = %for.end.i88
  br label %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit114

_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit114: ; preds = %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit, %for.end.i88, %if.then21.i93
  %Max1.3 = phi float [ %Max1.1, %for.end.i88 ], [ %Min1.1, %if.then21.i93 ], [ 0x47EFFFFFE0000000, %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit ]
  %194 = phi float [ %Min1.1, %for.end.i88 ], [ %193, %if.then21.i93 ], [ 0xC7EFFFFFE0000000, %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit ]
  %mul5.i.i.i90 = fmul float %posB.sroa.3.0.copyload, %crossje.sroa.0.4.vec.extract262
  %195 = tail call float @llvm.fmuladd.f32(float %posB.sroa.0.0.copyload, float %crossje.sroa.0.0.vec.extract251, float %mul5.i.i.i90)
  %196 = tail call noundef float @llvm.fmuladd.f32(float %posB.sroa.5.0.copyload, float %crossje.sroa.17.8.vec.extract273, float %195)
  %add28.i91 = fadd float %196, %194
  %add30.i92 = fadd float %196, %Max1.3
  %cmp37 = fcmp olt float %add30.i, %add28.i91
  %cmp38 = fcmp olt float %add30.i92, %add28.i
  %or.cond = select i1 %cmp37, i1 true, i1 %cmp38
  br i1 %or.cond, label %return, label %if.end40

if.end40:                                         ; preds = %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit114
  %sub = fsub float %add30.i, %add28.i91
  %sub41 = fsub float %add30.i92, %add28.i
  %cmp42 = fcmp olt float %sub, %sub41
  %cond = select i1 %cmp42, float %sub, float %sub41
  %197 = load float, ptr %dmin, align 4
  %cmp43 = fcmp olt float %cond, %197
  br i1 %cmp43, label %if.then44, label %for.inc

if.then44:                                        ; preds = %if.end40
  store float %cond, ptr %dmin, align 4
  store <2 x float> %crossje.sroa.0.0, ptr %sep, align 16
  store <2 x float> %crossje.sroa.17.0, ptr %crossje.sroa.17.0.sep.sroa_idx, align 8
  %.pre336 = load i32, ptr %m_numUniqueEdges2, align 8
  br label %for.inc

for.inc:                                          ; preds = %lor.lhs.false4.i, %if.then44, %if.end40
  %198 = phi i32 [ %56, %lor.lhs.false4.i ], [ %.pre336, %if.then44 ], [ %56, %if.end40 ]
  %inc47 = add nuw nsw i32 %e1.0308, 1
  %cmp14 = icmp slt i32 %inc47, %198
  br i1 %cmp14, label %for.body15, label %for.inc48.loopexit, !llvm.loop !11

for.inc48.loopexit:                               ; preds = %for.inc
  %.pre337 = load i32, ptr %m_numUniqueEdges, align 8
  br label %for.inc48

for.inc48:                                        ; preds = %for.inc48.loopexit, %for.body
  %199 = phi i32 [ %6, %for.body ], [ %.pre337, %for.inc48.loopexit ]
  %200 = phi i32 [ %7, %for.body ], [ %198, %for.inc48.loopexit ]
  %201 = phi i32 [ %8, %for.body ], [ %198, %for.inc48.loopexit ]
  %inc49 = add nuw nsw i32 %e0.0311, 1
  %cmp9 = icmp slt i32 %inc49, %199
  br i1 %cmp9, label %for.body, label %if.end83, !llvm.loop !12

for.body53:                                       ; preds = %for.cond51.preheader, %for.inc80
  %indvars.iv325 = phi i64 [ 0, %for.cond51.preheader ], [ %indvars.iv.next326, %for.inc80 ]
  %arrayidx56 = getelementptr inbounds [162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 %indvars.iv325
  %202 = load <4 x float>, ptr %arrayidx56, align 16
  %203 = load i32, ptr %m_numVertices.i115, align 4
  %204 = load float, ptr %ornA, align 16
  %fneg.i.i.i116 = fneg float %204
  %205 = load float, ptr %arrayidx3.i.i.i117, align 4
  %fneg4.i.i.i118 = fneg float %205
  %206 = load float, ptr %arrayidx6.i.i.i119, align 8
  %fneg7.i.i.i120 = fneg float %206
  %207 = load float, ptr %arrayidx8.i.i.i121, align 4
  %208 = extractelement <4 x float> %202, i64 2
  %mul4.i.i.i123 = fmul float %208, %fneg4.i.i.i118
  %209 = extractelement <4 x float> %202, i64 0
  %210 = tail call float @llvm.fmuladd.f32(float %207, float %209, float %mul4.i.i.i123)
  %211 = extractelement <4 x float> %202, i64 1
  %212 = tail call float @llvm.fmuladd.f32(float %206, float %211, float %210)
  %mul12.i.i.i125 = fmul float %209, %fneg7.i.i.i120
  %213 = tail call float @llvm.fmuladd.f32(float %207, float %211, float %mul12.i.i.i125)
  %214 = tail call float @llvm.fmuladd.f32(float %204, float %208, float %213)
  %mul21.i.i.i126 = fmul float %211, %fneg.i.i.i116
  %215 = tail call float @llvm.fmuladd.f32(float %207, float %208, float %mul21.i.i.i126)
  %216 = tail call float @llvm.fmuladd.f32(float %205, float %209, float %215)
  %neg31.i.i.i127 = fmul float %211, %205
  %217 = tail call float @llvm.fmuladd.f32(float %204, float %209, float %neg31.i.i.i127)
  %218 = tail call float @llvm.fmuladd.f32(float %206, float %208, float %217)
  %mul4.i9.i.i128 = fmul float %207, %212
  %219 = tail call float @llvm.fmuladd.f32(float %218, float %204, float %mul4.i9.i.i128)
  %220 = tail call float @llvm.fmuladd.f32(float %214, float %206, float %219)
  %221 = tail call float @llvm.fmuladd.f32(float %216, float %fneg4.i.i.i118, float %220)
  %mul14.i.i.i129 = fmul float %207, %214
  %222 = tail call float @llvm.fmuladd.f32(float %218, float %205, float %mul14.i.i.i129)
  %223 = tail call float @llvm.fmuladd.f32(float %216, float %204, float %222)
  %224 = tail call float @llvm.fmuladd.f32(float %212, float %fneg7.i.i.i120, float %223)
  %mul25.i.i.i130 = fmul float %207, %216
  %225 = tail call float @llvm.fmuladd.f32(float %218, float %206, float %mul25.i.i.i130)
  %226 = tail call float @llvm.fmuladd.f32(float %212, float %205, float %225)
  %227 = tail call float @llvm.fmuladd.f32(float %214, float %fneg.i.i.i116, float %226)
  %cmp29.i133 = icmp sgt i32 %203, 0
  br i1 %cmp29.i133, label %for.body.lr.ph.i141, label %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit160

for.body.lr.ph.i141:                              ; preds = %for.body53
  %228 = load i32, ptr %m_vertexOffset.i142, align 16
  %229 = sext i32 %228 to i64
  %230 = zext nneg i32 %203 to i64
  %invariant.gep = getelementptr %class.b3Vector3, ptr %verticesA, i64 %229
  br label %for.body.i143

for.body.i143:                                    ; preds = %for.body.i143, %for.body.lr.ph.i141
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body.i143 ], [ 0, %for.body.lr.ph.i141 ]
  %Min059.0 = phi float [ %Min059.1, %for.body.i143 ], [ 0x47EFFFFFE0000000, %for.body.lr.ph.i141 ]
  %Max060.0 = phi float [ %Max060.1, %for.body.i143 ], [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i141 ]
  %231 = phi float [ %238, %for.body.i143 ], [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i141 ]
  %gep = getelementptr %class.b3Vector3, ptr %invariant.gep, i64 %indvars.iv
  %232 = load float, ptr %gep, align 16
  %arrayidx3.i.i24.i148 = getelementptr inbounds [4 x float], ptr %gep, i64 0, i64 1
  %233 = load float, ptr %arrayidx3.i.i24.i148, align 4
  %mul5.i.i26.i149 = fmul float %224, %233
  %234 = tail call float @llvm.fmuladd.f32(float %232, float %221, float %mul5.i.i26.i149)
  %arrayidx6.i.i27.i150 = getelementptr inbounds [4 x float], ptr %gep, i64 0, i64 2
  %235 = load float, ptr %arrayidx6.i.i27.i150, align 8
  %236 = tail call noundef float @llvm.fmuladd.f32(float %235, float %227, float %234)
  %cmp11.i151 = fcmp olt float %236, %Min059.0
  %Min059.1 = select i1 %cmp11.i151, float %236, float %Min059.0
  %237 = select i1 %cmp11.i151, float %Max060.0, float %231
  %cmp14.i153 = fcmp ogt float %236, %237
  %Max060.1 = select i1 %cmp14.i153, float %236, float %Max060.0
  %238 = select i1 %cmp14.i153, float %236, float %237
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not.i156 = icmp eq i64 %indvars.iv.next, %230
  br i1 %exitcond.not.i156, label %for.end.i134, label %for.body.i143, !llvm.loop !9

for.end.i134:                                     ; preds = %for.body.i143
  %cmp20.i135 = fcmp ogt float %Min059.1, %238
  br i1 %cmp20.i135, label %if.then21.i139, label %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit160

if.then21.i139:                                   ; preds = %for.end.i134
  br label %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit160

_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit160: ; preds = %for.body53, %for.end.i134, %if.then21.i139
  %Max060.3 = phi float [ %Max060.1, %for.end.i134 ], [ %Min059.1, %if.then21.i139 ], [ 0x47EFFFFFE0000000, %for.body53 ]
  %239 = phi float [ %Min059.1, %for.end.i134 ], [ %238, %if.then21.i139 ], [ 0xC7EFFFFFE0000000, %for.body53 ]
  %mul5.i.i.i136 = fmul float %posA.sroa.3.0.copyload, %211
  %240 = tail call float @llvm.fmuladd.f32(float %posA.sroa.0.0.copyload, float %209, float %mul5.i.i.i136)
  %241 = tail call noundef float @llvm.fmuladd.f32(float %posA.sroa.5.0.copyload, float %208, float %240)
  %add28.i137 = fadd float %241, %239
  %add30.i138 = fadd float %241, %Max060.3
  %242 = load i32, ptr %m_numVertices.i161, align 4
  %243 = load float, ptr %ornB, align 16
  %fneg.i.i.i162 = fneg float %243
  %244 = load float, ptr %arrayidx3.i.i.i163, align 4
  %fneg4.i.i.i164 = fneg float %244
  %245 = load float, ptr %arrayidx6.i.i.i165, align 8
  %fneg7.i.i.i166 = fneg float %245
  %246 = load float, ptr %arrayidx8.i.i.i167, align 4
  %mul4.i.i.i169 = fmul float %208, %fneg4.i.i.i164
  %247 = tail call float @llvm.fmuladd.f32(float %246, float %209, float %mul4.i.i.i169)
  %248 = tail call float @llvm.fmuladd.f32(float %245, float %211, float %247)
  %mul12.i.i.i171 = fmul float %209, %fneg7.i.i.i166
  %249 = tail call float @llvm.fmuladd.f32(float %246, float %211, float %mul12.i.i.i171)
  %250 = tail call float @llvm.fmuladd.f32(float %243, float %208, float %249)
  %mul21.i.i.i172 = fmul float %211, %fneg.i.i.i162
  %251 = tail call float @llvm.fmuladd.f32(float %246, float %208, float %mul21.i.i.i172)
  %252 = tail call float @llvm.fmuladd.f32(float %244, float %209, float %251)
  %neg31.i.i.i173 = fmul float %211, %244
  %253 = tail call float @llvm.fmuladd.f32(float %243, float %209, float %neg31.i.i.i173)
  %254 = tail call float @llvm.fmuladd.f32(float %245, float %208, float %253)
  %mul4.i9.i.i174 = fmul float %246, %248
  %255 = tail call float @llvm.fmuladd.f32(float %254, float %243, float %mul4.i9.i.i174)
  %256 = tail call float @llvm.fmuladd.f32(float %250, float %245, float %255)
  %257 = tail call float @llvm.fmuladd.f32(float %252, float %fneg4.i.i.i164, float %256)
  %mul14.i.i.i175 = fmul float %246, %250
  %258 = tail call float @llvm.fmuladd.f32(float %254, float %244, float %mul14.i.i.i175)
  %259 = tail call float @llvm.fmuladd.f32(float %252, float %243, float %258)
  %260 = tail call float @llvm.fmuladd.f32(float %248, float %fneg7.i.i.i166, float %259)
  %mul25.i.i.i176 = fmul float %246, %252
  %261 = tail call float @llvm.fmuladd.f32(float %254, float %245, float %mul25.i.i.i176)
  %262 = tail call float @llvm.fmuladd.f32(float %248, float %244, float %261)
  %263 = tail call float @llvm.fmuladd.f32(float %250, float %fneg.i.i.i162, float %262)
  %cmp29.i179 = icmp sgt i32 %242, 0
  br i1 %cmp29.i179, label %for.body.lr.ph.i187, label %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit206

for.body.lr.ph.i187:                              ; preds = %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit160
  %264 = load i32, ptr %m_vertexOffset.i188, align 16
  %265 = sext i32 %264 to i64
  %266 = zext nneg i32 %242 to i64
  %invariant.gep344 = getelementptr %class.b3Vector3, ptr %verticesB, i64 %265
  br label %for.body.i189

for.body.i189:                                    ; preds = %for.body.i189, %for.body.lr.ph.i187
  %indvars.iv321 = phi i64 [ %indvars.iv.next322, %for.body.i189 ], [ 0, %for.body.lr.ph.i187 ]
  %Min161.0 = phi float [ %Min161.1, %for.body.i189 ], [ 0x47EFFFFFE0000000, %for.body.lr.ph.i187 ]
  %Max162.0 = phi float [ %Max162.1, %for.body.i189 ], [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i187 ]
  %267 = phi float [ %274, %for.body.i189 ], [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i187 ]
  %gep345 = getelementptr %class.b3Vector3, ptr %invariant.gep344, i64 %indvars.iv321
  %268 = load float, ptr %gep345, align 16
  %arrayidx3.i.i24.i194 = getelementptr inbounds [4 x float], ptr %gep345, i64 0, i64 1
  %269 = load float, ptr %arrayidx3.i.i24.i194, align 4
  %mul5.i.i26.i195 = fmul float %260, %269
  %270 = tail call float @llvm.fmuladd.f32(float %268, float %257, float %mul5.i.i26.i195)
  %arrayidx6.i.i27.i196 = getelementptr inbounds [4 x float], ptr %gep345, i64 0, i64 2
  %271 = load float, ptr %arrayidx6.i.i27.i196, align 8
  %272 = tail call noundef float @llvm.fmuladd.f32(float %271, float %263, float %270)
  %cmp11.i197 = fcmp olt float %272, %Min161.0
  %Min161.1 = select i1 %cmp11.i197, float %272, float %Min161.0
  %273 = select i1 %cmp11.i197, float %Max162.0, float %267
  %cmp14.i199 = fcmp ogt float %272, %273
  %Max162.1 = select i1 %cmp14.i199, float %272, float %Max162.0
  %274 = select i1 %cmp14.i199, float %272, float %273
  %indvars.iv.next322 = add nuw nsw i64 %indvars.iv321, 1
  %exitcond.not.i202 = icmp eq i64 %indvars.iv.next322, %266
  br i1 %exitcond.not.i202, label %for.end.i180, label %for.body.i189, !llvm.loop !9

for.end.i180:                                     ; preds = %for.body.i189
  %cmp20.i181 = fcmp ogt float %Min161.1, %274
  br i1 %cmp20.i181, label %if.then21.i185, label %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit206

if.then21.i185:                                   ; preds = %for.end.i180
  br label %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit206

_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit206: ; preds = %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit160, %for.end.i180, %if.then21.i185
  %Max162.3 = phi float [ %Max162.1, %for.end.i180 ], [ %Min161.1, %if.then21.i185 ], [ 0x47EFFFFFE0000000, %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit160 ]
  %275 = phi float [ %Min161.1, %for.end.i180 ], [ %274, %if.then21.i185 ], [ 0xC7EFFFFFE0000000, %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit160 ]
  %mul5.i.i.i182 = fmul float %posB.sroa.3.0.copyload, %211
  %276 = tail call float @llvm.fmuladd.f32(float %posB.sroa.0.0.copyload, float %209, float %mul5.i.i.i182)
  %277 = tail call noundef float @llvm.fmuladd.f32(float %posB.sroa.5.0.copyload, float %208, float %276)
  %add28.i183 = fadd float %277, %275
  %add30.i184 = fadd float %277, %Max162.3
  %cmp63 = fcmp olt float %add30.i138, %add28.i183
  %cmp65 = fcmp olt float %add30.i184, %add28.i137
  %or.cond299 = select i1 %cmp63, i1 true, i1 %cmp65
  br i1 %or.cond299, label %return, label %if.end67

if.end67:                                         ; preds = %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit206
  %sub69 = fsub float %add30.i138, %add28.i183
  %sub71 = fsub float %add30.i184, %add28.i137
  %cmp72 = fcmp olt float %sub69, %sub71
  %cond76 = select i1 %cmp72, float %sub69, float %sub71
  %278 = load float, ptr %dmin, align 4
  %cmp77 = fcmp olt float %cond76, %278
  br i1 %cmp77, label %if.then78, label %for.inc80

if.then78:                                        ; preds = %if.end67
  store float %cond76, ptr %dmin, align 4
  store <4 x float> %202, ptr %sep, align 16
  br label %for.inc80

for.inc80:                                        ; preds = %if.end67, %if.then78
  %indvars.iv.next326 = add nuw nsw i64 %indvars.iv325, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next326, 162
  br i1 %exitcond.not, label %if.end83, label %for.body53, !llvm.loop !13

if.end83:                                         ; preds = %for.inc80, %for.inc48, %for.cond.preheader
  %279 = load float, ptr %DeltaC2, align 16
  %fneg.i = fneg float %279
  %arrayidx1.i = getelementptr inbounds [4 x float], ptr %DeltaC2, i64 0, i64 1
  %280 = load float, ptr %arrayidx1.i, align 4
  %fneg2.i = fneg float %280
  %arrayidx3.i = getelementptr inbounds [4 x float], ptr %DeltaC2, i64 0, i64 2
  %281 = load float, ptr %arrayidx3.i, align 8
  %fneg4.i = fneg float %281
  %282 = load <2 x float>, ptr %sep, align 16
  %283 = extractelement <2 x float> %282, i64 1
  %mul5.i.i209 = fmul float %283, %fneg2.i
  %284 = extractelement <2 x float> %282, i64 0
  %285 = tail call float @llvm.fmuladd.f32(float %fneg.i, float %284, float %mul5.i.i209)
  %arrayidx7.i.i211 = getelementptr inbounds [4 x float], ptr %sep, i64 0, i64 2
  %286 = load float, ptr %arrayidx7.i.i211, align 8
  %287 = tail call noundef float @llvm.fmuladd.f32(float %fneg4.i, float %286, float %285)
  %cmp89 = fcmp ogt float %287, 0.000000e+00
  br i1 %cmp89, label %if.then90, label %return

if.then90:                                        ; preds = %if.end83
  %288 = fneg <2 x float> %282
  %fneg4.i216 = fneg float %286
  %retval.sroa.3.12.vec.insert.i.i219 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %fneg4.i216, i64 0
  store <2 x float> %288, ptr %sep, align 16
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i219, ptr %arrayidx7.i.i211, align 8
  br label %return

return:                                           ; preds = %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit206, %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit114, %if.end83, %if.then90
  %retval.0 = phi i1 [ true, %if.then90 ], [ true, %if.end83 ], [ false, %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit114 ], [ false, %_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_.exit206 ]
  ret i1 %retval.0
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #4

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_(ptr noundef %hull, ptr noundef nonnull align 16 dereferenceable(16) %pos, ptr noundef nonnull align 16 dereferenceable(16) %orn, ptr noundef %dir, ptr noundef %vertices, ptr noundef %min, ptr noundef %max) local_unnamed_addr #5 comdat {
entry:
  store float 0x47EFFFFFE0000000, ptr %min, align 4
  store float 0xC7EFFFFFE0000000, ptr %max, align 4
  %m_numVertices = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hull, i64 0, i32 7
  %0 = load i32, ptr %m_numVertices, align 4
  %1 = load float, ptr %orn, align 16
  %fneg.i.i = fneg float %1
  %arrayidx3.i.i = getelementptr inbounds [4 x float], ptr %orn, i64 0, i64 1
  %2 = load float, ptr %arrayidx3.i.i, align 4
  %fneg4.i.i = fneg float %2
  %arrayidx6.i.i = getelementptr inbounds [4 x float], ptr %orn, i64 0, i64 2
  %3 = load float, ptr %arrayidx6.i.i, align 8
  %fneg7.i.i = fneg float %3
  %arrayidx8.i.i = getelementptr inbounds [4 x float], ptr %orn, i64 0, i64 3
  %4 = load float, ptr %arrayidx8.i.i, align 4
  %5 = load float, ptr %dir, align 4
  %arrayidx.i24.i.i = getelementptr inbounds [4 x float], ptr %dir, i64 0, i64 2
  %6 = load float, ptr %arrayidx.i24.i.i, align 4
  %mul4.i.i = fmul float %6, %fneg4.i.i
  %7 = tail call float @llvm.fmuladd.f32(float %4, float %5, float %mul4.i.i)
  %arrayidx.i26.i.i = getelementptr inbounds [4 x float], ptr %dir, i64 0, i64 1
  %8 = load float, ptr %arrayidx.i26.i.i, align 4
  %9 = tail call float @llvm.fmuladd.f32(float %3, float %8, float %7)
  %mul12.i.i = fmul float %5, %fneg7.i.i
  %10 = tail call float @llvm.fmuladd.f32(float %4, float %8, float %mul12.i.i)
  %11 = tail call float @llvm.fmuladd.f32(float %1, float %6, float %10)
  %mul21.i.i = fmul float %8, %fneg.i.i
  %12 = tail call float @llvm.fmuladd.f32(float %4, float %6, float %mul21.i.i)
  %13 = tail call float @llvm.fmuladd.f32(float %2, float %5, float %12)
  %neg31.i.i = fmul float %2, %8
  %14 = tail call float @llvm.fmuladd.f32(float %1, float %5, float %neg31.i.i)
  %15 = tail call float @llvm.fmuladd.f32(float %3, float %6, float %14)
  %mul4.i9.i = fmul float %4, %9
  %16 = tail call float @llvm.fmuladd.f32(float %15, float %1, float %mul4.i9.i)
  %17 = tail call float @llvm.fmuladd.f32(float %11, float %3, float %16)
  %18 = tail call float @llvm.fmuladd.f32(float %13, float %fneg4.i.i, float %17)
  %mul14.i.i = fmul float %4, %11
  %19 = tail call float @llvm.fmuladd.f32(float %15, float %2, float %mul14.i.i)
  %20 = tail call float @llvm.fmuladd.f32(float %13, float %1, float %19)
  %21 = tail call float @llvm.fmuladd.f32(float %9, float %fneg7.i.i, float %20)
  %mul25.i.i = fmul float %4, %13
  %22 = tail call float @llvm.fmuladd.f32(float %15, float %3, float %mul25.i.i)
  %23 = tail call float @llvm.fmuladd.f32(float %9, float %2, float %22)
  %24 = tail call float @llvm.fmuladd.f32(float %11, float %fneg.i.i, float %23)
  %25 = load float, ptr %pos, align 16
  %arrayidx3.i.i22 = getelementptr inbounds [4 x float], ptr %pos, i64 0, i64 1
  %26 = load float, ptr %arrayidx3.i.i22, align 4
  %arrayidx6.i.i23 = getelementptr inbounds [4 x float], ptr %pos, i64 0, i64 2
  %27 = load float, ptr %arrayidx6.i.i23, align 8
  %cmp29 = icmp sgt i32 %0, 0
  br i1 %cmp29, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %entry
  %m_vertexOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hull, i64 0, i32 8
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %28 = phi float [ 0xC7EFFFFFE0000000, %for.body.lr.ph ], [ %37, %for.inc ]
  %i.030 = phi i32 [ 0, %for.body.lr.ph ], [ %inc, %for.inc ]
  %29 = load i32, ptr %m_vertexOffset, align 16
  %add = add nsw i32 %29, %i.030
  %idxprom = sext i32 %add to i64
  %arrayidx8 = getelementptr inbounds %class.b3Vector3, ptr %vertices, i64 %idxprom
  %30 = load float, ptr %arrayidx8, align 16
  %arrayidx3.i.i24 = getelementptr inbounds [4 x float], ptr %arrayidx8, i64 0, i64 1
  %31 = load float, ptr %arrayidx3.i.i24, align 4
  %mul5.i.i26 = fmul float %21, %31
  %32 = tail call float @llvm.fmuladd.f32(float %30, float %18, float %mul5.i.i26)
  %arrayidx6.i.i27 = getelementptr inbounds [4 x float], ptr %arrayidx8, i64 0, i64 2
  %33 = load float, ptr %arrayidx6.i.i27, align 8
  %34 = tail call noundef float @llvm.fmuladd.f32(float %33, float %24, float %32)
  %35 = load float, ptr %min, align 4
  %cmp11 = fcmp olt float %34, %35
  br i1 %cmp11, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  store float %34, ptr %min, align 4
  %.pre = load float, ptr %max, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %36 = phi float [ %.pre, %if.then ], [ %28, %for.body ]
  %cmp14 = fcmp ogt float %34, %36
  br i1 %cmp14, label %if.then15, label %for.inc

if.then15:                                        ; preds = %if.end
  store float %34, ptr %max, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then15
  %37 = phi float [ %36, %if.end ], [ %34, %if.then15 ]
  %inc = add nuw nsw i32 %i.030, 1
  %exitcond.not = icmp eq i32 %inc, %0
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !9

for.end:                                          ; preds = %for.inc, %entry
  %38 = phi float [ 0xC7EFFFFFE0000000, %entry ], [ %37, %for.inc ]
  %39 = load float, ptr %min, align 4
  %cmp20 = fcmp ogt float %39, %38
  br i1 %cmp20, label %if.then21, label %if.end26

if.then21:                                        ; preds = %for.end
  store float %38, ptr %min, align 4
  store float %39, ptr %max, align 4
  %.pre31 = load float, ptr %min, align 4
  br label %if.end26

if.end26:                                         ; preds = %if.then21, %for.end
  %40 = phi float [ %.pre31, %if.then21 ], [ %39, %for.end ]
  %mul5.i.i = fmul float %8, %26
  %41 = tail call float @llvm.fmuladd.f32(float %25, float %5, float %mul5.i.i)
  %42 = tail call noundef float @llvm.fmuladd.f32(float %27, float %6, float %41)
  %add28 = fadd float %42, %40
  store float %add28, ptr %min, align 4
  %43 = load float, ptr %max, align 4
  %add30 = fadd float %42, %43
  store float %add30, ptr %max, align 4
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local void @_Z33b3FindConcaveSeparatingAxisKernelP6b3Int4PK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataPK9b3Vector3SC_PK9b3GpuFacePKiPK15b3GpuChildShapeP6b3AabbPSA_S0_SN_SN_SN_Piiii(ptr nocapture noundef %concavePairs, ptr nocapture noundef readonly %rigidBodies, ptr nocapture noundef readonly %collidables, ptr noundef %convexShapes, ptr noundef %vertices, ptr nocapture noundef readonly %uniqueEdges, ptr noundef %faces, ptr noundef %indices, ptr nocapture noundef readonly %gpuChildShapes, ptr nocapture noundef readonly %aabbs, ptr nocapture noundef writeonly %concaveSeparatingNormalsOut, ptr noundef %clippingFacesOut, ptr noundef %worldVertsA1Out, ptr noundef %worldNormalsA1Out, ptr noundef %worldVertsB1Out, ptr nocapture noundef writeonly %hasSeparatingNormals, i32 noundef %vertexFaceCapacity, i32 %numConcavePairs, i32 noundef %pairIdx) local_unnamed_addr #5 {
entry:
  %convexPolyhedronA = alloca %struct.b3ConvexPolyhedronData, align 16
  %verticesA = alloca [3 x %class.b3Vector3], align 16
  %dmin = alloca float, align 4
  %sepAxis = alloca %class.b3Vector3, align 16
  %uniqueEdgesA = alloca [3 x %class.b3Vector3], align 16
  %facesA = alloca [5 x %struct.b3GpuFace], align 16
  %indicesA = alloca [12 x i32], align 16
  %posA = alloca %class.b3Vector3, align 16
  %posB = alloca %class.b3Vector3, align 16
  %ornA = alloca %class.b3Quaternion, align 16
  %ornB = alloca %class.b3Quaternion, align 16
  %DeltaC2 = alloca %class.b3Vector3, align 16
  %idxprom = sext i32 %pairIdx to i64
  %arrayidx = getelementptr inbounds %struct.b3Int4, ptr %concavePairs, i64 %idxprom
  %0 = load i32, ptr %arrayidx, align 16
  %y = getelementptr inbounds %struct.anon, ptr %arrayidx, i64 0, i32 1
  %1 = load i32, ptr %y, align 4
  %idxprom3 = sext i32 %0 to i64
  %arrayidx4 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom3
  %idxprom5 = sext i32 %1 to i64
  %arrayidx6 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom5
  %m_collidableIdx7 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom5, i32 4
  %2 = load i32, ptr %m_collidableIdx7, align 16
  %idxprom10 = sext i32 %2 to i64
  %3 = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom10, i32 3
  %4 = load i32, ptr %3, align 4
  %m_shapeType = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom10, i32 2
  %5 = load i32, ptr %m_shapeType, align 4
  switch i32 %5, label %if.then [
    i32 3, label %if.end
    i32 6, label %if.end
  ]

if.then:                                          ; preds = %entry
  %w = getelementptr inbounds %struct.anon, ptr %arrayidx, i64 0, i32 3
  store i32 -1, ptr %w, align 4
  br label %if.end374

if.end:                                           ; preds = %entry, %entry
  %m_collidableIdx = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom3, i32 4
  %6 = load i32, ptr %m_collidableIdx, align 16
  %idxprom8 = sext i32 %6 to i64
  %7 = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom8, i32 3
  %8 = load i32, ptr %7, align 4
  %arrayidx21 = getelementptr inbounds i32, ptr %hasSeparatingNormals, i64 %idxprom
  store i32 0, ptr %arrayidx21, align 4
  %z = getelementptr inbounds %struct.anon, ptr %arrayidx, i64 0, i32 2
  %9 = load i32, ptr %z, align 8
  %m_numVertices = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexPolyhedronA, i64 0, i32 7
  store i32 3, ptr %m_numVertices, align 4
  %m_vertexOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexPolyhedronA, i64 0, i32 8
  store i32 0, ptr %m_vertexOffset, align 16
  %idxprom25 = sext i32 %8 to i64
  %m_faceOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexShapes, i64 %idxprom25, i32 5
  %10 = load i32, ptr %m_faceOffset, align 4
  %add = add nsw i32 %10, %9
  %idxprom27 = sext i32 %add to i64
  %arrayidx28 = getelementptr inbounds %struct.b3GpuFace, ptr %faces, i64 %idxprom27
  %face.sroa.0.0.copyload = load float, ptr %arrayidx28, align 16
  %face.sroa.2.0.arrayidx28.sroa_idx = getelementptr inbounds i8, ptr %arrayidx28, i64 4
  %11 = load <2 x float>, ptr %face.sroa.2.0.arrayidx28.sroa_idx, align 4
  %face.sroa.4.0.arrayidx28.sroa_idx = getelementptr inbounds i8, ptr %arrayidx28, i64 12
  %face.sroa.4.0.copyload = load float, ptr %face.sroa.4.0.arrayidx28.sroa_idx, align 4
  %face.sroa.5.0.arrayidx28.sroa_idx = getelementptr inbounds i8, ptr %arrayidx28, i64 16
  %face.sroa.5.0.copyload = load i32, ptr %face.sroa.5.0.arrayidx28.sroa_idx, align 16
  %m_vertexOffset43 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexShapes, i64 %idxprom25, i32 8
  %12 = load i32, ptr %m_vertexOffset43, align 16
  %13 = sext i32 %face.sroa.5.0.copyload to i64
  %invariant.gep = getelementptr i32, ptr %indices, i64 %13
  br label %for.body

for.body:                                         ; preds = %if.end, %for.body
  %indvars.iv = phi i64 [ 0, %if.end ], [ %indvars.iv.next, %for.body ]
  %localCenter.sroa.7.0363 = phi <2 x float> [ zeroinitializer, %if.end ], [ %localCenter.sroa.7.8.vec.insert, %for.body ]
  %localCenter.sroa.0.0362 = phi <2 x float> [ zeroinitializer, %if.end ], [ %16, %for.body ]
  %triAabb.sroa.14.0361 = phi <2 x float> [ <float 0xC6293E5940000000, float 0.000000e+00>, %if.end ], [ %retval.sroa.6.1.i134, %for.body ]
  %triAabb.sroa.9.0360 = phi <2 x float> [ <float 0xC6293E5940000000, float 0xC6293E5940000000>, %if.end ], [ %retval.sroa.0.1.i124, %for.body ]
  %triAabb.sroa.5.0359 = phi <2 x float> [ <float 0x46293E5940000000, float 0.000000e+00>, %if.end ], [ %retval.sroa.6.1.i, %for.body ]
  %triAabb.sroa.0.0358 = phi <2 x float> [ <float 0x46293E5940000000, float 0x46293E5940000000>, %if.end ], [ %retval.sroa.0.1.i, %for.body ]
  %gep = getelementptr i32, ptr %invariant.gep, i64 %indvars.iv
  %14 = load i32, ptr %gep, align 4
  %add44 = add nsw i32 %12, %14
  %idxprom45 = sext i32 %add44 to i64
  %arrayidx46 = getelementptr inbounds %class.b3Vector3, ptr %vertices, i64 %idxprom45
  %vert.sroa.8.0.arrayidx46.sroa_idx = getelementptr inbounds i8, ptr %arrayidx46, i64 8
  %vert.sroa.8.0.copyload = load float, ptr %vert.sroa.8.0.arrayidx46.sroa_idx, align 8
  %vert.sroa.11.0.arrayidx46.sroa_idx = getelementptr inbounds i8, ptr %arrayidx46, i64 12
  %vert.sroa.11.0.copyload = load float, ptr %vert.sroa.11.0.arrayidx46.sroa_idx, align 4
  %arrayidx48 = getelementptr inbounds [3 x %class.b3Vector3], ptr %verticesA, i64 0, i64 %indvars.iv
  %vert.sroa.8.0.arrayidx48.sroa_idx = getelementptr inbounds i8, ptr %arrayidx48, i64 8
  store float %vert.sroa.8.0.copyload, ptr %vert.sroa.8.0.arrayidx48.sroa_idx, align 8
  %vert.sroa.11.0.arrayidx48.sroa_idx = getelementptr inbounds i8, ptr %arrayidx48, i64 12
  store float %vert.sroa.11.0.copyload, ptr %vert.sroa.11.0.arrayidx48.sroa_idx, align 4
  %15 = load <2 x float>, ptr %arrayidx46, align 16
  store <2 x float> %15, ptr %arrayidx48, align 16
  %16 = fadd <2 x float> %localCenter.sroa.0.0362, %15
  %localCenter.sroa.7.8.vec.extract = extractelement <2 x float> %localCenter.sroa.7.0363, i64 0
  %add8.i = fadd float %localCenter.sroa.7.8.vec.extract, %vert.sroa.8.0.copyload
  %localCenter.sroa.7.8.vec.insert = insertelement <2 x float> %localCenter.sroa.7.0363, float %add8.i, i64 0
  %retval.sroa.0.0.vec.extract.i = extractelement <2 x float> %triAabb.sroa.0.0358, i64 0
  %17 = extractelement <2 x float> %15, i64 0
  %cmp.i.i.i = fcmp olt float %17, %retval.sroa.0.0.vec.extract.i
  %sel = select i1 %cmp.i.i.i, <2 x float> %15, <2 x float> %triAabb.sroa.0.0358
  %retval.sroa.0.0.i = shufflevector <2 x float> %sel, <2 x float> %triAabb.sroa.0.0358, <2 x i32> <i32 0, i32 3>
  %retval.sroa.0.4.vec.extract.i = extractelement <2 x float> %triAabb.sroa.0.0358, i64 1
  %18 = extractelement <2 x float> %15, i64 1
  %cmp.i4.i.i = fcmp olt float %18, %retval.sroa.0.4.vec.extract.i
  %sel400 = select i1 %cmp.i4.i.i, <2 x float> %15, <2 x float> %retval.sroa.0.0.i
  %retval.sroa.0.1.i = shufflevector <2 x float> %retval.sroa.0.0.i, <2 x float> %sel400, <2 x i32> <i32 0, i32 3>
  %retval.sroa.6.8.vec.extract.i = extractelement <2 x float> %triAabb.sroa.5.0359, i64 0
  %cmp.i7.i.i = fcmp olt float %vert.sroa.8.0.copyload, %retval.sroa.6.8.vec.extract.i
  %retval.sroa.6.8.vec.insert.i = insertelement <2 x float> %triAabb.sroa.5.0359, float %vert.sroa.8.0.copyload, i64 0
  %retval.sroa.6.0.i = select i1 %cmp.i7.i.i, <2 x float> %retval.sroa.6.8.vec.insert.i, <2 x float> %triAabb.sroa.5.0359
  %retval.sroa.6.12.vec.extract.i = extractelement <2 x float> %retval.sroa.6.0.i, i64 1
  %cmp.i10.i.i = fcmp olt float %vert.sroa.11.0.copyload, %retval.sroa.6.12.vec.extract.i
  %retval.sroa.6.12.vec.insert.i = insertelement <2 x float> %retval.sroa.6.0.i, float %vert.sroa.11.0.copyload, i64 1
  %retval.sroa.6.1.i = select i1 %cmp.i10.i.i, <2 x float> %retval.sroa.6.12.vec.insert.i, <2 x float> %retval.sroa.6.0.i
  %retval.sroa.0.0.vec.extract.i116 = extractelement <2 x float> %triAabb.sroa.9.0360, i64 0
  %cmp.i.i.i117 = fcmp olt float %retval.sroa.0.0.vec.extract.i116, %17
  %sel401 = select i1 %cmp.i.i.i117, <2 x float> %15, <2 x float> %triAabb.sroa.9.0360
  %retval.sroa.0.0.i119 = shufflevector <2 x float> %sel401, <2 x float> %triAabb.sroa.9.0360, <2 x i32> <i32 0, i32 3>
  %retval.sroa.0.4.vec.extract.i121 = extractelement <2 x float> %triAabb.sroa.9.0360, i64 1
  %cmp.i4.i.i122 = fcmp olt float %retval.sroa.0.4.vec.extract.i121, %18
  %sel402 = select i1 %cmp.i4.i.i122, <2 x float> %15, <2 x float> %retval.sroa.0.0.i119
  %retval.sroa.0.1.i124 = shufflevector <2 x float> %retval.sroa.0.0.i119, <2 x float> %sel402, <2 x i32> <i32 0, i32 3>
  %retval.sroa.6.8.vec.extract.i126 = extractelement <2 x float> %triAabb.sroa.14.0361, i64 0
  %cmp.i7.i.i127 = fcmp olt float %retval.sroa.6.8.vec.extract.i126, %vert.sroa.8.0.copyload
  %retval.sroa.6.8.vec.insert.i128 = insertelement <2 x float> %triAabb.sroa.14.0361, float %vert.sroa.8.0.copyload, i64 0
  %retval.sroa.6.0.i129 = select i1 %cmp.i7.i.i127, <2 x float> %retval.sroa.6.8.vec.insert.i128, <2 x float> %triAabb.sroa.14.0361
  %retval.sroa.6.12.vec.extract.i131 = extractelement <2 x float> %retval.sroa.6.0.i129, i64 1
  %cmp.i10.i.i132 = fcmp olt float %retval.sroa.6.12.vec.extract.i131, %vert.sroa.11.0.copyload
  %retval.sroa.6.12.vec.insert.i133 = insertelement <2 x float> %retval.sroa.6.0.i129, float %vert.sroa.11.0.copyload, i64 1
  %retval.sroa.6.1.i134 = select i1 %cmp.i10.i.i132, <2 x float> %retval.sroa.6.12.vec.insert.i133, <2 x float> %retval.sroa.6.0.i129
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 3
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !14

for.end:                                          ; preds = %for.body
  %triAabb.sroa.0.0.vec.extract = extractelement <2 x float> %sel, i64 0
  %arrayidx60 = getelementptr inbounds %struct.b3Aabb, ptr %aabbs, i64 %idxprom5
  %19 = getelementptr inbounds %struct.b3Aabb, ptr %aabbs, i64 %idxprom5, i32 1
  %20 = load float, ptr %19, align 16
  %cmp62 = fcmp ogt float %triAabb.sroa.0.0.vec.extract, %20
  br i1 %cmp62, label %cond.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end
  %triAabb.sroa.9.16.vec.extract = extractelement <2 x float> %sel401, i64 0
  %21 = load float, ptr %arrayidx60, align 16
  %cmp67 = fcmp olt float %triAabb.sroa.9.16.vec.extract, %21
  br i1 %cmp67, label %cond.end, label %cond.false

cond.false:                                       ; preds = %lor.lhs.false
  br label %cond.end

cond.end:                                         ; preds = %for.end, %lor.lhs.false, %cond.false
  %cond = phi i1 [ false, %cond.false ], [ true, %lor.lhs.false ], [ true, %for.end ]
  %triAabb.sroa.5.8.vec.extract = extractelement <2 x float> %retval.sroa.6.1.i, i64 0
  %z71 = getelementptr inbounds %struct.anon.2, ptr %19, i64 0, i32 2
  %22 = load float, ptr %z71, align 8
  %cmp72 = fcmp ogt float %triAabb.sroa.5.8.vec.extract, %22
  br i1 %cmp72, label %cond.end82, label %lor.lhs.false73

lor.lhs.false73:                                  ; preds = %cond.end
  %triAabb.sroa.14.24.vec.extract = extractelement <2 x float> %retval.sroa.6.1.i134, i64 0
  %z77 = getelementptr inbounds %struct.anon.2, ptr %arrayidx60, i64 0, i32 2
  %23 = load float, ptr %z77, align 8
  %cmp78 = fcmp olt float %triAabb.sroa.14.24.vec.extract, %23
  br i1 %cmp78, label %cond.end82, label %cond.false80

cond.false80:                                     ; preds = %lor.lhs.false73
  br label %cond.end82

cond.end82:                                       ; preds = %cond.end, %lor.lhs.false73, %cond.false80
  %cond83 = phi i1 [ %cond, %cond.false80 ], [ true, %lor.lhs.false73 ], [ true, %cond.end ]
  %triAabb.sroa.0.4.vec.extract = extractelement <2 x float> %sel400, i64 1
  %y88 = getelementptr inbounds %struct.anon.2, ptr %19, i64 0, i32 1
  %24 = load float, ptr %y88, align 4
  %cmp89 = fcmp ogt float %triAabb.sroa.0.4.vec.extract, %24
  br i1 %cmp89, label %if.else370, label %lor.lhs.false90

lor.lhs.false90:                                  ; preds = %cond.end82
  %triAabb.sroa.9.20.vec.extract = extractelement <2 x float> %sel402, i64 1
  %y94 = getelementptr inbounds %struct.anon.2, ptr %arrayidx60, i64 0, i32 1
  %25 = load float, ptr %y94, align 4
  %cmp95 = fcmp olt float %triAabb.sroa.9.20.vec.extract, %25
  %brmerge = or i1 %cond83, %cmp95
  br i1 %brmerge, label %if.else370, label %if.then103

if.then103:                                       ; preds = %lor.lhs.false90
  store float 0x47EFFFFFE0000000, ptr %dmin, align 4
  store <2 x float> <float 1.000000e+00, float 2.000000e+00>, ptr %sepAxis, align 16
  %26 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %sepAxis, i64 0, i32 1
  store <2 x float> <float 3.000000e+00, float 4.000000e+00>, ptr %26, align 8
  %m_numUniqueEdges = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexPolyhedronA, i64 0, i32 10
  store i32 3, ptr %m_numUniqueEdges, align 8
  %m_uniqueEdgesOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexPolyhedronA, i64 0, i32 9
  store i32 0, ptr %m_uniqueEdgesOffset, align 4
  %arrayidx109 = getelementptr inbounds [3 x %class.b3Vector3], ptr %verticesA, i64 0, i64 1
  %27 = load <2 x float>, ptr %arrayidx109, align 16
  %28 = load <2 x float>, ptr %verticesA, align 16
  %29 = fsub <2 x float> %27, %28
  %arrayidx5.i = getelementptr inbounds [3 x %class.b3Vector3], ptr %verticesA, i64 0, i64 1, i32 0, i32 0, i64 2
  %30 = load float, ptr %arrayidx5.i, align 8
  %arrayidx6.i138 = getelementptr inbounds [4 x float], ptr %verticesA, i64 0, i64 2
  %31 = load float, ptr %arrayidx6.i138, align 8
  %sub7.i = fsub float %30, %31
  %retval.sroa.3.12.vec.insert.i.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %sub7.i, i64 0
  store <2 x float> %29, ptr %uniqueEdgesA, align 16
  %ref.tmp108.sroa.2.0.arrayidx114.sroa_idx = getelementptr inbounds i8, ptr %uniqueEdgesA, i64 8
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i, ptr %ref.tmp108.sroa.2.0.arrayidx114.sroa_idx, align 8
  %arrayidx116 = getelementptr inbounds [3 x %class.b3Vector3], ptr %verticesA, i64 0, i64 2
  %32 = load <2 x float>, ptr %arrayidx116, align 16
  %33 = fsub <2 x float> %32, %27
  %arrayidx5.i143 = getelementptr inbounds [3 x %class.b3Vector3], ptr %verticesA, i64 0, i64 2, i32 0, i32 0, i64 2
  %34 = load float, ptr %arrayidx5.i143, align 8
  %sub7.i145 = fsub float %34, %30
  %retval.sroa.3.12.vec.insert.i.i148 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %sub7.i145, i64 0
  %arrayidx121 = getelementptr inbounds [3 x %class.b3Vector3], ptr %uniqueEdgesA, i64 0, i64 1
  store <2 x float> %33, ptr %arrayidx121, align 16
  %ref.tmp115.sroa.2.0.arrayidx121.sroa_idx = getelementptr inbounds [3 x %class.b3Vector3], ptr %uniqueEdgesA, i64 0, i64 1, i32 0, i32 0, i64 2
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i148, ptr %ref.tmp115.sroa.2.0.arrayidx121.sroa_idx, align 8
  %35 = fsub <2 x float> %28, %32
  %sub7.i157 = fsub float %31, %34
  %retval.sroa.3.12.vec.insert.i.i160 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %sub7.i157, i64 0
  %arrayidx128 = getelementptr inbounds [3 x %class.b3Vector3], ptr %uniqueEdgesA, i64 0, i64 2
  store <2 x float> %35, ptr %arrayidx128, align 16
  %ref.tmp122.sroa.2.0.arrayidx128.sroa_idx = getelementptr inbounds [3 x %class.b3Vector3], ptr %uniqueEdgesA, i64 0, i64 2, i32 0, i32 0, i64 2
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i160, ptr %ref.tmp122.sroa.2.0.arrayidx128.sroa_idx, align 8
  %m_faceOffset129 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexPolyhedronA, i64 0, i32 5
  store i32 0, ptr %m_faceOffset129, align 4
  %m_indexOffset140 = getelementptr inbounds %struct.b3GpuFace, ptr %facesA, i64 0, i32 1
  store i32 0, ptr %m_indexOffset140, align 16
  store float %face.sroa.0.0.copyload, ptr %facesA, align 16
  %y156 = getelementptr inbounds %struct.anon.2, ptr %facesA, i64 0, i32 1
  store <2 x float> %11, ptr %y156, align 4
  %w165 = getelementptr inbounds %struct.anon.2, ptr %facesA, i64 0, i32 3
  store float %face.sroa.4.0.copyload, ptr %w165, align 4
  %m_numIndices = getelementptr inbounds %struct.b3GpuFace, ptr %facesA, i64 0, i32 2
  store i32 3, ptr %m_numIndices, align 4
  %arrayidx170 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 1
  %m_indexOffset171 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 1, i32 1
  store i32 3, ptr %m_indexOffset171, align 16
  store <4 x i32> <i32 0, i32 1, i32 2, i32 2>, ptr %indicesA, align 16
  %arrayidx173 = getelementptr inbounds [12 x i32], ptr %indicesA, i64 0, i64 4
  store i32 1, ptr %arrayidx173, align 16
  %arrayidx174 = getelementptr inbounds [12 x i32], ptr %indicesA, i64 0, i64 5
  store i32 0, ptr %arrayidx174, align 4
  %36 = extractelement <2 x float> %11, i64 0
  %shift = shufflevector <2 x float> %28, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %37 = fmul <2 x float> %11, %shift
  %mul5.i.i = extractelement <2 x float> %37, i64 0
  %38 = extractelement <2 x float> %28, i64 0
  %39 = tail call float @llvm.fmuladd.f32(float %face.sroa.0.0.copyload, float %38, float %mul5.i.i)
  %40 = extractelement <2 x float> %11, i64 1
  %41 = tail call noundef float @llvm.fmuladd.f32(float %40, float %31, float %39)
  %42 = insertelement <2 x float> %11, float %face.sroa.0.0.copyload, i64 0
  %43 = fneg <2 x float> %42
  %44 = extractelement <2 x float> %43, i64 0
  store float %44, ptr %arrayidx170, align 16
  %fneg185 = fneg float %36
  %y189 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 1, i32 0, i32 0, i32 0, i64 1
  store float %fneg185, ptr %y189, align 4
  %z195 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 1, i32 0, i32 0, i32 0, i64 2
  %45 = extractelement <2 x float> %43, i64 1
  store float %45, ptr %z195, align 8
  %w199 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 1, i32 0, i32 0, i32 0, i64 3
  store float %41, ptr %w199, align 4
  %m_numIndices202 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 1, i32 2
  store i32 3, ptr %m_numIndices202, align 4
  br label %for.body209

for.body209:                                      ; preds = %if.then103, %for.body209
  %indvars.iv376 = phi i64 [ 0, %if.then103 ], [ %indvars.iv.next377, %for.body209 ]
  %indvars.iv374 = phi i64 [ 2, %if.then103 ], [ %indvars.iv.next375, %for.body209 ]
  %indvars.iv371 = phi i64 [ 6, %if.then103 ], [ %indvars.iv.next372, %for.body209 ]
  %prevVertex.0366 = phi i32 [ 2, %if.then103 ], [ %48, %for.body209 ]
  %arrayidx211 = getelementptr inbounds [3 x %class.b3Vector3], ptr %verticesA, i64 0, i64 %indvars.iv376
  %v0.sroa.0.0.copyload = load float, ptr %arrayidx211, align 16
  %v0.sroa.3.0.arrayidx211.sroa_idx = getelementptr inbounds i8, ptr %arrayidx211, i64 4
  %v0.sroa.3.0.copyload = load float, ptr %v0.sroa.3.0.arrayidx211.sroa_idx, align 4
  %v0.sroa.5.0.arrayidx211.sroa_idx = getelementptr inbounds i8, ptr %arrayidx211, i64 8
  %v0.sroa.5.0.copyload = load float, ptr %v0.sroa.5.0.arrayidx211.sroa_idx, align 8
  %idxprom212 = zext nneg i32 %prevVertex.0366 to i64
  %arrayidx213 = getelementptr inbounds [3 x %class.b3Vector3], ptr %verticesA, i64 0, i64 %idxprom212
  %v1.sroa.0.0.copyload = load float, ptr %arrayidx213, align 16
  %v1.sroa.2.0.arrayidx213.sroa_idx = getelementptr inbounds i8, ptr %arrayidx213, i64 4
  %v1.sroa.2.0.copyload = load float, ptr %v1.sroa.2.0.arrayidx213.sroa_idx, align 4
  %v1.sroa.3.0.arrayidx213.sroa_idx = getelementptr inbounds i8, ptr %arrayidx213, i64 8
  %v1.sroa.3.0.copyload = load float, ptr %v1.sroa.3.0.arrayidx213.sroa_idx, align 8
  %sub4.i172 = fsub float %v1.sroa.2.0.copyload, %v0.sroa.3.0.copyload
  %arrayidx229 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 %indvars.iv374
  %m_numIndices230 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 %indvars.iv374, i32 2
  store i32 2, ptr %m_numIndices230, align 4
  %m_indexOffset233 = getelementptr inbounds [5 x %struct.b3GpuFace], ptr %facesA, i64 0, i64 %indvars.iv374, i32 1
  %46 = trunc i64 %indvars.iv371 to i32
  store i32 %46, ptr %m_indexOffset233, align 16
  %47 = or disjoint i64 %indvars.iv371, 1
  %arrayidx236 = getelementptr inbounds [12 x i32], ptr %indicesA, i64 0, i64 %indvars.iv371
  %48 = trunc i64 %indvars.iv376 to i32
  store i32 %48, ptr %arrayidx236, align 8
  %indvars.iv.next372 = add nuw nsw i64 %indvars.iv371, 2
  %arrayidx239 = getelementptr inbounds [12 x i32], ptr %indicesA, i64 0, i64 %47
  store i32 %prevVertex.0366, ptr %arrayidx239, align 4
  %49 = insertelement <2 x float> poison, float %v1.sroa.3.0.copyload, i64 0
  %50 = insertelement <2 x float> %49, float %v1.sroa.0.0.copyload, i64 1
  %51 = insertelement <2 x float> poison, float %v0.sroa.5.0.copyload, i64 0
  %52 = insertelement <2 x float> %51, float %v0.sroa.0.0.copyload, i64 1
  %53 = fsub <2 x float> %50, %52
  %54 = insertelement <2 x float> %53, float %sub4.i172, i64 1
  %55 = fmul <2 x float> %54, %43
  %56 = shufflevector <2 x float> %55, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %57 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %11, <2 x float> %53, <2 x float> %56)
  %58 = extractelement <2 x float> %53, i64 1
  %neg17.i.i = fmul float %58, %fneg185
  %59 = tail call float @llvm.fmuladd.f32(float %face.sroa.0.0.copyload, float %sub4.i172, float %neg17.i.i)
  %60 = fmul <2 x float> %57, %57
  %mul5.i.i.i.i.i = extractelement <2 x float> %60, i64 1
  %61 = extractelement <2 x float> %57, i64 0
  %62 = tail call float @llvm.fmuladd.f32(float %61, float %61, float %mul5.i.i.i.i.i)
  %63 = tail call noundef float @llvm.fmuladd.f32(float %59, float %59, float %62)
  %sqrt.i.i.i = tail call noundef float @llvm.sqrt.f32(float %63)
  %div.i.i.i = fdiv float 1.000000e+00, %sqrt.i.i.i
  %64 = insertelement <2 x float> poison, float %div.i.i.i, i64 0
  %65 = shufflevector <2 x float> %64, <2 x float> poison, <2 x i32> zeroinitializer
  %66 = fmul <2 x float> %57, %65
  %mul4.i.i.i.i = fmul float %59, %div.i.i.i
  %67 = extractelement <2 x float> %66, i64 1
  %mul5.i.i185 = fmul float %v0.sroa.3.0.copyload, %67
  %68 = extractelement <2 x float> %66, i64 0
  %69 = tail call float @llvm.fmuladd.f32(float %68, float %v0.sroa.0.0.copyload, float %mul5.i.i185)
  %70 = tail call noundef float @llvm.fmuladd.f32(float %mul4.i.i.i.i, float %v0.sroa.5.0.copyload, float %69)
  %fneg227 = fneg float %70
  store <2 x float> %66, ptr %arrayidx229, align 16
  %z254 = getelementptr inbounds %struct.anon.2, ptr %arrayidx229, i64 0, i32 2
  store float %mul4.i.i.i.i, ptr %z254, align 8
  %w258 = getelementptr inbounds %struct.anon.2, ptr %arrayidx229, i64 0, i32 3
  store float %fneg227, ptr %w258, align 4
  %indvars.iv.next375 = add nuw nsw i64 %indvars.iv374, 1
  %indvars.iv.next377 = add nuw nsw i64 %indvars.iv376, 1
  %exitcond383.not = icmp eq i64 %indvars.iv.next377, 3
  br i1 %exitcond383.not, label %if.end263, label %for.body209, !llvm.loop !15

if.end263:                                        ; preds = %for.body209
  %m_numFaces = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexPolyhedronA, i64 0, i32 6
  store i32 5, ptr %m_numFaces, align 8
  %71 = fmul <2 x float> %16, <float 0x3FD5555560000000, float 0x3FD5555560000000>
  %mul4.i = fmul float %add8.i, 0x3FD5555560000000
  %retval.sroa.3.12.vec.insert.i.i191 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %mul4.i, i64 0
  store <2 x float> %71, ptr %convexPolyhedronA, align 16
  %ref.tmp264.sroa.2.0.m_localCenter.sroa_idx = getelementptr inbounds i8, ptr %convexPolyhedronA, i64 8
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i191, ptr %ref.tmp264.sroa.2.0.m_localCenter.sroa_idx, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx4, i64 16, i1 false)
  %w271 = getelementptr inbounds %struct.anon.2, ptr %posA, i64 0, i32 3
  store float 0.000000e+00, ptr %w271, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx6, i64 16, i1 false)
  %w275 = getelementptr inbounds %struct.anon.2, ptr %posB, i64 0, i32 3
  store float 0.000000e+00, ptr %w275, align 4
  %m_quat = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom3, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %m_quat, i64 16, i1 false)
  %m_quat280 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom5, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %m_quat280, i64 16, i1 false)
  %72 = load i32, ptr %m_shapeType, align 4
  %cmp284 = icmp eq i32 %72, 6
  %tr.sroa.21.48.copyload.i248.pre = load float, ptr %posB, align 16
  br i1 %cmp284, label %if.then285, label %if.end263.if.end304_crit_edge

if.end263.if.end304_crit_edge:                    ; preds = %if.end263
  %tr.sroa.23.48.translation.sroa_idx.i249.phi.trans.insert = getelementptr inbounds i8, ptr %posB, i64 4
  %tr.sroa.23.48.copyload.i250.pre = load float, ptr %tr.sroa.23.48.translation.sroa_idx.i249.phi.trans.insert, align 4
  %tr.sroa.24.48.translation.sroa_idx.i251.phi.trans.insert = getelementptr inbounds i8, ptr %posB, i64 8
  %tr.sroa.24.48.copyload.i252.pre = load float, ptr %tr.sroa.24.48.translation.sroa_idx.i251.phi.trans.insert, align 8
  %73 = load <4 x float>, ptr %ornB, align 16
  br label %if.end304

if.then285:                                       ; preds = %if.end263
  %w288 = getelementptr inbounds %struct.anon, ptr %arrayidx, i64 0, i32 3
  %74 = load i32, ptr %w288, align 4
  %idxprom289 = sext i32 %74 to i64
  %arrayidx290 = getelementptr inbounds %struct.b3GpuChildShape, ptr %gpuChildShapes, i64 %idxprom289
  %75 = getelementptr inbounds %struct.b3GpuChildShape, ptr %gpuChildShapes, i64 %idxprom289, i32 2
  %76 = load i32, ptr %75, align 16
  %childPosB.sroa.0.0.copyload = load float, ptr %arrayidx290, align 16
  %childPosB.sroa.2.0.arrayidx290.sroa_idx = getelementptr inbounds i8, ptr %arrayidx290, i64 4
  %childPosB.sroa.2.0.copyload = load float, ptr %childPosB.sroa.2.0.arrayidx290.sroa_idx, align 4
  %childPosB.sroa.3.0.arrayidx290.sroa_idx = getelementptr inbounds i8, ptr %arrayidx290, i64 8
  %childPosB.sroa.3.0.copyload = load float, ptr %childPosB.sroa.3.0.arrayidx290.sroa_idx, align 8
  %m_childOrientation = getelementptr inbounds %struct.b3GpuChildShape, ptr %gpuChildShapes, i64 %idxprom289, i32 1
  %tr.sroa.23.48.translation.sroa_idx.i = getelementptr inbounds i8, ptr %posB, i64 4
  %tr.sroa.23.48.copyload.i = load float, ptr %tr.sroa.23.48.translation.sroa_idx.i, align 4
  %tr.sroa.24.48.translation.sroa_idx.i = getelementptr inbounds i8, ptr %posB, i64 8
  %tr.sroa.24.48.copyload.i = load float, ptr %tr.sroa.24.48.translation.sroa_idx.i, align 8
  %arrayidx5.i.i.i.i.i = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 2
  %77 = load float, ptr %arrayidx5.i.i.i.i.i, align 8
  %arrayidx7.i.i.i.i.i = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 3
  %78 = load float, ptr %arrayidx7.i.i.i.i.i, align 4
  %79 = load <2 x float>, ptr %ornB, align 16
  %80 = extractelement <2 x float> %79, i64 1
  %mul4.i.i.i.i.i = fmul float %80, %80
  %81 = extractelement <2 x float> %79, i64 0
  %82 = tail call float @llvm.fmuladd.f32(float %81, float %81, float %mul4.i.i.i.i.i)
  %83 = tail call float @llvm.fmuladd.f32(float %77, float %77, float %82)
  %84 = tail call noundef float @llvm.fmuladd.f32(float %78, float %78, float %83)
  %div.i.i.i194 = fdiv float 2.000000e+00, %84
  %85 = insertelement <2 x float> poison, float %div.i.i.i194, i64 0
  %86 = shufflevector <2 x float> %85, <2 x float> poison, <2 x i32> zeroinitializer
  %87 = fmul <2 x float> %79, %86
  %mul6.i.i.i = fmul float %77, %div.i.i.i194
  %88 = extractelement <2 x float> %87, i64 0
  %mul8.i.i.i = fmul float %78, %88
  %89 = extractelement <2 x float> %87, i64 1
  %mul10.i.i.i = fmul float %78, %89
  %mul12.i.i.i = fmul float %78, %mul6.i.i.i
  %mul16.i.i.i = fmul float %81, %89
  %mul18.i.i.i = fmul float %81, %mul6.i.i.i
  %90 = fmul <2 x float> %79, %87
  %mul22.i.i.i = fmul float %80, %mul6.i.i.i
  %mul24.i.i.i = fmul float %77, %mul6.i.i.i
  %91 = extractelement <2 x float> %90, i64 1
  %add.i.i.i = fadd float %91, %mul24.i.i.i
  %sub.i.i.i = fsub float 1.000000e+00, %add.i.i.i
  %sub26.i.i.i = fsub float %mul16.i.i.i, %mul12.i.i.i
  %add28.i.i.i = fadd float %mul18.i.i.i, %mul10.i.i.i
  %add30.i.i.i = fadd float %mul16.i.i.i, %mul12.i.i.i
  %92 = extractelement <2 x float> %90, i64 0
  %add32.i.i.i = fadd float %92, %mul24.i.i.i
  %sub33.i.i.i = fsub float 1.000000e+00, %add32.i.i.i
  %sub35.i.i.i = fsub float %mul22.i.i.i, %mul8.i.i.i
  %sub37.i.i.i = fsub float %mul18.i.i.i, %mul10.i.i.i
  %add39.i.i.i = fadd float %mul22.i.i.i, %mul8.i.i.i
  %add41.i.i.i = fadd float %92, %91
  %sub42.i.i.i = fsub float 1.000000e+00, %add41.i.i.i
  %mul5.i.i.i.i = fmul float %childPosB.sroa.2.0.copyload, %sub26.i.i.i
  %93 = tail call float @llvm.fmuladd.f32(float %childPosB.sroa.0.0.copyload, float %sub.i.i.i, float %mul5.i.i.i.i)
  %94 = tail call noundef float @llvm.fmuladd.f32(float %childPosB.sroa.3.0.copyload, float %add28.i.i.i, float %93)
  %mul5.i3.i.i.i = fmul float %childPosB.sroa.2.0.copyload, %sub33.i.i.i
  %95 = tail call float @llvm.fmuladd.f32(float %childPosB.sroa.0.0.copyload, float %add30.i.i.i, float %mul5.i3.i.i.i)
  %96 = tail call noundef float @llvm.fmuladd.f32(float %childPosB.sroa.3.0.copyload, float %sub35.i.i.i, float %95)
  %mul5.i8.i.i.i = fmul float %childPosB.sroa.2.0.copyload, %add39.i.i.i
  %97 = tail call float @llvm.fmuladd.f32(float %childPosB.sroa.0.0.copyload, float %sub37.i.i.i, float %mul5.i8.i.i.i)
  %98 = tail call noundef float @llvm.fmuladd.f32(float %childPosB.sroa.3.0.copyload, float %sub42.i.i.i, float %97)
  %add.i.i3.i = fadd float %tr.sroa.21.48.copyload.i248.pre, %94
  %add4.i.i.i = fadd float %tr.sroa.23.48.copyload.i, %96
  %add7.i.i.i = fadd float %tr.sroa.24.48.copyload.i, %98
  %retval.sroa.0.0.vec.insert.i.i2.i.i = insertelement <2 x float> poison, float %add.i.i3.i, i64 0
  %retval.sroa.0.4.vec.insert.i.i3.i.i = insertelement <2 x float> %retval.sroa.0.0.vec.insert.i.i2.i.i, float %add4.i.i.i, i64 1
  %retval.sroa.3.12.vec.insert.i.i4.i.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %add7.i.i.i, i64 0
  %neg.i.i195 = fneg float %77
  %99 = load <4 x float>, ptr %m_childOrientation, align 16
  %100 = shufflevector <4 x float> %99, <4 x float> poison, <4 x i32> <i32 3, i32 3, i32 3, i32 0>
  %101 = shufflevector <2 x float> %79, <2 x float> poison, <4 x i32> <i32 0, i32 1, i32 poison, i32 poison>
  %102 = insertelement <4 x float> %101, float %77, i64 2
  %103 = shufflevector <2 x float> %79, <2 x float> poison, <4 x i32> <i32 0, i32 1, i32 poison, i32 poison>
  %104 = fneg <4 x float> %103
  %105 = shufflevector <4 x float> %102, <4 x float> %104, <4 x i32> <i32 0, i32 1, i32 2, i32 4>
  %106 = fmul <4 x float> %100, %105
  %107 = insertelement <4 x float> poison, float %78, i64 0
  %108 = shufflevector <4 x float> %107, <4 x float> poison, <4 x i32> zeroinitializer
  %109 = tail call <4 x float> @llvm.fmuladd.v4f32(<4 x float> %108, <4 x float> %99, <4 x float> %106)
  %110 = shufflevector <4 x float> %102, <4 x float> poison, <4 x i32> <i32 1, i32 2, i32 0, i32 poison>
  %111 = shufflevector <4 x float> %110, <4 x float> %104, <4 x i32> <i32 0, i32 1, i32 2, i32 5>
  %112 = shufflevector <4 x float> %99, <4 x float> poison, <4 x i32> <i32 2, i32 0, i32 1, i32 1>
  %113 = tail call <4 x float> @llvm.fmuladd.v4f32(<4 x float> %111, <4 x float> %112, <4 x float> %109)
  %114 = insertelement <4 x float> poison, float %neg.i.i195, i64 0
  %115 = shufflevector <4 x float> %114, <4 x float> %104, <4 x i32> <i32 0, i32 4, i32 5, i32 poison>
  %116 = shufflevector <4 x float> %115, <4 x float> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 0>
  %117 = shufflevector <4 x float> %112, <4 x float> poison, <4 x i32> <i32 2, i32 0, i32 1, i32 0>
  %118 = tail call <4 x float> @llvm.fmuladd.v4f32(<4 x float> %116, <4 x float> %117, <4 x float> %113)
  %119 = shufflevector <4 x float> %118, <4 x float> poison, <2 x i32> <i32 0, i32 1>
  %120 = shufflevector <4 x float> %118, <4 x float> poison, <2 x i32> <i32 2, i32 3>
  store <2 x float> %retval.sroa.0.4.vec.insert.i.i3.i.i, ptr %posB, align 16
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i4.i.i, ptr %tr.sroa.24.48.translation.sroa_idx.i, align 8
  store <2 x float> %119, ptr %ornB, align 16
  store <2 x float> %120, ptr %arrayidx5.i.i.i.i.i, align 8
  %idxprom302 = sext i32 %76 to i64
  %121 = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom302, i32 3
  %122 = load i32, ptr %121, align 4
  %123 = load <2 x float>, ptr %convexPolyhedronA, align 16
  %c0local.sroa.3.0.copyload.pre = load float, ptr %ref.tmp264.sroa.2.0.m_localCenter.sroa_idx, align 8
  br label %if.end304

if.end304:                                        ; preds = %if.end263.if.end304_crit_edge, %if.then285
  %tr.sroa.24.48.copyload.i252 = phi float [ %add7.i.i.i, %if.then285 ], [ %tr.sroa.24.48.copyload.i252.pre, %if.end263.if.end304_crit_edge ]
  %tr.sroa.23.48.copyload.i250 = phi float [ %add4.i.i.i, %if.then285 ], [ %tr.sroa.23.48.copyload.i250.pre, %if.end263.if.end304_crit_edge ]
  %tr.sroa.21.48.copyload.i248 = phi float [ %add.i.i3.i, %if.then285 ], [ %tr.sroa.21.48.copyload.i248.pre, %if.end263.if.end304_crit_edge ]
  %c0local.sroa.3.0.copyload = phi float [ %c0local.sroa.3.0.copyload.pre, %if.then285 ], [ %mul4.i, %if.end263.if.end304_crit_edge ]
  %shapeIndexB.0 = phi i32 [ %122, %if.then285 ], [ %4, %if.end263.if.end304_crit_edge ]
  %124 = phi <4 x float> [ %118, %if.then285 ], [ %73, %if.end263.if.end304_crit_edge ]
  %125 = phi <2 x float> [ %123, %if.then285 ], [ %71, %if.end263.if.end304_crit_edge ]
  %126 = load <4 x float>, ptr %posA, align 16
  %127 = shufflevector <4 x float> %126, <4 x float> poison, <2 x i32> <i32 0, i32 poison>
  %tr.sroa.23.48.translation.sroa_idx.i202 = getelementptr inbounds i8, ptr %posA, i64 4
  %tr.sroa.23.48.copyload.i203 = load float, ptr %tr.sroa.23.48.translation.sroa_idx.i202, align 4
  %128 = shufflevector <4 x float> %126, <4 x float> poison, <2 x i32> <i32 2, i32 poison>
  %129 = load float, ptr %ornA, align 16
  %arrayidx2.i.i.i.i.i206 = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 1
  %130 = load float, ptr %arrayidx2.i.i.i.i.i206, align 4
  %arrayidx5.i.i.i.i.i208 = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 2
  %131 = load float, ptr %arrayidx5.i.i.i.i.i208, align 8
  %arrayidx7.i.i.i.i.i209 = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 3
  %132 = load float, ptr %arrayidx7.i.i.i.i.i209, align 4
  %idxprom309 = sext i32 %shapeIndexB.0 to i64
  %arrayidx310 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexShapes, i64 %idxprom309
  %c1local.sroa.0.0.copyload = load float, ptr %arrayidx310, align 16
  %c1local.sroa.2.0.arrayidx310.sroa_idx = getelementptr inbounds i8, ptr %arrayidx310, i64 4
  %c1local.sroa.2.0.copyload = load float, ptr %c1local.sroa.2.0.arrayidx310.sroa_idx, align 4
  %c1local.sroa.3.0.arrayidx310.sroa_idx = getelementptr inbounds i8, ptr %arrayidx310, i64 8
  %c1local.sroa.3.0.copyload = load float, ptr %c1local.sroa.3.0.arrayidx310.sroa_idx, align 8
  %133 = shufflevector <4 x float> %124, <4 x float> poison, <2 x i32> <i32 poison, i32 1>
  %134 = insertelement <2 x float> %133, float %130, i64 0
  %135 = fmul <2 x float> %134, %134
  %136 = shufflevector <4 x float> %124, <4 x float> poison, <2 x i32> <i32 poison, i32 0>
  %137 = insertelement <2 x float> %136, float %129, i64 0
  %138 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %137, <2 x float> %137, <2 x float> %135)
  %139 = shufflevector <4 x float> %124, <4 x float> poison, <2 x i32> <i32 poison, i32 2>
  %140 = insertelement <2 x float> %139, float %131, i64 0
  %141 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %140, <2 x float> %140, <2 x float> %138)
  %142 = shufflevector <4 x float> %124, <4 x float> poison, <2 x i32> <i32 poison, i32 3>
  %143 = insertelement <2 x float> %142, float %132, i64 0
  %144 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %143, <2 x float> %143, <2 x float> %141)
  %145 = fdiv <2 x float> <float 2.000000e+00, float 2.000000e+00>, %144
  %146 = fmul <2 x float> %140, %145
  %147 = fmul <2 x float> %134, %145
  %148 = fmul <2 x float> %134, %147
  %149 = fmul <2 x float> %143, %147
  %150 = fmul <2 x float> %137, %146
  %151 = fmul <2 x float> %137, %145
  %152 = fmul <2 x float> %137, %151
  %153 = fmul <2 x float> %143, %151
  %154 = fmul <2 x float> %134, %146
  %155 = fsub <2 x float> %150, %149
  %156 = fadd <2 x float> %154, %153
  %157 = fadd <2 x float> %152, %148
  %158 = fsub <2 x float> <float 1.000000e+00, float 1.000000e+00>, %157
  %159 = shufflevector <2 x float> %125, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %160 = insertelement <2 x float> %159, float %c1local.sroa.2.0.copyload, i64 1
  %161 = fmul <2 x float> %160, %156
  %162 = insertelement <2 x float> %125, float %c1local.sroa.0.0.copyload, i64 1
  %163 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %162, <2 x float> %155, <2 x float> %161)
  %164 = insertelement <2 x float> poison, float %c0local.sroa.3.0.copyload, i64 0
  %165 = insertelement <2 x float> %164, float %c1local.sroa.3.0.copyload, i64 1
  %166 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %165, <2 x float> %158, <2 x float> %163)
  %167 = fmul <2 x float> %140, %146
  %168 = fmul <2 x float> %143, %146
  %169 = fmul <2 x float> %137, %147
  %170 = fadd <2 x float> %169, %168
  %171 = fadd <2 x float> %152, %167
  %172 = fsub <2 x float> <float 1.000000e+00, float 1.000000e+00>, %171
  %173 = fsub <2 x float> %154, %153
  %174 = fmul <2 x float> %160, %172
  %175 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %162, <2 x float> %170, <2 x float> %174)
  %176 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %165, <2 x float> %173, <2 x float> %175)
  %177 = fadd <2 x float> %150, %149
  %178 = fadd <2 x float> %148, %167
  %179 = fsub <2 x float> <float 1.000000e+00, float 1.000000e+00>, %178
  %180 = fsub <2 x float> %169, %168
  %181 = fmul <2 x float> %160, %180
  %182 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %162, <2 x float> %179, <2 x float> %181)
  %183 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %165, <2 x float> %177, <2 x float> %182)
  %184 = insertelement <2 x float> %127, float %tr.sroa.21.48.copyload.i248, i64 1
  %185 = fadd <2 x float> %184, %183
  %186 = insertelement <2 x float> poison, float %tr.sroa.23.48.copyload.i203, i64 0
  %187 = insertelement <2 x float> %186, float %tr.sroa.23.48.copyload.i250, i64 1
  %188 = fadd <2 x float> %187, %176
  %189 = insertelement <2 x float> %128, float %tr.sroa.24.48.copyload.i252, i64 1
  %190 = fadd <2 x float> %189, %166
  %shift397 = shufflevector <2 x float> %185, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %191 = fsub <2 x float> %185, %shift397
  %shift398 = shufflevector <2 x float> %188, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %192 = fsub <2 x float> %188, %shift398
  %shift399 = shufflevector <2 x float> %190, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %193 = fsub <2 x float> %190, %shift399
  %retval.sroa.0.4.vec.insert.i.i303 = shufflevector <2 x float> %191, <2 x float> %192, <2 x i32> <i32 0, i32 2>
  %retval.sroa.3.12.vec.insert.i.i304403 = insertelement <2 x float> %193, float 0.000000e+00, i64 1
  store <2 x float> %retval.sroa.0.4.vec.insert.i.i303, ptr %DeltaC2, align 16
  %194 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %DeltaC2, i64 0, i32 1
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i304403, ptr %194, align 8
  %call323 = call noundef zeroext i1 @_Z20b3FindSeparatingAxisPK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_Pf(ptr noundef nonnull %convexPolyhedronA, ptr noundef nonnull %arrayidx310, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %DeltaC2, ptr noundef nonnull %verticesA, ptr nonnull poison, ptr noundef nonnull %facesA, ptr nonnull poison, ptr noundef %vertices, ptr poison, ptr poison, ptr poison, ptr noundef nonnull %sepAxis, ptr noundef nonnull %dmin)
  br i1 %call323, label %if.else, label %if.else365

if.else:                                          ; preds = %if.end304
  %call333 = call noundef zeroext i1 @_Z20b3FindSeparatingAxisPK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_Pf(ptr noundef nonnull %arrayidx310, ptr noundef nonnull %convexPolyhedronA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %DeltaC2, ptr noundef %vertices, ptr poison, ptr noundef %faces, ptr poison, ptr noundef nonnull %verticesA, ptr nonnull poison, ptr nonnull poison, ptr nonnull poison, ptr noundef nonnull %sepAxis, ptr noundef nonnull %dmin)
  br i1 %call333, label %if.else337, label %if.else365

if.else337:                                       ; preds = %if.else
  %call344 = call noundef zeroext i1 @_Z28b3FindSeparatingAxisEdgeEdgePK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_Pfb(ptr noundef nonnull %convexPolyhedronA, ptr noundef nonnull %arrayidx310, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %DeltaC2, ptr noundef nonnull %verticesA, ptr noundef nonnull %uniqueEdgesA, ptr nonnull poison, ptr nonnull poison, ptr noundef %vertices, ptr noundef %uniqueEdges, ptr poison, ptr poison, ptr noundef nonnull %sepAxis, ptr noundef nonnull %dmin, i1 noundef zeroext true)
  br i1 %call344, label %if.then353, label %if.else365

if.then353:                                       ; preds = %if.else337
  store i32 1, ptr %arrayidx21, align 4
  %195 = load float, ptr %dmin, align 4
  %w356 = getelementptr inbounds %struct.anon.2, ptr %sepAxis, i64 0, i32 3
  store float %195, ptr %w356, align 4
  %arrayidx358 = getelementptr inbounds %class.b3Vector3, ptr %concaveSeparatingNormalsOut, i64 %idxprom
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx358, ptr noundef nonnull align 16 dereferenceable(16) %sepAxis, i64 16, i1 false)
  %call364 = call noundef i32 @_Z19b3FindClippingFacesRK9b3Vector3PK22b3ConvexPolyhedronDataS4_S1_RK12b3QuaternionS1_S7_PS_S8_S8_iffPS0_PK9b3GpuFacePKiS9_SC_SE_P6b3Int4i(ptr noundef nonnull align 16 dereferenceable(16) %sepAxis, ptr noundef nonnull %convexPolyhedronA, ptr noundef nonnull %arrayidx310, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef %worldVertsA1Out, ptr noundef %worldNormalsA1Out, ptr noundef %worldVertsB1Out, i32 noundef %vertexFaceCapacity, float noundef 0xC6293E5940000000, float noundef 0x3F947AE140000000, ptr noundef nonnull %verticesA, ptr noundef nonnull %facesA, ptr noundef nonnull %indicesA, ptr noundef %vertices, ptr noundef %faces, ptr noundef %indices, ptr noundef %clippingFacesOut, i32 noundef %pairIdx)
  br label %if.end374

if.else365:                                       ; preds = %if.end304, %if.else, %if.else337
  %w368 = getelementptr inbounds %struct.anon, ptr %arrayidx, i64 0, i32 3
  store i32 -1, ptr %w368, align 4
  br label %if.end374

if.else370:                                       ; preds = %lor.lhs.false90, %cond.end82
  %w373 = getelementptr inbounds %struct.anon, ptr %arrayidx, i64 0, i32 3
  store i32 -1, ptr %w373, align 4
  br label %if.end374

if.end374:                                        ; preds = %if.then353, %if.else365, %if.else370, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i32 @_Z19b3FindClippingFacesRK9b3Vector3PK22b3ConvexPolyhedronDataS4_S1_RK12b3QuaternionS1_S7_PS_S8_S8_iffPS0_PK9b3GpuFacePKiS9_SC_SE_P6b3Int4i(ptr noundef nonnull align 16 dereferenceable(16) %separatingNormal, ptr noundef %hullA, ptr noundef %hullB, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef %worldVertsA1, ptr noundef %worldNormalsA1, ptr noundef %worldVertsB1, i32 noundef %capacityWorldVerts, float noundef %minDist, float noundef %maxDist, ptr noundef %verticesA, ptr noundef %facesA, ptr noundef %indicesA, ptr noundef %verticesB, ptr noundef %facesB, ptr noundef %indicesB, ptr noundef %clippingFaces, i32 noundef %pairIndex) local_unnamed_addr #5 comdat {
entry:
  %m_numFaces = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullB, i64 0, i32 6
  %0 = load i32, ptr %m_numFaces, align 8
  %cmp132 = icmp sgt i32 %0, 0
  %m_faceOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullB, i64 0, i32 5
  %1 = load i32, ptr %m_faceOffset, align 4
  br i1 %cmp132, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %entry
  %arrayidx.i.i.i = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 3
  %2 = load float, ptr %arrayidx.i.i.i, align 4
  %arrayidx.i23.i.i = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 1
  %3 = load float, ptr %arrayidx.i23.i.i, align 4
  %arrayidx.i25.i.i = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 2
  %4 = load float, ptr %arrayidx.i25.i.i, align 8
  %neg.i.i = fneg float %4
  %5 = load float, ptr %ornB, align 16
  %neg15.i.i = fneg float %5
  %neg24.i.i = fneg float %3
  %6 = load float, ptr %separatingNormal, align 16
  %arrayidx4.i.i = getelementptr inbounds [4 x float], ptr %separatingNormal, i64 0, i64 1
  %7 = load float, ptr %arrayidx4.i.i, align 4
  %arrayidx7.i.i = getelementptr inbounds [4 x float], ptr %separatingNormal, i64 0, i64 2
  %8 = load float, ptr %arrayidx7.i.i, align 8
  %9 = sext i32 %1 to i64
  %wide.trip.count = zext nneg i32 %0 to i64
  %invariant.gep = getelementptr %struct.b3GpuFace, ptr %facesB, i64 %9
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ]
  %closestFaceB.0135 = phi i32 [ -1, %for.body.lr.ph ], [ %closestFaceB.1, %for.body ]
  %dmax.0134 = phi float [ 0xC7EFFFFFE0000000, %for.body.lr.ph ], [ %dmax.1, %for.body ]
  %gep = getelementptr %struct.b3GpuFace, ptr %invariant.gep, i64 %indvars.iv
  %10 = load float, ptr %gep, align 16
  %y = getelementptr inbounds %struct.anon.2, ptr %gep, i64 0, i32 1
  %11 = load float, ptr %y, align 4
  %z = getelementptr inbounds %struct.anon.2, ptr %gep, i64 0, i32 2
  %12 = load float, ptr %z, align 8
  %mul4.i.i = fmul float %12, %3
  %13 = tail call float @llvm.fmuladd.f32(float %2, float %10, float %mul4.i.i)
  %14 = tail call float @llvm.fmuladd.f32(float %neg.i.i, float %11, float %13)
  %mul12.i.i = fmul float %10, %4
  %15 = tail call float @llvm.fmuladd.f32(float %2, float %11, float %mul12.i.i)
  %16 = tail call float @llvm.fmuladd.f32(float %neg15.i.i, float %12, float %15)
  %mul21.i.i = fmul float %11, %5
  %17 = tail call float @llvm.fmuladd.f32(float %2, float %12, float %mul21.i.i)
  %18 = tail call float @llvm.fmuladd.f32(float %neg24.i.i, float %10, float %17)
  %neg31.i.i = fmul float %11, %neg24.i.i
  %19 = tail call float @llvm.fmuladd.f32(float %neg15.i.i, float %10, float %neg31.i.i)
  %20 = tail call float @llvm.fmuladd.f32(float %neg.i.i, float %12, float %19)
  %mul4.i9.i = fmul float %2, %14
  %21 = tail call float @llvm.fmuladd.f32(float %20, float %neg15.i.i, float %mul4.i9.i)
  %22 = tail call float @llvm.fmuladd.f32(float %16, float %neg.i.i, float %21)
  %23 = tail call float @llvm.fmuladd.f32(float %18, float %3, float %22)
  %mul14.i.i = fmul float %2, %16
  %24 = tail call float @llvm.fmuladd.f32(float %20, float %neg24.i.i, float %mul14.i.i)
  %25 = tail call float @llvm.fmuladd.f32(float %18, float %neg15.i.i, float %24)
  %26 = tail call float @llvm.fmuladd.f32(float %14, float %4, float %25)
  %mul25.i.i = fmul float %2, %18
  %27 = tail call float @llvm.fmuladd.f32(float %20, float %neg.i.i, float %mul25.i.i)
  %28 = tail call float @llvm.fmuladd.f32(float %14, float %neg24.i.i, float %27)
  %29 = tail call float @llvm.fmuladd.f32(float %16, float %5, float %28)
  %mul5.i.i = fmul float %7, %26
  %30 = tail call float @llvm.fmuladd.f32(float %23, float %6, float %mul5.i.i)
  %31 = tail call noundef float @llvm.fmuladd.f32(float %29, float %8, float %30)
  %cmp16 = fcmp ogt float %31, %dmax.0134
  %dmax.1 = select i1 %cmp16, float %31, float %dmax.0134
  %32 = trunc i64 %indvars.iv to i32
  %closestFaceB.1 = select i1 %cmp16, i32 %32, i32 %closestFaceB.0135
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !16

for.end:                                          ; preds = %for.body, %entry
  %closestFaceB.0.lcssa = phi i32 [ -1, %entry ], [ %closestFaceB.1, %for.body ]
  %add18 = add nsw i32 %1, %closestFaceB.0.lcssa
  %idxprom19 = sext i32 %add18 to i64
  %arrayidx20 = getelementptr inbounds %struct.b3GpuFace, ptr %facesB, i64 %idxprom19
  %polyB.sroa.2.0.arrayidx20.sroa_idx = getelementptr inbounds i8, ptr %arrayidx20, i64 20
  %polyB.sroa.2.0.copyload = load i32, ptr %polyB.sroa.2.0.arrayidx20.sroa_idx, align 4
  %cmp22136 = icmp sgt i32 %polyB.sroa.2.0.copyload, 0
  br i1 %cmp22136, label %for.body23.lr.ph, label %for.cond41.preheader

for.body23.lr.ph:                                 ; preds = %for.end
  %polyB.sroa.1.0.arrayidx20.sroa_idx = getelementptr inbounds i8, ptr %arrayidx20, i64 16
  %polyB.sroa.1.0.copyload = load i32, ptr %polyB.sroa.1.0.arrayidx20.sroa_idx, align 16
  %m_vertexOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullB, i64 0, i32 8
  %tr.sroa.23.48.translation.sroa_idx.i = getelementptr inbounds i8, ptr %posB, i64 4
  %tr.sroa.24.48.translation.sroa_idx.i = getelementptr inbounds i8, ptr %posB, i64 8
  %arrayidx5.i.i.i.i.i = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 2
  %arrayidx7.i.i.i.i.i = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 3
  %mul = mul nsw i32 %pairIndex, %capacityWorldVerts
  %33 = sext i32 %mul to i64
  %34 = sext i32 %polyB.sroa.1.0.copyload to i64
  %wide.trip.count156 = zext nneg i32 %polyB.sroa.2.0.copyload to i64
  %invariant.gep166 = getelementptr i32, ptr %indicesB, i64 %34
  %invariant.gep168 = getelementptr %class.b3Vector3, ptr %worldVertsB1, i64 %33
  br label %for.body23

for.cond41.preheader:                             ; preds = %for.body23, %for.end
  %numWorldVertsB1.0.lcssa = phi i32 [ 0, %for.end ], [ %polyB.sroa.2.0.copyload, %for.body23 ]
  %m_numFaces42 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 6
  %35 = load i32, ptr %m_numFaces42, align 8
  %cmp43140 = icmp sgt i32 %35, 0
  br i1 %cmp43140, label %for.body44.lr.ph, label %for.end79

for.body44.lr.ph:                                 ; preds = %for.cond41.preheader
  %m_faceOffset46 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 5
  %arrayidx.i.i.i60 = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 3
  %arrayidx.i23.i.i61 = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 1
  %arrayidx4.i.i81 = getelementptr inbounds [4 x float], ptr %separatingNormal, i64 0, i64 1
  %arrayidx7.i.i84 = getelementptr inbounds [4 x float], ptr %separatingNormal, i64 0, i64 2
  %idxprom74 = sext i32 %pairIndex to i64
  %arrayidx75 = getelementptr inbounds %class.b3Vector3, ptr %worldNormalsA1, i64 %idxprom74
  %faceANormalWS.sroa.4.0.arrayidx75.sroa_idx = getelementptr inbounds i8, ptr %arrayidx75, i64 8
  br label %for.body44

for.body23:                                       ; preds = %for.body23.lr.ph, %for.body23
  %indvars.iv149 = phi i64 [ 0, %for.body23.lr.ph ], [ %indvars.iv.next150, %for.body23 ]
  %36 = load i32, ptr %m_vertexOffset, align 16
  %gep167 = getelementptr i32, ptr %invariant.gep166, i64 %indvars.iv149
  %37 = load i32, ptr %gep167, align 4
  %add27 = add nsw i32 %37, %36
  %idxprom28 = sext i32 %add27 to i64
  %arrayidx29 = getelementptr inbounds %class.b3Vector3, ptr %verticesB, i64 %idxprom28
  %b.sroa.0.0.copyload = load float, ptr %arrayidx29, align 16
  %b.sroa.2.0.arrayidx29.sroa_idx = getelementptr inbounds i8, ptr %arrayidx29, i64 4
  %b.sroa.2.0.copyload = load float, ptr %b.sroa.2.0.arrayidx29.sroa_idx, align 4
  %b.sroa.3.0.arrayidx29.sroa_idx = getelementptr inbounds i8, ptr %arrayidx29, i64 8
  %b.sroa.3.0.copyload = load float, ptr %b.sroa.3.0.arrayidx29.sroa_idx, align 8
  %tr.sroa.21.48.copyload.i = load float, ptr %posB, align 16
  %tr.sroa.23.48.copyload.i = load float, ptr %tr.sroa.23.48.translation.sroa_idx.i, align 4
  %tr.sroa.24.48.copyload.i = load float, ptr %tr.sroa.24.48.translation.sroa_idx.i, align 8
  %38 = load float, ptr %arrayidx5.i.i.i.i.i, align 8
  %39 = load float, ptr %arrayidx7.i.i.i.i.i, align 4
  %40 = load <2 x float>, ptr %ornB, align 16
  %41 = extractelement <2 x float> %40, i64 1
  %mul4.i.i.i.i.i = fmul float %41, %41
  %42 = extractelement <2 x float> %40, i64 0
  %43 = tail call float @llvm.fmuladd.f32(float %42, float %42, float %mul4.i.i.i.i.i)
  %44 = tail call float @llvm.fmuladd.f32(float %38, float %38, float %43)
  %45 = tail call noundef float @llvm.fmuladd.f32(float %39, float %39, float %44)
  %div.i.i.i = fdiv float 2.000000e+00, %45
  %46 = insertelement <2 x float> poison, float %div.i.i.i, i64 0
  %47 = shufflevector <2 x float> %46, <2 x float> poison, <2 x i32> zeroinitializer
  %48 = fmul <2 x float> %40, %47
  %mul6.i.i.i = fmul float %38, %div.i.i.i
  %49 = extractelement <2 x float> %48, i64 0
  %mul8.i.i.i = fmul float %39, %49
  %50 = extractelement <2 x float> %48, i64 1
  %mul10.i.i.i = fmul float %39, %50
  %mul12.i.i.i = fmul float %39, %mul6.i.i.i
  %mul16.i.i.i = fmul float %42, %50
  %mul18.i.i.i = fmul float %42, %mul6.i.i.i
  %51 = fmul <2 x float> %40, %48
  %mul22.i.i.i = fmul float %41, %mul6.i.i.i
  %mul24.i.i.i = fmul float %38, %mul6.i.i.i
  %52 = extractelement <2 x float> %51, i64 1
  %add.i.i.i = fadd float %52, %mul24.i.i.i
  %sub.i.i.i = fsub float 1.000000e+00, %add.i.i.i
  %sub26.i.i.i = fsub float %mul16.i.i.i, %mul12.i.i.i
  %add28.i.i.i = fadd float %mul18.i.i.i, %mul10.i.i.i
  %add30.i.i.i = fadd float %mul16.i.i.i, %mul12.i.i.i
  %53 = extractelement <2 x float> %51, i64 0
  %add32.i.i.i = fadd float %53, %mul24.i.i.i
  %sub33.i.i.i = fsub float 1.000000e+00, %add32.i.i.i
  %sub35.i.i.i = fsub float %mul22.i.i.i, %mul8.i.i.i
  %sub37.i.i.i = fsub float %mul18.i.i.i, %mul10.i.i.i
  %add39.i.i.i = fadd float %mul22.i.i.i, %mul8.i.i.i
  %add41.i.i.i = fadd float %53, %52
  %sub42.i.i.i = fsub float 1.000000e+00, %add41.i.i.i
  %mul5.i.i.i.i = fmul float %b.sroa.2.0.copyload, %sub26.i.i.i
  %54 = tail call float @llvm.fmuladd.f32(float %b.sroa.0.0.copyload, float %sub.i.i.i, float %mul5.i.i.i.i)
  %55 = tail call noundef float @llvm.fmuladd.f32(float %b.sroa.3.0.copyload, float %add28.i.i.i, float %54)
  %mul5.i3.i.i.i = fmul float %b.sroa.2.0.copyload, %sub33.i.i.i
  %56 = tail call float @llvm.fmuladd.f32(float %b.sroa.0.0.copyload, float %add30.i.i.i, float %mul5.i3.i.i.i)
  %57 = tail call noundef float @llvm.fmuladd.f32(float %b.sroa.3.0.copyload, float %sub35.i.i.i, float %56)
  %mul5.i8.i.i.i = fmul float %b.sroa.2.0.copyload, %add39.i.i.i
  %58 = tail call float @llvm.fmuladd.f32(float %b.sroa.0.0.copyload, float %sub37.i.i.i, float %mul5.i8.i.i.i)
  %59 = tail call noundef float @llvm.fmuladd.f32(float %b.sroa.3.0.copyload, float %sub42.i.i.i, float %58)
  %add.i.i3.i = fadd float %tr.sroa.21.48.copyload.i, %55
  %add4.i.i.i = fadd float %tr.sroa.23.48.copyload.i, %57
  %add7.i.i.i = fadd float %tr.sroa.24.48.copyload.i, %59
  %retval.sroa.0.0.vec.insert.i.i2.i.i = insertelement <2 x float> poison, float %add.i.i3.i, i64 0
  %retval.sroa.0.4.vec.insert.i.i3.i.i = insertelement <2 x float> %retval.sroa.0.0.vec.insert.i.i2.i.i, float %add4.i.i.i, i64 1
  %retval.sroa.3.12.vec.insert.i.i4.i.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %add7.i.i.i, i64 0
  %indvars.iv.next150 = add nuw nsw i64 %indvars.iv149, 1
  %gep169 = getelementptr %class.b3Vector3, ptr %invariant.gep168, i64 %indvars.iv149
  store <2 x float> %retval.sroa.0.4.vec.insert.i.i3.i.i, ptr %gep169, align 16
  %ref.tmp.sroa.2.0.arrayidx36.sroa_idx = getelementptr inbounds i8, ptr %gep169, i64 8
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i4.i.i, ptr %ref.tmp.sroa.2.0.arrayidx36.sroa_idx, align 8
  %exitcond157.not = icmp eq i64 %indvars.iv.next150, %wide.trip.count156
  br i1 %exitcond157.not, label %for.cond41.preheader, label %for.body23, !llvm.loop !17

for.body44:                                       ; preds = %for.body44.lr.ph, %for.inc77
  %60 = phi i32 [ %35, %for.body44.lr.ph ], [ %110, %for.inc77 ]
  %face40.0143 = phi i32 [ 0, %for.body44.lr.ph ], [ %inc78, %for.inc77 ]
  %dmin.0142 = phi float [ 0x47EFFFFFE0000000, %for.body44.lr.ph ], [ %dmin.1, %for.inc77 ]
  %closestFaceA.0141 = phi i32 [ -1, %for.body44.lr.ph ], [ %closestFaceA.1, %for.inc77 ]
  %61 = load i32, ptr %m_faceOffset46, align 4
  %add47 = add nsw i32 %61, %face40.0143
  %idxprom48 = sext i32 %add47 to i64
  %arrayidx49 = getelementptr inbounds %struct.b3GpuFace, ptr %facesA, i64 %idxprom48
  %z63 = getelementptr inbounds %struct.anon.2, ptr %arrayidx49, i64 0, i32 2
  %62 = load float, ptr %z63, align 8
  %63 = load float, ptr %arrayidx.i.i.i60, align 4
  %64 = load float, ptr %ornA, align 16
  %neg15.i.i68 = fneg float %64
  %65 = load <2 x float>, ptr %arrayidx49, align 16
  %66 = load <2 x float>, ptr %arrayidx.i23.i.i61, align 4
  %67 = extractelement <2 x float> %65, i64 0
  %shift = shufflevector <2 x float> %66, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %68 = fmul <2 x float> %65, %shift
  %mul12.i.i67 = extractelement <2 x float> %68, i64 0
  %69 = extractelement <2 x float> %65, i64 1
  %70 = tail call float @llvm.fmuladd.f32(float %63, float %69, float %mul12.i.i67)
  %71 = tail call float @llvm.fmuladd.f32(float %neg15.i.i68, float %62, float %70)
  %72 = insertelement <2 x float> %65, float %62, i64 0
  %73 = insertelement <2 x float> %66, float %64, i64 1
  %74 = fmul <2 x float> %72, %73
  %75 = insertelement <2 x float> poison, float %63, i64 0
  %76 = shufflevector <2 x float> %75, <2 x float> poison, <2 x i32> zeroinitializer
  %77 = insertelement <2 x float> %65, float %62, i64 1
  %78 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %76, <2 x float> %77, <2 x float> %74)
  %79 = shufflevector <2 x float> %78, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %80 = fneg <2 x float> %66
  %81 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %80, <2 x float> %65, <2 x float> %79)
  %82 = extractelement <2 x float> %80, i64 0
  %neg31.i.i71 = fmul float %69, %82
  %83 = tail call float @llvm.fmuladd.f32(float %neg15.i.i68, float %67, float %neg31.i.i71)
  %84 = extractelement <2 x float> %80, i64 1
  %85 = tail call float @llvm.fmuladd.f32(float %84, float %62, float %83)
  %86 = shufflevector <2 x float> %81, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %87 = insertelement <2 x float> %86, float %71, i64 1
  %88 = fmul <2 x float> %76, %87
  %89 = insertelement <2 x float> poison, float %85, i64 0
  %90 = shufflevector <2 x float> %89, <2 x float> poison, <2 x i32> zeroinitializer
  %91 = shufflevector <2 x float> %80, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %92 = insertelement <2 x float> %91, float %neg15.i.i68, i64 0
  %93 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %90, <2 x float> %92, <2 x float> %88)
  %94 = shufflevector <2 x float> %87, <2 x float> %81, <2 x i32> <i32 1, i32 2>
  %95 = shufflevector <2 x float> %80, <2 x float> %92, <2 x i32> <i32 1, i32 2>
  %96 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %94, <2 x float> %95, <2 x float> %93)
  %97 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %81, <2 x float> %66, <2 x float> %96)
  %98 = extractelement <2 x float> %81, i64 0
  %mul25.i.i74 = fmul float %63, %98
  %99 = tail call float @llvm.fmuladd.f32(float %85, float %84, float %mul25.i.i74)
  %100 = extractelement <2 x float> %81, i64 1
  %101 = tail call float @llvm.fmuladd.f32(float %100, float %82, float %99)
  %102 = tail call float @llvm.fmuladd.f32(float %71, float %64, float %101)
  %103 = load float, ptr %separatingNormal, align 16
  %104 = load float, ptr %arrayidx4.i.i81, align 4
  %105 = extractelement <2 x float> %97, i64 1
  %mul5.i.i82 = fmul float %104, %105
  %106 = extractelement <2 x float> %97, i64 0
  %107 = tail call float @llvm.fmuladd.f32(float %106, float %103, float %mul5.i.i82)
  %108 = load float, ptr %arrayidx7.i.i84, align 8
  %109 = tail call noundef float @llvm.fmuladd.f32(float %102, float %108, float %107)
  %cmp72 = fcmp olt float %109, %dmin.0142
  br i1 %cmp72, label %if.then73, label %for.inc77

if.then73:                                        ; preds = %for.body44
  %retval.sroa.3.12.vec.insert.i16.i77 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %102, i64 0
  store <2 x float> %97, ptr %arrayidx75, align 16
  store <2 x float> %retval.sroa.3.12.vec.insert.i16.i77, ptr %faceANormalWS.sroa.4.0.arrayidx75.sroa_idx, align 8
  %.pre165 = load i32, ptr %m_numFaces42, align 8
  br label %for.inc77

for.inc77:                                        ; preds = %for.body44, %if.then73
  %110 = phi i32 [ %.pre165, %if.then73 ], [ %60, %for.body44 ]
  %closestFaceA.1 = phi i32 [ %face40.0143, %if.then73 ], [ %closestFaceA.0141, %for.body44 ]
  %dmin.1 = phi float [ %109, %if.then73 ], [ %dmin.0142, %for.body44 ]
  %inc78 = add nuw nsw i32 %face40.0143, 1
  %cmp43 = icmp slt i32 %inc78, %110
  br i1 %cmp43, label %for.body44, label %for.end79, !llvm.loop !18

for.end79:                                        ; preds = %for.inc77, %for.cond41.preheader
  %closestFaceA.0.lcssa = phi i32 [ -1, %for.cond41.preheader ], [ %closestFaceA.1, %for.inc77 ]
  %m_faceOffset80 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 5
  %111 = load i32, ptr %m_faceOffset80, align 4
  %add81 = add nsw i32 %111, %closestFaceA.0.lcssa
  %idxprom82 = sext i32 %add81 to i64
  %m_numIndices84 = getelementptr inbounds %struct.b3GpuFace, ptr %facesA, i64 %idxprom82, i32 2
  %112 = load i32, ptr %m_numIndices84, align 4
  %cmp87145 = icmp sgt i32 %112, 0
  br i1 %cmp87145, label %for.body88.lr.ph, label %for.end111

for.body88.lr.ph:                                 ; preds = %for.end79
  %m_vertexOffset89 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 8
  %tr.sroa.23.48.translation.sroa_idx.i86 = getelementptr inbounds i8, ptr %posA, i64 4
  %tr.sroa.24.48.translation.sroa_idx.i88 = getelementptr inbounds i8, ptr %posA, i64 8
  %arrayidx5.i.i.i.i.i92 = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 2
  %arrayidx7.i.i.i.i.i93 = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 3
  %mul105 = mul nsw i32 %pairIndex, %capacityWorldVerts
  %113 = sext i32 %mul105 to i64
  %wide.trip.count163 = zext nneg i32 %112 to i64
  %invariant.gep170 = getelementptr %class.b3Vector3, ptr %worldVertsA1, i64 %113
  br label %for.body88

for.body88:                                       ; preds = %for.body88.lr.ph, %for.body88
  %indvars.iv158 = phi i64 [ 0, %for.body88.lr.ph ], [ %indvars.iv.next159, %for.body88 ]
  %114 = load i32, ptr %m_vertexOffset89, align 16
  %115 = load i32, ptr %m_faceOffset80, align 4
  %add91 = add nsw i32 %115, %closestFaceA.0.lcssa
  %idxprom92 = sext i32 %add91 to i64
  %m_indexOffset94 = getelementptr inbounds %struct.b3GpuFace, ptr %facesA, i64 %idxprom92, i32 1
  %116 = load i32, ptr %m_indexOffset94, align 16
  %117 = sext i32 %116 to i64
  %118 = getelementptr i32, ptr %indicesA, i64 %indvars.iv158
  %arrayidx97 = getelementptr i32, ptr %118, i64 %117
  %119 = load i32, ptr %arrayidx97, align 4
  %add98 = add nsw i32 %119, %114
  %idxprom99 = sext i32 %add98 to i64
  %arrayidx100 = getelementptr inbounds %class.b3Vector3, ptr %verticesA, i64 %idxprom99
  %a.sroa.0.0.copyload = load float, ptr %arrayidx100, align 16
  %a.sroa.2.0.arrayidx100.sroa_idx = getelementptr inbounds i8, ptr %arrayidx100, i64 4
  %a.sroa.2.0.copyload = load float, ptr %a.sroa.2.0.arrayidx100.sroa_idx, align 4
  %a.sroa.3.0.arrayidx100.sroa_idx = getelementptr inbounds i8, ptr %arrayidx100, i64 8
  %a.sroa.3.0.copyload = load float, ptr %a.sroa.3.0.arrayidx100.sroa_idx, align 8
  %tr.sroa.21.48.copyload.i85 = load float, ptr %posA, align 16
  %tr.sroa.23.48.copyload.i87 = load float, ptr %tr.sroa.23.48.translation.sroa_idx.i86, align 4
  %tr.sroa.24.48.copyload.i89 = load float, ptr %tr.sroa.24.48.translation.sroa_idx.i88, align 8
  %120 = load float, ptr %arrayidx5.i.i.i.i.i92, align 8
  %121 = load float, ptr %arrayidx7.i.i.i.i.i93, align 4
  %122 = load <2 x float>, ptr %ornA, align 16
  %123 = extractelement <2 x float> %122, i64 1
  %mul4.i.i.i.i.i91 = fmul float %123, %123
  %124 = extractelement <2 x float> %122, i64 0
  %125 = tail call float @llvm.fmuladd.f32(float %124, float %124, float %mul4.i.i.i.i.i91)
  %126 = tail call float @llvm.fmuladd.f32(float %120, float %120, float %125)
  %127 = tail call noundef float @llvm.fmuladd.f32(float %121, float %121, float %126)
  %div.i.i.i94 = fdiv float 2.000000e+00, %127
  %128 = insertelement <2 x float> poison, float %div.i.i.i94, i64 0
  %129 = shufflevector <2 x float> %128, <2 x float> poison, <2 x i32> zeroinitializer
  %130 = fmul <2 x float> %122, %129
  %mul6.i.i.i97 = fmul float %120, %div.i.i.i94
  %131 = extractelement <2 x float> %130, i64 0
  %mul8.i.i.i98 = fmul float %121, %131
  %132 = extractelement <2 x float> %130, i64 1
  %mul10.i.i.i99 = fmul float %121, %132
  %mul12.i.i.i100 = fmul float %121, %mul6.i.i.i97
  %mul16.i.i.i102 = fmul float %124, %132
  %mul18.i.i.i103 = fmul float %124, %mul6.i.i.i97
  %133 = fmul <2 x float> %122, %130
  %mul22.i.i.i105 = fmul float %123, %mul6.i.i.i97
  %mul24.i.i.i106 = fmul float %120, %mul6.i.i.i97
  %134 = extractelement <2 x float> %133, i64 1
  %add.i.i.i107 = fadd float %134, %mul24.i.i.i106
  %sub.i.i.i108 = fsub float 1.000000e+00, %add.i.i.i107
  %sub26.i.i.i109 = fsub float %mul16.i.i.i102, %mul12.i.i.i100
  %add28.i.i.i110 = fadd float %mul18.i.i.i103, %mul10.i.i.i99
  %add30.i.i.i111 = fadd float %mul16.i.i.i102, %mul12.i.i.i100
  %135 = extractelement <2 x float> %133, i64 0
  %add32.i.i.i112 = fadd float %135, %mul24.i.i.i106
  %sub33.i.i.i113 = fsub float 1.000000e+00, %add32.i.i.i112
  %sub35.i.i.i114 = fsub float %mul22.i.i.i105, %mul8.i.i.i98
  %sub37.i.i.i115 = fsub float %mul18.i.i.i103, %mul10.i.i.i99
  %add39.i.i.i116 = fadd float %mul22.i.i.i105, %mul8.i.i.i98
  %add41.i.i.i117 = fadd float %135, %134
  %sub42.i.i.i118 = fsub float 1.000000e+00, %add41.i.i.i117
  %mul5.i.i.i.i120 = fmul float %a.sroa.2.0.copyload, %sub26.i.i.i109
  %136 = tail call float @llvm.fmuladd.f32(float %a.sroa.0.0.copyload, float %sub.i.i.i108, float %mul5.i.i.i.i120)
  %137 = tail call noundef float @llvm.fmuladd.f32(float %a.sroa.3.0.copyload, float %add28.i.i.i110, float %136)
  %mul5.i3.i.i.i122 = fmul float %a.sroa.2.0.copyload, %sub33.i.i.i113
  %138 = tail call float @llvm.fmuladd.f32(float %a.sroa.0.0.copyload, float %add30.i.i.i111, float %mul5.i3.i.i.i122)
  %139 = tail call noundef float @llvm.fmuladd.f32(float %a.sroa.3.0.copyload, float %sub35.i.i.i114, float %138)
  %mul5.i8.i.i.i123 = fmul float %a.sroa.2.0.copyload, %add39.i.i.i116
  %140 = tail call float @llvm.fmuladd.f32(float %a.sroa.0.0.copyload, float %sub37.i.i.i115, float %mul5.i8.i.i.i123)
  %141 = tail call noundef float @llvm.fmuladd.f32(float %a.sroa.3.0.copyload, float %sub42.i.i.i118, float %140)
  %add.i.i3.i124 = fadd float %tr.sroa.21.48.copyload.i85, %137
  %add4.i.i.i125 = fadd float %tr.sroa.23.48.copyload.i87, %139
  %add7.i.i.i126 = fadd float %tr.sroa.24.48.copyload.i89, %141
  %retval.sroa.0.0.vec.insert.i.i2.i.i127 = insertelement <2 x float> poison, float %add.i.i3.i124, i64 0
  %retval.sroa.0.4.vec.insert.i.i3.i.i128 = insertelement <2 x float> %retval.sroa.0.0.vec.insert.i.i2.i.i127, float %add4.i.i.i125, i64 1
  %retval.sroa.3.12.vec.insert.i.i4.i.i129 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %add7.i.i.i126, i64 0
  %gep171 = getelementptr %class.b3Vector3, ptr %invariant.gep170, i64 %indvars.iv158
  store <2 x float> %retval.sroa.0.4.vec.insert.i.i3.i.i128, ptr %gep171, align 16
  %ref.tmp101.sroa.2.0.arrayidx108.sroa_idx = getelementptr inbounds i8, ptr %gep171, i64 8
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i4.i.i129, ptr %ref.tmp101.sroa.2.0.arrayidx108.sroa_idx, align 8
  %indvars.iv.next159 = add nuw nsw i64 %indvars.iv158, 1
  %exitcond164.not = icmp eq i64 %indvars.iv.next159, %wide.trip.count163
  br i1 %exitcond164.not, label %for.end111, label %for.body88, !llvm.loop !19

for.end111:                                       ; preds = %for.body88, %for.end79
  %idxprom112 = sext i32 %pairIndex to i64
  %arrayidx113 = getelementptr inbounds %struct.b3Int4, ptr %clippingFaces, i64 %idxprom112
  store i32 %closestFaceA.0.lcssa, ptr %arrayidx113, align 16
  %y117 = getelementptr inbounds %struct.anon, ptr %arrayidx113, i64 0, i32 1
  store i32 %closestFaceB.0.lcssa, ptr %y117, align 4
  %z120 = getelementptr inbounds %struct.anon, ptr %arrayidx113, i64 0, i32 2
  store i32 %112, ptr %z120, align 8
  %w = getelementptr inbounds %struct.anon, ptr %arrayidx113, i64 0, i32 3
  store i32 %numWorldVertsB1.0.lcssa, ptr %w, align 4
  ret i32 0
}

; Function Attrs: mustprogress nofree nosync nounwind memory(argmem: readwrite) uwtable
define dso_local noundef i32 @_Z14clipFaceGlobalPK9b3Vector3iRS0_fPS_(ptr nocapture noundef readonly %pVtxIn, i32 noundef %numVertsIn, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %planeNormalWS, float noundef %planeEqWS, ptr nocapture noundef writeonly %ppVtxOut) local_unnamed_addr #2 {
entry:
  %arrayidx3.i.i = getelementptr inbounds [4 x float], ptr %planeNormalWS, i64 0, i64 1
  %arrayidx6.i.i = getelementptr inbounds [4 x float], ptr %planeNormalWS, i64 0, i64 2
  %cmp68 = icmp sgt i32 %numVertsIn, 0
  br i1 %cmp68, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  %0 = load float, ptr %arrayidx6.i.i, align 8
  %1 = zext nneg i32 %numVertsIn to i64
  %2 = getelementptr %class.b3Vector3, ptr %pVtxIn, i64 %1
  %firstVertex.sroa.9.0.arrayidx.sroa_idx = getelementptr %class.b3Vector3, ptr %2, i64 -1, i32 0, i32 0, i64 2
  %firstVertex.sroa.9.0.copyload = load float, ptr %firstVertex.sroa.9.0.arrayidx.sroa_idx, align 8
  %3 = load float, ptr %planeNormalWS, align 16
  %arrayidx = getelementptr %class.b3Vector3, ptr %2, i64 -1
  %4 = load <2 x float>, ptr %arrayidx, align 16
  %5 = load float, ptr %arrayidx3.i.i, align 4
  %6 = extractelement <2 x float> %4, i64 1
  %mul5.i.i = fmul float %6, %5
  %7 = extractelement <2 x float> %4, i64 0
  %8 = tail call float @llvm.fmuladd.f32(float %3, float %7, float %mul5.i.i)
  %9 = tail call noundef float @llvm.fmuladd.f32(float %0, float %firstVertex.sroa.9.0.copyload, float %8)
  %add = fadd float %9, %planeEqWS
  %wide.trip.count = zext nneg i32 %numVertsIn to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end34
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %if.end34 ]
  %ds.073 = phi float [ %add, %for.body.preheader ], [ %add5, %if.end34 ]
  %numVertsOut.072 = phi i32 [ 0, %for.body.preheader ], [ %numVertsOut.1, %if.end34 ]
  %firstVertex.sroa.9.069 = phi float [ %firstVertex.sroa.9.0.copyload, %for.body.preheader ], [ %18, %if.end34 ]
  %10 = phi <2 x float> [ %4, %for.body.preheader ], [ %32, %if.end34 ]
  %arrayidx3 = getelementptr inbounds %class.b3Vector3, ptr %pVtxIn, i64 %indvars.iv
  %11 = load <4 x float>, ptr %arrayidx3, align 16
  %12 = load float, ptr %planeNormalWS, align 16
  %13 = load float, ptr %arrayidx3.i.i, align 4
  %14 = extractelement <4 x float> %11, i64 1
  %mul5.i.i25 = fmul float %14, %13
  %15 = extractelement <4 x float> %11, i64 0
  %16 = tail call float @llvm.fmuladd.f32(float %12, float %15, float %mul5.i.i25)
  %17 = load float, ptr %arrayidx6.i.i, align 8
  %18 = extractelement <4 x float> %11, i64 2
  %19 = tail call noundef float @llvm.fmuladd.f32(float %17, float %18, float %16)
  %add5 = fadd float %19, %planeEqWS
  %cmp6 = fcmp olt float %ds.073, 0.000000e+00
  %cmp7 = fcmp olt float %add5, 0.000000e+00
  br i1 %cmp6, label %if.then, label %if.else17

if.then:                                          ; preds = %for.body
  br i1 %cmp7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %inc = add nsw i32 %numVertsOut.072, 1
  %idxprom9 = sext i32 %numVertsOut.072 to i64
  %arrayidx10 = getelementptr inbounds %class.b3Vector3, ptr %ppVtxOut, i64 %idxprom9
  store <4 x float> %11, ptr %arrayidx10, align 16
  br label %if.end34

if.else:                                          ; preds = %if.then
  %sub11 = fsub float %ds.073, %add5
  %div = fdiv float %ds.073, %sub11
  %20 = shufflevector <4 x float> %11, <4 x float> poison, <2 x i32> <i32 0, i32 1>
  %21 = fsub <2 x float> %20, %10
  %22 = insertelement <2 x float> poison, float %div, i64 0
  %23 = shufflevector <2 x float> %22, <2 x float> poison, <2 x i32> zeroinitializer
  %24 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %21, <2 x float> %23, <2 x float> %10)
  %sub8.i = fsub float %18, %firstVertex.sroa.9.069
  %25 = tail call float @llvm.fmuladd.f32(float %sub8.i, float %div, float %firstVertex.sroa.9.069)
  %retval.sroa.3.12.vec.insert.i.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %25, i64 0
  %inc14 = add nsw i32 %numVertsOut.072, 1
  %idxprom15 = sext i32 %numVertsOut.072 to i64
  %arrayidx16 = getelementptr inbounds %class.b3Vector3, ptr %ppVtxOut, i64 %idxprom15
  store <2 x float> %24, ptr %arrayidx16, align 16
  %ref.tmp.sroa.2.0.arrayidx16.sroa_idx = getelementptr inbounds i8, ptr %arrayidx16, i64 8
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i, ptr %ref.tmp.sroa.2.0.arrayidx16.sroa_idx, align 8
  br label %if.end34

if.else17:                                        ; preds = %for.body
  br i1 %cmp7, label %if.then19, label %if.end34

if.then19:                                        ; preds = %if.else17
  %sub22 = fsub float %ds.073, %add5
  %div23 = fdiv float %ds.073, %sub22
  %26 = shufflevector <4 x float> %11, <4 x float> poison, <2 x i32> <i32 0, i32 1>
  %27 = fsub <2 x float> %26, %10
  %28 = insertelement <2 x float> poison, float %div23, i64 0
  %29 = shufflevector <2 x float> %28, <2 x float> poison, <2 x i32> zeroinitializer
  %30 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %27, <2 x float> %29, <2 x float> %10)
  %sub8.i34 = fsub float %18, %firstVertex.sroa.9.069
  %31 = tail call float @llvm.fmuladd.f32(float %sub8.i34, float %div23, float %firstVertex.sroa.9.069)
  %retval.sroa.3.12.vec.insert.i.i37 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %31, i64 0
  %idxprom28 = sext i32 %numVertsOut.072 to i64
  %arrayidx29 = getelementptr inbounds %class.b3Vector3, ptr %ppVtxOut, i64 %idxprom28
  store <2 x float> %30, ptr %arrayidx29, align 16
  %ref.tmp20.sroa.2.0.arrayidx29.sroa_idx = getelementptr inbounds i8, ptr %arrayidx29, i64 8
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i37, ptr %ref.tmp20.sroa.2.0.arrayidx29.sroa_idx, align 8
  %inc30 = add nsw i32 %numVertsOut.072, 2
  %arrayidx32 = getelementptr %class.b3Vector3, ptr %arrayidx29, i64 1
  store <4 x float> %11, ptr %arrayidx32, align 16
  br label %if.end34

if.end34:                                         ; preds = %if.else17, %if.then19, %if.then8, %if.else
  %numVertsOut.1 = phi i32 [ %inc, %if.then8 ], [ %inc14, %if.else ], [ %inc30, %if.then19 ], [ %numVertsOut.072, %if.else17 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  %32 = shufflevector <4 x float> %11, <4 x float> poison, <2 x i32> <i32 0, i32 1>
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !20

for.end:                                          ; preds = %if.end34, %entry
  %numVertsOut.0.lcssa = phi i32 [ 0, %entry ], [ %numVertsOut.1, %if.end34 ]
  ret i32 %numVertsOut.0.lcssa
}

; Function Attrs: mustprogress nofree nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local void @_Z30clipFacesAndFindContactsKernelPK9b3Vector3PKiP6b3Int4PS_S6_S6_S6_ii(ptr nocapture readnone %separatingNormals, ptr nocapture noundef readonly %hasSeparatingAxis, ptr nocapture noundef %clippingFacesOut, ptr nocapture noundef readonly %worldVertsA1, ptr nocapture noundef readonly %worldNormalsA1, ptr nocapture noundef %worldVertsB1, ptr nocapture noundef %worldVertsB2, i32 noundef %vertexFaceCapacity, i32 noundef %pairIndex) local_unnamed_addr #6 {
entry:
  %planeNormalWS = alloca %class.b3Vector3, align 16
  %idxprom = sext i32 %pairIndex to i64
  %arrayidx = getelementptr inbounds i32, ptr %hasSeparatingAxis, i64 %idxprom
  %0 = load i32, ptr %arrayidx, align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end84, label %if.then

if.then:                                          ; preds = %entry
  %mul = mul nsw i32 %pairIndex, %vertexFaceCapacity
  %idxprom1 = sext i32 %mul to i64
  %arrayidx2 = getelementptr inbounds %class.b3Vector3, ptr %worldVertsB1, i64 %idxprom1
  %arrayidx5 = getelementptr inbounds %class.b3Vector3, ptr %worldVertsB2, i64 %idxprom1
  %arrayidx7 = getelementptr inbounds %struct.b3Int4, ptr %clippingFacesOut, i64 %idxprom
  %1 = load i32, ptr %arrayidx7, align 16
  %z = getelementptr inbounds %struct.anon, ptr %arrayidx7, i64 0, i32 2
  %2 = load i32, ptr %z, align 8
  %w = getelementptr inbounds %struct.anon, ptr %arrayidx7, i64 0, i32 3
  %cmp = icmp sgt i32 %1, -1
  br i1 %cmp, label %if.then12, label %if.end69.thread

if.then12:                                        ; preds = %if.then
  %3 = load i32, ptr %w, align 4
  %cmp1366 = icmp sgt i32 %2, 0
  br i1 %cmp1366, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %if.then12
  %arrayidx24 = getelementptr inbounds %class.b3Vector3, ptr %worldNormalsA1, i64 %idxprom
  %worldPlaneAnormal1.sroa.2.0.arrayidx24.sroa_idx = getelementptr inbounds i8, ptr %arrayidx24, i64 4
  %planeNormalWS1.sroa.4.0.planeNormalWS.sroa_idx = getelementptr inbounds i8, ptr %planeNormalWS, i64 8
  %4 = zext nneg i32 %2 to i64
  %invariant.gep = getelementptr %class.b3Vector3, ptr %worldVertsA1, i64 %idxprom1
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ]
  %pVtxIn.070 = phi ptr [ %arrayidx2, %for.body.lr.ph ], [ %pVtxOut.069, %for.body ]
  %pVtxOut.069 = phi ptr [ %arrayidx5, %for.body.lr.ph ], [ %pVtxIn.070, %for.body ]
  %numVertsInB.068 = phi i32 [ %3, %for.body.lr.ph ], [ %call32, %for.body ]
  %gep = getelementptr %class.b3Vector3, ptr %invariant.gep, i64 %indvars.iv
  %aw.sroa.0.0.copyload = load float, ptr %gep, align 16
  %aw.sroa.3.0.arrayidx16.sroa_idx = getelementptr inbounds i8, ptr %gep, i64 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %5 = icmp eq i64 %indvars.iv.next, %4
  %6 = trunc i64 %indvars.iv.next to i32
  %iv.rem = select i1 %5, i32 0, i32 %6
  %add19 = add nsw i32 %iv.rem, %mul
  %idxprom20 = sext i32 %add19 to i64
  %arrayidx21 = getelementptr inbounds %class.b3Vector3, ptr %worldVertsA1, i64 %idxprom20
  %bw.sroa.0.0.copyload = load float, ptr %arrayidx21, align 16
  %bw.sroa.2.0.arrayidx21.sroa_idx = getelementptr inbounds i8, ptr %arrayidx21, i64 4
  %sub.i = fsub float %aw.sroa.0.0.copyload, %bw.sroa.0.0.copyload
  %worldPlaneAnormal1.sroa.0.0.copyload = load float, ptr %arrayidx24, align 16
  %7 = load <2 x float>, ptr %aw.sroa.3.0.arrayidx16.sroa_idx, align 4
  %8 = load <2 x float>, ptr %bw.sroa.2.0.arrayidx21.sroa_idx, align 4
  %9 = fsub <2 x float> %7, %8
  %10 = load <2 x float>, ptr %worldPlaneAnormal1.sroa.2.0.arrayidx24.sroa_idx, align 4
  %11 = shufflevector <2 x float> %9, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %12 = insertelement <2 x float> %11, float %sub.i, i64 1
  %13 = fneg <2 x float> %12
  %14 = fmul <2 x float> %10, %13
  %15 = shufflevector <2 x float> %10, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %16 = insertelement <2 x float> %15, float %worldPlaneAnormal1.sroa.0.0.copyload, i64 1
  %17 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %9, <2 x float> %16, <2 x float> %14)
  %18 = extractelement <2 x float> %9, i64 0
  %19 = fneg float %18
  %neg17.i.i = fmul float %worldPlaneAnormal1.sroa.0.0.copyload, %19
  %20 = extractelement <2 x float> %10, i64 0
  %21 = tail call float @llvm.fmuladd.f32(float %sub.i, float %20, float %neg17.i.i)
  %22 = fneg <2 x float> %17
  %fneg4.i = fneg float %21
  %retval.sroa.3.12.vec.insert.i.i48 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %fneg4.i, i64 0
  %shift = shufflevector <2 x float> %22, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %23 = fmul <2 x float> %7, %shift
  %mul5.i.i = extractelement <2 x float> %23, i64 0
  %24 = extractelement <2 x float> %22, i64 0
  %25 = tail call float @llvm.fmuladd.f32(float %aw.sroa.0.0.copyload, float %24, float %mul5.i.i)
  %26 = extractelement <2 x float> %7, i64 1
  %27 = tail call noundef float @llvm.fmuladd.f32(float %26, float %fneg4.i, float %25)
  %fneg = fneg float %27
  store <2 x float> %22, ptr %planeNormalWS, align 16
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i48, ptr %planeNormalWS1.sroa.4.0.planeNormalWS.sroa_idx, align 8
  %call32 = call noundef i32 @_Z14clipFaceGlobalPK9b3Vector3iRS0_fPS_(ptr noundef %pVtxIn.070, i32 noundef %numVertsInB.068, ptr noundef nonnull align 16 dereferenceable(16) %planeNormalWS, float noundef %fneg, ptr noundef %pVtxOut.069)
  %exitcond.not = icmp eq i64 %indvars.iv.next, %4
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !21

for.end:                                          ; preds = %for.body, %if.then12
  %numVertsInB.0.lcssa = phi i32 [ %3, %if.then12 ], [ %call32, %for.body ]
  %pVtxOut.0.lcssa = phi ptr [ %arrayidx5, %if.then12 ], [ %pVtxIn.070, %for.body ]
  %pVtxIn.0.lcssa = phi ptr [ %arrayidx2, %if.then12 ], [ %pVtxOut.069, %for.body ]
  %arrayidx35 = getelementptr inbounds %class.b3Vector3, ptr %worldNormalsA1, i64 %idxprom
  %planeNormalWS33.sroa.0.0.copyload = load float, ptr %arrayidx35, align 16
  %planeNormalWS33.sroa.3.0.arrayidx35.sroa_idx = getelementptr inbounds i8, ptr %arrayidx35, i64 4
  %planeNormalWS33.sroa.3.0.copyload = load float, ptr %planeNormalWS33.sroa.3.0.arrayidx35.sroa_idx, align 4
  %planeNormalWS33.sroa.5.0.arrayidx35.sroa_idx = getelementptr inbounds i8, ptr %arrayidx35, i64 8
  %planeNormalWS33.sroa.5.0.copyload = load float, ptr %planeNormalWS33.sroa.5.0.arrayidx35.sroa_idx, align 8
  %arrayidx39 = getelementptr inbounds %class.b3Vector3, ptr %worldVertsA1, i64 %idxprom1
  %28 = load float, ptr %arrayidx39, align 16
  %arrayidx4.i.i54 = getelementptr inbounds [4 x float], ptr %arrayidx39, i64 0, i64 1
  %29 = load float, ptr %arrayidx4.i.i54, align 4
  %mul5.i.i55 = fmul float %planeNormalWS33.sroa.3.0.copyload, %29
  %30 = tail call float @llvm.fmuladd.f32(float %planeNormalWS33.sroa.0.0.copyload, float %28, float %mul5.i.i55)
  %arrayidx7.i.i57 = getelementptr inbounds [4 x float], ptr %arrayidx39, i64 0, i64 2
  %31 = load float, ptr %arrayidx7.i.i57, align 8
  %32 = tail call noundef float @llvm.fmuladd.f32(float %planeNormalWS33.sroa.5.0.copyload, float %31, float %30)
  %cmp4473 = icmp sgt i32 %numVertsInB.0.lcssa, 0
  br i1 %cmp4473, label %for.body45.preheader, label %if.end69.thread

for.body45.preheader:                             ; preds = %for.end
  %wide.trip.count84 = zext nneg i32 %numVertsInB.0.lcssa to i64
  br label %for.body45

for.body45:                                       ; preds = %for.body45.preheader, %for.inc66
  %indvars.iv81 = phi i64 [ 0, %for.body45.preheader ], [ %indvars.iv.next82, %for.inc66 ]
  %numLocalContactsOut.075 = phi i32 [ 0, %for.body45.preheader ], [ %numLocalContactsOut.1, %for.inc66 ]
  %arrayidx47 = getelementptr inbounds %class.b3Vector3, ptr %pVtxIn.0.lcssa, i64 %indvars.iv81
  %33 = load <2 x float>, ptr %arrayidx47, align 16
  %34 = extractelement <2 x float> %33, i64 1
  %mul5.i.i60 = fmul float %planeNormalWS33.sroa.3.0.copyload, %34
  %35 = extractelement <2 x float> %33, i64 0
  %36 = tail call float @llvm.fmuladd.f32(float %planeNormalWS33.sroa.0.0.copyload, float %35, float %mul5.i.i60)
  %arrayidx7.i.i62 = getelementptr inbounds [4 x float], ptr %arrayidx47, i64 0, i64 2
  %37 = load float, ptr %arrayidx7.i.i62, align 8
  %38 = tail call noundef float @llvm.fmuladd.f32(float %planeNormalWS33.sroa.5.0.copyload, float %37, float %36)
  %add49 = fsub float %38, %32
  %cmp50.inv = fcmp ole float %add49, 0xC6293E5940000000
  %depth.0 = select i1 %cmp50.inv, float 0xC6293E5940000000, float %add49
  %cmp52 = fcmp ugt float %depth.0, 0x3F947AE140000000
  br i1 %cmp52, label %for.inc66, label %if.then53

if.then53:                                        ; preds = %for.body45
  %retval.sroa.3.12.vec.insert4.i = insertelement <2 x float> poison, float %37, i64 0
  %retval.sroa.3.12.vec.insert.i = insertelement <2 x float> %retval.sroa.3.12.vec.insert4.i, float %depth.0, i64 1
  %inc62 = add nsw i32 %numLocalContactsOut.075, 1
  %idxprom63 = sext i32 %numLocalContactsOut.075 to i64
  %arrayidx64 = getelementptr inbounds %class.b3Vector3, ptr %pVtxOut.0.lcssa, i64 %idxprom63
  store <2 x float> %33, ptr %arrayidx64, align 16
  %ref.tmp56.sroa.2.0.arrayidx64.sroa_idx = getelementptr inbounds i8, ptr %arrayidx64, i64 8
  store <2 x float> %retval.sroa.3.12.vec.insert.i, ptr %ref.tmp56.sroa.2.0.arrayidx64.sroa_idx, align 8
  br label %for.inc66

for.inc66:                                        ; preds = %for.body45, %if.then53
  %numLocalContactsOut.1 = phi i32 [ %inc62, %if.then53 ], [ %numLocalContactsOut.075, %for.body45 ]
  %indvars.iv.next82 = add nuw nsw i64 %indvars.iv81, 1
  %exitcond85.not = icmp eq i64 %indvars.iv.next82, %wide.trip.count84
  br i1 %exitcond85.not, label %if.end69, label %for.body45, !llvm.loop !22

if.end69.thread:                                  ; preds = %if.then, %for.end
  store i32 0, ptr %w, align 4
  br label %if.end84

if.end69:                                         ; preds = %for.inc66
  store i32 %numLocalContactsOut.1, ptr %w, align 4
  %cmp7577 = icmp sgt i32 %numLocalContactsOut.1, 0
  br i1 %cmp7577, label %for.body76.preheader, label %if.end84

for.body76.preheader:                             ; preds = %if.end69
  %wide.trip.count89 = zext nneg i32 %numLocalContactsOut.1 to i64
  br label %for.body76

for.body76:                                       ; preds = %for.body76.preheader, %for.body76
  %indvars.iv86 = phi i64 [ 0, %for.body76.preheader ], [ %indvars.iv.next87, %for.body76 ]
  %arrayidx78 = getelementptr inbounds %class.b3Vector3, ptr %pVtxOut.0.lcssa, i64 %indvars.iv86
  %arrayidx80 = getelementptr inbounds %class.b3Vector3, ptr %pVtxIn.0.lcssa, i64 %indvars.iv86
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx80, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx78, i64 16, i1 false)
  %indvars.iv.next87 = add nuw nsw i64 %indvars.iv86, 1
  %exitcond90.not = icmp eq i64 %indvars.iv.next87, %wide.trip.count89
  br i1 %exitcond90.not, label %if.end84, label %for.body76, !llvm.loop !23

if.end84:                                         ; preds = %for.body76, %if.end69.thread, %if.end69, %entry
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind memory(argmem: readwrite) uwtable
define dso_local noundef i32 @_Z33b3ExtractManifoldSequentialGlobalPK9b3Vector3iRS0_P6b3Int4(ptr nocapture noundef readonly %p, i32 noundef %nPoints, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %nearNormal, ptr nocapture noundef %contactIdx) local_unnamed_addr #2 {
entry:
  %cmp = icmp eq i32 %nPoints, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp slt i32 %nPoints, 5
  br i1 %cmp1, label %return, label %for.body.preheader

for.body.preheader:                               ; preds = %if.end
  %spec.store.select = tail call i32 @llvm.smin.i32(i32 %nPoints, i32 64)
  %wide.trip.count = zext nneg i32 %spec.store.select to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %center.sroa.13.0194 = phi <2 x float> [ zeroinitializer, %for.body.preheader ], [ %center.sroa.13.8.vec.insert, %for.body ]
  %center.sroa.0.0193 = phi <2 x float> [ zeroinitializer, %for.body.preheader ], [ %1, %for.body ]
  %arrayidx = getelementptr inbounds %class.b3Vector3, ptr %p, i64 %indvars.iv
  %0 = load <2 x float>, ptr %arrayidx, align 16
  %1 = fadd <2 x float> %center.sroa.0.0193, %0
  %arrayidx6.i = getelementptr inbounds [4 x float], ptr %arrayidx, i64 0, i64 2
  %2 = load float, ptr %arrayidx6.i, align 8
  %center.sroa.13.8.vec.extract = extractelement <2 x float> %center.sroa.13.0194, i64 0
  %add8.i = fadd float %center.sroa.13.8.vec.extract, %2
  %center.sroa.13.8.vec.insert = insertelement <2 x float> %center.sroa.13.0194, float %add8.i, i64 0
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.body31.lr.ph, label %for.body, !llvm.loop !24

for.body31.lr.ph:                                 ; preds = %for.body
  %conv = sitofp i32 %spec.store.select to float
  %div.i = fdiv float 1.000000e+00, %conv
  %3 = extractelement <2 x float> %1, i64 0
  %mul.i.i = fmul float %div.i, %3
  %4 = extractelement <2 x float> %1, i64 1
  %mul3.i.i = fmul float %div.i, %4
  %mul5.i.i = fmul float %div.i, %add8.i
  %5 = load float, ptr %p, align 16
  %sub.i = fsub float %5, %mul.i.i
  %arrayidx2.i = getelementptr inbounds [4 x float], ptr %p, i64 0, i64 1
  %6 = load float, ptr %arrayidx2.i, align 4
  %sub4.i = fsub float %6, %mul3.i.i
  %arrayidx5.i = getelementptr inbounds [4 x float], ptr %p, i64 0, i64 2
  %7 = load float, ptr %arrayidx5.i, align 8
  %sub7.i = fsub float %7, %mul5.i.i
  %arrayidx.i.i = getelementptr inbounds [4 x float], ptr %nearNormal, i64 0, i64 1
  %8 = load float, ptr %arrayidx.i.i, align 4
  %arrayidx3.i.i = getelementptr inbounds [4 x float], ptr %nearNormal, i64 0, i64 2
  %9 = load float, ptr %arrayidx3.i.i, align 8
  %10 = fneg float %9
  %neg.i.i = fmul float %sub4.i, %10
  %11 = tail call float @llvm.fmuladd.f32(float %8, float %sub7.i, float %neg.i.i)
  %12 = load float, ptr %nearNormal, align 16
  %13 = fneg float %12
  %neg11.i.i = fmul float %sub7.i, %13
  %14 = tail call float @llvm.fmuladd.f32(float %9, float %sub.i, float %neg11.i.i)
  %15 = fneg float %8
  %neg17.i.i = fmul float %sub.i, %15
  %16 = tail call float @llvm.fmuladd.f32(float %12, float %sub4.i, float %neg17.i.i)
  %neg.i.i50 = fmul float %14, %10
  %17 = tail call float @llvm.fmuladd.f32(float %8, float %16, float %neg.i.i50)
  %neg11.i.i51 = fmul float %16, %13
  %18 = tail call float @llvm.fmuladd.f32(float %9, float %11, float %neg11.i.i51)
  %neg17.i.i52 = fmul float %11, %15
  %19 = tail call float @llvm.fmuladd.f32(float %12, float %14, float %neg17.i.i52)
  %mul5.i.i.i.i.i = fmul float %14, %14
  %20 = tail call float @llvm.fmuladd.f32(float %11, float %11, float %mul5.i.i.i.i.i)
  %21 = tail call noundef float @llvm.fmuladd.f32(float %16, float %16, float %20)
  %sqrt.i.i.i = tail call noundef float @llvm.sqrt.f32(float %21)
  %div.i.i.i = fdiv float 1.000000e+00, %sqrt.i.i.i
  %mul.i.i.i.i = fmul float %11, %div.i.i.i
  %mul2.i.i.i.i = fmul float %14, %div.i.i.i
  %mul4.i.i.i.i = fmul float %16, %div.i.i.i
  %mul5.i.i.i.i.i59 = fmul float %18, %18
  %22 = tail call float @llvm.fmuladd.f32(float %17, float %17, float %mul5.i.i.i.i.i59)
  %23 = tail call noundef float @llvm.fmuladd.f32(float %19, float %19, float %22)
  %sqrt.i.i.i61 = tail call noundef float @llvm.sqrt.f32(float %23)
  %div.i.i.i62 = fdiv float 1.000000e+00, %sqrt.i.i.i61
  %mul.i.i.i.i63 = fmul float %17, %div.i.i.i62
  %mul2.i.i.i.i64 = fmul float %18, %div.i.i.i62
  %mul4.i.i.i.i65 = fmul float %19, %div.i.i.i62
  %fneg.i = fneg float %mul.i.i.i.i
  %fneg2.i = fneg float %mul2.i.i.i.i
  %fneg4.i = fneg float %mul4.i.i.i.i
  %y64 = getelementptr inbounds %struct.anon, ptr %contactIdx, i64 0, i32 1
  %z72 = getelementptr inbounds %struct.anon, ptr %contactIdx, i64 0, i32 2
  %fneg.i102 = fneg float %mul.i.i.i.i63
  %fneg2.i104 = fneg float %mul2.i.i.i.i64
  %fneg4.i106 = fneg float %mul4.i.i.i.i65
  %w84 = getelementptr inbounds %struct.anon, ptr %contactIdx, i64 0, i32 3
  %smax = tail call i32 @llvm.smax.i32(i32 %spec.store.select, i32 1)
  %wide.trip.count210 = zext nneg i32 %smax to i64
  br label %for.body31

for.body31:                                       ; preds = %for.body31.lr.ph, %for.inc86
  %indvars.iv207 = phi i64 [ 0, %for.body31.lr.ph ], [ %indvars.iv.next208, %for.inc86 ]
  %maxDots.sroa.0.0203 = phi float [ 0x3810000000000000, %for.body31.lr.ph ], [ %maxDots.sroa.0.1, %for.inc86 ]
  %maxDots.sroa.3.0202 = phi float [ 0x3810000000000000, %for.body31.lr.ph ], [ %maxDots.sroa.3.1, %for.inc86 ]
  %maxDots.sroa.6.0201 = phi float [ 0x3810000000000000, %for.body31.lr.ph ], [ %maxDots.sroa.6.1, %for.inc86 ]
  %maxDots.sroa.9.0200 = phi float [ 0x3810000000000000, %for.body31.lr.ph ], [ %maxDots.sroa.9.1, %for.inc86 ]
  %minIndex.0199 = phi i32 [ -1, %for.body31.lr.ph ], [ %minIndex.1, %for.inc86 ]
  %minW.0198 = phi float [ 0x47EFFFFFE0000000, %for.body31.lr.ph ], [ %minW.1, %for.inc86 ]
  %arrayidx33 = getelementptr inbounds %class.b3Vector3, ptr %p, i64 %indvars.iv207
  %w34 = getelementptr inbounds %struct.anon.2, ptr %arrayidx33, i64 0, i32 3
  %24 = load float, ptr %w34, align 4
  %cmp35 = fcmp olt float %24, %minW.0198
  %minW.1 = select i1 %cmp35, float %24, float %minW.0198
  %25 = trunc i64 %indvars.iv207 to i32
  %minIndex.1 = select i1 %cmp35, i32 %25, i32 %minIndex.0199
  %26 = load float, ptr %arrayidx33, align 16
  %sub.i71 = fsub float %26, %mul.i.i
  %arrayidx2.i72 = getelementptr inbounds [4 x float], ptr %arrayidx33, i64 0, i64 1
  %27 = load float, ptr %arrayidx2.i72, align 4
  %sub4.i74 = fsub float %27, %mul3.i.i
  %arrayidx5.i75 = getelementptr inbounds [4 x float], ptr %arrayidx33, i64 0, i64 2
  %28 = load float, ptr %arrayidx5.i75, align 8
  %sub7.i77 = fsub float %28, %mul5.i.i
  %mul5.i.i85 = fmul float %mul2.i.i.i.i, %sub4.i74
  %29 = tail call float @llvm.fmuladd.f32(float %mul.i.i.i.i, float %sub.i71, float %mul5.i.i85)
  %30 = tail call noundef float @llvm.fmuladd.f32(float %mul4.i.i.i.i, float %sub7.i77, float %29)
  %cmp48 = fcmp olt float %30, %maxDots.sroa.0.0203
  br i1 %cmp48, label %if.then49, label %if.end53

if.then49:                                        ; preds = %for.body31
  store i32 %25, ptr %contactIdx, align 16
  br label %if.end53

if.end53:                                         ; preds = %if.then49, %for.body31
  %maxDots.sroa.0.1 = phi float [ %30, %if.then49 ], [ %maxDots.sroa.0.0203, %for.body31 ]
  %mul5.i.i94 = fmul float %sub4.i74, %fneg2.i
  %31 = tail call float @llvm.fmuladd.f32(float %fneg.i, float %sub.i71, float %mul5.i.i94)
  %32 = tail call noundef float @llvm.fmuladd.f32(float %fneg4.i, float %sub7.i77, float %31)
  %cmp60 = fcmp olt float %32, %maxDots.sroa.3.0202
  br i1 %cmp60, label %if.then61, label %if.end65

if.then61:                                        ; preds = %if.end53
  store i32 %25, ptr %y64, align 4
  br label %if.end65

if.end65:                                         ; preds = %if.then61, %if.end53
  %maxDots.sroa.3.1 = phi float [ %32, %if.then61 ], [ %maxDots.sroa.3.0202, %if.end53 ]
  %mul5.i.i99 = fmul float %mul2.i.i.i.i64, %sub4.i74
  %33 = tail call float @llvm.fmuladd.f32(float %mul.i.i.i.i63, float %sub.i71, float %mul5.i.i99)
  %34 = tail call noundef float @llvm.fmuladd.f32(float %mul4.i.i.i.i65, float %sub7.i77, float %33)
  %cmp68 = fcmp olt float %34, %maxDots.sroa.6.0201
  br i1 %cmp68, label %if.then69, label %if.end73

if.then69:                                        ; preds = %if.end65
  store i32 %25, ptr %z72, align 8
  br label %if.end73

if.end73:                                         ; preds = %if.then69, %if.end65
  %maxDots.sroa.6.1 = phi float [ %34, %if.then69 ], [ %maxDots.sroa.6.0201, %if.end65 ]
  %mul5.i.i114 = fmul float %sub4.i74, %fneg2.i104
  %35 = tail call float @llvm.fmuladd.f32(float %fneg.i102, float %sub.i71, float %mul5.i.i114)
  %36 = tail call noundef float @llvm.fmuladd.f32(float %fneg4.i106, float %sub7.i77, float %35)
  %cmp80 = fcmp olt float %36, %maxDots.sroa.9.0200
  br i1 %cmp80, label %if.then81, label %for.inc86

if.then81:                                        ; preds = %if.end73
  store i32 %25, ptr %w84, align 4
  br label %for.inc86

for.inc86:                                        ; preds = %if.end73, %if.then81
  %maxDots.sroa.9.1 = phi float [ %36, %if.then81 ], [ %maxDots.sroa.9.0200, %if.end73 ]
  %indvars.iv.next208 = add nuw nsw i64 %indvars.iv207, 1
  %exitcond211.not = icmp eq i64 %indvars.iv.next208, %wide.trip.count210
  br i1 %exitcond211.not, label %for.end88, label %for.body31, !llvm.loop !25

for.end88:                                        ; preds = %for.inc86
  %37 = load i32, ptr %contactIdx, align 16
  %cmp91.not = icmp eq i32 %37, %minIndex.1
  br i1 %cmp91.not, label %return, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.end88
  %y93 = getelementptr inbounds %struct.anon, ptr %contactIdx, i64 0, i32 1
  %38 = load i32, ptr %y93, align 4
  %cmp94.not = icmp eq i32 %38, %minIndex.1
  br i1 %cmp94.not, label %return, label %land.lhs.true95

land.lhs.true95:                                  ; preds = %land.lhs.true
  %z97 = getelementptr inbounds %struct.anon, ptr %contactIdx, i64 0, i32 2
  %39 = load i32, ptr %z97, align 8
  %cmp98.not = icmp eq i32 %39, %minIndex.1
  br i1 %cmp98.not, label %return, label %land.lhs.true99

land.lhs.true99:                                  ; preds = %land.lhs.true95
  %w101 = getelementptr inbounds %struct.anon, ptr %contactIdx, i64 0, i32 3
  %40 = load i32, ptr %w101, align 4
  %cmp102.not = icmp eq i32 %40, %minIndex.1
  br i1 %cmp102.not, label %return, label %if.then103

if.then103:                                       ; preds = %land.lhs.true99
  store i32 %minIndex.1, ptr %contactIdx, align 16
  br label %return

return:                                           ; preds = %for.end88, %land.lhs.true, %land.lhs.true95, %land.lhs.true99, %if.then103, %if.end, %entry
  %retval.0 = phi i32 [ 0, %entry ], [ %nPoints, %if.end ], [ 4, %if.then103 ], [ 4, %land.lhs.true99 ], [ 4, %land.lhs.true95 ], [ 4, %land.lhs.true ], [ 4, %for.end88 ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree nounwind memory(argmem: readwrite, inaccessiblemem: readwrite) uwtable
define dso_local void @_Z27b3NewContactReductionKernelP6b3Int4PK15b3RigidBodyDataPK9b3Vector3PKiP14b3Contact4DataS0_PS4_PViiiii(ptr nocapture noundef %pairs, ptr nocapture noundef readonly %rigidBodies, ptr nocapture noundef readonly %separatingNormals, ptr nocapture noundef readonly %hasSeparatingAxis, ptr nocapture noundef writeonly %globalContactsOut, ptr nocapture noundef readonly %clippingFaces, ptr nocapture noundef readonly %worldVertsB2, ptr noundef %nGlobalContactsOut, i32 noundef %vertexFaceCapacity, i32 noundef %contactCapacity, i32 noundef %numPairs, i32 noundef %pairIndex) local_unnamed_addr #7 {
entry:
  %contactIdx = alloca %struct.b3Int4, align 16
  %normal = alloca %class.b3Vector3, align 16
  store i64 4294967296, ptr %contactIdx, align 16
  %ref.tmp.sroa.2.0.contactIdx.sroa_idx = getelementptr inbounds i8, ptr %contactIdx, i64 8
  store i64 12884901890, ptr %ref.tmp.sroa.2.0.contactIdx.sroa_idx, align 8
  %cmp = icmp slt i32 %pairIndex, %numPairs
  br i1 %cmp, label %if.then, label %if.end67

if.then:                                          ; preds = %entry
  %idxprom = sext i32 %pairIndex to i64
  %arrayidx = getelementptr inbounds i32, ptr %hasSeparatingAxis, i64 %idxprom
  %0 = load i32, ptr %arrayidx, align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end67, label %if.then2

if.then2:                                         ; preds = %if.then
  %w = getelementptr inbounds %struct.b3Int4, ptr %clippingFaces, i64 %idxprom, i32 0, i32 0, i32 3
  %1 = load i32, ptr %w, align 4
  %cmp5 = icmp sgt i32 %1, 0
  br i1 %cmp5, label %if.then6, label %if.end67

if.then6:                                         ; preds = %if.then2
  %mul = mul nsw i32 %pairIndex, %vertexFaceCapacity
  %idxprom7 = sext i32 %mul to i64
  %arrayidx8 = getelementptr inbounds %class.b3Vector3, ptr %worldVertsB2, i64 %idxprom7
  %arrayidx10 = getelementptr inbounds %class.b3Vector3, ptr %separatingNormals, i64 %idxprom
  %2 = load <2 x float>, ptr %arrayidx10, align 16
  %3 = fneg <2 x float> %2
  %arrayidx3.i = getelementptr inbounds [4 x float], ptr %arrayidx10, i64 0, i64 2
  %4 = load float, ptr %arrayidx3.i, align 8
  %fneg4.i = fneg float %4
  %retval.sroa.3.12.vec.insert.i.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %fneg4.i, i64 0
  store <2 x float> %3, ptr %normal, align 16
  %5 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %normal, i64 0, i32 1
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i, ptr %5, align 8
  %call14 = call noundef i32 @_Z33b3ExtractManifoldSequentialGlobalPK9b3Vector3iRS0_P6b3Int4(ptr noundef %arrayidx8, i32 noundef %1, ptr noundef nonnull align 16 dereferenceable(16) %normal, ptr noundef nonnull %contactIdx)
  %6 = load volatile i32, ptr %nGlobalContactsOut, align 4
  %inc = add nsw i32 %6, 1
  store volatile i32 %inc, ptr %nGlobalContactsOut, align 4
  %cmp15 = icmp slt i32 %6, %contactCapacity
  br i1 %cmp15, label %if.then16, label %if.end67

if.then16:                                        ; preds = %if.then6
  %idxprom17 = sext i32 %6 to i64
  %arrayidx18 = getelementptr inbounds %struct.b3Contact4Data, ptr %globalContactsOut, i64 %idxprom17
  %retval.sroa.3.12.vec.insert.i.i44 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %4, i64 0
  %m_worldNormalOnB = getelementptr inbounds %struct.b3Contact4Data, ptr %globalContactsOut, i64 %idxprom17, i32 1
  store <2 x float> %2, ptr %m_worldNormalOnB, align 16
  %ref.tmp19.sroa.2.0.m_worldNormalOnB.sroa_idx = getelementptr inbounds i8, ptr %m_worldNormalOnB, i64 8
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i44, ptr %ref.tmp19.sroa.2.0.m_worldNormalOnB.sroa_idx, align 8
  %m_restituitionCoeffCmp = getelementptr inbounds %struct.b3Contact4Data, ptr %globalContactsOut, i64 %idxprom17, i32 2
  store i16 0, ptr %m_restituitionCoeffCmp, align 16
  %m_frictionCoeffCmp = getelementptr inbounds %struct.b3Contact4Data, ptr %globalContactsOut, i64 %idxprom17, i32 3
  store i16 -19662, ptr %m_frictionCoeffCmp, align 2
  %m_batchIdx = getelementptr inbounds %struct.b3Contact4Data, ptr %globalContactsOut, i64 %idxprom17, i32 4
  store i32 %pairIndex, ptr %m_batchIdx, align 4
  %arrayidx24 = getelementptr inbounds %struct.b3Int4, ptr %pairs, i64 %idxprom
  %7 = load i32, ptr %arrayidx24, align 16
  %y = getelementptr inbounds %struct.anon, ptr %arrayidx24, i64 0, i32 1
  %8 = load i32, ptr %y, align 4
  %w29 = getelementptr inbounds %struct.anon, ptr %arrayidx24, i64 0, i32 3
  store i32 %6, ptr %w29, align 4
  %idxprom30 = sext i32 %7 to i64
  %m_invMass = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom30, i32 5
  %9 = load float, ptr %m_invMass, align 4
  %cmp32 = fcmp oeq float %9, 0.000000e+00
  %sub = sub nsw i32 0, %7
  %cond = select i1 %cmp32, i32 %sub, i32 %7
  %m_bodyAPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %globalContactsOut, i64 %idxprom17, i32 5
  store i32 %cond, ptr %m_bodyAPtrAndSignBit, align 8
  %idxprom33 = sext i32 %8 to i64
  %m_invMass35 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom33, i32 5
  %10 = load float, ptr %m_invMass35, align 4
  %cmp36 = fcmp oeq float %10, 0.000000e+00
  %sub38 = sub nsw i32 0, %8
  %cond41 = select i1 %cmp36, i32 %sub38, i32 %8
  %m_bodyBPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %globalContactsOut, i64 %idxprom17, i32 6
  store i32 %cond41, ptr %m_bodyBPtrAndSignBit, align 4
  %m_childIndexA = getelementptr inbounds %struct.b3Contact4Data, ptr %globalContactsOut, i64 %idxprom17, i32 7
  store i32 -1, ptr %m_childIndexA, align 16
  %m_childIndexB = getelementptr inbounds %struct.b3Contact4Data, ptr %globalContactsOut, i64 %idxprom17, i32 8
  store i32 -1, ptr %m_childIndexB, align 4
  switch i32 %call14, label %sw.epilog [
    i32 4, label %sw.bb
    i32 3, label %sw.bb46
    i32 2, label %sw.bb51
    i32 1, label %sw.bb57
  ]

sw.bb:                                            ; preds = %if.then16
  %w42 = getelementptr inbounds %struct.anon, ptr %contactIdx, i64 0, i32 3
  %11 = load i32, ptr %w42, align 4
  %idxprom43 = sext i32 %11 to i64
  %arrayidx44 = getelementptr inbounds %class.b3Vector3, ptr %arrayidx8, i64 %idxprom43
  %arrayidx45 = getelementptr inbounds [4 x %class.b3Vector3], ptr %arrayidx18, i64 0, i64 3
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx45, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx44, i64 16, i1 false)
  br label %sw.bb46

sw.bb46:                                          ; preds = %sw.bb, %if.then16
  %12 = load i32, ptr %ref.tmp.sroa.2.0.contactIdx.sroa_idx, align 8
  %idxprom47 = sext i32 %12 to i64
  %arrayidx48 = getelementptr inbounds %class.b3Vector3, ptr %arrayidx8, i64 %idxprom47
  %arrayidx50 = getelementptr inbounds [4 x %class.b3Vector3], ptr %arrayidx18, i64 0, i64 2
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx50, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx48, i64 16, i1 false)
  br label %sw.bb51

sw.bb51:                                          ; preds = %sw.bb46, %if.then16
  %y52 = getelementptr inbounds %struct.anon, ptr %contactIdx, i64 0, i32 1
  %13 = load i32, ptr %y52, align 4
  %idxprom53 = sext i32 %13 to i64
  %arrayidx54 = getelementptr inbounds %class.b3Vector3, ptr %arrayidx8, i64 %idxprom53
  %arrayidx56 = getelementptr inbounds [4 x %class.b3Vector3], ptr %arrayidx18, i64 0, i64 1
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx56, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx54, i64 16, i1 false)
  br label %sw.bb57

sw.bb57:                                          ; preds = %sw.bb51, %if.then16
  %14 = load i32, ptr %contactIdx, align 16
  %idxprom59 = sext i32 %14 to i64
  %arrayidx60 = getelementptr inbounds %class.b3Vector3, ptr %arrayidx8, i64 %idxprom59
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx18, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx60, i64 16, i1 false)
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then16, %sw.bb57
  %conv = sitofp i32 %call14 to float
  %w64 = getelementptr inbounds %struct.anon.2, ptr %m_worldNormalOnB, i64 0, i32 3
  store float %conv, ptr %w64, align 4
  br label %if.end67

if.end67:                                         ; preds = %if.then, %if.then6, %sw.epilog, %if.then2, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN15GpuSatCollisionC2EP11_cl_contextP13_cl_device_idP17_cl_command_queue(ptr noundef nonnull align 8 dereferenceable(864) %this, ptr noundef %ctx, ptr noundef %device, ptr noundef %q) unnamed_addr #8 align 2 personality ptr @__gxx_personality_v0 {
invoke.cont45:
  %ref.tmp = alloca i32, align 4
  %errNum = alloca i32, align 4
  %flags = alloca [1024 x i8], align 16
  %flags114 = alloca [1024 x i8], align 16
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV15GpuSatCollision, i64 0, inrange i32 0, i64 2), ptr %this, align 8
  %m_context = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 1
  store ptr %ctx, ptr %m_context, align 8
  %m_device = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 2
  store ptr %device, ptr %m_device, align 8
  %m_queue = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 3
  store ptr %q, ptr %m_queue, align 8
  %m_findSeparatingAxisKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 4
  store ptr null, ptr %m_findSeparatingAxisKernel, align 8
  %m_findSeparatingAxisVertexFaceKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 7
  %m_findSeparatingAxisEdgeEdgeKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 8
  %m_unitSphereDirections = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 24
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %m_findSeparatingAxisVertexFaceKernel, i8 0, i64 16, i1 false)
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayI9b3Vector3E, i64 0, inrange i32 0, i64 2), ptr %m_unitSphereDirections, align 8
  %m_size.i = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 24, i32 1
  %m_clContext.i = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 24, i32 4
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size.i, i8 0, i64 24, i1 false)
  store ptr %ctx, ptr %m_clContext.i, align 8
  %m_commandQueue.i = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 24, i32 5
  store ptr %q, ptr %m_commandQueue.i, align 8
  %m_ownsMemory.i = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 24, i32 6
  store i8 1, ptr %m_ownsMemory.i, align 8
  %m_allowGrowingCapacity.i = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 24, i32 7
  store i8 1, ptr %m_allowGrowingCapacity.i, align 1
  %m_totalContactsOut = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 25
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayIiE, i64 0, inrange i32 0, i64 2), ptr %m_totalContactsOut, align 8
  %m_size.i41 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 25, i32 1
  %m_clContext.i42 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 25, i32 4
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size.i41, i8 0, i64 24, i1 false)
  store ptr %ctx, ptr %m_clContext.i42, align 8
  %m_commandQueue.i43 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 25, i32 5
  store ptr %q, ptr %m_commandQueue.i43, align 8
  %m_ownsMemory.i44 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 25, i32 6
  store i8 1, ptr %m_ownsMemory.i44, align 8
  %m_allowGrowingCapacity.i45 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 25, i32 7
  store i8 1, ptr %m_allowGrowingCapacity.i45, align 1
  %m_sepNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 26
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayI9b3Vector3E, i64 0, inrange i32 0, i64 2), ptr %m_sepNormals, align 8
  %m_size.i46 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 26, i32 1
  %m_clContext.i47 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 26, i32 4
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size.i46, i8 0, i64 24, i1 false)
  store ptr %ctx, ptr %m_clContext.i47, align 8
  %m_commandQueue.i48 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 26, i32 5
  store ptr %q, ptr %m_commandQueue.i48, align 8
  %m_ownsMemory.i49 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 26, i32 6
  store i8 1, ptr %m_ownsMemory.i49, align 8
  %m_allowGrowingCapacity.i50 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 26, i32 7
  store i8 1, ptr %m_allowGrowingCapacity.i50, align 1
  %m_dmins = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 27
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayIfE, i64 0, inrange i32 0, i64 2), ptr %m_dmins, align 8
  %m_size.i51 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 27, i32 1
  %m_clContext.i52 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 27, i32 4
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size.i51, i8 0, i64 24, i1 false)
  store ptr %ctx, ptr %m_clContext.i52, align 8
  %m_commandQueue.i53 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 27, i32 5
  store ptr %q, ptr %m_commandQueue.i53, align 8
  %m_ownsMemory.i54 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 27, i32 6
  store i8 1, ptr %m_ownsMemory.i54, align 8
  %m_allowGrowingCapacity.i55 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 27, i32 7
  store i8 1, ptr %m_allowGrowingCapacity.i55, align 1
  %m_hasSeparatingNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 28
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayIiE, i64 0, inrange i32 0, i64 2), ptr %m_hasSeparatingNormals, align 8
  %m_size.i56 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 28, i32 1
  %m_clContext.i57 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 28, i32 4
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size.i56, i8 0, i64 24, i1 false)
  store ptr %ctx, ptr %m_clContext.i57, align 8
  %m_commandQueue.i58 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 28, i32 5
  store ptr %q, ptr %m_commandQueue.i58, align 8
  %m_ownsMemory.i59 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 28, i32 6
  store i8 1, ptr %m_ownsMemory.i59, align 8
  %m_allowGrowingCapacity.i60 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 28, i32 7
  store i8 1, ptr %m_allowGrowingCapacity.i60, align 1
  %m_concaveSepNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 29
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayI9b3Vector3E, i64 0, inrange i32 0, i64 2), ptr %m_concaveSepNormals, align 8
  %m_size.i61 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 29, i32 1
  %m_clContext.i62 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 29, i32 4
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size.i61, i8 0, i64 24, i1 false)
  store ptr %ctx, ptr %m_clContext.i62, align 8
  %m_commandQueue.i63 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 29, i32 5
  store ptr %q, ptr %m_commandQueue.i63, align 8
  %m_ownsMemory.i64 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 29, i32 6
  store i8 1, ptr %m_ownsMemory.i64, align 8
  %m_allowGrowingCapacity.i65 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 29, i32 7
  store i8 1, ptr %m_allowGrowingCapacity.i65, align 1
  %m_concaveHasSeparatingNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 30
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayIiE, i64 0, inrange i32 0, i64 2), ptr %m_concaveHasSeparatingNormals, align 8
  %m_size.i66 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 30, i32 1
  %m_clContext.i67 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 30, i32 4
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size.i66, i8 0, i64 24, i1 false)
  store ptr %ctx, ptr %m_clContext.i67, align 8
  %m_commandQueue.i68 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 30, i32 5
  store ptr %q, ptr %m_commandQueue.i68, align 8
  %m_ownsMemory.i69 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 30, i32 6
  store i8 1, ptr %m_ownsMemory.i69, align 8
  %m_allowGrowingCapacity.i70 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 30, i32 7
  store i8 1, ptr %m_allowGrowingCapacity.i70, align 1
  %m_numConcavePairsOut = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 31
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayIiE, i64 0, inrange i32 0, i64 2), ptr %m_numConcavePairsOut, align 8
  %m_size.i71 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 31, i32 1
  %m_clContext.i72 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 31, i32 4
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size.i71, i8 0, i64 24, i1 false)
  store ptr %ctx, ptr %m_clContext.i72, align 8
  %m_commandQueue.i73 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 31, i32 5
  store ptr %q, ptr %m_commandQueue.i73, align 8
  %m_ownsMemory.i74 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 31, i32 6
  store i8 1, ptr %m_ownsMemory.i74, align 8
  %m_allowGrowingCapacity.i75 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 31, i32 7
  store i8 1, ptr %m_allowGrowingCapacity.i75, align 1
  %m_gpuCompoundPairs = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 32
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayI25b3CompoundOverlappingPairE, i64 0, inrange i32 0, i64 2), ptr %m_gpuCompoundPairs, align 8
  %m_size.i76 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 32, i32 1
  %m_clContext.i77 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 32, i32 4
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size.i76, i8 0, i64 24, i1 false)
  store ptr %ctx, ptr %m_clContext.i77, align 8
  %m_commandQueue.i78 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 32, i32 5
  store ptr %q, ptr %m_commandQueue.i78, align 8
  %m_ownsMemory.i79 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 32, i32 6
  store i8 1, ptr %m_ownsMemory.i79, align 8
  %m_allowGrowingCapacity.i80 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 32, i32 7
  store i8 1, ptr %m_allowGrowingCapacity.i80, align 1
  %m_gpuCompoundSepNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 33
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayI9b3Vector3E, i64 0, inrange i32 0, i64 2), ptr %m_gpuCompoundSepNormals, align 8
  %m_size.i81 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 33, i32 1
  %m_clContext.i82 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 33, i32 4
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size.i81, i8 0, i64 24, i1 false)
  store ptr %ctx, ptr %m_clContext.i82, align 8
  %m_commandQueue.i83 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 33, i32 5
  store ptr %q, ptr %m_commandQueue.i83, align 8
  %m_ownsMemory.i84 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 33, i32 6
  store i8 1, ptr %m_ownsMemory.i84, align 8
  %m_allowGrowingCapacity.i85 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 33, i32 7
  store i8 1, ptr %m_allowGrowingCapacity.i85, align 1
  %m_gpuHasCompoundSepNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 34
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayIiE, i64 0, inrange i32 0, i64 2), ptr %m_gpuHasCompoundSepNormals, align 8
  %m_size.i86 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 34, i32 1
  %m_clContext.i87 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 34, i32 4
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size.i86, i8 0, i64 24, i1 false)
  store ptr %ctx, ptr %m_clContext.i87, align 8
  %m_commandQueue.i88 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 34, i32 5
  store ptr %q, ptr %m_commandQueue.i88, align 8
  %m_ownsMemory.i89 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 34, i32 6
  store i8 1, ptr %m_ownsMemory.i89, align 8
  %m_allowGrowingCapacity.i90 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 34, i32 7
  store i8 1, ptr %m_allowGrowingCapacity.i90, align 1
  %m_numCompoundPairsOut = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 35
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayIiE, i64 0, inrange i32 0, i64 2), ptr %m_numCompoundPairsOut, align 8
  %m_size.i91 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 35, i32 1
  %m_clContext.i92 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 35, i32 4
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size.i91, i8 0, i64 24, i1 false)
  store ptr %ctx, ptr %m_clContext.i92, align 8
  %m_commandQueue.i93 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 35, i32 5
  store ptr %q, ptr %m_commandQueue.i93, align 8
  %m_ownsMemory.i94 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 35, i32 6
  store i8 1, ptr %m_ownsMemory.i94, align 8
  %m_allowGrowingCapacity.i95 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 35, i32 7
  store i8 1, ptr %m_allowGrowingCapacity.i95, align 1
  store i32 0, ptr %ref.tmp, align 4
  %0 = load i64, ptr %m_size.i41, align 8
  %m_capacity.i.i = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 25, i32 2
  %1 = load i64, ptr %m_capacity.i.i, align 8
  %cmp.i = icmp eq i64 %0, %1
  br i1 %cmp.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %invoke.cont45
  %tobool.not.i.i = icmp eq i64 %0, 0
  %mul.i.i = shl i64 %0, 1
  %cond.i.i = select i1 %tobool.not.i.i, i64 1, i64 %mul.i.i
  %call5.i96 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayIiE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut, i64 noundef %cond.i.i, i1 noundef zeroext true)
          to label %if.end.i unwind label %lpad47

if.end.i:                                         ; preds = %if.then.i, %invoke.cont45
  %tobool.not.i3.i = icmp eq i64 %0, -1
  br i1 %tobool.not.i3.i, label %do.body.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.end.i
  %2 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %3 = load ptr, ptr %m_commandQueue.i43, align 8
  %m_clBuffer.i.i = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 25, i32 3
  %4 = load ptr, ptr %m_clBuffer.i.i, align 8
  %mul2.i.i = shl i64 %0, 2
  %call.i.i97 = invoke i32 %2(ptr noundef %3, ptr noundef %4, i32 noundef 0, i64 noundef %mul2.i.i, i64 noundef 4, ptr noundef nonnull %ref.tmp, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call.i.i.noexc unwind label %lpad47

call.i.i.noexc:                                   ; preds = %if.then.i.i
  %5 = load ptr, ptr @__clewFinish, align 8
  %6 = load ptr, ptr %m_commandQueue.i43, align 8
  %call6.i.i98 = invoke i32 %5(ptr noundef %6)
          to label %invoke.cont48 unwind label %lpad47

do.body.i.i:                                      ; preds = %if.end.i
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 258)
          to label %.noexc unwind label %lpad47

.noexc:                                           ; preds = %do.body.i.i
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.77)
          to label %invoke.cont48 unwind label %lpad47

invoke.cont48:                                    ; preds = %call.i.i.noexc, %.noexc
  %7 = load i64, ptr %m_size.i41, align 8
  %inc.i = add i64 %7, 1
  store i64 %inc.i, ptr %m_size.i41, align 8
  store i32 0, ptr %errNum, align 4
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(1024) %flags, i8 0, i64 1024, i1 false)
  %m_mprPenetrationKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 5
  %m_findSeparatingAxisUnitSphereKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 6
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %m_mprPenetrationKernel, i8 0, i64 16, i1 false)
  %8 = load i8, ptr @useMprGpu, align 1
  %9 = and i8 %8, 1
  %tobool.not = icmp eq i8 %9, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %invoke.cont48
  %10 = load ptr, ptr %m_context, align 8
  %11 = load ptr, ptr %m_device, align 8
  %call.i100 = invoke noundef ptr @b3OpenCLUtils_compileCLProgramFromString(ptr noundef %10, ptr noundef %11, ptr noundef nonnull @.str.66, ptr noundef nonnull %errNum, ptr noundef nonnull %flags, ptr noundef nonnull @.str.3, i1 noundef zeroext false)
          to label %invoke.cont51 unwind label %lpad47

invoke.cont51:                                    ; preds = %if.then
  %12 = load ptr, ptr %m_context, align 8
  %13 = load ptr, ptr %m_device, align 8
  %call.i101 = invoke noundef ptr @b3OpenCLUtils_compileCLKernelFromString(ptr noundef %12, ptr noundef %13, ptr noundef nonnull @.str.66, ptr noundef nonnull @.str.4, ptr noundef nonnull %errNum, ptr noundef %call.i100, ptr noundef nonnull @.str.5)
          to label %invoke.cont55 unwind label %lpad47

invoke.cont55:                                    ; preds = %invoke.cont51
  store ptr %call.i101, ptr %m_mprPenetrationKernel, align 8
  %14 = load ptr, ptr %m_context, align 8
  %15 = load ptr, ptr %m_device, align 8
  %call.i102 = invoke noundef ptr @b3OpenCLUtils_compileCLKernelFromString(ptr noundef %14, ptr noundef %15, ptr noundef nonnull @.str.66, ptr noundef nonnull @.str.6, ptr noundef nonnull %errNum, ptr noundef %call.i100, ptr noundef nonnull @.str.5)
          to label %invoke.cont60 unwind label %lpad47

invoke.cont60:                                    ; preds = %invoke.cont55
  store ptr %call.i102, ptr %m_findSeparatingAxisUnitSphereKernel, align 8
  %16 = load i64, ptr %m_size.i, align 8
  %cmp3.i = icmp ult i64 %16, 162
  br i1 %cmp3.i, label %if.end7.i, label %invoke.cont64

if.end7.i:                                        ; preds = %invoke.cont60
  %call5.i106 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_unitSphereDirections, i64 noundef 162, i1 noundef zeroext true)
          to label %call5.i.noexc105 unwind label %lpad47

call5.i.noexc105:                                 ; preds = %if.end7.i
  %spec.select.i = select i1 %call5.i106, i64 162, i64 0
  br label %invoke.cont64

invoke.cont64:                                    ; preds = %call5.i.noexc105, %invoke.cont60
  %storemerge.i = phi i64 [ 162, %invoke.cont60 ], [ %spec.select.i, %call5.i.noexc105 ]
  store i64 %storemerge.i, ptr %m_size.i, align 8
  %17 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %18 = load ptr, ptr %m_commandQueue.i, align 8
  %m_clBuffer.i = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 24, i32 3
  %19 = load ptr, ptr %m_clBuffer.i, align 8
  %call.i110 = invoke i32 %17(ptr noundef %18, ptr noundef %19, i32 noundef 0, i64 noundef 0, i64 noundef 2592, ptr noundef nonnull @unitSphere162, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call.i.noexc unwind label %lpad47

call.i.noexc:                                     ; preds = %invoke.cont64
  %20 = load ptr, ptr @__clewFinish, align 8
  %21 = load ptr, ptr %m_commandQueue.i, align 8
  %call6.i111 = invoke i32 %20(ptr noundef %21)
          to label %if.end unwind label %lpad47

lpad47:                                           ; preds = %invoke.cont162, %invoke.cont158, %invoke.cont154, %invoke.cont150, %invoke.cont146, %invoke.cont142, %invoke.cont138, %invoke.cont134, %invoke.cont130, %invoke.cont126, %invoke.cont122, %invoke.cont118, %invoke.cont112, %invoke.cont108, %invoke.cont104, %invoke.cont100, %invoke.cont96, %invoke.cont91, %invoke.cont86, %invoke.cont81, %invoke.cont77, %invoke.cont72, %if.end, %call.i.noexc, %invoke.cont64, %if.end7.i, %invoke.cont55, %invoke.cont51, %if.then, %.noexc, %do.body.i.i, %call.i.i.noexc, %if.then.i.i, %if.then.i
  %22 = landingpad { ptr, i32 }
          cleanup
  call void @_ZN13b3OpenCLArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_numCompoundPairsOut) #26
  call void @_ZN13b3OpenCLArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuHasCompoundSepNormals) #26
  call void @_ZN13b3OpenCLArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuCompoundSepNormals) #26
  call void @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuCompoundPairs) #26
  call void @_ZN13b3OpenCLArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_numConcavePairsOut) #26
  call void @_ZN13b3OpenCLArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveHasSeparatingNormals) #26
  call void @_ZN13b3OpenCLArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveSepNormals) #26
  call void @_ZN13b3OpenCLArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_hasSeparatingNormals) #26
  call void @_ZN13b3OpenCLArrayIfED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_dmins) #26
  call void @_ZN13b3OpenCLArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_sepNormals) #26
  call void @_ZN13b3OpenCLArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_totalContactsOut) #26
  call void @_ZN13b3OpenCLArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %m_unitSphereDirections) #26
  resume { ptr, i32 } %22

if.end:                                           ; preds = %call.i.noexc, %invoke.cont48
  %23 = load ptr, ptr %m_context, align 8
  %24 = load ptr, ptr %m_device, align 8
  %call.i113 = invoke noundef ptr @b3OpenCLUtils_compileCLProgramFromString(ptr noundef %23, ptr noundef %24, ptr noundef nonnull @.str.68, ptr noundef nonnull %errNum, ptr noundef nonnull %flags, ptr noundef nonnull @.str.7, i1 noundef zeroext false)
          to label %invoke.cont72 unwind label %lpad47

invoke.cont72:                                    ; preds = %if.end
  %25 = load ptr, ptr %m_context, align 8
  %26 = load ptr, ptr %m_device, align 8
  %call.i116 = invoke noundef ptr @b3OpenCLUtils_compileCLProgramFromString(ptr noundef %25, ptr noundef %26, ptr noundef nonnull @.str.67, ptr noundef nonnull %errNum, ptr noundef nonnull %flags, ptr noundef nonnull @.str.8, i1 noundef zeroext false)
          to label %invoke.cont77 unwind label %lpad47

invoke.cont77:                                    ; preds = %invoke.cont72
  %27 = load ptr, ptr %m_context, align 8
  %28 = load ptr, ptr %m_device, align 8
  %call.i119 = invoke noundef ptr @b3OpenCLUtils_compileCLKernelFromString(ptr noundef %27, ptr noundef %28, ptr noundef nonnull @.str.68, ptr noundef nonnull @.str.9, ptr noundef nonnull %errNum, ptr noundef %call.i113, ptr noundef nonnull @.str.5)
          to label %invoke.cont81 unwind label %lpad47

invoke.cont81:                                    ; preds = %invoke.cont77
  store ptr %call.i119, ptr %m_findSeparatingAxisKernel, align 8
  %29 = load ptr, ptr %m_context, align 8
  %30 = load ptr, ptr %m_device, align 8
  %call.i122 = invoke noundef ptr @b3OpenCLUtils_compileCLKernelFromString(ptr noundef %29, ptr noundef %30, ptr noundef nonnull @.str.68, ptr noundef nonnull @.str.10, ptr noundef nonnull %errNum, ptr noundef %call.i113, ptr noundef nonnull @.str.5)
          to label %invoke.cont86 unwind label %lpad47

invoke.cont86:                                    ; preds = %invoke.cont81
  store ptr %call.i122, ptr %m_findSeparatingAxisVertexFaceKernel, align 8
  %31 = load ptr, ptr %m_context, align 8
  %32 = load ptr, ptr %m_device, align 8
  %call.i125 = invoke noundef ptr @b3OpenCLUtils_compileCLKernelFromString(ptr noundef %31, ptr noundef %32, ptr noundef nonnull @.str.68, ptr noundef nonnull @.str.11, ptr noundef nonnull %errNum, ptr noundef %call.i113, ptr noundef nonnull @.str.5)
          to label %invoke.cont91 unwind label %lpad47

invoke.cont91:                                    ; preds = %invoke.cont86
  store ptr %call.i125, ptr %m_findSeparatingAxisEdgeEdgeKernel, align 8
  %33 = load ptr, ptr %m_context, align 8
  %34 = load ptr, ptr %m_device, align 8
  %call.i128 = invoke noundef ptr @b3OpenCLUtils_compileCLKernelFromString(ptr noundef %33, ptr noundef %34, ptr noundef nonnull @.str.68, ptr noundef nonnull @.str.12, ptr noundef nonnull %errNum, ptr noundef %call.i113, ptr noundef nonnull @.str.5)
          to label %invoke.cont96 unwind label %lpad47

invoke.cont96:                                    ; preds = %invoke.cont91
  %m_findConcaveSeparatingAxisKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 9
  store ptr %call.i128, ptr %m_findConcaveSeparatingAxisKernel, align 8
  %35 = load ptr, ptr %m_context, align 8
  %36 = load ptr, ptr %m_device, align 8
  %call.i131 = invoke noundef ptr @b3OpenCLUtils_compileCLKernelFromString(ptr noundef %35, ptr noundef %36, ptr noundef nonnull @.str.67, ptr noundef nonnull @.str.13, ptr noundef nonnull %errNum, ptr noundef %call.i116, ptr noundef nonnull @.str.5)
          to label %invoke.cont100 unwind label %lpad47

invoke.cont100:                                   ; preds = %invoke.cont96
  %m_findConcaveSeparatingAxisVertexFaceKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 10
  store ptr %call.i131, ptr %m_findConcaveSeparatingAxisVertexFaceKernel, align 8
  %37 = load ptr, ptr %m_context, align 8
  %38 = load ptr, ptr %m_device, align 8
  %call.i134 = invoke noundef ptr @b3OpenCLUtils_compileCLKernelFromString(ptr noundef %37, ptr noundef %38, ptr noundef nonnull @.str.67, ptr noundef nonnull @.str.14, ptr noundef nonnull %errNum, ptr noundef %call.i116, ptr noundef nonnull @.str.5)
          to label %invoke.cont104 unwind label %lpad47

invoke.cont104:                                   ; preds = %invoke.cont100
  %m_findConcaveSeparatingAxisEdgeEdgeKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 11
  store ptr %call.i134, ptr %m_findConcaveSeparatingAxisEdgeEdgeKernel, align 8
  %39 = load ptr, ptr %m_context, align 8
  %40 = load ptr, ptr %m_device, align 8
  %call.i137 = invoke noundef ptr @b3OpenCLUtils_compileCLKernelFromString(ptr noundef %39, ptr noundef %40, ptr noundef nonnull @.str.68, ptr noundef nonnull @.str.15, ptr noundef nonnull %errNum, ptr noundef %call.i113, ptr noundef nonnull @.str.5)
          to label %invoke.cont108 unwind label %lpad47

invoke.cont108:                                   ; preds = %invoke.cont104
  %m_findCompoundPairsKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 12
  store ptr %call.i137, ptr %m_findCompoundPairsKernel, align 8
  %41 = load ptr, ptr %m_context, align 8
  %42 = load ptr, ptr %m_device, align 8
  %call.i140 = invoke noundef ptr @b3OpenCLUtils_compileCLKernelFromString(ptr noundef %41, ptr noundef %42, ptr noundef nonnull @.str.68, ptr noundef nonnull @.str.16, ptr noundef nonnull %errNum, ptr noundef %call.i113, ptr noundef nonnull @.str.5)
          to label %invoke.cont112 unwind label %lpad47

invoke.cont112:                                   ; preds = %invoke.cont108
  %m_processCompoundPairsKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 13
  store ptr %call.i140, ptr %m_processCompoundPairsKernel, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(1024) %flags114, i8 0, i64 1024, i1 false)
  %43 = load ptr, ptr %m_context, align 8
  %44 = load ptr, ptr %m_device, align 8
  %call.i143 = invoke noundef ptr @b3OpenCLUtils_compileCLProgramFromString(ptr noundef %43, ptr noundef %44, ptr noundef nonnull @.str.69, ptr noundef nonnull %errNum, ptr noundef nonnull %flags114, ptr noundef nonnull @.str.17, i1 noundef zeroext false)
          to label %invoke.cont118 unwind label %lpad47

invoke.cont118:                                   ; preds = %invoke.cont112
  %45 = load ptr, ptr %m_context, align 8
  %46 = load ptr, ptr %m_device, align 8
  %call.i146 = invoke noundef ptr @b3OpenCLUtils_compileCLKernelFromString(ptr noundef %45, ptr noundef %46, ptr noundef nonnull @.str.69, ptr noundef nonnull @.str.18, ptr noundef nonnull %errNum, ptr noundef %call.i143, ptr noundef nonnull @.str.5)
          to label %invoke.cont122 unwind label %lpad47

invoke.cont122:                                   ; preds = %invoke.cont118
  %m_clipHullHullKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 14
  store ptr %call.i146, ptr %m_clipHullHullKernel, align 8
  %47 = load ptr, ptr %m_context, align 8
  %48 = load ptr, ptr %m_device, align 8
  %call.i149 = invoke noundef ptr @b3OpenCLUtils_compileCLKernelFromString(ptr noundef %47, ptr noundef %48, ptr noundef nonnull @.str.69, ptr noundef nonnull @.str.19, ptr noundef nonnull %errNum, ptr noundef %call.i143, ptr noundef nonnull @.str.5)
          to label %invoke.cont126 unwind label %lpad47

invoke.cont126:                                   ; preds = %invoke.cont122
  %m_clipCompoundsHullHullKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 15
  store ptr %call.i149, ptr %m_clipCompoundsHullHullKernel, align 8
  %49 = load ptr, ptr %m_context, align 8
  %50 = load ptr, ptr %m_device, align 8
  %call.i152 = invoke noundef ptr @b3OpenCLUtils_compileCLKernelFromString(ptr noundef %49, ptr noundef %50, ptr noundef nonnull @.str.69, ptr noundef nonnull @.str.20, ptr noundef nonnull %errNum, ptr noundef %call.i143, ptr noundef nonnull @.str.5)
          to label %invoke.cont130 unwind label %lpad47

invoke.cont130:                                   ; preds = %invoke.cont126
  %m_findClippingFacesKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 17
  store ptr %call.i152, ptr %m_findClippingFacesKernel, align 8
  %51 = load ptr, ptr %m_context, align 8
  %52 = load ptr, ptr %m_device, align 8
  %call.i155 = invoke noundef ptr @b3OpenCLUtils_compileCLKernelFromString(ptr noundef %51, ptr noundef %52, ptr noundef nonnull @.str.69, ptr noundef nonnull @.str.21, ptr noundef nonnull %errNum, ptr noundef %call.i143, ptr noundef nonnull @.str.5)
          to label %invoke.cont134 unwind label %lpad47

invoke.cont134:                                   ; preds = %invoke.cont130
  %m_clipFacesAndFindContacts = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 16
  store ptr %call.i155, ptr %m_clipFacesAndFindContacts, align 8
  %53 = load ptr, ptr %m_context, align 8
  %54 = load ptr, ptr %m_device, align 8
  %call.i158 = invoke noundef ptr @b3OpenCLUtils_compileCLKernelFromString(ptr noundef %53, ptr noundef %54, ptr noundef nonnull @.str.69, ptr noundef nonnull @.str.22, ptr noundef nonnull %errNum, ptr noundef %call.i143, ptr noundef nonnull @.str.5)
          to label %invoke.cont138 unwind label %lpad47

invoke.cont138:                                   ; preds = %invoke.cont134
  %m_clipHullHullConcaveConvexKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 18
  store ptr %call.i158, ptr %m_clipHullHullConcaveConvexKernel, align 8
  %55 = load ptr, ptr %m_context, align 8
  %56 = load ptr, ptr %m_device, align 8
  %call.i161 = invoke noundef ptr @b3OpenCLUtils_compileCLKernelFromString(ptr noundef %55, ptr noundef %56, ptr noundef nonnull @.str.69, ptr noundef nonnull @.str.23, ptr noundef nonnull %errNum, ptr noundef %call.i143, ptr noundef nonnull @.str.5)
          to label %invoke.cont142 unwind label %lpad47

invoke.cont142:                                   ; preds = %invoke.cont138
  %m_newContactReductionKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 19
  store ptr %call.i161, ptr %m_newContactReductionKernel, align 8
  %57 = load ptr, ptr %m_context, align 8
  %58 = load ptr, ptr %m_device, align 8
  %call.i164 = invoke noundef ptr @b3OpenCLUtils_compileCLProgramFromString(ptr noundef %57, ptr noundef %58, ptr noundef nonnull @.str.70, ptr noundef nonnull %errNum, ptr noundef nonnull @.str.5, ptr noundef nonnull @.str.24, i1 noundef zeroext false)
          to label %invoke.cont146 unwind label %lpad47

invoke.cont146:                                   ; preds = %invoke.cont142
  %59 = load ptr, ptr %m_context, align 8
  %60 = load ptr, ptr %m_device, align 8
  %call.i167 = invoke noundef ptr @b3OpenCLUtils_compileCLKernelFromString(ptr noundef %59, ptr noundef %60, ptr noundef nonnull @.str.70, ptr noundef nonnull @.str.25, ptr noundef nonnull %errNum, ptr noundef %call.i164, ptr noundef nonnull @.str.5)
          to label %invoke.cont150 unwind label %lpad47

invoke.cont150:                                   ; preds = %invoke.cont146
  %m_bvhTraversalKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 20
  store ptr %call.i167, ptr %m_bvhTraversalKernel, align 8
  %61 = load ptr, ptr %m_context, align 8
  %62 = load ptr, ptr %m_device, align 8
  %call.i170 = invoke noundef ptr @b3OpenCLUtils_compileCLProgramFromString(ptr noundef %61, ptr noundef %62, ptr noundef nonnull @.str.71, ptr noundef nonnull %errNum, ptr noundef nonnull @.str.5, ptr noundef nonnull @.str.26, i1 noundef zeroext false)
          to label %invoke.cont154 unwind label %lpad47

invoke.cont154:                                   ; preds = %invoke.cont150
  %63 = load ptr, ptr %m_context, align 8
  %64 = load ptr, ptr %m_device, align 8
  %call.i173 = invoke noundef ptr @b3OpenCLUtils_compileCLKernelFromString(ptr noundef %63, ptr noundef %64, ptr noundef nonnull @.str.71, ptr noundef nonnull @.str.27, ptr noundef nonnull %errNum, ptr noundef %call.i170, ptr noundef nonnull @.str.5)
          to label %invoke.cont158 unwind label %lpad47

invoke.cont158:                                   ; preds = %invoke.cont154
  %m_primitiveContactsKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 21
  store ptr %call.i173, ptr %m_primitiveContactsKernel, align 8
  %65 = load ptr, ptr %m_context, align 8
  %66 = load ptr, ptr %m_device, align 8
  %call.i176 = invoke noundef ptr @b3OpenCLUtils_compileCLKernelFromString(ptr noundef %65, ptr noundef %66, ptr noundef nonnull @.str.71, ptr noundef nonnull @.str.28, ptr noundef nonnull %errNum, ptr noundef %call.i170, ptr noundef nonnull @.str.5)
          to label %invoke.cont162 unwind label %lpad47

invoke.cont162:                                   ; preds = %invoke.cont158
  %m_findConcaveSphereContactsKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 22
  store ptr %call.i176, ptr %m_findConcaveSphereContactsKernel, align 8
  %67 = load ptr, ptr %m_context, align 8
  %68 = load ptr, ptr %m_device, align 8
  %call.i179 = invoke noundef ptr @b3OpenCLUtils_compileCLKernelFromString(ptr noundef %67, ptr noundef %68, ptr noundef nonnull @.str.71, ptr noundef nonnull @.str.29, ptr noundef nonnull %errNum, ptr noundef %call.i170, ptr noundef nonnull @.str.5)
          to label %invoke.cont166 unwind label %lpad47

invoke.cont166:                                   ; preds = %invoke.cont162
  %m_processCompoundPairsPrimitivesKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 23
  store ptr %call.i179, ptr %m_processCompoundPairsPrimitivesKernel, align 8
  ret void
}

declare i32 @__gxx_personality_v0(...)

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #9

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %this) unnamed_addr #10 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayIiE, i64 0, inrange i32 0, i64 2), ptr %this, align 8
  %m_clBuffer.i = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this, i64 0, i32 3
  %0 = load ptr, ptr %m_clBuffer.i, align 8
  %tobool.not.i = icmp eq ptr %0, null
  br i1 %tobool.not.i, label %invoke.cont, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %entry
  %m_ownsMemory.i = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this, i64 0, i32 6
  %1 = load i8, ptr %m_ownsMemory.i, align 8
  %2 = and i8 %1, 1
  %tobool2.not.i = icmp eq i8 %2, 0
  br i1 %tobool2.not.i, label %invoke.cont, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i
  %3 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i1 = invoke i32 %3(ptr noundef nonnull %0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %land.lhs.true.i, %entry, %if.then.i
  %m_size = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this, i64 0, i32 1
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size, i8 0, i64 24, i1 false)
  ret void

terminate.lpad:                                   ; preds = %if.then.i
  %4 = landingpad { ptr, i32 }
          catch ptr null
  %5 = extractvalue { ptr, i32 } %4, 0
  tail call void @__clang_call_terminate(ptr %5) #27
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %this) unnamed_addr #10 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayI9b3Vector3E, i64 0, inrange i32 0, i64 2), ptr %this, align 8
  %m_clBuffer.i = getelementptr inbounds %class.b3OpenCLArray, ptr %this, i64 0, i32 3
  %0 = load ptr, ptr %m_clBuffer.i, align 8
  %tobool.not.i = icmp eq ptr %0, null
  br i1 %tobool.not.i, label %invoke.cont, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %entry
  %m_ownsMemory.i = getelementptr inbounds %class.b3OpenCLArray, ptr %this, i64 0, i32 6
  %1 = load i8, ptr %m_ownsMemory.i, align 8
  %2 = and i8 %1, 1
  %tobool2.not.i = icmp eq i8 %2, 0
  br i1 %tobool2.not.i, label %invoke.cont, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i
  %3 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i1 = invoke i32 %3(ptr noundef nonnull %0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %land.lhs.true.i, %entry, %if.then.i
  %m_size = getelementptr inbounds %class.b3OpenCLArray, ptr %this, i64 0, i32 1
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size, i8 0, i64 24, i1 false)
  ret void

terminate.lpad:                                   ; preds = %if.then.i
  %4 = landingpad { ptr, i32 }
          catch ptr null
  %5 = extractvalue { ptr, i32 } %4, 0
  tail call void @__clang_call_terminate(ptr %5) #27
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %this) unnamed_addr #10 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayI25b3CompoundOverlappingPairE, i64 0, inrange i32 0, i64 2), ptr %this, align 8
  %m_clBuffer.i = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this, i64 0, i32 3
  %0 = load ptr, ptr %m_clBuffer.i, align 8
  %tobool.not.i = icmp eq ptr %0, null
  br i1 %tobool.not.i, label %invoke.cont, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %entry
  %m_ownsMemory.i = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this, i64 0, i32 6
  %1 = load i8, ptr %m_ownsMemory.i, align 8
  %2 = and i8 %1, 1
  %tobool2.not.i = icmp eq i8 %2, 0
  br i1 %tobool2.not.i, label %invoke.cont, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i
  %3 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i1 = invoke i32 %3(ptr noundef nonnull %0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %land.lhs.true.i, %entry, %if.then.i
  %m_size = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this, i64 0, i32 1
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size, i8 0, i64 24, i1 false)
  ret void

terminate.lpad:                                   ; preds = %if.then.i
  %4 = landingpad { ptr, i32 }
          catch ptr null
  %5 = extractvalue { ptr, i32 } %4, 0
  tail call void @__clang_call_terminate(ptr %5) #27
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayIfED2Ev(ptr noundef nonnull align 8 dereferenceable(50) %this) unnamed_addr #10 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayIfE, i64 0, inrange i32 0, i64 2), ptr %this, align 8
  %m_clBuffer.i = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this, i64 0, i32 3
  %0 = load ptr, ptr %m_clBuffer.i, align 8
  %tobool.not.i = icmp eq ptr %0, null
  br i1 %tobool.not.i, label %invoke.cont, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %entry
  %m_ownsMemory.i = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this, i64 0, i32 6
  %1 = load i8, ptr %m_ownsMemory.i, align 8
  %2 = and i8 %1, 1
  %tobool2.not.i = icmp eq i8 %2, 0
  br i1 %tobool2.not.i, label %invoke.cont, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i
  %3 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i1 = invoke i32 %3(ptr noundef nonnull %0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %land.lhs.true.i, %entry, %if.then.i
  %m_size = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this, i64 0, i32 1
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size, i8 0, i64 24, i1 false)
  ret void

terminate.lpad:                                   ; preds = %if.then.i
  %4 = landingpad { ptr, i32 }
          catch ptr null
  %5 = extractvalue { ptr, i32 } %4, 0
  tail call void @__clang_call_terminate(ptr %5) #27
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define dso_local void @_ZN15GpuSatCollisionD2Ev(ptr noundef nonnull align 8 dereferenceable(864) %this) unnamed_addr #10 align 2 personality ptr @__gxx_personality_v0 {
entry:
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV15GpuSatCollision, i64 0, inrange i32 0, i64 2), ptr %this, align 8
  %m_findSeparatingAxisVertexFaceKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 7
  %0 = load ptr, ptr %m_findSeparatingAxisVertexFaceKernel, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @__clewReleaseKernel, align 8
  %call = invoke i32 %1(ptr noundef nonnull %0)
          to label %if.end unwind label %terminate.lpad

if.end:                                           ; preds = %if.then, %entry
  %m_findSeparatingAxisEdgeEdgeKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 8
  %2 = load ptr, ptr %m_findSeparatingAxisEdgeEdgeKernel, align 8
  %tobool3.not = icmp eq ptr %2, null
  br i1 %tobool3.not, label %if.end8, label %if.then4

if.then4:                                         ; preds = %if.end
  %3 = load ptr, ptr @__clewReleaseKernel, align 8
  %call7 = invoke i32 %3(ptr noundef nonnull %2)
          to label %if.end8 unwind label %terminate.lpad

if.end8:                                          ; preds = %if.then4, %if.end
  %m_findSeparatingAxisUnitSphereKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 6
  %4 = load ptr, ptr %m_findSeparatingAxisUnitSphereKernel, align 8
  %tobool9.not = icmp eq ptr %4, null
  br i1 %tobool9.not, label %if.end14, label %if.then10

if.then10:                                        ; preds = %if.end8
  %5 = load ptr, ptr @__clewReleaseKernel, align 8
  %call13 = invoke i32 %5(ptr noundef nonnull %4)
          to label %if.end14 unwind label %terminate.lpad

if.end14:                                         ; preds = %if.then10, %if.end8
  %m_mprPenetrationKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 5
  %6 = load ptr, ptr %m_mprPenetrationKernel, align 8
  %tobool15.not = icmp eq ptr %6, null
  br i1 %tobool15.not, label %if.end20, label %if.then16

if.then16:                                        ; preds = %if.end14
  %7 = load ptr, ptr @__clewReleaseKernel, align 8
  %call19 = invoke i32 %7(ptr noundef nonnull %6)
          to label %if.end20 unwind label %terminate.lpad

if.end20:                                         ; preds = %if.then16, %if.end14
  %m_findSeparatingAxisKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 4
  %8 = load ptr, ptr %m_findSeparatingAxisKernel, align 8
  %tobool21.not = icmp eq ptr %8, null
  br i1 %tobool21.not, label %if.end26, label %if.then22

if.then22:                                        ; preds = %if.end20
  %9 = load ptr, ptr @__clewReleaseKernel, align 8
  %call25 = invoke i32 %9(ptr noundef nonnull %8)
          to label %if.end26 unwind label %terminate.lpad

if.end26:                                         ; preds = %if.then22, %if.end20
  %m_findConcaveSeparatingAxisVertexFaceKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 10
  %10 = load ptr, ptr %m_findConcaveSeparatingAxisVertexFaceKernel, align 8
  %tobool27.not = icmp eq ptr %10, null
  br i1 %tobool27.not, label %if.end32, label %if.then28

if.then28:                                        ; preds = %if.end26
  %11 = load ptr, ptr @__clewReleaseKernel, align 8
  %call31 = invoke i32 %11(ptr noundef nonnull %10)
          to label %if.end32 unwind label %terminate.lpad

if.end32:                                         ; preds = %if.then28, %if.end26
  %m_findConcaveSeparatingAxisEdgeEdgeKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 11
  %12 = load ptr, ptr %m_findConcaveSeparatingAxisEdgeEdgeKernel, align 8
  %tobool33.not = icmp eq ptr %12, null
  br i1 %tobool33.not, label %if.end38, label %if.then34

if.then34:                                        ; preds = %if.end32
  %13 = load ptr, ptr @__clewReleaseKernel, align 8
  %call37 = invoke i32 %13(ptr noundef nonnull %12)
          to label %if.end38 unwind label %terminate.lpad

if.end38:                                         ; preds = %if.then34, %if.end32
  %m_findConcaveSeparatingAxisKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 9
  %14 = load ptr, ptr %m_findConcaveSeparatingAxisKernel, align 8
  %tobool39.not = icmp eq ptr %14, null
  br i1 %tobool39.not, label %if.end44, label %if.then40

if.then40:                                        ; preds = %if.end38
  %15 = load ptr, ptr @__clewReleaseKernel, align 8
  %call43 = invoke i32 %15(ptr noundef nonnull %14)
          to label %if.end44 unwind label %terminate.lpad

if.end44:                                         ; preds = %if.then40, %if.end38
  %m_findCompoundPairsKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 12
  %16 = load ptr, ptr %m_findCompoundPairsKernel, align 8
  %tobool45.not = icmp eq ptr %16, null
  br i1 %tobool45.not, label %if.end50, label %if.then46

if.then46:                                        ; preds = %if.end44
  %17 = load ptr, ptr @__clewReleaseKernel, align 8
  %call49 = invoke i32 %17(ptr noundef nonnull %16)
          to label %if.end50 unwind label %terminate.lpad

if.end50:                                         ; preds = %if.then46, %if.end44
  %m_processCompoundPairsKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 13
  %18 = load ptr, ptr %m_processCompoundPairsKernel, align 8
  %tobool51.not = icmp eq ptr %18, null
  br i1 %tobool51.not, label %if.end56, label %if.then52

if.then52:                                        ; preds = %if.end50
  %19 = load ptr, ptr @__clewReleaseKernel, align 8
  %call55 = invoke i32 %19(ptr noundef nonnull %18)
          to label %if.end56 unwind label %terminate.lpad

if.end56:                                         ; preds = %if.then52, %if.end50
  %m_findClippingFacesKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 17
  %20 = load ptr, ptr %m_findClippingFacesKernel, align 8
  %tobool57.not = icmp eq ptr %20, null
  br i1 %tobool57.not, label %if.end62, label %if.then58

if.then58:                                        ; preds = %if.end56
  %21 = load ptr, ptr @__clewReleaseKernel, align 8
  %call61 = invoke i32 %21(ptr noundef nonnull %20)
          to label %if.end62 unwind label %terminate.lpad

if.end62:                                         ; preds = %if.then58, %if.end56
  %m_clipFacesAndFindContacts = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 16
  %22 = load ptr, ptr %m_clipFacesAndFindContacts, align 8
  %tobool63.not = icmp eq ptr %22, null
  br i1 %tobool63.not, label %if.end68, label %if.then64

if.then64:                                        ; preds = %if.end62
  %23 = load ptr, ptr @__clewReleaseKernel, align 8
  %call67 = invoke i32 %23(ptr noundef nonnull %22)
          to label %if.end68 unwind label %terminate.lpad

if.end68:                                         ; preds = %if.then64, %if.end62
  %m_newContactReductionKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 19
  %24 = load ptr, ptr %m_newContactReductionKernel, align 8
  %tobool69.not = icmp eq ptr %24, null
  br i1 %tobool69.not, label %if.end74, label %if.then70

if.then70:                                        ; preds = %if.end68
  %25 = load ptr, ptr @__clewReleaseKernel, align 8
  %call73 = invoke i32 %25(ptr noundef nonnull %24)
          to label %if.end74 unwind label %terminate.lpad

if.end74:                                         ; preds = %if.then70, %if.end68
  %m_primitiveContactsKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 21
  %26 = load ptr, ptr %m_primitiveContactsKernel, align 8
  %tobool75.not = icmp eq ptr %26, null
  br i1 %tobool75.not, label %if.end80, label %if.then76

if.then76:                                        ; preds = %if.end74
  %27 = load ptr, ptr @__clewReleaseKernel, align 8
  %call79 = invoke i32 %27(ptr noundef nonnull %26)
          to label %if.end80 unwind label %terminate.lpad

if.end80:                                         ; preds = %if.then76, %if.end74
  %m_findConcaveSphereContactsKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 22
  %28 = load ptr, ptr %m_findConcaveSphereContactsKernel, align 8
  %tobool81.not = icmp eq ptr %28, null
  br i1 %tobool81.not, label %if.end86, label %if.then82

if.then82:                                        ; preds = %if.end80
  %29 = load ptr, ptr @__clewReleaseKernel, align 8
  %call85 = invoke i32 %29(ptr noundef nonnull %28)
          to label %if.end86 unwind label %terminate.lpad

if.end86:                                         ; preds = %if.then82, %if.end80
  %m_processCompoundPairsPrimitivesKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 23
  %30 = load ptr, ptr %m_processCompoundPairsPrimitivesKernel, align 8
  %tobool87.not = icmp eq ptr %30, null
  br i1 %tobool87.not, label %if.end92, label %if.then88

if.then88:                                        ; preds = %if.end86
  %31 = load ptr, ptr @__clewReleaseKernel, align 8
  %call91 = invoke i32 %31(ptr noundef nonnull %30)
          to label %if.end92 unwind label %terminate.lpad

if.end92:                                         ; preds = %if.then88, %if.end86
  %m_clipHullHullKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 14
  %32 = load ptr, ptr %m_clipHullHullKernel, align 8
  %tobool93.not = icmp eq ptr %32, null
  br i1 %tobool93.not, label %if.end98, label %if.then94

if.then94:                                        ; preds = %if.end92
  %33 = load ptr, ptr @__clewReleaseKernel, align 8
  %call97 = invoke i32 %33(ptr noundef nonnull %32)
          to label %if.end98 unwind label %terminate.lpad

if.end98:                                         ; preds = %if.then94, %if.end92
  %m_clipCompoundsHullHullKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 15
  %34 = load ptr, ptr %m_clipCompoundsHullHullKernel, align 8
  %tobool99.not = icmp eq ptr %34, null
  br i1 %tobool99.not, label %if.end104, label %if.then100

if.then100:                                       ; preds = %if.end98
  %35 = load ptr, ptr @__clewReleaseKernel, align 8
  %call103 = invoke i32 %35(ptr noundef nonnull %34)
          to label %if.end104 unwind label %terminate.lpad

if.end104:                                        ; preds = %if.then100, %if.end98
  %m_clipHullHullConcaveConvexKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 18
  %36 = load ptr, ptr %m_clipHullHullConcaveConvexKernel, align 8
  %tobool105.not = icmp eq ptr %36, null
  br i1 %tobool105.not, label %if.end110, label %if.then106

if.then106:                                       ; preds = %if.end104
  %37 = load ptr, ptr @__clewReleaseKernel, align 8
  %call109 = invoke i32 %37(ptr noundef nonnull %36)
          to label %if.end110 unwind label %terminate.lpad

if.end110:                                        ; preds = %if.then106, %if.end104
  %m_bvhTraversalKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 20
  %38 = load ptr, ptr %m_bvhTraversalKernel, align 8
  %tobool111.not = icmp eq ptr %38, null
  br i1 %tobool111.not, label %if.end116, label %if.then112

if.then112:                                       ; preds = %if.end110
  %39 = load ptr, ptr @__clewReleaseKernel, align 8
  %call115 = invoke i32 %39(ptr noundef nonnull %38)
          to label %if.end116 unwind label %terminate.lpad

if.end116:                                        ; preds = %if.then112, %if.end110
  %m_numCompoundPairsOut = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 35
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayIiE, i64 0, inrange i32 0, i64 2), ptr %m_numCompoundPairsOut, align 8
  %m_clBuffer.i.i = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 35, i32 3
  %40 = load ptr, ptr %m_clBuffer.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %40, null
  br i1 %tobool.not.i.i, label %_ZN13b3OpenCLArrayIiED2Ev.exit, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %if.end116
  %m_ownsMemory.i.i = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 35, i32 6
  %41 = load i8, ptr %m_ownsMemory.i.i, align 8
  %42 = and i8 %41, 1
  %tobool2.not.i.i = icmp eq i8 %42, 0
  br i1 %tobool2.not.i.i, label %_ZN13b3OpenCLArrayIiED2Ev.exit, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.lhs.true.i.i
  %43 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i1.i = invoke i32 %43(ptr noundef nonnull %40)
          to label %_ZN13b3OpenCLArrayIiED2Ev.exit unwind label %terminate.lpad.i

terminate.lpad.i:                                 ; preds = %if.then.i.i
  %44 = landingpad { ptr, i32 }
          catch ptr null
  %45 = extractvalue { ptr, i32 } %44, 0
  tail call void @__clang_call_terminate(ptr %45) #27
  unreachable

_ZN13b3OpenCLArrayIiED2Ev.exit:                   ; preds = %if.end116, %land.lhs.true.i.i, %if.then.i.i
  %m_size.i = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 35, i32 1
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size.i, i8 0, i64 24, i1 false)
  %m_gpuHasCompoundSepNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 34
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayIiE, i64 0, inrange i32 0, i64 2), ptr %m_gpuHasCompoundSepNormals, align 8
  %m_clBuffer.i.i20 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 34, i32 3
  %46 = load ptr, ptr %m_clBuffer.i.i20, align 8
  %tobool.not.i.i21 = icmp eq ptr %46, null
  br i1 %tobool.not.i.i21, label %_ZN13b3OpenCLArrayIiED2Ev.exit29, label %land.lhs.true.i.i22

land.lhs.true.i.i22:                              ; preds = %_ZN13b3OpenCLArrayIiED2Ev.exit
  %m_ownsMemory.i.i23 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 34, i32 6
  %47 = load i8, ptr %m_ownsMemory.i.i23, align 8
  %48 = and i8 %47, 1
  %tobool2.not.i.i24 = icmp eq i8 %48, 0
  br i1 %tobool2.not.i.i24, label %_ZN13b3OpenCLArrayIiED2Ev.exit29, label %if.then.i.i25

if.then.i.i25:                                    ; preds = %land.lhs.true.i.i22
  %49 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i1.i26 = invoke i32 %49(ptr noundef nonnull %46)
          to label %_ZN13b3OpenCLArrayIiED2Ev.exit29 unwind label %terminate.lpad.i27

terminate.lpad.i27:                               ; preds = %if.then.i.i25
  %50 = landingpad { ptr, i32 }
          catch ptr null
  %51 = extractvalue { ptr, i32 } %50, 0
  tail call void @__clang_call_terminate(ptr %51) #27
  unreachable

_ZN13b3OpenCLArrayIiED2Ev.exit29:                 ; preds = %_ZN13b3OpenCLArrayIiED2Ev.exit, %land.lhs.true.i.i22, %if.then.i.i25
  %m_size.i28 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 34, i32 1
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size.i28, i8 0, i64 24, i1 false)
  %m_gpuCompoundSepNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 33
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayI9b3Vector3E, i64 0, inrange i32 0, i64 2), ptr %m_gpuCompoundSepNormals, align 8
  %m_clBuffer.i.i30 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 33, i32 3
  %52 = load ptr, ptr %m_clBuffer.i.i30, align 8
  %tobool.not.i.i31 = icmp eq ptr %52, null
  br i1 %tobool.not.i.i31, label %_ZN13b3OpenCLArrayI9b3Vector3ED2Ev.exit, label %land.lhs.true.i.i32

land.lhs.true.i.i32:                              ; preds = %_ZN13b3OpenCLArrayIiED2Ev.exit29
  %m_ownsMemory.i.i33 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 33, i32 6
  %53 = load i8, ptr %m_ownsMemory.i.i33, align 8
  %54 = and i8 %53, 1
  %tobool2.not.i.i34 = icmp eq i8 %54, 0
  br i1 %tobool2.not.i.i34, label %_ZN13b3OpenCLArrayI9b3Vector3ED2Ev.exit, label %if.then.i.i35

if.then.i.i35:                                    ; preds = %land.lhs.true.i.i32
  %55 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i1.i36 = invoke i32 %55(ptr noundef nonnull %52)
          to label %_ZN13b3OpenCLArrayI9b3Vector3ED2Ev.exit unwind label %terminate.lpad.i37

terminate.lpad.i37:                               ; preds = %if.then.i.i35
  %56 = landingpad { ptr, i32 }
          catch ptr null
  %57 = extractvalue { ptr, i32 } %56, 0
  tail call void @__clang_call_terminate(ptr %57) #27
  unreachable

_ZN13b3OpenCLArrayI9b3Vector3ED2Ev.exit:          ; preds = %_ZN13b3OpenCLArrayIiED2Ev.exit29, %land.lhs.true.i.i32, %if.then.i.i35
  %m_size.i38 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 33, i32 1
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size.i38, i8 0, i64 24, i1 false)
  %m_gpuCompoundPairs = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 32
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayI25b3CompoundOverlappingPairE, i64 0, inrange i32 0, i64 2), ptr %m_gpuCompoundPairs, align 8
  %m_clBuffer.i.i39 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 32, i32 3
  %58 = load ptr, ptr %m_clBuffer.i.i39, align 8
  %tobool.not.i.i40 = icmp eq ptr %58, null
  br i1 %tobool.not.i.i40, label %_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairED2Ev.exit, label %land.lhs.true.i.i41

land.lhs.true.i.i41:                              ; preds = %_ZN13b3OpenCLArrayI9b3Vector3ED2Ev.exit
  %m_ownsMemory.i.i42 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 32, i32 6
  %59 = load i8, ptr %m_ownsMemory.i.i42, align 8
  %60 = and i8 %59, 1
  %tobool2.not.i.i43 = icmp eq i8 %60, 0
  br i1 %tobool2.not.i.i43, label %_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairED2Ev.exit, label %if.then.i.i44

if.then.i.i44:                                    ; preds = %land.lhs.true.i.i41
  %61 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i1.i45 = invoke i32 %61(ptr noundef nonnull %58)
          to label %_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairED2Ev.exit unwind label %terminate.lpad.i46

terminate.lpad.i46:                               ; preds = %if.then.i.i44
  %62 = landingpad { ptr, i32 }
          catch ptr null
  %63 = extractvalue { ptr, i32 } %62, 0
  tail call void @__clang_call_terminate(ptr %63) #27
  unreachable

_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairED2Ev.exit: ; preds = %_ZN13b3OpenCLArrayI9b3Vector3ED2Ev.exit, %land.lhs.true.i.i41, %if.then.i.i44
  %m_size.i47 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 32, i32 1
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size.i47, i8 0, i64 24, i1 false)
  %m_numConcavePairsOut = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 31
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayIiE, i64 0, inrange i32 0, i64 2), ptr %m_numConcavePairsOut, align 8
  %m_clBuffer.i.i48 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 31, i32 3
  %64 = load ptr, ptr %m_clBuffer.i.i48, align 8
  %tobool.not.i.i49 = icmp eq ptr %64, null
  br i1 %tobool.not.i.i49, label %_ZN13b3OpenCLArrayIiED2Ev.exit57, label %land.lhs.true.i.i50

land.lhs.true.i.i50:                              ; preds = %_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairED2Ev.exit
  %m_ownsMemory.i.i51 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 31, i32 6
  %65 = load i8, ptr %m_ownsMemory.i.i51, align 8
  %66 = and i8 %65, 1
  %tobool2.not.i.i52 = icmp eq i8 %66, 0
  br i1 %tobool2.not.i.i52, label %_ZN13b3OpenCLArrayIiED2Ev.exit57, label %if.then.i.i53

if.then.i.i53:                                    ; preds = %land.lhs.true.i.i50
  %67 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i1.i54 = invoke i32 %67(ptr noundef nonnull %64)
          to label %_ZN13b3OpenCLArrayIiED2Ev.exit57 unwind label %terminate.lpad.i55

terminate.lpad.i55:                               ; preds = %if.then.i.i53
  %68 = landingpad { ptr, i32 }
          catch ptr null
  %69 = extractvalue { ptr, i32 } %68, 0
  tail call void @__clang_call_terminate(ptr %69) #27
  unreachable

_ZN13b3OpenCLArrayIiED2Ev.exit57:                 ; preds = %_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairED2Ev.exit, %land.lhs.true.i.i50, %if.then.i.i53
  %m_size.i56 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 31, i32 1
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size.i56, i8 0, i64 24, i1 false)
  %m_concaveHasSeparatingNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 30
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayIiE, i64 0, inrange i32 0, i64 2), ptr %m_concaveHasSeparatingNormals, align 8
  %m_clBuffer.i.i58 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 30, i32 3
  %70 = load ptr, ptr %m_clBuffer.i.i58, align 8
  %tobool.not.i.i59 = icmp eq ptr %70, null
  br i1 %tobool.not.i.i59, label %_ZN13b3OpenCLArrayIiED2Ev.exit67, label %land.lhs.true.i.i60

land.lhs.true.i.i60:                              ; preds = %_ZN13b3OpenCLArrayIiED2Ev.exit57
  %m_ownsMemory.i.i61 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 30, i32 6
  %71 = load i8, ptr %m_ownsMemory.i.i61, align 8
  %72 = and i8 %71, 1
  %tobool2.not.i.i62 = icmp eq i8 %72, 0
  br i1 %tobool2.not.i.i62, label %_ZN13b3OpenCLArrayIiED2Ev.exit67, label %if.then.i.i63

if.then.i.i63:                                    ; preds = %land.lhs.true.i.i60
  %73 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i1.i64 = invoke i32 %73(ptr noundef nonnull %70)
          to label %_ZN13b3OpenCLArrayIiED2Ev.exit67 unwind label %terminate.lpad.i65

terminate.lpad.i65:                               ; preds = %if.then.i.i63
  %74 = landingpad { ptr, i32 }
          catch ptr null
  %75 = extractvalue { ptr, i32 } %74, 0
  tail call void @__clang_call_terminate(ptr %75) #27
  unreachable

_ZN13b3OpenCLArrayIiED2Ev.exit67:                 ; preds = %_ZN13b3OpenCLArrayIiED2Ev.exit57, %land.lhs.true.i.i60, %if.then.i.i63
  %m_size.i66 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 30, i32 1
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size.i66, i8 0, i64 24, i1 false)
  %m_concaveSepNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 29
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayI9b3Vector3E, i64 0, inrange i32 0, i64 2), ptr %m_concaveSepNormals, align 8
  %m_clBuffer.i.i68 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 29, i32 3
  %76 = load ptr, ptr %m_clBuffer.i.i68, align 8
  %tobool.not.i.i69 = icmp eq ptr %76, null
  br i1 %tobool.not.i.i69, label %_ZN13b3OpenCLArrayI9b3Vector3ED2Ev.exit77, label %land.lhs.true.i.i70

land.lhs.true.i.i70:                              ; preds = %_ZN13b3OpenCLArrayIiED2Ev.exit67
  %m_ownsMemory.i.i71 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 29, i32 6
  %77 = load i8, ptr %m_ownsMemory.i.i71, align 8
  %78 = and i8 %77, 1
  %tobool2.not.i.i72 = icmp eq i8 %78, 0
  br i1 %tobool2.not.i.i72, label %_ZN13b3OpenCLArrayI9b3Vector3ED2Ev.exit77, label %if.then.i.i73

if.then.i.i73:                                    ; preds = %land.lhs.true.i.i70
  %79 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i1.i74 = invoke i32 %79(ptr noundef nonnull %76)
          to label %_ZN13b3OpenCLArrayI9b3Vector3ED2Ev.exit77 unwind label %terminate.lpad.i75

terminate.lpad.i75:                               ; preds = %if.then.i.i73
  %80 = landingpad { ptr, i32 }
          catch ptr null
  %81 = extractvalue { ptr, i32 } %80, 0
  tail call void @__clang_call_terminate(ptr %81) #27
  unreachable

_ZN13b3OpenCLArrayI9b3Vector3ED2Ev.exit77:        ; preds = %_ZN13b3OpenCLArrayIiED2Ev.exit67, %land.lhs.true.i.i70, %if.then.i.i73
  %m_size.i76 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 29, i32 1
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size.i76, i8 0, i64 24, i1 false)
  %m_hasSeparatingNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 28
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayIiE, i64 0, inrange i32 0, i64 2), ptr %m_hasSeparatingNormals, align 8
  %m_clBuffer.i.i78 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 28, i32 3
  %82 = load ptr, ptr %m_clBuffer.i.i78, align 8
  %tobool.not.i.i79 = icmp eq ptr %82, null
  br i1 %tobool.not.i.i79, label %_ZN13b3OpenCLArrayIiED2Ev.exit87, label %land.lhs.true.i.i80

land.lhs.true.i.i80:                              ; preds = %_ZN13b3OpenCLArrayI9b3Vector3ED2Ev.exit77
  %m_ownsMemory.i.i81 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 28, i32 6
  %83 = load i8, ptr %m_ownsMemory.i.i81, align 8
  %84 = and i8 %83, 1
  %tobool2.not.i.i82 = icmp eq i8 %84, 0
  br i1 %tobool2.not.i.i82, label %_ZN13b3OpenCLArrayIiED2Ev.exit87, label %if.then.i.i83

if.then.i.i83:                                    ; preds = %land.lhs.true.i.i80
  %85 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i1.i84 = invoke i32 %85(ptr noundef nonnull %82)
          to label %_ZN13b3OpenCLArrayIiED2Ev.exit87 unwind label %terminate.lpad.i85

terminate.lpad.i85:                               ; preds = %if.then.i.i83
  %86 = landingpad { ptr, i32 }
          catch ptr null
  %87 = extractvalue { ptr, i32 } %86, 0
  tail call void @__clang_call_terminate(ptr %87) #27
  unreachable

_ZN13b3OpenCLArrayIiED2Ev.exit87:                 ; preds = %_ZN13b3OpenCLArrayI9b3Vector3ED2Ev.exit77, %land.lhs.true.i.i80, %if.then.i.i83
  %m_size.i86 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 28, i32 1
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size.i86, i8 0, i64 24, i1 false)
  %m_dmins = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 27
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayIfE, i64 0, inrange i32 0, i64 2), ptr %m_dmins, align 8
  %m_clBuffer.i.i88 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 27, i32 3
  %88 = load ptr, ptr %m_clBuffer.i.i88, align 8
  %tobool.not.i.i89 = icmp eq ptr %88, null
  br i1 %tobool.not.i.i89, label %_ZN13b3OpenCLArrayIfED2Ev.exit, label %land.lhs.true.i.i90

land.lhs.true.i.i90:                              ; preds = %_ZN13b3OpenCLArrayIiED2Ev.exit87
  %m_ownsMemory.i.i91 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 27, i32 6
  %89 = load i8, ptr %m_ownsMemory.i.i91, align 8
  %90 = and i8 %89, 1
  %tobool2.not.i.i92 = icmp eq i8 %90, 0
  br i1 %tobool2.not.i.i92, label %_ZN13b3OpenCLArrayIfED2Ev.exit, label %if.then.i.i93

if.then.i.i93:                                    ; preds = %land.lhs.true.i.i90
  %91 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i1.i94 = invoke i32 %91(ptr noundef nonnull %88)
          to label %_ZN13b3OpenCLArrayIfED2Ev.exit unwind label %terminate.lpad.i95

terminate.lpad.i95:                               ; preds = %if.then.i.i93
  %92 = landingpad { ptr, i32 }
          catch ptr null
  %93 = extractvalue { ptr, i32 } %92, 0
  tail call void @__clang_call_terminate(ptr %93) #27
  unreachable

_ZN13b3OpenCLArrayIfED2Ev.exit:                   ; preds = %_ZN13b3OpenCLArrayIiED2Ev.exit87, %land.lhs.true.i.i90, %if.then.i.i93
  %m_size.i96 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 27, i32 1
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size.i96, i8 0, i64 24, i1 false)
  %m_sepNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 26
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayI9b3Vector3E, i64 0, inrange i32 0, i64 2), ptr %m_sepNormals, align 8
  %m_clBuffer.i.i97 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 26, i32 3
  %94 = load ptr, ptr %m_clBuffer.i.i97, align 8
  %tobool.not.i.i98 = icmp eq ptr %94, null
  br i1 %tobool.not.i.i98, label %_ZN13b3OpenCLArrayI9b3Vector3ED2Ev.exit106, label %land.lhs.true.i.i99

land.lhs.true.i.i99:                              ; preds = %_ZN13b3OpenCLArrayIfED2Ev.exit
  %m_ownsMemory.i.i100 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 26, i32 6
  %95 = load i8, ptr %m_ownsMemory.i.i100, align 8
  %96 = and i8 %95, 1
  %tobool2.not.i.i101 = icmp eq i8 %96, 0
  br i1 %tobool2.not.i.i101, label %_ZN13b3OpenCLArrayI9b3Vector3ED2Ev.exit106, label %if.then.i.i102

if.then.i.i102:                                   ; preds = %land.lhs.true.i.i99
  %97 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i1.i103 = invoke i32 %97(ptr noundef nonnull %94)
          to label %_ZN13b3OpenCLArrayI9b3Vector3ED2Ev.exit106 unwind label %terminate.lpad.i104

terminate.lpad.i104:                              ; preds = %if.then.i.i102
  %98 = landingpad { ptr, i32 }
          catch ptr null
  %99 = extractvalue { ptr, i32 } %98, 0
  tail call void @__clang_call_terminate(ptr %99) #27
  unreachable

_ZN13b3OpenCLArrayI9b3Vector3ED2Ev.exit106:       ; preds = %_ZN13b3OpenCLArrayIfED2Ev.exit, %land.lhs.true.i.i99, %if.then.i.i102
  %m_size.i105 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 26, i32 1
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size.i105, i8 0, i64 24, i1 false)
  %m_totalContactsOut = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 25
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayIiE, i64 0, inrange i32 0, i64 2), ptr %m_totalContactsOut, align 8
  %m_clBuffer.i.i107 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 25, i32 3
  %100 = load ptr, ptr %m_clBuffer.i.i107, align 8
  %tobool.not.i.i108 = icmp eq ptr %100, null
  br i1 %tobool.not.i.i108, label %_ZN13b3OpenCLArrayIiED2Ev.exit116, label %land.lhs.true.i.i109

land.lhs.true.i.i109:                             ; preds = %_ZN13b3OpenCLArrayI9b3Vector3ED2Ev.exit106
  %m_ownsMemory.i.i110 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 25, i32 6
  %101 = load i8, ptr %m_ownsMemory.i.i110, align 8
  %102 = and i8 %101, 1
  %tobool2.not.i.i111 = icmp eq i8 %102, 0
  br i1 %tobool2.not.i.i111, label %_ZN13b3OpenCLArrayIiED2Ev.exit116, label %if.then.i.i112

if.then.i.i112:                                   ; preds = %land.lhs.true.i.i109
  %103 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i1.i113 = invoke i32 %103(ptr noundef nonnull %100)
          to label %_ZN13b3OpenCLArrayIiED2Ev.exit116 unwind label %terminate.lpad.i114

terminate.lpad.i114:                              ; preds = %if.then.i.i112
  %104 = landingpad { ptr, i32 }
          catch ptr null
  %105 = extractvalue { ptr, i32 } %104, 0
  tail call void @__clang_call_terminate(ptr %105) #27
  unreachable

_ZN13b3OpenCLArrayIiED2Ev.exit116:                ; preds = %_ZN13b3OpenCLArrayI9b3Vector3ED2Ev.exit106, %land.lhs.true.i.i109, %if.then.i.i112
  %m_size.i115 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 25, i32 1
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size.i115, i8 0, i64 24, i1 false)
  %m_unitSphereDirections = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 24
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayI9b3Vector3E, i64 0, inrange i32 0, i64 2), ptr %m_unitSphereDirections, align 8
  %m_clBuffer.i.i117 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 24, i32 3
  %106 = load ptr, ptr %m_clBuffer.i.i117, align 8
  %tobool.not.i.i118 = icmp eq ptr %106, null
  br i1 %tobool.not.i.i118, label %_ZN13b3OpenCLArrayI9b3Vector3ED2Ev.exit126, label %land.lhs.true.i.i119

land.lhs.true.i.i119:                             ; preds = %_ZN13b3OpenCLArrayIiED2Ev.exit116
  %m_ownsMemory.i.i120 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 24, i32 6
  %107 = load i8, ptr %m_ownsMemory.i.i120, align 8
  %108 = and i8 %107, 1
  %tobool2.not.i.i121 = icmp eq i8 %108, 0
  br i1 %tobool2.not.i.i121, label %_ZN13b3OpenCLArrayI9b3Vector3ED2Ev.exit126, label %if.then.i.i122

if.then.i.i122:                                   ; preds = %land.lhs.true.i.i119
  %109 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i1.i123 = invoke i32 %109(ptr noundef nonnull %106)
          to label %_ZN13b3OpenCLArrayI9b3Vector3ED2Ev.exit126 unwind label %terminate.lpad.i124

terminate.lpad.i124:                              ; preds = %if.then.i.i122
  %110 = landingpad { ptr, i32 }
          catch ptr null
  %111 = extractvalue { ptr, i32 } %110, 0
  tail call void @__clang_call_terminate(ptr %111) #27
  unreachable

_ZN13b3OpenCLArrayI9b3Vector3ED2Ev.exit126:       ; preds = %_ZN13b3OpenCLArrayIiED2Ev.exit116, %land.lhs.true.i.i119, %if.then.i.i122
  %m_size.i125 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 24, i32 1
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %m_size.i125, i8 0, i64 24, i1 false)
  ret void

terminate.lpad:                                   ; preds = %if.then112, %if.then106, %if.then100, %if.then94, %if.then88, %if.then82, %if.then76, %if.then70, %if.then64, %if.then58, %if.then52, %if.then46, %if.then40, %if.then34, %if.then28, %if.then22, %if.then16, %if.then10, %if.then4, %if.then
  %112 = landingpad { ptr, i32 }
          catch ptr null
  %113 = extractvalue { ptr, i32 } %112, 0
  tail call void @__clang_call_terminate(ptr %113) #27
  unreachable
}

; Function Attrs: noreturn nounwind uwtable
define linkonce_odr hidden void @__clang_call_terminate(ptr noundef %0) local_unnamed_addr #11 comdat {
  %2 = tail call ptr @__cxa_begin_catch(ptr %0) #26
  tail call void @_ZSt9terminatev() #27
  unreachable
}

declare ptr @__cxa_begin_catch(ptr) local_unnamed_addr

declare void @_ZSt9terminatev() local_unnamed_addr

; Function Attrs: mustprogress nounwind uwtable
define dso_local void @_ZN15GpuSatCollisionD0Ev(ptr noundef nonnull align 8 dereferenceable(864) %this) unnamed_addr #10 align 2 {
entry:
  tail call void @_ZN15GpuSatCollisionD2Ev(ptr noundef nonnull align 8 dereferenceable(864) %this) #26
  tail call void @_ZdlPv(ptr noundef nonnull %this) #28
  ret void
}

; Function Attrs: nobuiltin nounwind
declare void @_ZdlPv(ptr noundef) local_unnamed_addr #12

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite) uwtable
define dso_local noundef float @_Z30signedDistanceFromPointToPlaneRK9b3Vector3S1_PS_(ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %point, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %planeEqn, ptr nocapture noundef writeonly %closestPointOnFace) local_unnamed_addr #13 {
entry:
  %n.sroa.5.0.planeEqn.sroa_idx = getelementptr inbounds i8, ptr %planeEqn, i64 8
  %n.sroa.5.0.copyload = load float, ptr %n.sroa.5.0.planeEqn.sroa_idx, align 8
  %n.sroa.7.0.planeEqn.sroa_idx = getelementptr inbounds i8, ptr %planeEqn, i64 12
  %arrayidx7.i.i = getelementptr inbounds [4 x float], ptr %point, i64 0, i64 2
  %0 = load float, ptr %arrayidx7.i.i, align 8
  %1 = load float, ptr %n.sroa.7.0.planeEqn.sroa_idx, align 4
  %2 = load <2 x float>, ptr %planeEqn, align 16
  %3 = load <2 x float>, ptr %point, align 16
  %4 = fmul <2 x float> %2, %3
  %mul5.i.i = extractelement <2 x float> %4, i64 1
  %5 = extractelement <2 x float> %3, i64 0
  %6 = extractelement <2 x float> %2, i64 0
  %7 = tail call float @llvm.fmuladd.f32(float %6, float %5, float %mul5.i.i)
  %8 = tail call noundef float @llvm.fmuladd.f32(float %n.sroa.5.0.copyload, float %0, float %7)
  %add = fadd float %1, %8
  %9 = insertelement <2 x float> poison, float %add, i64 0
  %10 = shufflevector <2 x float> %9, <2 x float> poison, <2 x i32> zeroinitializer
  %11 = fmul <2 x float> %2, %10
  %mul4.i.i = fmul float %n.sroa.5.0.copyload, %add
  %12 = fsub <2 x float> %3, %11
  %sub7.i = fsub float %0, %mul4.i.i
  %retval.sroa.3.12.vec.insert.i.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %sub7.i, i64 0
  store <2 x float> %12, ptr %closestPointOnFace, align 16
  %ref.tmp.sroa.2.0..sroa_idx = getelementptr inbounds i8, ptr %closestPointOnFace, i64 8
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i, ptr %ref.tmp.sroa.2.0..sroa_idx, align 8
  ret float %add
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local { <2 x float>, <2 x float> } @_Z9transformPK9b3Vector3S1_PK12b3Quaternion(ptr nocapture noundef readonly %v, ptr nocapture noundef readonly %pos, ptr nocapture noundef readonly %orn) local_unnamed_addr #14 {
entry:
  %tr.sroa.27.48.copyload = load float, ptr %pos, align 16
  %tr.sroa.29.48.pos.sroa_idx = getelementptr inbounds i8, ptr %pos, i64 4
  %tr.sroa.29.48.copyload = load float, ptr %tr.sroa.29.48.pos.sroa_idx, align 4
  %tr.sroa.30.48.pos.sroa_idx = getelementptr inbounds i8, ptr %pos, i64 8
  %tr.sroa.30.48.copyload = load float, ptr %tr.sroa.30.48.pos.sroa_idx, align 8
  %arrayidx5.i.i.i.i = getelementptr inbounds [4 x float], ptr %orn, i64 0, i64 2
  %0 = load float, ptr %arrayidx5.i.i.i.i, align 8
  %arrayidx7.i.i.i.i = getelementptr inbounds [4 x float], ptr %orn, i64 0, i64 3
  %1 = load float, ptr %arrayidx7.i.i.i.i, align 4
  %2 = load <2 x float>, ptr %orn, align 16
  %3 = extractelement <2 x float> %2, i64 1
  %mul4.i.i.i.i = fmul float %3, %3
  %4 = extractelement <2 x float> %2, i64 0
  %5 = tail call float @llvm.fmuladd.f32(float %4, float %4, float %mul4.i.i.i.i)
  %6 = tail call float @llvm.fmuladd.f32(float %0, float %0, float %5)
  %7 = tail call noundef float @llvm.fmuladd.f32(float %1, float %1, float %6)
  %div.i.i = fdiv float 2.000000e+00, %7
  %8 = insertelement <2 x float> poison, float %div.i.i, i64 0
  %9 = shufflevector <2 x float> %8, <2 x float> poison, <2 x i32> zeroinitializer
  %10 = fmul <2 x float> %2, %9
  %mul6.i.i = fmul float %0, %div.i.i
  %11 = extractelement <2 x float> %10, i64 0
  %mul8.i.i = fmul float %1, %11
  %12 = extractelement <2 x float> %10, i64 1
  %mul10.i.i = fmul float %1, %12
  %mul12.i.i = fmul float %1, %mul6.i.i
  %mul16.i.i = fmul float %4, %12
  %mul18.i.i = fmul float %4, %mul6.i.i
  %13 = fmul <2 x float> %2, %10
  %mul22.i.i = fmul float %3, %mul6.i.i
  %mul24.i.i = fmul float %0, %mul6.i.i
  %14 = extractelement <2 x float> %13, i64 1
  %add.i.i = fadd float %14, %mul24.i.i
  %sub.i.i = fsub float 1.000000e+00, %add.i.i
  %sub26.i.i = fsub float %mul16.i.i, %mul12.i.i
  %add28.i.i = fadd float %mul18.i.i, %mul10.i.i
  %add30.i.i = fadd float %mul16.i.i, %mul12.i.i
  %15 = extractelement <2 x float> %13, i64 0
  %add32.i.i = fadd float %15, %mul24.i.i
  %sub33.i.i = fsub float 1.000000e+00, %add32.i.i
  %sub35.i.i = fsub float %mul22.i.i, %mul8.i.i
  %sub37.i.i = fsub float %mul18.i.i, %mul10.i.i
  %add39.i.i = fadd float %mul22.i.i, %mul8.i.i
  %add41.i.i = fadd float %15, %14
  %sub42.i.i = fsub float 1.000000e+00, %add41.i.i
  %16 = load float, ptr %v, align 16
  %arrayidx3.i.i.i6 = getelementptr inbounds [4 x float], ptr %v, i64 0, i64 1
  %17 = load float, ptr %arrayidx3.i.i.i6, align 4
  %mul5.i.i.i = fmul float %17, %sub26.i.i
  %18 = tail call float @llvm.fmuladd.f32(float %16, float %sub.i.i, float %mul5.i.i.i)
  %arrayidx6.i.i.i = getelementptr inbounds [4 x float], ptr %v, i64 0, i64 2
  %19 = load float, ptr %arrayidx6.i.i.i, align 8
  %20 = tail call noundef float @llvm.fmuladd.f32(float %19, float %add28.i.i, float %18)
  %mul5.i3.i.i = fmul float %17, %sub33.i.i
  %21 = tail call float @llvm.fmuladd.f32(float %16, float %add30.i.i, float %mul5.i3.i.i)
  %22 = tail call noundef float @llvm.fmuladd.f32(float %19, float %sub35.i.i, float %21)
  %mul5.i8.i.i = fmul float %17, %add39.i.i
  %23 = tail call float @llvm.fmuladd.f32(float %16, float %sub37.i.i, float %mul5.i8.i.i)
  %24 = tail call noundef float @llvm.fmuladd.f32(float %19, float %sub42.i.i, float %23)
  %add.i.i8 = fadd float %tr.sroa.27.48.copyload, %20
  %add4.i.i = fadd float %tr.sroa.29.48.copyload, %22
  %add7.i.i = fadd float %tr.sroa.30.48.copyload, %24
  %retval.sroa.0.0.vec.insert.i.i2.i = insertelement <2 x float> poison, float %add.i.i8, i64 0
  %retval.sroa.0.4.vec.insert.i.i3.i = insertelement <2 x float> %retval.sroa.0.0.vec.insert.i.i2.i, float %add4.i.i, i64 1
  %retval.sroa.3.12.vec.insert.i.i4.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %add7.i.i, i64 0
  %.fca.0.insert.i.i5.i = insertvalue { <2 x float>, <2 x float> } poison, <2 x float> %retval.sroa.0.4.vec.insert.i.i3.i, 0
  %.fca.1.insert.i.i6.i = insertvalue { <2 x float>, <2 x float> } %.fca.0.insert.i.i5.i, <2 x float> %retval.sroa.3.12.vec.insert.i.i4.i, 1
  ret { <2 x float>, <2 x float> } %.fca.1.insert.i.i6.i
}

; Function Attrs: mustprogress nofree nosync nounwind memory(argmem: readwrite) uwtable
define dso_local noundef i32 @_Z31extractManifoldSequentialGlobalPK9b3Vector3iRS0_P6b3Int4(ptr nocapture noundef readonly %p, i32 noundef %nPoints, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %nearNormal, ptr nocapture noundef %contactIdx) local_unnamed_addr #2 {
entry:
  %cmp = icmp eq i32 %nPoints, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp slt i32 %nPoints, 5
  br i1 %cmp1, label %return, label %for.body.preheader

for.body.preheader:                               ; preds = %if.end
  %spec.store.select = tail call i32 @llvm.smin.i32(i32 %nPoints, i32 64)
  %wide.trip.count = zext nneg i32 %spec.store.select to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %center.sroa.13.0200 = phi <2 x float> [ zeroinitializer, %for.body.preheader ], [ %center.sroa.13.8.vec.insert, %for.body ]
  %center.sroa.0.0199 = phi <2 x float> [ zeroinitializer, %for.body.preheader ], [ %1, %for.body ]
  %arrayidx = getelementptr inbounds %class.b3Vector3, ptr %p, i64 %indvars.iv
  %0 = load <2 x float>, ptr %arrayidx, align 16
  %1 = fadd <2 x float> %center.sroa.0.0199, %0
  %arrayidx6.i = getelementptr inbounds [4 x float], ptr %arrayidx, i64 0, i64 2
  %2 = load float, ptr %arrayidx6.i, align 8
  %center.sroa.13.8.vec.extract = extractelement <2 x float> %center.sroa.13.0200, i64 0
  %add8.i = fadd float %center.sroa.13.8.vec.extract, %2
  %center.sroa.13.8.vec.insert = insertelement <2 x float> %center.sroa.13.0200, float %add8.i, i64 0
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.body25.lr.ph, label %for.body, !llvm.loop !26

for.body25.lr.ph:                                 ; preds = %for.body
  %conv = sitofp i32 %spec.store.select to float
  %div.i = fdiv float 1.000000e+00, %conv
  %3 = extractelement <2 x float> %1, i64 0
  %mul.i.i = fmul float %div.i, %3
  %4 = extractelement <2 x float> %1, i64 1
  %mul3.i.i = fmul float %div.i, %4
  %mul5.i.i = fmul float %div.i, %add8.i
  %5 = load float, ptr %p, align 16
  %sub.i = fsub float %5, %mul.i.i
  %arrayidx2.i = getelementptr inbounds [4 x float], ptr %p, i64 0, i64 1
  %6 = load float, ptr %arrayidx2.i, align 4
  %sub4.i = fsub float %6, %mul3.i.i
  %arrayidx5.i = getelementptr inbounds [4 x float], ptr %p, i64 0, i64 2
  %7 = load float, ptr %arrayidx5.i, align 8
  %sub7.i = fsub float %7, %mul5.i.i
  %arrayidx.i = getelementptr inbounds [4 x float], ptr %nearNormal, i64 0, i64 1
  %8 = load float, ptr %arrayidx.i, align 4
  %arrayidx3.i45 = getelementptr inbounds [4 x float], ptr %nearNormal, i64 0, i64 2
  %9 = load float, ptr %arrayidx3.i45, align 8
  %10 = fneg float %9
  %neg.i = fmul float %sub4.i, %10
  %11 = tail call float @llvm.fmuladd.f32(float %8, float %sub7.i, float %neg.i)
  %12 = load float, ptr %nearNormal, align 16
  %13 = fneg float %12
  %neg11.i = fmul float %sub7.i, %13
  %14 = tail call float @llvm.fmuladd.f32(float %9, float %sub.i, float %neg11.i)
  %15 = fneg float %8
  %neg17.i = fmul float %sub.i, %15
  %16 = tail call float @llvm.fmuladd.f32(float %12, float %sub4.i, float %neg17.i)
  %neg.i56 = fmul float %14, %10
  %17 = tail call float @llvm.fmuladd.f32(float %8, float %16, float %neg.i56)
  %neg11.i57 = fmul float %16, %13
  %18 = tail call float @llvm.fmuladd.f32(float %9, float %11, float %neg11.i57)
  %neg17.i58 = fmul float %11, %15
  %19 = tail call float @llvm.fmuladd.f32(float %12, float %14, float %neg17.i58)
  %mul5.i.i.i.i = fmul float %14, %14
  %20 = tail call float @llvm.fmuladd.f32(float %11, float %11, float %mul5.i.i.i.i)
  %21 = tail call noundef float @llvm.fmuladd.f32(float %16, float %16, float %20)
  %sqrt.i.i = tail call noundef float @llvm.sqrt.f32(float %21)
  %div.i.i = fdiv float 1.000000e+00, %sqrt.i.i
  %mul.i.i.i = fmul float %11, %div.i.i
  %mul3.i.i.i = fmul float %14, %div.i.i
  %mul5.i.i.i = fmul float %16, %div.i.i
  %mul5.i.i.i.i65 = fmul float %18, %18
  %22 = tail call float @llvm.fmuladd.f32(float %17, float %17, float %mul5.i.i.i.i65)
  %23 = tail call noundef float @llvm.fmuladd.f32(float %19, float %19, float %22)
  %sqrt.i.i67 = tail call noundef float @llvm.sqrt.f32(float %23)
  %div.i.i68 = fdiv float 1.000000e+00, %sqrt.i.i67
  %mul.i.i.i69 = fmul float %17, %div.i.i68
  %mul3.i.i.i70 = fmul float %18, %div.i.i68
  %mul5.i.i.i71 = fmul float %19, %div.i.i68
  %fneg.i = fneg float %mul.i.i.i
  %fneg2.i = fneg float %mul3.i.i.i
  %fneg4.i = fneg float %mul5.i.i.i
  %y58 = getelementptr inbounds %struct.anon, ptr %contactIdx, i64 0, i32 1
  %z66 = getelementptr inbounds %struct.anon, ptr %contactIdx, i64 0, i32 2
  %fneg.i102 = fneg float %mul.i.i.i69
  %fneg2.i104 = fneg float %mul3.i.i.i70
  %fneg4.i106 = fneg float %mul5.i.i.i71
  %w78 = getelementptr inbounds %struct.anon, ptr %contactIdx, i64 0, i32 3
  %smax = tail call i32 @llvm.smax.i32(i32 %spec.store.select, i32 1)
  %wide.trip.count216 = zext nneg i32 %smax to i64
  br label %for.body25

for.body25:                                       ; preds = %for.body25.lr.ph, %for.inc80
  %indvars.iv213 = phi i64 [ 0, %for.body25.lr.ph ], [ %indvars.iv.next214, %for.inc80 ]
  %maxDots.sroa.0.0209 = phi float [ 0x3810000000000000, %for.body25.lr.ph ], [ %maxDots.sroa.0.1, %for.inc80 ]
  %maxDots.sroa.3.0208 = phi float [ 0x3810000000000000, %for.body25.lr.ph ], [ %maxDots.sroa.3.1, %for.inc80 ]
  %maxDots.sroa.6.0207 = phi float [ 0x3810000000000000, %for.body25.lr.ph ], [ %maxDots.sroa.6.1, %for.inc80 ]
  %maxDots.sroa.9.0206 = phi float [ 0x3810000000000000, %for.body25.lr.ph ], [ %maxDots.sroa.9.1, %for.inc80 ]
  %minIndex.0205 = phi i32 [ -1, %for.body25.lr.ph ], [ %minIndex.1, %for.inc80 ]
  %minW.0204 = phi float [ 0x47EFFFFFE0000000, %for.body25.lr.ph ], [ %minW.1, %for.inc80 ]
  %arrayidx27 = getelementptr inbounds %class.b3Vector3, ptr %p, i64 %indvars.iv213
  %w28 = getelementptr inbounds %struct.anon.2, ptr %arrayidx27, i64 0, i32 3
  %24 = load float, ptr %w28, align 4
  %cmp29 = fcmp olt float %24, %minW.0204
  %minW.1 = select i1 %cmp29, float %24, float %minW.0204
  %25 = trunc i64 %indvars.iv213 to i32
  %minIndex.1 = select i1 %cmp29, i32 %25, i32 %minIndex.0205
  %26 = load float, ptr %arrayidx27, align 16
  %sub.i72 = fsub float %26, %mul.i.i
  %arrayidx2.i73 = getelementptr inbounds [4 x float], ptr %arrayidx27, i64 0, i64 1
  %27 = load float, ptr %arrayidx2.i73, align 4
  %sub4.i75 = fsub float %27, %mul3.i.i
  %arrayidx5.i76 = getelementptr inbounds [4 x float], ptr %arrayidx27, i64 0, i64 2
  %28 = load float, ptr %arrayidx5.i76, align 8
  %sub7.i78 = fsub float %28, %mul5.i.i
  %mul5.i.i85 = fmul float %mul3.i.i.i, %sub4.i75
  %29 = tail call float @llvm.fmuladd.f32(float %mul.i.i.i, float %sub.i72, float %mul5.i.i85)
  %30 = tail call noundef float @llvm.fmuladd.f32(float %mul5.i.i.i, float %sub7.i78, float %29)
  %cmp42 = fcmp olt float %30, %maxDots.sroa.0.0209
  br i1 %cmp42, label %if.then43, label %if.end47

if.then43:                                        ; preds = %for.body25
  store i32 %25, ptr %contactIdx, align 16
  br label %if.end47

if.end47:                                         ; preds = %if.then43, %for.body25
  %maxDots.sroa.0.1 = phi float [ %30, %if.then43 ], [ %maxDots.sroa.0.0209, %for.body25 ]
  %mul5.i.i94 = fmul float %sub4.i75, %fneg2.i
  %31 = tail call float @llvm.fmuladd.f32(float %fneg.i, float %sub.i72, float %mul5.i.i94)
  %32 = tail call noundef float @llvm.fmuladd.f32(float %fneg4.i, float %sub7.i78, float %31)
  %cmp54 = fcmp olt float %32, %maxDots.sroa.3.0208
  br i1 %cmp54, label %if.then55, label %if.end59

if.then55:                                        ; preds = %if.end47
  store i32 %25, ptr %y58, align 4
  br label %if.end59

if.end59:                                         ; preds = %if.then55, %if.end47
  %maxDots.sroa.3.1 = phi float [ %32, %if.then55 ], [ %maxDots.sroa.3.0208, %if.end47 ]
  %mul5.i.i99 = fmul float %mul3.i.i.i70, %sub4.i75
  %33 = tail call float @llvm.fmuladd.f32(float %mul.i.i.i69, float %sub.i72, float %mul5.i.i99)
  %34 = tail call noundef float @llvm.fmuladd.f32(float %mul5.i.i.i71, float %sub7.i78, float %33)
  %cmp62 = fcmp olt float %34, %maxDots.sroa.6.0207
  br i1 %cmp62, label %if.then63, label %if.end67

if.then63:                                        ; preds = %if.end59
  store i32 %25, ptr %z66, align 8
  br label %if.end67

if.end67:                                         ; preds = %if.then63, %if.end59
  %maxDots.sroa.6.1 = phi float [ %34, %if.then63 ], [ %maxDots.sroa.6.0207, %if.end59 ]
  %mul5.i.i114 = fmul float %sub4.i75, %fneg2.i104
  %35 = tail call float @llvm.fmuladd.f32(float %fneg.i102, float %sub.i72, float %mul5.i.i114)
  %36 = tail call noundef float @llvm.fmuladd.f32(float %fneg4.i106, float %sub7.i78, float %35)
  %cmp74 = fcmp olt float %36, %maxDots.sroa.9.0206
  br i1 %cmp74, label %if.then75, label %for.inc80

if.then75:                                        ; preds = %if.end67
  store i32 %25, ptr %w78, align 4
  br label %for.inc80

for.inc80:                                        ; preds = %if.end67, %if.then75
  %maxDots.sroa.9.1 = phi float [ %36, %if.then75 ], [ %maxDots.sroa.9.0206, %if.end67 ]
  %indvars.iv.next214 = add nuw nsw i64 %indvars.iv213, 1
  %exitcond217.not = icmp eq i64 %indvars.iv.next214, %wide.trip.count216
  br i1 %exitcond217.not, label %for.end82, label %for.body25, !llvm.loop !27

for.end82:                                        ; preds = %for.inc80
  %37 = load i32, ptr %contactIdx, align 16
  %cmp85.not = icmp eq i32 %37, %minIndex.1
  br i1 %cmp85.not, label %return, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.end82
  %y87 = getelementptr inbounds %struct.anon, ptr %contactIdx, i64 0, i32 1
  %38 = load i32, ptr %y87, align 4
  %cmp88.not = icmp eq i32 %38, %minIndex.1
  br i1 %cmp88.not, label %return, label %land.lhs.true89

land.lhs.true89:                                  ; preds = %land.lhs.true
  %z91 = getelementptr inbounds %struct.anon, ptr %contactIdx, i64 0, i32 2
  %39 = load i32, ptr %z91, align 8
  %cmp92.not = icmp eq i32 %39, %minIndex.1
  br i1 %cmp92.not, label %return, label %land.lhs.true93

land.lhs.true93:                                  ; preds = %land.lhs.true89
  %w95 = getelementptr inbounds %struct.anon, ptr %contactIdx, i64 0, i32 3
  %40 = load i32, ptr %w95, align 4
  %cmp96.not = icmp eq i32 %40, %minIndex.1
  br i1 %cmp96.not, label %return, label %if.then97

if.then97:                                        ; preds = %land.lhs.true93
  store i32 %minIndex.1, ptr %contactIdx, align 16
  br label %return

return:                                           ; preds = %for.end82, %land.lhs.true, %land.lhs.true89, %land.lhs.true93, %if.then97, %if.end, %entry
  %retval.0 = phi i32 [ 0, %entry ], [ %nPoints, %if.end ], [ 4, %if.then97 ], [ 4, %land.lhs.true93 ], [ 4, %land.lhs.true89 ], [ 4, %land.lhs.true ], [ 4, %for.end82 ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree nosync nounwind memory(read, argmem: readwrite, inaccessiblemem: none) uwtable
define dso_local noundef zeroext i1 @_Z26findSeparatingAxisEdgeEdgePK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_RK20b3AlignedObjectArrayIS2_ESB_RKS8_I9b3GpuFaceERKS8_IiEPS2_Pf(ptr nocapture noundef readonly %hullA, ptr nocapture noundef readonly %hullB, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %posA1, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %ornA, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %posB1, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %ornB, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %DeltaC2, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %vertices, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %uniqueEdges, ptr nocapture nonnull readnone align 8 %faces, ptr nocapture nonnull readnone align 1 %indices, ptr nocapture noundef %sep, ptr nocapture noundef %dmin) local_unnamed_addr #15 {
entry:
  %posA.sroa.0.0.copyload = load float, ptr %posA1, align 16
  %posA.sroa.2.0.posA1.sroa_idx = getelementptr inbounds i8, ptr %posA1, i64 4
  %posA.sroa.2.0.copyload = load float, ptr %posA.sroa.2.0.posA1.sroa_idx, align 4
  %posA.sroa.3.0.posA1.sroa_idx = getelementptr inbounds i8, ptr %posA1, i64 8
  %posA.sroa.3.0.copyload = load float, ptr %posA.sroa.3.0.posA1.sroa_idx, align 8
  %posB.sroa.0.0.copyload = load float, ptr %posB1, align 16
  %posB.sroa.2.0.posB1.sroa_idx = getelementptr inbounds i8, ptr %posB1, i64 4
  %posB.sroa.2.0.copyload = load float, ptr %posB.sroa.2.0.posB1.sroa_idx, align 4
  %posB.sroa.3.0.posB1.sroa_idx = getelementptr inbounds i8, ptr %posB1, i64 8
  %posB.sroa.3.0.copyload = load float, ptr %posB.sroa.3.0.posB1.sroa_idx, align 8
  %m_numUniqueEdges = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 10
  %0 = load i32, ptr %m_numUniqueEdges, align 8
  %cmp181 = icmp sgt i32 %0, 0
  br i1 %cmp181, label %for.body.lr.ph, label %for.end36

for.body.lr.ph:                                   ; preds = %entry
  %m_uniqueEdgesOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 9
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray, ptr %uniqueEdges, i64 0, i32 5
  %arrayidx.i.i.i = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 3
  %arrayidx.i23.i.i = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 1
  %arrayidx.i25.i.i = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 2
  %m_numUniqueEdges5 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullB, i64 0, i32 10
  %m_uniqueEdgesOffset8 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullB, i64 0, i32 9
  %arrayidx.i.i.i24 = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 3
  %arrayidx.i25.i.i28 = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 2
  %arrayidx3.i.i = getelementptr inbounds [4 x float], ptr %DeltaC2, i64 0, i64 1
  %arrayidx6.i.i = getelementptr inbounds [4 x float], ptr %DeltaC2, i64 0, i64 2
  %m_numVertices.i = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 7
  %m_vertexOffset.i = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 8
  %m_data.i.i = getelementptr inbounds %class.b3AlignedObjectArray, ptr %vertices, i64 0, i32 5
  %m_numVertices.i51 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullB, i64 0, i32 7
  %m_vertexOffset.i78 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullB, i64 0, i32 8
  %crossje.sroa.18.0.sep.sroa_idx = getelementptr inbounds i8, ptr %sep, i64 8
  %.pre = load i32, ptr %m_numUniqueEdges5, align 8
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc34
  %1 = phi i32 [ %0, %for.body.lr.ph ], [ %198, %for.inc34 ]
  %2 = phi i32 [ %.pre, %for.body.lr.ph ], [ %199, %for.inc34 ]
  %3 = phi i32 [ %.pre, %for.body.lr.ph ], [ %200, %for.inc34 ]
  %e0.0182 = phi i32 [ 0, %for.body.lr.ph ], [ %inc35, %for.inc34 ]
  %4 = load i32, ptr %m_uniqueEdgesOffset, align 4
  %add = add nsw i32 %4, %e0.0182
  %5 = load ptr, ptr %m_data.i, align 8
  %idxprom.i = sext i32 %add to i64
  %arrayidx.i = getelementptr inbounds %class.b3Vector3, ptr %5, i64 %idxprom.i
  %edge0.sroa.0.0.copyload = load float, ptr %arrayidx.i, align 16
  %edge0.sroa.2.0.arrayidx.i.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i, i64 4
  %6 = load float, ptr %arrayidx.i.i.i, align 4
  %7 = load float, ptr %ornA, align 16
  %8 = load <2 x float>, ptr %edge0.sroa.2.0.arrayidx.i.sroa_idx, align 4
  %9 = shufflevector <2 x float> %8, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %10 = load <2 x float>, ptr %arrayidx.i23.i.i, align 4
  %11 = shufflevector <2 x float> %10, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %12 = insertelement <2 x float> %8, float %edge0.sroa.0.0.copyload, i64 0
  %13 = fmul <2 x float> %12, %11
  %14 = insertelement <2 x float> poison, float %6, i64 0
  %15 = shufflevector <2 x float> %14, <2 x float> poison, <2 x i32> zeroinitializer
  %16 = insertelement <2 x float> %8, float %edge0.sroa.0.0.copyload, i64 1
  %17 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %15, <2 x float> %16, <2 x float> %13)
  %18 = insertelement <2 x float> %10, float %7, i64 0
  %19 = fneg <2 x float> %18
  %20 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %19, <2 x float> %9, <2 x float> %17)
  %21 = extractelement <2 x float> %8, i64 0
  %mul21.i.i = fmul float %21, %7
  %22 = extractelement <2 x float> %8, i64 1
  %23 = tail call float @llvm.fmuladd.f32(float %6, float %22, float %mul21.i.i)
  %24 = extractelement <2 x float> %10, i64 0
  %neg24.i.i = fneg float %24
  %25 = tail call float @llvm.fmuladd.f32(float %neg24.i.i, float %edge0.sroa.0.0.copyload, float %23)
  %neg31.i.i = fmul float %21, %neg24.i.i
  %26 = extractelement <2 x float> %19, i64 0
  %27 = tail call float @llvm.fmuladd.f32(float %26, float %edge0.sroa.0.0.copyload, float %neg31.i.i)
  %28 = extractelement <2 x float> %19, i64 1
  %29 = tail call float @llvm.fmuladd.f32(float %28, float %22, float %27)
  %30 = extractelement <2 x float> %20, i64 1
  %mul4.i9.i = fmul float %6, %30
  %31 = tail call float @llvm.fmuladd.f32(float %29, float %26, float %mul4.i9.i)
  %32 = extractelement <2 x float> %20, i64 0
  %33 = tail call float @llvm.fmuladd.f32(float %32, float %28, float %31)
  %34 = tail call float @llvm.fmuladd.f32(float %25, float %24, float %33)
  %35 = shufflevector <2 x float> %20, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %36 = insertelement <2 x float> %35, float %25, i64 0
  %37 = fmul <2 x float> %15, %36
  %38 = insertelement <2 x float> poison, float %29, i64 0
  %39 = shufflevector <2 x float> %38, <2 x float> poison, <2 x i32> zeroinitializer
  %40 = shufflevector <2 x float> %19, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %41 = insertelement <2 x float> %40, float %neg24.i.i, i64 1
  %42 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %39, <2 x float> %41, <2 x float> %37)
  %43 = shufflevector <2 x float> %20, <2 x float> %36, <2 x i32> <i32 1, i32 2>
  %44 = shufflevector <2 x float> %41, <2 x float> %19, <2 x i32> <i32 1, i32 2>
  %45 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %43, <2 x float> %44, <2 x float> %42)
  %46 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %20, <2 x float> %18, <2 x float> %45)
  %cmp6178 = icmp sgt i32 %3, 0
  br i1 %cmp6178, label %for.body7.lr.ph, label %for.inc34

for.body7.lr.ph:                                  ; preds = %for.body
  %47 = shufflevector <2 x float> %46, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %48 = insertelement <2 x float> %47, float %34, i64 0
  %49 = fneg <2 x float> %48
  %50 = extractelement <2 x float> %46, i64 1
  %51 = fneg float %50
  br label %for.body7

for.body7:                                        ; preds = %for.body7.lr.ph, %for.inc
  %52 = phi i32 [ %2, %for.body7.lr.ph ], [ %197, %for.inc ]
  %e1.0179 = phi i32 [ 0, %for.body7.lr.ph ], [ %inc33, %for.inc ]
  %53 = load i32, ptr %m_uniqueEdgesOffset8, align 4
  %add9 = add nsw i32 %53, %e1.0179
  %54 = load ptr, ptr %m_data.i, align 8
  %idxprom.i22 = sext i32 %add9 to i64
  %arrayidx.i23 = getelementptr inbounds %class.b3Vector3, ptr %54, i64 %idxprom.i22
  %edge1.sroa.0.0.copyload = load float, ptr %arrayidx.i23, align 16
  %edge1.sroa.2.0.arrayidx.i23.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i23, i64 4
  %55 = load float, ptr %arrayidx.i.i.i24, align 4
  %56 = load float, ptr %arrayidx.i25.i.i28, align 8
  %neg.i.i30 = fneg float %56
  %57 = load <2 x float>, ptr %edge1.sroa.2.0.arrayidx.i23.sroa_idx, align 4
  %58 = shufflevector <2 x float> %57, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %59 = load <2 x float>, ptr %ornB, align 16
  %60 = shufflevector <2 x float> %59, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %61 = extractelement <2 x float> %59, i64 1
  %62 = extractelement <2 x float> %57, i64 1
  %63 = fmul <2 x float> %58, %60
  %mul4.i.i27 = extractelement <2 x float> %63, i64 0
  %64 = tail call float @llvm.fmuladd.f32(float %55, float %edge1.sroa.0.0.copyload, float %mul4.i.i27)
  %65 = extractelement <2 x float> %57, i64 0
  %66 = tail call float @llvm.fmuladd.f32(float %neg.i.i30, float %65, float %64)
  %67 = insertelement <2 x float> %57, float %edge1.sroa.0.0.copyload, i64 1
  %68 = insertelement <2 x float> %59, float %56, i64 1
  %69 = fmul <2 x float> %67, %68
  %70 = insertelement <2 x float> poison, float %55, i64 0
  %71 = shufflevector <2 x float> %70, <2 x float> poison, <2 x i32> zeroinitializer
  %72 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %71, <2 x float> %58, <2 x float> %69)
  %73 = fneg <2 x float> %60
  %74 = insertelement <2 x float> %57, float %edge1.sroa.0.0.copyload, i64 0
  %75 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %73, <2 x float> %74, <2 x float> %72)
  %76 = extractelement <2 x float> %73, i64 0
  %neg31.i.i35 = fmul float %65, %76
  %77 = extractelement <2 x float> %73, i64 1
  %78 = tail call float @llvm.fmuladd.f32(float %77, float %edge1.sroa.0.0.copyload, float %neg31.i.i35)
  %79 = tail call float @llvm.fmuladd.f32(float %neg.i.i30, float %62, float %78)
  %80 = extractelement <2 x float> %75, i64 1
  %mul14.i.i37 = fmul float %55, %80
  %81 = tail call float @llvm.fmuladd.f32(float %79, float %76, float %mul14.i.i37)
  %82 = extractelement <2 x float> %75, i64 0
  %83 = tail call float @llvm.fmuladd.f32(float %82, float %77, float %81)
  %84 = tail call float @llvm.fmuladd.f32(float %66, float %56, float %83)
  %85 = shufflevector <2 x float> %75, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %86 = insertelement <2 x float> %85, float %66, i64 0
  %87 = fmul <2 x float> %71, %86
  %88 = insertelement <2 x float> poison, float %79, i64 0
  %89 = shufflevector <2 x float> %88, <2 x float> poison, <2 x i32> zeroinitializer
  %90 = shufflevector <2 x float> %73, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %91 = insertelement <2 x float> %90, float %neg.i.i30, i64 1
  %92 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %89, <2 x float> %91, <2 x float> %87)
  %93 = shufflevector <2 x float> %75, <2 x float> %86, <2 x i32> <i32 1, i32 2>
  %94 = shufflevector <2 x float> %91, <2 x float> %73, <2 x i32> <i32 1, i32 2>
  %95 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %93, <2 x float> %94, <2 x float> %92)
  %96 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %75, <2 x float> %60, <2 x float> %95)
  %97 = shufflevector <2 x float> %96, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %98 = insertelement <2 x float> %97, float %84, i64 1
  %99 = fmul <2 x float> %98, %49
  %100 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %46, <2 x float> %96, <2 x float> %99)
  %101 = extractelement <2 x float> %96, i64 0
  %neg17.i = fmul float %101, %51
  %102 = tail call float @llvm.fmuladd.f32(float %34, float %84, float %neg17.i)
  %103 = extractelement <2 x float> %100, i64 1
  %104 = tail call float @llvm.fabs.f32(float %103)
  %conv.i = fpext float %104 to double
  %cmp.i = fcmp ogt double %conv.i, 0x3EB0C6F7A0B5ED8D
  %105 = extractelement <2 x float> %100, i64 0
  %106 = tail call float @llvm.fabs.f32(float %105)
  %conv1.i = fpext float %106 to double
  %cmp2.i = fcmp ogt double %conv1.i, 0x3EB0C6F7A0B5ED8D
  %or.cond = select i1 %cmp.i, i1 true, i1 %cmp2.i
  br i1 %or.cond, label %if.then, label %lor.lhs.false3.i

lor.lhs.false3.i:                                 ; preds = %for.body7
  %107 = tail call float @llvm.fabs.f32(float %102)
  %conv4.i = fpext float %107 to double
  %cmp5.i = fcmp ogt double %conv4.i, 0x3EB0C6F7A0B5ED8D
  br i1 %cmp5.i, label %if.then, label %for.inc

if.then:                                          ; preds = %lor.lhs.false3.i, %for.body7
  %108 = fmul <2 x float> %100, %100
  %mul5.i.i.i.i = extractelement <2 x float> %108, i64 0
  %109 = tail call float @llvm.fmuladd.f32(float %103, float %103, float %mul5.i.i.i.i)
  %110 = tail call noundef float @llvm.fmuladd.f32(float %102, float %102, float %109)
  %sqrt.i.i = tail call noundef float @llvm.sqrt.f32(float %110)
  %div.i.i = fdiv float 1.000000e+00, %sqrt.i.i
  %111 = insertelement <2 x float> poison, float %div.i.i, i64 0
  %112 = shufflevector <2 x float> %111, <2 x float> poison, <2 x i32> zeroinitializer
  %113 = fmul <2 x float> %100, %112
  %114 = shufflevector <2 x float> %113, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %mul5.i.i.i = fmul float %102, %div.i.i
  %crossje.sroa.18.8.vec.insert = insertelement <2 x float> <float poison, float 0.000000e+00>, float %mul5.i.i.i, i64 0
  %115 = load float, ptr %DeltaC2, align 16
  %116 = load float, ptr %arrayidx3.i.i, align 4
  %117 = extractelement <2 x float> %113, i64 0
  %mul5.i.i = fmul float %117, %116
  %118 = extractelement <2 x float> %113, i64 1
  %119 = tail call float @llvm.fmuladd.f32(float %115, float %118, float %mul5.i.i)
  %120 = load float, ptr %arrayidx6.i.i, align 8
  %121 = tail call noundef float @llvm.fmuladd.f32(float %120, float %mul5.i.i.i, float %119)
  %cmp20 = fcmp olt float %121, 0.000000e+00
  br i1 %cmp20, label %if.then21, label %if.end

if.then21:                                        ; preds = %if.then
  %122 = shufflevector <2 x float> %113, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %123 = fneg <2 x float> %122
  %mul5.i = fneg float %mul5.i.i.i
  %crossje.sroa.18.8.vec.insert163 = insertelement <2 x float> %crossje.sroa.18.8.vec.insert, float %mul5.i, i64 0
  br label %if.end

if.end:                                           ; preds = %if.then21, %if.then
  %crossje.sroa.0.0 = phi <2 x float> [ %123, %if.then21 ], [ %114, %if.then ]
  %crossje.sroa.18.0 = phi <2 x float> [ %crossje.sroa.18.8.vec.insert163, %if.then21 ], [ %crossje.sroa.18.8.vec.insert, %if.then ]
  %124 = load i32, ptr %m_numVertices.i, align 4
  %125 = load float, ptr %ornA, align 16
  %fneg.i.i = fneg float %125
  %126 = load float, ptr %arrayidx.i23.i.i, align 4
  %fneg4.i.i = fneg float %126
  %127 = load float, ptr %arrayidx.i25.i.i, align 8
  %fneg7.i.i = fneg float %127
  %128 = load float, ptr %arrayidx.i.i.i, align 4
  %crossje.sroa.0.0.vec.extract139 = extractelement <2 x float> %crossje.sroa.0.0, i64 0
  %crossje.sroa.18.8.vec.extract165 = extractelement <2 x float> %crossje.sroa.18.0, i64 0
  %mul4.i.i.i = fmul float %crossje.sroa.18.8.vec.extract165, %fneg4.i.i
  %129 = tail call float @llvm.fmuladd.f32(float %128, float %crossje.sroa.0.0.vec.extract139, float %mul4.i.i.i)
  %crossje.sroa.0.4.vec.extract152 = extractelement <2 x float> %crossje.sroa.0.0, i64 1
  %130 = tail call float @llvm.fmuladd.f32(float %127, float %crossje.sroa.0.4.vec.extract152, float %129)
  %mul12.i.i.i = fmul float %crossje.sroa.0.0.vec.extract139, %fneg7.i.i
  %131 = tail call float @llvm.fmuladd.f32(float %128, float %crossje.sroa.0.4.vec.extract152, float %mul12.i.i.i)
  %132 = tail call float @llvm.fmuladd.f32(float %125, float %crossje.sroa.18.8.vec.extract165, float %131)
  %mul21.i.i.i = fmul float %crossje.sroa.0.4.vec.extract152, %fneg.i.i
  %133 = tail call float @llvm.fmuladd.f32(float %128, float %crossje.sroa.18.8.vec.extract165, float %mul21.i.i.i)
  %134 = tail call float @llvm.fmuladd.f32(float %126, float %crossje.sroa.0.0.vec.extract139, float %133)
  %neg31.i.i.i = fmul float %crossje.sroa.0.4.vec.extract152, %126
  %135 = tail call float @llvm.fmuladd.f32(float %125, float %crossje.sroa.0.0.vec.extract139, float %neg31.i.i.i)
  %136 = tail call float @llvm.fmuladd.f32(float %127, float %crossje.sroa.18.8.vec.extract165, float %135)
  %mul4.i9.i.i = fmul float %128, %130
  %137 = tail call float @llvm.fmuladd.f32(float %136, float %125, float %mul4.i9.i.i)
  %138 = tail call float @llvm.fmuladd.f32(float %132, float %127, float %137)
  %139 = tail call float @llvm.fmuladd.f32(float %134, float %fneg4.i.i, float %138)
  %mul14.i.i.i = fmul float %128, %132
  %140 = tail call float @llvm.fmuladd.f32(float %136, float %126, float %mul14.i.i.i)
  %141 = tail call float @llvm.fmuladd.f32(float %134, float %125, float %140)
  %142 = tail call float @llvm.fmuladd.f32(float %130, float %fneg7.i.i, float %141)
  %mul25.i.i.i = fmul float %128, %134
  %143 = tail call float @llvm.fmuladd.f32(float %136, float %127, float %mul25.i.i.i)
  %144 = tail call float @llvm.fmuladd.f32(float %130, float %126, float %143)
  %145 = tail call float @llvm.fmuladd.f32(float %132, float %fneg.i.i, float %144)
  %cmp27.i = icmp sgt i32 %124, 0
  br i1 %cmp27.i, label %for.body.lr.ph.i, label %_Z7projectRK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionS4_RK20b3AlignedObjectArrayIS2_ERfSC_.exit

for.body.lr.ph.i:                                 ; preds = %if.end
  %146 = load i32, ptr %m_vertexOffset.i, align 16
  %147 = load ptr, ptr %m_data.i.i, align 8
  %148 = sext i32 %146 to i64
  %149 = zext nneg i32 %124 to i64
  %invariant.gep = getelementptr %class.b3Vector3, ptr %147, i64 %148
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %for.body.lr.ph.i
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body.i ], [ 0, %for.body.lr.ph.i ]
  %Min0.0 = phi float [ %Min0.1, %for.body.i ], [ 0x47EFFFFFE0000000, %for.body.lr.ph.i ]
  %Max0.0 = phi float [ %Max0.1, %for.body.i ], [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i ]
  %150 = phi float [ %157, %for.body.i ], [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i ]
  %gep = getelementptr %class.b3Vector3, ptr %invariant.gep, i64 %indvars.iv
  %151 = load float, ptr %gep, align 16
  %arrayidx3.i.i22.i = getelementptr inbounds [4 x float], ptr %gep, i64 0, i64 1
  %152 = load float, ptr %arrayidx3.i.i22.i, align 4
  %mul5.i.i24.i = fmul float %142, %152
  %153 = tail call float @llvm.fmuladd.f32(float %151, float %139, float %mul5.i.i24.i)
  %arrayidx6.i.i25.i = getelementptr inbounds [4 x float], ptr %gep, i64 0, i64 2
  %154 = load float, ptr %arrayidx6.i.i25.i, align 8
  %155 = tail call noundef float @llvm.fmuladd.f32(float %154, float %145, float %153)
  %cmp9.i = fcmp olt float %155, %Min0.0
  %Min0.1 = select i1 %cmp9.i, float %155, float %Min0.0
  %156 = select i1 %cmp9.i, float %Max0.0, float %150
  %cmp10.i = fcmp ogt float %155, %156
  %Max0.1 = select i1 %cmp10.i, float %155, float %Max0.0
  %157 = select i1 %cmp10.i, float %155, float %156
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next, %149
  br i1 %exitcond.not.i, label %for.end.i, label %for.body.i, !llvm.loop !28

for.end.i:                                        ; preds = %for.body.i
  %cmp13.i = fcmp ogt float %Min0.1, %157
  br i1 %cmp13.i, label %if.then14.i, label %_Z7projectRK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionS4_RK20b3AlignedObjectArrayIS2_ERfSC_.exit

if.then14.i:                                      ; preds = %for.end.i
  br label %_Z7projectRK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionS4_RK20b3AlignedObjectArrayIS2_ERfSC_.exit

_Z7projectRK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionS4_RK20b3AlignedObjectArrayIS2_ERfSC_.exit: ; preds = %if.end, %for.end.i, %if.then14.i
  %Max0.3 = phi float [ %Max0.1, %for.end.i ], [ %Min0.1, %if.then14.i ], [ 0x47EFFFFFE0000000, %if.end ]
  %158 = phi float [ %Min0.1, %for.end.i ], [ %157, %if.then14.i ], [ 0xC7EFFFFFE0000000, %if.end ]
  %mul5.i.i.i49 = fmul float %posA.sroa.2.0.copyload, %crossje.sroa.0.4.vec.extract152
  %159 = tail call float @llvm.fmuladd.f32(float %posA.sroa.0.0.copyload, float %crossje.sroa.0.0.vec.extract139, float %mul5.i.i.i49)
  %160 = tail call noundef float @llvm.fmuladd.f32(float %posA.sroa.3.0.copyload, float %crossje.sroa.18.8.vec.extract165, float %159)
  %add16.i = fadd float %160, %158
  %add17.i = fadd float %160, %Max0.3
  %161 = load i32, ptr %m_numVertices.i51, align 4
  %162 = fmul <2 x float> %crossje.sroa.18.0, %73
  %mul4.i.i.i59 = extractelement <2 x float> %162, i64 0
  %163 = tail call float @llvm.fmuladd.f32(float %55, float %crossje.sroa.0.0.vec.extract139, float %mul4.i.i.i59)
  %164 = tail call float @llvm.fmuladd.f32(float %56, float %crossje.sroa.0.4.vec.extract152, float %163)
  %mul12.i.i.i61 = fmul float %crossje.sroa.0.0.vec.extract139, %neg.i.i30
  %165 = tail call float @llvm.fmuladd.f32(float %55, float %crossje.sroa.0.4.vec.extract152, float %mul12.i.i.i61)
  %166 = extractelement <2 x float> %59, i64 0
  %167 = tail call float @llvm.fmuladd.f32(float %166, float %crossje.sroa.18.8.vec.extract165, float %165)
  %mul21.i.i.i62 = fmul float %crossje.sroa.0.4.vec.extract152, %77
  %168 = tail call float @llvm.fmuladd.f32(float %55, float %crossje.sroa.18.8.vec.extract165, float %mul21.i.i.i62)
  %169 = tail call float @llvm.fmuladd.f32(float %61, float %crossje.sroa.0.0.vec.extract139, float %168)
  %neg31.i.i.i63 = fmul float %61, %crossje.sroa.0.4.vec.extract152
  %170 = tail call float @llvm.fmuladd.f32(float %166, float %crossje.sroa.0.0.vec.extract139, float %neg31.i.i.i63)
  %171 = tail call float @llvm.fmuladd.f32(float %56, float %crossje.sroa.18.8.vec.extract165, float %170)
  %mul4.i9.i.i64 = fmul float %55, %164
  %172 = tail call float @llvm.fmuladd.f32(float %171, float %166, float %mul4.i9.i.i64)
  %173 = tail call float @llvm.fmuladd.f32(float %167, float %56, float %172)
  %174 = tail call float @llvm.fmuladd.f32(float %169, float %76, float %173)
  %mul14.i.i.i65 = fmul float %55, %167
  %175 = tail call float @llvm.fmuladd.f32(float %171, float %61, float %mul14.i.i.i65)
  %176 = tail call float @llvm.fmuladd.f32(float %169, float %166, float %175)
  %177 = tail call float @llvm.fmuladd.f32(float %164, float %neg.i.i30, float %176)
  %mul25.i.i.i66 = fmul float %55, %169
  %178 = tail call float @llvm.fmuladd.f32(float %171, float %56, float %mul25.i.i.i66)
  %179 = tail call float @llvm.fmuladd.f32(float %164, float %61, float %178)
  %180 = tail call float @llvm.fmuladd.f32(float %167, float %77, float %179)
  %cmp27.i69 = icmp sgt i32 %161, 0
  br i1 %cmp27.i69, label %for.body.lr.ph.i77, label %_Z7projectRK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionS4_RK20b3AlignedObjectArrayIS2_ERfSC_.exit97

for.body.lr.ph.i77:                               ; preds = %_Z7projectRK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionS4_RK20b3AlignedObjectArrayIS2_ERfSC_.exit
  %181 = load i32, ptr %m_vertexOffset.i78, align 16
  %182 = load ptr, ptr %m_data.i.i, align 8
  %183 = sext i32 %181 to i64
  %184 = zext nneg i32 %161 to i64
  %invariant.gep195 = getelementptr %class.b3Vector3, ptr %182, i64 %183
  br label %for.body.i80

for.body.i80:                                     ; preds = %for.body.i80, %for.body.lr.ph.i77
  %indvars.iv187 = phi i64 [ %indvars.iv.next188, %for.body.i80 ], [ 0, %for.body.lr.ph.i77 ]
  %Min1.0 = phi float [ %Min1.1, %for.body.i80 ], [ 0x47EFFFFFE0000000, %for.body.lr.ph.i77 ]
  %Max1.0 = phi float [ %Max1.1, %for.body.i80 ], [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i77 ]
  %185 = phi float [ %192, %for.body.i80 ], [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i77 ]
  %gep196 = getelementptr %class.b3Vector3, ptr %invariant.gep195, i64 %indvars.iv187
  %186 = load float, ptr %gep196, align 16
  %arrayidx3.i.i22.i85 = getelementptr inbounds [4 x float], ptr %gep196, i64 0, i64 1
  %187 = load float, ptr %arrayidx3.i.i22.i85, align 4
  %mul5.i.i24.i86 = fmul float %177, %187
  %188 = tail call float @llvm.fmuladd.f32(float %186, float %174, float %mul5.i.i24.i86)
  %arrayidx6.i.i25.i87 = getelementptr inbounds [4 x float], ptr %gep196, i64 0, i64 2
  %189 = load float, ptr %arrayidx6.i.i25.i87, align 8
  %190 = tail call noundef float @llvm.fmuladd.f32(float %189, float %180, float %188)
  %cmp9.i88 = fcmp olt float %190, %Min1.0
  %Min1.1 = select i1 %cmp9.i88, float %190, float %Min1.0
  %191 = select i1 %cmp9.i88, float %Max1.0, float %185
  %cmp10.i90 = fcmp ogt float %190, %191
  %Max1.1 = select i1 %cmp10.i90, float %190, float %Max1.0
  %192 = select i1 %cmp10.i90, float %190, float %191
  %indvars.iv.next188 = add nuw nsw i64 %indvars.iv187, 1
  %exitcond.not.i93 = icmp eq i64 %indvars.iv.next188, %184
  br i1 %exitcond.not.i93, label %for.end.i70, label %for.body.i80, !llvm.loop !28

for.end.i70:                                      ; preds = %for.body.i80
  %cmp13.i71 = fcmp ogt float %Min1.1, %192
  br i1 %cmp13.i71, label %if.then14.i75, label %_Z7projectRK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionS4_RK20b3AlignedObjectArrayIS2_ERfSC_.exit97

if.then14.i75:                                    ; preds = %for.end.i70
  br label %_Z7projectRK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionS4_RK20b3AlignedObjectArrayIS2_ERfSC_.exit97

_Z7projectRK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionS4_RK20b3AlignedObjectArrayIS2_ERfSC_.exit97: ; preds = %_Z7projectRK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionS4_RK20b3AlignedObjectArrayIS2_ERfSC_.exit, %for.end.i70, %if.then14.i75
  %Max1.3 = phi float [ %Max1.1, %for.end.i70 ], [ %Min1.1, %if.then14.i75 ], [ 0x47EFFFFFE0000000, %_Z7projectRK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionS4_RK20b3AlignedObjectArrayIS2_ERfSC_.exit ]
  %193 = phi float [ %Min1.1, %for.end.i70 ], [ %192, %if.then14.i75 ], [ 0xC7EFFFFFE0000000, %_Z7projectRK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionS4_RK20b3AlignedObjectArrayIS2_ERfSC_.exit ]
  %mul5.i.i.i72 = fmul float %posB.sroa.2.0.copyload, %crossje.sroa.0.4.vec.extract152
  %194 = tail call float @llvm.fmuladd.f32(float %posB.sroa.0.0.copyload, float %crossje.sroa.0.0.vec.extract139, float %mul5.i.i.i72)
  %195 = tail call noundef float @llvm.fmuladd.f32(float %posB.sroa.3.0.copyload, float %crossje.sroa.18.8.vec.extract165, float %194)
  %add16.i73 = fadd float %195, %193
  %add17.i74 = fadd float %195, %Max1.3
  %sub = fsub float %add17.i, %add16.i73
  %sub27 = fsub float %add17.i74, %add16.i
  %cmp28 = fcmp olt float %sub, %sub27
  %cond = select i1 %cmp28, float %sub, float %sub27
  %196 = load float, ptr %dmin, align 4
  %cmp29 = fcmp olt float %cond, %196
  br i1 %cmp29, label %if.then30, label %for.inc

if.then30:                                        ; preds = %_Z7projectRK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionS4_RK20b3AlignedObjectArrayIS2_ERfSC_.exit97
  store float %cond, ptr %dmin, align 4
  store <2 x float> %crossje.sroa.0.0, ptr %sep, align 16
  store <2 x float> %crossje.sroa.18.0, ptr %crossje.sroa.18.0.sep.sroa_idx, align 8
  %.pre191 = load i32, ptr %m_numUniqueEdges5, align 8
  br label %for.inc

for.inc:                                          ; preds = %lor.lhs.false3.i, %if.then30, %_Z7projectRK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionS4_RK20b3AlignedObjectArrayIS2_ERfSC_.exit97
  %197 = phi i32 [ %52, %lor.lhs.false3.i ], [ %.pre191, %if.then30 ], [ %52, %_Z7projectRK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionS4_RK20b3AlignedObjectArrayIS2_ERfSC_.exit97 ]
  %inc33 = add nuw nsw i32 %e1.0179, 1
  %cmp6 = icmp slt i32 %inc33, %197
  br i1 %cmp6, label %for.body7, label %for.inc34.loopexit, !llvm.loop !29

for.inc34.loopexit:                               ; preds = %for.inc
  %.pre192 = load i32, ptr %m_numUniqueEdges, align 8
  br label %for.inc34

for.inc34:                                        ; preds = %for.inc34.loopexit, %for.body
  %198 = phi i32 [ %1, %for.body ], [ %.pre192, %for.inc34.loopexit ]
  %199 = phi i32 [ %2, %for.body ], [ %197, %for.inc34.loopexit ]
  %200 = phi i32 [ %3, %for.body ], [ %197, %for.inc34.loopexit ]
  %inc35 = add nuw nsw i32 %e0.0182, 1
  %cmp = icmp slt i32 %inc35, %198
  br i1 %cmp, label %for.body, label %for.end36, !llvm.loop !30

for.end36:                                        ; preds = %for.inc34, %entry
  %201 = load float, ptr %DeltaC2, align 16
  %fneg.i = fneg float %201
  %arrayidx1.i = getelementptr inbounds [4 x float], ptr %DeltaC2, i64 0, i64 1
  %202 = load float, ptr %arrayidx1.i, align 4
  %fneg2.i = fneg float %202
  %arrayidx3.i98 = getelementptr inbounds [4 x float], ptr %DeltaC2, i64 0, i64 2
  %203 = load float, ptr %arrayidx3.i98, align 8
  %fneg4.i = fneg float %203
  %204 = load <2 x float>, ptr %sep, align 16
  %205 = extractelement <2 x float> %204, i64 1
  %mul5.i.i106 = fmul float %205, %fneg2.i
  %206 = extractelement <2 x float> %204, i64 0
  %207 = tail call float @llvm.fmuladd.f32(float %fneg.i, float %206, float %mul5.i.i106)
  %arrayidx7.i.i108 = getelementptr inbounds [4 x float], ptr %sep, i64 0, i64 2
  %208 = load float, ptr %arrayidx7.i.i108, align 8
  %209 = tail call noundef float @llvm.fmuladd.f32(float %fneg4.i, float %208, float %207)
  %cmp42 = fcmp ogt float %209, 0.000000e+00
  br i1 %cmp42, label %if.then43, label %if.end48

if.then43:                                        ; preds = %for.end36
  %210 = fneg <2 x float> %204
  %fneg4.i113 = fneg float %208
  %retval.sroa.3.12.vec.insert.i.i116 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %fneg4.i113, i64 0
  store <2 x float> %210, ptr %sep, align 16
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i116, ptr %arrayidx7.i.i108, align 8
  br label %if.end48

if.end48:                                         ; preds = %if.then43, %for.end36
  ret i1 true
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z7projectRK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionS4_RK20b3AlignedObjectArrayIS2_ERfSC_(ptr noundef nonnull align 16 dereferenceable(96) %hull, ptr noundef nonnull align 16 dereferenceable(16) %pos, ptr noundef nonnull align 16 dereferenceable(16) %orn, ptr noundef nonnull align 16 dereferenceable(16) %dir, ptr noundef nonnull align 8 dereferenceable(25) %vertices, ptr noundef nonnull align 4 dereferenceable(4) %min, ptr noundef nonnull align 4 dereferenceable(4) %max) local_unnamed_addr #5 comdat {
entry:
  store float 0x47EFFFFFE0000000, ptr %min, align 4
  store float 0xC7EFFFFFE0000000, ptr %max, align 4
  %m_numVertices = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hull, i64 0, i32 7
  %0 = load i32, ptr %m_numVertices, align 4
  %1 = load float, ptr %orn, align 16
  %fneg.i = fneg float %1
  %arrayidx3.i = getelementptr inbounds [4 x float], ptr %orn, i64 0, i64 1
  %2 = load float, ptr %arrayidx3.i, align 4
  %fneg4.i = fneg float %2
  %arrayidx6.i = getelementptr inbounds [4 x float], ptr %orn, i64 0, i64 2
  %3 = load float, ptr %arrayidx6.i, align 8
  %fneg7.i = fneg float %3
  %arrayidx8.i = getelementptr inbounds [4 x float], ptr %orn, i64 0, i64 3
  %4 = load float, ptr %arrayidx8.i, align 4
  %5 = load float, ptr %dir, align 16
  %arrayidx.i24.i.i = getelementptr inbounds [4 x float], ptr %dir, i64 0, i64 2
  %6 = load float, ptr %arrayidx.i24.i.i, align 8
  %mul4.i.i = fmul float %6, %fneg4.i
  %7 = tail call float @llvm.fmuladd.f32(float %4, float %5, float %mul4.i.i)
  %arrayidx.i26.i.i = getelementptr inbounds [4 x float], ptr %dir, i64 0, i64 1
  %8 = load float, ptr %arrayidx.i26.i.i, align 4
  %9 = tail call float @llvm.fmuladd.f32(float %3, float %8, float %7)
  %mul12.i.i = fmul float %5, %fneg7.i
  %10 = tail call float @llvm.fmuladd.f32(float %4, float %8, float %mul12.i.i)
  %11 = tail call float @llvm.fmuladd.f32(float %1, float %6, float %10)
  %mul21.i.i = fmul float %8, %fneg.i
  %12 = tail call float @llvm.fmuladd.f32(float %4, float %6, float %mul21.i.i)
  %13 = tail call float @llvm.fmuladd.f32(float %2, float %5, float %12)
  %neg31.i.i = fmul float %2, %8
  %14 = tail call float @llvm.fmuladd.f32(float %1, float %5, float %neg31.i.i)
  %15 = tail call float @llvm.fmuladd.f32(float %3, float %6, float %14)
  %mul4.i9.i = fmul float %4, %9
  %16 = tail call float @llvm.fmuladd.f32(float %15, float %1, float %mul4.i9.i)
  %17 = tail call float @llvm.fmuladd.f32(float %11, float %3, float %16)
  %18 = tail call float @llvm.fmuladd.f32(float %13, float %fneg4.i, float %17)
  %mul14.i.i = fmul float %4, %11
  %19 = tail call float @llvm.fmuladd.f32(float %15, float %2, float %mul14.i.i)
  %20 = tail call float @llvm.fmuladd.f32(float %13, float %1, float %19)
  %21 = tail call float @llvm.fmuladd.f32(float %9, float %fneg7.i, float %20)
  %mul25.i.i = fmul float %4, %13
  %22 = tail call float @llvm.fmuladd.f32(float %15, float %3, float %mul25.i.i)
  %23 = tail call float @llvm.fmuladd.f32(float %9, float %2, float %22)
  %24 = tail call float @llvm.fmuladd.f32(float %11, float %fneg.i, float %23)
  %25 = load float, ptr %pos, align 16
  %arrayidx3.i.i = getelementptr inbounds [4 x float], ptr %pos, i64 0, i64 1
  %26 = load float, ptr %arrayidx3.i.i, align 4
  %arrayidx6.i.i = getelementptr inbounds [4 x float], ptr %pos, i64 0, i64 2
  %27 = load float, ptr %arrayidx6.i.i, align 8
  %cmp27 = icmp sgt i32 %0, 0
  br i1 %cmp27, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %entry
  %m_vertexOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hull, i64 0, i32 8
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray, ptr %vertices, i64 0, i32 5
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %28 = phi float [ 0xC7EFFFFFE0000000, %for.body.lr.ph ], [ %38, %for.inc ]
  %i.028 = phi i32 [ 0, %for.body.lr.ph ], [ %inc, %for.inc ]
  %29 = load i32, ptr %m_vertexOffset, align 16
  %add = add nsw i32 %29, %i.028
  %30 = load ptr, ptr %m_data.i, align 8
  %idxprom.i = sext i32 %add to i64
  %arrayidx.i = getelementptr inbounds %class.b3Vector3, ptr %30, i64 %idxprom.i
  %31 = load float, ptr %arrayidx.i, align 16
  %arrayidx3.i.i22 = getelementptr inbounds [4 x float], ptr %arrayidx.i, i64 0, i64 1
  %32 = load float, ptr %arrayidx3.i.i22, align 4
  %mul5.i.i24 = fmul float %21, %32
  %33 = tail call float @llvm.fmuladd.f32(float %31, float %18, float %mul5.i.i24)
  %arrayidx6.i.i25 = getelementptr inbounds [4 x float], ptr %arrayidx.i, i64 0, i64 2
  %34 = load float, ptr %arrayidx6.i.i25, align 8
  %35 = tail call noundef float @llvm.fmuladd.f32(float %34, float %24, float %33)
  %36 = load float, ptr %min, align 4
  %cmp9 = fcmp olt float %35, %36
  br i1 %cmp9, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  store float %35, ptr %min, align 4
  %.pre = load float, ptr %max, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %37 = phi float [ %.pre, %if.then ], [ %28, %for.body ]
  %cmp10 = fcmp ogt float %35, %37
  br i1 %cmp10, label %if.then11, label %for.inc

if.then11:                                        ; preds = %if.end
  store float %35, ptr %max, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then11
  %38 = phi float [ %37, %if.end ], [ %35, %if.then11 ]
  %inc = add nuw nsw i32 %i.028, 1
  %exitcond.not = icmp eq i32 %inc, %0
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !28

for.end:                                          ; preds = %for.inc, %entry
  %39 = phi float [ 0xC7EFFFFFE0000000, %entry ], [ %38, %for.inc ]
  %40 = load float, ptr %min, align 4
  %cmp13 = fcmp ogt float %40, %39
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %for.end
  store float %39, ptr %min, align 4
  store float %40, ptr %max, align 4
  %.pre29 = load float, ptr %min, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %for.end
  %41 = phi float [ %.pre29, %if.then14 ], [ %40, %for.end ]
  %mul5.i.i = fmul float %8, %26
  %42 = tail call float @llvm.fmuladd.f32(float %25, float %5, float %mul5.i.i)
  %43 = tail call noundef float @llvm.fmuladd.f32(float %27, float %6, float %42)
  %add16 = fadd float %43, %41
  store float %add16, ptr %min, align 4
  %44 = load float, ptr %max, align 4
  %add17 = fadd float %43, %44
  store float %add17, ptr %max, align 4
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind memory(argmem: readwrite) uwtable
define dso_local noundef i32 @_Z8clipFacePK9b3Vector3iRS_fPS_(ptr nocapture noundef readonly %pVtxIn, i32 noundef %numVertsIn, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %planeNormalWS, float noundef %planeEqWS, ptr nocapture noundef writeonly %ppVtxOut) local_unnamed_addr #2 {
entry:
  %cmp = icmp slt i32 %numVertsIn, 2
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %0 = zext nneg i32 %numVertsIn to i64
  %1 = getelementptr %class.b3Vector3, ptr %pVtxIn, i64 %0
  %arrayidx = getelementptr %class.b3Vector3, ptr %1, i64 -1
  %2 = load <2 x float>, ptr %arrayidx, align 16
  %firstVertex.sroa.9.0.arrayidx.sroa_idx = getelementptr %class.b3Vector3, ptr %1, i64 -1, i32 0, i32 0, i64 2
  %firstVertex.sroa.9.0.copyload = load float, ptr %firstVertex.sroa.9.0.arrayidx.sroa_idx, align 8
  %3 = load float, ptr %planeNormalWS, align 16
  %arrayidx3.i.i = getelementptr inbounds [4 x float], ptr %planeNormalWS, i64 0, i64 1
  %4 = load float, ptr %arrayidx3.i.i, align 4
  %5 = extractelement <2 x float> %2, i64 1
  %mul5.i.i = fmul float %5, %4
  %6 = extractelement <2 x float> %2, i64 0
  %7 = tail call float @llvm.fmuladd.f32(float %3, float %6, float %mul5.i.i)
  %arrayidx6.i.i = getelementptr inbounds [4 x float], ptr %planeNormalWS, i64 0, i64 2
  %8 = load float, ptr %arrayidx6.i.i, align 8
  %9 = tail call noundef float @llvm.fmuladd.f32(float %8, float %firstVertex.sroa.9.0.copyload, float %7)
  %add = fadd float %9, %planeEqWS
  br label %for.body

for.body:                                         ; preds = %if.end, %if.end37
  %indvars.iv = phi i64 [ 0, %if.end ], [ %indvars.iv.next, %if.end37 ]
  %ds.073 = phi float [ %add, %if.end ], [ %add6, %if.end37 ]
  %numVertsOut.072 = phi i32 [ 0, %if.end ], [ %numVertsOut.1, %if.end37 ]
  %firstVertex.sroa.9.069 = phi float [ %firstVertex.sroa.9.0.copyload, %if.end ], [ %18, %if.end37 ]
  %10 = phi <2 x float> [ %2, %if.end ], [ %32, %if.end37 ]
  %arrayidx4 = getelementptr inbounds %class.b3Vector3, ptr %pVtxIn, i64 %indvars.iv
  %11 = load <4 x float>, ptr %arrayidx4, align 16
  %12 = load float, ptr %planeNormalWS, align 16
  %13 = load float, ptr %arrayidx3.i.i, align 4
  %14 = extractelement <4 x float> %11, i64 1
  %mul5.i.i26 = fmul float %14, %13
  %15 = extractelement <4 x float> %11, i64 0
  %16 = tail call float @llvm.fmuladd.f32(float %12, float %15, float %mul5.i.i26)
  %17 = load float, ptr %arrayidx6.i.i, align 8
  %18 = extractelement <4 x float> %11, i64 2
  %19 = tail call noundef float @llvm.fmuladd.f32(float %17, float %18, float %16)
  %add6 = fadd float %19, %planeEqWS
  %cmp7 = fcmp olt float %ds.073, 0.000000e+00
  %cmp9 = fcmp olt float %add6, 0.000000e+00
  br i1 %cmp7, label %if.then8, label %if.else20

if.then8:                                         ; preds = %for.body
  br i1 %cmp9, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.then8
  %inc = add nsw i32 %numVertsOut.072, 1
  %idxprom11 = sext i32 %numVertsOut.072 to i64
  %arrayidx12 = getelementptr inbounds %class.b3Vector3, ptr %ppVtxOut, i64 %idxprom11
  store <4 x float> %11, ptr %arrayidx12, align 16
  br label %if.end37

if.else:                                          ; preds = %if.then8
  %sub13 = fsub float %ds.073, %add6
  %div = fdiv float %ds.073, %sub13
  %20 = shufflevector <4 x float> %11, <4 x float> poison, <2 x i32> <i32 0, i32 1>
  %21 = fsub <2 x float> %20, %10
  %22 = insertelement <2 x float> poison, float %div, i64 0
  %23 = shufflevector <2 x float> %22, <2 x float> poison, <2 x i32> zeroinitializer
  %24 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %21, <2 x float> %23, <2 x float> %10)
  %sub8.i = fsub float %18, %firstVertex.sroa.9.069
  %25 = tail call float @llvm.fmuladd.f32(float %sub8.i, float %div, float %firstVertex.sroa.9.069)
  %retval.sroa.3.12.vec.insert.i.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %25, i64 0
  %inc16 = add nsw i32 %numVertsOut.072, 1
  %idxprom17 = sext i32 %numVertsOut.072 to i64
  %arrayidx18 = getelementptr inbounds %class.b3Vector3, ptr %ppVtxOut, i64 %idxprom17
  store <2 x float> %24, ptr %arrayidx18, align 16
  %ref.tmp.sroa.2.0.arrayidx18.sroa_idx = getelementptr inbounds i8, ptr %arrayidx18, i64 8
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i, ptr %ref.tmp.sroa.2.0.arrayidx18.sroa_idx, align 8
  br label %if.end37

if.else20:                                        ; preds = %for.body
  br i1 %cmp9, label %if.then22, label %if.end37

if.then22:                                        ; preds = %if.else20
  %sub25 = fsub float %ds.073, %add6
  %div26 = fdiv float %ds.073, %sub25
  %26 = shufflevector <4 x float> %11, <4 x float> poison, <2 x i32> <i32 0, i32 1>
  %27 = fsub <2 x float> %26, %10
  %28 = insertelement <2 x float> poison, float %div26, i64 0
  %29 = shufflevector <2 x float> %28, <2 x float> poison, <2 x i32> zeroinitializer
  %30 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %27, <2 x float> %29, <2 x float> %10)
  %sub8.i35 = fsub float %18, %firstVertex.sroa.9.069
  %31 = tail call float @llvm.fmuladd.f32(float %sub8.i35, float %div26, float %firstVertex.sroa.9.069)
  %retval.sroa.3.12.vec.insert.i.i38 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %31, i64 0
  %idxprom31 = sext i32 %numVertsOut.072 to i64
  %arrayidx32 = getelementptr inbounds %class.b3Vector3, ptr %ppVtxOut, i64 %idxprom31
  store <2 x float> %30, ptr %arrayidx32, align 16
  %ref.tmp23.sroa.2.0.arrayidx32.sroa_idx = getelementptr inbounds i8, ptr %arrayidx32, i64 8
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i38, ptr %ref.tmp23.sroa.2.0.arrayidx32.sroa_idx, align 8
  %inc33 = add nsw i32 %numVertsOut.072, 2
  %arrayidx35 = getelementptr %class.b3Vector3, ptr %arrayidx32, i64 1
  store <4 x float> %11, ptr %arrayidx35, align 16
  br label %if.end37

if.end37:                                         ; preds = %if.else20, %if.then22, %if.then10, %if.else
  %numVertsOut.1 = phi i32 [ %inc, %if.then10 ], [ %inc16, %if.else ], [ %inc33, %if.then22 ], [ %numVertsOut.072, %if.else20 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %0
  %32 = shufflevector <4 x float> %11, <4 x float> poison, <2 x i32> <i32 0, i32 1>
  br i1 %exitcond.not, label %return, label %for.body, !llvm.loop !31

return:                                           ; preds = %if.end37, %entry
  %retval.0 = phi i32 [ 0, %entry ], [ %numVertsOut.1, %if.end37 ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress uwtable
define dso_local noundef i32 @_Z19clipFaceAgainstHullRK9b3Vector3PK22b3ConvexPolyhedronDataS1_RK12b3QuaternionPS_iS8_iffRK20b3AlignedObjectArrayIS_ERKS9_I9b3GpuFaceERKS9_IiES8_i(ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %separatingNormal, ptr nocapture noundef readonly %hullA, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %posA, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %ornA, ptr nocapture noundef %worldVertsB1, i32 noundef %numWorldVertsB1, ptr nocapture noundef %worldVertsB2, i32 %capacityWorldVertsB2, float noundef %minDist, float noundef %maxDist, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %verticesA, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %facesA, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %indicesA, ptr nocapture noundef writeonly %contactsOut, i32 noundef %contactCapacity) local_unnamed_addr #5 {
entry:
  %planeNormalWS = alloca %class.b3Vector3, align 16
  %m_numFaces = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 6
  %0 = load i32, ptr %m_numFaces, align 8
  %cmp185 = icmp sgt i32 %0, 0
  br i1 %cmp185, label %for.body.lr.ph, label %return

for.body.lr.ph:                                   ; preds = %entry
  %m_faceOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 5
  %1 = load i32, ptr %m_faceOffset, align 4
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %facesA, i64 0, i32 5
  %2 = load ptr, ptr %m_data.i, align 8
  %arrayidx.i.i.i = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 3
  %3 = load float, ptr %arrayidx.i.i.i, align 4
  %arrayidx.i23.i.i = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 1
  %4 = load float, ptr %arrayidx.i23.i.i, align 4
  %arrayidx.i25.i.i = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 2
  %5 = load float, ptr %arrayidx.i25.i.i, align 8
  %neg.i.i = fneg float %5
  %6 = load float, ptr %ornA, align 16
  %neg15.i.i = fneg float %6
  %neg24.i.i = fneg float %4
  %7 = load float, ptr %separatingNormal, align 16
  %arrayidx4.i.i = getelementptr inbounds [4 x float], ptr %separatingNormal, i64 0, i64 1
  %8 = load float, ptr %arrayidx4.i.i, align 4
  %arrayidx7.i.i = getelementptr inbounds [4 x float], ptr %separatingNormal, i64 0, i64 2
  %9 = load float, ptr %arrayidx7.i.i, align 8
  %10 = sext i32 %1 to i64
  %wide.trip.count = zext nneg i32 %0 to i64
  %invariant.gep = getelementptr %struct.b3GpuFace, ptr %2, i64 %10
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ]
  %closestFaceA.0188 = phi i32 [ -1, %for.body.lr.ph ], [ %closestFaceA.1, %for.body ]
  %dmin.0187 = phi float [ 0x47EFFFFFE0000000, %for.body.lr.ph ], [ %dmin.1, %for.body ]
  %gep = getelementptr %struct.b3GpuFace, ptr %invariant.gep, i64 %indvars.iv
  %11 = load float, ptr %gep, align 16
  %y = getelementptr inbounds %struct.anon.2, ptr %gep, i64 0, i32 1
  %12 = load float, ptr %y, align 4
  %z = getelementptr inbounds %struct.anon.2, ptr %gep, i64 0, i32 2
  %13 = load float, ptr %z, align 8
  %mul4.i.i = fmul float %13, %4
  %14 = tail call float @llvm.fmuladd.f32(float %3, float %11, float %mul4.i.i)
  %15 = tail call float @llvm.fmuladd.f32(float %neg.i.i, float %12, float %14)
  %mul12.i.i = fmul float %11, %5
  %16 = tail call float @llvm.fmuladd.f32(float %3, float %12, float %mul12.i.i)
  %17 = tail call float @llvm.fmuladd.f32(float %neg15.i.i, float %13, float %16)
  %mul21.i.i = fmul float %12, %6
  %18 = tail call float @llvm.fmuladd.f32(float %3, float %13, float %mul21.i.i)
  %19 = tail call float @llvm.fmuladd.f32(float %neg24.i.i, float %11, float %18)
  %neg31.i.i = fmul float %12, %neg24.i.i
  %20 = tail call float @llvm.fmuladd.f32(float %neg15.i.i, float %11, float %neg31.i.i)
  %21 = tail call float @llvm.fmuladd.f32(float %neg.i.i, float %13, float %20)
  %mul4.i9.i = fmul float %3, %15
  %22 = tail call float @llvm.fmuladd.f32(float %21, float %neg15.i.i, float %mul4.i9.i)
  %23 = tail call float @llvm.fmuladd.f32(float %17, float %neg.i.i, float %22)
  %24 = tail call float @llvm.fmuladd.f32(float %19, float %4, float %23)
  %mul14.i.i = fmul float %3, %17
  %25 = tail call float @llvm.fmuladd.f32(float %21, float %neg24.i.i, float %mul14.i.i)
  %26 = tail call float @llvm.fmuladd.f32(float %19, float %neg15.i.i, float %25)
  %27 = tail call float @llvm.fmuladd.f32(float %15, float %5, float %26)
  %mul25.i.i = fmul float %3, %19
  %28 = tail call float @llvm.fmuladd.f32(float %21, float %neg.i.i, float %mul25.i.i)
  %29 = tail call float @llvm.fmuladd.f32(float %15, float %neg24.i.i, float %28)
  %30 = tail call float @llvm.fmuladd.f32(float %17, float %6, float %29)
  %mul5.i.i = fmul float %8, %27
  %31 = tail call float @llvm.fmuladd.f32(float %24, float %7, float %mul5.i.i)
  %32 = tail call noundef float @llvm.fmuladd.f32(float %30, float %9, float %31)
  %cmp15 = fcmp olt float %32, %dmin.0187
  %dmin.1 = select i1 %cmp15, float %32, float %dmin.0187
  %33 = trunc i64 %indvars.iv to i32
  %closestFaceA.1 = select i1 %cmp15, i32 %33, i32 %closestFaceA.0188
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !32

for.end:                                          ; preds = %for.body
  %cmp16 = icmp slt i32 %closestFaceA.1, 0
  br i1 %cmp16, label %return, label %if.end18

if.end18:                                         ; preds = %for.end
  %m_faceOffset19 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 5
  %34 = load i32, ptr %m_faceOffset19, align 4
  %add20 = add nsw i32 %34, %closestFaceA.1
  %m_data.i54 = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %facesA, i64 0, i32 5
  %35 = load ptr, ptr %m_data.i54, align 8
  %idxprom.i55 = sext i32 %add20 to i64
  %arrayidx.i56 = getelementptr inbounds %struct.b3GpuFace, ptr %35, i64 %idxprom.i55
  %polyA.sroa.0.0.copyload = load float, ptr %arrayidx.i56, align 16
  %polyA.sroa.3.0.call21.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i56, i64 4
  %36 = load <2 x float>, ptr %polyA.sroa.3.0.call21.sroa_idx, align 4
  %37 = shufflevector <2 x float> %36, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %polyA.sroa.7.0.call21.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i56, i64 12
  %polyA.sroa.7.0.copyload = load float, ptr %polyA.sroa.7.0.call21.sroa_idx, align 4
  %polyA.sroa.8.0.call21.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i56, i64 16
  %polyA.sroa.8.0.copyload = load i32, ptr %polyA.sroa.8.0.call21.sroa_idx, align 16
  %polyA.sroa.10.0.call21.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i56, i64 20
  %polyA.sroa.10.0.copyload = load i32, ptr %polyA.sroa.10.0.call21.sroa_idx, align 4
  %cmp23189 = icmp sgt i32 %polyA.sroa.10.0.copyload, 0
  br i1 %cmp23189, label %for.body24.lr.ph, label %for.end67

for.body24.lr.ph:                                 ; preds = %if.end18
  %m_vertexOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 8
  %m_data.i57 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %indicesA, i64 0, i32 5
  %m_data.i60 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %verticesA, i64 0, i32 5
  %arrayidx.i.i.i69 = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 3
  %arrayidx.i25.i.i73 = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 2
  %tr.sroa.29.48.pos.sroa_idx.i = getelementptr inbounds i8, ptr %posA, i64 4
  %tr.sroa.30.48.pos.sroa_idx.i = getelementptr inbounds i8, ptr %posA, i64 8
  %planeNormalWS1.sroa.4.0.planeNormalWS.sroa_idx = getelementptr inbounds i8, ptr %planeNormalWS, i64 8
  %38 = sext i32 %polyA.sroa.8.0.copyload to i64
  %39 = zext nneg i32 %polyA.sroa.10.0.copyload to i64
  %40 = extractelement <2 x float> %36, i64 0
  %41 = extractelement <2 x float> %36, i64 1
  %42 = insertelement <2 x float> %36, float %polyA.sroa.0.0.copyload, i64 0
  %43 = insertelement <2 x float> %36, float %polyA.sroa.0.0.copyload, i64 1
  br label %for.body24

for.body24:                                       ; preds = %for.body24.lr.ph, %for.body24
  %indvars.iv202 = phi i64 [ 0, %for.body24.lr.ph ], [ %indvars.iv.next203, %for.body24 ]
  %pVtxIn.0193 = phi ptr [ %worldVertsB1, %for.body24.lr.ph ], [ %pVtxOut.0192, %for.body24 ]
  %pVtxOut.0192 = phi ptr [ %worldVertsB2, %for.body24.lr.ph ], [ %pVtxIn.0193, %for.body24 ]
  %numVertsIn.0191 = phi i32 [ %numWorldVertsB1, %for.body24.lr.ph ], [ %call64, %for.body24 ]
  %44 = load i32, ptr %m_vertexOffset, align 16
  %45 = load ptr, ptr %m_data.i57, align 8
  %46 = getelementptr i32, ptr %45, i64 %indvars.iv202
  %arrayidx.i59 = getelementptr i32, ptr %46, i64 %38
  %47 = load i32, ptr %arrayidx.i59, align 4
  %add27 = add nsw i32 %47, %44
  %48 = load ptr, ptr %m_data.i60, align 8
  %idxprom.i61 = sext i32 %add27 to i64
  %arrayidx.i62 = getelementptr inbounds %class.b3Vector3, ptr %48, i64 %idxprom.i61
  %a.sroa.0.0.copyload = load float, ptr %arrayidx.i62, align 16
  %a.sroa.3.0.arrayidx.i62.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i62, i64 4
  %indvars.iv.next203 = add nuw nsw i64 %indvars.iv202, 1
  %49 = icmp eq i64 %indvars.iv.next203, %39
  %50 = trunc i64 %indvars.iv.next203 to i32
  %iv.rem = select i1 %49, i32 0, i32 %50
  %add32 = add nsw i32 %iv.rem, %polyA.sroa.8.0.copyload
  %idxprom.i64 = sext i32 %add32 to i64
  %arrayidx.i65 = getelementptr inbounds i32, ptr %45, i64 %idxprom.i64
  %51 = load i32, ptr %arrayidx.i65, align 4
  %add34 = add nsw i32 %51, %44
  %idxprom.i67 = sext i32 %add34 to i64
  %arrayidx.i68 = getelementptr inbounds %class.b3Vector3, ptr %48, i64 %idxprom.i67
  %b.sroa.0.0.copyload = load float, ptr %arrayidx.i68, align 16
  %b.sroa.2.0.arrayidx.i68.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i68, i64 4
  %sub.i = fsub float %a.sroa.0.0.copyload, %b.sroa.0.0.copyload
  %52 = load float, ptr %arrayidx.i.i.i69, align 4
  %53 = load float, ptr %arrayidx.i25.i.i73, align 8
  %tr.sroa.27.48.copyload.i = load float, ptr %posA, align 16
  %tr.sroa.29.48.copyload.i = load float, ptr %tr.sroa.29.48.pos.sroa_idx.i, align 4
  %tr.sroa.30.48.copyload.i = load float, ptr %tr.sroa.30.48.pos.sroa_idx.i, align 8
  %54 = load <2 x float>, ptr %ornA, align 16
  %55 = shufflevector <2 x float> %54, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %56 = extractelement <2 x float> %54, i64 1
  %neg24.i.i79 = fneg float %56
  %mul4.i.i98 = fmul float %41, %56
  %57 = tail call float @llvm.fmuladd.f32(float %52, float %polyA.sroa.0.0.copyload, float %mul4.i.i98)
  %neg31.i.i106 = fmul float %40, %neg24.i.i79
  %58 = load <2 x float>, ptr %a.sroa.3.0.arrayidx.i62.sroa_idx, align 4
  %59 = load <2 x float>, ptr %b.sroa.2.0.arrayidx.i68.sroa_idx, align 4
  %60 = fsub <2 x float> %58, %59
  %61 = shufflevector <2 x float> %60, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %62 = insertelement <2 x float> %60, float %sub.i, i64 0
  %63 = insertelement <2 x float> %54, float %53, i64 0
  %64 = fmul <2 x float> %62, %63
  %65 = insertelement <2 x float> poison, float %52, i64 0
  %66 = shufflevector <2 x float> %65, <2 x float> poison, <2 x i32> zeroinitializer
  %67 = insertelement <2 x float> %60, float %sub.i, i64 1
  %68 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %66, <2 x float> %67, <2 x float> %64)
  %69 = insertelement <2 x float> %54, float %53, i64 1
  %70 = fneg <2 x float> %69
  %71 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %70, <2 x float> %61, <2 x float> %68)
  %72 = extractelement <2 x float> %60, i64 0
  %73 = extractelement <2 x float> %54, i64 0
  %mul21.i.i78 = fmul float %72, %73
  %74 = extractelement <2 x float> %60, i64 1
  %75 = tail call float @llvm.fmuladd.f32(float %52, float %74, float %mul21.i.i78)
  %76 = tail call float @llvm.fmuladd.f32(float %neg24.i.i79, float %sub.i, float %75)
  %neg31.i.i80 = fmul float %72, %neg24.i.i79
  %77 = extractelement <2 x float> %70, i64 0
  %78 = tail call float @llvm.fmuladd.f32(float %77, float %sub.i, float %neg31.i.i80)
  %79 = extractelement <2 x float> %70, i64 1
  %80 = tail call float @llvm.fmuladd.f32(float %79, float %74, float %78)
  %81 = extractelement <2 x float> %71, i64 1
  %mul4.i9.i81 = fmul float %52, %81
  %82 = tail call float @llvm.fmuladd.f32(float %80, float %77, float %mul4.i9.i81)
  %83 = extractelement <2 x float> %71, i64 0
  %84 = tail call float @llvm.fmuladd.f32(float %83, float %79, float %82)
  %85 = tail call float @llvm.fmuladd.f32(float %76, float %56, float %84)
  %86 = shufflevector <2 x float> %71, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %87 = insertelement <2 x float> %86, float %76, i64 0
  %88 = fmul <2 x float> %66, %87
  %89 = insertelement <2 x float> poison, float %80, i64 0
  %90 = shufflevector <2 x float> %89, <2 x float> poison, <2 x i32> zeroinitializer
  %91 = shufflevector <2 x float> %70, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %92 = insertelement <2 x float> %91, float %neg24.i.i79, i64 1
  %93 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %90, <2 x float> %92, <2 x float> %88)
  %94 = shufflevector <2 x float> %71, <2 x float> %87, <2 x i32> <i32 1, i32 2>
  %95 = shufflevector <2 x float> %92, <2 x float> %70, <2 x i32> <i32 1, i32 2>
  %96 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %94, <2 x float> %95, <2 x float> %93)
  %97 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %71, <2 x float> %69, <2 x float> %96)
  %98 = tail call float @llvm.fmuladd.f32(float %79, float %40, float %57)
  %99 = fmul <2 x float> %43, %69
  %100 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %66, <2 x float> %37, <2 x float> %99)
  %101 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %95, <2 x float> %42, <2 x float> %100)
  %102 = tail call float @llvm.fmuladd.f32(float %77, float %polyA.sroa.0.0.copyload, float %neg31.i.i106)
  %103 = tail call float @llvm.fmuladd.f32(float %79, float %41, float %102)
  %104 = extractelement <2 x float> %101, i64 1
  %mul14.i.i108 = fmul float %52, %104
  %105 = tail call float @llvm.fmuladd.f32(float %103, float %neg24.i.i79, float %mul14.i.i108)
  %106 = extractelement <2 x float> %101, i64 0
  %107 = tail call float @llvm.fmuladd.f32(float %106, float %77, float %105)
  %108 = tail call float @llvm.fmuladd.f32(float %98, float %53, float %107)
  %109 = shufflevector <2 x float> %101, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %110 = insertelement <2 x float> %109, float %98, i64 0
  %111 = fmul <2 x float> %66, %110
  %112 = insertelement <2 x float> poison, float %103, i64 0
  %113 = shufflevector <2 x float> %112, <2 x float> poison, <2 x i32> zeroinitializer
  %114 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %113, <2 x float> %70, <2 x float> %111)
  %115 = shufflevector <2 x float> %101, <2 x float> %110, <2 x i32> <i32 1, i32 2>
  %116 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %115, <2 x float> %92, <2 x float> %114)
  %117 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %101, <2 x float> %55, <2 x float> %116)
  %118 = shufflevector <2 x float> %97, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %119 = insertelement <2 x float> %118, float %85, i64 0
  %120 = fneg <2 x float> %119
  %121 = shufflevector <2 x float> %117, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %122 = insertelement <2 x float> %121, float %108, i64 1
  %123 = fmul <2 x float> %122, %120
  %124 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %97, <2 x float> %117, <2 x float> %123)
  %125 = extractelement <2 x float> %97, i64 1
  %126 = fneg float %125
  %127 = extractelement <2 x float> %117, i64 0
  %neg17.i = fmul float %127, %126
  %128 = tail call float @llvm.fmuladd.f32(float %85, float %108, float %neg17.i)
  %129 = fneg <2 x float> %124
  %fneg4.i = fneg float %128
  %130 = shufflevector <2 x float> %129, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %retval.sroa.3.12.vec.insert.i.i126 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %fneg4.i, i64 0
  %mul4.i.i.i.i.i = fmul float %56, %56
  %131 = tail call float @llvm.fmuladd.f32(float %73, float %73, float %mul4.i.i.i.i.i)
  %132 = tail call float @llvm.fmuladd.f32(float %53, float %53, float %131)
  %133 = tail call noundef float @llvm.fmuladd.f32(float %52, float %52, float %132)
  %div.i.i.i = fdiv float 2.000000e+00, %133
  %134 = insertelement <2 x float> poison, float %div.i.i.i, i64 0
  %135 = shufflevector <2 x float> %134, <2 x float> poison, <2 x i32> zeroinitializer
  %136 = fmul <2 x float> %54, %135
  %mul6.i.i.i = fmul float %53, %div.i.i.i
  %137 = extractelement <2 x float> %136, i64 0
  %mul8.i.i.i = fmul float %52, %137
  %138 = extractelement <2 x float> %136, i64 1
  %mul10.i.i.i = fmul float %52, %138
  %mul12.i.i.i = fmul float %52, %mul6.i.i.i
  %mul16.i.i.i = fmul float %73, %138
  %mul18.i.i.i = fmul float %73, %mul6.i.i.i
  %139 = fmul <2 x float> %54, %136
  %mul22.i.i.i = fmul float %56, %mul6.i.i.i
  %mul24.i.i.i = fmul float %53, %mul6.i.i.i
  %140 = extractelement <2 x float> %139, i64 1
  %add.i.i.i = fadd float %140, %mul24.i.i.i
  %sub.i.i.i = fsub float 1.000000e+00, %add.i.i.i
  %sub26.i.i.i = fsub float %mul16.i.i.i, %mul12.i.i.i
  %add28.i.i.i = fadd float %mul18.i.i.i, %mul10.i.i.i
  %add30.i.i.i = fadd float %mul16.i.i.i, %mul12.i.i.i
  %141 = extractelement <2 x float> %139, i64 0
  %add32.i.i.i = fadd float %141, %mul24.i.i.i
  %sub33.i.i.i = fsub float 1.000000e+00, %add32.i.i.i
  %sub35.i.i.i = fsub float %mul22.i.i.i, %mul8.i.i.i
  %sub37.i.i.i = fsub float %mul18.i.i.i, %mul10.i.i.i
  %add39.i.i.i = fadd float %mul22.i.i.i, %mul8.i.i.i
  %add41.i.i.i = fadd float %141, %140
  %sub42.i.i.i = fsub float 1.000000e+00, %add41.i.i.i
  %142 = extractelement <2 x float> %58, i64 0
  %mul5.i.i.i.i = fmul float %142, %sub26.i.i.i
  %143 = tail call float @llvm.fmuladd.f32(float %a.sroa.0.0.copyload, float %sub.i.i.i, float %mul5.i.i.i.i)
  %144 = extractelement <2 x float> %58, i64 1
  %145 = tail call noundef float @llvm.fmuladd.f32(float %144, float %add28.i.i.i, float %143)
  %mul5.i3.i.i.i = fmul float %142, %sub33.i.i.i
  %146 = tail call float @llvm.fmuladd.f32(float %a.sroa.0.0.copyload, float %add30.i.i.i, float %mul5.i3.i.i.i)
  %147 = tail call noundef float @llvm.fmuladd.f32(float %144, float %sub35.i.i.i, float %146)
  %mul5.i8.i.i.i = fmul float %142, %add39.i.i.i
  %148 = tail call float @llvm.fmuladd.f32(float %a.sroa.0.0.copyload, float %sub37.i.i.i, float %mul5.i8.i.i.i)
  %149 = tail call noundef float @llvm.fmuladd.f32(float %144, float %sub42.i.i.i, float %148)
  %add.i.i8.i = fadd float %tr.sroa.27.48.copyload.i, %145
  %add4.i.i.i = fadd float %tr.sroa.29.48.copyload.i, %147
  %add7.i.i.i = fadd float %tr.sroa.30.48.copyload.i, %149
  %150 = extractelement <2 x float> %129, i64 0
  %mul5.i.i131 = fmul float %add4.i.i.i, %150
  %151 = extractelement <2 x float> %129, i64 1
  %152 = tail call float @llvm.fmuladd.f32(float %add.i.i8.i, float %151, float %mul5.i.i131)
  %153 = tail call noundef float @llvm.fmuladd.f32(float %add7.i.i.i, float %fneg4.i, float %152)
  %fneg = fneg float %153
  store <2 x float> %130, ptr %planeNormalWS, align 16
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i126, ptr %planeNormalWS1.sroa.4.0.planeNormalWS.sroa_idx, align 8
  %call64 = call noundef i32 @_Z8clipFacePK9b3Vector3iRS_fPS_(ptr noundef %pVtxIn.0193, i32 noundef %numVertsIn.0191, ptr noundef nonnull align 16 dereferenceable(16) %planeNormalWS, float noundef %fneg, ptr noundef %pVtxOut.0192)
  %exitcond207.not = icmp eq i64 %indvars.iv.next203, %39
  br i1 %exitcond207.not, label %for.end67, label %for.body24, !llvm.loop !33

for.end67:                                        ; preds = %for.body24, %if.end18
  %numVertsIn.0.lcssa = phi i32 [ %numWorldVertsB1, %if.end18 ], [ %call64, %for.body24 ]
  %pVtxIn.0.lcssa = phi ptr [ %worldVertsB1, %if.end18 ], [ %pVtxOut.0192, %for.body24 ]
  %arrayidx.i.i.i140 = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 3
  %154 = load float, ptr %arrayidx.i.i.i140, align 4
  %arrayidx.i23.i.i141 = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 1
  %155 = load float, ptr %arrayidx.i23.i.i141, align 4
  %156 = extractelement <2 x float> %36, i64 1
  %mul4.i.i143 = fmul float %156, %155
  %157 = tail call float @llvm.fmuladd.f32(float %154, float %polyA.sroa.0.0.copyload, float %mul4.i.i143)
  %arrayidx.i25.i.i144 = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 2
  %158 = load float, ptr %arrayidx.i25.i.i144, align 8
  %neg.i.i146 = fneg float %158
  %159 = extractelement <2 x float> %36, i64 0
  %160 = tail call float @llvm.fmuladd.f32(float %neg.i.i146, float %159, float %157)
  %mul12.i.i147 = fmul float %polyA.sroa.0.0.copyload, %158
  %161 = tail call float @llvm.fmuladd.f32(float %154, float %159, float %mul12.i.i147)
  %162 = load float, ptr %ornA, align 16
  %neg15.i.i148 = fneg float %162
  %163 = tail call float @llvm.fmuladd.f32(float %neg15.i.i148, float %156, float %161)
  %mul21.i.i149 = fmul float %159, %162
  %164 = tail call float @llvm.fmuladd.f32(float %154, float %156, float %mul21.i.i149)
  %neg24.i.i150 = fneg float %155
  %165 = tail call float @llvm.fmuladd.f32(float %neg24.i.i150, float %polyA.sroa.0.0.copyload, float %164)
  %neg31.i.i151 = fmul float %159, %neg24.i.i150
  %166 = tail call float @llvm.fmuladd.f32(float %neg15.i.i148, float %polyA.sroa.0.0.copyload, float %neg31.i.i151)
  %167 = tail call float @llvm.fmuladd.f32(float %neg.i.i146, float %156, float %166)
  %mul4.i9.i152 = fmul float %154, %160
  %168 = tail call float @llvm.fmuladd.f32(float %167, float %neg15.i.i148, float %mul4.i9.i152)
  %169 = tail call float @llvm.fmuladd.f32(float %163, float %neg.i.i146, float %168)
  %170 = tail call float @llvm.fmuladd.f32(float %165, float %155, float %169)
  %mul14.i.i153 = fmul float %154, %163
  %171 = tail call float @llvm.fmuladd.f32(float %167, float %neg24.i.i150, float %mul14.i.i153)
  %172 = tail call float @llvm.fmuladd.f32(float %165, float %neg15.i.i148, float %171)
  %173 = tail call float @llvm.fmuladd.f32(float %160, float %158, float %172)
  %mul25.i.i154 = fmul float %154, %165
  %174 = tail call float @llvm.fmuladd.f32(float %167, float %neg.i.i146, float %mul25.i.i154)
  %175 = tail call float @llvm.fmuladd.f32(float %160, float %neg24.i.i150, float %174)
  %176 = tail call float @llvm.fmuladd.f32(float %163, float %162, float %175)
  %177 = load float, ptr %posA, align 16
  %arrayidx4.i.i161 = getelementptr inbounds [4 x float], ptr %posA, i64 0, i64 1
  %178 = load float, ptr %arrayidx4.i.i161, align 4
  %mul5.i.i162 = fmul float %178, %173
  %179 = tail call float @llvm.fmuladd.f32(float %170, float %177, float %mul5.i.i162)
  %arrayidx7.i.i164 = getelementptr inbounds [4 x float], ptr %posA, i64 0, i64 2
  %180 = load float, ptr %arrayidx7.i.i164, align 8
  %181 = tail call noundef float @llvm.fmuladd.f32(float %176, float %180, float %179)
  %sub = fsub float %polyA.sroa.7.0.copyload, %181
  %cmp85196 = icmp sgt i32 %numVertsIn.0.lcssa, 0
  br i1 %cmp85196, label %for.body86.preheader, label %return

for.body86.preheader:                             ; preds = %for.end67
  %wide.trip.count211 = zext nneg i32 %numVertsIn.0.lcssa to i64
  br label %for.body86

for.body86:                                       ; preds = %for.body86.preheader, %for.inc110
  %indvars.iv208 = phi i64 [ 0, %for.body86.preheader ], [ %indvars.iv.next209, %for.inc110 ]
  %numContactsOut.0198 = phi i32 [ 0, %for.body86.preheader ], [ %numContactsOut.1, %for.inc110 ]
  %arrayidx = getelementptr inbounds %class.b3Vector3, ptr %pVtxIn.0.lcssa, i64 %indvars.iv208
  %182 = load <2 x float>, ptr %arrayidx, align 16
  %183 = extractelement <2 x float> %182, i64 1
  %mul5.i.i167 = fmul float %173, %183
  %184 = extractelement <2 x float> %182, i64 0
  %185 = tail call float @llvm.fmuladd.f32(float %170, float %184, float %mul5.i.i167)
  %arrayidx7.i.i169 = getelementptr inbounds [4 x float], ptr %arrayidx, i64 0, i64 2
  %186 = load float, ptr %arrayidx7.i.i169, align 8
  %187 = tail call noundef float @llvm.fmuladd.f32(float %176, float %186, float %185)
  %add88 = fadd float %sub, %187
  %cmp89.inv = fcmp ole float %add88, %minDist
  %depth.0 = select i1 %cmp89.inv, float %minDist, float %add88
  %cmp92 = icmp slt i32 %numContactsOut.0198, %contactCapacity
  br i1 %cmp92, label %if.then93, label %do.body

if.then93:                                        ; preds = %for.body86
  %cmp94 = fcmp ugt float %depth.0, %maxDist
  br i1 %cmp94, label %for.inc110, label %if.then95

if.then95:                                        ; preds = %if.then93
  %retval.sroa.3.12.vec.insert4.i172 = insertelement <2 x float> poison, float %186, i64 0
  %retval.sroa.3.12.vec.insert.i173 = insertelement <2 x float> %retval.sroa.3.12.vec.insert4.i172, float %depth.0, i64 1
  %inc105 = add nsw i32 %numContactsOut.0198, 1
  %idxprom106 = sext i32 %numContactsOut.0198 to i64
  %arrayidx107 = getelementptr inbounds %class.b3Vector3, ptr %contactsOut, i64 %idxprom106
  store <2 x float> %182, ptr %arrayidx107, align 16
  %ref.tmp98.sroa.2.0.arrayidx107.sroa_idx = getelementptr inbounds i8, ptr %arrayidx107, i64 8
  store <2 x float> %retval.sroa.3.12.vec.insert.i173, ptr %ref.tmp98.sroa.2.0.arrayidx107.sroa_idx, align 8
  br label %for.inc110

do.body:                                          ; preds = %for.body86
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.31, i32 noundef 931)
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.32, i32 noundef %numContactsOut.0198, i32 noundef %contactCapacity)
  br label %for.inc110

for.inc110:                                       ; preds = %do.body, %if.then95, %if.then93
  %numContactsOut.1 = phi i32 [ %inc105, %if.then95 ], [ %numContactsOut.0198, %if.then93 ], [ %numContactsOut.0198, %do.body ]
  %indvars.iv.next209 = add nuw nsw i64 %indvars.iv208, 1
  %exitcond212.not = icmp eq i64 %indvars.iv.next209, %wide.trip.count211
  br i1 %exitcond212.not, label %return, label %for.body86, !llvm.loop !34

return:                                           ; preds = %for.inc110, %entry, %for.end67, %for.end
  %retval.0 = phi i32 [ 0, %for.end ], [ 0, %for.end67 ], [ 0, %entry ], [ %numContactsOut.1, %for.inc110 ]
  ret i32 %retval.0
}

declare void @b3OutputErrorMessageVarArgsInternal(ptr noundef, ...) local_unnamed_addr #16

; Function Attrs: mustprogress nofree nosync nounwind memory(argmem: readwrite) uwtable
define dso_local noundef i32 @_Z15extractManifoldPK9b3Vector3iRS0_P6b3Int4(ptr nocapture noundef readonly %p, i32 noundef %nPoints, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %nearNormal, ptr nocapture noundef %contactIdx) local_unnamed_addr #2 {
entry:
  %cmp = icmp eq i32 %nPoints, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp slt i32 %nPoints, 5
  br i1 %cmp1, label %return, label %for.body.preheader

for.body.preheader:                               ; preds = %if.end
  %spec.store.select = tail call i32 @llvm.smin.i32(i32 %nPoints, i32 64)
  %wide.trip.count = zext nneg i32 %spec.store.select to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %center.sroa.13.0200 = phi <2 x float> [ zeroinitializer, %for.body.preheader ], [ %center.sroa.13.8.vec.insert, %for.body ]
  %center.sroa.0.0199 = phi <2 x float> [ zeroinitializer, %for.body.preheader ], [ %1, %for.body ]
  %arrayidx = getelementptr inbounds %class.b3Vector3, ptr %p, i64 %indvars.iv
  %0 = load <2 x float>, ptr %arrayidx, align 16
  %1 = fadd <2 x float> %center.sroa.0.0199, %0
  %arrayidx6.i = getelementptr inbounds [4 x float], ptr %arrayidx, i64 0, i64 2
  %2 = load float, ptr %arrayidx6.i, align 8
  %center.sroa.13.8.vec.extract = extractelement <2 x float> %center.sroa.13.0200, i64 0
  %add8.i = fadd float %center.sroa.13.8.vec.extract, %2
  %center.sroa.13.8.vec.insert = insertelement <2 x float> %center.sroa.13.0200, float %add8.i, i64 0
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.body25.lr.ph, label %for.body, !llvm.loop !35

for.body25.lr.ph:                                 ; preds = %for.body
  %conv = sitofp i32 %spec.store.select to float
  %div.i = fdiv float 1.000000e+00, %conv
  %3 = extractelement <2 x float> %1, i64 0
  %mul.i.i = fmul float %div.i, %3
  %4 = extractelement <2 x float> %1, i64 1
  %mul3.i.i = fmul float %div.i, %4
  %mul5.i.i = fmul float %div.i, %add8.i
  %5 = load float, ptr %p, align 16
  %sub.i = fsub float %5, %mul.i.i
  %arrayidx2.i = getelementptr inbounds [4 x float], ptr %p, i64 0, i64 1
  %6 = load float, ptr %arrayidx2.i, align 4
  %sub4.i = fsub float %6, %mul3.i.i
  %arrayidx5.i = getelementptr inbounds [4 x float], ptr %p, i64 0, i64 2
  %7 = load float, ptr %arrayidx5.i, align 8
  %sub7.i = fsub float %7, %mul5.i.i
  %arrayidx.i = getelementptr inbounds [4 x float], ptr %nearNormal, i64 0, i64 1
  %8 = load float, ptr %arrayidx.i, align 4
  %arrayidx3.i45 = getelementptr inbounds [4 x float], ptr %nearNormal, i64 0, i64 2
  %9 = load float, ptr %arrayidx3.i45, align 8
  %10 = fneg float %9
  %neg.i = fmul float %sub4.i, %10
  %11 = tail call float @llvm.fmuladd.f32(float %8, float %sub7.i, float %neg.i)
  %12 = load float, ptr %nearNormal, align 16
  %13 = fneg float %12
  %neg11.i = fmul float %sub7.i, %13
  %14 = tail call float @llvm.fmuladd.f32(float %9, float %sub.i, float %neg11.i)
  %15 = fneg float %8
  %neg17.i = fmul float %sub.i, %15
  %16 = tail call float @llvm.fmuladd.f32(float %12, float %sub4.i, float %neg17.i)
  %neg.i56 = fmul float %14, %10
  %17 = tail call float @llvm.fmuladd.f32(float %8, float %16, float %neg.i56)
  %neg11.i57 = fmul float %16, %13
  %18 = tail call float @llvm.fmuladd.f32(float %9, float %11, float %neg11.i57)
  %neg17.i58 = fmul float %11, %15
  %19 = tail call float @llvm.fmuladd.f32(float %12, float %14, float %neg17.i58)
  %mul5.i.i.i.i = fmul float %14, %14
  %20 = tail call float @llvm.fmuladd.f32(float %11, float %11, float %mul5.i.i.i.i)
  %21 = tail call noundef float @llvm.fmuladd.f32(float %16, float %16, float %20)
  %sqrt.i.i = tail call noundef float @llvm.sqrt.f32(float %21)
  %div.i.i = fdiv float 1.000000e+00, %sqrt.i.i
  %mul.i.i.i = fmul float %11, %div.i.i
  %mul3.i.i.i = fmul float %14, %div.i.i
  %mul5.i.i.i = fmul float %16, %div.i.i
  %mul5.i.i.i.i65 = fmul float %18, %18
  %22 = tail call float @llvm.fmuladd.f32(float %17, float %17, float %mul5.i.i.i.i65)
  %23 = tail call noundef float @llvm.fmuladd.f32(float %19, float %19, float %22)
  %sqrt.i.i67 = tail call noundef float @llvm.sqrt.f32(float %23)
  %div.i.i68 = fdiv float 1.000000e+00, %sqrt.i.i67
  %mul.i.i.i69 = fmul float %17, %div.i.i68
  %mul3.i.i.i70 = fmul float %18, %div.i.i68
  %mul5.i.i.i71 = fmul float %19, %div.i.i68
  %fneg.i = fneg float %mul.i.i.i
  %fneg2.i = fneg float %mul3.i.i.i
  %fneg4.i = fneg float %mul5.i.i.i
  %y58 = getelementptr inbounds %struct.anon, ptr %contactIdx, i64 0, i32 1
  %z66 = getelementptr inbounds %struct.anon, ptr %contactIdx, i64 0, i32 2
  %fneg.i102 = fneg float %mul.i.i.i69
  %fneg2.i104 = fneg float %mul3.i.i.i70
  %fneg4.i106 = fneg float %mul5.i.i.i71
  %w78 = getelementptr inbounds %struct.anon, ptr %contactIdx, i64 0, i32 3
  %smax = tail call i32 @llvm.smax.i32(i32 %spec.store.select, i32 1)
  %wide.trip.count216 = zext nneg i32 %smax to i64
  br label %for.body25

for.body25:                                       ; preds = %for.body25.lr.ph, %for.inc80
  %indvars.iv213 = phi i64 [ 0, %for.body25.lr.ph ], [ %indvars.iv.next214, %for.inc80 ]
  %maxDots.sroa.0.0209 = phi float [ 0x3810000000000000, %for.body25.lr.ph ], [ %maxDots.sroa.0.1, %for.inc80 ]
  %maxDots.sroa.3.0208 = phi float [ 0x3810000000000000, %for.body25.lr.ph ], [ %maxDots.sroa.3.1, %for.inc80 ]
  %maxDots.sroa.6.0207 = phi float [ 0x3810000000000000, %for.body25.lr.ph ], [ %maxDots.sroa.6.1, %for.inc80 ]
  %maxDots.sroa.9.0206 = phi float [ 0x3810000000000000, %for.body25.lr.ph ], [ %maxDots.sroa.9.1, %for.inc80 ]
  %minIndex.0205 = phi i32 [ -1, %for.body25.lr.ph ], [ %minIndex.1, %for.inc80 ]
  %minW.0204 = phi float [ 0x47EFFFFFE0000000, %for.body25.lr.ph ], [ %minW.1, %for.inc80 ]
  %arrayidx27 = getelementptr inbounds %class.b3Vector3, ptr %p, i64 %indvars.iv213
  %w28 = getelementptr inbounds %struct.anon.2, ptr %arrayidx27, i64 0, i32 3
  %24 = load float, ptr %w28, align 4
  %cmp29 = fcmp olt float %24, %minW.0204
  %minW.1 = select i1 %cmp29, float %24, float %minW.0204
  %25 = trunc i64 %indvars.iv213 to i32
  %minIndex.1 = select i1 %cmp29, i32 %25, i32 %minIndex.0205
  %26 = load float, ptr %arrayidx27, align 16
  %sub.i72 = fsub float %26, %mul.i.i
  %arrayidx2.i73 = getelementptr inbounds [4 x float], ptr %arrayidx27, i64 0, i64 1
  %27 = load float, ptr %arrayidx2.i73, align 4
  %sub4.i75 = fsub float %27, %mul3.i.i
  %arrayidx5.i76 = getelementptr inbounds [4 x float], ptr %arrayidx27, i64 0, i64 2
  %28 = load float, ptr %arrayidx5.i76, align 8
  %sub7.i78 = fsub float %28, %mul5.i.i
  %mul5.i.i85 = fmul float %mul3.i.i.i, %sub4.i75
  %29 = tail call float @llvm.fmuladd.f32(float %mul.i.i.i, float %sub.i72, float %mul5.i.i85)
  %30 = tail call noundef float @llvm.fmuladd.f32(float %mul5.i.i.i, float %sub7.i78, float %29)
  %cmp42 = fcmp olt float %30, %maxDots.sroa.0.0209
  br i1 %cmp42, label %if.then43, label %if.end47

if.then43:                                        ; preds = %for.body25
  store i32 %25, ptr %contactIdx, align 16
  br label %if.end47

if.end47:                                         ; preds = %if.then43, %for.body25
  %maxDots.sroa.0.1 = phi float [ %30, %if.then43 ], [ %maxDots.sroa.0.0209, %for.body25 ]
  %mul5.i.i94 = fmul float %sub4.i75, %fneg2.i
  %31 = tail call float @llvm.fmuladd.f32(float %fneg.i, float %sub.i72, float %mul5.i.i94)
  %32 = tail call noundef float @llvm.fmuladd.f32(float %fneg4.i, float %sub7.i78, float %31)
  %cmp54 = fcmp olt float %32, %maxDots.sroa.3.0208
  br i1 %cmp54, label %if.then55, label %if.end59

if.then55:                                        ; preds = %if.end47
  store i32 %25, ptr %y58, align 4
  br label %if.end59

if.end59:                                         ; preds = %if.then55, %if.end47
  %maxDots.sroa.3.1 = phi float [ %32, %if.then55 ], [ %maxDots.sroa.3.0208, %if.end47 ]
  %mul5.i.i99 = fmul float %mul3.i.i.i70, %sub4.i75
  %33 = tail call float @llvm.fmuladd.f32(float %mul.i.i.i69, float %sub.i72, float %mul5.i.i99)
  %34 = tail call noundef float @llvm.fmuladd.f32(float %mul5.i.i.i71, float %sub7.i78, float %33)
  %cmp62 = fcmp olt float %34, %maxDots.sroa.6.0207
  br i1 %cmp62, label %if.then63, label %if.end67

if.then63:                                        ; preds = %if.end59
  store i32 %25, ptr %z66, align 8
  br label %if.end67

if.end67:                                         ; preds = %if.then63, %if.end59
  %maxDots.sroa.6.1 = phi float [ %34, %if.then63 ], [ %maxDots.sroa.6.0207, %if.end59 ]
  %mul5.i.i114 = fmul float %sub4.i75, %fneg2.i104
  %35 = tail call float @llvm.fmuladd.f32(float %fneg.i102, float %sub.i72, float %mul5.i.i114)
  %36 = tail call noundef float @llvm.fmuladd.f32(float %fneg4.i106, float %sub7.i78, float %35)
  %cmp74 = fcmp olt float %36, %maxDots.sroa.9.0206
  br i1 %cmp74, label %if.then75, label %for.inc80

if.then75:                                        ; preds = %if.end67
  store i32 %25, ptr %w78, align 4
  br label %for.inc80

for.inc80:                                        ; preds = %if.end67, %if.then75
  %maxDots.sroa.9.1 = phi float [ %36, %if.then75 ], [ %maxDots.sroa.9.0206, %if.end67 ]
  %indvars.iv.next214 = add nuw nsw i64 %indvars.iv213, 1
  %exitcond217.not = icmp eq i64 %indvars.iv.next214, %wide.trip.count216
  br i1 %exitcond217.not, label %for.end82, label %for.body25, !llvm.loop !36

for.end82:                                        ; preds = %for.inc80
  %37 = load i32, ptr %contactIdx, align 16
  %cmp85.not = icmp eq i32 %37, %minIndex.1
  br i1 %cmp85.not, label %return, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.end82
  %y87 = getelementptr inbounds %struct.anon, ptr %contactIdx, i64 0, i32 1
  %38 = load i32, ptr %y87, align 4
  %cmp88.not = icmp eq i32 %38, %minIndex.1
  br i1 %cmp88.not, label %return, label %land.lhs.true89

land.lhs.true89:                                  ; preds = %land.lhs.true
  %z91 = getelementptr inbounds %struct.anon, ptr %contactIdx, i64 0, i32 2
  %39 = load i32, ptr %z91, align 8
  %cmp92.not = icmp eq i32 %39, %minIndex.1
  br i1 %cmp92.not, label %return, label %land.lhs.true93

land.lhs.true93:                                  ; preds = %land.lhs.true89
  %w95 = getelementptr inbounds %struct.anon, ptr %contactIdx, i64 0, i32 3
  %40 = load i32, ptr %w95, align 4
  %cmp96.not = icmp eq i32 %40, %minIndex.1
  br i1 %cmp96.not, label %return, label %if.then97

if.then97:                                        ; preds = %land.lhs.true93
  store i32 %minIndex.1, ptr %contactIdx, align 16
  br label %return

return:                                           ; preds = %for.end82, %land.lhs.true, %land.lhs.true89, %land.lhs.true93, %if.then97, %if.end, %entry
  %retval.0 = phi i32 [ 0, %entry ], [ %nPoints, %if.end ], [ 4, %if.then97 ], [ 4, %land.lhs.true93 ], [ 4, %land.lhs.true89 ], [ 4, %land.lhs.true ], [ 4, %for.end82 ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress uwtable
define dso_local noundef i32 @_Z18clipHullHullSingleiiRK9b3Vector3RK12b3QuaternionS1_S4_iiPK20b3AlignedObjectArrayI15b3RigidBodyDataEPS5_I10b3Contact4ERiRKS5_I22b3ConvexPolyhedronDataESH_RKS5_IS_ESK_RKS5_I9b3GpuFaceERKS5_IiESK_SK_SO_SR_RKS5_I12b3CollidableESV_S1_i(i32 noundef %bodyIndexA, i32 noundef %bodyIndexB, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %posA, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %ornA, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %posB, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %ornB, i32 noundef %collidableIndexA, i32 noundef %collidableIndexB, ptr nocapture noundef readonly %bodyBuf, ptr noundef %globalContactOut, ptr nocapture noundef nonnull align 4 dereferenceable(4) %nContacts, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %hostConvexDataA, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %hostConvexDataB, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %verticesA, ptr nocapture nonnull readnone align 8 %uniqueEdgesA, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %facesA, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %indicesA, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %verticesB, ptr nocapture nonnull readnone align 8 %uniqueEdgesB, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %facesB, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %indicesB, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %hostCollidablesA, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %hostCollidablesB, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %sepNormalWorldSpace, i32 noundef %maxContactCapacity) local_unnamed_addr #5 personality ptr @__gxx_personality_v0 {
entry:
  %retval.i113 = alloca %class.b3Quaternion, align 16
  %retval.i = alloca %class.b3Quaternion, align 16
  %contactsOut = alloca [1024 x %class.b3Vector3], align 16
  %worldVertsB1 = alloca [1024 x %class.b3Vector3], align 16
  %worldVertsB2 = alloca [1024 x %class.b3Vector3], align 16
  %hostNormal = alloca %class.b3Vector3, align 16
  %trA = alloca %class.b3Transform, align 16
  %trB = alloca %class.b3Transform, align 16
  %trAorn = alloca %class.b3Quaternion, align 16
  %trBorn = alloca %class.b3Quaternion, align 16
  %normalOnSurfaceB = alloca %class.b3Vector3, align 16
  %contactIdx = alloca %struct.b3Int4, align 16
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %hostCollidablesA, i64 0, i32 5
  %0 = load ptr, ptr %m_data.i, align 8
  %idxprom.i = sext i32 %collidableIndexA to i64
  %colA.sroa.1.0.call.sroa_idx = getelementptr inbounds %struct.b3Collidable, ptr %0, i64 %idxprom.i, i32 3
  %colA.sroa.1.0.copyload = load i32, ptr %colA.sroa.1.0.call.sroa_idx, align 4
  %m_data.i42 = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %hostConvexDataA, i64 0, i32 5
  %idxprom.i43 = sext i32 %colA.sroa.1.0.copyload to i64
  %m_data.i45 = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %hostCollidablesB, i64 0, i32 5
  %1 = load ptr, ptr %m_data.i45, align 8
  %idxprom.i46 = sext i32 %collidableIndexB to i64
  %colB.sroa.1.0.call2.sroa_idx = getelementptr inbounds %struct.b3Collidable, ptr %1, i64 %idxprom.i46, i32 3
  %colB.sroa.1.0.copyload = load i32, ptr %colB.sroa.1.0.call2.sroa_idx, align 4
  %m_data.i48 = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %hostConvexDataB, i64 0, i32 5
  %idxprom.i49 = sext i32 %colB.sroa.1.0.copyload to i64
  %2 = load <4 x float>, ptr %sepNormalWorldSpace, align 16
  %3 = extractelement <4 x float> %2, i64 2
  %retval.sroa.0.4.vec.insert.i = shufflevector <4 x float> %2, <4 x float> poison, <2 x i32> <i32 0, i32 1>
  %retval.sroa.3.12.vec.insert.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %3, i64 0
  store <2 x float> %retval.sroa.0.4.vec.insert.i, ptr %hostNormal, align 16
  %4 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %hostNormal, i64 0, i32 1
  store <2 x float> %retval.sroa.3.12.vec.insert.i, ptr %4, align 8
  %5 = load <4 x float>, ptr %posA, align 16
  %6 = extractelement <4 x float> %5, i64 2
  %retval.sroa.0.4.vec.insert.i58 = shufflevector <4 x float> %5, <4 x float> poison, <2 x i32> <i32 0, i32 1>
  %retval.sroa.3.12.vec.insert.i59 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %6, i64 0
  %m_origin.i = getelementptr inbounds %class.b3Transform, ptr %trA, i64 0, i32 1
  store <2 x float> %retval.sroa.0.4.vec.insert.i58, ptr %m_origin.i, align 16
  %ref.tmp.sroa.2.0.m_origin.i.sroa_idx = getelementptr inbounds %class.b3Transform, ptr %trA, i64 0, i32 1, i32 0, i32 0, i64 2
  store <2 x float> %retval.sroa.3.12.vec.insert.i59, ptr %ref.tmp.sroa.2.0.m_origin.i.sroa_idx, align 8
  %y16 = getelementptr inbounds %struct.anon.4, ptr %ornA, i64 0, i32 1
  %z17 = getelementptr inbounds %struct.anon.4, ptr %ornA, i64 0, i32 2
  %w = getelementptr inbounds %struct.anon.4, ptr %ornA, i64 0, i32 3
  %7 = load float, ptr %ornA, align 16
  %8 = load float, ptr %y16, align 4
  %9 = load float, ptr %z17, align 8
  %10 = load float, ptr %w, align 4
  %mul4.i.i.i.i = fmul float %8, %8
  %11 = tail call float @llvm.fmuladd.f32(float %7, float %7, float %mul4.i.i.i.i)
  %12 = tail call float @llvm.fmuladd.f32(float %9, float %9, float %11)
  %13 = tail call noundef float @llvm.fmuladd.f32(float %10, float %10, float %12)
  %div.i.i = fdiv float 2.000000e+00, %13
  %mul.i.i = fmul float %7, %div.i.i
  %mul4.i.i = fmul float %8, %div.i.i
  %mul6.i.i = fmul float %9, %div.i.i
  %mul8.i.i = fmul float %10, %mul.i.i
  %mul10.i.i = fmul float %10, %mul4.i.i
  %mul12.i.i = fmul float %10, %mul6.i.i
  %mul14.i.i = fmul float %7, %mul.i.i
  %mul16.i.i = fmul float %7, %mul4.i.i
  %mul18.i.i = fmul float %7, %mul6.i.i
  %mul20.i.i = fmul float %8, %mul4.i.i
  %mul22.i.i = fmul float %8, %mul6.i.i
  %mul24.i.i = fmul float %9, %mul6.i.i
  %add.i.i = fadd float %mul20.i.i, %mul24.i.i
  %sub.i.i = fsub float 1.000000e+00, %add.i.i
  %sub26.i.i = fsub float %mul16.i.i, %mul12.i.i
  %add28.i.i = fadd float %mul18.i.i, %mul10.i.i
  %add30.i.i = fadd float %mul16.i.i, %mul12.i.i
  %add32.i.i = fadd float %mul14.i.i, %mul24.i.i
  %sub33.i.i = fsub float 1.000000e+00, %add32.i.i
  %sub35.i.i = fsub float %mul22.i.i, %mul8.i.i
  %sub37.i.i = fsub float %mul18.i.i, %mul10.i.i
  %add39.i.i = fadd float %mul22.i.i, %mul8.i.i
  %add41.i.i = fadd float %mul14.i.i, %mul20.i.i
  %sub42.i.i = fsub float 1.000000e+00, %add41.i.i
  store float %sub.i.i, ptr %trA, align 16
  %arrayidx2.i.i37.i.i = getelementptr inbounds [4 x float], ptr %trA, i64 0, i64 1
  store float %sub26.i.i, ptr %arrayidx2.i.i37.i.i, align 4
  %arrayidx3.i.i.i.i = getelementptr inbounds [4 x float], ptr %trA, i64 0, i64 2
  store float %add28.i.i, ptr %arrayidx3.i.i.i.i, align 8
  %arrayidx4.i.i.i.i = getelementptr inbounds [4 x float], ptr %trA, i64 0, i64 3
  store float 0.000000e+00, ptr %arrayidx4.i.i.i.i, align 4
  %arrayidx3.i.i.i = getelementptr inbounds [3 x %class.b3Vector3], ptr %trA, i64 0, i64 1
  store float %add30.i.i, ptr %arrayidx3.i.i.i, align 16
  %arrayidx2.i1.i.i.i = getelementptr inbounds [3 x %class.b3Vector3], ptr %trA, i64 0, i64 1, i32 0, i32 0, i64 1
  store float %sub33.i.i, ptr %arrayidx2.i1.i.i.i, align 4
  %arrayidx3.i2.i.i.i = getelementptr inbounds [3 x %class.b3Vector3], ptr %trA, i64 0, i64 1, i32 0, i32 0, i64 2
  store float %sub35.i.i, ptr %arrayidx3.i2.i.i.i, align 8
  %arrayidx4.i3.i.i.i = getelementptr inbounds [3 x %class.b3Vector3], ptr %trA, i64 0, i64 1, i32 0, i32 0, i64 3
  store float 0.000000e+00, ptr %arrayidx4.i3.i.i.i, align 4
  %arrayidx5.i.i.i = getelementptr inbounds [3 x %class.b3Vector3], ptr %trA, i64 0, i64 2
  store float %sub37.i.i, ptr %arrayidx5.i.i.i, align 16
  %arrayidx2.i4.i.i.i = getelementptr inbounds [3 x %class.b3Vector3], ptr %trA, i64 0, i64 2, i32 0, i32 0, i64 1
  store float %add39.i.i, ptr %arrayidx2.i4.i.i.i, align 4
  %arrayidx3.i5.i.i.i = getelementptr inbounds [3 x %class.b3Vector3], ptr %trA, i64 0, i64 2, i32 0, i32 0, i64 2
  store float %sub42.i.i, ptr %arrayidx3.i5.i.i.i, align 8
  %arrayidx4.i6.i.i.i = getelementptr inbounds [3 x %class.b3Vector3], ptr %trA, i64 0, i64 2, i32 0, i32 0, i64 3
  store float 0.000000e+00, ptr %arrayidx4.i6.i.i.i, align 4
  %14 = load <4 x float>, ptr %posB, align 16
  %15 = extractelement <4 x float> %14, i64 2
  %retval.sroa.0.4.vec.insert.i63 = shufflevector <4 x float> %14, <4 x float> poison, <2 x i32> <i32 0, i32 1>
  %retval.sroa.3.12.vec.insert.i64 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %15, i64 0
  %m_origin.i67 = getelementptr inbounds %class.b3Transform, ptr %trB, i64 0, i32 1
  store <2 x float> %retval.sroa.0.4.vec.insert.i63, ptr %m_origin.i67, align 16
  %ref.tmp18.sroa.2.0.m_origin.i67.sroa_idx = getelementptr inbounds %class.b3Transform, ptr %trB, i64 0, i32 1, i32 0, i32 0, i64 2
  store <2 x float> %retval.sroa.3.12.vec.insert.i64, ptr %ref.tmp18.sroa.2.0.m_origin.i67.sroa_idx, align 8
  %y27 = getelementptr inbounds %struct.anon.4, ptr %ornB, i64 0, i32 1
  %z28 = getelementptr inbounds %struct.anon.4, ptr %ornB, i64 0, i32 2
  %w29 = getelementptr inbounds %struct.anon.4, ptr %ornB, i64 0, i32 3
  %16 = load float, ptr %ornB, align 16
  %17 = load float, ptr %y27, align 4
  %18 = load float, ptr %z28, align 8
  %19 = load float, ptr %w29, align 4
  %mul4.i.i.i.i72 = fmul float %17, %17
  %20 = tail call float @llvm.fmuladd.f32(float %16, float %16, float %mul4.i.i.i.i72)
  %21 = tail call float @llvm.fmuladd.f32(float %18, float %18, float %20)
  %22 = tail call noundef float @llvm.fmuladd.f32(float %19, float %19, float %21)
  %div.i.i75 = fdiv float 2.000000e+00, %22
  %mul.i.i76 = fmul float %16, %div.i.i75
  %mul4.i.i77 = fmul float %17, %div.i.i75
  %mul6.i.i78 = fmul float %18, %div.i.i75
  %mul8.i.i79 = fmul float %19, %mul.i.i76
  %mul10.i.i80 = fmul float %19, %mul4.i.i77
  %mul12.i.i81 = fmul float %19, %mul6.i.i78
  %mul14.i.i82 = fmul float %16, %mul.i.i76
  %mul16.i.i83 = fmul float %16, %mul4.i.i77
  %mul18.i.i84 = fmul float %16, %mul6.i.i78
  %mul20.i.i85 = fmul float %17, %mul4.i.i77
  %mul22.i.i86 = fmul float %17, %mul6.i.i78
  %mul24.i.i87 = fmul float %18, %mul6.i.i78
  %add.i.i88 = fadd float %mul20.i.i85, %mul24.i.i87
  %sub.i.i89 = fsub float 1.000000e+00, %add.i.i88
  %sub26.i.i90 = fsub float %mul16.i.i83, %mul12.i.i81
  %add28.i.i91 = fadd float %mul18.i.i84, %mul10.i.i80
  %add30.i.i92 = fadd float %mul16.i.i83, %mul12.i.i81
  %add32.i.i93 = fadd float %mul14.i.i82, %mul24.i.i87
  %sub33.i.i94 = fsub float 1.000000e+00, %add32.i.i93
  %sub35.i.i95 = fsub float %mul22.i.i86, %mul8.i.i79
  %sub37.i.i96 = fsub float %mul18.i.i84, %mul10.i.i80
  %add39.i.i97 = fadd float %mul22.i.i86, %mul8.i.i79
  %add41.i.i98 = fadd float %mul14.i.i82, %mul20.i.i85
  %sub42.i.i99 = fsub float 1.000000e+00, %add41.i.i98
  store float %sub.i.i89, ptr %trB, align 16
  %arrayidx2.i.i37.i.i100 = getelementptr inbounds [4 x float], ptr %trB, i64 0, i64 1
  store float %sub26.i.i90, ptr %arrayidx2.i.i37.i.i100, align 4
  %arrayidx3.i.i.i.i101 = getelementptr inbounds [4 x float], ptr %trB, i64 0, i64 2
  store float %add28.i.i91, ptr %arrayidx3.i.i.i.i101, align 8
  %arrayidx4.i.i.i.i102 = getelementptr inbounds [4 x float], ptr %trB, i64 0, i64 3
  store float 0.000000e+00, ptr %arrayidx4.i.i.i.i102, align 4
  %arrayidx3.i.i.i103 = getelementptr inbounds [3 x %class.b3Vector3], ptr %trB, i64 0, i64 1
  store float %add30.i.i92, ptr %arrayidx3.i.i.i103, align 16
  %arrayidx2.i1.i.i.i104 = getelementptr inbounds [3 x %class.b3Vector3], ptr %trB, i64 0, i64 1, i32 0, i32 0, i64 1
  store float %sub33.i.i94, ptr %arrayidx2.i1.i.i.i104, align 4
  %arrayidx3.i2.i.i.i105 = getelementptr inbounds [3 x %class.b3Vector3], ptr %trB, i64 0, i64 1, i32 0, i32 0, i64 2
  store float %sub35.i.i95, ptr %arrayidx3.i2.i.i.i105, align 8
  %arrayidx4.i3.i.i.i106 = getelementptr inbounds [3 x %class.b3Vector3], ptr %trB, i64 0, i64 1, i32 0, i32 0, i64 3
  store float 0.000000e+00, ptr %arrayidx4.i3.i.i.i106, align 4
  %arrayidx5.i.i.i107 = getelementptr inbounds [3 x %class.b3Vector3], ptr %trB, i64 0, i64 2
  store float %sub37.i.i96, ptr %arrayidx5.i.i.i107, align 16
  %arrayidx2.i4.i.i.i108 = getelementptr inbounds [3 x %class.b3Vector3], ptr %trB, i64 0, i64 2, i32 0, i32 0, i64 1
  store float %add39.i.i97, ptr %arrayidx2.i4.i.i.i108, align 4
  %arrayidx3.i5.i.i.i109 = getelementptr inbounds [3 x %class.b3Vector3], ptr %trB, i64 0, i64 2, i32 0, i32 0, i64 2
  store float %sub42.i.i99, ptr %arrayidx3.i5.i.i.i109, align 8
  %arrayidx4.i6.i.i.i110 = getelementptr inbounds [3 x %class.b3Vector3], ptr %trB, i64 0, i64 2, i32 0, i32 0, i64 3
  store float 0.000000e+00, ptr %arrayidx4.i6.i.i.i110, align 4
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %retval.i)
  call void @_ZNK11b3Matrix3x311getRotationER12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(48) %trA, ptr noundef nonnull align 16 dereferenceable(16) %retval.i)
  %.fca.0.load.i = load <2 x float>, ptr %retval.i, align 16
  %.fca.1.gep.i = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %retval.i, i64 0, i32 1
  %.fca.1.load.i = load <2 x float>, ptr %.fca.1.gep.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %retval.i)
  store <2 x float> %.fca.0.load.i, ptr %trAorn, align 16
  %23 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %trAorn, i64 0, i32 1
  store <2 x float> %.fca.1.load.i, ptr %23, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %retval.i113)
  call void @_ZNK11b3Matrix3x311getRotationER12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(48) %trB, ptr noundef nonnull align 16 dereferenceable(16) %retval.i113)
  %.fca.0.load.i114 = load <2 x float>, ptr %retval.i113, align 16
  %.fca.1.gep.i116 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %retval.i113, i64 0, i32 1
  %.fca.1.load.i117 = load <2 x float>, ptr %.fca.1.gep.i116, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %retval.i113)
  store <2 x float> %.fca.0.load.i114, ptr %trBorn, align 16
  %24 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %trBorn, i64 0, i32 1
  store <2 x float> %.fca.1.load.i117, ptr %24, align 8
  %25 = load ptr, ptr %m_data.i42, align 8
  %arrayidx.i121 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %25, i64 %idxprom.i43
  %26 = load ptr, ptr %m_data.i48, align 8
  %arrayidx.i124 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %26, i64 %idxprom.i49
  %call44 = call fastcc noundef i32 @_ZL19clipHullAgainstHullRK9b3Vector3RK22b3ConvexPolyhedronDataS4_S1_RK12b3QuaternionS1_S7_PS_S8_iffRK20b3AlignedObjectArrayIS_ERKS9_I9b3GpuFaceERKS9_IiESC_SG_SJ_S8_i(ptr noundef nonnull align 16 dereferenceable(16) %hostNormal, ptr noundef nonnull align 16 dereferenceable(96) %arrayidx.i121, ptr noundef nonnull align 16 dereferenceable(96) %arrayidx.i124, ptr noundef nonnull align 16 dereferenceable(16) %m_origin.i, ptr noundef nonnull align 16 dereferenceable(16) %trAorn, ptr noundef nonnull align 16 dereferenceable(16) %m_origin.i67, ptr noundef nonnull align 16 dereferenceable(16) %trBorn, ptr noundef nonnull %worldVertsB1, ptr noundef nonnull %worldVertsB2, i32 noundef 1024, float noundef -1.000000e+00, ptr noundef nonnull align 8 dereferenceable(25) %verticesA, ptr noundef nonnull align 8 dereferenceable(25) %facesA, ptr noundef nonnull align 8 dereferenceable(25) %indicesA, ptr noundef nonnull align 8 dereferenceable(25) %verticesB, ptr noundef nonnull align 8 dereferenceable(25) %facesB, ptr noundef nonnull align 8 dereferenceable(25) %indicesB, ptr noundef nonnull %contactsOut, i32 noundef 1024)
  %cmp = icmp sgt i32 %call44, 0
  br i1 %cmp, label %if.then, label %if.end80

if.then:                                          ; preds = %entry
  call void @b3EnterProfileZone(ptr noundef nonnull @.str.33)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %normalOnSurfaceB, ptr noundef nonnull align 16 dereferenceable(16) %hostNormal, i64 16, i1 false)
  store <4 x i32> <i32 0, i32 1, i32 2, i32 3>, ptr %contactIdx, align 16
  %call50 = call noundef i32 @_Z15extractManifoldPK9b3Vector3iRS0_P6b3Int4(ptr noundef nonnull %contactsOut, i32 noundef %call44, ptr noundef nonnull align 16 dereferenceable(16) %normalOnSurfaceB, ptr noundef nonnull %contactIdx)
  %27 = load i32, ptr %nContacts, align 4
  %cmp51 = icmp slt i32 %27, %maxContactCapacity
  br i1 %cmp51, label %if.then52, label %do.body

if.then52:                                        ; preds = %if.then
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %globalContactOut, i64 0, i32 2
  %28 = load i32, ptr %m_size.i.i, align 4
  %m_capacity.i.i = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %globalContactOut, i64 0, i32 3
  %29 = load i32, ptr %m_capacity.i.i, align 8
  %cmp.i = icmp eq i32 %28, %29
  br i1 %cmp.i, label %if.then.i, label %invoke.cont54

if.then.i:                                        ; preds = %if.then52
  %tobool.not.i.i = icmp eq i32 %28, 0
  %mul.i.i130 = shl nsw i32 %28, 1
  %cond.i.i = select i1 %tobool.not.i.i, i32 1, i32 %mul.i.i130
  invoke void @_ZN20b3AlignedObjectArrayI10b3Contact4E7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %globalContactOut, i32 noundef %cond.i.i)
          to label %.noexc unwind label %lpad

.noexc:                                           ; preds = %if.then.i
  %.pre.i = load i32, ptr %m_size.i.i, align 4
  br label %invoke.cont54

invoke.cont54:                                    ; preds = %.noexc, %if.then52
  %30 = phi i32 [ %.pre.i, %.noexc ], [ %28, %if.then52 ]
  %inc.i = add nsw i32 %30, 1
  store i32 %inc.i, ptr %m_size.i.i, align 4
  %m_data.i127 = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %globalContactOut, i64 0, i32 5
  %31 = load ptr, ptr %m_data.i127, align 8
  %idxprom.i128 = sext i32 %28 to i64
  %arrayidx.i129 = getelementptr inbounds %struct.b3Contact4, ptr %31, i64 %idxprom.i128
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(112) %arrayidx.i129, i8 0, i64 112, i1 false)
  %32 = load ptr, ptr %m_data.i127, align 8
  %33 = load i32, ptr %nContacts, align 4
  %idxprom.i132 = sext i32 %33 to i64
  %arrayidx.i133 = getelementptr inbounds %struct.b3Contact4, ptr %32, i64 %idxprom.i132
  %m_batchIdx = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx.i133, i64 0, i32 4
  store i32 0, ptr %m_batchIdx, align 4
  %m_data.i134 = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %bodyBuf, i64 0, i32 5
  %34 = load ptr, ptr %m_data.i134, align 8
  %idxprom.i135 = sext i32 %bodyIndexA to i64
  %m_invMass = getelementptr inbounds %struct.b3RigidBodyData, ptr %34, i64 %idxprom.i135, i32 5
  %35 = load float, ptr %m_invMass, align 4
  %cmp60 = fcmp oeq float %35, 0.000000e+00
  %sub = sub nsw i32 0, %bodyIndexA
  %cond = select i1 %cmp60, i32 %sub, i32 %bodyIndexA
  %m_bodyAPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx.i133, i64 0, i32 5
  store i32 %cond, ptr %m_bodyAPtrAndSignBit, align 8
  %36 = load ptr, ptr %m_data.i134, align 8
  %idxprom.i138 = sext i32 %bodyIndexB to i64
  %m_invMass63 = getelementptr inbounds %struct.b3RigidBodyData, ptr %36, i64 %idxprom.i138, i32 5
  %37 = load float, ptr %m_invMass63, align 4
  %cmp64 = fcmp oeq float %37, 0.000000e+00
  %sub66 = sub nsw i32 0, %bodyIndexB
  %cond69 = select i1 %cmp64, i32 %sub66, i32 %bodyIndexB
  %m_bodyBPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx.i133, i64 0, i32 6
  store i32 %cond69, ptr %m_bodyBPtrAndSignBit, align 4
  %m_frictionCoeffCmp = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx.i133, i64 0, i32 3
  store i16 -19662, ptr %m_frictionCoeffCmp, align 2
  %m_restituitionCoeffCmp = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx.i133, i64 0, i32 2
  store i16 0, ptr %m_restituitionCoeffCmp, align 16
  %cmp70142 = icmp sgt i32 %call50, 0
  br i1 %cmp70142, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %invoke.cont54
  %m_worldNormalOnB = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx.i133, i64 0, i32 1
  %wide.trip.count = zext nneg i32 %call50 to i64
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr inbounds [4 x i32], ptr %contactIdx, i64 0, i64 %indvars.iv
  %38 = load i32, ptr %arrayidx, align 4
  %idxprom71 = sext i32 %38 to i64
  %arrayidx72 = getelementptr inbounds [1024 x %class.b3Vector3], ptr %contactsOut, i64 0, i64 %idxprom71
  %arrayidx74 = getelementptr inbounds [4 x %class.b3Vector3], ptr %arrayidx.i133, i64 0, i64 %indvars.iv
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx74, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx72, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %m_worldNormalOnB, ptr noundef nonnull align 16 dereferenceable(16) %hostNormal, i64 16, i1 false)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !37

lpad:                                             ; preds = %if.then.i, %invoke.cont78, %do.body
  %39 = landingpad { ptr, i32 }
          cleanup
  invoke void @b3LeaveProfileZone()
          to label %_ZN13b3ProfileZoneD2Ev.exit unwind label %terminate.lpad.i

terminate.lpad.i:                                 ; preds = %lpad
  %40 = landingpad { ptr, i32 }
          catch ptr null
  %41 = extractvalue { ptr, i32 } %40, 0
  call void @__clang_call_terminate(ptr %41) #27
  unreachable

_ZN13b3ProfileZoneD2Ev.exit:                      ; preds = %lpad
  resume { ptr, i32 } %39

for.end:                                          ; preds = %for.body, %invoke.cont54
  %conv = sitofp i32 %call50 to float
  %w76 = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx.i133, i64 0, i32 1, i32 0, i32 0, i64 3
  store float %conv, ptr %w76, align 4
  %42 = load i32, ptr %nContacts, align 4
  %inc77 = add nsw i32 %42, 1
  store i32 %inc77, ptr %nContacts, align 4
  br label %if.end

do.body:                                          ; preds = %if.then
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.31, i32 noundef 1265)
          to label %invoke.cont78 unwind label %lpad

invoke.cont78:                                    ; preds = %do.body
  %43 = load i32, ptr %nContacts, align 4
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.34, i32 noundef %43, i32 noundef %maxContactCapacity)
          to label %if.end unwind label %lpad

if.end:                                           ; preds = %invoke.cont78, %for.end
  %contactIndex.0 = phi i32 [ %27, %for.end ], [ -1, %invoke.cont78 ]
  invoke void @b3LeaveProfileZone()
          to label %if.end80 unwind label %terminate.lpad.i140

terminate.lpad.i140:                              ; preds = %if.end
  %44 = landingpad { ptr, i32 }
          catch ptr null
  %45 = extractvalue { ptr, i32 } %44, 0
  call void @__clang_call_terminate(ptr %45) #27
  unreachable

if.end80:                                         ; preds = %if.end, %entry
  %contactIndex.1 = phi i32 [ -1, %entry ], [ %contactIndex.0, %if.end ]
  ret i32 %contactIndex.1
}

; Function Attrs: mustprogress uwtable
define internal fastcc noundef i32 @_ZL19clipHullAgainstHullRK9b3Vector3RK22b3ConvexPolyhedronDataS4_S1_RK12b3QuaternionS1_S7_PS_S8_iffRK20b3AlignedObjectArrayIS_ERKS9_I9b3GpuFaceERKS9_IiESC_SG_SJ_S8_i(ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %separatingNormal, ptr nocapture noundef nonnull readonly align 16 dereferenceable(96) %hullA, ptr nocapture noundef nonnull readonly align 16 dereferenceable(96) %hullB, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %posA, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %ornA, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %posB, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %ornB, ptr nocapture noundef %worldVertsB1, ptr nocapture noundef %worldVertsB2, i32 noundef %capacityWorldVerts, float noundef %minDist, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %verticesA, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %facesA, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %indicesA, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %verticesB, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %facesB, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %indicesB, ptr nocapture noundef writeonly %contactsOut, i32 noundef %contactCapacity) unnamed_addr #5 personality ptr @__gxx_personality_v0 {
entry:
  tail call void @b3EnterProfileZone(ptr noundef nonnull @.str.72)
  %m_numFaces = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullB, i64 0, i32 6
  %0 = load i32, ptr %m_numFaces, align 8
  %cmp241 = icmp sgt i32 %0, 0
  %m_faceOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullB, i64 0, i32 5
  %1 = load i32, ptr %m_faceOffset, align 4
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %facesB, i64 0, i32 5
  %2 = load ptr, ptr %m_data.i, align 8
  br i1 %cmp241, label %invoke.cont19.lr.ph, label %for.end

invoke.cont19.lr.ph:                              ; preds = %entry
  %arrayidx.i.i.i = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 3
  %3 = load float, ptr %arrayidx.i.i.i, align 4
  %arrayidx.i23.i.i = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 1
  %4 = load float, ptr %arrayidx.i23.i.i, align 4
  %arrayidx.i25.i.i = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 2
  %5 = load float, ptr %arrayidx.i25.i.i, align 8
  %neg.i.i = fneg float %5
  %6 = load float, ptr %ornB, align 16
  %neg15.i.i = fneg float %6
  %neg24.i.i = fneg float %4
  %7 = load float, ptr %separatingNormal, align 16
  %arrayidx4.i.i = getelementptr inbounds [4 x float], ptr %separatingNormal, i64 0, i64 1
  %8 = load float, ptr %arrayidx4.i.i, align 4
  %arrayidx7.i.i = getelementptr inbounds [4 x float], ptr %separatingNormal, i64 0, i64 2
  %9 = load float, ptr %arrayidx7.i.i, align 8
  %10 = sext i32 %1 to i64
  %wide.trip.count = zext nneg i32 %0 to i64
  %invariant.gep = getelementptr %struct.b3GpuFace, ptr %2, i64 %10
  br label %invoke.cont19

invoke.cont19:                                    ; preds = %invoke.cont19.lr.ph, %invoke.cont19
  %indvars.iv = phi i64 [ 0, %invoke.cont19.lr.ph ], [ %indvars.iv.next, %invoke.cont19 ]
  %closestFaceB.044 = phi i32 [ -1, %invoke.cont19.lr.ph ], [ %closestFaceB.1, %invoke.cont19 ]
  %dmax.043 = phi float [ 0xC7EFFFFFE0000000, %invoke.cont19.lr.ph ], [ %dmax.1, %invoke.cont19 ]
  %gep = getelementptr %struct.b3GpuFace, ptr %invariant.gep, i64 %indvars.iv
  %11 = load float, ptr %gep, align 16
  %y = getelementptr inbounds %struct.anon.2, ptr %gep, i64 0, i32 1
  %12 = load float, ptr %y, align 4
  %z = getelementptr inbounds %struct.anon.2, ptr %gep, i64 0, i32 2
  %13 = load float, ptr %z, align 8
  %mul4.i.i = fmul float %13, %4
  %14 = tail call float @llvm.fmuladd.f32(float %3, float %11, float %mul4.i.i)
  %15 = tail call float @llvm.fmuladd.f32(float %neg.i.i, float %12, float %14)
  %mul12.i.i = fmul float %11, %5
  %16 = tail call float @llvm.fmuladd.f32(float %3, float %12, float %mul12.i.i)
  %17 = tail call float @llvm.fmuladd.f32(float %neg15.i.i, float %13, float %16)
  %mul21.i.i = fmul float %12, %6
  %18 = tail call float @llvm.fmuladd.f32(float %3, float %13, float %mul21.i.i)
  %19 = tail call float @llvm.fmuladd.f32(float %neg24.i.i, float %11, float %18)
  %neg31.i.i = fmul float %12, %neg24.i.i
  %20 = tail call float @llvm.fmuladd.f32(float %neg15.i.i, float %11, float %neg31.i.i)
  %21 = tail call float @llvm.fmuladd.f32(float %neg.i.i, float %13, float %20)
  %mul4.i9.i = fmul float %3, %15
  %22 = tail call float @llvm.fmuladd.f32(float %21, float %neg15.i.i, float %mul4.i9.i)
  %23 = tail call float @llvm.fmuladd.f32(float %17, float %neg.i.i, float %22)
  %24 = tail call float @llvm.fmuladd.f32(float %19, float %4, float %23)
  %mul14.i.i = fmul float %3, %17
  %25 = tail call float @llvm.fmuladd.f32(float %21, float %neg24.i.i, float %mul14.i.i)
  %26 = tail call float @llvm.fmuladd.f32(float %19, float %neg15.i.i, float %25)
  %27 = tail call float @llvm.fmuladd.f32(float %15, float %5, float %26)
  %mul25.i.i = fmul float %3, %19
  %28 = tail call float @llvm.fmuladd.f32(float %21, float %neg.i.i, float %mul25.i.i)
  %29 = tail call float @llvm.fmuladd.f32(float %15, float %neg24.i.i, float %28)
  %30 = tail call float @llvm.fmuladd.f32(float %17, float %6, float %29)
  %mul5.i.i = fmul float %8, %27
  %31 = tail call float @llvm.fmuladd.f32(float %24, float %7, float %mul5.i.i)
  %32 = tail call noundef float @llvm.fmuladd.f32(float %30, float %9, float %31)
  %cmp21 = fcmp ogt float %32, %dmax.043
  %dmax.1 = select i1 %cmp21, float %32, float %dmax.043
  %33 = trunc i64 %indvars.iv to i32
  %closestFaceB.1 = select i1 %cmp21, i32 %33, i32 %closestFaceB.044
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %invoke.cont19, !llvm.loop !38

lpad:                                             ; preds = %if.then46
  %34 = landingpad { ptr, i32 }
          cleanup
  invoke void @b3LeaveProfileZone()
          to label %_ZN13b3ProfileZoneD2Ev.exit unwind label %terminate.lpad.i

terminate.lpad.i:                                 ; preds = %lpad
  %35 = landingpad { ptr, i32 }
          catch ptr null
  %36 = extractvalue { ptr, i32 } %35, 0
  tail call void @__clang_call_terminate(ptr %36) #27
  unreachable

_ZN13b3ProfileZoneD2Ev.exit:                      ; preds = %lpad
  resume { ptr, i32 } %34

for.end:                                          ; preds = %invoke.cont19, %entry
  %closestFaceB.0.lcssa = phi i32 [ -1, %entry ], [ %closestFaceB.1, %invoke.cont19 ]
  %add25 = add nsw i32 %1, %closestFaceB.0.lcssa
  %idxprom.i31 = sext i32 %add25 to i64
  %m_numIndices = getelementptr inbounds %struct.b3GpuFace, ptr %2, i64 %idxprom.i31, i32 2
  %37 = load i32, ptr %m_numIndices, align 4
  %cmp2945 = icmp sgt i32 %37, 0
  br i1 %cmp2945, label %invoke.cont37.lr.ph, label %for.end44

invoke.cont37.lr.ph:                              ; preds = %for.end
  %m_vertexOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullB, i64 0, i32 8
  %m_indexOffset = getelementptr inbounds %struct.b3GpuFace, ptr %2, i64 %idxprom.i31, i32 1
  %m_data.i33 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %indicesB, i64 0, i32 5
  %m_data.i36 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %verticesB, i64 0, i32 5
  %tr.sroa.29.48.pos.sroa_idx.i = getelementptr inbounds i8, ptr %posB, i64 4
  %tr.sroa.30.48.pos.sroa_idx.i = getelementptr inbounds i8, ptr %posB, i64 8
  %arrayidx5.i.i.i.i.i = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 2
  %arrayidx7.i.i.i.i.i = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 3
  %wide.trip.count56 = zext nneg i32 %37 to i64
  br label %invoke.cont37

invoke.cont37:                                    ; preds = %invoke.cont37.lr.ph, %invoke.cont37
  %indvars.iv51 = phi i64 [ 0, %invoke.cont37.lr.ph ], [ %indvars.iv.next52, %invoke.cont37 ]
  %indvars55 = trunc i64 %indvars.iv51 to i32
  %38 = load i32, ptr %m_vertexOffset, align 16
  %39 = load i32, ptr %m_indexOffset, align 16
  %add31 = add nsw i32 %39, %indvars55
  %40 = load ptr, ptr %m_data.i33, align 8
  %idxprom.i34 = sext i32 %add31 to i64
  %arrayidx.i35 = getelementptr inbounds i32, ptr %40, i64 %idxprom.i34
  %41 = load i32, ptr %arrayidx.i35, align 4
  %add34 = add nsw i32 %41, %38
  %42 = load ptr, ptr %m_data.i36, align 8
  %idxprom.i37 = sext i32 %add34 to i64
  %arrayidx.i38 = getelementptr inbounds %class.b3Vector3, ptr %42, i64 %idxprom.i37
  %tr.sroa.27.48.copyload.i = load float, ptr %posB, align 16
  %tr.sroa.29.48.copyload.i = load float, ptr %tr.sroa.29.48.pos.sroa_idx.i, align 4
  %tr.sroa.30.48.copyload.i = load float, ptr %tr.sroa.30.48.pos.sroa_idx.i, align 8
  %43 = load float, ptr %arrayidx5.i.i.i.i.i, align 8
  %44 = load float, ptr %arrayidx7.i.i.i.i.i, align 4
  %45 = load <2 x float>, ptr %ornB, align 16
  %46 = extractelement <2 x float> %45, i64 1
  %mul4.i.i.i.i.i = fmul float %46, %46
  %47 = extractelement <2 x float> %45, i64 0
  %48 = tail call float @llvm.fmuladd.f32(float %47, float %47, float %mul4.i.i.i.i.i)
  %49 = tail call float @llvm.fmuladd.f32(float %43, float %43, float %48)
  %50 = tail call noundef float @llvm.fmuladd.f32(float %44, float %44, float %49)
  %div.i.i.i = fdiv float 2.000000e+00, %50
  %51 = insertelement <2 x float> poison, float %div.i.i.i, i64 0
  %52 = shufflevector <2 x float> %51, <2 x float> poison, <2 x i32> zeroinitializer
  %53 = fmul <2 x float> %45, %52
  %mul6.i.i.i = fmul float %43, %div.i.i.i
  %54 = extractelement <2 x float> %53, i64 0
  %mul8.i.i.i = fmul float %44, %54
  %55 = extractelement <2 x float> %53, i64 1
  %mul10.i.i.i = fmul float %44, %55
  %mul12.i.i.i = fmul float %44, %mul6.i.i.i
  %mul16.i.i.i = fmul float %47, %55
  %mul18.i.i.i = fmul float %47, %mul6.i.i.i
  %56 = fmul <2 x float> %45, %53
  %mul22.i.i.i = fmul float %46, %mul6.i.i.i
  %mul24.i.i.i = fmul float %43, %mul6.i.i.i
  %57 = extractelement <2 x float> %56, i64 1
  %add.i.i.i = fadd float %57, %mul24.i.i.i
  %sub.i.i.i = fsub float 1.000000e+00, %add.i.i.i
  %sub26.i.i.i = fsub float %mul16.i.i.i, %mul12.i.i.i
  %add28.i.i.i = fadd float %mul18.i.i.i, %mul10.i.i.i
  %add30.i.i.i = fadd float %mul16.i.i.i, %mul12.i.i.i
  %58 = extractelement <2 x float> %56, i64 0
  %add32.i.i.i = fadd float %58, %mul24.i.i.i
  %sub33.i.i.i = fsub float 1.000000e+00, %add32.i.i.i
  %sub35.i.i.i = fsub float %mul22.i.i.i, %mul8.i.i.i
  %sub37.i.i.i = fsub float %mul18.i.i.i, %mul10.i.i.i
  %add39.i.i.i = fadd float %mul22.i.i.i, %mul8.i.i.i
  %add41.i.i.i = fadd float %58, %57
  %sub42.i.i.i = fsub float 1.000000e+00, %add41.i.i.i
  %59 = load float, ptr %arrayidx.i38, align 16
  %arrayidx3.i.i.i6.i = getelementptr inbounds [4 x float], ptr %arrayidx.i38, i64 0, i64 1
  %60 = load float, ptr %arrayidx3.i.i.i6.i, align 4
  %mul5.i.i.i.i = fmul float %60, %sub26.i.i.i
  %61 = tail call float @llvm.fmuladd.f32(float %59, float %sub.i.i.i, float %mul5.i.i.i.i)
  %arrayidx6.i.i.i.i = getelementptr inbounds [4 x float], ptr %arrayidx.i38, i64 0, i64 2
  %62 = load float, ptr %arrayidx6.i.i.i.i, align 8
  %63 = tail call noundef float @llvm.fmuladd.f32(float %62, float %add28.i.i.i, float %61)
  %mul5.i3.i.i.i = fmul float %60, %sub33.i.i.i
  %64 = tail call float @llvm.fmuladd.f32(float %59, float %add30.i.i.i, float %mul5.i3.i.i.i)
  %65 = tail call noundef float @llvm.fmuladd.f32(float %62, float %sub35.i.i.i, float %64)
  %mul5.i8.i.i.i = fmul float %60, %add39.i.i.i
  %66 = tail call float @llvm.fmuladd.f32(float %59, float %sub37.i.i.i, float %mul5.i8.i.i.i)
  %67 = tail call noundef float @llvm.fmuladd.f32(float %62, float %sub42.i.i.i, float %66)
  %add.i.i8.i = fadd float %tr.sroa.27.48.copyload.i, %63
  %add4.i.i.i = fadd float %tr.sroa.29.48.copyload.i, %65
  %add7.i.i.i = fadd float %tr.sroa.30.48.copyload.i, %67
  %retval.sroa.0.0.vec.insert.i.i2.i.i = insertelement <2 x float> poison, float %add.i.i8.i, i64 0
  %retval.sroa.0.4.vec.insert.i.i3.i.i = insertelement <2 x float> %retval.sroa.0.0.vec.insert.i.i2.i.i, float %add4.i.i.i, i64 1
  %retval.sroa.3.12.vec.insert.i.i4.i.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %add7.i.i.i, i64 0
  %indvars.iv.next52 = add nuw nsw i64 %indvars.iv51, 1
  %arrayidx = getelementptr inbounds %class.b3Vector3, ptr %worldVertsB1, i64 %indvars.iv51
  store <2 x float> %retval.sroa.0.4.vec.insert.i.i3.i.i, ptr %arrayidx, align 16
  %ref.tmp.sroa.2.0.arrayidx.sroa_idx = getelementptr inbounds i8, ptr %arrayidx, i64 8
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i4.i.i, ptr %ref.tmp.sroa.2.0.arrayidx.sroa_idx, align 8
  %exitcond57.not = icmp eq i64 %indvars.iv.next52, %wide.trip.count56
  br i1 %exitcond57.not, label %for.end44, label %invoke.cont37, !llvm.loop !39

for.end44:                                        ; preds = %invoke.cont37, %for.end
  %numWorldVertsB1.0.lcssa = phi i32 [ 0, %for.end ], [ %37, %invoke.cont37 ]
  %cmp45 = icmp sgt i32 %closestFaceB.0.lcssa, -1
  br i1 %cmp45, label %if.then46, label %if.end49

if.then46:                                        ; preds = %for.end44
  %call48 = invoke noundef i32 @_Z19clipFaceAgainstHullRK9b3Vector3PK22b3ConvexPolyhedronDataS1_RK12b3QuaternionPS_iS8_iffRK20b3AlignedObjectArrayIS_ERKS9_I9b3GpuFaceERKS9_IiES8_i(ptr noundef nonnull align 16 dereferenceable(16) %separatingNormal, ptr noundef nonnull %hullA, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef %worldVertsB1, i32 noundef %numWorldVertsB1.0.lcssa, ptr noundef %worldVertsB2, i32 poison, float noundef %minDist, float noundef 0.000000e+00, ptr noundef nonnull align 8 dereferenceable(25) %verticesA, ptr noundef nonnull align 8 dereferenceable(25) %facesA, ptr noundef nonnull align 8 dereferenceable(25) %indicesA, ptr noundef %contactsOut, i32 noundef %contactCapacity)
          to label %if.end49 unwind label %lpad

if.end49:                                         ; preds = %if.then46, %for.end44
  %numContactsOut.0 = phi i32 [ 0, %for.end44 ], [ %call48, %if.then46 ]
  invoke void @b3LeaveProfileZone()
          to label %_ZN13b3ProfileZoneD2Ev.exit40 unwind label %terminate.lpad.i39

terminate.lpad.i39:                               ; preds = %if.end49
  %68 = landingpad { ptr, i32 }
          catch ptr null
  %69 = extractvalue { ptr, i32 } %68, 0
  tail call void @__clang_call_terminate(ptr %69) #27
  unreachable

_ZN13b3ProfileZoneD2Ev.exit40:                    ; preds = %if.end49
  ret i32 %numContactsOut.0
}

; Function Attrs: mustprogress nofree nosync nounwind memory(argmem: readwrite) uwtable
define dso_local void @_Z25computeContactPlaneConvexiiiiiPK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataPK9b3Vector3PKiPK9b3GpuFaceP10b3Contact4Rii(i32 noundef %pairIndex, i32 noundef %bodyIndexA, i32 noundef %bodyIndexB, i32 noundef %collidableIndexA, i32 noundef %collidableIndexB, ptr nocapture noundef readonly %rigidBodies, ptr nocapture noundef readonly %collidables, ptr nocapture noundef readonly %convexShapes, ptr nocapture noundef readonly %convexVertices, ptr nocapture noundef readnone %convexIndices, ptr nocapture noundef readonly %faces, ptr nocapture noundef writeonly %globalContactsOut, ptr nocapture noundef nonnull align 4 dereferenceable(4) %nGlobalContactsOut, i32 noundef %maxContactCapacity) local_unnamed_addr #2 {
entry:
  %planeNormalInConvex = alloca %class.b3Vector3, align 16
  %contactPoints = alloca [64 x %class.b3Vector3], align 16
  %contactIdx = alloca %struct.b3Int4, align 16
  %idxprom = sext i32 %collidableIndexB to i64
  %0 = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom, i32 3
  %1 = load i32, ptr %0, align 4
  %idxprom1 = sext i32 %1 to i64
  %idxprom3 = sext i32 %bodyIndexB to i64
  %arrayidx4 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom3
  %posB.sroa.0.0.copyload = load float, ptr %arrayidx4, align 16
  %posB.sroa.2.0.arrayidx4.sroa_idx = getelementptr inbounds i8, ptr %arrayidx4, i64 4
  %posB.sroa.2.0.copyload = load float, ptr %posB.sroa.2.0.arrayidx4.sroa_idx, align 4
  %posB.sroa.3.0.arrayidx4.sroa_idx = getelementptr inbounds i8, ptr %arrayidx4, i64 8
  %posB.sroa.3.0.copyload = load float, ptr %posB.sroa.3.0.arrayidx4.sroa_idx, align 8
  %m_quat = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom3, i32 1
  %ornB.sroa.3.0.m_quat.sroa_idx = getelementptr inbounds i8, ptr %m_quat, i64 8
  %ornB.sroa.3.0.copyload = load float, ptr %ornB.sroa.3.0.m_quat.sroa_idx, align 8
  %ornB.sroa.4.0.m_quat.sroa_idx = getelementptr inbounds i8, ptr %m_quat, i64 12
  %ornB.sroa.4.0.copyload = load float, ptr %ornB.sroa.4.0.m_quat.sroa_idx, align 4
  %idxprom7 = sext i32 %bodyIndexA to i64
  %arrayidx8 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom7
  %posA.sroa.0.0.copyload = load float, ptr %arrayidx8, align 16
  %posA.sroa.2.0.arrayidx8.sroa_idx = getelementptr inbounds i8, ptr %arrayidx8, i64 4
  %posA.sroa.2.0.copyload = load float, ptr %posA.sroa.2.0.arrayidx8.sroa_idx, align 4
  %posA.sroa.3.0.arrayidx8.sroa_idx = getelementptr inbounds i8, ptr %arrayidx8, i64 8
  %posA.sroa.3.0.copyload = load float, ptr %posA.sroa.3.0.arrayidx8.sroa_idx, align 8
  %m_quat12 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom7, i32 1
  %ornA.sroa.0.0.copyload = load float, ptr %m_quat12, align 16
  %ornA.sroa.3.0.m_quat12.sroa_idx = getelementptr inbounds i8, ptr %m_quat12, i64 4
  %ornA.sroa.7.0.m_quat12.sroa_idx = getelementptr inbounds i8, ptr %m_quat12, i64 12
  %ornA.sroa.7.0.copyload = load float, ptr %ornA.sroa.7.0.m_quat12.sroa_idx, align 4
  %idxprom13 = sext i32 %collidableIndexA to i64
  %2 = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom13, i32 3
  %3 = load i32, ptr %2, align 4
  %idxprom15 = sext i32 %3 to i64
  %arrayidx16 = getelementptr inbounds %struct.b3GpuFace, ptr %faces, i64 %idxprom15
  %planeEq.sroa.3.0.m_plane.sroa_idx = getelementptr inbounds i8, ptr %arrayidx16, i64 8
  %planeEq.sroa.3.0.copyload = load float, ptr %planeEq.sroa.3.0.m_plane.sroa_idx, align 8
  %planeEq.sroa.4.0.m_plane.sroa_idx = getelementptr inbounds i8, ptr %arrayidx16, i64 12
  %planeEq.sroa.4.0.copyload = load float, ptr %planeEq.sroa.4.0.m_plane.sroa_idx, align 4
  %neg15.i.i = fneg float %ornA.sroa.0.0.copyload
  %4 = load <2 x float>, ptr %ornA.sroa.3.0.m_quat12.sroa_idx, align 4
  %5 = load <2 x float>, ptr %arrayidx16, align 16
  %6 = extractelement <2 x float> %4, i64 1
  %7 = extractelement <2 x float> %5, i64 0
  %mul12.i.i = fmul float %6, %7
  %8 = extractelement <2 x float> %5, i64 1
  %9 = tail call float @llvm.fmuladd.f32(float %ornA.sroa.7.0.copyload, float %8, float %mul12.i.i)
  %10 = tail call float @llvm.fmuladd.f32(float %neg15.i.i, float %planeEq.sroa.3.0.copyload, float %9)
  %11 = insertelement <2 x float> %4, float %ornA.sroa.0.0.copyload, i64 1
  %12 = insertelement <2 x float> %5, float %planeEq.sroa.3.0.copyload, i64 0
  %13 = fmul <2 x float> %11, %12
  %14 = insertelement <2 x float> poison, float %ornA.sroa.7.0.copyload, i64 0
  %15 = shufflevector <2 x float> %14, <2 x float> poison, <2 x i32> zeroinitializer
  %16 = insertelement <2 x float> %5, float %planeEq.sroa.3.0.copyload, i64 1
  %17 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %15, <2 x float> %16, <2 x float> %13)
  %18 = shufflevector <2 x float> %17, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %19 = fneg <2 x float> %4
  %20 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %19, <2 x float> %5, <2 x float> %18)
  %21 = extractelement <2 x float> %19, i64 0
  %neg31.i.i = fmul float %8, %21
  %22 = tail call float @llvm.fmuladd.f32(float %neg15.i.i, float %7, float %neg31.i.i)
  %23 = extractelement <2 x float> %19, i64 1
  %24 = tail call float @llvm.fmuladd.f32(float %23, float %planeEq.sroa.3.0.copyload, float %22)
  %25 = shufflevector <2 x float> %20, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %26 = insertelement <2 x float> %25, float %10, i64 1
  %27 = fmul <2 x float> %15, %26
  %28 = insertelement <2 x float> poison, float %24, i64 0
  %29 = shufflevector <2 x float> %28, <2 x float> poison, <2 x i32> zeroinitializer
  %30 = shufflevector <2 x float> %19, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %31 = insertelement <2 x float> %30, float %neg15.i.i, i64 0
  %32 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %29, <2 x float> %31, <2 x float> %27)
  %33 = shufflevector <2 x float> %26, <2 x float> %20, <2 x i32> <i32 1, i32 2>
  %34 = shufflevector <2 x float> %19, <2 x float> %31, <2 x i32> <i32 1, i32 2>
  %35 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %33, <2 x float> %34, <2 x float> %32)
  %36 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %20, <2 x float> %4, <2 x float> %35)
  %37 = extractelement <2 x float> %20, i64 0
  %mul25.i.i = fmul float %ornA.sroa.7.0.copyload, %37
  %38 = tail call float @llvm.fmuladd.f32(float %24, float %23, float %mul25.i.i)
  %39 = extractelement <2 x float> %20, i64 1
  %40 = tail call float @llvm.fmuladd.f32(float %39, float %21, float %38)
  %41 = tail call float @llvm.fmuladd.f32(float %10, float %ornA.sroa.0.0.copyload, float %40)
  %42 = load <2 x float>, ptr %m_quat, align 16
  %43 = extractelement <2 x float> %42, i64 0
  %44 = extractelement <2 x float> %4, i64 0
  %45 = shufflevector <2 x float> %42, <2 x float> %4, <2 x i32> <i32 1, i32 2>
  %46 = fmul <2 x float> %45, %45
  %47 = insertelement <2 x float> %42, float %ornA.sroa.0.0.copyload, i64 1
  %48 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %47, <2 x float> %47, <2 x float> %46)
  %49 = insertelement <2 x float> %4, float %ornB.sroa.3.0.copyload, i64 0
  %50 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %49, <2 x float> %49, <2 x float> %48)
  %51 = insertelement <2 x float> poison, float %ornB.sroa.4.0.copyload, i64 0
  %52 = insertelement <2 x float> %51, float %ornA.sroa.7.0.copyload, i64 1
  %53 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %52, <2 x float> %52, <2 x float> %50)
  %54 = fdiv <2 x float> <float 2.000000e+00, float 2.000000e+00>, %53
  %55 = shufflevector <2 x float> %54, <2 x float> poison, <2 x i32> zeroinitializer
  %56 = fmul <2 x float> %42, %55
  %57 = extractelement <2 x float> %56, i64 1
  %mul10.i.i = fmul float %ornB.sroa.4.0.copyload, %57
  %58 = fmul <2 x float> %49, %54
  %59 = extractelement <2 x float> %58, i64 0
  %mul12.i.i44 = fmul float %ornB.sroa.4.0.copyload, %59
  %mul16.i.i = fmul float %43, %57
  %60 = fmul <2 x float> %42, %58
  %mul18.i.i = extractelement <2 x float> %60, i64 0
  %61 = fmul <2 x float> %42, %56
  %mul24.i.i = fmul float %ornB.sroa.3.0.copyload, %59
  %62 = extractelement <2 x float> %61, i64 1
  %add.i.i = fadd float %62, %mul24.i.i
  %sub.i.i = fsub float 1.000000e+00, %add.i.i
  %sub26.i.i = fsub float %mul16.i.i, %mul12.i.i44
  %add28.i.i = fadd float %mul18.i.i, %mul10.i.i
  %add30.i.i = fadd float %mul16.i.i, %mul12.i.i44
  %63 = extractelement <2 x float> %61, i64 0
  %add32.i.i = fadd float %63, %mul24.i.i
  %sub33.i.i = fsub float 1.000000e+00, %add32.i.i
  %sub37.i.i = fsub float %mul18.i.i, %mul10.i.i
  %64 = extractelement <2 x float> %54, i64 1
  %mul.i.i61 = fmul float %ornA.sroa.0.0.copyload, %64
  %65 = insertelement <2 x float> %56, float %mul.i.i61, i64 1
  %66 = fmul <2 x float> %52, %65
  %67 = fmul <2 x float> %45, %58
  %68 = fadd <2 x float> %67, %66
  %add39.i.i = extractelement <2 x float> %68, i64 0
  %add41.i.i = fadd float %63, %62
  %sub42.i.i = fsub float 1.000000e+00, %add41.i.i
  %mul4.i.i62 = fmul float %44, %64
  %mul10.i.i65 = fmul float %ornA.sroa.7.0.copyload, %mul4.i.i62
  %69 = extractelement <2 x float> %58, i64 1
  %mul12.i.i66 = fmul float %ornA.sroa.7.0.copyload, %69
  %mul14.i.i67 = fmul float %ornA.sroa.0.0.copyload, %mul.i.i61
  %mul16.i.i68 = fmul float %ornA.sroa.0.0.copyload, %mul4.i.i62
  %mul18.i.i69 = fmul float %ornA.sroa.0.0.copyload, %69
  %mul20.i.i70 = fmul float %44, %mul4.i.i62
  %mul24.i.i72 = fmul float %6, %69
  %add.i.i73 = fadd float %mul20.i.i70, %mul24.i.i72
  %sub.i.i74 = fsub float 1.000000e+00, %add.i.i73
  %sub26.i.i75 = fsub float %mul16.i.i68, %mul12.i.i66
  %add28.i.i76 = fadd float %mul18.i.i69, %mul10.i.i65
  %add30.i.i77 = fadd float %mul16.i.i68, %mul12.i.i66
  %add32.i.i78 = fadd float %mul14.i.i67, %mul24.i.i72
  %sub33.i.i79 = fsub float 1.000000e+00, %add32.i.i78
  %70 = fsub <2 x float> %67, %66
  %sub37.i.i81 = fsub float %mul18.i.i69, %mul10.i.i65
  %71 = fadd <2 x float> %67, %66
  %add39.i.i82 = extractelement <2 x float> %71, i64 1
  %add41.i.i83 = fadd float %mul14.i.i67, %mul20.i.i70
  %sub42.i.i84 = fsub float 1.000000e+00, %add41.i.i83
  %mul7.i.i.i = fmul float %add30.i.i, %add30.i.i77
  %72 = tail call float @llvm.fmuladd.f32(float %sub.i.i74, float %sub.i.i, float %mul7.i.i.i)
  %73 = tail call noundef float @llvm.fmuladd.f32(float %sub37.i.i81, float %sub37.i.i, float %72)
  %mul7.i19.i.i = fmul float %add30.i.i, %sub33.i.i79
  %74 = tail call float @llvm.fmuladd.f32(float %sub26.i.i75, float %sub.i.i, float %mul7.i19.i.i)
  %75 = tail call noundef float @llvm.fmuladd.f32(float %add39.i.i82, float %sub37.i.i, float %74)
  %76 = extractelement <2 x float> %70, i64 1
  %mul7.i23.i.i = fmul float %add30.i.i, %76
  %77 = tail call float @llvm.fmuladd.f32(float %add28.i.i76, float %sub.i.i, float %mul7.i23.i.i)
  %78 = tail call noundef float @llvm.fmuladd.f32(float %sub42.i.i84, float %sub37.i.i, float %77)
  %mul7.i28.i.i = fmul float %sub33.i.i, %add30.i.i77
  %79 = tail call float @llvm.fmuladd.f32(float %sub.i.i74, float %sub26.i.i, float %mul7.i28.i.i)
  %80 = tail call noundef float @llvm.fmuladd.f32(float %sub37.i.i81, float %add39.i.i, float %79)
  %mul7.i35.i.i = fmul float %sub33.i.i, %sub33.i.i79
  %81 = tail call float @llvm.fmuladd.f32(float %sub26.i.i75, float %sub26.i.i, float %mul7.i35.i.i)
  %82 = tail call noundef float @llvm.fmuladd.f32(float %add39.i.i82, float %add39.i.i, float %81)
  %mul7.i42.i.i = fmul float %sub33.i.i, %76
  %83 = tail call float @llvm.fmuladd.f32(float %add28.i.i76, float %sub26.i.i, float %mul7.i42.i.i)
  %84 = tail call noundef float @llvm.fmuladd.f32(float %sub42.i.i84, float %add39.i.i, float %83)
  %85 = extractelement <2 x float> %70, i64 0
  %mul7.i48.i.i = fmul float %85, %add30.i.i77
  %86 = tail call float @llvm.fmuladd.f32(float %sub.i.i74, float %add28.i.i, float %mul7.i48.i.i)
  %87 = tail call noundef float @llvm.fmuladd.f32(float %sub37.i.i81, float %sub42.i.i, float %86)
  %mul7.i55.i.i = fmul float %85, %sub33.i.i79
  %88 = tail call float @llvm.fmuladd.f32(float %sub26.i.i75, float %add28.i.i, float %mul7.i55.i.i)
  %89 = tail call noundef float @llvm.fmuladd.f32(float %add39.i.i82, float %sub42.i.i, float %88)
  %mul7.i62.i.i = fmul float %85, %76
  %90 = tail call float @llvm.fmuladd.f32(float %add28.i.i76, float %add28.i.i, float %mul7.i62.i.i)
  %91 = tail call noundef float @llvm.fmuladd.f32(float %sub42.i.i84, float %sub42.i.i, float %90)
  %fneg.i.i114 = fneg float %posA.sroa.0.0.copyload
  %fneg2.i.i116 = fneg float %posA.sroa.2.0.copyload
  %fneg4.i.i118 = fneg float %posA.sroa.3.0.copyload
  %mul5.i.i.i119 = fmul float %add30.i.i77, %fneg2.i.i116
  %92 = tail call float @llvm.fmuladd.f32(float %sub.i.i74, float %fneg.i.i114, float %mul5.i.i.i119)
  %93 = tail call noundef float @llvm.fmuladd.f32(float %sub37.i.i81, float %fneg4.i.i118, float %92)
  %mul5.i7.i.i120 = fmul float %sub33.i.i79, %fneg2.i.i116
  %94 = tail call float @llvm.fmuladd.f32(float %sub26.i.i75, float %fneg.i.i114, float %mul5.i7.i.i120)
  %95 = tail call noundef float @llvm.fmuladd.f32(float %add39.i.i82, float %fneg4.i.i118, float %94)
  %mul5.i13.i.i121 = fmul float %76, %fneg2.i.i116
  %96 = tail call float @llvm.fmuladd.f32(float %add28.i.i76, float %fneg.i.i114, float %mul5.i13.i.i121)
  %97 = tail call noundef float @llvm.fmuladd.f32(float %sub42.i.i84, float %fneg4.i.i118, float %96)
  %fneg.i = fneg float %7
  %fneg2.i = fneg float %8
  %fneg4.i = fneg float %planeEq.sroa.3.0.copyload
  %mul5.i.i = fmul float %75, %fneg2.i
  %98 = tail call float @llvm.fmuladd.f32(float %73, float %fneg.i, float %mul5.i.i)
  %99 = tail call noundef float @llvm.fmuladd.f32(float %78, float %fneg4.i, float %98)
  %mul5.i7.i = fmul float %82, %fneg2.i
  %100 = tail call float @llvm.fmuladd.f32(float %80, float %fneg.i, float %mul5.i7.i)
  %101 = tail call noundef float @llvm.fmuladd.f32(float %84, float %fneg4.i, float %100)
  %mul5.i13.i = fmul float %89, %fneg2.i
  %102 = tail call float @llvm.fmuladd.f32(float %87, float %fneg.i, float %mul5.i13.i)
  %103 = tail call noundef float @llvm.fmuladd.f32(float %91, float %fneg4.i, float %102)
  %retval.sroa.0.0.vec.insert.i.i200 = insertelement <2 x float> poison, float %99, i64 0
  %retval.sroa.0.4.vec.insert.i.i201 = insertelement <2 x float> %retval.sroa.0.0.vec.insert.i.i200, float %101, i64 1
  %retval.sroa.3.12.vec.insert.i.i202 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %103, i64 0
  store <2 x float> %retval.sroa.0.4.vec.insert.i.i201, ptr %planeNormalInConvex, align 16
  %104 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %planeNormalInConvex, i64 0, i32 1
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i202, ptr %104, align 8
  store <4 x i32> <i32 0, i32 1, i32 2, i32 3>, ptr %contactIdx, align 16
  %m_numVertices = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexShapes, i64 %idxprom1, i32 7
  %105 = load i32, ptr %m_numVertices, align 4
  %cmp363 = icmp sgt i32 %105, 0
  br i1 %cmp363, label %for.body.lr.ph, label %if.end111

for.body.lr.ph:                                   ; preds = %entry
  %m_vertexOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexShapes, i64 %idxprom1, i32 8
  %106 = load i32, ptr %m_vertexOffset, align 16
  %107 = sext i32 %106 to i64
  %wide.trip.count = zext nneg i32 %105 to i64
  %invariant.gep = getelementptr %class.b3Vector3, ptr %convexVertices, i64 %107
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ]
  %maxDot.0366 = phi float [ 0xC6293E5940000000, %for.body.lr.ph ], [ %maxDot.1, %for.inc ]
  %numPoints.0365 = phi i32 [ 0, %for.body.lr.ph ], [ %numPoints.2, %for.inc ]
  %gep = getelementptr %class.b3Vector3, ptr %invariant.gep, i64 %indvars.iv
  %vtx.sroa.0.0.copyload = load float, ptr %gep, align 16
  %vtx.sroa.3.0.arrayidx42.sroa_idx = getelementptr inbounds i8, ptr %gep, i64 4
  %vtx.sroa.3.0.copyload = load float, ptr %vtx.sroa.3.0.arrayidx42.sroa_idx, align 4
  %vtx.sroa.5.0.arrayidx42.sroa_idx = getelementptr inbounds i8, ptr %gep, i64 8
  %vtx.sroa.5.0.copyload = load float, ptr %vtx.sroa.5.0.arrayidx42.sroa_idx, align 8
  %mul5.i = fmul float %vtx.sroa.3.0.copyload, %101
  %108 = tail call float @llvm.fmuladd.f32(float %vtx.sroa.0.0.copyload, float %99, float %mul5.i)
  %109 = tail call noundef float @llvm.fmuladd.f32(float %vtx.sroa.5.0.copyload, float %103, float %108)
  %cmp44 = fcmp ogt float %109, %maxDot.0366
  %cmp45 = icmp eq i32 %numPoints.0365, 64
  %110 = select i1 %cmp44, i1 %cmp45, i1 false
  %numPoints.1 = select i1 %110, i32 63, i32 %numPoints.0365
  %maxDot.1 = select i1 %cmp44, float %109, float %maxDot.0366
  %cmp48 = icmp slt i32 %numPoints.1, 64
  br i1 %cmp48, label %if.then49, label %for.inc

if.then49:                                        ; preds = %for.body
  %mul5.i.i.i.i210 = fmul float %sub26.i.i, %vtx.sroa.3.0.copyload
  %111 = tail call float @llvm.fmuladd.f32(float %vtx.sroa.0.0.copyload, float %sub.i.i, float %mul5.i.i.i.i210)
  %112 = tail call noundef float @llvm.fmuladd.f32(float %vtx.sroa.5.0.copyload, float %add28.i.i, float %111)
  %mul5.i3.i.i.i213 = fmul float %sub33.i.i, %vtx.sroa.3.0.copyload
  %113 = tail call float @llvm.fmuladd.f32(float %vtx.sroa.0.0.copyload, float %add30.i.i, float %mul5.i3.i.i.i213)
  %114 = tail call noundef float @llvm.fmuladd.f32(float %vtx.sroa.5.0.copyload, float %85, float %113)
  %mul5.i8.i.i.i214 = fmul float %add39.i.i, %vtx.sroa.3.0.copyload
  %115 = tail call float @llvm.fmuladd.f32(float %vtx.sroa.0.0.copyload, float %sub37.i.i, float %mul5.i8.i.i.i214)
  %116 = tail call noundef float @llvm.fmuladd.f32(float %vtx.sroa.5.0.copyload, float %sub42.i.i, float %115)
  %add.i.i.i216 = fadd float %posB.sroa.0.0.copyload, %112
  %add4.i.i.i218 = fadd float %posB.sroa.2.0.copyload, %114
  %add7.i.i.i220 = fadd float %posB.sroa.3.0.copyload, %116
  %mul5.i.i.i.i261 = fmul float %add30.i.i77, %add4.i.i.i218
  %117 = tail call float @llvm.fmuladd.f32(float %add.i.i.i216, float %sub.i.i74, float %mul5.i.i.i.i261)
  %118 = tail call noundef float @llvm.fmuladd.f32(float %add7.i.i.i220, float %sub37.i.i81, float %117)
  %mul5.i3.i.i.i265 = fmul float %sub33.i.i79, %add4.i.i.i218
  %119 = tail call float @llvm.fmuladd.f32(float %add.i.i.i216, float %sub26.i.i75, float %mul5.i3.i.i.i265)
  %120 = tail call noundef float @llvm.fmuladd.f32(float %add7.i.i.i220, float %add39.i.i82, float %119)
  %mul5.i8.i.i.i268 = fmul float %76, %add4.i.i.i218
  %121 = tail call float @llvm.fmuladd.f32(float %add.i.i.i216, float %add28.i.i76, float %mul5.i8.i.i.i268)
  %122 = tail call noundef float @llvm.fmuladd.f32(float %add7.i.i.i220, float %sub42.i.i84, float %121)
  %add.i.i.i271 = fadd float %93, %118
  %add4.i.i.i273 = fadd float %95, %120
  %add7.i.i.i275 = fadd float %97, %122
  %mul5.i283 = fmul float %8, %add4.i.i.i273
  %123 = tail call float @llvm.fmuladd.f32(float %7, float %add.i.i.i271, float %mul5.i283)
  %124 = tail call noundef float @llvm.fmuladd.f32(float %planeEq.sroa.3.0.copyload, float %add7.i.i.i275, float %123)
  %sub = fsub float %124, %planeEq.sroa.4.0.copyload
  %cmp58 = fcmp olt float %sub, 0.000000e+00
  br i1 %cmp58, label %if.then59, label %for.inc

if.then59:                                        ; preds = %if.then49
  %retval.sroa.3.12.vec.insert.i.i4.i.i223 = insertelement <2 x float> poison, float %add7.i.i.i220, i64 0
  %retval.sroa.0.0.vec.insert.i.i2.i.i221 = insertelement <2 x float> poison, float %add.i.i.i216, i64 0
  %retval.sroa.0.4.vec.insert.i.i3.i.i222 = insertelement <2 x float> %retval.sroa.0.0.vec.insert.i.i2.i.i221, float %add4.i.i.i218, i64 1
  %vtxWorld.sroa.4.12.vec.insert = insertelement <2 x float> %retval.sroa.3.12.vec.insert.i.i4.i.i223, float %sub, i64 1
  %idxprom61 = sext i32 %numPoints.1 to i64
  %arrayidx62 = getelementptr inbounds [64 x %class.b3Vector3], ptr %contactPoints, i64 0, i64 %idxprom61
  store <2 x float> %retval.sroa.0.4.vec.insert.i.i3.i.i222, ptr %arrayidx62, align 16
  %vtxWorld.sroa.4.0.arrayidx62.sroa_idx = getelementptr inbounds i8, ptr %arrayidx62, i64 8
  store <2 x float> %vtxWorld.sroa.4.12.vec.insert, ptr %vtxWorld.sroa.4.0.arrayidx62.sroa_idx, align 8
  %inc = add nsw i32 %numPoints.1, 1
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then59, %if.then49
  %numPoints.2 = phi i32 [ %inc, %if.then59 ], [ %numPoints.1, %if.then49 ], [ %numPoints.0365, %for.body ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !40

for.end:                                          ; preds = %for.inc
  %cmp66 = icmp sgt i32 %numPoints.2, 4
  br i1 %cmp66, label %if.then67, label %if.end69

if.then67:                                        ; preds = %for.end
  %call68 = call noundef i32 @_Z31extractManifoldSequentialGlobalPK9b3Vector3iRS0_P6b3Int4(ptr noundef nonnull %contactPoints, i32 noundef %numPoints.2, ptr noundef nonnull align 16 dereferenceable(16) %planeNormalInConvex, ptr noundef nonnull %contactIdx)
  br label %if.end69

if.end69:                                         ; preds = %if.then67, %for.end
  %numReducedPoints.0 = phi i32 [ %call68, %if.then67 ], [ %numPoints.2, %for.end ]
  %cmp70 = icmp sgt i32 %numReducedPoints.0, 0
  br i1 %cmp70, label %if.then71, label %if.end111

if.then71:                                        ; preds = %if.end69
  %125 = load i32, ptr %nGlobalContactsOut, align 4
  %cmp72 = icmp slt i32 %125, %maxContactCapacity
  br i1 %cmp72, label %for.body97.preheader, label %if.end111

for.body97.preheader:                             ; preds = %if.then71
  %inc74 = add nsw i32 %125, 1
  store i32 %inc74, ptr %nGlobalContactsOut, align 4
  %idxprom75 = sext i32 %125 to i64
  %arrayidx76 = getelementptr inbounds %struct.b3Contact4, ptr %globalContactsOut, i64 %idxprom75
  %126 = fneg <2 x float> %36
  %fneg4.i290 = fneg float %41
  %retval.sroa.3.12.vec.insert.i.i293 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %fneg4.i290, i64 0
  %m_worldNormalOnB = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx76, i64 0, i32 1
  store <2 x float> %126, ptr %m_worldNormalOnB, align 16
  %ref.tmp77.sroa.2.0.m_worldNormalOnB.sroa_idx = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx76, i64 0, i32 1, i32 0, i32 0, i64 2
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i293, ptr %ref.tmp77.sroa.2.0.m_worldNormalOnB.sroa_idx, align 8
  %m_frictionCoeffCmp.i = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx76, i64 0, i32 3
  store i16 -19662, ptr %m_frictionCoeffCmp.i, align 2
  %m_restituitionCoeffCmp.i = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx76, i64 0, i32 2
  store i16 0, ptr %m_restituitionCoeffCmp.i, align 16
  %m_batchIdx = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx76, i64 0, i32 4
  store i32 %pairIndex, ptr %m_batchIdx, align 4
  %m_invMass = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom7, i32 5
  %127 = load float, ptr %m_invMass, align 4
  %cmp83 = fcmp oeq float %127, 0.000000e+00
  %sub84 = sub nsw i32 0, %bodyIndexA
  %cond = select i1 %cmp83, i32 %sub84, i32 %bodyIndexA
  %m_bodyAPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx76, i64 0, i32 5
  store i32 %cond, ptr %m_bodyAPtrAndSignBit, align 8
  %m_invMass87 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom3, i32 5
  %128 = load float, ptr %m_invMass87, align 4
  %cmp88 = fcmp oeq float %128, 0.000000e+00
  %sub90 = sub nsw i32 0, %bodyIndexB
  %cond93 = select i1 %cmp88, i32 %sub90, i32 %bodyIndexB
  %m_bodyBPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx76, i64 0, i32 6
  store i32 %cond93, ptr %m_bodyBPtrAndSignBit, align 4
  %wide.trip.count374 = zext nneg i32 %numReducedPoints.0 to i64
  br label %for.body97

for.body97:                                       ; preds = %for.body97.preheader, %for.body97
  %indvars.iv371 = phi i64 [ 0, %for.body97.preheader ], [ %indvars.iv.next372, %for.body97 ]
  %arrayidx100 = getelementptr inbounds [4 x i32], ptr %contactIdx, i64 0, i64 %indvars.iv371
  %129 = load i32, ptr %arrayidx100, align 4
  %idxprom101 = sext i32 %129 to i64
  %arrayidx102 = getelementptr inbounds [64 x %class.b3Vector3], ptr %contactPoints, i64 0, i64 %idxprom101
  %arrayidx104 = getelementptr inbounds [4 x %class.b3Vector3], ptr %arrayidx76, i64 0, i64 %indvars.iv371
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx104, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx102, i64 16, i1 false)
  %indvars.iv.next372 = add nuw nsw i64 %indvars.iv371, 1
  %exitcond375.not = icmp eq i64 %indvars.iv.next372, %wide.trip.count374
  br i1 %exitcond375.not, label %for.end107, label %for.body97, !llvm.loop !41

for.end107:                                       ; preds = %for.body97
  %conv = sitofp i32 %numReducedPoints.0 to float
  %w109 = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx76, i64 0, i32 1, i32 0, i32 0, i64 3
  store float %conv, ptr %w109, align 4
  br label %if.end111

if.end111:                                        ; preds = %entry, %if.then71, %for.end107, %if.end69
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local void @_Z16traverseTreeTreev() local_unnamed_addr #17 {
entry:
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local void @_Z23findCompoundPairsKerneliiiiiPK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataRK20b3AlignedObjectArrayI9b3Vector3ERKS8_I6b3AabbESG_PK15b3GpuChildShapeP6b3Int4PiiRS8_I18b3QuantizedBvhNodeERS8_I16b3BvhSubtreeInfoERS8_I9b3BvhInfoE(i32 %pairIndex, i32 noundef %bodyIndexA, i32 noundef %bodyIndexB, i32 noundef %collidableIndexA, i32 noundef %collidableIndexB, ptr nocapture noundef readonly %rigidBodies, ptr nocapture noundef readonly %collidables, ptr nocapture readonly %convexShapes, ptr nocapture nonnull readnone align 8 %vertices, ptr nocapture nonnull readnone align 8 %aabbsWorldSpace, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %aabbsLocalSpace, ptr nocapture noundef readonly %gpuChildShapes, ptr nocapture noundef writeonly %gpuCompoundPairsOut, ptr nocapture noundef %numCompoundPairsOut, i32 noundef %maxNumCompoundPairsCapacity, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %treeNodesCPU, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %subTreesCPU, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %bvhInfoCPU) local_unnamed_addr #5 personality ptr @__gxx_personality_v0 {
entry:
  %temp.i1585 = alloca [4 x float], align 16
  %temp.i1508 = alloca [4 x float], align 16
  %temp.i = alloca [4 x float], align 16
  %retval.i1112 = alloca %class.b3Quaternion, align 16
  %retval.i959 = alloca %class.b3Quaternion, align 16
  %retval.i = alloca %class.b3Quaternion, align 16
  %transA = alloca %class.b3Transform, align 16
  %transB = alloca %class.b3Transform, align 16
  %nodeStack = alloca %class.b3AlignedObjectArray.51, align 8
  %transA456 = alloca %class.b3Transform, align 16
  %transB504 = alloca %class.b3Transform, align 16
  store i32 0, ptr @numAabbChecks, align 4
  store i32 0, ptr @maxNumAabbChecks, align 4
  %idxprom = sext i32 %collidableIndexA to i64
  %arrayidx = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom
  %0 = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom, i32 3
  %idxprom1 = sext i32 %collidableIndexB to i64
  %arrayidx2 = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom1
  %1 = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom1, i32 3
  %idxprom3 = sext i32 %bodyIndexA to i64
  %arrayidx4 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom3
  %m_invMass = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom3, i32 5
  %2 = load float, ptr %m_invMass, align 4
  %cmp = fcmp oeq float %2, 0.000000e+00
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %idxprom5 = sext i32 %bodyIndexB to i64
  %m_invMass7 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom5, i32 5
  %3 = load float, ptr %m_invMass7, align 4
  %cmp8 = fcmp oeq float %3, 0.000000e+00
  br i1 %cmp8, label %if.end676, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %m_shapeType = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom, i32 2
  %4 = load i32, ptr %m_shapeType, align 4
  %cmp11 = icmp eq i32 %4, 6
  %m_shapeType15 = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom1, i32 2
  %5 = load i32, ptr %m_shapeType15, align 4
  br i1 %cmp11, label %land.lhs.true12, label %lor.lhs.false

land.lhs.true12:                                  ; preds = %if.end
  %cmp16 = icmp eq i32 %5, 6
  br i1 %cmp16, label %if.then17, label %if.then420

if.then17:                                        ; preds = %land.lhs.true12
  %6 = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom, i32 1
  %7 = load i32, ptr %6, align 4
  %8 = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom1, i32 1
  %9 = load i32, ptr %8, align 4
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %bvhInfoCPU, i64 0, i32 5
  %10 = load ptr, ptr %m_data.i, align 8
  %idxprom.i = sext i32 %7 to i64
  %m_numSubTrees = getelementptr inbounds %struct.b3BvhInfo, ptr %10, i64 %idxprom.i, i32 4
  %11 = load i32, ptr %m_numSubTrees, align 4
  %m_subTreeOffset = getelementptr inbounds %struct.b3BvhInfo, ptr %10, i64 %idxprom.i, i32 6
  %12 = load i32, ptr %m_subTreeOffset, align 4
  %idxprom.i231 = sext i32 %9 to i64
  %m_subTreeOffset24 = getelementptr inbounds %struct.b3BvhInfo, ptr %10, i64 %idxprom.i231, i32 6
  %13 = load i32, ptr %m_subTreeOffset24, align 4
  %m_numSubTrees26 = getelementptr inbounds %struct.b3BvhInfo, ptr %10, i64 %idxprom.i231, i32 4
  %14 = load i32, ptr %m_numSubTrees26, align 4
  %m_quat = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom3, i32 1
  %ornA.sroa.0.0.copyload = load float, ptr %m_quat, align 16
  %ornA.sroa.2.0.m_quat.sroa_idx = getelementptr inbounds i8, ptr %m_quat, i64 4
  %ornA.sroa.2.0.copyload = load float, ptr %ornA.sroa.2.0.m_quat.sroa_idx, align 4
  %ornA.sroa.3.0.m_quat.sroa_idx = getelementptr inbounds i8, ptr %m_quat, i64 8
  %ornA.sroa.3.0.copyload = load float, ptr %ornA.sroa.3.0.m_quat.sroa_idx, align 8
  %ornA.sroa.4.0.m_quat.sroa_idx = getelementptr inbounds i8, ptr %m_quat, i64 12
  %ornA.sroa.4.0.copyload = load float, ptr %ornA.sroa.4.0.m_quat.sroa_idx, align 4
  %arrayidx2.i.i.i.i = getelementptr inbounds [4 x float], ptr %transA, i64 0, i64 1
  %arrayidx2.i1.i.i.i = getelementptr inbounds [3 x %class.b3Vector3], ptr %transA, i64 0, i64 1, i32 0, i32 0, i64 1
  %arrayidx3.i2.i.i.i = getelementptr inbounds [3 x %class.b3Vector3], ptr %transA, i64 0, i64 1, i32 0, i32 0, i64 2
  %arrayidx3.i5.i.i.i = getelementptr inbounds [3 x %class.b3Vector3], ptr %transA, i64 0, i64 2, i32 0, i32 0, i64 2
  %arrayidx4.i6.i.i.i = getelementptr inbounds [3 x %class.b3Vector3], ptr %transA, i64 0, i64 2, i32 0, i32 0, i64 3
  %m_origin.i = getelementptr inbounds %class.b3Transform, ptr %transA, i64 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %m_origin.i, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx4, i64 16, i1 false)
  %mul4.i.i.i.i = fmul float %ornA.sroa.2.0.copyload, %ornA.sroa.2.0.copyload
  %15 = tail call float @llvm.fmuladd.f32(float %ornA.sroa.0.0.copyload, float %ornA.sroa.0.0.copyload, float %mul4.i.i.i.i)
  %16 = tail call float @llvm.fmuladd.f32(float %ornA.sroa.3.0.copyload, float %ornA.sroa.3.0.copyload, float %15)
  %17 = tail call noundef float @llvm.fmuladd.f32(float %ornA.sroa.4.0.copyload, float %ornA.sroa.4.0.copyload, float %16)
  %div.i.i = fdiv float 2.000000e+00, %17
  %mul.i.i = fmul float %ornA.sroa.0.0.copyload, %div.i.i
  %mul4.i.i = fmul float %ornA.sroa.2.0.copyload, %div.i.i
  %mul6.i.i = fmul float %ornA.sroa.3.0.copyload, %div.i.i
  %mul8.i.i = fmul float %ornA.sroa.4.0.copyload, %mul.i.i
  %mul10.i.i = fmul float %ornA.sroa.4.0.copyload, %mul4.i.i
  %mul12.i.i = fmul float %ornA.sroa.4.0.copyload, %mul6.i.i
  %mul14.i.i = fmul float %ornA.sroa.0.0.copyload, %mul.i.i
  %mul16.i.i = fmul float %ornA.sroa.0.0.copyload, %mul4.i.i
  %mul18.i.i = fmul float %ornA.sroa.0.0.copyload, %mul6.i.i
  %mul20.i.i = fmul float %ornA.sroa.2.0.copyload, %mul4.i.i
  %mul22.i.i = fmul float %ornA.sroa.2.0.copyload, %mul6.i.i
  %mul24.i.i = fmul float %ornA.sroa.3.0.copyload, %mul6.i.i
  %add.i.i = fadd float %mul20.i.i, %mul24.i.i
  %sub.i.i = fsub float 1.000000e+00, %add.i.i
  %sub26.i.i = fsub float %mul16.i.i, %mul12.i.i
  %add28.i.i = fadd float %mul18.i.i, %mul10.i.i
  %add30.i.i = fadd float %mul16.i.i, %mul12.i.i
  %add32.i.i = fadd float %mul14.i.i, %mul24.i.i
  %sub33.i.i = fsub float 1.000000e+00, %add32.i.i
  %sub35.i.i = fsub float %mul22.i.i, %mul8.i.i
  %sub37.i.i = fsub float %mul18.i.i, %mul10.i.i
  %add39.i.i = fadd float %mul22.i.i, %mul8.i.i
  %add41.i.i = fadd float %mul14.i.i, %mul20.i.i
  %sub42.i.i = fsub float 1.000000e+00, %add41.i.i
  store float %sub.i.i, ptr %transA, align 16
  store float %sub26.i.i, ptr %arrayidx2.i.i.i.i, align 4
  %arrayidx3.i.i.i.i = getelementptr inbounds [4 x float], ptr %transA, i64 0, i64 2
  store float %add28.i.i, ptr %arrayidx3.i.i.i.i, align 8
  %arrayidx4.i.i.i.i = getelementptr inbounds [4 x float], ptr %transA, i64 0, i64 3
  store float 0.000000e+00, ptr %arrayidx4.i.i.i.i, align 4
  %arrayidx3.i.i.i = getelementptr inbounds [3 x %class.b3Vector3], ptr %transA, i64 0, i64 1
  store float %add30.i.i, ptr %arrayidx3.i.i.i, align 16
  store float %sub33.i.i, ptr %arrayidx2.i1.i.i.i, align 4
  store float %sub35.i.i, ptr %arrayidx3.i2.i.i.i, align 8
  %arrayidx4.i3.i.i.i = getelementptr inbounds [3 x %class.b3Vector3], ptr %transA, i64 0, i64 1, i32 0, i32 0, i64 3
  store float 0.000000e+00, ptr %arrayidx4.i3.i.i.i, align 4
  %arrayidx5.i.i.i = getelementptr inbounds [3 x %class.b3Vector3], ptr %transA, i64 0, i64 2
  store float %sub37.i.i, ptr %arrayidx5.i.i.i, align 16
  %arrayidx2.i4.i.i.i = getelementptr inbounds [3 x %class.b3Vector3], ptr %transA, i64 0, i64 2, i32 0, i32 0, i64 1
  store float %add39.i.i, ptr %arrayidx2.i4.i.i.i, align 4
  store float %sub42.i.i, ptr %arrayidx3.i5.i.i.i, align 8
  store float 0.000000e+00, ptr %arrayidx4.i6.i.i.i, align 4
  %idxprom31 = sext i32 %bodyIndexB to i64
  %arrayidx32 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom31
  %m_quat33 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom31, i32 1
  %ornB.sroa.0.0.copyload = load float, ptr %m_quat33, align 16
  %ornB.sroa.2.0.m_quat33.sroa_idx = getelementptr inbounds i8, ptr %m_quat33, i64 4
  %ornB.sroa.4.0.m_quat33.sroa_idx = getelementptr inbounds i8, ptr %m_quat33, i64 12
  %ornB.sroa.4.0.copyload = load float, ptr %ornB.sroa.4.0.m_quat33.sroa_idx, align 4
  %arrayidx2.i.i.i.i241 = getelementptr inbounds [4 x float], ptr %transB, i64 0, i64 1
  %arrayidx2.i1.i.i.i242 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transB, i64 0, i64 1, i32 0, i32 0, i64 1
  %arrayidx3.i2.i.i.i243 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transB, i64 0, i64 1, i32 0, i32 0, i64 2
  %arrayidx3.i5.i.i.i244 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transB, i64 0, i64 2, i32 0, i32 0, i64 2
  %arrayidx4.i6.i.i.i245 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transB, i64 0, i64 2, i32 0, i32 0, i64 3
  %m_origin.i246 = getelementptr inbounds %class.b3Transform, ptr %transB, i64 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %m_origin.i246, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx32, i64 16, i1 false)
  %18 = load <2 x float>, ptr %ornB.sroa.2.0.m_quat33.sroa_idx, align 4
  %19 = extractelement <2 x float> %18, i64 0
  %20 = fmul <2 x float> %18, %18
  %mul4.i.i.i.i248 = extractelement <2 x float> %20, i64 0
  %21 = tail call float @llvm.fmuladd.f32(float %ornB.sroa.0.0.copyload, float %ornB.sroa.0.0.copyload, float %mul4.i.i.i.i248)
  %22 = extractelement <2 x float> %18, i64 1
  %23 = tail call float @llvm.fmuladd.f32(float %22, float %22, float %21)
  %24 = tail call noundef float @llvm.fmuladd.f32(float %ornB.sroa.4.0.copyload, float %ornB.sroa.4.0.copyload, float %23)
  %div.i.i251 = fdiv float 2.000000e+00, %24
  %mul.i.i252 = fmul float %ornB.sroa.0.0.copyload, %div.i.i251
  %25 = insertelement <2 x float> poison, float %div.i.i251, i64 0
  %26 = shufflevector <2 x float> %25, <2 x float> poison, <2 x i32> zeroinitializer
  %27 = fmul <2 x float> %18, %26
  %mul8.i.i255 = fmul float %ornB.sroa.4.0.copyload, %mul.i.i252
  %28 = insertelement <2 x float> poison, float %ornB.sroa.4.0.copyload, i64 0
  %29 = shufflevector <2 x float> %28, <2 x float> poison, <2 x i32> zeroinitializer
  %30 = fmul <2 x float> %29, %27
  %mul14.i.i258 = fmul float %ornB.sroa.0.0.copyload, %mul.i.i252
  %31 = insertelement <2 x float> poison, float %ornB.sroa.0.0.copyload, i64 0
  %32 = shufflevector <2 x float> %31, <2 x float> poison, <2 x i32> zeroinitializer
  %33 = fmul <2 x float> %32, %27
  %34 = shufflevector <2 x float> %33, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %35 = fmul <2 x float> %18, %27
  %mul20.i.i261 = extractelement <2 x float> %35, i64 0
  %36 = extractelement <2 x float> %27, i64 1
  %mul22.i.i262 = fmul float %19, %36
  %mul24.i.i263 = fmul float %22, %36
  %add.i.i264 = fadd float %mul20.i.i261, %mul24.i.i263
  %sub.i.i265 = fsub float 1.000000e+00, %add.i.i264
  %37 = fadd <2 x float> %34, %30
  %add32.i.i269 = fadd float %mul14.i.i258, %mul24.i.i263
  %sub33.i.i270 = fsub float 1.000000e+00, %add32.i.i269
  %sub35.i.i271 = fsub float %mul22.i.i262, %mul8.i.i255
  %38 = fsub <2 x float> %34, %30
  %add39.i.i273 = fadd float %mul22.i.i262, %mul8.i.i255
  %add41.i.i274 = fadd float %mul14.i.i258, %mul20.i.i261
  %sub42.i.i275 = fsub float 1.000000e+00, %add41.i.i274
  store float %sub.i.i265, ptr %transB, align 16
  %39 = extractelement <2 x float> %38, i64 1
  store float %39, ptr %arrayidx2.i.i.i.i241, align 4
  %arrayidx3.i.i.i.i277 = getelementptr inbounds [4 x float], ptr %transB, i64 0, i64 2
  %40 = extractelement <2 x float> %37, i64 0
  store float %40, ptr %arrayidx3.i.i.i.i277, align 8
  %arrayidx4.i.i.i.i278 = getelementptr inbounds [4 x float], ptr %transB, i64 0, i64 3
  store float 0.000000e+00, ptr %arrayidx4.i.i.i.i278, align 4
  %arrayidx3.i.i.i279 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transB, i64 0, i64 1
  %41 = extractelement <2 x float> %37, i64 1
  store float %41, ptr %arrayidx3.i.i.i279, align 16
  store float %sub33.i.i270, ptr %arrayidx2.i1.i.i.i242, align 4
  store float %sub35.i.i271, ptr %arrayidx3.i2.i.i.i243, align 8
  %arrayidx4.i3.i.i.i282 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transB, i64 0, i64 1, i32 0, i32 0, i64 3
  store float 0.000000e+00, ptr %arrayidx4.i3.i.i.i282, align 4
  %arrayidx5.i.i.i283 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transB, i64 0, i64 2
  %42 = extractelement <2 x float> %38, i64 0
  store float %42, ptr %arrayidx5.i.i.i283, align 16
  %arrayidx2.i4.i.i.i284 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transB, i64 0, i64 2, i32 0, i32 0, i64 1
  store float %add39.i.i273, ptr %arrayidx2.i4.i.i.i284, align 4
  store float %sub42.i.i275, ptr %arrayidx3.i5.i.i.i244, align 8
  store float 0.000000e+00, ptr %arrayidx4.i6.i.i.i245, align 4
  %cmp371755 = icmp sgt i32 %11, 0
  br i1 %cmp371755, label %for.body.lr.ph, label %if.end676

for.body.lr.ph:                                   ; preds = %if.then17
  %m_data.i287 = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %subTreesCPU, i64 0, i32 5
  %.fca.1.gep.i = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %retval.i, i64 0, i32 1
  %tr.sroa.23.48.translation.sroa_idx.i.i = getelementptr inbounds %class.b3Transform, ptr %transA, i64 0, i32 1, i32 0, i32 0, i64 1
  %tr.sroa.24.48.translation.sroa_idx.i.i = getelementptr inbounds %class.b3Transform, ptr %transA, i64 0, i32 1, i32 0, i32 0, i64 2
  %cmp571746 = icmp sgt i32 %14, 0
  %add.i1486 = fadd float %sub.i.i265, %sub33.i.i270
  %add8.i = fadd float %add.i1486, %sub42.i.i275
  %cmp.i1487 = fcmp ogt float %add8.i, 0.000000e+00
  %cmp44.i = fcmp olt float %sub.i.i265, %sub33.i.i270
  %cmp51.i = fcmp olt float %sub33.i.i270, %sub42.i.i275
  %cond.i1488 = select i1 %cmp51.i, i32 2, i32 1
  %cmp58.i = fcmp olt float %sub.i.i265, %sub42.i.i275
  %cond59.i = select i1 %cmp58.i, i32 2, i32 0
  %cond60.i = select i1 %cmp44.i, i32 %cond.i1488, i32 %cond59.i
  %cond60.fr.i = freeze i32 %cond60.i
  %add61.i = add nuw nsw i32 %cond60.fr.i, 1
  %43 = icmp eq i32 %add61.i, 3
  %rem.i = select i1 %43, i32 0, i32 %add61.i
  %add62.i = add nuw nsw i32 %cond60.fr.i, 2
  %rem63.i = urem i32 %add62.i, 3
  %idxprom.i1489 = zext nneg i32 %cond60.fr.i to i64
  %arrayidx66.i = getelementptr inbounds [3 x %class.b3Vector3], ptr %transB, i64 0, i64 %idxprom.i1489
  %arrayidx69.i = getelementptr inbounds float, ptr %arrayidx66.i, i64 %idxprom.i1489
  %idxprom71.i = sext i32 %rem.i to i64
  %arrayidx72.i = getelementptr inbounds [3 x %class.b3Vector3], ptr %transB, i64 0, i64 %idxprom71.i
  %arrayidx75.i = getelementptr inbounds float, ptr %arrayidx72.i, i64 %idxprom71.i
  %idxprom78.i = zext nneg i32 %rem63.i to i64
  %arrayidx79.i = getelementptr inbounds [3 x %class.b3Vector3], ptr %transB, i64 0, i64 %idxprom78.i
  %arrayidx82.i = getelementptr inbounds float, ptr %arrayidx79.i, i64 %idxprom78.i
  %arrayidx88.i = getelementptr inbounds [4 x float], ptr %temp.i, i64 0, i64 %idxprom.i1489
  %arrayidx95.i = getelementptr inbounds float, ptr %arrayidx79.i, i64 %idxprom71.i
  %arrayidx101.i = getelementptr inbounds float, ptr %arrayidx72.i, i64 %idxprom78.i
  %arrayidx104.i = getelementptr inbounds [4 x float], ptr %temp.i, i64 0, i64 3
  %arrayidx110.i = getelementptr inbounds float, ptr %arrayidx72.i, i64 %idxprom.i1489
  %arrayidx116.i = getelementptr inbounds float, ptr %arrayidx66.i, i64 %idxprom71.i
  %arrayidx120.i = getelementptr inbounds [4 x float], ptr %temp.i, i64 0, i64 %idxprom71.i
  %arrayidx126.i = getelementptr inbounds float, ptr %arrayidx79.i, i64 %idxprom.i1489
  %arrayidx132.i = getelementptr inbounds float, ptr %arrayidx66.i, i64 %idxprom78.i
  %arrayidx136.i = getelementptr inbounds [4 x float], ptr %temp.i, i64 0, i64 %idxprom78.i
  %arrayidx138.phi.trans.insert.i = getelementptr inbounds [4 x float], ptr %temp.i, i64 0, i64 1
  %add9.i = fadd float %add8.i, 1.000000e+00
  %sub.i1495 = fsub float %add39.i.i273, %sub35.i.i271
  %44 = fsub <2 x float> %37, %38
  %tr.sroa.21.48.copyload.i.i439 = load float, ptr %m_origin.i246, align 16
  %tr.sroa.23.48.translation.sroa_idx.i.i440 = getelementptr inbounds %class.b3Transform, ptr %transB, i64 0, i32 1, i32 0, i32 0, i64 1
  %tr.sroa.23.48.copyload.i.i441 = load float, ptr %tr.sroa.23.48.translation.sroa_idx.i.i440, align 4
  %tr.sroa.24.48.translation.sroa_idx.i.i442 = getelementptr inbounds %class.b3Transform, ptr %transB, i64 0, i32 1, i32 0, i32 0, i64 2
  %tr.sroa.24.48.copyload.i.i443 = load float, ptr %tr.sroa.24.48.translation.sroa_idx.i.i442, align 8
  %m_ownsMemory.i.i = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %nodeStack, i64 0, i32 6
  %m_data.i.i = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %nodeStack, i64 0, i32 5
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %nodeStack, i64 0, i32 2
  %m_capacity.i.i = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %nodeStack, i64 0, i32 3
  %m_data.i481 = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %treeNodesCPU, i64 0, i32 5
  %arrayidx104.i1546 = getelementptr inbounds [4 x float], ptr %temp.i1508, i64 0, i64 3
  %arrayidx138.phi.trans.insert.i1558 = getelementptr inbounds [4 x float], ptr %temp.i1508, i64 0, i64 1
  %arrayidx139.phi.trans.insert.i1560 = getelementptr inbounds [4 x float], ptr %temp.i1508, i64 0, i64 2
  %arrayidx88.i1617 = getelementptr inbounds [4 x float], ptr %temp.i1585, i64 0, i64 %idxprom.i1489
  %arrayidx104.i1623 = getelementptr inbounds [4 x float], ptr %temp.i1585, i64 0, i64 3
  %arrayidx120.i1628 = getelementptr inbounds [4 x float], ptr %temp.i1585, i64 0, i64 %idxprom71.i
  %arrayidx136.i1633 = getelementptr inbounds [4 x float], ptr %temp.i1585, i64 0, i64 %idxprom78.i
  %arrayidx138.phi.trans.insert.i1635 = getelementptr inbounds [4 x float], ptr %temp.i1585, i64 0, i64 1
  %retval.sroa.2.0.insert.ext.i887 = zext i32 %bodyIndexB to i64
  %retval.sroa.2.0.insert.shift.i888 = shl nuw i64 %retval.sroa.2.0.insert.ext.i887, 32
  %retval.sroa.0.0.insert.ext.i889 = zext i32 %bodyIndexA to i64
  %retval.sroa.0.0.insert.insert.i890 = or disjoint i64 %retval.sroa.2.0.insert.shift.i888, %retval.sroa.0.0.insert.ext.i889
  %45 = sext i32 %13 to i64
  %46 = sext i32 %12 to i64
  %wide.trip.count1787 = zext nneg i32 %11 to i64
  %wide.trip.count = zext nneg i32 %14 to i64
  %47 = insertelement <2 x float> <float 5.000000e-01, float poison>, float %sub.i1495, i64 1
  %48 = insertelement <2 x float> poison, float %tr.sroa.21.48.copyload.i.i439, i64 0
  %49 = insertelement <2 x float> %48, float %tr.sroa.24.48.copyload.i.i443, i64 1
  %50 = insertelement <2 x float> <float poison, float 5.000000e-01>, float %sub.i1495, i64 0
  %51 = insertelement <2 x float> poison, float %tr.sroa.24.48.copyload.i.i443, i64 0
  %52 = insertelement <2 x float> %51, float %tr.sroa.21.48.copyload.i.i439, i64 1
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc403
  %indvars.iv1783 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next1784, %for.inc403 ]
  %53 = load ptr, ptr %m_data.i287, align 8
  %54 = getelementptr %class.b3BvhSubtreeInfo, ptr %53, i64 %indvars.iv1783
  %arrayidx.i289 = getelementptr %class.b3BvhSubtreeInfo, ptr %54, i64 %46
  %subtreeA.sroa.0.0.copyload = load i16, ptr %arrayidx.i289, align 16
  %subtreeA.sroa.2.0.arrayidx.i289.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i289, i64 2
  %subtreeA.sroa.2.0.copyload = load i16, ptr %subtreeA.sroa.2.0.arrayidx.i289.sroa_idx, align 2
  %subtreeA.sroa.3.0.arrayidx.i289.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i289, i64 4
  %subtreeA.sroa.3.0.copyload = load i16, ptr %subtreeA.sroa.3.0.arrayidx.i289.sroa_idx, align 4
  %subtreeA.sroa.4.0.arrayidx.i289.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i289, i64 6
  %subtreeA.sroa.4.0.copyload = load i16, ptr %subtreeA.sroa.4.0.arrayidx.i289.sroa_idx, align 2
  %subtreeA.sroa.5.0.arrayidx.i289.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i289, i64 8
  %subtreeA.sroa.5.0.copyload = load i16, ptr %subtreeA.sroa.5.0.arrayidx.i289.sroa_idx, align 8
  %subtreeA.sroa.6.0.arrayidx.i289.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i289, i64 10
  %subtreeA.sroa.6.0.copyload = load i16, ptr %subtreeA.sroa.6.0.arrayidx.i289.sroa_idx, align 2
  %subtreeA.sroa.7.0.arrayidx.i289.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i289, i64 12
  %subtreeA.sroa.7.0.copyload = load i32, ptr %subtreeA.sroa.7.0.arrayidx.i289.sroa_idx, align 4
  %55 = load ptr, ptr %m_data.i, align 8
  %arrayidx.i292 = getelementptr inbounds %struct.b3BvhInfo, ptr %55, i64 %idxprom.i
  %m_quantization = getelementptr inbounds %struct.b3BvhInfo, ptr %55, i64 %idxprom.i, i32 2
  %56 = load float, ptr %m_quantization, align 16
  %y.i = getelementptr inbounds %struct.anon.2, ptr %m_quantization, i64 0, i32 1
  %57 = load float, ptr %y.i, align 4
  %z.i = getelementptr inbounds %struct.anon.2, ptr %m_quantization, i64 0, i32 2
  %58 = load float, ptr %z.i, align 8
  %59 = load float, ptr %arrayidx.i292, align 16
  %arrayidx3.i5.i = getelementptr inbounds [4 x float], ptr %arrayidx.i292, i64 0, i64 1
  %60 = load float, ptr %arrayidx3.i5.i, align 4
  %arrayidx6.i.i = getelementptr inbounds [4 x float], ptr %arrayidx.i292, i64 0, i64 2
  %61 = load float, ptr %arrayidx6.i.i, align 8
  %62 = insertelement <2 x i16> poison, i16 %subtreeA.sroa.4.0.copyload, i64 0
  %63 = insertelement <2 x i16> %62, i16 %subtreeA.sroa.0.0.copyload, i64 1
  %64 = uitofp <2 x i16> %63 to <2 x float>
  %65 = insertelement <2 x float> poison, float %56, i64 0
  %66 = shufflevector <2 x float> %65, <2 x float> poison, <2 x i32> zeroinitializer
  %67 = fdiv <2 x float> %64, %66
  %68 = insertelement <2 x float> poison, float %59, i64 0
  %69 = shufflevector <2 x float> %68, <2 x float> poison, <2 x i32> zeroinitializer
  %70 = fadd <2 x float> %67, %69
  %71 = insertelement <2 x i16> poison, i16 %subtreeA.sroa.5.0.copyload, i64 0
  %72 = insertelement <2 x i16> %71, i16 %subtreeA.sroa.2.0.copyload, i64 1
  %73 = uitofp <2 x i16> %72 to <2 x float>
  %74 = insertelement <2 x float> poison, float %57, i64 0
  %75 = shufflevector <2 x float> %74, <2 x float> poison, <2 x i32> zeroinitializer
  %76 = fdiv <2 x float> %73, %75
  %77 = insertelement <2 x float> poison, float %60, i64 0
  %78 = shufflevector <2 x float> %77, <2 x float> poison, <2 x i32> zeroinitializer
  %79 = fadd <2 x float> %76, %78
  %80 = insertelement <2 x i16> poison, i16 %subtreeA.sroa.6.0.copyload, i64 0
  %81 = insertelement <2 x i16> %80, i16 %subtreeA.sroa.3.0.copyload, i64 1
  %82 = uitofp <2 x i16> %81 to <2 x float>
  %83 = insertelement <2 x float> poison, float %58, i64 0
  %84 = shufflevector <2 x float> %83, <2 x float> poison, <2 x i32> zeroinitializer
  %85 = fdiv <2 x float> %82, %84
  %86 = insertelement <2 x float> poison, float %61, i64 0
  %87 = shufflevector <2 x float> %86, <2 x float> poison, <2 x i32> zeroinitializer
  %88 = fadd <2 x float> %85, %87
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %retval.i)
  call void @_ZNK11b3Matrix3x311getRotationER12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(48) %transA, ptr noundef nonnull align 16 dereferenceable(16) %retval.i)
  %.fca.0.load.i = load <2 x float>, ptr %retval.i, align 16
  %.fca.1.load.i = load <2 x float>, ptr %.fca.1.gep.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %retval.i)
  %89 = extractelement <2 x float> %70, i64 0
  %90 = extractelement <2 x float> %70, i64 1
  %sub.i.i325 = fsub float %89, %90
  %91 = extractelement <2 x float> %79, i64 0
  %92 = extractelement <2 x float> %79, i64 1
  %sub4.i.i = fsub float %91, %92
  %93 = extractelement <2 x float> %88, i64 0
  %94 = extractelement <2 x float> %88, i64 1
  %sub7.i.i = fsub float %93, %94
  %mul.i.i.i = fmul float %sub.i.i325, 5.000000e-01
  %mul2.i.i.i = fmul float %sub4.i.i, 5.000000e-01
  %mul4.i.i.i = fmul float %sub7.i.i, 5.000000e-01
  %add.i.i327 = fadd float %mul.i.i.i, 0.000000e+00
  %add5.i.i328 = fadd float %mul2.i.i.i, 0.000000e+00
  %add8.i.i329 = fadd float %mul4.i.i.i, 0.000000e+00
  %add.i8.i = fadd float %89, %90
  %add4.i.i = fadd float %91, %92
  %add7.i.i = fadd float %93, %94
  %mul.i.i18.i = fmul float %add.i8.i, 5.000000e-01
  %mul2.i.i20.i = fmul float %add4.i.i, 5.000000e-01
  %mul4.i.i22.i = fmul float %add7.i.i, 5.000000e-01
  %95 = extractelement <2 x float> %.fca.0.load.i, i64 1
  %mul4.i.i.i.i.i.i = fmul float %95, %95
  %96 = extractelement <2 x float> %.fca.0.load.i, i64 0
  %97 = call float @llvm.fmuladd.f32(float %96, float %96, float %mul4.i.i.i.i.i.i)
  %ref.tmp.sroa.3.8.vec.extract = extractelement <2 x float> %.fca.1.load.i, i64 0
  %98 = call float @llvm.fmuladd.f32(float %ref.tmp.sroa.3.8.vec.extract, float %ref.tmp.sroa.3.8.vec.extract, float %97)
  %ref.tmp.sroa.3.12.vec.extract = extractelement <2 x float> %.fca.1.load.i, i64 1
  %99 = call noundef float @llvm.fmuladd.f32(float %ref.tmp.sroa.3.12.vec.extract, float %ref.tmp.sroa.3.12.vec.extract, float %98)
  %div.i.i.i.i = fdiv float 2.000000e+00, %99
  %mul.i.i.i.i = fmul float %96, %div.i.i.i.i
  %mul4.i.i.i.i330 = fmul float %95, %div.i.i.i.i
  %mul20.i.i.i.i = fmul float %95, %mul4.i.i.i.i330
  %100 = load <4 x float>, ptr %m_origin.i, align 16
  %101 = shufflevector <4 x float> %100, <4 x float> poison, <2 x i32> <i32 0, i32 poison>
  %tr.sroa.23.48.copyload.i.i = load float, ptr %tr.sroa.23.48.translation.sroa_idx.i.i, align 4
  %tr.sroa.24.48.copyload.i.i = load float, ptr %tr.sroa.24.48.translation.sroa_idx.i.i, align 8
  %102 = shufflevector <2 x float> %.fca.0.load.i, <2 x float> %.fca.1.load.i, <2 x i32> <i32 0, i32 2>
  %103 = insertelement <2 x float> poison, float %mul.i.i.i.i, i64 0
  %104 = insertelement <2 x float> %103, float %div.i.i.i.i, i64 1
  %105 = fmul <2 x float> %102, %104
  %106 = shufflevector <2 x float> %105, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %107 = shufflevector <2 x float> %.fca.1.load.i, <2 x float> poison, <2 x i32> <i32 1, i32 1>
  %108 = insertelement <2 x float> %106, float %mul.i.i.i.i, i64 1
  %109 = fmul <2 x float> %107, %108
  %110 = insertelement <2 x float> %105, float %mul4.i.i.i.i330, i64 0
  %111 = fmul <2 x float> %.fca.0.load.i, %110
  %112 = fmul <2 x float> %.fca.1.load.i, %106
  %113 = shufflevector <2 x float> %112, <2 x float> %.fca.1.load.i, <2 x i32> <i32 0, i32 3>
  %114 = insertelement <2 x float> poison, float %mul20.i.i.i.i, i64 0
  %115 = insertelement <2 x float> %114, float %mul4.i.i.i.i330, i64 1
  %116 = fadd <2 x float> %113, %115
  %117 = fmul <2 x float> %113, %115
  %118 = shufflevector <2 x float> %116, <2 x float> %117, <2 x i32> <i32 0, i32 3>
  %119 = fadd <2 x float> %111, %109
  %add30.i.i.i.i = extractelement <2 x float> %119, i64 0
  %120 = fadd <2 x float> %105, %112
  %add32.i.i.i.i = extractelement <2 x float> %120, i64 0
  %sub33.i.i.i.i = fsub float 1.000000e+00, %add32.i.i.i.i
  %121 = fsub <2 x float> %111, %109
  %sub35.i.i.i.i = extractelement <2 x float> %121, i64 1
  %122 = insertelement <2 x float> %.fca.0.load.i, float %mul20.i.i.i.i, i64 1
  %123 = fmul <2 x float> %122, %106
  %124 = fadd <2 x float> %122, %106
  %125 = shufflevector <2 x float> %123, <2 x float> %124, <2 x i32> <i32 0, i32 3>
  %126 = shufflevector <2 x float> %125, <2 x float> <float 1.000000e+00, float poison>, <2 x i32> <i32 2, i32 0>
  %127 = fsub <2 x float> %126, %118
  %128 = fsub <2 x float> %111, %109
  %129 = fadd <2 x float> %111, %109
  %130 = shufflevector <2 x float> %128, <2 x float> %129, <2 x i32> <i32 0, i32 3>
  %131 = shufflevector <2 x float> %118, <2 x float> <float poison, float 1.000000e+00>, <2 x i32> <i32 1, i32 3>
  %132 = fadd <2 x float> %131, %125
  %133 = fsub <2 x float> %131, %125
  %134 = shufflevector <2 x float> %132, <2 x float> %133, <2 x i32> <i32 0, i32 3>
  %135 = call noundef float @llvm.fabs.f32(float %add30.i.i.i.i)
  %136 = call noundef float @llvm.fabs.f32(float %sub33.i.i.i.i)
  %137 = call noundef float @llvm.fabs.f32(float %sub35.i.i.i.i)
  %138 = call <2 x float> @llvm.fabs.v2f32(<2 x float> %127)
  %139 = call <2 x float> @llvm.fabs.v2f32(<2 x float> %130)
  %140 = call <2 x float> @llvm.fabs.v2f32(<2 x float> %134)
  %mul5.i3.i.i.i.i = fmul float %mul2.i.i20.i, %sub33.i.i.i.i
  %141 = call float @llvm.fmuladd.f32(float %mul.i.i18.i, float %add30.i.i.i.i, float %mul5.i3.i.i.i.i)
  %142 = call noundef float @llvm.fmuladd.f32(float %mul4.i.i22.i, float %sub35.i.i.i.i, float %141)
  %143 = insertelement <2 x float> poison, float %mul2.i.i20.i, i64 0
  %144 = shufflevector <2 x float> %143, <2 x float> poison, <2 x i32> zeroinitializer
  %145 = fmul <2 x float> %144, %130
  %146 = insertelement <2 x float> poison, float %mul.i.i18.i, i64 0
  %147 = shufflevector <2 x float> %146, <2 x float> poison, <2 x i32> zeroinitializer
  %148 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %147, <2 x float> %127, <2 x float> %145)
  %149 = insertelement <2 x float> poison, float %mul4.i.i22.i, i64 0
  %150 = shufflevector <2 x float> %149, <2 x float> poison, <2 x i32> zeroinitializer
  %151 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %150, <2 x float> %134, <2 x float> %148)
  %add4.i.i.i.i = fadd float %tr.sroa.23.48.copyload.i.i, %142
  %152 = insertelement <2 x float> %101, float %tr.sroa.24.48.copyload.i.i, i64 1
  %153 = fadd <2 x float> %152, %151
  %mul5.i.i73.i = fmul float %add5.i.i328, %136
  %154 = call float @llvm.fmuladd.f32(float %add.i.i327, float %135, float %mul5.i.i73.i)
  %155 = call noundef float @llvm.fmuladd.f32(float %add8.i.i329, float %137, float %154)
  %156 = insertelement <2 x float> poison, float %add5.i.i328, i64 0
  %157 = shufflevector <2 x float> %156, <2 x float> poison, <2 x i32> zeroinitializer
  %158 = fmul <2 x float> %157, %139
  %159 = insertelement <2 x float> poison, float %add.i.i327, i64 0
  %160 = shufflevector <2 x float> %159, <2 x float> poison, <2 x i32> zeroinitializer
  %161 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %160, <2 x float> %138, <2 x float> %158)
  %162 = insertelement <2 x float> poison, float %add8.i.i329, i64 0
  %163 = shufflevector <2 x float> %162, <2 x float> poison, <2 x i32> zeroinitializer
  %164 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %163, <2 x float> %140, <2 x float> %161)
  %sub4.i91.i = fsub float %add4.i.i.i.i, %155
  %165 = fsub <2 x float> %153, %164
  %166 = fadd <2 x float> %153, %164
  %add.i100.i = extractelement <2 x float> %166, i64 0
  %add4.i103.i = fadd float %add4.i.i.i.i, %155
  %167 = fadd <2 x float> %153, %164
  br i1 %cmp571746, label %for.body58, label %for.inc403

for.body58:                                       ; preds = %for.body, %for.inc
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ]
  %168 = load ptr, ptr %m_data.i287, align 8
  %169 = getelementptr %class.b3BvhSubtreeInfo, ptr %168, i64 %indvars.iv
  %arrayidx.i333 = getelementptr %class.b3BvhSubtreeInfo, ptr %169, i64 %45
  %subtreeB.sroa.0.0.copyload = load i16, ptr %arrayidx.i333, align 16
  %subtreeB.sroa.2.0.arrayidx.i333.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i333, i64 2
  %subtreeB.sroa.2.0.copyload = load i16, ptr %subtreeB.sroa.2.0.arrayidx.i333.sroa_idx, align 2
  %subtreeB.sroa.3.0.arrayidx.i333.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i333, i64 4
  %subtreeB.sroa.3.0.copyload = load i16, ptr %subtreeB.sroa.3.0.arrayidx.i333.sroa_idx, align 4
  %subtreeB.sroa.4.0.arrayidx.i333.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i333, i64 6
  %subtreeB.sroa.4.0.copyload = load i16, ptr %subtreeB.sroa.4.0.arrayidx.i333.sroa_idx, align 2
  %subtreeB.sroa.5.0.arrayidx.i333.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i333, i64 8
  %subtreeB.sroa.5.0.copyload = load i16, ptr %subtreeB.sroa.5.0.arrayidx.i333.sroa_idx, align 8
  %subtreeB.sroa.6.0.arrayidx.i333.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i333, i64 10
  %subtreeB.sroa.6.0.copyload = load i16, ptr %subtreeB.sroa.6.0.arrayidx.i333.sroa_idx, align 2
  %subtreeB.sroa.7.0.arrayidx.i333.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i333, i64 12
  %subtreeB.sroa.7.0.copyload = load i32, ptr %subtreeB.sroa.7.0.arrayidx.i333.sroa_idx, align 4
  %170 = load ptr, ptr %m_data.i, align 8
  %arrayidx.i336 = getelementptr inbounds %struct.b3BvhInfo, ptr %170, i64 %idxprom.i231
  %m_quantization64 = getelementptr inbounds %struct.b3BvhInfo, ptr %170, i64 %idxprom.i231, i32 2
  %conv.i340 = uitofp i16 %subtreeB.sroa.0.0.copyload to float
  %171 = load float, ptr %m_quantization64, align 16
  %div.i341 = fdiv float %conv.i340, %171
  %conv3.i343 = uitofp i16 %subtreeB.sroa.2.0.copyload to float
  %y.i344 = getelementptr inbounds %struct.anon.2, ptr %m_quantization64, i64 0, i32 1
  %172 = load float, ptr %y.i344, align 4
  %div4.i345 = fdiv float %conv3.i343, %172
  %conv7.i347 = uitofp i16 %subtreeB.sroa.3.0.copyload to float
  %z.i348 = getelementptr inbounds %struct.anon.2, ptr %m_quantization64, i64 0, i32 2
  %173 = load float, ptr %z.i348, align 8
  %div8.i349 = fdiv float %conv7.i347, %173
  %174 = load float, ptr %arrayidx.i336, align 16
  %add.i.i350 = fadd float %div.i341, %174
  %arrayidx3.i5.i351 = getelementptr inbounds [4 x float], ptr %arrayidx.i336, i64 0, i64 1
  %175 = load float, ptr %arrayidx3.i5.i351, align 4
  %add5.i.i352 = fadd float %div4.i345, %175
  %arrayidx6.i.i354 = getelementptr inbounds [4 x float], ptr %arrayidx.i336, i64 0, i64 2
  %176 = load float, ptr %arrayidx6.i.i354, align 8
  %add8.i.i355 = fadd float %div8.i349, %176
  %conv.i365 = uitofp i16 %subtreeB.sroa.4.0.copyload to float
  %div.i366 = fdiv float %conv.i365, %171
  %conv3.i368 = uitofp i16 %subtreeB.sroa.5.0.copyload to float
  %div4.i370 = fdiv float %conv3.i368, %172
  %conv7.i372 = uitofp i16 %subtreeB.sroa.6.0.copyload to float
  %div8.i374 = fdiv float %conv7.i372, %173
  %add.i.i375 = fadd float %div.i366, %174
  %add5.i.i377 = fadd float %div4.i370, %175
  %add8.i.i380 = fadd float %div8.i374, %176
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %temp.i)
  br i1 %cmp.i1487, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %for.body58
  %call.i.i = call noundef float @sqrtf(float noundef %add9.i) #26
  %div.i1494 = fdiv float 5.000000e-01, %call.i.i
  %177 = insertelement <2 x float> poison, float %call.i.i, i64 0
  %178 = insertelement <2 x float> %177, float %div.i1494, i64 1
  %179 = fmul <2 x float> %178, %47
  %180 = shufflevector <2 x float> %178, <2 x float> poison, <2 x i32> <i32 1, i32 1>
  %181 = fmul <2 x float> %180, %44
  br label %_ZNK11b3Matrix3x311getRotationER12b3Quaternion.exit

if.else.i:                                        ; preds = %for.body58
  %182 = load float, ptr %arrayidx69.i, align 4
  %183 = load float, ptr %arrayidx75.i, align 4
  %sub76.i = fsub float %182, %183
  %184 = load float, ptr %arrayidx82.i, align 4
  %sub83.i = fsub float %sub76.i, %184
  %add84.i = fadd float %sub83.i, 1.000000e+00
  %call.i39.i = call noundef float @sqrtf(float noundef %add84.i) #26
  %mul86.i = fmul float %call.i39.i, 5.000000e-01
  store float %mul86.i, ptr %arrayidx88.i, align 4
  %div89.i = fdiv float 5.000000e-01, %call.i39.i
  %185 = load float, ptr %arrayidx95.i, align 4
  %186 = load float, ptr %arrayidx101.i, align 4
  %sub102.i = fsub float %185, %186
  %mul103.i = fmul float %div89.i, %sub102.i
  store float %mul103.i, ptr %arrayidx104.i, align 4
  %187 = load float, ptr %arrayidx110.i, align 4
  %188 = load float, ptr %arrayidx116.i, align 4
  %add117.i = fadd float %187, %188
  %mul118.i = fmul float %div89.i, %add117.i
  store float %mul118.i, ptr %arrayidx120.i, align 4
  %189 = load float, ptr %arrayidx126.i, align 4
  %190 = load float, ptr %arrayidx132.i, align 4
  %add133.i = fadd float %189, %190
  %mul134.i = fmul float %div89.i, %add133.i
  store float %mul134.i, ptr %arrayidx136.i, align 4
  %.pre.i = load float, ptr %temp.i, align 16
  %191 = load <2 x float>, ptr %arrayidx138.phi.trans.insert.i, align 4
  %192 = load <4 x float>, ptr %temp.i, align 16
  %193 = shufflevector <4 x float> %192, <4 x float> poison, <2 x i32> <i32 3, i32 poison>
  %194 = insertelement <2 x float> %193, float %.pre.i, i64 1
  br label %_ZNK11b3Matrix3x311getRotationER12b3Quaternion.exit

_ZNK11b3Matrix3x311getRotationER12b3Quaternion.exit: ; preds = %if.then.i, %if.else.i
  %195 = phi <2 x float> [ %194, %if.else.i ], [ %179, %if.then.i ]
  %196 = phi <2 x float> [ %191, %if.else.i ], [ %181, %if.then.i ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %temp.i)
  %sub.i.i391 = fsub float %add.i.i375, %add.i.i350
  %sub4.i.i394 = fsub float %add5.i.i377, %add5.i.i352
  %sub7.i.i397 = fsub float %add8.i.i380, %add8.i.i355
  %mul.i.i.i398 = fmul float %sub.i.i391, 5.000000e-01
  %mul2.i.i.i399 = fmul float %sub4.i.i394, 5.000000e-01
  %mul4.i.i.i400 = fmul float %sub7.i.i397, 5.000000e-01
  %add.i.i401 = fadd float %mul.i.i.i398, 0.000000e+00
  %add5.i.i402 = fadd float %mul2.i.i.i399, 0.000000e+00
  %add8.i.i403 = fadd float %mul4.i.i.i400, 0.000000e+00
  %add.i8.i404 = fadd float %add.i.i375, %add.i.i350
  %add4.i.i405 = fadd float %add5.i.i377, %add5.i.i352
  %add7.i.i406 = fadd float %add8.i.i380, %add8.i.i355
  %mul.i.i18.i407 = fmul float %add.i8.i404, 5.000000e-01
  %mul2.i.i20.i408 = fmul float %add4.i.i405, 5.000000e-01
  %mul4.i.i22.i409 = fmul float %add7.i.i406, 5.000000e-01
  %197 = fmul <2 x float> %196, %196
  %mul4.i.i.i.i.i.i411 = extractelement <2 x float> %197, i64 0
  %198 = extractelement <2 x float> %195, i64 1
  %199 = call float @llvm.fmuladd.f32(float %198, float %198, float %mul4.i.i.i.i.i.i411)
  %200 = extractelement <2 x float> %196, i64 1
  %201 = call float @llvm.fmuladd.f32(float %200, float %200, float %199)
  %202 = extractelement <2 x float> %195, i64 0
  %203 = call noundef float @llvm.fmuladd.f32(float %202, float %202, float %201)
  %div.i.i.i.i414 = fdiv float 2.000000e+00, %203
  %mul.i.i.i.i415 = fmul float %198, %div.i.i.i.i414
  %204 = insertelement <2 x float> poison, float %div.i.i.i.i414, i64 0
  %205 = shufflevector <2 x float> %204, <2 x float> poison, <2 x i32> zeroinitializer
  %206 = fmul <2 x float> %196, %205
  %mul14.i.i.i.i421 = fmul float %198, %mul.i.i.i.i415
  %207 = shufflevector <2 x float> %195, <2 x float> poison, <2 x i32> zeroinitializer
  %208 = insertelement <2 x float> %206, float %mul.i.i.i.i415, i64 0
  %209 = fmul <2 x float> %207, %208
  %210 = shufflevector <2 x float> %209, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %211 = shufflevector <2 x float> %195, <2 x float> %196, <2 x i32> <i32 1, i32 2>
  %212 = fmul <2 x float> %211, %206
  %213 = fmul <2 x float> %196, %206
  %mul24.i.i.i.i426 = extractelement <2 x float> %213, i64 1
  %214 = fadd <2 x float> %212, %210
  %add30.i.i.i.i431 = extractelement <2 x float> %214, i64 0
  %add32.i.i.i.i432 = fadd float %mul14.i.i.i.i421, %mul24.i.i.i.i426
  %sub33.i.i.i.i433 = fsub float 1.000000e+00, %add32.i.i.i.i432
  %215 = fsub <2 x float> %212, %210
  %sub35.i.i.i.i434 = extractelement <2 x float> %215, i64 1
  %216 = call noundef float @llvm.fabs.f32(float %add30.i.i.i.i431)
  %217 = call noundef float @llvm.fabs.f32(float %sub33.i.i.i.i433)
  %218 = call noundef float @llvm.fabs.f32(float %sub35.i.i.i.i434)
  %mul5.i3.i.i.i.i445 = fmul float %mul2.i.i20.i408, %sub33.i.i.i.i433
  %219 = call float @llvm.fmuladd.f32(float %mul.i.i18.i407, float %add30.i.i.i.i431, float %mul5.i3.i.i.i.i445)
  %220 = call noundef float @llvm.fmuladd.f32(float %mul4.i.i22.i409, float %sub35.i.i.i.i434, float %219)
  %add4.i.i.i.i448 = fadd float %tr.sroa.23.48.copyload.i.i441, %220
  %mul5.i.i73.i451 = fmul float %add5.i.i402, %217
  %221 = call float @llvm.fmuladd.f32(float %add.i.i401, float %216, float %mul5.i.i73.i451)
  %222 = call noundef float @llvm.fmuladd.f32(float %add8.i.i403, float %218, float %221)
  %sub4.i91.i454 = fsub float %add4.i.i.i.i448, %222
  %add4.i103.i461 = fadd float %add4.i.i.i.i448, %222
  store i32 0, ptr @numAabbChecks, align 4
  %cmp18.i = fcmp ogt float %sub4.i91.i, %add4.i103.i461
  %cmp22.i = fcmp olt float %add4.i103.i, %sub4.i91.i454
  %or.cond1695 = or i1 %cmp18.i, %cmp22.i
  br i1 %or.cond1695, label %for.inc, label %_Z21b3TestAabbAgainstAabbRK9b3Vector3S1_S1_S1_.exit

_Z21b3TestAabbAgainstAabbRK9b3Vector3S1_S1_S1_.exit: ; preds = %_ZNK11b3Matrix3x311getRotationER12b3Quaternion.exit
  %223 = fmul <2 x float> %196, %206
  %mul20.i.i.i.i424 = extractelement <2 x float> %223, i64 0
  %add41.i.i.i.i437 = fadd float %mul14.i.i.i.i421, %mul20.i.i.i.i424
  %sub42.i.i.i.i438 = fsub float 1.000000e+00, %add41.i.i.i.i437
  %224 = fmul <2 x float> %195, %206
  %225 = fsub <2 x float> %212, %210
  %226 = fadd <2 x float> %212, %210
  %227 = shufflevector <2 x float> %225, <2 x float> %226, <2 x i32> <i32 0, i32 3>
  %shift1793 = shufflevector <2 x float> %224, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %228 = fadd <2 x float> %shift1793, %224
  %add.i.i.i.i427 = fadd float %mul20.i.i.i.i424, %mul24.i.i.i.i426
  %229 = insertelement <2 x float> %224, float 1.000000e+00, i64 0
  %230 = shufflevector <2 x float> %224, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %231 = insertelement <2 x float> %230, float %add.i.i.i.i427, i64 0
  %232 = fsub <2 x float> %229, %231
  %233 = insertelement <2 x float> poison, float %mul2.i.i20.i408, i64 0
  %234 = shufflevector <2 x float> %233, <2 x float> poison, <2 x i32> zeroinitializer
  %235 = fmul <2 x float> %234, %227
  %236 = insertelement <2 x float> poison, float %mul.i.i18.i407, i64 0
  %237 = shufflevector <2 x float> %236, <2 x float> poison, <2 x i32> zeroinitializer
  %238 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %237, <2 x float> %232, <2 x float> %235)
  %239 = insertelement <2 x float> poison, float %mul4.i.i22.i409, i64 0
  %240 = shufflevector <2 x float> %239, <2 x float> poison, <2 x i32> zeroinitializer
  %241 = insertelement <2 x float> %228, float %sub42.i.i.i.i438, i64 1
  %242 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %240, <2 x float> %241, <2 x float> %238)
  %243 = fadd <2 x float> %49, %242
  %244 = call <2 x float> @llvm.fabs.v2f32(<2 x float> %241)
  %245 = call <2 x float> @llvm.fabs.v2f32(<2 x float> %232)
  %246 = call <2 x float> @llvm.fabs.v2f32(<2 x float> %227)
  %247 = insertelement <2 x float> poison, float %add5.i.i402, i64 0
  %248 = shufflevector <2 x float> %247, <2 x float> poison, <2 x i32> zeroinitializer
  %249 = fmul <2 x float> %248, %246
  %250 = insertelement <2 x float> poison, float %add.i.i401, i64 0
  %251 = shufflevector <2 x float> %250, <2 x float> poison, <2 x i32> zeroinitializer
  %252 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %251, <2 x float> %245, <2 x float> %249)
  %253 = insertelement <2 x float> poison, float %add8.i.i403, i64 0
  %254 = shufflevector <2 x float> %253, <2 x float> poison, <2 x i32> zeroinitializer
  %255 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %254, <2 x float> %244, <2 x float> %252)
  %256 = fsub <2 x float> %243, %255
  %257 = fcmp uge <2 x float> %167, %256
  %258 = fadd <2 x float> %243, %255
  %259 = fcmp ule <2 x float> %165, %258
  %260 = fsub <2 x float> %243, %255
  %sub.i88.i453 = extractelement <2 x float> %260, i64 0
  %cmp4.i = fcmp uge float %add.i100.i, %sub.i88.i453
  %261 = extractelement <2 x i1> %259, i64 0
  %or.cond.not = and i1 %261, %cmp4.i
  %262 = and <2 x i1> %259, %257
  %or.cond1694.not = extractelement <2 x i1> %262, i64 1
  %spec.select1707 = select i1 %or.cond1694.not, i1 %or.cond.not, i1 false
  br i1 %spec.select1707, label %if.then.i1498, label %for.inc

if.then.i1498:                                    ; preds = %_Z21b3TestAabbAgainstAabbRK9b3Vector3S1_S1_S1_.exit
  %263 = load ptr, ptr %m_data.i, align 8
  %m_nodeOffset = getelementptr inbounds %struct.b3BvhInfo, ptr %263, i64 %idxprom.i, i32 5
  %264 = load i32, ptr %m_nodeOffset, align 8
  %m_nodeOffset92 = getelementptr inbounds %struct.b3BvhInfo, ptr %263, i64 %idxprom.i231, i32 5
  %265 = load i32, ptr %m_nodeOffset92, align 8
  store i8 1, ptr %m_ownsMemory.i.i, align 8
  store ptr null, ptr %m_data.i.i, align 8
  store i32 0, ptr %m_size.i.i, align 4
  store i32 0, ptr %m_capacity.i.i, align 8
  %call.i.i.i1504 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef 8192, i32 noundef 16)
          to label %call.i.i.i.noexc unwind label %lpad.loopexit.split-lp

call.i.i.i.noexc:                                 ; preds = %if.then.i1498
  %cmp3.i = icmp eq ptr %call.i.i.i1504, null
  br i1 %cmp3.i, label %_ZNK20b3AlignedObjectArrayI6b3Int2E4copyEiiPS0_.exit18.i, label %.noexc

_ZNK20b3AlignedObjectArrayI6b3Int2E4copyEiiPS0_.exit18.i: ; preds = %call.i.i.i.noexc
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc1505 unwind label %lpad.loopexit.split-lp

.noexc1505:                                       ; preds = %_ZNK20b3AlignedObjectArrayI6b3Int2E4copyEiiPS0_.exit18.i
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc unwind label %lpad.loopexit.split-lp

.noexc:                                           ; preds = %.noexc1505, %call.i.i.i.noexc
  %_Count.addr.0.i = phi i32 [ 1024, %call.i.i.i.noexc ], [ 0, %.noexc1505 ]
  store i8 1, ptr %m_ownsMemory.i.i, align 8
  store ptr %call.i.i.i1504, ptr %m_data.i.i, align 8
  store i32 %_Count.addr.0.i, ptr %m_capacity.i.i, align 8
  br label %for.body9.i

for.body9.i:                                      ; preds = %for.body9.i, %.noexc
  %indvars.iv.i = phi i64 [ 0, %.noexc ], [ %indvars.iv.next.i, %for.body9.i ]
  %arrayidx12.i = getelementptr inbounds %struct.b3Int2, ptr %call.i.i.i1504, i64 %indvars.iv.i
  store i64 0, ptr %arrayidx12.i, align 4
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, 1024
  br i1 %exitcond.not.i, label %invoke.cont, label %for.body9.i, !llvm.loop !42

invoke.cont:                                      ; preds = %for.body9.i
  store i32 1024, ptr %m_size.i.i, align 4
  %add93 = add nsw i32 %265, %subtreeB.sroa.7.0.copyload
  %add89 = add nsw i32 %264, %subtreeA.sroa.7.0.copyload
  store i32 %add89, ptr %call.i.i.i1504, align 4
  %node0.sroa.2.0.call96.sroa_idx = getelementptr inbounds i8, ptr %call.i.i.i1504, i64 4
  store i32 %add93, ptr %node0.sroa.2.0.call96.sroa_idx, align 4
  br label %do.body

do.body:                                          ; preds = %do.cond396, %invoke.cont
  %depth.0 = phi i32 [ 1, %invoke.cont ], [ %depth.1, %do.cond396 ]
  %266 = load i32, ptr @maxDepth, align 4
  %cmp97 = icmp sgt i32 %depth.0, %266
  br i1 %cmp97, label %if.then98, label %if.end101

if.then98:                                        ; preds = %do.body
  store i32 %depth.0, ptr @maxDepth, align 4
  %call100 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.35, i32 noundef %depth.0)
  br label %if.end101

lpad.loopexit:                                    ; preds = %do.body217, %invoke.cont218
  %lpad.loopexit1713 = landingpad { ptr, i32 }
          cleanup
  br label %lpad

lpad.loopexit.split-lp:                           ; preds = %if.then.i1498, %_ZNK20b3AlignedObjectArrayI6b3Int2E4copyEiiPS0_.exit18.i, %.noexc1505
  %lpad.loopexit.split-lp1714 = landingpad { ptr, i32 }
          cleanup
  br label %lpad

lpad:                                             ; preds = %lpad.loopexit.split-lp, %lpad.loopexit
  %lpad.phi = phi { ptr, i32 } [ %lpad.loopexit1713, %lpad.loopexit ], [ %lpad.loopexit.split-lp1714, %lpad.loopexit.split-lp ]
  call void @_ZN20b3AlignedObjectArrayI6b3Int2ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %nodeStack) #26
  resume { ptr, i32 } %lpad.phi

if.end101:                                        ; preds = %if.then98, %do.body
  %dec = add nsw i32 %depth.0, -1
  %267 = load ptr, ptr %m_data.i.i, align 8
  %idxprom.i479 = sext i32 %dec to i64
  %arrayidx.i480 = getelementptr inbounds %struct.b3Int2, ptr %267, i64 %idxprom.i479
  %node.sroa.0.0.copyload = load i32, ptr %arrayidx.i480, align 4
  %node.sroa.12.0.call103.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i480, i64 4
  %node.sroa.12.0.copyload = load i32, ptr %node.sroa.12.0.call103.sroa_idx, align 4
  %268 = load ptr, ptr %m_data.i481, align 8
  %idxprom.i482 = sext i32 %node.sroa.0.0.copyload to i64
  %arrayidx.i483 = getelementptr inbounds %struct.b3QuantizedBvhNode, ptr %268, i64 %idxprom.i482
  %269 = load ptr, ptr %m_data.i, align 8
  %arrayidx.i486 = getelementptr inbounds %struct.b3BvhInfo, ptr %269, i64 %idxprom.i
  %m_quantization111 = getelementptr inbounds %struct.b3BvhInfo, ptr %269, i64 %idxprom.i, i32 2
  %270 = load i16, ptr %arrayidx.i483, align 2
  %conv.i490 = uitofp i16 %270 to float
  %271 = load float, ptr %m_quantization111, align 16
  %div.i491 = fdiv float %conv.i490, %271
  %arrayidx2.i492 = getelementptr inbounds i16, ptr %arrayidx.i483, i64 1
  %272 = load i16, ptr %arrayidx2.i492, align 2
  %conv3.i493 = uitofp i16 %272 to float
  %y.i494 = getelementptr inbounds %struct.anon.2, ptr %m_quantization111, i64 0, i32 1
  %273 = load float, ptr %y.i494, align 4
  %div4.i495 = fdiv float %conv3.i493, %273
  %arrayidx6.i496 = getelementptr inbounds i16, ptr %arrayidx.i483, i64 2
  %274 = load i16, ptr %arrayidx6.i496, align 2
  %conv7.i497 = uitofp i16 %274 to float
  %z.i498 = getelementptr inbounds %struct.anon.2, ptr %m_quantization111, i64 0, i32 2
  %275 = load float, ptr %z.i498, align 8
  %div8.i499 = fdiv float %conv7.i497, %275
  %276 = load float, ptr %arrayidx.i486, align 16
  %add.i.i500 = fadd float %div.i491, %276
  %arrayidx3.i5.i501 = getelementptr inbounds [4 x float], ptr %arrayidx.i486, i64 0, i64 1
  %277 = load float, ptr %arrayidx3.i5.i501, align 4
  %add5.i.i502 = fadd float %div4.i495, %277
  %arrayidx6.i.i504 = getelementptr inbounds [4 x float], ptr %arrayidx.i486, i64 0, i64 2
  %278 = load float, ptr %arrayidx6.i.i504, align 8
  %add8.i.i505 = fadd float %div8.i499, %278
  %m_quantizedAabbMax122 = getelementptr inbounds %struct.b3QuantizedBvhNodeData, ptr %arrayidx.i483, i64 0, i32 1
  %279 = load i16, ptr %m_quantizedAabbMax122, align 2
  %conv.i518 = uitofp i16 %279 to float
  %div.i519 = fdiv float %conv.i518, %271
  %arrayidx2.i520 = getelementptr inbounds %struct.b3QuantizedBvhNodeData, ptr %arrayidx.i483, i64 0, i32 1, i64 1
  %280 = load i16, ptr %arrayidx2.i520, align 2
  %conv3.i521 = uitofp i16 %280 to float
  %div4.i523 = fdiv float %conv3.i521, %273
  %arrayidx6.i524 = getelementptr inbounds %struct.b3QuantizedBvhNodeData, ptr %arrayidx.i483, i64 0, i32 1, i64 2
  %281 = load i16, ptr %arrayidx6.i524, align 2
  %conv7.i525 = uitofp i16 %281 to float
  %div8.i527 = fdiv float %conv7.i525, %275
  %add.i.i528 = fadd float %276, %div.i519
  %add5.i.i530 = fadd float %277, %div4.i523
  %add8.i.i533 = fadd float %278, %div8.i527
  %idxprom.i538 = sext i32 %node.sroa.12.0.copyload to i64
  %arrayidx.i539 = getelementptr inbounds %struct.b3QuantizedBvhNode, ptr %268, i64 %idxprom.i538
  %arrayidx.i542 = getelementptr inbounds %struct.b3BvhInfo, ptr %269, i64 %idxprom.i231
  %m_quantization141 = getelementptr inbounds %struct.b3BvhInfo, ptr %269, i64 %idxprom.i231, i32 2
  %282 = load i16, ptr %arrayidx.i539, align 2
  %conv.i546 = uitofp i16 %282 to float
  %283 = load float, ptr %m_quantization141, align 16
  %div.i547 = fdiv float %conv.i546, %283
  %arrayidx2.i548 = getelementptr inbounds i16, ptr %arrayidx.i539, i64 1
  %284 = load i16, ptr %arrayidx2.i548, align 2
  %conv3.i549 = uitofp i16 %284 to float
  %y.i550 = getelementptr inbounds %struct.anon.2, ptr %m_quantization141, i64 0, i32 1
  %285 = load float, ptr %y.i550, align 4
  %div4.i551 = fdiv float %conv3.i549, %285
  %arrayidx6.i552 = getelementptr inbounds i16, ptr %arrayidx.i539, i64 2
  %286 = load i16, ptr %arrayidx6.i552, align 2
  %conv7.i553 = uitofp i16 %286 to float
  %z.i554 = getelementptr inbounds %struct.anon.2, ptr %m_quantization141, i64 0, i32 2
  %287 = load float, ptr %z.i554, align 8
  %div8.i555 = fdiv float %conv7.i553, %287
  %288 = load float, ptr %arrayidx.i542, align 16
  %add.i.i556 = fadd float %div.i547, %288
  %arrayidx3.i5.i557 = getelementptr inbounds [4 x float], ptr %arrayidx.i542, i64 0, i64 1
  %289 = load float, ptr %arrayidx3.i5.i557, align 4
  %add5.i.i558 = fadd float %div4.i551, %289
  %arrayidx6.i.i560 = getelementptr inbounds [4 x float], ptr %arrayidx.i542, i64 0, i64 2
  %290 = load float, ptr %arrayidx6.i.i560, align 8
  %add8.i.i561 = fadd float %div8.i555, %290
  %m_quantizedAabbMax152 = getelementptr inbounds %struct.b3QuantizedBvhNodeData, ptr %arrayidx.i539, i64 0, i32 1
  %291 = load i16, ptr %m_quantizedAabbMax152, align 2
  %conv.i574 = uitofp i16 %291 to float
  %div.i575 = fdiv float %conv.i574, %283
  %arrayidx2.i576 = getelementptr inbounds %struct.b3QuantizedBvhNodeData, ptr %arrayidx.i539, i64 0, i32 1, i64 1
  %292 = load i16, ptr %arrayidx2.i576, align 2
  %conv3.i577 = uitofp i16 %292 to float
  %div4.i579 = fdiv float %conv3.i577, %285
  %arrayidx6.i580 = getelementptr inbounds %struct.b3QuantizedBvhNodeData, ptr %arrayidx.i539, i64 0, i32 1, i64 2
  %293 = load i16, ptr %arrayidx6.i580, align 2
  %conv7.i581 = uitofp i16 %293 to float
  %div8.i583 = fdiv float %conv7.i581, %287
  %add.i.i584 = fadd float %288, %div.i575
  %add5.i.i586 = fadd float %289, %div4.i579
  %add8.i.i589 = fadd float %290, %div8.i583
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %temp.i1508)
  %294 = load float, ptr %transA, align 16
  %295 = load float, ptr %arrayidx2.i1.i.i.i, align 4
  %add.i1510 = fadd float %294, %295
  %296 = load float, ptr %arrayidx3.i5.i.i.i, align 8
  %add8.i1512 = fadd float %add.i1510, %296
  %cmp.i1513 = fcmp ogt float %add8.i1512, 0.000000e+00
  br i1 %cmp.i1513, label %if.then.i1567, label %if.else.i1514

if.then.i1567:                                    ; preds = %if.end101
  %add9.i1570 = fadd float %add8.i1512, 1.000000e+00
  %call.i.i1571 = call noundef float @sqrtf(float noundef %add9.i1570) #26
  %mul.i1572 = fmul float %call.i.i1571, 5.000000e-01
  %div.i1573 = fdiv float 5.000000e-01, %call.i.i1571
  %297 = load <4 x float>, ptr %arrayidx2.i4.i.i.i, align 4
  %298 = shufflevector <4 x float> %297, <4 x float> poison, <2 x i32> <i32 0, i32 poison>
  %299 = load <4 x float>, ptr %arrayidx3.i2.i.i.i, align 8
  %300 = shufflevector <4 x float> %299, <4 x float> poison, <2 x i32> <i32 0, i32 poison>
  %301 = load float, ptr %arrayidx3.i.i.i.i, align 8
  %302 = load float, ptr %arrayidx5.i.i.i, align 16
  %sub26.i1579 = fsub float %301, %302
  %mul27.i1580 = fmul float %div.i1573, %sub26.i1579
  %303 = load float, ptr %arrayidx3.i.i.i, align 16
  %304 = load float, ptr %arrayidx2.i.i.i.i, align 4
  %305 = insertelement <2 x float> %298, float %303, i64 1
  %306 = insertelement <2 x float> %300, float %304, i64 1
  %307 = fsub <2 x float> %305, %306
  %308 = insertelement <2 x float> poison, float %div.i1573, i64 0
  %309 = shufflevector <2 x float> %308, <2 x float> poison, <2 x i32> zeroinitializer
  %310 = fmul <2 x float> %309, %307
  br label %invoke.cont175

if.else.i1514:                                    ; preds = %if.end101
  %cmp44.i1515 = fcmp olt float %294, %295
  %cmp51.i1516 = fcmp olt float %295, %296
  %cond.i1517 = select i1 %cmp51.i1516, i32 2, i32 1
  %cmp58.i1518 = fcmp olt float %294, %296
  %cond59.i1519 = select i1 %cmp58.i1518, i32 2, i32 0
  %cond60.i1520 = select i1 %cmp44.i1515, i32 %cond.i1517, i32 %cond59.i1519
  %cond60.fr.i1521 = freeze i32 %cond60.i1520
  %add61.i1522 = add nuw nsw i32 %cond60.fr.i1521, 1
  %311 = icmp eq i32 %add61.i1522, 3
  %rem.i1523 = select i1 %311, i32 0, i32 %add61.i1522
  %add62.i1524 = add nuw nsw i32 %cond60.fr.i1521, 2
  %rem63.i1525 = urem i32 %add62.i1524, 3
  %idxprom.i1526 = zext nneg i32 %cond60.fr.i1521 to i64
  %arrayidx66.i1527 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transA, i64 0, i64 %idxprom.i1526
  %arrayidx69.i1528 = getelementptr inbounds float, ptr %arrayidx66.i1527, i64 %idxprom.i1526
  %312 = load float, ptr %arrayidx69.i1528, align 4
  %idxprom71.i1529 = sext i32 %rem.i1523 to i64
  %arrayidx72.i1530 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transA, i64 0, i64 %idxprom71.i1529
  %arrayidx75.i1531 = getelementptr inbounds float, ptr %arrayidx72.i1530, i64 %idxprom71.i1529
  %313 = load float, ptr %arrayidx75.i1531, align 4
  %sub76.i1532 = fsub float %312, %313
  %idxprom78.i1533 = zext nneg i32 %rem63.i1525 to i64
  %arrayidx79.i1534 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transA, i64 0, i64 %idxprom78.i1533
  %arrayidx82.i1535 = getelementptr inbounds float, ptr %arrayidx79.i1534, i64 %idxprom78.i1533
  %314 = load float, ptr %arrayidx82.i1535, align 4
  %sub83.i1536 = fsub float %sub76.i1532, %314
  %add84.i1537 = fadd float %sub83.i1536, 1.000000e+00
  %call.i39.i1538 = call noundef float @sqrtf(float noundef %add84.i1537) #26
  %mul86.i1539 = fmul float %call.i39.i1538, 5.000000e-01
  %arrayidx88.i1540 = getelementptr inbounds [4 x float], ptr %temp.i1508, i64 0, i64 %idxprom.i1526
  store float %mul86.i1539, ptr %arrayidx88.i1540, align 4
  %div89.i1541 = fdiv float 5.000000e-01, %call.i39.i1538
  %arrayidx95.i1542 = getelementptr inbounds float, ptr %arrayidx79.i1534, i64 %idxprom71.i1529
  %315 = load float, ptr %arrayidx95.i1542, align 4
  %arrayidx101.i1543 = getelementptr inbounds float, ptr %arrayidx72.i1530, i64 %idxprom78.i1533
  %316 = load float, ptr %arrayidx101.i1543, align 4
  %sub102.i1544 = fsub float %315, %316
  %mul103.i1545 = fmul float %div89.i1541, %sub102.i1544
  store float %mul103.i1545, ptr %arrayidx104.i1546, align 4
  %arrayidx110.i1547 = getelementptr inbounds float, ptr %arrayidx72.i1530, i64 %idxprom.i1526
  %317 = load float, ptr %arrayidx110.i1547, align 4
  %arrayidx116.i1548 = getelementptr inbounds float, ptr %arrayidx66.i1527, i64 %idxprom71.i1529
  %318 = load float, ptr %arrayidx116.i1548, align 4
  %add117.i1549 = fadd float %317, %318
  %mul118.i1550 = fmul float %div89.i1541, %add117.i1549
  %arrayidx120.i1551 = getelementptr inbounds [4 x float], ptr %temp.i1508, i64 0, i64 %idxprom71.i1529
  store float %mul118.i1550, ptr %arrayidx120.i1551, align 4
  %arrayidx126.i1552 = getelementptr inbounds float, ptr %arrayidx79.i1534, i64 %idxprom.i1526
  %319 = load float, ptr %arrayidx126.i1552, align 4
  %arrayidx132.i1553 = getelementptr inbounds float, ptr %arrayidx66.i1527, i64 %idxprom78.i1533
  %320 = load float, ptr %arrayidx132.i1553, align 4
  %add133.i1554 = fadd float %319, %320
  %mul134.i1555 = fmul float %div89.i1541, %add133.i1554
  %arrayidx136.i1556 = getelementptr inbounds [4 x float], ptr %temp.i1508, i64 0, i64 %idxprom78.i1533
  store float %mul134.i1555, ptr %arrayidx136.i1556, align 4
  %321 = load <4 x float>, ptr %temp.i1508, align 16
  %322 = shufflevector <4 x float> %321, <4 x float> poison, <2 x i32> <i32 0, i32 poison>
  %.pre40.i1559 = load float, ptr %arrayidx138.phi.trans.insert.i1558, align 4
  %.pre41.i1561 = load float, ptr %arrayidx139.phi.trans.insert.i1560, align 8
  %.pre42.i1562 = load float, ptr %arrayidx104.i1546, align 4
  %323 = insertelement <2 x float> %322, float %.pre41.i1561, i64 1
  br label %invoke.cont175

invoke.cont175:                                   ; preds = %if.else.i1514, %if.then.i1567
  %324 = phi float [ %.pre42.i1562, %if.else.i1514 ], [ %mul.i1572, %if.then.i1567 ]
  %325 = phi float [ %.pre40.i1559, %if.else.i1514 ], [ %mul27.i1580, %if.then.i1567 ]
  %326 = phi <2 x float> [ %323, %if.else.i1514 ], [ %310, %if.then.i1567 ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %temp.i1508)
  %sub.i.i601 = fsub float %add.i.i528, %add.i.i500
  %sub4.i.i604 = fsub float %add5.i.i530, %add5.i.i502
  %sub7.i.i607 = fsub float %add8.i.i533, %add8.i.i505
  %mul.i.i.i608 = fmul float %sub.i.i601, 5.000000e-01
  %mul2.i.i.i609 = fmul float %sub4.i.i604, 5.000000e-01
  %mul4.i.i.i610 = fmul float %sub7.i.i607, 5.000000e-01
  %add.i.i611 = fadd float %mul.i.i.i608, 0.000000e+00
  %add5.i.i612 = fadd float %mul2.i.i.i609, 0.000000e+00
  %add8.i.i613 = fadd float %mul4.i.i.i610, 0.000000e+00
  %add.i8.i614 = fadd float %add.i.i500, %add.i.i528
  %add4.i.i615 = fadd float %add5.i.i502, %add5.i.i530
  %add7.i.i616 = fadd float %add8.i.i505, %add8.i.i533
  %mul.i.i18.i617 = fmul float %add.i8.i614, 5.000000e-01
  %mul2.i.i20.i618 = fmul float %add4.i.i615, 5.000000e-01
  %mul4.i.i22.i619 = fmul float %add7.i.i616, 5.000000e-01
  %mul4.i.i.i.i.i.i621 = fmul float %325, %325
  %327 = extractelement <2 x float> %326, i64 0
  %328 = call float @llvm.fmuladd.f32(float %327, float %327, float %mul4.i.i.i.i.i.i621)
  %329 = extractelement <2 x float> %326, i64 1
  %330 = call float @llvm.fmuladd.f32(float %329, float %329, float %328)
  %331 = call noundef float @llvm.fmuladd.f32(float %324, float %324, float %330)
  %div.i.i.i.i624 = fdiv float 2.000000e+00, %331
  %mul.i.i.i.i625 = fmul float %327, %div.i.i.i.i624
  %tr.sroa.21.48.copyload.i.i649 = load float, ptr %m_origin.i, align 16
  %tr.sroa.23.48.copyload.i.i651 = load float, ptr %tr.sroa.23.48.translation.sroa_idx.i.i, align 4
  %tr.sroa.24.48.copyload.i.i653 = load float, ptr %tr.sroa.24.48.translation.sroa_idx.i.i, align 8
  %332 = insertelement <2 x float> poison, float %mul.i.i.i.i625, i64 0
  %333 = insertelement <2 x float> %332, float %div.i.i.i.i624, i64 1
  %334 = fmul <2 x float> %326, %333
  %335 = insertelement <2 x float> poison, float %324, i64 0
  %336 = shufflevector <2 x float> %335, <2 x float> poison, <2 x i32> zeroinitializer
  %337 = insertelement <2 x float> %334, float %mul.i.i.i.i625, i64 0
  %338 = fmul <2 x float> %336, %337
  %339 = insertelement <2 x float> %326, float %325, i64 0
  %340 = insertelement <2 x float> %334, float %div.i.i.i.i624, i64 0
  %341 = fmul <2 x float> %339, %340
  %342 = extractelement <2 x float> %341, i64 0
  %mul20.i.i.i.i634 = fmul float %325, %342
  %343 = shufflevector <2 x float> %339, <2 x float> %326, <2 x i32> <i32 0, i32 2>
  %344 = shufflevector <2 x float> %334, <2 x float> %341, <2 x i32> <i32 1, i32 2>
  %345 = fmul <2 x float> %343, %344
  %346 = insertelement <2 x float> %336, float %mul20.i.i.i.i634, i64 1
  %347 = fmul <2 x float> %346, %341
  %348 = fadd <2 x float> %346, %341
  %349 = shufflevector <2 x float> %347, <2 x float> %348, <2 x i32> <i32 0, i32 3>
  %350 = fadd <2 x float> %345, %338
  %add30.i.i.i.i641 = extractelement <2 x float> %350, i64 1
  %shift1794 = shufflevector <2 x float> %341, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %351 = fadd <2 x float> %334, %shift1794
  %add32.i.i.i.i642 = extractelement <2 x float> %351, i64 0
  %sub33.i.i.i.i643 = fsub float 1.000000e+00, %add32.i.i.i.i642
  %352 = fsub <2 x float> %345, %338
  %sub35.i.i.i.i644 = extractelement <2 x float> %352, i64 0
  %353 = shufflevector <2 x float> %346, <2 x float> %326, <2 x i32> <i32 1, i32 2>
  %354 = fadd <2 x float> %353, %334
  %355 = fmul <2 x float> %353, %334
  %356 = shufflevector <2 x float> %354, <2 x float> %355, <2 x i32> <i32 0, i32 3>
  %357 = shufflevector <2 x float> %356, <2 x float> <float poison, float 1.000000e+00>, <2 x i32> <i32 1, i32 3>
  %358 = fsub <2 x float> %357, %349
  %359 = fadd <2 x float> %345, %338
  %360 = fsub <2 x float> %345, %338
  %361 = shufflevector <2 x float> %359, <2 x float> %360, <2 x i32> <i32 0, i32 3>
  %362 = shufflevector <2 x float> %349, <2 x float> <float 1.000000e+00, float poison>, <2 x i32> <i32 2, i32 0>
  %363 = fsub <2 x float> %362, %356
  %364 = fadd <2 x float> %362, %356
  %365 = shufflevector <2 x float> %363, <2 x float> %364, <2 x i32> <i32 0, i32 3>
  %366 = call noundef float @llvm.fabs.f32(float %add30.i.i.i.i641)
  %367 = call noundef float @llvm.fabs.f32(float %sub33.i.i.i.i643)
  %368 = call noundef float @llvm.fabs.f32(float %sub35.i.i.i.i644)
  %369 = call <2 x float> @llvm.fabs.v2f32(<2 x float> %358)
  %370 = call <2 x float> @llvm.fabs.v2f32(<2 x float> %361)
  %371 = call <2 x float> @llvm.fabs.v2f32(<2 x float> %365)
  %mul5.i3.i.i.i.i655 = fmul float %mul2.i.i20.i618, %sub33.i.i.i.i643
  %372 = call float @llvm.fmuladd.f32(float %mul.i.i18.i617, float %add30.i.i.i.i641, float %mul5.i3.i.i.i.i655)
  %373 = call noundef float @llvm.fmuladd.f32(float %mul4.i.i22.i619, float %sub35.i.i.i.i644, float %372)
  %374 = insertelement <2 x float> poison, float %mul2.i.i20.i618, i64 0
  %375 = shufflevector <2 x float> %374, <2 x float> poison, <2 x i32> zeroinitializer
  %376 = fmul <2 x float> %375, %361
  %377 = insertelement <2 x float> poison, float %mul.i.i18.i617, i64 0
  %378 = shufflevector <2 x float> %377, <2 x float> poison, <2 x i32> zeroinitializer
  %379 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %378, <2 x float> %358, <2 x float> %376)
  %380 = insertelement <2 x float> poison, float %mul4.i.i22.i619, i64 0
  %381 = shufflevector <2 x float> %380, <2 x float> poison, <2 x i32> zeroinitializer
  %382 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %381, <2 x float> %365, <2 x float> %379)
  %add4.i.i.i.i658 = fadd float %tr.sroa.23.48.copyload.i.i651, %373
  %383 = insertelement <2 x float> poison, float %tr.sroa.24.48.copyload.i.i653, i64 0
  %384 = insertelement <2 x float> %383, float %tr.sroa.21.48.copyload.i.i649, i64 1
  %385 = fadd <2 x float> %384, %382
  %mul5.i.i73.i661 = fmul float %add5.i.i612, %367
  %386 = call float @llvm.fmuladd.f32(float %add.i.i611, float %366, float %mul5.i.i73.i661)
  %387 = call noundef float @llvm.fmuladd.f32(float %add8.i.i613, float %368, float %386)
  %388 = insertelement <2 x float> poison, float %add5.i.i612, i64 0
  %389 = shufflevector <2 x float> %388, <2 x float> poison, <2 x i32> zeroinitializer
  %390 = fmul <2 x float> %389, %370
  %391 = insertelement <2 x float> poison, float %add.i.i611, i64 0
  %392 = shufflevector <2 x float> %391, <2 x float> poison, <2 x i32> zeroinitializer
  %393 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %392, <2 x float> %369, <2 x float> %390)
  %394 = insertelement <2 x float> poison, float %add8.i.i613, i64 0
  %395 = shufflevector <2 x float> %394, <2 x float> poison, <2 x i32> zeroinitializer
  %396 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %395, <2 x float> %371, <2 x float> %393)
  %sub4.i91.i664 = fsub float %add4.i.i.i.i658, %387
  %397 = fsub <2 x float> %385, %396
  %398 = fadd <2 x float> %385, %396
  %add4.i103.i671 = fadd float %add4.i.i.i.i658, %387
  %399 = fadd <2 x float> %385, %396
  %add7.i106.i672 = extractelement <2 x float> %399, i64 0
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %temp.i1585)
  br i1 %cmp.i1487, label %if.then.i1644, label %if.else.i1591

if.then.i1644:                                    ; preds = %invoke.cont175
  %call.i.i1648 = call noundef float @sqrtf(float noundef %add9.i) #26
  %div.i1650 = fdiv float 5.000000e-01, %call.i.i1648
  %400 = insertelement <2 x float> poison, float %div.i1650, i64 0
  %401 = insertelement <2 x float> %400, float %call.i.i1648, i64 1
  %402 = fmul <2 x float> %401, %50
  %403 = shufflevector <2 x float> %400, <2 x float> poison, <2 x i32> zeroinitializer
  %404 = fmul <2 x float> %403, %44
  br label %invoke.cont186

if.else.i1591:                                    ; preds = %invoke.cont175
  %405 = load float, ptr %arrayidx69.i, align 4
  %406 = load float, ptr %arrayidx75.i, align 4
  %sub76.i1609 = fsub float %405, %406
  %407 = load float, ptr %arrayidx82.i, align 4
  %sub83.i1613 = fsub float %sub76.i1609, %407
  %add84.i1614 = fadd float %sub83.i1613, 1.000000e+00
  %call.i39.i1615 = call noundef float @sqrtf(float noundef %add84.i1614) #26
  %mul86.i1616 = fmul float %call.i39.i1615, 5.000000e-01
  store float %mul86.i1616, ptr %arrayidx88.i1617, align 4
  %div89.i1618 = fdiv float 5.000000e-01, %call.i39.i1615
  %408 = load float, ptr %arrayidx95.i, align 4
  %409 = load float, ptr %arrayidx101.i, align 4
  %sub102.i1621 = fsub float %408, %409
  %mul103.i1622 = fmul float %div89.i1618, %sub102.i1621
  store float %mul103.i1622, ptr %arrayidx104.i1623, align 4
  %410 = load float, ptr %arrayidx110.i, align 4
  %411 = load float, ptr %arrayidx116.i, align 4
  %add117.i1626 = fadd float %410, %411
  %mul118.i1627 = fmul float %div89.i1618, %add117.i1626
  store float %mul118.i1627, ptr %arrayidx120.i1628, align 4
  %412 = load float, ptr %arrayidx126.i, align 4
  %413 = load float, ptr %arrayidx132.i, align 4
  %add133.i1631 = fadd float %412, %413
  %mul134.i1632 = fmul float %div89.i1618, %add133.i1631
  store float %mul134.i1632, ptr %arrayidx136.i1633, align 4
  %414 = load <4 x float>, ptr %temp.i1585, align 16
  %415 = shufflevector <4 x float> %414, <4 x float> poison, <2 x i32> <i32 0, i32 poison>
  %416 = load <2 x float>, ptr %arrayidx138.phi.trans.insert.i1635, align 4
  %.pre42.i1639 = load float, ptr %arrayidx104.i1623, align 4
  %417 = insertelement <2 x float> %415, float %.pre42.i1639, i64 1
  br label %invoke.cont186

invoke.cont186:                                   ; preds = %if.else.i1591, %if.then.i1644
  %418 = phi <2 x float> [ %417, %if.else.i1591 ], [ %402, %if.then.i1644 ]
  %419 = phi <2 x float> [ %416, %if.else.i1591 ], [ %404, %if.then.i1644 ]
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %temp.i1585)
  %sub.i.i686 = fsub float %add.i.i584, %add.i.i556
  %sub4.i.i689 = fsub float %add5.i.i586, %add5.i.i558
  %sub7.i.i692 = fsub float %add8.i.i589, %add8.i.i561
  %mul.i.i.i693 = fmul float %sub.i.i686, 5.000000e-01
  %mul2.i.i.i694 = fmul float %sub4.i.i689, 5.000000e-01
  %mul4.i.i.i695 = fmul float %sub7.i.i692, 5.000000e-01
  %add.i.i696 = fadd float %mul.i.i.i693, 0.000000e+00
  %add5.i.i697 = fadd float %mul2.i.i.i694, 0.000000e+00
  %add8.i.i698 = fadd float %mul4.i.i.i695, 0.000000e+00
  %add.i8.i699 = fadd float %add.i.i556, %add.i.i584
  %add4.i.i700 = fadd float %add5.i.i558, %add5.i.i586
  %add7.i.i701 = fadd float %add8.i.i561, %add8.i.i589
  %mul.i.i18.i702 = fmul float %add.i8.i699, 5.000000e-01
  %mul2.i.i20.i703 = fmul float %add4.i.i700, 5.000000e-01
  %mul4.i.i22.i704 = fmul float %add7.i.i701, 5.000000e-01
  %420 = fmul <2 x float> %419, %419
  %mul4.i.i.i.i.i.i706 = extractelement <2 x float> %420, i64 0
  %421 = extractelement <2 x float> %418, i64 0
  %422 = call float @llvm.fmuladd.f32(float %421, float %421, float %mul4.i.i.i.i.i.i706)
  %423 = extractelement <2 x float> %419, i64 1
  %424 = call float @llvm.fmuladd.f32(float %423, float %423, float %422)
  %425 = extractelement <2 x float> %418, i64 1
  %426 = call noundef float @llvm.fmuladd.f32(float %425, float %425, float %424)
  %div.i.i.i.i709 = fdiv float 2.000000e+00, %426
  %mul.i.i.i.i710 = fmul float %421, %div.i.i.i.i709
  %mul8.i.i.i.i713 = fmul float %425, %mul.i.i.i.i710
  %mul14.i.i.i.i716 = fmul float %421, %mul.i.i.i.i710
  %427 = insertelement <2 x float> poison, float %div.i.i.i.i709, i64 0
  %428 = shufflevector <2 x float> %427, <2 x float> poison, <2 x i32> zeroinitializer
  %429 = fmul <2 x float> %419, %428
  %430 = shufflevector <2 x float> %429, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %431 = fmul <2 x float> %418, %429
  %432 = fmul <2 x float> %418, %430
  %shift1795 = shufflevector <2 x float> %429, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %433 = fmul <2 x float> %419, %shift1795
  %mul22.i.i.i.i720 = extractelement <2 x float> %433, i64 0
  %434 = fmul <2 x float> %419, %429
  %435 = extractelement <2 x float> %434, i64 0
  %436 = extractelement <2 x float> %434, i64 1
  %add.i.i.i.i722 = fadd float %435, %436
  %437 = extractelement <2 x float> %431, i64 0
  %438 = extractelement <2 x float> %431, i64 1
  %sub26.i.i.i.i724 = fsub float %437, %438
  %shift1796 = shufflevector <2 x float> %432, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %439 = fadd <2 x float> %432, %shift1796
  %add30.i.i.i.i726 = fadd float %437, %438
  %add32.i.i.i.i727 = fadd float %mul14.i.i.i.i716, %436
  %sub33.i.i.i.i728 = fsub float 1.000000e+00, %add32.i.i.i.i727
  %sub35.i.i.i.i729 = fsub float %mul22.i.i.i.i720, %mul8.i.i.i.i713
  %add39.i.i.i.i731 = fadd float %mul22.i.i.i.i720, %mul8.i.i.i.i713
  %add41.i.i.i.i732 = fadd float %mul14.i.i.i.i716, %435
  %sub42.i.i.i.i733 = fsub float 1.000000e+00, %add41.i.i.i.i732
  %440 = call noundef float @llvm.fabs.f32(float %add30.i.i.i.i726)
  %441 = call noundef float @llvm.fabs.f32(float %sub33.i.i.i.i728)
  %442 = call noundef float @llvm.fabs.f32(float %sub35.i.i.i.i729)
  %mul5.i3.i.i.i.i740 = fmul float %mul2.i.i20.i703, %sub33.i.i.i.i728
  %443 = call float @llvm.fmuladd.f32(float %mul.i.i18.i702, float %add30.i.i.i.i726, float %mul5.i3.i.i.i.i740)
  %444 = call noundef float @llvm.fmuladd.f32(float %mul4.i.i22.i704, float %sub35.i.i.i.i729, float %443)
  %add4.i.i.i.i743 = fadd float %tr.sroa.23.48.copyload.i.i441, %444
  %mul5.i.i73.i746 = fmul float %add5.i.i697, %441
  %445 = call float @llvm.fmuladd.f32(float %add.i.i696, float %440, float %mul5.i.i73.i746)
  %446 = call noundef float @llvm.fmuladd.f32(float %add8.i.i698, float %442, float %445)
  %sub4.i91.i749 = fsub float %add4.i.i.i.i743, %446
  %add4.i103.i756 = fadd float %add4.i.i.i.i743, %446
  %447 = load i32, ptr @numAabbChecks, align 4
  %inc187 = add nsw i32 %447, 1
  store i32 %inc187, ptr @numAabbChecks, align 4
  %448 = insertelement <2 x float> %432, float 1.000000e+00, i64 1
  %449 = shufflevector <2 x float> %432, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %450 = insertelement <2 x float> %449, float %add.i.i.i.i722, i64 1
  %451 = fsub <2 x float> %448, %450
  %452 = call <2 x float> @llvm.fabs.v2f32(<2 x float> %451)
  %453 = insertelement <2 x float> poison, float %add39.i.i.i.i731, i64 0
  %454 = insertelement <2 x float> %453, float %sub26.i.i.i.i724, i64 1
  %455 = call <2 x float> @llvm.fabs.v2f32(<2 x float> %454)
  %456 = insertelement <2 x float> poison, float %sub42.i.i.i.i733, i64 0
  %457 = shufflevector <2 x float> %456, <2 x float> %439, <2 x i32> <i32 0, i32 2>
  %458 = call <2 x float> @llvm.fabs.v2f32(<2 x float> %457)
  %459 = insertelement <2 x float> poison, float %mul2.i.i20.i703, i64 0
  %460 = shufflevector <2 x float> %459, <2 x float> poison, <2 x i32> zeroinitializer
  %461 = fmul <2 x float> %460, %454
  %462 = insertelement <2 x float> poison, float %mul.i.i18.i702, i64 0
  %463 = shufflevector <2 x float> %462, <2 x float> poison, <2 x i32> zeroinitializer
  %464 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %463, <2 x float> %451, <2 x float> %461)
  %465 = insertelement <2 x float> poison, float %mul4.i.i22.i704, i64 0
  %466 = shufflevector <2 x float> %465, <2 x float> poison, <2 x i32> zeroinitializer
  %467 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %466, <2 x float> %457, <2 x float> %464)
  %468 = fadd <2 x float> %52, %467
  %469 = insertelement <2 x float> poison, float %add5.i.i697, i64 0
  %470 = shufflevector <2 x float> %469, <2 x float> poison, <2 x i32> zeroinitializer
  %471 = fmul <2 x float> %470, %455
  %472 = insertelement <2 x float> poison, float %add.i.i696, i64 0
  %473 = shufflevector <2 x float> %472, <2 x float> poison, <2 x i32> zeroinitializer
  %474 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %473, <2 x float> %452, <2 x float> %471)
  %475 = insertelement <2 x float> poison, float %add8.i.i698, i64 0
  %476 = shufflevector <2 x float> %475, <2 x float> poison, <2 x i32> zeroinitializer
  %477 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %476, <2 x float> %458, <2 x float> %474)
  %478 = fsub <2 x float> %468, %477
  %479 = fsub <2 x float> %468, %477
  %sub7.i94.i750 = extractelement <2 x float> %479, i64 0
  %480 = fadd <2 x float> %468, %477
  %481 = fcmp uge <2 x float> %398, %478
  %482 = fcmp ule <2 x float> %397, %480
  %483 = and <2 x i1> %482, %481
  %or.cond1696.not = extractelement <2 x i1> %483, i64 1
  %cmp10.i774 = fcmp uge float %add7.i106.i672, %sub7.i94.i750
  %484 = extractelement <2 x i1> %482, i64 0
  %or.cond1697.not = and i1 %484, %cmp10.i774
  %spec.select1708 = select i1 %or.cond1697.not, i1 %or.cond1696.not, i1 false
  %cmp18.i780 = fcmp ogt float %sub4.i91.i664, %add4.i103.i756
  %cmp22.i784 = fcmp olt float %add4.i103.i671, %sub4.i91.i749
  %or.cond1698 = or i1 %cmp18.i780, %cmp22.i784
  %cond15.i777.not = xor i1 %spec.select1708, true
  %brmerge1699 = or i1 %or.cond1698, %cond15.i777.not
  br i1 %brmerge1699, label %do.cond396, label %if.then192

if.then192:                                       ; preds = %invoke.cont186
  %485 = load ptr, ptr %m_data.i481, align 8
  %m_escapeIndexOrTriangleIndex.i = getelementptr inbounds %struct.b3QuantizedBvhNode, ptr %485, i64 %idxprom.i482, i32 0, i32 2
  %486 = load i32, ptr %m_escapeIndexOrTriangleIndex.i, align 4
  %m_escapeIndexOrTriangleIndex.i795 = getelementptr inbounds %struct.b3QuantizedBvhNode, ptr %485, i64 %idxprom.i538, i32 0, i32 2
  %487 = load i32, ptr %m_escapeIndexOrTriangleIndex.i795, align 4
  %cmp.i796 = icmp slt i32 %487, 0
  %cmp211 = icmp sgt i32 %depth.0, 1021
  br i1 %cmp211, label %land.lhs.true212, label %if.end220

land.lhs.true212:                                 ; preds = %if.then192
  %488 = or i32 %487, %486
  %brmerge.not = icmp sgt i32 %488, -1
  br i1 %brmerge.not, label %if.else371, label %do.body217

do.body217:                                       ; preds = %land.lhs.true212
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.31, i32 noundef 1554)
          to label %invoke.cont218 unwind label %lpad.loopexit

invoke.cont218:                                   ; preds = %do.body217
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.36)
          to label %do.cond396 unwind label %lpad.loopexit

if.end220:                                        ; preds = %if.then192
  %cmp.i791 = icmp slt i32 %486, 0
  br i1 %cmp.i791, label %if.then222, label %if.else322

if.then222:                                       ; preds = %if.end220
  %add224 = add nsw i32 %node.sroa.0.0.copyload, 1
  %idxprom.i798 = sext i32 %add224 to i64
  %m_escapeIndexOrTriangleIndex.i800 = getelementptr inbounds %struct.b3QuantizedBvhNode, ptr %485, i64 %idxprom.i798, i32 0, i32 2
  %489 = load i32, ptr %m_escapeIndexOrTriangleIndex.i800, align 4
  %add234 = add nsw i32 %node.sroa.0.0.copyload, 2
  %add243 = sub i32 %add224, %489
  %cmp.i8011710 = icmp slt i32 %489, 0
  %cond = select i1 %cmp.i8011710, i32 %add243, i32 %add234
  br i1 %cmp.i796, label %if.then245, label %if.else

if.then245:                                       ; preds = %if.then222
  %add247 = add nsw i32 %node.sroa.12.0.copyload, 1
  %idxprom.i807 = sext i32 %add247 to i64
  %m_escapeIndexOrTriangleIndex.i809 = getelementptr inbounds %struct.b3QuantizedBvhNode, ptr %485, i64 %idxprom.i807, i32 0, i32 2
  %490 = load i32, ptr %m_escapeIndexOrTriangleIndex.i809, align 4
  %add258 = add nsw i32 %node.sroa.12.0.copyload, 2
  %add268 = sub i32 %add247, %490
  %cmp.i8101711 = icmp slt i32 %490, 0
  %cond270 = select i1 %cmp.i8101711, i32 %add268, i32 %add258
  %retval.sroa.2.0.insert.ext.i = zext i32 %add247 to i64
  %retval.sroa.2.0.insert.shift.i = shl nuw i64 %retval.sroa.2.0.insert.ext.i, 32
  %retval.sroa.0.0.insert.ext.i = zext i32 %add224 to i64
  %retval.sroa.0.0.insert.insert.i = or disjoint i64 %retval.sroa.2.0.insert.shift.i, %retval.sroa.0.0.insert.ext.i
  %491 = load ptr, ptr %m_data.i.i, align 8
  %arrayidx.i818 = getelementptr inbounds %struct.b3Int2, ptr %491, i64 %idxprom.i479
  store i64 %retval.sroa.0.0.insert.insert.i, ptr %arrayidx.i818, align 4
  %retval.sroa.0.0.insert.ext.i821 = zext i32 %cond to i64
  %retval.sroa.0.0.insert.insert.i822 = or disjoint i64 %retval.sroa.2.0.insert.shift.i, %retval.sroa.0.0.insert.ext.i821
  %idxprom.i824 = sext i32 %depth.0 to i64
  %arrayidx.i825 = getelementptr %struct.b3Int2, ptr %491, i64 %idxprom.i824
  store i64 %retval.sroa.0.0.insert.insert.i822, ptr %arrayidx.i825, align 4
  %retval.sroa.2.0.insert.ext.i826 = zext i32 %cond270 to i64
  %retval.sroa.2.0.insert.shift.i827 = shl nuw i64 %retval.sroa.2.0.insert.ext.i826, 32
  %retval.sroa.0.0.insert.insert.i829 = or disjoint i64 %retval.sroa.2.0.insert.shift.i827, %retval.sroa.0.0.insert.ext.i
  %arrayidx.i832 = getelementptr %struct.b3Int2, ptr %arrayidx.i825, i64 1
  store i64 %retval.sroa.0.0.insert.insert.i829, ptr %arrayidx.i832, align 4
  %retval.sroa.0.0.insert.insert.i836 = or disjoint i64 %retval.sroa.2.0.insert.shift.i827, %retval.sroa.0.0.insert.ext.i821
  %inc300 = add nsw i32 %depth.0, 3
  %arrayidx.i839 = getelementptr %struct.b3Int2, ptr %arrayidx.i825, i64 2
  store i64 %retval.sroa.0.0.insert.insert.i836, ptr %arrayidx.i839, align 4
  br label %do.cond396

if.else:                                          ; preds = %if.then222
  %retval.sroa.2.0.insert.ext.i840 = zext i32 %node.sroa.12.0.copyload to i64
  %retval.sroa.2.0.insert.shift.i841 = shl nuw i64 %retval.sroa.2.0.insert.ext.i840, 32
  %retval.sroa.0.0.insert.ext.i842 = zext i32 %add224 to i64
  %retval.sroa.0.0.insert.insert.i843 = or disjoint i64 %retval.sroa.2.0.insert.shift.i841, %retval.sroa.0.0.insert.ext.i842
  %492 = load ptr, ptr %m_data.i.i, align 8
  %arrayidx.i846 = getelementptr inbounds %struct.b3Int2, ptr %492, i64 %idxprom.i479
  store i64 %retval.sroa.0.0.insert.insert.i843, ptr %arrayidx.i846, align 4
  %retval.sroa.0.0.insert.ext.i849 = zext i32 %cond to i64
  %retval.sroa.0.0.insert.insert.i850 = or disjoint i64 %retval.sroa.2.0.insert.shift.i841, %retval.sroa.0.0.insert.ext.i849
  %inc318 = add nsw i32 %depth.0, 1
  %idxprom.i852 = sext i32 %depth.0 to i64
  %arrayidx.i853 = getelementptr inbounds %struct.b3Int2, ptr %492, i64 %idxprom.i852
  store i64 %retval.sroa.0.0.insert.insert.i850, ptr %arrayidx.i853, align 4
  br label %do.cond396

if.else322:                                       ; preds = %if.end220
  br i1 %cmp.i796, label %if.then324, label %if.else371

if.then324:                                       ; preds = %if.else322
  %add327 = add nsw i32 %node.sroa.12.0.copyload, 1
  %idxprom.i855 = sext i32 %add327 to i64
  %m_escapeIndexOrTriangleIndex.i857 = getelementptr inbounds %struct.b3QuantizedBvhNode, ptr %485, i64 %idxprom.i855, i32 0, i32 2
  %493 = load i32, ptr %m_escapeIndexOrTriangleIndex.i857, align 4
  %add340 = add nsw i32 %node.sroa.12.0.copyload, 2
  %add350 = sub i32 %add327, %493
  %cmp.i8581712 = icmp slt i32 %493, 0
  %cond352 = select i1 %cmp.i8581712, i32 %add350, i32 %add340
  %retval.sroa.2.0.insert.ext.i864 = zext i32 %add327 to i64
  %retval.sroa.2.0.insert.shift.i865 = shl nuw i64 %retval.sroa.2.0.insert.ext.i864, 32
  %retval.sroa.0.0.insert.ext.i866 = zext i32 %node.sroa.0.0.copyload to i64
  %retval.sroa.0.0.insert.insert.i867 = or disjoint i64 %retval.sroa.2.0.insert.shift.i865, %retval.sroa.0.0.insert.ext.i866
  %494 = load ptr, ptr %m_data.i.i, align 8
  %arrayidx.i870 = getelementptr inbounds %struct.b3Int2, ptr %494, i64 %idxprom.i479
  store i64 %retval.sroa.0.0.insert.insert.i867, ptr %arrayidx.i870, align 4
  %retval.sroa.2.0.insert.ext.i871 = zext i32 %cond352 to i64
  %retval.sroa.2.0.insert.shift.i872 = shl nuw i64 %retval.sroa.2.0.insert.ext.i871, 32
  %retval.sroa.0.0.insert.insert.i874 = or disjoint i64 %retval.sroa.2.0.insert.shift.i872, %retval.sroa.0.0.insert.ext.i866
  %inc368 = add nsw i32 %depth.0, 1
  %idxprom.i876 = sext i32 %depth.0 to i64
  %arrayidx.i877 = getelementptr inbounds %struct.b3Int2, ptr %494, i64 %idxprom.i876
  store i64 %retval.sroa.0.0.insert.insert.i874, ptr %arrayidx.i877, align 4
  br label %do.cond396

if.else371:                                       ; preds = %land.lhs.true212, %if.else322
  %495 = load i32, ptr %numCompoundPairsOut, align 4
  %inc372 = add nsw i32 %495, 1
  store i32 %inc372, ptr %numCompoundPairsOut, align 4
  %cmp373 = icmp slt i32 %495, %maxNumCompoundPairsCapacity
  br i1 %cmp373, label %if.then374, label %do.cond396

if.then374:                                       ; preds = %if.else371
  %496 = load ptr, ptr %m_data.i481, align 8
  %m_escapeIndexOrTriangleIndex.i881 = getelementptr inbounds %struct.b3QuantizedBvhNode, ptr %496, i64 %idxprom.i482, i32 0, i32 2
  %497 = load i32, ptr %m_escapeIndexOrTriangleIndex.i881, align 4
  %and3.i = and i32 %497, 2097151
  %m_escapeIndexOrTriangleIndex.i885 = getelementptr inbounds %struct.b3QuantizedBvhNode, ptr %496, i64 %idxprom.i538, i32 0, i32 2
  %498 = load i32, ptr %m_escapeIndexOrTriangleIndex.i885, align 4
  %and3.i886 = and i32 %498, 2097151
  %retval.sroa.5.8.insert.ext.i = zext nneg i32 %and3.i886 to i64
  %retval.sroa.5.8.insert.shift.i = shl nuw nsw i64 %retval.sroa.5.8.insert.ext.i, 32
  %retval.sroa.3.8.insert.ext.i = zext nneg i32 %and3.i to i64
  %retval.sroa.3.8.insert.insert.i = or disjoint i64 %retval.sroa.5.8.insert.shift.i, %retval.sroa.3.8.insert.ext.i
  %idxprom390 = sext i32 %495 to i64
  %arrayidx391 = getelementptr inbounds %struct.b3Int4, ptr %gpuCompoundPairsOut, i64 %idxprom390
  store i64 %retval.sroa.0.0.insert.insert.i890, ptr %arrayidx391, align 16
  %ref.tmp385.sroa.2.0.arrayidx391.sroa_idx = getelementptr inbounds i8, ptr %arrayidx391, i64 8
  store i64 %retval.sroa.3.8.insert.insert.i, ptr %ref.tmp385.sroa.2.0.arrayidx391.sroa_idx, align 8
  br label %do.cond396

do.cond396:                                       ; preds = %invoke.cont186, %if.then324, %if.then374, %if.else371, %if.then245, %if.else, %invoke.cont218
  %depth.1 = phi i32 [ %inc300, %if.then245 ], [ %inc318, %if.else ], [ %inc368, %if.then324 ], [ %dec, %if.then374 ], [ %dec, %if.else371 ], [ %dec, %invoke.cont218 ], [ %dec, %invoke.cont186 ]
  %tobool397.not = icmp eq i32 %depth.1, 0
  br i1 %tobool397.not, label %do.end398, label %do.body, !llvm.loop !43

do.end398:                                        ; preds = %do.cond396
  %499 = load i32, ptr @numAabbChecks, align 4
  %500 = load i32, ptr @maxNumAabbChecks, align 4
  %501 = call i32 @llvm.smax.i32(i32 %499, i32 %500)
  store i32 %501, ptr @maxNumAabbChecks, align 4
  %502 = load ptr, ptr %m_data.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %502, null
  br i1 %tobool.not.i.i.i, label %_ZN20b3AlignedObjectArrayI6b3Int2ED2Ev.exit, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %do.end398
  %503 = load i8, ptr %m_ownsMemory.i.i, align 8
  %504 = and i8 %503, 1
  %tobool2.not.i.i.i = icmp eq i8 %504, 0
  br i1 %tobool2.not.i.i.i, label %_ZN20b3AlignedObjectArrayI6b3Int2ED2Ev.exit, label %if.then3.i.i.i

if.then3.i.i.i:                                   ; preds = %if.then.i.i.i
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %502)
          to label %_ZN20b3AlignedObjectArrayI6b3Int2ED2Ev.exit unwind label %terminate.lpad.i

terminate.lpad.i:                                 ; preds = %if.then3.i.i.i
  %505 = landingpad { ptr, i32 }
          catch ptr null
  %506 = extractvalue { ptr, i32 } %505, 0
  call void @__clang_call_terminate(ptr %506) #27
  unreachable

_ZN20b3AlignedObjectArrayI6b3Int2ED2Ev.exit:      ; preds = %do.end398, %if.then.i.i.i, %if.then3.i.i.i
  store i8 1, ptr %m_ownsMemory.i.i, align 8
  store i32 0, ptr %m_size.i.i, align 4
  store i32 0, ptr %m_capacity.i.i, align 8
  br label %for.inc

for.inc:                                          ; preds = %_ZNK11b3Matrix3x311getRotationER12b3Quaternion.exit, %_Z21b3TestAabbAgainstAabbRK9b3Vector3S1_S1_S1_.exit, %_ZN20b3AlignedObjectArrayI6b3Int2ED2Ev.exit
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond1782.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond1782.not, label %for.inc403, label %for.body58, !llvm.loop !44

for.inc403:                                       ; preds = %for.inc, %for.body
  %indvars.iv.next1784 = add nuw nsw i64 %indvars.iv1783, 1
  %exitcond1788.not = icmp eq i64 %indvars.iv.next1784, %wide.trip.count1787
  br i1 %exitcond1788.not, label %if.end676, label %for.body, !llvm.loop !45

lor.lhs.false:                                    ; preds = %if.end
  %cmp414 = icmp ne i32 %5, 6
  %cond1693 = icmp eq i32 %4, 5
  %or.cond1700 = or i1 %cond1693, %cmp414
  br i1 %or.cond1700, label %if.end676, label %if.then584

if.then420:                                       ; preds = %land.lhs.true12
  %507 = load i32, ptr %arrayidx, align 4
  %cmp4241737 = icmp sgt i32 %507, 0
  br i1 %cmp4241737, label %for.body425.lr.ph, label %if.end676

for.body425.lr.ph:                                ; preds = %if.then420
  %posA432.sroa.3.0.arrayidx4.sroa_idx = getelementptr inbounds i8, ptr %arrayidx4, i64 8
  %m_quat439 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom3, i32 1
  %ornA436.sroa.5.0.m_quat439.sroa_idx = getelementptr inbounds i8, ptr %m_quat439, i64 8
  %ornA436.sroa.7.0.m_quat439.sroa_idx = getelementptr inbounds i8, ptr %m_quat439, i64 12
  %m_data.i909 = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %aabbsLocalSpace, i64 0, i32 5
  %arrayidx2.i1.i.i.i913 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transA456, i64 0, i64 1, i32 0, i32 0, i64 1
  %arrayidx3.i2.i.i.i914 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transA456, i64 0, i64 1, i32 0, i32 0, i64 2
  %arrayidx3.i5.i.i.i915 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transA456, i64 0, i64 2, i32 0, i32 0, i64 2
  %arrayidx4.i6.i.i.i916 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transA456, i64 0, i64 2, i32 0, i32 0, i64 3
  %m_origin.i917 = getelementptr inbounds %class.b3Transform, ptr %transA456, i64 0, i32 1
  %newPosA.sroa.4.0.m_origin.i917.sroa_idx = getelementptr inbounds %class.b3Transform, ptr %transA456, i64 0, i32 1, i32 0, i32 0, i64 2
  %arrayidx3.i.i.i.i948 = getelementptr inbounds [4 x float], ptr %transA456, i64 0, i64 2
  %arrayidx4.i.i.i.i949 = getelementptr inbounds [4 x float], ptr %transA456, i64 0, i64 3
  %arrayidx3.i.i.i950 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transA456, i64 0, i64 1
  %arrayidx4.i3.i.i.i953 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transA456, i64 0, i64 1, i32 0, i32 0, i64 3
  %arrayidx5.i.i.i954 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transA456, i64 0, i64 2
  %arrayidx2.i4.i.i.i955 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transA456, i64 0, i64 2, i32 0, i32 0, i64 1
  %.fca.1.gep.i962 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %retval.i959, i64 0, i32 1
  %tr.sroa.23.48.translation.sroa_idx.i.i1014 = getelementptr inbounds %class.b3Transform, ptr %transA456, i64 0, i32 1, i32 0, i32 0, i64 1
  %retval.sroa.2.0.insert.ext.i1324 = zext i32 %bodyIndexB to i64
  %retval.sroa.2.0.insert.shift.i1325 = shl nuw i64 %retval.sroa.2.0.insert.ext.i1324, 32
  %retval.sroa.0.0.insert.ext.i1326 = zext i32 %bodyIndexA to i64
  %retval.sroa.0.0.insert.insert.i1327 = or disjoint i64 %retval.sroa.2.0.insert.shift.i1325, %retval.sroa.0.0.insert.ext.i1326
  %idxprom483 = sext i32 %bodyIndexB to i64
  %arrayidx484 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom483
  %m_quat485 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom483, i32 1
  %ornB482.sroa.5.0.m_quat485.sroa_idx = getelementptr inbounds i8, ptr %m_quat485, i64 8
  %ornB482.sroa.7.0.m_quat485.sroa_idx = getelementptr inbounds i8, ptr %m_quat485, i64 12
  %posB486.sroa.2.0.arrayidx484.sroa_idx = getelementptr inbounds i8, ptr %arrayidx484, i64 4
  %posB486.sroa.3.0.arrayidx484.sroa_idx = getelementptr inbounds i8, ptr %arrayidx484, i64 8
  %arrayidx2.i1.i.i.i1066 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transB504, i64 0, i64 1, i32 0, i32 0, i64 1
  %arrayidx3.i2.i.i.i1067 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transB504, i64 0, i64 1, i32 0, i32 0, i64 2
  %arrayidx3.i5.i.i.i1068 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transB504, i64 0, i64 2, i32 0, i32 0, i64 2
  %arrayidx4.i6.i.i.i1069 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transB504, i64 0, i64 2, i32 0, i32 0, i64 3
  %m_origin.i1070 = getelementptr inbounds %class.b3Transform, ptr %transB504, i64 0, i32 1
  %newPosB.sroa.2.0.m_origin.i1070.sroa_idx = getelementptr inbounds %class.b3Transform, ptr %transB504, i64 0, i32 1, i32 0, i32 0, i64 2
  %arrayidx3.i.i.i.i1101 = getelementptr inbounds [4 x float], ptr %transB504, i64 0, i64 2
  %arrayidx4.i.i.i.i1102 = getelementptr inbounds [4 x float], ptr %transB504, i64 0, i64 3
  %arrayidx3.i.i.i1103 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transB504, i64 0, i64 1
  %arrayidx4.i3.i.i.i1106 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transB504, i64 0, i64 1, i32 0, i32 0, i64 3
  %arrayidx5.i.i.i1107 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transB504, i64 0, i64 2
  %arrayidx2.i4.i.i.i1108 = getelementptr inbounds [3 x %class.b3Vector3], ptr %transB504, i64 0, i64 2, i32 0, i32 0, i64 1
  %.fca.1.gep.i1115 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %retval.i1112, i64 0, i32 1
  %tr.sroa.23.48.translation.sroa_idx.i.i1167 = getelementptr inbounds %class.b3Transform, ptr %transB504, i64 0, i32 1, i32 0, i32 0, i64 1
  br label %for.body425

for.body425:                                      ; preds = %for.body425.lr.ph, %for.inc571
  %c.01738 = phi i32 [ 0, %for.body425.lr.ph ], [ %inc572, %for.inc571 ]
  %508 = load i32, ptr %0, align 4
  %add429 = add nsw i32 %508, %c.01738
  %idxprom430 = sext i32 %add429 to i64
  %arrayidx431 = getelementptr inbounds %struct.b3GpuChildShape, ptr %gpuChildShapes, i64 %idxprom430
  %509 = getelementptr inbounds %struct.b3GpuChildShape, ptr %gpuChildShapes, i64 %idxprom430, i32 2
  %510 = load i32, ptr %509, align 16
  %posA432.sroa.3.0.copyload = load float, ptr %posA432.sroa.3.0.arrayidx4.sroa_idx, align 8
  %ornA436.sroa.5.0.copyload = load float, ptr %ornA436.sroa.5.0.m_quat439.sroa_idx, align 8
  %ornA436.sroa.7.0.copyload = load float, ptr %ornA436.sroa.7.0.m_quat439.sroa_idx, align 4
  %childPosA.sroa.3.0.arrayidx431.sroa_idx = getelementptr inbounds i8, ptr %arrayidx431, i64 8
  %childPosA.sroa.3.0.copyload = load float, ptr %childPosA.sroa.3.0.arrayidx431.sroa_idx, align 8
  %m_childOrientation = getelementptr inbounds %struct.b3GpuChildShape, ptr %gpuChildShapes, i64 %idxprom430, i32 1
  %childOrnA.sroa.3.0.m_childOrientation.sroa_idx = getelementptr inbounds i8, ptr %m_childOrientation, i64 8
  %childOrnA.sroa.3.0.copyload = load float, ptr %childOrnA.sroa.3.0.m_childOrientation.sroa_idx, align 8
  %childOrnA.sroa.4.0.m_childOrientation.sroa_idx = getelementptr inbounds i8, ptr %m_childOrientation, i64 12
  %childOrnA.sroa.4.0.copyload = load float, ptr %childOrnA.sroa.4.0.m_childOrientation.sroa_idx, align 4
  %neg.i.i = fneg float %ornA436.sroa.5.0.copyload
  %511 = load ptr, ptr %m_data.i909, align 8
  %idxprom.i910 = sext i32 %510 to i64
  %arrayidx.i911 = getelementptr inbounds %struct.b3Aabb, ptr %511, i64 %idxprom.i910
  %aabbA.sroa.0.0.copyload = load float, ptr %arrayidx.i911, align 16
  %aabbA.sroa.2.0.arrayidx.i911.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i911, i64 4
  %aabbA.sroa.2.0.copyload = load float, ptr %aabbA.sroa.2.0.arrayidx.i911.sroa_idx, align 4
  %aabbA.sroa.3.0.arrayidx.i911.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i911, i64 8
  %aabbA.sroa.3.0.copyload = load float, ptr %aabbA.sroa.3.0.arrayidx.i911.sroa_idx, align 8
  %aabbA.sroa.41671.0.arrayidx.i911.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i911, i64 16
  %aabbA.sroa.41671.0.copyload = load float, ptr %aabbA.sroa.41671.0.arrayidx.i911.sroa_idx, align 16
  %aabbA.sroa.5.0.arrayidx.i911.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i911, i64 20
  %aabbA.sroa.5.0.copyload = load float, ptr %aabbA.sroa.5.0.arrayidx.i911.sroa_idx, align 4
  %aabbA.sroa.6.0.arrayidx.i911.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i911, i64 24
  %aabbA.sroa.6.0.copyload = load float, ptr %aabbA.sroa.6.0.arrayidx.i911.sroa_idx, align 8
  %512 = load <2 x float>, ptr %m_quat439, align 16
  %513 = load <2 x float>, ptr %m_childOrientation, align 16
  %514 = fneg <2 x float> %512
  %515 = load <2 x float>, ptr %arrayidx4, align 16
  %516 = load <2 x float>, ptr %arrayidx431, align 16
  %517 = extractelement <2 x float> %516, i64 0
  %mul12.i.i895 = fmul float %ornA436.sroa.5.0.copyload, %517
  %518 = extractelement <2 x float> %516, i64 1
  %519 = call float @llvm.fmuladd.f32(float %ornA436.sroa.7.0.copyload, float %518, float %mul12.i.i895)
  %520 = extractelement <2 x float> %514, i64 0
  %521 = call float @llvm.fmuladd.f32(float %520, float %childPosA.sroa.3.0.copyload, float %519)
  %522 = shufflevector <2 x float> %516, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %523 = insertelement <2 x float> %522, float %childPosA.sroa.3.0.copyload, i64 1
  %524 = fmul <2 x float> %512, %523
  %525 = insertelement <2 x float> poison, float %ornA436.sroa.7.0.copyload, i64 0
  %526 = shufflevector <2 x float> %525, <2 x float> poison, <2 x i32> zeroinitializer
  %527 = insertelement <2 x float> poison, float %childPosA.sroa.3.0.copyload, i64 0
  %528 = shufflevector <2 x float> %527, <2 x float> %516, <2 x i32> <i32 0, i32 2>
  %529 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %526, <2 x float> %528, <2 x float> %524)
  %530 = shufflevector <2 x float> %514, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %531 = insertelement <2 x float> %530, float %neg.i.i, i64 1
  %532 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %531, <2 x float> %516, <2 x float> %529)
  %533 = extractelement <2 x float> %514, i64 1
  %neg31.i.i = fmul float %518, %533
  %534 = call float @llvm.fmuladd.f32(float %520, float %517, float %neg31.i.i)
  %535 = call float @llvm.fmuladd.f32(float %neg.i.i, float %childPosA.sroa.3.0.copyload, float %534)
  %536 = shufflevector <2 x float> %532, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %537 = insertelement <2 x float> %536, float %521, i64 1
  %538 = fmul <2 x float> %526, %537
  %539 = insertelement <2 x float> poison, float %535, i64 0
  %540 = shufflevector <2 x float> %539, <2 x float> poison, <2 x i32> zeroinitializer
  %541 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %540, <2 x float> %514, <2 x float> %538)
  %542 = shufflevector <2 x float> %537, <2 x float> %532, <2 x i32> <i32 1, i32 2>
  %543 = insertelement <2 x float> %530, float %neg.i.i, i64 0
  %544 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %542, <2 x float> %543, <2 x float> %541)
  %545 = shufflevector <2 x float> %512, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %546 = insertelement <2 x float> %545, float %ornA436.sroa.5.0.copyload, i64 1
  %547 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %532, <2 x float> %546, <2 x float> %544)
  %548 = extractelement <2 x float> %532, i64 0
  %mul25.i.i = fmul float %ornA436.sroa.7.0.copyload, %548
  %549 = call float @llvm.fmuladd.f32(float %535, float %neg.i.i, float %mul25.i.i)
  %550 = extractelement <2 x float> %532, i64 1
  %551 = call float @llvm.fmuladd.f32(float %550, float %533, float %549)
  %552 = extractelement <2 x float> %512, i64 0
  %553 = call float @llvm.fmuladd.f32(float %521, float %552, float %551)
  %554 = fadd <2 x float> %515, %547
  %add7.i = fadd float %posA432.sroa.3.0.copyload, %553
  %retval.sroa.3.12.vec.insert.i.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %add7.i, i64 0
  %mul4.i.i900 = fmul float %552, %childOrnA.sroa.4.0.copyload
  %555 = extractelement <2 x float> %513, i64 0
  %556 = call float @llvm.fmuladd.f32(float %ornA436.sroa.7.0.copyload, float %555, float %mul4.i.i900)
  %557 = extractelement <2 x float> %512, i64 1
  %558 = call float @llvm.fmuladd.f32(float %557, float %childOrnA.sroa.3.0.copyload, float %556)
  %559 = extractelement <2 x float> %513, i64 1
  %560 = call float @llvm.fmuladd.f32(float %neg.i.i, float %559, float %558)
  %561 = insertelement <2 x float> poison, float %ornA436.sroa.5.0.copyload, i64 0
  %562 = insertelement <2 x float> %512, float %ornA436.sroa.5.0.copyload, i64 0
  %563 = insertelement <2 x float> poison, float %childOrnA.sroa.4.0.copyload, i64 0
  %564 = shufflevector <2 x float> %563, <2 x float> poison, <2 x i32> zeroinitializer
  %565 = fmul <2 x float> %562, %564
  %566 = insertelement <2 x float> poison, float %childOrnA.sroa.3.0.copyload, i64 0
  %567 = insertelement <2 x float> %513, float %childOrnA.sroa.3.0.copyload, i64 0
  %568 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %526, <2 x float> %567, <2 x float> %565)
  %569 = shufflevector <2 x float> %568, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %570 = shufflevector <2 x float> %561, <2 x float> %512, <2 x i32> <i32 0, i32 2>
  %571 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %570, <2 x float> %513, <2 x float> %569)
  %572 = shufflevector <2 x float> %566, <2 x float> %513, <2 x i32> <i32 0, i32 2>
  %573 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %514, <2 x float> %572, <2 x float> %571)
  %574 = fmul <2 x float> %513, %514
  %neg37.i.i = extractelement <2 x float> %574, i64 0
  %575 = call float @llvm.fmuladd.f32(float %ornA436.sroa.7.0.copyload, float %childOrnA.sroa.4.0.copyload, float %neg37.i.i)
  %576 = call float @llvm.fmuladd.f32(float %533, float %559, float %575)
  %577 = call float @llvm.fmuladd.f32(float %neg.i.i, float %childOrnA.sroa.3.0.copyload, float %576)
  store <2 x float> %554, ptr %m_origin.i917, align 16
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i, ptr %newPosA.sroa.4.0.m_origin.i917.sroa_idx, align 8
  %578 = extractelement <2 x float> %573, i64 0
  %579 = fmul <2 x float> %573, %573
  %mul4.i.i.i.i919 = extractelement <2 x float> %579, i64 0
  %580 = call float @llvm.fmuladd.f32(float %560, float %560, float %mul4.i.i.i.i919)
  %581 = extractelement <2 x float> %573, i64 1
  %582 = call float @llvm.fmuladd.f32(float %581, float %581, float %580)
  %583 = call noundef float @llvm.fmuladd.f32(float %577, float %577, float %582)
  %div.i.i922 = fdiv float 2.000000e+00, %583
  %mul.i.i923 = fmul float %560, %div.i.i922
  %mul4.i.i924 = fmul float %578, %div.i.i922
  %mul8.i.i926 = fmul float %577, %mul.i.i923
  %mul10.i.i927 = fmul float %577, %mul4.i.i924
  %mul14.i.i929 = fmul float %560, %mul.i.i923
  %mul16.i.i930 = fmul float %560, %mul4.i.i924
  %584 = insertelement <2 x float> poison, float %mul4.i.i924, i64 0
  %585 = insertelement <2 x float> %584, float %div.i.i922, i64 1
  %586 = fmul <2 x float> %573, %585
  %587 = extractelement <2 x float> %586, i64 1
  %mul18.i.i931 = fmul float %560, %587
  %mul22.i.i933 = fmul float %578, %587
  %mul24.i.i934 = fmul float %581, %587
  %588 = insertelement <2 x float> poison, float %mul24.i.i934, i64 0
  %589 = insertelement <2 x float> %588, float %577, i64 1
  %590 = fadd <2 x float> %589, %586
  %591 = fmul <2 x float> %589, %586
  %592 = shufflevector <2 x float> %590, <2 x float> %591, <2 x i32> <i32 0, i32 3>
  %593 = insertelement <2 x float> <float 1.000000e+00, float poison>, float %mul16.i.i930, i64 1
  %594 = fsub <2 x float> %593, %592
  %add28.i.i938 = fadd float %mul18.i.i931, %mul10.i.i927
  %595 = extractelement <2 x float> %591, i64 1
  %add30.i.i939 = fadd float %mul16.i.i930, %595
  %add32.i.i940 = fadd float %mul14.i.i929, %mul24.i.i934
  %sub33.i.i941 = fsub float 1.000000e+00, %add32.i.i940
  %sub35.i.i942 = fsub float %mul22.i.i933, %mul8.i.i926
  %sub37.i.i943 = fsub float %mul18.i.i931, %mul10.i.i927
  %add39.i.i944 = fadd float %mul22.i.i933, %mul8.i.i926
  %596 = extractelement <2 x float> %586, i64 0
  %add41.i.i945 = fadd float %mul14.i.i929, %596
  %sub42.i.i946 = fsub float 1.000000e+00, %add41.i.i945
  store <2 x float> %594, ptr %transA456, align 16
  store float %add28.i.i938, ptr %arrayidx3.i.i.i.i948, align 8
  store float 0.000000e+00, ptr %arrayidx4.i.i.i.i949, align 4
  store float %add30.i.i939, ptr %arrayidx3.i.i.i950, align 16
  store float %sub33.i.i941, ptr %arrayidx2.i1.i.i.i913, align 4
  store float %sub35.i.i942, ptr %arrayidx3.i2.i.i.i914, align 8
  store float 0.000000e+00, ptr %arrayidx4.i3.i.i.i953, align 4
  store float %sub37.i.i943, ptr %arrayidx5.i.i.i954, align 16
  store float %add39.i.i944, ptr %arrayidx2.i4.i.i.i955, align 4
  store float %sub42.i.i946, ptr %arrayidx3.i5.i.i.i915, align 8
  store float 0.000000e+00, ptr %arrayidx4.i6.i.i.i916, align 4
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %retval.i959)
  call void @_ZNK11b3Matrix3x311getRotationER12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(48) %transA456, ptr noundef nonnull align 16 dereferenceable(16) %retval.i959)
  %.fca.0.load.i960 = load <2 x float>, ptr %retval.i959, align 16
  %.fca.1.load.i963 = load <2 x float>, ptr %.fca.1.gep.i962, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %retval.i959)
  %sub.i.i965 = fsub float %aabbA.sroa.41671.0.copyload, %aabbA.sroa.0.0.copyload
  %sub4.i.i968 = fsub float %aabbA.sroa.5.0.copyload, %aabbA.sroa.2.0.copyload
  %sub7.i.i971 = fsub float %aabbA.sroa.6.0.copyload, %aabbA.sroa.3.0.copyload
  %mul.i.i.i972 = fmul float %sub.i.i965, 5.000000e-01
  %mul2.i.i.i973 = fmul float %sub4.i.i968, 5.000000e-01
  %mul4.i.i.i974 = fmul float %sub7.i.i971, 5.000000e-01
  %add.i.i975 = fadd float %mul.i.i.i972, 0.000000e+00
  %add5.i.i976 = fadd float %mul2.i.i.i973, 0.000000e+00
  %add8.i.i977 = fadd float %mul4.i.i.i974, 0.000000e+00
  %add.i8.i978 = fadd float %aabbA.sroa.0.0.copyload, %aabbA.sroa.41671.0.copyload
  %add4.i.i979 = fadd float %aabbA.sroa.2.0.copyload, %aabbA.sroa.5.0.copyload
  %add7.i.i980 = fadd float %aabbA.sroa.3.0.copyload, %aabbA.sroa.6.0.copyload
  %mul.i.i18.i981 = fmul float %add.i8.i978, 5.000000e-01
  %mul2.i.i20.i982 = fmul float %add4.i.i979, 5.000000e-01
  %mul4.i.i22.i983 = fmul float %add7.i.i980, 5.000000e-01
  %597 = extractelement <2 x float> %.fca.0.load.i960, i64 1
  %mul4.i.i.i.i.i.i985 = fmul float %597, %597
  %598 = extractelement <2 x float> %.fca.0.load.i960, i64 0
  %599 = call float @llvm.fmuladd.f32(float %598, float %598, float %mul4.i.i.i.i.i.i985)
  %ref.tmp461.sroa.3.8.vec.extract = extractelement <2 x float> %.fca.1.load.i963, i64 0
  %600 = call float @llvm.fmuladd.f32(float %ref.tmp461.sroa.3.8.vec.extract, float %ref.tmp461.sroa.3.8.vec.extract, float %599)
  %ref.tmp461.sroa.3.12.vec.extract = extractelement <2 x float> %.fca.1.load.i963, i64 1
  %601 = call noundef float @llvm.fmuladd.f32(float %ref.tmp461.sroa.3.12.vec.extract, float %ref.tmp461.sroa.3.12.vec.extract, float %600)
  %div.i.i.i.i988 = fdiv float 2.000000e+00, %601
  %mul.i.i.i.i989 = fmul float %598, %div.i.i.i.i988
  %mul4.i.i.i.i990 = fmul float %597, %div.i.i.i.i988
  %mul20.i.i.i.i998 = fmul float %597, %mul4.i.i.i.i990
  %tr.sroa.21.48.copyload.i.i1013 = load float, ptr %m_origin.i917, align 16
  %tr.sroa.23.48.copyload.i.i1015 = load float, ptr %tr.sroa.23.48.translation.sroa_idx.i.i1014, align 4
  %tr.sroa.24.48.copyload.i.i1017 = load float, ptr %newPosA.sroa.4.0.m_origin.i917.sroa_idx, align 8
  %602 = shufflevector <2 x float> %.fca.0.load.i960, <2 x float> %.fca.1.load.i963, <2 x i32> <i32 0, i32 2>
  %603 = insertelement <2 x float> poison, float %mul.i.i.i.i989, i64 0
  %604 = insertelement <2 x float> %603, float %div.i.i.i.i988, i64 1
  %605 = fmul <2 x float> %602, %604
  %606 = shufflevector <2 x float> %.fca.1.load.i963, <2 x float> poison, <2 x i32> <i32 1, i32 1>
  %607 = insertelement <2 x float> %605, float %mul.i.i.i.i989, i64 0
  %608 = fmul <2 x float> %606, %607
  %609 = insertelement <2 x float> %605, float %mul4.i.i.i.i990, i64 0
  %610 = fmul <2 x float> %.fca.0.load.i960, %609
  %611 = shufflevector <2 x float> %610, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %shift1797 = shufflevector <2 x float> %605, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %612 = fmul <2 x float> %.fca.1.load.i963, %shift1797
  %613 = shufflevector <2 x float> %606, <2 x float> %612, <2 x i32> <i32 0, i32 2>
  %614 = insertelement <2 x float> %609, float %mul20.i.i.i.i998, i64 1
  %615 = fmul <2 x float> %613, %614
  %616 = fadd <2 x float> %613, %614
  %617 = shufflevector <2 x float> %615, <2 x float> %616, <2 x i32> <i32 0, i32 3>
  %618 = fadd <2 x float> %611, %608
  %add30.i.i.i.i1005 = extractelement <2 x float> %618, i64 1
  %619 = fadd <2 x float> %605, %612
  %add32.i.i.i.i1006 = extractelement <2 x float> %619, i64 0
  %sub33.i.i.i.i1007 = fsub float 1.000000e+00, %add32.i.i.i.i1006
  %620 = fsub <2 x float> %611, %608
  %sub35.i.i.i.i1008 = extractelement <2 x float> %620, i64 0
  %621 = shufflevector <2 x float> %.fca.0.load.i960, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %622 = insertelement <2 x float> %621, float %mul20.i.i.i.i998, i64 0
  %623 = fadd <2 x float> %622, %605
  %624 = fmul <2 x float> %622, %605
  %625 = shufflevector <2 x float> %623, <2 x float> %624, <2 x i32> <i32 0, i32 3>
  %626 = shufflevector <2 x float> %625, <2 x float> <float poison, float 1.000000e+00>, <2 x i32> <i32 1, i32 3>
  %627 = fsub <2 x float> %626, %617
  %628 = fadd <2 x float> %611, %608
  %629 = fsub <2 x float> %611, %608
  %630 = shufflevector <2 x float> %628, <2 x float> %629, <2 x i32> <i32 0, i32 3>
  %631 = shufflevector <2 x float> %617, <2 x float> <float 1.000000e+00, float poison>, <2 x i32> <i32 2, i32 0>
  %632 = fsub <2 x float> %631, %625
  %633 = fadd <2 x float> %631, %625
  %634 = shufflevector <2 x float> %632, <2 x float> %633, <2 x i32> <i32 0, i32 3>
  %635 = call noundef float @llvm.fabs.f32(float %add30.i.i.i.i1005)
  %636 = call noundef float @llvm.fabs.f32(float %sub33.i.i.i.i1007)
  %637 = call noundef float @llvm.fabs.f32(float %sub35.i.i.i.i1008)
  %638 = call <2 x float> @llvm.fabs.v2f32(<2 x float> %627)
  %639 = call <2 x float> @llvm.fabs.v2f32(<2 x float> %630)
  %640 = call <2 x float> @llvm.fabs.v2f32(<2 x float> %634)
  %mul5.i3.i.i.i.i1019 = fmul float %mul2.i.i20.i982, %sub33.i.i.i.i1007
  %641 = call float @llvm.fmuladd.f32(float %mul.i.i18.i981, float %add30.i.i.i.i1005, float %mul5.i3.i.i.i.i1019)
  %642 = call noundef float @llvm.fmuladd.f32(float %mul4.i.i22.i983, float %sub35.i.i.i.i1008, float %641)
  %643 = insertelement <2 x float> poison, float %mul2.i.i20.i982, i64 0
  %644 = shufflevector <2 x float> %643, <2 x float> poison, <2 x i32> zeroinitializer
  %645 = fmul <2 x float> %644, %630
  %646 = insertelement <2 x float> poison, float %mul.i.i18.i981, i64 0
  %647 = shufflevector <2 x float> %646, <2 x float> poison, <2 x i32> zeroinitializer
  %648 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %647, <2 x float> %627, <2 x float> %645)
  %649 = insertelement <2 x float> poison, float %mul4.i.i22.i983, i64 0
  %650 = shufflevector <2 x float> %649, <2 x float> poison, <2 x i32> zeroinitializer
  %651 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %650, <2 x float> %634, <2 x float> %648)
  %add4.i.i.i.i1022 = fadd float %tr.sroa.23.48.copyload.i.i1015, %642
  %652 = insertelement <2 x float> poison, float %tr.sroa.24.48.copyload.i.i1017, i64 0
  %653 = insertelement <2 x float> %652, float %tr.sroa.21.48.copyload.i.i1013, i64 1
  %654 = fadd <2 x float> %653, %651
  %mul5.i.i73.i1025 = fmul float %add5.i.i976, %636
  %655 = call float @llvm.fmuladd.f32(float %add.i.i975, float %635, float %mul5.i.i73.i1025)
  %656 = call noundef float @llvm.fmuladd.f32(float %add8.i.i977, float %637, float %655)
  %657 = insertelement <2 x float> poison, float %add5.i.i976, i64 0
  %658 = shufflevector <2 x float> %657, <2 x float> poison, <2 x i32> zeroinitializer
  %659 = fmul <2 x float> %658, %639
  %660 = insertelement <2 x float> poison, float %add.i.i975, i64 0
  %661 = shufflevector <2 x float> %660, <2 x float> poison, <2 x i32> zeroinitializer
  %662 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %661, <2 x float> %638, <2 x float> %659)
  %663 = insertelement <2 x float> poison, float %add8.i.i977, i64 0
  %664 = shufflevector <2 x float> %663, <2 x float> poison, <2 x i32> zeroinitializer
  %665 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %664, <2 x float> %640, <2 x float> %662)
  %sub4.i91.i1028 = fsub float %add4.i.i.i.i1022, %656
  %666 = fsub <2 x float> %654, %665
  %667 = fadd <2 x float> %654, %665
  %add4.i103.i1035 = fadd float %add4.i.i.i.i1022, %656
  %668 = fadd <2 x float> %654, %665
  %add7.i106.i1036 = extractelement <2 x float> %668, i64 0
  %669 = load i32, ptr %m_shapeType15, align 4
  %cmp469 = icmp eq i32 %669, 6
  br i1 %cmp469, label %if.then470, label %if.else534

if.then470:                                       ; preds = %for.body425
  %670 = load i32, ptr %arrayidx2, align 4
  %cmp4741735 = icmp sgt i32 %670, 0
  br i1 %cmp4741735, label %for.body475.lr.ph, label %for.inc571

for.body475.lr.ph:                                ; preds = %if.then470
  %retval.sroa.3.8.insert.ext.i1227 = zext i32 %add429 to i64
  br label %for.body475

for.body475:                                      ; preds = %for.body475.lr.ph, %for.inc531
  %b.01736 = phi i32 [ 0, %for.body475.lr.ph ], [ %inc532, %for.inc531 ]
  %671 = load i32, ptr %1, align 4
  %add479 = add nsw i32 %671, %b.01736
  %idxprom480 = sext i32 %add479 to i64
  %arrayidx481 = getelementptr inbounds %struct.b3GpuChildShape, ptr %gpuChildShapes, i64 %idxprom480
  %672 = getelementptr inbounds %struct.b3GpuChildShape, ptr %gpuChildShapes, i64 %idxprom480, i32 2
  %673 = load i32, ptr %672, align 16
  %ornB482.sroa.5.0.copyload = load float, ptr %ornB482.sroa.5.0.m_quat485.sroa_idx, align 8
  %ornB482.sroa.7.0.copyload = load float, ptr %ornB482.sroa.7.0.m_quat485.sroa_idx, align 4
  %posB486.sroa.0.0.copyload = load float, ptr %arrayidx484, align 16
  %posB486.sroa.2.0.copyload = load float, ptr %posB486.sroa.2.0.arrayidx484.sroa_idx, align 4
  %posB486.sroa.3.0.copyload = load float, ptr %posB486.sroa.3.0.arrayidx484.sroa_idx, align 8
  %childPosB.sroa.0.0.copyload = load float, ptr %arrayidx481, align 16
  %childPosB.sroa.2.0.arrayidx481.sroa_idx = getelementptr inbounds i8, ptr %arrayidx481, i64 4
  %childPosB.sroa.2.0.copyload = load float, ptr %childPosB.sroa.2.0.arrayidx481.sroa_idx, align 4
  %childPosB.sroa.3.0.arrayidx481.sroa_idx = getelementptr inbounds i8, ptr %arrayidx481, i64 8
  %childPosB.sroa.3.0.copyload = load float, ptr %childPosB.sroa.3.0.arrayidx481.sroa_idx, align 8
  %m_childOrientation495 = getelementptr inbounds %struct.b3GpuChildShape, ptr %gpuChildShapes, i64 %idxprom480, i32 1
  %childOrnB.sroa.3.0.m_childOrientation495.sroa_idx = getelementptr inbounds i8, ptr %m_childOrientation495, i64 8
  %childOrnB.sroa.3.0.copyload = load float, ptr %childOrnB.sroa.3.0.m_childOrientation495.sroa_idx, align 8
  %childOrnB.sroa.4.0.m_childOrientation495.sroa_idx = getelementptr inbounds i8, ptr %m_childOrientation495, i64 12
  %childOrnB.sroa.4.0.copyload = load float, ptr %childOrnB.sroa.4.0.m_childOrientation495.sroa_idx, align 4
  %neg.i.i1050 = fneg float %ornB482.sroa.5.0.copyload
  %674 = load ptr, ptr %m_data.i909, align 8
  %idxprom.i1063 = sext i32 %673 to i64
  %arrayidx.i1064 = getelementptr inbounds %struct.b3Aabb, ptr %674, i64 %idxprom.i1063
  %aabbB.sroa.0.0.copyload = load float, ptr %arrayidx.i1064, align 16
  %aabbB.sroa.2.0.arrayidx.i1064.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i1064, i64 4
  %aabbB.sroa.2.0.copyload = load float, ptr %aabbB.sroa.2.0.arrayidx.i1064.sroa_idx, align 4
  %aabbB.sroa.3.0.arrayidx.i1064.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i1064, i64 8
  %aabbB.sroa.3.0.copyload = load float, ptr %aabbB.sroa.3.0.arrayidx.i1064.sroa_idx, align 8
  %aabbB.sroa.41666.0.arrayidx.i1064.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i1064, i64 16
  %aabbB.sroa.41666.0.copyload = load float, ptr %aabbB.sroa.41666.0.arrayidx.i1064.sroa_idx, align 16
  %aabbB.sroa.5.0.arrayidx.i1064.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i1064, i64 20
  %aabbB.sroa.5.0.copyload = load float, ptr %aabbB.sroa.5.0.arrayidx.i1064.sroa_idx, align 4
  %aabbB.sroa.6.0.arrayidx.i1064.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i1064, i64 24
  %aabbB.sroa.6.0.copyload = load float, ptr %aabbB.sroa.6.0.arrayidx.i1064.sroa_idx, align 8
  %675 = load <2 x float>, ptr %m_quat485, align 16
  %676 = load <2 x float>, ptr %m_childOrientation495, align 16
  %677 = extractelement <2 x float> %675, i64 1
  %mul4.i.i.i.i.i = fmul float %677, %677
  %678 = extractelement <2 x float> %675, i64 0
  %679 = call float @llvm.fmuladd.f32(float %678, float %678, float %mul4.i.i.i.i.i)
  %680 = call float @llvm.fmuladd.f32(float %ornB482.sroa.5.0.copyload, float %ornB482.sroa.5.0.copyload, float %679)
  %681 = call noundef float @llvm.fmuladd.f32(float %ornB482.sroa.7.0.copyload, float %ornB482.sroa.7.0.copyload, float %680)
  %div.i.i.i = fdiv float 2.000000e+00, %681
  %mul6.i.i.i = fmul float %ornB482.sroa.5.0.copyload, %div.i.i.i
  %mul12.i.i.i = fmul float %ornB482.sroa.7.0.copyload, %mul6.i.i.i
  %mul18.i.i.i = fmul float %678, %mul6.i.i.i
  %682 = insertelement <2 x float> poison, float %div.i.i.i, i64 0
  %683 = shufflevector <2 x float> %682, <2 x float> poison, <2 x i32> zeroinitializer
  %684 = fmul <2 x float> %675, %683
  %685 = extractelement <2 x float> %684, i64 0
  %mul8.i.i.i = fmul float %ornB482.sroa.7.0.copyload, %685
  %686 = extractelement <2 x float> %684, i64 1
  %mul10.i.i.i = fmul float %ornB482.sroa.7.0.copyload, %686
  %mul16.i.i.i = fmul float %678, %686
  %687 = fmul <2 x float> %675, %684
  %mul22.i.i.i = fmul float %677, %mul6.i.i.i
  %mul24.i.i.i = fmul float %ornB482.sroa.5.0.copyload, %mul6.i.i.i
  %688 = extractelement <2 x float> %687, i64 1
  %add.i.i.i = fadd float %688, %mul24.i.i.i
  %sub.i.i.i = fsub float 1.000000e+00, %add.i.i.i
  %sub26.i.i.i = fsub float %mul16.i.i.i, %mul12.i.i.i
  %add28.i.i.i = fadd float %mul18.i.i.i, %mul10.i.i.i
  %add30.i.i.i = fadd float %mul16.i.i.i, %mul12.i.i.i
  %689 = extractelement <2 x float> %687, i64 0
  %add32.i.i.i = fadd float %689, %mul24.i.i.i
  %sub33.i.i.i = fsub float 1.000000e+00, %add32.i.i.i
  %sub35.i.i.i = fsub float %mul22.i.i.i, %mul8.i.i.i
  %sub37.i.i.i = fsub float %mul18.i.i.i, %mul10.i.i.i
  %add39.i.i.i = fadd float %mul22.i.i.i, %mul8.i.i.i
  %add41.i.i.i = fadd float %689, %688
  %sub42.i.i.i = fsub float 1.000000e+00, %add41.i.i.i
  %mul5.i.i.i.i = fmul float %childPosB.sroa.2.0.copyload, %sub26.i.i.i
  %690 = call float @llvm.fmuladd.f32(float %childPosB.sroa.0.0.copyload, float %sub.i.i.i, float %mul5.i.i.i.i)
  %691 = call noundef float @llvm.fmuladd.f32(float %childPosB.sroa.3.0.copyload, float %add28.i.i.i, float %690)
  %mul5.i3.i.i.i = fmul float %childPosB.sroa.2.0.copyload, %sub33.i.i.i
  %692 = call float @llvm.fmuladd.f32(float %childPosB.sroa.0.0.copyload, float %add30.i.i.i, float %mul5.i3.i.i.i)
  %693 = call noundef float @llvm.fmuladd.f32(float %childPosB.sroa.3.0.copyload, float %sub35.i.i.i, float %692)
  %mul5.i8.i.i.i = fmul float %childPosB.sroa.2.0.copyload, %add39.i.i.i
  %694 = call float @llvm.fmuladd.f32(float %childPosB.sroa.0.0.copyload, float %sub37.i.i.i, float %mul5.i8.i.i.i)
  %695 = call noundef float @llvm.fmuladd.f32(float %childPosB.sroa.3.0.copyload, float %sub42.i.i.i, float %694)
  %add.i.i8.i = fadd float %posB486.sroa.0.0.copyload, %691
  %add4.i.i.i = fadd float %posB486.sroa.2.0.copyload, %693
  %add7.i.i.i = fadd float %posB486.sroa.3.0.copyload, %695
  %retval.sroa.0.0.vec.insert.i.i2.i.i = insertelement <2 x float> poison, float %add.i.i8.i, i64 0
  %retval.sroa.0.4.vec.insert.i.i3.i.i = insertelement <2 x float> %retval.sroa.0.0.vec.insert.i.i2.i.i, float %add4.i.i.i, i64 1
  %retval.sroa.3.12.vec.insert.i.i4.i.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %add7.i.i.i, i64 0
  %mul4.i.i1045 = fmul float %678, %childOrnB.sroa.4.0.copyload
  %696 = extractelement <2 x float> %676, i64 0
  %697 = call float @llvm.fmuladd.f32(float %ornB482.sroa.7.0.copyload, float %696, float %mul4.i.i1045)
  %698 = call float @llvm.fmuladd.f32(float %677, float %childOrnB.sroa.3.0.copyload, float %697)
  %699 = extractelement <2 x float> %676, i64 1
  %700 = call float @llvm.fmuladd.f32(float %neg.i.i1050, float %699, float %698)
  %701 = insertelement <2 x float> poison, float %ornB482.sroa.5.0.copyload, i64 0
  %702 = insertelement <2 x float> %675, float %ornB482.sroa.5.0.copyload, i64 0
  %703 = insertelement <2 x float> poison, float %childOrnB.sroa.4.0.copyload, i64 0
  %704 = shufflevector <2 x float> %703, <2 x float> poison, <2 x i32> zeroinitializer
  %705 = fmul <2 x float> %702, %704
  %706 = insertelement <2 x float> poison, float %ornB482.sroa.7.0.copyload, i64 0
  %707 = shufflevector <2 x float> %706, <2 x float> poison, <2 x i32> zeroinitializer
  %708 = insertelement <2 x float> poison, float %childOrnB.sroa.3.0.copyload, i64 0
  %709 = insertelement <2 x float> %676, float %childOrnB.sroa.3.0.copyload, i64 0
  %710 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %707, <2 x float> %709, <2 x float> %705)
  %711 = shufflevector <2 x float> %710, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %712 = shufflevector <2 x float> %701, <2 x float> %675, <2 x i32> <i32 0, i32 2>
  %713 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %712, <2 x float> %676, <2 x float> %711)
  %714 = fneg <2 x float> %675
  %715 = shufflevector <2 x float> %708, <2 x float> %676, <2 x i32> <i32 0, i32 2>
  %716 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %714, <2 x float> %715, <2 x float> %713)
  %717 = fmul <2 x float> %676, %714
  %neg37.i.i1055 = extractelement <2 x float> %717, i64 0
  %718 = call float @llvm.fmuladd.f32(float %ornB482.sroa.7.0.copyload, float %childOrnB.sroa.4.0.copyload, float %neg37.i.i1055)
  %719 = extractelement <2 x float> %714, i64 1
  %720 = call float @llvm.fmuladd.f32(float %719, float %699, float %718)
  %721 = call float @llvm.fmuladd.f32(float %neg.i.i1050, float %childOrnB.sroa.3.0.copyload, float %720)
  store <2 x float> %retval.sroa.0.4.vec.insert.i.i3.i.i, ptr %m_origin.i1070, align 16
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i4.i.i, ptr %newPosB.sroa.2.0.m_origin.i1070.sroa_idx, align 8
  %722 = extractelement <2 x float> %716, i64 0
  %723 = fmul <2 x float> %716, %716
  %mul4.i.i.i.i1072 = extractelement <2 x float> %723, i64 0
  %724 = call float @llvm.fmuladd.f32(float %700, float %700, float %mul4.i.i.i.i1072)
  %725 = extractelement <2 x float> %716, i64 1
  %726 = call float @llvm.fmuladd.f32(float %725, float %725, float %724)
  %727 = call noundef float @llvm.fmuladd.f32(float %721, float %721, float %726)
  %div.i.i1075 = fdiv float 2.000000e+00, %727
  %mul.i.i1076 = fmul float %700, %div.i.i1075
  %mul4.i.i1077 = fmul float %722, %div.i.i1075
  %mul8.i.i1079 = fmul float %721, %mul.i.i1076
  %mul10.i.i1080 = fmul float %721, %mul4.i.i1077
  %mul14.i.i1082 = fmul float %700, %mul.i.i1076
  %mul16.i.i1083 = fmul float %700, %mul4.i.i1077
  %728 = insertelement <2 x float> poison, float %mul4.i.i1077, i64 0
  %729 = insertelement <2 x float> %728, float %div.i.i1075, i64 1
  %730 = fmul <2 x float> %716, %729
  %731 = extractelement <2 x float> %730, i64 1
  %mul18.i.i1084 = fmul float %700, %731
  %mul22.i.i1086 = fmul float %722, %731
  %mul24.i.i1087 = fmul float %725, %731
  %732 = insertelement <2 x float> poison, float %mul24.i.i1087, i64 0
  %733 = insertelement <2 x float> %732, float %721, i64 1
  %734 = fadd <2 x float> %733, %730
  %735 = fmul <2 x float> %733, %730
  %736 = shufflevector <2 x float> %734, <2 x float> %735, <2 x i32> <i32 0, i32 3>
  %737 = insertelement <2 x float> <float 1.000000e+00, float poison>, float %mul16.i.i1083, i64 1
  %738 = fsub <2 x float> %737, %736
  %add28.i.i1091 = fadd float %mul18.i.i1084, %mul10.i.i1080
  %739 = extractelement <2 x float> %735, i64 1
  %add30.i.i1092 = fadd float %mul16.i.i1083, %739
  %add32.i.i1093 = fadd float %mul14.i.i1082, %mul24.i.i1087
  %sub33.i.i1094 = fsub float 1.000000e+00, %add32.i.i1093
  %sub35.i.i1095 = fsub float %mul22.i.i1086, %mul8.i.i1079
  %sub37.i.i1096 = fsub float %mul18.i.i1084, %mul10.i.i1080
  %add39.i.i1097 = fadd float %mul22.i.i1086, %mul8.i.i1079
  %740 = extractelement <2 x float> %730, i64 0
  %add41.i.i1098 = fadd float %mul14.i.i1082, %740
  %sub42.i.i1099 = fsub float 1.000000e+00, %add41.i.i1098
  store <2 x float> %738, ptr %transB504, align 16
  store float %add28.i.i1091, ptr %arrayidx3.i.i.i.i1101, align 8
  store float 0.000000e+00, ptr %arrayidx4.i.i.i.i1102, align 4
  store float %add30.i.i1092, ptr %arrayidx3.i.i.i1103, align 16
  store float %sub33.i.i1094, ptr %arrayidx2.i1.i.i.i1066, align 4
  store float %sub35.i.i1095, ptr %arrayidx3.i2.i.i.i1067, align 8
  store float 0.000000e+00, ptr %arrayidx4.i3.i.i.i1106, align 4
  store float %sub37.i.i1096, ptr %arrayidx5.i.i.i1107, align 16
  store float %add39.i.i1097, ptr %arrayidx2.i4.i.i.i1108, align 4
  store float %sub42.i.i1099, ptr %arrayidx3.i5.i.i.i1068, align 8
  store float 0.000000e+00, ptr %arrayidx4.i6.i.i.i1069, align 4
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %retval.i1112)
  call void @_ZNK11b3Matrix3x311getRotationER12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(48) %transB504, ptr noundef nonnull align 16 dereferenceable(16) %retval.i1112)
  %.fca.0.load.i1113 = load <2 x float>, ptr %retval.i1112, align 16
  %.fca.1.load.i1116 = load <2 x float>, ptr %.fca.1.gep.i1115, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %retval.i1112)
  %sub.i.i1118 = fsub float %aabbB.sroa.41666.0.copyload, %aabbB.sroa.0.0.copyload
  %sub4.i.i1121 = fsub float %aabbB.sroa.5.0.copyload, %aabbB.sroa.2.0.copyload
  %sub7.i.i1124 = fsub float %aabbB.sroa.6.0.copyload, %aabbB.sroa.3.0.copyload
  %mul.i.i.i1125 = fmul float %sub.i.i1118, 5.000000e-01
  %mul2.i.i.i1126 = fmul float %sub4.i.i1121, 5.000000e-01
  %mul4.i.i.i1127 = fmul float %sub7.i.i1124, 5.000000e-01
  %add.i.i1128 = fadd float %mul.i.i.i1125, 0.000000e+00
  %add5.i.i1129 = fadd float %mul2.i.i.i1126, 0.000000e+00
  %add8.i.i1130 = fadd float %mul4.i.i.i1127, 0.000000e+00
  %add.i8.i1131 = fadd float %aabbB.sroa.0.0.copyload, %aabbB.sroa.41666.0.copyload
  %add4.i.i1132 = fadd float %aabbB.sroa.2.0.copyload, %aabbB.sroa.5.0.copyload
  %add7.i.i1133 = fadd float %aabbB.sroa.3.0.copyload, %aabbB.sroa.6.0.copyload
  %mul.i.i18.i1134 = fmul float %add.i8.i1131, 5.000000e-01
  %mul2.i.i20.i1135 = fmul float %add4.i.i1132, 5.000000e-01
  %mul4.i.i22.i1136 = fmul float %add7.i.i1133, 5.000000e-01
  %741 = fmul <2 x float> %.fca.0.load.i1113, %.fca.0.load.i1113
  %mul4.i.i.i.i.i.i1138 = extractelement <2 x float> %741, i64 1
  %742 = extractelement <2 x float> %.fca.0.load.i1113, i64 0
  %743 = call float @llvm.fmuladd.f32(float %742, float %742, float %mul4.i.i.i.i.i.i1138)
  %ref.tmp508.sroa.3.8.vec.extract = extractelement <2 x float> %.fca.1.load.i1116, i64 0
  %744 = call float @llvm.fmuladd.f32(float %ref.tmp508.sroa.3.8.vec.extract, float %ref.tmp508.sroa.3.8.vec.extract, float %743)
  %ref.tmp508.sroa.3.12.vec.extract = extractelement <2 x float> %.fca.1.load.i1116, i64 1
  %745 = call noundef float @llvm.fmuladd.f32(float %ref.tmp508.sroa.3.12.vec.extract, float %ref.tmp508.sroa.3.12.vec.extract, float %744)
  %div.i.i.i.i1141 = fdiv float 2.000000e+00, %745
  %mul6.i.i.i.i1144 = fmul float %ref.tmp508.sroa.3.8.vec.extract, %div.i.i.i.i1141
  %mul18.i.i.i.i1150 = fmul float %742, %mul6.i.i.i.i1144
  %746 = insertelement <2 x float> poison, float %div.i.i.i.i1141, i64 0
  %747 = shufflevector <2 x float> %746, <2 x float> poison, <2 x i32> zeroinitializer
  %748 = fmul <2 x float> %.fca.0.load.i1113, %747
  %749 = fmul <2 x float> %.fca.1.load.i1116, %748
  %mul10.i.i.i.i1146 = extractelement <2 x float> %749, i64 1
  %750 = fmul <2 x float> %.fca.0.load.i1113, %748
  %mul24.i.i.i.i1153 = fmul float %ref.tmp508.sroa.3.8.vec.extract, %mul6.i.i.i.i1144
  %751 = extractelement <2 x float> %750, i64 1
  %add.i.i.i.i1154 = fadd float %751, %mul24.i.i.i.i1153
  %752 = extractelement <2 x float> %750, i64 0
  %add32.i.i.i.i1159 = fadd float %752, %mul24.i.i.i.i1153
  %sub33.i.i.i.i1160 = fsub float 1.000000e+00, %add32.i.i.i.i1159
  %add41.i.i.i.i1164 = fadd float %752, %751
  %753 = call noundef float @llvm.fabs.f32(float %sub33.i.i.i.i1160)
  %tr.sroa.21.48.copyload.i.i1166 = load float, ptr %m_origin.i1070, align 16
  %tr.sroa.23.48.copyload.i.i1168 = load float, ptr %tr.sroa.23.48.translation.sroa_idx.i.i1167, align 4
  %tr.sroa.24.48.copyload.i.i1170 = load float, ptr %newPosB.sroa.2.0.m_origin.i1070.sroa_idx, align 8
  %mul5.i3.i.i.i.i1172 = fmul float %mul2.i.i20.i1135, %sub33.i.i.i.i1160
  %mul5.i.i73.i1178 = fmul float %add5.i.i1129, %753
  %754 = load i32, ptr @numAabbChecks, align 4
  %inc513 = add nsw i32 %754, 1
  store i32 %inc513, ptr @numAabbChecks, align 4
  %755 = shufflevector <2 x float> %.fca.1.load.i1116, <2 x float> %.fca.0.load.i1113, <2 x i32> <i32 1, i32 2>
  %756 = fmul <2 x float> %755, %748
  %757 = shufflevector <2 x float> %.fca.0.load.i1113, <2 x float> %.fca.1.load.i1116, <2 x i32> <i32 1, i32 3>
  %758 = insertelement <2 x float> poison, float %mul6.i.i.i.i1144, i64 0
  %759 = shufflevector <2 x float> %758, <2 x float> poison, <2 x i32> zeroinitializer
  %760 = fmul <2 x float> %757, %759
  %761 = fadd <2 x float> %756, %760
  %add30.i.i.i.i1158 = extractelement <2 x float> %761, i64 1
  %762 = fsub <2 x float> %760, %756
  %sub35.i.i.i.i1161 = extractelement <2 x float> %762, i64 0
  %763 = insertelement <2 x float> <float poison, float 1.000000e+00>, float %mul18.i.i.i.i1150, i64 0
  %764 = insertelement <2 x float> poison, float %mul10.i.i.i.i1146, i64 0
  %765 = insertelement <2 x float> %764, float %add.i.i.i.i1154, i64 1
  %766 = fsub <2 x float> %763, %765
  %767 = fadd <2 x float> %756, %760
  %768 = fsub <2 x float> %756, %760
  %769 = shufflevector <2 x float> %767, <2 x float> %768, <2 x i32> <i32 0, i32 3>
  %770 = insertelement <2 x float> <float 1.000000e+00, float poison>, float %mul18.i.i.i.i1150, i64 1
  %771 = insertelement <2 x float> %749, float %add41.i.i.i.i1164, i64 0
  %772 = fsub <2 x float> %770, %771
  %773 = fadd <2 x float> %770, %771
  %774 = shufflevector <2 x float> %772, <2 x float> %773, <2 x i32> <i32 0, i32 3>
  %775 = call noundef float @llvm.fabs.f32(float %add30.i.i.i.i1158)
  %776 = call noundef float @llvm.fabs.f32(float %sub35.i.i.i.i1161)
  %777 = call <2 x float> @llvm.fabs.v2f32(<2 x float> %766)
  %778 = call <2 x float> @llvm.fabs.v2f32(<2 x float> %769)
  %779 = call <2 x float> @llvm.fabs.v2f32(<2 x float> %774)
  %780 = call float @llvm.fmuladd.f32(float %mul.i.i18.i1134, float %add30.i.i.i.i1158, float %mul5.i3.i.i.i.i1172)
  %781 = call noundef float @llvm.fmuladd.f32(float %mul4.i.i22.i1136, float %sub35.i.i.i.i1161, float %780)
  %782 = insertelement <2 x float> poison, float %mul2.i.i20.i1135, i64 0
  %783 = shufflevector <2 x float> %782, <2 x float> poison, <2 x i32> zeroinitializer
  %784 = fmul <2 x float> %783, %769
  %785 = insertelement <2 x float> poison, float %mul.i.i18.i1134, i64 0
  %786 = shufflevector <2 x float> %785, <2 x float> poison, <2 x i32> zeroinitializer
  %787 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %786, <2 x float> %766, <2 x float> %784)
  %788 = insertelement <2 x float> poison, float %mul4.i.i22.i1136, i64 0
  %789 = shufflevector <2 x float> %788, <2 x float> poison, <2 x i32> zeroinitializer
  %790 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %789, <2 x float> %774, <2 x float> %787)
  %add4.i.i.i.i1175 = fadd float %tr.sroa.23.48.copyload.i.i1168, %781
  %791 = insertelement <2 x float> poison, float %tr.sroa.24.48.copyload.i.i1170, i64 0
  %792 = insertelement <2 x float> %791, float %tr.sroa.21.48.copyload.i.i1166, i64 1
  %793 = fadd <2 x float> %792, %790
  %794 = call float @llvm.fmuladd.f32(float %add.i.i1128, float %775, float %mul5.i.i73.i1178)
  %795 = call noundef float @llvm.fmuladd.f32(float %add8.i.i1130, float %776, float %794)
  %796 = insertelement <2 x float> poison, float %add5.i.i1129, i64 0
  %797 = shufflevector <2 x float> %796, <2 x float> poison, <2 x i32> zeroinitializer
  %798 = fmul <2 x float> %797, %778
  %799 = insertelement <2 x float> poison, float %add.i.i1128, i64 0
  %800 = shufflevector <2 x float> %799, <2 x float> poison, <2 x i32> zeroinitializer
  %801 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %800, <2 x float> %777, <2 x float> %798)
  %802 = insertelement <2 x float> poison, float %add8.i.i1130, i64 0
  %803 = shufflevector <2 x float> %802, <2 x float> poison, <2 x i32> zeroinitializer
  %804 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %803, <2 x float> %779, <2 x float> %801)
  %805 = fsub <2 x float> %793, %804
  %sub4.i91.i1181 = fsub float %add4.i.i.i.i1175, %795
  %806 = fsub <2 x float> %793, %804
  %sub7.i94.i1182 = extractelement <2 x float> %806, i64 0
  %add4.i103.i1188 = fadd float %add4.i.i.i.i1175, %795
  %807 = fadd <2 x float> %793, %804
  %808 = fcmp uge <2 x float> %667, %805
  %809 = fcmp ule <2 x float> %666, %807
  %810 = and <2 x i1> %809, %808
  %or.cond1701.not = extractelement <2 x i1> %810, i64 1
  %cmp10.i1206 = fcmp uge float %add7.i106.i1036, %sub7.i94.i1182
  %811 = extractelement <2 x i1> %809, i64 0
  %or.cond1702.not = and i1 %811, %cmp10.i1206
  %spec.select1709 = select i1 %or.cond1702.not, i1 %or.cond1701.not, i1 false
  %cmp18.i1212 = fcmp ogt float %sub4.i91.i1028, %add4.i103.i1188
  %cmp22.i1216 = fcmp olt float %add4.i103.i1035, %sub4.i91.i1181
  %or.cond1703 = or i1 %cmp18.i1212, %cmp22.i1216
  %cond15.i1209.not = xor i1 %spec.select1709, true
  %brmerge1704 = or i1 %or.cond1703, %cond15.i1209.not
  br i1 %brmerge1704, label %for.inc531, label %if.then518

if.then518:                                       ; preds = %for.body475
  %812 = load i32, ptr %numCompoundPairsOut, align 4
  %inc520 = add nsw i32 %812, 1
  store i32 %inc520, ptr %numCompoundPairsOut, align 4
  %cmp521 = icmp slt i32 %812, %maxNumCompoundPairsCapacity
  br i1 %cmp521, label %if.then522, label %for.inc531

if.then522:                                       ; preds = %if.then518
  %retval.sroa.5.8.insert.ext.i1225 = zext i32 %add479 to i64
  %retval.sroa.5.8.insert.shift.i1226 = shl nuw i64 %retval.sroa.5.8.insert.ext.i1225, 32
  %retval.sroa.3.8.insert.insert.i1228 = or disjoint i64 %retval.sroa.5.8.insert.shift.i1226, %retval.sroa.3.8.insert.ext.i1227
  %idxprom527 = sext i32 %812 to i64
  %arrayidx528 = getelementptr inbounds %struct.b3Int4, ptr %gpuCompoundPairsOut, i64 %idxprom527
  store i64 %retval.sroa.0.0.insert.insert.i1327, ptr %arrayidx528, align 16
  %ref.tmp523.sroa.2.0.arrayidx528.sroa_idx = getelementptr inbounds i8, ptr %arrayidx528, i64 8
  store i64 %retval.sroa.3.8.insert.insert.i1228, ptr %ref.tmp523.sroa.2.0.arrayidx528.sroa_idx, align 8
  br label %for.inc531

for.inc531:                                       ; preds = %for.body475, %if.then522, %if.then518
  %inc532 = add nuw nsw i32 %b.01736, 1
  %exitcond1778.not = icmp eq i32 %inc532, %670
  br i1 %exitcond1778.not, label %for.inc571, label %for.body475, !llvm.loop !46

if.else534:                                       ; preds = %for.body425
  %813 = load i32, ptr %numCompoundPairsOut, align 4
  %inc560 = add nsw i32 %813, 1
  store i32 %inc560, ptr %numCompoundPairsOut, align 4
  %cmp561 = icmp slt i32 %813, %maxNumCompoundPairsCapacity
  br i1 %cmp561, label %if.then562, label %for.inc571

if.then562:                                       ; preds = %if.else534
  %retval.sroa.3.8.insert.ext.i1329 = zext i32 %add429 to i64
  %retval.sroa.3.8.insert.insert.i1330 = or disjoint i64 %retval.sroa.3.8.insert.ext.i1329, -4294967296
  %idxprom567 = sext i32 %813 to i64
  %arrayidx568 = getelementptr inbounds %struct.b3Int4, ptr %gpuCompoundPairsOut, i64 %idxprom567
  store i64 %retval.sroa.0.0.insert.insert.i1327, ptr %arrayidx568, align 16
  %ref.tmp563.sroa.2.0.arrayidx568.sroa_idx = getelementptr inbounds i8, ptr %arrayidx568, i64 8
  store i64 %retval.sroa.3.8.insert.insert.i1330, ptr %ref.tmp563.sroa.2.0.arrayidx568.sroa_idx, align 8
  br label %for.inc571

for.inc571:                                       ; preds = %for.inc531, %if.then470, %if.then562, %if.else534
  %inc572 = add nuw nsw i32 %c.01738, 1
  %exitcond1779.not = icmp eq i32 %inc572, %507
  br i1 %exitcond1779.not, label %if.end676, label %for.body425, !llvm.loop !47

if.then584:                                       ; preds = %lor.lhs.false
  %814 = load i32, ptr %arrayidx2, align 4
  %cmp5901733 = icmp sgt i32 %814, 0
  br i1 %cmp5901733, label %for.body591.lr.ph, label %if.end676

for.body591.lr.ph:                                ; preds = %if.then584
  %retval.sroa.2.0.insert.ext.i1477 = zext i32 %bodyIndexB to i64
  %retval.sroa.2.0.insert.shift.i1478 = shl nuw i64 %retval.sroa.2.0.insert.ext.i1477, 32
  %retval.sroa.0.0.insert.ext.i1479 = zext i32 %bodyIndexA to i64
  %retval.sroa.0.0.insert.insert.i1480 = or disjoint i64 %retval.sroa.2.0.insert.shift.i1478, %retval.sroa.0.0.insert.ext.i1479
  br label %for.body591

for.body591:                                      ; preds = %for.body591.lr.ph, %for.inc672
  %b588.01734 = phi i32 [ 0, %for.body591.lr.ph ], [ %inc673, %for.inc672 ]
  %815 = load i32, ptr %1, align 4
  %816 = load i32, ptr %numCompoundPairsOut, align 4
  %inc662 = add nsw i32 %816, 1
  store i32 %inc662, ptr %numCompoundPairsOut, align 4
  %cmp663 = icmp slt i32 %816, %maxNumCompoundPairsCapacity
  br i1 %cmp663, label %if.then664, label %for.inc672

if.then664:                                       ; preds = %for.body591
  %add595 = add nsw i32 %815, %b588.01734
  %retval.sroa.5.8.insert.ext.i1482 = zext i32 %add595 to i64
  %retval.sroa.5.8.insert.shift.i1483 = shl nuw i64 %retval.sroa.5.8.insert.ext.i1482, 32
  %retval.sroa.3.8.insert.insert.i1484 = or disjoint i64 %retval.sroa.5.8.insert.shift.i1483, 4294967295
  %idxprom669 = sext i32 %816 to i64
  %arrayidx670 = getelementptr inbounds %struct.b3Int4, ptr %gpuCompoundPairsOut, i64 %idxprom669
  store i64 %retval.sroa.0.0.insert.insert.i1480, ptr %arrayidx670, align 16
  %ref.tmp665.sroa.2.0.arrayidx670.sroa_idx = getelementptr inbounds i8, ptr %arrayidx670, i64 8
  store i64 %retval.sroa.3.8.insert.insert.i1484, ptr %ref.tmp665.sroa.2.0.arrayidx670.sroa_idx, align 8
  br label %for.inc672

for.inc672:                                       ; preds = %for.body591, %if.then664
  %inc673 = add nuw nsw i32 %b588.01734, 1
  %exitcond.not = icmp eq i32 %inc673, %814
  br i1 %exitcond.not, label %if.end676, label %for.body591, !llvm.loop !48

if.end676:                                        ; preds = %for.inc672, %for.inc571, %for.inc403, %if.then584, %if.then420, %if.then17, %land.lhs.true, %lor.lhs.false
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3Int2ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #10 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %m_data.i.i = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %this, i64 0, i32 5
  %0 = load ptr, ptr %m_data.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %0, null
  br i1 %tobool.not.i.i, label %invoke.cont, label %if.then.i.i

if.then.i.i:                                      ; preds = %entry
  %m_ownsMemory.i.i = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %this, i64 0, i32 6
  %1 = load i8, ptr %m_ownsMemory.i.i, align 8
  %2 = and i8 %1, 1
  %tobool2.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool2.not.i.i, label %invoke.cont, label %if.then3.i.i

if.then3.i.i:                                     ; preds = %if.then.i.i
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then.i.i, %entry, %if.then3.i.i
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %this, i64 0, i32 2
  %m_ownsMemory.i1.i = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i1.i, align 8
  store ptr null, ptr %m_data.i.i, align 8
  store i32 0, ptr %m_size.i.i, align 4
  %m_capacity.i.i = getelementptr inbounds %class.b3AlignedObjectArray.51, ptr %this, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i, align 8
  ret void

terminate.lpad:                                   ; preds = %if.then3.i.i
  %3 = landingpad { ptr, i32 }
          catch ptr null
  %4 = extractvalue { ptr, i32 } %3, 0
  tail call void @__clang_call_terminate(ptr %4) #27
  unreachable
}

; Function Attrs: mustprogress uwtable
define dso_local void @_Z26processCompoundPairsKernelPK6b3Int4PK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataRK20b3AlignedObjectArrayI9b3Vector3ESF_RKSB_I9b3GpuFaceERKSB_IiEP6b3AabbPK15b3GpuChildShapeRSD_RSK_ii(ptr nocapture noundef readonly %gpuCompoundPairs, ptr nocapture noundef readonly %rigidBodies, ptr nocapture noundef readonly %collidables, ptr noundef %convexShapes, ptr noundef nonnull align 8 dereferenceable(25) %vertices, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %uniqueEdges, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %faces, ptr nocapture nonnull readnone align 8 %indices, ptr nocapture readnone %aabbs, ptr nocapture noundef readonly %gpuChildShapes, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %gpuCompoundSepNormalsOut, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %gpuHasCompoundSepNormalsOut, i32 noundef %numCompoundPairs, i32 noundef %i) local_unnamed_addr #5 {
entry:
  %ornA = alloca %class.b3Quaternion, align 16
  %posA = alloca %class.b3Vector3, align 16
  %ornB = alloca %class.b3Quaternion, align 16
  %posB = alloca %class.b3Vector3, align 16
  %dmin = alloca float, align 4
  %DeltaC2 = alloca %class.b3Vector3, align 16
  %sepNormal = alloca %class.b3Vector3, align 16
  %cmp = icmp slt i32 %i, %numCompoundPairs
  br i1 %cmp, label %if.then, label %if.end123

if.then:                                          ; preds = %entry
  %idxprom = sext i32 %i to i64
  %arrayidx = getelementptr inbounds %struct.b3Int4, ptr %gpuCompoundPairs, i64 %idxprom
  %0 = load i32, ptr %arrayidx, align 16
  %y = getelementptr inbounds %struct.anon, ptr %arrayidx, i64 0, i32 1
  %1 = load i32, ptr %y, align 4
  %z = getelementptr inbounds %struct.anon, ptr %arrayidx, i64 0, i32 2
  %2 = load i32, ptr %z, align 8
  %w = getelementptr inbounds %struct.anon, ptr %arrayidx, i64 0, i32 3
  %3 = load i32, ptr %w, align 4
  %idxprom7 = sext i32 %0 to i64
  %arrayidx8 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom7
  %m_quat = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom7, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %m_quat, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx8, i64 16, i1 false)
  %idxprom11 = sext i32 %1 to i64
  %arrayidx12 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom11
  %m_quat13 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom11, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %m_quat13, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx12, i64 16, i1 false)
  %cmp17 = icmp sgt i32 %2, -1
  br i1 %cmp17, label %if.then18, label %if.else

if.then18:                                        ; preds = %if.then
  %idxprom19 = zext nneg i32 %2 to i64
  %arrayidx20 = getelementptr inbounds %struct.b3GpuChildShape, ptr %gpuChildShapes, i64 %idxprom19
  %4 = getelementptr inbounds %struct.b3GpuChildShape, ptr %gpuChildShapes, i64 %idxprom19, i32 2
  %5 = load i32, ptr %4, align 16
  %childPosA.sroa.3.0.arrayidx20.sroa_idx = getelementptr inbounds i8, ptr %arrayidx20, i64 8
  %childPosA.sroa.3.0.copyload = load float, ptr %childPosA.sroa.3.0.arrayidx20.sroa_idx, align 8
  %m_childOrientation = getelementptr inbounds %struct.b3GpuChildShape, ptr %gpuChildShapes, i64 %idxprom19, i32 1
  %childOrnA.sroa.3.0.m_childOrientation.sroa_idx = getelementptr inbounds i8, ptr %m_childOrientation, i64 8
  %arrayidx.i.i.i = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 3
  %6 = load float, ptr %arrayidx.i.i.i, align 4
  %arrayidx.i23.i.i = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 1
  %arrayidx.i25.i.i = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 2
  %7 = load float, ptr %ornA, align 16
  %neg15.i.i = fneg float %7
  %arrayidx6.i = getelementptr inbounds [4 x float], ptr %posA, i64 0, i64 2
  %8 = load float, ptr %arrayidx6.i, align 8
  %9 = load <2 x float>, ptr %childOrnA.sroa.3.0.m_childOrientation.sroa_idx, align 8
  %10 = load <2 x float>, ptr %arrayidx.i23.i.i, align 4
  %11 = fneg <2 x float> %10
  %12 = load <2 x float>, ptr %arrayidx20, align 16
  %13 = load <2 x float>, ptr %posA, align 16
  %14 = insertelement <2 x float> %12, float %childPosA.sroa.3.0.copyload, i64 0
  %15 = insertelement <2 x float> %10, float %7, i64 1
  %16 = fmul <2 x float> %14, %15
  %17 = insertelement <2 x float> poison, float %6, i64 0
  %18 = shufflevector <2 x float> %17, <2 x float> poison, <2 x i32> zeroinitializer
  %19 = insertelement <2 x float> %12, float %childPosA.sroa.3.0.copyload, i64 1
  %20 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %18, <2 x float> %19, <2 x float> %16)
  %21 = shufflevector <2 x float> %20, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %22 = extractelement <2 x float> %12, i64 0
  %shift = shufflevector <2 x float> %10, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %23 = fmul <2 x float> %12, %shift
  %mul12.i.i = extractelement <2 x float> %23, i64 0
  %24 = extractelement <2 x float> %12, i64 1
  %25 = tail call float @llvm.fmuladd.f32(float %6, float %24, float %mul12.i.i)
  %26 = tail call float @llvm.fmuladd.f32(float %neg15.i.i, float %childPosA.sroa.3.0.copyload, float %25)
  %27 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %11, <2 x float> %12, <2 x float> %21)
  %28 = extractelement <2 x float> %11, i64 0
  %neg31.i.i = fmul float %24, %28
  %29 = tail call float @llvm.fmuladd.f32(float %neg15.i.i, float %22, float %neg31.i.i)
  %30 = extractelement <2 x float> %11, i64 1
  %31 = tail call float @llvm.fmuladd.f32(float %30, float %childPosA.sroa.3.0.copyload, float %29)
  %32 = shufflevector <2 x float> %27, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %33 = insertelement <2 x float> %32, float %26, i64 1
  %34 = fmul <2 x float> %18, %33
  %35 = insertelement <2 x float> poison, float %31, i64 0
  %36 = shufflevector <2 x float> %35, <2 x float> poison, <2 x i32> zeroinitializer
  %37 = shufflevector <2 x float> %11, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %38 = insertelement <2 x float> %37, float %neg15.i.i, i64 0
  %39 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %36, <2 x float> %38, <2 x float> %34)
  %40 = shufflevector <2 x float> %33, <2 x float> %27, <2 x i32> <i32 1, i32 2>
  %41 = insertelement <2 x float> %37, float %neg15.i.i, i64 1
  %42 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %40, <2 x float> %41, <2 x float> %39)
  %43 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %27, <2 x float> %10, <2 x float> %42)
  %44 = extractelement <2 x float> %27, i64 0
  %mul25.i.i = fmul float %6, %44
  %45 = tail call float @llvm.fmuladd.f32(float %31, float %30, float %mul25.i.i)
  %46 = extractelement <2 x float> %27, i64 1
  %47 = tail call float @llvm.fmuladd.f32(float %46, float %28, float %45)
  %48 = tail call float @llvm.fmuladd.f32(float %26, float %7, float %47)
  %49 = fadd <2 x float> %13, %43
  %add7.i = fadd float %8, %48
  %retval.sroa.3.12.vec.insert.i.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %add7.i, i64 0
  %50 = load <2 x float>, ptr %m_childOrientation, align 16
  %51 = shufflevector <2 x float> %9, <2 x float> poison, <2 x i32> <i32 1, i32 1>
  %52 = fmul <2 x float> %51, %15
  %53 = shufflevector <2 x float> %52, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %54 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %18, <2 x float> %50, <2 x float> %53)
  %55 = shufflevector <2 x float> %9, <2 x float> %50, <2 x i32> <i32 0, i32 2>
  %56 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %10, <2 x float> %55, <2 x float> %54)
  %57 = shufflevector <2 x float> %9, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %58 = shufflevector <2 x float> %57, <2 x float> %50, <2 x i32> <i32 3, i32 1>
  %59 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %41, <2 x float> %58, <2 x float> %56)
  %60 = shufflevector <2 x float> %50, <2 x float> %9, <2 x i32> <i32 0, i32 3>
  %61 = insertelement <2 x float> %10, float %neg15.i.i, i64 0
  %62 = fmul <2 x float> %60, %61
  %63 = shufflevector <2 x float> %62, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %64 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %18, <2 x float> %9, <2 x float> %63)
  %65 = insertelement <2 x float> %37, float %7, i64 0
  %66 = shufflevector <2 x float> %50, <2 x float> poison, <2 x i32> <i32 1, i32 1>
  %67 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %65, <2 x float> %66, <2 x float> %64)
  %68 = shufflevector <2 x float> %50, <2 x float> %9, <2 x i32> <i32 0, i32 2>
  %69 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %11, <2 x float> %68, <2 x float> %67)
  store <2 x float> %49, ptr %posA, align 16
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i, ptr %arrayidx6.i, align 8
  store <2 x float> %59, ptr %ornA, align 16
  store <2 x float> %69, ptr %arrayidx.i25.i.i, align 8
  br label %if.end

if.else:                                          ; preds = %if.then
  %m_collidableIdx = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom7, i32 4
  %70 = load i32, ptr %m_collidableIdx, align 16
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then18
  %collidableIndexA.0 = phi i32 [ %5, %if.then18 ], [ %70, %if.else ]
  %cmp35 = icmp sgt i32 %3, -1
  br i1 %cmp35, label %if.then36, label %if.else56

if.then36:                                        ; preds = %if.end
  %idxprom37 = zext nneg i32 %3 to i64
  %arrayidx38 = getelementptr inbounds %struct.b3GpuChildShape, ptr %gpuChildShapes, i64 %idxprom37
  %71 = getelementptr inbounds %struct.b3GpuChildShape, ptr %gpuChildShapes, i64 %idxprom37, i32 2
  %72 = load i32, ptr %71, align 16
  %childPosB.sroa.3.0.arrayidx38.sroa_idx = getelementptr inbounds i8, ptr %arrayidx38, i64 8
  %childPosB.sroa.3.0.copyload = load float, ptr %childPosB.sroa.3.0.arrayidx38.sroa_idx, align 8
  %m_childOrientation44 = getelementptr inbounds %struct.b3GpuChildShape, ptr %gpuChildShapes, i64 %idxprom37, i32 1
  %childOrnB.sroa.3.0.m_childOrientation44.sroa_idx = getelementptr inbounds i8, ptr %m_childOrientation44, i64 8
  %arrayidx.i.i.i77 = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 3
  %73 = load float, ptr %arrayidx.i.i.i77, align 4
  %arrayidx.i23.i.i78 = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 1
  %arrayidx.i25.i.i81 = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 2
  %74 = load float, ptr %ornB, align 16
  %neg15.i.i85 = fneg float %74
  %arrayidx6.i102 = getelementptr inbounds [4 x float], ptr %posB, i64 0, i64 2
  %75 = load float, ptr %arrayidx6.i102, align 8
  %76 = load <2 x float>, ptr %childOrnB.sroa.3.0.m_childOrientation44.sroa_idx, align 8
  %77 = load <2 x float>, ptr %arrayidx.i23.i.i78, align 4
  %78 = fneg <2 x float> %77
  %79 = load <2 x float>, ptr %arrayidx38, align 16
  %80 = load <2 x float>, ptr %posB, align 16
  %81 = insertelement <2 x float> %79, float %childPosB.sroa.3.0.copyload, i64 0
  %82 = insertelement <2 x float> %77, float %74, i64 1
  %83 = fmul <2 x float> %81, %82
  %84 = insertelement <2 x float> poison, float %73, i64 0
  %85 = shufflevector <2 x float> %84, <2 x float> poison, <2 x i32> zeroinitializer
  %86 = insertelement <2 x float> %79, float %childPosB.sroa.3.0.copyload, i64 1
  %87 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %85, <2 x float> %86, <2 x float> %83)
  %88 = shufflevector <2 x float> %87, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %89 = extractelement <2 x float> %79, i64 0
  %shift190 = shufflevector <2 x float> %77, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %90 = fmul <2 x float> %79, %shift190
  %mul12.i.i84 = extractelement <2 x float> %90, i64 0
  %91 = extractelement <2 x float> %79, i64 1
  %92 = tail call float @llvm.fmuladd.f32(float %73, float %91, float %mul12.i.i84)
  %93 = tail call float @llvm.fmuladd.f32(float %neg15.i.i85, float %childPosB.sroa.3.0.copyload, float %92)
  %94 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %78, <2 x float> %79, <2 x float> %88)
  %95 = extractelement <2 x float> %78, i64 0
  %neg31.i.i88 = fmul float %91, %95
  %96 = tail call float @llvm.fmuladd.f32(float %neg15.i.i85, float %89, float %neg31.i.i88)
  %97 = extractelement <2 x float> %78, i64 1
  %98 = tail call float @llvm.fmuladd.f32(float %97, float %childPosB.sroa.3.0.copyload, float %96)
  %99 = shufflevector <2 x float> %94, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %100 = insertelement <2 x float> %99, float %93, i64 1
  %101 = fmul <2 x float> %85, %100
  %102 = insertelement <2 x float> poison, float %98, i64 0
  %103 = shufflevector <2 x float> %102, <2 x float> poison, <2 x i32> zeroinitializer
  %104 = shufflevector <2 x float> %78, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %105 = insertelement <2 x float> %104, float %neg15.i.i85, i64 0
  %106 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %103, <2 x float> %105, <2 x float> %101)
  %107 = shufflevector <2 x float> %100, <2 x float> %94, <2 x i32> <i32 1, i32 2>
  %108 = insertelement <2 x float> %104, float %neg15.i.i85, i64 1
  %109 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %107, <2 x float> %108, <2 x float> %106)
  %110 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %94, <2 x float> %77, <2 x float> %109)
  %111 = extractelement <2 x float> %94, i64 0
  %mul25.i.i91 = fmul float %73, %111
  %112 = tail call float @llvm.fmuladd.f32(float %98, float %97, float %mul25.i.i91)
  %113 = extractelement <2 x float> %94, i64 1
  %114 = tail call float @llvm.fmuladd.f32(float %113, float %95, float %112)
  %115 = tail call float @llvm.fmuladd.f32(float %93, float %74, float %114)
  %116 = fadd <2 x float> %80, %110
  %add7.i103 = fadd float %75, %115
  %retval.sroa.3.12.vec.insert.i.i106 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %add7.i103, i64 0
  %117 = load <2 x float>, ptr %m_childOrientation44, align 16
  %118 = shufflevector <2 x float> %76, <2 x float> poison, <2 x i32> <i32 1, i32 1>
  %119 = fmul <2 x float> %118, %82
  %120 = shufflevector <2 x float> %119, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %121 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %85, <2 x float> %117, <2 x float> %120)
  %122 = shufflevector <2 x float> %76, <2 x float> %117, <2 x i32> <i32 0, i32 2>
  %123 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %77, <2 x float> %122, <2 x float> %121)
  %124 = shufflevector <2 x float> %76, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %125 = shufflevector <2 x float> %124, <2 x float> %117, <2 x i32> <i32 3, i32 1>
  %126 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %108, <2 x float> %125, <2 x float> %123)
  %127 = shufflevector <2 x float> %117, <2 x float> %76, <2 x i32> <i32 0, i32 3>
  %128 = insertelement <2 x float> %77, float %neg15.i.i85, i64 0
  %129 = fmul <2 x float> %127, %128
  %130 = shufflevector <2 x float> %129, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %131 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %85, <2 x float> %76, <2 x float> %130)
  %132 = insertelement <2 x float> %104, float %74, i64 0
  %133 = shufflevector <2 x float> %117, <2 x float> poison, <2 x i32> <i32 1, i32 1>
  %134 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %132, <2 x float> %133, <2 x float> %131)
  %135 = shufflevector <2 x float> %117, <2 x float> %76, <2 x i32> <i32 0, i32 2>
  %136 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %78, <2 x float> %135, <2 x float> %134)
  store <2 x float> %116, ptr %posB, align 16
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i106, ptr %arrayidx6.i102, align 8
  store <2 x float> %126, ptr %ornB, align 16
  store <2 x float> %136, ptr %arrayidx.i25.i.i81, align 8
  br label %if.end60

if.else56:                                        ; preds = %if.end
  %m_collidableIdx59 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom11, i32 4
  %137 = load i32, ptr %m_collidableIdx59, align 16
  br label %if.end60

if.end60:                                         ; preds = %if.else56, %if.then36
  %collidableIndexB.0 = phi i32 [ %72, %if.then36 ], [ %137, %if.else56 ]
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %gpuHasCompoundSepNormalsOut, i64 0, i32 5
  %138 = load ptr, ptr %m_data.i, align 8
  %arrayidx.i = getelementptr inbounds i32, ptr %138, i64 %idxprom
  store i32 0, ptr %arrayidx.i, align 4
  %idxprom62 = sext i32 %collidableIndexA.0 to i64
  %idxprom64 = sext i32 %collidableIndexB.0 to i64
  %m_shapeType = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom62, i32 2
  %139 = load i32, ptr %m_shapeType, align 4
  %m_shapeType70 = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom64, i32 2
  %140 = load i32, ptr %m_shapeType70, align 4
  %cmp71 = icmp ne i32 %139, 3
  %cmp72 = icmp ne i32 %140, 3
  %or.cond = select i1 %cmp71, i1 true, i1 %cmp72
  br i1 %or.cond, label %if.end123, label %if.end74

if.end74:                                         ; preds = %if.end60
  %141 = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom64, i32 3
  %142 = load i32, ptr %141, align 4
  %143 = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom62, i32 3
  %144 = load i32, ptr %143, align 4
  store float 0x47EFFFFFE0000000, ptr %dmin, align 4
  %w75 = getelementptr inbounds %struct.anon.2, ptr %posA, i64 0, i32 3
  store float 0.000000e+00, ptr %w75, align 4
  %w76 = getelementptr inbounds %struct.anon.2, ptr %posB, i64 0, i32 3
  store float 0.000000e+00, ptr %w76, align 4
  %idxprom77 = sext i32 %144 to i64
  %arrayidx78 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexShapes, i64 %idxprom77
  %c0local.sroa.0.0.copyload = load float, ptr %arrayidx78, align 16
  %c0local.sroa.2.0.arrayidx78.sroa_idx = getelementptr inbounds i8, ptr %arrayidx78, i64 4
  %c0local.sroa.2.0.copyload = load float, ptr %c0local.sroa.2.0.arrayidx78.sroa_idx, align 4
  %c0local.sroa.3.0.arrayidx78.sroa_idx = getelementptr inbounds i8, ptr %arrayidx78, i64 8
  %c0local.sroa.3.0.copyload = load float, ptr %c0local.sroa.3.0.arrayidx78.sroa_idx, align 8
  %145 = load <4 x float>, ptr %posA, align 16
  %146 = shufflevector <4 x float> %145, <4 x float> poison, <2 x i32> <i32 0, i32 poison>
  %tr.sroa.29.48.pos.sroa_idx.i = getelementptr inbounds i8, ptr %posA, i64 4
  %tr.sroa.29.48.copyload.i = load float, ptr %tr.sroa.29.48.pos.sroa_idx.i, align 4
  %147 = shufflevector <4 x float> %145, <4 x float> poison, <2 x i32> <i32 2, i32 poison>
  %148 = load <4 x float>, ptr %ornA, align 16
  %149 = shufflevector <4 x float> %148, <4 x float> poison, <2 x i32> <i32 0, i32 poison>
  %arrayidx2.i.i.i.i1.i = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 1
  %150 = load float, ptr %arrayidx2.i.i.i.i1.i, align 4
  %151 = shufflevector <4 x float> %148, <4 x float> poison, <2 x i32> <i32 2, i32 poison>
  %152 = shufflevector <4 x float> %148, <4 x float> poison, <2 x i32> <i32 3, i32 poison>
  %idxprom82 = sext i32 %142 to i64
  %arrayidx83 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexShapes, i64 %idxprom82
  %c1local.sroa.0.0.copyload = load float, ptr %arrayidx83, align 16
  %c1local.sroa.2.0.arrayidx83.sroa_idx = getelementptr inbounds i8, ptr %arrayidx83, i64 4
  %c1local.sroa.2.0.copyload = load float, ptr %c1local.sroa.2.0.arrayidx83.sroa_idx, align 4
  %c1local.sroa.3.0.arrayidx83.sroa_idx = getelementptr inbounds i8, ptr %arrayidx83, i64 8
  %c1local.sroa.3.0.copyload = load float, ptr %c1local.sroa.3.0.arrayidx83.sroa_idx, align 8
  %tr.sroa.27.48.copyload.i128 = load float, ptr %posB, align 16
  %tr.sroa.29.48.pos.sroa_idx.i129 = getelementptr inbounds i8, ptr %posB, i64 4
  %tr.sroa.29.48.copyload.i130 = load float, ptr %tr.sroa.29.48.pos.sroa_idx.i129, align 4
  %tr.sroa.30.48.pos.sroa_idx.i131 = getelementptr inbounds i8, ptr %posB, i64 8
  %tr.sroa.30.48.copyload.i132 = load float, ptr %tr.sroa.30.48.pos.sroa_idx.i131, align 8
  %153 = load float, ptr %ornB, align 16
  %arrayidx2.i.i.i.i1.i133 = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 1
  %154 = load float, ptr %arrayidx2.i.i.i.i1.i133, align 4
  %arrayidx5.i.i.i.i.i135 = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 2
  %155 = load float, ptr %arrayidx5.i.i.i.i.i135, align 8
  %arrayidx7.i.i.i.i.i136 = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 3
  %156 = load float, ptr %arrayidx7.i.i.i.i.i136, align 4
  %157 = insertelement <2 x float> poison, float %150, i64 0
  %158 = insertelement <2 x float> %157, float %154, i64 1
  %159 = fmul <2 x float> %158, %158
  %160 = insertelement <2 x float> %149, float %153, i64 1
  %161 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %160, <2 x float> %160, <2 x float> %159)
  %162 = insertelement <2 x float> %151, float %155, i64 1
  %163 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %162, <2 x float> %162, <2 x float> %161)
  %164 = insertelement <2 x float> %152, float %156, i64 1
  %165 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %164, <2 x float> %164, <2 x float> %163)
  %166 = fdiv <2 x float> <float 2.000000e+00, float 2.000000e+00>, %165
  %167 = fmul <2 x float> %162, %166
  %168 = fmul <2 x float> %158, %166
  %169 = fmul <2 x float> %158, %168
  %170 = fmul <2 x float> %164, %168
  %171 = fmul <2 x float> %160, %167
  %172 = fmul <2 x float> %160, %166
  %173 = fmul <2 x float> %160, %172
  %174 = fmul <2 x float> %164, %172
  %175 = fmul <2 x float> %158, %167
  %176 = fsub <2 x float> %171, %170
  %177 = fadd <2 x float> %175, %174
  %178 = fadd <2 x float> %173, %169
  %179 = fsub <2 x float> <float 1.000000e+00, float 1.000000e+00>, %178
  %180 = insertelement <2 x float> poison, float %c0local.sroa.2.0.copyload, i64 0
  %181 = insertelement <2 x float> %180, float %c1local.sroa.2.0.copyload, i64 1
  %182 = fmul <2 x float> %181, %177
  %183 = insertelement <2 x float> poison, float %c0local.sroa.0.0.copyload, i64 0
  %184 = insertelement <2 x float> %183, float %c1local.sroa.0.0.copyload, i64 1
  %185 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %184, <2 x float> %176, <2 x float> %182)
  %186 = insertelement <2 x float> poison, float %c0local.sroa.3.0.copyload, i64 0
  %187 = insertelement <2 x float> %186, float %c1local.sroa.3.0.copyload, i64 1
  %188 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %187, <2 x float> %179, <2 x float> %185)
  %189 = fmul <2 x float> %162, %167
  %190 = fmul <2 x float> %164, %167
  %191 = fmul <2 x float> %160, %168
  %192 = fadd <2 x float> %191, %190
  %193 = fadd <2 x float> %173, %189
  %194 = fsub <2 x float> <float 1.000000e+00, float 1.000000e+00>, %193
  %195 = fsub <2 x float> %175, %174
  %196 = fmul <2 x float> %181, %194
  %197 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %184, <2 x float> %192, <2 x float> %196)
  %198 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %187, <2 x float> %195, <2 x float> %197)
  %199 = fadd <2 x float> %171, %170
  %200 = fadd <2 x float> %169, %189
  %201 = fsub <2 x float> <float 1.000000e+00, float 1.000000e+00>, %200
  %202 = fsub <2 x float> %191, %190
  %203 = fmul <2 x float> %181, %202
  %204 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %184, <2 x float> %201, <2 x float> %203)
  %205 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %187, <2 x float> %199, <2 x float> %204)
  %206 = insertelement <2 x float> %146, float %tr.sroa.27.48.copyload.i128, i64 1
  %207 = fadd <2 x float> %206, %205
  %208 = insertelement <2 x float> poison, float %tr.sroa.29.48.copyload.i, i64 0
  %209 = insertelement <2 x float> %208, float %tr.sroa.29.48.copyload.i130, i64 1
  %210 = fadd <2 x float> %209, %198
  %211 = insertelement <2 x float> %147, float %tr.sroa.30.48.copyload.i132, i64 1
  %212 = fadd <2 x float> %211, %188
  %shift191 = shufflevector <2 x float> %207, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %213 = fsub <2 x float> %207, %shift191
  %shift192 = shufflevector <2 x float> %210, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %214 = fsub <2 x float> %210, %shift192
  %shift193 = shufflevector <2 x float> %212, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %215 = fsub <2 x float> %212, %shift193
  %retval.sroa.0.4.vec.insert.i.i180 = shufflevector <2 x float> %213, <2 x float> %214, <2 x i32> <i32 0, i32 2>
  %retval.sroa.3.12.vec.insert.i.i181194 = insertelement <2 x float> %215, float 0.000000e+00, i64 1
  store <2 x float> %retval.sroa.0.4.vec.insert.i.i180, ptr %DeltaC2, align 16
  %216 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %DeltaC2, i64 0, i32 1
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i181194, ptr %216, align 8
  store <2 x float> <float 1.000000e+00, float 0.000000e+00>, ptr %sepNormal, align 16
  %217 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %sepNormal, i64 0, i32 1
  store <2 x float> zeroinitializer, ptr %217, align 8
  %call98 = call fastcc noundef zeroext i1 @_ZL18findSeparatingAxisRK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_RK20b3AlignedObjectArrayIS2_ESB_RKS8_I9b3GpuFaceERKS8_IiESB_SB_SF_SI_RS2_(ptr noundef nonnull align 16 dereferenceable(96) %arrayidx78, ptr noundef nonnull align 16 dereferenceable(96) %arrayidx83, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 8 dereferenceable(25) %vertices, ptr noundef nonnull align 8 dereferenceable(25) %uniqueEdges, ptr noundef nonnull align 8 dereferenceable(25) %faces, ptr noundef nonnull align 8 dereferenceable(25) %vertices, ptr noundef nonnull align 8 dereferenceable(25) %uniqueEdges, ptr noundef nonnull align 8 dereferenceable(25) %faces, ptr noundef nonnull align 16 dereferenceable(16) %sepNormal)
  br i1 %call98, label %if.else100, label %if.end123

if.else100:                                       ; preds = %if.end74
  %call105 = call fastcc noundef zeroext i1 @_ZL18findSeparatingAxisRK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_RK20b3AlignedObjectArrayIS2_ESB_RKS8_I9b3GpuFaceERKS8_IiESB_SB_SF_SI_RS2_(ptr noundef nonnull align 16 dereferenceable(96) %arrayidx83, ptr noundef nonnull align 16 dereferenceable(96) %arrayidx78, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 8 dereferenceable(25) %vertices, ptr noundef nonnull align 8 dereferenceable(25) %uniqueEdges, ptr noundef nonnull align 8 dereferenceable(25) %faces, ptr noundef nonnull align 8 dereferenceable(25) %vertices, ptr noundef nonnull align 8 dereferenceable(25) %uniqueEdges, ptr noundef nonnull align 8 dereferenceable(25) %faces, ptr noundef nonnull align 16 dereferenceable(16) %sepNormal)
  br i1 %call105, label %if.else109, label %if.end123

if.else109:                                       ; preds = %if.else100
  %call114 = call noundef zeroext i1 @_Z26findSeparatingAxisEdgeEdgePK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_RK20b3AlignedObjectArrayIS2_ESB_RKS8_I9b3GpuFaceERKS8_IiEPS2_Pf(ptr noundef nonnull %arrayidx78, ptr noundef nonnull %arrayidx83, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %DeltaC2, ptr noundef nonnull align 8 dereferenceable(25) %vertices, ptr noundef nonnull align 8 dereferenceable(25) %uniqueEdges, ptr nonnull align 8 poison, ptr nonnull align 8 poison, ptr noundef nonnull %sepNormal, ptr noundef nonnull %dmin)
  %m_data.i184 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %gpuCompoundSepNormalsOut, i64 0, i32 5
  %218 = load ptr, ptr %m_data.i184, align 8
  %arrayidx.i186 = getelementptr inbounds %class.b3Vector3, ptr %218, i64 %idxprom
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx.i186, ptr noundef nonnull align 16 dereferenceable(16) %sepNormal, i64 16, i1 false)
  %219 = load ptr, ptr %m_data.i, align 8
  %arrayidx.i189 = getelementptr inbounds i32, ptr %219, i64 %idxprom
  store i32 1, ptr %arrayidx.i189, align 4
  br label %if.end123

if.end123:                                        ; preds = %if.else100, %if.end74, %if.else109, %if.end60, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define internal fastcc noundef zeroext i1 @_ZL18findSeparatingAxisRK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_RK20b3AlignedObjectArrayIS2_ESB_RKS8_I9b3GpuFaceERKS8_IiESB_SB_SF_SI_RS2_(ptr nocapture noundef nonnull readonly align 16 dereferenceable(96) %hullA, ptr noundef nonnull align 16 dereferenceable(96) %hullB, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %posA1, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %ornA, ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) %posB1, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %verticesA, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %uniqueEdgesA, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %facesA, ptr noundef nonnull align 8 dereferenceable(25) %verticesB, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %uniqueEdgesB, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %facesB, ptr nocapture noundef nonnull align 16 dereferenceable(16) %sep) unnamed_addr #5 personality ptr @__gxx_personality_v0 {
invoke.cont8:
  %Min1.i220 = alloca float, align 4
  %Max1.i221 = alloca float, align 4
  %Min1.i132 = alloca float, align 4
  %Max1.i133 = alloca float, align 4
  %Min1.i = alloca float, align 4
  %Max1.i = alloca float, align 4
  %posB = alloca %class.b3Vector3, align 16
  %faceANormalWS = alloca %class.b3Vector3, align 16
  %WorldNormal = alloca %class.b3Vector3, align 16
  %crossje = alloca %class.b3Vector3, align 16
  tail call void @b3EnterProfileZone(ptr noundef nonnull @.str.73)
  %0 = load i32, ptr @b3g_actualSATPairTests, align 4
  %inc = add nsw i32 %0, 1
  store i32 %inc, ptr @b3g_actualSATPairTests, align 4
  %posA.sroa.0.0.copyload = load float, ptr %posA1, align 16
  %posA.sroa.5.0.posA1.sroa_idx = getelementptr inbounds i8, ptr %posA1, i64 4
  %posA.sroa.5.0.copyload = load float, ptr %posA.sroa.5.0.posA1.sroa_idx, align 4
  %posA.sroa.9.0.posA1.sroa_idx = getelementptr inbounds i8, ptr %posA1, i64 8
  %posA.sroa.9.0.copyload = load float, ptr %posA.sroa.9.0.posA1.sroa_idx, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %posB1, i64 16, i1 false)
  %w1 = getelementptr inbounds %struct.anon.2, ptr %posB, i64 0, i32 3
  store float 0.000000e+00, ptr %w1, align 4
  %c0local.sroa.0.0.copyload = load float, ptr %hullA, align 16
  %c0local.sroa.2.0.hullA.sroa_idx = getelementptr inbounds i8, ptr %hullA, i64 4
  %c0local.sroa.2.0.copyload = load float, ptr %c0local.sroa.2.0.hullA.sroa_idx, align 4
  %c0local.sroa.3.0.hullA.sroa_idx = getelementptr inbounds i8, ptr %hullA, i64 8
  %c0local.sroa.3.0.copyload = load float, ptr %c0local.sroa.3.0.hullA.sroa_idx, align 8
  %1 = load float, ptr %ornA, align 16
  %arrayidx2.i.i.i.i1.i = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 1
  %2 = load float, ptr %arrayidx2.i.i.i.i1.i, align 4
  %mul4.i.i.i.i.i = fmul float %2, %2
  %3 = tail call float @llvm.fmuladd.f32(float %1, float %1, float %mul4.i.i.i.i.i)
  %arrayidx5.i.i.i.i.i = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 2
  %4 = load float, ptr %arrayidx5.i.i.i.i.i, align 8
  %5 = tail call float @llvm.fmuladd.f32(float %4, float %4, float %3)
  %arrayidx7.i.i.i.i.i = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 3
  %6 = load float, ptr %arrayidx7.i.i.i.i.i, align 4
  %7 = tail call noundef float @llvm.fmuladd.f32(float %6, float %6, float %5)
  %div.i.i.i = fdiv float 2.000000e+00, %7
  %mul.i.i.i = fmul float %1, %div.i.i.i
  %mul4.i.i.i = fmul float %2, %div.i.i.i
  %mul6.i.i.i = fmul float %4, %div.i.i.i
  %mul8.i.i.i = fmul float %6, %mul.i.i.i
  %mul10.i.i.i = fmul float %6, %mul4.i.i.i
  %mul12.i.i.i = fmul float %6, %mul6.i.i.i
  %mul14.i.i.i = fmul float %1, %mul.i.i.i
  %mul16.i.i.i = fmul float %1, %mul4.i.i.i
  %mul18.i.i.i = fmul float %1, %mul6.i.i.i
  %mul20.i.i.i = fmul float %2, %mul4.i.i.i
  %mul22.i.i.i = fmul float %2, %mul6.i.i.i
  %mul24.i.i.i = fmul float %4, %mul6.i.i.i
  %add.i.i.i = fadd float %mul20.i.i.i, %mul24.i.i.i
  %sub.i.i.i = fsub float 1.000000e+00, %add.i.i.i
  %sub26.i.i.i = fsub float %mul16.i.i.i, %mul12.i.i.i
  %add28.i.i.i = fadd float %mul18.i.i.i, %mul10.i.i.i
  %add30.i.i.i = fadd float %mul16.i.i.i, %mul12.i.i.i
  %add32.i.i.i = fadd float %mul14.i.i.i, %mul24.i.i.i
  %sub33.i.i.i = fsub float 1.000000e+00, %add32.i.i.i
  %sub35.i.i.i = fsub float %mul22.i.i.i, %mul8.i.i.i
  %sub37.i.i.i = fsub float %mul18.i.i.i, %mul10.i.i.i
  %add39.i.i.i = fadd float %mul22.i.i.i, %mul8.i.i.i
  %add41.i.i.i = fadd float %mul14.i.i.i, %mul20.i.i.i
  %sub42.i.i.i = fsub float 1.000000e+00, %add41.i.i.i
  %mul5.i.i.i.i = fmul float %c0local.sroa.2.0.copyload, %sub26.i.i.i
  %8 = tail call float @llvm.fmuladd.f32(float %c0local.sroa.0.0.copyload, float %sub.i.i.i, float %mul5.i.i.i.i)
  %9 = tail call noundef float @llvm.fmuladd.f32(float %c0local.sroa.3.0.copyload, float %add28.i.i.i, float %8)
  %mul5.i3.i.i.i = fmul float %c0local.sroa.2.0.copyload, %sub33.i.i.i
  %10 = tail call float @llvm.fmuladd.f32(float %c0local.sroa.0.0.copyload, float %add30.i.i.i, float %mul5.i3.i.i.i)
  %11 = tail call noundef float @llvm.fmuladd.f32(float %c0local.sroa.3.0.copyload, float %sub35.i.i.i, float %10)
  %mul5.i8.i.i.i = fmul float %c0local.sroa.2.0.copyload, %add39.i.i.i
  %12 = tail call float @llvm.fmuladd.f32(float %c0local.sroa.0.0.copyload, float %sub37.i.i.i, float %mul5.i8.i.i.i)
  %13 = tail call noundef float @llvm.fmuladd.f32(float %c0local.sroa.3.0.copyload, float %sub42.i.i.i, float %12)
  %add.i.i8.i = fadd float %posA.sroa.0.0.copyload, %9
  %add4.i.i.i = fadd float %posA.sroa.5.0.copyload, %11
  %add7.i.i.i = fadd float %posA.sroa.9.0.copyload, %13
  %c1local.sroa.0.0.copyload = load float, ptr %hullB, align 16
  %c1local.sroa.2.0.hullB.sroa_idx = getelementptr inbounds i8, ptr %hullB, i64 4
  %c1local.sroa.2.0.copyload = load float, ptr %c1local.sroa.2.0.hullB.sroa_idx, align 4
  %c1local.sroa.3.0.hullB.sroa_idx = getelementptr inbounds i8, ptr %hullB, i64 8
  %c1local.sroa.3.0.copyload = load float, ptr %c1local.sroa.3.0.hullB.sroa_idx, align 8
  %tr.sroa.27.48.copyload.i47 = load float, ptr %posB, align 16
  %tr.sroa.29.48.pos.sroa_idx.i48 = getelementptr inbounds i8, ptr %posB, i64 4
  %tr.sroa.29.48.copyload.i49 = load float, ptr %tr.sroa.29.48.pos.sroa_idx.i48, align 4
  %tr.sroa.30.48.pos.sroa_idx.i50 = getelementptr inbounds i8, ptr %posB, i64 8
  %tr.sroa.30.48.copyload.i51 = load float, ptr %tr.sroa.30.48.pos.sroa_idx.i50, align 8
  %14 = load float, ptr %ornB, align 16
  %arrayidx2.i.i.i.i1.i52 = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 1
  %15 = load float, ptr %arrayidx2.i.i.i.i1.i52, align 4
  %mul4.i.i.i.i.i53 = fmul float %15, %15
  %16 = tail call float @llvm.fmuladd.f32(float %14, float %14, float %mul4.i.i.i.i.i53)
  %arrayidx5.i.i.i.i.i54 = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 2
  %17 = load float, ptr %arrayidx5.i.i.i.i.i54, align 8
  %18 = tail call float @llvm.fmuladd.f32(float %17, float %17, float %16)
  %arrayidx7.i.i.i.i.i55 = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 3
  %19 = load float, ptr %arrayidx7.i.i.i.i.i55, align 4
  %20 = tail call noundef float @llvm.fmuladd.f32(float %19, float %19, float %18)
  %div.i.i.i56 = fdiv float 2.000000e+00, %20
  %mul.i.i.i57 = fmul float %14, %div.i.i.i56
  %mul4.i.i.i58 = fmul float %15, %div.i.i.i56
  %mul6.i.i.i59 = fmul float %17, %div.i.i.i56
  %mul8.i.i.i60 = fmul float %19, %mul.i.i.i57
  %mul10.i.i.i61 = fmul float %19, %mul4.i.i.i58
  %mul12.i.i.i62 = fmul float %19, %mul6.i.i.i59
  %mul14.i.i.i63 = fmul float %14, %mul.i.i.i57
  %mul16.i.i.i64 = fmul float %14, %mul4.i.i.i58
  %mul18.i.i.i65 = fmul float %14, %mul6.i.i.i59
  %mul20.i.i.i66 = fmul float %15, %mul4.i.i.i58
  %mul22.i.i.i67 = fmul float %15, %mul6.i.i.i59
  %mul24.i.i.i68 = fmul float %17, %mul6.i.i.i59
  %add.i.i.i69 = fadd float %mul20.i.i.i66, %mul24.i.i.i68
  %sub.i.i.i70 = fsub float 1.000000e+00, %add.i.i.i69
  %sub26.i.i.i71 = fsub float %mul16.i.i.i64, %mul12.i.i.i62
  %add28.i.i.i72 = fadd float %mul18.i.i.i65, %mul10.i.i.i61
  %add30.i.i.i73 = fadd float %mul16.i.i.i64, %mul12.i.i.i62
  %add32.i.i.i74 = fadd float %mul14.i.i.i63, %mul24.i.i.i68
  %sub33.i.i.i75 = fsub float 1.000000e+00, %add32.i.i.i74
  %sub35.i.i.i76 = fsub float %mul22.i.i.i67, %mul8.i.i.i60
  %sub37.i.i.i77 = fsub float %mul18.i.i.i65, %mul10.i.i.i61
  %add39.i.i.i78 = fadd float %mul22.i.i.i67, %mul8.i.i.i60
  %add41.i.i.i79 = fadd float %mul14.i.i.i63, %mul20.i.i.i66
  %sub42.i.i.i80 = fsub float 1.000000e+00, %add41.i.i.i79
  %mul5.i.i.i.i82 = fmul float %c1local.sroa.2.0.copyload, %sub26.i.i.i71
  %21 = tail call float @llvm.fmuladd.f32(float %c1local.sroa.0.0.copyload, float %sub.i.i.i70, float %mul5.i.i.i.i82)
  %22 = tail call noundef float @llvm.fmuladd.f32(float %c1local.sroa.3.0.copyload, float %add28.i.i.i72, float %21)
  %mul5.i3.i.i.i84 = fmul float %c1local.sroa.2.0.copyload, %sub33.i.i.i75
  %23 = tail call float @llvm.fmuladd.f32(float %c1local.sroa.0.0.copyload, float %add30.i.i.i73, float %mul5.i3.i.i.i84)
  %24 = tail call noundef float @llvm.fmuladd.f32(float %c1local.sroa.3.0.copyload, float %sub35.i.i.i76, float %23)
  %mul5.i8.i.i.i85 = fmul float %c1local.sroa.2.0.copyload, %add39.i.i.i78
  %25 = tail call float @llvm.fmuladd.f32(float %c1local.sroa.0.0.copyload, float %sub37.i.i.i77, float %mul5.i8.i.i.i85)
  %26 = tail call noundef float @llvm.fmuladd.f32(float %c1local.sroa.3.0.copyload, float %sub42.i.i.i80, float %25)
  %add.i.i8.i86 = fadd float %tr.sroa.27.48.copyload.i47, %22
  %add4.i.i.i87 = fadd float %tr.sroa.29.48.copyload.i49, %24
  %add7.i.i.i88 = fadd float %tr.sroa.30.48.copyload.i51, %26
  %sub.i = fsub float %add.i.i8.i, %add.i.i8.i86
  %sub4.i = fsub float %add4.i.i.i, %add4.i.i.i87
  %sub7.i = fsub float %add7.i.i.i, %add7.i.i.i88
  %m_numFaces = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 6
  %27 = load i32, ptr %m_numFaces, align 8
  %cmp76 = icmp sgt i32 %27, 0
  br i1 %cmp76, label %invoke.cont18.lr.ph, label %for.end

invoke.cont18.lr.ph:                              ; preds = %invoke.cont8
  %m_faceOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 5
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %facesA, i64 0, i32 5
  %28 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %faceANormalWS, i64 0, i32 1
  %arrayidx4.i.i = getelementptr inbounds [4 x float], ptr %faceANormalWS, i64 0, i64 1
  %m_numVertices.i = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 7
  %m_vertexOffset.i = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 8
  %m_data.i.i = getelementptr inbounds %class.b3AlignedObjectArray, ptr %verticesA, i64 0, i32 5
  br label %invoke.cont18

invoke.cont18:                                    ; preds = %invoke.cont18.lr.ph, %for.inc
  %dmin.078 = phi float [ 0x47EFFFFFE0000000, %invoke.cont18.lr.ph ], [ %dmin.1, %for.inc ]
  %i.077 = phi i32 [ 0, %invoke.cont18.lr.ph ], [ %inc30, %for.inc ]
  %29 = load i32, ptr %m_faceOffset, align 4
  %add = add nsw i32 %29, %i.077
  %30 = load ptr, ptr %m_data.i, align 8
  %idxprom.i = sext i32 %add to i64
  %arrayidx.i = getelementptr inbounds %struct.b3GpuFace, ptr %30, i64 %idxprom.i
  %31 = load float, ptr %arrayidx7.i.i.i.i.i, align 4
  %32 = load float, ptr %arrayidx.i, align 4
  %33 = load float, ptr %arrayidx5.i.i.i.i.i, align 8
  %arrayidx.i26.i.i = getelementptr inbounds [4 x float], ptr %arrayidx.i, i64 0, i64 1
  %neg.i.i = fneg float %33
  %34 = load <2 x float>, ptr %arrayidx.i26.i.i, align 4
  %35 = shufflevector <2 x float> %34, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %36 = load <2 x float>, ptr %ornA, align 16
  %37 = shufflevector <2 x float> %36, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %38 = extractelement <2 x float> %36, i64 1
  %39 = extractelement <2 x float> %34, i64 1
  %40 = fmul <2 x float> %37, %35
  %mul4.i.i = extractelement <2 x float> %40, i64 0
  %41 = call float @llvm.fmuladd.f32(float %31, float %32, float %mul4.i.i)
  %42 = extractelement <2 x float> %34, i64 0
  %43 = call float @llvm.fmuladd.f32(float %neg.i.i, float %42, float %41)
  %44 = insertelement <2 x float> %34, float %32, i64 1
  %45 = insertelement <2 x float> %36, float %33, i64 1
  %46 = fmul <2 x float> %44, %45
  %47 = insertelement <2 x float> poison, float %31, i64 0
  %48 = shufflevector <2 x float> %47, <2 x float> poison, <2 x i32> zeroinitializer
  %49 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %48, <2 x float> %35, <2 x float> %46)
  %50 = fneg <2 x float> %37
  %51 = insertelement <2 x float> %34, float %32, i64 0
  %52 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %50, <2 x float> %51, <2 x float> %49)
  %53 = extractelement <2 x float> %50, i64 0
  %neg31.i.i = fmul float %42, %53
  %54 = extractelement <2 x float> %50, i64 1
  %55 = call float @llvm.fmuladd.f32(float %54, float %32, float %neg31.i.i)
  %56 = call float @llvm.fmuladd.f32(float %neg.i.i, float %39, float %55)
  %57 = extractelement <2 x float> %52, i64 1
  %mul14.i.i = fmul float %31, %57
  %58 = call float @llvm.fmuladd.f32(float %56, float %53, float %mul14.i.i)
  %59 = extractelement <2 x float> %52, i64 0
  %60 = call float @llvm.fmuladd.f32(float %59, float %54, float %58)
  %61 = call float @llvm.fmuladd.f32(float %43, float %33, float %60)
  %62 = shufflevector <2 x float> %52, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %63 = insertelement <2 x float> %62, float %43, i64 0
  %64 = fmul <2 x float> %48, %63
  %65 = insertelement <2 x float> poison, float %56, i64 0
  %66 = shufflevector <2 x float> %65, <2 x float> poison, <2 x i32> zeroinitializer
  %67 = shufflevector <2 x float> %50, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %68 = insertelement <2 x float> %67, float %neg.i.i, i64 1
  %69 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %66, <2 x float> %68, <2 x float> %64)
  %70 = shufflevector <2 x float> %52, <2 x float> %63, <2 x i32> <i32 1, i32 2>
  %71 = shufflevector <2 x float> %68, <2 x float> %50, <2 x i32> <i32 1, i32 2>
  %72 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %70, <2 x float> %71, <2 x float> %69)
  %73 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %52, <2 x float> %37, <2 x float> %72)
  %retval.sroa.0.4.vec.insert.i15.i = insertelement <2 x float> %73, float %61, i64 1
  %74 = shufflevector <2 x float> <float poison, float 0.000000e+00>, <2 x float> %73, <2 x i32> <i32 3, i32 1>
  store <2 x float> %retval.sroa.0.4.vec.insert.i15.i, ptr %faceANormalWS, align 16
  store <2 x float> %74, ptr %28, align 8
  %mul5.i.i = fmul float %sub4.i, %61
  %75 = extractelement <2 x float> %73, i64 0
  %76 = call float @llvm.fmuladd.f32(float %sub.i, float %75, float %mul5.i.i)
  %77 = extractelement <2 x float> %73, i64 1
  %78 = call noundef float @llvm.fmuladd.f32(float %sub7.i, float %77, float %76)
  %cmp20 = fcmp olt float %78, 0.000000e+00
  br i1 %cmp20, label %if.then, label %if.end

if.then:                                          ; preds = %invoke.cont18
  %79 = fneg <2 x float> %73
  %80 = extractelement <2 x float> %79, i64 0
  store float %80, ptr %faceANormalWS, align 16
  %mul3.i = fneg float %61
  store float %mul3.i, ptr %arrayidx4.i.i, align 4
  %81 = extractelement <2 x float> %79, i64 1
  store float %81, ptr %28, align 8
  br label %if.end

lpad.loopexit:                                    ; preds = %.noexc231
  %lpad.loopexit59 = landingpad { ptr, i32 }
          cleanup
  br label %lpad

lpad.loopexit.split-lp.loopexit:                  ; preds = %.noexc143
  %lpad.loopexit61 = landingpad { ptr, i32 }
          cleanup
  br label %lpad

lpad.loopexit.split-lp.loopexit.split-lp:         ; preds = %.noexc
  %lpad.loopexit.split-lp62 = landingpad { ptr, i32 }
          cleanup
  br label %lpad

lpad:                                             ; preds = %lpad.loopexit.split-lp.loopexit, %lpad.loopexit.split-lp.loopexit.split-lp, %lpad.loopexit
  %lpad.phi = phi { ptr, i32 } [ %lpad.loopexit59, %lpad.loopexit ], [ %lpad.loopexit61, %lpad.loopexit.split-lp.loopexit ], [ %lpad.loopexit.split-lp62, %lpad.loopexit.split-lp.loopexit.split-lp ]
  invoke void @b3LeaveProfileZone()
          to label %_ZN13b3ProfileZoneD2Ev.exit unwind label %terminate.lpad.i

terminate.lpad.i:                                 ; preds = %lpad
  %82 = landingpad { ptr, i32 }
          catch ptr null
  %83 = extractvalue { ptr, i32 } %82, 0
  call void @__clang_call_terminate(ptr %83) #27
  unreachable

_ZN13b3ProfileZoneD2Ev.exit:                      ; preds = %lpad
  resume { ptr, i32 } %lpad.phi

if.end:                                           ; preds = %if.then, %invoke.cont18
  %84 = phi float [ %mul3.i, %if.then ], [ %61, %invoke.cont18 ]
  %85 = phi <2 x float> [ %79, %if.then ], [ %73, %invoke.cont18 ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %Min1.i)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %Max1.i)
  %86 = load i32, ptr %m_numVertices.i, align 4
  %87 = extractelement <2 x float> %85, i64 1
  %mul4.i.i.i259 = fmul float %87, %53
  %88 = extractelement <2 x float> %85, i64 0
  %89 = call float @llvm.fmuladd.f32(float %31, float %88, float %mul4.i.i.i259)
  %90 = call float @llvm.fmuladd.f32(float %33, float %84, float %89)
  %mul12.i.i.i260 = fmul float %88, %neg.i.i
  %91 = call float @llvm.fmuladd.f32(float %31, float %84, float %mul12.i.i.i260)
  %92 = extractelement <2 x float> %36, i64 0
  %93 = call float @llvm.fmuladd.f32(float %92, float %87, float %91)
  %mul21.i.i.i = fmul float %84, %54
  %94 = call float @llvm.fmuladd.f32(float %31, float %87, float %mul21.i.i.i)
  %95 = call float @llvm.fmuladd.f32(float %38, float %88, float %94)
  %neg31.i.i.i = fmul float %38, %84
  %96 = call float @llvm.fmuladd.f32(float %92, float %88, float %neg31.i.i.i)
  %97 = call float @llvm.fmuladd.f32(float %33, float %87, float %96)
  %mul4.i9.i.i = fmul float %31, %90
  %98 = call float @llvm.fmuladd.f32(float %97, float %92, float %mul4.i9.i.i)
  %99 = call float @llvm.fmuladd.f32(float %93, float %33, float %98)
  %100 = call float @llvm.fmuladd.f32(float %95, float %53, float %99)
  %mul14.i.i.i261 = fmul float %31, %93
  %101 = call float @llvm.fmuladd.f32(float %97, float %38, float %mul14.i.i.i261)
  %102 = call float @llvm.fmuladd.f32(float %95, float %92, float %101)
  %103 = call float @llvm.fmuladd.f32(float %90, float %neg.i.i, float %102)
  %mul25.i.i.i = fmul float %31, %95
  %104 = call float @llvm.fmuladd.f32(float %97, float %33, float %mul25.i.i.i)
  %105 = call float @llvm.fmuladd.f32(float %90, float %38, float %104)
  %106 = call float @llvm.fmuladd.f32(float %93, float %54, float %105)
  %cmp27.i = icmp sgt i32 %86, 0
  br i1 %cmp27.i, label %for.body.lr.ph.i, label %.noexc

for.body.lr.ph.i:                                 ; preds = %if.end
  %107 = load i32, ptr %m_vertexOffset.i, align 16
  %108 = load ptr, ptr %m_data.i.i, align 8
  %109 = sext i32 %107 to i64
  %110 = zext nneg i32 %86 to i64
  %invariant.gep = getelementptr %class.b3Vector3, ptr %108, i64 %109
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %for.body.lr.ph.i
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body.i ], [ 0, %for.body.lr.ph.i ]
  %Max0.i.0 = phi float [ %Max0.i.1, %for.body.i ], [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i ]
  %Min0.i.0 = phi float [ %Min0.i.1, %for.body.i ], [ 0x47EFFFFFE0000000, %for.body.lr.ph.i ]
  %111 = phi float [ %118, %for.body.i ], [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i ]
  %gep = getelementptr %class.b3Vector3, ptr %invariant.gep, i64 %indvars.iv
  %112 = load float, ptr %gep, align 16
  %arrayidx3.i.i22.i = getelementptr inbounds [4 x float], ptr %gep, i64 0, i64 1
  %113 = load float, ptr %arrayidx3.i.i22.i, align 4
  %mul5.i.i24.i = fmul float %103, %113
  %114 = call float @llvm.fmuladd.f32(float %112, float %100, float %mul5.i.i24.i)
  %arrayidx6.i.i25.i = getelementptr inbounds [4 x float], ptr %gep, i64 0, i64 2
  %115 = load float, ptr %arrayidx6.i.i25.i, align 8
  %116 = call noundef float @llvm.fmuladd.f32(float %115, float %106, float %114)
  %cmp9.i = fcmp olt float %116, %Min0.i.0
  %Min0.i.1 = select i1 %cmp9.i, float %116, float %Min0.i.0
  %117 = select i1 %cmp9.i, float %Max0.i.0, float %111
  %cmp10.i = fcmp ogt float %116, %117
  %Max0.i.1 = select i1 %cmp10.i, float %116, float %Max0.i.0
  %118 = select i1 %cmp10.i, float %116, float %117
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next, %110
  br i1 %exitcond.not.i, label %for.end.i, label %for.body.i, !llvm.loop !28

for.end.i:                                        ; preds = %for.body.i
  %cmp13.i = fcmp ogt float %Min0.i.1, %118
  br i1 %cmp13.i, label %if.then14.i, label %.noexc

if.then14.i:                                      ; preds = %for.end.i
  br label %.noexc

.noexc:                                           ; preds = %if.end, %if.then14.i, %for.end.i
  %Max0.i.3 = phi float [ %Max0.i.1, %for.end.i ], [ %Min0.i.1, %if.then14.i ], [ 0x47EFFFFFE0000000, %if.end ]
  %119 = phi float [ %Min0.i.1, %for.end.i ], [ %118, %if.then14.i ], [ 0xC7EFFFFFE0000000, %if.end ]
  %mul5.i.i.i262 = fmul float %posA.sroa.5.0.copyload, %84
  %120 = call float @llvm.fmuladd.f32(float %posA.sroa.0.0.copyload, float %88, float %mul5.i.i.i262)
  %121 = call noundef float @llvm.fmuladd.f32(float %posA.sroa.9.0.copyload, float %87, float %120)
  %add16.i = fadd float %121, %119
  %add17.i = fadd float %121, %Max0.i.3
  invoke void @_Z7projectRK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionS4_RK20b3AlignedObjectArrayIS2_ERfSC_(ptr noundef nonnull align 16 dereferenceable(96) %hullB, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %faceANormalWS, ptr noundef nonnull align 8 dereferenceable(25) %verticesB, ptr noundef nonnull align 4 dereferenceable(4) %Min1.i, ptr noundef nonnull align 4 dereferenceable(4) %Max1.i)
          to label %.noexc96 unwind label %lpad.loopexit.split-lp.loopexit.split-lp

.noexc96:                                         ; preds = %.noexc
  %122 = load float, ptr %Min1.i, align 4
  %cmp.i = fcmp olt float %add17.i, %122
  br i1 %cmp.i, label %invoke.cont23.thread, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %.noexc96
  %123 = load float, ptr %Max1.i, align 4
  %cmp1.i = fcmp olt float %123, %add16.i
  br i1 %cmp1.i, label %invoke.cont23.thread, label %if.end26

invoke.cont23.thread:                             ; preds = %lor.lhs.false.i, %.noexc96
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %Min1.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %Max1.i)
  br label %cleanup

if.end26:                                         ; preds = %lor.lhs.false.i
  %sub.i95 = fsub float %add17.i, %122
  %sub2.i = fsub float %123, %add16.i
  %cmp3.i = fcmp olt float %sub.i95, %sub2.i
  %cond.i = select i1 %cmp3.i, float %sub.i95, float %sub2.i
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %Min1.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %Max1.i)
  %cmp27 = fcmp olt float %cond.i, %dmin.078
  br i1 %cmp27, label %if.then28, label %for.inc

if.then28:                                        ; preds = %if.end26
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %sep, ptr noundef nonnull align 16 dereferenceable(16) %faceANormalWS, i64 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end26, %if.then28
  %dmin.1 = phi float [ %cond.i, %if.then28 ], [ %dmin.078, %if.end26 ]
  %inc30 = add nuw nsw i32 %i.077, 1
  %exitcond.not = icmp eq i32 %inc30, %27
  br i1 %exitcond.not, label %for.end, label %invoke.cont18, !llvm.loop !49

for.end:                                          ; preds = %for.inc, %invoke.cont8
  %dmin.0.lcssa = phi float [ 0x47EFFFFFE0000000, %invoke.cont8 ], [ %dmin.1, %for.inc ]
  %m_numFaces31 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullB, i64 0, i32 6
  %124 = load i32, ptr %m_numFaces31, align 8
  %cmp3479 = icmp sgt i32 %124, 0
  br i1 %cmp3479, label %invoke.cont46.lr.ph, label %for.cond65.preheader

invoke.cont46.lr.ph:                              ; preds = %for.end
  %m_faceOffset37 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullB, i64 0, i32 5
  %m_data.i97 = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %facesB, i64 0, i32 5
  %125 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %WorldNormal, i64 0, i32 1
  %arrayidx4.i.i121 = getelementptr inbounds [4 x float], ptr %WorldNormal, i64 0, i64 1
  %m_numVertices.i264 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 7
  %m_vertexOffset.i291 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 8
  %m_data.i.i292 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %verticesA, i64 0, i32 5
  br label %invoke.cont46

for.cond65.preheader:                             ; preds = %for.inc62, %for.end
  %dmin.2.lcssa = phi float [ %dmin.0.lcssa, %for.end ], [ %dmin.3, %for.inc62 ]
  %m_numUniqueEdges = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 10
  %126 = load i32, ptr %m_numUniqueEdges, align 8
  %cmp6691 = icmp sgt i32 %126, 0
  br i1 %cmp6691, label %invoke.cont71.lr.ph, label %invoke.cont122

invoke.cont71.lr.ph:                              ; preds = %for.cond65.preheader
  %m_uniqueEdgesOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 9
  %m_data.i146 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %uniqueEdgesA, i64 0, i32 5
  %m_numUniqueEdges76 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullB, i64 0, i32 10
  %m_uniqueEdgesOffset79 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullB, i64 0, i32 9
  %m_data.i169 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %uniqueEdgesB, i64 0, i32 5
  %127 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %crossje, i64 0, i32 1
  %y.i = getelementptr inbounds %struct.anon.2, ptr %crossje, i64 0, i32 1
  %m_numVertices.i311 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 7
  %m_vertexOffset.i338 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %hullA, i64 0, i32 8
  %m_data.i.i339 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %verticesA, i64 0, i32 5
  %.pre = load i32, ptr %m_numUniqueEdges76, align 8
  br label %invoke.cont71

invoke.cont46:                                    ; preds = %invoke.cont46.lr.ph, %for.inc62
  %dmin.281 = phi float [ %dmin.0.lcssa, %invoke.cont46.lr.ph ], [ %dmin.3, %for.inc62 ]
  %i32.080 = phi i32 [ 0, %invoke.cont46.lr.ph ], [ %inc63, %for.inc62 ]
  %128 = load i32, ptr %m_faceOffset37, align 4
  %add38 = add nsw i32 %128, %i32.080
  %129 = load ptr, ptr %m_data.i97, align 8
  %idxprom.i98 = sext i32 %add38 to i64
  %arrayidx.i99 = getelementptr inbounds %struct.b3GpuFace, ptr %129, i64 %idxprom.i98
  %normal36.sroa.0.0.copyload = load float, ptr %arrayidx.i99, align 16
  %normal36.sroa.2.0.arrayidx.i99.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i99, i64 4
  %130 = load float, ptr %arrayidx7.i.i.i.i.i55, align 4
  %131 = load float, ptr %arrayidx5.i.i.i.i.i54, align 8
  %neg.i.i106 = fneg float %131
  %132 = load <2 x float>, ptr %normal36.sroa.2.0.arrayidx.i99.sroa_idx, align 4
  %133 = shufflevector <2 x float> %132, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %134 = load <2 x float>, ptr %ornB, align 16
  %135 = shufflevector <2 x float> %134, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %136 = extractelement <2 x float> %132, i64 1
  %137 = fmul <2 x float> %133, %135
  %mul4.i.i103 = extractelement <2 x float> %137, i64 0
  %138 = call float @llvm.fmuladd.f32(float %130, float %normal36.sroa.0.0.copyload, float %mul4.i.i103)
  %139 = extractelement <2 x float> %132, i64 0
  %140 = call float @llvm.fmuladd.f32(float %neg.i.i106, float %139, float %138)
  %141 = insertelement <2 x float> %132, float %normal36.sroa.0.0.copyload, i64 1
  %142 = insertelement <2 x float> %134, float %131, i64 1
  %143 = fmul <2 x float> %141, %142
  %144 = insertelement <2 x float> poison, float %130, i64 0
  %145 = shufflevector <2 x float> %144, <2 x float> poison, <2 x i32> zeroinitializer
  %146 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %145, <2 x float> %133, <2 x float> %143)
  %147 = fneg <2 x float> %135
  %148 = insertelement <2 x float> %132, float %normal36.sroa.0.0.copyload, i64 0
  %149 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %147, <2 x float> %148, <2 x float> %146)
  %150 = extractelement <2 x float> %147, i64 0
  %neg31.i.i111 = fmul float %139, %150
  %151 = extractelement <2 x float> %147, i64 1
  %152 = call float @llvm.fmuladd.f32(float %151, float %normal36.sroa.0.0.copyload, float %neg31.i.i111)
  %153 = call float @llvm.fmuladd.f32(float %neg.i.i106, float %136, float %152)
  %154 = extractelement <2 x float> %149, i64 1
  %mul14.i.i113 = fmul float %130, %154
  %155 = call float @llvm.fmuladd.f32(float %153, float %150, float %mul14.i.i113)
  %156 = extractelement <2 x float> %149, i64 0
  %157 = call float @llvm.fmuladd.f32(float %156, float %151, float %155)
  %158 = call float @llvm.fmuladd.f32(float %140, float %131, float %157)
  %159 = shufflevector <2 x float> %149, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %160 = insertelement <2 x float> %159, float %140, i64 0
  %161 = fmul <2 x float> %145, %160
  %162 = insertelement <2 x float> poison, float %153, i64 0
  %163 = shufflevector <2 x float> %162, <2 x float> poison, <2 x i32> zeroinitializer
  %164 = shufflevector <2 x float> %147, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %165 = insertelement <2 x float> %164, float %neg.i.i106, i64 1
  %166 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %163, <2 x float> %165, <2 x float> %161)
  %167 = shufflevector <2 x float> %149, <2 x float> %160, <2 x i32> <i32 1, i32 2>
  %168 = shufflevector <2 x float> %165, <2 x float> %147, <2 x i32> <i32 1, i32 2>
  %169 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %167, <2 x float> %168, <2 x float> %166)
  %170 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %149, <2 x float> %135, <2 x float> %169)
  %retval.sroa.0.4.vec.insert.i15.i116 = insertelement <2 x float> %170, float %158, i64 1
  %171 = shufflevector <2 x float> <float poison, float 0.000000e+00>, <2 x float> %170, <2 x i32> <i32 3, i32 1>
  store <2 x float> %retval.sroa.0.4.vec.insert.i15.i116, ptr %WorldNormal, align 16
  store <2 x float> %171, ptr %125, align 8
  %mul5.i.i122 = fmul float %sub4.i, %158
  %172 = extractelement <2 x float> %170, i64 0
  %173 = call float @llvm.fmuladd.f32(float %sub.i, float %172, float %mul5.i.i122)
  %174 = extractelement <2 x float> %170, i64 1
  %175 = call noundef float @llvm.fmuladd.f32(float %sub7.i, float %174, float %173)
  %cmp48 = fcmp olt float %175, 0.000000e+00
  br i1 %cmp48, label %if.then49, label %if.end52

if.then49:                                        ; preds = %invoke.cont46
  %176 = fneg <2 x float> %170
  %177 = extractelement <2 x float> %176, i64 0
  store float %177, ptr %WorldNormal, align 16
  %mul3.i127 = fneg float %158
  store float %mul3.i127, ptr %arrayidx4.i.i121, align 4
  %178 = extractelement <2 x float> %176, i64 1
  store float %178, ptr %125, align 8
  br label %if.end52

if.end52:                                         ; preds = %if.then49, %invoke.cont46
  %179 = phi float [ %mul3.i127, %if.then49 ], [ %158, %invoke.cont46 ]
  %180 = phi <2 x float> [ %176, %if.then49 ], [ %170, %invoke.cont46 ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %Min1.i132)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %Max1.i133)
  %181 = load i32, ptr %m_numVertices.i264, align 4
  %182 = load float, ptr %ornA, align 16
  %fneg.i.i265 = fneg float %182
  %183 = load float, ptr %arrayidx2.i.i.i.i1.i, align 4
  %fneg4.i.i267 = fneg float %183
  %184 = load float, ptr %arrayidx5.i.i.i.i.i, align 8
  %fneg7.i.i269 = fneg float %184
  %185 = load float, ptr %arrayidx7.i.i.i.i.i, align 4
  %186 = extractelement <2 x float> %180, i64 1
  %mul4.i.i.i272 = fmul float %186, %fneg4.i.i267
  %187 = extractelement <2 x float> %180, i64 0
  %188 = call float @llvm.fmuladd.f32(float %185, float %187, float %mul4.i.i.i272)
  %189 = call float @llvm.fmuladd.f32(float %184, float %179, float %188)
  %mul12.i.i.i274 = fmul float %187, %fneg7.i.i269
  %190 = call float @llvm.fmuladd.f32(float %185, float %179, float %mul12.i.i.i274)
  %191 = call float @llvm.fmuladd.f32(float %182, float %186, float %190)
  %mul21.i.i.i275 = fmul float %179, %fneg.i.i265
  %192 = call float @llvm.fmuladd.f32(float %185, float %186, float %mul21.i.i.i275)
  %193 = call float @llvm.fmuladd.f32(float %183, float %187, float %192)
  %neg31.i.i.i276 = fmul float %183, %179
  %194 = call float @llvm.fmuladd.f32(float %182, float %187, float %neg31.i.i.i276)
  %195 = call float @llvm.fmuladd.f32(float %184, float %186, float %194)
  %mul4.i9.i.i277 = fmul float %185, %189
  %196 = call float @llvm.fmuladd.f32(float %195, float %182, float %mul4.i9.i.i277)
  %197 = call float @llvm.fmuladd.f32(float %191, float %184, float %196)
  %198 = call float @llvm.fmuladd.f32(float %193, float %fneg4.i.i267, float %197)
  %mul14.i.i.i278 = fmul float %185, %191
  %199 = call float @llvm.fmuladd.f32(float %195, float %183, float %mul14.i.i.i278)
  %200 = call float @llvm.fmuladd.f32(float %193, float %182, float %199)
  %201 = call float @llvm.fmuladd.f32(float %189, float %fneg7.i.i269, float %200)
  %mul25.i.i.i279 = fmul float %185, %193
  %202 = call float @llvm.fmuladd.f32(float %195, float %184, float %mul25.i.i.i279)
  %203 = call float @llvm.fmuladd.f32(float %189, float %183, float %202)
  %204 = call float @llvm.fmuladd.f32(float %191, float %fneg.i.i265, float %203)
  %cmp27.i282 = icmp sgt i32 %181, 0
  br i1 %cmp27.i282, label %for.body.lr.ph.i290, label %.noexc143

for.body.lr.ph.i290:                              ; preds = %if.end52
  %205 = load i32, ptr %m_vertexOffset.i291, align 16
  %206 = load ptr, ptr %m_data.i.i292, align 8
  %207 = sext i32 %205 to i64
  %208 = zext nneg i32 %181 to i64
  %invariant.gep118 = getelementptr %class.b3Vector3, ptr %206, i64 %207
  br label %for.body.i293

for.body.i293:                                    ; preds = %for.body.i293, %for.body.lr.ph.i290
  %indvars.iv102 = phi i64 [ %indvars.iv.next103, %for.body.i293 ], [ 0, %for.body.lr.ph.i290 ]
  %Max0.i131.0 = phi float [ %Max0.i131.1, %for.body.i293 ], [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i290 ]
  %Min0.i130.0 = phi float [ %Min0.i130.1, %for.body.i293 ], [ 0x47EFFFFFE0000000, %for.body.lr.ph.i290 ]
  %209 = phi float [ %216, %for.body.i293 ], [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i290 ]
  %gep119 = getelementptr %class.b3Vector3, ptr %invariant.gep118, i64 %indvars.iv102
  %210 = load float, ptr %gep119, align 16
  %arrayidx3.i.i22.i298 = getelementptr inbounds [4 x float], ptr %gep119, i64 0, i64 1
  %211 = load float, ptr %arrayidx3.i.i22.i298, align 4
  %mul5.i.i24.i299 = fmul float %201, %211
  %212 = call float @llvm.fmuladd.f32(float %210, float %198, float %mul5.i.i24.i299)
  %arrayidx6.i.i25.i300 = getelementptr inbounds [4 x float], ptr %gep119, i64 0, i64 2
  %213 = load float, ptr %arrayidx6.i.i25.i300, align 8
  %214 = call noundef float @llvm.fmuladd.f32(float %213, float %204, float %212)
  %cmp9.i301 = fcmp olt float %214, %Min0.i130.0
  %Min0.i130.1 = select i1 %cmp9.i301, float %214, float %Min0.i130.0
  %215 = select i1 %cmp9.i301, float %Max0.i131.0, float %209
  %cmp10.i303 = fcmp ogt float %214, %215
  %Max0.i131.1 = select i1 %cmp10.i303, float %214, float %Max0.i131.0
  %216 = select i1 %cmp10.i303, float %214, float %215
  %indvars.iv.next103 = add nuw nsw i64 %indvars.iv102, 1
  %exitcond.not.i306 = icmp eq i64 %indvars.iv.next103, %208
  br i1 %exitcond.not.i306, label %for.end.i283, label %for.body.i293, !llvm.loop !28

for.end.i283:                                     ; preds = %for.body.i293
  %cmp13.i284 = fcmp ogt float %Min0.i130.1, %216
  br i1 %cmp13.i284, label %if.then14.i288, label %.noexc143

if.then14.i288:                                   ; preds = %for.end.i283
  br label %.noexc143

.noexc143:                                        ; preds = %if.end52, %if.then14.i288, %for.end.i283
  %Max0.i131.3 = phi float [ %Max0.i131.1, %for.end.i283 ], [ %Min0.i130.1, %if.then14.i288 ], [ 0x47EFFFFFE0000000, %if.end52 ]
  %217 = phi float [ %Min0.i130.1, %for.end.i283 ], [ %216, %if.then14.i288 ], [ 0xC7EFFFFFE0000000, %if.end52 ]
  %mul5.i.i.i285 = fmul float %posA.sroa.5.0.copyload, %179
  %218 = call float @llvm.fmuladd.f32(float %posA.sroa.0.0.copyload, float %187, float %mul5.i.i.i285)
  %219 = call noundef float @llvm.fmuladd.f32(float %posA.sroa.9.0.copyload, float %186, float %218)
  %add16.i286 = fadd float %219, %217
  %add17.i287 = fadd float %219, %Max0.i131.3
  invoke void @_Z7projectRK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionS4_RK20b3AlignedObjectArrayIS2_ERfSC_(ptr noundef nonnull align 16 dereferenceable(96) %hullB, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %WorldNormal, ptr noundef nonnull align 8 dereferenceable(25) %verticesB, ptr noundef nonnull align 4 dereferenceable(4) %Min1.i132, ptr noundef nonnull align 4 dereferenceable(4) %Max1.i133)
          to label %.noexc144 unwind label %lpad.loopexit.split-lp.loopexit

.noexc144:                                        ; preds = %.noexc143
  %220 = load float, ptr %Min1.i132, align 4
  %cmp.i134 = fcmp olt float %add17.i287, %220
  br i1 %cmp.i134, label %invoke.cont55.thread, label %lor.lhs.false.i135

lor.lhs.false.i135:                               ; preds = %.noexc144
  %221 = load float, ptr %Max1.i133, align 4
  %cmp1.i136 = fcmp olt float %221, %add16.i286
  br i1 %cmp1.i136, label %invoke.cont55.thread, label %if.end58

invoke.cont55.thread:                             ; preds = %lor.lhs.false.i135, %.noexc144
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %Min1.i132)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %Max1.i133)
  br label %cleanup

if.end58:                                         ; preds = %lor.lhs.false.i135
  %sub.i138 = fsub float %add17.i287, %220
  %sub2.i139 = fsub float %221, %add16.i286
  %cmp3.i140 = fcmp olt float %sub.i138, %sub2.i139
  %cond.i141 = select i1 %cmp3.i140, float %sub.i138, float %sub2.i139
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %Min1.i132)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %Max1.i133)
  %cmp59 = fcmp olt float %cond.i141, %dmin.281
  br i1 %cmp59, label %if.then60, label %for.inc62

if.then60:                                        ; preds = %if.end58
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %sep, ptr noundef nonnull align 16 dereferenceable(16) %WorldNormal, i64 16, i1 false)
  br label %for.inc62

for.inc62:                                        ; preds = %if.end58, %if.then60
  %dmin.3 = phi float [ %cond.i141, %if.then60 ], [ %dmin.281, %if.end58 ]
  %inc63 = add nuw nsw i32 %i32.080, 1
  %exitcond106.not = icmp eq i32 %inc63, %124
  br i1 %exitcond106.not, label %for.cond65.preheader, label %invoke.cont46, !llvm.loop !50

invoke.cont71:                                    ; preds = %invoke.cont71.lr.ph, %for.inc114
  %222 = phi i32 [ %126, %invoke.cont71.lr.ph ], [ %385, %for.inc114 ]
  %223 = phi i32 [ %.pre, %invoke.cont71.lr.ph ], [ %386, %for.inc114 ]
  %dmin.495 = phi float [ %dmin.2.lcssa, %invoke.cont71.lr.ph ], [ %dmin.5.lcssa, %for.inc114 ]
  %e0.094 = phi i32 [ 0, %invoke.cont71.lr.ph ], [ %inc115, %for.inc114 ]
  %224 = load i32, ptr %m_uniqueEdgesOffset, align 4
  %add68 = add nsw i32 %224, %e0.094
  %225 = load ptr, ptr %m_data.i146, align 8
  %idxprom.i147 = sext i32 %add68 to i64
  %arrayidx.i148 = getelementptr inbounds %class.b3Vector3, ptr %225, i64 %idxprom.i147
  %226 = load float, ptr %arrayidx7.i.i.i.i.i, align 4
  %arrayidx.i24.i.i151 = getelementptr inbounds [4 x float], ptr %arrayidx.i148, i64 0, i64 2
  %227 = load float, ptr %arrayidx.i24.i.i151, align 4
  %228 = load float, ptr %ornA, align 16
  %neg15.i.i157 = fneg float %228
  %229 = load <2 x float>, ptr %arrayidx2.i.i.i.i1.i, align 4
  %230 = shufflevector <2 x float> %229, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %231 = load <2 x float>, ptr %arrayidx.i148, align 4
  %232 = shufflevector <2 x float> %231, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %233 = extractelement <2 x float> %229, i64 1
  %234 = extractelement <2 x float> %231, i64 0
  %mul12.i.i156 = fmul float %234, %233
  %235 = extractelement <2 x float> %231, i64 1
  %236 = call float @llvm.fmuladd.f32(float %226, float %235, float %mul12.i.i156)
  %237 = call float @llvm.fmuladd.f32(float %neg15.i.i157, float %227, float %236)
  %238 = insertelement <2 x float> %229, float %228, i64 1
  %239 = insertelement <2 x float> %231, float %227, i64 0
  %240 = fmul <2 x float> %238, %239
  %241 = insertelement <2 x float> poison, float %226, i64 0
  %242 = shufflevector <2 x float> %241, <2 x float> poison, <2 x i32> zeroinitializer
  %243 = insertelement <2 x float> %231, float %227, i64 1
  %244 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %242, <2 x float> %243, <2 x float> %240)
  %245 = fneg <2 x float> %230
  %246 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %245, <2 x float> %232, <2 x float> %244)
  %247 = extractelement <2 x float> %245, i64 1
  %neg31.i.i160 = fmul float %235, %247
  %248 = call float @llvm.fmuladd.f32(float %neg15.i.i157, float %234, float %neg31.i.i160)
  %249 = extractelement <2 x float> %245, i64 0
  %250 = call float @llvm.fmuladd.f32(float %249, float %227, float %248)
  %251 = shufflevector <2 x float> %246, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %252 = insertelement <2 x float> %251, float %237, i64 0
  %253 = fmul <2 x float> %242, %252
  %254 = insertelement <2 x float> poison, float %250, i64 0
  %255 = shufflevector <2 x float> %254, <2 x float> poison, <2 x i32> zeroinitializer
  %256 = shufflevector <2 x float> %245, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %257 = insertelement <2 x float> %256, float %neg15.i.i157, i64 1
  %258 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %255, <2 x float> %257, <2 x float> %253)
  %259 = shufflevector <2 x float> %246, <2 x float> %252, <2 x i32> <i32 1, i32 2>
  %260 = shufflevector <2 x float> %257, <2 x float> %245, <2 x i32> <i32 1, i32 2>
  %261 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %259, <2 x float> %260, <2 x float> %258)
  %262 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %246, <2 x float> %230, <2 x float> %261)
  %263 = extractelement <2 x float> %246, i64 1
  %mul25.i.i163 = fmul float %226, %263
  %264 = call float @llvm.fmuladd.f32(float %250, float %249, float %mul25.i.i163)
  %265 = extractelement <2 x float> %246, i64 0
  %266 = call float @llvm.fmuladd.f32(float %265, float %247, float %264)
  %267 = call float @llvm.fmuladd.f32(float %237, float %228, float %266)
  %cmp7783 = icmp sgt i32 %223, 0
  br i1 %cmp7783, label %invoke.cont87.lr.ph, label %for.inc114

invoke.cont87.lr.ph:                              ; preds = %invoke.cont71
  %268 = extractelement <2 x float> %262, i64 1
  %269 = fneg float %268
  %270 = shufflevector <2 x float> %262, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %271 = insertelement <2 x float> %270, float %267, i64 0
  %272 = fneg <2 x float> %271
  br label %invoke.cont87

invoke.cont87:                                    ; preds = %invoke.cont87.lr.ph, %for.inc111
  %dmin.587 = phi float [ %dmin.495, %invoke.cont87.lr.ph ], [ %dmin.6, %for.inc111 ]
  %e1.086 = phi i32 [ 0, %invoke.cont87.lr.ph ], [ %inc112, %for.inc111 ]
  %273 = load i32, ptr %m_uniqueEdgesOffset79, align 4
  %add80 = add nsw i32 %273, %e1.086
  %274 = load ptr, ptr %m_data.i169, align 8
  %idxprom.i170 = sext i32 %add80 to i64
  %arrayidx.i171 = getelementptr inbounds %class.b3Vector3, ptr %274, i64 %idxprom.i170
  %edge1.sroa.0.0.copyload = load float, ptr %arrayidx.i171, align 16
  %edge1.sroa.2.0.arrayidx.i171.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i171, i64 4
  %275 = load float, ptr %arrayidx7.i.i.i.i.i55, align 4
  %276 = load float, ptr %ornB, align 16
  %277 = load <2 x float>, ptr %edge1.sroa.2.0.arrayidx.i171.sroa_idx, align 4
  %278 = shufflevector <2 x float> %277, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %279 = load <2 x float>, ptr %arrayidx2.i.i.i.i1.i52, align 4
  %280 = shufflevector <2 x float> %279, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %281 = insertelement <2 x float> %277, float %edge1.sroa.0.0.copyload, i64 0
  %282 = fmul <2 x float> %281, %280
  %283 = insertelement <2 x float> poison, float %275, i64 0
  %284 = shufflevector <2 x float> %283, <2 x float> poison, <2 x i32> zeroinitializer
  %285 = insertelement <2 x float> %277, float %edge1.sroa.0.0.copyload, i64 1
  %286 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %284, <2 x float> %285, <2 x float> %282)
  %287 = insertelement <2 x float> %279, float %276, i64 0
  %288 = fneg <2 x float> %287
  %289 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %288, <2 x float> %278, <2 x float> %286)
  %290 = extractelement <2 x float> %277, i64 0
  %mul21.i.i181 = fmul float %290, %276
  %291 = extractelement <2 x float> %277, i64 1
  %292 = call float @llvm.fmuladd.f32(float %275, float %291, float %mul21.i.i181)
  %293 = extractelement <2 x float> %279, i64 0
  %neg24.i.i182 = fneg float %293
  %294 = call float @llvm.fmuladd.f32(float %neg24.i.i182, float %edge1.sroa.0.0.copyload, float %292)
  %neg31.i.i183 = fmul float %290, %neg24.i.i182
  %295 = extractelement <2 x float> %288, i64 0
  %296 = call float @llvm.fmuladd.f32(float %295, float %edge1.sroa.0.0.copyload, float %neg31.i.i183)
  %297 = extractelement <2 x float> %288, i64 1
  %298 = call float @llvm.fmuladd.f32(float %297, float %291, float %296)
  %299 = extractelement <2 x float> %289, i64 1
  %mul4.i9.i184 = fmul float %275, %299
  %300 = call float @llvm.fmuladd.f32(float %298, float %295, float %mul4.i9.i184)
  %301 = extractelement <2 x float> %289, i64 0
  %302 = call float @llvm.fmuladd.f32(float %301, float %297, float %300)
  %303 = call float @llvm.fmuladd.f32(float %294, float %293, float %302)
  %304 = shufflevector <2 x float> %289, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %305 = insertelement <2 x float> %304, float %294, i64 0
  %306 = fmul <2 x float> %284, %305
  %307 = insertelement <2 x float> poison, float %298, i64 0
  %308 = shufflevector <2 x float> %307, <2 x float> poison, <2 x i32> zeroinitializer
  %309 = shufflevector <2 x float> %288, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %310 = insertelement <2 x float> %309, float %neg24.i.i182, i64 1
  %311 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %308, <2 x float> %310, <2 x float> %306)
  %312 = shufflevector <2 x float> %289, <2 x float> %305, <2 x i32> <i32 1, i32 2>
  %313 = shufflevector <2 x float> %310, <2 x float> %288, <2 x i32> <i32 1, i32 2>
  %314 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %312, <2 x float> %313, <2 x float> %311)
  %315 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %289, <2 x float> %287, <2 x float> %314)
  %316 = extractelement <2 x float> %315, i64 0
  %neg11.i = fmul float %316, %269
  %317 = call float @llvm.fmuladd.f32(float %267, float %303, float %neg11.i)
  %318 = shufflevector <2 x float> %315, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %319 = insertelement <2 x float> %318, float %303, i64 1
  %320 = fmul <2 x float> %319, %272
  %321 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %262, <2 x float> %315, <2 x float> %320)
  %retval.sroa.0.4.vec.insert.i.i197 = insertelement <2 x float> %321, float %317, i64 1
  %322 = shufflevector <2 x float> <float poison, float 0.000000e+00>, <2 x float> %321, <2 x i32> <i32 3, i32 1>
  store <2 x float> %retval.sroa.0.4.vec.insert.i.i197, ptr %crossje, align 16
  store <2 x float> %322, ptr %127, align 8
  %323 = extractelement <2 x float> %321, i64 0
  %324 = call float @llvm.fabs.f32(float %323)
  %conv.i = fpext float %324 to double
  %cmp.i201 = fcmp ogt double %conv.i, 0x3EB0C6F7A0B5ED8D
  br i1 %cmp.i201, label %invoke.cont96, label %lor.lhs.false.i202

lor.lhs.false.i202:                               ; preds = %invoke.cont87
  %325 = call float @llvm.fabs.f32(float %317)
  %conv1.i = fpext float %325 to double
  %cmp2.i = fcmp ogt double %conv1.i, 0x3EB0C6F7A0B5ED8D
  br i1 %cmp2.i, label %invoke.cont96, label %lor.lhs.false3.i

lor.lhs.false3.i:                                 ; preds = %lor.lhs.false.i202
  %326 = extractelement <2 x float> %321, i64 1
  %327 = call float @llvm.fabs.f32(float %326)
  %conv4.i = fpext float %327 to double
  %cmp5.i = fcmp ogt double %conv4.i, 0x3EB0C6F7A0B5ED8D
  br i1 %cmp5.i, label %invoke.cont96, label %for.inc111

invoke.cont96:                                    ; preds = %lor.lhs.false3.i, %lor.lhs.false.i202, %invoke.cont87
  %mul5.i.i.i.i205 = fmul float %317, %317
  %328 = call float @llvm.fmuladd.f32(float %323, float %323, float %mul5.i.i.i.i205)
  %329 = extractelement <2 x float> %321, i64 1
  %330 = call noundef float @llvm.fmuladd.f32(float %329, float %329, float %328)
  %sqrt.i.i = call noundef float @llvm.sqrt.f32(float %330)
  %div.i.i = fdiv float 1.000000e+00, %sqrt.i.i
  %mul3.i.i.i = fmul float %317, %div.i.i
  store float %mul3.i.i.i, ptr %y.i, align 4
  %331 = insertelement <2 x float> poison, float %div.i.i, i64 0
  %332 = shufflevector <2 x float> %331, <2 x float> poison, <2 x i32> zeroinitializer
  %333 = fmul <2 x float> %321, %332
  %334 = extractelement <2 x float> %333, i64 0
  store float %334, ptr %crossje, align 16
  %335 = extractelement <2 x float> %333, i64 1
  store float %335, ptr %127, align 8
  %mul5.i.i210 = fmul float %sub4.i, %mul3.i.i.i
  %336 = call float @llvm.fmuladd.f32(float %sub.i, float %334, float %mul5.i.i210)
  %337 = call noundef float @llvm.fmuladd.f32(float %sub7.i, float %335, float %336)
  %cmp98 = fcmp olt float %337, 0.000000e+00
  br i1 %cmp98, label %if.then99, label %if.end102

if.then99:                                        ; preds = %invoke.cont96
  %338 = fneg <2 x float> %333
  %339 = extractelement <2 x float> %338, i64 0
  store float %339, ptr %crossje, align 16
  %mul3.i215 = fneg float %mul3.i.i.i
  store float %mul3.i215, ptr %y.i, align 4
  %340 = extractelement <2 x float> %338, i64 1
  store float %340, ptr %127, align 8
  br label %if.end102

if.end102:                                        ; preds = %if.then99, %invoke.cont96
  %341 = phi float [ %mul3.i215, %if.then99 ], [ %mul3.i.i.i, %invoke.cont96 ]
  %342 = phi <2 x float> [ %338, %if.then99 ], [ %333, %invoke.cont96 ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %Min1.i220)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %Max1.i221)
  %343 = load i32, ptr %m_numVertices.i311, align 4
  %344 = load float, ptr %ornA, align 16
  %fneg.i.i312 = fneg float %344
  %345 = load float, ptr %arrayidx2.i.i.i.i1.i, align 4
  %fneg4.i.i314 = fneg float %345
  %346 = load float, ptr %arrayidx5.i.i.i.i.i, align 8
  %fneg7.i.i316 = fneg float %346
  %347 = load float, ptr %arrayidx7.i.i.i.i.i, align 4
  %348 = extractelement <2 x float> %342, i64 1
  %mul4.i.i.i319 = fmul float %348, %fneg4.i.i314
  %349 = extractelement <2 x float> %342, i64 0
  %350 = call float @llvm.fmuladd.f32(float %347, float %349, float %mul4.i.i.i319)
  %351 = call float @llvm.fmuladd.f32(float %346, float %341, float %350)
  %mul12.i.i.i321 = fmul float %349, %fneg7.i.i316
  %352 = call float @llvm.fmuladd.f32(float %347, float %341, float %mul12.i.i.i321)
  %353 = call float @llvm.fmuladd.f32(float %344, float %348, float %352)
  %mul21.i.i.i322 = fmul float %341, %fneg.i.i312
  %354 = call float @llvm.fmuladd.f32(float %347, float %348, float %mul21.i.i.i322)
  %355 = call float @llvm.fmuladd.f32(float %345, float %349, float %354)
  %neg31.i.i.i323 = fmul float %345, %341
  %356 = call float @llvm.fmuladd.f32(float %344, float %349, float %neg31.i.i.i323)
  %357 = call float @llvm.fmuladd.f32(float %346, float %348, float %356)
  %mul4.i9.i.i324 = fmul float %347, %351
  %358 = call float @llvm.fmuladd.f32(float %357, float %344, float %mul4.i9.i.i324)
  %359 = call float @llvm.fmuladd.f32(float %353, float %346, float %358)
  %360 = call float @llvm.fmuladd.f32(float %355, float %fneg4.i.i314, float %359)
  %mul14.i.i.i325 = fmul float %347, %353
  %361 = call float @llvm.fmuladd.f32(float %357, float %345, float %mul14.i.i.i325)
  %362 = call float @llvm.fmuladd.f32(float %355, float %344, float %361)
  %363 = call float @llvm.fmuladd.f32(float %351, float %fneg7.i.i316, float %362)
  %mul25.i.i.i326 = fmul float %347, %355
  %364 = call float @llvm.fmuladd.f32(float %357, float %346, float %mul25.i.i.i326)
  %365 = call float @llvm.fmuladd.f32(float %351, float %345, float %364)
  %366 = call float @llvm.fmuladd.f32(float %353, float %fneg.i.i312, float %365)
  %cmp27.i329 = icmp sgt i32 %343, 0
  br i1 %cmp27.i329, label %for.body.lr.ph.i337, label %.noexc231

for.body.lr.ph.i337:                              ; preds = %if.end102
  %367 = load i32, ptr %m_vertexOffset.i338, align 16
  %368 = load ptr, ptr %m_data.i.i339, align 8
  %369 = sext i32 %367 to i64
  %370 = zext nneg i32 %343 to i64
  %invariant.gep120 = getelementptr %class.b3Vector3, ptr %368, i64 %369
  br label %for.body.i340

for.body.i340:                                    ; preds = %for.body.i340, %for.body.lr.ph.i337
  %indvars.iv107 = phi i64 [ %indvars.iv.next108, %for.body.i340 ], [ 0, %for.body.lr.ph.i337 ]
  %Max0.i219.0 = phi float [ %Max0.i219.1, %for.body.i340 ], [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i337 ]
  %Min0.i218.0 = phi float [ %Min0.i218.1, %for.body.i340 ], [ 0x47EFFFFFE0000000, %for.body.lr.ph.i337 ]
  %371 = phi float [ %378, %for.body.i340 ], [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i337 ]
  %gep121 = getelementptr %class.b3Vector3, ptr %invariant.gep120, i64 %indvars.iv107
  %372 = load float, ptr %gep121, align 16
  %arrayidx3.i.i22.i345 = getelementptr inbounds [4 x float], ptr %gep121, i64 0, i64 1
  %373 = load float, ptr %arrayidx3.i.i22.i345, align 4
  %mul5.i.i24.i346 = fmul float %363, %373
  %374 = call float @llvm.fmuladd.f32(float %372, float %360, float %mul5.i.i24.i346)
  %arrayidx6.i.i25.i347 = getelementptr inbounds [4 x float], ptr %gep121, i64 0, i64 2
  %375 = load float, ptr %arrayidx6.i.i25.i347, align 8
  %376 = call noundef float @llvm.fmuladd.f32(float %375, float %366, float %374)
  %cmp9.i348 = fcmp olt float %376, %Min0.i218.0
  %Min0.i218.1 = select i1 %cmp9.i348, float %376, float %Min0.i218.0
  %377 = select i1 %cmp9.i348, float %Max0.i219.0, float %371
  %cmp10.i350 = fcmp ogt float %376, %377
  %Max0.i219.1 = select i1 %cmp10.i350, float %376, float %Max0.i219.0
  %378 = select i1 %cmp10.i350, float %376, float %377
  %indvars.iv.next108 = add nuw nsw i64 %indvars.iv107, 1
  %exitcond.not.i353 = icmp eq i64 %indvars.iv.next108, %370
  br i1 %exitcond.not.i353, label %for.end.i330, label %for.body.i340, !llvm.loop !28

for.end.i330:                                     ; preds = %for.body.i340
  %cmp13.i331 = fcmp ogt float %Min0.i218.1, %378
  br i1 %cmp13.i331, label %if.then14.i335, label %.noexc231

if.then14.i335:                                   ; preds = %for.end.i330
  br label %.noexc231

.noexc231:                                        ; preds = %if.end102, %if.then14.i335, %for.end.i330
  %Max0.i219.3 = phi float [ %Max0.i219.1, %for.end.i330 ], [ %Min0.i218.1, %if.then14.i335 ], [ 0x47EFFFFFE0000000, %if.end102 ]
  %379 = phi float [ %Min0.i218.1, %for.end.i330 ], [ %378, %if.then14.i335 ], [ 0xC7EFFFFFE0000000, %if.end102 ]
  %mul5.i.i.i332 = fmul float %posA.sroa.5.0.copyload, %341
  %380 = call float @llvm.fmuladd.f32(float %posA.sroa.0.0.copyload, float %349, float %mul5.i.i.i332)
  %381 = call noundef float @llvm.fmuladd.f32(float %posA.sroa.9.0.copyload, float %348, float %380)
  %add16.i333 = fadd float %381, %379
  %add17.i334 = fadd float %381, %Max0.i219.3
  invoke void @_Z7projectRK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionS4_RK20b3AlignedObjectArrayIS2_ERfSC_(ptr noundef nonnull align 16 dereferenceable(96) %hullB, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %crossje, ptr noundef nonnull align 8 dereferenceable(25) %verticesB, ptr noundef nonnull align 4 dereferenceable(4) %Min1.i220, ptr noundef nonnull align 4 dereferenceable(4) %Max1.i221)
          to label %.noexc232 unwind label %lpad.loopexit

.noexc232:                                        ; preds = %.noexc231
  %382 = load float, ptr %Min1.i220, align 4
  %cmp.i222 = fcmp olt float %add17.i334, %382
  br i1 %cmp.i222, label %invoke.cont103.thread, label %lor.lhs.false.i223

lor.lhs.false.i223:                               ; preds = %.noexc232
  %383 = load float, ptr %Max1.i221, align 4
  %cmp1.i224 = fcmp olt float %383, %add16.i333
  br i1 %cmp1.i224, label %invoke.cont103.thread, label %if.end106

invoke.cont103.thread:                            ; preds = %lor.lhs.false.i223, %.noexc232
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %Min1.i220)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %Max1.i221)
  br label %cleanup

if.end106:                                        ; preds = %lor.lhs.false.i223
  %sub.i226 = fsub float %add17.i334, %382
  %sub2.i227 = fsub float %383, %add16.i333
  %cmp3.i228 = fcmp olt float %sub.i226, %sub2.i227
  %cond.i229 = select i1 %cmp3.i228, float %sub.i226, float %sub2.i227
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %Min1.i220)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %Max1.i221)
  %cmp107 = fcmp olt float %cond.i229, %dmin.587
  br i1 %cmp107, label %if.then108, label %for.inc111

if.then108:                                       ; preds = %if.end106
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %sep, ptr noundef nonnull align 16 dereferenceable(16) %crossje, i64 16, i1 false)
  br label %for.inc111

for.inc111:                                       ; preds = %lor.lhs.false3.i, %if.then108, %if.end106
  %dmin.6 = phi float [ %cond.i229, %if.then108 ], [ %dmin.587, %if.end106 ], [ %dmin.587, %lor.lhs.false3.i ]
  %inc112 = add nuw nsw i32 %e1.086, 1
  %384 = load i32, ptr %m_numUniqueEdges76, align 8
  %cmp77 = icmp slt i32 %inc112, %384
  br i1 %cmp77, label %invoke.cont87, label %for.inc114.loopexit, !llvm.loop !51

for.inc114.loopexit:                              ; preds = %for.inc111
  %.pre111 = load i32, ptr %m_numUniqueEdges, align 8
  br label %for.inc114

for.inc114:                                       ; preds = %for.inc114.loopexit, %invoke.cont71
  %385 = phi i32 [ %222, %invoke.cont71 ], [ %.pre111, %for.inc114.loopexit ]
  %386 = phi i32 [ %223, %invoke.cont71 ], [ %384, %for.inc114.loopexit ]
  %dmin.5.lcssa = phi float [ %dmin.495, %invoke.cont71 ], [ %dmin.6, %for.inc114.loopexit ]
  %inc115 = add nuw nsw i32 %e0.094, 1
  %cmp66 = icmp slt i32 %inc115, %385
  br i1 %cmp66, label %invoke.cont71, label %invoke.cont122, !llvm.loop !52

invoke.cont122:                                   ; preds = %for.inc114, %for.cond65.preheader
  %fneg.i = fneg float %sub.i
  %fneg2.i = fneg float %sub4.i
  %fneg4.i = fneg float %sub7.i
  %387 = load <2 x float>, ptr %sep, align 16
  %388 = extractelement <2 x float> %387, i64 1
  %mul5.i.i242 = fmul float %388, %fneg2.i
  %389 = extractelement <2 x float> %387, i64 0
  %390 = call float @llvm.fmuladd.f32(float %fneg.i, float %389, float %mul5.i.i242)
  %arrayidx7.i.i244 = getelementptr inbounds [4 x float], ptr %sep, i64 0, i64 2
  %391 = load float, ptr %arrayidx7.i.i244, align 8
  %392 = call noundef float @llvm.fmuladd.f32(float %fneg4.i, float %391, float %390)
  %cmp124 = fcmp ogt float %392, 0.000000e+00
  br i1 %cmp124, label %invoke.cont127, label %cleanup

invoke.cont127:                                   ; preds = %invoke.cont122
  %393 = fneg <2 x float> %387
  %fneg4.i249 = fneg float %391
  %retval.sroa.3.12.vec.insert.i.i252 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %fneg4.i249, i64 0
  store <2 x float> %393, ptr %sep, align 16
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i252, ptr %arrayidx7.i.i244, align 8
  br label %cleanup

cleanup:                                          ; preds = %invoke.cont103.thread, %invoke.cont55.thread, %invoke.cont23.thread, %invoke.cont122, %invoke.cont127
  %retval.0 = phi i1 [ true, %invoke.cont127 ], [ true, %invoke.cont122 ], [ false, %invoke.cont23.thread ], [ false, %invoke.cont55.thread ], [ false, %invoke.cont103.thread ]
  invoke void @b3LeaveProfileZone()
          to label %_ZN13b3ProfileZoneD2Ev.exit256 unwind label %terminate.lpad.i255

terminate.lpad.i255:                              ; preds = %cleanup
  %394 = landingpad { ptr, i32 }
          catch ptr null
  %395 = extractvalue { ptr, i32 } %394, 0
  call void @__clang_call_terminate(ptr %395) #27
  unreachable

_ZN13b3ProfileZoneD2Ev.exit256:                   ; preds = %cleanup
  ret i1 %retval.0
}

; Function Attrs: mustprogress uwtable
define dso_local void @_Z27clipCompoundsHullHullKernelPK6b3Int4PK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataRK20b3AlignedObjectArrayI9b3Vector3ESF_RKSB_I9b3GpuFaceERKSB_IiEPK15b3GpuChildShapeSF_SM_P14b3Contact4DataPiiii(ptr nocapture noundef readonly %gpuCompoundPairs, ptr nocapture noundef readonly %rigidBodies, ptr nocapture noundef readonly %collidables, ptr nocapture noundef readonly %convexShapes, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %vertices, ptr nocapture nonnull readnone align 8 %uniqueEdges, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %faces, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %indices, ptr nocapture noundef readonly %gpuChildShapes, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %gpuCompoundSepNormalsOut, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %gpuHasCompoundSepNormalsOut, ptr nocapture noundef writeonly %globalContactsOut, ptr nocapture noundef %nGlobalContactsOut, i32 noundef %numCompoundPairs, i32 noundef %maxContactCapacity, i32 noundef %i) local_unnamed_addr #5 {
entry:
  %worldVertsB1 = alloca [64 x %class.b3Vector3], align 16
  %worldVertsB2 = alloca [64 x %class.b3Vector3], align 16
  %localContactsOut = alloca [64 x %class.b3Vector3], align 16
  %ornA = alloca %class.b3Quaternion, align 16
  %posA = alloca %class.b3Vector3, align 16
  %ornB = alloca %class.b3Quaternion, align 16
  %posB = alloca %class.b3Vector3, align 16
  %normal = alloca %class.b3Vector3, align 16
  %contactIdx = alloca %struct.b3Int4, align 16
  %cmp = icmp slt i32 %i, %numCompoundPairs
  br i1 %cmp, label %if.then, label %if.end127

if.then:                                          ; preds = %entry
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %gpuHasCompoundSepNormalsOut, i64 0, i32 5
  %0 = load ptr, ptr %m_data.i, align 8
  %idxprom.i = sext i32 %i to i64
  %arrayidx.i = getelementptr inbounds i32, ptr %0, i64 %idxprom.i
  %1 = load i32, ptr %arrayidx.i, align 4
  %tobool.not = icmp eq i32 %1, 0
  br i1 %tobool.not, label %if.end127, label %if.then1

if.then1:                                         ; preds = %if.then
  %arrayidx = getelementptr inbounds %struct.b3Int4, ptr %gpuCompoundPairs, i64 %idxprom.i
  %2 = load i32, ptr %arrayidx, align 16
  %y = getelementptr inbounds %struct.anon, ptr %arrayidx, i64 0, i32 1
  %3 = load i32, ptr %y, align 4
  %z = getelementptr inbounds %struct.anon, ptr %arrayidx, i64 0, i32 2
  %4 = load i32, ptr %z, align 8
  %w = getelementptr inbounds %struct.anon, ptr %arrayidx, i64 0, i32 3
  %5 = load i32, ptr %w, align 4
  %idxprom8 = sext i32 %2 to i64
  %arrayidx9 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom8
  %m_quat = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom8, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %m_quat, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx9, i64 16, i1 false)
  %idxprom12 = sext i32 %3 to i64
  %arrayidx13 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom12
  %m_quat14 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom12, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %m_quat14, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx13, i64 16, i1 false)
  %cmp18 = icmp sgt i32 %4, -1
  br i1 %cmp18, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.then1
  %idxprom20 = zext nneg i32 %4 to i64
  %arrayidx21 = getelementptr inbounds %struct.b3GpuChildShape, ptr %gpuChildShapes, i64 %idxprom20
  %6 = getelementptr inbounds %struct.b3GpuChildShape, ptr %gpuChildShapes, i64 %idxprom20, i32 2
  %7 = load i32, ptr %6, align 16
  %childPosA.sroa.3.0.arrayidx21.sroa_idx = getelementptr inbounds i8, ptr %arrayidx21, i64 8
  %childPosA.sroa.3.0.copyload = load float, ptr %childPosA.sroa.3.0.arrayidx21.sroa_idx, align 8
  %m_childOrientation = getelementptr inbounds %struct.b3GpuChildShape, ptr %gpuChildShapes, i64 %idxprom20, i32 1
  %childOrnA.sroa.3.0.m_childOrientation.sroa_idx = getelementptr inbounds i8, ptr %m_childOrientation, i64 8
  %arrayidx.i.i.i = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 3
  %8 = load float, ptr %arrayidx.i.i.i, align 4
  %arrayidx.i23.i.i = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 1
  %arrayidx.i25.i.i = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 2
  %9 = load float, ptr %ornA, align 16
  %neg15.i.i = fneg float %9
  %arrayidx6.i = getelementptr inbounds [4 x float], ptr %posA, i64 0, i64 2
  %10 = load float, ptr %arrayidx6.i, align 8
  %11 = load <2 x float>, ptr %childOrnA.sroa.3.0.m_childOrientation.sroa_idx, align 8
  %12 = load <2 x float>, ptr %arrayidx.i23.i.i, align 4
  %13 = fneg <2 x float> %12
  %14 = load <2 x float>, ptr %arrayidx21, align 16
  %15 = load <2 x float>, ptr %posA, align 16
  %16 = insertelement <2 x float> %14, float %childPosA.sroa.3.0.copyload, i64 0
  %17 = insertelement <2 x float> %12, float %9, i64 1
  %18 = fmul <2 x float> %16, %17
  %19 = insertelement <2 x float> poison, float %8, i64 0
  %20 = shufflevector <2 x float> %19, <2 x float> poison, <2 x i32> zeroinitializer
  %21 = insertelement <2 x float> %14, float %childPosA.sroa.3.0.copyload, i64 1
  %22 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %20, <2 x float> %21, <2 x float> %18)
  %23 = shufflevector <2 x float> %22, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %24 = extractelement <2 x float> %14, i64 0
  %shift = shufflevector <2 x float> %12, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %25 = fmul <2 x float> %14, %shift
  %mul12.i.i = extractelement <2 x float> %25, i64 0
  %26 = extractelement <2 x float> %14, i64 1
  %27 = tail call float @llvm.fmuladd.f32(float %8, float %26, float %mul12.i.i)
  %28 = tail call float @llvm.fmuladd.f32(float %neg15.i.i, float %childPosA.sroa.3.0.copyload, float %27)
  %29 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %13, <2 x float> %14, <2 x float> %23)
  %30 = extractelement <2 x float> %13, i64 0
  %neg31.i.i = fmul float %26, %30
  %31 = tail call float @llvm.fmuladd.f32(float %neg15.i.i, float %24, float %neg31.i.i)
  %32 = extractelement <2 x float> %13, i64 1
  %33 = tail call float @llvm.fmuladd.f32(float %32, float %childPosA.sroa.3.0.copyload, float %31)
  %34 = shufflevector <2 x float> %29, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %35 = insertelement <2 x float> %34, float %28, i64 1
  %36 = fmul <2 x float> %20, %35
  %37 = insertelement <2 x float> poison, float %33, i64 0
  %38 = shufflevector <2 x float> %37, <2 x float> poison, <2 x i32> zeroinitializer
  %39 = shufflevector <2 x float> %13, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %40 = insertelement <2 x float> %39, float %neg15.i.i, i64 0
  %41 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %38, <2 x float> %40, <2 x float> %36)
  %42 = shufflevector <2 x float> %35, <2 x float> %29, <2 x i32> <i32 1, i32 2>
  %43 = insertelement <2 x float> %39, float %neg15.i.i, i64 1
  %44 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %42, <2 x float> %43, <2 x float> %41)
  %45 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %29, <2 x float> %12, <2 x float> %44)
  %46 = extractelement <2 x float> %29, i64 0
  %mul25.i.i = fmul float %8, %46
  %47 = tail call float @llvm.fmuladd.f32(float %33, float %32, float %mul25.i.i)
  %48 = extractelement <2 x float> %29, i64 1
  %49 = tail call float @llvm.fmuladd.f32(float %48, float %30, float %47)
  %50 = tail call float @llvm.fmuladd.f32(float %28, float %9, float %49)
  %51 = fadd <2 x float> %15, %45
  %add7.i = fadd float %10, %50
  %retval.sroa.3.12.vec.insert.i.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %add7.i, i64 0
  %52 = load <2 x float>, ptr %m_childOrientation, align 16
  %53 = shufflevector <2 x float> %11, <2 x float> poison, <2 x i32> <i32 1, i32 1>
  %54 = fmul <2 x float> %53, %17
  %55 = shufflevector <2 x float> %54, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %56 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %20, <2 x float> %52, <2 x float> %55)
  %57 = shufflevector <2 x float> %11, <2 x float> %52, <2 x i32> <i32 0, i32 2>
  %58 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %12, <2 x float> %57, <2 x float> %56)
  %59 = shufflevector <2 x float> %11, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %60 = shufflevector <2 x float> %59, <2 x float> %52, <2 x i32> <i32 3, i32 1>
  %61 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %43, <2 x float> %60, <2 x float> %58)
  %62 = shufflevector <2 x float> %52, <2 x float> %11, <2 x i32> <i32 0, i32 3>
  %63 = insertelement <2 x float> %12, float %neg15.i.i, i64 0
  %64 = fmul <2 x float> %62, %63
  %65 = shufflevector <2 x float> %64, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %66 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %20, <2 x float> %11, <2 x float> %65)
  %67 = insertelement <2 x float> %39, float %9, i64 0
  %68 = shufflevector <2 x float> %52, <2 x float> poison, <2 x i32> <i32 1, i32 1>
  %69 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %67, <2 x float> %68, <2 x float> %66)
  %70 = shufflevector <2 x float> %52, <2 x float> %11, <2 x i32> <i32 0, i32 2>
  %71 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %13, <2 x float> %70, <2 x float> %69)
  store <2 x float> %51, ptr %posA, align 16
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i, ptr %arrayidx6.i, align 8
  store <2 x float> %61, ptr %ornA, align 16
  store <2 x float> %71, ptr %arrayidx.i25.i.i, align 8
  br label %if.end

if.else:                                          ; preds = %if.then1
  %m_collidableIdx = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom8, i32 4
  %72 = load i32, ptr %m_collidableIdx, align 16
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then19
  %collidableIndexA.0 = phi i32 [ %7, %if.then19 ], [ %72, %if.else ]
  %cmp37 = icmp sgt i32 %5, -1
  br i1 %cmp37, label %if.then38, label %if.else58

if.then38:                                        ; preds = %if.end
  %idxprom39 = zext nneg i32 %5 to i64
  %arrayidx40 = getelementptr inbounds %struct.b3GpuChildShape, ptr %gpuChildShapes, i64 %idxprom39
  %73 = getelementptr inbounds %struct.b3GpuChildShape, ptr %gpuChildShapes, i64 %idxprom39, i32 2
  %74 = load i32, ptr %73, align 16
  %childPosB.sroa.3.0.arrayidx40.sroa_idx = getelementptr inbounds i8, ptr %arrayidx40, i64 8
  %childPosB.sroa.3.0.copyload = load float, ptr %childPosB.sroa.3.0.arrayidx40.sroa_idx, align 8
  %m_childOrientation46 = getelementptr inbounds %struct.b3GpuChildShape, ptr %gpuChildShapes, i64 %idxprom39, i32 1
  %childOrnB.sroa.3.0.m_childOrientation46.sroa_idx = getelementptr inbounds i8, ptr %m_childOrientation46, i64 8
  %arrayidx.i.i.i78 = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 3
  %75 = load float, ptr %arrayidx.i.i.i78, align 4
  %arrayidx.i23.i.i79 = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 1
  %arrayidx.i25.i.i82 = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 2
  %76 = load float, ptr %ornB, align 16
  %neg15.i.i86 = fneg float %76
  %arrayidx6.i103 = getelementptr inbounds [4 x float], ptr %posB, i64 0, i64 2
  %77 = load float, ptr %arrayidx6.i103, align 8
  %78 = load <2 x float>, ptr %childOrnB.sroa.3.0.m_childOrientation46.sroa_idx, align 8
  %79 = load <2 x float>, ptr %arrayidx.i23.i.i79, align 4
  %80 = fneg <2 x float> %79
  %81 = load <2 x float>, ptr %arrayidx40, align 16
  %82 = load <2 x float>, ptr %posB, align 16
  %83 = insertelement <2 x float> %81, float %childPosB.sroa.3.0.copyload, i64 0
  %84 = insertelement <2 x float> %79, float %76, i64 1
  %85 = fmul <2 x float> %83, %84
  %86 = insertelement <2 x float> poison, float %75, i64 0
  %87 = shufflevector <2 x float> %86, <2 x float> poison, <2 x i32> zeroinitializer
  %88 = insertelement <2 x float> %81, float %childPosB.sroa.3.0.copyload, i64 1
  %89 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %87, <2 x float> %88, <2 x float> %85)
  %90 = shufflevector <2 x float> %89, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %91 = extractelement <2 x float> %81, i64 0
  %shift155 = shufflevector <2 x float> %79, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %92 = fmul <2 x float> %81, %shift155
  %mul12.i.i85 = extractelement <2 x float> %92, i64 0
  %93 = extractelement <2 x float> %81, i64 1
  %94 = tail call float @llvm.fmuladd.f32(float %75, float %93, float %mul12.i.i85)
  %95 = tail call float @llvm.fmuladd.f32(float %neg15.i.i86, float %childPosB.sroa.3.0.copyload, float %94)
  %96 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %80, <2 x float> %81, <2 x float> %90)
  %97 = extractelement <2 x float> %80, i64 0
  %neg31.i.i89 = fmul float %93, %97
  %98 = tail call float @llvm.fmuladd.f32(float %neg15.i.i86, float %91, float %neg31.i.i89)
  %99 = extractelement <2 x float> %80, i64 1
  %100 = tail call float @llvm.fmuladd.f32(float %99, float %childPosB.sroa.3.0.copyload, float %98)
  %101 = shufflevector <2 x float> %96, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %102 = insertelement <2 x float> %101, float %95, i64 1
  %103 = fmul <2 x float> %87, %102
  %104 = insertelement <2 x float> poison, float %100, i64 0
  %105 = shufflevector <2 x float> %104, <2 x float> poison, <2 x i32> zeroinitializer
  %106 = shufflevector <2 x float> %80, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %107 = insertelement <2 x float> %106, float %neg15.i.i86, i64 0
  %108 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %105, <2 x float> %107, <2 x float> %103)
  %109 = shufflevector <2 x float> %102, <2 x float> %96, <2 x i32> <i32 1, i32 2>
  %110 = insertelement <2 x float> %106, float %neg15.i.i86, i64 1
  %111 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %109, <2 x float> %110, <2 x float> %108)
  %112 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %96, <2 x float> %79, <2 x float> %111)
  %113 = extractelement <2 x float> %96, i64 0
  %mul25.i.i92 = fmul float %75, %113
  %114 = tail call float @llvm.fmuladd.f32(float %100, float %99, float %mul25.i.i92)
  %115 = extractelement <2 x float> %96, i64 1
  %116 = tail call float @llvm.fmuladd.f32(float %115, float %97, float %114)
  %117 = tail call float @llvm.fmuladd.f32(float %95, float %76, float %116)
  %118 = fadd <2 x float> %82, %112
  %add7.i104 = fadd float %77, %117
  %retval.sroa.3.12.vec.insert.i.i107 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %add7.i104, i64 0
  %119 = load <2 x float>, ptr %m_childOrientation46, align 16
  %120 = shufflevector <2 x float> %78, <2 x float> poison, <2 x i32> <i32 1, i32 1>
  %121 = fmul <2 x float> %120, %84
  %122 = shufflevector <2 x float> %121, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %123 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %87, <2 x float> %119, <2 x float> %122)
  %124 = shufflevector <2 x float> %78, <2 x float> %119, <2 x i32> <i32 0, i32 2>
  %125 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %79, <2 x float> %124, <2 x float> %123)
  %126 = shufflevector <2 x float> %78, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %127 = shufflevector <2 x float> %126, <2 x float> %119, <2 x i32> <i32 3, i32 1>
  %128 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %110, <2 x float> %127, <2 x float> %125)
  %129 = shufflevector <2 x float> %119, <2 x float> %78, <2 x i32> <i32 0, i32 3>
  %130 = insertelement <2 x float> %79, float %neg15.i.i86, i64 0
  %131 = fmul <2 x float> %129, %130
  %132 = shufflevector <2 x float> %131, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %133 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %87, <2 x float> %78, <2 x float> %132)
  %134 = insertelement <2 x float> %106, float %76, i64 0
  %135 = shufflevector <2 x float> %119, <2 x float> poison, <2 x i32> <i32 1, i32 1>
  %136 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %134, <2 x float> %135, <2 x float> %133)
  %137 = shufflevector <2 x float> %119, <2 x float> %78, <2 x i32> <i32 0, i32 2>
  %138 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %80, <2 x float> %137, <2 x float> %136)
  store <2 x float> %118, ptr %posB, align 16
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i107, ptr %arrayidx6.i103, align 8
  store <2 x float> %128, ptr %ornB, align 16
  store <2 x float> %138, ptr %arrayidx.i25.i.i82, align 8
  br label %if.end62

if.else58:                                        ; preds = %if.end
  %m_collidableIdx61 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom12, i32 4
  %139 = load i32, ptr %m_collidableIdx61, align 16
  br label %if.end62

if.end62:                                         ; preds = %if.else58, %if.then38
  %collidableIndexB.0 = phi i32 [ %74, %if.then38 ], [ %139, %if.else58 ]
  %idxprom63 = sext i32 %collidableIndexA.0 to i64
  %140 = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom63, i32 3
  %141 = load i32, ptr %140, align 4
  %idxprom65 = sext i32 %collidableIndexB.0 to i64
  %142 = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom65, i32 3
  %143 = load i32, ptr %142, align 4
  %m_data.i129 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %gpuCompoundSepNormalsOut, i64 0, i32 5
  %144 = load ptr, ptr %m_data.i129, align 8
  %arrayidx.i131 = getelementptr inbounds %class.b3Vector3, ptr %144, i64 %idxprom.i
  %idxprom68 = sext i32 %141 to i64
  %arrayidx69 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexShapes, i64 %idxprom68
  %idxprom70 = sext i32 %143 to i64
  %arrayidx71 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexShapes, i64 %idxprom70
  %call74 = call fastcc noundef i32 @_ZL19clipHullAgainstHullRK9b3Vector3RK22b3ConvexPolyhedronDataS4_S1_RK12b3QuaternionS1_S7_PS_S8_iffRK20b3AlignedObjectArrayIS_ERKS9_I9b3GpuFaceERKS9_IiESC_SG_SJ_S8_i(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx.i131, ptr noundef nonnull align 16 dereferenceable(96) %arrayidx69, ptr noundef nonnull align 16 dereferenceable(96) %arrayidx71, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull %worldVertsB1, ptr noundef nonnull %worldVertsB2, i32 noundef 64, float noundef 0xC6293E5940000000, ptr noundef nonnull align 8 dereferenceable(25) %vertices, ptr noundef nonnull align 8 dereferenceable(25) %faces, ptr noundef nonnull align 8 dereferenceable(25) %indices, ptr noundef nonnull align 8 dereferenceable(25) %vertices, ptr noundef nonnull align 8 dereferenceable(25) %faces, ptr noundef nonnull align 8 dereferenceable(25) %indices, ptr noundef nonnull %localContactsOut, i32 noundef 64)
  %cmp75 = icmp sgt i32 %call74, 0
  br i1 %cmp75, label %if.then76, label %if.end127

if.then76:                                        ; preds = %if.end62
  %145 = load ptr, ptr %m_data.i129, align 8
  %arrayidx.i134 = getelementptr inbounds %class.b3Vector3, ptr %145, i64 %idxprom.i
  %146 = load <2 x float>, ptr %arrayidx.i134, align 16
  %147 = fneg <2 x float> %146
  %arrayidx3.i135 = getelementptr inbounds [4 x float], ptr %arrayidx.i134, i64 0, i64 2
  %148 = load float, ptr %arrayidx3.i135, align 8
  %fneg4.i = fneg float %148
  %retval.sroa.3.12.vec.insert.i.i138 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %fneg4.i, i64 0
  store <2 x float> %147, ptr %normal, align 16
  %149 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %normal, i64 0, i32 1
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i138, ptr %149, align 8
  store <4 x i32> <i32 0, i32 1, i32 2, i32 3>, ptr %contactIdx, align 16
  %call89 = call noundef i32 @_Z31extractManifoldSequentialGlobalPK9b3Vector3iRS0_P6b3Int4(ptr noundef nonnull %localContactsOut, i32 noundef %call74, ptr noundef nonnull align 16 dereferenceable(16) %normal, ptr noundef nonnull %contactIdx)
  %150 = load i32, ptr %nGlobalContactsOut, align 4
  %inc = add nsw i32 %150, 1
  store i32 %inc, ptr %nGlobalContactsOut, align 4
  %add = add nsw i32 %150, %call89
  %cmp90 = icmp slt i32 %add, %maxContactCapacity
  br i1 %cmp90, label %if.then91, label %if.end127

if.then91:                                        ; preds = %if.then76
  %idx.ext = sext i32 %150 to i64
  %add.ptr = getelementptr inbounds %struct.b3Contact4Data, ptr %globalContactsOut, i64 %idx.ext
  %retval.sroa.3.12.vec.insert.i.i148 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %148, i64 0
  %m_worldNormalOnB = getelementptr inbounds %struct.b3Contact4Data, ptr %globalContactsOut, i64 %idx.ext, i32 1
  store <2 x float> %146, ptr %m_worldNormalOnB, align 16
  %ref.tmp92.sroa.2.0.m_worldNormalOnB.sroa_idx = getelementptr inbounds i8, ptr %m_worldNormalOnB, i64 8
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i148, ptr %ref.tmp92.sroa.2.0.m_worldNormalOnB.sroa_idx, align 8
  %m_restituitionCoeffCmp = getelementptr inbounds %struct.b3Contact4Data, ptr %globalContactsOut, i64 %idx.ext, i32 2
  store i16 0, ptr %m_restituitionCoeffCmp, align 16
  %m_frictionCoeffCmp = getelementptr inbounds %struct.b3Contact4Data, ptr %globalContactsOut, i64 %idx.ext, i32 3
  store i16 -19662, ptr %m_frictionCoeffCmp, align 2
  %m_batchIdx = getelementptr inbounds %struct.b3Contact4Data, ptr %globalContactsOut, i64 %idx.ext, i32 4
  store i32 %i, ptr %m_batchIdx, align 4
  %151 = load i32, ptr %arrayidx, align 16
  %152 = load i32, ptr %y, align 4
  %idxprom102 = sext i32 %151 to i64
  %m_invMass = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom102, i32 5
  %153 = load float, ptr %m_invMass, align 4
  %cmp104 = fcmp oeq float %153, 0.000000e+00
  %sub = sub nsw i32 0, %151
  %cond = select i1 %cmp104, i32 %sub, i32 %151
  %m_bodyAPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %globalContactsOut, i64 %idx.ext, i32 5
  store i32 %cond, ptr %m_bodyAPtrAndSignBit, align 8
  %idxprom105 = sext i32 %152 to i64
  %m_invMass107 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom105, i32 5
  %154 = load float, ptr %m_invMass107, align 4
  %cmp108 = fcmp oeq float %154, 0.000000e+00
  %sub110 = sub nsw i32 0, %152
  %cond113 = select i1 %cmp108, i32 %sub110, i32 %152
  %m_bodyBPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %globalContactsOut, i64 %idx.ext, i32 6
  store i32 %cond113, ptr %m_bodyBPtrAndSignBit, align 4
  %m_childIndexA = getelementptr inbounds %struct.b3Contact4Data, ptr %globalContactsOut, i64 %idx.ext, i32 7
  store i32 %4, ptr %m_childIndexA, align 16
  %m_childIndexB = getelementptr inbounds %struct.b3Contact4Data, ptr %globalContactsOut, i64 %idx.ext, i32 8
  store i32 %5, ptr %m_childIndexB, align 4
  %cmp115151 = icmp sgt i32 %call89, 0
  br i1 %cmp115151, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %if.then91
  %wide.trip.count = zext nneg i32 %call89 to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %arrayidx118 = getelementptr inbounds [4 x i32], ptr %contactIdx, i64 0, i64 %indvars.iv
  %155 = load i32, ptr %arrayidx118, align 4
  %idxprom119 = sext i32 %155 to i64
  %arrayidx120 = getelementptr inbounds %class.b3Vector3, ptr %localContactsOut, i64 %idxprom119
  %arrayidx122 = getelementptr inbounds [4 x %class.b3Vector3], ptr %add.ptr, i64 0, i64 %indvars.iv
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx122, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx120, i64 16, i1 false)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !53

for.end:                                          ; preds = %for.body, %if.then91
  %conv.i = sitofp i32 %call89 to float
  %w.i = getelementptr inbounds %struct.b3Contact4Data, ptr %globalContactsOut, i64 %idx.ext, i32 1, i32 0, i32 0, i64 3
  store float %conv.i, ptr %w.i, align 4
  br label %if.end127

if.end127:                                        ; preds = %if.then, %if.then76, %for.end, %if.end62, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local void @_Z30computeContactCompoundCompoundiiiiiPK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataPK15b3GpuChildShapeRK20b3AlignedObjectArrayI6b3AabbESF_RKSB_I9b3Vector3ESJ_RKSB_IiERKSB_I9b3GpuFaceEP10b3Contact4RiiRSB_I18b3QuantizedBvhNodeERSB_I16b3BvhSubtreeInfoERSB_I9b3BvhInfoE(i32 noundef %pairIndex, i32 noundef %bodyIndexA, i32 noundef %bodyIndexB, i32 noundef %collidableIndexA, i32 noundef %collidableIndexB, ptr nocapture noundef readonly %rigidBodies, ptr nocapture noundef readonly %collidables, ptr noundef %convexShapes, ptr nocapture noundef readonly %cpuChildShapes, ptr nocapture noundef nonnull readnone align 8 dereferenceable(25) %hostAabbsWorldSpace, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %hostAabbsLocalSpace, ptr noundef nonnull align 8 dereferenceable(25) %convexVertices, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %hostUniqueEdges, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %convexIndices, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %faces, ptr nocapture noundef writeonly %globalContactsOut, ptr nocapture noundef nonnull align 4 dereferenceable(4) %nGlobalContactsOut, i32 noundef %maxContactCapacity, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %treeNodesCPU, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %subTreesCPU, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %bvhInfoCPU) local_unnamed_addr #8 personality ptr @__gxx_personality_v0 {
if.then.i:
  %cpuCompoundPairsOut = alloca %class.b3AlignedObjectArray.66, align 8
  %numCompoundPairsOut = alloca i32, align 4
  %cpuCompoundSepNormalsOut = alloca %class.b3AlignedObjectArray, align 8
  %cpuHasCompoundSepNormalsOut = alloca %class.b3AlignedObjectArray.23, align 8
  %m_ownsMemory.i.i = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %cpuCompoundPairsOut, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i, align 8
  %m_data.i.i = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %cpuCompoundPairsOut, i64 0, i32 5
  store ptr null, ptr %m_data.i.i, align 8
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %cpuCompoundPairsOut, i64 0, i32 2
  store i32 0, ptr %m_size.i.i, align 4
  %m_capacity.i.i = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %cpuCompoundPairsOut, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i, align 8
  store i32 0, ptr %numCompoundPairsOut, align 4
  %call.i.i.i82 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef 131072, i32 noundef 16)
          to label %call.i.i.i.noexc unwind label %lpad

call.i.i.i.noexc:                                 ; preds = %if.then.i
  %cmp3.i = icmp eq ptr %call.i.i.i82, null
  br i1 %cmp3.i, label %_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_.exit18.i, label %.noexc

_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_.exit18.i: ; preds = %call.i.i.i.noexc
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc83 unwind label %lpad

.noexc83:                                         ; preds = %_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_.exit18.i
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc unwind label %lpad

.noexc:                                           ; preds = %.noexc83, %call.i.i.i.noexc
  %_Count.addr.0.i = phi i32 [ 8192, %call.i.i.i.noexc ], [ 0, %.noexc83 ]
  store i8 1, ptr %m_ownsMemory.i.i, align 8
  store ptr %call.i.i.i82, ptr %m_data.i.i, align 8
  store i32 %_Count.addr.0.i, ptr %m_capacity.i.i, align 8
  br label %for.body9.i

for.body9.i:                                      ; preds = %for.body9.i, %.noexc
  %indvars.iv.i = phi i64 [ 0, %.noexc ], [ %indvars.iv.next.i, %for.body9.i ]
  %arrayidx12.i = getelementptr inbounds %struct.b3Int4, ptr %call.i.i.i82, i64 %indvars.iv.i
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx12.i, i8 0, i64 16, i1 false)
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, 8192
  br i1 %exitcond.not.i, label %invoke.cont, label %for.body9.i, !llvm.loop !54

invoke.cont:                                      ; preds = %for.body9.i
  store i32 8192, ptr %m_size.i.i, align 4
  invoke void @_Z23findCompoundPairsKerneliiiiiPK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataRK20b3AlignedObjectArrayI9b3Vector3ERKS8_I6b3AabbESG_PK15b3GpuChildShapeP6b3Int4PiiRS8_I18b3QuantizedBvhNodeERS8_I16b3BvhSubtreeInfoERS8_I9b3BvhInfoE(i32 poison, i32 noundef %bodyIndexA, i32 noundef %bodyIndexB, i32 noundef %collidableIndexA, i32 noundef %collidableIndexB, ptr noundef %rigidBodies, ptr noundef %collidables, ptr poison, ptr nonnull align 8 poison, ptr nonnull align 8 poison, ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsLocalSpace, ptr noundef %cpuChildShapes, ptr noundef nonnull %call.i.i.i82, ptr noundef nonnull %numCompoundPairsOut, i32 noundef 8192, ptr noundef nonnull align 8 dereferenceable(25) %treeNodesCPU, ptr noundef nonnull align 8 dereferenceable(25) %subTreesCPU, ptr noundef nonnull align 8 dereferenceable(25) %bvhInfoCPU)
          to label %invoke.cont2 unwind label %lpad

invoke.cont2:                                     ; preds = %invoke.cont
  %0 = load i32, ptr @maxNumAabbChecks, align 4
  %call4 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.37, i32 noundef %0)
  %1 = load i32, ptr %numCompoundPairsOut, align 4
  %cmp = icmp sgt i32 %1, 8192
  br i1 %cmp, label %do.body, label %invoke.cont9

do.body:                                          ; preds = %invoke.cont2
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.31, i32 noundef 2077)
          to label %invoke.cont5 unwind label %lpad

invoke.cont5:                                     ; preds = %do.body
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.38, i32 noundef 8192)
          to label %invoke.cont9 unwind label %lpad

lpad:                                             ; preds = %.noexc83, %_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_.exit18.i, %if.then.i, %invoke.cont5, %do.body, %invoke.cont
  %2 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup29

invoke.cont9:                                     ; preds = %invoke.cont5, %invoke.cont2
  %3 = phi i32 [ %1, %invoke.cont2 ], [ 8192, %invoke.cont5 ]
  %m_ownsMemory.i.i27 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %cpuCompoundSepNormalsOut, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i27, align 8
  %m_data.i.i28 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %cpuCompoundSepNormalsOut, i64 0, i32 5
  store ptr null, ptr %m_data.i.i28, align 8
  %m_size.i.i29 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %cpuCompoundSepNormalsOut, i64 0, i32 2
  store i32 0, ptr %m_size.i.i29, align 4
  %m_capacity.i.i30 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %cpuCompoundSepNormalsOut, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i30, align 8
  %m_ownsMemory.i.i31 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %cpuHasCompoundSepNormalsOut, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i31, align 8
  %m_data.i.i32 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %cpuHasCompoundSepNormalsOut, i64 0, i32 5
  store ptr null, ptr %m_data.i.i32, align 8
  %m_size.i.i33 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %cpuHasCompoundSepNormalsOut, i64 0, i32 2
  store i32 0, ptr %m_size.i.i33, align 4
  %m_capacity.i.i34 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %cpuHasCompoundSepNormalsOut, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i34, align 8
  %cmp4.i36 = icmp sgt i32 %3, 0
  br i1 %cmp4.i36, label %_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit.i, label %_ZN20b3AlignedObjectArrayIiED2Ev.exit

_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit.i: ; preds = %invoke.cont9
  %conv.i.i.i = zext nneg i32 %3 to i64
  %mul.i.i.i = shl nuw nsw i64 %conv.i.i.i, 4
  %call.i.i.i114 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i, i32 noundef 16)
          to label %call.i.i.i.noexc113 unwind label %lpad11.loopexit.split-lp.loopexit.split-lp

call.i.i.i.noexc113:                              ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit.i
  %cmp3.i89 = icmp eq ptr %call.i.i.i114, null
  br i1 %cmp3.i89, label %_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i, label %.noexc44

_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i: ; preds = %call.i.i.i.noexc113
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc115 unwind label %lpad11.loopexit.split-lp.loopexit.split-lp

.noexc115:                                        ; preds = %_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc44 unwind label %lpad11.loopexit.split-lp.loopexit.split-lp

.noexc44:                                         ; preds = %.noexc115, %call.i.i.i.noexc113
  %_Count.addr.0.i95 = phi i32 [ %3, %call.i.i.i.noexc113 ], [ 0, %.noexc115 ]
  store i8 1, ptr %m_ownsMemory.i.i27, align 8
  store ptr %call.i.i.i114, ptr %m_data.i.i28, align 8
  store i32 %_Count.addr.0.i95, ptr %m_capacity.i.i30, align 8
  br label %for.body9.i39

for.body9.i39:                                    ; preds = %for.body9.i39, %.noexc44
  %indvars.iv.i40 = phi i64 [ 0, %.noexc44 ], [ %indvars.iv.next.i42, %for.body9.i39 ]
  %arrayidx12.i41 = getelementptr inbounds %class.b3Vector3, ptr %call.i.i.i114, i64 %indvars.iv.i40
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx12.i41, i8 0, i64 16, i1 false)
  %indvars.iv.next.i42 = add nuw nsw i64 %indvars.iv.i40, 1
  %exitcond.not.i43 = icmp eq i64 %indvars.iv.next.i42, %conv.i.i.i
  br i1 %exitcond.not.i43, label %invoke.cont12, label %for.body9.i39, !llvm.loop !55

invoke.cont12:                                    ; preds = %for.body9.i39
  store i32 %3, ptr %m_size.i.i29, align 4
  br i1 %cmp4.i36, label %_ZN20b3AlignedObjectArrayIiE8allocateEi.exit.i, label %_ZN20b3AlignedObjectArrayIiED2Ev.exit

_ZN20b3AlignedObjectArrayIiE8allocateEi.exit.i:   ; preds = %invoke.cont12
  %conv.i.i.i122 = zext nneg i32 %3 to i64
  %mul.i.i.i123 = shl nuw nsw i64 %conv.i.i.i122, 2
  %call.i.i.i149 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i123, i32 noundef 16)
          to label %call.i.i.i.noexc148 unwind label %lpad11.loopexit.split-lp.loopexit.split-lp

call.i.i.i.noexc148:                              ; preds = %_ZN20b3AlignedObjectArrayIiE8allocateEi.exit.i
  %cmp3.i124 = icmp eq ptr %call.i.i.i149, null
  br i1 %cmp3.i124, label %_ZNK20b3AlignedObjectArrayIiE4copyEiiPi.exit18.i, label %.noexc55

_ZNK20b3AlignedObjectArrayIiE4copyEiiPi.exit18.i: ; preds = %call.i.i.i.noexc148
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc150 unwind label %lpad11.loopexit.split-lp.loopexit.split-lp

.noexc150:                                        ; preds = %_ZNK20b3AlignedObjectArrayIiE4copyEiiPi.exit18.i
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc55 unwind label %lpad11.loopexit.split-lp.loopexit.split-lp

.noexc55:                                         ; preds = %.noexc150, %call.i.i.i.noexc148
  %_Count.addr.0.i130 = phi i32 [ %3, %call.i.i.i.noexc148 ], [ 0, %.noexc150 ]
  store i8 1, ptr %m_ownsMemory.i.i31, align 8
  store ptr %call.i.i.i149, ptr %m_data.i.i32, align 8
  store i32 %_Count.addr.0.i130, ptr %m_capacity.i.i34, align 8
  %wide.trip.count.i49 = zext nneg i32 %3 to i64
  br label %for.body9.i50

for.body9.i50:                                    ; preds = %for.body9.i50, %.noexc55
  %indvars.iv.i51 = phi i64 [ 0, %.noexc55 ], [ %indvars.iv.next.i53, %for.body9.i50 ]
  %arrayidx12.i52 = getelementptr inbounds i32, ptr %call.i.i.i149, i64 %indvars.iv.i51
  store i32 0, ptr %arrayidx12.i52, align 4
  %indvars.iv.next.i53 = add nuw nsw i64 %indvars.iv.i51, 1
  %exitcond.not.i54 = icmp eq i64 %indvars.iv.next.i53, %wide.trip.count.i49
  br i1 %exitcond.not.i54, label %_ZN20b3AlignedObjectArrayIiE6resizeEiRKi.exit, label %for.body9.i50, !llvm.loop !56

_ZN20b3AlignedObjectArrayIiE6resizeEiRKi.exit:    ; preds = %for.body9.i50
  store i32 %3, ptr %m_size.i.i33, align 4
  br i1 %cmp4.i36, label %for.body.preheader, label %if.then.i.i.i

for.body.preheader:                               ; preds = %_ZN20b3AlignedObjectArrayIiE6resizeEiRKi.exit
  %.pre = load ptr, ptr %m_data.i.i, align 8
  br label %for.body

for.cond20.preheader:                             ; preds = %for.inc
  br i1 %cmp4.i36, label %for.body22.preheader, label %for.end28

for.body22.preheader:                             ; preds = %for.cond20.preheader
  %.pre161 = load ptr, ptr %m_data.i.i, align 8
  br label %for.body22

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %i.0157 = phi i32 [ %inc, %for.inc ], [ 0, %for.body.preheader ]
  invoke void @_Z26processCompoundPairsKernelPK6b3Int4PK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataRK20b3AlignedObjectArrayI9b3Vector3ESF_RKSB_I9b3GpuFaceERKSB_IiEP6b3AabbPK15b3GpuChildShapeRSD_RSK_ii(ptr noundef nonnull %.pre, ptr noundef %rigidBodies, ptr noundef %collidables, ptr noundef %convexShapes, ptr noundef nonnull align 8 dereferenceable(25) %convexVertices, ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges, ptr noundef nonnull align 8 dereferenceable(25) %faces, ptr nonnull align 8 poison, ptr poison, ptr noundef %cpuChildShapes, ptr noundef nonnull align 8 dereferenceable(25) %cpuCompoundSepNormalsOut, ptr noundef nonnull align 8 dereferenceable(25) %cpuHasCompoundSepNormalsOut, i32 noundef %3, i32 noundef %i.0157)
          to label %for.inc unwind label %lpad11.loopexit.split-lp.loopexit

for.inc:                                          ; preds = %for.body
  %inc = add nuw nsw i32 %i.0157, 1
  %exitcond.not = icmp eq i32 %inc, %3
  br i1 %exitcond.not, label %for.cond20.preheader, label %for.body, !llvm.loop !57

lpad11.loopexit:                                  ; preds = %for.body22
  %lpad.loopexit = landingpad { ptr, i32 }
          cleanup
  br label %lpad11

lpad11.loopexit.split-lp.loopexit:                ; preds = %for.body
  %lpad.loopexit153 = landingpad { ptr, i32 }
          cleanup
  br label %lpad11

lpad11.loopexit.split-lp.loopexit.split-lp:       ; preds = %.noexc150, %_ZNK20b3AlignedObjectArrayIiE4copyEiiPi.exit18.i, %_ZN20b3AlignedObjectArrayIiE8allocateEi.exit.i, %.noexc115, %_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i, %_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit.i
  %lpad.loopexit.split-lp154 = landingpad { ptr, i32 }
          cleanup
  br label %lpad11

lpad11:                                           ; preds = %lpad11.loopexit.split-lp.loopexit, %lpad11.loopexit.split-lp.loopexit.split-lp, %lpad11.loopexit
  %lpad.phi = phi { ptr, i32 } [ %lpad.loopexit, %lpad11.loopexit ], [ %lpad.loopexit153, %lpad11.loopexit.split-lp.loopexit ], [ %lpad.loopexit.split-lp154, %lpad11.loopexit.split-lp.loopexit.split-lp ]
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuHasCompoundSepNormalsOut) #26
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuCompoundSepNormalsOut) #26
  br label %ehcleanup29

for.body22:                                       ; preds = %for.body22.preheader, %for.inc26
  %i19.0159 = phi i32 [ %inc27, %for.inc26 ], [ 0, %for.body22.preheader ]
  invoke void @_Z27clipCompoundsHullHullKernelPK6b3Int4PK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataRK20b3AlignedObjectArrayI9b3Vector3ESF_RKSB_I9b3GpuFaceERKSB_IiEPK15b3GpuChildShapeSF_SM_P14b3Contact4DataPiiii(ptr noundef nonnull %.pre161, ptr noundef %rigidBodies, ptr noundef %collidables, ptr noundef %convexShapes, ptr noundef nonnull align 8 dereferenceable(25) %convexVertices, ptr nonnull align 8 poison, ptr noundef nonnull align 8 dereferenceable(25) %faces, ptr noundef nonnull align 8 dereferenceable(25) %convexIndices, ptr noundef %cpuChildShapes, ptr noundef nonnull align 8 dereferenceable(25) %cpuCompoundSepNormalsOut, ptr noundef nonnull align 8 dereferenceable(25) %cpuHasCompoundSepNormalsOut, ptr noundef %globalContactsOut, ptr noundef nonnull %nGlobalContactsOut, i32 noundef %3, i32 noundef %maxContactCapacity, i32 noundef %i19.0159)
          to label %for.inc26 unwind label %lpad11.loopexit

for.inc26:                                        ; preds = %for.body22
  %inc27 = add nuw nsw i32 %i19.0159, 1
  %exitcond160.not = icmp eq i32 %inc27, %3
  br i1 %exitcond160.not, label %for.end28, label %for.body22, !llvm.loop !58

for.end28:                                        ; preds = %for.inc26, %for.cond20.preheader
  %tobool.not.i.i.i = icmp eq ptr %call.i.i.i149, null
  br i1 %tobool.not.i.i.i, label %_ZN20b3AlignedObjectArrayIiED2Ev.exit, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %_ZN20b3AlignedObjectArrayIiE6resizeEiRKi.exit, %for.end28
  %4 = load i8, ptr %m_ownsMemory.i.i31, align 8
  %5 = and i8 %4, 1
  %tobool2.not.i.i.i = icmp eq i8 %5, 0
  br i1 %tobool2.not.i.i.i, label %_ZN20b3AlignedObjectArrayIiED2Ev.exit, label %if.then3.i.i.i

if.then3.i.i.i:                                   ; preds = %if.then.i.i.i
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %call.i.i.i149)
          to label %_ZN20b3AlignedObjectArrayIiED2Ev.exit unwind label %terminate.lpad.i

terminate.lpad.i:                                 ; preds = %if.then3.i.i.i
  %6 = landingpad { ptr, i32 }
          catch ptr null
  %7 = extractvalue { ptr, i32 } %6, 0
  tail call void @__clang_call_terminate(ptr %7) #27
  unreachable

_ZN20b3AlignedObjectArrayIiED2Ev.exit:            ; preds = %invoke.cont12, %invoke.cont9, %for.end28, %if.then.i.i.i, %if.then3.i.i.i
  %8 = load ptr, ptr %m_data.i.i28, align 8
  %tobool.not.i.i.i59 = icmp eq ptr %8, null
  br i1 %tobool.not.i.i.i59, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit, label %if.then.i.i.i60

if.then.i.i.i60:                                  ; preds = %_ZN20b3AlignedObjectArrayIiED2Ev.exit
  %9 = load i8, ptr %m_ownsMemory.i.i27, align 8
  %10 = and i8 %9, 1
  %tobool2.not.i.i.i62 = icmp eq i8 %10, 0
  br i1 %tobool2.not.i.i.i62, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit, label %if.then3.i.i.i63

if.then3.i.i.i63:                                 ; preds = %if.then.i.i.i60
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %8)
          to label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit unwind label %terminate.lpad.i64

terminate.lpad.i64:                               ; preds = %if.then3.i.i.i63
  %11 = landingpad { ptr, i32 }
          catch ptr null
  %12 = extractvalue { ptr, i32 } %11, 0
  tail call void @__clang_call_terminate(ptr %12) #27
  unreachable

_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit:   ; preds = %_ZN20b3AlignedObjectArrayIiED2Ev.exit, %if.then.i.i.i60, %if.then3.i.i.i63
  %13 = load ptr, ptr %m_data.i.i, align 8
  %tobool.not.i.i.i69 = icmp eq ptr %13, null
  br i1 %tobool.not.i.i.i69, label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit, label %if.then.i.i.i70

if.then.i.i.i70:                                  ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit
  %14 = load i8, ptr %m_ownsMemory.i.i, align 8
  %15 = and i8 %14, 1
  %tobool2.not.i.i.i72 = icmp eq i8 %15, 0
  br i1 %tobool2.not.i.i.i72, label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit, label %if.then3.i.i.i73

if.then3.i.i.i73:                                 ; preds = %if.then.i.i.i70
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %13)
          to label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit unwind label %terminate.lpad.i74

terminate.lpad.i74:                               ; preds = %if.then3.i.i.i73
  %16 = landingpad { ptr, i32 }
          catch ptr null
  %17 = extractvalue { ptr, i32 } %16, 0
  tail call void @__clang_call_terminate(ptr %17) #27
  unreachable

_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit:      ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit, %if.then.i.i.i70, %if.then3.i.i.i73
  ret void

ehcleanup29:                                      ; preds = %lpad11, %lpad
  %.pn.pn = phi { ptr, i32 } [ %lpad.phi, %lpad11 ], [ %2, %lpad ]
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuCompoundPairsOut) #26
  resume { ptr, i32 } %.pn.pn
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #10 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %m_data.i.i = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this, i64 0, i32 5
  %0 = load ptr, ptr %m_data.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %0, null
  br i1 %tobool.not.i.i, label %invoke.cont, label %if.then.i.i

if.then.i.i:                                      ; preds = %entry
  %m_ownsMemory.i.i = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this, i64 0, i32 6
  %1 = load i8, ptr %m_ownsMemory.i.i, align 8
  %2 = and i8 %1, 1
  %tobool2.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool2.not.i.i, label %invoke.cont, label %if.then3.i.i

if.then3.i.i:                                     ; preds = %if.then.i.i
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then.i.i, %entry, %if.then3.i.i
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this, i64 0, i32 2
  %m_ownsMemory.i1.i = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i1.i, align 8
  store ptr null, ptr %m_data.i.i, align 8
  store i32 0, ptr %m_size.i.i, align 4
  %m_capacity.i.i = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i, align 8
  ret void

terminate.lpad:                                   ; preds = %if.then3.i.i
  %3 = landingpad { ptr, i32 }
          catch ptr null
  %4 = extractvalue { ptr, i32 } %3, 0
  tail call void @__clang_call_terminate(ptr %4) #27
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #10 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %m_data.i.i = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this, i64 0, i32 5
  %0 = load ptr, ptr %m_data.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %0, null
  br i1 %tobool.not.i.i, label %invoke.cont, label %if.then.i.i

if.then.i.i:                                      ; preds = %entry
  %m_ownsMemory.i.i = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this, i64 0, i32 6
  %1 = load i8, ptr %m_ownsMemory.i.i, align 8
  %2 = and i8 %1, 1
  %tobool2.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool2.not.i.i, label %invoke.cont, label %if.then3.i.i

if.then3.i.i:                                     ; preds = %if.then.i.i
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then.i.i, %entry, %if.then3.i.i
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this, i64 0, i32 2
  %m_ownsMemory.i1.i = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i1.i, align 8
  store ptr null, ptr %m_data.i.i, align 8
  store i32 0, ptr %m_size.i.i, align 4
  %m_capacity.i.i = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i, align 8
  ret void

terminate.lpad:                                   ; preds = %if.then3.i.i
  %3 = landingpad { ptr, i32 }
          catch ptr null
  %4 = extractvalue { ptr, i32 } %3, 0
  tail call void @__clang_call_terminate(ptr %4) #27
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #10 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %m_data.i.i = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this, i64 0, i32 5
  %0 = load ptr, ptr %m_data.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %0, null
  br i1 %tobool.not.i.i, label %invoke.cont, label %if.then.i.i

if.then.i.i:                                      ; preds = %entry
  %m_ownsMemory.i.i = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this, i64 0, i32 6
  %1 = load i8, ptr %m_ownsMemory.i.i, align 8
  %2 = and i8 %1, 1
  %tobool2.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool2.not.i.i, label %invoke.cont, label %if.then3.i.i

if.then3.i.i:                                     ; preds = %if.then.i.i
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then.i.i, %entry, %if.then3.i.i
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this, i64 0, i32 2
  %m_ownsMemory.i1.i = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i1.i, align 8
  store ptr null, ptr %m_data.i.i, align 8
  store i32 0, ptr %m_size.i.i, align 4
  %m_capacity.i.i = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i, align 8
  ret void

terminate.lpad:                                   ; preds = %if.then3.i.i
  %3 = landingpad { ptr, i32 }
          catch ptr null
  %4 = extractvalue { ptr, i32 } %3, 0
  tail call void @__clang_call_terminate(ptr %4) #27
  unreachable
}

; Function Attrs: mustprogress nofree nosync nounwind memory(argmem: readwrite) uwtable
define dso_local void @_Z27computeContactPlaneCompoundiiiiiPK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataPK15b3GpuChildShapePK9b3Vector3PKiPK9b3GpuFaceP10b3Contact4Rii(i32 noundef %pairIndex, i32 noundef %bodyIndexA, i32 noundef %bodyIndexB, i32 noundef %collidableIndexA, i32 noundef %collidableIndexB, ptr nocapture noundef readonly %rigidBodies, ptr nocapture noundef readonly %collidables, ptr nocapture noundef readonly %convexShapes, ptr nocapture noundef readonly %cpuChildShapes, ptr nocapture noundef readonly %convexVertices, ptr nocapture noundef readnone %convexIndices, ptr nocapture noundef readonly %faces, ptr nocapture noundef writeonly %globalContactsOut, ptr nocapture noundef nonnull align 4 dereferenceable(4) %nGlobalContactsOut, i32 noundef %maxContactCapacity) local_unnamed_addr #2 {
entry:
  %planeNormalInConvex = alloca %class.b3Vector3, align 16
  %contactPoints = alloca [64 x %class.b3Vector3], align 16
  %contactIdx = alloca %struct.b3Int4, align 16
  %idxprom = sext i32 %collidableIndexB to i64
  %arrayidx = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom
  %0 = load i32, ptr %arrayidx, align 4
  %cmp417 = icmp sgt i32 %0, 0
  br i1 %cmp417, label %for.body.lr.ph, label %for.end142

for.body.lr.ph:                                   ; preds = %entry
  %1 = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom, i32 3
  %idxprom7 = sext i32 %bodyIndexB to i64
  %arrayidx8 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom7
  %rootPosB.sroa.2.0.arrayidx8.sroa_idx = getelementptr inbounds i8, ptr %arrayidx8, i64 4
  %rootPosB.sroa.3.0.arrayidx8.sroa_idx = getelementptr inbounds i8, ptr %arrayidx8, i64 8
  %m_quat = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom7, i32 1
  %rootOrnB.sroa.3.0.m_quat.sroa_idx = getelementptr inbounds i8, ptr %m_quat, i64 4
  %rootOrnB.sroa.5.0.m_quat.sroa_idx = getelementptr inbounds i8, ptr %m_quat, i64 8
  %rootOrnB.sroa.7.0.m_quat.sroa_idx = getelementptr inbounds i8, ptr %m_quat, i64 12
  %idxprom27 = sext i32 %bodyIndexA to i64
  %arrayidx28 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom27
  %posA.sroa.2.0.arrayidx28.sroa_idx = getelementptr inbounds i8, ptr %arrayidx28, i64 4
  %posA.sroa.3.0.arrayidx28.sroa_idx = getelementptr inbounds i8, ptr %arrayidx28, i64 8
  %m_quat32 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom27, i32 1
  %ornA.sroa.3.0.m_quat32.sroa_idx = getelementptr inbounds i8, ptr %m_quat32, i64 4
  %ornA.sroa.7.0.m_quat32.sroa_idx = getelementptr inbounds i8, ptr %m_quat32, i64 12
  %idxprom33 = sext i32 %collidableIndexA to i64
  %2 = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom33, i32 3
  %3 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %planeNormalInConvex, i64 0, i32 1
  %m_invMass = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom27, i32 5
  %sub112 = sub nsw i32 0, %bodyIndexA
  %m_invMass115 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom7, i32 5
  %sub118 = sub nsw i32 0, %bodyIndexB
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc140
  %c.0418 = phi i32 [ 0, %for.body.lr.ph ], [ %inc141, %for.inc140 ]
  %4 = load i32, ptr %1, align 4
  %add = add nsw i32 %4, %c.0418
  %idxprom5 = sext i32 %add to i64
  %arrayidx6 = getelementptr inbounds %struct.b3GpuChildShape, ptr %cpuChildShapes, i64 %idxprom5
  %5 = getelementptr inbounds %struct.b3GpuChildShape, ptr %cpuChildShapes, i64 %idxprom5, i32 2
  %6 = load i32, ptr %5, align 16
  %rootPosB.sroa.0.0.copyload = load float, ptr %arrayidx8, align 16
  %rootPosB.sroa.2.0.copyload = load float, ptr %rootPosB.sroa.2.0.arrayidx8.sroa_idx, align 4
  %rootPosB.sroa.3.0.copyload = load float, ptr %rootPosB.sroa.3.0.arrayidx8.sroa_idx, align 8
  %rootOrnB.sroa.0.0.copyload = load float, ptr %m_quat, align 16
  %rootOrnB.sroa.3.0.copyload = load float, ptr %rootOrnB.sroa.3.0.m_quat.sroa_idx, align 4
  %rootOrnB.sroa.5.0.copyload = load float, ptr %rootOrnB.sroa.5.0.m_quat.sroa_idx, align 8
  %rootOrnB.sroa.7.0.copyload = load float, ptr %rootOrnB.sroa.7.0.m_quat.sroa_idx, align 4
  %childPosB.sroa.0.0.copyload = load float, ptr %arrayidx6, align 16
  %childPosB.sroa.2.0.arrayidx6.sroa_idx = getelementptr inbounds i8, ptr %arrayidx6, i64 4
  %childPosB.sroa.2.0.copyload = load float, ptr %childPosB.sroa.2.0.arrayidx6.sroa_idx, align 4
  %childPosB.sroa.3.0.arrayidx6.sroa_idx = getelementptr inbounds i8, ptr %arrayidx6, i64 8
  %childPosB.sroa.3.0.copyload = load float, ptr %childPosB.sroa.3.0.arrayidx6.sroa_idx, align 8
  %m_childOrientation = getelementptr inbounds %struct.b3GpuChildShape, ptr %cpuChildShapes, i64 %idxprom5, i32 1
  %childOrnB.sroa.0.0.copyload = load float, ptr %m_childOrientation, align 16
  %childOrnB.sroa.2.0.m_childOrientation.sroa_idx = getelementptr inbounds i8, ptr %m_childOrientation, i64 4
  %childOrnB.sroa.4.0.m_childOrientation.sroa_idx = getelementptr inbounds i8, ptr %m_childOrientation, i64 12
  %childOrnB.sroa.4.0.copyload = load float, ptr %childOrnB.sroa.4.0.m_childOrientation.sroa_idx, align 4
  %mul4.i.i = fmul float %rootOrnB.sroa.3.0.copyload, %childPosB.sroa.3.0.copyload
  %7 = tail call float @llvm.fmuladd.f32(float %rootOrnB.sroa.7.0.copyload, float %childPosB.sroa.0.0.copyload, float %mul4.i.i)
  %neg.i.i = fneg float %rootOrnB.sroa.5.0.copyload
  %8 = tail call float @llvm.fmuladd.f32(float %neg.i.i, float %childPosB.sroa.2.0.copyload, float %7)
  %mul12.i.i = fmul float %rootOrnB.sroa.5.0.copyload, %childPosB.sroa.0.0.copyload
  %9 = tail call float @llvm.fmuladd.f32(float %rootOrnB.sroa.7.0.copyload, float %childPosB.sroa.2.0.copyload, float %mul12.i.i)
  %neg15.i.i = fneg float %rootOrnB.sroa.0.0.copyload
  %10 = tail call float @llvm.fmuladd.f32(float %neg15.i.i, float %childPosB.sroa.3.0.copyload, float %9)
  %mul21.i.i = fmul float %rootOrnB.sroa.0.0.copyload, %childPosB.sroa.2.0.copyload
  %11 = tail call float @llvm.fmuladd.f32(float %rootOrnB.sroa.7.0.copyload, float %childPosB.sroa.3.0.copyload, float %mul21.i.i)
  %neg24.i.i = fneg float %rootOrnB.sroa.3.0.copyload
  %12 = tail call float @llvm.fmuladd.f32(float %neg24.i.i, float %childPosB.sroa.0.0.copyload, float %11)
  %neg31.i.i = fmul float %childPosB.sroa.2.0.copyload, %neg24.i.i
  %13 = tail call float @llvm.fmuladd.f32(float %neg15.i.i, float %childPosB.sroa.0.0.copyload, float %neg31.i.i)
  %14 = tail call float @llvm.fmuladd.f32(float %neg.i.i, float %childPosB.sroa.3.0.copyload, float %13)
  %mul4.i9.i = fmul float %rootOrnB.sroa.7.0.copyload, %8
  %15 = tail call float @llvm.fmuladd.f32(float %14, float %neg15.i.i, float %mul4.i9.i)
  %16 = tail call float @llvm.fmuladd.f32(float %10, float %neg.i.i, float %15)
  %17 = tail call float @llvm.fmuladd.f32(float %12, float %rootOrnB.sroa.3.0.copyload, float %16)
  %mul14.i.i = fmul float %rootOrnB.sroa.7.0.copyload, %10
  %18 = tail call float @llvm.fmuladd.f32(float %14, float %neg24.i.i, float %mul14.i.i)
  %19 = tail call float @llvm.fmuladd.f32(float %12, float %neg15.i.i, float %18)
  %20 = tail call float @llvm.fmuladd.f32(float %8, float %rootOrnB.sroa.5.0.copyload, float %19)
  %mul25.i.i = fmul float %rootOrnB.sroa.7.0.copyload, %12
  %21 = tail call float @llvm.fmuladd.f32(float %14, float %neg.i.i, float %mul25.i.i)
  %22 = tail call float @llvm.fmuladd.f32(float %8, float %neg24.i.i, float %21)
  %23 = tail call float @llvm.fmuladd.f32(float %10, float %rootOrnB.sroa.0.0.copyload, float %22)
  %add.i = fadd float %rootPosB.sroa.0.0.copyload, %17
  %add4.i = fadd float %rootPosB.sroa.2.0.copyload, %20
  %add7.i = fadd float %rootPosB.sroa.3.0.copyload, %23
  %mul14.i = fmul float %rootOrnB.sroa.3.0.copyload, %childOrnB.sroa.4.0.copyload
  %mul25.i = fmul float %rootOrnB.sroa.5.0.copyload, %childOrnB.sroa.4.0.copyload
  %idxprom23 = sext i32 %6 to i64
  %24 = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom23, i32 3
  %25 = load i32, ptr %24, align 4
  %idxprom25 = sext i32 %25 to i64
  %posA.sroa.0.0.copyload = load float, ptr %arrayidx28, align 16
  %posA.sroa.2.0.copyload = load float, ptr %posA.sroa.2.0.arrayidx28.sroa_idx, align 4
  %posA.sroa.3.0.copyload = load float, ptr %posA.sroa.3.0.arrayidx28.sroa_idx, align 8
  %ornA.sroa.0.0.copyload = load float, ptr %m_quat32, align 16
  %ornA.sroa.7.0.copyload = load float, ptr %ornA.sroa.7.0.m_quat32.sroa_idx, align 4
  %26 = load i32, ptr %2, align 4
  %idxprom35 = sext i32 %26 to i64
  %arrayidx36 = getelementptr inbounds %struct.b3GpuFace, ptr %faces, i64 %idxprom35
  %planeEq.sroa.3.0.m_plane.sroa_idx = getelementptr inbounds i8, ptr %arrayidx36, i64 8
  %planeEq.sroa.3.0.copyload = load float, ptr %planeEq.sroa.3.0.m_plane.sroa_idx, align 8
  %planeEq.sroa.4.0.m_plane.sroa_idx = getelementptr inbounds i8, ptr %arrayidx36, i64 12
  %planeEq.sroa.4.0.copyload = load float, ptr %planeEq.sroa.4.0.m_plane.sroa_idx, align 4
  %neg15.i.i66 = fneg float %ornA.sroa.0.0.copyload
  %27 = load <2 x float>, ptr %ornA.sroa.3.0.m_quat32.sroa_idx, align 4
  %28 = load <2 x float>, ptr %arrayidx36, align 16
  %29 = extractelement <2 x float> %27, i64 1
  %30 = extractelement <2 x float> %28, i64 0
  %mul12.i.i65 = fmul float %29, %30
  %31 = extractelement <2 x float> %28, i64 1
  %32 = tail call float @llvm.fmuladd.f32(float %ornA.sroa.7.0.copyload, float %31, float %mul12.i.i65)
  %33 = tail call float @llvm.fmuladd.f32(float %neg15.i.i66, float %planeEq.sroa.3.0.copyload, float %32)
  %34 = insertelement <2 x float> %27, float %ornA.sroa.0.0.copyload, i64 1
  %35 = insertelement <2 x float> %28, float %planeEq.sroa.3.0.copyload, i64 0
  %36 = fmul <2 x float> %34, %35
  %37 = insertelement <2 x float> poison, float %ornA.sroa.7.0.copyload, i64 0
  %38 = shufflevector <2 x float> %37, <2 x float> poison, <2 x i32> zeroinitializer
  %39 = insertelement <2 x float> %28, float %planeEq.sroa.3.0.copyload, i64 1
  %40 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %38, <2 x float> %39, <2 x float> %36)
  %41 = shufflevector <2 x float> %40, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %42 = fneg <2 x float> %27
  %43 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %42, <2 x float> %28, <2 x float> %41)
  %44 = extractelement <2 x float> %42, i64 0
  %neg31.i.i69 = fmul float %31, %44
  %45 = tail call float @llvm.fmuladd.f32(float %neg15.i.i66, float %30, float %neg31.i.i69)
  %46 = extractelement <2 x float> %42, i64 1
  %47 = tail call float @llvm.fmuladd.f32(float %46, float %planeEq.sroa.3.0.copyload, float %45)
  %48 = shufflevector <2 x float> %43, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %49 = insertelement <2 x float> %48, float %33, i64 1
  %50 = fmul <2 x float> %38, %49
  %51 = insertelement <2 x float> poison, float %47, i64 0
  %52 = shufflevector <2 x float> %51, <2 x float> poison, <2 x i32> zeroinitializer
  %53 = shufflevector <2 x float> %42, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %54 = insertelement <2 x float> %53, float %neg15.i.i66, i64 0
  %55 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %52, <2 x float> %54, <2 x float> %50)
  %56 = shufflevector <2 x float> %49, <2 x float> %43, <2 x i32> <i32 1, i32 2>
  %57 = shufflevector <2 x float> %42, <2 x float> %54, <2 x i32> <i32 1, i32 2>
  %58 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %56, <2 x float> %57, <2 x float> %55)
  %59 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %43, <2 x float> %27, <2 x float> %58)
  %60 = extractelement <2 x float> %43, i64 0
  %mul25.i.i72 = fmul float %ornA.sroa.7.0.copyload, %60
  %61 = tail call float @llvm.fmuladd.f32(float %47, float %46, float %mul25.i.i72)
  %62 = extractelement <2 x float> %43, i64 1
  %63 = tail call float @llvm.fmuladd.f32(float %62, float %44, float %61)
  %64 = tail call float @llvm.fmuladd.f32(float %33, float %ornA.sroa.0.0.copyload, float %63)
  %65 = fmul <2 x float> %27, %27
  %fneg.i.i150 = fneg float %posA.sroa.0.0.copyload
  %fneg2.i.i152 = fneg float %posA.sroa.2.0.copyload
  %fneg4.i.i154 = fneg float %posA.sroa.3.0.copyload
  %fneg.i = fneg float %30
  %fneg2.i = fneg float %31
  %fneg4.i = fneg float %planeEq.sroa.3.0.copyload
  %66 = load <2 x float>, ptr %childOrnB.sroa.2.0.m_childOrientation.sroa_idx, align 4
  %67 = extractelement <2 x float> %66, i64 0
  %68 = tail call float @llvm.fmuladd.f32(float %rootOrnB.sroa.7.0.copyload, float %67, float %mul14.i)
  %69 = tail call float @llvm.fmuladd.f32(float %rootOrnB.sroa.5.0.copyload, float %childOrnB.sroa.0.0.copyload, float %68)
  %70 = extractelement <2 x float> %66, i64 1
  %71 = tail call float @llvm.fmuladd.f32(float %neg15.i.i, float %70, float %69)
  %72 = tail call float @llvm.fmuladd.f32(float %rootOrnB.sroa.7.0.copyload, float %70, float %mul25.i)
  %73 = tail call float @llvm.fmuladd.f32(float %rootOrnB.sroa.0.0.copyload, float %67, float %72)
  %74 = tail call float @llvm.fmuladd.f32(float %neg24.i.i, float %childOrnB.sroa.0.0.copyload, float %73)
  %75 = insertelement <2 x float> poison, float %childOrnB.sroa.4.0.copyload, i64 0
  %76 = insertelement <2 x float> %75, float %childOrnB.sroa.0.0.copyload, i64 1
  %77 = insertelement <2 x float> poison, float %rootOrnB.sroa.0.0.copyload, i64 0
  %78 = insertelement <2 x float> %77, float %neg15.i.i, i64 1
  %79 = fmul <2 x float> %76, %78
  %80 = insertelement <2 x float> poison, float %rootOrnB.sroa.7.0.copyload, i64 0
  %81 = shufflevector <2 x float> %80, <2 x float> poison, <2 x i32> zeroinitializer
  %82 = insertelement <2 x float> poison, float %childOrnB.sroa.0.0.copyload, i64 0
  %83 = insertelement <2 x float> %82, float %childOrnB.sroa.4.0.copyload, i64 1
  %84 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %81, <2 x float> %83, <2 x float> %79)
  %85 = insertelement <2 x float> poison, float %rootOrnB.sroa.3.0.copyload, i64 0
  %86 = insertelement <2 x float> %85, float %neg24.i.i, i64 1
  %87 = shufflevector <2 x float> %66, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %88 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %86, <2 x float> %87, <2 x float> %84)
  %89 = insertelement <2 x float> poison, float %neg.i.i, i64 0
  %90 = shufflevector <2 x float> %89, <2 x float> poison, <2 x i32> zeroinitializer
  %91 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %90, <2 x float> %66, <2 x float> %88)
  %mul4.i.i.i.i = fmul float %71, %71
  %92 = insertelement <2 x float> %91, float %ornA.sroa.0.0.copyload, i64 1
  %93 = insertelement <2 x float> poison, float %mul4.i.i.i.i, i64 0
  %94 = shufflevector <2 x float> %93, <2 x float> %65, <2 x i32> <i32 0, i32 2>
  %95 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %92, <2 x float> %92, <2 x float> %94)
  %96 = insertelement <2 x float> %27, float %74, i64 0
  %97 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %96, <2 x float> %96, <2 x float> %95)
  %98 = shufflevector <2 x float> %91, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %99 = insertelement <2 x float> %98, float %ornA.sroa.7.0.copyload, i64 1
  %100 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %99, <2 x float> %99, <2 x float> %97)
  %101 = fdiv <2 x float> <float 2.000000e+00, float 2.000000e+00>, %100
  %102 = shufflevector <2 x float> %96, <2 x float> %91, <2 x i32> <i32 0, i32 2>
  %103 = shufflevector <2 x float> %101, <2 x float> poison, <2 x i32> zeroinitializer
  %104 = fmul <2 x float> %102, %103
  %shift = shufflevector <2 x float> %104, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %105 = fmul <2 x float> %91, %shift
  %mul14.i.i81 = extractelement <2 x float> %105, i64 0
  %106 = fmul <2 x float> %91, %104
  %107 = insertelement <2 x float> %27, float %71, i64 0
  %108 = fmul <2 x float> %107, %101
  %109 = extractelement <2 x float> %108, i64 0
  %mul20.i.i = fmul float %71, %109
  %110 = shufflevector <2 x float> %91, <2 x float> %107, <2 x i32> <i32 1, i32 2>
  %111 = shufflevector <2 x float> %108, <2 x float> %104, <2 x i32> <i32 0, i32 2>
  %112 = fmul <2 x float> %110, %111
  %113 = insertelement <2 x float> %27, float %74, i64 1
  %114 = shufflevector <2 x float> %101, <2 x float> %104, <2 x i32> <i32 1, i32 2>
  %115 = fmul <2 x float> %113, %114
  %116 = shufflevector <2 x float> %115, <2 x float> %91, <2 x i32> <i32 1, i32 3>
  %117 = shufflevector <2 x float> %104, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %118 = insertelement <2 x float> %117, float %mul20.i.i, i64 0
  %119 = fadd <2 x float> %116, %118
  %120 = fmul <2 x float> %116, %118
  %121 = shufflevector <2 x float> %119, <2 x float> %120, <2 x i32> <i32 0, i32 3>
  %122 = shufflevector <2 x float> %27, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %123 = shufflevector <2 x float> %91, <2 x float> %122, <2 x i32> <i32 0, i32 3>
  %124 = fmul <2 x float> %123, %108
  %125 = shufflevector <2 x float> %124, <2 x float> <float 1.000000e+00, float poison>, <2 x i32> <i32 2, i32 0>
  %126 = fsub <2 x float> %125, %121
  %127 = fadd <2 x float> %106, %112
  %add28.i.i = extractelement <2 x float> %127, i64 0
  %128 = fsub <2 x float> %112, %106
  %sub35.i.i = extractelement <2 x float> %128, i64 1
  %129 = fsub <2 x float> %106, %112
  %130 = fadd <2 x float> %106, %112
  %131 = shufflevector <2 x float> %129, <2 x float> %130, <2 x i32> <i32 0, i32 3>
  %add41.i.i = fadd float %mul14.i.i81, %mul20.i.i
  %sub42.i.i = fsub float 1.000000e+00, %add41.i.i
  %132 = extractelement <2 x float> %101, i64 1
  %mul.i.i97 = fmul float %ornA.sroa.0.0.copyload, %132
  %mul8.i.i100 = fmul float %ornA.sroa.7.0.copyload, %mul.i.i97
  %133 = extractelement <2 x float> %115, i64 0
  %mul10.i.i101 = fmul float %ornA.sroa.7.0.copyload, %133
  %134 = extractelement <2 x float> %108, i64 1
  %mul12.i.i102 = fmul float %ornA.sroa.7.0.copyload, %134
  %mul14.i.i103 = fmul float %ornA.sroa.0.0.copyload, %mul.i.i97
  %135 = insertelement <2 x float> poison, float %ornA.sroa.0.0.copyload, i64 0
  %136 = shufflevector <2 x float> %135, <2 x float> %105, <2 x i32> <i32 0, i32 2>
  %137 = fmul <2 x float> %136, %115
  %138 = fadd <2 x float> %136, %115
  %139 = shufflevector <2 x float> %137, <2 x float> %138, <2 x i32> <i32 0, i32 3>
  %mul18.i.i105 = fmul float %ornA.sroa.0.0.copyload, %134
  %140 = fmul <2 x float> %27, %115
  %mul20.i.i106 = extractelement <2 x float> %140, i64 0
  %mul24.i.i108 = fmul float %29, %134
  %add.i.i109 = fadd float %mul20.i.i106, %mul24.i.i108
  %sub.i.i110 = fsub float 1.000000e+00, %add.i.i109
  %141 = extractelement <2 x float> %137, i64 0
  %sub26.i.i111 = fsub float %141, %mul12.i.i102
  %add28.i.i112 = fadd float %mul18.i.i105, %mul10.i.i101
  %142 = insertelement <2 x float> <float poison, float 1.000000e+00>, float %mul12.i.i102, i64 0
  %143 = fadd <2 x float> %142, %139
  %144 = fsub <2 x float> %142, %139
  %145 = shufflevector <2 x float> %143, <2 x float> %144, <2 x i32> <i32 0, i32 3>
  %add32.i.i114 = fadd float %mul14.i.i103, %mul24.i.i108
  %sub33.i.i115 = fsub float 1.000000e+00, %add32.i.i114
  %146 = shufflevector <2 x float> %120, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %147 = insertelement <2 x float> %146, float %mul8.i.i100, i64 1
  %148 = fadd <2 x float> %124, %147
  %149 = fsub <2 x float> %124, %147
  %150 = shufflevector <2 x float> %148, <2 x float> %149, <2 x i32> <i32 0, i32 3>
  %sub37.i.i117 = fsub float %mul18.i.i105, %mul10.i.i101
  %151 = extractelement <2 x float> %124, i64 1
  %add39.i.i118 = fadd float %151, %mul8.i.i100
  %add41.i.i119 = fadd float %mul14.i.i103, %mul20.i.i106
  %sub42.i.i120 = fsub float 1.000000e+00, %add41.i.i119
  %152 = shufflevector <2 x float> %150, <2 x float> %145, <2 x i32> <i32 0, i32 2>
  %153 = fmul <2 x float> %152, %145
  %154 = insertelement <2 x float> poison, float %sub.i.i110, i64 0
  %155 = shufflevector <2 x float> %154, <2 x float> poison, <2 x i32> zeroinitializer
  %156 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %155, <2 x float> %126, <2 x float> %153)
  %157 = insertelement <2 x float> poison, float %sub37.i.i117, i64 0
  %158 = shufflevector <2 x float> %157, <2 x float> poison, <2 x i32> zeroinitializer
  %159 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %158, <2 x float> %131, <2 x float> %156)
  %160 = shufflevector <2 x float> %150, <2 x float> %145, <2 x i32> <i32 0, i32 3>
  %161 = insertelement <2 x float> poison, float %sub33.i.i115, i64 0
  %162 = shufflevector <2 x float> %161, <2 x float> poison, <2 x i32> zeroinitializer
  %163 = fmul <2 x float> %160, %162
  %164 = insertelement <2 x float> poison, float %sub26.i.i111, i64 0
  %165 = shufflevector <2 x float> %164, <2 x float> poison, <2 x i32> zeroinitializer
  %166 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %165, <2 x float> %126, <2 x float> %163)
  %167 = insertelement <2 x float> poison, float %add39.i.i118, i64 0
  %168 = shufflevector <2 x float> %167, <2 x float> poison, <2 x i32> zeroinitializer
  %169 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %168, <2 x float> %131, <2 x float> %166)
  %170 = shufflevector <2 x float> %150, <2 x float> %145, <2 x i32> <i32 1, i32 3>
  %171 = fmul <2 x float> %150, %170
  %172 = insertelement <2 x float> poison, float %add28.i.i112, i64 0
  %173 = shufflevector <2 x float> %172, <2 x float> poison, <2 x i32> zeroinitializer
  %174 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %173, <2 x float> %126, <2 x float> %171)
  %175 = insertelement <2 x float> poison, float %sub42.i.i120, i64 0
  %176 = shufflevector <2 x float> %175, <2 x float> poison, <2 x i32> zeroinitializer
  %177 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %176, <2 x float> %131, <2 x float> %174)
  %178 = extractelement <2 x float> %143, i64 0
  %mul7.i48.i.i = fmul float %sub35.i.i, %178
  %179 = tail call float @llvm.fmuladd.f32(float %sub.i.i110, float %add28.i.i, float %mul7.i48.i.i)
  %180 = tail call noundef float @llvm.fmuladd.f32(float %sub37.i.i117, float %sub42.i.i, float %179)
  %mul7.i55.i.i = fmul float %sub35.i.i, %sub33.i.i115
  %181 = tail call float @llvm.fmuladd.f32(float %sub26.i.i111, float %add28.i.i, float %mul7.i55.i.i)
  %182 = tail call noundef float @llvm.fmuladd.f32(float %add39.i.i118, float %sub42.i.i, float %181)
  %183 = extractelement <2 x float> %149, i64 1
  %mul7.i62.i.i = fmul float %sub35.i.i, %183
  %184 = tail call float @llvm.fmuladd.f32(float %add28.i.i112, float %add28.i.i, float %mul7.i62.i.i)
  %185 = tail call noundef float @llvm.fmuladd.f32(float %sub42.i.i120, float %sub42.i.i, float %184)
  %mul5.i.i.i155 = fmul float %178, %fneg2.i.i152
  %186 = tail call float @llvm.fmuladd.f32(float %sub.i.i110, float %fneg.i.i150, float %mul5.i.i.i155)
  %187 = tail call noundef float @llvm.fmuladd.f32(float %sub37.i.i117, float %fneg4.i.i154, float %186)
  %mul5.i7.i.i156 = fmul float %sub33.i.i115, %fneg2.i.i152
  %188 = tail call float @llvm.fmuladd.f32(float %sub26.i.i111, float %fneg.i.i150, float %mul5.i7.i.i156)
  %189 = tail call noundef float @llvm.fmuladd.f32(float %add39.i.i118, float %fneg4.i.i154, float %188)
  %mul5.i13.i.i157 = fmul float %183, %fneg2.i.i152
  %190 = tail call float @llvm.fmuladd.f32(float %add28.i.i112, float %fneg.i.i150, float %mul5.i13.i.i157)
  %191 = tail call noundef float @llvm.fmuladd.f32(float %sub42.i.i120, float %fneg4.i.i154, float %190)
  %192 = insertelement <2 x float> poison, float %fneg2.i, i64 0
  %193 = shufflevector <2 x float> %192, <2 x float> poison, <2 x i32> zeroinitializer
  %194 = fmul <2 x float> %169, %193
  %195 = insertelement <2 x float> poison, float %fneg.i, i64 0
  %196 = shufflevector <2 x float> %195, <2 x float> poison, <2 x i32> zeroinitializer
  %197 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %159, <2 x float> %196, <2 x float> %194)
  %198 = insertelement <2 x float> poison, float %fneg4.i, i64 0
  %199 = shufflevector <2 x float> %198, <2 x float> poison, <2 x i32> zeroinitializer
  %200 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %177, <2 x float> %199, <2 x float> %197)
  %mul5.i13.i = fmul float %182, %fneg2.i
  %201 = tail call float @llvm.fmuladd.f32(float %180, float %fneg.i, float %mul5.i13.i)
  %202 = tail call noundef float @llvm.fmuladd.f32(float %185, float %fneg4.i, float %201)
  %retval.sroa.3.12.vec.insert.i.i245 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %202, i64 0
  store <2 x float> %200, ptr %planeNormalInConvex, align 16
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i245, ptr %3, align 8
  store <4 x i32> <i32 0, i32 1, i32 2, i32 3>, ptr %contactIdx, align 16
  %m_numVertices = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexShapes, i64 %idxprom25, i32 7
  %203 = load i32, ptr %m_numVertices, align 4
  %cmp65411 = icmp sgt i32 %203, 0
  br i1 %cmp65411, label %for.body66.lr.ph, label %for.inc140

for.body66.lr.ph:                                 ; preds = %for.body
  %m_vertexOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexShapes, i64 %idxprom25, i32 8
  %204 = load i32, ptr %m_vertexOffset, align 16
  %205 = sext i32 %204 to i64
  %wide.trip.count = zext nneg i32 %203 to i64
  %invariant.gep = getelementptr %class.b3Vector3, ptr %convexVertices, i64 %205
  %206 = extractelement <2 x float> %200, i64 0
  %207 = extractelement <2 x float> %200, i64 1
  %208 = extractelement <2 x float> %129, i64 0
  %209 = extractelement <2 x float> %130, i64 1
  %210 = extractelement <2 x float> %126, i64 0
  %211 = extractelement <2 x float> %126, i64 1
  %212 = extractelement <2 x float> %148, i64 0
  %213 = extractelement <2 x float> %144, i64 1
  br label %for.body66

for.body66:                                       ; preds = %for.body66.lr.ph, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body66.lr.ph ], [ %indvars.iv.next, %for.inc ]
  %maxDot.0414 = phi float [ 0xC6293E5940000000, %for.body66.lr.ph ], [ %maxDot.1, %for.inc ]
  %numPoints.0413 = phi i32 [ 0, %for.body66.lr.ph ], [ %numPoints.2, %for.inc ]
  %gep = getelementptr %class.b3Vector3, ptr %invariant.gep, i64 %indvars.iv
  %vtx.sroa.0.0.copyload = load float, ptr %gep, align 16
  %vtx.sroa.3.0.arrayidx69.sroa_idx = getelementptr inbounds i8, ptr %gep, i64 4
  %vtx.sroa.3.0.copyload = load float, ptr %vtx.sroa.3.0.arrayidx69.sroa_idx, align 4
  %vtx.sroa.5.0.arrayidx69.sroa_idx = getelementptr inbounds i8, ptr %gep, i64 8
  %vtx.sroa.5.0.copyload = load float, ptr %vtx.sroa.5.0.arrayidx69.sroa_idx, align 8
  %mul5.i = fmul float %vtx.sroa.3.0.copyload, %207
  %214 = tail call float @llvm.fmuladd.f32(float %vtx.sroa.0.0.copyload, float %206, float %mul5.i)
  %215 = tail call noundef float @llvm.fmuladd.f32(float %vtx.sroa.5.0.copyload, float %202, float %214)
  %cmp71 = fcmp ogt float %215, %maxDot.0414
  %cmp72 = icmp eq i32 %numPoints.0413, 64
  %216 = select i1 %cmp71, i1 %cmp72, i1 false
  %numPoints.1 = select i1 %216, i32 63, i32 %numPoints.0413
  %maxDot.1 = select i1 %cmp71, float %215, float %maxDot.0414
  %cmp75 = icmp slt i32 %numPoints.1, 64
  br i1 %cmp75, label %if.then76, label %for.inc

if.then76:                                        ; preds = %for.body66
  %mul5.i.i.i.i254 = fmul float %211, %vtx.sroa.3.0.copyload
  %217 = tail call float @llvm.fmuladd.f32(float %vtx.sroa.0.0.copyload, float %210, float %mul5.i.i.i.i254)
  %218 = tail call noundef float @llvm.fmuladd.f32(float %vtx.sroa.5.0.copyload, float %add28.i.i, float %217)
  %mul5.i3.i.i.i257 = fmul float %213, %vtx.sroa.3.0.copyload
  %219 = tail call float @llvm.fmuladd.f32(float %vtx.sroa.0.0.copyload, float %212, float %mul5.i3.i.i.i257)
  %220 = tail call noundef float @llvm.fmuladd.f32(float %vtx.sroa.5.0.copyload, float %sub35.i.i, float %219)
  %mul5.i8.i.i.i258 = fmul float %209, %vtx.sroa.3.0.copyload
  %221 = tail call float @llvm.fmuladd.f32(float %vtx.sroa.0.0.copyload, float %208, float %mul5.i8.i.i.i258)
  %222 = tail call noundef float @llvm.fmuladd.f32(float %vtx.sroa.5.0.copyload, float %sub42.i.i, float %221)
  %add.i.i.i260 = fadd float %add.i, %218
  %add4.i.i.i262 = fadd float %add4.i, %220
  %add7.i.i.i264 = fadd float %add7.i, %222
  %mul5.i.i.i.i305 = fmul float %178, %add4.i.i.i262
  %223 = tail call float @llvm.fmuladd.f32(float %add.i.i.i260, float %sub.i.i110, float %mul5.i.i.i.i305)
  %224 = tail call noundef float @llvm.fmuladd.f32(float %add7.i.i.i264, float %sub37.i.i117, float %223)
  %mul5.i3.i.i.i309 = fmul float %sub33.i.i115, %add4.i.i.i262
  %225 = tail call float @llvm.fmuladd.f32(float %add.i.i.i260, float %sub26.i.i111, float %mul5.i3.i.i.i309)
  %226 = tail call noundef float @llvm.fmuladd.f32(float %add7.i.i.i264, float %add39.i.i118, float %225)
  %mul5.i8.i.i.i312 = fmul float %183, %add4.i.i.i262
  %227 = tail call float @llvm.fmuladd.f32(float %add.i.i.i260, float %add28.i.i112, float %mul5.i8.i.i.i312)
  %228 = tail call noundef float @llvm.fmuladd.f32(float %add7.i.i.i264, float %sub42.i.i120, float %227)
  %add.i.i.i315 = fadd float %187, %224
  %add4.i.i.i317 = fadd float %189, %226
  %add7.i.i.i319 = fadd float %191, %228
  %mul5.i327 = fmul float %31, %add4.i.i.i317
  %229 = tail call float @llvm.fmuladd.f32(float %30, float %add.i.i.i315, float %mul5.i327)
  %230 = tail call noundef float @llvm.fmuladd.f32(float %planeEq.sroa.3.0.copyload, float %add7.i.i.i319, float %229)
  %sub = fsub float %230, %planeEq.sroa.4.0.copyload
  %cmp85 = fcmp olt float %sub, 0.000000e+00
  br i1 %cmp85, label %if.then86, label %for.inc

if.then86:                                        ; preds = %if.then76
  %retval.sroa.3.12.vec.insert.i.i4.i.i267 = insertelement <2 x float> poison, float %add7.i.i.i264, i64 0
  %retval.sroa.0.0.vec.insert.i.i2.i.i265 = insertelement <2 x float> poison, float %add.i.i.i260, i64 0
  %retval.sroa.0.4.vec.insert.i.i3.i.i266 = insertelement <2 x float> %retval.sroa.0.0.vec.insert.i.i2.i.i265, float %add4.i.i.i262, i64 1
  %vtxWorld.sroa.4.12.vec.insert = insertelement <2 x float> %retval.sroa.3.12.vec.insert.i.i4.i.i267, float %sub, i64 1
  %idxprom88 = sext i32 %numPoints.1 to i64
  %arrayidx89 = getelementptr inbounds [64 x %class.b3Vector3], ptr %contactPoints, i64 0, i64 %idxprom88
  store <2 x float> %retval.sroa.0.4.vec.insert.i.i3.i.i266, ptr %arrayidx89, align 16
  %vtxWorld.sroa.4.0.arrayidx89.sroa_idx = getelementptr inbounds i8, ptr %arrayidx89, i64 8
  store <2 x float> %vtxWorld.sroa.4.12.vec.insert, ptr %vtxWorld.sroa.4.0.arrayidx89.sroa_idx, align 8
  %inc = add nsw i32 %numPoints.1, 1
  br label %for.inc

for.inc:                                          ; preds = %for.body66, %if.then86, %if.then76
  %numPoints.2 = phi i32 [ %inc, %if.then86 ], [ %numPoints.1, %if.then76 ], [ %numPoints.0413, %for.body66 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body66, !llvm.loop !59

for.end:                                          ; preds = %for.inc
  %cmp93 = icmp sgt i32 %numPoints.2, 4
  br i1 %cmp93, label %if.then94, label %if.end96

if.then94:                                        ; preds = %for.end
  %call95 = call noundef i32 @_Z31extractManifoldSequentialGlobalPK9b3Vector3iRS0_P6b3Int4(ptr noundef nonnull %contactPoints, i32 noundef %numPoints.2, ptr noundef nonnull align 16 dereferenceable(16) %planeNormalInConvex, ptr noundef nonnull %contactIdx)
  br label %if.end96

if.end96:                                         ; preds = %if.then94, %for.end
  %numReducedPoints.0 = phi i32 [ %call95, %if.then94 ], [ %numPoints.2, %for.end ]
  %cmp97 = icmp sgt i32 %numReducedPoints.0, 0
  br i1 %cmp97, label %if.then98, label %for.inc140

if.then98:                                        ; preds = %if.end96
  %231 = load i32, ptr %nGlobalContactsOut, align 4
  %cmp99 = icmp slt i32 %231, %maxContactCapacity
  br i1 %cmp99, label %for.body125.preheader, label %for.inc140

for.body125.preheader:                            ; preds = %if.then98
  %inc101 = add nsw i32 %231, 1
  store i32 %inc101, ptr %nGlobalContactsOut, align 4
  %idxprom103 = sext i32 %231 to i64
  %arrayidx104 = getelementptr inbounds %struct.b3Contact4, ptr %globalContactsOut, i64 %idxprom103
  %232 = fneg <2 x float> %59
  %fneg4.i334 = fneg float %64
  %retval.sroa.3.12.vec.insert.i.i337 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %fneg4.i334, i64 0
  %m_worldNormalOnB = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx104, i64 0, i32 1
  store <2 x float> %232, ptr %m_worldNormalOnB, align 16
  %ref.tmp105.sroa.2.0.m_worldNormalOnB.sroa_idx = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx104, i64 0, i32 1, i32 0, i32 0, i64 2
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i337, ptr %ref.tmp105.sroa.2.0.m_worldNormalOnB.sroa_idx, align 8
  %m_frictionCoeffCmp.i = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx104, i64 0, i32 3
  store i16 -19662, ptr %m_frictionCoeffCmp.i, align 2
  %m_restituitionCoeffCmp.i = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx104, i64 0, i32 2
  store i16 0, ptr %m_restituitionCoeffCmp.i, align 16
  %m_batchIdx = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx104, i64 0, i32 4
  store i32 %pairIndex, ptr %m_batchIdx, align 4
  %233 = load float, ptr %m_invMass, align 4
  %cmp111 = fcmp oeq float %233, 0.000000e+00
  %cond = select i1 %cmp111, i32 %sub112, i32 %bodyIndexA
  %m_bodyAPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx104, i64 0, i32 5
  store i32 %cond, ptr %m_bodyAPtrAndSignBit, align 8
  %234 = load float, ptr %m_invMass115, align 4
  %cmp116 = fcmp oeq float %234, 0.000000e+00
  %cond121 = select i1 %cmp116, i32 %sub118, i32 %bodyIndexB
  %m_bodyBPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx104, i64 0, i32 6
  store i32 %cond121, ptr %m_bodyBPtrAndSignBit, align 4
  %wide.trip.count424 = zext nneg i32 %numReducedPoints.0 to i64
  br label %for.body125

for.body125:                                      ; preds = %for.body125.preheader, %for.body125
  %indvars.iv421 = phi i64 [ 0, %for.body125.preheader ], [ %indvars.iv.next422, %for.body125 ]
  %arrayidx128 = getelementptr inbounds [4 x i32], ptr %contactIdx, i64 0, i64 %indvars.iv421
  %235 = load i32, ptr %arrayidx128, align 4
  %idxprom129 = sext i32 %235 to i64
  %arrayidx130 = getelementptr inbounds [64 x %class.b3Vector3], ptr %contactPoints, i64 0, i64 %idxprom129
  %arrayidx132 = getelementptr inbounds [4 x %class.b3Vector3], ptr %arrayidx104, i64 0, i64 %indvars.iv421
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx132, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx130, i64 16, i1 false)
  %indvars.iv.next422 = add nuw nsw i64 %indvars.iv421, 1
  %exitcond425.not = icmp eq i64 %indvars.iv.next422, %wide.trip.count424
  br i1 %exitcond425.not, label %for.end135, label %for.body125, !llvm.loop !60

for.end135:                                       ; preds = %for.body125
  %conv = sitofp i32 %numReducedPoints.0 to float
  %w137 = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx104, i64 0, i32 1, i32 0, i32 0, i64 3
  store float %conv, ptr %w137, align 4
  br label %for.inc140

for.inc140:                                       ; preds = %for.body, %if.end96, %for.end135, %if.then98
  %inc141 = add nuw nsw i32 %c.0418, 1
  %exitcond426.not = icmp eq i32 %inc141, %0
  br i1 %exitcond426.not, label %for.end142, label %for.body, !llvm.loop !61

for.end142:                                       ; preds = %for.inc140, %entry
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local void @_Z26computeContactSphereConvexiiiiiPK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataPK9b3Vector3PKiPK9b3GpuFaceP10b3Contact4Rii(i32 noundef %pairIndex, i32 noundef %bodyIndexA, i32 noundef %bodyIndexB, i32 noundef %collidableIndexA, i32 noundef %collidableIndexB, ptr nocapture noundef readonly %rigidBodies, ptr nocapture noundef readonly %collidables, ptr nocapture noundef readonly %convexShapes, ptr nocapture noundef readonly %convexVertices, ptr nocapture noundef readonly %convexIndices, ptr nocapture noundef readonly %faces, ptr nocapture noundef writeonly %globalContactsOut, ptr nocapture noundef nonnull align 4 dereferenceable(4) %nGlobalContactsOut, i32 noundef %maxContactCapacity) local_unnamed_addr #6 {
entry:
  %idxprom = sext i32 %collidableIndexA to i64
  %0 = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom, i32 1
  %1 = load float, ptr %0, align 4
  %idxprom1 = sext i32 %bodyIndexA to i64
  %arrayidx2 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom1
  %spherePos1.sroa.0.0.copyload = load float, ptr %arrayidx2, align 16
  %spherePos1.sroa.2.0.arrayidx2.sroa_idx = getelementptr inbounds i8, ptr %arrayidx2, i64 4
  %spherePos1.sroa.2.0.copyload = load float, ptr %spherePos1.sroa.2.0.arrayidx2.sroa_idx, align 4
  %spherePos1.sroa.3.0.arrayidx2.sroa_idx = getelementptr inbounds i8, ptr %arrayidx2, i64 8
  %spherePos1.sroa.3.0.copyload = load float, ptr %spherePos1.sroa.3.0.arrayidx2.sroa_idx, align 8
  %idxprom5 = sext i32 %bodyIndexB to i64
  %arrayidx6 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom5
  %pos.sroa.0.0.copyload = load float, ptr %arrayidx6, align 16
  %pos.sroa.2.0.arrayidx6.sroa_idx = getelementptr inbounds i8, ptr %arrayidx6, i64 4
  %pos.sroa.2.0.copyload = load float, ptr %pos.sroa.2.0.arrayidx6.sroa_idx, align 4
  %pos.sroa.3.0.arrayidx6.sroa_idx = getelementptr inbounds i8, ptr %arrayidx6, i64 8
  %pos.sroa.3.0.copyload = load float, ptr %pos.sroa.3.0.arrayidx6.sroa_idx, align 8
  %m_quat10 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom5, i32 1
  %quat.sroa.0.0.copyload = load float, ptr %m_quat10, align 16
  %quat.sroa.2.0.m_quat10.sroa_idx = getelementptr inbounds i8, ptr %m_quat10, i64 4
  %quat.sroa.2.0.copyload = load float, ptr %quat.sroa.2.0.m_quat10.sroa_idx, align 4
  %quat.sroa.3.0.m_quat10.sroa_idx = getelementptr inbounds i8, ptr %m_quat10, i64 8
  %quat.sroa.3.0.copyload = load float, ptr %quat.sroa.3.0.m_quat10.sroa_idx, align 8
  %quat.sroa.4.0.m_quat10.sroa_idx = getelementptr inbounds i8, ptr %m_quat10, i64 12
  %quat.sroa.4.0.copyload = load float, ptr %quat.sroa.4.0.m_quat10.sroa_idx, align 4
  %mul4.i.i.i.i = fmul float %quat.sroa.2.0.copyload, %quat.sroa.2.0.copyload
  %2 = tail call float @llvm.fmuladd.f32(float %quat.sroa.0.0.copyload, float %quat.sroa.0.0.copyload, float %mul4.i.i.i.i)
  %3 = tail call float @llvm.fmuladd.f32(float %quat.sroa.3.0.copyload, float %quat.sroa.3.0.copyload, float %2)
  %4 = tail call noundef float @llvm.fmuladd.f32(float %quat.sroa.4.0.copyload, float %quat.sroa.4.0.copyload, float %3)
  %div.i.i = fdiv float 2.000000e+00, %4
  %mul.i.i = fmul float %quat.sroa.0.0.copyload, %div.i.i
  %mul4.i.i = fmul float %quat.sroa.2.0.copyload, %div.i.i
  %mul6.i.i = fmul float %quat.sroa.3.0.copyload, %div.i.i
  %mul8.i.i = fmul float %quat.sroa.4.0.copyload, %mul.i.i
  %mul10.i.i = fmul float %quat.sroa.4.0.copyload, %mul4.i.i
  %mul12.i.i = fmul float %quat.sroa.4.0.copyload, %mul6.i.i
  %mul14.i.i = fmul float %quat.sroa.0.0.copyload, %mul.i.i
  %mul16.i.i = fmul float %quat.sroa.0.0.copyload, %mul4.i.i
  %mul18.i.i = fmul float %quat.sroa.0.0.copyload, %mul6.i.i
  %mul20.i.i = fmul float %quat.sroa.2.0.copyload, %mul4.i.i
  %mul22.i.i = fmul float %quat.sroa.2.0.copyload, %mul6.i.i
  %mul24.i.i = fmul float %quat.sroa.3.0.copyload, %mul6.i.i
  %add.i.i = fadd float %mul20.i.i, %mul24.i.i
  %sub.i.i = fsub float 1.000000e+00, %add.i.i
  %sub26.i.i = fsub float %mul16.i.i, %mul12.i.i
  %add28.i.i = fadd float %mul18.i.i, %mul10.i.i
  %add30.i.i = fadd float %mul16.i.i, %mul12.i.i
  %add32.i.i = fadd float %mul14.i.i, %mul24.i.i
  %sub33.i.i = fsub float 1.000000e+00, %add32.i.i
  %sub35.i.i = fsub float %mul22.i.i, %mul8.i.i
  %sub37.i.i = fsub float %mul18.i.i, %mul10.i.i
  %add39.i.i = fadd float %mul22.i.i, %mul8.i.i
  %add41.i.i = fadd float %mul14.i.i, %mul20.i.i
  %sub42.i.i = fsub float 1.000000e+00, %add41.i.i
  %fneg.i.i = fneg float %pos.sroa.0.0.copyload
  %fneg2.i.i = fneg float %pos.sroa.2.0.copyload
  %fneg4.i.i = fneg float %pos.sroa.3.0.copyload
  %mul5.i.i.i = fmul float %add30.i.i, %fneg2.i.i
  %5 = tail call float @llvm.fmuladd.f32(float %sub.i.i, float %fneg.i.i, float %mul5.i.i.i)
  %6 = tail call noundef float @llvm.fmuladd.f32(float %sub37.i.i, float %fneg4.i.i, float %5)
  %mul5.i7.i.i = fmul float %sub33.i.i, %fneg2.i.i
  %7 = tail call float @llvm.fmuladd.f32(float %sub26.i.i, float %fneg.i.i, float %mul5.i7.i.i)
  %8 = tail call noundef float @llvm.fmuladd.f32(float %add39.i.i, float %fneg4.i.i, float %7)
  %mul5.i13.i.i = fmul float %sub35.i.i, %fneg2.i.i
  %9 = tail call float @llvm.fmuladd.f32(float %add28.i.i, float %fneg.i.i, float %mul5.i13.i.i)
  %10 = tail call noundef float @llvm.fmuladd.f32(float %sub42.i.i, float %fneg4.i.i, float %9)
  %mul5.i.i.i50 = fmul float %spherePos1.sroa.2.0.copyload, %add30.i.i
  %11 = tail call float @llvm.fmuladd.f32(float %spherePos1.sroa.0.0.copyload, float %sub.i.i, float %mul5.i.i.i50)
  %12 = tail call noundef float @llvm.fmuladd.f32(float %spherePos1.sroa.3.0.copyload, float %sub37.i.i, float %11)
  %mul5.i3.i.i = fmul float %spherePos1.sroa.2.0.copyload, %sub33.i.i
  %13 = tail call float @llvm.fmuladd.f32(float %spherePos1.sroa.0.0.copyload, float %sub26.i.i, float %mul5.i3.i.i)
  %14 = tail call noundef float @llvm.fmuladd.f32(float %spherePos1.sroa.3.0.copyload, float %add39.i.i, float %13)
  %mul5.i8.i.i = fmul float %spherePos1.sroa.2.0.copyload, %sub35.i.i
  %15 = tail call float @llvm.fmuladd.f32(float %spherePos1.sroa.0.0.copyload, float %add28.i.i, float %mul5.i8.i.i)
  %16 = tail call noundef float @llvm.fmuladd.f32(float %spherePos1.sroa.3.0.copyload, float %sub42.i.i, float %15)
  %add.i.i52 = fadd float %12, %6
  %add4.i.i = fadd float %14, %8
  %add7.i.i = fadd float %16, %10
  %m_collidableIdx = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom5, i32 4
  %17 = load i32, ptr %m_collidableIdx, align 16
  %idxprom14 = sext i32 %17 to i64
  %18 = getelementptr inbounds %struct.b3Collidable, ptr %collidables, i64 %idxprom14, i32 3
  %19 = load i32, ptr %18, align 4
  %idxprom16 = sext i32 %19 to i64
  %m_numFaces = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexShapes, i64 %idxprom16, i32 6
  %20 = load i32, ptr %m_numFaces, align 8
  %invariant.gep = getelementptr i32, ptr %convexIndices, i64 -1
  %cmp193 = icmp slt i32 %20, 1
  br i1 %cmp193, label %for.end.thread231, label %for.body.lr.ph

for.end.thread231:                                ; preds = %entry
  %21 = load i32, ptr @_ZZ26computeContactSphereConvexiiiiiPK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataPK9b3Vector3PKiPK9b3GpuFaceP10b3Contact4RiiE9numChecks, align 4
  %inc67238 = add nsw i32 %21, 1
  store i32 %inc67238, ptr @_ZZ26computeContactSphereConvexiiiiiPK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataPK9b3Vector3PKiPK9b3GpuFaceP10b3Contact4RiiE9numChecks, align 4
  br label %if.end105

for.body.lr.ph:                                   ; preds = %entry
  %m_faceOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexShapes, i64 %idxprom16, i32 5
  %22 = load i32, ptr %m_faceOffset, align 4
  %m_vertexOffset = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %convexShapes, i64 %idxprom16, i32 8
  %mul = fmul float %1, %1
  %23 = sext i32 %22 to i64
  %24 = zext nneg i32 %20 to i64
  %wide.trip.count = zext nneg i32 %20 to i64
  %invariant.gep255 = getelementptr %struct.b3GpuFace, ptr %faces, i64 %23
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ]
  %cmp204 = phi i1 [ false, %for.body.lr.ph ], [ %cmp, %for.inc ]
  %minDist.0203 = phi float [ -1.000000e+06, %for.body.lr.ph ], [ %minDist.1, %for.inc ]
  %localHitNormal.sroa.0.0197 = phi <2 x float> [ undef, %for.body.lr.ph ], [ %localHitNormal.sroa.0.1, %for.inc ]
  %localHitNormal.sroa.5.0196 = phi <2 x float> [ undef, %for.body.lr.ph ], [ %localHitNormal.sroa.5.1, %for.inc ]
  %closestPnt.sroa.0.0195 = phi <2 x float> [ zeroinitializer, %for.body.lr.ph ], [ %closestPnt.sroa.0.1, %for.inc ]
  %closestPnt.sroa.7.0194 = phi <2 x float> [ zeroinitializer, %for.body.lr.ph ], [ %closestPnt.sroa.7.1, %for.inc ]
  %25 = phi <2 x float> [ undef, %for.body.lr.ph ], [ %82, %for.inc ]
  %26 = phi <2 x float> [ undef, %for.body.lr.ph ], [ %83, %for.inc ]
  %gep256 = getelementptr %struct.b3GpuFace, ptr %invariant.gep255, i64 %indvars.iv
  %27 = load <2 x float>, ptr %gep256, align 16
  %face.sroa.5.0.arrayidx24.sroa_idx = getelementptr inbounds i8, ptr %gep256, i64 8
  %28 = load <2 x float>, ptr %face.sroa.5.0.arrayidx24.sroa_idx, align 8
  %face.sroa.8.0.arrayidx24.sroa_idx = getelementptr inbounds i8, ptr %gep256, i64 16
  %face.sroa.8.0.copyload = load i32, ptr %face.sroa.8.0.arrayidx24.sroa_idx, align 16
  %face.sroa.9.0.arrayidx24.sroa_idx = getelementptr inbounds i8, ptr %gep256, i64 20
  %face.sroa.9.0.copyload = load i32, ptr %face.sroa.9.0.arrayidx24.sroa_idx, align 4
  %29 = extractelement <2 x float> %27, i64 1
  %mul5.i.i.i56 = fmul float %add4.i.i, %29
  %30 = extractelement <2 x float> %27, i64 0
  %31 = tail call float @llvm.fmuladd.f32(float %30, float %add.i.i52, float %mul5.i.i.i56)
  %32 = extractelement <2 x float> %28, i64 0
  %33 = tail call noundef float @llvm.fmuladd.f32(float %32, float %add7.i.i, float %31)
  %34 = extractelement <2 x float> %28, i64 1
  %add.i = fadd float %34, %33
  %mul.i.i.i = fmul float %30, %add.i
  %mul2.i.i.i = fmul float %29, %add.i
  %mul4.i.i.i = fmul float %32, %add.i
  %sub.i.i58 = fsub float %add.i.i52, %mul.i.i.i
  %sub4.i.i = fsub float %add4.i.i, %mul2.i.i.i
  %sub7.i.i = fsub float %add7.i.i, %mul4.i.i.i
  %retval.sroa.0.0.vec.insert.i.i.i = insertelement <2 x float> poison, float %sub.i.i58, i64 0
  %retval.sroa.0.4.vec.insert.i.i.i = insertelement <2 x float> %retval.sroa.0.0.vec.insert.i.i.i, float %sub4.i.i, i64 1
  %retval.sroa.3.12.vec.insert.i.i.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %sub7.i.i, i64 0
  %cmp34 = fcmp ogt float %add.i, %1
  br i1 %cmp34, label %for.end.thread, label %if.end

for.end.thread:                                   ; preds = %for.body
  %35 = load i32, ptr @_ZZ26computeContactSphereConvexiiiiiPK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataPK9b3Vector3PKiPK9b3GpuFaceP10b3Contact4RiiE9numChecks, align 4
  %inc67170 = add nsw i32 %35, 1
  store i32 %inc67170, ptr @_ZZ26computeContactSphereConvexiiiiiPK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataPK9b3Vector3PKiPK9b3GpuFaceP10b3Contact4RiiE9numChecks, align 4
  br label %if.end105

if.end:                                           ; preds = %for.body
  %cmp35 = fcmp ogt float %add.i, 0.000000e+00
  br i1 %cmp35, label %if.then36, label %if.else62

if.then36:                                        ; preds = %if.end
  %36 = load i32, ptr %m_vertexOffset, align 16
  %idxprom39 = sext i32 %36 to i64
  %arrayidx40 = getelementptr inbounds %class.b3Vector3, ptr %convexVertices, i64 %idxprom39
  %cmp.i = icmp slt i32 %face.sroa.9.0.copyload, 2
  br i1 %cmp.i, label %if.else, label %if.end.i

if.end.i:                                         ; preds = %if.then36
  %add.i59 = add nsw i32 %face.sroa.9.0.copyload, %face.sroa.8.0.copyload
  %37 = sext i32 %add.i59 to i64
  %gep = getelementptr i32, ptr %invariant.gep, i64 %37
  %38 = load i32, ptr %gep, align 4
  %idxprom5.i = sext i32 %38 to i64
  %arrayidx6.i = getelementptr inbounds %class.b3Vector3, ptr %arrayidx40, i64 %idxprom5.i
  %39 = load <2 x float>, ptr %arrayidx6.i, align 16
  %v0.sroa.0.sroa.3.0.arrayidx6.sroa_idx.i = getelementptr inbounds i8, ptr %arrayidx6.i, i64 8
  %40 = load <2 x float>, ptr %v0.sroa.0.sroa.3.0.arrayidx6.sroa_idx.i, align 8
  %41 = zext nneg i32 %face.sroa.9.0.copyload to i64
  br label %for.body.i

for.cond.i:                                       ; preds = %for.body.i
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %cmp8.not.i = icmp eq i64 %indvars.iv.next.i, %41
  br i1 %cmp8.not.i, label %if.then42, label %for.body.i, !llvm.loop !62

for.body.i:                                       ; preds = %for.cond.i, %if.end.i
  %indvars.iv.i = phi i64 [ 0, %if.end.i ], [ %indvars.iv.next.i, %for.cond.i ]
  %42 = phi <2 x float> [ %39, %if.end.i ], [ %46, %for.cond.i ]
  %43 = phi <2 x float> [ %40, %if.end.i ], [ %47, %for.cond.i ]
  %44 = trunc i64 %indvars.iv.i to i32
  %add10.i = add i32 %face.sroa.8.0.copyload, %44
  %idxprom11.i = zext i32 %add10.i to i64
  %arrayidx12.i = getelementptr inbounds i32, ptr %convexIndices, i64 %idxprom11.i
  %45 = load i32, ptr %arrayidx12.i, align 4
  %idxprom13.i = sext i32 %45 to i64
  %arrayidx14.i = getelementptr inbounds %class.b3Vector3, ptr %arrayidx40, i64 %idxprom13.i
  %46 = load <2 x float>, ptr %arrayidx14.i, align 16
  %vi.sroa.0.sroa.3.0.arrayidx14.sroa_idx.i = getelementptr inbounds i8, ptr %arrayidx14.i, i64 8
  %47 = load <2 x float>, ptr %vi.sroa.0.sroa.3.0.arrayidx14.sroa_idx.i, align 8
  %48 = extractelement <2 x float> %42, i64 0
  %49 = fsub <2 x float> %46, %42
  %sub.i.i60 = extractelement <2 x float> %49, i64 0
  %50 = extractelement <2 x float> %42, i64 1
  %51 = fsub <2 x float> %46, %42
  %sub4.i.i61 = extractelement <2 x float> %51, i64 1
  %52 = extractelement <2 x float> %43, i64 0
  %53 = fsub <2 x float> %47, %43
  %sub7.i.i62 = extractelement <2 x float> %53, i64 0
  %sub.i24.i = fsub float %add.i.i52, %48
  %sub4.i27.i = fsub float %add4.i.i, %50
  %sub7.i30.i = fsub float %add7.i.i, %52
  %54 = fneg float %sub7.i.i62
  %neg.i.i = fmul float %29, %54
  %55 = tail call float @llvm.fmuladd.f32(float %sub4.i.i61, float %32, float %neg.i.i)
  %56 = fneg float %sub.i.i60
  %neg11.i.i = fmul float %32, %56
  %57 = tail call float @llvm.fmuladd.f32(float %sub7.i.i62, float %30, float %neg11.i.i)
  %58 = fneg float %sub4.i.i61
  %neg17.i.i = fmul float %30, %58
  %59 = tail call float @llvm.fmuladd.f32(float %sub.i.i60, float %29, float %neg17.i.i)
  %mul5.i.i.i63 = fmul float %sub4.i27.i, %57
  %60 = tail call float @llvm.fmuladd.f32(float %sub.i24.i, float %55, float %mul5.i.i.i63)
  %61 = tail call noundef float @llvm.fmuladd.f32(float %sub7.i30.i, float %59, float %60)
  %cmp27.i = fcmp ogt float %61, 0.000000e+00
  br i1 %cmp27.i, label %if.then28.i, label %for.cond.i

if.then28.i:                                      ; preds = %for.body.i
  %62 = extractelement <2 x float> %47, i64 0
  %mul5.i.i45.i = fmul float %sub4.i.i61, %sub4.i.i61
  %63 = tail call float @llvm.fmuladd.f32(float %sub.i.i60, float %sub.i.i60, float %mul5.i.i45.i)
  %64 = tail call noundef float @llvm.fmuladd.f32(float %sub7.i.i62, float %sub7.i.i62, float %63)
  %cmp30.i = fcmp une float %64, 0.000000e+00
  br i1 %cmp30.i, label %cond.end.i, label %if.else

cond.end.i:                                       ; preds = %if.then28.i
  %mul5.i.i50.i = fmul float %sub4.i27.i, %sub4.i.i61
  %65 = tail call float @llvm.fmuladd.f32(float %sub.i.i60, float %sub.i24.i, float %mul5.i.i50.i)
  %66 = tail call noundef float @llvm.fmuladd.f32(float %sub7.i.i62, float %sub7.i30.i, float %65)
  %div.i = fdiv float %66, %64
  %cmp32.i = fcmp ugt float %div.i, 0.000000e+00
  br i1 %cmp32.i, label %if.else.i, label %if.else

if.else.i:                                        ; preds = %cond.end.i
  %cmp34.i = fcmp ult float %div.i, 1.000000e+00
  br i1 %cmp34.i, label %if.else36.i, label %if.else

if.else36.i:                                      ; preds = %if.else.i
  %sub37.i = fsub float 1.000000e+00, %div.i
  %67 = insertelement <2 x float> poison, float %div.i, i64 0
  %68 = shufflevector <2 x float> %67, <2 x float> poison, <2 x i32> zeroinitializer
  %69 = fmul <2 x float> %46, %68
  %70 = insertelement <2 x float> poison, float %sub37.i, i64 0
  %71 = shufflevector <2 x float> %70, <2 x float> poison, <2 x i32> zeroinitializer
  %72 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %71, <2 x float> %42, <2 x float> %69)
  %mul50.i = fmul float %62, %div.i
  %73 = tail call float @llvm.fmuladd.f32(float %sub37.i, float %52, float %mul50.i)
  %74 = insertelement <2 x float> %26, float %73, i64 0
  br label %if.else

if.then42:                                        ; preds = %for.cond.i
  %cmp43 = fcmp ogt float %add.i, %minDist.0203
  br i1 %cmp43, label %if.then44, label %for.inc

if.then44:                                        ; preds = %if.then42
  br label %for.inc

if.else:                                          ; preds = %if.then36, %if.else36.i, %cond.end.i, %if.then28.i, %if.else.i
  %75 = phi <2 x float> [ %46, %if.else.i ], [ %42, %if.then28.i ], [ %42, %cond.end.i ], [ %72, %if.else36.i ], [ %25, %if.then36 ]
  %76 = phi <2 x float> [ %47, %if.else.i ], [ %43, %if.then28.i ], [ %43, %cond.end.i ], [ %74, %if.else36.i ], [ %26, %if.then36 ]
  %77 = extractelement <2 x float> %75, i64 0
  %sub.i = fsub float %add.i.i52, %77
  %78 = extractelement <2 x float> %75, i64 1
  %sub4.i = fsub float %add4.i.i, %78
  %79 = extractelement <2 x float> %76, i64 0
  %sub7.i = fsub float %add7.i.i, %79
  %mul5.i.i = fmul float %sub4.i, %sub4.i
  %80 = tail call float @llvm.fmuladd.f32(float %sub.i, float %sub.i, float %mul5.i.i)
  %81 = tail call noundef float @llvm.fmuladd.f32(float %sub7.i, float %sub7.i, float %80)
  %cmp50 = fcmp olt float %81, %mul
  br i1 %cmp50, label %if.then51, label %for.end

if.then51:                                        ; preds = %if.else
  %sqrt = tail call float @llvm.sqrt.f32(float %81)
  %cmp53 = fcmp ogt float %sqrt, %minDist.0203
  br i1 %cmp53, label %if.then54, label %for.inc

if.then54:                                        ; preds = %if.then51
  %div.i67 = fdiv float 1.000000e+00, %sqrt
  %mul.i.i68 = fmul float %sub.i, %div.i67
  %mul2.i.i = fmul float %sub4.i, %div.i67
  %mul4.i.i71 = fmul float %sub7.i, %div.i67
  %retval.sroa.0.0.vec.insert.i.i.i72 = insertelement <2 x float> poison, float %mul.i.i68, i64 0
  %retval.sroa.0.4.vec.insert.i.i.i73 = insertelement <2 x float> %retval.sroa.0.0.vec.insert.i.i.i72, float %mul2.i.i, i64 1
  %retval.sroa.3.12.vec.insert.i.i.i74 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %mul4.i.i71, i64 0
  br label %for.inc

if.else62:                                        ; preds = %if.end
  %cmp63 = fcmp ogt float %add.i, %minDist.0203
  br i1 %cmp63, label %if.then64, label %for.inc

if.then64:                                        ; preds = %if.else62
  br label %for.inc

for.inc:                                          ; preds = %if.then54, %if.then51, %if.then42, %if.then44, %if.then64, %if.else62
  %closestPnt.sroa.7.1 = phi <2 x float> [ %retval.sroa.3.12.vec.insert.i.i.i, %if.then44 ], [ %closestPnt.sroa.7.0194, %if.then42 ], [ %76, %if.then54 ], [ %closestPnt.sroa.7.0194, %if.then51 ], [ %retval.sroa.3.12.vec.insert.i.i.i, %if.then64 ], [ %closestPnt.sroa.7.0194, %if.else62 ]
  %closestPnt.sroa.0.1 = phi <2 x float> [ %retval.sroa.0.4.vec.insert.i.i.i, %if.then44 ], [ %closestPnt.sroa.0.0195, %if.then42 ], [ %75, %if.then54 ], [ %closestPnt.sroa.0.0195, %if.then51 ], [ %retval.sroa.0.4.vec.insert.i.i.i, %if.then64 ], [ %closestPnt.sroa.0.0195, %if.else62 ]
  %localHitNormal.sroa.5.1 = phi <2 x float> [ %28, %if.then44 ], [ %localHitNormal.sroa.5.0196, %if.then42 ], [ %retval.sroa.3.12.vec.insert.i.i.i74, %if.then54 ], [ %localHitNormal.sroa.5.0196, %if.then51 ], [ %28, %if.then64 ], [ %localHitNormal.sroa.5.0196, %if.else62 ]
  %localHitNormal.sroa.0.1 = phi <2 x float> [ %27, %if.then44 ], [ %localHitNormal.sroa.0.0197, %if.then42 ], [ %retval.sroa.0.4.vec.insert.i.i.i73, %if.then54 ], [ %localHitNormal.sroa.0.0197, %if.then51 ], [ %27, %if.then64 ], [ %localHitNormal.sroa.0.0197, %if.else62 ]
  %minDist.1 = phi float [ %add.i, %if.then44 ], [ %minDist.0203, %if.then42 ], [ %sqrt, %if.then54 ], [ %minDist.0203, %if.then51 ], [ %add.i, %if.then64 ], [ %minDist.0203, %if.else62 ]
  %82 = phi <2 x float> [ %25, %if.then44 ], [ %25, %if.then42 ], [ %75, %if.then54 ], [ %75, %if.then51 ], [ %25, %if.then64 ], [ %25, %if.else62 ]
  %83 = phi <2 x float> [ %26, %if.then44 ], [ %26, %if.then42 ], [ %76, %if.then54 ], [ %76, %if.then51 ], [ %26, %if.then64 ], [ %26, %if.else62 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %cmp = icmp uge i64 %indvars.iv.next, %24
  %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond, label %for.end, label %for.body, !llvm.loop !63

for.end:                                          ; preds = %for.inc, %if.else
  %closestPnt.sroa.7.0.lcssa = phi <2 x float> [ %closestPnt.sroa.7.1, %for.inc ], [ %closestPnt.sroa.7.0194, %if.else ]
  %closestPnt.sroa.0.0.lcssa = phi <2 x float> [ %closestPnt.sroa.0.1, %for.inc ], [ %closestPnt.sroa.0.0195, %if.else ]
  %localHitNormal.sroa.5.0.lcssa = phi <2 x float> [ %localHitNormal.sroa.5.1, %for.inc ], [ %localHitNormal.sroa.5.0196, %if.else ]
  %localHitNormal.sroa.0.0.lcssa = phi <2 x float> [ %localHitNormal.sroa.0.1, %for.inc ], [ %localHitNormal.sroa.0.0197, %if.else ]
  %minDist.0.lcssa = phi float [ %minDist.1, %for.inc ], [ %minDist.0203, %if.else ]
  %cmp.lcssa = phi i1 [ %cmp, %for.inc ], [ %cmp204, %if.else ]
  %84 = load i32, ptr @_ZZ26computeContactSphereConvexiiiiiPK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataPK9b3Vector3PKiPK9b3GpuFaceP10b3Contact4RiiE9numChecks, align 4
  %inc67 = add nsw i32 %84, 1
  store i32 %inc67, ptr @_ZZ26computeContactSphereConvexiiiiiPK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataPK9b3Vector3PKiPK9b3GpuFaceP10b3Contact4RiiE9numChecks, align 4
  %cmp69 = fcmp ogt float %minDist.0.lcssa, -1.000000e+04
  %or.cond = select i1 %cmp.lcssa, i1 %cmp69, i1 false
  br i1 %or.cond, label %if.then70, label %if.end105

if.then70:                                        ; preds = %for.end
  %localHitNormal.sroa.0.0.vec.extract = extractelement <2 x float> %localHitNormal.sroa.0.0.lcssa, i64 0
  %localHitNormal.sroa.0.4.vec.extract = extractelement <2 x float> %localHitNormal.sroa.0.0.lcssa, i64 1
  %mul5.i.i76 = fmul float %sub26.i.i, %localHitNormal.sroa.0.4.vec.extract
  %85 = tail call float @llvm.fmuladd.f32(float %sub.i.i, float %localHitNormal.sroa.0.0.vec.extract, float %mul5.i.i76)
  %localHitNormal.sroa.5.8.vec.extract = extractelement <2 x float> %localHitNormal.sroa.5.0.lcssa, i64 0
  %86 = tail call noundef float @llvm.fmuladd.f32(float %add28.i.i, float %localHitNormal.sroa.5.8.vec.extract, float %85)
  %mul5.i7.i = fmul float %sub33.i.i, %localHitNormal.sroa.0.4.vec.extract
  %87 = tail call float @llvm.fmuladd.f32(float %add30.i.i, float %localHitNormal.sroa.0.0.vec.extract, float %mul5.i7.i)
  %88 = tail call noundef float @llvm.fmuladd.f32(float %sub35.i.i, float %localHitNormal.sroa.5.8.vec.extract, float %87)
  %mul5.i13.i = fmul float %add39.i.i, %localHitNormal.sroa.0.4.vec.extract
  %89 = tail call float @llvm.fmuladd.f32(float %sub37.i.i, float %localHitNormal.sroa.0.0.vec.extract, float %mul5.i13.i)
  %90 = tail call noundef float @llvm.fmuladd.f32(float %sub42.i.i, float %localHitNormal.sroa.5.8.vec.extract, float %89)
  %retval.sroa.0.0.vec.insert.i.i79 = insertelement <2 x float> poison, float %86, i64 0
  %retval.sroa.0.4.vec.insert.i.i80 = insertelement <2 x float> %retval.sroa.0.0.vec.insert.i.i79, float %88, i64 1
  %retval.sroa.3.12.vec.insert.i.i81 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %90, i64 0
  %closestPnt.sroa.0.0.vec.extract = extractelement <2 x float> %closestPnt.sroa.0.0.lcssa, i64 0
  %closestPnt.sroa.0.4.vec.extract = extractelement <2 x float> %closestPnt.sroa.0.0.lcssa, i64 1
  %mul5.i.i.i88 = fmul float %sub26.i.i, %closestPnt.sroa.0.4.vec.extract
  %91 = tail call float @llvm.fmuladd.f32(float %closestPnt.sroa.0.0.vec.extract, float %sub.i.i, float %mul5.i.i.i88)
  %closestPnt.sroa.7.8.vec.extract = extractelement <2 x float> %closestPnt.sroa.7.0.lcssa, i64 0
  %92 = tail call noundef float @llvm.fmuladd.f32(float %closestPnt.sroa.7.8.vec.extract, float %add28.i.i, float %91)
  %mul5.i3.i.i92 = fmul float %sub33.i.i, %closestPnt.sroa.0.4.vec.extract
  %93 = tail call float @llvm.fmuladd.f32(float %closestPnt.sroa.0.0.vec.extract, float %add30.i.i, float %mul5.i3.i.i92)
  %94 = tail call noundef float @llvm.fmuladd.f32(float %closestPnt.sroa.7.8.vec.extract, float %sub35.i.i, float %93)
  %add.i.i98 = fadd float %pos.sroa.0.0.copyload, %92
  %add4.i.i100 = fadd float %pos.sroa.2.0.copyload, %94
  %retval.sroa.0.0.vec.insert.i.i2.i103 = insertelement <2 x float> poison, float %add.i.i98, i64 0
  %retval.sroa.0.4.vec.insert.i.i3.i104 = insertelement <2 x float> %retval.sroa.0.0.vec.insert.i.i2.i103, float %add4.i.i100, i64 1
  %sub = fsub float %minDist.0.lcssa, %1
  %cmp78 = fcmp olt float %sub, 0.000000e+00
  br i1 %cmp78, label %if.then79, label %if.end105

if.then79:                                        ; preds = %if.then70
  %95 = load i32, ptr %nGlobalContactsOut, align 4
  %cmp82 = icmp slt i32 %95, %maxContactCapacity
  br i1 %cmp82, label %if.then83, label %if.end105

if.then83:                                        ; preds = %if.then79
  %mul5.i8.i.i95 = fmul float %add39.i.i, %closestPnt.sroa.0.4.vec.extract
  %96 = tail call float @llvm.fmuladd.f32(float %closestPnt.sroa.0.0.vec.extract, float %sub37.i.i, float %mul5.i8.i.i95)
  %97 = tail call noundef float @llvm.fmuladd.f32(float %closestPnt.sroa.7.8.vec.extract, float %sub42.i.i, float %96)
  %add7.i.i102 = fadd float %pos.sroa.3.0.copyload, %97
  %retval.sroa.3.12.vec.insert.i.i4.i105 = insertelement <2 x float> poison, float %add7.i.i102, i64 0
  %pOnB1.sroa.2.12.vec.insert = insertelement <2 x float> %retval.sroa.3.12.vec.insert.i.i4.i105, float %sub, i64 1
  %inc84 = add nsw i32 %95, 1
  store i32 %inc84, ptr %nGlobalContactsOut, align 4
  %idxprom85 = sext i32 %95 to i64
  %arrayidx86 = getelementptr inbounds %struct.b3Contact4, ptr %globalContactsOut, i64 %idxprom85
  %m_worldNormalOnB = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx86, i64 0, i32 1
  store <2 x float> %retval.sroa.0.4.vec.insert.i.i80, ptr %m_worldNormalOnB, align 16
  %normalOnSurfaceB1.sroa.2.0.m_worldNormalOnB.sroa_idx = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx86, i64 0, i32 1, i32 0, i32 0, i64 2
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i81, ptr %normalOnSurfaceB1.sroa.2.0.m_worldNormalOnB.sroa_idx, align 8
  %m_frictionCoeffCmp.i = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx86, i64 0, i32 3
  store i16 -19662, ptr %m_frictionCoeffCmp.i, align 2
  %m_restituitionCoeffCmp.i = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx86, i64 0, i32 2
  store i16 0, ptr %m_restituitionCoeffCmp.i, align 16
  %m_batchIdx = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx86, i64 0, i32 4
  store i32 %pairIndex, ptr %m_batchIdx, align 4
  %m_invMass = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom1, i32 5
  %98 = load float, ptr %m_invMass, align 4
  %cmp89 = fcmp oeq float %98, 0.000000e+00
  %sub90 = sub nsw i32 0, %bodyIndexA
  %cond = select i1 %cmp89, i32 %sub90, i32 %bodyIndexA
  %m_bodyAPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx86, i64 0, i32 5
  store i32 %cond, ptr %m_bodyAPtrAndSignBit, align 8
  %m_invMass93 = getelementptr inbounds %struct.b3RigidBodyData, ptr %rigidBodies, i64 %idxprom5, i32 5
  %99 = load float, ptr %m_invMass93, align 4
  %cmp94 = fcmp oeq float %99, 0.000000e+00
  %sub96 = sub nsw i32 0, %bodyIndexB
  %cond99 = select i1 %cmp94, i32 %sub96, i32 %bodyIndexB
  %m_bodyBPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx86, i64 0, i32 6
  store i32 %cond99, ptr %m_bodyBPtrAndSignBit, align 4
  store <2 x float> %retval.sroa.0.4.vec.insert.i.i3.i104, ptr %arrayidx86, align 16
  %pOnB1.sroa.2.0.arrayidx86.sroa_idx = getelementptr inbounds i8, ptr %arrayidx86, i64 8
  store <2 x float> %pOnB1.sroa.2.12.vec.insert, ptr %pOnB1.sroa.2.0.arrayidx86.sroa_idx, align 8
  %w102 = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx86, i64 0, i32 1, i32 0, i32 0, i64 3
  store float 1.000000e+00, ptr %w102, align 4
  br label %if.end105

if.end105:                                        ; preds = %for.end.thread231, %for.end.thread, %if.then70, %if.then83, %if.then79, %for.end
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local noundef i32 @_Z27computeContactConvexConvex2iiiiiRK20b3AlignedObjectArrayI15b3RigidBodyDataERKS_I12b3CollidableERKS_I22b3ConvexPolyhedronDataERKS_I9b3Vector3ESF_RKS_IiERKS_I9b3GpuFaceERS_I10b3Contact4ERiiRKSO_(i32 noundef %pairIndex, i32 noundef %bodyIndexA, i32 noundef %bodyIndexB, i32 noundef %collidableIndexA, i32 noundef %collidableIndexB, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %rigidBodies, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %collidables, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %convexShapes, ptr noundef nonnull align 8 dereferenceable(25) %convexVertices, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %uniqueEdges, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %convexIndices, ptr nocapture noundef nonnull readonly align 8 dereferenceable(25) %faces, ptr noundef nonnull align 8 dereferenceable(25) %globalContactsOut, ptr nocapture noundef nonnull align 4 dereferenceable(4) %nGlobalContactsOut, i32 noundef %maxContactCapacity, ptr nocapture noundef nonnull readnone align 8 dereferenceable(25) %oldContacts) local_unnamed_addr #8 {
entry:
  %posA = alloca %class.b3Vector3, align 16
  %ornA = alloca %class.b3Quaternion, align 16
  %posB = alloca %class.b3Vector3, align 16
  %ornB = alloca %class.b3Quaternion, align 16
  %hullA = alloca %struct.b3ConvexPolyhedronData, align 16
  %hullB = alloca %struct.b3ConvexPolyhedronData, align 16
  %sepNormalWorldSpace = alloca %class.b3Vector3, align 16
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %rigidBodies, i64 0, i32 5
  %0 = load ptr, ptr %m_data.i, align 8
  %idxprom.i = sext i32 %bodyIndexA to i64
  %arrayidx.i = getelementptr inbounds %struct.b3RigidBodyData, ptr %0, i64 %idxprom.i
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx.i, i64 16, i1 false)
  %m_quat = getelementptr inbounds %struct.b3RigidBodyData, ptr %0, i64 %idxprom.i, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %m_quat, i64 16, i1 false)
  %idxprom.i33 = sext i32 %bodyIndexB to i64
  %arrayidx.i34 = getelementptr inbounds %struct.b3RigidBodyData, ptr %0, i64 %idxprom.i33
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx.i34, i64 16, i1 false)
  %m_quat5 = getelementptr inbounds %struct.b3RigidBodyData, ptr %0, i64 %idxprom.i33, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %m_quat5, i64 16, i1 false)
  %m_data.i38 = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %collidables, i64 0, i32 5
  %1 = load ptr, ptr %m_data.i38, align 8
  %idxprom.i39 = sext i32 %collidableIndexA to i64
  %colA.sroa.1.0.call6.sroa_idx = getelementptr inbounds %struct.b3Collidable, ptr %1, i64 %idxprom.i39, i32 3
  %colA.sroa.1.0.copyload = load i32, ptr %colA.sroa.1.0.call6.sroa_idx, align 4
  %m_data.i41 = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %convexShapes, i64 0, i32 5
  %2 = load ptr, ptr %m_data.i41, align 8
  %idxprom.i42 = sext i32 %colA.sroa.1.0.copyload to i64
  %arrayidx.i43 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %2, i64 %idxprom.i42
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(96) %hullA, ptr noundef nonnull align 16 dereferenceable(96) %arrayidx.i43, i64 96, i1 false)
  %idxprom.i45 = sext i32 %collidableIndexB to i64
  %colB.sroa.1.0.call8.sroa_idx = getelementptr inbounds %struct.b3Collidable, ptr %1, i64 %idxprom.i45, i32 3
  %colB.sroa.1.0.copyload = load i32, ptr %colB.sroa.1.0.call8.sroa_idx, align 4
  %idxprom.i48 = sext i32 %colB.sroa.1.0.copyload to i64
  %arrayidx.i49 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %2, i64 %idxprom.i48
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(96) %hullB, ptr noundef nonnull align 16 dereferenceable(96) %arrayidx.i49, i64 96, i1 false)
  %call10 = call fastcc noundef zeroext i1 @_ZL18findSeparatingAxisRK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_RK20b3AlignedObjectArrayIS2_ESB_RKS8_I9b3GpuFaceERKS8_IiESB_SB_SF_SI_RS2_(ptr noundef nonnull align 16 dereferenceable(96) %hullA, ptr noundef nonnull align 16 dereferenceable(96) %hullB, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 8 dereferenceable(25) %convexVertices, ptr noundef nonnull align 8 dereferenceable(25) %uniqueEdges, ptr noundef nonnull align 8 dereferenceable(25) %faces, ptr noundef nonnull align 8 dereferenceable(25) %convexVertices, ptr noundef nonnull align 8 dereferenceable(25) %uniqueEdges, ptr noundef nonnull align 8 dereferenceable(25) %faces, ptr noundef nonnull align 16 dereferenceable(16) %sepNormalWorldSpace)
  br i1 %call10, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call11 = call noundef i32 @_Z18clipHullHullSingleiiRK9b3Vector3RK12b3QuaternionS1_S4_iiPK20b3AlignedObjectArrayI15b3RigidBodyDataEPS5_I10b3Contact4ERiRKS5_I22b3ConvexPolyhedronDataESH_RKS5_IS_ESK_RKS5_I9b3GpuFaceERKS5_IiESK_SK_SO_SR_RKS5_I12b3CollidableESV_S1_i(i32 noundef %bodyIndexA, i32 noundef %bodyIndexB, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, i32 noundef %collidableIndexA, i32 noundef %collidableIndexB, ptr noundef nonnull %rigidBodies, ptr noundef nonnull %globalContactsOut, ptr noundef nonnull align 4 dereferenceable(4) %nGlobalContactsOut, ptr noundef nonnull align 8 dereferenceable(25) %convexShapes, ptr noundef nonnull align 8 dereferenceable(25) %convexShapes, ptr noundef nonnull align 8 dereferenceable(25) %convexVertices, ptr nonnull align 8 poison, ptr noundef nonnull align 8 dereferenceable(25) %faces, ptr noundef nonnull align 8 dereferenceable(25) %convexIndices, ptr noundef nonnull align 8 dereferenceable(25) %convexVertices, ptr nonnull align 8 poison, ptr noundef nonnull align 8 dereferenceable(25) %faces, ptr noundef nonnull align 8 dereferenceable(25) %convexIndices, ptr noundef nonnull align 8 dereferenceable(25) %collidables, ptr noundef nonnull align 8 dereferenceable(25) %collidables, ptr noundef nonnull align 16 dereferenceable(16) %sepNormalWorldSpace, i32 noundef %maxContactCapacity)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %contactIndex.0 = phi i32 [ %call11, %if.then ], [ -1, %entry ]
  ret i32 %contactIndex.0
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_(ptr noundef nonnull align 8 dereferenceable(864) %this, ptr noundef %pairs, i32 noundef %nPairs, ptr noundef %bodyBuf, ptr noundef %contactOut, ptr noundef nonnull align 4 dereferenceable(4) %nContacts, ptr nocapture noundef readnone %oldContacts, i32 noundef %maxContactCapacity, i32 noundef %compoundPairCapacity, ptr noundef nonnull align 8 dereferenceable(50) %convexData, ptr noundef nonnull align 8 dereferenceable(50) %gpuVertices, ptr noundef nonnull align 8 dereferenceable(50) %gpuUniqueEdges, ptr noundef nonnull align 8 dereferenceable(50) %gpuFaces, ptr noundef nonnull align 8 dereferenceable(50) %gpuIndices, ptr noundef nonnull align 8 dereferenceable(50) %gpuCollidables, ptr noundef nonnull align 8 dereferenceable(50) %gpuChildShapes, ptr noundef nonnull align 8 dereferenceable(50) %clAabbsWorldSpace, ptr nocapture noundef nonnull readonly align 8 dereferenceable(50) %clAabbsLocalSpace, ptr noundef nonnull align 8 dereferenceable(50) %worldVertsB1GPU, ptr noundef nonnull align 8 dereferenceable(50) %clippingFacesOutGPU, ptr noundef nonnull align 8 dereferenceable(50) %worldNormalsAGPU, ptr noundef nonnull align 8 dereferenceable(50) %worldVertsA1GPU, ptr noundef nonnull align 8 dereferenceable(50) %worldVertsB2GPU, ptr nocapture noundef nonnull readnone align 1 %bvhDataUnused, ptr noundef %treeNodesGPU, ptr nocapture noundef readonly %subTreesGPU, ptr noundef %bvhInfo, i32 noundef %numObjects, i32 noundef %maxTriConvexPairCapacity, ptr noundef nonnull align 8 dereferenceable(50) %triangleConvexPairsOut, ptr nocapture noundef nonnull readnone align 4 dereferenceable(4) %numTriConvexPairsOut) local_unnamed_addr #5 align 2 personality ptr @__gxx_personality_v0 {
entry:
  %elem.i4459 = alloca i32, align 4
  %gRange.i.i4439 = alloca [3 x i64], align 16
  %lRange.i.i4440 = alloca [3 x i64], align 16
  %elem.i4326 = alloca i32, align 4
  %gRange.i.i4306 = alloca [3 x i64], align 16
  %lRange.i.i4307 = alloca [3 x i64], align 16
  %elem.i4025 = alloca i32, align 4
  %gRange.i.i4003 = alloca [3 x i64], align 16
  %lRange.i.i4004 = alloca [3 x i64], align 16
  %gRange.i.i3868 = alloca [3 x i64], align 16
  %lRange.i.i3869 = alloca [3 x i64], align 16
  %elem.i3553 = alloca i32, align 4
  %gRange.i.i3533 = alloca [3 x i64], align 16
  %lRange.i.i3534 = alloca [3 x i64], align 16
  %elem.i3434 = alloca i32, align 4
  %gRange.i.i2953 = alloca [3 x i64], align 16
  %lRange.i.i2954 = alloca [3 x i64], align 16
  %gRange.i.i2831 = alloca [3 x i64], align 16
  %lRange.i.i2832 = alloca [3 x i64], align 16
  %gRange.i.i2711 = alloca [3 x i64], align 16
  %lRange.i.i2712 = alloca [3 x i64], align 16
  %elem.i2325 = alloca i32, align 4
  %gRange.i.i2305 = alloca [3 x i64], align 16
  %lRange.i.i2306 = alloca [3 x i64], align 16
  %elem.i2219 = alloca i32, align 4
  %gRange.i.i2192 = alloca [3 x i64], align 16
  %lRange.i.i2193 = alloca [3 x i64], align 16
  %elem.i2116 = alloca i32, align 4
  %gRange.i.i2096 = alloca [3 x i64], align 16
  %lRange.i.i2097 = alloca [3 x i64], align 16
  %elem.i1962 = alloca i32, align 4
  %gRange.i.i1942 = alloca [3 x i64], align 16
  %lRange.i.i1943 = alloca [3 x i64], align 16
  %elem.i1833 = alloca i32, align 4
  %Min1.i1486 = alloca float, align 4
  %Max1.i1487 = alloca float, align 4
  %Min1.i = alloca float, align 4
  %Max1.i = alloca float, align 4
  %gRange.i.i1211 = alloca [3 x i64], align 16
  %lRange.i.i1212 = alloca [3 x i64], align 16
  %gRange.i.i1128 = alloca [3 x i64], align 16
  %lRange.i.i1129 = alloca [3 x i64], align 16
  %gRange.i.i1024 = alloca [3 x i64], align 16
  %lRange.i.i1025 = alloca [3 x i64], align 16
  %gRange.i.i912 = alloca [3 x i64], align 16
  %lRange.i.i913 = alloca [3 x i64], align 16
  %elem.i827 = alloca i32, align 4
  %gRange.i.i807 = alloca [3 x i64], align 16
  %lRange.i.i808 = alloca [3 x i64], align 16
  %elem.i711 = alloca i32, align 4
  %elem.i = alloca i32, align 4
  %gRange.i.i = alloca [3 x i64], align 16
  %lRange.i.i = alloca [3 x i64], align 16
  %nPairs.addr = alloca i32, align 4
  %maxContactCapacity.addr = alloca i32, align 4
  %compoundPairCapacity.addr = alloca i32, align 4
  %maxTriConvexPairCapacity.addr = alloca i32, align 4
  %bInfo = alloca [10 x %struct.b3BufferInfoCL], align 16
  %launcher = alloca %class.b3LauncherCL, align 8
  %ref.tmp = alloca i32, align 4
  %ref.tmp87 = alloca i32, align 4
  %numCompoundPairs = alloca i32, align 4
  %numConcavePairs = alloca i32, align 4
  %bInfo107 = alloca [9 x %struct.b3BufferInfoCL], align 16
  %launcher148 = alloca %class.b3LauncherCL, align 8
  %bInfo176 = alloca [12 x %struct.b3BufferInfoCL], align 16
  %launcher229 = alloca %class.b3LauncherCL, align 8
  %numDirections = alloca i32, align 4
  %bInfo245 = alloca [13 x %struct.b3BufferInfoCL], align 16
  %launcher302 = alloca %class.b3LauncherCL, align 8
  %bInfo321 = alloca [9 x %struct.b3BufferInfoCL], align 16
  %launcher363 = alloca %class.b3LauncherCL, align 8
  %numDirections369 = alloca i32, align 4
  %bInfo382 = alloca [11 x %struct.b3BufferInfoCL], align 16
  %launcher430 = alloca %class.b3LauncherCL, align 8
  %hostPairs = alloca %class.b3AlignedObjectArray.66, align 8
  %hostBodyBuf = alloca %class.b3AlignedObjectArray.39, align 8
  %hostCollidables = alloca %class.b3AlignedObjectArray.27, align 8
  %cpuChildShapes = alloca %class.b3AlignedObjectArray.92, align 8
  %hostConvexShapeData = alloca %class.b3AlignedObjectArray.31, align 8
  %hostVertices = alloca %class.b3AlignedObjectArray, align 8
  %hostHasSepAxis = alloca %class.b3AlignedObjectArray.23, align 8
  %hostSepAxis = alloca %class.b3AlignedObjectArray, align 8
  %hostUniqueEdges = alloca %class.b3AlignedObjectArray, align 8
  %hostFaces = alloca %class.b3AlignedObjectArray.19, align 8
  %hostIndices = alloca %class.b3AlignedObjectArray.23, align 8
  %hostContacts = alloca %class.b3AlignedObjectArray.35, align 8
  %ref.tmp490.sroa.0 = alloca %struct.b3Contact4Data, align 16
  %dmin = alloca float, align 4
  %posA = alloca %class.b3Vector3, align 16
  %posB = alloca %class.b3Vector3, align 16
  %ornA = alloca %class.b3Quaternion, align 16
  %ornB = alloca %class.b3Quaternion, align 16
  %DeltaC2 = alloca %class.b3Vector3, align 16
  %sepAxis = alloca %class.b3Vector3, align 16
  %sepAxis2 = alloca %class.b3Vector3, align 16
  %depthOut = alloca float, align 4
  %dirOut = alloca %class.b3Vector3, align 16
  %posOut = alloca %class.b3Vector3, align 16
  %DeltaC2781 = alloca %class.b3Vector3, align 16
  %sepAxis786 = alloca %class.b3Vector3, align 16
  %bInfo893 = alloca [15 x %struct.b3BufferInfoCL], align 16
  %launcher957 = alloca %class.b3LauncherCL, align 8
  %bInfo1112 = alloca [12 x %struct.b3BufferInfoCL], align 16
  %launcher1164 = alloca %class.b3LauncherCL, align 8
  %bInfo1195 = alloca [12 x %struct.b3BufferInfoCL], align 16
  %launcher1248 = alloca %class.b3LauncherCL, align 8
  %vertexFaceCapacity = alloca i32, align 4
  %launcher1279 = alloca %class.b3LauncherCL, align 8
  %hostPairs1324 = alloca %class.b3AlignedObjectArray.66, align 8
  %hostBodyBuf1328 = alloca %class.b3AlignedObjectArray.39, align 8
  %hostCollidables1332 = alloca %class.b3AlignedObjectArray.27, align 8
  %hostAabbsWorldSpace1336 = alloca %class.b3AlignedObjectArray.62, align 8
  %triangleConvexPairsOutHost = alloca %class.b3AlignedObjectArray.66, align 8
  %treeNodesCPU1344 = alloca %class.b3AlignedObjectArray.58, align 8
  %subTreesCPU1348 = alloca %class.b3AlignedObjectArray.47, align 8
  %bvhInfoCPU1352 = alloca %class.b3AlignedObjectArray.43, align 8
  %hostNumConcavePairsOut = alloca i32, align 4
  %ref.tmp1382.sroa.0 = alloca %struct.anon, align 16
  %bInfo1438 = alloca [17 x %struct.b3BufferInfoCL], align 16
  %launcher1511 = alloca %class.b3LauncherCL, align 8
  %bInfo1528 = alloca [17 x %struct.b3BufferInfoCL], align 16
  %launcher1601 = alloca %class.b3LauncherCL, align 8
  %bInfo1619 = alloca [16 x %struct.b3BufferInfoCL], align 16
  %launcher1687 = alloca %class.b3LauncherCL, align 8
  %clippingFacesOutCPU = alloca %class.b3AlignedObjectArray.66, align 8
  %worldVertsA1CPU = alloca %class.b3AlignedObjectArray, align 8
  %worldNormalsACPU = alloca %class.b3AlignedObjectArray, align 8
  %worldVertsB1CPU = alloca %class.b3AlignedObjectArray, align 8
  %concaveHasSeparatingNormalsCPU = alloca %class.b3AlignedObjectArray.23, align 8
  %triangleConvexPairsOutHost1713 = alloca %class.b3AlignedObjectArray.66, align 8
  %hostBodyBuf1718 = alloca %class.b3AlignedObjectArray.39, align 8
  %hostCollidables1722 = alloca %class.b3AlignedObjectArray.27, align 8
  %hostAabbsWorldSpace1726 = alloca %class.b3AlignedObjectArray.62, align 8
  %hostConvexData1730 = alloca %class.b3AlignedObjectArray.31, align 8
  %hostVertices1734 = alloca %class.b3AlignedObjectArray, align 8
  %hostUniqueEdges1738 = alloca %class.b3AlignedObjectArray, align 8
  %hostFaces1742 = alloca %class.b3AlignedObjectArray.19, align 8
  %hostIndices1746 = alloca %class.b3AlignedObjectArray.23, align 8
  %cpuChildShapes1750 = alloca %class.b3AlignedObjectArray.92, align 8
  %concaveSepNormalsHost = alloca %class.b3AlignedObjectArray, align 8
  %ref.tmp1772.sroa.0 = alloca %struct.anon, align 16
  %ref.tmp1777.sroa.0 = alloca [4 x float], align 16
  %ref.tmp1782.sroa.0 = alloca [4 x float], align 16
  %ref.tmp1787.sroa.0 = alloca [4 x float], align 16
  %bInfo1864 = alloca [11 x %struct.b3BufferInfoCL], align 16
  %launcher1910 = alloca %class.b3LauncherCL, align 8
  %clippingFacesOutCPU1952 = alloca %class.b3AlignedObjectArray.66, align 8
  %worldVertsA1CPU1954 = alloca %class.b3AlignedObjectArray, align 8
  %worldNormalsACPU1957 = alloca %class.b3AlignedObjectArray, align 8
  %worldVertsB1CPU1960 = alloca %class.b3AlignedObjectArray, align 8
  %concaveHasSeparatingNormalsCPU1968 = alloca %class.b3AlignedObjectArray.23, align 8
  %concaveSepNormalsHost1973 = alloca %class.b3AlignedObjectArray, align 8
  %worldVertsB2CPU = alloca %class.b3AlignedObjectArray, align 8
  %bInfo2019 = alloca [7 x %struct.b3BufferInfoCL], align 16
  %launcher2051 = alloca %class.b3LauncherCL, align 8
  %debugMode = alloca i32, align 4
  %newContactCapacity = alloca i32, align 4
  %bInfo2075 = alloca [8 x %struct.b3BufferInfoCL], align 16
  %launcher2112 = alloca %class.b3LauncherCL, align 8
  %nGlobalContactsOut2132 = alloca i32, align 4
  %triangleConvexPairsOutHost2133 = alloca %class.b3AlignedObjectArray.66, align 8
  %hostBodyBuf2137 = alloca %class.b3AlignedObjectArray.39, align 8
  %concaveHasSeparatingNormalsCPU2141 = alloca %class.b3AlignedObjectArray.23, align 8
  %concaveSepNormalsHost2146 = alloca %class.b3AlignedObjectArray, align 8
  %hostContacts2151 = alloca %class.b3AlignedObjectArray.35, align 8
  %ref.tmp2158.sroa.0 = alloca %struct.b3Contact4Data, align 16
  %clippingFacesOutCPU2160 = alloca %class.b3AlignedObjectArray.66, align 8
  %worldVertsB2CPU2162 = alloca %class.b3AlignedObjectArray, align 8
  %ref.tmp2192.sroa.0 = alloca %struct.b3Contact4Data, align 16
  %bInfo2803 = alloca [12 x %struct.b3BufferInfoCL], align 16
  %launcher2855 = alloca %class.b3LauncherCL, align 8
  %nCompoundsPairs = alloca i32, align 4
  %bInfo2891 = alloca [13 x %struct.b3BufferInfoCL], align 16
  %launcher2948 = alloca %class.b3LauncherCL, align 8
  store i32 %nPairs, ptr %nPairs.addr, align 4
  store i32 %maxContactCapacity, ptr %maxContactCapacity.addr, align 4
  store i32 %compoundPairCapacity, ptr %compoundPairCapacity.addr, align 4
  store i32 %maxTriConvexPairCapacity, ptr %maxTriConvexPairCapacity.addr, align 4
  %0 = load i32, ptr @_ZL12myframecount, align 4
  %inc = add nsw i32 %0, 1
  store i32 %inc, ptr @_ZL12myframecount, align 4
  %tobool.not = icmp eq i32 %nPairs, 0
  br i1 %tobool.not, label %return, label %if.then3

if.then3:                                         ; preds = %entry
  %1 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %m_commandQueue.i = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 25, i32 5
  %2 = load ptr, ptr %m_commandQueue.i, align 8
  %m_clBuffer.i = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 25, i32 3
  %3 = load ptr, ptr %m_clBuffer.i, align 8
  %call.i = tail call i32 %1(ptr noundef %2, ptr noundef %3, i32 noundef 0, i64 noundef 0, i64 noundef 4, ptr noundef nonnull %nContacts, i32 noundef 0, ptr noundef null, ptr noundef null)
  %4 = load ptr, ptr @__clewFinish, align 8
  %5 = load ptr, ptr %m_commandQueue.i, align 8
  %call6.i = tail call i32 %4(ptr noundef %5)
  tail call void @b3EnterProfileZone(ptr noundef nonnull @.str.27)
  %m_clBuffer.i530 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %pairs, i64 0, i32 3
  %6 = load ptr, ptr %m_clBuffer.i530, align 8
  store ptr %6, ptr %bInfo, align 16
  %m_isReadOnly.i = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo, i64 0, i32 1
  store i8 1, ptr %m_isReadOnly.i, align 8
  %arrayinit.element = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo, i64 1
  %m_clBuffer.i531 = getelementptr inbounds %class.b3OpenCLArray.72, ptr %bodyBuf, i64 0, i32 3
  %7 = load ptr, ptr %m_clBuffer.i531, align 8
  store ptr %7, ptr %arrayinit.element, align 16
  %m_isReadOnly.i532 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo, i64 1, i32 1
  store i8 1, ptr %m_isReadOnly.i532, align 8
  %arrayinit.element8 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo, i64 2
  %m_clBuffer.i533 = getelementptr inbounds %class.b3OpenCLArray.74, ptr %gpuCollidables, i64 0, i32 3
  %8 = load ptr, ptr %m_clBuffer.i533, align 8
  store ptr %8, ptr %arrayinit.element8, align 16
  %m_isReadOnly.i534 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo, i64 2, i32 1
  store i8 1, ptr %m_isReadOnly.i534, align 8
  %arrayinit.element12 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo, i64 3
  %m_clBuffer.i535 = getelementptr inbounds %class.b3OpenCLArray.76, ptr %convexData, i64 0, i32 3
  %9 = load ptr, ptr %m_clBuffer.i535, align 8
  store ptr %9, ptr %arrayinit.element12, align 16
  %m_isReadOnly.i536 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo, i64 3, i32 1
  store i8 1, ptr %m_isReadOnly.i536, align 8
  %arrayinit.element16 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo, i64 4
  %m_clBuffer.i537 = getelementptr inbounds %class.b3OpenCLArray, ptr %gpuVertices, i64 0, i32 3
  %10 = load ptr, ptr %m_clBuffer.i537, align 8
  store ptr %10, ptr %arrayinit.element16, align 16
  %m_isReadOnly.i538 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo, i64 4, i32 1
  store i8 1, ptr %m_isReadOnly.i538, align 8
  %arrayinit.element20 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo, i64 5
  %m_clBuffer.i539 = getelementptr inbounds %class.b3OpenCLArray, ptr %gpuUniqueEdges, i64 0, i32 3
  %11 = load ptr, ptr %m_clBuffer.i539, align 8
  store ptr %11, ptr %arrayinit.element20, align 16
  %m_isReadOnly.i540 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo, i64 5, i32 1
  store i8 1, ptr %m_isReadOnly.i540, align 8
  %arrayinit.element24 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo, i64 6
  %m_clBuffer.i541 = getelementptr inbounds %class.b3OpenCLArray.78, ptr %gpuFaces, i64 0, i32 3
  %12 = load ptr, ptr %m_clBuffer.i541, align 8
  store ptr %12, ptr %arrayinit.element24, align 16
  %m_isReadOnly.i542 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo, i64 6, i32 1
  store i8 1, ptr %m_isReadOnly.i542, align 8
  %arrayinit.element28 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo, i64 7
  %m_clBuffer.i543 = getelementptr inbounds %class.b3OpenCLArray.13, ptr %gpuIndices, i64 0, i32 3
  %13 = load ptr, ptr %m_clBuffer.i543, align 8
  store ptr %13, ptr %arrayinit.element28, align 16
  %m_isReadOnly.i544 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo, i64 7, i32 1
  store i8 1, ptr %m_isReadOnly.i544, align 8
  %arrayinit.element32 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo, i64 8
  %m_clBuffer.i545 = getelementptr inbounds %class.b3OpenCLArray.80, ptr %contactOut, i64 0, i32 3
  %14 = load ptr, ptr %m_clBuffer.i545, align 8
  store ptr %14, ptr %arrayinit.element32, align 16
  %m_isReadOnly.i546 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo, i64 8, i32 1
  store i8 0, ptr %m_isReadOnly.i546, align 8
  %arrayinit.element36 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo, i64 9
  %15 = load ptr, ptr %m_clBuffer.i, align 8
  store ptr %15, ptr %arrayinit.element36, align 16
  %m_isReadOnly.i548 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo, i64 9, i32 1
  store i8 0, ptr %m_isReadOnly.i548, align 8
  %m_queue = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 3
  %16 = load ptr, ptr %m_queue, align 8
  %m_primitiveContactsKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 21
  %17 = load ptr, ptr %m_primitiveContactsKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher, ptr noundef %16, ptr noundef %17, ptr noundef nonnull @.str.39)
          to label %invoke.cont41 unwind label %lpad

invoke.cont41:                                    ; preds = %if.then3
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher, ptr noundef nonnull %bInfo, i32 noundef 10)
          to label %invoke.cont43 unwind label %lpad42

invoke.cont43:                                    ; preds = %invoke.cont41
  %m_enableSerialization.i = getelementptr inbounds %class.b3LauncherCL, ptr %launcher, i64 0, i32 7
  %18 = load i8, ptr %m_enableSerialization.i, align 4
  %19 = and i8 %18, 1
  %tobool.not.i = icmp eq i8 %19, 0
  br i1 %tobool.not.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %invoke.cont43
  %m_idx.i = getelementptr inbounds %class.b3LauncherCL, ptr %launcher, i64 0, i32 3
  %20 = load i32, ptr %m_idx.i, align 8
  %21 = load i32, ptr %nPairs.addr, align 4
  %m_size.i.i.i = getelementptr inbounds %class.b3LauncherCL, ptr %launcher, i64 0, i32 5, i32 2
  %22 = load i32, ptr %m_size.i.i.i, align 4
  %m_capacity.i.i.i = getelementptr inbounds %class.b3LauncherCL, ptr %launcher, i64 0, i32 5, i32 3
  %23 = load i32, ptr %m_capacity.i.i.i, align 8
  %cmp.i.i = icmp eq i32 %22, %23
  br i1 %cmp.i.i, label %if.then.i.i, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i

if.then.i.i:                                      ; preds = %if.then.i
  %tobool.not.i.i.i = icmp eq i32 %22, 0
  %mul.i.i.i = shl nsw i32 %22, 1
  %cond.i.i.i = select i1 %tobool.not.i.i.i, i32 1, i32 %mul.i.i.i
  %cmp.i4492 = icmp slt i32 %22, %cond.i.i.i
  br i1 %cmp.i4492, label %if.then.i4494, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i

if.then.i4494:                                    ; preds = %if.then.i.i
  %tobool.not.i.i4495 = icmp eq i32 %cond.i.i.i, 0
  br i1 %tobool.not.i.i4495, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i: ; preds = %if.then.i4494
  %conv.i.i.i = sext i32 %cond.i.i.i to i64
  %mul.i.i.i4496 = shl nsw i64 %conv.i.i.i, 5
  %call.i.i.i4506 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i4496, i32 noundef 16)
          to label %call.i.i.i.noexc unwind label %lpad42

call.i.i.i.noexc:                                 ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i
  %cmp3.i4497 = icmp eq ptr %call.i.i.i4506, null
  br i1 %cmp3.i4497, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i, label %if.then.split.i

if.then.split.i:                                  ; preds = %call.i.i.i.noexc
  %24 = load i32, ptr %m_size.i.i.i, align 4
  %cmp4.i.i4499 = icmp sgt i32 %24, 0
  br i1 %cmp4.i.i4499, label %for.body.lr.ph.i.i, label %if.end.i4500

for.body.lr.ph.i.i:                               ; preds = %if.then.split.i
  %m_data.i.i4502 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher, i64 0, i32 5, i32 5
  %wide.trip.count.i.i = zext nneg i32 %24 to i64
  br label %for.body.i.i

for.body.i.i:                                     ; preds = %for.body.i.i, %for.body.lr.ph.i.i
  %indvars.iv.i.i = phi i64 [ 0, %for.body.lr.ph.i.i ], [ %indvars.iv.next.i.i, %for.body.i.i ]
  %arrayidx.i.i4503 = getelementptr inbounds %struct.b3KernelArgData, ptr %call.i.i.i4506, i64 %indvars.iv.i.i
  %25 = load ptr, ptr %m_data.i.i4502, align 8
  %arrayidx3.i.i4504 = getelementptr inbounds %struct.b3KernelArgData, ptr %25, i64 %indvars.iv.i.i
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i.i4503, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i.i4504, i64 32, i1 false)
  %indvars.iv.next.i.i = add nuw nsw i64 %indvars.iv.i.i, 1
  %exitcond.not.i.i = icmp eq i64 %indvars.iv.next.i.i, %wide.trip.count.i.i
  br i1 %exitcond.not.i.i, label %if.end.i4500, label %for.body.i.i, !llvm.loop !64

_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i: ; preds = %call.i.i.i.noexc, %if.then.i4494
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc4507 unwind label %lpad42

.noexc4507:                                       ; preds = %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc4508 unwind label %lpad42

.noexc4508:                                       ; preds = %.noexc4507
  store i32 0, ptr %m_size.i.i.i, align 4
  br label %if.end.i4500

if.end.i4500:                                     ; preds = %for.body.i.i, %.noexc4508, %if.then.split.i
  %retval.0.i25.i = phi ptr [ null, %.noexc4508 ], [ %call.i.i.i4506, %if.then.split.i ], [ %call.i.i.i4506, %for.body.i.i ]
  %_Count.addr.0.i = phi i32 [ 0, %.noexc4508 ], [ %cond.i.i.i, %if.then.split.i ], [ %cond.i.i.i, %for.body.i.i ]
  %m_data.i20.i = getelementptr inbounds %class.b3LauncherCL, ptr %launcher, i64 0, i32 5, i32 5
  %26 = load ptr, ptr %m_data.i20.i, align 8
  %tobool.not.i21.i = icmp eq ptr %26, null
  br i1 %tobool.not.i21.i, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i, label %if.then.i22.i

if.then.i22.i:                                    ; preds = %if.end.i4500
  %m_ownsMemory.i.i4501 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher, i64 0, i32 5, i32 6
  %27 = load i8, ptr %m_ownsMemory.i.i4501, align 8
  %28 = and i8 %27, 1
  %tobool2.not.i.i = icmp eq i8 %28, 0
  br i1 %tobool2.not.i.i, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i, label %if.then3.i.i

if.then3.i.i:                                     ; preds = %if.then.i22.i
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %26)
          to label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i unwind label %lpad42

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i: ; preds = %if.then3.i.i, %if.then.i22.i, %if.end.i4500
  %m_ownsMemory.i = getelementptr inbounds %class.b3LauncherCL, ptr %launcher, i64 0, i32 5, i32 6
  store i8 1, ptr %m_ownsMemory.i, align 8
  store ptr %retval.0.i25.i, ptr %m_data.i20.i, align 8
  store i32 %_Count.addr.0.i, ptr %m_capacity.i.i.i, align 8
  %.pre.i.i.pre = load i32, ptr %m_size.i.i.i, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i: ; preds = %if.then.i.i, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i, %if.then.i
  %29 = phi i32 [ %22, %if.then.i ], [ %.pre.i.i.pre, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i ], [ %22, %if.then.i.i ]
  %m_data.i.i = getelementptr inbounds %class.b3LauncherCL, ptr %launcher, i64 0, i32 5, i32 5
  %30 = load ptr, ptr %m_data.i.i, align 8
  %idxprom.i.i = sext i32 %29 to i64
  %arrayidx.i.i = getelementptr inbounds %struct.b3KernelArgData, ptr %30, i64 %idxprom.i.i
  store i32 0, ptr %arrayidx.i.i, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i = getelementptr inbounds i8, ptr %arrayidx.i.i, i64 4
  store i32 %20, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i = getelementptr inbounds i8, ptr %arrayidx.i.i, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i = getelementptr inbounds i8, ptr %arrayidx.i.i, i64 16
  store i32 %21, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i, align 16
  %31 = load i32, ptr %m_size.i.i.i, align 4
  %inc.i.i = add nsw i32 %31, 1
  store i32 %inc.i.i, ptr %m_size.i.i.i, align 4
  %m_serializationSizeInBytes.i = getelementptr inbounds %class.b3LauncherCL, ptr %launcher, i64 0, i32 6
  %32 = load i32, ptr %m_serializationSizeInBytes.i, align 8
  %add.i = add i32 %32, 32
  store i32 %add.i, ptr %m_serializationSizeInBytes.i, align 8
  br label %if.end.i

if.end.i:                                         ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i, %invoke.cont43
  %33 = load ptr, ptr @__clewSetKernelArg, align 8
  %m_kernel.i = getelementptr inbounds %class.b3LauncherCL, ptr %launcher, i64 0, i32 2
  %34 = load ptr, ptr %m_kernel.i, align 8
  %m_idx3.i = getelementptr inbounds %class.b3LauncherCL, ptr %launcher, i64 0, i32 3
  %35 = load i32, ptr %m_idx3.i, align 8
  %inc.i = add nsw i32 %35, 1
  store i32 %inc.i, ptr %m_idx3.i, align 8
  %call.i549550 = invoke i32 %33(ptr noundef %34, i32 noundef %35, i64 noundef 4, ptr noundef nonnull %nPairs.addr)
          to label %invoke.cont44 unwind label %lpad42

invoke.cont44:                                    ; preds = %if.end.i
  %36 = load i8, ptr %m_enableSerialization.i, align 4
  %37 = and i8 %36, 1
  %tobool.not.i552 = icmp eq i8 %37, 0
  br i1 %tobool.not.i552, label %if.end.i568, label %if.then.i553

if.then.i553:                                     ; preds = %invoke.cont44
  %38 = load i32, ptr %m_idx3.i, align 8
  %39 = load i32, ptr %maxContactCapacity.addr, align 4
  %m_size.i.i.i555 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher, i64 0, i32 5, i32 2
  %40 = load i32, ptr %m_size.i.i.i555, align 4
  %m_capacity.i.i.i556 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher, i64 0, i32 5, i32 3
  %41 = load i32, ptr %m_capacity.i.i.i556, align 8
  %cmp.i.i557 = icmp eq i32 %40, %41
  br i1 %cmp.i.i557, label %if.then.i.i573, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i558

if.then.i.i573:                                   ; preds = %if.then.i553
  %tobool.not.i.i.i575 = icmp eq i32 %40, 0
  %mul.i.i.i576 = shl nsw i32 %40, 1
  %cond.i.i.i577 = select i1 %tobool.not.i.i.i575, i32 1, i32 %mul.i.i.i576
  %cmp.i4511 = icmp slt i32 %40, %cond.i.i.i577
  br i1 %cmp.i4511, label %if.then.i4513, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i558

if.then.i4513:                                    ; preds = %if.then.i.i573
  %tobool.not.i.i4514 = icmp eq i32 %cond.i.i.i577, 0
  br i1 %tobool.not.i.i4514, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4542, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4515

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4515: ; preds = %if.then.i4513
  %conv.i.i.i4516 = sext i32 %cond.i.i.i577 to i64
  %mul.i.i.i4517 = shl nsw i64 %conv.i.i.i4516, 5
  %call.i.i.i4545 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i4517, i32 noundef 16)
          to label %call.i.i.i.noexc4544 unwind label %lpad42

call.i.i.i.noexc4544:                             ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4515
  %cmp3.i4518 = icmp eq ptr %call.i.i.i4545, null
  br i1 %cmp3.i4518, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4542, label %if.then.split.i4519

if.then.split.i4519:                              ; preds = %call.i.i.i.noexc4544
  %42 = load i32, ptr %m_size.i.i.i555, align 4
  %cmp4.i.i4521 = icmp sgt i32 %42, 0
  br i1 %cmp4.i.i4521, label %for.body.lr.ph.i.i4533, label %if.end.i4522

for.body.lr.ph.i.i4533:                           ; preds = %if.then.split.i4519
  %m_data.i.i4534 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher, i64 0, i32 5, i32 5
  %wide.trip.count.i.i4535 = zext nneg i32 %42 to i64
  br label %for.body.i.i4536

for.body.i.i4536:                                 ; preds = %for.body.i.i4536, %for.body.lr.ph.i.i4533
  %indvars.iv.i.i4537 = phi i64 [ 0, %for.body.lr.ph.i.i4533 ], [ %indvars.iv.next.i.i4540, %for.body.i.i4536 ]
  %arrayidx.i.i4538 = getelementptr inbounds %struct.b3KernelArgData, ptr %call.i.i.i4545, i64 %indvars.iv.i.i4537
  %43 = load ptr, ptr %m_data.i.i4534, align 8
  %arrayidx3.i.i4539 = getelementptr inbounds %struct.b3KernelArgData, ptr %43, i64 %indvars.iv.i.i4537
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i.i4538, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i.i4539, i64 32, i1 false)
  %indvars.iv.next.i.i4540 = add nuw nsw i64 %indvars.iv.i.i4537, 1
  %exitcond.not.i.i4541 = icmp eq i64 %indvars.iv.next.i.i4540, %wide.trip.count.i.i4535
  br i1 %exitcond.not.i.i4541, label %if.end.i4522, label %for.body.i.i4536, !llvm.loop !64

_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4542: ; preds = %call.i.i.i.noexc4544, %if.then.i4513
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc4546 unwind label %lpad42

.noexc4546:                                       ; preds = %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4542
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc4547 unwind label %lpad42

.noexc4547:                                       ; preds = %.noexc4546
  store i32 0, ptr %m_size.i.i.i555, align 4
  br label %if.end.i4522

if.end.i4522:                                     ; preds = %for.body.i.i4536, %.noexc4547, %if.then.split.i4519
  %retval.0.i25.i4523 = phi ptr [ null, %.noexc4547 ], [ %call.i.i.i4545, %if.then.split.i4519 ], [ %call.i.i.i4545, %for.body.i.i4536 ]
  %_Count.addr.0.i4524 = phi i32 [ 0, %.noexc4547 ], [ %cond.i.i.i577, %if.then.split.i4519 ], [ %cond.i.i.i577, %for.body.i.i4536 ]
  %m_data.i20.i4525 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher, i64 0, i32 5, i32 5
  %44 = load ptr, ptr %m_data.i20.i4525, align 8
  %tobool.not.i21.i4526 = icmp eq ptr %44, null
  br i1 %tobool.not.i21.i4526, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4531, label %if.then.i22.i4527

if.then.i22.i4527:                                ; preds = %if.end.i4522
  %m_ownsMemory.i.i4528 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher, i64 0, i32 5, i32 6
  %45 = load i8, ptr %m_ownsMemory.i.i4528, align 8
  %46 = and i8 %45, 1
  %tobool2.not.i.i4529 = icmp eq i8 %46, 0
  br i1 %tobool2.not.i.i4529, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4531, label %if.then3.i.i4530

if.then3.i.i4530:                                 ; preds = %if.then.i22.i4527
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %44)
          to label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4531 unwind label %lpad42

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4531: ; preds = %if.then3.i.i4530, %if.then.i22.i4527, %if.end.i4522
  %m_ownsMemory.i4532 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher, i64 0, i32 5, i32 6
  store i8 1, ptr %m_ownsMemory.i4532, align 8
  store ptr %retval.0.i25.i4523, ptr %m_data.i20.i4525, align 8
  store i32 %_Count.addr.0.i4524, ptr %m_capacity.i.i.i556, align 8
  %.pre.i.i578.pre = load i32, ptr %m_size.i.i.i555, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i558

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i558: ; preds = %if.then.i.i573, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4531, %if.then.i553
  %47 = phi i32 [ %40, %if.then.i553 ], [ %.pre.i.i578.pre, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4531 ], [ %40, %if.then.i.i573 ]
  %m_data.i.i559 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher, i64 0, i32 5, i32 5
  %48 = load ptr, ptr %m_data.i.i559, align 8
  %idxprom.i.i560 = sext i32 %47 to i64
  %arrayidx.i.i561 = getelementptr inbounds %struct.b3KernelArgData, ptr %48, i64 %idxprom.i.i560
  store i32 0, ptr %arrayidx.i.i561, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i562 = getelementptr inbounds i8, ptr %arrayidx.i.i561, i64 4
  store i32 %38, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i562, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i563 = getelementptr inbounds i8, ptr %arrayidx.i.i561, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i563, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i564 = getelementptr inbounds i8, ptr %arrayidx.i.i561, i64 16
  store i32 %39, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i564, align 16
  %49 = load i32, ptr %m_size.i.i.i555, align 4
  %inc.i.i565 = add nsw i32 %49, 1
  store i32 %inc.i.i565, ptr %m_size.i.i.i555, align 4
  %m_serializationSizeInBytes.i566 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher, i64 0, i32 6
  %50 = load i32, ptr %m_serializationSizeInBytes.i566, align 8
  %add.i567 = add i32 %50, 32
  store i32 %add.i567, ptr %m_serializationSizeInBytes.i566, align 8
  br label %if.end.i568

if.end.i568:                                      ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i558, %invoke.cont44
  %51 = load ptr, ptr @__clewSetKernelArg, align 8
  %52 = load ptr, ptr %m_kernel.i, align 8
  %53 = load i32, ptr %m_idx3.i, align 8
  %inc.i571 = add nsw i32 %53, 1
  store i32 %inc.i571, ptr %m_idx3.i, align 8
  %call.i572580 = invoke i32 %51(ptr noundef %52, i32 noundef %53, i64 noundef 4, ptr noundef nonnull %maxContactCapacity.addr)
          to label %invoke.cont45 unwind label %lpad42

invoke.cont45:                                    ; preds = %if.end.i568
  %54 = load i32, ptr %nPairs.addr, align 4
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %gRange.i.i)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %lRange.i.i)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %gRange.i.i, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %lRange.i.i, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  store i64 64, ptr %lRange.i.i, align 16
  %arrayidx3.i.i = getelementptr inbounds [3 x i64], ptr %lRange.i.i, i64 0, i64 1
  store i64 1, ptr %arrayidx3.i.i, align 8
  %conv5.i.i = sext i32 %54 to i64
  %div.i.i6116 = lshr i64 %conv5.i.i, 6
  %rem.i.i = and i64 %conv5.i.i, 63
  %tobool.not.i.i = icmp ne i64 %rem.i.i, 0
  %conv9.i.i = zext i1 %tobool.not.i.i to i64
  %add.i.i = add nuw nsw i64 %div.i.i6116, %conv9.i.i
  %.sroa.speculated8.i.i = call i64 @llvm.umax.i64(i64 %add.i.i, i64 1)
  %mul.i.i = shl i64 %.sroa.speculated8.i.i, 6
  store i64 %mul.i.i, ptr %gRange.i.i, align 16
  %arrayidx27.i.i = getelementptr inbounds [3 x i64], ptr %gRange.i.i, i64 0, i64 1
  store i64 1, ptr %arrayidx27.i.i, align 8
  %55 = load ptr, ptr @__clewEnqueueNDRangeKernel, align 8
  %m_commandQueue.i.i = getelementptr inbounds %class.b3LauncherCL, ptr %launcher, i64 0, i32 1
  %56 = load ptr, ptr %m_commandQueue.i.i, align 8
  %57 = load ptr, ptr %m_kernel.i, align 8
  %call32.i.i583 = invoke i32 %55(ptr noundef %56, ptr noundef %57, i32 noundef 2, ptr noundef null, ptr noundef nonnull %gRange.i.i, ptr noundef nonnull %lRange.i.i, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call32.i.i.noexc unwind label %lpad42

call32.i.i.noexc:                                 ; preds = %invoke.cont45
  %cmp.not.i.i = icmp eq i32 %call32.i.i583, 0
  br i1 %cmp.not.i.i, label %invoke.cont46, label %if.then.i.i582

if.then.i.i582:                                   ; preds = %call32.i.i.noexc
  %call33.i.i = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.74, i32 noundef %call32.i.i583)
  br label %invoke.cont46

invoke.cont46:                                    ; preds = %if.then.i.i582, %call32.i.i.noexc
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %gRange.i.i)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %lRange.i.i)
  %58 = load ptr, ptr @__clewFinish, align 8
  %59 = load ptr, ptr %m_queue, align 8
  %call49 = invoke i32 %58(ptr noundef %59)
          to label %invoke.cont48 unwind label %lpad42

invoke.cont48:                                    ; preds = %invoke.cont46
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %elem.i)
  %m_capacity.i.i.i584 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 25, i32 2
  %60 = load i64, ptr %m_capacity.i.i.i584, align 8
  %cmp.not.i.i585 = icmp eq i64 %60, 0
  br i1 %cmp.not.i.i585, label %do.body.i.i, label %if.then.i.i586

if.then.i.i586:                                   ; preds = %invoke.cont48
  %61 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %62 = load ptr, ptr %m_commandQueue.i, align 8
  %63 = load ptr, ptr %m_clBuffer.i, align 8
  %call3.i.i588 = invoke i32 %61(ptr noundef %62, ptr noundef %63, i32 noundef 0, i64 noundef 0, i64 noundef 4, ptr noundef nonnull %elem.i, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call3.i.i.noexc unwind label %lpad42

call3.i.i.noexc:                                  ; preds = %if.then.i.i586
  %64 = load ptr, ptr @__clewFinish, align 8
  %65 = load ptr, ptr %m_commandQueue.i, align 8
  %call6.i.i589 = invoke i32 %64(ptr noundef %65)
          to label %call6.i.i.noexc unwind label %lpad42

call6.i.i.noexc:                                  ; preds = %call3.i.i.noexc
  %.pre.i = load i32, ptr %elem.i, align 4
  br label %invoke.cont51

do.body.i.i:                                      ; preds = %invoke.cont48
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 285)
          to label %.noexc590 unwind label %lpad42

.noexc590:                                        ; preds = %do.body.i.i
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.80)
          to label %invoke.cont51 unwind label %lpad42

invoke.cont51:                                    ; preds = %call6.i.i.noexc, %.noexc590
  %66 = phi i32 [ %.pre.i, %call6.i.i.noexc ], [ undef, %.noexc590 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %elem.i)
  store i32 %66, ptr %nContacts, align 4
  %conv = sext i32 %66 to i64
  %m_size.i.i = getelementptr inbounds %class.b3OpenCLArray.80, ptr %contactOut, i64 0, i32 1
  %67 = load i64, ptr %m_size.i.i, align 8
  %cmp3.i = icmp ult i64 %67, %conv
  br i1 %cmp3.i, label %if.end7.i, label %invoke.cont53

if.end7.i:                                        ; preds = %invoke.cont51
  %call5.i592 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI10b3Contact4E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %contactOut, i64 noundef %conv, i1 noundef zeroext true)
          to label %call5.i.noexc unwind label %lpad42

call5.i.noexc:                                    ; preds = %if.end7.i
  %spec.select.i = select i1 %call5.i592, i64 %conv, i64 0
  br label %invoke.cont53

invoke.cont53:                                    ; preds = %call5.i.noexc, %invoke.cont51
  %storemerge.i = phi i64 [ %conv, %invoke.cont51 ], [ %spec.select.i, %call5.i.noexc ]
  store i64 %storemerge.i, ptr %m_size.i.i, align 8
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher) #26
  invoke void @b3LeaveProfileZone()
          to label %_ZN13b3ProfileZoneD2Ev.exit unwind label %terminate.lpad.i

terminate.lpad.i:                                 ; preds = %invoke.cont53
  %68 = landingpad { ptr, i32 }
          catch ptr null
  %69 = extractvalue { ptr, i32 } %68, 0
  call void @__clang_call_terminate(ptr %69) #27
  unreachable

_ZN13b3ProfileZoneD2Ev.exit:                      ; preds = %invoke.cont53
  call void @b3EnterProfileZone(ptr noundef nonnull @.str.40)
  %m_sepNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 26
  %70 = load i32, ptr %nPairs.addr, align 4
  %conv57 = sext i32 %70 to i64
  %m_size.i.i593 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 26, i32 1
  %71 = load i64, ptr %m_size.i.i593, align 8
  %cmp3.i594 = icmp ult i64 %71, %conv57
  br i1 %cmp3.i594, label %if.end7.i597, label %invoke.cont59

if.end7.i597:                                     ; preds = %_ZN13b3ProfileZoneD2Ev.exit
  %call5.i600 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_sepNormals, i64 noundef %conv57, i1 noundef zeroext true)
          to label %call5.i.noexc599 unwind label %lpad58

call5.i.noexc599:                                 ; preds = %if.end7.i597
  %spec.select.i598 = select i1 %call5.i600, i64 %conv57, i64 0
  %.pre = load i32, ptr %nPairs.addr, align 4
  %.pre6237 = sext i32 %.pre to i64
  br label %invoke.cont59

lpad:                                             ; preds = %if.then3
  %72 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup

lpad42:                                           ; preds = %if.then3.i.i4530, %.noexc4546, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4542, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4515, %if.then3.i.i, %.noexc4507, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i, %if.end7.i, %.noexc590, %do.body.i.i, %call3.i.i.noexc, %if.then.i.i586, %invoke.cont45, %if.end.i568, %if.end.i, %invoke.cont46, %invoke.cont41
  %73 = landingpad { ptr, i32 }
          cleanup
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher) #26
  br label %ehcleanup

ehcleanup:                                        ; preds = %lpad42, %lpad
  %.pn = phi { ptr, i32 } [ %73, %lpad42 ], [ %72, %lpad ]
  invoke void @b3LeaveProfileZone()
          to label %eh.resume unwind label %terminate.lpad.i601

terminate.lpad.i601:                              ; preds = %ehcleanup
  %74 = landingpad { ptr, i32 }
          catch ptr null
  %75 = extractvalue { ptr, i32 } %74, 0
  call void @__clang_call_terminate(ptr %75) #27
  unreachable

invoke.cont59:                                    ; preds = %call5.i.noexc599, %_ZN13b3ProfileZoneD2Ev.exit
  %conv61.pre-phi = phi i64 [ %.pre6237, %call5.i.noexc599 ], [ %conv57, %_ZN13b3ProfileZoneD2Ev.exit ]
  %storemerge.i595 = phi i64 [ %spec.select.i598, %call5.i.noexc599 ], [ %conv57, %_ZN13b3ProfileZoneD2Ev.exit ]
  store i64 %storemerge.i595, ptr %m_size.i.i593, align 8
  %m_hasSeparatingNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 28
  %m_size.i.i603 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 28, i32 1
  %76 = load i64, ptr %m_size.i.i603, align 8
  %cmp3.i604 = icmp ult i64 %76, %conv61.pre-phi
  br i1 %cmp3.i604, label %if.end7.i607, label %invoke.cont62

if.end7.i607:                                     ; preds = %invoke.cont59
  %call5.i610 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayIiE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_hasSeparatingNormals, i64 noundef %conv61.pre-phi, i1 noundef zeroext true)
          to label %call5.i.noexc609 unwind label %lpad58

call5.i.noexc609:                                 ; preds = %if.end7.i607
  %spec.select.i608 = select i1 %call5.i610, i64 %conv61.pre-phi, i64 0
  br label %invoke.cont62

invoke.cont62:                                    ; preds = %call5.i.noexc609, %invoke.cont59
  %storemerge.i605 = phi i64 [ %conv61.pre-phi, %invoke.cont59 ], [ %spec.select.i608, %call5.i.noexc609 ]
  store i64 %storemerge.i605, ptr %m_size.i.i603, align 8
  %77 = load i32, ptr %maxTriConvexPairCapacity.addr, align 4
  %m_concaveSepNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 29
  %conv64 = sext i32 %77 to i64
  %m_size.i.i611 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 29, i32 1
  %78 = load i64, ptr %m_size.i.i611, align 8
  %cmp3.i612 = icmp ult i64 %78, %conv64
  br i1 %cmp3.i612, label %if.end7.i615, label %invoke.cont65

if.end7.i615:                                     ; preds = %invoke.cont62
  %call5.i618 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveSepNormals, i64 noundef %conv64, i1 noundef zeroext true)
          to label %call5.i.noexc617 unwind label %lpad58

call5.i.noexc617:                                 ; preds = %if.end7.i615
  %spec.select.i616 = select i1 %call5.i618, i64 %conv64, i64 0
  br label %invoke.cont65

invoke.cont65:                                    ; preds = %call5.i.noexc617, %invoke.cont62
  %storemerge.i613 = phi i64 [ %conv64, %invoke.cont62 ], [ %spec.select.i616, %call5.i.noexc617 ]
  store i64 %storemerge.i613, ptr %m_size.i.i611, align 8
  %m_concaveHasSeparatingNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 30
  %m_size.i.i620 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 30, i32 1
  %79 = load i64, ptr %m_size.i.i620, align 8
  %cmp3.i621 = icmp ult i64 %79, %conv64
  br i1 %cmp3.i621, label %if.end7.i624, label %invoke.cont70

if.end7.i624:                                     ; preds = %invoke.cont65
  %call5.i627 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayIiE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveHasSeparatingNormals, i64 noundef %conv64, i1 noundef zeroext true)
          to label %call5.i.noexc626 unwind label %lpad58

call5.i.noexc626:                                 ; preds = %if.end7.i624
  %spec.select.i625 = select i1 %call5.i627, i64 %conv64, i64 0
  br label %invoke.cont70

invoke.cont70:                                    ; preds = %invoke.cont65, %call5.i.noexc626
  %storemerge.i622 = phi i64 [ %conv64, %invoke.cont65 ], [ %spec.select.i625, %call5.i.noexc626 ]
  store i64 %storemerge.i622, ptr %m_size.i.i620, align 8
  %m_numConcavePairsOut = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 31
  %m_size.i.i629 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 31, i32 1
  store i64 0, ptr %m_size.i.i629, align 8
  store i32 0, ptr %ref.tmp, align 4
  %m_capacity.i.i = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 31, i32 2
  %80 = load i64, ptr %m_capacity.i.i, align 8
  %cmp.i = icmp eq i64 %80, 0
  br i1 %cmp.i, label %if.then.i639, label %if.then.i.i634

if.then.i639:                                     ; preds = %invoke.cont70
  %call5.i643 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayIiE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_numConcavePairsOut, i64 noundef 1, i1 noundef zeroext true)
          to label %if.then.i.i634 unwind label %lpad58

if.then.i.i634:                                   ; preds = %invoke.cont70, %if.then.i639
  %81 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %m_commandQueue.i.i635 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 31, i32 5
  %82 = load ptr, ptr %m_commandQueue.i.i635, align 8
  %m_clBuffer.i.i636 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 31, i32 3
  %83 = load ptr, ptr %m_clBuffer.i.i636, align 8
  %call.i.i644 = invoke i32 %81(ptr noundef %82, ptr noundef %83, i32 noundef 0, i64 noundef 0, i64 noundef 4, ptr noundef nonnull %ref.tmp, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call.i.i.noexc unwind label %lpad58

call.i.i.noexc:                                   ; preds = %if.then.i.i634
  %84 = load ptr, ptr @__clewFinish, align 8
  %85 = load ptr, ptr %m_commandQueue.i.i635, align 8
  %call6.i.i646 = invoke i32 %84(ptr noundef %85)
          to label %invoke.cont73 unwind label %lpad58

invoke.cont73:                                    ; preds = %call.i.i.noexc
  %86 = load i64, ptr %m_size.i.i629, align 8
  %inc.i637 = add i64 %86, 1
  store i64 %inc.i637, ptr %m_size.i.i629, align 8
  %m_gpuCompoundPairs = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 32
  %87 = load i32, ptr %compoundPairCapacity.addr, align 4
  %conv75 = sext i32 %87 to i64
  %m_size.i.i649 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 32, i32 1
  %88 = load i64, ptr %m_size.i.i649, align 8
  %cmp3.i650 = icmp ult i64 %88, %conv75
  br i1 %cmp3.i650, label %if.end7.i653, label %invoke.cont76

if.end7.i653:                                     ; preds = %invoke.cont73
  %call5.i656 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuCompoundPairs, i64 noundef %conv75, i1 noundef zeroext true)
          to label %call5.i.noexc655 unwind label %lpad58

call5.i.noexc655:                                 ; preds = %if.end7.i653
  %spec.select.i654 = select i1 %call5.i656, i64 %conv75, i64 0
  %.pre6172 = load i32, ptr %compoundPairCapacity.addr, align 4
  %.pre6238 = sext i32 %.pre6172 to i64
  br label %invoke.cont76

invoke.cont76:                                    ; preds = %call5.i.noexc655, %invoke.cont73
  %conv78.pre-phi = phi i64 [ %.pre6238, %call5.i.noexc655 ], [ %conv75, %invoke.cont73 ]
  %storemerge.i651 = phi i64 [ %spec.select.i654, %call5.i.noexc655 ], [ %conv75, %invoke.cont73 ]
  store i64 %storemerge.i651, ptr %m_size.i.i649, align 8
  %m_gpuCompoundSepNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 33
  %m_size.i.i657 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 33, i32 1
  %89 = load i64, ptr %m_size.i.i657, align 8
  %cmp3.i658 = icmp ult i64 %89, %conv78.pre-phi
  br i1 %cmp3.i658, label %if.end7.i661, label %invoke.cont79

if.end7.i661:                                     ; preds = %invoke.cont76
  %call5.i664 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuCompoundSepNormals, i64 noundef %conv78.pre-phi, i1 noundef zeroext true)
          to label %call5.i.noexc663 unwind label %lpad58

call5.i.noexc663:                                 ; preds = %if.end7.i661
  %spec.select.i662 = select i1 %call5.i664, i64 %conv78.pre-phi, i64 0
  %.pre6173 = load i32, ptr %compoundPairCapacity.addr, align 4
  %.pre6239 = sext i32 %.pre6173 to i64
  br label %invoke.cont79

invoke.cont79:                                    ; preds = %call5.i.noexc663, %invoke.cont76
  %conv81.pre-phi = phi i64 [ %.pre6239, %call5.i.noexc663 ], [ %conv78.pre-phi, %invoke.cont76 ]
  %storemerge.i659 = phi i64 [ %spec.select.i662, %call5.i.noexc663 ], [ %conv78.pre-phi, %invoke.cont76 ]
  store i64 %storemerge.i659, ptr %m_size.i.i657, align 8
  %m_gpuHasCompoundSepNormals = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 34
  %m_size.i.i666 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 34, i32 1
  %90 = load i64, ptr %m_size.i.i666, align 8
  %cmp3.i667 = icmp ult i64 %90, %conv81.pre-phi
  br i1 %cmp3.i667, label %if.end7.i670, label %invoke.cont84

if.end7.i670:                                     ; preds = %invoke.cont79
  %call5.i673 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayIiE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuHasCompoundSepNormals, i64 noundef %conv81.pre-phi, i1 noundef zeroext true)
          to label %call5.i.noexc672 unwind label %lpad58

call5.i.noexc672:                                 ; preds = %if.end7.i670
  %spec.select.i671 = select i1 %call5.i673, i64 %conv81.pre-phi, i64 0
  br label %invoke.cont84

invoke.cont84:                                    ; preds = %invoke.cont79, %call5.i.noexc672
  %storemerge.i668 = phi i64 [ %conv81.pre-phi, %invoke.cont79 ], [ %spec.select.i671, %call5.i.noexc672 ]
  store i64 %storemerge.i668, ptr %m_size.i.i666, align 8
  %m_size.i.i675 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 35, i32 1
  store i64 0, ptr %m_size.i.i675, align 8
  store i32 0, ptr %ref.tmp87, align 4
  %m_capacity.i.i679 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 35, i32 2
  %91 = load i64, ptr %m_capacity.i.i679, align 8
  %cmp.i680 = icmp eq i64 %91, 0
  br i1 %cmp.i680, label %if.then.i690, label %if.then.i.i684

if.then.i690:                                     ; preds = %invoke.cont84
  %m_numCompoundPairsOut = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 35
  %call5.i695 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayIiE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_numCompoundPairsOut, i64 noundef 1, i1 noundef zeroext true)
          to label %if.then.i.i684 unwind label %lpad58

if.then.i.i684:                                   ; preds = %invoke.cont84, %if.then.i690
  %92 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %m_commandQueue.i.i685 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 35, i32 5
  %93 = load ptr, ptr %m_commandQueue.i.i685, align 8
  %m_clBuffer.i.i686 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 35, i32 3
  %94 = load ptr, ptr %m_clBuffer.i.i686, align 8
  %call.i.i697 = invoke i32 %92(ptr noundef %93, ptr noundef %94, i32 noundef 0, i64 noundef 0, i64 noundef 4, ptr noundef nonnull %ref.tmp87, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call.i.i.noexc696 unwind label %lpad58

call.i.i.noexc696:                                ; preds = %if.then.i.i684
  %95 = load ptr, ptr @__clewFinish, align 8
  %96 = load ptr, ptr %m_commandQueue.i.i685, align 8
  %call6.i.i699 = invoke i32 %95(ptr noundef %96)
          to label %invoke.cont88 unwind label %lpad58

invoke.cont88:                                    ; preds = %call.i.i.noexc696
  %97 = load i64, ptr %m_size.i.i675, align 8
  %inc.i688 = add i64 %97, 1
  store i64 %inc.i688, ptr %m_size.i.i675, align 8
  store i32 0, ptr %numCompoundPairs, align 4
  store i32 0, ptr %numConcavePairs, align 4
  %98 = load ptr, ptr @__clewFinish, align 8
  %99 = load ptr, ptr %m_queue, align 8
  %call92 = invoke i32 %98(ptr noundef %99)
          to label %invoke.cont91 unwind label %lpad58

invoke.cont91:                                    ; preds = %invoke.cont88
  %100 = load i8, ptr @findSeparatingAxisOnGpu, align 1
  %101 = and i8 %100, 1
  %tobool93.not = icmp eq i8 %101, 0
  br i1 %tobool93.not, label %if.else445, label %if.then94

if.then94:                                        ; preds = %invoke.cont91
  %102 = load i32, ptr %nPairs.addr, align 4
  %conv95 = sext i32 %102 to i64
  %m_size.i.i703 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 27, i32 1
  %103 = load i64, ptr %m_size.i.i703, align 8
  %cmp3.i704 = icmp ult i64 %103, %conv95
  br i1 %cmp3.i704, label %if.end7.i707, label %invoke.cont96

if.end7.i707:                                     ; preds = %if.then94
  %m_dmins = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 27
  %call5.i710 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayIfE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_dmins, i64 noundef %conv95, i1 noundef zeroext true)
          to label %call5.i.noexc709 unwind label %lpad58

call5.i.noexc709:                                 ; preds = %if.end7.i707
  %spec.select.i708 = select i1 %call5.i710, i64 %conv95, i64 0
  br label %invoke.cont96

invoke.cont96:                                    ; preds = %call5.i.noexc709, %if.then94
  %storemerge.i705 = phi i64 [ %conv95, %if.then94 ], [ %spec.select.i708, %call5.i.noexc709 ]
  store i64 %storemerge.i705, ptr %m_size.i.i703, align 8
  %104 = load i8, ptr @splitSearchSepAxisConvex, align 1
  %105 = and i8 %104, 1
  %tobool98.not = icmp eq i8 %105, 0
  br i1 %tobool98.not, label %if.else, label %if.then99

if.then99:                                        ; preds = %invoke.cont96
  %106 = load i8, ptr @useMprGpu, align 1
  %107 = and i8 %106, 1
  %tobool100.not = icmp eq i8 %107, 0
  br i1 %tobool100.not, label %if.end173, label %if.then101

if.then101:                                       ; preds = %if.then99
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %elem.i711)
  %108 = load i64, ptr %m_capacity.i.i.i584, align 8
  %cmp.not.i.i713 = icmp eq i64 %108, 0
  br i1 %cmp.not.i.i713, label %do.body.i.i718, label %if.then.i.i714

if.then.i.i714:                                   ; preds = %if.then101
  %109 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %110 = load ptr, ptr %m_commandQueue.i, align 8
  %111 = load ptr, ptr %m_clBuffer.i, align 8
  %call3.i.i720 = invoke i32 %109(ptr noundef %110, ptr noundef %111, i32 noundef 0, i64 noundef 0, i64 noundef 4, ptr noundef nonnull %elem.i711, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call3.i.i.noexc719 unwind label %lpad58

call3.i.i.noexc719:                               ; preds = %if.then.i.i714
  %112 = load ptr, ptr @__clewFinish, align 8
  %113 = load ptr, ptr %m_commandQueue.i, align 8
  %call6.i.i722 = invoke i32 %112(ptr noundef %113)
          to label %call6.i.i.noexc721 unwind label %lpad58

call6.i.i.noexc721:                               ; preds = %call3.i.i.noexc719
  %.pre.i717 = load i32, ptr %elem.i711, align 4
  br label %invoke.cont103

do.body.i.i718:                                   ; preds = %if.then101
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 285)
          to label %.noexc723 unwind label %lpad58

.noexc723:                                        ; preds = %do.body.i.i718
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.80)
          to label %invoke.cont103 unwind label %lpad58

invoke.cont103:                                   ; preds = %call6.i.i.noexc721, %.noexc723
  %114 = phi i32 [ %.pre.i717, %call6.i.i.noexc721 ], [ undef, %.noexc723 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %elem.i711)
  store i32 %114, ptr %nContacts, align 4
  invoke void @b3EnterProfileZone(ptr noundef nonnull @.str.4)
          to label %invoke.cont106 unwind label %lpad58

invoke.cont106:                                   ; preds = %invoke.cont103
  %115 = load ptr, ptr %m_clBuffer.i530, align 8
  store ptr %115, ptr %bInfo107, align 16
  %m_isReadOnly.i728 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo107, i64 0, i32 1
  store i8 1, ptr %m_isReadOnly.i728, align 8
  %arrayinit.element113 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo107, i64 1
  %116 = load ptr, ptr %m_clBuffer.i531, align 8
  store ptr %116, ptr %arrayinit.element113, align 16
  %m_isReadOnly.i730 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo107, i64 1, i32 1
  store i8 1, ptr %m_isReadOnly.i730, align 8
  %arrayinit.element117 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo107, i64 2
  %117 = load ptr, ptr %m_clBuffer.i533, align 8
  store ptr %117, ptr %arrayinit.element117, align 16
  %m_isReadOnly.i732 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo107, i64 2, i32 1
  store i8 1, ptr %m_isReadOnly.i732, align 8
  %arrayinit.element121 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo107, i64 3
  %118 = load ptr, ptr %m_clBuffer.i535, align 8
  store ptr %118, ptr %arrayinit.element121, align 16
  %m_isReadOnly.i734 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo107, i64 3, i32 1
  store i8 1, ptr %m_isReadOnly.i734, align 8
  %arrayinit.element125 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo107, i64 4
  %119 = load ptr, ptr %m_clBuffer.i537, align 8
  store ptr %119, ptr %arrayinit.element125, align 16
  %m_isReadOnly.i736 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo107, i64 4, i32 1
  store i8 1, ptr %m_isReadOnly.i736, align 8
  %arrayinit.element129 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo107, i64 5
  %m_clBuffer.i737 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 26, i32 3
  %120 = load ptr, ptr %m_clBuffer.i737, align 8
  store ptr %120, ptr %arrayinit.element129, align 16
  %m_isReadOnly.i738 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo107, i64 5, i32 1
  store i8 0, ptr %m_isReadOnly.i738, align 8
  %arrayinit.element134 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo107, i64 6
  %m_clBuffer.i739 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 28, i32 3
  %121 = load ptr, ptr %m_clBuffer.i739, align 8
  store ptr %121, ptr %arrayinit.element134, align 16
  %m_isReadOnly.i740 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo107, i64 6, i32 1
  store i8 0, ptr %m_isReadOnly.i740, align 8
  %arrayinit.element139 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo107, i64 7
  %122 = load ptr, ptr %m_clBuffer.i545, align 8
  store ptr %122, ptr %arrayinit.element139, align 16
  %m_isReadOnly.i742 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo107, i64 7, i32 1
  store i8 0, ptr %m_isReadOnly.i742, align 8
  %arrayinit.element143 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo107, i64 8
  %123 = load ptr, ptr %m_clBuffer.i, align 8
  store ptr %123, ptr %arrayinit.element143, align 16
  %m_isReadOnly.i744 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo107, i64 8, i32 1
  store i8 0, ptr %m_isReadOnly.i744, align 8
  %124 = load ptr, ptr %m_queue, align 8
  %m_mprPenetrationKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 5
  %125 = load ptr, ptr %m_mprPenetrationKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher148, ptr noundef %124, ptr noundef %125, ptr noundef nonnull @.str.4)
          to label %invoke.cont150 unwind label %lpad109

invoke.cont150:                                   ; preds = %invoke.cont106
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher148, ptr noundef nonnull %bInfo107, i32 noundef 9)
          to label %invoke.cont153 unwind label %lpad152

invoke.cont153:                                   ; preds = %invoke.cont150
  %m_enableSerialization.i745 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher148, i64 0, i32 7
  %126 = load i8, ptr %m_enableSerialization.i745, align 4
  %127 = and i8 %126, 1
  %tobool.not.i746 = icmp eq i8 %127, 0
  br i1 %tobool.not.i746, label %if.end.i762, label %if.then.i747

if.then.i747:                                     ; preds = %invoke.cont153
  %m_idx.i748 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher148, i64 0, i32 3
  %128 = load i32, ptr %m_idx.i748, align 8
  %129 = load i32, ptr %maxContactCapacity.addr, align 4
  %m_size.i.i.i749 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher148, i64 0, i32 5, i32 2
  %130 = load i32, ptr %m_size.i.i.i749, align 4
  %m_capacity.i.i.i750 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher148, i64 0, i32 5, i32 3
  %131 = load i32, ptr %m_capacity.i.i.i750, align 8
  %cmp.i.i751 = icmp eq i32 %130, %131
  br i1 %cmp.i.i751, label %if.then.i.i767, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i752

if.then.i.i767:                                   ; preds = %if.then.i747
  %m_kernelArguments.i768 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher148, i64 0, i32 5
  %tobool.not.i.i.i769 = icmp eq i32 %130, 0
  %mul.i.i.i770 = shl nsw i32 %130, 1
  %cond.i.i.i771 = select i1 %tobool.not.i.i.i769, i32 1, i32 %mul.i.i.i770
  invoke void @_ZN20b3AlignedObjectArrayI15b3KernelArgDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %m_kernelArguments.i768, i32 noundef %cond.i.i.i771)
          to label %.noexc773 unwind label %lpad152

.noexc773:                                        ; preds = %if.then.i.i767
  %.pre.i.i772 = load i32, ptr %m_size.i.i.i749, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i752

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i752: ; preds = %.noexc773, %if.then.i747
  %132 = phi i32 [ %.pre.i.i772, %.noexc773 ], [ %130, %if.then.i747 ]
  %m_data.i.i753 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher148, i64 0, i32 5, i32 5
  %133 = load ptr, ptr %m_data.i.i753, align 8
  %idxprom.i.i754 = sext i32 %132 to i64
  %arrayidx.i.i755 = getelementptr inbounds %struct.b3KernelArgData, ptr %133, i64 %idxprom.i.i754
  store i32 0, ptr %arrayidx.i.i755, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i756 = getelementptr inbounds i8, ptr %arrayidx.i.i755, i64 4
  store i32 %128, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i756, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i757 = getelementptr inbounds i8, ptr %arrayidx.i.i755, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i757, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i758 = getelementptr inbounds i8, ptr %arrayidx.i.i755, i64 16
  store i32 %129, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i758, align 16
  %134 = load i32, ptr %m_size.i.i.i749, align 4
  %inc.i.i759 = add nsw i32 %134, 1
  store i32 %inc.i.i759, ptr %m_size.i.i.i749, align 4
  %m_serializationSizeInBytes.i760 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher148, i64 0, i32 6
  %135 = load i32, ptr %m_serializationSizeInBytes.i760, align 8
  %add.i761 = add i32 %135, 32
  store i32 %add.i761, ptr %m_serializationSizeInBytes.i760, align 8
  br label %if.end.i762

if.end.i762:                                      ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i752, %invoke.cont153
  %136 = load ptr, ptr @__clewSetKernelArg, align 8
  %m_kernel.i763 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher148, i64 0, i32 2
  %137 = load ptr, ptr %m_kernel.i763, align 8
  %m_idx3.i764 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher148, i64 0, i32 3
  %138 = load i32, ptr %m_idx3.i764, align 8
  %inc.i765 = add nsw i32 %138, 1
  store i32 %inc.i765, ptr %m_idx3.i764, align 8
  %call.i766774 = invoke i32 %136(ptr noundef %137, i32 noundef %138, i64 noundef 4, ptr noundef nonnull %maxContactCapacity.addr)
          to label %invoke.cont154 unwind label %lpad152

invoke.cont154:                                   ; preds = %if.end.i762
  %139 = load i8, ptr %m_enableSerialization.i745, align 4
  %140 = and i8 %139, 1
  %tobool.not.i777 = icmp eq i8 %140, 0
  br i1 %tobool.not.i777, label %if.end.i793, label %if.then.i778

if.then.i778:                                     ; preds = %invoke.cont154
  %141 = load i32, ptr %m_idx3.i764, align 8
  %142 = load i32, ptr %nPairs.addr, align 4
  %m_size.i.i.i780 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher148, i64 0, i32 5, i32 2
  %143 = load i32, ptr %m_size.i.i.i780, align 4
  %m_capacity.i.i.i781 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher148, i64 0, i32 5, i32 3
  %144 = load i32, ptr %m_capacity.i.i.i781, align 8
  %cmp.i.i782 = icmp eq i32 %143, %144
  br i1 %cmp.i.i782, label %if.then.i.i798, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i783

if.then.i.i798:                                   ; preds = %if.then.i778
  %m_kernelArguments.i799 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher148, i64 0, i32 5
  %tobool.not.i.i.i800 = icmp eq i32 %143, 0
  %mul.i.i.i801 = shl nsw i32 %143, 1
  %cond.i.i.i802 = select i1 %tobool.not.i.i.i800, i32 1, i32 %mul.i.i.i801
  invoke void @_ZN20b3AlignedObjectArrayI15b3KernelArgDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %m_kernelArguments.i799, i32 noundef %cond.i.i.i802)
          to label %.noexc804 unwind label %lpad152

.noexc804:                                        ; preds = %if.then.i.i798
  %.pre.i.i803 = load i32, ptr %m_size.i.i.i780, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i783

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i783: ; preds = %.noexc804, %if.then.i778
  %145 = phi i32 [ %.pre.i.i803, %.noexc804 ], [ %143, %if.then.i778 ]
  %m_data.i.i784 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher148, i64 0, i32 5, i32 5
  %146 = load ptr, ptr %m_data.i.i784, align 8
  %idxprom.i.i785 = sext i32 %145 to i64
  %arrayidx.i.i786 = getelementptr inbounds %struct.b3KernelArgData, ptr %146, i64 %idxprom.i.i785
  store i32 0, ptr %arrayidx.i.i786, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i787 = getelementptr inbounds i8, ptr %arrayidx.i.i786, i64 4
  store i32 %141, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i787, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i788 = getelementptr inbounds i8, ptr %arrayidx.i.i786, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i788, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i789 = getelementptr inbounds i8, ptr %arrayidx.i.i786, i64 16
  store i32 %142, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i789, align 16
  %147 = load i32, ptr %m_size.i.i.i780, align 4
  %inc.i.i790 = add nsw i32 %147, 1
  store i32 %inc.i.i790, ptr %m_size.i.i.i780, align 4
  %m_serializationSizeInBytes.i791 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher148, i64 0, i32 6
  %148 = load i32, ptr %m_serializationSizeInBytes.i791, align 8
  %add.i792 = add i32 %148, 32
  store i32 %add.i792, ptr %m_serializationSizeInBytes.i791, align 8
  br label %if.end.i793

if.end.i793:                                      ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i783, %invoke.cont154
  %149 = load ptr, ptr @__clewSetKernelArg, align 8
  %150 = load ptr, ptr %m_kernel.i763, align 8
  %151 = load i32, ptr %m_idx3.i764, align 8
  %inc.i796 = add nsw i32 %151, 1
  store i32 %inc.i796, ptr %m_idx3.i764, align 8
  %call.i797805 = invoke i32 %149(ptr noundef %150, i32 noundef %151, i64 noundef 4, ptr noundef nonnull %nPairs.addr)
          to label %invoke.cont155 unwind label %lpad152

invoke.cont155:                                   ; preds = %if.end.i793
  %152 = load i32, ptr %nPairs.addr, align 4
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %gRange.i.i807)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %lRange.i.i808)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %gRange.i.i807, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %lRange.i.i808, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  store i64 64, ptr %lRange.i.i808, align 16
  %arrayidx3.i.i809 = getelementptr inbounds [3 x i64], ptr %lRange.i.i808, i64 0, i64 1
  store i64 1, ptr %arrayidx3.i.i809, align 8
  %conv5.i.i810 = sext i32 %152 to i64
  %div.i.i8116117 = lshr i64 %conv5.i.i810, 6
  %rem.i.i812 = and i64 %conv5.i.i810, 63
  %tobool.not.i.i813 = icmp ne i64 %rem.i.i812, 0
  %conv9.i.i814 = zext i1 %tobool.not.i.i813 to i64
  %add.i.i815 = add nuw nsw i64 %div.i.i8116117, %conv9.i.i814
  %.sroa.speculated8.i.i816 = call i64 @llvm.umax.i64(i64 %add.i.i815, i64 1)
  %mul.i.i817 = shl i64 %.sroa.speculated8.i.i816, 6
  store i64 %mul.i.i817, ptr %gRange.i.i807, align 16
  %arrayidx27.i.i818 = getelementptr inbounds [3 x i64], ptr %gRange.i.i807, i64 0, i64 1
  store i64 1, ptr %arrayidx27.i.i818, align 8
  %153 = load ptr, ptr @__clewEnqueueNDRangeKernel, align 8
  %m_commandQueue.i.i819 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher148, i64 0, i32 1
  %154 = load ptr, ptr %m_commandQueue.i.i819, align 8
  %155 = load ptr, ptr %m_kernel.i763, align 8
  %call32.i.i825 = invoke i32 %153(ptr noundef %154, ptr noundef %155, i32 noundef 2, ptr noundef null, ptr noundef nonnull %gRange.i.i807, ptr noundef nonnull %lRange.i.i808, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call32.i.i.noexc824 unwind label %lpad152

call32.i.i.noexc824:                              ; preds = %invoke.cont155
  %cmp.not.i.i821 = icmp eq i32 %call32.i.i825, 0
  br i1 %cmp.not.i.i821, label %invoke.cont157, label %if.then.i.i822

if.then.i.i822:                                   ; preds = %call32.i.i.noexc824
  %call33.i.i823 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.74, i32 noundef %call32.i.i825)
  br label %invoke.cont157

invoke.cont157:                                   ; preds = %if.then.i.i822, %call32.i.i.noexc824
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %gRange.i.i807)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %lRange.i.i808)
  %156 = load ptr, ptr @__clewFinish, align 8
  %157 = load ptr, ptr %m_queue, align 8
  %call160 = invoke i32 %156(ptr noundef %157)
          to label %invoke.cont159 unwind label %lpad152

invoke.cont159:                                   ; preds = %invoke.cont157
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %elem.i827)
  %158 = load i64, ptr %m_capacity.i.i.i584, align 8
  %cmp.not.i.i829 = icmp eq i64 %158, 0
  br i1 %cmp.not.i.i829, label %do.body.i.i834, label %if.then.i.i830

if.then.i.i830:                                   ; preds = %invoke.cont159
  %159 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %160 = load ptr, ptr %m_commandQueue.i, align 8
  %161 = load ptr, ptr %m_clBuffer.i, align 8
  %call3.i.i836 = invoke i32 %159(ptr noundef %160, ptr noundef %161, i32 noundef 0, i64 noundef 0, i64 noundef 4, ptr noundef nonnull %elem.i827, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call3.i.i.noexc835 unwind label %lpad152

call3.i.i.noexc835:                               ; preds = %if.then.i.i830
  %162 = load ptr, ptr @__clewFinish, align 8
  %163 = load ptr, ptr %m_commandQueue.i, align 8
  %call6.i.i838 = invoke i32 %162(ptr noundef %163)
          to label %call6.i.i.noexc837 unwind label %lpad152

call6.i.i.noexc837:                               ; preds = %call3.i.i.noexc835
  %.pre.i833 = load i32, ptr %elem.i827, align 4
  br label %invoke.cont162

do.body.i.i834:                                   ; preds = %invoke.cont159
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 285)
          to label %.noexc839 unwind label %lpad152

.noexc839:                                        ; preds = %do.body.i.i834
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.80)
          to label %invoke.cont162 unwind label %lpad152

invoke.cont162:                                   ; preds = %call6.i.i.noexc837, %.noexc839
  %164 = phi i32 [ %.pre.i833, %call6.i.i.noexc837 ], [ undef, %.noexc839 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %elem.i827)
  store i32 %164, ptr %nContacts, align 4
  %conv164 = sext i32 %164 to i64
  %165 = load i64, ptr %m_size.i.i, align 8
  %cmp3.i843 = icmp ult i64 %165, %conv164
  br i1 %cmp3.i843, label %if.end7.i846, label %invoke.cont165

if.end7.i846:                                     ; preds = %invoke.cont162
  %call5.i849 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI10b3Contact4E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %contactOut, i64 noundef %conv164, i1 noundef zeroext true)
          to label %call5.i.noexc848 unwind label %lpad152

call5.i.noexc848:                                 ; preds = %if.end7.i846
  %spec.select.i847 = select i1 %call5.i849, i64 %conv164, i64 0
  br label %invoke.cont165

invoke.cont165:                                   ; preds = %call5.i.noexc848, %invoke.cont162
  %storemerge.i844 = phi i64 [ %conv164, %invoke.cont162 ], [ %spec.select.i847, %call5.i.noexc848 ]
  store i64 %storemerge.i844, ptr %m_size.i.i, align 8
  %166 = load i32, ptr %nContacts, align 4
  %167 = load i32, ptr %maxContactCapacity.addr, align 4
  %cmp = icmp sgt i32 %166, %167
  br i1 %cmp, label %do.body, label %if.end170

do.body:                                          ; preds = %invoke.cont165
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.31, i32 noundef 2853)
          to label %invoke.cont168 unwind label %lpad152

invoke.cont168:                                   ; preds = %do.body
  %168 = load i32, ptr %nContacts, align 4
  %169 = load i32, ptr %maxContactCapacity.addr, align 4
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.41, i32 noundef %168, i32 noundef %169)
          to label %do.end unwind label %lpad152

do.end:                                           ; preds = %invoke.cont168
  %170 = load i32, ptr %maxContactCapacity.addr, align 4
  store i32 %170, ptr %nContacts, align 4
  br label %if.end170

lpad58:                                           ; preds = %if.then2293, %if.end7.i4044, %.noexc4037, %do.body.i.i4032, %call3.i.i.noexc4033, %if.then.i.i4028, %if.then2072, %if.else2016, %if.end7.i3585, %call.i3575.noexc, %if.then1939, %if.then1857, %if.else1616, %_ZN13b3ProfileZoneD2Ev.exit2732, %invoke.cont1434, %if.end7.i2608, %if.end7.i2599, %if.end7.i2590, %if.end7.i2581, %if.end7.i2572, %if.end7.i2564, %if.then1272, %if.then1192, %if.then1109, %if.end7.i2003, %if.end7.i1994, %if.end7.i1985, %invoke.cont887, %.noexc1845, %do.body.i.i1840, %call3.i.i.noexc1841, %if.then.i.i1836, %if.else445, %if.else, %if.then318, %_ZN13b3ProfileZoneD2Ev.exit933, %if.end173, %invoke.cont103, %.noexc723, %do.body.i.i718, %call3.i.i.noexc719, %if.then.i.i714, %if.end7.i707, %call.i.i.noexc696, %if.then.i.i684, %if.then.i690, %if.end7.i670, %if.end7.i661, %if.end7.i653, %call.i.i.noexc, %if.then.i.i634, %if.then.i639, %if.end7.i624, %if.end7.i615, %if.end7.i607, %if.end7.i597, %if.end2067, %invoke.cont1404, %do.body1403, %invoke.cont1091, %do.body1090, %invoke.cont88
  %171 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup2980

lpad109:                                          ; preds = %invoke.cont106
  %172 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup172

lpad152:                                          ; preds = %if.end7.i846, %.noexc839, %do.body.i.i834, %call3.i.i.noexc835, %if.then.i.i830, %invoke.cont155, %if.end.i793, %if.then.i.i798, %if.end.i762, %if.then.i.i767, %invoke.cont168, %do.body, %invoke.cont157, %invoke.cont150
  %173 = landingpad { ptr, i32 }
          cleanup
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher148) #26
  br label %ehcleanup172

if.end170:                                        ; preds = %do.end, %invoke.cont165
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher148) #26
  invoke void @b3LeaveProfileZone()
          to label %if.end173 unwind label %terminate.lpad.i851

terminate.lpad.i851:                              ; preds = %if.end170
  %174 = landingpad { ptr, i32 }
          catch ptr null
  %175 = extractvalue { ptr, i32 } %174, 0
  call void @__clang_call_terminate(ptr %175) #27
  unreachable

ehcleanup172:                                     ; preds = %lpad152, %lpad109
  %.pn460 = phi { ptr, i32 } [ %173, %lpad152 ], [ %172, %lpad109 ]
  invoke void @b3LeaveProfileZone()
          to label %ehcleanup2980 unwind label %terminate.lpad.i853

terminate.lpad.i853:                              ; preds = %ehcleanup172
  %176 = landingpad { ptr, i32 }
          catch ptr null
  %177 = extractvalue { ptr, i32 } %176, 0
  call void @__clang_call_terminate(ptr %177) #27
  unreachable

if.end173:                                        ; preds = %if.end170, %if.then99
  invoke void @b3EnterProfileZone(ptr noundef nonnull @.str.10)
          to label %invoke.cont175 unwind label %lpad58

invoke.cont175:                                   ; preds = %if.end173
  %178 = load ptr, ptr %m_clBuffer.i530, align 8
  store ptr %178, ptr %bInfo176, align 16
  %m_isReadOnly.i858 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo176, i64 0, i32 1
  store i8 1, ptr %m_isReadOnly.i858, align 8
  %arrayinit.element182 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo176, i64 1
  %179 = load ptr, ptr %m_clBuffer.i531, align 8
  store ptr %179, ptr %arrayinit.element182, align 16
  %m_isReadOnly.i860 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo176, i64 1, i32 1
  store i8 1, ptr %m_isReadOnly.i860, align 8
  %arrayinit.element186 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo176, i64 2
  %180 = load ptr, ptr %m_clBuffer.i533, align 8
  store ptr %180, ptr %arrayinit.element186, align 16
  %m_isReadOnly.i862 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo176, i64 2, i32 1
  store i8 1, ptr %m_isReadOnly.i862, align 8
  %arrayinit.element190 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo176, i64 3
  %181 = load ptr, ptr %m_clBuffer.i535, align 8
  store ptr %181, ptr %arrayinit.element190, align 16
  %m_isReadOnly.i864 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo176, i64 3, i32 1
  store i8 1, ptr %m_isReadOnly.i864, align 8
  %arrayinit.element194 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo176, i64 4
  %182 = load ptr, ptr %m_clBuffer.i537, align 8
  store ptr %182, ptr %arrayinit.element194, align 16
  %m_isReadOnly.i866 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo176, i64 4, i32 1
  store i8 1, ptr %m_isReadOnly.i866, align 8
  %arrayinit.element198 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo176, i64 5
  %183 = load ptr, ptr %m_clBuffer.i539, align 8
  store ptr %183, ptr %arrayinit.element198, align 16
  %m_isReadOnly.i868 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo176, i64 5, i32 1
  store i8 1, ptr %m_isReadOnly.i868, align 8
  %arrayinit.element202 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo176, i64 6
  %184 = load ptr, ptr %m_clBuffer.i541, align 8
  store ptr %184, ptr %arrayinit.element202, align 16
  %m_isReadOnly.i870 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo176, i64 6, i32 1
  store i8 1, ptr %m_isReadOnly.i870, align 8
  %arrayinit.element206 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo176, i64 7
  %185 = load ptr, ptr %m_clBuffer.i543, align 8
  store ptr %185, ptr %arrayinit.element206, align 16
  %m_isReadOnly.i872 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo176, i64 7, i32 1
  store i8 1, ptr %m_isReadOnly.i872, align 8
  %arrayinit.element210 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo176, i64 8
  %m_clBuffer.i873 = getelementptr inbounds %class.b3OpenCLArray.90, ptr %clAabbsWorldSpace, i64 0, i32 3
  %186 = load ptr, ptr %m_clBuffer.i873, align 8
  store ptr %186, ptr %arrayinit.element210, align 16
  %m_isReadOnly.i874 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo176, i64 8, i32 1
  store i8 1, ptr %m_isReadOnly.i874, align 8
  %arrayinit.element214 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo176, i64 9
  %m_clBuffer.i875 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 26, i32 3
  %187 = load ptr, ptr %m_clBuffer.i875, align 8
  store ptr %187, ptr %arrayinit.element214, align 16
  %m_isReadOnly.i876 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo176, i64 9, i32 1
  store i8 0, ptr %m_isReadOnly.i876, align 8
  %arrayinit.element219 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo176, i64 10
  %m_clBuffer.i877 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 28, i32 3
  %188 = load ptr, ptr %m_clBuffer.i877, align 8
  store ptr %188, ptr %arrayinit.element219, align 16
  %m_isReadOnly.i878 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo176, i64 10, i32 1
  store i8 0, ptr %m_isReadOnly.i878, align 8
  %arrayinit.element224 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo176, i64 11
  %m_clBuffer.i879 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 27, i32 3
  %189 = load ptr, ptr %m_clBuffer.i879, align 8
  store ptr %189, ptr %arrayinit.element224, align 16
  %m_isReadOnly.i880 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo176, i64 11, i32 1
  store i8 0, ptr %m_isReadOnly.i880, align 8
  %190 = load ptr, ptr %m_queue, align 8
  %m_findSeparatingAxisVertexFaceKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 7
  %191 = load ptr, ptr %m_findSeparatingAxisVertexFaceKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher229, ptr noundef %190, ptr noundef %191, ptr noundef nonnull @.str.10)
          to label %invoke.cont231 unwind label %lpad178

invoke.cont231:                                   ; preds = %invoke.cont175
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher229, ptr noundef nonnull %bInfo176, i32 noundef 12)
          to label %invoke.cont234 unwind label %lpad233

invoke.cont234:                                   ; preds = %invoke.cont231
  %m_enableSerialization.i881 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher229, i64 0, i32 7
  %192 = load i8, ptr %m_enableSerialization.i881, align 4
  %193 = and i8 %192, 1
  %tobool.not.i882 = icmp eq i8 %193, 0
  br i1 %tobool.not.i882, label %if.end.i898, label %if.then.i883

if.then.i883:                                     ; preds = %invoke.cont234
  %m_idx.i884 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher229, i64 0, i32 3
  %194 = load i32, ptr %m_idx.i884, align 8
  %195 = load i32, ptr %nPairs.addr, align 4
  %m_size.i.i.i885 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher229, i64 0, i32 5, i32 2
  %196 = load i32, ptr %m_size.i.i.i885, align 4
  %m_capacity.i.i.i886 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher229, i64 0, i32 5, i32 3
  %197 = load i32, ptr %m_capacity.i.i.i886, align 8
  %cmp.i.i887 = icmp eq i32 %196, %197
  br i1 %cmp.i.i887, label %if.then.i.i903, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i888

if.then.i.i903:                                   ; preds = %if.then.i883
  %tobool.not.i.i.i905 = icmp eq i32 %196, 0
  %mul.i.i.i906 = shl nsw i32 %196, 1
  %cond.i.i.i907 = select i1 %tobool.not.i.i.i905, i32 1, i32 %mul.i.i.i906
  %cmp.i4551 = icmp slt i32 %196, %cond.i.i.i907
  br i1 %cmp.i4551, label %if.then.i4553, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i888

if.then.i4553:                                    ; preds = %if.then.i.i903
  %tobool.not.i.i4554 = icmp eq i32 %cond.i.i.i907, 0
  br i1 %tobool.not.i.i4554, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4582, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4555

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4555: ; preds = %if.then.i4553
  %conv.i.i.i4556 = sext i32 %cond.i.i.i907 to i64
  %mul.i.i.i4557 = shl nsw i64 %conv.i.i.i4556, 5
  %call.i.i.i4585 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i4557, i32 noundef 16)
          to label %call.i.i.i.noexc4584 unwind label %lpad233

call.i.i.i.noexc4584:                             ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4555
  %cmp3.i4558 = icmp eq ptr %call.i.i.i4585, null
  br i1 %cmp3.i4558, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4582, label %if.then.split.i4559

if.then.split.i4559:                              ; preds = %call.i.i.i.noexc4584
  %198 = load i32, ptr %m_size.i.i.i885, align 4
  %cmp4.i.i4561 = icmp sgt i32 %198, 0
  br i1 %cmp4.i.i4561, label %for.body.lr.ph.i.i4573, label %if.end.i4562

for.body.lr.ph.i.i4573:                           ; preds = %if.then.split.i4559
  %m_data.i.i4574 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher229, i64 0, i32 5, i32 5
  %wide.trip.count.i.i4575 = zext nneg i32 %198 to i64
  br label %for.body.i.i4576

for.body.i.i4576:                                 ; preds = %for.body.i.i4576, %for.body.lr.ph.i.i4573
  %indvars.iv.i.i4577 = phi i64 [ 0, %for.body.lr.ph.i.i4573 ], [ %indvars.iv.next.i.i4580, %for.body.i.i4576 ]
  %arrayidx.i.i4578 = getelementptr inbounds %struct.b3KernelArgData, ptr %call.i.i.i4585, i64 %indvars.iv.i.i4577
  %199 = load ptr, ptr %m_data.i.i4574, align 8
  %arrayidx3.i.i4579 = getelementptr inbounds %struct.b3KernelArgData, ptr %199, i64 %indvars.iv.i.i4577
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i.i4578, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i.i4579, i64 32, i1 false)
  %indvars.iv.next.i.i4580 = add nuw nsw i64 %indvars.iv.i.i4577, 1
  %exitcond.not.i.i4581 = icmp eq i64 %indvars.iv.next.i.i4580, %wide.trip.count.i.i4575
  br i1 %exitcond.not.i.i4581, label %if.end.i4562, label %for.body.i.i4576, !llvm.loop !64

_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4582: ; preds = %call.i.i.i.noexc4584, %if.then.i4553
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc4586 unwind label %lpad233

.noexc4586:                                       ; preds = %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4582
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc4587 unwind label %lpad233

.noexc4587:                                       ; preds = %.noexc4586
  store i32 0, ptr %m_size.i.i.i885, align 4
  br label %if.end.i4562

if.end.i4562:                                     ; preds = %for.body.i.i4576, %.noexc4587, %if.then.split.i4559
  %retval.0.i25.i4563 = phi ptr [ null, %.noexc4587 ], [ %call.i.i.i4585, %if.then.split.i4559 ], [ %call.i.i.i4585, %for.body.i.i4576 ]
  %_Count.addr.0.i4564 = phi i32 [ 0, %.noexc4587 ], [ %cond.i.i.i907, %if.then.split.i4559 ], [ %cond.i.i.i907, %for.body.i.i4576 ]
  %m_data.i20.i4565 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher229, i64 0, i32 5, i32 5
  %200 = load ptr, ptr %m_data.i20.i4565, align 8
  %tobool.not.i21.i4566 = icmp eq ptr %200, null
  br i1 %tobool.not.i21.i4566, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4571, label %if.then.i22.i4567

if.then.i22.i4567:                                ; preds = %if.end.i4562
  %m_ownsMemory.i.i4568 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher229, i64 0, i32 5, i32 6
  %201 = load i8, ptr %m_ownsMemory.i.i4568, align 8
  %202 = and i8 %201, 1
  %tobool2.not.i.i4569 = icmp eq i8 %202, 0
  br i1 %tobool2.not.i.i4569, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4571, label %if.then3.i.i4570

if.then3.i.i4570:                                 ; preds = %if.then.i22.i4567
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %200)
          to label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4571 unwind label %lpad233

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4571: ; preds = %if.then3.i.i4570, %if.then.i22.i4567, %if.end.i4562
  %m_ownsMemory.i4572 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher229, i64 0, i32 5, i32 6
  store i8 1, ptr %m_ownsMemory.i4572, align 8
  store ptr %retval.0.i25.i4563, ptr %m_data.i20.i4565, align 8
  store i32 %_Count.addr.0.i4564, ptr %m_capacity.i.i.i886, align 8
  %.pre.i.i908.pre = load i32, ptr %m_size.i.i.i885, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i888

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i888: ; preds = %if.then.i.i903, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4571, %if.then.i883
  %203 = phi i32 [ %196, %if.then.i883 ], [ %.pre.i.i908.pre, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4571 ], [ %196, %if.then.i.i903 ]
  %m_data.i.i889 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher229, i64 0, i32 5, i32 5
  %204 = load ptr, ptr %m_data.i.i889, align 8
  %idxprom.i.i890 = sext i32 %203 to i64
  %arrayidx.i.i891 = getelementptr inbounds %struct.b3KernelArgData, ptr %204, i64 %idxprom.i.i890
  store i32 0, ptr %arrayidx.i.i891, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i892 = getelementptr inbounds i8, ptr %arrayidx.i.i891, i64 4
  store i32 %194, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i892, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i893 = getelementptr inbounds i8, ptr %arrayidx.i.i891, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i893, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i894 = getelementptr inbounds i8, ptr %arrayidx.i.i891, i64 16
  store i32 %195, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i894, align 16
  %205 = load i32, ptr %m_size.i.i.i885, align 4
  %inc.i.i895 = add nsw i32 %205, 1
  store i32 %inc.i.i895, ptr %m_size.i.i.i885, align 4
  %m_serializationSizeInBytes.i896 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher229, i64 0, i32 6
  %206 = load i32, ptr %m_serializationSizeInBytes.i896, align 8
  %add.i897 = add i32 %206, 32
  store i32 %add.i897, ptr %m_serializationSizeInBytes.i896, align 8
  br label %if.end.i898

if.end.i898:                                      ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i888, %invoke.cont234
  %207 = load ptr, ptr @__clewSetKernelArg, align 8
  %m_kernel.i899 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher229, i64 0, i32 2
  %208 = load ptr, ptr %m_kernel.i899, align 8
  %m_idx3.i900 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher229, i64 0, i32 3
  %209 = load i32, ptr %m_idx3.i900, align 8
  %inc.i901 = add nsw i32 %209, 1
  store i32 %inc.i901, ptr %m_idx3.i900, align 8
  %call.i902910 = invoke i32 %207(ptr noundef %208, i32 noundef %209, i64 noundef 4, ptr noundef nonnull %nPairs.addr)
          to label %invoke.cont235 unwind label %lpad233

invoke.cont235:                                   ; preds = %if.end.i898
  %210 = load i32, ptr %nPairs.addr, align 4
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %gRange.i.i912)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %lRange.i.i913)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %gRange.i.i912, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %lRange.i.i913, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  store i64 64, ptr %lRange.i.i913, align 16
  %arrayidx3.i.i914 = getelementptr inbounds [3 x i64], ptr %lRange.i.i913, i64 0, i64 1
  store i64 1, ptr %arrayidx3.i.i914, align 8
  %conv5.i.i915 = sext i32 %210 to i64
  %div.i.i9166118 = lshr i64 %conv5.i.i915, 6
  %rem.i.i917 = and i64 %conv5.i.i915, 63
  %tobool.not.i.i918 = icmp ne i64 %rem.i.i917, 0
  %conv9.i.i919 = zext i1 %tobool.not.i.i918 to i64
  %add.i.i920 = add nuw nsw i64 %div.i.i9166118, %conv9.i.i919
  %.sroa.speculated8.i.i921 = call i64 @llvm.umax.i64(i64 %add.i.i920, i64 1)
  %mul.i.i922 = shl i64 %.sroa.speculated8.i.i921, 6
  store i64 %mul.i.i922, ptr %gRange.i.i912, align 16
  %arrayidx27.i.i923 = getelementptr inbounds [3 x i64], ptr %gRange.i.i912, i64 0, i64 1
  store i64 1, ptr %arrayidx27.i.i923, align 8
  %211 = load ptr, ptr @__clewEnqueueNDRangeKernel, align 8
  %m_commandQueue.i.i924 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher229, i64 0, i32 1
  %212 = load ptr, ptr %m_commandQueue.i.i924, align 8
  %213 = load ptr, ptr %m_kernel.i899, align 8
  %call32.i.i930 = invoke i32 %211(ptr noundef %212, ptr noundef %213, i32 noundef 2, ptr noundef null, ptr noundef nonnull %gRange.i.i912, ptr noundef nonnull %lRange.i.i913, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call32.i.i.noexc929 unwind label %lpad233

call32.i.i.noexc929:                              ; preds = %invoke.cont235
  %cmp.not.i.i926 = icmp eq i32 %call32.i.i930, 0
  br i1 %cmp.not.i.i926, label %invoke.cont237, label %if.then.i.i927

if.then.i.i927:                                   ; preds = %call32.i.i.noexc929
  %call33.i.i928 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.74, i32 noundef %call32.i.i930)
  br label %invoke.cont237

invoke.cont237:                                   ; preds = %if.then.i.i927, %call32.i.i.noexc929
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %gRange.i.i912)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %lRange.i.i913)
  %214 = load ptr, ptr @__clewFinish, align 8
  %215 = load ptr, ptr %m_queue, align 8
  %call240 = invoke i32 %214(ptr noundef %215)
          to label %invoke.cont239 unwind label %lpad233

invoke.cont239:                                   ; preds = %invoke.cont237
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher229) #26
  invoke void @b3LeaveProfileZone()
          to label %_ZN13b3ProfileZoneD2Ev.exit933 unwind label %terminate.lpad.i932

terminate.lpad.i932:                              ; preds = %invoke.cont239
  %216 = landingpad { ptr, i32 }
          catch ptr null
  %217 = extractvalue { ptr, i32 } %216, 0
  call void @__clang_call_terminate(ptr %217) #27
  unreachable

_ZN13b3ProfileZoneD2Ev.exit933:                   ; preds = %invoke.cont239
  store i32 162, ptr %numDirections, align 4
  invoke void @b3EnterProfileZone(ptr noundef nonnull @.str.11)
          to label %invoke.cont244 unwind label %lpad58

invoke.cont244:                                   ; preds = %_ZN13b3ProfileZoneD2Ev.exit933
  %218 = load ptr, ptr %m_clBuffer.i530, align 8
  store ptr %218, ptr %bInfo245, align 16
  %m_isReadOnly.i937 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo245, i64 0, i32 1
  store i8 1, ptr %m_isReadOnly.i937, align 8
  %arrayinit.element251 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo245, i64 1
  %219 = load ptr, ptr %m_clBuffer.i531, align 8
  store ptr %219, ptr %arrayinit.element251, align 16
  %m_isReadOnly.i939 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo245, i64 1, i32 1
  store i8 1, ptr %m_isReadOnly.i939, align 8
  %arrayinit.element255 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo245, i64 2
  %220 = load ptr, ptr %m_clBuffer.i533, align 8
  store ptr %220, ptr %arrayinit.element255, align 16
  %m_isReadOnly.i941 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo245, i64 2, i32 1
  store i8 1, ptr %m_isReadOnly.i941, align 8
  %arrayinit.element259 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo245, i64 3
  %221 = load ptr, ptr %m_clBuffer.i535, align 8
  store ptr %221, ptr %arrayinit.element259, align 16
  %m_isReadOnly.i943 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo245, i64 3, i32 1
  store i8 1, ptr %m_isReadOnly.i943, align 8
  %arrayinit.element263 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo245, i64 4
  %222 = load ptr, ptr %m_clBuffer.i537, align 8
  store ptr %222, ptr %arrayinit.element263, align 16
  %m_isReadOnly.i945 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo245, i64 4, i32 1
  store i8 1, ptr %m_isReadOnly.i945, align 8
  %arrayinit.element267 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo245, i64 5
  %223 = load ptr, ptr %m_clBuffer.i539, align 8
  store ptr %223, ptr %arrayinit.element267, align 16
  %m_isReadOnly.i947 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo245, i64 5, i32 1
  store i8 1, ptr %m_isReadOnly.i947, align 8
  %arrayinit.element271 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo245, i64 6
  %224 = load ptr, ptr %m_clBuffer.i541, align 8
  store ptr %224, ptr %arrayinit.element271, align 16
  %m_isReadOnly.i949 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo245, i64 6, i32 1
  store i8 1, ptr %m_isReadOnly.i949, align 8
  %arrayinit.element275 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo245, i64 7
  %225 = load ptr, ptr %m_clBuffer.i543, align 8
  store ptr %225, ptr %arrayinit.element275, align 16
  %m_isReadOnly.i951 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo245, i64 7, i32 1
  store i8 1, ptr %m_isReadOnly.i951, align 8
  %arrayinit.element279 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo245, i64 8
  %226 = load ptr, ptr %m_clBuffer.i873, align 8
  store ptr %226, ptr %arrayinit.element279, align 16
  %m_isReadOnly.i953 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo245, i64 8, i32 1
  store i8 1, ptr %m_isReadOnly.i953, align 8
  %arrayinit.element283 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo245, i64 9
  %227 = load ptr, ptr %m_clBuffer.i875, align 8
  store ptr %227, ptr %arrayinit.element283, align 16
  %m_isReadOnly.i955 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo245, i64 9, i32 1
  store i8 0, ptr %m_isReadOnly.i955, align 8
  %arrayinit.element288 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo245, i64 10
  %228 = load ptr, ptr %m_clBuffer.i877, align 8
  store ptr %228, ptr %arrayinit.element288, align 16
  %m_isReadOnly.i957 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo245, i64 10, i32 1
  store i8 0, ptr %m_isReadOnly.i957, align 8
  %arrayinit.element293 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo245, i64 11
  %229 = load ptr, ptr %m_clBuffer.i879, align 8
  store ptr %229, ptr %arrayinit.element293, align 16
  %m_isReadOnly.i959 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo245, i64 11, i32 1
  store i8 0, ptr %m_isReadOnly.i959, align 8
  %arrayinit.element298 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo245, i64 12
  %m_clBuffer.i960 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 24, i32 3
  %230 = load ptr, ptr %m_clBuffer.i960, align 8
  store ptr %230, ptr %arrayinit.element298, align 16
  %m_isReadOnly.i961 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo245, i64 12, i32 1
  store i8 1, ptr %m_isReadOnly.i961, align 8
  %231 = load ptr, ptr %m_queue, align 8
  %m_findSeparatingAxisEdgeEdgeKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 8
  %232 = load ptr, ptr %m_findSeparatingAxisEdgeEdgeKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher302, ptr noundef %231, ptr noundef %232, ptr noundef nonnull @.str.11)
          to label %invoke.cont304 unwind label %lpad247

invoke.cont304:                                   ; preds = %invoke.cont244
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher302, ptr noundef nonnull %bInfo245, i32 noundef 13)
          to label %invoke.cont307 unwind label %lpad306

invoke.cont307:                                   ; preds = %invoke.cont304
  %m_enableSerialization.i962 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher302, i64 0, i32 7
  %233 = load i8, ptr %m_enableSerialization.i962, align 4
  %234 = and i8 %233, 1
  %tobool.not.i963 = icmp eq i8 %234, 0
  br i1 %tobool.not.i963, label %if.end.i979, label %if.then.i964

if.then.i964:                                     ; preds = %invoke.cont307
  %m_idx.i965 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher302, i64 0, i32 3
  %235 = load i32, ptr %m_idx.i965, align 8
  %236 = load i32, ptr %numDirections, align 4
  %m_size.i.i.i966 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher302, i64 0, i32 5, i32 2
  %237 = load i32, ptr %m_size.i.i.i966, align 4
  %m_capacity.i.i.i967 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher302, i64 0, i32 5, i32 3
  %238 = load i32, ptr %m_capacity.i.i.i967, align 8
  %cmp.i.i968 = icmp eq i32 %237, %238
  br i1 %cmp.i.i968, label %if.then.i.i984, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i969

if.then.i.i984:                                   ; preds = %if.then.i964
  %tobool.not.i.i.i986 = icmp eq i32 %237, 0
  %mul.i.i.i987 = shl nsw i32 %237, 1
  %cond.i.i.i988 = select i1 %tobool.not.i.i.i986, i32 1, i32 %mul.i.i.i987
  %cmp.i4591 = icmp slt i32 %237, %cond.i.i.i988
  br i1 %cmp.i4591, label %if.then.i4593, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i969

if.then.i4593:                                    ; preds = %if.then.i.i984
  %tobool.not.i.i4594 = icmp eq i32 %cond.i.i.i988, 0
  br i1 %tobool.not.i.i4594, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4622, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4595

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4595: ; preds = %if.then.i4593
  %conv.i.i.i4596 = sext i32 %cond.i.i.i988 to i64
  %mul.i.i.i4597 = shl nsw i64 %conv.i.i.i4596, 5
  %call.i.i.i4625 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i4597, i32 noundef 16)
          to label %call.i.i.i.noexc4624 unwind label %lpad306

call.i.i.i.noexc4624:                             ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4595
  %cmp3.i4598 = icmp eq ptr %call.i.i.i4625, null
  br i1 %cmp3.i4598, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4622, label %if.then.split.i4599

if.then.split.i4599:                              ; preds = %call.i.i.i.noexc4624
  %239 = load i32, ptr %m_size.i.i.i966, align 4
  %cmp4.i.i4601 = icmp sgt i32 %239, 0
  br i1 %cmp4.i.i4601, label %for.body.lr.ph.i.i4613, label %if.end.i4602

for.body.lr.ph.i.i4613:                           ; preds = %if.then.split.i4599
  %m_data.i.i4614 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher302, i64 0, i32 5, i32 5
  %wide.trip.count.i.i4615 = zext nneg i32 %239 to i64
  br label %for.body.i.i4616

for.body.i.i4616:                                 ; preds = %for.body.i.i4616, %for.body.lr.ph.i.i4613
  %indvars.iv.i.i4617 = phi i64 [ 0, %for.body.lr.ph.i.i4613 ], [ %indvars.iv.next.i.i4620, %for.body.i.i4616 ]
  %arrayidx.i.i4618 = getelementptr inbounds %struct.b3KernelArgData, ptr %call.i.i.i4625, i64 %indvars.iv.i.i4617
  %240 = load ptr, ptr %m_data.i.i4614, align 8
  %arrayidx3.i.i4619 = getelementptr inbounds %struct.b3KernelArgData, ptr %240, i64 %indvars.iv.i.i4617
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i.i4618, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i.i4619, i64 32, i1 false)
  %indvars.iv.next.i.i4620 = add nuw nsw i64 %indvars.iv.i.i4617, 1
  %exitcond.not.i.i4621 = icmp eq i64 %indvars.iv.next.i.i4620, %wide.trip.count.i.i4615
  br i1 %exitcond.not.i.i4621, label %if.end.i4602, label %for.body.i.i4616, !llvm.loop !64

_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4622: ; preds = %call.i.i.i.noexc4624, %if.then.i4593
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc4626 unwind label %lpad306

.noexc4626:                                       ; preds = %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4622
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc4627 unwind label %lpad306

.noexc4627:                                       ; preds = %.noexc4626
  store i32 0, ptr %m_size.i.i.i966, align 4
  br label %if.end.i4602

if.end.i4602:                                     ; preds = %for.body.i.i4616, %.noexc4627, %if.then.split.i4599
  %retval.0.i25.i4603 = phi ptr [ null, %.noexc4627 ], [ %call.i.i.i4625, %if.then.split.i4599 ], [ %call.i.i.i4625, %for.body.i.i4616 ]
  %_Count.addr.0.i4604 = phi i32 [ 0, %.noexc4627 ], [ %cond.i.i.i988, %if.then.split.i4599 ], [ %cond.i.i.i988, %for.body.i.i4616 ]
  %m_data.i20.i4605 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher302, i64 0, i32 5, i32 5
  %241 = load ptr, ptr %m_data.i20.i4605, align 8
  %tobool.not.i21.i4606 = icmp eq ptr %241, null
  br i1 %tobool.not.i21.i4606, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4611, label %if.then.i22.i4607

if.then.i22.i4607:                                ; preds = %if.end.i4602
  %m_ownsMemory.i.i4608 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher302, i64 0, i32 5, i32 6
  %242 = load i8, ptr %m_ownsMemory.i.i4608, align 8
  %243 = and i8 %242, 1
  %tobool2.not.i.i4609 = icmp eq i8 %243, 0
  br i1 %tobool2.not.i.i4609, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4611, label %if.then3.i.i4610

if.then3.i.i4610:                                 ; preds = %if.then.i22.i4607
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %241)
          to label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4611 unwind label %lpad306

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4611: ; preds = %if.then3.i.i4610, %if.then.i22.i4607, %if.end.i4602
  %m_ownsMemory.i4612 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher302, i64 0, i32 5, i32 6
  store i8 1, ptr %m_ownsMemory.i4612, align 8
  store ptr %retval.0.i25.i4603, ptr %m_data.i20.i4605, align 8
  store i32 %_Count.addr.0.i4604, ptr %m_capacity.i.i.i967, align 8
  %.pre.i.i989.pre = load i32, ptr %m_size.i.i.i966, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i969

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i969: ; preds = %if.then.i.i984, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4611, %if.then.i964
  %244 = phi i32 [ %237, %if.then.i964 ], [ %.pre.i.i989.pre, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4611 ], [ %237, %if.then.i.i984 ]
  %m_data.i.i970 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher302, i64 0, i32 5, i32 5
  %245 = load ptr, ptr %m_data.i.i970, align 8
  %idxprom.i.i971 = sext i32 %244 to i64
  %arrayidx.i.i972 = getelementptr inbounds %struct.b3KernelArgData, ptr %245, i64 %idxprom.i.i971
  store i32 0, ptr %arrayidx.i.i972, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i973 = getelementptr inbounds i8, ptr %arrayidx.i.i972, i64 4
  store i32 %235, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i973, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i974 = getelementptr inbounds i8, ptr %arrayidx.i.i972, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i974, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i975 = getelementptr inbounds i8, ptr %arrayidx.i.i972, i64 16
  store i32 %236, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i975, align 16
  %246 = load i32, ptr %m_size.i.i.i966, align 4
  %inc.i.i976 = add nsw i32 %246, 1
  store i32 %inc.i.i976, ptr %m_size.i.i.i966, align 4
  %m_serializationSizeInBytes.i977 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher302, i64 0, i32 6
  %247 = load i32, ptr %m_serializationSizeInBytes.i977, align 8
  %add.i978 = add i32 %247, 32
  store i32 %add.i978, ptr %m_serializationSizeInBytes.i977, align 8
  br label %if.end.i979

if.end.i979:                                      ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i969, %invoke.cont307
  %248 = load ptr, ptr @__clewSetKernelArg, align 8
  %m_kernel.i980 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher302, i64 0, i32 2
  %249 = load ptr, ptr %m_kernel.i980, align 8
  %m_idx3.i981 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher302, i64 0, i32 3
  %250 = load i32, ptr %m_idx3.i981, align 8
  %inc.i982 = add nsw i32 %250, 1
  store i32 %inc.i982, ptr %m_idx3.i981, align 8
  %call.i983991 = invoke i32 %248(ptr noundef %249, i32 noundef %250, i64 noundef 4, ptr noundef nonnull %numDirections)
          to label %invoke.cont308 unwind label %lpad306

invoke.cont308:                                   ; preds = %if.end.i979
  %251 = load i8, ptr %m_enableSerialization.i962, align 4
  %252 = and i8 %251, 1
  %tobool.not.i994 = icmp eq i8 %252, 0
  br i1 %tobool.not.i994, label %if.end.i1010, label %if.then.i995

if.then.i995:                                     ; preds = %invoke.cont308
  %253 = load i32, ptr %m_idx3.i981, align 8
  %254 = load i32, ptr %nPairs.addr, align 4
  %m_size.i.i.i997 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher302, i64 0, i32 5, i32 2
  %255 = load i32, ptr %m_size.i.i.i997, align 4
  %m_capacity.i.i.i998 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher302, i64 0, i32 5, i32 3
  %256 = load i32, ptr %m_capacity.i.i.i998, align 8
  %cmp.i.i999 = icmp eq i32 %255, %256
  br i1 %cmp.i.i999, label %if.then.i.i1015, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1000

if.then.i.i1015:                                  ; preds = %if.then.i995
  %tobool.not.i.i.i1017 = icmp eq i32 %255, 0
  %mul.i.i.i1018 = shl nsw i32 %255, 1
  %cond.i.i.i1019 = select i1 %tobool.not.i.i.i1017, i32 1, i32 %mul.i.i.i1018
  %cmp.i4631 = icmp slt i32 %255, %cond.i.i.i1019
  br i1 %cmp.i4631, label %if.then.i4633, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1000

if.then.i4633:                                    ; preds = %if.then.i.i1015
  %tobool.not.i.i4634 = icmp eq i32 %cond.i.i.i1019, 0
  br i1 %tobool.not.i.i4634, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4662, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4635

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4635: ; preds = %if.then.i4633
  %conv.i.i.i4636 = sext i32 %cond.i.i.i1019 to i64
  %mul.i.i.i4637 = shl nsw i64 %conv.i.i.i4636, 5
  %call.i.i.i4665 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i4637, i32 noundef 16)
          to label %call.i.i.i.noexc4664 unwind label %lpad306

call.i.i.i.noexc4664:                             ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4635
  %cmp3.i4638 = icmp eq ptr %call.i.i.i4665, null
  br i1 %cmp3.i4638, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4662, label %if.then.split.i4639

if.then.split.i4639:                              ; preds = %call.i.i.i.noexc4664
  %257 = load i32, ptr %m_size.i.i.i997, align 4
  %cmp4.i.i4641 = icmp sgt i32 %257, 0
  br i1 %cmp4.i.i4641, label %for.body.lr.ph.i.i4653, label %if.end.i4642

for.body.lr.ph.i.i4653:                           ; preds = %if.then.split.i4639
  %m_data.i.i4654 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher302, i64 0, i32 5, i32 5
  %wide.trip.count.i.i4655 = zext nneg i32 %257 to i64
  br label %for.body.i.i4656

for.body.i.i4656:                                 ; preds = %for.body.i.i4656, %for.body.lr.ph.i.i4653
  %indvars.iv.i.i4657 = phi i64 [ 0, %for.body.lr.ph.i.i4653 ], [ %indvars.iv.next.i.i4660, %for.body.i.i4656 ]
  %arrayidx.i.i4658 = getelementptr inbounds %struct.b3KernelArgData, ptr %call.i.i.i4665, i64 %indvars.iv.i.i4657
  %258 = load ptr, ptr %m_data.i.i4654, align 8
  %arrayidx3.i.i4659 = getelementptr inbounds %struct.b3KernelArgData, ptr %258, i64 %indvars.iv.i.i4657
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i.i4658, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i.i4659, i64 32, i1 false)
  %indvars.iv.next.i.i4660 = add nuw nsw i64 %indvars.iv.i.i4657, 1
  %exitcond.not.i.i4661 = icmp eq i64 %indvars.iv.next.i.i4660, %wide.trip.count.i.i4655
  br i1 %exitcond.not.i.i4661, label %if.end.i4642, label %for.body.i.i4656, !llvm.loop !64

_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4662: ; preds = %call.i.i.i.noexc4664, %if.then.i4633
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc4666 unwind label %lpad306

.noexc4666:                                       ; preds = %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4662
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc4667 unwind label %lpad306

.noexc4667:                                       ; preds = %.noexc4666
  store i32 0, ptr %m_size.i.i.i997, align 4
  br label %if.end.i4642

if.end.i4642:                                     ; preds = %for.body.i.i4656, %.noexc4667, %if.then.split.i4639
  %retval.0.i25.i4643 = phi ptr [ null, %.noexc4667 ], [ %call.i.i.i4665, %if.then.split.i4639 ], [ %call.i.i.i4665, %for.body.i.i4656 ]
  %_Count.addr.0.i4644 = phi i32 [ 0, %.noexc4667 ], [ %cond.i.i.i1019, %if.then.split.i4639 ], [ %cond.i.i.i1019, %for.body.i.i4656 ]
  %m_data.i20.i4645 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher302, i64 0, i32 5, i32 5
  %259 = load ptr, ptr %m_data.i20.i4645, align 8
  %tobool.not.i21.i4646 = icmp eq ptr %259, null
  br i1 %tobool.not.i21.i4646, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4651, label %if.then.i22.i4647

if.then.i22.i4647:                                ; preds = %if.end.i4642
  %m_ownsMemory.i.i4648 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher302, i64 0, i32 5, i32 6
  %260 = load i8, ptr %m_ownsMemory.i.i4648, align 8
  %261 = and i8 %260, 1
  %tobool2.not.i.i4649 = icmp eq i8 %261, 0
  br i1 %tobool2.not.i.i4649, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4651, label %if.then3.i.i4650

if.then3.i.i4650:                                 ; preds = %if.then.i22.i4647
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %259)
          to label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4651 unwind label %lpad306

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4651: ; preds = %if.then3.i.i4650, %if.then.i22.i4647, %if.end.i4642
  %m_ownsMemory.i4652 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher302, i64 0, i32 5, i32 6
  store i8 1, ptr %m_ownsMemory.i4652, align 8
  store ptr %retval.0.i25.i4643, ptr %m_data.i20.i4645, align 8
  store i32 %_Count.addr.0.i4644, ptr %m_capacity.i.i.i998, align 8
  %.pre.i.i1020.pre = load i32, ptr %m_size.i.i.i997, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1000

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1000: ; preds = %if.then.i.i1015, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4651, %if.then.i995
  %262 = phi i32 [ %255, %if.then.i995 ], [ %.pre.i.i1020.pre, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4651 ], [ %255, %if.then.i.i1015 ]
  %m_data.i.i1001 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher302, i64 0, i32 5, i32 5
  %263 = load ptr, ptr %m_data.i.i1001, align 8
  %idxprom.i.i1002 = sext i32 %262 to i64
  %arrayidx.i.i1003 = getelementptr inbounds %struct.b3KernelArgData, ptr %263, i64 %idxprom.i.i1002
  store i32 0, ptr %arrayidx.i.i1003, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i1004 = getelementptr inbounds i8, ptr %arrayidx.i.i1003, i64 4
  store i32 %253, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i1004, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i1005 = getelementptr inbounds i8, ptr %arrayidx.i.i1003, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i1005, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i1006 = getelementptr inbounds i8, ptr %arrayidx.i.i1003, i64 16
  store i32 %254, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i1006, align 16
  %264 = load i32, ptr %m_size.i.i.i997, align 4
  %inc.i.i1007 = add nsw i32 %264, 1
  store i32 %inc.i.i1007, ptr %m_size.i.i.i997, align 4
  %m_serializationSizeInBytes.i1008 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher302, i64 0, i32 6
  %265 = load i32, ptr %m_serializationSizeInBytes.i1008, align 8
  %add.i1009 = add i32 %265, 32
  store i32 %add.i1009, ptr %m_serializationSizeInBytes.i1008, align 8
  br label %if.end.i1010

if.end.i1010:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1000, %invoke.cont308
  %266 = load ptr, ptr @__clewSetKernelArg, align 8
  %267 = load ptr, ptr %m_kernel.i980, align 8
  %268 = load i32, ptr %m_idx3.i981, align 8
  %inc.i1013 = add nsw i32 %268, 1
  store i32 %inc.i1013, ptr %m_idx3.i981, align 8
  %call.i10141022 = invoke i32 %266(ptr noundef %267, i32 noundef %268, i64 noundef 4, ptr noundef nonnull %nPairs.addr)
          to label %invoke.cont309 unwind label %lpad306

invoke.cont309:                                   ; preds = %if.end.i1010
  %269 = load i32, ptr %nPairs.addr, align 4
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %gRange.i.i1024)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %lRange.i.i1025)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %gRange.i.i1024, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %lRange.i.i1025, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  store i64 64, ptr %lRange.i.i1025, align 16
  %arrayidx3.i.i1026 = getelementptr inbounds [3 x i64], ptr %lRange.i.i1025, i64 0, i64 1
  store i64 1, ptr %arrayidx3.i.i1026, align 8
  %conv5.i.i1027 = sext i32 %269 to i64
  %div.i.i10286119 = lshr i64 %conv5.i.i1027, 6
  %rem.i.i1029 = and i64 %conv5.i.i1027, 63
  %tobool.not.i.i1030 = icmp ne i64 %rem.i.i1029, 0
  %conv9.i.i1031 = zext i1 %tobool.not.i.i1030 to i64
  %add.i.i1032 = add nuw nsw i64 %div.i.i10286119, %conv9.i.i1031
  %.sroa.speculated8.i.i1033 = call i64 @llvm.umax.i64(i64 %add.i.i1032, i64 1)
  %mul.i.i1034 = shl i64 %.sroa.speculated8.i.i1033, 6
  store i64 %mul.i.i1034, ptr %gRange.i.i1024, align 16
  %arrayidx27.i.i1035 = getelementptr inbounds [3 x i64], ptr %gRange.i.i1024, i64 0, i64 1
  store i64 1, ptr %arrayidx27.i.i1035, align 8
  %270 = load ptr, ptr @__clewEnqueueNDRangeKernel, align 8
  %m_commandQueue.i.i1036 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher302, i64 0, i32 1
  %271 = load ptr, ptr %m_commandQueue.i.i1036, align 8
  %272 = load ptr, ptr %m_kernel.i980, align 8
  %call32.i.i1042 = invoke i32 %270(ptr noundef %271, ptr noundef %272, i32 noundef 2, ptr noundef null, ptr noundef nonnull %gRange.i.i1024, ptr noundef nonnull %lRange.i.i1025, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call32.i.i.noexc1041 unwind label %lpad306

call32.i.i.noexc1041:                             ; preds = %invoke.cont309
  %cmp.not.i.i1038 = icmp eq i32 %call32.i.i1042, 0
  br i1 %cmp.not.i.i1038, label %invoke.cont311, label %if.then.i.i1039

if.then.i.i1039:                                  ; preds = %call32.i.i.noexc1041
  %call33.i.i1040 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.74, i32 noundef %call32.i.i1042)
  br label %invoke.cont311

invoke.cont311:                                   ; preds = %if.then.i.i1039, %call32.i.i.noexc1041
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %gRange.i.i1024)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %lRange.i.i1025)
  %273 = load ptr, ptr @__clewFinish, align 8
  %274 = load ptr, ptr %m_queue, align 8
  %call314 = invoke i32 %273(ptr noundef %274)
          to label %invoke.cont313 unwind label %lpad306

invoke.cont313:                                   ; preds = %invoke.cont311
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher302) #26
  invoke void @b3LeaveProfileZone()
          to label %_ZN13b3ProfileZoneD2Ev.exit1045 unwind label %terminate.lpad.i1044

terminate.lpad.i1044:                             ; preds = %invoke.cont313
  %275 = landingpad { ptr, i32 }
          catch ptr null
  %276 = extractvalue { ptr, i32 } %275, 0
  call void @__clang_call_terminate(ptr %276) #27
  unreachable

_ZN13b3ProfileZoneD2Ev.exit1045:                  ; preds = %invoke.cont313
  %277 = load i8, ptr @useMprGpu, align 1
  %278 = and i8 %277, 1
  %tobool317.not = icmp eq i8 %278, 0
  br i1 %tobool317.not, label %if.end885, label %if.then318

if.then318:                                       ; preds = %_ZN13b3ProfileZoneD2Ev.exit1045
  invoke void @b3EnterProfileZone(ptr noundef nonnull @.str.6)
          to label %invoke.cont320 unwind label %lpad58

invoke.cont320:                                   ; preds = %if.then318
  %279 = load ptr, ptr %m_clBuffer.i530, align 8
  store ptr %279, ptr %bInfo321, align 16
  %m_isReadOnly.i1049 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo321, i64 0, i32 1
  store i8 1, ptr %m_isReadOnly.i1049, align 8
  %arrayinit.element327 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo321, i64 1
  %280 = load ptr, ptr %m_clBuffer.i531, align 8
  store ptr %280, ptr %arrayinit.element327, align 16
  %m_isReadOnly.i1051 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo321, i64 1, i32 1
  store i8 1, ptr %m_isReadOnly.i1051, align 8
  %arrayinit.element331 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo321, i64 2
  %281 = load ptr, ptr %m_clBuffer.i533, align 8
  store ptr %281, ptr %arrayinit.element331, align 16
  %m_isReadOnly.i1053 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo321, i64 2, i32 1
  store i8 1, ptr %m_isReadOnly.i1053, align 8
  %arrayinit.element335 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo321, i64 3
  %282 = load ptr, ptr %m_clBuffer.i535, align 8
  store ptr %282, ptr %arrayinit.element335, align 16
  %m_isReadOnly.i1055 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo321, i64 3, i32 1
  store i8 1, ptr %m_isReadOnly.i1055, align 8
  %arrayinit.element339 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo321, i64 4
  %283 = load ptr, ptr %m_clBuffer.i537, align 8
  store ptr %283, ptr %arrayinit.element339, align 16
  %m_isReadOnly.i1057 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo321, i64 4, i32 1
  store i8 1, ptr %m_isReadOnly.i1057, align 8
  %arrayinit.element343 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo321, i64 5
  %284 = load ptr, ptr %m_clBuffer.i960, align 8
  store ptr %284, ptr %arrayinit.element343, align 16
  %m_isReadOnly.i1059 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo321, i64 5, i32 1
  store i8 1, ptr %m_isReadOnly.i1059, align 8
  %arrayinit.element348 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo321, i64 6
  %285 = load ptr, ptr %m_clBuffer.i875, align 8
  store ptr %285, ptr %arrayinit.element348, align 16
  %m_isReadOnly.i1061 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo321, i64 6, i32 1
  store i8 0, ptr %m_isReadOnly.i1061, align 8
  %arrayinit.element353 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo321, i64 7
  %286 = load ptr, ptr %m_clBuffer.i877, align 8
  store ptr %286, ptr %arrayinit.element353, align 16
  %m_isReadOnly.i1063 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo321, i64 7, i32 1
  store i8 0, ptr %m_isReadOnly.i1063, align 8
  %arrayinit.element358 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo321, i64 8
  %287 = load ptr, ptr %m_clBuffer.i879, align 8
  store ptr %287, ptr %arrayinit.element358, align 16
  %m_isReadOnly.i1065 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo321, i64 8, i32 1
  store i8 0, ptr %m_isReadOnly.i1065, align 8
  %288 = load ptr, ptr %m_queue, align 8
  %m_findSeparatingAxisUnitSphereKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 6
  %289 = load ptr, ptr %m_findSeparatingAxisUnitSphereKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher363, ptr noundef %288, ptr noundef %289, ptr noundef nonnull @.str.6)
          to label %invoke.cont365 unwind label %lpad323

invoke.cont365:                                   ; preds = %invoke.cont320
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher363, ptr noundef nonnull %bInfo321, i32 noundef 9)
          to label %invoke.cont368 unwind label %lpad367

invoke.cont368:                                   ; preds = %invoke.cont365
  store i32 162, ptr %numDirections369, align 4
  %m_enableSerialization.i1066 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher363, i64 0, i32 7
  %290 = load i8, ptr %m_enableSerialization.i1066, align 4
  %291 = and i8 %290, 1
  %tobool.not.i1067 = icmp eq i8 %291, 0
  br i1 %tobool.not.i1067, label %if.end.i1083, label %if.then.i1068

if.then.i1068:                                    ; preds = %invoke.cont368
  %m_idx.i1069 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher363, i64 0, i32 3
  %292 = load i32, ptr %m_idx.i1069, align 8
  %m_size.i.i.i1070 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher363, i64 0, i32 5, i32 2
  %293 = load i32, ptr %m_size.i.i.i1070, align 4
  %m_capacity.i.i.i1071 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher363, i64 0, i32 5, i32 3
  %294 = load i32, ptr %m_capacity.i.i.i1071, align 8
  %cmp.i.i1072 = icmp eq i32 %293, %294
  br i1 %cmp.i.i1072, label %if.then.i.i1088, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1073

if.then.i.i1088:                                  ; preds = %if.then.i1068
  %m_kernelArguments.i1089 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher363, i64 0, i32 5
  %tobool.not.i.i.i1090 = icmp eq i32 %293, 0
  %mul.i.i.i1091 = shl nsw i32 %293, 1
  %cond.i.i.i1092 = select i1 %tobool.not.i.i.i1090, i32 1, i32 %mul.i.i.i1091
  invoke void @_ZN20b3AlignedObjectArrayI15b3KernelArgDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %m_kernelArguments.i1089, i32 noundef %cond.i.i.i1092)
          to label %.noexc1094 unwind label %lpad367

.noexc1094:                                       ; preds = %if.then.i.i1088
  %.pre.i.i1093 = load i32, ptr %m_size.i.i.i1070, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1073

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1073: ; preds = %.noexc1094, %if.then.i1068
  %295 = phi i32 [ %.pre.i.i1093, %.noexc1094 ], [ %293, %if.then.i1068 ]
  %m_data.i.i1074 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher363, i64 0, i32 5, i32 5
  %296 = load ptr, ptr %m_data.i.i1074, align 8
  %idxprom.i.i1075 = sext i32 %295 to i64
  %arrayidx.i.i1076 = getelementptr inbounds %struct.b3KernelArgData, ptr %296, i64 %idxprom.i.i1075
  store i32 0, ptr %arrayidx.i.i1076, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i1077 = getelementptr inbounds i8, ptr %arrayidx.i.i1076, i64 4
  store i32 %292, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i1077, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i1078 = getelementptr inbounds i8, ptr %arrayidx.i.i1076, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i1078, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i1079 = getelementptr inbounds i8, ptr %arrayidx.i.i1076, i64 16
  store i32 162, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i1079, align 16
  %297 = load i32, ptr %m_size.i.i.i1070, align 4
  %inc.i.i1080 = add nsw i32 %297, 1
  store i32 %inc.i.i1080, ptr %m_size.i.i.i1070, align 4
  %m_serializationSizeInBytes.i1081 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher363, i64 0, i32 6
  %298 = load i32, ptr %m_serializationSizeInBytes.i1081, align 8
  %add.i1082 = add i32 %298, 32
  store i32 %add.i1082, ptr %m_serializationSizeInBytes.i1081, align 8
  br label %if.end.i1083

if.end.i1083:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1073, %invoke.cont368
  %299 = load ptr, ptr @__clewSetKernelArg, align 8
  %m_kernel.i1084 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher363, i64 0, i32 2
  %300 = load ptr, ptr %m_kernel.i1084, align 8
  %m_idx3.i1085 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher363, i64 0, i32 3
  %301 = load i32, ptr %m_idx3.i1085, align 8
  %inc.i1086 = add nsw i32 %301, 1
  store i32 %inc.i1086, ptr %m_idx3.i1085, align 8
  %call.i10871095 = invoke i32 %299(ptr noundef %300, i32 noundef %301, i64 noundef 4, ptr noundef nonnull %numDirections369)
          to label %invoke.cont370 unwind label %lpad367

invoke.cont370:                                   ; preds = %if.end.i1083
  %302 = load i8, ptr %m_enableSerialization.i1066, align 4
  %303 = and i8 %302, 1
  %tobool.not.i1098 = icmp eq i8 %303, 0
  br i1 %tobool.not.i1098, label %if.end.i1114, label %if.then.i1099

if.then.i1099:                                    ; preds = %invoke.cont370
  %304 = load i32, ptr %m_idx3.i1085, align 8
  %305 = load i32, ptr %nPairs.addr, align 4
  %m_size.i.i.i1101 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher363, i64 0, i32 5, i32 2
  %306 = load i32, ptr %m_size.i.i.i1101, align 4
  %m_capacity.i.i.i1102 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher363, i64 0, i32 5, i32 3
  %307 = load i32, ptr %m_capacity.i.i.i1102, align 8
  %cmp.i.i1103 = icmp eq i32 %306, %307
  br i1 %cmp.i.i1103, label %if.then.i.i1119, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1104

if.then.i.i1119:                                  ; preds = %if.then.i1099
  %m_kernelArguments.i1120 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher363, i64 0, i32 5
  %tobool.not.i.i.i1121 = icmp eq i32 %306, 0
  %mul.i.i.i1122 = shl nsw i32 %306, 1
  %cond.i.i.i1123 = select i1 %tobool.not.i.i.i1121, i32 1, i32 %mul.i.i.i1122
  invoke void @_ZN20b3AlignedObjectArrayI15b3KernelArgDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %m_kernelArguments.i1120, i32 noundef %cond.i.i.i1123)
          to label %.noexc1125 unwind label %lpad367

.noexc1125:                                       ; preds = %if.then.i.i1119
  %.pre.i.i1124 = load i32, ptr %m_size.i.i.i1101, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1104

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1104: ; preds = %.noexc1125, %if.then.i1099
  %308 = phi i32 [ %.pre.i.i1124, %.noexc1125 ], [ %306, %if.then.i1099 ]
  %m_data.i.i1105 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher363, i64 0, i32 5, i32 5
  %309 = load ptr, ptr %m_data.i.i1105, align 8
  %idxprom.i.i1106 = sext i32 %308 to i64
  %arrayidx.i.i1107 = getelementptr inbounds %struct.b3KernelArgData, ptr %309, i64 %idxprom.i.i1106
  store i32 0, ptr %arrayidx.i.i1107, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i1108 = getelementptr inbounds i8, ptr %arrayidx.i.i1107, i64 4
  store i32 %304, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i1108, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i1109 = getelementptr inbounds i8, ptr %arrayidx.i.i1107, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i1109, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i1110 = getelementptr inbounds i8, ptr %arrayidx.i.i1107, i64 16
  store i32 %305, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i1110, align 16
  %310 = load i32, ptr %m_size.i.i.i1101, align 4
  %inc.i.i1111 = add nsw i32 %310, 1
  store i32 %inc.i.i1111, ptr %m_size.i.i.i1101, align 4
  %m_serializationSizeInBytes.i1112 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher363, i64 0, i32 6
  %311 = load i32, ptr %m_serializationSizeInBytes.i1112, align 8
  %add.i1113 = add i32 %311, 32
  store i32 %add.i1113, ptr %m_serializationSizeInBytes.i1112, align 8
  br label %if.end.i1114

if.end.i1114:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1104, %invoke.cont370
  %312 = load ptr, ptr @__clewSetKernelArg, align 8
  %313 = load ptr, ptr %m_kernel.i1084, align 8
  %314 = load i32, ptr %m_idx3.i1085, align 8
  %inc.i1117 = add nsw i32 %314, 1
  store i32 %inc.i1117, ptr %m_idx3.i1085, align 8
  %call.i11181126 = invoke i32 %312(ptr noundef %313, i32 noundef %314, i64 noundef 4, ptr noundef nonnull %nPairs.addr)
          to label %invoke.cont371 unwind label %lpad367

invoke.cont371:                                   ; preds = %if.end.i1114
  %315 = load i32, ptr %nPairs.addr, align 4
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %gRange.i.i1128)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %lRange.i.i1129)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %gRange.i.i1128, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %lRange.i.i1129, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  store i64 64, ptr %lRange.i.i1129, align 16
  %arrayidx3.i.i1130 = getelementptr inbounds [3 x i64], ptr %lRange.i.i1129, i64 0, i64 1
  store i64 1, ptr %arrayidx3.i.i1130, align 8
  %conv5.i.i1131 = sext i32 %315 to i64
  %div.i.i11326120 = lshr i64 %conv5.i.i1131, 6
  %rem.i.i1133 = and i64 %conv5.i.i1131, 63
  %tobool.not.i.i1134 = icmp ne i64 %rem.i.i1133, 0
  %conv9.i.i1135 = zext i1 %tobool.not.i.i1134 to i64
  %add.i.i1136 = add nuw nsw i64 %div.i.i11326120, %conv9.i.i1135
  %.sroa.speculated8.i.i1137 = call i64 @llvm.umax.i64(i64 %add.i.i1136, i64 1)
  %mul.i.i1138 = shl i64 %.sroa.speculated8.i.i1137, 6
  store i64 %mul.i.i1138, ptr %gRange.i.i1128, align 16
  %arrayidx27.i.i1139 = getelementptr inbounds [3 x i64], ptr %gRange.i.i1128, i64 0, i64 1
  store i64 1, ptr %arrayidx27.i.i1139, align 8
  %316 = load ptr, ptr @__clewEnqueueNDRangeKernel, align 8
  %m_commandQueue.i.i1140 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher363, i64 0, i32 1
  %317 = load ptr, ptr %m_commandQueue.i.i1140, align 8
  %318 = load ptr, ptr %m_kernel.i1084, align 8
  %call32.i.i1146 = invoke i32 %316(ptr noundef %317, ptr noundef %318, i32 noundef 2, ptr noundef null, ptr noundef nonnull %gRange.i.i1128, ptr noundef nonnull %lRange.i.i1129, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call32.i.i.noexc1145 unwind label %lpad367

call32.i.i.noexc1145:                             ; preds = %invoke.cont371
  %cmp.not.i.i1142 = icmp eq i32 %call32.i.i1146, 0
  br i1 %cmp.not.i.i1142, label %invoke.cont373, label %if.then.i.i1143

if.then.i.i1143:                                  ; preds = %call32.i.i.noexc1145
  %call33.i.i1144 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.74, i32 noundef %call32.i.i1146)
  br label %invoke.cont373

invoke.cont373:                                   ; preds = %if.then.i.i1143, %call32.i.i.noexc1145
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %gRange.i.i1128)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %lRange.i.i1129)
  %319 = load ptr, ptr @__clewFinish, align 8
  %320 = load ptr, ptr %m_queue, align 8
  %call376 = invoke i32 %319(ptr noundef %320)
          to label %invoke.cont375 unwind label %lpad367

invoke.cont375:                                   ; preds = %invoke.cont373
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher363) #26
  invoke void @b3LeaveProfileZone()
          to label %if.end885 unwind label %terminate.lpad.i1148

terminate.lpad.i1148:                             ; preds = %invoke.cont375
  %321 = landingpad { ptr, i32 }
          catch ptr null
  %322 = extractvalue { ptr, i32 } %321, 0
  call void @__clang_call_terminate(ptr %322) #27
  unreachable

lpad178:                                          ; preds = %invoke.cont175
  %323 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup242

lpad233:                                          ; preds = %if.then3.i.i4570, %.noexc4586, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4582, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4555, %invoke.cont235, %if.end.i898, %invoke.cont237, %invoke.cont231
  %324 = landingpad { ptr, i32 }
          cleanup
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher229) #26
  br label %ehcleanup242

ehcleanup242:                                     ; preds = %lpad233, %lpad178
  %.pn462 = phi { ptr, i32 } [ %324, %lpad233 ], [ %323, %lpad178 ]
  invoke void @b3LeaveProfileZone()
          to label %ehcleanup2980 unwind label %terminate.lpad.i1150

terminate.lpad.i1150:                             ; preds = %ehcleanup242
  %325 = landingpad { ptr, i32 }
          catch ptr null
  %326 = extractvalue { ptr, i32 } %325, 0
  call void @__clang_call_terminate(ptr %326) #27
  unreachable

lpad247:                                          ; preds = %invoke.cont244
  %327 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup316

lpad306:                                          ; preds = %if.then3.i.i4650, %.noexc4666, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4662, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4635, %if.then3.i.i4610, %.noexc4626, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4622, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4595, %invoke.cont309, %if.end.i1010, %if.end.i979, %invoke.cont311, %invoke.cont304
  %328 = landingpad { ptr, i32 }
          cleanup
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher302) #26
  br label %ehcleanup316

ehcleanup316:                                     ; preds = %lpad306, %lpad247
  %.pn464 = phi { ptr, i32 } [ %328, %lpad306 ], [ %327, %lpad247 ]
  invoke void @b3LeaveProfileZone()
          to label %ehcleanup2980 unwind label %terminate.lpad.i1152

terminate.lpad.i1152:                             ; preds = %ehcleanup316
  %329 = landingpad { ptr, i32 }
          catch ptr null
  %330 = extractvalue { ptr, i32 } %329, 0
  call void @__clang_call_terminate(ptr %330) #27
  unreachable

lpad323:                                          ; preds = %invoke.cont320
  %331 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup378

lpad367:                                          ; preds = %invoke.cont371, %if.end.i1114, %if.then.i.i1119, %if.end.i1083, %if.then.i.i1088, %invoke.cont373, %invoke.cont365
  %332 = landingpad { ptr, i32 }
          cleanup
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher363) #26
  br label %ehcleanup378

ehcleanup378:                                     ; preds = %lpad367, %lpad323
  %.pn466 = phi { ptr, i32 } [ %332, %lpad367 ], [ %331, %lpad323 ]
  invoke void @b3LeaveProfileZone()
          to label %ehcleanup2980 unwind label %terminate.lpad.i1154

terminate.lpad.i1154:                             ; preds = %ehcleanup378
  %333 = landingpad { ptr, i32 }
          catch ptr null
  %334 = extractvalue { ptr, i32 } %333, 0
  call void @__clang_call_terminate(ptr %334) #27
  unreachable

if.else:                                          ; preds = %invoke.cont96
  invoke void @b3EnterProfileZone(ptr noundef nonnull @.str.9)
          to label %invoke.cont381 unwind label %lpad58

invoke.cont381:                                   ; preds = %if.else
  %335 = load ptr, ptr %m_clBuffer.i530, align 8
  store ptr %335, ptr %bInfo382, align 16
  %m_isReadOnly.i1159 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo382, i64 0, i32 1
  store i8 1, ptr %m_isReadOnly.i1159, align 8
  %arrayinit.element388 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo382, i64 1
  %336 = load ptr, ptr %m_clBuffer.i531, align 8
  store ptr %336, ptr %arrayinit.element388, align 16
  %m_isReadOnly.i1161 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo382, i64 1, i32 1
  store i8 1, ptr %m_isReadOnly.i1161, align 8
  %arrayinit.element392 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo382, i64 2
  %337 = load ptr, ptr %m_clBuffer.i533, align 8
  store ptr %337, ptr %arrayinit.element392, align 16
  %m_isReadOnly.i1163 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo382, i64 2, i32 1
  store i8 1, ptr %m_isReadOnly.i1163, align 8
  %arrayinit.element396 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo382, i64 3
  %338 = load ptr, ptr %m_clBuffer.i535, align 8
  store ptr %338, ptr %arrayinit.element396, align 16
  %m_isReadOnly.i1165 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo382, i64 3, i32 1
  store i8 1, ptr %m_isReadOnly.i1165, align 8
  %arrayinit.element400 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo382, i64 4
  %339 = load ptr, ptr %m_clBuffer.i537, align 8
  store ptr %339, ptr %arrayinit.element400, align 16
  %m_isReadOnly.i1167 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo382, i64 4, i32 1
  store i8 1, ptr %m_isReadOnly.i1167, align 8
  %arrayinit.element404 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo382, i64 5
  %340 = load ptr, ptr %m_clBuffer.i539, align 8
  store ptr %340, ptr %arrayinit.element404, align 16
  %m_isReadOnly.i1169 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo382, i64 5, i32 1
  store i8 1, ptr %m_isReadOnly.i1169, align 8
  %arrayinit.element408 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo382, i64 6
  %341 = load ptr, ptr %m_clBuffer.i541, align 8
  store ptr %341, ptr %arrayinit.element408, align 16
  %m_isReadOnly.i1171 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo382, i64 6, i32 1
  store i8 1, ptr %m_isReadOnly.i1171, align 8
  %arrayinit.element412 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo382, i64 7
  %342 = load ptr, ptr %m_clBuffer.i543, align 8
  store ptr %342, ptr %arrayinit.element412, align 16
  %m_isReadOnly.i1173 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo382, i64 7, i32 1
  store i8 1, ptr %m_isReadOnly.i1173, align 8
  %arrayinit.element416 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo382, i64 8
  %m_clBuffer.i1174 = getelementptr inbounds %class.b3OpenCLArray.90, ptr %clAabbsWorldSpace, i64 0, i32 3
  %343 = load ptr, ptr %m_clBuffer.i1174, align 8
  store ptr %343, ptr %arrayinit.element416, align 16
  %m_isReadOnly.i1175 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo382, i64 8, i32 1
  store i8 1, ptr %m_isReadOnly.i1175, align 8
  %arrayinit.element420 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo382, i64 9
  %m_clBuffer.i1176 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 26, i32 3
  %344 = load ptr, ptr %m_clBuffer.i1176, align 8
  store ptr %344, ptr %arrayinit.element420, align 16
  %m_isReadOnly.i1177 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo382, i64 9, i32 1
  store i8 0, ptr %m_isReadOnly.i1177, align 8
  %arrayinit.element425 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo382, i64 10
  %m_clBuffer.i1178 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 28, i32 3
  %345 = load ptr, ptr %m_clBuffer.i1178, align 8
  store ptr %345, ptr %arrayinit.element425, align 16
  %m_isReadOnly.i1179 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo382, i64 10, i32 1
  store i8 0, ptr %m_isReadOnly.i1179, align 8
  %346 = load ptr, ptr %m_queue, align 8
  %m_findSeparatingAxisKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 4
  %347 = load ptr, ptr %m_findSeparatingAxisKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher430, ptr noundef %346, ptr noundef %347, ptr noundef nonnull @.str.42)
          to label %invoke.cont432 unwind label %lpad384

invoke.cont432:                                   ; preds = %invoke.cont381
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher430, ptr noundef nonnull %bInfo382, i32 noundef 11)
          to label %invoke.cont435 unwind label %lpad434

invoke.cont435:                                   ; preds = %invoke.cont432
  %m_enableSerialization.i1180 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher430, i64 0, i32 7
  %348 = load i8, ptr %m_enableSerialization.i1180, align 4
  %349 = and i8 %348, 1
  %tobool.not.i1181 = icmp eq i8 %349, 0
  br i1 %tobool.not.i1181, label %if.end.i1197, label %if.then.i1182

if.then.i1182:                                    ; preds = %invoke.cont435
  %m_idx.i1183 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher430, i64 0, i32 3
  %350 = load i32, ptr %m_idx.i1183, align 8
  %351 = load i32, ptr %nPairs.addr, align 4
  %m_size.i.i.i1184 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher430, i64 0, i32 5, i32 2
  %352 = load i32, ptr %m_size.i.i.i1184, align 4
  %m_capacity.i.i.i1185 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher430, i64 0, i32 5, i32 3
  %353 = load i32, ptr %m_capacity.i.i.i1185, align 8
  %cmp.i.i1186 = icmp eq i32 %352, %353
  br i1 %cmp.i.i1186, label %if.then.i.i1202, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1187

if.then.i.i1202:                                  ; preds = %if.then.i1182
  %tobool.not.i.i.i1204 = icmp eq i32 %352, 0
  %mul.i.i.i1205 = shl nsw i32 %352, 1
  %cond.i.i.i1206 = select i1 %tobool.not.i.i.i1204, i32 1, i32 %mul.i.i.i1205
  %cmp.i4671 = icmp slt i32 %352, %cond.i.i.i1206
  br i1 %cmp.i4671, label %if.then.i4673, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1187

if.then.i4673:                                    ; preds = %if.then.i.i1202
  %tobool.not.i.i4674 = icmp eq i32 %cond.i.i.i1206, 0
  br i1 %tobool.not.i.i4674, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4702, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4675

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4675: ; preds = %if.then.i4673
  %conv.i.i.i4676 = sext i32 %cond.i.i.i1206 to i64
  %mul.i.i.i4677 = shl nsw i64 %conv.i.i.i4676, 5
  %call.i.i.i4705 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i4677, i32 noundef 16)
          to label %call.i.i.i.noexc4704 unwind label %lpad434

call.i.i.i.noexc4704:                             ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4675
  %cmp3.i4678 = icmp eq ptr %call.i.i.i4705, null
  br i1 %cmp3.i4678, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4702, label %if.then.split.i4679

if.then.split.i4679:                              ; preds = %call.i.i.i.noexc4704
  %354 = load i32, ptr %m_size.i.i.i1184, align 4
  %cmp4.i.i4681 = icmp sgt i32 %354, 0
  br i1 %cmp4.i.i4681, label %for.body.lr.ph.i.i4693, label %if.end.i4682

for.body.lr.ph.i.i4693:                           ; preds = %if.then.split.i4679
  %m_data.i.i4694 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher430, i64 0, i32 5, i32 5
  %wide.trip.count.i.i4695 = zext nneg i32 %354 to i64
  br label %for.body.i.i4696

for.body.i.i4696:                                 ; preds = %for.body.i.i4696, %for.body.lr.ph.i.i4693
  %indvars.iv.i.i4697 = phi i64 [ 0, %for.body.lr.ph.i.i4693 ], [ %indvars.iv.next.i.i4700, %for.body.i.i4696 ]
  %arrayidx.i.i4698 = getelementptr inbounds %struct.b3KernelArgData, ptr %call.i.i.i4705, i64 %indvars.iv.i.i4697
  %355 = load ptr, ptr %m_data.i.i4694, align 8
  %arrayidx3.i.i4699 = getelementptr inbounds %struct.b3KernelArgData, ptr %355, i64 %indvars.iv.i.i4697
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i.i4698, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i.i4699, i64 32, i1 false)
  %indvars.iv.next.i.i4700 = add nuw nsw i64 %indvars.iv.i.i4697, 1
  %exitcond.not.i.i4701 = icmp eq i64 %indvars.iv.next.i.i4700, %wide.trip.count.i.i4695
  br i1 %exitcond.not.i.i4701, label %if.end.i4682, label %for.body.i.i4696, !llvm.loop !64

_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4702: ; preds = %call.i.i.i.noexc4704, %if.then.i4673
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc4706 unwind label %lpad434

.noexc4706:                                       ; preds = %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4702
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc4707 unwind label %lpad434

.noexc4707:                                       ; preds = %.noexc4706
  store i32 0, ptr %m_size.i.i.i1184, align 4
  br label %if.end.i4682

if.end.i4682:                                     ; preds = %for.body.i.i4696, %.noexc4707, %if.then.split.i4679
  %retval.0.i25.i4683 = phi ptr [ null, %.noexc4707 ], [ %call.i.i.i4705, %if.then.split.i4679 ], [ %call.i.i.i4705, %for.body.i.i4696 ]
  %_Count.addr.0.i4684 = phi i32 [ 0, %.noexc4707 ], [ %cond.i.i.i1206, %if.then.split.i4679 ], [ %cond.i.i.i1206, %for.body.i.i4696 ]
  %m_data.i20.i4685 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher430, i64 0, i32 5, i32 5
  %356 = load ptr, ptr %m_data.i20.i4685, align 8
  %tobool.not.i21.i4686 = icmp eq ptr %356, null
  br i1 %tobool.not.i21.i4686, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4691, label %if.then.i22.i4687

if.then.i22.i4687:                                ; preds = %if.end.i4682
  %m_ownsMemory.i.i4688 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher430, i64 0, i32 5, i32 6
  %357 = load i8, ptr %m_ownsMemory.i.i4688, align 8
  %358 = and i8 %357, 1
  %tobool2.not.i.i4689 = icmp eq i8 %358, 0
  br i1 %tobool2.not.i.i4689, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4691, label %if.then3.i.i4690

if.then3.i.i4690:                                 ; preds = %if.then.i22.i4687
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %356)
          to label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4691 unwind label %lpad434

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4691: ; preds = %if.then3.i.i4690, %if.then.i22.i4687, %if.end.i4682
  %m_ownsMemory.i4692 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher430, i64 0, i32 5, i32 6
  store i8 1, ptr %m_ownsMemory.i4692, align 8
  store ptr %retval.0.i25.i4683, ptr %m_data.i20.i4685, align 8
  store i32 %_Count.addr.0.i4684, ptr %m_capacity.i.i.i1185, align 8
  %.pre.i.i1207.pre = load i32, ptr %m_size.i.i.i1184, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1187

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1187: ; preds = %if.then.i.i1202, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4691, %if.then.i1182
  %359 = phi i32 [ %352, %if.then.i1182 ], [ %.pre.i.i1207.pre, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4691 ], [ %352, %if.then.i.i1202 ]
  %m_data.i.i1188 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher430, i64 0, i32 5, i32 5
  %360 = load ptr, ptr %m_data.i.i1188, align 8
  %idxprom.i.i1189 = sext i32 %359 to i64
  %arrayidx.i.i1190 = getelementptr inbounds %struct.b3KernelArgData, ptr %360, i64 %idxprom.i.i1189
  store i32 0, ptr %arrayidx.i.i1190, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i1191 = getelementptr inbounds i8, ptr %arrayidx.i.i1190, i64 4
  store i32 %350, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i1191, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i1192 = getelementptr inbounds i8, ptr %arrayidx.i.i1190, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i1192, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i1193 = getelementptr inbounds i8, ptr %arrayidx.i.i1190, i64 16
  store i32 %351, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i1193, align 16
  %361 = load i32, ptr %m_size.i.i.i1184, align 4
  %inc.i.i1194 = add nsw i32 %361, 1
  store i32 %inc.i.i1194, ptr %m_size.i.i.i1184, align 4
  %m_serializationSizeInBytes.i1195 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher430, i64 0, i32 6
  %362 = load i32, ptr %m_serializationSizeInBytes.i1195, align 8
  %add.i1196 = add i32 %362, 32
  store i32 %add.i1196, ptr %m_serializationSizeInBytes.i1195, align 8
  br label %if.end.i1197

if.end.i1197:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1187, %invoke.cont435
  %363 = load ptr, ptr @__clewSetKernelArg, align 8
  %m_kernel.i1198 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher430, i64 0, i32 2
  %364 = load ptr, ptr %m_kernel.i1198, align 8
  %m_idx3.i1199 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher430, i64 0, i32 3
  %365 = load i32, ptr %m_idx3.i1199, align 8
  %inc.i1200 = add nsw i32 %365, 1
  store i32 %inc.i1200, ptr %m_idx3.i1199, align 8
  %call.i12011209 = invoke i32 %363(ptr noundef %364, i32 noundef %365, i64 noundef 4, ptr noundef nonnull %nPairs.addr)
          to label %invoke.cont436 unwind label %lpad434

invoke.cont436:                                   ; preds = %if.end.i1197
  %366 = load i32, ptr %nPairs.addr, align 4
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %gRange.i.i1211)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %lRange.i.i1212)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %gRange.i.i1211, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %lRange.i.i1212, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  store i64 64, ptr %lRange.i.i1212, align 16
  %arrayidx3.i.i1213 = getelementptr inbounds [3 x i64], ptr %lRange.i.i1212, i64 0, i64 1
  store i64 1, ptr %arrayidx3.i.i1213, align 8
  %conv5.i.i1214 = sext i32 %366 to i64
  %div.i.i12156121 = lshr i64 %conv5.i.i1214, 6
  %rem.i.i1216 = and i64 %conv5.i.i1214, 63
  %tobool.not.i.i1217 = icmp ne i64 %rem.i.i1216, 0
  %conv9.i.i1218 = zext i1 %tobool.not.i.i1217 to i64
  %add.i.i1219 = add nuw nsw i64 %div.i.i12156121, %conv9.i.i1218
  %.sroa.speculated8.i.i1220 = call i64 @llvm.umax.i64(i64 %add.i.i1219, i64 1)
  %mul.i.i1221 = shl i64 %.sroa.speculated8.i.i1220, 6
  store i64 %mul.i.i1221, ptr %gRange.i.i1211, align 16
  %arrayidx27.i.i1222 = getelementptr inbounds [3 x i64], ptr %gRange.i.i1211, i64 0, i64 1
  store i64 1, ptr %arrayidx27.i.i1222, align 8
  %367 = load ptr, ptr @__clewEnqueueNDRangeKernel, align 8
  %m_commandQueue.i.i1223 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher430, i64 0, i32 1
  %368 = load ptr, ptr %m_commandQueue.i.i1223, align 8
  %369 = load ptr, ptr %m_kernel.i1198, align 8
  %call32.i.i1229 = invoke i32 %367(ptr noundef %368, ptr noundef %369, i32 noundef 2, ptr noundef null, ptr noundef nonnull %gRange.i.i1211, ptr noundef nonnull %lRange.i.i1212, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call32.i.i.noexc1228 unwind label %lpad434

call32.i.i.noexc1228:                             ; preds = %invoke.cont436
  %cmp.not.i.i1225 = icmp eq i32 %call32.i.i1229, 0
  br i1 %cmp.not.i.i1225, label %invoke.cont438, label %if.then.i.i1226

if.then.i.i1226:                                  ; preds = %call32.i.i.noexc1228
  %call33.i.i1227 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.74, i32 noundef %call32.i.i1229)
  br label %invoke.cont438

invoke.cont438:                                   ; preds = %if.then.i.i1226, %call32.i.i.noexc1228
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %gRange.i.i1211)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %lRange.i.i1212)
  %370 = load ptr, ptr @__clewFinish, align 8
  %371 = load ptr, ptr %m_queue, align 8
  %call441 = invoke i32 %370(ptr noundef %371)
          to label %invoke.cont440 unwind label %lpad434

invoke.cont440:                                   ; preds = %invoke.cont438
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher430) #26
  invoke void @b3LeaveProfileZone()
          to label %if.end885 unwind label %terminate.lpad.i1231

terminate.lpad.i1231:                             ; preds = %invoke.cont440
  %372 = landingpad { ptr, i32 }
          catch ptr null
  %373 = extractvalue { ptr, i32 } %372, 0
  call void @__clang_call_terminate(ptr %373) #27
  unreachable

lpad384:                                          ; preds = %invoke.cont381
  %374 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup443

lpad434:                                          ; preds = %if.then3.i.i4690, %.noexc4706, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4702, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4675, %invoke.cont436, %if.end.i1197, %invoke.cont438, %invoke.cont432
  %375 = landingpad { ptr, i32 }
          cleanup
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher430) #26
  br label %ehcleanup443

ehcleanup443:                                     ; preds = %lpad434, %lpad384
  %.pn458 = phi { ptr, i32 } [ %375, %lpad434 ], [ %374, %lpad384 ]
  invoke void @b3LeaveProfileZone()
          to label %ehcleanup2980 unwind label %terminate.lpad.i1233

terminate.lpad.i1233:                             ; preds = %ehcleanup443
  %376 = landingpad { ptr, i32 }
          catch ptr null
  %377 = extractvalue { ptr, i32 } %376, 0
  call void @__clang_call_terminate(ptr %377) #27
  unreachable

if.else445:                                       ; preds = %invoke.cont91
  invoke void @b3EnterProfileZone(ptr noundef nonnull @.str.43)
          to label %invoke.cont449 unwind label %lpad58

invoke.cont449:                                   ; preds = %if.else445
  %m_ownsMemory.i.i = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %hostPairs, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i, align 8
  %m_data.i.i1237 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %hostPairs, i64 0, i32 5
  store ptr null, ptr %m_data.i.i1237, align 8
  %m_size.i.i1238 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %hostPairs, i64 0, i32 2
  store i32 0, ptr %m_size.i.i1238, align 4
  %m_capacity.i.i1239 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %hostPairs, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i1239, align 8
  invoke void @_ZNK13b3OpenCLArrayI6b3Int4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %pairs, ptr noundef nonnull align 8 dereferenceable(25) %hostPairs, i1 noundef zeroext true)
          to label %invoke.cont452 unwind label %lpad450

invoke.cont452:                                   ; preds = %invoke.cont449
  %m_ownsMemory.i.i1240 = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %hostBodyBuf, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i1240, align 8
  %m_data.i.i1241 = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %hostBodyBuf, i64 0, i32 5
  store ptr null, ptr %m_data.i.i1241, align 8
  %m_size.i.i1242 = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %hostBodyBuf, i64 0, i32 2
  store i32 0, ptr %m_size.i.i1242, align 4
  %m_capacity.i.i1243 = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %hostBodyBuf, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i1243, align 8
  invoke void @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %bodyBuf, ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf, i1 noundef zeroext true)
          to label %invoke.cont455 unwind label %lpad453

invoke.cont455:                                   ; preds = %invoke.cont452
  %m_ownsMemory.i.i1244 = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %hostCollidables, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i1244, align 8
  %m_data.i.i1245 = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %hostCollidables, i64 0, i32 5
  store ptr null, ptr %m_data.i.i1245, align 8
  %m_size.i.i1246 = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %hostCollidables, i64 0, i32 2
  store i32 0, ptr %m_size.i.i1246, align 4
  %m_capacity.i.i1247 = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %hostCollidables, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i1247, align 8
  invoke void @_ZNK13b3OpenCLArrayI12b3CollidableE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %gpuCollidables, ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables, i1 noundef zeroext true)
          to label %invoke.cont458 unwind label %lpad456

invoke.cont458:                                   ; preds = %invoke.cont455
  %m_ownsMemory.i.i1248 = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %cpuChildShapes, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i1248, align 8
  %m_data.i.i1249 = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %cpuChildShapes, i64 0, i32 5
  store ptr null, ptr %m_data.i.i1249, align 8
  %m_size.i.i1250 = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %cpuChildShapes, i64 0, i32 2
  store i32 0, ptr %m_size.i.i1250, align 4
  %m_capacity.i.i1251 = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %cpuChildShapes, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i1251, align 8
  invoke void @_ZNK13b3OpenCLArrayI15b3GpuChildShapeE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %gpuChildShapes, ptr noundef nonnull align 8 dereferenceable(25) %cpuChildShapes, i1 noundef zeroext true)
          to label %invoke.cont461 unwind label %lpad459

invoke.cont461:                                   ; preds = %invoke.cont458
  %m_ownsMemory.i.i1252 = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %hostConvexShapeData, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i1252, align 8
  %m_data.i.i1253 = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %hostConvexShapeData, i64 0, i32 5
  store ptr null, ptr %m_data.i.i1253, align 8
  %m_size.i.i1254 = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %hostConvexShapeData, i64 0, i32 2
  store i32 0, ptr %m_size.i.i1254, align 4
  %m_capacity.i.i1255 = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %hostConvexShapeData, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i1255, align 8
  invoke void @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %convexData, ptr noundef nonnull align 8 dereferenceable(25) %hostConvexShapeData, i1 noundef zeroext true)
          to label %invoke.cont464 unwind label %lpad462

invoke.cont464:                                   ; preds = %invoke.cont461
  %m_ownsMemory.i.i1256 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %hostVertices, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i1256, align 8
  %m_data.i.i1257 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %hostVertices, i64 0, i32 5
  store ptr null, ptr %m_data.i.i1257, align 8
  %m_size.i.i1258 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %hostVertices, i64 0, i32 2
  store i32 0, ptr %m_size.i.i1258, align 4
  %m_capacity.i.i1259 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %hostVertices, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i1259, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %gpuVertices, ptr noundef nonnull align 8 dereferenceable(25) %hostVertices, i1 noundef zeroext true)
          to label %invoke.cont467 unwind label %lpad465

invoke.cont467:                                   ; preds = %invoke.cont464
  %m_ownsMemory.i.i1260 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %hostHasSepAxis, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i1260, align 8
  %m_data.i.i1261 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %hostHasSepAxis, i64 0, i32 5
  store ptr null, ptr %m_data.i.i1261, align 8
  %m_size.i.i1262 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %hostHasSepAxis, i64 0, i32 2
  store i32 0, ptr %m_size.i.i1262, align 4
  %m_capacity.i.i1263 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %hostHasSepAxis, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i1263, align 8
  %378 = load i32, ptr %nPairs.addr, align 4
  %cmp4.i = icmp sgt i32 %378, 0
  br i1 %cmp4.i, label %_ZN20b3AlignedObjectArrayIiE8allocateEi.exit.i, label %invoke.cont471

_ZN20b3AlignedObjectArrayIiE8allocateEi.exit.i:   ; preds = %invoke.cont467
  %conv.i.i.i4715 = zext nneg i32 %378 to i64
  %mul.i.i.i4716 = shl nuw nsw i64 %conv.i.i.i4715, 2
  %call.i.i.i4742 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i4716, i32 noundef 16)
          to label %call.i.i.i.noexc4741 unwind label %lpad469

call.i.i.i.noexc4741:                             ; preds = %_ZN20b3AlignedObjectArrayIiE8allocateEi.exit.i
  %cmp3.i4717 = icmp eq ptr %call.i.i.i4742, null
  br i1 %cmp3.i4717, label %_ZNK20b3AlignedObjectArrayIiE4copyEiiPi.exit18.i, label %.noexc1266

_ZNK20b3AlignedObjectArrayIiE4copyEiiPi.exit18.i: ; preds = %call.i.i.i.noexc4741
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc4743 unwind label %lpad469

.noexc4743:                                       ; preds = %_ZNK20b3AlignedObjectArrayIiE4copyEiiPi.exit18.i
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc1266 unwind label %lpad469

.noexc1266:                                       ; preds = %.noexc4743, %call.i.i.i.noexc4741
  %_Count.addr.0.i4723 = phi i32 [ %378, %call.i.i.i.noexc4741 ], [ 0, %.noexc4743 ]
  store i8 1, ptr %m_ownsMemory.i.i1260, align 8
  store ptr %call.i.i.i4742, ptr %m_data.i.i1261, align 8
  store i32 %_Count.addr.0.i4723, ptr %m_capacity.i.i1263, align 8
  br label %for.body9.i

for.body9.i:                                      ; preds = %for.body9.i, %.noexc1266
  %indvars.iv.i = phi i64 [ 0, %.noexc1266 ], [ %indvars.iv.next.i, %for.body9.i ]
  %arrayidx12.i = getelementptr inbounds i32, ptr %call.i.i.i4742, i64 %indvars.iv.i
  store i32 0, ptr %arrayidx12.i, align 4
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %conv.i.i.i4715
  br i1 %exitcond.not.i, label %invoke.cont471.loopexit, label %for.body9.i, !llvm.loop !56

invoke.cont471.loopexit:                          ; preds = %for.body9.i
  %.pre6178 = load i32, ptr %nPairs.addr, align 4
  br label %invoke.cont471

invoke.cont471:                                   ; preds = %invoke.cont471.loopexit, %invoke.cont467
  %379 = phi i32 [ %.pre6178, %invoke.cont471.loopexit ], [ %378, %invoke.cont467 ]
  store i32 %378, ptr %m_size.i.i1262, align 4
  %m_ownsMemory.i.i1267 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %hostSepAxis, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i1267, align 8
  %m_data.i.i1268 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %hostSepAxis, i64 0, i32 5
  store ptr null, ptr %m_data.i.i1268, align 8
  %m_size.i.i1269 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %hostSepAxis, i64 0, i32 2
  store i32 0, ptr %m_size.i.i1269, align 4
  %m_capacity.i.i1270 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %hostSepAxis, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i1270, align 8
  %cmp4.i1272 = icmp sgt i32 %379, 0
  br i1 %cmp4.i1272, label %_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit.i, label %invoke.cont475

_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit.i: ; preds = %invoke.cont471
  %conv.i.i.i4751 = zext nneg i32 %379 to i64
  %mul.i.i.i4752 = shl nuw nsw i64 %conv.i.i.i4751, 4
  %call.i.i.i4778 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i4752, i32 noundef 16)
          to label %call.i.i.i.noexc4777 unwind label %lpad473

call.i.i.i.noexc4777:                             ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit.i
  %cmp3.i4753 = icmp eq ptr %call.i.i.i4778, null
  br i1 %cmp3.i4753, label %_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i, label %.noexc1281

_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i: ; preds = %call.i.i.i.noexc4777
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc4779 unwind label %lpad473

.noexc4779:                                       ; preds = %_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc1281 unwind label %lpad473

.noexc1281:                                       ; preds = %.noexc4779, %call.i.i.i.noexc4777
  %_Count.addr.0.i4759 = phi i32 [ %379, %call.i.i.i.noexc4777 ], [ 0, %.noexc4779 ]
  store i8 1, ptr %m_ownsMemory.i.i1267, align 8
  store ptr %call.i.i.i4778, ptr %m_data.i.i1268, align 8
  store i32 %_Count.addr.0.i4759, ptr %m_capacity.i.i1270, align 8
  br label %for.body9.i1276

for.body9.i1276:                                  ; preds = %for.body9.i1276, %.noexc1281
  %indvars.iv.i1277 = phi i64 [ 0, %.noexc1281 ], [ %indvars.iv.next.i1279, %for.body9.i1276 ]
  %arrayidx12.i1278 = getelementptr inbounds %class.b3Vector3, ptr %call.i.i.i4778, i64 %indvars.iv.i1277
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx12.i1278, i8 0, i64 16, i1 false)
  %indvars.iv.next.i1279 = add nuw nsw i64 %indvars.iv.i1277, 1
  %exitcond.not.i1280 = icmp eq i64 %indvars.iv.next.i1279, %conv.i.i.i4751
  br i1 %exitcond.not.i1280, label %invoke.cont475, label %for.body9.i1276, !llvm.loop !55

invoke.cont475:                                   ; preds = %for.body9.i1276, %invoke.cont471
  store i32 %379, ptr %m_size.i.i1269, align 4
  %m_ownsMemory.i.i1282 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %hostUniqueEdges, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i1282, align 8
  %m_data.i.i1283 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %hostUniqueEdges, i64 0, i32 5
  store ptr null, ptr %m_data.i.i1283, align 8
  %m_size.i.i1284 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %hostUniqueEdges, i64 0, i32 2
  store i32 0, ptr %m_size.i.i1284, align 4
  %m_capacity.i.i1285 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %hostUniqueEdges, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i1285, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %gpuUniqueEdges, ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges, i1 noundef zeroext true)
          to label %invoke.cont478 unwind label %lpad476

invoke.cont478:                                   ; preds = %invoke.cont475
  %m_ownsMemory.i.i1286 = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %hostFaces, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i1286, align 8
  %m_data.i.i1287 = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %hostFaces, i64 0, i32 5
  store ptr null, ptr %m_data.i.i1287, align 8
  %m_size.i.i1288 = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %hostFaces, i64 0, i32 2
  store i32 0, ptr %m_size.i.i1288, align 4
  %m_capacity.i.i1289 = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %hostFaces, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i1289, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3GpuFaceE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %gpuFaces, ptr noundef nonnull align 8 dereferenceable(25) %hostFaces, i1 noundef zeroext true)
          to label %invoke.cont481 unwind label %lpad479

invoke.cont481:                                   ; preds = %invoke.cont478
  %m_ownsMemory.i.i1290 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %hostIndices, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i1290, align 8
  %m_data.i.i1291 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %hostIndices, i64 0, i32 5
  store ptr null, ptr %m_data.i.i1291, align 8
  %m_size.i.i1292 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %hostIndices, i64 0, i32 2
  store i32 0, ptr %m_size.i.i1292, align 4
  %m_capacity.i.i1293 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %hostIndices, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i1293, align 8
  invoke void @_ZNK13b3OpenCLArrayIiE10copyToHostER20b3AlignedObjectArrayIiEb(ptr noundef nonnull align 8 dereferenceable(50) %gpuIndices, ptr noundef nonnull align 8 dereferenceable(25) %hostIndices, i1 noundef zeroext true)
          to label %invoke.cont484 unwind label %lpad482

invoke.cont484:                                   ; preds = %invoke.cont481
  %m_ownsMemory.i.i1294 = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %hostContacts, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i1294, align 8
  %m_data.i.i1295 = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %hostContacts, i64 0, i32 5
  store ptr null, ptr %m_data.i.i1295, align 8
  %m_size.i.i1296 = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %hostContacts, i64 0, i32 2
  store i32 0, ptr %m_size.i.i1296, align 4
  %m_capacity.i.i1297 = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %hostContacts, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i1297, align 8
  %380 = load i32, ptr %nContacts, align 4
  %tobool485.not = icmp eq i32 %380, 0
  br i1 %tobool485.not, label %if.end489, label %if.then486

if.then486:                                       ; preds = %invoke.cont484
  invoke void @_ZNK13b3OpenCLArrayI10b3Contact4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %contactOut, ptr noundef nonnull align 8 dereferenceable(25) %hostContacts, i1 noundef zeroext true)
          to label %if.then486.if.end489_crit_edge unwind label %lpad487.loopexit.split-lp

if.then486.if.end489_crit_edge:                   ; preds = %if.then486
  %.pre6179 = load i32, ptr %m_size.i.i1296, align 4
  br label %if.end489

lpad450:                                          ; preds = %invoke.cont449
  %381 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup883

lpad453:                                          ; preds = %invoke.cont452
  %382 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup882

lpad456:                                          ; preds = %invoke.cont455
  %383 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup881

lpad459:                                          ; preds = %invoke.cont458
  %384 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup880

lpad462:                                          ; preds = %invoke.cont461
  %385 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup879

lpad465:                                          ; preds = %invoke.cont464
  %386 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup878

lpad469:                                          ; preds = %.noexc4743, %_ZNK20b3AlignedObjectArrayIiE4copyEiiPi.exit18.i, %_ZN20b3AlignedObjectArrayIiE8allocateEi.exit.i
  %387 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup877

lpad473:                                          ; preds = %.noexc4779, %_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i, %_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit.i
  %388 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup876

lpad476:                                          ; preds = %invoke.cont475
  %389 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup875

lpad479:                                          ; preds = %invoke.cont478
  %390 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup874

lpad482:                                          ; preds = %invoke.cont481
  %391 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup873

lpad487.loopexit:                                 ; preds = %invoke.cont639, %.noexc1477, %.noexc1497
  %lpad.loopexit6141 = landingpad { ptr, i32 }
          cleanup
  br label %lpad487

lpad487.loopexit.split-lp:                        ; preds = %if.then486, %if.end7.i.i, %if.then.i.i1653, %call.i.i.noexc1660, %invoke.cont864, %call.i1667.noexc, %if.end7.i.i1684, %if.then.i.i1678, %call.i.i.noexc1688, %if.end7.i.i1704, %if.then.i.i1698, %call.i.i.noexc1708, %_ZN20b3AlignedObjectArrayI10b3Contact4E8allocateEi.exit.i, %_ZNK20b3AlignedObjectArrayI10b3Contact4E4copyEiiPS0_.exit18.i, %.noexc4815, %if.then3.i.i4801
  %lpad.loopexit.split-lp6142 = landingpad { ptr, i32 }
          cleanup
  br label %lpad487

lpad487:                                          ; preds = %lpad487.loopexit.split-lp, %lpad487.loopexit
  %lpad.phi6143 = phi { ptr, i32 } [ %lpad.loopexit6141, %lpad487.loopexit ], [ %lpad.loopexit.split-lp6142, %lpad487.loopexit.split-lp ]
  call void @_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostContacts) #26
  br label %ehcleanup873

if.end489:                                        ; preds = %if.then486.if.end489_crit_edge, %invoke.cont484
  %392 = phi i32 [ %.pre6179, %if.then486.if.end489_crit_edge ], [ 0, %invoke.cont484 ]
  %393 = load i32, ptr %maxContactCapacity.addr, align 4
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(112) %ref.tmp490.sroa.0, i8 0, i64 112, i1 false)
  %cmp4.i1299 = icmp slt i32 %392, %393
  br i1 %cmp4.i1299, label %for.body9.lr.ph.i1300, label %invoke.cont491

for.body9.lr.ph.i1300:                            ; preds = %if.end489
  %394 = load i32, ptr %m_capacity.i.i1297, align 8
  %cmp.i4783 = icmp slt i32 %394, %393
  br i1 %cmp.i4783, label %if.then.i4785, label %for.body9.lr.ph.i1300..noexc1308_crit_edge

for.body9.lr.ph.i1300..noexc1308_crit_edge:       ; preds = %for.body9.lr.ph.i1300
  %.pre6180 = load ptr, ptr %m_data.i.i1295, align 8
  br label %.noexc1308

if.then.i4785:                                    ; preds = %for.body9.lr.ph.i1300
  %tobool.not.i.i4786 = icmp eq i32 %393, 0
  br i1 %tobool.not.i.i4786, label %_ZNK20b3AlignedObjectArrayI10b3Contact4E4copyEiiPS0_.exit18.i, label %_ZN20b3AlignedObjectArrayI10b3Contact4E8allocateEi.exit.i

_ZN20b3AlignedObjectArrayI10b3Contact4E8allocateEi.exit.i: ; preds = %if.then.i4785
  %conv.i.i.i4787 = sext i32 %393 to i64
  %mul.i.i.i4788 = mul nsw i64 %conv.i.i.i4787, 112
  %call.i.i.i4814 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i4788, i32 noundef 16)
          to label %call.i.i.i.noexc4813 unwind label %lpad487.loopexit.split-lp

call.i.i.i.noexc4813:                             ; preds = %_ZN20b3AlignedObjectArrayI10b3Contact4E8allocateEi.exit.i
  %cmp3.i4789 = icmp eq ptr %call.i.i.i4814, null
  br i1 %cmp3.i4789, label %_ZNK20b3AlignedObjectArrayI10b3Contact4E4copyEiiPS0_.exit18.i, label %if.then.split.i4790

if.then.split.i4790:                              ; preds = %call.i.i.i.noexc4813
  %395 = load i32, ptr %m_size.i.i1296, align 4
  %cmp4.i.i4792 = icmp sgt i32 %395, 0
  br i1 %cmp4.i.i4792, label %for.body.lr.ph.i.i4803, label %if.end.i4793

for.body.lr.ph.i.i4803:                           ; preds = %if.then.split.i4790
  %wide.trip.count.i.i4805 = zext nneg i32 %395 to i64
  %396 = load ptr, ptr %m_data.i.i1295, align 8
  br label %for.body.i.i4806

for.body.i.i4806:                                 ; preds = %for.body.i.i4806, %for.body.lr.ph.i.i4803
  %indvars.iv.i.i4807 = phi i64 [ 0, %for.body.lr.ph.i.i4803 ], [ %indvars.iv.next.i.i4810, %for.body.i.i4806 ]
  %arrayidx.i.i4808 = getelementptr inbounds %struct.b3Contact4, ptr %call.i.i.i4814, i64 %indvars.iv.i.i4807
  %arrayidx3.i.i4809 = getelementptr inbounds %struct.b3Contact4, ptr %396, i64 %indvars.iv.i.i4807
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(112) %arrayidx.i.i4808, ptr noundef nonnull align 16 dereferenceable(112) %arrayidx3.i.i4809, i64 112, i1 false)
  %indvars.iv.next.i.i4810 = add nuw nsw i64 %indvars.iv.i.i4807, 1
  %exitcond.not.i.i4811 = icmp eq i64 %indvars.iv.next.i.i4810, %wide.trip.count.i.i4805
  br i1 %exitcond.not.i.i4811, label %if.then.i22.i4798, label %for.body.i.i4806, !llvm.loop !65

_ZNK20b3AlignedObjectArrayI10b3Contact4E4copyEiiPS0_.exit18.i: ; preds = %call.i.i.i.noexc4813, %if.then.i4785
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc4815 unwind label %lpad487.loopexit.split-lp

.noexc4815:                                       ; preds = %_ZNK20b3AlignedObjectArrayI10b3Contact4E4copyEiiPS0_.exit18.i
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc4816 unwind label %lpad487.loopexit.split-lp

.noexc4816:                                       ; preds = %.noexc4815
  store i32 0, ptr %m_size.i.i1296, align 4
  br label %if.end.i4793

if.end.i4793:                                     ; preds = %.noexc4816, %if.then.split.i4790
  %retval.0.i25.i4794.ph = phi ptr [ %call.i.i.i4814, %if.then.split.i4790 ], [ null, %.noexc4816 ]
  %_Count.addr.0.i4795.ph = phi i32 [ %393, %if.then.split.i4790 ], [ 0, %.noexc4816 ]
  %.pr = load ptr, ptr %m_data.i.i1295, align 8
  %tobool.not.i21.i4797 = icmp eq ptr %.pr, null
  br i1 %tobool.not.i21.i4797, label %_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv.exit.i, label %if.then.i22.i4798

if.then.i22.i4798:                                ; preds = %for.body.i.i4806, %if.end.i4793
  %_Count.addr.0.i47956078 = phi i32 [ %_Count.addr.0.i4795.ph, %if.end.i4793 ], [ %393, %for.body.i.i4806 ]
  %retval.0.i25.i47946076 = phi ptr [ %retval.0.i25.i4794.ph, %if.end.i4793 ], [ %call.i.i.i4814, %for.body.i.i4806 ]
  %397 = phi ptr [ %.pr, %if.end.i4793 ], [ %396, %for.body.i.i4806 ]
  %398 = load i8, ptr %m_ownsMemory.i.i1294, align 8
  %399 = and i8 %398, 1
  %tobool2.not.i.i4800 = icmp eq i8 %399, 0
  br i1 %tobool2.not.i.i4800, label %_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv.exit.i, label %if.then3.i.i4801

if.then3.i.i4801:                                 ; preds = %if.then.i22.i4798
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %397)
          to label %_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv.exit.i unwind label %lpad487.loopexit.split-lp

_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv.exit.i: ; preds = %if.then3.i.i4801, %if.then.i22.i4798, %if.end.i4793
  %_Count.addr.0.i47956079 = phi i32 [ %_Count.addr.0.i47956078, %if.then.i22.i4798 ], [ %_Count.addr.0.i4795.ph, %if.end.i4793 ], [ %_Count.addr.0.i47956078, %if.then3.i.i4801 ]
  %retval.0.i25.i47946077 = phi ptr [ %retval.0.i25.i47946076, %if.then.i22.i4798 ], [ %retval.0.i25.i4794.ph, %if.end.i4793 ], [ %retval.0.i25.i47946076, %if.then3.i.i4801 ]
  store i8 1, ptr %m_ownsMemory.i.i1294, align 8
  store ptr %retval.0.i25.i47946077, ptr %m_data.i.i1295, align 8
  store i32 %_Count.addr.0.i47956079, ptr %m_capacity.i.i1297, align 8
  br label %.noexc1308

.noexc1308:                                       ; preds = %for.body9.lr.ph.i1300..noexc1308_crit_edge, %_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv.exit.i
  %400 = phi ptr [ %.pre6180, %for.body9.lr.ph.i1300..noexc1308_crit_edge ], [ %retval.0.i25.i47946077, %_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv.exit.i ]
  %401 = sext i32 %392 to i64
  %wide.trip.count.i1302 = sext i32 %393 to i64
  br label %for.body9.i1303

for.body9.i1303:                                  ; preds = %for.body9.i1303, %.noexc1308
  %indvars.iv.i1304 = phi i64 [ %401, %.noexc1308 ], [ %indvars.iv.next.i1306, %for.body9.i1303 ]
  %arrayidx12.i1305 = getelementptr inbounds %struct.b3Contact4, ptr %400, i64 %indvars.iv.i1304
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(112) %arrayidx12.i1305, ptr noundef nonnull align 16 dereferenceable(112) %ref.tmp490.sroa.0, i64 112, i1 false)
  %indvars.iv.next.i1306 = add nsw i64 %indvars.iv.i1304, 1
  %exitcond.not.i1307 = icmp eq i64 %indvars.iv.next.i1306, %wide.trip.count.i1302
  br i1 %exitcond.not.i1307, label %invoke.cont491, label %for.body9.i1303, !llvm.loop !66

invoke.cont491:                                   ; preds = %for.body9.i1303, %if.end489
  store i32 %393, ptr %m_size.i.i1296, align 4
  %402 = load i32, ptr %nContacts, align 4
  %403 = load i32, ptr %nPairs.addr, align 4
  %cmp4926149 = icmp sgt i32 %403, 0
  br i1 %cmp4926149, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %invoke.cont491
  %tr.sroa.23.48.translation.sroa_idx.i = getelementptr inbounds i8, ptr %posA, i64 4
  %tr.sroa.24.48.translation.sroa_idx.i = getelementptr inbounds i8, ptr %posA, i64 8
  %arrayidx2.i.i.i.i.i = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 1
  %arrayidx5.i.i.i.i.i = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 2
  %arrayidx7.i.i.i.i.i = getelementptr inbounds [4 x float], ptr %ornA, i64 0, i64 3
  %tr.sroa.23.48.translation.sroa_idx.i1365 = getelementptr inbounds i8, ptr %posB, i64 4
  %tr.sroa.24.48.translation.sroa_idx.i1367 = getelementptr inbounds i8, ptr %posB, i64 8
  %arrayidx2.i.i.i.i.i1369 = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 1
  %arrayidx5.i.i.i.i.i1371 = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 2
  %arrayidx7.i.i.i.i.i1372 = getelementptr inbounds [4 x float], ptr %ornB, i64 0, i64 3
  %404 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %DeltaC2, i64 0, i32 1
  %405 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %sepAxis2, i64 0, i32 1
  %z = getelementptr inbounds %struct.anon.2, ptr %dirOut, i64 0, i32 2
  %resultPointOnBWorld.sroa.3.0.posOut.sroa_idx = getelementptr inbounds i8, ptr %posOut, i64 8
  %arrayidx.i26.i.i.i = getelementptr inbounds [4 x float], ptr %sepAxis2, i64 0, i64 1
  %406 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %DeltaC2781, i64 0, i32 1
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %indvars.iv6167 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next6168, %for.inc ]
  %nGlobalContactsOut.06150 = phi i32 [ %402, %for.body.lr.ph ], [ %nGlobalContactsOut.1, %for.inc ]
  %407 = load ptr, ptr %m_data.i.i1237, align 8
  %arrayidx.i = getelementptr inbounds %struct.b3Int4, ptr %407, i64 %indvars.iv6167
  %408 = load i32, ptr %arrayidx.i, align 16
  %y = getelementptr inbounds %struct.anon, ptr %arrayidx.i, i64 0, i32 1
  %409 = load i32, ptr %y, align 4
  %410 = load ptr, ptr %m_data.i.i1241, align 8
  %idxprom.i1313 = sext i32 %408 to i64
  %m_collidableIdx = getelementptr inbounds %struct.b3RigidBodyData, ptr %410, i64 %idxprom.i1313, i32 4
  %411 = load i32, ptr %m_collidableIdx, align 16
  %idxprom.i1316 = sext i32 %409 to i64
  %m_collidableIdx501 = getelementptr inbounds %struct.b3RigidBodyData, ptr %410, i64 %idxprom.i1316, i32 4
  %412 = load i32, ptr %m_collidableIdx501, align 16
  %413 = load ptr, ptr %m_data.i.i1245, align 8
  %idxprom.i1319 = sext i32 %411 to i64
  %414 = getelementptr inbounds %struct.b3Collidable, ptr %413, i64 %idxprom.i1319, i32 3
  %415 = load i32, ptr %414, align 4
  %idxprom.i1322 = sext i32 %412 to i64
  %416 = getelementptr inbounds %struct.b3Collidable, ptr %413, i64 %idxprom.i1322, i32 3
  %417 = load i32, ptr %416, align 4
  %418 = load ptr, ptr %m_data.i.i1261, align 8
  %arrayidx.i1326 = getelementptr inbounds i32, ptr %418, i64 %indvars.iv6167
  store i32 0, ptr %arrayidx.i1326, align 4
  %419 = load ptr, ptr %m_data.i.i1241, align 8
  %arrayidx.i1329 = getelementptr inbounds %struct.b3RigidBodyData, ptr %419, i64 %idxprom.i1313
  %m_invMass = getelementptr inbounds %struct.b3RigidBodyData, ptr %419, i64 %idxprom.i1313, i32 5
  %420 = load float, ptr %m_invMass, align 4
  %cmp510 = fcmp oeq float %420, 0.000000e+00
  br i1 %cmp510, label %land.lhs.true, label %if.end516

land.lhs.true:                                    ; preds = %for.body
  %m_invMass513 = getelementptr inbounds %struct.b3RigidBodyData, ptr %419, i64 %idxprom.i1316, i32 5
  %421 = load float, ptr %m_invMass513, align 4
  %cmp514 = fcmp oeq float %421, 0.000000e+00
  br i1 %cmp514, label %for.inc, label %if.end516

if.end516:                                        ; preds = %land.lhs.true, %for.body
  %422 = load ptr, ptr %m_data.i.i1245, align 8
  %m_shapeType = getelementptr inbounds %struct.b3Collidable, ptr %422, i64 %idxprom.i1319, i32 2
  %423 = load i32, ptr %m_shapeType, align 4
  %cmp519.not = icmp eq i32 %423, 3
  br i1 %cmp519.not, label %lor.lhs.false, label %for.inc

lor.lhs.false:                                    ; preds = %if.end516
  %m_shapeType522 = getelementptr inbounds %struct.b3Collidable, ptr %422, i64 %idxprom.i1322, i32 2
  %424 = load i32, ptr %m_shapeType522, align 4
  %cmp523.not = icmp eq i32 %424, 3
  br i1 %cmp523.not, label %if.end525, label %for.inc

if.end525:                                        ; preds = %lor.lhs.false
  store float 0x47EFFFFFE0000000, ptr %dmin, align 4
  %425 = load ptr, ptr %m_data.i.i1253, align 8
  %idxprom.i1340 = sext i32 %415 to i64
  %arrayidx.i1341 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %425, i64 %idxprom.i1340
  %idxprom.i1343 = sext i32 %417 to i64
  %arrayidx.i1344 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %425, i64 %idxprom.i1343
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx.i1329, i64 16, i1 false)
  %arrayidx.i1350 = getelementptr inbounds %struct.b3RigidBodyData, ptr %419, i64 %idxprom.i1316
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx.i1350, i64 16, i1 false)
  %m_quat = getelementptr inbounds %struct.b3RigidBodyData, ptr %419, i64 %idxprom.i1313, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %m_quat, i64 16, i1 false)
  %m_quat539 = getelementptr inbounds %struct.b3RigidBodyData, ptr %419, i64 %idxprom.i1316, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %m_quat539, i64 16, i1 false)
  %426 = load i8, ptr @useGjk, align 1
  %427 = and i8 %426, 1
  %tobool540.not = icmp eq i8 %427, 0
  %c0local763.sroa.0.0.copyload = load float, ptr %arrayidx.i1341, align 16
  %c0local763.sroa.2.0.arrayidx.i1511.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i1341, i64 4
  %c0local763.sroa.2.0.copyload = load float, ptr %c0local763.sroa.2.0.arrayidx.i1511.sroa_idx, align 4
  %c0local763.sroa.3.0.arrayidx.i1511.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i1341, i64 8
  %c0local763.sroa.3.0.copyload = load float, ptr %c0local763.sroa.3.0.arrayidx.i1511.sroa_idx, align 8
  %tr.sroa.21.48.copyload.i1512 = load float, ptr %posA, align 16
  %tr.sroa.23.48.copyload.i1514 = load float, ptr %tr.sroa.23.48.translation.sroa_idx.i, align 4
  %tr.sroa.24.48.copyload.i1516 = load float, ptr %tr.sroa.24.48.translation.sroa_idx.i, align 8
  %428 = load float, ptr %ornA, align 16
  %429 = load float, ptr %arrayidx2.i.i.i.i.i, align 4
  %430 = load float, ptr %arrayidx5.i.i.i.i.i, align 8
  %431 = load float, ptr %arrayidx7.i.i.i.i.i, align 4
  %c1local772.sroa.0.0.copyload = load float, ptr %arrayidx.i1344, align 16
  %c1local772.sroa.2.0.arrayidx.i1561.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i1344, i64 4
  %c1local772.sroa.2.0.copyload = load float, ptr %c1local772.sroa.2.0.arrayidx.i1561.sroa_idx, align 4
  %c1local772.sroa.3.0.arrayidx.i1561.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i1344, i64 8
  %c1local772.sroa.3.0.copyload = load float, ptr %c1local772.sroa.3.0.arrayidx.i1561.sroa_idx, align 8
  %tr.sroa.21.48.copyload.i1562 = load float, ptr %posB, align 16
  %tr.sroa.23.48.copyload.i1564 = load float, ptr %tr.sroa.23.48.translation.sroa_idx.i1365, align 4
  %tr.sroa.24.48.copyload.i1566 = load float, ptr %tr.sroa.24.48.translation.sroa_idx.i1367, align 8
  %432 = load float, ptr %ornB, align 16
  %433 = load float, ptr %arrayidx2.i.i.i.i.i1369, align 4
  %434 = load float, ptr %arrayidx5.i.i.i.i.i1371, align 8
  %435 = load float, ptr %arrayidx7.i.i.i.i.i1372, align 4
  %436 = insertelement <2 x float> poison, float %429, i64 0
  %437 = insertelement <2 x float> %436, float %433, i64 1
  %438 = fmul <2 x float> %437, %437
  %439 = insertelement <2 x float> poison, float %428, i64 0
  %440 = insertelement <2 x float> %439, float %432, i64 1
  %441 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %440, <2 x float> %440, <2 x float> %438)
  %442 = insertelement <2 x float> poison, float %430, i64 0
  %443 = insertelement <2 x float> %442, float %434, i64 1
  %444 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %443, <2 x float> %443, <2 x float> %441)
  %445 = insertelement <2 x float> poison, float %431, i64 0
  %446 = insertelement <2 x float> %445, float %435, i64 1
  %447 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %446, <2 x float> %446, <2 x float> %444)
  %448 = fdiv <2 x float> <float 2.000000e+00, float 2.000000e+00>, %447
  %449 = fmul <2 x float> %443, %448
  %450 = fmul <2 x float> %437, %448
  %451 = fmul <2 x float> %437, %450
  %452 = fmul <2 x float> %446, %450
  %453 = fmul <2 x float> %440, %449
  %454 = fmul <2 x float> %440, %448
  %455 = fmul <2 x float> %440, %454
  %456 = fmul <2 x float> %446, %454
  %457 = fmul <2 x float> %437, %449
  %458 = fsub <2 x float> %453, %452
  %459 = fadd <2 x float> %457, %456
  %460 = fadd <2 x float> %455, %451
  %461 = fsub <2 x float> <float 1.000000e+00, float 1.000000e+00>, %460
  %462 = insertelement <2 x float> poison, float %c0local763.sroa.2.0.copyload, i64 0
  %463 = insertelement <2 x float> %462, float %c1local772.sroa.2.0.copyload, i64 1
  %464 = fmul <2 x float> %463, %459
  %465 = insertelement <2 x float> poison, float %c0local763.sroa.0.0.copyload, i64 0
  %466 = insertelement <2 x float> %465, float %c1local772.sroa.0.0.copyload, i64 1
  %467 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %466, <2 x float> %458, <2 x float> %464)
  %468 = insertelement <2 x float> poison, float %c0local763.sroa.3.0.copyload, i64 0
  %469 = insertelement <2 x float> %468, float %c1local772.sroa.3.0.copyload, i64 1
  %470 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %469, <2 x float> %461, <2 x float> %467)
  %471 = fmul <2 x float> %443, %449
  %472 = fmul <2 x float> %446, %449
  %473 = fmul <2 x float> %440, %450
  %474 = fadd <2 x float> %473, %472
  %475 = fadd <2 x float> %455, %471
  %476 = fsub <2 x float> <float 1.000000e+00, float 1.000000e+00>, %475
  %477 = fsub <2 x float> %457, %456
  %478 = fmul <2 x float> %463, %476
  %479 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %466, <2 x float> %474, <2 x float> %478)
  %480 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %469, <2 x float> %477, <2 x float> %479)
  %481 = fadd <2 x float> %453, %452
  %482 = fadd <2 x float> %451, %471
  %483 = fsub <2 x float> <float 1.000000e+00, float 1.000000e+00>, %482
  %484 = fsub <2 x float> %473, %472
  %485 = fmul <2 x float> %463, %484
  %486 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %466, <2 x float> %483, <2 x float> %485)
  %487 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %469, <2 x float> %481, <2 x float> %486)
  %488 = insertelement <2 x float> poison, float %tr.sroa.21.48.copyload.i1512, i64 0
  %489 = insertelement <2 x float> %488, float %tr.sroa.21.48.copyload.i1562, i64 1
  %490 = fadd <2 x float> %489, %487
  %491 = insertelement <2 x float> poison, float %tr.sroa.23.48.copyload.i1514, i64 0
  %492 = insertelement <2 x float> %491, float %tr.sroa.23.48.copyload.i1564, i64 1
  %493 = fadd <2 x float> %492, %480
  %494 = insertelement <2 x float> poison, float %tr.sroa.24.48.copyload.i1516, i64 0
  %495 = insertelement <2 x float> %494, float %tr.sroa.24.48.copyload.i1566, i64 1
  %496 = fadd <2 x float> %495, %470
  %shift = shufflevector <2 x float> %490, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %497 = fsub <2 x float> %490, %shift
  %shift6290 = shufflevector <2 x float> %493, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %498 = fsub <2 x float> %493, %shift6290
  %shift6291 = shufflevector <2 x float> %496, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %499 = fsub <2 x float> %496, %shift6291
  %retval.sroa.0.4.vec.insert.i.i1617 = shufflevector <2 x float> %497, <2 x float> %498, <2 x i32> <i32 0, i32 2>
  %retval.sroa.3.12.vec.insert.i.i16186292 = insertelement <2 x float> %499, float 0.000000e+00, i64 1
  br i1 %tobool540.not, label %invoke.cont782, label %invoke.cont554

invoke.cont554:                                   ; preds = %if.end525
  store <2 x float> %retval.sroa.0.4.vec.insert.i.i1617, ptr %DeltaC2, align 16
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i16186292, ptr %404, align 8
  %500 = load ptr, ptr %m_data.i.i1257, align 8
  %501 = load ptr, ptr %m_data.i.i1283, align 8
  %502 = load ptr, ptr %m_data.i.i1287, align 8
  %call575 = call noundef zeroext i1 @_Z20b3FindSeparatingAxisPK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_Pf(ptr noundef nonnull %arrayidx.i1341, ptr noundef nonnull %arrayidx.i1344, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %DeltaC2, ptr noundef nonnull %500, ptr nonnull poison, ptr noundef nonnull %502, ptr nonnull poison, ptr noundef nonnull %500, ptr nonnull poison, ptr nonnull poison, ptr nonnull poison, ptr noundef nonnull %sepAxis, ptr noundef nonnull %dmin)
  br i1 %call575, label %if.then577, label %if.end628

if.then577:                                       ; preds = %invoke.cont554
  %call595 = call noundef zeroext i1 @_Z20b3FindSeparatingAxisPK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_Pf(ptr noundef nonnull %arrayidx.i1344, ptr noundef nonnull %arrayidx.i1341, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %DeltaC2, ptr noundef nonnull %500, ptr nonnull poison, ptr noundef nonnull %502, ptr nonnull poison, ptr noundef nonnull %500, ptr nonnull poison, ptr nonnull poison, ptr nonnull poison, ptr noundef nonnull %sepAxis, ptr noundef nonnull %dmin)
  br i1 %call595, label %if.then598, label %if.end628

if.then598:                                       ; preds = %if.then577
  %call616 = call noundef zeroext i1 @_Z28b3FindSeparatingAxisEdgeEdgePK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_Pfb(ptr noundef nonnull %arrayidx.i1341, ptr noundef nonnull %arrayidx.i1344, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %DeltaC2, ptr noundef nonnull %500, ptr noundef nonnull %501, ptr nonnull poison, ptr nonnull poison, ptr noundef nonnull %500, ptr noundef nonnull %501, ptr nonnull poison, ptr nonnull poison, ptr noundef nonnull %sepAxis, ptr noundef nonnull %dmin, i1 noundef zeroext false)
  br i1 %call616, label %if.then619, label %if.end628

if.then619:                                       ; preds = %if.then598
  %503 = load ptr, ptr %m_data.i.i1261, align 8
  %arrayidx.i1437 = getelementptr inbounds i32, ptr %503, i64 %indvars.iv6167
  store i32 1, ptr %arrayidx.i1437, align 4
  %504 = load ptr, ptr %m_data.i.i1268, align 8
  %arrayidx.i1440 = getelementptr inbounds %class.b3Vector3, ptr %504, i64 %indvars.iv6167
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx.i1440, ptr noundef nonnull align 16 dereferenceable(16) %sepAxis, i64 16, i1 false)
  %505 = load float, ptr %dmin, align 4
  %w = getelementptr inbounds %class.b3Vector3, ptr %504, i64 %indvars.iv6167, i32 0, i32 0, i64 3
  store float %505, ptr %w, align 4
  br label %if.end628

if.end628:                                        ; preds = %if.then577, %if.then619, %if.then598, %invoke.cont554
  %506 = load ptr, ptr %m_data.i.i1261, align 8
  %arrayidx.i1446 = getelementptr inbounds i32, ptr %506, i64 %indvars.iv6167
  %507 = load i32, ptr %arrayidx.i1446, align 4
  %tobool631.not = icmp eq i32 %507, 0
  br i1 %tobool631.not, label %for.inc, label %invoke.cont639

invoke.cont639:                                   ; preds = %if.end628
  store <2 x float> <float 1.000000e+00, float 0.000000e+00>, ptr %sepAxis2, align 16
  store <2 x float> zeroinitializer, ptr %405, align 8
  %508 = load ptr, ptr %m_data.i.i1241, align 8
  %509 = load ptr, ptr %m_data.i.i1253, align 8
  %510 = load ptr, ptr %m_data.i.i1245, align 8
  %511 = load ptr, ptr %m_data.i.i1257, align 8
  %512 = load ptr, ptr %m_data.i.i1268, align 8
  %513 = trunc i64 %indvars.iv6167 to i32
  %call656 = invoke noundef i32 @_Z16b3MprPenetrationiiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_PiPfSB_SB_(i32 noundef %513, i32 noundef %408, i32 noundef %409, ptr noundef nonnull %508, ptr noundef nonnull %509, ptr noundef nonnull %510, ptr noundef nonnull %511, ptr noundef nonnull %512, ptr noundef nonnull %506, ptr noundef nonnull %depthOut, ptr noundef nonnull %dirOut, ptr noundef nonnull %posOut)
          to label %invoke.cont662 unwind label %lpad487.loopexit

invoke.cont662:                                   ; preds = %invoke.cont639
  %514 = load float, ptr %depthOut, align 4
  %515 = load <2 x float>, ptr %dirOut, align 16
  %516 = fneg <2 x float> %515
  %517 = load float, ptr %z, align 8
  %fneg661 = fneg float %517
  %retval.sroa.3.12.vec.insert.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %fneg661, i64 0
  store <2 x float> %516, ptr %sepAxis2, align 16
  store <2 x float> %retval.sroa.3.12.vec.insert.i, ptr %405, align 8
  %resultPointOnBWorld.sroa.0.0.copyload = load <2 x float>, ptr %posOut, align 16
  %resultPointOnBWorld.sroa.3.0.copyload = load <2 x float>, ptr %resultPointOnBWorld.sroa.3.0.posOut.sroa_idx, align 8
  %cmp666 = icmp eq i32 %call656, 0
  br i1 %cmp666, label %if.then667, label %for.inc

if.then667:                                       ; preds = %invoke.cont662
  %518 = load ptr, ptr %m_data.i.i1241, align 8
  %m_collidableIdx670 = getelementptr inbounds %struct.b3RigidBodyData, ptr %518, i64 %idxprom.i1313, i32 4
  %519 = load i32, ptr %m_collidableIdx670, align 16
  %520 = load ptr, ptr %m_data.i.i1245, align 8
  %idxprom.i1457 = sext i32 %519 to i64
  %521 = getelementptr inbounds %struct.b3Collidable, ptr %520, i64 %idxprom.i1457, i32 3
  %522 = load i32, ptr %521, align 4
  %523 = load ptr, ptr %m_data.i.i1253, align 8
  %idxprom.i1460 = sext i32 %522 to i64
  %m_collidableIdx677 = getelementptr inbounds %struct.b3RigidBodyData, ptr %518, i64 %idxprom.i1316, i32 4
  %524 = load i32, ptr %m_collidableIdx677, align 16
  %idxprom.i1466 = sext i32 %524 to i64
  %525 = getelementptr inbounds %struct.b3Collidable, ptr %520, i64 %idxprom.i1466, i32 3
  %526 = load i32, ptr %525, align 4
  %idxprom.i1469 = sext i32 %526 to i64
  %arrayidx.i1470 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %523, i64 %idxprom.i1469
  %527 = load ptr, ptr %m_data.i.i1257, align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %Min1.i)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %Max1.i)
  %m_numVertices.i = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %523, i64 %idxprom.i1460, i32 7
  %528 = load i32, ptr %m_numVertices.i, align 4
  %fneg.i.i.i = fneg float %428
  %fneg4.i.i.i = fneg float %429
  %fneg7.i.i.i = fneg float %430
  %mul4.i.i.i4818 = fmul float %517, %429
  %529 = extractelement <2 x float> %516, i64 0
  %530 = call float @llvm.fmuladd.f32(float %431, float %529, float %mul4.i.i.i4818)
  %531 = extractelement <2 x float> %516, i64 1
  %532 = call float @llvm.fmuladd.f32(float %430, float %531, float %530)
  %533 = extractelement <2 x float> %515, i64 0
  %mul12.i.i.i4819 = fmul float %533, %430
  %534 = call float @llvm.fmuladd.f32(float %431, float %531, float %mul12.i.i.i4819)
  %535 = call float @llvm.fmuladd.f32(float %428, float %fneg661, float %534)
  %536 = extractelement <2 x float> %515, i64 1
  %mul21.i.i.i = fmul float %536, %428
  %537 = call float @llvm.fmuladd.f32(float %431, float %fneg661, float %mul21.i.i.i)
  %538 = call float @llvm.fmuladd.f32(float %429, float %529, float %537)
  %neg31.i.i.i = fmul float %429, %531
  %539 = call float @llvm.fmuladd.f32(float %428, float %529, float %neg31.i.i.i)
  %540 = call float @llvm.fmuladd.f32(float %430, float %fneg661, float %539)
  %mul4.i9.i.i = fmul float %431, %532
  %541 = call float @llvm.fmuladd.f32(float %540, float %428, float %mul4.i9.i.i)
  %542 = call float @llvm.fmuladd.f32(float %535, float %430, float %541)
  %543 = call float @llvm.fmuladd.f32(float %538, float %fneg4.i.i.i, float %542)
  %mul14.i.i.i4820 = fmul float %431, %535
  %544 = call float @llvm.fmuladd.f32(float %540, float %429, float %mul14.i.i.i4820)
  %545 = call float @llvm.fmuladd.f32(float %538, float %428, float %544)
  %546 = call float @llvm.fmuladd.f32(float %532, float %fneg7.i.i.i, float %545)
  %mul25.i.i.i = fmul float %431, %538
  %547 = call float @llvm.fmuladd.f32(float %540, float %430, float %mul25.i.i.i)
  %548 = call float @llvm.fmuladd.f32(float %532, float %429, float %547)
  %549 = call float @llvm.fmuladd.f32(float %535, float %fneg.i.i.i, float %548)
  %cmp29.i = icmp sgt i32 %528, 0
  br i1 %cmp29.i, label %for.body.lr.ph.i, label %.noexc1477

for.body.lr.ph.i:                                 ; preds = %if.then667
  %m_vertexOffset.i = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %523, i64 %idxprom.i1460, i32 8
  %550 = load i32, ptr %m_vertexOffset.i, align 16
  %551 = sext i32 %550 to i64
  %552 = zext nneg i32 %528 to i64
  %invariant.gep = getelementptr %class.b3Vector3, ptr %527, i64 %551
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %for.body.lr.ph.i
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body.i ], [ 0, %for.body.lr.ph.i ]
  %Max0.i.0 = phi float [ %Max0.i.1, %for.body.i ], [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i ]
  %Min0.i.0 = phi float [ %Min0.i.1, %for.body.i ], [ 0x47EFFFFFE0000000, %for.body.lr.ph.i ]
  %553 = phi float [ %560, %for.body.i ], [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i ]
  %gep = getelementptr %class.b3Vector3, ptr %invariant.gep, i64 %indvars.iv
  %554 = load float, ptr %gep, align 16
  %arrayidx3.i.i24.i = getelementptr inbounds [4 x float], ptr %gep, i64 0, i64 1
  %555 = load float, ptr %arrayidx3.i.i24.i, align 4
  %mul5.i.i26.i = fmul float %546, %555
  %556 = call float @llvm.fmuladd.f32(float %554, float %543, float %mul5.i.i26.i)
  %arrayidx6.i.i27.i = getelementptr inbounds [4 x float], ptr %gep, i64 0, i64 2
  %557 = load float, ptr %arrayidx6.i.i27.i, align 8
  %558 = call noundef float @llvm.fmuladd.f32(float %557, float %549, float %556)
  %cmp11.i = fcmp olt float %558, %Min0.i.0
  %Min0.i.1 = select i1 %cmp11.i, float %558, float %Min0.i.0
  %559 = select i1 %cmp11.i, float %Max0.i.0, float %553
  %cmp14.i = fcmp ogt float %558, %559
  %Max0.i.1 = select i1 %cmp14.i, float %558, float %Max0.i.0
  %560 = select i1 %cmp14.i, float %558, float %559
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not.i4825 = icmp eq i64 %indvars.iv.next, %552
  br i1 %exitcond.not.i4825, label %for.end.i, label %for.body.i, !llvm.loop !9

for.end.i:                                        ; preds = %for.body.i
  %cmp20.i = fcmp ogt float %Min0.i.1, %560
  br i1 %cmp20.i, label %if.then21.i, label %.noexc1477

if.then21.i:                                      ; preds = %for.end.i
  br label %.noexc1477

.noexc1477:                                       ; preds = %if.then667, %if.then21.i, %for.end.i
  %Max0.i.3 = phi float [ %Max0.i.1, %for.end.i ], [ %Min0.i.1, %if.then21.i ], [ 0x47EFFFFFE0000000, %if.then667 ]
  %561 = phi float [ %Min0.i.1, %for.end.i ], [ %560, %if.then21.i ], [ 0xC7EFFFFFE0000000, %if.then667 ]
  %mul5.i.i.i = fmul float %tr.sroa.23.48.copyload.i1514, %531
  %562 = call float @llvm.fmuladd.f32(float %tr.sroa.21.48.copyload.i1512, float %529, float %mul5.i.i.i)
  %563 = call noundef float @llvm.fmuladd.f32(float %tr.sroa.24.48.copyload.i1516, float %fneg661, float %562)
  %add28.i = fadd float %563, %561
  %add30.i = fadd float %563, %Max0.i.3
  invoke void @_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_(ptr noundef nonnull %arrayidx.i1470, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull %sepAxis2, ptr noundef %527, ptr noundef nonnull %Min1.i, ptr noundef nonnull %Max1.i)
          to label %.noexc1478 unwind label %lpad487.loopexit

.noexc1478:                                       ; preds = %.noexc1477
  %564 = load float, ptr %Min1.i, align 4
  %cmp.i1473 = fcmp olt float %add30.i, %564
  br i1 %cmp.i1473, label %invoke.cont686.thread, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %.noexc1478
  %565 = load float, ptr %Max1.i, align 4
  %cmp1.i = fcmp olt float %565, %add28.i
  br i1 %cmp1.i, label %invoke.cont686.thread, label %if.then688

invoke.cont686.thread:                            ; preds = %lor.lhs.false.i, %.noexc1478
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %Min1.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %Max1.i)
  br label %if.end698

if.then688:                                       ; preds = %lor.lhs.false.i
  %sub.i1475 = fsub float %add30.i, %564
  %sub2.i = fsub float %565, %add28.i
  %cmp3.i1476 = fcmp olt float %sub.i1475, %sub2.i
  %cond.i = select i1 %cmp3.i1476, float %sub.i1475, float %sub2.i
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %Min1.i)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %Max1.i)
  %cmp689 = fcmp ogt float %514, %cond.i
  br i1 %cmp689, label %if.then690, label %if.end698

if.then690:                                       ; preds = %if.then688
  %sub = fsub float %514, %cond.i
  %566 = load float, ptr @_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E7maxdiff, align 4
  %cmp691 = fcmp olt float %566, %sub
  br i1 %cmp691, label %if.then692, label %if.end698

if.then692:                                       ; preds = %if.then690
  store float %sub, ptr @_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E7maxdiff, align 4
  %conv693 = fpext float %sub to double
  %call695 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.44, double noundef %conv693)
  br label %if.end698

if.end698:                                        ; preds = %invoke.cont686.thread, %if.then688, %if.then692, %if.then690
  %567 = load float, ptr %dmin, align 4
  %cmp699 = fcmp ogt float %514, %567
  br i1 %cmp699, label %if.then700, label %if.end703

if.then700:                                       ; preds = %if.end698
  %arrayidx.i1481 = getelementptr inbounds %class.b3Vector3, ptr %512, i64 %indvars.iv6167
  call void @llvm.memmove.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %sepAxis2, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx.i1481, i64 16, i1 false)
  br label %if.end703

if.end703:                                        ; preds = %if.then700, %if.end698
  %depth.0 = phi float [ %567, %if.then700 ], [ %514, %if.end698 ]
  %568 = load ptr, ptr %m_data.i.i1257, align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %Min1.i1486)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %Max1.i1487)
  %569 = load i32, ptr %m_numVertices.i, align 4
  %570 = load float, ptr %sepAxis2, align 16
  %571 = load float, ptr %405, align 8
  %mul4.i.i.i4836 = fmul float %571, %fneg4.i.i.i
  %572 = call float @llvm.fmuladd.f32(float %431, float %570, float %mul4.i.i.i4836)
  %573 = load float, ptr %arrayidx.i26.i.i.i, align 4
  %574 = call float @llvm.fmuladd.f32(float %430, float %573, float %572)
  %mul12.i.i.i4838 = fmul float %570, %fneg7.i.i.i
  %575 = call float @llvm.fmuladd.f32(float %431, float %573, float %mul12.i.i.i4838)
  %576 = call float @llvm.fmuladd.f32(float %428, float %571, float %575)
  %mul21.i.i.i4839 = fmul float %573, %fneg.i.i.i
  %577 = call float @llvm.fmuladd.f32(float %431, float %571, float %mul21.i.i.i4839)
  %578 = call float @llvm.fmuladd.f32(float %429, float %570, float %577)
  %neg31.i.i.i4840 = fmul float %429, %573
  %579 = call float @llvm.fmuladd.f32(float %428, float %570, float %neg31.i.i.i4840)
  %580 = call float @llvm.fmuladd.f32(float %430, float %571, float %579)
  %mul4.i9.i.i4841 = fmul float %431, %574
  %581 = call float @llvm.fmuladd.f32(float %580, float %428, float %mul4.i9.i.i4841)
  %582 = call float @llvm.fmuladd.f32(float %576, float %430, float %581)
  %583 = call float @llvm.fmuladd.f32(float %578, float %fneg4.i.i.i, float %582)
  %mul14.i.i.i4842 = fmul float %431, %576
  %584 = call float @llvm.fmuladd.f32(float %580, float %429, float %mul14.i.i.i4842)
  %585 = call float @llvm.fmuladd.f32(float %578, float %428, float %584)
  %586 = call float @llvm.fmuladd.f32(float %574, float %fneg7.i.i.i, float %585)
  %mul25.i.i.i4843 = fmul float %431, %578
  %587 = call float @llvm.fmuladd.f32(float %580, float %430, float %mul25.i.i.i4843)
  %588 = call float @llvm.fmuladd.f32(float %574, float %429, float %587)
  %589 = call float @llvm.fmuladd.f32(float %576, float %fneg.i.i.i, float %588)
  %cmp29.i4846 = icmp sgt i32 %569, 0
  br i1 %cmp29.i4846, label %for.body.lr.ph.i4854, label %.noexc1497

for.body.lr.ph.i4854:                             ; preds = %if.end703
  %m_vertexOffset.i4855 = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %523, i64 %idxprom.i1460, i32 8
  %590 = load i32, ptr %m_vertexOffset.i4855, align 16
  %591 = sext i32 %590 to i64
  %592 = zext nneg i32 %569 to i64
  %invariant.gep6287 = getelementptr %class.b3Vector3, ptr %568, i64 %591
  br label %for.body.i4856

for.body.i4856:                                   ; preds = %for.body.i4856, %for.body.lr.ph.i4854
  %indvars.iv6163 = phi i64 [ %indvars.iv.next6164, %for.body.i4856 ], [ 0, %for.body.lr.ph.i4854 ]
  %Max0.i1485.0 = phi float [ %Max0.i1485.1, %for.body.i4856 ], [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i4854 ]
  %Min0.i1484.0 = phi float [ %Min0.i1484.1, %for.body.i4856 ], [ 0x47EFFFFFE0000000, %for.body.lr.ph.i4854 ]
  %593 = phi float [ %600, %for.body.i4856 ], [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i4854 ]
  %gep6288 = getelementptr %class.b3Vector3, ptr %invariant.gep6287, i64 %indvars.iv6163
  %594 = load float, ptr %gep6288, align 16
  %arrayidx3.i.i24.i4861 = getelementptr inbounds [4 x float], ptr %gep6288, i64 0, i64 1
  %595 = load float, ptr %arrayidx3.i.i24.i4861, align 4
  %mul5.i.i26.i4862 = fmul float %586, %595
  %596 = call float @llvm.fmuladd.f32(float %594, float %583, float %mul5.i.i26.i4862)
  %arrayidx6.i.i27.i4863 = getelementptr inbounds [4 x float], ptr %gep6288, i64 0, i64 2
  %597 = load float, ptr %arrayidx6.i.i27.i4863, align 8
  %598 = call noundef float @llvm.fmuladd.f32(float %597, float %589, float %596)
  %cmp11.i4864 = fcmp olt float %598, %Min0.i1484.0
  %Min0.i1484.1 = select i1 %cmp11.i4864, float %598, float %Min0.i1484.0
  %599 = select i1 %cmp11.i4864, float %Max0.i1485.0, float %593
  %cmp14.i4866 = fcmp ogt float %598, %599
  %Max0.i1485.1 = select i1 %cmp14.i4866, float %598, float %Max0.i1485.0
  %600 = select i1 %cmp14.i4866, float %598, float %599
  %indvars.iv.next6164 = add nuw nsw i64 %indvars.iv6163, 1
  %exitcond.not.i4869 = icmp eq i64 %indvars.iv.next6164, %592
  br i1 %exitcond.not.i4869, label %for.end.i4847, label %for.body.i4856, !llvm.loop !9

for.end.i4847:                                    ; preds = %for.body.i4856
  %cmp20.i4848 = fcmp ogt float %Min0.i1484.1, %600
  br i1 %cmp20.i4848, label %if.then21.i4852, label %.noexc1497

if.then21.i4852:                                  ; preds = %for.end.i4847
  br label %.noexc1497

.noexc1497:                                       ; preds = %if.end703, %if.then21.i4852, %for.end.i4847
  %Max0.i1485.3 = phi float [ %Max0.i1485.1, %for.end.i4847 ], [ %Min0.i1484.1, %if.then21.i4852 ], [ 0x47EFFFFFE0000000, %if.end703 ]
  %601 = phi float [ %Min0.i1484.1, %for.end.i4847 ], [ %600, %if.then21.i4852 ], [ 0xC7EFFFFFE0000000, %if.end703 ]
  %mul5.i.i.i4849 = fmul float %tr.sroa.23.48.copyload.i1514, %573
  %602 = call float @llvm.fmuladd.f32(float %tr.sroa.21.48.copyload.i1512, float %570, float %mul5.i.i.i4849)
  %603 = call noundef float @llvm.fmuladd.f32(float %tr.sroa.24.48.copyload.i1516, float %571, float %602)
  %add28.i4850 = fadd float %603, %601
  %add30.i4851 = fadd float %603, %Max0.i1485.3
  invoke void @_Z9b3ProjectPK22b3ConvexPolyhedronDataRK9b3Vector3RK12b3QuaternionPS3_S8_PfS9_(ptr noundef nonnull %arrayidx.i1470, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull %sepAxis2, ptr noundef %568, ptr noundef nonnull %Min1.i1486, ptr noundef nonnull %Max1.i1487)
          to label %.noexc1498 unwind label %lpad487.loopexit

.noexc1498:                                       ; preds = %.noexc1497
  %604 = load float, ptr %Min1.i1486, align 4
  %cmp.i1488 = fcmp olt float %add30.i4851, %604
  br i1 %cmp.i1488, label %if.else749, label %lor.lhs.false.i1489

lor.lhs.false.i1489:                              ; preds = %.noexc1498
  %605 = load float, ptr %Max1.i1487, align 4
  %cmp1.i1490 = fcmp olt float %605, %add28.i4850
  br i1 %cmp1.i1490, label %if.else749, label %if.then710

if.then710:                                       ; preds = %lor.lhs.false.i1489
  %sub.i1492 = fsub float %add30.i4851, %604
  %sub2.i1493 = fsub float %605, %add28.i4850
  %cmp3.i1494 = fcmp olt float %sub.i1492, %sub2.i1493
  %cond.i1495 = select i1 %cmp3.i1494, float %sub.i1492, float %sub2.i1493
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %Min1.i1486)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %Max1.i1487)
  %cmp711 = fcmp ogt float %depth.0, %cond.i1495
  br i1 %cmp711, label %if.then712, label %if.end721

if.then712:                                       ; preds = %if.then710
  %sub714 = fsub float %depth.0, %cond.i1495
  %606 = load float, ptr @_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E7maxdiff_0, align 4
  %cmp715 = fcmp olt float %606, %sub714
  br i1 %cmp715, label %if.then716, label %if.end721

if.then716:                                       ; preds = %if.then712
  store float %sub714, ptr @_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E7maxdiff_0, align 4
  %conv717 = fpext float %sub714 to double
  %call719 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.44, double noundef %conv717)
  br label %if.end721

if.end721:                                        ; preds = %if.then712, %if.then716, %if.then710
  %607 = load ptr, ptr %m_data.i.i1295, align 8
  %idxprom.i1501 = sext i32 %nGlobalContactsOut.06150 to i64
  %arrayidx.i1502 = getelementptr inbounds %struct.b3Contact4, ptr %607, i64 %idxprom.i1501
  %inc724 = add nsw i32 %nGlobalContactsOut.06150, 1
  %m_batchIdx = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx.i1502, i64 0, i32 4
  store i32 0, ptr %m_batchIdx, align 4
  %608 = load ptr, ptr %m_data.i.i1241, align 8
  %m_invMass727 = getelementptr inbounds %struct.b3RigidBodyData, ptr %608, i64 %idxprom.i1313, i32 5
  %609 = load float, ptr %m_invMass727, align 4
  %cmp728 = fcmp oeq float %609, 0.000000e+00
  %sub729 = sub nsw i32 0, %408
  %cond = select i1 %cmp728, i32 %sub729, i32 %408
  %m_bodyAPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx.i1502, i64 0, i32 5
  store i32 %cond, ptr %m_bodyAPtrAndSignBit, align 8
  %610 = load ptr, ptr %m_data.i.i1241, align 8
  %m_invMass732 = getelementptr inbounds %struct.b3RigidBodyData, ptr %610, i64 %idxprom.i1316, i32 5
  %611 = load float, ptr %m_invMass732, align 4
  %cmp733 = fcmp oeq float %611, 0.000000e+00
  %sub735 = sub nsw i32 0, %409
  %cond738 = select i1 %cmp733, i32 %sub735, i32 %409
  %m_bodyBPtrAndSignBit = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx.i1502, i64 0, i32 6
  store i32 %cond738, ptr %m_bodyBPtrAndSignBit, align 4
  %m_frictionCoeffCmp = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx.i1502, i64 0, i32 3
  store i16 -19662, ptr %m_frictionCoeffCmp, align 2
  %m_restituitionCoeffCmp = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx.i1502, i64 0, i32 2
  store i16 0, ptr %m_restituitionCoeffCmp, align 16
  %612 = load float, ptr @_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E8maxDepth, align 4
  %cmp739 = fcmp ogt float %depth.0, %612
  br i1 %cmp739, label %if.then740, label %if.end744

if.then740:                                       ; preds = %if.end721
  store float %depth.0, ptr @_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E8maxDepth, align 4
  %conv741 = fpext float %depth.0 to double
  %call743 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.45, double noundef %conv741)
  br label %if.end744

if.end744:                                        ; preds = %if.then740, %if.end721
  %fneg745 = fneg float %depth.0
  %resultPointOnBWorld.sroa.3.12.vec.insert = insertelement <2 x float> %resultPointOnBWorld.sroa.3.0.copyload, float %fneg745, i64 1
  store <2 x float> %resultPointOnBWorld.sroa.0.0.copyload, ptr %arrayidx.i1502, align 16
  %resultPointOnBWorld.sroa.3.0.arrayidx.sroa_idx = getelementptr inbounds i8, ptr %arrayidx.i1502, i64 8
  store <2 x float> %resultPointOnBWorld.sroa.3.12.vec.insert, ptr %resultPointOnBWorld.sroa.3.0.arrayidx.sroa_idx, align 8
  %m_worldNormalOnB = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx.i1502, i64 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %m_worldNormalOnB, ptr noundef nonnull align 16 dereferenceable(16) %sepAxis2, i64 16, i1 false)
  %w748 = getelementptr inbounds %struct.b3Contact4Data, ptr %arrayidx.i1502, i64 0, i32 1, i32 0, i32 0, i64 3
  store float 1.000000e+00, ptr %w748, align 4
  br label %for.inc

if.else749:                                       ; preds = %lor.lhs.false.i1489, %.noexc1498
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %Min1.i1486)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %Max1.i1487)
  %puts = call i32 @puts(ptr nonnull dereferenceable(1) @str)
  br label %for.inc

invoke.cont782:                                   ; preds = %if.end525
  store <2 x float> %retval.sroa.0.4.vec.insert.i.i1617, ptr %DeltaC2781, align 16
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i16186292, ptr %406, align 8
  %613 = load ptr, ptr %m_data.i.i1257, align 8
  %614 = load ptr, ptr %m_data.i.i1283, align 8
  %615 = load ptr, ptr %m_data.i.i1287, align 8
  %call805 = call noundef zeroext i1 @_Z20b3FindSeparatingAxisPK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_Pf(ptr noundef nonnull %arrayidx.i1341, ptr noundef nonnull %arrayidx.i1344, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %DeltaC2781, ptr noundef nonnull %613, ptr nonnull poison, ptr noundef nonnull %615, ptr nonnull poison, ptr noundef nonnull %613, ptr nonnull poison, ptr nonnull poison, ptr nonnull poison, ptr noundef nonnull %sepAxis786, ptr noundef nonnull %dmin)
  br i1 %call805, label %if.then808, label %for.inc

if.then808:                                       ; preds = %invoke.cont782
  %call827 = call noundef zeroext i1 @_Z20b3FindSeparatingAxisPK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_Pf(ptr noundef nonnull %arrayidx.i1344, ptr noundef nonnull %arrayidx.i1341, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %DeltaC2781, ptr noundef nonnull %613, ptr nonnull poison, ptr noundef nonnull %615, ptr nonnull poison, ptr noundef nonnull %613, ptr nonnull poison, ptr nonnull poison, ptr nonnull poison, ptr noundef nonnull %sepAxis786, ptr noundef nonnull %dmin)
  br i1 %call827, label %if.then830, label %for.inc

if.then830:                                       ; preds = %if.then808
  %call849 = call noundef zeroext i1 @_Z28b3FindSeparatingAxisEdgeEdgePK22b3ConvexPolyhedronDataS1_RK9b3Vector3RK12b3QuaternionS4_S7_S4_PS3_S8_PK9b3GpuFacePKiS8_S8_SB_SD_PS2_Pfb(ptr noundef nonnull %arrayidx.i1341, ptr noundef nonnull %arrayidx.i1344, ptr noundef nonnull align 16 dereferenceable(16) %posA, ptr noundef nonnull align 16 dereferenceable(16) %ornA, ptr noundef nonnull align 16 dereferenceable(16) %posB, ptr noundef nonnull align 16 dereferenceable(16) %ornB, ptr noundef nonnull align 16 dereferenceable(16) %DeltaC2781, ptr noundef nonnull %613, ptr noundef nonnull %614, ptr nonnull poison, ptr nonnull poison, ptr noundef nonnull %613, ptr noundef nonnull %614, ptr nonnull poison, ptr nonnull poison, ptr noundef nonnull %sepAxis786, ptr noundef nonnull %dmin, i1 noundef zeroext true)
  br i1 %call849, label %if.then852, label %for.inc

if.then852:                                       ; preds = %if.then830
  %616 = load ptr, ptr %m_data.i.i1261, align 8
  %arrayidx.i1647 = getelementptr inbounds i32, ptr %616, i64 %indvars.iv6167
  store i32 1, ptr %arrayidx.i1647, align 4
  %617 = load ptr, ptr %m_data.i.i1268, align 8
  %arrayidx.i1650 = getelementptr inbounds %class.b3Vector3, ptr %617, i64 %indvars.iv6167
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx.i1650, ptr noundef nonnull align 16 dereferenceable(16) %sepAxis786, i64 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end744, %if.else749, %invoke.cont662, %if.end628, %if.then808, %if.then852, %if.then830, %invoke.cont782, %if.end516, %lor.lhs.false, %land.lhs.true
  %nGlobalContactsOut.1 = phi i32 [ %nGlobalContactsOut.06150, %land.lhs.true ], [ %nGlobalContactsOut.06150, %if.end516 ], [ %nGlobalContactsOut.06150, %lor.lhs.false ], [ %inc724, %if.end744 ], [ %nGlobalContactsOut.06150, %if.else749 ], [ %nGlobalContactsOut.06150, %invoke.cont662 ], [ %nGlobalContactsOut.06150, %if.end628 ], [ %nGlobalContactsOut.06150, %if.then852 ], [ %nGlobalContactsOut.06150, %if.then830 ], [ %nGlobalContactsOut.06150, %if.then808 ], [ %nGlobalContactsOut.06150, %invoke.cont782 ]
  %indvars.iv.next6168 = add nuw nsw i64 %indvars.iv6167, 1
  %618 = load i32, ptr %nPairs.addr, align 4
  %619 = sext i32 %618 to i64
  %cmp492 = icmp slt i64 %indvars.iv.next6168, %619
  br i1 %cmp492, label %for.body, label %for.end, !llvm.loop !67

for.end:                                          ; preds = %for.inc, %invoke.cont491
  %nGlobalContactsOut.0.lcssa = phi i32 [ %402, %invoke.cont491 ], [ %nGlobalContactsOut.1, %for.inc ]
  %620 = load i8, ptr @useGjkContacts, align 1
  %621 = and i8 %620, 1
  %tobool862.not = icmp eq i8 %621, 0
  br i1 %tobool862.not, label %if.end867, label %if.then863

if.then863:                                       ; preds = %for.end
  store i32 %nGlobalContactsOut.0.lcssa, ptr %nContacts, align 4
  %622 = load i32, ptr %m_size.i.i1296, align 4
  %conv.i = sext i32 %622 to i64
  %623 = load i64, ptr %m_size.i.i, align 8
  %cmp3.i.i = icmp ult i64 %623, %conv.i
  br i1 %cmp3.i.i, label %if.end7.i.i, label %_ZN13b3OpenCLArrayI10b3Contact4E6resizeEmb.exit.i

if.end7.i.i:                                      ; preds = %if.then863
  %call5.i.i1659 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI10b3Contact4E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %contactOut, i64 noundef %conv.i, i1 noundef zeroext false)
          to label %call5.i.i.noexc unwind label %lpad487.loopexit.split-lp

call5.i.i.noexc:                                  ; preds = %if.end7.i.i
  %spec.select.i.i = select i1 %call5.i.i1659, i64 %conv.i, i64 0
  br label %_ZN13b3OpenCLArrayI10b3Contact4E6resizeEmb.exit.i

_ZN13b3OpenCLArrayI10b3Contact4E6resizeEmb.exit.i: ; preds = %call5.i.i.noexc, %if.then863
  %storemerge.i.i = phi i64 [ %conv.i, %if.then863 ], [ %spec.select.i.i, %call5.i.i.noexc ]
  store i64 %storemerge.i.i, ptr %m_size.i.i, align 8
  %tobool3.not.i = icmp eq i32 %622, 0
  br i1 %tobool3.not.i, label %invoke.cont864, label %if.then.i.i1653

if.then.i.i1653:                                  ; preds = %_ZN13b3OpenCLArrayI10b3Contact4E6resizeEmb.exit.i
  %624 = load ptr, ptr %m_data.i.i1295, align 8
  %mul.i.i1655 = mul nsw i64 %conv.i, 112
  %625 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %m_commandQueue.i.i1656 = getelementptr inbounds %class.b3OpenCLArray.80, ptr %contactOut, i64 0, i32 5
  %626 = load ptr, ptr %m_commandQueue.i.i1656, align 8
  %627 = load ptr, ptr %m_clBuffer.i545, align 8
  %call.i.i1661 = invoke i32 %625(ptr noundef %626, ptr noundef %627, i32 noundef 0, i64 noundef 0, i64 noundef %mul.i.i1655, ptr noundef %624, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call.i.i.noexc1660 unwind label %lpad487.loopexit.split-lp

call.i.i.noexc1660:                               ; preds = %if.then.i.i1653
  %628 = load ptr, ptr @__clewFinish, align 8
  %629 = load ptr, ptr %m_commandQueue.i.i1656, align 8
  %call6.i.i1663 = invoke i32 %628(ptr noundef %629)
          to label %invoke.cont864 unwind label %lpad487.loopexit.split-lp

invoke.cont864:                                   ; preds = %_ZN13b3OpenCLArrayI10b3Contact4E6resizeEmb.exit.i, %call.i.i.noexc1660
  %630 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %631 = load ptr, ptr %m_commandQueue.i, align 8
  %632 = load ptr, ptr %m_clBuffer.i, align 8
  %call.i16671670 = invoke i32 %630(ptr noundef %631, ptr noundef %632, i32 noundef 0, i64 noundef 0, i64 noundef 4, ptr noundef nonnull %nContacts, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call.i1667.noexc unwind label %lpad487.loopexit.split-lp

call.i1667.noexc:                                 ; preds = %invoke.cont864
  %633 = load ptr, ptr @__clewFinish, align 8
  %634 = load ptr, ptr %m_commandQueue.i, align 8
  %call6.i16681671 = invoke i32 %633(ptr noundef %634)
          to label %if.end867 unwind label %lpad487.loopexit.split-lp

if.end867:                                        ; preds = %call.i1667.noexc, %for.end
  %635 = load i32, ptr %m_size.i.i1262, align 4
  %conv.i1673 = sext i32 %635 to i64
  %636 = load i64, ptr %m_size.i.i603, align 8
  %cmp3.i.i1675 = icmp ult i64 %636, %conv.i1673
  br i1 %cmp3.i.i1675, label %if.end7.i.i1684, label %_ZN13b3OpenCLArrayIiE6resizeEmb.exit.i

if.end7.i.i1684:                                  ; preds = %if.end867
  %call5.i.i1687 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayIiE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_hasSeparatingNormals, i64 noundef %conv.i1673, i1 noundef zeroext false)
          to label %call5.i.i.noexc1686 unwind label %lpad487.loopexit.split-lp

call5.i.i.noexc1686:                              ; preds = %if.end7.i.i1684
  %spec.select.i.i1685 = select i1 %call5.i.i1687, i64 %conv.i1673, i64 0
  br label %_ZN13b3OpenCLArrayIiE6resizeEmb.exit.i

_ZN13b3OpenCLArrayIiE6resizeEmb.exit.i:           ; preds = %call5.i.i.noexc1686, %if.end867
  %storemerge.i.i1676 = phi i64 [ %conv.i1673, %if.end867 ], [ %spec.select.i.i1685, %call5.i.i.noexc1686 ]
  store i64 %storemerge.i.i1676, ptr %m_size.i.i603, align 8
  %tobool3.not.i1677 = icmp eq i32 %635, 0
  br i1 %tobool3.not.i1677, label %invoke.cont869, label %if.then.i.i1678

if.then.i.i1678:                                  ; preds = %_ZN13b3OpenCLArrayIiE6resizeEmb.exit.i
  %637 = load ptr, ptr %m_data.i.i1261, align 8
  %mul.i.i1680 = shl nsw i64 %conv.i1673, 2
  %638 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %m_commandQueue.i.i1681 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 28, i32 5
  %639 = load ptr, ptr %m_commandQueue.i.i1681, align 8
  %m_clBuffer.i.i1682 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 28, i32 3
  %640 = load ptr, ptr %m_clBuffer.i.i1682, align 8
  %call.i.i1689 = invoke i32 %638(ptr noundef %639, ptr noundef %640, i32 noundef 0, i64 noundef 0, i64 noundef %mul.i.i1680, ptr noundef %637, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call.i.i.noexc1688 unwind label %lpad487.loopexit.split-lp

call.i.i.noexc1688:                               ; preds = %if.then.i.i1678
  %641 = load ptr, ptr @__clewFinish, align 8
  %642 = load ptr, ptr %m_commandQueue.i.i1681, align 8
  %call6.i.i1691 = invoke i32 %641(ptr noundef %642)
          to label %invoke.cont869 unwind label %lpad487.loopexit.split-lp

invoke.cont869:                                   ; preds = %_ZN13b3OpenCLArrayIiE6resizeEmb.exit.i, %call.i.i.noexc1688
  %643 = load i32, ptr %m_size.i.i1269, align 4
  %conv.i1693 = sext i32 %643 to i64
  %644 = load i64, ptr %m_size.i.i593, align 8
  %cmp3.i.i1695 = icmp ult i64 %644, %conv.i1693
  br i1 %cmp3.i.i1695, label %if.end7.i.i1704, label %_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i

if.end7.i.i1704:                                  ; preds = %invoke.cont869
  %call5.i.i1707 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_sepNormals, i64 noundef %conv.i1693, i1 noundef zeroext false)
          to label %call5.i.i.noexc1706 unwind label %lpad487.loopexit.split-lp

call5.i.i.noexc1706:                              ; preds = %if.end7.i.i1704
  %spec.select.i.i1705 = select i1 %call5.i.i1707, i64 %conv.i1693, i64 0
  br label %_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i

_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i:  ; preds = %call5.i.i.noexc1706, %invoke.cont869
  %storemerge.i.i1696 = phi i64 [ %conv.i1693, %invoke.cont869 ], [ %spec.select.i.i1705, %call5.i.i.noexc1706 ]
  store i64 %storemerge.i.i1696, ptr %m_size.i.i593, align 8
  %tobool3.not.i1697 = icmp eq i32 %643, 0
  br i1 %tobool3.not.i1697, label %invoke.cont871, label %if.then.i.i1698

if.then.i.i1698:                                  ; preds = %_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i
  %645 = load ptr, ptr %m_data.i.i1268, align 8
  %mul.i.i1700 = shl nsw i64 %conv.i1693, 4
  %646 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %m_commandQueue.i.i1701 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 26, i32 5
  %647 = load ptr, ptr %m_commandQueue.i.i1701, align 8
  %m_clBuffer.i.i1702 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 26, i32 3
  %648 = load ptr, ptr %m_clBuffer.i.i1702, align 8
  %call.i.i1709 = invoke i32 %646(ptr noundef %647, ptr noundef %648, i32 noundef 0, i64 noundef 0, i64 noundef %mul.i.i1700, ptr noundef %645, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call.i.i.noexc1708 unwind label %lpad487.loopexit.split-lp

call.i.i.noexc1708:                               ; preds = %if.then.i.i1698
  %649 = load ptr, ptr @__clewFinish, align 8
  %650 = load ptr, ptr %m_commandQueue.i.i1701, align 8
  %call6.i.i1711 = invoke i32 %649(ptr noundef %650)
          to label %invoke.cont871 unwind label %lpad487.loopexit.split-lp

invoke.cont871:                                   ; preds = %_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i, %call.i.i.noexc1708
  %651 = load ptr, ptr %m_data.i.i1295, align 8
  %tobool.not.i.i.i1712 = icmp eq ptr %651, null
  br i1 %tobool.not.i.i.i1712, label %_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev.exit, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %invoke.cont871
  %652 = load i8, ptr %m_ownsMemory.i.i1294, align 8
  %653 = and i8 %652, 1
  %tobool2.not.i.i.i = icmp eq i8 %653, 0
  br i1 %tobool2.not.i.i.i, label %_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev.exit, label %if.then3.i.i.i

if.then3.i.i.i:                                   ; preds = %if.then.i.i.i
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %651)
          to label %_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev.exit unwind label %terminate.lpad.i1713

terminate.lpad.i1713:                             ; preds = %if.then3.i.i.i
  %654 = landingpad { ptr, i32 }
          catch ptr null
  %655 = extractvalue { ptr, i32 } %654, 0
  call void @__clang_call_terminate(ptr %655) #27
  unreachable

_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev.exit: ; preds = %invoke.cont871, %if.then.i.i.i, %if.then3.i.i.i
  store i8 1, ptr %m_ownsMemory.i.i1294, align 8
  store ptr null, ptr %m_data.i.i1295, align 8
  store i32 0, ptr %m_size.i.i1296, align 4
  store i32 0, ptr %m_capacity.i.i1297, align 8
  %656 = load ptr, ptr %m_data.i.i1291, align 8
  %tobool.not.i.i.i1717 = icmp eq ptr %656, null
  br i1 %tobool.not.i.i.i1717, label %_ZN20b3AlignedObjectArrayIiED2Ev.exit, label %if.then.i.i.i1718

if.then.i.i.i1718:                                ; preds = %_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev.exit
  %657 = load i8, ptr %m_ownsMemory.i.i1290, align 8
  %658 = and i8 %657, 1
  %tobool2.not.i.i.i1720 = icmp eq i8 %658, 0
  br i1 %tobool2.not.i.i.i1720, label %_ZN20b3AlignedObjectArrayIiED2Ev.exit, label %if.then3.i.i.i1721

if.then3.i.i.i1721:                               ; preds = %if.then.i.i.i1718
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %656)
          to label %_ZN20b3AlignedObjectArrayIiED2Ev.exit unwind label %terminate.lpad.i1722

terminate.lpad.i1722:                             ; preds = %if.then3.i.i.i1721
  %659 = landingpad { ptr, i32 }
          catch ptr null
  %660 = extractvalue { ptr, i32 } %659, 0
  call void @__clang_call_terminate(ptr %660) #27
  unreachable

_ZN20b3AlignedObjectArrayIiED2Ev.exit:            ; preds = %_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev.exit, %if.then.i.i.i1718, %if.then3.i.i.i1721
  store i8 1, ptr %m_ownsMemory.i.i1290, align 8
  store ptr null, ptr %m_data.i.i1291, align 8
  store i32 0, ptr %m_size.i.i1292, align 4
  store i32 0, ptr %m_capacity.i.i1293, align 8
  %661 = load ptr, ptr %m_data.i.i1287, align 8
  %tobool.not.i.i.i1727 = icmp eq ptr %661, null
  br i1 %tobool.not.i.i.i1727, label %_ZN20b3AlignedObjectArrayI9b3GpuFaceED2Ev.exit, label %if.then.i.i.i1728

if.then.i.i.i1728:                                ; preds = %_ZN20b3AlignedObjectArrayIiED2Ev.exit
  %662 = load i8, ptr %m_ownsMemory.i.i1286, align 8
  %663 = and i8 %662, 1
  %tobool2.not.i.i.i1730 = icmp eq i8 %663, 0
  br i1 %tobool2.not.i.i.i1730, label %_ZN20b3AlignedObjectArrayI9b3GpuFaceED2Ev.exit, label %if.then3.i.i.i1731

if.then3.i.i.i1731:                               ; preds = %if.then.i.i.i1728
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %661)
          to label %_ZN20b3AlignedObjectArrayI9b3GpuFaceED2Ev.exit unwind label %terminate.lpad.i1732

terminate.lpad.i1732:                             ; preds = %if.then3.i.i.i1731
  %664 = landingpad { ptr, i32 }
          catch ptr null
  %665 = extractvalue { ptr, i32 } %664, 0
  call void @__clang_call_terminate(ptr %665) #27
  unreachable

_ZN20b3AlignedObjectArrayI9b3GpuFaceED2Ev.exit:   ; preds = %_ZN20b3AlignedObjectArrayIiED2Ev.exit, %if.then.i.i.i1728, %if.then3.i.i.i1731
  store i8 1, ptr %m_ownsMemory.i.i1286, align 8
  store ptr null, ptr %m_data.i.i1287, align 8
  store i32 0, ptr %m_size.i.i1288, align 4
  store i32 0, ptr %m_capacity.i.i1289, align 8
  %666 = load ptr, ptr %m_data.i.i1283, align 8
  %tobool.not.i.i.i1737 = icmp eq ptr %666, null
  br i1 %tobool.not.i.i.i1737, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit, label %if.then.i.i.i1738

if.then.i.i.i1738:                                ; preds = %_ZN20b3AlignedObjectArrayI9b3GpuFaceED2Ev.exit
  %667 = load i8, ptr %m_ownsMemory.i.i1282, align 8
  %668 = and i8 %667, 1
  %tobool2.not.i.i.i1740 = icmp eq i8 %668, 0
  br i1 %tobool2.not.i.i.i1740, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit, label %if.then3.i.i.i1741

if.then3.i.i.i1741:                               ; preds = %if.then.i.i.i1738
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %666)
          to label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit unwind label %terminate.lpad.i1742

terminate.lpad.i1742:                             ; preds = %if.then3.i.i.i1741
  %669 = landingpad { ptr, i32 }
          catch ptr null
  %670 = extractvalue { ptr, i32 } %669, 0
  call void @__clang_call_terminate(ptr %670) #27
  unreachable

_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit:   ; preds = %_ZN20b3AlignedObjectArrayI9b3GpuFaceED2Ev.exit, %if.then.i.i.i1738, %if.then3.i.i.i1741
  store i8 1, ptr %m_ownsMemory.i.i1282, align 8
  store ptr null, ptr %m_data.i.i1283, align 8
  store i32 0, ptr %m_size.i.i1284, align 4
  store i32 0, ptr %m_capacity.i.i1285, align 8
  %671 = load ptr, ptr %m_data.i.i1268, align 8
  %tobool.not.i.i.i1747 = icmp eq ptr %671, null
  br i1 %tobool.not.i.i.i1747, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit1756, label %if.then.i.i.i1748

if.then.i.i.i1748:                                ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit
  %672 = load i8, ptr %m_ownsMemory.i.i1267, align 8
  %673 = and i8 %672, 1
  %tobool2.not.i.i.i1750 = icmp eq i8 %673, 0
  br i1 %tobool2.not.i.i.i1750, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit1756, label %if.then3.i.i.i1751

if.then3.i.i.i1751:                               ; preds = %if.then.i.i.i1748
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %671)
          to label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit1756 unwind label %terminate.lpad.i1752

terminate.lpad.i1752:                             ; preds = %if.then3.i.i.i1751
  %674 = landingpad { ptr, i32 }
          catch ptr null
  %675 = extractvalue { ptr, i32 } %674, 0
  call void @__clang_call_terminate(ptr %675) #27
  unreachable

_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit1756: ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit, %if.then.i.i.i1748, %if.then3.i.i.i1751
  store i8 1, ptr %m_ownsMemory.i.i1267, align 8
  store i32 0, ptr %m_size.i.i1269, align 4
  store i32 0, ptr %m_capacity.i.i1270, align 8
  %676 = load ptr, ptr %m_data.i.i1261, align 8
  %tobool.not.i.i.i1758 = icmp eq ptr %676, null
  br i1 %tobool.not.i.i.i1758, label %_ZN20b3AlignedObjectArrayIiED2Ev.exit1767, label %if.then.i.i.i1759

if.then.i.i.i1759:                                ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit1756
  %677 = load i8, ptr %m_ownsMemory.i.i1260, align 8
  %678 = and i8 %677, 1
  %tobool2.not.i.i.i1761 = icmp eq i8 %678, 0
  br i1 %tobool2.not.i.i.i1761, label %_ZN20b3AlignedObjectArrayIiED2Ev.exit1767, label %if.then3.i.i.i1762

if.then3.i.i.i1762:                               ; preds = %if.then.i.i.i1759
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %676)
          to label %_ZN20b3AlignedObjectArrayIiED2Ev.exit1767 unwind label %terminate.lpad.i1763

terminate.lpad.i1763:                             ; preds = %if.then3.i.i.i1762
  %679 = landingpad { ptr, i32 }
          catch ptr null
  %680 = extractvalue { ptr, i32 } %679, 0
  call void @__clang_call_terminate(ptr %680) #27
  unreachable

_ZN20b3AlignedObjectArrayIiED2Ev.exit1767:        ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit1756, %if.then.i.i.i1759, %if.then3.i.i.i1762
  store i8 1, ptr %m_ownsMemory.i.i1260, align 8
  store i32 0, ptr %m_size.i.i1262, align 4
  store i32 0, ptr %m_capacity.i.i1263, align 8
  %681 = load ptr, ptr %m_data.i.i1257, align 8
  %tobool.not.i.i.i1769 = icmp eq ptr %681, null
  br i1 %tobool.not.i.i.i1769, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit1778, label %if.then.i.i.i1770

if.then.i.i.i1770:                                ; preds = %_ZN20b3AlignedObjectArrayIiED2Ev.exit1767
  %682 = load i8, ptr %m_ownsMemory.i.i1256, align 8
  %683 = and i8 %682, 1
  %tobool2.not.i.i.i1772 = icmp eq i8 %683, 0
  br i1 %tobool2.not.i.i.i1772, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit1778, label %if.then3.i.i.i1773

if.then3.i.i.i1773:                               ; preds = %if.then.i.i.i1770
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %681)
          to label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit1778 unwind label %terminate.lpad.i1774

terminate.lpad.i1774:                             ; preds = %if.then3.i.i.i1773
  %684 = landingpad { ptr, i32 }
          catch ptr null
  %685 = extractvalue { ptr, i32 } %684, 0
  call void @__clang_call_terminate(ptr %685) #27
  unreachable

_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit1778: ; preds = %_ZN20b3AlignedObjectArrayIiED2Ev.exit1767, %if.then.i.i.i1770, %if.then3.i.i.i1773
  store i8 1, ptr %m_ownsMemory.i.i1256, align 8
  store ptr null, ptr %m_data.i.i1257, align 8
  store i32 0, ptr %m_size.i.i1258, align 4
  store i32 0, ptr %m_capacity.i.i1259, align 8
  %686 = load ptr, ptr %m_data.i.i1253, align 8
  %tobool.not.i.i.i1780 = icmp eq ptr %686, null
  br i1 %tobool.not.i.i.i1780, label %_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataED2Ev.exit, label %if.then.i.i.i1781

if.then.i.i.i1781:                                ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit1778
  %687 = load i8, ptr %m_ownsMemory.i.i1252, align 8
  %688 = and i8 %687, 1
  %tobool2.not.i.i.i1783 = icmp eq i8 %688, 0
  br i1 %tobool2.not.i.i.i1783, label %_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataED2Ev.exit, label %if.then3.i.i.i1784

if.then3.i.i.i1784:                               ; preds = %if.then.i.i.i1781
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %686)
          to label %_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataED2Ev.exit unwind label %terminate.lpad.i1785

terminate.lpad.i1785:                             ; preds = %if.then3.i.i.i1784
  %689 = landingpad { ptr, i32 }
          catch ptr null
  %690 = extractvalue { ptr, i32 } %689, 0
  call void @__clang_call_terminate(ptr %690) #27
  unreachable

_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataED2Ev.exit: ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit1778, %if.then.i.i.i1781, %if.then3.i.i.i1784
  store i8 1, ptr %m_ownsMemory.i.i1252, align 8
  store ptr null, ptr %m_data.i.i1253, align 8
  store i32 0, ptr %m_size.i.i1254, align 4
  store i32 0, ptr %m_capacity.i.i1255, align 8
  %691 = load ptr, ptr %m_data.i.i1249, align 8
  %tobool.not.i.i.i1790 = icmp eq ptr %691, null
  br i1 %tobool.not.i.i.i1790, label %_ZN20b3AlignedObjectArrayI15b3GpuChildShapeED2Ev.exit, label %if.then.i.i.i1791

if.then.i.i.i1791:                                ; preds = %_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataED2Ev.exit
  %692 = load i8, ptr %m_ownsMemory.i.i1248, align 8
  %693 = and i8 %692, 1
  %tobool2.not.i.i.i1793 = icmp eq i8 %693, 0
  br i1 %tobool2.not.i.i.i1793, label %_ZN20b3AlignedObjectArrayI15b3GpuChildShapeED2Ev.exit, label %if.then3.i.i.i1794

if.then3.i.i.i1794:                               ; preds = %if.then.i.i.i1791
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %691)
          to label %_ZN20b3AlignedObjectArrayI15b3GpuChildShapeED2Ev.exit unwind label %terminate.lpad.i1795

terminate.lpad.i1795:                             ; preds = %if.then3.i.i.i1794
  %694 = landingpad { ptr, i32 }
          catch ptr null
  %695 = extractvalue { ptr, i32 } %694, 0
  call void @__clang_call_terminate(ptr %695) #27
  unreachable

_ZN20b3AlignedObjectArrayI15b3GpuChildShapeED2Ev.exit: ; preds = %_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataED2Ev.exit, %if.then.i.i.i1791, %if.then3.i.i.i1794
  store i8 1, ptr %m_ownsMemory.i.i1248, align 8
  store ptr null, ptr %m_data.i.i1249, align 8
  store i32 0, ptr %m_size.i.i1250, align 4
  store i32 0, ptr %m_capacity.i.i1251, align 8
  %696 = load ptr, ptr %m_data.i.i1245, align 8
  %tobool.not.i.i.i1800 = icmp eq ptr %696, null
  br i1 %tobool.not.i.i.i1800, label %_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev.exit, label %if.then.i.i.i1801

if.then.i.i.i1801:                                ; preds = %_ZN20b3AlignedObjectArrayI15b3GpuChildShapeED2Ev.exit
  %697 = load i8, ptr %m_ownsMemory.i.i1244, align 8
  %698 = and i8 %697, 1
  %tobool2.not.i.i.i1803 = icmp eq i8 %698, 0
  br i1 %tobool2.not.i.i.i1803, label %_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev.exit, label %if.then3.i.i.i1804

if.then3.i.i.i1804:                               ; preds = %if.then.i.i.i1801
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %696)
          to label %_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev.exit unwind label %terminate.lpad.i1805

terminate.lpad.i1805:                             ; preds = %if.then3.i.i.i1804
  %699 = landingpad { ptr, i32 }
          catch ptr null
  %700 = extractvalue { ptr, i32 } %699, 0
  call void @__clang_call_terminate(ptr %700) #27
  unreachable

_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev.exit: ; preds = %_ZN20b3AlignedObjectArrayI15b3GpuChildShapeED2Ev.exit, %if.then.i.i.i1801, %if.then3.i.i.i1804
  store i8 1, ptr %m_ownsMemory.i.i1244, align 8
  store ptr null, ptr %m_data.i.i1245, align 8
  store i32 0, ptr %m_size.i.i1246, align 4
  store i32 0, ptr %m_capacity.i.i1247, align 8
  %701 = load ptr, ptr %m_data.i.i1241, align 8
  %tobool.not.i.i.i1810 = icmp eq ptr %701, null
  br i1 %tobool.not.i.i.i1810, label %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev.exit, label %if.then.i.i.i1811

if.then.i.i.i1811:                                ; preds = %_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev.exit
  %702 = load i8, ptr %m_ownsMemory.i.i1240, align 8
  %703 = and i8 %702, 1
  %tobool2.not.i.i.i1813 = icmp eq i8 %703, 0
  br i1 %tobool2.not.i.i.i1813, label %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev.exit, label %if.then3.i.i.i1814

if.then3.i.i.i1814:                               ; preds = %if.then.i.i.i1811
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %701)
          to label %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev.exit unwind label %terminate.lpad.i1815

terminate.lpad.i1815:                             ; preds = %if.then3.i.i.i1814
  %704 = landingpad { ptr, i32 }
          catch ptr null
  %705 = extractvalue { ptr, i32 } %704, 0
  call void @__clang_call_terminate(ptr %705) #27
  unreachable

_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev.exit: ; preds = %_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev.exit, %if.then.i.i.i1811, %if.then3.i.i.i1814
  store i8 1, ptr %m_ownsMemory.i.i1240, align 8
  store ptr null, ptr %m_data.i.i1241, align 8
  store i32 0, ptr %m_size.i.i1242, align 4
  store i32 0, ptr %m_capacity.i.i1243, align 8
  %706 = load ptr, ptr %m_data.i.i1237, align 8
  %tobool.not.i.i.i1820 = icmp eq ptr %706, null
  br i1 %tobool.not.i.i.i1820, label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit, label %if.then.i.i.i1821

if.then.i.i.i1821:                                ; preds = %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev.exit
  %707 = load i8, ptr %m_ownsMemory.i.i, align 8
  %708 = and i8 %707, 1
  %tobool2.not.i.i.i1823 = icmp eq i8 %708, 0
  br i1 %tobool2.not.i.i.i1823, label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit, label %if.then3.i.i.i1824

if.then3.i.i.i1824:                               ; preds = %if.then.i.i.i1821
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %706)
          to label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit unwind label %terminate.lpad.i1825

terminate.lpad.i1825:                             ; preds = %if.then3.i.i.i1824
  %709 = landingpad { ptr, i32 }
          catch ptr null
  %710 = extractvalue { ptr, i32 } %709, 0
  call void @__clang_call_terminate(ptr %710) #27
  unreachable

_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit:      ; preds = %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev.exit, %if.then.i.i.i1821, %if.then3.i.i.i1824
  store i8 1, ptr %m_ownsMemory.i.i, align 8
  store ptr null, ptr %m_data.i.i1237, align 8
  store i32 0, ptr %m_size.i.i1238, align 4
  store i32 0, ptr %m_capacity.i.i1239, align 8
  invoke void @b3LeaveProfileZone()
          to label %if.end885 unwind label %terminate.lpad.i1829

terminate.lpad.i1829:                             ; preds = %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit
  %711 = landingpad { ptr, i32 }
          catch ptr null
  %712 = extractvalue { ptr, i32 } %711, 0
  call void @__clang_call_terminate(ptr %712) #27
  unreachable

ehcleanup873:                                     ; preds = %lpad487, %lpad482
  %.pn445 = phi { ptr, i32 } [ %lpad.phi6143, %lpad487 ], [ %391, %lpad482 ]
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostIndices) #26
  br label %ehcleanup874

ehcleanup874:                                     ; preds = %ehcleanup873, %lpad479
  %.pn445.pn = phi { ptr, i32 } [ %.pn445, %ehcleanup873 ], [ %390, %lpad479 ]
  call void @_ZN20b3AlignedObjectArrayI9b3GpuFaceED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostFaces) #26
  br label %ehcleanup875

ehcleanup875:                                     ; preds = %ehcleanup874, %lpad476
  %.pn445.pn.pn = phi { ptr, i32 } [ %.pn445.pn, %ehcleanup874 ], [ %389, %lpad476 ]
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges) #26
  br label %ehcleanup876

ehcleanup876:                                     ; preds = %ehcleanup875, %lpad473
  %.pn445.pn.pn.pn = phi { ptr, i32 } [ %.pn445.pn.pn, %ehcleanup875 ], [ %388, %lpad473 ]
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostSepAxis) #26
  br label %ehcleanup877

ehcleanup877:                                     ; preds = %ehcleanup876, %lpad469
  %.pn445.pn.pn.pn.pn = phi { ptr, i32 } [ %.pn445.pn.pn.pn, %ehcleanup876 ], [ %387, %lpad469 ]
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostHasSepAxis) #26
  br label %ehcleanup878

ehcleanup878:                                     ; preds = %ehcleanup877, %lpad465
  %.pn445.pn.pn.pn.pn.pn = phi { ptr, i32 } [ %.pn445.pn.pn.pn.pn, %ehcleanup877 ], [ %386, %lpad465 ]
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices) #26
  br label %ehcleanup879

ehcleanup879:                                     ; preds = %ehcleanup878, %lpad462
  %.pn445.pn.pn.pn.pn.pn.pn = phi { ptr, i32 } [ %.pn445.pn.pn.pn.pn.pn, %ehcleanup878 ], [ %385, %lpad462 ]
  call void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexShapeData) #26
  br label %ehcleanup880

ehcleanup880:                                     ; preds = %ehcleanup879, %lpad459
  %.pn445.pn.pn.pn.pn.pn.pn.pn = phi { ptr, i32 } [ %.pn445.pn.pn.pn.pn.pn.pn, %ehcleanup879 ], [ %384, %lpad459 ]
  call void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuChildShapes) #26
  br label %ehcleanup881

ehcleanup881:                                     ; preds = %ehcleanup880, %lpad456
  %.pn445.pn.pn.pn.pn.pn.pn.pn.pn = phi { ptr, i32 } [ %.pn445.pn.pn.pn.pn.pn.pn.pn, %ehcleanup880 ], [ %383, %lpad456 ]
  call void @_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables) #26
  br label %ehcleanup882

ehcleanup882:                                     ; preds = %ehcleanup881, %lpad453
  %.pn445.pn.pn.pn.pn.pn.pn.pn.pn.pn = phi { ptr, i32 } [ %.pn445.pn.pn.pn.pn.pn.pn.pn.pn, %ehcleanup881 ], [ %382, %lpad453 ]
  call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf) #26
  br label %ehcleanup883

ehcleanup883:                                     ; preds = %ehcleanup882, %lpad450
  %.pn445.pn.pn.pn.pn.pn.pn.pn.pn.pn.pn = phi { ptr, i32 } [ %.pn445.pn.pn.pn.pn.pn.pn.pn.pn.pn, %ehcleanup882 ], [ %381, %lpad450 ]
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostPairs) #26
  invoke void @b3LeaveProfileZone()
          to label %ehcleanup2980 unwind label %terminate.lpad.i1831

terminate.lpad.i1831:                             ; preds = %ehcleanup883
  %713 = landingpad { ptr, i32 }
          catch ptr null
  %714 = extractvalue { ptr, i32 } %713, 0
  call void @__clang_call_terminate(ptr %714) #27
  unreachable

if.end885:                                        ; preds = %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit, %invoke.cont440, %invoke.cont375, %_ZN13b3ProfileZoneD2Ev.exit1045
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %elem.i1833)
  %715 = load i64, ptr %m_capacity.i.i679, align 8
  %cmp.not.i.i1835 = icmp eq i64 %715, 0
  br i1 %cmp.not.i.i1835, label %do.body.i.i1840, label %if.then.i.i1836

if.then.i.i1836:                                  ; preds = %if.end885
  %716 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %717 = load ptr, ptr %m_commandQueue.i.i685, align 8
  %718 = load ptr, ptr %m_clBuffer.i.i686, align 8
  %call3.i.i1842 = invoke i32 %716(ptr noundef %717, ptr noundef %718, i32 noundef 0, i64 noundef 0, i64 noundef 4, ptr noundef nonnull %elem.i1833, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call3.i.i.noexc1841 unwind label %lpad58

call3.i.i.noexc1841:                              ; preds = %if.then.i.i1836
  %719 = load ptr, ptr @__clewFinish, align 8
  %720 = load ptr, ptr %m_commandQueue.i.i685, align 8
  %call6.i.i1844 = invoke i32 %719(ptr noundef %720)
          to label %call6.i.i.noexc1843 unwind label %lpad58

call6.i.i.noexc1843:                              ; preds = %call3.i.i.noexc1841
  %.pre.i1839 = load i32, ptr %elem.i1833, align 4
  br label %invoke.cont887

do.body.i.i1840:                                  ; preds = %if.end885
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 285)
          to label %.noexc1845 unwind label %lpad58

.noexc1845:                                       ; preds = %do.body.i.i1840
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.80)
          to label %invoke.cont887 unwind label %lpad58

invoke.cont887:                                   ; preds = %call6.i.i.noexc1843, %.noexc1845
  %721 = phi i32 [ %.pre.i1839, %call6.i.i.noexc1843 ], [ undef, %.noexc1845 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %elem.i1833)
  store i32 %721, ptr %numCompoundPairs, align 4
  invoke void @b3EnterProfileZone(ptr noundef nonnull @.str.15)
          to label %invoke.cont892 unwind label %lpad58

invoke.cont892:                                   ; preds = %invoke.cont887
  %722 = load ptr, ptr %m_clBuffer.i530, align 8
  store ptr %722, ptr %bInfo893, align 16
  %m_isReadOnly.i1851 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 0, i32 1
  store i8 1, ptr %m_isReadOnly.i1851, align 8
  %arrayinit.element899 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 1
  %723 = load ptr, ptr %m_clBuffer.i531, align 8
  store ptr %723, ptr %arrayinit.element899, align 16
  %m_isReadOnly.i1853 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 1, i32 1
  store i8 1, ptr %m_isReadOnly.i1853, align 8
  %arrayinit.element903 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 2
  %724 = load ptr, ptr %m_clBuffer.i533, align 8
  store ptr %724, ptr %arrayinit.element903, align 16
  %m_isReadOnly.i1855 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 2, i32 1
  store i8 1, ptr %m_isReadOnly.i1855, align 8
  %arrayinit.element907 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 3
  %725 = load ptr, ptr %m_clBuffer.i535, align 8
  store ptr %725, ptr %arrayinit.element907, align 16
  %m_isReadOnly.i1857 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 3, i32 1
  store i8 1, ptr %m_isReadOnly.i1857, align 8
  %arrayinit.element911 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 4
  %726 = load ptr, ptr %m_clBuffer.i537, align 8
  store ptr %726, ptr %arrayinit.element911, align 16
  %m_isReadOnly.i1859 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 4, i32 1
  store i8 1, ptr %m_isReadOnly.i1859, align 8
  %arrayinit.element915 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 5
  %727 = load ptr, ptr %m_clBuffer.i539, align 8
  store ptr %727, ptr %arrayinit.element915, align 16
  %m_isReadOnly.i1861 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 5, i32 1
  store i8 1, ptr %m_isReadOnly.i1861, align 8
  %arrayinit.element919 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 6
  %728 = load ptr, ptr %m_clBuffer.i541, align 8
  store ptr %728, ptr %arrayinit.element919, align 16
  %m_isReadOnly.i1863 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 6, i32 1
  store i8 1, ptr %m_isReadOnly.i1863, align 8
  %arrayinit.element923 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 7
  %729 = load ptr, ptr %m_clBuffer.i543, align 8
  store ptr %729, ptr %arrayinit.element923, align 16
  %m_isReadOnly.i1865 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 7, i32 1
  store i8 1, ptr %m_isReadOnly.i1865, align 8
  %arrayinit.element927 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 8
  %m_clBuffer.i1866 = getelementptr inbounds %class.b3OpenCLArray.90, ptr %clAabbsLocalSpace, i64 0, i32 3
  %730 = load ptr, ptr %m_clBuffer.i1866, align 8
  store ptr %730, ptr %arrayinit.element927, align 16
  %m_isReadOnly.i1867 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 8, i32 1
  store i8 1, ptr %m_isReadOnly.i1867, align 8
  %arrayinit.element931 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 9
  %m_clBuffer.i1868 = getelementptr inbounds %class.b3OpenCLArray.96, ptr %gpuChildShapes, i64 0, i32 3
  %731 = load ptr, ptr %m_clBuffer.i1868, align 8
  store ptr %731, ptr %arrayinit.element931, align 16
  %m_isReadOnly.i1869 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 9, i32 1
  store i8 1, ptr %m_isReadOnly.i1869, align 8
  %arrayinit.element935 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 10
  %m_clBuffer.i1870 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 32, i32 3
  %732 = load ptr, ptr %m_clBuffer.i1870, align 8
  store ptr %732, ptr %arrayinit.element935, align 16
  %m_isReadOnly.i1871 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 10, i32 1
  store i8 0, ptr %m_isReadOnly.i1871, align 8
  %arrayinit.element940 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 11
  %733 = load ptr, ptr %m_clBuffer.i.i686, align 8
  store ptr %733, ptr %arrayinit.element940, align 16
  %m_isReadOnly.i1873 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 11, i32 1
  store i8 0, ptr %m_isReadOnly.i1873, align 8
  %arrayinit.element945 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 12
  %m_clBuffer.i1874 = getelementptr inbounds %class.b3OpenCLArray.98, ptr %subTreesGPU, i64 0, i32 3
  %734 = load ptr, ptr %m_clBuffer.i1874, align 8
  store ptr %734, ptr %arrayinit.element945, align 16
  %m_isReadOnly.i1875 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 12, i32 1
  store i8 0, ptr %m_isReadOnly.i1875, align 8
  %arrayinit.element949 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 13
  %m_clBuffer.i1876 = getelementptr inbounds %class.b3OpenCLArray.100, ptr %treeNodesGPU, i64 0, i32 3
  %735 = load ptr, ptr %m_clBuffer.i1876, align 8
  store ptr %735, ptr %arrayinit.element949, align 16
  %m_isReadOnly.i1877 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 13, i32 1
  store i8 0, ptr %m_isReadOnly.i1877, align 8
  %arrayinit.element953 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 14
  %m_clBuffer.i1878 = getelementptr inbounds %class.b3OpenCLArray.102, ptr %bvhInfo, i64 0, i32 3
  %736 = load ptr, ptr %m_clBuffer.i1878, align 8
  store ptr %736, ptr %arrayinit.element953, align 16
  %m_isReadOnly.i1879 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo893, i64 14, i32 1
  store i8 0, ptr %m_isReadOnly.i1879, align 8
  %737 = load ptr, ptr %m_queue, align 8
  %m_findCompoundPairsKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 12
  %738 = load ptr, ptr %m_findCompoundPairsKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher957, ptr noundef %737, ptr noundef %738, ptr noundef nonnull @.str.47)
          to label %invoke.cont959 unwind label %lpad895

invoke.cont959:                                   ; preds = %invoke.cont892
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher957, ptr noundef nonnull %bInfo893, i32 noundef 15)
          to label %invoke.cont962 unwind label %lpad961

invoke.cont962:                                   ; preds = %invoke.cont959
  %m_enableSerialization.i1880 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher957, i64 0, i32 7
  %739 = load i8, ptr %m_enableSerialization.i1880, align 4
  %740 = and i8 %739, 1
  %tobool.not.i1881 = icmp eq i8 %740, 0
  br i1 %tobool.not.i1881, label %if.end.i1897, label %if.then.i1882

if.then.i1882:                                    ; preds = %invoke.cont962
  %m_idx.i1883 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher957, i64 0, i32 3
  %741 = load i32, ptr %m_idx.i1883, align 8
  %742 = load i32, ptr %nPairs.addr, align 4
  %m_size.i.i.i1884 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher957, i64 0, i32 5, i32 2
  %743 = load i32, ptr %m_size.i.i.i1884, align 4
  %m_capacity.i.i.i1885 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher957, i64 0, i32 5, i32 3
  %744 = load i32, ptr %m_capacity.i.i.i1885, align 8
  %cmp.i.i1886 = icmp eq i32 %743, %744
  br i1 %cmp.i.i1886, label %if.then.i.i1902, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1887

if.then.i.i1902:                                  ; preds = %if.then.i1882
  %tobool.not.i.i.i1904 = icmp eq i32 %743, 0
  %mul.i.i.i1905 = shl nsw i32 %743, 1
  %cond.i.i.i1906 = select i1 %tobool.not.i.i.i1904, i32 1, i32 %mul.i.i.i1905
  %cmp.i4875 = icmp slt i32 %743, %cond.i.i.i1906
  br i1 %cmp.i4875, label %if.then.i4877, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1887

if.then.i4877:                                    ; preds = %if.then.i.i1902
  %tobool.not.i.i4878 = icmp eq i32 %cond.i.i.i1906, 0
  br i1 %tobool.not.i.i4878, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4906, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4879

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4879: ; preds = %if.then.i4877
  %conv.i.i.i4880 = sext i32 %cond.i.i.i1906 to i64
  %mul.i.i.i4881 = shl nsw i64 %conv.i.i.i4880, 5
  %call.i.i.i4909 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i4881, i32 noundef 16)
          to label %call.i.i.i.noexc4908 unwind label %lpad961

call.i.i.i.noexc4908:                             ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4879
  %cmp3.i4882 = icmp eq ptr %call.i.i.i4909, null
  br i1 %cmp3.i4882, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4906, label %if.then.split.i4883

if.then.split.i4883:                              ; preds = %call.i.i.i.noexc4908
  %745 = load i32, ptr %m_size.i.i.i1884, align 4
  %cmp4.i.i4885 = icmp sgt i32 %745, 0
  br i1 %cmp4.i.i4885, label %for.body.lr.ph.i.i4897, label %if.end.i4886

for.body.lr.ph.i.i4897:                           ; preds = %if.then.split.i4883
  %m_data.i.i4898 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher957, i64 0, i32 5, i32 5
  %wide.trip.count.i.i4899 = zext nneg i32 %745 to i64
  br label %for.body.i.i4900

for.body.i.i4900:                                 ; preds = %for.body.i.i4900, %for.body.lr.ph.i.i4897
  %indvars.iv.i.i4901 = phi i64 [ 0, %for.body.lr.ph.i.i4897 ], [ %indvars.iv.next.i.i4904, %for.body.i.i4900 ]
  %arrayidx.i.i4902 = getelementptr inbounds %struct.b3KernelArgData, ptr %call.i.i.i4909, i64 %indvars.iv.i.i4901
  %746 = load ptr, ptr %m_data.i.i4898, align 8
  %arrayidx3.i.i4903 = getelementptr inbounds %struct.b3KernelArgData, ptr %746, i64 %indvars.iv.i.i4901
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i.i4902, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i.i4903, i64 32, i1 false)
  %indvars.iv.next.i.i4904 = add nuw nsw i64 %indvars.iv.i.i4901, 1
  %exitcond.not.i.i4905 = icmp eq i64 %indvars.iv.next.i.i4904, %wide.trip.count.i.i4899
  br i1 %exitcond.not.i.i4905, label %if.end.i4886, label %for.body.i.i4900, !llvm.loop !64

_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4906: ; preds = %call.i.i.i.noexc4908, %if.then.i4877
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc4910 unwind label %lpad961

.noexc4910:                                       ; preds = %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4906
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc4911 unwind label %lpad961

.noexc4911:                                       ; preds = %.noexc4910
  store i32 0, ptr %m_size.i.i.i1884, align 4
  br label %if.end.i4886

if.end.i4886:                                     ; preds = %for.body.i.i4900, %.noexc4911, %if.then.split.i4883
  %retval.0.i25.i4887 = phi ptr [ null, %.noexc4911 ], [ %call.i.i.i4909, %if.then.split.i4883 ], [ %call.i.i.i4909, %for.body.i.i4900 ]
  %_Count.addr.0.i4888 = phi i32 [ 0, %.noexc4911 ], [ %cond.i.i.i1906, %if.then.split.i4883 ], [ %cond.i.i.i1906, %for.body.i.i4900 ]
  %m_data.i20.i4889 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher957, i64 0, i32 5, i32 5
  %747 = load ptr, ptr %m_data.i20.i4889, align 8
  %tobool.not.i21.i4890 = icmp eq ptr %747, null
  br i1 %tobool.not.i21.i4890, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4895, label %if.then.i22.i4891

if.then.i22.i4891:                                ; preds = %if.end.i4886
  %m_ownsMemory.i.i4892 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher957, i64 0, i32 5, i32 6
  %748 = load i8, ptr %m_ownsMemory.i.i4892, align 8
  %749 = and i8 %748, 1
  %tobool2.not.i.i4893 = icmp eq i8 %749, 0
  br i1 %tobool2.not.i.i4893, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4895, label %if.then3.i.i4894

if.then3.i.i4894:                                 ; preds = %if.then.i22.i4891
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %747)
          to label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4895 unwind label %lpad961

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4895: ; preds = %if.then3.i.i4894, %if.then.i22.i4891, %if.end.i4886
  %m_ownsMemory.i4896 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher957, i64 0, i32 5, i32 6
  store i8 1, ptr %m_ownsMemory.i4896, align 8
  store ptr %retval.0.i25.i4887, ptr %m_data.i20.i4889, align 8
  store i32 %_Count.addr.0.i4888, ptr %m_capacity.i.i.i1885, align 8
  %.pre.i.i1907.pre = load i32, ptr %m_size.i.i.i1884, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1887

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1887: ; preds = %if.then.i.i1902, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4895, %if.then.i1882
  %750 = phi i32 [ %743, %if.then.i1882 ], [ %.pre.i.i1907.pre, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4895 ], [ %743, %if.then.i.i1902 ]
  %m_data.i.i1888 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher957, i64 0, i32 5, i32 5
  %751 = load ptr, ptr %m_data.i.i1888, align 8
  %idxprom.i.i1889 = sext i32 %750 to i64
  %arrayidx.i.i1890 = getelementptr inbounds %struct.b3KernelArgData, ptr %751, i64 %idxprom.i.i1889
  store i32 0, ptr %arrayidx.i.i1890, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i1891 = getelementptr inbounds i8, ptr %arrayidx.i.i1890, i64 4
  store i32 %741, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i1891, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i1892 = getelementptr inbounds i8, ptr %arrayidx.i.i1890, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i1892, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i1893 = getelementptr inbounds i8, ptr %arrayidx.i.i1890, i64 16
  store i32 %742, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i1893, align 16
  %752 = load i32, ptr %m_size.i.i.i1884, align 4
  %inc.i.i1894 = add nsw i32 %752, 1
  store i32 %inc.i.i1894, ptr %m_size.i.i.i1884, align 4
  %m_serializationSizeInBytes.i1895 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher957, i64 0, i32 6
  %753 = load i32, ptr %m_serializationSizeInBytes.i1895, align 8
  %add.i1896 = add i32 %753, 32
  store i32 %add.i1896, ptr %m_serializationSizeInBytes.i1895, align 8
  br label %if.end.i1897

if.end.i1897:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1887, %invoke.cont962
  %754 = load ptr, ptr @__clewSetKernelArg, align 8
  %m_kernel.i1898 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher957, i64 0, i32 2
  %755 = load ptr, ptr %m_kernel.i1898, align 8
  %m_idx3.i1899 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher957, i64 0, i32 3
  %756 = load i32, ptr %m_idx3.i1899, align 8
  %inc.i1900 = add nsw i32 %756, 1
  store i32 %inc.i1900, ptr %m_idx3.i1899, align 8
  %call.i19011909 = invoke i32 %754(ptr noundef %755, i32 noundef %756, i64 noundef 4, ptr noundef nonnull %nPairs.addr)
          to label %invoke.cont963 unwind label %lpad961

invoke.cont963:                                   ; preds = %if.end.i1897
  %757 = load i8, ptr %m_enableSerialization.i1880, align 4
  %758 = and i8 %757, 1
  %tobool.not.i1912 = icmp eq i8 %758, 0
  br i1 %tobool.not.i1912, label %if.end.i1928, label %if.then.i1913

if.then.i1913:                                    ; preds = %invoke.cont963
  %759 = load i32, ptr %m_idx3.i1899, align 8
  %760 = load i32, ptr %compoundPairCapacity.addr, align 4
  %m_size.i.i.i1915 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher957, i64 0, i32 5, i32 2
  %761 = load i32, ptr %m_size.i.i.i1915, align 4
  %m_capacity.i.i.i1916 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher957, i64 0, i32 5, i32 3
  %762 = load i32, ptr %m_capacity.i.i.i1916, align 8
  %cmp.i.i1917 = icmp eq i32 %761, %762
  br i1 %cmp.i.i1917, label %if.then.i.i1933, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1918

if.then.i.i1933:                                  ; preds = %if.then.i1913
  %tobool.not.i.i.i1935 = icmp eq i32 %761, 0
  %mul.i.i.i1936 = shl nsw i32 %761, 1
  %cond.i.i.i1937 = select i1 %tobool.not.i.i.i1935, i32 1, i32 %mul.i.i.i1936
  %cmp.i4915 = icmp slt i32 %761, %cond.i.i.i1937
  br i1 %cmp.i4915, label %if.then.i4917, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1918

if.then.i4917:                                    ; preds = %if.then.i.i1933
  %tobool.not.i.i4918 = icmp eq i32 %cond.i.i.i1937, 0
  br i1 %tobool.not.i.i4918, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4946, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4919

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4919: ; preds = %if.then.i4917
  %conv.i.i.i4920 = sext i32 %cond.i.i.i1937 to i64
  %mul.i.i.i4921 = shl nsw i64 %conv.i.i.i4920, 5
  %call.i.i.i4949 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i4921, i32 noundef 16)
          to label %call.i.i.i.noexc4948 unwind label %lpad961

call.i.i.i.noexc4948:                             ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4919
  %cmp3.i4922 = icmp eq ptr %call.i.i.i4949, null
  br i1 %cmp3.i4922, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4946, label %if.then.split.i4923

if.then.split.i4923:                              ; preds = %call.i.i.i.noexc4948
  %763 = load i32, ptr %m_size.i.i.i1915, align 4
  %cmp4.i.i4925 = icmp sgt i32 %763, 0
  br i1 %cmp4.i.i4925, label %for.body.lr.ph.i.i4937, label %if.end.i4926

for.body.lr.ph.i.i4937:                           ; preds = %if.then.split.i4923
  %m_data.i.i4938 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher957, i64 0, i32 5, i32 5
  %wide.trip.count.i.i4939 = zext nneg i32 %763 to i64
  br label %for.body.i.i4940

for.body.i.i4940:                                 ; preds = %for.body.i.i4940, %for.body.lr.ph.i.i4937
  %indvars.iv.i.i4941 = phi i64 [ 0, %for.body.lr.ph.i.i4937 ], [ %indvars.iv.next.i.i4944, %for.body.i.i4940 ]
  %arrayidx.i.i4942 = getelementptr inbounds %struct.b3KernelArgData, ptr %call.i.i.i4949, i64 %indvars.iv.i.i4941
  %764 = load ptr, ptr %m_data.i.i4938, align 8
  %arrayidx3.i.i4943 = getelementptr inbounds %struct.b3KernelArgData, ptr %764, i64 %indvars.iv.i.i4941
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i.i4942, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i.i4943, i64 32, i1 false)
  %indvars.iv.next.i.i4944 = add nuw nsw i64 %indvars.iv.i.i4941, 1
  %exitcond.not.i.i4945 = icmp eq i64 %indvars.iv.next.i.i4944, %wide.trip.count.i.i4939
  br i1 %exitcond.not.i.i4945, label %if.end.i4926, label %for.body.i.i4940, !llvm.loop !64

_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4946: ; preds = %call.i.i.i.noexc4948, %if.then.i4917
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc4950 unwind label %lpad961

.noexc4950:                                       ; preds = %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4946
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc4951 unwind label %lpad961

.noexc4951:                                       ; preds = %.noexc4950
  store i32 0, ptr %m_size.i.i.i1915, align 4
  br label %if.end.i4926

if.end.i4926:                                     ; preds = %for.body.i.i4940, %.noexc4951, %if.then.split.i4923
  %retval.0.i25.i4927 = phi ptr [ null, %.noexc4951 ], [ %call.i.i.i4949, %if.then.split.i4923 ], [ %call.i.i.i4949, %for.body.i.i4940 ]
  %_Count.addr.0.i4928 = phi i32 [ 0, %.noexc4951 ], [ %cond.i.i.i1937, %if.then.split.i4923 ], [ %cond.i.i.i1937, %for.body.i.i4940 ]
  %m_data.i20.i4929 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher957, i64 0, i32 5, i32 5
  %765 = load ptr, ptr %m_data.i20.i4929, align 8
  %tobool.not.i21.i4930 = icmp eq ptr %765, null
  br i1 %tobool.not.i21.i4930, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4935, label %if.then.i22.i4931

if.then.i22.i4931:                                ; preds = %if.end.i4926
  %m_ownsMemory.i.i4932 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher957, i64 0, i32 5, i32 6
  %766 = load i8, ptr %m_ownsMemory.i.i4932, align 8
  %767 = and i8 %766, 1
  %tobool2.not.i.i4933 = icmp eq i8 %767, 0
  br i1 %tobool2.not.i.i4933, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4935, label %if.then3.i.i4934

if.then3.i.i4934:                                 ; preds = %if.then.i22.i4931
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %765)
          to label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4935 unwind label %lpad961

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4935: ; preds = %if.then3.i.i4934, %if.then.i22.i4931, %if.end.i4926
  %m_ownsMemory.i4936 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher957, i64 0, i32 5, i32 6
  store i8 1, ptr %m_ownsMemory.i4936, align 8
  store ptr %retval.0.i25.i4927, ptr %m_data.i20.i4929, align 8
  store i32 %_Count.addr.0.i4928, ptr %m_capacity.i.i.i1916, align 8
  %.pre.i.i1938.pre = load i32, ptr %m_size.i.i.i1915, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1918

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1918: ; preds = %if.then.i.i1933, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4935, %if.then.i1913
  %768 = phi i32 [ %761, %if.then.i1913 ], [ %.pre.i.i1938.pre, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4935 ], [ %761, %if.then.i.i1933 ]
  %m_data.i.i1919 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher957, i64 0, i32 5, i32 5
  %769 = load ptr, ptr %m_data.i.i1919, align 8
  %idxprom.i.i1920 = sext i32 %768 to i64
  %arrayidx.i.i1921 = getelementptr inbounds %struct.b3KernelArgData, ptr %769, i64 %idxprom.i.i1920
  store i32 0, ptr %arrayidx.i.i1921, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i1922 = getelementptr inbounds i8, ptr %arrayidx.i.i1921, i64 4
  store i32 %759, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i1922, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i1923 = getelementptr inbounds i8, ptr %arrayidx.i.i1921, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i1923, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i1924 = getelementptr inbounds i8, ptr %arrayidx.i.i1921, i64 16
  store i32 %760, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i1924, align 16
  %770 = load i32, ptr %m_size.i.i.i1915, align 4
  %inc.i.i1925 = add nsw i32 %770, 1
  store i32 %inc.i.i1925, ptr %m_size.i.i.i1915, align 4
  %m_serializationSizeInBytes.i1926 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher957, i64 0, i32 6
  %771 = load i32, ptr %m_serializationSizeInBytes.i1926, align 8
  %add.i1927 = add i32 %771, 32
  store i32 %add.i1927, ptr %m_serializationSizeInBytes.i1926, align 8
  br label %if.end.i1928

if.end.i1928:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i1918, %invoke.cont963
  %772 = load ptr, ptr @__clewSetKernelArg, align 8
  %773 = load ptr, ptr %m_kernel.i1898, align 8
  %774 = load i32, ptr %m_idx3.i1899, align 8
  %inc.i1931 = add nsw i32 %774, 1
  store i32 %inc.i1931, ptr %m_idx3.i1899, align 8
  %call.i19321940 = invoke i32 %772(ptr noundef %773, i32 noundef %774, i64 noundef 4, ptr noundef nonnull %compoundPairCapacity.addr)
          to label %invoke.cont964 unwind label %lpad961

invoke.cont964:                                   ; preds = %if.end.i1928
  %775 = load i32, ptr %nPairs.addr, align 4
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %gRange.i.i1942)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %lRange.i.i1943)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %gRange.i.i1942, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %lRange.i.i1943, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  store i64 64, ptr %lRange.i.i1943, align 16
  %arrayidx3.i.i1944 = getelementptr inbounds [3 x i64], ptr %lRange.i.i1943, i64 0, i64 1
  store i64 1, ptr %arrayidx3.i.i1944, align 8
  %conv5.i.i1945 = sext i32 %775 to i64
  %div.i.i19466122 = lshr i64 %conv5.i.i1945, 6
  %rem.i.i1947 = and i64 %conv5.i.i1945, 63
  %tobool.not.i.i1948 = icmp ne i64 %rem.i.i1947, 0
  %conv9.i.i1949 = zext i1 %tobool.not.i.i1948 to i64
  %add.i.i1950 = add nuw nsw i64 %div.i.i19466122, %conv9.i.i1949
  %.sroa.speculated8.i.i1951 = call i64 @llvm.umax.i64(i64 %add.i.i1950, i64 1)
  %mul.i.i1952 = shl i64 %.sroa.speculated8.i.i1951, 6
  store i64 %mul.i.i1952, ptr %gRange.i.i1942, align 16
  %arrayidx27.i.i1953 = getelementptr inbounds [3 x i64], ptr %gRange.i.i1942, i64 0, i64 1
  store i64 1, ptr %arrayidx27.i.i1953, align 8
  %776 = load ptr, ptr @__clewEnqueueNDRangeKernel, align 8
  %m_commandQueue.i.i1954 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher957, i64 0, i32 1
  %777 = load ptr, ptr %m_commandQueue.i.i1954, align 8
  %778 = load ptr, ptr %m_kernel.i1898, align 8
  %call32.i.i1960 = invoke i32 %776(ptr noundef %777, ptr noundef %778, i32 noundef 2, ptr noundef null, ptr noundef nonnull %gRange.i.i1942, ptr noundef nonnull %lRange.i.i1943, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call32.i.i.noexc1959 unwind label %lpad961

call32.i.i.noexc1959:                             ; preds = %invoke.cont964
  %cmp.not.i.i1956 = icmp eq i32 %call32.i.i1960, 0
  br i1 %cmp.not.i.i1956, label %invoke.cont966, label %if.then.i.i1957

if.then.i.i1957:                                  ; preds = %call32.i.i.noexc1959
  %call33.i.i1958 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.74, i32 noundef %call32.i.i1960)
  br label %invoke.cont966

invoke.cont966:                                   ; preds = %if.then.i.i1957, %call32.i.i.noexc1959
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %gRange.i.i1942)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %lRange.i.i1943)
  %779 = load ptr, ptr @__clewFinish, align 8
  %780 = load ptr, ptr %m_queue, align 8
  %call969 = invoke i32 %779(ptr noundef %780)
          to label %invoke.cont968 unwind label %lpad961

invoke.cont968:                                   ; preds = %invoke.cont966
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %elem.i1962)
  %781 = load i64, ptr %m_capacity.i.i679, align 8
  %cmp.not.i.i1964 = icmp eq i64 %781, 0
  br i1 %cmp.not.i.i1964, label %do.body.i.i1969, label %if.then.i.i1965

if.then.i.i1965:                                  ; preds = %invoke.cont968
  %782 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %783 = load ptr, ptr %m_commandQueue.i.i685, align 8
  %784 = load ptr, ptr %m_clBuffer.i.i686, align 8
  %call3.i.i1971 = invoke i32 %782(ptr noundef %783, ptr noundef %784, i32 noundef 0, i64 noundef 0, i64 noundef 4, ptr noundef nonnull %elem.i1962, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call3.i.i.noexc1970 unwind label %lpad961

call3.i.i.noexc1970:                              ; preds = %if.then.i.i1965
  %785 = load ptr, ptr @__clewFinish, align 8
  %786 = load ptr, ptr %m_commandQueue.i.i685, align 8
  %call6.i.i1973 = invoke i32 %785(ptr noundef %786)
          to label %call6.i.i.noexc1972 unwind label %lpad961

call6.i.i.noexc1972:                              ; preds = %call3.i.i.noexc1970
  %.pre.i1968 = load i32, ptr %elem.i1962, align 4
  br label %invoke.cont971

do.body.i.i1969:                                  ; preds = %invoke.cont968
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 285)
          to label %.noexc1974 unwind label %lpad961

.noexc1974:                                       ; preds = %do.body.i.i1969
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.80)
          to label %invoke.cont971 unwind label %lpad961

invoke.cont971:                                   ; preds = %call6.i.i.noexc1972, %.noexc1974
  %787 = phi i32 [ %.pre.i1968, %call6.i.i.noexc1972 ], [ undef, %.noexc1974 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %elem.i1962)
  store i32 %787, ptr %numCompoundPairs, align 4
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher957) #26
  invoke void @b3LeaveProfileZone()
          to label %_ZN13b3ProfileZoneD2Ev.exit1978 unwind label %terminate.lpad.i1977

terminate.lpad.i1977:                             ; preds = %invoke.cont971
  %788 = landingpad { ptr, i32 }
          catch ptr null
  %789 = extractvalue { ptr, i32 } %788, 0
  call void @__clang_call_terminate(ptr %789) #27
  unreachable

_ZN13b3ProfileZoneD2Ev.exit1978:                  ; preds = %invoke.cont971
  %790 = load i32, ptr %numCompoundPairs, align 4
  %tobool1083.not = icmp eq i32 %790, 0
  br i1 %tobool1083.not, label %if.end1087, label %if.then1084

lpad895:                                          ; preds = %invoke.cont892
  %791 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup977

lpad961:                                          ; preds = %if.then3.i.i4934, %.noexc4950, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4946, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4919, %if.then3.i.i4894, %.noexc4910, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4906, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4879, %.noexc1974, %do.body.i.i1969, %call3.i.i.noexc1970, %if.then.i.i1965, %invoke.cont964, %if.end.i1928, %if.end.i1897, %invoke.cont966, %invoke.cont959
  %792 = landingpad { ptr, i32 }
          cleanup
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher957) #26
  br label %ehcleanup977

ehcleanup977:                                     ; preds = %lpad961, %lpad895
  %.pn468 = phi { ptr, i32 } [ %792, %lpad961 ], [ %791, %lpad895 ]
  invoke void @b3LeaveProfileZone()
          to label %ehcleanup2980 unwind label %terminate.lpad.i1979

terminate.lpad.i1979:                             ; preds = %ehcleanup977
  %793 = landingpad { ptr, i32 }
          catch ptr null
  %794 = extractvalue { ptr, i32 } %793, 0
  call void @__clang_call_terminate(ptr %794) #27
  unreachable

if.then1084:                                      ; preds = %_ZN13b3ProfileZoneD2Ev.exit1978
  %call1086 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.48, i32 noundef %790)
  %.pre6183 = load i32, ptr %numCompoundPairs, align 4
  br label %if.end1087

if.end1087:                                       ; preds = %if.then1084, %_ZN13b3ProfileZoneD2Ev.exit1978
  %795 = phi i32 [ %.pre6183, %if.then1084 ], [ 0, %_ZN13b3ProfileZoneD2Ev.exit1978 ]
  %796 = load i32, ptr %compoundPairCapacity.addr, align 4
  %cmp1088 = icmp sgt i32 %795, %796
  br i1 %cmp1088, label %do.body1090, label %if.end1095

do.body1090:                                      ; preds = %if.end1087
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.31, i32 noundef 3407)
          to label %invoke.cont1091 unwind label %lpad58

invoke.cont1091:                                  ; preds = %do.body1090
  %797 = load i32, ptr %numCompoundPairs, align 4
  %798 = load i32, ptr %compoundPairCapacity.addr, align 4
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.49, i32 noundef %797, i32 noundef %798)
          to label %do.end1094 unwind label %lpad58

do.end1094:                                       ; preds = %invoke.cont1091
  %799 = load i32, ptr %compoundPairCapacity.addr, align 4
  store i32 %799, ptr %numCompoundPairs, align 4
  br label %if.end1095

if.end1095:                                       ; preds = %do.end1094, %if.end1087
  %800 = phi i32 [ %799, %do.end1094 ], [ %795, %if.end1087 ]
  %conv1097 = sext i32 %800 to i64
  %801 = load i64, ptr %m_size.i.i649, align 8
  %cmp3.i1982 = icmp ult i64 %801, %conv1097
  br i1 %cmp3.i1982, label %if.end7.i1985, label %invoke.cont1098

if.end7.i1985:                                    ; preds = %if.end1095
  %call5.i1988 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuCompoundPairs, i64 noundef %conv1097, i1 noundef zeroext true)
          to label %call5.i.noexc1987 unwind label %lpad58

call5.i.noexc1987:                                ; preds = %if.end7.i1985
  %spec.select.i1986 = select i1 %call5.i1988, i64 %conv1097, i64 0
  %.pre6184 = load i32, ptr %numCompoundPairs, align 4
  %.pre6240 = sext i32 %.pre6184 to i64
  br label %invoke.cont1098

invoke.cont1098:                                  ; preds = %call5.i.noexc1987, %if.end1095
  %conv1101.pre-phi = phi i64 [ %.pre6240, %call5.i.noexc1987 ], [ %conv1097, %if.end1095 ]
  %802 = phi i32 [ %.pre6184, %call5.i.noexc1987 ], [ %800, %if.end1095 ]
  %storemerge.i1983 = phi i64 [ %spec.select.i1986, %call5.i.noexc1987 ], [ %conv1097, %if.end1095 ]
  store i64 %storemerge.i1983, ptr %m_size.i.i649, align 8
  %803 = load i64, ptr %m_size.i.i666, align 8
  %cmp3.i1991 = icmp ult i64 %803, %conv1101.pre-phi
  br i1 %cmp3.i1991, label %if.end7.i1994, label %invoke.cont1102

if.end7.i1994:                                    ; preds = %invoke.cont1098
  %call5.i1997 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayIiE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuHasCompoundSepNormals, i64 noundef %conv1101.pre-phi, i1 noundef zeroext true)
          to label %call5.i.noexc1996 unwind label %lpad58

call5.i.noexc1996:                                ; preds = %if.end7.i1994
  %spec.select.i1995 = select i1 %call5.i1997, i64 %conv1101.pre-phi, i64 0
  %.pre6185 = load i32, ptr %numCompoundPairs, align 4
  %.pre6241 = sext i32 %.pre6185 to i64
  br label %invoke.cont1102

invoke.cont1102:                                  ; preds = %call5.i.noexc1996, %invoke.cont1098
  %conv1105.pre-phi = phi i64 [ %.pre6241, %call5.i.noexc1996 ], [ %conv1101.pre-phi, %invoke.cont1098 ]
  %804 = phi i32 [ %.pre6185, %call5.i.noexc1996 ], [ %802, %invoke.cont1098 ]
  %storemerge.i1992 = phi i64 [ %spec.select.i1995, %call5.i.noexc1996 ], [ %conv1101.pre-phi, %invoke.cont1098 ]
  store i64 %storemerge.i1992, ptr %m_size.i.i666, align 8
  %805 = load i64, ptr %m_size.i.i657, align 8
  %cmp3.i2000 = icmp ult i64 %805, %conv1105.pre-phi
  br i1 %cmp3.i2000, label %if.end7.i2003, label %invoke.cont1106

if.end7.i2003:                                    ; preds = %invoke.cont1102
  %call5.i2006 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_gpuCompoundSepNormals, i64 noundef %conv1105.pre-phi, i1 noundef zeroext true)
          to label %call5.i.noexc2005 unwind label %lpad58

call5.i.noexc2005:                                ; preds = %if.end7.i2003
  %spec.select.i2004 = select i1 %call5.i2006, i64 %conv1105.pre-phi, i64 0
  %.pr6093 = load i32, ptr %numCompoundPairs, align 4
  br label %invoke.cont1106

invoke.cont1106:                                  ; preds = %call5.i.noexc2005, %invoke.cont1102
  %806 = phi i32 [ %.pr6093, %call5.i.noexc2005 ], [ %804, %invoke.cont1102 ]
  %storemerge.i2001 = phi i64 [ %spec.select.i2004, %call5.i.noexc2005 ], [ %conv1105.pre-phi, %invoke.cont1102 ]
  store i64 %storemerge.i2001, ptr %m_size.i.i657, align 8
  %tobool1108.not = icmp eq i32 %806, 0
  br i1 %tobool1108.not, label %if.end1262, label %if.then1109

if.then1109:                                      ; preds = %invoke.cont1106
  invoke void @b3EnterProfileZone(ptr noundef nonnull @.str.29)
          to label %invoke.cont1111 unwind label %lpad58

invoke.cont1111:                                  ; preds = %if.then1109
  %807 = load ptr, ptr %m_clBuffer.i1870, align 8
  store ptr %807, ptr %bInfo1112, align 16
  %m_isReadOnly.i2011 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1112, i64 0, i32 1
  store i8 1, ptr %m_isReadOnly.i2011, align 8
  %arrayinit.element1119 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1112, i64 1
  %808 = load ptr, ptr %m_clBuffer.i531, align 8
  store ptr %808, ptr %arrayinit.element1119, align 16
  %m_isReadOnly.i2013 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1112, i64 1, i32 1
  store i8 1, ptr %m_isReadOnly.i2013, align 8
  %arrayinit.element1123 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1112, i64 2
  %809 = load ptr, ptr %m_clBuffer.i533, align 8
  store ptr %809, ptr %arrayinit.element1123, align 16
  %m_isReadOnly.i2015 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1112, i64 2, i32 1
  store i8 1, ptr %m_isReadOnly.i2015, align 8
  %arrayinit.element1127 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1112, i64 3
  %810 = load ptr, ptr %m_clBuffer.i535, align 8
  store ptr %810, ptr %arrayinit.element1127, align 16
  %m_isReadOnly.i2017 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1112, i64 3, i32 1
  store i8 1, ptr %m_isReadOnly.i2017, align 8
  %arrayinit.element1131 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1112, i64 4
  %811 = load ptr, ptr %m_clBuffer.i537, align 8
  store ptr %811, ptr %arrayinit.element1131, align 16
  %m_isReadOnly.i2019 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1112, i64 4, i32 1
  store i8 1, ptr %m_isReadOnly.i2019, align 8
  %arrayinit.element1135 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1112, i64 5
  %812 = load ptr, ptr %m_clBuffer.i539, align 8
  store ptr %812, ptr %arrayinit.element1135, align 16
  %m_isReadOnly.i2021 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1112, i64 5, i32 1
  store i8 1, ptr %m_isReadOnly.i2021, align 8
  %arrayinit.element1139 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1112, i64 6
  %813 = load ptr, ptr %m_clBuffer.i541, align 8
  store ptr %813, ptr %arrayinit.element1139, align 16
  %m_isReadOnly.i2023 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1112, i64 6, i32 1
  store i8 1, ptr %m_isReadOnly.i2023, align 8
  %arrayinit.element1143 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1112, i64 7
  %814 = load ptr, ptr %m_clBuffer.i543, align 8
  store ptr %814, ptr %arrayinit.element1143, align 16
  %m_isReadOnly.i2025 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1112, i64 7, i32 1
  store i8 1, ptr %m_isReadOnly.i2025, align 8
  %arrayinit.element1147 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1112, i64 8
  %m_clBuffer.i2026 = getelementptr inbounds %class.b3OpenCLArray.90, ptr %clAabbsWorldSpace, i64 0, i32 3
  %815 = load ptr, ptr %m_clBuffer.i2026, align 8
  store ptr %815, ptr %arrayinit.element1147, align 16
  %m_isReadOnly.i2027 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1112, i64 8, i32 1
  store i8 1, ptr %m_isReadOnly.i2027, align 8
  %arrayinit.element1151 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1112, i64 9
  %816 = load ptr, ptr %m_clBuffer.i1868, align 8
  store ptr %816, ptr %arrayinit.element1151, align 16
  %m_isReadOnly.i2029 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1112, i64 9, i32 1
  store i8 1, ptr %m_isReadOnly.i2029, align 8
  %arrayinit.element1155 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1112, i64 10
  %817 = load ptr, ptr %m_clBuffer.i545, align 8
  store ptr %817, ptr %arrayinit.element1155, align 16
  %m_isReadOnly.i2031 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1112, i64 10, i32 1
  store i8 0, ptr %m_isReadOnly.i2031, align 8
  %arrayinit.element1159 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1112, i64 11
  %818 = load ptr, ptr %m_clBuffer.i, align 8
  store ptr %818, ptr %arrayinit.element1159, align 16
  %m_isReadOnly.i2033 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1112, i64 11, i32 1
  store i8 0, ptr %m_isReadOnly.i2033, align 8
  %819 = load ptr, ptr %m_queue, align 8
  %m_processCompoundPairsPrimitivesKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 23
  %820 = load ptr, ptr %m_processCompoundPairsPrimitivesKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher1164, ptr noundef %819, ptr noundef %820, ptr noundef nonnull @.str.50)
          to label %invoke.cont1166 unwind label %lpad1115

invoke.cont1166:                                  ; preds = %invoke.cont1111
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher1164, ptr noundef nonnull %bInfo1112, i32 noundef 12)
          to label %invoke.cont1169 unwind label %lpad1168

invoke.cont1169:                                  ; preds = %invoke.cont1166
  %m_enableSerialization.i2034 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1164, i64 0, i32 7
  %821 = load i8, ptr %m_enableSerialization.i2034, align 4
  %822 = and i8 %821, 1
  %tobool.not.i2035 = icmp eq i8 %822, 0
  br i1 %tobool.not.i2035, label %if.end.i2051, label %if.then.i2036

if.then.i2036:                                    ; preds = %invoke.cont1169
  %m_idx.i2037 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1164, i64 0, i32 3
  %823 = load i32, ptr %m_idx.i2037, align 8
  %824 = load i32, ptr %numCompoundPairs, align 4
  %m_size.i.i.i2038 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1164, i64 0, i32 5, i32 2
  %825 = load i32, ptr %m_size.i.i.i2038, align 4
  %m_capacity.i.i.i2039 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1164, i64 0, i32 5, i32 3
  %826 = load i32, ptr %m_capacity.i.i.i2039, align 8
  %cmp.i.i2040 = icmp eq i32 %825, %826
  br i1 %cmp.i.i2040, label %if.then.i.i2056, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2041

if.then.i.i2056:                                  ; preds = %if.then.i2036
  %tobool.not.i.i.i2058 = icmp eq i32 %825, 0
  %mul.i.i.i2059 = shl nsw i32 %825, 1
  %cond.i.i.i2060 = select i1 %tobool.not.i.i.i2058, i32 1, i32 %mul.i.i.i2059
  %cmp.i4955 = icmp slt i32 %825, %cond.i.i.i2060
  br i1 %cmp.i4955, label %if.then.i4957, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2041

if.then.i4957:                                    ; preds = %if.then.i.i2056
  %tobool.not.i.i4958 = icmp eq i32 %cond.i.i.i2060, 0
  br i1 %tobool.not.i.i4958, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4986, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4959

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4959: ; preds = %if.then.i4957
  %conv.i.i.i4960 = sext i32 %cond.i.i.i2060 to i64
  %mul.i.i.i4961 = shl nsw i64 %conv.i.i.i4960, 5
  %call.i.i.i4989 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i4961, i32 noundef 16)
          to label %call.i.i.i.noexc4988 unwind label %lpad1168

call.i.i.i.noexc4988:                             ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4959
  %cmp3.i4962 = icmp eq ptr %call.i.i.i4989, null
  br i1 %cmp3.i4962, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4986, label %if.then.split.i4963

if.then.split.i4963:                              ; preds = %call.i.i.i.noexc4988
  %827 = load i32, ptr %m_size.i.i.i2038, align 4
  %cmp4.i.i4965 = icmp sgt i32 %827, 0
  br i1 %cmp4.i.i4965, label %for.body.lr.ph.i.i4977, label %if.end.i4966

for.body.lr.ph.i.i4977:                           ; preds = %if.then.split.i4963
  %m_data.i.i4978 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1164, i64 0, i32 5, i32 5
  %wide.trip.count.i.i4979 = zext nneg i32 %827 to i64
  br label %for.body.i.i4980

for.body.i.i4980:                                 ; preds = %for.body.i.i4980, %for.body.lr.ph.i.i4977
  %indvars.iv.i.i4981 = phi i64 [ 0, %for.body.lr.ph.i.i4977 ], [ %indvars.iv.next.i.i4984, %for.body.i.i4980 ]
  %arrayidx.i.i4982 = getelementptr inbounds %struct.b3KernelArgData, ptr %call.i.i.i4989, i64 %indvars.iv.i.i4981
  %828 = load ptr, ptr %m_data.i.i4978, align 8
  %arrayidx3.i.i4983 = getelementptr inbounds %struct.b3KernelArgData, ptr %828, i64 %indvars.iv.i.i4981
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i.i4982, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i.i4983, i64 32, i1 false)
  %indvars.iv.next.i.i4984 = add nuw nsw i64 %indvars.iv.i.i4981, 1
  %exitcond.not.i.i4985 = icmp eq i64 %indvars.iv.next.i.i4984, %wide.trip.count.i.i4979
  br i1 %exitcond.not.i.i4985, label %if.end.i4966, label %for.body.i.i4980, !llvm.loop !64

_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4986: ; preds = %call.i.i.i.noexc4988, %if.then.i4957
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc4990 unwind label %lpad1168

.noexc4990:                                       ; preds = %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4986
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc4991 unwind label %lpad1168

.noexc4991:                                       ; preds = %.noexc4990
  store i32 0, ptr %m_size.i.i.i2038, align 4
  br label %if.end.i4966

if.end.i4966:                                     ; preds = %for.body.i.i4980, %.noexc4991, %if.then.split.i4963
  %retval.0.i25.i4967 = phi ptr [ null, %.noexc4991 ], [ %call.i.i.i4989, %if.then.split.i4963 ], [ %call.i.i.i4989, %for.body.i.i4980 ]
  %_Count.addr.0.i4968 = phi i32 [ 0, %.noexc4991 ], [ %cond.i.i.i2060, %if.then.split.i4963 ], [ %cond.i.i.i2060, %for.body.i.i4980 ]
  %m_data.i20.i4969 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1164, i64 0, i32 5, i32 5
  %829 = load ptr, ptr %m_data.i20.i4969, align 8
  %tobool.not.i21.i4970 = icmp eq ptr %829, null
  br i1 %tobool.not.i21.i4970, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4975, label %if.then.i22.i4971

if.then.i22.i4971:                                ; preds = %if.end.i4966
  %m_ownsMemory.i.i4972 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1164, i64 0, i32 5, i32 6
  %830 = load i8, ptr %m_ownsMemory.i.i4972, align 8
  %831 = and i8 %830, 1
  %tobool2.not.i.i4973 = icmp eq i8 %831, 0
  br i1 %tobool2.not.i.i4973, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4975, label %if.then3.i.i4974

if.then3.i.i4974:                                 ; preds = %if.then.i22.i4971
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %829)
          to label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4975 unwind label %lpad1168

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4975: ; preds = %if.then3.i.i4974, %if.then.i22.i4971, %if.end.i4966
  %m_ownsMemory.i4976 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1164, i64 0, i32 5, i32 6
  store i8 1, ptr %m_ownsMemory.i4976, align 8
  store ptr %retval.0.i25.i4967, ptr %m_data.i20.i4969, align 8
  store i32 %_Count.addr.0.i4968, ptr %m_capacity.i.i.i2039, align 8
  %.pre.i.i2061.pre = load i32, ptr %m_size.i.i.i2038, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2041

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2041: ; preds = %if.then.i.i2056, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4975, %if.then.i2036
  %832 = phi i32 [ %825, %if.then.i2036 ], [ %.pre.i.i2061.pre, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i4975 ], [ %825, %if.then.i.i2056 ]
  %m_data.i.i2042 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1164, i64 0, i32 5, i32 5
  %833 = load ptr, ptr %m_data.i.i2042, align 8
  %idxprom.i.i2043 = sext i32 %832 to i64
  %arrayidx.i.i2044 = getelementptr inbounds %struct.b3KernelArgData, ptr %833, i64 %idxprom.i.i2043
  store i32 0, ptr %arrayidx.i.i2044, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i2045 = getelementptr inbounds i8, ptr %arrayidx.i.i2044, i64 4
  store i32 %823, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i2045, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i2046 = getelementptr inbounds i8, ptr %arrayidx.i.i2044, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i2046, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i2047 = getelementptr inbounds i8, ptr %arrayidx.i.i2044, i64 16
  store i32 %824, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i2047, align 16
  %834 = load i32, ptr %m_size.i.i.i2038, align 4
  %inc.i.i2048 = add nsw i32 %834, 1
  store i32 %inc.i.i2048, ptr %m_size.i.i.i2038, align 4
  %m_serializationSizeInBytes.i2049 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1164, i64 0, i32 6
  %835 = load i32, ptr %m_serializationSizeInBytes.i2049, align 8
  %add.i2050 = add i32 %835, 32
  store i32 %add.i2050, ptr %m_serializationSizeInBytes.i2049, align 8
  br label %if.end.i2051

if.end.i2051:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2041, %invoke.cont1169
  %836 = load ptr, ptr @__clewSetKernelArg, align 8
  %m_kernel.i2052 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1164, i64 0, i32 2
  %837 = load ptr, ptr %m_kernel.i2052, align 8
  %m_idx3.i2053 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1164, i64 0, i32 3
  %838 = load i32, ptr %m_idx3.i2053, align 8
  %inc.i2054 = add nsw i32 %838, 1
  store i32 %inc.i2054, ptr %m_idx3.i2053, align 8
  %call.i20552063 = invoke i32 %836(ptr noundef %837, i32 noundef %838, i64 noundef 4, ptr noundef nonnull %numCompoundPairs)
          to label %invoke.cont1170 unwind label %lpad1168

invoke.cont1170:                                  ; preds = %if.end.i2051
  %839 = load i8, ptr %m_enableSerialization.i2034, align 4
  %840 = and i8 %839, 1
  %tobool.not.i2066 = icmp eq i8 %840, 0
  br i1 %tobool.not.i2066, label %if.end.i2082, label %if.then.i2067

if.then.i2067:                                    ; preds = %invoke.cont1170
  %841 = load i32, ptr %m_idx3.i2053, align 8
  %842 = load i32, ptr %maxContactCapacity.addr, align 4
  %m_size.i.i.i2069 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1164, i64 0, i32 5, i32 2
  %843 = load i32, ptr %m_size.i.i.i2069, align 4
  %m_capacity.i.i.i2070 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1164, i64 0, i32 5, i32 3
  %844 = load i32, ptr %m_capacity.i.i.i2070, align 8
  %cmp.i.i2071 = icmp eq i32 %843, %844
  br i1 %cmp.i.i2071, label %if.then.i.i2087, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2072

if.then.i.i2087:                                  ; preds = %if.then.i2067
  %tobool.not.i.i.i2089 = icmp eq i32 %843, 0
  %mul.i.i.i2090 = shl nsw i32 %843, 1
  %cond.i.i.i2091 = select i1 %tobool.not.i.i.i2089, i32 1, i32 %mul.i.i.i2090
  %cmp.i4995 = icmp slt i32 %843, %cond.i.i.i2091
  br i1 %cmp.i4995, label %if.then.i4997, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2072

if.then.i4997:                                    ; preds = %if.then.i.i2087
  %tobool.not.i.i4998 = icmp eq i32 %cond.i.i.i2091, 0
  br i1 %tobool.not.i.i4998, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5026, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4999

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4999: ; preds = %if.then.i4997
  %conv.i.i.i5000 = sext i32 %cond.i.i.i2091 to i64
  %mul.i.i.i5001 = shl nsw i64 %conv.i.i.i5000, 5
  %call.i.i.i5029 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i5001, i32 noundef 16)
          to label %call.i.i.i.noexc5028 unwind label %lpad1168

call.i.i.i.noexc5028:                             ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4999
  %cmp3.i5002 = icmp eq ptr %call.i.i.i5029, null
  br i1 %cmp3.i5002, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5026, label %if.then.split.i5003

if.then.split.i5003:                              ; preds = %call.i.i.i.noexc5028
  %845 = load i32, ptr %m_size.i.i.i2069, align 4
  %cmp4.i.i5005 = icmp sgt i32 %845, 0
  br i1 %cmp4.i.i5005, label %for.body.lr.ph.i.i5017, label %if.end.i5006

for.body.lr.ph.i.i5017:                           ; preds = %if.then.split.i5003
  %m_data.i.i5018 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1164, i64 0, i32 5, i32 5
  %wide.trip.count.i.i5019 = zext nneg i32 %845 to i64
  br label %for.body.i.i5020

for.body.i.i5020:                                 ; preds = %for.body.i.i5020, %for.body.lr.ph.i.i5017
  %indvars.iv.i.i5021 = phi i64 [ 0, %for.body.lr.ph.i.i5017 ], [ %indvars.iv.next.i.i5024, %for.body.i.i5020 ]
  %arrayidx.i.i5022 = getelementptr inbounds %struct.b3KernelArgData, ptr %call.i.i.i5029, i64 %indvars.iv.i.i5021
  %846 = load ptr, ptr %m_data.i.i5018, align 8
  %arrayidx3.i.i5023 = getelementptr inbounds %struct.b3KernelArgData, ptr %846, i64 %indvars.iv.i.i5021
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i.i5022, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i.i5023, i64 32, i1 false)
  %indvars.iv.next.i.i5024 = add nuw nsw i64 %indvars.iv.i.i5021, 1
  %exitcond.not.i.i5025 = icmp eq i64 %indvars.iv.next.i.i5024, %wide.trip.count.i.i5019
  br i1 %exitcond.not.i.i5025, label %if.end.i5006, label %for.body.i.i5020, !llvm.loop !64

_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5026: ; preds = %call.i.i.i.noexc5028, %if.then.i4997
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc5030 unwind label %lpad1168

.noexc5030:                                       ; preds = %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5026
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc5031 unwind label %lpad1168

.noexc5031:                                       ; preds = %.noexc5030
  store i32 0, ptr %m_size.i.i.i2069, align 4
  br label %if.end.i5006

if.end.i5006:                                     ; preds = %for.body.i.i5020, %.noexc5031, %if.then.split.i5003
  %retval.0.i25.i5007 = phi ptr [ null, %.noexc5031 ], [ %call.i.i.i5029, %if.then.split.i5003 ], [ %call.i.i.i5029, %for.body.i.i5020 ]
  %_Count.addr.0.i5008 = phi i32 [ 0, %.noexc5031 ], [ %cond.i.i.i2091, %if.then.split.i5003 ], [ %cond.i.i.i2091, %for.body.i.i5020 ]
  %m_data.i20.i5009 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1164, i64 0, i32 5, i32 5
  %847 = load ptr, ptr %m_data.i20.i5009, align 8
  %tobool.not.i21.i5010 = icmp eq ptr %847, null
  br i1 %tobool.not.i21.i5010, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5015, label %if.then.i22.i5011

if.then.i22.i5011:                                ; preds = %if.end.i5006
  %m_ownsMemory.i.i5012 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1164, i64 0, i32 5, i32 6
  %848 = load i8, ptr %m_ownsMemory.i.i5012, align 8
  %849 = and i8 %848, 1
  %tobool2.not.i.i5013 = icmp eq i8 %849, 0
  br i1 %tobool2.not.i.i5013, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5015, label %if.then3.i.i5014

if.then3.i.i5014:                                 ; preds = %if.then.i22.i5011
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %847)
          to label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5015 unwind label %lpad1168

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5015: ; preds = %if.then3.i.i5014, %if.then.i22.i5011, %if.end.i5006
  %m_ownsMemory.i5016 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1164, i64 0, i32 5, i32 6
  store i8 1, ptr %m_ownsMemory.i5016, align 8
  store ptr %retval.0.i25.i5007, ptr %m_data.i20.i5009, align 8
  store i32 %_Count.addr.0.i5008, ptr %m_capacity.i.i.i2070, align 8
  %.pre.i.i2092.pre = load i32, ptr %m_size.i.i.i2069, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2072

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2072: ; preds = %if.then.i.i2087, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5015, %if.then.i2067
  %850 = phi i32 [ %843, %if.then.i2067 ], [ %.pre.i.i2092.pre, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5015 ], [ %843, %if.then.i.i2087 ]
  %m_data.i.i2073 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1164, i64 0, i32 5, i32 5
  %851 = load ptr, ptr %m_data.i.i2073, align 8
  %idxprom.i.i2074 = sext i32 %850 to i64
  %arrayidx.i.i2075 = getelementptr inbounds %struct.b3KernelArgData, ptr %851, i64 %idxprom.i.i2074
  store i32 0, ptr %arrayidx.i.i2075, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i2076 = getelementptr inbounds i8, ptr %arrayidx.i.i2075, i64 4
  store i32 %841, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i2076, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i2077 = getelementptr inbounds i8, ptr %arrayidx.i.i2075, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i2077, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i2078 = getelementptr inbounds i8, ptr %arrayidx.i.i2075, i64 16
  store i32 %842, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i2078, align 16
  %852 = load i32, ptr %m_size.i.i.i2069, align 4
  %inc.i.i2079 = add nsw i32 %852, 1
  store i32 %inc.i.i2079, ptr %m_size.i.i.i2069, align 4
  %m_serializationSizeInBytes.i2080 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1164, i64 0, i32 6
  %853 = load i32, ptr %m_serializationSizeInBytes.i2080, align 8
  %add.i2081 = add i32 %853, 32
  store i32 %add.i2081, ptr %m_serializationSizeInBytes.i2080, align 8
  br label %if.end.i2082

if.end.i2082:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2072, %invoke.cont1170
  %854 = load ptr, ptr @__clewSetKernelArg, align 8
  %855 = load ptr, ptr %m_kernel.i2052, align 8
  %856 = load i32, ptr %m_idx3.i2053, align 8
  %inc.i2085 = add nsw i32 %856, 1
  store i32 %inc.i2085, ptr %m_idx3.i2053, align 8
  %call.i20862094 = invoke i32 %854(ptr noundef %855, i32 noundef %856, i64 noundef 4, ptr noundef nonnull %maxContactCapacity.addr)
          to label %invoke.cont1171 unwind label %lpad1168

invoke.cont1171:                                  ; preds = %if.end.i2082
  %857 = load i32, ptr %numCompoundPairs, align 4
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %gRange.i.i2096)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %lRange.i.i2097)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %gRange.i.i2096, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %lRange.i.i2097, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  store i64 64, ptr %lRange.i.i2097, align 16
  %arrayidx3.i.i2098 = getelementptr inbounds [3 x i64], ptr %lRange.i.i2097, i64 0, i64 1
  store i64 1, ptr %arrayidx3.i.i2098, align 8
  %conv5.i.i2099 = sext i32 %857 to i64
  %div.i.i21006123 = lshr i64 %conv5.i.i2099, 6
  %rem.i.i2101 = and i64 %conv5.i.i2099, 63
  %tobool.not.i.i2102 = icmp ne i64 %rem.i.i2101, 0
  %conv9.i.i2103 = zext i1 %tobool.not.i.i2102 to i64
  %add.i.i2104 = add nuw nsw i64 %div.i.i21006123, %conv9.i.i2103
  %.sroa.speculated8.i.i2105 = call i64 @llvm.umax.i64(i64 %add.i.i2104, i64 1)
  %mul.i.i2106 = shl i64 %.sroa.speculated8.i.i2105, 6
  store i64 %mul.i.i2106, ptr %gRange.i.i2096, align 16
  %arrayidx27.i.i2107 = getelementptr inbounds [3 x i64], ptr %gRange.i.i2096, i64 0, i64 1
  store i64 1, ptr %arrayidx27.i.i2107, align 8
  %858 = load ptr, ptr @__clewEnqueueNDRangeKernel, align 8
  %m_commandQueue.i.i2108 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1164, i64 0, i32 1
  %859 = load ptr, ptr %m_commandQueue.i.i2108, align 8
  %860 = load ptr, ptr %m_kernel.i2052, align 8
  %call32.i.i2114 = invoke i32 %858(ptr noundef %859, ptr noundef %860, i32 noundef 2, ptr noundef null, ptr noundef nonnull %gRange.i.i2096, ptr noundef nonnull %lRange.i.i2097, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call32.i.i.noexc2113 unwind label %lpad1168

call32.i.i.noexc2113:                             ; preds = %invoke.cont1171
  %cmp.not.i.i2110 = icmp eq i32 %call32.i.i2114, 0
  br i1 %cmp.not.i.i2110, label %invoke.cont1173, label %if.then.i.i2111

if.then.i.i2111:                                  ; preds = %call32.i.i.noexc2113
  %call33.i.i2112 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.74, i32 noundef %call32.i.i2114)
  br label %invoke.cont1173

invoke.cont1173:                                  ; preds = %if.then.i.i2111, %call32.i.i.noexc2113
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %gRange.i.i2096)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %lRange.i.i2097)
  %861 = load ptr, ptr @__clewFinish, align 8
  %862 = load ptr, ptr %m_queue, align 8
  %call1176 = invoke i32 %861(ptr noundef %862)
          to label %invoke.cont1175 unwind label %lpad1168

invoke.cont1175:                                  ; preds = %invoke.cont1173
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %elem.i2116)
  %863 = load i64, ptr %m_capacity.i.i.i584, align 8
  %cmp.not.i.i2118 = icmp eq i64 %863, 0
  br i1 %cmp.not.i.i2118, label %do.body.i.i2123, label %if.then.i.i2119

if.then.i.i2119:                                  ; preds = %invoke.cont1175
  %864 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %865 = load ptr, ptr %m_commandQueue.i, align 8
  %866 = load ptr, ptr %m_clBuffer.i, align 8
  %call3.i.i2125 = invoke i32 %864(ptr noundef %865, ptr noundef %866, i32 noundef 0, i64 noundef 0, i64 noundef 4, ptr noundef nonnull %elem.i2116, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call3.i.i.noexc2124 unwind label %lpad1168

call3.i.i.noexc2124:                              ; preds = %if.then.i.i2119
  %867 = load ptr, ptr @__clewFinish, align 8
  %868 = load ptr, ptr %m_commandQueue.i, align 8
  %call6.i.i2127 = invoke i32 %867(ptr noundef %868)
          to label %invoke.cont1178 unwind label %lpad1168

do.body.i.i2123:                                  ; preds = %invoke.cont1175
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 285)
          to label %.noexc2128 unwind label %lpad1168

.noexc2128:                                       ; preds = %do.body.i.i2123
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.80)
          to label %invoke.cont1178.thread unwind label %lpad1168

invoke.cont1178.thread:                           ; preds = %.noexc2128
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %elem.i2116)
  br label %if.end1187

invoke.cont1178:                                  ; preds = %call3.i.i.noexc2124
  %.pre.i2122 = load i32, ptr %elem.i2116, align 4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %elem.i2116)
  store i32 %.pre.i2122, ptr %nContacts, align 4
  %869 = load i32, ptr %maxContactCapacity.addr, align 4
  %cmp1180 = icmp sgt i32 %.pre.i2122, %869
  br i1 %cmp1180, label %do.body1182, label %if.end1187

do.body1182:                                      ; preds = %invoke.cont1178
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.31, i32 noundef 3445)
          to label %invoke.cont1183 unwind label %lpad1168

invoke.cont1183:                                  ; preds = %do.body1182
  %870 = load i32, ptr %nContacts, align 4
  %871 = load i32, ptr %maxContactCapacity.addr, align 4
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.41, i32 noundef %870, i32 noundef %871)
          to label %do.end1186 unwind label %lpad1168

do.end1186:                                       ; preds = %invoke.cont1183
  %872 = load i32, ptr %maxContactCapacity.addr, align 4
  store i32 %872, ptr %nContacts, align 4
  br label %if.end1187

lpad1115:                                         ; preds = %invoke.cont1111
  %873 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup1189

lpad1168:                                         ; preds = %if.then3.i.i5014, %.noexc5030, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5026, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4999, %if.then3.i.i4974, %.noexc4990, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i4986, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i4959, %.noexc2128, %do.body.i.i2123, %call3.i.i.noexc2124, %if.then.i.i2119, %invoke.cont1171, %if.end.i2082, %if.end.i2051, %invoke.cont1183, %do.body1182, %invoke.cont1173, %invoke.cont1166
  %874 = landingpad { ptr, i32 }
          cleanup
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1164) #26
  br label %ehcleanup1189

if.end1187:                                       ; preds = %invoke.cont1178.thread, %do.end1186, %invoke.cont1178
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1164) #26
  invoke void @b3LeaveProfileZone()
          to label %if.end1190 unwind label %terminate.lpad.i2131

terminate.lpad.i2131:                             ; preds = %if.end1187
  %875 = landingpad { ptr, i32 }
          catch ptr null
  %876 = extractvalue { ptr, i32 } %875, 0
  call void @__clang_call_terminate(ptr %876) #27
  unreachable

ehcleanup1189:                                    ; preds = %lpad1168, %lpad1115
  %.pn470 = phi { ptr, i32 } [ %874, %lpad1168 ], [ %873, %lpad1115 ]
  invoke void @b3LeaveProfileZone()
          to label %ehcleanup2980 unwind label %terminate.lpad.i2133

terminate.lpad.i2133:                             ; preds = %ehcleanup1189
  %877 = landingpad { ptr, i32 }
          catch ptr null
  %878 = extractvalue { ptr, i32 } %877, 0
  call void @__clang_call_terminate(ptr %878) #27
  unreachable

if.end1190:                                       ; preds = %if.end1187
  %.pre6188 = load i32, ptr %numCompoundPairs, align 4
  %tobool1191.not = icmp eq i32 %.pre6188, 0
  br i1 %tobool1191.not, label %if.end1262, label %if.then1192

if.then1192:                                      ; preds = %if.end1190
  invoke void @b3EnterProfileZone(ptr noundef nonnull @.str.16)
          to label %invoke.cont1194 unwind label %lpad58

invoke.cont1194:                                  ; preds = %if.then1192
  %879 = load ptr, ptr %m_clBuffer.i1870, align 8
  store ptr %879, ptr %bInfo1195, align 16
  %m_isReadOnly.i2138 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1195, i64 0, i32 1
  store i8 1, ptr %m_isReadOnly.i2138, align 8
  %arrayinit.element1202 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1195, i64 1
  %880 = load ptr, ptr %m_clBuffer.i531, align 8
  store ptr %880, ptr %arrayinit.element1202, align 16
  %m_isReadOnly.i2140 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1195, i64 1, i32 1
  store i8 1, ptr %m_isReadOnly.i2140, align 8
  %arrayinit.element1206 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1195, i64 2
  %881 = load ptr, ptr %m_clBuffer.i533, align 8
  store ptr %881, ptr %arrayinit.element1206, align 16
  %m_isReadOnly.i2142 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1195, i64 2, i32 1
  store i8 1, ptr %m_isReadOnly.i2142, align 8
  %arrayinit.element1210 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1195, i64 3
  %882 = load ptr, ptr %m_clBuffer.i535, align 8
  store ptr %882, ptr %arrayinit.element1210, align 16
  %m_isReadOnly.i2144 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1195, i64 3, i32 1
  store i8 1, ptr %m_isReadOnly.i2144, align 8
  %arrayinit.element1214 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1195, i64 4
  %883 = load ptr, ptr %m_clBuffer.i537, align 8
  store ptr %883, ptr %arrayinit.element1214, align 16
  %m_isReadOnly.i2146 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1195, i64 4, i32 1
  store i8 1, ptr %m_isReadOnly.i2146, align 8
  %arrayinit.element1218 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1195, i64 5
  %884 = load ptr, ptr %m_clBuffer.i539, align 8
  store ptr %884, ptr %arrayinit.element1218, align 16
  %m_isReadOnly.i2148 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1195, i64 5, i32 1
  store i8 1, ptr %m_isReadOnly.i2148, align 8
  %arrayinit.element1222 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1195, i64 6
  %885 = load ptr, ptr %m_clBuffer.i541, align 8
  store ptr %885, ptr %arrayinit.element1222, align 16
  %m_isReadOnly.i2150 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1195, i64 6, i32 1
  store i8 1, ptr %m_isReadOnly.i2150, align 8
  %arrayinit.element1226 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1195, i64 7
  %886 = load ptr, ptr %m_clBuffer.i543, align 8
  store ptr %886, ptr %arrayinit.element1226, align 16
  %m_isReadOnly.i2152 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1195, i64 7, i32 1
  store i8 1, ptr %m_isReadOnly.i2152, align 8
  %arrayinit.element1230 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1195, i64 8
  %m_clBuffer.i2153 = getelementptr inbounds %class.b3OpenCLArray.90, ptr %clAabbsWorldSpace, i64 0, i32 3
  %887 = load ptr, ptr %m_clBuffer.i2153, align 8
  store ptr %887, ptr %arrayinit.element1230, align 16
  %m_isReadOnly.i2154 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1195, i64 8, i32 1
  store i8 1, ptr %m_isReadOnly.i2154, align 8
  %arrayinit.element1234 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1195, i64 9
  %888 = load ptr, ptr %m_clBuffer.i1868, align 8
  store ptr %888, ptr %arrayinit.element1234, align 16
  %m_isReadOnly.i2156 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1195, i64 9, i32 1
  store i8 1, ptr %m_isReadOnly.i2156, align 8
  %arrayinit.element1238 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1195, i64 10
  %m_clBuffer.i2157 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 33, i32 3
  %889 = load ptr, ptr %m_clBuffer.i2157, align 8
  store ptr %889, ptr %arrayinit.element1238, align 16
  %m_isReadOnly.i2158 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1195, i64 10, i32 1
  store i8 0, ptr %m_isReadOnly.i2158, align 8
  %arrayinit.element1243 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1195, i64 11
  %m_clBuffer.i2159 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 34, i32 3
  %890 = load ptr, ptr %m_clBuffer.i2159, align 8
  store ptr %890, ptr %arrayinit.element1243, align 16
  %m_isReadOnly.i2160 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1195, i64 11, i32 1
  store i8 0, ptr %m_isReadOnly.i2160, align 8
  %891 = load ptr, ptr %m_queue, align 8
  %m_processCompoundPairsKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 13
  %892 = load ptr, ptr %m_processCompoundPairsKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher1248, ptr noundef %891, ptr noundef %892, ptr noundef nonnull @.str.51)
          to label %invoke.cont1250 unwind label %lpad1198

invoke.cont1250:                                  ; preds = %invoke.cont1194
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher1248, ptr noundef nonnull %bInfo1195, i32 noundef 12)
          to label %invoke.cont1253 unwind label %lpad1252

invoke.cont1253:                                  ; preds = %invoke.cont1250
  %m_enableSerialization.i2161 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1248, i64 0, i32 7
  %893 = load i8, ptr %m_enableSerialization.i2161, align 4
  %894 = and i8 %893, 1
  %tobool.not.i2162 = icmp eq i8 %894, 0
  br i1 %tobool.not.i2162, label %if.end.i2178, label %if.then.i2163

if.then.i2163:                                    ; preds = %invoke.cont1253
  %m_idx.i2164 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1248, i64 0, i32 3
  %895 = load i32, ptr %m_idx.i2164, align 8
  %896 = load i32, ptr %numCompoundPairs, align 4
  %m_size.i.i.i2165 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1248, i64 0, i32 5, i32 2
  %897 = load i32, ptr %m_size.i.i.i2165, align 4
  %m_capacity.i.i.i2166 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1248, i64 0, i32 5, i32 3
  %898 = load i32, ptr %m_capacity.i.i.i2166, align 8
  %cmp.i.i2167 = icmp eq i32 %897, %898
  br i1 %cmp.i.i2167, label %if.then.i.i2183, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2168

if.then.i.i2183:                                  ; preds = %if.then.i2163
  %tobool.not.i.i.i2185 = icmp eq i32 %897, 0
  %mul.i.i.i2186 = shl nsw i32 %897, 1
  %cond.i.i.i2187 = select i1 %tobool.not.i.i.i2185, i32 1, i32 %mul.i.i.i2186
  %cmp.i5035 = icmp slt i32 %897, %cond.i.i.i2187
  br i1 %cmp.i5035, label %if.then.i5037, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2168

if.then.i5037:                                    ; preds = %if.then.i.i2183
  %tobool.not.i.i5038 = icmp eq i32 %cond.i.i.i2187, 0
  br i1 %tobool.not.i.i5038, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5066, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5039

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5039: ; preds = %if.then.i5037
  %conv.i.i.i5040 = sext i32 %cond.i.i.i2187 to i64
  %mul.i.i.i5041 = shl nsw i64 %conv.i.i.i5040, 5
  %call.i.i.i5069 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i5041, i32 noundef 16)
          to label %call.i.i.i.noexc5068 unwind label %lpad1252

call.i.i.i.noexc5068:                             ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5039
  %cmp3.i5042 = icmp eq ptr %call.i.i.i5069, null
  br i1 %cmp3.i5042, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5066, label %if.then.split.i5043

if.then.split.i5043:                              ; preds = %call.i.i.i.noexc5068
  %899 = load i32, ptr %m_size.i.i.i2165, align 4
  %cmp4.i.i5045 = icmp sgt i32 %899, 0
  br i1 %cmp4.i.i5045, label %for.body.lr.ph.i.i5057, label %if.end.i5046

for.body.lr.ph.i.i5057:                           ; preds = %if.then.split.i5043
  %m_data.i.i5058 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1248, i64 0, i32 5, i32 5
  %wide.trip.count.i.i5059 = zext nneg i32 %899 to i64
  br label %for.body.i.i5060

for.body.i.i5060:                                 ; preds = %for.body.i.i5060, %for.body.lr.ph.i.i5057
  %indvars.iv.i.i5061 = phi i64 [ 0, %for.body.lr.ph.i.i5057 ], [ %indvars.iv.next.i.i5064, %for.body.i.i5060 ]
  %arrayidx.i.i5062 = getelementptr inbounds %struct.b3KernelArgData, ptr %call.i.i.i5069, i64 %indvars.iv.i.i5061
  %900 = load ptr, ptr %m_data.i.i5058, align 8
  %arrayidx3.i.i5063 = getelementptr inbounds %struct.b3KernelArgData, ptr %900, i64 %indvars.iv.i.i5061
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i.i5062, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i.i5063, i64 32, i1 false)
  %indvars.iv.next.i.i5064 = add nuw nsw i64 %indvars.iv.i.i5061, 1
  %exitcond.not.i.i5065 = icmp eq i64 %indvars.iv.next.i.i5064, %wide.trip.count.i.i5059
  br i1 %exitcond.not.i.i5065, label %if.end.i5046, label %for.body.i.i5060, !llvm.loop !64

_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5066: ; preds = %call.i.i.i.noexc5068, %if.then.i5037
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc5070 unwind label %lpad1252

.noexc5070:                                       ; preds = %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5066
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc5071 unwind label %lpad1252

.noexc5071:                                       ; preds = %.noexc5070
  store i32 0, ptr %m_size.i.i.i2165, align 4
  br label %if.end.i5046

if.end.i5046:                                     ; preds = %for.body.i.i5060, %.noexc5071, %if.then.split.i5043
  %retval.0.i25.i5047 = phi ptr [ null, %.noexc5071 ], [ %call.i.i.i5069, %if.then.split.i5043 ], [ %call.i.i.i5069, %for.body.i.i5060 ]
  %_Count.addr.0.i5048 = phi i32 [ 0, %.noexc5071 ], [ %cond.i.i.i2187, %if.then.split.i5043 ], [ %cond.i.i.i2187, %for.body.i.i5060 ]
  %m_data.i20.i5049 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1248, i64 0, i32 5, i32 5
  %901 = load ptr, ptr %m_data.i20.i5049, align 8
  %tobool.not.i21.i5050 = icmp eq ptr %901, null
  br i1 %tobool.not.i21.i5050, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5055, label %if.then.i22.i5051

if.then.i22.i5051:                                ; preds = %if.end.i5046
  %m_ownsMemory.i.i5052 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1248, i64 0, i32 5, i32 6
  %902 = load i8, ptr %m_ownsMemory.i.i5052, align 8
  %903 = and i8 %902, 1
  %tobool2.not.i.i5053 = icmp eq i8 %903, 0
  br i1 %tobool2.not.i.i5053, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5055, label %if.then3.i.i5054

if.then3.i.i5054:                                 ; preds = %if.then.i22.i5051
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %901)
          to label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5055 unwind label %lpad1252

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5055: ; preds = %if.then3.i.i5054, %if.then.i22.i5051, %if.end.i5046
  %m_ownsMemory.i5056 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1248, i64 0, i32 5, i32 6
  store i8 1, ptr %m_ownsMemory.i5056, align 8
  store ptr %retval.0.i25.i5047, ptr %m_data.i20.i5049, align 8
  store i32 %_Count.addr.0.i5048, ptr %m_capacity.i.i.i2166, align 8
  %.pre.i.i2188.pre = load i32, ptr %m_size.i.i.i2165, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2168

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2168: ; preds = %if.then.i.i2183, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5055, %if.then.i2163
  %904 = phi i32 [ %897, %if.then.i2163 ], [ %.pre.i.i2188.pre, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5055 ], [ %897, %if.then.i.i2183 ]
  %m_data.i.i2169 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1248, i64 0, i32 5, i32 5
  %905 = load ptr, ptr %m_data.i.i2169, align 8
  %idxprom.i.i2170 = sext i32 %904 to i64
  %arrayidx.i.i2171 = getelementptr inbounds %struct.b3KernelArgData, ptr %905, i64 %idxprom.i.i2170
  store i32 0, ptr %arrayidx.i.i2171, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i2172 = getelementptr inbounds i8, ptr %arrayidx.i.i2171, i64 4
  store i32 %895, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i2172, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i2173 = getelementptr inbounds i8, ptr %arrayidx.i.i2171, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i2173, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i2174 = getelementptr inbounds i8, ptr %arrayidx.i.i2171, i64 16
  store i32 %896, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i2174, align 16
  %906 = load i32, ptr %m_size.i.i.i2165, align 4
  %inc.i.i2175 = add nsw i32 %906, 1
  store i32 %inc.i.i2175, ptr %m_size.i.i.i2165, align 4
  %m_serializationSizeInBytes.i2176 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1248, i64 0, i32 6
  %907 = load i32, ptr %m_serializationSizeInBytes.i2176, align 8
  %add.i2177 = add i32 %907, 32
  store i32 %add.i2177, ptr %m_serializationSizeInBytes.i2176, align 8
  br label %if.end.i2178

if.end.i2178:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2168, %invoke.cont1253
  %908 = load ptr, ptr @__clewSetKernelArg, align 8
  %m_kernel.i2179 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1248, i64 0, i32 2
  %909 = load ptr, ptr %m_kernel.i2179, align 8
  %m_idx3.i2180 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1248, i64 0, i32 3
  %910 = load i32, ptr %m_idx3.i2180, align 8
  %inc.i2181 = add nsw i32 %910, 1
  store i32 %inc.i2181, ptr %m_idx3.i2180, align 8
  %call.i21822190 = invoke i32 %908(ptr noundef %909, i32 noundef %910, i64 noundef 4, ptr noundef nonnull %numCompoundPairs)
          to label %invoke.cont1254 unwind label %lpad1252

invoke.cont1254:                                  ; preds = %if.end.i2178
  %911 = load i32, ptr %numCompoundPairs, align 4
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %gRange.i.i2192)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %lRange.i.i2193)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %gRange.i.i2192, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %lRange.i.i2193, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  store i64 64, ptr %lRange.i.i2193, align 16
  %arrayidx3.i.i2194 = getelementptr inbounds [3 x i64], ptr %lRange.i.i2193, i64 0, i64 1
  store i64 1, ptr %arrayidx3.i.i2194, align 8
  %conv5.i.i2195 = sext i32 %911 to i64
  %div.i.i21966124 = lshr i64 %conv5.i.i2195, 6
  %rem.i.i2197 = and i64 %conv5.i.i2195, 63
  %tobool.not.i.i2198 = icmp ne i64 %rem.i.i2197, 0
  %conv9.i.i2199 = zext i1 %tobool.not.i.i2198 to i64
  %add.i.i2200 = add nuw nsw i64 %div.i.i21966124, %conv9.i.i2199
  %.sroa.speculated8.i.i2201 = call i64 @llvm.umax.i64(i64 %add.i.i2200, i64 1)
  %mul.i.i2202 = shl i64 %.sroa.speculated8.i.i2201, 6
  store i64 %mul.i.i2202, ptr %gRange.i.i2192, align 16
  %arrayidx27.i.i2203 = getelementptr inbounds [3 x i64], ptr %gRange.i.i2192, i64 0, i64 1
  store i64 1, ptr %arrayidx27.i.i2203, align 8
  %912 = load ptr, ptr @__clewEnqueueNDRangeKernel, align 8
  %m_commandQueue.i.i2204 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1248, i64 0, i32 1
  %913 = load ptr, ptr %m_commandQueue.i.i2204, align 8
  %914 = load ptr, ptr %m_kernel.i2179, align 8
  %call32.i.i2210 = invoke i32 %912(ptr noundef %913, ptr noundef %914, i32 noundef 2, ptr noundef null, ptr noundef nonnull %gRange.i.i2192, ptr noundef nonnull %lRange.i.i2193, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call32.i.i.noexc2209 unwind label %lpad1252

call32.i.i.noexc2209:                             ; preds = %invoke.cont1254
  %cmp.not.i.i2206 = icmp eq i32 %call32.i.i2210, 0
  br i1 %cmp.not.i.i2206, label %invoke.cont1256, label %if.then.i.i2207

if.then.i.i2207:                                  ; preds = %call32.i.i.noexc2209
  %call33.i.i2208 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.74, i32 noundef %call32.i.i2210)
  br label %invoke.cont1256

invoke.cont1256:                                  ; preds = %if.then.i.i2207, %call32.i.i.noexc2209
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %gRange.i.i2192)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %lRange.i.i2193)
  %915 = load ptr, ptr @__clewFinish, align 8
  %916 = load ptr, ptr %m_queue, align 8
  %call1259 = invoke i32 %915(ptr noundef %916)
          to label %invoke.cont1258 unwind label %lpad1252

invoke.cont1258:                                  ; preds = %invoke.cont1256
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1248) #26
  invoke void @b3LeaveProfileZone()
          to label %if.end1262 unwind label %terminate.lpad.i2212

terminate.lpad.i2212:                             ; preds = %invoke.cont1258
  %917 = landingpad { ptr, i32 }
          catch ptr null
  %918 = extractvalue { ptr, i32 } %917, 0
  call void @__clang_call_terminate(ptr %918) #27
  unreachable

lpad1198:                                         ; preds = %invoke.cont1194
  %919 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup1261

lpad1252:                                         ; preds = %if.then3.i.i5054, %.noexc5070, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5066, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5039, %invoke.cont1254, %if.end.i2178, %invoke.cont1256, %invoke.cont1250
  %920 = landingpad { ptr, i32 }
          cleanup
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1248) #26
  br label %ehcleanup1261

ehcleanup1261:                                    ; preds = %lpad1252, %lpad1198
  %.pn472 = phi { ptr, i32 } [ %920, %lpad1252 ], [ %919, %lpad1198 ]
  invoke void @b3LeaveProfileZone()
          to label %ehcleanup2980 unwind label %terminate.lpad.i2214

terminate.lpad.i2214:                             ; preds = %ehcleanup1261
  %921 = landingpad { ptr, i32 }
          catch ptr null
  %922 = extractvalue { ptr, i32 } %921, 0
  call void @__clang_call_terminate(ptr %922) #27
  unreachable

if.end1262:                                       ; preds = %invoke.cont1106, %invoke.cont1258, %if.end1190
  store i32 64, ptr %vertexFaceCapacity, align 4
  %m_size.i = getelementptr inbounds %class.b3OpenCLArray.100, ptr %treeNodesGPU, i64 0, i32 1
  %923 = load i64, ptr %m_size.i, align 8
  %tobool1265.not = icmp eq i64 %923, 0
  br i1 %tobool1265.not, label %if.end1853, label %if.then1270

if.then1270:                                      ; preds = %if.end1262
  %924 = load i8, ptr @bvhTraversalKernelGPU, align 1
  %925 = and i8 %924, 1
  %tobool1271.not = icmp eq i8 %925, 0
  br i1 %tobool1271.not, label %invoke.cont1325, label %if.then1272

if.then1272:                                      ; preds = %if.then1270
  invoke void @b3EnterProfileZone(ptr noundef nonnull @.str.52)
          to label %invoke.cont1274 unwind label %lpad58

invoke.cont1274:                                  ; preds = %if.then1272
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %elem.i2219)
  %926 = load i64, ptr %m_capacity.i.i, align 8
  %cmp.not.i.i2221 = icmp eq i64 %926, 0
  br i1 %cmp.not.i.i2221, label %do.body.i.i2226, label %if.then.i.i2222

if.then.i.i2222:                                  ; preds = %invoke.cont1274
  %927 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %928 = load ptr, ptr %m_commandQueue.i.i635, align 8
  %929 = load ptr, ptr %m_clBuffer.i.i636, align 8
  %call3.i.i2228 = invoke i32 %927(ptr noundef %928, ptr noundef %929, i32 noundef 0, i64 noundef 0, i64 noundef 4, ptr noundef nonnull %elem.i2219, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call3.i.i.noexc2227 unwind label %lpad1276

call3.i.i.noexc2227:                              ; preds = %if.then.i.i2222
  %930 = load ptr, ptr @__clewFinish, align 8
  %931 = load ptr, ptr %m_commandQueue.i.i635, align 8
  %call6.i.i2230 = invoke i32 %930(ptr noundef %931)
          to label %call6.i.i.noexc2229 unwind label %lpad1276

call6.i.i.noexc2229:                              ; preds = %call3.i.i.noexc2227
  %.pre.i2225 = load i32, ptr %elem.i2219, align 4
  br label %invoke.cont1277

do.body.i.i2226:                                  ; preds = %invoke.cont1274
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 285)
          to label %.noexc2231 unwind label %lpad1276

.noexc2231:                                       ; preds = %do.body.i.i2226
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.80)
          to label %invoke.cont1277 unwind label %lpad1276

invoke.cont1277:                                  ; preds = %call6.i.i.noexc2229, %.noexc2231
  %932 = phi i32 [ %.pre.i2225, %call6.i.i.noexc2229 ], [ undef, %.noexc2231 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %elem.i2219)
  store i32 %932, ptr %numConcavePairs, align 4
  %933 = load ptr, ptr %m_queue, align 8
  %m_bvhTraversalKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 20
  %934 = load ptr, ptr %m_bvhTraversalKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279, ptr noundef %933, ptr noundef %934, ptr noundef nonnull @.str.52)
          to label %invoke.cont1281 unwind label %lpad1276

invoke.cont1281:                                  ; preds = %invoke.cont1277
  %935 = load ptr, ptr %m_clBuffer.i530, align 8
  invoke void @_ZN12b3LauncherCL9setBufferEP7_cl_mem(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279, ptr noundef %935)
          to label %invoke.cont1285 unwind label %lpad1282

invoke.cont1285:                                  ; preds = %invoke.cont1281
  %936 = load ptr, ptr %m_clBuffer.i531, align 8
  invoke void @_ZN12b3LauncherCL9setBufferEP7_cl_mem(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279, ptr noundef %936)
          to label %invoke.cont1288 unwind label %lpad1282

invoke.cont1288:                                  ; preds = %invoke.cont1285
  %937 = load ptr, ptr %m_clBuffer.i533, align 8
  invoke void @_ZN12b3LauncherCL9setBufferEP7_cl_mem(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279, ptr noundef %937)
          to label %invoke.cont1291 unwind label %lpad1282

invoke.cont1291:                                  ; preds = %invoke.cont1288
  %m_clBuffer.i2237 = getelementptr inbounds %class.b3OpenCLArray.90, ptr %clAabbsWorldSpace, i64 0, i32 3
  %938 = load ptr, ptr %m_clBuffer.i2237, align 8
  invoke void @_ZN12b3LauncherCL9setBufferEP7_cl_mem(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279, ptr noundef %938)
          to label %invoke.cont1294 unwind label %lpad1282

invoke.cont1294:                                  ; preds = %invoke.cont1291
  %m_clBuffer.i2238 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %triangleConvexPairsOut, i64 0, i32 3
  %939 = load ptr, ptr %m_clBuffer.i2238, align 8
  invoke void @_ZN12b3LauncherCL9setBufferEP7_cl_mem(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279, ptr noundef %939)
          to label %invoke.cont1297 unwind label %lpad1282

invoke.cont1297:                                  ; preds = %invoke.cont1294
  %940 = load ptr, ptr %m_clBuffer.i.i636, align 8
  invoke void @_ZN12b3LauncherCL9setBufferEP7_cl_mem(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279, ptr noundef %940)
          to label %invoke.cont1301 unwind label %lpad1282

invoke.cont1301:                                  ; preds = %invoke.cont1297
  %941 = load ptr, ptr %m_clBuffer.i1874, align 8
  invoke void @_ZN12b3LauncherCL9setBufferEP7_cl_mem(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279, ptr noundef %941)
          to label %invoke.cont1304 unwind label %lpad1282

invoke.cont1304:                                  ; preds = %invoke.cont1301
  %942 = load ptr, ptr %m_clBuffer.i1876, align 8
  invoke void @_ZN12b3LauncherCL9setBufferEP7_cl_mem(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279, ptr noundef %942)
          to label %invoke.cont1307 unwind label %lpad1282

invoke.cont1307:                                  ; preds = %invoke.cont1304
  %943 = load ptr, ptr %m_clBuffer.i1878, align 8
  invoke void @_ZN12b3LauncherCL9setBufferEP7_cl_mem(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279, ptr noundef %943)
          to label %invoke.cont1310 unwind label %lpad1282

invoke.cont1310:                                  ; preds = %invoke.cont1307
  %m_enableSerialization.i2243 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1279, i64 0, i32 7
  %944 = load i8, ptr %m_enableSerialization.i2243, align 4
  %945 = and i8 %944, 1
  %tobool.not.i2244 = icmp eq i8 %945, 0
  br i1 %tobool.not.i2244, label %if.end.i2260, label %if.then.i2245

if.then.i2245:                                    ; preds = %invoke.cont1310
  %m_idx.i2246 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1279, i64 0, i32 3
  %946 = load i32, ptr %m_idx.i2246, align 8
  %947 = load i32, ptr %nPairs.addr, align 4
  %m_size.i.i.i2247 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1279, i64 0, i32 5, i32 2
  %948 = load i32, ptr %m_size.i.i.i2247, align 4
  %m_capacity.i.i.i2248 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1279, i64 0, i32 5, i32 3
  %949 = load i32, ptr %m_capacity.i.i.i2248, align 8
  %cmp.i.i2249 = icmp eq i32 %948, %949
  br i1 %cmp.i.i2249, label %if.then.i.i2265, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2250

if.then.i.i2265:                                  ; preds = %if.then.i2245
  %tobool.not.i.i.i2267 = icmp eq i32 %948, 0
  %mul.i.i.i2268 = shl nsw i32 %948, 1
  %cond.i.i.i2269 = select i1 %tobool.not.i.i.i2267, i32 1, i32 %mul.i.i.i2268
  %cmp.i5075 = icmp slt i32 %948, %cond.i.i.i2269
  br i1 %cmp.i5075, label %if.then.i5077, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2250

if.then.i5077:                                    ; preds = %if.then.i.i2265
  %tobool.not.i.i5078 = icmp eq i32 %cond.i.i.i2269, 0
  br i1 %tobool.not.i.i5078, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5106, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5079

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5079: ; preds = %if.then.i5077
  %conv.i.i.i5080 = sext i32 %cond.i.i.i2269 to i64
  %mul.i.i.i5081 = shl nsw i64 %conv.i.i.i5080, 5
  %call.i.i.i5109 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i5081, i32 noundef 16)
          to label %call.i.i.i.noexc5108 unwind label %lpad1282

call.i.i.i.noexc5108:                             ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5079
  %cmp3.i5082 = icmp eq ptr %call.i.i.i5109, null
  br i1 %cmp3.i5082, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5106, label %if.then.split.i5083

if.then.split.i5083:                              ; preds = %call.i.i.i.noexc5108
  %950 = load i32, ptr %m_size.i.i.i2247, align 4
  %cmp4.i.i5085 = icmp sgt i32 %950, 0
  br i1 %cmp4.i.i5085, label %for.body.lr.ph.i.i5097, label %if.end.i5086

for.body.lr.ph.i.i5097:                           ; preds = %if.then.split.i5083
  %m_data.i.i5098 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1279, i64 0, i32 5, i32 5
  %wide.trip.count.i.i5099 = zext nneg i32 %950 to i64
  br label %for.body.i.i5100

for.body.i.i5100:                                 ; preds = %for.body.i.i5100, %for.body.lr.ph.i.i5097
  %indvars.iv.i.i5101 = phi i64 [ 0, %for.body.lr.ph.i.i5097 ], [ %indvars.iv.next.i.i5104, %for.body.i.i5100 ]
  %arrayidx.i.i5102 = getelementptr inbounds %struct.b3KernelArgData, ptr %call.i.i.i5109, i64 %indvars.iv.i.i5101
  %951 = load ptr, ptr %m_data.i.i5098, align 8
  %arrayidx3.i.i5103 = getelementptr inbounds %struct.b3KernelArgData, ptr %951, i64 %indvars.iv.i.i5101
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i.i5102, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i.i5103, i64 32, i1 false)
  %indvars.iv.next.i.i5104 = add nuw nsw i64 %indvars.iv.i.i5101, 1
  %exitcond.not.i.i5105 = icmp eq i64 %indvars.iv.next.i.i5104, %wide.trip.count.i.i5099
  br i1 %exitcond.not.i.i5105, label %if.end.i5086, label %for.body.i.i5100, !llvm.loop !64

_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5106: ; preds = %call.i.i.i.noexc5108, %if.then.i5077
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc5110 unwind label %lpad1282

.noexc5110:                                       ; preds = %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5106
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc5111 unwind label %lpad1282

.noexc5111:                                       ; preds = %.noexc5110
  store i32 0, ptr %m_size.i.i.i2247, align 4
  br label %if.end.i5086

if.end.i5086:                                     ; preds = %for.body.i.i5100, %.noexc5111, %if.then.split.i5083
  %retval.0.i25.i5087 = phi ptr [ null, %.noexc5111 ], [ %call.i.i.i5109, %if.then.split.i5083 ], [ %call.i.i.i5109, %for.body.i.i5100 ]
  %_Count.addr.0.i5088 = phi i32 [ 0, %.noexc5111 ], [ %cond.i.i.i2269, %if.then.split.i5083 ], [ %cond.i.i.i2269, %for.body.i.i5100 ]
  %m_data.i20.i5089 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1279, i64 0, i32 5, i32 5
  %952 = load ptr, ptr %m_data.i20.i5089, align 8
  %tobool.not.i21.i5090 = icmp eq ptr %952, null
  br i1 %tobool.not.i21.i5090, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5095, label %if.then.i22.i5091

if.then.i22.i5091:                                ; preds = %if.end.i5086
  %m_ownsMemory.i.i5092 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1279, i64 0, i32 5, i32 6
  %953 = load i8, ptr %m_ownsMemory.i.i5092, align 8
  %954 = and i8 %953, 1
  %tobool2.not.i.i5093 = icmp eq i8 %954, 0
  br i1 %tobool2.not.i.i5093, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5095, label %if.then3.i.i5094

if.then3.i.i5094:                                 ; preds = %if.then.i22.i5091
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %952)
          to label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5095 unwind label %lpad1282

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5095: ; preds = %if.then3.i.i5094, %if.then.i22.i5091, %if.end.i5086
  %m_ownsMemory.i5096 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1279, i64 0, i32 5, i32 6
  store i8 1, ptr %m_ownsMemory.i5096, align 8
  store ptr %retval.0.i25.i5087, ptr %m_data.i20.i5089, align 8
  store i32 %_Count.addr.0.i5088, ptr %m_capacity.i.i.i2248, align 8
  %.pre.i.i2270.pre = load i32, ptr %m_size.i.i.i2247, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2250

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2250: ; preds = %if.then.i.i2265, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5095, %if.then.i2245
  %955 = phi i32 [ %948, %if.then.i2245 ], [ %.pre.i.i2270.pre, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5095 ], [ %948, %if.then.i.i2265 ]
  %m_data.i.i2251 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1279, i64 0, i32 5, i32 5
  %956 = load ptr, ptr %m_data.i.i2251, align 8
  %idxprom.i.i2252 = sext i32 %955 to i64
  %arrayidx.i.i2253 = getelementptr inbounds %struct.b3KernelArgData, ptr %956, i64 %idxprom.i.i2252
  store i32 0, ptr %arrayidx.i.i2253, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i2254 = getelementptr inbounds i8, ptr %arrayidx.i.i2253, i64 4
  store i32 %946, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i2254, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i2255 = getelementptr inbounds i8, ptr %arrayidx.i.i2253, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i2255, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i2256 = getelementptr inbounds i8, ptr %arrayidx.i.i2253, i64 16
  store i32 %947, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i2256, align 16
  %957 = load i32, ptr %m_size.i.i.i2247, align 4
  %inc.i.i2257 = add nsw i32 %957, 1
  store i32 %inc.i.i2257, ptr %m_size.i.i.i2247, align 4
  %m_serializationSizeInBytes.i2258 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1279, i64 0, i32 6
  %958 = load i32, ptr %m_serializationSizeInBytes.i2258, align 8
  %add.i2259 = add i32 %958, 32
  store i32 %add.i2259, ptr %m_serializationSizeInBytes.i2258, align 8
  br label %if.end.i2260

if.end.i2260:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2250, %invoke.cont1310
  %959 = load ptr, ptr @__clewSetKernelArg, align 8
  %m_kernel.i2261 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1279, i64 0, i32 2
  %960 = load ptr, ptr %m_kernel.i2261, align 8
  %m_idx3.i2262 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1279, i64 0, i32 3
  %961 = load i32, ptr %m_idx3.i2262, align 8
  %inc.i2263 = add nsw i32 %961, 1
  store i32 %inc.i2263, ptr %m_idx3.i2262, align 8
  %call.i22642272 = invoke i32 %959(ptr noundef %960, i32 noundef %961, i64 noundef 4, ptr noundef nonnull %nPairs.addr)
          to label %invoke.cont1311 unwind label %lpad1282

invoke.cont1311:                                  ; preds = %if.end.i2260
  %962 = load i8, ptr %m_enableSerialization.i2243, align 4
  %963 = and i8 %962, 1
  %tobool.not.i2275 = icmp eq i8 %963, 0
  br i1 %tobool.not.i2275, label %if.end.i2291, label %if.then.i2276

if.then.i2276:                                    ; preds = %invoke.cont1311
  %964 = load i32, ptr %m_idx3.i2262, align 8
  %965 = load i32, ptr %maxTriConvexPairCapacity.addr, align 4
  %m_size.i.i.i2278 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1279, i64 0, i32 5, i32 2
  %966 = load i32, ptr %m_size.i.i.i2278, align 4
  %m_capacity.i.i.i2279 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1279, i64 0, i32 5, i32 3
  %967 = load i32, ptr %m_capacity.i.i.i2279, align 8
  %cmp.i.i2280 = icmp eq i32 %966, %967
  br i1 %cmp.i.i2280, label %if.then.i.i2296, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2281

if.then.i.i2296:                                  ; preds = %if.then.i2276
  %tobool.not.i.i.i2298 = icmp eq i32 %966, 0
  %mul.i.i.i2299 = shl nsw i32 %966, 1
  %cond.i.i.i2300 = select i1 %tobool.not.i.i.i2298, i32 1, i32 %mul.i.i.i2299
  %cmp.i5115 = icmp slt i32 %966, %cond.i.i.i2300
  br i1 %cmp.i5115, label %if.then.i5117, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2281

if.then.i5117:                                    ; preds = %if.then.i.i2296
  %tobool.not.i.i5118 = icmp eq i32 %cond.i.i.i2300, 0
  br i1 %tobool.not.i.i5118, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5146, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5119

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5119: ; preds = %if.then.i5117
  %conv.i.i.i5120 = sext i32 %cond.i.i.i2300 to i64
  %mul.i.i.i5121 = shl nsw i64 %conv.i.i.i5120, 5
  %call.i.i.i5149 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i5121, i32 noundef 16)
          to label %call.i.i.i.noexc5148 unwind label %lpad1282

call.i.i.i.noexc5148:                             ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5119
  %cmp3.i5122 = icmp eq ptr %call.i.i.i5149, null
  br i1 %cmp3.i5122, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5146, label %if.then.split.i5123

if.then.split.i5123:                              ; preds = %call.i.i.i.noexc5148
  %968 = load i32, ptr %m_size.i.i.i2278, align 4
  %cmp4.i.i5125 = icmp sgt i32 %968, 0
  br i1 %cmp4.i.i5125, label %for.body.lr.ph.i.i5137, label %if.end.i5126

for.body.lr.ph.i.i5137:                           ; preds = %if.then.split.i5123
  %m_data.i.i5138 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1279, i64 0, i32 5, i32 5
  %wide.trip.count.i.i5139 = zext nneg i32 %968 to i64
  br label %for.body.i.i5140

for.body.i.i5140:                                 ; preds = %for.body.i.i5140, %for.body.lr.ph.i.i5137
  %indvars.iv.i.i5141 = phi i64 [ 0, %for.body.lr.ph.i.i5137 ], [ %indvars.iv.next.i.i5144, %for.body.i.i5140 ]
  %arrayidx.i.i5142 = getelementptr inbounds %struct.b3KernelArgData, ptr %call.i.i.i5149, i64 %indvars.iv.i.i5141
  %969 = load ptr, ptr %m_data.i.i5138, align 8
  %arrayidx3.i.i5143 = getelementptr inbounds %struct.b3KernelArgData, ptr %969, i64 %indvars.iv.i.i5141
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i.i5142, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i.i5143, i64 32, i1 false)
  %indvars.iv.next.i.i5144 = add nuw nsw i64 %indvars.iv.i.i5141, 1
  %exitcond.not.i.i5145 = icmp eq i64 %indvars.iv.next.i.i5144, %wide.trip.count.i.i5139
  br i1 %exitcond.not.i.i5145, label %if.end.i5126, label %for.body.i.i5140, !llvm.loop !64

_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5146: ; preds = %call.i.i.i.noexc5148, %if.then.i5117
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc5150 unwind label %lpad1282

.noexc5150:                                       ; preds = %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5146
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc5151 unwind label %lpad1282

.noexc5151:                                       ; preds = %.noexc5150
  store i32 0, ptr %m_size.i.i.i2278, align 4
  br label %if.end.i5126

if.end.i5126:                                     ; preds = %for.body.i.i5140, %.noexc5151, %if.then.split.i5123
  %retval.0.i25.i5127 = phi ptr [ null, %.noexc5151 ], [ %call.i.i.i5149, %if.then.split.i5123 ], [ %call.i.i.i5149, %for.body.i.i5140 ]
  %_Count.addr.0.i5128 = phi i32 [ 0, %.noexc5151 ], [ %cond.i.i.i2300, %if.then.split.i5123 ], [ %cond.i.i.i2300, %for.body.i.i5140 ]
  %m_data.i20.i5129 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1279, i64 0, i32 5, i32 5
  %970 = load ptr, ptr %m_data.i20.i5129, align 8
  %tobool.not.i21.i5130 = icmp eq ptr %970, null
  br i1 %tobool.not.i21.i5130, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5135, label %if.then.i22.i5131

if.then.i22.i5131:                                ; preds = %if.end.i5126
  %m_ownsMemory.i.i5132 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1279, i64 0, i32 5, i32 6
  %971 = load i8, ptr %m_ownsMemory.i.i5132, align 8
  %972 = and i8 %971, 1
  %tobool2.not.i.i5133 = icmp eq i8 %972, 0
  br i1 %tobool2.not.i.i5133, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5135, label %if.then3.i.i5134

if.then3.i.i5134:                                 ; preds = %if.then.i22.i5131
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %970)
          to label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5135 unwind label %lpad1282

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5135: ; preds = %if.then3.i.i5134, %if.then.i22.i5131, %if.end.i5126
  %m_ownsMemory.i5136 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1279, i64 0, i32 5, i32 6
  store i8 1, ptr %m_ownsMemory.i5136, align 8
  store ptr %retval.0.i25.i5127, ptr %m_data.i20.i5129, align 8
  store i32 %_Count.addr.0.i5128, ptr %m_capacity.i.i.i2279, align 8
  %.pre.i.i2301.pre = load i32, ptr %m_size.i.i.i2278, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2281

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2281: ; preds = %if.then.i.i2296, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5135, %if.then.i2276
  %973 = phi i32 [ %966, %if.then.i2276 ], [ %.pre.i.i2301.pre, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5135 ], [ %966, %if.then.i.i2296 ]
  %m_data.i.i2282 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1279, i64 0, i32 5, i32 5
  %974 = load ptr, ptr %m_data.i.i2282, align 8
  %idxprom.i.i2283 = sext i32 %973 to i64
  %arrayidx.i.i2284 = getelementptr inbounds %struct.b3KernelArgData, ptr %974, i64 %idxprom.i.i2283
  store i32 0, ptr %arrayidx.i.i2284, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i2285 = getelementptr inbounds i8, ptr %arrayidx.i.i2284, i64 4
  store i32 %964, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i2285, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i2286 = getelementptr inbounds i8, ptr %arrayidx.i.i2284, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i2286, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i2287 = getelementptr inbounds i8, ptr %arrayidx.i.i2284, i64 16
  store i32 %965, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i2287, align 16
  %975 = load i32, ptr %m_size.i.i.i2278, align 4
  %inc.i.i2288 = add nsw i32 %975, 1
  store i32 %inc.i.i2288, ptr %m_size.i.i.i2278, align 4
  %m_serializationSizeInBytes.i2289 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1279, i64 0, i32 6
  %976 = load i32, ptr %m_serializationSizeInBytes.i2289, align 8
  %add.i2290 = add i32 %976, 32
  store i32 %add.i2290, ptr %m_serializationSizeInBytes.i2289, align 8
  br label %if.end.i2291

if.end.i2291:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2281, %invoke.cont1311
  %977 = load ptr, ptr @__clewSetKernelArg, align 8
  %978 = load ptr, ptr %m_kernel.i2261, align 8
  %979 = load i32, ptr %m_idx3.i2262, align 8
  %inc.i2294 = add nsw i32 %979, 1
  store i32 %inc.i2294, ptr %m_idx3.i2262, align 8
  %call.i22952303 = invoke i32 %977(ptr noundef %978, i32 noundef %979, i64 noundef 4, ptr noundef nonnull %maxTriConvexPairCapacity.addr)
          to label %invoke.cont1312 unwind label %lpad1282

invoke.cont1312:                                  ; preds = %if.end.i2291
  %980 = load i32, ptr %nPairs.addr, align 4
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %gRange.i.i2305)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %lRange.i.i2306)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %gRange.i.i2305, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %lRange.i.i2306, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  store i64 64, ptr %lRange.i.i2306, align 16
  %arrayidx3.i.i2307 = getelementptr inbounds [3 x i64], ptr %lRange.i.i2306, i64 0, i64 1
  store i64 1, ptr %arrayidx3.i.i2307, align 8
  %conv5.i.i2308 = sext i32 %980 to i64
  %div.i.i23096125 = lshr i64 %conv5.i.i2308, 6
  %rem.i.i2310 = and i64 %conv5.i.i2308, 63
  %tobool.not.i.i2311 = icmp ne i64 %rem.i.i2310, 0
  %conv9.i.i2312 = zext i1 %tobool.not.i.i2311 to i64
  %add.i.i2313 = add nuw nsw i64 %div.i.i23096125, %conv9.i.i2312
  %.sroa.speculated8.i.i2314 = call i64 @llvm.umax.i64(i64 %add.i.i2313, i64 1)
  %mul.i.i2315 = shl i64 %.sroa.speculated8.i.i2314, 6
  store i64 %mul.i.i2315, ptr %gRange.i.i2305, align 16
  %arrayidx27.i.i2316 = getelementptr inbounds [3 x i64], ptr %gRange.i.i2305, i64 0, i64 1
  store i64 1, ptr %arrayidx27.i.i2316, align 8
  %981 = load ptr, ptr @__clewEnqueueNDRangeKernel, align 8
  %m_commandQueue.i.i2317 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1279, i64 0, i32 1
  %982 = load ptr, ptr %m_commandQueue.i.i2317, align 8
  %983 = load ptr, ptr %m_kernel.i2261, align 8
  %call32.i.i2323 = invoke i32 %981(ptr noundef %982, ptr noundef %983, i32 noundef 2, ptr noundef null, ptr noundef nonnull %gRange.i.i2305, ptr noundef nonnull %lRange.i.i2306, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call32.i.i.noexc2322 unwind label %lpad1282

call32.i.i.noexc2322:                             ; preds = %invoke.cont1312
  %cmp.not.i.i2319 = icmp eq i32 %call32.i.i2323, 0
  br i1 %cmp.not.i.i2319, label %invoke.cont1314, label %if.then.i.i2320

if.then.i.i2320:                                  ; preds = %call32.i.i.noexc2322
  %call33.i.i2321 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.74, i32 noundef %call32.i.i2323)
  br label %invoke.cont1314

invoke.cont1314:                                  ; preds = %if.then.i.i2320, %call32.i.i.noexc2322
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %gRange.i.i2305)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %lRange.i.i2306)
  %984 = load ptr, ptr @__clewFinish, align 8
  %985 = load ptr, ptr %m_queue, align 8
  %call1317 = invoke i32 %984(ptr noundef %985)
          to label %invoke.cont1316 unwind label %lpad1282

invoke.cont1316:                                  ; preds = %invoke.cont1314
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %elem.i2325)
  %986 = load i64, ptr %m_capacity.i.i, align 8
  %cmp.not.i.i2327 = icmp eq i64 %986, 0
  br i1 %cmp.not.i.i2327, label %do.body.i.i2332, label %if.then.i.i2328

if.then.i.i2328:                                  ; preds = %invoke.cont1316
  %987 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %988 = load ptr, ptr %m_commandQueue.i.i635, align 8
  %989 = load ptr, ptr %m_clBuffer.i.i636, align 8
  %call3.i.i2334 = invoke i32 %987(ptr noundef %988, ptr noundef %989, i32 noundef 0, i64 noundef 0, i64 noundef 4, ptr noundef nonnull %elem.i2325, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call3.i.i.noexc2333 unwind label %lpad1282

call3.i.i.noexc2333:                              ; preds = %if.then.i.i2328
  %990 = load ptr, ptr @__clewFinish, align 8
  %991 = load ptr, ptr %m_commandQueue.i.i635, align 8
  %call6.i.i2336 = invoke i32 %990(ptr noundef %991)
          to label %call6.i.i.noexc2335 unwind label %lpad1282

call6.i.i.noexc2335:                              ; preds = %call3.i.i.noexc2333
  %.pre.i2331 = load i32, ptr %elem.i2325, align 4
  br label %invoke.cont1319

do.body.i.i2332:                                  ; preds = %invoke.cont1316
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 285)
          to label %.noexc2337 unwind label %lpad1282

.noexc2337:                                       ; preds = %do.body.i.i2332
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.80)
          to label %invoke.cont1319 unwind label %lpad1282

invoke.cont1319:                                  ; preds = %call6.i.i.noexc2335, %.noexc2337
  %992 = phi i32 [ %.pre.i2331, %call6.i.i.noexc2335 ], [ undef, %.noexc2337 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %elem.i2325)
  store i32 %992, ptr %numConcavePairs, align 4
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279) #26
  invoke void @b3LeaveProfileZone()
          to label %if.end1400 unwind label %terminate.lpad.i2340

terminate.lpad.i2340:                             ; preds = %invoke.cont1319
  %993 = landingpad { ptr, i32 }
          catch ptr null
  %994 = extractvalue { ptr, i32 } %993, 0
  call void @__clang_call_terminate(ptr %994) #27
  unreachable

lpad1276:                                         ; preds = %.noexc2231, %do.body.i.i2226, %call3.i.i.noexc2227, %if.then.i.i2222, %invoke.cont1277
  %995 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup1322

lpad1282:                                         ; preds = %if.then3.i.i5134, %.noexc5150, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5146, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5119, %if.then3.i.i5094, %.noexc5110, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5106, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5079, %.noexc2337, %do.body.i.i2332, %call3.i.i.noexc2333, %if.then.i.i2328, %invoke.cont1312, %if.end.i2291, %if.end.i2260, %invoke.cont1314, %invoke.cont1307, %invoke.cont1304, %invoke.cont1301, %invoke.cont1297, %invoke.cont1294, %invoke.cont1291, %invoke.cont1288, %invoke.cont1285, %invoke.cont1281
  %996 = landingpad { ptr, i32 }
          cleanup
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1279) #26
  br label %ehcleanup1322

ehcleanup1322:                                    ; preds = %lpad1282, %lpad1276
  %.pn482 = phi { ptr, i32 } [ %996, %lpad1282 ], [ %995, %lpad1276 ]
  invoke void @b3LeaveProfileZone()
          to label %ehcleanup2980 unwind label %terminate.lpad.i2342

terminate.lpad.i2342:                             ; preds = %ehcleanup1322
  %997 = landingpad { ptr, i32 }
          catch ptr null
  %998 = extractvalue { ptr, i32 } %997, 0
  call void @__clang_call_terminate(ptr %998) #27
  unreachable

invoke.cont1325:                                  ; preds = %if.then1270
  %m_ownsMemory.i.i2344 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %hostPairs1324, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i2344, align 8
  %m_data.i.i2345 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %hostPairs1324, i64 0, i32 5
  store ptr null, ptr %m_data.i.i2345, align 8
  %m_size.i.i2346 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %hostPairs1324, i64 0, i32 2
  store i32 0, ptr %m_size.i.i2346, align 4
  %m_capacity.i.i2347 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %hostPairs1324, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i2347, align 8
  invoke void @_ZNK13b3OpenCLArrayI6b3Int4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %pairs, ptr noundef nonnull align 8 dereferenceable(25) %hostPairs1324, i1 noundef zeroext true)
          to label %invoke.cont1329 unwind label %lpad1326

invoke.cont1329:                                  ; preds = %invoke.cont1325
  %m_ownsMemory.i.i2348 = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %hostBodyBuf1328, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i2348, align 8
  %m_data.i.i2349 = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %hostBodyBuf1328, i64 0, i32 5
  store ptr null, ptr %m_data.i.i2349, align 8
  %m_size.i.i2350 = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %hostBodyBuf1328, i64 0, i32 2
  store i32 0, ptr %m_size.i.i2350, align 4
  %m_capacity.i.i2351 = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %hostBodyBuf1328, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i2351, align 8
  invoke void @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %bodyBuf, ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf1328, i1 noundef zeroext true)
          to label %invoke.cont1333 unwind label %lpad1330

invoke.cont1333:                                  ; preds = %invoke.cont1329
  %m_ownsMemory.i.i2352 = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %hostCollidables1332, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i2352, align 8
  %m_data.i.i2353 = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %hostCollidables1332, i64 0, i32 5
  store ptr null, ptr %m_data.i.i2353, align 8
  %m_size.i.i2354 = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %hostCollidables1332, i64 0, i32 2
  store i32 0, ptr %m_size.i.i2354, align 4
  %m_capacity.i.i2355 = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %hostCollidables1332, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i2355, align 8
  invoke void @_ZNK13b3OpenCLArrayI12b3CollidableE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %gpuCollidables, ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables1332, i1 noundef zeroext true)
          to label %invoke.cont1337 unwind label %lpad1334

invoke.cont1337:                                  ; preds = %invoke.cont1333
  %m_ownsMemory.i.i2356 = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %hostAabbsWorldSpace1336, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i2356, align 8
  %m_data.i.i2357 = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %hostAabbsWorldSpace1336, i64 0, i32 5
  store ptr null, ptr %m_data.i.i2357, align 8
  %m_size.i.i2358 = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %hostAabbsWorldSpace1336, i64 0, i32 2
  store i32 0, ptr %m_size.i.i2358, align 4
  %m_capacity.i.i2359 = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %hostAabbsWorldSpace1336, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i2359, align 8
  invoke void @_ZNK13b3OpenCLArrayI6b3AabbE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %clAabbsWorldSpace, ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsWorldSpace1336, i1 noundef zeroext true)
          to label %invoke.cont1340 unwind label %lpad1338

invoke.cont1340:                                  ; preds = %invoke.cont1337
  %m_ownsMemory.i.i2360 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %triangleConvexPairsOutHost, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i2360, align 8
  %m_data.i.i2361 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %triangleConvexPairsOutHost, i64 0, i32 5
  store ptr null, ptr %m_data.i.i2361, align 8
  %m_size.i.i2362 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %triangleConvexPairsOutHost, i64 0, i32 2
  store i32 0, ptr %m_size.i.i2362, align 4
  %m_capacity.i.i2363 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %triangleConvexPairsOutHost, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i2363, align 8
  %999 = load i32, ptr %maxTriConvexPairCapacity.addr, align 4
  %cmp4.i2365 = icmp sgt i32 %999, 0
  br i1 %cmp4.i2365, label %_ZN20b3AlignedObjectArrayI6b3Int4E8allocateEi.exit.i, label %invoke.cont1345

_ZN20b3AlignedObjectArrayI6b3Int4E8allocateEi.exit.i: ; preds = %invoke.cont1340
  %conv.i.i.i5159 = zext nneg i32 %999 to i64
  %mul.i.i.i5160 = shl nuw nsw i64 %conv.i.i.i5159, 4
  %call.i.i.i5186 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i5160, i32 noundef 16)
          to label %call.i.i.i.noexc5185 unwind label %lpad1342

call.i.i.i.noexc5185:                             ; preds = %_ZN20b3AlignedObjectArrayI6b3Int4E8allocateEi.exit.i
  %cmp3.i5161 = icmp eq ptr %call.i.i.i5186, null
  br i1 %cmp3.i5161, label %_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_.exit18.i, label %.noexc2374

_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_.exit18.i: ; preds = %call.i.i.i.noexc5185
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc5187 unwind label %lpad1342

.noexc5187:                                       ; preds = %_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_.exit18.i
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc2374 unwind label %lpad1342

.noexc2374:                                       ; preds = %.noexc5187, %call.i.i.i.noexc5185
  %_Count.addr.0.i5167 = phi i32 [ %999, %call.i.i.i.noexc5185 ], [ 0, %.noexc5187 ]
  store i8 1, ptr %m_ownsMemory.i.i2360, align 8
  store ptr %call.i.i.i5186, ptr %m_data.i.i2361, align 8
  store i32 %_Count.addr.0.i5167, ptr %m_capacity.i.i2363, align 8
  br label %for.body9.i2369

for.body9.i2369:                                  ; preds = %for.body9.i2369, %.noexc2374
  %indvars.iv.i2370 = phi i64 [ 0, %.noexc2374 ], [ %indvars.iv.next.i2372, %for.body9.i2369 ]
  %arrayidx12.i2371 = getelementptr inbounds %struct.b3Int4, ptr %call.i.i.i5186, i64 %indvars.iv.i2370
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx12.i2371, i8 0, i64 16, i1 false)
  %indvars.iv.next.i2372 = add nuw nsw i64 %indvars.iv.i2370, 1
  %exitcond.not.i2373 = icmp eq i64 %indvars.iv.next.i2372, %conv.i.i.i5159
  br i1 %exitcond.not.i2373, label %invoke.cont1345, label %for.body9.i2369, !llvm.loop !54

invoke.cont1345:                                  ; preds = %for.body9.i2369, %invoke.cont1340
  %1000 = phi ptr [ null, %invoke.cont1340 ], [ %call.i.i.i5186, %for.body9.i2369 ]
  store i32 %999, ptr %m_size.i.i2362, align 4
  store i32 0, ptr %numConcavePairs, align 4
  %m_ownsMemory.i.i2375 = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %treeNodesCPU1344, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i2375, align 8
  %m_data.i.i2376 = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %treeNodesCPU1344, i64 0, i32 5
  store ptr null, ptr %m_data.i.i2376, align 8
  %m_size.i.i2377 = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %treeNodesCPU1344, i64 0, i32 2
  store i32 0, ptr %m_size.i.i2377, align 4
  %m_capacity.i.i2378 = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %treeNodesCPU1344, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i2378, align 8
  invoke void @_ZNK13b3OpenCLArrayI18b3QuantizedBvhNodeE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %treeNodesGPU, ptr noundef nonnull align 8 dereferenceable(25) %treeNodesCPU1344, i1 noundef zeroext true)
          to label %invoke.cont1349 unwind label %lpad1346

invoke.cont1349:                                  ; preds = %invoke.cont1345
  %m_ownsMemory.i.i2379 = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %subTreesCPU1348, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i2379, align 8
  %m_data.i.i2380 = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %subTreesCPU1348, i64 0, i32 5
  store ptr null, ptr %m_data.i.i2380, align 8
  %m_size.i.i2381 = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %subTreesCPU1348, i64 0, i32 2
  store i32 0, ptr %m_size.i.i2381, align 4
  %m_capacity.i.i2382 = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %subTreesCPU1348, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i2382, align 8
  %m_size.i.i2383 = getelementptr inbounds %class.b3OpenCLArray.98, ptr %subTreesGPU, i64 0, i32 1
  %1001 = load i64, ptr %m_size.i.i2383, align 8
  %conv.i2384 = trunc i64 %1001 to i32
  %cmp4.i.i = icmp sgt i32 %conv.i2384, 0
  br i1 %cmp4.i.i, label %_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE8allocateEi.exit.i, label %_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE6resizeEiRKS0_.exit.i

_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE8allocateEi.exit.i: ; preds = %invoke.cont1349
  %conv.i.i.i5195 = shl i64 %1001, 5
  %mul.i.i.i5196 = and i64 %conv.i.i.i5195, 137438953440
  %call.i.i.i5222 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i5196, i32 noundef 16)
          to label %call.i.i.i.noexc5221 unwind label %lpad1350

call.i.i.i.noexc5221:                             ; preds = %_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE8allocateEi.exit.i
  %cmp3.i5197 = icmp eq ptr %call.i.i.i5222, null
  br i1 %cmp3.i5197, label %_ZNK20b3AlignedObjectArrayI16b3BvhSubtreeInfoE4copyEiiPS0_.exit18.i, label %_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE10deallocateEv.exit.i

_ZNK20b3AlignedObjectArrayI16b3BvhSubtreeInfoE4copyEiiPS0_.exit18.i: ; preds = %call.i.i.i.noexc5221
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc5223 unwind label %lpad1350

.noexc5223:                                       ; preds = %_ZNK20b3AlignedObjectArrayI16b3BvhSubtreeInfoE4copyEiiPS0_.exit18.i
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE10deallocateEv.exit.i unwind label %lpad1350

_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE10deallocateEv.exit.i: ; preds = %.noexc5223, %call.i.i.i.noexc5221
  %_Count.addr.0.i5203 = phi i32 [ %conv.i2384, %call.i.i.i.noexc5221 ], [ 0, %.noexc5223 ]
  store i8 1, ptr %m_ownsMemory.i.i2379, align 8
  store ptr %call.i.i.i5222, ptr %m_data.i.i2380, align 8
  store i32 %_Count.addr.0.i5203, ptr %m_capacity.i.i2382, align 8
  %.pr6095 = load i64, ptr %m_size.i.i2383, align 8
  br label %_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE6resizeEiRKS0_.exit.i

_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE6resizeEiRKS0_.exit.i: ; preds = %_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE10deallocateEv.exit.i, %invoke.cont1349
  %1002 = phi ptr [ %call.i.i.i5222, %_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE10deallocateEv.exit.i ], [ null, %invoke.cont1349 ]
  %1003 = phi i64 [ %.pr6095, %_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE10deallocateEv.exit.i ], [ %1001, %invoke.cont1349 ]
  store i32 %conv.i2384, ptr %m_size.i.i2381, align 4
  %tobool.not.i2386 = icmp eq i64 %1003, 0
  br i1 %tobool.not.i2386, label %invoke.cont1353, label %if.then.i2387

if.then.i2387:                                    ; preds = %_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE6resizeEiRKS0_.exit.i
  %m_capacity.i.i.i2388 = getelementptr inbounds %class.b3OpenCLArray.98, ptr %subTreesGPU, i64 0, i32 2
  %1004 = load i64, ptr %m_capacity.i.i.i2388, align 8
  %cmp.not.i.i2389 = icmp ugt i64 %1003, %1004
  br i1 %cmp.not.i.i2389, label %do.body.i.i2396, label %if.then.i.i2390

if.then.i.i2390:                                  ; preds = %if.then.i2387
  %1005 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %m_commandQueue.i.i2392 = getelementptr inbounds %class.b3OpenCLArray.98, ptr %subTreesGPU, i64 0, i32 5
  %1006 = load ptr, ptr %m_commandQueue.i.i2392, align 8
  %1007 = load ptr, ptr %m_clBuffer.i1874, align 8
  %mul2.i.i2394 = shl i64 %1003, 5
  %call3.i.i2399 = invoke i32 %1005(ptr noundef %1006, ptr noundef %1007, i32 noundef 0, i64 noundef 0, i64 noundef %mul2.i.i2394, ptr noundef %1002, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call3.i.i.noexc2398 unwind label %lpad1350

call3.i.i.noexc2398:                              ; preds = %if.then.i.i2390
  %1008 = load ptr, ptr @__clewFinish, align 8
  %1009 = load ptr, ptr %m_commandQueue.i.i2392, align 8
  %call6.i.i2401 = invoke i32 %1008(ptr noundef %1009)
          to label %invoke.cont1353 unwind label %lpad1350

do.body.i.i2396:                                  ; preds = %if.then.i2387
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 285)
          to label %.noexc2402 unwind label %lpad1350

.noexc2402:                                       ; preds = %do.body.i.i2396
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.80)
          to label %invoke.cont1353 unwind label %lpad1350

invoke.cont1353:                                  ; preds = %.noexc2402, %call3.i.i.noexc2398, %_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE6resizeEiRKS0_.exit.i
  %m_ownsMemory.i.i2404 = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %bvhInfoCPU1352, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i2404, align 8
  %m_data.i.i2405 = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %bvhInfoCPU1352, i64 0, i32 5
  store ptr null, ptr %m_data.i.i2405, align 8
  %m_size.i.i2406 = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %bvhInfoCPU1352, i64 0, i32 2
  store i32 0, ptr %m_size.i.i2406, align 4
  %m_capacity.i.i2407 = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %bvhInfoCPU1352, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i2407, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3BvhInfoE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %bvhInfo, ptr noundef nonnull align 8 dereferenceable(25) %bvhInfoCPU1352, i1 noundef zeroext true)
          to label %invoke.cont1355 unwind label %lpad1354

invoke.cont1355:                                  ; preds = %invoke.cont1353
  store volatile i32 0, ptr %hostNumConcavePairsOut, align 4
  %1010 = load i32, ptr %nPairs.addr, align 4
  %cmp13586152 = icmp sgt i32 %1010, 0
  br i1 %cmp13586152, label %for.body1359, label %for.end1379

for.body1359:                                     ; preds = %invoke.cont1355, %for.body1359
  %i1356.06153 = phi i32 [ %inc1378, %for.body1359 ], [ 0, %invoke.cont1355 ]
  %1011 = load ptr, ptr %m_data.i.i2345, align 8
  %1012 = load ptr, ptr %m_data.i.i2349, align 8
  %1013 = load ptr, ptr %m_data.i.i2353, align 8
  %1014 = load ptr, ptr %m_data.i.i2357, align 8
  %1015 = load ptr, ptr %m_data.i.i2380, align 8
  %1016 = load ptr, ptr %m_data.i.i2376, align 8
  %1017 = load ptr, ptr %m_data.i.i2405, align 8
  %1018 = load i32, ptr %maxTriConvexPairCapacity.addr, align 4
  call void @_Z14b3BvhTraversalPK6b3Int4PK15b3RigidBodyDataPK12b3CollidableP6b3AabbPS_PViPK16b3BvhSubtreeInfoPK18b3QuantizedBvhNodePK9b3BvhInfoiii(ptr noundef nonnull %1011, ptr noundef nonnull %1012, ptr noundef nonnull %1013, ptr noundef nonnull %1014, ptr noundef nonnull %1000, ptr noundef nonnull %hostNumConcavePairsOut, ptr noundef nonnull %1015, ptr noundef nonnull %1016, ptr noundef nonnull %1017, i32 poison, i32 noundef %1018, i32 noundef %i1356.06153)
  %inc1378 = add nuw nsw i32 %i1356.06153, 1
  %1019 = load i32, ptr %nPairs.addr, align 4
  %cmp1358 = icmp slt i32 %inc1378, %1019
  br i1 %cmp1358, label %for.body1359, label %for.end1379, !llvm.loop !68

lpad1326:                                         ; preds = %invoke.cont1325
  %1020 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup1399

lpad1330:                                         ; preds = %invoke.cont1329
  %1021 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup1398

lpad1334:                                         ; preds = %invoke.cont1333
  %1022 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup1397

lpad1338:                                         ; preds = %invoke.cont1337
  %1023 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup1396

lpad1342:                                         ; preds = %.noexc5187, %_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_.exit18.i, %_ZN20b3AlignedObjectArrayI6b3Int4E8allocateEi.exit.i
  %1024 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup1395

lpad1346:                                         ; preds = %invoke.cont1345
  %1025 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup1394

lpad1350:                                         ; preds = %.noexc5223, %_ZNK20b3AlignedObjectArrayI16b3BvhSubtreeInfoE4copyEiiPS0_.exit18.i, %_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoE8allocateEi.exit.i, %.noexc2402, %do.body.i.i2396, %call3.i.i.noexc2398, %if.then.i.i2390
  %1026 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup1393

lpad1354:                                         ; preds = %if.then3.i.i5246, %.noexc5262, %_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_.exit18.i5258, %_ZN20b3AlignedObjectArrayI6b3Int4E8allocateEi.exit.i5231, %call.i.i.noexc2469, %if.then.i.i2457, %if.then.i2463, %call.i.i.noexc2444, %if.then.i.i2434, %if.end7.i.i2440, %invoke.cont1353
  %1027 = landingpad { ptr, i32 }
          cleanup
  call void @_ZN20b3AlignedObjectArrayI9b3BvhInfoED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %bvhInfoCPU1352) #26
  br label %ehcleanup1393

for.end1379:                                      ; preds = %for.body1359, %invoke.cont1355
  %1028 = load volatile i32, ptr %hostNumConcavePairsOut, align 4
  store i32 %1028, ptr %numConcavePairs, align 4
  %1029 = load volatile i32, ptr %hostNumConcavePairsOut, align 4
  %tobool1380.not = icmp eq i32 %1029, 0
  br i1 %tobool1380.not, label %invoke.cont1387, label %if.then1381

if.then1381:                                      ; preds = %for.end1379
  %1030 = load volatile i32, ptr %hostNumConcavePairsOut, align 4
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp1382.sroa.0, i8 0, i64 16, i1 false)
  %1031 = load i32, ptr %m_size.i.i2362, align 4
  %cmp4.i2417 = icmp slt i32 %1031, %1030
  br i1 %cmp4.i2417, label %for.body9.lr.ph.i2418, label %if.then1381.invoke.cont1383_crit_edge

if.then1381.invoke.cont1383_crit_edge:            ; preds = %if.then1381
  %.pre6247 = sext i32 %1030 to i64
  br label %invoke.cont1383

for.body9.lr.ph.i2418:                            ; preds = %if.then1381
  %1032 = load i32, ptr %m_capacity.i.i2363, align 8
  %cmp.i5227 = icmp slt i32 %1032, %1030
  br i1 %cmp.i5227, label %if.then.i5229, label %.noexc2426

if.then.i5229:                                    ; preds = %for.body9.lr.ph.i2418
  %tobool.not.i.i5230 = icmp eq i32 %1030, 0
  br i1 %tobool.not.i.i5230, label %_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_.exit18.i5258, label %_ZN20b3AlignedObjectArrayI6b3Int4E8allocateEi.exit.i5231

_ZN20b3AlignedObjectArrayI6b3Int4E8allocateEi.exit.i5231: ; preds = %if.then.i5229
  %conv.i.i.i5232 = sext i32 %1030 to i64
  %mul.i.i.i5233 = shl nsw i64 %conv.i.i.i5232, 4
  %call.i.i.i5261 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i5233, i32 noundef 16)
          to label %call.i.i.i.noexc5260 unwind label %lpad1354

call.i.i.i.noexc5260:                             ; preds = %_ZN20b3AlignedObjectArrayI6b3Int4E8allocateEi.exit.i5231
  %cmp3.i5234 = icmp eq ptr %call.i.i.i5261, null
  br i1 %cmp3.i5234, label %_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_.exit18.i5258, label %if.then.split.i5235

if.then.split.i5235:                              ; preds = %call.i.i.i.noexc5260
  %cmp4.i.i5237 = icmp sgt i32 %1031, 0
  br i1 %cmp4.i.i5237, label %for.body.lr.ph.i.i5249, label %if.end.i5238

for.body.lr.ph.i.i5249:                           ; preds = %if.then.split.i5235
  %wide.trip.count.i.i5251 = zext nneg i32 %1031 to i64
  br label %for.body.i.i5252

for.body.i.i5252:                                 ; preds = %for.body.i.i5252, %for.body.lr.ph.i.i5249
  %indvars.iv.i.i5253 = phi i64 [ 0, %for.body.lr.ph.i.i5249 ], [ %indvars.iv.next.i.i5256, %for.body.i.i5252 ]
  %arrayidx.i.i5254 = getelementptr inbounds %struct.b3Int4, ptr %call.i.i.i5261, i64 %indvars.iv.i.i5253
  %arrayidx3.i.i5255 = getelementptr inbounds %struct.b3Int4, ptr %1000, i64 %indvars.iv.i.i5253
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx.i.i5254, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx3.i.i5255, i64 16, i1 false)
  %indvars.iv.next.i.i5256 = add nuw nsw i64 %indvars.iv.i.i5253, 1
  %exitcond.not.i.i5257 = icmp eq i64 %indvars.iv.next.i.i5256, %wide.trip.count.i.i5251
  br i1 %exitcond.not.i.i5257, label %if.then.i22.i5243, label %for.body.i.i5252, !llvm.loop !69

_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_.exit18.i5258: ; preds = %call.i.i.i.noexc5260, %if.then.i5229
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc5262 unwind label %lpad1354

.noexc5262:                                       ; preds = %_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_.exit18.i5258
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc5263 unwind label %lpad1354

.noexc5263:                                       ; preds = %.noexc5262
  store i32 0, ptr %m_size.i.i2362, align 4
  br label %if.end.i5238

if.end.i5238:                                     ; preds = %.noexc5263, %if.then.split.i5235
  %retval.0.i25.i5239 = phi ptr [ null, %.noexc5263 ], [ %call.i.i.i5261, %if.then.split.i5235 ]
  %_Count.addr.0.i5240 = phi i32 [ 0, %.noexc5263 ], [ %1030, %if.then.split.i5235 ]
  %tobool.not.i21.i5242 = icmp eq ptr %1000, null
  br i1 %tobool.not.i21.i5242, label %_ZN20b3AlignedObjectArrayI6b3Int4E10deallocateEv.exit.i5247, label %if.then.i22.i5243

if.then.i22.i5243:                                ; preds = %for.body.i.i5252, %if.end.i5238
  %_Count.addr.0.i52406256 = phi i32 [ %_Count.addr.0.i5240, %if.end.i5238 ], [ %1030, %for.body.i.i5252 ]
  %retval.0.i25.i52396254 = phi ptr [ %retval.0.i25.i5239, %if.end.i5238 ], [ %call.i.i.i5261, %for.body.i.i5252 ]
  %1033 = load i8, ptr %m_ownsMemory.i.i2360, align 8
  %1034 = and i8 %1033, 1
  %tobool2.not.i.i5245 = icmp eq i8 %1034, 0
  br i1 %tobool2.not.i.i5245, label %_ZN20b3AlignedObjectArrayI6b3Int4E10deallocateEv.exit.i5247, label %if.then3.i.i5246

if.then3.i.i5246:                                 ; preds = %if.then.i22.i5243
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1000)
          to label %_ZN20b3AlignedObjectArrayI6b3Int4E10deallocateEv.exit.i5247 unwind label %lpad1354

_ZN20b3AlignedObjectArrayI6b3Int4E10deallocateEv.exit.i5247: ; preds = %if.then3.i.i5246, %if.then.i22.i5243, %if.end.i5238
  %_Count.addr.0.i52406257 = phi i32 [ %_Count.addr.0.i52406256, %if.then3.i.i5246 ], [ %_Count.addr.0.i52406256, %if.then.i22.i5243 ], [ %_Count.addr.0.i5240, %if.end.i5238 ]
  %retval.0.i25.i52396255 = phi ptr [ %retval.0.i25.i52396254, %if.then3.i.i5246 ], [ %retval.0.i25.i52396254, %if.then.i22.i5243 ], [ %retval.0.i25.i5239, %if.end.i5238 ]
  store i8 1, ptr %m_ownsMemory.i.i2360, align 8
  store ptr %retval.0.i25.i52396255, ptr %m_data.i.i2361, align 8
  store i32 %_Count.addr.0.i52406257, ptr %m_capacity.i.i2363, align 8
  br label %.noexc2426

.noexc2426:                                       ; preds = %_ZN20b3AlignedObjectArrayI6b3Int4E10deallocateEv.exit.i5247, %for.body9.lr.ph.i2418
  %1035 = phi ptr [ %retval.0.i25.i52396255, %_ZN20b3AlignedObjectArrayI6b3Int4E10deallocateEv.exit.i5247 ], [ %1000, %for.body9.lr.ph.i2418 ]
  %1036 = sext i32 %1031 to i64
  %wide.trip.count.i2420 = sext i32 %1030 to i64
  br label %for.body9.i2421

for.body9.i2421:                                  ; preds = %for.body9.i2421, %.noexc2426
  %indvars.iv.i2422 = phi i64 [ %1036, %.noexc2426 ], [ %indvars.iv.next.i2424, %for.body9.i2421 ]
  %arrayidx12.i2423 = getelementptr inbounds %struct.b3Int4, ptr %1035, i64 %indvars.iv.i2422
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx12.i2423, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp1382.sroa.0, i64 16, i1 false)
  %indvars.iv.next.i2424 = add nsw i64 %indvars.iv.i2422, 1
  %exitcond.not.i2425 = icmp eq i64 %indvars.iv.next.i2424, %wide.trip.count.i2420
  br i1 %exitcond.not.i2425, label %invoke.cont1383, label %for.body9.i2421, !llvm.loop !54

invoke.cont1383:                                  ; preds = %for.body9.i2421, %if.then1381.invoke.cont1383_crit_edge
  %conv.i2429.pre-phi = phi i64 [ %.pre6247, %if.then1381.invoke.cont1383_crit_edge ], [ %wide.trip.count.i2420, %for.body9.i2421 ]
  %1037 = phi ptr [ %1000, %if.then1381.invoke.cont1383_crit_edge ], [ %1035, %for.body9.i2421 ]
  store i32 %1030, ptr %m_size.i.i2362, align 4
  %m_size.i.i.i2430 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %triangleConvexPairsOut, i64 0, i32 1
  %1038 = load i64, ptr %m_size.i.i.i2430, align 8
  %cmp3.i.i2431 = icmp ult i64 %1038, %conv.i2429.pre-phi
  br i1 %cmp3.i.i2431, label %if.end7.i.i2440, label %_ZN13b3OpenCLArrayI6b3Int4E6resizeEmb.exit.i

if.end7.i.i2440:                                  ; preds = %invoke.cont1383
  %call5.i.i2443 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI6b3Int4E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %triangleConvexPairsOut, i64 noundef %conv.i2429.pre-phi, i1 noundef zeroext false)
          to label %call5.i.i.noexc2442 unwind label %lpad1354

call5.i.i.noexc2442:                              ; preds = %if.end7.i.i2440
  %spec.select.i.i2441 = select i1 %call5.i.i2443, i64 %conv.i2429.pre-phi, i64 0
  br label %_ZN13b3OpenCLArrayI6b3Int4E6resizeEmb.exit.i

_ZN13b3OpenCLArrayI6b3Int4E6resizeEmb.exit.i:     ; preds = %call5.i.i.noexc2442, %invoke.cont1383
  %storemerge.i.i2432 = phi i64 [ %conv.i2429.pre-phi, %invoke.cont1383 ], [ %spec.select.i.i2441, %call5.i.i.noexc2442 ]
  store i64 %storemerge.i.i2432, ptr %m_size.i.i.i2430, align 8
  %tobool3.not.i2433 = icmp eq i32 %1030, 0
  br i1 %tobool3.not.i2433, label %invoke.cont1387, label %if.then.i.i2434

if.then.i.i2434:                                  ; preds = %_ZN13b3OpenCLArrayI6b3Int4E6resizeEmb.exit.i
  %mul.i.i2436 = shl nsw i64 %conv.i2429.pre-phi, 4
  %1039 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %m_commandQueue.i.i2437 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %triangleConvexPairsOut, i64 0, i32 5
  %1040 = load ptr, ptr %m_commandQueue.i.i2437, align 8
  %m_clBuffer.i.i2438 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %triangleConvexPairsOut, i64 0, i32 3
  %1041 = load ptr, ptr %m_clBuffer.i.i2438, align 8
  %call.i.i2445 = invoke i32 %1039(ptr noundef %1040, ptr noundef %1041, i32 noundef 0, i64 noundef 0, i64 noundef %mul.i.i2436, ptr noundef %1037, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call.i.i.noexc2444 unwind label %lpad1354

call.i.i.noexc2444:                               ; preds = %if.then.i.i2434
  %1042 = load ptr, ptr @__clewFinish, align 8
  %1043 = load ptr, ptr %m_commandQueue.i.i2437, align 8
  %call6.i.i2447 = invoke i32 %1042(ptr noundef %1043)
          to label %invoke.cont1387 unwind label %lpad1354

invoke.cont1387:                                  ; preds = %for.end1379, %call.i.i.noexc2444, %_ZN13b3OpenCLArrayI6b3Int4E6resizeEmb.exit.i
  store i64 0, ptr %m_size.i.i629, align 8
  %1044 = load i64, ptr %m_capacity.i.i, align 8
  %cmp.i2453 = icmp eq i64 %1044, 0
  br i1 %cmp.i2453, label %if.then.i2463, label %if.then.i.i2457

if.then.i2463:                                    ; preds = %invoke.cont1387
  %call5.i2468 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayIiE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_numConcavePairsOut, i64 noundef 1, i1 noundef zeroext true)
          to label %if.then.i.i2457 unwind label %lpad1354

if.then.i.i2457:                                  ; preds = %invoke.cont1387, %if.then.i2463
  %1045 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %1046 = load ptr, ptr %m_commandQueue.i.i635, align 8
  %1047 = load ptr, ptr %m_clBuffer.i.i636, align 8
  %call.i.i2470 = invoke i32 %1045(ptr noundef %1046, ptr noundef %1047, i32 noundef 0, i64 noundef 0, i64 noundef 4, ptr noundef nonnull %numConcavePairs, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call.i.i.noexc2469 unwind label %lpad1354

call.i.i.noexc2469:                               ; preds = %if.then.i.i2457
  %1048 = load ptr, ptr @__clewFinish, align 8
  %1049 = load ptr, ptr %m_commandQueue.i.i635, align 8
  %call6.i.i2472 = invoke i32 %1048(ptr noundef %1049)
          to label %invoke.cont1390 unwind label %lpad1354

invoke.cont1390:                                  ; preds = %call.i.i.noexc2469
  %1050 = load i64, ptr %m_size.i.i629, align 8
  %inc.i2461 = add i64 %1050, 1
  store i64 %inc.i2461, ptr %m_size.i.i629, align 8
  %1051 = load ptr, ptr %m_data.i.i2405, align 8
  %tobool.not.i.i.i2477 = icmp eq ptr %1051, null
  br i1 %tobool.not.i.i.i2477, label %_ZN20b3AlignedObjectArrayI9b3BvhInfoED2Ev.exit, label %if.then.i.i.i2478

if.then.i.i.i2478:                                ; preds = %invoke.cont1390
  %1052 = load i8, ptr %m_ownsMemory.i.i2404, align 8
  %1053 = and i8 %1052, 1
  %tobool2.not.i.i.i2480 = icmp eq i8 %1053, 0
  br i1 %tobool2.not.i.i.i2480, label %_ZN20b3AlignedObjectArrayI9b3BvhInfoED2Ev.exit, label %if.then3.i.i.i2481

if.then3.i.i.i2481:                               ; preds = %if.then.i.i.i2478
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1051)
          to label %_ZN20b3AlignedObjectArrayI9b3BvhInfoED2Ev.exit unwind label %terminate.lpad.i2482

terminate.lpad.i2482:                             ; preds = %if.then3.i.i.i2481
  %1054 = landingpad { ptr, i32 }
          catch ptr null
  %1055 = extractvalue { ptr, i32 } %1054, 0
  call void @__clang_call_terminate(ptr %1055) #27
  unreachable

_ZN20b3AlignedObjectArrayI9b3BvhInfoED2Ev.exit:   ; preds = %invoke.cont1390, %if.then.i.i.i2478, %if.then3.i.i.i2481
  store i8 1, ptr %m_ownsMemory.i.i2404, align 8
  store ptr null, ptr %m_data.i.i2405, align 8
  store i32 0, ptr %m_size.i.i2406, align 4
  store i32 0, ptr %m_capacity.i.i2407, align 8
  %1056 = load ptr, ptr %m_data.i.i2380, align 8
  %tobool.not.i.i.i2487 = icmp eq ptr %1056, null
  br i1 %tobool.not.i.i.i2487, label %_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoED2Ev.exit, label %if.then.i.i.i2488

if.then.i.i.i2488:                                ; preds = %_ZN20b3AlignedObjectArrayI9b3BvhInfoED2Ev.exit
  %1057 = load i8, ptr %m_ownsMemory.i.i2379, align 8
  %1058 = and i8 %1057, 1
  %tobool2.not.i.i.i2490 = icmp eq i8 %1058, 0
  br i1 %tobool2.not.i.i.i2490, label %_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoED2Ev.exit, label %if.then3.i.i.i2491

if.then3.i.i.i2491:                               ; preds = %if.then.i.i.i2488
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1056)
          to label %_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoED2Ev.exit unwind label %terminate.lpad.i2492

terminate.lpad.i2492:                             ; preds = %if.then3.i.i.i2491
  %1059 = landingpad { ptr, i32 }
          catch ptr null
  %1060 = extractvalue { ptr, i32 } %1059, 0
  call void @__clang_call_terminate(ptr %1060) #27
  unreachable

_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoED2Ev.exit: ; preds = %_ZN20b3AlignedObjectArrayI9b3BvhInfoED2Ev.exit, %if.then.i.i.i2488, %if.then3.i.i.i2491
  store i8 1, ptr %m_ownsMemory.i.i2379, align 8
  store i32 0, ptr %m_size.i.i2381, align 4
  store i32 0, ptr %m_capacity.i.i2382, align 8
  %1061 = load ptr, ptr %m_data.i.i2376, align 8
  %tobool.not.i.i.i2497 = icmp eq ptr %1061, null
  br i1 %tobool.not.i.i.i2497, label %_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeED2Ev.exit, label %if.then.i.i.i2498

if.then.i.i.i2498:                                ; preds = %_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoED2Ev.exit
  %1062 = load i8, ptr %m_ownsMemory.i.i2375, align 8
  %1063 = and i8 %1062, 1
  %tobool2.not.i.i.i2500 = icmp eq i8 %1063, 0
  br i1 %tobool2.not.i.i.i2500, label %_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeED2Ev.exit, label %if.then3.i.i.i2501

if.then3.i.i.i2501:                               ; preds = %if.then.i.i.i2498
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1061)
          to label %_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeED2Ev.exit unwind label %terminate.lpad.i2502

terminate.lpad.i2502:                             ; preds = %if.then3.i.i.i2501
  %1064 = landingpad { ptr, i32 }
          catch ptr null
  %1065 = extractvalue { ptr, i32 } %1064, 0
  call void @__clang_call_terminate(ptr %1065) #27
  unreachable

_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeED2Ev.exit: ; preds = %_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoED2Ev.exit, %if.then.i.i.i2498, %if.then3.i.i.i2501
  store i8 1, ptr %m_ownsMemory.i.i2375, align 8
  store ptr null, ptr %m_data.i.i2376, align 8
  store i32 0, ptr %m_size.i.i2377, align 4
  store i32 0, ptr %m_capacity.i.i2378, align 8
  %1066 = load ptr, ptr %m_data.i.i2361, align 8
  %tobool.not.i.i.i2507 = icmp eq ptr %1066, null
  br i1 %tobool.not.i.i.i2507, label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit2516, label %if.then.i.i.i2508

if.then.i.i.i2508:                                ; preds = %_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeED2Ev.exit
  %1067 = load i8, ptr %m_ownsMemory.i.i2360, align 8
  %1068 = and i8 %1067, 1
  %tobool2.not.i.i.i2510 = icmp eq i8 %1068, 0
  br i1 %tobool2.not.i.i.i2510, label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit2516, label %if.then3.i.i.i2511

if.then3.i.i.i2511:                               ; preds = %if.then.i.i.i2508
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1066)
          to label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit2516 unwind label %terminate.lpad.i2512

terminate.lpad.i2512:                             ; preds = %if.then3.i.i.i2511
  %1069 = landingpad { ptr, i32 }
          catch ptr null
  %1070 = extractvalue { ptr, i32 } %1069, 0
  call void @__clang_call_terminate(ptr %1070) #27
  unreachable

_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit2516:  ; preds = %_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeED2Ev.exit, %if.then.i.i.i2508, %if.then3.i.i.i2511
  store i8 1, ptr %m_ownsMemory.i.i2360, align 8
  store i32 0, ptr %m_size.i.i2362, align 4
  store i32 0, ptr %m_capacity.i.i2363, align 8
  %1071 = load ptr, ptr %m_data.i.i2357, align 8
  %tobool.not.i.i.i2518 = icmp eq ptr %1071, null
  br i1 %tobool.not.i.i.i2518, label %_ZN20b3AlignedObjectArrayI6b3AabbED2Ev.exit, label %if.then.i.i.i2519

if.then.i.i.i2519:                                ; preds = %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit2516
  %1072 = load i8, ptr %m_ownsMemory.i.i2356, align 8
  %1073 = and i8 %1072, 1
  %tobool2.not.i.i.i2521 = icmp eq i8 %1073, 0
  br i1 %tobool2.not.i.i.i2521, label %_ZN20b3AlignedObjectArrayI6b3AabbED2Ev.exit, label %if.then3.i.i.i2522

if.then3.i.i.i2522:                               ; preds = %if.then.i.i.i2519
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1071)
          to label %_ZN20b3AlignedObjectArrayI6b3AabbED2Ev.exit unwind label %terminate.lpad.i2523

terminate.lpad.i2523:                             ; preds = %if.then3.i.i.i2522
  %1074 = landingpad { ptr, i32 }
          catch ptr null
  %1075 = extractvalue { ptr, i32 } %1074, 0
  call void @__clang_call_terminate(ptr %1075) #27
  unreachable

_ZN20b3AlignedObjectArrayI6b3AabbED2Ev.exit:      ; preds = %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit2516, %if.then.i.i.i2519, %if.then3.i.i.i2522
  store i8 1, ptr %m_ownsMemory.i.i2356, align 8
  store ptr null, ptr %m_data.i.i2357, align 8
  store i32 0, ptr %m_size.i.i2358, align 4
  store i32 0, ptr %m_capacity.i.i2359, align 8
  %1076 = load ptr, ptr %m_data.i.i2353, align 8
  %tobool.not.i.i.i2528 = icmp eq ptr %1076, null
  br i1 %tobool.not.i.i.i2528, label %_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev.exit2537, label %if.then.i.i.i2529

if.then.i.i.i2529:                                ; preds = %_ZN20b3AlignedObjectArrayI6b3AabbED2Ev.exit
  %1077 = load i8, ptr %m_ownsMemory.i.i2352, align 8
  %1078 = and i8 %1077, 1
  %tobool2.not.i.i.i2531 = icmp eq i8 %1078, 0
  br i1 %tobool2.not.i.i.i2531, label %_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev.exit2537, label %if.then3.i.i.i2532

if.then3.i.i.i2532:                               ; preds = %if.then.i.i.i2529
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1076)
          to label %_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev.exit2537 unwind label %terminate.lpad.i2533

terminate.lpad.i2533:                             ; preds = %if.then3.i.i.i2532
  %1079 = landingpad { ptr, i32 }
          catch ptr null
  %1080 = extractvalue { ptr, i32 } %1079, 0
  call void @__clang_call_terminate(ptr %1080) #27
  unreachable

_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev.exit2537: ; preds = %_ZN20b3AlignedObjectArrayI6b3AabbED2Ev.exit, %if.then.i.i.i2529, %if.then3.i.i.i2532
  store i8 1, ptr %m_ownsMemory.i.i2352, align 8
  store ptr null, ptr %m_data.i.i2353, align 8
  store i32 0, ptr %m_size.i.i2354, align 4
  store i32 0, ptr %m_capacity.i.i2355, align 8
  %1081 = load ptr, ptr %m_data.i.i2349, align 8
  %tobool.not.i.i.i2539 = icmp eq ptr %1081, null
  br i1 %tobool.not.i.i.i2539, label %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev.exit2548, label %if.then.i.i.i2540

if.then.i.i.i2540:                                ; preds = %_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev.exit2537
  %1082 = load i8, ptr %m_ownsMemory.i.i2348, align 8
  %1083 = and i8 %1082, 1
  %tobool2.not.i.i.i2542 = icmp eq i8 %1083, 0
  br i1 %tobool2.not.i.i.i2542, label %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev.exit2548, label %if.then3.i.i.i2543

if.then3.i.i.i2543:                               ; preds = %if.then.i.i.i2540
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1081)
          to label %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev.exit2548 unwind label %terminate.lpad.i2544

terminate.lpad.i2544:                             ; preds = %if.then3.i.i.i2543
  %1084 = landingpad { ptr, i32 }
          catch ptr null
  %1085 = extractvalue { ptr, i32 } %1084, 0
  call void @__clang_call_terminate(ptr %1085) #27
  unreachable

_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev.exit2548: ; preds = %_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev.exit2537, %if.then.i.i.i2540, %if.then3.i.i.i2543
  store i8 1, ptr %m_ownsMemory.i.i2348, align 8
  store ptr null, ptr %m_data.i.i2349, align 8
  store i32 0, ptr %m_size.i.i2350, align 4
  store i32 0, ptr %m_capacity.i.i2351, align 8
  %1086 = load ptr, ptr %m_data.i.i2345, align 8
  %tobool.not.i.i.i2550 = icmp eq ptr %1086, null
  br i1 %tobool.not.i.i.i2550, label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit2559, label %if.then.i.i.i2551

if.then.i.i.i2551:                                ; preds = %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev.exit2548
  %1087 = load i8, ptr %m_ownsMemory.i.i2344, align 8
  %1088 = and i8 %1087, 1
  %tobool2.not.i.i.i2553 = icmp eq i8 %1088, 0
  br i1 %tobool2.not.i.i.i2553, label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit2559, label %if.then3.i.i.i2554

if.then3.i.i.i2554:                               ; preds = %if.then.i.i.i2551
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1086)
          to label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit2559 unwind label %terminate.lpad.i2555

terminate.lpad.i2555:                             ; preds = %if.then3.i.i.i2554
  %1089 = landingpad { ptr, i32 }
          catch ptr null
  %1090 = extractvalue { ptr, i32 } %1089, 0
  call void @__clang_call_terminate(ptr %1090) #27
  unreachable

_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit2559:  ; preds = %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev.exit2548, %if.then.i.i.i2551, %if.then3.i.i.i2554
  store i8 1, ptr %m_ownsMemory.i.i2344, align 8
  store ptr null, ptr %m_data.i.i2345, align 8
  store i32 0, ptr %m_size.i.i2346, align 4
  store i32 0, ptr %m_capacity.i.i2347, align 8
  br label %if.end1400

ehcleanup1393:                                    ; preds = %lpad1354, %lpad1350
  %.pn474 = phi { ptr, i32 } [ %1027, %lpad1354 ], [ %1026, %lpad1350 ]
  call void @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %subTreesCPU1348) #26
  br label %ehcleanup1394

ehcleanup1394:                                    ; preds = %ehcleanup1393, %lpad1346
  %.pn474.pn = phi { ptr, i32 } [ %.pn474, %ehcleanup1393 ], [ %1025, %lpad1346 ]
  call void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %treeNodesCPU1344) #26
  br label %ehcleanup1395

ehcleanup1395:                                    ; preds = %ehcleanup1394, %lpad1342
  %.pn474.pn.pn = phi { ptr, i32 } [ %.pn474.pn, %ehcleanup1394 ], [ %1024, %lpad1342 ]
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %triangleConvexPairsOutHost) #26
  br label %ehcleanup1396

ehcleanup1396:                                    ; preds = %ehcleanup1395, %lpad1338
  %.pn474.pn.pn.pn = phi { ptr, i32 } [ %.pn474.pn.pn, %ehcleanup1395 ], [ %1023, %lpad1338 ]
  call void @_ZN20b3AlignedObjectArrayI6b3AabbED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsWorldSpace1336) #26
  br label %ehcleanup1397

ehcleanup1397:                                    ; preds = %ehcleanup1396, %lpad1334
  %.pn474.pn.pn.pn.pn = phi { ptr, i32 } [ %.pn474.pn.pn.pn, %ehcleanup1396 ], [ %1022, %lpad1334 ]
  call void @_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables1332) #26
  br label %ehcleanup1398

ehcleanup1398:                                    ; preds = %ehcleanup1397, %lpad1330
  %.pn474.pn.pn.pn.pn.pn = phi { ptr, i32 } [ %.pn474.pn.pn.pn.pn, %ehcleanup1397 ], [ %1021, %lpad1330 ]
  call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf1328) #26
  br label %ehcleanup1399

ehcleanup1399:                                    ; preds = %ehcleanup1398, %lpad1326
  %.pn474.pn.pn.pn.pn.pn.pn = phi { ptr, i32 } [ %.pn474.pn.pn.pn.pn.pn, %ehcleanup1398 ], [ %1020, %lpad1326 ]
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostPairs1324) #26
  br label %ehcleanup2980

if.end1400:                                       ; preds = %invoke.cont1319, %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit2559
  %1091 = load i32, ptr %numConcavePairs, align 4
  %1092 = load i32, ptr %maxTriConvexPairCapacity.addr, align 4
  %cmp1401 = icmp sgt i32 %1091, %1092
  br i1 %cmp1401, label %do.body1403, label %if.end1409

do.body1403:                                      ; preds = %if.end1400
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.31, i32 noundef 3577)
          to label %invoke.cont1404 unwind label %lpad58

invoke.cont1404:                                  ; preds = %do.body1403
  %1093 = load i32, ptr %numConcavePairs, align 4
  %1094 = load i32, ptr %maxTriConvexPairCapacity.addr, align 4
  %1095 = load i32, ptr @_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E39exceeded_maxTriConvexPairCapacity_count, align 4
  %inc1405 = add nsw i32 %1095, 1
  store i32 %inc1405, ptr @_ZZN15GpuSatCollision33computeConvexConvexContactsGPUSATEP13b3OpenCLArrayI6b3Int4EiPKS0_I15b3RigidBodyDataEPS0_I10b3Contact4ERiPKS9_iiRKS0_I22b3ConvexPolyhedronDataERKS0_I9b3Vector3ESL_RKS0_I9b3GpuFaceERKS0_IiERKS0_I12b3CollidableERKS0_I15b3GpuChildShapeERKS0_I6b3AabbES14_RSJ_RS2_S15_S15_S15_R20b3AlignedObjectArrayIP14b3OptimizedBvhEPS0_I18b3QuantizedBvhNodeEPS0_I16b3BvhSubtreeInfoEPS0_I9b3BvhInfoEiiS16_SB_E39exceeded_maxTriConvexPairCapacity_count, align 4
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.53, i32 noundef %1093, i32 noundef %1094, i32 noundef %1095)
          to label %do.end1408 unwind label %lpad58

do.end1408:                                       ; preds = %invoke.cont1404
  %1096 = load i32, ptr %maxTriConvexPairCapacity.addr, align 4
  store i32 %1096, ptr %numConcavePairs, align 4
  br label %if.end1409

if.end1409:                                       ; preds = %do.end1408, %if.end1400
  %1097 = phi i32 [ %1096, %do.end1408 ], [ %1091, %if.end1400 ]
  %conv1410 = sext i32 %1097 to i64
  %m_size.i.i2560 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %triangleConvexPairsOut, i64 0, i32 1
  %1098 = load i64, ptr %m_size.i.i2560, align 8
  %cmp3.i2561 = icmp ult i64 %1098, %conv1410
  br i1 %cmp3.i2561, label %if.end7.i2564, label %invoke.cont1411

if.end7.i2564:                                    ; preds = %if.end1409
  %call5.i2567 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI6b3Int4E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %triangleConvexPairsOut, i64 noundef %conv1410, i1 noundef zeroext true)
          to label %call5.i.noexc2566 unwind label %lpad58

call5.i.noexc2566:                                ; preds = %if.end7.i2564
  %spec.select.i2565 = select i1 %call5.i2567, i64 %conv1410, i64 0
  %.pr6096 = load i32, ptr %numConcavePairs, align 4
  br label %invoke.cont1411

invoke.cont1411:                                  ; preds = %call5.i.noexc2566, %if.end1409
  %1099 = phi i32 [ %.pr6096, %call5.i.noexc2566 ], [ %1097, %if.end1409 ]
  %storemerge.i2562 = phi i64 [ %spec.select.i2565, %call5.i.noexc2566 ], [ %conv1410, %if.end1409 ]
  store i64 %storemerge.i2562, ptr %m_size.i.i2560, align 8
  %tobool1413.not = icmp eq i32 %1099, 0
  br i1 %tobool1413.not, label %if.end1853, label %if.then1414

if.then1414:                                      ; preds = %invoke.cont1411
  %conv1415 = sext i32 %1099 to i64
  %m_size.i.i2568 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %clippingFacesOutGPU, i64 0, i32 1
  %1100 = load i64, ptr %m_size.i.i2568, align 8
  %cmp3.i2569 = icmp ult i64 %1100, %conv1415
  br i1 %cmp3.i2569, label %if.end7.i2572, label %invoke.cont1416

if.end7.i2572:                                    ; preds = %if.then1414
  %call5.i2575 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI6b3Int4E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %clippingFacesOutGPU, i64 noundef %conv1415, i1 noundef zeroext true)
          to label %call5.i.noexc2574 unwind label %lpad58

call5.i.noexc2574:                                ; preds = %if.end7.i2572
  %spec.select.i2573 = select i1 %call5.i2575, i64 %conv1415, i64 0
  %.pre6192 = load i32, ptr %numConcavePairs, align 4
  %.pre6243 = sext i32 %.pre6192 to i64
  br label %invoke.cont1416

invoke.cont1416:                                  ; preds = %call5.i.noexc2574, %if.then1414
  %conv1418.pre-phi = phi i64 [ %.pre6243, %call5.i.noexc2574 ], [ %conv1415, %if.then1414 ]
  %1101 = phi i32 [ %.pre6192, %call5.i.noexc2574 ], [ %1099, %if.then1414 ]
  %storemerge.i2570 = phi i64 [ %spec.select.i2573, %call5.i.noexc2574 ], [ %conv1415, %if.then1414 ]
  store i64 %storemerge.i2570, ptr %m_size.i.i2568, align 8
  %m_size.i.i2577 = getelementptr inbounds %class.b3OpenCLArray, ptr %worldNormalsAGPU, i64 0, i32 1
  %1102 = load i64, ptr %m_size.i.i2577, align 8
  %cmp3.i2578 = icmp ult i64 %1102, %conv1418.pre-phi
  br i1 %cmp3.i2578, label %if.end7.i2581, label %invoke.cont1419

if.end7.i2581:                                    ; preds = %invoke.cont1416
  %call5.i2584 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %worldNormalsAGPU, i64 noundef %conv1418.pre-phi, i1 noundef zeroext true)
          to label %call5.i.noexc2583 unwind label %lpad58

call5.i.noexc2583:                                ; preds = %if.end7.i2581
  %spec.select.i2582 = select i1 %call5.i2584, i64 %conv1418.pre-phi, i64 0
  %.pre6193 = load i32, ptr %numConcavePairs, align 4
  br label %invoke.cont1419

invoke.cont1419:                                  ; preds = %call5.i.noexc2583, %invoke.cont1416
  %1103 = phi i32 [ %1101, %invoke.cont1416 ], [ %.pre6193, %call5.i.noexc2583 ]
  %storemerge.i2579 = phi i64 [ %conv1418.pre-phi, %invoke.cont1416 ], [ %spec.select.i2582, %call5.i.noexc2583 ]
  store i64 %storemerge.i2579, ptr %m_size.i.i2577, align 8
  %1104 = load i32, ptr %vertexFaceCapacity, align 4
  %mul = mul nsw i32 %1103, %1104
  %conv1421 = sext i32 %mul to i64
  %m_size.i.i2586 = getelementptr inbounds %class.b3OpenCLArray, ptr %worldVertsA1GPU, i64 0, i32 1
  %1105 = load i64, ptr %m_size.i.i2586, align 8
  %cmp3.i2587 = icmp ult i64 %1105, %conv1421
  br i1 %cmp3.i2587, label %if.end7.i2590, label %invoke.cont1422

if.end7.i2590:                                    ; preds = %invoke.cont1419
  %call5.i2593 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %worldVertsA1GPU, i64 noundef %conv1421, i1 noundef zeroext true)
          to label %call5.i.noexc2592 unwind label %lpad58

call5.i.noexc2592:                                ; preds = %if.end7.i2590
  %spec.select.i2591 = select i1 %call5.i2593, i64 %conv1421, i64 0
  %.pre6194 = load i32, ptr %vertexFaceCapacity, align 4
  %.pre6195 = load i32, ptr %numConcavePairs, align 4
  %.pre6244 = mul nsw i32 %.pre6195, %.pre6194
  %.pre6245 = sext i32 %.pre6244 to i64
  br label %invoke.cont1422

invoke.cont1422:                                  ; preds = %call5.i.noexc2592, %invoke.cont1419
  %conv1425.pre-phi = phi i64 [ %.pre6245, %call5.i.noexc2592 ], [ %conv1421, %invoke.cont1419 ]
  %storemerge.i2588 = phi i64 [ %spec.select.i2591, %call5.i.noexc2592 ], [ %conv1421, %invoke.cont1419 ]
  store i64 %storemerge.i2588, ptr %m_size.i.i2586, align 8
  %m_size.i.i2595 = getelementptr inbounds %class.b3OpenCLArray, ptr %worldVertsB1GPU, i64 0, i32 1
  %1106 = load i64, ptr %m_size.i.i2595, align 8
  %cmp3.i2596 = icmp ult i64 %1106, %conv1425.pre-phi
  br i1 %cmp3.i2596, label %if.end7.i2599, label %invoke.cont1426

if.end7.i2599:                                    ; preds = %invoke.cont1422
  %call5.i2602 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %worldVertsB1GPU, i64 noundef %conv1425.pre-phi, i1 noundef zeroext true)
          to label %call5.i.noexc2601 unwind label %lpad58

call5.i.noexc2601:                                ; preds = %if.end7.i2599
  %spec.select.i2600 = select i1 %call5.i2602, i64 %conv1425.pre-phi, i64 0
  br label %invoke.cont1426

invoke.cont1426:                                  ; preds = %call5.i.noexc2601, %invoke.cont1422
  %storemerge.i2597 = phi i64 [ %conv1425.pre-phi, %invoke.cont1422 ], [ %spec.select.i2600, %call5.i.noexc2601 ]
  store i64 %storemerge.i2597, ptr %m_size.i.i2595, align 8
  %1107 = load i8, ptr @findConcaveSeparatingAxisKernelGPU, align 1
  %1108 = and i8 %1107, 1
  %tobool1428.not = icmp eq i8 %1108, 0
  br i1 %tobool1428.not, label %invoke.cont1715, label %if.then1429

if.then1429:                                      ; preds = %invoke.cont1426
  %1109 = load i8, ptr @splitSearchSepAxisConcave, align 1
  %1110 = and i8 %1109, 1
  %tobool1430.not = icmp eq i8 %1110, 0
  br i1 %tobool1430.not, label %if.else1616, label %if.then1431

if.then1431:                                      ; preds = %if.then1429
  %1111 = load i32, ptr %numConcavePairs, align 4
  %conv1433 = sext i32 %1111 to i64
  %m_size.i.i2604 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 27, i32 1
  %1112 = load i64, ptr %m_size.i.i2604, align 8
  %cmp3.i2605 = icmp ult i64 %1112, %conv1433
  br i1 %cmp3.i2605, label %if.end7.i2608, label %invoke.cont1434

if.end7.i2608:                                    ; preds = %if.then1431
  %m_dmins1432 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 27
  %call5.i2611 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayIfE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_dmins1432, i64 noundef %conv1433, i1 noundef zeroext true)
          to label %call5.i.noexc2610 unwind label %lpad58

call5.i.noexc2610:                                ; preds = %if.end7.i2608
  %spec.select.i2609 = select i1 %call5.i2611, i64 %conv1433, i64 0
  br label %invoke.cont1434

invoke.cont1434:                                  ; preds = %call5.i.noexc2610, %if.then1431
  %storemerge.i2606 = phi i64 [ %conv1433, %if.then1431 ], [ %spec.select.i2609, %call5.i.noexc2610 ]
  store i64 %storemerge.i2606, ptr %m_size.i.i2604, align 8
  invoke void @b3EnterProfileZone(ptr noundef nonnull @.str.13)
          to label %invoke.cont1437 unwind label %lpad58

invoke.cont1437:                                  ; preds = %invoke.cont1434
  %m_clBuffer.i2615 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %triangleConvexPairsOut, i64 0, i32 3
  %1113 = load ptr, ptr %m_clBuffer.i2615, align 8
  store ptr %1113, ptr %bInfo1438, align 16
  %m_isReadOnly.i2616 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 0, i32 1
  store i8 0, ptr %m_isReadOnly.i2616, align 8
  %arrayinit.element1444 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 1
  %1114 = load ptr, ptr %m_clBuffer.i531, align 8
  store ptr %1114, ptr %arrayinit.element1444, align 16
  %m_isReadOnly.i2618 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 1, i32 1
  store i8 1, ptr %m_isReadOnly.i2618, align 8
  %arrayinit.element1448 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 2
  %1115 = load ptr, ptr %m_clBuffer.i533, align 8
  store ptr %1115, ptr %arrayinit.element1448, align 16
  %m_isReadOnly.i2620 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 2, i32 1
  store i8 1, ptr %m_isReadOnly.i2620, align 8
  %arrayinit.element1452 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 3
  %1116 = load ptr, ptr %m_clBuffer.i535, align 8
  store ptr %1116, ptr %arrayinit.element1452, align 16
  %m_isReadOnly.i2622 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 3, i32 1
  store i8 1, ptr %m_isReadOnly.i2622, align 8
  %arrayinit.element1456 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 4
  %1117 = load ptr, ptr %m_clBuffer.i537, align 8
  store ptr %1117, ptr %arrayinit.element1456, align 16
  %m_isReadOnly.i2624 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 4, i32 1
  store i8 1, ptr %m_isReadOnly.i2624, align 8
  %arrayinit.element1460 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 5
  %1118 = load ptr, ptr %m_clBuffer.i539, align 8
  store ptr %1118, ptr %arrayinit.element1460, align 16
  %m_isReadOnly.i2626 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 5, i32 1
  store i8 1, ptr %m_isReadOnly.i2626, align 8
  %arrayinit.element1464 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 6
  %1119 = load ptr, ptr %m_clBuffer.i541, align 8
  store ptr %1119, ptr %arrayinit.element1464, align 16
  %m_isReadOnly.i2628 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 6, i32 1
  store i8 1, ptr %m_isReadOnly.i2628, align 8
  %arrayinit.element1468 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 7
  %1120 = load ptr, ptr %m_clBuffer.i543, align 8
  store ptr %1120, ptr %arrayinit.element1468, align 16
  %m_isReadOnly.i2630 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 7, i32 1
  store i8 1, ptr %m_isReadOnly.i2630, align 8
  %arrayinit.element1472 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 8
  %1121 = load ptr, ptr %m_clBuffer.i1868, align 8
  store ptr %1121, ptr %arrayinit.element1472, align 16
  %m_isReadOnly.i2632 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 8, i32 1
  store i8 1, ptr %m_isReadOnly.i2632, align 8
  %arrayinit.element1476 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 9
  %m_clBuffer.i2633 = getelementptr inbounds %class.b3OpenCLArray.90, ptr %clAabbsWorldSpace, i64 0, i32 3
  %1122 = load ptr, ptr %m_clBuffer.i2633, align 8
  store ptr %1122, ptr %arrayinit.element1476, align 16
  %m_isReadOnly.i2634 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 9, i32 1
  store i8 1, ptr %m_isReadOnly.i2634, align 8
  %arrayinit.element1480 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 10
  %m_clBuffer.i2635 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 29, i32 3
  %1123 = load ptr, ptr %m_clBuffer.i2635, align 8
  store ptr %1123, ptr %arrayinit.element1480, align 16
  %m_isReadOnly.i2636 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 10, i32 1
  store i8 0, ptr %m_isReadOnly.i2636, align 8
  %arrayinit.element1485 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 11
  %m_clBuffer.i2637 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 30, i32 3
  %1124 = load ptr, ptr %m_clBuffer.i2637, align 8
  store ptr %1124, ptr %arrayinit.element1485, align 16
  %m_isReadOnly.i2638 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 11, i32 1
  store i8 0, ptr %m_isReadOnly.i2638, align 8
  %arrayinit.element1490 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 12
  %m_clBuffer.i2639 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %clippingFacesOutGPU, i64 0, i32 3
  %1125 = load ptr, ptr %m_clBuffer.i2639, align 8
  store ptr %1125, ptr %arrayinit.element1490, align 16
  %m_isReadOnly.i2640 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 12, i32 1
  store i8 0, ptr %m_isReadOnly.i2640, align 8
  %arrayinit.element1494 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 13
  %m_clBuffer.i2641 = getelementptr inbounds %class.b3OpenCLArray, ptr %worldVertsA1GPU, i64 0, i32 3
  %1126 = load ptr, ptr %m_clBuffer.i2641, align 8
  store ptr %1126, ptr %arrayinit.element1494, align 16
  %m_isReadOnly.i2642 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 13, i32 1
  store i8 0, ptr %m_isReadOnly.i2642, align 8
  %arrayinit.element1498 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 14
  %m_clBuffer.i2643 = getelementptr inbounds %class.b3OpenCLArray, ptr %worldNormalsAGPU, i64 0, i32 3
  %1127 = load ptr, ptr %m_clBuffer.i2643, align 8
  store ptr %1127, ptr %arrayinit.element1498, align 16
  %m_isReadOnly.i2644 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 14, i32 1
  store i8 0, ptr %m_isReadOnly.i2644, align 8
  %arrayinit.element1502 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 15
  %m_clBuffer.i2645 = getelementptr inbounds %class.b3OpenCLArray, ptr %worldVertsB1GPU, i64 0, i32 3
  %1128 = load ptr, ptr %m_clBuffer.i2645, align 8
  store ptr %1128, ptr %arrayinit.element1502, align 16
  %m_isReadOnly.i2646 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 15, i32 1
  store i8 0, ptr %m_isReadOnly.i2646, align 8
  %arrayinit.element1506 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 16
  %m_clBuffer.i2647 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 27, i32 3
  %1129 = load ptr, ptr %m_clBuffer.i2647, align 8
  store ptr %1129, ptr %arrayinit.element1506, align 16
  %m_isReadOnly.i2648 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1438, i64 16, i32 1
  store i8 0, ptr %m_isReadOnly.i2648, align 8
  %1130 = load ptr, ptr %m_queue, align 8
  %m_findConcaveSeparatingAxisVertexFaceKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 10
  %1131 = load ptr, ptr %m_findConcaveSeparatingAxisVertexFaceKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher1511, ptr noundef %1130, ptr noundef %1131, ptr noundef nonnull @.str.54)
          to label %invoke.cont1513 unwind label %lpad1440

invoke.cont1513:                                  ; preds = %invoke.cont1437
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher1511, ptr noundef nonnull %bInfo1438, i32 noundef 17)
          to label %invoke.cont1516 unwind label %lpad1515

invoke.cont1516:                                  ; preds = %invoke.cont1513
  %m_enableSerialization.i2649 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1511, i64 0, i32 7
  %1132 = load i8, ptr %m_enableSerialization.i2649, align 4
  %1133 = and i8 %1132, 1
  %tobool.not.i2650 = icmp eq i8 %1133, 0
  br i1 %tobool.not.i2650, label %if.end.i2666, label %if.then.i2651

if.then.i2651:                                    ; preds = %invoke.cont1516
  %m_idx.i2652 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1511, i64 0, i32 3
  %1134 = load i32, ptr %m_idx.i2652, align 8
  %1135 = load i32, ptr %vertexFaceCapacity, align 4
  %m_size.i.i.i2653 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1511, i64 0, i32 5, i32 2
  %1136 = load i32, ptr %m_size.i.i.i2653, align 4
  %m_capacity.i.i.i2654 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1511, i64 0, i32 5, i32 3
  %1137 = load i32, ptr %m_capacity.i.i.i2654, align 8
  %cmp.i.i2655 = icmp eq i32 %1136, %1137
  br i1 %cmp.i.i2655, label %if.then.i.i2671, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2656

if.then.i.i2671:                                  ; preds = %if.then.i2651
  %m_kernelArguments.i2672 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1511, i64 0, i32 5
  %tobool.not.i.i.i2673 = icmp eq i32 %1136, 0
  %mul.i.i.i2674 = shl nsw i32 %1136, 1
  %cond.i.i.i2675 = select i1 %tobool.not.i.i.i2673, i32 1, i32 %mul.i.i.i2674
  invoke void @_ZN20b3AlignedObjectArrayI15b3KernelArgDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %m_kernelArguments.i2672, i32 noundef %cond.i.i.i2675)
          to label %.noexc2677 unwind label %lpad1515

.noexc2677:                                       ; preds = %if.then.i.i2671
  %.pre.i.i2676 = load i32, ptr %m_size.i.i.i2653, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2656

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2656: ; preds = %.noexc2677, %if.then.i2651
  %1138 = phi i32 [ %.pre.i.i2676, %.noexc2677 ], [ %1136, %if.then.i2651 ]
  %m_data.i.i2657 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1511, i64 0, i32 5, i32 5
  %1139 = load ptr, ptr %m_data.i.i2657, align 8
  %idxprom.i.i2658 = sext i32 %1138 to i64
  %arrayidx.i.i2659 = getelementptr inbounds %struct.b3KernelArgData, ptr %1139, i64 %idxprom.i.i2658
  store i32 0, ptr %arrayidx.i.i2659, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i2660 = getelementptr inbounds i8, ptr %arrayidx.i.i2659, i64 4
  store i32 %1134, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i2660, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i2661 = getelementptr inbounds i8, ptr %arrayidx.i.i2659, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i2661, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i2662 = getelementptr inbounds i8, ptr %arrayidx.i.i2659, i64 16
  store i32 %1135, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i2662, align 16
  %1140 = load i32, ptr %m_size.i.i.i2653, align 4
  %inc.i.i2663 = add nsw i32 %1140, 1
  store i32 %inc.i.i2663, ptr %m_size.i.i.i2653, align 4
  %m_serializationSizeInBytes.i2664 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1511, i64 0, i32 6
  %1141 = load i32, ptr %m_serializationSizeInBytes.i2664, align 8
  %add.i2665 = add i32 %1141, 32
  store i32 %add.i2665, ptr %m_serializationSizeInBytes.i2664, align 8
  br label %if.end.i2666

if.end.i2666:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2656, %invoke.cont1516
  %1142 = load ptr, ptr @__clewSetKernelArg, align 8
  %m_kernel.i2667 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1511, i64 0, i32 2
  %1143 = load ptr, ptr %m_kernel.i2667, align 8
  %m_idx3.i2668 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1511, i64 0, i32 3
  %1144 = load i32, ptr %m_idx3.i2668, align 8
  %inc.i2669 = add nsw i32 %1144, 1
  store i32 %inc.i2669, ptr %m_idx3.i2668, align 8
  %call.i26702678 = invoke i32 %1142(ptr noundef %1143, i32 noundef %1144, i64 noundef 4, ptr noundef nonnull %vertexFaceCapacity)
          to label %invoke.cont1517 unwind label %lpad1515

invoke.cont1517:                                  ; preds = %if.end.i2666
  %1145 = load i8, ptr %m_enableSerialization.i2649, align 4
  %1146 = and i8 %1145, 1
  %tobool.not.i2681 = icmp eq i8 %1146, 0
  br i1 %tobool.not.i2681, label %if.end.i2697, label %if.then.i2682

if.then.i2682:                                    ; preds = %invoke.cont1517
  %1147 = load i32, ptr %m_idx3.i2668, align 8
  %1148 = load i32, ptr %numConcavePairs, align 4
  %m_size.i.i.i2684 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1511, i64 0, i32 5, i32 2
  %1149 = load i32, ptr %m_size.i.i.i2684, align 4
  %m_capacity.i.i.i2685 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1511, i64 0, i32 5, i32 3
  %1150 = load i32, ptr %m_capacity.i.i.i2685, align 8
  %cmp.i.i2686 = icmp eq i32 %1149, %1150
  br i1 %cmp.i.i2686, label %if.then.i.i2702, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2687

if.then.i.i2702:                                  ; preds = %if.then.i2682
  %m_kernelArguments.i2703 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1511, i64 0, i32 5
  %tobool.not.i.i.i2704 = icmp eq i32 %1149, 0
  %mul.i.i.i2705 = shl nsw i32 %1149, 1
  %cond.i.i.i2706 = select i1 %tobool.not.i.i.i2704, i32 1, i32 %mul.i.i.i2705
  invoke void @_ZN20b3AlignedObjectArrayI15b3KernelArgDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %m_kernelArguments.i2703, i32 noundef %cond.i.i.i2706)
          to label %.noexc2708 unwind label %lpad1515

.noexc2708:                                       ; preds = %if.then.i.i2702
  %.pre.i.i2707 = load i32, ptr %m_size.i.i.i2684, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2687

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2687: ; preds = %.noexc2708, %if.then.i2682
  %1151 = phi i32 [ %.pre.i.i2707, %.noexc2708 ], [ %1149, %if.then.i2682 ]
  %m_data.i.i2688 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1511, i64 0, i32 5, i32 5
  %1152 = load ptr, ptr %m_data.i.i2688, align 8
  %idxprom.i.i2689 = sext i32 %1151 to i64
  %arrayidx.i.i2690 = getelementptr inbounds %struct.b3KernelArgData, ptr %1152, i64 %idxprom.i.i2689
  store i32 0, ptr %arrayidx.i.i2690, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i2691 = getelementptr inbounds i8, ptr %arrayidx.i.i2690, i64 4
  store i32 %1147, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i2691, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i2692 = getelementptr inbounds i8, ptr %arrayidx.i.i2690, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i2692, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i2693 = getelementptr inbounds i8, ptr %arrayidx.i.i2690, i64 16
  store i32 %1148, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i2693, align 16
  %1153 = load i32, ptr %m_size.i.i.i2684, align 4
  %inc.i.i2694 = add nsw i32 %1153, 1
  store i32 %inc.i.i2694, ptr %m_size.i.i.i2684, align 4
  %m_serializationSizeInBytes.i2695 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1511, i64 0, i32 6
  %1154 = load i32, ptr %m_serializationSizeInBytes.i2695, align 8
  %add.i2696 = add i32 %1154, 32
  store i32 %add.i2696, ptr %m_serializationSizeInBytes.i2695, align 8
  br label %if.end.i2697

if.end.i2697:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2687, %invoke.cont1517
  %1155 = load ptr, ptr @__clewSetKernelArg, align 8
  %1156 = load ptr, ptr %m_kernel.i2667, align 8
  %1157 = load i32, ptr %m_idx3.i2668, align 8
  %inc.i2700 = add nsw i32 %1157, 1
  store i32 %inc.i2700, ptr %m_idx3.i2668, align 8
  %call.i27012709 = invoke i32 %1155(ptr noundef %1156, i32 noundef %1157, i64 noundef 4, ptr noundef nonnull %numConcavePairs)
          to label %invoke.cont1518 unwind label %lpad1515

invoke.cont1518:                                  ; preds = %if.end.i2697
  %1158 = load i32, ptr %numConcavePairs, align 4
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %gRange.i.i2711)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %lRange.i.i2712)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %gRange.i.i2711, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %lRange.i.i2712, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  store i64 64, ptr %lRange.i.i2712, align 16
  %arrayidx3.i.i2713 = getelementptr inbounds [3 x i64], ptr %lRange.i.i2712, i64 0, i64 1
  store i64 1, ptr %arrayidx3.i.i2713, align 8
  %conv5.i.i2714 = sext i32 %1158 to i64
  %div.i.i27156126 = lshr i64 %conv5.i.i2714, 6
  %rem.i.i2716 = and i64 %conv5.i.i2714, 63
  %tobool.not.i.i2717 = icmp ne i64 %rem.i.i2716, 0
  %conv9.i.i2718 = zext i1 %tobool.not.i.i2717 to i64
  %add.i.i2719 = add nuw nsw i64 %div.i.i27156126, %conv9.i.i2718
  %.sroa.speculated8.i.i2720 = call i64 @llvm.umax.i64(i64 %add.i.i2719, i64 1)
  %mul.i.i2721 = shl i64 %.sroa.speculated8.i.i2720, 6
  store i64 %mul.i.i2721, ptr %gRange.i.i2711, align 16
  %arrayidx27.i.i2722 = getelementptr inbounds [3 x i64], ptr %gRange.i.i2711, i64 0, i64 1
  store i64 1, ptr %arrayidx27.i.i2722, align 8
  %1159 = load ptr, ptr @__clewEnqueueNDRangeKernel, align 8
  %m_commandQueue.i.i2723 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1511, i64 0, i32 1
  %1160 = load ptr, ptr %m_commandQueue.i.i2723, align 8
  %1161 = load ptr, ptr %m_kernel.i2667, align 8
  %call32.i.i2729 = invoke i32 %1159(ptr noundef %1160, ptr noundef %1161, i32 noundef 2, ptr noundef null, ptr noundef nonnull %gRange.i.i2711, ptr noundef nonnull %lRange.i.i2712, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call32.i.i.noexc2728 unwind label %lpad1515

call32.i.i.noexc2728:                             ; preds = %invoke.cont1518
  %cmp.not.i.i2725 = icmp eq i32 %call32.i.i2729, 0
  br i1 %cmp.not.i.i2725, label %invoke.cont1520, label %if.then.i.i2726

if.then.i.i2726:                                  ; preds = %call32.i.i.noexc2728
  %call33.i.i2727 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.74, i32 noundef %call32.i.i2729)
  br label %invoke.cont1520

invoke.cont1520:                                  ; preds = %if.then.i.i2726, %call32.i.i.noexc2728
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %gRange.i.i2711)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %lRange.i.i2712)
  %1162 = load ptr, ptr @__clewFinish, align 8
  %1163 = load ptr, ptr %m_queue, align 8
  %call1523 = invoke i32 %1162(ptr noundef %1163)
          to label %invoke.cont1522 unwind label %lpad1515

invoke.cont1522:                                  ; preds = %invoke.cont1520
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1511) #26
  invoke void @b3LeaveProfileZone()
          to label %_ZN13b3ProfileZoneD2Ev.exit2732 unwind label %terminate.lpad.i2731

terminate.lpad.i2731:                             ; preds = %invoke.cont1522
  %1164 = landingpad { ptr, i32 }
          catch ptr null
  %1165 = extractvalue { ptr, i32 } %1164, 0
  call void @__clang_call_terminate(ptr %1165) #27
  unreachable

_ZN13b3ProfileZoneD2Ev.exit2732:                  ; preds = %invoke.cont1522
  invoke void @b3EnterProfileZone(ptr noundef nonnull @.str.14)
          to label %invoke.cont1527 unwind label %lpad58

invoke.cont1527:                                  ; preds = %_ZN13b3ProfileZoneD2Ev.exit2732
  %1166 = load ptr, ptr %m_clBuffer.i2615, align 8
  store ptr %1166, ptr %bInfo1528, align 16
  %m_isReadOnly.i2736 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 0, i32 1
  store i8 0, ptr %m_isReadOnly.i2736, align 8
  %arrayinit.element1534 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 1
  %1167 = load ptr, ptr %m_clBuffer.i531, align 8
  store ptr %1167, ptr %arrayinit.element1534, align 16
  %m_isReadOnly.i2738 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 1, i32 1
  store i8 1, ptr %m_isReadOnly.i2738, align 8
  %arrayinit.element1538 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 2
  %1168 = load ptr, ptr %m_clBuffer.i533, align 8
  store ptr %1168, ptr %arrayinit.element1538, align 16
  %m_isReadOnly.i2740 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 2, i32 1
  store i8 1, ptr %m_isReadOnly.i2740, align 8
  %arrayinit.element1542 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 3
  %1169 = load ptr, ptr %m_clBuffer.i535, align 8
  store ptr %1169, ptr %arrayinit.element1542, align 16
  %m_isReadOnly.i2742 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 3, i32 1
  store i8 1, ptr %m_isReadOnly.i2742, align 8
  %arrayinit.element1546 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 4
  %1170 = load ptr, ptr %m_clBuffer.i537, align 8
  store ptr %1170, ptr %arrayinit.element1546, align 16
  %m_isReadOnly.i2744 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 4, i32 1
  store i8 1, ptr %m_isReadOnly.i2744, align 8
  %arrayinit.element1550 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 5
  %1171 = load ptr, ptr %m_clBuffer.i539, align 8
  store ptr %1171, ptr %arrayinit.element1550, align 16
  %m_isReadOnly.i2746 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 5, i32 1
  store i8 1, ptr %m_isReadOnly.i2746, align 8
  %arrayinit.element1554 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 6
  %1172 = load ptr, ptr %m_clBuffer.i541, align 8
  store ptr %1172, ptr %arrayinit.element1554, align 16
  %m_isReadOnly.i2748 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 6, i32 1
  store i8 1, ptr %m_isReadOnly.i2748, align 8
  %arrayinit.element1558 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 7
  %1173 = load ptr, ptr %m_clBuffer.i543, align 8
  store ptr %1173, ptr %arrayinit.element1558, align 16
  %m_isReadOnly.i2750 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 7, i32 1
  store i8 1, ptr %m_isReadOnly.i2750, align 8
  %arrayinit.element1562 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 8
  %1174 = load ptr, ptr %m_clBuffer.i1868, align 8
  store ptr %1174, ptr %arrayinit.element1562, align 16
  %m_isReadOnly.i2752 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 8, i32 1
  store i8 1, ptr %m_isReadOnly.i2752, align 8
  %arrayinit.element1566 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 9
  %1175 = load ptr, ptr %m_clBuffer.i2633, align 8
  store ptr %1175, ptr %arrayinit.element1566, align 16
  %m_isReadOnly.i2754 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 9, i32 1
  store i8 1, ptr %m_isReadOnly.i2754, align 8
  %arrayinit.element1570 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 10
  %1176 = load ptr, ptr %m_clBuffer.i2635, align 8
  store ptr %1176, ptr %arrayinit.element1570, align 16
  %m_isReadOnly.i2756 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 10, i32 1
  store i8 0, ptr %m_isReadOnly.i2756, align 8
  %arrayinit.element1575 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 11
  %1177 = load ptr, ptr %m_clBuffer.i2637, align 8
  store ptr %1177, ptr %arrayinit.element1575, align 16
  %m_isReadOnly.i2758 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 11, i32 1
  store i8 0, ptr %m_isReadOnly.i2758, align 8
  %arrayinit.element1580 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 12
  %1178 = load ptr, ptr %m_clBuffer.i2639, align 8
  store ptr %1178, ptr %arrayinit.element1580, align 16
  %m_isReadOnly.i2760 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 12, i32 1
  store i8 0, ptr %m_isReadOnly.i2760, align 8
  %arrayinit.element1584 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 13
  %1179 = load ptr, ptr %m_clBuffer.i2641, align 8
  store ptr %1179, ptr %arrayinit.element1584, align 16
  %m_isReadOnly.i2762 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 13, i32 1
  store i8 0, ptr %m_isReadOnly.i2762, align 8
  %arrayinit.element1588 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 14
  %1180 = load ptr, ptr %m_clBuffer.i2643, align 8
  store ptr %1180, ptr %arrayinit.element1588, align 16
  %m_isReadOnly.i2764 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 14, i32 1
  store i8 0, ptr %m_isReadOnly.i2764, align 8
  %arrayinit.element1592 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 15
  %1181 = load ptr, ptr %m_clBuffer.i2645, align 8
  store ptr %1181, ptr %arrayinit.element1592, align 16
  %m_isReadOnly.i2766 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 15, i32 1
  store i8 0, ptr %m_isReadOnly.i2766, align 8
  %arrayinit.element1596 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 16
  %1182 = load ptr, ptr %m_clBuffer.i2647, align 8
  store ptr %1182, ptr %arrayinit.element1596, align 16
  %m_isReadOnly.i2768 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1528, i64 16, i32 1
  store i8 0, ptr %m_isReadOnly.i2768, align 8
  %1183 = load ptr, ptr %m_queue, align 8
  %m_findConcaveSeparatingAxisEdgeEdgeKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 11
  %1184 = load ptr, ptr %m_findConcaveSeparatingAxisEdgeEdgeKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher1601, ptr noundef %1183, ptr noundef %1184, ptr noundef nonnull @.str.55)
          to label %invoke.cont1603 unwind label %lpad1530

invoke.cont1603:                                  ; preds = %invoke.cont1527
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher1601, ptr noundef nonnull %bInfo1528, i32 noundef 17)
          to label %invoke.cont1606 unwind label %lpad1605

invoke.cont1606:                                  ; preds = %invoke.cont1603
  %m_enableSerialization.i2769 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1601, i64 0, i32 7
  %1185 = load i8, ptr %m_enableSerialization.i2769, align 4
  %1186 = and i8 %1185, 1
  %tobool.not.i2770 = icmp eq i8 %1186, 0
  br i1 %tobool.not.i2770, label %if.end.i2786, label %if.then.i2771

if.then.i2771:                                    ; preds = %invoke.cont1606
  %m_idx.i2772 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1601, i64 0, i32 3
  %1187 = load i32, ptr %m_idx.i2772, align 8
  %1188 = load i32, ptr %vertexFaceCapacity, align 4
  %m_size.i.i.i2773 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1601, i64 0, i32 5, i32 2
  %1189 = load i32, ptr %m_size.i.i.i2773, align 4
  %m_capacity.i.i.i2774 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1601, i64 0, i32 5, i32 3
  %1190 = load i32, ptr %m_capacity.i.i.i2774, align 8
  %cmp.i.i2775 = icmp eq i32 %1189, %1190
  br i1 %cmp.i.i2775, label %if.then.i.i2791, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2776

if.then.i.i2791:                                  ; preds = %if.then.i2771
  %m_kernelArguments.i2792 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1601, i64 0, i32 5
  %tobool.not.i.i.i2793 = icmp eq i32 %1189, 0
  %mul.i.i.i2794 = shl nsw i32 %1189, 1
  %cond.i.i.i2795 = select i1 %tobool.not.i.i.i2793, i32 1, i32 %mul.i.i.i2794
  invoke void @_ZN20b3AlignedObjectArrayI15b3KernelArgDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %m_kernelArguments.i2792, i32 noundef %cond.i.i.i2795)
          to label %.noexc2797 unwind label %lpad1605

.noexc2797:                                       ; preds = %if.then.i.i2791
  %.pre.i.i2796 = load i32, ptr %m_size.i.i.i2773, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2776

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2776: ; preds = %.noexc2797, %if.then.i2771
  %1191 = phi i32 [ %.pre.i.i2796, %.noexc2797 ], [ %1189, %if.then.i2771 ]
  %m_data.i.i2777 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1601, i64 0, i32 5, i32 5
  %1192 = load ptr, ptr %m_data.i.i2777, align 8
  %idxprom.i.i2778 = sext i32 %1191 to i64
  %arrayidx.i.i2779 = getelementptr inbounds %struct.b3KernelArgData, ptr %1192, i64 %idxprom.i.i2778
  store i32 0, ptr %arrayidx.i.i2779, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i2780 = getelementptr inbounds i8, ptr %arrayidx.i.i2779, i64 4
  store i32 %1187, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i2780, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i2781 = getelementptr inbounds i8, ptr %arrayidx.i.i2779, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i2781, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i2782 = getelementptr inbounds i8, ptr %arrayidx.i.i2779, i64 16
  store i32 %1188, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i2782, align 16
  %1193 = load i32, ptr %m_size.i.i.i2773, align 4
  %inc.i.i2783 = add nsw i32 %1193, 1
  store i32 %inc.i.i2783, ptr %m_size.i.i.i2773, align 4
  %m_serializationSizeInBytes.i2784 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1601, i64 0, i32 6
  %1194 = load i32, ptr %m_serializationSizeInBytes.i2784, align 8
  %add.i2785 = add i32 %1194, 32
  store i32 %add.i2785, ptr %m_serializationSizeInBytes.i2784, align 8
  br label %if.end.i2786

if.end.i2786:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2776, %invoke.cont1606
  %1195 = load ptr, ptr @__clewSetKernelArg, align 8
  %m_kernel.i2787 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1601, i64 0, i32 2
  %1196 = load ptr, ptr %m_kernel.i2787, align 8
  %m_idx3.i2788 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1601, i64 0, i32 3
  %1197 = load i32, ptr %m_idx3.i2788, align 8
  %inc.i2789 = add nsw i32 %1197, 1
  store i32 %inc.i2789, ptr %m_idx3.i2788, align 8
  %call.i27902798 = invoke i32 %1195(ptr noundef %1196, i32 noundef %1197, i64 noundef 4, ptr noundef nonnull %vertexFaceCapacity)
          to label %invoke.cont1607 unwind label %lpad1605

invoke.cont1607:                                  ; preds = %if.end.i2786
  %1198 = load i8, ptr %m_enableSerialization.i2769, align 4
  %1199 = and i8 %1198, 1
  %tobool.not.i2801 = icmp eq i8 %1199, 0
  br i1 %tobool.not.i2801, label %if.end.i2817, label %if.then.i2802

if.then.i2802:                                    ; preds = %invoke.cont1607
  %1200 = load i32, ptr %m_idx3.i2788, align 8
  %1201 = load i32, ptr %numConcavePairs, align 4
  %m_size.i.i.i2804 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1601, i64 0, i32 5, i32 2
  %1202 = load i32, ptr %m_size.i.i.i2804, align 4
  %m_capacity.i.i.i2805 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1601, i64 0, i32 5, i32 3
  %1203 = load i32, ptr %m_capacity.i.i.i2805, align 8
  %cmp.i.i2806 = icmp eq i32 %1202, %1203
  br i1 %cmp.i.i2806, label %if.then.i.i2822, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2807

if.then.i.i2822:                                  ; preds = %if.then.i2802
  %m_kernelArguments.i2823 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1601, i64 0, i32 5
  %tobool.not.i.i.i2824 = icmp eq i32 %1202, 0
  %mul.i.i.i2825 = shl nsw i32 %1202, 1
  %cond.i.i.i2826 = select i1 %tobool.not.i.i.i2824, i32 1, i32 %mul.i.i.i2825
  invoke void @_ZN20b3AlignedObjectArrayI15b3KernelArgDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %m_kernelArguments.i2823, i32 noundef %cond.i.i.i2826)
          to label %.noexc2828 unwind label %lpad1605

.noexc2828:                                       ; preds = %if.then.i.i2822
  %.pre.i.i2827 = load i32, ptr %m_size.i.i.i2804, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2807

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2807: ; preds = %.noexc2828, %if.then.i2802
  %1204 = phi i32 [ %.pre.i.i2827, %.noexc2828 ], [ %1202, %if.then.i2802 ]
  %m_data.i.i2808 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1601, i64 0, i32 5, i32 5
  %1205 = load ptr, ptr %m_data.i.i2808, align 8
  %idxprom.i.i2809 = sext i32 %1204 to i64
  %arrayidx.i.i2810 = getelementptr inbounds %struct.b3KernelArgData, ptr %1205, i64 %idxprom.i.i2809
  store i32 0, ptr %arrayidx.i.i2810, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i2811 = getelementptr inbounds i8, ptr %arrayidx.i.i2810, i64 4
  store i32 %1200, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i2811, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i2812 = getelementptr inbounds i8, ptr %arrayidx.i.i2810, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i2812, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i2813 = getelementptr inbounds i8, ptr %arrayidx.i.i2810, i64 16
  store i32 %1201, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i2813, align 16
  %1206 = load i32, ptr %m_size.i.i.i2804, align 4
  %inc.i.i2814 = add nsw i32 %1206, 1
  store i32 %inc.i.i2814, ptr %m_size.i.i.i2804, align 4
  %m_serializationSizeInBytes.i2815 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1601, i64 0, i32 6
  %1207 = load i32, ptr %m_serializationSizeInBytes.i2815, align 8
  %add.i2816 = add i32 %1207, 32
  store i32 %add.i2816, ptr %m_serializationSizeInBytes.i2815, align 8
  br label %if.end.i2817

if.end.i2817:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2807, %invoke.cont1607
  %1208 = load ptr, ptr @__clewSetKernelArg, align 8
  %1209 = load ptr, ptr %m_kernel.i2787, align 8
  %1210 = load i32, ptr %m_idx3.i2788, align 8
  %inc.i2820 = add nsw i32 %1210, 1
  store i32 %inc.i2820, ptr %m_idx3.i2788, align 8
  %call.i28212829 = invoke i32 %1208(ptr noundef %1209, i32 noundef %1210, i64 noundef 4, ptr noundef nonnull %numConcavePairs)
          to label %invoke.cont1608 unwind label %lpad1605

invoke.cont1608:                                  ; preds = %if.end.i2817
  %1211 = load i32, ptr %numConcavePairs, align 4
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %gRange.i.i2831)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %lRange.i.i2832)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %gRange.i.i2831, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %lRange.i.i2832, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  store i64 64, ptr %lRange.i.i2832, align 16
  %arrayidx3.i.i2833 = getelementptr inbounds [3 x i64], ptr %lRange.i.i2832, i64 0, i64 1
  store i64 1, ptr %arrayidx3.i.i2833, align 8
  %conv5.i.i2834 = sext i32 %1211 to i64
  %div.i.i28356127 = lshr i64 %conv5.i.i2834, 6
  %rem.i.i2836 = and i64 %conv5.i.i2834, 63
  %tobool.not.i.i2837 = icmp ne i64 %rem.i.i2836, 0
  %conv9.i.i2838 = zext i1 %tobool.not.i.i2837 to i64
  %add.i.i2839 = add nuw nsw i64 %div.i.i28356127, %conv9.i.i2838
  %.sroa.speculated8.i.i2840 = call i64 @llvm.umax.i64(i64 %add.i.i2839, i64 1)
  %mul.i.i2841 = shl i64 %.sroa.speculated8.i.i2840, 6
  store i64 %mul.i.i2841, ptr %gRange.i.i2831, align 16
  %arrayidx27.i.i2842 = getelementptr inbounds [3 x i64], ptr %gRange.i.i2831, i64 0, i64 1
  store i64 1, ptr %arrayidx27.i.i2842, align 8
  %1212 = load ptr, ptr @__clewEnqueueNDRangeKernel, align 8
  %m_commandQueue.i.i2843 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1601, i64 0, i32 1
  %1213 = load ptr, ptr %m_commandQueue.i.i2843, align 8
  %1214 = load ptr, ptr %m_kernel.i2787, align 8
  %call32.i.i2849 = invoke i32 %1212(ptr noundef %1213, ptr noundef %1214, i32 noundef 2, ptr noundef null, ptr noundef nonnull %gRange.i.i2831, ptr noundef nonnull %lRange.i.i2832, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call32.i.i.noexc2848 unwind label %lpad1605

call32.i.i.noexc2848:                             ; preds = %invoke.cont1608
  %cmp.not.i.i2845 = icmp eq i32 %call32.i.i2849, 0
  br i1 %cmp.not.i.i2845, label %invoke.cont1610, label %if.then.i.i2846

if.then.i.i2846:                                  ; preds = %call32.i.i.noexc2848
  %call33.i.i2847 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.74, i32 noundef %call32.i.i2849)
  br label %invoke.cont1610

invoke.cont1610:                                  ; preds = %if.then.i.i2846, %call32.i.i.noexc2848
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %gRange.i.i2831)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %lRange.i.i2832)
  %1215 = load ptr, ptr @__clewFinish, align 8
  %1216 = load ptr, ptr %m_queue, align 8
  %call1613 = invoke i32 %1215(ptr noundef %1216)
          to label %invoke.cont1612 unwind label %lpad1605

invoke.cont1612:                                  ; preds = %invoke.cont1610
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1601) #26
  invoke void @b3LeaveProfileZone()
          to label %if.end1853 unwind label %terminate.lpad.i2851

terminate.lpad.i2851:                             ; preds = %invoke.cont1612
  %1217 = landingpad { ptr, i32 }
          catch ptr null
  %1218 = extractvalue { ptr, i32 } %1217, 0
  call void @__clang_call_terminate(ptr %1218) #27
  unreachable

lpad1440:                                         ; preds = %invoke.cont1437
  %1219 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup1525

lpad1515:                                         ; preds = %invoke.cont1518, %if.end.i2697, %if.then.i.i2702, %if.end.i2666, %if.then.i.i2671, %invoke.cont1520, %invoke.cont1513
  %1220 = landingpad { ptr, i32 }
          cleanup
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1511) #26
  br label %ehcleanup1525

ehcleanup1525:                                    ; preds = %lpad1515, %lpad1440
  %.pn502 = phi { ptr, i32 } [ %1220, %lpad1515 ], [ %1219, %lpad1440 ]
  invoke void @b3LeaveProfileZone()
          to label %ehcleanup2980 unwind label %terminate.lpad.i2853

terminate.lpad.i2853:                             ; preds = %ehcleanup1525
  %1221 = landingpad { ptr, i32 }
          catch ptr null
  %1222 = extractvalue { ptr, i32 } %1221, 0
  call void @__clang_call_terminate(ptr %1222) #27
  unreachable

lpad1530:                                         ; preds = %invoke.cont1527
  %1223 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup1615

lpad1605:                                         ; preds = %invoke.cont1608, %if.end.i2817, %if.then.i.i2822, %if.end.i2786, %if.then.i.i2791, %invoke.cont1610, %invoke.cont1603
  %1224 = landingpad { ptr, i32 }
          cleanup
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1601) #26
  br label %ehcleanup1615

ehcleanup1615:                                    ; preds = %lpad1605, %lpad1530
  %.pn504 = phi { ptr, i32 } [ %1224, %lpad1605 ], [ %1223, %lpad1530 ]
  invoke void @b3LeaveProfileZone()
          to label %ehcleanup2980 unwind label %terminate.lpad.i2855

terminate.lpad.i2855:                             ; preds = %ehcleanup1615
  %1225 = landingpad { ptr, i32 }
          catch ptr null
  %1226 = extractvalue { ptr, i32 } %1225, 0
  call void @__clang_call_terminate(ptr %1226) #27
  unreachable

if.else1616:                                      ; preds = %if.then1429
  invoke void @b3EnterProfileZone(ptr noundef nonnull @.str.12)
          to label %invoke.cont1618 unwind label %lpad58

invoke.cont1618:                                  ; preds = %if.else1616
  %m_clBuffer.i2859 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %triangleConvexPairsOut, i64 0, i32 3
  %1227 = load ptr, ptr %m_clBuffer.i2859, align 8
  store ptr %1227, ptr %bInfo1619, align 16
  %m_isReadOnly.i2860 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 0, i32 1
  store i8 0, ptr %m_isReadOnly.i2860, align 8
  %arrayinit.element1625 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 1
  %1228 = load ptr, ptr %m_clBuffer.i531, align 8
  store ptr %1228, ptr %arrayinit.element1625, align 16
  %m_isReadOnly.i2862 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 1, i32 1
  store i8 1, ptr %m_isReadOnly.i2862, align 8
  %arrayinit.element1629 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 2
  %1229 = load ptr, ptr %m_clBuffer.i533, align 8
  store ptr %1229, ptr %arrayinit.element1629, align 16
  %m_isReadOnly.i2864 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 2, i32 1
  store i8 1, ptr %m_isReadOnly.i2864, align 8
  %arrayinit.element1633 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 3
  %1230 = load ptr, ptr %m_clBuffer.i535, align 8
  store ptr %1230, ptr %arrayinit.element1633, align 16
  %m_isReadOnly.i2866 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 3, i32 1
  store i8 1, ptr %m_isReadOnly.i2866, align 8
  %arrayinit.element1637 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 4
  %1231 = load ptr, ptr %m_clBuffer.i537, align 8
  store ptr %1231, ptr %arrayinit.element1637, align 16
  %m_isReadOnly.i2868 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 4, i32 1
  store i8 1, ptr %m_isReadOnly.i2868, align 8
  %arrayinit.element1641 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 5
  %1232 = load ptr, ptr %m_clBuffer.i539, align 8
  store ptr %1232, ptr %arrayinit.element1641, align 16
  %m_isReadOnly.i2870 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 5, i32 1
  store i8 1, ptr %m_isReadOnly.i2870, align 8
  %arrayinit.element1645 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 6
  %1233 = load ptr, ptr %m_clBuffer.i541, align 8
  store ptr %1233, ptr %arrayinit.element1645, align 16
  %m_isReadOnly.i2872 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 6, i32 1
  store i8 1, ptr %m_isReadOnly.i2872, align 8
  %arrayinit.element1649 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 7
  %1234 = load ptr, ptr %m_clBuffer.i543, align 8
  store ptr %1234, ptr %arrayinit.element1649, align 16
  %m_isReadOnly.i2874 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 7, i32 1
  store i8 1, ptr %m_isReadOnly.i2874, align 8
  %arrayinit.element1653 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 8
  %1235 = load ptr, ptr %m_clBuffer.i1868, align 8
  store ptr %1235, ptr %arrayinit.element1653, align 16
  %m_isReadOnly.i2876 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 8, i32 1
  store i8 1, ptr %m_isReadOnly.i2876, align 8
  %arrayinit.element1657 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 9
  %m_clBuffer.i2877 = getelementptr inbounds %class.b3OpenCLArray.90, ptr %clAabbsWorldSpace, i64 0, i32 3
  %1236 = load ptr, ptr %m_clBuffer.i2877, align 8
  store ptr %1236, ptr %arrayinit.element1657, align 16
  %m_isReadOnly.i2878 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 9, i32 1
  store i8 1, ptr %m_isReadOnly.i2878, align 8
  %arrayinit.element1661 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 10
  %m_clBuffer.i2879 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 29, i32 3
  %1237 = load ptr, ptr %m_clBuffer.i2879, align 8
  store ptr %1237, ptr %arrayinit.element1661, align 16
  %m_isReadOnly.i2880 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 10, i32 1
  store i8 0, ptr %m_isReadOnly.i2880, align 8
  %arrayinit.element1666 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 11
  %m_clBuffer.i2881 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 30, i32 3
  %1238 = load ptr, ptr %m_clBuffer.i2881, align 8
  store ptr %1238, ptr %arrayinit.element1666, align 16
  %m_isReadOnly.i2882 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 11, i32 1
  store i8 0, ptr %m_isReadOnly.i2882, align 8
  %arrayinit.element1671 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 12
  %m_clBuffer.i2883 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %clippingFacesOutGPU, i64 0, i32 3
  %1239 = load ptr, ptr %m_clBuffer.i2883, align 8
  store ptr %1239, ptr %arrayinit.element1671, align 16
  %m_isReadOnly.i2884 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 12, i32 1
  store i8 0, ptr %m_isReadOnly.i2884, align 8
  %arrayinit.element1675 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 13
  %m_clBuffer.i2885 = getelementptr inbounds %class.b3OpenCLArray, ptr %worldVertsA1GPU, i64 0, i32 3
  %1240 = load ptr, ptr %m_clBuffer.i2885, align 8
  store ptr %1240, ptr %arrayinit.element1675, align 16
  %m_isReadOnly.i2886 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 13, i32 1
  store i8 0, ptr %m_isReadOnly.i2886, align 8
  %arrayinit.element1679 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 14
  %m_clBuffer.i2887 = getelementptr inbounds %class.b3OpenCLArray, ptr %worldNormalsAGPU, i64 0, i32 3
  %1241 = load ptr, ptr %m_clBuffer.i2887, align 8
  store ptr %1241, ptr %arrayinit.element1679, align 16
  %m_isReadOnly.i2888 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 14, i32 1
  store i8 0, ptr %m_isReadOnly.i2888, align 8
  %arrayinit.element1683 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 15
  %m_clBuffer.i2889 = getelementptr inbounds %class.b3OpenCLArray, ptr %worldVertsB1GPU, i64 0, i32 3
  %1242 = load ptr, ptr %m_clBuffer.i2889, align 8
  store ptr %1242, ptr %arrayinit.element1683, align 16
  %m_isReadOnly.i2890 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1619, i64 15, i32 1
  store i8 0, ptr %m_isReadOnly.i2890, align 8
  %1243 = load ptr, ptr %m_queue, align 8
  %m_findConcaveSeparatingAxisKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 9
  %1244 = load ptr, ptr %m_findConcaveSeparatingAxisKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher1687, ptr noundef %1243, ptr noundef %1244, ptr noundef nonnull @.str.56)
          to label %invoke.cont1689 unwind label %lpad1621

invoke.cont1689:                                  ; preds = %invoke.cont1618
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher1687, ptr noundef nonnull %bInfo1619, i32 noundef 16)
          to label %invoke.cont1692 unwind label %lpad1691

invoke.cont1692:                                  ; preds = %invoke.cont1689
  %m_enableSerialization.i2891 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1687, i64 0, i32 7
  %1245 = load i8, ptr %m_enableSerialization.i2891, align 4
  %1246 = and i8 %1245, 1
  %tobool.not.i2892 = icmp eq i8 %1246, 0
  br i1 %tobool.not.i2892, label %if.end.i2908, label %if.then.i2893

if.then.i2893:                                    ; preds = %invoke.cont1692
  %m_idx.i2894 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1687, i64 0, i32 3
  %1247 = load i32, ptr %m_idx.i2894, align 8
  %1248 = load i32, ptr %vertexFaceCapacity, align 4
  %m_size.i.i.i2895 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1687, i64 0, i32 5, i32 2
  %1249 = load i32, ptr %m_size.i.i.i2895, align 4
  %m_capacity.i.i.i2896 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1687, i64 0, i32 5, i32 3
  %1250 = load i32, ptr %m_capacity.i.i.i2896, align 8
  %cmp.i.i2897 = icmp eq i32 %1249, %1250
  br i1 %cmp.i.i2897, label %if.then.i.i2913, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2898

if.then.i.i2913:                                  ; preds = %if.then.i2893
  %m_kernelArguments.i2914 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1687, i64 0, i32 5
  %tobool.not.i.i.i2915 = icmp eq i32 %1249, 0
  %mul.i.i.i2916 = shl nsw i32 %1249, 1
  %cond.i.i.i2917 = select i1 %tobool.not.i.i.i2915, i32 1, i32 %mul.i.i.i2916
  invoke void @_ZN20b3AlignedObjectArrayI15b3KernelArgDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %m_kernelArguments.i2914, i32 noundef %cond.i.i.i2917)
          to label %.noexc2919 unwind label %lpad1691

.noexc2919:                                       ; preds = %if.then.i.i2913
  %.pre.i.i2918 = load i32, ptr %m_size.i.i.i2895, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2898

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2898: ; preds = %.noexc2919, %if.then.i2893
  %1251 = phi i32 [ %.pre.i.i2918, %.noexc2919 ], [ %1249, %if.then.i2893 ]
  %m_data.i.i2899 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1687, i64 0, i32 5, i32 5
  %1252 = load ptr, ptr %m_data.i.i2899, align 8
  %idxprom.i.i2900 = sext i32 %1251 to i64
  %arrayidx.i.i2901 = getelementptr inbounds %struct.b3KernelArgData, ptr %1252, i64 %idxprom.i.i2900
  store i32 0, ptr %arrayidx.i.i2901, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i2902 = getelementptr inbounds i8, ptr %arrayidx.i.i2901, i64 4
  store i32 %1247, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i2902, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i2903 = getelementptr inbounds i8, ptr %arrayidx.i.i2901, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i2903, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i2904 = getelementptr inbounds i8, ptr %arrayidx.i.i2901, i64 16
  store i32 %1248, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i2904, align 16
  %1253 = load i32, ptr %m_size.i.i.i2895, align 4
  %inc.i.i2905 = add nsw i32 %1253, 1
  store i32 %inc.i.i2905, ptr %m_size.i.i.i2895, align 4
  %m_serializationSizeInBytes.i2906 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1687, i64 0, i32 6
  %1254 = load i32, ptr %m_serializationSizeInBytes.i2906, align 8
  %add.i2907 = add i32 %1254, 32
  store i32 %add.i2907, ptr %m_serializationSizeInBytes.i2906, align 8
  br label %if.end.i2908

if.end.i2908:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2898, %invoke.cont1692
  %1255 = load ptr, ptr @__clewSetKernelArg, align 8
  %m_kernel.i2909 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1687, i64 0, i32 2
  %1256 = load ptr, ptr %m_kernel.i2909, align 8
  %m_idx3.i2910 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1687, i64 0, i32 3
  %1257 = load i32, ptr %m_idx3.i2910, align 8
  %inc.i2911 = add nsw i32 %1257, 1
  store i32 %inc.i2911, ptr %m_idx3.i2910, align 8
  %call.i29122920 = invoke i32 %1255(ptr noundef %1256, i32 noundef %1257, i64 noundef 4, ptr noundef nonnull %vertexFaceCapacity)
          to label %invoke.cont1693 unwind label %lpad1691

invoke.cont1693:                                  ; preds = %if.end.i2908
  %1258 = load i8, ptr %m_enableSerialization.i2891, align 4
  %1259 = and i8 %1258, 1
  %tobool.not.i2923 = icmp eq i8 %1259, 0
  br i1 %tobool.not.i2923, label %if.end.i2939, label %if.then.i2924

if.then.i2924:                                    ; preds = %invoke.cont1693
  %1260 = load i32, ptr %m_idx3.i2910, align 8
  %1261 = load i32, ptr %numConcavePairs, align 4
  %m_size.i.i.i2926 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1687, i64 0, i32 5, i32 2
  %1262 = load i32, ptr %m_size.i.i.i2926, align 4
  %m_capacity.i.i.i2927 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1687, i64 0, i32 5, i32 3
  %1263 = load i32, ptr %m_capacity.i.i.i2927, align 8
  %cmp.i.i2928 = icmp eq i32 %1262, %1263
  br i1 %cmp.i.i2928, label %if.then.i.i2944, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2929

if.then.i.i2944:                                  ; preds = %if.then.i2924
  %m_kernelArguments.i2945 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1687, i64 0, i32 5
  %tobool.not.i.i.i2946 = icmp eq i32 %1262, 0
  %mul.i.i.i2947 = shl nsw i32 %1262, 1
  %cond.i.i.i2948 = select i1 %tobool.not.i.i.i2946, i32 1, i32 %mul.i.i.i2947
  invoke void @_ZN20b3AlignedObjectArrayI15b3KernelArgDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %m_kernelArguments.i2945, i32 noundef %cond.i.i.i2948)
          to label %.noexc2950 unwind label %lpad1691

.noexc2950:                                       ; preds = %if.then.i.i2944
  %.pre.i.i2949 = load i32, ptr %m_size.i.i.i2926, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2929

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2929: ; preds = %.noexc2950, %if.then.i2924
  %1264 = phi i32 [ %.pre.i.i2949, %.noexc2950 ], [ %1262, %if.then.i2924 ]
  %m_data.i.i2930 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1687, i64 0, i32 5, i32 5
  %1265 = load ptr, ptr %m_data.i.i2930, align 8
  %idxprom.i.i2931 = sext i32 %1264 to i64
  %arrayidx.i.i2932 = getelementptr inbounds %struct.b3KernelArgData, ptr %1265, i64 %idxprom.i.i2931
  store i32 0, ptr %arrayidx.i.i2932, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i2933 = getelementptr inbounds i8, ptr %arrayidx.i.i2932, i64 4
  store i32 %1260, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i2933, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i2934 = getelementptr inbounds i8, ptr %arrayidx.i.i2932, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i2934, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i2935 = getelementptr inbounds i8, ptr %arrayidx.i.i2932, i64 16
  store i32 %1261, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i2935, align 16
  %1266 = load i32, ptr %m_size.i.i.i2926, align 4
  %inc.i.i2936 = add nsw i32 %1266, 1
  store i32 %inc.i.i2936, ptr %m_size.i.i.i2926, align 4
  %m_serializationSizeInBytes.i2937 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1687, i64 0, i32 6
  %1267 = load i32, ptr %m_serializationSizeInBytes.i2937, align 8
  %add.i2938 = add i32 %1267, 32
  store i32 %add.i2938, ptr %m_serializationSizeInBytes.i2937, align 8
  br label %if.end.i2939

if.end.i2939:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i2929, %invoke.cont1693
  %1268 = load ptr, ptr @__clewSetKernelArg, align 8
  %1269 = load ptr, ptr %m_kernel.i2909, align 8
  %1270 = load i32, ptr %m_idx3.i2910, align 8
  %inc.i2942 = add nsw i32 %1270, 1
  store i32 %inc.i2942, ptr %m_idx3.i2910, align 8
  %call.i29432951 = invoke i32 %1268(ptr noundef %1269, i32 noundef %1270, i64 noundef 4, ptr noundef nonnull %numConcavePairs)
          to label %invoke.cont1694 unwind label %lpad1691

invoke.cont1694:                                  ; preds = %if.end.i2939
  %1271 = load i32, ptr %numConcavePairs, align 4
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %gRange.i.i2953)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %lRange.i.i2954)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %gRange.i.i2953, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %lRange.i.i2954, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  store i64 64, ptr %lRange.i.i2954, align 16
  %arrayidx3.i.i2955 = getelementptr inbounds [3 x i64], ptr %lRange.i.i2954, i64 0, i64 1
  store i64 1, ptr %arrayidx3.i.i2955, align 8
  %conv5.i.i2956 = sext i32 %1271 to i64
  %div.i.i29576128 = lshr i64 %conv5.i.i2956, 6
  %rem.i.i2958 = and i64 %conv5.i.i2956, 63
  %tobool.not.i.i2959 = icmp ne i64 %rem.i.i2958, 0
  %conv9.i.i2960 = zext i1 %tobool.not.i.i2959 to i64
  %add.i.i2961 = add nuw nsw i64 %div.i.i29576128, %conv9.i.i2960
  %.sroa.speculated8.i.i2962 = call i64 @llvm.umax.i64(i64 %add.i.i2961, i64 1)
  %mul.i.i2963 = shl i64 %.sroa.speculated8.i.i2962, 6
  store i64 %mul.i.i2963, ptr %gRange.i.i2953, align 16
  %arrayidx27.i.i2964 = getelementptr inbounds [3 x i64], ptr %gRange.i.i2953, i64 0, i64 1
  store i64 1, ptr %arrayidx27.i.i2964, align 8
  %1272 = load ptr, ptr @__clewEnqueueNDRangeKernel, align 8
  %m_commandQueue.i.i2965 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1687, i64 0, i32 1
  %1273 = load ptr, ptr %m_commandQueue.i.i2965, align 8
  %1274 = load ptr, ptr %m_kernel.i2909, align 8
  %call32.i.i2971 = invoke i32 %1272(ptr noundef %1273, ptr noundef %1274, i32 noundef 2, ptr noundef null, ptr noundef nonnull %gRange.i.i2953, ptr noundef nonnull %lRange.i.i2954, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call32.i.i.noexc2970 unwind label %lpad1691

call32.i.i.noexc2970:                             ; preds = %invoke.cont1694
  %cmp.not.i.i2967 = icmp eq i32 %call32.i.i2971, 0
  br i1 %cmp.not.i.i2967, label %invoke.cont1696, label %if.then.i.i2968

if.then.i.i2968:                                  ; preds = %call32.i.i.noexc2970
  %call33.i.i2969 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.74, i32 noundef %call32.i.i2971)
  br label %invoke.cont1696

invoke.cont1696:                                  ; preds = %if.then.i.i2968, %call32.i.i.noexc2970
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %gRange.i.i2953)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %lRange.i.i2954)
  %1275 = load ptr, ptr @__clewFinish, align 8
  %1276 = load ptr, ptr %m_queue, align 8
  %call1699 = invoke i32 %1275(ptr noundef %1276)
          to label %invoke.cont1698 unwind label %lpad1691

invoke.cont1698:                                  ; preds = %invoke.cont1696
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1687) #26
  invoke void @b3LeaveProfileZone()
          to label %if.end1853 unwind label %terminate.lpad.i2973

terminate.lpad.i2973:                             ; preds = %invoke.cont1698
  %1277 = landingpad { ptr, i32 }
          catch ptr null
  %1278 = extractvalue { ptr, i32 } %1277, 0
  call void @__clang_call_terminate(ptr %1278) #27
  unreachable

lpad1621:                                         ; preds = %invoke.cont1618
  %1279 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup1701

lpad1691:                                         ; preds = %invoke.cont1694, %if.end.i2939, %if.then.i.i2944, %if.end.i2908, %if.then.i.i2913, %invoke.cont1696, %invoke.cont1689
  %1280 = landingpad { ptr, i32 }
          cleanup
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1687) #26
  br label %ehcleanup1701

ehcleanup1701:                                    ; preds = %lpad1691, %lpad1621
  %.pn500 = phi { ptr, i32 } [ %1280, %lpad1691 ], [ %1279, %lpad1621 ]
  invoke void @b3LeaveProfileZone()
          to label %ehcleanup2980 unwind label %terminate.lpad.i2975

terminate.lpad.i2975:                             ; preds = %ehcleanup1701
  %1281 = landingpad { ptr, i32 }
          catch ptr null
  %1282 = extractvalue { ptr, i32 } %1281, 0
  call void @__clang_call_terminate(ptr %1282) #27
  unreachable

invoke.cont1715:                                  ; preds = %invoke.cont1426
  %m_ownsMemory.i.i2977 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %clippingFacesOutCPU, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i2977, align 8
  %m_data.i.i2978 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %clippingFacesOutCPU, i64 0, i32 5
  store ptr null, ptr %m_data.i.i2978, align 8
  %m_size.i.i2979 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %clippingFacesOutCPU, i64 0, i32 2
  store i32 0, ptr %m_size.i.i2979, align 4
  %m_capacity.i.i2980 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %clippingFacesOutCPU, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i2980, align 8
  %m_ownsMemory.i.i2981 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldVertsA1CPU, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i2981, align 8
  %m_data.i.i2982 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldVertsA1CPU, i64 0, i32 5
  store ptr null, ptr %m_data.i.i2982, align 8
  %m_size.i.i2983 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldVertsA1CPU, i64 0, i32 2
  store i32 0, ptr %m_size.i.i2983, align 4
  %m_capacity.i.i2984 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldVertsA1CPU, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i2984, align 8
  %m_ownsMemory.i.i2985 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldNormalsACPU, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i2985, align 8
  %m_data.i.i2986 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldNormalsACPU, i64 0, i32 5
  store ptr null, ptr %m_data.i.i2986, align 8
  %m_size.i.i2987 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldNormalsACPU, i64 0, i32 2
  store i32 0, ptr %m_size.i.i2987, align 4
  %m_capacity.i.i2988 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldNormalsACPU, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i2988, align 8
  %m_ownsMemory.i.i2989 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldVertsB1CPU, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i2989, align 8
  %m_data.i.i2990 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldVertsB1CPU, i64 0, i32 5
  store ptr null, ptr %m_data.i.i2990, align 8
  %m_size.i.i2991 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldVertsB1CPU, i64 0, i32 2
  store i32 0, ptr %m_size.i.i2991, align 4
  %m_capacity.i.i2992 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldVertsB1CPU, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i2992, align 8
  %m_ownsMemory.i.i2993 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %concaveHasSeparatingNormalsCPU, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i2993, align 8
  %m_data.i.i2994 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %concaveHasSeparatingNormalsCPU, i64 0, i32 5
  store ptr null, ptr %m_data.i.i2994, align 8
  %m_size.i.i2995 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %concaveHasSeparatingNormalsCPU, i64 0, i32 2
  store i32 0, ptr %m_size.i.i2995, align 4
  %m_capacity.i.i2996 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %concaveHasSeparatingNormalsCPU, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i2996, align 8
  %m_ownsMemory.i.i2997 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %triangleConvexPairsOutHost1713, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i2997, align 8
  %m_data.i.i2998 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %triangleConvexPairsOutHost1713, i64 0, i32 5
  store ptr null, ptr %m_data.i.i2998, align 8
  %m_size.i.i2999 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %triangleConvexPairsOutHost1713, i64 0, i32 2
  store i32 0, ptr %m_size.i.i2999, align 4
  %m_capacity.i.i3000 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %triangleConvexPairsOutHost1713, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i3000, align 8
  invoke void @_ZNK13b3OpenCLArrayI6b3Int4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %triangleConvexPairsOut, ptr noundef nonnull align 8 dereferenceable(25) %triangleConvexPairsOutHost1713, i1 noundef zeroext true)
          to label %invoke.cont1719 unwind label %lpad1716

invoke.cont1719:                                  ; preds = %invoke.cont1715
  %m_ownsMemory.i.i3001 = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %hostBodyBuf1718, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i3001, align 8
  %m_data.i.i3002 = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %hostBodyBuf1718, i64 0, i32 5
  store ptr null, ptr %m_data.i.i3002, align 8
  %m_size.i.i3003 = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %hostBodyBuf1718, i64 0, i32 2
  store i32 0, ptr %m_size.i.i3003, align 4
  %m_capacity.i.i3004 = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %hostBodyBuf1718, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i3004, align 8
  invoke void @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %bodyBuf, ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf1718, i1 noundef zeroext true)
          to label %invoke.cont1723 unwind label %lpad1720

invoke.cont1723:                                  ; preds = %invoke.cont1719
  %m_ownsMemory.i.i3005 = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %hostCollidables1722, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i3005, align 8
  %m_data.i.i3006 = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %hostCollidables1722, i64 0, i32 5
  store ptr null, ptr %m_data.i.i3006, align 8
  %m_size.i.i3007 = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %hostCollidables1722, i64 0, i32 2
  store i32 0, ptr %m_size.i.i3007, align 4
  %m_capacity.i.i3008 = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %hostCollidables1722, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i3008, align 8
  invoke void @_ZNK13b3OpenCLArrayI12b3CollidableE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %gpuCollidables, ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables1722, i1 noundef zeroext true)
          to label %invoke.cont1727 unwind label %lpad1724

invoke.cont1727:                                  ; preds = %invoke.cont1723
  %m_ownsMemory.i.i3009 = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %hostAabbsWorldSpace1726, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i3009, align 8
  %m_data.i.i3010 = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %hostAabbsWorldSpace1726, i64 0, i32 5
  store ptr null, ptr %m_data.i.i3010, align 8
  %m_size.i.i3011 = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %hostAabbsWorldSpace1726, i64 0, i32 2
  store i32 0, ptr %m_size.i.i3011, align 4
  %m_capacity.i.i3012 = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %hostAabbsWorldSpace1726, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i3012, align 8
  invoke void @_ZNK13b3OpenCLArrayI6b3AabbE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %clAabbsWorldSpace, ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsWorldSpace1726, i1 noundef zeroext true)
          to label %invoke.cont1731 unwind label %lpad1728

invoke.cont1731:                                  ; preds = %invoke.cont1727
  %m_ownsMemory.i.i3013 = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %hostConvexData1730, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i3013, align 8
  %m_data.i.i3014 = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %hostConvexData1730, i64 0, i32 5
  store ptr null, ptr %m_data.i.i3014, align 8
  %m_size.i.i3015 = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %hostConvexData1730, i64 0, i32 2
  store i32 0, ptr %m_size.i.i3015, align 4
  %m_capacity.i.i3016 = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %hostConvexData1730, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i3016, align 8
  invoke void @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %convexData, ptr noundef nonnull align 8 dereferenceable(25) %hostConvexData1730, i1 noundef zeroext true)
          to label %invoke.cont1735 unwind label %lpad1732

invoke.cont1735:                                  ; preds = %invoke.cont1731
  %m_ownsMemory.i.i3017 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %hostVertices1734, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i3017, align 8
  %m_data.i.i3018 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %hostVertices1734, i64 0, i32 5
  store ptr null, ptr %m_data.i.i3018, align 8
  %m_size.i.i3019 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %hostVertices1734, i64 0, i32 2
  store i32 0, ptr %m_size.i.i3019, align 4
  %m_capacity.i.i3020 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %hostVertices1734, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i3020, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %gpuVertices, ptr noundef nonnull align 8 dereferenceable(25) %hostVertices1734, i1 noundef zeroext true)
          to label %invoke.cont1739 unwind label %lpad1736

invoke.cont1739:                                  ; preds = %invoke.cont1735
  %m_ownsMemory.i.i3021 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %hostUniqueEdges1738, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i3021, align 8
  %m_data.i.i3022 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %hostUniqueEdges1738, i64 0, i32 5
  store ptr null, ptr %m_data.i.i3022, align 8
  %m_size.i.i3023 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %hostUniqueEdges1738, i64 0, i32 2
  store i32 0, ptr %m_size.i.i3023, align 4
  %m_capacity.i.i3024 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %hostUniqueEdges1738, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i3024, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %gpuUniqueEdges, ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges1738, i1 noundef zeroext true)
          to label %invoke.cont1743 unwind label %lpad1740

invoke.cont1743:                                  ; preds = %invoke.cont1739
  %m_ownsMemory.i.i3025 = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %hostFaces1742, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i3025, align 8
  %m_data.i.i3026 = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %hostFaces1742, i64 0, i32 5
  store ptr null, ptr %m_data.i.i3026, align 8
  %m_size.i.i3027 = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %hostFaces1742, i64 0, i32 2
  store i32 0, ptr %m_size.i.i3027, align 4
  %m_capacity.i.i3028 = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %hostFaces1742, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i3028, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3GpuFaceE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %gpuFaces, ptr noundef nonnull align 8 dereferenceable(25) %hostFaces1742, i1 noundef zeroext true)
          to label %invoke.cont1747 unwind label %lpad1744

invoke.cont1747:                                  ; preds = %invoke.cont1743
  %m_ownsMemory.i.i3029 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %hostIndices1746, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i3029, align 8
  %m_data.i.i3030 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %hostIndices1746, i64 0, i32 5
  store ptr null, ptr %m_data.i.i3030, align 8
  %m_size.i.i3031 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %hostIndices1746, i64 0, i32 2
  store i32 0, ptr %m_size.i.i3031, align 4
  %m_capacity.i.i3032 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %hostIndices1746, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i3032, align 8
  invoke void @_ZNK13b3OpenCLArrayIiE10copyToHostER20b3AlignedObjectArrayIiEb(ptr noundef nonnull align 8 dereferenceable(50) %gpuIndices, ptr noundef nonnull align 8 dereferenceable(25) %hostIndices1746, i1 noundef zeroext true)
          to label %invoke.cont1751 unwind label %lpad1748

invoke.cont1751:                                  ; preds = %invoke.cont1747
  %m_ownsMemory.i.i3033 = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %cpuChildShapes1750, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i3033, align 8
  %m_data.i.i3034 = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %cpuChildShapes1750, i64 0, i32 5
  store ptr null, ptr %m_data.i.i3034, align 8
  %m_size.i.i3035 = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %cpuChildShapes1750, i64 0, i32 2
  store i32 0, ptr %m_size.i.i3035, align 4
  %m_capacity.i.i3036 = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %cpuChildShapes1750, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i3036, align 8
  invoke void @_ZNK13b3OpenCLArrayI15b3GpuChildShapeE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %gpuChildShapes, ptr noundef nonnull align 8 dereferenceable(25) %cpuChildShapes1750, i1 noundef zeroext true)
          to label %invoke.cont1754 unwind label %lpad1752

invoke.cont1754:                                  ; preds = %invoke.cont1751
  %m_ownsMemory.i.i3037 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %concaveSepNormalsHost, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i3037, align 8
  %m_data.i.i3038 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %concaveSepNormalsHost, i64 0, i32 5
  store ptr null, ptr %m_data.i.i3038, align 8
  %m_size.i.i3039 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %concaveSepNormalsHost, i64 0, i32 2
  store i32 0, ptr %m_size.i.i3039, align 4
  %m_capacity.i.i3040 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %concaveSepNormalsHost, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i3040, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveSepNormals, ptr noundef nonnull align 8 dereferenceable(25) %concaveSepNormalsHost, i1 noundef zeroext true)
          to label %invoke.cont1757 unwind label %lpad1756.loopexit.split-lp

invoke.cont1757:                                  ; preds = %invoke.cont1754
  %1283 = load i32, ptr %m_size.i.i3039, align 4
  %cmp4.i3043 = icmp sgt i32 %1283, 0
  br i1 %cmp4.i3043, label %_ZN20b3AlignedObjectArrayIiE8allocateEi.exit.i5271, label %invoke.cont1761

_ZN20b3AlignedObjectArrayIiE8allocateEi.exit.i5271: ; preds = %invoke.cont1757
  %conv.i.i.i5272 = zext nneg i32 %1283 to i64
  %mul.i.i.i5273 = shl nuw nsw i64 %conv.i.i.i5272, 2
  %call.i.i.i5301 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i5273, i32 noundef 16)
          to label %call.i.i.i.noexc5300 unwind label %lpad1756.loopexit.split-lp

call.i.i.i.noexc5300:                             ; preds = %_ZN20b3AlignedObjectArrayIiE8allocateEi.exit.i5271
  %cmp3.i5274 = icmp eq ptr %call.i.i.i5301, null
  br i1 %cmp3.i5274, label %_ZNK20b3AlignedObjectArrayIiE4copyEiiPi.exit18.i5298, label %.noexc3053

_ZNK20b3AlignedObjectArrayIiE4copyEiiPi.exit18.i5298: ; preds = %call.i.i.i.noexc5300
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc5302 unwind label %lpad1756.loopexit.split-lp

.noexc5302:                                       ; preds = %_ZNK20b3AlignedObjectArrayIiE4copyEiiPi.exit18.i5298
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc5303 unwind label %lpad1756.loopexit.split-lp

.noexc5303:                                       ; preds = %.noexc5302
  store i32 0, ptr %m_size.i.i2995, align 4
  br label %.noexc3053

.noexc3053:                                       ; preds = %call.i.i.i.noexc5300, %.noexc5303
  %_Count.addr.0.i5280 = phi i32 [ 0, %.noexc5303 ], [ %1283, %call.i.i.i.noexc5300 ]
  store i8 1, ptr %m_ownsMemory.i.i2993, align 8
  store ptr %call.i.i.i5301, ptr %m_data.i.i2994, align 8
  store i32 %_Count.addr.0.i5280, ptr %m_capacity.i.i2996, align 8
  %wide.trip.count.i3046 = zext nneg i32 %1283 to i64
  br label %for.body9.i3048

for.body9.i3048:                                  ; preds = %for.body9.i3048, %.noexc3053
  %indvars.iv.i3049 = phi i64 [ 0, %.noexc3053 ], [ %indvars.iv.next.i3051, %for.body9.i3048 ]
  %arrayidx12.i3050 = getelementptr inbounds i32, ptr %call.i.i.i5301, i64 %indvars.iv.i3049
  store i32 0, ptr %arrayidx12.i3050, align 4
  %indvars.iv.next.i3051 = add nuw nsw i64 %indvars.iv.i3049, 1
  %exitcond.not.i3052 = icmp eq i64 %indvars.iv.next.i3051, %wide.trip.count.i3046
  br i1 %exitcond.not.i3052, label %invoke.cont1761.loopexit, label %for.body9.i3048, !llvm.loop !56

invoke.cont1761.loopexit:                         ; preds = %for.body9.i3048
  %.pre6196 = load i32, ptr %m_size.i.i2979, align 4
  br label %invoke.cont1761

invoke.cont1761:                                  ; preds = %invoke.cont1761.loopexit, %invoke.cont1757
  %1284 = phi ptr [ %call.i.i.i5301, %invoke.cont1761.loopexit ], [ null, %invoke.cont1757 ]
  %1285 = phi i32 [ %.pre6196, %invoke.cont1761.loopexit ], [ 0, %invoke.cont1757 ]
  store i32 %1283, ptr %m_size.i.i2995, align 4
  %1286 = load i32, ptr %m_size.i.i3035, align 4
  %tobool1764.not = icmp eq i32 %1286, 0
  %1287 = load ptr, ptr %m_data.i.i3034, align 8
  %spec.select = select i1 %tobool1764.not, ptr null, ptr %1287
  %1288 = load i64, ptr %m_size.i.i2568, align 8
  %conv1771 = trunc i64 %1288 to i32
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp1772.sroa.0, i8 0, i64 16, i1 false)
  %cmp4.i3059 = icmp slt i32 %1285, %conv1771
  br i1 %cmp4.i3059, label %for.body9.lr.ph.i3060, label %invoke.cont1773

lpad1716:                                         ; preds = %invoke.cont1715
  %1289 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup1845

lpad1720:                                         ; preds = %invoke.cont1719
  %1290 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup1844

lpad1724:                                         ; preds = %invoke.cont1723
  %1291 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup1843

lpad1728:                                         ; preds = %invoke.cont1727
  %1292 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup1842

lpad1732:                                         ; preds = %invoke.cont1731
  %1293 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup1841

lpad1736:                                         ; preds = %invoke.cont1735
  %1294 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup1840

lpad1740:                                         ; preds = %invoke.cont1739
  %1295 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup1839

lpad1744:                                         ; preds = %invoke.cont1743
  %1296 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup1838

lpad1748:                                         ; preds = %invoke.cont1747
  %1297 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup1837

lpad1752:                                         ; preds = %invoke.cont1751
  %1298 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup1836

lpad1756.loopexit:                                ; preds = %for.body1792
  %lpad.loopexit = landingpad { ptr, i32 }
          cleanup
  br label %lpad1756

lpad1756.loopexit.split-lp:                       ; preds = %invoke.cont1754, %if.end7.i.i3137, %if.then.i.i3131, %call.i.i.noexc3141, %if.end7.i.i3159, %if.then.i.i3153, %call.i.i.noexc3163, %if.end7.i.i3181, %if.then.i.i3175, %call.i.i.noexc3185, %if.end7.i.i3203, %if.then.i.i3197, %call.i.i.noexc3207, %if.end7.i.i3225, %if.then.i.i3219, %call.i.i.noexc3229, %if.end7.i.i3247, %if.then.i.i3241, %call.i.i.noexc3251, %_ZN20b3AlignedObjectArrayIiE8allocateEi.exit.i5271, %_ZNK20b3AlignedObjectArrayIiE4copyEiiPi.exit18.i5298, %.noexc5302, %_ZN20b3AlignedObjectArrayI6b3Int4E8allocateEi.exit.i5311, %_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_.exit18.i5338, %.noexc5342, %if.then3.i.i5326, %_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit.i5351, %_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i5378, %.noexc5382, %if.then3.i.i5366, %_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit.i5391, %_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i5418, %.noexc5422, %if.then3.i.i5406, %_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit.i5431, %_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i5458, %.noexc5462, %if.then3.i.i5446
  %lpad.loopexit.split-lp = landingpad { ptr, i32 }
          cleanup
  br label %lpad1756

lpad1756:                                         ; preds = %lpad1756.loopexit.split-lp, %lpad1756.loopexit
  %lpad.phi = phi { ptr, i32 } [ %lpad.loopexit, %lpad1756.loopexit ], [ %lpad.loopexit.split-lp, %lpad1756.loopexit.split-lp ]
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %concaveSepNormalsHost) #26
  br label %ehcleanup1836

for.body9.lr.ph.i3060:                            ; preds = %invoke.cont1761
  %1299 = load i32, ptr %m_capacity.i.i2980, align 8
  %cmp.i5307 = icmp slt i32 %1299, %conv1771
  br i1 %cmp.i5307, label %if.then.i5309, label %for.body9.lr.ph.i3060..noexc3068_crit_edge

for.body9.lr.ph.i3060..noexc3068_crit_edge:       ; preds = %for.body9.lr.ph.i3060
  %.pre6200.pre = load ptr, ptr %m_data.i.i2978, align 8
  br label %.noexc3068

if.then.i5309:                                    ; preds = %for.body9.lr.ph.i3060
  %tobool.not.i.i5310 = icmp eq i32 %conv1771, 0
  br i1 %tobool.not.i.i5310, label %_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_.exit18.i5338, label %_ZN20b3AlignedObjectArrayI6b3Int4E8allocateEi.exit.i5311

_ZN20b3AlignedObjectArrayI6b3Int4E8allocateEi.exit.i5311: ; preds = %if.then.i5309
  %sext = shl i64 %1288, 32
  %mul.i.i.i5313 = ashr exact i64 %sext, 28
  %call.i.i.i5341 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i5313, i32 noundef 16)
          to label %call.i.i.i.noexc5340 unwind label %lpad1756.loopexit.split-lp

call.i.i.i.noexc5340:                             ; preds = %_ZN20b3AlignedObjectArrayI6b3Int4E8allocateEi.exit.i5311
  %cmp3.i5314 = icmp eq ptr %call.i.i.i5341, null
  br i1 %cmp3.i5314, label %_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_.exit18.i5338, label %if.then.split.i5315

if.then.split.i5315:                              ; preds = %call.i.i.i.noexc5340
  %cmp4.i.i5317 = icmp sgt i32 %1285, 0
  %.pre6199 = load ptr, ptr %m_data.i.i2978, align 8
  br i1 %cmp4.i.i5317, label %for.body.lr.ph.i.i5329, label %if.end.i5318

for.body.lr.ph.i.i5329:                           ; preds = %if.then.split.i5315
  %wide.trip.count.i.i5331 = zext nneg i32 %1285 to i64
  br label %for.body.i.i5332

for.body.i.i5332:                                 ; preds = %for.body.i.i5332, %for.body.lr.ph.i.i5329
  %indvars.iv.i.i5333 = phi i64 [ 0, %for.body.lr.ph.i.i5329 ], [ %indvars.iv.next.i.i5336, %for.body.i.i5332 ]
  %arrayidx.i.i5334 = getelementptr inbounds %struct.b3Int4, ptr %call.i.i.i5341, i64 %indvars.iv.i.i5333
  %arrayidx3.i.i5335 = getelementptr inbounds %struct.b3Int4, ptr %.pre6199, i64 %indvars.iv.i.i5333
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx.i.i5334, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx3.i.i5335, i64 16, i1 false)
  %indvars.iv.next.i.i5336 = add nuw nsw i64 %indvars.iv.i.i5333, 1
  %exitcond.not.i.i5337 = icmp eq i64 %indvars.iv.next.i.i5336, %wide.trip.count.i.i5331
  br i1 %exitcond.not.i.i5337, label %if.then.i22.i5323, label %for.body.i.i5332, !llvm.loop !69

_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_.exit18.i5338: ; preds = %call.i.i.i.noexc5340, %if.then.i5309
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc5342 unwind label %lpad1756.loopexit.split-lp

.noexc5342:                                       ; preds = %_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_.exit18.i5338
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc5343 unwind label %lpad1756.loopexit.split-lp

.noexc5343:                                       ; preds = %.noexc5342
  store i32 0, ptr %m_size.i.i2979, align 4
  %.pre6198 = load ptr, ptr %m_data.i.i2978, align 8
  br label %if.end.i5318

if.end.i5318:                                     ; preds = %.noexc5343, %if.then.split.i5315
  %1300 = phi ptr [ %.pre6198, %.noexc5343 ], [ %.pre6199, %if.then.split.i5315 ]
  %retval.0.i25.i5319 = phi ptr [ null, %.noexc5343 ], [ %call.i.i.i5341, %if.then.split.i5315 ]
  %_Count.addr.0.i5320 = phi i32 [ 0, %.noexc5343 ], [ %conv1771, %if.then.split.i5315 ]
  %tobool.not.i21.i5322 = icmp eq ptr %1300, null
  br i1 %tobool.not.i21.i5322, label %_ZN20b3AlignedObjectArrayI6b3Int4E10deallocateEv.exit.i5327, label %if.then.i22.i5323

if.then.i22.i5323:                                ; preds = %for.body.i.i5332, %if.end.i5318
  %_Count.addr.0.i53206263 = phi i32 [ %_Count.addr.0.i5320, %if.end.i5318 ], [ %conv1771, %for.body.i.i5332 ]
  %retval.0.i25.i53196261 = phi ptr [ %retval.0.i25.i5319, %if.end.i5318 ], [ %call.i.i.i5341, %for.body.i.i5332 ]
  %1301 = phi ptr [ %1300, %if.end.i5318 ], [ %.pre6199, %for.body.i.i5332 ]
  %1302 = load i8, ptr %m_ownsMemory.i.i2977, align 8
  %1303 = and i8 %1302, 1
  %tobool2.not.i.i5325 = icmp eq i8 %1303, 0
  br i1 %tobool2.not.i.i5325, label %_ZN20b3AlignedObjectArrayI6b3Int4E10deallocateEv.exit.i5327, label %if.then3.i.i5326

if.then3.i.i5326:                                 ; preds = %if.then.i22.i5323
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1301)
          to label %_ZN20b3AlignedObjectArrayI6b3Int4E10deallocateEv.exit.i5327 unwind label %lpad1756.loopexit.split-lp

_ZN20b3AlignedObjectArrayI6b3Int4E10deallocateEv.exit.i5327: ; preds = %if.then3.i.i5326, %if.then.i22.i5323, %if.end.i5318
  %_Count.addr.0.i53206264 = phi i32 [ %_Count.addr.0.i53206263, %if.then3.i.i5326 ], [ %_Count.addr.0.i53206263, %if.then.i22.i5323 ], [ %_Count.addr.0.i5320, %if.end.i5318 ]
  %retval.0.i25.i53196262 = phi ptr [ %retval.0.i25.i53196261, %if.then3.i.i5326 ], [ %retval.0.i25.i53196261, %if.then.i22.i5323 ], [ %retval.0.i25.i5319, %if.end.i5318 ]
  store i8 1, ptr %m_ownsMemory.i.i2977, align 8
  store ptr %retval.0.i25.i53196262, ptr %m_data.i.i2978, align 8
  store i32 %_Count.addr.0.i53206264, ptr %m_capacity.i.i2980, align 8
  br label %.noexc3068

.noexc3068:                                       ; preds = %for.body9.lr.ph.i3060..noexc3068_crit_edge, %_ZN20b3AlignedObjectArrayI6b3Int4E10deallocateEv.exit.i5327
  %.pre6200 = phi ptr [ %.pre6200.pre, %for.body9.lr.ph.i3060..noexc3068_crit_edge ], [ %retval.0.i25.i53196262, %_ZN20b3AlignedObjectArrayI6b3Int4E10deallocateEv.exit.i5327 ]
  %1304 = sext i32 %1285 to i64
  %sext6129 = shl i64 %1288, 32
  %wide.trip.count.i3062 = ashr exact i64 %sext6129, 32
  br label %for.body9.i3063

for.body9.i3063:                                  ; preds = %for.body9.i3063, %.noexc3068
  %indvars.iv.i3064 = phi i64 [ %1304, %.noexc3068 ], [ %indvars.iv.next.i3066, %for.body9.i3063 ]
  %arrayidx12.i3065 = getelementptr inbounds %struct.b3Int4, ptr %.pre6200, i64 %indvars.iv.i3064
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx12.i3065, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp1772.sroa.0, i64 16, i1 false)
  %indvars.iv.next.i3066 = add nsw i64 %indvars.iv.i3064, 1
  %exitcond.not.i3067 = icmp eq i64 %indvars.iv.next.i3066, %wide.trip.count.i3062
  br i1 %exitcond.not.i3067, label %invoke.cont1773, label %for.body9.i3063, !llvm.loop !54

invoke.cont1773:                                  ; preds = %for.body9.i3063, %invoke.cont1761
  store i32 %conv1771, ptr %m_size.i.i2979, align 4
  %1305 = load i64, ptr %m_size.i.i2586, align 8
  %conv1776 = trunc i64 %1305 to i32
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp1777.sroa.0, i8 0, i64 16, i1 false)
  %1306 = load i32, ptr %m_size.i.i2983, align 4
  %cmp4.i3072 = icmp slt i32 %1306, %conv1776
  br i1 %cmp4.i3072, label %for.body9.lr.ph.i3073, label %invoke.cont1778

for.body9.lr.ph.i3073:                            ; preds = %invoke.cont1773
  %1307 = load i32, ptr %m_capacity.i.i2984, align 8
  %cmp.i5347 = icmp slt i32 %1307, %conv1776
  br i1 %cmp.i5347, label %if.then.i5349, label %for.body9.lr.ph.i3073..noexc3081_crit_edge

for.body9.lr.ph.i3073..noexc3081_crit_edge:       ; preds = %for.body9.lr.ph.i3073
  %.pre6204.pre = load ptr, ptr %m_data.i.i2982, align 8
  br label %.noexc3081

if.then.i5349:                                    ; preds = %for.body9.lr.ph.i3073
  %tobool.not.i.i5350 = icmp eq i32 %conv1776, 0
  br i1 %tobool.not.i.i5350, label %_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i5378, label %_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit.i5351

_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit.i5351: ; preds = %if.then.i5349
  %sext6130 = shl i64 %1305, 32
  %mul.i.i.i5353 = ashr exact i64 %sext6130, 28
  %call.i.i.i5381 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i5353, i32 noundef 16)
          to label %call.i.i.i.noexc5380 unwind label %lpad1756.loopexit.split-lp

call.i.i.i.noexc5380:                             ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit.i5351
  %cmp3.i5354 = icmp eq ptr %call.i.i.i5381, null
  br i1 %cmp3.i5354, label %_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i5378, label %if.then.split.i5355

if.then.split.i5355:                              ; preds = %call.i.i.i.noexc5380
  %cmp4.i.i5357 = icmp sgt i32 %1306, 0
  %.pre6203 = load ptr, ptr %m_data.i.i2982, align 8
  br i1 %cmp4.i.i5357, label %for.body.lr.ph.i.i5369, label %if.end.i5358

for.body.lr.ph.i.i5369:                           ; preds = %if.then.split.i5355
  %wide.trip.count.i.i5371 = zext nneg i32 %1306 to i64
  br label %for.body.i.i5372

for.body.i.i5372:                                 ; preds = %for.body.i.i5372, %for.body.lr.ph.i.i5369
  %indvars.iv.i.i5373 = phi i64 [ 0, %for.body.lr.ph.i.i5369 ], [ %indvars.iv.next.i.i5376, %for.body.i.i5372 ]
  %arrayidx.i.i5374 = getelementptr inbounds %class.b3Vector3, ptr %call.i.i.i5381, i64 %indvars.iv.i.i5373
  %arrayidx3.i.i5375 = getelementptr inbounds %class.b3Vector3, ptr %.pre6203, i64 %indvars.iv.i.i5373
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx.i.i5374, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx3.i.i5375, i64 16, i1 false)
  %indvars.iv.next.i.i5376 = add nuw nsw i64 %indvars.iv.i.i5373, 1
  %exitcond.not.i.i5377 = icmp eq i64 %indvars.iv.next.i.i5376, %wide.trip.count.i.i5371
  br i1 %exitcond.not.i.i5377, label %if.then.i22.i5363, label %for.body.i.i5372, !llvm.loop !70

_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i5378: ; preds = %call.i.i.i.noexc5380, %if.then.i5349
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc5382 unwind label %lpad1756.loopexit.split-lp

.noexc5382:                                       ; preds = %_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i5378
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc5383 unwind label %lpad1756.loopexit.split-lp

.noexc5383:                                       ; preds = %.noexc5382
  store i32 0, ptr %m_size.i.i2983, align 4
  %.pre6202 = load ptr, ptr %m_data.i.i2982, align 8
  br label %if.end.i5358

if.end.i5358:                                     ; preds = %.noexc5383, %if.then.split.i5355
  %1308 = phi ptr [ %.pre6202, %.noexc5383 ], [ %.pre6203, %if.then.split.i5355 ]
  %retval.0.i25.i5359 = phi ptr [ null, %.noexc5383 ], [ %call.i.i.i5381, %if.then.split.i5355 ]
  %_Count.addr.0.i5360 = phi i32 [ 0, %.noexc5383 ], [ %conv1776, %if.then.split.i5355 ]
  %tobool.not.i21.i5362 = icmp eq ptr %1308, null
  br i1 %tobool.not.i21.i5362, label %_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv.exit.i5367, label %if.then.i22.i5363

if.then.i22.i5363:                                ; preds = %for.body.i.i5372, %if.end.i5358
  %_Count.addr.0.i53606270 = phi i32 [ %_Count.addr.0.i5360, %if.end.i5358 ], [ %conv1776, %for.body.i.i5372 ]
  %retval.0.i25.i53596268 = phi ptr [ %retval.0.i25.i5359, %if.end.i5358 ], [ %call.i.i.i5381, %for.body.i.i5372 ]
  %1309 = phi ptr [ %1308, %if.end.i5358 ], [ %.pre6203, %for.body.i.i5372 ]
  %1310 = load i8, ptr %m_ownsMemory.i.i2981, align 8
  %1311 = and i8 %1310, 1
  %tobool2.not.i.i5365 = icmp eq i8 %1311, 0
  br i1 %tobool2.not.i.i5365, label %_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv.exit.i5367, label %if.then3.i.i5366

if.then3.i.i5366:                                 ; preds = %if.then.i22.i5363
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1309)
          to label %_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv.exit.i5367 unwind label %lpad1756.loopexit.split-lp

_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv.exit.i5367: ; preds = %if.then3.i.i5366, %if.then.i22.i5363, %if.end.i5358
  %_Count.addr.0.i53606271 = phi i32 [ %_Count.addr.0.i53606270, %if.then3.i.i5366 ], [ %_Count.addr.0.i53606270, %if.then.i22.i5363 ], [ %_Count.addr.0.i5360, %if.end.i5358 ]
  %retval.0.i25.i53596269 = phi ptr [ %retval.0.i25.i53596268, %if.then3.i.i5366 ], [ %retval.0.i25.i53596268, %if.then.i22.i5363 ], [ %retval.0.i25.i5359, %if.end.i5358 ]
  store i8 1, ptr %m_ownsMemory.i.i2981, align 8
  store ptr %retval.0.i25.i53596269, ptr %m_data.i.i2982, align 8
  store i32 %_Count.addr.0.i53606271, ptr %m_capacity.i.i2984, align 8
  br label %.noexc3081

.noexc3081:                                       ; preds = %for.body9.lr.ph.i3073..noexc3081_crit_edge, %_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv.exit.i5367
  %.pre6204 = phi ptr [ %.pre6204.pre, %for.body9.lr.ph.i3073..noexc3081_crit_edge ], [ %retval.0.i25.i53596269, %_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv.exit.i5367 ]
  %1312 = sext i32 %1306 to i64
  %sext6131 = shl i64 %1305, 32
  %wide.trip.count.i3075 = ashr exact i64 %sext6131, 32
  br label %for.body9.i3076

for.body9.i3076:                                  ; preds = %for.body9.i3076, %.noexc3081
  %indvars.iv.i3077 = phi i64 [ %1312, %.noexc3081 ], [ %indvars.iv.next.i3079, %for.body9.i3076 ]
  %arrayidx12.i3078 = getelementptr inbounds %class.b3Vector3, ptr %.pre6204, i64 %indvars.iv.i3077
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx12.i3078, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp1777.sroa.0, i64 16, i1 false)
  %indvars.iv.next.i3079 = add nsw i64 %indvars.iv.i3077, 1
  %exitcond.not.i3080 = icmp eq i64 %indvars.iv.next.i3079, %wide.trip.count.i3075
  br i1 %exitcond.not.i3080, label %invoke.cont1778, label %for.body9.i3076, !llvm.loop !55

invoke.cont1778:                                  ; preds = %for.body9.i3076, %invoke.cont1773
  store i32 %conv1776, ptr %m_size.i.i2983, align 4
  %1313 = load i64, ptr %m_size.i.i2577, align 8
  %conv1781 = trunc i64 %1313 to i32
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp1782.sroa.0, i8 0, i64 16, i1 false)
  %1314 = load i32, ptr %m_size.i.i2987, align 4
  %cmp4.i3085 = icmp slt i32 %1314, %conv1781
  br i1 %cmp4.i3085, label %for.body9.lr.ph.i3086, label %invoke.cont1783

for.body9.lr.ph.i3086:                            ; preds = %invoke.cont1778
  %1315 = load i32, ptr %m_capacity.i.i2988, align 8
  %cmp.i5387 = icmp slt i32 %1315, %conv1781
  br i1 %cmp.i5387, label %if.then.i5389, label %for.body9.lr.ph.i3086..noexc3094_crit_edge

for.body9.lr.ph.i3086..noexc3094_crit_edge:       ; preds = %for.body9.lr.ph.i3086
  %.pre6208.pre = load ptr, ptr %m_data.i.i2986, align 8
  br label %.noexc3094

if.then.i5389:                                    ; preds = %for.body9.lr.ph.i3086
  %tobool.not.i.i5390 = icmp eq i32 %conv1781, 0
  br i1 %tobool.not.i.i5390, label %_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i5418, label %_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit.i5391

_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit.i5391: ; preds = %if.then.i5389
  %sext6132 = shl i64 %1313, 32
  %mul.i.i.i5393 = ashr exact i64 %sext6132, 28
  %call.i.i.i5421 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i5393, i32 noundef 16)
          to label %call.i.i.i.noexc5420 unwind label %lpad1756.loopexit.split-lp

call.i.i.i.noexc5420:                             ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit.i5391
  %cmp3.i5394 = icmp eq ptr %call.i.i.i5421, null
  br i1 %cmp3.i5394, label %_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i5418, label %if.then.split.i5395

if.then.split.i5395:                              ; preds = %call.i.i.i.noexc5420
  %cmp4.i.i5397 = icmp sgt i32 %1314, 0
  %.pre6207 = load ptr, ptr %m_data.i.i2986, align 8
  br i1 %cmp4.i.i5397, label %for.body.lr.ph.i.i5409, label %if.end.i5398

for.body.lr.ph.i.i5409:                           ; preds = %if.then.split.i5395
  %wide.trip.count.i.i5411 = zext nneg i32 %1314 to i64
  br label %for.body.i.i5412

for.body.i.i5412:                                 ; preds = %for.body.i.i5412, %for.body.lr.ph.i.i5409
  %indvars.iv.i.i5413 = phi i64 [ 0, %for.body.lr.ph.i.i5409 ], [ %indvars.iv.next.i.i5416, %for.body.i.i5412 ]
  %arrayidx.i.i5414 = getelementptr inbounds %class.b3Vector3, ptr %call.i.i.i5421, i64 %indvars.iv.i.i5413
  %arrayidx3.i.i5415 = getelementptr inbounds %class.b3Vector3, ptr %.pre6207, i64 %indvars.iv.i.i5413
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx.i.i5414, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx3.i.i5415, i64 16, i1 false)
  %indvars.iv.next.i.i5416 = add nuw nsw i64 %indvars.iv.i.i5413, 1
  %exitcond.not.i.i5417 = icmp eq i64 %indvars.iv.next.i.i5416, %wide.trip.count.i.i5411
  br i1 %exitcond.not.i.i5417, label %if.then.i22.i5403, label %for.body.i.i5412, !llvm.loop !70

_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i5418: ; preds = %call.i.i.i.noexc5420, %if.then.i5389
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc5422 unwind label %lpad1756.loopexit.split-lp

.noexc5422:                                       ; preds = %_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i5418
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc5423 unwind label %lpad1756.loopexit.split-lp

.noexc5423:                                       ; preds = %.noexc5422
  store i32 0, ptr %m_size.i.i2987, align 4
  %.pre6206 = load ptr, ptr %m_data.i.i2986, align 8
  br label %if.end.i5398

if.end.i5398:                                     ; preds = %.noexc5423, %if.then.split.i5395
  %1316 = phi ptr [ %.pre6206, %.noexc5423 ], [ %.pre6207, %if.then.split.i5395 ]
  %retval.0.i25.i5399 = phi ptr [ null, %.noexc5423 ], [ %call.i.i.i5421, %if.then.split.i5395 ]
  %_Count.addr.0.i5400 = phi i32 [ 0, %.noexc5423 ], [ %conv1781, %if.then.split.i5395 ]
  %tobool.not.i21.i5402 = icmp eq ptr %1316, null
  br i1 %tobool.not.i21.i5402, label %_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv.exit.i5407, label %if.then.i22.i5403

if.then.i22.i5403:                                ; preds = %for.body.i.i5412, %if.end.i5398
  %_Count.addr.0.i54006277 = phi i32 [ %_Count.addr.0.i5400, %if.end.i5398 ], [ %conv1781, %for.body.i.i5412 ]
  %retval.0.i25.i53996275 = phi ptr [ %retval.0.i25.i5399, %if.end.i5398 ], [ %call.i.i.i5421, %for.body.i.i5412 ]
  %1317 = phi ptr [ %1316, %if.end.i5398 ], [ %.pre6207, %for.body.i.i5412 ]
  %1318 = load i8, ptr %m_ownsMemory.i.i2985, align 8
  %1319 = and i8 %1318, 1
  %tobool2.not.i.i5405 = icmp eq i8 %1319, 0
  br i1 %tobool2.not.i.i5405, label %_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv.exit.i5407, label %if.then3.i.i5406

if.then3.i.i5406:                                 ; preds = %if.then.i22.i5403
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1317)
          to label %_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv.exit.i5407 unwind label %lpad1756.loopexit.split-lp

_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv.exit.i5407: ; preds = %if.then3.i.i5406, %if.then.i22.i5403, %if.end.i5398
  %_Count.addr.0.i54006278 = phi i32 [ %_Count.addr.0.i54006277, %if.then3.i.i5406 ], [ %_Count.addr.0.i54006277, %if.then.i22.i5403 ], [ %_Count.addr.0.i5400, %if.end.i5398 ]
  %retval.0.i25.i53996276 = phi ptr [ %retval.0.i25.i53996275, %if.then3.i.i5406 ], [ %retval.0.i25.i53996275, %if.then.i22.i5403 ], [ %retval.0.i25.i5399, %if.end.i5398 ]
  store i8 1, ptr %m_ownsMemory.i.i2985, align 8
  store ptr %retval.0.i25.i53996276, ptr %m_data.i.i2986, align 8
  store i32 %_Count.addr.0.i54006278, ptr %m_capacity.i.i2988, align 8
  br label %.noexc3094

.noexc3094:                                       ; preds = %for.body9.lr.ph.i3086..noexc3094_crit_edge, %_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv.exit.i5407
  %.pre6208 = phi ptr [ %.pre6208.pre, %for.body9.lr.ph.i3086..noexc3094_crit_edge ], [ %retval.0.i25.i53996276, %_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv.exit.i5407 ]
  %1320 = sext i32 %1314 to i64
  %sext6133 = shl i64 %1313, 32
  %wide.trip.count.i3088 = ashr exact i64 %sext6133, 32
  br label %for.body9.i3089

for.body9.i3089:                                  ; preds = %for.body9.i3089, %.noexc3094
  %indvars.iv.i3090 = phi i64 [ %1320, %.noexc3094 ], [ %indvars.iv.next.i3092, %for.body9.i3089 ]
  %arrayidx12.i3091 = getelementptr inbounds %class.b3Vector3, ptr %.pre6208, i64 %indvars.iv.i3090
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx12.i3091, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp1782.sroa.0, i64 16, i1 false)
  %indvars.iv.next.i3092 = add nsw i64 %indvars.iv.i3090, 1
  %exitcond.not.i3093 = icmp eq i64 %indvars.iv.next.i3092, %wide.trip.count.i3088
  br i1 %exitcond.not.i3093, label %invoke.cont1783, label %for.body9.i3089, !llvm.loop !55

invoke.cont1783:                                  ; preds = %for.body9.i3089, %invoke.cont1778
  store i32 %conv1781, ptr %m_size.i.i2987, align 4
  %1321 = load i64, ptr %m_size.i.i2595, align 8
  %conv1786 = trunc i64 %1321 to i32
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp1787.sroa.0, i8 0, i64 16, i1 false)
  %1322 = load i32, ptr %m_size.i.i2991, align 4
  %cmp4.i3098 = icmp slt i32 %1322, %conv1786
  br i1 %cmp4.i3098, label %for.body9.lr.ph.i3099, label %_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_.exit3108

for.body9.lr.ph.i3099:                            ; preds = %invoke.cont1783
  %1323 = load i32, ptr %m_capacity.i.i2992, align 8
  %cmp.i5427 = icmp slt i32 %1323, %conv1786
  br i1 %cmp.i5427, label %if.then.i5429, label %for.body9.lr.ph.i3099..noexc3107_crit_edge

for.body9.lr.ph.i3099..noexc3107_crit_edge:       ; preds = %for.body9.lr.ph.i3099
  %.pre6212.pre = load ptr, ptr %m_data.i.i2990, align 8
  br label %.noexc3107

if.then.i5429:                                    ; preds = %for.body9.lr.ph.i3099
  %tobool.not.i.i5430 = icmp eq i32 %conv1786, 0
  br i1 %tobool.not.i.i5430, label %_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i5458, label %_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit.i5431

_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit.i5431: ; preds = %if.then.i5429
  %sext6134 = shl i64 %1321, 32
  %mul.i.i.i5433 = ashr exact i64 %sext6134, 28
  %call.i.i.i5461 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i5433, i32 noundef 16)
          to label %call.i.i.i.noexc5460 unwind label %lpad1756.loopexit.split-lp

call.i.i.i.noexc5460:                             ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit.i5431
  %cmp3.i5434 = icmp eq ptr %call.i.i.i5461, null
  br i1 %cmp3.i5434, label %_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i5458, label %if.then.split.i5435

if.then.split.i5435:                              ; preds = %call.i.i.i.noexc5460
  %cmp4.i.i5437 = icmp sgt i32 %1322, 0
  %.pre6211 = load ptr, ptr %m_data.i.i2990, align 8
  br i1 %cmp4.i.i5437, label %for.body.lr.ph.i.i5449, label %if.end.i5438

for.body.lr.ph.i.i5449:                           ; preds = %if.then.split.i5435
  %wide.trip.count.i.i5451 = zext nneg i32 %1322 to i64
  br label %for.body.i.i5452

for.body.i.i5452:                                 ; preds = %for.body.i.i5452, %for.body.lr.ph.i.i5449
  %indvars.iv.i.i5453 = phi i64 [ 0, %for.body.lr.ph.i.i5449 ], [ %indvars.iv.next.i.i5456, %for.body.i.i5452 ]
  %arrayidx.i.i5454 = getelementptr inbounds %class.b3Vector3, ptr %call.i.i.i5461, i64 %indvars.iv.i.i5453
  %arrayidx3.i.i5455 = getelementptr inbounds %class.b3Vector3, ptr %.pre6211, i64 %indvars.iv.i.i5453
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx.i.i5454, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx3.i.i5455, i64 16, i1 false)
  %indvars.iv.next.i.i5456 = add nuw nsw i64 %indvars.iv.i.i5453, 1
  %exitcond.not.i.i5457 = icmp eq i64 %indvars.iv.next.i.i5456, %wide.trip.count.i.i5451
  br i1 %exitcond.not.i.i5457, label %if.then.i22.i5443, label %for.body.i.i5452, !llvm.loop !70

_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i5458: ; preds = %call.i.i.i.noexc5460, %if.then.i5429
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc5462 unwind label %lpad1756.loopexit.split-lp

.noexc5462:                                       ; preds = %_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i5458
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc5463 unwind label %lpad1756.loopexit.split-lp

.noexc5463:                                       ; preds = %.noexc5462
  store i32 0, ptr %m_size.i.i2991, align 4
  %.pre6210 = load ptr, ptr %m_data.i.i2990, align 8
  br label %if.end.i5438

if.end.i5438:                                     ; preds = %.noexc5463, %if.then.split.i5435
  %1324 = phi ptr [ %.pre6210, %.noexc5463 ], [ %.pre6211, %if.then.split.i5435 ]
  %retval.0.i25.i5439 = phi ptr [ null, %.noexc5463 ], [ %call.i.i.i5461, %if.then.split.i5435 ]
  %_Count.addr.0.i5440 = phi i32 [ 0, %.noexc5463 ], [ %conv1786, %if.then.split.i5435 ]
  %tobool.not.i21.i5442 = icmp eq ptr %1324, null
  br i1 %tobool.not.i21.i5442, label %_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv.exit.i5447, label %if.then.i22.i5443

if.then.i22.i5443:                                ; preds = %for.body.i.i5452, %if.end.i5438
  %_Count.addr.0.i54406284 = phi i32 [ %_Count.addr.0.i5440, %if.end.i5438 ], [ %conv1786, %for.body.i.i5452 ]
  %retval.0.i25.i54396282 = phi ptr [ %retval.0.i25.i5439, %if.end.i5438 ], [ %call.i.i.i5461, %for.body.i.i5452 ]
  %1325 = phi ptr [ %1324, %if.end.i5438 ], [ %.pre6211, %for.body.i.i5452 ]
  %1326 = load i8, ptr %m_ownsMemory.i.i2989, align 8
  %1327 = and i8 %1326, 1
  %tobool2.not.i.i5445 = icmp eq i8 %1327, 0
  br i1 %tobool2.not.i.i5445, label %_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv.exit.i5447, label %if.then3.i.i5446

if.then3.i.i5446:                                 ; preds = %if.then.i22.i5443
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1325)
          to label %_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv.exit.i5447 unwind label %lpad1756.loopexit.split-lp

_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv.exit.i5447: ; preds = %if.then3.i.i5446, %if.then.i22.i5443, %if.end.i5438
  %_Count.addr.0.i54406285 = phi i32 [ %_Count.addr.0.i54406284, %if.then3.i.i5446 ], [ %_Count.addr.0.i54406284, %if.then.i22.i5443 ], [ %_Count.addr.0.i5440, %if.end.i5438 ]
  %retval.0.i25.i54396283 = phi ptr [ %retval.0.i25.i54396282, %if.then3.i.i5446 ], [ %retval.0.i25.i54396282, %if.then.i22.i5443 ], [ %retval.0.i25.i5439, %if.end.i5438 ]
  store i8 1, ptr %m_ownsMemory.i.i2989, align 8
  store ptr %retval.0.i25.i54396283, ptr %m_data.i.i2990, align 8
  store i32 %_Count.addr.0.i54406285, ptr %m_capacity.i.i2992, align 8
  br label %.noexc3107

.noexc3107:                                       ; preds = %for.body9.lr.ph.i3099..noexc3107_crit_edge, %_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv.exit.i5447
  %.pre6212 = phi ptr [ %.pre6212.pre, %for.body9.lr.ph.i3099..noexc3107_crit_edge ], [ %retval.0.i25.i54396283, %_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv.exit.i5447 ]
  %1328 = sext i32 %1322 to i64
  %sext6135 = shl i64 %1321, 32
  %wide.trip.count.i3101 = ashr exact i64 %sext6135, 32
  br label %for.body9.i3102

for.body9.i3102:                                  ; preds = %for.body9.i3102, %.noexc3107
  %indvars.iv.i3103 = phi i64 [ %1328, %.noexc3107 ], [ %indvars.iv.next.i3105, %for.body9.i3102 ]
  %arrayidx12.i3104 = getelementptr inbounds %class.b3Vector3, ptr %.pre6212, i64 %indvars.iv.i3103
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx12.i3104, ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp1787.sroa.0, i64 16, i1 false)
  %indvars.iv.next.i3105 = add nsw i64 %indvars.iv.i3103, 1
  %exitcond.not.i3106 = icmp eq i64 %indvars.iv.next.i3105, %wide.trip.count.i3101
  br i1 %exitcond.not.i3106, label %_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_.exit3108, label %for.body9.i3102, !llvm.loop !55

_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_.exit3108: ; preds = %for.body9.i3102, %invoke.cont1783
  store i32 %conv1786, ptr %m_size.i.i2991, align 4
  %1329 = load i32, ptr %numConcavePairs, align 4
  %cmp17916154 = icmp sgt i32 %1329, 0
  br i1 %cmp17916154, label %for.body1792.preheader, label %for.end1826

for.body1792.preheader:                           ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_.exit3108
  %.pre6213 = load ptr, ptr %m_data.i.i2978, align 8
  %.pre6214 = load ptr, ptr %m_data.i.i2982, align 8
  %.pre6215 = load ptr, ptr %m_data.i.i2986, align 8
  %.pre6216 = load ptr, ptr %m_data.i.i2990, align 8
  br label %for.body1792

for.body1792:                                     ; preds = %for.body1792.preheader, %for.inc1824
  %i1789.06155 = phi i32 [ %inc1825, %for.inc1824 ], [ 0, %for.body1792.preheader ]
  %1330 = load ptr, ptr %m_data.i.i2998, align 8
  %1331 = load ptr, ptr %m_data.i.i3002, align 8
  %1332 = load ptr, ptr %m_data.i.i3006, align 8
  %1333 = load ptr, ptr %m_data.i.i3014, align 8
  %1334 = load ptr, ptr %m_data.i.i3018, align 8
  %1335 = load ptr, ptr %m_data.i.i3022, align 8
  %1336 = load ptr, ptr %m_data.i.i3026, align 8
  %1337 = load ptr, ptr %m_data.i.i3030, align 8
  %1338 = load ptr, ptr %m_data.i.i3010, align 8
  %1339 = load ptr, ptr %m_data.i.i3038, align 8
  %1340 = load i32, ptr %vertexFaceCapacity, align 4
  invoke void @_Z33b3FindConcaveSeparatingAxisKernelP6b3Int4PK15b3RigidBodyDataPK12b3CollidablePK22b3ConvexPolyhedronDataPK9b3Vector3SC_PK9b3GpuFacePKiPK15b3GpuChildShapeP6b3AabbPSA_S0_SN_SN_SN_Piiii(ptr noundef nonnull %1330, ptr noundef nonnull %1331, ptr noundef nonnull %1332, ptr noundef nonnull %1333, ptr noundef nonnull %1334, ptr noundef nonnull %1335, ptr noundef nonnull %1336, ptr noundef nonnull %1337, ptr noundef %spec.select, ptr noundef nonnull %1338, ptr noundef nonnull %1339, ptr noundef nonnull %.pre6213, ptr noundef nonnull %.pre6214, ptr noundef nonnull %.pre6215, ptr noundef nonnull %.pre6216, ptr noundef nonnull %1284, i32 noundef %1340, i32 poison, i32 noundef %i1789.06155)
          to label %for.inc1824 unwind label %lpad1756.loopexit

for.inc1824:                                      ; preds = %for.body1792
  %inc1825 = add nuw nsw i32 %i1789.06155, 1
  %1341 = load i32, ptr %numConcavePairs, align 4
  %cmp1791 = icmp slt i32 %inc1825, %1341
  br i1 %cmp1791, label %for.body1792, label %for.end1826, !llvm.loop !71

for.end1826:                                      ; preds = %for.inc1824, %_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_.exit3108
  %1342 = load i32, ptr %m_size.i.i3039, align 4
  %conv.i3125 = sext i32 %1342 to i64
  %1343 = load i64, ptr %m_size.i.i611, align 8
  %cmp3.i.i3127 = icmp ult i64 %1343, %conv.i3125
  br i1 %cmp3.i.i3127, label %if.end7.i.i3137, label %_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i3128

if.end7.i.i3137:                                  ; preds = %for.end1826
  %call5.i.i3140 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveSepNormals, i64 noundef %conv.i3125, i1 noundef zeroext false)
          to label %call5.i.i.noexc3139 unwind label %lpad1756.loopexit.split-lp

call5.i.i.noexc3139:                              ; preds = %if.end7.i.i3137
  %spec.select.i.i3138 = select i1 %call5.i.i3140, i64 %conv.i3125, i64 0
  br label %_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i3128

_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i3128: ; preds = %call5.i.i.noexc3139, %for.end1826
  %storemerge.i.i3129 = phi i64 [ %conv.i3125, %for.end1826 ], [ %spec.select.i.i3138, %call5.i.i.noexc3139 ]
  store i64 %storemerge.i.i3129, ptr %m_size.i.i611, align 8
  %tobool3.not.i3130 = icmp eq i32 %1342, 0
  br i1 %tobool3.not.i3130, label %invoke.cont1828, label %if.then.i.i3131

if.then.i.i3131:                                  ; preds = %_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i3128
  %1344 = load ptr, ptr %m_data.i.i3038, align 8
  %mul.i.i3133 = shl nsw i64 %conv.i3125, 4
  %1345 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %m_commandQueue.i.i3134 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 29, i32 5
  %1346 = load ptr, ptr %m_commandQueue.i.i3134, align 8
  %m_clBuffer.i.i3135 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 29, i32 3
  %1347 = load ptr, ptr %m_clBuffer.i.i3135, align 8
  %call.i.i3142 = invoke i32 %1345(ptr noundef %1346, ptr noundef %1347, i32 noundef 0, i64 noundef 0, i64 noundef %mul.i.i3133, ptr noundef %1344, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call.i.i.noexc3141 unwind label %lpad1756.loopexit.split-lp

call.i.i.noexc3141:                               ; preds = %if.then.i.i3131
  %1348 = load ptr, ptr @__clewFinish, align 8
  %1349 = load ptr, ptr %m_commandQueue.i.i3134, align 8
  %call6.i.i3144 = invoke i32 %1348(ptr noundef %1349)
          to label %invoke.cont1828 unwind label %lpad1756.loopexit.split-lp

invoke.cont1828:                                  ; preds = %_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i3128, %call.i.i.noexc3141
  %1350 = load i32, ptr %m_size.i.i2995, align 4
  %conv.i3147 = sext i32 %1350 to i64
  %1351 = load i64, ptr %m_size.i.i620, align 8
  %cmp3.i.i3149 = icmp ult i64 %1351, %conv.i3147
  br i1 %cmp3.i.i3149, label %if.end7.i.i3159, label %_ZN13b3OpenCLArrayIiE6resizeEmb.exit.i3150

if.end7.i.i3159:                                  ; preds = %invoke.cont1828
  %call5.i.i3162 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayIiE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveHasSeparatingNormals, i64 noundef %conv.i3147, i1 noundef zeroext false)
          to label %call5.i.i.noexc3161 unwind label %lpad1756.loopexit.split-lp

call5.i.i.noexc3161:                              ; preds = %if.end7.i.i3159
  %spec.select.i.i3160 = select i1 %call5.i.i3162, i64 %conv.i3147, i64 0
  br label %_ZN13b3OpenCLArrayIiE6resizeEmb.exit.i3150

_ZN13b3OpenCLArrayIiE6resizeEmb.exit.i3150:       ; preds = %call5.i.i.noexc3161, %invoke.cont1828
  %storemerge.i.i3151 = phi i64 [ %conv.i3147, %invoke.cont1828 ], [ %spec.select.i.i3160, %call5.i.i.noexc3161 ]
  store i64 %storemerge.i.i3151, ptr %m_size.i.i620, align 8
  %tobool3.not.i3152 = icmp eq i32 %1350, 0
  br i1 %tobool3.not.i3152, label %invoke.cont1830, label %if.then.i.i3153

if.then.i.i3153:                                  ; preds = %_ZN13b3OpenCLArrayIiE6resizeEmb.exit.i3150
  %mul.i.i3155 = shl nsw i64 %conv.i3147, 2
  %1352 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %m_commandQueue.i.i3156 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 30, i32 5
  %1353 = load ptr, ptr %m_commandQueue.i.i3156, align 8
  %m_clBuffer.i.i3157 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 30, i32 3
  %1354 = load ptr, ptr %m_clBuffer.i.i3157, align 8
  %call.i.i3164 = invoke i32 %1352(ptr noundef %1353, ptr noundef %1354, i32 noundef 0, i64 noundef 0, i64 noundef %mul.i.i3155, ptr noundef %1284, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call.i.i.noexc3163 unwind label %lpad1756.loopexit.split-lp

call.i.i.noexc3163:                               ; preds = %if.then.i.i3153
  %1355 = load ptr, ptr @__clewFinish, align 8
  %1356 = load ptr, ptr %m_commandQueue.i.i3156, align 8
  %call6.i.i3166 = invoke i32 %1355(ptr noundef %1356)
          to label %invoke.cont1830 unwind label %lpad1756.loopexit.split-lp

invoke.cont1830:                                  ; preds = %_ZN13b3OpenCLArrayIiE6resizeEmb.exit.i3150, %call.i.i.noexc3163
  %1357 = load i32, ptr %m_size.i.i2979, align 4
  %conv.i3169 = sext i32 %1357 to i64
  %1358 = load i64, ptr %m_size.i.i2568, align 8
  %cmp3.i.i3171 = icmp ult i64 %1358, %conv.i3169
  br i1 %cmp3.i.i3171, label %if.end7.i.i3181, label %_ZN13b3OpenCLArrayI6b3Int4E6resizeEmb.exit.i3172

if.end7.i.i3181:                                  ; preds = %invoke.cont1830
  %call5.i.i3184 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI6b3Int4E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %clippingFacesOutGPU, i64 noundef %conv.i3169, i1 noundef zeroext false)
          to label %call5.i.i.noexc3183 unwind label %lpad1756.loopexit.split-lp

call5.i.i.noexc3183:                              ; preds = %if.end7.i.i3181
  %spec.select.i.i3182 = select i1 %call5.i.i3184, i64 %conv.i3169, i64 0
  br label %_ZN13b3OpenCLArrayI6b3Int4E6resizeEmb.exit.i3172

_ZN13b3OpenCLArrayI6b3Int4E6resizeEmb.exit.i3172: ; preds = %call5.i.i.noexc3183, %invoke.cont1830
  %storemerge.i.i3173 = phi i64 [ %conv.i3169, %invoke.cont1830 ], [ %spec.select.i.i3182, %call5.i.i.noexc3183 ]
  store i64 %storemerge.i.i3173, ptr %m_size.i.i2568, align 8
  %tobool3.not.i3174 = icmp eq i32 %1357, 0
  br i1 %tobool3.not.i3174, label %invoke.cont1831, label %if.then.i.i3175

if.then.i.i3175:                                  ; preds = %_ZN13b3OpenCLArrayI6b3Int4E6resizeEmb.exit.i3172
  %1359 = load ptr, ptr %m_data.i.i2978, align 8
  %mul.i.i3177 = shl nsw i64 %conv.i3169, 4
  %1360 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %m_commandQueue.i.i3178 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %clippingFacesOutGPU, i64 0, i32 5
  %1361 = load ptr, ptr %m_commandQueue.i.i3178, align 8
  %m_clBuffer.i.i3179 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %clippingFacesOutGPU, i64 0, i32 3
  %1362 = load ptr, ptr %m_clBuffer.i.i3179, align 8
  %call.i.i3186 = invoke i32 %1360(ptr noundef %1361, ptr noundef %1362, i32 noundef 0, i64 noundef 0, i64 noundef %mul.i.i3177, ptr noundef %1359, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call.i.i.noexc3185 unwind label %lpad1756.loopexit.split-lp

call.i.i.noexc3185:                               ; preds = %if.then.i.i3175
  %1363 = load ptr, ptr @__clewFinish, align 8
  %1364 = load ptr, ptr %m_commandQueue.i.i3178, align 8
  %call6.i.i3188 = invoke i32 %1363(ptr noundef %1364)
          to label %invoke.cont1831 unwind label %lpad1756.loopexit.split-lp

invoke.cont1831:                                  ; preds = %_ZN13b3OpenCLArrayI6b3Int4E6resizeEmb.exit.i3172, %call.i.i.noexc3185
  %1365 = load i32, ptr %m_size.i.i2983, align 4
  %conv.i3191 = sext i32 %1365 to i64
  %1366 = load i64, ptr %m_size.i.i2586, align 8
  %cmp3.i.i3193 = icmp ult i64 %1366, %conv.i3191
  br i1 %cmp3.i.i3193, label %if.end7.i.i3203, label %_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i3194

if.end7.i.i3203:                                  ; preds = %invoke.cont1831
  %call5.i.i3206 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %worldVertsA1GPU, i64 noundef %conv.i3191, i1 noundef zeroext false)
          to label %call5.i.i.noexc3205 unwind label %lpad1756.loopexit.split-lp

call5.i.i.noexc3205:                              ; preds = %if.end7.i.i3203
  %spec.select.i.i3204 = select i1 %call5.i.i3206, i64 %conv.i3191, i64 0
  br label %_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i3194

_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i3194: ; preds = %call5.i.i.noexc3205, %invoke.cont1831
  %storemerge.i.i3195 = phi i64 [ %conv.i3191, %invoke.cont1831 ], [ %spec.select.i.i3204, %call5.i.i.noexc3205 ]
  store i64 %storemerge.i.i3195, ptr %m_size.i.i2586, align 8
  %tobool3.not.i3196 = icmp eq i32 %1365, 0
  br i1 %tobool3.not.i3196, label %invoke.cont1832, label %if.then.i.i3197

if.then.i.i3197:                                  ; preds = %_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i3194
  %1367 = load ptr, ptr %m_data.i.i2982, align 8
  %mul.i.i3199 = shl nsw i64 %conv.i3191, 4
  %1368 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %m_commandQueue.i.i3200 = getelementptr inbounds %class.b3OpenCLArray, ptr %worldVertsA1GPU, i64 0, i32 5
  %1369 = load ptr, ptr %m_commandQueue.i.i3200, align 8
  %m_clBuffer.i.i3201 = getelementptr inbounds %class.b3OpenCLArray, ptr %worldVertsA1GPU, i64 0, i32 3
  %1370 = load ptr, ptr %m_clBuffer.i.i3201, align 8
  %call.i.i3208 = invoke i32 %1368(ptr noundef %1369, ptr noundef %1370, i32 noundef 0, i64 noundef 0, i64 noundef %mul.i.i3199, ptr noundef %1367, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call.i.i.noexc3207 unwind label %lpad1756.loopexit.split-lp

call.i.i.noexc3207:                               ; preds = %if.then.i.i3197
  %1371 = load ptr, ptr @__clewFinish, align 8
  %1372 = load ptr, ptr %m_commandQueue.i.i3200, align 8
  %call6.i.i3210 = invoke i32 %1371(ptr noundef %1372)
          to label %invoke.cont1832 unwind label %lpad1756.loopexit.split-lp

invoke.cont1832:                                  ; preds = %_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i3194, %call.i.i.noexc3207
  %1373 = load i32, ptr %m_size.i.i2987, align 4
  %conv.i3213 = sext i32 %1373 to i64
  %1374 = load i64, ptr %m_size.i.i2577, align 8
  %cmp3.i.i3215 = icmp ult i64 %1374, %conv.i3213
  br i1 %cmp3.i.i3215, label %if.end7.i.i3225, label %_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i3216

if.end7.i.i3225:                                  ; preds = %invoke.cont1832
  %call5.i.i3228 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %worldNormalsAGPU, i64 noundef %conv.i3213, i1 noundef zeroext false)
          to label %call5.i.i.noexc3227 unwind label %lpad1756.loopexit.split-lp

call5.i.i.noexc3227:                              ; preds = %if.end7.i.i3225
  %spec.select.i.i3226 = select i1 %call5.i.i3228, i64 %conv.i3213, i64 0
  br label %_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i3216

_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i3216: ; preds = %call5.i.i.noexc3227, %invoke.cont1832
  %storemerge.i.i3217 = phi i64 [ %conv.i3213, %invoke.cont1832 ], [ %spec.select.i.i3226, %call5.i.i.noexc3227 ]
  store i64 %storemerge.i.i3217, ptr %m_size.i.i2577, align 8
  %tobool3.not.i3218 = icmp eq i32 %1373, 0
  br i1 %tobool3.not.i3218, label %invoke.cont1833, label %if.then.i.i3219

if.then.i.i3219:                                  ; preds = %_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i3216
  %1375 = load ptr, ptr %m_data.i.i2986, align 8
  %mul.i.i3221 = shl nsw i64 %conv.i3213, 4
  %1376 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %m_commandQueue.i.i3222 = getelementptr inbounds %class.b3OpenCLArray, ptr %worldNormalsAGPU, i64 0, i32 5
  %1377 = load ptr, ptr %m_commandQueue.i.i3222, align 8
  %m_clBuffer.i.i3223 = getelementptr inbounds %class.b3OpenCLArray, ptr %worldNormalsAGPU, i64 0, i32 3
  %1378 = load ptr, ptr %m_clBuffer.i.i3223, align 8
  %call.i.i3230 = invoke i32 %1376(ptr noundef %1377, ptr noundef %1378, i32 noundef 0, i64 noundef 0, i64 noundef %mul.i.i3221, ptr noundef %1375, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call.i.i.noexc3229 unwind label %lpad1756.loopexit.split-lp

call.i.i.noexc3229:                               ; preds = %if.then.i.i3219
  %1379 = load ptr, ptr @__clewFinish, align 8
  %1380 = load ptr, ptr %m_commandQueue.i.i3222, align 8
  %call6.i.i3232 = invoke i32 %1379(ptr noundef %1380)
          to label %invoke.cont1833 unwind label %lpad1756.loopexit.split-lp

invoke.cont1833:                                  ; preds = %_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i3216, %call.i.i.noexc3229
  %1381 = load i32, ptr %m_size.i.i2991, align 4
  %conv.i3235 = sext i32 %1381 to i64
  %1382 = load i64, ptr %m_size.i.i2595, align 8
  %cmp3.i.i3237 = icmp ult i64 %1382, %conv.i3235
  br i1 %cmp3.i.i3237, label %if.end7.i.i3247, label %_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i3238

if.end7.i.i3247:                                  ; preds = %invoke.cont1833
  %call5.i.i3250 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %worldVertsB1GPU, i64 noundef %conv.i3235, i1 noundef zeroext false)
          to label %call5.i.i.noexc3249 unwind label %lpad1756.loopexit.split-lp

call5.i.i.noexc3249:                              ; preds = %if.end7.i.i3247
  %spec.select.i.i3248 = select i1 %call5.i.i3250, i64 %conv.i3235, i64 0
  br label %_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i3238

_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i3238: ; preds = %call5.i.i.noexc3249, %invoke.cont1833
  %storemerge.i.i3239 = phi i64 [ %conv.i3235, %invoke.cont1833 ], [ %spec.select.i.i3248, %call5.i.i.noexc3249 ]
  store i64 %storemerge.i.i3239, ptr %m_size.i.i2595, align 8
  %tobool3.not.i3240 = icmp eq i32 %1381, 0
  br i1 %tobool3.not.i3240, label %invoke.cont1834, label %if.then.i.i3241

if.then.i.i3241:                                  ; preds = %_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i3238
  %1383 = load ptr, ptr %m_data.i.i2990, align 8
  %mul.i.i3243 = shl nsw i64 %conv.i3235, 4
  %1384 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %m_commandQueue.i.i3244 = getelementptr inbounds %class.b3OpenCLArray, ptr %worldVertsB1GPU, i64 0, i32 5
  %1385 = load ptr, ptr %m_commandQueue.i.i3244, align 8
  %m_clBuffer.i.i3245 = getelementptr inbounds %class.b3OpenCLArray, ptr %worldVertsB1GPU, i64 0, i32 3
  %1386 = load ptr, ptr %m_clBuffer.i.i3245, align 8
  %call.i.i3252 = invoke i32 %1384(ptr noundef %1385, ptr noundef %1386, i32 noundef 0, i64 noundef 0, i64 noundef %mul.i.i3243, ptr noundef %1383, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call.i.i.noexc3251 unwind label %lpad1756.loopexit.split-lp

call.i.i.noexc3251:                               ; preds = %if.then.i.i3241
  %1387 = load ptr, ptr @__clewFinish, align 8
  %1388 = load ptr, ptr %m_commandQueue.i.i3244, align 8
  %call6.i.i3254 = invoke i32 %1387(ptr noundef %1388)
          to label %invoke.cont1834 unwind label %lpad1756.loopexit.split-lp

invoke.cont1834:                                  ; preds = %_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i3238, %call.i.i.noexc3251
  %1389 = load ptr, ptr %m_data.i.i3038, align 8
  %tobool.not.i.i.i3257 = icmp eq ptr %1389, null
  br i1 %tobool.not.i.i.i3257, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3266, label %if.then.i.i.i3258

if.then.i.i.i3258:                                ; preds = %invoke.cont1834
  %1390 = load i8, ptr %m_ownsMemory.i.i3037, align 8
  %1391 = and i8 %1390, 1
  %tobool2.not.i.i.i3260 = icmp eq i8 %1391, 0
  br i1 %tobool2.not.i.i.i3260, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3266, label %if.then3.i.i.i3261

if.then3.i.i.i3261:                               ; preds = %if.then.i.i.i3258
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1389)
          to label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3266 unwind label %terminate.lpad.i3262

terminate.lpad.i3262:                             ; preds = %if.then3.i.i.i3261
  %1392 = landingpad { ptr, i32 }
          catch ptr null
  %1393 = extractvalue { ptr, i32 } %1392, 0
  call void @__clang_call_terminate(ptr %1393) #27
  unreachable

_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3266: ; preds = %invoke.cont1834, %if.then.i.i.i3258, %if.then3.i.i.i3261
  store i8 1, ptr %m_ownsMemory.i.i3037, align 8
  store ptr null, ptr %m_data.i.i3038, align 8
  store i32 0, ptr %m_size.i.i3039, align 4
  store i32 0, ptr %m_capacity.i.i3040, align 8
  %1394 = load ptr, ptr %m_data.i.i3034, align 8
  %tobool.not.i.i.i3268 = icmp eq ptr %1394, null
  br i1 %tobool.not.i.i.i3268, label %_ZN20b3AlignedObjectArrayI15b3GpuChildShapeED2Ev.exit3277, label %if.then.i.i.i3269

if.then.i.i.i3269:                                ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3266
  %1395 = load i8, ptr %m_ownsMemory.i.i3033, align 8
  %1396 = and i8 %1395, 1
  %tobool2.not.i.i.i3271 = icmp eq i8 %1396, 0
  br i1 %tobool2.not.i.i.i3271, label %_ZN20b3AlignedObjectArrayI15b3GpuChildShapeED2Ev.exit3277, label %if.then3.i.i.i3272

if.then3.i.i.i3272:                               ; preds = %if.then.i.i.i3269
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1394)
          to label %_ZN20b3AlignedObjectArrayI15b3GpuChildShapeED2Ev.exit3277 unwind label %terminate.lpad.i3273

terminate.lpad.i3273:                             ; preds = %if.then3.i.i.i3272
  %1397 = landingpad { ptr, i32 }
          catch ptr null
  %1398 = extractvalue { ptr, i32 } %1397, 0
  call void @__clang_call_terminate(ptr %1398) #27
  unreachable

_ZN20b3AlignedObjectArrayI15b3GpuChildShapeED2Ev.exit3277: ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3266, %if.then.i.i.i3269, %if.then3.i.i.i3272
  store i8 1, ptr %m_ownsMemory.i.i3033, align 8
  store ptr null, ptr %m_data.i.i3034, align 8
  store i32 0, ptr %m_size.i.i3035, align 4
  store i32 0, ptr %m_capacity.i.i3036, align 8
  %1399 = load ptr, ptr %m_data.i.i3030, align 8
  %tobool.not.i.i.i3279 = icmp eq ptr %1399, null
  br i1 %tobool.not.i.i.i3279, label %_ZN20b3AlignedObjectArrayIiED2Ev.exit3288, label %if.then.i.i.i3280

if.then.i.i.i3280:                                ; preds = %_ZN20b3AlignedObjectArrayI15b3GpuChildShapeED2Ev.exit3277
  %1400 = load i8, ptr %m_ownsMemory.i.i3029, align 8
  %1401 = and i8 %1400, 1
  %tobool2.not.i.i.i3282 = icmp eq i8 %1401, 0
  br i1 %tobool2.not.i.i.i3282, label %_ZN20b3AlignedObjectArrayIiED2Ev.exit3288, label %if.then3.i.i.i3283

if.then3.i.i.i3283:                               ; preds = %if.then.i.i.i3280
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1399)
          to label %_ZN20b3AlignedObjectArrayIiED2Ev.exit3288 unwind label %terminate.lpad.i3284

terminate.lpad.i3284:                             ; preds = %if.then3.i.i.i3283
  %1402 = landingpad { ptr, i32 }
          catch ptr null
  %1403 = extractvalue { ptr, i32 } %1402, 0
  call void @__clang_call_terminate(ptr %1403) #27
  unreachable

_ZN20b3AlignedObjectArrayIiED2Ev.exit3288:        ; preds = %_ZN20b3AlignedObjectArrayI15b3GpuChildShapeED2Ev.exit3277, %if.then.i.i.i3280, %if.then3.i.i.i3283
  store i8 1, ptr %m_ownsMemory.i.i3029, align 8
  store ptr null, ptr %m_data.i.i3030, align 8
  store i32 0, ptr %m_size.i.i3031, align 4
  store i32 0, ptr %m_capacity.i.i3032, align 8
  %1404 = load ptr, ptr %m_data.i.i3026, align 8
  %tobool.not.i.i.i3290 = icmp eq ptr %1404, null
  br i1 %tobool.not.i.i.i3290, label %_ZN20b3AlignedObjectArrayI9b3GpuFaceED2Ev.exit3299, label %if.then.i.i.i3291

if.then.i.i.i3291:                                ; preds = %_ZN20b3AlignedObjectArrayIiED2Ev.exit3288
  %1405 = load i8, ptr %m_ownsMemory.i.i3025, align 8
  %1406 = and i8 %1405, 1
  %tobool2.not.i.i.i3293 = icmp eq i8 %1406, 0
  br i1 %tobool2.not.i.i.i3293, label %_ZN20b3AlignedObjectArrayI9b3GpuFaceED2Ev.exit3299, label %if.then3.i.i.i3294

if.then3.i.i.i3294:                               ; preds = %if.then.i.i.i3291
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1404)
          to label %_ZN20b3AlignedObjectArrayI9b3GpuFaceED2Ev.exit3299 unwind label %terminate.lpad.i3295

terminate.lpad.i3295:                             ; preds = %if.then3.i.i.i3294
  %1407 = landingpad { ptr, i32 }
          catch ptr null
  %1408 = extractvalue { ptr, i32 } %1407, 0
  call void @__clang_call_terminate(ptr %1408) #27
  unreachable

_ZN20b3AlignedObjectArrayI9b3GpuFaceED2Ev.exit3299: ; preds = %_ZN20b3AlignedObjectArrayIiED2Ev.exit3288, %if.then.i.i.i3291, %if.then3.i.i.i3294
  store i8 1, ptr %m_ownsMemory.i.i3025, align 8
  store ptr null, ptr %m_data.i.i3026, align 8
  store i32 0, ptr %m_size.i.i3027, align 4
  store i32 0, ptr %m_capacity.i.i3028, align 8
  %1409 = load ptr, ptr %m_data.i.i3022, align 8
  %tobool.not.i.i.i3301 = icmp eq ptr %1409, null
  br i1 %tobool.not.i.i.i3301, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3310, label %if.then.i.i.i3302

if.then.i.i.i3302:                                ; preds = %_ZN20b3AlignedObjectArrayI9b3GpuFaceED2Ev.exit3299
  %1410 = load i8, ptr %m_ownsMemory.i.i3021, align 8
  %1411 = and i8 %1410, 1
  %tobool2.not.i.i.i3304 = icmp eq i8 %1411, 0
  br i1 %tobool2.not.i.i.i3304, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3310, label %if.then3.i.i.i3305

if.then3.i.i.i3305:                               ; preds = %if.then.i.i.i3302
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1409)
          to label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3310 unwind label %terminate.lpad.i3306

terminate.lpad.i3306:                             ; preds = %if.then3.i.i.i3305
  %1412 = landingpad { ptr, i32 }
          catch ptr null
  %1413 = extractvalue { ptr, i32 } %1412, 0
  call void @__clang_call_terminate(ptr %1413) #27
  unreachable

_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3310: ; preds = %_ZN20b3AlignedObjectArrayI9b3GpuFaceED2Ev.exit3299, %if.then.i.i.i3302, %if.then3.i.i.i3305
  store i8 1, ptr %m_ownsMemory.i.i3021, align 8
  store ptr null, ptr %m_data.i.i3022, align 8
  store i32 0, ptr %m_size.i.i3023, align 4
  store i32 0, ptr %m_capacity.i.i3024, align 8
  %1414 = load ptr, ptr %m_data.i.i3018, align 8
  %tobool.not.i.i.i3312 = icmp eq ptr %1414, null
  br i1 %tobool.not.i.i.i3312, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3321, label %if.then.i.i.i3313

if.then.i.i.i3313:                                ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3310
  %1415 = load i8, ptr %m_ownsMemory.i.i3017, align 8
  %1416 = and i8 %1415, 1
  %tobool2.not.i.i.i3315 = icmp eq i8 %1416, 0
  br i1 %tobool2.not.i.i.i3315, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3321, label %if.then3.i.i.i3316

if.then3.i.i.i3316:                               ; preds = %if.then.i.i.i3313
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1414)
          to label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3321 unwind label %terminate.lpad.i3317

terminate.lpad.i3317:                             ; preds = %if.then3.i.i.i3316
  %1417 = landingpad { ptr, i32 }
          catch ptr null
  %1418 = extractvalue { ptr, i32 } %1417, 0
  call void @__clang_call_terminate(ptr %1418) #27
  unreachable

_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3321: ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3310, %if.then.i.i.i3313, %if.then3.i.i.i3316
  store i8 1, ptr %m_ownsMemory.i.i3017, align 8
  store ptr null, ptr %m_data.i.i3018, align 8
  store i32 0, ptr %m_size.i.i3019, align 4
  store i32 0, ptr %m_capacity.i.i3020, align 8
  %1419 = load ptr, ptr %m_data.i.i3014, align 8
  %tobool.not.i.i.i3323 = icmp eq ptr %1419, null
  br i1 %tobool.not.i.i.i3323, label %_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataED2Ev.exit3332, label %if.then.i.i.i3324

if.then.i.i.i3324:                                ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3321
  %1420 = load i8, ptr %m_ownsMemory.i.i3013, align 8
  %1421 = and i8 %1420, 1
  %tobool2.not.i.i.i3326 = icmp eq i8 %1421, 0
  br i1 %tobool2.not.i.i.i3326, label %_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataED2Ev.exit3332, label %if.then3.i.i.i3327

if.then3.i.i.i3327:                               ; preds = %if.then.i.i.i3324
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1419)
          to label %_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataED2Ev.exit3332 unwind label %terminate.lpad.i3328

terminate.lpad.i3328:                             ; preds = %if.then3.i.i.i3327
  %1422 = landingpad { ptr, i32 }
          catch ptr null
  %1423 = extractvalue { ptr, i32 } %1422, 0
  call void @__clang_call_terminate(ptr %1423) #27
  unreachable

_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataED2Ev.exit3332: ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3321, %if.then.i.i.i3324, %if.then3.i.i.i3327
  store i8 1, ptr %m_ownsMemory.i.i3013, align 8
  store ptr null, ptr %m_data.i.i3014, align 8
  store i32 0, ptr %m_size.i.i3015, align 4
  store i32 0, ptr %m_capacity.i.i3016, align 8
  %1424 = load ptr, ptr %m_data.i.i3010, align 8
  %tobool.not.i.i.i3334 = icmp eq ptr %1424, null
  br i1 %tobool.not.i.i.i3334, label %_ZN20b3AlignedObjectArrayI6b3AabbED2Ev.exit3343, label %if.then.i.i.i3335

if.then.i.i.i3335:                                ; preds = %_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataED2Ev.exit3332
  %1425 = load i8, ptr %m_ownsMemory.i.i3009, align 8
  %1426 = and i8 %1425, 1
  %tobool2.not.i.i.i3337 = icmp eq i8 %1426, 0
  br i1 %tobool2.not.i.i.i3337, label %_ZN20b3AlignedObjectArrayI6b3AabbED2Ev.exit3343, label %if.then3.i.i.i3338

if.then3.i.i.i3338:                               ; preds = %if.then.i.i.i3335
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1424)
          to label %_ZN20b3AlignedObjectArrayI6b3AabbED2Ev.exit3343 unwind label %terminate.lpad.i3339

terminate.lpad.i3339:                             ; preds = %if.then3.i.i.i3338
  %1427 = landingpad { ptr, i32 }
          catch ptr null
  %1428 = extractvalue { ptr, i32 } %1427, 0
  call void @__clang_call_terminate(ptr %1428) #27
  unreachable

_ZN20b3AlignedObjectArrayI6b3AabbED2Ev.exit3343:  ; preds = %_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataED2Ev.exit3332, %if.then.i.i.i3335, %if.then3.i.i.i3338
  store i8 1, ptr %m_ownsMemory.i.i3009, align 8
  store ptr null, ptr %m_data.i.i3010, align 8
  store i32 0, ptr %m_size.i.i3011, align 4
  store i32 0, ptr %m_capacity.i.i3012, align 8
  %1429 = load ptr, ptr %m_data.i.i3006, align 8
  %tobool.not.i.i.i3345 = icmp eq ptr %1429, null
  br i1 %tobool.not.i.i.i3345, label %_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev.exit3354, label %if.then.i.i.i3346

if.then.i.i.i3346:                                ; preds = %_ZN20b3AlignedObjectArrayI6b3AabbED2Ev.exit3343
  %1430 = load i8, ptr %m_ownsMemory.i.i3005, align 8
  %1431 = and i8 %1430, 1
  %tobool2.not.i.i.i3348 = icmp eq i8 %1431, 0
  br i1 %tobool2.not.i.i.i3348, label %_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev.exit3354, label %if.then3.i.i.i3349

if.then3.i.i.i3349:                               ; preds = %if.then.i.i.i3346
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1429)
          to label %_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev.exit3354 unwind label %terminate.lpad.i3350

terminate.lpad.i3350:                             ; preds = %if.then3.i.i.i3349
  %1432 = landingpad { ptr, i32 }
          catch ptr null
  %1433 = extractvalue { ptr, i32 } %1432, 0
  call void @__clang_call_terminate(ptr %1433) #27
  unreachable

_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev.exit3354: ; preds = %_ZN20b3AlignedObjectArrayI6b3AabbED2Ev.exit3343, %if.then.i.i.i3346, %if.then3.i.i.i3349
  store i8 1, ptr %m_ownsMemory.i.i3005, align 8
  store ptr null, ptr %m_data.i.i3006, align 8
  store i32 0, ptr %m_size.i.i3007, align 4
  store i32 0, ptr %m_capacity.i.i3008, align 8
  %1434 = load ptr, ptr %m_data.i.i3002, align 8
  %tobool.not.i.i.i3356 = icmp eq ptr %1434, null
  br i1 %tobool.not.i.i.i3356, label %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev.exit3365, label %if.then.i.i.i3357

if.then.i.i.i3357:                                ; preds = %_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev.exit3354
  %1435 = load i8, ptr %m_ownsMemory.i.i3001, align 8
  %1436 = and i8 %1435, 1
  %tobool2.not.i.i.i3359 = icmp eq i8 %1436, 0
  br i1 %tobool2.not.i.i.i3359, label %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev.exit3365, label %if.then3.i.i.i3360

if.then3.i.i.i3360:                               ; preds = %if.then.i.i.i3357
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1434)
          to label %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev.exit3365 unwind label %terminate.lpad.i3361

terminate.lpad.i3361:                             ; preds = %if.then3.i.i.i3360
  %1437 = landingpad { ptr, i32 }
          catch ptr null
  %1438 = extractvalue { ptr, i32 } %1437, 0
  call void @__clang_call_terminate(ptr %1438) #27
  unreachable

_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev.exit3365: ; preds = %_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev.exit3354, %if.then.i.i.i3357, %if.then3.i.i.i3360
  store i8 1, ptr %m_ownsMemory.i.i3001, align 8
  store ptr null, ptr %m_data.i.i3002, align 8
  store i32 0, ptr %m_size.i.i3003, align 4
  store i32 0, ptr %m_capacity.i.i3004, align 8
  %1439 = load ptr, ptr %m_data.i.i2998, align 8
  %tobool.not.i.i.i3367 = icmp eq ptr %1439, null
  br i1 %tobool.not.i.i.i3367, label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit3376, label %if.then.i.i.i3368

if.then.i.i.i3368:                                ; preds = %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev.exit3365
  %1440 = load i8, ptr %m_ownsMemory.i.i2997, align 8
  %1441 = and i8 %1440, 1
  %tobool2.not.i.i.i3370 = icmp eq i8 %1441, 0
  br i1 %tobool2.not.i.i.i3370, label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit3376, label %if.then3.i.i.i3371

if.then3.i.i.i3371:                               ; preds = %if.then.i.i.i3368
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1439)
          to label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit3376 unwind label %terminate.lpad.i3372

terminate.lpad.i3372:                             ; preds = %if.then3.i.i.i3371
  %1442 = landingpad { ptr, i32 }
          catch ptr null
  %1443 = extractvalue { ptr, i32 } %1442, 0
  call void @__clang_call_terminate(ptr %1443) #27
  unreachable

_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit3376:  ; preds = %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev.exit3365, %if.then.i.i.i3368, %if.then3.i.i.i3371
  store i8 1, ptr %m_ownsMemory.i.i2997, align 8
  store ptr null, ptr %m_data.i.i2998, align 8
  store i32 0, ptr %m_size.i.i2999, align 4
  store i32 0, ptr %m_capacity.i.i3000, align 8
  %1444 = load ptr, ptr %m_data.i.i2994, align 8
  %tobool.not.i.i.i3378 = icmp eq ptr %1444, null
  br i1 %tobool.not.i.i.i3378, label %_ZN20b3AlignedObjectArrayIiED2Ev.exit3387, label %if.then.i.i.i3379

if.then.i.i.i3379:                                ; preds = %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit3376
  %1445 = load i8, ptr %m_ownsMemory.i.i2993, align 8
  %1446 = and i8 %1445, 1
  %tobool2.not.i.i.i3381 = icmp eq i8 %1446, 0
  br i1 %tobool2.not.i.i.i3381, label %_ZN20b3AlignedObjectArrayIiED2Ev.exit3387, label %if.then3.i.i.i3382

if.then3.i.i.i3382:                               ; preds = %if.then.i.i.i3379
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1444)
          to label %_ZN20b3AlignedObjectArrayIiED2Ev.exit3387 unwind label %terminate.lpad.i3383

terminate.lpad.i3383:                             ; preds = %if.then3.i.i.i3382
  %1447 = landingpad { ptr, i32 }
          catch ptr null
  %1448 = extractvalue { ptr, i32 } %1447, 0
  call void @__clang_call_terminate(ptr %1448) #27
  unreachable

_ZN20b3AlignedObjectArrayIiED2Ev.exit3387:        ; preds = %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit3376, %if.then.i.i.i3379, %if.then3.i.i.i3382
  store i8 1, ptr %m_ownsMemory.i.i2993, align 8
  store i32 0, ptr %m_size.i.i2995, align 4
  store i32 0, ptr %m_capacity.i.i2996, align 8
  %1449 = load ptr, ptr %m_data.i.i2990, align 8
  %tobool.not.i.i.i3389 = icmp eq ptr %1449, null
  br i1 %tobool.not.i.i.i3389, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3398, label %if.then.i.i.i3390

if.then.i.i.i3390:                                ; preds = %_ZN20b3AlignedObjectArrayIiED2Ev.exit3387
  %1450 = load i8, ptr %m_ownsMemory.i.i2989, align 8
  %1451 = and i8 %1450, 1
  %tobool2.not.i.i.i3392 = icmp eq i8 %1451, 0
  br i1 %tobool2.not.i.i.i3392, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3398, label %if.then3.i.i.i3393

if.then3.i.i.i3393:                               ; preds = %if.then.i.i.i3390
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1449)
          to label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3398 unwind label %terminate.lpad.i3394

terminate.lpad.i3394:                             ; preds = %if.then3.i.i.i3393
  %1452 = landingpad { ptr, i32 }
          catch ptr null
  %1453 = extractvalue { ptr, i32 } %1452, 0
  call void @__clang_call_terminate(ptr %1453) #27
  unreachable

_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3398: ; preds = %_ZN20b3AlignedObjectArrayIiED2Ev.exit3387, %if.then.i.i.i3390, %if.then3.i.i.i3393
  store i8 1, ptr %m_ownsMemory.i.i2989, align 8
  store i32 0, ptr %m_size.i.i2991, align 4
  store i32 0, ptr %m_capacity.i.i2992, align 8
  %1454 = load ptr, ptr %m_data.i.i2986, align 8
  %tobool.not.i.i.i3400 = icmp eq ptr %1454, null
  br i1 %tobool.not.i.i.i3400, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3409, label %if.then.i.i.i3401

if.then.i.i.i3401:                                ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3398
  %1455 = load i8, ptr %m_ownsMemory.i.i2985, align 8
  %1456 = and i8 %1455, 1
  %tobool2.not.i.i.i3403 = icmp eq i8 %1456, 0
  br i1 %tobool2.not.i.i.i3403, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3409, label %if.then3.i.i.i3404

if.then3.i.i.i3404:                               ; preds = %if.then.i.i.i3401
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1454)
          to label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3409 unwind label %terminate.lpad.i3405

terminate.lpad.i3405:                             ; preds = %if.then3.i.i.i3404
  %1457 = landingpad { ptr, i32 }
          catch ptr null
  %1458 = extractvalue { ptr, i32 } %1457, 0
  call void @__clang_call_terminate(ptr %1458) #27
  unreachable

_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3409: ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3398, %if.then.i.i.i3401, %if.then3.i.i.i3404
  store i8 1, ptr %m_ownsMemory.i.i2985, align 8
  store i32 0, ptr %m_size.i.i2987, align 4
  store i32 0, ptr %m_capacity.i.i2988, align 8
  %1459 = load ptr, ptr %m_data.i.i2982, align 8
  %tobool.not.i.i.i3411 = icmp eq ptr %1459, null
  br i1 %tobool.not.i.i.i3411, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3420, label %if.then.i.i.i3412

if.then.i.i.i3412:                                ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3409
  %1460 = load i8, ptr %m_ownsMemory.i.i2981, align 8
  %1461 = and i8 %1460, 1
  %tobool2.not.i.i.i3414 = icmp eq i8 %1461, 0
  br i1 %tobool2.not.i.i.i3414, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3420, label %if.then3.i.i.i3415

if.then3.i.i.i3415:                               ; preds = %if.then.i.i.i3412
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1459)
          to label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3420 unwind label %terminate.lpad.i3416

terminate.lpad.i3416:                             ; preds = %if.then3.i.i.i3415
  %1462 = landingpad { ptr, i32 }
          catch ptr null
  %1463 = extractvalue { ptr, i32 } %1462, 0
  call void @__clang_call_terminate(ptr %1463) #27
  unreachable

_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3420: ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3409, %if.then.i.i.i3412, %if.then3.i.i.i3415
  store i8 1, ptr %m_ownsMemory.i.i2981, align 8
  store i32 0, ptr %m_size.i.i2983, align 4
  store i32 0, ptr %m_capacity.i.i2984, align 8
  %1464 = load ptr, ptr %m_data.i.i2978, align 8
  %tobool.not.i.i.i3422 = icmp eq ptr %1464, null
  br i1 %tobool.not.i.i.i3422, label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit3431, label %if.then.i.i.i3423

if.then.i.i.i3423:                                ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3420
  %1465 = load i8, ptr %m_ownsMemory.i.i2977, align 8
  %1466 = and i8 %1465, 1
  %tobool2.not.i.i.i3425 = icmp eq i8 %1466, 0
  br i1 %tobool2.not.i.i.i3425, label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit3431, label %if.then3.i.i.i3426

if.then3.i.i.i3426:                               ; preds = %if.then.i.i.i3423
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1464)
          to label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit3431 unwind label %terminate.lpad.i3427

terminate.lpad.i3427:                             ; preds = %if.then3.i.i.i3426
  %1467 = landingpad { ptr, i32 }
          catch ptr null
  %1468 = extractvalue { ptr, i32 } %1467, 0
  call void @__clang_call_terminate(ptr %1468) #27
  unreachable

_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit3431:  ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3420, %if.then.i.i.i3423, %if.then3.i.i.i3426
  store i8 1, ptr %m_ownsMemory.i.i2977, align 8
  store i32 0, ptr %m_size.i.i2979, align 4
  store i32 0, ptr %m_capacity.i.i2980, align 8
  br label %if.end1853

ehcleanup1836:                                    ; preds = %lpad1756, %lpad1752
  %.pn484 = phi { ptr, i32 } [ %lpad.phi, %lpad1756 ], [ %1298, %lpad1752 ]
  call void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %cpuChildShapes1750) #26
  br label %ehcleanup1837

ehcleanup1837:                                    ; preds = %ehcleanup1836, %lpad1748
  %.pn484.pn = phi { ptr, i32 } [ %.pn484, %ehcleanup1836 ], [ %1297, %lpad1748 ]
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostIndices1746) #26
  br label %ehcleanup1838

ehcleanup1838:                                    ; preds = %ehcleanup1837, %lpad1744
  %.pn484.pn.pn = phi { ptr, i32 } [ %.pn484.pn, %ehcleanup1837 ], [ %1296, %lpad1744 ]
  call void @_ZN20b3AlignedObjectArrayI9b3GpuFaceED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostFaces1742) #26
  br label %ehcleanup1839

ehcleanup1839:                                    ; preds = %ehcleanup1838, %lpad1740
  %.pn484.pn.pn.pn = phi { ptr, i32 } [ %.pn484.pn.pn, %ehcleanup1838 ], [ %1295, %lpad1740 ]
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostUniqueEdges1738) #26
  br label %ehcleanup1840

ehcleanup1840:                                    ; preds = %ehcleanup1839, %lpad1736
  %.pn484.pn.pn.pn.pn = phi { ptr, i32 } [ %.pn484.pn.pn.pn, %ehcleanup1839 ], [ %1294, %lpad1736 ]
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostVertices1734) #26
  br label %ehcleanup1841

ehcleanup1841:                                    ; preds = %ehcleanup1840, %lpad1732
  %.pn484.pn.pn.pn.pn.pn = phi { ptr, i32 } [ %.pn484.pn.pn.pn.pn, %ehcleanup1840 ], [ %1293, %lpad1732 ]
  call void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostConvexData1730) #26
  br label %ehcleanup1842

ehcleanup1842:                                    ; preds = %ehcleanup1841, %lpad1728
  %.pn484.pn.pn.pn.pn.pn.pn = phi { ptr, i32 } [ %.pn484.pn.pn.pn.pn.pn, %ehcleanup1841 ], [ %1292, %lpad1728 ]
  call void @_ZN20b3AlignedObjectArrayI6b3AabbED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostAabbsWorldSpace1726) #26
  br label %ehcleanup1843

ehcleanup1843:                                    ; preds = %ehcleanup1842, %lpad1724
  %.pn484.pn.pn.pn.pn.pn.pn.pn = phi { ptr, i32 } [ %.pn484.pn.pn.pn.pn.pn.pn, %ehcleanup1842 ], [ %1291, %lpad1724 ]
  call void @_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostCollidables1722) #26
  br label %ehcleanup1844

ehcleanup1844:                                    ; preds = %ehcleanup1843, %lpad1720
  %.pn484.pn.pn.pn.pn.pn.pn.pn.pn = phi { ptr, i32 } [ %.pn484.pn.pn.pn.pn.pn.pn.pn, %ehcleanup1843 ], [ %1290, %lpad1720 ]
  call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf1718) #26
  br label %ehcleanup1845

ehcleanup1845:                                    ; preds = %ehcleanup1844, %lpad1716
  %.pn484.pn.pn.pn.pn.pn.pn.pn.pn.pn = phi { ptr, i32 } [ %.pn484.pn.pn.pn.pn.pn.pn.pn.pn, %ehcleanup1844 ], [ %1289, %lpad1716 ]
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %triangleConvexPairsOutHost1713) #26
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %concaveHasSeparatingNormalsCPU) #26
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB1CPU) #26
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldNormalsACPU) #26
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsA1CPU) #26
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU) #26
  br label %ehcleanup2980

if.end1853:                                       ; preds = %invoke.cont1698, %invoke.cont1612, %invoke.cont1411, %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit3431, %if.end1262
  %1469 = load i32, ptr %numConcavePairs, align 4
  %tobool1854.not = icmp eq i32 %1469, 0
  br i1 %tobool1854.not, label %if.then1939, label %if.then1857

if.then1857:                                      ; preds = %if.end1853
  invoke void @b3EnterProfileZone(ptr noundef nonnull @.str.28)
          to label %invoke.cont1859 unwind label %lpad58

invoke.cont1859:                                  ; preds = %if.then1857
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %elem.i3434)
  %1470 = load i64, ptr %m_capacity.i.i.i584, align 8
  %cmp.not.i.i3436 = icmp eq i64 %1470, 0
  br i1 %cmp.not.i.i3436, label %do.body.i.i3441, label %if.then.i.i3437

if.then.i.i3437:                                  ; preds = %invoke.cont1859
  %1471 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %1472 = load ptr, ptr %m_commandQueue.i, align 8
  %1473 = load ptr, ptr %m_clBuffer.i, align 8
  %call3.i.i3443 = invoke i32 %1471(ptr noundef %1472, ptr noundef %1473, i32 noundef 0, i64 noundef 0, i64 noundef 4, ptr noundef nonnull %elem.i3434, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call3.i.i.noexc3442 unwind label %lpad1861

call3.i.i.noexc3442:                              ; preds = %if.then.i.i3437
  %1474 = load ptr, ptr @__clewFinish, align 8
  %1475 = load ptr, ptr %m_commandQueue.i, align 8
  %call6.i.i3445 = invoke i32 %1474(ptr noundef %1475)
          to label %call6.i.i.noexc3444 unwind label %lpad1861

call6.i.i.noexc3444:                              ; preds = %call3.i.i.noexc3442
  %.pre.i3440 = load i32, ptr %elem.i3434, align 4
  br label %invoke.cont1862

do.body.i.i3441:                                  ; preds = %invoke.cont1859
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 285)
          to label %.noexc3446 unwind label %lpad1861

.noexc3446:                                       ; preds = %do.body.i.i3441
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.80)
          to label %invoke.cont1862 unwind label %lpad1861

invoke.cont1862:                                  ; preds = %call6.i.i.noexc3444, %.noexc3446
  %1476 = phi i32 [ %.pre.i3440, %call6.i.i.noexc3444 ], [ undef, %.noexc3446 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %elem.i3434)
  store i32 %1476, ptr %nContacts, align 4
  %m_clBuffer.i3449 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %triangleConvexPairsOut, i64 0, i32 3
  %1477 = load ptr, ptr %m_clBuffer.i3449, align 8
  store ptr %1477, ptr %bInfo1864, align 16
  %m_isReadOnly.i3450 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1864, i64 0, i32 1
  store i8 0, ptr %m_isReadOnly.i3450, align 8
  %arrayinit.element1869 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1864, i64 1
  %1478 = load ptr, ptr %m_clBuffer.i531, align 8
  store ptr %1478, ptr %arrayinit.element1869, align 16
  %m_isReadOnly.i3452 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1864, i64 1, i32 1
  store i8 1, ptr %m_isReadOnly.i3452, align 8
  %arrayinit.element1873 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1864, i64 2
  %1479 = load ptr, ptr %m_clBuffer.i533, align 8
  store ptr %1479, ptr %arrayinit.element1873, align 16
  %m_isReadOnly.i3454 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1864, i64 2, i32 1
  store i8 1, ptr %m_isReadOnly.i3454, align 8
  %arrayinit.element1877 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1864, i64 3
  %1480 = load ptr, ptr %m_clBuffer.i535, align 8
  store ptr %1480, ptr %arrayinit.element1877, align 16
  %m_isReadOnly.i3456 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1864, i64 3, i32 1
  store i8 1, ptr %m_isReadOnly.i3456, align 8
  %arrayinit.element1881 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1864, i64 4
  %1481 = load ptr, ptr %m_clBuffer.i537, align 8
  store ptr %1481, ptr %arrayinit.element1881, align 16
  %m_isReadOnly.i3458 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1864, i64 4, i32 1
  store i8 1, ptr %m_isReadOnly.i3458, align 8
  %arrayinit.element1885 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1864, i64 5
  %1482 = load ptr, ptr %m_clBuffer.i539, align 8
  store ptr %1482, ptr %arrayinit.element1885, align 16
  %m_isReadOnly.i3460 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1864, i64 5, i32 1
  store i8 1, ptr %m_isReadOnly.i3460, align 8
  %arrayinit.element1889 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1864, i64 6
  %1483 = load ptr, ptr %m_clBuffer.i541, align 8
  store ptr %1483, ptr %arrayinit.element1889, align 16
  %m_isReadOnly.i3462 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1864, i64 6, i32 1
  store i8 1, ptr %m_isReadOnly.i3462, align 8
  %arrayinit.element1893 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1864, i64 7
  %1484 = load ptr, ptr %m_clBuffer.i543, align 8
  store ptr %1484, ptr %arrayinit.element1893, align 16
  %m_isReadOnly.i3464 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1864, i64 7, i32 1
  store i8 1, ptr %m_isReadOnly.i3464, align 8
  %arrayinit.element1897 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1864, i64 8
  %m_clBuffer.i3465 = getelementptr inbounds %class.b3OpenCLArray.90, ptr %clAabbsWorldSpace, i64 0, i32 3
  %1485 = load ptr, ptr %m_clBuffer.i3465, align 8
  store ptr %1485, ptr %arrayinit.element1897, align 16
  %m_isReadOnly.i3466 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1864, i64 8, i32 1
  store i8 1, ptr %m_isReadOnly.i3466, align 8
  %arrayinit.element1901 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1864, i64 9
  %1486 = load ptr, ptr %m_clBuffer.i545, align 8
  store ptr %1486, ptr %arrayinit.element1901, align 16
  %m_isReadOnly.i3468 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1864, i64 9, i32 1
  store i8 0, ptr %m_isReadOnly.i3468, align 8
  %arrayinit.element1905 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1864, i64 10
  %1487 = load ptr, ptr %m_clBuffer.i, align 8
  store ptr %1487, ptr %arrayinit.element1905, align 16
  %m_isReadOnly.i3470 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo1864, i64 10, i32 1
  store i8 0, ptr %m_isReadOnly.i3470, align 8
  %1488 = load ptr, ptr %m_queue, align 8
  %m_findConcaveSphereContactsKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 22
  %1489 = load ptr, ptr %m_findConcaveSphereContactsKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher1910, ptr noundef %1488, ptr noundef %1489, ptr noundef nonnull @.str.57)
          to label %invoke.cont1912 unwind label %lpad1861

invoke.cont1912:                                  ; preds = %invoke.cont1862
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher1910, ptr noundef nonnull %bInfo1864, i32 noundef 11)
          to label %invoke.cont1915 unwind label %lpad1914

invoke.cont1915:                                  ; preds = %invoke.cont1912
  %m_enableSerialization.i3471 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1910, i64 0, i32 7
  %1490 = load i8, ptr %m_enableSerialization.i3471, align 4
  %1491 = and i8 %1490, 1
  %tobool.not.i3472 = icmp eq i8 %1491, 0
  br i1 %tobool.not.i3472, label %if.end.i3488, label %if.then.i3473

if.then.i3473:                                    ; preds = %invoke.cont1915
  %m_idx.i3474 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1910, i64 0, i32 3
  %1492 = load i32, ptr %m_idx.i3474, align 8
  %1493 = load i32, ptr %numConcavePairs, align 4
  %m_size.i.i.i3475 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1910, i64 0, i32 5, i32 2
  %1494 = load i32, ptr %m_size.i.i.i3475, align 4
  %m_capacity.i.i.i3476 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1910, i64 0, i32 5, i32 3
  %1495 = load i32, ptr %m_capacity.i.i.i3476, align 8
  %cmp.i.i3477 = icmp eq i32 %1494, %1495
  br i1 %cmp.i.i3477, label %if.then.i.i3493, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3478

if.then.i.i3493:                                  ; preds = %if.then.i3473
  %tobool.not.i.i.i3495 = icmp eq i32 %1494, 0
  %mul.i.i.i3496 = shl nsw i32 %1494, 1
  %cond.i.i.i3497 = select i1 %tobool.not.i.i.i3495, i32 1, i32 %mul.i.i.i3496
  %cmp.i5467 = icmp slt i32 %1494, %cond.i.i.i3497
  br i1 %cmp.i5467, label %if.then.i5469, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3478

if.then.i5469:                                    ; preds = %if.then.i.i3493
  %tobool.not.i.i5470 = icmp eq i32 %cond.i.i.i3497, 0
  br i1 %tobool.not.i.i5470, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5498, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5471

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5471: ; preds = %if.then.i5469
  %conv.i.i.i5472 = sext i32 %cond.i.i.i3497 to i64
  %mul.i.i.i5473 = shl nsw i64 %conv.i.i.i5472, 5
  %call.i.i.i5501 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i5473, i32 noundef 16)
          to label %call.i.i.i.noexc5500 unwind label %lpad1914

call.i.i.i.noexc5500:                             ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5471
  %cmp3.i5474 = icmp eq ptr %call.i.i.i5501, null
  br i1 %cmp3.i5474, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5498, label %if.then.split.i5475

if.then.split.i5475:                              ; preds = %call.i.i.i.noexc5500
  %1496 = load i32, ptr %m_size.i.i.i3475, align 4
  %cmp4.i.i5477 = icmp sgt i32 %1496, 0
  br i1 %cmp4.i.i5477, label %for.body.lr.ph.i.i5489, label %if.end.i5478

for.body.lr.ph.i.i5489:                           ; preds = %if.then.split.i5475
  %m_data.i.i5490 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1910, i64 0, i32 5, i32 5
  %wide.trip.count.i.i5491 = zext nneg i32 %1496 to i64
  br label %for.body.i.i5492

for.body.i.i5492:                                 ; preds = %for.body.i.i5492, %for.body.lr.ph.i.i5489
  %indvars.iv.i.i5493 = phi i64 [ 0, %for.body.lr.ph.i.i5489 ], [ %indvars.iv.next.i.i5496, %for.body.i.i5492 ]
  %arrayidx.i.i5494 = getelementptr inbounds %struct.b3KernelArgData, ptr %call.i.i.i5501, i64 %indvars.iv.i.i5493
  %1497 = load ptr, ptr %m_data.i.i5490, align 8
  %arrayidx3.i.i5495 = getelementptr inbounds %struct.b3KernelArgData, ptr %1497, i64 %indvars.iv.i.i5493
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i.i5494, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i.i5495, i64 32, i1 false)
  %indvars.iv.next.i.i5496 = add nuw nsw i64 %indvars.iv.i.i5493, 1
  %exitcond.not.i.i5497 = icmp eq i64 %indvars.iv.next.i.i5496, %wide.trip.count.i.i5491
  br i1 %exitcond.not.i.i5497, label %if.end.i5478, label %for.body.i.i5492, !llvm.loop !64

_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5498: ; preds = %call.i.i.i.noexc5500, %if.then.i5469
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc5502 unwind label %lpad1914

.noexc5502:                                       ; preds = %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5498
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc5503 unwind label %lpad1914

.noexc5503:                                       ; preds = %.noexc5502
  store i32 0, ptr %m_size.i.i.i3475, align 4
  br label %if.end.i5478

if.end.i5478:                                     ; preds = %for.body.i.i5492, %.noexc5503, %if.then.split.i5475
  %retval.0.i25.i5479 = phi ptr [ null, %.noexc5503 ], [ %call.i.i.i5501, %if.then.split.i5475 ], [ %call.i.i.i5501, %for.body.i.i5492 ]
  %_Count.addr.0.i5480 = phi i32 [ 0, %.noexc5503 ], [ %cond.i.i.i3497, %if.then.split.i5475 ], [ %cond.i.i.i3497, %for.body.i.i5492 ]
  %m_data.i20.i5481 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1910, i64 0, i32 5, i32 5
  %1498 = load ptr, ptr %m_data.i20.i5481, align 8
  %tobool.not.i21.i5482 = icmp eq ptr %1498, null
  br i1 %tobool.not.i21.i5482, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5487, label %if.then.i22.i5483

if.then.i22.i5483:                                ; preds = %if.end.i5478
  %m_ownsMemory.i.i5484 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1910, i64 0, i32 5, i32 6
  %1499 = load i8, ptr %m_ownsMemory.i.i5484, align 8
  %1500 = and i8 %1499, 1
  %tobool2.not.i.i5485 = icmp eq i8 %1500, 0
  br i1 %tobool2.not.i.i5485, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5487, label %if.then3.i.i5486

if.then3.i.i5486:                                 ; preds = %if.then.i22.i5483
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1498)
          to label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5487 unwind label %lpad1914

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5487: ; preds = %if.then3.i.i5486, %if.then.i22.i5483, %if.end.i5478
  %m_ownsMemory.i5488 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1910, i64 0, i32 5, i32 6
  store i8 1, ptr %m_ownsMemory.i5488, align 8
  store ptr %retval.0.i25.i5479, ptr %m_data.i20.i5481, align 8
  store i32 %_Count.addr.0.i5480, ptr %m_capacity.i.i.i3476, align 8
  %.pre.i.i3498.pre = load i32, ptr %m_size.i.i.i3475, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3478

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3478: ; preds = %if.then.i.i3493, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5487, %if.then.i3473
  %1501 = phi i32 [ %1494, %if.then.i3473 ], [ %.pre.i.i3498.pre, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5487 ], [ %1494, %if.then.i.i3493 ]
  %m_data.i.i3479 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1910, i64 0, i32 5, i32 5
  %1502 = load ptr, ptr %m_data.i.i3479, align 8
  %idxprom.i.i3480 = sext i32 %1501 to i64
  %arrayidx.i.i3481 = getelementptr inbounds %struct.b3KernelArgData, ptr %1502, i64 %idxprom.i.i3480
  store i32 0, ptr %arrayidx.i.i3481, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i3482 = getelementptr inbounds i8, ptr %arrayidx.i.i3481, i64 4
  store i32 %1492, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i3482, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i3483 = getelementptr inbounds i8, ptr %arrayidx.i.i3481, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i3483, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i3484 = getelementptr inbounds i8, ptr %arrayidx.i.i3481, i64 16
  store i32 %1493, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i3484, align 16
  %1503 = load i32, ptr %m_size.i.i.i3475, align 4
  %inc.i.i3485 = add nsw i32 %1503, 1
  store i32 %inc.i.i3485, ptr %m_size.i.i.i3475, align 4
  %m_serializationSizeInBytes.i3486 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1910, i64 0, i32 6
  %1504 = load i32, ptr %m_serializationSizeInBytes.i3486, align 8
  %add.i3487 = add i32 %1504, 32
  store i32 %add.i3487, ptr %m_serializationSizeInBytes.i3486, align 8
  br label %if.end.i3488

if.end.i3488:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3478, %invoke.cont1915
  %1505 = load ptr, ptr @__clewSetKernelArg, align 8
  %m_kernel.i3489 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1910, i64 0, i32 2
  %1506 = load ptr, ptr %m_kernel.i3489, align 8
  %m_idx3.i3490 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1910, i64 0, i32 3
  %1507 = load i32, ptr %m_idx3.i3490, align 8
  %inc.i3491 = add nsw i32 %1507, 1
  store i32 %inc.i3491, ptr %m_idx3.i3490, align 8
  %call.i34923500 = invoke i32 %1505(ptr noundef %1506, i32 noundef %1507, i64 noundef 4, ptr noundef nonnull %numConcavePairs)
          to label %invoke.cont1916 unwind label %lpad1914

invoke.cont1916:                                  ; preds = %if.end.i3488
  %1508 = load i8, ptr %m_enableSerialization.i3471, align 4
  %1509 = and i8 %1508, 1
  %tobool.not.i3503 = icmp eq i8 %1509, 0
  br i1 %tobool.not.i3503, label %if.end.i3519, label %if.then.i3504

if.then.i3504:                                    ; preds = %invoke.cont1916
  %1510 = load i32, ptr %m_idx3.i3490, align 8
  %1511 = load i32, ptr %maxContactCapacity.addr, align 4
  %m_size.i.i.i3506 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1910, i64 0, i32 5, i32 2
  %1512 = load i32, ptr %m_size.i.i.i3506, align 4
  %m_capacity.i.i.i3507 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1910, i64 0, i32 5, i32 3
  %1513 = load i32, ptr %m_capacity.i.i.i3507, align 8
  %cmp.i.i3508 = icmp eq i32 %1512, %1513
  br i1 %cmp.i.i3508, label %if.then.i.i3524, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3509

if.then.i.i3524:                                  ; preds = %if.then.i3504
  %tobool.not.i.i.i3526 = icmp eq i32 %1512, 0
  %mul.i.i.i3527 = shl nsw i32 %1512, 1
  %cond.i.i.i3528 = select i1 %tobool.not.i.i.i3526, i32 1, i32 %mul.i.i.i3527
  %cmp.i5507 = icmp slt i32 %1512, %cond.i.i.i3528
  br i1 %cmp.i5507, label %if.then.i5509, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3509

if.then.i5509:                                    ; preds = %if.then.i.i3524
  %tobool.not.i.i5510 = icmp eq i32 %cond.i.i.i3528, 0
  br i1 %tobool.not.i.i5510, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5538, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5511

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5511: ; preds = %if.then.i5509
  %conv.i.i.i5512 = sext i32 %cond.i.i.i3528 to i64
  %mul.i.i.i5513 = shl nsw i64 %conv.i.i.i5512, 5
  %call.i.i.i5541 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i5513, i32 noundef 16)
          to label %call.i.i.i.noexc5540 unwind label %lpad1914

call.i.i.i.noexc5540:                             ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5511
  %cmp3.i5514 = icmp eq ptr %call.i.i.i5541, null
  br i1 %cmp3.i5514, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5538, label %if.then.split.i5515

if.then.split.i5515:                              ; preds = %call.i.i.i.noexc5540
  %1514 = load i32, ptr %m_size.i.i.i3506, align 4
  %cmp4.i.i5517 = icmp sgt i32 %1514, 0
  br i1 %cmp4.i.i5517, label %for.body.lr.ph.i.i5529, label %if.end.i5518

for.body.lr.ph.i.i5529:                           ; preds = %if.then.split.i5515
  %m_data.i.i5530 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1910, i64 0, i32 5, i32 5
  %wide.trip.count.i.i5531 = zext nneg i32 %1514 to i64
  br label %for.body.i.i5532

for.body.i.i5532:                                 ; preds = %for.body.i.i5532, %for.body.lr.ph.i.i5529
  %indvars.iv.i.i5533 = phi i64 [ 0, %for.body.lr.ph.i.i5529 ], [ %indvars.iv.next.i.i5536, %for.body.i.i5532 ]
  %arrayidx.i.i5534 = getelementptr inbounds %struct.b3KernelArgData, ptr %call.i.i.i5541, i64 %indvars.iv.i.i5533
  %1515 = load ptr, ptr %m_data.i.i5530, align 8
  %arrayidx3.i.i5535 = getelementptr inbounds %struct.b3KernelArgData, ptr %1515, i64 %indvars.iv.i.i5533
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i.i5534, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i.i5535, i64 32, i1 false)
  %indvars.iv.next.i.i5536 = add nuw nsw i64 %indvars.iv.i.i5533, 1
  %exitcond.not.i.i5537 = icmp eq i64 %indvars.iv.next.i.i5536, %wide.trip.count.i.i5531
  br i1 %exitcond.not.i.i5537, label %if.end.i5518, label %for.body.i.i5532, !llvm.loop !64

_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5538: ; preds = %call.i.i.i.noexc5540, %if.then.i5509
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc5542 unwind label %lpad1914

.noexc5542:                                       ; preds = %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5538
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc5543 unwind label %lpad1914

.noexc5543:                                       ; preds = %.noexc5542
  store i32 0, ptr %m_size.i.i.i3506, align 4
  br label %if.end.i5518

if.end.i5518:                                     ; preds = %for.body.i.i5532, %.noexc5543, %if.then.split.i5515
  %retval.0.i25.i5519 = phi ptr [ null, %.noexc5543 ], [ %call.i.i.i5541, %if.then.split.i5515 ], [ %call.i.i.i5541, %for.body.i.i5532 ]
  %_Count.addr.0.i5520 = phi i32 [ 0, %.noexc5543 ], [ %cond.i.i.i3528, %if.then.split.i5515 ], [ %cond.i.i.i3528, %for.body.i.i5532 ]
  %m_data.i20.i5521 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1910, i64 0, i32 5, i32 5
  %1516 = load ptr, ptr %m_data.i20.i5521, align 8
  %tobool.not.i21.i5522 = icmp eq ptr %1516, null
  br i1 %tobool.not.i21.i5522, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5527, label %if.then.i22.i5523

if.then.i22.i5523:                                ; preds = %if.end.i5518
  %m_ownsMemory.i.i5524 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1910, i64 0, i32 5, i32 6
  %1517 = load i8, ptr %m_ownsMemory.i.i5524, align 8
  %1518 = and i8 %1517, 1
  %tobool2.not.i.i5525 = icmp eq i8 %1518, 0
  br i1 %tobool2.not.i.i5525, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5527, label %if.then3.i.i5526

if.then3.i.i5526:                                 ; preds = %if.then.i22.i5523
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1516)
          to label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5527 unwind label %lpad1914

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5527: ; preds = %if.then3.i.i5526, %if.then.i22.i5523, %if.end.i5518
  %m_ownsMemory.i5528 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1910, i64 0, i32 5, i32 6
  store i8 1, ptr %m_ownsMemory.i5528, align 8
  store ptr %retval.0.i25.i5519, ptr %m_data.i20.i5521, align 8
  store i32 %_Count.addr.0.i5520, ptr %m_capacity.i.i.i3507, align 8
  %.pre.i.i3529.pre = load i32, ptr %m_size.i.i.i3506, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3509

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3509: ; preds = %if.then.i.i3524, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5527, %if.then.i3504
  %1519 = phi i32 [ %1512, %if.then.i3504 ], [ %.pre.i.i3529.pre, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5527 ], [ %1512, %if.then.i.i3524 ]
  %m_data.i.i3510 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1910, i64 0, i32 5, i32 5
  %1520 = load ptr, ptr %m_data.i.i3510, align 8
  %idxprom.i.i3511 = sext i32 %1519 to i64
  %arrayidx.i.i3512 = getelementptr inbounds %struct.b3KernelArgData, ptr %1520, i64 %idxprom.i.i3511
  store i32 0, ptr %arrayidx.i.i3512, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i3513 = getelementptr inbounds i8, ptr %arrayidx.i.i3512, i64 4
  store i32 %1510, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i3513, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i3514 = getelementptr inbounds i8, ptr %arrayidx.i.i3512, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i3514, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i3515 = getelementptr inbounds i8, ptr %arrayidx.i.i3512, i64 16
  store i32 %1511, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i3515, align 16
  %1521 = load i32, ptr %m_size.i.i.i3506, align 4
  %inc.i.i3516 = add nsw i32 %1521, 1
  store i32 %inc.i.i3516, ptr %m_size.i.i.i3506, align 4
  %m_serializationSizeInBytes.i3517 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1910, i64 0, i32 6
  %1522 = load i32, ptr %m_serializationSizeInBytes.i3517, align 8
  %add.i3518 = add i32 %1522, 32
  store i32 %add.i3518, ptr %m_serializationSizeInBytes.i3517, align 8
  br label %if.end.i3519

if.end.i3519:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3509, %invoke.cont1916
  %1523 = load ptr, ptr @__clewSetKernelArg, align 8
  %1524 = load ptr, ptr %m_kernel.i3489, align 8
  %1525 = load i32, ptr %m_idx3.i3490, align 8
  %inc.i3522 = add nsw i32 %1525, 1
  store i32 %inc.i3522, ptr %m_idx3.i3490, align 8
  %call.i35233531 = invoke i32 %1523(ptr noundef %1524, i32 noundef %1525, i64 noundef 4, ptr noundef nonnull %maxContactCapacity.addr)
          to label %invoke.cont1917 unwind label %lpad1914

invoke.cont1917:                                  ; preds = %if.end.i3519
  %1526 = load i32, ptr %numConcavePairs, align 4
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %gRange.i.i3533)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %lRange.i.i3534)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %gRange.i.i3533, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %lRange.i.i3534, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  store i64 64, ptr %lRange.i.i3534, align 16
  %arrayidx3.i.i3535 = getelementptr inbounds [3 x i64], ptr %lRange.i.i3534, i64 0, i64 1
  store i64 1, ptr %arrayidx3.i.i3535, align 8
  %conv5.i.i3536 = sext i32 %1526 to i64
  %div.i.i35376136 = lshr i64 %conv5.i.i3536, 6
  %rem.i.i3538 = and i64 %conv5.i.i3536, 63
  %tobool.not.i.i3539 = icmp ne i64 %rem.i.i3538, 0
  %conv9.i.i3540 = zext i1 %tobool.not.i.i3539 to i64
  %add.i.i3541 = add nuw nsw i64 %div.i.i35376136, %conv9.i.i3540
  %.sroa.speculated8.i.i3542 = call i64 @llvm.umax.i64(i64 %add.i.i3541, i64 1)
  %mul.i.i3543 = shl i64 %.sroa.speculated8.i.i3542, 6
  store i64 %mul.i.i3543, ptr %gRange.i.i3533, align 16
  %arrayidx27.i.i3544 = getelementptr inbounds [3 x i64], ptr %gRange.i.i3533, i64 0, i64 1
  store i64 1, ptr %arrayidx27.i.i3544, align 8
  %1527 = load ptr, ptr @__clewEnqueueNDRangeKernel, align 8
  %m_commandQueue.i.i3545 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher1910, i64 0, i32 1
  %1528 = load ptr, ptr %m_commandQueue.i.i3545, align 8
  %1529 = load ptr, ptr %m_kernel.i3489, align 8
  %call32.i.i3551 = invoke i32 %1527(ptr noundef %1528, ptr noundef %1529, i32 noundef 2, ptr noundef null, ptr noundef nonnull %gRange.i.i3533, ptr noundef nonnull %lRange.i.i3534, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call32.i.i.noexc3550 unwind label %lpad1914

call32.i.i.noexc3550:                             ; preds = %invoke.cont1917
  %cmp.not.i.i3547 = icmp eq i32 %call32.i.i3551, 0
  br i1 %cmp.not.i.i3547, label %invoke.cont1919, label %if.then.i.i3548

if.then.i.i3548:                                  ; preds = %call32.i.i.noexc3550
  %call33.i.i3549 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.74, i32 noundef %call32.i.i3551)
  br label %invoke.cont1919

invoke.cont1919:                                  ; preds = %if.then.i.i3548, %call32.i.i.noexc3550
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %gRange.i.i3533)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %lRange.i.i3534)
  %1530 = load ptr, ptr @__clewFinish, align 8
  %1531 = load ptr, ptr %m_queue, align 8
  %call1922 = invoke i32 %1530(ptr noundef %1531)
          to label %invoke.cont1921 unwind label %lpad1914

invoke.cont1921:                                  ; preds = %invoke.cont1919
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %elem.i3553)
  %1532 = load i64, ptr %m_capacity.i.i.i584, align 8
  %cmp.not.i.i3555 = icmp eq i64 %1532, 0
  br i1 %cmp.not.i.i3555, label %do.body.i.i3560, label %if.then.i.i3556

if.then.i.i3556:                                  ; preds = %invoke.cont1921
  %1533 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %1534 = load ptr, ptr %m_commandQueue.i, align 8
  %1535 = load ptr, ptr %m_clBuffer.i, align 8
  %call3.i.i3562 = invoke i32 %1533(ptr noundef %1534, ptr noundef %1535, i32 noundef 0, i64 noundef 0, i64 noundef 4, ptr noundef nonnull %elem.i3553, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call3.i.i.noexc3561 unwind label %lpad1914

call3.i.i.noexc3561:                              ; preds = %if.then.i.i3556
  %1536 = load ptr, ptr @__clewFinish, align 8
  %1537 = load ptr, ptr %m_commandQueue.i, align 8
  %call6.i.i3564 = invoke i32 %1536(ptr noundef %1537)
          to label %invoke.cont1924 unwind label %lpad1914

do.body.i.i3560:                                  ; preds = %invoke.cont1921
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 285)
          to label %.noexc3565 unwind label %lpad1914

.noexc3565:                                       ; preds = %do.body.i.i3560
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.80)
          to label %invoke.cont1924.thread unwind label %lpad1914

invoke.cont1924.thread:                           ; preds = %.noexc3565
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %elem.i3553)
  br label %do.body1928

invoke.cont1924:                                  ; preds = %call3.i.i.noexc3561
  %.pre.i3559 = load i32, ptr %elem.i3553, align 4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %elem.i3553)
  store i32 %.pre.i3559, ptr %nContacts, align 4
  %1538 = load i32, ptr %maxContactCapacity.addr, align 4
  %cmp1926.not = icmp slt i32 %.pre.i3559, %1538
  br i1 %cmp1926.not, label %if.end1933, label %do.body1928

do.body1928:                                      ; preds = %invoke.cont1924.thread, %invoke.cont1924
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.31, i32 noundef 3815)
          to label %invoke.cont1929 unwind label %lpad1914

invoke.cont1929:                                  ; preds = %do.body1928
  %1539 = load i32, ptr %nContacts, align 4
  %1540 = load i32, ptr %maxContactCapacity.addr, align 4
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.41, i32 noundef %1539, i32 noundef %1540)
          to label %do.end1932 unwind label %lpad1914

do.end1932:                                       ; preds = %invoke.cont1929
  %1541 = load i32, ptr %maxContactCapacity.addr, align 4
  store i32 %1541, ptr %nContacts, align 4
  br label %if.end1933

lpad1861:                                         ; preds = %.noexc3446, %do.body.i.i3441, %call3.i.i.noexc3442, %if.then.i.i3437, %invoke.cont1862
  %1542 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup1935

lpad1914:                                         ; preds = %if.then3.i.i5526, %.noexc5542, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5538, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5511, %if.then3.i.i5486, %.noexc5502, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5498, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5471, %.noexc3565, %do.body.i.i3560, %call3.i.i.noexc3561, %if.then.i.i3556, %invoke.cont1917, %if.end.i3519, %if.end.i3488, %invoke.cont1929, %do.body1928, %invoke.cont1919, %invoke.cont1912
  %1543 = landingpad { ptr, i32 }
          cleanup
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1910) #26
  br label %ehcleanup1935

if.end1933:                                       ; preds = %do.end1932, %invoke.cont1924
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher1910) #26
  invoke void @b3LeaveProfileZone()
          to label %if.then1939 unwind label %terminate.lpad.i3568

terminate.lpad.i3568:                             ; preds = %if.end1933
  %1544 = landingpad { ptr, i32 }
          catch ptr null
  %1545 = extractvalue { ptr, i32 } %1544, 0
  call void @__clang_call_terminate(ptr %1545) #27
  unreachable

ehcleanup1935:                                    ; preds = %lpad1914, %lpad1861
  %.pn506 = phi { ptr, i32 } [ %1543, %lpad1914 ], [ %1542, %lpad1861 ]
  invoke void @b3LeaveProfileZone()
          to label %ehcleanup2980 unwind label %terminate.lpad.i3570

terminate.lpad.i3570:                             ; preds = %ehcleanup1935
  %1546 = landingpad { ptr, i32 }
          catch ptr null
  %1547 = extractvalue { ptr, i32 } %1546, 0
  call void @__clang_call_terminate(ptr %1547) #27
  unreachable

if.then1939:                                      ; preds = %if.end1933, %if.end1853
  %1548 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %1549 = load ptr, ptr %m_commandQueue.i, align 8
  %1550 = load ptr, ptr %m_clBuffer.i, align 8
  %call.i35753578 = invoke i32 %1548(ptr noundef %1549, ptr noundef %1550, i32 noundef 0, i64 noundef 0, i64 noundef 4, ptr noundef nonnull %nContacts, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call.i3575.noexc unwind label %lpad58

call.i3575.noexc:                                 ; preds = %if.then1939
  %1551 = load ptr, ptr @__clewFinish, align 8
  %1552 = load ptr, ptr %m_commandQueue.i, align 8
  %call6.i35763579 = invoke i32 %1551(ptr noundef %1552)
          to label %invoke.cont1941 unwind label %lpad58

invoke.cont1941:                                  ; preds = %call.i3575.noexc
  %1553 = load i32, ptr %numConcavePairs, align 4
  %tobool1942.not = icmp eq i32 %1553, 0
  br i1 %tobool1942.not, label %if.then2293, label %if.then1945

if.then1945:                                      ; preds = %invoke.cont1941
  %1554 = load i32, ptr %vertexFaceCapacity, align 4
  %mul1946 = mul nsw i32 %1554, %1553
  %conv1947 = sext i32 %mul1946 to i64
  %m_size.i.i3581 = getelementptr inbounds %class.b3OpenCLArray, ptr %worldVertsB2GPU, i64 0, i32 1
  %1555 = load i64, ptr %m_size.i.i3581, align 8
  %cmp3.i3582 = icmp ult i64 %1555, %conv1947
  br i1 %cmp3.i3582, label %if.end7.i3585, label %invoke.cont1948

if.end7.i3585:                                    ; preds = %if.then1945
  %call5.i3588 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %worldVertsB2GPU, i64 noundef %conv1947, i1 noundef zeroext true)
          to label %call5.i.noexc3587 unwind label %lpad58

call5.i.noexc3587:                                ; preds = %if.end7.i3585
  %spec.select.i3586 = select i1 %call5.i3588, i64 %conv1947, i64 0
  br label %invoke.cont1948

invoke.cont1948:                                  ; preds = %call5.i.noexc3587, %if.then1945
  %storemerge.i3583 = phi i64 [ %conv1947, %if.then1945 ], [ %spec.select.i3586, %call5.i.noexc3587 ]
  store i64 %storemerge.i3583, ptr %m_size.i.i3581, align 8
  %1556 = load i8, ptr @clipConcaveFacesAndFindContactsCPU, align 1
  %1557 = and i8 %1556, 1
  %tobool1950.not = icmp eq i8 %1557, 0
  br i1 %tobool1950.not, label %if.else2016, label %invoke.cont1962

invoke.cont1962:                                  ; preds = %invoke.cont1948
  %m_ownsMemory.i.i3590 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %clippingFacesOutCPU1952, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i3590, align 8
  %m_data.i.i3591 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %clippingFacesOutCPU1952, i64 0, i32 5
  store ptr null, ptr %m_data.i.i3591, align 8
  %m_size.i.i3592 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %clippingFacesOutCPU1952, i64 0, i32 2
  store i32 0, ptr %m_size.i.i3592, align 4
  %m_capacity.i.i3593 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %clippingFacesOutCPU1952, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i3593, align 8
  %m_ownsMemory.i.i3594 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldVertsA1CPU1954, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i3594, align 8
  %m_data.i.i3595 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldVertsA1CPU1954, i64 0, i32 5
  store ptr null, ptr %m_data.i.i3595, align 8
  %m_size.i.i3596 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldVertsA1CPU1954, i64 0, i32 2
  store i32 0, ptr %m_size.i.i3596, align 4
  %m_capacity.i.i3597 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldVertsA1CPU1954, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i3597, align 8
  %m_ownsMemory.i.i3598 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldNormalsACPU1957, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i3598, align 8
  %m_data.i.i3599 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldNormalsACPU1957, i64 0, i32 5
  store ptr null, ptr %m_data.i.i3599, align 8
  %m_size.i.i3600 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldNormalsACPU1957, i64 0, i32 2
  store i32 0, ptr %m_size.i.i3600, align 4
  %m_capacity.i.i3601 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldNormalsACPU1957, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i3601, align 8
  %m_ownsMemory.i.i3602 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldVertsB1CPU1960, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i3602, align 8
  %m_data.i.i3603 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldVertsB1CPU1960, i64 0, i32 5
  store ptr null, ptr %m_data.i.i3603, align 8
  %m_size.i.i3604 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldVertsB1CPU1960, i64 0, i32 2
  store i32 0, ptr %m_size.i.i3604, align 4
  %m_capacity.i.i3605 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldVertsB1CPU1960, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i3605, align 8
  invoke void @_ZNK13b3OpenCLArrayI6b3Int4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %clippingFacesOutGPU, ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU1952, i1 noundef zeroext true)
          to label %invoke.cont1964 unwind label %lpad1963

invoke.cont1964:                                  ; preds = %invoke.cont1962
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %worldVertsA1GPU, ptr noundef nonnull align 8 dereferenceable(25) %worldVertsA1CPU1954, i1 noundef zeroext true)
          to label %invoke.cont1965 unwind label %lpad1963

invoke.cont1965:                                  ; preds = %invoke.cont1964
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %worldNormalsAGPU, ptr noundef nonnull align 8 dereferenceable(25) %worldNormalsACPU1957, i1 noundef zeroext true)
          to label %invoke.cont1966 unwind label %lpad1963

invoke.cont1966:                                  ; preds = %invoke.cont1965
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %worldVertsB1GPU, ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB1CPU1960, i1 noundef zeroext true)
          to label %invoke.cont1969 unwind label %lpad1963

invoke.cont1969:                                  ; preds = %invoke.cont1966
  %m_ownsMemory.i.i3606 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %concaveHasSeparatingNormalsCPU1968, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i3606, align 8
  %m_data.i.i3607 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %concaveHasSeparatingNormalsCPU1968, i64 0, i32 5
  store ptr null, ptr %m_data.i.i3607, align 8
  %m_size.i.i3608 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %concaveHasSeparatingNormalsCPU1968, i64 0, i32 2
  store i32 0, ptr %m_size.i.i3608, align 4
  %m_capacity.i.i3609 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %concaveHasSeparatingNormalsCPU1968, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i3609, align 8
  invoke void @_ZNK13b3OpenCLArrayIiE10copyToHostER20b3AlignedObjectArrayIiEb(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveHasSeparatingNormals, ptr noundef nonnull align 8 dereferenceable(25) %concaveHasSeparatingNormalsCPU1968, i1 noundef zeroext true)
          to label %invoke.cont1974 unwind label %lpad1971

invoke.cont1974:                                  ; preds = %invoke.cont1969
  %m_ownsMemory.i.i3610 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %concaveSepNormalsHost1973, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i3610, align 8
  %m_data.i.i3611 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %concaveSepNormalsHost1973, i64 0, i32 5
  store ptr null, ptr %m_data.i.i3611, align 8
  %m_size.i.i3612 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %concaveSepNormalsHost1973, i64 0, i32 2
  store i32 0, ptr %m_size.i.i3612, align 4
  %m_capacity.i.i3613 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %concaveSepNormalsHost1973, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i3613, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveSepNormals, ptr noundef nonnull align 8 dereferenceable(25) %concaveSepNormalsHost1973, i1 noundef zeroext true)
          to label %invoke.cont1978 unwind label %lpad1976

invoke.cont1978:                                  ; preds = %invoke.cont1974
  %m_ownsMemory.i.i3614 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldVertsB2CPU, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i3614, align 8
  %m_data.i.i3615 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldVertsB2CPU, i64 0, i32 5
  store ptr null, ptr %m_data.i.i3615, align 8
  %m_size.i.i3616 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldVertsB2CPU, i64 0, i32 2
  store i32 0, ptr %m_size.i.i3616, align 4
  %m_capacity.i.i3617 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldVertsB2CPU, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i3617, align 8
  %1558 = load i64, ptr %m_size.i.i3581, align 8
  %conv1982 = trunc i64 %1558 to i32
  %cmp4.i3620 = icmp sgt i32 %conv1982, 0
  br i1 %cmp4.i3620, label %_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit.i5551, label %_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_.exit3630

_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit.i5551: ; preds = %invoke.cont1978
  %conv.i.i.i5552 = shl i64 %1558, 4
  %mul.i.i.i5553 = and i64 %conv.i.i.i5552, 68719476720
  %call.i.i.i5581 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i5553, i32 noundef 16)
          to label %call.i.i.i.noexc5580 unwind label %lpad1979

call.i.i.i.noexc5580:                             ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit.i5551
  %cmp3.i5554 = icmp eq ptr %call.i.i.i5581, null
  br i1 %cmp3.i5554, label %_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i5578, label %.noexc3629

_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i5578: ; preds = %call.i.i.i.noexc5580
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc5582 unwind label %lpad1979

.noexc5582:                                       ; preds = %_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i5578
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc3629 unwind label %lpad1979

.noexc3629:                                       ; preds = %.noexc5582, %call.i.i.i.noexc5580
  %_Count.addr.0.i5560 = phi i32 [ %conv1982, %call.i.i.i.noexc5580 ], [ 0, %.noexc5582 ]
  store i8 1, ptr %m_ownsMemory.i.i3614, align 8
  store ptr %call.i.i.i5581, ptr %m_data.i.i3615, align 8
  store i32 %_Count.addr.0.i5560, ptr %m_capacity.i.i3617, align 8
  %wide.trip.count.i3623 = and i64 %1558, 4294967295
  br label %for.body9.i3624

for.body9.i3624:                                  ; preds = %for.body9.i3624, %.noexc3629
  %indvars.iv.i3625 = phi i64 [ 0, %.noexc3629 ], [ %indvars.iv.next.i3627, %for.body9.i3624 ]
  %arrayidx12.i3626 = getelementptr inbounds %class.b3Vector3, ptr %call.i.i.i5581, i64 %indvars.iv.i3625
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx12.i3626, i8 0, i64 16, i1 false)
  %indvars.iv.next.i3627 = add nuw nsw i64 %indvars.iv.i3625, 1
  %exitcond.not.i3628 = icmp eq i64 %indvars.iv.next.i3627, %wide.trip.count.i3623
  br i1 %exitcond.not.i3628, label %_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_.exit3630, label %for.body9.i3624, !llvm.loop !55

_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_.exit3630: ; preds = %for.body9.i3624, %invoke.cont1978
  %1559 = phi ptr [ null, %invoke.cont1978 ], [ %call.i.i.i5581, %for.body9.i3624 ]
  store i32 %conv1982, ptr %m_size.i.i3616, align 4
  %1560 = load i32, ptr %numConcavePairs, align 4
  %cmp19876156 = icmp sgt i32 %1560, 0
  br i1 %cmp19876156, label %for.body1988, label %for.end2006

for.body1988:                                     ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_.exit3630, %for.body1988
  %i1985.06157 = phi i32 [ %inc2005, %for.body1988 ], [ 0, %_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_.exit3630 ]
  %1561 = load ptr, ptr %m_data.i.i3607, align 8
  %1562 = load ptr, ptr %m_data.i.i3591, align 8
  %1563 = load ptr, ptr %m_data.i.i3595, align 8
  %1564 = load ptr, ptr %m_data.i.i3599, align 8
  %1565 = load ptr, ptr %m_data.i.i3603, align 8
  %1566 = load i32, ptr %vertexFaceCapacity, align 4
  call void @_Z30clipFacesAndFindContactsKernelPK9b3Vector3PKiP6b3Int4PS_S6_S6_S6_ii(ptr nonnull poison, ptr noundef nonnull %1561, ptr noundef nonnull %1562, ptr noundef nonnull %1563, ptr noundef nonnull %1564, ptr noundef nonnull %1565, ptr noundef nonnull %1559, i32 noundef %1566, i32 noundef %i1985.06157)
  %inc2005 = add nuw nsw i32 %i1985.06157, 1
  %1567 = load i32, ptr %numConcavePairs, align 4
  %cmp1987 = icmp slt i32 %inc2005, %1567
  br i1 %cmp1987, label %for.body1988, label %for.end2006, !llvm.loop !72

lpad1963:                                         ; preds = %invoke.cont1966, %invoke.cont1965, %invoke.cont1964, %invoke.cont1962
  %1568 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup2012

lpad1971:                                         ; preds = %invoke.cont1969
  %1569 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup2011

lpad1976:                                         ; preds = %invoke.cont1974
  %1570 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup2010

lpad1979:                                         ; preds = %.noexc5582, %_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18.i5578, %_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit.i5551, %call.i.i.noexc3677, %if.then.i.i3667, %if.end7.i.i3673, %call.i.i.noexc3655, %if.then.i.i3645, %if.end7.i.i3651
  %1571 = landingpad { ptr, i32 }
          cleanup
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB2CPU) #26
  br label %ehcleanup2010

for.end2006:                                      ; preds = %for.body1988, %_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_.exit3630
  %1572 = load i32, ptr %m_size.i.i3592, align 4
  %conv.i3639 = sext i32 %1572 to i64
  %m_size.i.i.i3640 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %clippingFacesOutGPU, i64 0, i32 1
  %1573 = load i64, ptr %m_size.i.i.i3640, align 8
  %cmp3.i.i3641 = icmp ult i64 %1573, %conv.i3639
  br i1 %cmp3.i.i3641, label %if.end7.i.i3651, label %_ZN13b3OpenCLArrayI6b3Int4E6resizeEmb.exit.i3642

if.end7.i.i3651:                                  ; preds = %for.end2006
  %call5.i.i3654 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI6b3Int4E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %clippingFacesOutGPU, i64 noundef %conv.i3639, i1 noundef zeroext false)
          to label %call5.i.i.noexc3653 unwind label %lpad1979

call5.i.i.noexc3653:                              ; preds = %if.end7.i.i3651
  %spec.select.i.i3652 = select i1 %call5.i.i3654, i64 %conv.i3639, i64 0
  br label %_ZN13b3OpenCLArrayI6b3Int4E6resizeEmb.exit.i3642

_ZN13b3OpenCLArrayI6b3Int4E6resizeEmb.exit.i3642: ; preds = %call5.i.i.noexc3653, %for.end2006
  %storemerge.i.i3643 = phi i64 [ %conv.i3639, %for.end2006 ], [ %spec.select.i.i3652, %call5.i.i.noexc3653 ]
  store i64 %storemerge.i.i3643, ptr %m_size.i.i.i3640, align 8
  %tobool3.not.i3644 = icmp eq i32 %1572, 0
  br i1 %tobool3.not.i3644, label %invoke.cont2007, label %if.then.i.i3645

if.then.i.i3645:                                  ; preds = %_ZN13b3OpenCLArrayI6b3Int4E6resizeEmb.exit.i3642
  %1574 = load ptr, ptr %m_data.i.i3591, align 8
  %mul.i.i3647 = shl nsw i64 %conv.i3639, 4
  %1575 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %m_commandQueue.i.i3648 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %clippingFacesOutGPU, i64 0, i32 5
  %1576 = load ptr, ptr %m_commandQueue.i.i3648, align 8
  %m_clBuffer.i.i3649 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %clippingFacesOutGPU, i64 0, i32 3
  %1577 = load ptr, ptr %m_clBuffer.i.i3649, align 8
  %call.i.i3656 = invoke i32 %1575(ptr noundef %1576, ptr noundef %1577, i32 noundef 0, i64 noundef 0, i64 noundef %mul.i.i3647, ptr noundef %1574, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call.i.i.noexc3655 unwind label %lpad1979

call.i.i.noexc3655:                               ; preds = %if.then.i.i3645
  %1578 = load ptr, ptr @__clewFinish, align 8
  %1579 = load ptr, ptr %m_commandQueue.i.i3648, align 8
  %call6.i.i3658 = invoke i32 %1578(ptr noundef %1579)
          to label %invoke.cont2007 unwind label %lpad1979

invoke.cont2007:                                  ; preds = %_ZN13b3OpenCLArrayI6b3Int4E6resizeEmb.exit.i3642, %call.i.i.noexc3655
  %sext6249 = shl i64 %1558, 32
  %conv.i3661 = ashr exact i64 %sext6249, 32
  %1580 = load i64, ptr %m_size.i.i3581, align 8
  %cmp3.i.i3663 = icmp ult i64 %1580, %conv.i3661
  br i1 %cmp3.i.i3663, label %if.end7.i.i3673, label %_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i3664

if.end7.i.i3673:                                  ; preds = %invoke.cont2007
  %call5.i.i3676 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %worldVertsB2GPU, i64 noundef %conv.i3661, i1 noundef zeroext false)
          to label %call5.i.i.noexc3675 unwind label %lpad1979

call5.i.i.noexc3675:                              ; preds = %if.end7.i.i3673
  %spec.select.i.i3674 = select i1 %call5.i.i3676, i64 %conv.i3661, i64 0
  br label %_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i3664

_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i3664: ; preds = %call5.i.i.noexc3675, %invoke.cont2007
  %storemerge.i.i3665 = phi i64 [ %conv.i3661, %invoke.cont2007 ], [ %spec.select.i.i3674, %call5.i.i.noexc3675 ]
  store i64 %storemerge.i.i3665, ptr %m_size.i.i3581, align 8
  %tobool3.not.i3666 = icmp eq i32 %conv1982, 0
  br i1 %tobool3.not.i3666, label %invoke.cont2008, label %if.then.i.i3667

if.then.i.i3667:                                  ; preds = %_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i3664
  %mul.i.i3669 = ashr exact i64 %sext6249, 28
  %1581 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %m_commandQueue.i.i3670 = getelementptr inbounds %class.b3OpenCLArray, ptr %worldVertsB2GPU, i64 0, i32 5
  %1582 = load ptr, ptr %m_commandQueue.i.i3670, align 8
  %m_clBuffer.i.i3671 = getelementptr inbounds %class.b3OpenCLArray, ptr %worldVertsB2GPU, i64 0, i32 3
  %1583 = load ptr, ptr %m_clBuffer.i.i3671, align 8
  %call.i.i3678 = invoke i32 %1581(ptr noundef %1582, ptr noundef %1583, i32 noundef 0, i64 noundef 0, i64 noundef %mul.i.i3669, ptr noundef %1559, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call.i.i.noexc3677 unwind label %lpad1979

call.i.i.noexc3677:                               ; preds = %if.then.i.i3667
  %1584 = load ptr, ptr @__clewFinish, align 8
  %1585 = load ptr, ptr %m_commandQueue.i.i3670, align 8
  %call6.i.i3680 = invoke i32 %1584(ptr noundef %1585)
          to label %invoke.cont2008 unwind label %lpad1979

invoke.cont2008:                                  ; preds = %_ZN13b3OpenCLArrayI9b3Vector3E6resizeEmb.exit.i3664, %call.i.i.noexc3677
  %tobool.not.i.i.i3683 = icmp eq ptr %1559, null
  br i1 %tobool.not.i.i.i3683, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3692, label %if.then3.i.i.i3687

if.then3.i.i.i3687:                               ; preds = %invoke.cont2008
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1559)
          to label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3692 unwind label %terminate.lpad.i3688

terminate.lpad.i3688:                             ; preds = %if.then3.i.i.i3687
  %1586 = landingpad { ptr, i32 }
          catch ptr null
  %1587 = extractvalue { ptr, i32 } %1586, 0
  call void @__clang_call_terminate(ptr %1587) #27
  unreachable

_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3692: ; preds = %invoke.cont2008, %if.then3.i.i.i3687
  store i8 1, ptr %m_ownsMemory.i.i3614, align 8
  store ptr null, ptr %m_data.i.i3615, align 8
  store i32 0, ptr %m_size.i.i3616, align 4
  store i32 0, ptr %m_capacity.i.i3617, align 8
  %1588 = load ptr, ptr %m_data.i.i3611, align 8
  %tobool.not.i.i.i3694 = icmp eq ptr %1588, null
  br i1 %tobool.not.i.i.i3694, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3703, label %if.then.i.i.i3695

if.then.i.i.i3695:                                ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3692
  %1589 = load i8, ptr %m_ownsMemory.i.i3610, align 8
  %1590 = and i8 %1589, 1
  %tobool2.not.i.i.i3697 = icmp eq i8 %1590, 0
  br i1 %tobool2.not.i.i.i3697, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3703, label %if.then3.i.i.i3698

if.then3.i.i.i3698:                               ; preds = %if.then.i.i.i3695
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1588)
          to label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3703 unwind label %terminate.lpad.i3699

terminate.lpad.i3699:                             ; preds = %if.then3.i.i.i3698
  %1591 = landingpad { ptr, i32 }
          catch ptr null
  %1592 = extractvalue { ptr, i32 } %1591, 0
  call void @__clang_call_terminate(ptr %1592) #27
  unreachable

_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3703: ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3692, %if.then.i.i.i3695, %if.then3.i.i.i3698
  store i8 1, ptr %m_ownsMemory.i.i3610, align 8
  store ptr null, ptr %m_data.i.i3611, align 8
  store i32 0, ptr %m_size.i.i3612, align 4
  store i32 0, ptr %m_capacity.i.i3613, align 8
  %1593 = load ptr, ptr %m_data.i.i3607, align 8
  %tobool.not.i.i.i3705 = icmp eq ptr %1593, null
  br i1 %tobool.not.i.i.i3705, label %_ZN20b3AlignedObjectArrayIiED2Ev.exit3714, label %if.then.i.i.i3706

if.then.i.i.i3706:                                ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3703
  %1594 = load i8, ptr %m_ownsMemory.i.i3606, align 8
  %1595 = and i8 %1594, 1
  %tobool2.not.i.i.i3708 = icmp eq i8 %1595, 0
  br i1 %tobool2.not.i.i.i3708, label %_ZN20b3AlignedObjectArrayIiED2Ev.exit3714, label %if.then3.i.i.i3709

if.then3.i.i.i3709:                               ; preds = %if.then.i.i.i3706
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1593)
          to label %_ZN20b3AlignedObjectArrayIiED2Ev.exit3714 unwind label %terminate.lpad.i3710

terminate.lpad.i3710:                             ; preds = %if.then3.i.i.i3709
  %1596 = landingpad { ptr, i32 }
          catch ptr null
  %1597 = extractvalue { ptr, i32 } %1596, 0
  call void @__clang_call_terminate(ptr %1597) #27
  unreachable

_ZN20b3AlignedObjectArrayIiED2Ev.exit3714:        ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3703, %if.then.i.i.i3706, %if.then3.i.i.i3709
  store i8 1, ptr %m_ownsMemory.i.i3606, align 8
  store ptr null, ptr %m_data.i.i3607, align 8
  store i32 0, ptr %m_size.i.i3608, align 4
  store i32 0, ptr %m_capacity.i.i3609, align 8
  %1598 = load ptr, ptr %m_data.i.i3603, align 8
  %tobool.not.i.i.i3716 = icmp eq ptr %1598, null
  br i1 %tobool.not.i.i.i3716, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3725, label %if.then.i.i.i3717

if.then.i.i.i3717:                                ; preds = %_ZN20b3AlignedObjectArrayIiED2Ev.exit3714
  %1599 = load i8, ptr %m_ownsMemory.i.i3602, align 8
  %1600 = and i8 %1599, 1
  %tobool2.not.i.i.i3719 = icmp eq i8 %1600, 0
  br i1 %tobool2.not.i.i.i3719, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3725, label %if.then3.i.i.i3720

if.then3.i.i.i3720:                               ; preds = %if.then.i.i.i3717
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1598)
          to label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3725 unwind label %terminate.lpad.i3721

terminate.lpad.i3721:                             ; preds = %if.then3.i.i.i3720
  %1601 = landingpad { ptr, i32 }
          catch ptr null
  %1602 = extractvalue { ptr, i32 } %1601, 0
  call void @__clang_call_terminate(ptr %1602) #27
  unreachable

_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3725: ; preds = %_ZN20b3AlignedObjectArrayIiED2Ev.exit3714, %if.then.i.i.i3717, %if.then3.i.i.i3720
  store i8 1, ptr %m_ownsMemory.i.i3602, align 8
  store ptr null, ptr %m_data.i.i3603, align 8
  store i32 0, ptr %m_size.i.i3604, align 4
  store i32 0, ptr %m_capacity.i.i3605, align 8
  %1603 = load ptr, ptr %m_data.i.i3599, align 8
  %tobool.not.i.i.i3727 = icmp eq ptr %1603, null
  br i1 %tobool.not.i.i.i3727, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3736, label %if.then.i.i.i3728

if.then.i.i.i3728:                                ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3725
  %1604 = load i8, ptr %m_ownsMemory.i.i3598, align 8
  %1605 = and i8 %1604, 1
  %tobool2.not.i.i.i3730 = icmp eq i8 %1605, 0
  br i1 %tobool2.not.i.i.i3730, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3736, label %if.then3.i.i.i3731

if.then3.i.i.i3731:                               ; preds = %if.then.i.i.i3728
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1603)
          to label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3736 unwind label %terminate.lpad.i3732

terminate.lpad.i3732:                             ; preds = %if.then3.i.i.i3731
  %1606 = landingpad { ptr, i32 }
          catch ptr null
  %1607 = extractvalue { ptr, i32 } %1606, 0
  call void @__clang_call_terminate(ptr %1607) #27
  unreachable

_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3736: ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3725, %if.then.i.i.i3728, %if.then3.i.i.i3731
  store i8 1, ptr %m_ownsMemory.i.i3598, align 8
  store ptr null, ptr %m_data.i.i3599, align 8
  store i32 0, ptr %m_size.i.i3600, align 4
  store i32 0, ptr %m_capacity.i.i3601, align 8
  %1608 = load ptr, ptr %m_data.i.i3595, align 8
  %tobool.not.i.i.i3738 = icmp eq ptr %1608, null
  br i1 %tobool.not.i.i.i3738, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3747, label %if.then.i.i.i3739

if.then.i.i.i3739:                                ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3736
  %1609 = load i8, ptr %m_ownsMemory.i.i3594, align 8
  %1610 = and i8 %1609, 1
  %tobool2.not.i.i.i3741 = icmp eq i8 %1610, 0
  br i1 %tobool2.not.i.i.i3741, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3747, label %if.then3.i.i.i3742

if.then3.i.i.i3742:                               ; preds = %if.then.i.i.i3739
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1608)
          to label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3747 unwind label %terminate.lpad.i3743

terminate.lpad.i3743:                             ; preds = %if.then3.i.i.i3742
  %1611 = landingpad { ptr, i32 }
          catch ptr null
  %1612 = extractvalue { ptr, i32 } %1611, 0
  call void @__clang_call_terminate(ptr %1612) #27
  unreachable

_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3747: ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3736, %if.then.i.i.i3739, %if.then3.i.i.i3742
  store i8 1, ptr %m_ownsMemory.i.i3594, align 8
  store ptr null, ptr %m_data.i.i3595, align 8
  store i32 0, ptr %m_size.i.i3596, align 4
  store i32 0, ptr %m_capacity.i.i3597, align 8
  %1613 = load ptr, ptr %m_data.i.i3591, align 8
  %tobool.not.i.i.i3749 = icmp eq ptr %1613, null
  br i1 %tobool.not.i.i.i3749, label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit3758, label %if.then.i.i.i3750

if.then.i.i.i3750:                                ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3747
  %1614 = load i8, ptr %m_ownsMemory.i.i3590, align 8
  %1615 = and i8 %1614, 1
  %tobool2.not.i.i.i3752 = icmp eq i8 %1615, 0
  br i1 %tobool2.not.i.i.i3752, label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit3758, label %if.then3.i.i.i3753

if.then3.i.i.i3753:                               ; preds = %if.then.i.i.i3750
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1613)
          to label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit3758 unwind label %terminate.lpad.i3754

terminate.lpad.i3754:                             ; preds = %if.then3.i.i.i3753
  %1616 = landingpad { ptr, i32 }
          catch ptr null
  %1617 = extractvalue { ptr, i32 } %1616, 0
  call void @__clang_call_terminate(ptr %1617) #27
  unreachable

_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit3758:  ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit3747, %if.then.i.i.i3750, %if.then3.i.i.i3753
  store i8 1, ptr %m_ownsMemory.i.i3590, align 8
  store ptr null, ptr %m_data.i.i3591, align 8
  store i32 0, ptr %m_size.i.i3592, align 4
  store i32 0, ptr %m_capacity.i.i3593, align 8
  br label %if.end2067

ehcleanup2010:                                    ; preds = %lpad1979, %lpad1976
  %.pn521 = phi { ptr, i32 } [ %1571, %lpad1979 ], [ %1570, %lpad1976 ]
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %concaveSepNormalsHost1973) #26
  br label %ehcleanup2011

ehcleanup2011:                                    ; preds = %ehcleanup2010, %lpad1971
  %.pn521.pn = phi { ptr, i32 } [ %.pn521, %ehcleanup2010 ], [ %1569, %lpad1971 ]
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %concaveHasSeparatingNormalsCPU1968) #26
  br label %ehcleanup2012

ehcleanup2012:                                    ; preds = %ehcleanup2011, %lpad1963
  %.pn521.pn.pn = phi { ptr, i32 } [ %.pn521.pn, %ehcleanup2011 ], [ %1568, %lpad1963 ]
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB1CPU1960) #26
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldNormalsACPU1957) #26
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsA1CPU1954) #26
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU1952) #26
  br label %ehcleanup2980

if.else2016:                                      ; preds = %invoke.cont1948
  invoke void @b3EnterProfileZone(ptr noundef nonnull @.str.58)
          to label %invoke.cont2018 unwind label %lpad58

invoke.cont2018:                                  ; preds = %if.else2016
  %m_clBuffer.i3761 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 29, i32 3
  %1618 = load ptr, ptr %m_clBuffer.i3761, align 8
  store ptr %1618, ptr %bInfo2019, align 16
  %m_isReadOnly.i3762 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2019, i64 0, i32 1
  store i8 0, ptr %m_isReadOnly.i3762, align 8
  %arrayinit.element2026 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2019, i64 1
  %m_clBuffer.i3763 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 30, i32 3
  %1619 = load ptr, ptr %m_clBuffer.i3763, align 8
  store ptr %1619, ptr %arrayinit.element2026, align 16
  %m_isReadOnly.i3764 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2019, i64 1, i32 1
  store i8 0, ptr %m_isReadOnly.i3764, align 8
  %arrayinit.element2031 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2019, i64 2
  %m_clBuffer.i3765 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %clippingFacesOutGPU, i64 0, i32 3
  %1620 = load ptr, ptr %m_clBuffer.i3765, align 8
  store ptr %1620, ptr %arrayinit.element2031, align 16
  %m_isReadOnly.i3766 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2019, i64 2, i32 1
  store i8 0, ptr %m_isReadOnly.i3766, align 8
  %arrayinit.element2035 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2019, i64 3
  %m_clBuffer.i3767 = getelementptr inbounds %class.b3OpenCLArray, ptr %worldVertsA1GPU, i64 0, i32 3
  %1621 = load ptr, ptr %m_clBuffer.i3767, align 8
  store ptr %1621, ptr %arrayinit.element2035, align 16
  %m_isReadOnly.i3768 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2019, i64 3, i32 1
  store i8 0, ptr %m_isReadOnly.i3768, align 8
  %arrayinit.element2039 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2019, i64 4
  %m_clBuffer.i3769 = getelementptr inbounds %class.b3OpenCLArray, ptr %worldNormalsAGPU, i64 0, i32 3
  %1622 = load ptr, ptr %m_clBuffer.i3769, align 8
  store ptr %1622, ptr %arrayinit.element2039, align 16
  %m_isReadOnly.i3770 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2019, i64 4, i32 1
  store i8 0, ptr %m_isReadOnly.i3770, align 8
  %arrayinit.element2043 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2019, i64 5
  %m_clBuffer.i3771 = getelementptr inbounds %class.b3OpenCLArray, ptr %worldVertsB1GPU, i64 0, i32 3
  %1623 = load ptr, ptr %m_clBuffer.i3771, align 8
  store ptr %1623, ptr %arrayinit.element2043, align 16
  %m_isReadOnly.i3772 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2019, i64 5, i32 1
  store i8 0, ptr %m_isReadOnly.i3772, align 8
  %arrayinit.element2047 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2019, i64 6
  %m_clBuffer.i3773 = getelementptr inbounds %class.b3OpenCLArray, ptr %worldVertsB2GPU, i64 0, i32 3
  %1624 = load ptr, ptr %m_clBuffer.i3773, align 8
  store ptr %1624, ptr %arrayinit.element2047, align 16
  %m_isReadOnly.i3774 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2019, i64 6, i32 1
  store i8 0, ptr %m_isReadOnly.i3774, align 8
  %1625 = load ptr, ptr %m_queue, align 8
  %m_clipFacesAndFindContacts = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 16
  %1626 = load ptr, ptr %m_clipFacesAndFindContacts, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher2051, ptr noundef %1625, ptr noundef %1626, ptr noundef nonnull @.str.59)
          to label %invoke.cont2053 unwind label %lpad2022

invoke.cont2053:                                  ; preds = %invoke.cont2018
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher2051, ptr noundef nonnull %bInfo2019, i32 noundef 7)
          to label %invoke.cont2056 unwind label %lpad2055

invoke.cont2056:                                  ; preds = %invoke.cont2053
  %m_enableSerialization.i3775 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 7
  %1627 = load i8, ptr %m_enableSerialization.i3775, align 4
  %1628 = and i8 %1627, 1
  %tobool.not.i3776 = icmp eq i8 %1628, 0
  br i1 %tobool.not.i3776, label %if.end.i3792, label %if.then.i3777

if.then.i3777:                                    ; preds = %invoke.cont2056
  %m_idx.i3778 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 3
  %1629 = load i32, ptr %m_idx.i3778, align 8
  %1630 = load i32, ptr %vertexFaceCapacity, align 4
  %m_size.i.i.i3779 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 5, i32 2
  %1631 = load i32, ptr %m_size.i.i.i3779, align 4
  %m_capacity.i.i.i3780 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 5, i32 3
  %1632 = load i32, ptr %m_capacity.i.i.i3780, align 8
  %cmp.i.i3781 = icmp eq i32 %1631, %1632
  br i1 %cmp.i.i3781, label %if.then.i.i3797, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3782

if.then.i.i3797:                                  ; preds = %if.then.i3777
  %tobool.not.i.i.i3799 = icmp eq i32 %1631, 0
  %mul.i.i.i3800 = shl nsw i32 %1631, 1
  %cond.i.i.i3801 = select i1 %tobool.not.i.i.i3799, i32 1, i32 %mul.i.i.i3800
  %cmp.i5587 = icmp slt i32 %1631, %cond.i.i.i3801
  br i1 %cmp.i5587, label %if.then.i5589, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3782

if.then.i5589:                                    ; preds = %if.then.i.i3797
  %tobool.not.i.i5590 = icmp eq i32 %cond.i.i.i3801, 0
  br i1 %tobool.not.i.i5590, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5618, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5591

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5591: ; preds = %if.then.i5589
  %conv.i.i.i5592 = sext i32 %cond.i.i.i3801 to i64
  %mul.i.i.i5593 = shl nsw i64 %conv.i.i.i5592, 5
  %call.i.i.i5621 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i5593, i32 noundef 16)
          to label %call.i.i.i.noexc5620 unwind label %lpad2055

call.i.i.i.noexc5620:                             ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5591
  %cmp3.i5594 = icmp eq ptr %call.i.i.i5621, null
  br i1 %cmp3.i5594, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5618, label %if.then.split.i5595

if.then.split.i5595:                              ; preds = %call.i.i.i.noexc5620
  %1633 = load i32, ptr %m_size.i.i.i3779, align 4
  %cmp4.i.i5597 = icmp sgt i32 %1633, 0
  br i1 %cmp4.i.i5597, label %for.body.lr.ph.i.i5609, label %if.end.i5598

for.body.lr.ph.i.i5609:                           ; preds = %if.then.split.i5595
  %m_data.i.i5610 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 5, i32 5
  %wide.trip.count.i.i5611 = zext nneg i32 %1633 to i64
  br label %for.body.i.i5612

for.body.i.i5612:                                 ; preds = %for.body.i.i5612, %for.body.lr.ph.i.i5609
  %indvars.iv.i.i5613 = phi i64 [ 0, %for.body.lr.ph.i.i5609 ], [ %indvars.iv.next.i.i5616, %for.body.i.i5612 ]
  %arrayidx.i.i5614 = getelementptr inbounds %struct.b3KernelArgData, ptr %call.i.i.i5621, i64 %indvars.iv.i.i5613
  %1634 = load ptr, ptr %m_data.i.i5610, align 8
  %arrayidx3.i.i5615 = getelementptr inbounds %struct.b3KernelArgData, ptr %1634, i64 %indvars.iv.i.i5613
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i.i5614, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i.i5615, i64 32, i1 false)
  %indvars.iv.next.i.i5616 = add nuw nsw i64 %indvars.iv.i.i5613, 1
  %exitcond.not.i.i5617 = icmp eq i64 %indvars.iv.next.i.i5616, %wide.trip.count.i.i5611
  br i1 %exitcond.not.i.i5617, label %if.end.i5598, label %for.body.i.i5612, !llvm.loop !64

_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5618: ; preds = %call.i.i.i.noexc5620, %if.then.i5589
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc5622 unwind label %lpad2055

.noexc5622:                                       ; preds = %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5618
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc5623 unwind label %lpad2055

.noexc5623:                                       ; preds = %.noexc5622
  store i32 0, ptr %m_size.i.i.i3779, align 4
  br label %if.end.i5598

if.end.i5598:                                     ; preds = %for.body.i.i5612, %.noexc5623, %if.then.split.i5595
  %retval.0.i25.i5599 = phi ptr [ null, %.noexc5623 ], [ %call.i.i.i5621, %if.then.split.i5595 ], [ %call.i.i.i5621, %for.body.i.i5612 ]
  %_Count.addr.0.i5600 = phi i32 [ 0, %.noexc5623 ], [ %cond.i.i.i3801, %if.then.split.i5595 ], [ %cond.i.i.i3801, %for.body.i.i5612 ]
  %m_data.i20.i5601 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 5, i32 5
  %1635 = load ptr, ptr %m_data.i20.i5601, align 8
  %tobool.not.i21.i5602 = icmp eq ptr %1635, null
  br i1 %tobool.not.i21.i5602, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5607, label %if.then.i22.i5603

if.then.i22.i5603:                                ; preds = %if.end.i5598
  %m_ownsMemory.i.i5604 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 5, i32 6
  %1636 = load i8, ptr %m_ownsMemory.i.i5604, align 8
  %1637 = and i8 %1636, 1
  %tobool2.not.i.i5605 = icmp eq i8 %1637, 0
  br i1 %tobool2.not.i.i5605, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5607, label %if.then3.i.i5606

if.then3.i.i5606:                                 ; preds = %if.then.i22.i5603
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1635)
          to label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5607 unwind label %lpad2055

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5607: ; preds = %if.then3.i.i5606, %if.then.i22.i5603, %if.end.i5598
  %m_ownsMemory.i5608 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 5, i32 6
  store i8 1, ptr %m_ownsMemory.i5608, align 8
  store ptr %retval.0.i25.i5599, ptr %m_data.i20.i5601, align 8
  store i32 %_Count.addr.0.i5600, ptr %m_capacity.i.i.i3780, align 8
  %.pre.i.i3802.pre = load i32, ptr %m_size.i.i.i3779, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3782

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3782: ; preds = %if.then.i.i3797, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5607, %if.then.i3777
  %1638 = phi i32 [ %1631, %if.then.i3777 ], [ %.pre.i.i3802.pre, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5607 ], [ %1631, %if.then.i.i3797 ]
  %m_data.i.i3783 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 5, i32 5
  %1639 = load ptr, ptr %m_data.i.i3783, align 8
  %idxprom.i.i3784 = sext i32 %1638 to i64
  %arrayidx.i.i3785 = getelementptr inbounds %struct.b3KernelArgData, ptr %1639, i64 %idxprom.i.i3784
  store i32 0, ptr %arrayidx.i.i3785, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i3786 = getelementptr inbounds i8, ptr %arrayidx.i.i3785, i64 4
  store i32 %1629, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i3786, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i3787 = getelementptr inbounds i8, ptr %arrayidx.i.i3785, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i3787, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i3788 = getelementptr inbounds i8, ptr %arrayidx.i.i3785, i64 16
  store i32 %1630, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i3788, align 16
  %1640 = load i32, ptr %m_size.i.i.i3779, align 4
  %inc.i.i3789 = add nsw i32 %1640, 1
  store i32 %inc.i.i3789, ptr %m_size.i.i.i3779, align 4
  %m_serializationSizeInBytes.i3790 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 6
  %1641 = load i32, ptr %m_serializationSizeInBytes.i3790, align 8
  %add.i3791 = add i32 %1641, 32
  store i32 %add.i3791, ptr %m_serializationSizeInBytes.i3790, align 8
  br label %if.end.i3792

if.end.i3792:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3782, %invoke.cont2056
  %1642 = load ptr, ptr @__clewSetKernelArg, align 8
  %m_kernel.i3793 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 2
  %1643 = load ptr, ptr %m_kernel.i3793, align 8
  %m_idx3.i3794 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 3
  %1644 = load i32, ptr %m_idx3.i3794, align 8
  %inc.i3795 = add nsw i32 %1644, 1
  store i32 %inc.i3795, ptr %m_idx3.i3794, align 8
  %call.i37963804 = invoke i32 %1642(ptr noundef %1643, i32 noundef %1644, i64 noundef 4, ptr noundef nonnull %vertexFaceCapacity)
          to label %invoke.cont2057 unwind label %lpad2055

invoke.cont2057:                                  ; preds = %if.end.i3792
  %1645 = load i8, ptr %m_enableSerialization.i3775, align 4
  %1646 = and i8 %1645, 1
  %tobool.not.i3807 = icmp eq i8 %1646, 0
  br i1 %tobool.not.i3807, label %if.end.i3823, label %if.then.i3808

if.then.i3808:                                    ; preds = %invoke.cont2057
  %1647 = load i32, ptr %m_idx3.i3794, align 8
  %1648 = load i32, ptr %numConcavePairs, align 4
  %m_size.i.i.i3810 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 5, i32 2
  %1649 = load i32, ptr %m_size.i.i.i3810, align 4
  %m_capacity.i.i.i3811 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 5, i32 3
  %1650 = load i32, ptr %m_capacity.i.i.i3811, align 8
  %cmp.i.i3812 = icmp eq i32 %1649, %1650
  br i1 %cmp.i.i3812, label %if.then.i.i3828, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3813

if.then.i.i3828:                                  ; preds = %if.then.i3808
  %tobool.not.i.i.i3830 = icmp eq i32 %1649, 0
  %mul.i.i.i3831 = shl nsw i32 %1649, 1
  %cond.i.i.i3832 = select i1 %tobool.not.i.i.i3830, i32 1, i32 %mul.i.i.i3831
  %cmp.i5627 = icmp slt i32 %1649, %cond.i.i.i3832
  br i1 %cmp.i5627, label %if.then.i5629, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3813

if.then.i5629:                                    ; preds = %if.then.i.i3828
  %tobool.not.i.i5630 = icmp eq i32 %cond.i.i.i3832, 0
  br i1 %tobool.not.i.i5630, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5658, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5631

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5631: ; preds = %if.then.i5629
  %conv.i.i.i5632 = sext i32 %cond.i.i.i3832 to i64
  %mul.i.i.i5633 = shl nsw i64 %conv.i.i.i5632, 5
  %call.i.i.i5661 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i5633, i32 noundef 16)
          to label %call.i.i.i.noexc5660 unwind label %lpad2055

call.i.i.i.noexc5660:                             ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5631
  %cmp3.i5634 = icmp eq ptr %call.i.i.i5661, null
  br i1 %cmp3.i5634, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5658, label %if.then.split.i5635

if.then.split.i5635:                              ; preds = %call.i.i.i.noexc5660
  %1651 = load i32, ptr %m_size.i.i.i3810, align 4
  %cmp4.i.i5637 = icmp sgt i32 %1651, 0
  br i1 %cmp4.i.i5637, label %for.body.lr.ph.i.i5649, label %if.end.i5638

for.body.lr.ph.i.i5649:                           ; preds = %if.then.split.i5635
  %m_data.i.i5650 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 5, i32 5
  %wide.trip.count.i.i5651 = zext nneg i32 %1651 to i64
  br label %for.body.i.i5652

for.body.i.i5652:                                 ; preds = %for.body.i.i5652, %for.body.lr.ph.i.i5649
  %indvars.iv.i.i5653 = phi i64 [ 0, %for.body.lr.ph.i.i5649 ], [ %indvars.iv.next.i.i5656, %for.body.i.i5652 ]
  %arrayidx.i.i5654 = getelementptr inbounds %struct.b3KernelArgData, ptr %call.i.i.i5661, i64 %indvars.iv.i.i5653
  %1652 = load ptr, ptr %m_data.i.i5650, align 8
  %arrayidx3.i.i5655 = getelementptr inbounds %struct.b3KernelArgData, ptr %1652, i64 %indvars.iv.i.i5653
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i.i5654, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i.i5655, i64 32, i1 false)
  %indvars.iv.next.i.i5656 = add nuw nsw i64 %indvars.iv.i.i5653, 1
  %exitcond.not.i.i5657 = icmp eq i64 %indvars.iv.next.i.i5656, %wide.trip.count.i.i5651
  br i1 %exitcond.not.i.i5657, label %if.end.i5638, label %for.body.i.i5652, !llvm.loop !64

_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5658: ; preds = %call.i.i.i.noexc5660, %if.then.i5629
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc5662 unwind label %lpad2055

.noexc5662:                                       ; preds = %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5658
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc5663 unwind label %lpad2055

.noexc5663:                                       ; preds = %.noexc5662
  store i32 0, ptr %m_size.i.i.i3810, align 4
  br label %if.end.i5638

if.end.i5638:                                     ; preds = %for.body.i.i5652, %.noexc5663, %if.then.split.i5635
  %retval.0.i25.i5639 = phi ptr [ null, %.noexc5663 ], [ %call.i.i.i5661, %if.then.split.i5635 ], [ %call.i.i.i5661, %for.body.i.i5652 ]
  %_Count.addr.0.i5640 = phi i32 [ 0, %.noexc5663 ], [ %cond.i.i.i3832, %if.then.split.i5635 ], [ %cond.i.i.i3832, %for.body.i.i5652 ]
  %m_data.i20.i5641 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 5, i32 5
  %1653 = load ptr, ptr %m_data.i20.i5641, align 8
  %tobool.not.i21.i5642 = icmp eq ptr %1653, null
  br i1 %tobool.not.i21.i5642, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5647, label %if.then.i22.i5643

if.then.i22.i5643:                                ; preds = %if.end.i5638
  %m_ownsMemory.i.i5644 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 5, i32 6
  %1654 = load i8, ptr %m_ownsMemory.i.i5644, align 8
  %1655 = and i8 %1654, 1
  %tobool2.not.i.i5645 = icmp eq i8 %1655, 0
  br i1 %tobool2.not.i.i5645, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5647, label %if.then3.i.i5646

if.then3.i.i5646:                                 ; preds = %if.then.i22.i5643
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1653)
          to label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5647 unwind label %lpad2055

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5647: ; preds = %if.then3.i.i5646, %if.then.i22.i5643, %if.end.i5638
  %m_ownsMemory.i5648 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 5, i32 6
  store i8 1, ptr %m_ownsMemory.i5648, align 8
  store ptr %retval.0.i25.i5639, ptr %m_data.i20.i5641, align 8
  store i32 %_Count.addr.0.i5640, ptr %m_capacity.i.i.i3811, align 8
  %.pre.i.i3833.pre = load i32, ptr %m_size.i.i.i3810, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3813

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3813: ; preds = %if.then.i.i3828, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5647, %if.then.i3808
  %1656 = phi i32 [ %1649, %if.then.i3808 ], [ %.pre.i.i3833.pre, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5647 ], [ %1649, %if.then.i.i3828 ]
  %m_data.i.i3814 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 5, i32 5
  %1657 = load ptr, ptr %m_data.i.i3814, align 8
  %idxprom.i.i3815 = sext i32 %1656 to i64
  %arrayidx.i.i3816 = getelementptr inbounds %struct.b3KernelArgData, ptr %1657, i64 %idxprom.i.i3815
  store i32 0, ptr %arrayidx.i.i3816, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i3817 = getelementptr inbounds i8, ptr %arrayidx.i.i3816, i64 4
  store i32 %1647, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i3817, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i3818 = getelementptr inbounds i8, ptr %arrayidx.i.i3816, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i3818, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i3819 = getelementptr inbounds i8, ptr %arrayidx.i.i3816, i64 16
  store i32 %1648, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i3819, align 16
  %1658 = load i32, ptr %m_size.i.i.i3810, align 4
  %inc.i.i3820 = add nsw i32 %1658, 1
  store i32 %inc.i.i3820, ptr %m_size.i.i.i3810, align 4
  %m_serializationSizeInBytes.i3821 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 6
  %1659 = load i32, ptr %m_serializationSizeInBytes.i3821, align 8
  %add.i3822 = add i32 %1659, 32
  store i32 %add.i3822, ptr %m_serializationSizeInBytes.i3821, align 8
  br label %if.end.i3823

if.end.i3823:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3813, %invoke.cont2057
  %1660 = load ptr, ptr @__clewSetKernelArg, align 8
  %1661 = load ptr, ptr %m_kernel.i3793, align 8
  %1662 = load i32, ptr %m_idx3.i3794, align 8
  %inc.i3826 = add nsw i32 %1662, 1
  store i32 %inc.i3826, ptr %m_idx3.i3794, align 8
  %call.i38273835 = invoke i32 %1660(ptr noundef %1661, i32 noundef %1662, i64 noundef 4, ptr noundef nonnull %numConcavePairs)
          to label %invoke.cont2058 unwind label %lpad2055

invoke.cont2058:                                  ; preds = %if.end.i3823
  store i32 0, ptr %debugMode, align 4
  %1663 = load i8, ptr %m_enableSerialization.i3775, align 4
  %1664 = and i8 %1663, 1
  %tobool.not.i3838 = icmp eq i8 %1664, 0
  br i1 %tobool.not.i3838, label %if.end.i3854, label %if.then.i3839

if.then.i3839:                                    ; preds = %invoke.cont2058
  %1665 = load i32, ptr %m_idx3.i3794, align 8
  %m_size.i.i.i3841 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 5, i32 2
  %1666 = load i32, ptr %m_size.i.i.i3841, align 4
  %m_capacity.i.i.i3842 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 5, i32 3
  %1667 = load i32, ptr %m_capacity.i.i.i3842, align 8
  %cmp.i.i3843 = icmp eq i32 %1666, %1667
  br i1 %cmp.i.i3843, label %if.then.i.i3859, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3844

if.then.i.i3859:                                  ; preds = %if.then.i3839
  %tobool.not.i.i.i3861 = icmp eq i32 %1666, 0
  %mul.i.i.i3862 = shl nsw i32 %1666, 1
  %cond.i.i.i3863 = select i1 %tobool.not.i.i.i3861, i32 1, i32 %mul.i.i.i3862
  %cmp.i5667 = icmp slt i32 %1666, %cond.i.i.i3863
  br i1 %cmp.i5667, label %if.then.i5669, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3844

if.then.i5669:                                    ; preds = %if.then.i.i3859
  %tobool.not.i.i5670 = icmp eq i32 %cond.i.i.i3863, 0
  br i1 %tobool.not.i.i5670, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5698, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5671

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5671: ; preds = %if.then.i5669
  %conv.i.i.i5672 = sext i32 %cond.i.i.i3863 to i64
  %mul.i.i.i5673 = shl nsw i64 %conv.i.i.i5672, 5
  %call.i.i.i5701 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i5673, i32 noundef 16)
          to label %call.i.i.i.noexc5700 unwind label %lpad2055

call.i.i.i.noexc5700:                             ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5671
  %cmp3.i5674 = icmp eq ptr %call.i.i.i5701, null
  br i1 %cmp3.i5674, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5698, label %if.then.split.i5675

if.then.split.i5675:                              ; preds = %call.i.i.i.noexc5700
  %1668 = load i32, ptr %m_size.i.i.i3841, align 4
  %cmp4.i.i5677 = icmp sgt i32 %1668, 0
  br i1 %cmp4.i.i5677, label %for.body.lr.ph.i.i5689, label %if.end.i5678

for.body.lr.ph.i.i5689:                           ; preds = %if.then.split.i5675
  %m_data.i.i5690 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 5, i32 5
  %wide.trip.count.i.i5691 = zext nneg i32 %1668 to i64
  br label %for.body.i.i5692

for.body.i.i5692:                                 ; preds = %for.body.i.i5692, %for.body.lr.ph.i.i5689
  %indvars.iv.i.i5693 = phi i64 [ 0, %for.body.lr.ph.i.i5689 ], [ %indvars.iv.next.i.i5696, %for.body.i.i5692 ]
  %arrayidx.i.i5694 = getelementptr inbounds %struct.b3KernelArgData, ptr %call.i.i.i5701, i64 %indvars.iv.i.i5693
  %1669 = load ptr, ptr %m_data.i.i5690, align 8
  %arrayidx3.i.i5695 = getelementptr inbounds %struct.b3KernelArgData, ptr %1669, i64 %indvars.iv.i.i5693
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i.i5694, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i.i5695, i64 32, i1 false)
  %indvars.iv.next.i.i5696 = add nuw nsw i64 %indvars.iv.i.i5693, 1
  %exitcond.not.i.i5697 = icmp eq i64 %indvars.iv.next.i.i5696, %wide.trip.count.i.i5691
  br i1 %exitcond.not.i.i5697, label %if.end.i5678, label %for.body.i.i5692, !llvm.loop !64

_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5698: ; preds = %call.i.i.i.noexc5700, %if.then.i5669
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc5702 unwind label %lpad2055

.noexc5702:                                       ; preds = %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5698
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc5703 unwind label %lpad2055

.noexc5703:                                       ; preds = %.noexc5702
  store i32 0, ptr %m_size.i.i.i3841, align 4
  br label %if.end.i5678

if.end.i5678:                                     ; preds = %for.body.i.i5692, %.noexc5703, %if.then.split.i5675
  %retval.0.i25.i5679 = phi ptr [ null, %.noexc5703 ], [ %call.i.i.i5701, %if.then.split.i5675 ], [ %call.i.i.i5701, %for.body.i.i5692 ]
  %_Count.addr.0.i5680 = phi i32 [ 0, %.noexc5703 ], [ %cond.i.i.i3863, %if.then.split.i5675 ], [ %cond.i.i.i3863, %for.body.i.i5692 ]
  %m_data.i20.i5681 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 5, i32 5
  %1670 = load ptr, ptr %m_data.i20.i5681, align 8
  %tobool.not.i21.i5682 = icmp eq ptr %1670, null
  br i1 %tobool.not.i21.i5682, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5687, label %if.then.i22.i5683

if.then.i22.i5683:                                ; preds = %if.end.i5678
  %m_ownsMemory.i.i5684 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 5, i32 6
  %1671 = load i8, ptr %m_ownsMemory.i.i5684, align 8
  %1672 = and i8 %1671, 1
  %tobool2.not.i.i5685 = icmp eq i8 %1672, 0
  br i1 %tobool2.not.i.i5685, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5687, label %if.then3.i.i5686

if.then3.i.i5686:                                 ; preds = %if.then.i22.i5683
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1670)
          to label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5687 unwind label %lpad2055

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5687: ; preds = %if.then3.i.i5686, %if.then.i22.i5683, %if.end.i5678
  %m_ownsMemory.i5688 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 5, i32 6
  store i8 1, ptr %m_ownsMemory.i5688, align 8
  store ptr %retval.0.i25.i5679, ptr %m_data.i20.i5681, align 8
  store i32 %_Count.addr.0.i5680, ptr %m_capacity.i.i.i3842, align 8
  %.pre.i.i3864.pre = load i32, ptr %m_size.i.i.i3841, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3844

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3844: ; preds = %if.then.i.i3859, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5687, %if.then.i3839
  %1673 = phi i32 [ %1666, %if.then.i3839 ], [ %.pre.i.i3864.pre, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5687 ], [ %1666, %if.then.i.i3859 ]
  %m_data.i.i3845 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 5, i32 5
  %1674 = load ptr, ptr %m_data.i.i3845, align 8
  %idxprom.i.i3846 = sext i32 %1673 to i64
  %arrayidx.i.i3847 = getelementptr inbounds %struct.b3KernelArgData, ptr %1674, i64 %idxprom.i.i3846
  store i32 0, ptr %arrayidx.i.i3847, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i3848 = getelementptr inbounds i8, ptr %arrayidx.i.i3847, i64 4
  store i32 %1665, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i3848, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i3849 = getelementptr inbounds i8, ptr %arrayidx.i.i3847, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i3849, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i3850 = getelementptr inbounds i8, ptr %arrayidx.i.i3847, i64 16
  store i32 0, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i3850, align 16
  %1675 = load i32, ptr %m_size.i.i.i3841, align 4
  %inc.i.i3851 = add nsw i32 %1675, 1
  store i32 %inc.i.i3851, ptr %m_size.i.i.i3841, align 4
  %m_serializationSizeInBytes.i3852 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 6
  %1676 = load i32, ptr %m_serializationSizeInBytes.i3852, align 8
  %add.i3853 = add i32 %1676, 32
  store i32 %add.i3853, ptr %m_serializationSizeInBytes.i3852, align 8
  br label %if.end.i3854

if.end.i3854:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3844, %invoke.cont2058
  %1677 = load ptr, ptr @__clewSetKernelArg, align 8
  %1678 = load ptr, ptr %m_kernel.i3793, align 8
  %1679 = load i32, ptr %m_idx3.i3794, align 8
  %inc.i3857 = add nsw i32 %1679, 1
  store i32 %inc.i3857, ptr %m_idx3.i3794, align 8
  %call.i38583866 = invoke i32 %1677(ptr noundef %1678, i32 noundef %1679, i64 noundef 4, ptr noundef nonnull %debugMode)
          to label %invoke.cont2059 unwind label %lpad2055

invoke.cont2059:                                  ; preds = %if.end.i3854
  %1680 = load i32, ptr %numConcavePairs, align 4
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %gRange.i.i3868)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %lRange.i.i3869)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %gRange.i.i3868, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %lRange.i.i3869, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  store i64 64, ptr %lRange.i.i3869, align 16
  %arrayidx3.i.i3870 = getelementptr inbounds [3 x i64], ptr %lRange.i.i3869, i64 0, i64 1
  store i64 1, ptr %arrayidx3.i.i3870, align 8
  %conv5.i.i3871 = sext i32 %1680 to i64
  %div.i.i38726137 = lshr i64 %conv5.i.i3871, 6
  %rem.i.i3873 = and i64 %conv5.i.i3871, 63
  %tobool.not.i.i3874 = icmp ne i64 %rem.i.i3873, 0
  %conv9.i.i3875 = zext i1 %tobool.not.i.i3874 to i64
  %add.i.i3876 = add nuw nsw i64 %div.i.i38726137, %conv9.i.i3875
  %.sroa.speculated8.i.i3877 = call i64 @llvm.umax.i64(i64 %add.i.i3876, i64 1)
  %mul.i.i3878 = shl i64 %.sroa.speculated8.i.i3877, 6
  store i64 %mul.i.i3878, ptr %gRange.i.i3868, align 16
  %arrayidx27.i.i3879 = getelementptr inbounds [3 x i64], ptr %gRange.i.i3868, i64 0, i64 1
  store i64 1, ptr %arrayidx27.i.i3879, align 8
  %1681 = load ptr, ptr @__clewEnqueueNDRangeKernel, align 8
  %m_commandQueue.i.i3880 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2051, i64 0, i32 1
  %1682 = load ptr, ptr %m_commandQueue.i.i3880, align 8
  %1683 = load ptr, ptr %m_kernel.i3793, align 8
  %call32.i.i3886 = invoke i32 %1681(ptr noundef %1682, ptr noundef %1683, i32 noundef 2, ptr noundef null, ptr noundef nonnull %gRange.i.i3868, ptr noundef nonnull %lRange.i.i3869, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call32.i.i.noexc3885 unwind label %lpad2055

call32.i.i.noexc3885:                             ; preds = %invoke.cont2059
  %cmp.not.i.i3882 = icmp eq i32 %call32.i.i3886, 0
  br i1 %cmp.not.i.i3882, label %invoke.cont2061, label %if.then.i.i3883

if.then.i.i3883:                                  ; preds = %call32.i.i.noexc3885
  %call33.i.i3884 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.74, i32 noundef %call32.i.i3886)
  br label %invoke.cont2061

invoke.cont2061:                                  ; preds = %if.then.i.i3883, %call32.i.i.noexc3885
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %gRange.i.i3868)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %lRange.i.i3869)
  %1684 = load ptr, ptr @__clewFinish, align 8
  %1685 = load ptr, ptr %m_queue, align 8
  %call2064 = invoke i32 %1684(ptr noundef %1685)
          to label %invoke.cont2063 unwind label %lpad2055

invoke.cont2063:                                  ; preds = %invoke.cont2061
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher2051) #26
  invoke void @b3LeaveProfileZone()
          to label %if.end2067 unwind label %terminate.lpad.i3888

terminate.lpad.i3888:                             ; preds = %invoke.cont2063
  %1686 = landingpad { ptr, i32 }
          catch ptr null
  %1687 = extractvalue { ptr, i32 } %1686, 0
  call void @__clang_call_terminate(ptr %1687) #27
  unreachable

lpad2022:                                         ; preds = %invoke.cont2018
  %1688 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup2066

lpad2055:                                         ; preds = %if.then3.i.i5686, %.noexc5702, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5698, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5671, %if.then3.i.i5646, %.noexc5662, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5658, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5631, %if.then3.i.i5606, %.noexc5622, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5618, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5591, %invoke.cont2059, %if.end.i3854, %if.end.i3823, %if.end.i3792, %invoke.cont2061, %invoke.cont2053
  %1689 = landingpad { ptr, i32 }
          cleanup
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher2051) #26
  br label %ehcleanup2066

ehcleanup2066:                                    ; preds = %lpad2055, %lpad2022
  %.pn508 = phi { ptr, i32 } [ %1689, %lpad2055 ], [ %1688, %lpad2022 ]
  invoke void @b3LeaveProfileZone()
          to label %ehcleanup2980 unwind label %terminate.lpad.i3890

terminate.lpad.i3890:                             ; preds = %ehcleanup2066
  %1690 = landingpad { ptr, i32 }
          catch ptr null
  %1691 = extractvalue { ptr, i32 } %1690, 0
  call void @__clang_call_terminate(ptr %1691) #27
  unreachable

if.end2067:                                       ; preds = %invoke.cont2063, %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit3758
  %1692 = load i32, ptr %nContacts, align 4
  %1693 = load i32, ptr %numConcavePairs, align 4
  %add = add nsw i32 %1693, %1692
  store i32 %add, ptr %newContactCapacity, align 4
  %conv2068 = sext i32 %add to i64
  %call2070 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI10b3Contact4E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %contactOut, i64 noundef %conv2068, i1 noundef zeroext true)
          to label %invoke.cont2069 unwind label %lpad58

invoke.cont2069:                                  ; preds = %if.end2067
  %1694 = load i8, ptr @reduceConcaveContactsOnGPU, align 1
  %1695 = and i8 %1694, 1
  %tobool2071.not = icmp eq i8 %1695, 0
  br i1 %tobool2071.not, label %invoke.cont2134, label %if.then2072

if.then2072:                                      ; preds = %invoke.cont2069
  invoke void @b3EnterProfileZone(ptr noundef nonnull @.str.23)
          to label %invoke.cont2074 unwind label %lpad58

invoke.cont2074:                                  ; preds = %if.then2072
  %m_clBuffer.i3894 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %triangleConvexPairsOut, i64 0, i32 3
  %1696 = load ptr, ptr %m_clBuffer.i3894, align 8
  store ptr %1696, ptr %bInfo2075, align 16
  %m_isReadOnly.i3895 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2075, i64 0, i32 1
  store i8 1, ptr %m_isReadOnly.i3895, align 8
  %arrayinit.element2081 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2075, i64 1
  %1697 = load ptr, ptr %m_clBuffer.i531, align 8
  store ptr %1697, ptr %arrayinit.element2081, align 16
  %m_isReadOnly.i3897 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2075, i64 1, i32 1
  store i8 1, ptr %m_isReadOnly.i3897, align 8
  %arrayinit.element2085 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2075, i64 2
  %m_clBuffer.i3898 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 29, i32 3
  %1698 = load ptr, ptr %m_clBuffer.i3898, align 8
  store ptr %1698, ptr %arrayinit.element2085, align 16
  %m_isReadOnly.i3899 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2075, i64 2, i32 1
  store i8 0, ptr %m_isReadOnly.i3899, align 8
  %arrayinit.element2090 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2075, i64 3
  %m_clBuffer.i3900 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 30, i32 3
  %1699 = load ptr, ptr %m_clBuffer.i3900, align 8
  store ptr %1699, ptr %arrayinit.element2090, align 16
  %m_isReadOnly.i3901 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2075, i64 3, i32 1
  store i8 0, ptr %m_isReadOnly.i3901, align 8
  %arrayinit.element2095 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2075, i64 4
  %1700 = load ptr, ptr %m_clBuffer.i545, align 8
  store ptr %1700, ptr %arrayinit.element2095, align 16
  %m_isReadOnly.i3903 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2075, i64 4, i32 1
  store i8 0, ptr %m_isReadOnly.i3903, align 8
  %arrayinit.element2099 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2075, i64 5
  %m_clBuffer.i3904 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %clippingFacesOutGPU, i64 0, i32 3
  %1701 = load ptr, ptr %m_clBuffer.i3904, align 8
  store ptr %1701, ptr %arrayinit.element2099, align 16
  %m_isReadOnly.i3905 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2075, i64 5, i32 1
  store i8 0, ptr %m_isReadOnly.i3905, align 8
  %arrayinit.element2103 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2075, i64 6
  %m_clBuffer.i3906 = getelementptr inbounds %class.b3OpenCLArray, ptr %worldVertsB2GPU, i64 0, i32 3
  %1702 = load ptr, ptr %m_clBuffer.i3906, align 8
  store ptr %1702, ptr %arrayinit.element2103, align 16
  %m_isReadOnly.i3907 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2075, i64 6, i32 1
  store i8 0, ptr %m_isReadOnly.i3907, align 8
  %arrayinit.element2107 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2075, i64 7
  %1703 = load ptr, ptr %m_clBuffer.i, align 8
  store ptr %1703, ptr %arrayinit.element2107, align 16
  %m_isReadOnly.i3909 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2075, i64 7, i32 1
  store i8 0, ptr %m_isReadOnly.i3909, align 8
  %1704 = load ptr, ptr %m_queue, align 8
  %m_newContactReductionKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 19
  %1705 = load ptr, ptr %m_newContactReductionKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher2112, ptr noundef %1704, ptr noundef %1705, ptr noundef nonnull @.str.60)
          to label %invoke.cont2114 unwind label %lpad2077

invoke.cont2114:                                  ; preds = %invoke.cont2074
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher2112, ptr noundef nonnull %bInfo2075, i32 noundef 8)
          to label %invoke.cont2117 unwind label %lpad2116

invoke.cont2117:                                  ; preds = %invoke.cont2114
  %m_enableSerialization.i3910 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 7
  %1706 = load i8, ptr %m_enableSerialization.i3910, align 4
  %1707 = and i8 %1706, 1
  %tobool.not.i3911 = icmp eq i8 %1707, 0
  br i1 %tobool.not.i3911, label %if.end.i3927, label %if.then.i3912

if.then.i3912:                                    ; preds = %invoke.cont2117
  %m_idx.i3913 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 3
  %1708 = load i32, ptr %m_idx.i3913, align 8
  %1709 = load i32, ptr %vertexFaceCapacity, align 4
  %m_size.i.i.i3914 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 5, i32 2
  %1710 = load i32, ptr %m_size.i.i.i3914, align 4
  %m_capacity.i.i.i3915 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 5, i32 3
  %1711 = load i32, ptr %m_capacity.i.i.i3915, align 8
  %cmp.i.i3916 = icmp eq i32 %1710, %1711
  br i1 %cmp.i.i3916, label %if.then.i.i3932, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3917

if.then.i.i3932:                                  ; preds = %if.then.i3912
  %tobool.not.i.i.i3934 = icmp eq i32 %1710, 0
  %mul.i.i.i3935 = shl nsw i32 %1710, 1
  %cond.i.i.i3936 = select i1 %tobool.not.i.i.i3934, i32 1, i32 %mul.i.i.i3935
  %cmp.i5707 = icmp slt i32 %1710, %cond.i.i.i3936
  br i1 %cmp.i5707, label %if.then.i5709, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3917

if.then.i5709:                                    ; preds = %if.then.i.i3932
  %tobool.not.i.i5710 = icmp eq i32 %cond.i.i.i3936, 0
  br i1 %tobool.not.i.i5710, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5738, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5711

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5711: ; preds = %if.then.i5709
  %conv.i.i.i5712 = sext i32 %cond.i.i.i3936 to i64
  %mul.i.i.i5713 = shl nsw i64 %conv.i.i.i5712, 5
  %call.i.i.i5741 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i5713, i32 noundef 16)
          to label %call.i.i.i.noexc5740 unwind label %lpad2116

call.i.i.i.noexc5740:                             ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5711
  %cmp3.i5714 = icmp eq ptr %call.i.i.i5741, null
  br i1 %cmp3.i5714, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5738, label %if.then.split.i5715

if.then.split.i5715:                              ; preds = %call.i.i.i.noexc5740
  %1712 = load i32, ptr %m_size.i.i.i3914, align 4
  %cmp4.i.i5717 = icmp sgt i32 %1712, 0
  br i1 %cmp4.i.i5717, label %for.body.lr.ph.i.i5729, label %if.end.i5718

for.body.lr.ph.i.i5729:                           ; preds = %if.then.split.i5715
  %m_data.i.i5730 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 5, i32 5
  %wide.trip.count.i.i5731 = zext nneg i32 %1712 to i64
  br label %for.body.i.i5732

for.body.i.i5732:                                 ; preds = %for.body.i.i5732, %for.body.lr.ph.i.i5729
  %indvars.iv.i.i5733 = phi i64 [ 0, %for.body.lr.ph.i.i5729 ], [ %indvars.iv.next.i.i5736, %for.body.i.i5732 ]
  %arrayidx.i.i5734 = getelementptr inbounds %struct.b3KernelArgData, ptr %call.i.i.i5741, i64 %indvars.iv.i.i5733
  %1713 = load ptr, ptr %m_data.i.i5730, align 8
  %arrayidx3.i.i5735 = getelementptr inbounds %struct.b3KernelArgData, ptr %1713, i64 %indvars.iv.i.i5733
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i.i5734, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i.i5735, i64 32, i1 false)
  %indvars.iv.next.i.i5736 = add nuw nsw i64 %indvars.iv.i.i5733, 1
  %exitcond.not.i.i5737 = icmp eq i64 %indvars.iv.next.i.i5736, %wide.trip.count.i.i5731
  br i1 %exitcond.not.i.i5737, label %if.end.i5718, label %for.body.i.i5732, !llvm.loop !64

_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5738: ; preds = %call.i.i.i.noexc5740, %if.then.i5709
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc5742 unwind label %lpad2116

.noexc5742:                                       ; preds = %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5738
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc5743 unwind label %lpad2116

.noexc5743:                                       ; preds = %.noexc5742
  store i32 0, ptr %m_size.i.i.i3914, align 4
  br label %if.end.i5718

if.end.i5718:                                     ; preds = %for.body.i.i5732, %.noexc5743, %if.then.split.i5715
  %retval.0.i25.i5719 = phi ptr [ null, %.noexc5743 ], [ %call.i.i.i5741, %if.then.split.i5715 ], [ %call.i.i.i5741, %for.body.i.i5732 ]
  %_Count.addr.0.i5720 = phi i32 [ 0, %.noexc5743 ], [ %cond.i.i.i3936, %if.then.split.i5715 ], [ %cond.i.i.i3936, %for.body.i.i5732 ]
  %m_data.i20.i5721 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 5, i32 5
  %1714 = load ptr, ptr %m_data.i20.i5721, align 8
  %tobool.not.i21.i5722 = icmp eq ptr %1714, null
  br i1 %tobool.not.i21.i5722, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5727, label %if.then.i22.i5723

if.then.i22.i5723:                                ; preds = %if.end.i5718
  %m_ownsMemory.i.i5724 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 5, i32 6
  %1715 = load i8, ptr %m_ownsMemory.i.i5724, align 8
  %1716 = and i8 %1715, 1
  %tobool2.not.i.i5725 = icmp eq i8 %1716, 0
  br i1 %tobool2.not.i.i5725, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5727, label %if.then3.i.i5726

if.then3.i.i5726:                                 ; preds = %if.then.i22.i5723
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1714)
          to label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5727 unwind label %lpad2116

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5727: ; preds = %if.then3.i.i5726, %if.then.i22.i5723, %if.end.i5718
  %m_ownsMemory.i5728 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 5, i32 6
  store i8 1, ptr %m_ownsMemory.i5728, align 8
  store ptr %retval.0.i25.i5719, ptr %m_data.i20.i5721, align 8
  store i32 %_Count.addr.0.i5720, ptr %m_capacity.i.i.i3915, align 8
  %.pre.i.i3937.pre = load i32, ptr %m_size.i.i.i3914, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3917

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3917: ; preds = %if.then.i.i3932, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5727, %if.then.i3912
  %1717 = phi i32 [ %1710, %if.then.i3912 ], [ %.pre.i.i3937.pre, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5727 ], [ %1710, %if.then.i.i3932 ]
  %m_data.i.i3918 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 5, i32 5
  %1718 = load ptr, ptr %m_data.i.i3918, align 8
  %idxprom.i.i3919 = sext i32 %1717 to i64
  %arrayidx.i.i3920 = getelementptr inbounds %struct.b3KernelArgData, ptr %1718, i64 %idxprom.i.i3919
  store i32 0, ptr %arrayidx.i.i3920, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i3921 = getelementptr inbounds i8, ptr %arrayidx.i.i3920, i64 4
  store i32 %1708, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i3921, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i3922 = getelementptr inbounds i8, ptr %arrayidx.i.i3920, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i3922, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i3923 = getelementptr inbounds i8, ptr %arrayidx.i.i3920, i64 16
  store i32 %1709, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i3923, align 16
  %1719 = load i32, ptr %m_size.i.i.i3914, align 4
  %inc.i.i3924 = add nsw i32 %1719, 1
  store i32 %inc.i.i3924, ptr %m_size.i.i.i3914, align 4
  %m_serializationSizeInBytes.i3925 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 6
  %1720 = load i32, ptr %m_serializationSizeInBytes.i3925, align 8
  %add.i3926 = add i32 %1720, 32
  store i32 %add.i3926, ptr %m_serializationSizeInBytes.i3925, align 8
  br label %if.end.i3927

if.end.i3927:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3917, %invoke.cont2117
  %1721 = load ptr, ptr @__clewSetKernelArg, align 8
  %m_kernel.i3928 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 2
  %1722 = load ptr, ptr %m_kernel.i3928, align 8
  %m_idx3.i3929 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 3
  %1723 = load i32, ptr %m_idx3.i3929, align 8
  %inc.i3930 = add nsw i32 %1723, 1
  store i32 %inc.i3930, ptr %m_idx3.i3929, align 8
  %call.i39313939 = invoke i32 %1721(ptr noundef %1722, i32 noundef %1723, i64 noundef 4, ptr noundef nonnull %vertexFaceCapacity)
          to label %invoke.cont2118 unwind label %lpad2116

invoke.cont2118:                                  ; preds = %if.end.i3927
  %1724 = load i8, ptr %m_enableSerialization.i3910, align 4
  %1725 = and i8 %1724, 1
  %tobool.not.i3942 = icmp eq i8 %1725, 0
  br i1 %tobool.not.i3942, label %if.end.i3958, label %if.then.i3943

if.then.i3943:                                    ; preds = %invoke.cont2118
  %1726 = load i32, ptr %m_idx3.i3929, align 8
  %1727 = load i32, ptr %newContactCapacity, align 4
  %m_size.i.i.i3945 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 5, i32 2
  %1728 = load i32, ptr %m_size.i.i.i3945, align 4
  %m_capacity.i.i.i3946 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 5, i32 3
  %1729 = load i32, ptr %m_capacity.i.i.i3946, align 8
  %cmp.i.i3947 = icmp eq i32 %1728, %1729
  br i1 %cmp.i.i3947, label %if.then.i.i3963, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3948

if.then.i.i3963:                                  ; preds = %if.then.i3943
  %tobool.not.i.i.i3965 = icmp eq i32 %1728, 0
  %mul.i.i.i3966 = shl nsw i32 %1728, 1
  %cond.i.i.i3967 = select i1 %tobool.not.i.i.i3965, i32 1, i32 %mul.i.i.i3966
  %cmp.i5747 = icmp slt i32 %1728, %cond.i.i.i3967
  br i1 %cmp.i5747, label %if.then.i5749, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3948

if.then.i5749:                                    ; preds = %if.then.i.i3963
  %tobool.not.i.i5750 = icmp eq i32 %cond.i.i.i3967, 0
  br i1 %tobool.not.i.i5750, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5778, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5751

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5751: ; preds = %if.then.i5749
  %conv.i.i.i5752 = sext i32 %cond.i.i.i3967 to i64
  %mul.i.i.i5753 = shl nsw i64 %conv.i.i.i5752, 5
  %call.i.i.i5781 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i5753, i32 noundef 16)
          to label %call.i.i.i.noexc5780 unwind label %lpad2116

call.i.i.i.noexc5780:                             ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5751
  %cmp3.i5754 = icmp eq ptr %call.i.i.i5781, null
  br i1 %cmp3.i5754, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5778, label %if.then.split.i5755

if.then.split.i5755:                              ; preds = %call.i.i.i.noexc5780
  %1730 = load i32, ptr %m_size.i.i.i3945, align 4
  %cmp4.i.i5757 = icmp sgt i32 %1730, 0
  br i1 %cmp4.i.i5757, label %for.body.lr.ph.i.i5769, label %if.end.i5758

for.body.lr.ph.i.i5769:                           ; preds = %if.then.split.i5755
  %m_data.i.i5770 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 5, i32 5
  %wide.trip.count.i.i5771 = zext nneg i32 %1730 to i64
  br label %for.body.i.i5772

for.body.i.i5772:                                 ; preds = %for.body.i.i5772, %for.body.lr.ph.i.i5769
  %indvars.iv.i.i5773 = phi i64 [ 0, %for.body.lr.ph.i.i5769 ], [ %indvars.iv.next.i.i5776, %for.body.i.i5772 ]
  %arrayidx.i.i5774 = getelementptr inbounds %struct.b3KernelArgData, ptr %call.i.i.i5781, i64 %indvars.iv.i.i5773
  %1731 = load ptr, ptr %m_data.i.i5770, align 8
  %arrayidx3.i.i5775 = getelementptr inbounds %struct.b3KernelArgData, ptr %1731, i64 %indvars.iv.i.i5773
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i.i5774, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i.i5775, i64 32, i1 false)
  %indvars.iv.next.i.i5776 = add nuw nsw i64 %indvars.iv.i.i5773, 1
  %exitcond.not.i.i5777 = icmp eq i64 %indvars.iv.next.i.i5776, %wide.trip.count.i.i5771
  br i1 %exitcond.not.i.i5777, label %if.end.i5758, label %for.body.i.i5772, !llvm.loop !64

_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5778: ; preds = %call.i.i.i.noexc5780, %if.then.i5749
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc5782 unwind label %lpad2116

.noexc5782:                                       ; preds = %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5778
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc5783 unwind label %lpad2116

.noexc5783:                                       ; preds = %.noexc5782
  store i32 0, ptr %m_size.i.i.i3945, align 4
  br label %if.end.i5758

if.end.i5758:                                     ; preds = %for.body.i.i5772, %.noexc5783, %if.then.split.i5755
  %retval.0.i25.i5759 = phi ptr [ null, %.noexc5783 ], [ %call.i.i.i5781, %if.then.split.i5755 ], [ %call.i.i.i5781, %for.body.i.i5772 ]
  %_Count.addr.0.i5760 = phi i32 [ 0, %.noexc5783 ], [ %cond.i.i.i3967, %if.then.split.i5755 ], [ %cond.i.i.i3967, %for.body.i.i5772 ]
  %m_data.i20.i5761 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 5, i32 5
  %1732 = load ptr, ptr %m_data.i20.i5761, align 8
  %tobool.not.i21.i5762 = icmp eq ptr %1732, null
  br i1 %tobool.not.i21.i5762, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5767, label %if.then.i22.i5763

if.then.i22.i5763:                                ; preds = %if.end.i5758
  %m_ownsMemory.i.i5764 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 5, i32 6
  %1733 = load i8, ptr %m_ownsMemory.i.i5764, align 8
  %1734 = and i8 %1733, 1
  %tobool2.not.i.i5765 = icmp eq i8 %1734, 0
  br i1 %tobool2.not.i.i5765, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5767, label %if.then3.i.i5766

if.then3.i.i5766:                                 ; preds = %if.then.i22.i5763
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1732)
          to label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5767 unwind label %lpad2116

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5767: ; preds = %if.then3.i.i5766, %if.then.i22.i5763, %if.end.i5758
  %m_ownsMemory.i5768 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 5, i32 6
  store i8 1, ptr %m_ownsMemory.i5768, align 8
  store ptr %retval.0.i25.i5759, ptr %m_data.i20.i5761, align 8
  store i32 %_Count.addr.0.i5760, ptr %m_capacity.i.i.i3946, align 8
  %.pre.i.i3968.pre = load i32, ptr %m_size.i.i.i3945, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3948

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3948: ; preds = %if.then.i.i3963, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5767, %if.then.i3943
  %1735 = phi i32 [ %1728, %if.then.i3943 ], [ %.pre.i.i3968.pre, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5767 ], [ %1728, %if.then.i.i3963 ]
  %m_data.i.i3949 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 5, i32 5
  %1736 = load ptr, ptr %m_data.i.i3949, align 8
  %idxprom.i.i3950 = sext i32 %1735 to i64
  %arrayidx.i.i3951 = getelementptr inbounds %struct.b3KernelArgData, ptr %1736, i64 %idxprom.i.i3950
  store i32 0, ptr %arrayidx.i.i3951, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i3952 = getelementptr inbounds i8, ptr %arrayidx.i.i3951, i64 4
  store i32 %1726, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i3952, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i3953 = getelementptr inbounds i8, ptr %arrayidx.i.i3951, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i3953, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i3954 = getelementptr inbounds i8, ptr %arrayidx.i.i3951, i64 16
  store i32 %1727, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i3954, align 16
  %1737 = load i32, ptr %m_size.i.i.i3945, align 4
  %inc.i.i3955 = add nsw i32 %1737, 1
  store i32 %inc.i.i3955, ptr %m_size.i.i.i3945, align 4
  %m_serializationSizeInBytes.i3956 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 6
  %1738 = load i32, ptr %m_serializationSizeInBytes.i3956, align 8
  %add.i3957 = add i32 %1738, 32
  store i32 %add.i3957, ptr %m_serializationSizeInBytes.i3956, align 8
  br label %if.end.i3958

if.end.i3958:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3948, %invoke.cont2118
  %1739 = load ptr, ptr @__clewSetKernelArg, align 8
  %1740 = load ptr, ptr %m_kernel.i3928, align 8
  %1741 = load i32, ptr %m_idx3.i3929, align 8
  %inc.i3961 = add nsw i32 %1741, 1
  store i32 %inc.i3961, ptr %m_idx3.i3929, align 8
  %call.i39623970 = invoke i32 %1739(ptr noundef %1740, i32 noundef %1741, i64 noundef 4, ptr noundef nonnull %newContactCapacity)
          to label %invoke.cont2119 unwind label %lpad2116

invoke.cont2119:                                  ; preds = %if.end.i3958
  %1742 = load i8, ptr %m_enableSerialization.i3910, align 4
  %1743 = and i8 %1742, 1
  %tobool.not.i3973 = icmp eq i8 %1743, 0
  br i1 %tobool.not.i3973, label %if.end.i3989, label %if.then.i3974

if.then.i3974:                                    ; preds = %invoke.cont2119
  %1744 = load i32, ptr %m_idx3.i3929, align 8
  %1745 = load i32, ptr %numConcavePairs, align 4
  %m_size.i.i.i3976 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 5, i32 2
  %1746 = load i32, ptr %m_size.i.i.i3976, align 4
  %m_capacity.i.i.i3977 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 5, i32 3
  %1747 = load i32, ptr %m_capacity.i.i.i3977, align 8
  %cmp.i.i3978 = icmp eq i32 %1746, %1747
  br i1 %cmp.i.i3978, label %if.then.i.i3994, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3979

if.then.i.i3994:                                  ; preds = %if.then.i3974
  %tobool.not.i.i.i3996 = icmp eq i32 %1746, 0
  %mul.i.i.i3997 = shl nsw i32 %1746, 1
  %cond.i.i.i3998 = select i1 %tobool.not.i.i.i3996, i32 1, i32 %mul.i.i.i3997
  %cmp.i5787 = icmp slt i32 %1746, %cond.i.i.i3998
  br i1 %cmp.i5787, label %if.then.i5789, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3979

if.then.i5789:                                    ; preds = %if.then.i.i3994
  %tobool.not.i.i5790 = icmp eq i32 %cond.i.i.i3998, 0
  br i1 %tobool.not.i.i5790, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5818, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5791

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5791: ; preds = %if.then.i5789
  %conv.i.i.i5792 = sext i32 %cond.i.i.i3998 to i64
  %mul.i.i.i5793 = shl nsw i64 %conv.i.i.i5792, 5
  %call.i.i.i5821 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i5793, i32 noundef 16)
          to label %call.i.i.i.noexc5820 unwind label %lpad2116

call.i.i.i.noexc5820:                             ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5791
  %cmp3.i5794 = icmp eq ptr %call.i.i.i5821, null
  br i1 %cmp3.i5794, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5818, label %if.then.split.i5795

if.then.split.i5795:                              ; preds = %call.i.i.i.noexc5820
  %1748 = load i32, ptr %m_size.i.i.i3976, align 4
  %cmp4.i.i5797 = icmp sgt i32 %1748, 0
  br i1 %cmp4.i.i5797, label %for.body.lr.ph.i.i5809, label %if.end.i5798

for.body.lr.ph.i.i5809:                           ; preds = %if.then.split.i5795
  %m_data.i.i5810 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 5, i32 5
  %wide.trip.count.i.i5811 = zext nneg i32 %1748 to i64
  br label %for.body.i.i5812

for.body.i.i5812:                                 ; preds = %for.body.i.i5812, %for.body.lr.ph.i.i5809
  %indvars.iv.i.i5813 = phi i64 [ 0, %for.body.lr.ph.i.i5809 ], [ %indvars.iv.next.i.i5816, %for.body.i.i5812 ]
  %arrayidx.i.i5814 = getelementptr inbounds %struct.b3KernelArgData, ptr %call.i.i.i5821, i64 %indvars.iv.i.i5813
  %1749 = load ptr, ptr %m_data.i.i5810, align 8
  %arrayidx3.i.i5815 = getelementptr inbounds %struct.b3KernelArgData, ptr %1749, i64 %indvars.iv.i.i5813
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i.i5814, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i.i5815, i64 32, i1 false)
  %indvars.iv.next.i.i5816 = add nuw nsw i64 %indvars.iv.i.i5813, 1
  %exitcond.not.i.i5817 = icmp eq i64 %indvars.iv.next.i.i5816, %wide.trip.count.i.i5811
  br i1 %exitcond.not.i.i5817, label %if.end.i5798, label %for.body.i.i5812, !llvm.loop !64

_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5818: ; preds = %call.i.i.i.noexc5820, %if.then.i5789
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc5822 unwind label %lpad2116

.noexc5822:                                       ; preds = %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5818
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc5823 unwind label %lpad2116

.noexc5823:                                       ; preds = %.noexc5822
  store i32 0, ptr %m_size.i.i.i3976, align 4
  br label %if.end.i5798

if.end.i5798:                                     ; preds = %for.body.i.i5812, %.noexc5823, %if.then.split.i5795
  %retval.0.i25.i5799 = phi ptr [ null, %.noexc5823 ], [ %call.i.i.i5821, %if.then.split.i5795 ], [ %call.i.i.i5821, %for.body.i.i5812 ]
  %_Count.addr.0.i5800 = phi i32 [ 0, %.noexc5823 ], [ %cond.i.i.i3998, %if.then.split.i5795 ], [ %cond.i.i.i3998, %for.body.i.i5812 ]
  %m_data.i20.i5801 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 5, i32 5
  %1750 = load ptr, ptr %m_data.i20.i5801, align 8
  %tobool.not.i21.i5802 = icmp eq ptr %1750, null
  br i1 %tobool.not.i21.i5802, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5807, label %if.then.i22.i5803

if.then.i22.i5803:                                ; preds = %if.end.i5798
  %m_ownsMemory.i.i5804 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 5, i32 6
  %1751 = load i8, ptr %m_ownsMemory.i.i5804, align 8
  %1752 = and i8 %1751, 1
  %tobool2.not.i.i5805 = icmp eq i8 %1752, 0
  br i1 %tobool2.not.i.i5805, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5807, label %if.then3.i.i5806

if.then3.i.i5806:                                 ; preds = %if.then.i22.i5803
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1750)
          to label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5807 unwind label %lpad2116

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5807: ; preds = %if.then3.i.i5806, %if.then.i22.i5803, %if.end.i5798
  %m_ownsMemory.i5808 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 5, i32 6
  store i8 1, ptr %m_ownsMemory.i5808, align 8
  store ptr %retval.0.i25.i5799, ptr %m_data.i20.i5801, align 8
  store i32 %_Count.addr.0.i5800, ptr %m_capacity.i.i.i3977, align 8
  %.pre.i.i3999.pre = load i32, ptr %m_size.i.i.i3976, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3979

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3979: ; preds = %if.then.i.i3994, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5807, %if.then.i3974
  %1753 = phi i32 [ %1746, %if.then.i3974 ], [ %.pre.i.i3999.pre, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5807 ], [ %1746, %if.then.i.i3994 ]
  %m_data.i.i3980 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 5, i32 5
  %1754 = load ptr, ptr %m_data.i.i3980, align 8
  %idxprom.i.i3981 = sext i32 %1753 to i64
  %arrayidx.i.i3982 = getelementptr inbounds %struct.b3KernelArgData, ptr %1754, i64 %idxprom.i.i3981
  store i32 0, ptr %arrayidx.i.i3982, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i3983 = getelementptr inbounds i8, ptr %arrayidx.i.i3982, i64 4
  store i32 %1744, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i3983, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i3984 = getelementptr inbounds i8, ptr %arrayidx.i.i3982, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i3984, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i3985 = getelementptr inbounds i8, ptr %arrayidx.i.i3982, i64 16
  store i32 %1745, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i3985, align 16
  %1755 = load i32, ptr %m_size.i.i.i3976, align 4
  %inc.i.i3986 = add nsw i32 %1755, 1
  store i32 %inc.i.i3986, ptr %m_size.i.i.i3976, align 4
  %m_serializationSizeInBytes.i3987 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 6
  %1756 = load i32, ptr %m_serializationSizeInBytes.i3987, align 8
  %add.i3988 = add i32 %1756, 32
  store i32 %add.i3988, ptr %m_serializationSizeInBytes.i3987, align 8
  br label %if.end.i3989

if.end.i3989:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i3979, %invoke.cont2119
  %1757 = load ptr, ptr @__clewSetKernelArg, align 8
  %1758 = load ptr, ptr %m_kernel.i3928, align 8
  %1759 = load i32, ptr %m_idx3.i3929, align 8
  %inc.i3992 = add nsw i32 %1759, 1
  store i32 %inc.i3992, ptr %m_idx3.i3929, align 8
  %call.i39934001 = invoke i32 %1757(ptr noundef %1758, i32 noundef %1759, i64 noundef 4, ptr noundef nonnull %numConcavePairs)
          to label %invoke.cont2120 unwind label %lpad2116

invoke.cont2120:                                  ; preds = %if.end.i3989
  %1760 = load i32, ptr %numConcavePairs, align 4
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %gRange.i.i4003)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %lRange.i.i4004)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %gRange.i.i4003, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %lRange.i.i4004, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  store i64 64, ptr %lRange.i.i4004, align 16
  %arrayidx3.i.i4005 = getelementptr inbounds [3 x i64], ptr %lRange.i.i4004, i64 0, i64 1
  store i64 1, ptr %arrayidx3.i.i4005, align 8
  %conv5.i.i4006 = sext i32 %1760 to i64
  %div.i.i40076138 = lshr i64 %conv5.i.i4006, 6
  %rem.i.i4008 = and i64 %conv5.i.i4006, 63
  %tobool.not.i.i4009 = icmp ne i64 %rem.i.i4008, 0
  %conv9.i.i4010 = zext i1 %tobool.not.i.i4009 to i64
  %add.i.i4011 = add nuw nsw i64 %div.i.i40076138, %conv9.i.i4010
  %.sroa.speculated8.i.i4012 = call i64 @llvm.umax.i64(i64 %add.i.i4011, i64 1)
  %mul.i.i4013 = shl i64 %.sroa.speculated8.i.i4012, 6
  store i64 %mul.i.i4013, ptr %gRange.i.i4003, align 16
  %arrayidx27.i.i4014 = getelementptr inbounds [3 x i64], ptr %gRange.i.i4003, i64 0, i64 1
  store i64 1, ptr %arrayidx27.i.i4014, align 8
  %1761 = load ptr, ptr @__clewEnqueueNDRangeKernel, align 8
  %m_commandQueue.i.i4015 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2112, i64 0, i32 1
  %1762 = load ptr, ptr %m_commandQueue.i.i4015, align 8
  %1763 = load ptr, ptr %m_kernel.i3928, align 8
  %call32.i.i4021 = invoke i32 %1761(ptr noundef %1762, ptr noundef %1763, i32 noundef 2, ptr noundef null, ptr noundef nonnull %gRange.i.i4003, ptr noundef nonnull %lRange.i.i4004, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call32.i.i.noexc4020 unwind label %lpad2116

call32.i.i.noexc4020:                             ; preds = %invoke.cont2120
  %cmp.not.i.i4017 = icmp eq i32 %call32.i.i4021, 0
  br i1 %cmp.not.i.i4017, label %invoke.cont2122, label %if.then.i.i4018

if.then.i.i4018:                                  ; preds = %call32.i.i.noexc4020
  %call33.i.i4019 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.74, i32 noundef %call32.i.i4021)
  br label %invoke.cont2122

invoke.cont2122:                                  ; preds = %if.then.i.i4018, %call32.i.i.noexc4020
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %gRange.i.i4003)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %lRange.i.i4004)
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher2112) #26
  invoke void @b3LeaveProfileZone()
          to label %_ZN13b3ProfileZoneD2Ev.exit4024 unwind label %terminate.lpad.i4023

terminate.lpad.i4023:                             ; preds = %invoke.cont2122
  %1764 = landingpad { ptr, i32 }
          catch ptr null
  %1765 = extractvalue { ptr, i32 } %1764, 0
  call void @__clang_call_terminate(ptr %1765) #27
  unreachable

_ZN13b3ProfileZoneD2Ev.exit4024:                  ; preds = %invoke.cont2122
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %elem.i4025)
  %1766 = load i64, ptr %m_capacity.i.i.i584, align 8
  %cmp.not.i.i4027 = icmp eq i64 %1766, 0
  br i1 %cmp.not.i.i4027, label %do.body.i.i4032, label %if.then.i.i4028

if.then.i.i4028:                                  ; preds = %_ZN13b3ProfileZoneD2Ev.exit4024
  %1767 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %1768 = load ptr, ptr %m_commandQueue.i, align 8
  %1769 = load ptr, ptr %m_clBuffer.i, align 8
  %call3.i.i4034 = invoke i32 %1767(ptr noundef %1768, ptr noundef %1769, i32 noundef 0, i64 noundef 0, i64 noundef 4, ptr noundef nonnull %elem.i4025, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call3.i.i.noexc4033 unwind label %lpad58

call3.i.i.noexc4033:                              ; preds = %if.then.i.i4028
  %1770 = load ptr, ptr @__clewFinish, align 8
  %1771 = load ptr, ptr %m_commandQueue.i, align 8
  %call6.i.i4036 = invoke i32 %1770(ptr noundef %1771)
          to label %call6.i.i.noexc4035 unwind label %lpad58

call6.i.i.noexc4035:                              ; preds = %call3.i.i.noexc4033
  %.pre.i4031 = load i32, ptr %elem.i4025, align 4
  br label %invoke.cont2126

do.body.i.i4032:                                  ; preds = %_ZN13b3ProfileZoneD2Ev.exit4024
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 285)
          to label %.noexc4037 unwind label %lpad58

.noexc4037:                                       ; preds = %do.body.i.i4032
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.80)
          to label %invoke.cont2126 unwind label %lpad58

invoke.cont2126:                                  ; preds = %call6.i.i.noexc4035, %.noexc4037
  %1772 = phi i32 [ %.pre.i4031, %call6.i.i.noexc4035 ], [ undef, %.noexc4037 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %elem.i4025)
  store i32 %1772, ptr %nContacts, align 4
  %conv2128 = sext i32 %1772 to i64
  %1773 = load i64, ptr %m_size.i.i, align 8
  %cmp3.i4041 = icmp ult i64 %1773, %conv2128
  br i1 %cmp3.i4041, label %if.end7.i4044, label %_ZN13b3OpenCLArrayI10b3Contact4E6resizeEmb.exit4048

if.end7.i4044:                                    ; preds = %invoke.cont2126
  %call5.i4047 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI10b3Contact4E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %contactOut, i64 noundef %conv2128, i1 noundef zeroext true)
          to label %call5.i.noexc4046 unwind label %lpad58

call5.i.noexc4046:                                ; preds = %if.end7.i4044
  %spec.select.i4045 = select i1 %call5.i4047, i64 %conv2128, i64 0
  br label %_ZN13b3OpenCLArrayI10b3Contact4E6resizeEmb.exit4048

_ZN13b3OpenCLArrayI10b3Contact4E6resizeEmb.exit4048: ; preds = %invoke.cont2126, %call5.i.noexc4046
  %storemerge.i4042 = phi i64 [ %conv2128, %invoke.cont2126 ], [ %spec.select.i4045, %call5.i.noexc4046 ]
  store i64 %storemerge.i4042, ptr %m_size.i.i, align 8
  br label %if.then2293

lpad2077:                                         ; preds = %invoke.cont2074
  %1774 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup2124

lpad2116:                                         ; preds = %if.then3.i.i5806, %.noexc5822, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5818, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5791, %if.then3.i.i5766, %.noexc5782, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5778, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5751, %if.then3.i.i5726, %.noexc5742, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5738, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5711, %invoke.cont2120, %if.end.i3989, %if.end.i3958, %if.end.i3927, %invoke.cont2114
  %1775 = landingpad { ptr, i32 }
          cleanup
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher2112) #26
  br label %ehcleanup2124

ehcleanup2124:                                    ; preds = %lpad2116, %lpad2077
  %.pn517 = phi { ptr, i32 } [ %1775, %lpad2116 ], [ %1774, %lpad2077 ]
  invoke void @b3LeaveProfileZone()
          to label %ehcleanup2980 unwind label %terminate.lpad.i4049

terminate.lpad.i4049:                             ; preds = %ehcleanup2124
  %1776 = landingpad { ptr, i32 }
          catch ptr null
  %1777 = extractvalue { ptr, i32 } %1776, 0
  call void @__clang_call_terminate(ptr %1777) #27
  unreachable

invoke.cont2134:                                  ; preds = %invoke.cont2069
  %1778 = load i32, ptr %nContacts, align 4
  store volatile i32 %1778, ptr %nGlobalContactsOut2132, align 4
  %m_ownsMemory.i.i4051 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %triangleConvexPairsOutHost2133, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i4051, align 8
  %m_data.i.i4052 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %triangleConvexPairsOutHost2133, i64 0, i32 5
  store ptr null, ptr %m_data.i.i4052, align 8
  %m_size.i.i4053 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %triangleConvexPairsOutHost2133, i64 0, i32 2
  store i32 0, ptr %m_size.i.i4053, align 4
  %m_capacity.i.i4054 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %triangleConvexPairsOutHost2133, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i4054, align 8
  invoke void @_ZNK13b3OpenCLArrayI6b3Int4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %triangleConvexPairsOut, ptr noundef nonnull align 8 dereferenceable(25) %triangleConvexPairsOutHost2133, i1 noundef zeroext true)
          to label %invoke.cont2138 unwind label %lpad2135

invoke.cont2138:                                  ; preds = %invoke.cont2134
  %m_ownsMemory.i.i4055 = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %hostBodyBuf2137, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i4055, align 8
  %m_data.i.i4056 = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %hostBodyBuf2137, i64 0, i32 5
  store ptr null, ptr %m_data.i.i4056, align 8
  %m_size.i.i4057 = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %hostBodyBuf2137, i64 0, i32 2
  store i32 0, ptr %m_size.i.i4057, align 4
  %m_capacity.i.i4058 = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %hostBodyBuf2137, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i4058, align 8
  invoke void @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %bodyBuf, ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf2137, i1 noundef zeroext true)
          to label %invoke.cont2142 unwind label %lpad2139

invoke.cont2142:                                  ; preds = %invoke.cont2138
  %m_ownsMemory.i.i4059 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %concaveHasSeparatingNormalsCPU2141, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i4059, align 8
  %m_data.i.i4060 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %concaveHasSeparatingNormalsCPU2141, i64 0, i32 5
  store ptr null, ptr %m_data.i.i4060, align 8
  %m_size.i.i4061 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %concaveHasSeparatingNormalsCPU2141, i64 0, i32 2
  store i32 0, ptr %m_size.i.i4061, align 4
  %m_capacity.i.i4062 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %concaveHasSeparatingNormalsCPU2141, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i4062, align 8
  invoke void @_ZNK13b3OpenCLArrayIiE10copyToHostER20b3AlignedObjectArrayIiEb(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveHasSeparatingNormals, ptr noundef nonnull align 8 dereferenceable(25) %concaveHasSeparatingNormalsCPU2141, i1 noundef zeroext true)
          to label %invoke.cont2147 unwind label %lpad2144

invoke.cont2147:                                  ; preds = %invoke.cont2142
  %m_ownsMemory.i.i4063 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %concaveSepNormalsHost2146, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i4063, align 8
  %m_data.i.i4064 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %concaveSepNormalsHost2146, i64 0, i32 5
  store ptr null, ptr %m_data.i.i4064, align 8
  %m_size.i.i4065 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %concaveSepNormalsHost2146, i64 0, i32 2
  store i32 0, ptr %m_size.i.i4065, align 4
  %m_capacity.i.i4066 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %concaveSepNormalsHost2146, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i4066, align 8
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %m_concaveSepNormals, ptr noundef nonnull align 8 dereferenceable(25) %concaveSepNormalsHost2146, i1 noundef zeroext true)
          to label %invoke.cont2152 unwind label %lpad2149

invoke.cont2152:                                  ; preds = %invoke.cont2147
  %m_ownsMemory.i.i4067 = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %hostContacts2151, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i4067, align 8
  %m_data.i.i4068 = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %hostContacts2151, i64 0, i32 5
  store ptr null, ptr %m_data.i.i4068, align 8
  %m_size.i.i4069 = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %hostContacts2151, i64 0, i32 2
  store i32 0, ptr %m_size.i.i4069, align 4
  %m_capacity.i.i4070 = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %hostContacts2151, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i4070, align 8
  %1779 = load i32, ptr %nContacts, align 4
  %tobool2153.not = icmp eq i32 %1779, 0
  br i1 %tobool2153.not, label %if.end2157, label %if.then2154

if.then2154:                                      ; preds = %invoke.cont2152
  invoke void @_ZNK13b3OpenCLArrayI10b3Contact4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %contactOut, ptr noundef nonnull align 8 dereferenceable(25) %hostContacts2151, i1 noundef zeroext true)
          to label %if.then2154.if.end2157_crit_edge unwind label %lpad2155

if.then2154.if.end2157_crit_edge:                 ; preds = %if.then2154
  %.pre6225 = load i32, ptr %m_size.i.i4069, align 4
  br label %if.end2157

lpad2135:                                         ; preds = %invoke.cont2134
  %1780 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup2201

lpad2139:                                         ; preds = %invoke.cont2138
  %1781 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup2200

lpad2144:                                         ; preds = %invoke.cont2142
  %1782 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup2199

lpad2149:                                         ; preds = %invoke.cont2147
  %1783 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup2198

lpad2155:                                         ; preds = %if.then3.i.i5846, %.noexc5862, %_ZNK20b3AlignedObjectArrayI10b3Contact4E4copyEiiPS0_.exit18.i5858, %_ZN20b3AlignedObjectArrayI10b3Contact4E8allocateEi.exit.i5831, %if.then2154
  %1784 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup2197

if.end2157:                                       ; preds = %if.then2154.if.end2157_crit_edge, %invoke.cont2152
  %1785 = phi i32 [ %.pre6225, %if.then2154.if.end2157_crit_edge ], [ 0, %invoke.cont2152 ]
  %1786 = load i32, ptr %newContactCapacity, align 4
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(112) %ref.tmp2158.sroa.0, i8 0, i64 112, i1 false)
  %cmp4.i4072 = icmp slt i32 %1785, %1786
  br i1 %cmp4.i4072, label %for.body9.lr.ph.i4073, label %invoke.cont2164

for.body9.lr.ph.i4073:                            ; preds = %if.end2157
  %1787 = load i32, ptr %m_capacity.i.i4070, align 8
  %cmp.i5827 = icmp slt i32 %1787, %1786
  br i1 %cmp.i5827, label %if.then.i5829, label %for.body9.lr.ph.i4073..noexc4081_crit_edge

for.body9.lr.ph.i4073..noexc4081_crit_edge:       ; preds = %for.body9.lr.ph.i4073
  %.pre6226 = load ptr, ptr %m_data.i.i4068, align 8
  br label %.noexc4081

if.then.i5829:                                    ; preds = %for.body9.lr.ph.i4073
  %tobool.not.i.i5830 = icmp eq i32 %1786, 0
  br i1 %tobool.not.i.i5830, label %_ZNK20b3AlignedObjectArrayI10b3Contact4E4copyEiiPS0_.exit18.i5858, label %_ZN20b3AlignedObjectArrayI10b3Contact4E8allocateEi.exit.i5831

_ZN20b3AlignedObjectArrayI10b3Contact4E8allocateEi.exit.i5831: ; preds = %if.then.i5829
  %conv.i.i.i5832 = sext i32 %1786 to i64
  %mul.i.i.i5833 = mul nsw i64 %conv.i.i.i5832, 112
  %call.i.i.i5861 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i5833, i32 noundef 16)
          to label %call.i.i.i.noexc5860 unwind label %lpad2155

call.i.i.i.noexc5860:                             ; preds = %_ZN20b3AlignedObjectArrayI10b3Contact4E8allocateEi.exit.i5831
  %cmp3.i5834 = icmp eq ptr %call.i.i.i5861, null
  br i1 %cmp3.i5834, label %_ZNK20b3AlignedObjectArrayI10b3Contact4E4copyEiiPS0_.exit18.i5858, label %if.then.split.i5835

if.then.split.i5835:                              ; preds = %call.i.i.i.noexc5860
  %1788 = load i32, ptr %m_size.i.i4069, align 4
  %cmp4.i.i5837 = icmp sgt i32 %1788, 0
  br i1 %cmp4.i.i5837, label %for.body.lr.ph.i.i5849, label %if.end.i5838

for.body.lr.ph.i.i5849:                           ; preds = %if.then.split.i5835
  %wide.trip.count.i.i5851 = zext nneg i32 %1788 to i64
  %1789 = load ptr, ptr %m_data.i.i4068, align 8
  br label %for.body.i.i5852

for.body.i.i5852:                                 ; preds = %for.body.i.i5852, %for.body.lr.ph.i.i5849
  %indvars.iv.i.i5853 = phi i64 [ 0, %for.body.lr.ph.i.i5849 ], [ %indvars.iv.next.i.i5856, %for.body.i.i5852 ]
  %arrayidx.i.i5854 = getelementptr inbounds %struct.b3Contact4, ptr %call.i.i.i5861, i64 %indvars.iv.i.i5853
  %arrayidx3.i.i5855 = getelementptr inbounds %struct.b3Contact4, ptr %1789, i64 %indvars.iv.i.i5853
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(112) %arrayidx.i.i5854, ptr noundef nonnull align 16 dereferenceable(112) %arrayidx3.i.i5855, i64 112, i1 false)
  %indvars.iv.next.i.i5856 = add nuw nsw i64 %indvars.iv.i.i5853, 1
  %exitcond.not.i.i5857 = icmp eq i64 %indvars.iv.next.i.i5856, %wide.trip.count.i.i5851
  br i1 %exitcond.not.i.i5857, label %if.then.i22.i5843, label %for.body.i.i5852, !llvm.loop !65

_ZNK20b3AlignedObjectArrayI10b3Contact4E4copyEiiPS0_.exit18.i5858: ; preds = %call.i.i.i.noexc5860, %if.then.i5829
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc5862 unwind label %lpad2155

.noexc5862:                                       ; preds = %_ZNK20b3AlignedObjectArrayI10b3Contact4E4copyEiiPS0_.exit18.i5858
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc5863 unwind label %lpad2155

.noexc5863:                                       ; preds = %.noexc5862
  store i32 0, ptr %m_size.i.i4069, align 4
  br label %if.end.i5838

if.end.i5838:                                     ; preds = %.noexc5863, %if.then.split.i5835
  %retval.0.i25.i5839.ph = phi ptr [ %call.i.i.i5861, %if.then.split.i5835 ], [ null, %.noexc5863 ]
  %_Count.addr.0.i5840.ph = phi i32 [ %1786, %if.then.split.i5835 ], [ 0, %.noexc5863 ]
  %.pr6098 = load ptr, ptr %m_data.i.i4068, align 8
  %tobool.not.i21.i5842 = icmp eq ptr %.pr6098, null
  br i1 %tobool.not.i21.i5842, label %_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv.exit.i5847, label %if.then.i22.i5843

if.then.i22.i5843:                                ; preds = %for.body.i.i5852, %if.end.i5838
  %_Count.addr.0.i58406104 = phi i32 [ %_Count.addr.0.i5840.ph, %if.end.i5838 ], [ %1786, %for.body.i.i5852 ]
  %retval.0.i25.i58396102 = phi ptr [ %retval.0.i25.i5839.ph, %if.end.i5838 ], [ %call.i.i.i5861, %for.body.i.i5852 ]
  %1790 = phi ptr [ %.pr6098, %if.end.i5838 ], [ %1789, %for.body.i.i5852 ]
  %1791 = load i8, ptr %m_ownsMemory.i.i4067, align 8
  %1792 = and i8 %1791, 1
  %tobool2.not.i.i5845 = icmp eq i8 %1792, 0
  br i1 %tobool2.not.i.i5845, label %_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv.exit.i5847, label %if.then3.i.i5846

if.then3.i.i5846:                                 ; preds = %if.then.i22.i5843
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1790)
          to label %_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv.exit.i5847 unwind label %lpad2155

_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv.exit.i5847: ; preds = %if.then3.i.i5846, %if.then.i22.i5843, %if.end.i5838
  %_Count.addr.0.i58406105 = phi i32 [ %_Count.addr.0.i58406104, %if.then.i22.i5843 ], [ %_Count.addr.0.i5840.ph, %if.end.i5838 ], [ %_Count.addr.0.i58406104, %if.then3.i.i5846 ]
  %retval.0.i25.i58396103 = phi ptr [ %retval.0.i25.i58396102, %if.then.i22.i5843 ], [ %retval.0.i25.i5839.ph, %if.end.i5838 ], [ %retval.0.i25.i58396102, %if.then3.i.i5846 ]
  store i8 1, ptr %m_ownsMemory.i.i4067, align 8
  store ptr %retval.0.i25.i58396103, ptr %m_data.i.i4068, align 8
  store i32 %_Count.addr.0.i58406105, ptr %m_capacity.i.i4070, align 8
  br label %.noexc4081

.noexc4081:                                       ; preds = %for.body9.lr.ph.i4073..noexc4081_crit_edge, %_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv.exit.i5847
  %1793 = phi ptr [ %.pre6226, %for.body9.lr.ph.i4073..noexc4081_crit_edge ], [ %retval.0.i25.i58396103, %_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv.exit.i5847 ]
  %1794 = sext i32 %1785 to i64
  %wide.trip.count.i4075 = sext i32 %1786 to i64
  br label %for.body9.i4076

for.body9.i4076:                                  ; preds = %for.body9.i4076, %.noexc4081
  %indvars.iv.i4077 = phi i64 [ %1794, %.noexc4081 ], [ %indvars.iv.next.i4079, %for.body9.i4076 ]
  %arrayidx12.i4078 = getelementptr inbounds %struct.b3Contact4, ptr %1793, i64 %indvars.iv.i4077
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(112) %arrayidx12.i4078, ptr noundef nonnull align 16 dereferenceable(112) %ref.tmp2158.sroa.0, i64 112, i1 false)
  %indvars.iv.next.i4079 = add nsw i64 %indvars.iv.i4077, 1
  %exitcond.not.i4080 = icmp eq i64 %indvars.iv.next.i4079, %wide.trip.count.i4075
  br i1 %exitcond.not.i4080, label %invoke.cont2164, label %for.body9.i4076, !llvm.loop !66

invoke.cont2164:                                  ; preds = %for.body9.i4076, %if.end2157
  store i32 %1786, ptr %m_size.i.i4069, align 4
  %m_ownsMemory.i.i4083 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %clippingFacesOutCPU2160, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i4083, align 8
  %m_data.i.i4084 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %clippingFacesOutCPU2160, i64 0, i32 5
  store ptr null, ptr %m_data.i.i4084, align 8
  %m_size.i.i4085 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %clippingFacesOutCPU2160, i64 0, i32 2
  store i32 0, ptr %m_size.i.i4085, align 4
  %m_capacity.i.i4086 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %clippingFacesOutCPU2160, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i4086, align 8
  %m_ownsMemory.i.i4087 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldVertsB2CPU2162, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i.i4087, align 8
  %m_data.i.i4088 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldVertsB2CPU2162, i64 0, i32 5
  store ptr null, ptr %m_data.i.i4088, align 8
  %m_size.i.i4089 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldVertsB2CPU2162, i64 0, i32 2
  store i32 0, ptr %m_size.i.i4089, align 4
  %m_capacity.i.i4090 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %worldVertsB2CPU2162, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i4090, align 8
  invoke void @_ZNK13b3OpenCLArrayI6b3Int4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %clippingFacesOutGPU, ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU2160, i1 noundef zeroext true)
          to label %invoke.cont2166 unwind label %lpad2165

invoke.cont2166:                                  ; preds = %invoke.cont2164
  invoke void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %worldVertsB2GPU, ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB2CPU2162, i1 noundef zeroext true)
          to label %for.cond2169.preheader unwind label %lpad2165

for.cond2169.preheader:                           ; preds = %invoke.cont2166
  %1795 = load i32, ptr %numConcavePairs, align 4
  %cmp21706158 = icmp sgt i32 %1795, 0
  br i1 %cmp21706158, label %for.body2171, label %for.end2189

for.body2171:                                     ; preds = %for.cond2169.preheader, %for.body2171
  %1796 = phi i32 [ %1806, %for.body2171 ], [ %1795, %for.cond2169.preheader ]
  %i2168.06159 = phi i32 [ %inc2188, %for.body2171 ], [ 0, %for.cond2169.preheader ]
  %1797 = load ptr, ptr %m_data.i.i4052, align 8
  %1798 = load ptr, ptr %m_data.i.i4056, align 8
  %1799 = load ptr, ptr %m_data.i.i4064, align 8
  %1800 = load ptr, ptr %m_data.i.i4060, align 8
  %1801 = load ptr, ptr %m_data.i.i4068, align 8
  %1802 = load ptr, ptr %m_data.i.i4084, align 8
  %1803 = load ptr, ptr %m_data.i.i4088, align 8
  %1804 = load i32, ptr %vertexFaceCapacity, align 4
  %1805 = load i32, ptr %newContactCapacity, align 4
  call void @_Z27b3NewContactReductionKernelP6b3Int4PK15b3RigidBodyDataPK9b3Vector3PKiP14b3Contact4DataS0_PS4_PViiiii(ptr noundef nonnull %1797, ptr noundef nonnull %1798, ptr noundef nonnull %1799, ptr noundef nonnull %1800, ptr noundef nonnull %1801, ptr noundef nonnull %1802, ptr noundef nonnull %1803, ptr noundef nonnull %nGlobalContactsOut2132, i32 noundef %1804, i32 noundef %1805, i32 noundef %1796, i32 noundef %i2168.06159)
  %inc2188 = add nuw nsw i32 %i2168.06159, 1
  %1806 = load i32, ptr %numConcavePairs, align 4
  %cmp2170 = icmp slt i32 %inc2188, %1806
  br i1 %cmp2170, label %for.body2171, label %for.end2189, !llvm.loop !73

lpad2165:                                         ; preds = %if.then3.i.i5886, %.noexc5902, %_ZNK20b3AlignedObjectArrayI10b3Contact4E4copyEiiPS0_.exit18.i5898, %_ZN20b3AlignedObjectArrayI10b3Contact4E8allocateEi.exit.i5871, %call.i.i.noexc4136, %if.then.i.i4126, %if.end7.i.i4132, %call.i4101.noexc, %for.end2189, %invoke.cont2166, %invoke.cont2164
  %1807 = landingpad { ptr, i32 }
          cleanup
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %worldVertsB2CPU2162) #26
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %clippingFacesOutCPU2160) #26
  br label %ehcleanup2197

for.end2189:                                      ; preds = %for.body2171, %for.cond2169.preheader
  %1808 = load volatile i32, ptr %nGlobalContactsOut2132, align 4
  store i32 %1808, ptr %nContacts, align 4
  %1809 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %1810 = load ptr, ptr %m_commandQueue.i, align 8
  %1811 = load ptr, ptr %m_clBuffer.i, align 8
  %call.i41014104 = invoke i32 %1809(ptr noundef %1810, ptr noundef %1811, i32 noundef 0, i64 noundef 0, i64 noundef 4, ptr noundef nonnull %nContacts, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call.i4101.noexc unwind label %lpad2165

call.i4101.noexc:                                 ; preds = %for.end2189
  %1812 = load ptr, ptr @__clewFinish, align 8
  %1813 = load ptr, ptr %m_commandQueue.i, align 8
  %call6.i41024105 = invoke i32 %1812(ptr noundef %1813)
          to label %invoke.cont2191 unwind label %lpad2165

invoke.cont2191:                                  ; preds = %call.i4101.noexc
  %1814 = load i32, ptr %nContacts, align 4
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(112) %ref.tmp2192.sroa.0, i8 0, i64 112, i1 false)
  %1815 = load i32, ptr %m_size.i.i4069, align 4
  %cmp4.i4108 = icmp slt i32 %1815, %1814
  br i1 %cmp4.i4108, label %for.body9.lr.ph.i4109, label %invoke.cont2191.invoke.cont2193_crit_edge

invoke.cont2191.invoke.cont2193_crit_edge:        ; preds = %invoke.cont2191
  %.pre6246 = sext i32 %1814 to i64
  br label %invoke.cont2193

for.body9.lr.ph.i4109:                            ; preds = %invoke.cont2191
  %1816 = load i32, ptr %m_capacity.i.i4070, align 8
  %cmp.i5867 = icmp slt i32 %1816, %1814
  br i1 %cmp.i5867, label %if.then.i5869, label %for.body9.lr.ph.i4109..noexc4117_crit_edge

for.body9.lr.ph.i4109..noexc4117_crit_edge:       ; preds = %for.body9.lr.ph.i4109
  %.pre6227 = load ptr, ptr %m_data.i.i4068, align 8
  br label %.noexc4117

if.then.i5869:                                    ; preds = %for.body9.lr.ph.i4109
  %tobool.not.i.i5870 = icmp eq i32 %1814, 0
  br i1 %tobool.not.i.i5870, label %_ZNK20b3AlignedObjectArrayI10b3Contact4E4copyEiiPS0_.exit18.i5898, label %_ZN20b3AlignedObjectArrayI10b3Contact4E8allocateEi.exit.i5871

_ZN20b3AlignedObjectArrayI10b3Contact4E8allocateEi.exit.i5871: ; preds = %if.then.i5869
  %conv.i.i.i5872 = sext i32 %1814 to i64
  %mul.i.i.i5873 = mul nsw i64 %conv.i.i.i5872, 112
  %call.i.i.i5901 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i5873, i32 noundef 16)
          to label %call.i.i.i.noexc5900 unwind label %lpad2165

call.i.i.i.noexc5900:                             ; preds = %_ZN20b3AlignedObjectArrayI10b3Contact4E8allocateEi.exit.i5871
  %cmp3.i5874 = icmp eq ptr %call.i.i.i5901, null
  br i1 %cmp3.i5874, label %_ZNK20b3AlignedObjectArrayI10b3Contact4E4copyEiiPS0_.exit18.i5898, label %if.then.split.i5875

if.then.split.i5875:                              ; preds = %call.i.i.i.noexc5900
  %1817 = load i32, ptr %m_size.i.i4069, align 4
  %cmp4.i.i5877 = icmp sgt i32 %1817, 0
  br i1 %cmp4.i.i5877, label %for.body.lr.ph.i.i5889, label %if.end.i5878

for.body.lr.ph.i.i5889:                           ; preds = %if.then.split.i5875
  %wide.trip.count.i.i5891 = zext nneg i32 %1817 to i64
  %1818 = load ptr, ptr %m_data.i.i4068, align 8
  br label %for.body.i.i5892

for.body.i.i5892:                                 ; preds = %for.body.i.i5892, %for.body.lr.ph.i.i5889
  %indvars.iv.i.i5893 = phi i64 [ 0, %for.body.lr.ph.i.i5889 ], [ %indvars.iv.next.i.i5896, %for.body.i.i5892 ]
  %arrayidx.i.i5894 = getelementptr inbounds %struct.b3Contact4, ptr %call.i.i.i5901, i64 %indvars.iv.i.i5893
  %arrayidx3.i.i5895 = getelementptr inbounds %struct.b3Contact4, ptr %1818, i64 %indvars.iv.i.i5893
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(112) %arrayidx.i.i5894, ptr noundef nonnull align 16 dereferenceable(112) %arrayidx3.i.i5895, i64 112, i1 false)
  %indvars.iv.next.i.i5896 = add nuw nsw i64 %indvars.iv.i.i5893, 1
  %exitcond.not.i.i5897 = icmp eq i64 %indvars.iv.next.i.i5896, %wide.trip.count.i.i5891
  br i1 %exitcond.not.i.i5897, label %if.then.i22.i5883, label %for.body.i.i5892, !llvm.loop !65

_ZNK20b3AlignedObjectArrayI10b3Contact4E4copyEiiPS0_.exit18.i5898: ; preds = %call.i.i.i.noexc5900, %if.then.i5869
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc5902 unwind label %lpad2165

.noexc5902:                                       ; preds = %_ZNK20b3AlignedObjectArrayI10b3Contact4E4copyEiiPS0_.exit18.i5898
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc5903 unwind label %lpad2165

.noexc5903:                                       ; preds = %.noexc5902
  store i32 0, ptr %m_size.i.i4069, align 4
  br label %if.end.i5878

if.end.i5878:                                     ; preds = %.noexc5903, %if.then.split.i5875
  %retval.0.i25.i5879.ph = phi ptr [ %call.i.i.i5901, %if.then.split.i5875 ], [ null, %.noexc5903 ]
  %_Count.addr.0.i5880.ph = phi i32 [ %1814, %if.then.split.i5875 ], [ 0, %.noexc5903 ]
  %.pr6106 = load ptr, ptr %m_data.i.i4068, align 8
  %tobool.not.i21.i5882 = icmp eq ptr %.pr6106, null
  br i1 %tobool.not.i21.i5882, label %_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv.exit.i5887, label %if.then.i22.i5883

if.then.i22.i5883:                                ; preds = %for.body.i.i5892, %if.end.i5878
  %_Count.addr.0.i58806112 = phi i32 [ %_Count.addr.0.i5880.ph, %if.end.i5878 ], [ %1814, %for.body.i.i5892 ]
  %retval.0.i25.i58796110 = phi ptr [ %retval.0.i25.i5879.ph, %if.end.i5878 ], [ %call.i.i.i5901, %for.body.i.i5892 ]
  %1819 = phi ptr [ %.pr6106, %if.end.i5878 ], [ %1818, %for.body.i.i5892 ]
  %1820 = load i8, ptr %m_ownsMemory.i.i4067, align 8
  %1821 = and i8 %1820, 1
  %tobool2.not.i.i5885 = icmp eq i8 %1821, 0
  br i1 %tobool2.not.i.i5885, label %_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv.exit.i5887, label %if.then3.i.i5886

if.then3.i.i5886:                                 ; preds = %if.then.i22.i5883
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1819)
          to label %_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv.exit.i5887 unwind label %lpad2165

_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv.exit.i5887: ; preds = %if.then3.i.i5886, %if.then.i22.i5883, %if.end.i5878
  %_Count.addr.0.i58806113 = phi i32 [ %_Count.addr.0.i58806112, %if.then.i22.i5883 ], [ %_Count.addr.0.i5880.ph, %if.end.i5878 ], [ %_Count.addr.0.i58806112, %if.then3.i.i5886 ]
  %retval.0.i25.i58796111 = phi ptr [ %retval.0.i25.i58796110, %if.then.i22.i5883 ], [ %retval.0.i25.i5879.ph, %if.end.i5878 ], [ %retval.0.i25.i58796110, %if.then3.i.i5886 ]
  store i8 1, ptr %m_ownsMemory.i.i4067, align 8
  store ptr %retval.0.i25.i58796111, ptr %m_data.i.i4068, align 8
  store i32 %_Count.addr.0.i58806113, ptr %m_capacity.i.i4070, align 8
  br label %.noexc4117

.noexc4117:                                       ; preds = %for.body9.lr.ph.i4109..noexc4117_crit_edge, %_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv.exit.i5887
  %1822 = phi ptr [ %.pre6227, %for.body9.lr.ph.i4109..noexc4117_crit_edge ], [ %retval.0.i25.i58796111, %_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv.exit.i5887 ]
  %1823 = sext i32 %1815 to i64
  %wide.trip.count.i4111 = sext i32 %1814 to i64
  br label %for.body9.i4112

for.body9.i4112:                                  ; preds = %for.body9.i4112, %.noexc4117
  %indvars.iv.i4113 = phi i64 [ %1823, %.noexc4117 ], [ %indvars.iv.next.i4115, %for.body9.i4112 ]
  %arrayidx12.i4114 = getelementptr inbounds %struct.b3Contact4, ptr %1822, i64 %indvars.iv.i4113
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(112) %arrayidx12.i4114, ptr noundef nonnull align 16 dereferenceable(112) %ref.tmp2192.sroa.0, i64 112, i1 false)
  %indvars.iv.next.i4115 = add nsw i64 %indvars.iv.i4113, 1
  %exitcond.not.i4116 = icmp eq i64 %indvars.iv.next.i4115, %wide.trip.count.i4111
  br i1 %exitcond.not.i4116, label %invoke.cont2193, label %for.body9.i4112, !llvm.loop !66

invoke.cont2193:                                  ; preds = %for.body9.i4112, %invoke.cont2191.invoke.cont2193_crit_edge
  %conv.i4120.pre-phi = phi i64 [ %.pre6246, %invoke.cont2191.invoke.cont2193_crit_edge ], [ %wide.trip.count.i4111, %for.body9.i4112 ]
  store i32 %1814, ptr %m_size.i.i4069, align 4
  %1824 = load i64, ptr %m_size.i.i, align 8
  %cmp3.i.i4122 = icmp ult i64 %1824, %conv.i4120.pre-phi
  br i1 %cmp3.i.i4122, label %if.end7.i.i4132, label %_ZN13b3OpenCLArrayI10b3Contact4E6resizeEmb.exit.i4123

if.end7.i.i4132:                                  ; preds = %invoke.cont2193
  %call5.i.i4135 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI10b3Contact4E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %contactOut, i64 noundef %conv.i4120.pre-phi, i1 noundef zeroext false)
          to label %call5.i.i.noexc4134 unwind label %lpad2165

call5.i.i.noexc4134:                              ; preds = %if.end7.i.i4132
  %spec.select.i.i4133 = select i1 %call5.i.i4135, i64 %conv.i4120.pre-phi, i64 0
  br label %_ZN13b3OpenCLArrayI10b3Contact4E6resizeEmb.exit.i4123

_ZN13b3OpenCLArrayI10b3Contact4E6resizeEmb.exit.i4123: ; preds = %call5.i.i.noexc4134, %invoke.cont2193
  %storemerge.i.i4124 = phi i64 [ %conv.i4120.pre-phi, %invoke.cont2193 ], [ %spec.select.i.i4133, %call5.i.i.noexc4134 ]
  store i64 %storemerge.i.i4124, ptr %m_size.i.i, align 8
  %tobool3.not.i4125 = icmp eq i32 %1814, 0
  br i1 %tobool3.not.i4125, label %invoke.cont2194, label %if.then.i.i4126

if.then.i.i4126:                                  ; preds = %_ZN13b3OpenCLArrayI10b3Contact4E6resizeEmb.exit.i4123
  %1825 = load ptr, ptr %m_data.i.i4068, align 8
  %mul.i.i4128 = mul nsw i64 %conv.i4120.pre-phi, 112
  %1826 = load ptr, ptr @__clewEnqueueWriteBuffer, align 8
  %m_commandQueue.i.i4129 = getelementptr inbounds %class.b3OpenCLArray.80, ptr %contactOut, i64 0, i32 5
  %1827 = load ptr, ptr %m_commandQueue.i.i4129, align 8
  %1828 = load ptr, ptr %m_clBuffer.i545, align 8
  %call.i.i4137 = invoke i32 %1826(ptr noundef %1827, ptr noundef %1828, i32 noundef 0, i64 noundef 0, i64 noundef %mul.i.i4128, ptr noundef %1825, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call.i.i.noexc4136 unwind label %lpad2165

call.i.i.noexc4136:                               ; preds = %if.then.i.i4126
  %1829 = load ptr, ptr @__clewFinish, align 8
  %1830 = load ptr, ptr %m_commandQueue.i.i4129, align 8
  %call6.i.i4139 = invoke i32 %1829(ptr noundef %1830)
          to label %invoke.cont2194 unwind label %lpad2165

invoke.cont2194:                                  ; preds = %_ZN13b3OpenCLArrayI10b3Contact4E6resizeEmb.exit.i4123, %call.i.i.noexc4136
  %1831 = load ptr, ptr %m_data.i.i4088, align 8
  %tobool.not.i.i.i4142 = icmp eq ptr %1831, null
  br i1 %tobool.not.i.i.i4142, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit4151, label %if.then.i.i.i4143

if.then.i.i.i4143:                                ; preds = %invoke.cont2194
  %1832 = load i8, ptr %m_ownsMemory.i.i4087, align 8
  %1833 = and i8 %1832, 1
  %tobool2.not.i.i.i4145 = icmp eq i8 %1833, 0
  br i1 %tobool2.not.i.i.i4145, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit4151, label %if.then3.i.i.i4146

if.then3.i.i.i4146:                               ; preds = %if.then.i.i.i4143
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1831)
          to label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit4151 unwind label %terminate.lpad.i4147

terminate.lpad.i4147:                             ; preds = %if.then3.i.i.i4146
  %1834 = landingpad { ptr, i32 }
          catch ptr null
  %1835 = extractvalue { ptr, i32 } %1834, 0
  call void @__clang_call_terminate(ptr %1835) #27
  unreachable

_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit4151: ; preds = %invoke.cont2194, %if.then.i.i.i4143, %if.then3.i.i.i4146
  store i8 1, ptr %m_ownsMemory.i.i4087, align 8
  store ptr null, ptr %m_data.i.i4088, align 8
  store i32 0, ptr %m_size.i.i4089, align 4
  store i32 0, ptr %m_capacity.i.i4090, align 8
  %1836 = load ptr, ptr %m_data.i.i4084, align 8
  %tobool.not.i.i.i4153 = icmp eq ptr %1836, null
  br i1 %tobool.not.i.i.i4153, label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit4162, label %if.then.i.i.i4154

if.then.i.i.i4154:                                ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit4151
  %1837 = load i8, ptr %m_ownsMemory.i.i4083, align 8
  %1838 = and i8 %1837, 1
  %tobool2.not.i.i.i4156 = icmp eq i8 %1838, 0
  br i1 %tobool2.not.i.i.i4156, label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit4162, label %if.then3.i.i.i4157

if.then3.i.i.i4157:                               ; preds = %if.then.i.i.i4154
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1836)
          to label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit4162 unwind label %terminate.lpad.i4158

terminate.lpad.i4158:                             ; preds = %if.then3.i.i.i4157
  %1839 = landingpad { ptr, i32 }
          catch ptr null
  %1840 = extractvalue { ptr, i32 } %1839, 0
  call void @__clang_call_terminate(ptr %1840) #27
  unreachable

_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit4162:  ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit4151, %if.then.i.i.i4154, %if.then3.i.i.i4157
  store i8 1, ptr %m_ownsMemory.i.i4083, align 8
  store ptr null, ptr %m_data.i.i4084, align 8
  store i32 0, ptr %m_size.i.i4085, align 4
  store i32 0, ptr %m_capacity.i.i4086, align 8
  %1841 = load ptr, ptr %m_data.i.i4068, align 8
  %tobool.not.i.i.i4164 = icmp eq ptr %1841, null
  br i1 %tobool.not.i.i.i4164, label %_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev.exit4173, label %if.then.i.i.i4165

if.then.i.i.i4165:                                ; preds = %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit4162
  %1842 = load i8, ptr %m_ownsMemory.i.i4067, align 8
  %1843 = and i8 %1842, 1
  %tobool2.not.i.i.i4167 = icmp eq i8 %1843, 0
  br i1 %tobool2.not.i.i.i4167, label %_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev.exit4173, label %if.then3.i.i.i4168

if.then3.i.i.i4168:                               ; preds = %if.then.i.i.i4165
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1841)
          to label %_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev.exit4173 unwind label %terminate.lpad.i4169

terminate.lpad.i4169:                             ; preds = %if.then3.i.i.i4168
  %1844 = landingpad { ptr, i32 }
          catch ptr null
  %1845 = extractvalue { ptr, i32 } %1844, 0
  call void @__clang_call_terminate(ptr %1845) #27
  unreachable

_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev.exit4173: ; preds = %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit4162, %if.then.i.i.i4165, %if.then3.i.i.i4168
  store i8 1, ptr %m_ownsMemory.i.i4067, align 8
  store ptr null, ptr %m_data.i.i4068, align 8
  store i32 0, ptr %m_size.i.i4069, align 4
  store i32 0, ptr %m_capacity.i.i4070, align 8
  %1846 = load ptr, ptr %m_data.i.i4064, align 8
  %tobool.not.i.i.i4175 = icmp eq ptr %1846, null
  br i1 %tobool.not.i.i.i4175, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit4184, label %if.then.i.i.i4176

if.then.i.i.i4176:                                ; preds = %_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev.exit4173
  %1847 = load i8, ptr %m_ownsMemory.i.i4063, align 8
  %1848 = and i8 %1847, 1
  %tobool2.not.i.i.i4178 = icmp eq i8 %1848, 0
  br i1 %tobool2.not.i.i.i4178, label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit4184, label %if.then3.i.i.i4179

if.then3.i.i.i4179:                               ; preds = %if.then.i.i.i4176
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1846)
          to label %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit4184 unwind label %terminate.lpad.i4180

terminate.lpad.i4180:                             ; preds = %if.then3.i.i.i4179
  %1849 = landingpad { ptr, i32 }
          catch ptr null
  %1850 = extractvalue { ptr, i32 } %1849, 0
  call void @__clang_call_terminate(ptr %1850) #27
  unreachable

_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit4184: ; preds = %_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev.exit4173, %if.then.i.i.i4176, %if.then3.i.i.i4179
  store i8 1, ptr %m_ownsMemory.i.i4063, align 8
  store ptr null, ptr %m_data.i.i4064, align 8
  store i32 0, ptr %m_size.i.i4065, align 4
  store i32 0, ptr %m_capacity.i.i4066, align 8
  %1851 = load ptr, ptr %m_data.i.i4060, align 8
  %tobool.not.i.i.i4186 = icmp eq ptr %1851, null
  br i1 %tobool.not.i.i.i4186, label %_ZN20b3AlignedObjectArrayIiED2Ev.exit4195, label %if.then.i.i.i4187

if.then.i.i.i4187:                                ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit4184
  %1852 = load i8, ptr %m_ownsMemory.i.i4059, align 8
  %1853 = and i8 %1852, 1
  %tobool2.not.i.i.i4189 = icmp eq i8 %1853, 0
  br i1 %tobool2.not.i.i.i4189, label %_ZN20b3AlignedObjectArrayIiED2Ev.exit4195, label %if.then3.i.i.i4190

if.then3.i.i.i4190:                               ; preds = %if.then.i.i.i4187
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1851)
          to label %_ZN20b3AlignedObjectArrayIiED2Ev.exit4195 unwind label %terminate.lpad.i4191

terminate.lpad.i4191:                             ; preds = %if.then3.i.i.i4190
  %1854 = landingpad { ptr, i32 }
          catch ptr null
  %1855 = extractvalue { ptr, i32 } %1854, 0
  call void @__clang_call_terminate(ptr %1855) #27
  unreachable

_ZN20b3AlignedObjectArrayIiED2Ev.exit4195:        ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev.exit4184, %if.then.i.i.i4187, %if.then3.i.i.i4190
  store i8 1, ptr %m_ownsMemory.i.i4059, align 8
  store ptr null, ptr %m_data.i.i4060, align 8
  store i32 0, ptr %m_size.i.i4061, align 4
  store i32 0, ptr %m_capacity.i.i4062, align 8
  %1856 = load ptr, ptr %m_data.i.i4056, align 8
  %tobool.not.i.i.i4197 = icmp eq ptr %1856, null
  br i1 %tobool.not.i.i.i4197, label %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev.exit4206, label %if.then.i.i.i4198

if.then.i.i.i4198:                                ; preds = %_ZN20b3AlignedObjectArrayIiED2Ev.exit4195
  %1857 = load i8, ptr %m_ownsMemory.i.i4055, align 8
  %1858 = and i8 %1857, 1
  %tobool2.not.i.i.i4200 = icmp eq i8 %1858, 0
  br i1 %tobool2.not.i.i.i4200, label %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev.exit4206, label %if.then3.i.i.i4201

if.then3.i.i.i4201:                               ; preds = %if.then.i.i.i4198
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1856)
          to label %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev.exit4206 unwind label %terminate.lpad.i4202

terminate.lpad.i4202:                             ; preds = %if.then3.i.i.i4201
  %1859 = landingpad { ptr, i32 }
          catch ptr null
  %1860 = extractvalue { ptr, i32 } %1859, 0
  call void @__clang_call_terminate(ptr %1860) #27
  unreachable

_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev.exit4206: ; preds = %_ZN20b3AlignedObjectArrayIiED2Ev.exit4195, %if.then.i.i.i4198, %if.then3.i.i.i4201
  store i8 1, ptr %m_ownsMemory.i.i4055, align 8
  store ptr null, ptr %m_data.i.i4056, align 8
  store i32 0, ptr %m_size.i.i4057, align 4
  store i32 0, ptr %m_capacity.i.i4058, align 8
  %1861 = load ptr, ptr %m_data.i.i4052, align 8
  %tobool.not.i.i.i4208 = icmp eq ptr %1861, null
  br i1 %tobool.not.i.i.i4208, label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit4217, label %if.then.i.i.i4209

if.then.i.i.i4209:                                ; preds = %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev.exit4206
  %1862 = load i8, ptr %m_ownsMemory.i.i4051, align 8
  %1863 = and i8 %1862, 1
  %tobool2.not.i.i.i4211 = icmp eq i8 %1863, 0
  br i1 %tobool2.not.i.i.i4211, label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit4217, label %if.then3.i.i.i4212

if.then3.i.i.i4212:                               ; preds = %if.then.i.i.i4209
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1861)
          to label %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit4217 unwind label %terminate.lpad.i4213

terminate.lpad.i4213:                             ; preds = %if.then3.i.i.i4212
  %1864 = landingpad { ptr, i32 }
          catch ptr null
  %1865 = extractvalue { ptr, i32 } %1864, 0
  call void @__clang_call_terminate(ptr %1865) #27
  unreachable

_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit4217:  ; preds = %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev.exit4206, %if.then.i.i.i4209, %if.then3.i.i.i4212
  store i8 1, ptr %m_ownsMemory.i.i4051, align 8
  store ptr null, ptr %m_data.i.i4052, align 8
  store i32 0, ptr %m_size.i.i4053, align 4
  store i32 0, ptr %m_capacity.i.i4054, align 8
  br label %if.then2293

ehcleanup2197:                                    ; preds = %lpad2165, %lpad2155
  %.pn510.pn = phi { ptr, i32 } [ %1807, %lpad2165 ], [ %1784, %lpad2155 ]
  call void @_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostContacts2151) #26
  br label %ehcleanup2198

ehcleanup2198:                                    ; preds = %ehcleanup2197, %lpad2149
  %.pn510.pn.pn = phi { ptr, i32 } [ %.pn510.pn, %ehcleanup2197 ], [ %1783, %lpad2149 ]
  call void @_ZN20b3AlignedObjectArrayI9b3Vector3ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %concaveSepNormalsHost2146) #26
  br label %ehcleanup2199

ehcleanup2199:                                    ; preds = %ehcleanup2198, %lpad2144
  %.pn510.pn.pn.pn = phi { ptr, i32 } [ %.pn510.pn.pn, %ehcleanup2198 ], [ %1782, %lpad2144 ]
  call void @_ZN20b3AlignedObjectArrayIiED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %concaveHasSeparatingNormalsCPU2141) #26
  br label %ehcleanup2200

ehcleanup2200:                                    ; preds = %ehcleanup2199, %lpad2139
  %.pn510.pn.pn.pn.pn = phi { ptr, i32 } [ %.pn510.pn.pn.pn, %ehcleanup2199 ], [ %1781, %lpad2139 ]
  call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %hostBodyBuf2137) #26
  br label %ehcleanup2201

ehcleanup2201:                                    ; preds = %ehcleanup2200, %lpad2135
  %.pn510.pn.pn.pn.pn.pn = phi { ptr, i32 } [ %.pn510.pn.pn.pn.pn, %ehcleanup2200 ], [ %1780, %lpad2135 ]
  call void @_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %triangleConvexPairsOutHost2133) #26
  br label %ehcleanup2980

if.then2293:                                      ; preds = %_ZN13b3OpenCLArrayI10b3Contact4E6resizeEmb.exit4048, %invoke.cont1941, %_ZN20b3AlignedObjectArrayI6b3Int4ED2Ev.exit4217
  invoke void @b3EnterProfileZone(ptr noundef nonnull @.str.18)
          to label %if.else2800 unwind label %lpad58

lpad2300:                                         ; preds = %if.then2890, %if.then2802
  %1866 = landingpad { ptr, i32 }
          cleanup
  br label %ehcleanup2977

if.else2800:                                      ; preds = %if.then2293
  %1867 = load i32, ptr %nPairs.addr, align 4
  %tobool2801.not = icmp eq i32 %1867, 0
  br i1 %tobool2801.not, label %if.end2884, label %if.then2802

if.then2802:                                      ; preds = %if.else2800
  %1868 = load ptr, ptr %m_clBuffer.i530, align 8
  store ptr %1868, ptr %bInfo2803, align 16
  %m_isReadOnly.i4221 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2803, i64 0, i32 1
  store i8 1, ptr %m_isReadOnly.i4221, align 8
  %arrayinit.element2808 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2803, i64 1
  %1869 = load ptr, ptr %m_clBuffer.i531, align 8
  store ptr %1869, ptr %arrayinit.element2808, align 16
  %m_isReadOnly.i4223 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2803, i64 1, i32 1
  store i8 1, ptr %m_isReadOnly.i4223, align 8
  %arrayinit.element2812 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2803, i64 2
  %1870 = load ptr, ptr %m_clBuffer.i533, align 8
  store ptr %1870, ptr %arrayinit.element2812, align 16
  %m_isReadOnly.i4225 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2803, i64 2, i32 1
  store i8 1, ptr %m_isReadOnly.i4225, align 8
  %arrayinit.element2816 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2803, i64 3
  %1871 = load ptr, ptr %m_clBuffer.i535, align 8
  store ptr %1871, ptr %arrayinit.element2816, align 16
  %m_isReadOnly.i4227 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2803, i64 3, i32 1
  store i8 1, ptr %m_isReadOnly.i4227, align 8
  %arrayinit.element2820 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2803, i64 4
  %1872 = load ptr, ptr %m_clBuffer.i537, align 8
  store ptr %1872, ptr %arrayinit.element2820, align 16
  %m_isReadOnly.i4229 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2803, i64 4, i32 1
  store i8 1, ptr %m_isReadOnly.i4229, align 8
  %arrayinit.element2824 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2803, i64 5
  %1873 = load ptr, ptr %m_clBuffer.i539, align 8
  store ptr %1873, ptr %arrayinit.element2824, align 16
  %m_isReadOnly.i4231 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2803, i64 5, i32 1
  store i8 1, ptr %m_isReadOnly.i4231, align 8
  %arrayinit.element2828 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2803, i64 6
  %1874 = load ptr, ptr %m_clBuffer.i541, align 8
  store ptr %1874, ptr %arrayinit.element2828, align 16
  %m_isReadOnly.i4233 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2803, i64 6, i32 1
  store i8 1, ptr %m_isReadOnly.i4233, align 8
  %arrayinit.element2832 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2803, i64 7
  %1875 = load ptr, ptr %m_clBuffer.i543, align 8
  store ptr %1875, ptr %arrayinit.element2832, align 16
  %m_isReadOnly.i4235 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2803, i64 7, i32 1
  store i8 1, ptr %m_isReadOnly.i4235, align 8
  %arrayinit.element2836 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2803, i64 8
  %m_clBuffer.i4236 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 26, i32 3
  %1876 = load ptr, ptr %m_clBuffer.i4236, align 8
  store ptr %1876, ptr %arrayinit.element2836, align 16
  %m_isReadOnly.i4237 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2803, i64 8, i32 1
  store i8 0, ptr %m_isReadOnly.i4237, align 8
  %arrayinit.element2841 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2803, i64 9
  %m_clBuffer.i4238 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 28, i32 3
  %1877 = load ptr, ptr %m_clBuffer.i4238, align 8
  store ptr %1877, ptr %arrayinit.element2841, align 16
  %m_isReadOnly.i4239 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2803, i64 9, i32 1
  store i8 0, ptr %m_isReadOnly.i4239, align 8
  %arrayinit.element2846 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2803, i64 10
  %1878 = load ptr, ptr %m_clBuffer.i545, align 8
  store ptr %1878, ptr %arrayinit.element2846, align 16
  %m_isReadOnly.i4241 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2803, i64 10, i32 1
  store i8 0, ptr %m_isReadOnly.i4241, align 8
  %arrayinit.element2850 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2803, i64 11
  %1879 = load ptr, ptr %m_clBuffer.i, align 8
  store ptr %1879, ptr %arrayinit.element2850, align 16
  %m_isReadOnly.i4243 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2803, i64 11, i32 1
  store i8 0, ptr %m_isReadOnly.i4243, align 8
  %1880 = load ptr, ptr %m_queue, align 8
  %m_clipHullHullKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 14
  %1881 = load ptr, ptr %m_clipHullHullKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher2855, ptr noundef %1880, ptr noundef %1881, ptr noundef nonnull @.str.63)
          to label %invoke.cont2857 unwind label %lpad2300

invoke.cont2857:                                  ; preds = %if.then2802
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher2855, ptr noundef nonnull %bInfo2803, i32 noundef 12)
          to label %invoke.cont2860 unwind label %lpad2859

invoke.cont2860:                                  ; preds = %invoke.cont2857
  %m_enableSerialization.i4244 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2855, i64 0, i32 7
  %1882 = load i8, ptr %m_enableSerialization.i4244, align 4
  %1883 = and i8 %1882, 1
  %tobool.not.i4245 = icmp eq i8 %1883, 0
  br i1 %tobool.not.i4245, label %if.end.i4261, label %if.then.i4246

if.then.i4246:                                    ; preds = %invoke.cont2860
  %m_idx.i4247 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2855, i64 0, i32 3
  %1884 = load i32, ptr %m_idx.i4247, align 8
  %1885 = load i32, ptr %nPairs.addr, align 4
  %m_size.i.i.i4248 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2855, i64 0, i32 5, i32 2
  %1886 = load i32, ptr %m_size.i.i.i4248, align 4
  %m_capacity.i.i.i4249 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2855, i64 0, i32 5, i32 3
  %1887 = load i32, ptr %m_capacity.i.i.i4249, align 8
  %cmp.i.i4250 = icmp eq i32 %1886, %1887
  br i1 %cmp.i.i4250, label %if.then.i.i4266, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i4251

if.then.i.i4266:                                  ; preds = %if.then.i4246
  %tobool.not.i.i.i4268 = icmp eq i32 %1886, 0
  %mul.i.i.i4269 = shl nsw i32 %1886, 1
  %cond.i.i.i4270 = select i1 %tobool.not.i.i.i4268, i32 1, i32 %mul.i.i.i4269
  %cmp.i5907 = icmp slt i32 %1886, %cond.i.i.i4270
  br i1 %cmp.i5907, label %if.then.i5909, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i4251

if.then.i5909:                                    ; preds = %if.then.i.i4266
  %tobool.not.i.i5910 = icmp eq i32 %cond.i.i.i4270, 0
  br i1 %tobool.not.i.i5910, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5938, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5911

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5911: ; preds = %if.then.i5909
  %conv.i.i.i5912 = sext i32 %cond.i.i.i4270 to i64
  %mul.i.i.i5913 = shl nsw i64 %conv.i.i.i5912, 5
  %call.i.i.i5941 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i5913, i32 noundef 16)
          to label %call.i.i.i.noexc5940 unwind label %lpad2859

call.i.i.i.noexc5940:                             ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5911
  %cmp3.i5914 = icmp eq ptr %call.i.i.i5941, null
  br i1 %cmp3.i5914, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5938, label %if.then.split.i5915

if.then.split.i5915:                              ; preds = %call.i.i.i.noexc5940
  %1888 = load i32, ptr %m_size.i.i.i4248, align 4
  %cmp4.i.i5917 = icmp sgt i32 %1888, 0
  br i1 %cmp4.i.i5917, label %for.body.lr.ph.i.i5929, label %if.end.i5918

for.body.lr.ph.i.i5929:                           ; preds = %if.then.split.i5915
  %m_data.i.i5930 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2855, i64 0, i32 5, i32 5
  %wide.trip.count.i.i5931 = zext nneg i32 %1888 to i64
  br label %for.body.i.i5932

for.body.i.i5932:                                 ; preds = %for.body.i.i5932, %for.body.lr.ph.i.i5929
  %indvars.iv.i.i5933 = phi i64 [ 0, %for.body.lr.ph.i.i5929 ], [ %indvars.iv.next.i.i5936, %for.body.i.i5932 ]
  %arrayidx.i.i5934 = getelementptr inbounds %struct.b3KernelArgData, ptr %call.i.i.i5941, i64 %indvars.iv.i.i5933
  %1889 = load ptr, ptr %m_data.i.i5930, align 8
  %arrayidx3.i.i5935 = getelementptr inbounds %struct.b3KernelArgData, ptr %1889, i64 %indvars.iv.i.i5933
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i.i5934, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i.i5935, i64 32, i1 false)
  %indvars.iv.next.i.i5936 = add nuw nsw i64 %indvars.iv.i.i5933, 1
  %exitcond.not.i.i5937 = icmp eq i64 %indvars.iv.next.i.i5936, %wide.trip.count.i.i5931
  br i1 %exitcond.not.i.i5937, label %if.end.i5918, label %for.body.i.i5932, !llvm.loop !64

_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5938: ; preds = %call.i.i.i.noexc5940, %if.then.i5909
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc5942 unwind label %lpad2859

.noexc5942:                                       ; preds = %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5938
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc5943 unwind label %lpad2859

.noexc5943:                                       ; preds = %.noexc5942
  store i32 0, ptr %m_size.i.i.i4248, align 4
  br label %if.end.i5918

if.end.i5918:                                     ; preds = %for.body.i.i5932, %.noexc5943, %if.then.split.i5915
  %retval.0.i25.i5919 = phi ptr [ null, %.noexc5943 ], [ %call.i.i.i5941, %if.then.split.i5915 ], [ %call.i.i.i5941, %for.body.i.i5932 ]
  %_Count.addr.0.i5920 = phi i32 [ 0, %.noexc5943 ], [ %cond.i.i.i4270, %if.then.split.i5915 ], [ %cond.i.i.i4270, %for.body.i.i5932 ]
  %m_data.i20.i5921 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2855, i64 0, i32 5, i32 5
  %1890 = load ptr, ptr %m_data.i20.i5921, align 8
  %tobool.not.i21.i5922 = icmp eq ptr %1890, null
  br i1 %tobool.not.i21.i5922, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5927, label %if.then.i22.i5923

if.then.i22.i5923:                                ; preds = %if.end.i5918
  %m_ownsMemory.i.i5924 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2855, i64 0, i32 5, i32 6
  %1891 = load i8, ptr %m_ownsMemory.i.i5924, align 8
  %1892 = and i8 %1891, 1
  %tobool2.not.i.i5925 = icmp eq i8 %1892, 0
  br i1 %tobool2.not.i.i5925, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5927, label %if.then3.i.i5926

if.then3.i.i5926:                                 ; preds = %if.then.i22.i5923
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1890)
          to label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5927 unwind label %lpad2859

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5927: ; preds = %if.then3.i.i5926, %if.then.i22.i5923, %if.end.i5918
  %m_ownsMemory.i5928 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2855, i64 0, i32 5, i32 6
  store i8 1, ptr %m_ownsMemory.i5928, align 8
  store ptr %retval.0.i25.i5919, ptr %m_data.i20.i5921, align 8
  store i32 %_Count.addr.0.i5920, ptr %m_capacity.i.i.i4249, align 8
  %.pre.i.i4271.pre = load i32, ptr %m_size.i.i.i4248, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i4251

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i4251: ; preds = %if.then.i.i4266, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5927, %if.then.i4246
  %1893 = phi i32 [ %1886, %if.then.i4246 ], [ %.pre.i.i4271.pre, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5927 ], [ %1886, %if.then.i.i4266 ]
  %m_data.i.i4252 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2855, i64 0, i32 5, i32 5
  %1894 = load ptr, ptr %m_data.i.i4252, align 8
  %idxprom.i.i4253 = sext i32 %1893 to i64
  %arrayidx.i.i4254 = getelementptr inbounds %struct.b3KernelArgData, ptr %1894, i64 %idxprom.i.i4253
  store i32 0, ptr %arrayidx.i.i4254, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i4255 = getelementptr inbounds i8, ptr %arrayidx.i.i4254, i64 4
  store i32 %1884, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i4255, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i4256 = getelementptr inbounds i8, ptr %arrayidx.i.i4254, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i4256, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i4257 = getelementptr inbounds i8, ptr %arrayidx.i.i4254, i64 16
  store i32 %1885, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i4257, align 16
  %1895 = load i32, ptr %m_size.i.i.i4248, align 4
  %inc.i.i4258 = add nsw i32 %1895, 1
  store i32 %inc.i.i4258, ptr %m_size.i.i.i4248, align 4
  %m_serializationSizeInBytes.i4259 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2855, i64 0, i32 6
  %1896 = load i32, ptr %m_serializationSizeInBytes.i4259, align 8
  %add.i4260 = add i32 %1896, 32
  store i32 %add.i4260, ptr %m_serializationSizeInBytes.i4259, align 8
  br label %if.end.i4261

if.end.i4261:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i4251, %invoke.cont2860
  %1897 = load ptr, ptr @__clewSetKernelArg, align 8
  %m_kernel.i4262 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2855, i64 0, i32 2
  %1898 = load ptr, ptr %m_kernel.i4262, align 8
  %m_idx3.i4263 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2855, i64 0, i32 3
  %1899 = load i32, ptr %m_idx3.i4263, align 8
  %inc.i4264 = add nsw i32 %1899, 1
  store i32 %inc.i4264, ptr %m_idx3.i4263, align 8
  %call.i42654273 = invoke i32 %1897(ptr noundef %1898, i32 noundef %1899, i64 noundef 4, ptr noundef nonnull %nPairs.addr)
          to label %invoke.cont2861 unwind label %lpad2859

invoke.cont2861:                                  ; preds = %if.end.i4261
  %1900 = load i8, ptr %m_enableSerialization.i4244, align 4
  %1901 = and i8 %1900, 1
  %tobool.not.i4276 = icmp eq i8 %1901, 0
  br i1 %tobool.not.i4276, label %if.end.i4292, label %if.then.i4277

if.then.i4277:                                    ; preds = %invoke.cont2861
  %1902 = load i32, ptr %m_idx3.i4263, align 8
  %1903 = load i32, ptr %maxContactCapacity.addr, align 4
  %m_size.i.i.i4279 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2855, i64 0, i32 5, i32 2
  %1904 = load i32, ptr %m_size.i.i.i4279, align 4
  %m_capacity.i.i.i4280 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2855, i64 0, i32 5, i32 3
  %1905 = load i32, ptr %m_capacity.i.i.i4280, align 8
  %cmp.i.i4281 = icmp eq i32 %1904, %1905
  br i1 %cmp.i.i4281, label %if.then.i.i4297, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i4282

if.then.i.i4297:                                  ; preds = %if.then.i4277
  %tobool.not.i.i.i4299 = icmp eq i32 %1904, 0
  %mul.i.i.i4300 = shl nsw i32 %1904, 1
  %cond.i.i.i4301 = select i1 %tobool.not.i.i.i4299, i32 1, i32 %mul.i.i.i4300
  %cmp.i5947 = icmp slt i32 %1904, %cond.i.i.i4301
  br i1 %cmp.i5947, label %if.then.i5949, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i4282

if.then.i5949:                                    ; preds = %if.then.i.i4297
  %tobool.not.i.i5950 = icmp eq i32 %cond.i.i.i4301, 0
  br i1 %tobool.not.i.i5950, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5978, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5951

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5951: ; preds = %if.then.i5949
  %conv.i.i.i5952 = sext i32 %cond.i.i.i4301 to i64
  %mul.i.i.i5953 = shl nsw i64 %conv.i.i.i5952, 5
  %call.i.i.i5981 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i5953, i32 noundef 16)
          to label %call.i.i.i.noexc5980 unwind label %lpad2859

call.i.i.i.noexc5980:                             ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5951
  %cmp3.i5954 = icmp eq ptr %call.i.i.i5981, null
  br i1 %cmp3.i5954, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5978, label %if.then.split.i5955

if.then.split.i5955:                              ; preds = %call.i.i.i.noexc5980
  %1906 = load i32, ptr %m_size.i.i.i4279, align 4
  %cmp4.i.i5957 = icmp sgt i32 %1906, 0
  br i1 %cmp4.i.i5957, label %for.body.lr.ph.i.i5969, label %if.end.i5958

for.body.lr.ph.i.i5969:                           ; preds = %if.then.split.i5955
  %m_data.i.i5970 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2855, i64 0, i32 5, i32 5
  %wide.trip.count.i.i5971 = zext nneg i32 %1906 to i64
  br label %for.body.i.i5972

for.body.i.i5972:                                 ; preds = %for.body.i.i5972, %for.body.lr.ph.i.i5969
  %indvars.iv.i.i5973 = phi i64 [ 0, %for.body.lr.ph.i.i5969 ], [ %indvars.iv.next.i.i5976, %for.body.i.i5972 ]
  %arrayidx.i.i5974 = getelementptr inbounds %struct.b3KernelArgData, ptr %call.i.i.i5981, i64 %indvars.iv.i.i5973
  %1907 = load ptr, ptr %m_data.i.i5970, align 8
  %arrayidx3.i.i5975 = getelementptr inbounds %struct.b3KernelArgData, ptr %1907, i64 %indvars.iv.i.i5973
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i.i5974, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i.i5975, i64 32, i1 false)
  %indvars.iv.next.i.i5976 = add nuw nsw i64 %indvars.iv.i.i5973, 1
  %exitcond.not.i.i5977 = icmp eq i64 %indvars.iv.next.i.i5976, %wide.trip.count.i.i5971
  br i1 %exitcond.not.i.i5977, label %if.end.i5958, label %for.body.i.i5972, !llvm.loop !64

_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5978: ; preds = %call.i.i.i.noexc5980, %if.then.i5949
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc5982 unwind label %lpad2859

.noexc5982:                                       ; preds = %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5978
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc5983 unwind label %lpad2859

.noexc5983:                                       ; preds = %.noexc5982
  store i32 0, ptr %m_size.i.i.i4279, align 4
  br label %if.end.i5958

if.end.i5958:                                     ; preds = %for.body.i.i5972, %.noexc5983, %if.then.split.i5955
  %retval.0.i25.i5959 = phi ptr [ null, %.noexc5983 ], [ %call.i.i.i5981, %if.then.split.i5955 ], [ %call.i.i.i5981, %for.body.i.i5972 ]
  %_Count.addr.0.i5960 = phi i32 [ 0, %.noexc5983 ], [ %cond.i.i.i4301, %if.then.split.i5955 ], [ %cond.i.i.i4301, %for.body.i.i5972 ]
  %m_data.i20.i5961 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2855, i64 0, i32 5, i32 5
  %1908 = load ptr, ptr %m_data.i20.i5961, align 8
  %tobool.not.i21.i5962 = icmp eq ptr %1908, null
  br i1 %tobool.not.i21.i5962, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5967, label %if.then.i22.i5963

if.then.i22.i5963:                                ; preds = %if.end.i5958
  %m_ownsMemory.i.i5964 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2855, i64 0, i32 5, i32 6
  %1909 = load i8, ptr %m_ownsMemory.i.i5964, align 8
  %1910 = and i8 %1909, 1
  %tobool2.not.i.i5965 = icmp eq i8 %1910, 0
  br i1 %tobool2.not.i.i5965, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5967, label %if.then3.i.i5966

if.then3.i.i5966:                                 ; preds = %if.then.i22.i5963
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1908)
          to label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5967 unwind label %lpad2859

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5967: ; preds = %if.then3.i.i5966, %if.then.i22.i5963, %if.end.i5958
  %m_ownsMemory.i5968 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2855, i64 0, i32 5, i32 6
  store i8 1, ptr %m_ownsMemory.i5968, align 8
  store ptr %retval.0.i25.i5959, ptr %m_data.i20.i5961, align 8
  store i32 %_Count.addr.0.i5960, ptr %m_capacity.i.i.i4280, align 8
  %.pre.i.i4302.pre = load i32, ptr %m_size.i.i.i4279, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i4282

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i4282: ; preds = %if.then.i.i4297, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5967, %if.then.i4277
  %1911 = phi i32 [ %1904, %if.then.i4277 ], [ %.pre.i.i4302.pre, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i5967 ], [ %1904, %if.then.i.i4297 ]
  %m_data.i.i4283 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2855, i64 0, i32 5, i32 5
  %1912 = load ptr, ptr %m_data.i.i4283, align 8
  %idxprom.i.i4284 = sext i32 %1911 to i64
  %arrayidx.i.i4285 = getelementptr inbounds %struct.b3KernelArgData, ptr %1912, i64 %idxprom.i.i4284
  store i32 0, ptr %arrayidx.i.i4285, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i4286 = getelementptr inbounds i8, ptr %arrayidx.i.i4285, i64 4
  store i32 %1902, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i4286, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i4287 = getelementptr inbounds i8, ptr %arrayidx.i.i4285, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i4287, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i4288 = getelementptr inbounds i8, ptr %arrayidx.i.i4285, i64 16
  store i32 %1903, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i4288, align 16
  %1913 = load i32, ptr %m_size.i.i.i4279, align 4
  %inc.i.i4289 = add nsw i32 %1913, 1
  store i32 %inc.i.i4289, ptr %m_size.i.i.i4279, align 4
  %m_serializationSizeInBytes.i4290 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2855, i64 0, i32 6
  %1914 = load i32, ptr %m_serializationSizeInBytes.i4290, align 8
  %add.i4291 = add i32 %1914, 32
  store i32 %add.i4291, ptr %m_serializationSizeInBytes.i4290, align 8
  br label %if.end.i4292

if.end.i4292:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i4282, %invoke.cont2861
  %1915 = load ptr, ptr @__clewSetKernelArg, align 8
  %1916 = load ptr, ptr %m_kernel.i4262, align 8
  %1917 = load i32, ptr %m_idx3.i4263, align 8
  %inc.i4295 = add nsw i32 %1917, 1
  store i32 %inc.i4295, ptr %m_idx3.i4263, align 8
  %call.i42964304 = invoke i32 %1915(ptr noundef %1916, i32 noundef %1917, i64 noundef 4, ptr noundef nonnull %maxContactCapacity.addr)
          to label %invoke.cont2862 unwind label %lpad2859

invoke.cont2862:                                  ; preds = %if.end.i4292
  %1918 = load i32, ptr %nPairs.addr, align 4
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %gRange.i.i4306)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %lRange.i.i4307)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %gRange.i.i4306, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %lRange.i.i4307, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  store i64 64, ptr %lRange.i.i4307, align 16
  %arrayidx3.i.i4308 = getelementptr inbounds [3 x i64], ptr %lRange.i.i4307, i64 0, i64 1
  store i64 1, ptr %arrayidx3.i.i4308, align 8
  %conv5.i.i4309 = sext i32 %1918 to i64
  %div.i.i43106139 = lshr i64 %conv5.i.i4309, 6
  %rem.i.i4311 = and i64 %conv5.i.i4309, 63
  %tobool.not.i.i4312 = icmp ne i64 %rem.i.i4311, 0
  %conv9.i.i4313 = zext i1 %tobool.not.i.i4312 to i64
  %add.i.i4314 = add nuw nsw i64 %div.i.i43106139, %conv9.i.i4313
  %.sroa.speculated8.i.i4315 = call i64 @llvm.umax.i64(i64 %add.i.i4314, i64 1)
  %mul.i.i4316 = shl i64 %.sroa.speculated8.i.i4315, 6
  store i64 %mul.i.i4316, ptr %gRange.i.i4306, align 16
  %arrayidx27.i.i4317 = getelementptr inbounds [3 x i64], ptr %gRange.i.i4306, i64 0, i64 1
  store i64 1, ptr %arrayidx27.i.i4317, align 8
  %1919 = load ptr, ptr @__clewEnqueueNDRangeKernel, align 8
  %m_commandQueue.i.i4318 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2855, i64 0, i32 1
  %1920 = load ptr, ptr %m_commandQueue.i.i4318, align 8
  %1921 = load ptr, ptr %m_kernel.i4262, align 8
  %call32.i.i4324 = invoke i32 %1919(ptr noundef %1920, ptr noundef %1921, i32 noundef 2, ptr noundef null, ptr noundef nonnull %gRange.i.i4306, ptr noundef nonnull %lRange.i.i4307, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call32.i.i.noexc4323 unwind label %lpad2859

call32.i.i.noexc4323:                             ; preds = %invoke.cont2862
  %cmp.not.i.i4320 = icmp eq i32 %call32.i.i4324, 0
  br i1 %cmp.not.i.i4320, label %invoke.cont2864, label %if.then.i.i4321

if.then.i.i4321:                                  ; preds = %call32.i.i.noexc4323
  %call33.i.i4322 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.74, i32 noundef %call32.i.i4324)
  br label %invoke.cont2864

invoke.cont2864:                                  ; preds = %if.then.i.i4321, %call32.i.i.noexc4323
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %gRange.i.i4306)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %lRange.i.i4307)
  %1922 = load ptr, ptr @__clewFinish, align 8
  %1923 = load ptr, ptr %m_queue, align 8
  %call2867 = invoke i32 %1922(ptr noundef %1923)
          to label %invoke.cont2866 unwind label %lpad2859

invoke.cont2866:                                  ; preds = %invoke.cont2864
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %elem.i4326)
  %1924 = load i64, ptr %m_capacity.i.i.i584, align 8
  %cmp.not.i.i4328 = icmp eq i64 %1924, 0
  br i1 %cmp.not.i.i4328, label %do.body.i.i4333, label %if.then.i.i4329

if.then.i.i4329:                                  ; preds = %invoke.cont2866
  %1925 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %1926 = load ptr, ptr %m_commandQueue.i, align 8
  %1927 = load ptr, ptr %m_clBuffer.i, align 8
  %call3.i.i4335 = invoke i32 %1925(ptr noundef %1926, ptr noundef %1927, i32 noundef 0, i64 noundef 0, i64 noundef 4, ptr noundef nonnull %elem.i4326, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call3.i.i.noexc4334 unwind label %lpad2859

call3.i.i.noexc4334:                              ; preds = %if.then.i.i4329
  %1928 = load ptr, ptr @__clewFinish, align 8
  %1929 = load ptr, ptr %m_commandQueue.i, align 8
  %call6.i.i4337 = invoke i32 %1928(ptr noundef %1929)
          to label %invoke.cont2869 unwind label %lpad2859

do.body.i.i4333:                                  ; preds = %invoke.cont2866
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 285)
          to label %.noexc4338 unwind label %lpad2859

.noexc4338:                                       ; preds = %do.body.i.i4333
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.80)
          to label %invoke.cont2869.thread unwind label %lpad2859

invoke.cont2869.thread:                           ; preds = %.noexc4338
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %elem.i4326)
  br label %do.body2873

invoke.cont2869:                                  ; preds = %call3.i.i.noexc4334
  %.pre.i4332 = load i32, ptr %elem.i4326, align 4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %elem.i4326)
  store i32 %.pre.i4332, ptr %nContacts, align 4
  %1930 = load i32, ptr %maxContactCapacity.addr, align 4
  %cmp2871.not = icmp slt i32 %.pre.i4332, %1930
  br i1 %cmp2871.not, label %if.end2878, label %do.body2873

do.body2873:                                      ; preds = %invoke.cont2869.thread, %invoke.cont2869
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.31, i32 noundef 4360)
          to label %invoke.cont2874 unwind label %lpad2859

invoke.cont2874:                                  ; preds = %do.body2873
  %1931 = load i32, ptr %nContacts, align 4
  %1932 = load i32, ptr %maxContactCapacity.addr, align 4
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.64, i32 noundef %1931, i32 noundef %1932)
          to label %do.end2877 unwind label %lpad2859

do.end2877:                                       ; preds = %invoke.cont2874
  %1933 = load i32, ptr %maxContactCapacity.addr, align 4
  store i32 %1933, ptr %nContacts, align 4
  br label %if.end2878

lpad2859:                                         ; preds = %if.then3.i.i5966, %.noexc5982, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5978, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5951, %if.then3.i.i5926, %.noexc5942, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i5938, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5911, %if.end7.i4345, %.noexc4338, %do.body.i.i4333, %call3.i.i.noexc4334, %if.then.i.i4329, %invoke.cont2862, %if.end.i4292, %if.end.i4261, %invoke.cont2874, %do.body2873, %invoke.cont2864, %invoke.cont2857
  %1934 = landingpad { ptr, i32 }
          cleanup
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher2855) #26
  br label %ehcleanup2977

if.end2878:                                       ; preds = %do.end2877, %invoke.cont2869
  %1935 = phi i32 [ %1933, %do.end2877 ], [ %.pre.i4332, %invoke.cont2869 ]
  %conv2879 = sext i32 %1935 to i64
  %1936 = load i64, ptr %m_size.i.i, align 8
  %cmp3.i4342 = icmp ult i64 %1936, %conv2879
  br i1 %cmp3.i4342, label %if.end7.i4345, label %invoke.cont2880

if.end7.i4345:                                    ; preds = %if.end2878
  %call5.i4348 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI10b3Contact4E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %contactOut, i64 noundef %conv2879, i1 noundef zeroext true)
          to label %call5.i.noexc4347 unwind label %lpad2859

call5.i.noexc4347:                                ; preds = %if.end7.i4345
  %spec.select.i4346 = select i1 %call5.i4348, i64 %conv2879, i64 0
  br label %invoke.cont2880

invoke.cont2880:                                  ; preds = %call5.i.noexc4347, %if.end2878
  %storemerge.i4343 = phi i64 [ %conv2879, %if.end2878 ], [ %spec.select.i4346, %call5.i.noexc4347 ]
  store i64 %storemerge.i4343, ptr %m_size.i.i, align 8
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher2855) #26
  br label %if.end2884

if.end2884:                                       ; preds = %if.else2800, %invoke.cont2880
  %1937 = load i64, ptr %m_size.i.i649, align 8
  %conv2888 = trunc i64 %1937 to i32
  store i32 %conv2888, ptr %nCompoundsPairs, align 4
  %tobool2889.not = icmp eq i32 %conv2888, 0
  br i1 %tobool2889.not, label %if.end2976, label %if.then2890

if.then2890:                                      ; preds = %if.end2884
  %1938 = load ptr, ptr %m_clBuffer.i1870, align 8
  store ptr %1938, ptr %bInfo2891, align 16
  %m_isReadOnly.i4352 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2891, i64 0, i32 1
  store i8 1, ptr %m_isReadOnly.i4352, align 8
  %arrayinit.element2897 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2891, i64 1
  %1939 = load ptr, ptr %m_clBuffer.i531, align 8
  store ptr %1939, ptr %arrayinit.element2897, align 16
  %m_isReadOnly.i4354 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2891, i64 1, i32 1
  store i8 1, ptr %m_isReadOnly.i4354, align 8
  %arrayinit.element2901 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2891, i64 2
  %1940 = load ptr, ptr %m_clBuffer.i533, align 8
  store ptr %1940, ptr %arrayinit.element2901, align 16
  %m_isReadOnly.i4356 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2891, i64 2, i32 1
  store i8 1, ptr %m_isReadOnly.i4356, align 8
  %arrayinit.element2905 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2891, i64 3
  %1941 = load ptr, ptr %m_clBuffer.i535, align 8
  store ptr %1941, ptr %arrayinit.element2905, align 16
  %m_isReadOnly.i4358 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2891, i64 3, i32 1
  store i8 1, ptr %m_isReadOnly.i4358, align 8
  %arrayinit.element2909 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2891, i64 4
  %1942 = load ptr, ptr %m_clBuffer.i537, align 8
  store ptr %1942, ptr %arrayinit.element2909, align 16
  %m_isReadOnly.i4360 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2891, i64 4, i32 1
  store i8 1, ptr %m_isReadOnly.i4360, align 8
  %arrayinit.element2913 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2891, i64 5
  %1943 = load ptr, ptr %m_clBuffer.i539, align 8
  store ptr %1943, ptr %arrayinit.element2913, align 16
  %m_isReadOnly.i4362 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2891, i64 5, i32 1
  store i8 1, ptr %m_isReadOnly.i4362, align 8
  %arrayinit.element2917 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2891, i64 6
  %1944 = load ptr, ptr %m_clBuffer.i541, align 8
  store ptr %1944, ptr %arrayinit.element2917, align 16
  %m_isReadOnly.i4364 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2891, i64 6, i32 1
  store i8 1, ptr %m_isReadOnly.i4364, align 8
  %arrayinit.element2921 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2891, i64 7
  %1945 = load ptr, ptr %m_clBuffer.i543, align 8
  store ptr %1945, ptr %arrayinit.element2921, align 16
  %m_isReadOnly.i4366 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2891, i64 7, i32 1
  store i8 1, ptr %m_isReadOnly.i4366, align 8
  %arrayinit.element2925 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2891, i64 8
  %1946 = load ptr, ptr %m_clBuffer.i1868, align 8
  store ptr %1946, ptr %arrayinit.element2925, align 16
  %m_isReadOnly.i4368 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2891, i64 8, i32 1
  store i8 1, ptr %m_isReadOnly.i4368, align 8
  %arrayinit.element2929 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2891, i64 9
  %m_clBuffer.i4369 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 33, i32 3
  %1947 = load ptr, ptr %m_clBuffer.i4369, align 8
  store ptr %1947, ptr %arrayinit.element2929, align 16
  %m_isReadOnly.i4370 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2891, i64 9, i32 1
  store i8 1, ptr %m_isReadOnly.i4370, align 8
  %arrayinit.element2934 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2891, i64 10
  %m_clBuffer.i4371 = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 34, i32 3
  %1948 = load ptr, ptr %m_clBuffer.i4371, align 8
  store ptr %1948, ptr %arrayinit.element2934, align 16
  %m_isReadOnly.i4372 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2891, i64 10, i32 1
  store i8 1, ptr %m_isReadOnly.i4372, align 8
  %arrayinit.element2939 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2891, i64 11
  %1949 = load ptr, ptr %m_clBuffer.i545, align 8
  store ptr %1949, ptr %arrayinit.element2939, align 16
  %m_isReadOnly.i4374 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2891, i64 11, i32 1
  store i8 0, ptr %m_isReadOnly.i4374, align 8
  %arrayinit.element2943 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2891, i64 12
  %1950 = load ptr, ptr %m_clBuffer.i, align 8
  store ptr %1950, ptr %arrayinit.element2943, align 16
  %m_isReadOnly.i4376 = getelementptr inbounds %struct.b3BufferInfoCL, ptr %bInfo2891, i64 12, i32 1
  store i8 0, ptr %m_isReadOnly.i4376, align 8
  %1951 = load ptr, ptr %m_queue, align 8
  %m_clipCompoundsHullHullKernel = getelementptr inbounds %struct.GpuSatCollision, ptr %this, i64 0, i32 15
  %1952 = load ptr, ptr %m_clipCompoundsHullHullKernel, align 8
  invoke void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112) %launcher2948, ptr noundef %1951, ptr noundef %1952, ptr noundef nonnull @.str.65)
          to label %invoke.cont2950 unwind label %lpad2300

invoke.cont2950:                                  ; preds = %if.then2890
  invoke void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112) %launcher2948, ptr noundef nonnull %bInfo2891, i32 noundef 13)
          to label %invoke.cont2953 unwind label %lpad2952

invoke.cont2953:                                  ; preds = %invoke.cont2950
  %m_enableSerialization.i4377 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2948, i64 0, i32 7
  %1953 = load i8, ptr %m_enableSerialization.i4377, align 4
  %1954 = and i8 %1953, 1
  %tobool.not.i4378 = icmp eq i8 %1954, 0
  br i1 %tobool.not.i4378, label %if.end.i4394, label %if.then.i4379

if.then.i4379:                                    ; preds = %invoke.cont2953
  %m_idx.i4380 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2948, i64 0, i32 3
  %1955 = load i32, ptr %m_idx.i4380, align 8
  %1956 = load i32, ptr %nCompoundsPairs, align 4
  %m_size.i.i.i4381 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2948, i64 0, i32 5, i32 2
  %1957 = load i32, ptr %m_size.i.i.i4381, align 4
  %m_capacity.i.i.i4382 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2948, i64 0, i32 5, i32 3
  %1958 = load i32, ptr %m_capacity.i.i.i4382, align 8
  %cmp.i.i4383 = icmp eq i32 %1957, %1958
  br i1 %cmp.i.i4383, label %if.then.i.i4399, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i4384

if.then.i.i4399:                                  ; preds = %if.then.i4379
  %tobool.not.i.i.i4401 = icmp eq i32 %1957, 0
  %mul.i.i.i4402 = shl nsw i32 %1957, 1
  %cond.i.i.i4403 = select i1 %tobool.not.i.i.i4401, i32 1, i32 %mul.i.i.i4402
  %cmp.i5987 = icmp slt i32 %1957, %cond.i.i.i4403
  br i1 %cmp.i5987, label %if.then.i5989, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i4384

if.then.i5989:                                    ; preds = %if.then.i.i4399
  %tobool.not.i.i5990 = icmp eq i32 %cond.i.i.i4403, 0
  br i1 %tobool.not.i.i5990, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i6018, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5991

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5991: ; preds = %if.then.i5989
  %conv.i.i.i5992 = sext i32 %cond.i.i.i4403 to i64
  %mul.i.i.i5993 = shl nsw i64 %conv.i.i.i5992, 5
  %call.i.i.i6021 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i5993, i32 noundef 16)
          to label %call.i.i.i.noexc6020 unwind label %lpad2952

call.i.i.i.noexc6020:                             ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5991
  %cmp3.i5994 = icmp eq ptr %call.i.i.i6021, null
  br i1 %cmp3.i5994, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i6018, label %if.then.split.i5995

if.then.split.i5995:                              ; preds = %call.i.i.i.noexc6020
  %1959 = load i32, ptr %m_size.i.i.i4381, align 4
  %cmp4.i.i5997 = icmp sgt i32 %1959, 0
  br i1 %cmp4.i.i5997, label %for.body.lr.ph.i.i6009, label %if.end.i5998

for.body.lr.ph.i.i6009:                           ; preds = %if.then.split.i5995
  %m_data.i.i6010 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2948, i64 0, i32 5, i32 5
  %wide.trip.count.i.i6011 = zext nneg i32 %1959 to i64
  br label %for.body.i.i6012

for.body.i.i6012:                                 ; preds = %for.body.i.i6012, %for.body.lr.ph.i.i6009
  %indvars.iv.i.i6013 = phi i64 [ 0, %for.body.lr.ph.i.i6009 ], [ %indvars.iv.next.i.i6016, %for.body.i.i6012 ]
  %arrayidx.i.i6014 = getelementptr inbounds %struct.b3KernelArgData, ptr %call.i.i.i6021, i64 %indvars.iv.i.i6013
  %1960 = load ptr, ptr %m_data.i.i6010, align 8
  %arrayidx3.i.i6015 = getelementptr inbounds %struct.b3KernelArgData, ptr %1960, i64 %indvars.iv.i.i6013
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i.i6014, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i.i6015, i64 32, i1 false)
  %indvars.iv.next.i.i6016 = add nuw nsw i64 %indvars.iv.i.i6013, 1
  %exitcond.not.i.i6017 = icmp eq i64 %indvars.iv.next.i.i6016, %wide.trip.count.i.i6011
  br i1 %exitcond.not.i.i6017, label %if.end.i5998, label %for.body.i.i6012, !llvm.loop !64

_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i6018: ; preds = %call.i.i.i.noexc6020, %if.then.i5989
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc6022 unwind label %lpad2952

.noexc6022:                                       ; preds = %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i6018
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc6023 unwind label %lpad2952

.noexc6023:                                       ; preds = %.noexc6022
  store i32 0, ptr %m_size.i.i.i4381, align 4
  br label %if.end.i5998

if.end.i5998:                                     ; preds = %for.body.i.i6012, %.noexc6023, %if.then.split.i5995
  %retval.0.i25.i5999 = phi ptr [ null, %.noexc6023 ], [ %call.i.i.i6021, %if.then.split.i5995 ], [ %call.i.i.i6021, %for.body.i.i6012 ]
  %_Count.addr.0.i6000 = phi i32 [ 0, %.noexc6023 ], [ %cond.i.i.i4403, %if.then.split.i5995 ], [ %cond.i.i.i4403, %for.body.i.i6012 ]
  %m_data.i20.i6001 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2948, i64 0, i32 5, i32 5
  %1961 = load ptr, ptr %m_data.i20.i6001, align 8
  %tobool.not.i21.i6002 = icmp eq ptr %1961, null
  br i1 %tobool.not.i21.i6002, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i6007, label %if.then.i22.i6003

if.then.i22.i6003:                                ; preds = %if.end.i5998
  %m_ownsMemory.i.i6004 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2948, i64 0, i32 5, i32 6
  %1962 = load i8, ptr %m_ownsMemory.i.i6004, align 8
  %1963 = and i8 %1962, 1
  %tobool2.not.i.i6005 = icmp eq i8 %1963, 0
  br i1 %tobool2.not.i.i6005, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i6007, label %if.then3.i.i6006

if.then3.i.i6006:                                 ; preds = %if.then.i22.i6003
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1961)
          to label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i6007 unwind label %lpad2952

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i6007: ; preds = %if.then3.i.i6006, %if.then.i22.i6003, %if.end.i5998
  %m_ownsMemory.i6008 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2948, i64 0, i32 5, i32 6
  store i8 1, ptr %m_ownsMemory.i6008, align 8
  store ptr %retval.0.i25.i5999, ptr %m_data.i20.i6001, align 8
  store i32 %_Count.addr.0.i6000, ptr %m_capacity.i.i.i4382, align 8
  %.pre.i.i4404.pre = load i32, ptr %m_size.i.i.i4381, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i4384

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i4384: ; preds = %if.then.i.i4399, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i6007, %if.then.i4379
  %1964 = phi i32 [ %1957, %if.then.i4379 ], [ %.pre.i.i4404.pre, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i6007 ], [ %1957, %if.then.i.i4399 ]
  %m_data.i.i4385 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2948, i64 0, i32 5, i32 5
  %1965 = load ptr, ptr %m_data.i.i4385, align 8
  %idxprom.i.i4386 = sext i32 %1964 to i64
  %arrayidx.i.i4387 = getelementptr inbounds %struct.b3KernelArgData, ptr %1965, i64 %idxprom.i.i4386
  store i32 0, ptr %arrayidx.i.i4387, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i4388 = getelementptr inbounds i8, ptr %arrayidx.i.i4387, i64 4
  store i32 %1955, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i4388, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i4389 = getelementptr inbounds i8, ptr %arrayidx.i.i4387, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i4389, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i4390 = getelementptr inbounds i8, ptr %arrayidx.i.i4387, i64 16
  store i32 %1956, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i4390, align 16
  %1966 = load i32, ptr %m_size.i.i.i4381, align 4
  %inc.i.i4391 = add nsw i32 %1966, 1
  store i32 %inc.i.i4391, ptr %m_size.i.i.i4381, align 4
  %m_serializationSizeInBytes.i4392 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2948, i64 0, i32 6
  %1967 = load i32, ptr %m_serializationSizeInBytes.i4392, align 8
  %add.i4393 = add i32 %1967, 32
  store i32 %add.i4393, ptr %m_serializationSizeInBytes.i4392, align 8
  br label %if.end.i4394

if.end.i4394:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i4384, %invoke.cont2953
  %1968 = load ptr, ptr @__clewSetKernelArg, align 8
  %m_kernel.i4395 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2948, i64 0, i32 2
  %1969 = load ptr, ptr %m_kernel.i4395, align 8
  %m_idx3.i4396 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2948, i64 0, i32 3
  %1970 = load i32, ptr %m_idx3.i4396, align 8
  %inc.i4397 = add nsw i32 %1970, 1
  store i32 %inc.i4397, ptr %m_idx3.i4396, align 8
  %call.i43984406 = invoke i32 %1968(ptr noundef %1969, i32 noundef %1970, i64 noundef 4, ptr noundef nonnull %nCompoundsPairs)
          to label %invoke.cont2954 unwind label %lpad2952

invoke.cont2954:                                  ; preds = %if.end.i4394
  %1971 = load i8, ptr %m_enableSerialization.i4377, align 4
  %1972 = and i8 %1971, 1
  %tobool.not.i4409 = icmp eq i8 %1972, 0
  br i1 %tobool.not.i4409, label %if.end.i4425, label %if.then.i4410

if.then.i4410:                                    ; preds = %invoke.cont2954
  %1973 = load i32, ptr %m_idx3.i4396, align 8
  %1974 = load i32, ptr %maxContactCapacity.addr, align 4
  %m_size.i.i.i4412 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2948, i64 0, i32 5, i32 2
  %1975 = load i32, ptr %m_size.i.i.i4412, align 4
  %m_capacity.i.i.i4413 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2948, i64 0, i32 5, i32 3
  %1976 = load i32, ptr %m_capacity.i.i.i4413, align 8
  %cmp.i.i4414 = icmp eq i32 %1975, %1976
  br i1 %cmp.i.i4414, label %if.then.i.i4430, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i4415

if.then.i.i4430:                                  ; preds = %if.then.i4410
  %tobool.not.i.i.i4432 = icmp eq i32 %1975, 0
  %mul.i.i.i4433 = shl nsw i32 %1975, 1
  %cond.i.i.i4434 = select i1 %tobool.not.i.i.i4432, i32 1, i32 %mul.i.i.i4433
  %cmp.i6027 = icmp slt i32 %1975, %cond.i.i.i4434
  br i1 %cmp.i6027, label %if.then.i6029, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i4415

if.then.i6029:                                    ; preds = %if.then.i.i4430
  %tobool.not.i.i6030 = icmp eq i32 %cond.i.i.i4434, 0
  br i1 %tobool.not.i.i6030, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i6058, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i6031

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i6031: ; preds = %if.then.i6029
  %conv.i.i.i6032 = sext i32 %cond.i.i.i4434 to i64
  %mul.i.i.i6033 = shl nsw i64 %conv.i.i.i6032, 5
  %call.i.i.i6061 = invoke noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i.i6033, i32 noundef 16)
          to label %call.i.i.i.noexc6060 unwind label %lpad2952

call.i.i.i.noexc6060:                             ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i6031
  %cmp3.i6034 = icmp eq ptr %call.i.i.i6061, null
  br i1 %cmp3.i6034, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i6058, label %if.then.split.i6035

if.then.split.i6035:                              ; preds = %call.i.i.i.noexc6060
  %1977 = load i32, ptr %m_size.i.i.i4412, align 4
  %cmp4.i.i6037 = icmp sgt i32 %1977, 0
  br i1 %cmp4.i.i6037, label %for.body.lr.ph.i.i6049, label %if.end.i6038

for.body.lr.ph.i.i6049:                           ; preds = %if.then.split.i6035
  %m_data.i.i6050 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2948, i64 0, i32 5, i32 5
  %wide.trip.count.i.i6051 = zext nneg i32 %1977 to i64
  br label %for.body.i.i6052

for.body.i.i6052:                                 ; preds = %for.body.i.i6052, %for.body.lr.ph.i.i6049
  %indvars.iv.i.i6053 = phi i64 [ 0, %for.body.lr.ph.i.i6049 ], [ %indvars.iv.next.i.i6056, %for.body.i.i6052 ]
  %arrayidx.i.i6054 = getelementptr inbounds %struct.b3KernelArgData, ptr %call.i.i.i6061, i64 %indvars.iv.i.i6053
  %1978 = load ptr, ptr %m_data.i.i6050, align 8
  %arrayidx3.i.i6055 = getelementptr inbounds %struct.b3KernelArgData, ptr %1978, i64 %indvars.iv.i.i6053
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i.i6054, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i.i6055, i64 32, i1 false)
  %indvars.iv.next.i.i6056 = add nuw nsw i64 %indvars.iv.i.i6053, 1
  %exitcond.not.i.i6057 = icmp eq i64 %indvars.iv.next.i.i6056, %wide.trip.count.i.i6051
  br i1 %exitcond.not.i.i6057, label %if.end.i6038, label %for.body.i.i6052, !llvm.loop !64

_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i6058: ; preds = %call.i.i.i.noexc6060, %if.then.i6029
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
          to label %.noexc6062 unwind label %lpad2952

.noexc6062:                                       ; preds = %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i6058
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
          to label %.noexc6063 unwind label %lpad2952

.noexc6063:                                       ; preds = %.noexc6062
  store i32 0, ptr %m_size.i.i.i4412, align 4
  br label %if.end.i6038

if.end.i6038:                                     ; preds = %for.body.i.i6052, %.noexc6063, %if.then.split.i6035
  %retval.0.i25.i6039 = phi ptr [ null, %.noexc6063 ], [ %call.i.i.i6061, %if.then.split.i6035 ], [ %call.i.i.i6061, %for.body.i.i6052 ]
  %_Count.addr.0.i6040 = phi i32 [ 0, %.noexc6063 ], [ %cond.i.i.i4434, %if.then.split.i6035 ], [ %cond.i.i.i4434, %for.body.i.i6052 ]
  %m_data.i20.i6041 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2948, i64 0, i32 5, i32 5
  %1979 = load ptr, ptr %m_data.i20.i6041, align 8
  %tobool.not.i21.i6042 = icmp eq ptr %1979, null
  br i1 %tobool.not.i21.i6042, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i6047, label %if.then.i22.i6043

if.then.i22.i6043:                                ; preds = %if.end.i6038
  %m_ownsMemory.i.i6044 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2948, i64 0, i32 5, i32 6
  %1980 = load i8, ptr %m_ownsMemory.i.i6044, align 8
  %1981 = and i8 %1980, 1
  %tobool2.not.i.i6045 = icmp eq i8 %1981, 0
  br i1 %tobool2.not.i.i6045, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i6047, label %if.then3.i.i6046

if.then3.i.i6046:                                 ; preds = %if.then.i22.i6043
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %1979)
          to label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i6047 unwind label %lpad2952

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i6047: ; preds = %if.then3.i.i6046, %if.then.i22.i6043, %if.end.i6038
  %m_ownsMemory.i6048 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2948, i64 0, i32 5, i32 6
  store i8 1, ptr %m_ownsMemory.i6048, align 8
  store ptr %retval.0.i25.i6039, ptr %m_data.i20.i6041, align 8
  store i32 %_Count.addr.0.i6040, ptr %m_capacity.i.i.i4413, align 8
  %.pre.i.i4435.pre = load i32, ptr %m_size.i.i.i4412, align 4
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i4415

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i4415: ; preds = %if.then.i.i4430, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i6047, %if.then.i4410
  %1982 = phi i32 [ %1975, %if.then.i4410 ], [ %.pre.i.i4435.pre, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit.i6047 ], [ %1975, %if.then.i.i4430 ]
  %m_data.i.i4416 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2948, i64 0, i32 5, i32 5
  %1983 = load ptr, ptr %m_data.i.i4416, align 8
  %idxprom.i.i4417 = sext i32 %1982 to i64
  %arrayidx.i.i4418 = getelementptr inbounds %struct.b3KernelArgData, ptr %1983, i64 %idxprom.i.i4417
  store i32 0, ptr %arrayidx.i.i4418, align 16
  %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i4419 = getelementptr inbounds i8, ptr %arrayidx.i.i4418, i64 4
  store i32 %1973, ptr %kernelArg.sroa.2.0.arrayidx.i.sroa_idx.i4419, align 4
  %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i4420 = getelementptr inbounds i8, ptr %arrayidx.i.i4418, i64 8
  store i32 4, ptr %kernelArg.sroa.3.0.arrayidx.i.sroa_idx.i4420, align 8
  %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i4421 = getelementptr inbounds i8, ptr %arrayidx.i.i4418, i64 16
  store i32 %1974, ptr %kernelArg.sroa.42.0.arrayidx.i.sroa_idx.i4421, align 16
  %1984 = load i32, ptr %m_size.i.i.i4412, align 4
  %inc.i.i4422 = add nsw i32 %1984, 1
  store i32 %inc.i.i4422, ptr %m_size.i.i.i4412, align 4
  %m_serializationSizeInBytes.i4423 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2948, i64 0, i32 6
  %1985 = load i32, ptr %m_serializationSizeInBytes.i4423, align 8
  %add.i4424 = add i32 %1985, 32
  store i32 %add.i4424, ptr %m_serializationSizeInBytes.i4423, align 8
  br label %if.end.i4425

if.end.i4425:                                     ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE9push_backERKS0_.exit.i4415, %invoke.cont2954
  %1986 = load ptr, ptr @__clewSetKernelArg, align 8
  %1987 = load ptr, ptr %m_kernel.i4395, align 8
  %1988 = load i32, ptr %m_idx3.i4396, align 8
  %inc.i4428 = add nsw i32 %1988, 1
  store i32 %inc.i4428, ptr %m_idx3.i4396, align 8
  %call.i44294437 = invoke i32 %1986(ptr noundef %1987, i32 noundef %1988, i64 noundef 4, ptr noundef nonnull %maxContactCapacity.addr)
          to label %invoke.cont2955 unwind label %lpad2952

invoke.cont2955:                                  ; preds = %if.end.i4425
  %1989 = load i32, ptr %nCompoundsPairs, align 4
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %gRange.i.i4439)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %lRange.i.i4440)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %gRange.i.i4439, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %lRange.i.i4440, ptr noundef nonnull align 16 dereferenceable(24) @__const._ZN12b3LauncherCL8launch2DEiiii.lRange, i64 24, i1 false)
  store i64 64, ptr %lRange.i.i4440, align 16
  %arrayidx3.i.i4441 = getelementptr inbounds [3 x i64], ptr %lRange.i.i4440, i64 0, i64 1
  store i64 1, ptr %arrayidx3.i.i4441, align 8
  %conv5.i.i4442 = sext i32 %1989 to i64
  %div.i.i44436140 = lshr i64 %conv5.i.i4442, 6
  %rem.i.i4444 = and i64 %conv5.i.i4442, 63
  %tobool.not.i.i4445 = icmp ne i64 %rem.i.i4444, 0
  %conv9.i.i4446 = zext i1 %tobool.not.i.i4445 to i64
  %add.i.i4447 = add nuw nsw i64 %div.i.i44436140, %conv9.i.i4446
  %.sroa.speculated8.i.i4448 = call i64 @llvm.umax.i64(i64 %add.i.i4447, i64 1)
  %mul.i.i4449 = shl i64 %.sroa.speculated8.i.i4448, 6
  store i64 %mul.i.i4449, ptr %gRange.i.i4439, align 16
  %arrayidx27.i.i4450 = getelementptr inbounds [3 x i64], ptr %gRange.i.i4439, i64 0, i64 1
  store i64 1, ptr %arrayidx27.i.i4450, align 8
  %1990 = load ptr, ptr @__clewEnqueueNDRangeKernel, align 8
  %m_commandQueue.i.i4451 = getelementptr inbounds %class.b3LauncherCL, ptr %launcher2948, i64 0, i32 1
  %1991 = load ptr, ptr %m_commandQueue.i.i4451, align 8
  %1992 = load ptr, ptr %m_kernel.i4395, align 8
  %call32.i.i4457 = invoke i32 %1990(ptr noundef %1991, ptr noundef %1992, i32 noundef 2, ptr noundef null, ptr noundef nonnull %gRange.i.i4439, ptr noundef nonnull %lRange.i.i4440, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call32.i.i.noexc4456 unwind label %lpad2952

call32.i.i.noexc4456:                             ; preds = %invoke.cont2955
  %cmp.not.i.i4453 = icmp eq i32 %call32.i.i4457, 0
  br i1 %cmp.not.i.i4453, label %invoke.cont2957, label %if.then.i.i4454

if.then.i.i4454:                                  ; preds = %call32.i.i.noexc4456
  %call33.i.i4455 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.74, i32 noundef %call32.i.i4457)
  br label %invoke.cont2957

invoke.cont2957:                                  ; preds = %if.then.i.i4454, %call32.i.i.noexc4456
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %gRange.i.i4439)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %lRange.i.i4440)
  %1993 = load ptr, ptr @__clewFinish, align 8
  %1994 = load ptr, ptr %m_queue, align 8
  %call2960 = invoke i32 %1993(ptr noundef %1994)
          to label %invoke.cont2959 unwind label %lpad2952

invoke.cont2959:                                  ; preds = %invoke.cont2957
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %elem.i4459)
  %1995 = load i64, ptr %m_capacity.i.i.i584, align 8
  %cmp.not.i.i4461 = icmp eq i64 %1995, 0
  br i1 %cmp.not.i.i4461, label %do.body.i.i4466, label %if.then.i.i4462

if.then.i.i4462:                                  ; preds = %invoke.cont2959
  %1996 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %1997 = load ptr, ptr %m_commandQueue.i, align 8
  %1998 = load ptr, ptr %m_clBuffer.i, align 8
  %call3.i.i4468 = invoke i32 %1996(ptr noundef %1997, ptr noundef %1998, i32 noundef 0, i64 noundef 0, i64 noundef 4, ptr noundef nonnull %elem.i4459, i32 noundef 0, ptr noundef null, ptr noundef null)
          to label %call3.i.i.noexc4467 unwind label %lpad2952

call3.i.i.noexc4467:                              ; preds = %if.then.i.i4462
  %1999 = load ptr, ptr @__clewFinish, align 8
  %2000 = load ptr, ptr %m_commandQueue.i, align 8
  %call6.i.i4470 = invoke i32 %1999(ptr noundef %2000)
          to label %invoke.cont2962 unwind label %lpad2952

do.body.i.i4466:                                  ; preds = %invoke.cont2959
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 285)
          to label %.noexc4471 unwind label %lpad2952

.noexc4471:                                       ; preds = %do.body.i.i4466
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.80)
          to label %invoke.cont2962.thread unwind label %lpad2952

invoke.cont2962.thread:                           ; preds = %.noexc4471
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %elem.i4459)
  %.pre6232 = load i32, ptr %nContacts, align 4
  br label %if.end2971

invoke.cont2962:                                  ; preds = %call3.i.i.noexc4467
  %.pre.i4465 = load i32, ptr %elem.i4459, align 4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %elem.i4459)
  store i32 %.pre.i4465, ptr %nContacts, align 4
  %2001 = load i32, ptr %maxContactCapacity.addr, align 4
  %cmp2964 = icmp sgt i32 %.pre.i4465, %2001
  br i1 %cmp2964, label %do.body2966, label %if.end2971

do.body2966:                                      ; preds = %invoke.cont2962
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.31, i32 noundef 4397)
          to label %invoke.cont2967 unwind label %lpad2952

invoke.cont2967:                                  ; preds = %do.body2966
  %2002 = load i32, ptr %nContacts, align 4
  %2003 = load i32, ptr %maxContactCapacity.addr, align 4
  invoke void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.41, i32 noundef %2002, i32 noundef %2003)
          to label %do.end2970 unwind label %lpad2952

do.end2970:                                       ; preds = %invoke.cont2967
  %2004 = load i32, ptr %maxContactCapacity.addr, align 4
  store i32 %2004, ptr %nContacts, align 4
  br label %if.end2971

lpad2952:                                         ; preds = %if.then3.i.i6046, %.noexc6062, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i6058, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i6031, %if.then3.i.i6006, %.noexc6022, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18.i6018, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit.i5991, %if.end7.i4478, %.noexc4471, %do.body.i.i4466, %call3.i.i.noexc4467, %if.then.i.i4462, %invoke.cont2955, %if.end.i4425, %if.end.i4394, %invoke.cont2967, %do.body2966, %invoke.cont2957, %invoke.cont2950
  %2005 = landingpad { ptr, i32 }
          cleanup
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher2948) #26
  br label %ehcleanup2977

if.end2971:                                       ; preds = %invoke.cont2962.thread, %do.end2970, %invoke.cont2962
  %2006 = phi i32 [ %.pre6232, %invoke.cont2962.thread ], [ %2004, %do.end2970 ], [ %.pre.i4465, %invoke.cont2962 ]
  %conv2972 = sext i32 %2006 to i64
  %2007 = load i64, ptr %m_size.i.i, align 8
  %cmp3.i4475 = icmp ult i64 %2007, %conv2972
  br i1 %cmp3.i4475, label %if.end7.i4478, label %invoke.cont2973

if.end7.i4478:                                    ; preds = %if.end2971
  %call5.i4481 = invoke noundef zeroext i1 @_ZN13b3OpenCLArrayI10b3Contact4E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %contactOut, i64 noundef %conv2972, i1 noundef zeroext true)
          to label %call5.i.noexc4480 unwind label %lpad2952

call5.i.noexc4480:                                ; preds = %if.end7.i4478
  %spec.select.i4479 = select i1 %call5.i4481, i64 %conv2972, i64 0
  br label %invoke.cont2973

invoke.cont2973:                                  ; preds = %call5.i.noexc4480, %if.end2971
  %storemerge.i4476 = phi i64 [ %conv2972, %if.end2971 ], [ %spec.select.i4479, %call5.i.noexc4480 ]
  store i64 %storemerge.i4476, ptr %m_size.i.i, align 8
  call void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112) %launcher2948) #26
  br label %if.end2976

if.end2976:                                       ; preds = %invoke.cont2973, %if.end2884
  invoke void @b3LeaveProfileZone()
          to label %_ZN13b3ProfileZoneD2Ev.exit4484 unwind label %terminate.lpad.i4483

terminate.lpad.i4483:                             ; preds = %if.end2976
  %2008 = landingpad { ptr, i32 }
          catch ptr null
  %2009 = extractvalue { ptr, i32 } %2008, 0
  call void @__clang_call_terminate(ptr %2009) #27
  unreachable

_ZN13b3ProfileZoneD2Ev.exit4484:                  ; preds = %if.end2976
  invoke void @b3LeaveProfileZone()
          to label %return unwind label %terminate.lpad.i4485

terminate.lpad.i4485:                             ; preds = %_ZN13b3ProfileZoneD2Ev.exit4484
  %2010 = landingpad { ptr, i32 }
          catch ptr null
  %2011 = extractvalue { ptr, i32 } %2010, 0
  call void @__clang_call_terminate(ptr %2011) #27
  unreachable

ehcleanup2977:                                    ; preds = %lpad2952, %lpad2859, %lpad2300
  %.pn519 = phi { ptr, i32 } [ %2005, %lpad2952 ], [ %1866, %lpad2300 ], [ %1934, %lpad2859 ]
  invoke void @b3LeaveProfileZone()
          to label %ehcleanup2980 unwind label %terminate.lpad.i4487

terminate.lpad.i4487:                             ; preds = %ehcleanup2977
  %2012 = landingpad { ptr, i32 }
          catch ptr null
  %2013 = extractvalue { ptr, i32 } %2012, 0
  call void @__clang_call_terminate(ptr %2013) #27
  unreachable

return:                                           ; preds = %_ZN13b3ProfileZoneD2Ev.exit4484, %entry
  ret void

ehcleanup2980:                                    ; preds = %ehcleanup2977, %ehcleanup2124, %ehcleanup2066, %ehcleanup1935, %ehcleanup1701, %ehcleanup1615, %ehcleanup1525, %ehcleanup1322, %ehcleanup1261, %ehcleanup1189, %ehcleanup977, %ehcleanup883, %ehcleanup443, %ehcleanup378, %ehcleanup316, %ehcleanup242, %ehcleanup172, %ehcleanup2201, %ehcleanup2012, %ehcleanup1845, %ehcleanup1399, %lpad58
  %.pn521.pn.pn.pn.pn.pn.pn = phi { ptr, i32 } [ %.pn521.pn.pn, %ehcleanup2012 ], [ %171, %lpad58 ], [ %.pn510.pn.pn.pn.pn.pn, %ehcleanup2201 ], [ %.pn484.pn.pn.pn.pn.pn.pn.pn.pn.pn, %ehcleanup1845 ], [ %.pn474.pn.pn.pn.pn.pn.pn, %ehcleanup1399 ], [ %.pn460, %ehcleanup172 ], [ %.pn462, %ehcleanup242 ], [ %.pn464, %ehcleanup316 ], [ %.pn466, %ehcleanup378 ], [ %.pn458, %ehcleanup443 ], [ %.pn445.pn.pn.pn.pn.pn.pn.pn.pn.pn.pn, %ehcleanup883 ], [ %.pn468, %ehcleanup977 ], [ %.pn470, %ehcleanup1189 ], [ %.pn472, %ehcleanup1261 ], [ %.pn482, %ehcleanup1322 ], [ %.pn502, %ehcleanup1525 ], [ %.pn504, %ehcleanup1615 ], [ %.pn500, %ehcleanup1701 ], [ %.pn506, %ehcleanup1935 ], [ %.pn508, %ehcleanup2066 ], [ %.pn517, %ehcleanup2124 ], [ %.pn519, %ehcleanup2977 ]
  invoke void @b3LeaveProfileZone()
          to label %eh.resume unwind label %terminate.lpad.i4489

terminate.lpad.i4489:                             ; preds = %ehcleanup2980
  %2014 = landingpad { ptr, i32 }
          catch ptr null
  %2015 = extractvalue { ptr, i32 } %2014, 0
  call void @__clang_call_terminate(ptr %2015) #27
  unreachable

eh.resume:                                        ; preds = %ehcleanup2980, %ehcleanup
  %.pn521.pn.pn.pn.pn.pn.pn.pn = phi { ptr, i32 } [ %.pn, %ehcleanup ], [ %.pn521.pn.pn.pn.pn.pn.pn, %ehcleanup2980 ]
  resume { ptr, i32 } %.pn521.pn.pn.pn.pn.pn.pn.pn
}

declare void @_ZN12b3LauncherCLC1EP17_cl_command_queueP10_cl_kernelPKc(ptr noundef nonnull align 8 dereferenceable(112), ptr noundef, ptr noundef, ptr noundef) unnamed_addr #16

declare void @_ZN12b3LauncherCL10setBuffersEP14b3BufferInfoCLi(ptr noundef nonnull align 8 dereferenceable(112), ptr noundef, i32 noundef) local_unnamed_addr #16

; Function Attrs: nounwind
declare void @_ZN12b3LauncherCLD1Ev(ptr noundef nonnull align 8 dereferenceable(112)) unnamed_addr #18

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI6b3Int4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %destArray, i1 noundef zeroext %waitForCompletion) local_unnamed_addr #8 comdat align 2 {
entry:
  %m_size.i = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this, i64 0, i32 1
  %0 = load i64, ptr %m_size.i, align 8
  %conv = trunc i64 %0 to i32
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %destArray, i64 0, i32 2
  %1 = load i32, ptr %m_size.i.i, align 4
  %cmp4.i = icmp slt i32 %1, %conv
  br i1 %cmp4.i, label %for.body9.lr.ph.i, label %_ZN20b3AlignedObjectArrayI6b3Int4E6resizeEiRKS0_.exit

for.body9.lr.ph.i:                                ; preds = %entry
  tail call void @_ZN20b3AlignedObjectArrayI6b3Int4E7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %destArray, i32 noundef %conv)
  %m_data10.i = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %destArray, i64 0, i32 5
  %2 = sext i32 %1 to i64
  %sext = shl i64 %0, 32
  %wide.trip.count.i = ashr exact i64 %sext, 32
  br label %for.body9.i

for.body9.i:                                      ; preds = %for.body9.i, %for.body9.lr.ph.i
  %indvars.iv.i = phi i64 [ %2, %for.body9.lr.ph.i ], [ %indvars.iv.next.i, %for.body9.i ]
  %3 = load ptr, ptr %m_data10.i, align 8
  %arrayidx12.i = getelementptr inbounds %struct.b3Int4, ptr %3, i64 %indvars.iv.i
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx12.i, i8 0, i64 16, i1 false)
  %indvars.iv.next.i = add nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %_ZN20b3AlignedObjectArrayI6b3Int4E6resizeEiRKS0_.exit, label %for.body9.i, !llvm.loop !54

_ZN20b3AlignedObjectArrayI6b3Int4E6resizeEiRKS0_.exit: ; preds = %for.body9.i, %entry
  store i32 %conv, ptr %m_size.i.i, align 4
  %4 = load i64, ptr %m_size.i, align 8
  %tobool.not = icmp eq i64 %4, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %_ZN20b3AlignedObjectArrayI6b3Int4E6resizeEiRKS0_.exit
  %m_capacity.i.i = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this, i64 0, i32 2
  %5 = load i64, ptr %m_capacity.i.i, align 8
  %cmp.not.i = icmp ugt i64 %4, %5
  br i1 %cmp.not.i, label %do.body.i, label %if.then.i

if.then.i:                                        ; preds = %if.then
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %destArray, i64 0, i32 5
  %6 = load ptr, ptr %m_data.i, align 8
  %7 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %m_commandQueue.i = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this, i64 0, i32 5
  %8 = load ptr, ptr %m_commandQueue.i, align 8
  %m_clBuffer.i = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this, i64 0, i32 3
  %9 = load ptr, ptr %m_clBuffer.i, align 8
  %mul2.i = shl i64 %4, 4
  %call3.i = tail call i32 %7(ptr noundef %8, ptr noundef %9, i32 noundef 0, i64 noundef 0, i64 noundef %mul2.i, ptr noundef %6, i32 noundef 0, ptr noundef null, ptr noundef null)
  br i1 %waitForCompletion, label %if.then4.i, label %if.end

if.then4.i:                                       ; preds = %if.then.i
  %10 = load ptr, ptr @__clewFinish, align 8
  %11 = load ptr, ptr %m_commandQueue.i, align 8
  %call6.i = tail call i32 %10(ptr noundef %11)
  br label %if.end

do.body.i:                                        ; preds = %if.then
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 285)
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.80)
  br label %if.end

if.end:                                           ; preds = %do.body.i, %if.then4.i, %if.then.i, %_ZN20b3AlignedObjectArrayI6b3Int4E6resizeEiRKS0_.exit
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI15b3RigidBodyDataE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %destArray, i1 noundef zeroext %waitForCompletion) local_unnamed_addr #8 comdat align 2 {
entry:
  %m_size.i = getelementptr inbounds %class.b3OpenCLArray.72, ptr %this, i64 0, i32 1
  %0 = load i64, ptr %m_size.i, align 8
  %conv = trunc i64 %0 to i32
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %destArray, i64 0, i32 2
  %1 = load i32, ptr %m_size.i.i, align 4
  %cmp4.i = icmp slt i32 %1, %conv
  br i1 %cmp4.i, label %for.body9.lr.ph.i, label %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE6resizeEiRKS0_.exit

for.body9.lr.ph.i:                                ; preds = %entry
  tail call void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %destArray, i32 noundef %conv)
  %m_data10.i = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %destArray, i64 0, i32 5
  %2 = sext i32 %1 to i64
  %sext = shl i64 %0, 32
  %wide.trip.count.i = ashr exact i64 %sext, 32
  br label %for.body9.i

for.body9.i:                                      ; preds = %for.body9.i, %for.body9.lr.ph.i
  %indvars.iv.i = phi i64 [ %2, %for.body9.lr.ph.i ], [ %indvars.iv.next.i, %for.body9.i ]
  %3 = load ptr, ptr %m_data10.i, align 8
  %arrayidx12.i = getelementptr inbounds %struct.b3RigidBodyData, ptr %3, i64 %indvars.iv.i
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(80) %arrayidx12.i, i8 0, i64 80, i1 false)
  %indvars.iv.next.i = add nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE6resizeEiRKS0_.exit, label %for.body9.i, !llvm.loop !74

_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE6resizeEiRKS0_.exit: ; preds = %for.body9.i, %entry
  store i32 %conv, ptr %m_size.i.i, align 4
  %4 = load i64, ptr %m_size.i, align 8
  %tobool.not = icmp eq i64 %4, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE6resizeEiRKS0_.exit
  %m_capacity.i.i = getelementptr inbounds %class.b3OpenCLArray.72, ptr %this, i64 0, i32 2
  %5 = load i64, ptr %m_capacity.i.i, align 8
  %cmp.not.i = icmp ugt i64 %4, %5
  br i1 %cmp.not.i, label %do.body.i, label %if.then.i

if.then.i:                                        ; preds = %if.then
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %destArray, i64 0, i32 5
  %6 = load ptr, ptr %m_data.i, align 8
  %7 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %m_commandQueue.i = getelementptr inbounds %class.b3OpenCLArray.72, ptr %this, i64 0, i32 5
  %8 = load ptr, ptr %m_commandQueue.i, align 8
  %m_clBuffer.i = getelementptr inbounds %class.b3OpenCLArray.72, ptr %this, i64 0, i32 3
  %9 = load ptr, ptr %m_clBuffer.i, align 8
  %mul2.i = mul i64 %4, 80
  %call3.i = tail call i32 %7(ptr noundef %8, ptr noundef %9, i32 noundef 0, i64 noundef 0, i64 noundef %mul2.i, ptr noundef %6, i32 noundef 0, ptr noundef null, ptr noundef null)
  br i1 %waitForCompletion, label %if.then4.i, label %if.end

if.then4.i:                                       ; preds = %if.then.i
  %10 = load ptr, ptr @__clewFinish, align 8
  %11 = load ptr, ptr %m_commandQueue.i, align 8
  %call6.i = tail call i32 %10(ptr noundef %11)
  br label %if.end

do.body.i:                                        ; preds = %if.then
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 285)
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.80)
  br label %if.end

if.end:                                           ; preds = %do.body.i, %if.then4.i, %if.then.i, %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE6resizeEiRKS0_.exit
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI12b3CollidableE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %destArray, i1 noundef zeroext %waitForCompletion) local_unnamed_addr #8 comdat align 2 {
entry:
  %m_size.i = getelementptr inbounds %class.b3OpenCLArray.74, ptr %this, i64 0, i32 1
  %0 = load i64, ptr %m_size.i, align 8
  %conv = trunc i64 %0 to i32
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %destArray, i64 0, i32 2
  %1 = load i32, ptr %m_size.i.i, align 4
  %cmp4.i = icmp slt i32 %1, %conv
  br i1 %cmp4.i, label %for.body9.lr.ph.i, label %_ZN20b3AlignedObjectArrayI12b3CollidableE6resizeEiRKS0_.exit

for.body9.lr.ph.i:                                ; preds = %entry
  tail call void @_ZN20b3AlignedObjectArrayI12b3CollidableE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %destArray, i32 noundef %conv)
  %m_data10.i = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %destArray, i64 0, i32 5
  %2 = sext i32 %1 to i64
  %sext = shl i64 %0, 32
  %wide.trip.count.i = ashr exact i64 %sext, 32
  br label %for.body9.i

for.body9.i:                                      ; preds = %for.body9.i, %for.body9.lr.ph.i
  %indvars.iv.i = phi i64 [ %2, %for.body9.lr.ph.i ], [ %indvars.iv.next.i, %for.body9.i ]
  %3 = load ptr, ptr %m_data10.i, align 8
  %arrayidx12.i = getelementptr inbounds %struct.b3Collidable, ptr %3, i64 %indvars.iv.i
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 4 dereferenceable(16) %arrayidx12.i, i8 0, i64 16, i1 false)
  %indvars.iv.next.i = add nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %_ZN20b3AlignedObjectArrayI12b3CollidableE6resizeEiRKS0_.exit, label %for.body9.i, !llvm.loop !75

_ZN20b3AlignedObjectArrayI12b3CollidableE6resizeEiRKS0_.exit: ; preds = %for.body9.i, %entry
  store i32 %conv, ptr %m_size.i.i, align 4
  %4 = load i64, ptr %m_size.i, align 8
  %tobool.not = icmp eq i64 %4, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %_ZN20b3AlignedObjectArrayI12b3CollidableE6resizeEiRKS0_.exit
  %m_capacity.i.i = getelementptr inbounds %class.b3OpenCLArray.74, ptr %this, i64 0, i32 2
  %5 = load i64, ptr %m_capacity.i.i, align 8
  %cmp.not.i = icmp ugt i64 %4, %5
  br i1 %cmp.not.i, label %do.body.i, label %if.then.i

if.then.i:                                        ; preds = %if.then
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %destArray, i64 0, i32 5
  %6 = load ptr, ptr %m_data.i, align 8
  %7 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %m_commandQueue.i = getelementptr inbounds %class.b3OpenCLArray.74, ptr %this, i64 0, i32 5
  %8 = load ptr, ptr %m_commandQueue.i, align 8
  %m_clBuffer.i = getelementptr inbounds %class.b3OpenCLArray.74, ptr %this, i64 0, i32 3
  %9 = load ptr, ptr %m_clBuffer.i, align 8
  %mul2.i = shl i64 %4, 4
  %call3.i = tail call i32 %7(ptr noundef %8, ptr noundef %9, i32 noundef 0, i64 noundef 0, i64 noundef %mul2.i, ptr noundef %6, i32 noundef 0, ptr noundef null, ptr noundef null)
  br i1 %waitForCompletion, label %if.then4.i, label %if.end

if.then4.i:                                       ; preds = %if.then.i
  %10 = load ptr, ptr @__clewFinish, align 8
  %11 = load ptr, ptr %m_commandQueue.i, align 8
  %call6.i = tail call i32 %10(ptr noundef %11)
  br label %if.end

do.body.i:                                        ; preds = %if.then
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 285)
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.80)
  br label %if.end

if.end:                                           ; preds = %do.body.i, %if.then4.i, %if.then.i, %_ZN20b3AlignedObjectArrayI12b3CollidableE6resizeEiRKS0_.exit
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI15b3GpuChildShapeE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %destArray, i1 noundef zeroext %waitForCompletion) local_unnamed_addr #8 comdat align 2 {
entry:
  %m_size.i = getelementptr inbounds %class.b3OpenCLArray.96, ptr %this, i64 0, i32 1
  %0 = load i64, ptr %m_size.i, align 8
  %conv = trunc i64 %0 to i32
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %destArray, i64 0, i32 2
  %1 = load i32, ptr %m_size.i.i, align 4
  %cmp4.i = icmp slt i32 %1, %conv
  br i1 %cmp4.i, label %for.body9.lr.ph.i, label %_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE6resizeEiRKS0_.exit

for.body9.lr.ph.i:                                ; preds = %entry
  tail call void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %destArray, i32 noundef %conv)
  %m_data10.i = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %destArray, i64 0, i32 5
  %2 = sext i32 %1 to i64
  %sext = shl i64 %0, 32
  %wide.trip.count.i = ashr exact i64 %sext, 32
  br label %for.body9.i

for.body9.i:                                      ; preds = %for.body9.i, %for.body9.lr.ph.i
  %indvars.iv.i = phi i64 [ %2, %for.body9.lr.ph.i ], [ %indvars.iv.next.i, %for.body9.i ]
  %3 = load ptr, ptr %m_data10.i, align 8
  %arrayidx12.i = getelementptr inbounds %struct.b3GpuChildShape, ptr %3, i64 %indvars.iv.i
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(48) %arrayidx12.i, i8 0, i64 48, i1 false)
  %indvars.iv.next.i = add nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE6resizeEiRKS0_.exit, label %for.body9.i, !llvm.loop !76

_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE6resizeEiRKS0_.exit: ; preds = %for.body9.i, %entry
  store i32 %conv, ptr %m_size.i.i, align 4
  %4 = load i64, ptr %m_size.i, align 8
  %tobool.not = icmp eq i64 %4, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE6resizeEiRKS0_.exit
  %m_capacity.i.i = getelementptr inbounds %class.b3OpenCLArray.96, ptr %this, i64 0, i32 2
  %5 = load i64, ptr %m_capacity.i.i, align 8
  %cmp.not.i = icmp ugt i64 %4, %5
  br i1 %cmp.not.i, label %do.body.i, label %if.then.i

if.then.i:                                        ; preds = %if.then
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %destArray, i64 0, i32 5
  %6 = load ptr, ptr %m_data.i, align 8
  %7 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %m_commandQueue.i = getelementptr inbounds %class.b3OpenCLArray.96, ptr %this, i64 0, i32 5
  %8 = load ptr, ptr %m_commandQueue.i, align 8
  %m_clBuffer.i = getelementptr inbounds %class.b3OpenCLArray.96, ptr %this, i64 0, i32 3
  %9 = load ptr, ptr %m_clBuffer.i, align 8
  %mul2.i = mul i64 %4, 48
  %call3.i = tail call i32 %7(ptr noundef %8, ptr noundef %9, i32 noundef 0, i64 noundef 0, i64 noundef %mul2.i, ptr noundef %6, i32 noundef 0, ptr noundef null, ptr noundef null)
  br i1 %waitForCompletion, label %if.then4.i, label %if.end

if.then4.i:                                       ; preds = %if.then.i
  %10 = load ptr, ptr @__clewFinish, align 8
  %11 = load ptr, ptr %m_commandQueue.i, align 8
  %call6.i = tail call i32 %10(ptr noundef %11)
  br label %if.end

do.body.i:                                        ; preds = %if.then
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 285)
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.80)
  br label %if.end

if.end:                                           ; preds = %do.body.i, %if.then4.i, %if.then.i, %_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE6resizeEiRKS0_.exit
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI22b3ConvexPolyhedronDataE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %destArray, i1 noundef zeroext %waitForCompletion) local_unnamed_addr #8 comdat align 2 {
entry:
  %m_size.i = getelementptr inbounds %class.b3OpenCLArray.76, ptr %this, i64 0, i32 1
  %0 = load i64, ptr %m_size.i, align 8
  %conv = trunc i64 %0 to i32
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %destArray, i64 0, i32 2
  %1 = load i32, ptr %m_size.i.i, align 4
  %cmp4.i = icmp slt i32 %1, %conv
  br i1 %cmp4.i, label %for.body9.lr.ph.i, label %_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE6resizeEiRKS0_.exit

for.body9.lr.ph.i:                                ; preds = %entry
  tail call void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %destArray, i32 noundef %conv)
  %m_data10.i = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %destArray, i64 0, i32 5
  %2 = sext i32 %1 to i64
  %sext = shl i64 %0, 32
  %wide.trip.count.i = ashr exact i64 %sext, 32
  br label %for.body9.i

for.body9.i:                                      ; preds = %for.body9.i, %for.body9.lr.ph.i
  %indvars.iv.i = phi i64 [ %2, %for.body9.lr.ph.i ], [ %indvars.iv.next.i, %for.body9.i ]
  %3 = load ptr, ptr %m_data10.i, align 8
  %arrayidx12.i = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %3, i64 %indvars.iv.i
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(96) %arrayidx12.i, i8 0, i64 96, i1 false)
  %indvars.iv.next.i = add nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE6resizeEiRKS0_.exit, label %for.body9.i, !llvm.loop !77

_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE6resizeEiRKS0_.exit: ; preds = %for.body9.i, %entry
  store i32 %conv, ptr %m_size.i.i, align 4
  %4 = load i64, ptr %m_size.i, align 8
  %tobool.not = icmp eq i64 %4, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE6resizeEiRKS0_.exit
  %m_capacity.i.i = getelementptr inbounds %class.b3OpenCLArray.76, ptr %this, i64 0, i32 2
  %5 = load i64, ptr %m_capacity.i.i, align 8
  %cmp.not.i = icmp ugt i64 %4, %5
  br i1 %cmp.not.i, label %do.body.i, label %if.then.i

if.then.i:                                        ; preds = %if.then
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %destArray, i64 0, i32 5
  %6 = load ptr, ptr %m_data.i, align 8
  %7 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %m_commandQueue.i = getelementptr inbounds %class.b3OpenCLArray.76, ptr %this, i64 0, i32 5
  %8 = load ptr, ptr %m_commandQueue.i, align 8
  %m_clBuffer.i = getelementptr inbounds %class.b3OpenCLArray.76, ptr %this, i64 0, i32 3
  %9 = load ptr, ptr %m_clBuffer.i, align 8
  %mul2.i = mul i64 %4, 96
  %call3.i = tail call i32 %7(ptr noundef %8, ptr noundef %9, i32 noundef 0, i64 noundef 0, i64 noundef %mul2.i, ptr noundef %6, i32 noundef 0, ptr noundef null, ptr noundef null)
  br i1 %waitForCompletion, label %if.then4.i, label %if.end

if.then4.i:                                       ; preds = %if.then.i
  %10 = load ptr, ptr @__clewFinish, align 8
  %11 = load ptr, ptr %m_commandQueue.i, align 8
  %call6.i = tail call i32 %10(ptr noundef %11)
  br label %if.end

do.body.i:                                        ; preds = %if.then
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 285)
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.80)
  br label %if.end

if.end:                                           ; preds = %do.body.i, %if.then4.i, %if.then.i, %_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE6resizeEiRKS0_.exit
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI9b3Vector3E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %destArray, i1 noundef zeroext %waitForCompletion) local_unnamed_addr #8 comdat align 2 {
entry:
  %m_size.i = getelementptr inbounds %class.b3OpenCLArray, ptr %this, i64 0, i32 1
  %0 = load i64, ptr %m_size.i, align 8
  %conv = trunc i64 %0 to i32
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray, ptr %destArray, i64 0, i32 2
  %1 = load i32, ptr %m_size.i.i, align 4
  %cmp4.i = icmp slt i32 %1, %conv
  br i1 %cmp4.i, label %for.body9.lr.ph.i, label %_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_.exit

for.body9.lr.ph.i:                                ; preds = %entry
  tail call void @_ZN20b3AlignedObjectArrayI9b3Vector3E7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %destArray, i32 noundef %conv)
  %m_data10.i = getelementptr inbounds %class.b3AlignedObjectArray, ptr %destArray, i64 0, i32 5
  %2 = sext i32 %1 to i64
  %sext = shl i64 %0, 32
  %wide.trip.count.i = ashr exact i64 %sext, 32
  br label %for.body9.i

for.body9.i:                                      ; preds = %for.body9.i, %for.body9.lr.ph.i
  %indvars.iv.i = phi i64 [ %2, %for.body9.lr.ph.i ], [ %indvars.iv.next.i, %for.body9.i ]
  %3 = load ptr, ptr %m_data10.i, align 8
  %arrayidx12.i = getelementptr inbounds %class.b3Vector3, ptr %3, i64 %indvars.iv.i
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx12.i, i8 0, i64 16, i1 false)
  %indvars.iv.next.i = add nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_.exit, label %for.body9.i, !llvm.loop !55

_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_.exit: ; preds = %for.body9.i, %entry
  store i32 %conv, ptr %m_size.i.i, align 4
  %4 = load i64, ptr %m_size.i, align 8
  %tobool.not = icmp eq i64 %4, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_.exit
  %m_capacity.i.i = getelementptr inbounds %class.b3OpenCLArray, ptr %this, i64 0, i32 2
  %5 = load i64, ptr %m_capacity.i.i, align 8
  %cmp.not.i = icmp ugt i64 %4, %5
  br i1 %cmp.not.i, label %do.body.i, label %if.then.i

if.then.i:                                        ; preds = %if.then
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray, ptr %destArray, i64 0, i32 5
  %6 = load ptr, ptr %m_data.i, align 8
  %7 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %m_commandQueue.i = getelementptr inbounds %class.b3OpenCLArray, ptr %this, i64 0, i32 5
  %8 = load ptr, ptr %m_commandQueue.i, align 8
  %m_clBuffer.i = getelementptr inbounds %class.b3OpenCLArray, ptr %this, i64 0, i32 3
  %9 = load ptr, ptr %m_clBuffer.i, align 8
  %mul2.i = shl i64 %4, 4
  %call3.i = tail call i32 %7(ptr noundef %8, ptr noundef %9, i32 noundef 0, i64 noundef 0, i64 noundef %mul2.i, ptr noundef %6, i32 noundef 0, ptr noundef null, ptr noundef null)
  br i1 %waitForCompletion, label %if.then4.i, label %if.end

if.then4.i:                                       ; preds = %if.then.i
  %10 = load ptr, ptr @__clewFinish, align 8
  %11 = load ptr, ptr %m_commandQueue.i, align 8
  %call6.i = tail call i32 %10(ptr noundef %11)
  br label %if.end

do.body.i:                                        ; preds = %if.then
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 285)
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.80)
  br label %if.end

if.end:                                           ; preds = %do.body.i, %if.then4.i, %if.then.i, %_ZN20b3AlignedObjectArrayI9b3Vector3E6resizeEiRKS0_.exit
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI9b3GpuFaceE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %destArray, i1 noundef zeroext %waitForCompletion) local_unnamed_addr #8 comdat align 2 {
entry:
  %m_size.i = getelementptr inbounds %class.b3OpenCLArray.78, ptr %this, i64 0, i32 1
  %0 = load i64, ptr %m_size.i, align 8
  %conv = trunc i64 %0 to i32
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %destArray, i64 0, i32 2
  %1 = load i32, ptr %m_size.i.i, align 4
  %cmp4.i = icmp slt i32 %1, %conv
  br i1 %cmp4.i, label %for.body9.lr.ph.i, label %_ZN20b3AlignedObjectArrayI9b3GpuFaceE6resizeEiRKS0_.exit

for.body9.lr.ph.i:                                ; preds = %entry
  tail call void @_ZN20b3AlignedObjectArrayI9b3GpuFaceE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %destArray, i32 noundef %conv)
  %m_data10.i = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %destArray, i64 0, i32 5
  %2 = sext i32 %1 to i64
  %sext = shl i64 %0, 32
  %wide.trip.count.i = ashr exact i64 %sext, 32
  br label %for.body9.i

for.body9.i:                                      ; preds = %for.body9.i, %for.body9.lr.ph.i
  %indvars.iv.i = phi i64 [ %2, %for.body9.lr.ph.i ], [ %indvars.iv.next.i, %for.body9.i ]
  %3 = load ptr, ptr %m_data10.i, align 8
  %arrayidx12.i = getelementptr inbounds %struct.b3GpuFace, ptr %3, i64 %indvars.iv.i
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx12.i, i8 0, i64 32, i1 false)
  %indvars.iv.next.i = add nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %_ZN20b3AlignedObjectArrayI9b3GpuFaceE6resizeEiRKS0_.exit, label %for.body9.i, !llvm.loop !78

_ZN20b3AlignedObjectArrayI9b3GpuFaceE6resizeEiRKS0_.exit: ; preds = %for.body9.i, %entry
  store i32 %conv, ptr %m_size.i.i, align 4
  %4 = load i64, ptr %m_size.i, align 8
  %tobool.not = icmp eq i64 %4, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %_ZN20b3AlignedObjectArrayI9b3GpuFaceE6resizeEiRKS0_.exit
  %m_capacity.i.i = getelementptr inbounds %class.b3OpenCLArray.78, ptr %this, i64 0, i32 2
  %5 = load i64, ptr %m_capacity.i.i, align 8
  %cmp.not.i = icmp ugt i64 %4, %5
  br i1 %cmp.not.i, label %do.body.i, label %if.then.i

if.then.i:                                        ; preds = %if.then
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %destArray, i64 0, i32 5
  %6 = load ptr, ptr %m_data.i, align 8
  %7 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %m_commandQueue.i = getelementptr inbounds %class.b3OpenCLArray.78, ptr %this, i64 0, i32 5
  %8 = load ptr, ptr %m_commandQueue.i, align 8
  %m_clBuffer.i = getelementptr inbounds %class.b3OpenCLArray.78, ptr %this, i64 0, i32 3
  %9 = load ptr, ptr %m_clBuffer.i, align 8
  %mul2.i = shl i64 %4, 5
  %call3.i = tail call i32 %7(ptr noundef %8, ptr noundef %9, i32 noundef 0, i64 noundef 0, i64 noundef %mul2.i, ptr noundef %6, i32 noundef 0, ptr noundef null, ptr noundef null)
  br i1 %waitForCompletion, label %if.then4.i, label %if.end

if.then4.i:                                       ; preds = %if.then.i
  %10 = load ptr, ptr @__clewFinish, align 8
  %11 = load ptr, ptr %m_commandQueue.i, align 8
  %call6.i = tail call i32 %10(ptr noundef %11)
  br label %if.end

do.body.i:                                        ; preds = %if.then
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 285)
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.80)
  br label %if.end

if.end:                                           ; preds = %do.body.i, %if.then4.i, %if.then.i, %_ZN20b3AlignedObjectArrayI9b3GpuFaceE6resizeEiRKS0_.exit
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayIiE10copyToHostER20b3AlignedObjectArrayIiEb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %destArray, i1 noundef zeroext %waitForCompletion) local_unnamed_addr #8 comdat align 2 {
entry:
  %m_size.i = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this, i64 0, i32 1
  %0 = load i64, ptr %m_size.i, align 8
  %conv = trunc i64 %0 to i32
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %destArray, i64 0, i32 2
  %1 = load i32, ptr %m_size.i.i, align 4
  %cmp4.i = icmp slt i32 %1, %conv
  br i1 %cmp4.i, label %for.body9.lr.ph.i, label %_ZN20b3AlignedObjectArrayIiE6resizeEiRKi.exit

for.body9.lr.ph.i:                                ; preds = %entry
  tail call void @_ZN20b3AlignedObjectArrayIiE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %destArray, i32 noundef %conv)
  %m_data10.i = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %destArray, i64 0, i32 5
  %2 = sext i32 %1 to i64
  %sext = shl i64 %0, 32
  %wide.trip.count.i = ashr exact i64 %sext, 32
  br label %for.body9.i

for.body9.i:                                      ; preds = %for.body9.i, %for.body9.lr.ph.i
  %indvars.iv.i = phi i64 [ %2, %for.body9.lr.ph.i ], [ %indvars.iv.next.i, %for.body9.i ]
  %3 = load ptr, ptr %m_data10.i, align 8
  %arrayidx12.i = getelementptr inbounds i32, ptr %3, i64 %indvars.iv.i
  store i32 0, ptr %arrayidx12.i, align 4
  %indvars.iv.next.i = add nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %_ZN20b3AlignedObjectArrayIiE6resizeEiRKi.exit, label %for.body9.i, !llvm.loop !56

_ZN20b3AlignedObjectArrayIiE6resizeEiRKi.exit:    ; preds = %for.body9.i, %entry
  store i32 %conv, ptr %m_size.i.i, align 4
  %4 = load i64, ptr %m_size.i, align 8
  %tobool.not = icmp eq i64 %4, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %_ZN20b3AlignedObjectArrayIiE6resizeEiRKi.exit
  %m_capacity.i.i = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this, i64 0, i32 2
  %5 = load i64, ptr %m_capacity.i.i, align 8
  %cmp.not.i = icmp ugt i64 %4, %5
  br i1 %cmp.not.i, label %do.body.i, label %if.then.i

if.then.i:                                        ; preds = %if.then
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %destArray, i64 0, i32 5
  %6 = load ptr, ptr %m_data.i, align 8
  %7 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %m_commandQueue.i = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this, i64 0, i32 5
  %8 = load ptr, ptr %m_commandQueue.i, align 8
  %m_clBuffer.i = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this, i64 0, i32 3
  %9 = load ptr, ptr %m_clBuffer.i, align 8
  %mul2.i = shl i64 %4, 2
  %call3.i = tail call i32 %7(ptr noundef %8, ptr noundef %9, i32 noundef 0, i64 noundef 0, i64 noundef %mul2.i, ptr noundef %6, i32 noundef 0, ptr noundef null, ptr noundef null)
  br i1 %waitForCompletion, label %if.then4.i, label %if.end

if.then4.i:                                       ; preds = %if.then.i
  %10 = load ptr, ptr @__clewFinish, align 8
  %11 = load ptr, ptr %m_commandQueue.i, align 8
  %call6.i = tail call i32 %10(ptr noundef %11)
  br label %if.end

do.body.i:                                        ; preds = %if.then
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 285)
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.80)
  br label %if.end

if.end:                                           ; preds = %do.body.i, %if.then4.i, %if.then.i, %_ZN20b3AlignedObjectArrayIiE6resizeEiRKi.exit
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI10b3Contact4E10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %destArray, i1 noundef zeroext %waitForCompletion) local_unnamed_addr #8 comdat align 2 {
entry:
  %m_size.i = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this, i64 0, i32 1
  %0 = load i64, ptr %m_size.i, align 8
  %conv = trunc i64 %0 to i32
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %destArray, i64 0, i32 2
  %1 = load i32, ptr %m_size.i.i, align 4
  %cmp4.i = icmp slt i32 %1, %conv
  br i1 %cmp4.i, label %for.body9.lr.ph.i, label %_ZN20b3AlignedObjectArrayI10b3Contact4E6resizeEiRKS0_.exit

for.body9.lr.ph.i:                                ; preds = %entry
  tail call void @_ZN20b3AlignedObjectArrayI10b3Contact4E7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %destArray, i32 noundef %conv)
  %m_data10.i = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %destArray, i64 0, i32 5
  %2 = sext i32 %1 to i64
  %sext = shl i64 %0, 32
  %wide.trip.count.i = ashr exact i64 %sext, 32
  br label %for.body9.i

for.body9.i:                                      ; preds = %for.body9.i, %for.body9.lr.ph.i
  %indvars.iv.i = phi i64 [ %2, %for.body9.lr.ph.i ], [ %indvars.iv.next.i, %for.body9.i ]
  %3 = load ptr, ptr %m_data10.i, align 8
  %arrayidx12.i = getelementptr inbounds %struct.b3Contact4, ptr %3, i64 %indvars.iv.i
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(112) %arrayidx12.i, i8 0, i64 112, i1 false)
  %indvars.iv.next.i = add nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %_ZN20b3AlignedObjectArrayI10b3Contact4E6resizeEiRKS0_.exit, label %for.body9.i, !llvm.loop !66

_ZN20b3AlignedObjectArrayI10b3Contact4E6resizeEiRKS0_.exit: ; preds = %for.body9.i, %entry
  store i32 %conv, ptr %m_size.i.i, align 4
  %4 = load i64, ptr %m_size.i, align 8
  %tobool.not = icmp eq i64 %4, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %_ZN20b3AlignedObjectArrayI10b3Contact4E6resizeEiRKS0_.exit
  %m_capacity.i.i = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this, i64 0, i32 2
  %5 = load i64, ptr %m_capacity.i.i, align 8
  %cmp.not.i = icmp ugt i64 %4, %5
  br i1 %cmp.not.i, label %do.body.i, label %if.then.i

if.then.i:                                        ; preds = %if.then
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %destArray, i64 0, i32 5
  %6 = load ptr, ptr %m_data.i, align 8
  %7 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %m_commandQueue.i = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this, i64 0, i32 5
  %8 = load ptr, ptr %m_commandQueue.i, align 8
  %m_clBuffer.i = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this, i64 0, i32 3
  %9 = load ptr, ptr %m_clBuffer.i, align 8
  %mul2.i = mul i64 %4, 112
  %call3.i = tail call i32 %7(ptr noundef %8, ptr noundef %9, i32 noundef 0, i64 noundef 0, i64 noundef %mul2.i, ptr noundef %6, i32 noundef 0, ptr noundef null, ptr noundef null)
  br i1 %waitForCompletion, label %if.then4.i, label %if.end

if.then4.i:                                       ; preds = %if.then.i
  %10 = load ptr, ptr @__clewFinish, align 8
  %11 = load ptr, ptr %m_commandQueue.i, align 8
  %call6.i = tail call i32 %10(ptr noundef %11)
  br label %if.end

do.body.i:                                        ; preds = %if.then
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 285)
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.80)
  br label %if.end

if.end:                                           ; preds = %do.body.i, %if.then4.i, %if.then.i, %_ZN20b3AlignedObjectArrayI10b3Contact4E6resizeEiRKS0_.exit
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i32 @_Z16b3MprPenetrationiiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_PiPfSB_SB_(i32 noundef %pairIndex, i32 noundef %bodyIndexA, i32 noundef %bodyIndexB, ptr noundef %cpuBodyBuf, ptr noundef %cpuConvexData, ptr noundef %cpuCollidables, ptr noundef %cpuVertices, ptr noundef %sepAxis, ptr noundef %hasSepAxis, ptr noundef %depthOut, ptr noundef %dirOut, ptr noundef %posOut) local_unnamed_addr #5 comdat {
entry:
  %b.i.i = alloca [4 x float], align 16
  %dir.i.i60 = alloca %class.b3Vector3, align 16
  %v4.i61 = alloca %struct._b3MprSupport_t, align 16
  %zero.i = alloca %class.b3Vector3, align 16
  %dir.i.i33 = alloca %class.b3Vector3, align 16
  %v4.i = alloca %struct._b3MprSupport_t, align 16
  %dir.i239.i = alloca %class.b3Vector3, align 16
  %supp.i.i = alloca %struct._b3MprSupport_t, align 16
  %dir.i150.i = alloca %class.b3Vector3, align 16
  %dir.i.i = alloca %class.b3Vector3, align 16
  %portal = alloca %struct._b3MprSimplex_t, align 16
  %idxprom = sext i32 %pairIndex to i64
  %arrayidx = getelementptr inbounds i32, ptr %hasSepAxis, i64 %idxprom
  store i32 0, ptr %arrayidx, align 4
  %idxprom.i.i = sext i32 %bodyIndexA to i64
  %arrayidx.i.i = getelementptr inbounds %struct.b3RigidBodyData, ptr %cpuBodyBuf, i64 %idxprom.i.i
  %v1.i.i = getelementptr inbounds %struct._b3MprSupport_t, ptr %portal, i64 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %v1.i.i, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx.i.i, i64 16, i1 false)
  %idxprom1.i.i = sext i32 %bodyIndexB to i64
  %arrayidx2.i.i = getelementptr inbounds %struct.b3RigidBodyData, ptr %cpuBodyBuf, i64 %idxprom1.i.i
  %v2.i.i = getelementptr inbounds %struct._b3MprSupport_t, ptr %portal, i64 0, i32 2
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %v2.i.i, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx2.i.i, i64 16, i1 false)
  %0 = load <2 x float>, ptr %v1.i.i, align 16
  %1 = load <2 x float>, ptr %v2.i.i, align 16
  %2 = fsub <2 x float> %0, %1
  %arrayidx5.i.i.i = getelementptr inbounds %struct._b3MprSupport_t, ptr %portal, i64 0, i32 1, i32 0, i32 0, i64 2
  %3 = load float, ptr %arrayidx5.i.i.i, align 8
  %arrayidx6.i.i.i = getelementptr inbounds %struct._b3MprSupport_t, ptr %portal, i64 0, i32 2, i32 0, i32 0, i64 2
  %4 = load float, ptr %arrayidx6.i.i.i, align 8
  %sub7.i.i.i = fsub float %3, %4
  %retval.sroa.3.12.vec.insert.i.i.i.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %sub7.i.i.i, i64 0
  store <2 x float> %2, ptr %portal, align 16
  %ref.tmp.sroa.2.0.v.sroa_idx.i.i = getelementptr inbounds i8, ptr %portal, i64 8
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i.i.i, ptr %ref.tmp.sroa.2.0.v.sroa_idx.i.i, align 8
  %last.i.i = getelementptr inbounds %struct._b3MprSimplex_t, ptr %portal, i64 0, i32 1
  store i32 0, ptr %last.i.i, align 16
  %5 = extractelement <2 x float> %2, i64 0
  %6 = tail call noundef float @llvm.fabs.f32(float %5)
  %cmp.i.i.i = fcmp uge float %6, 0x3E80000000000000
  %mul7.i.i.i = fmul float %6, 0x3E80000000000000
  %cmp8.i.i.i = fcmp uge float %6, %mul7.i.i.i
  %or.cond171.i = and i1 %cmp.i.i.i, %cmp8.i.i.i
  br i1 %or.cond171.i, label %if.end.i, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %entry
  %7 = extractelement <2 x float> %2, i64 1
  %8 = tail call noundef float @llvm.fabs.f32(float %7)
  %cmp.i6.i.i = fcmp uge float %8, 0x3E80000000000000
  %mul7.i10.i.i = fmul float %8, 0x3E80000000000000
  %cmp8.i11.i.i = fcmp uge float %8, %mul7.i10.i.i
  %or.cond172.i = and i1 %cmp.i6.i.i, %cmp8.i11.i.i
  br i1 %or.cond172.i, label %if.end.i, label %land.rhs.i.i

land.rhs.i.i:                                     ; preds = %land.lhs.true.i.i
  %9 = tail call noundef float @llvm.fabs.f32(float %sub7.i.i.i)
  %cmp.i19.i.i = fcmp uge float %9, 0x3E80000000000000
  %mul7.i23.i.i = fmul float %9, 0x3E80000000000000
  %cmp8.i24.i.i = fcmp uge float %9, %mul7.i23.i.i
  %or.cond175.i = and i1 %cmp.i19.i.i, %cmp8.i24.i.i
  br i1 %or.cond175.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %land.rhs.i.i
  %10 = fadd <2 x float> %2, <float 0x3EB4000000000000, float 0.000000e+00>
  store <2 x float> %10, ptr %portal, align 16
  %add5.i.i = fadd float %sub7.i.i.i, 0.000000e+00
  store float %add5.i.i, ptr %ref.tmp.sroa.2.0.v.sroa_idx.i.i, align 8
  %dir.sroa.47.0.copyload.pre.i = load <2 x float>, ptr %ref.tmp.sroa.2.0.v.sroa_idx.i.i, align 8
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %land.rhs.i.i, %land.lhs.true.i.i, %entry
  %dir.sroa.47.0.copyload.i = phi <2 x float> [ %retval.sroa.3.12.vec.insert.i.i.i.i, %land.rhs.i.i ], [ %retval.sroa.3.12.vec.insert.i.i.i.i, %land.lhs.true.i.i ], [ %retval.sroa.3.12.vec.insert.i.i.i.i, %entry ], [ %dir.sroa.47.0.copyload.pre.i, %if.then.i ]
  %dir.sroa.0.0.copyload.i = phi <2 x float> [ %2, %land.rhs.i.i ], [ %2, %land.lhs.true.i.i ], [ %2, %entry ], [ %10, %if.then.i ]
  %dir.sroa.47.8.vec.extract.i = extractelement <2 x float> %dir.sroa.47.0.copyload.i, i64 0
  %mul5.i.i.i = fneg float %dir.sroa.47.8.vec.extract.i
  %11 = fmul <2 x float> %dir.sroa.0.0.copyload.i, %dir.sroa.0.0.copyload.i
  %mul5.i.i.i.i.i.i = extractelement <2 x float> %11, i64 1
  %12 = extractelement <2 x float> %dir.sroa.0.0.copyload.i, i64 0
  %13 = tail call float @llvm.fmuladd.f32(float %12, float %12, float %mul5.i.i.i.i.i.i)
  %14 = tail call noundef float @llvm.fmuladd.f32(float %dir.sroa.47.8.vec.extract.i, float %dir.sroa.47.8.vec.extract.i, float %13)
  %sqrt.i.i = tail call float @llvm.sqrt.f32(float %14)
  %div.i.i = fdiv float 1.000000e+00, %sqrt.i.i
  %15 = fneg <2 x float> %dir.sroa.0.0.copyload.i
  %16 = insertelement <2 x float> poison, float %div.i.i, i64 0
  %17 = shufflevector <2 x float> %16, <2 x float> poison, <2 x i32> zeroinitializer
  %18 = fmul <2 x float> %17, %15
  %mul5.i.i.i.i = fmul float %div.i.i, %mul5.i.i.i
  %dir.sroa.47.8.vec.insert124.i = insertelement <2 x float> %dir.sroa.47.0.copyload.i, float %mul5.i.i.i.i, i64 0
  %arrayidx.i78.i = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %portal, i64 0, i64 1
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %dir.i.i)
  store <2 x float> %18, ptr %dir.i.i, align 16
  %dir.sroa.47.0.dir.i.sroa_idx.i = getelementptr inbounds i8, ptr %dir.i.i, i64 8
  store <2 x float> %dir.sroa.47.8.vec.insert124.i, ptr %dir.sroa.47.0.dir.i.sroa_idx.i, align 8
  %v1.i79.i = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %portal, i64 0, i64 1, i32 1
  call fastcc void @_ZL18b3MprConvexSupportiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_SA_SB_i(i32 noundef %bodyIndexA, ptr noundef nonnull %cpuBodyBuf, ptr noundef %cpuConvexData, ptr noundef %cpuCollidables, ptr noundef %cpuVertices, ptr noundef nonnull %dir.i.i, ptr noundef nonnull %v1.i79.i)
  %19 = fneg <2 x float> %18
  %mul4.i.i.i = fneg float %mul5.i.i.i.i
  %retval.sroa.3.12.vec.insert.i.i.i84.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %mul4.i.i.i, i64 0
  store <2 x float> %19, ptr %dir.i.i, align 16
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i.i84.i, ptr %dir.sroa.47.0.dir.i.sroa_idx.i, align 8
  %v2.i85.i = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %portal, i64 0, i64 1, i32 2
  call fastcc void @_ZL18b3MprConvexSupportiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_SA_SB_i(i32 noundef %bodyIndexB, ptr noundef nonnull %cpuBodyBuf, ptr noundef %cpuConvexData, ptr noundef %cpuCollidables, ptr noundef %cpuVertices, ptr noundef nonnull %dir.i.i, ptr noundef nonnull %v2.i85.i)
  %20 = load float, ptr %v1.i79.i, align 16
  %arrayidx2.i.i87.i = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %portal, i64 0, i64 1, i32 1, i32 0, i32 0, i64 1
  %21 = load float, ptr %arrayidx2.i.i87.i, align 4
  %22 = load <2 x float>, ptr %v2.i85.i, align 16
  %23 = extractelement <2 x float> %22, i64 1
  %sub4.i.i88.i = fsub float %21, %23
  %arrayidx5.i.i89.i = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %portal, i64 0, i64 1, i32 1, i32 0, i32 0, i64 2
  %24 = load <4 x float>, ptr %arrayidx5.i.i89.i, align 8
  %25 = shufflevector <4 x float> %24, <4 x float> poison, <2 x i32> <i32 0, i32 poison>
  %arrayidx6.i.i90.i = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %portal, i64 0, i64 1, i32 2, i32 0, i32 0, i64 2
  %26 = load float, ptr %arrayidx6.i.i90.i, align 8
  %27 = insertelement <2 x float> %25, float %20, i64 1
  %28 = insertelement <2 x float> poison, float %26, i64 0
  %29 = shufflevector <2 x float> %28, <2 x float> %22, <2 x i32> <i32 0, i32 2>
  %30 = fsub <2 x float> %27, %29
  %31 = shufflevector <2 x float> %30, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %retval.sroa.0.4.vec.insert.i.i14.i.i = insertelement <2 x float> %31, float %sub4.i.i88.i, i64 1
  %32 = insertelement <2 x float> %30, float 0.000000e+00, i64 1
  store <2 x float> %retval.sroa.0.4.vec.insert.i.i14.i.i, ptr %arrayidx.i78.i, align 16
  %ref.tmp3.sroa.2.0.v.sroa_idx.i.i = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %portal, i64 0, i64 1, i32 0, i32 0, i32 0, i64 2
  store <2 x float> %32, ptr %ref.tmp3.sroa.2.0.v.sroa_idx.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %dir.i.i)
  %arrayidx3.i.i.i.i = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %portal, i64 0, i64 1, i32 0, i32 0, i32 0, i64 1
  %33 = extractelement <2 x float> %18, i64 1
  %mul5.i.i.i94.i = fmul float %33, %sub4.i.i88.i
  %34 = extractelement <2 x float> %30, i64 1
  %35 = extractelement <2 x float> %18, i64 0
  %36 = tail call float @llvm.fmuladd.f32(float %34, float %35, float %mul5.i.i.i94.i)
  %37 = extractelement <2 x float> %30, i64 0
  %38 = tail call noundef float @llvm.fmuladd.f32(float %37, float %mul5.i.i.i.i, float %36)
  %39 = tail call noundef float @llvm.fabs.f32(float %38)
  %cmp.i.i = fcmp olt float %39, 0x3E80000000000000
  %cmp.i = fcmp olt float %38, 0.000000e+00
  %or.cond.i = or i1 %cmp.i, %cmp.i.i
  br i1 %or.cond.i, label %sw.default, label %if.end16.i

if.end16.i:                                       ; preds = %if.end.i
  %arrayidx.i.i.i.i = getelementptr inbounds [4 x float], ptr %portal, i64 0, i64 1
  %40 = load float, ptr %portal, align 16
  %41 = load <2 x float>, ptr %arrayidx.i.i.i.i, align 4
  %42 = insertelement <2 x float> %41, float %40, i64 0
  %43 = fneg <2 x float> %42
  %44 = insertelement <2 x float> %30, float %sub4.i.i88.i, i64 1
  %45 = fmul <2 x float> %44, %43
  %46 = shufflevector <2 x float> %45, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %47 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %41, <2 x float> %30, <2 x float> %46)
  %48 = extractelement <2 x float> %41, i64 0
  %49 = fneg float %48
  %neg17.i.i.i.i = fmul float %34, %49
  %50 = tail call float @llvm.fmuladd.f32(float %40, float %sub4.i.i88.i, float %neg17.i.i.i.i)
  %51 = fmul <2 x float> %47, %47
  %mul5.i.i.i.i.i = extractelement <2 x float> %51, i64 1
  %52 = extractelement <2 x float> %47, i64 0
  %53 = tail call float @llvm.fmuladd.f32(float %52, float %52, float %mul5.i.i.i.i.i)
  %54 = tail call noundef float @llvm.fmuladd.f32(float %50, float %50, float %53)
  %55 = tail call noundef float @llvm.fabs.f32(float %54)
  %cmp.i99.i = fcmp uge float %55, 0x3E80000000000000
  br i1 %cmp.i99.i, label %if.end30.i, label %if.then24.i

if.then24.i:                                      ; preds = %if.end16.i
  %56 = tail call noundef float @llvm.fabs.f32(float %34)
  %cmp.i.i103.i = fcmp uge float %56, 0x3E80000000000000
  %mul7.i.i108.i = fmul float %56, 0x3E80000000000000
  %cmp8.i.i109.i = fcmp uge float %56, %mul7.i.i108.i
  %or.cond173.i = and i1 %cmp.i.i103.i, %cmp8.i.i109.i
  br i1 %or.cond173.i, label %sw.bb9, label %land.lhs.true.i111.i

land.lhs.true.i111.i:                             ; preds = %if.then24.i
  %57 = tail call noundef float @llvm.fabs.f32(float %sub4.i.i88.i)
  %cmp.i6.i115.i = fcmp uge float %57, 0x3E80000000000000
  %mul7.i10.i120.i = fmul float %57, 0x3E80000000000000
  %cmp8.i11.i121.i = fcmp uge float %57, %mul7.i10.i120.i
  %or.cond174.i = and i1 %cmp.i6.i115.i, %cmp8.i11.i121.i
  br i1 %or.cond174.i, label %sw.bb9, label %land.rhs.i123.i

land.rhs.i123.i:                                  ; preds = %land.lhs.true.i111.i
  %58 = tail call noundef float @llvm.fabs.f32(float %37)
  %cmp.i19.i127.i = fcmp uge float %58, 0x3E80000000000000
  %mul7.i23.i131.i = fmul float %58, 0x3E80000000000000
  %cmp8.i24.i132.i = fcmp uge float %58, %mul7.i23.i131.i
  %or.cond176.i = and i1 %cmp.i19.i127.i, %cmp8.i24.i132.i
  br i1 %or.cond176.i, label %sw.bb9, label %sw.bb8

if.end30.i:                                       ; preds = %if.end16.i
  %sqrt.i144.i = tail call float @llvm.sqrt.f32(float %54)
  %div.i145.i = fdiv float 1.000000e+00, %sqrt.i144.i
  %59 = insertelement <2 x float> poison, float %div.i145.i, i64 0
  %60 = shufflevector <2 x float> %59, <2 x float> poison, <2 x i32> zeroinitializer
  %61 = fmul <2 x float> %47, %60
  %mul5.i.i.i148.i = fmul float %50, %div.i145.i
  %dir.sroa.47.8.vec.insert134.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %mul5.i.i.i148.i, i64 0
  %arrayidx.i149.i = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %portal, i64 0, i64 2
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %dir.i150.i)
  store <2 x float> %61, ptr %dir.i150.i, align 16
  %dir.sroa.47.0.dir.i150.sroa_idx.i = getelementptr inbounds i8, ptr %dir.i150.i, i64 8
  store <2 x float> %dir.sroa.47.8.vec.insert134.i, ptr %dir.sroa.47.0.dir.i150.sroa_idx.i, align 8
  %v1.i151.i = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %portal, i64 0, i64 2, i32 1
  call fastcc void @_ZL18b3MprConvexSupportiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_SA_SB_i(i32 noundef %bodyIndexA, ptr noundef nonnull %cpuBodyBuf, ptr noundef %cpuConvexData, ptr noundef %cpuCollidables, ptr noundef %cpuVertices, ptr noundef nonnull %dir.i150.i, ptr noundef nonnull %v1.i151.i)
  %62 = fneg <2 x float> %61
  %mul4.i.i156.i = fneg float %mul5.i.i.i148.i
  %retval.sroa.3.12.vec.insert.i.i.i159.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %mul4.i.i156.i, i64 0
  store <2 x float> %62, ptr %dir.i150.i, align 16
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i.i159.i, ptr %dir.sroa.47.0.dir.i150.sroa_idx.i, align 8
  %v2.i161.i = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %portal, i64 0, i64 2, i32 2
  call fastcc void @_ZL18b3MprConvexSupportiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_SA_SB_i(i32 noundef %bodyIndexB, ptr noundef nonnull %cpuBodyBuf, ptr noundef %cpuConvexData, ptr noundef %cpuCollidables, ptr noundef %cpuVertices, ptr noundef nonnull %dir.i150.i, ptr noundef nonnull %v2.i161.i)
  %63 = load float, ptr %v1.i151.i, align 16
  %64 = load float, ptr %v2.i161.i, align 16
  %arrayidx2.i.i163.i = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %portal, i64 0, i64 2, i32 1, i32 0, i32 0, i64 1
  %65 = load float, ptr %arrayidx2.i.i163.i, align 4
  %arrayidx3.i12.i164.i = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %portal, i64 0, i64 2, i32 2, i32 0, i32 0, i64 1
  %66 = load float, ptr %arrayidx3.i12.i164.i, align 4
  %sub4.i.i165.i = fsub float %65, %66
  %arrayidx5.i.i166.i = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %portal, i64 0, i64 2, i32 1, i32 0, i32 0, i64 2
  %67 = load <4 x float>, ptr %arrayidx5.i.i166.i, align 8
  %68 = shufflevector <4 x float> %67, <4 x float> poison, <2 x i32> <i32 0, i32 poison>
  %arrayidx6.i.i167.i = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %portal, i64 0, i64 2, i32 2, i32 0, i32 0, i64 2
  %69 = load <4 x float>, ptr %arrayidx6.i.i167.i, align 8
  %70 = shufflevector <4 x float> %69, <4 x float> poison, <2 x i32> <i32 0, i32 poison>
  %71 = insertelement <2 x float> %68, float %63, i64 1
  %72 = insertelement <2 x float> %70, float %64, i64 1
  %73 = fsub <2 x float> %71, %72
  %74 = shufflevector <2 x float> %73, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %retval.sroa.0.4.vec.insert.i.i14.i170.i = insertelement <2 x float> %74, float %sub4.i.i165.i, i64 1
  %75 = insertelement <2 x float> %73, float 0.000000e+00, i64 1
  store <2 x float> %retval.sroa.0.4.vec.insert.i.i14.i170.i, ptr %arrayidx.i149.i, align 16
  %ref.tmp3.sroa.2.0.v.sroa_idx.i172.i = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %portal, i64 0, i64 2, i32 0, i32 0, i32 0, i64 2
  store <2 x float> %75, ptr %ref.tmp3.sroa.2.0.v.sroa_idx.i172.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %dir.i150.i)
  %arrayidx3.i.i.i174.i = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %portal, i64 0, i64 2, i32 0, i32 0, i32 0, i64 1
  %76 = extractelement <2 x float> %61, i64 1
  %mul5.i.i.i176.i = fmul float %76, %sub4.i.i165.i
  %77 = extractelement <2 x float> %73, i64 1
  %78 = extractelement <2 x float> %61, i64 0
  %79 = tail call float @llvm.fmuladd.f32(float %77, float %78, float %mul5.i.i.i176.i)
  %80 = extractelement <2 x float> %73, i64 0
  %81 = tail call noundef float @llvm.fmuladd.f32(float %80, float %mul5.i.i.i148.i, float %79)
  %82 = tail call noundef float @llvm.fabs.f32(float %81)
  %cmp.i179.i = fcmp olt float %82, 0x3E80000000000000
  %cmp38.i = fcmp olt float %81, 0.000000e+00
  %or.cond1.i = or i1 %cmp38.i, %cmp.i179.i
  br i1 %or.cond1.i, label %sw.default, label %if.end40.i

if.end40.i:                                       ; preds = %if.end30.i
  store i32 2, ptr %last.i.i, align 16
  %83 = load float, ptr %arrayidx.i78.i, align 16
  %84 = load float, ptr %portal, align 16
  %sub.i.i183.i = fsub float %83, %84
  %85 = load <2 x float>, ptr %arrayidx3.i.i.i.i, align 4
  %86 = load <2 x float>, ptr %arrayidx.i.i.i.i, align 4
  %87 = fsub <2 x float> %85, %86
  %88 = extractelement <2 x float> %86, i64 0
  %sub4.i.i198.i = fsub float %sub4.i.i165.i, %88
  %89 = shufflevector <2 x float> %86, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %90 = insertelement <2 x float> %89, float %84, i64 1
  %91 = fsub <2 x float> %73, %90
  %92 = shufflevector <2 x float> %87, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %93 = insertelement <2 x float> %92, float %sub.i.i183.i, i64 1
  %94 = fneg <2 x float> %93
  %95 = shufflevector <2 x float> %91, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %96 = insertelement <2 x float> %95, float %sub4.i.i198.i, i64 0
  %97 = fmul <2 x float> %96, %94
  %98 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %87, <2 x float> %91, <2 x float> %97)
  %99 = extractelement <2 x float> %87, i64 0
  %100 = fneg float %99
  %101 = extractelement <2 x float> %91, i64 1
  %neg17.i.i.i212.i = fmul float %101, %100
  %102 = tail call float @llvm.fmuladd.f32(float %sub.i.i183.i, float %sub4.i.i198.i, float %neg17.i.i.i212.i)
  %103 = fmul <2 x float> %98, %98
  %mul5.i.i.i.i.i218.i = extractelement <2 x float> %103, i64 1
  %104 = extractelement <2 x float> %98, i64 0
  %105 = tail call float @llvm.fmuladd.f32(float %104, float %104, float %mul5.i.i.i.i.i218.i)
  %106 = tail call noundef float @llvm.fmuladd.f32(float %102, float %102, float %105)
  %sqrt.i220.i = tail call float @llvm.sqrt.f32(float %106)
  %div.i221.i = fdiv float 1.000000e+00, %sqrt.i220.i
  %107 = insertelement <2 x float> poison, float %div.i221.i, i64 0
  %108 = shufflevector <2 x float> %107, <2 x float> poison, <2 x i32> zeroinitializer
  %109 = fmul <2 x float> %98, %108
  %mul5.i.i.i224.i = fmul float %102, %div.i221.i
  %dir.sroa.47.8.vec.insert142.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %mul5.i.i.i224.i, i64 0
  %shift = shufflevector <2 x float> %109, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %110 = fmul <2 x float> %86, %shift
  %mul5.i.i.i227.i = extractelement <2 x float> %110, i64 0
  %111 = extractelement <2 x float> %109, i64 0
  %112 = tail call float @llvm.fmuladd.f32(float %111, float %84, float %mul5.i.i.i227.i)
  %113 = extractelement <2 x float> %86, i64 1
  %114 = tail call noundef float @llvm.fmuladd.f32(float %mul5.i.i.i224.i, float %113, float %112)
  %cmp52.i = fcmp ogt float %114, 0.000000e+00
  br i1 %cmp52.i, label %if.then53.i, label %while.body.lr.ph.i

if.then53.i:                                      ; preds = %if.end40.i
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %supp.i.i)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(48) %supp.i.i, ptr noundef nonnull align 16 dereferenceable(48) %arrayidx.i78.i, i64 48, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(48) %arrayidx.i78.i, ptr noundef nonnull align 16 dereferenceable(48) %arrayidx.i149.i, i64 48, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(48) %arrayidx.i149.i, ptr noundef nonnull align 16 dereferenceable(48) %supp.i.i, i64 48, i1 false)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %supp.i.i)
  %115 = fneg <2 x float> %109
  %mul5.i.i235.i = fneg float %mul5.i.i.i224.i
  %dir.sroa.47.8.vec.insert148.i = insertelement <2 x float> %dir.sroa.47.8.vec.insert142.i, float %mul5.i.i235.i, i64 0
  br label %while.body.lr.ph.i

while.body.lr.ph.i:                               ; preds = %if.then53.i, %if.end40.i
  %dir.sroa.0.0.i = phi <2 x float> [ %115, %if.then53.i ], [ %109, %if.end40.i ]
  %dir.sroa.47.0.i = phi <2 x float> [ %dir.sroa.47.8.vec.insert148.i, %if.then53.i ], [ %dir.sroa.47.8.vec.insert142.i, %if.end40.i ]
  %arrayidx.i238.i = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %portal, i64 0, i64 3
  %dir.sroa.47.0.dir.i239.sroa_idx.i = getelementptr inbounds i8, ptr %dir.i239.i, i64 8
  %v1.i240.i = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %portal, i64 0, i64 3, i32 1
  %v2.i250.i = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %portal, i64 0, i64 3, i32 2
  %arrayidx5.i.i255.i = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %portal, i64 0, i64 3, i32 1, i32 0, i32 0, i64 2
  %arrayidx6.i.i256.i = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %portal, i64 0, i64 3, i32 2, i32 0, i32 0, i64 2
  %ref.tmp3.sroa.2.0.v.sroa_idx.i261.i = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %portal, i64 0, i64 3, i32 0, i32 0, i32 0, i64 2
  br label %while.body.i

while.body.i:                                     ; preds = %if.end108.i, %while.body.lr.ph.i
  %dir.sroa.47.1181.i = phi <2 x float> [ %dir.sroa.47.0.i, %while.body.lr.ph.i ], [ %dir.sroa.47.8.vec.insert156.i, %if.end108.i ]
  %dir.sroa.0.1180.i = phi <2 x float> [ %dir.sroa.0.0.i, %while.body.lr.ph.i ], [ %190, %if.end108.i ]
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %dir.i239.i)
  store <2 x float> %dir.sroa.0.1180.i, ptr %dir.i239.i, align 16
  store <2 x float> %dir.sroa.47.1181.i, ptr %dir.sroa.47.0.dir.i239.sroa_idx.i, align 8
  call fastcc void @_ZL18b3MprConvexSupportiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_SA_SB_i(i32 noundef %bodyIndexA, ptr noundef %cpuBodyBuf, ptr noundef %cpuConvexData, ptr noundef %cpuCollidables, ptr noundef %cpuVertices, ptr noundef nonnull %dir.i239.i, ptr noundef nonnull %v1.i240.i)
  %116 = fneg <2 x float> %dir.sroa.0.1180.i
  %dir.sroa.47.8.vec.extract150.i = extractelement <2 x float> %dir.sroa.47.1181.i, i64 0
  %117 = fneg <2 x float> %dir.sroa.47.1181.i
  %retval.sroa.3.12.vec.insert.i.i.i248.i240 = insertelement <2 x float> %117, float 0.000000e+00, i64 1
  store <2 x float> %116, ptr %dir.i239.i, align 16
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i.i248.i240, ptr %dir.sroa.47.0.dir.i239.sroa_idx.i, align 8
  call fastcc void @_ZL18b3MprConvexSupportiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_SA_SB_i(i32 noundef %bodyIndexB, ptr noundef %cpuBodyBuf, ptr noundef %cpuConvexData, ptr noundef %cpuCollidables, ptr noundef %cpuVertices, ptr noundef nonnull %dir.i239.i, ptr noundef nonnull %v2.i250.i)
  %118 = load <2 x float>, ptr %v1.i240.i, align 16
  %119 = load <2 x float>, ptr %v2.i250.i, align 16
  %120 = fsub <2 x float> %118, %119
  %121 = load float, ptr %arrayidx5.i.i255.i, align 8
  %122 = load float, ptr %arrayidx6.i.i256.i, align 8
  %sub7.i.i257.i = fsub float %121, %122
  %retval.sroa.3.12.vec.insert.i.i15.i260.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %sub7.i.i257.i, i64 0
  store <2 x float> %120, ptr %arrayidx.i238.i, align 16
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i15.i260.i, ptr %ref.tmp3.sroa.2.0.v.sroa_idx.i261.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %dir.i239.i)
  %123 = extractelement <2 x float> %120, i64 1
  %124 = fmul <2 x float> %dir.sroa.0.1180.i, %120
  %mul5.i.i.i265.i = extractelement <2 x float> %124, i64 1
  %125 = extractelement <2 x float> %dir.sroa.0.1180.i, i64 0
  %126 = extractelement <2 x float> %120, i64 0
  %127 = tail call float @llvm.fmuladd.f32(float %126, float %125, float %mul5.i.i.i265.i)
  %128 = tail call noundef float @llvm.fmuladd.f32(float %sub7.i.i257.i, float %dir.sroa.47.8.vec.extract150.i, float %127)
  %129 = tail call noundef float @llvm.fabs.f32(float %128)
  %cmp.i268.i = fcmp olt float %129, 0x3E80000000000000
  %cmp64.i = fcmp olt float %128, 0.000000e+00
  %or.cond2.i = or i1 %cmp64.i, %cmp.i268.i
  br i1 %or.cond2.i, label %sw.default, label %if.end66.i

if.end66.i:                                       ; preds = %while.body.i
  %130 = load float, ptr %arrayidx.i78.i, align 16
  %131 = fneg float %130
  %neg11.i.i.i277.i = fmul float %sub7.i.i257.i, %131
  %132 = load float, ptr %portal, align 16
  %133 = load <2 x float>, ptr %arrayidx3.i.i.i.i, align 4
  %134 = extractelement <2 x float> %133, i64 1
  %135 = fneg float %134
  %neg.i.i.i276.i = fmul float %123, %135
  %136 = extractelement <2 x float> %133, i64 0
  %137 = tail call float @llvm.fmuladd.f32(float %136, float %sub7.i.i257.i, float %neg.i.i.i276.i)
  %138 = tail call float @llvm.fmuladd.f32(float %134, float %126, float %neg11.i.i.i277.i)
  %139 = fneg float %136
  %neg17.i.i.i278.i = fmul float %126, %139
  %140 = tail call float @llvm.fmuladd.f32(float %130, float %123, float %neg17.i.i.i278.i)
  %141 = load <2 x float>, ptr %arrayidx.i.i.i.i, align 4
  %142 = extractelement <2 x float> %141, i64 0
  %mul5.i.i.i285.i = fmul float %138, %142
  %143 = tail call float @llvm.fmuladd.f32(float %137, float %132, float %mul5.i.i.i285.i)
  %144 = extractelement <2 x float> %141, i64 1
  %145 = tail call noundef float @llvm.fmuladd.f32(float %140, float %144, float %143)
  %cmp74.i = fcmp olt float %145, 0.000000e+00
  %146 = tail call float @llvm.fabs.f32(float %145)
  %cmp.i288.i = fcmp uge float %146, 0x3E80000000000000
  %or.cond177.i = and i1 %cmp74.i, %cmp.i288.i
  br i1 %or.cond177.i, label %if.then77.i, label %if.then81.critedge.i

if.then77.i:                                      ; preds = %if.end66.i
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(48) %arrayidx.i149.i, ptr noundef nonnull align 16 dereferenceable(48) %arrayidx.i238.i, i64 48, i1 false)
  %.pre187.i = load float, ptr %arrayidx.i149.i, align 16
  %.pre188.i = load float, ptr %arrayidx3.i.i.i174.i, align 4
  %147 = load <4 x float>, ptr %ref.tmp3.sroa.2.0.v.sroa_idx.i172.i, align 8
  %148 = shufflevector <4 x float> %147, <4 x float> poison, <2 x i32> <i32 0, i32 poison>
  %149 = insertelement <2 x float> %148, float %.pre187.i, i64 1
  br label %if.end108.i

if.then81.critedge.i:                             ; preds = %if.end66.i
  %150 = load float, ptr %ref.tmp3.sroa.2.0.v.sroa_idx.i172.i, align 8
  %151 = load float, ptr %arrayidx3.i.i.i174.i, align 4
  %152 = fneg float %sub7.i.i257.i
  %neg.i.i.i297.i = fmul float %151, %152
  %153 = tail call float @llvm.fmuladd.f32(float %123, float %150, float %neg.i.i.i297.i)
  %154 = load float, ptr %arrayidx.i149.i, align 16
  %155 = fneg float %126
  %neg11.i.i.i298.i = fmul float %150, %155
  %156 = tail call float @llvm.fmuladd.f32(float %sub7.i.i257.i, float %154, float %neg11.i.i.i298.i)
  %157 = fneg float %123
  %neg17.i.i.i299.i = fmul float %154, %157
  %158 = tail call float @llvm.fmuladd.f32(float %126, float %151, float %neg17.i.i.i299.i)
  %mul5.i.i.i306.i = fmul float %142, %156
  %159 = tail call float @llvm.fmuladd.f32(float %153, float %132, float %mul5.i.i.i306.i)
  %160 = tail call noundef float @llvm.fmuladd.f32(float %158, float %144, float %159)
  %cmp89.i = fcmp olt float %160, 0.000000e+00
  %161 = tail call float @llvm.fabs.f32(float %160)
  %cmp.i309.i = fcmp uge float %161, 0x3E80000000000000
  %or.cond178.i = and i1 %cmp89.i, %cmp.i309.i
  br i1 %or.cond178.i, label %if.then93.i, label %if.end108.thread.i

if.then93.i:                                      ; preds = %if.then81.critedge.i
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(48) %arrayidx.i78.i, ptr noundef nonnull align 16 dereferenceable(48) %arrayidx.i238.i, i64 48, i1 false)
  %.pre.i = load float, ptr %arrayidx.i78.i, align 16
  %162 = load <2 x float>, ptr %arrayidx3.i.i.i.i, align 4
  %163 = insertelement <2 x float> poison, float %150, i64 0
  %164 = insertelement <2 x float> %163, float %154, i64 1
  br label %if.end108.i

if.end108.thread.i:                               ; preds = %if.then81.critedge.i
  store i32 3, ptr %last.i.i, align 16
  br label %sw.bb

if.end108.i:                                      ; preds = %if.then93.i, %if.then77.i
  %165 = phi float [ %151, %if.then93.i ], [ %.pre188.i, %if.then77.i ]
  %166 = phi float [ %.pre.i, %if.then93.i ], [ %130, %if.then77.i ]
  %167 = phi <2 x float> [ %162, %if.then93.i ], [ %133, %if.then77.i ]
  %168 = phi <2 x float> [ %164, %if.then93.i ], [ %149, %if.then77.i ]
  %sub.i.i314.i = fsub float %166, %132
  %169 = fsub <2 x float> %167, %141
  %170 = shufflevector <2 x float> %141, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %171 = insertelement <2 x float> %170, float %132, i64 1
  %172 = fsub <2 x float> %168, %171
  %sub4.i.i329.i = fsub float %165, %142
  %173 = extractelement <2 x float> %169, i64 0
  %174 = fneg float %173
  %175 = extractelement <2 x float> %172, i64 1
  %neg17.i.i.i343.i = fmul float %175, %174
  %176 = tail call float @llvm.fmuladd.f32(float %sub.i.i314.i, float %sub4.i.i329.i, float %neg17.i.i.i343.i)
  %177 = shufflevector <2 x float> %169, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %178 = insertelement <2 x float> %177, float %sub.i.i314.i, i64 1
  %179 = fneg <2 x float> %178
  %180 = shufflevector <2 x float> %172, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %181 = insertelement <2 x float> %180, float %sub4.i.i329.i, i64 0
  %182 = fmul <2 x float> %181, %179
  %183 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %169, <2 x float> %172, <2 x float> %182)
  %184 = fmul <2 x float> %183, %183
  %mul5.i.i.i.i.i349.i = extractelement <2 x float> %184, i64 1
  %185 = extractelement <2 x float> %183, i64 0
  %186 = tail call float @llvm.fmuladd.f32(float %185, float %185, float %mul5.i.i.i.i.i349.i)
  %187 = tail call noundef float @llvm.fmuladd.f32(float %176, float %176, float %186)
  %sqrt.i351.i = tail call float @llvm.sqrt.f32(float %187)
  %div.i352.i = fdiv float 1.000000e+00, %sqrt.i351.i
  %188 = insertelement <2 x float> poison, float %div.i352.i, i64 0
  %189 = shufflevector <2 x float> %188, <2 x float> poison, <2 x i32> zeroinitializer
  %190 = fmul <2 x float> %183, %189
  %mul5.i.i.i355.i = fmul float %176, %div.i352.i
  %dir.sroa.47.8.vec.insert156.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %mul5.i.i.i355.i, i64 0
  %.pre190.i = load i32, ptr %last.i.i, align 16
  %cmp56.i = icmp slt i32 %.pre190.i, 3
  br i1 %cmp56.i, label %while.body.i, label %sw.bb, !llvm.loop !79

sw.bb:                                            ; preds = %if.end108.i, %if.end108.thread.i
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %v4.i)
  %arrayidx2.i.i9.i.i = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %portal, i64 0, i64 3, i32 0, i32 0, i32 0, i64 1
  %dir.sroa.11.0.dir.i.sroa_idx.i = getelementptr inbounds i8, ptr %dir.i.i33, i64 8
  %v1.i.i35 = getelementptr inbounds %struct._b3MprSupport_t, ptr %v4.i, i64 0, i32 1
  %v2.i.i36 = getelementptr inbounds %struct._b3MprSupport_t, ptr %v4.i, i64 0, i32 2
  %arrayidx5.i.i.i39 = getelementptr inbounds %struct._b3MprSupport_t, ptr %v4.i, i64 0, i32 1, i32 0, i32 0, i64 2
  %arrayidx6.i.i.i40 = getelementptr inbounds %struct._b3MprSupport_t, ptr %v4.i, i64 0, i32 2, i32 0, i32 0, i64 2
  %ref.tmp3.sroa.2.0.v.sroa_idx.i.i41 = getelementptr inbounds i8, ptr %v4.i, i64 8
  br label %for.body.i

for.body.i:                                       ; preds = %_Z14b3ExpandPortalP15_b3MprSimplex_tPK15_b3MprSupport_t.exit.i, %sw.bb
  %i.020.i = phi i32 [ 0, %sw.bb ], [ %inc.i, %_Z14b3ExpandPortalP15_b3MprSimplex_tPK15_b3MprSupport_t.exit.i ]
  %191 = load float, ptr %arrayidx.i149.i, align 16
  %192 = load float, ptr %arrayidx.i78.i, align 16
  %sub.i.i.i.i = fsub float %191, %192
  %193 = load float, ptr %arrayidx.i238.i, align 16
  %194 = load float, ptr %arrayidx2.i.i9.i.i, align 4
  %195 = load float, ptr %ref.tmp3.sroa.2.0.v.sroa_idx.i261.i, align 8
  %196 = load <2 x float>, ptr %arrayidx3.i.i.i174.i, align 4
  %197 = load <2 x float>, ptr %arrayidx3.i.i.i.i, align 4
  %198 = fsub <2 x float> %196, %197
  %199 = extractelement <2 x float> %197, i64 0
  %sub4.i.i11.i.i = fsub float %194, %199
  %200 = insertelement <2 x float> poison, float %193, i64 0
  %201 = insertelement <2 x float> %200, float %195, i64 1
  %202 = insertelement <2 x float> %197, float %192, i64 0
  %203 = fsub <2 x float> %201, %202
  %204 = shufflevector <2 x float> %203, <2 x float> poison, <2 x i32> <i32 1, i32 0>
  %205 = shufflevector <2 x float> %198, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %206 = insertelement <2 x float> %205, float %sub.i.i.i.i, i64 1
  %207 = fneg <2 x float> %206
  %208 = insertelement <2 x float> %203, float %sub4.i.i11.i.i, i64 0
  %209 = fmul <2 x float> %208, %207
  %210 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %198, <2 x float> %204, <2 x float> %209)
  %211 = extractelement <2 x float> %198, i64 0
  %212 = fneg float %211
  %213 = extractelement <2 x float> %203, i64 0
  %neg17.i.i.i.i.i = fmul float %213, %212
  %214 = tail call float @llvm.fmuladd.f32(float %sub.i.i.i.i, float %sub4.i.i11.i.i, float %neg17.i.i.i.i.i)
  %215 = fmul <2 x float> %210, %210
  %mul5.i.i.i.i.i.i.i = extractelement <2 x float> %215, i64 1
  %216 = extractelement <2 x float> %210, i64 0
  %217 = tail call float @llvm.fmuladd.f32(float %216, float %216, float %mul5.i.i.i.i.i.i.i)
  %218 = tail call noundef float @llvm.fmuladd.f32(float %214, float %214, float %217)
  %sqrt.i.i.i = tail call float @llvm.sqrt.f32(float %218)
  %div.i.i.i = fdiv float 1.000000e+00, %sqrt.i.i.i
  %219 = insertelement <2 x float> poison, float %div.i.i.i, i64 0
  %220 = shufflevector <2 x float> %219, <2 x float> poison, <2 x i32> zeroinitializer
  %221 = fmul <2 x float> %210, %220
  %mul5.i.i.i.i.i42 = fmul float %214, %div.i.i.i
  %222 = extractelement <2 x float> %221, i64 1
  %mul5.i.i.i.i7.i = fmul float %199, %222
  %223 = extractelement <2 x float> %221, i64 0
  %224 = tail call float @llvm.fmuladd.f32(float %223, float %192, float %mul5.i.i.i.i7.i)
  %225 = extractelement <2 x float> %197, i64 1
  %226 = tail call noundef float @llvm.fmuladd.f32(float %mul5.i.i.i.i.i42, float %225, float %224)
  %227 = tail call noundef float @llvm.fabs.f32(float %226)
  %cmp.i.i.i43 = fcmp uge float %227, 0x3E80000000000000
  %cmp.i.i44 = fcmp ule float %226, 0.000000e+00
  %.not.i = and i1 %cmp.i.i44, %cmp.i.i.i43
  br i1 %.not.i, label %if.end.i46, label %if.end

if.end.i46:                                       ; preds = %for.body.i
  %dir.sroa.11.8.vec.insert.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %mul5.i.i.i.i.i42, i64 0
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %dir.i.i33)
  store <2 x float> %221, ptr %dir.i.i33, align 16
  store <2 x float> %dir.sroa.11.8.vec.insert.i, ptr %dir.sroa.11.0.dir.i.sroa_idx.i, align 8
  call fastcc void @_ZL18b3MprConvexSupportiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_SA_SB_i(i32 noundef %bodyIndexA, ptr noundef %cpuBodyBuf, ptr noundef %cpuConvexData, ptr noundef %cpuCollidables, ptr noundef %cpuVertices, ptr noundef nonnull %dir.i.i33, ptr noundef nonnull %v1.i.i35)
  %228 = fneg <2 x float> %221
  %mul4.i.i.i48 = fneg float %mul5.i.i.i.i.i42
  %retval.sroa.3.12.vec.insert.i.i.i.i51 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %mul4.i.i.i48, i64 0
  store <2 x float> %228, ptr %dir.i.i33, align 16
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i.i.i51, ptr %dir.sroa.11.0.dir.i.sroa_idx.i, align 8
  call fastcc void @_ZL18b3MprConvexSupportiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_SA_SB_i(i32 noundef %bodyIndexB, ptr noundef %cpuBodyBuf, ptr noundef %cpuConvexData, ptr noundef %cpuCollidables, ptr noundef %cpuVertices, ptr noundef nonnull %dir.i.i33, ptr noundef nonnull %v2.i.i36)
  %229 = load <2 x float>, ptr %v1.i.i35, align 16
  %230 = load <2 x float>, ptr %v2.i.i36, align 16
  %231 = fsub <2 x float> %229, %230
  %232 = load float, ptr %arrayidx5.i.i.i39, align 8
  %233 = load float, ptr %arrayidx6.i.i.i40, align 8
  %sub7.i.i.i54 = fsub float %232, %233
  %retval.sroa.3.12.vec.insert.i.i15.i.i57 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %sub7.i.i.i54, i64 0
  store <2 x float> %231, ptr %v4.i, align 16
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i15.i.i57, ptr %ref.tmp3.sroa.2.0.v.sroa_idx.i.i41, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %dir.i.i33)
  %234 = extractelement <2 x float> %231, i64 1
  %mul5.i.i.i.i10.i = fmul float %222, %234
  %235 = extractelement <2 x float> %231, i64 0
  %236 = tail call float @llvm.fmuladd.f32(float %235, float %223, float %mul5.i.i.i.i10.i)
  %237 = tail call noundef float @llvm.fmuladd.f32(float %sub7.i.i.i54, float %mul5.i.i.i.i.i42, float %236)
  %238 = tail call noundef float @llvm.fabs.f32(float %237)
  %cmp.i.i13.i = fcmp uge float %238, 0x3E80000000000000
  %cmp.i14.i = fcmp ule float %237, 0.000000e+00
  %.not18.i = and i1 %cmp.i14.i, %cmp.i.i13.i
  br i1 %.not18.i, label %_ZL14b3RefinePortaliiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_P15_b3MprSimplex_t.exit.thread, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %if.end.i46
  %239 = extractelement <2 x float> %196, i64 0
  %mul5.i.i.i18.i.i = fmul float %239, %222
  %240 = tail call float @llvm.fmuladd.f32(float %191, float %223, float %mul5.i.i.i18.i.i)
  %241 = extractelement <2 x float> %196, i64 1
  %242 = tail call noundef float @llvm.fmuladd.f32(float %241, float %mul5.i.i.i.i.i42, float %240)
  %mul5.i.i.i24.i.i = fmul float %194, %222
  %243 = tail call float @llvm.fmuladd.f32(float %193, float %223, float %mul5.i.i.i24.i.i)
  %244 = tail call noundef float @llvm.fmuladd.f32(float %195, float %mul5.i.i.i.i.i42, float %243)
  %sub.i.i = fsub float %237, %226
  %sub10.i.i = fsub float %237, %242
  %sub11.i.i = fsub float %237, %244
  %cmp.i22.i = fcmp olt float %sub.i.i, %sub10.i.i
  %cond.i.i = select i1 %cmp.i22.i, float %sub.i.i, float %sub10.i.i
  %cmp12.i.i = fcmp olt float %cond.i.i, %sub11.i.i
  %cond16.i.i = select i1 %cmp12.i.i, float %cond.i.i, float %sub11.i.i
  %sub.i.i23.i = fadd float %cond16.i.i, 0xBEB0C6F7A0000000
  %245 = tail call noundef float @llvm.fabs.f32(float %sub.i.i23.i)
  %cmp.i.i24.i = fcmp olt float %245, 0x3E80000000000000
  br i1 %cmp.i.i24.i, label %_ZL14b3RefinePortaliiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_P15_b3MprSimplex_t.exit.thread, label %if.end.i.i.i

if.end.i.i.i:                                     ; preds = %lor.lhs.false.i
  %246 = tail call noundef float @llvm.fabs.f32(float %cond16.i.i)
  %cmp4.i.i.i = fcmp olt float %246, 0x3EB0C6F7A0000000
  %cmp6.i.i.i = fcmp uge float %245, 0x3D40C6F7A0000000
  %mul7.i.i.i58 = fmul float %246, 0x3E80000000000000
  %cmp8.i.i.i59 = fcmp uge float %245, %mul7.i.i.i58
  %retval.0.shrunk.i.i.i = select i1 %cmp4.i.i.i, i1 %cmp6.i.i.i, i1 %cmp8.i.i.i59
  %cmp18.i.i = fcmp uge float %cond16.i.i, 0x3EB0C6F7A0000000
  %.not19.i = and i1 %cmp18.i.i, %retval.0.shrunk.i.i.i
  br i1 %.not19.i, label %if.end6.i, label %_ZL14b3RefinePortaliiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_P15_b3MprSimplex_t.exit.thread

if.end6.i:                                        ; preds = %if.end.i.i.i
  %247 = fneg float %sub7.i.i.i54
  %neg.i.i.i.i28.i = fmul float %142, %247
  %248 = tail call float @llvm.fmuladd.f32(float %234, float %144, float %neg.i.i.i.i28.i)
  %249 = fneg float %235
  %neg11.i.i.i.i29.i = fmul float %144, %249
  %250 = tail call float @llvm.fmuladd.f32(float %sub7.i.i.i54, float %132, float %neg11.i.i.i.i29.i)
  %251 = fneg float %234
  %neg17.i.i.i.i30.i = fmul float %132, %251
  %252 = tail call float @llvm.fmuladd.f32(float %235, float %142, float %neg17.i.i.i.i30.i)
  %mul5.i.i.i.i32.i = fmul float %199, %250
  %253 = tail call float @llvm.fmuladd.f32(float %192, float %248, float %mul5.i.i.i.i32.i)
  %254 = tail call noundef float @llvm.fmuladd.f32(float %225, float %252, float %253)
  %cmp.i34.i = fcmp ogt float %254, 0.000000e+00
  br i1 %cmp.i34.i, label %if.then.i.i, label %if.else10.i.i

if.then.i.i:                                      ; preds = %if.end6.i
  %mul5.i.i.i19.i.i = fmul float %239, %250
  %255 = tail call float @llvm.fmuladd.f32(float %191, float %248, float %mul5.i.i.i19.i.i)
  %256 = tail call noundef float @llvm.fmuladd.f32(float %241, float %252, float %255)
  %cmp8.i.i = fcmp ogt float %256, 0.000000e+00
  br i1 %cmp8.i.i, label %_Z14b3ExpandPortalP15_b3MprSimplex_tPK15_b3MprSupport_t.exit.i, label %if.else.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  br label %_Z14b3ExpandPortalP15_b3MprSimplex_tPK15_b3MprSupport_t.exit.i

if.else10.i.i:                                    ; preds = %if.end6.i
  %mul5.i.i.i26.i.i = fmul float %194, %250
  %257 = tail call float @llvm.fmuladd.f32(float %193, float %248, float %mul5.i.i.i26.i.i)
  %258 = tail call noundef float @llvm.fmuladd.f32(float %195, float %252, float %257)
  %cmp14.i.i = fcmp ogt float %258, 0.000000e+00
  br i1 %cmp14.i.i, label %if.then15.i.i, label %_Z14b3ExpandPortalP15_b3MprSimplex_tPK15_b3MprSupport_t.exit.i

if.then15.i.i:                                    ; preds = %if.else10.i.i
  br label %_Z14b3ExpandPortalP15_b3MprSimplex_tPK15_b3MprSupport_t.exit.i

_Z14b3ExpandPortalP15_b3MprSimplex_tPK15_b3MprSupport_t.exit.i: ; preds = %if.then15.i.i, %if.else10.i.i, %if.else.i.i, %if.then.i.i
  %add.ptr.i29.sink.i.i = phi ptr [ %arrayidx.i149.i, %if.then15.i.i ], [ %arrayidx.i238.i, %if.else.i.i ], [ %arrayidx.i78.i, %if.then.i.i ], [ %arrayidx.i78.i, %if.else10.i.i ]
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(48) %add.ptr.i29.sink.i.i, ptr noundef nonnull align 16 dereferenceable(48) %v4.i, i64 48, i1 false)
  %inc.i = add nuw nsw i32 %i.020.i, 1
  %exitcond.not.i = icmp eq i32 %inc.i, 1000
  br i1 %exitcond.not.i, label %_ZL14b3RefinePortaliiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_P15_b3MprSimplex_t.exit.thread, label %for.body.i, !llvm.loop !80

_ZL14b3RefinePortaliiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_P15_b3MprSimplex_t.exit.thread: ; preds = %if.end.i.i.i, %if.end.i46, %_Z14b3ExpandPortalP15_b3MprSimplex_tPK15_b3MprSupport_t.exit.i, %lor.lhs.false.i
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %v4.i)
  br label %return

if.end:                                           ; preds = %for.body.i
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %v4.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %v4.i61)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %zero.i)
  %dir.sroa.5.0.dir.i.sroa_idx.i = getelementptr inbounds i8, ptr %dir.i.i60, i64 4
  %dir.sroa.8.0.dir.i.sroa_idx.i = getelementptr inbounds i8, ptr %dir.i.i60, i64 8
  %v1.i.i71 = getelementptr inbounds %struct._b3MprSupport_t, ptr %v4.i61, i64 0, i32 1
  %v2.i.i72 = getelementptr inbounds %struct._b3MprSupport_t, ptr %v4.i61, i64 0, i32 2
  %arrayidx5.i.i.i75 = getelementptr inbounds %struct._b3MprSupport_t, ptr %v4.i61, i64 0, i32 1, i32 0, i32 0, i64 2
  %arrayidx6.i.i.i76 = getelementptr inbounds %struct._b3MprSupport_t, ptr %v4.i61, i64 0, i32 2, i32 0, i32 0, i64 2
  %ref.tmp3.sroa.2.0.v.sroa_idx.i.i77 = getelementptr inbounds i8, ptr %v4.i61, i64 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %zero.i, i8 0, i64 16, i1 false)
  %259 = insertelement <2 x float> poison, float %195, i64 0
  %260 = insertelement <2 x float> %259, float %193, i64 1
  br label %for.body.i78

for.body.i78:                                     ; preds = %_Z14b3ExpandPortalP15_b3MprSimplex_tPK15_b3MprSupport_t.exit.i127, %if.end
  %261 = phi float [ %194, %if.end ], [ %.pre188, %_Z14b3ExpandPortalP15_b3MprSimplex_tPK15_b3MprSupport_t.exit.i127 ]
  %262 = phi float [ %192, %if.end ], [ %.pre182, %_Z14b3ExpandPortalP15_b3MprSimplex_tPK15_b3MprSupport_t.exit.i127 ]
  %263 = phi float [ %191, %if.end ], [ %.pre, %_Z14b3ExpandPortalP15_b3MprSimplex_tPK15_b3MprSupport_t.exit.i127 ]
  %iterations.014.i = phi i64 [ 1, %if.end ], [ %inc.i129, %_Z14b3ExpandPortalP15_b3MprSimplex_tPK15_b3MprSupport_t.exit.i127 ]
  %264 = phi <2 x float> [ %196, %if.end ], [ %475, %_Z14b3ExpandPortalP15_b3MprSimplex_tPK15_b3MprSupport_t.exit.i127 ]
  %265 = phi <2 x float> [ %197, %if.end ], [ %476, %_Z14b3ExpandPortalP15_b3MprSimplex_tPK15_b3MprSupport_t.exit.i127 ]
  %266 = phi <2 x float> [ %260, %if.end ], [ %479, %_Z14b3ExpandPortalP15_b3MprSimplex_tPK15_b3MprSupport_t.exit.i127 ]
  %sub.i.i.i.i79 = fsub float %263, %262
  %267 = fsub <2 x float> %264, %265
  %268 = shufflevector <2 x float> %265, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %269 = insertelement <2 x float> %268, float %262, i64 1
  %270 = fsub <2 x float> %266, %269
  %271 = extractelement <2 x float> %265, i64 0
  %sub4.i.i11.i.i83 = fsub float %261, %271
  %272 = extractelement <2 x float> %267, i64 0
  %273 = fneg float %272
  %274 = extractelement <2 x float> %270, i64 1
  %neg17.i.i.i.i.i87 = fmul float %274, %273
  %275 = tail call float @llvm.fmuladd.f32(float %sub.i.i.i.i79, float %sub4.i.i11.i.i83, float %neg17.i.i.i.i.i87)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %dir.i.i60)
  %276 = shufflevector <2 x float> %267, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %277 = insertelement <2 x float> %276, float %sub.i.i.i.i79, i64 1
  %278 = fneg <2 x float> %277
  %279 = shufflevector <2 x float> %270, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %280 = insertelement <2 x float> %279, float %sub4.i.i11.i.i83, i64 0
  %281 = fmul <2 x float> %280, %278
  %282 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %267, <2 x float> %270, <2 x float> %281)
  %283 = fmul <2 x float> %282, %282
  %mul5.i.i.i.i.i.i.i88 = extractelement <2 x float> %283, i64 1
  %284 = extractelement <2 x float> %282, i64 0
  %285 = tail call float @llvm.fmuladd.f32(float %284, float %284, float %mul5.i.i.i.i.i.i.i88)
  %286 = tail call noundef float @llvm.fmuladd.f32(float %275, float %275, float %285)
  %sqrt.i.i.i89 = tail call float @llvm.sqrt.f32(float %286)
  %div.i.i.i90 = fdiv float 1.000000e+00, %sqrt.i.i.i89
  %287 = insertelement <2 x float> poison, float %div.i.i.i90, i64 0
  %288 = shufflevector <2 x float> %287, <2 x float> poison, <2 x i32> zeroinitializer
  %289 = fmul <2 x float> %282, %288
  %mul5.i.i.i.i.i93 = fmul float %275, %div.i.i.i90
  %dir.sroa.8.8.vec.insert.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %mul5.i.i.i.i.i93, i64 0
  %290 = extractelement <2 x float> %289, i64 0
  store float %290, ptr %dir.i.i60, align 16
  %291 = extractelement <2 x float> %289, i64 1
  store float %291, ptr %dir.sroa.5.0.dir.i.sroa_idx.i, align 4
  store <2 x float> %dir.sroa.8.8.vec.insert.i, ptr %dir.sroa.8.0.dir.i.sroa_idx.i, align 8
  call fastcc void @_ZL18b3MprConvexSupportiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_SA_SB_i(i32 noundef %bodyIndexA, ptr noundef %cpuBodyBuf, ptr noundef %cpuConvexData, ptr noundef %cpuCollidables, ptr noundef %cpuVertices, ptr noundef nonnull %dir.i.i60, ptr noundef nonnull %v1.i.i71)
  %292 = fneg <2 x float> %289
  %mul4.i.i.i96 = fneg float %mul5.i.i.i.i.i93
  %retval.sroa.3.12.vec.insert.i.i.i.i99 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %mul4.i.i.i96, i64 0
  store <2 x float> %292, ptr %dir.i.i60, align 16
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i.i.i99, ptr %dir.sroa.8.0.dir.i.sroa_idx.i, align 8
  call fastcc void @_ZL18b3MprConvexSupportiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_SA_SB_i(i32 noundef %bodyIndexB, ptr noundef %cpuBodyBuf, ptr noundef %cpuConvexData, ptr noundef %cpuCollidables, ptr noundef %cpuVertices, ptr noundef nonnull %dir.i.i60, ptr noundef nonnull %v2.i.i72)
  %293 = load <2 x float>, ptr %v1.i.i71, align 16
  %294 = load <2 x float>, ptr %v2.i.i72, align 16
  %295 = fsub <2 x float> %293, %294
  %296 = load float, ptr %arrayidx5.i.i.i75, align 8
  %297 = load float, ptr %arrayidx6.i.i.i76, align 8
  %sub7.i.i.i102 = fsub float %296, %297
  %retval.sroa.3.12.vec.insert.i.i15.i.i105 = insertelement <2 x float> <float poison, float 0.000000e+00>, float %sub7.i.i.i102, i64 0
  store <2 x float> %295, ptr %v4.i61, align 16
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i15.i.i105, ptr %ref.tmp3.sroa.2.0.v.sroa_idx.i.i77, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %dir.i.i60)
  %298 = extractelement <2 x float> %264, i64 0
  %mul5.i.i.i18.i.i106 = fmul float %298, %291
  %299 = tail call float @llvm.fmuladd.f32(float %263, float %290, float %mul5.i.i.i18.i.i106)
  %300 = extractelement <2 x float> %264, i64 1
  %301 = tail call noundef float @llvm.fmuladd.f32(float %300, float %mul5.i.i.i.i.i93, float %299)
  %mul5.i.i.i24.i.i107 = fmul float %261, %291
  %302 = extractelement <2 x float> %266, i64 1
  %303 = tail call float @llvm.fmuladd.f32(float %302, float %290, float %mul5.i.i.i24.i.i107)
  %304 = extractelement <2 x float> %266, i64 0
  %305 = tail call noundef float @llvm.fmuladd.f32(float %304, float %mul5.i.i.i.i.i93, float %303)
  %306 = shufflevector <2 x float> %289, <2 x float> %265, <2 x i32> <i32 1, i32 2>
  %307 = shufflevector <2 x float> %295, <2 x float> %289, <2 x i32> <i32 1, i32 3>
  %308 = fmul <2 x float> %306, %307
  %309 = insertelement <2 x float> %295, float %262, i64 1
  %310 = shufflevector <2 x float> %289, <2 x float> poison, <2 x i32> zeroinitializer
  %311 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %309, <2 x float> %310, <2 x float> %308)
  %312 = insertelement <2 x float> %265, float %sub7.i.i.i102, i64 0
  %313 = insertelement <2 x float> poison, float %mul5.i.i.i.i.i93, i64 0
  %314 = shufflevector <2 x float> %313, <2 x float> poison, <2 x i32> zeroinitializer
  %315 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %312, <2 x float> %314, <2 x float> %311)
  %316 = extractelement <2 x float> %315, i64 0
  %shift236 = shufflevector <2 x float> %315, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %317 = fsub <2 x float> %315, %shift236
  %sub.i.i108 = extractelement <2 x float> %317, i64 0
  %sub10.i.i109 = fsub float %316, %301
  %sub11.i.i110 = fsub float %316, %305
  %cmp.i.i111 = fcmp olt float %sub.i.i108, %sub10.i.i109
  %cond.i.i112 = select i1 %cmp.i.i111, float %sub.i.i108, float %sub10.i.i109
  %cmp12.i.i113 = fcmp olt float %cond.i.i112, %sub11.i.i110
  %cond16.i.i114 = select i1 %cmp12.i.i113, float %cond.i.i112, float %sub11.i.i110
  %sub.i.i18.i = fadd float %cond16.i.i114, 0xBEB0C6F7A0000000
  %318 = tail call noundef float @llvm.fabs.f32(float %sub.i.i18.i)
  %cmp.i.i.i115 = fcmp olt float %318, 0x3E80000000000000
  br i1 %cmp.i.i.i115, label %if.then.i134, label %if.end.i.i.i116

if.end.i.i.i116:                                  ; preds = %for.body.i78
  %319 = tail call noundef float @llvm.fabs.f32(float %cond16.i.i114)
  %cmp4.i.i.i117 = fcmp olt float %319, 0x3EB0C6F7A0000000
  %cmp6.i.i.i118 = fcmp olt float %318, 0x3D40C6F7A0000000
  %mul7.i.i.i119 = fmul float %319, 0x3E80000000000000
  %cmp8.i.i.i120 = fcmp olt float %318, %mul7.i.i.i119
  %retval.0.shrunk.i.i.i121 = select i1 %cmp4.i.i.i117, i1 %cmp6.i.i.i118, i1 %cmp8.i.i.i120
  %cmp18.i.i122 = fcmp olt float %cond16.i.i114, 0x3EB0C6F7A0000000
  %320 = or i1 %cmp18.i.i122, %retval.0.shrunk.i.i.i121
  %cmp3.i = icmp eq i64 %iterations.014.i, 1000
  %or.cond.i123 = or i1 %cmp3.i, %320
  br i1 %or.cond.i123, label %if.then.i134, label %if.end19.i

if.then.i134:                                     ; preds = %if.end.i.i.i116, %for.body.i78
  %call9.i = call noundef float @_Z22b3MprVec3PointTriDist2PK9b3Vector3S1_S1_S1_PS_(ptr noundef nonnull %zero.i, ptr noundef nonnull %arrayidx.i78.i, ptr noundef nonnull %arrayidx.i149.i, ptr noundef nonnull %arrayidx.i238.i, ptr noundef %dirOut)
  %call10.i = call float @sqrtf(float noundef %call9.i) #26
  store float %call10.i, ptr %depthOut, align 4
  %321 = load float, ptr %dirOut, align 16
  %322 = call noundef float @llvm.fabs.f32(float %321)
  %cmp.i21.i = fcmp uge float %322, 0x3E80000000000000
  br i1 %cmp.i21.i, label %if.then.if.end_crit_edge.i, label %land.lhs.true.i

if.then.if.end_crit_edge.i:                       ; preds = %if.then.i134
  %arrayidx3.i.i.i.i.i.phi.trans.insert.i = getelementptr inbounds [4 x float], ptr %dirOut, i64 0, i64 1
  %.pre.i146 = load float, ptr %arrayidx3.i.i.i.i.i.phi.trans.insert.i, align 4
  br label %if.end.i135

land.lhs.true.i:                                  ; preds = %if.then.i134
  %y.i = getelementptr inbounds %struct.anon.2, ptr %dirOut, i64 0, i32 1
  %323 = load float, ptr %y.i, align 4
  %324 = call noundef float @llvm.fabs.f32(float %323)
  %cmp.i23.i = fcmp uge float %324, 0x3E80000000000000
  br i1 %cmp.i23.i, label %if.end.i135, label %land.lhs.true15.i

land.lhs.true15.i:                                ; preds = %land.lhs.true.i
  %z.i = getelementptr inbounds %struct.anon.2, ptr %dirOut, i64 0, i32 2
  %325 = load float, ptr %z.i, align 8
  %326 = call noundef float @llvm.fabs.f32(float %325)
  %cmp.i25.i = fcmp uge float %326, 0x3E80000000000000
  br i1 %cmp.i25.i, label %if.end.i135, label %if.then18.i

if.then18.i:                                      ; preds = %land.lhs.true15.i
  store <2 x float> %dir.sroa.8.8.vec.insert.i, ptr %z.i, align 8
  br label %if.end.i135

if.end.i135:                                      ; preds = %if.then18.i, %land.lhs.true15.i, %land.lhs.true.i, %if.then.if.end_crit_edge.i
  %327 = phi float [ %291, %if.then18.i ], [ %323, %land.lhs.true15.i ], [ %323, %land.lhs.true.i ], [ %.pre.i146, %if.then.if.end_crit_edge.i ]
  %328 = phi float [ %290, %if.then18.i ], [ %321, %land.lhs.true15.i ], [ %321, %land.lhs.true.i ], [ %321, %if.then.if.end_crit_edge.i ]
  %arrayidx3.i.i.i.i.i.i = getelementptr inbounds [4 x float], ptr %dirOut, i64 0, i64 1
  %mul5.i.i.i.i.i.i136 = fmul float %327, %327
  %329 = call float @llvm.fmuladd.f32(float %328, float %328, float %mul5.i.i.i.i.i.i136)
  %arrayidx6.i.i.i.i.i.i = getelementptr inbounds [4 x float], ptr %dirOut, i64 0, i64 2
  %330 = load float, ptr %arrayidx6.i.i.i.i.i.i, align 8
  %331 = call noundef float @llvm.fmuladd.f32(float %330, float %330, float %329)
  %sqrt.i.i137 = call float @llvm.sqrt.f32(float %331)
  %div.i.i138 = fdiv float 1.000000e+00, %sqrt.i.i137
  %mul.i.i.i.i139 = fmul float %328, %div.i.i138
  store float %mul.i.i.i.i139, ptr %dirOut, align 16
  %332 = insertelement <2 x float> poison, float %327, i64 0
  %333 = insertelement <2 x float> %332, float %330, i64 1
  %334 = insertelement <2 x float> poison, float %div.i.i138, i64 0
  %335 = shufflevector <2 x float> %334, <2 x float> poison, <2 x i32> zeroinitializer
  %336 = fmul <2 x float> %333, %335
  store <2 x float> %336, ptr %arrayidx3.i.i.i.i.i.i, align 4
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %b.i.i)
  %337 = load float, ptr %arrayidx.i149.i, align 16
  %338 = load float, ptr %arrayidx.i78.i, align 16
  %339 = load float, ptr %arrayidx3.i.i.i174.i, align 4
  %340 = load float, ptr %arrayidx3.i.i.i.i, align 4
  %341 = load float, ptr %ref.tmp3.sroa.2.0.v.sroa_idx.i172.i, align 8
  %342 = load float, ptr %ref.tmp3.sroa.2.0.v.sroa_idx.i.i, align 8
  %343 = load float, ptr %arrayidx.i238.i, align 16
  %344 = load float, ptr %arrayidx2.i.i9.i.i, align 4
  %345 = load float, ptr %ref.tmp3.sroa.2.0.v.sroa_idx.i261.i, align 8
  %346 = fneg float %342
  %347 = fneg float %338
  %348 = fneg float %340
  %349 = load float, ptr %portal, align 16
  %350 = load float, ptr %arrayidx.i.i.i.i, align 4
  %351 = load float, ptr %ref.tmp.sroa.2.0.v.sroa_idx.i.i, align 8
  %352 = fneg float %351
  %353 = fneg float %349
  %354 = fneg float %350
  %arrayidx23.i.i = getelementptr inbounds [4 x float], ptr %b.i.i, i64 0, i64 2
  %355 = insertelement <2 x float> poison, float %341, i64 0
  %356 = insertelement <2 x float> %355, float %345, i64 1
  %357 = fneg <2 x float> %356
  %358 = insertelement <2 x float> poison, float %337, i64 0
  %359 = insertelement <2 x float> %358, float %343, i64 1
  %360 = fneg <2 x float> %359
  %361 = insertelement <2 x float> poison, float %339, i64 0
  %362 = insertelement <2 x float> %361, float %344, i64 1
  %363 = fneg <2 x float> %362
  %364 = shufflevector <2 x float> %361, <2 x float> poison, <2 x i32> zeroinitializer
  %365 = insertelement <2 x float> %357, float %346, i64 0
  %366 = fmul <2 x float> %364, %365
  %367 = insertelement <2 x float> poison, float %340, i64 0
  %368 = insertelement <2 x float> %367, float %344, i64 1
  %369 = shufflevector <2 x float> %355, <2 x float> poison, <2 x i32> zeroinitializer
  %370 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %368, <2 x float> %369, <2 x float> %366)
  %371 = insertelement <2 x float> %360, float %347, i64 0
  %372 = fmul <2 x float> %369, %371
  %373 = insertelement <2 x float> poison, float %342, i64 0
  %374 = insertelement <2 x float> %373, float %345, i64 1
  %375 = shufflevector <2 x float> %358, <2 x float> poison, <2 x i32> zeroinitializer
  %376 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %374, <2 x float> %375, <2 x float> %372)
  %377 = insertelement <2 x float> %363, float %348, i64 0
  %378 = fmul <2 x float> %375, %377
  %379 = insertelement <2 x float> poison, float %338, i64 0
  %380 = insertelement <2 x float> %379, float %343, i64 1
  %381 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %380, <2 x float> %364, <2 x float> %378)
  %382 = insertelement <2 x float> poison, float %344, i64 0
  %383 = insertelement <2 x float> %382, float %350, i64 1
  %384 = fmul <2 x float> %376, %383
  %385 = insertelement <2 x float> poison, float %343, i64 0
  %386 = insertelement <2 x float> %385, float %349, i64 1
  %387 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %370, <2 x float> %386, <2 x float> %384)
  %388 = insertelement <2 x float> poison, float %345, i64 0
  %389 = insertelement <2 x float> %388, float %351, i64 1
  %390 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %381, <2 x float> %389, <2 x float> %387)
  store <2 x float> %390, ptr %b.i.i, align 16
  %391 = shufflevector <2 x float> %367, <2 x float> poison, <2 x i32> zeroinitializer
  %392 = shufflevector <2 x float> %357, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %393 = insertelement <2 x float> %392, float %352, i64 0
  %394 = fmul <2 x float> %391, %393
  %395 = insertelement <2 x float> poison, float %350, i64 0
  %396 = insertelement <2 x float> %395, float %339, i64 1
  %397 = shufflevector <2 x float> %373, <2 x float> poison, <2 x i32> zeroinitializer
  %398 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %396, <2 x float> %397, <2 x float> %394)
  %399 = shufflevector <2 x float> %360, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %400 = insertelement <2 x float> %399, float %353, i64 0
  %401 = fmul <2 x float> %397, %400
  %402 = insertelement <2 x float> poison, float %351, i64 0
  %403 = insertelement <2 x float> %402, float %341, i64 1
  %404 = shufflevector <2 x float> %379, <2 x float> poison, <2 x i32> zeroinitializer
  %405 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %403, <2 x float> %404, <2 x float> %401)
  %406 = shufflevector <2 x float> %363, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %407 = insertelement <2 x float> %406, float %354, i64 0
  %408 = fmul <2 x float> %404, %407
  %409 = insertelement <2 x float> poison, float %349, i64 0
  %410 = insertelement <2 x float> %409, float %337, i64 1
  %411 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %410, <2 x float> %391, <2 x float> %408)
  %412 = fmul <2 x float> %383, %405
  %413 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %398, <2 x float> %386, <2 x float> %412)
  %414 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %411, <2 x float> %389, <2 x float> %413)
  store <2 x float> %414, ptr %arrayidx23.i.i, align 8
  %shift237 = shufflevector <2 x float> %390, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %415 = fadd <2 x float> %390, %shift237
  %416 = fadd <2 x float> %415, %414
  %shift238 = shufflevector <2 x float> %414, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %417 = fadd <2 x float> %shift238, %416
  %add37.i.i = extractelement <2 x float> %417, i64 0
  %418 = call noundef float @llvm.fabs.f32(float %add37.i.i)
  %cmp.i.i33.i = fcmp olt float %418, 0x3E80000000000000
  %cmp.i34.i144 = fcmp olt float %add37.i.i, 0.000000e+00
  %or.cond.i.i = or i1 %cmp.i34.i144, %cmp.i.i33.i
  br i1 %or.cond.i.i, label %if.then.i.i145, label %if.end.i.i

if.then.i.i145:                                   ; preds = %if.end.i135
  %arrayidx31.i.i = getelementptr inbounds [4 x float], ptr %b.i.i, i64 0, i64 3
  %arrayidx15.i.i = getelementptr inbounds [4 x float], ptr %b.i.i, i64 0, i64 1
  %sub.i.i.i.i.i = fsub float %337, %338
  %sub4.i.i11.i.i.i = fsub float %344, %340
  %sub.i.i8.i.i.i = fsub float %343, %338
  %sub4.i.i.i.i.i = fsub float %339, %340
  %419 = fneg float %sub4.i.i.i.i.i
  %neg17.i.i.i.i.i.i = fmul float %sub.i.i8.i.i.i, %419
  %420 = call float @llvm.fmuladd.f32(float %sub.i.i.i.i.i, float %sub4.i.i11.i.i.i, float %neg17.i.i.i.i.i.i)
  %sub7.i.i14.i.i.i = fsub float %345, %342
  %sub7.i.i.i.i.i = fsub float %341, %342
  %421 = fneg float %sub7.i.i.i.i.i
  %neg.i.i.i.i.i.i = fmul float %sub4.i.i11.i.i.i, %421
  %422 = call float @llvm.fmuladd.f32(float %sub4.i.i.i.i.i, float %sub7.i.i14.i.i.i, float %neg.i.i.i.i.i.i)
  %423 = fneg float %sub.i.i.i.i.i
  %neg11.i.i.i.i.i.i = fmul float %sub7.i.i14.i.i.i, %423
  %424 = call float @llvm.fmuladd.f32(float %sub7.i.i.i.i.i, float %sub.i.i8.i.i.i, float %neg11.i.i.i.i.i.i)
  %mul5.i.i.i.i.i.i.i.i = fmul float %424, %424
  %425 = call float @llvm.fmuladd.f32(float %422, float %422, float %mul5.i.i.i.i.i.i.i.i)
  %426 = call noundef float @llvm.fmuladd.f32(float %420, float %420, float %425)
  %sqrt.i.i.i.i = call float @llvm.sqrt.f32(float %426)
  %div.i.i.i.i = fdiv float 1.000000e+00, %sqrt.i.i.i.i
  %mul5.i.i.i.i.i41.i = fmul float %420, %div.i.i.i.i
  %mul3.i.i.i.i.i.i = fmul float %424, %div.i.i.i.i
  %mul.i.i.i.i.i.i = fmul float %422, %div.i.i.i.i
  store float 0.000000e+00, ptr %b.i.i, align 16
  %427 = insertelement <2 x float> %382, float %340, i64 1
  %428 = fmul <2 x float> %427, %357
  %429 = insertelement <2 x float> %388, float %342, i64 1
  %430 = fmul <2 x float> %429, %360
  %431 = insertelement <2 x float> %385, float %338, i64 1
  %432 = fmul <2 x float> %431, %363
  %433 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %362, <2 x float> %429, <2 x float> %428)
  %434 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %356, <2 x float> %431, <2 x float> %430)
  %435 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %359, <2 x float> %427, <2 x float> %432)
  %436 = insertelement <2 x float> poison, float %mul3.i.i.i.i.i.i, i64 0
  %437 = shufflevector <2 x float> %436, <2 x float> poison, <2 x i32> zeroinitializer
  %438 = fmul <2 x float> %434, %437
  %439 = insertelement <2 x float> poison, float %mul.i.i.i.i.i.i, i64 0
  %440 = shufflevector <2 x float> %439, <2 x float> poison, <2 x i32> zeroinitializer
  %441 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %433, <2 x float> %440, <2 x float> %438)
  %442 = insertelement <2 x float> poison, float %mul5.i.i.i.i.i41.i, i64 0
  %443 = shufflevector <2 x float> %442, <2 x float> poison, <2 x i32> zeroinitializer
  %444 = call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %435, <2 x float> %443, <2 x float> %441)
  store <2 x float> %444, ptr %arrayidx15.i.i, align 4
  %445 = extractelement <2 x float> %376, i64 0
  %mul5.i.i.i144.i.i = fmul float %445, %mul3.i.i.i.i.i.i
  %446 = extractelement <2 x float> %370, i64 0
  %447 = call float @llvm.fmuladd.f32(float %446, float %mul.i.i.i.i.i.i, float %mul5.i.i.i144.i.i)
  %448 = extractelement <2 x float> %381, i64 0
  %449 = call noundef float @llvm.fmuladd.f32(float %448, float %mul5.i.i.i.i.i41.i, float %447)
  store float %449, ptr %arrayidx31.i.i, align 4
  %shift239 = shufflevector <2 x float> %444, <2 x float> poison, <2 x i32> <i32 1, i32 poison>
  %450 = fadd <2 x float> %444, %shift239
  %add60.i.i = extractelement <2 x float> %450, i64 0
  %add62.i.i = fadd float %449, %add60.i.i
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then.i.i145, %if.end.i135
  %sum.0.i.i = phi float [ %add62.i.i, %if.then.i.i145 ], [ %add37.i.i, %if.end.i135 ]
  br label %for.body.i.i

for.body.i.i:                                     ; preds = %for.body.i.i, %if.end.i.i
  %i.0291.i.i = phi i64 [ 0, %if.end.i.i ], [ %inc.i.i, %for.body.i.i ]
  %p2.sroa.11.0288.i.i = phi float [ 0.000000e+00, %if.end.i.i ], [ %add5.i161.i.i, %for.body.i.i ]
  %p1.sroa.10.0285.i.i = phi float [ 0.000000e+00, %if.end.i.i ], [ %add5.i.i.i, %for.body.i.i ]
  %451 = phi <2 x float> [ zeroinitializer, %if.end.i.i ], [ %457, %for.body.i.i ]
  %452 = phi <2 x float> [ zeroinitializer, %if.end.i.i ], [ %459, %for.body.i.i ]
  %v1.i35.i = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %portal, i64 0, i64 %i.0291.i.i, i32 1
  %vec.sroa.0.0.copyload.i.i = load <2 x float>, ptr %v1.i35.i, align 16
  %vec.sroa.35.0.v1.sroa_idx.i.i = getelementptr inbounds i8, ptr %v1.i35.i, i64 8
  %vec.sroa.35.0.copyload.i.i = load <2 x float>, ptr %vec.sroa.35.0.v1.sroa_idx.i.i, align 8
  %arrayidx65.i.i = getelementptr inbounds [4 x float], ptr %b.i.i, i64 0, i64 %i.0291.i.i
  %453 = load float, ptr %arrayidx65.i.i, align 4
  %vec.sroa.35.8.vec.extract258.i.i = extractelement <2 x float> %vec.sroa.35.0.copyload.i.i, i64 0
  %mul5.i.i.i38.i = fmul float %vec.sroa.35.8.vec.extract258.i.i, %453
  %add5.i.i.i = fadd float %p1.sroa.10.0285.i.i, %mul5.i.i.i38.i
  %v2.i39.i = getelementptr inbounds [4 x %struct._b3MprSupport_t], ptr %portal, i64 0, i64 %i.0291.i.i, i32 2
  %vec.sroa.0.0.copyload220.i.i = load <2 x float>, ptr %v2.i39.i, align 16
  %vec.sroa.35.0.v2.sroa_idx.i.i = getelementptr inbounds i8, ptr %v2.i39.i, i64 8
  %vec.sroa.35.0.copyload244.i.i = load <2 x float>, ptr %vec.sroa.35.0.v2.sroa_idx.i.i, align 8
  %454 = insertelement <2 x float> poison, float %453, i64 0
  %455 = shufflevector <2 x float> %454, <2 x float> poison, <2 x i32> zeroinitializer
  %456 = fmul <2 x float> %vec.sroa.0.0.copyload.i.i, %455
  %457 = fadd <2 x float> %451, %456
  %458 = fmul <2 x float> %455, %vec.sroa.0.0.copyload220.i.i
  %vec.sroa.35.8.vec.extract263.i.i = extractelement <2 x float> %vec.sroa.35.0.copyload244.i.i, i64 0
  %mul5.i.i154.i.i = fmul float %453, %vec.sroa.35.8.vec.extract263.i.i
  %459 = fadd <2 x float> %452, %458
  %add5.i161.i.i = fadd float %p2.sroa.11.0288.i.i, %mul5.i.i154.i.i
  %inc.i.i = add nuw nsw i64 %i.0291.i.i, 1
  %exitcond.not.i.i = icmp eq i64 %inc.i.i, 4
  br i1 %exitcond.not.i.i, label %_ZL12b3FindPenetriiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_P15_b3MprSimplex_tPfSB_SB_.exit, label %for.body.i.i, !llvm.loop !81

if.end19.i:                                       ; preds = %if.end.i.i.i116
  %460 = fneg float %sub7.i.i.i102
  %neg.i.i.i.i45.i = fmul float %142, %460
  %461 = extractelement <2 x float> %295, i64 1
  %462 = tail call float @llvm.fmuladd.f32(float %461, float %144, float %neg.i.i.i.i45.i)
  %463 = extractelement <2 x float> %295, i64 0
  %464 = fneg float %463
  %neg11.i.i.i.i46.i = fmul float %144, %464
  %465 = tail call float @llvm.fmuladd.f32(float %sub7.i.i.i102, float %132, float %neg11.i.i.i.i46.i)
  %466 = fneg float %461
  %neg17.i.i.i.i47.i = fmul float %132, %466
  %467 = tail call float @llvm.fmuladd.f32(float %463, float %142, float %neg17.i.i.i.i47.i)
  %mul5.i.i.i.i49.i = fmul float %271, %465
  %468 = tail call float @llvm.fmuladd.f32(float %262, float %462, float %mul5.i.i.i.i49.i)
  %469 = extractelement <2 x float> %265, i64 1
  %470 = tail call noundef float @llvm.fmuladd.f32(float %469, float %467, float %468)
  %cmp.i51.i = fcmp ogt float %470, 0.000000e+00
  br i1 %cmp.i51.i, label %if.then.i52.i, label %if.else10.i.i124

if.then.i52.i:                                    ; preds = %if.end19.i
  %mul5.i.i.i19.i.i131 = fmul float %298, %465
  %471 = tail call float @llvm.fmuladd.f32(float %263, float %462, float %mul5.i.i.i19.i.i131)
  %472 = tail call noundef float @llvm.fmuladd.f32(float %300, float %467, float %471)
  %cmp8.i.i132 = fcmp ogt float %472, 0.000000e+00
  br i1 %cmp8.i.i132, label %_Z14b3ExpandPortalP15_b3MprSimplex_tPK15_b3MprSupport_t.exit.i127, label %if.else.i.i133

if.else.i.i133:                                   ; preds = %if.then.i52.i
  br label %_Z14b3ExpandPortalP15_b3MprSimplex_tPK15_b3MprSupport_t.exit.i127

if.else10.i.i124:                                 ; preds = %if.end19.i
  %mul5.i.i.i26.i.i125 = fmul float %261, %465
  %473 = tail call float @llvm.fmuladd.f32(float %302, float %462, float %mul5.i.i.i26.i.i125)
  %474 = tail call noundef float @llvm.fmuladd.f32(float %304, float %467, float %473)
  %cmp14.i.i126 = fcmp ogt float %474, 0.000000e+00
  br i1 %cmp14.i.i126, label %if.then15.i.i130, label %_Z14b3ExpandPortalP15_b3MprSimplex_tPK15_b3MprSupport_t.exit.i127

if.then15.i.i130:                                 ; preds = %if.else10.i.i124
  br label %_Z14b3ExpandPortalP15_b3MprSimplex_tPK15_b3MprSupport_t.exit.i127

_Z14b3ExpandPortalP15_b3MprSimplex_tPK15_b3MprSupport_t.exit.i127: ; preds = %if.then15.i.i130, %if.else10.i.i124, %if.else.i.i133, %if.then.i52.i
  %add.ptr.i29.sink.i.i128 = phi ptr [ %arrayidx.i149.i, %if.then15.i.i130 ], [ %arrayidx.i238.i, %if.else.i.i133 ], [ %arrayidx.i78.i, %if.then.i52.i ], [ %arrayidx.i78.i, %if.else10.i.i124 ]
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(48) %add.ptr.i29.sink.i.i128, ptr noundef nonnull align 16 dereferenceable(48) %v4.i61, i64 48, i1 false)
  %inc.i129 = add nuw nsw i64 %iterations.014.i, 1
  %.pre = load float, ptr %arrayidx.i149.i, align 16
  %.pre182 = load float, ptr %arrayidx.i78.i, align 16
  %475 = load <2 x float>, ptr %arrayidx3.i.i.i174.i, align 4
  %476 = load <2 x float>, ptr %arrayidx3.i.i.i.i, align 4
  %.pre187 = load float, ptr %arrayidx.i238.i, align 16
  %.pre188 = load float, ptr %arrayidx2.i.i9.i.i, align 4
  %477 = load <4 x float>, ptr %ref.tmp3.sroa.2.0.v.sroa_idx.i261.i, align 8
  %478 = shufflevector <4 x float> %477, <4 x float> poison, <2 x i32> <i32 0, i32 poison>
  %479 = insertelement <2 x float> %478, float %.pre187, i64 1
  br label %for.body.i78

_ZL12b3FindPenetriiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_P15_b3MprSimplex_tPfSB_SB_.exit: ; preds = %for.body.i.i
  %div.i40.i = fdiv float 1.000000e+00, %sum.0.i.i
  %mul5.i.i166.i.i = fmul float %div.i40.i, %add5.i.i.i
  %mul5.i.i171.i.i = fmul float %div.i40.i, %add5.i161.i.i
  %p1.sroa.10.0.pos.sroa_idx.i.i = getelementptr inbounds i8, ptr %posOut, i64 8
  %p1.sroa.14.0.pos.sroa_idx.i.i = getelementptr inbounds i8, ptr %posOut, i64 12
  store float 0.000000e+00, ptr %p1.sroa.14.0.pos.sroa_idx.i.i, align 4
  %add5.i178.i.i = fadd float %mul5.i.i166.i.i, %mul5.i.i171.i.i
  %480 = insertelement <2 x float> poison, float %div.i40.i, i64 0
  %481 = shufflevector <2 x float> %480, <2 x float> poison, <2 x i32> zeroinitializer
  %482 = fmul <2 x float> %481, %457
  %483 = fmul <2 x float> %481, %459
  %484 = fadd <2 x float> %482, %483
  %485 = fmul <2 x float> %484, <float 5.000000e-01, float 5.000000e-01>
  store <2 x float> %485, ptr %posOut, align 16
  %mul5.i.i183.i.i = fmul float %add5.i178.i.i, 5.000000e-01
  store float %mul5.i.i183.i.i, ptr %p1.sroa.10.0.pos.sroa_idx.i.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %b.i.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %v4.i61)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %zero.i)
  store i32 1, ptr %arrayidx, align 4
  %486 = load <2 x float>, ptr %dirOut, align 16
  %487 = fneg <2 x float> %486
  %488 = load float, ptr %arrayidx6.i.i.i.i.i.i, align 8
  %fneg4.i = fneg float %488
  %retval.sroa.3.12.vec.insert.i.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %fneg4.i, i64 0
  %arrayidx7 = getelementptr inbounds %class.b3Vector3, ptr %sepAxis, i64 %idxprom
  store <2 x float> %487, ptr %arrayidx7, align 16
  %ref.tmp.sroa.2.0.arrayidx7.sroa_idx = getelementptr inbounds i8, ptr %arrayidx7, i64 8
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i, ptr %ref.tmp.sroa.2.0.arrayidx7.sroa_idx, align 8
  br label %return

sw.bb8:                                           ; preds = %land.rhs.i123.i
  store float 0.000000e+00, ptr %depthOut, align 4
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %dirOut, i8 0, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %posOut, ptr noundef nonnull align 16 dereferenceable(16) %v1.i79.i, i64 16, i1 false)
  %z4.i.i = getelementptr inbounds %struct.anon.2, ptr %posOut, i64 0, i32 2
  %489 = load float, ptr %z4.i.i, align 8
  %add5.i.i150 = fadd float %26, %489
  %490 = load <2 x float>, ptr %posOut, align 16
  %491 = fadd <2 x float> %22, %490
  %492 = fmul <2 x float> %491, <float 5.000000e-01, float 5.000000e-01>
  store <2 x float> %492, ptr %posOut, align 16
  %mul5.i.i.i153 = fmul float %add5.i.i150, 5.000000e-01
  store float %mul5.i.i.i153, ptr %z4.i.i, align 8
  br label %return

sw.bb9:                                           ; preds = %land.rhs.i123.i, %land.lhs.true.i111.i, %if.then24.i
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %posOut, ptr noundef nonnull align 16 dereferenceable(16) %v1.i79.i, i64 16, i1 false)
  %z4.i.i162 = getelementptr inbounds %struct.anon.2, ptr %posOut, i64 0, i32 2
  %493 = load float, ptr %z4.i.i162, align 8
  %add5.i.i163 = fadd float %26, %493
  %494 = load <2 x float>, ptr %posOut, align 16
  %495 = fadd <2 x float> %22, %494
  %496 = fmul <2 x float> %495, <float 5.000000e-01, float 5.000000e-01>
  store <2 x float> %496, ptr %posOut, align 16
  %mul5.i.i.i166 = fmul float %add5.i.i163, 5.000000e-01
  store float %mul5.i.i.i166, ptr %z4.i.i162, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %dirOut, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx.i78.i, i64 16, i1 false)
  %497 = load float, ptr %dirOut, align 16
  %arrayidx3.i.i.i.i.i = getelementptr inbounds [4 x float], ptr %dirOut, i64 0, i64 1
  %498 = load float, ptr %arrayidx3.i.i.i.i.i, align 4
  %mul5.i.i.i.i.i167 = fmul float %498, %498
  %499 = tail call float @llvm.fmuladd.f32(float %497, float %497, float %mul5.i.i.i.i.i167)
  %arrayidx6.i.i.i.i.i = getelementptr inbounds [4 x float], ptr %dirOut, i64 0, i64 2
  %500 = load float, ptr %arrayidx6.i.i.i.i.i, align 8
  %501 = tail call noundef float @llvm.fmuladd.f32(float %500, float %500, float %499)
  %sqrt.i = tail call float @llvm.sqrt.f32(float %501)
  store float %sqrt.i, ptr %depthOut, align 4
  %502 = load float, ptr %arrayidx6.i.i.i.i.i, align 8
  %503 = load <2 x float>, ptr %dirOut, align 16
  %504 = fmul <2 x float> %503, %503
  %mul5.i.i.i.i.i.i168 = extractelement <2 x float> %504, i64 1
  %505 = extractelement <2 x float> %503, i64 0
  %506 = tail call float @llvm.fmuladd.f32(float %505, float %505, float %mul5.i.i.i.i.i.i168)
  %507 = tail call noundef float @llvm.fmuladd.f32(float %502, float %502, float %506)
  %sqrt.i.i169 = tail call float @llvm.sqrt.f32(float %507)
  %div.i.i170 = fdiv float 1.000000e+00, %sqrt.i.i169
  %508 = insertelement <2 x float> poison, float %div.i.i170, i64 0
  %509 = shufflevector <2 x float> %508, <2 x float> poison, <2 x i32> zeroinitializer
  %510 = fmul <2 x float> %503, %509
  store <2 x float> %510, ptr %dirOut, align 16
  %mul5.i.i.i.i173 = fmul float %502, %div.i.i170
  store float %mul5.i.i.i.i173, ptr %arrayidx6.i.i.i.i.i, align 8
  br label %return

sw.default:                                       ; preds = %while.body.i, %if.end.i, %if.end30.i
  store i32 0, ptr %arrayidx, align 4
  br label %return

return:                                           ; preds = %_ZL14b3RefinePortaliiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_P15_b3MprSimplex_t.exit.thread, %_ZL12b3FindPenetriiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_P15_b3MprSimplex_tPfSB_SB_.exit, %sw.bb8, %sw.bb9, %sw.default
  %retval.0 = phi i32 [ -1, %sw.default ], [ 0, %sw.bb9 ], [ 0, %sw.bb8 ], [ 0, %_ZL12b3FindPenetriiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_P15_b3MprSimplex_tPfSB_SB_.exit ], [ -1, %_ZL14b3RefinePortaliiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_P15_b3MprSimplex_t.exit.thread ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI10b3Contact4ED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #10 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %m_data.i.i = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this, i64 0, i32 5
  %0 = load ptr, ptr %m_data.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %0, null
  br i1 %tobool.not.i.i, label %invoke.cont, label %if.then.i.i

if.then.i.i:                                      ; preds = %entry
  %m_ownsMemory.i.i = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this, i64 0, i32 6
  %1 = load i8, ptr %m_ownsMemory.i.i, align 8
  %2 = and i8 %1, 1
  %tobool2.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool2.not.i.i, label %invoke.cont, label %if.then3.i.i

if.then3.i.i:                                     ; preds = %if.then.i.i
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then.i.i, %entry, %if.then3.i.i
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this, i64 0, i32 2
  %m_ownsMemory.i1.i = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i1.i, align 8
  store ptr null, ptr %m_data.i.i, align 8
  store i32 0, ptr %m_size.i.i, align 4
  %m_capacity.i.i = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i, align 8
  ret void

terminate.lpad:                                   ; preds = %if.then3.i.i
  %3 = landingpad { ptr, i32 }
          catch ptr null
  %4 = extractvalue { ptr, i32 } %3, 0
  tail call void @__clang_call_terminate(ptr %4) #27
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3GpuFaceED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #10 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %m_data.i.i = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this, i64 0, i32 5
  %0 = load ptr, ptr %m_data.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %0, null
  br i1 %tobool.not.i.i, label %invoke.cont, label %if.then.i.i

if.then.i.i:                                      ; preds = %entry
  %m_ownsMemory.i.i = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this, i64 0, i32 6
  %1 = load i8, ptr %m_ownsMemory.i.i, align 8
  %2 = and i8 %1, 1
  %tobool2.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool2.not.i.i, label %invoke.cont, label %if.then3.i.i

if.then3.i.i:                                     ; preds = %if.then.i.i
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then.i.i, %entry, %if.then3.i.i
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this, i64 0, i32 2
  %m_ownsMemory.i1.i = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i1.i, align 8
  store ptr null, ptr %m_data.i.i, align 8
  store i32 0, ptr %m_size.i.i, align 4
  %m_capacity.i.i = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i, align 8
  ret void

terminate.lpad:                                   ; preds = %if.then3.i.i
  %3 = landingpad { ptr, i32 }
          catch ptr null
  %4 = extractvalue { ptr, i32 } %3, 0
  tail call void @__clang_call_terminate(ptr %4) #27
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #10 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %m_data.i.i = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this, i64 0, i32 5
  %0 = load ptr, ptr %m_data.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %0, null
  br i1 %tobool.not.i.i, label %invoke.cont, label %if.then.i.i

if.then.i.i:                                      ; preds = %entry
  %m_ownsMemory.i.i = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this, i64 0, i32 6
  %1 = load i8, ptr %m_ownsMemory.i.i, align 8
  %2 = and i8 %1, 1
  %tobool2.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool2.not.i.i, label %invoke.cont, label %if.then3.i.i

if.then3.i.i:                                     ; preds = %if.then.i.i
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then.i.i, %entry, %if.then3.i.i
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this, i64 0, i32 2
  %m_ownsMemory.i1.i = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i1.i, align 8
  store ptr null, ptr %m_data.i.i, align 8
  store i32 0, ptr %m_size.i.i, align 4
  %m_capacity.i.i = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i, align 8
  ret void

terminate.lpad:                                   ; preds = %if.then3.i.i
  %3 = landingpad { ptr, i32 }
          catch ptr null
  %4 = extractvalue { ptr, i32 } %3, 0
  tail call void @__clang_call_terminate(ptr %4) #27
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #10 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %m_data.i.i = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this, i64 0, i32 5
  %0 = load ptr, ptr %m_data.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %0, null
  br i1 %tobool.not.i.i, label %invoke.cont, label %if.then.i.i

if.then.i.i:                                      ; preds = %entry
  %m_ownsMemory.i.i = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this, i64 0, i32 6
  %1 = load i8, ptr %m_ownsMemory.i.i, align 8
  %2 = and i8 %1, 1
  %tobool2.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool2.not.i.i, label %invoke.cont, label %if.then3.i.i

if.then3.i.i:                                     ; preds = %if.then.i.i
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then.i.i, %entry, %if.then3.i.i
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this, i64 0, i32 2
  %m_ownsMemory.i1.i = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i1.i, align 8
  store ptr null, ptr %m_data.i.i, align 8
  store i32 0, ptr %m_size.i.i, align 4
  %m_capacity.i.i = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i, align 8
  ret void

terminate.lpad:                                   ; preds = %if.then3.i.i
  %3 = landingpad { ptr, i32 }
          catch ptr null
  %4 = extractvalue { ptr, i32 } %3, 0
  tail call void @__clang_call_terminate(ptr %4) #27
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI12b3CollidableED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #10 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %m_data.i.i = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this, i64 0, i32 5
  %0 = load ptr, ptr %m_data.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %0, null
  br i1 %tobool.not.i.i, label %invoke.cont, label %if.then.i.i

if.then.i.i:                                      ; preds = %entry
  %m_ownsMemory.i.i = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this, i64 0, i32 6
  %1 = load i8, ptr %m_ownsMemory.i.i, align 8
  %2 = and i8 %1, 1
  %tobool2.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool2.not.i.i, label %invoke.cont, label %if.then3.i.i

if.then3.i.i:                                     ; preds = %if.then.i.i
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then.i.i, %entry, %if.then3.i.i
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this, i64 0, i32 2
  %m_ownsMemory.i1.i = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i1.i, align 8
  store ptr null, ptr %m_data.i.i, align 8
  store i32 0, ptr %m_size.i.i, align 4
  %m_capacity.i.i = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i, align 8
  ret void

terminate.lpad:                                   ; preds = %if.then3.i.i
  %3 = landingpad { ptr, i32 }
          catch ptr null
  %4 = extractvalue { ptr, i32 } %3, 0
  tail call void @__clang_call_terminate(ptr %4) #27
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #10 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %m_data.i.i = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this, i64 0, i32 5
  %0 = load ptr, ptr %m_data.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %0, null
  br i1 %tobool.not.i.i, label %invoke.cont, label %if.then.i.i

if.then.i.i:                                      ; preds = %entry
  %m_ownsMemory.i.i = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this, i64 0, i32 6
  %1 = load i8, ptr %m_ownsMemory.i.i, align 8
  %2 = and i8 %1, 1
  %tobool2.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool2.not.i.i, label %invoke.cont, label %if.then3.i.i

if.then3.i.i:                                     ; preds = %if.then.i.i
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then.i.i, %entry, %if.then3.i.i
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this, i64 0, i32 2
  %m_ownsMemory.i1.i = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i1.i, align 8
  store ptr null, ptr %m_data.i.i, align 8
  store i32 0, ptr %m_size.i.i, align 4
  %m_capacity.i.i = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i, align 8
  ret void

terminate.lpad:                                   ; preds = %if.then3.i.i
  %3 = landingpad { ptr, i32 }
          catch ptr null
  %4 = extractvalue { ptr, i32 } %3, 0
  tail call void @__clang_call_terminate(ptr %4) #27
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI18b3QuantizedBvhNodeE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %destArray, i1 noundef zeroext %waitForCompletion) local_unnamed_addr #8 comdat align 2 {
entry:
  %m_size.i = getelementptr inbounds %class.b3OpenCLArray.100, ptr %this, i64 0, i32 1
  %0 = load i64, ptr %m_size.i, align 8
  %conv = trunc i64 %0 to i32
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %destArray, i64 0, i32 2
  %1 = load i32, ptr %m_size.i.i, align 4
  %cmp4.i = icmp slt i32 %1, %conv
  br i1 %cmp4.i, label %for.body9.lr.ph.i, label %_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE6resizeEiRKS0_.exit

for.body9.lr.ph.i:                                ; preds = %entry
  tail call void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %destArray, i32 noundef %conv)
  %m_data10.i = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %destArray, i64 0, i32 5
  %2 = sext i32 %1 to i64
  %sext = shl i64 %0, 32
  %wide.trip.count.i = ashr exact i64 %sext, 32
  br label %for.body9.i

for.body9.i:                                      ; preds = %for.body9.i, %for.body9.lr.ph.i
  %indvars.iv.i = phi i64 [ %2, %for.body9.lr.ph.i ], [ %indvars.iv.next.i, %for.body9.i ]
  %3 = load ptr, ptr %m_data10.i, align 8
  %arrayidx12.i = getelementptr inbounds %struct.b3QuantizedBvhNode, ptr %3, i64 %indvars.iv.i
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx12.i, i8 0, i64 16, i1 false)
  %indvars.iv.next.i = add nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE6resizeEiRKS0_.exit, label %for.body9.i, !llvm.loop !82

_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE6resizeEiRKS0_.exit: ; preds = %for.body9.i, %entry
  store i32 %conv, ptr %m_size.i.i, align 4
  %4 = load i64, ptr %m_size.i, align 8
  %tobool.not = icmp eq i64 %4, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE6resizeEiRKS0_.exit
  %m_capacity.i.i = getelementptr inbounds %class.b3OpenCLArray.100, ptr %this, i64 0, i32 2
  %5 = load i64, ptr %m_capacity.i.i, align 8
  %cmp.not.i = icmp ugt i64 %4, %5
  br i1 %cmp.not.i, label %do.body.i, label %if.then.i

if.then.i:                                        ; preds = %if.then
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %destArray, i64 0, i32 5
  %6 = load ptr, ptr %m_data.i, align 8
  %7 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %m_commandQueue.i = getelementptr inbounds %class.b3OpenCLArray.100, ptr %this, i64 0, i32 5
  %8 = load ptr, ptr %m_commandQueue.i, align 8
  %m_clBuffer.i = getelementptr inbounds %class.b3OpenCLArray.100, ptr %this, i64 0, i32 3
  %9 = load ptr, ptr %m_clBuffer.i, align 8
  %mul2.i = shl i64 %4, 4
  %call3.i = tail call i32 %7(ptr noundef %8, ptr noundef %9, i32 noundef 0, i64 noundef 0, i64 noundef %mul2.i, ptr noundef %6, i32 noundef 0, ptr noundef null, ptr noundef null)
  br i1 %waitForCompletion, label %if.then4.i, label %if.end

if.then4.i:                                       ; preds = %if.then.i
  %10 = load ptr, ptr @__clewFinish, align 8
  %11 = load ptr, ptr %m_commandQueue.i, align 8
  %call6.i = tail call i32 %10(ptr noundef %11)
  br label %if.end

do.body.i:                                        ; preds = %if.then
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 285)
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.80)
  br label %if.end

if.end:                                           ; preds = %do.body.i, %if.then4.i, %if.then.i, %_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE6resizeEiRKS0_.exit
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI9b3BvhInfoE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %destArray, i1 noundef zeroext %waitForCompletion) local_unnamed_addr #8 comdat align 2 {
entry:
  %m_size.i = getelementptr inbounds %class.b3OpenCLArray.102, ptr %this, i64 0, i32 1
  %0 = load i64, ptr %m_size.i, align 8
  %conv = trunc i64 %0 to i32
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %destArray, i64 0, i32 2
  %1 = load i32, ptr %m_size.i.i, align 4
  %cmp4.i = icmp slt i32 %1, %conv
  br i1 %cmp4.i, label %for.body9.lr.ph.i, label %_ZN20b3AlignedObjectArrayI9b3BvhInfoE6resizeEiRKS0_.exit

for.body9.lr.ph.i:                                ; preds = %entry
  tail call void @_ZN20b3AlignedObjectArrayI9b3BvhInfoE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %destArray, i32 noundef %conv)
  %m_data10.i = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %destArray, i64 0, i32 5
  %2 = sext i32 %1 to i64
  %sext = shl i64 %0, 32
  %wide.trip.count.i = ashr exact i64 %sext, 32
  br label %for.body9.i

for.body9.i:                                      ; preds = %for.body9.i, %for.body9.lr.ph.i
  %indvars.iv.i = phi i64 [ %2, %for.body9.lr.ph.i ], [ %indvars.iv.next.i, %for.body9.i ]
  %3 = load ptr, ptr %m_data10.i, align 8
  %arrayidx12.i = getelementptr inbounds %struct.b3BvhInfo, ptr %3, i64 %indvars.iv.i
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(64) %arrayidx12.i, i8 0, i64 64, i1 false)
  %indvars.iv.next.i = add nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %_ZN20b3AlignedObjectArrayI9b3BvhInfoE6resizeEiRKS0_.exit, label %for.body9.i, !llvm.loop !83

_ZN20b3AlignedObjectArrayI9b3BvhInfoE6resizeEiRKS0_.exit: ; preds = %for.body9.i, %entry
  store i32 %conv, ptr %m_size.i.i, align 4
  %4 = load i64, ptr %m_size.i, align 8
  %tobool.not = icmp eq i64 %4, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %_ZN20b3AlignedObjectArrayI9b3BvhInfoE6resizeEiRKS0_.exit
  %m_capacity.i.i = getelementptr inbounds %class.b3OpenCLArray.102, ptr %this, i64 0, i32 2
  %5 = load i64, ptr %m_capacity.i.i, align 8
  %cmp.not.i = icmp ugt i64 %4, %5
  br i1 %cmp.not.i, label %do.body.i, label %if.then.i

if.then.i:                                        ; preds = %if.then
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %destArray, i64 0, i32 5
  %6 = load ptr, ptr %m_data.i, align 8
  %7 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %m_commandQueue.i = getelementptr inbounds %class.b3OpenCLArray.102, ptr %this, i64 0, i32 5
  %8 = load ptr, ptr %m_commandQueue.i, align 8
  %m_clBuffer.i = getelementptr inbounds %class.b3OpenCLArray.102, ptr %this, i64 0, i32 3
  %9 = load ptr, ptr %m_clBuffer.i, align 8
  %mul2.i = shl i64 %4, 6
  %call3.i = tail call i32 %7(ptr noundef %8, ptr noundef %9, i32 noundef 0, i64 noundef 0, i64 noundef %mul2.i, ptr noundef %6, i32 noundef 0, ptr noundef null, ptr noundef null)
  br i1 %waitForCompletion, label %if.then4.i, label %if.end

if.then4.i:                                       ; preds = %if.then.i
  %10 = load ptr, ptr @__clewFinish, align 8
  %11 = load ptr, ptr %m_commandQueue.i, align 8
  %call6.i = tail call i32 %10(ptr noundef %11)
  br label %if.end

do.body.i:                                        ; preds = %if.then
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 285)
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.80)
  br label %if.end

if.end:                                           ; preds = %do.body.i, %if.then4.i, %if.then.i, %_ZN20b3AlignedObjectArrayI9b3BvhInfoE6resizeEiRKS0_.exit
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK13b3OpenCLArrayI6b3AabbE10copyToHostER20b3AlignedObjectArrayIS0_Eb(ptr noundef nonnull align 8 dereferenceable(50) %this, ptr noundef nonnull align 8 dereferenceable(25) %destArray, i1 noundef zeroext %waitForCompletion) local_unnamed_addr #8 comdat align 2 {
entry:
  %m_size.i = getelementptr inbounds %class.b3OpenCLArray.90, ptr %this, i64 0, i32 1
  %0 = load i64, ptr %m_size.i, align 8
  %conv = trunc i64 %0 to i32
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %destArray, i64 0, i32 2
  %1 = load i32, ptr %m_size.i.i, align 4
  %cmp4.i = icmp slt i32 %1, %conv
  br i1 %cmp4.i, label %for.body9.lr.ph.i, label %_ZN20b3AlignedObjectArrayI6b3AabbE6resizeEiRKS0_.exit

for.body9.lr.ph.i:                                ; preds = %entry
  tail call void @_ZN20b3AlignedObjectArrayI6b3AabbE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %destArray, i32 noundef %conv)
  %m_data10.i = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %destArray, i64 0, i32 5
  %2 = sext i32 %1 to i64
  %sext = shl i64 %0, 32
  %wide.trip.count.i = ashr exact i64 %sext, 32
  br label %for.body9.i

for.body9.i:                                      ; preds = %for.body9.i, %for.body9.lr.ph.i
  %indvars.iv.i = phi i64 [ %2, %for.body9.lr.ph.i ], [ %indvars.iv.next.i, %for.body9.i ]
  %3 = load ptr, ptr %m_data10.i, align 8
  %arrayidx12.i = getelementptr inbounds %struct.b3Aabb, ptr %3, i64 %indvars.iv.i
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx12.i, i8 0, i64 32, i1 false)
  %indvars.iv.next.i = add nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %_ZN20b3AlignedObjectArrayI6b3AabbE6resizeEiRKS0_.exit, label %for.body9.i, !llvm.loop !84

_ZN20b3AlignedObjectArrayI6b3AabbE6resizeEiRKS0_.exit: ; preds = %for.body9.i, %entry
  store i32 %conv, ptr %m_size.i.i, align 4
  %4 = load i64, ptr %m_size.i, align 8
  %tobool.not = icmp eq i64 %4, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %_ZN20b3AlignedObjectArrayI6b3AabbE6resizeEiRKS0_.exit
  %m_capacity.i.i = getelementptr inbounds %class.b3OpenCLArray.90, ptr %this, i64 0, i32 2
  %5 = load i64, ptr %m_capacity.i.i, align 8
  %cmp.not.i = icmp ugt i64 %4, %5
  br i1 %cmp.not.i, label %do.body.i, label %if.then.i

if.then.i:                                        ; preds = %if.then
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %destArray, i64 0, i32 5
  %6 = load ptr, ptr %m_data.i, align 8
  %7 = load ptr, ptr @__clewEnqueueReadBuffer, align 8
  %m_commandQueue.i = getelementptr inbounds %class.b3OpenCLArray.90, ptr %this, i64 0, i32 5
  %8 = load ptr, ptr %m_commandQueue.i, align 8
  %m_clBuffer.i = getelementptr inbounds %class.b3OpenCLArray.90, ptr %this, i64 0, i32 3
  %9 = load ptr, ptr %m_clBuffer.i, align 8
  %mul2.i = shl i64 %4, 5
  %call3.i = tail call i32 %7(ptr noundef %8, ptr noundef %9, i32 noundef 0, i64 noundef 0, i64 noundef %mul2.i, ptr noundef %6, i32 noundef 0, ptr noundef null, ptr noundef null)
  br i1 %waitForCompletion, label %if.then4.i, label %if.end

if.then4.i:                                       ; preds = %if.then.i
  %10 = load ptr, ptr @__clewFinish, align 8
  %11 = load ptr, ptr %m_commandQueue.i, align 8
  %call6.i = tail call i32 %10(ptr noundef %11)
  br label %if.end

do.body.i:                                        ; preds = %if.then
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 285)
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.80)
  br label %if.end

if.end:                                           ; preds = %do.body.i, %if.then4.i, %if.then.i, %_ZN20b3AlignedObjectArrayI6b3AabbE6resizeEiRKS0_.exit
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3AabbED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #10 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %m_data.i.i = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this, i64 0, i32 5
  %0 = load ptr, ptr %m_data.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %0, null
  br i1 %tobool.not.i.i, label %invoke.cont, label %if.then.i.i

if.then.i.i:                                      ; preds = %entry
  %m_ownsMemory.i.i = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this, i64 0, i32 6
  %1 = load i8, ptr %m_ownsMemory.i.i, align 8
  %2 = and i8 %1, 1
  %tobool2.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool2.not.i.i, label %invoke.cont, label %if.then3.i.i

if.then3.i.i:                                     ; preds = %if.then.i.i
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then.i.i, %entry, %if.then3.i.i
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this, i64 0, i32 2
  %m_ownsMemory.i1.i = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i1.i, align 8
  store ptr null, ptr %m_data.i.i, align 8
  store i32 0, ptr %m_size.i.i, align 4
  %m_capacity.i.i = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i, align 8
  ret void

terminate.lpad:                                   ; preds = %if.then3.i.i
  %3 = landingpad { ptr, i32 }
          catch ptr null
  %4 = extractvalue { ptr, i32 } %3, 0
  tail call void @__clang_call_terminate(ptr %4) #27
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3BvhInfoED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #10 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %m_data.i.i = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this, i64 0, i32 5
  %0 = load ptr, ptr %m_data.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %0, null
  br i1 %tobool.not.i.i, label %invoke.cont, label %if.then.i.i

if.then.i.i:                                      ; preds = %entry
  %m_ownsMemory.i.i = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this, i64 0, i32 6
  %1 = load i8, ptr %m_ownsMemory.i.i, align 8
  %2 = and i8 %1, 1
  %tobool2.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool2.not.i.i, label %invoke.cont, label %if.then3.i.i

if.then3.i.i:                                     ; preds = %if.then.i.i
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then.i.i, %entry, %if.then3.i.i
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this, i64 0, i32 2
  %m_ownsMemory.i1.i = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i1.i, align 8
  store ptr null, ptr %m_data.i.i, align 8
  store i32 0, ptr %m_size.i.i, align 4
  %m_capacity.i.i = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i, align 8
  ret void

terminate.lpad:                                   ; preds = %if.then3.i.i
  %3 = landingpad { ptr, i32 }
          catch ptr null
  %4 = extractvalue { ptr, i32 } %3, 0
  tail call void @__clang_call_terminate(ptr %4) #27
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI16b3BvhSubtreeInfoED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #10 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %m_data.i.i = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this, i64 0, i32 5
  %0 = load ptr, ptr %m_data.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %0, null
  br i1 %tobool.not.i.i, label %invoke.cont, label %if.then.i.i

if.then.i.i:                                      ; preds = %entry
  %m_ownsMemory.i.i = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this, i64 0, i32 6
  %1 = load i8, ptr %m_ownsMemory.i.i, align 8
  %2 = and i8 %1, 1
  %tobool2.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool2.not.i.i, label %invoke.cont, label %if.then3.i.i

if.then3.i.i:                                     ; preds = %if.then.i.i
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then.i.i, %entry, %if.then3.i.i
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this, i64 0, i32 2
  %m_ownsMemory.i1.i = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i1.i, align 8
  store ptr null, ptr %m_data.i.i, align 8
  store i32 0, ptr %m_size.i.i, align 4
  %m_capacity.i.i = getelementptr inbounds %class.b3AlignedObjectArray.47, ptr %this, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i, align 8
  ret void

terminate.lpad:                                   ; preds = %if.then3.i.i
  %3 = landingpad { ptr, i32 }
          catch ptr null
  %4 = extractvalue { ptr, i32 } %3, 0
  tail call void @__clang_call_terminate(ptr %4) #27
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeED2Ev(ptr noundef nonnull align 8 dereferenceable(25) %this) unnamed_addr #10 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %m_data.i.i = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this, i64 0, i32 5
  %0 = load ptr, ptr %m_data.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %0, null
  br i1 %tobool.not.i.i, label %invoke.cont, label %if.then.i.i

if.then.i.i:                                      ; preds = %entry
  %m_ownsMemory.i.i = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this, i64 0, i32 6
  %1 = load i8, ptr %m_ownsMemory.i.i, align 8
  %2 = and i8 %1, 1
  %tobool2.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool2.not.i.i, label %invoke.cont, label %if.then3.i.i

if.then3.i.i:                                     ; preds = %if.then.i.i
  invoke void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then.i.i, %entry, %if.then3.i.i
  %m_size.i.i = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this, i64 0, i32 2
  %m_ownsMemory.i1.i = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory.i1.i, align 8
  store ptr null, ptr %m_data.i.i, align 8
  store i32 0, ptr %m_size.i.i, align 4
  %m_capacity.i.i = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this, i64 0, i32 3
  store i32 0, ptr %m_capacity.i.i, align 8
  ret void

terminate.lpad:                                   ; preds = %if.then3.i.i
  %3 = landingpad { ptr, i32 }
          catch ptr null
  %4 = extractvalue { ptr, i32 } %3, 0
  tail call void @__clang_call_terminate(ptr %4) #27
  unreachable
}

declare void @_ZN12b3LauncherCL9setBufferEP7_cl_mem(ptr noundef nonnull align 8 dereferenceable(112), ptr noundef) local_unnamed_addr #16

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN13b3OpenCLArrayI10b3Contact4E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %this, i64 noundef %_Count, i1 noundef zeroext %copyOldContents) local_unnamed_addr #8 comdat align 2 {
entry:
  %ciErrNum = alloca i32, align 4
  %m_capacity.i = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this, i64 0, i32 2
  %0 = load i64, ptr %m_capacity.i, align 8
  %cmp = icmp ult i64 %0, %_Count
  br i1 %cmp, label %if.then, label %if.end14

if.then:                                          ; preds = %entry
  %m_allowGrowingCapacity = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this, i64 0, i32 7
  %1 = load i8, ptr %m_allowGrowingCapacity, align 1
  %2 = and i8 %1, 1
  %tobool.not = icmp eq i8 %2, 0
  br i1 %tobool.not, label %if.else, label %if.then2

if.then2:                                         ; preds = %if.then
  %mul = mul i64 %_Count, 112
  %3 = load ptr, ptr @__clewCreateBuffer, align 8
  %m_clContext = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this, i64 0, i32 4
  %4 = load ptr, ptr %m_clContext, align 8
  %call3 = call ptr %3(ptr noundef %4, i64 noundef 1, i64 noundef %mul, ptr noundef null, ptr noundef nonnull %ciErrNum)
  %5 = load i32, ptr %ciErrNum, align 4
  %cmp4.not.not = icmp eq i32 %5, 0
  br i1 %cmp4.not.not, label %if.end, label %if.end.thread

if.end.thread:                                    ; preds = %if.then2
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 166)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.76)
  br label %if.end12

if.end:                                           ; preds = %if.then2
  br i1 %copyOldContents, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.end
  %m_size.i = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this, i64 0, i32 1
  %6 = load i64, ptr %m_size.i, align 8
  %cmp.i = icmp eq i64 %6, 0
  br i1 %cmp.i, label %if.end12, label %if.end.i

if.end.i:                                         ; preds = %if.then9
  %7 = load ptr, ptr @__clewEnqueueCopyBuffer, align 8
  %m_commandQueue.i = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this, i64 0, i32 5
  %8 = load ptr, ptr %m_commandQueue.i, align 8
  %m_clBuffer.i = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this, i64 0, i32 3
  %9 = load ptr, ptr %m_clBuffer.i, align 8
  %mul3.i = mul i64 %6, 112
  %call.i = call i32 %7(ptr noundef %8, ptr noundef %9, ptr noundef %call3, i64 noundef 0, i64 noundef 0, i64 noundef %mul3.i, i32 noundef 0, ptr noundef null, ptr noundef null)
  br label %if.end12

if.end12:                                         ; preds = %if.end.i, %if.then9, %if.end.thread, %if.end
  %_Count.addr.023 = phi i64 [ 0, %if.end.thread ], [ %_Count, %if.end ], [ %_Count, %if.then9 ], [ %_Count, %if.end.i ]
  %m_clBuffer.i5 = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this, i64 0, i32 3
  %10 = load ptr, ptr %m_clBuffer.i5, align 8
  %tobool.not.i = icmp eq ptr %10, null
  br i1 %tobool.not.i, label %_ZN13b3OpenCLArrayI10b3Contact4E10deallocateEv.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end12
  %m_ownsMemory.i = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this, i64 0, i32 6
  %11 = load i8, ptr %m_ownsMemory.i, align 8
  %12 = and i8 %11, 1
  %tobool2.not.i = icmp eq i8 %12, 0
  br i1 %tobool2.not.i, label %_ZN13b3OpenCLArrayI10b3Contact4E10deallocateEv.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i
  %13 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i6 = call i32 %13(ptr noundef nonnull %10)
  br label %_ZN13b3OpenCLArrayI10b3Contact4E10deallocateEv.exit

_ZN13b3OpenCLArrayI10b3Contact4E10deallocateEv.exit: ; preds = %if.end12, %land.lhs.true.i, %if.then.i
  store ptr %call3, ptr %m_clBuffer.i5, align 8
  store i64 %_Count.addr.023, ptr %m_capacity.i, align 8
  br label %if.end14

if.else:                                          ; preds = %if.then
  %m_clBuffer.i9 = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this, i64 0, i32 3
  %14 = load ptr, ptr %m_clBuffer.i9, align 8
  %tobool.not.i10 = icmp eq ptr %14, null
  br i1 %tobool.not.i10, label %_ZN13b3OpenCLArrayI10b3Contact4E10deallocateEv.exit18, label %land.lhs.true.i11

land.lhs.true.i11:                                ; preds = %if.else
  %m_ownsMemory.i12 = getelementptr inbounds %class.b3OpenCLArray.80, ptr %this, i64 0, i32 6
  %15 = load i8, ptr %m_ownsMemory.i12, align 8
  %16 = and i8 %15, 1
  %tobool2.not.i13 = icmp eq i8 %16, 0
  br i1 %tobool2.not.i13, label %_ZN13b3OpenCLArrayI10b3Contact4E10deallocateEv.exit18, label %if.then.i14

if.then.i14:                                      ; preds = %land.lhs.true.i11
  %17 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i15 = tail call i32 %17(ptr noundef nonnull %14)
  br label %_ZN13b3OpenCLArrayI10b3Contact4E10deallocateEv.exit18

_ZN13b3OpenCLArrayI10b3Contact4E10deallocateEv.exit18: ; preds = %if.else, %land.lhs.true.i11, %if.then.i14
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %m_capacity.i, i8 0, i64 16, i1 false)
  br label %if.end14

if.end14:                                         ; preds = %_ZN13b3OpenCLArrayI10b3Contact4E10deallocateEv.exit, %_ZN13b3OpenCLArrayI10b3Contact4E10deallocateEv.exit18, %entry
  %result.1 = phi i1 [ %cmp4.not.not, %_ZN13b3OpenCLArrayI10b3Contact4E10deallocateEv.exit ], [ false, %_ZN13b3OpenCLArrayI10b3Contact4E10deallocateEv.exit18 ], [ true, %entry ]
  ret i1 %result.1
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.fmuladd.f32(float, float, float) #19

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.fabs.f32(float) #19

declare ptr @b3OpenCLUtils_compileCLProgramFromString(ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, i1 noundef zeroext) local_unnamed_addr #16

declare ptr @b3OpenCLUtils_compileCLKernelFromString(ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #16

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK11b3Matrix3x311getRotationER12b3Quaternion(ptr noundef nonnull align 16 dereferenceable(48) %this, ptr noundef nonnull align 16 dereferenceable(16) %q) local_unnamed_addr #8 comdat align 2 {
entry:
  %temp = alloca [4 x float], align 16
  %0 = load float, ptr %this, align 16
  %arrayidx.i = getelementptr inbounds [3 x %class.b3Vector3], ptr %this, i64 0, i64 1, i32 0, i32 0, i64 1
  %1 = load float, ptr %arrayidx.i, align 4
  %add = fadd float %0, %1
  %arrayidx.i30 = getelementptr inbounds [3 x %class.b3Vector3], ptr %this, i64 0, i64 2, i32 0, i32 0, i64 2
  %2 = load float, ptr %arrayidx.i30, align 8
  %add8 = fadd float %add, %2
  %cmp = fcmp ogt float %add8, 0.000000e+00
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %arrayidx6 = getelementptr inbounds [3 x %class.b3Vector3], ptr %this, i64 0, i64 2
  %arrayidx3 = getelementptr inbounds [3 x %class.b3Vector3], ptr %this, i64 0, i64 1
  %add9 = fadd float %add8, 1.000000e+00
  %call.i = tail call noundef float @sqrtf(float noundef %add9) #26
  %div = fdiv float 5.000000e-01, %call.i
  %arrayidx.i31 = getelementptr inbounds [3 x %class.b3Vector3], ptr %this, i64 0, i64 2, i32 0, i32 0, i64 1
  %3 = load float, ptr %arrayidx.i31, align 4
  %arrayidx.i32 = getelementptr inbounds [3 x %class.b3Vector3], ptr %this, i64 0, i64 1, i32 0, i32 0, i64 2
  %4 = load float, ptr %arrayidx.i32, align 8
  %sub = fsub float %3, %4
  %arrayidx.i33 = getelementptr inbounds [4 x float], ptr %this, i64 0, i64 2
  %5 = load <4 x float>, ptr %arrayidx.i33, align 8
  %6 = shufflevector <4 x float> %5, <4 x float> poison, <2 x i32> <i32 0, i32 poison>
  %7 = load <4 x float>, ptr %arrayidx6, align 16
  %8 = shufflevector <4 x float> %7, <4 x float> poison, <2 x i32> <i32 0, i32 poison>
  %9 = load float, ptr %arrayidx3, align 16
  %arrayidx.i34 = getelementptr inbounds [4 x float], ptr %this, i64 0, i64 1
  %10 = load float, ptr %arrayidx.i34, align 4
  %11 = insertelement <2 x float> %6, float %9, i64 1
  %12 = insertelement <2 x float> %8, float %10, i64 1
  %13 = fsub <2 x float> %11, %12
  %14 = insertelement <4 x float> poison, float %div, i64 0
  %15 = insertelement <4 x float> %14, float %call.i, i64 1
  %16 = shufflevector <4 x float> %15, <4 x float> poison, <4 x i32> <i32 0, i32 0, i32 0, i32 1>
  %17 = insertelement <4 x float> <float poison, float poison, float poison, float 5.000000e-01>, float %sub, i64 0
  %18 = shufflevector <2 x float> %13, <2 x float> poison, <4 x i32> <i32 0, i32 1, i32 poison, i32 poison>
  %19 = shufflevector <4 x float> %17, <4 x float> %18, <4 x i32> <i32 0, i32 4, i32 5, i32 3>
  %20 = fmul <4 x float> %16, %19
  br label %if.end

if.else:                                          ; preds = %entry
  %cmp44 = fcmp olt float %0, %1
  %cmp51 = fcmp olt float %1, %2
  %cond = select i1 %cmp51, i32 2, i32 1
  %cmp58 = fcmp olt float %0, %2
  %cond59 = select i1 %cmp58, i32 2, i32 0
  %cond60 = select i1 %cmp44, i32 %cond, i32 %cond59
  %cond60.fr = freeze i32 %cond60
  %add61 = add nuw nsw i32 %cond60.fr, 1
  %21 = icmp eq i32 %add61, 3
  %rem = select i1 %21, i32 0, i32 %add61
  %add62 = add nuw nsw i32 %cond60.fr, 2
  %rem63 = urem i32 %add62, 3
  %idxprom = zext nneg i32 %cond60.fr to i64
  %arrayidx66 = getelementptr inbounds [3 x %class.b3Vector3], ptr %this, i64 0, i64 %idxprom
  %arrayidx69 = getelementptr inbounds float, ptr %arrayidx66, i64 %idxprom
  %22 = load float, ptr %arrayidx69, align 4
  %idxprom71 = sext i32 %rem to i64
  %arrayidx72 = getelementptr inbounds [3 x %class.b3Vector3], ptr %this, i64 0, i64 %idxprom71
  %arrayidx75 = getelementptr inbounds float, ptr %arrayidx72, i64 %idxprom71
  %23 = load float, ptr %arrayidx75, align 4
  %sub76 = fsub float %22, %23
  %idxprom78 = zext nneg i32 %rem63 to i64
  %arrayidx79 = getelementptr inbounds [3 x %class.b3Vector3], ptr %this, i64 0, i64 %idxprom78
  %arrayidx82 = getelementptr inbounds float, ptr %arrayidx79, i64 %idxprom78
  %24 = load float, ptr %arrayidx82, align 4
  %sub83 = fsub float %sub76, %24
  %add84 = fadd float %sub83, 1.000000e+00
  %call.i39 = tail call noundef float @sqrtf(float noundef %add84) #26
  %mul86 = fmul float %call.i39, 5.000000e-01
  %arrayidx88 = getelementptr inbounds [4 x float], ptr %temp, i64 0, i64 %idxprom
  store float %mul86, ptr %arrayidx88, align 4
  %div89 = fdiv float 5.000000e-01, %call.i39
  %arrayidx95 = getelementptr inbounds float, ptr %arrayidx79, i64 %idxprom71
  %25 = load float, ptr %arrayidx95, align 4
  %arrayidx101 = getelementptr inbounds float, ptr %arrayidx72, i64 %idxprom78
  %26 = load float, ptr %arrayidx101, align 4
  %sub102 = fsub float %25, %26
  %mul103 = fmul float %div89, %sub102
  %arrayidx104 = getelementptr inbounds [4 x float], ptr %temp, i64 0, i64 3
  store float %mul103, ptr %arrayidx104, align 4
  %arrayidx110 = getelementptr inbounds float, ptr %arrayidx72, i64 %idxprom
  %27 = load float, ptr %arrayidx110, align 4
  %arrayidx116 = getelementptr inbounds float, ptr %arrayidx66, i64 %idxprom71
  %28 = load float, ptr %arrayidx116, align 4
  %add117 = fadd float %27, %28
  %mul118 = fmul float %div89, %add117
  %arrayidx120 = getelementptr inbounds [4 x float], ptr %temp, i64 0, i64 %idxprom71
  store float %mul118, ptr %arrayidx120, align 4
  %arrayidx126 = getelementptr inbounds float, ptr %arrayidx79, i64 %idxprom
  %29 = load float, ptr %arrayidx126, align 4
  %arrayidx132 = getelementptr inbounds float, ptr %arrayidx66, i64 %idxprom78
  %30 = load float, ptr %arrayidx132, align 4
  %add133 = fadd float %29, %30
  %mul134 = fmul float %div89, %add133
  %arrayidx136 = getelementptr inbounds [4 x float], ptr %temp, i64 0, i64 %idxprom78
  store float %mul134, ptr %arrayidx136, align 4
  %31 = load <4 x float>, ptr %temp, align 16
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %32 = phi <4 x float> [ %31, %if.else ], [ %20, %if.then ]
  store <4 x float> %32, ptr %q, align 16
  ret void
}

declare void @b3EnterProfileZone(ptr noundef) local_unnamed_addr #16

declare void @b3LeaveProfileZone() local_unnamed_addr #16

; Function Attrs: mustprogress nofree nounwind willreturn memory(write)
declare float @sqrtf(float noundef) local_unnamed_addr #20

; Function Attrs: mustprogress nofree nosync nounwind memory(argmem: readwrite) uwtable
define internal fastcc void @_ZL18b3MprConvexSupportiiPK15b3RigidBodyDataPK22b3ConvexPolyhedronDataPK12b3CollidablePK9b3Vector3PS8_SA_SB_i(i32 noundef %bodyIndex, ptr nocapture noundef readonly %cpuBodyBuf, ptr nocapture noundef readonly %cpuConvexData, ptr nocapture noundef readonly %cpuCollidables, ptr nocapture noundef readonly %cpuVertices, ptr nocapture noundef readonly %_dir, ptr nocapture noundef writeonly %outp) unnamed_addr #2 {
entry:
  %idxprom = sext i32 %bodyIndex to i64
  %arrayidx = getelementptr inbounds %struct.b3RigidBodyData, ptr %cpuBodyBuf, i64 %idxprom
  %pos.sroa.0.0.copyload = load float, ptr %arrayidx, align 16
  %pos.sroa.2.0.arrayidx.sroa_idx = getelementptr inbounds i8, ptr %arrayidx, i64 4
  %pos.sroa.2.0.copyload = load float, ptr %pos.sroa.2.0.arrayidx.sroa_idx, align 4
  %pos.sroa.3.0.arrayidx.sroa_idx = getelementptr inbounds i8, ptr %arrayidx, i64 8
  %pos.sroa.3.0.copyload = load float, ptr %pos.sroa.3.0.arrayidx.sroa_idx, align 8
  %m_quat = getelementptr inbounds %struct.b3RigidBodyData, ptr %cpuBodyBuf, i64 %idxprom, i32 1
  %0 = load <2 x float>, ptr %m_quat, align 16
  %orn.sroa.5.0.m_quat.sroa_idx = getelementptr inbounds i8, ptr %m_quat, i64 8
  %orn.sroa.5.0.copyload = load float, ptr %orn.sroa.5.0.m_quat.sroa_idx, align 8
  %orn.sroa.7.0.m_quat.sroa_idx = getelementptr inbounds i8, ptr %m_quat, i64 12
  %orn.sroa.7.0.copyload = load float, ptr %orn.sroa.7.0.m_quat.sroa_idx, align 4
  %1 = load float, ptr %_dir, align 16
  %y = getelementptr inbounds %struct.anon.2, ptr %_dir, i64 0, i32 1
  %2 = load float, ptr %y, align 4
  %z = getelementptr inbounds %struct.anon.2, ptr %_dir, i64 0, i32 2
  %3 = load float, ptr %z, align 8
  %4 = extractelement <2 x float> %0, i64 0
  %fneg.i.i = fneg float %4
  %5 = extractelement <2 x float> %0, i64 1
  %fneg4.i.i = fneg float %5
  %fneg7.i.i = fneg float %orn.sroa.5.0.copyload
  %mul4.i.i = fmul float %3, %fneg4.i.i
  %6 = tail call float @llvm.fmuladd.f32(float %orn.sroa.7.0.copyload, float %1, float %mul4.i.i)
  %7 = tail call float @llvm.fmuladd.f32(float %orn.sroa.5.0.copyload, float %2, float %6)
  %mul12.i.i = fmul float %1, %fneg7.i.i
  %8 = tail call float @llvm.fmuladd.f32(float %orn.sroa.7.0.copyload, float %2, float %mul12.i.i)
  %9 = tail call float @llvm.fmuladd.f32(float %4, float %3, float %8)
  %mul21.i.i = fmul float %2, %fneg.i.i
  %10 = tail call float @llvm.fmuladd.f32(float %orn.sroa.7.0.copyload, float %3, float %mul21.i.i)
  %11 = tail call float @llvm.fmuladd.f32(float %5, float %1, float %10)
  %neg31.i.i = fmul float %5, %2
  %12 = tail call float @llvm.fmuladd.f32(float %4, float %1, float %neg31.i.i)
  %13 = tail call float @llvm.fmuladd.f32(float %orn.sroa.5.0.copyload, float %3, float %12)
  %mul4.i9.i = fmul float %orn.sroa.7.0.copyload, %7
  %14 = tail call float @llvm.fmuladd.f32(float %13, float %4, float %mul4.i9.i)
  %15 = tail call float @llvm.fmuladd.f32(float %9, float %orn.sroa.5.0.copyload, float %14)
  %16 = tail call float @llvm.fmuladd.f32(float %11, float %fneg4.i.i, float %15)
  %mul14.i.i = fmul float %orn.sroa.7.0.copyload, %9
  %17 = tail call float @llvm.fmuladd.f32(float %13, float %5, float %mul14.i.i)
  %18 = tail call float @llvm.fmuladd.f32(float %11, float %4, float %17)
  %19 = tail call float @llvm.fmuladd.f32(float %7, float %fneg7.i.i, float %18)
  %mul25.i.i = fmul float %orn.sroa.7.0.copyload, %11
  %20 = tail call float @llvm.fmuladd.f32(float %13, float %orn.sroa.5.0.copyload, float %mul25.i.i)
  %21 = tail call float @llvm.fmuladd.f32(float %7, float %5, float %20)
  %22 = tail call float @llvm.fmuladd.f32(float %9, float %fneg.i.i, float %21)
  %m_collidableIdx = getelementptr inbounds %struct.b3RigidBodyData, ptr %cpuBodyBuf, i64 %idxprom, i32 4
  %23 = load i32, ptr %m_collidableIdx, align 16
  %idxprom13 = sext i32 %23 to i64
  %24 = getelementptr inbounds %struct.b3Collidable, ptr %cpuCollidables, i64 %idxprom13, i32 3
  %25 = load i32, ptr %24, align 4
  %idxprom15 = sext i32 %25 to i64
  %m_numVertices.i = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %cpuConvexData, i64 %idxprom15, i32 7
  %26 = load i32, ptr %m_numVertices.i, align 4
  %cmp.i = icmp sgt i32 %26, 0
  br i1 %cmp.i, label %for.body.lr.ph.i.i, label %_Z23b3LocalGetSupportVertexRK9b3Vector3PK22b3ConvexPolyhedronDataPS0_.exit

for.body.lr.ph.i.i:                               ; preds = %entry
  %m_vertexOffset.i = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %cpuConvexData, i64 %idxprom15, i32 8
  %27 = load i32, ptr %m_vertexOffset.i, align 16
  %idxprom.i = sext i32 %27 to i64
  %arrayidx.i = getelementptr inbounds %class.b3Vector3, ptr %cpuVertices, i64 %idxprom.i
  %wide.trip.count.i.i = zext nneg i32 %26 to i64
  br label %for.body.i.i

for.body.i.i:                                     ; preds = %for.body.i.i, %for.body.lr.ph.i.i
  %indvars.iv.i.i = phi i64 [ 0, %for.body.lr.ph.i.i ], [ %indvars.iv.next.i.i, %for.body.i.i ]
  %maxDot.010.i.i = phi float [ 0xC7EFFFFFE0000000, %for.body.lr.ph.i.i ], [ %maxDot.1.i.i, %for.body.i.i ]
  %ptIndex.09.i.i = phi i32 [ -1, %for.body.lr.ph.i.i ], [ %ptIndex.1.i.i, %for.body.i.i ]
  %arrayidx.i.i = getelementptr inbounds %class.b3Vector3, ptr %arrayidx.i, i64 %indvars.iv.i.i
  %28 = load float, ptr %arrayidx.i.i, align 16
  %arrayidx3.i.i.i.i = getelementptr inbounds [4 x float], ptr %arrayidx.i.i, i64 0, i64 1
  %29 = load float, ptr %arrayidx3.i.i.i.i, align 4
  %mul5.i.i.i.i = fmul float %19, %29
  %30 = tail call float @llvm.fmuladd.f32(float %28, float %16, float %mul5.i.i.i.i)
  %arrayidx6.i.i.i.i = getelementptr inbounds [4 x float], ptr %arrayidx.i.i, i64 0, i64 2
  %31 = load float, ptr %arrayidx6.i.i.i.i, align 8
  %32 = tail call noundef float @llvm.fmuladd.f32(float %31, float %22, float %30)
  %cmp1.i.i = fcmp ogt float %32, %maxDot.010.i.i
  %33 = trunc i64 %indvars.iv.i.i to i32
  %ptIndex.1.i.i = select i1 %cmp1.i.i, i32 %33, i32 %ptIndex.09.i.i
  %maxDot.1.i.i = select i1 %cmp1.i.i, float %32, float %maxDot.010.i.i
  %indvars.iv.next.i.i = add nuw nsw i64 %indvars.iv.i.i, 1
  %exitcond.not.i.i = icmp eq i64 %indvars.iv.next.i.i, %wide.trip.count.i.i
  br i1 %exitcond.not.i.i, label %_Z8b3MaxDotRK9b3Vector3PS0_iPf.exit.i, label %for.body.i.i, !llvm.loop !85

_Z8b3MaxDotRK9b3Vector3PS0_iPf.exit.i:            ; preds = %for.body.i.i
  %spec.store.select.i.i = tail call noundef i32 @llvm.smax.i32(i32 %ptIndex.1.i.i, i32 0)
  %add.i = add nsw i32 %spec.store.select.i.i, %27
  %idxprom5.i = sext i32 %add.i to i64
  %arrayidx6.i = getelementptr inbounds %class.b3Vector3, ptr %cpuVertices, i64 %idxprom5.i
  %retval.sroa.0.0.copyload.i = load <2 x float>, ptr %arrayidx6.i, align 16
  %retval.sroa.3.0.arrayidx6.sroa_idx.i = getelementptr inbounds i8, ptr %arrayidx6.i, i64 8
  %retval.sroa.3.0.copyload.i = load <2 x float>, ptr %retval.sroa.3.0.arrayidx6.sroa_idx.i, align 8
  br label %_Z23b3LocalGetSupportVertexRK9b3Vector3PK22b3ConvexPolyhedronDataPS0_.exit

_Z23b3LocalGetSupportVertexRK9b3Vector3PK22b3ConvexPolyhedronDataPS0_.exit: ; preds = %entry, %_Z8b3MaxDotRK9b3Vector3PS0_iPf.exit.i
  %retval.sroa.0.0.i = phi <2 x float> [ %retval.sroa.0.0.copyload.i, %_Z8b3MaxDotRK9b3Vector3PS0_iPf.exit.i ], [ zeroinitializer, %entry ]
  %retval.sroa.3.0.i = phi <2 x float> [ %retval.sroa.3.0.copyload.i, %_Z8b3MaxDotRK9b3Vector3PS0_iPf.exit.i ], [ zeroinitializer, %entry ]
  %mul4.i.i.i.i.i = fmul float %5, %5
  %34 = tail call float @llvm.fmuladd.f32(float %4, float %4, float %mul4.i.i.i.i.i)
  %35 = tail call float @llvm.fmuladd.f32(float %orn.sroa.5.0.copyload, float %orn.sroa.5.0.copyload, float %34)
  %36 = tail call noundef float @llvm.fmuladd.f32(float %orn.sroa.7.0.copyload, float %orn.sroa.7.0.copyload, float %35)
  %div.i.i.i = fdiv float 2.000000e+00, %36
  %mul6.i.i.i = fmul float %orn.sroa.5.0.copyload, %div.i.i.i
  %mul12.i.i.i = fmul float %orn.sroa.7.0.copyload, %mul6.i.i.i
  %mul18.i.i.i = fmul float %4, %mul6.i.i.i
  %37 = insertelement <2 x float> poison, float %div.i.i.i, i64 0
  %38 = shufflevector <2 x float> %37, <2 x float> poison, <2 x i32> zeroinitializer
  %39 = fmul <2 x float> %0, %38
  %40 = extractelement <2 x float> %39, i64 0
  %mul8.i.i.i = fmul float %orn.sroa.7.0.copyload, %40
  %41 = extractelement <2 x float> %39, i64 1
  %mul10.i.i.i = fmul float %orn.sroa.7.0.copyload, %41
  %mul16.i.i.i = fmul float %4, %41
  %42 = fmul <2 x float> %0, %39
  %mul22.i.i.i = fmul float %5, %mul6.i.i.i
  %mul24.i.i.i = fmul float %orn.sroa.5.0.copyload, %mul6.i.i.i
  %43 = extractelement <2 x float> %42, i64 1
  %add.i.i.i = fadd float %43, %mul24.i.i.i
  %sub.i.i.i = fsub float 1.000000e+00, %add.i.i.i
  %sub26.i.i.i = fsub float %mul16.i.i.i, %mul12.i.i.i
  %add28.i.i.i = fadd float %mul18.i.i.i, %mul10.i.i.i
  %add30.i.i.i = fadd float %mul16.i.i.i, %mul12.i.i.i
  %44 = extractelement <2 x float> %42, i64 0
  %add32.i.i.i = fadd float %44, %mul24.i.i.i
  %sub33.i.i.i = fsub float 1.000000e+00, %add32.i.i.i
  %sub35.i.i.i = fsub float %mul22.i.i.i, %mul8.i.i.i
  %sub37.i.i.i = fsub float %mul18.i.i.i, %mul10.i.i.i
  %add39.i.i.i = fadd float %mul22.i.i.i, %mul8.i.i.i
  %add41.i.i.i = fadd float %44, %43
  %sub42.i.i.i = fsub float 1.000000e+00, %add41.i.i.i
  %pInA.sroa.0.0.vec.extract = extractelement <2 x float> %retval.sroa.0.0.i, i64 0
  %pInA.sroa.0.4.vec.extract = extractelement <2 x float> %retval.sroa.0.0.i, i64 1
  %mul5.i.i.i.i15 = fmul float %sub26.i.i.i, %pInA.sroa.0.4.vec.extract
  %45 = tail call float @llvm.fmuladd.f32(float %pInA.sroa.0.0.vec.extract, float %sub.i.i.i, float %mul5.i.i.i.i15)
  %pInA.sroa.3.8.vec.extract = extractelement <2 x float> %retval.sroa.3.0.i, i64 0
  %46 = tail call noundef float @llvm.fmuladd.f32(float %pInA.sroa.3.8.vec.extract, float %add28.i.i.i, float %45)
  %mul5.i3.i.i.i = fmul float %sub33.i.i.i, %pInA.sroa.0.4.vec.extract
  %47 = tail call float @llvm.fmuladd.f32(float %pInA.sroa.0.0.vec.extract, float %add30.i.i.i, float %mul5.i3.i.i.i)
  %48 = tail call noundef float @llvm.fmuladd.f32(float %pInA.sroa.3.8.vec.extract, float %sub35.i.i.i, float %47)
  %mul5.i8.i.i.i = fmul float %add39.i.i.i, %pInA.sroa.0.4.vec.extract
  %49 = tail call float @llvm.fmuladd.f32(float %pInA.sroa.0.0.vec.extract, float %sub37.i.i.i, float %mul5.i8.i.i.i)
  %50 = tail call noundef float @llvm.fmuladd.f32(float %pInA.sroa.3.8.vec.extract, float %sub42.i.i.i, float %49)
  %add.i.i3.i = fadd float %pos.sroa.0.0.copyload, %46
  %add4.i.i.i = fadd float %pos.sroa.2.0.copyload, %48
  %add7.i.i.i = fadd float %pos.sroa.3.0.copyload, %50
  %retval.sroa.0.0.vec.insert.i.i2.i.i = insertelement <2 x float> poison, float %add.i.i3.i, i64 0
  %retval.sroa.0.4.vec.insert.i.i3.i.i = insertelement <2 x float> %retval.sroa.0.0.vec.insert.i.i2.i.i, float %add4.i.i.i, i64 1
  %retval.sroa.3.12.vec.insert.i.i4.i.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %add7.i.i.i, i64 0
  store <2 x float> %retval.sroa.0.4.vec.insert.i.i3.i.i, ptr %outp, align 16
  %ref.tmp30.sroa.2.0..sroa_idx = getelementptr inbounds i8, ptr %outp, i64 8
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i4.i.i, ptr %ref.tmp30.sroa.2.0..sroa_idx, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef float @_Z22b3MprVec3PointTriDist2PK9b3Vector3S1_S1_S1_PS_(ptr noundef %P, ptr noundef %x0, ptr noundef %B, ptr noundef %C, ptr noundef %witness) local_unnamed_addr #5 comdat {
entry:
  %witness2 = alloca %class.b3Vector3, align 16
  %arrayidx5.i.i = getelementptr inbounds [4 x float], ptr %B, i64 0, i64 2
  %0 = load float, ptr %arrayidx5.i.i, align 8
  %arrayidx6.i.i = getelementptr inbounds [4 x float], ptr %x0, i64 0, i64 2
  %1 = load float, ptr %arrayidx6.i.i, align 8
  %sub7.i.i = fsub float %0, %1
  %2 = load <2 x float>, ptr %B, align 16
  %3 = load <2 x float>, ptr %x0, align 16
  %4 = fsub <2 x float> %2, %3
  %5 = load <2 x float>, ptr %C, align 16
  %6 = fsub <2 x float> %5, %3
  %arrayidx5.i.i73 = getelementptr inbounds [4 x float], ptr %C, i64 0, i64 2
  %7 = load float, ptr %arrayidx5.i.i73, align 8
  %8 = load float, ptr %P, align 16
  %9 = extractelement <2 x float> %3, i64 0
  %sub.i.i80 = fsub float %9, %8
  %arrayidx3.i.i82 = getelementptr inbounds [4 x float], ptr %P, i64 0, i64 1
  %10 = load float, ptr %arrayidx3.i.i82, align 4
  %11 = extractelement <2 x float> %3, i64 1
  %sub4.i.i83 = fsub float %11, %10
  %arrayidx6.i.i85 = getelementptr inbounds [4 x float], ptr %P, i64 0, i64 2
  %12 = load float, ptr %arrayidx6.i.i85, align 8
  %mul5.i.i.i = fmul float %sub4.i.i83, %sub4.i.i83
  %13 = tail call float @llvm.fmuladd.f32(float %sub.i.i80, float %sub.i.i80, float %mul5.i.i.i)
  %14 = extractelement <2 x float> %4, i64 1
  %15 = extractelement <2 x float> %4, i64 0
  %mul5.i.i.i103 = fmul float %14, %sub4.i.i83
  %16 = tail call float @llvm.fmuladd.f32(float %sub.i.i80, float %15, float %mul5.i.i.i103)
  %17 = insertelement <2 x float> poison, float %1, i64 0
  %18 = insertelement <2 x float> %17, float %7, i64 1
  %19 = insertelement <2 x float> poison, float %12, i64 0
  %20 = insertelement <2 x float> %19, float %1, i64 1
  %21 = fsub <2 x float> %18, %20
  %22 = extractelement <2 x float> %21, i64 0
  %23 = tail call noundef float @llvm.fmuladd.f32(float %22, float %22, float %13)
  %24 = tail call noundef float @llvm.fmuladd.f32(float %22, float %sub7.i.i, float %16)
  %25 = shufflevector <2 x float> %6, <2 x float> poison, <2 x i32> <i32 1, i32 1>
  %26 = insertelement <2 x float> %6, float %sub4.i.i83, i64 0
  %27 = fmul <2 x float> %25, %26
  %28 = shufflevector <2 x float> %6, <2 x float> poison, <2 x i32> zeroinitializer
  %29 = insertelement <2 x float> %28, float %sub.i.i80, i64 0
  %30 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %29, <2 x float> %28, <2 x float> %27)
  %31 = shufflevector <2 x float> %21, <2 x float> poison, <2 x i32> <i32 1, i32 1>
  %32 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %21, <2 x float> %31, <2 x float> %30)
  %33 = shufflevector <2 x float> %4, <2 x float> poison, <2 x i32> <i32 1, i32 1>
  %34 = shufflevector <2 x float> %6, <2 x float> %4, <2 x i32> <i32 1, i32 3>
  %35 = fmul <2 x float> %33, %34
  %36 = shufflevector <2 x float> %4, <2 x float> poison, <2 x i32> zeroinitializer
  %37 = shufflevector <2 x float> %6, <2 x float> %4, <2 x i32> <i32 0, i32 2>
  %38 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %36, <2 x float> %37, <2 x float> %35)
  %39 = insertelement <2 x float> poison, float %sub7.i.i, i64 0
  %40 = shufflevector <2 x float> %39, <2 x float> poison, <2 x i32> zeroinitializer
  %41 = shufflevector <2 x float> %21, <2 x float> %39, <2 x i32> <i32 1, i32 2>
  %42 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %40, <2 x float> %41, <2 x float> %38)
  %43 = shufflevector <2 x float> %32, <2 x float> %42, <2 x i32> <i32 1, i32 2>
  %44 = fneg <2 x float> %43
  %45 = shufflevector <2 x float> %42, <2 x float> poison, <2 x i32> <i32 poison, i32 0>
  %46 = insertelement <2 x float> %45, float %24, i64 0
  %47 = fmul <2 x float> %46, %44
  %48 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %32, <2 x float> %42, <2 x float> %47)
  %49 = extractelement <2 x float> %48, i64 0
  %50 = extractelement <2 x float> %48, i64 1
  %div = fdiv float %49, %50
  %fneg = fneg float %div
  %51 = extractelement <2 x float> %32, i64 0
  %neg9 = fneg float %51
  %52 = extractelement <2 x float> %42, i64 0
  %53 = tail call float @llvm.fmuladd.f32(float %fneg, float %52, float %neg9)
  %54 = extractelement <2 x float> %32, i64 1
  %div10 = fdiv float %53, %54
  %55 = tail call noundef float @llvm.fabs.f32(float %div)
  %cmp.i = fcmp olt float %55, 0x3E80000000000000
  %cmp = fcmp ogt float %div, 0.000000e+00
  %or.cond = or i1 %cmp, %cmp.i
  br i1 %or.cond, label %land.lhs.true, label %if.else46

land.lhs.true:                                    ; preds = %entry
  %sub.i = fadd float %div, -1.000000e+00
  %56 = tail call noundef float @llvm.fabs.f32(float %sub.i)
  %cmp.i116 = fcmp olt float %56, 0x3E80000000000000
  br i1 %cmp.i116, label %land.lhs.true16, label %if.end.i

if.end.i:                                         ; preds = %land.lhs.true
  %cmp4.i = fcmp uge float %55, 1.000000e+00
  %mul7.i = fmul float %55, 0x3E80000000000000
  %cmp8.i = fcmp olt float %56, %mul7.i
  %retval.0.shrunk.i = and i1 %cmp4.i, %cmp8.i
  %cmp15 = fcmp olt float %div, 1.000000e+00
  %or.cond1 = or i1 %cmp15, %retval.0.shrunk.i
  br i1 %or.cond1, label %land.lhs.true16, label %if.else46

land.lhs.true16:                                  ; preds = %land.lhs.true, %if.end.i
  %57 = tail call noundef float @llvm.fabs.f32(float %div10)
  %cmp.i117 = fcmp olt float %57, 0x3E80000000000000
  %cmp20 = fcmp ogt float %div10, 0.000000e+00
  %or.cond2 = or i1 %cmp20, %cmp.i117
  br i1 %or.cond2, label %land.lhs.true21, label %if.else46

land.lhs.true21:                                  ; preds = %land.lhs.true16
  %sub.i119 = fadd float %div10, -1.000000e+00
  %58 = tail call noundef float @llvm.fabs.f32(float %sub.i119)
  %cmp.i120 = fcmp olt float %58, 0x3E80000000000000
  br i1 %cmp.i120, label %land.lhs.true26, label %if.end.i121

if.end.i121:                                      ; preds = %land.lhs.true21
  %cmp4.i122 = fcmp uge float %57, 1.000000e+00
  %mul7.i124 = fmul float %57, 0x3E80000000000000
  %cmp8.i125 = fcmp olt float %58, %mul7.i124
  %retval.0.shrunk.i126 = and i1 %cmp4.i122, %cmp8.i125
  %cmp25 = fcmp olt float %div10, 1.000000e+00
  %or.cond3 = or i1 %cmp25, %retval.0.shrunk.i126
  br i1 %or.cond3, label %land.lhs.true26, label %if.else46

land.lhs.true26:                                  ; preds = %land.lhs.true21, %if.end.i121
  %add = fadd float %div, %div10
  %sub.i131 = fadd float %add, -1.000000e+00
  %59 = tail call noundef float @llvm.fabs.f32(float %sub.i131)
  %cmp.i132 = fcmp olt float %59, 0x3E80000000000000
  br i1 %cmp.i132, label %if.then, label %if.end.i133

if.end.i133:                                      ; preds = %land.lhs.true26
  %60 = tail call noundef float @llvm.fabs.f32(float %add)
  %cmp4.i134 = fcmp uge float %60, 1.000000e+00
  %mul7.i136 = fmul float %60, 0x3E80000000000000
  %cmp8.i137 = fcmp olt float %59, %mul7.i136
  %retval.0.shrunk.i138 = and i1 %cmp4.i134, %cmp8.i137
  %cmp31 = fcmp olt float %add, 1.000000e+00
  %or.cond68 = or i1 %cmp31, %retval.0.shrunk.i138
  br i1 %or.cond68, label %if.then, label %if.else46

if.then:                                          ; preds = %land.lhs.true26, %if.end.i133
  %tobool32.not = icmp eq ptr %witness, null
  br i1 %tobool32.not, label %if.else, label %if.then33

if.then33:                                        ; preds = %if.then
  %61 = insertelement <2 x float> poison, float %div, i64 0
  %62 = shufflevector <2 x float> %61, <2 x float> poison, <2 x i32> zeroinitializer
  %63 = fmul <2 x float> %4, %62
  %mul5.i.i = fmul float %sub7.i.i, %div
  %64 = insertelement <2 x float> poison, float %div10, i64 0
  %65 = shufflevector <2 x float> %64, <2 x float> poison, <2 x i32> zeroinitializer
  %66 = fmul <2 x float> %6, %65
  %67 = extractelement <2 x float> %21, i64 1
  %mul5.i.i148 = fmul float %67, %div10
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %witness, ptr noundef nonnull align 16 dereferenceable(16) %x0, i64 16, i1 false)
  %z4.i = getelementptr inbounds %struct.anon.2, ptr %witness, i64 0, i32 2
  %68 = load float, ptr %z4.i, align 8
  %add5.i = fadd float %mul5.i.i, %68
  %69 = load <2 x float>, ptr %witness, align 16
  %70 = fadd <2 x float> %63, %69
  %71 = fadd <2 x float> %66, %70
  store <2 x float> %71, ptr %witness, align 16
  %add5.i155 = fadd float %mul5.i.i148, %add5.i
  store float %add5.i155, ptr %z4.i, align 8
  %72 = load float, ptr %P, align 16
  %73 = extractelement <2 x float> %71, i64 0
  %sub.i.i.i = fsub float %73, %72
  %74 = load float, ptr %arrayidx3.i.i82, align 4
  %75 = extractelement <2 x float> %71, i64 1
  %sub4.i.i.i = fsub float %75, %74
  %76 = load float, ptr %arrayidx6.i.i85, align 8
  %sub7.i.i.i = fsub float %add5.i155, %76
  %mul5.i.i.i.i.i = fmul float %sub4.i.i.i, %sub4.i.i.i
  %77 = tail call float @llvm.fmuladd.f32(float %sub.i.i.i, float %sub.i.i.i, float %mul5.i.i.i.i.i)
  %78 = tail call noundef float @llvm.fmuladd.f32(float %sub7.i.i.i, float %sub7.i.i.i, float %77)
  br label %if.end62

if.else:                                          ; preds = %if.then
  %mul = fmul float %div, %div
  %79 = extractelement <2 x float> %42, i64 1
  %mul35 = fmul float %79, %mul
  %mul36 = fmul float %div10, %div10
  %80 = tail call float @llvm.fmuladd.f32(float %mul36, float %54, float %mul35)
  %mul38 = fmul float %div, 2.000000e+00
  %mul39 = fmul float %mul38, %div10
  %81 = tail call float @llvm.fmuladd.f32(float %mul39, float %52, float %80)
  %82 = tail call float @llvm.fmuladd.f32(float %mul38, float %24, float %81)
  %mul43 = fmul float %div10, 2.000000e+00
  %83 = tail call float @llvm.fmuladd.f32(float %mul43, float %51, float %82)
  %add45 = fadd float %23, %83
  br label %if.end62

if.else46:                                        ; preds = %if.end.i133, %if.end.i121, %land.lhs.true16, %if.end.i, %entry
  %call47 = tail call noundef float @_Z27_b3MprVec3PointSegmentDist2PK9b3Vector3S1_S1_PS_(ptr noundef nonnull %P, ptr noundef nonnull %x0, ptr noundef nonnull %B, ptr noundef %witness)
  %call48 = call noundef float @_Z27_b3MprVec3PointSegmentDist2PK9b3Vector3S1_S1_PS_(ptr noundef nonnull %P, ptr noundef nonnull %x0, ptr noundef nonnull %C, ptr noundef nonnull %witness2)
  %cmp49 = fcmp olt float %call48, %call47
  br i1 %cmp49, label %if.then50, label %if.end54

if.then50:                                        ; preds = %if.else46
  %tobool51.not = icmp eq ptr %witness, null
  br i1 %tobool51.not, label %if.end54.thread, label %if.then52

if.then52:                                        ; preds = %if.then50
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %witness, ptr noundef nonnull align 16 dereferenceable(16) %witness2, i64 16, i1 false)
  br label %if.end54

if.end54:                                         ; preds = %if.then52, %if.else46
  %dist.0 = phi float [ %call48, %if.then52 ], [ %call47, %if.else46 ]
  %call55 = call noundef float @_Z27_b3MprVec3PointSegmentDist2PK9b3Vector3S1_S1_PS_(ptr noundef nonnull %P, ptr noundef nonnull %B, ptr noundef nonnull %C, ptr noundef nonnull %witness2)
  %cmp56 = fcmp olt float %call55, %dist.0
  br i1 %cmp56, label %if.then57, label %if.end62

if.end54.thread:                                  ; preds = %if.then50
  %call55255 = call noundef float @_Z27_b3MprVec3PointSegmentDist2PK9b3Vector3S1_S1_PS_(ptr noundef nonnull %P, ptr noundef nonnull %B, ptr noundef nonnull %C, ptr noundef nonnull %witness2)
  %cmp56256 = fcmp olt float %call55255, %call48
  br i1 %cmp56256, label %if.then57.thread, label %if.end62

if.then57.thread:                                 ; preds = %if.end54.thread
  br label %if.end62

if.then57:                                        ; preds = %if.end54
  %tobool58.not = icmp eq ptr %witness, null
  br i1 %tobool58.not, label %if.end62, label %if.then59

if.then59:                                        ; preds = %if.then57
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %witness, ptr noundef nonnull align 16 dereferenceable(16) %witness2, i64 16, i1 false)
  br label %if.end62

if.end62:                                         ; preds = %if.then57.thread, %if.end54.thread, %if.end54, %if.then59, %if.then57, %if.then33, %if.else
  %dist.1 = phi float [ %78, %if.then33 ], [ %add45, %if.else ], [ %call55, %if.then59 ], [ %call55, %if.then57 ], [ %dist.0, %if.end54 ], [ %call48, %if.end54.thread ], [ %call55255, %if.then57.thread ]
  ret float %dist.1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef float @_Z27_b3MprVec3PointSegmentDist2PK9b3Vector3S1_S1_PS_(ptr noundef %P, ptr noundef %x0, ptr noundef %b, ptr noundef %witness) local_unnamed_addr #5 comdat {
entry:
  %arrayidx3.i.i = getelementptr inbounds [4 x float], ptr %x0, i64 0, i64 1
  %0 = load <2 x float>, ptr %b, align 16
  %1 = load <2 x float>, ptr %x0, align 16
  %2 = fsub <2 x float> %0, %1
  %arrayidx5.i.i = getelementptr inbounds [4 x float], ptr %b, i64 0, i64 2
  %3 = load float, ptr %arrayidx5.i.i, align 8
  %arrayidx6.i.i = getelementptr inbounds [4 x float], ptr %x0, i64 0, i64 2
  %4 = load float, ptr %arrayidx6.i.i, align 8
  %sub7.i.i = fsub float %3, %4
  %retval.sroa.3.12.vec.insert.i.i.i = insertelement <2 x float> <float poison, float 0.000000e+00>, float %sub7.i.i, i64 0
  %5 = load float, ptr %P, align 16
  %6 = extractelement <2 x float> %1, i64 0
  %sub.i.i24 = fsub float %6, %5
  %arrayidx3.i.i26 = getelementptr inbounds [4 x float], ptr %P, i64 0, i64 1
  %7 = load float, ptr %arrayidx3.i.i26, align 4
  %8 = extractelement <2 x float> %1, i64 1
  %sub4.i.i27 = fsub float %8, %7
  %arrayidx6.i.i29 = getelementptr inbounds [4 x float], ptr %P, i64 0, i64 2
  %9 = load float, ptr %arrayidx6.i.i29, align 8
  %sub7.i.i30 = fsub float %4, %9
  %10 = extractelement <2 x float> %2, i64 1
  %mul5.i.i.i = fmul float %10, %sub4.i.i27
  %11 = extractelement <2 x float> %2, i64 0
  %12 = tail call float @llvm.fmuladd.f32(float %sub.i.i24, float %11, float %mul5.i.i.i)
  %13 = tail call noundef float @llvm.fmuladd.f32(float %sub7.i.i30, float %sub7.i.i, float %12)
  %mul = fneg float %13
  %mul5.i.i.i.i = fmul float %10, %10
  %14 = tail call float @llvm.fmuladd.f32(float %11, float %11, float %mul5.i.i.i.i)
  %15 = tail call noundef float @llvm.fmuladd.f32(float %sub7.i.i, float %sub7.i.i, float %14)
  %div = fdiv float %mul, %15
  %cmp = fcmp olt float %div, 0.000000e+00
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %16 = tail call noundef float @llvm.fabs.f32(float %div)
  %cmp.i = fcmp uge float %16, 0x3E80000000000000
  br i1 %cmp.i, label %if.else, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %mul5.i.i.i.i.i = fmul float %sub4.i.i27, %sub4.i.i27
  %17 = tail call float @llvm.fmuladd.f32(float %sub.i.i24, float %sub.i.i24, float %mul5.i.i.i.i.i)
  %18 = tail call noundef float @llvm.fmuladd.f32(float %sub7.i.i30, float %sub7.i.i30, float %17)
  %tobool4.not = icmp eq ptr %witness, null
  br i1 %tobool4.not, label %if.end23, label %if.then5

if.then5:                                         ; preds = %if.then
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %witness, ptr noundef nonnull align 16 dereferenceable(16) %x0, i64 16, i1 false)
  br label %if.end23

if.else:                                          ; preds = %lor.lhs.false
  %cmp6 = fcmp ogt float %div, 1.000000e+00
  br i1 %cmp6, label %if.then10, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %if.else
  %sub.i = fadd float %div, -1.000000e+00
  %19 = tail call noundef float @llvm.fabs.f32(float %sub.i)
  %cmp.i37 = fcmp olt float %19, 0x3E80000000000000
  br i1 %cmp.i37, label %if.then10, label %if.end.i

if.end.i:                                         ; preds = %lor.lhs.false7
  %cmp4.i = fcmp olt float %16, 1.000000e+00
  %mul7.i = fmul float %16, 0x3E80000000000000
  %cmp8.i = fcmp uge float %19, %mul7.i
  %or.cond = or i1 %cmp4.i, %cmp8.i
  br i1 %or.cond, label %if.else15, label %if.then10

if.then10:                                        ; preds = %if.end.i, %lor.lhs.false7, %if.else
  %20 = extractelement <2 x float> %0, i64 0
  %sub.i.i.i38 = fsub float %20, %5
  %21 = extractelement <2 x float> %0, i64 1
  %sub4.i.i.i41 = fsub float %21, %7
  %sub7.i.i.i44 = fsub float %3, %9
  %mul5.i.i.i.i.i45 = fmul float %sub4.i.i.i41, %sub4.i.i.i41
  %22 = tail call float @llvm.fmuladd.f32(float %sub.i.i.i38, float %sub.i.i.i38, float %mul5.i.i.i.i.i45)
  %23 = tail call noundef float @llvm.fmuladd.f32(float %sub7.i.i.i44, float %sub7.i.i.i44, float %22)
  %tobool12.not = icmp eq ptr %witness, null
  br i1 %tobool12.not, label %if.end23, label %if.then13

if.then13:                                        ; preds = %if.then10
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %witness, ptr noundef nonnull align 16 dereferenceable(16) %b, i64 16, i1 false)
  br label %if.end23

if.else15:                                        ; preds = %if.end.i
  %tobool16.not = icmp eq ptr %witness, null
  br i1 %tobool16.not, label %if.else19, label %if.then17

if.then17:                                        ; preds = %if.else15
  %d.sroa.16.0.witness.sroa_idx = getelementptr inbounds i8, ptr %witness, i64 8
  store <2 x float> %retval.sroa.3.12.vec.insert.i.i.i, ptr %d.sroa.16.0.witness.sroa_idx, align 8
  %24 = insertelement <2 x float> poison, float %div, i64 0
  %25 = shufflevector <2 x float> %24, <2 x float> poison, <2 x i32> zeroinitializer
  %26 = fmul <2 x float> %25, %2
  %arrayidx2.i.i46 = getelementptr inbounds [4 x float], ptr %witness, i64 0, i64 1
  store <2 x float> %26, ptr %witness, align 16
  %mul5.i.i = fmul float %div, %sub7.i.i
  store float %mul5.i.i, ptr %d.sroa.16.0.witness.sroa_idx, align 8
  %27 = load float, ptr %x0, align 16
  %28 = extractelement <2 x float> %26, i64 0
  %add.i = fadd float %28, %27
  store float %add.i, ptr %witness, align 16
  %29 = load float, ptr %arrayidx3.i.i, align 4
  %30 = extractelement <2 x float> %26, i64 1
  %add3.i = fadd float %30, %29
  store float %add3.i, ptr %arrayidx2.i.i46, align 4
  %31 = load float, ptr %arrayidx6.i.i, align 8
  %add5.i = fadd float %mul5.i.i, %31
  store float %add5.i, ptr %d.sroa.16.0.witness.sroa_idx, align 8
  %32 = load float, ptr %P, align 16
  %sub.i.i.i47 = fsub float %add.i, %32
  %33 = load float, ptr %arrayidx3.i.i26, align 4
  %sub4.i.i.i50 = fsub float %add3.i, %33
  %34 = load float, ptr %arrayidx6.i.i29, align 8
  %sub7.i.i.i53 = fsub float %add5.i, %34
  %mul5.i.i.i.i.i54 = fmul float %sub4.i.i.i50, %sub4.i.i.i50
  %35 = tail call float @llvm.fmuladd.f32(float %sub.i.i.i47, float %sub.i.i.i47, float %mul5.i.i.i.i.i54)
  %36 = tail call noundef float @llvm.fmuladd.f32(float %sub7.i.i.i53, float %sub7.i.i.i53, float %35)
  br label %if.end23

if.else19:                                        ; preds = %if.else15
  %mul.i.i55 = fmul float %11, %div
  %mul3.i.i57 = fmul float %10, %div
  %mul5.i.i59 = fmul float %sub7.i.i, %div
  %add.i60 = fadd float %sub.i.i24, %mul.i.i55
  %add3.i63 = fadd float %sub4.i.i27, %mul3.i.i57
  %add5.i66 = fadd float %sub7.i.i30, %mul5.i.i59
  %mul5.i.i.i.i68 = fmul float %add3.i63, %add3.i63
  %37 = tail call float @llvm.fmuladd.f32(float %add.i60, float %add.i60, float %mul5.i.i.i.i68)
  %38 = tail call noundef float @llvm.fmuladd.f32(float %add5.i66, float %add5.i66, float %37)
  br label %if.end23

if.end23:                                         ; preds = %if.then13, %if.then10, %if.else19, %if.then17, %if.then, %if.then5
  %dist.0 = phi float [ %18, %if.then5 ], [ %18, %if.then ], [ %23, %if.then13 ], [ %23, %if.then10 ], [ %36, %if.then17 ], [ %38, %if.else19 ]
  ret float %dist.0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN13b3OpenCLArrayI9b3Vector3E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %this, i64 noundef %_Count, i1 noundef zeroext %copyOldContents) local_unnamed_addr #8 comdat align 2 {
entry:
  %ciErrNum = alloca i32, align 4
  %m_capacity.i = getelementptr inbounds %class.b3OpenCLArray, ptr %this, i64 0, i32 2
  %0 = load i64, ptr %m_capacity.i, align 8
  %cmp = icmp ult i64 %0, %_Count
  br i1 %cmp, label %if.then, label %if.end14

if.then:                                          ; preds = %entry
  %m_allowGrowingCapacity = getelementptr inbounds %class.b3OpenCLArray, ptr %this, i64 0, i32 7
  %1 = load i8, ptr %m_allowGrowingCapacity, align 1
  %2 = and i8 %1, 1
  %tobool.not = icmp eq i8 %2, 0
  br i1 %tobool.not, label %if.else, label %if.then2

if.then2:                                         ; preds = %if.then
  %mul = shl i64 %_Count, 4
  %3 = load ptr, ptr @__clewCreateBuffer, align 8
  %m_clContext = getelementptr inbounds %class.b3OpenCLArray, ptr %this, i64 0, i32 4
  %4 = load ptr, ptr %m_clContext, align 8
  %call3 = call ptr %3(ptr noundef %4, i64 noundef 1, i64 noundef %mul, ptr noundef null, ptr noundef nonnull %ciErrNum)
  %5 = load i32, ptr %ciErrNum, align 4
  %cmp4.not.not = icmp eq i32 %5, 0
  br i1 %cmp4.not.not, label %if.end, label %if.end.thread

if.end.thread:                                    ; preds = %if.then2
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 166)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.76)
  br label %if.end12

if.end:                                           ; preds = %if.then2
  br i1 %copyOldContents, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.end
  %m_size.i = getelementptr inbounds %class.b3OpenCLArray, ptr %this, i64 0, i32 1
  %6 = load i64, ptr %m_size.i, align 8
  %cmp.i = icmp eq i64 %6, 0
  br i1 %cmp.i, label %if.end12, label %if.end.i

if.end.i:                                         ; preds = %if.then9
  %7 = load ptr, ptr @__clewEnqueueCopyBuffer, align 8
  %m_commandQueue.i = getelementptr inbounds %class.b3OpenCLArray, ptr %this, i64 0, i32 5
  %8 = load ptr, ptr %m_commandQueue.i, align 8
  %m_clBuffer.i = getelementptr inbounds %class.b3OpenCLArray, ptr %this, i64 0, i32 3
  %9 = load ptr, ptr %m_clBuffer.i, align 8
  %mul3.i = shl i64 %6, 4
  %call.i = call i32 %7(ptr noundef %8, ptr noundef %9, ptr noundef %call3, i64 noundef 0, i64 noundef 0, i64 noundef %mul3.i, i32 noundef 0, ptr noundef null, ptr noundef null)
  br label %if.end12

if.end12:                                         ; preds = %if.end.i, %if.then9, %if.end.thread, %if.end
  %_Count.addr.023 = phi i64 [ 0, %if.end.thread ], [ %_Count, %if.end ], [ %_Count, %if.then9 ], [ %_Count, %if.end.i ]
  %m_clBuffer.i5 = getelementptr inbounds %class.b3OpenCLArray, ptr %this, i64 0, i32 3
  %10 = load ptr, ptr %m_clBuffer.i5, align 8
  %tobool.not.i = icmp eq ptr %10, null
  br i1 %tobool.not.i, label %_ZN13b3OpenCLArrayI9b3Vector3E10deallocateEv.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end12
  %m_ownsMemory.i = getelementptr inbounds %class.b3OpenCLArray, ptr %this, i64 0, i32 6
  %11 = load i8, ptr %m_ownsMemory.i, align 8
  %12 = and i8 %11, 1
  %tobool2.not.i = icmp eq i8 %12, 0
  br i1 %tobool2.not.i, label %_ZN13b3OpenCLArrayI9b3Vector3E10deallocateEv.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i
  %13 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i6 = call i32 %13(ptr noundef nonnull %10)
  br label %_ZN13b3OpenCLArrayI9b3Vector3E10deallocateEv.exit

_ZN13b3OpenCLArrayI9b3Vector3E10deallocateEv.exit: ; preds = %if.end12, %land.lhs.true.i, %if.then.i
  store ptr %call3, ptr %m_clBuffer.i5, align 8
  store i64 %_Count.addr.023, ptr %m_capacity.i, align 8
  br label %if.end14

if.else:                                          ; preds = %if.then
  %m_clBuffer.i9 = getelementptr inbounds %class.b3OpenCLArray, ptr %this, i64 0, i32 3
  %14 = load ptr, ptr %m_clBuffer.i9, align 8
  %tobool.not.i10 = icmp eq ptr %14, null
  br i1 %tobool.not.i10, label %_ZN13b3OpenCLArrayI9b3Vector3E10deallocateEv.exit18, label %land.lhs.true.i11

land.lhs.true.i11:                                ; preds = %if.else
  %m_ownsMemory.i12 = getelementptr inbounds %class.b3OpenCLArray, ptr %this, i64 0, i32 6
  %15 = load i8, ptr %m_ownsMemory.i12, align 8
  %16 = and i8 %15, 1
  %tobool2.not.i13 = icmp eq i8 %16, 0
  br i1 %tobool2.not.i13, label %_ZN13b3OpenCLArrayI9b3Vector3E10deallocateEv.exit18, label %if.then.i14

if.then.i14:                                      ; preds = %land.lhs.true.i11
  %17 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i15 = tail call i32 %17(ptr noundef nonnull %14)
  br label %_ZN13b3OpenCLArrayI9b3Vector3E10deallocateEv.exit18

_ZN13b3OpenCLArrayI9b3Vector3E10deallocateEv.exit18: ; preds = %if.else, %land.lhs.true.i11, %if.then.i14
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %m_capacity.i, i8 0, i64 16, i1 false)
  br label %if.end14

if.end14:                                         ; preds = %_ZN13b3OpenCLArrayI9b3Vector3E10deallocateEv.exit, %_ZN13b3OpenCLArrayI9b3Vector3E10deallocateEv.exit18, %entry
  %result.1 = phi i1 [ %cmp4.not.not, %_ZN13b3OpenCLArrayI9b3Vector3E10deallocateEv.exit ], [ false, %_ZN13b3OpenCLArrayI9b3Vector3E10deallocateEv.exit18 ], [ true, %entry ]
  ret i1 %result.1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayI9b3Vector3ED0Ev(ptr noundef nonnull align 8 dereferenceable(50) %this) unnamed_addr #10 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayI9b3Vector3E, i64 0, inrange i32 0, i64 2), ptr %this, align 8
  %m_clBuffer.i.i = getelementptr inbounds %class.b3OpenCLArray, ptr %this, i64 0, i32 3
  %0 = load ptr, ptr %m_clBuffer.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %0, null
  br i1 %tobool.not.i.i, label %_ZN13b3OpenCLArrayI9b3Vector3ED2Ev.exit, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %entry
  %m_ownsMemory.i.i = getelementptr inbounds %class.b3OpenCLArray, ptr %this, i64 0, i32 6
  %1 = load i8, ptr %m_ownsMemory.i.i, align 8
  %2 = and i8 %1, 1
  %tobool2.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool2.not.i.i, label %_ZN13b3OpenCLArrayI9b3Vector3ED2Ev.exit, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.lhs.true.i.i
  %3 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i1.i = invoke i32 %3(ptr noundef nonnull %0)
          to label %_ZN13b3OpenCLArrayI9b3Vector3ED2Ev.exit unwind label %terminate.lpad.i

terminate.lpad.i:                                 ; preds = %if.then.i.i
  %4 = landingpad { ptr, i32 }
          catch ptr null
  %5 = extractvalue { ptr, i32 } %4, 0
  tail call void @__clang_call_terminate(ptr %5) #27
  unreachable

_ZN13b3OpenCLArrayI9b3Vector3ED2Ev.exit:          ; preds = %entry, %land.lhs.true.i.i, %if.then.i.i
  tail call void @_ZdlPv(ptr noundef nonnull %this) #28
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN13b3OpenCLArrayIiE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %this, i64 noundef %_Count, i1 noundef zeroext %copyOldContents) local_unnamed_addr #8 comdat align 2 {
entry:
  %ciErrNum = alloca i32, align 4
  %m_capacity.i = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this, i64 0, i32 2
  %0 = load i64, ptr %m_capacity.i, align 8
  %cmp = icmp ult i64 %0, %_Count
  br i1 %cmp, label %if.then, label %if.end14

if.then:                                          ; preds = %entry
  %m_allowGrowingCapacity = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this, i64 0, i32 7
  %1 = load i8, ptr %m_allowGrowingCapacity, align 1
  %2 = and i8 %1, 1
  %tobool.not = icmp eq i8 %2, 0
  br i1 %tobool.not, label %if.else, label %if.then2

if.then2:                                         ; preds = %if.then
  %mul = shl i64 %_Count, 2
  %3 = load ptr, ptr @__clewCreateBuffer, align 8
  %m_clContext = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this, i64 0, i32 4
  %4 = load ptr, ptr %m_clContext, align 8
  %call3 = call ptr %3(ptr noundef %4, i64 noundef 1, i64 noundef %mul, ptr noundef null, ptr noundef nonnull %ciErrNum)
  %5 = load i32, ptr %ciErrNum, align 4
  %cmp4.not.not = icmp eq i32 %5, 0
  br i1 %cmp4.not.not, label %if.end, label %if.end.thread

if.end.thread:                                    ; preds = %if.then2
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 166)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.76)
  br label %if.end12

if.end:                                           ; preds = %if.then2
  br i1 %copyOldContents, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.end
  %m_size.i = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this, i64 0, i32 1
  %6 = load i64, ptr %m_size.i, align 8
  %cmp.i = icmp eq i64 %6, 0
  br i1 %cmp.i, label %if.end12, label %if.end.i

if.end.i:                                         ; preds = %if.then9
  %7 = load ptr, ptr @__clewEnqueueCopyBuffer, align 8
  %m_commandQueue.i = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this, i64 0, i32 5
  %8 = load ptr, ptr %m_commandQueue.i, align 8
  %m_clBuffer.i = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this, i64 0, i32 3
  %9 = load ptr, ptr %m_clBuffer.i, align 8
  %mul3.i = shl i64 %6, 2
  %call.i = call i32 %7(ptr noundef %8, ptr noundef %9, ptr noundef %call3, i64 noundef 0, i64 noundef 0, i64 noundef %mul3.i, i32 noundef 0, ptr noundef null, ptr noundef null)
  br label %if.end12

if.end12:                                         ; preds = %if.end.i, %if.then9, %if.end.thread, %if.end
  %_Count.addr.023 = phi i64 [ 0, %if.end.thread ], [ %_Count, %if.end ], [ %_Count, %if.then9 ], [ %_Count, %if.end.i ]
  %m_clBuffer.i5 = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this, i64 0, i32 3
  %10 = load ptr, ptr %m_clBuffer.i5, align 8
  %tobool.not.i = icmp eq ptr %10, null
  br i1 %tobool.not.i, label %_ZN13b3OpenCLArrayIiE10deallocateEv.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end12
  %m_ownsMemory.i = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this, i64 0, i32 6
  %11 = load i8, ptr %m_ownsMemory.i, align 8
  %12 = and i8 %11, 1
  %tobool2.not.i = icmp eq i8 %12, 0
  br i1 %tobool2.not.i, label %_ZN13b3OpenCLArrayIiE10deallocateEv.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i
  %13 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i6 = call i32 %13(ptr noundef nonnull %10)
  br label %_ZN13b3OpenCLArrayIiE10deallocateEv.exit

_ZN13b3OpenCLArrayIiE10deallocateEv.exit:         ; preds = %if.end12, %land.lhs.true.i, %if.then.i
  store ptr %call3, ptr %m_clBuffer.i5, align 8
  store i64 %_Count.addr.023, ptr %m_capacity.i, align 8
  br label %if.end14

if.else:                                          ; preds = %if.then
  %m_clBuffer.i9 = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this, i64 0, i32 3
  %14 = load ptr, ptr %m_clBuffer.i9, align 8
  %tobool.not.i10 = icmp eq ptr %14, null
  br i1 %tobool.not.i10, label %_ZN13b3OpenCLArrayIiE10deallocateEv.exit18, label %land.lhs.true.i11

land.lhs.true.i11:                                ; preds = %if.else
  %m_ownsMemory.i12 = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this, i64 0, i32 6
  %15 = load i8, ptr %m_ownsMemory.i12, align 8
  %16 = and i8 %15, 1
  %tobool2.not.i13 = icmp eq i8 %16, 0
  br i1 %tobool2.not.i13, label %_ZN13b3OpenCLArrayIiE10deallocateEv.exit18, label %if.then.i14

if.then.i14:                                      ; preds = %land.lhs.true.i11
  %17 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i15 = tail call i32 %17(ptr noundef nonnull %14)
  br label %_ZN13b3OpenCLArrayIiE10deallocateEv.exit18

_ZN13b3OpenCLArrayIiE10deallocateEv.exit18:       ; preds = %if.else, %land.lhs.true.i11, %if.then.i14
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %m_capacity.i, i8 0, i64 16, i1 false)
  br label %if.end14

if.end14:                                         ; preds = %_ZN13b3OpenCLArrayIiE10deallocateEv.exit, %_ZN13b3OpenCLArrayIiE10deallocateEv.exit18, %entry
  %result.1 = phi i1 [ %cmp4.not.not, %_ZN13b3OpenCLArrayIiE10deallocateEv.exit ], [ false, %_ZN13b3OpenCLArrayIiE10deallocateEv.exit18 ], [ true, %entry ]
  ret i1 %result.1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayIiED0Ev(ptr noundef nonnull align 8 dereferenceable(50) %this) unnamed_addr #10 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayIiE, i64 0, inrange i32 0, i64 2), ptr %this, align 8
  %m_clBuffer.i.i = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this, i64 0, i32 3
  %0 = load ptr, ptr %m_clBuffer.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %0, null
  br i1 %tobool.not.i.i, label %_ZN13b3OpenCLArrayIiED2Ev.exit, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %entry
  %m_ownsMemory.i.i = getelementptr inbounds %class.b3OpenCLArray.13, ptr %this, i64 0, i32 6
  %1 = load i8, ptr %m_ownsMemory.i.i, align 8
  %2 = and i8 %1, 1
  %tobool2.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool2.not.i.i, label %_ZN13b3OpenCLArrayIiED2Ev.exit, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.lhs.true.i.i
  %3 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i1.i = invoke i32 %3(ptr noundef nonnull %0)
          to label %_ZN13b3OpenCLArrayIiED2Ev.exit unwind label %terminate.lpad.i

terminate.lpad.i:                                 ; preds = %if.then.i.i
  %4 = landingpad { ptr, i32 }
          catch ptr null
  %5 = extractvalue { ptr, i32 } %4, 0
  tail call void @__clang_call_terminate(ptr %5) #27
  unreachable

_ZN13b3OpenCLArrayIiED2Ev.exit:                   ; preds = %entry, %land.lhs.true.i.i, %if.then.i.i
  tail call void @_ZdlPv(ptr noundef nonnull %this) #28
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN13b3OpenCLArrayIfE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %this, i64 noundef %_Count, i1 noundef zeroext %copyOldContents) local_unnamed_addr #8 comdat align 2 {
entry:
  %ciErrNum = alloca i32, align 4
  %m_capacity.i = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this, i64 0, i32 2
  %0 = load i64, ptr %m_capacity.i, align 8
  %cmp = icmp ult i64 %0, %_Count
  br i1 %cmp, label %if.then, label %if.end14

if.then:                                          ; preds = %entry
  %m_allowGrowingCapacity = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this, i64 0, i32 7
  %1 = load i8, ptr %m_allowGrowingCapacity, align 1
  %2 = and i8 %1, 1
  %tobool.not = icmp eq i8 %2, 0
  br i1 %tobool.not, label %if.else, label %if.then2

if.then2:                                         ; preds = %if.then
  %mul = shl i64 %_Count, 2
  %3 = load ptr, ptr @__clewCreateBuffer, align 8
  %m_clContext = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this, i64 0, i32 4
  %4 = load ptr, ptr %m_clContext, align 8
  %call3 = call ptr %3(ptr noundef %4, i64 noundef 1, i64 noundef %mul, ptr noundef null, ptr noundef nonnull %ciErrNum)
  %5 = load i32, ptr %ciErrNum, align 4
  %cmp4.not.not = icmp eq i32 %5, 0
  br i1 %cmp4.not.not, label %if.end, label %if.end.thread

if.end.thread:                                    ; preds = %if.then2
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 166)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.76)
  br label %if.end12

if.end:                                           ; preds = %if.then2
  br i1 %copyOldContents, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.end
  %m_size.i = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this, i64 0, i32 1
  %6 = load i64, ptr %m_size.i, align 8
  %cmp.i = icmp eq i64 %6, 0
  br i1 %cmp.i, label %if.end12, label %if.end.i

if.end.i:                                         ; preds = %if.then9
  %7 = load ptr, ptr @__clewEnqueueCopyBuffer, align 8
  %m_commandQueue.i = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this, i64 0, i32 5
  %8 = load ptr, ptr %m_commandQueue.i, align 8
  %m_clBuffer.i = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this, i64 0, i32 3
  %9 = load ptr, ptr %m_clBuffer.i, align 8
  %mul3.i = shl i64 %6, 2
  %call.i = call i32 %7(ptr noundef %8, ptr noundef %9, ptr noundef %call3, i64 noundef 0, i64 noundef 0, i64 noundef %mul3.i, i32 noundef 0, ptr noundef null, ptr noundef null)
  br label %if.end12

if.end12:                                         ; preds = %if.end.i, %if.then9, %if.end.thread, %if.end
  %_Count.addr.023 = phi i64 [ 0, %if.end.thread ], [ %_Count, %if.end ], [ %_Count, %if.then9 ], [ %_Count, %if.end.i ]
  %m_clBuffer.i5 = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this, i64 0, i32 3
  %10 = load ptr, ptr %m_clBuffer.i5, align 8
  %tobool.not.i = icmp eq ptr %10, null
  br i1 %tobool.not.i, label %_ZN13b3OpenCLArrayIfE10deallocateEv.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end12
  %m_ownsMemory.i = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this, i64 0, i32 6
  %11 = load i8, ptr %m_ownsMemory.i, align 8
  %12 = and i8 %11, 1
  %tobool2.not.i = icmp eq i8 %12, 0
  br i1 %tobool2.not.i, label %_ZN13b3OpenCLArrayIfE10deallocateEv.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i
  %13 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i6 = call i32 %13(ptr noundef nonnull %10)
  br label %_ZN13b3OpenCLArrayIfE10deallocateEv.exit

_ZN13b3OpenCLArrayIfE10deallocateEv.exit:         ; preds = %if.end12, %land.lhs.true.i, %if.then.i
  store ptr %call3, ptr %m_clBuffer.i5, align 8
  store i64 %_Count.addr.023, ptr %m_capacity.i, align 8
  br label %if.end14

if.else:                                          ; preds = %if.then
  %m_clBuffer.i9 = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this, i64 0, i32 3
  %14 = load ptr, ptr %m_clBuffer.i9, align 8
  %tobool.not.i10 = icmp eq ptr %14, null
  br i1 %tobool.not.i10, label %_ZN13b3OpenCLArrayIfE10deallocateEv.exit18, label %land.lhs.true.i11

land.lhs.true.i11:                                ; preds = %if.else
  %m_ownsMemory.i12 = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this, i64 0, i32 6
  %15 = load i8, ptr %m_ownsMemory.i12, align 8
  %16 = and i8 %15, 1
  %tobool2.not.i13 = icmp eq i8 %16, 0
  br i1 %tobool2.not.i13, label %_ZN13b3OpenCLArrayIfE10deallocateEv.exit18, label %if.then.i14

if.then.i14:                                      ; preds = %land.lhs.true.i11
  %17 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i15 = tail call i32 %17(ptr noundef nonnull %14)
  br label %_ZN13b3OpenCLArrayIfE10deallocateEv.exit18

_ZN13b3OpenCLArrayIfE10deallocateEv.exit18:       ; preds = %if.else, %land.lhs.true.i11, %if.then.i14
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %m_capacity.i, i8 0, i64 16, i1 false)
  br label %if.end14

if.end14:                                         ; preds = %_ZN13b3OpenCLArrayIfE10deallocateEv.exit, %_ZN13b3OpenCLArrayIfE10deallocateEv.exit18, %entry
  %result.1 = phi i1 [ %cmp4.not.not, %_ZN13b3OpenCLArrayIfE10deallocateEv.exit ], [ false, %_ZN13b3OpenCLArrayIfE10deallocateEv.exit18 ], [ true, %entry ]
  ret i1 %result.1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayIfED0Ev(ptr noundef nonnull align 8 dereferenceable(50) %this) unnamed_addr #10 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayIfE, i64 0, inrange i32 0, i64 2), ptr %this, align 8
  %m_clBuffer.i.i = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this, i64 0, i32 3
  %0 = load ptr, ptr %m_clBuffer.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %0, null
  br i1 %tobool.not.i.i, label %_ZN13b3OpenCLArrayIfED2Ev.exit, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %entry
  %m_ownsMemory.i.i = getelementptr inbounds %class.b3OpenCLArray.15, ptr %this, i64 0, i32 6
  %1 = load i8, ptr %m_ownsMemory.i.i, align 8
  %2 = and i8 %1, 1
  %tobool2.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool2.not.i.i, label %_ZN13b3OpenCLArrayIfED2Ev.exit, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.lhs.true.i.i
  %3 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i1.i = invoke i32 %3(ptr noundef nonnull %0)
          to label %_ZN13b3OpenCLArrayIfED2Ev.exit unwind label %terminate.lpad.i

terminate.lpad.i:                                 ; preds = %if.then.i.i
  %4 = landingpad { ptr, i32 }
          catch ptr null
  %5 = extractvalue { ptr, i32 } %4, 0
  tail call void @__clang_call_terminate(ptr %5) #27
  unreachable

_ZN13b3OpenCLArrayIfED2Ev.exit:                   ; preds = %entry, %land.lhs.true.i.i, %if.then.i.i
  tail call void @_ZdlPv(ptr noundef nonnull %this) #28
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %this, i64 noundef %_Count, i1 noundef zeroext %copyOldContents) local_unnamed_addr #8 comdat align 2 {
entry:
  %ciErrNum = alloca i32, align 4
  %m_capacity.i = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this, i64 0, i32 2
  %0 = load i64, ptr %m_capacity.i, align 8
  %cmp = icmp ult i64 %0, %_Count
  br i1 %cmp, label %if.then, label %if.end14

if.then:                                          ; preds = %entry
  %m_allowGrowingCapacity = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this, i64 0, i32 7
  %1 = load i8, ptr %m_allowGrowingCapacity, align 1
  %2 = and i8 %1, 1
  %tobool.not = icmp eq i8 %2, 0
  br i1 %tobool.not, label %if.else, label %if.then2

if.then2:                                         ; preds = %if.then
  %mul = shl i64 %_Count, 4
  %3 = load ptr, ptr @__clewCreateBuffer, align 8
  %m_clContext = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this, i64 0, i32 4
  %4 = load ptr, ptr %m_clContext, align 8
  %call3 = call ptr %3(ptr noundef %4, i64 noundef 1, i64 noundef %mul, ptr noundef null, ptr noundef nonnull %ciErrNum)
  %5 = load i32, ptr %ciErrNum, align 4
  %cmp4.not.not = icmp eq i32 %5, 0
  br i1 %cmp4.not.not, label %if.end, label %if.end.thread

if.end.thread:                                    ; preds = %if.then2
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 166)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.76)
  br label %if.end12

if.end:                                           ; preds = %if.then2
  br i1 %copyOldContents, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.end
  %m_size.i = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this, i64 0, i32 1
  %6 = load i64, ptr %m_size.i, align 8
  %cmp.i = icmp eq i64 %6, 0
  br i1 %cmp.i, label %if.end12, label %if.end.i

if.end.i:                                         ; preds = %if.then9
  %7 = load ptr, ptr @__clewEnqueueCopyBuffer, align 8
  %m_commandQueue.i = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this, i64 0, i32 5
  %8 = load ptr, ptr %m_commandQueue.i, align 8
  %m_clBuffer.i = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this, i64 0, i32 3
  %9 = load ptr, ptr %m_clBuffer.i, align 8
  %mul3.i = shl i64 %6, 4
  %call.i = call i32 %7(ptr noundef %8, ptr noundef %9, ptr noundef %call3, i64 noundef 0, i64 noundef 0, i64 noundef %mul3.i, i32 noundef 0, ptr noundef null, ptr noundef null)
  br label %if.end12

if.end12:                                         ; preds = %if.end.i, %if.then9, %if.end.thread, %if.end
  %_Count.addr.023 = phi i64 [ 0, %if.end.thread ], [ %_Count, %if.end ], [ %_Count, %if.then9 ], [ %_Count, %if.end.i ]
  %m_clBuffer.i5 = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this, i64 0, i32 3
  %10 = load ptr, ptr %m_clBuffer.i5, align 8
  %tobool.not.i = icmp eq ptr %10, null
  br i1 %tobool.not.i, label %_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE10deallocateEv.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end12
  %m_ownsMemory.i = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this, i64 0, i32 6
  %11 = load i8, ptr %m_ownsMemory.i, align 8
  %12 = and i8 %11, 1
  %tobool2.not.i = icmp eq i8 %12, 0
  br i1 %tobool2.not.i, label %_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE10deallocateEv.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i
  %13 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i6 = call i32 %13(ptr noundef nonnull %10)
  br label %_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE10deallocateEv.exit

_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE10deallocateEv.exit: ; preds = %if.end12, %land.lhs.true.i, %if.then.i
  store ptr %call3, ptr %m_clBuffer.i5, align 8
  store i64 %_Count.addr.023, ptr %m_capacity.i, align 8
  br label %if.end14

if.else:                                          ; preds = %if.then
  %m_clBuffer.i9 = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this, i64 0, i32 3
  %14 = load ptr, ptr %m_clBuffer.i9, align 8
  %tobool.not.i10 = icmp eq ptr %14, null
  br i1 %tobool.not.i10, label %_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE10deallocateEv.exit18, label %land.lhs.true.i11

land.lhs.true.i11:                                ; preds = %if.else
  %m_ownsMemory.i12 = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this, i64 0, i32 6
  %15 = load i8, ptr %m_ownsMemory.i12, align 8
  %16 = and i8 %15, 1
  %tobool2.not.i13 = icmp eq i8 %16, 0
  br i1 %tobool2.not.i13, label %_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE10deallocateEv.exit18, label %if.then.i14

if.then.i14:                                      ; preds = %land.lhs.true.i11
  %17 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i15 = tail call i32 %17(ptr noundef nonnull %14)
  br label %_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE10deallocateEv.exit18

_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE10deallocateEv.exit18: ; preds = %if.else, %land.lhs.true.i11, %if.then.i14
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %m_capacity.i, i8 0, i64 16, i1 false)
  br label %if.end14

if.end14:                                         ; preds = %_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE10deallocateEv.exit, %_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE10deallocateEv.exit18, %entry
  %result.1 = phi i1 [ %cmp4.not.not, %_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE10deallocateEv.exit ], [ false, %_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairE10deallocateEv.exit18 ], [ true, %entry ]
  ret i1 %result.1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairED0Ev(ptr noundef nonnull align 8 dereferenceable(50) %this) unnamed_addr #10 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV13b3OpenCLArrayI25b3CompoundOverlappingPairE, i64 0, inrange i32 0, i64 2), ptr %this, align 8
  %m_clBuffer.i.i = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this, i64 0, i32 3
  %0 = load ptr, ptr %m_clBuffer.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %0, null
  br i1 %tobool.not.i.i, label %_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairED2Ev.exit, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %entry
  %m_ownsMemory.i.i = getelementptr inbounds %class.b3OpenCLArray.17, ptr %this, i64 0, i32 6
  %1 = load i8, ptr %m_ownsMemory.i.i, align 8
  %2 = and i8 %1, 1
  %tobool2.not.i.i = icmp eq i8 %2, 0
  br i1 %tobool2.not.i.i, label %_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairED2Ev.exit, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.lhs.true.i.i
  %3 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i1.i = invoke i32 %3(ptr noundef nonnull %0)
          to label %_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairED2Ev.exit unwind label %terminate.lpad.i

terminate.lpad.i:                                 ; preds = %if.then.i.i
  %4 = landingpad { ptr, i32 }
          catch ptr null
  %5 = extractvalue { ptr, i32 } %4, 0
  tail call void @__clang_call_terminate(ptr %5) #27
  unreachable

_ZN13b3OpenCLArrayI25b3CompoundOverlappingPairED2Ev.exit: ; preds = %entry, %land.lhs.true.i.i, %if.then.i.i
  tail call void @_ZdlPv(ptr noundef nonnull %this) #28
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI10b3Contact4E7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) local_unnamed_addr #8 comdat align 2 {
entry:
  %m_capacity.i = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this, i64 0, i32 3
  %0 = load i32, ptr %m_capacity.i, align 8
  %cmp = icmp slt i32 %0, %_Count
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %tobool.not.i = icmp eq i32 %_Count, 0
  br i1 %tobool.not.i, label %_ZNK20b3AlignedObjectArrayI10b3Contact4E4copyEiiPS0_.exit18, label %_ZN20b3AlignedObjectArrayI10b3Contact4E8allocateEi.exit

_ZN20b3AlignedObjectArrayI10b3Contact4E8allocateEi.exit: ; preds = %if.then
  %conv.i.i = sext i32 %_Count to i64
  %mul.i.i = mul nsw i64 %conv.i.i, 112
  %call.i.i = tail call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i, i32 noundef 16)
  %cmp3 = icmp eq ptr %call.i.i, null
  br i1 %cmp3, label %_ZNK20b3AlignedObjectArrayI10b3Contact4E4copyEiiPS0_.exit18, label %if.then.split

if.then.split:                                    ; preds = %_ZN20b3AlignedObjectArrayI10b3Contact4E8allocateEi.exit
  %m_size.i = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this, i64 0, i32 2
  %1 = load i32, ptr %m_size.i, align 4
  %cmp4.i = icmp sgt i32 %1, 0
  br i1 %cmp4.i, label %for.body.lr.ph.i, label %if.end

for.body.lr.ph.i:                                 ; preds = %if.then.split
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this, i64 0, i32 5
  %wide.trip.count.i = zext nneg i32 %1 to i64
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %for.body.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %for.body.lr.ph.i ], [ %indvars.iv.next.i, %for.body.i ]
  %arrayidx.i = getelementptr inbounds %struct.b3Contact4, ptr %call.i.i, i64 %indvars.iv.i
  %2 = load ptr, ptr %m_data.i, align 8
  %arrayidx3.i = getelementptr inbounds %struct.b3Contact4, ptr %2, i64 %indvars.iv.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(112) %arrayidx.i, ptr noundef nonnull align 16 dereferenceable(112) %arrayidx3.i, i64 112, i1 false)
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %if.end, label %for.body.i, !llvm.loop !65

_ZNK20b3AlignedObjectArrayI10b3Contact4E4copyEiiPS0_.exit18: ; preds = %if.then, %_ZN20b3AlignedObjectArrayI10b3Contact4E8allocateEi.exit
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this, i64 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %for.body.i, %if.then.split, %_ZNK20b3AlignedObjectArrayI10b3Contact4E4copyEiiPS0_.exit18
  %retval.0.i25 = phi ptr [ null, %_ZNK20b3AlignedObjectArrayI10b3Contact4E4copyEiiPS0_.exit18 ], [ %call.i.i, %if.then.split ], [ %call.i.i, %for.body.i ]
  %_Count.addr.0 = phi i32 [ 0, %_ZNK20b3AlignedObjectArrayI10b3Contact4E4copyEiiPS0_.exit18 ], [ %_Count, %if.then.split ], [ %_Count, %for.body.i ]
  %m_data.i20 = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this, i64 0, i32 5
  %3 = load ptr, ptr %m_data.i20, align 8
  %tobool.not.i21 = icmp eq ptr %3, null
  br i1 %tobool.not.i21, label %_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv.exit, label %if.then.i22

if.then.i22:                                      ; preds = %if.end
  %m_ownsMemory.i = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this, i64 0, i32 6
  %4 = load i8, ptr %m_ownsMemory.i, align 8
  %5 = and i8 %4, 1
  %tobool2.not.i = icmp eq i8 %5, 0
  br i1 %tobool2.not.i, label %_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv.exit, label %if.then3.i

if.then3.i:                                       ; preds = %if.then.i22
  tail call void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %3)
  br label %_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv.exit

_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv.exit: ; preds = %if.then.i22, %if.then3.i, %if.end
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.35, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  store ptr %retval.0.i25, ptr %m_data.i20, align 8
  store i32 %_Count.addr.0, ptr %m_capacity.i, align 8
  br label %if.end7

if.end7:                                          ; preds = %_ZN20b3AlignedObjectArrayI10b3Contact4E10deallocateEv.exit, %entry
  ret void
}

declare noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef, i32 noundef) local_unnamed_addr #16

declare void @_Z21b3AlignedFreeInternalPv(ptr noundef) local_unnamed_addr #16

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3Int4E7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) local_unnamed_addr #8 comdat align 2 {
entry:
  %m_capacity.i = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this, i64 0, i32 3
  %0 = load i32, ptr %m_capacity.i, align 8
  %cmp = icmp slt i32 %0, %_Count
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %tobool.not.i = icmp eq i32 %_Count, 0
  br i1 %tobool.not.i, label %_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_.exit18, label %_ZN20b3AlignedObjectArrayI6b3Int4E8allocateEi.exit

_ZN20b3AlignedObjectArrayI6b3Int4E8allocateEi.exit: ; preds = %if.then
  %conv.i.i = sext i32 %_Count to i64
  %mul.i.i = shl nsw i64 %conv.i.i, 4
  %call.i.i = tail call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i, i32 noundef 16)
  %cmp3 = icmp eq ptr %call.i.i, null
  br i1 %cmp3, label %_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_.exit18, label %if.then.split

if.then.split:                                    ; preds = %_ZN20b3AlignedObjectArrayI6b3Int4E8allocateEi.exit
  %m_size.i = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this, i64 0, i32 2
  %1 = load i32, ptr %m_size.i, align 4
  %cmp4.i = icmp sgt i32 %1, 0
  br i1 %cmp4.i, label %for.body.lr.ph.i, label %if.end

for.body.lr.ph.i:                                 ; preds = %if.then.split
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this, i64 0, i32 5
  %wide.trip.count.i = zext nneg i32 %1 to i64
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %for.body.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %for.body.lr.ph.i ], [ %indvars.iv.next.i, %for.body.i ]
  %arrayidx.i = getelementptr inbounds %struct.b3Int4, ptr %call.i.i, i64 %indvars.iv.i
  %2 = load ptr, ptr %m_data.i, align 8
  %arrayidx3.i = getelementptr inbounds %struct.b3Int4, ptr %2, i64 %indvars.iv.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx.i, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx3.i, i64 16, i1 false)
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %if.end, label %for.body.i, !llvm.loop !69

_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_.exit18: ; preds = %if.then, %_ZN20b3AlignedObjectArrayI6b3Int4E8allocateEi.exit
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this, i64 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %for.body.i, %if.then.split, %_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_.exit18
  %retval.0.i25 = phi ptr [ null, %_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_.exit18 ], [ %call.i.i, %if.then.split ], [ %call.i.i, %for.body.i ]
  %_Count.addr.0 = phi i32 [ 0, %_ZNK20b3AlignedObjectArrayI6b3Int4E4copyEiiPS0_.exit18 ], [ %_Count, %if.then.split ], [ %_Count, %for.body.i ]
  %m_data.i20 = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this, i64 0, i32 5
  %3 = load ptr, ptr %m_data.i20, align 8
  %tobool.not.i21 = icmp eq ptr %3, null
  br i1 %tobool.not.i21, label %_ZN20b3AlignedObjectArrayI6b3Int4E10deallocateEv.exit, label %if.then.i22

if.then.i22:                                      ; preds = %if.end
  %m_ownsMemory.i = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this, i64 0, i32 6
  %4 = load i8, ptr %m_ownsMemory.i, align 8
  %5 = and i8 %4, 1
  %tobool2.not.i = icmp eq i8 %5, 0
  br i1 %tobool2.not.i, label %_ZN20b3AlignedObjectArrayI6b3Int4E10deallocateEv.exit, label %if.then3.i

if.then3.i:                                       ; preds = %if.then.i22
  tail call void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %3)
  br label %_ZN20b3AlignedObjectArrayI6b3Int4E10deallocateEv.exit

_ZN20b3AlignedObjectArrayI6b3Int4E10deallocateEv.exit: ; preds = %if.then.i22, %if.then3.i, %if.end
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.66, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  store ptr %retval.0.i25, ptr %m_data.i20, align 8
  store i32 %_Count.addr.0, ptr %m_capacity.i, align 8
  br label %if.end7

if.end7:                                          ; preds = %_ZN20b3AlignedObjectArrayI6b3Int4E10deallocateEv.exit, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3Vector3E7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) local_unnamed_addr #8 comdat align 2 {
entry:
  %m_capacity.i = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this, i64 0, i32 3
  %0 = load i32, ptr %m_capacity.i, align 8
  %cmp = icmp slt i32 %0, %_Count
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %tobool.not.i = icmp eq i32 %_Count, 0
  br i1 %tobool.not.i, label %_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18, label %_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit

_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit: ; preds = %if.then
  %conv.i.i = sext i32 %_Count to i64
  %mul.i.i = shl nsw i64 %conv.i.i, 4
  %call.i.i = tail call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i, i32 noundef 16)
  %cmp3 = icmp eq ptr %call.i.i, null
  br i1 %cmp3, label %_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18, label %if.then.split

if.then.split:                                    ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit
  %m_size.i = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this, i64 0, i32 2
  %1 = load i32, ptr %m_size.i, align 4
  %cmp4.i = icmp sgt i32 %1, 0
  br i1 %cmp4.i, label %for.body.lr.ph.i, label %if.end

for.body.lr.ph.i:                                 ; preds = %if.then.split
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this, i64 0, i32 5
  %wide.trip.count.i = zext nneg i32 %1 to i64
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %for.body.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %for.body.lr.ph.i ], [ %indvars.iv.next.i, %for.body.i ]
  %arrayidx.i = getelementptr inbounds %class.b3Vector3, ptr %call.i.i, i64 %indvars.iv.i
  %2 = load ptr, ptr %m_data.i, align 8
  %arrayidx3.i = getelementptr inbounds %class.b3Vector3, ptr %2, i64 %indvars.iv.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx.i, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx3.i, i64 16, i1 false)
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %if.end, label %for.body.i, !llvm.loop !70

_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18: ; preds = %if.then, %_ZN20b3AlignedObjectArrayI9b3Vector3E8allocateEi.exit
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this, i64 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %for.body.i, %if.then.split, %_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18
  %retval.0.i25 = phi ptr [ null, %_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18 ], [ %call.i.i, %if.then.split ], [ %call.i.i, %for.body.i ]
  %_Count.addr.0 = phi i32 [ 0, %_ZNK20b3AlignedObjectArrayI9b3Vector3E4copyEiiPS0_.exit18 ], [ %_Count, %if.then.split ], [ %_Count, %for.body.i ]
  %m_data.i20 = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this, i64 0, i32 5
  %3 = load ptr, ptr %m_data.i20, align 8
  %tobool.not.i21 = icmp eq ptr %3, null
  br i1 %tobool.not.i21, label %_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv.exit, label %if.then.i22

if.then.i22:                                      ; preds = %if.end
  %m_ownsMemory.i = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this, i64 0, i32 6
  %4 = load i8, ptr %m_ownsMemory.i, align 8
  %5 = and i8 %4, 1
  %tobool2.not.i = icmp eq i8 %5, 0
  br i1 %tobool2.not.i, label %_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv.exit, label %if.then3.i

if.then3.i:                                       ; preds = %if.then.i22
  tail call void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %3)
  br label %_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv.exit

_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv.exit: ; preds = %if.then.i22, %if.then3.i, %if.end
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  store ptr %retval.0.i25, ptr %m_data.i20, align 8
  store i32 %_Count.addr.0, ptr %m_capacity.i, align 8
  br label %if.end7

if.end7:                                          ; preds = %_ZN20b3AlignedObjectArrayI9b3Vector3E10deallocateEv.exit, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayIiE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) local_unnamed_addr #8 comdat align 2 {
entry:
  %m_capacity.i = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this, i64 0, i32 3
  %0 = load i32, ptr %m_capacity.i, align 8
  %cmp = icmp slt i32 %0, %_Count
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %tobool.not.i = icmp eq i32 %_Count, 0
  br i1 %tobool.not.i, label %_ZNK20b3AlignedObjectArrayIiE4copyEiiPi.exit18, label %_ZN20b3AlignedObjectArrayIiE8allocateEi.exit

_ZN20b3AlignedObjectArrayIiE8allocateEi.exit:     ; preds = %if.then
  %conv.i.i = sext i32 %_Count to i64
  %mul.i.i = shl nsw i64 %conv.i.i, 2
  %call.i.i = tail call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i, i32 noundef 16)
  %cmp3 = icmp eq ptr %call.i.i, null
  br i1 %cmp3, label %_ZNK20b3AlignedObjectArrayIiE4copyEiiPi.exit18, label %if.then.split

if.then.split:                                    ; preds = %_ZN20b3AlignedObjectArrayIiE8allocateEi.exit
  %m_size.i = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this, i64 0, i32 2
  %1 = load i32, ptr %m_size.i, align 4
  %cmp4.i = icmp sgt i32 %1, 0
  br i1 %cmp4.i, label %for.body.lr.ph.i, label %if.end

for.body.lr.ph.i:                                 ; preds = %if.then.split
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this, i64 0, i32 5
  %wide.trip.count.i = zext nneg i32 %1 to i64
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %for.body.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %for.body.lr.ph.i ], [ %indvars.iv.next.i, %for.body.i ]
  %arrayidx.i = getelementptr inbounds i32, ptr %call.i.i, i64 %indvars.iv.i
  %2 = load ptr, ptr %m_data.i, align 8
  %arrayidx3.i = getelementptr inbounds i32, ptr %2, i64 %indvars.iv.i
  %3 = load i32, ptr %arrayidx3.i, align 4
  store i32 %3, ptr %arrayidx.i, align 4
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %if.end, label %for.body.i, !llvm.loop !86

_ZNK20b3AlignedObjectArrayIiE4copyEiiPi.exit18:   ; preds = %if.then, %_ZN20b3AlignedObjectArrayIiE8allocateEi.exit
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this, i64 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %for.body.i, %if.then.split, %_ZNK20b3AlignedObjectArrayIiE4copyEiiPi.exit18
  %retval.0.i25 = phi ptr [ null, %_ZNK20b3AlignedObjectArrayIiE4copyEiiPi.exit18 ], [ %call.i.i, %if.then.split ], [ %call.i.i, %for.body.i ]
  %_Count.addr.0 = phi i32 [ 0, %_ZNK20b3AlignedObjectArrayIiE4copyEiiPi.exit18 ], [ %_Count, %if.then.split ], [ %_Count, %for.body.i ]
  %m_data.i20 = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this, i64 0, i32 5
  %4 = load ptr, ptr %m_data.i20, align 8
  %tobool.not.i21 = icmp eq ptr %4, null
  br i1 %tobool.not.i21, label %_ZN20b3AlignedObjectArrayIiE10deallocateEv.exit, label %if.then.i22

if.then.i22:                                      ; preds = %if.end
  %m_ownsMemory.i = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this, i64 0, i32 6
  %5 = load i8, ptr %m_ownsMemory.i, align 8
  %6 = and i8 %5, 1
  %tobool2.not.i = icmp eq i8 %6, 0
  br i1 %tobool2.not.i, label %_ZN20b3AlignedObjectArrayIiE10deallocateEv.exit, label %if.then3.i

if.then3.i:                                       ; preds = %if.then.i22
  tail call void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %4)
  br label %_ZN20b3AlignedObjectArrayIiE10deallocateEv.exit

_ZN20b3AlignedObjectArrayIiE10deallocateEv.exit:  ; preds = %if.then.i22, %if.then3.i, %if.end
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.23, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  store ptr %retval.0.i25, ptr %m_data.i20, align 8
  store i32 %_Count.addr.0, ptr %m_capacity.i, align 8
  br label %if.end7

if.end7:                                          ; preds = %_ZN20b3AlignedObjectArrayIiE10deallocateEv.exit, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI15b3KernelArgDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) local_unnamed_addr #8 comdat align 2 {
entry:
  %m_capacity.i = getelementptr inbounds %class.b3AlignedObjectArray.82, ptr %this, i64 0, i32 3
  %0 = load i32, ptr %m_capacity.i, align 8
  %cmp = icmp slt i32 %0, %_Count
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %tobool.not.i = icmp eq i32 %_Count, 0
  br i1 %tobool.not.i, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit: ; preds = %if.then
  %conv.i.i = sext i32 %_Count to i64
  %mul.i.i = shl nsw i64 %conv.i.i, 5
  %call.i.i = tail call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i, i32 noundef 16)
  %cmp3 = icmp eq ptr %call.i.i, null
  br i1 %cmp3, label %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18, label %if.then.split

if.then.split:                                    ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit
  %m_size.i = getelementptr inbounds %class.b3AlignedObjectArray.82, ptr %this, i64 0, i32 2
  %1 = load i32, ptr %m_size.i, align 4
  %cmp4.i = icmp sgt i32 %1, 0
  br i1 %cmp4.i, label %for.body.lr.ph.i, label %if.end

for.body.lr.ph.i:                                 ; preds = %if.then.split
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.82, ptr %this, i64 0, i32 5
  %wide.trip.count.i = zext nneg i32 %1 to i64
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %for.body.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %for.body.lr.ph.i ], [ %indvars.iv.next.i, %for.body.i ]
  %arrayidx.i = getelementptr inbounds %struct.b3KernelArgData, ptr %call.i.i, i64 %indvars.iv.i
  %2 = load ptr, ptr %m_data.i, align 8
  %arrayidx3.i = getelementptr inbounds %struct.b3KernelArgData, ptr %2, i64 %indvars.iv.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i, i64 32, i1 false)
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %if.end, label %for.body.i, !llvm.loop !64

_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18: ; preds = %if.then, %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE8allocateEi.exit
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.82, ptr %this, i64 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %for.body.i, %if.then.split, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18
  %retval.0.i25 = phi ptr [ null, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18 ], [ %call.i.i, %if.then.split ], [ %call.i.i, %for.body.i ]
  %_Count.addr.0 = phi i32 [ 0, %_ZNK20b3AlignedObjectArrayI15b3KernelArgDataE4copyEiiPS0_.exit18 ], [ %_Count, %if.then.split ], [ %_Count, %for.body.i ]
  %m_data.i20 = getelementptr inbounds %class.b3AlignedObjectArray.82, ptr %this, i64 0, i32 5
  %3 = load ptr, ptr %m_data.i20, align 8
  %tobool.not.i21 = icmp eq ptr %3, null
  br i1 %tobool.not.i21, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit, label %if.then.i22

if.then.i22:                                      ; preds = %if.end
  %m_ownsMemory.i = getelementptr inbounds %class.b3AlignedObjectArray.82, ptr %this, i64 0, i32 6
  %4 = load i8, ptr %m_ownsMemory.i, align 8
  %5 = and i8 %4, 1
  %tobool2.not.i = icmp eq i8 %5, 0
  br i1 %tobool2.not.i, label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit, label %if.then3.i

if.then3.i:                                       ; preds = %if.then.i22
  tail call void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %3)
  br label %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit

_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit: ; preds = %if.then.i22, %if.then3.i, %if.end
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.82, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  store ptr %retval.0.i25, ptr %m_data.i20, align 8
  store i32 %_Count.addr.0, ptr %m_capacity.i, align 8
  br label %if.end7

if.end7:                                          ; preds = %_ZN20b3AlignedObjectArrayI15b3KernelArgDataE10deallocateEv.exit, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) local_unnamed_addr #8 comdat align 2 {
entry:
  %m_capacity.i = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this, i64 0, i32 3
  %0 = load i32, ptr %m_capacity.i, align 8
  %cmp = icmp slt i32 %0, %_Count
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %tobool.not.i = icmp eq i32 %_Count, 0
  br i1 %tobool.not.i, label %_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataE4copyEiiPS0_.exit18, label %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE8allocateEi.exit

_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE8allocateEi.exit: ; preds = %if.then
  %conv.i.i = sext i32 %_Count to i64
  %mul.i.i = mul nsw i64 %conv.i.i, 80
  %call.i.i = tail call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i, i32 noundef 16)
  %cmp3 = icmp eq ptr %call.i.i, null
  br i1 %cmp3, label %_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataE4copyEiiPS0_.exit18, label %if.then.split

if.then.split:                                    ; preds = %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE8allocateEi.exit
  %m_size.i = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this, i64 0, i32 2
  %1 = load i32, ptr %m_size.i, align 4
  %cmp4.i = icmp sgt i32 %1, 0
  br i1 %cmp4.i, label %for.body.lr.ph.i, label %if.end

for.body.lr.ph.i:                                 ; preds = %if.then.split
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this, i64 0, i32 5
  %wide.trip.count.i = zext nneg i32 %1 to i64
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %for.body.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %for.body.lr.ph.i ], [ %indvars.iv.next.i, %for.body.i ]
  %arrayidx.i = getelementptr inbounds %struct.b3RigidBodyData, ptr %call.i.i, i64 %indvars.iv.i
  %2 = load ptr, ptr %m_data.i, align 8
  %arrayidx3.i = getelementptr inbounds %struct.b3RigidBodyData, ptr %2, i64 %indvars.iv.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(80) %arrayidx.i, ptr noundef nonnull align 16 dereferenceable(80) %arrayidx3.i, i64 80, i1 false)
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %if.end, label %for.body.i, !llvm.loop !87

_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataE4copyEiiPS0_.exit18: ; preds = %if.then, %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE8allocateEi.exit
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this, i64 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %for.body.i, %if.then.split, %_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataE4copyEiiPS0_.exit18
  %retval.0.i25 = phi ptr [ null, %_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataE4copyEiiPS0_.exit18 ], [ %call.i.i, %if.then.split ], [ %call.i.i, %for.body.i ]
  %_Count.addr.0 = phi i32 [ 0, %_ZNK20b3AlignedObjectArrayI15b3RigidBodyDataE4copyEiiPS0_.exit18 ], [ %_Count, %if.then.split ], [ %_Count, %for.body.i ]
  %m_data.i20 = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this, i64 0, i32 5
  %3 = load ptr, ptr %m_data.i20, align 8
  %tobool.not.i21 = icmp eq ptr %3, null
  br i1 %tobool.not.i21, label %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE10deallocateEv.exit, label %if.then.i22

if.then.i22:                                      ; preds = %if.end
  %m_ownsMemory.i = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this, i64 0, i32 6
  %4 = load i8, ptr %m_ownsMemory.i, align 8
  %5 = and i8 %4, 1
  %tobool2.not.i = icmp eq i8 %5, 0
  br i1 %tobool2.not.i, label %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE10deallocateEv.exit, label %if.then3.i

if.then3.i:                                       ; preds = %if.then.i22
  tail call void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %3)
  br label %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE10deallocateEv.exit

_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE10deallocateEv.exit: ; preds = %if.then.i22, %if.then3.i, %if.end
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.39, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  store ptr %retval.0.i25, ptr %m_data.i20, align 8
  store i32 %_Count.addr.0, ptr %m_capacity.i, align 8
  br label %if.end7

if.end7:                                          ; preds = %_ZN20b3AlignedObjectArrayI15b3RigidBodyDataE10deallocateEv.exit, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI12b3CollidableE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) local_unnamed_addr #8 comdat align 2 {
entry:
  %m_capacity.i = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this, i64 0, i32 3
  %0 = load i32, ptr %m_capacity.i, align 8
  %cmp = icmp slt i32 %0, %_Count
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %tobool.not.i = icmp eq i32 %_Count, 0
  br i1 %tobool.not.i, label %_ZNK20b3AlignedObjectArrayI12b3CollidableE4copyEiiPS0_.exit18, label %_ZN20b3AlignedObjectArrayI12b3CollidableE8allocateEi.exit

_ZN20b3AlignedObjectArrayI12b3CollidableE8allocateEi.exit: ; preds = %if.then
  %conv.i.i = sext i32 %_Count to i64
  %mul.i.i = shl nsw i64 %conv.i.i, 4
  %call.i.i = tail call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i, i32 noundef 16)
  %cmp3 = icmp eq ptr %call.i.i, null
  br i1 %cmp3, label %_ZNK20b3AlignedObjectArrayI12b3CollidableE4copyEiiPS0_.exit18, label %if.then.split

if.then.split:                                    ; preds = %_ZN20b3AlignedObjectArrayI12b3CollidableE8allocateEi.exit
  %m_size.i = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this, i64 0, i32 2
  %1 = load i32, ptr %m_size.i, align 4
  %cmp4.i = icmp sgt i32 %1, 0
  br i1 %cmp4.i, label %for.body.lr.ph.i, label %if.end

for.body.lr.ph.i:                                 ; preds = %if.then.split
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this, i64 0, i32 5
  %wide.trip.count.i = zext nneg i32 %1 to i64
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %for.body.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %for.body.lr.ph.i ], [ %indvars.iv.next.i, %for.body.i ]
  %arrayidx.i = getelementptr inbounds %struct.b3Collidable, ptr %call.i.i, i64 %indvars.iv.i
  %2 = load ptr, ptr %m_data.i, align 8
  %arrayidx3.i = getelementptr inbounds %struct.b3Collidable, ptr %2, i64 %indvars.iv.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 4 dereferenceable(16) %arrayidx.i, ptr noundef nonnull align 4 dereferenceable(16) %arrayidx3.i, i64 16, i1 false)
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %if.end, label %for.body.i, !llvm.loop !88

_ZNK20b3AlignedObjectArrayI12b3CollidableE4copyEiiPS0_.exit18: ; preds = %if.then, %_ZN20b3AlignedObjectArrayI12b3CollidableE8allocateEi.exit
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this, i64 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %for.body.i, %if.then.split, %_ZNK20b3AlignedObjectArrayI12b3CollidableE4copyEiiPS0_.exit18
  %retval.0.i25 = phi ptr [ null, %_ZNK20b3AlignedObjectArrayI12b3CollidableE4copyEiiPS0_.exit18 ], [ %call.i.i, %if.then.split ], [ %call.i.i, %for.body.i ]
  %_Count.addr.0 = phi i32 [ 0, %_ZNK20b3AlignedObjectArrayI12b3CollidableE4copyEiiPS0_.exit18 ], [ %_Count, %if.then.split ], [ %_Count, %for.body.i ]
  %m_data.i20 = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this, i64 0, i32 5
  %3 = load ptr, ptr %m_data.i20, align 8
  %tobool.not.i21 = icmp eq ptr %3, null
  br i1 %tobool.not.i21, label %_ZN20b3AlignedObjectArrayI12b3CollidableE10deallocateEv.exit, label %if.then.i22

if.then.i22:                                      ; preds = %if.end
  %m_ownsMemory.i = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this, i64 0, i32 6
  %4 = load i8, ptr %m_ownsMemory.i, align 8
  %5 = and i8 %4, 1
  %tobool2.not.i = icmp eq i8 %5, 0
  br i1 %tobool2.not.i, label %_ZN20b3AlignedObjectArrayI12b3CollidableE10deallocateEv.exit, label %if.then3.i

if.then3.i:                                       ; preds = %if.then.i22
  tail call void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %3)
  br label %_ZN20b3AlignedObjectArrayI12b3CollidableE10deallocateEv.exit

_ZN20b3AlignedObjectArrayI12b3CollidableE10deallocateEv.exit: ; preds = %if.then.i22, %if.then3.i, %if.end
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.27, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  store ptr %retval.0.i25, ptr %m_data.i20, align 8
  store i32 %_Count.addr.0, ptr %m_capacity.i, align 8
  br label %if.end7

if.end7:                                          ; preds = %_ZN20b3AlignedObjectArrayI12b3CollidableE10deallocateEv.exit, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) local_unnamed_addr #8 comdat align 2 {
entry:
  %m_capacity.i = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this, i64 0, i32 3
  %0 = load i32, ptr %m_capacity.i, align 8
  %cmp = icmp slt i32 %0, %_Count
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %tobool.not.i = icmp eq i32 %_Count, 0
  br i1 %tobool.not.i, label %_ZNK20b3AlignedObjectArrayI15b3GpuChildShapeE4copyEiiPS0_.exit18, label %_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE8allocateEi.exit

_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE8allocateEi.exit: ; preds = %if.then
  %conv.i.i = sext i32 %_Count to i64
  %mul.i.i = mul nsw i64 %conv.i.i, 48
  %call.i.i = tail call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i, i32 noundef 16)
  %cmp3 = icmp eq ptr %call.i.i, null
  br i1 %cmp3, label %_ZNK20b3AlignedObjectArrayI15b3GpuChildShapeE4copyEiiPS0_.exit18, label %if.then.split

if.then.split:                                    ; preds = %_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE8allocateEi.exit
  %m_size.i = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this, i64 0, i32 2
  %1 = load i32, ptr %m_size.i, align 4
  %cmp4.i = icmp sgt i32 %1, 0
  br i1 %cmp4.i, label %for.body.lr.ph.i, label %if.end

for.body.lr.ph.i:                                 ; preds = %if.then.split
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this, i64 0, i32 5
  %wide.trip.count.i = zext nneg i32 %1 to i64
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %for.body.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %for.body.lr.ph.i ], [ %indvars.iv.next.i, %for.body.i ]
  %arrayidx.i = getelementptr inbounds %struct.b3GpuChildShape, ptr %call.i.i, i64 %indvars.iv.i
  %2 = load ptr, ptr %m_data.i, align 8
  %arrayidx3.i = getelementptr inbounds %struct.b3GpuChildShape, ptr %2, i64 %indvars.iv.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(48) %arrayidx.i, ptr noundef nonnull align 16 dereferenceable(48) %arrayidx3.i, i64 48, i1 false)
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %if.end, label %for.body.i, !llvm.loop !89

_ZNK20b3AlignedObjectArrayI15b3GpuChildShapeE4copyEiiPS0_.exit18: ; preds = %if.then, %_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE8allocateEi.exit
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this, i64 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %for.body.i, %if.then.split, %_ZNK20b3AlignedObjectArrayI15b3GpuChildShapeE4copyEiiPS0_.exit18
  %retval.0.i25 = phi ptr [ null, %_ZNK20b3AlignedObjectArrayI15b3GpuChildShapeE4copyEiiPS0_.exit18 ], [ %call.i.i, %if.then.split ], [ %call.i.i, %for.body.i ]
  %_Count.addr.0 = phi i32 [ 0, %_ZNK20b3AlignedObjectArrayI15b3GpuChildShapeE4copyEiiPS0_.exit18 ], [ %_Count, %if.then.split ], [ %_Count, %for.body.i ]
  %m_data.i20 = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this, i64 0, i32 5
  %3 = load ptr, ptr %m_data.i20, align 8
  %tobool.not.i21 = icmp eq ptr %3, null
  br i1 %tobool.not.i21, label %_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE10deallocateEv.exit, label %if.then.i22

if.then.i22:                                      ; preds = %if.end
  %m_ownsMemory.i = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this, i64 0, i32 6
  %4 = load i8, ptr %m_ownsMemory.i, align 8
  %5 = and i8 %4, 1
  %tobool2.not.i = icmp eq i8 %5, 0
  br i1 %tobool2.not.i, label %_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE10deallocateEv.exit, label %if.then3.i

if.then3.i:                                       ; preds = %if.then.i22
  tail call void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %3)
  br label %_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE10deallocateEv.exit

_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE10deallocateEv.exit: ; preds = %if.then.i22, %if.then3.i, %if.end
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.92, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  store ptr %retval.0.i25, ptr %m_data.i20, align 8
  store i32 %_Count.addr.0, ptr %m_capacity.i, align 8
  br label %if.end7

if.end7:                                          ; preds = %_ZN20b3AlignedObjectArrayI15b3GpuChildShapeE10deallocateEv.exit, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) local_unnamed_addr #8 comdat align 2 {
entry:
  %m_capacity.i = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this, i64 0, i32 3
  %0 = load i32, ptr %m_capacity.i, align 8
  %cmp = icmp slt i32 %0, %_Count
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %tobool.not.i = icmp eq i32 %_Count, 0
  br i1 %tobool.not.i, label %_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE4copyEiiPS0_.exit18, label %_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE8allocateEi.exit

_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE8allocateEi.exit: ; preds = %if.then
  %conv.i.i = sext i32 %_Count to i64
  %mul.i.i = mul nsw i64 %conv.i.i, 96
  %call.i.i = tail call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i, i32 noundef 16)
  %cmp3 = icmp eq ptr %call.i.i, null
  br i1 %cmp3, label %_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE4copyEiiPS0_.exit18, label %if.then.split

if.then.split:                                    ; preds = %_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE8allocateEi.exit
  %m_size.i = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this, i64 0, i32 2
  %1 = load i32, ptr %m_size.i, align 4
  %cmp4.i = icmp sgt i32 %1, 0
  br i1 %cmp4.i, label %for.body.lr.ph.i, label %if.end

for.body.lr.ph.i:                                 ; preds = %if.then.split
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this, i64 0, i32 5
  %wide.trip.count.i = zext nneg i32 %1 to i64
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %for.body.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %for.body.lr.ph.i ], [ %indvars.iv.next.i, %for.body.i ]
  %arrayidx.i = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %call.i.i, i64 %indvars.iv.i
  %2 = load ptr, ptr %m_data.i, align 8
  %arrayidx3.i = getelementptr inbounds %struct.b3ConvexPolyhedronData, ptr %2, i64 %indvars.iv.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(96) %arrayidx.i, ptr noundef nonnull align 16 dereferenceable(96) %arrayidx3.i, i64 96, i1 false)
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %if.end, label %for.body.i, !llvm.loop !90

_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE4copyEiiPS0_.exit18: ; preds = %if.then, %_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE8allocateEi.exit
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this, i64 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %for.body.i, %if.then.split, %_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE4copyEiiPS0_.exit18
  %retval.0.i25 = phi ptr [ null, %_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE4copyEiiPS0_.exit18 ], [ %call.i.i, %if.then.split ], [ %call.i.i, %for.body.i ]
  %_Count.addr.0 = phi i32 [ 0, %_ZNK20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE4copyEiiPS0_.exit18 ], [ %_Count, %if.then.split ], [ %_Count, %for.body.i ]
  %m_data.i20 = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this, i64 0, i32 5
  %3 = load ptr, ptr %m_data.i20, align 8
  %tobool.not.i21 = icmp eq ptr %3, null
  br i1 %tobool.not.i21, label %_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE10deallocateEv.exit, label %if.then.i22

if.then.i22:                                      ; preds = %if.end
  %m_ownsMemory.i = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this, i64 0, i32 6
  %4 = load i8, ptr %m_ownsMemory.i, align 8
  %5 = and i8 %4, 1
  %tobool2.not.i = icmp eq i8 %5, 0
  br i1 %tobool2.not.i, label %_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE10deallocateEv.exit, label %if.then3.i

if.then3.i:                                       ; preds = %if.then.i22
  tail call void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %3)
  br label %_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE10deallocateEv.exit

_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE10deallocateEv.exit: ; preds = %if.then.i22, %if.then3.i, %if.end
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.31, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  store ptr %retval.0.i25, ptr %m_data.i20, align 8
  store i32 %_Count.addr.0, ptr %m_capacity.i, align 8
  br label %if.end7

if.end7:                                          ; preds = %_ZN20b3AlignedObjectArrayI22b3ConvexPolyhedronDataE10deallocateEv.exit, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3GpuFaceE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) local_unnamed_addr #8 comdat align 2 {
entry:
  %m_capacity.i = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this, i64 0, i32 3
  %0 = load i32, ptr %m_capacity.i, align 8
  %cmp = icmp slt i32 %0, %_Count
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %tobool.not.i = icmp eq i32 %_Count, 0
  br i1 %tobool.not.i, label %_ZNK20b3AlignedObjectArrayI9b3GpuFaceE4copyEiiPS0_.exit18, label %_ZN20b3AlignedObjectArrayI9b3GpuFaceE8allocateEi.exit

_ZN20b3AlignedObjectArrayI9b3GpuFaceE8allocateEi.exit: ; preds = %if.then
  %conv.i.i = sext i32 %_Count to i64
  %mul.i.i = shl nsw i64 %conv.i.i, 5
  %call.i.i = tail call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i, i32 noundef 16)
  %cmp3 = icmp eq ptr %call.i.i, null
  br i1 %cmp3, label %_ZNK20b3AlignedObjectArrayI9b3GpuFaceE4copyEiiPS0_.exit18, label %if.then.split

if.then.split:                                    ; preds = %_ZN20b3AlignedObjectArrayI9b3GpuFaceE8allocateEi.exit
  %m_size.i = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this, i64 0, i32 2
  %1 = load i32, ptr %m_size.i, align 4
  %cmp4.i = icmp sgt i32 %1, 0
  br i1 %cmp4.i, label %for.body.lr.ph.i, label %if.end

for.body.lr.ph.i:                                 ; preds = %if.then.split
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this, i64 0, i32 5
  %wide.trip.count.i = zext nneg i32 %1 to i64
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %for.body.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %for.body.lr.ph.i ], [ %indvars.iv.next.i, %for.body.i ]
  %arrayidx.i = getelementptr inbounds %struct.b3GpuFace, ptr %call.i.i, i64 %indvars.iv.i
  %2 = load ptr, ptr %m_data.i, align 8
  %arrayidx3.i = getelementptr inbounds %struct.b3GpuFace, ptr %2, i64 %indvars.iv.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i, i64 32, i1 false)
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %if.end, label %for.body.i, !llvm.loop !91

_ZNK20b3AlignedObjectArrayI9b3GpuFaceE4copyEiiPS0_.exit18: ; preds = %if.then, %_ZN20b3AlignedObjectArrayI9b3GpuFaceE8allocateEi.exit
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this, i64 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %for.body.i, %if.then.split, %_ZNK20b3AlignedObjectArrayI9b3GpuFaceE4copyEiiPS0_.exit18
  %retval.0.i25 = phi ptr [ null, %_ZNK20b3AlignedObjectArrayI9b3GpuFaceE4copyEiiPS0_.exit18 ], [ %call.i.i, %if.then.split ], [ %call.i.i, %for.body.i ]
  %_Count.addr.0 = phi i32 [ 0, %_ZNK20b3AlignedObjectArrayI9b3GpuFaceE4copyEiiPS0_.exit18 ], [ %_Count, %if.then.split ], [ %_Count, %for.body.i ]
  %m_data.i20 = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this, i64 0, i32 5
  %3 = load ptr, ptr %m_data.i20, align 8
  %tobool.not.i21 = icmp eq ptr %3, null
  br i1 %tobool.not.i21, label %_ZN20b3AlignedObjectArrayI9b3GpuFaceE10deallocateEv.exit, label %if.then.i22

if.then.i22:                                      ; preds = %if.end
  %m_ownsMemory.i = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this, i64 0, i32 6
  %4 = load i8, ptr %m_ownsMemory.i, align 8
  %5 = and i8 %4, 1
  %tobool2.not.i = icmp eq i8 %5, 0
  br i1 %tobool2.not.i, label %_ZN20b3AlignedObjectArrayI9b3GpuFaceE10deallocateEv.exit, label %if.then3.i

if.then3.i:                                       ; preds = %if.then.i22
  tail call void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %3)
  br label %_ZN20b3AlignedObjectArrayI9b3GpuFaceE10deallocateEv.exit

_ZN20b3AlignedObjectArrayI9b3GpuFaceE10deallocateEv.exit: ; preds = %if.then.i22, %if.then3.i, %if.end
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.19, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  store ptr %retval.0.i25, ptr %m_data.i20, align 8
  store i32 %_Count.addr.0, ptr %m_capacity.i, align 8
  br label %if.end7

if.end7:                                          ; preds = %_ZN20b3AlignedObjectArrayI9b3GpuFaceE10deallocateEv.exit, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) local_unnamed_addr #8 comdat align 2 {
entry:
  %m_capacity.i = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this, i64 0, i32 3
  %0 = load i32, ptr %m_capacity.i, align 8
  %cmp = icmp slt i32 %0, %_Count
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %tobool.not.i = icmp eq i32 %_Count, 0
  br i1 %tobool.not.i, label %_ZNK20b3AlignedObjectArrayI18b3QuantizedBvhNodeE4copyEiiPS0_.exit18, label %_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE8allocateEi.exit

_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE8allocateEi.exit: ; preds = %if.then
  %conv.i.i = sext i32 %_Count to i64
  %mul.i.i = shl nsw i64 %conv.i.i, 4
  %call.i.i = tail call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i, i32 noundef 16)
  %cmp3 = icmp eq ptr %call.i.i, null
  br i1 %cmp3, label %_ZNK20b3AlignedObjectArrayI18b3QuantizedBvhNodeE4copyEiiPS0_.exit18, label %if.then.split

if.then.split:                                    ; preds = %_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE8allocateEi.exit
  %m_size.i = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this, i64 0, i32 2
  %1 = load i32, ptr %m_size.i, align 4
  %cmp4.i = icmp sgt i32 %1, 0
  br i1 %cmp4.i, label %for.body.lr.ph.i, label %if.end

for.body.lr.ph.i:                                 ; preds = %if.then.split
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this, i64 0, i32 5
  %wide.trip.count.i = zext nneg i32 %1 to i64
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %for.body.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %for.body.lr.ph.i ], [ %indvars.iv.next.i, %for.body.i ]
  %arrayidx.i = getelementptr inbounds %struct.b3QuantizedBvhNode, ptr %call.i.i, i64 %indvars.iv.i
  %2 = load ptr, ptr %m_data.i, align 8
  %arrayidx3.i = getelementptr inbounds %struct.b3QuantizedBvhNode, ptr %2, i64 %indvars.iv.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx.i, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx3.i, i64 16, i1 false)
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %if.end, label %for.body.i, !llvm.loop !92

_ZNK20b3AlignedObjectArrayI18b3QuantizedBvhNodeE4copyEiiPS0_.exit18: ; preds = %if.then, %_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE8allocateEi.exit
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this, i64 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %for.body.i, %if.then.split, %_ZNK20b3AlignedObjectArrayI18b3QuantizedBvhNodeE4copyEiiPS0_.exit18
  %retval.0.i25 = phi ptr [ null, %_ZNK20b3AlignedObjectArrayI18b3QuantizedBvhNodeE4copyEiiPS0_.exit18 ], [ %call.i.i, %if.then.split ], [ %call.i.i, %for.body.i ]
  %_Count.addr.0 = phi i32 [ 0, %_ZNK20b3AlignedObjectArrayI18b3QuantizedBvhNodeE4copyEiiPS0_.exit18 ], [ %_Count, %if.then.split ], [ %_Count, %for.body.i ]
  %m_data.i20 = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this, i64 0, i32 5
  %3 = load ptr, ptr %m_data.i20, align 8
  %tobool.not.i21 = icmp eq ptr %3, null
  br i1 %tobool.not.i21, label %_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE10deallocateEv.exit, label %if.then.i22

if.then.i22:                                      ; preds = %if.end
  %m_ownsMemory.i = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this, i64 0, i32 6
  %4 = load i8, ptr %m_ownsMemory.i, align 8
  %5 = and i8 %4, 1
  %tobool2.not.i = icmp eq i8 %5, 0
  br i1 %tobool2.not.i, label %_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE10deallocateEv.exit, label %if.then3.i

if.then3.i:                                       ; preds = %if.then.i22
  tail call void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %3)
  br label %_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE10deallocateEv.exit

_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE10deallocateEv.exit: ; preds = %if.then.i22, %if.then3.i, %if.end
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.58, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  store ptr %retval.0.i25, ptr %m_data.i20, align 8
  store i32 %_Count.addr.0, ptr %m_capacity.i, align 8
  br label %if.end7

if.end7:                                          ; preds = %_ZN20b3AlignedObjectArrayI18b3QuantizedBvhNodeE10deallocateEv.exit, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI9b3BvhInfoE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) local_unnamed_addr #8 comdat align 2 {
entry:
  %m_capacity.i = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this, i64 0, i32 3
  %0 = load i32, ptr %m_capacity.i, align 8
  %cmp = icmp slt i32 %0, %_Count
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %tobool.not.i = icmp eq i32 %_Count, 0
  br i1 %tobool.not.i, label %_ZNK20b3AlignedObjectArrayI9b3BvhInfoE4copyEiiPS0_.exit18, label %_ZN20b3AlignedObjectArrayI9b3BvhInfoE8allocateEi.exit

_ZN20b3AlignedObjectArrayI9b3BvhInfoE8allocateEi.exit: ; preds = %if.then
  %conv.i.i = sext i32 %_Count to i64
  %mul.i.i = shl nsw i64 %conv.i.i, 6
  %call.i.i = tail call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i, i32 noundef 16)
  %cmp3 = icmp eq ptr %call.i.i, null
  br i1 %cmp3, label %_ZNK20b3AlignedObjectArrayI9b3BvhInfoE4copyEiiPS0_.exit18, label %if.then.split

if.then.split:                                    ; preds = %_ZN20b3AlignedObjectArrayI9b3BvhInfoE8allocateEi.exit
  %m_size.i = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this, i64 0, i32 2
  %1 = load i32, ptr %m_size.i, align 4
  %cmp4.i = icmp sgt i32 %1, 0
  br i1 %cmp4.i, label %for.body.lr.ph.i, label %if.end

for.body.lr.ph.i:                                 ; preds = %if.then.split
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this, i64 0, i32 5
  %wide.trip.count.i = zext nneg i32 %1 to i64
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %for.body.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %for.body.lr.ph.i ], [ %indvars.iv.next.i, %for.body.i ]
  %arrayidx.i = getelementptr inbounds %struct.b3BvhInfo, ptr %call.i.i, i64 %indvars.iv.i
  %2 = load ptr, ptr %m_data.i, align 8
  %arrayidx3.i = getelementptr inbounds %struct.b3BvhInfo, ptr %2, i64 %indvars.iv.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(64) %arrayidx.i, ptr noundef nonnull align 16 dereferenceable(64) %arrayidx3.i, i64 64, i1 false)
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %if.end, label %for.body.i, !llvm.loop !93

_ZNK20b3AlignedObjectArrayI9b3BvhInfoE4copyEiiPS0_.exit18: ; preds = %if.then, %_ZN20b3AlignedObjectArrayI9b3BvhInfoE8allocateEi.exit
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this, i64 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %for.body.i, %if.then.split, %_ZNK20b3AlignedObjectArrayI9b3BvhInfoE4copyEiiPS0_.exit18
  %retval.0.i25 = phi ptr [ null, %_ZNK20b3AlignedObjectArrayI9b3BvhInfoE4copyEiiPS0_.exit18 ], [ %call.i.i, %if.then.split ], [ %call.i.i, %for.body.i ]
  %_Count.addr.0 = phi i32 [ 0, %_ZNK20b3AlignedObjectArrayI9b3BvhInfoE4copyEiiPS0_.exit18 ], [ %_Count, %if.then.split ], [ %_Count, %for.body.i ]
  %m_data.i20 = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this, i64 0, i32 5
  %3 = load ptr, ptr %m_data.i20, align 8
  %tobool.not.i21 = icmp eq ptr %3, null
  br i1 %tobool.not.i21, label %_ZN20b3AlignedObjectArrayI9b3BvhInfoE10deallocateEv.exit, label %if.then.i22

if.then.i22:                                      ; preds = %if.end
  %m_ownsMemory.i = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this, i64 0, i32 6
  %4 = load i8, ptr %m_ownsMemory.i, align 8
  %5 = and i8 %4, 1
  %tobool2.not.i = icmp eq i8 %5, 0
  br i1 %tobool2.not.i, label %_ZN20b3AlignedObjectArrayI9b3BvhInfoE10deallocateEv.exit, label %if.then3.i

if.then3.i:                                       ; preds = %if.then.i22
  tail call void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %3)
  br label %_ZN20b3AlignedObjectArrayI9b3BvhInfoE10deallocateEv.exit

_ZN20b3AlignedObjectArrayI9b3BvhInfoE10deallocateEv.exit: ; preds = %if.then.i22, %if.then3.i, %if.end
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.43, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  store ptr %retval.0.i25, ptr %m_data.i20, align 8
  store i32 %_Count.addr.0, ptr %m_capacity.i, align 8
  br label %if.end7

if.end7:                                          ; preds = %_ZN20b3AlignedObjectArrayI9b3BvhInfoE10deallocateEv.exit, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN20b3AlignedObjectArrayI6b3AabbE7reserveEi(ptr noundef nonnull align 8 dereferenceable(25) %this, i32 noundef %_Count) local_unnamed_addr #8 comdat align 2 {
entry:
  %m_capacity.i = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this, i64 0, i32 3
  %0 = load i32, ptr %m_capacity.i, align 8
  %cmp = icmp slt i32 %0, %_Count
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %tobool.not.i = icmp eq i32 %_Count, 0
  br i1 %tobool.not.i, label %_ZNK20b3AlignedObjectArrayI6b3AabbE4copyEiiPS0_.exit18, label %_ZN20b3AlignedObjectArrayI6b3AabbE8allocateEi.exit

_ZN20b3AlignedObjectArrayI6b3AabbE8allocateEi.exit: ; preds = %if.then
  %conv.i.i = sext i32 %_Count to i64
  %mul.i.i = shl nsw i64 %conv.i.i, 5
  %call.i.i = tail call noundef ptr @_Z22b3AlignedAllocInternalmi(i64 noundef %mul.i.i, i32 noundef 16)
  %cmp3 = icmp eq ptr %call.i.i, null
  br i1 %cmp3, label %_ZNK20b3AlignedObjectArrayI6b3AabbE4copyEiiPS0_.exit18, label %if.then.split

if.then.split:                                    ; preds = %_ZN20b3AlignedObjectArrayI6b3AabbE8allocateEi.exit
  %m_size.i = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this, i64 0, i32 2
  %1 = load i32, ptr %m_size.i, align 4
  %cmp4.i = icmp sgt i32 %1, 0
  br i1 %cmp4.i, label %for.body.lr.ph.i, label %if.end

for.body.lr.ph.i:                                 ; preds = %if.then.split
  %m_data.i = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this, i64 0, i32 5
  %wide.trip.count.i = zext nneg i32 %1 to i64
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %for.body.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %for.body.lr.ph.i ], [ %indvars.iv.next.i, %for.body.i ]
  %arrayidx.i = getelementptr inbounds %struct.b3Aabb, ptr %call.i.i, i64 %indvars.iv.i
  %2 = load ptr, ptr %m_data.i, align 8
  %arrayidx3.i = getelementptr inbounds %struct.b3Aabb, ptr %2, i64 %indvars.iv.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) %arrayidx.i, ptr noundef nonnull align 16 dereferenceable(32) %arrayidx3.i, i64 32, i1 false)
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %if.end, label %for.body.i, !llvm.loop !94

_ZNK20b3AlignedObjectArrayI6b3AabbE4copyEiiPS0_.exit18: ; preds = %if.then, %_ZN20b3AlignedObjectArrayI6b3AabbE8allocateEi.exit
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.78, i32 noundef 301)
  tail call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.79)
  %m_size = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this, i64 0, i32 2
  store i32 0, ptr %m_size, align 4
  br label %if.end

if.end:                                           ; preds = %for.body.i, %if.then.split, %_ZNK20b3AlignedObjectArrayI6b3AabbE4copyEiiPS0_.exit18
  %retval.0.i25 = phi ptr [ null, %_ZNK20b3AlignedObjectArrayI6b3AabbE4copyEiiPS0_.exit18 ], [ %call.i.i, %if.then.split ], [ %call.i.i, %for.body.i ]
  %_Count.addr.0 = phi i32 [ 0, %_ZNK20b3AlignedObjectArrayI6b3AabbE4copyEiiPS0_.exit18 ], [ %_Count, %if.then.split ], [ %_Count, %for.body.i ]
  %m_data.i20 = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this, i64 0, i32 5
  %3 = load ptr, ptr %m_data.i20, align 8
  %tobool.not.i21 = icmp eq ptr %3, null
  br i1 %tobool.not.i21, label %_ZN20b3AlignedObjectArrayI6b3AabbE10deallocateEv.exit, label %if.then.i22

if.then.i22:                                      ; preds = %if.end
  %m_ownsMemory.i = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this, i64 0, i32 6
  %4 = load i8, ptr %m_ownsMemory.i, align 8
  %5 = and i8 %4, 1
  %tobool2.not.i = icmp eq i8 %5, 0
  br i1 %tobool2.not.i, label %_ZN20b3AlignedObjectArrayI6b3AabbE10deallocateEv.exit, label %if.then3.i

if.then3.i:                                       ; preds = %if.then.i22
  tail call void @_Z21b3AlignedFreeInternalPv(ptr noundef nonnull %3)
  br label %_ZN20b3AlignedObjectArrayI6b3AabbE10deallocateEv.exit

_ZN20b3AlignedObjectArrayI6b3AabbE10deallocateEv.exit: ; preds = %if.then.i22, %if.then3.i, %if.end
  %m_ownsMemory = getelementptr inbounds %class.b3AlignedObjectArray.62, ptr %this, i64 0, i32 6
  store i8 1, ptr %m_ownsMemory, align 8
  store ptr %retval.0.i25, ptr %m_data.i20, align 8
  store i32 %_Count.addr.0, ptr %m_capacity.i, align 8
  br label %if.end7

if.end7:                                          ; preds = %_ZN20b3AlignedObjectArrayI6b3AabbE10deallocateEv.exit, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN13b3OpenCLArrayI6b3Int4E7reserveEmb(ptr noundef nonnull align 8 dereferenceable(50) %this, i64 noundef %_Count, i1 noundef zeroext %copyOldContents) local_unnamed_addr #8 comdat align 2 {
entry:
  %ciErrNum = alloca i32, align 4
  %m_capacity.i = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this, i64 0, i32 2
  %0 = load i64, ptr %m_capacity.i, align 8
  %cmp = icmp ult i64 %0, %_Count
  br i1 %cmp, label %if.then, label %if.end14

if.then:                                          ; preds = %entry
  %m_allowGrowingCapacity = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this, i64 0, i32 7
  %1 = load i8, ptr %m_allowGrowingCapacity, align 1
  %2 = and i8 %1, 1
  %tobool.not = icmp eq i8 %2, 0
  br i1 %tobool.not, label %if.else, label %if.then2

if.then2:                                         ; preds = %if.then
  %mul = shl i64 %_Count, 4
  %3 = load ptr, ptr @__clewCreateBuffer, align 8
  %m_clContext = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this, i64 0, i32 4
  %4 = load ptr, ptr %m_clContext, align 8
  %call3 = call ptr %3(ptr noundef %4, i64 noundef 1, i64 noundef %mul, ptr noundef null, ptr noundef nonnull %ciErrNum)
  %5 = load i32, ptr %ciErrNum, align 4
  %cmp4.not.not = icmp eq i32 %5, 0
  br i1 %cmp4.not.not, label %if.end, label %if.end.thread

if.end.thread:                                    ; preds = %if.then2
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.75, i32 noundef 166)
  call void (ptr, ...) @b3OutputErrorMessageVarArgsInternal(ptr noundef nonnull @.str.76)
  br label %if.end12

if.end:                                           ; preds = %if.then2
  br i1 %copyOldContents, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.end
  %m_size.i = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this, i64 0, i32 1
  %6 = load i64, ptr %m_size.i, align 8
  %cmp.i = icmp eq i64 %6, 0
  br i1 %cmp.i, label %if.end12, label %if.end.i

if.end.i:                                         ; preds = %if.then9
  %7 = load ptr, ptr @__clewEnqueueCopyBuffer, align 8
  %m_commandQueue.i = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this, i64 0, i32 5
  %8 = load ptr, ptr %m_commandQueue.i, align 8
  %m_clBuffer.i = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this, i64 0, i32 3
  %9 = load ptr, ptr %m_clBuffer.i, align 8
  %mul3.i = shl i64 %6, 4
  %call.i = call i32 %7(ptr noundef %8, ptr noundef %9, ptr noundef %call3, i64 noundef 0, i64 noundef 0, i64 noundef %mul3.i, i32 noundef 0, ptr noundef null, ptr noundef null)
  br label %if.end12

if.end12:                                         ; preds = %if.end.i, %if.then9, %if.end.thread, %if.end
  %_Count.addr.023 = phi i64 [ 0, %if.end.thread ], [ %_Count, %if.end ], [ %_Count, %if.then9 ], [ %_Count, %if.end.i ]
  %m_clBuffer.i5 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this, i64 0, i32 3
  %10 = load ptr, ptr %m_clBuffer.i5, align 8
  %tobool.not.i = icmp eq ptr %10, null
  br i1 %tobool.not.i, label %_ZN13b3OpenCLArrayI6b3Int4E10deallocateEv.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end12
  %m_ownsMemory.i = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this, i64 0, i32 6
  %11 = load i8, ptr %m_ownsMemory.i, align 8
  %12 = and i8 %11, 1
  %tobool2.not.i = icmp eq i8 %12, 0
  br i1 %tobool2.not.i, label %_ZN13b3OpenCLArrayI6b3Int4E10deallocateEv.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i
  %13 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i6 = call i32 %13(ptr noundef nonnull %10)
  br label %_ZN13b3OpenCLArrayI6b3Int4E10deallocateEv.exit

_ZN13b3OpenCLArrayI6b3Int4E10deallocateEv.exit:   ; preds = %if.end12, %land.lhs.true.i, %if.then.i
  store ptr %call3, ptr %m_clBuffer.i5, align 8
  store i64 %_Count.addr.023, ptr %m_capacity.i, align 8
  br label %if.end14

if.else:                                          ; preds = %if.then
  %m_clBuffer.i9 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this, i64 0, i32 3
  %14 = load ptr, ptr %m_clBuffer.i9, align 8
  %tobool.not.i10 = icmp eq ptr %14, null
  br i1 %tobool.not.i10, label %_ZN13b3OpenCLArrayI6b3Int4E10deallocateEv.exit18, label %land.lhs.true.i11

land.lhs.true.i11:                                ; preds = %if.else
  %m_ownsMemory.i12 = getelementptr inbounds %class.b3OpenCLArray.70, ptr %this, i64 0, i32 6
  %15 = load i8, ptr %m_ownsMemory.i12, align 8
  %16 = and i8 %15, 1
  %tobool2.not.i13 = icmp eq i8 %16, 0
  br i1 %tobool2.not.i13, label %_ZN13b3OpenCLArrayI6b3Int4E10deallocateEv.exit18, label %if.then.i14

if.then.i14:                                      ; preds = %land.lhs.true.i11
  %17 = load ptr, ptr @__clewReleaseMemObject, align 8
  %call.i15 = tail call i32 %17(ptr noundef nonnull %14)
  br label %_ZN13b3OpenCLArrayI6b3Int4E10deallocateEv.exit18

_ZN13b3OpenCLArrayI6b3Int4E10deallocateEv.exit18: ; preds = %if.else, %land.lhs.true.i11, %if.then.i14
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %m_capacity.i, i8 0, i64 16, i1 false)
  br label %if.end14

if.end14:                                         ; preds = %_ZN13b3OpenCLArrayI6b3Int4E10deallocateEv.exit, %_ZN13b3OpenCLArrayI6b3Int4E10deallocateEv.exit18, %entry
  %result.1 = phi i1 [ %cmp4.not.not, %_ZN13b3OpenCLArrayI6b3Int4E10deallocateEv.exit ], [ false, %_ZN13b3OpenCLArrayI6b3Int4E10deallocateEv.exit18 ], [ true, %entry ]
  ret i1 %result.1
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(write, argmem: none, inaccessiblemem: none) uwtable
define internal void @_GLOBAL__sub_I_b3ConvexHullContact.cpp() #21 section ".text.startup" {
entry:
  store <2 x float> <float 0.000000e+00, float -1.000000e+00>, ptr @unitSphere162, align 16
  store <2 x float> zeroinitializer, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 0, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FCA01D5C0000000, float 0xBFEEF97240000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 1), align 16
  store <2 x float> <float 0x3FC2E52580000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 1, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFB3DE0D60000000, float 0xBFEEF97240000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 2), align 16
  store <2 x float> <float 0x3FCE92BC20000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 2, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FE727C9E0000000, float 0xBFDC9F40A0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 3), align 16
  store <2 x float> <float 0x3FE0D2BD40000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 3, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FE38168C0000000, float 0xBFE50A6540000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 4), align 16
  store <2 x float> <float 0x3FDC57C0C0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 4, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FEA01E040000000, float 0xBFE012D980000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 5), align 16
  store <2 x float> <float 0x3FD2E52DE0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 5, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFD012CAE0000000, float 0xBFEEF97020000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 6), align 16
  store <2 x float> zeroinitializer, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 6, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFB3DE0D60000000, float 0xBFEEF97240000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 7), align 16
  store <2 x float> <float 0xBFCE92BC20000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 7, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FCA01D5C0000000, float 0xBFEEF97240000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 8), align 16
  store <2 x float> <float 0xBFC2E52580000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 8, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FEB8AD680000000, float 0xBFD012DBA0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 9), align 16
  store <2 x float> <float 0x3FDC57C920000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 9, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFD1B05740000000, float 0xBFDC9F40A0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 10), align 16
  store <2 x float> <float 0x3FEB388440000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 10, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBF9E59AFA0000000, float 0xBFE012DBA0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 11), align 16
  store <2 x float> <float 0x3FEBA76540000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 11, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFC3DE15C0000000, float 0xBFD012DFE0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 12), align 16
  store <2 x float> <float 0x3FEE92D120000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 12, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFEC9F2340000000, float 0xBFDC9F2FE0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 13), align 16
  store <2 x float> zeroinitializer, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 13, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFEA97F840000000, float 0xBFE012D560000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 14), align 16
  store <2 x float> <float 0x3FCE92BC20000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 14, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFEE9CAE20000000, float 0xBFD012D340000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 15), align 16
  store <2 x float> <float 0x3FC2E52580000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 15, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFD1B05740000000, float 0xBFDC9F40A0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 16), align 16
  store <2 x float> <float 0xBFEB388440000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 16, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFDEF96180000000, float 0xBFE012DBA0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 17), align 16
  store <2 x float> <float 0xBFE6EE19C0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 17, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFDBE789E0000000, float 0xBFD012DFE0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 18), align 16
  store <2 x float> <float 0xBFEBA76DA0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 18, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FE727C9E0000000, float 0xBFDC9F40A0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 19), align 16
  store <2 x float> <float 0xBFE0D2BD40000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 19, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FE105A920000000, float 0xBFE012DBA0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 20), align 16
  store <2 x float> <float 0xBFE5D095A0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 20, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FE5FD34E0000000, float 0xBFD012DFE0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 21), align 16
  store <2 x float> <float 0xBFE5D09C00000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 21, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FE5FD34E0000000, float 0xBFD012DFE0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 22), align 16
  store <2 x float> <float 0x3FE5D09C00000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 22, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFDBE789E0000000, float 0xBFD012DFE0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 23), align 16
  store <2 x float> <float 0x3FEBA76DA0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 23, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFEE9CAE20000000, float 0xBFD012D340000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 24), align 16
  store <2 x float> <float 0xBFC2E52580000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 24, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFC3DE15C0000000, float 0xBFD012DFE0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 25), align 16
  store <2 x float> <float 0xBFEE92D120000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 25, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FEB8AD680000000, float 0xBFD012DBA0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 26), align 16
  store <2 x float> <float 0xBFDC57C920000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 26, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FD1B05740000000, float 0x3FDC9F40A0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 27), align 16
  store <2 x float> <float 0x3FEB388440000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 27, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FDEF96180000000, float 0x3FE012DBA0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 28), align 16
  store <2 x float> <float 0x3FE6EE19C0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 28, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FCDCD1C80000000, float 0x3FE50A6540000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 29), align 16
  store <2 x float> <float 0x3FE6EE1580000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 29, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFE727C9E0000000, float 0x3FDC9F40A0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 30), align 16
  store <2 x float> <float 0x3FE0D2BD40000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 30, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFE105A920000000, float 0x3FE012DBA0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 31), align 16
  store <2 x float> <float 0x3FE5D095A0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 31, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFE38168C0000000, float 0x3FE50A6540000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 32), align 16
  store <2 x float> <float 0x3FDC57C0C0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 32, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFE727C9E0000000, float 0x3FDC9F40A0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 33), align 16
  store <2 x float> <float 0xBFE0D2BD40000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 33, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFEA01E040000000, float 0x3FE012D980000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 34), align 16
  store <2 x float> <float 0xBFD2E52DE0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 34, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFE38168C0000000, float 0x3FE50A6540000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 35), align 16
  store <2 x float> <float 0xBFDC57C0C0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 35, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FD1B05740000000, float 0x3FDC9F40A0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 36), align 16
  store <2 x float> <float 0xBFEB388440000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 36, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3F9E59AFA0000000, float 0x3FE012DBA0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 37), align 16
  store <2 x float> <float 0xBFEBA76540000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 37, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FCDCD1C80000000, float 0x3FE50A6540000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 38), align 16
  store <2 x float> <float 0xBFE6EE1580000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 38, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FEC9F2340000000, float 0x3FDC9F2FE0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 39), align 16
  store <2 x float> zeroinitializer, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 39, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FEA97F840000000, float 0x3FE012D560000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 40), align 16
  store <2 x float> <float 0xBFCE92BC20000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 40, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FE81C3260000000, float 0x3FE50A5CE0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 41), align 16
  store <2 x float> zeroinitializer, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 41, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFCDCD1C80000000, float 0xBFE50A6540000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 42), align 16
  store <2 x float> <float 0x3FE6EE1580000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 42, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFC4CB5BC0000000, float 0xBFEB388EC0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 43), align 16
  store <2 x float> <float 0x3FDFFFEB00000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 43, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FAB074A80000000, float 0xBFE727D460000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 44), align 16
  store <2 x float> <float 0x3FE6059C80000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 44, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FC1B08140000000, float 0xBFEC9F29A0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 45), align 16
  store <2 x float> <float 0x3FDB3875A0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 45, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FD0D2D880000000, float 0xBFE0D2D880000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 46), align 16
  store <2 x float> <float 0x3FE9E36D20000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 46, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FD727D020000000, float 0xBFE727D240000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 47), align 16
  store <2 x float> <float 0x3FE2CF15E0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 47, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FE105A920000000, float 0xBFE012DBA0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 48), align 16
  store <2 x float> <float 0x3FE5D095A0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 48, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FDB387E00000000, float 0xBFEB388EC0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 49), align 16
  store <2 x float> <float 0x3FD3C6D620000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 49, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FEA01E040000000, float 0xBFE012D980000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 50), align 16
  store <2 x float> <float 0xBFD2E52DE0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 50, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FE38168C0000000, float 0xBFE50A6540000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 51), align 16
  store <2 x float> <float 0xBFDC57C0C0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 51, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FEB388220000000, float 0xBFE0D2D440000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 52), align 16
  store <2 x float> zeroinitializer, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 52, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FE5775540000000, float 0xBFE727D240000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 53), align 16
  store <2 x float> <float 0xBFC4CB6420000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 53, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FE5775540000000, float 0xBFE727D020000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 54), align 16
  store <2 x float> <float 0x3FC4CB6C80000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 54, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FDB387E00000000, float 0xBFEB388EC0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 55), align 16
  store <2 x float> <float 0xBFD3C6D620000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 55, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FDC9F1AE0000000, float 0xBFEC9F2780000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 56), align 16
  store <2 x float> <float 0x3EB0C6F7A0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 56, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFE81C3260000000, float 0xBFE50A5CE0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 57), align 16
  store <2 x float> zeroinitializer, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 57, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFE0D2C7C0000000, float 0xBFEB388A80000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 58), align 16
  store <2 x float> zeroinitializer, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 58, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFE46C17E0000000, float 0xBFE727CE00000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 59), align 16
  store <2 x float> <float 0x3FD0D2C380000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 59, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFD727BF60000000, float 0xBFEC9F2780000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 60), align 16
  store <2 x float> <float 0x3FD0D2C380000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 60, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFE605A500000000, float 0xBFE0D2D440000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 61), align 16
  store <2 x float> <float 0x3FDFFFF360000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 61, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFDC9F1AE0000000, float 0xBFE727D020000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 62), align 16
  store <2 x float> <float 0x3FE0D2C5A0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 62, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFDEF96180000000, float 0xBFE012DBA0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 63), align 16
  store <2 x float> <float 0x3FE6EE19C0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 63, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFCDCD1C80000000, float 0xBFE50A6540000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 64), align 16
  store <2 x float> <float 0xBFE6EE1580000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 64, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFC4CB5BC0000000, float 0xBFEB388EC0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 65), align 16
  store <2 x float> <float 0xBFDFFFEB00000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 65, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFDC9F1AE0000000, float 0xBFE727D240000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 66), align 16
  store <2 x float> <float 0xBFE0D2C160000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 66, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFD727BF60000000, float 0xBFEC9F29A0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 67), align 16
  store <2 x float> <float 0xBFD0D2BF60000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 67, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFE605A500000000, float 0xBFE0D2D440000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 68), align 16
  store <2 x float> <float 0xBFDFFFF360000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 68, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFE46C17E0000000, float 0xBFE727CE00000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 69), align 16
  store <2 x float> <float 0xBFD0D2BF60000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 69, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFEA97F840000000, float 0xBFE012D560000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 70), align 16
  store <2 x float> <float 0xBFCE92BC20000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 70, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FD727CC00000000, float 0xBFE727D460000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 71), align 16
  store <2 x float> <float 0xBFE2CF15E0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 71, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FC1B07080000000, float 0xBFEC9F29A0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 72), align 16
  store <2 x float> <float 0xBFDB3875A0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 72, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FD0D2D880000000, float 0xBFE0D2D880000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 73), align 16
  store <2 x float> <float 0xBFE9E36D20000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 73, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FAB0728E0000000, float 0xBFE727D240000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 74), align 16
  store <2 x float> <float 0xBFE6059EA0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 74, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBF9E59AFA0000000, float 0xBFE012DBA0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 75), align 16
  store <2 x float> <float 0xBFEBA76540000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 75, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FEE9CAE20000000, float 0x3FD012D340000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 76), align 16
  store <2 x float> <float 0x3FC2E52580000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 76, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FEE9CAE20000000, float 0x3FD012D340000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 77), align 16
  store <2 x float> <float 0xBFC2E52580000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 77, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FEE6F1120000000, float -0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 78), align 16
  store <2 x float> <float 0x3FD3C6DE80000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 78, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 1.000000e+00, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 79), align 16
  store <2 x float> zeroinitializer, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 79, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FEE4F91A0000000, float 0xBFD1B078E0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 80), align 16
  store <2 x float> <float 0x3FC4CB6C80000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 80, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FEE6F1120000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 81), align 16
  store <2 x float> <float 0xBFD3C6DE80000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 81, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FEE4F91A0000000, float 0xBFD1B078E0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 82), align 16
  store <2 x float> <float 0xBFC4CB6C80000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 82, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FC3DE15C0000000, float 0x3FD012DFE0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 83), align 16
  store <2 x float> <float 0x3FEE92D120000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 83, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FDBE789E0000000, float 0x3FD012DFE0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 84), align 16
  store <2 x float> <float 0x3FEBA76DA0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 84, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float -0.000000e+00, float -0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 85), align 16
  store <2 x float> <float 1.000000e+00, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 85, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FD3C6EF40000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 86), align 16
  store <2 x float> <float 0x3FEE6F0D00000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 86, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FC1B08140000000, float 0xBFD1B08140000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 87), align 16
  store <2 x float> <float 0x3FEE6F0AE0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 87, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FE2CF24A0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 88), align 16
  store <2 x float> <float 0x3FE9E377A0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 88, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FDC9F2FE0000000, float 0xBFD1B08140000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 89), align 16
  store <2 x float> <float 0x3FEB388220000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 89, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFEB8AD680000000, float 0x3FD012DBA0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 90), align 16
  store <2 x float> <float 0x3FDC57C920000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 90, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFE5FD34E0000000, float 0x3FD012DFE0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 91), align 16
  store <2 x float> <float 0x3FE5D09C00000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 91, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFEE6F1120000000, float -0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 92), align 16
  store <2 x float> <float 0x3FD3C6DE80000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 92, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFE9E379C0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 93), align 16
  store <2 x float> <float 0x3FE2CF1E40000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 93, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFEB93E3E0000000, float 0xBFD1B078E0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 94), align 16
  store <2 x float> <float 0x3FDB388220000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 94, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFE2CF24A0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 95), align 16
  store <2 x float> <float 0x3FE9E377A0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 95, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFE5775960000000, float 0xBFD1B07D00000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 96), align 16
  store <2 x float> <float 0x3FE605A920000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 96, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFE5FD34E0000000, float 0x3FD012DFE0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 97), align 16
  store <2 x float> <float 0xBFE5D09C00000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 97, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFEB8AD680000000, float 0x3FD012DBA0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 98), align 16
  store <2 x float> <float 0xBFDC57C920000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 98, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFE2CF24A0000000, float -0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 99), align 16
  store <2 x float> <float 0xBFE9E377A0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 99, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFE9E379C0000000, float -0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 100), align 16
  store <2 x float> <float 0xBFE2CF1E40000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 100, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFE5775960000000, float 0xBFD1B07D00000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 101), align 16
  store <2 x float> <float 0xBFE605A920000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 101, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFEE6F1120000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 102), align 16
  store <2 x float> <float 0xBFD3C6DE80000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 102, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFEB93E3E0000000, float 0xBFD1B078E0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 103), align 16
  store <2 x float> <float 0xBFDB388220000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 103, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FDBE789E0000000, float 0x3FD012DFE0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 104), align 16
  store <2 x float> <float 0xBFEBA76DA0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 104, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FC3DE15C0000000, float 0x3FD012DFE0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 105), align 16
  store <2 x float> <float 0xBFEE92D120000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 105, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FE2CF24A0000000, float -0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 106), align 16
  store <2 x float> <float 0xBFE9E377A0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 106, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FD3C6EF40000000, float -0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 107), align 16
  store <2 x float> <float 0xBFEE6F0D00000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 107, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FDC9F2FE0000000, float 0xBFD1B08140000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 108), align 16
  store <2 x float> <float 0xBFEB388220000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 108, i32 0, i32 0, i64 2), align 8
  store <2 x float> zeroinitializer, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 109), align 16
  store <2 x float> <float -1.000000e+00, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 109, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FC1B08140000000, float 0xBFD1B08140000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 110), align 16
  store <2 x float> <float 0xBFEE6F0AE0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 110, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FE5775B80000000, float 0x3FD1B078E0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 111), align 16
  store <2 x float> <float 0x3FE605A700000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 111, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FE9E37BE0000000, float 0xBEC0C6F7A0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 112), align 16
  store <2 x float> <float 0x3FE2CF1E40000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 112, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FE605A500000000, float 0x3FE0D2D440000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 113), align 16
  store <2 x float> <float 0x3FDFFFF360000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 113, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FEB93E600000000, float 0x3FD1B07080000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 114), align 16
  store <2 x float> <float 0x3FDB387E00000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 114, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FEA97F840000000, float 0x3FE012D560000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 115), align 16
  store <2 x float> <float 0x3FCE92BC20000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 115, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFDC9F2FE0000000, float 0x3FD1B07D00000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 116), align 16
  store <2 x float> <float 0x3FEB388440000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 116, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFD3C6EF40000000, float 0xBEB0C6F7A0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 117), align 16
  store <2 x float> <float 0x3FEE6F0D00000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 117, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFD0D2D880000000, float 0x3FE0D2D880000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 118), align 16
  store <2 x float> <float 0x3FE9E36D20000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 118, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFC1B08140000000, float 0x3FD1B07D00000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 119), align 16
  store <2 x float> <float 0x3FEE6F0AE0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 119, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3F9E59AFA0000000, float 0x3FE012DBA0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 120), align 16
  store <2 x float> <float 0x3FEBA76540000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 120, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFEE4F91A0000000, float 0x3FD1B078E0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 121), align 16
  store <2 x float> <float 0xBFC4CB6C80000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 121, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float -1.000000e+00, float 0x3EB0C6F7A0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 122), align 16
  store <2 x float> zeroinitializer, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 122, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFEB388220000000, float 0x3FE0D2D440000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 123), align 16
  store <2 x float> <float -0.000000e+00, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 123, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFEE4F91A0000000, float 0x3FD1B07D00000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 124), align 16
  store <2 x float> <float 0x3FC4CB6C80000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 124, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFEA01E040000000, float 0x3FE012D980000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 125), align 16
  store <2 x float> <float 0x3FD2E52DE0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 125, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFC1B08140000000, float 0x3FD1B07D00000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 126), align 16
  store <2 x float> <float 0xBFEE6F0AE0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 126, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFD3C6EB00000000, float -0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 127), align 16
  store <2 x float> <float 0xBFEE6F0F20000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 127, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFD0D2D880000000, float 0x3FE0D2D880000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 128), align 16
  store <2 x float> <float 0xBFE9E36D20000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 128, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFDC9F2BA0000000, float 0x3FD1B07D00000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 129), align 16
  store <2 x float> <float 0xBFEB388440000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 129, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFE105A920000000, float 0x3FE012DBA0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 130), align 16
  store <2 x float> <float 0xBFE5D095A0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 130, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FEB93E600000000, float 0x3FD1B078E0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 131), align 16
  store <2 x float> <float 0xBFDB3879C0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 131, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FE9E37BE0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 132), align 16
  store <2 x float> <float 0xBFE2CF1C40000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 132, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FE605A500000000, float 0x3FE0D2D440000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 133), align 16
  store <2 x float> <float 0xBFDFFFF360000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 133, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FE5775DA0000000, float 0x3FD1B07D00000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 134), align 16
  store <2 x float> <float 0xBFE605A500000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 134, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FDEF96180000000, float 0x3FE012DBA0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 135), align 16
  store <2 x float> <float 0xBFE6EE19C0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 135, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FB3DE0D60000000, float 0x3FEEF97240000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 136), align 16
  store <2 x float> <float 0x3FCE92BC20000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 136, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FD012CAE0000000, float 0x3FEEF97020000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 137), align 16
  store <2 x float> zeroinitializer, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 137, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0.000000e+00, float 1.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 138), align 16
  store <2 x float> zeroinitializer, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 138, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FC4CB5BC0000000, float 0x3FEB388EC0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 139), align 16
  store <2 x float> <float 0x3FDFFFEB00000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 139, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FD727BB20000000, float 0x3FEC9F29A0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 140), align 16
  store <2 x float> <float 0x3FD0D2BF60000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 140, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FDC9F1280000000, float 0x3FE727D460000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 141), align 16
  store <2 x float> <float 0x3FE0D2C380000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 141, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FE0D2C7C0000000, float 0x3FEB388A80000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 142), align 16
  store <2 x float> zeroinitializer, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 142, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FE46C15E0000000, float 0x3FE727D020000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 143), align 16
  store <2 x float> <float 0x3FD0D2C380000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 143, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFCA01D5C0000000, float 0x3FEEF97240000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 144), align 16
  store <2 x float> <float 0x3FC2E52580000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 144, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFDB387E00000000, float 0x3FEB388EC0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 145), align 16
  store <2 x float> <float 0x3FD3C6D620000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 145, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFC1B07080000000, float 0x3FEC9F2BA0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 146), align 16
  store <2 x float> <float 0x3FDB387160000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 146, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFD727CC00000000, float 0x3FE727D460000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 147), align 16
  store <2 x float> <float 0x3FE2CF13C0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 147, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFAB074A80000000, float 0x3FE727D460000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 148), align 16
  store <2 x float> <float 0x3FE6059C80000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 148, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFCA01D5C0000000, float 0x3FEEF97240000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 149), align 16
  store <2 x float> <float 0xBFC2E52580000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 149, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFDB387E00000000, float 0x3FEB388EC0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 150), align 16
  store <2 x float> <float 0xBFD3C6D620000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 150, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFDC9F16C0000000, float 0x3FEC9F29A0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 151), align 16
  store <2 x float> zeroinitializer, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 151, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFE5775540000000, float 0x3FE727D240000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 152), align 16
  store <2 x float> <float 0xBFC4CB6420000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 152, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFE5775540000000, float 0x3FE727D240000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 153), align 16
  store <2 x float> <float 0x3FC4CB6420000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 153, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FB3DE0D60000000, float 0x3FEEF97240000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 154), align 16
  store <2 x float> <float 0xBFCE92BC20000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 154, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FC4CB5BC0000000, float 0x3FEB388EC0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 155), align 16
  store <2 x float> <float 0xBFDFFFEB00000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 155, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFC1B07080000000, float 0x3FEC9F2BA0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 156), align 16
  store <2 x float> <float 0xBFDB387160000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 156, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFAB074A80000000, float 0x3FE727D460000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 157), align 16
  store <2 x float> <float 0xBFE6059C80000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 157, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0xBFD727CC00000000, float 0x3FE727D460000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 158), align 16
  store <2 x float> <float 0xBFE2CF13C0000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 158, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FD727BB20000000, float 0x3FEC9F29A0000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 159), align 16
  store <2 x float> <float 0xBFD0D2BF60000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 159, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FE46C15E0000000, float 0x3FE727D020000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 160), align 16
  store <2 x float> <float 0xBFD0D2C380000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 160, i32 0, i32 0, i64 2), align 8
  store <2 x float> <float 0x3FDC9F1280000000, float 0x3FE727D460000000>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 161), align 16
  store <2 x float> <float 0xBFE0D2C380000000, float 0.000000e+00>, ptr getelementptr inbounds ([162 x %class.b3Vector3], ptr @unitSphere162, i64 0, i64 161, i32 0, i32 0, i64 2), align 8
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smin.i32(i32, i32) #22

; Function Attrs: nofree nounwind
declare noundef i32 @puts(ptr nocapture noundef readonly) local_unnamed_addr #23

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #22

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #24

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #24

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.sqrt.f32(float) #22

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.umax.i64(i64, i64) #22

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memmove.p0.p0.i64(ptr nocapture writeonly, ptr nocapture readonly, i64, i1 immarg) #25

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare <2 x float> @llvm.fmuladd.v2f32(<2 x float>, <2 x float>, <2 x float>) #22

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare <4 x float> @llvm.fmuladd.v4f32(<4 x float>, <4 x float>, <4 x float>) #22

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare <2 x float> @llvm.fabs.v2f32(<2 x float>) #22

attributes #0 = { mustprogress nofree norecurse nounwind memory(argmem: readwrite, inaccessiblemem: readwrite) uwtable "frame-pointer"="all" "min-legal-vector-width"="64" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { mustprogress nofree nosync nounwind memory(argmem: readwrite) uwtable "frame-pointer"="all" "min-legal-vector-width"="64" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { mustprogress nofree nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="64" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { nofree nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { mustprogress uwtable "frame-pointer"="all" "min-legal-vector-width"="64" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #6 = { mustprogress nofree nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="64" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #7 = { mustprogress nofree nounwind memory(argmem: readwrite, inaccessiblemem: readwrite) uwtable "frame-pointer"="all" "min-legal-vector-width"="64" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #8 = { mustprogress uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #9 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #10 = { mustprogress nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #11 = { noreturn nounwind uwtable "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #12 = { nobuiltin nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #13 = { mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite) uwtable "frame-pointer"="all" "min-legal-vector-width"="64" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #14 = { mustprogress nofree nosync nounwind willreturn memory(argmem: read) uwtable "frame-pointer"="all" "min-legal-vector-width"="64" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #15 = { mustprogress nofree nosync nounwind memory(read, argmem: readwrite, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="64" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #16 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #17 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #18 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #19 = { mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #20 = { mustprogress nofree nounwind willreturn memory(write) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #21 = { mustprogress nofree norecurse nosync nounwind willreturn memory(write, argmem: none, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="64" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #22 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #23 = { nofree nounwind }
attributes #24 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #25 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #26 = { nounwind }
attributes #27 = { noreturn nounwind }
attributes #28 = { builtin nounwind }

!llvm.module.flags = !{!0, !1, !2, !3, !4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = distinct !{!5, !6}
!6 = !{!"llvm.loop.mustprogress"}
!7 = distinct !{!7, !6}
!8 = distinct !{!8, !6}
!9 = distinct !{!9, !6}
!10 = distinct !{!10, !6}
!11 = distinct !{!11, !6}
!12 = distinct !{!12, !6}
!13 = distinct !{!13, !6}
!14 = distinct !{!14, !6}
!15 = distinct !{!15, !6}
!16 = distinct !{!16, !6}
!17 = distinct !{!17, !6}
!18 = distinct !{!18, !6}
!19 = distinct !{!19, !6}
!20 = distinct !{!20, !6}
!21 = distinct !{!21, !6}
!22 = distinct !{!22, !6}
!23 = distinct !{!23, !6}
!24 = distinct !{!24, !6}
!25 = distinct !{!25, !6}
!26 = distinct !{!26, !6}
!27 = distinct !{!27, !6}
!28 = distinct !{!28, !6}
!29 = distinct !{!29, !6}
!30 = distinct !{!30, !6}
!31 = distinct !{!31, !6}
!32 = distinct !{!32, !6}
!33 = distinct !{!33, !6}
!34 = distinct !{!34, !6}
!35 = distinct !{!35, !6}
!36 = distinct !{!36, !6}
!37 = distinct !{!37, !6}
!38 = distinct !{!38, !6}
!39 = distinct !{!39, !6}
!40 = distinct !{!40, !6}
!41 = distinct !{!41, !6}
!42 = distinct !{!42, !6}
!43 = distinct !{!43, !6}
!44 = distinct !{!44, !6}
!45 = distinct !{!45, !6}
!46 = distinct !{!46, !6}
!47 = distinct !{!47, !6}
!48 = distinct !{!48, !6}
!49 = distinct !{!49, !6}
!50 = distinct !{!50, !6}
!51 = distinct !{!51, !6}
!52 = distinct !{!52, !6}
!53 = distinct !{!53, !6}
!54 = distinct !{!54, !6}
!55 = distinct !{!55, !6}
!56 = distinct !{!56, !6}
!57 = distinct !{!57, !6}
!58 = distinct !{!58, !6}
!59 = distinct !{!59, !6}
!60 = distinct !{!60, !6}
!61 = distinct !{!61, !6}
!62 = distinct !{!62, !6}
!63 = distinct !{!63, !6}
!64 = distinct !{!64, !6}
!65 = distinct !{!65, !6}
!66 = distinct !{!66, !6}
!67 = distinct !{!67, !6}
!68 = distinct !{!68, !6}
!69 = distinct !{!69, !6}
!70 = distinct !{!70, !6}
!71 = distinct !{!71, !6}
!72 = distinct !{!72, !6}
!73 = distinct !{!73, !6}
!74 = distinct !{!74, !6}
!75 = distinct !{!75, !6}
!76 = distinct !{!76, !6}
!77 = distinct !{!77, !6}
!78 = distinct !{!78, !6}
!79 = distinct !{!79, !6}
!80 = distinct !{!80, !6}
!81 = distinct !{!81, !6}
!82 = distinct !{!82, !6}
!83 = distinct !{!83, !6}
!84 = distinct !{!84, !6}
!85 = distinct !{!85, !6}
!86 = distinct !{!86, !6}
!87 = distinct !{!87, !6}
!88 = distinct !{!88, !6}
!89 = distinct !{!89, !6}
!90 = distinct !{!90, !6}
!91 = distinct !{!91, !6}
!92 = distinct !{!92, !6}
!93 = distinct !{!93, !6}
!94 = distinct !{!94, !6}
