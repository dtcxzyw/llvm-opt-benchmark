target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%"class.std::ios_base::Init" = type { i8 }
%"struct.absl::from_chars_result" = type { ptr, i32 }
%"struct.absl::strings_internal::ParsedFloat" = type { i64, i32, i32, i32, ptr, ptr, ptr }
%"struct.absl::(anonymous namespace)::CalculatedFloat" = type <{ i64, i32, [4 x i8] }>
%"class.absl::uint128" = type { i64, i64 }
%"class.absl::strings_internal::BigUnsigned" = type { i32, [84 x i32] }

$_ZN4abslanENS_12chars_formatES0_ = comdat any

$_ZSt3minIlERKT_S2_S2_ = comdat any

$_ZSt6copy_nIPKclPcET1_T_T0_S3_ = comdat any

$_ZNSt14numeric_limitsIdE8infinityEv = comdat any

$_ZSt17__size_to_integerl = comdat any

$_ZSt8__copy_nIPKclPcET1_T_T0_S3_St26random_access_iterator_tag = comdat any

$_ZSt19__iterator_categoryIPKcENSt15iterator_traitsIT_E17iterator_categoryERKS3_ = comdat any

$_ZSt4copyIPKcPcET0_T_S4_S3_ = comdat any

$_ZSt13__copy_move_aILb0EPKcPcET1_T0_S4_S3_ = comdat any

$_ZSt12__miter_baseIPKcET_S2_ = comdat any

$_ZSt12__niter_wrapIPcET_RKS1_S1_ = comdat any

$_ZSt14__copy_move_a1ILb0EPKcPcET1_T0_S4_S3_ = comdat any

$_ZSt12__niter_baseIPKcET_S2_ = comdat any

$_ZSt12__niter_baseIPcET_S1_ = comdat any

$_ZSt14__copy_move_a2ILb0EPKcPcET1_T0_S4_S3_ = comdat any

$_ZNSt11__copy_moveILb0ELb1ESt26random_access_iterator_tagE8__copy_mIcEEPT_PKS3_S6_S4_ = comdat any

$_ZN4absl9bit_widthImEENSt9enable_ifIXsr3std11is_unsignedIT_EE5valueEiE4typeES2_ = comdat any

$_ZN4absl7uint128C2Em = comdat any

$_ZN4absl11countl_zeroImEENSt9enable_ifIXsr3std11is_unsignedIT_EE5valueEiE4typeES2_ = comdat any

$__clang_call_terminate = comdat any

$_ZSt3maxIiERKT_S2_S2_ = comdat any

$_ZN4absllsENS_7uint128Ei = comdat any

$_ZNK4absl7uint128cvmEv = comdat any

$_ZN4abslmiENS_7uint128ES0_ = comdat any

$_ZN4absl7uint128C2Ei = comdat any

$_ZN4abslanENS_7uint128ES0_ = comdat any

$_ZN4absl7uint128rSEi = comdat any

$_ZN4abslgtENS_7uint128ES0_ = comdat any

$_ZN4abslplENS_7uint128ES0_ = comdat any

$_ZN4absleqENS_7uint128ES0_ = comdat any

$_ZN4absl7uint128ppEv = comdat any

$_ZNK4absl7uint128cvoEv = comdat any

$_ZN4absl7uint128C2Eo = comdat any

$_ZNSt14numeric_limitsImE3maxEv = comdat any

$_ZN4abslrsENS_7uint128Ei = comdat any

$_ZN4abslltENS_7uint128ES0_ = comdat any

$_ZN4absl7uint128pLES0_ = comdat any

$_ZNSt14numeric_limitsIdE3maxEv = comdat any

$_ZN4absl8bit_castIdmTnNSt9enable_ifIXaaaaeqstT_stT0_sr3std21is_trivially_copyableIS3_EE5valuesr3std21is_trivially_copyableIS2_EE5valueEiE4typeELi0EEES2_RKS3_ = comdat any

$_ZN4abslmlENS_7uint128ES0_ = comdat any

$_ZN4absl13Uint128High64ENS_7uint128E = comdat any

$_ZN4absl12Uint128Low64ENS_7uint128E = comdat any

$_ZN4absl7uint128mLES0_ = comdat any

$_ZN4absl16strings_internal7CompareILi84ELi84EEEiRKNS0_11BigUnsignedIXT_EEERKNS2_IXT0_EEE = comdat any

$_ZNSt14numeric_limitsIfE8infinityEv = comdat any

$_ZNSt14numeric_limitsIfE3maxEv = comdat any

$_ZN4absl8bit_castIfjTnNSt9enable_ifIXaaaaeqstT_stT0_sr3std21is_trivially_copyableIS3_EE5valuesr3std21is_trivially_copyableIS2_EE5valueEiE4typeELi0EEES2_RKS3_ = comdat any

@_ZStL8__ioinit = internal global %"class.std::ios_base::Init" zeroinitializer, align 1
@__dso_handle = external hidden global i8
@_ZZN4absl12_GLOBAL__N_111EiselLemireIdEEbRKNS_16strings_internal11ParsedFloatEbPT_PSt4errcE11high64_mask = internal constant i64 511, align 8
@_ZZN4absl12_GLOBAL__N_111EiselLemireIdEEbRKNS_16strings_internal11ParsedFloatEbPT_PSt4errcE8max_exp2 = internal constant i64 2047, align 8
@_ZN4absl12_GLOBAL__N_125kPower10MantissaHighTableE = internal constant [651 x i64] [i64 -1228264617323800998, i64 -7685194413468457480, i64 -4994806998408183946, i64 -1631822729582842029, i64 -7937418233630358124, i64 -5310086773610559751, i64 -2025922448585811785, i64 -8183730558007214222, i64 -5617977179081629873, i64 -2410785455424649437, i64 -8424269937281487754, i64 -5918651403174471789, i64 -2786628235540701832, i64 -8659171674854020501, i64 -6212278575140137722, i64 -3153662200497784248, i64 -8888567902952197011, i64 -6499023860262858360, i64 -3512093806901185046, i64 -9112587656954322510, i64 -6779048552765515233, i64 -3862124672529506138, i64 -215969822234494768, i64 -7052510166537641086, i64 -4203951689744663454, i64 -643253593753441413, i64 -7319562523736982739, i64 -4537767136243840520, i64 -1060522901877412746, i64 -7580355841314464822, i64 -4863758783215693124, i64 -1468012460592228501, i64 -7835036815511224669, i64 -5182110000961642932, i64 -1865951482774665761, i64 -8083748704375247957, i64 -5492999862041672042, i64 -2254563809124702148, i64 -8326631408344020699, i64 -5796603242002637969, i64 -2634068034075909558, i64 -8563821548938525330, i64 -6093090917745768758, i64 -3004677628754823043, i64 -8795452545612846258, i64 -6382629663588669919, i64 -3366601061058449494, i64 -9021654690802612790, i64 -6665382345075878084, i64 -3720041912917459700, i64 -38366372719436721, i64 -6941508010590729807, i64 -4065198994811024355, i64 -469812725086392539, i64 -7211161980820077193, i64 -4402266457597708587, i64 -891147053569747830, i64 -7474495936122174250, i64 -4731433901725329908, i64 -1302606358729274481, i64 -7731658001846878407, i64 -5052886483881210105, i64 -1704422086424124727, i64 -7982792831656159810, i64 -5366805021142811859, i64 -2096820258001126919, i64 -8228041688891786181, i64 -5673366092687344822, i64 -2480021597431793123, i64 -8467542526035952558, i64 -5972742139117552794, i64 -2854241655469553088, i64 -8701430062309552536, i64 -6265101559459552766, i64 -3219690930897053053, i64 -8929835859451740015, i64 -6550608805887287114, i64 -3576574988931720989, i64 -9152888395723407474, i64 -6829424476226871438, i64 -3925094576856201394, i64 -294682202642863838, i64 -7101705404292871755, i64 -4265445736938701790, i64 -720121152745989333, i64 -7367604748107325189, i64 -4597819916706768583, i64 -1135588877456072824, i64 -7627272076051127371, i64 -4922404076636521310, i64 -1541319077368263733, i64 -7880853450996246689, i64 -5239380795317920458, i64 -1937539975720012668, i64 -8128491512466089774, i64 -5548928372155224313, i64 -2324474446766642487, i64 -8370325556870233411, i64 -5851220927660403859, i64 -2702340141148116920, i64 -8606491615858654931, i64 -6146428501395930760, i64 -3071349608317525546, i64 -8837122532839535322, i64 -6434717147622031249, i64 -3431710416100151157, i64 -9062348037703676329, i64 -6716249028702207507, i64 -3783625267450371480, i64 -117845565885576446, i64 -6991182506319567135, i64 -4127292114472071014, i64 -547429124662700864, i64 -7259672230555269896, i64 -4462904269766699466, i64 -966944318780986428, i64 -7521869226879198374, i64 -4790650515171610063, i64 -1376627125537124675, i64 -7777920981101784778, i64 -5110715207949843068, i64 -1776707991509915931, i64 -8027971522334779313, i64 -5423278384491086237, i64 -2167411962186469893, i64 -8272161504007625539, i64 -5728515861582144020, i64 -2548958808550292121, i64 -8510628282985014432, i64 -6026599335303880135, i64 -2921563150702462265, i64 -8743505996830120772, i64 -6317696477610263061, i64 -3285434578585440922, i64 -8970925639256982432, i64 -6601971030643840136, i64 -3640777769877412266, i64 -9193015133814464522, i64 -6879582898840692749, i64 -3987792605123478032, i64 -373054737976959636, i64 -7150688238876681629, i64 -4326674280168464132, i64 -796656831783192261, i64 -7415439547505577019, i64 -4657613415954583370, i64 -1210330751515841308, i64 -7673985747338482674, i64 -4980796165745715438, i64 -1614309188754756393, i64 -7926472270612804602, i64 -5296404319838617848, i64 -2008819381370884406, i64 -8173041140997884610, i64 -5604615407819967859, i64 -2394083241347571919, i64 -8413831053483314306, i64 -5905602798426754978, i64 -2770317479606055818, i64 -8648977452394866743, i64 -6199535797066195524, i64 -3137733727905356501, i64 -8878612607581929669, i64 -6486579741050024183, i64 -3496538657885142324, i64 -9102865688819295809, i64 -6766896092596731857, i64 -3846934097318526917, i64 -196981603220770742, i64 -7040642529654063570, i64 -4189117143640191558, i64 -624710411122851544, i64 -7307973034592864071, i64 -4523280274813692185, i64 -1042414325089727327, i64 -7569037980822161435, i64 -4849611457600313890, i64 -1450328303573004458, i64 -7823984217374209643, i64 -5168294253290374149, i64 -1848681798185579782, i64 -8072955151507069220, i64 -5479507920956448621, i64 -2237698882768172872, i64 -8316090829371189901, i64 -5783427518286599473, i64 -2617598379430861437, i64 -8553528014785370254, i64 -6080224000054324913, i64 -2988593981640518238, i64 -8785400266166405755, i64 -6370064314280619289, i64 -3350894374423386208, i64 -9011838011655698236, i64 -6653111496142234891, i64 -3704703351750405709, i64 -19193171260619233, i64 -6929524759678968877, i64 -4050219931171323192, i64 -451088895536766085, i64 -7199459587351560659, i64 -4387638465762062920, i64 -872862063775190746, i64 -7463067817500576073, i64 -4717148753448332187, i64 -1284749923383027329, i64 -7720497729755473937, i64 -5038936143766954517, i64 -1686984161281305242, i64 -7971894128441897632, i64 -5353181642124984136, i64 -2079791034228842266, i64 -8217398424034108273, i64 -5660062011615247437, i64 -2463391496091671392, i64 -8457148712698376476, i64 -5959749872445582691, i64 -2838001322129590460, i64 -8691279853972075893, i64 -6252413799037706963, i64 -3203831230369745799, i64 -8919923546622172981, i64 -6538218414850328322, i64 -3561087000135522498, i64 -9143208402725783417, i64 -6817324484979841368, i64 -3909969587797413806, i64 -275775966319379353, i64 -7089889006590693952, i64 -4250675239810979535, i64 -701658031336336515, i64 -7356065297226292178, i64 -4583395603105477319, i64 -1117558485454458744, i64 -7616003081050118571, i64 -4908317832885260310, i64 -1523711272679187483, i64 -7869848573065574033, i64 -5225624697904579637, i64 -1920344853953336643, i64 -8117744561361917258, i64 -5535494683275008668, i64 -2307682335666372931, i64 -8359830487432564938, i64 -5838102090863318269, i64 -2685941595151759932, i64 -8596242524610931813, i64 -6133617137336276863, i64 -3055335403242958174, i64 -8827113654667930715, i64 -6422206049907525490, i64 -3416071543957018958, i64 -9052573742614218705, i64 -6704031159840385477, i64 -3768352931373093942, i64 -98755145788979524, i64 -6979250993759194058, i64 -4112377723771604669, i64 -528786136287117932, i64 -7248020362820530564, i64 -4448339435098275301, i64 -948738275445456222, i64 -7510490449794491995, i64 -4776427043815727089, i64 -1358847786342270957, i64 -7766808894105001205, i64 -5096825099203863602, i64 -1759345355577441598, i64 -8017119874876982855, i64 -5409713825168840664, i64 -2150456263033662926, i64 -8261564192037121185, i64 -5715269221619013577, i64 -2532400508596379068, i64 -8500279345513818773, i64 -6013663163464885563, i64 -2905392935903719049, i64 -8733399612580906262, i64 -6305063497298744923, i64 -3269643353196043250, i64 -8961056123388608887, i64 -6589634135808373205, i64 -3625356651333078602, i64 -9183376934724255983, i64 -6867535149977932074, i64 -3972732919045027189, i64 -354230130378896082, i64 -7138922859127891907, i64 -4311967555482476980, i64 -778273425925708321, i64 -7403949918844649557, i64 -4643251380128424042, i64 -1192378206733142148, i64 -7662765406849295699, i64 -4966770740134231719, i64 -1596777406740401745, i64 -7915514906853832947, i64 -5282707615139903279, i64 -1991698500497491195, i64 -8162340590452013853, i64 -5591239719637629412, i64 -2377363631119648861, i64 -8403381297090862394, i64 -5892540602936190089, i64 -2753989735242849707, i64 -8638772612167862923, i64 -6186779746782440750, i64 -3121788665050663033, i64 -8868646943297746252, i64 -6474122660694794911, i64 -3480967307441105734, i64 -9093133594791772940, i64 -6754730975062328271, i64 -3831727700400522434, i64 -177973607073265139, i64 -7028762532061872568, i64 -4174267146649952806, i64 -606147914885053103, i64 -7296371474444240046, i64 -4508778324627912153, i64 -1024286887357502287, i64 -7557708332239520786, i64 -4835449396872013078, i64 -1432625727662628443, i64 -7812920107430224633, i64 -5154464115860392887, i64 -1831394126398103205, i64 -8062150356639896359, i64 -5466001927372482545, i64 -2220816390788215277, i64 -8305539271883716405, i64 -5770238071427257602, i64 -2601111570856684098, i64 -8543223759426509417, i64 -6067343680855748868, i64 -2972493582642298180, i64 -8775337516792518219, i64 -6357485877563259869, i64 -3335171328526686933, i64 -9002011107970261189, i64 -6640827866535438582, i64 -3689348814741910324, i64 -9223372036854775808, i64 -6917529027641081856, i64 -4035225266123964416, i64 -432345564227567616, i64 -7187745005283311616, i64 -4372995238176751616, i64 -854558029293551616, i64 -7451627795949551616, i64 -4702848726509551616, i64 -1266874889709551616, i64 -7709325833709551616, i64 -5024971273709551616, i64 -1669528073709551616, i64 -7960984073709551616, i64 -5339544073709551616, i64 -2062744073709551616, i64 -8206744073709551616, i64 -5646744073709551616, i64 -2446744073709551616, i64 -8446744073709551616, i64 -5946744073709551616, i64 -2821744073709551616, i64 -8681119073709551616, i64 -6239712823709551616, i64 -3187955011209551616, i64 -8910000909647051616, i64 -6525815118631426616, i64 -3545582879861895366, i64 -9133518327554766460, i64 -6805211891016070171, i64 -3894828845342699810, i64 -256850038250986858, i64 -7078060301547948643, i64 -4235889358507547899, i64 -683175679707046970, i64 -7344513827457986212, i64 -4568956265895094861, i64 -1099509313941480672, i64 -7604722348854507276, i64 -4894216917640746191, i64 -1506085128623544835, i64 -7858832233030797378, i64 -5211854272861108819, i64 -1903131822648998119, i64 -8106986416796705681, i64 -5522047002568494197, i64 -2290872734783229842, i64 -8349324486880600507, i64 -5824969590173362730, i64 -2669525969289315508, i64 -8585982758446904049, i64 -6120792429631242157, i64 -3039304518611664792, i64 -8817094351773372351, i64 -6409681921289327535, i64 -3400416383184271515, i64 -9042789267131251553, i64 -6691800565486676537, i64 -3753064688430957767, i64 -79644842111309304, i64 -6967307053960650171, i64 -4097447799023424810, i64 -510123730351893109, i64 -7236356359111015049, i64 -4433759430461380907, i64 -930513269649338230, i64 -7499099821171918250, i64 -4762188758037509908, i64 -1341049929119499481, i64 -7755685233340769032, i64 -5082920523248573386, i64 -1741964635633328828, i64 -8006256924911912374, i64 -5396135137712502563, i64 -2133482903713240300, i64 -8250955842461857044, i64 -5702008784649933400, i64 -2515824962385028846, i64 -8489919629131724885, i64 -6000713517987268202, i64 -2889205879056697349, i64 -8723282702051517699, i64 -6292417359137009220, i64 -3253835680493873621, i64 -8951176327949752869, i64 -6577284391509803182, i64 -3609919470959866074, i64 -9173728696990998152, i64 -6855474852811359786, i64 -3957657547586811828, i64 -335385916056126881, i64 -7127145225176161157, i64 -4297245513042813542, i64 -759870872876129024, i64 -7392448323188662496, i64 -4628874385558440216, i64 -1174406963520662366, i64 -7651533379841495835, i64 -4952730706374481889, i64 -1579227364540714458, i64 -7904546130479028392, i64 -5268996644671397586, i64 -1974559787411859078, i64 -8151628894773493780, i64 -5577850100039479321, i64 -2360626606621961247, i64 -8392920656779807636, i64 -5879464802547371641, i64 -2737644984756826647, i64 -8628557143114098510, i64 -6174010410465235234, i64 -3105826994654156138, i64 -8858670899299929442, i64 -6461652605697523899, i64 -3465379738694516970, i64 -9083391364325154962, i64 -6742553186979055799, i64 -3816505465296431844, i64 -158945813193151901, i64 -7016870160886801794, i64 -4159401682681114339, i64 -587566084924005019, i64 -7284757830718584993, i64 -4494261269970843337, i64 -1006140569036166268, i64 -7546366883288685774, i64 -4821272585683469313, i64 -1414904713676948737, i64 -7801844473689174817, i64 -5140619573684080617, i64 -1814088448677712867, i64 -8051334308064652398, i64 -5452481866653427593, i64 -2203916314889396588, i64 -8294976724446954723, i64 -5757034887131305500, i64 -2584607590486743971, i64 -8532908771695296838, i64 -6054449946191733143, i64 -2956376414312278525, i64 -8765264286586255934, i64 -6344894339805432014, i64 -3319431906329402113, i64 -8992173969096958177, i64 -6628531442943809817, i64 -3673978285252374367, i64 -9213765455923815836, i64 -6905520801477381891, i64 -4020214983419339459, i64 -413582710846786420, i64 -7176018221920323369, i64 -4358336758973016307, i64 -836234930288882479, i64 -7440175859071633406, i64 -4688533805412153853, i64 -1248981238337804412, i64 -7698142301602209614, i64 -5010991858575374113, i64 -1652053804791829737, i64 -7950062655635975442, i64 -5325892301117581398, i64 -2045679357969588844, i64 -8196078626372074883, i64 -5633412264537705700, i64 -2430079312244744221, i64 -8436328597794046994, i64 -5933724728815170839, i64 -2805469892591575644, i64 -8670947710510816634, i64 -6226998619711132888, i64 -3172062256211528206, i64 -8900067937773286985, i64 -6513398903789220827, i64 -3530062611309138130, i64 -9123818159709293187, i64 -6793086681209228580, i64 -3879672333084147821, i64 -237904397927796872, i64 -7066219276345954901, i64 -4221088077005055722, i64 -664674077828931749, i64 -7332950326284164199, i64 -4554501889427817345, i64 -1081441343357383777, i64 -7593429867239446717, i64 -4880101315621920492, i64 -1488440626100012711, i64 -7847804418953589800, i64 -5198069505264599346, i64 -1885900863153361279, i64 -8096217067111932656, i64 -5508585315462527915, i64 -2274045625900771990, i64 -8338807543829064350, i64 -5811823411358942533, i64 -2653093245771290262, i64 -8575712306248138270, i64 -6107954364382784934, i64 -3023256937051093263, i64 -8807064613298015146, i64 -6397144748195131028, i64 -3384744916816525881, i64 -9032994600651410532, i64 -6679557232386875260, i64 -3737760522056206171, i64 -60514634142869810, i64 -6955350673980375487, i64 -4082502324048081455, i64 -491441886632713915, i64 -7224680206786528053, i64 -4419164240055772162, i64 -912269281642327298, i64 -7487697328667536418, i64 -4747935642407032618, i64 -1323233534581402868, i64 -7744549986754458649, i64 -5069001465015685407, i64 -1724565812842218855, i64 -7995382660667468640, i64 -5382542307406947896, i64 -2116491865831296966, i64 -8240336443785642460, i64 -5688734536304665171, i64 -2499232151953443560, i64 -8479549122611984081, i64 -5987750384837592197, i64 -2873001962619602342, i64 -8713155254278333320, i64 -6279758049420528746, i64 -3238011543348273028, i64 -8941286242233752499, i64 -6564921784364802720, i64 -3594466212028615495, i64 -9164070410158966541, i64 -6843401994271320272, i64 -3942566474411762436, i64 -316522074587315140, i64 -7115355324258153819, i64 -4282508136895304370, i64 -741449152691742558, i64 -7380934748073420955, i64 -4614482416664388289, i64 -1156417002403097458, i64 -7640289654143017767, i64 -4938676049251384305, i64 -1561659043136842477, i64 -7893565929601608404, i64 -5255271393574622601, i64 -1957403223540890347, i64 -8140906042354138323, i64 -5564446534515285000, i64 -2343872149716718346, i64 -8382449121214030822, i64 -5866375383090150624, i64 -2721283210435300376, i64 -8618331034163144591, i64 -6161227774276542835, i64 -3089848699418290639, i64 -8848684464777513506, i64 -6449169562544503978, i64 -3449775934753242068, i64 -9073638986861858149, i64 -6730362715149934782, i64 -3801267375510030573, i64 -139898200960150313, i64 -7004965403241175802, i64 -4144520735624081848, i64 -568964901102714406, i64 -7273132090830278360, i64 -4479729095110460046, i64 -987975350460687153, i64 -7535013621679011327, i64 -4807081008671376254, i64 -1397165242411832414, i64 -7790757304148477115, i64 -5126760611758208489, i64 -1796764746270372707, i64 -8040506994060064798, i64 -5438947724147693094, i64 -2186998636757228463, i64 -8284403175614349646, i64 -5743817951090549153, i64 -2568086420435798537, i64 -8522583040413455942, i64 -6041542782089432023, i64 -2940242459184402125, i64 -8755180564631333184, i64 -6332289687361778576, i64 -3303676090774835316, i64 -8982326584375353929, i64 -6616222212041804507, i64 -3658591746624867729, i64 -9204148869281624187, i64 -6893500068174642330, i64 -4005189066790915008, i64 -394800315061255856, i64 -7164279224554366766, i64 -4343663012265570553, i64 -817892746904575288, i64 -7428711994456441411, i64 -4674203974643163860, i64 -1231068949876566920, i64 -7686947121313936181, i64 -4996997883215032323, i64 -1634561335591402499, i64 -7939129862385708418, i64 -5312226309554747619, i64 -2028596868516046619, i64 -8185402070463610993], align 16
@_ZN4absl12_GLOBAL__N_124kPower10MantissaLowTableE = internal constant [651 x i64] [i64 1242899115359157055, i64 5388497965526861063, i64 6735622456908576329, i64 -803843965719055396, i64 8720969558280366185, i64 -7545532125859093884, i64 -208543120469091547, i64 -130339450293182217, i64 -4774610331293865675, i64 -5968262914117332094, i64 5493207715531443249, i64 -2356862392440471747, i64 -2946077990550589683, i64 -8758827771735200408, i64 7498209359040551106, i64 149389661945913074, i64 93368538716195671, i64 4728396691822632493, i64 5910495864778290617, i64 8305745933913819539, i64 1158810380537498616, i64 -3163173042755514634, i64 -8565652321871781196, i64 6175682344898606512, i64 -1503769105731517667, i64 -6491397400591784988, i64 5166248661484910190, i64 -7377247228426025974, i64 -4609873017105144563, i64 4036358391950366504, i64 -4177924046916817678, i64 -610719040218634194, i64 8841672636718129437, i64 6440404777470273892, i64 8050505971837842365, i64 -6497648813669818282, i64 -8122061017087272852, i64 3682481783923072647, i64 -6921820921902855404, i64 571095884476206553, i64 -3897816162832129712, i64 -4741978110983775022, i64 7907585416552444934, i64 661109733835780360, i64 2719036592861056677, i64 -5824576295778454962, i64 1942651667131707105, i64 5825843310384704845, i64 -1941067898873894752, i64 2185351144835019464, i64 2731688931043774330, i64 8624834609543440812, i64 -3054014793352862697, i64 5405853545163697437, i64 5684501474941004850, i64 2493940825248868159, i64 7729112049988473103, i64 -9004363024039368023, i64 2579604275232953683, i64 3224505344041192104, i64 8932844867666826921, i64 -2669001970698630061, i64 -3336252463373287576, i64 2526528228819083169, i64 -6065211750830921846, i64 1641857348316123500, i64 -5891368184943504669, i64 -7364210231179380836, i64 4629795266307937667, i64 5199465050656154994, i64 -2724040723534582065, i64 -8016736922845615486, i64 6518754469289960081, i64 8148443086612450102, i64 962181821410786819, i64 -1704479370831952190, i64 7092772823314835570, i64 -357406007711231345, i64 8999993282035256217, i64 2026619565689294464, i64 -6690097579743157728, i64 5472436080603216552, i64 8031958568804398249, i64 -3795109844276665901, i64 9091170749936331336, i64 3376138709496513133, i64 -391512631556746488, i64 8733981247408842698, i64 5458738279630526686, i64 -7011635205744005354, i64 5070514048102157020, i64 863228270850154185, i64 -3532650679864695173, i64 -9027499368258256870, i64 -3336344095947716592, i64 -8782116138362033643, i64 7469098900757009562, i64 -2249342214667950880, i64 6411694268519837208, i64 -5820440219632367202, i64 7891439908798240259, i64 -3970758169284363389, i64 -351761693178066332, i64 6697677969404790399, i64 -851274575098787810, i64 -1064093218873484762, i64 8558313775058847832, i64 6086206200396171886, i64 -6227300304786948855, i64 -3172439362556298164, i64 -4288617610811380305, i64 3862600023340550427, i64 -4395122007679087774, i64 8782263791269039901, i64 -7468914334623251740, i64 4498915137003099037, i64 -6411550076227838910, i64 5820620459997365075, i64 -6559282480285457368, i64 -8711237568605798759, i64 2946011094524915263, i64 3682513868156144079, i64 4607414176811284001, i64 1147581702586717097, i64 -3177208890193991532, i64 7237616480483531100, i64 -4788037454677749837, i64 -1373360799919799392, i64 -858350499949874620, i64 3538747893490044629, i64 9035120885289943691, i64 -5882264492762254953, i64 -2741144597525430788, i64 -3426430746906788485, i64 4776009810824339053, i64 5970012263530423816, i64 7462515329413029771, i64 52386062455755702, i64 -9157889458785081180, i64 6999382250228200141, i64 8749227812785250177, i64 -3755104653863994448, i64 -4693880817329993060, i64 -1255665003235103420, i64 8438581409832836170, i64 -3286831292991118499, i64 -8720225134666286028, i64 -3144297699952734816, i64 -8542058143368306423, i64 3157485376071780683, i64 8890957387685944783, i64 1890324697752655170, i64 2362905872190818963, i64 6088502188546649756, i64 -1612744301171463613, i64 7207441660390446292, i64 -2412877989897052924, i64 -7627783505798704059, i64 4300328673033783639, i64 -1923980597781273130, i64 6818396289628184396, i64 8522995362035230495, i64 3021029092058325107, i64 -835399653354481520, i64 8179122470161673908, i64 -4111420493003729616, i64 -5139275616254662020, i64 -6424094520318327524, i64 -8030118150397909405, i64 -7324666853212387330, i64 4679224488766679549, i64 -3374341425896426372, i64 -9026492418826348338, i64 -2059743486678159615, i64 -2574679358347699519, i64 3002511419460075705, i64 8364825292752482535, i64 1232659579085827361, i64 -3841273781498745804, i64 4421779809981343554, i64 915538744049291538, i64 5183897733458195115, i64 6479872166822743894, i64 3488154190101041964, i64 2180096368813151227, i64 -1886565557410948870, i64 -2358206946763686087, i64 7749492695127472003, i64 463493832054564196, i64 -4032318728359182659, i64 -4826042214438183114, i64 3190819268807046916, i64 -623161932418579259, i64 -7307005235402693893, i64 -4522070525825979462, i64 3570783879572301480, i64 -148206168962011054, i64 -92628855601256909, i64 -115786069501571136, i64 4466953431550423984, i64 486002885505321038, i64 5219189625309039202, i64 6523987031636299002, i64 -534194123654701028, i64 -667742654568376285, i64 8388693718644305452, i64 -6286281471915778852, i64 -7857851839894723565, i64 8624429273841147159, i64 778582277723329070, i64 973227847154161338, i64 1216534808942701673, i64 -3851351762838199359, i64 -4814189703547749198, i64 -6017737129434686498, i64 7768129340171790699, i64 -8736582398494813242, i64 -1697355961263740745, i64 1244995533423855986, i64 -3055441601647567921, i64 5404070034795315907, i64 -3539985255894009414, i64 -4424981569867511768, i64 8303831092947774002, i64 578208414664970847, i64 -3888925500096174345, i64 -249470856692830027, i64 -4923524589293425438, i64 -3077202868308390899, i64 765182433041899281, i64 5568164059729762005, i64 5785945546544795205, i64 -1990940103673781802, i64 6734696907262548556, i64 4209185567039092847, i64 -8573576096483297653, i64 3118087934678041646, i64 4254647968387469981, i64 706623942056949572, i64 -3728406090856200939, i64 -6941939825212513491, i64 5157633273766521849, i64 6447041592208152311, i64 6335244004343789146, i64 -1304317031425039375, i64 -1630396289281299219, i64 1286845328412881940, i64 -3003129357911285479, i64 5469460339465668959, i64 8030098730593431003, i64 -3797434642040374958, i64 9088264752731695015, i64 -8154892584824854328, i64 8253128342678483706, i64 5704724409920716729, i64 -2092466524453879896, i64 998051431430019017, i64 -7975807747567252037, i64 8476984389250486570, i64 -3925256793573221702, i64 -294884973539139224, i64 -368606216923924029, i64 -2536221894791146470, i64 6053094668365842720, i64 2954682317029915496, i64 -459166561069996767, i64 -573958201337495959, i64 -5329133770099257852, i64 -5636551615525730110, i64 2177682517447613171, i64 2722103146809516464, i64 6313000485183335694, i64 3279564588051781713, i64 -512230283362660763, i64 1985699082112030975, i64 -2129562165787349185, i64 6561419329620589327, i64 -7428327965055601431, i64 4549648098962661924, i64 -8147997931578836307, i64 1825030320404309164, i64 6892973918932774359, i64 4004531380238580045, i64 -2108853905778275376, i64 6587304654631931588, i64 -989241218564861323, i64 -1236551523206076654, i64 6144684325637283947, i64 -6154202648235558778, i64 -3081067291867060568, i64 -1925667057416912855, i64 -2407083821771141069, i64 -7620540795641314240, i64 -2456994988062127448, i64 6152128301777116498, i64 -6144897678060768090, i64 -3840561048787980056, i64 4422670725869800738, i64 -8306719647944912790, i64 8643358275316593218, i64 6192511825718353619, i64 7740639782147942024, i64 2532056854628769813, i64 -6058300968568813542, i64 -7572876210711016927, i64 9102010423587778132, i64 -2457545025797441047, i64 -7683617300674189212, i64 -4802260812921368258, i64 -1391139997724322418, i64 7484447039699372786, i64 -9157278655470055721, i64 -6834912300910181747, i64 679731660717048624, i64 -8373707460958465028, i64 8601490892183123069, i64 -7694880458480647779, i64 4216457482181353988, i64 -4282243101277735614, i64 8482254178684994195, i64 5991131704928854840, i64 -3173071712060547581, i64 -8578025658503072380, i64 3112525982153323237, i64 4251171748059520975, i64 702278666647013314, i64 5489534351736154547, i64 1125115960621402640, i64 6018080969204141204, i64 2910915193077788601, i64 -486521013540076077, i64 -608151266925095096, i64 -5371875102083756773, i64 3560107088838733872, i64 -161552157378970563, i64 4409745821703674700, i64 -6467280898289979121, i64 1139270913992301907, i64 -3187597375937010520, i64 7231123676894144233, i64 4427218577690292387, i64 -3689348814741910324, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 4611686018427387904, i64 5764607523034234880, i64 -6629298651489370112, i64 5548434740920451072, i64 -1143914305352105984, i64 7793479155164643328, i64 -4093209111326359552, i64 4359273333062107136, i64 5449091666327633920, i64 2199678564482154496, i64 1374799102801346560, i64 1718498878501683200, i64 6759809616554491904, i64 6530724019560251392, i64 -1059967012404461568, i64 7898413271349198848, i64 -1981020733047832576, i64 -2476275916309790720, i64 -3095344895387238400, i64 4982938468024057856, i64 -7606384970252091392, i64 4327076842467049472, i64 -6518949010312869888, i64 -8148686262891087360, i64 8260886245095692416, i64 5163053903184807760, i64 -7381240676301154012, i64 -3178808521666707, i64 -4613672773753429596, i64 -5767090967191786995, i64 -7208863708989733744, i64 212292400617608628, i64 132682750386005392, i64 4777539456409894645, i64 -3251447716342407502, i64 7191217214140771119, i64 4377335499248575995, i64 -8363388681221443718, i64 -7532960934977096276, i64 4418856886560793367, i64 5523571108200991709, i64 -8076983103442849942, i64 -5484542860876174524, i64 6979379479186945558, i64 -4861259862362934835, i64 7758483227328495169, i64 -4136954021121544751, i64 -279753253987271518, i64 4261994450943298507, i64 5327493063679123134, i64 7941369183226839863, i64 5315025460606161924, i64 -2579590211097073402, i64 7611128154919104931, i64 -4321147861633282548, i64 -789748808614215280, i64 8729779031470891258, i64 6300537770911226168, i64 -1347699823215743098, i64 6075216638131242420, i64 7594020797664053025, i64 269153960225290473, i64 336442450281613091, i64 7127805559067090038, i64 4298070930406474644, i64 -3850783373846682503, i64 9122475437414293195, i64 -7043649776941685122, i64 -4192876202749718498, i64 -4926390635932268014, i64 3065383741939440791, i64 -779956341003086915, i64 6430056314514152534, i64 8037570393142690668, i64 823590954573587527, i64 5126430365035880108, i64 6408037956294850135, i64 3398361426941174765, i64 -4793553135802847628, i64 -1380255401326171631, i64 -1725319251657714539, i64 3533361486141316317, i64 -4806670179178130411, i64 7826720331309500698, i64 280014188641050032, i64 -8873354301053463268, i64 -1868320839462053277, i64 5749828502977298558, i64 -2036086408133152611, i64 6678264026688335045, i64 8347830033360418806, i64 2911550761636567802, i64 -5583933584809066056, i64 2243455055843443238, i64 3708002419115845976, i64 23317005467419566, i64 -4582539761593113446, i64 -558244341782001952, i64 -5309491445654890344, i64 -6636864307068612930, i64 -4148040191917883081, i64 -5185050239897353852, i64 -6481312799871692315, i64 -8662506518347195601, i64 3006924907348169211, i64 -853029884242176390, i64 1772699331562333708, i64 6827560182880305039, i64 8534450228600381299, i64 7639874402088932264, i64 326470965756389522, i64 5019774725622874806, i64 831516194300602802, i64 -8183976793979022306, i64 3605087062808385830, i64 9170708441896323000, i64 6851699533943015846, i64 3952938399001381903, i64 -4446942528265218167, i64 -946992141904134804, i64 8039631859474607303, i64 -3785518230938904583, i64 -60105885123121413, i64 -75132356403901766, i64 9129456591349898601, i64 -1211618658047395231, i64 -6126209340986631942, i64 -7657761676233289928, i64 -2480258038432112253, i64 -7712008566467528220, i64 8806733365625141341, i64 -6025006692552756422, i64 6303799689591218185, i64 -1343622424865753077, i64 1466078993672598279, i64 6444284760518135752, i64 8055355950647669691, i64 2728754459941099604, i64 -5812428961928401302, i64 1957835834444274180, i64 -7999724640327104446, i64 3835402254873283155, i64 4794252818591603944, i64 7608094030047140369, i64 4898431519131537557, i64 -7712018656367741765, i64 2097517367411243253, i64 7233582727691441970, i64 9041978409614302462, i64 6690786993590490174, i64 4181741870994056359, i64 615491320315182544, i64 -8454007886460797627, i64 3939617107816777291, i64 -8910536670511192099, i64 7308573235570561493, i64 -6961356773836868827, i64 -8701695967296086034, i64 -6265433940692719638, i64 695789805494438130, i64 869737256868047663, i64 -8136200465769716230, i64 -473439272678684740, i64 4019886927579031980, i64 -8810199395808373737, i64 -7812217631593927538, i64 4069786015789754290, i64 475546501309804958, i64 4908902581746016003, i64 -3087243809672255805, i64 -8470740780517707660, i64 -682526969396179383, i64 -5464844730172612133, i64 -2219369894288377262, i64 -1387106183930235789, i64 2877803288514593168, i64 3597254110643241460, i64 9108253656731439729, i64 1080972517029761926, i64 5962901664714590312, i64 -6381430974388925822, i64 -8600080377420466543, i64 7696643601933968437, i64 397432465562684739, i64 -4363290727450709942, i64 8380944645968776284, i64 1252808770606194547, i64 -8440366555225904216, i64 7896285879677171346, i64 -3964700705685699529, i64 2133748077373825698, i64 2667185096717282123, i64 3333981370896602653, i64 6695424375237764562, i64 8369280469047205703, i64 -3373457468973156583, i64 -9025939945749304721, i64 7164319141522920715, i64 4343712908476262990, i64 7326506586225052273, i64 9158133232781315341, i64 2224294504121868368, i64 -7833187971778608078, i64 -568112927868484289, i64 3901544858591782542, i64 -4479063491021217767, i64 -5598829363776522209, i64 -2386850686293264857, i64 1628122660560806833, i64 -8205795374004271538, i64 -1033872180650563614, i64 -5904026244240592421, i64 -5995859411864064215, i64 1728547772024695539, i64 -2451001303396518480, i64 5385653213018257806, i64 -7102991539009341455, i64 -8878739423761676819, i64 3674159897003727796, i64 4592699871254659745, i64 1129188820640936778, i64 3011586022114279438, i64 8376168546070237202, i64 -7976533391121755114, i64 1932195658189984910, i64 -6808127464117294671, i64 -3898473311719230434, i64 9092669226243950738, i64 -2469221522477225289, i64 6136845133758244197, i64 -3082000819042179233, i64 -8464187042230111945, i64 3254824252494523781, i64 -7189106879045698445, i64 -8986383598807123057, i64 2602078556773259891, i64 -1359087822460813040, i64 -849429889038008150, i64 -5673473379724898091, i64 -2480155706228734710, i64 -3855940325606653146, i64 -208239388580928528, i64 -4871985254153548564, i64 -3044990783845967853, i64 5417133557047315992, i64 -2451955090545630818, i64 -3838314940804713213, i64 4425478360848884291, i64 920161932633717460, i64 2880944217109767365, i64 -5622191765467566602, i64 6807318348447705459, i64 -2662955059861265944, i64 -7940379843253970334, i64 8521269269642088699, i64 -6203421752542164323, i64 6080780864604458308, i64 -6234081974526590827, i64 5327070802775656541, i64 6658838503469570676, i64 8323548129336963345, i64 -4021154456019173717, i64 -5026443070023967147, i64 2940318199324816875, i64 8755227902219092403, i64 -2891023177508298209, i64 -8225464990312760665, i64 -5670145219463562927, i64 7985374283903742931, i64 758345818024902856, i64 -3663753745896259334, i64 -9207375118826243940, i64 -2285846861678029117, i64 1754377441329851508, i64 1096485900831157192, i64 -3241078642388441414, i64 5172023733869224041, i64 5538357842881958977, i64 -2300424733252327086, i64 6347841120289366950, i64 6273243709394548296], align 16
@_ZZN4absl12_GLOBAL__N_111EiselLemireIfEEbRKNS_16strings_internal11ParsedFloatEbPT_PSt4errcE11high64_mask = internal constant i64 274877906943, align 8
@_ZZN4absl12_GLOBAL__N_111EiselLemireIfEEbRKNS_16strings_internal11ParsedFloatEbPT_PSt4errcE8max_exp2 = internal constant i64 255, align 8
@llvm.global_ctors = appending global [1 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 65535, ptr @_GLOBAL__sub_I_charconv.cc, ptr null }]

; Function Attrs: uwtable
define internal void @__cxx_global_var_init() #0 section ".text.startup" {
entry:
  call void @_ZNSt8ios_base4InitC1Ev(ptr noundef nonnull align 1 dereferenceable(1) @_ZStL8__ioinit)
  %0 = call i32 @__cxa_atexit(ptr @_ZNSt8ios_base4InitD1Ev, ptr @_ZStL8__ioinit, ptr @__dso_handle) #3
  ret void
}

declare void @_ZNSt8ios_base4InitC1Ev(ptr noundef nonnull align 1 dereferenceable(1)) unnamed_addr #1

; Function Attrs: nounwind
declare void @_ZNSt8ios_base4InitD1Ev(ptr noundef nonnull align 1 dereferenceable(1)) unnamed_addr #2

; Function Attrs: nounwind
declare i32 @__cxa_atexit(ptr, ptr, ptr) #3

; Function Attrs: mustprogress uwtable
define dso_local { ptr, i32 } @_ZN4absl10from_charsEPKcS1_RdNS_12chars_formatE(ptr noundef %first, ptr noundef %last, ptr noundef nonnull align 8 dereferenceable(8) %value, i32 noundef %fmt) #4 {
entry:
  %retval = alloca %"struct.absl::from_chars_result", align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %value.addr = alloca ptr, align 8
  %fmt.addr = alloca i32, align 4
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  store i32 %fmt, ptr %fmt.addr, align 4
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %2 = load ptr, ptr %value.addr, align 8
  %3 = load i32, ptr %fmt.addr, align 4
  %call = call { ptr, i32 } @_ZN4absl12_GLOBAL__N_113FromCharsImplIdEENS_17from_chars_resultEPKcS4_RT_NS_12chars_formatE(ptr noundef %0, ptr noundef %1, ptr noundef nonnull align 8 dereferenceable(8) %2, i32 noundef %3)
  %4 = getelementptr inbounds { ptr, i32 }, ptr %retval, i32 0, i32 0
  %5 = extractvalue { ptr, i32 } %call, 0
  store ptr %5, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i32 }, ptr %retval, i32 0, i32 1
  %7 = extractvalue { ptr, i32 } %call, 1
  store i32 %7, ptr %6, align 8
  %8 = load { ptr, i32 }, ptr %retval, align 8
  ret { ptr, i32 } %8
}

; Function Attrs: mustprogress uwtable
define internal { ptr, i32 } @_ZN4absl12_GLOBAL__N_113FromCharsImplIdEENS_17from_chars_resultEPKcS4_RT_NS_12chars_formatE(ptr noundef %first, ptr noundef %last, ptr noundef nonnull align 8 dereferenceable(8) %value, i32 noundef %fmt_flags) #4 {
entry:
  %retval = alloca %"struct.absl::from_chars_result", align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %value.addr = alloca ptr, align 8
  %fmt_flags.addr = alloca i32, align 4
  %negative = alloca i8, align 1
  %hex_first = alloca ptr, align 8
  %hex_parse = alloca %"struct.absl::strings_internal::ParsedFloat", align 8
  %calculated = alloca %"struct.absl::(anonymous namespace)::CalculatedFloat", align 8
  %hex_parse38 = alloca %"struct.absl::strings_internal::ParsedFloat", align 8
  %calculated50 = alloca %"struct.absl::(anonymous namespace)::CalculatedFloat", align 8
  %decimal_parse = alloca %"struct.absl::strings_internal::ParsedFloat", align 8
  %calculated72 = alloca %"struct.absl::(anonymous namespace)::CalculatedFloat", align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  store i32 %fmt_flags, ptr %fmt_flags.addr, align 4
  %0 = load ptr, ptr %first.addr, align 8
  %ptr = getelementptr inbounds %"struct.absl::from_chars_result", ptr %retval, i32 0, i32 0
  store ptr %0, ptr %ptr, align 8
  %ec = getelementptr inbounds %"struct.absl::from_chars_result", ptr %retval, i32 0, i32 1
  store i32 0, ptr %ec, align 8
  store i8 0, ptr %negative, align 1
  %1 = load ptr, ptr %first.addr, align 8
  %2 = load ptr, ptr %last.addr, align 8
  %cmp = icmp ne ptr %1, %2
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %3 = load ptr, ptr %first.addr, align 8
  %4 = load i8, ptr %3, align 1
  %conv = sext i8 %4 to i32
  %cmp1 = icmp eq i32 %conv, 45
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %5 = load ptr, ptr %first.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %5, i32 1
  store ptr %incdec.ptr, ptr %first.addr, align 8
  store i8 1, ptr %negative, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %6 = load i32, ptr %fmt_flags.addr, align 4
  %call = call noundef i32 @_ZN4abslanENS_12chars_formatES0_(i32 noundef %6, i32 noundef 4)
  %cmp2 = icmp eq i32 %call, 0
  br i1 %cmp2, label %land.lhs.true3, label %if.end34

land.lhs.true3:                                   ; preds = %if.end
  %7 = load ptr, ptr %last.addr, align 8
  %8 = load ptr, ptr %first.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %7 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %8 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp4 = icmp sge i64 %sub.ptr.sub, 2
  br i1 %cmp4, label %land.lhs.true5, label %if.end34

land.lhs.true5:                                   ; preds = %land.lhs.true3
  %9 = load ptr, ptr %first.addr, align 8
  %10 = load i8, ptr %9, align 1
  %conv6 = sext i8 %10 to i32
  %cmp7 = icmp eq i32 %conv6, 48
  br i1 %cmp7, label %land.lhs.true8, label %if.end34

land.lhs.true8:                                   ; preds = %land.lhs.true5
  %11 = load ptr, ptr %first.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %11, i64 1
  %12 = load i8, ptr %arrayidx, align 1
  %conv9 = sext i8 %12 to i32
  %cmp10 = icmp eq i32 %conv9, 120
  br i1 %cmp10, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true8
  %13 = load ptr, ptr %first.addr, align 8
  %arrayidx11 = getelementptr inbounds i8, ptr %13, i64 1
  %14 = load i8, ptr %arrayidx11, align 1
  %conv12 = sext i8 %14 to i32
  %cmp13 = icmp eq i32 %conv12, 88
  br i1 %cmp13, label %if.then14, label %if.end34

if.then14:                                        ; preds = %lor.lhs.false, %land.lhs.true8
  %15 = load ptr, ptr %first.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %15, i64 2
  store ptr %add.ptr, ptr %hex_first, align 8
  %16 = load ptr, ptr %hex_first, align 8
  %17 = load ptr, ptr %last.addr, align 8
  %18 = load i32, ptr %fmt_flags.addr, align 4
  call void @_ZN4absl16strings_internal10ParseFloatILi16EEENS0_11ParsedFloatEPKcS4_NS_12chars_formatE(ptr sret(%"struct.absl::strings_internal::ParsedFloat") align 8 %hex_parse, ptr noundef %16, ptr noundef %17, i32 noundef %18)
  %end = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %hex_parse, i32 0, i32 6
  %19 = load ptr, ptr %end, align 8
  %cmp15 = icmp eq ptr %19, null
  br i1 %cmp15, label %if.then18, label %lor.lhs.false16

lor.lhs.false16:                                  ; preds = %if.then14
  %type = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %hex_parse, i32 0, i32 3
  %20 = load i32, ptr %type, align 8
  %cmp17 = icmp ne i32 %20, 0
  br i1 %cmp17, label %if.then18, label %if.end25

if.then18:                                        ; preds = %lor.lhs.false16, %if.then14
  %21 = load i32, ptr %fmt_flags.addr, align 4
  %cmp19 = icmp eq i32 %21, 1
  br i1 %cmp19, label %if.then20, label %if.else

if.then20:                                        ; preds = %if.then18
  %ec21 = getelementptr inbounds %"struct.absl::from_chars_result", ptr %retval, i32 0, i32 1
  store i32 22, ptr %ec21, align 8
  br label %if.end24

if.else:                                          ; preds = %if.then18
  %22 = load ptr, ptr %first.addr, align 8
  %add.ptr22 = getelementptr inbounds i8, ptr %22, i64 1
  %ptr23 = getelementptr inbounds %"struct.absl::from_chars_result", ptr %retval, i32 0, i32 0
  store ptr %add.ptr22, ptr %ptr23, align 8
  %23 = load i8, ptr %negative, align 1
  %tobool = trunc i8 %23 to i1
  %cond = select i1 %tobool, double -0.000000e+00, double 0.000000e+00
  %24 = load ptr, ptr %value.addr, align 8
  store double %cond, ptr %24, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.else, %if.then20
  br label %return

if.end25:                                         ; preds = %lor.lhs.false16
  %end26 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %hex_parse, i32 0, i32 6
  %25 = load ptr, ptr %end26, align 8
  %ptr27 = getelementptr inbounds %"struct.absl::from_chars_result", ptr %retval, i32 0, i32 0
  store ptr %25, ptr %ptr27, align 8
  %26 = load i8, ptr %negative, align 1
  %tobool28 = trunc i8 %26 to i1
  %27 = load ptr, ptr %value.addr, align 8
  %call29 = call noundef zeroext i1 @_ZN4absl12_GLOBAL__N_114HandleEdgeCaseIdEEbRKNS_16strings_internal11ParsedFloatEbPT_(ptr noundef nonnull align 8 dereferenceable(48) %hex_parse, i1 noundef zeroext %tobool28, ptr noundef %27)
  br i1 %call29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.end25
  br label %return

if.end31:                                         ; preds = %if.end25
  %call32 = call { i64, i32 } @_ZN4absl12_GLOBAL__N_130CalculateFromParsedHexadecimalIdEENS0_15CalculatedFloatERKNS_16strings_internal11ParsedFloatE(ptr noundef nonnull align 8 dereferenceable(48) %hex_parse)
  %28 = getelementptr inbounds { i64, i32 }, ptr %calculated, i32 0, i32 0
  %29 = extractvalue { i64, i32 } %call32, 0
  store i64 %29, ptr %28, align 8
  %30 = getelementptr inbounds { i64, i32 }, ptr %calculated, i32 0, i32 1
  %31 = extractvalue { i64, i32 } %call32, 1
  store i32 %31, ptr %30, align 8
  %32 = load i8, ptr %negative, align 1
  %tobool33 = trunc i8 %32 to i1
  %33 = load ptr, ptr %value.addr, align 8
  call void @_ZN4absl12_GLOBAL__N_112EncodeResultIdEEvRKNS0_15CalculatedFloatEbPNS_17from_chars_resultEPT_(ptr noundef nonnull align 8 dereferenceable(12) %calculated, i1 noundef zeroext %tobool33, ptr noundef %retval, ptr noundef %33)
  br label %return

if.end34:                                         ; preds = %lor.lhs.false, %land.lhs.true5, %land.lhs.true3, %if.end
  %34 = load i32, ptr %fmt_flags.addr, align 4
  %call35 = call noundef i32 @_ZN4abslanENS_12chars_formatES0_(i32 noundef %34, i32 noundef 4)
  %cmp36 = icmp eq i32 %call35, 4
  br i1 %cmp36, label %if.then37, label %if.else53

if.then37:                                        ; preds = %if.end34
  %35 = load ptr, ptr %first.addr, align 8
  %36 = load ptr, ptr %last.addr, align 8
  %37 = load i32, ptr %fmt_flags.addr, align 4
  call void @_ZN4absl16strings_internal10ParseFloatILi16EEENS0_11ParsedFloatEPKcS4_NS_12chars_formatE(ptr sret(%"struct.absl::strings_internal::ParsedFloat") align 8 %hex_parse38, ptr noundef %35, ptr noundef %36, i32 noundef %37)
  %end39 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %hex_parse38, i32 0, i32 6
  %38 = load ptr, ptr %end39, align 8
  %cmp40 = icmp eq ptr %38, null
  br i1 %cmp40, label %if.then41, label %if.end43

if.then41:                                        ; preds = %if.then37
  %ec42 = getelementptr inbounds %"struct.absl::from_chars_result", ptr %retval, i32 0, i32 1
  store i32 22, ptr %ec42, align 8
  br label %return

if.end43:                                         ; preds = %if.then37
  %end44 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %hex_parse38, i32 0, i32 6
  %39 = load ptr, ptr %end44, align 8
  %ptr45 = getelementptr inbounds %"struct.absl::from_chars_result", ptr %retval, i32 0, i32 0
  store ptr %39, ptr %ptr45, align 8
  %40 = load i8, ptr %negative, align 1
  %tobool46 = trunc i8 %40 to i1
  %41 = load ptr, ptr %value.addr, align 8
  %call47 = call noundef zeroext i1 @_ZN4absl12_GLOBAL__N_114HandleEdgeCaseIdEEbRKNS_16strings_internal11ParsedFloatEbPT_(ptr noundef nonnull align 8 dereferenceable(48) %hex_parse38, i1 noundef zeroext %tobool46, ptr noundef %41)
  br i1 %call47, label %if.then48, label %if.end49

if.then48:                                        ; preds = %if.end43
  br label %return

if.end49:                                         ; preds = %if.end43
  %call51 = call { i64, i32 } @_ZN4absl12_GLOBAL__N_130CalculateFromParsedHexadecimalIdEENS0_15CalculatedFloatERKNS_16strings_internal11ParsedFloatE(ptr noundef nonnull align 8 dereferenceable(48) %hex_parse38)
  %42 = getelementptr inbounds { i64, i32 }, ptr %calculated50, i32 0, i32 0
  %43 = extractvalue { i64, i32 } %call51, 0
  store i64 %43, ptr %42, align 8
  %44 = getelementptr inbounds { i64, i32 }, ptr %calculated50, i32 0, i32 1
  %45 = extractvalue { i64, i32 } %call51, 1
  store i32 %45, ptr %44, align 8
  %46 = load i8, ptr %negative, align 1
  %tobool52 = trunc i8 %46 to i1
  %47 = load ptr, ptr %value.addr, align 8
  call void @_ZN4absl12_GLOBAL__N_112EncodeResultIdEEvRKNS0_15CalculatedFloatEbPNS_17from_chars_resultEPT_(ptr noundef nonnull align 8 dereferenceable(12) %calculated50, i1 noundef zeroext %tobool52, ptr noundef %retval, ptr noundef %47)
  br label %return

if.else53:                                        ; preds = %if.end34
  %48 = load ptr, ptr %first.addr, align 8
  %49 = load ptr, ptr %last.addr, align 8
  %50 = load i32, ptr %fmt_flags.addr, align 4
  call void @_ZN4absl16strings_internal10ParseFloatILi10EEENS0_11ParsedFloatEPKcS4_NS_12chars_formatE(ptr sret(%"struct.absl::strings_internal::ParsedFloat") align 8 %decimal_parse, ptr noundef %48, ptr noundef %49, i32 noundef %50)
  %end54 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %decimal_parse, i32 0, i32 6
  %51 = load ptr, ptr %end54, align 8
  %cmp55 = icmp eq ptr %51, null
  br i1 %cmp55, label %if.then56, label %if.end58

if.then56:                                        ; preds = %if.else53
  %ec57 = getelementptr inbounds %"struct.absl::from_chars_result", ptr %retval, i32 0, i32 1
  store i32 22, ptr %ec57, align 8
  br label %return

if.end58:                                         ; preds = %if.else53
  %end59 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %decimal_parse, i32 0, i32 6
  %52 = load ptr, ptr %end59, align 8
  %ptr60 = getelementptr inbounds %"struct.absl::from_chars_result", ptr %retval, i32 0, i32 0
  store ptr %52, ptr %ptr60, align 8
  %53 = load i8, ptr %negative, align 1
  %tobool61 = trunc i8 %53 to i1
  %54 = load ptr, ptr %value.addr, align 8
  %call62 = call noundef zeroext i1 @_ZN4absl12_GLOBAL__N_114HandleEdgeCaseIdEEbRKNS_16strings_internal11ParsedFloatEbPT_(ptr noundef nonnull align 8 dereferenceable(48) %decimal_parse, i1 noundef zeroext %tobool61, ptr noundef %54)
  br i1 %call62, label %if.then63, label %if.end64

if.then63:                                        ; preds = %if.end58
  br label %return

if.end64:                                         ; preds = %if.end58
  %subrange_begin = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %decimal_parse, i32 0, i32 4
  %55 = load ptr, ptr %subrange_begin, align 8
  %cmp65 = icmp eq ptr %55, null
  br i1 %cmp65, label %land.lhs.true66, label %if.end71

land.lhs.true66:                                  ; preds = %if.end64
  %56 = load i8, ptr %negative, align 1
  %tobool67 = trunc i8 %56 to i1
  %57 = load ptr, ptr %value.addr, align 8
  %ec68 = getelementptr inbounds %"struct.absl::from_chars_result", ptr %retval, i32 0, i32 1
  %call69 = call noundef zeroext i1 @_ZN4absl12_GLOBAL__N_111EiselLemireIdEEbRKNS_16strings_internal11ParsedFloatEbPT_PSt4errc(ptr noundef nonnull align 8 dereferenceable(48) %decimal_parse, i1 noundef zeroext %tobool67, ptr noundef %57, ptr noundef %ec68)
  br i1 %call69, label %if.then70, label %if.end71

if.then70:                                        ; preds = %land.lhs.true66
  br label %return

if.end71:                                         ; preds = %land.lhs.true66, %if.end64
  %call73 = call { i64, i32 } @_ZN4absl12_GLOBAL__N_126CalculateFromParsedDecimalIdEENS0_15CalculatedFloatERKNS_16strings_internal11ParsedFloatE(ptr noundef nonnull align 8 dereferenceable(48) %decimal_parse)
  %58 = getelementptr inbounds { i64, i32 }, ptr %calculated72, i32 0, i32 0
  %59 = extractvalue { i64, i32 } %call73, 0
  store i64 %59, ptr %58, align 8
  %60 = getelementptr inbounds { i64, i32 }, ptr %calculated72, i32 0, i32 1
  %61 = extractvalue { i64, i32 } %call73, 1
  store i32 %61, ptr %60, align 8
  %62 = load i8, ptr %negative, align 1
  %tobool74 = trunc i8 %62 to i1
  %63 = load ptr, ptr %value.addr, align 8
  call void @_ZN4absl12_GLOBAL__N_112EncodeResultIdEEvRKNS0_15CalculatedFloatEbPNS_17from_chars_resultEPT_(ptr noundef nonnull align 8 dereferenceable(12) %calculated72, i1 noundef zeroext %tobool74, ptr noundef %retval, ptr noundef %63)
  br label %return

return:                                           ; preds = %if.end71, %if.then70, %if.then63, %if.then56, %if.end49, %if.then48, %if.then41, %if.end31, %if.then30, %if.end24
  %64 = load { ptr, i32 }, ptr %retval, align 8
  ret { ptr, i32 } %64
}

; Function Attrs: mustprogress uwtable
define dso_local { ptr, i32 } @_ZN4absl10from_charsEPKcS1_RfNS_12chars_formatE(ptr noundef %first, ptr noundef %last, ptr noundef nonnull align 4 dereferenceable(4) %value, i32 noundef %fmt) #4 {
entry:
  %retval = alloca %"struct.absl::from_chars_result", align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %value.addr = alloca ptr, align 8
  %fmt.addr = alloca i32, align 4
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  store i32 %fmt, ptr %fmt.addr, align 4
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %2 = load ptr, ptr %value.addr, align 8
  %3 = load i32, ptr %fmt.addr, align 4
  %call = call { ptr, i32 } @_ZN4absl12_GLOBAL__N_113FromCharsImplIfEENS_17from_chars_resultEPKcS4_RT_NS_12chars_formatE(ptr noundef %0, ptr noundef %1, ptr noundef nonnull align 4 dereferenceable(4) %2, i32 noundef %3)
  %4 = getelementptr inbounds { ptr, i32 }, ptr %retval, i32 0, i32 0
  %5 = extractvalue { ptr, i32 } %call, 0
  store ptr %5, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i32 }, ptr %retval, i32 0, i32 1
  %7 = extractvalue { ptr, i32 } %call, 1
  store i32 %7, ptr %6, align 8
  %8 = load { ptr, i32 }, ptr %retval, align 8
  ret { ptr, i32 } %8
}

; Function Attrs: mustprogress uwtable
define internal { ptr, i32 } @_ZN4absl12_GLOBAL__N_113FromCharsImplIfEENS_17from_chars_resultEPKcS4_RT_NS_12chars_formatE(ptr noundef %first, ptr noundef %last, ptr noundef nonnull align 4 dereferenceable(4) %value, i32 noundef %fmt_flags) #4 {
entry:
  %retval = alloca %"struct.absl::from_chars_result", align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %value.addr = alloca ptr, align 8
  %fmt_flags.addr = alloca i32, align 4
  %negative = alloca i8, align 1
  %hex_first = alloca ptr, align 8
  %hex_parse = alloca %"struct.absl::strings_internal::ParsedFloat", align 8
  %calculated = alloca %"struct.absl::(anonymous namespace)::CalculatedFloat", align 8
  %hex_parse39 = alloca %"struct.absl::strings_internal::ParsedFloat", align 8
  %calculated51 = alloca %"struct.absl::(anonymous namespace)::CalculatedFloat", align 8
  %decimal_parse = alloca %"struct.absl::strings_internal::ParsedFloat", align 8
  %calculated73 = alloca %"struct.absl::(anonymous namespace)::CalculatedFloat", align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  store i32 %fmt_flags, ptr %fmt_flags.addr, align 4
  %0 = load ptr, ptr %first.addr, align 8
  %ptr = getelementptr inbounds %"struct.absl::from_chars_result", ptr %retval, i32 0, i32 0
  store ptr %0, ptr %ptr, align 8
  %ec = getelementptr inbounds %"struct.absl::from_chars_result", ptr %retval, i32 0, i32 1
  store i32 0, ptr %ec, align 8
  store i8 0, ptr %negative, align 1
  %1 = load ptr, ptr %first.addr, align 8
  %2 = load ptr, ptr %last.addr, align 8
  %cmp = icmp ne ptr %1, %2
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %3 = load ptr, ptr %first.addr, align 8
  %4 = load i8, ptr %3, align 1
  %conv = sext i8 %4 to i32
  %cmp1 = icmp eq i32 %conv, 45
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %5 = load ptr, ptr %first.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %5, i32 1
  store ptr %incdec.ptr, ptr %first.addr, align 8
  store i8 1, ptr %negative, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %6 = load i32, ptr %fmt_flags.addr, align 4
  %call = call noundef i32 @_ZN4abslanENS_12chars_formatES0_(i32 noundef %6, i32 noundef 4)
  %cmp2 = icmp eq i32 %call, 0
  br i1 %cmp2, label %land.lhs.true3, label %if.end35

land.lhs.true3:                                   ; preds = %if.end
  %7 = load ptr, ptr %last.addr, align 8
  %8 = load ptr, ptr %first.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %7 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %8 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp4 = icmp sge i64 %sub.ptr.sub, 2
  br i1 %cmp4, label %land.lhs.true5, label %if.end35

land.lhs.true5:                                   ; preds = %land.lhs.true3
  %9 = load ptr, ptr %first.addr, align 8
  %10 = load i8, ptr %9, align 1
  %conv6 = sext i8 %10 to i32
  %cmp7 = icmp eq i32 %conv6, 48
  br i1 %cmp7, label %land.lhs.true8, label %if.end35

land.lhs.true8:                                   ; preds = %land.lhs.true5
  %11 = load ptr, ptr %first.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %11, i64 1
  %12 = load i8, ptr %arrayidx, align 1
  %conv9 = sext i8 %12 to i32
  %cmp10 = icmp eq i32 %conv9, 120
  br i1 %cmp10, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true8
  %13 = load ptr, ptr %first.addr, align 8
  %arrayidx11 = getelementptr inbounds i8, ptr %13, i64 1
  %14 = load i8, ptr %arrayidx11, align 1
  %conv12 = sext i8 %14 to i32
  %cmp13 = icmp eq i32 %conv12, 88
  br i1 %cmp13, label %if.then14, label %if.end35

if.then14:                                        ; preds = %lor.lhs.false, %land.lhs.true8
  %15 = load ptr, ptr %first.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %15, i64 2
  store ptr %add.ptr, ptr %hex_first, align 8
  %16 = load ptr, ptr %hex_first, align 8
  %17 = load ptr, ptr %last.addr, align 8
  %18 = load i32, ptr %fmt_flags.addr, align 4
  call void @_ZN4absl16strings_internal10ParseFloatILi16EEENS0_11ParsedFloatEPKcS4_NS_12chars_formatE(ptr sret(%"struct.absl::strings_internal::ParsedFloat") align 8 %hex_parse, ptr noundef %16, ptr noundef %17, i32 noundef %18)
  %end = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %hex_parse, i32 0, i32 6
  %19 = load ptr, ptr %end, align 8
  %cmp15 = icmp eq ptr %19, null
  br i1 %cmp15, label %if.then18, label %lor.lhs.false16

lor.lhs.false16:                                  ; preds = %if.then14
  %type = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %hex_parse, i32 0, i32 3
  %20 = load i32, ptr %type, align 8
  %cmp17 = icmp ne i32 %20, 0
  br i1 %cmp17, label %if.then18, label %if.end26

if.then18:                                        ; preds = %lor.lhs.false16, %if.then14
  %21 = load i32, ptr %fmt_flags.addr, align 4
  %cmp19 = icmp eq i32 %21, 1
  br i1 %cmp19, label %if.then20, label %if.else

if.then20:                                        ; preds = %if.then18
  %ec21 = getelementptr inbounds %"struct.absl::from_chars_result", ptr %retval, i32 0, i32 1
  store i32 22, ptr %ec21, align 8
  br label %if.end25

if.else:                                          ; preds = %if.then18
  %22 = load ptr, ptr %first.addr, align 8
  %add.ptr22 = getelementptr inbounds i8, ptr %22, i64 1
  %ptr23 = getelementptr inbounds %"struct.absl::from_chars_result", ptr %retval, i32 0, i32 0
  store ptr %add.ptr22, ptr %ptr23, align 8
  %23 = load i8, ptr %negative, align 1
  %tobool = trunc i8 %23 to i1
  %cond = select i1 %tobool, double -0.000000e+00, double 0.000000e+00
  %conv24 = fptrunc double %cond to float
  %24 = load ptr, ptr %value.addr, align 8
  store float %conv24, ptr %24, align 4
  br label %if.end25

if.end25:                                         ; preds = %if.else, %if.then20
  br label %return

if.end26:                                         ; preds = %lor.lhs.false16
  %end27 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %hex_parse, i32 0, i32 6
  %25 = load ptr, ptr %end27, align 8
  %ptr28 = getelementptr inbounds %"struct.absl::from_chars_result", ptr %retval, i32 0, i32 0
  store ptr %25, ptr %ptr28, align 8
  %26 = load i8, ptr %negative, align 1
  %tobool29 = trunc i8 %26 to i1
  %27 = load ptr, ptr %value.addr, align 8
  %call30 = call noundef zeroext i1 @_ZN4absl12_GLOBAL__N_114HandleEdgeCaseIfEEbRKNS_16strings_internal11ParsedFloatEbPT_(ptr noundef nonnull align 8 dereferenceable(48) %hex_parse, i1 noundef zeroext %tobool29, ptr noundef %27)
  br i1 %call30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.end26
  br label %return

if.end32:                                         ; preds = %if.end26
  %call33 = call { i64, i32 } @_ZN4absl12_GLOBAL__N_130CalculateFromParsedHexadecimalIfEENS0_15CalculatedFloatERKNS_16strings_internal11ParsedFloatE(ptr noundef nonnull align 8 dereferenceable(48) %hex_parse)
  %28 = getelementptr inbounds { i64, i32 }, ptr %calculated, i32 0, i32 0
  %29 = extractvalue { i64, i32 } %call33, 0
  store i64 %29, ptr %28, align 8
  %30 = getelementptr inbounds { i64, i32 }, ptr %calculated, i32 0, i32 1
  %31 = extractvalue { i64, i32 } %call33, 1
  store i32 %31, ptr %30, align 8
  %32 = load i8, ptr %negative, align 1
  %tobool34 = trunc i8 %32 to i1
  %33 = load ptr, ptr %value.addr, align 8
  call void @_ZN4absl12_GLOBAL__N_112EncodeResultIfEEvRKNS0_15CalculatedFloatEbPNS_17from_chars_resultEPT_(ptr noundef nonnull align 8 dereferenceable(12) %calculated, i1 noundef zeroext %tobool34, ptr noundef %retval, ptr noundef %33)
  br label %return

if.end35:                                         ; preds = %lor.lhs.false, %land.lhs.true5, %land.lhs.true3, %if.end
  %34 = load i32, ptr %fmt_flags.addr, align 4
  %call36 = call noundef i32 @_ZN4abslanENS_12chars_formatES0_(i32 noundef %34, i32 noundef 4)
  %cmp37 = icmp eq i32 %call36, 4
  br i1 %cmp37, label %if.then38, label %if.else54

if.then38:                                        ; preds = %if.end35
  %35 = load ptr, ptr %first.addr, align 8
  %36 = load ptr, ptr %last.addr, align 8
  %37 = load i32, ptr %fmt_flags.addr, align 4
  call void @_ZN4absl16strings_internal10ParseFloatILi16EEENS0_11ParsedFloatEPKcS4_NS_12chars_formatE(ptr sret(%"struct.absl::strings_internal::ParsedFloat") align 8 %hex_parse39, ptr noundef %35, ptr noundef %36, i32 noundef %37)
  %end40 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %hex_parse39, i32 0, i32 6
  %38 = load ptr, ptr %end40, align 8
  %cmp41 = icmp eq ptr %38, null
  br i1 %cmp41, label %if.then42, label %if.end44

if.then42:                                        ; preds = %if.then38
  %ec43 = getelementptr inbounds %"struct.absl::from_chars_result", ptr %retval, i32 0, i32 1
  store i32 22, ptr %ec43, align 8
  br label %return

if.end44:                                         ; preds = %if.then38
  %end45 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %hex_parse39, i32 0, i32 6
  %39 = load ptr, ptr %end45, align 8
  %ptr46 = getelementptr inbounds %"struct.absl::from_chars_result", ptr %retval, i32 0, i32 0
  store ptr %39, ptr %ptr46, align 8
  %40 = load i8, ptr %negative, align 1
  %tobool47 = trunc i8 %40 to i1
  %41 = load ptr, ptr %value.addr, align 8
  %call48 = call noundef zeroext i1 @_ZN4absl12_GLOBAL__N_114HandleEdgeCaseIfEEbRKNS_16strings_internal11ParsedFloatEbPT_(ptr noundef nonnull align 8 dereferenceable(48) %hex_parse39, i1 noundef zeroext %tobool47, ptr noundef %41)
  br i1 %call48, label %if.then49, label %if.end50

if.then49:                                        ; preds = %if.end44
  br label %return

if.end50:                                         ; preds = %if.end44
  %call52 = call { i64, i32 } @_ZN4absl12_GLOBAL__N_130CalculateFromParsedHexadecimalIfEENS0_15CalculatedFloatERKNS_16strings_internal11ParsedFloatE(ptr noundef nonnull align 8 dereferenceable(48) %hex_parse39)
  %42 = getelementptr inbounds { i64, i32 }, ptr %calculated51, i32 0, i32 0
  %43 = extractvalue { i64, i32 } %call52, 0
  store i64 %43, ptr %42, align 8
  %44 = getelementptr inbounds { i64, i32 }, ptr %calculated51, i32 0, i32 1
  %45 = extractvalue { i64, i32 } %call52, 1
  store i32 %45, ptr %44, align 8
  %46 = load i8, ptr %negative, align 1
  %tobool53 = trunc i8 %46 to i1
  %47 = load ptr, ptr %value.addr, align 8
  call void @_ZN4absl12_GLOBAL__N_112EncodeResultIfEEvRKNS0_15CalculatedFloatEbPNS_17from_chars_resultEPT_(ptr noundef nonnull align 8 dereferenceable(12) %calculated51, i1 noundef zeroext %tobool53, ptr noundef %retval, ptr noundef %47)
  br label %return

if.else54:                                        ; preds = %if.end35
  %48 = load ptr, ptr %first.addr, align 8
  %49 = load ptr, ptr %last.addr, align 8
  %50 = load i32, ptr %fmt_flags.addr, align 4
  call void @_ZN4absl16strings_internal10ParseFloatILi10EEENS0_11ParsedFloatEPKcS4_NS_12chars_formatE(ptr sret(%"struct.absl::strings_internal::ParsedFloat") align 8 %decimal_parse, ptr noundef %48, ptr noundef %49, i32 noundef %50)
  %end55 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %decimal_parse, i32 0, i32 6
  %51 = load ptr, ptr %end55, align 8
  %cmp56 = icmp eq ptr %51, null
  br i1 %cmp56, label %if.then57, label %if.end59

if.then57:                                        ; preds = %if.else54
  %ec58 = getelementptr inbounds %"struct.absl::from_chars_result", ptr %retval, i32 0, i32 1
  store i32 22, ptr %ec58, align 8
  br label %return

if.end59:                                         ; preds = %if.else54
  %end60 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %decimal_parse, i32 0, i32 6
  %52 = load ptr, ptr %end60, align 8
  %ptr61 = getelementptr inbounds %"struct.absl::from_chars_result", ptr %retval, i32 0, i32 0
  store ptr %52, ptr %ptr61, align 8
  %53 = load i8, ptr %negative, align 1
  %tobool62 = trunc i8 %53 to i1
  %54 = load ptr, ptr %value.addr, align 8
  %call63 = call noundef zeroext i1 @_ZN4absl12_GLOBAL__N_114HandleEdgeCaseIfEEbRKNS_16strings_internal11ParsedFloatEbPT_(ptr noundef nonnull align 8 dereferenceable(48) %decimal_parse, i1 noundef zeroext %tobool62, ptr noundef %54)
  br i1 %call63, label %if.then64, label %if.end65

if.then64:                                        ; preds = %if.end59
  br label %return

if.end65:                                         ; preds = %if.end59
  %subrange_begin = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %decimal_parse, i32 0, i32 4
  %55 = load ptr, ptr %subrange_begin, align 8
  %cmp66 = icmp eq ptr %55, null
  br i1 %cmp66, label %land.lhs.true67, label %if.end72

land.lhs.true67:                                  ; preds = %if.end65
  %56 = load i8, ptr %negative, align 1
  %tobool68 = trunc i8 %56 to i1
  %57 = load ptr, ptr %value.addr, align 8
  %ec69 = getelementptr inbounds %"struct.absl::from_chars_result", ptr %retval, i32 0, i32 1
  %call70 = call noundef zeroext i1 @_ZN4absl12_GLOBAL__N_111EiselLemireIfEEbRKNS_16strings_internal11ParsedFloatEbPT_PSt4errc(ptr noundef nonnull align 8 dereferenceable(48) %decimal_parse, i1 noundef zeroext %tobool68, ptr noundef %57, ptr noundef %ec69)
  br i1 %call70, label %if.then71, label %if.end72

if.then71:                                        ; preds = %land.lhs.true67
  br label %return

if.end72:                                         ; preds = %land.lhs.true67, %if.end65
  %call74 = call { i64, i32 } @_ZN4absl12_GLOBAL__N_126CalculateFromParsedDecimalIfEENS0_15CalculatedFloatERKNS_16strings_internal11ParsedFloatE(ptr noundef nonnull align 8 dereferenceable(48) %decimal_parse)
  %58 = getelementptr inbounds { i64, i32 }, ptr %calculated73, i32 0, i32 0
  %59 = extractvalue { i64, i32 } %call74, 0
  store i64 %59, ptr %58, align 8
  %60 = getelementptr inbounds { i64, i32 }, ptr %calculated73, i32 0, i32 1
  %61 = extractvalue { i64, i32 } %call74, 1
  store i32 %61, ptr %60, align 8
  %62 = load i8, ptr %negative, align 1
  %tobool75 = trunc i8 %62 to i1
  %63 = load ptr, ptr %value.addr, align 8
  call void @_ZN4absl12_GLOBAL__N_112EncodeResultIfEEvRKNS0_15CalculatedFloatEbPNS_17from_chars_resultEPT_(ptr noundef nonnull align 8 dereferenceable(12) %calculated73, i1 noundef zeroext %tobool75, ptr noundef %retval, ptr noundef %63)
  br label %return

return:                                           ; preds = %if.end72, %if.then71, %if.then64, %if.then57, %if.end50, %if.then49, %if.then42, %if.end32, %if.then31, %if.end25
  %64 = load { ptr, i32 }, ptr %retval, align 8
  ret { ptr, i32 } %64
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZN4abslanENS_12chars_formatES0_(i32 noundef %lhs, i32 noundef %rhs) #5 comdat {
entry:
  %lhs.addr = alloca i32, align 4
  %rhs.addr = alloca i32, align 4
  store i32 %lhs, ptr %lhs.addr, align 4
  store i32 %rhs, ptr %rhs.addr, align 4
  %0 = load i32, ptr %lhs.addr, align 4
  %1 = load i32, ptr %rhs.addr, align 4
  %and = and i32 %0, %1
  ret i32 %and
}

declare void @_ZN4absl16strings_internal10ParseFloatILi16EEENS0_11ParsedFloatEPKcS4_NS_12chars_formatE(ptr sret(%"struct.absl::strings_internal::ParsedFloat") align 8, ptr noundef, ptr noundef, i32 noundef) #1

; Function Attrs: mustprogress uwtable
define internal noundef zeroext i1 @_ZN4absl12_GLOBAL__N_114HandleEdgeCaseIdEEbRKNS_16strings_internal11ParsedFloatEbPT_(ptr noundef nonnull align 8 dereferenceable(48) %input, i1 noundef zeroext %negative, ptr noundef %value) #4 {
entry:
  %retval = alloca i1, align 1
  %input.addr = alloca ptr, align 8
  %negative.addr = alloca i8, align 1
  %value.addr = alloca ptr, align 8
  %kNanBufferSize = alloca i64, align 8
  %n_char_sequence = alloca [128 x i8], align 16
  %nan_size = alloca i64, align 8
  %ref.tmp = alloca i64, align 8
  %nan_argument = alloca ptr, align 8
  store ptr %input, ptr %input.addr, align 8
  %frombool = zext i1 %negative to i8
  store i8 %frombool, ptr %negative.addr, align 1
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %input.addr, align 8
  %type = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %0, i32 0, i32 3
  %1 = load i32, ptr %type, align 8
  %cmp = icmp eq i32 %1, 2
  br i1 %cmp, label %if.then, label %if.end10

if.then:                                          ; preds = %entry
  store i64 128, ptr %kNanBufferSize, align 8
  %2 = load ptr, ptr %input.addr, align 8
  %subrange_begin = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %2, i32 0, i32 4
  %3 = load ptr, ptr %subrange_begin, align 8
  %cmp1 = icmp eq ptr %3, null
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %arrayidx = getelementptr inbounds [128 x i8], ptr %n_char_sequence, i64 0, i64 0
  store i8 0, ptr %arrayidx, align 16
  br label %if.end

if.else:                                          ; preds = %if.then
  %4 = load ptr, ptr %input.addr, align 8
  %subrange_end = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %4, i32 0, i32 5
  %5 = load ptr, ptr %subrange_end, align 8
  %6 = load ptr, ptr %input.addr, align 8
  %subrange_begin3 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %6, i32 0, i32 4
  %7 = load ptr, ptr %subrange_begin3, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %5 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %7 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %nan_size, align 8
  store i64 127, ptr %ref.tmp, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZSt3minIlERKT_S2_S2_(ptr noundef nonnull align 8 dereferenceable(8) %nan_size, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp)
  %8 = load i64, ptr %call, align 8
  store i64 %8, ptr %nan_size, align 8
  %9 = load ptr, ptr %input.addr, align 8
  %subrange_begin4 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %9, i32 0, i32 4
  %10 = load ptr, ptr %subrange_begin4, align 8
  %11 = load i64, ptr %nan_size, align 8
  %arraydecay = getelementptr inbounds [128 x i8], ptr %n_char_sequence, i64 0, i64 0
  %call5 = call noundef ptr @_ZSt6copy_nIPKclPcET1_T_T0_S3_(ptr noundef %10, i64 noundef %11, ptr noundef %arraydecay)
  %12 = load i64, ptr %nan_size, align 8
  %arrayidx6 = getelementptr inbounds [128 x i8], ptr %n_char_sequence, i64 0, i64 %12
  store i8 0, ptr %arrayidx6, align 1
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then2
  %arraydecay7 = getelementptr inbounds [128 x i8], ptr %n_char_sequence, i64 0, i64 0
  store ptr %arraydecay7, ptr %nan_argument, align 8
  %13 = load i8, ptr %negative.addr, align 1
  %tobool = trunc i8 %13 to i1
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %14 = load ptr, ptr %nan_argument, align 8
  %call8 = call noundef double @_ZN4absl12_GLOBAL__N_111FloatTraitsIdE7MakeNanEPKc(ptr noundef %14)
  %fneg = fneg double %call8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %15 = load ptr, ptr %nan_argument, align 8
  %call9 = call noundef double @_ZN4absl12_GLOBAL__N_111FloatTraitsIdE7MakeNanEPKc(ptr noundef %15)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %fneg, %cond.true ], [ %call9, %cond.false ]
  %16 = load ptr, ptr %value.addr, align 8
  store double %cond, ptr %16, align 8
  store i1 true, ptr %retval, align 1
  br label %return

if.end10:                                         ; preds = %entry
  %17 = load ptr, ptr %input.addr, align 8
  %type11 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %17, i32 0, i32 3
  %18 = load i32, ptr %type11, align 8
  %cmp12 = icmp eq i32 %18, 1
  br i1 %cmp12, label %if.then13, label %if.end19

if.then13:                                        ; preds = %if.end10
  %19 = load i8, ptr %negative.addr, align 1
  %tobool14 = trunc i8 %19 to i1
  %call15 = call noundef double @_ZNSt14numeric_limitsIdE8infinityEv() #3
  %fneg16 = fneg double %call15
  %call17 = call noundef double @_ZNSt14numeric_limitsIdE8infinityEv() #3
  %cond18 = select i1 %tobool14, double %fneg16, double %call17
  %20 = load ptr, ptr %value.addr, align 8
  store double %cond18, ptr %20, align 8
  store i1 true, ptr %retval, align 1
  br label %return

if.end19:                                         ; preds = %if.end10
  %21 = load ptr, ptr %input.addr, align 8
  %mantissa = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %21, i32 0, i32 0
  %22 = load i64, ptr %mantissa, align 8
  %cmp20 = icmp eq i64 %22, 0
  br i1 %cmp20, label %if.then21, label %if.end24

if.then21:                                        ; preds = %if.end19
  %23 = load i8, ptr %negative.addr, align 1
  %tobool22 = trunc i8 %23 to i1
  %cond23 = select i1 %tobool22, double -0.000000e+00, double 0.000000e+00
  %24 = load ptr, ptr %value.addr, align 8
  store double %cond23, ptr %24, align 8
  store i1 true, ptr %retval, align 1
  br label %return

if.end24:                                         ; preds = %if.end19
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end24, %if.then21, %if.then13, %cond.end
  %25 = load i1, ptr %retval, align 1
  ret i1 %25
}

; Function Attrs: mustprogress uwtable
define internal { i64, i32 } @_ZN4absl12_GLOBAL__N_130CalculateFromParsedHexadecimalIdEENS0_15CalculatedFloatERKNS_16strings_internal11ParsedFloatE(ptr noundef nonnull align 8 dereferenceable(48) %parsed_hex) #4 {
entry:
  %retval = alloca %"struct.absl::(anonymous namespace)::CalculatedFloat", align 8
  %parsed_hex.addr = alloca ptr, align 8
  %mantissa = alloca i64, align 8
  %exponent = alloca i32, align 4
  %mantissa_width = alloca i32, align 4
  %shift = alloca i32, align 4
  %result_exact = alloca i8, align 1
  %agg.tmp = alloca %"class.absl::uint128", align 16
  store ptr %parsed_hex, ptr %parsed_hex.addr, align 8
  %0 = load ptr, ptr %parsed_hex.addr, align 8
  %mantissa1 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %0, i32 0, i32 0
  %1 = load i64, ptr %mantissa1, align 8
  store i64 %1, ptr %mantissa, align 8
  %2 = load ptr, ptr %parsed_hex.addr, align 8
  %exponent2 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %2, i32 0, i32 1
  %3 = load i32, ptr %exponent2, align 8
  store i32 %3, ptr %exponent, align 4
  %4 = load i64, ptr %mantissa, align 8
  %call = call noundef i32 @_ZN4absl9bit_widthImEENSt9enable_ifIXsr3std11is_unsignedIT_EE5valueEiE4typeES2_(i64 noundef %4) #3
  store i32 %call, ptr %mantissa_width, align 4
  %5 = load i32, ptr %mantissa_width, align 4
  %6 = load i32, ptr %exponent, align 4
  %call3 = call noundef i32 @_ZN4absl12_GLOBAL__N_119NormalizedShiftSizeIdEEiii(i32 noundef %5, i32 noundef %6)
  store i32 %call3, ptr %shift, align 4
  %7 = load i32, ptr %shift, align 4
  %8 = load i32, ptr %exponent, align 4
  %add = add nsw i32 %8, %7
  store i32 %add, ptr %exponent, align 4
  %9 = load i64, ptr %mantissa, align 8
  call void @_ZN4absl7uint128C2Em(ptr noundef nonnull align 16 dereferenceable(16) %agg.tmp, i64 noundef %9)
  %10 = load i32, ptr %shift, align 4
  %11 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 0
  %12 = load i64, ptr %11, align 16
  %13 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 1
  %14 = load i64, ptr %13, align 8
  %call4 = call noundef i64 @_ZN4absl12_GLOBAL__N_118ShiftRightAndRoundENS_7uint128EibPb(i64 %12, i64 %14, i32 noundef %10, i1 noundef zeroext true, ptr noundef %result_exact)
  store i64 %call4, ptr %mantissa, align 8
  %15 = load i64, ptr %mantissa, align 8
  %16 = load i32, ptr %exponent, align 4
  %call5 = call { i64, i32 } @_ZN4absl12_GLOBAL__N_128CalculatedFloatFromRawValuesIdEENS0_15CalculatedFloatEmi(i64 noundef %15, i32 noundef %16)
  %17 = getelementptr inbounds { i64, i32 }, ptr %retval, i32 0, i32 0
  %18 = extractvalue { i64, i32 } %call5, 0
  store i64 %18, ptr %17, align 8
  %19 = getelementptr inbounds { i64, i32 }, ptr %retval, i32 0, i32 1
  %20 = extractvalue { i64, i32 } %call5, 1
  store i32 %20, ptr %19, align 8
  %21 = load { i64, i32 }, ptr %retval, align 8
  ret { i64, i32 } %21
}

; Function Attrs: mustprogress uwtable
define internal void @_ZN4absl12_GLOBAL__N_112EncodeResultIdEEvRKNS0_15CalculatedFloatEbPNS_17from_chars_resultEPT_(ptr noundef nonnull align 8 dereferenceable(12) %calculated, i1 noundef zeroext %negative, ptr noundef %result, ptr noundef %value) #4 {
entry:
  %calculated.addr = alloca ptr, align 8
  %negative.addr = alloca i8, align 1
  %result.addr = alloca ptr, align 8
  %value.addr = alloca ptr, align 8
  store ptr %calculated, ptr %calculated.addr, align 8
  %frombool = zext i1 %negative to i8
  store i8 %frombool, ptr %negative.addr, align 1
  store ptr %result, ptr %result.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %calculated.addr, align 8
  %exponent = getelementptr inbounds %"struct.absl::(anonymous namespace)::CalculatedFloat", ptr %0, i32 0, i32 1
  %1 = load i32, ptr %exponent, align 8
  %cmp = icmp eq i32 %1, 99999
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %result.addr, align 8
  %ec = getelementptr inbounds %"struct.absl::from_chars_result", ptr %2, i32 0, i32 1
  store i32 34, ptr %ec, align 8
  %3 = load i8, ptr %negative.addr, align 1
  %tobool = trunc i8 %3 to i1
  %call = call noundef double @_ZNSt14numeric_limitsIdE3maxEv() #3
  %fneg = fneg double %call
  %call1 = call noundef double @_ZNSt14numeric_limitsIdE3maxEv() #3
  %cond = select i1 %tobool, double %fneg, double %call1
  %4 = load ptr, ptr %value.addr, align 8
  store double %cond, ptr %4, align 8
  br label %return

if.else:                                          ; preds = %entry
  %5 = load ptr, ptr %calculated.addr, align 8
  %mantissa = getelementptr inbounds %"struct.absl::(anonymous namespace)::CalculatedFloat", ptr %5, i32 0, i32 0
  %6 = load i64, ptr %mantissa, align 8
  %cmp2 = icmp eq i64 %6, 0
  br i1 %cmp2, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %7 = load ptr, ptr %calculated.addr, align 8
  %exponent3 = getelementptr inbounds %"struct.absl::(anonymous namespace)::CalculatedFloat", ptr %7, i32 0, i32 1
  %8 = load i32, ptr %exponent3, align 8
  %cmp4 = icmp eq i32 %8, -99999
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %lor.lhs.false, %if.else
  %9 = load ptr, ptr %result.addr, align 8
  %ec6 = getelementptr inbounds %"struct.absl::from_chars_result", ptr %9, i32 0, i32 1
  store i32 34, ptr %ec6, align 8
  %10 = load i8, ptr %negative.addr, align 1
  %tobool7 = trunc i8 %10 to i1
  %cond8 = select i1 %tobool7, double -0.000000e+00, double 0.000000e+00
  %11 = load ptr, ptr %value.addr, align 8
  store double %cond8, ptr %11, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  br label %if.end9

if.end9:                                          ; preds = %if.end
  %12 = load ptr, ptr %calculated.addr, align 8
  %mantissa10 = getelementptr inbounds %"struct.absl::(anonymous namespace)::CalculatedFloat", ptr %12, i32 0, i32 0
  %13 = load i64, ptr %mantissa10, align 8
  %14 = load ptr, ptr %calculated.addr, align 8
  %exponent11 = getelementptr inbounds %"struct.absl::(anonymous namespace)::CalculatedFloat", ptr %14, i32 0, i32 1
  %15 = load i32, ptr %exponent11, align 8
  %16 = load i8, ptr %negative.addr, align 1
  %tobool12 = trunc i8 %16 to i1
  %call13 = call noundef double @_ZN4absl12_GLOBAL__N_111FloatTraitsIdE4MakeEmib(i64 noundef %13, i32 noundef %15, i1 noundef zeroext %tobool12)
  %17 = load ptr, ptr %value.addr, align 8
  store double %call13, ptr %17, align 8
  br label %return

return:                                           ; preds = %if.end9, %if.then5, %if.then
  ret void
}

declare void @_ZN4absl16strings_internal10ParseFloatILi10EEENS0_11ParsedFloatEPKcS4_NS_12chars_formatE(ptr sret(%"struct.absl::strings_internal::ParsedFloat") align 8, ptr noundef, ptr noundef, i32 noundef) #1

; Function Attrs: mustprogress uwtable
define internal noundef zeroext i1 @_ZN4absl12_GLOBAL__N_111EiselLemireIdEEbRKNS_16strings_internal11ParsedFloatEbPT_PSt4errc(ptr noundef nonnull align 8 dereferenceable(48) %input, i1 noundef zeroext %negative, ptr noundef %value, ptr noundef %ec) #4 {
entry:
  %retval = alloca i1, align 1
  %input.addr = alloca ptr, align 8
  %negative.addr = alloca i8, align 1
  %value.addr = alloca ptr, align 8
  %ec.addr = alloca ptr, align 8
  %man = alloca i64, align 8
  %exp10 = alloca i32, align 4
  %clz = alloca i32, align 4
  %ret_exp2 = alloca i64, align 8
  %x = alloca %"class.absl::uint128", align 16
  %agg.tmp = alloca %"class.absl::uint128", align 16
  %agg.tmp9 = alloca %"class.absl::uint128", align 16
  %agg.tmp12 = alloca %"class.absl::uint128", align 16
  %agg.tmp16 = alloca %"class.absl::uint128", align 16
  %y = alloca %"class.absl::uint128", align 16
  %agg.tmp21 = alloca %"class.absl::uint128", align 16
  %agg.tmp22 = alloca %"class.absl::uint128", align 16
  %agg.tmp27 = alloca %"class.absl::uint128", align 16
  %agg.tmp28 = alloca %"class.absl::uint128", align 16
  %agg.tmp31 = alloca %"class.absl::uint128", align 16
  %agg.tmp36 = alloca %"class.absl::uint128", align 16
  %agg.tmp42 = alloca %"class.absl::uint128", align 16
  %msb = alloca i64, align 8
  %agg.tmp49 = alloca %"class.absl::uint128", align 16
  %ret_man = alloca i64, align 8
  %agg.tmp52 = alloca %"class.absl::uint128", align 16
  %agg.tmp57 = alloca %"class.absl::uint128", align 16
  %agg.tmp61 = alloca %"class.absl::uint128", align 16
  %ret_bits = alloca i64, align 8
  store ptr %input, ptr %input.addr, align 8
  %frombool = zext i1 %negative to i8
  store i8 %frombool, ptr %negative.addr, align 1
  store ptr %value, ptr %value.addr, align 8
  store ptr %ec, ptr %ec.addr, align 8
  %0 = load ptr, ptr %input.addr, align 8
  %mantissa = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %0, i32 0, i32 0
  %1 = load i64, ptr %mantissa, align 8
  store i64 %1, ptr %man, align 8
  %2 = load ptr, ptr %input.addr, align 8
  %exponent = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %2, i32 0, i32 1
  %3 = load i32, ptr %exponent, align 8
  store i32 %3, ptr %exp10, align 4
  %4 = load i32, ptr %exp10, align 4
  %cmp = icmp slt i32 %4, -342
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = load i8, ptr %negative.addr, align 1
  %tobool = trunc i8 %5 to i1
  %cond = select i1 %tobool, double -0.000000e+00, double 0.000000e+00
  %6 = load ptr, ptr %value.addr, align 8
  store double %cond, ptr %6, align 8
  %7 = load ptr, ptr %ec.addr, align 8
  store i32 34, ptr %7, align 4
  store i1 true, ptr %retval, align 1
  br label %return

if.else:                                          ; preds = %entry
  %8 = load i32, ptr %exp10, align 4
  %cmp1 = icmp sge i32 %8, 309
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  %9 = load i8, ptr %negative.addr, align 1
  %tobool3 = trunc i8 %9 to i1
  %call = call noundef double @_ZNSt14numeric_limitsIdE3maxEv() #3
  %fneg = fneg double %call
  %call4 = call noundef double @_ZNSt14numeric_limitsIdE3maxEv() #3
  %cond5 = select i1 %tobool3, double %fneg, double %call4
  %10 = load ptr, ptr %value.addr, align 8
  store double %cond5, ptr %10, align 8
  %11 = load ptr, ptr %ec.addr, align 8
  store i32 34, ptr %11, align 4
  store i1 true, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end6

if.end6:                                          ; preds = %if.end
  %12 = load i64, ptr %man, align 8
  %call7 = call noundef i32 @_ZN4absl11countl_zeroImEENSt9enable_ifIXsr3std11is_unsignedIT_EE5valueEiE4typeES2_(i64 noundef %12) #3
  store i32 %call7, ptr %clz, align 4
  %13 = load i32, ptr %clz, align 4
  %14 = load i64, ptr %man, align 8
  %sh_prom = zext i32 %13 to i64
  %shl = shl i64 %14, %sh_prom
  store i64 %shl, ptr %man, align 8
  %15 = load i32, ptr %exp10, align 4
  %mul = mul nsw i32 217706, %15
  %shr = ashr i32 %mul, 16
  %add = add nsw i32 %shr, 64
  %add8 = add nsw i32 %add, 1023
  %16 = load i32, ptr %clz, align 4
  %sub = sub nsw i32 %add8, %16
  %conv = sext i32 %sub to i64
  store i64 %conv, ptr %ret_exp2, align 8
  %17 = load i64, ptr %man, align 8
  call void @_ZN4absl7uint128C2Em(ptr noundef nonnull align 16 dereferenceable(16) %agg.tmp, i64 noundef %17)
  %18 = load i32, ptr %exp10, align 4
  %sub10 = sub nsw i32 %18, -342
  %idxprom = sext i32 %sub10 to i64
  %arrayidx = getelementptr inbounds [0 x i64], ptr @_ZN4absl12_GLOBAL__N_125kPower10MantissaHighTableE, i64 0, i64 %idxprom
  %19 = load i64, ptr %arrayidx, align 8
  call void @_ZN4absl7uint128C2Em(ptr noundef nonnull align 16 dereferenceable(16) %agg.tmp9, i64 noundef %19)
  %20 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 0
  %21 = load i64, ptr %20, align 16
  %22 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 1
  %23 = load i64, ptr %22, align 8
  %24 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp9, i32 0, i32 0
  %25 = load i64, ptr %24, align 16
  %26 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp9, i32 0, i32 1
  %27 = load i64, ptr %26, align 8
  %call11 = call { i64, i64 } @_ZN4abslmlENS_7uint128ES0_(i64 %21, i64 %23, i64 %25, i64 %27)
  %28 = getelementptr inbounds { i64, i64 }, ptr %x, i32 0, i32 0
  %29 = extractvalue { i64, i64 } %call11, 0
  store i64 %29, ptr %28, align 16
  %30 = getelementptr inbounds { i64, i64 }, ptr %x, i32 0, i32 1
  %31 = extractvalue { i64, i64 } %call11, 1
  store i64 %31, ptr %30, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp12, ptr align 16 %x, i64 16, i1 false)
  %32 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp12, i32 0, i32 0
  %33 = load i64, ptr %32, align 16
  %34 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp12, i32 0, i32 1
  %35 = load i64, ptr %34, align 8
  %call13 = call noundef i64 @_ZN4absl13Uint128High64ENS_7uint128E(i64 %33, i64 %35)
  %and = and i64 %call13, 511
  %cmp14 = icmp eq i64 %and, 511
  br i1 %cmp14, label %land.lhs.true, label %if.end48

land.lhs.true:                                    ; preds = %if.end6
  %36 = load i64, ptr %man, align 8
  %call15 = call noundef i64 @_ZNSt14numeric_limitsImE3maxEv() #3
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp16, ptr align 16 %x, i64 16, i1 false)
  %37 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp16, i32 0, i32 0
  %38 = load i64, ptr %37, align 16
  %39 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp16, i32 0, i32 1
  %40 = load i64, ptr %39, align 8
  %call17 = call noundef i64 @_ZN4absl12Uint128Low64ENS_7uint128E(i64 %38, i64 %40)
  %sub18 = sub i64 %call15, %call17
  %cmp19 = icmp ugt i64 %36, %sub18
  br i1 %cmp19, label %if.then20, label %if.end48

if.then20:                                        ; preds = %land.lhs.true
  %41 = load i64, ptr %man, align 8
  call void @_ZN4absl7uint128C2Em(ptr noundef nonnull align 16 dereferenceable(16) %agg.tmp21, i64 noundef %41)
  %42 = load i32, ptr %exp10, align 4
  %sub23 = sub nsw i32 %42, -342
  %idxprom24 = sext i32 %sub23 to i64
  %arrayidx25 = getelementptr inbounds [0 x i64], ptr @_ZN4absl12_GLOBAL__N_124kPower10MantissaLowTableE, i64 0, i64 %idxprom24
  %43 = load i64, ptr %arrayidx25, align 8
  call void @_ZN4absl7uint128C2Em(ptr noundef nonnull align 16 dereferenceable(16) %agg.tmp22, i64 noundef %43)
  %44 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp21, i32 0, i32 0
  %45 = load i64, ptr %44, align 16
  %46 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp21, i32 0, i32 1
  %47 = load i64, ptr %46, align 8
  %48 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp22, i32 0, i32 0
  %49 = load i64, ptr %48, align 16
  %50 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp22, i32 0, i32 1
  %51 = load i64, ptr %50, align 8
  %call26 = call { i64, i64 } @_ZN4abslmlENS_7uint128ES0_(i64 %45, i64 %47, i64 %49, i64 %51)
  %52 = getelementptr inbounds { i64, i64 }, ptr %y, i32 0, i32 0
  %53 = extractvalue { i64, i64 } %call26, 0
  store i64 %53, ptr %52, align 16
  %54 = getelementptr inbounds { i64, i64 }, ptr %y, i32 0, i32 1
  %55 = extractvalue { i64, i64 } %call26, 1
  store i64 %55, ptr %54, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp28, ptr align 16 %y, i64 16, i1 false)
  %56 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp28, i32 0, i32 0
  %57 = load i64, ptr %56, align 16
  %58 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp28, i32 0, i32 1
  %59 = load i64, ptr %58, align 8
  %call29 = call noundef i64 @_ZN4absl13Uint128High64ENS_7uint128E(i64 %57, i64 %59)
  call void @_ZN4absl7uint128C2Em(ptr noundef nonnull align 16 dereferenceable(16) %agg.tmp27, i64 noundef %call29)
  %60 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp27, i32 0, i32 0
  %61 = load i64, ptr %60, align 16
  %62 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp27, i32 0, i32 1
  %63 = load i64, ptr %62, align 8
  %call30 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN4absl7uint128pLES0_(ptr noundef nonnull align 16 dereferenceable(16) %x, i64 %61, i64 %63)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp31, ptr align 16 %x, i64 16, i1 false)
  %64 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp31, i32 0, i32 0
  %65 = load i64, ptr %64, align 16
  %66 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp31, i32 0, i32 1
  %67 = load i64, ptr %66, align 8
  %call32 = call noundef i64 @_ZN4absl13Uint128High64ENS_7uint128E(i64 %65, i64 %67)
  %and33 = and i64 %call32, 511
  %cmp34 = icmp eq i64 %and33, 511
  br i1 %cmp34, label %land.lhs.true35, label %if.end47

land.lhs.true35:                                  ; preds = %if.then20
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp36, ptr align 16 %x, i64 16, i1 false)
  %68 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp36, i32 0, i32 0
  %69 = load i64, ptr %68, align 16
  %70 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp36, i32 0, i32 1
  %71 = load i64, ptr %70, align 8
  %call37 = call noundef i64 @_ZN4absl12Uint128Low64ENS_7uint128E(i64 %69, i64 %71)
  %add38 = add i64 %call37, 1
  %cmp39 = icmp eq i64 %add38, 0
  br i1 %cmp39, label %land.lhs.true40, label %if.end47

land.lhs.true40:                                  ; preds = %land.lhs.true35
  %72 = load i64, ptr %man, align 8
  %call41 = call noundef i64 @_ZNSt14numeric_limitsImE3maxEv() #3
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp42, ptr align 16 %y, i64 16, i1 false)
  %73 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp42, i32 0, i32 0
  %74 = load i64, ptr %73, align 16
  %75 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp42, i32 0, i32 1
  %76 = load i64, ptr %75, align 8
  %call43 = call noundef i64 @_ZN4absl12Uint128Low64ENS_7uint128E(i64 %74, i64 %76)
  %sub44 = sub i64 %call41, %call43
  %cmp45 = icmp ugt i64 %72, %sub44
  br i1 %cmp45, label %if.then46, label %if.end47

if.then46:                                        ; preds = %land.lhs.true40
  store i1 false, ptr %retval, align 1
  br label %return

if.end47:                                         ; preds = %land.lhs.true40, %land.lhs.true35, %if.then20
  br label %if.end48

if.end48:                                         ; preds = %if.end47, %land.lhs.true, %if.end6
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp49, ptr align 16 %x, i64 16, i1 false)
  %77 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp49, i32 0, i32 0
  %78 = load i64, ptr %77, align 16
  %79 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp49, i32 0, i32 1
  %80 = load i64, ptr %79, align 8
  %call50 = call noundef i64 @_ZN4absl13Uint128High64ENS_7uint128E(i64 %78, i64 %80)
  %shr51 = lshr i64 %call50, 63
  store i64 %shr51, ptr %msb, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp52, ptr align 16 %x, i64 16, i1 false)
  %81 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp52, i32 0, i32 0
  %82 = load i64, ptr %81, align 16
  %83 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp52, i32 0, i32 1
  %84 = load i64, ptr %83, align 8
  %call53 = call noundef i64 @_ZN4absl13Uint128High64ENS_7uint128E(i64 %82, i64 %84)
  %85 = load i64, ptr %msb, align 8
  %add54 = add i64 %85, 9
  %shr55 = lshr i64 %call53, %add54
  store i64 %shr55, ptr %ret_man, align 8
  %86 = load i64, ptr %msb, align 8
  %xor = xor i64 1, %86
  %87 = load i64, ptr %ret_exp2, align 8
  %sub56 = sub i64 %87, %xor
  store i64 %sub56, ptr %ret_exp2, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp57, ptr align 16 %x, i64 16, i1 false)
  %88 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp57, i32 0, i32 0
  %89 = load i64, ptr %88, align 16
  %90 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp57, i32 0, i32 1
  %91 = load i64, ptr %90, align 8
  %call58 = call noundef i64 @_ZN4absl12Uint128Low64ENS_7uint128E(i64 %89, i64 %91)
  %cmp59 = icmp eq i64 %call58, 0
  br i1 %cmp59, label %land.lhs.true60, label %if.end69

land.lhs.true60:                                  ; preds = %if.end48
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp61, ptr align 16 %x, i64 16, i1 false)
  %92 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp61, i32 0, i32 0
  %93 = load i64, ptr %92, align 16
  %94 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp61, i32 0, i32 1
  %95 = load i64, ptr %94, align 8
  %call62 = call noundef i64 @_ZN4absl13Uint128High64ENS_7uint128E(i64 %93, i64 %95)
  %and63 = and i64 %call62, 511
  %cmp64 = icmp eq i64 %and63, 0
  br i1 %cmp64, label %land.lhs.true65, label %if.end69

land.lhs.true65:                                  ; preds = %land.lhs.true60
  %96 = load i64, ptr %ret_man, align 8
  %and66 = and i64 %96, 3
  %cmp67 = icmp eq i64 %and66, 1
  br i1 %cmp67, label %if.then68, label %if.end69

if.then68:                                        ; preds = %land.lhs.true65
  store i1 false, ptr %retval, align 1
  br label %return

if.end69:                                         ; preds = %land.lhs.true65, %land.lhs.true60, %if.end48
  %97 = load i64, ptr %ret_man, align 8
  %and70 = and i64 %97, 1
  %98 = load i64, ptr %ret_man, align 8
  %add71 = add i64 %98, %and70
  store i64 %add71, ptr %ret_man, align 8
  %99 = load i64, ptr %ret_man, align 8
  %shr72 = lshr i64 %99, 1
  store i64 %shr72, ptr %ret_man, align 8
  %100 = load i64, ptr %ret_man, align 8
  %shr73 = lshr i64 %100, 53
  %cmp74 = icmp ugt i64 %shr73, 0
  br i1 %cmp74, label %if.then75, label %if.end77

if.then75:                                        ; preds = %if.end69
  %101 = load i64, ptr %ret_exp2, align 8
  %add76 = add i64 %101, 1
  store i64 %add76, ptr %ret_exp2, align 8
  br label %if.end77

if.end77:                                         ; preds = %if.then75, %if.end69
  %102 = load i64, ptr %ret_exp2, align 8
  %sub78 = sub i64 %102, 1
  %cmp79 = icmp uge i64 %sub78, 2046
  br i1 %cmp79, label %if.then80, label %if.end81

if.then80:                                        ; preds = %if.end77
  store i1 false, ptr %retval, align 1
  br label %return

if.end81:                                         ; preds = %if.end77
  %103 = load i64, ptr %ret_exp2, align 8
  %shl82 = shl i64 %103, 52
  %104 = load i64, ptr %ret_man, align 8
  %and83 = and i64 %104, 4503599627370495
  %or = or i64 %shl82, %and83
  store i64 %or, ptr %ret_bits, align 8
  %105 = load i8, ptr %negative.addr, align 1
  %tobool84 = trunc i8 %105 to i1
  br i1 %tobool84, label %if.then85, label %if.end87

if.then85:                                        ; preds = %if.end81
  %106 = load i64, ptr %ret_bits, align 8
  %or86 = or i64 %106, -9223372036854775808
  store i64 %or86, ptr %ret_bits, align 8
  br label %if.end87

if.end87:                                         ; preds = %if.then85, %if.end81
  %call88 = call noundef double @_ZN4absl8bit_castIdmTnNSt9enable_ifIXaaaaeqstT_stT0_sr3std21is_trivially_copyableIS3_EE5valuesr3std21is_trivially_copyableIS2_EE5valueEiE4typeELi0EEES2_RKS3_(ptr noundef nonnull align 8 dereferenceable(8) %ret_bits)
  %107 = load ptr, ptr %value.addr, align 8
  store double %call88, ptr %107, align 8
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end87, %if.then80, %if.then68, %if.then46, %if.then2, %if.then
  %108 = load i1, ptr %retval, align 1
  ret i1 %108
}

; Function Attrs: mustprogress uwtable
define internal { i64, i32 } @_ZN4absl12_GLOBAL__N_126CalculateFromParsedDecimalIdEENS0_15CalculatedFloatERKNS_16strings_internal11ParsedFloatE(ptr noundef nonnull align 8 dereferenceable(48) %parsed_decimal) #4 {
entry:
  %retval = alloca %"struct.absl::(anonymous namespace)::CalculatedFloat", align 8
  %parsed_decimal.addr = alloca ptr, align 8
  %result = alloca %"struct.absl::(anonymous namespace)::CalculatedFloat", align 8
  %wide_binary_mantissa = alloca %"class.absl::uint128", align 16
  %agg.tmp = alloca %"class.absl::uint128", align 16
  %binary_exponent = alloca i32, align 4
  %mantissa_exact = alloca i8, align 1
  %mantissa_width = alloca i32, align 4
  %agg.tmp21 = alloca %"class.absl::uint128", align 16
  %shift = alloca i32, align 4
  %result_exact = alloca i8, align 1
  %binary_mantissa = alloca i64, align 8
  %agg.tmp27 = alloca %"class.absl::uint128", align 16
  store ptr %parsed_decimal, ptr %parsed_decimal.addr, align 8
  call void @_ZN4absl12_GLOBAL__N_115CalculatedFloatC2Ev(ptr noundef nonnull align 8 dereferenceable(12) %result) #3
  %0 = load ptr, ptr %parsed_decimal.addr, align 8
  %exponent = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %0, i32 0, i32 1
  %1 = load i32, ptr %exponent, align 8
  %call = call noundef zeroext i1 @_ZN4absl12_GLOBAL__N_116Power10UnderflowEi(i32 noundef %1)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %exponent1 = getelementptr inbounds %"struct.absl::(anonymous namespace)::CalculatedFloat", ptr %result, i32 0, i32 1
  store i32 -99999, ptr %exponent1, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %result, i64 16, i1 false)
  br label %return

if.else:                                          ; preds = %entry
  %2 = load ptr, ptr %parsed_decimal.addr, align 8
  %exponent2 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %2, i32 0, i32 1
  %3 = load i32, ptr %exponent2, align 8
  %call3 = call noundef zeroext i1 @_ZN4absl12_GLOBAL__N_115Power10OverflowEi(i32 noundef %3)
  br i1 %call3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %exponent5 = getelementptr inbounds %"struct.absl::(anonymous namespace)::CalculatedFloat", ptr %result, i32 0, i32 1
  store i32 99999, ptr %exponent5, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %result, i64 16, i1 false)
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end6

if.end6:                                          ; preds = %if.end
  %4 = load ptr, ptr %parsed_decimal.addr, align 8
  %mantissa = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %4, i32 0, i32 0
  %5 = load i64, ptr %mantissa, align 8
  call void @_ZN4absl7uint128C2Em(ptr noundef nonnull align 16 dereferenceable(16) %wide_binary_mantissa, i64 noundef %5)
  %6 = load ptr, ptr %parsed_decimal.addr, align 8
  %exponent7 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %6, i32 0, i32 1
  %7 = load i32, ptr %exponent7, align 8
  %call8 = call noundef i64 @_ZN4absl12_GLOBAL__N_115Power10MantissaEi(i32 noundef %7)
  call void @_ZN4absl7uint128C2Em(ptr noundef nonnull align 16 dereferenceable(16) %agg.tmp, i64 noundef %call8)
  %8 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 0
  %9 = load i64, ptr %8, align 16
  %10 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  %call9 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN4absl7uint128mLES0_(ptr noundef nonnull align 16 dereferenceable(16) %wide_binary_mantissa, i64 %9, i64 %11)
  %12 = load ptr, ptr %parsed_decimal.addr, align 8
  %exponent10 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %12, i32 0, i32 1
  %13 = load i32, ptr %exponent10, align 8
  %call11 = call noundef i32 @_ZN4absl12_GLOBAL__N_115Power10ExponentEi(i32 noundef %13)
  store i32 %call11, ptr %binary_exponent, align 4
  %14 = load ptr, ptr %parsed_decimal.addr, align 8
  %subrange_begin = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %14, i32 0, i32 4
  %15 = load ptr, ptr %subrange_begin, align 8
  %tobool = icmp ne ptr %15, null
  br i1 %tobool, label %if.then12, label %if.else14

if.then12:                                        ; preds = %if.end6
  store i32 58, ptr %mantissa_width, align 4
  store i8 0, ptr %mantissa_exact, align 1
  %16 = load i32, ptr %mantissa_width, align 4
  %call13 = call noundef i32 @_ZN4absl12_GLOBAL__N_118TruncateToBitWidthEiPNS_7uint128E(i32 noundef %16, ptr noundef %wide_binary_mantissa)
  %17 = load i32, ptr %binary_exponent, align 4
  %add = add nsw i32 %17, %call13
  store i32 %add, ptr %binary_exponent, align 4
  br label %if.end24

if.else14:                                        ; preds = %if.end6
  %18 = load ptr, ptr %parsed_decimal.addr, align 8
  %exponent15 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %18, i32 0, i32 1
  %19 = load i32, ptr %exponent15, align 8
  %call16 = call noundef zeroext i1 @_ZN4absl12_GLOBAL__N_112Power10ExactEi(i32 noundef %19)
  br i1 %call16, label %if.else20, label %if.then17

if.then17:                                        ; preds = %if.else14
  store i32 63, ptr %mantissa_width, align 4
  store i8 0, ptr %mantissa_exact, align 1
  %20 = load i32, ptr %mantissa_width, align 4
  %call18 = call noundef i32 @_ZN4absl12_GLOBAL__N_118TruncateToBitWidthEiPNS_7uint128E(i32 noundef %20, ptr noundef %wide_binary_mantissa)
  %21 = load i32, ptr %binary_exponent, align 4
  %add19 = add nsw i32 %21, %call18
  store i32 %add19, ptr %binary_exponent, align 4
  br label %if.end23

if.else20:                                        ; preds = %if.else14
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp21, ptr align 16 %wide_binary_mantissa, i64 16, i1 false)
  %22 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp21, i32 0, i32 0
  %23 = load i64, ptr %22, align 16
  %24 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp21, i32 0, i32 1
  %25 = load i64, ptr %24, align 8
  %call22 = call noundef i32 @_ZN4absl12_GLOBAL__N_18BitWidthENS_7uint128E(i64 %23, i64 %25)
  store i32 %call22, ptr %mantissa_width, align 4
  store i8 1, ptr %mantissa_exact, align 1
  br label %if.end23

if.end23:                                         ; preds = %if.else20, %if.then17
  br label %if.end24

if.end24:                                         ; preds = %if.end23, %if.then12
  %26 = load i32, ptr %mantissa_width, align 4
  %27 = load i32, ptr %binary_exponent, align 4
  %call25 = call noundef i32 @_ZN4absl12_GLOBAL__N_119NormalizedShiftSizeIdEEiii(i32 noundef %26, i32 noundef %27)
  store i32 %call25, ptr %shift, align 4
  %28 = load i32, ptr %shift, align 4
  %29 = load i32, ptr %binary_exponent, align 4
  %add26 = add nsw i32 %29, %28
  store i32 %add26, ptr %binary_exponent, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp27, ptr align 16 %wide_binary_mantissa, i64 16, i1 false)
  %30 = load i32, ptr %shift, align 4
  %31 = load i8, ptr %mantissa_exact, align 1
  %tobool28 = trunc i8 %31 to i1
  %32 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp27, i32 0, i32 0
  %33 = load i64, ptr %32, align 16
  %34 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp27, i32 0, i32 1
  %35 = load i64, ptr %34, align 8
  %call29 = call noundef i64 @_ZN4absl12_GLOBAL__N_118ShiftRightAndRoundENS_7uint128EibPb(i64 %33, i64 %35, i32 noundef %30, i1 noundef zeroext %tobool28, ptr noundef %result_exact)
  store i64 %call29, ptr %binary_mantissa, align 8
  %36 = load i8, ptr %result_exact, align 1
  %tobool30 = trunc i8 %36 to i1
  br i1 %tobool30, label %if.end36, label %if.then31

if.then31:                                        ; preds = %if.end24
  %37 = load i64, ptr %binary_mantissa, align 8
  %38 = load i32, ptr %binary_exponent, align 4
  %39 = load ptr, ptr %parsed_decimal.addr, align 8
  %call32 = call noundef zeroext i1 @_ZN4absl12_GLOBAL__N_111MustRoundUpEmiRKNS_16strings_internal11ParsedFloatE(i64 noundef %37, i32 noundef %38, ptr noundef nonnull align 8 dereferenceable(48) %39)
  br i1 %call32, label %if.then33, label %if.end35

if.then33:                                        ; preds = %if.then31
  %40 = load i64, ptr %binary_mantissa, align 8
  %add34 = add i64 %40, 1
  store i64 %add34, ptr %binary_mantissa, align 8
  br label %if.end35

if.end35:                                         ; preds = %if.then33, %if.then31
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.end24
  %41 = load i64, ptr %binary_mantissa, align 8
  %42 = load i32, ptr %binary_exponent, align 4
  %call37 = call { i64, i32 } @_ZN4absl12_GLOBAL__N_128CalculatedFloatFromRawValuesIdEENS0_15CalculatedFloatEmi(i64 noundef %41, i32 noundef %42)
  %43 = getelementptr inbounds { i64, i32 }, ptr %retval, i32 0, i32 0
  %44 = extractvalue { i64, i32 } %call37, 0
  store i64 %44, ptr %43, align 8
  %45 = getelementptr inbounds { i64, i32 }, ptr %retval, i32 0, i32 1
  %46 = extractvalue { i64, i32 } %call37, 1
  store i32 %46, ptr %45, align 8
  br label %return

return:                                           ; preds = %if.end36, %if.then4, %if.then
  %47 = load { i64, i32 }, ptr %retval, align 8
  ret { i64, i32 } %47
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZSt3minIlERKT_S2_S2_(ptr noundef nonnull align 8 dereferenceable(8) %__a, ptr noundef nonnull align 8 dereferenceable(8) %__b) #5 comdat {
entry:
  %retval = alloca ptr, align 8
  %__a.addr = alloca ptr, align 8
  %__b.addr = alloca ptr, align 8
  store ptr %__a, ptr %__a.addr, align 8
  store ptr %__b, ptr %__b.addr, align 8
  %0 = load ptr, ptr %__b.addr, align 8
  %1 = load i64, ptr %0, align 8
  %2 = load ptr, ptr %__a.addr, align 8
  %3 = load i64, ptr %2, align 8
  %cmp = icmp slt i64 %1, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %__b.addr, align 8
  store ptr %4, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %__a.addr, align 8
  store ptr %5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load ptr, ptr %retval, align 8
  ret ptr %6
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZSt6copy_nIPKclPcET1_T_T0_S3_(ptr noundef %__first, i64 noundef %__n, ptr noundef %__result) #4 comdat {
entry:
  %retval = alloca ptr, align 8
  %__first.addr = alloca ptr, align 8
  %__n.addr = alloca i64, align 8
  %__result.addr = alloca ptr, align 8
  %__n2 = alloca i64, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store i64 %__n, ptr %__n.addr, align 8
  store ptr %__result, ptr %__result.addr, align 8
  %0 = load i64, ptr %__n.addr, align 8
  %call = call noundef i64 @_ZSt17__size_to_integerl(i64 noundef %0)
  store i64 %call, ptr %__n2, align 8
  %1 = load i64, ptr %__n2, align 8
  %cmp = icmp sle i64 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %__result.addr, align 8
  store ptr %2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %__first.addr, align 8
  %4 = load i64, ptr %__n2, align 8
  %5 = load ptr, ptr %__result.addr, align 8
  call void @_ZSt19__iterator_categoryIPKcENSt15iterator_traitsIT_E17iterator_categoryERKS3_(ptr noundef nonnull align 8 dereferenceable(8) %__first.addr)
  %call1 = call noundef ptr @_ZSt8__copy_nIPKclPcET1_T_T0_S3_St26random_access_iterator_tag(ptr noundef %3, i64 noundef %4, ptr noundef %5)
  store ptr %call1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load ptr, ptr %retval, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef double @_ZN4absl12_GLOBAL__N_111FloatTraitsIdE7MakeNanEPKc(ptr noundef %tagp) #5 align 2 {
entry:
  %tagp.addr = alloca ptr, align 8
  store ptr %tagp, ptr %tagp.addr, align 8
  %0 = load ptr, ptr %tagp.addr, align 8
  %call = call double @nan(ptr noundef %0) #10
  ret double %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef double @_ZNSt14numeric_limitsIdE8infinityEv() #5 comdat align 2 {
entry:
  ret double 0x7FF0000000000000
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZSt17__size_to_integerl(i64 noundef %__n) #5 comdat {
entry:
  %__n.addr = alloca i64, align 8
  store i64 %__n, ptr %__n.addr, align 8
  %0 = load i64, ptr %__n.addr, align 8
  ret i64 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZSt8__copy_nIPKclPcET1_T_T0_S3_St26random_access_iterator_tag(ptr noundef %__first, i64 noundef %__n, ptr noundef %__result) #4 comdat {
entry:
  %__first.addr = alloca ptr, align 8
  %__n.addr = alloca i64, align 8
  %__result.addr = alloca ptr, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store i64 %__n, ptr %__n.addr, align 8
  store ptr %__result, ptr %__result.addr, align 8
  %0 = load ptr, ptr %__first.addr, align 8
  %1 = load ptr, ptr %__first.addr, align 8
  %2 = load i64, ptr %__n.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %1, i64 %2
  %3 = load ptr, ptr %__result.addr, align 8
  %call = call noundef ptr @_ZSt4copyIPKcPcET0_T_S4_S3_(ptr noundef %0, ptr noundef %add.ptr, ptr noundef %3)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZSt19__iterator_categoryIPKcENSt15iterator_traitsIT_E17iterator_categoryERKS3_(ptr noundef nonnull align 8 dereferenceable(8) %0) #5 comdat {
entry:
  %.addr = alloca ptr, align 8
  store ptr %0, ptr %.addr, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZSt4copyIPKcPcET0_T_S4_S3_(ptr noundef %__first, ptr noundef %__last, ptr noundef %__result) #4 comdat {
entry:
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__result.addr = alloca ptr, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store ptr %__last, ptr %__last.addr, align 8
  store ptr %__result, ptr %__result.addr, align 8
  %0 = load ptr, ptr %__first.addr, align 8
  %call = call noundef ptr @_ZSt12__miter_baseIPKcET_S2_(ptr noundef %0)
  %1 = load ptr, ptr %__last.addr, align 8
  %call1 = call noundef ptr @_ZSt12__miter_baseIPKcET_S2_(ptr noundef %1)
  %2 = load ptr, ptr %__result.addr, align 8
  %call2 = call noundef ptr @_ZSt13__copy_move_aILb0EPKcPcET1_T0_S4_S3_(ptr noundef %call, ptr noundef %call1, ptr noundef %2)
  ret ptr %call2
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZSt13__copy_move_aILb0EPKcPcET1_T0_S4_S3_(ptr noundef %__first, ptr noundef %__last, ptr noundef %__result) #4 comdat {
entry:
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__result.addr = alloca ptr, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store ptr %__last, ptr %__last.addr, align 8
  store ptr %__result, ptr %__result.addr, align 8
  %0 = load ptr, ptr %__first.addr, align 8
  %call = call noundef ptr @_ZSt12__niter_baseIPKcET_S2_(ptr noundef %0) #3
  %1 = load ptr, ptr %__last.addr, align 8
  %call1 = call noundef ptr @_ZSt12__niter_baseIPKcET_S2_(ptr noundef %1) #3
  %2 = load ptr, ptr %__result.addr, align 8
  %call2 = call noundef ptr @_ZSt12__niter_baseIPcET_S1_(ptr noundef %2) #3
  %call3 = call noundef ptr @_ZSt14__copy_move_a1ILb0EPKcPcET1_T0_S4_S3_(ptr noundef %call, ptr noundef %call1, ptr noundef %call2)
  %call4 = call noundef ptr @_ZSt12__niter_wrapIPcET_RKS1_S1_(ptr noundef nonnull align 8 dereferenceable(8) %__result.addr, ptr noundef %call3)
  ret ptr %call4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZSt12__miter_baseIPKcET_S2_(ptr noundef %__it) #5 comdat {
entry:
  %__it.addr = alloca ptr, align 8
  store ptr %__it, ptr %__it.addr, align 8
  %0 = load ptr, ptr %__it.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZSt12__niter_wrapIPcET_RKS1_S1_(ptr noundef nonnull align 8 dereferenceable(8) %0, ptr noundef %__res) #5 comdat {
entry:
  %.addr = alloca ptr, align 8
  %__res.addr = alloca ptr, align 8
  store ptr %0, ptr %.addr, align 8
  store ptr %__res, ptr %__res.addr, align 8
  %1 = load ptr, ptr %__res.addr, align 8
  ret ptr %1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZSt14__copy_move_a1ILb0EPKcPcET1_T0_S4_S3_(ptr noundef %__first, ptr noundef %__last, ptr noundef %__result) #4 comdat {
entry:
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__result.addr = alloca ptr, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store ptr %__last, ptr %__last.addr, align 8
  store ptr %__result, ptr %__result.addr, align 8
  %0 = load ptr, ptr %__first.addr, align 8
  %1 = load ptr, ptr %__last.addr, align 8
  %2 = load ptr, ptr %__result.addr, align 8
  %call = call noundef ptr @_ZSt14__copy_move_a2ILb0EPKcPcET1_T0_S4_S3_(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZSt12__niter_baseIPKcET_S2_(ptr noundef %__it) #5 comdat {
entry:
  %__it.addr = alloca ptr, align 8
  store ptr %__it, ptr %__it.addr, align 8
  %0 = load ptr, ptr %__it.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZSt12__niter_baseIPcET_S1_(ptr noundef %__it) #5 comdat {
entry:
  %__it.addr = alloca ptr, align 8
  store ptr %__it, ptr %__it.addr, align 8
  %0 = load ptr, ptr %__it.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZSt14__copy_move_a2ILb0EPKcPcET1_T0_S4_S3_(ptr noundef %__first, ptr noundef %__last, ptr noundef %__result) #4 comdat {
entry:
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__result.addr = alloca ptr, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store ptr %__last, ptr %__last.addr, align 8
  store ptr %__result, ptr %__result.addr, align 8
  %0 = load ptr, ptr %__first.addr, align 8
  %1 = load ptr, ptr %__last.addr, align 8
  %2 = load ptr, ptr %__result.addr, align 8
  %call = call noundef ptr @_ZNSt11__copy_moveILb0ELb1ESt26random_access_iterator_tagE8__copy_mIcEEPT_PKS3_S6_S4_(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNSt11__copy_moveILb0ELb1ESt26random_access_iterator_tagE8__copy_mIcEEPT_PKS3_S6_S4_(ptr noundef %__first, ptr noundef %__last, ptr noundef %__result) #5 comdat align 2 {
entry:
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__result.addr = alloca ptr, align 8
  %_Num = alloca i64, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store ptr %__last, ptr %__last.addr, align 8
  store ptr %__result, ptr %__result.addr, align 8
  %0 = load ptr, ptr %__last.addr, align 8
  %1 = load ptr, ptr %__first.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %_Num, align 8
  %2 = load i64, ptr %_Num, align 8
  %tobool = icmp ne i64 %2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %__result.addr, align 8
  %4 = load ptr, ptr %__first.addr, align 8
  %5 = load i64, ptr %_Num, align 8
  %mul = mul i64 1, %5
  call void @llvm.memmove.p0.p0.i64(ptr align 1 %3, ptr align 1 %4, i64 %mul, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load ptr, ptr %__result.addr, align 8
  %7 = load i64, ptr %_Num, align 8
  %add.ptr = getelementptr inbounds i8, ptr %6, i64 %7
  ret ptr %add.ptr
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memmove.p0.p0.i64(ptr nocapture writeonly, ptr nocapture readonly, i64, i1 immarg) #6

; Function Attrs: nounwind willreturn memory(read)
declare double @nan(ptr noundef) #7

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZN4absl9bit_widthImEENSt9enable_ifIXsr3std11is_unsignedIT_EE5valueEiE4typeES2_(i64 noundef %x) #5 comdat {
entry:
  %x.addr = alloca i64, align 8
  store i64 %x, ptr %x.addr, align 8
  %0 = load i64, ptr %x.addr, align 8
  %call = call noundef i32 @_ZN4absl11countl_zeroImEENSt9enable_ifIXsr3std11is_unsignedIT_EE5valueEiE4typeES2_(i64 noundef %0) #3
  %sub = sub nsw i32 64, %call
  ret i32 %sub
}

; Function Attrs: mustprogress uwtable
define internal noundef i32 @_ZN4absl12_GLOBAL__N_119NormalizedShiftSizeIdEEiii(i32 noundef %mantissa_width, i32 noundef %binary_exponent) #4 {
entry:
  %mantissa_width.addr = alloca i32, align 4
  %binary_exponent.addr = alloca i32, align 4
  %normal_shift = alloca i32, align 4
  %minimum_shift = alloca i32, align 4
  store i32 %mantissa_width, ptr %mantissa_width.addr, align 4
  store i32 %binary_exponent, ptr %binary_exponent.addr, align 4
  %0 = load i32, ptr %mantissa_width.addr, align 4
  %sub = sub nsw i32 %0, 53
  store i32 %sub, ptr %normal_shift, align 4
  %1 = load i32, ptr %binary_exponent.addr, align 4
  %sub1 = sub nsw i32 -1074, %1
  store i32 %sub1, ptr %minimum_shift, align 4
  %call = call noundef nonnull align 4 dereferenceable(4) ptr @_ZSt3maxIiERKT_S2_S2_(ptr noundef nonnull align 4 dereferenceable(4) %normal_shift, ptr noundef nonnull align 4 dereferenceable(4) %minimum_shift)
  %2 = load i32, ptr %call, align 4
  ret i32 %2
}

; Function Attrs: mustprogress uwtable
define internal noundef i64 @_ZN4absl12_GLOBAL__N_118ShiftRightAndRoundENS_7uint128EibPb(i64 %value.coerce0, i64 %value.coerce1, i32 noundef %shift, i1 noundef zeroext %input_exact, ptr noundef %output_exact) #4 {
entry:
  %retval = alloca i64, align 8
  %value = alloca %"class.absl::uint128", align 16
  %shift.addr = alloca i32, align 4
  %input_exact.addr = alloca i8, align 1
  %output_exact.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.absl::uint128", align 16
  %agg.tmp = alloca %"class.absl::uint128", align 16
  %shift_mask = alloca %"class.absl::uint128", align 16
  %agg.tmp6 = alloca %"class.absl::uint128", align 16
  %agg.tmp7 = alloca %"class.absl::uint128", align 16
  %agg.tmp9 = alloca %"class.absl::uint128", align 16
  %halfway_point = alloca %"class.absl::uint128", align 16
  %agg.tmp11 = alloca %"class.absl::uint128", align 16
  %shifted_bits = alloca %"class.absl::uint128", align 16
  %agg.tmp14 = alloca %"class.absl::uint128", align 16
  %agg.tmp15 = alloca %"class.absl::uint128", align 16
  %agg.tmp18 = alloca %"class.absl::uint128", align 16
  %agg.tmp19 = alloca %"class.absl::uint128", align 16
  %ref.tmp22 = alloca %"class.absl::uint128", align 16
  %agg.tmp23 = alloca %"class.absl::uint128", align 16
  %agg.tmp24 = alloca %"class.absl::uint128", align 16
  %agg.tmp28 = alloca %"class.absl::uint128", align 16
  %agg.tmp29 = alloca %"class.absl::uint128", align 16
  %agg.tmp32 = alloca %"class.absl::uint128", align 16
  %agg.tmp33 = alloca %"class.absl::uint128", align 16
  %agg.tmp34 = alloca %"class.absl::uint128", align 16
  %agg.tmp36 = alloca %"class.absl::uint128", align 16
  %agg.tmp45 = alloca %"class.absl::uint128", align 16
  %agg.tmp46 = alloca %"class.absl::uint128", align 16
  %agg.tmp47 = alloca %"class.absl::uint128", align 16
  %agg.tmp48 = alloca %"class.absl::uint128", align 16
  %0 = getelementptr inbounds { i64, i64 }, ptr %value, i32 0, i32 0
  store i64 %value.coerce0, ptr %0, align 16
  %1 = getelementptr inbounds { i64, i64 }, ptr %value, i32 0, i32 1
  store i64 %value.coerce1, ptr %1, align 8
  store i32 %shift, ptr %shift.addr, align 4
  %frombool = zext i1 %input_exact to i8
  store i8 %frombool, ptr %input_exact.addr, align 1
  store ptr %output_exact, ptr %output_exact.addr, align 8
  %2 = load i32, ptr %shift.addr, align 4
  %cmp = icmp sle i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i8, ptr %input_exact.addr, align 1
  %tobool = trunc i8 %3 to i1
  %4 = load ptr, ptr %output_exact.addr, align 8
  %frombool1 = zext i1 %tobool to i8
  store i8 %frombool1, ptr %4, align 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp, ptr align 16 %value, i64 16, i1 false)
  %5 = load i32, ptr %shift.addr, align 4
  %sub = sub nsw i32 0, %5
  %6 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 0
  %7 = load i64, ptr %6, align 16
  %8 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 1
  %9 = load i64, ptr %8, align 8
  %call = call { i64, i64 } @_ZN4absllsENS_7uint128Ei(i64 %7, i64 %9, i32 noundef %sub)
  %10 = getelementptr inbounds { i64, i64 }, ptr %ref.tmp, i32 0, i32 0
  %11 = extractvalue { i64, i64 } %call, 0
  store i64 %11, ptr %10, align 16
  %12 = getelementptr inbounds { i64, i64 }, ptr %ref.tmp, i32 0, i32 1
  %13 = extractvalue { i64, i64 } %call, 1
  store i64 %13, ptr %12, align 8
  %call2 = call noundef i64 @_ZNK4absl7uint128cvmEv(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp)
  store i64 %call2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %14 = load i32, ptr %shift.addr, align 4
  %cmp3 = icmp sge i32 %14, 128
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %15 = load ptr, ptr %output_exact.addr, align 8
  store i8 1, ptr %15, align 1
  store i64 0, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.end
  %16 = load ptr, ptr %output_exact.addr, align 8
  store i8 1, ptr %16, align 1
  call void @_ZN4absl7uint128C2Ei(ptr noundef nonnull align 16 dereferenceable(16) %agg.tmp7, i32 noundef 1)
  %17 = load i32, ptr %shift.addr, align 4
  %18 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp7, i32 0, i32 0
  %19 = load i64, ptr %18, align 16
  %20 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp7, i32 0, i32 1
  %21 = load i64, ptr %20, align 8
  %call8 = call { i64, i64 } @_ZN4absllsENS_7uint128Ei(i64 %19, i64 %21, i32 noundef %17)
  %22 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp6, i32 0, i32 0
  %23 = extractvalue { i64, i64 } %call8, 0
  store i64 %23, ptr %22, align 16
  %24 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp6, i32 0, i32 1
  %25 = extractvalue { i64, i64 } %call8, 1
  store i64 %25, ptr %24, align 8
  call void @_ZN4absl7uint128C2Ei(ptr noundef nonnull align 16 dereferenceable(16) %agg.tmp9, i32 noundef 1)
  %26 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp6, i32 0, i32 0
  %27 = load i64, ptr %26, align 16
  %28 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp6, i32 0, i32 1
  %29 = load i64, ptr %28, align 8
  %30 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp9, i32 0, i32 0
  %31 = load i64, ptr %30, align 16
  %32 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp9, i32 0, i32 1
  %33 = load i64, ptr %32, align 8
  %call10 = call { i64, i64 } @_ZN4abslmiENS_7uint128ES0_(i64 %27, i64 %29, i64 %31, i64 %33)
  %34 = getelementptr inbounds { i64, i64 }, ptr %shift_mask, i32 0, i32 0
  %35 = extractvalue { i64, i64 } %call10, 0
  store i64 %35, ptr %34, align 16
  %36 = getelementptr inbounds { i64, i64 }, ptr %shift_mask, i32 0, i32 1
  %37 = extractvalue { i64, i64 } %call10, 1
  store i64 %37, ptr %36, align 8
  call void @_ZN4absl7uint128C2Ei(ptr noundef nonnull align 16 dereferenceable(16) %agg.tmp11, i32 noundef 1)
  %38 = load i32, ptr %shift.addr, align 4
  %sub12 = sub nsw i32 %38, 1
  %39 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp11, i32 0, i32 0
  %40 = load i64, ptr %39, align 16
  %41 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp11, i32 0, i32 1
  %42 = load i64, ptr %41, align 8
  %call13 = call { i64, i64 } @_ZN4absllsENS_7uint128Ei(i64 %40, i64 %42, i32 noundef %sub12)
  %43 = getelementptr inbounds { i64, i64 }, ptr %halfway_point, i32 0, i32 0
  %44 = extractvalue { i64, i64 } %call13, 0
  store i64 %44, ptr %43, align 16
  %45 = getelementptr inbounds { i64, i64 }, ptr %halfway_point, i32 0, i32 1
  %46 = extractvalue { i64, i64 } %call13, 1
  store i64 %46, ptr %45, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp14, ptr align 16 %value, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp15, ptr align 16 %shift_mask, i64 16, i1 false)
  %47 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp14, i32 0, i32 0
  %48 = load i64, ptr %47, align 16
  %49 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp14, i32 0, i32 1
  %50 = load i64, ptr %49, align 8
  %51 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp15, i32 0, i32 0
  %52 = load i64, ptr %51, align 16
  %53 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp15, i32 0, i32 1
  %54 = load i64, ptr %53, align 8
  %call16 = call { i64, i64 } @_ZN4abslanENS_7uint128ES0_(i64 %48, i64 %50, i64 %52, i64 %54)
  %55 = getelementptr inbounds { i64, i64 }, ptr %shifted_bits, i32 0, i32 0
  %56 = extractvalue { i64, i64 } %call16, 0
  store i64 %56, ptr %55, align 16
  %57 = getelementptr inbounds { i64, i64 }, ptr %shifted_bits, i32 0, i32 1
  %58 = extractvalue { i64, i64 } %call16, 1
  store i64 %58, ptr %57, align 8
  %59 = load i32, ptr %shift.addr, align 4
  %call17 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN4absl7uint128rSEi(ptr noundef nonnull align 16 dereferenceable(16) %value, i32 noundef %59)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp18, ptr align 16 %shifted_bits, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp19, ptr align 16 %halfway_point, i64 16, i1 false)
  %60 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp18, i32 0, i32 0
  %61 = load i64, ptr %60, align 16
  %62 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp18, i32 0, i32 1
  %63 = load i64, ptr %62, align 8
  %64 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp19, i32 0, i32 0
  %65 = load i64, ptr %64, align 16
  %66 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp19, i32 0, i32 1
  %67 = load i64, ptr %66, align 8
  %call20 = call noundef zeroext i1 @_ZN4abslgtENS_7uint128ES0_(i64 %61, i64 %63, i64 %65, i64 %67)
  br i1 %call20, label %if.then21, label %if.end27

if.then21:                                        ; preds = %if.end5
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp23, ptr align 16 %value, i64 16, i1 false)
  call void @_ZN4absl7uint128C2Ei(ptr noundef nonnull align 16 dereferenceable(16) %agg.tmp24, i32 noundef 1)
  %68 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp23, i32 0, i32 0
  %69 = load i64, ptr %68, align 16
  %70 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp23, i32 0, i32 1
  %71 = load i64, ptr %70, align 8
  %72 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp24, i32 0, i32 0
  %73 = load i64, ptr %72, align 16
  %74 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp24, i32 0, i32 1
  %75 = load i64, ptr %74, align 8
  %call25 = call { i64, i64 } @_ZN4abslplENS_7uint128ES0_(i64 %69, i64 %71, i64 %73, i64 %75)
  %76 = getelementptr inbounds { i64, i64 }, ptr %ref.tmp22, i32 0, i32 0
  %77 = extractvalue { i64, i64 } %call25, 0
  store i64 %77, ptr %76, align 16
  %78 = getelementptr inbounds { i64, i64 }, ptr %ref.tmp22, i32 0, i32 1
  %79 = extractvalue { i64, i64 } %call25, 1
  store i64 %79, ptr %78, align 8
  %call26 = call noundef i64 @_ZNK4absl7uint128cvmEv(ptr noundef nonnull align 16 dereferenceable(16) %ref.tmp22)
  store i64 %call26, ptr %retval, align 8
  br label %return

if.end27:                                         ; preds = %if.end5
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp28, ptr align 16 %shifted_bits, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp29, ptr align 16 %halfway_point, i64 16, i1 false)
  %80 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp28, i32 0, i32 0
  %81 = load i64, ptr %80, align 16
  %82 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp28, i32 0, i32 1
  %83 = load i64, ptr %82, align 8
  %84 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp29, i32 0, i32 0
  %85 = load i64, ptr %84, align 16
  %86 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp29, i32 0, i32 1
  %87 = load i64, ptr %86, align 8
  %call30 = call noundef zeroext i1 @_ZN4absleqENS_7uint128ES0_(i64 %81, i64 %83, i64 %85, i64 %87)
  br i1 %call30, label %if.then31, label %if.end43

if.then31:                                        ; preds = %if.end27
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp33, ptr align 16 %value, i64 16, i1 false)
  call void @_ZN4absl7uint128C2Ei(ptr noundef nonnull align 16 dereferenceable(16) %agg.tmp34, i32 noundef 1)
  %88 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp33, i32 0, i32 0
  %89 = load i64, ptr %88, align 16
  %90 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp33, i32 0, i32 1
  %91 = load i64, ptr %90, align 8
  %92 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp34, i32 0, i32 0
  %93 = load i64, ptr %92, align 16
  %94 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp34, i32 0, i32 1
  %95 = load i64, ptr %94, align 8
  %call35 = call { i64, i64 } @_ZN4abslanENS_7uint128ES0_(i64 %89, i64 %91, i64 %93, i64 %95)
  %96 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp32, i32 0, i32 0
  %97 = extractvalue { i64, i64 } %call35, 0
  store i64 %97, ptr %96, align 16
  %98 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp32, i32 0, i32 1
  %99 = extractvalue { i64, i64 } %call35, 1
  store i64 %99, ptr %98, align 8
  call void @_ZN4absl7uint128C2Ei(ptr noundef nonnull align 16 dereferenceable(16) %agg.tmp36, i32 noundef 1)
  %100 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp32, i32 0, i32 0
  %101 = load i64, ptr %100, align 16
  %102 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp32, i32 0, i32 1
  %103 = load i64, ptr %102, align 8
  %104 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp36, i32 0, i32 0
  %105 = load i64, ptr %104, align 16
  %106 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp36, i32 0, i32 1
  %107 = load i64, ptr %106, align 8
  %call37 = call noundef zeroext i1 @_ZN4absleqENS_7uint128ES0_(i64 %101, i64 %103, i64 %105, i64 %107)
  br i1 %call37, label %if.then39, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then31
  %108 = load i8, ptr %input_exact.addr, align 1
  %tobool38 = trunc i8 %108 to i1
  br i1 %tobool38, label %if.end41, label %if.then39

if.then39:                                        ; preds = %lor.lhs.false, %if.then31
  %call40 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN4absl7uint128ppEv(ptr noundef nonnull align 16 dereferenceable(16) %value)
  br label %if.end41

if.end41:                                         ; preds = %if.then39, %lor.lhs.false
  %call42 = call noundef i64 @_ZNK4absl7uint128cvmEv(ptr noundef nonnull align 16 dereferenceable(16) %value)
  store i64 %call42, ptr %retval, align 8
  br label %return

if.end43:                                         ; preds = %if.end27
  %109 = load i8, ptr %input_exact.addr, align 1
  %tobool44 = trunc i8 %109 to i1
  br i1 %tobool44, label %if.end52, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end43
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp45, ptr align 16 %shifted_bits, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp47, ptr align 16 %halfway_point, i64 16, i1 false)
  call void @_ZN4absl7uint128C2Ei(ptr noundef nonnull align 16 dereferenceable(16) %agg.tmp48, i32 noundef 1)
  %110 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp47, i32 0, i32 0
  %111 = load i64, ptr %110, align 16
  %112 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp47, i32 0, i32 1
  %113 = load i64, ptr %112, align 8
  %114 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp48, i32 0, i32 0
  %115 = load i64, ptr %114, align 16
  %116 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp48, i32 0, i32 1
  %117 = load i64, ptr %116, align 8
  %call49 = call { i64, i64 } @_ZN4abslmiENS_7uint128ES0_(i64 %111, i64 %113, i64 %115, i64 %117)
  %118 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp46, i32 0, i32 0
  %119 = extractvalue { i64, i64 } %call49, 0
  store i64 %119, ptr %118, align 16
  %120 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp46, i32 0, i32 1
  %121 = extractvalue { i64, i64 } %call49, 1
  store i64 %121, ptr %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp45, i32 0, i32 0
  %123 = load i64, ptr %122, align 16
  %124 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp45, i32 0, i32 1
  %125 = load i64, ptr %124, align 8
  %126 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp46, i32 0, i32 0
  %127 = load i64, ptr %126, align 16
  %128 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp46, i32 0, i32 1
  %129 = load i64, ptr %128, align 8
  %call50 = call noundef zeroext i1 @_ZN4absleqENS_7uint128ES0_(i64 %123, i64 %125, i64 %127, i64 %129)
  br i1 %call50, label %if.then51, label %if.end52

if.then51:                                        ; preds = %land.lhs.true
  %130 = load ptr, ptr %output_exact.addr, align 8
  store i8 0, ptr %130, align 1
  br label %if.end52

if.end52:                                         ; preds = %if.then51, %land.lhs.true, %if.end43
  %call53 = call noundef i64 @_ZNK4absl7uint128cvmEv(ptr noundef nonnull align 16 dereferenceable(16) %value)
  store i64 %call53, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end52, %if.end41, %if.then21, %if.then4, %if.then
  %131 = load i64, ptr %retval, align 8
  ret i64 %131
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN4absl7uint128C2Em(ptr noundef nonnull align 16 dereferenceable(16) %this, i64 noundef %v) unnamed_addr #5 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %v.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %v, ptr %v.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %lo_ = getelementptr inbounds %"class.absl::uint128", ptr %this1, i32 0, i32 0
  %0 = load i64, ptr %v.addr, align 8
  store i64 %0, ptr %lo_, align 16
  %hi_ = getelementptr inbounds %"class.absl::uint128", ptr %this1, i32 0, i32 1
  store i64 0, ptr %hi_, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal { i64, i32 } @_ZN4absl12_GLOBAL__N_128CalculatedFloatFromRawValuesIdEENS0_15CalculatedFloatEmi(i64 noundef %mantissa, i32 noundef %exponent) #5 {
entry:
  %retval = alloca %"struct.absl::(anonymous namespace)::CalculatedFloat", align 8
  %mantissa.addr = alloca i64, align 8
  %exponent.addr = alloca i32, align 4
  store i64 %mantissa, ptr %mantissa.addr, align 8
  store i32 %exponent, ptr %exponent.addr, align 4
  call void @_ZN4absl12_GLOBAL__N_115CalculatedFloatC2Ev(ptr noundef nonnull align 8 dereferenceable(12) %retval) #3
  %0 = load i64, ptr %mantissa.addr, align 8
  %cmp = icmp eq i64 %0, 9007199254740992
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %mantissa.addr, align 8
  %shr = lshr i64 %1, 1
  store i64 %shr, ptr %mantissa.addr, align 8
  %2 = load i32, ptr %exponent.addr, align 4
  %add = add nsw i32 %2, 1
  store i32 %add, ptr %exponent.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %exponent.addr, align 4
  %cmp1 = icmp sgt i32 %3, 971
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  %exponent3 = getelementptr inbounds %"struct.absl::(anonymous namespace)::CalculatedFloat", ptr %retval, i32 0, i32 1
  store i32 99999, ptr %exponent3, align 8
  br label %if.end11

if.else:                                          ; preds = %if.end
  %4 = load i64, ptr %mantissa.addr, align 8
  %cmp4 = icmp eq i64 %4, 0
  br i1 %cmp4, label %if.then5, label %if.else7

if.then5:                                         ; preds = %if.else
  %exponent6 = getelementptr inbounds %"struct.absl::(anonymous namespace)::CalculatedFloat", ptr %retval, i32 0, i32 1
  store i32 -99999, ptr %exponent6, align 8
  br label %if.end10

if.else7:                                         ; preds = %if.else
  %5 = load i32, ptr %exponent.addr, align 4
  %exponent8 = getelementptr inbounds %"struct.absl::(anonymous namespace)::CalculatedFloat", ptr %retval, i32 0, i32 1
  store i32 %5, ptr %exponent8, align 8
  %6 = load i64, ptr %mantissa.addr, align 8
  %mantissa9 = getelementptr inbounds %"struct.absl::(anonymous namespace)::CalculatedFloat", ptr %retval, i32 0, i32 0
  store i64 %6, ptr %mantissa9, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.else7, %if.then5
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %if.then2
  %7 = load { i64, i32 }, ptr %retval, align 8
  ret { i64, i32 } %7
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZN4absl11countl_zeroImEENSt9enable_ifIXsr3std11is_unsignedIT_EE5valueEiE4typeES2_(i64 noundef %x) #5 comdat personality ptr @__gxx_personality_v0 {
entry:
  %x.addr.i1 = alloca i64, align 8
  %x.addr.i = alloca i64, align 8
  %x.addr = alloca i64, align 8
  store i64 %x, ptr %x.addr, align 8
  %0 = load i64, ptr %x.addr, align 8
  store i64 %0, ptr %x.addr.i, align 8
  %1 = load i64, ptr %x.addr.i, align 8
  store i64 %1, ptr %x.addr.i1, align 8
  %2 = load i64, ptr %x.addr.i1, align 8
  %cmp.i = icmp eq i64 %2, 0
  br i1 %cmp.i, label %cond.true.i, label %cond.false.i

cond.true.i:                                      ; preds = %entry
  br label %_ZN4absl16numeric_internal20CountLeadingZeroes64Em.exit

cond.false.i:                                     ; preds = %entry
  %3 = load i64, ptr %x.addr.i1, align 8
  %4 = call i64 @llvm.ctlz.i64(i64 %3, i1 true)
  %cast.i = trunc i64 %4 to i32
  br label %_ZN4absl16numeric_internal20CountLeadingZeroes64Em.exit

_ZN4absl16numeric_internal20CountLeadingZeroes64Em.exit: ; preds = %cond.false.i, %cond.true.i
  %cond.i = phi i32 [ 64, %cond.true.i ], [ %cast.i, %cond.false.i ]
  br label %invoke.cont

invoke.cont:                                      ; preds = %_ZN4absl16numeric_internal20CountLeadingZeroes64Em.exit
  ret i32 %cond.i

terminate.lpad:                                   ; No predecessors!
  %5 = landingpad { ptr, i32 }
          catch ptr null
  %6 = extractvalue { ptr, i32 } %5, 0
  call void @__clang_call_terminate(ptr %6) #11
  unreachable
}

declare i32 @__gxx_personality_v0(...)

; Function Attrs: noreturn nounwind uwtable
define linkonce_odr hidden void @__clang_call_terminate(ptr noundef %0) #8 comdat {
  %2 = call ptr @__cxa_begin_catch(ptr %0) #3
  call void @_ZSt9terminatev() #11
  unreachable
}

declare ptr @__cxa_begin_catch(ptr)

declare void @_ZSt9terminatev()

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.ctlz.i64(i64, i1 immarg) #9

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 4 dereferenceable(4) ptr @_ZSt3maxIiERKT_S2_S2_(ptr noundef nonnull align 4 dereferenceable(4) %__a, ptr noundef nonnull align 4 dereferenceable(4) %__b) #5 comdat {
entry:
  %retval = alloca ptr, align 8
  %__a.addr = alloca ptr, align 8
  %__b.addr = alloca ptr, align 8
  store ptr %__a, ptr %__a.addr, align 8
  store ptr %__b, ptr %__b.addr, align 8
  %0 = load ptr, ptr %__a.addr, align 8
  %1 = load i32, ptr %0, align 4
  %2 = load ptr, ptr %__b.addr, align 8
  %3 = load i32, ptr %2, align 4
  %cmp = icmp slt i32 %1, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %__b.addr, align 8
  store ptr %4, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %__a.addr, align 8
  store ptr %5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load ptr, ptr %retval, align 8
  ret ptr %6
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { i64, i64 } @_ZN4absllsENS_7uint128Ei(i64 %lhs.coerce0, i64 %lhs.coerce1, i32 noundef %amount) #4 comdat {
entry:
  %retval = alloca %"class.absl::uint128", align 16
  %lhs = alloca %"class.absl::uint128", align 16
  %amount.addr = alloca i32, align 4
  %coerce = alloca i128, align 16
  %coerce1 = alloca i128, align 16
  %0 = getelementptr inbounds { i64, i64 }, ptr %lhs, i32 0, i32 0
  store i64 %lhs.coerce0, ptr %0, align 16
  %1 = getelementptr inbounds { i64, i64 }, ptr %lhs, i32 0, i32 1
  store i64 %lhs.coerce1, ptr %1, align 8
  store i32 %amount, ptr %amount.addr, align 4
  %call = call noundef { i64, i64 } @_ZNK4absl7uint128cvoEv(ptr noundef nonnull align 16 dereferenceable(16) %lhs)
  %2 = getelementptr inbounds { i64, i64 }, ptr %coerce, i32 0, i32 0
  %3 = extractvalue { i64, i64 } %call, 0
  store i64 %3, ptr %2, align 16
  %4 = getelementptr inbounds { i64, i64 }, ptr %coerce, i32 0, i32 1
  %5 = extractvalue { i64, i64 } %call, 1
  store i64 %5, ptr %4, align 8
  %6 = load i128, ptr %coerce, align 16
  %7 = load i32, ptr %amount.addr, align 4
  %sh_prom = zext i32 %7 to i128
  %shl = shl i128 %6, %sh_prom
  store i128 %shl, ptr %coerce1, align 16
  %8 = getelementptr inbounds { i64, i64 }, ptr %coerce1, i32 0, i32 0
  %9 = load i64, ptr %8, align 16
  %10 = getelementptr inbounds { i64, i64 }, ptr %coerce1, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  call void @_ZN4absl7uint128C2Eo(ptr noundef nonnull align 16 dereferenceable(16) %retval, i64 noundef %9, i64 noundef %11)
  %12 = load { i64, i64 }, ptr %retval, align 16
  ret { i64, i64 } %12
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #6

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK4absl7uint128cvmEv(ptr noundef nonnull align 16 dereferenceable(16) %this) #5 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %lo_ = getelementptr inbounds %"class.absl::uint128", ptr %this1, i32 0, i32 0
  %0 = load i64, ptr %lo_, align 16
  ret i64 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { i64, i64 } @_ZN4abslmiENS_7uint128ES0_(i64 %lhs.coerce0, i64 %lhs.coerce1, i64 %rhs.coerce0, i64 %rhs.coerce1) #4 comdat {
entry:
  %retval = alloca %"class.absl::uint128", align 16
  %lhs = alloca %"class.absl::uint128", align 16
  %rhs = alloca %"class.absl::uint128", align 16
  %coerce = alloca i128, align 16
  %coerce2 = alloca i128, align 16
  %coerce3 = alloca i128, align 16
  %0 = getelementptr inbounds { i64, i64 }, ptr %lhs, i32 0, i32 0
  store i64 %lhs.coerce0, ptr %0, align 16
  %1 = getelementptr inbounds { i64, i64 }, ptr %lhs, i32 0, i32 1
  store i64 %lhs.coerce1, ptr %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, ptr %rhs, i32 0, i32 0
  store i64 %rhs.coerce0, ptr %2, align 16
  %3 = getelementptr inbounds { i64, i64 }, ptr %rhs, i32 0, i32 1
  store i64 %rhs.coerce1, ptr %3, align 8
  %call = call noundef { i64, i64 } @_ZNK4absl7uint128cvoEv(ptr noundef nonnull align 16 dereferenceable(16) %lhs)
  %4 = getelementptr inbounds { i64, i64 }, ptr %coerce, i32 0, i32 0
  %5 = extractvalue { i64, i64 } %call, 0
  store i64 %5, ptr %4, align 16
  %6 = getelementptr inbounds { i64, i64 }, ptr %coerce, i32 0, i32 1
  %7 = extractvalue { i64, i64 } %call, 1
  store i64 %7, ptr %6, align 8
  %8 = load i128, ptr %coerce, align 16
  %call1 = call noundef { i64, i64 } @_ZNK4absl7uint128cvoEv(ptr noundef nonnull align 16 dereferenceable(16) %rhs)
  %9 = getelementptr inbounds { i64, i64 }, ptr %coerce2, i32 0, i32 0
  %10 = extractvalue { i64, i64 } %call1, 0
  store i64 %10, ptr %9, align 16
  %11 = getelementptr inbounds { i64, i64 }, ptr %coerce2, i32 0, i32 1
  %12 = extractvalue { i64, i64 } %call1, 1
  store i64 %12, ptr %11, align 8
  %13 = load i128, ptr %coerce2, align 16
  %sub = sub i128 %8, %13
  store i128 %sub, ptr %coerce3, align 16
  %14 = getelementptr inbounds { i64, i64 }, ptr %coerce3, i32 0, i32 0
  %15 = load i64, ptr %14, align 16
  %16 = getelementptr inbounds { i64, i64 }, ptr %coerce3, i32 0, i32 1
  %17 = load i64, ptr %16, align 8
  call void @_ZN4absl7uint128C2Eo(ptr noundef nonnull align 16 dereferenceable(16) %retval, i64 noundef %15, i64 noundef %17)
  %18 = load { i64, i64 }, ptr %retval, align 16
  ret { i64, i64 } %18
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN4absl7uint128C2Ei(ptr noundef nonnull align 16 dereferenceable(16) %this, i32 noundef %v) unnamed_addr #5 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %v.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %v, ptr %v.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %lo_ = getelementptr inbounds %"class.absl::uint128", ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %v.addr, align 4
  %conv = sext i32 %0 to i64
  store i64 %conv, ptr %lo_, align 16
  %hi_ = getelementptr inbounds %"class.absl::uint128", ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %v.addr, align 4
  %cmp = icmp slt i32 %1, 0
  %call = call noundef i64 @_ZNSt14numeric_limitsImE3maxEv() #3
  %cond = select i1 %cmp, i64 %call, i64 0
  store i64 %cond, ptr %hi_, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { i64, i64 } @_ZN4abslanENS_7uint128ES0_(i64 %lhs.coerce0, i64 %lhs.coerce1, i64 %rhs.coerce0, i64 %rhs.coerce1) #4 comdat {
entry:
  %retval = alloca %"class.absl::uint128", align 16
  %lhs = alloca %"class.absl::uint128", align 16
  %rhs = alloca %"class.absl::uint128", align 16
  %coerce = alloca i128, align 16
  %coerce2 = alloca i128, align 16
  %coerce3 = alloca i128, align 16
  %0 = getelementptr inbounds { i64, i64 }, ptr %lhs, i32 0, i32 0
  store i64 %lhs.coerce0, ptr %0, align 16
  %1 = getelementptr inbounds { i64, i64 }, ptr %lhs, i32 0, i32 1
  store i64 %lhs.coerce1, ptr %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, ptr %rhs, i32 0, i32 0
  store i64 %rhs.coerce0, ptr %2, align 16
  %3 = getelementptr inbounds { i64, i64 }, ptr %rhs, i32 0, i32 1
  store i64 %rhs.coerce1, ptr %3, align 8
  %call = call noundef { i64, i64 } @_ZNK4absl7uint128cvoEv(ptr noundef nonnull align 16 dereferenceable(16) %lhs)
  %4 = getelementptr inbounds { i64, i64 }, ptr %coerce, i32 0, i32 0
  %5 = extractvalue { i64, i64 } %call, 0
  store i64 %5, ptr %4, align 16
  %6 = getelementptr inbounds { i64, i64 }, ptr %coerce, i32 0, i32 1
  %7 = extractvalue { i64, i64 } %call, 1
  store i64 %7, ptr %6, align 8
  %8 = load i128, ptr %coerce, align 16
  %call1 = call noundef { i64, i64 } @_ZNK4absl7uint128cvoEv(ptr noundef nonnull align 16 dereferenceable(16) %rhs)
  %9 = getelementptr inbounds { i64, i64 }, ptr %coerce2, i32 0, i32 0
  %10 = extractvalue { i64, i64 } %call1, 0
  store i64 %10, ptr %9, align 16
  %11 = getelementptr inbounds { i64, i64 }, ptr %coerce2, i32 0, i32 1
  %12 = extractvalue { i64, i64 } %call1, 1
  store i64 %12, ptr %11, align 8
  %13 = load i128, ptr %coerce2, align 16
  %and = and i128 %8, %13
  store i128 %and, ptr %coerce3, align 16
  %14 = getelementptr inbounds { i64, i64 }, ptr %coerce3, i32 0, i32 0
  %15 = load i64, ptr %14, align 16
  %16 = getelementptr inbounds { i64, i64 }, ptr %coerce3, i32 0, i32 1
  %17 = load i64, ptr %16, align 8
  call void @_ZN4absl7uint128C2Eo(ptr noundef nonnull align 16 dereferenceable(16) %retval, i64 noundef %15, i64 noundef %17)
  %18 = load { i64, i64 }, ptr %retval, align 16
  ret { i64, i64 } %18
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(16) ptr @_ZN4absl7uint128rSEi(ptr noundef nonnull align 16 dereferenceable(16) %this, i32 noundef %amount) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %amount.addr = alloca i32, align 4
  %ref.tmp = alloca %"class.absl::uint128", align 16
  %agg.tmp = alloca %"class.absl::uint128", align 16
  store ptr %this, ptr %this.addr, align 8
  store i32 %amount, ptr %amount.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp, ptr align 16 %this1, i64 16, i1 false)
  %0 = load i32, ptr %amount.addr, align 4
  %1 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 0
  %2 = load i64, ptr %1, align 16
  %3 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 1
  %4 = load i64, ptr %3, align 8
  %call = call { i64, i64 } @_ZN4abslrsENS_7uint128Ei(i64 %2, i64 %4, i32 noundef %0)
  %5 = getelementptr inbounds { i64, i64 }, ptr %ref.tmp, i32 0, i32 0
  %6 = extractvalue { i64, i64 } %call, 0
  store i64 %6, ptr %5, align 16
  %7 = getelementptr inbounds { i64, i64 }, ptr %ref.tmp, i32 0, i32 1
  %8 = extractvalue { i64, i64 } %call, 1
  store i64 %8, ptr %7, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %this1, ptr align 16 %ref.tmp, i64 16, i1 false)
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN4abslgtENS_7uint128ES0_(i64 %lhs.coerce0, i64 %lhs.coerce1, i64 %rhs.coerce0, i64 %rhs.coerce1) #4 comdat {
entry:
  %lhs = alloca %"class.absl::uint128", align 16
  %rhs = alloca %"class.absl::uint128", align 16
  %agg.tmp = alloca %"class.absl::uint128", align 16
  %agg.tmp1 = alloca %"class.absl::uint128", align 16
  %0 = getelementptr inbounds { i64, i64 }, ptr %lhs, i32 0, i32 0
  store i64 %lhs.coerce0, ptr %0, align 16
  %1 = getelementptr inbounds { i64, i64 }, ptr %lhs, i32 0, i32 1
  store i64 %lhs.coerce1, ptr %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, ptr %rhs, i32 0, i32 0
  store i64 %rhs.coerce0, ptr %2, align 16
  %3 = getelementptr inbounds { i64, i64 }, ptr %rhs, i32 0, i32 1
  store i64 %rhs.coerce1, ptr %3, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp, ptr align 16 %rhs, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp1, ptr align 16 %lhs, i64 16, i1 false)
  %4 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load i64, ptr %4, align 16
  %6 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp1, i32 0, i32 0
  %9 = load i64, ptr %8, align 16
  %10 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp1, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  %call = call noundef zeroext i1 @_ZN4abslltENS_7uint128ES0_(i64 %5, i64 %7, i64 %9, i64 %11)
  ret i1 %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { i64, i64 } @_ZN4abslplENS_7uint128ES0_(i64 %lhs.coerce0, i64 %lhs.coerce1, i64 %rhs.coerce0, i64 %rhs.coerce1) #4 comdat {
entry:
  %retval = alloca %"class.absl::uint128", align 16
  %lhs = alloca %"class.absl::uint128", align 16
  %rhs = alloca %"class.absl::uint128", align 16
  %coerce = alloca i128, align 16
  %coerce2 = alloca i128, align 16
  %coerce3 = alloca i128, align 16
  %0 = getelementptr inbounds { i64, i64 }, ptr %lhs, i32 0, i32 0
  store i64 %lhs.coerce0, ptr %0, align 16
  %1 = getelementptr inbounds { i64, i64 }, ptr %lhs, i32 0, i32 1
  store i64 %lhs.coerce1, ptr %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, ptr %rhs, i32 0, i32 0
  store i64 %rhs.coerce0, ptr %2, align 16
  %3 = getelementptr inbounds { i64, i64 }, ptr %rhs, i32 0, i32 1
  store i64 %rhs.coerce1, ptr %3, align 8
  %call = call noundef { i64, i64 } @_ZNK4absl7uint128cvoEv(ptr noundef nonnull align 16 dereferenceable(16) %lhs)
  %4 = getelementptr inbounds { i64, i64 }, ptr %coerce, i32 0, i32 0
  %5 = extractvalue { i64, i64 } %call, 0
  store i64 %5, ptr %4, align 16
  %6 = getelementptr inbounds { i64, i64 }, ptr %coerce, i32 0, i32 1
  %7 = extractvalue { i64, i64 } %call, 1
  store i64 %7, ptr %6, align 8
  %8 = load i128, ptr %coerce, align 16
  %call1 = call noundef { i64, i64 } @_ZNK4absl7uint128cvoEv(ptr noundef nonnull align 16 dereferenceable(16) %rhs)
  %9 = getelementptr inbounds { i64, i64 }, ptr %coerce2, i32 0, i32 0
  %10 = extractvalue { i64, i64 } %call1, 0
  store i64 %10, ptr %9, align 16
  %11 = getelementptr inbounds { i64, i64 }, ptr %coerce2, i32 0, i32 1
  %12 = extractvalue { i64, i64 } %call1, 1
  store i64 %12, ptr %11, align 8
  %13 = load i128, ptr %coerce2, align 16
  %add = add i128 %8, %13
  store i128 %add, ptr %coerce3, align 16
  %14 = getelementptr inbounds { i64, i64 }, ptr %coerce3, i32 0, i32 0
  %15 = load i64, ptr %14, align 16
  %16 = getelementptr inbounds { i64, i64 }, ptr %coerce3, i32 0, i32 1
  %17 = load i64, ptr %16, align 8
  call void @_ZN4absl7uint128C2Eo(ptr noundef nonnull align 16 dereferenceable(16) %retval, i64 noundef %15, i64 noundef %17)
  %18 = load { i64, i64 }, ptr %retval, align 16
  ret { i64, i64 } %18
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN4absleqENS_7uint128ES0_(i64 %lhs.coerce0, i64 %lhs.coerce1, i64 %rhs.coerce0, i64 %rhs.coerce1) #5 comdat {
entry:
  %lhs = alloca %"class.absl::uint128", align 16
  %rhs = alloca %"class.absl::uint128", align 16
  %coerce = alloca i128, align 16
  %coerce2 = alloca i128, align 16
  %0 = getelementptr inbounds { i64, i64 }, ptr %lhs, i32 0, i32 0
  store i64 %lhs.coerce0, ptr %0, align 16
  %1 = getelementptr inbounds { i64, i64 }, ptr %lhs, i32 0, i32 1
  store i64 %lhs.coerce1, ptr %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, ptr %rhs, i32 0, i32 0
  store i64 %rhs.coerce0, ptr %2, align 16
  %3 = getelementptr inbounds { i64, i64 }, ptr %rhs, i32 0, i32 1
  store i64 %rhs.coerce1, ptr %3, align 8
  %call = call noundef { i64, i64 } @_ZNK4absl7uint128cvoEv(ptr noundef nonnull align 16 dereferenceable(16) %lhs)
  %4 = getelementptr inbounds { i64, i64 }, ptr %coerce, i32 0, i32 0
  %5 = extractvalue { i64, i64 } %call, 0
  store i64 %5, ptr %4, align 16
  %6 = getelementptr inbounds { i64, i64 }, ptr %coerce, i32 0, i32 1
  %7 = extractvalue { i64, i64 } %call, 1
  store i64 %7, ptr %6, align 8
  %8 = load i128, ptr %coerce, align 16
  %call1 = call noundef { i64, i64 } @_ZNK4absl7uint128cvoEv(ptr noundef nonnull align 16 dereferenceable(16) %rhs)
  %9 = getelementptr inbounds { i64, i64 }, ptr %coerce2, i32 0, i32 0
  %10 = extractvalue { i64, i64 } %call1, 0
  store i64 %10, ptr %9, align 16
  %11 = getelementptr inbounds { i64, i64 }, ptr %coerce2, i32 0, i32 1
  %12 = extractvalue { i64, i64 } %call1, 1
  store i64 %12, ptr %11, align 8
  %13 = load i128, ptr %coerce2, align 16
  %cmp = icmp eq i128 %8, %13
  ret i1 %cmp
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(16) ptr @_ZN4absl7uint128ppEv(ptr noundef nonnull align 16 dereferenceable(16) %this) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.absl::uint128", align 16
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4absl7uint128C2Ei(ptr noundef nonnull align 16 dereferenceable(16) %agg.tmp, i32 noundef 1)
  %0 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 0
  %1 = load i64, ptr %0, align 16
  %2 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 1
  %3 = load i64, ptr %2, align 8
  %call = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN4absl7uint128pLES0_(ptr noundef nonnull align 16 dereferenceable(16) %this1, i64 %1, i64 %3)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef { i64, i64 } @_ZNK4absl7uint128cvoEv(ptr noundef nonnull align 16 dereferenceable(16) %this) #5 comdat align 2 {
entry:
  %retval = alloca i128, align 16
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %hi_ = getelementptr inbounds %"class.absl::uint128", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %hi_, align 8
  %conv = zext i64 %0 to i128
  %shl = shl i128 %conv, 64
  %lo_ = getelementptr inbounds %"class.absl::uint128", ptr %this1, i32 0, i32 0
  %1 = load i64, ptr %lo_, align 16
  %conv2 = zext i64 %1 to i128
  %add = add i128 %shl, %conv2
  store i128 %add, ptr %retval, align 16
  %2 = load { i64, i64 }, ptr %retval, align 16
  ret { i64, i64 } %2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN4absl7uint128C2Eo(ptr noundef nonnull align 16 dereferenceable(16) %this, i64 noundef %v.coerce0, i64 noundef %v.coerce1) unnamed_addr #5 comdat align 2 {
entry:
  %v = alloca i128, align 16
  %this.addr = alloca ptr, align 8
  %v.addr = alloca i128, align 16
  %0 = getelementptr inbounds { i64, i64 }, ptr %v, i32 0, i32 0
  store i64 %v.coerce0, ptr %0, align 16
  %1 = getelementptr inbounds { i64, i64 }, ptr %v, i32 0, i32 1
  store i64 %v.coerce1, ptr %1, align 8
  %v1 = load i128, ptr %v, align 16
  store ptr %this, ptr %this.addr, align 8
  store i128 %v1, ptr %v.addr, align 16
  %this2 = load ptr, ptr %this.addr, align 8
  %lo_ = getelementptr inbounds %"class.absl::uint128", ptr %this2, i32 0, i32 0
  %2 = load i128, ptr %v.addr, align 16
  %and = and i128 %2, 18446744073709551615
  %conv = trunc i128 %and to i64
  store i64 %conv, ptr %lo_, align 16
  %hi_ = getelementptr inbounds %"class.absl::uint128", ptr %this2, i32 0, i32 1
  %3 = load i128, ptr %v.addr, align 16
  %shr = lshr i128 %3, 64
  %conv3 = trunc i128 %shr to i64
  store i64 %conv3, ptr %hi_, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNSt14numeric_limitsImE3maxEv() #5 comdat align 2 {
entry:
  ret i64 -1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { i64, i64 } @_ZN4abslrsENS_7uint128Ei(i64 %lhs.coerce0, i64 %lhs.coerce1, i32 noundef %amount) #4 comdat {
entry:
  %retval = alloca %"class.absl::uint128", align 16
  %lhs = alloca %"class.absl::uint128", align 16
  %amount.addr = alloca i32, align 4
  %coerce = alloca i128, align 16
  %coerce1 = alloca i128, align 16
  %0 = getelementptr inbounds { i64, i64 }, ptr %lhs, i32 0, i32 0
  store i64 %lhs.coerce0, ptr %0, align 16
  %1 = getelementptr inbounds { i64, i64 }, ptr %lhs, i32 0, i32 1
  store i64 %lhs.coerce1, ptr %1, align 8
  store i32 %amount, ptr %amount.addr, align 4
  %call = call noundef { i64, i64 } @_ZNK4absl7uint128cvoEv(ptr noundef nonnull align 16 dereferenceable(16) %lhs)
  %2 = getelementptr inbounds { i64, i64 }, ptr %coerce, i32 0, i32 0
  %3 = extractvalue { i64, i64 } %call, 0
  store i64 %3, ptr %2, align 16
  %4 = getelementptr inbounds { i64, i64 }, ptr %coerce, i32 0, i32 1
  %5 = extractvalue { i64, i64 } %call, 1
  store i64 %5, ptr %4, align 8
  %6 = load i128, ptr %coerce, align 16
  %7 = load i32, ptr %amount.addr, align 4
  %sh_prom = zext i32 %7 to i128
  %shr = lshr i128 %6, %sh_prom
  store i128 %shr, ptr %coerce1, align 16
  %8 = getelementptr inbounds { i64, i64 }, ptr %coerce1, i32 0, i32 0
  %9 = load i64, ptr %8, align 16
  %10 = getelementptr inbounds { i64, i64 }, ptr %coerce1, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  call void @_ZN4absl7uint128C2Eo(ptr noundef nonnull align 16 dereferenceable(16) %retval, i64 noundef %9, i64 noundef %11)
  %12 = load { i64, i64 }, ptr %retval, align 16
  ret { i64, i64 } %12
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN4abslltENS_7uint128ES0_(i64 %lhs.coerce0, i64 %lhs.coerce1, i64 %rhs.coerce0, i64 %rhs.coerce1) #5 comdat {
entry:
  %lhs = alloca %"class.absl::uint128", align 16
  %rhs = alloca %"class.absl::uint128", align 16
  %coerce = alloca i128, align 16
  %coerce2 = alloca i128, align 16
  %0 = getelementptr inbounds { i64, i64 }, ptr %lhs, i32 0, i32 0
  store i64 %lhs.coerce0, ptr %0, align 16
  %1 = getelementptr inbounds { i64, i64 }, ptr %lhs, i32 0, i32 1
  store i64 %lhs.coerce1, ptr %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, ptr %rhs, i32 0, i32 0
  store i64 %rhs.coerce0, ptr %2, align 16
  %3 = getelementptr inbounds { i64, i64 }, ptr %rhs, i32 0, i32 1
  store i64 %rhs.coerce1, ptr %3, align 8
  %call = call noundef { i64, i64 } @_ZNK4absl7uint128cvoEv(ptr noundef nonnull align 16 dereferenceable(16) %lhs)
  %4 = getelementptr inbounds { i64, i64 }, ptr %coerce, i32 0, i32 0
  %5 = extractvalue { i64, i64 } %call, 0
  store i64 %5, ptr %4, align 16
  %6 = getelementptr inbounds { i64, i64 }, ptr %coerce, i32 0, i32 1
  %7 = extractvalue { i64, i64 } %call, 1
  store i64 %7, ptr %6, align 8
  %8 = load i128, ptr %coerce, align 16
  %call1 = call noundef { i64, i64 } @_ZNK4absl7uint128cvoEv(ptr noundef nonnull align 16 dereferenceable(16) %rhs)
  %9 = getelementptr inbounds { i64, i64 }, ptr %coerce2, i32 0, i32 0
  %10 = extractvalue { i64, i64 } %call1, 0
  store i64 %10, ptr %9, align 16
  %11 = getelementptr inbounds { i64, i64 }, ptr %coerce2, i32 0, i32 1
  %12 = extractvalue { i64, i64 } %call1, 1
  store i64 %12, ptr %11, align 8
  %13 = load i128, ptr %coerce2, align 16
  %cmp = icmp ult i128 %8, %13
  ret i1 %cmp
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(16) ptr @_ZN4absl7uint128pLES0_(ptr noundef nonnull align 16 dereferenceable(16) %this, i64 %other.coerce0, i64 %other.coerce1) #4 comdat align 2 {
entry:
  %other = alloca %"class.absl::uint128", align 16
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.absl::uint128", align 16
  %agg.tmp = alloca %"class.absl::uint128", align 16
  %agg.tmp2 = alloca %"class.absl::uint128", align 16
  %0 = getelementptr inbounds { i64, i64 }, ptr %other, i32 0, i32 0
  store i64 %other.coerce0, ptr %0, align 16
  %1 = getelementptr inbounds { i64, i64 }, ptr %other, i32 0, i32 1
  store i64 %other.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp, ptr align 16 %this1, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp2, ptr align 16 %other, i64 16, i1 false)
  %2 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 0
  %3 = load i64, ptr %2, align 16
  %4 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 1
  %5 = load i64, ptr %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp2, i32 0, i32 0
  %7 = load i64, ptr %6, align 16
  %8 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp2, i32 0, i32 1
  %9 = load i64, ptr %8, align 8
  %call = call { i64, i64 } @_ZN4abslplENS_7uint128ES0_(i64 %3, i64 %5, i64 %7, i64 %9)
  %10 = getelementptr inbounds { i64, i64 }, ptr %ref.tmp, i32 0, i32 0
  %11 = extractvalue { i64, i64 } %call, 0
  store i64 %11, ptr %10, align 16
  %12 = getelementptr inbounds { i64, i64 }, ptr %ref.tmp, i32 0, i32 1
  %13 = extractvalue { i64, i64 } %call, 1
  store i64 %13, ptr %12, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %this1, ptr align 16 %ref.tmp, i64 16, i1 false)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZN4absl12_GLOBAL__N_115CalculatedFloatC2Ev(ptr noundef nonnull align 8 dereferenceable(12) %this) unnamed_addr #5 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mantissa = getelementptr inbounds %"struct.absl::(anonymous namespace)::CalculatedFloat", ptr %this1, i32 0, i32 0
  store i64 0, ptr %mantissa, align 8
  %exponent = getelementptr inbounds %"struct.absl::(anonymous namespace)::CalculatedFloat", ptr %this1, i32 0, i32 1
  store i32 0, ptr %exponent, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef double @_ZNSt14numeric_limitsIdE3maxEv() #5 comdat align 2 {
entry:
  ret double 0x7FEFFFFFFFFFFFFF
}

; Function Attrs: mustprogress uwtable
define internal noundef double @_ZN4absl12_GLOBAL__N_111FloatTraitsIdE4MakeEmib(i64 noundef %mantissa, i32 noundef %exponent, i1 noundef zeroext %sign) #4 align 2 {
entry:
  %mantissa.addr = alloca i64, align 8
  %exponent.addr = alloca i32, align 4
  %sign.addr = alloca i8, align 1
  %kMantissaMask = alloca i64, align 8
  %dbl = alloca i64, align 8
  store i64 %mantissa, ptr %mantissa.addr, align 8
  store i32 %exponent, ptr %exponent.addr, align 4
  %frombool = zext i1 %sign to i8
  store i8 %frombool, ptr %sign.addr, align 1
  store i64 4503599627370495, ptr %kMantissaMask, align 8
  %0 = load i8, ptr %sign.addr, align 1
  %tobool = trunc i8 %0 to i1
  %conv = zext i1 %tobool to i64
  %shl = shl i64 %conv, 63
  store i64 %shl, ptr %dbl, align 8
  %1 = load i64, ptr %mantissa.addr, align 8
  %cmp = icmp ugt i64 %1, 4503599627370495
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %exponent.addr, align 4
  %add = add nsw i32 %2, 1023
  %add1 = add nsw i32 %add, 53
  %sub = sub nsw i32 %add1, 1
  %conv2 = sext i32 %sub to i64
  %shl3 = shl i64 %conv2, 52
  %3 = load i64, ptr %dbl, align 8
  %add4 = add i64 %3, %shl3
  store i64 %add4, ptr %dbl, align 8
  %4 = load i64, ptr %mantissa.addr, align 8
  %and = and i64 %4, 4503599627370495
  store i64 %and, ptr %mantissa.addr, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %5 = load i64, ptr %mantissa.addr, align 8
  %6 = load i64, ptr %dbl, align 8
  %add5 = add i64 %6, %5
  store i64 %add5, ptr %dbl, align 8
  %call = call noundef double @_ZN4absl8bit_castIdmTnNSt9enable_ifIXaaaaeqstT_stT0_sr3std21is_trivially_copyableIS3_EE5valuesr3std21is_trivially_copyableIS2_EE5valueEiE4typeELi0EEES2_RKS3_(ptr noundef nonnull align 8 dereferenceable(8) %dbl)
  ret double %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef double @_ZN4absl8bit_castIdmTnNSt9enable_ifIXaaaaeqstT_stT0_sr3std21is_trivially_copyableIS3_EE5valuesr3std21is_trivially_copyableIS2_EE5valueEiE4typeELi0EEES2_RKS3_(ptr noundef nonnull align 8 dereferenceable(8) %source) #5 comdat {
entry:
  %source.addr = alloca ptr, align 8
  store ptr %source, ptr %source.addr, align 8
  %0 = load ptr, ptr %source.addr, align 8
  %1 = load double, ptr %0, align 8
  ret double %1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { i64, i64 } @_ZN4abslmlENS_7uint128ES0_(i64 %lhs.coerce0, i64 %lhs.coerce1, i64 %rhs.coerce0, i64 %rhs.coerce1) #4 comdat {
entry:
  %retval = alloca %"class.absl::uint128", align 16
  %lhs = alloca %"class.absl::uint128", align 16
  %rhs = alloca %"class.absl::uint128", align 16
  %coerce = alloca i128, align 16
  %coerce2 = alloca i128, align 16
  %coerce3 = alloca i128, align 16
  %0 = getelementptr inbounds { i64, i64 }, ptr %lhs, i32 0, i32 0
  store i64 %lhs.coerce0, ptr %0, align 16
  %1 = getelementptr inbounds { i64, i64 }, ptr %lhs, i32 0, i32 1
  store i64 %lhs.coerce1, ptr %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, ptr %rhs, i32 0, i32 0
  store i64 %rhs.coerce0, ptr %2, align 16
  %3 = getelementptr inbounds { i64, i64 }, ptr %rhs, i32 0, i32 1
  store i64 %rhs.coerce1, ptr %3, align 8
  %call = call noundef { i64, i64 } @_ZNK4absl7uint128cvoEv(ptr noundef nonnull align 16 dereferenceable(16) %lhs)
  %4 = getelementptr inbounds { i64, i64 }, ptr %coerce, i32 0, i32 0
  %5 = extractvalue { i64, i64 } %call, 0
  store i64 %5, ptr %4, align 16
  %6 = getelementptr inbounds { i64, i64 }, ptr %coerce, i32 0, i32 1
  %7 = extractvalue { i64, i64 } %call, 1
  store i64 %7, ptr %6, align 8
  %8 = load i128, ptr %coerce, align 16
  %call1 = call noundef { i64, i64 } @_ZNK4absl7uint128cvoEv(ptr noundef nonnull align 16 dereferenceable(16) %rhs)
  %9 = getelementptr inbounds { i64, i64 }, ptr %coerce2, i32 0, i32 0
  %10 = extractvalue { i64, i64 } %call1, 0
  store i64 %10, ptr %9, align 16
  %11 = getelementptr inbounds { i64, i64 }, ptr %coerce2, i32 0, i32 1
  %12 = extractvalue { i64, i64 } %call1, 1
  store i64 %12, ptr %11, align 8
  %13 = load i128, ptr %coerce2, align 16
  %mul = mul i128 %8, %13
  store i128 %mul, ptr %coerce3, align 16
  %14 = getelementptr inbounds { i64, i64 }, ptr %coerce3, i32 0, i32 0
  %15 = load i64, ptr %14, align 16
  %16 = getelementptr inbounds { i64, i64 }, ptr %coerce3, i32 0, i32 1
  %17 = load i64, ptr %16, align 8
  call void @_ZN4absl7uint128C2Eo(ptr noundef nonnull align 16 dereferenceable(16) %retval, i64 noundef %15, i64 noundef %17)
  %18 = load { i64, i64 }, ptr %retval, align 16
  ret { i64, i64 } %18
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZN4absl13Uint128High64ENS_7uint128E(i64 %v.coerce0, i64 %v.coerce1) #5 comdat {
entry:
  %v = alloca %"class.absl::uint128", align 16
  %0 = getelementptr inbounds { i64, i64 }, ptr %v, i32 0, i32 0
  store i64 %v.coerce0, ptr %0, align 16
  %1 = getelementptr inbounds { i64, i64 }, ptr %v, i32 0, i32 1
  store i64 %v.coerce1, ptr %1, align 8
  %hi_ = getelementptr inbounds %"class.absl::uint128", ptr %v, i32 0, i32 1
  %2 = load i64, ptr %hi_, align 8
  ret i64 %2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZN4absl12Uint128Low64ENS_7uint128E(i64 %v.coerce0, i64 %v.coerce1) #5 comdat {
entry:
  %v = alloca %"class.absl::uint128", align 16
  %0 = getelementptr inbounds { i64, i64 }, ptr %v, i32 0, i32 0
  store i64 %v.coerce0, ptr %0, align 16
  %1 = getelementptr inbounds { i64, i64 }, ptr %v, i32 0, i32 1
  store i64 %v.coerce1, ptr %1, align 8
  %lo_ = getelementptr inbounds %"class.absl::uint128", ptr %v, i32 0, i32 0
  %2 = load i64, ptr %lo_, align 16
  ret i64 %2
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef zeroext i1 @_ZN4absl12_GLOBAL__N_116Power10UnderflowEi(i32 noundef %n) #5 {
entry:
  %n.addr = alloca i32, align 4
  store i32 %n, ptr %n.addr, align 4
  %0 = load i32, ptr %n.addr, align 4
  %cmp = icmp slt i32 %0, -342
  ret i1 %cmp
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef zeroext i1 @_ZN4absl12_GLOBAL__N_115Power10OverflowEi(i32 noundef %n) #5 {
entry:
  %n.addr = alloca i32, align 4
  store i32 %n, ptr %n.addr, align 4
  %0 = load i32, ptr %n.addr, align 4
  %cmp = icmp sge i32 %0, 309
  ret i1 %cmp
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i64 @_ZN4absl12_GLOBAL__N_115Power10MantissaEi(i32 noundef %n) #5 {
entry:
  %n.addr = alloca i32, align 4
  store i32 %n, ptr %n.addr, align 4
  %0 = load i32, ptr %n.addr, align 4
  %sub = sub nsw i32 %0, -342
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [0 x i64], ptr @_ZN4absl12_GLOBAL__N_125kPower10MantissaHighTableE, i64 0, i64 %idxprom
  %1 = load i64, ptr %arrayidx, align 8
  ret i64 %1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 16 dereferenceable(16) ptr @_ZN4absl7uint128mLES0_(ptr noundef nonnull align 16 dereferenceable(16) %this, i64 %other.coerce0, i64 %other.coerce1) #4 comdat align 2 {
entry:
  %other = alloca %"class.absl::uint128", align 16
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.absl::uint128", align 16
  %agg.tmp = alloca %"class.absl::uint128", align 16
  %agg.tmp2 = alloca %"class.absl::uint128", align 16
  %0 = getelementptr inbounds { i64, i64 }, ptr %other, i32 0, i32 0
  store i64 %other.coerce0, ptr %0, align 16
  %1 = getelementptr inbounds { i64, i64 }, ptr %other, i32 0, i32 1
  store i64 %other.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp, ptr align 16 %this1, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp2, ptr align 16 %other, i64 16, i1 false)
  %2 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 0
  %3 = load i64, ptr %2, align 16
  %4 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 1
  %5 = load i64, ptr %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp2, i32 0, i32 0
  %7 = load i64, ptr %6, align 16
  %8 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp2, i32 0, i32 1
  %9 = load i64, ptr %8, align 8
  %call = call { i64, i64 } @_ZN4abslmlENS_7uint128ES0_(i64 %3, i64 %5, i64 %7, i64 %9)
  %10 = getelementptr inbounds { i64, i64 }, ptr %ref.tmp, i32 0, i32 0
  %11 = extractvalue { i64, i64 } %call, 0
  store i64 %11, ptr %10, align 16
  %12 = getelementptr inbounds { i64, i64 }, ptr %ref.tmp, i32 0, i32 1
  %13 = extractvalue { i64, i64 } %call, 1
  store i64 %13, ptr %12, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %this1, ptr align 16 %ref.tmp, i64 16, i1 false)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZN4absl12_GLOBAL__N_115Power10ExponentEi(i32 noundef %n) #5 {
entry:
  %n.addr = alloca i32, align 4
  store i32 %n, ptr %n.addr, align 4
  %0 = load i32, ptr %n.addr, align 4
  %mul = mul nsw i32 217706, %0
  %shr = ashr i32 %mul, 16
  %sub = sub nsw i32 %shr, 63
  ret i32 %sub
}

; Function Attrs: mustprogress uwtable
define internal noundef i32 @_ZN4absl12_GLOBAL__N_118TruncateToBitWidthEiPNS_7uint128E(i32 noundef %bit_width, ptr noundef %value) #4 {
entry:
  %bit_width.addr = alloca i32, align 4
  %value.addr = alloca ptr, align 8
  %current_bit_width = alloca i32, align 4
  %agg.tmp = alloca %"class.absl::uint128", align 16
  %shift = alloca i32, align 4
  store i32 %bit_width, ptr %bit_width.addr, align 4
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %value.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp, ptr align 16 %0, i64 16, i1 false)
  %1 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 0
  %2 = load i64, ptr %1, align 16
  %3 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 1
  %4 = load i64, ptr %3, align 8
  %call = call noundef i32 @_ZN4absl12_GLOBAL__N_18BitWidthENS_7uint128E(i64 %2, i64 %4)
  store i32 %call, ptr %current_bit_width, align 4
  %5 = load i32, ptr %current_bit_width, align 4
  %6 = load i32, ptr %bit_width.addr, align 4
  %sub = sub nsw i32 %5, %6
  store i32 %sub, ptr %shift, align 4
  %7 = load i32, ptr %shift, align 4
  %8 = load ptr, ptr %value.addr, align 8
  %call1 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN4absl7uint128rSEi(ptr noundef nonnull align 16 dereferenceable(16) %8, i32 noundef %7)
  %9 = load i32, ptr %shift, align 4
  ret i32 %9
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef zeroext i1 @_ZN4absl12_GLOBAL__N_112Power10ExactEi(i32 noundef %n) #5 {
entry:
  %n.addr = alloca i32, align 4
  store i32 %n, ptr %n.addr, align 4
  %0 = load i32, ptr %n.addr, align 4
  %cmp = icmp sge i32 %0, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load i32, ptr %n.addr, align 4
  %cmp1 = icmp sle i32 %1, 27
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %cmp1, %land.rhs ]
  ret i1 %2
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZN4absl12_GLOBAL__N_18BitWidthENS_7uint128E(i64 %value.coerce0, i64 %value.coerce1) #5 {
entry:
  %retval = alloca i32, align 4
  %value = alloca %"class.absl::uint128", align 16
  %agg.tmp = alloca %"class.absl::uint128", align 16
  %agg.tmp1 = alloca %"class.absl::uint128", align 16
  %agg.tmp4 = alloca %"class.absl::uint128", align 16
  %0 = getelementptr inbounds { i64, i64 }, ptr %value, i32 0, i32 0
  store i64 %value.coerce0, ptr %0, align 16
  %1 = getelementptr inbounds { i64, i64 }, ptr %value, i32 0, i32 1
  store i64 %value.coerce1, ptr %1, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp, ptr align 16 %value, i64 16, i1 false)
  %2 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 0
  %3 = load i64, ptr %2, align 16
  %4 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 1
  %5 = load i64, ptr %4, align 8
  %call = call noundef i64 @_ZN4absl13Uint128High64ENS_7uint128E(i64 %3, i64 %5)
  %cmp = icmp eq i64 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp1, ptr align 16 %value, i64 16, i1 false)
  %6 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp1, i32 0, i32 0
  %7 = load i64, ptr %6, align 16
  %8 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp1, i32 0, i32 1
  %9 = load i64, ptr %8, align 8
  %call2 = call noundef i64 @_ZN4absl12Uint128Low64ENS_7uint128E(i64 %7, i64 %9)
  %call3 = call noundef i32 @_ZN4absl9bit_widthImEENSt9enable_ifIXsr3std11is_unsignedIT_EE5valueEiE4typeES2_(i64 noundef %call2) #3
  store i32 %call3, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp4, ptr align 16 %value, i64 16, i1 false)
  %10 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp4, i32 0, i32 0
  %11 = load i64, ptr %10, align 16
  %12 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp4, i32 0, i32 1
  %13 = load i64, ptr %12, align 8
  %call5 = call noundef i64 @_ZN4absl13Uint128High64ENS_7uint128E(i64 %11, i64 %13)
  %call6 = call noundef i32 @_ZN4absl11countl_zeroImEENSt9enable_ifIXsr3std11is_unsignedIT_EE5valueEiE4typeES2_(i64 noundef %call5) #3
  %sub = sub nsw i32 128, %call6
  store i32 %sub, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %14 = load i32, ptr %retval, align 4
  ret i32 %14
}

; Function Attrs: mustprogress uwtable
define internal noundef zeroext i1 @_ZN4absl12_GLOBAL__N_111MustRoundUpEmiRKNS_16strings_internal11ParsedFloatE(i64 noundef %guess_mantissa, i32 noundef %guess_exponent, ptr noundef nonnull align 8 dereferenceable(48) %parsed_decimal) #4 {
entry:
  %retval = alloca i1, align 1
  %guess_mantissa.addr = alloca i64, align 8
  %guess_exponent.addr = alloca i32, align 4
  %parsed_decimal.addr = alloca ptr, align 8
  %exact_mantissa = alloca %"class.absl::strings_internal::BigUnsigned", align 4
  %exact_exponent = alloca i32, align 4
  %lhs = alloca ptr, align 8
  %comparison = alloca i32, align 4
  %rhs = alloca %"class.absl::strings_internal::BigUnsigned", align 4
  %rhs7 = alloca %"class.absl::strings_internal::BigUnsigned", align 4
  store i64 %guess_mantissa, ptr %guess_mantissa.addr, align 8
  store i32 %guess_exponent, ptr %guess_exponent.addr, align 4
  store ptr %parsed_decimal, ptr %parsed_decimal.addr, align 8
  call void @_ZN4absl16strings_internal11BigUnsignedILi84EEC1Ev(ptr noundef nonnull align 4 dereferenceable(340) %exact_mantissa)
  %0 = load ptr, ptr %parsed_decimal.addr, align 8
  %call = call noundef i32 @_ZN4absl16strings_internal11BigUnsignedILi84EE17ReadFloatMantissaERKNS0_11ParsedFloatEi(ptr noundef nonnull align 4 dereferenceable(340) %exact_mantissa, ptr noundef nonnull align 8 dereferenceable(48) %0, i32 noundef 768)
  store i32 %call, ptr %exact_exponent, align 4
  %1 = load i64, ptr %guess_mantissa.addr, align 8
  %mul = mul i64 %1, 2
  %add = add i64 %mul, 1
  store i64 %add, ptr %guess_mantissa.addr, align 8
  %2 = load i32, ptr %guess_exponent.addr, align 4
  %sub = sub nsw i32 %2, 1
  store i32 %sub, ptr %guess_exponent.addr, align 4
  store ptr %exact_mantissa, ptr %lhs, align 8
  %3 = load i32, ptr %exact_exponent, align 4
  %cmp = icmp sge i32 %3, 0
  br i1 %cmp, label %if.then, label %if.else6

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %lhs, align 8
  %5 = load i32, ptr %exact_exponent, align 4
  call void @_ZN4absl16strings_internal11BigUnsignedILi84EE22MultiplyByFiveToTheNthEi(ptr noundef nonnull align 4 dereferenceable(340) %4, i32 noundef %5)
  %6 = load i64, ptr %guess_mantissa.addr, align 8
  call void @_ZN4absl16strings_internal11BigUnsignedILi84EEC1Em(ptr noundef nonnull align 4 dereferenceable(340) %rhs, i64 noundef %6)
  %7 = load i32, ptr %exact_exponent, align 4
  %8 = load i32, ptr %guess_exponent.addr, align 4
  %cmp1 = icmp sgt i32 %7, %8
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %9 = load ptr, ptr %lhs, align 8
  %10 = load i32, ptr %exact_exponent, align 4
  %11 = load i32, ptr %guess_exponent.addr, align 4
  %sub3 = sub nsw i32 %10, %11
  call void @_ZN4absl16strings_internal11BigUnsignedILi84EE9ShiftLeftEi(ptr noundef nonnull align 4 dereferenceable(340) %9, i32 noundef %sub3)
  br label %if.end

if.else:                                          ; preds = %if.then
  %12 = load i32, ptr %guess_exponent.addr, align 4
  %13 = load i32, ptr %exact_exponent, align 4
  %sub4 = sub nsw i32 %12, %13
  call void @_ZN4absl16strings_internal11BigUnsignedILi84EE9ShiftLeftEi(ptr noundef nonnull align 4 dereferenceable(340) %rhs, i32 noundef %sub4)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then2
  %14 = load ptr, ptr %lhs, align 8
  %call5 = call noundef i32 @_ZN4absl16strings_internal7CompareILi84ELi84EEEiRKNS0_11BigUnsignedIXT_EEERKNS2_IXT0_EEE(ptr noundef nonnull align 4 dereferenceable(340) %14, ptr noundef nonnull align 4 dereferenceable(340) %rhs)
  store i32 %call5, ptr %comparison, align 4
  br label %if.end16

if.else6:                                         ; preds = %entry
  %15 = load i32, ptr %exact_exponent, align 4
  %sub8 = sub nsw i32 0, %15
  call void @_ZN4absl16strings_internal11BigUnsignedILi84EE12FiveToTheNthEi(ptr sret(%"class.absl::strings_internal::BigUnsigned") align 4 %rhs7, i32 noundef %sub8)
  %16 = load i64, ptr %guess_mantissa.addr, align 8
  call void @_ZN4absl16strings_internal11BigUnsignedILi84EE10MultiplyByEm(ptr noundef nonnull align 4 dereferenceable(340) %rhs7, i64 noundef %16)
  %17 = load i32, ptr %exact_exponent, align 4
  %18 = load i32, ptr %guess_exponent.addr, align 4
  %cmp9 = icmp sgt i32 %17, %18
  br i1 %cmp9, label %if.then10, label %if.else12

if.then10:                                        ; preds = %if.else6
  %19 = load ptr, ptr %lhs, align 8
  %20 = load i32, ptr %exact_exponent, align 4
  %21 = load i32, ptr %guess_exponent.addr, align 4
  %sub11 = sub nsw i32 %20, %21
  call void @_ZN4absl16strings_internal11BigUnsignedILi84EE9ShiftLeftEi(ptr noundef nonnull align 4 dereferenceable(340) %19, i32 noundef %sub11)
  br label %if.end14

if.else12:                                        ; preds = %if.else6
  %22 = load i32, ptr %guess_exponent.addr, align 4
  %23 = load i32, ptr %exact_exponent, align 4
  %sub13 = sub nsw i32 %22, %23
  call void @_ZN4absl16strings_internal11BigUnsignedILi84EE9ShiftLeftEi(ptr noundef nonnull align 4 dereferenceable(340) %rhs7, i32 noundef %sub13)
  br label %if.end14

if.end14:                                         ; preds = %if.else12, %if.then10
  %24 = load ptr, ptr %lhs, align 8
  %call15 = call noundef i32 @_ZN4absl16strings_internal7CompareILi84ELi84EEEiRKNS0_11BigUnsignedIXT_EEERKNS2_IXT0_EEE(ptr noundef nonnull align 4 dereferenceable(340) %24, ptr noundef nonnull align 4 dereferenceable(340) %rhs7)
  store i32 %call15, ptr %comparison, align 4
  br label %if.end16

if.end16:                                         ; preds = %if.end14, %if.end
  %25 = load i32, ptr %comparison, align 4
  %cmp17 = icmp slt i32 %25, 0
  br i1 %cmp17, label %if.then18, label %if.else19

if.then18:                                        ; preds = %if.end16
  store i1 false, ptr %retval, align 1
  br label %return

if.else19:                                        ; preds = %if.end16
  %26 = load i32, ptr %comparison, align 4
  %cmp20 = icmp sgt i32 %26, 0
  br i1 %cmp20, label %if.then21, label %if.else22

if.then21:                                        ; preds = %if.else19
  store i1 true, ptr %retval, align 1
  br label %return

if.else22:                                        ; preds = %if.else19
  %27 = load i64, ptr %guess_mantissa.addr, align 8
  %and = and i64 %27, 2
  %cmp23 = icmp eq i64 %and, 2
  store i1 %cmp23, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.else22, %if.then21, %if.then18
  %28 = load i1, ptr %retval, align 1
  ret i1 %28
}

declare void @_ZN4absl16strings_internal11BigUnsignedILi84EEC1Ev(ptr noundef nonnull align 4 dereferenceable(340)) unnamed_addr #1

declare noundef i32 @_ZN4absl16strings_internal11BigUnsignedILi84EE17ReadFloatMantissaERKNS0_11ParsedFloatEi(ptr noundef nonnull align 4 dereferenceable(340), ptr noundef nonnull align 8 dereferenceable(48), i32 noundef) #1

declare void @_ZN4absl16strings_internal11BigUnsignedILi84EE22MultiplyByFiveToTheNthEi(ptr noundef nonnull align 4 dereferenceable(340), i32 noundef) #1

declare void @_ZN4absl16strings_internal11BigUnsignedILi84EEC1Em(ptr noundef nonnull align 4 dereferenceable(340), i64 noundef) unnamed_addr #1

declare void @_ZN4absl16strings_internal11BigUnsignedILi84EE9ShiftLeftEi(ptr noundef nonnull align 4 dereferenceable(340), i32 noundef) #1

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i32 @_ZN4absl16strings_internal7CompareILi84ELi84EEEiRKNS0_11BigUnsignedIXT_EEERKNS2_IXT0_EEE(ptr noundef nonnull align 4 dereferenceable(340) %lhs, ptr noundef nonnull align 4 dereferenceable(340) %rhs) #4 comdat {
entry:
  %retval = alloca i32, align 4
  %lhs.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  %limit = alloca i32, align 4
  %ref.tmp = alloca i32, align 4
  %ref.tmp1 = alloca i32, align 4
  %i = alloca i32, align 4
  %lhs_word = alloca i32, align 4
  %rhs_word = alloca i32, align 4
  store ptr %lhs, ptr %lhs.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %0 = load ptr, ptr %lhs.addr, align 8
  %call = call noundef i32 @_ZNK4absl16strings_internal11BigUnsignedILi84EE4sizeEv(ptr noundef nonnull align 4 dereferenceable(340) %0)
  store i32 %call, ptr %ref.tmp, align 4
  %1 = load ptr, ptr %rhs.addr, align 8
  %call2 = call noundef i32 @_ZNK4absl16strings_internal11BigUnsignedILi84EE4sizeEv(ptr noundef nonnull align 4 dereferenceable(340) %1)
  store i32 %call2, ptr %ref.tmp1, align 4
  %call3 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZSt3maxIiERKT_S2_S2_(ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp1)
  %2 = load i32, ptr %call3, align 4
  store i32 %2, ptr %limit, align 4
  %3 = load i32, ptr %limit, align 4
  %sub = sub nsw i32 %3, 1
  store i32 %sub, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load i32, ptr %i, align 4
  %cmp = icmp sge i32 %4, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %lhs.addr, align 8
  %6 = load i32, ptr %i, align 4
  %call4 = call noundef i32 @_ZNK4absl16strings_internal11BigUnsignedILi84EE7GetWordEi(ptr noundef nonnull align 4 dereferenceable(340) %5, i32 noundef %6)
  store i32 %call4, ptr %lhs_word, align 4
  %7 = load ptr, ptr %rhs.addr, align 8
  %8 = load i32, ptr %i, align 4
  %call5 = call noundef i32 @_ZNK4absl16strings_internal11BigUnsignedILi84EE7GetWordEi(ptr noundef nonnull align 4 dereferenceable(340) %7, i32 noundef %8)
  store i32 %call5, ptr %rhs_word, align 4
  %9 = load i32, ptr %lhs_word, align 4
  %10 = load i32, ptr %rhs_word, align 4
  %cmp6 = icmp ult i32 %9, %10
  br i1 %cmp6, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  store i32 -1, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %for.body
  %11 = load i32, ptr %lhs_word, align 4
  %12 = load i32, ptr %rhs_word, align 4
  %cmp7 = icmp ugt i32 %11, %12
  br i1 %cmp7, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.else
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end9

if.end9:                                          ; preds = %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end9
  %13 = load i32, ptr %i, align 4
  %dec = add nsw i32 %13, -1
  store i32 %dec, ptr %i, align 4
  br label %for.cond, !llvm.loop !5

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then8, %if.then
  %14 = load i32, ptr %retval, align 4
  ret i32 %14
}

declare void @_ZN4absl16strings_internal11BigUnsignedILi84EE12FiveToTheNthEi(ptr sret(%"class.absl::strings_internal::BigUnsigned") align 4, i32 noundef) #1

declare void @_ZN4absl16strings_internal11BigUnsignedILi84EE10MultiplyByEm(ptr noundef nonnull align 4 dereferenceable(340), i64 noundef) #1

declare noundef i32 @_ZNK4absl16strings_internal11BigUnsignedILi84EE4sizeEv(ptr noundef nonnull align 4 dereferenceable(340)) #1

declare noundef i32 @_ZNK4absl16strings_internal11BigUnsignedILi84EE7GetWordEi(ptr noundef nonnull align 4 dereferenceable(340), i32 noundef) #1

; Function Attrs: mustprogress uwtable
define internal noundef zeroext i1 @_ZN4absl12_GLOBAL__N_114HandleEdgeCaseIfEEbRKNS_16strings_internal11ParsedFloatEbPT_(ptr noundef nonnull align 8 dereferenceable(48) %input, i1 noundef zeroext %negative, ptr noundef %value) #4 {
entry:
  %retval = alloca i1, align 1
  %input.addr = alloca ptr, align 8
  %negative.addr = alloca i8, align 1
  %value.addr = alloca ptr, align 8
  %kNanBufferSize = alloca i64, align 8
  %n_char_sequence = alloca [128 x i8], align 16
  %nan_size = alloca i64, align 8
  %ref.tmp = alloca i64, align 8
  %nan_argument = alloca ptr, align 8
  store ptr %input, ptr %input.addr, align 8
  %frombool = zext i1 %negative to i8
  store i8 %frombool, ptr %negative.addr, align 1
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %input.addr, align 8
  %type = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %0, i32 0, i32 3
  %1 = load i32, ptr %type, align 8
  %cmp = icmp eq i32 %1, 2
  br i1 %cmp, label %if.then, label %if.end10

if.then:                                          ; preds = %entry
  store i64 128, ptr %kNanBufferSize, align 8
  %2 = load ptr, ptr %input.addr, align 8
  %subrange_begin = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %2, i32 0, i32 4
  %3 = load ptr, ptr %subrange_begin, align 8
  %cmp1 = icmp eq ptr %3, null
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %arrayidx = getelementptr inbounds [128 x i8], ptr %n_char_sequence, i64 0, i64 0
  store i8 0, ptr %arrayidx, align 16
  br label %if.end

if.else:                                          ; preds = %if.then
  %4 = load ptr, ptr %input.addr, align 8
  %subrange_end = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %4, i32 0, i32 5
  %5 = load ptr, ptr %subrange_end, align 8
  %6 = load ptr, ptr %input.addr, align 8
  %subrange_begin3 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %6, i32 0, i32 4
  %7 = load ptr, ptr %subrange_begin3, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %5 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %7 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %nan_size, align 8
  store i64 127, ptr %ref.tmp, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZSt3minIlERKT_S2_S2_(ptr noundef nonnull align 8 dereferenceable(8) %nan_size, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp)
  %8 = load i64, ptr %call, align 8
  store i64 %8, ptr %nan_size, align 8
  %9 = load ptr, ptr %input.addr, align 8
  %subrange_begin4 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %9, i32 0, i32 4
  %10 = load ptr, ptr %subrange_begin4, align 8
  %11 = load i64, ptr %nan_size, align 8
  %arraydecay = getelementptr inbounds [128 x i8], ptr %n_char_sequence, i64 0, i64 0
  %call5 = call noundef ptr @_ZSt6copy_nIPKclPcET1_T_T0_S3_(ptr noundef %10, i64 noundef %11, ptr noundef %arraydecay)
  %12 = load i64, ptr %nan_size, align 8
  %arrayidx6 = getelementptr inbounds [128 x i8], ptr %n_char_sequence, i64 0, i64 %12
  store i8 0, ptr %arrayidx6, align 1
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then2
  %arraydecay7 = getelementptr inbounds [128 x i8], ptr %n_char_sequence, i64 0, i64 0
  store ptr %arraydecay7, ptr %nan_argument, align 8
  %13 = load i8, ptr %negative.addr, align 1
  %tobool = trunc i8 %13 to i1
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %14 = load ptr, ptr %nan_argument, align 8
  %call8 = call noundef float @_ZN4absl12_GLOBAL__N_111FloatTraitsIfE7MakeNanEPKc(ptr noundef %14)
  %fneg = fneg float %call8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %15 = load ptr, ptr %nan_argument, align 8
  %call9 = call noundef float @_ZN4absl12_GLOBAL__N_111FloatTraitsIfE7MakeNanEPKc(ptr noundef %15)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %fneg, %cond.true ], [ %call9, %cond.false ]
  %16 = load ptr, ptr %value.addr, align 8
  store float %cond, ptr %16, align 4
  store i1 true, ptr %retval, align 1
  br label %return

if.end10:                                         ; preds = %entry
  %17 = load ptr, ptr %input.addr, align 8
  %type11 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %17, i32 0, i32 3
  %18 = load i32, ptr %type11, align 8
  %cmp12 = icmp eq i32 %18, 1
  br i1 %cmp12, label %if.then13, label %if.end19

if.then13:                                        ; preds = %if.end10
  %19 = load i8, ptr %negative.addr, align 1
  %tobool14 = trunc i8 %19 to i1
  %call15 = call noundef float @_ZNSt14numeric_limitsIfE8infinityEv() #3
  %fneg16 = fneg float %call15
  %call17 = call noundef float @_ZNSt14numeric_limitsIfE8infinityEv() #3
  %cond18 = select i1 %tobool14, float %fneg16, float %call17
  %20 = load ptr, ptr %value.addr, align 8
  store float %cond18, ptr %20, align 4
  store i1 true, ptr %retval, align 1
  br label %return

if.end19:                                         ; preds = %if.end10
  %21 = load ptr, ptr %input.addr, align 8
  %mantissa = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %21, i32 0, i32 0
  %22 = load i64, ptr %mantissa, align 8
  %cmp20 = icmp eq i64 %22, 0
  br i1 %cmp20, label %if.then21, label %if.end24

if.then21:                                        ; preds = %if.end19
  %23 = load i8, ptr %negative.addr, align 1
  %tobool22 = trunc i8 %23 to i1
  %cond23 = select i1 %tobool22, double -0.000000e+00, double 0.000000e+00
  %conv = fptrunc double %cond23 to float
  %24 = load ptr, ptr %value.addr, align 8
  store float %conv, ptr %24, align 4
  store i1 true, ptr %retval, align 1
  br label %return

if.end24:                                         ; preds = %if.end19
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end24, %if.then21, %if.then13, %cond.end
  %25 = load i1, ptr %retval, align 1
  ret i1 %25
}

; Function Attrs: mustprogress uwtable
define internal { i64, i32 } @_ZN4absl12_GLOBAL__N_130CalculateFromParsedHexadecimalIfEENS0_15CalculatedFloatERKNS_16strings_internal11ParsedFloatE(ptr noundef nonnull align 8 dereferenceable(48) %parsed_hex) #4 {
entry:
  %retval = alloca %"struct.absl::(anonymous namespace)::CalculatedFloat", align 8
  %parsed_hex.addr = alloca ptr, align 8
  %mantissa = alloca i64, align 8
  %exponent = alloca i32, align 4
  %mantissa_width = alloca i32, align 4
  %shift = alloca i32, align 4
  %result_exact = alloca i8, align 1
  %agg.tmp = alloca %"class.absl::uint128", align 16
  store ptr %parsed_hex, ptr %parsed_hex.addr, align 8
  %0 = load ptr, ptr %parsed_hex.addr, align 8
  %mantissa1 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %0, i32 0, i32 0
  %1 = load i64, ptr %mantissa1, align 8
  store i64 %1, ptr %mantissa, align 8
  %2 = load ptr, ptr %parsed_hex.addr, align 8
  %exponent2 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %2, i32 0, i32 1
  %3 = load i32, ptr %exponent2, align 8
  store i32 %3, ptr %exponent, align 4
  %4 = load i64, ptr %mantissa, align 8
  %call = call noundef i32 @_ZN4absl9bit_widthImEENSt9enable_ifIXsr3std11is_unsignedIT_EE5valueEiE4typeES2_(i64 noundef %4) #3
  store i32 %call, ptr %mantissa_width, align 4
  %5 = load i32, ptr %mantissa_width, align 4
  %6 = load i32, ptr %exponent, align 4
  %call3 = call noundef i32 @_ZN4absl12_GLOBAL__N_119NormalizedShiftSizeIfEEiii(i32 noundef %5, i32 noundef %6)
  store i32 %call3, ptr %shift, align 4
  %7 = load i32, ptr %shift, align 4
  %8 = load i32, ptr %exponent, align 4
  %add = add nsw i32 %8, %7
  store i32 %add, ptr %exponent, align 4
  %9 = load i64, ptr %mantissa, align 8
  call void @_ZN4absl7uint128C2Em(ptr noundef nonnull align 16 dereferenceable(16) %agg.tmp, i64 noundef %9)
  %10 = load i32, ptr %shift, align 4
  %11 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 0
  %12 = load i64, ptr %11, align 16
  %13 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 1
  %14 = load i64, ptr %13, align 8
  %call4 = call noundef i64 @_ZN4absl12_GLOBAL__N_118ShiftRightAndRoundENS_7uint128EibPb(i64 %12, i64 %14, i32 noundef %10, i1 noundef zeroext true, ptr noundef %result_exact)
  store i64 %call4, ptr %mantissa, align 8
  %15 = load i64, ptr %mantissa, align 8
  %16 = load i32, ptr %exponent, align 4
  %call5 = call { i64, i32 } @_ZN4absl12_GLOBAL__N_128CalculatedFloatFromRawValuesIfEENS0_15CalculatedFloatEmi(i64 noundef %15, i32 noundef %16)
  %17 = getelementptr inbounds { i64, i32 }, ptr %retval, i32 0, i32 0
  %18 = extractvalue { i64, i32 } %call5, 0
  store i64 %18, ptr %17, align 8
  %19 = getelementptr inbounds { i64, i32 }, ptr %retval, i32 0, i32 1
  %20 = extractvalue { i64, i32 } %call5, 1
  store i32 %20, ptr %19, align 8
  %21 = load { i64, i32 }, ptr %retval, align 8
  ret { i64, i32 } %21
}

; Function Attrs: mustprogress uwtable
define internal void @_ZN4absl12_GLOBAL__N_112EncodeResultIfEEvRKNS0_15CalculatedFloatEbPNS_17from_chars_resultEPT_(ptr noundef nonnull align 8 dereferenceable(12) %calculated, i1 noundef zeroext %negative, ptr noundef %result, ptr noundef %value) #4 {
entry:
  %calculated.addr = alloca ptr, align 8
  %negative.addr = alloca i8, align 1
  %result.addr = alloca ptr, align 8
  %value.addr = alloca ptr, align 8
  store ptr %calculated, ptr %calculated.addr, align 8
  %frombool = zext i1 %negative to i8
  store i8 %frombool, ptr %negative.addr, align 1
  store ptr %result, ptr %result.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %calculated.addr, align 8
  %exponent = getelementptr inbounds %"struct.absl::(anonymous namespace)::CalculatedFloat", ptr %0, i32 0, i32 1
  %1 = load i32, ptr %exponent, align 8
  %cmp = icmp eq i32 %1, 99999
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %result.addr, align 8
  %ec = getelementptr inbounds %"struct.absl::from_chars_result", ptr %2, i32 0, i32 1
  store i32 34, ptr %ec, align 8
  %3 = load i8, ptr %negative.addr, align 1
  %tobool = trunc i8 %3 to i1
  %call = call noundef float @_ZNSt14numeric_limitsIfE3maxEv() #3
  %fneg = fneg float %call
  %call1 = call noundef float @_ZNSt14numeric_limitsIfE3maxEv() #3
  %cond = select i1 %tobool, float %fneg, float %call1
  %4 = load ptr, ptr %value.addr, align 8
  store float %cond, ptr %4, align 4
  br label %return

if.else:                                          ; preds = %entry
  %5 = load ptr, ptr %calculated.addr, align 8
  %mantissa = getelementptr inbounds %"struct.absl::(anonymous namespace)::CalculatedFloat", ptr %5, i32 0, i32 0
  %6 = load i64, ptr %mantissa, align 8
  %cmp2 = icmp eq i64 %6, 0
  br i1 %cmp2, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %7 = load ptr, ptr %calculated.addr, align 8
  %exponent3 = getelementptr inbounds %"struct.absl::(anonymous namespace)::CalculatedFloat", ptr %7, i32 0, i32 1
  %8 = load i32, ptr %exponent3, align 8
  %cmp4 = icmp eq i32 %8, -99999
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %lor.lhs.false, %if.else
  %9 = load ptr, ptr %result.addr, align 8
  %ec6 = getelementptr inbounds %"struct.absl::from_chars_result", ptr %9, i32 0, i32 1
  store i32 34, ptr %ec6, align 8
  %10 = load i8, ptr %negative.addr, align 1
  %tobool7 = trunc i8 %10 to i1
  %cond8 = select i1 %tobool7, double -0.000000e+00, double 0.000000e+00
  %conv = fptrunc double %cond8 to float
  %11 = load ptr, ptr %value.addr, align 8
  store float %conv, ptr %11, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  br label %if.end9

if.end9:                                          ; preds = %if.end
  %12 = load ptr, ptr %calculated.addr, align 8
  %mantissa10 = getelementptr inbounds %"struct.absl::(anonymous namespace)::CalculatedFloat", ptr %12, i32 0, i32 0
  %13 = load i64, ptr %mantissa10, align 8
  %conv11 = trunc i64 %13 to i32
  %14 = load ptr, ptr %calculated.addr, align 8
  %exponent12 = getelementptr inbounds %"struct.absl::(anonymous namespace)::CalculatedFloat", ptr %14, i32 0, i32 1
  %15 = load i32, ptr %exponent12, align 8
  %16 = load i8, ptr %negative.addr, align 1
  %tobool13 = trunc i8 %16 to i1
  %call14 = call noundef float @_ZN4absl12_GLOBAL__N_111FloatTraitsIfE4MakeEjib(i32 noundef %conv11, i32 noundef %15, i1 noundef zeroext %tobool13)
  %17 = load ptr, ptr %value.addr, align 8
  store float %call14, ptr %17, align 4
  br label %return

return:                                           ; preds = %if.end9, %if.then5, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define internal noundef zeroext i1 @_ZN4absl12_GLOBAL__N_111EiselLemireIfEEbRKNS_16strings_internal11ParsedFloatEbPT_PSt4errc(ptr noundef nonnull align 8 dereferenceable(48) %input, i1 noundef zeroext %negative, ptr noundef %value, ptr noundef %ec) #4 {
entry:
  %retval = alloca i1, align 1
  %input.addr = alloca ptr, align 8
  %negative.addr = alloca i8, align 1
  %value.addr = alloca ptr, align 8
  %ec.addr = alloca ptr, align 8
  %man = alloca i64, align 8
  %exp10 = alloca i32, align 4
  %clz = alloca i32, align 4
  %ret_exp2 = alloca i64, align 8
  %x = alloca %"class.absl::uint128", align 16
  %agg.tmp = alloca %"class.absl::uint128", align 16
  %agg.tmp10 = alloca %"class.absl::uint128", align 16
  %agg.tmp13 = alloca %"class.absl::uint128", align 16
  %agg.tmp17 = alloca %"class.absl::uint128", align 16
  %y = alloca %"class.absl::uint128", align 16
  %agg.tmp22 = alloca %"class.absl::uint128", align 16
  %agg.tmp23 = alloca %"class.absl::uint128", align 16
  %agg.tmp28 = alloca %"class.absl::uint128", align 16
  %agg.tmp29 = alloca %"class.absl::uint128", align 16
  %agg.tmp32 = alloca %"class.absl::uint128", align 16
  %agg.tmp37 = alloca %"class.absl::uint128", align 16
  %agg.tmp43 = alloca %"class.absl::uint128", align 16
  %msb = alloca i64, align 8
  %agg.tmp50 = alloca %"class.absl::uint128", align 16
  %ret_man = alloca i64, align 8
  %agg.tmp53 = alloca %"class.absl::uint128", align 16
  %agg.tmp58 = alloca %"class.absl::uint128", align 16
  %agg.tmp62 = alloca %"class.absl::uint128", align 16
  %ret_bits = alloca i32, align 4
  store ptr %input, ptr %input.addr, align 8
  %frombool = zext i1 %negative to i8
  store i8 %frombool, ptr %negative.addr, align 1
  store ptr %value, ptr %value.addr, align 8
  store ptr %ec, ptr %ec.addr, align 8
  %0 = load ptr, ptr %input.addr, align 8
  %mantissa = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %0, i32 0, i32 0
  %1 = load i64, ptr %mantissa, align 8
  store i64 %1, ptr %man, align 8
  %2 = load ptr, ptr %input.addr, align 8
  %exponent = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %2, i32 0, i32 1
  %3 = load i32, ptr %exponent, align 8
  store i32 %3, ptr %exp10, align 4
  %4 = load i32, ptr %exp10, align 4
  %cmp = icmp slt i32 %4, -64
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = load i8, ptr %negative.addr, align 1
  %tobool = trunc i8 %5 to i1
  %cond = select i1 %tobool, double -0.000000e+00, double 0.000000e+00
  %conv = fptrunc double %cond to float
  %6 = load ptr, ptr %value.addr, align 8
  store float %conv, ptr %6, align 4
  %7 = load ptr, ptr %ec.addr, align 8
  store i32 34, ptr %7, align 4
  store i1 true, ptr %retval, align 1
  br label %return

if.else:                                          ; preds = %entry
  %8 = load i32, ptr %exp10, align 4
  %cmp1 = icmp sge i32 %8, 39
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  %9 = load i8, ptr %negative.addr, align 1
  %tobool3 = trunc i8 %9 to i1
  %call = call noundef float @_ZNSt14numeric_limitsIfE3maxEv() #3
  %fneg = fneg float %call
  %call4 = call noundef float @_ZNSt14numeric_limitsIfE3maxEv() #3
  %cond5 = select i1 %tobool3, float %fneg, float %call4
  %10 = load ptr, ptr %value.addr, align 8
  store float %cond5, ptr %10, align 4
  %11 = load ptr, ptr %ec.addr, align 8
  store i32 34, ptr %11, align 4
  store i1 true, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end6

if.end6:                                          ; preds = %if.end
  %12 = load i64, ptr %man, align 8
  %call7 = call noundef i32 @_ZN4absl11countl_zeroImEENSt9enable_ifIXsr3std11is_unsignedIT_EE5valueEiE4typeES2_(i64 noundef %12) #3
  store i32 %call7, ptr %clz, align 4
  %13 = load i32, ptr %clz, align 4
  %14 = load i64, ptr %man, align 8
  %sh_prom = zext i32 %13 to i64
  %shl = shl i64 %14, %sh_prom
  store i64 %shl, ptr %man, align 8
  %15 = load i32, ptr %exp10, align 4
  %mul = mul nsw i32 217706, %15
  %shr = ashr i32 %mul, 16
  %add = add nsw i32 %shr, 64
  %add8 = add nsw i32 %add, 127
  %16 = load i32, ptr %clz, align 4
  %sub = sub nsw i32 %add8, %16
  %conv9 = sext i32 %sub to i64
  store i64 %conv9, ptr %ret_exp2, align 8
  %17 = load i64, ptr %man, align 8
  call void @_ZN4absl7uint128C2Em(ptr noundef nonnull align 16 dereferenceable(16) %agg.tmp, i64 noundef %17)
  %18 = load i32, ptr %exp10, align 4
  %sub11 = sub nsw i32 %18, -342
  %idxprom = sext i32 %sub11 to i64
  %arrayidx = getelementptr inbounds [0 x i64], ptr @_ZN4absl12_GLOBAL__N_125kPower10MantissaHighTableE, i64 0, i64 %idxprom
  %19 = load i64, ptr %arrayidx, align 8
  call void @_ZN4absl7uint128C2Em(ptr noundef nonnull align 16 dereferenceable(16) %agg.tmp10, i64 noundef %19)
  %20 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 0
  %21 = load i64, ptr %20, align 16
  %22 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 1
  %23 = load i64, ptr %22, align 8
  %24 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp10, i32 0, i32 0
  %25 = load i64, ptr %24, align 16
  %26 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp10, i32 0, i32 1
  %27 = load i64, ptr %26, align 8
  %call12 = call { i64, i64 } @_ZN4abslmlENS_7uint128ES0_(i64 %21, i64 %23, i64 %25, i64 %27)
  %28 = getelementptr inbounds { i64, i64 }, ptr %x, i32 0, i32 0
  %29 = extractvalue { i64, i64 } %call12, 0
  store i64 %29, ptr %28, align 16
  %30 = getelementptr inbounds { i64, i64 }, ptr %x, i32 0, i32 1
  %31 = extractvalue { i64, i64 } %call12, 1
  store i64 %31, ptr %30, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp13, ptr align 16 %x, i64 16, i1 false)
  %32 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp13, i32 0, i32 0
  %33 = load i64, ptr %32, align 16
  %34 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp13, i32 0, i32 1
  %35 = load i64, ptr %34, align 8
  %call14 = call noundef i64 @_ZN4absl13Uint128High64ENS_7uint128E(i64 %33, i64 %35)
  %and = and i64 %call14, 274877906943
  %cmp15 = icmp eq i64 %and, 274877906943
  br i1 %cmp15, label %land.lhs.true, label %if.end49

land.lhs.true:                                    ; preds = %if.end6
  %36 = load i64, ptr %man, align 8
  %call16 = call noundef i64 @_ZNSt14numeric_limitsImE3maxEv() #3
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp17, ptr align 16 %x, i64 16, i1 false)
  %37 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp17, i32 0, i32 0
  %38 = load i64, ptr %37, align 16
  %39 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp17, i32 0, i32 1
  %40 = load i64, ptr %39, align 8
  %call18 = call noundef i64 @_ZN4absl12Uint128Low64ENS_7uint128E(i64 %38, i64 %40)
  %sub19 = sub i64 %call16, %call18
  %cmp20 = icmp ugt i64 %36, %sub19
  br i1 %cmp20, label %if.then21, label %if.end49

if.then21:                                        ; preds = %land.lhs.true
  %41 = load i64, ptr %man, align 8
  call void @_ZN4absl7uint128C2Em(ptr noundef nonnull align 16 dereferenceable(16) %agg.tmp22, i64 noundef %41)
  %42 = load i32, ptr %exp10, align 4
  %sub24 = sub nsw i32 %42, -342
  %idxprom25 = sext i32 %sub24 to i64
  %arrayidx26 = getelementptr inbounds [0 x i64], ptr @_ZN4absl12_GLOBAL__N_124kPower10MantissaLowTableE, i64 0, i64 %idxprom25
  %43 = load i64, ptr %arrayidx26, align 8
  call void @_ZN4absl7uint128C2Em(ptr noundef nonnull align 16 dereferenceable(16) %agg.tmp23, i64 noundef %43)
  %44 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp22, i32 0, i32 0
  %45 = load i64, ptr %44, align 16
  %46 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp22, i32 0, i32 1
  %47 = load i64, ptr %46, align 8
  %48 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp23, i32 0, i32 0
  %49 = load i64, ptr %48, align 16
  %50 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp23, i32 0, i32 1
  %51 = load i64, ptr %50, align 8
  %call27 = call { i64, i64 } @_ZN4abslmlENS_7uint128ES0_(i64 %45, i64 %47, i64 %49, i64 %51)
  %52 = getelementptr inbounds { i64, i64 }, ptr %y, i32 0, i32 0
  %53 = extractvalue { i64, i64 } %call27, 0
  store i64 %53, ptr %52, align 16
  %54 = getelementptr inbounds { i64, i64 }, ptr %y, i32 0, i32 1
  %55 = extractvalue { i64, i64 } %call27, 1
  store i64 %55, ptr %54, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp29, ptr align 16 %y, i64 16, i1 false)
  %56 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp29, i32 0, i32 0
  %57 = load i64, ptr %56, align 16
  %58 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp29, i32 0, i32 1
  %59 = load i64, ptr %58, align 8
  %call30 = call noundef i64 @_ZN4absl13Uint128High64ENS_7uint128E(i64 %57, i64 %59)
  call void @_ZN4absl7uint128C2Em(ptr noundef nonnull align 16 dereferenceable(16) %agg.tmp28, i64 noundef %call30)
  %60 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp28, i32 0, i32 0
  %61 = load i64, ptr %60, align 16
  %62 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp28, i32 0, i32 1
  %63 = load i64, ptr %62, align 8
  %call31 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN4absl7uint128pLES0_(ptr noundef nonnull align 16 dereferenceable(16) %x, i64 %61, i64 %63)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp32, ptr align 16 %x, i64 16, i1 false)
  %64 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp32, i32 0, i32 0
  %65 = load i64, ptr %64, align 16
  %66 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp32, i32 0, i32 1
  %67 = load i64, ptr %66, align 8
  %call33 = call noundef i64 @_ZN4absl13Uint128High64ENS_7uint128E(i64 %65, i64 %67)
  %and34 = and i64 %call33, 274877906943
  %cmp35 = icmp eq i64 %and34, 274877906943
  br i1 %cmp35, label %land.lhs.true36, label %if.end48

land.lhs.true36:                                  ; preds = %if.then21
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp37, ptr align 16 %x, i64 16, i1 false)
  %68 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp37, i32 0, i32 0
  %69 = load i64, ptr %68, align 16
  %70 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp37, i32 0, i32 1
  %71 = load i64, ptr %70, align 8
  %call38 = call noundef i64 @_ZN4absl12Uint128Low64ENS_7uint128E(i64 %69, i64 %71)
  %add39 = add i64 %call38, 1
  %cmp40 = icmp eq i64 %add39, 0
  br i1 %cmp40, label %land.lhs.true41, label %if.end48

land.lhs.true41:                                  ; preds = %land.lhs.true36
  %72 = load i64, ptr %man, align 8
  %call42 = call noundef i64 @_ZNSt14numeric_limitsImE3maxEv() #3
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp43, ptr align 16 %y, i64 16, i1 false)
  %73 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp43, i32 0, i32 0
  %74 = load i64, ptr %73, align 16
  %75 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp43, i32 0, i32 1
  %76 = load i64, ptr %75, align 8
  %call44 = call noundef i64 @_ZN4absl12Uint128Low64ENS_7uint128E(i64 %74, i64 %76)
  %sub45 = sub i64 %call42, %call44
  %cmp46 = icmp ugt i64 %72, %sub45
  br i1 %cmp46, label %if.then47, label %if.end48

if.then47:                                        ; preds = %land.lhs.true41
  store i1 false, ptr %retval, align 1
  br label %return

if.end48:                                         ; preds = %land.lhs.true41, %land.lhs.true36, %if.then21
  br label %if.end49

if.end49:                                         ; preds = %if.end48, %land.lhs.true, %if.end6
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp50, ptr align 16 %x, i64 16, i1 false)
  %77 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp50, i32 0, i32 0
  %78 = load i64, ptr %77, align 16
  %79 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp50, i32 0, i32 1
  %80 = load i64, ptr %79, align 8
  %call51 = call noundef i64 @_ZN4absl13Uint128High64ENS_7uint128E(i64 %78, i64 %80)
  %shr52 = lshr i64 %call51, 63
  store i64 %shr52, ptr %msb, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp53, ptr align 16 %x, i64 16, i1 false)
  %81 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp53, i32 0, i32 0
  %82 = load i64, ptr %81, align 16
  %83 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp53, i32 0, i32 1
  %84 = load i64, ptr %83, align 8
  %call54 = call noundef i64 @_ZN4absl13Uint128High64ENS_7uint128E(i64 %82, i64 %84)
  %85 = load i64, ptr %msb, align 8
  %add55 = add i64 %85, 38
  %shr56 = lshr i64 %call54, %add55
  store i64 %shr56, ptr %ret_man, align 8
  %86 = load i64, ptr %msb, align 8
  %xor = xor i64 1, %86
  %87 = load i64, ptr %ret_exp2, align 8
  %sub57 = sub i64 %87, %xor
  store i64 %sub57, ptr %ret_exp2, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp58, ptr align 16 %x, i64 16, i1 false)
  %88 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp58, i32 0, i32 0
  %89 = load i64, ptr %88, align 16
  %90 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp58, i32 0, i32 1
  %91 = load i64, ptr %90, align 8
  %call59 = call noundef i64 @_ZN4absl12Uint128Low64ENS_7uint128E(i64 %89, i64 %91)
  %cmp60 = icmp eq i64 %call59, 0
  br i1 %cmp60, label %land.lhs.true61, label %if.end70

land.lhs.true61:                                  ; preds = %if.end49
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp62, ptr align 16 %x, i64 16, i1 false)
  %92 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp62, i32 0, i32 0
  %93 = load i64, ptr %92, align 16
  %94 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp62, i32 0, i32 1
  %95 = load i64, ptr %94, align 8
  %call63 = call noundef i64 @_ZN4absl13Uint128High64ENS_7uint128E(i64 %93, i64 %95)
  %and64 = and i64 %call63, 274877906943
  %cmp65 = icmp eq i64 %and64, 0
  br i1 %cmp65, label %land.lhs.true66, label %if.end70

land.lhs.true66:                                  ; preds = %land.lhs.true61
  %96 = load i64, ptr %ret_man, align 8
  %and67 = and i64 %96, 3
  %cmp68 = icmp eq i64 %and67, 1
  br i1 %cmp68, label %if.then69, label %if.end70

if.then69:                                        ; preds = %land.lhs.true66
  store i1 false, ptr %retval, align 1
  br label %return

if.end70:                                         ; preds = %land.lhs.true66, %land.lhs.true61, %if.end49
  %97 = load i64, ptr %ret_man, align 8
  %and71 = and i64 %97, 1
  %98 = load i64, ptr %ret_man, align 8
  %add72 = add i64 %98, %and71
  store i64 %add72, ptr %ret_man, align 8
  %99 = load i64, ptr %ret_man, align 8
  %shr73 = lshr i64 %99, 1
  store i64 %shr73, ptr %ret_man, align 8
  %100 = load i64, ptr %ret_man, align 8
  %shr74 = lshr i64 %100, 24
  %cmp75 = icmp ugt i64 %shr74, 0
  br i1 %cmp75, label %if.then76, label %if.end78

if.then76:                                        ; preds = %if.end70
  %101 = load i64, ptr %ret_exp2, align 8
  %add77 = add i64 %101, 1
  store i64 %add77, ptr %ret_exp2, align 8
  br label %if.end78

if.end78:                                         ; preds = %if.then76, %if.end70
  %102 = load i64, ptr %ret_exp2, align 8
  %sub79 = sub i64 %102, 1
  %cmp80 = icmp uge i64 %sub79, 254
  br i1 %cmp80, label %if.then81, label %if.end82

if.then81:                                        ; preds = %if.end78
  store i1 false, ptr %retval, align 1
  br label %return

if.end82:                                         ; preds = %if.end78
  %103 = load i64, ptr %ret_exp2, align 8
  %conv83 = trunc i64 %103 to i32
  %shl84 = shl i32 %conv83, 23
  %104 = load i64, ptr %ret_man, align 8
  %conv85 = trunc i64 %104 to i32
  %and86 = and i32 %conv85, 8388607
  %or = or i32 %shl84, %and86
  store i32 %or, ptr %ret_bits, align 4
  %105 = load i8, ptr %negative.addr, align 1
  %tobool87 = trunc i8 %105 to i1
  br i1 %tobool87, label %if.then88, label %if.end90

if.then88:                                        ; preds = %if.end82
  %106 = load i32, ptr %ret_bits, align 4
  %or89 = or i32 %106, -2147483648
  store i32 %or89, ptr %ret_bits, align 4
  br label %if.end90

if.end90:                                         ; preds = %if.then88, %if.end82
  %call91 = call noundef float @_ZN4absl8bit_castIfjTnNSt9enable_ifIXaaaaeqstT_stT0_sr3std21is_trivially_copyableIS3_EE5valuesr3std21is_trivially_copyableIS2_EE5valueEiE4typeELi0EEES2_RKS3_(ptr noundef nonnull align 4 dereferenceable(4) %ret_bits)
  %107 = load ptr, ptr %value.addr, align 8
  store float %call91, ptr %107, align 4
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end90, %if.then81, %if.then69, %if.then47, %if.then2, %if.then
  %108 = load i1, ptr %retval, align 1
  ret i1 %108
}

; Function Attrs: mustprogress uwtable
define internal { i64, i32 } @_ZN4absl12_GLOBAL__N_126CalculateFromParsedDecimalIfEENS0_15CalculatedFloatERKNS_16strings_internal11ParsedFloatE(ptr noundef nonnull align 8 dereferenceable(48) %parsed_decimal) #4 {
entry:
  %retval = alloca %"struct.absl::(anonymous namespace)::CalculatedFloat", align 8
  %parsed_decimal.addr = alloca ptr, align 8
  %result = alloca %"struct.absl::(anonymous namespace)::CalculatedFloat", align 8
  %wide_binary_mantissa = alloca %"class.absl::uint128", align 16
  %agg.tmp = alloca %"class.absl::uint128", align 16
  %binary_exponent = alloca i32, align 4
  %mantissa_exact = alloca i8, align 1
  %mantissa_width = alloca i32, align 4
  %agg.tmp21 = alloca %"class.absl::uint128", align 16
  %shift = alloca i32, align 4
  %result_exact = alloca i8, align 1
  %binary_mantissa = alloca i64, align 8
  %agg.tmp27 = alloca %"class.absl::uint128", align 16
  store ptr %parsed_decimal, ptr %parsed_decimal.addr, align 8
  call void @_ZN4absl12_GLOBAL__N_115CalculatedFloatC2Ev(ptr noundef nonnull align 8 dereferenceable(12) %result) #3
  %0 = load ptr, ptr %parsed_decimal.addr, align 8
  %exponent = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %0, i32 0, i32 1
  %1 = load i32, ptr %exponent, align 8
  %call = call noundef zeroext i1 @_ZN4absl12_GLOBAL__N_116Power10UnderflowEi(i32 noundef %1)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %exponent1 = getelementptr inbounds %"struct.absl::(anonymous namespace)::CalculatedFloat", ptr %result, i32 0, i32 1
  store i32 -99999, ptr %exponent1, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %result, i64 16, i1 false)
  br label %return

if.else:                                          ; preds = %entry
  %2 = load ptr, ptr %parsed_decimal.addr, align 8
  %exponent2 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %2, i32 0, i32 1
  %3 = load i32, ptr %exponent2, align 8
  %call3 = call noundef zeroext i1 @_ZN4absl12_GLOBAL__N_115Power10OverflowEi(i32 noundef %3)
  br i1 %call3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %exponent5 = getelementptr inbounds %"struct.absl::(anonymous namespace)::CalculatedFloat", ptr %result, i32 0, i32 1
  store i32 99999, ptr %exponent5, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %result, i64 16, i1 false)
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end6

if.end6:                                          ; preds = %if.end
  %4 = load ptr, ptr %parsed_decimal.addr, align 8
  %mantissa = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %4, i32 0, i32 0
  %5 = load i64, ptr %mantissa, align 8
  call void @_ZN4absl7uint128C2Em(ptr noundef nonnull align 16 dereferenceable(16) %wide_binary_mantissa, i64 noundef %5)
  %6 = load ptr, ptr %parsed_decimal.addr, align 8
  %exponent7 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %6, i32 0, i32 1
  %7 = load i32, ptr %exponent7, align 8
  %call8 = call noundef i64 @_ZN4absl12_GLOBAL__N_115Power10MantissaEi(i32 noundef %7)
  call void @_ZN4absl7uint128C2Em(ptr noundef nonnull align 16 dereferenceable(16) %agg.tmp, i64 noundef %call8)
  %8 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 0
  %9 = load i64, ptr %8, align 16
  %10 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  %call9 = call noundef nonnull align 16 dereferenceable(16) ptr @_ZN4absl7uint128mLES0_(ptr noundef nonnull align 16 dereferenceable(16) %wide_binary_mantissa, i64 %9, i64 %11)
  %12 = load ptr, ptr %parsed_decimal.addr, align 8
  %exponent10 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %12, i32 0, i32 1
  %13 = load i32, ptr %exponent10, align 8
  %call11 = call noundef i32 @_ZN4absl12_GLOBAL__N_115Power10ExponentEi(i32 noundef %13)
  store i32 %call11, ptr %binary_exponent, align 4
  %14 = load ptr, ptr %parsed_decimal.addr, align 8
  %subrange_begin = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %14, i32 0, i32 4
  %15 = load ptr, ptr %subrange_begin, align 8
  %tobool = icmp ne ptr %15, null
  br i1 %tobool, label %if.then12, label %if.else14

if.then12:                                        ; preds = %if.end6
  store i32 58, ptr %mantissa_width, align 4
  store i8 0, ptr %mantissa_exact, align 1
  %16 = load i32, ptr %mantissa_width, align 4
  %call13 = call noundef i32 @_ZN4absl12_GLOBAL__N_118TruncateToBitWidthEiPNS_7uint128E(i32 noundef %16, ptr noundef %wide_binary_mantissa)
  %17 = load i32, ptr %binary_exponent, align 4
  %add = add nsw i32 %17, %call13
  store i32 %add, ptr %binary_exponent, align 4
  br label %if.end24

if.else14:                                        ; preds = %if.end6
  %18 = load ptr, ptr %parsed_decimal.addr, align 8
  %exponent15 = getelementptr inbounds %"struct.absl::strings_internal::ParsedFloat", ptr %18, i32 0, i32 1
  %19 = load i32, ptr %exponent15, align 8
  %call16 = call noundef zeroext i1 @_ZN4absl12_GLOBAL__N_112Power10ExactEi(i32 noundef %19)
  br i1 %call16, label %if.else20, label %if.then17

if.then17:                                        ; preds = %if.else14
  store i32 63, ptr %mantissa_width, align 4
  store i8 0, ptr %mantissa_exact, align 1
  %20 = load i32, ptr %mantissa_width, align 4
  %call18 = call noundef i32 @_ZN4absl12_GLOBAL__N_118TruncateToBitWidthEiPNS_7uint128E(i32 noundef %20, ptr noundef %wide_binary_mantissa)
  %21 = load i32, ptr %binary_exponent, align 4
  %add19 = add nsw i32 %21, %call18
  store i32 %add19, ptr %binary_exponent, align 4
  br label %if.end23

if.else20:                                        ; preds = %if.else14
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp21, ptr align 16 %wide_binary_mantissa, i64 16, i1 false)
  %22 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp21, i32 0, i32 0
  %23 = load i64, ptr %22, align 16
  %24 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp21, i32 0, i32 1
  %25 = load i64, ptr %24, align 8
  %call22 = call noundef i32 @_ZN4absl12_GLOBAL__N_18BitWidthENS_7uint128E(i64 %23, i64 %25)
  store i32 %call22, ptr %mantissa_width, align 4
  store i8 1, ptr %mantissa_exact, align 1
  br label %if.end23

if.end23:                                         ; preds = %if.else20, %if.then17
  br label %if.end24

if.end24:                                         ; preds = %if.end23, %if.then12
  %26 = load i32, ptr %mantissa_width, align 4
  %27 = load i32, ptr %binary_exponent, align 4
  %call25 = call noundef i32 @_ZN4absl12_GLOBAL__N_119NormalizedShiftSizeIfEEiii(i32 noundef %26, i32 noundef %27)
  store i32 %call25, ptr %shift, align 4
  %28 = load i32, ptr %shift, align 4
  %29 = load i32, ptr %binary_exponent, align 4
  %add26 = add nsw i32 %29, %28
  store i32 %add26, ptr %binary_exponent, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp27, ptr align 16 %wide_binary_mantissa, i64 16, i1 false)
  %30 = load i32, ptr %shift, align 4
  %31 = load i8, ptr %mantissa_exact, align 1
  %tobool28 = trunc i8 %31 to i1
  %32 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp27, i32 0, i32 0
  %33 = load i64, ptr %32, align 16
  %34 = getelementptr inbounds { i64, i64 }, ptr %agg.tmp27, i32 0, i32 1
  %35 = load i64, ptr %34, align 8
  %call29 = call noundef i64 @_ZN4absl12_GLOBAL__N_118ShiftRightAndRoundENS_7uint128EibPb(i64 %33, i64 %35, i32 noundef %30, i1 noundef zeroext %tobool28, ptr noundef %result_exact)
  store i64 %call29, ptr %binary_mantissa, align 8
  %36 = load i8, ptr %result_exact, align 1
  %tobool30 = trunc i8 %36 to i1
  br i1 %tobool30, label %if.end36, label %if.then31

if.then31:                                        ; preds = %if.end24
  %37 = load i64, ptr %binary_mantissa, align 8
  %38 = load i32, ptr %binary_exponent, align 4
  %39 = load ptr, ptr %parsed_decimal.addr, align 8
  %call32 = call noundef zeroext i1 @_ZN4absl12_GLOBAL__N_111MustRoundUpEmiRKNS_16strings_internal11ParsedFloatE(i64 noundef %37, i32 noundef %38, ptr noundef nonnull align 8 dereferenceable(48) %39)
  br i1 %call32, label %if.then33, label %if.end35

if.then33:                                        ; preds = %if.then31
  %40 = load i64, ptr %binary_mantissa, align 8
  %add34 = add i64 %40, 1
  store i64 %add34, ptr %binary_mantissa, align 8
  br label %if.end35

if.end35:                                         ; preds = %if.then33, %if.then31
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.end24
  %41 = load i64, ptr %binary_mantissa, align 8
  %42 = load i32, ptr %binary_exponent, align 4
  %call37 = call { i64, i32 } @_ZN4absl12_GLOBAL__N_128CalculatedFloatFromRawValuesIfEENS0_15CalculatedFloatEmi(i64 noundef %41, i32 noundef %42)
  %43 = getelementptr inbounds { i64, i32 }, ptr %retval, i32 0, i32 0
  %44 = extractvalue { i64, i32 } %call37, 0
  store i64 %44, ptr %43, align 8
  %45 = getelementptr inbounds { i64, i32 }, ptr %retval, i32 0, i32 1
  %46 = extractvalue { i64, i32 } %call37, 1
  store i32 %46, ptr %45, align 8
  br label %return

return:                                           ; preds = %if.end36, %if.then4, %if.then
  %47 = load { i64, i32 }, ptr %retval, align 8
  ret { i64, i32 } %47
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef float @_ZN4absl12_GLOBAL__N_111FloatTraitsIfE7MakeNanEPKc(ptr noundef %tagp) #5 align 2 {
entry:
  %tagp.addr = alloca ptr, align 8
  store ptr %tagp, ptr %tagp.addr, align 8
  %0 = load ptr, ptr %tagp.addr, align 8
  %call = call float @nanf(ptr noundef %0) #10
  ret float %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef float @_ZNSt14numeric_limitsIfE8infinityEv() #5 comdat align 2 {
entry:
  ret float 0x7FF0000000000000
}

; Function Attrs: nounwind willreturn memory(read)
declare float @nanf(ptr noundef) #7

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZN4absl12_GLOBAL__N_119NormalizedShiftSizeIfEEiii(i32 noundef %mantissa_width, i32 noundef %binary_exponent) #5 {
entry:
  %mantissa_width.addr = alloca i32, align 4
  %binary_exponent.addr = alloca i32, align 4
  %normal_shift = alloca i32, align 4
  %minimum_shift = alloca i32, align 4
  store i32 %mantissa_width, ptr %mantissa_width.addr, align 4
  store i32 %binary_exponent, ptr %binary_exponent.addr, align 4
  %0 = load i32, ptr %mantissa_width.addr, align 4
  %sub = sub nsw i32 %0, 24
  store i32 %sub, ptr %normal_shift, align 4
  %1 = load i32, ptr %binary_exponent.addr, align 4
  %sub1 = sub nsw i32 -149, %1
  store i32 %sub1, ptr %minimum_shift, align 4
  %call = call noundef nonnull align 4 dereferenceable(4) ptr @_ZSt3maxIiERKT_S2_S2_(ptr noundef nonnull align 4 dereferenceable(4) %normal_shift, ptr noundef nonnull align 4 dereferenceable(4) %minimum_shift)
  %2 = load i32, ptr %call, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nounwind uwtable
define internal { i64, i32 } @_ZN4absl12_GLOBAL__N_128CalculatedFloatFromRawValuesIfEENS0_15CalculatedFloatEmi(i64 noundef %mantissa, i32 noundef %exponent) #5 {
entry:
  %retval = alloca %"struct.absl::(anonymous namespace)::CalculatedFloat", align 8
  %mantissa.addr = alloca i64, align 8
  %exponent.addr = alloca i32, align 4
  store i64 %mantissa, ptr %mantissa.addr, align 8
  store i32 %exponent, ptr %exponent.addr, align 4
  call void @_ZN4absl12_GLOBAL__N_115CalculatedFloatC2Ev(ptr noundef nonnull align 8 dereferenceable(12) %retval) #3
  %0 = load i64, ptr %mantissa.addr, align 8
  %cmp = icmp eq i64 %0, 16777216
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %mantissa.addr, align 8
  %shr = lshr i64 %1, 1
  store i64 %shr, ptr %mantissa.addr, align 8
  %2 = load i32, ptr %exponent.addr, align 4
  %add = add nsw i32 %2, 1
  store i32 %add, ptr %exponent.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %exponent.addr, align 4
  %cmp1 = icmp sgt i32 %3, 104
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  %exponent3 = getelementptr inbounds %"struct.absl::(anonymous namespace)::CalculatedFloat", ptr %retval, i32 0, i32 1
  store i32 99999, ptr %exponent3, align 8
  br label %if.end11

if.else:                                          ; preds = %if.end
  %4 = load i64, ptr %mantissa.addr, align 8
  %cmp4 = icmp eq i64 %4, 0
  br i1 %cmp4, label %if.then5, label %if.else7

if.then5:                                         ; preds = %if.else
  %exponent6 = getelementptr inbounds %"struct.absl::(anonymous namespace)::CalculatedFloat", ptr %retval, i32 0, i32 1
  store i32 -99999, ptr %exponent6, align 8
  br label %if.end10

if.else7:                                         ; preds = %if.else
  %5 = load i32, ptr %exponent.addr, align 4
  %exponent8 = getelementptr inbounds %"struct.absl::(anonymous namespace)::CalculatedFloat", ptr %retval, i32 0, i32 1
  store i32 %5, ptr %exponent8, align 8
  %6 = load i64, ptr %mantissa.addr, align 8
  %mantissa9 = getelementptr inbounds %"struct.absl::(anonymous namespace)::CalculatedFloat", ptr %retval, i32 0, i32 0
  store i64 %6, ptr %mantissa9, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.else7, %if.then5
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %if.then2
  %7 = load { i64, i32 }, ptr %retval, align 8
  ret { i64, i32 } %7
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef float @_ZNSt14numeric_limitsIfE3maxEv() #5 comdat align 2 {
entry:
  ret float 0x47EFFFFFE0000000
}

; Function Attrs: mustprogress uwtable
define internal noundef float @_ZN4absl12_GLOBAL__N_111FloatTraitsIfE4MakeEjib(i32 noundef %mantissa, i32 noundef %exponent, i1 noundef zeroext %sign) #4 align 2 {
entry:
  %mantissa.addr = alloca i32, align 4
  %exponent.addr = alloca i32, align 4
  %sign.addr = alloca i8, align 1
  %kMantissaMask = alloca i32, align 4
  %flt = alloca i32, align 4
  store i32 %mantissa, ptr %mantissa.addr, align 4
  store i32 %exponent, ptr %exponent.addr, align 4
  %frombool = zext i1 %sign to i8
  store i8 %frombool, ptr %sign.addr, align 1
  store i32 8388607, ptr %kMantissaMask, align 4
  %0 = load i8, ptr %sign.addr, align 1
  %tobool = trunc i8 %0 to i1
  %conv = zext i1 %tobool to i32
  %shl = shl i32 %conv, 31
  store i32 %shl, ptr %flt, align 4
  %1 = load i32, ptr %mantissa.addr, align 4
  %cmp = icmp ugt i32 %1, 8388607
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %exponent.addr, align 4
  %add = add nsw i32 %2, 127
  %add1 = add nsw i32 %add, 24
  %sub = sub nsw i32 %add1, 1
  %shl2 = shl i32 %sub, 23
  %3 = load i32, ptr %flt, align 4
  %add3 = add i32 %3, %shl2
  store i32 %add3, ptr %flt, align 4
  %4 = load i32, ptr %mantissa.addr, align 4
  %and = and i32 %4, 8388607
  store i32 %and, ptr %mantissa.addr, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %5 = load i32, ptr %mantissa.addr, align 4
  %6 = load i32, ptr %flt, align 4
  %add4 = add i32 %6, %5
  store i32 %add4, ptr %flt, align 4
  %call = call noundef float @_ZN4absl8bit_castIfjTnNSt9enable_ifIXaaaaeqstT_stT0_sr3std21is_trivially_copyableIS3_EE5valuesr3std21is_trivially_copyableIS2_EE5valueEiE4typeELi0EEES2_RKS3_(ptr noundef nonnull align 4 dereferenceable(4) %flt)
  ret float %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef float @_ZN4absl8bit_castIfjTnNSt9enable_ifIXaaaaeqstT_stT0_sr3std21is_trivially_copyableIS3_EE5valuesr3std21is_trivially_copyableIS2_EE5valueEiE4typeELi0EEES2_RKS3_(ptr noundef nonnull align 4 dereferenceable(4) %source) #5 comdat {
entry:
  %source.addr = alloca ptr, align 8
  store ptr %source, ptr %source.addr, align 8
  %0 = load ptr, ptr %source.addr, align 8
  %1 = load float, ptr %0, align 4
  ret float %1
}

; Function Attrs: uwtable
define internal void @_GLOBAL__sub_I_charconv.cc() #0 section ".text.startup" {
entry:
  call void @__cxx_global_var_init()
  ret void
}

attributes #0 = { uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind }
attributes #4 = { mustprogress uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { mustprogress nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #6 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #7 = { nounwind willreturn memory(read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #8 = { noreturn nounwind uwtable "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #9 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #10 = { nounwind willreturn memory(read) }
attributes #11 = { noreturn nounwind }

!llvm.module.flags = !{!0, !1, !2, !3, !4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = distinct !{!5, !6}
!6 = !{!"llvm.loop.mustprogress"}
