target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%"class.absl::base_internal::AtomicHook" = type { %"struct.std::atomic", ptr }
%"struct.std::atomic" = type { %"struct.std::__atomic_base" }
%"struct.std::__atomic_base" = type { ptr }
%"class.absl::base_internal::AtomicHook.0" = type { %"struct.std::atomic.1", ptr }
%"struct.std::atomic.1" = type { %"struct.std::__atomic_base.2" }
%"struct.std::__atomic_base.2" = type { ptr }
%"class.absl::base_internal::AtomicHook.3" = type { %"struct.std::atomic.4", ptr }
%"struct.std::atomic.4" = type { %"struct.std::__atomic_base.5" }
%"struct.std::__atomic_base.5" = type { ptr }
%"struct.std::atomic.13" = type { i32 }
%"struct.std::atomic.11" = type { %"struct.std::__atomic_base.12" }
%"struct.std::__atomic_base.12" = type { i8 }
%"struct.absl::MuHowS" = type { i64, i64, i64, i64, i64 }
%"class.absl::Condition" = type { [16 x i8], ptr, ptr }
%"struct.absl::base_internal::SpinLockWaitTransition" = type { i32, i32, i8 }
%struct.anon = type { i32, ptr }
%"class.absl::Duration" = type { %"class.absl::Duration::HiRep", i32 }
%"class.absl::Duration::HiRep" = type { i32, i32 }
%"struct.std::atomic.17" = type { %"struct.std::__atomic_base.18" }
%"struct.std::__atomic_base.18" = type { ptr }
%"class.absl::base_internal::SchedulingGuard::ScopedEnable" = type { i32 }
%"struct.absl::(anonymous namespace)::MutexGlobals" = type { %"class.absl::once_flag", %"struct.std::atomic.8", [2 x i32], %"class.absl::Duration", [36 x i8] }
%"class.absl::once_flag" = type { %"struct.std::atomic.6" }
%"struct.std::atomic.6" = type { %"struct.std::__atomic_base.7" }
%"struct.std::__atomic_base.7" = type { i32 }
%"struct.std::atomic.8" = type { %"struct.std::__atomic_base.9" }
%"struct.std::__atomic_base.9" = type { i32 }
%class.anon = type { i8 }
%"class.absl::synchronization_internal::KernelTimeout" = type { i64 }
%"struct.absl::base_internal::ThreadIdentity" = type { %"struct.absl::base_internal::PerThreadSynch", %"struct.absl::base_internal::ThreadIdentity::WaiterState", ptr, %"struct.std::atomic.8", %"struct.std::atomic.8", %"struct.std::atomic.11", ptr }
%"struct.absl::base_internal::PerThreadSynch" = type { ptr, ptr, i8, i8, i8, i8, i8, i32, %"struct.std::atomic.10", ptr, i64, i64, ptr }
%"struct.std::atomic.10" = type { i32 }
%"struct.absl::base_internal::ThreadIdentity::WaiterState" = type { [256 x i8] }
%"class.absl::Mutex" = type { %"struct.std::atomic.14" }
%"struct.std::atomic.14" = type { %"struct.std::__atomic_base.15" }
%"struct.std::__atomic_base.15" = type { i64 }
%"struct.absl::SynchEvent" = type { i32, ptr, i64, ptr, ptr, i8, [1 x i8] }
%"struct.absl::base_internal::SchedulingGuard::ScopedDisable" = type { i8 }
%"struct.absl::SynchWaitParams" = type <{ ptr, ptr, %"class.absl::synchronization_internal::KernelTimeout", ptr, ptr, ptr, i64, i8, [7 x i8] }>
%"struct.absl::synchronization_internal::GraphId" = type { i64 }
%struct.sched_param = type { i32 }
%"class.absl::CondVar" = type { %"struct.std::atomic.14" }
%"class.absl::ReleasableMutexLock" = type { ptr }
%"class.absl::base_internal::SchedulingHelper" = type <{ i32, i8, [3 x i8] }>
%"class.absl::Time" = type { %"class.absl::Duration" }
%"class.absl::base_internal::SpinLock" = type { %"struct.std::atomic.6" }

$_ZNSt11this_thread5yieldEv = comdat any

$_ZN4absl13base_internal10AtomicHookIPFvlEE5StoreES3_ = comdat any

$_ZN4absl13base_internal10AtomicHookIPFvPKcPKvlEE5StoreES7_ = comdat any

$_ZN4absl13base_internal10AtomicHookIPFvPKcPKvEE5StoreES7_ = comdat any

$_ZN4absl13base_internal15SchedulingGuard12ScopedEnableC2Ev = comdat any

$_ZN4absl8SleepForENS_8DurationE = comdat any

$_ZN4absl13base_internal15SchedulingGuard12ScopedEnableD2Ev = comdat any

$_Z36AbslInternalAnnotateIgnoreReadsBeginv = comdat any

$_ZN4absl24synchronization_internal12PerThreadSem4PostEPNS_13base_internal14ThreadIdentityE = comdat any

$_ZN4absl13base_internal14PerThreadSynch15thread_identityEv = comdat any

$_Z34AbslInternalAnnotateIgnoreReadsEndv = comdat any

$_ZN4absl24synchronization_internal12PerThreadSem4WaitENS0_13KernelTimeoutE = comdat any

$_ZNSt6atomicIN4absl15OnDeadlockCycleEE5storeES1_St12memory_order = comdat any

$_ZN4absl5Mutex4DtorEv = comdat any

$_ZNSt6atomicIbE5storeEbSt12memory_order = comdat any

$_ZNKSt6atomicIbE4loadESt12memory_order = comdat any

$_ZN4absl13base_internal15SchedulingGuard13ScopedDisableC2Ev = comdat any

$_ZNSt6atomicIN4absl13base_internal14PerThreadSynch5StateEE5storeES3_St12memory_order = comdat any

$_ZN4absl13base_internal15SchedulingGuard13ScopedDisableD2Ev = comdat any

$_ZNKSt6atomicIN4absl13base_internal14PerThreadSynch5StateEE4loadESt12memory_order = comdat any

$_ZN4absl24synchronization_internal13KernelTimeout5NeverEv = comdat any

$_ZN4absl15SynchWaitParamsC2EPKNS_6MuHowSEPKNS_9ConditionENS_24synchronization_internal13KernelTimeoutEPNS_5MutexEPNS_13base_internal14PerThreadSynchEPSt6atomicIlE = comdat any

$_ZNK4absl24synchronization_internal13KernelTimeout11has_timeoutEv = comdat any

$_ZN4absl13base_internal10CycleClock3NowEv = comdat any

$_ZNK4absl13base_internal10AtomicHookIPFvPKcPKvlEEclIJRA13_S2_PNS_5MutexERlEEEvDpOT_ = comdat any

$_ZNK4absl13base_internal10AtomicHookIPFvlEEclIJRlEEEvDpOT_ = comdat any

$_ZN4absl24synchronization_internal13KernelTimeoutC2Ev = comdat any

$_ZNK4absl13base_internal10AtomicHookIPFvPKcPKvEEclIJRA5_S2_PNS_7CondVarEEEEvDpOT_ = comdat any

$_ZNK4absl13base_internal10AtomicHookIPFvPKcPKvEEclIJRA7_S2_PNS_7CondVarEEEEvDpOT_ = comdat any

$_ZNK4absl13base_internal10AtomicHookIPFvPKcPKvEEclIJRA14_S2_PNS_7CondVarEEEEvDpOT_ = comdat any

$_ZNK4absl13base_internal10AtomicHookIPFvPKcPKvEEclIJRA17_S2_PNS_7CondVarEEEEvDpOT_ = comdat any

$_ZN4absl9Condition10AlwaysTrueEPKS0_ = comdat any

$_ZN4absl9Condition13StoreCallbackIPFbPvEEEvT_ = comdat any

$__clang_call_terminate = comdat any

$_ZN4absl13base_internal10AtomicHookIPFvlEE13DummyFunctionEl = comdat any

$_ZN4absl13base_internal10AtomicHookIPFvPKcPKvlEE13DummyFunctionES3_S5_l = comdat any

$_ZN4absl13base_internal10AtomicHookIPFvPKcPKvEE13DummyFunctionES3_S5_ = comdat any

$_ZN4absl13base_internal11ControlWordEPNS_9once_flagE = comdat any

$_ZStanSt12memory_orderSt23__memory_order_modifier = comdat any

$_ZN4absl13base_internal16SchedulingHelperC2ENS0_14SchedulingModeE = comdat any

$_ZN4absl13base_internal12SpinLockWakeEPSt6atomicIjEb = comdat any

$_ZN4absl13base_internal16SchedulingHelperD2Ev = comdat any

$_ZN4absl13base_internal15SchedulingGuard19DisableReschedulingEv = comdat any

$_ZSt23__cmpexch_failure_orderSt12memory_order = comdat any

$_ZStorSt12memory_orderSt23__memory_order_modifier = comdat any

$_ZSt24__cmpexch_failure_order2St12memory_order = comdat any

$_ZN4absl12MicrosecondsIiTnNSt9enable_ifIXoosr3std11is_integralIT_EE5valuesr3std7is_enumIS2_EE5valueEiE4typeELi0EEENS_8DurationES2_ = comdat any

$_ZN4abslmlIiEENS_8DurationES1_T_ = comdat any

$_ZSt3minIN4absl8DurationEERKT_S4_S4_ = comdat any

$_ZN4absl12MillisecondsIiTnNSt9enable_ifIXoosr3std11is_integralIT_EE5valuesr3std7is_enumIS2_EE5valueEiE4typeELi0EEENS_8DurationES2_ = comdat any

$_ZSt3maxIN4absl8DurationEERKT_S4_S4_ = comdat any

$_ZN4absl13time_internal9FromInt64ILl1000000EEENS_8DurationElSt5ratioILl1EXT_EE = comdat any

$_ZN4absl13time_internal22MakeNormalizedDurationEll = comdat any

$_ZN4absl13time_internal12MakeDurationEll = comdat any

$_ZN4absl13time_internal12MakeDurationElj = comdat any

$_ZN4absl8DurationC2Elj = comdat any

$_ZN4absl8Duration5HiRepC2El = comdat any

$_ZN4absl8Duration5HiRepaSEl = comdat any

$_ZN4absl8DurationmLIiTnNSt9enable_ifIXoosr3std11is_integralIT_EE5valuesr3std7is_enumIS3_EE5valueEiE4typeELi0EEERS0_S3_ = comdat any

$_ZN4abslmiENS_4TimeES0_ = comdat any

$_ZN4abslmiENS_8DurationES0_ = comdat any

$_ZN4abslltENS_8DurationES0_ = comdat any

$_ZN4absl13time_internal8GetRepHiENS_8DurationE = comdat any

$_ZNSt14numeric_limitsIlE3minEv = comdat any

$_ZN4absl13time_internal8GetRepLoENS_8DurationE = comdat any

$_ZNK4absl8Duration5HiRep3GetEv = comdat any

$_ZN4absl13time_internal9FromInt64ILl1000EEENS_8DurationElSt5ratioILl1EXT_EE = comdat any

$_ZN4absl13base_internal15SchedulingGuard18EnableReschedulingEb = comdat any

$_ZN4absl13base_internal8SpinLock4LockEv = comdat any

$_ZN4absl13base_internal7HidePtrISt6atomicIlEEEmPT_ = comdat any

$_ZN4absl13base_internal8SpinLock6UnlockEv = comdat any

$_ZN4absl13base_internal8SpinLock11TryLockImplEv = comdat any

$_ZN4absl13base_internal8SpinLock15TryLockInternalEjj = comdat any

$_ZN4absl13base_internal8HideMaskEv = comdat any

$_ZN4absl24synchronization_internal14InvalidGraphIdEv = comdat any

$_ZN4absl24synchronization_internal32GetOrCreateCurrentThreadIdentityEv = comdat any

$_ZN4absl9ConditionC2INS_10SynchEventEEEPFbPT_ES4_ = comdat any

$_ZN4absl9Condition19CastAndCallFunctionINS_10SynchEventEEEbPKS0_ = comdat any

$_ZN4absl9Condition13StoreCallbackIPFbPNS_10SynchEventEEEEvT_ = comdat any

$_ZNK4absl9Condition12ReadCallbackIPFbPNS_10SynchEventEEEEvPT_ = comdat any

$_ZN4absl13base_internal10CycleClock9FrequencyEv = comdat any

$_ZN4absl13base_internal10CycleClock20LoadCycleClockSourceEv = comdat any

$_ZN4absl13base_internal18UnscaledCycleClock3NowEv = comdat any

$_ZNKSt6atomicIPFlvEE4loadESt12memory_order = comdat any

$_ZN4absl13base_internal7HidePtrIKvEEmPT_ = comdat any

$_ZN4absl13base_internal10AtomicHookIPFvlEE7DoStoreES3_ = comdat any

$_ZNSt6atomicIPFvlEE23compare_exchange_strongERS1_S1_St12memory_orderS4_ = comdat any

$_ZN4absl13base_internal10AtomicHookIPFvPKcPKvlEE7DoStoreES7_ = comdat any

$_ZNSt6atomicIPFvPKcPKvlEE23compare_exchange_strongERS5_S5_St12memory_orderS8_ = comdat any

$_ZN4absl13base_internal10AtomicHookIPFvPKcPKvEE7DoStoreES7_ = comdat any

$_ZNSt6atomicIPFvPKcPKvEE23compare_exchange_strongERS5_S5_St12memory_orderS8_ = comdat any

$_ZNK4absl13base_internal10AtomicHookIPFvPKcPKvlEE6DoLoadEv = comdat any

$_ZNKSt6atomicIPFvPKcPKvlEE4loadESt12memory_order = comdat any

$_ZNK4absl13base_internal10AtomicHookIPFvlEE6DoLoadEv = comdat any

$_ZNKSt6atomicIPFvlEE4loadESt12memory_order = comdat any

$_ZNK4absl13base_internal10AtomicHookIPFvPKcPKvEE6DoLoadEv = comdat any

$_ZNKSt6atomicIPFvPKcPKvEE4loadESt12memory_order = comdat any

@_ZN4absl12_GLOBAL__N_119submit_profile_dataE = internal global %"class.absl::base_internal::AtomicHook" { %"struct.std::atomic" { %"struct.std::__atomic_base" { ptr @_ZN4absl13base_internal10AtomicHookIPFvlEE13DummyFunctionEl } }, ptr @_ZN4absl13base_internal10AtomicHookIPFvlEE13DummyFunctionEl }, align 8
@_ZN4absl12_GLOBAL__N_112mutex_tracerE = internal global %"class.absl::base_internal::AtomicHook.0" { %"struct.std::atomic.1" { %"struct.std::__atomic_base.2" { ptr @_ZN4absl13base_internal10AtomicHookIPFvPKcPKvlEE13DummyFunctionES3_S5_l } }, ptr @_ZN4absl13base_internal10AtomicHookIPFvPKcPKvlEE13DummyFunctionES3_S5_l }, align 8
@_ZN4absl12_GLOBAL__N_115cond_var_tracerE = internal global %"class.absl::base_internal::AtomicHook.3" { %"struct.std::atomic.4" { %"struct.std::__atomic_base.5" { ptr @_ZN4absl13base_internal10AtomicHookIPFvPKcPKvEE13DummyFunctionES3_S5_ } }, ptr @_ZN4absl13base_internal10AtomicHookIPFvPKcPKvEE13DummyFunctionES3_S5_ }, align 8
@_ZN4absl12_GLOBAL__N_124synch_deadlock_detectionE = internal global %"struct.std::atomic.13" { i32 2 }, align 4
@_ZN4absl12_GLOBAL__N_122synch_check_invariantsE = internal global %"struct.std::atomic.11" zeroinitializer, align 1
@.str = private unnamed_addr constant [129 x i8] c"generated/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/abseil-cpp/abseil-cpp/absl/synchronization/mutex.cc\00", align 1
@.str.1 = private unnamed_addr constant [20 x i8] c"Check %s failed: %s\00", align 1
@.str.2 = private unnamed_addr constant [48 x i8] c"s->waitp != nullptr || s->suppress_fatal_errors\00", align 1
@.str.3 = private unnamed_addr constant [41 x i8] c"detected illegal recursion in Mutex code\00", align 1
@_ZN4abslL11kExclusiveSE = internal constant %"struct.absl::MuHowS" { i64 25, i64 8, i64 0, i64 9, i64 -1 }, align 8
@_ZN4abslL8kSharedSE = internal constant %"struct.absl::MuHowS" { i64 28, i64 1, i64 256, i64 12, i64 104 }, align 8
@.str.4 = private unnamed_addr constant [23 x i8] c"res || t.has_timeout()\00", align 1
@.str.5 = private unnamed_addr constant [38 x i8] c"condition untrue on return from Await\00", align 1
@.str.6 = private unnamed_addr constant [69 x i8] c"this->LockSlowWithDeadline(how, cond, KernelTimeout::Never(), flags)\00", align 1
@.str.7 = private unnamed_addr constant [41 x i8] c"condition untrue on return from LockSlow\00", align 1
@.str.8 = private unnamed_addr constant [72 x i8] c"waitp->thread->waitp == nullptr || waitp->thread->suppress_fatal_errors\00", align 1
@.str.9 = private unnamed_addr constant [43 x i8] c"detected illegal recursion into Mutex code\00", align 1
@.str.10 = private unnamed_addr constant [5 x i8] c"Lock\00", align 1
@.str.11 = private unnamed_addr constant [17 x i8] c"new_h != nullptr\00", align 1
@.str.12 = private unnamed_addr constant [29 x i8] c"Enqueue to empty list failed\00", align 1
@.str.13 = private unnamed_addr constant [23 x i8] c"Enqueue to list failed\00", align 1
@.str.14 = private unnamed_addr constant [7 x i8] c"Unlock\00", align 1
@.str.15 = private unnamed_addr constant [92 x i8] c"waitp == nullptr || waitp->thread->waitp == nullptr || waitp->thread->suppress_fatal_errors\00", align 1
@.str.16 = private unnamed_addr constant [17 x i8] c"waitp != nullptr\00", align 1
@.str.17 = private unnamed_addr constant [23 x i8] c"UnlockSlow is confused\00", align 1
@.str.18 = private unnamed_addr constant [38 x i8] c"waiters disappeared during Enqueue()!\00", align 1
@.str.19 = private unnamed_addr constant [39 x i8] c"old_h == nullptr || h->maybe_unlocking\00", align 1
@.str.20 = private unnamed_addr constant [31 x i8] c"Mutex queue changed beneath us\00", align 1
@.str.21 = private unnamed_addr constant [23 x i8] c"old_h->skip == nullptr\00", align 1
@.str.22 = private unnamed_addr constant [23 x i8] c"illegal skip from head\00", align 1
@.str.23 = private unnamed_addr constant [19 x i8] c"h->skip == nullptr\00", align 1
@.str.24 = private unnamed_addr constant [14 x i8] c"pw->next == w\00", align 1
@.str.25 = private unnamed_addr constant [23 x i8] c"pw not w's predecessor\00", align 1
@.str.26 = private unnamed_addr constant [33 x i8] c"wake_list != kPerThreadSynchNull\00", align 1
@.str.27 = private unnamed_addr constant [27 x i8] c"unexpected empty wake list\00", align 1
@.str.28 = private unnamed_addr constant [13 x i8] c"slow release\00", align 1
@.str.29 = private unnamed_addr constant [26 x i8] c"w->waitp->cond == nullptr\00", align 1
@.str.30 = private unnamed_addr constant [38 x i8] c"Mutex::Fer while waiting on Condition\00", align 1
@.str.31 = private unnamed_addr constant [29 x i8] c"w->waitp->cv_word == nullptr\00", align 1
@.str.32 = private unnamed_addr constant [41 x i8] c"Mutex::Fer with pending CondVar queueing\00", align 1
@.str.33 = private unnamed_addr constant [15 x i8] c"Enqueue failed\00", align 1
@.str.34 = private unnamed_addr constant [45 x i8] c"thread should hold write lock on Mutex %p %s\00", align 1
@.str.35 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.36 = private unnamed_addr constant [55 x i8] c"thread should hold at least a read lock on Mutex %p %s\00", align 1
@.str.37 = private unnamed_addr constant [5 x i8] c"Wait\00", align 1
@.str.38 = private unnamed_addr constant [31 x i8] c"waitp.thread->waitp != nullptr\00", align 1
@.str.39 = private unnamed_addr constant [27 x i8] c"not waiting when should be\00", align 1
@.str.40 = private unnamed_addr constant [7 x i8] c"Unwait\00", align 1
@.str.41 = private unnamed_addr constant [14 x i8] c"Signal wakeup\00", align 1
@.str.42 = private unnamed_addr constant [17 x i8] c"SignalAll wakeup\00", align 1
@.str.43 = private unnamed_addr constant [21 x i8] c"this->mu_ != nullptr\00", align 1
@.str.44 = private unnamed_addr constant [53 x i8] c"ReleasableMutexLock::Release may only be called once\00", align 1
@_ZN4absl9Condition5kTrueE = dso_local constant %"class.absl::Condition" { [16 x i8] zeroinitializer, ptr @_ZN4absl9Condition10AlwaysTrueEPKS0_, ptr null }, align 8
@"_ZZN4absl13base_internal12CallOnceImplIZNS_12_GLOBAL__N_115GetMutexGlobalsEvE3$_0JEEEvPSt6atomicIjENS0_14SchedulingModeEOT_DpOT0_E5trans" = internal constant [3 x %"struct.absl::base_internal::SpinLockWaitTransition"] [%"struct.absl::base_internal::SpinLockWaitTransition" { i32 0, i32 1707250555, i8 1 }, %"struct.absl::base_internal::SpinLockWaitTransition" { i32 1707250555, i32 94570706, i8 0 }, %"struct.absl::base_internal::SpinLockWaitTransition" { i32 221, i32 221, i8 1 }], align 16
@.str.45 = private unnamed_addr constant [141 x i8] c"generated/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/abseil-cpp/abseil-cpp/absl/base/internal/low_level_scheduling.h\00", align 1
@.str.46 = private unnamed_addr constant [32 x i8] c"scheduling_disabled_depth_ == 0\00", align 1
@.str.47 = private unnamed_addr constant [23 x i8] c"disable unused warning\00", align 1
@_ZZN4abslL16EnsureSynchEventEPSt6atomicIlEPKcllE17synch_event_count = internal global i64 0, align 8
@.str.48 = private unnamed_addr constant [180 x i8] c"Accumulated %zu Mutex debug objects. If you see this in production, it may mean that the production code accidentally calls Mutex/CondVar::EnableDebugLog/EnableInvariantDebugging.\00", align 1
@_ZN4abslL11synch_eventE = internal global [1031 x ptr] zeroinitializer, align 16
@_ZN4abslL14synch_event_muE = internal global { { i32 } } zeroinitializer, align 4
@.str.50 = private unnamed_addr constant [3 x i8] c" @\00", align 1
@.str.51 = private unnamed_addr constant [4 x i8] c" %p\00", align 1
@.str.52 = private unnamed_addr constant [11 x i8] c"%s%p %s %s\00", align 1
@_ZN4abslL16event_propertiesE = internal constant [14 x %struct.anon] [%struct.anon { i32 6, ptr @.str.53 }, %struct.anon { i32 0, ptr @.str.54 }, %struct.anon { i32 7, ptr @.str.55 }, %struct.anon { i32 0, ptr @.str.56 }, %struct.anon { i32 0, ptr @.str.57 }, %struct.anon { i32 2, ptr @.str.58 }, %struct.anon { i32 0, ptr @.str.59 }, %struct.anon { i32 3, ptr @.str.60 }, %struct.anon { i32 10, ptr @.str.61 }, %struct.anon { i32 11, ptr @.str.62 }, %struct.anon { i32 0, ptr @.str.63 }, %struct.anon { i32 0, ptr @.str.64 }, %struct.anon { i32 0, ptr @.str.65 }, %struct.anon { i32 0, ptr @.str.66 }], align 16
@.str.53 = private unnamed_addr constant [19 x i8] c"TryLock succeeded \00", align 1
@.str.54 = private unnamed_addr constant [16 x i8] c"TryLock failed \00", align 1
@.str.55 = private unnamed_addr constant [25 x i8] c"ReaderTryLock succeeded \00", align 1
@.str.56 = private unnamed_addr constant [22 x i8] c"ReaderTryLock failed \00", align 1
@.str.57 = private unnamed_addr constant [15 x i8] c"Lock blocking \00", align 1
@.str.58 = private unnamed_addr constant [16 x i8] c"Lock returning \00", align 1
@.str.59 = private unnamed_addr constant [21 x i8] c"ReaderLock blocking \00", align 1
@.str.60 = private unnamed_addr constant [22 x i8] c"ReaderLock returning \00", align 1
@.str.61 = private unnamed_addr constant [8 x i8] c"Unlock \00", align 1
@.str.62 = private unnamed_addr constant [14 x i8] c"ReaderUnlock \00", align 1
@.str.63 = private unnamed_addr constant [9 x i8] c"Wait on \00", align 1
@.str.64 = private unnamed_addr constant [16 x i8] c"Wait unblocked \00", align 1
@.str.65 = private unnamed_addr constant [11 x i8] c"Signal on \00", align 1
@.str.66 = private unnamed_addr constant [14 x i8] c"SignalAll on \00", align 1
@_ZN4absl12_GLOBAL__N_17globalsE = internal global { { { i32 } }, { i32 }, [2 x i32], %"class.absl::Duration", [36 x i8] } { { { i32 } } zeroinitializer, { i32 } zeroinitializer, [2 x i32] zeroinitializer, %"class.absl::Duration" zeroinitializer, [36 x i8] undef }, align 64
@.str.68 = private unnamed_addr constant [127 x i8] c"Check (v & (kMuWriter | kMuReader)) != (kMuWriter | kMuReader) failed: %s: Mutex corrupt: both reader and writer lock held: %p\00", align 1
@.str.69 = private unnamed_addr constant [109 x i8] c"Check (v & (kMuWait | kMuWrWait)) != kMuWrWait failed: %s: Mutex corrupt: waiting writer with no waiters: %p\00", align 1
@.str.70 = private unnamed_addr constant [69 x i8] c"s->waitp == nullptr || s->waitp == waitp || s->suppress_fatal_errors\00", align 1
@.str.71 = private unnamed_addr constant [33 x i8] c"pthread_getschedparam failed: %d\00", align 1
@.str.72 = private unnamed_addr constant [71 x i8] c"enqueue_after->skip == nullptr || MuEquivalentWaiter(enqueue_after, s)\00", align 1
@.str.73 = private unnamed_addr constant [22 x i8] c"Mutex Enqueue failure\00", align 1
@.str.74 = private unnamed_addr constant [32 x i8] c"waitp->thread->waitp == nullptr\00", align 1
@.str.75 = private unnamed_addr constant [26 x i8] c"waiting when shouldn't be\00", align 1
@.str.76 = private unnamed_addr constant [20 x i8] c"pw->skip == nullptr\00", align 1
@.str.77 = private unnamed_addr constant [31 x i8] c"bad skip in DequeueAllWakeable\00", align 1
@_ZN4absl13base_internal10CycleClock19cycle_clock_source_E = external global %"struct.std::atomic.17", align 8

@_ZN4absl9ConditionC1EPFbPvES1_ = dso_local unnamed_addr alias void (ptr, ptr, ptr), ptr @_ZN4absl9ConditionC2EPFbPvES1_
@_ZN4absl9ConditionC1EPKb = dso_local unnamed_addr alias void (ptr, ptr), ptr @_ZN4absl9ConditionC2EPKb

; Function Attrs: mustprogress uwtable
define weak dso_local void @AbslInternalMutexYield() #0 {
entry:
  call void @_ZNSt11this_thread5yieldEv() #13
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZNSt11this_thread5yieldEv() #1 comdat personality ptr @__gxx_personality_v0 {
entry:
  %call = invoke noundef i32 @_ZL15__gthread_yieldv()
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #14
  unreachable
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN4absl21RegisterMutexProfilerEPFvlE(ptr noundef %fn) #0 {
entry:
  %fn.addr = alloca ptr, align 8
  store ptr %fn, ptr %fn.addr, align 8
  %0 = load ptr, ptr %fn.addr, align 8
  call void @_ZN4absl13base_internal10AtomicHookIPFvlEE5StoreES3_(ptr noundef nonnull align 8 dereferenceable(16) @_ZN4absl12_GLOBAL__N_119submit_profile_dataE, ptr noundef %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN4absl13base_internal10AtomicHookIPFvlEE5StoreES3_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %fn) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %fn.addr = alloca ptr, align 8
  %success = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  store ptr %fn, ptr %fn.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %fn.addr, align 8
  %call = call noundef zeroext i1 @_ZN4absl13base_internal10AtomicHookIPFvlEE7DoStoreES3_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef %0)
  %frombool = zext i1 %call to i8
  store i8 %frombool, ptr %success, align 1
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN4absl19RegisterMutexTracerEPFvPKcPKvlE(ptr noundef %fn) #0 {
entry:
  %fn.addr = alloca ptr, align 8
  store ptr %fn, ptr %fn.addr, align 8
  %0 = load ptr, ptr %fn.addr, align 8
  call void @_ZN4absl13base_internal10AtomicHookIPFvPKcPKvlEE5StoreES7_(ptr noundef nonnull align 8 dereferenceable(16) @_ZN4absl12_GLOBAL__N_112mutex_tracerE, ptr noundef %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN4absl13base_internal10AtomicHookIPFvPKcPKvlEE5StoreES7_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %fn) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %fn.addr = alloca ptr, align 8
  %success = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  store ptr %fn, ptr %fn.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %fn.addr, align 8
  %call = call noundef zeroext i1 @_ZN4absl13base_internal10AtomicHookIPFvPKcPKvlEE7DoStoreES7_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef %0)
  %frombool = zext i1 %call to i8
  store i8 %frombool, ptr %success, align 1
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN4absl21RegisterCondVarTracerEPFvPKcPKvE(ptr noundef %fn) #0 {
entry:
  %fn.addr = alloca ptr, align 8
  store ptr %fn, ptr %fn.addr, align 8
  %0 = load ptr, ptr %fn.addr, align 8
  call void @_ZN4absl13base_internal10AtomicHookIPFvPKcPKvEE5StoreES7_(ptr noundef nonnull align 8 dereferenceable(16) @_ZN4absl12_GLOBAL__N_115cond_var_tracerE, ptr noundef %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN4absl13base_internal10AtomicHookIPFvPKcPKvEE5StoreES7_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %fn) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %fn.addr = alloca ptr, align 8
  %success = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  store ptr %fn, ptr %fn.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %fn.addr, align 8
  %call = call noundef zeroext i1 @_ZN4absl13base_internal10AtomicHookIPFvPKcPKvEE7DoStoreES7_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef %0)
  %frombool = zext i1 %call to i8
  store i8 %frombool, ptr %success, align 1
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local noundef i32 @_ZN4absl24synchronization_internal10MutexDelayEii(i32 noundef %c, i32 noundef %mode) #0 personality ptr @__gxx_personality_v0 {
entry:
  %c.addr = alloca i32, align 4
  %mode.addr = alloca i32, align 4
  %limit = alloca i32, align 4
  %sleep_time = alloca %"class.absl::Duration", align 4
  %enable_rescheduling = alloca %"class.absl::base_internal::SchedulingGuard::ScopedEnable", align 4
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %agg.tmp = alloca %"class.absl::Duration", align 4
  %agg.tmp.coerce = alloca { i64, i32 }, align 4
  store i32 %c, ptr %c.addr, align 4
  store i32 %mode, ptr %mode.addr, align 4
  %call = call noundef nonnull align 64 dereferenceable(28) ptr @_ZN4absl12_GLOBAL__N_115GetMutexGlobalsEv()
  %mutex_sleep_spins = getelementptr inbounds %"struct.absl::(anonymous namespace)::MutexGlobals", ptr %call, i32 0, i32 2
  %0 = load i32, ptr %mode.addr, align 4
  %idxprom = sext i32 %0 to i64
  %arrayidx = getelementptr inbounds [2 x i32], ptr %mutex_sleep_spins, i64 0, i64 %idxprom
  %1 = load i32, ptr %arrayidx, align 4
  store i32 %1, ptr %limit, align 4
  %call1 = call noundef nonnull align 64 dereferenceable(28) ptr @_ZN4absl12_GLOBAL__N_115GetMutexGlobalsEv()
  %mutex_sleep_time = getelementptr inbounds %"struct.absl::(anonymous namespace)::MutexGlobals", ptr %call1, i32 0, i32 3
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %sleep_time, ptr align 16 %mutex_sleep_time, i64 12, i1 false)
  %2 = load i32, ptr %c.addr, align 4
  %3 = load i32, ptr %limit, align 4
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load i32, ptr %c.addr, align 4
  %inc = add nsw i32 %4, 1
  store i32 %inc, ptr %c.addr, align 4
  br label %if.end7

if.else:                                          ; preds = %entry
  call void @_ZN4absl13base_internal15SchedulingGuard12ScopedEnableC2Ev(ptr noundef nonnull align 4 dereferenceable(4) %enable_rescheduling)
  %5 = load i32, ptr %c.addr, align 4
  %6 = load i32, ptr %limit, align 4
  %cmp2 = icmp eq i32 %5, %6
  br i1 %cmp2, label %if.then3, label %if.else5

if.then3:                                         ; preds = %if.else
  invoke void @AbslInternalMutexYield()
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %if.then3
  %7 = load i32, ptr %c.addr, align 4
  %inc4 = add nsw i32 %7, 1
  store i32 %inc4, ptr %c.addr, align 4
  br label %if.end

lpad:                                             ; preds = %if.else5, %if.then3
  %8 = landingpad { ptr, i32 }
          cleanup
  %9 = extractvalue { ptr, i32 } %8, 0
  store ptr %9, ptr %exn.slot, align 8
  %10 = extractvalue { ptr, i32 } %8, 1
  store i32 %10, ptr %ehselector.slot, align 4
  call void @_ZN4absl13base_internal15SchedulingGuard12ScopedEnableD2Ev(ptr noundef nonnull align 4 dereferenceable(4) %enable_rescheduling) #13
  br label %eh.resume

if.else5:                                         ; preds = %if.else
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp, ptr align 4 %sleep_time, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp.coerce, ptr align 4 %agg.tmp, i64 12, i1 false)
  %11 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp.coerce, i32 0, i32 0
  %12 = load i64, ptr %11, align 4
  %13 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp.coerce, i32 0, i32 1
  %14 = load i32, ptr %13, align 4
  invoke void @_ZN4absl8SleepForENS_8DurationE(i64 %12, i32 %14)
          to label %invoke.cont6 unwind label %lpad

invoke.cont6:                                     ; preds = %if.else5
  store i32 0, ptr %c.addr, align 4
  br label %if.end

if.end:                                           ; preds = %invoke.cont6, %invoke.cont
  call void @_ZN4absl13base_internal15SchedulingGuard12ScopedEnableD2Ev(ptr noundef nonnull align 4 dereferenceable(4) %enable_rescheduling) #13
  br label %if.end7

if.end7:                                          ; preds = %if.end, %if.then
  %15 = load i32, ptr %c.addr, align 4
  ret i32 %15

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val8 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val8
}

; Function Attrs: mustprogress uwtable
define internal noundef nonnull align 64 dereferenceable(28) ptr @_ZN4absl12_GLOBAL__N_115GetMutexGlobalsEv() #0 {
entry:
  %ref.tmp = alloca %class.anon, align 1
  call void @"_ZN4absl13base_internal16LowLevelCallOnceIZNS_12_GLOBAL__N_115GetMutexGlobalsEvE3$_0JEEEvPNS_9once_flagEOT_DpOT0_"(ptr noundef @_ZN4absl12_GLOBAL__N_17globalsE, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp)
  ret ptr @_ZN4absl12_GLOBAL__N_17globalsE
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #2

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN4absl13base_internal15SchedulingGuard12ScopedEnableC2Ev(ptr noundef nonnull align 4 dereferenceable(4) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %scheduling_disabled_depth_ = getelementptr inbounds %"class.absl::base_internal::SchedulingGuard::ScopedEnable", ptr %this1, i32 0, i32 0
  store i32 0, ptr %scheduling_disabled_depth_, align 4
  ret void
}

declare i32 @__gxx_personality_v0(...)

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN4absl8SleepForENS_8DurationE(i64 %duration.coerce0, i32 %duration.coerce1) #0 comdat {
entry:
  %duration = alloca %"class.absl::Duration", align 4
  %coerce = alloca { i64, i32 }, align 4
  %agg.tmp = alloca %"class.absl::Duration", align 4
  %agg.tmp.coerce = alloca { i64, i32 }, align 4
  %0 = getelementptr inbounds { i64, i32 }, ptr %coerce, i32 0, i32 0
  store i64 %duration.coerce0, ptr %0, align 4
  %1 = getelementptr inbounds { i64, i32 }, ptr %coerce, i32 0, i32 1
  store i32 %duration.coerce1, ptr %1, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %duration, ptr align 4 %coerce, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp, ptr align 4 %duration, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp.coerce, ptr align 4 %agg.tmp, i64 12, i1 false)
  %2 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp.coerce, i32 0, i32 0
  %3 = load i64, ptr %2, align 4
  %4 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp.coerce, i32 0, i32 1
  %5 = load i32, ptr %4, align 4
  call void @AbslInternalSleepFor(i64 %3, i32 %5)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN4absl13base_internal15SchedulingGuard12ScopedEnableD2Ev(ptr noundef nonnull align 4 dereferenceable(4) %this) unnamed_addr #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %absl_raw_log_internal_basename = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %scheduling_disabled_depth_ = getelementptr inbounds %"class.absl::base_internal::SchedulingGuard::ScopedEnable", ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %scheduling_disabled_depth_, align 4
  %cmp = icmp eq i32 %0, 0
  %lnot = xor i1 %cmp, true
  br i1 %lnot, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  br label %do.body2

do.body2:                                         ; preds = %if.then
  store ptr getelementptr (i8, ptr @.str.45, i64 118), ptr %absl_raw_log_internal_basename, align 8
  invoke void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str.45, i64 118), i32 noundef 127, ptr noundef @.str.1, ptr noundef @.str.46, ptr noundef @.str.47)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %do.body2
  br label %do.body3

do.body3:                                         ; preds = %invoke.cont
  unreachable

do.cond:                                          ; No predecessors!
  br label %do.end

do.end:                                           ; preds = %do.cond
  br label %do.cond4

do.cond4:                                         ; preds = %do.end
  br label %do.end5

do.end5:                                          ; preds = %do.cond4
  br label %if.end

if.end:                                           ; preds = %do.end5, %do.body
  br label %do.cond6

do.cond6:                                         ; preds = %if.end
  br label %do.end7

do.end7:                                          ; preds = %do.cond6
  ret void

terminate.lpad:                                   ; preds = %do.body2
  %1 = landingpad { ptr, i32 }
          catch ptr null
  %2 = extractvalue { ptr, i32 } %1, 0
  call void @__clang_call_terminate(ptr %2) #14
  unreachable
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN4absl5Mutex17IncrementSynchSemEPS0_PNS_13base_internal14PerThreadSynchE(ptr noundef %mu, ptr noundef %w) #0 align 2 {
entry:
  %mu.addr = alloca ptr, align 8
  %w.addr = alloca ptr, align 8
  store ptr %mu, ptr %mu.addr, align 8
  store ptr %w, ptr %w.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  call void @_Z36AbslInternalAnnotateIgnoreReadsBeginv()
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %w.addr, align 8
  %call = call noundef ptr @_ZN4absl13base_internal14PerThreadSynch15thread_identityEv(ptr noundef nonnull align 8 dereferenceable(64) %0)
  call void @_ZN4absl24synchronization_internal12PerThreadSem4PostEPNS_13base_internal14ThreadIdentityE(ptr noundef %call)
  br label %do.body1

do.body1:                                         ; preds = %do.end
  call void @_Z34AbslInternalAnnotateIgnoreReadsEndv()
  br label %do.end2

do.end2:                                          ; preds = %do.body1
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_Z36AbslInternalAnnotateIgnoreReadsBeginv() #1 comdat {
entry:
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN4absl24synchronization_internal12PerThreadSem4PostEPNS_13base_internal14ThreadIdentityE(ptr noundef %identity) #0 comdat align 2 {
entry:
  %identity.addr = alloca ptr, align 8
  store ptr %identity, ptr %identity.addr, align 8
  %0 = load ptr, ptr %identity.addr, align 8
  call void @AbslInternalPerThreadSemPost(ptr noundef %0)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN4absl13base_internal14PerThreadSynch15thread_identityEv(ptr noundef nonnull align 8 dereferenceable(64) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_Z34AbslInternalAnnotateIgnoreReadsEndv() #1 comdat {
entry:
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local noundef zeroext i1 @_ZN4absl5Mutex17DecrementSynchSemEPS0_PNS_13base_internal14PerThreadSynchENS_24synchronization_internal13KernelTimeoutE(ptr noundef %mu, ptr noundef %w, i64 %t.coerce) #0 align 2 {
entry:
  %t = alloca %"class.absl::synchronization_internal::KernelTimeout", align 8
  %mu.addr = alloca ptr, align 8
  %w.addr = alloca ptr, align 8
  %res = alloca i8, align 1
  %agg.tmp = alloca %"class.absl::synchronization_internal::KernelTimeout", align 8
  %coerce.dive = getelementptr inbounds %"class.absl::synchronization_internal::KernelTimeout", ptr %t, i32 0, i32 0
  store i64 %t.coerce, ptr %coerce.dive, align 8
  store ptr %mu, ptr %mu.addr, align 8
  store ptr %w, ptr %w.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %t, i64 8, i1 false)
  %coerce.dive1 = getelementptr inbounds %"class.absl::synchronization_internal::KernelTimeout", ptr %agg.tmp, i32 0, i32 0
  %0 = load i64, ptr %coerce.dive1, align 8
  %call = call noundef zeroext i1 @_ZN4absl24synchronization_internal12PerThreadSem4WaitENS0_13KernelTimeoutE(i64 %0)
  %frombool = zext i1 %call to i8
  store i8 %frombool, ptr %res, align 1
  %1 = load i8, ptr %res, align 1
  %tobool = trunc i8 %1 to i1
  ret i1 %tobool
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN4absl24synchronization_internal12PerThreadSem4WaitENS0_13KernelTimeoutE(i64 %t.coerce) #0 comdat align 2 {
entry:
  %t = alloca %"class.absl::synchronization_internal::KernelTimeout", align 8
  %agg.tmp = alloca %"class.absl::synchronization_internal::KernelTimeout", align 8
  %coerce.dive = getelementptr inbounds %"class.absl::synchronization_internal::KernelTimeout", ptr %t, i32 0, i32 0
  store i64 %t.coerce, ptr %coerce.dive, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %t, i64 8, i1 false)
  %coerce.dive1 = getelementptr inbounds %"class.absl::synchronization_internal::KernelTimeout", ptr %agg.tmp, i32 0, i32 0
  %0 = load i64, ptr %coerce.dive1, align 8
  %call = call zeroext i1 @AbslInternalPerThreadSemWait(i64 %0)
  ret i1 %call
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN4absl5Mutex45InternalAttemptToUseMutexInFatalSignalHandlerEv() #0 align 2 {
entry:
  %identity = alloca ptr, align 8
  %call = call noundef ptr @_ZN4absl13base_internal30CurrentThreadIdentityIfPresentEv()
  store ptr %call, ptr %identity, align 8
  %0 = load ptr, ptr %identity, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %identity, align 8
  %per_thread_synch = getelementptr inbounds %"struct.absl::base_internal::ThreadIdentity", ptr %1, i32 0, i32 0
  %suppress_fatal_errors = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %per_thread_synch, i32 0, i32 6
  store i8 1, ptr %suppress_fatal_errors, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @_ZNSt6atomicIN4absl15OnDeadlockCycleEE5storeES1_St12memory_order(ptr noundef nonnull align 4 dereferenceable(4) @_ZN4absl12_GLOBAL__N_124synch_deadlock_detectionE, i32 noundef 0, i32 noundef 3) #13
  ret void
}

declare noundef ptr @_ZN4absl13base_internal30CurrentThreadIdentityIfPresentEv() #3

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZNSt6atomicIN4absl15OnDeadlockCycleEE5storeES1_St12memory_order(ptr noundef nonnull align 4 dereferenceable(4) %this, i32 noundef %__i, i32 noundef %__m) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %__i.addr = alloca i32, align 4
  %__m.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %__i, ptr %__i.addr, align 4
  store i32 %__m, ptr %__m.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %_M_i = getelementptr inbounds %"struct.std::atomic.13", ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %__m.addr, align 4
  switch i32 %0, label %monotonic [
    i32 3, label %release
    i32 5, label %seqcst
  ]

monotonic:                                        ; preds = %entry
  %1 = load i32, ptr %__i.addr, align 4
  store atomic i32 %1, ptr %_M_i monotonic, align 4
  br label %atomic.continue

release:                                          ; preds = %entry
  %2 = load i32, ptr %__i.addr, align 4
  store atomic i32 %2, ptr %_M_i release, align 4
  br label %atomic.continue

seqcst:                                           ; preds = %entry
  %3 = load i32, ptr %__i.addr, align 4
  store atomic i32 %3, ptr %_M_i seq_cst, align 4
  br label %atomic.continue

atomic.continue:                                  ; preds = %seqcst, %release, %monotonic
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN4absl5Mutex14EnableDebugLogEPKc(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %name) #0 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %e = alloca ptr, align 8
  %dtor = alloca { i64, i64 }, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mu_ = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %name.addr, align 8
  %call = call noundef ptr @_ZN4abslL16EnsureSynchEventEPSt6atomicIlEPKcll(ptr noundef %mu_, ptr noundef %0, i64 noundef 16, i64 noundef 64)
  store ptr %call, ptr %e, align 8
  %1 = load ptr, ptr %e, align 8
  %log = getelementptr inbounds %"struct.absl::SynchEvent", ptr %1, i32 0, i32 5
  store i8 1, ptr %log, align 8
  %2 = load ptr, ptr %e, align 8
  call void @_ZN4abslL15UnrefSynchEventEPNS_10SynchEventE(ptr noundef %2)
  store volatile { i64, i64 } { i64 ptrtoint (ptr @_ZN4absl5Mutex4DtorEv to i64), i64 0 }, ptr %dtor, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define internal noundef ptr @_ZN4abslL16EnsureSynchEventEPSt6atomicIlEPKcll(ptr noundef %addr, ptr noundef %name, i64 noundef %bits, i64 noundef %lockbit) #0 {
entry:
  %addr.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %bits.addr = alloca i64, align 8
  %lockbit.addr = alloca i64, align 8
  %h = alloca i32, align 4
  %kMaxSynchEventCount = alloca i64, align 8
  %absl_raw_log_internal_basename = alloca ptr, align 8
  %__range2 = alloca ptr, align 8
  %__begin2 = alloca ptr, align 8
  %__end2 = alloca ptr, align 8
  %head = alloca ptr, align 8
  %e = alloca ptr, align 8
  %next = alloca ptr, align 8
  %e10 = alloca ptr, align 8
  %l = alloca i64, align 8
  store ptr %addr, ptr %addr.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  store i64 %bits, ptr %bits.addr, align 8
  store i64 %lockbit, ptr %lockbit.addr, align 8
  %0 = load ptr, ptr %addr.addr, align 8
  %1 = ptrtoint ptr %0 to i64
  %rem = urem i64 %1, 1031
  %conv = trunc i64 %rem to i32
  store i32 %conv, ptr %h, align 4
  call void @_ZN4absl13base_internal8SpinLock4LockEv(ptr noundef nonnull align 4 dereferenceable(4) @_ZN4abslL14synch_event_muE)
  store i64 102400, ptr %kMaxSynchEventCount, align 8
  %2 = load i64, ptr @_ZZN4abslL16EnsureSynchEventEPSt6atomicIlEPKcllE17synch_event_count, align 8
  %inc = add i64 %2, 1
  store i64 %inc, ptr @_ZZN4abslL16EnsureSynchEventEPSt6atomicIlEPKcllE17synch_event_count, align 8
  %cmp = icmp ugt i64 %inc, 102400
  br i1 %cmp, label %if.then, label %if.end9

if.then:                                          ; preds = %entry
  store i64 0, ptr @_ZZN4abslL16EnsureSynchEventEPSt6atomicIlEPKcllE17synch_event_count, align 8
  br label %do.body

do.body:                                          ; preds = %if.then
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename, align 8
  call void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 2, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 358, ptr noundef @.str.48, i64 noundef 102400)
  br label %do.end

do.end:                                           ; preds = %do.body
  store ptr @_ZN4abslL11synch_eventE, ptr %__range2, align 8
  store ptr @_ZN4abslL11synch_eventE, ptr %__begin2, align 8
  store ptr getelementptr inbounds (ptr, ptr @_ZN4abslL11synch_eventE, i64 1031), ptr %__end2, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %3 = load ptr, ptr %__begin2, align 8
  %4 = load ptr, ptr %__end2, align 8
  %cmp1 = icmp ne ptr %3, %4
  br i1 %cmp1, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %__begin2, align 8
  store ptr %5, ptr %head, align 8
  %6 = load ptr, ptr %head, align 8
  %7 = load ptr, ptr %6, align 8
  store ptr %7, ptr %e, align 8
  br label %for.cond2

for.cond2:                                        ; preds = %if.end, %for.body
  %8 = load ptr, ptr %e, align 8
  %cmp3 = icmp ne ptr %8, null
  br i1 %cmp3, label %for.body4, label %for.end

for.body4:                                        ; preds = %for.cond2
  %9 = load ptr, ptr %e, align 8
  %next5 = getelementptr inbounds %"struct.absl::SynchEvent", ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %next5, align 8
  store ptr %10, ptr %next, align 8
  %11 = load ptr, ptr %e, align 8
  %refcount = getelementptr inbounds %"struct.absl::SynchEvent", ptr %11, i32 0, i32 0
  %12 = load i32, ptr %refcount, align 8
  %dec = add nsw i32 %12, -1
  store i32 %dec, ptr %refcount, align 8
  %cmp6 = icmp eq i32 %dec, 0
  br i1 %cmp6, label %if.then7, label %if.end

if.then7:                                         ; preds = %for.body4
  %13 = load ptr, ptr %e, align 8
  call void @_ZN4absl13base_internal13LowLevelAlloc4FreeEPv(ptr noundef %13)
  br label %if.end

if.end:                                           ; preds = %if.then7, %for.body4
  %14 = load ptr, ptr %next, align 8
  store ptr %14, ptr %e, align 8
  br label %for.cond2, !llvm.loop !5

for.end:                                          ; preds = %for.cond2
  %15 = load ptr, ptr %head, align 8
  store ptr null, ptr %15, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.end
  %16 = load ptr, ptr %__begin2, align 8
  %incdec.ptr = getelementptr inbounds ptr, ptr %16, i32 1
  store ptr %incdec.ptr, ptr %__begin2, align 8
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  br label %if.end9

if.end9:                                          ; preds = %for.end8, %entry
  store ptr null, ptr %e10, align 8
  %17 = load ptr, ptr %addr.addr, align 8
  %18 = load i64, ptr %bits.addr, align 8
  %19 = load i64, ptr %lockbit.addr, align 8
  %call = call noundef zeroext i1 @_ZN4abslL13AtomicSetBitsEPSt6atomicIlEll(ptr noundef %17, i64 noundef %18, i64 noundef %19)
  br i1 %call, label %if.end20, label %if.then11

if.then11:                                        ; preds = %if.end9
  %20 = load i32, ptr %h, align 4
  %idxprom = zext i32 %20 to i64
  %arrayidx = getelementptr inbounds [1031 x ptr], ptr @_ZN4abslL11synch_eventE, i64 0, i64 %idxprom
  %21 = load ptr, ptr %arrayidx, align 8
  store ptr %21, ptr %e10, align 8
  br label %for.cond12

for.cond12:                                       ; preds = %for.inc17, %if.then11
  %22 = load ptr, ptr %e10, align 8
  %cmp13 = icmp ne ptr %22, null
  br i1 %cmp13, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond12
  %23 = load ptr, ptr %e10, align 8
  %masked_addr = getelementptr inbounds %"struct.absl::SynchEvent", ptr %23, i32 0, i32 2
  %24 = load i64, ptr %masked_addr, align 8
  %25 = load ptr, ptr %addr.addr, align 8
  %call14 = call noundef i64 @_ZN4absl13base_internal7HidePtrISt6atomicIlEEEmPT_(ptr noundef %25)
  %cmp15 = icmp ne i64 %24, %call14
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond12
  %26 = phi i1 [ false, %for.cond12 ], [ %cmp15, %land.rhs ]
  br i1 %26, label %for.body16, label %for.end19

for.body16:                                       ; preds = %land.end
  br label %for.inc17

for.inc17:                                        ; preds = %for.body16
  %27 = load ptr, ptr %e10, align 8
  %next18 = getelementptr inbounds %"struct.absl::SynchEvent", ptr %27, i32 0, i32 1
  %28 = load ptr, ptr %next18, align 8
  store ptr %28, ptr %e10, align 8
  br label %for.cond12, !llvm.loop !7

for.end19:                                        ; preds = %land.end
  br label %if.end20

if.end20:                                         ; preds = %for.end19, %if.end9
  %29 = load ptr, ptr %e10, align 8
  %cmp21 = icmp eq ptr %29, null
  br i1 %cmp21, label %if.then22, label %if.else

if.then22:                                        ; preds = %if.end20
  %30 = load ptr, ptr %name.addr, align 8
  %cmp23 = icmp eq ptr %30, null
  br i1 %cmp23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.then22
  store ptr @.str.35, ptr %name.addr, align 8
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %if.then22
  %31 = load ptr, ptr %name.addr, align 8
  %call26 = call i64 @strlen(ptr noundef %31) #15
  store i64 %call26, ptr %l, align 8
  %32 = load i64, ptr %l, align 8
  %add = add i64 48, %32
  %call27 = call noundef ptr @_ZN4absl13base_internal13LowLevelAlloc5AllocEm(i64 noundef %add)
  store ptr %call27, ptr %e10, align 8
  %33 = load ptr, ptr %e10, align 8
  %refcount28 = getelementptr inbounds %"struct.absl::SynchEvent", ptr %33, i32 0, i32 0
  store i32 2, ptr %refcount28, align 8
  %34 = load ptr, ptr %addr.addr, align 8
  %call29 = call noundef i64 @_ZN4absl13base_internal7HidePtrISt6atomicIlEEEmPT_(ptr noundef %34)
  %35 = load ptr, ptr %e10, align 8
  %masked_addr30 = getelementptr inbounds %"struct.absl::SynchEvent", ptr %35, i32 0, i32 2
  store i64 %call29, ptr %masked_addr30, align 8
  %36 = load ptr, ptr %e10, align 8
  %invariant = getelementptr inbounds %"struct.absl::SynchEvent", ptr %36, i32 0, i32 3
  store ptr null, ptr %invariant, align 8
  %37 = load ptr, ptr %e10, align 8
  %arg = getelementptr inbounds %"struct.absl::SynchEvent", ptr %37, i32 0, i32 4
  store ptr null, ptr %arg, align 8
  %38 = load ptr, ptr %e10, align 8
  %log = getelementptr inbounds %"struct.absl::SynchEvent", ptr %38, i32 0, i32 5
  store i8 0, ptr %log, align 8
  %39 = load ptr, ptr %e10, align 8
  %name31 = getelementptr inbounds %"struct.absl::SynchEvent", ptr %39, i32 0, i32 6
  %arraydecay = getelementptr inbounds [1 x i8], ptr %name31, i64 0, i64 0
  %40 = load ptr, ptr %name.addr, align 8
  %call32 = call ptr @strcpy(ptr noundef %arraydecay, ptr noundef %40) #13
  %41 = load i32, ptr %h, align 4
  %idxprom33 = zext i32 %41 to i64
  %arrayidx34 = getelementptr inbounds [1031 x ptr], ptr @_ZN4abslL11synch_eventE, i64 0, i64 %idxprom33
  %42 = load ptr, ptr %arrayidx34, align 8
  %43 = load ptr, ptr %e10, align 8
  %next35 = getelementptr inbounds %"struct.absl::SynchEvent", ptr %43, i32 0, i32 1
  store ptr %42, ptr %next35, align 8
  %44 = load ptr, ptr %e10, align 8
  %45 = load i32, ptr %h, align 4
  %idxprom36 = zext i32 %45 to i64
  %arrayidx37 = getelementptr inbounds [1031 x ptr], ptr @_ZN4abslL11synch_eventE, i64 0, i64 %idxprom36
  store ptr %44, ptr %arrayidx37, align 8
  br label %if.end40

if.else:                                          ; preds = %if.end20
  %46 = load ptr, ptr %e10, align 8
  %refcount38 = getelementptr inbounds %"struct.absl::SynchEvent", ptr %46, i32 0, i32 0
  %47 = load i32, ptr %refcount38, align 8
  %inc39 = add nsw i32 %47, 1
  store i32 %inc39, ptr %refcount38, align 8
  br label %if.end40

if.end40:                                         ; preds = %if.else, %if.end25
  call void @_ZN4absl13base_internal8SpinLock6UnlockEv(ptr noundef nonnull align 4 dereferenceable(4) @_ZN4abslL14synch_event_muE)
  %48 = load ptr, ptr %e10, align 8
  ret ptr %48
}

; Function Attrs: mustprogress uwtable
define internal void @_ZN4abslL15UnrefSynchEventEPNS_10SynchEventE(ptr noundef %e) #0 {
entry:
  %e.addr = alloca ptr, align 8
  %del = alloca i8, align 1
  store ptr %e, ptr %e.addr, align 8
  %0 = load ptr, ptr %e.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  call void @_ZN4absl13base_internal8SpinLock4LockEv(ptr noundef nonnull align 4 dereferenceable(4) @_ZN4abslL14synch_event_muE)
  %1 = load ptr, ptr %e.addr, align 8
  %refcount = getelementptr inbounds %"struct.absl::SynchEvent", ptr %1, i32 0, i32 0
  %2 = load i32, ptr %refcount, align 8
  %dec = add nsw i32 %2, -1
  store i32 %dec, ptr %refcount, align 8
  %cmp1 = icmp eq i32 %dec, 0
  %frombool = zext i1 %cmp1 to i8
  store i8 %frombool, ptr %del, align 1
  call void @_ZN4absl13base_internal8SpinLock6UnlockEv(ptr noundef nonnull align 4 dereferenceable(4) @_ZN4abslL14synch_event_muE)
  %3 = load i8, ptr %del, align 1
  %tobool = trunc i8 %3 to i1
  br i1 %tobool, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %4 = load ptr, ptr %e.addr, align 8
  call void @_ZN4absl13base_internal13LowLevelAlloc4FreeEPv(ptr noundef %4)
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  br label %if.end3

if.end3:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN4absl5Mutex4DtorEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define dso_local void @_ZN4absl29EnableMutexInvariantDebuggingEb(i1 noundef zeroext %enabled) #1 {
entry:
  %enabled.addr = alloca i8, align 1
  %frombool = zext i1 %enabled to i8
  store i8 %frombool, ptr %enabled.addr, align 1
  %0 = load i8, ptr %enabled.addr, align 1
  %tobool = trunc i8 %0 to i1
  call void @_ZNSt6atomicIbE5storeEbSt12memory_order(ptr noundef nonnull align 1 dereferenceable(1) @_ZN4absl12_GLOBAL__N_122synch_check_invariantsE, i1 noundef zeroext %tobool, i32 noundef 3) #13
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZNSt6atomicIbE5storeEbSt12memory_order(ptr noundef nonnull align 1 dereferenceable(1) %this, i1 noundef zeroext %__i, i32 noundef %__m) #1 comdat align 2 {
entry:
  %this.addr.i = alloca ptr, align 8
  %__i.addr.i = alloca i8, align 1
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %.atomictmp.i = alloca i8, align 1
  %this.addr = alloca ptr, align 8
  %__i.addr = alloca i8, align 1
  %__m.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %__i to i8
  store i8 %frombool, ptr %__i.addr, align 1
  store i32 %__m, ptr %__m.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %_M_base = getelementptr inbounds %"struct.std::atomic.11", ptr %this1, i32 0, i32 0
  %0 = load i8, ptr %__i.addr, align 1
  %tobool = trunc i8 %0 to i1
  %1 = load i32, ptr %__m.addr, align 4
  store ptr %_M_base, ptr %this.addr.i, align 8
  %frombool.i = zext i1 %tobool to i8
  store i8 %frombool.i, ptr %__i.addr.i, align 1
  store i32 %1, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %2 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %2, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %3 = load i32, ptr %__m.addr.i, align 4
  %4 = load i8, ptr %__i.addr.i, align 1
  %tobool.i = trunc i8 %4 to i1
  %frombool8.i = zext i1 %tobool.i to i8
  store i8 %frombool8.i, ptr %.atomictmp.i, align 1
  switch i32 %3, label %monotonic.i [
    i32 3, label %release.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %entry
  %5 = load i8, ptr %.atomictmp.i, align 1
  store atomic i8 %5, ptr %this1.i monotonic, align 1
  br label %_ZNSt13__atomic_baseIbE5storeEbSt12memory_order.exit

release.i:                                        ; preds = %entry
  %6 = load i8, ptr %.atomictmp.i, align 1
  store atomic i8 %6, ptr %this1.i release, align 1
  br label %_ZNSt13__atomic_baseIbE5storeEbSt12memory_order.exit

seqcst.i:                                         ; preds = %entry
  %7 = load i8, ptr %.atomictmp.i, align 1
  store atomic i8 %7, ptr %this1.i seq_cst, align 1
  br label %_ZNSt13__atomic_baseIbE5storeEbSt12memory_order.exit

_ZNSt13__atomic_baseIbE5storeEbSt12memory_order.exit: ; preds = %seqcst.i, %release.i, %monotonic.i
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN4absl5Mutex24EnableInvariantDebuggingEPFvPvES1_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %invariant, ptr noundef %arg) #0 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %invariant.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %e = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %invariant, ptr %invariant.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNKSt6atomicIbE4loadESt12memory_order(ptr noundef nonnull align 1 dereferenceable(1) @_ZN4absl12_GLOBAL__N_122synch_check_invariantsE, i32 noundef 2) #13
  br i1 %call, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %0 = load ptr, ptr %invariant.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %mu_ = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %call2 = call noundef ptr @_ZN4abslL16EnsureSynchEventEPSt6atomicIlEPKcll(ptr noundef %mu_, ptr noundef null, i64 noundef 16, i64 noundef 64)
  store ptr %call2, ptr %e, align 8
  %1 = load ptr, ptr %invariant.addr, align 8
  %2 = load ptr, ptr %e, align 8
  %invariant3 = getelementptr inbounds %"struct.absl::SynchEvent", ptr %2, i32 0, i32 3
  store ptr %1, ptr %invariant3, align 8
  %3 = load ptr, ptr %arg.addr, align 8
  %4 = load ptr, ptr %e, align 8
  %arg4 = getelementptr inbounds %"struct.absl::SynchEvent", ptr %4, i32 0, i32 4
  store ptr %3, ptr %arg4, align 8
  %5 = load ptr, ptr %e, align 8
  call void @_ZN4abslL15UnrefSynchEventEPNS_10SynchEventE(ptr noundef %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNKSt6atomicIbE4loadESt12memory_order(ptr noundef nonnull align 1 dereferenceable(1) %this, i32 noundef %__m) #1 comdat align 2 {
entry:
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i8, align 1
  %this.addr = alloca ptr, align 8
  %__m.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %__m, ptr %__m.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %_M_base = getelementptr inbounds %"struct.std::atomic.11", ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %__m.addr, align 4
  store ptr %_M_base, ptr %this.addr.i, align 8
  store i32 %0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %1 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %1, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %2 = load i32, ptr %__m.addr.i, align 4
  switch i32 %2, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %entry
  %3 = load atomic i8, ptr %this1.i monotonic, align 1
  store i8 %3, ptr %atomic-temp.i, align 1
  br label %_ZNKSt13__atomic_baseIbE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %entry, %entry
  %4 = load atomic i8, ptr %this1.i acquire, align 1
  store i8 %4, ptr %atomic-temp.i, align 1
  br label %_ZNKSt13__atomic_baseIbE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %entry
  %5 = load atomic i8, ptr %this1.i seq_cst, align 1
  store i8 %5, ptr %atomic-temp.i, align 1
  br label %_ZNKSt13__atomic_baseIbE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIbE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %6 = load i8, ptr %atomic-temp.i, align 1
  %tobool.i = trunc i8 %6 to i1
  ret i1 %tobool.i
}

; Function Attrs: mustprogress nounwind uwtable
define dso_local void @_ZN4absl29SetMutexDeadlockDetectionModeENS_15OnDeadlockCycleE(i32 noundef %mode) #1 {
entry:
  %mode.addr = alloca i32, align 4
  store i32 %mode, ptr %mode.addr, align 4
  %0 = load i32, ptr %mode.addr, align 4
  call void @_ZNSt6atomicIN4absl15OnDeadlockCycleEE5storeES1_St12memory_order(ptr noundef nonnull align 4 dereferenceable(4) @_ZN4absl12_GLOBAL__N_124synch_deadlock_detectionE, i32 noundef %0, i32 noundef 3) #13
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN4absl5Mutex9TryRemoveEPNS_13base_internal14PerThreadSynchE(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %s) #0 align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr.i57 = alloca ptr, align 8
  %__i1.addr.i58 = alloca ptr, align 8
  %__i2.addr.i59 = alloca i64, align 8
  %__m1.addr.i60 = alloca i32, align 4
  %__m2.addr.i61 = alloca i32, align 4
  %.atomictmp.i62 = alloca i64, align 8
  %cmpxchg.bool.i63 = alloca i8, align 1
  %this.addr.i52 = alloca ptr, align 8
  %__i1.addr.i = alloca ptr, align 8
  %__i2.addr.i = alloca i64, align 8
  %__m1.addr.i = alloca i32, align 4
  %__m2.addr.i = alloca i32, align 4
  %.atomictmp.i = alloca i64, align 8
  %cmpxchg.bool.i = alloca i8, align 1
  %this.addr.i42 = alloca ptr, align 8
  %__m.addr.i43 = alloca i32, align 4
  %__b.i44 = alloca i32, align 4
  %atomic-temp.i45 = alloca i64, align 8
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i64, align 8
  %this.addr = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %disable_rescheduling = alloca %"struct.absl::base_internal::SchedulingGuard::ScopedDisable", align 1
  %v = alloca i64, align 8
  %h = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %pw = alloca ptr, align 8
  %w = alloca ptr, align 8
  %nv = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4absl13base_internal15SchedulingGuard13ScopedDisableC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %disable_rescheduling)
  %mu_ = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  store ptr %mu_, ptr %this.addr.i42, align 8
  store i32 0, ptr %__m.addr.i43, align 4
  %this1.i46 = load ptr, ptr %this.addr.i42, align 8
  %0 = load i32, ptr %__m.addr.i43, align 4
  %call.i47 = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %0, i32 noundef 65535)
  store i32 %call.i47, ptr %__b.i44, align 4
  %1 = load i32, ptr %__m.addr.i43, align 4
  switch i32 %1, label %monotonic.i50 [
    i32 1, label %acquire.i49
    i32 2, label %acquire.i49
    i32 5, label %seqcst.i48
  ]

monotonic.i50:                                    ; preds = %entry
  %2 = load atomic i64, ptr %this1.i46 monotonic, align 8
  store i64 %2, ptr %atomic-temp.i45, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit51

acquire.i49:                                      ; preds = %entry, %entry
  %3 = load atomic i64, ptr %this1.i46 acquire, align 8
  store i64 %3, ptr %atomic-temp.i45, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit51

seqcst.i48:                                       ; preds = %entry
  %4 = load atomic i64, ptr %this1.i46 seq_cst, align 8
  store i64 %4, ptr %atomic-temp.i45, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit51

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit51: ; preds = %seqcst.i48, %acquire.i49, %monotonic.i50
  %5 = load i64, ptr %atomic-temp.i45, align 8
  store i64 %5, ptr %v, align 8
  %6 = load i64, ptr %v, align 8
  %and = and i64 %6, 77
  %cmp = icmp eq i64 %and, 4
  br i1 %cmp, label %land.lhs.true, label %if.end40

land.lhs.true:                                    ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit51
  %mu_2 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %7 = load i64, ptr %v, align 8
  %or = or i64 %7, 64
  %or3 = or i64 %or, 8
  store ptr %mu_2, ptr %this.addr.i52, align 8
  store ptr %v, ptr %__i1.addr.i, align 8
  store i64 %or3, ptr %__i2.addr.i, align 8
  store i32 2, ptr %__m1.addr.i, align 4
  store i32 0, ptr %__m2.addr.i, align 4
  %this1.i53 = load ptr, ptr %this.addr.i52, align 8
  %8 = load i32, ptr %__m1.addr.i, align 4
  %9 = load ptr, ptr %__i1.addr.i, align 8
  %10 = load i64, ptr %__i2.addr.i, align 8
  store i64 %10, ptr %.atomictmp.i, align 8
  %11 = load i32, ptr %__m2.addr.i, align 4
  switch i32 %8, label %monotonic.i56 [
    i32 1, label %acquire.i55
    i32 2, label %acquire.i55
    i32 3, label %release.i
    i32 4, label %acqrel.i
    i32 5, label %seqcst.i54
  ]

monotonic.i56:                                    ; preds = %land.lhs.true
  switch i32 %11, label %monotonic_fail.i [
    i32 1, label %acquire_fail.i
    i32 2, label %acquire_fail.i
    i32 5, label %seqcst_fail.i
  ]

acquire.i55:                                      ; preds = %land.lhs.true, %land.lhs.true
  switch i32 %11, label %monotonic_fail9.i [
    i32 1, label %acquire_fail10.i
    i32 2, label %acquire_fail10.i
    i32 5, label %seqcst_fail11.i
  ]

release.i:                                        ; preds = %land.lhs.true
  switch i32 %11, label %monotonic_fail22.i [
    i32 1, label %acquire_fail23.i
    i32 2, label %acquire_fail23.i
    i32 5, label %seqcst_fail24.i
  ]

acqrel.i:                                         ; preds = %land.lhs.true
  switch i32 %11, label %monotonic_fail35.i [
    i32 1, label %acquire_fail36.i
    i32 2, label %acquire_fail36.i
    i32 5, label %seqcst_fail37.i
  ]

seqcst.i54:                                       ; preds = %land.lhs.true
  switch i32 %11, label %monotonic_fail48.i [
    i32 1, label %acquire_fail49.i
    i32 2, label %acquire_fail49.i
    i32 5, label %seqcst_fail50.i
  ]

monotonic_fail.i:                                 ; preds = %monotonic.i56
  %12 = load i64, ptr %9, align 8
  %13 = load i64, ptr %.atomictmp.i, align 8
  %14 = cmpxchg ptr %this1.i53, i64 %12, i64 %13 monotonic monotonic, align 8
  %15 = extractvalue { i64, i1 } %14, 0
  %16 = extractvalue { i64, i1 } %14, 1
  br i1 %16, label %cmpxchg.continue.i, label %cmpxchg.store_expected.i

acquire_fail.i:                                   ; preds = %monotonic.i56, %monotonic.i56
  %17 = load i64, ptr %9, align 8
  %18 = load i64, ptr %.atomictmp.i, align 8
  %19 = cmpxchg ptr %this1.i53, i64 %17, i64 %18 monotonic acquire, align 8
  %20 = extractvalue { i64, i1 } %19, 0
  %21 = extractvalue { i64, i1 } %19, 1
  br i1 %21, label %cmpxchg.continue4.i, label %cmpxchg.store_expected3.i

seqcst_fail.i:                                    ; preds = %monotonic.i56
  %22 = load i64, ptr %9, align 8
  %23 = load i64, ptr %.atomictmp.i, align 8
  %24 = cmpxchg ptr %this1.i53, i64 %22, i64 %23 monotonic seq_cst, align 8
  %25 = extractvalue { i64, i1 } %24, 0
  %26 = extractvalue { i64, i1 } %24, 1
  br i1 %26, label %cmpxchg.continue7.i, label %cmpxchg.store_expected6.i

atomic.continue2.i:                               ; preds = %cmpxchg.continue7.i, %cmpxchg.continue4.i, %cmpxchg.continue.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected.i:                         ; preds = %monotonic_fail.i
  store i64 %15, ptr %9, align 8
  br label %cmpxchg.continue.i

cmpxchg.continue.i:                               ; preds = %cmpxchg.store_expected.i, %monotonic_fail.i
  %frombool.i = zext i1 %16 to i8
  store i8 %frombool.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected3.i:                        ; preds = %acquire_fail.i
  store i64 %20, ptr %9, align 8
  br label %cmpxchg.continue4.i

cmpxchg.continue4.i:                              ; preds = %cmpxchg.store_expected3.i, %acquire_fail.i
  %frombool5.i = zext i1 %21 to i8
  store i8 %frombool5.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected6.i:                        ; preds = %seqcst_fail.i
  store i64 %25, ptr %9, align 8
  br label %cmpxchg.continue7.i

cmpxchg.continue7.i:                              ; preds = %cmpxchg.store_expected6.i, %seqcst_fail.i
  %frombool8.i = zext i1 %26 to i8
  store i8 %frombool8.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

monotonic_fail9.i:                                ; preds = %acquire.i55
  %27 = load i64, ptr %9, align 8
  %28 = load i64, ptr %.atomictmp.i, align 8
  %29 = cmpxchg ptr %this1.i53, i64 %27, i64 %28 acquire monotonic, align 8
  %30 = extractvalue { i64, i1 } %29, 0
  %31 = extractvalue { i64, i1 } %29, 1
  br i1 %31, label %cmpxchg.continue14.i, label %cmpxchg.store_expected13.i

acquire_fail10.i:                                 ; preds = %acquire.i55, %acquire.i55
  %32 = load i64, ptr %9, align 8
  %33 = load i64, ptr %.atomictmp.i, align 8
  %34 = cmpxchg ptr %this1.i53, i64 %32, i64 %33 acquire acquire, align 8
  %35 = extractvalue { i64, i1 } %34, 0
  %36 = extractvalue { i64, i1 } %34, 1
  br i1 %36, label %cmpxchg.continue17.i, label %cmpxchg.store_expected16.i

seqcst_fail11.i:                                  ; preds = %acquire.i55
  %37 = load i64, ptr %9, align 8
  %38 = load i64, ptr %.atomictmp.i, align 8
  %39 = cmpxchg ptr %this1.i53, i64 %37, i64 %38 acquire seq_cst, align 8
  %40 = extractvalue { i64, i1 } %39, 0
  %41 = extractvalue { i64, i1 } %39, 1
  br i1 %41, label %cmpxchg.continue20.i, label %cmpxchg.store_expected19.i

atomic.continue12.i:                              ; preds = %cmpxchg.continue20.i, %cmpxchg.continue17.i, %cmpxchg.continue14.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected13.i:                       ; preds = %monotonic_fail9.i
  store i64 %30, ptr %9, align 8
  br label %cmpxchg.continue14.i

cmpxchg.continue14.i:                             ; preds = %cmpxchg.store_expected13.i, %monotonic_fail9.i
  %frombool15.i = zext i1 %31 to i8
  store i8 %frombool15.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected16.i:                       ; preds = %acquire_fail10.i
  store i64 %35, ptr %9, align 8
  br label %cmpxchg.continue17.i

cmpxchg.continue17.i:                             ; preds = %cmpxchg.store_expected16.i, %acquire_fail10.i
  %frombool18.i = zext i1 %36 to i8
  store i8 %frombool18.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected19.i:                       ; preds = %seqcst_fail11.i
  store i64 %40, ptr %9, align 8
  br label %cmpxchg.continue20.i

cmpxchg.continue20.i:                             ; preds = %cmpxchg.store_expected19.i, %seqcst_fail11.i
  %frombool21.i = zext i1 %41 to i8
  store i8 %frombool21.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

monotonic_fail22.i:                               ; preds = %release.i
  %42 = load i64, ptr %9, align 8
  %43 = load i64, ptr %.atomictmp.i, align 8
  %44 = cmpxchg ptr %this1.i53, i64 %42, i64 %43 release monotonic, align 8
  %45 = extractvalue { i64, i1 } %44, 0
  %46 = extractvalue { i64, i1 } %44, 1
  br i1 %46, label %cmpxchg.continue27.i, label %cmpxchg.store_expected26.i

acquire_fail23.i:                                 ; preds = %release.i, %release.i
  %47 = load i64, ptr %9, align 8
  %48 = load i64, ptr %.atomictmp.i, align 8
  %49 = cmpxchg ptr %this1.i53, i64 %47, i64 %48 release acquire, align 8
  %50 = extractvalue { i64, i1 } %49, 0
  %51 = extractvalue { i64, i1 } %49, 1
  br i1 %51, label %cmpxchg.continue30.i, label %cmpxchg.store_expected29.i

seqcst_fail24.i:                                  ; preds = %release.i
  %52 = load i64, ptr %9, align 8
  %53 = load i64, ptr %.atomictmp.i, align 8
  %54 = cmpxchg ptr %this1.i53, i64 %52, i64 %53 release seq_cst, align 8
  %55 = extractvalue { i64, i1 } %54, 0
  %56 = extractvalue { i64, i1 } %54, 1
  br i1 %56, label %cmpxchg.continue33.i, label %cmpxchg.store_expected32.i

atomic.continue25.i:                              ; preds = %cmpxchg.continue33.i, %cmpxchg.continue30.i, %cmpxchg.continue27.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected26.i:                       ; preds = %monotonic_fail22.i
  store i64 %45, ptr %9, align 8
  br label %cmpxchg.continue27.i

cmpxchg.continue27.i:                             ; preds = %cmpxchg.store_expected26.i, %monotonic_fail22.i
  %frombool28.i = zext i1 %46 to i8
  store i8 %frombool28.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected29.i:                       ; preds = %acquire_fail23.i
  store i64 %50, ptr %9, align 8
  br label %cmpxchg.continue30.i

cmpxchg.continue30.i:                             ; preds = %cmpxchg.store_expected29.i, %acquire_fail23.i
  %frombool31.i = zext i1 %51 to i8
  store i8 %frombool31.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected32.i:                       ; preds = %seqcst_fail24.i
  store i64 %55, ptr %9, align 8
  br label %cmpxchg.continue33.i

cmpxchg.continue33.i:                             ; preds = %cmpxchg.store_expected32.i, %seqcst_fail24.i
  %frombool34.i = zext i1 %56 to i8
  store i8 %frombool34.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

monotonic_fail35.i:                               ; preds = %acqrel.i
  %57 = load i64, ptr %9, align 8
  %58 = load i64, ptr %.atomictmp.i, align 8
  %59 = cmpxchg ptr %this1.i53, i64 %57, i64 %58 acq_rel monotonic, align 8
  %60 = extractvalue { i64, i1 } %59, 0
  %61 = extractvalue { i64, i1 } %59, 1
  br i1 %61, label %cmpxchg.continue40.i, label %cmpxchg.store_expected39.i

acquire_fail36.i:                                 ; preds = %acqrel.i, %acqrel.i
  %62 = load i64, ptr %9, align 8
  %63 = load i64, ptr %.atomictmp.i, align 8
  %64 = cmpxchg ptr %this1.i53, i64 %62, i64 %63 acq_rel acquire, align 8
  %65 = extractvalue { i64, i1 } %64, 0
  %66 = extractvalue { i64, i1 } %64, 1
  br i1 %66, label %cmpxchg.continue43.i, label %cmpxchg.store_expected42.i

seqcst_fail37.i:                                  ; preds = %acqrel.i
  %67 = load i64, ptr %9, align 8
  %68 = load i64, ptr %.atomictmp.i, align 8
  %69 = cmpxchg ptr %this1.i53, i64 %67, i64 %68 acq_rel seq_cst, align 8
  %70 = extractvalue { i64, i1 } %69, 0
  %71 = extractvalue { i64, i1 } %69, 1
  br i1 %71, label %cmpxchg.continue46.i, label %cmpxchg.store_expected45.i

atomic.continue38.i:                              ; preds = %cmpxchg.continue46.i, %cmpxchg.continue43.i, %cmpxchg.continue40.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected39.i:                       ; preds = %monotonic_fail35.i
  store i64 %60, ptr %9, align 8
  br label %cmpxchg.continue40.i

cmpxchg.continue40.i:                             ; preds = %cmpxchg.store_expected39.i, %monotonic_fail35.i
  %frombool41.i = zext i1 %61 to i8
  store i8 %frombool41.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected42.i:                       ; preds = %acquire_fail36.i
  store i64 %65, ptr %9, align 8
  br label %cmpxchg.continue43.i

cmpxchg.continue43.i:                             ; preds = %cmpxchg.store_expected42.i, %acquire_fail36.i
  %frombool44.i = zext i1 %66 to i8
  store i8 %frombool44.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected45.i:                       ; preds = %seqcst_fail37.i
  store i64 %70, ptr %9, align 8
  br label %cmpxchg.continue46.i

cmpxchg.continue46.i:                             ; preds = %cmpxchg.store_expected45.i, %seqcst_fail37.i
  %frombool47.i = zext i1 %71 to i8
  store i8 %frombool47.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

monotonic_fail48.i:                               ; preds = %seqcst.i54
  %72 = load i64, ptr %9, align 8
  %73 = load i64, ptr %.atomictmp.i, align 8
  %74 = cmpxchg ptr %this1.i53, i64 %72, i64 %73 seq_cst monotonic, align 8
  %75 = extractvalue { i64, i1 } %74, 0
  %76 = extractvalue { i64, i1 } %74, 1
  br i1 %76, label %cmpxchg.continue53.i, label %cmpxchg.store_expected52.i

acquire_fail49.i:                                 ; preds = %seqcst.i54, %seqcst.i54
  %77 = load i64, ptr %9, align 8
  %78 = load i64, ptr %.atomictmp.i, align 8
  %79 = cmpxchg ptr %this1.i53, i64 %77, i64 %78 seq_cst acquire, align 8
  %80 = extractvalue { i64, i1 } %79, 0
  %81 = extractvalue { i64, i1 } %79, 1
  br i1 %81, label %cmpxchg.continue56.i, label %cmpxchg.store_expected55.i

seqcst_fail50.i:                                  ; preds = %seqcst.i54
  %82 = load i64, ptr %9, align 8
  %83 = load i64, ptr %.atomictmp.i, align 8
  %84 = cmpxchg ptr %this1.i53, i64 %82, i64 %83 seq_cst seq_cst, align 8
  %85 = extractvalue { i64, i1 } %84, 0
  %86 = extractvalue { i64, i1 } %84, 1
  br i1 %86, label %cmpxchg.continue59.i, label %cmpxchg.store_expected58.i

atomic.continue51.i:                              ; preds = %cmpxchg.continue59.i, %cmpxchg.continue56.i, %cmpxchg.continue53.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected52.i:                       ; preds = %monotonic_fail48.i
  store i64 %75, ptr %9, align 8
  br label %cmpxchg.continue53.i

cmpxchg.continue53.i:                             ; preds = %cmpxchg.store_expected52.i, %monotonic_fail48.i
  %frombool54.i = zext i1 %76 to i8
  store i8 %frombool54.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected55.i:                       ; preds = %acquire_fail49.i
  store i64 %80, ptr %9, align 8
  br label %cmpxchg.continue56.i

cmpxchg.continue56.i:                             ; preds = %cmpxchg.store_expected55.i, %acquire_fail49.i
  %frombool57.i = zext i1 %81 to i8
  store i8 %frombool57.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected58.i:                       ; preds = %seqcst_fail50.i
  store i64 %85, ptr %9, align 8
  br label %cmpxchg.continue59.i

cmpxchg.continue59.i:                             ; preds = %cmpxchg.store_expected58.i, %seqcst_fail50.i
  %frombool60.i = zext i1 %86 to i8
  store i8 %frombool60.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit: ; preds = %atomic.continue51.i, %atomic.continue38.i, %atomic.continue25.i, %atomic.continue12.i, %atomic.continue2.i
  %87 = load i8, ptr %cmpxchg.bool.i, align 1
  %tobool.i = trunc i8 %87 to i1
  br i1 %tobool.i, label %if.then, label %if.end40

if.then:                                          ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit
  %88 = load i64, ptr %v, align 8
  %call5 = invoke noundef ptr @_ZN4abslL17GetPerThreadSynchEl(i64 noundef %88)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %if.then
  store ptr %call5, ptr %h, align 8
  %89 = load ptr, ptr %h, align 8
  %cmp6 = icmp ne ptr %89, null
  br i1 %cmp6, label %if.then7, label %if.end26

if.then7:                                         ; preds = %invoke.cont
  %90 = load ptr, ptr %h, align 8
  store ptr %90, ptr %pw, align 8
  %91 = load ptr, ptr %pw, align 8
  %next = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %91, i32 0, i32 0
  %92 = load ptr, ptr %next, align 8
  store ptr %92, ptr %w, align 8
  %93 = load ptr, ptr %s.addr, align 8
  %cmp8 = icmp ne ptr %92, %93
  br i1 %cmp8, label %if.then9, label %if.end19

if.then9:                                         ; preds = %if.then7
  br label %do.body

do.body:                                          ; preds = %land.end, %if.then9
  %94 = load ptr, ptr %s.addr, align 8
  %95 = load ptr, ptr %w, align 8
  %call11 = invoke noundef zeroext i1 @_ZN4abslL18MuEquivalentWaiterEPNS_13base_internal14PerThreadSynchES2_(ptr noundef %94, ptr noundef %95)
          to label %invoke.cont10 unwind label %lpad

invoke.cont10:                                    ; preds = %do.body
  br i1 %call11, label %if.else, label %if.then12

if.then12:                                        ; preds = %invoke.cont10
  %96 = load ptr, ptr %w, align 8
  %call14 = invoke noundef ptr @_ZN4abslL4SkipEPNS_13base_internal14PerThreadSynchE(ptr noundef %96)
          to label %invoke.cont13 unwind label %lpad

invoke.cont13:                                    ; preds = %if.then12
  store ptr %call14, ptr %pw, align 8
  br label %if.end

lpad:                                             ; preds = %if.then21, %if.else, %if.then12, %do.body, %if.then
  %97 = landingpad { ptr, i32 }
          cleanup
  %98 = extractvalue { ptr, i32 } %97, 0
  store ptr %98, ptr %exn.slot, align 8
  %99 = extractvalue { ptr, i32 } %97, 1
  store i32 %99, ptr %ehselector.slot, align 4
  call void @_ZN4absl13base_internal15SchedulingGuard13ScopedDisableD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %disable_rescheduling) #13
  br label %eh.resume

if.else:                                          ; preds = %invoke.cont10
  %100 = load ptr, ptr %w, align 8
  %101 = load ptr, ptr %s.addr, align 8
  invoke void @_ZN4abslL7FixSkipEPNS_13base_internal14PerThreadSynchES2_(ptr noundef %100, ptr noundef %101)
          to label %invoke.cont15 unwind label %lpad

invoke.cont15:                                    ; preds = %if.else
  %102 = load ptr, ptr %w, align 8
  store ptr %102, ptr %pw, align 8
  br label %if.end

if.end:                                           ; preds = %invoke.cont15, %invoke.cont13
  br label %do.cond

do.cond:                                          ; preds = %if.end
  %103 = load ptr, ptr %pw, align 8
  %next16 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %103, i32 0, i32 0
  %104 = load ptr, ptr %next16, align 8
  store ptr %104, ptr %w, align 8
  %105 = load ptr, ptr %s.addr, align 8
  %cmp17 = icmp ne ptr %104, %105
  br i1 %cmp17, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %do.cond
  %106 = load ptr, ptr %pw, align 8
  %107 = load ptr, ptr %h, align 8
  %cmp18 = icmp ne ptr %106, %107
  br label %land.end

land.end:                                         ; preds = %land.rhs, %do.cond
  %108 = phi i1 [ false, %do.cond ], [ %cmp18, %land.rhs ]
  br i1 %108, label %do.body, label %do.end, !llvm.loop !8

do.end:                                           ; preds = %land.end
  br label %if.end19

if.end19:                                         ; preds = %do.end, %if.then7
  %109 = load ptr, ptr %w, align 8
  %110 = load ptr, ptr %s.addr, align 8
  %cmp20 = icmp eq ptr %109, %110
  br i1 %cmp20, label %if.then21, label %if.end25

if.then21:                                        ; preds = %if.end19
  %111 = load ptr, ptr %h, align 8
  %112 = load ptr, ptr %pw, align 8
  %call23 = invoke noundef ptr @_ZN4abslL7DequeueEPNS_13base_internal14PerThreadSynchES2_(ptr noundef %111, ptr noundef %112)
          to label %invoke.cont22 unwind label %lpad

invoke.cont22:                                    ; preds = %if.then21
  store ptr %call23, ptr %h, align 8
  %113 = load ptr, ptr %s.addr, align 8
  %next24 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %113, i32 0, i32 0
  store ptr null, ptr %next24, align 8
  %114 = load ptr, ptr %s.addr, align 8
  %state = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %114, i32 0, i32 8
  call void @_ZNSt6atomicIN4absl13base_internal14PerThreadSynch5StateEE5storeES3_St12memory_order(ptr noundef nonnull align 4 dereferenceable(4) %state, i32 noundef 0, i32 noundef 3) #13
  br label %if.end25

if.end25:                                         ; preds = %invoke.cont22, %if.end19
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %invoke.cont
  br label %do.body27

do.body27:                                        ; preds = %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit, %if.end26
  %mu_28 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  store ptr %mu_28, ptr %this.addr.i, align 8
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %115 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %115, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %116 = load i32, ptr %__m.addr.i, align 4
  switch i32 %116, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %do.body27
  %117 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %117, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %do.body27, %do.body27
  %118 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %118, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %do.body27
  %119 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %119, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %120 = load i64, ptr %atomic-temp.i, align 8
  store i64 %120, ptr %v, align 8
  %121 = load i64, ptr %v, align 8
  %and30 = and i64 %121, 18
  store i64 %and30, ptr %nv, align 8
  %122 = load ptr, ptr %h, align 8
  %cmp31 = icmp ne ptr %122, null
  br i1 %cmp31, label %if.then32, label %if.end35

if.then32:                                        ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  %123 = load ptr, ptr %h, align 8
  %124 = ptrtoint ptr %123 to i64
  %or33 = or i64 4, %124
  %125 = load i64, ptr %nv, align 8
  %or34 = or i64 %125, %or33
  store i64 %or34, ptr %nv, align 8
  %126 = load ptr, ptr %h, align 8
  %readers = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %126, i32 0, i32 10
  store i64 0, ptr %readers, align 8
  %127 = load ptr, ptr %h, align 8
  %maybe_unlocking = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %127, i32 0, i32 5
  store i8 0, ptr %maybe_unlocking, align 1
  br label %if.end35

if.end35:                                         ; preds = %if.then32, %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  br label %do.cond36

do.cond36:                                        ; preds = %if.end35
  %mu_37 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %128 = load i64, ptr %nv, align 8
  store ptr %mu_37, ptr %this.addr.i57, align 8
  store ptr %v, ptr %__i1.addr.i58, align 8
  store i64 %128, ptr %__i2.addr.i59, align 8
  store i32 3, ptr %__m1.addr.i60, align 4
  store i32 0, ptr %__m2.addr.i61, align 4
  %this1.i64 = load ptr, ptr %this.addr.i57, align 8
  %129 = load i32, ptr %__m1.addr.i60, align 4
  %130 = load ptr, ptr %__i1.addr.i58, align 8
  %131 = load i64, ptr %__i2.addr.i59, align 8
  store i64 %131, ptr %.atomictmp.i62, align 8
  %132 = load i32, ptr %__m2.addr.i61, align 4
  switch i32 %129, label %monotonic.i122 [
    i32 1, label %acquire.i108
    i32 2, label %acquire.i108
    i32 3, label %release.i94
    i32 4, label %acqrel.i80
    i32 5, label %seqcst.i65
  ]

monotonic.i122:                                   ; preds = %do.cond36
  switch i32 %132, label %monotonic_fail.i132 [
    i32 1, label %acquire_fail.i128
    i32 2, label %acquire_fail.i128
    i32 5, label %seqcst_fail.i123
  ]

acquire.i108:                                     ; preds = %do.cond36, %do.cond36
  switch i32 %132, label %monotonic_fail9.i118 [
    i32 1, label %acquire_fail10.i114
    i32 2, label %acquire_fail10.i114
    i32 5, label %seqcst_fail11.i109
  ]

release.i94:                                      ; preds = %do.cond36
  switch i32 %132, label %monotonic_fail22.i104 [
    i32 1, label %acquire_fail23.i100
    i32 2, label %acquire_fail23.i100
    i32 5, label %seqcst_fail24.i95
  ]

acqrel.i80:                                       ; preds = %do.cond36
  switch i32 %132, label %monotonic_fail35.i90 [
    i32 1, label %acquire_fail36.i86
    i32 2, label %acquire_fail36.i86
    i32 5, label %seqcst_fail37.i81
  ]

seqcst.i65:                                       ; preds = %do.cond36
  switch i32 %132, label %monotonic_fail48.i76 [
    i32 1, label %acquire_fail49.i72
    i32 2, label %acquire_fail49.i72
    i32 5, label %seqcst_fail50.i66
  ]

monotonic_fail.i132:                              ; preds = %monotonic.i122
  %133 = load i64, ptr %130, align 8
  %134 = load i64, ptr %.atomictmp.i62, align 8
  %135 = cmpxchg weak ptr %this1.i64, i64 %133, i64 %134 monotonic monotonic, align 8
  %136 = extractvalue { i64, i1 } %135, 0
  %137 = extractvalue { i64, i1 } %135, 1
  br i1 %137, label %cmpxchg.continue.i134, label %cmpxchg.store_expected.i133

acquire_fail.i128:                                ; preds = %monotonic.i122, %monotonic.i122
  %138 = load i64, ptr %130, align 8
  %139 = load i64, ptr %.atomictmp.i62, align 8
  %140 = cmpxchg weak ptr %this1.i64, i64 %138, i64 %139 monotonic acquire, align 8
  %141 = extractvalue { i64, i1 } %140, 0
  %142 = extractvalue { i64, i1 } %140, 1
  br i1 %142, label %cmpxchg.continue4.i130, label %cmpxchg.store_expected3.i129

seqcst_fail.i123:                                 ; preds = %monotonic.i122
  %143 = load i64, ptr %130, align 8
  %144 = load i64, ptr %.atomictmp.i62, align 8
  %145 = cmpxchg weak ptr %this1.i64, i64 %143, i64 %144 monotonic seq_cst, align 8
  %146 = extractvalue { i64, i1 } %145, 0
  %147 = extractvalue { i64, i1 } %145, 1
  br i1 %147, label %cmpxchg.continue7.i125, label %cmpxchg.store_expected6.i124

atomic.continue2.i127:                            ; preds = %cmpxchg.continue7.i125, %cmpxchg.continue4.i130, %cmpxchg.continue.i134
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected.i133:                      ; preds = %monotonic_fail.i132
  store i64 %136, ptr %130, align 8
  br label %cmpxchg.continue.i134

cmpxchg.continue.i134:                            ; preds = %cmpxchg.store_expected.i133, %monotonic_fail.i132
  %frombool.i135 = zext i1 %137 to i8
  store i8 %frombool.i135, ptr %cmpxchg.bool.i63, align 1
  br label %atomic.continue2.i127

cmpxchg.store_expected3.i129:                     ; preds = %acquire_fail.i128
  store i64 %141, ptr %130, align 8
  br label %cmpxchg.continue4.i130

cmpxchg.continue4.i130:                           ; preds = %cmpxchg.store_expected3.i129, %acquire_fail.i128
  %frombool5.i131 = zext i1 %142 to i8
  store i8 %frombool5.i131, ptr %cmpxchg.bool.i63, align 1
  br label %atomic.continue2.i127

cmpxchg.store_expected6.i124:                     ; preds = %seqcst_fail.i123
  store i64 %146, ptr %130, align 8
  br label %cmpxchg.continue7.i125

cmpxchg.continue7.i125:                           ; preds = %cmpxchg.store_expected6.i124, %seqcst_fail.i123
  %frombool8.i126 = zext i1 %147 to i8
  store i8 %frombool8.i126, ptr %cmpxchg.bool.i63, align 1
  br label %atomic.continue2.i127

monotonic_fail9.i118:                             ; preds = %acquire.i108
  %148 = load i64, ptr %130, align 8
  %149 = load i64, ptr %.atomictmp.i62, align 8
  %150 = cmpxchg weak ptr %this1.i64, i64 %148, i64 %149 acquire monotonic, align 8
  %151 = extractvalue { i64, i1 } %150, 0
  %152 = extractvalue { i64, i1 } %150, 1
  br i1 %152, label %cmpxchg.continue14.i120, label %cmpxchg.store_expected13.i119

acquire_fail10.i114:                              ; preds = %acquire.i108, %acquire.i108
  %153 = load i64, ptr %130, align 8
  %154 = load i64, ptr %.atomictmp.i62, align 8
  %155 = cmpxchg weak ptr %this1.i64, i64 %153, i64 %154 acquire acquire, align 8
  %156 = extractvalue { i64, i1 } %155, 0
  %157 = extractvalue { i64, i1 } %155, 1
  br i1 %157, label %cmpxchg.continue17.i116, label %cmpxchg.store_expected16.i115

seqcst_fail11.i109:                               ; preds = %acquire.i108
  %158 = load i64, ptr %130, align 8
  %159 = load i64, ptr %.atomictmp.i62, align 8
  %160 = cmpxchg weak ptr %this1.i64, i64 %158, i64 %159 acquire seq_cst, align 8
  %161 = extractvalue { i64, i1 } %160, 0
  %162 = extractvalue { i64, i1 } %160, 1
  br i1 %162, label %cmpxchg.continue20.i111, label %cmpxchg.store_expected19.i110

atomic.continue12.i113:                           ; preds = %cmpxchg.continue20.i111, %cmpxchg.continue17.i116, %cmpxchg.continue14.i120
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected13.i119:                    ; preds = %monotonic_fail9.i118
  store i64 %151, ptr %130, align 8
  br label %cmpxchg.continue14.i120

cmpxchg.continue14.i120:                          ; preds = %cmpxchg.store_expected13.i119, %monotonic_fail9.i118
  %frombool15.i121 = zext i1 %152 to i8
  store i8 %frombool15.i121, ptr %cmpxchg.bool.i63, align 1
  br label %atomic.continue12.i113

cmpxchg.store_expected16.i115:                    ; preds = %acquire_fail10.i114
  store i64 %156, ptr %130, align 8
  br label %cmpxchg.continue17.i116

cmpxchg.continue17.i116:                          ; preds = %cmpxchg.store_expected16.i115, %acquire_fail10.i114
  %frombool18.i117 = zext i1 %157 to i8
  store i8 %frombool18.i117, ptr %cmpxchg.bool.i63, align 1
  br label %atomic.continue12.i113

cmpxchg.store_expected19.i110:                    ; preds = %seqcst_fail11.i109
  store i64 %161, ptr %130, align 8
  br label %cmpxchg.continue20.i111

cmpxchg.continue20.i111:                          ; preds = %cmpxchg.store_expected19.i110, %seqcst_fail11.i109
  %frombool21.i112 = zext i1 %162 to i8
  store i8 %frombool21.i112, ptr %cmpxchg.bool.i63, align 1
  br label %atomic.continue12.i113

monotonic_fail22.i104:                            ; preds = %release.i94
  %163 = load i64, ptr %130, align 8
  %164 = load i64, ptr %.atomictmp.i62, align 8
  %165 = cmpxchg weak ptr %this1.i64, i64 %163, i64 %164 release monotonic, align 8
  %166 = extractvalue { i64, i1 } %165, 0
  %167 = extractvalue { i64, i1 } %165, 1
  br i1 %167, label %cmpxchg.continue27.i106, label %cmpxchg.store_expected26.i105

acquire_fail23.i100:                              ; preds = %release.i94, %release.i94
  %168 = load i64, ptr %130, align 8
  %169 = load i64, ptr %.atomictmp.i62, align 8
  %170 = cmpxchg weak ptr %this1.i64, i64 %168, i64 %169 release acquire, align 8
  %171 = extractvalue { i64, i1 } %170, 0
  %172 = extractvalue { i64, i1 } %170, 1
  br i1 %172, label %cmpxchg.continue30.i102, label %cmpxchg.store_expected29.i101

seqcst_fail24.i95:                                ; preds = %release.i94
  %173 = load i64, ptr %130, align 8
  %174 = load i64, ptr %.atomictmp.i62, align 8
  %175 = cmpxchg weak ptr %this1.i64, i64 %173, i64 %174 release seq_cst, align 8
  %176 = extractvalue { i64, i1 } %175, 0
  %177 = extractvalue { i64, i1 } %175, 1
  br i1 %177, label %cmpxchg.continue33.i97, label %cmpxchg.store_expected32.i96

atomic.continue25.i99:                            ; preds = %cmpxchg.continue33.i97, %cmpxchg.continue30.i102, %cmpxchg.continue27.i106
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected26.i105:                    ; preds = %monotonic_fail22.i104
  store i64 %166, ptr %130, align 8
  br label %cmpxchg.continue27.i106

cmpxchg.continue27.i106:                          ; preds = %cmpxchg.store_expected26.i105, %monotonic_fail22.i104
  %frombool28.i107 = zext i1 %167 to i8
  store i8 %frombool28.i107, ptr %cmpxchg.bool.i63, align 1
  br label %atomic.continue25.i99

cmpxchg.store_expected29.i101:                    ; preds = %acquire_fail23.i100
  store i64 %171, ptr %130, align 8
  br label %cmpxchg.continue30.i102

cmpxchg.continue30.i102:                          ; preds = %cmpxchg.store_expected29.i101, %acquire_fail23.i100
  %frombool31.i103 = zext i1 %172 to i8
  store i8 %frombool31.i103, ptr %cmpxchg.bool.i63, align 1
  br label %atomic.continue25.i99

cmpxchg.store_expected32.i96:                     ; preds = %seqcst_fail24.i95
  store i64 %176, ptr %130, align 8
  br label %cmpxchg.continue33.i97

cmpxchg.continue33.i97:                           ; preds = %cmpxchg.store_expected32.i96, %seqcst_fail24.i95
  %frombool34.i98 = zext i1 %177 to i8
  store i8 %frombool34.i98, ptr %cmpxchg.bool.i63, align 1
  br label %atomic.continue25.i99

monotonic_fail35.i90:                             ; preds = %acqrel.i80
  %178 = load i64, ptr %130, align 8
  %179 = load i64, ptr %.atomictmp.i62, align 8
  %180 = cmpxchg weak ptr %this1.i64, i64 %178, i64 %179 acq_rel monotonic, align 8
  %181 = extractvalue { i64, i1 } %180, 0
  %182 = extractvalue { i64, i1 } %180, 1
  br i1 %182, label %cmpxchg.continue40.i92, label %cmpxchg.store_expected39.i91

acquire_fail36.i86:                               ; preds = %acqrel.i80, %acqrel.i80
  %183 = load i64, ptr %130, align 8
  %184 = load i64, ptr %.atomictmp.i62, align 8
  %185 = cmpxchg weak ptr %this1.i64, i64 %183, i64 %184 acq_rel acquire, align 8
  %186 = extractvalue { i64, i1 } %185, 0
  %187 = extractvalue { i64, i1 } %185, 1
  br i1 %187, label %cmpxchg.continue43.i88, label %cmpxchg.store_expected42.i87

seqcst_fail37.i81:                                ; preds = %acqrel.i80
  %188 = load i64, ptr %130, align 8
  %189 = load i64, ptr %.atomictmp.i62, align 8
  %190 = cmpxchg weak ptr %this1.i64, i64 %188, i64 %189 acq_rel seq_cst, align 8
  %191 = extractvalue { i64, i1 } %190, 0
  %192 = extractvalue { i64, i1 } %190, 1
  br i1 %192, label %cmpxchg.continue46.i83, label %cmpxchg.store_expected45.i82

atomic.continue38.i85:                            ; preds = %cmpxchg.continue46.i83, %cmpxchg.continue43.i88, %cmpxchg.continue40.i92
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected39.i91:                     ; preds = %monotonic_fail35.i90
  store i64 %181, ptr %130, align 8
  br label %cmpxchg.continue40.i92

cmpxchg.continue40.i92:                           ; preds = %cmpxchg.store_expected39.i91, %monotonic_fail35.i90
  %frombool41.i93 = zext i1 %182 to i8
  store i8 %frombool41.i93, ptr %cmpxchg.bool.i63, align 1
  br label %atomic.continue38.i85

cmpxchg.store_expected42.i87:                     ; preds = %acquire_fail36.i86
  store i64 %186, ptr %130, align 8
  br label %cmpxchg.continue43.i88

cmpxchg.continue43.i88:                           ; preds = %cmpxchg.store_expected42.i87, %acquire_fail36.i86
  %frombool44.i89 = zext i1 %187 to i8
  store i8 %frombool44.i89, ptr %cmpxchg.bool.i63, align 1
  br label %atomic.continue38.i85

cmpxchg.store_expected45.i82:                     ; preds = %seqcst_fail37.i81
  store i64 %191, ptr %130, align 8
  br label %cmpxchg.continue46.i83

cmpxchg.continue46.i83:                           ; preds = %cmpxchg.store_expected45.i82, %seqcst_fail37.i81
  %frombool47.i84 = zext i1 %192 to i8
  store i8 %frombool47.i84, ptr %cmpxchg.bool.i63, align 1
  br label %atomic.continue38.i85

monotonic_fail48.i76:                             ; preds = %seqcst.i65
  %193 = load i64, ptr %130, align 8
  %194 = load i64, ptr %.atomictmp.i62, align 8
  %195 = cmpxchg weak ptr %this1.i64, i64 %193, i64 %194 seq_cst monotonic, align 8
  %196 = extractvalue { i64, i1 } %195, 0
  %197 = extractvalue { i64, i1 } %195, 1
  br i1 %197, label %cmpxchg.continue53.i78, label %cmpxchg.store_expected52.i77

acquire_fail49.i72:                               ; preds = %seqcst.i65, %seqcst.i65
  %198 = load i64, ptr %130, align 8
  %199 = load i64, ptr %.atomictmp.i62, align 8
  %200 = cmpxchg weak ptr %this1.i64, i64 %198, i64 %199 seq_cst acquire, align 8
  %201 = extractvalue { i64, i1 } %200, 0
  %202 = extractvalue { i64, i1 } %200, 1
  br i1 %202, label %cmpxchg.continue56.i74, label %cmpxchg.store_expected55.i73

seqcst_fail50.i66:                                ; preds = %seqcst.i65
  %203 = load i64, ptr %130, align 8
  %204 = load i64, ptr %.atomictmp.i62, align 8
  %205 = cmpxchg weak ptr %this1.i64, i64 %203, i64 %204 seq_cst seq_cst, align 8
  %206 = extractvalue { i64, i1 } %205, 0
  %207 = extractvalue { i64, i1 } %205, 1
  br i1 %207, label %cmpxchg.continue59.i68, label %cmpxchg.store_expected58.i67

atomic.continue51.i70:                            ; preds = %cmpxchg.continue59.i68, %cmpxchg.continue56.i74, %cmpxchg.continue53.i78
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected52.i77:                     ; preds = %monotonic_fail48.i76
  store i64 %196, ptr %130, align 8
  br label %cmpxchg.continue53.i78

cmpxchg.continue53.i78:                           ; preds = %cmpxchg.store_expected52.i77, %monotonic_fail48.i76
  %frombool54.i79 = zext i1 %197 to i8
  store i8 %frombool54.i79, ptr %cmpxchg.bool.i63, align 1
  br label %atomic.continue51.i70

cmpxchg.store_expected55.i73:                     ; preds = %acquire_fail49.i72
  store i64 %201, ptr %130, align 8
  br label %cmpxchg.continue56.i74

cmpxchg.continue56.i74:                           ; preds = %cmpxchg.store_expected55.i73, %acquire_fail49.i72
  %frombool57.i75 = zext i1 %202 to i8
  store i8 %frombool57.i75, ptr %cmpxchg.bool.i63, align 1
  br label %atomic.continue51.i70

cmpxchg.store_expected58.i67:                     ; preds = %seqcst_fail50.i66
  store i64 %206, ptr %130, align 8
  br label %cmpxchg.continue59.i68

cmpxchg.continue59.i68:                           ; preds = %cmpxchg.store_expected58.i67, %seqcst_fail50.i66
  %frombool60.i69 = zext i1 %207 to i8
  store i8 %frombool60.i69, ptr %cmpxchg.bool.i63, align 1
  br label %atomic.continue51.i70

_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit: ; preds = %atomic.continue51.i70, %atomic.continue38.i85, %atomic.continue25.i99, %atomic.continue12.i113, %atomic.continue2.i127
  %208 = load i8, ptr %cmpxchg.bool.i63, align 1
  %tobool.i71 = trunc i8 %208 to i1
  %lnot = xor i1 %tobool.i71, true
  br i1 %lnot, label %do.body27, label %do.end39, !llvm.loop !9

do.end39:                                         ; preds = %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit
  br label %if.end40

if.end40:                                         ; preds = %do.end39, %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit, %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit51
  call void @_ZN4absl13base_internal15SchedulingGuard13ScopedDisableD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %disable_rescheduling) #13
  ret void

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val41 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val41
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN4absl13base_internal15SchedulingGuard13ScopedDisableC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZN4absl13base_internal15SchedulingGuard19DisableReschedulingEv()
  %disabled = getelementptr inbounds %"struct.absl::base_internal::SchedulingGuard::ScopedDisable", ptr %this1, i32 0, i32 0
  %frombool = zext i1 %call to i8
  store i8 %frombool, ptr %disabled, align 1
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef ptr @_ZN4abslL17GetPerThreadSynchEl(i64 noundef %v) #1 {
entry:
  %v.addr = alloca i64, align 8
  store i64 %v, ptr %v.addr, align 8
  %0 = load i64, ptr %v.addr, align 8
  %and = and i64 %0, -256
  %1 = inttoptr i64 %and to ptr
  ret ptr %1
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef zeroext i1 @_ZN4abslL18MuEquivalentWaiterEPNS_13base_internal14PerThreadSynchES2_(ptr noundef %x, ptr noundef %y) #1 {
entry:
  %x.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %waitp = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %0, i32 0, i32 9
  %1 = load ptr, ptr %waitp, align 8
  %how = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %how, align 8
  %3 = load ptr, ptr %y.addr, align 8
  %waitp1 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %3, i32 0, i32 9
  %4 = load ptr, ptr %waitp1, align 8
  %how2 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %how2, align 8
  %cmp = icmp eq ptr %2, %5
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %6 = load ptr, ptr %x.addr, align 8
  %priority = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %6, i32 0, i32 7
  %7 = load i32, ptr %priority, align 8
  %8 = load ptr, ptr %y.addr, align 8
  %priority3 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %8, i32 0, i32 7
  %9 = load i32, ptr %priority3, align 8
  %cmp4 = icmp eq i32 %7, %9
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %10 = load ptr, ptr %x.addr, align 8
  %waitp5 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %10, i32 0, i32 9
  %11 = load ptr, ptr %waitp5, align 8
  %cond = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %11, i32 0, i32 1
  %12 = load ptr, ptr %cond, align 8
  %13 = load ptr, ptr %y.addr, align 8
  %waitp6 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %13, i32 0, i32 9
  %14 = load ptr, ptr %waitp6, align 8
  %cond7 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %14, i32 0, i32 1
  %15 = load ptr, ptr %cond7, align 8
  %call = call noundef zeroext i1 @_ZN4absl9Condition15GuaranteedEqualEPKS0_S2_(ptr noundef %12, ptr noundef %15)
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %16 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %call, %land.rhs ]
  ret i1 %16
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef ptr @_ZN4abslL4SkipEPNS_13base_internal14PerThreadSynchE(ptr noundef %x) #1 {
entry:
  %x.addr = alloca ptr, align 8
  %x0 = alloca ptr, align 8
  %x1 = alloca ptr, align 8
  %x2 = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  store ptr null, ptr %x0, align 8
  %0 = load ptr, ptr %x.addr, align 8
  store ptr %0, ptr %x1, align 8
  %1 = load ptr, ptr %x.addr, align 8
  %skip = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %skip, align 8
  store ptr %2, ptr %x2, align 8
  %3 = load ptr, ptr %x2, align 8
  %cmp = icmp ne ptr %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %4 = load ptr, ptr %x1, align 8
  store ptr %4, ptr %x0, align 8
  %5 = load ptr, ptr %x2, align 8
  store ptr %5, ptr %x1, align 8
  %6 = load ptr, ptr %x2, align 8
  %skip1 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %skip1, align 8
  store ptr %7, ptr %x2, align 8
  %cmp2 = icmp ne ptr %7, null
  br i1 %cmp2, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %8 = load ptr, ptr %x2, align 8
  %9 = load ptr, ptr %x0, align 8
  %skip3 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %9, i32 0, i32 1
  store ptr %8, ptr %skip3, align 8
  br label %while.cond, !llvm.loop !10

while.end:                                        ; preds = %while.cond
  %10 = load ptr, ptr %x1, align 8
  %11 = load ptr, ptr %x.addr, align 8
  %skip4 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %11, i32 0, i32 1
  store ptr %10, ptr %skip4, align 8
  br label %if.end

if.end:                                           ; preds = %while.end, %entry
  %12 = load ptr, ptr %x1, align 8
  ret ptr %12
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZN4abslL7FixSkipEPNS_13base_internal14PerThreadSynchES2_(ptr noundef %ancestor, ptr noundef %to_be_removed) #1 {
entry:
  %ancestor.addr = alloca ptr, align 8
  %to_be_removed.addr = alloca ptr, align 8
  store ptr %ancestor, ptr %ancestor.addr, align 8
  store ptr %to_be_removed, ptr %to_be_removed.addr, align 8
  %0 = load ptr, ptr %ancestor.addr, align 8
  %skip = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %skip, align 8
  %2 = load ptr, ptr %to_be_removed.addr, align 8
  %cmp = icmp eq ptr %1, %2
  br i1 %cmp, label %if.then, label %if.end13

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %to_be_removed.addr, align 8
  %skip1 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %skip1, align 8
  %cmp2 = icmp ne ptr %4, null
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.then
  %5 = load ptr, ptr %to_be_removed.addr, align 8
  %skip4 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %skip4, align 8
  %7 = load ptr, ptr %ancestor.addr, align 8
  %skip5 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %7, i32 0, i32 1
  store ptr %6, ptr %skip5, align 8
  br label %if.end12

if.else:                                          ; preds = %if.then
  %8 = load ptr, ptr %ancestor.addr, align 8
  %next = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %8, i32 0, i32 0
  %9 = load ptr, ptr %next, align 8
  %10 = load ptr, ptr %to_be_removed.addr, align 8
  %cmp6 = icmp ne ptr %9, %10
  br i1 %cmp6, label %if.then7, label %if.else10

if.then7:                                         ; preds = %if.else
  %11 = load ptr, ptr %ancestor.addr, align 8
  %next8 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %11, i32 0, i32 0
  %12 = load ptr, ptr %next8, align 8
  %13 = load ptr, ptr %ancestor.addr, align 8
  %skip9 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %13, i32 0, i32 1
  store ptr %12, ptr %skip9, align 8
  br label %if.end

if.else10:                                        ; preds = %if.else
  %14 = load ptr, ptr %ancestor.addr, align 8
  %skip11 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %14, i32 0, i32 1
  store ptr null, ptr %skip11, align 8
  br label %if.end

if.end:                                           ; preds = %if.else10, %if.then7
  br label %if.end12

if.end12:                                         ; preds = %if.end, %if.then3
  br label %if.end13

if.end13:                                         ; preds = %if.end12, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef ptr @_ZN4abslL7DequeueEPNS_13base_internal14PerThreadSynchES2_(ptr noundef %head, ptr noundef %pw) #1 {
entry:
  %head.addr = alloca ptr, align 8
  %pw.addr = alloca ptr, align 8
  %w = alloca ptr, align 8
  store ptr %head, ptr %head.addr, align 8
  store ptr %pw, ptr %pw.addr, align 8
  %0 = load ptr, ptr %pw.addr, align 8
  %next = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %next, align 8
  store ptr %1, ptr %w, align 8
  %2 = load ptr, ptr %w, align 8
  %next1 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %next1, align 8
  %4 = load ptr, ptr %pw.addr, align 8
  %next2 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %4, i32 0, i32 0
  store ptr %3, ptr %next2, align 8
  %5 = load ptr, ptr %head.addr, align 8
  %6 = load ptr, ptr %w, align 8
  %cmp = icmp eq ptr %5, %6
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %7 = load ptr, ptr %pw.addr, align 8
  %8 = load ptr, ptr %w, align 8
  %cmp3 = icmp eq ptr %7, %8
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %9 = load ptr, ptr %pw.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ null, %cond.true ], [ %9, %cond.false ]
  store ptr %cond, ptr %head.addr, align 8
  br label %if.end17

if.else:                                          ; preds = %entry
  %10 = load ptr, ptr %pw.addr, align 8
  %11 = load ptr, ptr %head.addr, align 8
  %cmp4 = icmp ne ptr %10, %11
  br i1 %cmp4, label %land.lhs.true, label %if.end16

land.lhs.true:                                    ; preds = %if.else
  %12 = load ptr, ptr %pw.addr, align 8
  %13 = load ptr, ptr %pw.addr, align 8
  %next5 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %13, i32 0, i32 0
  %14 = load ptr, ptr %next5, align 8
  %call = call noundef zeroext i1 @_ZN4abslL18MuEquivalentWaiterEPNS_13base_internal14PerThreadSynchES2_(ptr noundef %12, ptr noundef %14)
  br i1 %call, label %if.then6, label %if.end16

if.then6:                                         ; preds = %land.lhs.true
  %15 = load ptr, ptr %pw.addr, align 8
  %next7 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %15, i32 0, i32 0
  %16 = load ptr, ptr %next7, align 8
  %skip = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %16, i32 0, i32 1
  %17 = load ptr, ptr %skip, align 8
  %cmp8 = icmp ne ptr %17, null
  br i1 %cmp8, label %if.then9, label %if.else13

if.then9:                                         ; preds = %if.then6
  %18 = load ptr, ptr %pw.addr, align 8
  %next10 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %18, i32 0, i32 0
  %19 = load ptr, ptr %next10, align 8
  %skip11 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %19, i32 0, i32 1
  %20 = load ptr, ptr %skip11, align 8
  %21 = load ptr, ptr %pw.addr, align 8
  %skip12 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %21, i32 0, i32 1
  store ptr %20, ptr %skip12, align 8
  br label %if.end

if.else13:                                        ; preds = %if.then6
  %22 = load ptr, ptr %pw.addr, align 8
  %next14 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %22, i32 0, i32 0
  %23 = load ptr, ptr %next14, align 8
  %24 = load ptr, ptr %pw.addr, align 8
  %skip15 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %24, i32 0, i32 1
  store ptr %23, ptr %skip15, align 8
  br label %if.end

if.end:                                           ; preds = %if.else13, %if.then9
  br label %if.end16

if.end16:                                         ; preds = %if.end, %land.lhs.true, %if.else
  br label %if.end17

if.end17:                                         ; preds = %if.end16, %cond.end
  %25 = load ptr, ptr %head.addr, align 8
  ret ptr %25
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZNSt6atomicIN4absl13base_internal14PerThreadSynch5StateEE5storeES3_St12memory_order(ptr noundef nonnull align 4 dereferenceable(4) %this, i32 noundef %__i, i32 noundef %__m) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %__i.addr = alloca i32, align 4
  %__m.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %__i, ptr %__i.addr, align 4
  store i32 %__m, ptr %__m.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %_M_i = getelementptr inbounds %"struct.std::atomic.10", ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %__m.addr, align 4
  switch i32 %0, label %monotonic [
    i32 3, label %release
    i32 5, label %seqcst
  ]

monotonic:                                        ; preds = %entry
  %1 = load i32, ptr %__i.addr, align 4
  store atomic i32 %1, ptr %_M_i monotonic, align 4
  br label %atomic.continue

release:                                          ; preds = %entry
  %2 = load i32, ptr %__i.addr, align 4
  store atomic i32 %2, ptr %_M_i release, align 4
  br label %atomic.continue

seqcst:                                           ; preds = %entry
  %3 = load i32, ptr %__i.addr, align 4
  store atomic i32 %3, ptr %_M_i seq_cst, align 4
  br label %atomic.continue

atomic.continue:                                  ; preds = %seqcst, %release, %monotonic
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN4absl13base_internal15SchedulingGuard13ScopedDisableD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %disabled = getelementptr inbounds %"struct.absl::base_internal::SchedulingGuard::ScopedDisable", ptr %this1, i32 0, i32 0
  %0 = load i8, ptr %disabled, align 1
  %tobool = trunc i8 %0 to i1
  call void @_ZN4absl13base_internal15SchedulingGuard18EnableReschedulingEb(i1 noundef zeroext %tobool)
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN4absl5Mutex5BlockEPNS_13base_internal14PerThreadSynchE(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %s) #0 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.absl::synchronization_internal::KernelTimeout", align 8
  %c = alloca i32, align 4
  %ref.tmp = alloca %"class.absl::synchronization_internal::KernelTimeout", align 8
  %absl_raw_log_internal_basename = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %0 = load ptr, ptr %s.addr, align 8
  %state = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %0, i32 0, i32 8
  %call = call noundef i32 @_ZNKSt6atomicIN4absl13base_internal14PerThreadSynch5StateEE4loadESt12memory_order(ptr noundef nonnull align 4 dereferenceable(4) %state, i32 noundef 2) #13
  %cmp = icmp eq i32 %call, 1
  br i1 %cmp, label %while.body, label %while.end12

while.body:                                       ; preds = %while.cond
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load ptr, ptr %s.addr, align 8
  %waitp = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %2, i32 0, i32 9
  %3 = load ptr, ptr %waitp, align 8
  %timeout = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %3, i32 0, i32 2
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %timeout, i64 8, i1 false)
  %coerce.dive = getelementptr inbounds %"class.absl::synchronization_internal::KernelTimeout", ptr %agg.tmp, i32 0, i32 0
  %4 = load i64, ptr %coerce.dive, align 8
  %call2 = call noundef zeroext i1 @_ZN4absl5Mutex17DecrementSynchSemEPS0_PNS_13base_internal14PerThreadSynchENS_24synchronization_internal13KernelTimeoutE(ptr noundef %this1, ptr noundef %1, i64 %4)
  br i1 %call2, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  %5 = load ptr, ptr %s.addr, align 8
  call void @_ZN4absl5Mutex9TryRemoveEPNS_13base_internal14PerThreadSynchE(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef %5)
  store i32 0, ptr %c, align 4
  br label %while.cond3

while.cond3:                                      ; preds = %while.body5, %if.then
  %6 = load ptr, ptr %s.addr, align 8
  %next = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %6, i32 0, i32 0
  %7 = load ptr, ptr %next, align 8
  %cmp4 = icmp ne ptr %7, null
  br i1 %cmp4, label %while.body5, label %while.end

while.body5:                                      ; preds = %while.cond3
  %8 = load i32, ptr %c, align 4
  %call6 = call noundef i32 @_ZN4absl24synchronization_internal10MutexDelayEii(i32 noundef %8, i32 noundef 1)
  store i32 %call6, ptr %c, align 4
  %9 = load ptr, ptr %s.addr, align 8
  call void @_ZN4absl5Mutex9TryRemoveEPNS_13base_internal14PerThreadSynchE(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef %9)
  br label %while.cond3, !llvm.loop !11

while.end:                                        ; preds = %while.cond3
  %call7 = call i64 @_ZN4absl24synchronization_internal13KernelTimeout5NeverEv()
  %coerce.dive8 = getelementptr inbounds %"class.absl::synchronization_internal::KernelTimeout", ptr %ref.tmp, i32 0, i32 0
  store i64 %call7, ptr %coerce.dive8, align 8
  %10 = load ptr, ptr %s.addr, align 8
  %waitp9 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %10, i32 0, i32 9
  %11 = load ptr, ptr %waitp9, align 8
  %timeout10 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %11, i32 0, i32 2
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %timeout10, ptr align 8 %ref.tmp, i64 8, i1 false)
  %12 = load ptr, ptr %s.addr, align 8
  %waitp11 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %12, i32 0, i32 9
  %13 = load ptr, ptr %waitp11, align 8
  %cond = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %13, i32 0, i32 1
  store ptr null, ptr %cond, align 8
  br label %if.end

if.end:                                           ; preds = %while.end, %while.body
  br label %while.cond, !llvm.loop !12

while.end12:                                      ; preds = %while.cond
  br label %do.body

do.body:                                          ; preds = %while.end12
  %14 = load ptr, ptr %s.addr, align 8
  %waitp13 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %14, i32 0, i32 9
  %15 = load ptr, ptr %waitp13, align 8
  %cmp14 = icmp ne ptr %15, null
  br i1 %cmp14, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %do.body
  %16 = load ptr, ptr %s.addr, align 8
  %suppress_fatal_errors = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %16, i32 0, i32 6
  %17 = load i8, ptr %suppress_fatal_errors, align 4
  %tobool = trunc i8 %17 to i1
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %do.body
  %18 = phi i1 [ true, %do.body ], [ %tobool, %lor.rhs ]
  %lnot = xor i1 %18, true
  br i1 %lnot, label %if.then15, label %if.end19

if.then15:                                        ; preds = %lor.end
  br label %do.body16

do.body16:                                        ; preds = %if.then15
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename, align 8
  call void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 1184, ptr noundef @.str.1, ptr noundef @.str.2, ptr noundef @.str.3)
  br label %do.body17

do.body17:                                        ; preds = %do.body16
  unreachable

do.end:                                           ; No predecessors!
  br label %do.end18

do.end18:                                         ; preds = %do.end
  br label %if.end19

if.end19:                                         ; preds = %do.end18, %lor.end
  br label %do.end20

do.end20:                                         ; preds = %if.end19
  %19 = load ptr, ptr %s.addr, align 8
  %waitp21 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %19, i32 0, i32 9
  store ptr null, ptr %waitp21, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNKSt6atomicIN4absl13base_internal14PerThreadSynch5StateEE4loadESt12memory_order(ptr noundef nonnull align 4 dereferenceable(4) %this, i32 noundef %__m) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %__m.addr = alloca i32, align 4
  %__buf = alloca [4 x i8], align 4
  %__ptr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %__m, ptr %__m.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %arraydecay = getelementptr inbounds [4 x i8], ptr %__buf, i64 0, i64 0
  store ptr %arraydecay, ptr %__ptr, align 8
  %_M_i = getelementptr inbounds %"struct.std::atomic.10", ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %__m.addr, align 4
  %1 = load ptr, ptr %__ptr, align 8
  switch i32 %0, label %monotonic [
    i32 1, label %acquire
    i32 2, label %acquire
    i32 5, label %seqcst
  ]

monotonic:                                        ; preds = %entry
  %2 = load atomic i32, ptr %_M_i monotonic, align 4
  store i32 %2, ptr %1, align 4
  br label %atomic.continue

acquire:                                          ; preds = %entry, %entry
  %3 = load atomic i32, ptr %_M_i acquire, align 4
  store i32 %3, ptr %1, align 4
  br label %atomic.continue

seqcst:                                           ; preds = %entry
  %4 = load atomic i32, ptr %_M_i seq_cst, align 4
  store i32 %4, ptr %1, align 4
  br label %atomic.continue

atomic.continue:                                  ; preds = %seqcst, %acquire, %monotonic
  %5 = load ptr, ptr %__ptr, align 8
  %6 = load i32, ptr %5, align 4
  ret i32 %6
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local i64 @_ZN4absl24synchronization_internal13KernelTimeout5NeverEv() #0 comdat align 2 {
entry:
  %retval = alloca %"class.absl::synchronization_internal::KernelTimeout", align 8
  call void @_ZN4absl24synchronization_internal13KernelTimeoutC2Ev(ptr noundef nonnull align 8 dereferenceable(8) %retval)
  %coerce.dive = getelementptr inbounds %"class.absl::synchronization_internal::KernelTimeout", ptr %retval, i32 0, i32 0
  %0 = load i64, ptr %coerce.dive, align 8
  ret i64 %0
}

declare void @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef, ptr noundef, i32 noundef, ptr noundef, ...) #3

; Function Attrs: mustprogress uwtable
define dso_local noundef ptr @_ZN4absl5Mutex6WakeupEPNS_13base_internal14PerThreadSynchE(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %w) #0 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %w.addr = alloca ptr, align 8
  %next = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %w, ptr %w.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %w.addr, align 8
  %next2 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %next2, align 8
  store ptr %1, ptr %next, align 8
  %2 = load ptr, ptr %w.addr, align 8
  %next3 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %2, i32 0, i32 0
  store ptr null, ptr %next3, align 8
  %3 = load ptr, ptr %w.addr, align 8
  %state = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %3, i32 0, i32 8
  call void @_ZNSt6atomicIN4absl13base_internal14PerThreadSynch5StateEE5storeES3_St12memory_order(ptr noundef nonnull align 4 dereferenceable(4) %state, i32 noundef 0, i32 noundef 3) #13
  %4 = load ptr, ptr %w.addr, align 8
  call void @_ZN4absl5Mutex17IncrementSynchSemEPS0_PNS_13base_internal14PerThreadSynchE(ptr noundef %this1, ptr noundef %4)
  %5 = load ptr, ptr %next, align 8
  ret ptr %5
}

; Function Attrs: mustprogress nounwind uwtable
define dso_local void @_ZN4absl5Mutex18ForgetDeadlockInfoEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define dso_local void @_ZNK4absl5Mutex13AssertNotHeldEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN4absl5Mutex4LockEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 align 2 {
entry:
  %this.addr.i11 = alloca ptr, align 8
  %__i1.addr.i = alloca ptr, align 8
  %__i2.addr.i = alloca i64, align 8
  %__m1.addr.i = alloca i32, align 4
  %__m2.addr.i = alloca i32, align 4
  %.atomictmp.i = alloca i64, align 8
  %cmpxchg.bool.i = alloca i8, align 1
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i64, align 8
  %this.addr = alloca ptr, align 8
  %id = alloca %"struct.absl::synchronization_internal::GraphId", align 8
  %v = alloca i64, align 8
  %agg.tmp = alloca %"struct.absl::synchronization_internal::GraphId", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call i64 @_ZN4abslL22DebugOnlyDeadlockCheckEPNS_5MutexE(ptr noundef %this1)
  %coerce.dive = getelementptr inbounds %"struct.absl::synchronization_internal::GraphId", ptr %id, i32 0, i32 0
  store i64 %call, ptr %coerce.dive, align 8
  %mu_ = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  store ptr %mu_, ptr %this.addr.i, align 8
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %0 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %0, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %1 = load i32, ptr %__m.addr.i, align 4
  switch i32 %1, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %entry
  %2 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %2, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %entry, %entry
  %3 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %3, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %entry
  %4 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %4, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %5 = load i64, ptr %atomic-temp.i, align 8
  store i64 %5, ptr %v, align 8
  %6 = load i64, ptr %v, align 8
  %and = and i64 %6, 25
  %cmp = icmp ne i64 %and, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  %mu_3 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %7 = load i64, ptr %v, align 8
  %or = or i64 8, %7
  store ptr %mu_3, ptr %this.addr.i11, align 8
  store ptr %v, ptr %__i1.addr.i, align 8
  store i64 %or, ptr %__i2.addr.i, align 8
  store i32 2, ptr %__m1.addr.i, align 4
  store i32 0, ptr %__m2.addr.i, align 4
  %this1.i12 = load ptr, ptr %this.addr.i11, align 8
  %8 = load i32, ptr %__m1.addr.i, align 4
  %9 = load ptr, ptr %__i1.addr.i, align 8
  %10 = load i64, ptr %__i2.addr.i, align 8
  store i64 %10, ptr %.atomictmp.i, align 8
  %11 = load i32, ptr %__m2.addr.i, align 4
  switch i32 %8, label %monotonic.i15 [
    i32 1, label %acquire.i14
    i32 2, label %acquire.i14
    i32 3, label %release.i
    i32 4, label %acqrel.i
    i32 5, label %seqcst.i13
  ]

monotonic.i15:                                    ; preds = %lor.lhs.false
  switch i32 %11, label %monotonic_fail.i [
    i32 1, label %acquire_fail.i
    i32 2, label %acquire_fail.i
    i32 5, label %seqcst_fail.i
  ]

acquire.i14:                                      ; preds = %lor.lhs.false, %lor.lhs.false
  switch i32 %11, label %monotonic_fail9.i [
    i32 1, label %acquire_fail10.i
    i32 2, label %acquire_fail10.i
    i32 5, label %seqcst_fail11.i
  ]

release.i:                                        ; preds = %lor.lhs.false
  switch i32 %11, label %monotonic_fail22.i [
    i32 1, label %acquire_fail23.i
    i32 2, label %acquire_fail23.i
    i32 5, label %seqcst_fail24.i
  ]

acqrel.i:                                         ; preds = %lor.lhs.false
  switch i32 %11, label %monotonic_fail35.i [
    i32 1, label %acquire_fail36.i
    i32 2, label %acquire_fail36.i
    i32 5, label %seqcst_fail37.i
  ]

seqcst.i13:                                       ; preds = %lor.lhs.false
  switch i32 %11, label %monotonic_fail48.i [
    i32 1, label %acquire_fail49.i
    i32 2, label %acquire_fail49.i
    i32 5, label %seqcst_fail50.i
  ]

monotonic_fail.i:                                 ; preds = %monotonic.i15
  %12 = load i64, ptr %9, align 8
  %13 = load i64, ptr %.atomictmp.i, align 8
  %14 = cmpxchg ptr %this1.i12, i64 %12, i64 %13 monotonic monotonic, align 8
  %15 = extractvalue { i64, i1 } %14, 0
  %16 = extractvalue { i64, i1 } %14, 1
  br i1 %16, label %cmpxchg.continue.i, label %cmpxchg.store_expected.i

acquire_fail.i:                                   ; preds = %monotonic.i15, %monotonic.i15
  %17 = load i64, ptr %9, align 8
  %18 = load i64, ptr %.atomictmp.i, align 8
  %19 = cmpxchg ptr %this1.i12, i64 %17, i64 %18 monotonic acquire, align 8
  %20 = extractvalue { i64, i1 } %19, 0
  %21 = extractvalue { i64, i1 } %19, 1
  br i1 %21, label %cmpxchg.continue4.i, label %cmpxchg.store_expected3.i

seqcst_fail.i:                                    ; preds = %monotonic.i15
  %22 = load i64, ptr %9, align 8
  %23 = load i64, ptr %.atomictmp.i, align 8
  %24 = cmpxchg ptr %this1.i12, i64 %22, i64 %23 monotonic seq_cst, align 8
  %25 = extractvalue { i64, i1 } %24, 0
  %26 = extractvalue { i64, i1 } %24, 1
  br i1 %26, label %cmpxchg.continue7.i, label %cmpxchg.store_expected6.i

atomic.continue2.i:                               ; preds = %cmpxchg.continue7.i, %cmpxchg.continue4.i, %cmpxchg.continue.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected.i:                         ; preds = %monotonic_fail.i
  store i64 %15, ptr %9, align 8
  br label %cmpxchg.continue.i

cmpxchg.continue.i:                               ; preds = %cmpxchg.store_expected.i, %monotonic_fail.i
  %frombool.i = zext i1 %16 to i8
  store i8 %frombool.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected3.i:                        ; preds = %acquire_fail.i
  store i64 %20, ptr %9, align 8
  br label %cmpxchg.continue4.i

cmpxchg.continue4.i:                              ; preds = %cmpxchg.store_expected3.i, %acquire_fail.i
  %frombool5.i = zext i1 %21 to i8
  store i8 %frombool5.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected6.i:                        ; preds = %seqcst_fail.i
  store i64 %25, ptr %9, align 8
  br label %cmpxchg.continue7.i

cmpxchg.continue7.i:                              ; preds = %cmpxchg.store_expected6.i, %seqcst_fail.i
  %frombool8.i = zext i1 %26 to i8
  store i8 %frombool8.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

monotonic_fail9.i:                                ; preds = %acquire.i14
  %27 = load i64, ptr %9, align 8
  %28 = load i64, ptr %.atomictmp.i, align 8
  %29 = cmpxchg ptr %this1.i12, i64 %27, i64 %28 acquire monotonic, align 8
  %30 = extractvalue { i64, i1 } %29, 0
  %31 = extractvalue { i64, i1 } %29, 1
  br i1 %31, label %cmpxchg.continue14.i, label %cmpxchg.store_expected13.i

acquire_fail10.i:                                 ; preds = %acquire.i14, %acquire.i14
  %32 = load i64, ptr %9, align 8
  %33 = load i64, ptr %.atomictmp.i, align 8
  %34 = cmpxchg ptr %this1.i12, i64 %32, i64 %33 acquire acquire, align 8
  %35 = extractvalue { i64, i1 } %34, 0
  %36 = extractvalue { i64, i1 } %34, 1
  br i1 %36, label %cmpxchg.continue17.i, label %cmpxchg.store_expected16.i

seqcst_fail11.i:                                  ; preds = %acquire.i14
  %37 = load i64, ptr %9, align 8
  %38 = load i64, ptr %.atomictmp.i, align 8
  %39 = cmpxchg ptr %this1.i12, i64 %37, i64 %38 acquire seq_cst, align 8
  %40 = extractvalue { i64, i1 } %39, 0
  %41 = extractvalue { i64, i1 } %39, 1
  br i1 %41, label %cmpxchg.continue20.i, label %cmpxchg.store_expected19.i

atomic.continue12.i:                              ; preds = %cmpxchg.continue20.i, %cmpxchg.continue17.i, %cmpxchg.continue14.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected13.i:                       ; preds = %monotonic_fail9.i
  store i64 %30, ptr %9, align 8
  br label %cmpxchg.continue14.i

cmpxchg.continue14.i:                             ; preds = %cmpxchg.store_expected13.i, %monotonic_fail9.i
  %frombool15.i = zext i1 %31 to i8
  store i8 %frombool15.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected16.i:                       ; preds = %acquire_fail10.i
  store i64 %35, ptr %9, align 8
  br label %cmpxchg.continue17.i

cmpxchg.continue17.i:                             ; preds = %cmpxchg.store_expected16.i, %acquire_fail10.i
  %frombool18.i = zext i1 %36 to i8
  store i8 %frombool18.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected19.i:                       ; preds = %seqcst_fail11.i
  store i64 %40, ptr %9, align 8
  br label %cmpxchg.continue20.i

cmpxchg.continue20.i:                             ; preds = %cmpxchg.store_expected19.i, %seqcst_fail11.i
  %frombool21.i = zext i1 %41 to i8
  store i8 %frombool21.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

monotonic_fail22.i:                               ; preds = %release.i
  %42 = load i64, ptr %9, align 8
  %43 = load i64, ptr %.atomictmp.i, align 8
  %44 = cmpxchg ptr %this1.i12, i64 %42, i64 %43 release monotonic, align 8
  %45 = extractvalue { i64, i1 } %44, 0
  %46 = extractvalue { i64, i1 } %44, 1
  br i1 %46, label %cmpxchg.continue27.i, label %cmpxchg.store_expected26.i

acquire_fail23.i:                                 ; preds = %release.i, %release.i
  %47 = load i64, ptr %9, align 8
  %48 = load i64, ptr %.atomictmp.i, align 8
  %49 = cmpxchg ptr %this1.i12, i64 %47, i64 %48 release acquire, align 8
  %50 = extractvalue { i64, i1 } %49, 0
  %51 = extractvalue { i64, i1 } %49, 1
  br i1 %51, label %cmpxchg.continue30.i, label %cmpxchg.store_expected29.i

seqcst_fail24.i:                                  ; preds = %release.i
  %52 = load i64, ptr %9, align 8
  %53 = load i64, ptr %.atomictmp.i, align 8
  %54 = cmpxchg ptr %this1.i12, i64 %52, i64 %53 release seq_cst, align 8
  %55 = extractvalue { i64, i1 } %54, 0
  %56 = extractvalue { i64, i1 } %54, 1
  br i1 %56, label %cmpxchg.continue33.i, label %cmpxchg.store_expected32.i

atomic.continue25.i:                              ; preds = %cmpxchg.continue33.i, %cmpxchg.continue30.i, %cmpxchg.continue27.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected26.i:                       ; preds = %monotonic_fail22.i
  store i64 %45, ptr %9, align 8
  br label %cmpxchg.continue27.i

cmpxchg.continue27.i:                             ; preds = %cmpxchg.store_expected26.i, %monotonic_fail22.i
  %frombool28.i = zext i1 %46 to i8
  store i8 %frombool28.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected29.i:                       ; preds = %acquire_fail23.i
  store i64 %50, ptr %9, align 8
  br label %cmpxchg.continue30.i

cmpxchg.continue30.i:                             ; preds = %cmpxchg.store_expected29.i, %acquire_fail23.i
  %frombool31.i = zext i1 %51 to i8
  store i8 %frombool31.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected32.i:                       ; preds = %seqcst_fail24.i
  store i64 %55, ptr %9, align 8
  br label %cmpxchg.continue33.i

cmpxchg.continue33.i:                             ; preds = %cmpxchg.store_expected32.i, %seqcst_fail24.i
  %frombool34.i = zext i1 %56 to i8
  store i8 %frombool34.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

monotonic_fail35.i:                               ; preds = %acqrel.i
  %57 = load i64, ptr %9, align 8
  %58 = load i64, ptr %.atomictmp.i, align 8
  %59 = cmpxchg ptr %this1.i12, i64 %57, i64 %58 acq_rel monotonic, align 8
  %60 = extractvalue { i64, i1 } %59, 0
  %61 = extractvalue { i64, i1 } %59, 1
  br i1 %61, label %cmpxchg.continue40.i, label %cmpxchg.store_expected39.i

acquire_fail36.i:                                 ; preds = %acqrel.i, %acqrel.i
  %62 = load i64, ptr %9, align 8
  %63 = load i64, ptr %.atomictmp.i, align 8
  %64 = cmpxchg ptr %this1.i12, i64 %62, i64 %63 acq_rel acquire, align 8
  %65 = extractvalue { i64, i1 } %64, 0
  %66 = extractvalue { i64, i1 } %64, 1
  br i1 %66, label %cmpxchg.continue43.i, label %cmpxchg.store_expected42.i

seqcst_fail37.i:                                  ; preds = %acqrel.i
  %67 = load i64, ptr %9, align 8
  %68 = load i64, ptr %.atomictmp.i, align 8
  %69 = cmpxchg ptr %this1.i12, i64 %67, i64 %68 acq_rel seq_cst, align 8
  %70 = extractvalue { i64, i1 } %69, 0
  %71 = extractvalue { i64, i1 } %69, 1
  br i1 %71, label %cmpxchg.continue46.i, label %cmpxchg.store_expected45.i

atomic.continue38.i:                              ; preds = %cmpxchg.continue46.i, %cmpxchg.continue43.i, %cmpxchg.continue40.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected39.i:                       ; preds = %monotonic_fail35.i
  store i64 %60, ptr %9, align 8
  br label %cmpxchg.continue40.i

cmpxchg.continue40.i:                             ; preds = %cmpxchg.store_expected39.i, %monotonic_fail35.i
  %frombool41.i = zext i1 %61 to i8
  store i8 %frombool41.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected42.i:                       ; preds = %acquire_fail36.i
  store i64 %65, ptr %9, align 8
  br label %cmpxchg.continue43.i

cmpxchg.continue43.i:                             ; preds = %cmpxchg.store_expected42.i, %acquire_fail36.i
  %frombool44.i = zext i1 %66 to i8
  store i8 %frombool44.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected45.i:                       ; preds = %seqcst_fail37.i
  store i64 %70, ptr %9, align 8
  br label %cmpxchg.continue46.i

cmpxchg.continue46.i:                             ; preds = %cmpxchg.store_expected45.i, %seqcst_fail37.i
  %frombool47.i = zext i1 %71 to i8
  store i8 %frombool47.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

monotonic_fail48.i:                               ; preds = %seqcst.i13
  %72 = load i64, ptr %9, align 8
  %73 = load i64, ptr %.atomictmp.i, align 8
  %74 = cmpxchg ptr %this1.i12, i64 %72, i64 %73 seq_cst monotonic, align 8
  %75 = extractvalue { i64, i1 } %74, 0
  %76 = extractvalue { i64, i1 } %74, 1
  br i1 %76, label %cmpxchg.continue53.i, label %cmpxchg.store_expected52.i

acquire_fail49.i:                                 ; preds = %seqcst.i13, %seqcst.i13
  %77 = load i64, ptr %9, align 8
  %78 = load i64, ptr %.atomictmp.i, align 8
  %79 = cmpxchg ptr %this1.i12, i64 %77, i64 %78 seq_cst acquire, align 8
  %80 = extractvalue { i64, i1 } %79, 0
  %81 = extractvalue { i64, i1 } %79, 1
  br i1 %81, label %cmpxchg.continue56.i, label %cmpxchg.store_expected55.i

seqcst_fail50.i:                                  ; preds = %seqcst.i13
  %82 = load i64, ptr %9, align 8
  %83 = load i64, ptr %.atomictmp.i, align 8
  %84 = cmpxchg ptr %this1.i12, i64 %82, i64 %83 seq_cst seq_cst, align 8
  %85 = extractvalue { i64, i1 } %84, 0
  %86 = extractvalue { i64, i1 } %84, 1
  br i1 %86, label %cmpxchg.continue59.i, label %cmpxchg.store_expected58.i

atomic.continue51.i:                              ; preds = %cmpxchg.continue59.i, %cmpxchg.continue56.i, %cmpxchg.continue53.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected52.i:                       ; preds = %monotonic_fail48.i
  store i64 %75, ptr %9, align 8
  br label %cmpxchg.continue53.i

cmpxchg.continue53.i:                             ; preds = %cmpxchg.store_expected52.i, %monotonic_fail48.i
  %frombool54.i = zext i1 %76 to i8
  store i8 %frombool54.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected55.i:                       ; preds = %acquire_fail49.i
  store i64 %80, ptr %9, align 8
  br label %cmpxchg.continue56.i

cmpxchg.continue56.i:                             ; preds = %cmpxchg.store_expected55.i, %acquire_fail49.i
  %frombool57.i = zext i1 %81 to i8
  store i8 %frombool57.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected58.i:                       ; preds = %seqcst_fail50.i
  store i64 %85, ptr %9, align 8
  br label %cmpxchg.continue59.i

cmpxchg.continue59.i:                             ; preds = %cmpxchg.store_expected58.i, %seqcst_fail50.i
  %frombool60.i = zext i1 %86 to i8
  store i8 %frombool60.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit: ; preds = %atomic.continue51.i, %atomic.continue38.i, %atomic.continue25.i, %atomic.continue12.i, %atomic.continue2.i
  %87 = load i8, ptr %cmpxchg.bool.i, align 1
  %tobool.i = trunc i8 %87 to i1
  %lnot = xor i1 %tobool.i, true
  br i1 %lnot, label %if.then, label %if.end9

if.then:                                          ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit, %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  %mu_5 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %call6 = call noundef zeroext i1 @_ZN4abslL22TryAcquireWithSpinningEPSt6atomicIlE(ptr noundef %mu_5)
  %lnot7 = xor i1 %call6, true
  br i1 %lnot7, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.then
  call void @_ZN4absl5Mutex8LockSlowEPKNS_6MuHowSEPKNS_9ConditionEi(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef @_ZN4abslL11kExclusiveSE, ptr noundef null, i32 noundef 0) #16
  br label %if.end

if.end:                                           ; preds = %if.then8, %if.then
  br label %if.end9

if.end9:                                          ; preds = %if.end, %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %id, i64 8, i1 false)
  %coerce.dive10 = getelementptr inbounds %"struct.absl::synchronization_internal::GraphId", ptr %agg.tmp, i32 0, i32 0
  %88 = load i64, ptr %coerce.dive10, align 8
  call void @_ZN4abslL18DebugOnlyLockEnterEPNS_5MutexENS_24synchronization_internal7GraphIdE(ptr noundef %this1, i64 %88)
  ret void
}

; Function Attrs: mustprogress uwtable
define internal i64 @_ZN4abslL22DebugOnlyDeadlockCheckEPNS_5MutexE(ptr noundef %mu) #0 {
entry:
  %retval = alloca %"struct.absl::synchronization_internal::GraphId", align 8
  %mu.addr = alloca ptr, align 8
  store ptr %mu, ptr %mu.addr, align 8
  %call = call i64 @_ZN4absl24synchronization_internal14InvalidGraphIdEv()
  %coerce.dive = getelementptr inbounds %"struct.absl::synchronization_internal::GraphId", ptr %retval, i32 0, i32 0
  store i64 %call, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"struct.absl::synchronization_internal::GraphId", ptr %retval, i32 0, i32 0
  %0 = load i64, ptr %coerce.dive1, align 8
  ret i64 %0
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef zeroext i1 @_ZN4abslL22TryAcquireWithSpinningEPSt6atomicIlE(ptr noundef %mu) #1 {
entry:
  %this.addr.i13 = alloca ptr, align 8
  %__m.addr.i14 = alloca i32, align 4
  %__b.i15 = alloca i32, align 4
  %atomic-temp.i16 = alloca i32, align 4
  %this.addr.i8 = alloca ptr, align 8
  %__i1.addr.i = alloca ptr, align 8
  %__i2.addr.i = alloca i64, align 8
  %__m1.addr.i = alloca i32, align 4
  %__m2.addr.i = alloca i32, align 4
  %.atomictmp.i = alloca i64, align 8
  %cmpxchg.bool.i = alloca i8, align 1
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i64, align 8
  %retval = alloca i1, align 1
  %mu.addr = alloca ptr, align 8
  %c = alloca i32, align 4
  %v = alloca i64, align 8
  store ptr %mu, ptr %mu.addr, align 8
  store ptr getelementptr inbounds (%"struct.absl::(anonymous namespace)::MutexGlobals", ptr @_ZN4absl12_GLOBAL__N_17globalsE, i32 0, i32 1), ptr %this.addr.i13, align 8
  store i32 0, ptr %__m.addr.i14, align 4
  %this1.i17 = load ptr, ptr %this.addr.i13, align 8
  %0 = load i32, ptr %__m.addr.i14, align 4
  %call.i18 = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %0, i32 noundef 65535)
  store i32 %call.i18, ptr %__b.i15, align 4
  %1 = load i32, ptr %__m.addr.i14, align 4
  switch i32 %1, label %monotonic.i21 [
    i32 1, label %acquire.i20
    i32 2, label %acquire.i20
    i32 5, label %seqcst.i19
  ]

monotonic.i21:                                    ; preds = %entry
  %2 = load atomic i32, ptr %this1.i17 monotonic, align 4
  store i32 %2, ptr %atomic-temp.i16, align 4
  br label %_ZNKSt13__atomic_baseIiE4loadESt12memory_order.exit

acquire.i20:                                      ; preds = %entry, %entry
  %3 = load atomic i32, ptr %this1.i17 acquire, align 4
  store i32 %3, ptr %atomic-temp.i16, align 4
  br label %_ZNKSt13__atomic_baseIiE4loadESt12memory_order.exit

seqcst.i19:                                       ; preds = %entry
  %4 = load atomic i32, ptr %this1.i17 seq_cst, align 4
  store i32 %4, ptr %atomic-temp.i16, align 4
  br label %_ZNKSt13__atomic_baseIiE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIiE4loadESt12memory_order.exit: ; preds = %seqcst.i19, %acquire.i20, %monotonic.i21
  %5 = load i32, ptr %atomic-temp.i16, align 4
  store i32 %5, ptr %c, align 4
  br label %do.body

do.body:                                          ; preds = %do.cond, %_ZNKSt13__atomic_baseIiE4loadESt12memory_order.exit
  %6 = load ptr, ptr %mu.addr, align 8
  store ptr %6, ptr %this.addr.i, align 8
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %7 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %7, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %8 = load i32, ptr %__m.addr.i, align 4
  switch i32 %8, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %do.body
  %9 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %9, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %do.body, %do.body
  %10 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %10, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %do.body
  %11 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %11, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %12 = load i64, ptr %atomic-temp.i, align 8
  store i64 %12, ptr %v, align 8
  %13 = load i64, ptr %v, align 8
  %and = and i64 %13, 17
  %cmp = icmp ne i64 %and, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  store i1 false, ptr %retval, align 1
  br label %return

if.else:                                          ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  %14 = load i64, ptr %v, align 8
  %and2 = and i64 %14, 8
  %cmp3 = icmp eq i64 %and2, 0
  br i1 %cmp3, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %15 = load ptr, ptr %mu.addr, align 8
  %16 = load i64, ptr %v, align 8
  %or = or i64 8, %16
  store ptr %15, ptr %this.addr.i8, align 8
  store ptr %v, ptr %__i1.addr.i, align 8
  store i64 %or, ptr %__i2.addr.i, align 8
  store i32 2, ptr %__m1.addr.i, align 4
  store i32 0, ptr %__m2.addr.i, align 4
  %this1.i9 = load ptr, ptr %this.addr.i8, align 8
  %17 = load i32, ptr %__m1.addr.i, align 4
  %18 = load ptr, ptr %__i1.addr.i, align 8
  %19 = load i64, ptr %__i2.addr.i, align 8
  store i64 %19, ptr %.atomictmp.i, align 8
  %20 = load i32, ptr %__m2.addr.i, align 4
  switch i32 %17, label %monotonic.i12 [
    i32 1, label %acquire.i11
    i32 2, label %acquire.i11
    i32 3, label %release.i
    i32 4, label %acqrel.i
    i32 5, label %seqcst.i10
  ]

monotonic.i12:                                    ; preds = %land.lhs.true
  switch i32 %20, label %monotonic_fail.i [
    i32 1, label %acquire_fail.i
    i32 2, label %acquire_fail.i
    i32 5, label %seqcst_fail.i
  ]

acquire.i11:                                      ; preds = %land.lhs.true, %land.lhs.true
  switch i32 %20, label %monotonic_fail9.i [
    i32 1, label %acquire_fail10.i
    i32 2, label %acquire_fail10.i
    i32 5, label %seqcst_fail11.i
  ]

release.i:                                        ; preds = %land.lhs.true
  switch i32 %20, label %monotonic_fail22.i [
    i32 1, label %acquire_fail23.i
    i32 2, label %acquire_fail23.i
    i32 5, label %seqcst_fail24.i
  ]

acqrel.i:                                         ; preds = %land.lhs.true
  switch i32 %20, label %monotonic_fail35.i [
    i32 1, label %acquire_fail36.i
    i32 2, label %acquire_fail36.i
    i32 5, label %seqcst_fail37.i
  ]

seqcst.i10:                                       ; preds = %land.lhs.true
  switch i32 %20, label %monotonic_fail48.i [
    i32 1, label %acquire_fail49.i
    i32 2, label %acquire_fail49.i
    i32 5, label %seqcst_fail50.i
  ]

monotonic_fail.i:                                 ; preds = %monotonic.i12
  %21 = load i64, ptr %18, align 8
  %22 = load i64, ptr %.atomictmp.i, align 8
  %23 = cmpxchg ptr %this1.i9, i64 %21, i64 %22 monotonic monotonic, align 8
  %24 = extractvalue { i64, i1 } %23, 0
  %25 = extractvalue { i64, i1 } %23, 1
  br i1 %25, label %cmpxchg.continue.i, label %cmpxchg.store_expected.i

acquire_fail.i:                                   ; preds = %monotonic.i12, %monotonic.i12
  %26 = load i64, ptr %18, align 8
  %27 = load i64, ptr %.atomictmp.i, align 8
  %28 = cmpxchg ptr %this1.i9, i64 %26, i64 %27 monotonic acquire, align 8
  %29 = extractvalue { i64, i1 } %28, 0
  %30 = extractvalue { i64, i1 } %28, 1
  br i1 %30, label %cmpxchg.continue4.i, label %cmpxchg.store_expected3.i

seqcst_fail.i:                                    ; preds = %monotonic.i12
  %31 = load i64, ptr %18, align 8
  %32 = load i64, ptr %.atomictmp.i, align 8
  %33 = cmpxchg ptr %this1.i9, i64 %31, i64 %32 monotonic seq_cst, align 8
  %34 = extractvalue { i64, i1 } %33, 0
  %35 = extractvalue { i64, i1 } %33, 1
  br i1 %35, label %cmpxchg.continue7.i, label %cmpxchg.store_expected6.i

atomic.continue2.i:                               ; preds = %cmpxchg.continue7.i, %cmpxchg.continue4.i, %cmpxchg.continue.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected.i:                         ; preds = %monotonic_fail.i
  store i64 %24, ptr %18, align 8
  br label %cmpxchg.continue.i

cmpxchg.continue.i:                               ; preds = %cmpxchg.store_expected.i, %monotonic_fail.i
  %frombool.i = zext i1 %25 to i8
  store i8 %frombool.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected3.i:                        ; preds = %acquire_fail.i
  store i64 %29, ptr %18, align 8
  br label %cmpxchg.continue4.i

cmpxchg.continue4.i:                              ; preds = %cmpxchg.store_expected3.i, %acquire_fail.i
  %frombool5.i = zext i1 %30 to i8
  store i8 %frombool5.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected6.i:                        ; preds = %seqcst_fail.i
  store i64 %34, ptr %18, align 8
  br label %cmpxchg.continue7.i

cmpxchg.continue7.i:                              ; preds = %cmpxchg.store_expected6.i, %seqcst_fail.i
  %frombool8.i = zext i1 %35 to i8
  store i8 %frombool8.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

monotonic_fail9.i:                                ; preds = %acquire.i11
  %36 = load i64, ptr %18, align 8
  %37 = load i64, ptr %.atomictmp.i, align 8
  %38 = cmpxchg ptr %this1.i9, i64 %36, i64 %37 acquire monotonic, align 8
  %39 = extractvalue { i64, i1 } %38, 0
  %40 = extractvalue { i64, i1 } %38, 1
  br i1 %40, label %cmpxchg.continue14.i, label %cmpxchg.store_expected13.i

acquire_fail10.i:                                 ; preds = %acquire.i11, %acquire.i11
  %41 = load i64, ptr %18, align 8
  %42 = load i64, ptr %.atomictmp.i, align 8
  %43 = cmpxchg ptr %this1.i9, i64 %41, i64 %42 acquire acquire, align 8
  %44 = extractvalue { i64, i1 } %43, 0
  %45 = extractvalue { i64, i1 } %43, 1
  br i1 %45, label %cmpxchg.continue17.i, label %cmpxchg.store_expected16.i

seqcst_fail11.i:                                  ; preds = %acquire.i11
  %46 = load i64, ptr %18, align 8
  %47 = load i64, ptr %.atomictmp.i, align 8
  %48 = cmpxchg ptr %this1.i9, i64 %46, i64 %47 acquire seq_cst, align 8
  %49 = extractvalue { i64, i1 } %48, 0
  %50 = extractvalue { i64, i1 } %48, 1
  br i1 %50, label %cmpxchg.continue20.i, label %cmpxchg.store_expected19.i

atomic.continue12.i:                              ; preds = %cmpxchg.continue20.i, %cmpxchg.continue17.i, %cmpxchg.continue14.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected13.i:                       ; preds = %monotonic_fail9.i
  store i64 %39, ptr %18, align 8
  br label %cmpxchg.continue14.i

cmpxchg.continue14.i:                             ; preds = %cmpxchg.store_expected13.i, %monotonic_fail9.i
  %frombool15.i = zext i1 %40 to i8
  store i8 %frombool15.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected16.i:                       ; preds = %acquire_fail10.i
  store i64 %44, ptr %18, align 8
  br label %cmpxchg.continue17.i

cmpxchg.continue17.i:                             ; preds = %cmpxchg.store_expected16.i, %acquire_fail10.i
  %frombool18.i = zext i1 %45 to i8
  store i8 %frombool18.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected19.i:                       ; preds = %seqcst_fail11.i
  store i64 %49, ptr %18, align 8
  br label %cmpxchg.continue20.i

cmpxchg.continue20.i:                             ; preds = %cmpxchg.store_expected19.i, %seqcst_fail11.i
  %frombool21.i = zext i1 %50 to i8
  store i8 %frombool21.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

monotonic_fail22.i:                               ; preds = %release.i
  %51 = load i64, ptr %18, align 8
  %52 = load i64, ptr %.atomictmp.i, align 8
  %53 = cmpxchg ptr %this1.i9, i64 %51, i64 %52 release monotonic, align 8
  %54 = extractvalue { i64, i1 } %53, 0
  %55 = extractvalue { i64, i1 } %53, 1
  br i1 %55, label %cmpxchg.continue27.i, label %cmpxchg.store_expected26.i

acquire_fail23.i:                                 ; preds = %release.i, %release.i
  %56 = load i64, ptr %18, align 8
  %57 = load i64, ptr %.atomictmp.i, align 8
  %58 = cmpxchg ptr %this1.i9, i64 %56, i64 %57 release acquire, align 8
  %59 = extractvalue { i64, i1 } %58, 0
  %60 = extractvalue { i64, i1 } %58, 1
  br i1 %60, label %cmpxchg.continue30.i, label %cmpxchg.store_expected29.i

seqcst_fail24.i:                                  ; preds = %release.i
  %61 = load i64, ptr %18, align 8
  %62 = load i64, ptr %.atomictmp.i, align 8
  %63 = cmpxchg ptr %this1.i9, i64 %61, i64 %62 release seq_cst, align 8
  %64 = extractvalue { i64, i1 } %63, 0
  %65 = extractvalue { i64, i1 } %63, 1
  br i1 %65, label %cmpxchg.continue33.i, label %cmpxchg.store_expected32.i

atomic.continue25.i:                              ; preds = %cmpxchg.continue33.i, %cmpxchg.continue30.i, %cmpxchg.continue27.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected26.i:                       ; preds = %monotonic_fail22.i
  store i64 %54, ptr %18, align 8
  br label %cmpxchg.continue27.i

cmpxchg.continue27.i:                             ; preds = %cmpxchg.store_expected26.i, %monotonic_fail22.i
  %frombool28.i = zext i1 %55 to i8
  store i8 %frombool28.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected29.i:                       ; preds = %acquire_fail23.i
  store i64 %59, ptr %18, align 8
  br label %cmpxchg.continue30.i

cmpxchg.continue30.i:                             ; preds = %cmpxchg.store_expected29.i, %acquire_fail23.i
  %frombool31.i = zext i1 %60 to i8
  store i8 %frombool31.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected32.i:                       ; preds = %seqcst_fail24.i
  store i64 %64, ptr %18, align 8
  br label %cmpxchg.continue33.i

cmpxchg.continue33.i:                             ; preds = %cmpxchg.store_expected32.i, %seqcst_fail24.i
  %frombool34.i = zext i1 %65 to i8
  store i8 %frombool34.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

monotonic_fail35.i:                               ; preds = %acqrel.i
  %66 = load i64, ptr %18, align 8
  %67 = load i64, ptr %.atomictmp.i, align 8
  %68 = cmpxchg ptr %this1.i9, i64 %66, i64 %67 acq_rel monotonic, align 8
  %69 = extractvalue { i64, i1 } %68, 0
  %70 = extractvalue { i64, i1 } %68, 1
  br i1 %70, label %cmpxchg.continue40.i, label %cmpxchg.store_expected39.i

acquire_fail36.i:                                 ; preds = %acqrel.i, %acqrel.i
  %71 = load i64, ptr %18, align 8
  %72 = load i64, ptr %.atomictmp.i, align 8
  %73 = cmpxchg ptr %this1.i9, i64 %71, i64 %72 acq_rel acquire, align 8
  %74 = extractvalue { i64, i1 } %73, 0
  %75 = extractvalue { i64, i1 } %73, 1
  br i1 %75, label %cmpxchg.continue43.i, label %cmpxchg.store_expected42.i

seqcst_fail37.i:                                  ; preds = %acqrel.i
  %76 = load i64, ptr %18, align 8
  %77 = load i64, ptr %.atomictmp.i, align 8
  %78 = cmpxchg ptr %this1.i9, i64 %76, i64 %77 acq_rel seq_cst, align 8
  %79 = extractvalue { i64, i1 } %78, 0
  %80 = extractvalue { i64, i1 } %78, 1
  br i1 %80, label %cmpxchg.continue46.i, label %cmpxchg.store_expected45.i

atomic.continue38.i:                              ; preds = %cmpxchg.continue46.i, %cmpxchg.continue43.i, %cmpxchg.continue40.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected39.i:                       ; preds = %monotonic_fail35.i
  store i64 %69, ptr %18, align 8
  br label %cmpxchg.continue40.i

cmpxchg.continue40.i:                             ; preds = %cmpxchg.store_expected39.i, %monotonic_fail35.i
  %frombool41.i = zext i1 %70 to i8
  store i8 %frombool41.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected42.i:                       ; preds = %acquire_fail36.i
  store i64 %74, ptr %18, align 8
  br label %cmpxchg.continue43.i

cmpxchg.continue43.i:                             ; preds = %cmpxchg.store_expected42.i, %acquire_fail36.i
  %frombool44.i = zext i1 %75 to i8
  store i8 %frombool44.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected45.i:                       ; preds = %seqcst_fail37.i
  store i64 %79, ptr %18, align 8
  br label %cmpxchg.continue46.i

cmpxchg.continue46.i:                             ; preds = %cmpxchg.store_expected45.i, %seqcst_fail37.i
  %frombool47.i = zext i1 %80 to i8
  store i8 %frombool47.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

monotonic_fail48.i:                               ; preds = %seqcst.i10
  %81 = load i64, ptr %18, align 8
  %82 = load i64, ptr %.atomictmp.i, align 8
  %83 = cmpxchg ptr %this1.i9, i64 %81, i64 %82 seq_cst monotonic, align 8
  %84 = extractvalue { i64, i1 } %83, 0
  %85 = extractvalue { i64, i1 } %83, 1
  br i1 %85, label %cmpxchg.continue53.i, label %cmpxchg.store_expected52.i

acquire_fail49.i:                                 ; preds = %seqcst.i10, %seqcst.i10
  %86 = load i64, ptr %18, align 8
  %87 = load i64, ptr %.atomictmp.i, align 8
  %88 = cmpxchg ptr %this1.i9, i64 %86, i64 %87 seq_cst acquire, align 8
  %89 = extractvalue { i64, i1 } %88, 0
  %90 = extractvalue { i64, i1 } %88, 1
  br i1 %90, label %cmpxchg.continue56.i, label %cmpxchg.store_expected55.i

seqcst_fail50.i:                                  ; preds = %seqcst.i10
  %91 = load i64, ptr %18, align 8
  %92 = load i64, ptr %.atomictmp.i, align 8
  %93 = cmpxchg ptr %this1.i9, i64 %91, i64 %92 seq_cst seq_cst, align 8
  %94 = extractvalue { i64, i1 } %93, 0
  %95 = extractvalue { i64, i1 } %93, 1
  br i1 %95, label %cmpxchg.continue59.i, label %cmpxchg.store_expected58.i

atomic.continue51.i:                              ; preds = %cmpxchg.continue59.i, %cmpxchg.continue56.i, %cmpxchg.continue53.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected52.i:                       ; preds = %monotonic_fail48.i
  store i64 %84, ptr %18, align 8
  br label %cmpxchg.continue53.i

cmpxchg.continue53.i:                             ; preds = %cmpxchg.store_expected52.i, %monotonic_fail48.i
  %frombool54.i = zext i1 %85 to i8
  store i8 %frombool54.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected55.i:                       ; preds = %acquire_fail49.i
  store i64 %89, ptr %18, align 8
  br label %cmpxchg.continue56.i

cmpxchg.continue56.i:                             ; preds = %cmpxchg.store_expected55.i, %acquire_fail49.i
  %frombool57.i = zext i1 %90 to i8
  store i8 %frombool57.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected58.i:                       ; preds = %seqcst_fail50.i
  store i64 %94, ptr %18, align 8
  br label %cmpxchg.continue59.i

cmpxchg.continue59.i:                             ; preds = %cmpxchg.store_expected58.i, %seqcst_fail50.i
  %frombool60.i = zext i1 %95 to i8
  store i8 %frombool60.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit: ; preds = %atomic.continue51.i, %atomic.continue38.i, %atomic.continue25.i, %atomic.continue12.i, %atomic.continue2.i
  %96 = load i8, ptr %cmpxchg.bool.i, align 1
  %tobool.i = trunc i8 %96 to i1
  br i1 %tobool.i, label %if.then5, label %if.end

if.then5:                                         ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit
  store i1 true, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit, %if.else
  br label %if.end6

if.end6:                                          ; preds = %if.end
  br label %do.cond

do.cond:                                          ; preds = %if.end6
  %97 = load i32, ptr %c, align 4
  %dec = add nsw i32 %97, -1
  store i32 %dec, ptr %c, align 4
  %cmp7 = icmp sgt i32 %dec, 0
  br i1 %cmp7, label %do.body, label %do.end, !llvm.loop !13

do.end:                                           ; preds = %do.cond
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %do.end, %if.then5, %if.then
  %98 = load i1, ptr %retval, align 1
  ret i1 %98
}

; Function Attrs: cold mustprogress uwtable
define dso_local void @_ZN4absl5Mutex8LockSlowEPKNS_6MuHowSEPKNS_9ConditionEi(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %how, ptr noundef %cond, i32 noundef %flags) #5 align 2 {
entry:
  %this.addr.i22 = alloca ptr, align 8
  %__i.addr.i23 = alloca i32, align 4
  %__m.addr.i24 = alloca i32, align 4
  %__b.i25 = alloca i32, align 4
  %.atomictmp.i26 = alloca i32, align 4
  %this.addr.i15 = alloca ptr, align 8
  %__i.addr.i = alloca i32, align 4
  %__m.addr.i16 = alloca i32, align 4
  %__b.i17 = alloca i32, align 4
  %.atomictmp.i = alloca i32, align 4
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %how.addr = alloca ptr, align 8
  %cond.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %agg.tmp = alloca %"class.absl::synchronization_internal::KernelTimeout", align 8
  %absl_raw_log_internal_basename = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %how, ptr %how.addr, align 8
  store ptr %cond, ptr %cond.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  store ptr getelementptr inbounds (%"struct.absl::(anonymous namespace)::MutexGlobals", ptr @_ZN4absl12_GLOBAL__N_17globalsE, i32 0, i32 1), ptr %this.addr.i, align 8
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %0 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %0, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %1 = load i32, ptr %__m.addr.i, align 4
  switch i32 %1, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %entry
  %2 = load atomic i32, ptr %this1.i monotonic, align 4
  store i32 %2, ptr %atomic-temp.i, align 4
  br label %_ZNKSt13__atomic_baseIiE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %entry, %entry
  %3 = load atomic i32, ptr %this1.i acquire, align 4
  store i32 %3, ptr %atomic-temp.i, align 4
  br label %_ZNKSt13__atomic_baseIiE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %entry
  %4 = load atomic i32, ptr %this1.i seq_cst, align 4
  store i32 %4, ptr %atomic-temp.i, align 4
  br label %_ZNKSt13__atomic_baseIiE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIiE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %5 = load i32, ptr %atomic-temp.i, align 4
  %cmp = icmp eq i32 %5, 0
  br i1 %cmp, label %if.then, label %if.end5

if.then:                                          ; preds = %_ZNKSt13__atomic_baseIiE4loadESt12memory_order.exit
  %call2 = call noundef i32 @_ZN4absl13base_internal7NumCPUsEv()
  %cmp3 = icmp sgt i32 %call2, 1
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.then
  store ptr getelementptr inbounds (%"struct.absl::(anonymous namespace)::MutexGlobals", ptr @_ZN4absl12_GLOBAL__N_17globalsE, i32 0, i32 1), ptr %this.addr.i22, align 8
  store i32 1500, ptr %__i.addr.i23, align 4
  store i32 0, ptr %__m.addr.i24, align 4
  %this1.i27 = load ptr, ptr %this.addr.i22, align 8
  %6 = load i32, ptr %__m.addr.i24, align 4
  %call.i28 = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %6, i32 noundef 65535)
  store i32 %call.i28, ptr %__b.i25, align 4
  %7 = load i32, ptr %__m.addr.i24, align 4
  %8 = load i32, ptr %__i.addr.i23, align 4
  store i32 %8, ptr %.atomictmp.i26, align 4
  switch i32 %7, label %monotonic.i31 [
    i32 3, label %release.i30
    i32 5, label %seqcst.i29
  ]

monotonic.i31:                                    ; preds = %if.then4
  %9 = load i32, ptr %.atomictmp.i26, align 4
  store atomic i32 %9, ptr %this1.i27 monotonic, align 4
  br label %_ZNSt13__atomic_baseIiE5storeEiSt12memory_order.exit32

release.i30:                                      ; preds = %if.then4
  %10 = load i32, ptr %.atomictmp.i26, align 4
  store atomic i32 %10, ptr %this1.i27 release, align 4
  br label %_ZNSt13__atomic_baseIiE5storeEiSt12memory_order.exit32

seqcst.i29:                                       ; preds = %if.then4
  %11 = load i32, ptr %.atomictmp.i26, align 4
  store atomic i32 %11, ptr %this1.i27 seq_cst, align 4
  br label %_ZNSt13__atomic_baseIiE5storeEiSt12memory_order.exit32

_ZNSt13__atomic_baseIiE5storeEiSt12memory_order.exit32: ; preds = %seqcst.i29, %release.i30, %monotonic.i31
  br label %if.end

if.else:                                          ; preds = %if.then
  store ptr getelementptr inbounds (%"struct.absl::(anonymous namespace)::MutexGlobals", ptr @_ZN4absl12_GLOBAL__N_17globalsE, i32 0, i32 1), ptr %this.addr.i15, align 8
  store i32 -1, ptr %__i.addr.i, align 4
  store i32 0, ptr %__m.addr.i16, align 4
  %this1.i18 = load ptr, ptr %this.addr.i15, align 8
  %12 = load i32, ptr %__m.addr.i16, align 4
  %call.i19 = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %12, i32 noundef 65535)
  store i32 %call.i19, ptr %__b.i17, align 4
  %13 = load i32, ptr %__m.addr.i16, align 4
  %14 = load i32, ptr %__i.addr.i, align 4
  store i32 %14, ptr %.atomictmp.i, align 4
  switch i32 %13, label %monotonic.i21 [
    i32 3, label %release.i
    i32 5, label %seqcst.i20
  ]

monotonic.i21:                                    ; preds = %if.else
  %15 = load i32, ptr %.atomictmp.i, align 4
  store atomic i32 %15, ptr %this1.i18 monotonic, align 4
  br label %_ZNSt13__atomic_baseIiE5storeEiSt12memory_order.exit

release.i:                                        ; preds = %if.else
  %16 = load i32, ptr %.atomictmp.i, align 4
  store atomic i32 %16, ptr %this1.i18 release, align 4
  br label %_ZNSt13__atomic_baseIiE5storeEiSt12memory_order.exit

seqcst.i20:                                       ; preds = %if.else
  %17 = load i32, ptr %.atomictmp.i, align 4
  store atomic i32 %17, ptr %this1.i18 seq_cst, align 4
  br label %_ZNSt13__atomic_baseIiE5storeEiSt12memory_order.exit

_ZNSt13__atomic_baseIiE5storeEiSt12memory_order.exit: ; preds = %seqcst.i20, %release.i, %monotonic.i21
  br label %if.end

if.end:                                           ; preds = %_ZNSt13__atomic_baseIiE5storeEiSt12memory_order.exit, %_ZNSt13__atomic_baseIiE5storeEiSt12memory_order.exit32
  br label %if.end5

if.end5:                                          ; preds = %if.end, %_ZNKSt13__atomic_baseIiE4loadESt12memory_order.exit
  br label %do.body

do.body:                                          ; preds = %if.end5
  %18 = load ptr, ptr %how.addr, align 8
  %19 = load ptr, ptr %cond.addr, align 8
  %call6 = call i64 @_ZN4absl24synchronization_internal13KernelTimeout5NeverEv()
  %coerce.dive = getelementptr inbounds %"class.absl::synchronization_internal::KernelTimeout", ptr %agg.tmp, i32 0, i32 0
  store i64 %call6, ptr %coerce.dive, align 8
  %20 = load i32, ptr %flags.addr, align 4
  %coerce.dive7 = getelementptr inbounds %"class.absl::synchronization_internal::KernelTimeout", ptr %agg.tmp, i32 0, i32 0
  %21 = load i64, ptr %coerce.dive7, align 8
  %call8 = call noundef zeroext i1 @_ZN4absl5Mutex20LockSlowWithDeadlineEPKNS_6MuHowSEPKNS_9ConditionENS_24synchronization_internal13KernelTimeoutEi(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef %18, ptr noundef %19, i64 %21, i32 noundef %20)
  %lnot = xor i1 %call8, true
  br i1 %lnot, label %if.then9, label %if.end13

if.then9:                                         ; preds = %do.body
  br label %do.body10

do.body10:                                        ; preds = %if.then9
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename, align 8
  call void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 1814, ptr noundef @.str.1, ptr noundef @.str.6, ptr noundef @.str.7)
  br label %do.body11

do.body11:                                        ; preds = %do.body10
  unreachable

do.end:                                           ; No predecessors!
  br label %do.end12

do.end12:                                         ; preds = %do.end
  br label %if.end13

if.end13:                                         ; preds = %do.end12, %do.body
  br label %do.end14

do.end14:                                         ; preds = %if.end13
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZN4abslL18DebugOnlyLockEnterEPNS_5MutexENS_24synchronization_internal7GraphIdE(ptr noundef %mu, i64 %id.coerce) #1 {
entry:
  %id = alloca %"struct.absl::synchronization_internal::GraphId", align 8
  %mu.addr = alloca ptr, align 8
  %coerce.dive = getelementptr inbounds %"struct.absl::synchronization_internal::GraphId", ptr %id, i32 0, i32 0
  store i64 %id.coerce, ptr %coerce.dive, align 8
  store ptr %mu, ptr %mu.addr, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN4absl5Mutex10ReaderLockEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 align 2 {
entry:
  %this.addr.i9 = alloca ptr, align 8
  %__i1.addr.i = alloca ptr, align 8
  %__i2.addr.i = alloca i64, align 8
  %__m1.addr.i = alloca i32, align 4
  %__m2.addr.i = alloca i32, align 4
  %.atomictmp.i = alloca i64, align 8
  %cmpxchg.bool.i = alloca i8, align 1
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i64, align 8
  %this.addr = alloca ptr, align 8
  %id = alloca %"struct.absl::synchronization_internal::GraphId", align 8
  %v = alloca i64, align 8
  %agg.tmp = alloca %"struct.absl::synchronization_internal::GraphId", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call i64 @_ZN4abslL22DebugOnlyDeadlockCheckEPNS_5MutexE(ptr noundef %this1)
  %coerce.dive = getelementptr inbounds %"struct.absl::synchronization_internal::GraphId", ptr %id, i32 0, i32 0
  store i64 %call, ptr %coerce.dive, align 8
  %mu_ = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  store ptr %mu_, ptr %this.addr.i, align 8
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %0 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %0, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %1 = load i32, ptr %__m.addr.i, align 4
  switch i32 %1, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %entry
  %2 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %2, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %entry, %entry
  %3 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %3, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %entry
  %4 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %4, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %5 = load i64, ptr %atomic-temp.i, align 8
  store i64 %5, ptr %v, align 8
  br label %for.cond

for.cond:                                         ; preds = %if.end7, %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  %6 = load i64, ptr %v, align 8
  %and = and i64 %6, 28
  %tobool = icmp ne i64 %and, 0
  %conv = zext i1 %tobool to i64
  %cmp = icmp ne i64 %conv, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %for.cond
  call void @_ZN4absl5Mutex8LockSlowEPKNS_6MuHowSEPKNS_9ConditionEi(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef @_ZN4abslL8kSharedSE, ptr noundef null, i32 noundef 0) #16
  br label %for.end

if.end:                                           ; preds = %for.cond
  %mu_3 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %7 = load i64, ptr %v, align 8
  %or = or i64 1, %7
  %add = add nsw i64 %or, 256
  store ptr %mu_3, ptr %this.addr.i9, align 8
  store ptr %v, ptr %__i1.addr.i, align 8
  store i64 %add, ptr %__i2.addr.i, align 8
  store i32 2, ptr %__m1.addr.i, align 4
  store i32 0, ptr %__m2.addr.i, align 4
  %this1.i10 = load ptr, ptr %this.addr.i9, align 8
  %8 = load i32, ptr %__m1.addr.i, align 4
  %9 = load ptr, ptr %__i1.addr.i, align 8
  %10 = load i64, ptr %__i2.addr.i, align 8
  store i64 %10, ptr %.atomictmp.i, align 8
  %11 = load i32, ptr %__m2.addr.i, align 4
  switch i32 %8, label %monotonic.i13 [
    i32 1, label %acquire.i12
    i32 2, label %acquire.i12
    i32 3, label %release.i
    i32 4, label %acqrel.i
    i32 5, label %seqcst.i11
  ]

monotonic.i13:                                    ; preds = %if.end
  switch i32 %11, label %monotonic_fail.i [
    i32 1, label %acquire_fail.i
    i32 2, label %acquire_fail.i
    i32 5, label %seqcst_fail.i
  ]

acquire.i12:                                      ; preds = %if.end, %if.end
  switch i32 %11, label %monotonic_fail9.i [
    i32 1, label %acquire_fail10.i
    i32 2, label %acquire_fail10.i
    i32 5, label %seqcst_fail11.i
  ]

release.i:                                        ; preds = %if.end
  switch i32 %11, label %monotonic_fail22.i [
    i32 1, label %acquire_fail23.i
    i32 2, label %acquire_fail23.i
    i32 5, label %seqcst_fail24.i
  ]

acqrel.i:                                         ; preds = %if.end
  switch i32 %11, label %monotonic_fail35.i [
    i32 1, label %acquire_fail36.i
    i32 2, label %acquire_fail36.i
    i32 5, label %seqcst_fail37.i
  ]

seqcst.i11:                                       ; preds = %if.end
  switch i32 %11, label %monotonic_fail48.i [
    i32 1, label %acquire_fail49.i
    i32 2, label %acquire_fail49.i
    i32 5, label %seqcst_fail50.i
  ]

monotonic_fail.i:                                 ; preds = %monotonic.i13
  %12 = load i64, ptr %9, align 8
  %13 = load i64, ptr %.atomictmp.i, align 8
  %14 = cmpxchg ptr %this1.i10, i64 %12, i64 %13 monotonic monotonic, align 8
  %15 = extractvalue { i64, i1 } %14, 0
  %16 = extractvalue { i64, i1 } %14, 1
  br i1 %16, label %cmpxchg.continue.i, label %cmpxchg.store_expected.i

acquire_fail.i:                                   ; preds = %monotonic.i13, %monotonic.i13
  %17 = load i64, ptr %9, align 8
  %18 = load i64, ptr %.atomictmp.i, align 8
  %19 = cmpxchg ptr %this1.i10, i64 %17, i64 %18 monotonic acquire, align 8
  %20 = extractvalue { i64, i1 } %19, 0
  %21 = extractvalue { i64, i1 } %19, 1
  br i1 %21, label %cmpxchg.continue4.i, label %cmpxchg.store_expected3.i

seqcst_fail.i:                                    ; preds = %monotonic.i13
  %22 = load i64, ptr %9, align 8
  %23 = load i64, ptr %.atomictmp.i, align 8
  %24 = cmpxchg ptr %this1.i10, i64 %22, i64 %23 monotonic seq_cst, align 8
  %25 = extractvalue { i64, i1 } %24, 0
  %26 = extractvalue { i64, i1 } %24, 1
  br i1 %26, label %cmpxchg.continue7.i, label %cmpxchg.store_expected6.i

atomic.continue2.i:                               ; preds = %cmpxchg.continue7.i, %cmpxchg.continue4.i, %cmpxchg.continue.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected.i:                         ; preds = %monotonic_fail.i
  store i64 %15, ptr %9, align 8
  br label %cmpxchg.continue.i

cmpxchg.continue.i:                               ; preds = %cmpxchg.store_expected.i, %monotonic_fail.i
  %frombool.i = zext i1 %16 to i8
  store i8 %frombool.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected3.i:                        ; preds = %acquire_fail.i
  store i64 %20, ptr %9, align 8
  br label %cmpxchg.continue4.i

cmpxchg.continue4.i:                              ; preds = %cmpxchg.store_expected3.i, %acquire_fail.i
  %frombool5.i = zext i1 %21 to i8
  store i8 %frombool5.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected6.i:                        ; preds = %seqcst_fail.i
  store i64 %25, ptr %9, align 8
  br label %cmpxchg.continue7.i

cmpxchg.continue7.i:                              ; preds = %cmpxchg.store_expected6.i, %seqcst_fail.i
  %frombool8.i = zext i1 %26 to i8
  store i8 %frombool8.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

monotonic_fail9.i:                                ; preds = %acquire.i12
  %27 = load i64, ptr %9, align 8
  %28 = load i64, ptr %.atomictmp.i, align 8
  %29 = cmpxchg ptr %this1.i10, i64 %27, i64 %28 acquire monotonic, align 8
  %30 = extractvalue { i64, i1 } %29, 0
  %31 = extractvalue { i64, i1 } %29, 1
  br i1 %31, label %cmpxchg.continue14.i, label %cmpxchg.store_expected13.i

acquire_fail10.i:                                 ; preds = %acquire.i12, %acquire.i12
  %32 = load i64, ptr %9, align 8
  %33 = load i64, ptr %.atomictmp.i, align 8
  %34 = cmpxchg ptr %this1.i10, i64 %32, i64 %33 acquire acquire, align 8
  %35 = extractvalue { i64, i1 } %34, 0
  %36 = extractvalue { i64, i1 } %34, 1
  br i1 %36, label %cmpxchg.continue17.i, label %cmpxchg.store_expected16.i

seqcst_fail11.i:                                  ; preds = %acquire.i12
  %37 = load i64, ptr %9, align 8
  %38 = load i64, ptr %.atomictmp.i, align 8
  %39 = cmpxchg ptr %this1.i10, i64 %37, i64 %38 acquire seq_cst, align 8
  %40 = extractvalue { i64, i1 } %39, 0
  %41 = extractvalue { i64, i1 } %39, 1
  br i1 %41, label %cmpxchg.continue20.i, label %cmpxchg.store_expected19.i

atomic.continue12.i:                              ; preds = %cmpxchg.continue20.i, %cmpxchg.continue17.i, %cmpxchg.continue14.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected13.i:                       ; preds = %monotonic_fail9.i
  store i64 %30, ptr %9, align 8
  br label %cmpxchg.continue14.i

cmpxchg.continue14.i:                             ; preds = %cmpxchg.store_expected13.i, %monotonic_fail9.i
  %frombool15.i = zext i1 %31 to i8
  store i8 %frombool15.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected16.i:                       ; preds = %acquire_fail10.i
  store i64 %35, ptr %9, align 8
  br label %cmpxchg.continue17.i

cmpxchg.continue17.i:                             ; preds = %cmpxchg.store_expected16.i, %acquire_fail10.i
  %frombool18.i = zext i1 %36 to i8
  store i8 %frombool18.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected19.i:                       ; preds = %seqcst_fail11.i
  store i64 %40, ptr %9, align 8
  br label %cmpxchg.continue20.i

cmpxchg.continue20.i:                             ; preds = %cmpxchg.store_expected19.i, %seqcst_fail11.i
  %frombool21.i = zext i1 %41 to i8
  store i8 %frombool21.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

monotonic_fail22.i:                               ; preds = %release.i
  %42 = load i64, ptr %9, align 8
  %43 = load i64, ptr %.atomictmp.i, align 8
  %44 = cmpxchg ptr %this1.i10, i64 %42, i64 %43 release monotonic, align 8
  %45 = extractvalue { i64, i1 } %44, 0
  %46 = extractvalue { i64, i1 } %44, 1
  br i1 %46, label %cmpxchg.continue27.i, label %cmpxchg.store_expected26.i

acquire_fail23.i:                                 ; preds = %release.i, %release.i
  %47 = load i64, ptr %9, align 8
  %48 = load i64, ptr %.atomictmp.i, align 8
  %49 = cmpxchg ptr %this1.i10, i64 %47, i64 %48 release acquire, align 8
  %50 = extractvalue { i64, i1 } %49, 0
  %51 = extractvalue { i64, i1 } %49, 1
  br i1 %51, label %cmpxchg.continue30.i, label %cmpxchg.store_expected29.i

seqcst_fail24.i:                                  ; preds = %release.i
  %52 = load i64, ptr %9, align 8
  %53 = load i64, ptr %.atomictmp.i, align 8
  %54 = cmpxchg ptr %this1.i10, i64 %52, i64 %53 release seq_cst, align 8
  %55 = extractvalue { i64, i1 } %54, 0
  %56 = extractvalue { i64, i1 } %54, 1
  br i1 %56, label %cmpxchg.continue33.i, label %cmpxchg.store_expected32.i

atomic.continue25.i:                              ; preds = %cmpxchg.continue33.i, %cmpxchg.continue30.i, %cmpxchg.continue27.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected26.i:                       ; preds = %monotonic_fail22.i
  store i64 %45, ptr %9, align 8
  br label %cmpxchg.continue27.i

cmpxchg.continue27.i:                             ; preds = %cmpxchg.store_expected26.i, %monotonic_fail22.i
  %frombool28.i = zext i1 %46 to i8
  store i8 %frombool28.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected29.i:                       ; preds = %acquire_fail23.i
  store i64 %50, ptr %9, align 8
  br label %cmpxchg.continue30.i

cmpxchg.continue30.i:                             ; preds = %cmpxchg.store_expected29.i, %acquire_fail23.i
  %frombool31.i = zext i1 %51 to i8
  store i8 %frombool31.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected32.i:                       ; preds = %seqcst_fail24.i
  store i64 %55, ptr %9, align 8
  br label %cmpxchg.continue33.i

cmpxchg.continue33.i:                             ; preds = %cmpxchg.store_expected32.i, %seqcst_fail24.i
  %frombool34.i = zext i1 %56 to i8
  store i8 %frombool34.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

monotonic_fail35.i:                               ; preds = %acqrel.i
  %57 = load i64, ptr %9, align 8
  %58 = load i64, ptr %.atomictmp.i, align 8
  %59 = cmpxchg ptr %this1.i10, i64 %57, i64 %58 acq_rel monotonic, align 8
  %60 = extractvalue { i64, i1 } %59, 0
  %61 = extractvalue { i64, i1 } %59, 1
  br i1 %61, label %cmpxchg.continue40.i, label %cmpxchg.store_expected39.i

acquire_fail36.i:                                 ; preds = %acqrel.i, %acqrel.i
  %62 = load i64, ptr %9, align 8
  %63 = load i64, ptr %.atomictmp.i, align 8
  %64 = cmpxchg ptr %this1.i10, i64 %62, i64 %63 acq_rel acquire, align 8
  %65 = extractvalue { i64, i1 } %64, 0
  %66 = extractvalue { i64, i1 } %64, 1
  br i1 %66, label %cmpxchg.continue43.i, label %cmpxchg.store_expected42.i

seqcst_fail37.i:                                  ; preds = %acqrel.i
  %67 = load i64, ptr %9, align 8
  %68 = load i64, ptr %.atomictmp.i, align 8
  %69 = cmpxchg ptr %this1.i10, i64 %67, i64 %68 acq_rel seq_cst, align 8
  %70 = extractvalue { i64, i1 } %69, 0
  %71 = extractvalue { i64, i1 } %69, 1
  br i1 %71, label %cmpxchg.continue46.i, label %cmpxchg.store_expected45.i

atomic.continue38.i:                              ; preds = %cmpxchg.continue46.i, %cmpxchg.continue43.i, %cmpxchg.continue40.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected39.i:                       ; preds = %monotonic_fail35.i
  store i64 %60, ptr %9, align 8
  br label %cmpxchg.continue40.i

cmpxchg.continue40.i:                             ; preds = %cmpxchg.store_expected39.i, %monotonic_fail35.i
  %frombool41.i = zext i1 %61 to i8
  store i8 %frombool41.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected42.i:                       ; preds = %acquire_fail36.i
  store i64 %65, ptr %9, align 8
  br label %cmpxchg.continue43.i

cmpxchg.continue43.i:                             ; preds = %cmpxchg.store_expected42.i, %acquire_fail36.i
  %frombool44.i = zext i1 %66 to i8
  store i8 %frombool44.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected45.i:                       ; preds = %seqcst_fail37.i
  store i64 %70, ptr %9, align 8
  br label %cmpxchg.continue46.i

cmpxchg.continue46.i:                             ; preds = %cmpxchg.store_expected45.i, %seqcst_fail37.i
  %frombool47.i = zext i1 %71 to i8
  store i8 %frombool47.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

monotonic_fail48.i:                               ; preds = %seqcst.i11
  %72 = load i64, ptr %9, align 8
  %73 = load i64, ptr %.atomictmp.i, align 8
  %74 = cmpxchg ptr %this1.i10, i64 %72, i64 %73 seq_cst monotonic, align 8
  %75 = extractvalue { i64, i1 } %74, 0
  %76 = extractvalue { i64, i1 } %74, 1
  br i1 %76, label %cmpxchg.continue53.i, label %cmpxchg.store_expected52.i

acquire_fail49.i:                                 ; preds = %seqcst.i11, %seqcst.i11
  %77 = load i64, ptr %9, align 8
  %78 = load i64, ptr %.atomictmp.i, align 8
  %79 = cmpxchg ptr %this1.i10, i64 %77, i64 %78 seq_cst acquire, align 8
  %80 = extractvalue { i64, i1 } %79, 0
  %81 = extractvalue { i64, i1 } %79, 1
  br i1 %81, label %cmpxchg.continue56.i, label %cmpxchg.store_expected55.i

seqcst_fail50.i:                                  ; preds = %seqcst.i11
  %82 = load i64, ptr %9, align 8
  %83 = load i64, ptr %.atomictmp.i, align 8
  %84 = cmpxchg ptr %this1.i10, i64 %82, i64 %83 seq_cst seq_cst, align 8
  %85 = extractvalue { i64, i1 } %84, 0
  %86 = extractvalue { i64, i1 } %84, 1
  br i1 %86, label %cmpxchg.continue59.i, label %cmpxchg.store_expected58.i

atomic.continue51.i:                              ; preds = %cmpxchg.continue59.i, %cmpxchg.continue56.i, %cmpxchg.continue53.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected52.i:                       ; preds = %monotonic_fail48.i
  store i64 %75, ptr %9, align 8
  br label %cmpxchg.continue53.i

cmpxchg.continue53.i:                             ; preds = %cmpxchg.store_expected52.i, %monotonic_fail48.i
  %frombool54.i = zext i1 %76 to i8
  store i8 %frombool54.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected55.i:                       ; preds = %acquire_fail49.i
  store i64 %80, ptr %9, align 8
  br label %cmpxchg.continue56.i

cmpxchg.continue56.i:                             ; preds = %cmpxchg.store_expected55.i, %acquire_fail49.i
  %frombool57.i = zext i1 %81 to i8
  store i8 %frombool57.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected58.i:                       ; preds = %seqcst_fail50.i
  store i64 %85, ptr %9, align 8
  br label %cmpxchg.continue59.i

cmpxchg.continue59.i:                             ; preds = %cmpxchg.store_expected58.i, %seqcst_fail50.i
  %frombool60.i = zext i1 %86 to i8
  store i8 %frombool60.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit: ; preds = %atomic.continue51.i, %atomic.continue38.i, %atomic.continue25.i, %atomic.continue12.i, %atomic.continue2.i
  %87 = load i8, ptr %cmpxchg.bool.i, align 1
  %tobool.i = trunc i8 %87 to i1
  br i1 %tobool.i, label %if.then6, label %if.end7

if.then6:                                         ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit
  br label %for.end

if.end7:                                          ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit
  br label %for.cond, !llvm.loop !14

for.end:                                          ; preds = %if.then6, %if.then
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %id, i64 8, i1 false)
  %coerce.dive8 = getelementptr inbounds %"struct.absl::synchronization_internal::GraphId", ptr %agg.tmp, i32 0, i32 0
  %88 = load i64, ptr %coerce.dive8, align 8
  call void @_ZN4abslL18DebugOnlyLockEnterEPNS_5MutexENS_24synchronization_internal7GraphIdE(ptr noundef %this1, i64 %88)
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local noundef zeroext i1 @_ZN4absl5Mutex14LockWhenCommonERKNS_9ConditionENS_24synchronization_internal13KernelTimeoutEb(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 8 dereferenceable(32) %cond, i64 %t.coerce, i1 noundef zeroext %write) #0 align 2 {
entry:
  %t = alloca %"class.absl::synchronization_internal::KernelTimeout", align 8
  %this.addr = alloca ptr, align 8
  %cond.addr = alloca ptr, align 8
  %write.addr = alloca i8, align 1
  %how = alloca ptr, align 8
  %id = alloca %"struct.absl::synchronization_internal::GraphId", align 8
  %res = alloca i8, align 1
  %agg.tmp = alloca %"class.absl::synchronization_internal::KernelTimeout", align 8
  %agg.tmp7 = alloca %"struct.absl::synchronization_internal::GraphId", align 8
  %coerce.dive = getelementptr inbounds %"class.absl::synchronization_internal::KernelTimeout", ptr %t, i32 0, i32 0
  store i64 %t.coerce, ptr %coerce.dive, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %cond, ptr %cond.addr, align 8
  %frombool = zext i1 %write to i8
  store i8 %frombool, ptr %write.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i8, ptr %write.addr, align 1
  %tobool = trunc i8 %0 to i1
  %cond2 = select i1 %tobool, ptr @_ZN4abslL11kExclusiveSE, ptr @_ZN4abslL8kSharedSE
  store ptr %cond2, ptr %how, align 8
  %call = call i64 @_ZN4abslL22DebugOnlyDeadlockCheckEPNS_5MutexE(ptr noundef %this1)
  %coerce.dive3 = getelementptr inbounds %"struct.absl::synchronization_internal::GraphId", ptr %id, i32 0, i32 0
  store i64 %call, ptr %coerce.dive3, align 8
  %1 = load ptr, ptr %how, align 8
  %2 = load ptr, ptr %cond.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %t, i64 8, i1 false)
  %coerce.dive4 = getelementptr inbounds %"class.absl::synchronization_internal::KernelTimeout", ptr %agg.tmp, i32 0, i32 0
  %3 = load i64, ptr %coerce.dive4, align 8
  %call5 = call noundef zeroext i1 @_ZN4absl5Mutex20LockSlowWithDeadlineEPKNS_6MuHowSEPKNS_9ConditionENS_24synchronization_internal13KernelTimeoutEi(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef %1, ptr noundef %2, i64 %3, i32 noundef 0)
  %frombool6 = zext i1 %call5 to i8
  store i8 %frombool6, ptr %res, align 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp7, ptr align 8 %id, i64 8, i1 false)
  %coerce.dive8 = getelementptr inbounds %"struct.absl::synchronization_internal::GraphId", ptr %agg.tmp7, i32 0, i32 0
  %4 = load i64, ptr %coerce.dive8, align 8
  call void @_ZN4abslL18DebugOnlyLockEnterEPNS_5MutexENS_24synchronization_internal7GraphIdE(ptr noundef %this1, i64 %4)
  %5 = load i8, ptr %res, align 1
  %tobool9 = trunc i8 %5 to i1
  ret i1 %tobool9
}

; Function Attrs: mustprogress uwtable
define dso_local noundef zeroext i1 @_ZN4absl5Mutex20LockSlowWithDeadlineEPKNS_6MuHowSEPKNS_9ConditionENS_24synchronization_internal13KernelTimeoutEi(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %how, ptr noundef %cond, i64 %t.coerce, i32 noundef %flags) #0 align 2 {
entry:
  %this.addr.i27 = alloca ptr, align 8
  %__i1.addr.i = alloca ptr, align 8
  %__i2.addr.i = alloca i64, align 8
  %__m1.addr.i = alloca i32, align 4
  %__m2.addr.i = alloca i32, align 4
  %.atomictmp.i = alloca i64, align 8
  %cmpxchg.bool.i = alloca i8, align 1
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i64, align 8
  %retval = alloca i1, align 1
  %t = alloca %"class.absl::synchronization_internal::KernelTimeout", align 8
  %this.addr = alloca ptr, align 8
  %how.addr = alloca ptr, align 8
  %cond.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %v = alloca i64, align 8
  %unlock = alloca i8, align 1
  %waitp = alloca %"struct.absl::SynchWaitParams", align 8
  %agg.tmp = alloca %"class.absl::synchronization_internal::KernelTimeout", align 8
  %coerce.dive = getelementptr inbounds %"class.absl::synchronization_internal::KernelTimeout", ptr %t, i32 0, i32 0
  store i64 %t.coerce, ptr %coerce.dive, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %how, ptr %how.addr, align 8
  store ptr %cond, ptr %cond.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %mu_ = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  store ptr %mu_, ptr %this.addr.i, align 8
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %0 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %0, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %1 = load i32, ptr %__m.addr.i, align 4
  switch i32 %1, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %entry
  %2 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %2, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %entry, %entry
  %3 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %3, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %entry
  %4 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %4, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %5 = load i64, ptr %atomic-temp.i, align 8
  store i64 %5, ptr %v, align 8
  store i8 0, ptr %unlock, align 1
  %6 = load i64, ptr %v, align 8
  %7 = load ptr, ptr %how.addr, align 8
  %fast_need_zero = getelementptr inbounds %"struct.absl::MuHowS", ptr %7, i32 0, i32 0
  %8 = load i64, ptr %fast_need_zero, align 8
  %and = and i64 %6, %8
  %cmp = icmp eq i64 %and, 0
  br i1 %cmp, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  %mu_2 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %9 = load ptr, ptr %how.addr, align 8
  %fast_or = getelementptr inbounds %"struct.absl::MuHowS", ptr %9, i32 0, i32 1
  %10 = load i64, ptr %fast_or, align 8
  %11 = load i64, ptr %v, align 8
  %12 = load i32, ptr %flags.addr, align 4
  %and3 = and i32 %12, 1
  %call4 = call noundef i64 @_ZN4abslL24ClearDesignatedWakerMaskEi(i32 noundef %and3)
  %and5 = and i64 %11, %call4
  %or = or i64 %10, %and5
  %13 = load ptr, ptr %how.addr, align 8
  %fast_add = getelementptr inbounds %"struct.absl::MuHowS", ptr %13, i32 0, i32 2
  %14 = load i64, ptr %fast_add, align 8
  %add = add nsw i64 %or, %14
  store ptr %mu_2, ptr %this.addr.i27, align 8
  store ptr %v, ptr %__i1.addr.i, align 8
  store i64 %add, ptr %__i2.addr.i, align 8
  store i32 2, ptr %__m1.addr.i, align 4
  store i32 0, ptr %__m2.addr.i, align 4
  %this1.i28 = load ptr, ptr %this.addr.i27, align 8
  %15 = load i32, ptr %__m1.addr.i, align 4
  %16 = load ptr, ptr %__i1.addr.i, align 8
  %17 = load i64, ptr %__i2.addr.i, align 8
  store i64 %17, ptr %.atomictmp.i, align 8
  %18 = load i32, ptr %__m2.addr.i, align 4
  switch i32 %15, label %monotonic.i31 [
    i32 1, label %acquire.i30
    i32 2, label %acquire.i30
    i32 3, label %release.i
    i32 4, label %acqrel.i
    i32 5, label %seqcst.i29
  ]

monotonic.i31:                                    ; preds = %land.lhs.true
  switch i32 %18, label %monotonic_fail.i [
    i32 1, label %acquire_fail.i
    i32 2, label %acquire_fail.i
    i32 5, label %seqcst_fail.i
  ]

acquire.i30:                                      ; preds = %land.lhs.true, %land.lhs.true
  switch i32 %18, label %monotonic_fail9.i [
    i32 1, label %acquire_fail10.i
    i32 2, label %acquire_fail10.i
    i32 5, label %seqcst_fail11.i
  ]

release.i:                                        ; preds = %land.lhs.true
  switch i32 %18, label %monotonic_fail22.i [
    i32 1, label %acquire_fail23.i
    i32 2, label %acquire_fail23.i
    i32 5, label %seqcst_fail24.i
  ]

acqrel.i:                                         ; preds = %land.lhs.true
  switch i32 %18, label %monotonic_fail35.i [
    i32 1, label %acquire_fail36.i
    i32 2, label %acquire_fail36.i
    i32 5, label %seqcst_fail37.i
  ]

seqcst.i29:                                       ; preds = %land.lhs.true
  switch i32 %18, label %monotonic_fail48.i [
    i32 1, label %acquire_fail49.i
    i32 2, label %acquire_fail49.i
    i32 5, label %seqcst_fail50.i
  ]

monotonic_fail.i:                                 ; preds = %monotonic.i31
  %19 = load i64, ptr %16, align 8
  %20 = load i64, ptr %.atomictmp.i, align 8
  %21 = cmpxchg ptr %this1.i28, i64 %19, i64 %20 monotonic monotonic, align 8
  %22 = extractvalue { i64, i1 } %21, 0
  %23 = extractvalue { i64, i1 } %21, 1
  br i1 %23, label %cmpxchg.continue.i, label %cmpxchg.store_expected.i

acquire_fail.i:                                   ; preds = %monotonic.i31, %monotonic.i31
  %24 = load i64, ptr %16, align 8
  %25 = load i64, ptr %.atomictmp.i, align 8
  %26 = cmpxchg ptr %this1.i28, i64 %24, i64 %25 monotonic acquire, align 8
  %27 = extractvalue { i64, i1 } %26, 0
  %28 = extractvalue { i64, i1 } %26, 1
  br i1 %28, label %cmpxchg.continue4.i, label %cmpxchg.store_expected3.i

seqcst_fail.i:                                    ; preds = %monotonic.i31
  %29 = load i64, ptr %16, align 8
  %30 = load i64, ptr %.atomictmp.i, align 8
  %31 = cmpxchg ptr %this1.i28, i64 %29, i64 %30 monotonic seq_cst, align 8
  %32 = extractvalue { i64, i1 } %31, 0
  %33 = extractvalue { i64, i1 } %31, 1
  br i1 %33, label %cmpxchg.continue7.i, label %cmpxchg.store_expected6.i

atomic.continue2.i:                               ; preds = %cmpxchg.continue7.i, %cmpxchg.continue4.i, %cmpxchg.continue.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected.i:                         ; preds = %monotonic_fail.i
  store i64 %22, ptr %16, align 8
  br label %cmpxchg.continue.i

cmpxchg.continue.i:                               ; preds = %cmpxchg.store_expected.i, %monotonic_fail.i
  %frombool.i = zext i1 %23 to i8
  store i8 %frombool.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected3.i:                        ; preds = %acquire_fail.i
  store i64 %27, ptr %16, align 8
  br label %cmpxchg.continue4.i

cmpxchg.continue4.i:                              ; preds = %cmpxchg.store_expected3.i, %acquire_fail.i
  %frombool5.i = zext i1 %28 to i8
  store i8 %frombool5.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected6.i:                        ; preds = %seqcst_fail.i
  store i64 %32, ptr %16, align 8
  br label %cmpxchg.continue7.i

cmpxchg.continue7.i:                              ; preds = %cmpxchg.store_expected6.i, %seqcst_fail.i
  %frombool8.i = zext i1 %33 to i8
  store i8 %frombool8.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

monotonic_fail9.i:                                ; preds = %acquire.i30
  %34 = load i64, ptr %16, align 8
  %35 = load i64, ptr %.atomictmp.i, align 8
  %36 = cmpxchg ptr %this1.i28, i64 %34, i64 %35 acquire monotonic, align 8
  %37 = extractvalue { i64, i1 } %36, 0
  %38 = extractvalue { i64, i1 } %36, 1
  br i1 %38, label %cmpxchg.continue14.i, label %cmpxchg.store_expected13.i

acquire_fail10.i:                                 ; preds = %acquire.i30, %acquire.i30
  %39 = load i64, ptr %16, align 8
  %40 = load i64, ptr %.atomictmp.i, align 8
  %41 = cmpxchg ptr %this1.i28, i64 %39, i64 %40 acquire acquire, align 8
  %42 = extractvalue { i64, i1 } %41, 0
  %43 = extractvalue { i64, i1 } %41, 1
  br i1 %43, label %cmpxchg.continue17.i, label %cmpxchg.store_expected16.i

seqcst_fail11.i:                                  ; preds = %acquire.i30
  %44 = load i64, ptr %16, align 8
  %45 = load i64, ptr %.atomictmp.i, align 8
  %46 = cmpxchg ptr %this1.i28, i64 %44, i64 %45 acquire seq_cst, align 8
  %47 = extractvalue { i64, i1 } %46, 0
  %48 = extractvalue { i64, i1 } %46, 1
  br i1 %48, label %cmpxchg.continue20.i, label %cmpxchg.store_expected19.i

atomic.continue12.i:                              ; preds = %cmpxchg.continue20.i, %cmpxchg.continue17.i, %cmpxchg.continue14.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected13.i:                       ; preds = %monotonic_fail9.i
  store i64 %37, ptr %16, align 8
  br label %cmpxchg.continue14.i

cmpxchg.continue14.i:                             ; preds = %cmpxchg.store_expected13.i, %monotonic_fail9.i
  %frombool15.i = zext i1 %38 to i8
  store i8 %frombool15.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected16.i:                       ; preds = %acquire_fail10.i
  store i64 %42, ptr %16, align 8
  br label %cmpxchg.continue17.i

cmpxchg.continue17.i:                             ; preds = %cmpxchg.store_expected16.i, %acquire_fail10.i
  %frombool18.i = zext i1 %43 to i8
  store i8 %frombool18.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected19.i:                       ; preds = %seqcst_fail11.i
  store i64 %47, ptr %16, align 8
  br label %cmpxchg.continue20.i

cmpxchg.continue20.i:                             ; preds = %cmpxchg.store_expected19.i, %seqcst_fail11.i
  %frombool21.i = zext i1 %48 to i8
  store i8 %frombool21.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

monotonic_fail22.i:                               ; preds = %release.i
  %49 = load i64, ptr %16, align 8
  %50 = load i64, ptr %.atomictmp.i, align 8
  %51 = cmpxchg ptr %this1.i28, i64 %49, i64 %50 release monotonic, align 8
  %52 = extractvalue { i64, i1 } %51, 0
  %53 = extractvalue { i64, i1 } %51, 1
  br i1 %53, label %cmpxchg.continue27.i, label %cmpxchg.store_expected26.i

acquire_fail23.i:                                 ; preds = %release.i, %release.i
  %54 = load i64, ptr %16, align 8
  %55 = load i64, ptr %.atomictmp.i, align 8
  %56 = cmpxchg ptr %this1.i28, i64 %54, i64 %55 release acquire, align 8
  %57 = extractvalue { i64, i1 } %56, 0
  %58 = extractvalue { i64, i1 } %56, 1
  br i1 %58, label %cmpxchg.continue30.i, label %cmpxchg.store_expected29.i

seqcst_fail24.i:                                  ; preds = %release.i
  %59 = load i64, ptr %16, align 8
  %60 = load i64, ptr %.atomictmp.i, align 8
  %61 = cmpxchg ptr %this1.i28, i64 %59, i64 %60 release seq_cst, align 8
  %62 = extractvalue { i64, i1 } %61, 0
  %63 = extractvalue { i64, i1 } %61, 1
  br i1 %63, label %cmpxchg.continue33.i, label %cmpxchg.store_expected32.i

atomic.continue25.i:                              ; preds = %cmpxchg.continue33.i, %cmpxchg.continue30.i, %cmpxchg.continue27.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected26.i:                       ; preds = %monotonic_fail22.i
  store i64 %52, ptr %16, align 8
  br label %cmpxchg.continue27.i

cmpxchg.continue27.i:                             ; preds = %cmpxchg.store_expected26.i, %monotonic_fail22.i
  %frombool28.i = zext i1 %53 to i8
  store i8 %frombool28.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected29.i:                       ; preds = %acquire_fail23.i
  store i64 %57, ptr %16, align 8
  br label %cmpxchg.continue30.i

cmpxchg.continue30.i:                             ; preds = %cmpxchg.store_expected29.i, %acquire_fail23.i
  %frombool31.i = zext i1 %58 to i8
  store i8 %frombool31.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected32.i:                       ; preds = %seqcst_fail24.i
  store i64 %62, ptr %16, align 8
  br label %cmpxchg.continue33.i

cmpxchg.continue33.i:                             ; preds = %cmpxchg.store_expected32.i, %seqcst_fail24.i
  %frombool34.i = zext i1 %63 to i8
  store i8 %frombool34.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

monotonic_fail35.i:                               ; preds = %acqrel.i
  %64 = load i64, ptr %16, align 8
  %65 = load i64, ptr %.atomictmp.i, align 8
  %66 = cmpxchg ptr %this1.i28, i64 %64, i64 %65 acq_rel monotonic, align 8
  %67 = extractvalue { i64, i1 } %66, 0
  %68 = extractvalue { i64, i1 } %66, 1
  br i1 %68, label %cmpxchg.continue40.i, label %cmpxchg.store_expected39.i

acquire_fail36.i:                                 ; preds = %acqrel.i, %acqrel.i
  %69 = load i64, ptr %16, align 8
  %70 = load i64, ptr %.atomictmp.i, align 8
  %71 = cmpxchg ptr %this1.i28, i64 %69, i64 %70 acq_rel acquire, align 8
  %72 = extractvalue { i64, i1 } %71, 0
  %73 = extractvalue { i64, i1 } %71, 1
  br i1 %73, label %cmpxchg.continue43.i, label %cmpxchg.store_expected42.i

seqcst_fail37.i:                                  ; preds = %acqrel.i
  %74 = load i64, ptr %16, align 8
  %75 = load i64, ptr %.atomictmp.i, align 8
  %76 = cmpxchg ptr %this1.i28, i64 %74, i64 %75 acq_rel seq_cst, align 8
  %77 = extractvalue { i64, i1 } %76, 0
  %78 = extractvalue { i64, i1 } %76, 1
  br i1 %78, label %cmpxchg.continue46.i, label %cmpxchg.store_expected45.i

atomic.continue38.i:                              ; preds = %cmpxchg.continue46.i, %cmpxchg.continue43.i, %cmpxchg.continue40.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected39.i:                       ; preds = %monotonic_fail35.i
  store i64 %67, ptr %16, align 8
  br label %cmpxchg.continue40.i

cmpxchg.continue40.i:                             ; preds = %cmpxchg.store_expected39.i, %monotonic_fail35.i
  %frombool41.i = zext i1 %68 to i8
  store i8 %frombool41.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected42.i:                       ; preds = %acquire_fail36.i
  store i64 %72, ptr %16, align 8
  br label %cmpxchg.continue43.i

cmpxchg.continue43.i:                             ; preds = %cmpxchg.store_expected42.i, %acquire_fail36.i
  %frombool44.i = zext i1 %73 to i8
  store i8 %frombool44.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected45.i:                       ; preds = %seqcst_fail37.i
  store i64 %77, ptr %16, align 8
  br label %cmpxchg.continue46.i

cmpxchg.continue46.i:                             ; preds = %cmpxchg.store_expected45.i, %seqcst_fail37.i
  %frombool47.i = zext i1 %78 to i8
  store i8 %frombool47.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

monotonic_fail48.i:                               ; preds = %seqcst.i29
  %79 = load i64, ptr %16, align 8
  %80 = load i64, ptr %.atomictmp.i, align 8
  %81 = cmpxchg ptr %this1.i28, i64 %79, i64 %80 seq_cst monotonic, align 8
  %82 = extractvalue { i64, i1 } %81, 0
  %83 = extractvalue { i64, i1 } %81, 1
  br i1 %83, label %cmpxchg.continue53.i, label %cmpxchg.store_expected52.i

acquire_fail49.i:                                 ; preds = %seqcst.i29, %seqcst.i29
  %84 = load i64, ptr %16, align 8
  %85 = load i64, ptr %.atomictmp.i, align 8
  %86 = cmpxchg ptr %this1.i28, i64 %84, i64 %85 seq_cst acquire, align 8
  %87 = extractvalue { i64, i1 } %86, 0
  %88 = extractvalue { i64, i1 } %86, 1
  br i1 %88, label %cmpxchg.continue56.i, label %cmpxchg.store_expected55.i

seqcst_fail50.i:                                  ; preds = %seqcst.i29
  %89 = load i64, ptr %16, align 8
  %90 = load i64, ptr %.atomictmp.i, align 8
  %91 = cmpxchg ptr %this1.i28, i64 %89, i64 %90 seq_cst seq_cst, align 8
  %92 = extractvalue { i64, i1 } %91, 0
  %93 = extractvalue { i64, i1 } %91, 1
  br i1 %93, label %cmpxchg.continue59.i, label %cmpxchg.store_expected58.i

atomic.continue51.i:                              ; preds = %cmpxchg.continue59.i, %cmpxchg.continue56.i, %cmpxchg.continue53.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected52.i:                       ; preds = %monotonic_fail48.i
  store i64 %82, ptr %16, align 8
  br label %cmpxchg.continue53.i

cmpxchg.continue53.i:                             ; preds = %cmpxchg.store_expected52.i, %monotonic_fail48.i
  %frombool54.i = zext i1 %83 to i8
  store i8 %frombool54.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected55.i:                       ; preds = %acquire_fail49.i
  store i64 %87, ptr %16, align 8
  br label %cmpxchg.continue56.i

cmpxchg.continue56.i:                             ; preds = %cmpxchg.store_expected55.i, %acquire_fail49.i
  %frombool57.i = zext i1 %88 to i8
  store i8 %frombool57.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected58.i:                       ; preds = %seqcst_fail50.i
  store i64 %92, ptr %16, align 8
  br label %cmpxchg.continue59.i

cmpxchg.continue59.i:                             ; preds = %cmpxchg.store_expected58.i, %seqcst_fail50.i
  %frombool60.i = zext i1 %93 to i8
  store i8 %frombool60.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit: ; preds = %atomic.continue51.i, %atomic.continue38.i, %atomic.continue25.i, %atomic.continue12.i, %atomic.continue2.i
  %94 = load i8, ptr %cmpxchg.bool.i, align 1
  %tobool.i = trunc i8 %94 to i1
  br i1 %tobool.i, label %if.then, label %if.end11

if.then:                                          ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit
  %95 = load ptr, ptr %cond.addr, align 8
  %cmp7 = icmp eq ptr %95, null
  br i1 %cmp7, label %if.then10, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %96 = load ptr, ptr %cond.addr, align 8
  %97 = load ptr, ptr %how.addr, align 8
  %cmp8 = icmp eq ptr %97, @_ZN4abslL8kSharedSE
  %call9 = call noundef zeroext i1 @_ZN4abslL22EvalConditionAnnotatedEPKNS_9ConditionEPNS_5MutexEbbb(ptr noundef %96, ptr noundef %this1, i1 noundef zeroext true, i1 noundef zeroext false, i1 noundef zeroext %cmp8)
  br i1 %call9, label %if.then10, label %if.end

if.then10:                                        ; preds = %lor.lhs.false, %if.then
  store i1 true, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  store i8 1, ptr %unlock, align 1
  br label %if.end11

if.end11:                                         ; preds = %if.end, %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit, %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  %98 = load ptr, ptr %how.addr, align 8
  %99 = load ptr, ptr %cond.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %t, i64 8, i1 false)
  %call12 = call noundef ptr @_ZN4abslL27Synch_GetPerThreadAnnotatedEPNS_5MutexE(ptr noundef %this1)
  %coerce.dive13 = getelementptr inbounds %"class.absl::synchronization_internal::KernelTimeout", ptr %agg.tmp, i32 0, i32 0
  %100 = load i64, ptr %coerce.dive13, align 8
  call void @_ZN4absl15SynchWaitParamsC2EPKNS_6MuHowSEPKNS_9ConditionENS_24synchronization_internal13KernelTimeoutEPNS_5MutexEPNS_13base_internal14PerThreadSynchEPSt6atomicIlE(ptr noundef nonnull align 8 dereferenceable(57) %waitp, ptr noundef %98, ptr noundef %99, i64 %100, ptr noundef null, ptr noundef %call12, ptr noundef null)
  %101 = load ptr, ptr %cond.addr, align 8
  %cmp14 = icmp ne ptr %101, null
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end11
  %102 = load i32, ptr %flags.addr, align 4
  %or16 = or i32 %102, 2
  store i32 %or16, ptr %flags.addr, align 4
  br label %if.end17

if.end17:                                         ; preds = %if.then15, %if.end11
  %103 = load i8, ptr %unlock, align 1
  %tobool = trunc i8 %103 to i1
  br i1 %tobool, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.end17
  call void @_ZN4absl5Mutex10UnlockSlowEPNS_15SynchWaitParamsE(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef %waitp) #16
  %thread = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %waitp, i32 0, i32 4
  %104 = load ptr, ptr %thread, align 8
  call void @_ZN4absl5Mutex5BlockEPNS_13base_internal14PerThreadSynchE(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef %104)
  %105 = load i32, ptr %flags.addr, align 4
  %or19 = or i32 %105, 1
  store i32 %or19, ptr %flags.addr, align 4
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %if.end17
  %106 = load i32, ptr %flags.addr, align 4
  call void @_ZN4absl5Mutex12LockSlowLoopEPNS_15SynchWaitParamsEi(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef %waitp, i32 noundef %106)
  %cond21 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %waitp, i32 0, i32 1
  %107 = load ptr, ptr %cond21, align 8
  %cmp22 = icmp ne ptr %107, null
  br i1 %cmp22, label %lor.end, label %lor.lhs.false23

lor.lhs.false23:                                  ; preds = %if.end20
  %108 = load ptr, ptr %cond.addr, align 8
  %cmp24 = icmp eq ptr %108, null
  br i1 %cmp24, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false23
  %109 = load ptr, ptr %cond.addr, align 8
  %110 = load ptr, ptr %how.addr, align 8
  %cmp25 = icmp eq ptr %110, @_ZN4abslL8kSharedSE
  %call26 = call noundef zeroext i1 @_ZN4abslL22EvalConditionAnnotatedEPKNS_9ConditionEPNS_5MutexEbbb(ptr noundef %109, ptr noundef %this1, i1 noundef zeroext true, i1 noundef zeroext false, i1 noundef zeroext %cmp25)
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false23, %if.end20
  %111 = phi i1 [ true, %lor.lhs.false23 ], [ true, %if.end20 ], [ %call26, %lor.rhs ]
  store i1 %111, ptr %retval, align 1
  br label %return

return:                                           ; preds = %lor.end, %if.then10
  %112 = load i1, ptr %retval, align 1
  ret i1 %112
}

; Function Attrs: mustprogress uwtable
define dso_local noundef zeroext i1 @_ZN4absl5Mutex11AwaitCommonERKNS_9ConditionENS_24synchronization_internal13KernelTimeoutE(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 8 dereferenceable(32) %cond, i64 %t.coerce) #0 align 2 {
entry:
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i64, align 8
  %retval = alloca i1, align 1
  %t = alloca %"class.absl::synchronization_internal::KernelTimeout", align 8
  %this.addr = alloca ptr, align 8
  %cond.addr = alloca ptr, align 8
  %how = alloca ptr, align 8
  %waitp = alloca %"struct.absl::SynchWaitParams", align 8
  %agg.tmp = alloca %"class.absl::synchronization_internal::KernelTimeout", align 8
  %res = alloca i8, align 1
  %absl_raw_log_internal_basename = alloca ptr, align 8
  %coerce.dive = getelementptr inbounds %"class.absl::synchronization_internal::KernelTimeout", ptr %t, i32 0, i32 0
  store i64 %t.coerce, ptr %coerce.dive, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %cond, ptr %cond.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %cond.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4absl9Condition4EvalEv(ptr noundef nonnull align 8 dereferenceable(32) %0)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %mu_ = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  store ptr %mu_, ptr %this.addr.i, align 8
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %1 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %1, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %2 = load i32, ptr %__m.addr.i, align 4
  switch i32 %2, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %if.end
  %3 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %3, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %if.end, %if.end
  %4 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %4, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %if.end
  %5 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %5, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %6 = load i64, ptr %atomic-temp.i, align 8
  %and = and i64 %6, 8
  %tobool = icmp ne i64 %and, 0
  %cond3 = select i1 %tobool, ptr @_ZN4abslL11kExclusiveSE, ptr @_ZN4abslL8kSharedSE
  store ptr %cond3, ptr %how, align 8
  %7 = load ptr, ptr %how, align 8
  %8 = load ptr, ptr %cond.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %t, i64 8, i1 false)
  %call4 = call noundef ptr @_ZN4abslL27Synch_GetPerThreadAnnotatedEPNS_5MutexE(ptr noundef %this1)
  %coerce.dive5 = getelementptr inbounds %"class.absl::synchronization_internal::KernelTimeout", ptr %agg.tmp, i32 0, i32 0
  %9 = load i64, ptr %coerce.dive5, align 8
  call void @_ZN4absl15SynchWaitParamsC2EPKNS_6MuHowSEPKNS_9ConditionENS_24synchronization_internal13KernelTimeoutEPNS_5MutexEPNS_13base_internal14PerThreadSynchEPSt6atomicIlE(ptr noundef nonnull align 8 dereferenceable(57) %waitp, ptr noundef %7, ptr noundef %8, i64 %9, ptr noundef null, ptr noundef %call4, ptr noundef null)
  call void @_ZN4absl5Mutex10UnlockSlowEPNS_15SynchWaitParamsE(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef %waitp) #16
  %thread = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %waitp, i32 0, i32 4
  %10 = load ptr, ptr %thread, align 8
  call void @_ZN4absl5Mutex5BlockEPNS_13base_internal14PerThreadSynchE(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef %10)
  call void @_ZN4absl5Mutex12LockSlowLoopEPNS_15SynchWaitParamsEi(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef %waitp, i32 noundef 3)
  %cond6 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %waitp, i32 0, i32 1
  %11 = load ptr, ptr %cond6, align 8
  %cmp = icmp ne ptr %11, null
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  %12 = load ptr, ptr %cond.addr, align 8
  %13 = load ptr, ptr %how, align 8
  %cmp7 = icmp eq ptr %13, @_ZN4abslL8kSharedSE
  %call8 = call noundef zeroext i1 @_ZN4abslL22EvalConditionAnnotatedEPKNS_9ConditionEPNS_5MutexEbbb(ptr noundef %12, ptr noundef %this1, i1 noundef zeroext true, i1 noundef zeroext false, i1 noundef zeroext %cmp7)
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  %14 = phi i1 [ true, %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit ], [ %call8, %lor.rhs ]
  %frombool = zext i1 %14 to i8
  store i8 %frombool, ptr %res, align 1
  br label %do.body

do.body:                                          ; preds = %lor.end
  %15 = load i8, ptr %res, align 1
  %tobool9 = trunc i8 %15 to i1
  br i1 %tobool9, label %lor.end12, label %lor.rhs10

lor.rhs10:                                        ; preds = %do.body
  %call11 = call noundef zeroext i1 @_ZNK4absl24synchronization_internal13KernelTimeout11has_timeoutEv(ptr noundef nonnull align 8 dereferenceable(8) %t)
  br label %lor.end12

lor.end12:                                        ; preds = %lor.rhs10, %do.body
  %16 = phi i1 [ true, %do.body ], [ %call11, %lor.rhs10 ]
  %lnot = xor i1 %16, true
  br i1 %lnot, label %if.then13, label %if.end17

if.then13:                                        ; preds = %lor.end12
  br label %do.body14

do.body14:                                        ; preds = %if.then13
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename, align 8
  call void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 1588, ptr noundef @.str.1, ptr noundef @.str.4, ptr noundef @.str.5)
  br label %do.body15

do.body15:                                        ; preds = %do.body14
  unreachable

do.end:                                           ; No predecessors!
  br label %do.end16

do.end16:                                         ; preds = %do.end
  br label %if.end17

if.end17:                                         ; preds = %do.end16, %lor.end12
  br label %do.end18

do.end18:                                         ; preds = %if.end17
  %17 = load i8, ptr %res, align 1
  %tobool19 = trunc i8 %17 to i1
  store i1 %tobool19, ptr %retval, align 1
  br label %return

return:                                           ; preds = %do.end18, %if.then
  %18 = load i1, ptr %retval, align 1
  ret i1 %18
}

; Function Attrs: mustprogress uwtable
define dso_local noundef zeroext i1 @_ZNK4absl9Condition4EvalEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %eval_ = getelementptr inbounds %"class.absl::Condition", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %eval_, align 8
  %call = call noundef zeroext i1 %0(ptr noundef %this1)
  ret i1 %call
}

; Function Attrs: mustprogress uwtable
define internal noundef ptr @_ZN4abslL27Synch_GetPerThreadAnnotatedEPNS_5MutexE(ptr noundef %mu) #0 {
entry:
  %mu.addr = alloca ptr, align 8
  %w = alloca ptr, align 8
  store ptr %mu, ptr %mu.addr, align 8
  %0 = load ptr, ptr %mu.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call = call noundef ptr @_ZN4abslL18Synch_GetPerThreadEv()
  store ptr %call, ptr %w, align 8
  %1 = load ptr, ptr %mu.addr, align 8
  %tobool1 = icmp ne ptr %1, null
  br i1 %tobool1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %2 = load ptr, ptr %w, align 8
  ret ptr %2
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN4absl15SynchWaitParamsC2EPKNS_6MuHowSEPKNS_9ConditionENS_24synchronization_internal13KernelTimeoutEPNS_5MutexEPNS_13base_internal14PerThreadSynchEPSt6atomicIlE(ptr noundef nonnull align 8 dereferenceable(57) %this, ptr noundef %how_arg, ptr noundef %cond_arg, i64 %timeout_arg.coerce, ptr noundef %cvmu_arg, ptr noundef %thread_arg, ptr noundef %cv_word_arg) unnamed_addr #0 comdat align 2 {
entry:
  %timeout_arg = alloca %"class.absl::synchronization_internal::KernelTimeout", align 8
  %this.addr = alloca ptr, align 8
  %how_arg.addr = alloca ptr, align 8
  %cond_arg.addr = alloca ptr, align 8
  %cvmu_arg.addr = alloca ptr, align 8
  %thread_arg.addr = alloca ptr, align 8
  %cv_word_arg.addr = alloca ptr, align 8
  %coerce.dive = getelementptr inbounds %"class.absl::synchronization_internal::KernelTimeout", ptr %timeout_arg, i32 0, i32 0
  store i64 %timeout_arg.coerce, ptr %coerce.dive, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %how_arg, ptr %how_arg.addr, align 8
  store ptr %cond_arg, ptr %cond_arg.addr, align 8
  store ptr %cvmu_arg, ptr %cvmu_arg.addr, align 8
  store ptr %thread_arg, ptr %thread_arg.addr, align 8
  store ptr %cv_word_arg, ptr %cv_word_arg.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %how = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %how_arg.addr, align 8
  store ptr %0, ptr %how, align 8
  %cond = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %cond_arg.addr, align 8
  store ptr %1, ptr %cond, align 8
  %timeout = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %this1, i32 0, i32 2
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %timeout, ptr align 8 %timeout_arg, i64 8, i1 false)
  %cvmu = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %this1, i32 0, i32 3
  %2 = load ptr, ptr %cvmu_arg.addr, align 8
  store ptr %2, ptr %cvmu, align 8
  %thread = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %this1, i32 0, i32 4
  %3 = load ptr, ptr %thread_arg.addr, align 8
  store ptr %3, ptr %thread, align 8
  %cv_word = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %this1, i32 0, i32 5
  %4 = load ptr, ptr %cv_word_arg.addr, align 8
  store ptr %4, ptr %cv_word, align 8
  %contention_start_cycles = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %this1, i32 0, i32 6
  %call = call noundef i64 @_ZN4absl13base_internal10CycleClock3NowEv()
  store i64 %call, ptr %contention_start_cycles, align 8
  %should_submit_contention_data = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %this1, i32 0, i32 7
  store i8 0, ptr %should_submit_contention_data, align 8
  ret void
}

; Function Attrs: cold mustprogress uwtable
define dso_local void @_ZN4absl5Mutex10UnlockSlowEPNS_15SynchWaitParamsE(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %waitp) #5 align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr.i679 = alloca ptr, align 8
  %__i.addr.i680 = alloca i64, align 8
  %__m.addr.i681 = alloca i32, align 4
  %__b.i682 = alloca i32, align 4
  %.atomictmp.i683 = alloca i64, align 8
  %this.addr.i668 = alloca ptr, align 8
  %__i.addr.i669 = alloca i64, align 8
  %__m.addr.i670 = alloca i32, align 4
  %__b.i671 = alloca i32, align 4
  %.atomictmp.i672 = alloca i64, align 8
  %this.addr.i657 = alloca ptr, align 8
  %__i.addr.i658 = alloca i64, align 8
  %__m.addr.i659 = alloca i32, align 4
  %__b.i660 = alloca i32, align 4
  %.atomictmp.i661 = alloca i64, align 8
  %this.addr.i648 = alloca ptr, align 8
  %__i.addr.i = alloca i64, align 8
  %__m.addr.i649 = alloca i32, align 4
  %__b.i650 = alloca i32, align 4
  %.atomictmp.i651 = alloca i64, align 8
  %this.addr.i569 = alloca ptr, align 8
  %__i1.addr.i570 = alloca ptr, align 8
  %__i2.addr.i571 = alloca i64, align 8
  %__m1.addr.i572 = alloca i32, align 4
  %__m2.addr.i573 = alloca i32, align 4
  %.atomictmp.i574 = alloca i64, align 8
  %cmpxchg.bool.i575 = alloca i8, align 1
  %this.addr.i489 = alloca ptr, align 8
  %__i1.addr.i490 = alloca ptr, align 8
  %__i2.addr.i491 = alloca i64, align 8
  %__m1.addr.i492 = alloca i32, align 4
  %__m2.addr.i493 = alloca i32, align 4
  %.atomictmp.i494 = alloca i64, align 8
  %cmpxchg.bool.i495 = alloca i8, align 1
  %this.addr.i409 = alloca ptr, align 8
  %__i1.addr.i410 = alloca ptr, align 8
  %__i2.addr.i411 = alloca i64, align 8
  %__m1.addr.i412 = alloca i32, align 4
  %__m2.addr.i413 = alloca i32, align 4
  %.atomictmp.i414 = alloca i64, align 8
  %cmpxchg.bool.i415 = alloca i8, align 1
  %this.addr.i404 = alloca ptr, align 8
  %__i1.addr.i = alloca ptr, align 8
  %__i2.addr.i = alloca i64, align 8
  %__m1.addr.i = alloca i32, align 4
  %__m2.addr.i = alloca i32, align 4
  %.atomictmp.i = alloca i64, align 8
  %cmpxchg.bool.i = alloca i8, align 1
  %this.addr.i394 = alloca ptr, align 8
  %__m.addr.i395 = alloca i32, align 4
  %__b.i396 = alloca i32, align 4
  %atomic-temp.i397 = alloca i64, align 8
  %this.addr.i384 = alloca ptr, align 8
  %__m.addr.i385 = alloca i32, align 4
  %__b.i386 = alloca i32, align 4
  %atomic-temp.i387 = alloca i64, align 8
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i64, align 8
  %this.addr = alloca ptr, align 8
  %waitp.addr = alloca ptr, align 8
  %disable_rescheduling = alloca %"struct.absl::base_internal::SchedulingGuard::ScopedDisable", align 1
  %v = alloca i64, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %c = alloca i32, align 4
  %w = alloca ptr, align 8
  %pw = alloca ptr, align 8
  %old_h = alloca ptr, align 8
  %wake_list = alloca ptr, align 8
  %wr_wait = alloca i64, align 8
  %absl_raw_log_internal_basename = alloca ptr, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %clear = alloca i64, align 8
  %nv = alloca i64, align 8
  %do_enqueue = alloca i8, align 1
  %absl_raw_log_internal_basename60 = alloca ptr, align 8
  %new_readers = alloca i64, align 8
  %new_h = alloca ptr, align 8
  %clear82 = alloca i64, align 8
  %h = alloca ptr, align 8
  %nv117 = alloca i64, align 8
  %new_h120 = alloca ptr, align 8
  %absl_raw_log_internal_basename128 = alloca ptr, align 8
  %absl_raw_log_internal_basename152 = alloca ptr, align 8
  %absl_raw_log_internal_basename172 = alloca ptr, align 8
  %nv216 = alloca i64, align 8
  %new_h222 = alloca ptr, align 8
  %w_walk = alloca ptr, align 8
  %pw_walk = alloca ptr, align 8
  %absl_raw_log_internal_basename247 = alloca ptr, align 8
  %absl_raw_log_internal_basename307 = alloca ptr, align 8
  %nv319 = alloca i64, align 8
  %absl_raw_log_internal_basename332 = alloca ptr, align 8
  %total_wait_cycles = alloca i64, align 8
  %max_wait_cycles = alloca i64, align 8
  %now = alloca i64, align 8
  %cycles_waited = alloca i64, align 8
  %ref.tmp = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %waitp, ptr %waitp.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4absl13base_internal15SchedulingGuard13ScopedDisableC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %disable_rescheduling)
  %mu_ = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  store ptr %mu_, ptr %this.addr.i394, align 8
  store i32 0, ptr %__m.addr.i395, align 4
  %this1.i398 = load ptr, ptr %this.addr.i394, align 8
  %0 = load i32, ptr %__m.addr.i395, align 4
  %call.i399 = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %0, i32 noundef 65535)
  store i32 %call.i399, ptr %__b.i396, align 4
  %1 = load i32, ptr %__m.addr.i395, align 4
  switch i32 %1, label %monotonic.i402 [
    i32 1, label %acquire.i401
    i32 2, label %acquire.i401
    i32 5, label %seqcst.i400
  ]

monotonic.i402:                                   ; preds = %entry
  %2 = load atomic i64, ptr %this1.i398 monotonic, align 8
  store i64 %2, ptr %atomic-temp.i397, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit403

acquire.i401:                                     ; preds = %entry, %entry
  %3 = load atomic i64, ptr %this1.i398 acquire, align 8
  store i64 %3, ptr %atomic-temp.i397, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit403

seqcst.i400:                                      ; preds = %entry
  %4 = load atomic i64, ptr %this1.i398 seq_cst, align 8
  store i64 %4, ptr %atomic-temp.i397, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit403

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit403: ; preds = %seqcst.i400, %acquire.i401, %monotonic.i402
  %5 = load i64, ptr %atomic-temp.i397, align 8
  store i64 %5, ptr %v, align 8
  invoke void @_ZNK4absl5Mutex16AssertReaderHeldEv(ptr noundef nonnull align 8 dereferenceable(8) %this1)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit403
  %6 = load i64, ptr %v, align 8
  invoke void @_ZN4abslL23CheckForMutexCorruptionElPKc(i64 noundef %6, ptr noundef @.str.14)
          to label %invoke.cont2 unwind label %lpad

invoke.cont2:                                     ; preds = %invoke.cont
  %7 = load i64, ptr %v, align 8
  %and = and i64 %7, 16
  %cmp = icmp ne i64 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %invoke.cont2
  %8 = load i64, ptr %v, align 8
  %and3 = and i64 %8, 8
  %cmp4 = icmp ne i64 %and3, 0
  %cond = select i1 %cmp4, i32 8, i32 9
  invoke void @_ZN4abslL14PostSynchEventEPvi(ptr noundef %this1, i32 noundef %cond)
          to label %invoke.cont5 unwind label %lpad

invoke.cont5:                                     ; preds = %if.then
  br label %if.end

lpad:                                             ; preds = %invoke.cont379, %if.then378, %if.end371, %if.then357, %if.end353, %do.body331, %if.then323, %do.end316, %do.body306, %if.else291, %lor.lhs.false264, %do.body246, %if.then221, %land.lhs.true183, %do.body171, %do.body151, %do.body127, %if.then119, %if.end106, %land.lhs.true85, %if.then77, %do.body59, %if.then37, %do.body11, %if.then, %invoke.cont, %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit403
  %9 = landingpad { ptr, i32 }
          cleanup
  %10 = extractvalue { ptr, i32 } %9, 0
  store ptr %10, ptr %exn.slot, align 8
  %11 = extractvalue { ptr, i32 } %9, 1
  store i32 %11, ptr %ehselector.slot, align 4
  call void @_ZN4absl13base_internal15SchedulingGuard13ScopedDisableD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %disable_rescheduling) #13
  br label %eh.resume

if.end:                                           ; preds = %invoke.cont5, %invoke.cont2
  store i32 0, ptr %c, align 4
  store ptr null, ptr %w, align 8
  store ptr null, ptr %pw, align 8
  store ptr null, ptr %old_h, align 8
  store ptr inttoptr (i64 1 to ptr), ptr %wake_list, align 8
  store i64 0, ptr %wr_wait, align 8
  br label %do.body

do.body:                                          ; preds = %if.end
  %12 = load ptr, ptr %waitp.addr, align 8
  %cmp6 = icmp eq ptr %12, null
  br i1 %cmp6, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.body
  %13 = load ptr, ptr %waitp.addr, align 8
  %thread = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %13, i32 0, i32 4
  %14 = load ptr, ptr %thread, align 8
  %waitp7 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %14, i32 0, i32 9
  %15 = load ptr, ptr %waitp7, align 8
  %cmp8 = icmp eq ptr %15, null
  br i1 %cmp8, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false
  %16 = load ptr, ptr %waitp.addr, align 8
  %thread9 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %16, i32 0, i32 4
  %17 = load ptr, ptr %thread9, align 8
  %suppress_fatal_errors = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %17, i32 0, i32 6
  %18 = load i8, ptr %suppress_fatal_errors, align 4
  %tobool = trunc i8 %18 to i1
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false, %do.body
  %19 = phi i1 [ true, %lor.lhs.false ], [ true, %do.body ], [ %tobool, %lor.rhs ]
  %lnot = xor i1 %19, true
  br i1 %lnot, label %if.then10, label %if.end16

if.then10:                                        ; preds = %lor.end
  br label %do.body11

do.body11:                                        ; preds = %if.then10
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename, align 8
  invoke void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 2109, ptr noundef @.str.1, ptr noundef @.str.15, ptr noundef @.str.9)
          to label %invoke.cont12 unwind label %lpad

invoke.cont12:                                    ; preds = %do.body11
  br label %do.body13

do.body13:                                        ; preds = %invoke.cont12
  unreachable

do.cond:                                          ; No predecessors!
  br label %do.end

do.end:                                           ; preds = %do.cond
  br label %do.cond14

do.cond14:                                        ; preds = %do.end
  br label %do.end15

do.end15:                                         ; preds = %do.cond14
  br label %if.end16

if.end16:                                         ; preds = %do.end15, %lor.end
  br label %do.cond17

do.cond17:                                        ; preds = %if.end16
  br label %do.end18

do.end18:                                         ; preds = %do.cond17
  br label %for.cond

for.cond:                                         ; preds = %invoke.cont354, %while.end, %do.end18
  %mu_19 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  store ptr %mu_19, ptr %this.addr.i384, align 8
  store i32 0, ptr %__m.addr.i385, align 4
  %this1.i388 = load ptr, ptr %this.addr.i384, align 8
  %20 = load i32, ptr %__m.addr.i385, align 4
  %call.i389 = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %20, i32 noundef 65535)
  store i32 %call.i389, ptr %__b.i386, align 4
  %21 = load i32, ptr %__m.addr.i385, align 4
  switch i32 %21, label %monotonic.i392 [
    i32 1, label %acquire.i391
    i32 2, label %acquire.i391
    i32 5, label %seqcst.i390
  ]

monotonic.i392:                                   ; preds = %for.cond
  %22 = load atomic i64, ptr %this1.i388 monotonic, align 8
  store i64 %22, ptr %atomic-temp.i387, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit393

acquire.i391:                                     ; preds = %for.cond, %for.cond
  %23 = load atomic i64, ptr %this1.i388 acquire, align 8
  store i64 %23, ptr %atomic-temp.i387, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit393

seqcst.i390:                                      ; preds = %for.cond
  %24 = load atomic i64, ptr %this1.i388 seq_cst, align 8
  store i64 %24, ptr %atomic-temp.i387, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit393

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit393: ; preds = %seqcst.i390, %acquire.i391, %monotonic.i392
  %25 = load i64, ptr %atomic-temp.i387, align 8
  store i64 %25, ptr %v, align 8
  %26 = load i64, ptr %v, align 8
  %and21 = and i64 %26, 8
  %cmp22 = icmp ne i64 %and21, 0
  br i1 %cmp22, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit393
  %27 = load i64, ptr %v, align 8
  %and23 = and i64 %27, 6
  %cmp24 = icmp ne i64 %and23, 4
  br i1 %cmp24, label %land.lhs.true25, label %if.else

land.lhs.true25:                                  ; preds = %land.lhs.true
  %28 = load ptr, ptr %waitp.addr, align 8
  %cmp26 = icmp eq ptr %28, null
  br i1 %cmp26, label %if.then27, label %if.else

if.then27:                                        ; preds = %land.lhs.true25
  %mu_28 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %29 = load i64, ptr %v, align 8
  %and29 = and i64 %29, -41
  store ptr %mu_28, ptr %this.addr.i489, align 8
  store ptr %v, ptr %__i1.addr.i490, align 8
  store i64 %and29, ptr %__i2.addr.i491, align 8
  store i32 3, ptr %__m1.addr.i492, align 4
  store i32 0, ptr %__m2.addr.i493, align 4
  %this1.i496 = load ptr, ptr %this.addr.i489, align 8
  %30 = load i32, ptr %__m1.addr.i492, align 4
  %31 = load ptr, ptr %__i1.addr.i490, align 8
  %32 = load i64, ptr %__i2.addr.i491, align 8
  store i64 %32, ptr %.atomictmp.i494, align 8
  %33 = load i32, ptr %__m2.addr.i493, align 4
  switch i32 %30, label %monotonic.i554 [
    i32 1, label %acquire.i540
    i32 2, label %acquire.i540
    i32 3, label %release.i526
    i32 4, label %acqrel.i512
    i32 5, label %seqcst.i497
  ]

monotonic.i554:                                   ; preds = %if.then27
  switch i32 %33, label %monotonic_fail.i564 [
    i32 1, label %acquire_fail.i560
    i32 2, label %acquire_fail.i560
    i32 5, label %seqcst_fail.i555
  ]

acquire.i540:                                     ; preds = %if.then27, %if.then27
  switch i32 %33, label %monotonic_fail9.i550 [
    i32 1, label %acquire_fail10.i546
    i32 2, label %acquire_fail10.i546
    i32 5, label %seqcst_fail11.i541
  ]

release.i526:                                     ; preds = %if.then27
  switch i32 %33, label %monotonic_fail22.i536 [
    i32 1, label %acquire_fail23.i532
    i32 2, label %acquire_fail23.i532
    i32 5, label %seqcst_fail24.i527
  ]

acqrel.i512:                                      ; preds = %if.then27
  switch i32 %33, label %monotonic_fail35.i522 [
    i32 1, label %acquire_fail36.i518
    i32 2, label %acquire_fail36.i518
    i32 5, label %seqcst_fail37.i513
  ]

seqcst.i497:                                      ; preds = %if.then27
  switch i32 %33, label %monotonic_fail48.i508 [
    i32 1, label %acquire_fail49.i504
    i32 2, label %acquire_fail49.i504
    i32 5, label %seqcst_fail50.i498
  ]

monotonic_fail.i564:                              ; preds = %monotonic.i554
  %34 = load i64, ptr %31, align 8
  %35 = load i64, ptr %.atomictmp.i494, align 8
  %36 = cmpxchg ptr %this1.i496, i64 %34, i64 %35 monotonic monotonic, align 8
  %37 = extractvalue { i64, i1 } %36, 0
  %38 = extractvalue { i64, i1 } %36, 1
  br i1 %38, label %cmpxchg.continue.i566, label %cmpxchg.store_expected.i565

acquire_fail.i560:                                ; preds = %monotonic.i554, %monotonic.i554
  %39 = load i64, ptr %31, align 8
  %40 = load i64, ptr %.atomictmp.i494, align 8
  %41 = cmpxchg ptr %this1.i496, i64 %39, i64 %40 monotonic acquire, align 8
  %42 = extractvalue { i64, i1 } %41, 0
  %43 = extractvalue { i64, i1 } %41, 1
  br i1 %43, label %cmpxchg.continue4.i562, label %cmpxchg.store_expected3.i561

seqcst_fail.i555:                                 ; preds = %monotonic.i554
  %44 = load i64, ptr %31, align 8
  %45 = load i64, ptr %.atomictmp.i494, align 8
  %46 = cmpxchg ptr %this1.i496, i64 %44, i64 %45 monotonic seq_cst, align 8
  %47 = extractvalue { i64, i1 } %46, 0
  %48 = extractvalue { i64, i1 } %46, 1
  br i1 %48, label %cmpxchg.continue7.i557, label %cmpxchg.store_expected6.i556

atomic.continue2.i559:                            ; preds = %cmpxchg.continue7.i557, %cmpxchg.continue4.i562, %cmpxchg.continue.i566
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit568

cmpxchg.store_expected.i565:                      ; preds = %monotonic_fail.i564
  store i64 %37, ptr %31, align 8
  br label %cmpxchg.continue.i566

cmpxchg.continue.i566:                            ; preds = %cmpxchg.store_expected.i565, %monotonic_fail.i564
  %frombool.i567 = zext i1 %38 to i8
  store i8 %frombool.i567, ptr %cmpxchg.bool.i495, align 1
  br label %atomic.continue2.i559

cmpxchg.store_expected3.i561:                     ; preds = %acquire_fail.i560
  store i64 %42, ptr %31, align 8
  br label %cmpxchg.continue4.i562

cmpxchg.continue4.i562:                           ; preds = %cmpxchg.store_expected3.i561, %acquire_fail.i560
  %frombool5.i563 = zext i1 %43 to i8
  store i8 %frombool5.i563, ptr %cmpxchg.bool.i495, align 1
  br label %atomic.continue2.i559

cmpxchg.store_expected6.i556:                     ; preds = %seqcst_fail.i555
  store i64 %47, ptr %31, align 8
  br label %cmpxchg.continue7.i557

cmpxchg.continue7.i557:                           ; preds = %cmpxchg.store_expected6.i556, %seqcst_fail.i555
  %frombool8.i558 = zext i1 %48 to i8
  store i8 %frombool8.i558, ptr %cmpxchg.bool.i495, align 1
  br label %atomic.continue2.i559

monotonic_fail9.i550:                             ; preds = %acquire.i540
  %49 = load i64, ptr %31, align 8
  %50 = load i64, ptr %.atomictmp.i494, align 8
  %51 = cmpxchg ptr %this1.i496, i64 %49, i64 %50 acquire monotonic, align 8
  %52 = extractvalue { i64, i1 } %51, 0
  %53 = extractvalue { i64, i1 } %51, 1
  br i1 %53, label %cmpxchg.continue14.i552, label %cmpxchg.store_expected13.i551

acquire_fail10.i546:                              ; preds = %acquire.i540, %acquire.i540
  %54 = load i64, ptr %31, align 8
  %55 = load i64, ptr %.atomictmp.i494, align 8
  %56 = cmpxchg ptr %this1.i496, i64 %54, i64 %55 acquire acquire, align 8
  %57 = extractvalue { i64, i1 } %56, 0
  %58 = extractvalue { i64, i1 } %56, 1
  br i1 %58, label %cmpxchg.continue17.i548, label %cmpxchg.store_expected16.i547

seqcst_fail11.i541:                               ; preds = %acquire.i540
  %59 = load i64, ptr %31, align 8
  %60 = load i64, ptr %.atomictmp.i494, align 8
  %61 = cmpxchg ptr %this1.i496, i64 %59, i64 %60 acquire seq_cst, align 8
  %62 = extractvalue { i64, i1 } %61, 0
  %63 = extractvalue { i64, i1 } %61, 1
  br i1 %63, label %cmpxchg.continue20.i543, label %cmpxchg.store_expected19.i542

atomic.continue12.i545:                           ; preds = %cmpxchg.continue20.i543, %cmpxchg.continue17.i548, %cmpxchg.continue14.i552
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit568

cmpxchg.store_expected13.i551:                    ; preds = %monotonic_fail9.i550
  store i64 %52, ptr %31, align 8
  br label %cmpxchg.continue14.i552

cmpxchg.continue14.i552:                          ; preds = %cmpxchg.store_expected13.i551, %monotonic_fail9.i550
  %frombool15.i553 = zext i1 %53 to i8
  store i8 %frombool15.i553, ptr %cmpxchg.bool.i495, align 1
  br label %atomic.continue12.i545

cmpxchg.store_expected16.i547:                    ; preds = %acquire_fail10.i546
  store i64 %57, ptr %31, align 8
  br label %cmpxchg.continue17.i548

cmpxchg.continue17.i548:                          ; preds = %cmpxchg.store_expected16.i547, %acquire_fail10.i546
  %frombool18.i549 = zext i1 %58 to i8
  store i8 %frombool18.i549, ptr %cmpxchg.bool.i495, align 1
  br label %atomic.continue12.i545

cmpxchg.store_expected19.i542:                    ; preds = %seqcst_fail11.i541
  store i64 %62, ptr %31, align 8
  br label %cmpxchg.continue20.i543

cmpxchg.continue20.i543:                          ; preds = %cmpxchg.store_expected19.i542, %seqcst_fail11.i541
  %frombool21.i544 = zext i1 %63 to i8
  store i8 %frombool21.i544, ptr %cmpxchg.bool.i495, align 1
  br label %atomic.continue12.i545

monotonic_fail22.i536:                            ; preds = %release.i526
  %64 = load i64, ptr %31, align 8
  %65 = load i64, ptr %.atomictmp.i494, align 8
  %66 = cmpxchg ptr %this1.i496, i64 %64, i64 %65 release monotonic, align 8
  %67 = extractvalue { i64, i1 } %66, 0
  %68 = extractvalue { i64, i1 } %66, 1
  br i1 %68, label %cmpxchg.continue27.i538, label %cmpxchg.store_expected26.i537

acquire_fail23.i532:                              ; preds = %release.i526, %release.i526
  %69 = load i64, ptr %31, align 8
  %70 = load i64, ptr %.atomictmp.i494, align 8
  %71 = cmpxchg ptr %this1.i496, i64 %69, i64 %70 release acquire, align 8
  %72 = extractvalue { i64, i1 } %71, 0
  %73 = extractvalue { i64, i1 } %71, 1
  br i1 %73, label %cmpxchg.continue30.i534, label %cmpxchg.store_expected29.i533

seqcst_fail24.i527:                               ; preds = %release.i526
  %74 = load i64, ptr %31, align 8
  %75 = load i64, ptr %.atomictmp.i494, align 8
  %76 = cmpxchg ptr %this1.i496, i64 %74, i64 %75 release seq_cst, align 8
  %77 = extractvalue { i64, i1 } %76, 0
  %78 = extractvalue { i64, i1 } %76, 1
  br i1 %78, label %cmpxchg.continue33.i529, label %cmpxchg.store_expected32.i528

atomic.continue25.i531:                           ; preds = %cmpxchg.continue33.i529, %cmpxchg.continue30.i534, %cmpxchg.continue27.i538
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit568

cmpxchg.store_expected26.i537:                    ; preds = %monotonic_fail22.i536
  store i64 %67, ptr %31, align 8
  br label %cmpxchg.continue27.i538

cmpxchg.continue27.i538:                          ; preds = %cmpxchg.store_expected26.i537, %monotonic_fail22.i536
  %frombool28.i539 = zext i1 %68 to i8
  store i8 %frombool28.i539, ptr %cmpxchg.bool.i495, align 1
  br label %atomic.continue25.i531

cmpxchg.store_expected29.i533:                    ; preds = %acquire_fail23.i532
  store i64 %72, ptr %31, align 8
  br label %cmpxchg.continue30.i534

cmpxchg.continue30.i534:                          ; preds = %cmpxchg.store_expected29.i533, %acquire_fail23.i532
  %frombool31.i535 = zext i1 %73 to i8
  store i8 %frombool31.i535, ptr %cmpxchg.bool.i495, align 1
  br label %atomic.continue25.i531

cmpxchg.store_expected32.i528:                    ; preds = %seqcst_fail24.i527
  store i64 %77, ptr %31, align 8
  br label %cmpxchg.continue33.i529

cmpxchg.continue33.i529:                          ; preds = %cmpxchg.store_expected32.i528, %seqcst_fail24.i527
  %frombool34.i530 = zext i1 %78 to i8
  store i8 %frombool34.i530, ptr %cmpxchg.bool.i495, align 1
  br label %atomic.continue25.i531

monotonic_fail35.i522:                            ; preds = %acqrel.i512
  %79 = load i64, ptr %31, align 8
  %80 = load i64, ptr %.atomictmp.i494, align 8
  %81 = cmpxchg ptr %this1.i496, i64 %79, i64 %80 acq_rel monotonic, align 8
  %82 = extractvalue { i64, i1 } %81, 0
  %83 = extractvalue { i64, i1 } %81, 1
  br i1 %83, label %cmpxchg.continue40.i524, label %cmpxchg.store_expected39.i523

acquire_fail36.i518:                              ; preds = %acqrel.i512, %acqrel.i512
  %84 = load i64, ptr %31, align 8
  %85 = load i64, ptr %.atomictmp.i494, align 8
  %86 = cmpxchg ptr %this1.i496, i64 %84, i64 %85 acq_rel acquire, align 8
  %87 = extractvalue { i64, i1 } %86, 0
  %88 = extractvalue { i64, i1 } %86, 1
  br i1 %88, label %cmpxchg.continue43.i520, label %cmpxchg.store_expected42.i519

seqcst_fail37.i513:                               ; preds = %acqrel.i512
  %89 = load i64, ptr %31, align 8
  %90 = load i64, ptr %.atomictmp.i494, align 8
  %91 = cmpxchg ptr %this1.i496, i64 %89, i64 %90 acq_rel seq_cst, align 8
  %92 = extractvalue { i64, i1 } %91, 0
  %93 = extractvalue { i64, i1 } %91, 1
  br i1 %93, label %cmpxchg.continue46.i515, label %cmpxchg.store_expected45.i514

atomic.continue38.i517:                           ; preds = %cmpxchg.continue46.i515, %cmpxchg.continue43.i520, %cmpxchg.continue40.i524
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit568

cmpxchg.store_expected39.i523:                    ; preds = %monotonic_fail35.i522
  store i64 %82, ptr %31, align 8
  br label %cmpxchg.continue40.i524

cmpxchg.continue40.i524:                          ; preds = %cmpxchg.store_expected39.i523, %monotonic_fail35.i522
  %frombool41.i525 = zext i1 %83 to i8
  store i8 %frombool41.i525, ptr %cmpxchg.bool.i495, align 1
  br label %atomic.continue38.i517

cmpxchg.store_expected42.i519:                    ; preds = %acquire_fail36.i518
  store i64 %87, ptr %31, align 8
  br label %cmpxchg.continue43.i520

cmpxchg.continue43.i520:                          ; preds = %cmpxchg.store_expected42.i519, %acquire_fail36.i518
  %frombool44.i521 = zext i1 %88 to i8
  store i8 %frombool44.i521, ptr %cmpxchg.bool.i495, align 1
  br label %atomic.continue38.i517

cmpxchg.store_expected45.i514:                    ; preds = %seqcst_fail37.i513
  store i64 %92, ptr %31, align 8
  br label %cmpxchg.continue46.i515

cmpxchg.continue46.i515:                          ; preds = %cmpxchg.store_expected45.i514, %seqcst_fail37.i513
  %frombool47.i516 = zext i1 %93 to i8
  store i8 %frombool47.i516, ptr %cmpxchg.bool.i495, align 1
  br label %atomic.continue38.i517

monotonic_fail48.i508:                            ; preds = %seqcst.i497
  %94 = load i64, ptr %31, align 8
  %95 = load i64, ptr %.atomictmp.i494, align 8
  %96 = cmpxchg ptr %this1.i496, i64 %94, i64 %95 seq_cst monotonic, align 8
  %97 = extractvalue { i64, i1 } %96, 0
  %98 = extractvalue { i64, i1 } %96, 1
  br i1 %98, label %cmpxchg.continue53.i510, label %cmpxchg.store_expected52.i509

acquire_fail49.i504:                              ; preds = %seqcst.i497, %seqcst.i497
  %99 = load i64, ptr %31, align 8
  %100 = load i64, ptr %.atomictmp.i494, align 8
  %101 = cmpxchg ptr %this1.i496, i64 %99, i64 %100 seq_cst acquire, align 8
  %102 = extractvalue { i64, i1 } %101, 0
  %103 = extractvalue { i64, i1 } %101, 1
  br i1 %103, label %cmpxchg.continue56.i506, label %cmpxchg.store_expected55.i505

seqcst_fail50.i498:                               ; preds = %seqcst.i497
  %104 = load i64, ptr %31, align 8
  %105 = load i64, ptr %.atomictmp.i494, align 8
  %106 = cmpxchg ptr %this1.i496, i64 %104, i64 %105 seq_cst seq_cst, align 8
  %107 = extractvalue { i64, i1 } %106, 0
  %108 = extractvalue { i64, i1 } %106, 1
  br i1 %108, label %cmpxchg.continue59.i500, label %cmpxchg.store_expected58.i499

atomic.continue51.i502:                           ; preds = %cmpxchg.continue59.i500, %cmpxchg.continue56.i506, %cmpxchg.continue53.i510
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit568

cmpxchg.store_expected52.i509:                    ; preds = %monotonic_fail48.i508
  store i64 %97, ptr %31, align 8
  br label %cmpxchg.continue53.i510

cmpxchg.continue53.i510:                          ; preds = %cmpxchg.store_expected52.i509, %monotonic_fail48.i508
  %frombool54.i511 = zext i1 %98 to i8
  store i8 %frombool54.i511, ptr %cmpxchg.bool.i495, align 1
  br label %atomic.continue51.i502

cmpxchg.store_expected55.i505:                    ; preds = %acquire_fail49.i504
  store i64 %102, ptr %31, align 8
  br label %cmpxchg.continue56.i506

cmpxchg.continue56.i506:                          ; preds = %cmpxchg.store_expected55.i505, %acquire_fail49.i504
  %frombool57.i507 = zext i1 %103 to i8
  store i8 %frombool57.i507, ptr %cmpxchg.bool.i495, align 1
  br label %atomic.continue51.i502

cmpxchg.store_expected58.i499:                    ; preds = %seqcst_fail50.i498
  store i64 %107, ptr %31, align 8
  br label %cmpxchg.continue59.i500

cmpxchg.continue59.i500:                          ; preds = %cmpxchg.store_expected58.i499, %seqcst_fail50.i498
  %frombool60.i501 = zext i1 %108 to i8
  store i8 %frombool60.i501, ptr %cmpxchg.bool.i495, align 1
  br label %atomic.continue51.i502

_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit568: ; preds = %atomic.continue51.i502, %atomic.continue38.i517, %atomic.continue25.i531, %atomic.continue12.i545, %atomic.continue2.i559
  %109 = load i8, ptr %cmpxchg.bool.i495, align 1
  %tobool.i503 = trunc i8 %109 to i1
  br i1 %tobool.i503, label %if.then31, label %if.end32

if.then31:                                        ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit568
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end32:                                         ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit568
  br label %if.end353

if.else:                                          ; preds = %land.lhs.true25, %land.lhs.true, %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit393
  %110 = load i64, ptr %v, align 8
  %and33 = and i64 %110, 5
  %cmp34 = icmp eq i64 %and33, 1
  br i1 %cmp34, label %land.lhs.true35, label %if.else45

land.lhs.true35:                                  ; preds = %if.else
  %111 = load ptr, ptr %waitp.addr, align 8
  %cmp36 = icmp eq ptr %111, null
  br i1 %cmp36, label %if.then37, label %if.else45

if.then37:                                        ; preds = %land.lhs.true35
  %112 = load i64, ptr %v, align 8
  %call39 = invoke noundef zeroext i1 @_ZN4abslL16ExactlyOneReaderEl(i64 noundef %112)
          to label %invoke.cont38 unwind label %lpad

invoke.cont38:                                    ; preds = %if.then37
  %cond40 = select i1 %call39, i64 257, i64 256
  store i64 %cond40, ptr %clear, align 8
  %mu_41 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %113 = load i64, ptr %v, align 8
  %114 = load i64, ptr %clear, align 8
  %sub = sub nsw i64 %113, %114
  store ptr %mu_41, ptr %this.addr.i409, align 8
  store ptr %v, ptr %__i1.addr.i410, align 8
  store i64 %sub, ptr %__i2.addr.i411, align 8
  store i32 3, ptr %__m1.addr.i412, align 4
  store i32 0, ptr %__m2.addr.i413, align 4
  %this1.i416 = load ptr, ptr %this.addr.i409, align 8
  %115 = load i32, ptr %__m1.addr.i412, align 4
  %116 = load ptr, ptr %__i1.addr.i410, align 8
  %117 = load i64, ptr %__i2.addr.i411, align 8
  store i64 %117, ptr %.atomictmp.i414, align 8
  %118 = load i32, ptr %__m2.addr.i413, align 4
  switch i32 %115, label %monotonic.i474 [
    i32 1, label %acquire.i460
    i32 2, label %acquire.i460
    i32 3, label %release.i446
    i32 4, label %acqrel.i432
    i32 5, label %seqcst.i417
  ]

monotonic.i474:                                   ; preds = %invoke.cont38
  switch i32 %118, label %monotonic_fail.i484 [
    i32 1, label %acquire_fail.i480
    i32 2, label %acquire_fail.i480
    i32 5, label %seqcst_fail.i475
  ]

acquire.i460:                                     ; preds = %invoke.cont38, %invoke.cont38
  switch i32 %118, label %monotonic_fail9.i470 [
    i32 1, label %acquire_fail10.i466
    i32 2, label %acquire_fail10.i466
    i32 5, label %seqcst_fail11.i461
  ]

release.i446:                                     ; preds = %invoke.cont38
  switch i32 %118, label %monotonic_fail22.i456 [
    i32 1, label %acquire_fail23.i452
    i32 2, label %acquire_fail23.i452
    i32 5, label %seqcst_fail24.i447
  ]

acqrel.i432:                                      ; preds = %invoke.cont38
  switch i32 %118, label %monotonic_fail35.i442 [
    i32 1, label %acquire_fail36.i438
    i32 2, label %acquire_fail36.i438
    i32 5, label %seqcst_fail37.i433
  ]

seqcst.i417:                                      ; preds = %invoke.cont38
  switch i32 %118, label %monotonic_fail48.i428 [
    i32 1, label %acquire_fail49.i424
    i32 2, label %acquire_fail49.i424
    i32 5, label %seqcst_fail50.i418
  ]

monotonic_fail.i484:                              ; preds = %monotonic.i474
  %119 = load i64, ptr %116, align 8
  %120 = load i64, ptr %.atomictmp.i414, align 8
  %121 = cmpxchg ptr %this1.i416, i64 %119, i64 %120 monotonic monotonic, align 8
  %122 = extractvalue { i64, i1 } %121, 0
  %123 = extractvalue { i64, i1 } %121, 1
  br i1 %123, label %cmpxchg.continue.i486, label %cmpxchg.store_expected.i485

acquire_fail.i480:                                ; preds = %monotonic.i474, %monotonic.i474
  %124 = load i64, ptr %116, align 8
  %125 = load i64, ptr %.atomictmp.i414, align 8
  %126 = cmpxchg ptr %this1.i416, i64 %124, i64 %125 monotonic acquire, align 8
  %127 = extractvalue { i64, i1 } %126, 0
  %128 = extractvalue { i64, i1 } %126, 1
  br i1 %128, label %cmpxchg.continue4.i482, label %cmpxchg.store_expected3.i481

seqcst_fail.i475:                                 ; preds = %monotonic.i474
  %129 = load i64, ptr %116, align 8
  %130 = load i64, ptr %.atomictmp.i414, align 8
  %131 = cmpxchg ptr %this1.i416, i64 %129, i64 %130 monotonic seq_cst, align 8
  %132 = extractvalue { i64, i1 } %131, 0
  %133 = extractvalue { i64, i1 } %131, 1
  br i1 %133, label %cmpxchg.continue7.i477, label %cmpxchg.store_expected6.i476

atomic.continue2.i479:                            ; preds = %cmpxchg.continue7.i477, %cmpxchg.continue4.i482, %cmpxchg.continue.i486
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit488

cmpxchg.store_expected.i485:                      ; preds = %monotonic_fail.i484
  store i64 %122, ptr %116, align 8
  br label %cmpxchg.continue.i486

cmpxchg.continue.i486:                            ; preds = %cmpxchg.store_expected.i485, %monotonic_fail.i484
  %frombool.i487 = zext i1 %123 to i8
  store i8 %frombool.i487, ptr %cmpxchg.bool.i415, align 1
  br label %atomic.continue2.i479

cmpxchg.store_expected3.i481:                     ; preds = %acquire_fail.i480
  store i64 %127, ptr %116, align 8
  br label %cmpxchg.continue4.i482

cmpxchg.continue4.i482:                           ; preds = %cmpxchg.store_expected3.i481, %acquire_fail.i480
  %frombool5.i483 = zext i1 %128 to i8
  store i8 %frombool5.i483, ptr %cmpxchg.bool.i415, align 1
  br label %atomic.continue2.i479

cmpxchg.store_expected6.i476:                     ; preds = %seqcst_fail.i475
  store i64 %132, ptr %116, align 8
  br label %cmpxchg.continue7.i477

cmpxchg.continue7.i477:                           ; preds = %cmpxchg.store_expected6.i476, %seqcst_fail.i475
  %frombool8.i478 = zext i1 %133 to i8
  store i8 %frombool8.i478, ptr %cmpxchg.bool.i415, align 1
  br label %atomic.continue2.i479

monotonic_fail9.i470:                             ; preds = %acquire.i460
  %134 = load i64, ptr %116, align 8
  %135 = load i64, ptr %.atomictmp.i414, align 8
  %136 = cmpxchg ptr %this1.i416, i64 %134, i64 %135 acquire monotonic, align 8
  %137 = extractvalue { i64, i1 } %136, 0
  %138 = extractvalue { i64, i1 } %136, 1
  br i1 %138, label %cmpxchg.continue14.i472, label %cmpxchg.store_expected13.i471

acquire_fail10.i466:                              ; preds = %acquire.i460, %acquire.i460
  %139 = load i64, ptr %116, align 8
  %140 = load i64, ptr %.atomictmp.i414, align 8
  %141 = cmpxchg ptr %this1.i416, i64 %139, i64 %140 acquire acquire, align 8
  %142 = extractvalue { i64, i1 } %141, 0
  %143 = extractvalue { i64, i1 } %141, 1
  br i1 %143, label %cmpxchg.continue17.i468, label %cmpxchg.store_expected16.i467

seqcst_fail11.i461:                               ; preds = %acquire.i460
  %144 = load i64, ptr %116, align 8
  %145 = load i64, ptr %.atomictmp.i414, align 8
  %146 = cmpxchg ptr %this1.i416, i64 %144, i64 %145 acquire seq_cst, align 8
  %147 = extractvalue { i64, i1 } %146, 0
  %148 = extractvalue { i64, i1 } %146, 1
  br i1 %148, label %cmpxchg.continue20.i463, label %cmpxchg.store_expected19.i462

atomic.continue12.i465:                           ; preds = %cmpxchg.continue20.i463, %cmpxchg.continue17.i468, %cmpxchg.continue14.i472
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit488

cmpxchg.store_expected13.i471:                    ; preds = %monotonic_fail9.i470
  store i64 %137, ptr %116, align 8
  br label %cmpxchg.continue14.i472

cmpxchg.continue14.i472:                          ; preds = %cmpxchg.store_expected13.i471, %monotonic_fail9.i470
  %frombool15.i473 = zext i1 %138 to i8
  store i8 %frombool15.i473, ptr %cmpxchg.bool.i415, align 1
  br label %atomic.continue12.i465

cmpxchg.store_expected16.i467:                    ; preds = %acquire_fail10.i466
  store i64 %142, ptr %116, align 8
  br label %cmpxchg.continue17.i468

cmpxchg.continue17.i468:                          ; preds = %cmpxchg.store_expected16.i467, %acquire_fail10.i466
  %frombool18.i469 = zext i1 %143 to i8
  store i8 %frombool18.i469, ptr %cmpxchg.bool.i415, align 1
  br label %atomic.continue12.i465

cmpxchg.store_expected19.i462:                    ; preds = %seqcst_fail11.i461
  store i64 %147, ptr %116, align 8
  br label %cmpxchg.continue20.i463

cmpxchg.continue20.i463:                          ; preds = %cmpxchg.store_expected19.i462, %seqcst_fail11.i461
  %frombool21.i464 = zext i1 %148 to i8
  store i8 %frombool21.i464, ptr %cmpxchg.bool.i415, align 1
  br label %atomic.continue12.i465

monotonic_fail22.i456:                            ; preds = %release.i446
  %149 = load i64, ptr %116, align 8
  %150 = load i64, ptr %.atomictmp.i414, align 8
  %151 = cmpxchg ptr %this1.i416, i64 %149, i64 %150 release monotonic, align 8
  %152 = extractvalue { i64, i1 } %151, 0
  %153 = extractvalue { i64, i1 } %151, 1
  br i1 %153, label %cmpxchg.continue27.i458, label %cmpxchg.store_expected26.i457

acquire_fail23.i452:                              ; preds = %release.i446, %release.i446
  %154 = load i64, ptr %116, align 8
  %155 = load i64, ptr %.atomictmp.i414, align 8
  %156 = cmpxchg ptr %this1.i416, i64 %154, i64 %155 release acquire, align 8
  %157 = extractvalue { i64, i1 } %156, 0
  %158 = extractvalue { i64, i1 } %156, 1
  br i1 %158, label %cmpxchg.continue30.i454, label %cmpxchg.store_expected29.i453

seqcst_fail24.i447:                               ; preds = %release.i446
  %159 = load i64, ptr %116, align 8
  %160 = load i64, ptr %.atomictmp.i414, align 8
  %161 = cmpxchg ptr %this1.i416, i64 %159, i64 %160 release seq_cst, align 8
  %162 = extractvalue { i64, i1 } %161, 0
  %163 = extractvalue { i64, i1 } %161, 1
  br i1 %163, label %cmpxchg.continue33.i449, label %cmpxchg.store_expected32.i448

atomic.continue25.i451:                           ; preds = %cmpxchg.continue33.i449, %cmpxchg.continue30.i454, %cmpxchg.continue27.i458
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit488

cmpxchg.store_expected26.i457:                    ; preds = %monotonic_fail22.i456
  store i64 %152, ptr %116, align 8
  br label %cmpxchg.continue27.i458

cmpxchg.continue27.i458:                          ; preds = %cmpxchg.store_expected26.i457, %monotonic_fail22.i456
  %frombool28.i459 = zext i1 %153 to i8
  store i8 %frombool28.i459, ptr %cmpxchg.bool.i415, align 1
  br label %atomic.continue25.i451

cmpxchg.store_expected29.i453:                    ; preds = %acquire_fail23.i452
  store i64 %157, ptr %116, align 8
  br label %cmpxchg.continue30.i454

cmpxchg.continue30.i454:                          ; preds = %cmpxchg.store_expected29.i453, %acquire_fail23.i452
  %frombool31.i455 = zext i1 %158 to i8
  store i8 %frombool31.i455, ptr %cmpxchg.bool.i415, align 1
  br label %atomic.continue25.i451

cmpxchg.store_expected32.i448:                    ; preds = %seqcst_fail24.i447
  store i64 %162, ptr %116, align 8
  br label %cmpxchg.continue33.i449

cmpxchg.continue33.i449:                          ; preds = %cmpxchg.store_expected32.i448, %seqcst_fail24.i447
  %frombool34.i450 = zext i1 %163 to i8
  store i8 %frombool34.i450, ptr %cmpxchg.bool.i415, align 1
  br label %atomic.continue25.i451

monotonic_fail35.i442:                            ; preds = %acqrel.i432
  %164 = load i64, ptr %116, align 8
  %165 = load i64, ptr %.atomictmp.i414, align 8
  %166 = cmpxchg ptr %this1.i416, i64 %164, i64 %165 acq_rel monotonic, align 8
  %167 = extractvalue { i64, i1 } %166, 0
  %168 = extractvalue { i64, i1 } %166, 1
  br i1 %168, label %cmpxchg.continue40.i444, label %cmpxchg.store_expected39.i443

acquire_fail36.i438:                              ; preds = %acqrel.i432, %acqrel.i432
  %169 = load i64, ptr %116, align 8
  %170 = load i64, ptr %.atomictmp.i414, align 8
  %171 = cmpxchg ptr %this1.i416, i64 %169, i64 %170 acq_rel acquire, align 8
  %172 = extractvalue { i64, i1 } %171, 0
  %173 = extractvalue { i64, i1 } %171, 1
  br i1 %173, label %cmpxchg.continue43.i440, label %cmpxchg.store_expected42.i439

seqcst_fail37.i433:                               ; preds = %acqrel.i432
  %174 = load i64, ptr %116, align 8
  %175 = load i64, ptr %.atomictmp.i414, align 8
  %176 = cmpxchg ptr %this1.i416, i64 %174, i64 %175 acq_rel seq_cst, align 8
  %177 = extractvalue { i64, i1 } %176, 0
  %178 = extractvalue { i64, i1 } %176, 1
  br i1 %178, label %cmpxchg.continue46.i435, label %cmpxchg.store_expected45.i434

atomic.continue38.i437:                           ; preds = %cmpxchg.continue46.i435, %cmpxchg.continue43.i440, %cmpxchg.continue40.i444
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit488

cmpxchg.store_expected39.i443:                    ; preds = %monotonic_fail35.i442
  store i64 %167, ptr %116, align 8
  br label %cmpxchg.continue40.i444

cmpxchg.continue40.i444:                          ; preds = %cmpxchg.store_expected39.i443, %monotonic_fail35.i442
  %frombool41.i445 = zext i1 %168 to i8
  store i8 %frombool41.i445, ptr %cmpxchg.bool.i415, align 1
  br label %atomic.continue38.i437

cmpxchg.store_expected42.i439:                    ; preds = %acquire_fail36.i438
  store i64 %172, ptr %116, align 8
  br label %cmpxchg.continue43.i440

cmpxchg.continue43.i440:                          ; preds = %cmpxchg.store_expected42.i439, %acquire_fail36.i438
  %frombool44.i441 = zext i1 %173 to i8
  store i8 %frombool44.i441, ptr %cmpxchg.bool.i415, align 1
  br label %atomic.continue38.i437

cmpxchg.store_expected45.i434:                    ; preds = %seqcst_fail37.i433
  store i64 %177, ptr %116, align 8
  br label %cmpxchg.continue46.i435

cmpxchg.continue46.i435:                          ; preds = %cmpxchg.store_expected45.i434, %seqcst_fail37.i433
  %frombool47.i436 = zext i1 %178 to i8
  store i8 %frombool47.i436, ptr %cmpxchg.bool.i415, align 1
  br label %atomic.continue38.i437

monotonic_fail48.i428:                            ; preds = %seqcst.i417
  %179 = load i64, ptr %116, align 8
  %180 = load i64, ptr %.atomictmp.i414, align 8
  %181 = cmpxchg ptr %this1.i416, i64 %179, i64 %180 seq_cst monotonic, align 8
  %182 = extractvalue { i64, i1 } %181, 0
  %183 = extractvalue { i64, i1 } %181, 1
  br i1 %183, label %cmpxchg.continue53.i430, label %cmpxchg.store_expected52.i429

acquire_fail49.i424:                              ; preds = %seqcst.i417, %seqcst.i417
  %184 = load i64, ptr %116, align 8
  %185 = load i64, ptr %.atomictmp.i414, align 8
  %186 = cmpxchg ptr %this1.i416, i64 %184, i64 %185 seq_cst acquire, align 8
  %187 = extractvalue { i64, i1 } %186, 0
  %188 = extractvalue { i64, i1 } %186, 1
  br i1 %188, label %cmpxchg.continue56.i426, label %cmpxchg.store_expected55.i425

seqcst_fail50.i418:                               ; preds = %seqcst.i417
  %189 = load i64, ptr %116, align 8
  %190 = load i64, ptr %.atomictmp.i414, align 8
  %191 = cmpxchg ptr %this1.i416, i64 %189, i64 %190 seq_cst seq_cst, align 8
  %192 = extractvalue { i64, i1 } %191, 0
  %193 = extractvalue { i64, i1 } %191, 1
  br i1 %193, label %cmpxchg.continue59.i420, label %cmpxchg.store_expected58.i419

atomic.continue51.i422:                           ; preds = %cmpxchg.continue59.i420, %cmpxchg.continue56.i426, %cmpxchg.continue53.i430
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit488

cmpxchg.store_expected52.i429:                    ; preds = %monotonic_fail48.i428
  store i64 %182, ptr %116, align 8
  br label %cmpxchg.continue53.i430

cmpxchg.continue53.i430:                          ; preds = %cmpxchg.store_expected52.i429, %monotonic_fail48.i428
  %frombool54.i431 = zext i1 %183 to i8
  store i8 %frombool54.i431, ptr %cmpxchg.bool.i415, align 1
  br label %atomic.continue51.i422

cmpxchg.store_expected55.i425:                    ; preds = %acquire_fail49.i424
  store i64 %187, ptr %116, align 8
  br label %cmpxchg.continue56.i426

cmpxchg.continue56.i426:                          ; preds = %cmpxchg.store_expected55.i425, %acquire_fail49.i424
  %frombool57.i427 = zext i1 %188 to i8
  store i8 %frombool57.i427, ptr %cmpxchg.bool.i415, align 1
  br label %atomic.continue51.i422

cmpxchg.store_expected58.i419:                    ; preds = %seqcst_fail50.i418
  store i64 %192, ptr %116, align 8
  br label %cmpxchg.continue59.i420

cmpxchg.continue59.i420:                          ; preds = %cmpxchg.store_expected58.i419, %seqcst_fail50.i418
  %frombool60.i421 = zext i1 %193 to i8
  store i8 %frombool60.i421, ptr %cmpxchg.bool.i415, align 1
  br label %atomic.continue51.i422

_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit488: ; preds = %atomic.continue51.i422, %atomic.continue38.i437, %atomic.continue25.i451, %atomic.continue12.i465, %atomic.continue2.i479
  %194 = load i8, ptr %cmpxchg.bool.i415, align 1
  %tobool.i423 = trunc i8 %194 to i1
  br i1 %tobool.i423, label %if.then43, label %if.end44

if.then43:                                        ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit488
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end44:                                         ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit488
  br label %if.end352

if.else45:                                        ; preds = %land.lhs.true35, %if.else
  %195 = load i64, ptr %v, align 8
  %and46 = and i64 %195, 64
  %cmp47 = icmp eq i64 %and46, 0
  br i1 %cmp47, label %land.lhs.true48, label %if.end351

land.lhs.true48:                                  ; preds = %if.else45
  %mu_49 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %196 = load i64, ptr %v, align 8
  %or = or i64 %196, 64
  store ptr %mu_49, ptr %this.addr.i404, align 8
  store ptr %v, ptr %__i1.addr.i, align 8
  store i64 %or, ptr %__i2.addr.i, align 8
  store i32 2, ptr %__m1.addr.i, align 4
  store i32 0, ptr %__m2.addr.i, align 4
  %this1.i405 = load ptr, ptr %this.addr.i404, align 8
  %197 = load i32, ptr %__m1.addr.i, align 4
  %198 = load ptr, ptr %__i1.addr.i, align 8
  %199 = load i64, ptr %__i2.addr.i, align 8
  store i64 %199, ptr %.atomictmp.i, align 8
  %200 = load i32, ptr %__m2.addr.i, align 4
  switch i32 %197, label %monotonic.i408 [
    i32 1, label %acquire.i407
    i32 2, label %acquire.i407
    i32 3, label %release.i
    i32 4, label %acqrel.i
    i32 5, label %seqcst.i406
  ]

monotonic.i408:                                   ; preds = %land.lhs.true48
  switch i32 %200, label %monotonic_fail.i [
    i32 1, label %acquire_fail.i
    i32 2, label %acquire_fail.i
    i32 5, label %seqcst_fail.i
  ]

acquire.i407:                                     ; preds = %land.lhs.true48, %land.lhs.true48
  switch i32 %200, label %monotonic_fail9.i [
    i32 1, label %acquire_fail10.i
    i32 2, label %acquire_fail10.i
    i32 5, label %seqcst_fail11.i
  ]

release.i:                                        ; preds = %land.lhs.true48
  switch i32 %200, label %monotonic_fail22.i [
    i32 1, label %acquire_fail23.i
    i32 2, label %acquire_fail23.i
    i32 5, label %seqcst_fail24.i
  ]

acqrel.i:                                         ; preds = %land.lhs.true48
  switch i32 %200, label %monotonic_fail35.i [
    i32 1, label %acquire_fail36.i
    i32 2, label %acquire_fail36.i
    i32 5, label %seqcst_fail37.i
  ]

seqcst.i406:                                      ; preds = %land.lhs.true48
  switch i32 %200, label %monotonic_fail48.i [
    i32 1, label %acquire_fail49.i
    i32 2, label %acquire_fail49.i
    i32 5, label %seqcst_fail50.i
  ]

monotonic_fail.i:                                 ; preds = %monotonic.i408
  %201 = load i64, ptr %198, align 8
  %202 = load i64, ptr %.atomictmp.i, align 8
  %203 = cmpxchg ptr %this1.i405, i64 %201, i64 %202 monotonic monotonic, align 8
  %204 = extractvalue { i64, i1 } %203, 0
  %205 = extractvalue { i64, i1 } %203, 1
  br i1 %205, label %cmpxchg.continue.i, label %cmpxchg.store_expected.i

acquire_fail.i:                                   ; preds = %monotonic.i408, %monotonic.i408
  %206 = load i64, ptr %198, align 8
  %207 = load i64, ptr %.atomictmp.i, align 8
  %208 = cmpxchg ptr %this1.i405, i64 %206, i64 %207 monotonic acquire, align 8
  %209 = extractvalue { i64, i1 } %208, 0
  %210 = extractvalue { i64, i1 } %208, 1
  br i1 %210, label %cmpxchg.continue4.i, label %cmpxchg.store_expected3.i

seqcst_fail.i:                                    ; preds = %monotonic.i408
  %211 = load i64, ptr %198, align 8
  %212 = load i64, ptr %.atomictmp.i, align 8
  %213 = cmpxchg ptr %this1.i405, i64 %211, i64 %212 monotonic seq_cst, align 8
  %214 = extractvalue { i64, i1 } %213, 0
  %215 = extractvalue { i64, i1 } %213, 1
  br i1 %215, label %cmpxchg.continue7.i, label %cmpxchg.store_expected6.i

atomic.continue2.i:                               ; preds = %cmpxchg.continue7.i, %cmpxchg.continue4.i, %cmpxchg.continue.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected.i:                         ; preds = %monotonic_fail.i
  store i64 %204, ptr %198, align 8
  br label %cmpxchg.continue.i

cmpxchg.continue.i:                               ; preds = %cmpxchg.store_expected.i, %monotonic_fail.i
  %frombool.i = zext i1 %205 to i8
  store i8 %frombool.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected3.i:                        ; preds = %acquire_fail.i
  store i64 %209, ptr %198, align 8
  br label %cmpxchg.continue4.i

cmpxchg.continue4.i:                              ; preds = %cmpxchg.store_expected3.i, %acquire_fail.i
  %frombool5.i = zext i1 %210 to i8
  store i8 %frombool5.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected6.i:                        ; preds = %seqcst_fail.i
  store i64 %214, ptr %198, align 8
  br label %cmpxchg.continue7.i

cmpxchg.continue7.i:                              ; preds = %cmpxchg.store_expected6.i, %seqcst_fail.i
  %frombool8.i = zext i1 %215 to i8
  store i8 %frombool8.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

monotonic_fail9.i:                                ; preds = %acquire.i407
  %216 = load i64, ptr %198, align 8
  %217 = load i64, ptr %.atomictmp.i, align 8
  %218 = cmpxchg ptr %this1.i405, i64 %216, i64 %217 acquire monotonic, align 8
  %219 = extractvalue { i64, i1 } %218, 0
  %220 = extractvalue { i64, i1 } %218, 1
  br i1 %220, label %cmpxchg.continue14.i, label %cmpxchg.store_expected13.i

acquire_fail10.i:                                 ; preds = %acquire.i407, %acquire.i407
  %221 = load i64, ptr %198, align 8
  %222 = load i64, ptr %.atomictmp.i, align 8
  %223 = cmpxchg ptr %this1.i405, i64 %221, i64 %222 acquire acquire, align 8
  %224 = extractvalue { i64, i1 } %223, 0
  %225 = extractvalue { i64, i1 } %223, 1
  br i1 %225, label %cmpxchg.continue17.i, label %cmpxchg.store_expected16.i

seqcst_fail11.i:                                  ; preds = %acquire.i407
  %226 = load i64, ptr %198, align 8
  %227 = load i64, ptr %.atomictmp.i, align 8
  %228 = cmpxchg ptr %this1.i405, i64 %226, i64 %227 acquire seq_cst, align 8
  %229 = extractvalue { i64, i1 } %228, 0
  %230 = extractvalue { i64, i1 } %228, 1
  br i1 %230, label %cmpxchg.continue20.i, label %cmpxchg.store_expected19.i

atomic.continue12.i:                              ; preds = %cmpxchg.continue20.i, %cmpxchg.continue17.i, %cmpxchg.continue14.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected13.i:                       ; preds = %monotonic_fail9.i
  store i64 %219, ptr %198, align 8
  br label %cmpxchg.continue14.i

cmpxchg.continue14.i:                             ; preds = %cmpxchg.store_expected13.i, %monotonic_fail9.i
  %frombool15.i = zext i1 %220 to i8
  store i8 %frombool15.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected16.i:                       ; preds = %acquire_fail10.i
  store i64 %224, ptr %198, align 8
  br label %cmpxchg.continue17.i

cmpxchg.continue17.i:                             ; preds = %cmpxchg.store_expected16.i, %acquire_fail10.i
  %frombool18.i = zext i1 %225 to i8
  store i8 %frombool18.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected19.i:                       ; preds = %seqcst_fail11.i
  store i64 %229, ptr %198, align 8
  br label %cmpxchg.continue20.i

cmpxchg.continue20.i:                             ; preds = %cmpxchg.store_expected19.i, %seqcst_fail11.i
  %frombool21.i = zext i1 %230 to i8
  store i8 %frombool21.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

monotonic_fail22.i:                               ; preds = %release.i
  %231 = load i64, ptr %198, align 8
  %232 = load i64, ptr %.atomictmp.i, align 8
  %233 = cmpxchg ptr %this1.i405, i64 %231, i64 %232 release monotonic, align 8
  %234 = extractvalue { i64, i1 } %233, 0
  %235 = extractvalue { i64, i1 } %233, 1
  br i1 %235, label %cmpxchg.continue27.i, label %cmpxchg.store_expected26.i

acquire_fail23.i:                                 ; preds = %release.i, %release.i
  %236 = load i64, ptr %198, align 8
  %237 = load i64, ptr %.atomictmp.i, align 8
  %238 = cmpxchg ptr %this1.i405, i64 %236, i64 %237 release acquire, align 8
  %239 = extractvalue { i64, i1 } %238, 0
  %240 = extractvalue { i64, i1 } %238, 1
  br i1 %240, label %cmpxchg.continue30.i, label %cmpxchg.store_expected29.i

seqcst_fail24.i:                                  ; preds = %release.i
  %241 = load i64, ptr %198, align 8
  %242 = load i64, ptr %.atomictmp.i, align 8
  %243 = cmpxchg ptr %this1.i405, i64 %241, i64 %242 release seq_cst, align 8
  %244 = extractvalue { i64, i1 } %243, 0
  %245 = extractvalue { i64, i1 } %243, 1
  br i1 %245, label %cmpxchg.continue33.i, label %cmpxchg.store_expected32.i

atomic.continue25.i:                              ; preds = %cmpxchg.continue33.i, %cmpxchg.continue30.i, %cmpxchg.continue27.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected26.i:                       ; preds = %monotonic_fail22.i
  store i64 %234, ptr %198, align 8
  br label %cmpxchg.continue27.i

cmpxchg.continue27.i:                             ; preds = %cmpxchg.store_expected26.i, %monotonic_fail22.i
  %frombool28.i = zext i1 %235 to i8
  store i8 %frombool28.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected29.i:                       ; preds = %acquire_fail23.i
  store i64 %239, ptr %198, align 8
  br label %cmpxchg.continue30.i

cmpxchg.continue30.i:                             ; preds = %cmpxchg.store_expected29.i, %acquire_fail23.i
  %frombool31.i = zext i1 %240 to i8
  store i8 %frombool31.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected32.i:                       ; preds = %seqcst_fail24.i
  store i64 %244, ptr %198, align 8
  br label %cmpxchg.continue33.i

cmpxchg.continue33.i:                             ; preds = %cmpxchg.store_expected32.i, %seqcst_fail24.i
  %frombool34.i = zext i1 %245 to i8
  store i8 %frombool34.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

monotonic_fail35.i:                               ; preds = %acqrel.i
  %246 = load i64, ptr %198, align 8
  %247 = load i64, ptr %.atomictmp.i, align 8
  %248 = cmpxchg ptr %this1.i405, i64 %246, i64 %247 acq_rel monotonic, align 8
  %249 = extractvalue { i64, i1 } %248, 0
  %250 = extractvalue { i64, i1 } %248, 1
  br i1 %250, label %cmpxchg.continue40.i, label %cmpxchg.store_expected39.i

acquire_fail36.i:                                 ; preds = %acqrel.i, %acqrel.i
  %251 = load i64, ptr %198, align 8
  %252 = load i64, ptr %.atomictmp.i, align 8
  %253 = cmpxchg ptr %this1.i405, i64 %251, i64 %252 acq_rel acquire, align 8
  %254 = extractvalue { i64, i1 } %253, 0
  %255 = extractvalue { i64, i1 } %253, 1
  br i1 %255, label %cmpxchg.continue43.i, label %cmpxchg.store_expected42.i

seqcst_fail37.i:                                  ; preds = %acqrel.i
  %256 = load i64, ptr %198, align 8
  %257 = load i64, ptr %.atomictmp.i, align 8
  %258 = cmpxchg ptr %this1.i405, i64 %256, i64 %257 acq_rel seq_cst, align 8
  %259 = extractvalue { i64, i1 } %258, 0
  %260 = extractvalue { i64, i1 } %258, 1
  br i1 %260, label %cmpxchg.continue46.i, label %cmpxchg.store_expected45.i

atomic.continue38.i:                              ; preds = %cmpxchg.continue46.i, %cmpxchg.continue43.i, %cmpxchg.continue40.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected39.i:                       ; preds = %monotonic_fail35.i
  store i64 %249, ptr %198, align 8
  br label %cmpxchg.continue40.i

cmpxchg.continue40.i:                             ; preds = %cmpxchg.store_expected39.i, %monotonic_fail35.i
  %frombool41.i = zext i1 %250 to i8
  store i8 %frombool41.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected42.i:                       ; preds = %acquire_fail36.i
  store i64 %254, ptr %198, align 8
  br label %cmpxchg.continue43.i

cmpxchg.continue43.i:                             ; preds = %cmpxchg.store_expected42.i, %acquire_fail36.i
  %frombool44.i = zext i1 %255 to i8
  store i8 %frombool44.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected45.i:                       ; preds = %seqcst_fail37.i
  store i64 %259, ptr %198, align 8
  br label %cmpxchg.continue46.i

cmpxchg.continue46.i:                             ; preds = %cmpxchg.store_expected45.i, %seqcst_fail37.i
  %frombool47.i = zext i1 %260 to i8
  store i8 %frombool47.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

monotonic_fail48.i:                               ; preds = %seqcst.i406
  %261 = load i64, ptr %198, align 8
  %262 = load i64, ptr %.atomictmp.i, align 8
  %263 = cmpxchg ptr %this1.i405, i64 %261, i64 %262 seq_cst monotonic, align 8
  %264 = extractvalue { i64, i1 } %263, 0
  %265 = extractvalue { i64, i1 } %263, 1
  br i1 %265, label %cmpxchg.continue53.i, label %cmpxchg.store_expected52.i

acquire_fail49.i:                                 ; preds = %seqcst.i406, %seqcst.i406
  %266 = load i64, ptr %198, align 8
  %267 = load i64, ptr %.atomictmp.i, align 8
  %268 = cmpxchg ptr %this1.i405, i64 %266, i64 %267 seq_cst acquire, align 8
  %269 = extractvalue { i64, i1 } %268, 0
  %270 = extractvalue { i64, i1 } %268, 1
  br i1 %270, label %cmpxchg.continue56.i, label %cmpxchg.store_expected55.i

seqcst_fail50.i:                                  ; preds = %seqcst.i406
  %271 = load i64, ptr %198, align 8
  %272 = load i64, ptr %.atomictmp.i, align 8
  %273 = cmpxchg ptr %this1.i405, i64 %271, i64 %272 seq_cst seq_cst, align 8
  %274 = extractvalue { i64, i1 } %273, 0
  %275 = extractvalue { i64, i1 } %273, 1
  br i1 %275, label %cmpxchg.continue59.i, label %cmpxchg.store_expected58.i

atomic.continue51.i:                              ; preds = %cmpxchg.continue59.i, %cmpxchg.continue56.i, %cmpxchg.continue53.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected52.i:                       ; preds = %monotonic_fail48.i
  store i64 %264, ptr %198, align 8
  br label %cmpxchg.continue53.i

cmpxchg.continue53.i:                             ; preds = %cmpxchg.store_expected52.i, %monotonic_fail48.i
  %frombool54.i = zext i1 %265 to i8
  store i8 %frombool54.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected55.i:                       ; preds = %acquire_fail49.i
  store i64 %269, ptr %198, align 8
  br label %cmpxchg.continue56.i

cmpxchg.continue56.i:                             ; preds = %cmpxchg.store_expected55.i, %acquire_fail49.i
  %frombool57.i = zext i1 %270 to i8
  store i8 %frombool57.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected58.i:                       ; preds = %seqcst_fail50.i
  store i64 %274, ptr %198, align 8
  br label %cmpxchg.continue59.i

cmpxchg.continue59.i:                             ; preds = %cmpxchg.store_expected58.i, %seqcst_fail50.i
  %frombool60.i = zext i1 %275 to i8
  store i8 %frombool60.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit: ; preds = %atomic.continue51.i, %atomic.continue38.i, %atomic.continue25.i, %atomic.continue12.i, %atomic.continue2.i
  %276 = load i8, ptr %cmpxchg.bool.i, align 1
  %tobool.i = trunc i8 %276 to i1
  br i1 %tobool.i, label %if.then51, label %if.end351

if.then51:                                        ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit
  %277 = load i64, ptr %v, align 8
  %and52 = and i64 %277, 4
  %cmp53 = icmp eq i64 %and52, 0
  br i1 %cmp53, label %if.then54, label %if.end106

if.then54:                                        ; preds = %if.then51
  store i8 1, ptr %do_enqueue, align 1
  br label %do.body55

do.body55:                                        ; preds = %if.then54
  %278 = load ptr, ptr %waitp.addr, align 8
  %cmp56 = icmp ne ptr %278, null
  %lnot57 = xor i1 %cmp56, true
  br i1 %lnot57, label %if.then58, label %if.end67

if.then58:                                        ; preds = %do.body55
  br label %do.body59

do.body59:                                        ; preds = %if.then58
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename60, align 8
  invoke void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 2138, ptr noundef @.str.1, ptr noundef @.str.16, ptr noundef @.str.17)
          to label %invoke.cont61 unwind label %lpad

invoke.cont61:                                    ; preds = %do.body59
  br label %do.body62

do.body62:                                        ; preds = %invoke.cont61
  unreachable

do.cond63:                                        ; No predecessors!
  br label %do.end64

do.end64:                                         ; preds = %do.cond63
  br label %do.cond65

do.cond65:                                        ; preds = %do.end64
  br label %do.end66

do.end66:                                         ; preds = %do.cond65
  br label %if.end67

if.end67:                                         ; preds = %do.end66, %do.body55
  br label %do.cond68

do.cond68:                                        ; preds = %if.end67
  br label %do.end69

do.end69:                                         ; preds = %do.cond68
  br label %do.body70

do.body70:                                        ; preds = %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit, %do.end69
  %mu_71 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  store ptr %mu_71, ptr %this.addr.i, align 8
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %279 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %279, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %280 = load i32, ptr %__m.addr.i, align 4
  switch i32 %280, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %do.body70
  %281 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %281, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %do.body70, %do.body70
  %282 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %282, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %do.body70
  %283 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %283, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %284 = load i64, ptr %atomic-temp.i, align 8
  store i64 %284, ptr %v, align 8
  %285 = load i64, ptr %v, align 8
  %cmp73 = icmp sge i64 %285, 256
  br i1 %cmp73, label %cond.true, label %cond.false

cond.true:                                        ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  %286 = load i64, ptr %v, align 8
  %sub74 = sub nsw i64 %286, 256
  br label %cond.end

cond.false:                                       ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  %287 = load i64, ptr %v, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond75 = phi i64 [ %sub74, %cond.true ], [ %287, %cond.false ]
  store i64 %cond75, ptr %new_readers, align 8
  store ptr null, ptr %new_h, align 8
  %288 = load i8, ptr %do_enqueue, align 1
  %tobool76 = trunc i8 %288 to i1
  br i1 %tobool76, label %if.then77, label %if.end81

if.then77:                                        ; preds = %cond.end
  %289 = load ptr, ptr %waitp.addr, align 8
  %cv_word = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %289, i32 0, i32 5
  %290 = load ptr, ptr %cv_word, align 8
  %cmp78 = icmp eq ptr %290, null
  %frombool = zext i1 %cmp78 to i8
  store i8 %frombool, ptr %do_enqueue, align 1
  %291 = load ptr, ptr %waitp.addr, align 8
  %292 = load i64, ptr %new_readers, align 8
  %call80 = invoke noundef ptr @_ZN4abslL7EnqueueEPNS_13base_internal14PerThreadSynchEPNS_15SynchWaitParamsEli(ptr noundef null, ptr noundef %291, i64 noundef %292, i32 noundef 2)
          to label %invoke.cont79 unwind label %lpad

invoke.cont79:                                    ; preds = %if.then77
  store ptr %call80, ptr %new_h, align 8
  br label %if.end81

if.end81:                                         ; preds = %invoke.cont79, %cond.end
  store i64 40, ptr %clear82, align 8
  %293 = load i64, ptr %v, align 8
  %and83 = and i64 %293, 8
  %cmp84 = icmp eq i64 %and83, 0
  br i1 %cmp84, label %land.lhs.true85, label %if.end89

land.lhs.true85:                                  ; preds = %if.end81
  %294 = load i64, ptr %v, align 8
  %call87 = invoke noundef zeroext i1 @_ZN4abslL16ExactlyOneReaderEl(i64 noundef %294)
          to label %invoke.cont86 unwind label %lpad

invoke.cont86:                                    ; preds = %land.lhs.true85
  br i1 %call87, label %if.then88, label %if.end89

if.then88:                                        ; preds = %invoke.cont86
  store i64 33, ptr %clear82, align 8
  br label %if.end89

if.end89:                                         ; preds = %if.then88, %invoke.cont86, %if.end81
  %295 = load i64, ptr %v, align 8
  %and90 = and i64 %295, 255
  %296 = load i64, ptr %clear82, align 8
  %not = xor i64 %296, -1
  %and91 = and i64 %and90, %not
  %and92 = and i64 %and91, -65
  store i64 %and92, ptr %nv, align 8
  %297 = load ptr, ptr %new_h, align 8
  %cmp93 = icmp ne ptr %297, null
  br i1 %cmp93, label %if.then94, label %if.else97

if.then94:                                        ; preds = %if.end89
  %298 = load ptr, ptr %new_h, align 8
  %299 = ptrtoint ptr %298 to i64
  %or95 = or i64 4, %299
  %300 = load i64, ptr %nv, align 8
  %or96 = or i64 %300, %or95
  store i64 %or96, ptr %nv, align 8
  br label %if.end100

if.else97:                                        ; preds = %if.end89
  %301 = load i64, ptr %new_readers, align 8
  %and98 = and i64 %301, -256
  %302 = load i64, ptr %nv, align 8
  %or99 = or i64 %302, %and98
  store i64 %or99, ptr %nv, align 8
  br label %if.end100

if.end100:                                        ; preds = %if.else97, %if.then94
  br label %do.cond101

do.cond101:                                       ; preds = %if.end100
  %mu_102 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %303 = load i64, ptr %nv, align 8
  store ptr %mu_102, ptr %this.addr.i569, align 8
  store ptr %v, ptr %__i1.addr.i570, align 8
  store i64 %303, ptr %__i2.addr.i571, align 8
  store i32 3, ptr %__m1.addr.i572, align 4
  store i32 0, ptr %__m2.addr.i573, align 4
  %this1.i576 = load ptr, ptr %this.addr.i569, align 8
  %304 = load i32, ptr %__m1.addr.i572, align 4
  %305 = load ptr, ptr %__i1.addr.i570, align 8
  %306 = load i64, ptr %__i2.addr.i571, align 8
  store i64 %306, ptr %.atomictmp.i574, align 8
  %307 = load i32, ptr %__m2.addr.i573, align 4
  switch i32 %304, label %monotonic.i634 [
    i32 1, label %acquire.i620
    i32 2, label %acquire.i620
    i32 3, label %release.i606
    i32 4, label %acqrel.i592
    i32 5, label %seqcst.i577
  ]

monotonic.i634:                                   ; preds = %do.cond101
  switch i32 %307, label %monotonic_fail.i644 [
    i32 1, label %acquire_fail.i640
    i32 2, label %acquire_fail.i640
    i32 5, label %seqcst_fail.i635
  ]

acquire.i620:                                     ; preds = %do.cond101, %do.cond101
  switch i32 %307, label %monotonic_fail9.i630 [
    i32 1, label %acquire_fail10.i626
    i32 2, label %acquire_fail10.i626
    i32 5, label %seqcst_fail11.i621
  ]

release.i606:                                     ; preds = %do.cond101
  switch i32 %307, label %monotonic_fail22.i616 [
    i32 1, label %acquire_fail23.i612
    i32 2, label %acquire_fail23.i612
    i32 5, label %seqcst_fail24.i607
  ]

acqrel.i592:                                      ; preds = %do.cond101
  switch i32 %307, label %monotonic_fail35.i602 [
    i32 1, label %acquire_fail36.i598
    i32 2, label %acquire_fail36.i598
    i32 5, label %seqcst_fail37.i593
  ]

seqcst.i577:                                      ; preds = %do.cond101
  switch i32 %307, label %monotonic_fail48.i588 [
    i32 1, label %acquire_fail49.i584
    i32 2, label %acquire_fail49.i584
    i32 5, label %seqcst_fail50.i578
  ]

monotonic_fail.i644:                              ; preds = %monotonic.i634
  %308 = load i64, ptr %305, align 8
  %309 = load i64, ptr %.atomictmp.i574, align 8
  %310 = cmpxchg weak ptr %this1.i576, i64 %308, i64 %309 monotonic monotonic, align 8
  %311 = extractvalue { i64, i1 } %310, 0
  %312 = extractvalue { i64, i1 } %310, 1
  br i1 %312, label %cmpxchg.continue.i646, label %cmpxchg.store_expected.i645

acquire_fail.i640:                                ; preds = %monotonic.i634, %monotonic.i634
  %313 = load i64, ptr %305, align 8
  %314 = load i64, ptr %.atomictmp.i574, align 8
  %315 = cmpxchg weak ptr %this1.i576, i64 %313, i64 %314 monotonic acquire, align 8
  %316 = extractvalue { i64, i1 } %315, 0
  %317 = extractvalue { i64, i1 } %315, 1
  br i1 %317, label %cmpxchg.continue4.i642, label %cmpxchg.store_expected3.i641

seqcst_fail.i635:                                 ; preds = %monotonic.i634
  %318 = load i64, ptr %305, align 8
  %319 = load i64, ptr %.atomictmp.i574, align 8
  %320 = cmpxchg weak ptr %this1.i576, i64 %318, i64 %319 monotonic seq_cst, align 8
  %321 = extractvalue { i64, i1 } %320, 0
  %322 = extractvalue { i64, i1 } %320, 1
  br i1 %322, label %cmpxchg.continue7.i637, label %cmpxchg.store_expected6.i636

atomic.continue2.i639:                            ; preds = %cmpxchg.continue7.i637, %cmpxchg.continue4.i642, %cmpxchg.continue.i646
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected.i645:                      ; preds = %monotonic_fail.i644
  store i64 %311, ptr %305, align 8
  br label %cmpxchg.continue.i646

cmpxchg.continue.i646:                            ; preds = %cmpxchg.store_expected.i645, %monotonic_fail.i644
  %frombool.i647 = zext i1 %312 to i8
  store i8 %frombool.i647, ptr %cmpxchg.bool.i575, align 1
  br label %atomic.continue2.i639

cmpxchg.store_expected3.i641:                     ; preds = %acquire_fail.i640
  store i64 %316, ptr %305, align 8
  br label %cmpxchg.continue4.i642

cmpxchg.continue4.i642:                           ; preds = %cmpxchg.store_expected3.i641, %acquire_fail.i640
  %frombool5.i643 = zext i1 %317 to i8
  store i8 %frombool5.i643, ptr %cmpxchg.bool.i575, align 1
  br label %atomic.continue2.i639

cmpxchg.store_expected6.i636:                     ; preds = %seqcst_fail.i635
  store i64 %321, ptr %305, align 8
  br label %cmpxchg.continue7.i637

cmpxchg.continue7.i637:                           ; preds = %cmpxchg.store_expected6.i636, %seqcst_fail.i635
  %frombool8.i638 = zext i1 %322 to i8
  store i8 %frombool8.i638, ptr %cmpxchg.bool.i575, align 1
  br label %atomic.continue2.i639

monotonic_fail9.i630:                             ; preds = %acquire.i620
  %323 = load i64, ptr %305, align 8
  %324 = load i64, ptr %.atomictmp.i574, align 8
  %325 = cmpxchg weak ptr %this1.i576, i64 %323, i64 %324 acquire monotonic, align 8
  %326 = extractvalue { i64, i1 } %325, 0
  %327 = extractvalue { i64, i1 } %325, 1
  br i1 %327, label %cmpxchg.continue14.i632, label %cmpxchg.store_expected13.i631

acquire_fail10.i626:                              ; preds = %acquire.i620, %acquire.i620
  %328 = load i64, ptr %305, align 8
  %329 = load i64, ptr %.atomictmp.i574, align 8
  %330 = cmpxchg weak ptr %this1.i576, i64 %328, i64 %329 acquire acquire, align 8
  %331 = extractvalue { i64, i1 } %330, 0
  %332 = extractvalue { i64, i1 } %330, 1
  br i1 %332, label %cmpxchg.continue17.i628, label %cmpxchg.store_expected16.i627

seqcst_fail11.i621:                               ; preds = %acquire.i620
  %333 = load i64, ptr %305, align 8
  %334 = load i64, ptr %.atomictmp.i574, align 8
  %335 = cmpxchg weak ptr %this1.i576, i64 %333, i64 %334 acquire seq_cst, align 8
  %336 = extractvalue { i64, i1 } %335, 0
  %337 = extractvalue { i64, i1 } %335, 1
  br i1 %337, label %cmpxchg.continue20.i623, label %cmpxchg.store_expected19.i622

atomic.continue12.i625:                           ; preds = %cmpxchg.continue20.i623, %cmpxchg.continue17.i628, %cmpxchg.continue14.i632
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected13.i631:                    ; preds = %monotonic_fail9.i630
  store i64 %326, ptr %305, align 8
  br label %cmpxchg.continue14.i632

cmpxchg.continue14.i632:                          ; preds = %cmpxchg.store_expected13.i631, %monotonic_fail9.i630
  %frombool15.i633 = zext i1 %327 to i8
  store i8 %frombool15.i633, ptr %cmpxchg.bool.i575, align 1
  br label %atomic.continue12.i625

cmpxchg.store_expected16.i627:                    ; preds = %acquire_fail10.i626
  store i64 %331, ptr %305, align 8
  br label %cmpxchg.continue17.i628

cmpxchg.continue17.i628:                          ; preds = %cmpxchg.store_expected16.i627, %acquire_fail10.i626
  %frombool18.i629 = zext i1 %332 to i8
  store i8 %frombool18.i629, ptr %cmpxchg.bool.i575, align 1
  br label %atomic.continue12.i625

cmpxchg.store_expected19.i622:                    ; preds = %seqcst_fail11.i621
  store i64 %336, ptr %305, align 8
  br label %cmpxchg.continue20.i623

cmpxchg.continue20.i623:                          ; preds = %cmpxchg.store_expected19.i622, %seqcst_fail11.i621
  %frombool21.i624 = zext i1 %337 to i8
  store i8 %frombool21.i624, ptr %cmpxchg.bool.i575, align 1
  br label %atomic.continue12.i625

monotonic_fail22.i616:                            ; preds = %release.i606
  %338 = load i64, ptr %305, align 8
  %339 = load i64, ptr %.atomictmp.i574, align 8
  %340 = cmpxchg weak ptr %this1.i576, i64 %338, i64 %339 release monotonic, align 8
  %341 = extractvalue { i64, i1 } %340, 0
  %342 = extractvalue { i64, i1 } %340, 1
  br i1 %342, label %cmpxchg.continue27.i618, label %cmpxchg.store_expected26.i617

acquire_fail23.i612:                              ; preds = %release.i606, %release.i606
  %343 = load i64, ptr %305, align 8
  %344 = load i64, ptr %.atomictmp.i574, align 8
  %345 = cmpxchg weak ptr %this1.i576, i64 %343, i64 %344 release acquire, align 8
  %346 = extractvalue { i64, i1 } %345, 0
  %347 = extractvalue { i64, i1 } %345, 1
  br i1 %347, label %cmpxchg.continue30.i614, label %cmpxchg.store_expected29.i613

seqcst_fail24.i607:                               ; preds = %release.i606
  %348 = load i64, ptr %305, align 8
  %349 = load i64, ptr %.atomictmp.i574, align 8
  %350 = cmpxchg weak ptr %this1.i576, i64 %348, i64 %349 release seq_cst, align 8
  %351 = extractvalue { i64, i1 } %350, 0
  %352 = extractvalue { i64, i1 } %350, 1
  br i1 %352, label %cmpxchg.continue33.i609, label %cmpxchg.store_expected32.i608

atomic.continue25.i611:                           ; preds = %cmpxchg.continue33.i609, %cmpxchg.continue30.i614, %cmpxchg.continue27.i618
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected26.i617:                    ; preds = %monotonic_fail22.i616
  store i64 %341, ptr %305, align 8
  br label %cmpxchg.continue27.i618

cmpxchg.continue27.i618:                          ; preds = %cmpxchg.store_expected26.i617, %monotonic_fail22.i616
  %frombool28.i619 = zext i1 %342 to i8
  store i8 %frombool28.i619, ptr %cmpxchg.bool.i575, align 1
  br label %atomic.continue25.i611

cmpxchg.store_expected29.i613:                    ; preds = %acquire_fail23.i612
  store i64 %346, ptr %305, align 8
  br label %cmpxchg.continue30.i614

cmpxchg.continue30.i614:                          ; preds = %cmpxchg.store_expected29.i613, %acquire_fail23.i612
  %frombool31.i615 = zext i1 %347 to i8
  store i8 %frombool31.i615, ptr %cmpxchg.bool.i575, align 1
  br label %atomic.continue25.i611

cmpxchg.store_expected32.i608:                    ; preds = %seqcst_fail24.i607
  store i64 %351, ptr %305, align 8
  br label %cmpxchg.continue33.i609

cmpxchg.continue33.i609:                          ; preds = %cmpxchg.store_expected32.i608, %seqcst_fail24.i607
  %frombool34.i610 = zext i1 %352 to i8
  store i8 %frombool34.i610, ptr %cmpxchg.bool.i575, align 1
  br label %atomic.continue25.i611

monotonic_fail35.i602:                            ; preds = %acqrel.i592
  %353 = load i64, ptr %305, align 8
  %354 = load i64, ptr %.atomictmp.i574, align 8
  %355 = cmpxchg weak ptr %this1.i576, i64 %353, i64 %354 acq_rel monotonic, align 8
  %356 = extractvalue { i64, i1 } %355, 0
  %357 = extractvalue { i64, i1 } %355, 1
  br i1 %357, label %cmpxchg.continue40.i604, label %cmpxchg.store_expected39.i603

acquire_fail36.i598:                              ; preds = %acqrel.i592, %acqrel.i592
  %358 = load i64, ptr %305, align 8
  %359 = load i64, ptr %.atomictmp.i574, align 8
  %360 = cmpxchg weak ptr %this1.i576, i64 %358, i64 %359 acq_rel acquire, align 8
  %361 = extractvalue { i64, i1 } %360, 0
  %362 = extractvalue { i64, i1 } %360, 1
  br i1 %362, label %cmpxchg.continue43.i600, label %cmpxchg.store_expected42.i599

seqcst_fail37.i593:                               ; preds = %acqrel.i592
  %363 = load i64, ptr %305, align 8
  %364 = load i64, ptr %.atomictmp.i574, align 8
  %365 = cmpxchg weak ptr %this1.i576, i64 %363, i64 %364 acq_rel seq_cst, align 8
  %366 = extractvalue { i64, i1 } %365, 0
  %367 = extractvalue { i64, i1 } %365, 1
  br i1 %367, label %cmpxchg.continue46.i595, label %cmpxchg.store_expected45.i594

atomic.continue38.i597:                           ; preds = %cmpxchg.continue46.i595, %cmpxchg.continue43.i600, %cmpxchg.continue40.i604
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected39.i603:                    ; preds = %monotonic_fail35.i602
  store i64 %356, ptr %305, align 8
  br label %cmpxchg.continue40.i604

cmpxchg.continue40.i604:                          ; preds = %cmpxchg.store_expected39.i603, %monotonic_fail35.i602
  %frombool41.i605 = zext i1 %357 to i8
  store i8 %frombool41.i605, ptr %cmpxchg.bool.i575, align 1
  br label %atomic.continue38.i597

cmpxchg.store_expected42.i599:                    ; preds = %acquire_fail36.i598
  store i64 %361, ptr %305, align 8
  br label %cmpxchg.continue43.i600

cmpxchg.continue43.i600:                          ; preds = %cmpxchg.store_expected42.i599, %acquire_fail36.i598
  %frombool44.i601 = zext i1 %362 to i8
  store i8 %frombool44.i601, ptr %cmpxchg.bool.i575, align 1
  br label %atomic.continue38.i597

cmpxchg.store_expected45.i594:                    ; preds = %seqcst_fail37.i593
  store i64 %366, ptr %305, align 8
  br label %cmpxchg.continue46.i595

cmpxchg.continue46.i595:                          ; preds = %cmpxchg.store_expected45.i594, %seqcst_fail37.i593
  %frombool47.i596 = zext i1 %367 to i8
  store i8 %frombool47.i596, ptr %cmpxchg.bool.i575, align 1
  br label %atomic.continue38.i597

monotonic_fail48.i588:                            ; preds = %seqcst.i577
  %368 = load i64, ptr %305, align 8
  %369 = load i64, ptr %.atomictmp.i574, align 8
  %370 = cmpxchg weak ptr %this1.i576, i64 %368, i64 %369 seq_cst monotonic, align 8
  %371 = extractvalue { i64, i1 } %370, 0
  %372 = extractvalue { i64, i1 } %370, 1
  br i1 %372, label %cmpxchg.continue53.i590, label %cmpxchg.store_expected52.i589

acquire_fail49.i584:                              ; preds = %seqcst.i577, %seqcst.i577
  %373 = load i64, ptr %305, align 8
  %374 = load i64, ptr %.atomictmp.i574, align 8
  %375 = cmpxchg weak ptr %this1.i576, i64 %373, i64 %374 seq_cst acquire, align 8
  %376 = extractvalue { i64, i1 } %375, 0
  %377 = extractvalue { i64, i1 } %375, 1
  br i1 %377, label %cmpxchg.continue56.i586, label %cmpxchg.store_expected55.i585

seqcst_fail50.i578:                               ; preds = %seqcst.i577
  %378 = load i64, ptr %305, align 8
  %379 = load i64, ptr %.atomictmp.i574, align 8
  %380 = cmpxchg weak ptr %this1.i576, i64 %378, i64 %379 seq_cst seq_cst, align 8
  %381 = extractvalue { i64, i1 } %380, 0
  %382 = extractvalue { i64, i1 } %380, 1
  br i1 %382, label %cmpxchg.continue59.i580, label %cmpxchg.store_expected58.i579

atomic.continue51.i582:                           ; preds = %cmpxchg.continue59.i580, %cmpxchg.continue56.i586, %cmpxchg.continue53.i590
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected52.i589:                    ; preds = %monotonic_fail48.i588
  store i64 %371, ptr %305, align 8
  br label %cmpxchg.continue53.i590

cmpxchg.continue53.i590:                          ; preds = %cmpxchg.store_expected52.i589, %monotonic_fail48.i588
  %frombool54.i591 = zext i1 %372 to i8
  store i8 %frombool54.i591, ptr %cmpxchg.bool.i575, align 1
  br label %atomic.continue51.i582

cmpxchg.store_expected55.i585:                    ; preds = %acquire_fail49.i584
  store i64 %376, ptr %305, align 8
  br label %cmpxchg.continue56.i586

cmpxchg.continue56.i586:                          ; preds = %cmpxchg.store_expected55.i585, %acquire_fail49.i584
  %frombool57.i587 = zext i1 %377 to i8
  store i8 %frombool57.i587, ptr %cmpxchg.bool.i575, align 1
  br label %atomic.continue51.i582

cmpxchg.store_expected58.i579:                    ; preds = %seqcst_fail50.i578
  store i64 %381, ptr %305, align 8
  br label %cmpxchg.continue59.i580

cmpxchg.continue59.i580:                          ; preds = %cmpxchg.store_expected58.i579, %seqcst_fail50.i578
  %frombool60.i581 = zext i1 %382 to i8
  store i8 %frombool60.i581, ptr %cmpxchg.bool.i575, align 1
  br label %atomic.continue51.i582

_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit: ; preds = %atomic.continue51.i582, %atomic.continue38.i597, %atomic.continue25.i611, %atomic.continue12.i625, %atomic.continue2.i639
  %383 = load i8, ptr %cmpxchg.bool.i575, align 1
  %tobool.i583 = trunc i8 %383 to i1
  %lnot104 = xor i1 %tobool.i583, true
  br i1 %lnot104, label %do.body70, label %do.end105, !llvm.loop !15

do.end105:                                        ; preds = %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit
  br label %for.end

if.end106:                                        ; preds = %if.then51
  %384 = load i64, ptr %v, align 8
  %call108 = invoke noundef ptr @_ZN4abslL17GetPerThreadSynchEl(i64 noundef %384)
          to label %invoke.cont107 unwind label %lpad

invoke.cont107:                                   ; preds = %if.end106
  store ptr %call108, ptr %h, align 8
  %385 = load i64, ptr %v, align 8
  %and109 = and i64 %385, 1
  %cmp110 = icmp ne i64 %and109, 0
  br i1 %cmp110, label %land.lhs.true111, label %if.end143

land.lhs.true111:                                 ; preds = %invoke.cont107
  %386 = load ptr, ptr %h, align 8
  %readers = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %386, i32 0, i32 10
  %387 = load i64, ptr %readers, align 8
  %and112 = and i64 %387, -256
  %cmp113 = icmp sgt i64 %and112, 256
  br i1 %cmp113, label %if.then114, label %if.end143

if.then114:                                       ; preds = %land.lhs.true111
  %388 = load ptr, ptr %h, align 8
  %readers115 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %388, i32 0, i32 10
  %389 = load i64, ptr %readers115, align 8
  %sub116 = sub nsw i64 %389, 256
  store i64 %sub116, ptr %readers115, align 8
  %390 = load i64, ptr %v, align 8
  store i64 %390, ptr %nv117, align 8
  %391 = load ptr, ptr %waitp.addr, align 8
  %cmp118 = icmp ne ptr %391, null
  br i1 %cmp118, label %if.then119, label %if.end141

if.then119:                                       ; preds = %if.then114
  %392 = load ptr, ptr %h, align 8
  %393 = load ptr, ptr %waitp.addr, align 8
  %394 = load i64, ptr %v, align 8
  %call122 = invoke noundef ptr @_ZN4abslL7EnqueueEPNS_13base_internal14PerThreadSynchEPNS_15SynchWaitParamsEli(ptr noundef %392, ptr noundef %393, i64 noundef %394, i32 noundef 2)
          to label %invoke.cont121 unwind label %lpad

invoke.cont121:                                   ; preds = %if.then119
  store ptr %call122, ptr %new_h120, align 8
  br label %do.body123

do.body123:                                       ; preds = %invoke.cont121
  %395 = load ptr, ptr %new_h120, align 8
  %cmp124 = icmp ne ptr %395, null
  %lnot125 = xor i1 %cmp124, true
  br i1 %lnot125, label %if.then126, label %if.end135

if.then126:                                       ; preds = %do.body123
  br label %do.body127

do.body127:                                       ; preds = %if.then126
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename128, align 8
  invoke void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 2182, ptr noundef @.str.1, ptr noundef @.str.11, ptr noundef @.str.18)
          to label %invoke.cont129 unwind label %lpad

invoke.cont129:                                   ; preds = %do.body127
  br label %do.body130

do.body130:                                       ; preds = %invoke.cont129
  unreachable

do.cond131:                                       ; No predecessors!
  br label %do.end132

do.end132:                                        ; preds = %do.cond131
  br label %do.cond133

do.cond133:                                       ; preds = %do.end132
  br label %do.end134

do.end134:                                        ; preds = %do.cond133
  br label %if.end135

if.end135:                                        ; preds = %do.end134, %do.body123
  br label %do.cond136

do.cond136:                                       ; preds = %if.end135
  br label %do.end137

do.end137:                                        ; preds = %do.cond136
  %396 = load i64, ptr %nv117, align 8
  %and138 = and i64 %396, 255
  store i64 %and138, ptr %nv117, align 8
  %397 = load ptr, ptr %new_h120, align 8
  %398 = ptrtoint ptr %397 to i64
  %or139 = or i64 4, %398
  %399 = load i64, ptr %nv117, align 8
  %or140 = or i64 %399, %or139
  store i64 %or140, ptr %nv117, align 8
  br label %if.end141

if.end141:                                        ; preds = %do.end137, %if.then114
  %mu_142 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %400 = load i64, ptr %nv117, align 8
  store ptr %mu_142, ptr %this.addr.i679, align 8
  store i64 %400, ptr %__i.addr.i680, align 8
  store i32 3, ptr %__m.addr.i681, align 4
  %this1.i684 = load ptr, ptr %this.addr.i679, align 8
  %401 = load i32, ptr %__m.addr.i681, align 4
  %call.i685 = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %401, i32 noundef 65535)
  store i32 %call.i685, ptr %__b.i682, align 4
  %402 = load i32, ptr %__m.addr.i681, align 4
  %403 = load i64, ptr %__i.addr.i680, align 8
  store i64 %403, ptr %.atomictmp.i683, align 8
  switch i32 %402, label %monotonic.i688 [
    i32 3, label %release.i687
    i32 5, label %seqcst.i686
  ]

monotonic.i688:                                   ; preds = %if.end141
  %404 = load i64, ptr %.atomictmp.i683, align 8
  store atomic i64 %404, ptr %this1.i684 monotonic, align 8
  br label %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit689

release.i687:                                     ; preds = %if.end141
  %405 = load i64, ptr %.atomictmp.i683, align 8
  store atomic i64 %405, ptr %this1.i684 release, align 8
  br label %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit689

seqcst.i686:                                      ; preds = %if.end141
  %406 = load i64, ptr %.atomictmp.i683, align 8
  store atomic i64 %406, ptr %this1.i684 seq_cst, align 8
  br label %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit689

_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit689: ; preds = %seqcst.i686, %release.i687, %monotonic.i688
  br label %for.end

if.end143:                                        ; preds = %land.lhs.true111, %invoke.cont107
  br label %do.body144

do.body144:                                       ; preds = %if.end143
  %407 = load ptr, ptr %old_h, align 8
  %cmp145 = icmp eq ptr %407, null
  br i1 %cmp145, label %lor.end148, label %lor.rhs146

lor.rhs146:                                       ; preds = %do.body144
  %408 = load ptr, ptr %h, align 8
  %maybe_unlocking = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %408, i32 0, i32 5
  %409 = load i8, ptr %maybe_unlocking, align 1
  %tobool147 = trunc i8 %409 to i1
  br label %lor.end148

lor.end148:                                       ; preds = %lor.rhs146, %do.body144
  %410 = phi i1 [ true, %do.body144 ], [ %tobool147, %lor.rhs146 ]
  %lnot149 = xor i1 %410, true
  br i1 %lnot149, label %if.then150, label %if.end159

if.then150:                                       ; preds = %lor.end148
  br label %do.body151

do.body151:                                       ; preds = %if.then150
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename152, align 8
  invoke void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 2194, ptr noundef @.str.1, ptr noundef @.str.19, ptr noundef @.str.20)
          to label %invoke.cont153 unwind label %lpad

invoke.cont153:                                   ; preds = %do.body151
  br label %do.body154

do.body154:                                       ; preds = %invoke.cont153
  unreachable

do.cond155:                                       ; No predecessors!
  br label %do.end156

do.end156:                                        ; preds = %do.cond155
  br label %do.cond157

do.cond157:                                       ; preds = %do.end156
  br label %do.end158

do.end158:                                        ; preds = %do.cond157
  br label %if.end159

if.end159:                                        ; preds = %do.end158, %lor.end148
  br label %do.cond160

do.cond160:                                       ; preds = %if.end159
  br label %do.end161

do.end161:                                        ; preds = %do.cond160
  %411 = load ptr, ptr %old_h, align 8
  %cmp162 = icmp ne ptr %411, null
  br i1 %cmp162, label %land.lhs.true163, label %if.end190

land.lhs.true163:                                 ; preds = %do.end161
  %412 = load ptr, ptr %old_h, align 8
  %may_skip = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %412, i32 0, i32 2
  %413 = load i8, ptr %may_skip, align 8
  %tobool164 = trunc i8 %413 to i1
  br i1 %tobool164, label %if.end190, label %if.then165

if.then165:                                       ; preds = %land.lhs.true163
  %414 = load ptr, ptr %old_h, align 8
  %may_skip166 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %414, i32 0, i32 2
  store i8 1, ptr %may_skip166, align 8
  br label %do.body167

do.body167:                                       ; preds = %if.then165
  %415 = load ptr, ptr %old_h, align 8
  %skip = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %415, i32 0, i32 1
  %416 = load ptr, ptr %skip, align 8
  %cmp168 = icmp eq ptr %416, null
  %lnot169 = xor i1 %cmp168, true
  br i1 %lnot169, label %if.then170, label %if.end179

if.then170:                                       ; preds = %do.body167
  br label %do.body171

do.body171:                                       ; preds = %if.then170
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename172, align 8
  invoke void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 2200, ptr noundef @.str.1, ptr noundef @.str.21, ptr noundef @.str.22)
          to label %invoke.cont173 unwind label %lpad

invoke.cont173:                                   ; preds = %do.body171
  br label %do.body174

do.body174:                                       ; preds = %invoke.cont173
  unreachable

do.cond175:                                       ; No predecessors!
  br label %do.end176

do.end176:                                        ; preds = %do.cond175
  br label %do.cond177

do.cond177:                                       ; preds = %do.end176
  br label %do.end178

do.end178:                                        ; preds = %do.cond177
  br label %if.end179

if.end179:                                        ; preds = %do.end178, %do.body167
  br label %do.cond180

do.cond180:                                       ; preds = %if.end179
  br label %do.end181

do.end181:                                        ; preds = %do.cond180
  %417 = load ptr, ptr %h, align 8
  %418 = load ptr, ptr %old_h, align 8
  %cmp182 = icmp ne ptr %417, %418
  br i1 %cmp182, label %land.lhs.true183, label %if.end189

land.lhs.true183:                                 ; preds = %do.end181
  %419 = load ptr, ptr %old_h, align 8
  %420 = load ptr, ptr %old_h, align 8
  %next = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %420, i32 0, i32 0
  %421 = load ptr, ptr %next, align 8
  %call185 = invoke noundef zeroext i1 @_ZN4abslL18MuEquivalentWaiterEPNS_13base_internal14PerThreadSynchES2_(ptr noundef %419, ptr noundef %421)
          to label %invoke.cont184 unwind label %lpad

invoke.cont184:                                   ; preds = %land.lhs.true183
  br i1 %call185, label %if.then186, label %if.end189

if.then186:                                       ; preds = %invoke.cont184
  %422 = load ptr, ptr %old_h, align 8
  %next187 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %422, i32 0, i32 0
  %423 = load ptr, ptr %next187, align 8
  %424 = load ptr, ptr %old_h, align 8
  %skip188 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %424, i32 0, i32 1
  store ptr %423, ptr %skip188, align 8
  br label %if.end189

if.end189:                                        ; preds = %if.then186, %invoke.cont184, %do.end181
  br label %if.end190

if.end190:                                        ; preds = %if.end189, %land.lhs.true163, %do.end161
  %425 = load ptr, ptr %h, align 8
  %next191 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %425, i32 0, i32 0
  %426 = load ptr, ptr %next191, align 8
  %waitp192 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %426, i32 0, i32 9
  %427 = load ptr, ptr %waitp192, align 8
  %how = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %427, i32 0, i32 0
  %428 = load ptr, ptr %how, align 8
  %cmp193 = icmp eq ptr %428, @_ZN4abslL11kExclusiveSE
  br i1 %cmp193, label %land.lhs.true194, label %if.else201

land.lhs.true194:                                 ; preds = %if.end190
  %429 = load ptr, ptr %h, align 8
  %next195 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %429, i32 0, i32 0
  %430 = load ptr, ptr %next195, align 8
  %waitp196 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %430, i32 0, i32 9
  %431 = load ptr, ptr %waitp196, align 8
  %cond197 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %431, i32 0, i32 1
  %432 = load ptr, ptr %cond197, align 8
  %cmp198 = icmp eq ptr %432, null
  br i1 %cmp198, label %if.then199, label %if.else201

if.then199:                                       ; preds = %land.lhs.true194
  %433 = load ptr, ptr %h, align 8
  store ptr %433, ptr %pw, align 8
  %434 = load ptr, ptr %h, align 8
  %next200 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %434, i32 0, i32 0
  %435 = load ptr, ptr %next200, align 8
  store ptr %435, ptr %w, align 8
  %436 = load ptr, ptr %w, align 8
  %wake = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %436, i32 0, i32 3
  store i8 1, ptr %wake, align 1
  store i64 32, ptr %wr_wait, align 8
  br label %if.end300

if.else201:                                       ; preds = %land.lhs.true194, %if.end190
  %437 = load ptr, ptr %w, align 8
  %cmp202 = icmp ne ptr %437, null
  br i1 %cmp202, label %land.lhs.true203, label %if.else213

land.lhs.true203:                                 ; preds = %if.else201
  %438 = load ptr, ptr %w, align 8
  %waitp204 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %438, i32 0, i32 9
  %439 = load ptr, ptr %waitp204, align 8
  %how205 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %439, i32 0, i32 0
  %440 = load ptr, ptr %how205, align 8
  %cmp206 = icmp eq ptr %440, @_ZN4abslL11kExclusiveSE
  br i1 %cmp206, label %if.then209, label %lor.lhs.false207

lor.lhs.false207:                                 ; preds = %land.lhs.true203
  %441 = load ptr, ptr %h, align 8
  %442 = load ptr, ptr %old_h, align 8
  %cmp208 = icmp eq ptr %441, %442
  br i1 %cmp208, label %if.then209, label %if.else213

if.then209:                                       ; preds = %lor.lhs.false207, %land.lhs.true203
  %443 = load ptr, ptr %pw, align 8
  %cmp210 = icmp eq ptr %443, null
  br i1 %cmp210, label %if.then211, label %if.end212

if.then211:                                       ; preds = %if.then209
  %444 = load ptr, ptr %h, align 8
  store ptr %444, ptr %pw, align 8
  br label %if.end212

if.end212:                                        ; preds = %if.then211, %if.then209
  br label %if.end299

if.else213:                                       ; preds = %lor.lhs.false207, %if.else201
  %445 = load ptr, ptr %old_h, align 8
  %446 = load ptr, ptr %h, align 8
  %cmp214 = icmp eq ptr %445, %446
  br i1 %cmp214, label %if.then215, label %if.end233

if.then215:                                       ; preds = %if.else213
  %447 = load i64, ptr %v, align 8
  %and217 = and i64 %447, -42
  store i64 %and217, ptr %nv216, align 8
  %448 = load ptr, ptr %h, align 8
  %readers218 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %448, i32 0, i32 10
  store i64 0, ptr %readers218, align 8
  %449 = load ptr, ptr %h, align 8
  %maybe_unlocking219 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %449, i32 0, i32 5
  store i8 0, ptr %maybe_unlocking219, align 1
  %450 = load ptr, ptr %waitp.addr, align 8
  %cmp220 = icmp ne ptr %450, null
  br i1 %cmp220, label %if.then221, label %if.end231

if.then221:                                       ; preds = %if.then215
  %451 = load ptr, ptr %h, align 8
  %452 = load ptr, ptr %waitp.addr, align 8
  %453 = load i64, ptr %v, align 8
  %call224 = invoke noundef ptr @_ZN4abslL7EnqueueEPNS_13base_internal14PerThreadSynchEPNS_15SynchWaitParamsEli(ptr noundef %451, ptr noundef %452, i64 noundef %453, i32 noundef 2)
          to label %invoke.cont223 unwind label %lpad

invoke.cont223:                                   ; preds = %if.then221
  store ptr %call224, ptr %new_h222, align 8
  %454 = load i64, ptr %nv216, align 8
  %and225 = and i64 %454, 255
  store i64 %and225, ptr %nv216, align 8
  %455 = load ptr, ptr %new_h222, align 8
  %cmp226 = icmp ne ptr %455, null
  br i1 %cmp226, label %if.then227, label %if.end230

if.then227:                                       ; preds = %invoke.cont223
  %456 = load ptr, ptr %new_h222, align 8
  %457 = ptrtoint ptr %456 to i64
  %or228 = or i64 4, %457
  %458 = load i64, ptr %nv216, align 8
  %or229 = or i64 %458, %or228
  store i64 %or229, ptr %nv216, align 8
  br label %if.end230

if.end230:                                        ; preds = %if.then227, %invoke.cont223
  br label %if.end231

if.end231:                                        ; preds = %if.end230, %if.then215
  %mu_232 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %459 = load i64, ptr %nv216, align 8
  store ptr %mu_232, ptr %this.addr.i668, align 8
  store i64 %459, ptr %__i.addr.i669, align 8
  store i32 3, ptr %__m.addr.i670, align 4
  %this1.i673 = load ptr, ptr %this.addr.i668, align 8
  %460 = load i32, ptr %__m.addr.i670, align 4
  %call.i674 = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %460, i32 noundef 65535)
  store i32 %call.i674, ptr %__b.i671, align 4
  %461 = load i32, ptr %__m.addr.i670, align 4
  %462 = load i64, ptr %__i.addr.i669, align 8
  store i64 %462, ptr %.atomictmp.i672, align 8
  switch i32 %461, label %monotonic.i677 [
    i32 3, label %release.i676
    i32 5, label %seqcst.i675
  ]

monotonic.i677:                                   ; preds = %if.end231
  %463 = load i64, ptr %.atomictmp.i672, align 8
  store atomic i64 %463, ptr %this1.i673 monotonic, align 8
  br label %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit678

release.i676:                                     ; preds = %if.end231
  %464 = load i64, ptr %.atomictmp.i672, align 8
  store atomic i64 %464, ptr %this1.i673 release, align 8
  br label %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit678

seqcst.i675:                                      ; preds = %if.end231
  %465 = load i64, ptr %.atomictmp.i672, align 8
  store atomic i64 %465, ptr %this1.i673 seq_cst, align 8
  br label %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit678

_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit678: ; preds = %seqcst.i675, %release.i676, %monotonic.i677
  br label %for.end

if.end233:                                        ; preds = %if.else213
  %466 = load ptr, ptr %old_h, align 8
  %cmp234 = icmp ne ptr %466, null
  br i1 %cmp234, label %if.then235, label %if.else237

if.then235:                                       ; preds = %if.end233
  %467 = load ptr, ptr %old_h, align 8
  store ptr %467, ptr %pw_walk, align 8
  %468 = load ptr, ptr %old_h, align 8
  %next236 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %468, i32 0, i32 0
  %469 = load ptr, ptr %next236, align 8
  store ptr %469, ptr %w_walk, align 8
  br label %if.end239

if.else237:                                       ; preds = %if.end233
  store ptr null, ptr %pw_walk, align 8
  %470 = load ptr, ptr %h, align 8
  %next238 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %470, i32 0, i32 0
  %471 = load ptr, ptr %next238, align 8
  store ptr %471, ptr %w_walk, align 8
  br label %if.end239

if.end239:                                        ; preds = %if.else237, %if.then235
  %472 = load ptr, ptr %h, align 8
  %may_skip240 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %472, i32 0, i32 2
  store i8 0, ptr %may_skip240, align 8
  br label %do.body241

do.body241:                                       ; preds = %if.end239
  %473 = load ptr, ptr %h, align 8
  %skip242 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %473, i32 0, i32 1
  %474 = load ptr, ptr %skip242, align 8
  %cmp243 = icmp eq ptr %474, null
  %lnot244 = xor i1 %cmp243, true
  br i1 %lnot244, label %if.then245, label %if.end254

if.then245:                                       ; preds = %do.body241
  br label %do.body246

do.body246:                                       ; preds = %if.then245
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename247, align 8
  invoke void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 2264, ptr noundef @.str.1, ptr noundef @.str.23, ptr noundef @.str.22)
          to label %invoke.cont248 unwind label %lpad

invoke.cont248:                                   ; preds = %do.body246
  br label %do.body249

do.body249:                                       ; preds = %invoke.cont248
  unreachable

do.cond250:                                       ; No predecessors!
  br label %do.end251

do.end251:                                        ; preds = %do.cond250
  br label %do.cond252

do.cond252:                                       ; preds = %do.end251
  br label %do.end253

do.end253:                                        ; preds = %do.cond252
  br label %if.end254

if.end254:                                        ; preds = %do.end253, %do.body241
  br label %do.cond255

do.cond255:                                       ; preds = %if.end254
  br label %do.end256

do.end256:                                        ; preds = %do.cond255
  %475 = load ptr, ptr %h, align 8
  %maybe_unlocking257 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %475, i32 0, i32 5
  store i8 1, ptr %maybe_unlocking257, align 1
  %mu_258 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %476 = load i64, ptr %v, align 8
  store ptr %mu_258, ptr %this.addr.i657, align 8
  store i64 %476, ptr %__i.addr.i658, align 8
  store i32 3, ptr %__m.addr.i659, align 4
  %this1.i662 = load ptr, ptr %this.addr.i657, align 8
  %477 = load i32, ptr %__m.addr.i659, align 4
  %call.i663 = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %477, i32 noundef 65535)
  store i32 %call.i663, ptr %__b.i660, align 4
  %478 = load i32, ptr %__m.addr.i659, align 4
  %479 = load i64, ptr %__i.addr.i658, align 8
  store i64 %479, ptr %.atomictmp.i661, align 8
  switch i32 %478, label %monotonic.i666 [
    i32 3, label %release.i665
    i32 5, label %seqcst.i664
  ]

monotonic.i666:                                   ; preds = %do.end256
  %480 = load i64, ptr %.atomictmp.i661, align 8
  store atomic i64 %480, ptr %this1.i662 monotonic, align 8
  br label %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit667

release.i665:                                     ; preds = %do.end256
  %481 = load i64, ptr %.atomictmp.i661, align 8
  store atomic i64 %481, ptr %this1.i662 release, align 8
  br label %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit667

seqcst.i664:                                      ; preds = %do.end256
  %482 = load i64, ptr %.atomictmp.i661, align 8
  store atomic i64 %482, ptr %this1.i662 seq_cst, align 8
  br label %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit667

_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit667: ; preds = %seqcst.i664, %release.i665, %monotonic.i666
  %483 = load ptr, ptr %h, align 8
  store ptr %483, ptr %old_h, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end298, %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit667
  %484 = load ptr, ptr %pw_walk, align 8
  %485 = load ptr, ptr %h, align 8
  %cmp259 = icmp ne ptr %484, %485
  br i1 %cmp259, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %486 = load ptr, ptr %w_walk, align 8
  %wake260 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %486, i32 0, i32 3
  store i8 0, ptr %wake260, align 1
  %487 = load ptr, ptr %w_walk, align 8
  %waitp261 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %487, i32 0, i32 9
  %488 = load ptr, ptr %waitp261, align 8
  %cond262 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %488, i32 0, i32 1
  %489 = load ptr, ptr %cond262, align 8
  %cmp263 = icmp eq ptr %489, null
  br i1 %cmp263, label %if.then269, label %lor.lhs.false264

lor.lhs.false264:                                 ; preds = %while.body
  %490 = load ptr, ptr %w_walk, align 8
  %waitp265 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %490, i32 0, i32 9
  %491 = load ptr, ptr %waitp265, align 8
  %cond266 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %491, i32 0, i32 1
  %492 = load ptr, ptr %cond266, align 8
  %call268 = invoke noundef zeroext i1 @_ZN4abslL20EvalConditionIgnoredEPNS_5MutexEPKNS_9ConditionE(ptr noundef %this1, ptr noundef %492)
          to label %invoke.cont267 unwind label %lpad

invoke.cont267:                                   ; preds = %lor.lhs.false264
  br i1 %call268, label %if.then269, label %if.end287

if.then269:                                       ; preds = %invoke.cont267, %while.body
  %493 = load ptr, ptr %w, align 8
  %cmp270 = icmp eq ptr %493, null
  br i1 %cmp270, label %if.then271, label %if.else278

if.then271:                                       ; preds = %if.then269
  %494 = load ptr, ptr %w_walk, align 8
  %wake272 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %494, i32 0, i32 3
  store i8 1, ptr %wake272, align 1
  %495 = load ptr, ptr %w_walk, align 8
  store ptr %495, ptr %w, align 8
  %496 = load ptr, ptr %pw_walk, align 8
  store ptr %496, ptr %pw, align 8
  %497 = load ptr, ptr %w_walk, align 8
  %waitp273 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %497, i32 0, i32 9
  %498 = load ptr, ptr %waitp273, align 8
  %how274 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %498, i32 0, i32 0
  %499 = load ptr, ptr %how274, align 8
  %cmp275 = icmp eq ptr %499, @_ZN4abslL11kExclusiveSE
  br i1 %cmp275, label %if.then276, label %if.end277

if.then276:                                       ; preds = %if.then271
  store i64 32, ptr %wr_wait, align 8
  br label %while.end

if.end277:                                        ; preds = %if.then271
  br label %if.end286

if.else278:                                       ; preds = %if.then269
  %500 = load ptr, ptr %w_walk, align 8
  %waitp279 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %500, i32 0, i32 9
  %501 = load ptr, ptr %waitp279, align 8
  %how280 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %501, i32 0, i32 0
  %502 = load ptr, ptr %how280, align 8
  %cmp281 = icmp eq ptr %502, @_ZN4abslL8kSharedSE
  br i1 %cmp281, label %if.then282, label %if.else284

if.then282:                                       ; preds = %if.else278
  %503 = load ptr, ptr %w_walk, align 8
  %wake283 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %503, i32 0, i32 3
  store i8 1, ptr %wake283, align 1
  br label %if.end285

if.else284:                                       ; preds = %if.else278
  store i64 32, ptr %wr_wait, align 8
  br label %if.end285

if.end285:                                        ; preds = %if.else284, %if.then282
  br label %if.end286

if.end286:                                        ; preds = %if.end285, %if.end277
  br label %if.end287

if.end287:                                        ; preds = %if.end286, %invoke.cont267
  %504 = load ptr, ptr %w_walk, align 8
  %wake288 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %504, i32 0, i32 3
  %505 = load i8, ptr %wake288, align 1
  %tobool289 = trunc i8 %505 to i1
  br i1 %tobool289, label %if.then290, label %if.else291

if.then290:                                       ; preds = %if.end287
  %506 = load ptr, ptr %w_walk, align 8
  store ptr %506, ptr %pw_walk, align 8
  br label %if.end294

if.else291:                                       ; preds = %if.end287
  %507 = load ptr, ptr %w_walk, align 8
  %call293 = invoke noundef ptr @_ZN4abslL4SkipEPNS_13base_internal14PerThreadSynchE(ptr noundef %507)
          to label %invoke.cont292 unwind label %lpad

invoke.cont292:                                   ; preds = %if.else291
  store ptr %call293, ptr %pw_walk, align 8
  br label %if.end294

if.end294:                                        ; preds = %invoke.cont292, %if.then290
  %508 = load ptr, ptr %pw_walk, align 8
  %509 = load ptr, ptr %h, align 8
  %cmp295 = icmp ne ptr %508, %509
  br i1 %cmp295, label %if.then296, label %if.end298

if.then296:                                       ; preds = %if.end294
  %510 = load ptr, ptr %pw_walk, align 8
  %next297 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %510, i32 0, i32 0
  %511 = load ptr, ptr %next297, align 8
  store ptr %511, ptr %w_walk, align 8
  br label %if.end298

if.end298:                                        ; preds = %if.then296, %if.end294
  br label %while.cond, !llvm.loop !16

while.end:                                        ; preds = %if.then276, %while.cond
  br label %for.cond, !llvm.loop !17

if.end299:                                        ; preds = %if.end212
  br label %if.end300

if.end300:                                        ; preds = %if.end299, %if.then199
  br label %do.body301

do.body301:                                       ; preds = %if.end300
  %512 = load ptr, ptr %pw, align 8
  %next302 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %512, i32 0, i32 0
  %513 = load ptr, ptr %next302, align 8
  %514 = load ptr, ptr %w, align 8
  %cmp303 = icmp eq ptr %513, %514
  %lnot304 = xor i1 %cmp303, true
  br i1 %lnot304, label %if.then305, label %if.end314

if.then305:                                       ; preds = %do.body301
  br label %do.body306

do.body306:                                       ; preds = %if.then305
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename307, align 8
  invoke void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 2321, ptr noundef @.str.1, ptr noundef @.str.24, ptr noundef @.str.25)
          to label %invoke.cont308 unwind label %lpad

invoke.cont308:                                   ; preds = %do.body306
  br label %do.body309

do.body309:                                       ; preds = %invoke.cont308
  unreachable

do.cond310:                                       ; No predecessors!
  br label %do.end311

do.end311:                                        ; preds = %do.cond310
  br label %do.cond312

do.cond312:                                       ; preds = %do.end311
  br label %do.end313

do.end313:                                        ; preds = %do.cond312
  br label %if.end314

if.end314:                                        ; preds = %do.end313, %do.body301
  br label %do.cond315

do.cond315:                                       ; preds = %if.end314
  br label %do.end316

do.end316:                                        ; preds = %do.cond315
  %515 = load ptr, ptr %h, align 8
  %516 = load ptr, ptr %pw, align 8
  %call318 = invoke noundef ptr @_ZN4abslL18DequeueAllWakeableEPNS_13base_internal14PerThreadSynchES2_PS2_(ptr noundef %515, ptr noundef %516, ptr noundef %wake_list)
          to label %invoke.cont317 unwind label %lpad

invoke.cont317:                                   ; preds = %do.end316
  store ptr %call318, ptr %h, align 8
  %517 = load i64, ptr %v, align 8
  %and320 = and i64 %517, 16
  %or321 = or i64 %and320, 2
  store i64 %or321, ptr %nv319, align 8
  %518 = load ptr, ptr %waitp.addr, align 8
  %cmp322 = icmp ne ptr %518, null
  br i1 %cmp322, label %if.then323, label %if.end326

if.then323:                                       ; preds = %invoke.cont317
  %519 = load ptr, ptr %h, align 8
  %520 = load ptr, ptr %waitp.addr, align 8
  %521 = load i64, ptr %v, align 8
  %call325 = invoke noundef ptr @_ZN4abslL7EnqueueEPNS_13base_internal14PerThreadSynchEPNS_15SynchWaitParamsEli(ptr noundef %519, ptr noundef %520, i64 noundef %521, i32 noundef 2)
          to label %invoke.cont324 unwind label %lpad

invoke.cont324:                                   ; preds = %if.then323
  store ptr %call325, ptr %h, align 8
  br label %if.end326

if.end326:                                        ; preds = %invoke.cont324, %invoke.cont317
  br label %do.body327

do.body327:                                       ; preds = %if.end326
  %522 = load ptr, ptr %wake_list, align 8
  %cmp328 = icmp ne ptr %522, inttoptr (i64 1 to ptr)
  %lnot329 = xor i1 %cmp328, true
  br i1 %lnot329, label %if.then330, label %if.end339

if.then330:                                       ; preds = %do.body327
  br label %do.body331

do.body331:                                       ; preds = %if.then330
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename332, align 8
  invoke void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 2344, ptr noundef @.str.1, ptr noundef @.str.26, ptr noundef @.str.27)
          to label %invoke.cont333 unwind label %lpad

invoke.cont333:                                   ; preds = %do.body331
  br label %do.body334

do.body334:                                       ; preds = %invoke.cont333
  unreachable

do.cond335:                                       ; No predecessors!
  br label %do.end336

do.end336:                                        ; preds = %do.cond335
  br label %do.cond337

do.cond337:                                       ; preds = %do.end336
  br label %do.end338

do.end338:                                        ; preds = %do.cond337
  br label %if.end339

if.end339:                                        ; preds = %do.end338, %do.body327
  br label %do.cond340

do.cond340:                                       ; preds = %if.end339
  br label %do.end341

do.end341:                                        ; preds = %do.cond340
  %523 = load ptr, ptr %h, align 8
  %cmp342 = icmp ne ptr %523, null
  br i1 %cmp342, label %if.then343, label %if.end349

if.then343:                                       ; preds = %do.end341
  %524 = load ptr, ptr %h, align 8
  %readers344 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %524, i32 0, i32 10
  store i64 0, ptr %readers344, align 8
  %525 = load ptr, ptr %h, align 8
  %maybe_unlocking345 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %525, i32 0, i32 5
  store i8 0, ptr %maybe_unlocking345, align 1
  %526 = load i64, ptr %wr_wait, align 8
  %or346 = or i64 %526, 4
  %527 = load ptr, ptr %h, align 8
  %528 = ptrtoint ptr %527 to i64
  %or347 = or i64 %or346, %528
  %529 = load i64, ptr %nv319, align 8
  %or348 = or i64 %529, %or347
  store i64 %or348, ptr %nv319, align 8
  br label %if.end349

if.end349:                                        ; preds = %if.then343, %do.end341
  %mu_350 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %530 = load i64, ptr %nv319, align 8
  store ptr %mu_350, ptr %this.addr.i648, align 8
  store i64 %530, ptr %__i.addr.i, align 8
  store i32 3, ptr %__m.addr.i649, align 4
  %this1.i652 = load ptr, ptr %this.addr.i648, align 8
  %531 = load i32, ptr %__m.addr.i649, align 4
  %call.i653 = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %531, i32 noundef 65535)
  store i32 %call.i653, ptr %__b.i650, align 4
  %532 = load i32, ptr %__m.addr.i649, align 4
  %533 = load i64, ptr %__i.addr.i, align 8
  store i64 %533, ptr %.atomictmp.i651, align 8
  switch i32 %532, label %monotonic.i656 [
    i32 3, label %release.i655
    i32 5, label %seqcst.i654
  ]

monotonic.i656:                                   ; preds = %if.end349
  %534 = load i64, ptr %.atomictmp.i651, align 8
  store atomic i64 %534, ptr %this1.i652 monotonic, align 8
  br label %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit

release.i655:                                     ; preds = %if.end349
  %535 = load i64, ptr %.atomictmp.i651, align 8
  store atomic i64 %535, ptr %this1.i652 release, align 8
  br label %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit

seqcst.i654:                                      ; preds = %if.end349
  %536 = load i64, ptr %.atomictmp.i651, align 8
  store atomic i64 %536, ptr %this1.i652 seq_cst, align 8
  br label %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit

_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit: ; preds = %seqcst.i654, %release.i655, %monotonic.i656
  br label %for.end

if.end351:                                        ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit, %if.else45
  br label %if.end352

if.end352:                                        ; preds = %if.end351, %if.end44
  br label %if.end353

if.end353:                                        ; preds = %if.end352, %if.end32
  %537 = load i32, ptr %c, align 4
  %call355 = invoke noundef i32 @_ZN4absl24synchronization_internal10MutexDelayEii(i32 noundef %537, i32 noundef 0)
          to label %invoke.cont354 unwind label %lpad

invoke.cont354:                                   ; preds = %if.end353
  store i32 %call355, ptr %c, align 4
  br label %for.cond, !llvm.loop !17

for.end:                                          ; preds = %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit, %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit678, %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit689, %do.end105
  %538 = load ptr, ptr %wake_list, align 8
  %cmp356 = icmp ne ptr %538, inttoptr (i64 1 to ptr)
  br i1 %cmp356, label %if.then357, label %if.end382

if.then357:                                       ; preds = %for.end
  store i64 0, ptr %total_wait_cycles, align 8
  store i64 0, ptr %max_wait_cycles, align 8
  %call359 = invoke noundef i64 @_ZN4absl13base_internal10CycleClock3NowEv()
          to label %invoke.cont358 unwind label %lpad

invoke.cont358:                                   ; preds = %if.then357
  store i64 %call359, ptr %now, align 8
  br label %do.body360

do.body360:                                       ; preds = %do.cond374, %invoke.cont358
  %539 = load ptr, ptr %wake_list, align 8
  %cond_waiter = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %539, i32 0, i32 4
  %540 = load i8, ptr %cond_waiter, align 2
  %tobool361 = trunc i8 %540 to i1
  br i1 %tobool361, label %if.end371, label %if.then362

if.then362:                                       ; preds = %do.body360
  %541 = load i64, ptr %now, align 8
  %542 = load ptr, ptr %wake_list, align 8
  %waitp363 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %542, i32 0, i32 9
  %543 = load ptr, ptr %waitp363, align 8
  %contention_start_cycles = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %543, i32 0, i32 6
  %544 = load i64, ptr %contention_start_cycles, align 8
  %sub364 = sub nsw i64 %541, %544
  store i64 %sub364, ptr %cycles_waited, align 8
  %545 = load i64, ptr %cycles_waited, align 8
  %546 = load i64, ptr %total_wait_cycles, align 8
  %add = add nsw i64 %546, %545
  store i64 %add, ptr %total_wait_cycles, align 8
  %547 = load i64, ptr %max_wait_cycles, align 8
  %cmp365 = icmp eq i64 %547, 0
  br i1 %cmp365, label %if.then366, label %if.end367

if.then366:                                       ; preds = %if.then362
  %548 = load i64, ptr %cycles_waited, align 8
  store i64 %548, ptr %max_wait_cycles, align 8
  br label %if.end367

if.end367:                                        ; preds = %if.then366, %if.then362
  %549 = load i64, ptr %now, align 8
  %550 = load ptr, ptr %wake_list, align 8
  %waitp368 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %550, i32 0, i32 9
  %551 = load ptr, ptr %waitp368, align 8
  %contention_start_cycles369 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %551, i32 0, i32 6
  store i64 %549, ptr %contention_start_cycles369, align 8
  %552 = load ptr, ptr %wake_list, align 8
  %waitp370 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %552, i32 0, i32 9
  %553 = load ptr, ptr %waitp370, align 8
  %should_submit_contention_data = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %553, i32 0, i32 7
  store i8 1, ptr %should_submit_contention_data, align 8
  br label %if.end371

if.end371:                                        ; preds = %if.end367, %do.body360
  %554 = load ptr, ptr %wake_list, align 8
  %call373 = invoke noundef ptr @_ZN4absl5Mutex6WakeupEPNS_13base_internal14PerThreadSynchE(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef %554)
          to label %invoke.cont372 unwind label %lpad

invoke.cont372:                                   ; preds = %if.end371
  store ptr %call373, ptr %wake_list, align 8
  br label %do.cond374

do.cond374:                                       ; preds = %invoke.cont372
  %555 = load ptr, ptr %wake_list, align 8
  %cmp375 = icmp ne ptr %555, inttoptr (i64 1 to ptr)
  br i1 %cmp375, label %do.body360, label %do.end376, !llvm.loop !18

do.end376:                                        ; preds = %do.cond374
  %556 = load i64, ptr %total_wait_cycles, align 8
  %cmp377 = icmp sgt i64 %556, 0
  br i1 %cmp377, label %if.then378, label %if.end381

if.then378:                                       ; preds = %do.end376
  store ptr %this1, ptr %ref.tmp, align 8
  invoke void @_ZNK4absl13base_internal10AtomicHookIPFvPKcPKvlEEclIJRA13_S2_PNS_5MutexERlEEEvDpOT_(ptr noundef nonnull align 8 dereferenceable(16) @_ZN4absl12_GLOBAL__N_112mutex_tracerE, ptr noundef nonnull align 1 dereferenceable(13) @.str.28, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp, ptr noundef nonnull align 8 dereferenceable(8) %total_wait_cycles)
          to label %invoke.cont379 unwind label %lpad

invoke.cont379:                                   ; preds = %if.then378
  invoke void @_ZNK4absl13base_internal10AtomicHookIPFvlEEclIJRlEEEvDpOT_(ptr noundef nonnull align 8 dereferenceable(16) @_ZN4absl12_GLOBAL__N_119submit_profile_dataE, ptr noundef nonnull align 8 dereferenceable(8) %total_wait_cycles)
          to label %invoke.cont380 unwind label %lpad

invoke.cont380:                                   ; preds = %invoke.cont379
  br label %if.end381

if.end381:                                        ; preds = %invoke.cont380, %do.end376
  br label %if.end382

if.end382:                                        ; preds = %if.end381, %for.end
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end382, %if.then43, %if.then31
  call void @_ZN4absl13base_internal15SchedulingGuard13ScopedDisableD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %disable_rescheduling) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup, %cleanup
  ret void

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val383 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val383

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN4absl5Mutex12LockSlowLoopEPNS_15SynchWaitParamsEi(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %waitp, i32 noundef %flags) #0 align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr.i604 = alloca ptr, align 8
  %__i1.addr.i605 = alloca ptr, align 8
  %__i2.addr.i606 = alloca i64, align 8
  %__m1.addr.i607 = alloca i32, align 4
  %__m2.addr.i608 = alloca i32, align 4
  %.atomictmp.i609 = alloca i64, align 8
  %cmpxchg.bool.i610 = alloca i8, align 1
  %this.addr.i525 = alloca ptr, align 8
  %__i1.addr.i526 = alloca ptr, align 8
  %__i2.addr.i527 = alloca i64, align 8
  %__m1.addr.i528 = alloca i32, align 4
  %__m2.addr.i529 = alloca i32, align 4
  %.atomictmp.i530 = alloca i64, align 8
  %cmpxchg.bool.i531 = alloca i8, align 1
  %this.addr.i445 = alloca ptr, align 8
  %__i1.addr.i446 = alloca ptr, align 8
  %__i2.addr.i447 = alloca i64, align 8
  %__m1.addr.i448 = alloca i32, align 4
  %__m2.addr.i449 = alloca i32, align 4
  %.atomictmp.i450 = alloca i64, align 8
  %cmpxchg.bool.i451 = alloca i8, align 1
  %this.addr.i365 = alloca ptr, align 8
  %__i1.addr.i366 = alloca ptr, align 8
  %__i2.addr.i367 = alloca i64, align 8
  %__m1.addr.i368 = alloca i32, align 4
  %__m2.addr.i369 = alloca i32, align 4
  %.atomictmp.i370 = alloca i64, align 8
  %cmpxchg.bool.i371 = alloca i8, align 1
  %this.addr.i285 = alloca ptr, align 8
  %__i1.addr.i286 = alloca ptr, align 8
  %__i2.addr.i287 = alloca i64, align 8
  %__m1.addr.i288 = alloca i32, align 4
  %__m2.addr.i289 = alloca i32, align 4
  %.atomictmp.i290 = alloca i64, align 8
  %cmpxchg.bool.i291 = alloca i8, align 1
  %this.addr.i280 = alloca ptr, align 8
  %__i1.addr.i = alloca ptr, align 8
  %__i2.addr.i = alloca i64, align 8
  %__m1.addr.i = alloca i32, align 4
  %__m2.addr.i = alloca i32, align 4
  %.atomictmp.i = alloca i64, align 8
  %cmpxchg.bool.i = alloca i8, align 1
  %this.addr.i270 = alloca ptr, align 8
  %__m.addr.i271 = alloca i32, align 4
  %__b.i272 = alloca i32, align 4
  %atomic-temp.i273 = alloca i64, align 8
  %this.addr.i260 = alloca ptr, align 8
  %__m.addr.i261 = alloca i32, align 4
  %__b.i262 = alloca i32, align 4
  %atomic-temp.i263 = alloca i64, align 8
  %this.addr.i250 = alloca ptr, align 8
  %__m.addr.i251 = alloca i32, align 4
  %__b.i252 = alloca i32, align 4
  %atomic-temp.i253 = alloca i64, align 8
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i64, align 8
  %this.addr = alloca ptr, align 8
  %waitp.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %disable_rescheduling = alloca %"struct.absl::base_internal::SchedulingGuard::ScopedDisable", align 1
  %c = alloca i32, align 4
  %v = alloca i64, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %absl_raw_log_internal_basename = alloca ptr, align 8
  %dowait = alloca i8, align 1
  %new_h = alloca ptr, align 8
  %nv = alloca i64, align 8
  %absl_raw_log_internal_basename61 = alloca ptr, align 8
  %h = alloca ptr, align 8
  %h145 = alloca ptr, align 8
  %new_h148 = alloca ptr, align 8
  %wr_wait = alloca i64, align 8
  %absl_raw_log_internal_basename156 = alloca ptr, align 8
  %absl_raw_log_internal_basename207 = alloca ptr, align 8
  %absl_raw_log_internal_basename231 = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %waitp, ptr %waitp.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4absl13base_internal15SchedulingGuard13ScopedDisableC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %disable_rescheduling)
  store i32 0, ptr %c, align 4
  %mu_ = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  store ptr %mu_, ptr %this.addr.i270, align 8
  store i32 0, ptr %__m.addr.i271, align 4
  %this1.i274 = load ptr, ptr %this.addr.i270, align 8
  %0 = load i32, ptr %__m.addr.i271, align 4
  %call.i275 = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %0, i32 noundef 65535)
  store i32 %call.i275, ptr %__b.i272, align 4
  %1 = load i32, ptr %__m.addr.i271, align 4
  switch i32 %1, label %monotonic.i278 [
    i32 1, label %acquire.i277
    i32 2, label %acquire.i277
    i32 5, label %seqcst.i276
  ]

monotonic.i278:                                   ; preds = %entry
  %2 = load atomic i64, ptr %this1.i274 monotonic, align 8
  store i64 %2, ptr %atomic-temp.i273, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit279

acquire.i277:                                     ; preds = %entry, %entry
  %3 = load atomic i64, ptr %this1.i274 acquire, align 8
  store i64 %3, ptr %atomic-temp.i273, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit279

seqcst.i276:                                      ; preds = %entry
  %4 = load atomic i64, ptr %this1.i274 seq_cst, align 8
  store i64 %4, ptr %atomic-temp.i273, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit279

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit279: ; preds = %seqcst.i276, %acquire.i277, %monotonic.i278
  %5 = load i64, ptr %atomic-temp.i273, align 8
  store i64 %5, ptr %v, align 8
  %6 = load i64, ptr %v, align 8
  %and = and i64 %6, 16
  %cmp = icmp ne i64 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit279
  %7 = load ptr, ptr %waitp.addr, align 8
  %how = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %7, i32 0, i32 0
  %8 = load ptr, ptr %how, align 8
  %cmp2 = icmp eq ptr %8, @_ZN4abslL11kExclusiveSE
  %cond = select i1 %cmp2, i32 4, i32 6
  invoke void @_ZN4abslL14PostSynchEventEPvi(ptr noundef %this1, i32 noundef %cond)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

lpad:                                             ; preds = %if.then243, %do.body230, %do.end216, %do.body206, %if.then189, %do.body155, %invoke.cont146, %if.then144, %land.lhs.true135, %invoke.cont127, %if.end126, %lor.lhs.false119, %if.then103, %if.then94, %if.else86, %do.body60, %invoke.cont48, %if.then47, %invoke.cont40, %if.end39, %lor.lhs.false, %if.then21, %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit269, %do.body7, %if.then
  %9 = landingpad { ptr, i32 }
          cleanup
  %10 = extractvalue { ptr, i32 } %9, 0
  store ptr %10, ptr %exn.slot, align 8
  %11 = extractvalue { ptr, i32 } %9, 1
  store i32 %11, ptr %ehselector.slot, align 4
  call void @_ZN4absl13base_internal15SchedulingGuard13ScopedDisableD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %disable_rescheduling) #13
  br label %eh.resume

if.end:                                           ; preds = %invoke.cont, %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit279
  br label %do.body

do.body:                                          ; preds = %if.end
  %12 = load ptr, ptr %waitp.addr, align 8
  %thread = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %12, i32 0, i32 4
  %13 = load ptr, ptr %thread, align 8
  %waitp3 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %13, i32 0, i32 9
  %14 = load ptr, ptr %waitp3, align 8
  %cmp4 = icmp eq ptr %14, null
  br i1 %cmp4, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %do.body
  %15 = load ptr, ptr %waitp.addr, align 8
  %thread5 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %15, i32 0, i32 4
  %16 = load ptr, ptr %thread5, align 8
  %suppress_fatal_errors = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %16, i32 0, i32 6
  %17 = load i8, ptr %suppress_fatal_errors, align 4
  %tobool = trunc i8 %17 to i1
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %do.body
  %18 = phi i1 [ true, %do.body ], [ %tobool, %lor.rhs ]
  %lnot = xor i1 %18, true
  br i1 %lnot, label %if.then6, label %if.end12

if.then6:                                         ; preds = %lor.end
  br label %do.body7

do.body7:                                         ; preds = %if.then6
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename, align 8
  invoke void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 1970, ptr noundef @.str.1, ptr noundef @.str.8, ptr noundef @.str.9)
          to label %invoke.cont8 unwind label %lpad

invoke.cont8:                                     ; preds = %do.body7
  br label %do.body9

do.body9:                                         ; preds = %invoke.cont8
  unreachable

do.cond:                                          ; No predecessors!
  br label %do.end

do.end:                                           ; preds = %do.cond
  br label %do.cond10

do.cond10:                                        ; preds = %do.end
  br label %do.end11

do.end11:                                         ; preds = %do.cond10
  br label %if.end12

if.end12:                                         ; preds = %do.end11, %lor.end
  br label %do.cond13

do.cond13:                                        ; preds = %if.end12
  br label %do.end14

do.end14:                                         ; preds = %do.cond13
  br label %for.cond

for.cond:                                         ; preds = %invoke.cont217, %do.end14
  %mu_15 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  store ptr %mu_15, ptr %this.addr.i260, align 8
  store i32 0, ptr %__m.addr.i261, align 4
  %this1.i264 = load ptr, ptr %this.addr.i260, align 8
  %19 = load i32, ptr %__m.addr.i261, align 4
  %call.i265 = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %19, i32 noundef 65535)
  store i32 %call.i265, ptr %__b.i262, align 4
  %20 = load i32, ptr %__m.addr.i261, align 4
  switch i32 %20, label %monotonic.i268 [
    i32 1, label %acquire.i267
    i32 2, label %acquire.i267
    i32 5, label %seqcst.i266
  ]

monotonic.i268:                                   ; preds = %for.cond
  %21 = load atomic i64, ptr %this1.i264 monotonic, align 8
  store i64 %21, ptr %atomic-temp.i263, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit269

acquire.i267:                                     ; preds = %for.cond, %for.cond
  %22 = load atomic i64, ptr %this1.i264 acquire, align 8
  store i64 %22, ptr %atomic-temp.i263, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit269

seqcst.i266:                                      ; preds = %for.cond
  %23 = load atomic i64, ptr %this1.i264 seq_cst, align 8
  store i64 %23, ptr %atomic-temp.i263, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit269

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit269: ; preds = %seqcst.i266, %acquire.i267, %monotonic.i268
  %24 = load i64, ptr %atomic-temp.i263, align 8
  store i64 %24, ptr %v, align 8
  %25 = load i64, ptr %v, align 8
  invoke void @_ZN4abslL23CheckForMutexCorruptionElPKc(i64 noundef %25, ptr noundef @.str.10)
          to label %invoke.cont17 unwind label %lpad

invoke.cont17:                                    ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit269
  %26 = load i64, ptr %v, align 8
  %27 = load ptr, ptr %waitp.addr, align 8
  %how18 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %27, i32 0, i32 0
  %28 = load ptr, ptr %how18, align 8
  %slow_need_zero = getelementptr inbounds %"struct.absl::MuHowS", ptr %28, i32 0, i32 3
  %29 = load i64, ptr %slow_need_zero, align 8
  %and19 = and i64 %26, %29
  %cmp20 = icmp eq i64 %and19, 0
  br i1 %cmp20, label %if.then21, label %if.else

if.then21:                                        ; preds = %invoke.cont17
  %mu_22 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %30 = load ptr, ptr %waitp.addr, align 8
  %how23 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %30, i32 0, i32 0
  %31 = load ptr, ptr %how23, align 8
  %fast_or = getelementptr inbounds %"struct.absl::MuHowS", ptr %31, i32 0, i32 1
  %32 = load i64, ptr %fast_or, align 8
  %33 = load i64, ptr %v, align 8
  %34 = load i32, ptr %flags.addr, align 4
  %and24 = and i32 %34, 1
  %call26 = invoke noundef i64 @_ZN4abslL24ClearDesignatedWakerMaskEi(i32 noundef %and24)
          to label %invoke.cont25 unwind label %lpad

invoke.cont25:                                    ; preds = %if.then21
  %and27 = and i64 %33, %call26
  %or = or i64 %32, %and27
  %35 = load ptr, ptr %waitp.addr, align 8
  %how28 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %35, i32 0, i32 0
  %36 = load ptr, ptr %how28, align 8
  %fast_add = getelementptr inbounds %"struct.absl::MuHowS", ptr %36, i32 0, i32 2
  %37 = load i64, ptr %fast_add, align 8
  %add = add nsw i64 %or, %37
  store ptr %mu_22, ptr %this.addr.i445, align 8
  store ptr %v, ptr %__i1.addr.i446, align 8
  store i64 %add, ptr %__i2.addr.i447, align 8
  store i32 2, ptr %__m1.addr.i448, align 4
  store i32 0, ptr %__m2.addr.i449, align 4
  %this1.i452 = load ptr, ptr %this.addr.i445, align 8
  %38 = load i32, ptr %__m1.addr.i448, align 4
  %39 = load ptr, ptr %__i1.addr.i446, align 8
  %40 = load i64, ptr %__i2.addr.i447, align 8
  store i64 %40, ptr %.atomictmp.i450, align 8
  %41 = load i32, ptr %__m2.addr.i449, align 4
  switch i32 %38, label %monotonic.i510 [
    i32 1, label %acquire.i496
    i32 2, label %acquire.i496
    i32 3, label %release.i482
    i32 4, label %acqrel.i468
    i32 5, label %seqcst.i453
  ]

monotonic.i510:                                   ; preds = %invoke.cont25
  switch i32 %41, label %monotonic_fail.i520 [
    i32 1, label %acquire_fail.i516
    i32 2, label %acquire_fail.i516
    i32 5, label %seqcst_fail.i511
  ]

acquire.i496:                                     ; preds = %invoke.cont25, %invoke.cont25
  switch i32 %41, label %monotonic_fail9.i506 [
    i32 1, label %acquire_fail10.i502
    i32 2, label %acquire_fail10.i502
    i32 5, label %seqcst_fail11.i497
  ]

release.i482:                                     ; preds = %invoke.cont25
  switch i32 %41, label %monotonic_fail22.i492 [
    i32 1, label %acquire_fail23.i488
    i32 2, label %acquire_fail23.i488
    i32 5, label %seqcst_fail24.i483
  ]

acqrel.i468:                                      ; preds = %invoke.cont25
  switch i32 %41, label %monotonic_fail35.i478 [
    i32 1, label %acquire_fail36.i474
    i32 2, label %acquire_fail36.i474
    i32 5, label %seqcst_fail37.i469
  ]

seqcst.i453:                                      ; preds = %invoke.cont25
  switch i32 %41, label %monotonic_fail48.i464 [
    i32 1, label %acquire_fail49.i460
    i32 2, label %acquire_fail49.i460
    i32 5, label %seqcst_fail50.i454
  ]

monotonic_fail.i520:                              ; preds = %monotonic.i510
  %42 = load i64, ptr %39, align 8
  %43 = load i64, ptr %.atomictmp.i450, align 8
  %44 = cmpxchg ptr %this1.i452, i64 %42, i64 %43 monotonic monotonic, align 8
  %45 = extractvalue { i64, i1 } %44, 0
  %46 = extractvalue { i64, i1 } %44, 1
  br i1 %46, label %cmpxchg.continue.i522, label %cmpxchg.store_expected.i521

acquire_fail.i516:                                ; preds = %monotonic.i510, %monotonic.i510
  %47 = load i64, ptr %39, align 8
  %48 = load i64, ptr %.atomictmp.i450, align 8
  %49 = cmpxchg ptr %this1.i452, i64 %47, i64 %48 monotonic acquire, align 8
  %50 = extractvalue { i64, i1 } %49, 0
  %51 = extractvalue { i64, i1 } %49, 1
  br i1 %51, label %cmpxchg.continue4.i518, label %cmpxchg.store_expected3.i517

seqcst_fail.i511:                                 ; preds = %monotonic.i510
  %52 = load i64, ptr %39, align 8
  %53 = load i64, ptr %.atomictmp.i450, align 8
  %54 = cmpxchg ptr %this1.i452, i64 %52, i64 %53 monotonic seq_cst, align 8
  %55 = extractvalue { i64, i1 } %54, 0
  %56 = extractvalue { i64, i1 } %54, 1
  br i1 %56, label %cmpxchg.continue7.i513, label %cmpxchg.store_expected6.i512

atomic.continue2.i515:                            ; preds = %cmpxchg.continue7.i513, %cmpxchg.continue4.i518, %cmpxchg.continue.i522
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit524

cmpxchg.store_expected.i521:                      ; preds = %monotonic_fail.i520
  store i64 %45, ptr %39, align 8
  br label %cmpxchg.continue.i522

cmpxchg.continue.i522:                            ; preds = %cmpxchg.store_expected.i521, %monotonic_fail.i520
  %frombool.i523 = zext i1 %46 to i8
  store i8 %frombool.i523, ptr %cmpxchg.bool.i451, align 1
  br label %atomic.continue2.i515

cmpxchg.store_expected3.i517:                     ; preds = %acquire_fail.i516
  store i64 %50, ptr %39, align 8
  br label %cmpxchg.continue4.i518

cmpxchg.continue4.i518:                           ; preds = %cmpxchg.store_expected3.i517, %acquire_fail.i516
  %frombool5.i519 = zext i1 %51 to i8
  store i8 %frombool5.i519, ptr %cmpxchg.bool.i451, align 1
  br label %atomic.continue2.i515

cmpxchg.store_expected6.i512:                     ; preds = %seqcst_fail.i511
  store i64 %55, ptr %39, align 8
  br label %cmpxchg.continue7.i513

cmpxchg.continue7.i513:                           ; preds = %cmpxchg.store_expected6.i512, %seqcst_fail.i511
  %frombool8.i514 = zext i1 %56 to i8
  store i8 %frombool8.i514, ptr %cmpxchg.bool.i451, align 1
  br label %atomic.continue2.i515

monotonic_fail9.i506:                             ; preds = %acquire.i496
  %57 = load i64, ptr %39, align 8
  %58 = load i64, ptr %.atomictmp.i450, align 8
  %59 = cmpxchg ptr %this1.i452, i64 %57, i64 %58 acquire monotonic, align 8
  %60 = extractvalue { i64, i1 } %59, 0
  %61 = extractvalue { i64, i1 } %59, 1
  br i1 %61, label %cmpxchg.continue14.i508, label %cmpxchg.store_expected13.i507

acquire_fail10.i502:                              ; preds = %acquire.i496, %acquire.i496
  %62 = load i64, ptr %39, align 8
  %63 = load i64, ptr %.atomictmp.i450, align 8
  %64 = cmpxchg ptr %this1.i452, i64 %62, i64 %63 acquire acquire, align 8
  %65 = extractvalue { i64, i1 } %64, 0
  %66 = extractvalue { i64, i1 } %64, 1
  br i1 %66, label %cmpxchg.continue17.i504, label %cmpxchg.store_expected16.i503

seqcst_fail11.i497:                               ; preds = %acquire.i496
  %67 = load i64, ptr %39, align 8
  %68 = load i64, ptr %.atomictmp.i450, align 8
  %69 = cmpxchg ptr %this1.i452, i64 %67, i64 %68 acquire seq_cst, align 8
  %70 = extractvalue { i64, i1 } %69, 0
  %71 = extractvalue { i64, i1 } %69, 1
  br i1 %71, label %cmpxchg.continue20.i499, label %cmpxchg.store_expected19.i498

atomic.continue12.i501:                           ; preds = %cmpxchg.continue20.i499, %cmpxchg.continue17.i504, %cmpxchg.continue14.i508
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit524

cmpxchg.store_expected13.i507:                    ; preds = %monotonic_fail9.i506
  store i64 %60, ptr %39, align 8
  br label %cmpxchg.continue14.i508

cmpxchg.continue14.i508:                          ; preds = %cmpxchg.store_expected13.i507, %monotonic_fail9.i506
  %frombool15.i509 = zext i1 %61 to i8
  store i8 %frombool15.i509, ptr %cmpxchg.bool.i451, align 1
  br label %atomic.continue12.i501

cmpxchg.store_expected16.i503:                    ; preds = %acquire_fail10.i502
  store i64 %65, ptr %39, align 8
  br label %cmpxchg.continue17.i504

cmpxchg.continue17.i504:                          ; preds = %cmpxchg.store_expected16.i503, %acquire_fail10.i502
  %frombool18.i505 = zext i1 %66 to i8
  store i8 %frombool18.i505, ptr %cmpxchg.bool.i451, align 1
  br label %atomic.continue12.i501

cmpxchg.store_expected19.i498:                    ; preds = %seqcst_fail11.i497
  store i64 %70, ptr %39, align 8
  br label %cmpxchg.continue20.i499

cmpxchg.continue20.i499:                          ; preds = %cmpxchg.store_expected19.i498, %seqcst_fail11.i497
  %frombool21.i500 = zext i1 %71 to i8
  store i8 %frombool21.i500, ptr %cmpxchg.bool.i451, align 1
  br label %atomic.continue12.i501

monotonic_fail22.i492:                            ; preds = %release.i482
  %72 = load i64, ptr %39, align 8
  %73 = load i64, ptr %.atomictmp.i450, align 8
  %74 = cmpxchg ptr %this1.i452, i64 %72, i64 %73 release monotonic, align 8
  %75 = extractvalue { i64, i1 } %74, 0
  %76 = extractvalue { i64, i1 } %74, 1
  br i1 %76, label %cmpxchg.continue27.i494, label %cmpxchg.store_expected26.i493

acquire_fail23.i488:                              ; preds = %release.i482, %release.i482
  %77 = load i64, ptr %39, align 8
  %78 = load i64, ptr %.atomictmp.i450, align 8
  %79 = cmpxchg ptr %this1.i452, i64 %77, i64 %78 release acquire, align 8
  %80 = extractvalue { i64, i1 } %79, 0
  %81 = extractvalue { i64, i1 } %79, 1
  br i1 %81, label %cmpxchg.continue30.i490, label %cmpxchg.store_expected29.i489

seqcst_fail24.i483:                               ; preds = %release.i482
  %82 = load i64, ptr %39, align 8
  %83 = load i64, ptr %.atomictmp.i450, align 8
  %84 = cmpxchg ptr %this1.i452, i64 %82, i64 %83 release seq_cst, align 8
  %85 = extractvalue { i64, i1 } %84, 0
  %86 = extractvalue { i64, i1 } %84, 1
  br i1 %86, label %cmpxchg.continue33.i485, label %cmpxchg.store_expected32.i484

atomic.continue25.i487:                           ; preds = %cmpxchg.continue33.i485, %cmpxchg.continue30.i490, %cmpxchg.continue27.i494
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit524

cmpxchg.store_expected26.i493:                    ; preds = %monotonic_fail22.i492
  store i64 %75, ptr %39, align 8
  br label %cmpxchg.continue27.i494

cmpxchg.continue27.i494:                          ; preds = %cmpxchg.store_expected26.i493, %monotonic_fail22.i492
  %frombool28.i495 = zext i1 %76 to i8
  store i8 %frombool28.i495, ptr %cmpxchg.bool.i451, align 1
  br label %atomic.continue25.i487

cmpxchg.store_expected29.i489:                    ; preds = %acquire_fail23.i488
  store i64 %80, ptr %39, align 8
  br label %cmpxchg.continue30.i490

cmpxchg.continue30.i490:                          ; preds = %cmpxchg.store_expected29.i489, %acquire_fail23.i488
  %frombool31.i491 = zext i1 %81 to i8
  store i8 %frombool31.i491, ptr %cmpxchg.bool.i451, align 1
  br label %atomic.continue25.i487

cmpxchg.store_expected32.i484:                    ; preds = %seqcst_fail24.i483
  store i64 %85, ptr %39, align 8
  br label %cmpxchg.continue33.i485

cmpxchg.continue33.i485:                          ; preds = %cmpxchg.store_expected32.i484, %seqcst_fail24.i483
  %frombool34.i486 = zext i1 %86 to i8
  store i8 %frombool34.i486, ptr %cmpxchg.bool.i451, align 1
  br label %atomic.continue25.i487

monotonic_fail35.i478:                            ; preds = %acqrel.i468
  %87 = load i64, ptr %39, align 8
  %88 = load i64, ptr %.atomictmp.i450, align 8
  %89 = cmpxchg ptr %this1.i452, i64 %87, i64 %88 acq_rel monotonic, align 8
  %90 = extractvalue { i64, i1 } %89, 0
  %91 = extractvalue { i64, i1 } %89, 1
  br i1 %91, label %cmpxchg.continue40.i480, label %cmpxchg.store_expected39.i479

acquire_fail36.i474:                              ; preds = %acqrel.i468, %acqrel.i468
  %92 = load i64, ptr %39, align 8
  %93 = load i64, ptr %.atomictmp.i450, align 8
  %94 = cmpxchg ptr %this1.i452, i64 %92, i64 %93 acq_rel acquire, align 8
  %95 = extractvalue { i64, i1 } %94, 0
  %96 = extractvalue { i64, i1 } %94, 1
  br i1 %96, label %cmpxchg.continue43.i476, label %cmpxchg.store_expected42.i475

seqcst_fail37.i469:                               ; preds = %acqrel.i468
  %97 = load i64, ptr %39, align 8
  %98 = load i64, ptr %.atomictmp.i450, align 8
  %99 = cmpxchg ptr %this1.i452, i64 %97, i64 %98 acq_rel seq_cst, align 8
  %100 = extractvalue { i64, i1 } %99, 0
  %101 = extractvalue { i64, i1 } %99, 1
  br i1 %101, label %cmpxchg.continue46.i471, label %cmpxchg.store_expected45.i470

atomic.continue38.i473:                           ; preds = %cmpxchg.continue46.i471, %cmpxchg.continue43.i476, %cmpxchg.continue40.i480
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit524

cmpxchg.store_expected39.i479:                    ; preds = %monotonic_fail35.i478
  store i64 %90, ptr %39, align 8
  br label %cmpxchg.continue40.i480

cmpxchg.continue40.i480:                          ; preds = %cmpxchg.store_expected39.i479, %monotonic_fail35.i478
  %frombool41.i481 = zext i1 %91 to i8
  store i8 %frombool41.i481, ptr %cmpxchg.bool.i451, align 1
  br label %atomic.continue38.i473

cmpxchg.store_expected42.i475:                    ; preds = %acquire_fail36.i474
  store i64 %95, ptr %39, align 8
  br label %cmpxchg.continue43.i476

cmpxchg.continue43.i476:                          ; preds = %cmpxchg.store_expected42.i475, %acquire_fail36.i474
  %frombool44.i477 = zext i1 %96 to i8
  store i8 %frombool44.i477, ptr %cmpxchg.bool.i451, align 1
  br label %atomic.continue38.i473

cmpxchg.store_expected45.i470:                    ; preds = %seqcst_fail37.i469
  store i64 %100, ptr %39, align 8
  br label %cmpxchg.continue46.i471

cmpxchg.continue46.i471:                          ; preds = %cmpxchg.store_expected45.i470, %seqcst_fail37.i469
  %frombool47.i472 = zext i1 %101 to i8
  store i8 %frombool47.i472, ptr %cmpxchg.bool.i451, align 1
  br label %atomic.continue38.i473

monotonic_fail48.i464:                            ; preds = %seqcst.i453
  %102 = load i64, ptr %39, align 8
  %103 = load i64, ptr %.atomictmp.i450, align 8
  %104 = cmpxchg ptr %this1.i452, i64 %102, i64 %103 seq_cst monotonic, align 8
  %105 = extractvalue { i64, i1 } %104, 0
  %106 = extractvalue { i64, i1 } %104, 1
  br i1 %106, label %cmpxchg.continue53.i466, label %cmpxchg.store_expected52.i465

acquire_fail49.i460:                              ; preds = %seqcst.i453, %seqcst.i453
  %107 = load i64, ptr %39, align 8
  %108 = load i64, ptr %.atomictmp.i450, align 8
  %109 = cmpxchg ptr %this1.i452, i64 %107, i64 %108 seq_cst acquire, align 8
  %110 = extractvalue { i64, i1 } %109, 0
  %111 = extractvalue { i64, i1 } %109, 1
  br i1 %111, label %cmpxchg.continue56.i462, label %cmpxchg.store_expected55.i461

seqcst_fail50.i454:                               ; preds = %seqcst.i453
  %112 = load i64, ptr %39, align 8
  %113 = load i64, ptr %.atomictmp.i450, align 8
  %114 = cmpxchg ptr %this1.i452, i64 %112, i64 %113 seq_cst seq_cst, align 8
  %115 = extractvalue { i64, i1 } %114, 0
  %116 = extractvalue { i64, i1 } %114, 1
  br i1 %116, label %cmpxchg.continue59.i456, label %cmpxchg.store_expected58.i455

atomic.continue51.i458:                           ; preds = %cmpxchg.continue59.i456, %cmpxchg.continue56.i462, %cmpxchg.continue53.i466
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit524

cmpxchg.store_expected52.i465:                    ; preds = %monotonic_fail48.i464
  store i64 %105, ptr %39, align 8
  br label %cmpxchg.continue53.i466

cmpxchg.continue53.i466:                          ; preds = %cmpxchg.store_expected52.i465, %monotonic_fail48.i464
  %frombool54.i467 = zext i1 %106 to i8
  store i8 %frombool54.i467, ptr %cmpxchg.bool.i451, align 1
  br label %atomic.continue51.i458

cmpxchg.store_expected55.i461:                    ; preds = %acquire_fail49.i460
  store i64 %110, ptr %39, align 8
  br label %cmpxchg.continue56.i462

cmpxchg.continue56.i462:                          ; preds = %cmpxchg.store_expected55.i461, %acquire_fail49.i460
  %frombool57.i463 = zext i1 %111 to i8
  store i8 %frombool57.i463, ptr %cmpxchg.bool.i451, align 1
  br label %atomic.continue51.i458

cmpxchg.store_expected58.i455:                    ; preds = %seqcst_fail50.i454
  store i64 %115, ptr %39, align 8
  br label %cmpxchg.continue59.i456

cmpxchg.continue59.i456:                          ; preds = %cmpxchg.store_expected58.i455, %seqcst_fail50.i454
  %frombool60.i457 = zext i1 %116 to i8
  store i8 %frombool60.i457, ptr %cmpxchg.bool.i451, align 1
  br label %atomic.continue51.i458

_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit524: ; preds = %atomic.continue51.i458, %atomic.continue38.i473, %atomic.continue25.i487, %atomic.continue12.i501, %atomic.continue2.i515
  %117 = load i8, ptr %cmpxchg.bool.i451, align 1
  %tobool.i459 = trunc i8 %117 to i1
  br i1 %tobool.i459, label %if.then30, label %if.end44

if.then30:                                        ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit524
  %118 = load ptr, ptr %waitp.addr, align 8
  %cond31 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %118, i32 0, i32 1
  %119 = load ptr, ptr %cond31, align 8
  %cmp32 = icmp eq ptr %119, null
  br i1 %cmp32, label %if.then38, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then30
  %120 = load ptr, ptr %waitp.addr, align 8
  %cond33 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %120, i32 0, i32 1
  %121 = load ptr, ptr %cond33, align 8
  %122 = load ptr, ptr %waitp.addr, align 8
  %how34 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %122, i32 0, i32 0
  %123 = load ptr, ptr %how34, align 8
  %cmp35 = icmp eq ptr %123, @_ZN4abslL8kSharedSE
  %call37 = invoke noundef zeroext i1 @_ZN4abslL22EvalConditionAnnotatedEPKNS_9ConditionEPNS_5MutexEbbb(ptr noundef %121, ptr noundef %this1, i1 noundef zeroext true, i1 noundef zeroext false, i1 noundef zeroext %cmp35)
          to label %invoke.cont36 unwind label %lpad

invoke.cont36:                                    ; preds = %lor.lhs.false
  br i1 %call37, label %if.then38, label %if.end39

if.then38:                                        ; preds = %invoke.cont36, %if.then30
  br label %for.end

if.end39:                                         ; preds = %invoke.cont36
  %124 = load ptr, ptr %waitp.addr, align 8
  invoke void @_ZN4absl5Mutex10UnlockSlowEPNS_15SynchWaitParamsE(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef %124) #16
          to label %invoke.cont40 unwind label %lpad

invoke.cont40:                                    ; preds = %if.end39
  %125 = load ptr, ptr %waitp.addr, align 8
  %thread41 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %125, i32 0, i32 4
  %126 = load ptr, ptr %thread41, align 8
  invoke void @_ZN4absl5Mutex5BlockEPNS_13base_internal14PerThreadSynchE(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef %126)
          to label %invoke.cont42 unwind label %lpad

invoke.cont42:                                    ; preds = %invoke.cont40
  %127 = load i32, ptr %flags.addr, align 4
  %or43 = or i32 %127, 1
  store i32 %or43, ptr %flags.addr, align 4
  store i32 0, ptr %c, align 4
  br label %if.end44

if.end44:                                         ; preds = %invoke.cont42, %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit524
  br label %if.end194

if.else:                                          ; preds = %invoke.cont17
  store i8 0, ptr %dowait, align 1
  %128 = load i64, ptr %v, align 8
  %and45 = and i64 %128, 68
  %cmp46 = icmp eq i64 %and45, 0
  br i1 %cmp46, label %if.then47, label %if.else86

if.then47:                                        ; preds = %if.else
  %129 = load ptr, ptr %waitp.addr, align 8
  %130 = load i64, ptr %v, align 8
  %131 = load i32, ptr %flags.addr, align 4
  %call49 = invoke noundef ptr @_ZN4abslL7EnqueueEPNS_13base_internal14PerThreadSynchEPNS_15SynchWaitParamsEli(ptr noundef null, ptr noundef %129, i64 noundef %130, i32 noundef %131)
          to label %invoke.cont48 unwind label %lpad

invoke.cont48:                                    ; preds = %if.then47
  store ptr %call49, ptr %new_h, align 8
  %132 = load i64, ptr %v, align 8
  %133 = load i32, ptr %flags.addr, align 4
  %and50 = and i32 %133, 1
  %call52 = invoke noundef i64 @_ZN4abslL24ClearDesignatedWakerMaskEi(i32 noundef %and50)
          to label %invoke.cont51 unwind label %lpad

invoke.cont51:                                    ; preds = %invoke.cont48
  %and53 = and i64 %132, %call52
  %and54 = and i64 %and53, 255
  %or55 = or i64 %and54, 4
  store i64 %or55, ptr %nv, align 8
  br label %do.body56

do.body56:                                        ; preds = %invoke.cont51
  %134 = load ptr, ptr %new_h, align 8
  %cmp57 = icmp ne ptr %134, null
  %lnot58 = xor i1 %cmp57, true
  br i1 %lnot58, label %if.then59, label %if.end68

if.then59:                                        ; preds = %do.body56
  br label %do.body60

do.body60:                                        ; preds = %if.then59
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename61, align 8
  invoke void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 1999, ptr noundef @.str.1, ptr noundef @.str.11, ptr noundef @.str.12)
          to label %invoke.cont62 unwind label %lpad

invoke.cont62:                                    ; preds = %do.body60
  br label %do.body63

do.body63:                                        ; preds = %invoke.cont62
  unreachable

do.cond64:                                        ; No predecessors!
  br label %do.end65

do.end65:                                         ; preds = %do.cond64
  br label %do.cond66

do.cond66:                                        ; preds = %do.end65
  br label %do.end67

do.end67:                                         ; preds = %do.cond66
  br label %if.end68

if.end68:                                         ; preds = %do.end67, %do.body56
  br label %do.cond69

do.cond69:                                        ; preds = %if.end68
  br label %do.end70

do.end70:                                         ; preds = %do.cond69
  %135 = load ptr, ptr %waitp.addr, align 8
  %how71 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %135, i32 0, i32 0
  %136 = load ptr, ptr %how71, align 8
  %cmp72 = icmp eq ptr %136, @_ZN4abslL11kExclusiveSE
  br i1 %cmp72, label %land.lhs.true, label %if.end77

land.lhs.true:                                    ; preds = %do.end70
  %137 = load i64, ptr %v, align 8
  %and73 = and i64 %137, 1
  %cmp74 = icmp ne i64 %and73, 0
  br i1 %cmp74, label %if.then75, label %if.end77

if.then75:                                        ; preds = %land.lhs.true
  %138 = load i64, ptr %nv, align 8
  %or76 = or i64 %138, 32
  store i64 %or76, ptr %nv, align 8
  br label %if.end77

if.end77:                                         ; preds = %if.then75, %land.lhs.true, %do.end70
  %mu_78 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %139 = load ptr, ptr %new_h, align 8
  %140 = ptrtoint ptr %139 to i64
  %141 = load i64, ptr %nv, align 8
  %or79 = or i64 %140, %141
  store ptr %mu_78, ptr %this.addr.i365, align 8
  store ptr %v, ptr %__i1.addr.i366, align 8
  store i64 %or79, ptr %__i2.addr.i367, align 8
  store i32 3, ptr %__m1.addr.i368, align 4
  store i32 0, ptr %__m2.addr.i369, align 4
  %this1.i372 = load ptr, ptr %this.addr.i365, align 8
  %142 = load i32, ptr %__m1.addr.i368, align 4
  %143 = load ptr, ptr %__i1.addr.i366, align 8
  %144 = load i64, ptr %__i2.addr.i367, align 8
  store i64 %144, ptr %.atomictmp.i370, align 8
  %145 = load i32, ptr %__m2.addr.i369, align 4
  switch i32 %142, label %monotonic.i430 [
    i32 1, label %acquire.i416
    i32 2, label %acquire.i416
    i32 3, label %release.i402
    i32 4, label %acqrel.i388
    i32 5, label %seqcst.i373
  ]

monotonic.i430:                                   ; preds = %if.end77
  switch i32 %145, label %monotonic_fail.i440 [
    i32 1, label %acquire_fail.i436
    i32 2, label %acquire_fail.i436
    i32 5, label %seqcst_fail.i431
  ]

acquire.i416:                                     ; preds = %if.end77, %if.end77
  switch i32 %145, label %monotonic_fail9.i426 [
    i32 1, label %acquire_fail10.i422
    i32 2, label %acquire_fail10.i422
    i32 5, label %seqcst_fail11.i417
  ]

release.i402:                                     ; preds = %if.end77
  switch i32 %145, label %monotonic_fail22.i412 [
    i32 1, label %acquire_fail23.i408
    i32 2, label %acquire_fail23.i408
    i32 5, label %seqcst_fail24.i403
  ]

acqrel.i388:                                      ; preds = %if.end77
  switch i32 %145, label %monotonic_fail35.i398 [
    i32 1, label %acquire_fail36.i394
    i32 2, label %acquire_fail36.i394
    i32 5, label %seqcst_fail37.i389
  ]

seqcst.i373:                                      ; preds = %if.end77
  switch i32 %145, label %monotonic_fail48.i384 [
    i32 1, label %acquire_fail49.i380
    i32 2, label %acquire_fail49.i380
    i32 5, label %seqcst_fail50.i374
  ]

monotonic_fail.i440:                              ; preds = %monotonic.i430
  %146 = load i64, ptr %143, align 8
  %147 = load i64, ptr %.atomictmp.i370, align 8
  %148 = cmpxchg ptr %this1.i372, i64 %146, i64 %147 monotonic monotonic, align 8
  %149 = extractvalue { i64, i1 } %148, 0
  %150 = extractvalue { i64, i1 } %148, 1
  br i1 %150, label %cmpxchg.continue.i442, label %cmpxchg.store_expected.i441

acquire_fail.i436:                                ; preds = %monotonic.i430, %monotonic.i430
  %151 = load i64, ptr %143, align 8
  %152 = load i64, ptr %.atomictmp.i370, align 8
  %153 = cmpxchg ptr %this1.i372, i64 %151, i64 %152 monotonic acquire, align 8
  %154 = extractvalue { i64, i1 } %153, 0
  %155 = extractvalue { i64, i1 } %153, 1
  br i1 %155, label %cmpxchg.continue4.i438, label %cmpxchg.store_expected3.i437

seqcst_fail.i431:                                 ; preds = %monotonic.i430
  %156 = load i64, ptr %143, align 8
  %157 = load i64, ptr %.atomictmp.i370, align 8
  %158 = cmpxchg ptr %this1.i372, i64 %156, i64 %157 monotonic seq_cst, align 8
  %159 = extractvalue { i64, i1 } %158, 0
  %160 = extractvalue { i64, i1 } %158, 1
  br i1 %160, label %cmpxchg.continue7.i433, label %cmpxchg.store_expected6.i432

atomic.continue2.i435:                            ; preds = %cmpxchg.continue7.i433, %cmpxchg.continue4.i438, %cmpxchg.continue.i442
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit444

cmpxchg.store_expected.i441:                      ; preds = %monotonic_fail.i440
  store i64 %149, ptr %143, align 8
  br label %cmpxchg.continue.i442

cmpxchg.continue.i442:                            ; preds = %cmpxchg.store_expected.i441, %monotonic_fail.i440
  %frombool.i443 = zext i1 %150 to i8
  store i8 %frombool.i443, ptr %cmpxchg.bool.i371, align 1
  br label %atomic.continue2.i435

cmpxchg.store_expected3.i437:                     ; preds = %acquire_fail.i436
  store i64 %154, ptr %143, align 8
  br label %cmpxchg.continue4.i438

cmpxchg.continue4.i438:                           ; preds = %cmpxchg.store_expected3.i437, %acquire_fail.i436
  %frombool5.i439 = zext i1 %155 to i8
  store i8 %frombool5.i439, ptr %cmpxchg.bool.i371, align 1
  br label %atomic.continue2.i435

cmpxchg.store_expected6.i432:                     ; preds = %seqcst_fail.i431
  store i64 %159, ptr %143, align 8
  br label %cmpxchg.continue7.i433

cmpxchg.continue7.i433:                           ; preds = %cmpxchg.store_expected6.i432, %seqcst_fail.i431
  %frombool8.i434 = zext i1 %160 to i8
  store i8 %frombool8.i434, ptr %cmpxchg.bool.i371, align 1
  br label %atomic.continue2.i435

monotonic_fail9.i426:                             ; preds = %acquire.i416
  %161 = load i64, ptr %143, align 8
  %162 = load i64, ptr %.atomictmp.i370, align 8
  %163 = cmpxchg ptr %this1.i372, i64 %161, i64 %162 acquire monotonic, align 8
  %164 = extractvalue { i64, i1 } %163, 0
  %165 = extractvalue { i64, i1 } %163, 1
  br i1 %165, label %cmpxchg.continue14.i428, label %cmpxchg.store_expected13.i427

acquire_fail10.i422:                              ; preds = %acquire.i416, %acquire.i416
  %166 = load i64, ptr %143, align 8
  %167 = load i64, ptr %.atomictmp.i370, align 8
  %168 = cmpxchg ptr %this1.i372, i64 %166, i64 %167 acquire acquire, align 8
  %169 = extractvalue { i64, i1 } %168, 0
  %170 = extractvalue { i64, i1 } %168, 1
  br i1 %170, label %cmpxchg.continue17.i424, label %cmpxchg.store_expected16.i423

seqcst_fail11.i417:                               ; preds = %acquire.i416
  %171 = load i64, ptr %143, align 8
  %172 = load i64, ptr %.atomictmp.i370, align 8
  %173 = cmpxchg ptr %this1.i372, i64 %171, i64 %172 acquire seq_cst, align 8
  %174 = extractvalue { i64, i1 } %173, 0
  %175 = extractvalue { i64, i1 } %173, 1
  br i1 %175, label %cmpxchg.continue20.i419, label %cmpxchg.store_expected19.i418

atomic.continue12.i421:                           ; preds = %cmpxchg.continue20.i419, %cmpxchg.continue17.i424, %cmpxchg.continue14.i428
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit444

cmpxchg.store_expected13.i427:                    ; preds = %monotonic_fail9.i426
  store i64 %164, ptr %143, align 8
  br label %cmpxchg.continue14.i428

cmpxchg.continue14.i428:                          ; preds = %cmpxchg.store_expected13.i427, %monotonic_fail9.i426
  %frombool15.i429 = zext i1 %165 to i8
  store i8 %frombool15.i429, ptr %cmpxchg.bool.i371, align 1
  br label %atomic.continue12.i421

cmpxchg.store_expected16.i423:                    ; preds = %acquire_fail10.i422
  store i64 %169, ptr %143, align 8
  br label %cmpxchg.continue17.i424

cmpxchg.continue17.i424:                          ; preds = %cmpxchg.store_expected16.i423, %acquire_fail10.i422
  %frombool18.i425 = zext i1 %170 to i8
  store i8 %frombool18.i425, ptr %cmpxchg.bool.i371, align 1
  br label %atomic.continue12.i421

cmpxchg.store_expected19.i418:                    ; preds = %seqcst_fail11.i417
  store i64 %174, ptr %143, align 8
  br label %cmpxchg.continue20.i419

cmpxchg.continue20.i419:                          ; preds = %cmpxchg.store_expected19.i418, %seqcst_fail11.i417
  %frombool21.i420 = zext i1 %175 to i8
  store i8 %frombool21.i420, ptr %cmpxchg.bool.i371, align 1
  br label %atomic.continue12.i421

monotonic_fail22.i412:                            ; preds = %release.i402
  %176 = load i64, ptr %143, align 8
  %177 = load i64, ptr %.atomictmp.i370, align 8
  %178 = cmpxchg ptr %this1.i372, i64 %176, i64 %177 release monotonic, align 8
  %179 = extractvalue { i64, i1 } %178, 0
  %180 = extractvalue { i64, i1 } %178, 1
  br i1 %180, label %cmpxchg.continue27.i414, label %cmpxchg.store_expected26.i413

acquire_fail23.i408:                              ; preds = %release.i402, %release.i402
  %181 = load i64, ptr %143, align 8
  %182 = load i64, ptr %.atomictmp.i370, align 8
  %183 = cmpxchg ptr %this1.i372, i64 %181, i64 %182 release acquire, align 8
  %184 = extractvalue { i64, i1 } %183, 0
  %185 = extractvalue { i64, i1 } %183, 1
  br i1 %185, label %cmpxchg.continue30.i410, label %cmpxchg.store_expected29.i409

seqcst_fail24.i403:                               ; preds = %release.i402
  %186 = load i64, ptr %143, align 8
  %187 = load i64, ptr %.atomictmp.i370, align 8
  %188 = cmpxchg ptr %this1.i372, i64 %186, i64 %187 release seq_cst, align 8
  %189 = extractvalue { i64, i1 } %188, 0
  %190 = extractvalue { i64, i1 } %188, 1
  br i1 %190, label %cmpxchg.continue33.i405, label %cmpxchg.store_expected32.i404

atomic.continue25.i407:                           ; preds = %cmpxchg.continue33.i405, %cmpxchg.continue30.i410, %cmpxchg.continue27.i414
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit444

cmpxchg.store_expected26.i413:                    ; preds = %monotonic_fail22.i412
  store i64 %179, ptr %143, align 8
  br label %cmpxchg.continue27.i414

cmpxchg.continue27.i414:                          ; preds = %cmpxchg.store_expected26.i413, %monotonic_fail22.i412
  %frombool28.i415 = zext i1 %180 to i8
  store i8 %frombool28.i415, ptr %cmpxchg.bool.i371, align 1
  br label %atomic.continue25.i407

cmpxchg.store_expected29.i409:                    ; preds = %acquire_fail23.i408
  store i64 %184, ptr %143, align 8
  br label %cmpxchg.continue30.i410

cmpxchg.continue30.i410:                          ; preds = %cmpxchg.store_expected29.i409, %acquire_fail23.i408
  %frombool31.i411 = zext i1 %185 to i8
  store i8 %frombool31.i411, ptr %cmpxchg.bool.i371, align 1
  br label %atomic.continue25.i407

cmpxchg.store_expected32.i404:                    ; preds = %seqcst_fail24.i403
  store i64 %189, ptr %143, align 8
  br label %cmpxchg.continue33.i405

cmpxchg.continue33.i405:                          ; preds = %cmpxchg.store_expected32.i404, %seqcst_fail24.i403
  %frombool34.i406 = zext i1 %190 to i8
  store i8 %frombool34.i406, ptr %cmpxchg.bool.i371, align 1
  br label %atomic.continue25.i407

monotonic_fail35.i398:                            ; preds = %acqrel.i388
  %191 = load i64, ptr %143, align 8
  %192 = load i64, ptr %.atomictmp.i370, align 8
  %193 = cmpxchg ptr %this1.i372, i64 %191, i64 %192 acq_rel monotonic, align 8
  %194 = extractvalue { i64, i1 } %193, 0
  %195 = extractvalue { i64, i1 } %193, 1
  br i1 %195, label %cmpxchg.continue40.i400, label %cmpxchg.store_expected39.i399

acquire_fail36.i394:                              ; preds = %acqrel.i388, %acqrel.i388
  %196 = load i64, ptr %143, align 8
  %197 = load i64, ptr %.atomictmp.i370, align 8
  %198 = cmpxchg ptr %this1.i372, i64 %196, i64 %197 acq_rel acquire, align 8
  %199 = extractvalue { i64, i1 } %198, 0
  %200 = extractvalue { i64, i1 } %198, 1
  br i1 %200, label %cmpxchg.continue43.i396, label %cmpxchg.store_expected42.i395

seqcst_fail37.i389:                               ; preds = %acqrel.i388
  %201 = load i64, ptr %143, align 8
  %202 = load i64, ptr %.atomictmp.i370, align 8
  %203 = cmpxchg ptr %this1.i372, i64 %201, i64 %202 acq_rel seq_cst, align 8
  %204 = extractvalue { i64, i1 } %203, 0
  %205 = extractvalue { i64, i1 } %203, 1
  br i1 %205, label %cmpxchg.continue46.i391, label %cmpxchg.store_expected45.i390

atomic.continue38.i393:                           ; preds = %cmpxchg.continue46.i391, %cmpxchg.continue43.i396, %cmpxchg.continue40.i400
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit444

cmpxchg.store_expected39.i399:                    ; preds = %monotonic_fail35.i398
  store i64 %194, ptr %143, align 8
  br label %cmpxchg.continue40.i400

cmpxchg.continue40.i400:                          ; preds = %cmpxchg.store_expected39.i399, %monotonic_fail35.i398
  %frombool41.i401 = zext i1 %195 to i8
  store i8 %frombool41.i401, ptr %cmpxchg.bool.i371, align 1
  br label %atomic.continue38.i393

cmpxchg.store_expected42.i395:                    ; preds = %acquire_fail36.i394
  store i64 %199, ptr %143, align 8
  br label %cmpxchg.continue43.i396

cmpxchg.continue43.i396:                          ; preds = %cmpxchg.store_expected42.i395, %acquire_fail36.i394
  %frombool44.i397 = zext i1 %200 to i8
  store i8 %frombool44.i397, ptr %cmpxchg.bool.i371, align 1
  br label %atomic.continue38.i393

cmpxchg.store_expected45.i390:                    ; preds = %seqcst_fail37.i389
  store i64 %204, ptr %143, align 8
  br label %cmpxchg.continue46.i391

cmpxchg.continue46.i391:                          ; preds = %cmpxchg.store_expected45.i390, %seqcst_fail37.i389
  %frombool47.i392 = zext i1 %205 to i8
  store i8 %frombool47.i392, ptr %cmpxchg.bool.i371, align 1
  br label %atomic.continue38.i393

monotonic_fail48.i384:                            ; preds = %seqcst.i373
  %206 = load i64, ptr %143, align 8
  %207 = load i64, ptr %.atomictmp.i370, align 8
  %208 = cmpxchg ptr %this1.i372, i64 %206, i64 %207 seq_cst monotonic, align 8
  %209 = extractvalue { i64, i1 } %208, 0
  %210 = extractvalue { i64, i1 } %208, 1
  br i1 %210, label %cmpxchg.continue53.i386, label %cmpxchg.store_expected52.i385

acquire_fail49.i380:                              ; preds = %seqcst.i373, %seqcst.i373
  %211 = load i64, ptr %143, align 8
  %212 = load i64, ptr %.atomictmp.i370, align 8
  %213 = cmpxchg ptr %this1.i372, i64 %211, i64 %212 seq_cst acquire, align 8
  %214 = extractvalue { i64, i1 } %213, 0
  %215 = extractvalue { i64, i1 } %213, 1
  br i1 %215, label %cmpxchg.continue56.i382, label %cmpxchg.store_expected55.i381

seqcst_fail50.i374:                               ; preds = %seqcst.i373
  %216 = load i64, ptr %143, align 8
  %217 = load i64, ptr %.atomictmp.i370, align 8
  %218 = cmpxchg ptr %this1.i372, i64 %216, i64 %217 seq_cst seq_cst, align 8
  %219 = extractvalue { i64, i1 } %218, 0
  %220 = extractvalue { i64, i1 } %218, 1
  br i1 %220, label %cmpxchg.continue59.i376, label %cmpxchg.store_expected58.i375

atomic.continue51.i378:                           ; preds = %cmpxchg.continue59.i376, %cmpxchg.continue56.i382, %cmpxchg.continue53.i386
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit444

cmpxchg.store_expected52.i385:                    ; preds = %monotonic_fail48.i384
  store i64 %209, ptr %143, align 8
  br label %cmpxchg.continue53.i386

cmpxchg.continue53.i386:                          ; preds = %cmpxchg.store_expected52.i385, %monotonic_fail48.i384
  %frombool54.i387 = zext i1 %210 to i8
  store i8 %frombool54.i387, ptr %cmpxchg.bool.i371, align 1
  br label %atomic.continue51.i378

cmpxchg.store_expected55.i381:                    ; preds = %acquire_fail49.i380
  store i64 %214, ptr %143, align 8
  br label %cmpxchg.continue56.i382

cmpxchg.continue56.i382:                          ; preds = %cmpxchg.store_expected55.i381, %acquire_fail49.i380
  %frombool57.i383 = zext i1 %215 to i8
  store i8 %frombool57.i383, ptr %cmpxchg.bool.i371, align 1
  br label %atomic.continue51.i378

cmpxchg.store_expected58.i375:                    ; preds = %seqcst_fail50.i374
  store i64 %219, ptr %143, align 8
  br label %cmpxchg.continue59.i376

cmpxchg.continue59.i376:                          ; preds = %cmpxchg.store_expected58.i375, %seqcst_fail50.i374
  %frombool60.i377 = zext i1 %220 to i8
  store i8 %frombool60.i377, ptr %cmpxchg.bool.i371, align 1
  br label %atomic.continue51.i378

_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit444: ; preds = %atomic.continue51.i378, %atomic.continue38.i393, %atomic.continue25.i407, %atomic.continue12.i421, %atomic.continue2.i435
  %221 = load i8, ptr %cmpxchg.bool.i371, align 1
  %tobool.i379 = trunc i8 %221 to i1
  br i1 %tobool.i379, label %if.then81, label %if.else82

if.then81:                                        ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit444
  store i8 1, ptr %dowait, align 1
  br label %if.end85

if.else82:                                        ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit444
  %222 = load ptr, ptr %waitp.addr, align 8
  %thread83 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %222, i32 0, i32 4
  %223 = load ptr, ptr %thread83, align 8
  %waitp84 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %223, i32 0, i32 9
  store ptr null, ptr %waitp84, align 8
  br label %if.end85

if.end85:                                         ; preds = %if.else82, %if.then81
  br label %if.end187

if.else86:                                        ; preds = %if.else
  %224 = load i64, ptr %v, align 8
  %225 = load ptr, ptr %waitp.addr, align 8
  %how87 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %225, i32 0, i32 0
  %226 = load ptr, ptr %how87, align 8
  %slow_inc_need_zero = getelementptr inbounds %"struct.absl::MuHowS", ptr %226, i32 0, i32 4
  %227 = load i64, ptr %slow_inc_need_zero, align 8
  %and88 = and i64 %224, %227
  %228 = load i32, ptr %flags.addr, align 4
  %and89 = and i32 %228, 1
  %call91 = invoke noundef i64 @_ZN4abslL24IgnoreWaitingWritersMaskEi(i32 noundef %and89)
          to label %invoke.cont90 unwind label %lpad

invoke.cont90:                                    ; preds = %if.else86
  %and92 = and i64 %and88, %call91
  %cmp93 = icmp eq i64 %and92, 0
  br i1 %cmp93, label %if.then94, label %if.else132

if.then94:                                        ; preds = %invoke.cont90
  %mu_95 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %229 = load i64, ptr %v, align 8
  %230 = load i32, ptr %flags.addr, align 4
  %and96 = and i32 %230, 1
  %call98 = invoke noundef i64 @_ZN4abslL24ClearDesignatedWakerMaskEi(i32 noundef %and96)
          to label %invoke.cont97 unwind label %lpad

invoke.cont97:                                    ; preds = %if.then94
  %and99 = and i64 %229, %call98
  %or100 = or i64 %and99, 64
  %or101 = or i64 %or100, 1
  store ptr %mu_95, ptr %this.addr.i285, align 8
  store ptr %v, ptr %__i1.addr.i286, align 8
  store i64 %or101, ptr %__i2.addr.i287, align 8
  store i32 2, ptr %__m1.addr.i288, align 4
  store i32 0, ptr %__m2.addr.i289, align 4
  %this1.i292 = load ptr, ptr %this.addr.i285, align 8
  %231 = load i32, ptr %__m1.addr.i288, align 4
  %232 = load ptr, ptr %__i1.addr.i286, align 8
  %233 = load i64, ptr %__i2.addr.i287, align 8
  store i64 %233, ptr %.atomictmp.i290, align 8
  %234 = load i32, ptr %__m2.addr.i289, align 4
  switch i32 %231, label %monotonic.i350 [
    i32 1, label %acquire.i336
    i32 2, label %acquire.i336
    i32 3, label %release.i322
    i32 4, label %acqrel.i308
    i32 5, label %seqcst.i293
  ]

monotonic.i350:                                   ; preds = %invoke.cont97
  switch i32 %234, label %monotonic_fail.i360 [
    i32 1, label %acquire_fail.i356
    i32 2, label %acquire_fail.i356
    i32 5, label %seqcst_fail.i351
  ]

acquire.i336:                                     ; preds = %invoke.cont97, %invoke.cont97
  switch i32 %234, label %monotonic_fail9.i346 [
    i32 1, label %acquire_fail10.i342
    i32 2, label %acquire_fail10.i342
    i32 5, label %seqcst_fail11.i337
  ]

release.i322:                                     ; preds = %invoke.cont97
  switch i32 %234, label %monotonic_fail22.i332 [
    i32 1, label %acquire_fail23.i328
    i32 2, label %acquire_fail23.i328
    i32 5, label %seqcst_fail24.i323
  ]

acqrel.i308:                                      ; preds = %invoke.cont97
  switch i32 %234, label %monotonic_fail35.i318 [
    i32 1, label %acquire_fail36.i314
    i32 2, label %acquire_fail36.i314
    i32 5, label %seqcst_fail37.i309
  ]

seqcst.i293:                                      ; preds = %invoke.cont97
  switch i32 %234, label %monotonic_fail48.i304 [
    i32 1, label %acquire_fail49.i300
    i32 2, label %acquire_fail49.i300
    i32 5, label %seqcst_fail50.i294
  ]

monotonic_fail.i360:                              ; preds = %monotonic.i350
  %235 = load i64, ptr %232, align 8
  %236 = load i64, ptr %.atomictmp.i290, align 8
  %237 = cmpxchg ptr %this1.i292, i64 %235, i64 %236 monotonic monotonic, align 8
  %238 = extractvalue { i64, i1 } %237, 0
  %239 = extractvalue { i64, i1 } %237, 1
  br i1 %239, label %cmpxchg.continue.i362, label %cmpxchg.store_expected.i361

acquire_fail.i356:                                ; preds = %monotonic.i350, %monotonic.i350
  %240 = load i64, ptr %232, align 8
  %241 = load i64, ptr %.atomictmp.i290, align 8
  %242 = cmpxchg ptr %this1.i292, i64 %240, i64 %241 monotonic acquire, align 8
  %243 = extractvalue { i64, i1 } %242, 0
  %244 = extractvalue { i64, i1 } %242, 1
  br i1 %244, label %cmpxchg.continue4.i358, label %cmpxchg.store_expected3.i357

seqcst_fail.i351:                                 ; preds = %monotonic.i350
  %245 = load i64, ptr %232, align 8
  %246 = load i64, ptr %.atomictmp.i290, align 8
  %247 = cmpxchg ptr %this1.i292, i64 %245, i64 %246 monotonic seq_cst, align 8
  %248 = extractvalue { i64, i1 } %247, 0
  %249 = extractvalue { i64, i1 } %247, 1
  br i1 %249, label %cmpxchg.continue7.i353, label %cmpxchg.store_expected6.i352

atomic.continue2.i355:                            ; preds = %cmpxchg.continue7.i353, %cmpxchg.continue4.i358, %cmpxchg.continue.i362
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit364

cmpxchg.store_expected.i361:                      ; preds = %monotonic_fail.i360
  store i64 %238, ptr %232, align 8
  br label %cmpxchg.continue.i362

cmpxchg.continue.i362:                            ; preds = %cmpxchg.store_expected.i361, %monotonic_fail.i360
  %frombool.i363 = zext i1 %239 to i8
  store i8 %frombool.i363, ptr %cmpxchg.bool.i291, align 1
  br label %atomic.continue2.i355

cmpxchg.store_expected3.i357:                     ; preds = %acquire_fail.i356
  store i64 %243, ptr %232, align 8
  br label %cmpxchg.continue4.i358

cmpxchg.continue4.i358:                           ; preds = %cmpxchg.store_expected3.i357, %acquire_fail.i356
  %frombool5.i359 = zext i1 %244 to i8
  store i8 %frombool5.i359, ptr %cmpxchg.bool.i291, align 1
  br label %atomic.continue2.i355

cmpxchg.store_expected6.i352:                     ; preds = %seqcst_fail.i351
  store i64 %248, ptr %232, align 8
  br label %cmpxchg.continue7.i353

cmpxchg.continue7.i353:                           ; preds = %cmpxchg.store_expected6.i352, %seqcst_fail.i351
  %frombool8.i354 = zext i1 %249 to i8
  store i8 %frombool8.i354, ptr %cmpxchg.bool.i291, align 1
  br label %atomic.continue2.i355

monotonic_fail9.i346:                             ; preds = %acquire.i336
  %250 = load i64, ptr %232, align 8
  %251 = load i64, ptr %.atomictmp.i290, align 8
  %252 = cmpxchg ptr %this1.i292, i64 %250, i64 %251 acquire monotonic, align 8
  %253 = extractvalue { i64, i1 } %252, 0
  %254 = extractvalue { i64, i1 } %252, 1
  br i1 %254, label %cmpxchg.continue14.i348, label %cmpxchg.store_expected13.i347

acquire_fail10.i342:                              ; preds = %acquire.i336, %acquire.i336
  %255 = load i64, ptr %232, align 8
  %256 = load i64, ptr %.atomictmp.i290, align 8
  %257 = cmpxchg ptr %this1.i292, i64 %255, i64 %256 acquire acquire, align 8
  %258 = extractvalue { i64, i1 } %257, 0
  %259 = extractvalue { i64, i1 } %257, 1
  br i1 %259, label %cmpxchg.continue17.i344, label %cmpxchg.store_expected16.i343

seqcst_fail11.i337:                               ; preds = %acquire.i336
  %260 = load i64, ptr %232, align 8
  %261 = load i64, ptr %.atomictmp.i290, align 8
  %262 = cmpxchg ptr %this1.i292, i64 %260, i64 %261 acquire seq_cst, align 8
  %263 = extractvalue { i64, i1 } %262, 0
  %264 = extractvalue { i64, i1 } %262, 1
  br i1 %264, label %cmpxchg.continue20.i339, label %cmpxchg.store_expected19.i338

atomic.continue12.i341:                           ; preds = %cmpxchg.continue20.i339, %cmpxchg.continue17.i344, %cmpxchg.continue14.i348
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit364

cmpxchg.store_expected13.i347:                    ; preds = %monotonic_fail9.i346
  store i64 %253, ptr %232, align 8
  br label %cmpxchg.continue14.i348

cmpxchg.continue14.i348:                          ; preds = %cmpxchg.store_expected13.i347, %monotonic_fail9.i346
  %frombool15.i349 = zext i1 %254 to i8
  store i8 %frombool15.i349, ptr %cmpxchg.bool.i291, align 1
  br label %atomic.continue12.i341

cmpxchg.store_expected16.i343:                    ; preds = %acquire_fail10.i342
  store i64 %258, ptr %232, align 8
  br label %cmpxchg.continue17.i344

cmpxchg.continue17.i344:                          ; preds = %cmpxchg.store_expected16.i343, %acquire_fail10.i342
  %frombool18.i345 = zext i1 %259 to i8
  store i8 %frombool18.i345, ptr %cmpxchg.bool.i291, align 1
  br label %atomic.continue12.i341

cmpxchg.store_expected19.i338:                    ; preds = %seqcst_fail11.i337
  store i64 %263, ptr %232, align 8
  br label %cmpxchg.continue20.i339

cmpxchg.continue20.i339:                          ; preds = %cmpxchg.store_expected19.i338, %seqcst_fail11.i337
  %frombool21.i340 = zext i1 %264 to i8
  store i8 %frombool21.i340, ptr %cmpxchg.bool.i291, align 1
  br label %atomic.continue12.i341

monotonic_fail22.i332:                            ; preds = %release.i322
  %265 = load i64, ptr %232, align 8
  %266 = load i64, ptr %.atomictmp.i290, align 8
  %267 = cmpxchg ptr %this1.i292, i64 %265, i64 %266 release monotonic, align 8
  %268 = extractvalue { i64, i1 } %267, 0
  %269 = extractvalue { i64, i1 } %267, 1
  br i1 %269, label %cmpxchg.continue27.i334, label %cmpxchg.store_expected26.i333

acquire_fail23.i328:                              ; preds = %release.i322, %release.i322
  %270 = load i64, ptr %232, align 8
  %271 = load i64, ptr %.atomictmp.i290, align 8
  %272 = cmpxchg ptr %this1.i292, i64 %270, i64 %271 release acquire, align 8
  %273 = extractvalue { i64, i1 } %272, 0
  %274 = extractvalue { i64, i1 } %272, 1
  br i1 %274, label %cmpxchg.continue30.i330, label %cmpxchg.store_expected29.i329

seqcst_fail24.i323:                               ; preds = %release.i322
  %275 = load i64, ptr %232, align 8
  %276 = load i64, ptr %.atomictmp.i290, align 8
  %277 = cmpxchg ptr %this1.i292, i64 %275, i64 %276 release seq_cst, align 8
  %278 = extractvalue { i64, i1 } %277, 0
  %279 = extractvalue { i64, i1 } %277, 1
  br i1 %279, label %cmpxchg.continue33.i325, label %cmpxchg.store_expected32.i324

atomic.continue25.i327:                           ; preds = %cmpxchg.continue33.i325, %cmpxchg.continue30.i330, %cmpxchg.continue27.i334
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit364

cmpxchg.store_expected26.i333:                    ; preds = %monotonic_fail22.i332
  store i64 %268, ptr %232, align 8
  br label %cmpxchg.continue27.i334

cmpxchg.continue27.i334:                          ; preds = %cmpxchg.store_expected26.i333, %monotonic_fail22.i332
  %frombool28.i335 = zext i1 %269 to i8
  store i8 %frombool28.i335, ptr %cmpxchg.bool.i291, align 1
  br label %atomic.continue25.i327

cmpxchg.store_expected29.i329:                    ; preds = %acquire_fail23.i328
  store i64 %273, ptr %232, align 8
  br label %cmpxchg.continue30.i330

cmpxchg.continue30.i330:                          ; preds = %cmpxchg.store_expected29.i329, %acquire_fail23.i328
  %frombool31.i331 = zext i1 %274 to i8
  store i8 %frombool31.i331, ptr %cmpxchg.bool.i291, align 1
  br label %atomic.continue25.i327

cmpxchg.store_expected32.i324:                    ; preds = %seqcst_fail24.i323
  store i64 %278, ptr %232, align 8
  br label %cmpxchg.continue33.i325

cmpxchg.continue33.i325:                          ; preds = %cmpxchg.store_expected32.i324, %seqcst_fail24.i323
  %frombool34.i326 = zext i1 %279 to i8
  store i8 %frombool34.i326, ptr %cmpxchg.bool.i291, align 1
  br label %atomic.continue25.i327

monotonic_fail35.i318:                            ; preds = %acqrel.i308
  %280 = load i64, ptr %232, align 8
  %281 = load i64, ptr %.atomictmp.i290, align 8
  %282 = cmpxchg ptr %this1.i292, i64 %280, i64 %281 acq_rel monotonic, align 8
  %283 = extractvalue { i64, i1 } %282, 0
  %284 = extractvalue { i64, i1 } %282, 1
  br i1 %284, label %cmpxchg.continue40.i320, label %cmpxchg.store_expected39.i319

acquire_fail36.i314:                              ; preds = %acqrel.i308, %acqrel.i308
  %285 = load i64, ptr %232, align 8
  %286 = load i64, ptr %.atomictmp.i290, align 8
  %287 = cmpxchg ptr %this1.i292, i64 %285, i64 %286 acq_rel acquire, align 8
  %288 = extractvalue { i64, i1 } %287, 0
  %289 = extractvalue { i64, i1 } %287, 1
  br i1 %289, label %cmpxchg.continue43.i316, label %cmpxchg.store_expected42.i315

seqcst_fail37.i309:                               ; preds = %acqrel.i308
  %290 = load i64, ptr %232, align 8
  %291 = load i64, ptr %.atomictmp.i290, align 8
  %292 = cmpxchg ptr %this1.i292, i64 %290, i64 %291 acq_rel seq_cst, align 8
  %293 = extractvalue { i64, i1 } %292, 0
  %294 = extractvalue { i64, i1 } %292, 1
  br i1 %294, label %cmpxchg.continue46.i311, label %cmpxchg.store_expected45.i310

atomic.continue38.i313:                           ; preds = %cmpxchg.continue46.i311, %cmpxchg.continue43.i316, %cmpxchg.continue40.i320
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit364

cmpxchg.store_expected39.i319:                    ; preds = %monotonic_fail35.i318
  store i64 %283, ptr %232, align 8
  br label %cmpxchg.continue40.i320

cmpxchg.continue40.i320:                          ; preds = %cmpxchg.store_expected39.i319, %monotonic_fail35.i318
  %frombool41.i321 = zext i1 %284 to i8
  store i8 %frombool41.i321, ptr %cmpxchg.bool.i291, align 1
  br label %atomic.continue38.i313

cmpxchg.store_expected42.i315:                    ; preds = %acquire_fail36.i314
  store i64 %288, ptr %232, align 8
  br label %cmpxchg.continue43.i316

cmpxchg.continue43.i316:                          ; preds = %cmpxchg.store_expected42.i315, %acquire_fail36.i314
  %frombool44.i317 = zext i1 %289 to i8
  store i8 %frombool44.i317, ptr %cmpxchg.bool.i291, align 1
  br label %atomic.continue38.i313

cmpxchg.store_expected45.i310:                    ; preds = %seqcst_fail37.i309
  store i64 %293, ptr %232, align 8
  br label %cmpxchg.continue46.i311

cmpxchg.continue46.i311:                          ; preds = %cmpxchg.store_expected45.i310, %seqcst_fail37.i309
  %frombool47.i312 = zext i1 %294 to i8
  store i8 %frombool47.i312, ptr %cmpxchg.bool.i291, align 1
  br label %atomic.continue38.i313

monotonic_fail48.i304:                            ; preds = %seqcst.i293
  %295 = load i64, ptr %232, align 8
  %296 = load i64, ptr %.atomictmp.i290, align 8
  %297 = cmpxchg ptr %this1.i292, i64 %295, i64 %296 seq_cst monotonic, align 8
  %298 = extractvalue { i64, i1 } %297, 0
  %299 = extractvalue { i64, i1 } %297, 1
  br i1 %299, label %cmpxchg.continue53.i306, label %cmpxchg.store_expected52.i305

acquire_fail49.i300:                              ; preds = %seqcst.i293, %seqcst.i293
  %300 = load i64, ptr %232, align 8
  %301 = load i64, ptr %.atomictmp.i290, align 8
  %302 = cmpxchg ptr %this1.i292, i64 %300, i64 %301 seq_cst acquire, align 8
  %303 = extractvalue { i64, i1 } %302, 0
  %304 = extractvalue { i64, i1 } %302, 1
  br i1 %304, label %cmpxchg.continue56.i302, label %cmpxchg.store_expected55.i301

seqcst_fail50.i294:                               ; preds = %seqcst.i293
  %305 = load i64, ptr %232, align 8
  %306 = load i64, ptr %.atomictmp.i290, align 8
  %307 = cmpxchg ptr %this1.i292, i64 %305, i64 %306 seq_cst seq_cst, align 8
  %308 = extractvalue { i64, i1 } %307, 0
  %309 = extractvalue { i64, i1 } %307, 1
  br i1 %309, label %cmpxchg.continue59.i296, label %cmpxchg.store_expected58.i295

atomic.continue51.i298:                           ; preds = %cmpxchg.continue59.i296, %cmpxchg.continue56.i302, %cmpxchg.continue53.i306
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit364

cmpxchg.store_expected52.i305:                    ; preds = %monotonic_fail48.i304
  store i64 %298, ptr %232, align 8
  br label %cmpxchg.continue53.i306

cmpxchg.continue53.i306:                          ; preds = %cmpxchg.store_expected52.i305, %monotonic_fail48.i304
  %frombool54.i307 = zext i1 %299 to i8
  store i8 %frombool54.i307, ptr %cmpxchg.bool.i291, align 1
  br label %atomic.continue51.i298

cmpxchg.store_expected55.i301:                    ; preds = %acquire_fail49.i300
  store i64 %303, ptr %232, align 8
  br label %cmpxchg.continue56.i302

cmpxchg.continue56.i302:                          ; preds = %cmpxchg.store_expected55.i301, %acquire_fail49.i300
  %frombool57.i303 = zext i1 %304 to i8
  store i8 %frombool57.i303, ptr %cmpxchg.bool.i291, align 1
  br label %atomic.continue51.i298

cmpxchg.store_expected58.i295:                    ; preds = %seqcst_fail50.i294
  store i64 %308, ptr %232, align 8
  br label %cmpxchg.continue59.i296

cmpxchg.continue59.i296:                          ; preds = %cmpxchg.store_expected58.i295, %seqcst_fail50.i294
  %frombool60.i297 = zext i1 %309 to i8
  store i8 %frombool60.i297, ptr %cmpxchg.bool.i291, align 1
  br label %atomic.continue51.i298

_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit364: ; preds = %atomic.continue51.i298, %atomic.continue38.i313, %atomic.continue25.i327, %atomic.continue12.i341, %atomic.continue2.i355
  %310 = load i8, ptr %cmpxchg.bool.i291, align 1
  %tobool.i299 = trunc i8 %310 to i1
  br i1 %tobool.i299, label %if.then103, label %if.end131

if.then103:                                       ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit364
  %311 = load i64, ptr %v, align 8
  %call105 = invoke noundef ptr @_ZN4abslL17GetPerThreadSynchEl(i64 noundef %311)
          to label %invoke.cont104 unwind label %lpad

invoke.cont104:                                   ; preds = %if.then103
  store ptr %call105, ptr %h, align 8
  %312 = load ptr, ptr %h, align 8
  %readers = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %312, i32 0, i32 10
  %313 = load i64, ptr %readers, align 8
  %add106 = add nsw i64 %313, 256
  store i64 %add106, ptr %readers, align 8
  br label %do.body107

do.body107:                                       ; preds = %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit683, %invoke.cont104
  %mu_108 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  store ptr %mu_108, ptr %this.addr.i250, align 8
  store i32 0, ptr %__m.addr.i251, align 4
  %this1.i254 = load ptr, ptr %this.addr.i250, align 8
  %314 = load i32, ptr %__m.addr.i251, align 4
  %call.i255 = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %314, i32 noundef 65535)
  store i32 %call.i255, ptr %__b.i252, align 4
  %315 = load i32, ptr %__m.addr.i251, align 4
  switch i32 %315, label %monotonic.i258 [
    i32 1, label %acquire.i257
    i32 2, label %acquire.i257
    i32 5, label %seqcst.i256
  ]

monotonic.i258:                                   ; preds = %do.body107
  %316 = load atomic i64, ptr %this1.i254 monotonic, align 8
  store i64 %316, ptr %atomic-temp.i253, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit259

acquire.i257:                                     ; preds = %do.body107, %do.body107
  %317 = load atomic i64, ptr %this1.i254 acquire, align 8
  store i64 %317, ptr %atomic-temp.i253, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit259

seqcst.i256:                                      ; preds = %do.body107
  %318 = load atomic i64, ptr %this1.i254 seq_cst, align 8
  store i64 %318, ptr %atomic-temp.i253, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit259

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit259: ; preds = %seqcst.i256, %acquire.i257, %monotonic.i258
  %319 = load i64, ptr %atomic-temp.i253, align 8
  store i64 %319, ptr %v, align 8
  br label %do.cond110

do.cond110:                                       ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit259
  %mu_111 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %320 = load i64, ptr %v, align 8
  %and112 = and i64 %320, -65
  %or113 = or i64 %and112, 1
  store ptr %mu_111, ptr %this.addr.i604, align 8
  store ptr %v, ptr %__i1.addr.i605, align 8
  store i64 %or113, ptr %__i2.addr.i606, align 8
  store i32 3, ptr %__m1.addr.i607, align 4
  store i32 0, ptr %__m2.addr.i608, align 4
  %this1.i611 = load ptr, ptr %this.addr.i604, align 8
  %321 = load i32, ptr %__m1.addr.i607, align 4
  %322 = load ptr, ptr %__i1.addr.i605, align 8
  %323 = load i64, ptr %__i2.addr.i606, align 8
  store i64 %323, ptr %.atomictmp.i609, align 8
  %324 = load i32, ptr %__m2.addr.i608, align 4
  switch i32 %321, label %monotonic.i669 [
    i32 1, label %acquire.i655
    i32 2, label %acquire.i655
    i32 3, label %release.i641
    i32 4, label %acqrel.i627
    i32 5, label %seqcst.i612
  ]

monotonic.i669:                                   ; preds = %do.cond110
  switch i32 %324, label %monotonic_fail.i679 [
    i32 1, label %acquire_fail.i675
    i32 2, label %acquire_fail.i675
    i32 5, label %seqcst_fail.i670
  ]

acquire.i655:                                     ; preds = %do.cond110, %do.cond110
  switch i32 %324, label %monotonic_fail9.i665 [
    i32 1, label %acquire_fail10.i661
    i32 2, label %acquire_fail10.i661
    i32 5, label %seqcst_fail11.i656
  ]

release.i641:                                     ; preds = %do.cond110
  switch i32 %324, label %monotonic_fail22.i651 [
    i32 1, label %acquire_fail23.i647
    i32 2, label %acquire_fail23.i647
    i32 5, label %seqcst_fail24.i642
  ]

acqrel.i627:                                      ; preds = %do.cond110
  switch i32 %324, label %monotonic_fail35.i637 [
    i32 1, label %acquire_fail36.i633
    i32 2, label %acquire_fail36.i633
    i32 5, label %seqcst_fail37.i628
  ]

seqcst.i612:                                      ; preds = %do.cond110
  switch i32 %324, label %monotonic_fail48.i623 [
    i32 1, label %acquire_fail49.i619
    i32 2, label %acquire_fail49.i619
    i32 5, label %seqcst_fail50.i613
  ]

monotonic_fail.i679:                              ; preds = %monotonic.i669
  %325 = load i64, ptr %322, align 8
  %326 = load i64, ptr %.atomictmp.i609, align 8
  %327 = cmpxchg weak ptr %this1.i611, i64 %325, i64 %326 monotonic monotonic, align 8
  %328 = extractvalue { i64, i1 } %327, 0
  %329 = extractvalue { i64, i1 } %327, 1
  br i1 %329, label %cmpxchg.continue.i681, label %cmpxchg.store_expected.i680

acquire_fail.i675:                                ; preds = %monotonic.i669, %monotonic.i669
  %330 = load i64, ptr %322, align 8
  %331 = load i64, ptr %.atomictmp.i609, align 8
  %332 = cmpxchg weak ptr %this1.i611, i64 %330, i64 %331 monotonic acquire, align 8
  %333 = extractvalue { i64, i1 } %332, 0
  %334 = extractvalue { i64, i1 } %332, 1
  br i1 %334, label %cmpxchg.continue4.i677, label %cmpxchg.store_expected3.i676

seqcst_fail.i670:                                 ; preds = %monotonic.i669
  %335 = load i64, ptr %322, align 8
  %336 = load i64, ptr %.atomictmp.i609, align 8
  %337 = cmpxchg weak ptr %this1.i611, i64 %335, i64 %336 monotonic seq_cst, align 8
  %338 = extractvalue { i64, i1 } %337, 0
  %339 = extractvalue { i64, i1 } %337, 1
  br i1 %339, label %cmpxchg.continue7.i672, label %cmpxchg.store_expected6.i671

atomic.continue2.i674:                            ; preds = %cmpxchg.continue7.i672, %cmpxchg.continue4.i677, %cmpxchg.continue.i681
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit683

cmpxchg.store_expected.i680:                      ; preds = %monotonic_fail.i679
  store i64 %328, ptr %322, align 8
  br label %cmpxchg.continue.i681

cmpxchg.continue.i681:                            ; preds = %cmpxchg.store_expected.i680, %monotonic_fail.i679
  %frombool.i682 = zext i1 %329 to i8
  store i8 %frombool.i682, ptr %cmpxchg.bool.i610, align 1
  br label %atomic.continue2.i674

cmpxchg.store_expected3.i676:                     ; preds = %acquire_fail.i675
  store i64 %333, ptr %322, align 8
  br label %cmpxchg.continue4.i677

cmpxchg.continue4.i677:                           ; preds = %cmpxchg.store_expected3.i676, %acquire_fail.i675
  %frombool5.i678 = zext i1 %334 to i8
  store i8 %frombool5.i678, ptr %cmpxchg.bool.i610, align 1
  br label %atomic.continue2.i674

cmpxchg.store_expected6.i671:                     ; preds = %seqcst_fail.i670
  store i64 %338, ptr %322, align 8
  br label %cmpxchg.continue7.i672

cmpxchg.continue7.i672:                           ; preds = %cmpxchg.store_expected6.i671, %seqcst_fail.i670
  %frombool8.i673 = zext i1 %339 to i8
  store i8 %frombool8.i673, ptr %cmpxchg.bool.i610, align 1
  br label %atomic.continue2.i674

monotonic_fail9.i665:                             ; preds = %acquire.i655
  %340 = load i64, ptr %322, align 8
  %341 = load i64, ptr %.atomictmp.i609, align 8
  %342 = cmpxchg weak ptr %this1.i611, i64 %340, i64 %341 acquire monotonic, align 8
  %343 = extractvalue { i64, i1 } %342, 0
  %344 = extractvalue { i64, i1 } %342, 1
  br i1 %344, label %cmpxchg.continue14.i667, label %cmpxchg.store_expected13.i666

acquire_fail10.i661:                              ; preds = %acquire.i655, %acquire.i655
  %345 = load i64, ptr %322, align 8
  %346 = load i64, ptr %.atomictmp.i609, align 8
  %347 = cmpxchg weak ptr %this1.i611, i64 %345, i64 %346 acquire acquire, align 8
  %348 = extractvalue { i64, i1 } %347, 0
  %349 = extractvalue { i64, i1 } %347, 1
  br i1 %349, label %cmpxchg.continue17.i663, label %cmpxchg.store_expected16.i662

seqcst_fail11.i656:                               ; preds = %acquire.i655
  %350 = load i64, ptr %322, align 8
  %351 = load i64, ptr %.atomictmp.i609, align 8
  %352 = cmpxchg weak ptr %this1.i611, i64 %350, i64 %351 acquire seq_cst, align 8
  %353 = extractvalue { i64, i1 } %352, 0
  %354 = extractvalue { i64, i1 } %352, 1
  br i1 %354, label %cmpxchg.continue20.i658, label %cmpxchg.store_expected19.i657

atomic.continue12.i660:                           ; preds = %cmpxchg.continue20.i658, %cmpxchg.continue17.i663, %cmpxchg.continue14.i667
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit683

cmpxchg.store_expected13.i666:                    ; preds = %monotonic_fail9.i665
  store i64 %343, ptr %322, align 8
  br label %cmpxchg.continue14.i667

cmpxchg.continue14.i667:                          ; preds = %cmpxchg.store_expected13.i666, %monotonic_fail9.i665
  %frombool15.i668 = zext i1 %344 to i8
  store i8 %frombool15.i668, ptr %cmpxchg.bool.i610, align 1
  br label %atomic.continue12.i660

cmpxchg.store_expected16.i662:                    ; preds = %acquire_fail10.i661
  store i64 %348, ptr %322, align 8
  br label %cmpxchg.continue17.i663

cmpxchg.continue17.i663:                          ; preds = %cmpxchg.store_expected16.i662, %acquire_fail10.i661
  %frombool18.i664 = zext i1 %349 to i8
  store i8 %frombool18.i664, ptr %cmpxchg.bool.i610, align 1
  br label %atomic.continue12.i660

cmpxchg.store_expected19.i657:                    ; preds = %seqcst_fail11.i656
  store i64 %353, ptr %322, align 8
  br label %cmpxchg.continue20.i658

cmpxchg.continue20.i658:                          ; preds = %cmpxchg.store_expected19.i657, %seqcst_fail11.i656
  %frombool21.i659 = zext i1 %354 to i8
  store i8 %frombool21.i659, ptr %cmpxchg.bool.i610, align 1
  br label %atomic.continue12.i660

monotonic_fail22.i651:                            ; preds = %release.i641
  %355 = load i64, ptr %322, align 8
  %356 = load i64, ptr %.atomictmp.i609, align 8
  %357 = cmpxchg weak ptr %this1.i611, i64 %355, i64 %356 release monotonic, align 8
  %358 = extractvalue { i64, i1 } %357, 0
  %359 = extractvalue { i64, i1 } %357, 1
  br i1 %359, label %cmpxchg.continue27.i653, label %cmpxchg.store_expected26.i652

acquire_fail23.i647:                              ; preds = %release.i641, %release.i641
  %360 = load i64, ptr %322, align 8
  %361 = load i64, ptr %.atomictmp.i609, align 8
  %362 = cmpxchg weak ptr %this1.i611, i64 %360, i64 %361 release acquire, align 8
  %363 = extractvalue { i64, i1 } %362, 0
  %364 = extractvalue { i64, i1 } %362, 1
  br i1 %364, label %cmpxchg.continue30.i649, label %cmpxchg.store_expected29.i648

seqcst_fail24.i642:                               ; preds = %release.i641
  %365 = load i64, ptr %322, align 8
  %366 = load i64, ptr %.atomictmp.i609, align 8
  %367 = cmpxchg weak ptr %this1.i611, i64 %365, i64 %366 release seq_cst, align 8
  %368 = extractvalue { i64, i1 } %367, 0
  %369 = extractvalue { i64, i1 } %367, 1
  br i1 %369, label %cmpxchg.continue33.i644, label %cmpxchg.store_expected32.i643

atomic.continue25.i646:                           ; preds = %cmpxchg.continue33.i644, %cmpxchg.continue30.i649, %cmpxchg.continue27.i653
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit683

cmpxchg.store_expected26.i652:                    ; preds = %monotonic_fail22.i651
  store i64 %358, ptr %322, align 8
  br label %cmpxchg.continue27.i653

cmpxchg.continue27.i653:                          ; preds = %cmpxchg.store_expected26.i652, %monotonic_fail22.i651
  %frombool28.i654 = zext i1 %359 to i8
  store i8 %frombool28.i654, ptr %cmpxchg.bool.i610, align 1
  br label %atomic.continue25.i646

cmpxchg.store_expected29.i648:                    ; preds = %acquire_fail23.i647
  store i64 %363, ptr %322, align 8
  br label %cmpxchg.continue30.i649

cmpxchg.continue30.i649:                          ; preds = %cmpxchg.store_expected29.i648, %acquire_fail23.i647
  %frombool31.i650 = zext i1 %364 to i8
  store i8 %frombool31.i650, ptr %cmpxchg.bool.i610, align 1
  br label %atomic.continue25.i646

cmpxchg.store_expected32.i643:                    ; preds = %seqcst_fail24.i642
  store i64 %368, ptr %322, align 8
  br label %cmpxchg.continue33.i644

cmpxchg.continue33.i644:                          ; preds = %cmpxchg.store_expected32.i643, %seqcst_fail24.i642
  %frombool34.i645 = zext i1 %369 to i8
  store i8 %frombool34.i645, ptr %cmpxchg.bool.i610, align 1
  br label %atomic.continue25.i646

monotonic_fail35.i637:                            ; preds = %acqrel.i627
  %370 = load i64, ptr %322, align 8
  %371 = load i64, ptr %.atomictmp.i609, align 8
  %372 = cmpxchg weak ptr %this1.i611, i64 %370, i64 %371 acq_rel monotonic, align 8
  %373 = extractvalue { i64, i1 } %372, 0
  %374 = extractvalue { i64, i1 } %372, 1
  br i1 %374, label %cmpxchg.continue40.i639, label %cmpxchg.store_expected39.i638

acquire_fail36.i633:                              ; preds = %acqrel.i627, %acqrel.i627
  %375 = load i64, ptr %322, align 8
  %376 = load i64, ptr %.atomictmp.i609, align 8
  %377 = cmpxchg weak ptr %this1.i611, i64 %375, i64 %376 acq_rel acquire, align 8
  %378 = extractvalue { i64, i1 } %377, 0
  %379 = extractvalue { i64, i1 } %377, 1
  br i1 %379, label %cmpxchg.continue43.i635, label %cmpxchg.store_expected42.i634

seqcst_fail37.i628:                               ; preds = %acqrel.i627
  %380 = load i64, ptr %322, align 8
  %381 = load i64, ptr %.atomictmp.i609, align 8
  %382 = cmpxchg weak ptr %this1.i611, i64 %380, i64 %381 acq_rel seq_cst, align 8
  %383 = extractvalue { i64, i1 } %382, 0
  %384 = extractvalue { i64, i1 } %382, 1
  br i1 %384, label %cmpxchg.continue46.i630, label %cmpxchg.store_expected45.i629

atomic.continue38.i632:                           ; preds = %cmpxchg.continue46.i630, %cmpxchg.continue43.i635, %cmpxchg.continue40.i639
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit683

cmpxchg.store_expected39.i638:                    ; preds = %monotonic_fail35.i637
  store i64 %373, ptr %322, align 8
  br label %cmpxchg.continue40.i639

cmpxchg.continue40.i639:                          ; preds = %cmpxchg.store_expected39.i638, %monotonic_fail35.i637
  %frombool41.i640 = zext i1 %374 to i8
  store i8 %frombool41.i640, ptr %cmpxchg.bool.i610, align 1
  br label %atomic.continue38.i632

cmpxchg.store_expected42.i634:                    ; preds = %acquire_fail36.i633
  store i64 %378, ptr %322, align 8
  br label %cmpxchg.continue43.i635

cmpxchg.continue43.i635:                          ; preds = %cmpxchg.store_expected42.i634, %acquire_fail36.i633
  %frombool44.i636 = zext i1 %379 to i8
  store i8 %frombool44.i636, ptr %cmpxchg.bool.i610, align 1
  br label %atomic.continue38.i632

cmpxchg.store_expected45.i629:                    ; preds = %seqcst_fail37.i628
  store i64 %383, ptr %322, align 8
  br label %cmpxchg.continue46.i630

cmpxchg.continue46.i630:                          ; preds = %cmpxchg.store_expected45.i629, %seqcst_fail37.i628
  %frombool47.i631 = zext i1 %384 to i8
  store i8 %frombool47.i631, ptr %cmpxchg.bool.i610, align 1
  br label %atomic.continue38.i632

monotonic_fail48.i623:                            ; preds = %seqcst.i612
  %385 = load i64, ptr %322, align 8
  %386 = load i64, ptr %.atomictmp.i609, align 8
  %387 = cmpxchg weak ptr %this1.i611, i64 %385, i64 %386 seq_cst monotonic, align 8
  %388 = extractvalue { i64, i1 } %387, 0
  %389 = extractvalue { i64, i1 } %387, 1
  br i1 %389, label %cmpxchg.continue53.i625, label %cmpxchg.store_expected52.i624

acquire_fail49.i619:                              ; preds = %seqcst.i612, %seqcst.i612
  %390 = load i64, ptr %322, align 8
  %391 = load i64, ptr %.atomictmp.i609, align 8
  %392 = cmpxchg weak ptr %this1.i611, i64 %390, i64 %391 seq_cst acquire, align 8
  %393 = extractvalue { i64, i1 } %392, 0
  %394 = extractvalue { i64, i1 } %392, 1
  br i1 %394, label %cmpxchg.continue56.i621, label %cmpxchg.store_expected55.i620

seqcst_fail50.i613:                               ; preds = %seqcst.i612
  %395 = load i64, ptr %322, align 8
  %396 = load i64, ptr %.atomictmp.i609, align 8
  %397 = cmpxchg weak ptr %this1.i611, i64 %395, i64 %396 seq_cst seq_cst, align 8
  %398 = extractvalue { i64, i1 } %397, 0
  %399 = extractvalue { i64, i1 } %397, 1
  br i1 %399, label %cmpxchg.continue59.i615, label %cmpxchg.store_expected58.i614

atomic.continue51.i617:                           ; preds = %cmpxchg.continue59.i615, %cmpxchg.continue56.i621, %cmpxchg.continue53.i625
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit683

cmpxchg.store_expected52.i624:                    ; preds = %monotonic_fail48.i623
  store i64 %388, ptr %322, align 8
  br label %cmpxchg.continue53.i625

cmpxchg.continue53.i625:                          ; preds = %cmpxchg.store_expected52.i624, %monotonic_fail48.i623
  %frombool54.i626 = zext i1 %389 to i8
  store i8 %frombool54.i626, ptr %cmpxchg.bool.i610, align 1
  br label %atomic.continue51.i617

cmpxchg.store_expected55.i620:                    ; preds = %acquire_fail49.i619
  store i64 %393, ptr %322, align 8
  br label %cmpxchg.continue56.i621

cmpxchg.continue56.i621:                          ; preds = %cmpxchg.store_expected55.i620, %acquire_fail49.i619
  %frombool57.i622 = zext i1 %394 to i8
  store i8 %frombool57.i622, ptr %cmpxchg.bool.i610, align 1
  br label %atomic.continue51.i617

cmpxchg.store_expected58.i614:                    ; preds = %seqcst_fail50.i613
  store i64 %398, ptr %322, align 8
  br label %cmpxchg.continue59.i615

cmpxchg.continue59.i615:                          ; preds = %cmpxchg.store_expected58.i614, %seqcst_fail50.i613
  %frombool60.i616 = zext i1 %399 to i8
  store i8 %frombool60.i616, ptr %cmpxchg.bool.i610, align 1
  br label %atomic.continue51.i617

_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit683: ; preds = %atomic.continue51.i617, %atomic.continue38.i632, %atomic.continue25.i646, %atomic.continue12.i660, %atomic.continue2.i674
  %400 = load i8, ptr %cmpxchg.bool.i610, align 1
  %tobool.i618 = trunc i8 %400 to i1
  %lnot115 = xor i1 %tobool.i618, true
  br i1 %lnot115, label %do.body107, label %do.end116, !llvm.loop !19

do.end116:                                        ; preds = %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit683
  %401 = load ptr, ptr %waitp.addr, align 8
  %cond117 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %401, i32 0, i32 1
  %402 = load ptr, ptr %cond117, align 8
  %cmp118 = icmp eq ptr %402, null
  br i1 %cmp118, label %if.then125, label %lor.lhs.false119

lor.lhs.false119:                                 ; preds = %do.end116
  %403 = load ptr, ptr %waitp.addr, align 8
  %cond120 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %403, i32 0, i32 1
  %404 = load ptr, ptr %cond120, align 8
  %405 = load ptr, ptr %waitp.addr, align 8
  %how121 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %405, i32 0, i32 0
  %406 = load ptr, ptr %how121, align 8
  %cmp122 = icmp eq ptr %406, @_ZN4abslL8kSharedSE
  %call124 = invoke noundef zeroext i1 @_ZN4abslL22EvalConditionAnnotatedEPKNS_9ConditionEPNS_5MutexEbbb(ptr noundef %404, ptr noundef %this1, i1 noundef zeroext true, i1 noundef zeroext false, i1 noundef zeroext %cmp122)
          to label %invoke.cont123 unwind label %lpad

invoke.cont123:                                   ; preds = %lor.lhs.false119
  br i1 %call124, label %if.then125, label %if.end126

if.then125:                                       ; preds = %invoke.cont123, %do.end116
  br label %for.end

if.end126:                                        ; preds = %invoke.cont123
  %407 = load ptr, ptr %waitp.addr, align 8
  invoke void @_ZN4absl5Mutex10UnlockSlowEPNS_15SynchWaitParamsE(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef %407) #16
          to label %invoke.cont127 unwind label %lpad

invoke.cont127:                                   ; preds = %if.end126
  %408 = load ptr, ptr %waitp.addr, align 8
  %thread128 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %408, i32 0, i32 4
  %409 = load ptr, ptr %thread128, align 8
  invoke void @_ZN4absl5Mutex5BlockEPNS_13base_internal14PerThreadSynchE(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef %409)
          to label %invoke.cont129 unwind label %lpad

invoke.cont129:                                   ; preds = %invoke.cont127
  %410 = load i32, ptr %flags.addr, align 4
  %or130 = or i32 %410, 1
  store i32 %or130, ptr %flags.addr, align 4
  store i32 0, ptr %c, align 4
  br label %if.end131

if.end131:                                        ; preds = %invoke.cont129, %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit364
  br label %if.end186

if.else132:                                       ; preds = %invoke.cont90
  %411 = load i64, ptr %v, align 8
  %and133 = and i64 %411, 64
  %cmp134 = icmp eq i64 %and133, 0
  br i1 %cmp134, label %land.lhs.true135, label %if.end185

land.lhs.true135:                                 ; preds = %if.else132
  %mu_136 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %412 = load i64, ptr %v, align 8
  %413 = load i32, ptr %flags.addr, align 4
  %and137 = and i32 %413, 1
  %call139 = invoke noundef i64 @_ZN4abslL24ClearDesignatedWakerMaskEi(i32 noundef %and137)
          to label %invoke.cont138 unwind label %lpad

invoke.cont138:                                   ; preds = %land.lhs.true135
  %and140 = and i64 %412, %call139
  %or141 = or i64 %and140, 64
  %or142 = or i64 %or141, 4
  store ptr %mu_136, ptr %this.addr.i280, align 8
  store ptr %v, ptr %__i1.addr.i, align 8
  store i64 %or142, ptr %__i2.addr.i, align 8
  store i32 2, ptr %__m1.addr.i, align 4
  store i32 0, ptr %__m2.addr.i, align 4
  %this1.i281 = load ptr, ptr %this.addr.i280, align 8
  %414 = load i32, ptr %__m1.addr.i, align 4
  %415 = load ptr, ptr %__i1.addr.i, align 8
  %416 = load i64, ptr %__i2.addr.i, align 8
  store i64 %416, ptr %.atomictmp.i, align 8
  %417 = load i32, ptr %__m2.addr.i, align 4
  switch i32 %414, label %monotonic.i284 [
    i32 1, label %acquire.i283
    i32 2, label %acquire.i283
    i32 3, label %release.i
    i32 4, label %acqrel.i
    i32 5, label %seqcst.i282
  ]

monotonic.i284:                                   ; preds = %invoke.cont138
  switch i32 %417, label %monotonic_fail.i [
    i32 1, label %acquire_fail.i
    i32 2, label %acquire_fail.i
    i32 5, label %seqcst_fail.i
  ]

acquire.i283:                                     ; preds = %invoke.cont138, %invoke.cont138
  switch i32 %417, label %monotonic_fail9.i [
    i32 1, label %acquire_fail10.i
    i32 2, label %acquire_fail10.i
    i32 5, label %seqcst_fail11.i
  ]

release.i:                                        ; preds = %invoke.cont138
  switch i32 %417, label %monotonic_fail22.i [
    i32 1, label %acquire_fail23.i
    i32 2, label %acquire_fail23.i
    i32 5, label %seqcst_fail24.i
  ]

acqrel.i:                                         ; preds = %invoke.cont138
  switch i32 %417, label %monotonic_fail35.i [
    i32 1, label %acquire_fail36.i
    i32 2, label %acquire_fail36.i
    i32 5, label %seqcst_fail37.i
  ]

seqcst.i282:                                      ; preds = %invoke.cont138
  switch i32 %417, label %monotonic_fail48.i [
    i32 1, label %acquire_fail49.i
    i32 2, label %acquire_fail49.i
    i32 5, label %seqcst_fail50.i
  ]

monotonic_fail.i:                                 ; preds = %monotonic.i284
  %418 = load i64, ptr %415, align 8
  %419 = load i64, ptr %.atomictmp.i, align 8
  %420 = cmpxchg ptr %this1.i281, i64 %418, i64 %419 monotonic monotonic, align 8
  %421 = extractvalue { i64, i1 } %420, 0
  %422 = extractvalue { i64, i1 } %420, 1
  br i1 %422, label %cmpxchg.continue.i, label %cmpxchg.store_expected.i

acquire_fail.i:                                   ; preds = %monotonic.i284, %monotonic.i284
  %423 = load i64, ptr %415, align 8
  %424 = load i64, ptr %.atomictmp.i, align 8
  %425 = cmpxchg ptr %this1.i281, i64 %423, i64 %424 monotonic acquire, align 8
  %426 = extractvalue { i64, i1 } %425, 0
  %427 = extractvalue { i64, i1 } %425, 1
  br i1 %427, label %cmpxchg.continue4.i, label %cmpxchg.store_expected3.i

seqcst_fail.i:                                    ; preds = %monotonic.i284
  %428 = load i64, ptr %415, align 8
  %429 = load i64, ptr %.atomictmp.i, align 8
  %430 = cmpxchg ptr %this1.i281, i64 %428, i64 %429 monotonic seq_cst, align 8
  %431 = extractvalue { i64, i1 } %430, 0
  %432 = extractvalue { i64, i1 } %430, 1
  br i1 %432, label %cmpxchg.continue7.i, label %cmpxchg.store_expected6.i

atomic.continue2.i:                               ; preds = %cmpxchg.continue7.i, %cmpxchg.continue4.i, %cmpxchg.continue.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected.i:                         ; preds = %monotonic_fail.i
  store i64 %421, ptr %415, align 8
  br label %cmpxchg.continue.i

cmpxchg.continue.i:                               ; preds = %cmpxchg.store_expected.i, %monotonic_fail.i
  %frombool.i = zext i1 %422 to i8
  store i8 %frombool.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected3.i:                        ; preds = %acquire_fail.i
  store i64 %426, ptr %415, align 8
  br label %cmpxchg.continue4.i

cmpxchg.continue4.i:                              ; preds = %cmpxchg.store_expected3.i, %acquire_fail.i
  %frombool5.i = zext i1 %427 to i8
  store i8 %frombool5.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected6.i:                        ; preds = %seqcst_fail.i
  store i64 %431, ptr %415, align 8
  br label %cmpxchg.continue7.i

cmpxchg.continue7.i:                              ; preds = %cmpxchg.store_expected6.i, %seqcst_fail.i
  %frombool8.i = zext i1 %432 to i8
  store i8 %frombool8.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

monotonic_fail9.i:                                ; preds = %acquire.i283
  %433 = load i64, ptr %415, align 8
  %434 = load i64, ptr %.atomictmp.i, align 8
  %435 = cmpxchg ptr %this1.i281, i64 %433, i64 %434 acquire monotonic, align 8
  %436 = extractvalue { i64, i1 } %435, 0
  %437 = extractvalue { i64, i1 } %435, 1
  br i1 %437, label %cmpxchg.continue14.i, label %cmpxchg.store_expected13.i

acquire_fail10.i:                                 ; preds = %acquire.i283, %acquire.i283
  %438 = load i64, ptr %415, align 8
  %439 = load i64, ptr %.atomictmp.i, align 8
  %440 = cmpxchg ptr %this1.i281, i64 %438, i64 %439 acquire acquire, align 8
  %441 = extractvalue { i64, i1 } %440, 0
  %442 = extractvalue { i64, i1 } %440, 1
  br i1 %442, label %cmpxchg.continue17.i, label %cmpxchg.store_expected16.i

seqcst_fail11.i:                                  ; preds = %acquire.i283
  %443 = load i64, ptr %415, align 8
  %444 = load i64, ptr %.atomictmp.i, align 8
  %445 = cmpxchg ptr %this1.i281, i64 %443, i64 %444 acquire seq_cst, align 8
  %446 = extractvalue { i64, i1 } %445, 0
  %447 = extractvalue { i64, i1 } %445, 1
  br i1 %447, label %cmpxchg.continue20.i, label %cmpxchg.store_expected19.i

atomic.continue12.i:                              ; preds = %cmpxchg.continue20.i, %cmpxchg.continue17.i, %cmpxchg.continue14.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected13.i:                       ; preds = %monotonic_fail9.i
  store i64 %436, ptr %415, align 8
  br label %cmpxchg.continue14.i

cmpxchg.continue14.i:                             ; preds = %cmpxchg.store_expected13.i, %monotonic_fail9.i
  %frombool15.i = zext i1 %437 to i8
  store i8 %frombool15.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected16.i:                       ; preds = %acquire_fail10.i
  store i64 %441, ptr %415, align 8
  br label %cmpxchg.continue17.i

cmpxchg.continue17.i:                             ; preds = %cmpxchg.store_expected16.i, %acquire_fail10.i
  %frombool18.i = zext i1 %442 to i8
  store i8 %frombool18.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected19.i:                       ; preds = %seqcst_fail11.i
  store i64 %446, ptr %415, align 8
  br label %cmpxchg.continue20.i

cmpxchg.continue20.i:                             ; preds = %cmpxchg.store_expected19.i, %seqcst_fail11.i
  %frombool21.i = zext i1 %447 to i8
  store i8 %frombool21.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

monotonic_fail22.i:                               ; preds = %release.i
  %448 = load i64, ptr %415, align 8
  %449 = load i64, ptr %.atomictmp.i, align 8
  %450 = cmpxchg ptr %this1.i281, i64 %448, i64 %449 release monotonic, align 8
  %451 = extractvalue { i64, i1 } %450, 0
  %452 = extractvalue { i64, i1 } %450, 1
  br i1 %452, label %cmpxchg.continue27.i, label %cmpxchg.store_expected26.i

acquire_fail23.i:                                 ; preds = %release.i, %release.i
  %453 = load i64, ptr %415, align 8
  %454 = load i64, ptr %.atomictmp.i, align 8
  %455 = cmpxchg ptr %this1.i281, i64 %453, i64 %454 release acquire, align 8
  %456 = extractvalue { i64, i1 } %455, 0
  %457 = extractvalue { i64, i1 } %455, 1
  br i1 %457, label %cmpxchg.continue30.i, label %cmpxchg.store_expected29.i

seqcst_fail24.i:                                  ; preds = %release.i
  %458 = load i64, ptr %415, align 8
  %459 = load i64, ptr %.atomictmp.i, align 8
  %460 = cmpxchg ptr %this1.i281, i64 %458, i64 %459 release seq_cst, align 8
  %461 = extractvalue { i64, i1 } %460, 0
  %462 = extractvalue { i64, i1 } %460, 1
  br i1 %462, label %cmpxchg.continue33.i, label %cmpxchg.store_expected32.i

atomic.continue25.i:                              ; preds = %cmpxchg.continue33.i, %cmpxchg.continue30.i, %cmpxchg.continue27.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected26.i:                       ; preds = %monotonic_fail22.i
  store i64 %451, ptr %415, align 8
  br label %cmpxchg.continue27.i

cmpxchg.continue27.i:                             ; preds = %cmpxchg.store_expected26.i, %monotonic_fail22.i
  %frombool28.i = zext i1 %452 to i8
  store i8 %frombool28.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected29.i:                       ; preds = %acquire_fail23.i
  store i64 %456, ptr %415, align 8
  br label %cmpxchg.continue30.i

cmpxchg.continue30.i:                             ; preds = %cmpxchg.store_expected29.i, %acquire_fail23.i
  %frombool31.i = zext i1 %457 to i8
  store i8 %frombool31.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected32.i:                       ; preds = %seqcst_fail24.i
  store i64 %461, ptr %415, align 8
  br label %cmpxchg.continue33.i

cmpxchg.continue33.i:                             ; preds = %cmpxchg.store_expected32.i, %seqcst_fail24.i
  %frombool34.i = zext i1 %462 to i8
  store i8 %frombool34.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

monotonic_fail35.i:                               ; preds = %acqrel.i
  %463 = load i64, ptr %415, align 8
  %464 = load i64, ptr %.atomictmp.i, align 8
  %465 = cmpxchg ptr %this1.i281, i64 %463, i64 %464 acq_rel monotonic, align 8
  %466 = extractvalue { i64, i1 } %465, 0
  %467 = extractvalue { i64, i1 } %465, 1
  br i1 %467, label %cmpxchg.continue40.i, label %cmpxchg.store_expected39.i

acquire_fail36.i:                                 ; preds = %acqrel.i, %acqrel.i
  %468 = load i64, ptr %415, align 8
  %469 = load i64, ptr %.atomictmp.i, align 8
  %470 = cmpxchg ptr %this1.i281, i64 %468, i64 %469 acq_rel acquire, align 8
  %471 = extractvalue { i64, i1 } %470, 0
  %472 = extractvalue { i64, i1 } %470, 1
  br i1 %472, label %cmpxchg.continue43.i, label %cmpxchg.store_expected42.i

seqcst_fail37.i:                                  ; preds = %acqrel.i
  %473 = load i64, ptr %415, align 8
  %474 = load i64, ptr %.atomictmp.i, align 8
  %475 = cmpxchg ptr %this1.i281, i64 %473, i64 %474 acq_rel seq_cst, align 8
  %476 = extractvalue { i64, i1 } %475, 0
  %477 = extractvalue { i64, i1 } %475, 1
  br i1 %477, label %cmpxchg.continue46.i, label %cmpxchg.store_expected45.i

atomic.continue38.i:                              ; preds = %cmpxchg.continue46.i, %cmpxchg.continue43.i, %cmpxchg.continue40.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected39.i:                       ; preds = %monotonic_fail35.i
  store i64 %466, ptr %415, align 8
  br label %cmpxchg.continue40.i

cmpxchg.continue40.i:                             ; preds = %cmpxchg.store_expected39.i, %monotonic_fail35.i
  %frombool41.i = zext i1 %467 to i8
  store i8 %frombool41.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected42.i:                       ; preds = %acquire_fail36.i
  store i64 %471, ptr %415, align 8
  br label %cmpxchg.continue43.i

cmpxchg.continue43.i:                             ; preds = %cmpxchg.store_expected42.i, %acquire_fail36.i
  %frombool44.i = zext i1 %472 to i8
  store i8 %frombool44.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected45.i:                       ; preds = %seqcst_fail37.i
  store i64 %476, ptr %415, align 8
  br label %cmpxchg.continue46.i

cmpxchg.continue46.i:                             ; preds = %cmpxchg.store_expected45.i, %seqcst_fail37.i
  %frombool47.i = zext i1 %477 to i8
  store i8 %frombool47.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

monotonic_fail48.i:                               ; preds = %seqcst.i282
  %478 = load i64, ptr %415, align 8
  %479 = load i64, ptr %.atomictmp.i, align 8
  %480 = cmpxchg ptr %this1.i281, i64 %478, i64 %479 seq_cst monotonic, align 8
  %481 = extractvalue { i64, i1 } %480, 0
  %482 = extractvalue { i64, i1 } %480, 1
  br i1 %482, label %cmpxchg.continue53.i, label %cmpxchg.store_expected52.i

acquire_fail49.i:                                 ; preds = %seqcst.i282, %seqcst.i282
  %483 = load i64, ptr %415, align 8
  %484 = load i64, ptr %.atomictmp.i, align 8
  %485 = cmpxchg ptr %this1.i281, i64 %483, i64 %484 seq_cst acquire, align 8
  %486 = extractvalue { i64, i1 } %485, 0
  %487 = extractvalue { i64, i1 } %485, 1
  br i1 %487, label %cmpxchg.continue56.i, label %cmpxchg.store_expected55.i

seqcst_fail50.i:                                  ; preds = %seqcst.i282
  %488 = load i64, ptr %415, align 8
  %489 = load i64, ptr %.atomictmp.i, align 8
  %490 = cmpxchg ptr %this1.i281, i64 %488, i64 %489 seq_cst seq_cst, align 8
  %491 = extractvalue { i64, i1 } %490, 0
  %492 = extractvalue { i64, i1 } %490, 1
  br i1 %492, label %cmpxchg.continue59.i, label %cmpxchg.store_expected58.i

atomic.continue51.i:                              ; preds = %cmpxchg.continue59.i, %cmpxchg.continue56.i, %cmpxchg.continue53.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected52.i:                       ; preds = %monotonic_fail48.i
  store i64 %481, ptr %415, align 8
  br label %cmpxchg.continue53.i

cmpxchg.continue53.i:                             ; preds = %cmpxchg.store_expected52.i, %monotonic_fail48.i
  %frombool54.i = zext i1 %482 to i8
  store i8 %frombool54.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected55.i:                       ; preds = %acquire_fail49.i
  store i64 %486, ptr %415, align 8
  br label %cmpxchg.continue56.i

cmpxchg.continue56.i:                             ; preds = %cmpxchg.store_expected55.i, %acquire_fail49.i
  %frombool57.i = zext i1 %487 to i8
  store i8 %frombool57.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected58.i:                       ; preds = %seqcst_fail50.i
  store i64 %491, ptr %415, align 8
  br label %cmpxchg.continue59.i

cmpxchg.continue59.i:                             ; preds = %cmpxchg.store_expected58.i, %seqcst_fail50.i
  %frombool60.i = zext i1 %492 to i8
  store i8 %frombool60.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit: ; preds = %atomic.continue51.i, %atomic.continue38.i, %atomic.continue25.i, %atomic.continue12.i, %atomic.continue2.i
  %493 = load i8, ptr %cmpxchg.bool.i, align 1
  %tobool.i = trunc i8 %493 to i1
  br i1 %tobool.i, label %if.then144, label %if.end185

if.then144:                                       ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit
  %494 = load i64, ptr %v, align 8
  %call147 = invoke noundef ptr @_ZN4abslL17GetPerThreadSynchEl(i64 noundef %494)
          to label %invoke.cont146 unwind label %lpad

invoke.cont146:                                   ; preds = %if.then144
  store ptr %call147, ptr %h145, align 8
  %495 = load ptr, ptr %h145, align 8
  %496 = load ptr, ptr %waitp.addr, align 8
  %497 = load i64, ptr %v, align 8
  %498 = load i32, ptr %flags.addr, align 4
  %call150 = invoke noundef ptr @_ZN4abslL7EnqueueEPNS_13base_internal14PerThreadSynchEPNS_15SynchWaitParamsEli(ptr noundef %495, ptr noundef %496, i64 noundef %497, i32 noundef %498)
          to label %invoke.cont149 unwind label %lpad

invoke.cont149:                                   ; preds = %invoke.cont146
  store ptr %call150, ptr %new_h148, align 8
  store i64 0, ptr %wr_wait, align 8
  br label %do.body151

do.body151:                                       ; preds = %invoke.cont149
  %499 = load ptr, ptr %new_h148, align 8
  %cmp152 = icmp ne ptr %499, null
  %lnot153 = xor i1 %cmp152, true
  br i1 %lnot153, label %if.then154, label %if.end163

if.then154:                                       ; preds = %do.body151
  br label %do.body155

do.body155:                                       ; preds = %if.then154
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename156, align 8
  invoke void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 2046, ptr noundef @.str.1, ptr noundef @.str.11, ptr noundef @.str.13)
          to label %invoke.cont157 unwind label %lpad

invoke.cont157:                                   ; preds = %do.body155
  br label %do.body158

do.body158:                                       ; preds = %invoke.cont157
  unreachable

do.cond159:                                       ; No predecessors!
  br label %do.end160

do.end160:                                        ; preds = %do.cond159
  br label %do.cond161

do.cond161:                                       ; preds = %do.end160
  br label %do.end162

do.end162:                                        ; preds = %do.cond161
  br label %if.end163

if.end163:                                        ; preds = %do.end162, %do.body151
  br label %do.cond164

do.cond164:                                       ; preds = %if.end163
  br label %do.end165

do.end165:                                        ; preds = %do.cond164
  %500 = load ptr, ptr %waitp.addr, align 8
  %how166 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %500, i32 0, i32 0
  %501 = load ptr, ptr %how166, align 8
  %cmp167 = icmp eq ptr %501, @_ZN4abslL11kExclusiveSE
  br i1 %cmp167, label %land.lhs.true168, label %if.end172

land.lhs.true168:                                 ; preds = %do.end165
  %502 = load i64, ptr %v, align 8
  %and169 = and i64 %502, 1
  %cmp170 = icmp ne i64 %and169, 0
  br i1 %cmp170, label %if.then171, label %if.end172

if.then171:                                       ; preds = %land.lhs.true168
  store i64 32, ptr %wr_wait, align 8
  br label %if.end172

if.end172:                                        ; preds = %if.then171, %land.lhs.true168, %do.end165
  br label %do.body173

do.body173:                                       ; preds = %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit, %if.end172
  %mu_174 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  store ptr %mu_174, ptr %this.addr.i, align 8
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %503 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %503, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %504 = load i32, ptr %__m.addr.i, align 4
  switch i32 %504, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %do.body173
  %505 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %505, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %do.body173, %do.body173
  %506 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %506, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %do.body173
  %507 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %507, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %508 = load i64, ptr %atomic-temp.i, align 8
  store i64 %508, ptr %v, align 8
  br label %do.cond176

do.cond176:                                       ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  %mu_177 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %509 = load i64, ptr %v, align 8
  %and178 = and i64 %509, 191
  %or179 = or i64 %and178, 4
  %510 = load i64, ptr %wr_wait, align 8
  %or180 = or i64 %or179, %510
  %511 = load ptr, ptr %new_h148, align 8
  %512 = ptrtoint ptr %511 to i64
  %or181 = or i64 %or180, %512
  store ptr %mu_177, ptr %this.addr.i525, align 8
  store ptr %v, ptr %__i1.addr.i526, align 8
  store i64 %or181, ptr %__i2.addr.i527, align 8
  store i32 3, ptr %__m1.addr.i528, align 4
  store i32 0, ptr %__m2.addr.i529, align 4
  %this1.i532 = load ptr, ptr %this.addr.i525, align 8
  %513 = load i32, ptr %__m1.addr.i528, align 4
  %514 = load ptr, ptr %__i1.addr.i526, align 8
  %515 = load i64, ptr %__i2.addr.i527, align 8
  store i64 %515, ptr %.atomictmp.i530, align 8
  %516 = load i32, ptr %__m2.addr.i529, align 4
  switch i32 %513, label %monotonic.i590 [
    i32 1, label %acquire.i576
    i32 2, label %acquire.i576
    i32 3, label %release.i562
    i32 4, label %acqrel.i548
    i32 5, label %seqcst.i533
  ]

monotonic.i590:                                   ; preds = %do.cond176
  switch i32 %516, label %monotonic_fail.i600 [
    i32 1, label %acquire_fail.i596
    i32 2, label %acquire_fail.i596
    i32 5, label %seqcst_fail.i591
  ]

acquire.i576:                                     ; preds = %do.cond176, %do.cond176
  switch i32 %516, label %monotonic_fail9.i586 [
    i32 1, label %acquire_fail10.i582
    i32 2, label %acquire_fail10.i582
    i32 5, label %seqcst_fail11.i577
  ]

release.i562:                                     ; preds = %do.cond176
  switch i32 %516, label %monotonic_fail22.i572 [
    i32 1, label %acquire_fail23.i568
    i32 2, label %acquire_fail23.i568
    i32 5, label %seqcst_fail24.i563
  ]

acqrel.i548:                                      ; preds = %do.cond176
  switch i32 %516, label %monotonic_fail35.i558 [
    i32 1, label %acquire_fail36.i554
    i32 2, label %acquire_fail36.i554
    i32 5, label %seqcst_fail37.i549
  ]

seqcst.i533:                                      ; preds = %do.cond176
  switch i32 %516, label %monotonic_fail48.i544 [
    i32 1, label %acquire_fail49.i540
    i32 2, label %acquire_fail49.i540
    i32 5, label %seqcst_fail50.i534
  ]

monotonic_fail.i600:                              ; preds = %monotonic.i590
  %517 = load i64, ptr %514, align 8
  %518 = load i64, ptr %.atomictmp.i530, align 8
  %519 = cmpxchg weak ptr %this1.i532, i64 %517, i64 %518 monotonic monotonic, align 8
  %520 = extractvalue { i64, i1 } %519, 0
  %521 = extractvalue { i64, i1 } %519, 1
  br i1 %521, label %cmpxchg.continue.i602, label %cmpxchg.store_expected.i601

acquire_fail.i596:                                ; preds = %monotonic.i590, %monotonic.i590
  %522 = load i64, ptr %514, align 8
  %523 = load i64, ptr %.atomictmp.i530, align 8
  %524 = cmpxchg weak ptr %this1.i532, i64 %522, i64 %523 monotonic acquire, align 8
  %525 = extractvalue { i64, i1 } %524, 0
  %526 = extractvalue { i64, i1 } %524, 1
  br i1 %526, label %cmpxchg.continue4.i598, label %cmpxchg.store_expected3.i597

seqcst_fail.i591:                                 ; preds = %monotonic.i590
  %527 = load i64, ptr %514, align 8
  %528 = load i64, ptr %.atomictmp.i530, align 8
  %529 = cmpxchg weak ptr %this1.i532, i64 %527, i64 %528 monotonic seq_cst, align 8
  %530 = extractvalue { i64, i1 } %529, 0
  %531 = extractvalue { i64, i1 } %529, 1
  br i1 %531, label %cmpxchg.continue7.i593, label %cmpxchg.store_expected6.i592

atomic.continue2.i595:                            ; preds = %cmpxchg.continue7.i593, %cmpxchg.continue4.i598, %cmpxchg.continue.i602
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected.i601:                      ; preds = %monotonic_fail.i600
  store i64 %520, ptr %514, align 8
  br label %cmpxchg.continue.i602

cmpxchg.continue.i602:                            ; preds = %cmpxchg.store_expected.i601, %monotonic_fail.i600
  %frombool.i603 = zext i1 %521 to i8
  store i8 %frombool.i603, ptr %cmpxchg.bool.i531, align 1
  br label %atomic.continue2.i595

cmpxchg.store_expected3.i597:                     ; preds = %acquire_fail.i596
  store i64 %525, ptr %514, align 8
  br label %cmpxchg.continue4.i598

cmpxchg.continue4.i598:                           ; preds = %cmpxchg.store_expected3.i597, %acquire_fail.i596
  %frombool5.i599 = zext i1 %526 to i8
  store i8 %frombool5.i599, ptr %cmpxchg.bool.i531, align 1
  br label %atomic.continue2.i595

cmpxchg.store_expected6.i592:                     ; preds = %seqcst_fail.i591
  store i64 %530, ptr %514, align 8
  br label %cmpxchg.continue7.i593

cmpxchg.continue7.i593:                           ; preds = %cmpxchg.store_expected6.i592, %seqcst_fail.i591
  %frombool8.i594 = zext i1 %531 to i8
  store i8 %frombool8.i594, ptr %cmpxchg.bool.i531, align 1
  br label %atomic.continue2.i595

monotonic_fail9.i586:                             ; preds = %acquire.i576
  %532 = load i64, ptr %514, align 8
  %533 = load i64, ptr %.atomictmp.i530, align 8
  %534 = cmpxchg weak ptr %this1.i532, i64 %532, i64 %533 acquire monotonic, align 8
  %535 = extractvalue { i64, i1 } %534, 0
  %536 = extractvalue { i64, i1 } %534, 1
  br i1 %536, label %cmpxchg.continue14.i588, label %cmpxchg.store_expected13.i587

acquire_fail10.i582:                              ; preds = %acquire.i576, %acquire.i576
  %537 = load i64, ptr %514, align 8
  %538 = load i64, ptr %.atomictmp.i530, align 8
  %539 = cmpxchg weak ptr %this1.i532, i64 %537, i64 %538 acquire acquire, align 8
  %540 = extractvalue { i64, i1 } %539, 0
  %541 = extractvalue { i64, i1 } %539, 1
  br i1 %541, label %cmpxchg.continue17.i584, label %cmpxchg.store_expected16.i583

seqcst_fail11.i577:                               ; preds = %acquire.i576
  %542 = load i64, ptr %514, align 8
  %543 = load i64, ptr %.atomictmp.i530, align 8
  %544 = cmpxchg weak ptr %this1.i532, i64 %542, i64 %543 acquire seq_cst, align 8
  %545 = extractvalue { i64, i1 } %544, 0
  %546 = extractvalue { i64, i1 } %544, 1
  br i1 %546, label %cmpxchg.continue20.i579, label %cmpxchg.store_expected19.i578

atomic.continue12.i581:                           ; preds = %cmpxchg.continue20.i579, %cmpxchg.continue17.i584, %cmpxchg.continue14.i588
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected13.i587:                    ; preds = %monotonic_fail9.i586
  store i64 %535, ptr %514, align 8
  br label %cmpxchg.continue14.i588

cmpxchg.continue14.i588:                          ; preds = %cmpxchg.store_expected13.i587, %monotonic_fail9.i586
  %frombool15.i589 = zext i1 %536 to i8
  store i8 %frombool15.i589, ptr %cmpxchg.bool.i531, align 1
  br label %atomic.continue12.i581

cmpxchg.store_expected16.i583:                    ; preds = %acquire_fail10.i582
  store i64 %540, ptr %514, align 8
  br label %cmpxchg.continue17.i584

cmpxchg.continue17.i584:                          ; preds = %cmpxchg.store_expected16.i583, %acquire_fail10.i582
  %frombool18.i585 = zext i1 %541 to i8
  store i8 %frombool18.i585, ptr %cmpxchg.bool.i531, align 1
  br label %atomic.continue12.i581

cmpxchg.store_expected19.i578:                    ; preds = %seqcst_fail11.i577
  store i64 %545, ptr %514, align 8
  br label %cmpxchg.continue20.i579

cmpxchg.continue20.i579:                          ; preds = %cmpxchg.store_expected19.i578, %seqcst_fail11.i577
  %frombool21.i580 = zext i1 %546 to i8
  store i8 %frombool21.i580, ptr %cmpxchg.bool.i531, align 1
  br label %atomic.continue12.i581

monotonic_fail22.i572:                            ; preds = %release.i562
  %547 = load i64, ptr %514, align 8
  %548 = load i64, ptr %.atomictmp.i530, align 8
  %549 = cmpxchg weak ptr %this1.i532, i64 %547, i64 %548 release monotonic, align 8
  %550 = extractvalue { i64, i1 } %549, 0
  %551 = extractvalue { i64, i1 } %549, 1
  br i1 %551, label %cmpxchg.continue27.i574, label %cmpxchg.store_expected26.i573

acquire_fail23.i568:                              ; preds = %release.i562, %release.i562
  %552 = load i64, ptr %514, align 8
  %553 = load i64, ptr %.atomictmp.i530, align 8
  %554 = cmpxchg weak ptr %this1.i532, i64 %552, i64 %553 release acquire, align 8
  %555 = extractvalue { i64, i1 } %554, 0
  %556 = extractvalue { i64, i1 } %554, 1
  br i1 %556, label %cmpxchg.continue30.i570, label %cmpxchg.store_expected29.i569

seqcst_fail24.i563:                               ; preds = %release.i562
  %557 = load i64, ptr %514, align 8
  %558 = load i64, ptr %.atomictmp.i530, align 8
  %559 = cmpxchg weak ptr %this1.i532, i64 %557, i64 %558 release seq_cst, align 8
  %560 = extractvalue { i64, i1 } %559, 0
  %561 = extractvalue { i64, i1 } %559, 1
  br i1 %561, label %cmpxchg.continue33.i565, label %cmpxchg.store_expected32.i564

atomic.continue25.i567:                           ; preds = %cmpxchg.continue33.i565, %cmpxchg.continue30.i570, %cmpxchg.continue27.i574
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected26.i573:                    ; preds = %monotonic_fail22.i572
  store i64 %550, ptr %514, align 8
  br label %cmpxchg.continue27.i574

cmpxchg.continue27.i574:                          ; preds = %cmpxchg.store_expected26.i573, %monotonic_fail22.i572
  %frombool28.i575 = zext i1 %551 to i8
  store i8 %frombool28.i575, ptr %cmpxchg.bool.i531, align 1
  br label %atomic.continue25.i567

cmpxchg.store_expected29.i569:                    ; preds = %acquire_fail23.i568
  store i64 %555, ptr %514, align 8
  br label %cmpxchg.continue30.i570

cmpxchg.continue30.i570:                          ; preds = %cmpxchg.store_expected29.i569, %acquire_fail23.i568
  %frombool31.i571 = zext i1 %556 to i8
  store i8 %frombool31.i571, ptr %cmpxchg.bool.i531, align 1
  br label %atomic.continue25.i567

cmpxchg.store_expected32.i564:                    ; preds = %seqcst_fail24.i563
  store i64 %560, ptr %514, align 8
  br label %cmpxchg.continue33.i565

cmpxchg.continue33.i565:                          ; preds = %cmpxchg.store_expected32.i564, %seqcst_fail24.i563
  %frombool34.i566 = zext i1 %561 to i8
  store i8 %frombool34.i566, ptr %cmpxchg.bool.i531, align 1
  br label %atomic.continue25.i567

monotonic_fail35.i558:                            ; preds = %acqrel.i548
  %562 = load i64, ptr %514, align 8
  %563 = load i64, ptr %.atomictmp.i530, align 8
  %564 = cmpxchg weak ptr %this1.i532, i64 %562, i64 %563 acq_rel monotonic, align 8
  %565 = extractvalue { i64, i1 } %564, 0
  %566 = extractvalue { i64, i1 } %564, 1
  br i1 %566, label %cmpxchg.continue40.i560, label %cmpxchg.store_expected39.i559

acquire_fail36.i554:                              ; preds = %acqrel.i548, %acqrel.i548
  %567 = load i64, ptr %514, align 8
  %568 = load i64, ptr %.atomictmp.i530, align 8
  %569 = cmpxchg weak ptr %this1.i532, i64 %567, i64 %568 acq_rel acquire, align 8
  %570 = extractvalue { i64, i1 } %569, 0
  %571 = extractvalue { i64, i1 } %569, 1
  br i1 %571, label %cmpxchg.continue43.i556, label %cmpxchg.store_expected42.i555

seqcst_fail37.i549:                               ; preds = %acqrel.i548
  %572 = load i64, ptr %514, align 8
  %573 = load i64, ptr %.atomictmp.i530, align 8
  %574 = cmpxchg weak ptr %this1.i532, i64 %572, i64 %573 acq_rel seq_cst, align 8
  %575 = extractvalue { i64, i1 } %574, 0
  %576 = extractvalue { i64, i1 } %574, 1
  br i1 %576, label %cmpxchg.continue46.i551, label %cmpxchg.store_expected45.i550

atomic.continue38.i553:                           ; preds = %cmpxchg.continue46.i551, %cmpxchg.continue43.i556, %cmpxchg.continue40.i560
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected39.i559:                    ; preds = %monotonic_fail35.i558
  store i64 %565, ptr %514, align 8
  br label %cmpxchg.continue40.i560

cmpxchg.continue40.i560:                          ; preds = %cmpxchg.store_expected39.i559, %monotonic_fail35.i558
  %frombool41.i561 = zext i1 %566 to i8
  store i8 %frombool41.i561, ptr %cmpxchg.bool.i531, align 1
  br label %atomic.continue38.i553

cmpxchg.store_expected42.i555:                    ; preds = %acquire_fail36.i554
  store i64 %570, ptr %514, align 8
  br label %cmpxchg.continue43.i556

cmpxchg.continue43.i556:                          ; preds = %cmpxchg.store_expected42.i555, %acquire_fail36.i554
  %frombool44.i557 = zext i1 %571 to i8
  store i8 %frombool44.i557, ptr %cmpxchg.bool.i531, align 1
  br label %atomic.continue38.i553

cmpxchg.store_expected45.i550:                    ; preds = %seqcst_fail37.i549
  store i64 %575, ptr %514, align 8
  br label %cmpxchg.continue46.i551

cmpxchg.continue46.i551:                          ; preds = %cmpxchg.store_expected45.i550, %seqcst_fail37.i549
  %frombool47.i552 = zext i1 %576 to i8
  store i8 %frombool47.i552, ptr %cmpxchg.bool.i531, align 1
  br label %atomic.continue38.i553

monotonic_fail48.i544:                            ; preds = %seqcst.i533
  %577 = load i64, ptr %514, align 8
  %578 = load i64, ptr %.atomictmp.i530, align 8
  %579 = cmpxchg weak ptr %this1.i532, i64 %577, i64 %578 seq_cst monotonic, align 8
  %580 = extractvalue { i64, i1 } %579, 0
  %581 = extractvalue { i64, i1 } %579, 1
  br i1 %581, label %cmpxchg.continue53.i546, label %cmpxchg.store_expected52.i545

acquire_fail49.i540:                              ; preds = %seqcst.i533, %seqcst.i533
  %582 = load i64, ptr %514, align 8
  %583 = load i64, ptr %.atomictmp.i530, align 8
  %584 = cmpxchg weak ptr %this1.i532, i64 %582, i64 %583 seq_cst acquire, align 8
  %585 = extractvalue { i64, i1 } %584, 0
  %586 = extractvalue { i64, i1 } %584, 1
  br i1 %586, label %cmpxchg.continue56.i542, label %cmpxchg.store_expected55.i541

seqcst_fail50.i534:                               ; preds = %seqcst.i533
  %587 = load i64, ptr %514, align 8
  %588 = load i64, ptr %.atomictmp.i530, align 8
  %589 = cmpxchg weak ptr %this1.i532, i64 %587, i64 %588 seq_cst seq_cst, align 8
  %590 = extractvalue { i64, i1 } %589, 0
  %591 = extractvalue { i64, i1 } %589, 1
  br i1 %591, label %cmpxchg.continue59.i536, label %cmpxchg.store_expected58.i535

atomic.continue51.i538:                           ; preds = %cmpxchg.continue59.i536, %cmpxchg.continue56.i542, %cmpxchg.continue53.i546
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected52.i545:                    ; preds = %monotonic_fail48.i544
  store i64 %580, ptr %514, align 8
  br label %cmpxchg.continue53.i546

cmpxchg.continue53.i546:                          ; preds = %cmpxchg.store_expected52.i545, %monotonic_fail48.i544
  %frombool54.i547 = zext i1 %581 to i8
  store i8 %frombool54.i547, ptr %cmpxchg.bool.i531, align 1
  br label %atomic.continue51.i538

cmpxchg.store_expected55.i541:                    ; preds = %acquire_fail49.i540
  store i64 %585, ptr %514, align 8
  br label %cmpxchg.continue56.i542

cmpxchg.continue56.i542:                          ; preds = %cmpxchg.store_expected55.i541, %acquire_fail49.i540
  %frombool57.i543 = zext i1 %586 to i8
  store i8 %frombool57.i543, ptr %cmpxchg.bool.i531, align 1
  br label %atomic.continue51.i538

cmpxchg.store_expected58.i535:                    ; preds = %seqcst_fail50.i534
  store i64 %590, ptr %514, align 8
  br label %cmpxchg.continue59.i536

cmpxchg.continue59.i536:                          ; preds = %cmpxchg.store_expected58.i535, %seqcst_fail50.i534
  %frombool60.i537 = zext i1 %591 to i8
  store i8 %frombool60.i537, ptr %cmpxchg.bool.i531, align 1
  br label %atomic.continue51.i538

_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit: ; preds = %atomic.continue51.i538, %atomic.continue38.i553, %atomic.continue25.i567, %atomic.continue12.i581, %atomic.continue2.i595
  %592 = load i8, ptr %cmpxchg.bool.i531, align 1
  %tobool.i539 = trunc i8 %592 to i1
  %lnot183 = xor i1 %tobool.i539, true
  br i1 %lnot183, label %do.body173, label %do.end184, !llvm.loop !20

do.end184:                                        ; preds = %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit
  store i8 1, ptr %dowait, align 1
  br label %if.end185

if.end185:                                        ; preds = %do.end184, %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit, %if.else132
  br label %if.end186

if.end186:                                        ; preds = %if.end185, %if.end131
  br label %if.end187

if.end187:                                        ; preds = %if.end186, %if.end85
  %593 = load i8, ptr %dowait, align 1
  %tobool188 = trunc i8 %593 to i1
  br i1 %tobool188, label %if.then189, label %if.end193

if.then189:                                       ; preds = %if.end187
  %594 = load ptr, ptr %waitp.addr, align 8
  %thread190 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %594, i32 0, i32 4
  %595 = load ptr, ptr %thread190, align 8
  invoke void @_ZN4absl5Mutex5BlockEPNS_13base_internal14PerThreadSynchE(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef %595)
          to label %invoke.cont191 unwind label %lpad

invoke.cont191:                                   ; preds = %if.then189
  %596 = load i32, ptr %flags.addr, align 4
  %or192 = or i32 %596, 1
  store i32 %or192, ptr %flags.addr, align 4
  store i32 0, ptr %c, align 4
  br label %if.end193

if.end193:                                        ; preds = %invoke.cont191, %if.end187
  br label %if.end194

if.end194:                                        ; preds = %if.end193, %if.end44
  br label %do.body195

do.body195:                                       ; preds = %if.end194
  %597 = load ptr, ptr %waitp.addr, align 8
  %thread196 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %597, i32 0, i32 4
  %598 = load ptr, ptr %thread196, align 8
  %waitp197 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %598, i32 0, i32 9
  %599 = load ptr, ptr %waitp197, align 8
  %cmp198 = icmp eq ptr %599, null
  br i1 %cmp198, label %lor.end203, label %lor.rhs199

lor.rhs199:                                       ; preds = %do.body195
  %600 = load ptr, ptr %waitp.addr, align 8
  %thread200 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %600, i32 0, i32 4
  %601 = load ptr, ptr %thread200, align 8
  %suppress_fatal_errors201 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %601, i32 0, i32 6
  %602 = load i8, ptr %suppress_fatal_errors201, align 4
  %tobool202 = trunc i8 %602 to i1
  br label %lor.end203

lor.end203:                                       ; preds = %lor.rhs199, %do.body195
  %603 = phi i1 [ true, %do.body195 ], [ %tobool202, %lor.rhs199 ]
  %lnot204 = xor i1 %603, true
  br i1 %lnot204, label %if.then205, label %if.end214

if.then205:                                       ; preds = %lor.end203
  br label %do.body206

do.body206:                                       ; preds = %if.then205
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename207, align 8
  invoke void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 2067, ptr noundef @.str.1, ptr noundef @.str.8, ptr noundef @.str.9)
          to label %invoke.cont208 unwind label %lpad

invoke.cont208:                                   ; preds = %do.body206
  br label %do.body209

do.body209:                                       ; preds = %invoke.cont208
  unreachable

do.cond210:                                       ; No predecessors!
  br label %do.end211

do.end211:                                        ; preds = %do.cond210
  br label %do.cond212

do.cond212:                                       ; preds = %do.end211
  br label %do.end213

do.end213:                                        ; preds = %do.cond212
  br label %if.end214

if.end214:                                        ; preds = %do.end213, %lor.end203
  br label %do.cond215

do.cond215:                                       ; preds = %if.end214
  br label %do.end216

do.end216:                                        ; preds = %do.cond215
  %604 = load i32, ptr %c, align 4
  %call218 = invoke noundef i32 @_ZN4absl24synchronization_internal10MutexDelayEii(i32 noundef %604, i32 noundef 1)
          to label %invoke.cont217 unwind label %lpad

invoke.cont217:                                   ; preds = %do.end216
  store i32 %call218, ptr %c, align 4
  br label %for.cond, !llvm.loop !21

for.end:                                          ; preds = %if.then125, %if.then38
  br label %do.body219

do.body219:                                       ; preds = %for.end
  %605 = load ptr, ptr %waitp.addr, align 8
  %thread220 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %605, i32 0, i32 4
  %606 = load ptr, ptr %thread220, align 8
  %waitp221 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %606, i32 0, i32 9
  %607 = load ptr, ptr %waitp221, align 8
  %cmp222 = icmp eq ptr %607, null
  br i1 %cmp222, label %lor.end227, label %lor.rhs223

lor.rhs223:                                       ; preds = %do.body219
  %608 = load ptr, ptr %waitp.addr, align 8
  %thread224 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %608, i32 0, i32 4
  %609 = load ptr, ptr %thread224, align 8
  %suppress_fatal_errors225 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %609, i32 0, i32 6
  %610 = load i8, ptr %suppress_fatal_errors225, align 4
  %tobool226 = trunc i8 %610 to i1
  br label %lor.end227

lor.end227:                                       ; preds = %lor.rhs223, %do.body219
  %611 = phi i1 [ true, %do.body219 ], [ %tobool226, %lor.rhs223 ]
  %lnot228 = xor i1 %611, true
  br i1 %lnot228, label %if.then229, label %if.end238

if.then229:                                       ; preds = %lor.end227
  br label %do.body230

do.body230:                                       ; preds = %if.then229
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename231, align 8
  invoke void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 2073, ptr noundef @.str.1, ptr noundef @.str.8, ptr noundef @.str.9)
          to label %invoke.cont232 unwind label %lpad

invoke.cont232:                                   ; preds = %do.body230
  br label %do.body233

do.body233:                                       ; preds = %invoke.cont232
  unreachable

do.cond234:                                       ; No predecessors!
  br label %do.end235

do.end235:                                        ; preds = %do.cond234
  br label %do.cond236

do.cond236:                                       ; preds = %do.end235
  br label %do.end237

do.end237:                                        ; preds = %do.cond236
  br label %if.end238

if.end238:                                        ; preds = %do.end237, %lor.end227
  br label %do.cond239

do.cond239:                                       ; preds = %if.end238
  br label %do.end240

do.end240:                                        ; preds = %do.cond239
  %612 = load i64, ptr %v, align 8
  %and241 = and i64 %612, 16
  %cmp242 = icmp ne i64 %and241, 0
  br i1 %cmp242, label %if.then243, label %if.end248

if.then243:                                       ; preds = %do.end240
  %613 = load ptr, ptr %waitp.addr, align 8
  %how244 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %613, i32 0, i32 0
  %614 = load ptr, ptr %how244, align 8
  %cmp245 = icmp eq ptr %614, @_ZN4abslL11kExclusiveSE
  %cond246 = select i1 %cmp245, i32 5, i32 7
  invoke void @_ZN4abslL14PostSynchEventEPvi(ptr noundef %this1, i32 noundef %cond246)
          to label %invoke.cont247 unwind label %lpad

invoke.cont247:                                   ; preds = %if.then243
  br label %if.end248

if.end248:                                        ; preds = %invoke.cont247, %do.end240
  call void @_ZN4absl13base_internal15SchedulingGuard13ScopedDisableD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %disable_rescheduling) #13
  ret void

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val249 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val249
}

; Function Attrs: mustprogress uwtable
define internal noundef zeroext i1 @_ZN4abslL22EvalConditionAnnotatedEPKNS_9ConditionEPNS_5MutexEbbb(ptr noundef %cond, ptr noundef %mu, i1 noundef zeroext %locking, i1 noundef zeroext %trylock, i1 noundef zeroext %read_lock) #0 {
entry:
  %cond.addr = alloca ptr, align 8
  %mu.addr = alloca ptr, align 8
  %locking.addr = alloca i8, align 1
  %trylock.addr = alloca i8, align 1
  %read_lock.addr = alloca i8, align 1
  %res = alloca i8, align 1
  store ptr %cond, ptr %cond.addr, align 8
  store ptr %mu, ptr %mu.addr, align 8
  %frombool = zext i1 %locking to i8
  store i8 %frombool, ptr %locking.addr, align 1
  %frombool1 = zext i1 %trylock to i8
  store i8 %frombool1, ptr %trylock.addr, align 1
  %frombool2 = zext i1 %read_lock to i8
  store i8 %frombool2, ptr %read_lock.addr, align 1
  store i8 0, ptr %res, align 1
  %0 = load i8, ptr %locking.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %cond.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4absl9Condition4EvalEv(ptr noundef nonnull align 8 dereferenceable(32) %1)
  %frombool3 = zext i1 %call to i8
  store i8 %frombool3, ptr %res, align 1
  br label %if.end

if.else:                                          ; preds = %entry
  %2 = load ptr, ptr %cond.addr, align 8
  %call4 = call noundef zeroext i1 @_ZNK4absl9Condition4EvalEv(ptr noundef nonnull align 8 dereferenceable(32) %2)
  %frombool5 = zext i1 %call4 to i8
  store i8 %frombool5, ptr %res, align 1
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %3 = load i8, ptr %res, align 1
  %tobool6 = trunc i8 %3 to i1
  ret i1 %tobool6
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK4absl24synchronization_internal13KernelTimeout11has_timeoutEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %rep_ = getelementptr inbounds %"class.absl::synchronization_internal::KernelTimeout", ptr %this1, i32 0, i32 0
  %0 = load i64, ptr %rep_, align 8
  %cmp = icmp ne i64 %0, -1
  ret i1 %cmp
}

; Function Attrs: mustprogress uwtable
define dso_local noundef zeroext i1 @_ZN4absl5Mutex7TryLockEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 align 2 {
entry:
  %this.addr.i11 = alloca ptr, align 8
  %__i1.addr.i = alloca ptr, align 8
  %__i2.addr.i = alloca i64, align 8
  %__m1.addr.i = alloca i32, align 4
  %__m2.addr.i = alloca i32, align 4
  %.atomictmp.i = alloca i64, align 8
  %cmpxchg.bool.i = alloca i8, align 1
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i64, align 8
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  %v = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mu_ = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  store ptr %mu_, ptr %this.addr.i, align 8
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %0 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %0, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %1 = load i32, ptr %__m.addr.i, align 4
  switch i32 %1, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %entry
  %2 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %2, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %entry, %entry
  %3 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %3, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %entry
  %4 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %4, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %5 = load i64, ptr %atomic-temp.i, align 8
  store i64 %5, ptr %v, align 8
  %6 = load i64, ptr %v, align 8
  %and = and i64 %6, 25
  %cmp = icmp eq i64 %and, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  %mu_2 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %7 = load i64, ptr %v, align 8
  %or = or i64 8, %7
  store ptr %mu_2, ptr %this.addr.i11, align 8
  store ptr %v, ptr %__i1.addr.i, align 8
  store i64 %or, ptr %__i2.addr.i, align 8
  store i32 2, ptr %__m1.addr.i, align 4
  store i32 0, ptr %__m2.addr.i, align 4
  %this1.i12 = load ptr, ptr %this.addr.i11, align 8
  %8 = load i32, ptr %__m1.addr.i, align 4
  %9 = load ptr, ptr %__i1.addr.i, align 8
  %10 = load i64, ptr %__i2.addr.i, align 8
  store i64 %10, ptr %.atomictmp.i, align 8
  %11 = load i32, ptr %__m2.addr.i, align 4
  switch i32 %8, label %monotonic.i15 [
    i32 1, label %acquire.i14
    i32 2, label %acquire.i14
    i32 3, label %release.i
    i32 4, label %acqrel.i
    i32 5, label %seqcst.i13
  ]

monotonic.i15:                                    ; preds = %if.then
  switch i32 %11, label %monotonic_fail.i [
    i32 1, label %acquire_fail.i
    i32 2, label %acquire_fail.i
    i32 5, label %seqcst_fail.i
  ]

acquire.i14:                                      ; preds = %if.then, %if.then
  switch i32 %11, label %monotonic_fail9.i [
    i32 1, label %acquire_fail10.i
    i32 2, label %acquire_fail10.i
    i32 5, label %seqcst_fail11.i
  ]

release.i:                                        ; preds = %if.then
  switch i32 %11, label %monotonic_fail22.i [
    i32 1, label %acquire_fail23.i
    i32 2, label %acquire_fail23.i
    i32 5, label %seqcst_fail24.i
  ]

acqrel.i:                                         ; preds = %if.then
  switch i32 %11, label %monotonic_fail35.i [
    i32 1, label %acquire_fail36.i
    i32 2, label %acquire_fail36.i
    i32 5, label %seqcst_fail37.i
  ]

seqcst.i13:                                       ; preds = %if.then
  switch i32 %11, label %monotonic_fail48.i [
    i32 1, label %acquire_fail49.i
    i32 2, label %acquire_fail49.i
    i32 5, label %seqcst_fail50.i
  ]

monotonic_fail.i:                                 ; preds = %monotonic.i15
  %12 = load i64, ptr %9, align 8
  %13 = load i64, ptr %.atomictmp.i, align 8
  %14 = cmpxchg ptr %this1.i12, i64 %12, i64 %13 monotonic monotonic, align 8
  %15 = extractvalue { i64, i1 } %14, 0
  %16 = extractvalue { i64, i1 } %14, 1
  br i1 %16, label %cmpxchg.continue.i, label %cmpxchg.store_expected.i

acquire_fail.i:                                   ; preds = %monotonic.i15, %monotonic.i15
  %17 = load i64, ptr %9, align 8
  %18 = load i64, ptr %.atomictmp.i, align 8
  %19 = cmpxchg ptr %this1.i12, i64 %17, i64 %18 monotonic acquire, align 8
  %20 = extractvalue { i64, i1 } %19, 0
  %21 = extractvalue { i64, i1 } %19, 1
  br i1 %21, label %cmpxchg.continue4.i, label %cmpxchg.store_expected3.i

seqcst_fail.i:                                    ; preds = %monotonic.i15
  %22 = load i64, ptr %9, align 8
  %23 = load i64, ptr %.atomictmp.i, align 8
  %24 = cmpxchg ptr %this1.i12, i64 %22, i64 %23 monotonic seq_cst, align 8
  %25 = extractvalue { i64, i1 } %24, 0
  %26 = extractvalue { i64, i1 } %24, 1
  br i1 %26, label %cmpxchg.continue7.i, label %cmpxchg.store_expected6.i

atomic.continue2.i:                               ; preds = %cmpxchg.continue7.i, %cmpxchg.continue4.i, %cmpxchg.continue.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected.i:                         ; preds = %monotonic_fail.i
  store i64 %15, ptr %9, align 8
  br label %cmpxchg.continue.i

cmpxchg.continue.i:                               ; preds = %cmpxchg.store_expected.i, %monotonic_fail.i
  %frombool.i = zext i1 %16 to i8
  store i8 %frombool.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected3.i:                        ; preds = %acquire_fail.i
  store i64 %20, ptr %9, align 8
  br label %cmpxchg.continue4.i

cmpxchg.continue4.i:                              ; preds = %cmpxchg.store_expected3.i, %acquire_fail.i
  %frombool5.i = zext i1 %21 to i8
  store i8 %frombool5.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected6.i:                        ; preds = %seqcst_fail.i
  store i64 %25, ptr %9, align 8
  br label %cmpxchg.continue7.i

cmpxchg.continue7.i:                              ; preds = %cmpxchg.store_expected6.i, %seqcst_fail.i
  %frombool8.i = zext i1 %26 to i8
  store i8 %frombool8.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

monotonic_fail9.i:                                ; preds = %acquire.i14
  %27 = load i64, ptr %9, align 8
  %28 = load i64, ptr %.atomictmp.i, align 8
  %29 = cmpxchg ptr %this1.i12, i64 %27, i64 %28 acquire monotonic, align 8
  %30 = extractvalue { i64, i1 } %29, 0
  %31 = extractvalue { i64, i1 } %29, 1
  br i1 %31, label %cmpxchg.continue14.i, label %cmpxchg.store_expected13.i

acquire_fail10.i:                                 ; preds = %acquire.i14, %acquire.i14
  %32 = load i64, ptr %9, align 8
  %33 = load i64, ptr %.atomictmp.i, align 8
  %34 = cmpxchg ptr %this1.i12, i64 %32, i64 %33 acquire acquire, align 8
  %35 = extractvalue { i64, i1 } %34, 0
  %36 = extractvalue { i64, i1 } %34, 1
  br i1 %36, label %cmpxchg.continue17.i, label %cmpxchg.store_expected16.i

seqcst_fail11.i:                                  ; preds = %acquire.i14
  %37 = load i64, ptr %9, align 8
  %38 = load i64, ptr %.atomictmp.i, align 8
  %39 = cmpxchg ptr %this1.i12, i64 %37, i64 %38 acquire seq_cst, align 8
  %40 = extractvalue { i64, i1 } %39, 0
  %41 = extractvalue { i64, i1 } %39, 1
  br i1 %41, label %cmpxchg.continue20.i, label %cmpxchg.store_expected19.i

atomic.continue12.i:                              ; preds = %cmpxchg.continue20.i, %cmpxchg.continue17.i, %cmpxchg.continue14.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected13.i:                       ; preds = %monotonic_fail9.i
  store i64 %30, ptr %9, align 8
  br label %cmpxchg.continue14.i

cmpxchg.continue14.i:                             ; preds = %cmpxchg.store_expected13.i, %monotonic_fail9.i
  %frombool15.i = zext i1 %31 to i8
  store i8 %frombool15.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected16.i:                       ; preds = %acquire_fail10.i
  store i64 %35, ptr %9, align 8
  br label %cmpxchg.continue17.i

cmpxchg.continue17.i:                             ; preds = %cmpxchg.store_expected16.i, %acquire_fail10.i
  %frombool18.i = zext i1 %36 to i8
  store i8 %frombool18.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected19.i:                       ; preds = %seqcst_fail11.i
  store i64 %40, ptr %9, align 8
  br label %cmpxchg.continue20.i

cmpxchg.continue20.i:                             ; preds = %cmpxchg.store_expected19.i, %seqcst_fail11.i
  %frombool21.i = zext i1 %41 to i8
  store i8 %frombool21.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

monotonic_fail22.i:                               ; preds = %release.i
  %42 = load i64, ptr %9, align 8
  %43 = load i64, ptr %.atomictmp.i, align 8
  %44 = cmpxchg ptr %this1.i12, i64 %42, i64 %43 release monotonic, align 8
  %45 = extractvalue { i64, i1 } %44, 0
  %46 = extractvalue { i64, i1 } %44, 1
  br i1 %46, label %cmpxchg.continue27.i, label %cmpxchg.store_expected26.i

acquire_fail23.i:                                 ; preds = %release.i, %release.i
  %47 = load i64, ptr %9, align 8
  %48 = load i64, ptr %.atomictmp.i, align 8
  %49 = cmpxchg ptr %this1.i12, i64 %47, i64 %48 release acquire, align 8
  %50 = extractvalue { i64, i1 } %49, 0
  %51 = extractvalue { i64, i1 } %49, 1
  br i1 %51, label %cmpxchg.continue30.i, label %cmpxchg.store_expected29.i

seqcst_fail24.i:                                  ; preds = %release.i
  %52 = load i64, ptr %9, align 8
  %53 = load i64, ptr %.atomictmp.i, align 8
  %54 = cmpxchg ptr %this1.i12, i64 %52, i64 %53 release seq_cst, align 8
  %55 = extractvalue { i64, i1 } %54, 0
  %56 = extractvalue { i64, i1 } %54, 1
  br i1 %56, label %cmpxchg.continue33.i, label %cmpxchg.store_expected32.i

atomic.continue25.i:                              ; preds = %cmpxchg.continue33.i, %cmpxchg.continue30.i, %cmpxchg.continue27.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected26.i:                       ; preds = %monotonic_fail22.i
  store i64 %45, ptr %9, align 8
  br label %cmpxchg.continue27.i

cmpxchg.continue27.i:                             ; preds = %cmpxchg.store_expected26.i, %monotonic_fail22.i
  %frombool28.i = zext i1 %46 to i8
  store i8 %frombool28.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected29.i:                       ; preds = %acquire_fail23.i
  store i64 %50, ptr %9, align 8
  br label %cmpxchg.continue30.i

cmpxchg.continue30.i:                             ; preds = %cmpxchg.store_expected29.i, %acquire_fail23.i
  %frombool31.i = zext i1 %51 to i8
  store i8 %frombool31.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected32.i:                       ; preds = %seqcst_fail24.i
  store i64 %55, ptr %9, align 8
  br label %cmpxchg.continue33.i

cmpxchg.continue33.i:                             ; preds = %cmpxchg.store_expected32.i, %seqcst_fail24.i
  %frombool34.i = zext i1 %56 to i8
  store i8 %frombool34.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

monotonic_fail35.i:                               ; preds = %acqrel.i
  %57 = load i64, ptr %9, align 8
  %58 = load i64, ptr %.atomictmp.i, align 8
  %59 = cmpxchg ptr %this1.i12, i64 %57, i64 %58 acq_rel monotonic, align 8
  %60 = extractvalue { i64, i1 } %59, 0
  %61 = extractvalue { i64, i1 } %59, 1
  br i1 %61, label %cmpxchg.continue40.i, label %cmpxchg.store_expected39.i

acquire_fail36.i:                                 ; preds = %acqrel.i, %acqrel.i
  %62 = load i64, ptr %9, align 8
  %63 = load i64, ptr %.atomictmp.i, align 8
  %64 = cmpxchg ptr %this1.i12, i64 %62, i64 %63 acq_rel acquire, align 8
  %65 = extractvalue { i64, i1 } %64, 0
  %66 = extractvalue { i64, i1 } %64, 1
  br i1 %66, label %cmpxchg.continue43.i, label %cmpxchg.store_expected42.i

seqcst_fail37.i:                                  ; preds = %acqrel.i
  %67 = load i64, ptr %9, align 8
  %68 = load i64, ptr %.atomictmp.i, align 8
  %69 = cmpxchg ptr %this1.i12, i64 %67, i64 %68 acq_rel seq_cst, align 8
  %70 = extractvalue { i64, i1 } %69, 0
  %71 = extractvalue { i64, i1 } %69, 1
  br i1 %71, label %cmpxchg.continue46.i, label %cmpxchg.store_expected45.i

atomic.continue38.i:                              ; preds = %cmpxchg.continue46.i, %cmpxchg.continue43.i, %cmpxchg.continue40.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected39.i:                       ; preds = %monotonic_fail35.i
  store i64 %60, ptr %9, align 8
  br label %cmpxchg.continue40.i

cmpxchg.continue40.i:                             ; preds = %cmpxchg.store_expected39.i, %monotonic_fail35.i
  %frombool41.i = zext i1 %61 to i8
  store i8 %frombool41.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected42.i:                       ; preds = %acquire_fail36.i
  store i64 %65, ptr %9, align 8
  br label %cmpxchg.continue43.i

cmpxchg.continue43.i:                             ; preds = %cmpxchg.store_expected42.i, %acquire_fail36.i
  %frombool44.i = zext i1 %66 to i8
  store i8 %frombool44.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected45.i:                       ; preds = %seqcst_fail37.i
  store i64 %70, ptr %9, align 8
  br label %cmpxchg.continue46.i

cmpxchg.continue46.i:                             ; preds = %cmpxchg.store_expected45.i, %seqcst_fail37.i
  %frombool47.i = zext i1 %71 to i8
  store i8 %frombool47.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

monotonic_fail48.i:                               ; preds = %seqcst.i13
  %72 = load i64, ptr %9, align 8
  %73 = load i64, ptr %.atomictmp.i, align 8
  %74 = cmpxchg ptr %this1.i12, i64 %72, i64 %73 seq_cst monotonic, align 8
  %75 = extractvalue { i64, i1 } %74, 0
  %76 = extractvalue { i64, i1 } %74, 1
  br i1 %76, label %cmpxchg.continue53.i, label %cmpxchg.store_expected52.i

acquire_fail49.i:                                 ; preds = %seqcst.i13, %seqcst.i13
  %77 = load i64, ptr %9, align 8
  %78 = load i64, ptr %.atomictmp.i, align 8
  %79 = cmpxchg ptr %this1.i12, i64 %77, i64 %78 seq_cst acquire, align 8
  %80 = extractvalue { i64, i1 } %79, 0
  %81 = extractvalue { i64, i1 } %79, 1
  br i1 %81, label %cmpxchg.continue56.i, label %cmpxchg.store_expected55.i

seqcst_fail50.i:                                  ; preds = %seqcst.i13
  %82 = load i64, ptr %9, align 8
  %83 = load i64, ptr %.atomictmp.i, align 8
  %84 = cmpxchg ptr %this1.i12, i64 %82, i64 %83 seq_cst seq_cst, align 8
  %85 = extractvalue { i64, i1 } %84, 0
  %86 = extractvalue { i64, i1 } %84, 1
  br i1 %86, label %cmpxchg.continue59.i, label %cmpxchg.store_expected58.i

atomic.continue51.i:                              ; preds = %cmpxchg.continue59.i, %cmpxchg.continue56.i, %cmpxchg.continue53.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected52.i:                       ; preds = %monotonic_fail48.i
  store i64 %75, ptr %9, align 8
  br label %cmpxchg.continue53.i

cmpxchg.continue53.i:                             ; preds = %cmpxchg.store_expected52.i, %monotonic_fail48.i
  %frombool54.i = zext i1 %76 to i8
  store i8 %frombool54.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected55.i:                       ; preds = %acquire_fail49.i
  store i64 %80, ptr %9, align 8
  br label %cmpxchg.continue56.i

cmpxchg.continue56.i:                             ; preds = %cmpxchg.store_expected55.i, %acquire_fail49.i
  %frombool57.i = zext i1 %81 to i8
  store i8 %frombool57.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected58.i:                       ; preds = %seqcst_fail50.i
  store i64 %85, ptr %9, align 8
  br label %cmpxchg.continue59.i

cmpxchg.continue59.i:                             ; preds = %cmpxchg.store_expected58.i, %seqcst_fail50.i
  %frombool60.i = zext i1 %86 to i8
  store i8 %frombool60.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit: ; preds = %atomic.continue51.i, %atomic.continue38.i, %atomic.continue25.i, %atomic.continue12.i, %atomic.continue2.i
  %87 = load i8, ptr %cmpxchg.bool.i, align 1
  %tobool.i = trunc i8 %87 to i1
  br i1 %tobool.i, label %if.then4, label %if.end

if.then4:                                         ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit
  call void @_ZN4abslL18DebugOnlyLockEnterEPNS_5MutexE(ptr noundef %this1)
  store i1 true, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit
  br label %if.end10

if.else:                                          ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  %88 = load i64, ptr %v, align 8
  %and5 = and i64 %88, 16
  %cmp6 = icmp ne i64 %and5, 0
  br i1 %cmp6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.else
  %call8 = call noundef zeroext i1 @_ZN4absl5Mutex11TryLockSlowEv(ptr noundef nonnull align 8 dereferenceable(8) %this1)
  store i1 %call8, ptr %retval, align 1
  br label %return

if.end9:                                          ; preds = %if.else
  br label %if.end10

if.end10:                                         ; preds = %if.end9, %if.end
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end10, %if.then7, %if.then4
  %89 = load i1, ptr %retval, align 1
  ret i1 %89
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZN4abslL18DebugOnlyLockEnterEPNS_5MutexE(ptr noundef %mu) #1 {
entry:
  %mu.addr = alloca ptr, align 8
  store ptr %mu, ptr %mu.addr, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local noundef zeroext i1 @_ZN4absl5Mutex11TryLockSlowEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 align 2 {
entry:
  %this.addr.i4 = alloca ptr, align 8
  %__i1.addr.i = alloca ptr, align 8
  %__i2.addr.i = alloca i64, align 8
  %__m1.addr.i = alloca i32, align 4
  %__m2.addr.i = alloca i32, align 4
  %.atomictmp.i = alloca i64, align 8
  %cmpxchg.bool.i = alloca i8, align 1
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i64, align 8
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  %v = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mu_ = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  store ptr %mu_, ptr %this.addr.i, align 8
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %0 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %0, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %1 = load i32, ptr %__m.addr.i, align 4
  switch i32 %1, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %entry
  %2 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %2, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %entry, %entry
  %3 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %3, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %entry
  %4 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %4, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %5 = load i64, ptr %atomic-temp.i, align 8
  store i64 %5, ptr %v, align 8
  %6 = load i64, ptr %v, align 8
  %and = and i64 %6, 9
  %cmp = icmp eq i64 %and, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  %mu_2 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %7 = load i64, ptr %v, align 8
  %or = or i64 8, %7
  %add = add nsw i64 %or, 0
  store ptr %mu_2, ptr %this.addr.i4, align 8
  store ptr %v, ptr %__i1.addr.i, align 8
  store i64 %add, ptr %__i2.addr.i, align 8
  store i32 2, ptr %__m1.addr.i, align 4
  store i32 0, ptr %__m2.addr.i, align 4
  %this1.i5 = load ptr, ptr %this.addr.i4, align 8
  %8 = load i32, ptr %__m1.addr.i, align 4
  %9 = load ptr, ptr %__i1.addr.i, align 8
  %10 = load i64, ptr %__i2.addr.i, align 8
  store i64 %10, ptr %.atomictmp.i, align 8
  %11 = load i32, ptr %__m2.addr.i, align 4
  switch i32 %8, label %monotonic.i8 [
    i32 1, label %acquire.i7
    i32 2, label %acquire.i7
    i32 3, label %release.i
    i32 4, label %acqrel.i
    i32 5, label %seqcst.i6
  ]

monotonic.i8:                                     ; preds = %land.lhs.true
  switch i32 %11, label %monotonic_fail.i [
    i32 1, label %acquire_fail.i
    i32 2, label %acquire_fail.i
    i32 5, label %seqcst_fail.i
  ]

acquire.i7:                                       ; preds = %land.lhs.true, %land.lhs.true
  switch i32 %11, label %monotonic_fail9.i [
    i32 1, label %acquire_fail10.i
    i32 2, label %acquire_fail10.i
    i32 5, label %seqcst_fail11.i
  ]

release.i:                                        ; preds = %land.lhs.true
  switch i32 %11, label %monotonic_fail22.i [
    i32 1, label %acquire_fail23.i
    i32 2, label %acquire_fail23.i
    i32 5, label %seqcst_fail24.i
  ]

acqrel.i:                                         ; preds = %land.lhs.true
  switch i32 %11, label %monotonic_fail35.i [
    i32 1, label %acquire_fail36.i
    i32 2, label %acquire_fail36.i
    i32 5, label %seqcst_fail37.i
  ]

seqcst.i6:                                        ; preds = %land.lhs.true
  switch i32 %11, label %monotonic_fail48.i [
    i32 1, label %acquire_fail49.i
    i32 2, label %acquire_fail49.i
    i32 5, label %seqcst_fail50.i
  ]

monotonic_fail.i:                                 ; preds = %monotonic.i8
  %12 = load i64, ptr %9, align 8
  %13 = load i64, ptr %.atomictmp.i, align 8
  %14 = cmpxchg ptr %this1.i5, i64 %12, i64 %13 monotonic monotonic, align 8
  %15 = extractvalue { i64, i1 } %14, 0
  %16 = extractvalue { i64, i1 } %14, 1
  br i1 %16, label %cmpxchg.continue.i, label %cmpxchg.store_expected.i

acquire_fail.i:                                   ; preds = %monotonic.i8, %monotonic.i8
  %17 = load i64, ptr %9, align 8
  %18 = load i64, ptr %.atomictmp.i, align 8
  %19 = cmpxchg ptr %this1.i5, i64 %17, i64 %18 monotonic acquire, align 8
  %20 = extractvalue { i64, i1 } %19, 0
  %21 = extractvalue { i64, i1 } %19, 1
  br i1 %21, label %cmpxchg.continue4.i, label %cmpxchg.store_expected3.i

seqcst_fail.i:                                    ; preds = %monotonic.i8
  %22 = load i64, ptr %9, align 8
  %23 = load i64, ptr %.atomictmp.i, align 8
  %24 = cmpxchg ptr %this1.i5, i64 %22, i64 %23 monotonic seq_cst, align 8
  %25 = extractvalue { i64, i1 } %24, 0
  %26 = extractvalue { i64, i1 } %24, 1
  br i1 %26, label %cmpxchg.continue7.i, label %cmpxchg.store_expected6.i

atomic.continue2.i:                               ; preds = %cmpxchg.continue7.i, %cmpxchg.continue4.i, %cmpxchg.continue.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected.i:                         ; preds = %monotonic_fail.i
  store i64 %15, ptr %9, align 8
  br label %cmpxchg.continue.i

cmpxchg.continue.i:                               ; preds = %cmpxchg.store_expected.i, %monotonic_fail.i
  %frombool.i = zext i1 %16 to i8
  store i8 %frombool.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected3.i:                        ; preds = %acquire_fail.i
  store i64 %20, ptr %9, align 8
  br label %cmpxchg.continue4.i

cmpxchg.continue4.i:                              ; preds = %cmpxchg.store_expected3.i, %acquire_fail.i
  %frombool5.i = zext i1 %21 to i8
  store i8 %frombool5.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected6.i:                        ; preds = %seqcst_fail.i
  store i64 %25, ptr %9, align 8
  br label %cmpxchg.continue7.i

cmpxchg.continue7.i:                              ; preds = %cmpxchg.store_expected6.i, %seqcst_fail.i
  %frombool8.i = zext i1 %26 to i8
  store i8 %frombool8.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

monotonic_fail9.i:                                ; preds = %acquire.i7
  %27 = load i64, ptr %9, align 8
  %28 = load i64, ptr %.atomictmp.i, align 8
  %29 = cmpxchg ptr %this1.i5, i64 %27, i64 %28 acquire monotonic, align 8
  %30 = extractvalue { i64, i1 } %29, 0
  %31 = extractvalue { i64, i1 } %29, 1
  br i1 %31, label %cmpxchg.continue14.i, label %cmpxchg.store_expected13.i

acquire_fail10.i:                                 ; preds = %acquire.i7, %acquire.i7
  %32 = load i64, ptr %9, align 8
  %33 = load i64, ptr %.atomictmp.i, align 8
  %34 = cmpxchg ptr %this1.i5, i64 %32, i64 %33 acquire acquire, align 8
  %35 = extractvalue { i64, i1 } %34, 0
  %36 = extractvalue { i64, i1 } %34, 1
  br i1 %36, label %cmpxchg.continue17.i, label %cmpxchg.store_expected16.i

seqcst_fail11.i:                                  ; preds = %acquire.i7
  %37 = load i64, ptr %9, align 8
  %38 = load i64, ptr %.atomictmp.i, align 8
  %39 = cmpxchg ptr %this1.i5, i64 %37, i64 %38 acquire seq_cst, align 8
  %40 = extractvalue { i64, i1 } %39, 0
  %41 = extractvalue { i64, i1 } %39, 1
  br i1 %41, label %cmpxchg.continue20.i, label %cmpxchg.store_expected19.i

atomic.continue12.i:                              ; preds = %cmpxchg.continue20.i, %cmpxchg.continue17.i, %cmpxchg.continue14.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected13.i:                       ; preds = %monotonic_fail9.i
  store i64 %30, ptr %9, align 8
  br label %cmpxchg.continue14.i

cmpxchg.continue14.i:                             ; preds = %cmpxchg.store_expected13.i, %monotonic_fail9.i
  %frombool15.i = zext i1 %31 to i8
  store i8 %frombool15.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected16.i:                       ; preds = %acquire_fail10.i
  store i64 %35, ptr %9, align 8
  br label %cmpxchg.continue17.i

cmpxchg.continue17.i:                             ; preds = %cmpxchg.store_expected16.i, %acquire_fail10.i
  %frombool18.i = zext i1 %36 to i8
  store i8 %frombool18.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected19.i:                       ; preds = %seqcst_fail11.i
  store i64 %40, ptr %9, align 8
  br label %cmpxchg.continue20.i

cmpxchg.continue20.i:                             ; preds = %cmpxchg.store_expected19.i, %seqcst_fail11.i
  %frombool21.i = zext i1 %41 to i8
  store i8 %frombool21.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

monotonic_fail22.i:                               ; preds = %release.i
  %42 = load i64, ptr %9, align 8
  %43 = load i64, ptr %.atomictmp.i, align 8
  %44 = cmpxchg ptr %this1.i5, i64 %42, i64 %43 release monotonic, align 8
  %45 = extractvalue { i64, i1 } %44, 0
  %46 = extractvalue { i64, i1 } %44, 1
  br i1 %46, label %cmpxchg.continue27.i, label %cmpxchg.store_expected26.i

acquire_fail23.i:                                 ; preds = %release.i, %release.i
  %47 = load i64, ptr %9, align 8
  %48 = load i64, ptr %.atomictmp.i, align 8
  %49 = cmpxchg ptr %this1.i5, i64 %47, i64 %48 release acquire, align 8
  %50 = extractvalue { i64, i1 } %49, 0
  %51 = extractvalue { i64, i1 } %49, 1
  br i1 %51, label %cmpxchg.continue30.i, label %cmpxchg.store_expected29.i

seqcst_fail24.i:                                  ; preds = %release.i
  %52 = load i64, ptr %9, align 8
  %53 = load i64, ptr %.atomictmp.i, align 8
  %54 = cmpxchg ptr %this1.i5, i64 %52, i64 %53 release seq_cst, align 8
  %55 = extractvalue { i64, i1 } %54, 0
  %56 = extractvalue { i64, i1 } %54, 1
  br i1 %56, label %cmpxchg.continue33.i, label %cmpxchg.store_expected32.i

atomic.continue25.i:                              ; preds = %cmpxchg.continue33.i, %cmpxchg.continue30.i, %cmpxchg.continue27.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected26.i:                       ; preds = %monotonic_fail22.i
  store i64 %45, ptr %9, align 8
  br label %cmpxchg.continue27.i

cmpxchg.continue27.i:                             ; preds = %cmpxchg.store_expected26.i, %monotonic_fail22.i
  %frombool28.i = zext i1 %46 to i8
  store i8 %frombool28.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected29.i:                       ; preds = %acquire_fail23.i
  store i64 %50, ptr %9, align 8
  br label %cmpxchg.continue30.i

cmpxchg.continue30.i:                             ; preds = %cmpxchg.store_expected29.i, %acquire_fail23.i
  %frombool31.i = zext i1 %51 to i8
  store i8 %frombool31.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected32.i:                       ; preds = %seqcst_fail24.i
  store i64 %55, ptr %9, align 8
  br label %cmpxchg.continue33.i

cmpxchg.continue33.i:                             ; preds = %cmpxchg.store_expected32.i, %seqcst_fail24.i
  %frombool34.i = zext i1 %56 to i8
  store i8 %frombool34.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

monotonic_fail35.i:                               ; preds = %acqrel.i
  %57 = load i64, ptr %9, align 8
  %58 = load i64, ptr %.atomictmp.i, align 8
  %59 = cmpxchg ptr %this1.i5, i64 %57, i64 %58 acq_rel monotonic, align 8
  %60 = extractvalue { i64, i1 } %59, 0
  %61 = extractvalue { i64, i1 } %59, 1
  br i1 %61, label %cmpxchg.continue40.i, label %cmpxchg.store_expected39.i

acquire_fail36.i:                                 ; preds = %acqrel.i, %acqrel.i
  %62 = load i64, ptr %9, align 8
  %63 = load i64, ptr %.atomictmp.i, align 8
  %64 = cmpxchg ptr %this1.i5, i64 %62, i64 %63 acq_rel acquire, align 8
  %65 = extractvalue { i64, i1 } %64, 0
  %66 = extractvalue { i64, i1 } %64, 1
  br i1 %66, label %cmpxchg.continue43.i, label %cmpxchg.store_expected42.i

seqcst_fail37.i:                                  ; preds = %acqrel.i
  %67 = load i64, ptr %9, align 8
  %68 = load i64, ptr %.atomictmp.i, align 8
  %69 = cmpxchg ptr %this1.i5, i64 %67, i64 %68 acq_rel seq_cst, align 8
  %70 = extractvalue { i64, i1 } %69, 0
  %71 = extractvalue { i64, i1 } %69, 1
  br i1 %71, label %cmpxchg.continue46.i, label %cmpxchg.store_expected45.i

atomic.continue38.i:                              ; preds = %cmpxchg.continue46.i, %cmpxchg.continue43.i, %cmpxchg.continue40.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected39.i:                       ; preds = %monotonic_fail35.i
  store i64 %60, ptr %9, align 8
  br label %cmpxchg.continue40.i

cmpxchg.continue40.i:                             ; preds = %cmpxchg.store_expected39.i, %monotonic_fail35.i
  %frombool41.i = zext i1 %61 to i8
  store i8 %frombool41.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected42.i:                       ; preds = %acquire_fail36.i
  store i64 %65, ptr %9, align 8
  br label %cmpxchg.continue43.i

cmpxchg.continue43.i:                             ; preds = %cmpxchg.store_expected42.i, %acquire_fail36.i
  %frombool44.i = zext i1 %66 to i8
  store i8 %frombool44.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected45.i:                       ; preds = %seqcst_fail37.i
  store i64 %70, ptr %9, align 8
  br label %cmpxchg.continue46.i

cmpxchg.continue46.i:                             ; preds = %cmpxchg.store_expected45.i, %seqcst_fail37.i
  %frombool47.i = zext i1 %71 to i8
  store i8 %frombool47.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

monotonic_fail48.i:                               ; preds = %seqcst.i6
  %72 = load i64, ptr %9, align 8
  %73 = load i64, ptr %.atomictmp.i, align 8
  %74 = cmpxchg ptr %this1.i5, i64 %72, i64 %73 seq_cst monotonic, align 8
  %75 = extractvalue { i64, i1 } %74, 0
  %76 = extractvalue { i64, i1 } %74, 1
  br i1 %76, label %cmpxchg.continue53.i, label %cmpxchg.store_expected52.i

acquire_fail49.i:                                 ; preds = %seqcst.i6, %seqcst.i6
  %77 = load i64, ptr %9, align 8
  %78 = load i64, ptr %.atomictmp.i, align 8
  %79 = cmpxchg ptr %this1.i5, i64 %77, i64 %78 seq_cst acquire, align 8
  %80 = extractvalue { i64, i1 } %79, 0
  %81 = extractvalue { i64, i1 } %79, 1
  br i1 %81, label %cmpxchg.continue56.i, label %cmpxchg.store_expected55.i

seqcst_fail50.i:                                  ; preds = %seqcst.i6
  %82 = load i64, ptr %9, align 8
  %83 = load i64, ptr %.atomictmp.i, align 8
  %84 = cmpxchg ptr %this1.i5, i64 %82, i64 %83 seq_cst seq_cst, align 8
  %85 = extractvalue { i64, i1 } %84, 0
  %86 = extractvalue { i64, i1 } %84, 1
  br i1 %86, label %cmpxchg.continue59.i, label %cmpxchg.store_expected58.i

atomic.continue51.i:                              ; preds = %cmpxchg.continue59.i, %cmpxchg.continue56.i, %cmpxchg.continue53.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected52.i:                       ; preds = %monotonic_fail48.i
  store i64 %75, ptr %9, align 8
  br label %cmpxchg.continue53.i

cmpxchg.continue53.i:                             ; preds = %cmpxchg.store_expected52.i, %monotonic_fail48.i
  %frombool54.i = zext i1 %76 to i8
  store i8 %frombool54.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected55.i:                       ; preds = %acquire_fail49.i
  store i64 %80, ptr %9, align 8
  br label %cmpxchg.continue56.i

cmpxchg.continue56.i:                             ; preds = %cmpxchg.store_expected55.i, %acquire_fail49.i
  %frombool57.i = zext i1 %81 to i8
  store i8 %frombool57.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected58.i:                       ; preds = %seqcst_fail50.i
  store i64 %85, ptr %9, align 8
  br label %cmpxchg.continue59.i

cmpxchg.continue59.i:                             ; preds = %cmpxchg.store_expected58.i, %seqcst_fail50.i
  %frombool60.i = zext i1 %86 to i8
  store i8 %frombool60.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit: ; preds = %atomic.continue51.i, %atomic.continue38.i, %atomic.continue25.i, %atomic.continue12.i, %atomic.continue2.i
  %87 = load i8, ptr %cmpxchg.bool.i, align 1
  %tobool.i = trunc i8 %87 to i1
  br i1 %tobool.i, label %if.then, label %if.end

if.then:                                          ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit
  call void @_ZN4abslL18DebugOnlyLockEnterEPNS_5MutexE(ptr noundef %this1)
  call void @_ZN4abslL14PostSynchEventEPvi(ptr noundef %this1, i32 noundef 0)
  store i1 true, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit, %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  call void @_ZN4abslL14PostSynchEventEPvi(ptr noundef %this1, i32 noundef 1)
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %88 = load i1, ptr %retval, align 1
  ret i1 %88
}

; Function Attrs: mustprogress uwtable
define internal void @_ZN4abslL14PostSynchEventEPvi(ptr noundef %obj, i32 noundef %ev) #0 {
entry:
  %obj.addr = alloca ptr, align 8
  %ev.addr = alloca i32, align 4
  %e = alloca ptr, align 8
  %pcs = alloca [40 x ptr], align 16
  %n = alloca i32, align 4
  %buffer = alloca [960 x i8], align 16
  %pos = alloca i32, align 4
  %i = alloca i32, align 4
  %b = alloca i32, align 4
  %absl_raw_log_internal_basename = alloca ptr, align 8
  %flags = alloca i32, align 4
  %cond = alloca %"class.absl::Condition", align 8
  %mu = alloca ptr, align 8
  %locking = alloca i8, align 1
  %trylock = alloca i8, align 1
  %read_lock = alloca i8, align 1
  store ptr %obj, ptr %obj.addr, align 8
  store i32 %ev, ptr %ev.addr, align 4
  %0 = load ptr, ptr %obj.addr, align 8
  %call = call noundef ptr @_ZN4abslL13GetSynchEventEPKv(ptr noundef %0)
  store ptr %call, ptr %e, align 8
  %1 = load ptr, ptr %e, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %e, align 8
  %log = getelementptr inbounds %"struct.absl::SynchEvent", ptr %2, i32 0, i32 5
  %3 = load i8, ptr %log, align 8
  %tobool = trunc i8 %3 to i1
  br i1 %tobool, label %if.then, label %if.end20

if.then:                                          ; preds = %lor.lhs.false, %entry
  %arraydecay = getelementptr inbounds [40 x ptr], ptr %pcs, i64 0, i64 0
  %call1 = call noundef i32 @_ZN4absl13GetStackTraceEPPvii(ptr noundef %arraydecay, i32 noundef 40, i32 noundef 1)
  store i32 %call1, ptr %n, align 4
  %arraydecay2 = getelementptr inbounds [960 x i8], ptr %buffer, i64 0, i64 0
  %call3 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %arraydecay2, i64 noundef 960, ptr noundef @.str.50) #13
  store i32 %call3, ptr %pos, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %4 = load i32, ptr %i, align 4
  %5 = load i32, ptr %n, align 4
  %cmp4 = icmp ne i32 %4, %5
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i32, ptr %pos, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr inbounds [960 x i8], ptr %buffer, i64 0, i64 %idxprom
  %7 = load i32, ptr %pos, align 4
  %conv = sext i32 %7 to i64
  %sub = sub i64 960, %conv
  %8 = load i32, ptr %i, align 4
  %idxprom5 = sext i32 %8 to i64
  %arrayidx6 = getelementptr inbounds [40 x ptr], ptr %pcs, i64 0, i64 %idxprom5
  %9 = load ptr, ptr %arrayidx6, align 8
  %call7 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %arrayidx, i64 noundef %sub, ptr noundef @.str.51, ptr noundef %9) #13
  store i32 %call7, ptr %b, align 4
  %10 = load i32, ptr %b, align 4
  %cmp8 = icmp slt i32 %10, 0
  br i1 %cmp8, label %if.then14, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %for.body
  %11 = load i32, ptr %b, align 4
  %conv10 = sext i32 %11 to i64
  %12 = load i32, ptr %pos, align 4
  %conv11 = sext i32 %12 to i64
  %sub12 = sub i64 960, %conv11
  %cmp13 = icmp uge i64 %conv10, %sub12
  br i1 %cmp13, label %if.then14, label %if.end

if.then14:                                        ; preds = %lor.lhs.false9, %for.body
  br label %for.end

if.end:                                           ; preds = %lor.lhs.false9
  %13 = load i32, ptr %b, align 4
  %14 = load i32, ptr %pos, align 4
  %add = add nsw i32 %14, %13
  store i32 %add, ptr %pos, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %15 = load i32, ptr %i, align 4
  %inc = add nsw i32 %15, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !22

for.end:                                          ; preds = %if.then14, %for.cond
  br label %do.body

do.body:                                          ; preds = %for.end
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename, align 8
  %16 = load i32, ptr %ev.addr, align 4
  %idxprom15 = sext i32 %16 to i64
  %arrayidx16 = getelementptr inbounds [14 x %struct.anon], ptr @_ZN4abslL16event_propertiesE, i64 0, i64 %idxprom15
  %msg = getelementptr inbounds %struct.anon, ptr %arrayidx16, i32 0, i32 1
  %17 = load ptr, ptr %msg, align 8
  %18 = load ptr, ptr %obj.addr, align 8
  %19 = load ptr, ptr %e, align 8
  %cmp17 = icmp eq ptr %19, null
  br i1 %cmp17, label %cond.true, label %cond.false

cond.true:                                        ; preds = %do.body
  br label %cond.end

cond.false:                                       ; preds = %do.body
  %20 = load ptr, ptr %e, align 8
  %name = getelementptr inbounds %"struct.absl::SynchEvent", ptr %20, i32 0, i32 6
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond-lvalue = phi ptr [ @.str.35, %cond.true ], [ %name, %cond.false ]
  %arraydecay18 = getelementptr inbounds [1 x i8], ptr %cond-lvalue, i64 0, i64 0
  %arraydecay19 = getelementptr inbounds [960 x i8], ptr %buffer, i64 0, i64 0
  call void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 0, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 452, ptr noundef @.str.52, ptr noundef %17, ptr noundef %18, ptr noundef %arraydecay18, ptr noundef %arraydecay19)
  br label %do.end

do.end:                                           ; preds = %cond.end
  br label %if.end20

if.end20:                                         ; preds = %do.end, %lor.lhs.false
  %21 = load i32, ptr %ev.addr, align 4
  %idxprom21 = sext i32 %21 to i64
  %arrayidx22 = getelementptr inbounds [14 x %struct.anon], ptr @_ZN4abslL16event_propertiesE, i64 0, i64 %idxprom21
  %flags23 = getelementptr inbounds %struct.anon, ptr %arrayidx22, i32 0, i32 0
  %22 = load i32, ptr %flags23, align 16
  store i32 %22, ptr %flags, align 4
  %23 = load i32, ptr %flags, align 4
  %and = and i32 %23, 2
  %cmp24 = icmp ne i32 %and, 0
  br i1 %cmp24, label %land.lhs.true, label %if.end41

land.lhs.true:                                    ; preds = %if.end20
  %24 = load ptr, ptr %e, align 8
  %cmp25 = icmp ne ptr %24, null
  br i1 %cmp25, label %land.lhs.true26, label %if.end41

land.lhs.true26:                                  ; preds = %land.lhs.true
  %25 = load ptr, ptr %e, align 8
  %invariant = getelementptr inbounds %"struct.absl::SynchEvent", ptr %25, i32 0, i32 3
  %26 = load ptr, ptr %invariant, align 8
  %cmp27 = icmp ne ptr %26, null
  br i1 %cmp27, label %if.then28, label %if.end41

if.then28:                                        ; preds = %land.lhs.true26
  %27 = load ptr, ptr %e, align 8
  call void @_ZN4absl9ConditionC2INS_10SynchEventEEEPFbPT_ES4_(ptr noundef nonnull align 8 dereferenceable(32) %cond, ptr noundef @_ZZN4abslL14PostSynchEventEPviEN5local4predEPNS_10SynchEventE, ptr noundef %27)
  %28 = load ptr, ptr %obj.addr, align 8
  store ptr %28, ptr %mu, align 8
  %29 = load i32, ptr %flags, align 4
  %and29 = and i32 %29, 8
  %cmp30 = icmp eq i32 %and29, 0
  %frombool = zext i1 %cmp30 to i8
  store i8 %frombool, ptr %locking, align 1
  %30 = load i32, ptr %flags, align 4
  %and31 = and i32 %30, 4
  %cmp32 = icmp ne i32 %and31, 0
  %frombool33 = zext i1 %cmp32 to i8
  store i8 %frombool33, ptr %trylock, align 1
  %31 = load i32, ptr %flags, align 4
  %and34 = and i32 %31, 1
  %cmp35 = icmp ne i32 %and34, 0
  %frombool36 = zext i1 %cmp35 to i8
  store i8 %frombool36, ptr %read_lock, align 1
  %32 = load ptr, ptr %mu, align 8
  %33 = load i8, ptr %locking, align 1
  %tobool37 = trunc i8 %33 to i1
  %34 = load i8, ptr %trylock, align 1
  %tobool38 = trunc i8 %34 to i1
  %35 = load i8, ptr %read_lock, align 1
  %tobool39 = trunc i8 %35 to i1
  %call40 = call noundef zeroext i1 @_ZN4abslL22EvalConditionAnnotatedEPKNS_9ConditionEPNS_5MutexEbbb(ptr noundef %cond, ptr noundef %32, i1 noundef zeroext %tobool37, i1 noundef zeroext %tobool38, i1 noundef zeroext %tobool39)
  br label %if.end41

if.end41:                                         ; preds = %if.then28, %land.lhs.true26, %land.lhs.true, %if.end20
  %36 = load ptr, ptr %e, align 8
  call void @_ZN4abslL15UnrefSynchEventEPNS_10SynchEventE(ptr noundef %36)
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local noundef zeroext i1 @_ZN4absl5Mutex13ReaderTryLockEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 align 2 {
entry:
  %this.addr.i12 = alloca ptr, align 8
  %__i1.addr.i = alloca ptr, align 8
  %__i2.addr.i = alloca i64, align 8
  %__m1.addr.i = alloca i32, align 4
  %__m2.addr.i = alloca i32, align 4
  %.atomictmp.i = alloca i64, align 8
  %cmpxchg.bool.i = alloca i8, align 1
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i64, align 8
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  %v = alloca i64, align 8
  %loop_limit = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mu_ = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  store ptr %mu_, ptr %this.addr.i, align 8
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %0 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %0, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %1 = load i32, ptr %__m.addr.i, align 4
  switch i32 %1, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %entry
  %2 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %2, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %entry, %entry
  %3 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %3, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %entry
  %4 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %4, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %5 = load i64, ptr %atomic-temp.i, align 8
  store i64 %5, ptr %v, align 8
  store i32 5, ptr %loop_limit, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  %6 = load i32, ptr %loop_limit, align 4
  %cmp = icmp ne i32 %6, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i64, ptr %v, align 8
  %and = and i64 %7, 28
  %cmp2 = icmp ne i64 %and, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.end

if.end:                                           ; preds = %for.body
  %mu_3 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %8 = load i64, ptr %v, align 8
  %or = or i64 1, %8
  %add = add nsw i64 %or, 256
  store ptr %mu_3, ptr %this.addr.i12, align 8
  store ptr %v, ptr %__i1.addr.i, align 8
  store i64 %add, ptr %__i2.addr.i, align 8
  store i32 2, ptr %__m1.addr.i, align 4
  store i32 0, ptr %__m2.addr.i, align 4
  %this1.i13 = load ptr, ptr %this.addr.i12, align 8
  %9 = load i32, ptr %__m1.addr.i, align 4
  %10 = load ptr, ptr %__i1.addr.i, align 8
  %11 = load i64, ptr %__i2.addr.i, align 8
  store i64 %11, ptr %.atomictmp.i, align 8
  %12 = load i32, ptr %__m2.addr.i, align 4
  switch i32 %9, label %monotonic.i16 [
    i32 1, label %acquire.i15
    i32 2, label %acquire.i15
    i32 3, label %release.i
    i32 4, label %acqrel.i
    i32 5, label %seqcst.i14
  ]

monotonic.i16:                                    ; preds = %if.end
  switch i32 %12, label %monotonic_fail.i [
    i32 1, label %acquire_fail.i
    i32 2, label %acquire_fail.i
    i32 5, label %seqcst_fail.i
  ]

acquire.i15:                                      ; preds = %if.end, %if.end
  switch i32 %12, label %monotonic_fail9.i [
    i32 1, label %acquire_fail10.i
    i32 2, label %acquire_fail10.i
    i32 5, label %seqcst_fail11.i
  ]

release.i:                                        ; preds = %if.end
  switch i32 %12, label %monotonic_fail22.i [
    i32 1, label %acquire_fail23.i
    i32 2, label %acquire_fail23.i
    i32 5, label %seqcst_fail24.i
  ]

acqrel.i:                                         ; preds = %if.end
  switch i32 %12, label %monotonic_fail35.i [
    i32 1, label %acquire_fail36.i
    i32 2, label %acquire_fail36.i
    i32 5, label %seqcst_fail37.i
  ]

seqcst.i14:                                       ; preds = %if.end
  switch i32 %12, label %monotonic_fail48.i [
    i32 1, label %acquire_fail49.i
    i32 2, label %acquire_fail49.i
    i32 5, label %seqcst_fail50.i
  ]

monotonic_fail.i:                                 ; preds = %monotonic.i16
  %13 = load i64, ptr %10, align 8
  %14 = load i64, ptr %.atomictmp.i, align 8
  %15 = cmpxchg ptr %this1.i13, i64 %13, i64 %14 monotonic monotonic, align 8
  %16 = extractvalue { i64, i1 } %15, 0
  %17 = extractvalue { i64, i1 } %15, 1
  br i1 %17, label %cmpxchg.continue.i, label %cmpxchg.store_expected.i

acquire_fail.i:                                   ; preds = %monotonic.i16, %monotonic.i16
  %18 = load i64, ptr %10, align 8
  %19 = load i64, ptr %.atomictmp.i, align 8
  %20 = cmpxchg ptr %this1.i13, i64 %18, i64 %19 monotonic acquire, align 8
  %21 = extractvalue { i64, i1 } %20, 0
  %22 = extractvalue { i64, i1 } %20, 1
  br i1 %22, label %cmpxchg.continue4.i, label %cmpxchg.store_expected3.i

seqcst_fail.i:                                    ; preds = %monotonic.i16
  %23 = load i64, ptr %10, align 8
  %24 = load i64, ptr %.atomictmp.i, align 8
  %25 = cmpxchg ptr %this1.i13, i64 %23, i64 %24 monotonic seq_cst, align 8
  %26 = extractvalue { i64, i1 } %25, 0
  %27 = extractvalue { i64, i1 } %25, 1
  br i1 %27, label %cmpxchg.continue7.i, label %cmpxchg.store_expected6.i

atomic.continue2.i:                               ; preds = %cmpxchg.continue7.i, %cmpxchg.continue4.i, %cmpxchg.continue.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected.i:                         ; preds = %monotonic_fail.i
  store i64 %16, ptr %10, align 8
  br label %cmpxchg.continue.i

cmpxchg.continue.i:                               ; preds = %cmpxchg.store_expected.i, %monotonic_fail.i
  %frombool.i = zext i1 %17 to i8
  store i8 %frombool.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected3.i:                        ; preds = %acquire_fail.i
  store i64 %21, ptr %10, align 8
  br label %cmpxchg.continue4.i

cmpxchg.continue4.i:                              ; preds = %cmpxchg.store_expected3.i, %acquire_fail.i
  %frombool5.i = zext i1 %22 to i8
  store i8 %frombool5.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected6.i:                        ; preds = %seqcst_fail.i
  store i64 %26, ptr %10, align 8
  br label %cmpxchg.continue7.i

cmpxchg.continue7.i:                              ; preds = %cmpxchg.store_expected6.i, %seqcst_fail.i
  %frombool8.i = zext i1 %27 to i8
  store i8 %frombool8.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

monotonic_fail9.i:                                ; preds = %acquire.i15
  %28 = load i64, ptr %10, align 8
  %29 = load i64, ptr %.atomictmp.i, align 8
  %30 = cmpxchg ptr %this1.i13, i64 %28, i64 %29 acquire monotonic, align 8
  %31 = extractvalue { i64, i1 } %30, 0
  %32 = extractvalue { i64, i1 } %30, 1
  br i1 %32, label %cmpxchg.continue14.i, label %cmpxchg.store_expected13.i

acquire_fail10.i:                                 ; preds = %acquire.i15, %acquire.i15
  %33 = load i64, ptr %10, align 8
  %34 = load i64, ptr %.atomictmp.i, align 8
  %35 = cmpxchg ptr %this1.i13, i64 %33, i64 %34 acquire acquire, align 8
  %36 = extractvalue { i64, i1 } %35, 0
  %37 = extractvalue { i64, i1 } %35, 1
  br i1 %37, label %cmpxchg.continue17.i, label %cmpxchg.store_expected16.i

seqcst_fail11.i:                                  ; preds = %acquire.i15
  %38 = load i64, ptr %10, align 8
  %39 = load i64, ptr %.atomictmp.i, align 8
  %40 = cmpxchg ptr %this1.i13, i64 %38, i64 %39 acquire seq_cst, align 8
  %41 = extractvalue { i64, i1 } %40, 0
  %42 = extractvalue { i64, i1 } %40, 1
  br i1 %42, label %cmpxchg.continue20.i, label %cmpxchg.store_expected19.i

atomic.continue12.i:                              ; preds = %cmpxchg.continue20.i, %cmpxchg.continue17.i, %cmpxchg.continue14.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected13.i:                       ; preds = %monotonic_fail9.i
  store i64 %31, ptr %10, align 8
  br label %cmpxchg.continue14.i

cmpxchg.continue14.i:                             ; preds = %cmpxchg.store_expected13.i, %monotonic_fail9.i
  %frombool15.i = zext i1 %32 to i8
  store i8 %frombool15.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected16.i:                       ; preds = %acquire_fail10.i
  store i64 %36, ptr %10, align 8
  br label %cmpxchg.continue17.i

cmpxchg.continue17.i:                             ; preds = %cmpxchg.store_expected16.i, %acquire_fail10.i
  %frombool18.i = zext i1 %37 to i8
  store i8 %frombool18.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected19.i:                       ; preds = %seqcst_fail11.i
  store i64 %41, ptr %10, align 8
  br label %cmpxchg.continue20.i

cmpxchg.continue20.i:                             ; preds = %cmpxchg.store_expected19.i, %seqcst_fail11.i
  %frombool21.i = zext i1 %42 to i8
  store i8 %frombool21.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

monotonic_fail22.i:                               ; preds = %release.i
  %43 = load i64, ptr %10, align 8
  %44 = load i64, ptr %.atomictmp.i, align 8
  %45 = cmpxchg ptr %this1.i13, i64 %43, i64 %44 release monotonic, align 8
  %46 = extractvalue { i64, i1 } %45, 0
  %47 = extractvalue { i64, i1 } %45, 1
  br i1 %47, label %cmpxchg.continue27.i, label %cmpxchg.store_expected26.i

acquire_fail23.i:                                 ; preds = %release.i, %release.i
  %48 = load i64, ptr %10, align 8
  %49 = load i64, ptr %.atomictmp.i, align 8
  %50 = cmpxchg ptr %this1.i13, i64 %48, i64 %49 release acquire, align 8
  %51 = extractvalue { i64, i1 } %50, 0
  %52 = extractvalue { i64, i1 } %50, 1
  br i1 %52, label %cmpxchg.continue30.i, label %cmpxchg.store_expected29.i

seqcst_fail24.i:                                  ; preds = %release.i
  %53 = load i64, ptr %10, align 8
  %54 = load i64, ptr %.atomictmp.i, align 8
  %55 = cmpxchg ptr %this1.i13, i64 %53, i64 %54 release seq_cst, align 8
  %56 = extractvalue { i64, i1 } %55, 0
  %57 = extractvalue { i64, i1 } %55, 1
  br i1 %57, label %cmpxchg.continue33.i, label %cmpxchg.store_expected32.i

atomic.continue25.i:                              ; preds = %cmpxchg.continue33.i, %cmpxchg.continue30.i, %cmpxchg.continue27.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected26.i:                       ; preds = %monotonic_fail22.i
  store i64 %46, ptr %10, align 8
  br label %cmpxchg.continue27.i

cmpxchg.continue27.i:                             ; preds = %cmpxchg.store_expected26.i, %monotonic_fail22.i
  %frombool28.i = zext i1 %47 to i8
  store i8 %frombool28.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected29.i:                       ; preds = %acquire_fail23.i
  store i64 %51, ptr %10, align 8
  br label %cmpxchg.continue30.i

cmpxchg.continue30.i:                             ; preds = %cmpxchg.store_expected29.i, %acquire_fail23.i
  %frombool31.i = zext i1 %52 to i8
  store i8 %frombool31.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected32.i:                       ; preds = %seqcst_fail24.i
  store i64 %56, ptr %10, align 8
  br label %cmpxchg.continue33.i

cmpxchg.continue33.i:                             ; preds = %cmpxchg.store_expected32.i, %seqcst_fail24.i
  %frombool34.i = zext i1 %57 to i8
  store i8 %frombool34.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

monotonic_fail35.i:                               ; preds = %acqrel.i
  %58 = load i64, ptr %10, align 8
  %59 = load i64, ptr %.atomictmp.i, align 8
  %60 = cmpxchg ptr %this1.i13, i64 %58, i64 %59 acq_rel monotonic, align 8
  %61 = extractvalue { i64, i1 } %60, 0
  %62 = extractvalue { i64, i1 } %60, 1
  br i1 %62, label %cmpxchg.continue40.i, label %cmpxchg.store_expected39.i

acquire_fail36.i:                                 ; preds = %acqrel.i, %acqrel.i
  %63 = load i64, ptr %10, align 8
  %64 = load i64, ptr %.atomictmp.i, align 8
  %65 = cmpxchg ptr %this1.i13, i64 %63, i64 %64 acq_rel acquire, align 8
  %66 = extractvalue { i64, i1 } %65, 0
  %67 = extractvalue { i64, i1 } %65, 1
  br i1 %67, label %cmpxchg.continue43.i, label %cmpxchg.store_expected42.i

seqcst_fail37.i:                                  ; preds = %acqrel.i
  %68 = load i64, ptr %10, align 8
  %69 = load i64, ptr %.atomictmp.i, align 8
  %70 = cmpxchg ptr %this1.i13, i64 %68, i64 %69 acq_rel seq_cst, align 8
  %71 = extractvalue { i64, i1 } %70, 0
  %72 = extractvalue { i64, i1 } %70, 1
  br i1 %72, label %cmpxchg.continue46.i, label %cmpxchg.store_expected45.i

atomic.continue38.i:                              ; preds = %cmpxchg.continue46.i, %cmpxchg.continue43.i, %cmpxchg.continue40.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected39.i:                       ; preds = %monotonic_fail35.i
  store i64 %61, ptr %10, align 8
  br label %cmpxchg.continue40.i

cmpxchg.continue40.i:                             ; preds = %cmpxchg.store_expected39.i, %monotonic_fail35.i
  %frombool41.i = zext i1 %62 to i8
  store i8 %frombool41.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected42.i:                       ; preds = %acquire_fail36.i
  store i64 %66, ptr %10, align 8
  br label %cmpxchg.continue43.i

cmpxchg.continue43.i:                             ; preds = %cmpxchg.store_expected42.i, %acquire_fail36.i
  %frombool44.i = zext i1 %67 to i8
  store i8 %frombool44.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected45.i:                       ; preds = %seqcst_fail37.i
  store i64 %71, ptr %10, align 8
  br label %cmpxchg.continue46.i

cmpxchg.continue46.i:                             ; preds = %cmpxchg.store_expected45.i, %seqcst_fail37.i
  %frombool47.i = zext i1 %72 to i8
  store i8 %frombool47.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

monotonic_fail48.i:                               ; preds = %seqcst.i14
  %73 = load i64, ptr %10, align 8
  %74 = load i64, ptr %.atomictmp.i, align 8
  %75 = cmpxchg ptr %this1.i13, i64 %73, i64 %74 seq_cst monotonic, align 8
  %76 = extractvalue { i64, i1 } %75, 0
  %77 = extractvalue { i64, i1 } %75, 1
  br i1 %77, label %cmpxchg.continue53.i, label %cmpxchg.store_expected52.i

acquire_fail49.i:                                 ; preds = %seqcst.i14, %seqcst.i14
  %78 = load i64, ptr %10, align 8
  %79 = load i64, ptr %.atomictmp.i, align 8
  %80 = cmpxchg ptr %this1.i13, i64 %78, i64 %79 seq_cst acquire, align 8
  %81 = extractvalue { i64, i1 } %80, 0
  %82 = extractvalue { i64, i1 } %80, 1
  br i1 %82, label %cmpxchg.continue56.i, label %cmpxchg.store_expected55.i

seqcst_fail50.i:                                  ; preds = %seqcst.i14
  %83 = load i64, ptr %10, align 8
  %84 = load i64, ptr %.atomictmp.i, align 8
  %85 = cmpxchg ptr %this1.i13, i64 %83, i64 %84 seq_cst seq_cst, align 8
  %86 = extractvalue { i64, i1 } %85, 0
  %87 = extractvalue { i64, i1 } %85, 1
  br i1 %87, label %cmpxchg.continue59.i, label %cmpxchg.store_expected58.i

atomic.continue51.i:                              ; preds = %cmpxchg.continue59.i, %cmpxchg.continue56.i, %cmpxchg.continue53.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected52.i:                       ; preds = %monotonic_fail48.i
  store i64 %76, ptr %10, align 8
  br label %cmpxchg.continue53.i

cmpxchg.continue53.i:                             ; preds = %cmpxchg.store_expected52.i, %monotonic_fail48.i
  %frombool54.i = zext i1 %77 to i8
  store i8 %frombool54.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected55.i:                       ; preds = %acquire_fail49.i
  store i64 %81, ptr %10, align 8
  br label %cmpxchg.continue56.i

cmpxchg.continue56.i:                             ; preds = %cmpxchg.store_expected55.i, %acquire_fail49.i
  %frombool57.i = zext i1 %82 to i8
  store i8 %frombool57.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected58.i:                       ; preds = %seqcst_fail50.i
  store i64 %86, ptr %10, align 8
  br label %cmpxchg.continue59.i

cmpxchg.continue59.i:                             ; preds = %cmpxchg.store_expected58.i, %seqcst_fail50.i
  %frombool60.i = zext i1 %87 to i8
  store i8 %frombool60.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit: ; preds = %atomic.continue51.i, %atomic.continue38.i, %atomic.continue25.i, %atomic.continue12.i, %atomic.continue2.i
  %88 = load i8, ptr %cmpxchg.bool.i, align 1
  %tobool.i = trunc i8 %88 to i1
  br i1 %tobool.i, label %if.then5, label %if.end6

if.then5:                                         ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit
  call void @_ZN4abslL18DebugOnlyLockEnterEPNS_5MutexE(ptr noundef %this1)
  store i1 true, ptr %retval, align 1
  br label %return

if.end6:                                          ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit
  br label %for.inc

for.inc:                                          ; preds = %if.end6
  %89 = load i32, ptr %loop_limit, align 4
  %dec = add nsw i32 %89, -1
  store i32 %dec, ptr %loop_limit, align 4
  br label %for.cond, !llvm.loop !23

for.end:                                          ; preds = %if.then, %for.cond
  %90 = load i64, ptr %v, align 8
  %and7 = and i64 %90, 16
  %cmp8 = icmp eq i64 %and7, 0
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %for.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end10:                                         ; preds = %for.end
  %call11 = call noundef zeroext i1 @_ZN4absl5Mutex17ReaderTryLockSlowEv(ptr noundef nonnull align 8 dereferenceable(8) %this1)
  store i1 %call11, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end10, %if.then9, %if.then5
  %91 = load i1, ptr %retval, align 1
  ret i1 %91
}

; Function Attrs: mustprogress uwtable
define dso_local noundef zeroext i1 @_ZN4absl5Mutex17ReaderTryLockSlowEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 align 2 {
entry:
  %this.addr.i5 = alloca ptr, align 8
  %__i1.addr.i = alloca ptr, align 8
  %__i2.addr.i = alloca i64, align 8
  %__m1.addr.i = alloca i32, align 4
  %__m2.addr.i = alloca i32, align 4
  %.atomictmp.i = alloca i64, align 8
  %cmpxchg.bool.i = alloca i8, align 1
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i64, align 8
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  %v = alloca i64, align 8
  %loop_limit = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mu_ = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  store ptr %mu_, ptr %this.addr.i, align 8
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %0 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %0, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %1 = load i32, ptr %__m.addr.i, align 4
  switch i32 %1, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %entry
  %2 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %2, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %entry, %entry
  %3 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %3, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %entry
  %4 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %4, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %5 = load i64, ptr %atomic-temp.i, align 8
  store i64 %5, ptr %v, align 8
  store i32 5, ptr %loop_limit, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  %6 = load i32, ptr %loop_limit, align 4
  %cmp = icmp ne i32 %6, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i64, ptr %v, align 8
  %and = and i64 %7, 12
  %cmp2 = icmp eq i64 %and, 0
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %mu_3 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %8 = load i64, ptr %v, align 8
  %or = or i64 1, %8
  %add = add nsw i64 %or, 256
  store ptr %mu_3, ptr %this.addr.i5, align 8
  store ptr %v, ptr %__i1.addr.i, align 8
  store i64 %add, ptr %__i2.addr.i, align 8
  store i32 2, ptr %__m1.addr.i, align 4
  store i32 0, ptr %__m2.addr.i, align 4
  %this1.i6 = load ptr, ptr %this.addr.i5, align 8
  %9 = load i32, ptr %__m1.addr.i, align 4
  %10 = load ptr, ptr %__i1.addr.i, align 8
  %11 = load i64, ptr %__i2.addr.i, align 8
  store i64 %11, ptr %.atomictmp.i, align 8
  %12 = load i32, ptr %__m2.addr.i, align 4
  switch i32 %9, label %monotonic.i9 [
    i32 1, label %acquire.i8
    i32 2, label %acquire.i8
    i32 3, label %release.i
    i32 4, label %acqrel.i
    i32 5, label %seqcst.i7
  ]

monotonic.i9:                                     ; preds = %land.lhs.true
  switch i32 %12, label %monotonic_fail.i [
    i32 1, label %acquire_fail.i
    i32 2, label %acquire_fail.i
    i32 5, label %seqcst_fail.i
  ]

acquire.i8:                                       ; preds = %land.lhs.true, %land.lhs.true
  switch i32 %12, label %monotonic_fail9.i [
    i32 1, label %acquire_fail10.i
    i32 2, label %acquire_fail10.i
    i32 5, label %seqcst_fail11.i
  ]

release.i:                                        ; preds = %land.lhs.true
  switch i32 %12, label %monotonic_fail22.i [
    i32 1, label %acquire_fail23.i
    i32 2, label %acquire_fail23.i
    i32 5, label %seqcst_fail24.i
  ]

acqrel.i:                                         ; preds = %land.lhs.true
  switch i32 %12, label %monotonic_fail35.i [
    i32 1, label %acquire_fail36.i
    i32 2, label %acquire_fail36.i
    i32 5, label %seqcst_fail37.i
  ]

seqcst.i7:                                        ; preds = %land.lhs.true
  switch i32 %12, label %monotonic_fail48.i [
    i32 1, label %acquire_fail49.i
    i32 2, label %acquire_fail49.i
    i32 5, label %seqcst_fail50.i
  ]

monotonic_fail.i:                                 ; preds = %monotonic.i9
  %13 = load i64, ptr %10, align 8
  %14 = load i64, ptr %.atomictmp.i, align 8
  %15 = cmpxchg ptr %this1.i6, i64 %13, i64 %14 monotonic monotonic, align 8
  %16 = extractvalue { i64, i1 } %15, 0
  %17 = extractvalue { i64, i1 } %15, 1
  br i1 %17, label %cmpxchg.continue.i, label %cmpxchg.store_expected.i

acquire_fail.i:                                   ; preds = %monotonic.i9, %monotonic.i9
  %18 = load i64, ptr %10, align 8
  %19 = load i64, ptr %.atomictmp.i, align 8
  %20 = cmpxchg ptr %this1.i6, i64 %18, i64 %19 monotonic acquire, align 8
  %21 = extractvalue { i64, i1 } %20, 0
  %22 = extractvalue { i64, i1 } %20, 1
  br i1 %22, label %cmpxchg.continue4.i, label %cmpxchg.store_expected3.i

seqcst_fail.i:                                    ; preds = %monotonic.i9
  %23 = load i64, ptr %10, align 8
  %24 = load i64, ptr %.atomictmp.i, align 8
  %25 = cmpxchg ptr %this1.i6, i64 %23, i64 %24 monotonic seq_cst, align 8
  %26 = extractvalue { i64, i1 } %25, 0
  %27 = extractvalue { i64, i1 } %25, 1
  br i1 %27, label %cmpxchg.continue7.i, label %cmpxchg.store_expected6.i

atomic.continue2.i:                               ; preds = %cmpxchg.continue7.i, %cmpxchg.continue4.i, %cmpxchg.continue.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected.i:                         ; preds = %monotonic_fail.i
  store i64 %16, ptr %10, align 8
  br label %cmpxchg.continue.i

cmpxchg.continue.i:                               ; preds = %cmpxchg.store_expected.i, %monotonic_fail.i
  %frombool.i = zext i1 %17 to i8
  store i8 %frombool.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected3.i:                        ; preds = %acquire_fail.i
  store i64 %21, ptr %10, align 8
  br label %cmpxchg.continue4.i

cmpxchg.continue4.i:                              ; preds = %cmpxchg.store_expected3.i, %acquire_fail.i
  %frombool5.i = zext i1 %22 to i8
  store i8 %frombool5.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected6.i:                        ; preds = %seqcst_fail.i
  store i64 %26, ptr %10, align 8
  br label %cmpxchg.continue7.i

cmpxchg.continue7.i:                              ; preds = %cmpxchg.store_expected6.i, %seqcst_fail.i
  %frombool8.i = zext i1 %27 to i8
  store i8 %frombool8.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

monotonic_fail9.i:                                ; preds = %acquire.i8
  %28 = load i64, ptr %10, align 8
  %29 = load i64, ptr %.atomictmp.i, align 8
  %30 = cmpxchg ptr %this1.i6, i64 %28, i64 %29 acquire monotonic, align 8
  %31 = extractvalue { i64, i1 } %30, 0
  %32 = extractvalue { i64, i1 } %30, 1
  br i1 %32, label %cmpxchg.continue14.i, label %cmpxchg.store_expected13.i

acquire_fail10.i:                                 ; preds = %acquire.i8, %acquire.i8
  %33 = load i64, ptr %10, align 8
  %34 = load i64, ptr %.atomictmp.i, align 8
  %35 = cmpxchg ptr %this1.i6, i64 %33, i64 %34 acquire acquire, align 8
  %36 = extractvalue { i64, i1 } %35, 0
  %37 = extractvalue { i64, i1 } %35, 1
  br i1 %37, label %cmpxchg.continue17.i, label %cmpxchg.store_expected16.i

seqcst_fail11.i:                                  ; preds = %acquire.i8
  %38 = load i64, ptr %10, align 8
  %39 = load i64, ptr %.atomictmp.i, align 8
  %40 = cmpxchg ptr %this1.i6, i64 %38, i64 %39 acquire seq_cst, align 8
  %41 = extractvalue { i64, i1 } %40, 0
  %42 = extractvalue { i64, i1 } %40, 1
  br i1 %42, label %cmpxchg.continue20.i, label %cmpxchg.store_expected19.i

atomic.continue12.i:                              ; preds = %cmpxchg.continue20.i, %cmpxchg.continue17.i, %cmpxchg.continue14.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected13.i:                       ; preds = %monotonic_fail9.i
  store i64 %31, ptr %10, align 8
  br label %cmpxchg.continue14.i

cmpxchg.continue14.i:                             ; preds = %cmpxchg.store_expected13.i, %monotonic_fail9.i
  %frombool15.i = zext i1 %32 to i8
  store i8 %frombool15.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected16.i:                       ; preds = %acquire_fail10.i
  store i64 %36, ptr %10, align 8
  br label %cmpxchg.continue17.i

cmpxchg.continue17.i:                             ; preds = %cmpxchg.store_expected16.i, %acquire_fail10.i
  %frombool18.i = zext i1 %37 to i8
  store i8 %frombool18.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected19.i:                       ; preds = %seqcst_fail11.i
  store i64 %41, ptr %10, align 8
  br label %cmpxchg.continue20.i

cmpxchg.continue20.i:                             ; preds = %cmpxchg.store_expected19.i, %seqcst_fail11.i
  %frombool21.i = zext i1 %42 to i8
  store i8 %frombool21.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

monotonic_fail22.i:                               ; preds = %release.i
  %43 = load i64, ptr %10, align 8
  %44 = load i64, ptr %.atomictmp.i, align 8
  %45 = cmpxchg ptr %this1.i6, i64 %43, i64 %44 release monotonic, align 8
  %46 = extractvalue { i64, i1 } %45, 0
  %47 = extractvalue { i64, i1 } %45, 1
  br i1 %47, label %cmpxchg.continue27.i, label %cmpxchg.store_expected26.i

acquire_fail23.i:                                 ; preds = %release.i, %release.i
  %48 = load i64, ptr %10, align 8
  %49 = load i64, ptr %.atomictmp.i, align 8
  %50 = cmpxchg ptr %this1.i6, i64 %48, i64 %49 release acquire, align 8
  %51 = extractvalue { i64, i1 } %50, 0
  %52 = extractvalue { i64, i1 } %50, 1
  br i1 %52, label %cmpxchg.continue30.i, label %cmpxchg.store_expected29.i

seqcst_fail24.i:                                  ; preds = %release.i
  %53 = load i64, ptr %10, align 8
  %54 = load i64, ptr %.atomictmp.i, align 8
  %55 = cmpxchg ptr %this1.i6, i64 %53, i64 %54 release seq_cst, align 8
  %56 = extractvalue { i64, i1 } %55, 0
  %57 = extractvalue { i64, i1 } %55, 1
  br i1 %57, label %cmpxchg.continue33.i, label %cmpxchg.store_expected32.i

atomic.continue25.i:                              ; preds = %cmpxchg.continue33.i, %cmpxchg.continue30.i, %cmpxchg.continue27.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected26.i:                       ; preds = %monotonic_fail22.i
  store i64 %46, ptr %10, align 8
  br label %cmpxchg.continue27.i

cmpxchg.continue27.i:                             ; preds = %cmpxchg.store_expected26.i, %monotonic_fail22.i
  %frombool28.i = zext i1 %47 to i8
  store i8 %frombool28.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected29.i:                       ; preds = %acquire_fail23.i
  store i64 %51, ptr %10, align 8
  br label %cmpxchg.continue30.i

cmpxchg.continue30.i:                             ; preds = %cmpxchg.store_expected29.i, %acquire_fail23.i
  %frombool31.i = zext i1 %52 to i8
  store i8 %frombool31.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected32.i:                       ; preds = %seqcst_fail24.i
  store i64 %56, ptr %10, align 8
  br label %cmpxchg.continue33.i

cmpxchg.continue33.i:                             ; preds = %cmpxchg.store_expected32.i, %seqcst_fail24.i
  %frombool34.i = zext i1 %57 to i8
  store i8 %frombool34.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

monotonic_fail35.i:                               ; preds = %acqrel.i
  %58 = load i64, ptr %10, align 8
  %59 = load i64, ptr %.atomictmp.i, align 8
  %60 = cmpxchg ptr %this1.i6, i64 %58, i64 %59 acq_rel monotonic, align 8
  %61 = extractvalue { i64, i1 } %60, 0
  %62 = extractvalue { i64, i1 } %60, 1
  br i1 %62, label %cmpxchg.continue40.i, label %cmpxchg.store_expected39.i

acquire_fail36.i:                                 ; preds = %acqrel.i, %acqrel.i
  %63 = load i64, ptr %10, align 8
  %64 = load i64, ptr %.atomictmp.i, align 8
  %65 = cmpxchg ptr %this1.i6, i64 %63, i64 %64 acq_rel acquire, align 8
  %66 = extractvalue { i64, i1 } %65, 0
  %67 = extractvalue { i64, i1 } %65, 1
  br i1 %67, label %cmpxchg.continue43.i, label %cmpxchg.store_expected42.i

seqcst_fail37.i:                                  ; preds = %acqrel.i
  %68 = load i64, ptr %10, align 8
  %69 = load i64, ptr %.atomictmp.i, align 8
  %70 = cmpxchg ptr %this1.i6, i64 %68, i64 %69 acq_rel seq_cst, align 8
  %71 = extractvalue { i64, i1 } %70, 0
  %72 = extractvalue { i64, i1 } %70, 1
  br i1 %72, label %cmpxchg.continue46.i, label %cmpxchg.store_expected45.i

atomic.continue38.i:                              ; preds = %cmpxchg.continue46.i, %cmpxchg.continue43.i, %cmpxchg.continue40.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected39.i:                       ; preds = %monotonic_fail35.i
  store i64 %61, ptr %10, align 8
  br label %cmpxchg.continue40.i

cmpxchg.continue40.i:                             ; preds = %cmpxchg.store_expected39.i, %monotonic_fail35.i
  %frombool41.i = zext i1 %62 to i8
  store i8 %frombool41.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected42.i:                       ; preds = %acquire_fail36.i
  store i64 %66, ptr %10, align 8
  br label %cmpxchg.continue43.i

cmpxchg.continue43.i:                             ; preds = %cmpxchg.store_expected42.i, %acquire_fail36.i
  %frombool44.i = zext i1 %67 to i8
  store i8 %frombool44.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected45.i:                       ; preds = %seqcst_fail37.i
  store i64 %71, ptr %10, align 8
  br label %cmpxchg.continue46.i

cmpxchg.continue46.i:                             ; preds = %cmpxchg.store_expected45.i, %seqcst_fail37.i
  %frombool47.i = zext i1 %72 to i8
  store i8 %frombool47.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

monotonic_fail48.i:                               ; preds = %seqcst.i7
  %73 = load i64, ptr %10, align 8
  %74 = load i64, ptr %.atomictmp.i, align 8
  %75 = cmpxchg ptr %this1.i6, i64 %73, i64 %74 seq_cst monotonic, align 8
  %76 = extractvalue { i64, i1 } %75, 0
  %77 = extractvalue { i64, i1 } %75, 1
  br i1 %77, label %cmpxchg.continue53.i, label %cmpxchg.store_expected52.i

acquire_fail49.i:                                 ; preds = %seqcst.i7, %seqcst.i7
  %78 = load i64, ptr %10, align 8
  %79 = load i64, ptr %.atomictmp.i, align 8
  %80 = cmpxchg ptr %this1.i6, i64 %78, i64 %79 seq_cst acquire, align 8
  %81 = extractvalue { i64, i1 } %80, 0
  %82 = extractvalue { i64, i1 } %80, 1
  br i1 %82, label %cmpxchg.continue56.i, label %cmpxchg.store_expected55.i

seqcst_fail50.i:                                  ; preds = %seqcst.i7
  %83 = load i64, ptr %10, align 8
  %84 = load i64, ptr %.atomictmp.i, align 8
  %85 = cmpxchg ptr %this1.i6, i64 %83, i64 %84 seq_cst seq_cst, align 8
  %86 = extractvalue { i64, i1 } %85, 0
  %87 = extractvalue { i64, i1 } %85, 1
  br i1 %87, label %cmpxchg.continue59.i, label %cmpxchg.store_expected58.i

atomic.continue51.i:                              ; preds = %cmpxchg.continue59.i, %cmpxchg.continue56.i, %cmpxchg.continue53.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected52.i:                       ; preds = %monotonic_fail48.i
  store i64 %76, ptr %10, align 8
  br label %cmpxchg.continue53.i

cmpxchg.continue53.i:                             ; preds = %cmpxchg.store_expected52.i, %monotonic_fail48.i
  %frombool54.i = zext i1 %77 to i8
  store i8 %frombool54.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected55.i:                       ; preds = %acquire_fail49.i
  store i64 %81, ptr %10, align 8
  br label %cmpxchg.continue56.i

cmpxchg.continue56.i:                             ; preds = %cmpxchg.store_expected55.i, %acquire_fail49.i
  %frombool57.i = zext i1 %82 to i8
  store i8 %frombool57.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected58.i:                       ; preds = %seqcst_fail50.i
  store i64 %86, ptr %10, align 8
  br label %cmpxchg.continue59.i

cmpxchg.continue59.i:                             ; preds = %cmpxchg.store_expected58.i, %seqcst_fail50.i
  %frombool60.i = zext i1 %87 to i8
  store i8 %frombool60.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit: ; preds = %atomic.continue51.i, %atomic.continue38.i, %atomic.continue25.i, %atomic.continue12.i, %atomic.continue2.i
  %88 = load i8, ptr %cmpxchg.bool.i, align 1
  %tobool.i = trunc i8 %88 to i1
  br i1 %tobool.i, label %if.then, label %if.end

if.then:                                          ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit
  call void @_ZN4abslL18DebugOnlyLockEnterEPNS_5MutexE(ptr noundef %this1)
  call void @_ZN4abslL14PostSynchEventEPvi(ptr noundef %this1, i32 noundef 2)
  store i1 true, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %89 = load i32, ptr %loop_limit, align 4
  %dec = add nsw i32 %89, -1
  store i32 %dec, ptr %loop_limit, align 4
  br label %for.cond, !llvm.loop !25

for.end:                                          ; preds = %for.cond
  call void @_ZN4abslL14PostSynchEventEPvi(ptr noundef %this1, i32 noundef 3)
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then
  %90 = load i1, ptr %retval, align 1
  ret i1 %90
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN4absl5Mutex6UnlockEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 align 2 {
entry:
  %this.addr.i11 = alloca ptr, align 8
  %__i1.addr.i = alloca ptr, align 8
  %__i2.addr.i = alloca i64, align 8
  %__m1.addr.i = alloca i32, align 4
  %__m2.addr.i = alloca i32, align 4
  %.atomictmp.i = alloca i64, align 8
  %cmpxchg.bool.i = alloca i8, align 1
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i64, align 8
  %this.addr = alloca ptr, align 8
  %v = alloca i64, align 8
  %should_try_cas = alloca i8, align 1
  %x = alloca i64, align 8
  %y = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4abslL18DebugOnlyLockLeaveEPNS_5MutexE(ptr noundef %this1)
  %mu_ = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  store ptr %mu_, ptr %this.addr.i, align 8
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %0 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %0, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %1 = load i32, ptr %__m.addr.i, align 4
  switch i32 %1, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %entry
  %2 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %2, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %entry, %entry
  %3 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %3, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %entry
  %4 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %4, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %5 = load i64, ptr %atomic-temp.i, align 8
  store i64 %5, ptr %v, align 8
  %6 = load i64, ptr %v, align 8
  %and = and i64 %6, 24
  %cmp = icmp eq i64 %and, 8
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  %7 = load i64, ptr %v, align 8
  %and2 = and i64 %7, 6
  %cmp3 = icmp ne i64 %and2, 4
  br label %land.end

land.end:                                         ; preds = %land.rhs, %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  %8 = phi i1 [ false, %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit ], [ %cmp3, %land.rhs ]
  %frombool = zext i1 %8 to i8
  store i8 %frombool, ptr %should_try_cas, align 1
  %9 = load i64, ptr %v, align 8
  %xor = xor i64 %9, 12
  %and4 = and i64 %xor, 24
  store i64 %and4, ptr %x, align 8
  %10 = load i64, ptr %v, align 8
  %xor5 = xor i64 %10, 12
  %and6 = and i64 %xor5, 6
  store i64 %and6, ptr %y, align 8
  %11 = load i64, ptr %x, align 8
  %12 = load i64, ptr %y, align 8
  %cmp7 = icmp slt i64 %11, %12
  br i1 %cmp7, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %land.end
  %mu_8 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %13 = load i64, ptr %v, align 8
  %and9 = and i64 %13, -41
  store ptr %mu_8, ptr %this.addr.i11, align 8
  store ptr %v, ptr %__i1.addr.i, align 8
  store i64 %and9, ptr %__i2.addr.i, align 8
  store i32 3, ptr %__m1.addr.i, align 4
  store i32 0, ptr %__m2.addr.i, align 4
  %this1.i12 = load ptr, ptr %this.addr.i11, align 8
  %14 = load i32, ptr %__m1.addr.i, align 4
  %15 = load ptr, ptr %__i1.addr.i, align 8
  %16 = load i64, ptr %__i2.addr.i, align 8
  store i64 %16, ptr %.atomictmp.i, align 8
  %17 = load i32, ptr %__m2.addr.i, align 4
  switch i32 %14, label %monotonic.i15 [
    i32 1, label %acquire.i14
    i32 2, label %acquire.i14
    i32 3, label %release.i
    i32 4, label %acqrel.i
    i32 5, label %seqcst.i13
  ]

monotonic.i15:                                    ; preds = %land.lhs.true
  switch i32 %17, label %monotonic_fail.i [
    i32 1, label %acquire_fail.i
    i32 2, label %acquire_fail.i
    i32 5, label %seqcst_fail.i
  ]

acquire.i14:                                      ; preds = %land.lhs.true, %land.lhs.true
  switch i32 %17, label %monotonic_fail9.i [
    i32 1, label %acquire_fail10.i
    i32 2, label %acquire_fail10.i
    i32 5, label %seqcst_fail11.i
  ]

release.i:                                        ; preds = %land.lhs.true
  switch i32 %17, label %monotonic_fail22.i [
    i32 1, label %acquire_fail23.i
    i32 2, label %acquire_fail23.i
    i32 5, label %seqcst_fail24.i
  ]

acqrel.i:                                         ; preds = %land.lhs.true
  switch i32 %17, label %monotonic_fail35.i [
    i32 1, label %acquire_fail36.i
    i32 2, label %acquire_fail36.i
    i32 5, label %seqcst_fail37.i
  ]

seqcst.i13:                                       ; preds = %land.lhs.true
  switch i32 %17, label %monotonic_fail48.i [
    i32 1, label %acquire_fail49.i
    i32 2, label %acquire_fail49.i
    i32 5, label %seqcst_fail50.i
  ]

monotonic_fail.i:                                 ; preds = %monotonic.i15
  %18 = load i64, ptr %15, align 8
  %19 = load i64, ptr %.atomictmp.i, align 8
  %20 = cmpxchg ptr %this1.i12, i64 %18, i64 %19 monotonic monotonic, align 8
  %21 = extractvalue { i64, i1 } %20, 0
  %22 = extractvalue { i64, i1 } %20, 1
  br i1 %22, label %cmpxchg.continue.i, label %cmpxchg.store_expected.i

acquire_fail.i:                                   ; preds = %monotonic.i15, %monotonic.i15
  %23 = load i64, ptr %15, align 8
  %24 = load i64, ptr %.atomictmp.i, align 8
  %25 = cmpxchg ptr %this1.i12, i64 %23, i64 %24 monotonic acquire, align 8
  %26 = extractvalue { i64, i1 } %25, 0
  %27 = extractvalue { i64, i1 } %25, 1
  br i1 %27, label %cmpxchg.continue4.i, label %cmpxchg.store_expected3.i

seqcst_fail.i:                                    ; preds = %monotonic.i15
  %28 = load i64, ptr %15, align 8
  %29 = load i64, ptr %.atomictmp.i, align 8
  %30 = cmpxchg ptr %this1.i12, i64 %28, i64 %29 monotonic seq_cst, align 8
  %31 = extractvalue { i64, i1 } %30, 0
  %32 = extractvalue { i64, i1 } %30, 1
  br i1 %32, label %cmpxchg.continue7.i, label %cmpxchg.store_expected6.i

atomic.continue2.i:                               ; preds = %cmpxchg.continue7.i, %cmpxchg.continue4.i, %cmpxchg.continue.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected.i:                         ; preds = %monotonic_fail.i
  store i64 %21, ptr %15, align 8
  br label %cmpxchg.continue.i

cmpxchg.continue.i:                               ; preds = %cmpxchg.store_expected.i, %monotonic_fail.i
  %frombool.i = zext i1 %22 to i8
  store i8 %frombool.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected3.i:                        ; preds = %acquire_fail.i
  store i64 %26, ptr %15, align 8
  br label %cmpxchg.continue4.i

cmpxchg.continue4.i:                              ; preds = %cmpxchg.store_expected3.i, %acquire_fail.i
  %frombool5.i = zext i1 %27 to i8
  store i8 %frombool5.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected6.i:                        ; preds = %seqcst_fail.i
  store i64 %31, ptr %15, align 8
  br label %cmpxchg.continue7.i

cmpxchg.continue7.i:                              ; preds = %cmpxchg.store_expected6.i, %seqcst_fail.i
  %frombool8.i = zext i1 %32 to i8
  store i8 %frombool8.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

monotonic_fail9.i:                                ; preds = %acquire.i14
  %33 = load i64, ptr %15, align 8
  %34 = load i64, ptr %.atomictmp.i, align 8
  %35 = cmpxchg ptr %this1.i12, i64 %33, i64 %34 acquire monotonic, align 8
  %36 = extractvalue { i64, i1 } %35, 0
  %37 = extractvalue { i64, i1 } %35, 1
  br i1 %37, label %cmpxchg.continue14.i, label %cmpxchg.store_expected13.i

acquire_fail10.i:                                 ; preds = %acquire.i14, %acquire.i14
  %38 = load i64, ptr %15, align 8
  %39 = load i64, ptr %.atomictmp.i, align 8
  %40 = cmpxchg ptr %this1.i12, i64 %38, i64 %39 acquire acquire, align 8
  %41 = extractvalue { i64, i1 } %40, 0
  %42 = extractvalue { i64, i1 } %40, 1
  br i1 %42, label %cmpxchg.continue17.i, label %cmpxchg.store_expected16.i

seqcst_fail11.i:                                  ; preds = %acquire.i14
  %43 = load i64, ptr %15, align 8
  %44 = load i64, ptr %.atomictmp.i, align 8
  %45 = cmpxchg ptr %this1.i12, i64 %43, i64 %44 acquire seq_cst, align 8
  %46 = extractvalue { i64, i1 } %45, 0
  %47 = extractvalue { i64, i1 } %45, 1
  br i1 %47, label %cmpxchg.continue20.i, label %cmpxchg.store_expected19.i

atomic.continue12.i:                              ; preds = %cmpxchg.continue20.i, %cmpxchg.continue17.i, %cmpxchg.continue14.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected13.i:                       ; preds = %monotonic_fail9.i
  store i64 %36, ptr %15, align 8
  br label %cmpxchg.continue14.i

cmpxchg.continue14.i:                             ; preds = %cmpxchg.store_expected13.i, %monotonic_fail9.i
  %frombool15.i = zext i1 %37 to i8
  store i8 %frombool15.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected16.i:                       ; preds = %acquire_fail10.i
  store i64 %41, ptr %15, align 8
  br label %cmpxchg.continue17.i

cmpxchg.continue17.i:                             ; preds = %cmpxchg.store_expected16.i, %acquire_fail10.i
  %frombool18.i = zext i1 %42 to i8
  store i8 %frombool18.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected19.i:                       ; preds = %seqcst_fail11.i
  store i64 %46, ptr %15, align 8
  br label %cmpxchg.continue20.i

cmpxchg.continue20.i:                             ; preds = %cmpxchg.store_expected19.i, %seqcst_fail11.i
  %frombool21.i = zext i1 %47 to i8
  store i8 %frombool21.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

monotonic_fail22.i:                               ; preds = %release.i
  %48 = load i64, ptr %15, align 8
  %49 = load i64, ptr %.atomictmp.i, align 8
  %50 = cmpxchg ptr %this1.i12, i64 %48, i64 %49 release monotonic, align 8
  %51 = extractvalue { i64, i1 } %50, 0
  %52 = extractvalue { i64, i1 } %50, 1
  br i1 %52, label %cmpxchg.continue27.i, label %cmpxchg.store_expected26.i

acquire_fail23.i:                                 ; preds = %release.i, %release.i
  %53 = load i64, ptr %15, align 8
  %54 = load i64, ptr %.atomictmp.i, align 8
  %55 = cmpxchg ptr %this1.i12, i64 %53, i64 %54 release acquire, align 8
  %56 = extractvalue { i64, i1 } %55, 0
  %57 = extractvalue { i64, i1 } %55, 1
  br i1 %57, label %cmpxchg.continue30.i, label %cmpxchg.store_expected29.i

seqcst_fail24.i:                                  ; preds = %release.i
  %58 = load i64, ptr %15, align 8
  %59 = load i64, ptr %.atomictmp.i, align 8
  %60 = cmpxchg ptr %this1.i12, i64 %58, i64 %59 release seq_cst, align 8
  %61 = extractvalue { i64, i1 } %60, 0
  %62 = extractvalue { i64, i1 } %60, 1
  br i1 %62, label %cmpxchg.continue33.i, label %cmpxchg.store_expected32.i

atomic.continue25.i:                              ; preds = %cmpxchg.continue33.i, %cmpxchg.continue30.i, %cmpxchg.continue27.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected26.i:                       ; preds = %monotonic_fail22.i
  store i64 %51, ptr %15, align 8
  br label %cmpxchg.continue27.i

cmpxchg.continue27.i:                             ; preds = %cmpxchg.store_expected26.i, %monotonic_fail22.i
  %frombool28.i = zext i1 %52 to i8
  store i8 %frombool28.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected29.i:                       ; preds = %acquire_fail23.i
  store i64 %56, ptr %15, align 8
  br label %cmpxchg.continue30.i

cmpxchg.continue30.i:                             ; preds = %cmpxchg.store_expected29.i, %acquire_fail23.i
  %frombool31.i = zext i1 %57 to i8
  store i8 %frombool31.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected32.i:                       ; preds = %seqcst_fail24.i
  store i64 %61, ptr %15, align 8
  br label %cmpxchg.continue33.i

cmpxchg.continue33.i:                             ; preds = %cmpxchg.store_expected32.i, %seqcst_fail24.i
  %frombool34.i = zext i1 %62 to i8
  store i8 %frombool34.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

monotonic_fail35.i:                               ; preds = %acqrel.i
  %63 = load i64, ptr %15, align 8
  %64 = load i64, ptr %.atomictmp.i, align 8
  %65 = cmpxchg ptr %this1.i12, i64 %63, i64 %64 acq_rel monotonic, align 8
  %66 = extractvalue { i64, i1 } %65, 0
  %67 = extractvalue { i64, i1 } %65, 1
  br i1 %67, label %cmpxchg.continue40.i, label %cmpxchg.store_expected39.i

acquire_fail36.i:                                 ; preds = %acqrel.i, %acqrel.i
  %68 = load i64, ptr %15, align 8
  %69 = load i64, ptr %.atomictmp.i, align 8
  %70 = cmpxchg ptr %this1.i12, i64 %68, i64 %69 acq_rel acquire, align 8
  %71 = extractvalue { i64, i1 } %70, 0
  %72 = extractvalue { i64, i1 } %70, 1
  br i1 %72, label %cmpxchg.continue43.i, label %cmpxchg.store_expected42.i

seqcst_fail37.i:                                  ; preds = %acqrel.i
  %73 = load i64, ptr %15, align 8
  %74 = load i64, ptr %.atomictmp.i, align 8
  %75 = cmpxchg ptr %this1.i12, i64 %73, i64 %74 acq_rel seq_cst, align 8
  %76 = extractvalue { i64, i1 } %75, 0
  %77 = extractvalue { i64, i1 } %75, 1
  br i1 %77, label %cmpxchg.continue46.i, label %cmpxchg.store_expected45.i

atomic.continue38.i:                              ; preds = %cmpxchg.continue46.i, %cmpxchg.continue43.i, %cmpxchg.continue40.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected39.i:                       ; preds = %monotonic_fail35.i
  store i64 %66, ptr %15, align 8
  br label %cmpxchg.continue40.i

cmpxchg.continue40.i:                             ; preds = %cmpxchg.store_expected39.i, %monotonic_fail35.i
  %frombool41.i = zext i1 %67 to i8
  store i8 %frombool41.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected42.i:                       ; preds = %acquire_fail36.i
  store i64 %71, ptr %15, align 8
  br label %cmpxchg.continue43.i

cmpxchg.continue43.i:                             ; preds = %cmpxchg.store_expected42.i, %acquire_fail36.i
  %frombool44.i = zext i1 %72 to i8
  store i8 %frombool44.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected45.i:                       ; preds = %seqcst_fail37.i
  store i64 %76, ptr %15, align 8
  br label %cmpxchg.continue46.i

cmpxchg.continue46.i:                             ; preds = %cmpxchg.store_expected45.i, %seqcst_fail37.i
  %frombool47.i = zext i1 %77 to i8
  store i8 %frombool47.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

monotonic_fail48.i:                               ; preds = %seqcst.i13
  %78 = load i64, ptr %15, align 8
  %79 = load i64, ptr %.atomictmp.i, align 8
  %80 = cmpxchg ptr %this1.i12, i64 %78, i64 %79 seq_cst monotonic, align 8
  %81 = extractvalue { i64, i1 } %80, 0
  %82 = extractvalue { i64, i1 } %80, 1
  br i1 %82, label %cmpxchg.continue53.i, label %cmpxchg.store_expected52.i

acquire_fail49.i:                                 ; preds = %seqcst.i13, %seqcst.i13
  %83 = load i64, ptr %15, align 8
  %84 = load i64, ptr %.atomictmp.i, align 8
  %85 = cmpxchg ptr %this1.i12, i64 %83, i64 %84 seq_cst acquire, align 8
  %86 = extractvalue { i64, i1 } %85, 0
  %87 = extractvalue { i64, i1 } %85, 1
  br i1 %87, label %cmpxchg.continue56.i, label %cmpxchg.store_expected55.i

seqcst_fail50.i:                                  ; preds = %seqcst.i13
  %88 = load i64, ptr %15, align 8
  %89 = load i64, ptr %.atomictmp.i, align 8
  %90 = cmpxchg ptr %this1.i12, i64 %88, i64 %89 seq_cst seq_cst, align 8
  %91 = extractvalue { i64, i1 } %90, 0
  %92 = extractvalue { i64, i1 } %90, 1
  br i1 %92, label %cmpxchg.continue59.i, label %cmpxchg.store_expected58.i

atomic.continue51.i:                              ; preds = %cmpxchg.continue59.i, %cmpxchg.continue56.i, %cmpxchg.continue53.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected52.i:                       ; preds = %monotonic_fail48.i
  store i64 %81, ptr %15, align 8
  br label %cmpxchg.continue53.i

cmpxchg.continue53.i:                             ; preds = %cmpxchg.store_expected52.i, %monotonic_fail48.i
  %frombool54.i = zext i1 %82 to i8
  store i8 %frombool54.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected55.i:                       ; preds = %acquire_fail49.i
  store i64 %86, ptr %15, align 8
  br label %cmpxchg.continue56.i

cmpxchg.continue56.i:                             ; preds = %cmpxchg.store_expected55.i, %acquire_fail49.i
  %frombool57.i = zext i1 %87 to i8
  store i8 %frombool57.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected58.i:                       ; preds = %seqcst_fail50.i
  store i64 %91, ptr %15, align 8
  br label %cmpxchg.continue59.i

cmpxchg.continue59.i:                             ; preds = %cmpxchg.store_expected58.i, %seqcst_fail50.i
  %frombool60.i = zext i1 %92 to i8
  store i8 %frombool60.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit: ; preds = %atomic.continue51.i, %atomic.continue38.i, %atomic.continue25.i, %atomic.continue12.i, %atomic.continue2.i
  %93 = load i8, ptr %cmpxchg.bool.i, align 1
  %tobool.i = trunc i8 %93 to i1
  br i1 %tobool.i, label %if.then, label %if.else

if.then:                                          ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit
  br label %if.end

if.else:                                          ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit, %land.end
  call void @_ZN4absl5Mutex10UnlockSlowEPNS_15SynchWaitParamsE(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef null) #16
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZN4abslL18DebugOnlyLockLeaveEPNS_5MutexE(ptr noundef %mu) #1 {
entry:
  %mu.addr = alloca ptr, align 8
  store ptr %mu, ptr %mu.addr, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN4absl5Mutex12ReaderUnlockEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 align 2 {
entry:
  %this.addr.i7 = alloca ptr, align 8
  %__i1.addr.i = alloca ptr, align 8
  %__i2.addr.i = alloca i64, align 8
  %__m1.addr.i = alloca i32, align 4
  %__m2.addr.i = alloca i32, align 4
  %.atomictmp.i = alloca i64, align 8
  %cmpxchg.bool.i = alloca i8, align 1
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i64, align 8
  %this.addr = alloca ptr, align 8
  %v = alloca i64, align 8
  %clear = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4abslL18DebugOnlyLockLeaveEPNS_5MutexE(ptr noundef %this1)
  %mu_ = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  store ptr %mu_, ptr %this.addr.i, align 8
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %0 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %0, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %1 = load i32, ptr %__m.addr.i, align 4
  switch i32 %1, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %entry
  %2 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %2, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %entry, %entry
  %3 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %3, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %entry
  %4 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %4, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %5 = load i64, ptr %atomic-temp.i, align 8
  store i64 %5, ptr %v, align 8
  br label %for.cond

for.cond:                                         ; preds = %if.end6, %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  %6 = load i64, ptr %v, align 8
  %and = and i64 %6, 21
  %cmp = icmp ne i64 %and, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %for.cond
  call void @_ZN4absl5Mutex10UnlockSlowEPNS_15SynchWaitParamsE(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef null) #16
  br label %for.end

if.end:                                           ; preds = %for.cond
  %7 = load i64, ptr %v, align 8
  %call2 = call noundef zeroext i1 @_ZN4abslL16ExactlyOneReaderEl(i64 noundef %7)
  %cond = select i1 %call2, i64 257, i64 256
  store i64 %cond, ptr %clear, align 8
  %mu_3 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %8 = load i64, ptr %v, align 8
  %9 = load i64, ptr %clear, align 8
  %sub = sub nsw i64 %8, %9
  store ptr %mu_3, ptr %this.addr.i7, align 8
  store ptr %v, ptr %__i1.addr.i, align 8
  store i64 %sub, ptr %__i2.addr.i, align 8
  store i32 3, ptr %__m1.addr.i, align 4
  store i32 0, ptr %__m2.addr.i, align 4
  %this1.i8 = load ptr, ptr %this.addr.i7, align 8
  %10 = load i32, ptr %__m1.addr.i, align 4
  %11 = load ptr, ptr %__i1.addr.i, align 8
  %12 = load i64, ptr %__i2.addr.i, align 8
  store i64 %12, ptr %.atomictmp.i, align 8
  %13 = load i32, ptr %__m2.addr.i, align 4
  switch i32 %10, label %monotonic.i11 [
    i32 1, label %acquire.i10
    i32 2, label %acquire.i10
    i32 3, label %release.i
    i32 4, label %acqrel.i
    i32 5, label %seqcst.i9
  ]

monotonic.i11:                                    ; preds = %if.end
  switch i32 %13, label %monotonic_fail.i [
    i32 1, label %acquire_fail.i
    i32 2, label %acquire_fail.i
    i32 5, label %seqcst_fail.i
  ]

acquire.i10:                                      ; preds = %if.end, %if.end
  switch i32 %13, label %monotonic_fail9.i [
    i32 1, label %acquire_fail10.i
    i32 2, label %acquire_fail10.i
    i32 5, label %seqcst_fail11.i
  ]

release.i:                                        ; preds = %if.end
  switch i32 %13, label %monotonic_fail22.i [
    i32 1, label %acquire_fail23.i
    i32 2, label %acquire_fail23.i
    i32 5, label %seqcst_fail24.i
  ]

acqrel.i:                                         ; preds = %if.end
  switch i32 %13, label %monotonic_fail35.i [
    i32 1, label %acquire_fail36.i
    i32 2, label %acquire_fail36.i
    i32 5, label %seqcst_fail37.i
  ]

seqcst.i9:                                        ; preds = %if.end
  switch i32 %13, label %monotonic_fail48.i [
    i32 1, label %acquire_fail49.i
    i32 2, label %acquire_fail49.i
    i32 5, label %seqcst_fail50.i
  ]

monotonic_fail.i:                                 ; preds = %monotonic.i11
  %14 = load i64, ptr %11, align 8
  %15 = load i64, ptr %.atomictmp.i, align 8
  %16 = cmpxchg ptr %this1.i8, i64 %14, i64 %15 monotonic monotonic, align 8
  %17 = extractvalue { i64, i1 } %16, 0
  %18 = extractvalue { i64, i1 } %16, 1
  br i1 %18, label %cmpxchg.continue.i, label %cmpxchg.store_expected.i

acquire_fail.i:                                   ; preds = %monotonic.i11, %monotonic.i11
  %19 = load i64, ptr %11, align 8
  %20 = load i64, ptr %.atomictmp.i, align 8
  %21 = cmpxchg ptr %this1.i8, i64 %19, i64 %20 monotonic acquire, align 8
  %22 = extractvalue { i64, i1 } %21, 0
  %23 = extractvalue { i64, i1 } %21, 1
  br i1 %23, label %cmpxchg.continue4.i, label %cmpxchg.store_expected3.i

seqcst_fail.i:                                    ; preds = %monotonic.i11
  %24 = load i64, ptr %11, align 8
  %25 = load i64, ptr %.atomictmp.i, align 8
  %26 = cmpxchg ptr %this1.i8, i64 %24, i64 %25 monotonic seq_cst, align 8
  %27 = extractvalue { i64, i1 } %26, 0
  %28 = extractvalue { i64, i1 } %26, 1
  br i1 %28, label %cmpxchg.continue7.i, label %cmpxchg.store_expected6.i

atomic.continue2.i:                               ; preds = %cmpxchg.continue7.i, %cmpxchg.continue4.i, %cmpxchg.continue.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected.i:                         ; preds = %monotonic_fail.i
  store i64 %17, ptr %11, align 8
  br label %cmpxchg.continue.i

cmpxchg.continue.i:                               ; preds = %cmpxchg.store_expected.i, %monotonic_fail.i
  %frombool.i = zext i1 %18 to i8
  store i8 %frombool.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected3.i:                        ; preds = %acquire_fail.i
  store i64 %22, ptr %11, align 8
  br label %cmpxchg.continue4.i

cmpxchg.continue4.i:                              ; preds = %cmpxchg.store_expected3.i, %acquire_fail.i
  %frombool5.i = zext i1 %23 to i8
  store i8 %frombool5.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected6.i:                        ; preds = %seqcst_fail.i
  store i64 %27, ptr %11, align 8
  br label %cmpxchg.continue7.i

cmpxchg.continue7.i:                              ; preds = %cmpxchg.store_expected6.i, %seqcst_fail.i
  %frombool8.i = zext i1 %28 to i8
  store i8 %frombool8.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

monotonic_fail9.i:                                ; preds = %acquire.i10
  %29 = load i64, ptr %11, align 8
  %30 = load i64, ptr %.atomictmp.i, align 8
  %31 = cmpxchg ptr %this1.i8, i64 %29, i64 %30 acquire monotonic, align 8
  %32 = extractvalue { i64, i1 } %31, 0
  %33 = extractvalue { i64, i1 } %31, 1
  br i1 %33, label %cmpxchg.continue14.i, label %cmpxchg.store_expected13.i

acquire_fail10.i:                                 ; preds = %acquire.i10, %acquire.i10
  %34 = load i64, ptr %11, align 8
  %35 = load i64, ptr %.atomictmp.i, align 8
  %36 = cmpxchg ptr %this1.i8, i64 %34, i64 %35 acquire acquire, align 8
  %37 = extractvalue { i64, i1 } %36, 0
  %38 = extractvalue { i64, i1 } %36, 1
  br i1 %38, label %cmpxchg.continue17.i, label %cmpxchg.store_expected16.i

seqcst_fail11.i:                                  ; preds = %acquire.i10
  %39 = load i64, ptr %11, align 8
  %40 = load i64, ptr %.atomictmp.i, align 8
  %41 = cmpxchg ptr %this1.i8, i64 %39, i64 %40 acquire seq_cst, align 8
  %42 = extractvalue { i64, i1 } %41, 0
  %43 = extractvalue { i64, i1 } %41, 1
  br i1 %43, label %cmpxchg.continue20.i, label %cmpxchg.store_expected19.i

atomic.continue12.i:                              ; preds = %cmpxchg.continue20.i, %cmpxchg.continue17.i, %cmpxchg.continue14.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected13.i:                       ; preds = %monotonic_fail9.i
  store i64 %32, ptr %11, align 8
  br label %cmpxchg.continue14.i

cmpxchg.continue14.i:                             ; preds = %cmpxchg.store_expected13.i, %monotonic_fail9.i
  %frombool15.i = zext i1 %33 to i8
  store i8 %frombool15.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected16.i:                       ; preds = %acquire_fail10.i
  store i64 %37, ptr %11, align 8
  br label %cmpxchg.continue17.i

cmpxchg.continue17.i:                             ; preds = %cmpxchg.store_expected16.i, %acquire_fail10.i
  %frombool18.i = zext i1 %38 to i8
  store i8 %frombool18.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected19.i:                       ; preds = %seqcst_fail11.i
  store i64 %42, ptr %11, align 8
  br label %cmpxchg.continue20.i

cmpxchg.continue20.i:                             ; preds = %cmpxchg.store_expected19.i, %seqcst_fail11.i
  %frombool21.i = zext i1 %43 to i8
  store i8 %frombool21.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

monotonic_fail22.i:                               ; preds = %release.i
  %44 = load i64, ptr %11, align 8
  %45 = load i64, ptr %.atomictmp.i, align 8
  %46 = cmpxchg ptr %this1.i8, i64 %44, i64 %45 release monotonic, align 8
  %47 = extractvalue { i64, i1 } %46, 0
  %48 = extractvalue { i64, i1 } %46, 1
  br i1 %48, label %cmpxchg.continue27.i, label %cmpxchg.store_expected26.i

acquire_fail23.i:                                 ; preds = %release.i, %release.i
  %49 = load i64, ptr %11, align 8
  %50 = load i64, ptr %.atomictmp.i, align 8
  %51 = cmpxchg ptr %this1.i8, i64 %49, i64 %50 release acquire, align 8
  %52 = extractvalue { i64, i1 } %51, 0
  %53 = extractvalue { i64, i1 } %51, 1
  br i1 %53, label %cmpxchg.continue30.i, label %cmpxchg.store_expected29.i

seqcst_fail24.i:                                  ; preds = %release.i
  %54 = load i64, ptr %11, align 8
  %55 = load i64, ptr %.atomictmp.i, align 8
  %56 = cmpxchg ptr %this1.i8, i64 %54, i64 %55 release seq_cst, align 8
  %57 = extractvalue { i64, i1 } %56, 0
  %58 = extractvalue { i64, i1 } %56, 1
  br i1 %58, label %cmpxchg.continue33.i, label %cmpxchg.store_expected32.i

atomic.continue25.i:                              ; preds = %cmpxchg.continue33.i, %cmpxchg.continue30.i, %cmpxchg.continue27.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected26.i:                       ; preds = %monotonic_fail22.i
  store i64 %47, ptr %11, align 8
  br label %cmpxchg.continue27.i

cmpxchg.continue27.i:                             ; preds = %cmpxchg.store_expected26.i, %monotonic_fail22.i
  %frombool28.i = zext i1 %48 to i8
  store i8 %frombool28.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected29.i:                       ; preds = %acquire_fail23.i
  store i64 %52, ptr %11, align 8
  br label %cmpxchg.continue30.i

cmpxchg.continue30.i:                             ; preds = %cmpxchg.store_expected29.i, %acquire_fail23.i
  %frombool31.i = zext i1 %53 to i8
  store i8 %frombool31.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected32.i:                       ; preds = %seqcst_fail24.i
  store i64 %57, ptr %11, align 8
  br label %cmpxchg.continue33.i

cmpxchg.continue33.i:                             ; preds = %cmpxchg.store_expected32.i, %seqcst_fail24.i
  %frombool34.i = zext i1 %58 to i8
  store i8 %frombool34.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

monotonic_fail35.i:                               ; preds = %acqrel.i
  %59 = load i64, ptr %11, align 8
  %60 = load i64, ptr %.atomictmp.i, align 8
  %61 = cmpxchg ptr %this1.i8, i64 %59, i64 %60 acq_rel monotonic, align 8
  %62 = extractvalue { i64, i1 } %61, 0
  %63 = extractvalue { i64, i1 } %61, 1
  br i1 %63, label %cmpxchg.continue40.i, label %cmpxchg.store_expected39.i

acquire_fail36.i:                                 ; preds = %acqrel.i, %acqrel.i
  %64 = load i64, ptr %11, align 8
  %65 = load i64, ptr %.atomictmp.i, align 8
  %66 = cmpxchg ptr %this1.i8, i64 %64, i64 %65 acq_rel acquire, align 8
  %67 = extractvalue { i64, i1 } %66, 0
  %68 = extractvalue { i64, i1 } %66, 1
  br i1 %68, label %cmpxchg.continue43.i, label %cmpxchg.store_expected42.i

seqcst_fail37.i:                                  ; preds = %acqrel.i
  %69 = load i64, ptr %11, align 8
  %70 = load i64, ptr %.atomictmp.i, align 8
  %71 = cmpxchg ptr %this1.i8, i64 %69, i64 %70 acq_rel seq_cst, align 8
  %72 = extractvalue { i64, i1 } %71, 0
  %73 = extractvalue { i64, i1 } %71, 1
  br i1 %73, label %cmpxchg.continue46.i, label %cmpxchg.store_expected45.i

atomic.continue38.i:                              ; preds = %cmpxchg.continue46.i, %cmpxchg.continue43.i, %cmpxchg.continue40.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected39.i:                       ; preds = %monotonic_fail35.i
  store i64 %62, ptr %11, align 8
  br label %cmpxchg.continue40.i

cmpxchg.continue40.i:                             ; preds = %cmpxchg.store_expected39.i, %monotonic_fail35.i
  %frombool41.i = zext i1 %63 to i8
  store i8 %frombool41.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected42.i:                       ; preds = %acquire_fail36.i
  store i64 %67, ptr %11, align 8
  br label %cmpxchg.continue43.i

cmpxchg.continue43.i:                             ; preds = %cmpxchg.store_expected42.i, %acquire_fail36.i
  %frombool44.i = zext i1 %68 to i8
  store i8 %frombool44.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected45.i:                       ; preds = %seqcst_fail37.i
  store i64 %72, ptr %11, align 8
  br label %cmpxchg.continue46.i

cmpxchg.continue46.i:                             ; preds = %cmpxchg.store_expected45.i, %seqcst_fail37.i
  %frombool47.i = zext i1 %73 to i8
  store i8 %frombool47.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

monotonic_fail48.i:                               ; preds = %seqcst.i9
  %74 = load i64, ptr %11, align 8
  %75 = load i64, ptr %.atomictmp.i, align 8
  %76 = cmpxchg ptr %this1.i8, i64 %74, i64 %75 seq_cst monotonic, align 8
  %77 = extractvalue { i64, i1 } %76, 0
  %78 = extractvalue { i64, i1 } %76, 1
  br i1 %78, label %cmpxchg.continue53.i, label %cmpxchg.store_expected52.i

acquire_fail49.i:                                 ; preds = %seqcst.i9, %seqcst.i9
  %79 = load i64, ptr %11, align 8
  %80 = load i64, ptr %.atomictmp.i, align 8
  %81 = cmpxchg ptr %this1.i8, i64 %79, i64 %80 seq_cst acquire, align 8
  %82 = extractvalue { i64, i1 } %81, 0
  %83 = extractvalue { i64, i1 } %81, 1
  br i1 %83, label %cmpxchg.continue56.i, label %cmpxchg.store_expected55.i

seqcst_fail50.i:                                  ; preds = %seqcst.i9
  %84 = load i64, ptr %11, align 8
  %85 = load i64, ptr %.atomictmp.i, align 8
  %86 = cmpxchg ptr %this1.i8, i64 %84, i64 %85 seq_cst seq_cst, align 8
  %87 = extractvalue { i64, i1 } %86, 0
  %88 = extractvalue { i64, i1 } %86, 1
  br i1 %88, label %cmpxchg.continue59.i, label %cmpxchg.store_expected58.i

atomic.continue51.i:                              ; preds = %cmpxchg.continue59.i, %cmpxchg.continue56.i, %cmpxchg.continue53.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected52.i:                       ; preds = %monotonic_fail48.i
  store i64 %77, ptr %11, align 8
  br label %cmpxchg.continue53.i

cmpxchg.continue53.i:                             ; preds = %cmpxchg.store_expected52.i, %monotonic_fail48.i
  %frombool54.i = zext i1 %78 to i8
  store i8 %frombool54.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected55.i:                       ; preds = %acquire_fail49.i
  store i64 %82, ptr %11, align 8
  br label %cmpxchg.continue56.i

cmpxchg.continue56.i:                             ; preds = %cmpxchg.store_expected55.i, %acquire_fail49.i
  %frombool57.i = zext i1 %83 to i8
  store i8 %frombool57.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected58.i:                       ; preds = %seqcst_fail50.i
  store i64 %87, ptr %11, align 8
  br label %cmpxchg.continue59.i

cmpxchg.continue59.i:                             ; preds = %cmpxchg.store_expected58.i, %seqcst_fail50.i
  %frombool60.i = zext i1 %88 to i8
  store i8 %frombool60.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit: ; preds = %atomic.continue51.i, %atomic.continue38.i, %atomic.continue25.i, %atomic.continue12.i, %atomic.continue2.i
  %89 = load i8, ptr %cmpxchg.bool.i, align 1
  %tobool.i = trunc i8 %89 to i1
  br i1 %tobool.i, label %if.then5, label %if.end6

if.then5:                                         ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit
  br label %for.end

if.end6:                                          ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit
  br label %for.cond, !llvm.loop !26

for.end:                                          ; preds = %if.then5, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef zeroext i1 @_ZN4abslL16ExactlyOneReaderEl(i64 noundef %v) #1 {
entry:
  %v.addr = alloca i64, align 8
  %kMuMultipleWaitersMask = alloca i64, align 8
  store i64 %v, ptr %v.addr, align 8
  store i64 -512, ptr %kMuMultipleWaitersMask, align 8
  %0 = load i64, ptr %v.addr, align 8
  %and = and i64 %0, -512
  %cmp = icmp eq i64 %and, 0
  ret i1 %cmp
}

declare noundef i32 @_ZN4absl13base_internal7NumCPUsEv() #3

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i64 @_ZN4abslL24ClearDesignatedWakerMaskEi(i32 noundef %flag) #1 {
entry:
  %retval = alloca i64, align 8
  %flag.addr = alloca i32, align 4
  store i32 %flag, ptr %flag.addr, align 4
  %0 = load i32, ptr %flag.addr, align 4
  switch i32 %0, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  store i64 -1, ptr %retval, align 8
  br label %return

sw.bb1:                                           ; preds = %entry
  store i64 -3, ptr %retval, align 8
  br label %return

sw.epilog:                                        ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.epilog
  unreachable

do.end:                                           ; No predecessors!
  call void @llvm.trap()
  unreachable

return:                                           ; preds = %sw.bb1, %sw.bb
  %1 = load i64, ptr %retval, align 8
  ret i64 %1
}

; Function Attrs: mustprogress uwtable
define internal void @_ZN4abslL23CheckForMutexCorruptionElPKc(i64 noundef %v, ptr noundef %label) #0 {
entry:
  %v.addr = alloca i64, align 8
  %label.addr = alloca ptr, align 8
  %w = alloca i64, align 8
  %absl_raw_log_internal_basename = alloca ptr, align 8
  %absl_raw_log_internal_basename16 = alloca ptr, align 8
  store i64 %v, ptr %v.addr, align 8
  store ptr %label, ptr %label.addr, align 8
  %0 = load i64, ptr %v.addr, align 8
  %xor = xor i64 %0, 4
  store i64 %xor, ptr %w, align 8
  %1 = load i64, ptr %w, align 8
  %2 = load i64, ptr %w, align 8
  %shl = shl i64 %2, 3
  %and = and i64 %1, %shl
  %and1 = and i64 %and, 40
  %cmp = icmp eq i64 %and1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %do.end21

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %3 = load i64, ptr %v.addr, align 8
  %and2 = and i64 %3, 9
  %cmp3 = icmp ne i64 %and2, 9
  %lnot = xor i1 %cmp3, true
  br i1 %lnot, label %if.then4, label %if.end8

if.then4:                                         ; preds = %do.body
  br label %do.body5

do.body5:                                         ; preds = %if.then4
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename, align 8
  %4 = load ptr, ptr %label.addr, align 8
  %5 = load i64, ptr %v.addr, align 8
  %6 = inttoptr i64 %5 to ptr
  call void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 1953, ptr noundef @.str.68, ptr noundef %4, ptr noundef %6)
  br label %do.body6

do.body6:                                         ; preds = %do.body5
  unreachable

do.end:                                           ; No predecessors!
  br label %do.end7

do.end7:                                          ; preds = %do.end
  br label %if.end8

if.end8:                                          ; preds = %do.end7, %do.body
  br label %do.end9

do.end9:                                          ; preds = %if.end8
  br label %do.body10

do.body10:                                        ; preds = %do.end9
  %7 = load i64, ptr %v.addr, align 8
  %and11 = and i64 %7, 36
  %cmp12 = icmp ne i64 %and11, 32
  %lnot13 = xor i1 %cmp12, true
  br i1 %lnot13, label %if.then14, label %if.end20

if.then14:                                        ; preds = %do.body10
  br label %do.body15

do.body15:                                        ; preds = %if.then14
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename16, align 8
  %8 = load ptr, ptr %label.addr, align 8
  %9 = load i64, ptr %v.addr, align 8
  %10 = inttoptr i64 %9 to ptr
  call void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 1956, ptr noundef @.str.69, ptr noundef %8, ptr noundef %10)
  br label %do.body17

do.body17:                                        ; preds = %do.body15
  unreachable

do.end18:                                         ; No predecessors!
  br label %do.end19

do.end19:                                         ; preds = %do.end18
  br label %if.end20

if.end20:                                         ; preds = %do.end19, %do.body10
  br label %do.end21

do.end21:                                         ; preds = %if.end20, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define internal noundef ptr @_ZN4abslL7EnqueueEPNS_13base_internal14PerThreadSynchEPNS_15SynchWaitParamsEli(ptr noundef %head, ptr noundef %waitp, i64 noundef %mu, i32 noundef %flags) #0 {
entry:
  %retval = alloca ptr, align 8
  %head.addr = alloca ptr, align 8
  %waitp.addr = alloca ptr, align 8
  %mu.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %s = alloca ptr, align 8
  %absl_raw_log_internal_basename = alloca ptr, align 8
  %now_cycles = alloca i64, align 8
  %policy = alloca i32, align 4
  %param = alloca %struct.sched_param, align 4
  %err = alloca i32, align 4
  %absl_raw_log_internal_basename23 = alloca ptr, align 8
  %enqueue_after = alloca ptr, align 8
  %advance_to = alloca ptr, align 8
  %absl_raw_log_internal_basename69 = alloca ptr, align 8
  store ptr %head, ptr %head.addr, align 8
  store ptr %waitp, ptr %waitp.addr, align 8
  store i64 %mu, ptr %mu.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load ptr, ptr %waitp.addr, align 8
  %cv_word = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %0, i32 0, i32 5
  %1 = load ptr, ptr %cv_word, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %waitp.addr, align 8
  call void @_ZN4abslL14CondVarEnqueueEPNS_15SynchWaitParamsE(ptr noundef %2)
  %3 = load ptr, ptr %head.addr, align 8
  store ptr %3, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %waitp.addr, align 8
  %thread = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %4, i32 0, i32 4
  %5 = load ptr, ptr %thread, align 8
  store ptr %5, ptr %s, align 8
  br label %do.body

do.body:                                          ; preds = %if.end
  %6 = load ptr, ptr %s, align 8
  %waitp1 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %6, i32 0, i32 9
  %7 = load ptr, ptr %waitp1, align 8
  %cmp2 = icmp eq ptr %7, null
  br i1 %cmp2, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.body
  %8 = load ptr, ptr %s, align 8
  %waitp3 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %8, i32 0, i32 9
  %9 = load ptr, ptr %waitp3, align 8
  %10 = load ptr, ptr %waitp.addr, align 8
  %cmp4 = icmp eq ptr %9, %10
  br i1 %cmp4, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false
  %11 = load ptr, ptr %s, align 8
  %suppress_fatal_errors = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %11, i32 0, i32 6
  %12 = load i8, ptr %suppress_fatal_errors, align 4
  %tobool = trunc i8 %12 to i1
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false, %do.body
  %13 = phi i1 [ true, %lor.lhs.false ], [ true, %do.body ], [ %tobool, %lor.rhs ]
  %lnot = xor i1 %13, true
  br i1 %lnot, label %if.then5, label %if.end9

if.then5:                                         ; preds = %lor.end
  br label %do.body6

do.body6:                                         ; preds = %if.then5
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename, align 8
  call void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 920, ptr noundef @.str.1, ptr noundef @.str.70, ptr noundef @.str.9)
  br label %do.body7

do.body7:                                         ; preds = %do.body6
  unreachable

do.end:                                           ; No predecessors!
  br label %do.end8

do.end8:                                          ; preds = %do.end
  br label %if.end9

if.end9:                                          ; preds = %do.end8, %lor.end
  br label %do.end10

do.end10:                                         ; preds = %if.end9
  %14 = load ptr, ptr %waitp.addr, align 8
  %15 = load ptr, ptr %s, align 8
  %waitp11 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %15, i32 0, i32 9
  store ptr %14, ptr %waitp11, align 8
  %16 = load ptr, ptr %s, align 8
  %skip = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %16, i32 0, i32 1
  store ptr null, ptr %skip, align 8
  %17 = load ptr, ptr %s, align 8
  %may_skip = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %17, i32 0, i32 2
  store i8 1, ptr %may_skip, align 8
  %18 = load ptr, ptr %s, align 8
  %wake = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %18, i32 0, i32 3
  store i8 0, ptr %wake, align 1
  %19 = load i32, ptr %flags.addr, align 4
  %and = and i32 %19, 2
  %cmp12 = icmp ne i32 %and, 0
  %20 = load ptr, ptr %s, align 8
  %cond_waiter = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %20, i32 0, i32 4
  %frombool = zext i1 %cmp12 to i8
  store i8 %frombool, ptr %cond_waiter, align 2
  %21 = load i32, ptr %flags.addr, align 4
  %and13 = and i32 %21, 4
  %cmp14 = icmp eq i32 %and13, 0
  br i1 %cmp14, label %if.then15, label %if.end29

if.then15:                                        ; preds = %do.end10
  %call = call noundef i64 @_ZN4absl13base_internal10CycleClock3NowEv()
  store i64 %call, ptr %now_cycles, align 8
  %22 = load ptr, ptr %s, align 8
  %next_priority_read_cycles = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %22, i32 0, i32 11
  %23 = load i64, ptr %next_priority_read_cycles, align 8
  %24 = load i64, ptr %now_cycles, align 8
  %cmp16 = icmp slt i64 %23, %24
  br i1 %cmp16, label %if.then17, label %if.end28

if.then17:                                        ; preds = %if.then15
  %call18 = call i64 @pthread_self() #17
  %call19 = call i32 @pthread_getschedparam(i64 noundef %call18, ptr noundef %policy, ptr noundef %param) #13
  store i32 %call19, ptr %err, align 4
  %25 = load i32, ptr %err, align 4
  %cmp20 = icmp ne i32 %25, 0
  br i1 %cmp20, label %if.then21, label %if.else

if.then21:                                        ; preds = %if.then17
  br label %do.body22

do.body22:                                        ; preds = %if.then21
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename23, align 8
  %26 = load i32, ptr %err, align 4
  call void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 2, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 938, ptr noundef @.str.71, i32 noundef %26)
  br label %do.end24

do.end24:                                         ; preds = %do.body22
  br label %if.end27

if.else:                                          ; preds = %if.then17
  %sched_priority = getelementptr inbounds %struct.sched_param, ptr %param, i32 0, i32 0
  %27 = load i32, ptr %sched_priority, align 4
  %28 = load ptr, ptr %s, align 8
  %priority = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %28, i32 0, i32 7
  store i32 %27, ptr %priority, align 8
  %29 = load i64, ptr %now_cycles, align 8
  %call25 = call noundef double @_ZN4absl13base_internal10CycleClock9FrequencyEv()
  %conv = fptosi double %call25 to i64
  %add = add nsw i64 %29, %conv
  %30 = load ptr, ptr %s, align 8
  %next_priority_read_cycles26 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %30, i32 0, i32 11
  store i64 %add, ptr %next_priority_read_cycles26, align 8
  br label %if.end27

if.end27:                                         ; preds = %if.else, %do.end24
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.then15
  br label %if.end29

if.end29:                                         ; preds = %if.end28, %do.end10
  %31 = load ptr, ptr %head.addr, align 8
  %cmp30 = icmp eq ptr %31, null
  br i1 %cmp30, label %if.then31, label %if.else32

if.then31:                                        ; preds = %if.end29
  %32 = load ptr, ptr %s, align 8
  %33 = load ptr, ptr %s, align 8
  %next = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %33, i32 0, i32 0
  store ptr %32, ptr %next, align 8
  %34 = load i64, ptr %mu.addr, align 8
  %35 = load ptr, ptr %s, align 8
  %readers = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %35, i32 0, i32 10
  store i64 %34, ptr %readers, align 8
  %36 = load ptr, ptr %s, align 8
  %maybe_unlocking = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %36, i32 0, i32 5
  store i8 0, ptr %maybe_unlocking, align 1
  %37 = load ptr, ptr %s, align 8
  store ptr %37, ptr %head.addr, align 8
  br label %if.end141

if.else32:                                        ; preds = %if.end29
  store ptr null, ptr %enqueue_after, align 8
  %38 = load ptr, ptr %s, align 8
  %priority33 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %38, i32 0, i32 7
  %39 = load i32, ptr %priority33, align 8
  %40 = load ptr, ptr %head.addr, align 8
  %priority34 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %40, i32 0, i32 7
  %41 = load i32, ptr %priority34, align 8
  %cmp35 = icmp sgt i32 %39, %41
  br i1 %cmp35, label %if.then36, label %if.end53

if.then36:                                        ; preds = %if.else32
  %42 = load ptr, ptr %head.addr, align 8
  %maybe_unlocking37 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %42, i32 0, i32 5
  %43 = load i8, ptr %maybe_unlocking37, align 1
  %tobool38 = trunc i8 %43 to i1
  br i1 %tobool38, label %if.else47, label %if.then39

if.then39:                                        ; preds = %if.then36
  %44 = load ptr, ptr %head.addr, align 8
  store ptr %44, ptr %advance_to, align 8
  br label %do.body40

do.body40:                                        ; preds = %do.cond, %if.then39
  %45 = load ptr, ptr %advance_to, align 8
  store ptr %45, ptr %enqueue_after, align 8
  %46 = load ptr, ptr %enqueue_after, align 8
  %next41 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %46, i32 0, i32 0
  %47 = load ptr, ptr %next41, align 8
  %call42 = call noundef ptr @_ZN4abslL4SkipEPNS_13base_internal14PerThreadSynchE(ptr noundef %47)
  store ptr %call42, ptr %advance_to, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body40
  %48 = load ptr, ptr %s, align 8
  %priority43 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %48, i32 0, i32 7
  %49 = load i32, ptr %priority43, align 8
  %50 = load ptr, ptr %advance_to, align 8
  %priority44 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %50, i32 0, i32 7
  %51 = load i32, ptr %priority44, align 8
  %cmp45 = icmp sle i32 %49, %51
  br i1 %cmp45, label %do.body40, label %do.end46, !llvm.loop !27

do.end46:                                         ; preds = %do.cond
  br label %if.end52

if.else47:                                        ; preds = %if.then36
  %52 = load ptr, ptr %waitp.addr, align 8
  %how = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %52, i32 0, i32 0
  %53 = load ptr, ptr %how, align 8
  %cmp48 = icmp eq ptr %53, @_ZN4abslL11kExclusiveSE
  br i1 %cmp48, label %land.lhs.true, label %if.end51

land.lhs.true:                                    ; preds = %if.else47
  %54 = load ptr, ptr %waitp.addr, align 8
  %cond = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %54, i32 0, i32 1
  %55 = load ptr, ptr %cond, align 8
  %cmp49 = icmp eq ptr %55, null
  br i1 %cmp49, label %if.then50, label %if.end51

if.then50:                                        ; preds = %land.lhs.true
  %56 = load ptr, ptr %head.addr, align 8
  store ptr %56, ptr %enqueue_after, align 8
  br label %if.end51

if.end51:                                         ; preds = %if.then50, %land.lhs.true, %if.else47
  br label %if.end52

if.end52:                                         ; preds = %if.end51, %do.end46
  br label %if.end53

if.end53:                                         ; preds = %if.end52, %if.else32
  %57 = load ptr, ptr %enqueue_after, align 8
  %cmp54 = icmp ne ptr %57, null
  br i1 %cmp54, label %if.then55, label %if.else95

if.then55:                                        ; preds = %if.end53
  %58 = load ptr, ptr %enqueue_after, align 8
  %next56 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %58, i32 0, i32 0
  %59 = load ptr, ptr %next56, align 8
  %60 = load ptr, ptr %s, align 8
  %next57 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %60, i32 0, i32 0
  store ptr %59, ptr %next57, align 8
  %61 = load ptr, ptr %s, align 8
  %62 = load ptr, ptr %enqueue_after, align 8
  %next58 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %62, i32 0, i32 0
  store ptr %61, ptr %next58, align 8
  br label %do.body59

do.body59:                                        ; preds = %if.then55
  %63 = load ptr, ptr %enqueue_after, align 8
  %skip60 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %63, i32 0, i32 1
  %64 = load ptr, ptr %skip60, align 8
  %cmp61 = icmp eq ptr %64, null
  br i1 %cmp61, label %lor.end64, label %lor.rhs62

lor.rhs62:                                        ; preds = %do.body59
  %65 = load ptr, ptr %enqueue_after, align 8
  %66 = load ptr, ptr %s, align 8
  %call63 = call noundef zeroext i1 @_ZN4abslL18MuEquivalentWaiterEPNS_13base_internal14PerThreadSynchES2_(ptr noundef %65, ptr noundef %66)
  br label %lor.end64

lor.end64:                                        ; preds = %lor.rhs62, %do.body59
  %67 = phi i1 [ true, %do.body59 ], [ %call63, %lor.rhs62 ]
  %lnot65 = xor i1 %67, true
  br i1 %lnot65, label %if.then67, label %if.end75

if.then67:                                        ; preds = %lor.end64
  br label %do.body68

do.body68:                                        ; preds = %if.then67
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename69, align 8
  call void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 993, ptr noundef @.str.1, ptr noundef @.str.72, ptr noundef @.str.73)
  br label %do.body70

do.body70:                                        ; preds = %do.body68
  unreachable

do.end72:                                         ; No predecessors!
  br label %do.end74

do.end74:                                         ; preds = %do.end72
  br label %if.end75

if.end75:                                         ; preds = %do.end74, %lor.end64
  br label %do.end77

do.end77:                                         ; preds = %if.end75
  %68 = load ptr, ptr %enqueue_after, align 8
  %69 = load ptr, ptr %head.addr, align 8
  %cmp78 = icmp ne ptr %68, %69
  br i1 %cmp78, label %land.lhs.true79, label %if.end88

land.lhs.true79:                                  ; preds = %do.end77
  %70 = load ptr, ptr %enqueue_after, align 8
  %may_skip80 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %70, i32 0, i32 2
  %71 = load i8, ptr %may_skip80, align 8
  %tobool81 = trunc i8 %71 to i1
  br i1 %tobool81, label %land.lhs.true82, label %if.end88

land.lhs.true82:                                  ; preds = %land.lhs.true79
  %72 = load ptr, ptr %enqueue_after, align 8
  %73 = load ptr, ptr %enqueue_after, align 8
  %next83 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %73, i32 0, i32 0
  %74 = load ptr, ptr %next83, align 8
  %call84 = call noundef zeroext i1 @_ZN4abslL18MuEquivalentWaiterEPNS_13base_internal14PerThreadSynchES2_(ptr noundef %72, ptr noundef %74)
  br i1 %call84, label %if.then85, label %if.end88

if.then85:                                        ; preds = %land.lhs.true82
  %75 = load ptr, ptr %enqueue_after, align 8
  %next86 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %75, i32 0, i32 0
  %76 = load ptr, ptr %next86, align 8
  %77 = load ptr, ptr %enqueue_after, align 8
  %skip87 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %77, i32 0, i32 1
  store ptr %76, ptr %skip87, align 8
  br label %if.end88

if.end88:                                         ; preds = %if.then85, %land.lhs.true82, %land.lhs.true79, %do.end77
  %78 = load ptr, ptr %s, align 8
  %79 = load ptr, ptr %s, align 8
  %next89 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %79, i32 0, i32 0
  %80 = load ptr, ptr %next89, align 8
  %call90 = call noundef zeroext i1 @_ZN4abslL18MuEquivalentWaiterEPNS_13base_internal14PerThreadSynchES2_(ptr noundef %78, ptr noundef %80)
  br i1 %call90, label %if.then91, label %if.end94

if.then91:                                        ; preds = %if.end88
  %81 = load ptr, ptr %s, align 8
  %next92 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %81, i32 0, i32 0
  %82 = load ptr, ptr %next92, align 8
  %83 = load ptr, ptr %s, align 8
  %skip93 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %83, i32 0, i32 1
  store ptr %82, ptr %skip93, align 8
  br label %if.end94

if.end94:                                         ; preds = %if.then91, %if.end88
  br label %if.end140

if.else95:                                        ; preds = %if.end53
  %84 = load i32, ptr %flags.addr, align 4
  %and96 = and i32 %84, 1
  %tobool97 = icmp ne i32 %and96, 0
  br i1 %tobool97, label %land.lhs.true98, label %if.else122

land.lhs.true98:                                  ; preds = %if.else95
  %85 = load ptr, ptr %s, align 8
  %priority99 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %85, i32 0, i32 7
  %86 = load i32, ptr %priority99, align 8
  %87 = load ptr, ptr %head.addr, align 8
  %next100 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %87, i32 0, i32 0
  %88 = load ptr, ptr %next100, align 8
  %priority101 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %88, i32 0, i32 7
  %89 = load i32, ptr %priority101, align 8
  %cmp102 = icmp sge i32 %86, %89
  br i1 %cmp102, label %land.lhs.true103, label %if.else122

land.lhs.true103:                                 ; preds = %land.lhs.true98
  %90 = load ptr, ptr %head.addr, align 8
  %maybe_unlocking104 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %90, i32 0, i32 5
  %91 = load i8, ptr %maybe_unlocking104, align 1
  %tobool105 = trunc i8 %91 to i1
  br i1 %tobool105, label %lor.lhs.false106, label %if.then112

lor.lhs.false106:                                 ; preds = %land.lhs.true103
  %92 = load ptr, ptr %waitp.addr, align 8
  %how107 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %92, i32 0, i32 0
  %93 = load ptr, ptr %how107, align 8
  %cmp108 = icmp eq ptr %93, @_ZN4abslL11kExclusiveSE
  br i1 %cmp108, label %land.lhs.true109, label %if.else122

land.lhs.true109:                                 ; preds = %lor.lhs.false106
  %94 = load ptr, ptr %waitp.addr, align 8
  %cond110 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %94, i32 0, i32 1
  %95 = load ptr, ptr %cond110, align 8
  %call111 = call noundef zeroext i1 @_ZN4absl9Condition15GuaranteedEqualEPKS0_S2_(ptr noundef %95, ptr noundef null)
  br i1 %call111, label %if.then112, label %if.else122

if.then112:                                       ; preds = %land.lhs.true109, %land.lhs.true103
  %96 = load ptr, ptr %head.addr, align 8
  %next113 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %96, i32 0, i32 0
  %97 = load ptr, ptr %next113, align 8
  %98 = load ptr, ptr %s, align 8
  %next114 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %98, i32 0, i32 0
  store ptr %97, ptr %next114, align 8
  %99 = load ptr, ptr %s, align 8
  %100 = load ptr, ptr %head.addr, align 8
  %next115 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %100, i32 0, i32 0
  store ptr %99, ptr %next115, align 8
  %101 = load ptr, ptr %s, align 8
  %102 = load ptr, ptr %s, align 8
  %next116 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %102, i32 0, i32 0
  %103 = load ptr, ptr %next116, align 8
  %call117 = call noundef zeroext i1 @_ZN4abslL18MuEquivalentWaiterEPNS_13base_internal14PerThreadSynchES2_(ptr noundef %101, ptr noundef %103)
  br i1 %call117, label %if.then118, label %if.end121

if.then118:                                       ; preds = %if.then112
  %104 = load ptr, ptr %s, align 8
  %next119 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %104, i32 0, i32 0
  %105 = load ptr, ptr %next119, align 8
  %106 = load ptr, ptr %s, align 8
  %skip120 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %106, i32 0, i32 1
  store ptr %105, ptr %skip120, align 8
  br label %if.end121

if.end121:                                        ; preds = %if.then118, %if.then112
  br label %if.end139

if.else122:                                       ; preds = %land.lhs.true109, %lor.lhs.false106, %land.lhs.true98, %if.else95
  %107 = load ptr, ptr %head.addr, align 8
  %next123 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %107, i32 0, i32 0
  %108 = load ptr, ptr %next123, align 8
  %109 = load ptr, ptr %s, align 8
  %next124 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %109, i32 0, i32 0
  store ptr %108, ptr %next124, align 8
  %110 = load ptr, ptr %s, align 8
  %111 = load ptr, ptr %head.addr, align 8
  %next125 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %111, i32 0, i32 0
  store ptr %110, ptr %next125, align 8
  %112 = load ptr, ptr %head.addr, align 8
  %readers126 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %112, i32 0, i32 10
  %113 = load i64, ptr %readers126, align 8
  %114 = load ptr, ptr %s, align 8
  %readers127 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %114, i32 0, i32 10
  store i64 %113, ptr %readers127, align 8
  %115 = load ptr, ptr %head.addr, align 8
  %maybe_unlocking128 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %115, i32 0, i32 5
  %116 = load i8, ptr %maybe_unlocking128, align 1
  %tobool129 = trunc i8 %116 to i1
  %117 = load ptr, ptr %s, align 8
  %maybe_unlocking130 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %117, i32 0, i32 5
  %frombool131 = zext i1 %tobool129 to i8
  store i8 %frombool131, ptr %maybe_unlocking130, align 1
  %118 = load ptr, ptr %head.addr, align 8
  %may_skip132 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %118, i32 0, i32 2
  %119 = load i8, ptr %may_skip132, align 8
  %tobool133 = trunc i8 %119 to i1
  br i1 %tobool133, label %land.lhs.true134, label %if.end138

land.lhs.true134:                                 ; preds = %if.else122
  %120 = load ptr, ptr %head.addr, align 8
  %121 = load ptr, ptr %s, align 8
  %call135 = call noundef zeroext i1 @_ZN4abslL18MuEquivalentWaiterEPNS_13base_internal14PerThreadSynchES2_(ptr noundef %120, ptr noundef %121)
  br i1 %call135, label %if.then136, label %if.end138

if.then136:                                       ; preds = %land.lhs.true134
  %122 = load ptr, ptr %s, align 8
  %123 = load ptr, ptr %head.addr, align 8
  %skip137 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %123, i32 0, i32 1
  store ptr %122, ptr %skip137, align 8
  br label %if.end138

if.end138:                                        ; preds = %if.then136, %land.lhs.true134, %if.else122
  %124 = load ptr, ptr %s, align 8
  store ptr %124, ptr %head.addr, align 8
  br label %if.end139

if.end139:                                        ; preds = %if.end138, %if.end121
  br label %if.end140

if.end140:                                        ; preds = %if.end139, %if.end94
  br label %if.end141

if.end141:                                        ; preds = %if.end140, %if.then31
  %125 = load ptr, ptr %s, align 8
  %state = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %125, i32 0, i32 8
  call void @_ZNSt6atomicIN4absl13base_internal14PerThreadSynch5StateEE5storeES3_St12memory_order(ptr noundef nonnull align 4 dereferenceable(4) %state, i32 noundef 1, i32 noundef 0) #13
  %126 = load ptr, ptr %head.addr, align 8
  store ptr %126, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end141, %if.then
  %127 = load ptr, ptr %retval, align 8
  ret ptr %127
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i64 @_ZN4abslL24IgnoreWaitingWritersMaskEi(i32 noundef %flag) #1 {
entry:
  %retval = alloca i64, align 8
  %flag.addr = alloca i32, align 4
  store i32 %flag, ptr %flag.addr, align 4
  %0 = load i32, ptr %flag.addr, align 4
  switch i32 %0, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  store i64 -1, ptr %retval, align 8
  br label %return

sw.bb1:                                           ; preds = %entry
  store i64 -33, ptr %retval, align 8
  br label %return

sw.epilog:                                        ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.epilog
  unreachable

do.end:                                           ; No predecessors!
  call void @llvm.trap()
  unreachable

return:                                           ; preds = %sw.bb1, %sw.bb
  %1 = load i64, ptr %retval, align 8
  ret i64 %1
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZNK4absl5Mutex16AssertReaderHeldEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 align 2 {
entry:
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i64, align 8
  %this.addr = alloca ptr, align 8
  %e = alloca ptr, align 8
  %absl_raw_log_internal_basename = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mu_ = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  store ptr %mu_, ptr %this.addr.i, align 8
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %0 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %0, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %1 = load i32, ptr %__m.addr.i, align 4
  switch i32 %1, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %entry
  %2 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %2, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %entry, %entry
  %3 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %3, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %entry
  %4 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %4, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %5 = load i64, ptr %atomic-temp.i, align 8
  %and = and i64 %5, 9
  %cmp = icmp eq i64 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  %call2 = call noundef ptr @_ZN4abslL13GetSynchEventEPKv(ptr noundef %this1)
  store ptr %call2, ptr %e, align 8
  br label %do.body

do.body:                                          ; preds = %if.then
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename, align 8
  %6 = load ptr, ptr %e, align 8
  %cmp3 = icmp eq ptr %6, null
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %do.body
  br label %cond.end

cond.false:                                       ; preds = %do.body
  %7 = load ptr, ptr %e, align 8
  %name = getelementptr inbounds %"struct.absl::SynchEvent", ptr %7, i32 0, i32 6
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond-lvalue = phi ptr [ @.str.35, %cond.true ], [ %name, %cond.false ]
  %arraydecay = getelementptr inbounds [1 x i8], ptr %cond-lvalue, i64 0, i64 0
  call void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 2473, ptr noundef @.str.36, ptr noundef %this1, ptr noundef %arraydecay)
  br label %do.body4

do.body4:                                         ; preds = %cond.end
  unreachable

do.end:                                           ; No predecessors!
  br label %do.end5

do.end5:                                          ; preds = %do.end
  br label %if.end

if.end:                                           ; preds = %do.end5, %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  ret void
}

; Function Attrs: mustprogress uwtable
define internal noundef zeroext i1 @_ZN4abslL20EvalConditionIgnoredEPNS_5MutexEPKNS_9ConditionE(ptr noundef %mu, ptr noundef %cond) #0 {
entry:
  %mu.addr = alloca ptr, align 8
  %cond.addr = alloca ptr, align 8
  %res = alloca i8, align 1
  store ptr %mu, ptr %mu.addr, align 8
  store ptr %cond, ptr %cond.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  call void @_Z36AbslInternalAnnotateIgnoreReadsBeginv()
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %cond.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4absl9Condition4EvalEv(ptr noundef nonnull align 8 dereferenceable(32) %0)
  %frombool = zext i1 %call to i8
  store i8 %frombool, ptr %res, align 1
  br label %do.body1

do.body1:                                         ; preds = %do.end
  call void @_Z34AbslInternalAnnotateIgnoreReadsEndv()
  br label %do.end2

do.end2:                                          ; preds = %do.body1
  %1 = load i8, ptr %res, align 1
  %tobool = trunc i8 %1 to i1
  ret i1 %tobool
}

; Function Attrs: mustprogress uwtable
define internal noundef ptr @_ZN4abslL18DequeueAllWakeableEPNS_13base_internal14PerThreadSynchES2_PS2_(ptr noundef %head, ptr noundef %pw, ptr noundef %wake_tail) #0 {
entry:
  %head.addr = alloca ptr, align 8
  %pw.addr = alloca ptr, align 8
  %wake_tail.addr = alloca ptr, align 8
  %orig_h = alloca ptr, align 8
  %w = alloca ptr, align 8
  %skipped = alloca i8, align 1
  %absl_raw_log_internal_basename = alloca ptr, align 8
  store ptr %head, ptr %head.addr, align 8
  store ptr %pw, ptr %pw.addr, align 8
  store ptr %wake_tail, ptr %wake_tail.addr, align 8
  %0 = load ptr, ptr %head.addr, align 8
  store ptr %0, ptr %orig_h, align 8
  %1 = load ptr, ptr %pw.addr, align 8
  %next = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %next, align 8
  store ptr %2, ptr %w, align 8
  store i8 0, ptr %skipped, align 1
  br label %do.body

do.body:                                          ; preds = %land.end, %entry
  %3 = load ptr, ptr %w, align 8
  %wake = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %3, i32 0, i32 3
  %4 = load i8, ptr %wake, align 1
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %do.body1

do.body1:                                         ; preds = %if.then
  %5 = load ptr, ptr %pw.addr, align 8
  %skip = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %skip, align 8
  %cmp = icmp eq ptr %6, null
  %lnot = xor i1 %cmp, true
  br i1 %lnot, label %if.then2, label %if.end

if.then2:                                         ; preds = %do.body1
  br label %do.body3

do.body3:                                         ; preds = %if.then2
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename, align 8
  call void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 1074, ptr noundef @.str.1, ptr noundef @.str.76, ptr noundef @.str.77)
  br label %do.body4

do.body4:                                         ; preds = %do.body3
  unreachable

do.end:                                           ; No predecessors!
  br label %do.end5

do.end5:                                          ; preds = %do.end
  br label %if.end

if.end:                                           ; preds = %do.end5, %do.body1
  br label %do.end6

do.end6:                                          ; preds = %if.end
  %7 = load ptr, ptr %head.addr, align 8
  %8 = load ptr, ptr %pw.addr, align 8
  %call = call noundef ptr @_ZN4abslL7DequeueEPNS_13base_internal14PerThreadSynchES2_(ptr noundef %7, ptr noundef %8)
  store ptr %call, ptr %head.addr, align 8
  %9 = load ptr, ptr %wake_tail.addr, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %w, align 8
  %next7 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %11, i32 0, i32 0
  store ptr %10, ptr %next7, align 8
  %12 = load ptr, ptr %w, align 8
  %13 = load ptr, ptr %wake_tail.addr, align 8
  store ptr %12, ptr %13, align 8
  %14 = load ptr, ptr %w, align 8
  %next8 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %14, i32 0, i32 0
  store ptr %next8, ptr %wake_tail.addr, align 8
  %15 = load ptr, ptr %w, align 8
  %waitp = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %15, i32 0, i32 9
  %16 = load ptr, ptr %waitp, align 8
  %how = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %16, i32 0, i32 0
  %17 = load ptr, ptr %how, align 8
  %cmp9 = icmp eq ptr %17, @_ZN4abslL11kExclusiveSE
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %do.end6
  br label %do.end19

if.end11:                                         ; preds = %do.end6
  br label %if.end13

if.else:                                          ; preds = %do.body
  %18 = load ptr, ptr %w, align 8
  %call12 = call noundef ptr @_ZN4abslL4SkipEPNS_13base_internal14PerThreadSynchE(ptr noundef %18)
  store ptr %call12, ptr %pw.addr, align 8
  store i8 1, ptr %skipped, align 1
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.end11
  %19 = load ptr, ptr %pw.addr, align 8
  %next14 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %19, i32 0, i32 0
  %20 = load ptr, ptr %next14, align 8
  store ptr %20, ptr %w, align 8
  br label %do.cond

do.cond:                                          ; preds = %if.end13
  %21 = load ptr, ptr %orig_h, align 8
  %22 = load ptr, ptr %head.addr, align 8
  %cmp15 = icmp eq ptr %21, %22
  br i1 %cmp15, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %do.cond
  %23 = load ptr, ptr %pw.addr, align 8
  %24 = load ptr, ptr %head.addr, align 8
  %cmp16 = icmp ne ptr %23, %24
  br i1 %cmp16, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.rhs
  %25 = load i8, ptr %skipped, align 1
  %tobool17 = trunc i8 %25 to i1
  %lnot18 = xor i1 %tobool17, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.rhs
  %26 = phi i1 [ true, %land.rhs ], [ %lnot18, %lor.rhs ]
  br label %land.end

land.end:                                         ; preds = %lor.end, %do.cond
  %27 = phi i1 [ false, %do.cond ], [ %26, %lor.end ]
  br i1 %27, label %do.body, label %do.end19, !llvm.loop !28

do.end19:                                         ; preds = %land.end, %if.then10
  %28 = load ptr, ptr %head.addr, align 8
  ret ptr %28
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i64 @_ZN4absl13base_internal10CycleClock3NowEv() #0 comdat align 2 {
entry:
  %retval = alloca i64, align 8
  %fn = alloca ptr, align 8
  %call = call noundef ptr @_ZN4absl13base_internal10CycleClock20LoadCycleClockSourceEv()
  store ptr %call, ptr %fn, align 8
  %0 = load ptr, ptr %fn, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call noundef i64 @_ZN4absl13base_internal18UnscaledCycleClock3NowEv()
  %shr = ashr i64 %call1, 1
  store i64 %shr, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %fn, align 8
  %call2 = call noundef i64 %1()
  %shr3 = ashr i64 %call2, 1
  store i64 %shr3, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i64, ptr %retval, align 8
  ret i64 %2
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK4absl13base_internal10AtomicHookIPFvPKcPKvlEEclIJRA13_S2_PNS_5MutexERlEEEvDpOT_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 1 dereferenceable(13) %args, ptr noundef nonnull align 8 dereferenceable(8) %args1, ptr noundef nonnull align 8 dereferenceable(8) %args3) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %args.addr2 = alloca ptr, align 8
  %args.addr4 = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store ptr %args1, ptr %args.addr2, align 8
  store ptr %args3, ptr %args.addr4, align 8
  %this5 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZNK4absl13base_internal10AtomicHookIPFvPKcPKvlEE6DoLoadEv(ptr noundef nonnull align 8 dereferenceable(16) %this5)
  %0 = load ptr, ptr %args.addr, align 8
  %arraydecay = getelementptr inbounds [13 x i8], ptr %0, i64 0, i64 0
  %1 = load ptr, ptr %args.addr2, align 8
  %2 = load ptr, ptr %1, align 8
  %3 = load ptr, ptr %args.addr4, align 8
  %4 = load i64, ptr %3, align 8
  call void %call(ptr noundef %arraydecay, ptr noundef %2, i64 noundef %4)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK4absl13base_internal10AtomicHookIPFvlEEclIJRlEEEvDpOT_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(8) %args) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZNK4absl13base_internal10AtomicHookIPFvlEE6DoLoadEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %0 = load ptr, ptr %args.addr, align 8
  %1 = load i64, ptr %0, align 8
  call void %call(i64 noundef %1)
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN4absl5Mutex5TransEPKNS_6MuHowSE(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %how) #0 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %how.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %how, ptr %how.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %how.addr, align 8
  call void @_ZN4absl5Mutex8LockSlowEPKNS_6MuHowSEPKNS_9ConditionEi(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef %0, ptr noundef null, i32 noundef 3) #16
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN4absl5Mutex3FerEPNS_13base_internal14PerThreadSynchE(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %w) #0 align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr.i.i = alloca ptr, align 8
  %__i1.addr.i.i = alloca ptr, align 8
  %__i2.addr.i.i = alloca i64, align 8
  %__m1.addr.i.i = alloca i32, align 4
  %__m2.addr.i.i = alloca i32, align 4
  %.atomictmp.i.i = alloca i64, align 8
  %cmpxchg.bool.i.i = alloca i8, align 1
  %this.addr.i201 = alloca ptr, align 8
  %__i1.addr.i202 = alloca ptr, align 8
  %__i2.addr.i203 = alloca i64, align 8
  %__m.addr.i204 = alloca i32, align 4
  %this.addr.i122 = alloca ptr, align 8
  %__i1.addr.i123 = alloca ptr, align 8
  %__i2.addr.i124 = alloca i64, align 8
  %__m1.addr.i125 = alloca i32, align 4
  %__m2.addr.i126 = alloca i32, align 4
  %.atomictmp.i127 = alloca i64, align 8
  %cmpxchg.bool.i128 = alloca i8, align 1
  %this.addr.i117 = alloca ptr, align 8
  %__i1.addr.i = alloca ptr, align 8
  %__i2.addr.i = alloca i64, align 8
  %__m1.addr.i = alloca i32, align 4
  %__m2.addr.i = alloca i32, align 4
  %.atomictmp.i = alloca i64, align 8
  %cmpxchg.bool.i = alloca i8, align 1
  %this.addr.i107 = alloca ptr, align 8
  %__m.addr.i108 = alloca i32, align 4
  %__b.i109 = alloca i32, align 4
  %atomic-temp.i110 = alloca i64, align 8
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i64, align 8
  %this.addr = alloca ptr, align 8
  %w.addr = alloca ptr, align 8
  %disable_rescheduling = alloca %"struct.absl::base_internal::SchedulingGuard::ScopedDisable", align 1
  %c = alloca i32, align 4
  %absl_raw_log_internal_basename = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %absl_raw_log_internal_basename14 = alloca ptr, align 8
  %ref.tmp = alloca %"class.absl::synchronization_internal::KernelTimeout", align 8
  %v = alloca i64, align 8
  %conflicting = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %new_h = alloca ptr, align 8
  %absl_raw_log_internal_basename43 = alloca ptr, align 8
  %h = alloca ptr, align 8
  %new_h70 = alloca ptr, align 8
  %absl_raw_log_internal_basename79 = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %w, ptr %w.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4absl13base_internal15SchedulingGuard13ScopedDisableC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %disable_rescheduling)
  store i32 0, ptr %c, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load ptr, ptr %w.addr, align 8
  %waitp = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %0, i32 0, i32 9
  %1 = load ptr, ptr %waitp, align 8
  %cond = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %cond, align 8
  %cmp = icmp eq ptr %2, null
  %lnot = xor i1 %cmp, true
  br i1 %lnot, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  br label %do.body2

do.body2:                                         ; preds = %if.then
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename, align 8
  invoke void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 2408, ptr noundef @.str.1, ptr noundef @.str.29, ptr noundef @.str.30)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %do.body2
  br label %do.body3

do.body3:                                         ; preds = %invoke.cont
  unreachable

lpad:                                             ; preds = %if.end103, %do.body78, %invoke.cont68, %if.then67, %do.body42, %if.then34, %if.then30, %do.end23, %do.body13, %do.body2
  %3 = landingpad { ptr, i32 }
          cleanup
  %4 = extractvalue { ptr, i32 } %3, 0
  store ptr %4, ptr %exn.slot, align 8
  %5 = extractvalue { ptr, i32 } %3, 1
  store i32 %5, ptr %ehselector.slot, align 4
  call void @_ZN4absl13base_internal15SchedulingGuard13ScopedDisableD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %disable_rescheduling) #13
  br label %eh.resume

do.cond:                                          ; No predecessors!
  br label %do.end

do.end:                                           ; preds = %do.cond
  br label %do.cond4

do.cond4:                                         ; preds = %do.end
  br label %do.end5

do.end5:                                          ; preds = %do.cond4
  br label %if.end

if.end:                                           ; preds = %do.end5, %do.body
  br label %do.cond6

do.cond6:                                         ; preds = %if.end
  br label %do.end7

do.end7:                                          ; preds = %do.cond6
  br label %do.body8

do.body8:                                         ; preds = %do.end7
  %6 = load ptr, ptr %w.addr, align 8
  %waitp9 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %6, i32 0, i32 9
  %7 = load ptr, ptr %waitp9, align 8
  %cv_word = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %7, i32 0, i32 5
  %8 = load ptr, ptr %cv_word, align 8
  %cmp10 = icmp eq ptr %8, null
  %lnot11 = xor i1 %cmp10, true
  br i1 %lnot11, label %if.then12, label %if.end21

if.then12:                                        ; preds = %do.body8
  br label %do.body13

do.body13:                                        ; preds = %if.then12
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename14, align 8
  invoke void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 2410, ptr noundef @.str.1, ptr noundef @.str.31, ptr noundef @.str.32)
          to label %invoke.cont15 unwind label %lpad

invoke.cont15:                                    ; preds = %do.body13
  br label %do.body16

do.body16:                                        ; preds = %invoke.cont15
  unreachable

do.cond17:                                        ; No predecessors!
  br label %do.end18

do.end18:                                         ; preds = %do.cond17
  br label %do.cond19

do.cond19:                                        ; preds = %do.end18
  br label %do.end20

do.end20:                                         ; preds = %do.cond19
  br label %if.end21

if.end21:                                         ; preds = %do.end20, %do.body8
  br label %do.cond22

do.cond22:                                        ; preds = %if.end21
  br label %do.end23

do.end23:                                         ; preds = %do.cond22
  invoke void @_ZN4absl24synchronization_internal13KernelTimeoutC2Ev(ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp)
          to label %invoke.cont24 unwind label %lpad

invoke.cont24:                                    ; preds = %do.end23
  %9 = load ptr, ptr %w.addr, align 8
  %waitp25 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %9, i32 0, i32 9
  %10 = load ptr, ptr %waitp25, align 8
  %timeout = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %10, i32 0, i32 2
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %timeout, ptr align 8 %ref.tmp, i64 8, i1 false)
  br label %for.cond

for.cond:                                         ; preds = %invoke.cont104, %invoke.cont24
  %mu_ = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  store ptr %mu_, ptr %this.addr.i107, align 8
  store i32 0, ptr %__m.addr.i108, align 4
  %this1.i111 = load ptr, ptr %this.addr.i107, align 8
  %11 = load i32, ptr %__m.addr.i108, align 4
  %call.i112 = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %11, i32 noundef 65535)
  store i32 %call.i112, ptr %__b.i109, align 4
  %12 = load i32, ptr %__m.addr.i108, align 4
  switch i32 %12, label %monotonic.i115 [
    i32 1, label %acquire.i114
    i32 2, label %acquire.i114
    i32 5, label %seqcst.i113
  ]

monotonic.i115:                                   ; preds = %for.cond
  %13 = load atomic i64, ptr %this1.i111 monotonic, align 8
  store i64 %13, ptr %atomic-temp.i110, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit116

acquire.i114:                                     ; preds = %for.cond, %for.cond
  %14 = load atomic i64, ptr %this1.i111 acquire, align 8
  store i64 %14, ptr %atomic-temp.i110, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit116

seqcst.i113:                                      ; preds = %for.cond
  %15 = load atomic i64, ptr %this1.i111 seq_cst, align 8
  store i64 %15, ptr %atomic-temp.i110, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit116

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit116: ; preds = %seqcst.i113, %acquire.i114, %monotonic.i115
  %16 = load i64, ptr %atomic-temp.i110, align 8
  store i64 %16, ptr %v, align 8
  %17 = load ptr, ptr %w.addr, align 8
  %waitp26 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %17, i32 0, i32 9
  %18 = load ptr, ptr %waitp26, align 8
  %how = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %18, i32 0, i32 0
  %19 = load ptr, ptr %how, align 8
  %cmp27 = icmp eq ptr %19, @_ZN4abslL8kSharedSE
  %cond28 = select i1 %cmp27, i64 0, i64 1
  %or = or i64 8, %cond28
  store i64 %or, ptr %conflicting, align 8
  %20 = load i64, ptr %v, align 8
  %21 = load i64, ptr %conflicting, align 8
  %and = and i64 %20, %21
  %cmp29 = icmp eq i64 %and, 0
  br i1 %cmp29, label %if.then30, label %if.else

if.then30:                                        ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit116
  %22 = load ptr, ptr %w.addr, align 8
  %next = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %22, i32 0, i32 0
  store ptr null, ptr %next, align 8
  %23 = load ptr, ptr %w.addr, align 8
  %state = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %23, i32 0, i32 8
  call void @_ZNSt6atomicIN4absl13base_internal14PerThreadSynch5StateEE5storeES3_St12memory_order(ptr noundef nonnull align 4 dereferenceable(4) %state, i32 noundef 0, i32 noundef 3) #13
  %24 = load ptr, ptr %w.addr, align 8
  invoke void @_ZN4absl5Mutex17IncrementSynchSemEPS0_PNS_13base_internal14PerThreadSynchE(ptr noundef %this1, ptr noundef %24)
          to label %invoke.cont31 unwind label %lpad

invoke.cont31:                                    ; preds = %if.then30
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.else:                                          ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit116
  %25 = load i64, ptr %v, align 8
  %and32 = and i64 %25, 68
  %cmp33 = icmp eq i64 %and32, 0
  br i1 %cmp33, label %if.then34, label %if.else60

if.then34:                                        ; preds = %if.else
  %26 = load ptr, ptr %w.addr, align 8
  %waitp35 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %26, i32 0, i32 9
  %27 = load ptr, ptr %waitp35, align 8
  %28 = load i64, ptr %v, align 8
  %call37 = invoke noundef ptr @_ZN4abslL7EnqueueEPNS_13base_internal14PerThreadSynchEPNS_15SynchWaitParamsEli(ptr noundef null, ptr noundef %27, i64 noundef %28, i32 noundef 6)
          to label %invoke.cont36 unwind label %lpad

invoke.cont36:                                    ; preds = %if.then34
  store ptr %call37, ptr %new_h, align 8
  br label %do.body38

do.body38:                                        ; preds = %invoke.cont36
  %29 = load ptr, ptr %new_h, align 8
  %cmp39 = icmp ne ptr %29, null
  %lnot40 = xor i1 %cmp39, true
  br i1 %lnot40, label %if.then41, label %if.end50

if.then41:                                        ; preds = %do.body38
  br label %do.body42

do.body42:                                        ; preds = %if.then41
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename43, align 8
  invoke void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 2434, ptr noundef @.str.1, ptr noundef @.str.11, ptr noundef @.str.33)
          to label %invoke.cont44 unwind label %lpad

invoke.cont44:                                    ; preds = %do.body42
  br label %do.body45

do.body45:                                        ; preds = %invoke.cont44
  unreachable

do.cond46:                                        ; No predecessors!
  br label %do.end47

do.end47:                                         ; preds = %do.cond46
  br label %do.cond48

do.cond48:                                        ; preds = %do.end47
  br label %do.end49

do.end49:                                         ; preds = %do.cond48
  br label %if.end50

if.end50:                                         ; preds = %do.end49, %do.body38
  br label %do.cond51

do.cond51:                                        ; preds = %if.end50
  br label %do.end52

do.end52:                                         ; preds = %do.cond51
  %mu_53 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %30 = load ptr, ptr %new_h, align 8
  %31 = ptrtoint ptr %30 to i64
  %32 = load i64, ptr %v, align 8
  %and54 = and i64 %32, 255
  %or55 = or i64 %31, %and54
  %or56 = or i64 %or55, 4
  store ptr %mu_53, ptr %this.addr.i117, align 8
  store ptr %v, ptr %__i1.addr.i, align 8
  store i64 %or56, ptr %__i2.addr.i, align 8
  store i32 3, ptr %__m1.addr.i, align 4
  store i32 0, ptr %__m2.addr.i, align 4
  %this1.i118 = load ptr, ptr %this.addr.i117, align 8
  %33 = load i32, ptr %__m1.addr.i, align 4
  %34 = load ptr, ptr %__i1.addr.i, align 8
  %35 = load i64, ptr %__i2.addr.i, align 8
  store i64 %35, ptr %.atomictmp.i, align 8
  %36 = load i32, ptr %__m2.addr.i, align 4
  switch i32 %33, label %monotonic.i121 [
    i32 1, label %acquire.i120
    i32 2, label %acquire.i120
    i32 3, label %release.i
    i32 4, label %acqrel.i
    i32 5, label %seqcst.i119
  ]

monotonic.i121:                                   ; preds = %do.end52
  switch i32 %36, label %monotonic_fail.i [
    i32 1, label %acquire_fail.i
    i32 2, label %acquire_fail.i
    i32 5, label %seqcst_fail.i
  ]

acquire.i120:                                     ; preds = %do.end52, %do.end52
  switch i32 %36, label %monotonic_fail9.i [
    i32 1, label %acquire_fail10.i
    i32 2, label %acquire_fail10.i
    i32 5, label %seqcst_fail11.i
  ]

release.i:                                        ; preds = %do.end52
  switch i32 %36, label %monotonic_fail22.i [
    i32 1, label %acquire_fail23.i
    i32 2, label %acquire_fail23.i
    i32 5, label %seqcst_fail24.i
  ]

acqrel.i:                                         ; preds = %do.end52
  switch i32 %36, label %monotonic_fail35.i [
    i32 1, label %acquire_fail36.i
    i32 2, label %acquire_fail36.i
    i32 5, label %seqcst_fail37.i
  ]

seqcst.i119:                                      ; preds = %do.end52
  switch i32 %36, label %monotonic_fail48.i [
    i32 1, label %acquire_fail49.i
    i32 2, label %acquire_fail49.i
    i32 5, label %seqcst_fail50.i
  ]

monotonic_fail.i:                                 ; preds = %monotonic.i121
  %37 = load i64, ptr %34, align 8
  %38 = load i64, ptr %.atomictmp.i, align 8
  %39 = cmpxchg ptr %this1.i118, i64 %37, i64 %38 monotonic monotonic, align 8
  %40 = extractvalue { i64, i1 } %39, 0
  %41 = extractvalue { i64, i1 } %39, 1
  br i1 %41, label %cmpxchg.continue.i, label %cmpxchg.store_expected.i

acquire_fail.i:                                   ; preds = %monotonic.i121, %monotonic.i121
  %42 = load i64, ptr %34, align 8
  %43 = load i64, ptr %.atomictmp.i, align 8
  %44 = cmpxchg ptr %this1.i118, i64 %42, i64 %43 monotonic acquire, align 8
  %45 = extractvalue { i64, i1 } %44, 0
  %46 = extractvalue { i64, i1 } %44, 1
  br i1 %46, label %cmpxchg.continue4.i, label %cmpxchg.store_expected3.i

seqcst_fail.i:                                    ; preds = %monotonic.i121
  %47 = load i64, ptr %34, align 8
  %48 = load i64, ptr %.atomictmp.i, align 8
  %49 = cmpxchg ptr %this1.i118, i64 %47, i64 %48 monotonic seq_cst, align 8
  %50 = extractvalue { i64, i1 } %49, 0
  %51 = extractvalue { i64, i1 } %49, 1
  br i1 %51, label %cmpxchg.continue7.i, label %cmpxchg.store_expected6.i

atomic.continue2.i:                               ; preds = %cmpxchg.continue7.i, %cmpxchg.continue4.i, %cmpxchg.continue.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected.i:                         ; preds = %monotonic_fail.i
  store i64 %40, ptr %34, align 8
  br label %cmpxchg.continue.i

cmpxchg.continue.i:                               ; preds = %cmpxchg.store_expected.i, %monotonic_fail.i
  %frombool.i = zext i1 %41 to i8
  store i8 %frombool.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected3.i:                        ; preds = %acquire_fail.i
  store i64 %45, ptr %34, align 8
  br label %cmpxchg.continue4.i

cmpxchg.continue4.i:                              ; preds = %cmpxchg.store_expected3.i, %acquire_fail.i
  %frombool5.i = zext i1 %46 to i8
  store i8 %frombool5.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected6.i:                        ; preds = %seqcst_fail.i
  store i64 %50, ptr %34, align 8
  br label %cmpxchg.continue7.i

cmpxchg.continue7.i:                              ; preds = %cmpxchg.store_expected6.i, %seqcst_fail.i
  %frombool8.i = zext i1 %51 to i8
  store i8 %frombool8.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

monotonic_fail9.i:                                ; preds = %acquire.i120
  %52 = load i64, ptr %34, align 8
  %53 = load i64, ptr %.atomictmp.i, align 8
  %54 = cmpxchg ptr %this1.i118, i64 %52, i64 %53 acquire monotonic, align 8
  %55 = extractvalue { i64, i1 } %54, 0
  %56 = extractvalue { i64, i1 } %54, 1
  br i1 %56, label %cmpxchg.continue14.i, label %cmpxchg.store_expected13.i

acquire_fail10.i:                                 ; preds = %acquire.i120, %acquire.i120
  %57 = load i64, ptr %34, align 8
  %58 = load i64, ptr %.atomictmp.i, align 8
  %59 = cmpxchg ptr %this1.i118, i64 %57, i64 %58 acquire acquire, align 8
  %60 = extractvalue { i64, i1 } %59, 0
  %61 = extractvalue { i64, i1 } %59, 1
  br i1 %61, label %cmpxchg.continue17.i, label %cmpxchg.store_expected16.i

seqcst_fail11.i:                                  ; preds = %acquire.i120
  %62 = load i64, ptr %34, align 8
  %63 = load i64, ptr %.atomictmp.i, align 8
  %64 = cmpxchg ptr %this1.i118, i64 %62, i64 %63 acquire seq_cst, align 8
  %65 = extractvalue { i64, i1 } %64, 0
  %66 = extractvalue { i64, i1 } %64, 1
  br i1 %66, label %cmpxchg.continue20.i, label %cmpxchg.store_expected19.i

atomic.continue12.i:                              ; preds = %cmpxchg.continue20.i, %cmpxchg.continue17.i, %cmpxchg.continue14.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected13.i:                       ; preds = %monotonic_fail9.i
  store i64 %55, ptr %34, align 8
  br label %cmpxchg.continue14.i

cmpxchg.continue14.i:                             ; preds = %cmpxchg.store_expected13.i, %monotonic_fail9.i
  %frombool15.i = zext i1 %56 to i8
  store i8 %frombool15.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected16.i:                       ; preds = %acquire_fail10.i
  store i64 %60, ptr %34, align 8
  br label %cmpxchg.continue17.i

cmpxchg.continue17.i:                             ; preds = %cmpxchg.store_expected16.i, %acquire_fail10.i
  %frombool18.i = zext i1 %61 to i8
  store i8 %frombool18.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected19.i:                       ; preds = %seqcst_fail11.i
  store i64 %65, ptr %34, align 8
  br label %cmpxchg.continue20.i

cmpxchg.continue20.i:                             ; preds = %cmpxchg.store_expected19.i, %seqcst_fail11.i
  %frombool21.i = zext i1 %66 to i8
  store i8 %frombool21.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

monotonic_fail22.i:                               ; preds = %release.i
  %67 = load i64, ptr %34, align 8
  %68 = load i64, ptr %.atomictmp.i, align 8
  %69 = cmpxchg ptr %this1.i118, i64 %67, i64 %68 release monotonic, align 8
  %70 = extractvalue { i64, i1 } %69, 0
  %71 = extractvalue { i64, i1 } %69, 1
  br i1 %71, label %cmpxchg.continue27.i, label %cmpxchg.store_expected26.i

acquire_fail23.i:                                 ; preds = %release.i, %release.i
  %72 = load i64, ptr %34, align 8
  %73 = load i64, ptr %.atomictmp.i, align 8
  %74 = cmpxchg ptr %this1.i118, i64 %72, i64 %73 release acquire, align 8
  %75 = extractvalue { i64, i1 } %74, 0
  %76 = extractvalue { i64, i1 } %74, 1
  br i1 %76, label %cmpxchg.continue30.i, label %cmpxchg.store_expected29.i

seqcst_fail24.i:                                  ; preds = %release.i
  %77 = load i64, ptr %34, align 8
  %78 = load i64, ptr %.atomictmp.i, align 8
  %79 = cmpxchg ptr %this1.i118, i64 %77, i64 %78 release seq_cst, align 8
  %80 = extractvalue { i64, i1 } %79, 0
  %81 = extractvalue { i64, i1 } %79, 1
  br i1 %81, label %cmpxchg.continue33.i, label %cmpxchg.store_expected32.i

atomic.continue25.i:                              ; preds = %cmpxchg.continue33.i, %cmpxchg.continue30.i, %cmpxchg.continue27.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected26.i:                       ; preds = %monotonic_fail22.i
  store i64 %70, ptr %34, align 8
  br label %cmpxchg.continue27.i

cmpxchg.continue27.i:                             ; preds = %cmpxchg.store_expected26.i, %monotonic_fail22.i
  %frombool28.i = zext i1 %71 to i8
  store i8 %frombool28.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected29.i:                       ; preds = %acquire_fail23.i
  store i64 %75, ptr %34, align 8
  br label %cmpxchg.continue30.i

cmpxchg.continue30.i:                             ; preds = %cmpxchg.store_expected29.i, %acquire_fail23.i
  %frombool31.i = zext i1 %76 to i8
  store i8 %frombool31.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected32.i:                       ; preds = %seqcst_fail24.i
  store i64 %80, ptr %34, align 8
  br label %cmpxchg.continue33.i

cmpxchg.continue33.i:                             ; preds = %cmpxchg.store_expected32.i, %seqcst_fail24.i
  %frombool34.i = zext i1 %81 to i8
  store i8 %frombool34.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

monotonic_fail35.i:                               ; preds = %acqrel.i
  %82 = load i64, ptr %34, align 8
  %83 = load i64, ptr %.atomictmp.i, align 8
  %84 = cmpxchg ptr %this1.i118, i64 %82, i64 %83 acq_rel monotonic, align 8
  %85 = extractvalue { i64, i1 } %84, 0
  %86 = extractvalue { i64, i1 } %84, 1
  br i1 %86, label %cmpxchg.continue40.i, label %cmpxchg.store_expected39.i

acquire_fail36.i:                                 ; preds = %acqrel.i, %acqrel.i
  %87 = load i64, ptr %34, align 8
  %88 = load i64, ptr %.atomictmp.i, align 8
  %89 = cmpxchg ptr %this1.i118, i64 %87, i64 %88 acq_rel acquire, align 8
  %90 = extractvalue { i64, i1 } %89, 0
  %91 = extractvalue { i64, i1 } %89, 1
  br i1 %91, label %cmpxchg.continue43.i, label %cmpxchg.store_expected42.i

seqcst_fail37.i:                                  ; preds = %acqrel.i
  %92 = load i64, ptr %34, align 8
  %93 = load i64, ptr %.atomictmp.i, align 8
  %94 = cmpxchg ptr %this1.i118, i64 %92, i64 %93 acq_rel seq_cst, align 8
  %95 = extractvalue { i64, i1 } %94, 0
  %96 = extractvalue { i64, i1 } %94, 1
  br i1 %96, label %cmpxchg.continue46.i, label %cmpxchg.store_expected45.i

atomic.continue38.i:                              ; preds = %cmpxchg.continue46.i, %cmpxchg.continue43.i, %cmpxchg.continue40.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected39.i:                       ; preds = %monotonic_fail35.i
  store i64 %85, ptr %34, align 8
  br label %cmpxchg.continue40.i

cmpxchg.continue40.i:                             ; preds = %cmpxchg.store_expected39.i, %monotonic_fail35.i
  %frombool41.i = zext i1 %86 to i8
  store i8 %frombool41.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected42.i:                       ; preds = %acquire_fail36.i
  store i64 %90, ptr %34, align 8
  br label %cmpxchg.continue43.i

cmpxchg.continue43.i:                             ; preds = %cmpxchg.store_expected42.i, %acquire_fail36.i
  %frombool44.i = zext i1 %91 to i8
  store i8 %frombool44.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected45.i:                       ; preds = %seqcst_fail37.i
  store i64 %95, ptr %34, align 8
  br label %cmpxchg.continue46.i

cmpxchg.continue46.i:                             ; preds = %cmpxchg.store_expected45.i, %seqcst_fail37.i
  %frombool47.i = zext i1 %96 to i8
  store i8 %frombool47.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

monotonic_fail48.i:                               ; preds = %seqcst.i119
  %97 = load i64, ptr %34, align 8
  %98 = load i64, ptr %.atomictmp.i, align 8
  %99 = cmpxchg ptr %this1.i118, i64 %97, i64 %98 seq_cst monotonic, align 8
  %100 = extractvalue { i64, i1 } %99, 0
  %101 = extractvalue { i64, i1 } %99, 1
  br i1 %101, label %cmpxchg.continue53.i, label %cmpxchg.store_expected52.i

acquire_fail49.i:                                 ; preds = %seqcst.i119, %seqcst.i119
  %102 = load i64, ptr %34, align 8
  %103 = load i64, ptr %.atomictmp.i, align 8
  %104 = cmpxchg ptr %this1.i118, i64 %102, i64 %103 seq_cst acquire, align 8
  %105 = extractvalue { i64, i1 } %104, 0
  %106 = extractvalue { i64, i1 } %104, 1
  br i1 %106, label %cmpxchg.continue56.i, label %cmpxchg.store_expected55.i

seqcst_fail50.i:                                  ; preds = %seqcst.i119
  %107 = load i64, ptr %34, align 8
  %108 = load i64, ptr %.atomictmp.i, align 8
  %109 = cmpxchg ptr %this1.i118, i64 %107, i64 %108 seq_cst seq_cst, align 8
  %110 = extractvalue { i64, i1 } %109, 0
  %111 = extractvalue { i64, i1 } %109, 1
  br i1 %111, label %cmpxchg.continue59.i, label %cmpxchg.store_expected58.i

atomic.continue51.i:                              ; preds = %cmpxchg.continue59.i, %cmpxchg.continue56.i, %cmpxchg.continue53.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected52.i:                       ; preds = %monotonic_fail48.i
  store i64 %100, ptr %34, align 8
  br label %cmpxchg.continue53.i

cmpxchg.continue53.i:                             ; preds = %cmpxchg.store_expected52.i, %monotonic_fail48.i
  %frombool54.i = zext i1 %101 to i8
  store i8 %frombool54.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected55.i:                       ; preds = %acquire_fail49.i
  store i64 %105, ptr %34, align 8
  br label %cmpxchg.continue56.i

cmpxchg.continue56.i:                             ; preds = %cmpxchg.store_expected55.i, %acquire_fail49.i
  %frombool57.i = zext i1 %106 to i8
  store i8 %frombool57.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected58.i:                       ; preds = %seqcst_fail50.i
  store i64 %110, ptr %34, align 8
  br label %cmpxchg.continue59.i

cmpxchg.continue59.i:                             ; preds = %cmpxchg.store_expected58.i, %seqcst_fail50.i
  %frombool60.i = zext i1 %111 to i8
  store i8 %frombool60.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit: ; preds = %atomic.continue51.i, %atomic.continue38.i, %atomic.continue25.i, %atomic.continue12.i, %atomic.continue2.i
  %112 = load i8, ptr %cmpxchg.bool.i, align 1
  %tobool.i = trunc i8 %112 to i1
  br i1 %tobool.i, label %if.then58, label %if.end59

if.then58:                                        ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end59:                                         ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit
  br label %if.end102

if.else60:                                        ; preds = %if.else
  %113 = load i64, ptr %v, align 8
  %and61 = and i64 %113, 64
  %cmp62 = icmp eq i64 %and61, 0
  br i1 %cmp62, label %land.lhs.true, label %if.end101

land.lhs.true:                                    ; preds = %if.else60
  %mu_63 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %114 = load i64, ptr %v, align 8
  %or64 = or i64 %114, 64
  %or65 = or i64 %or64, 4
  store ptr %mu_63, ptr %this.addr.i201, align 8
  store ptr %v, ptr %__i1.addr.i202, align 8
  store i64 %or65, ptr %__i2.addr.i203, align 8
  store i32 5, ptr %__m.addr.i204, align 4
  %this1.i205 = load ptr, ptr %this.addr.i201, align 8
  %115 = load ptr, ptr %__i1.addr.i202, align 8
  %116 = load i64, ptr %__i2.addr.i203, align 8
  %117 = load i32, ptr %__m.addr.i204, align 4
  %118 = load i32, ptr %__m.addr.i204, align 4
  %call.i206 = call noundef i32 @_ZSt23__cmpexch_failure_orderSt12memory_order(i32 noundef %118) #13
  store ptr %this1.i205, ptr %this.addr.i.i, align 8
  store ptr %115, ptr %__i1.addr.i.i, align 8
  store i64 %116, ptr %__i2.addr.i.i, align 8
  store i32 %117, ptr %__m1.addr.i.i, align 4
  store i32 %call.i206, ptr %__m2.addr.i.i, align 4
  %this1.i.i = load ptr, ptr %this.addr.i.i, align 8
  %119 = load i32, ptr %__m1.addr.i.i, align 4
  %120 = load ptr, ptr %__i1.addr.i.i, align 8
  %121 = load i64, ptr %__i2.addr.i.i, align 8
  store i64 %121, ptr %.atomictmp.i.i, align 8
  %122 = load i32, ptr %__m2.addr.i.i, align 4
  switch i32 %119, label %monotonic.i.i [
    i32 1, label %acquire.i.i
    i32 2, label %acquire.i.i
    i32 3, label %release.i.i
    i32 4, label %acqrel.i.i
    i32 5, label %seqcst.i.i
  ]

monotonic.i.i:                                    ; preds = %land.lhs.true
  switch i32 %122, label %monotonic_fail.i.i [
    i32 1, label %acquire_fail.i.i
    i32 2, label %acquire_fail.i.i
    i32 5, label %seqcst_fail.i.i
  ]

acquire.i.i:                                      ; preds = %land.lhs.true, %land.lhs.true
  switch i32 %122, label %monotonic_fail9.i.i [
    i32 1, label %acquire_fail10.i.i
    i32 2, label %acquire_fail10.i.i
    i32 5, label %seqcst_fail11.i.i
  ]

release.i.i:                                      ; preds = %land.lhs.true
  switch i32 %122, label %monotonic_fail22.i.i [
    i32 1, label %acquire_fail23.i.i
    i32 2, label %acquire_fail23.i.i
    i32 5, label %seqcst_fail24.i.i
  ]

acqrel.i.i:                                       ; preds = %land.lhs.true
  switch i32 %122, label %monotonic_fail35.i.i [
    i32 1, label %acquire_fail36.i.i
    i32 2, label %acquire_fail36.i.i
    i32 5, label %seqcst_fail37.i.i
  ]

seqcst.i.i:                                       ; preds = %land.lhs.true
  switch i32 %122, label %monotonic_fail48.i.i [
    i32 1, label %acquire_fail49.i.i
    i32 2, label %acquire_fail49.i.i
    i32 5, label %seqcst_fail50.i.i
  ]

monotonic_fail.i.i:                               ; preds = %monotonic.i.i
  %123 = load i64, ptr %120, align 8
  %124 = load i64, ptr %.atomictmp.i.i, align 8
  %125 = cmpxchg ptr %this1.i.i, i64 %123, i64 %124 monotonic monotonic, align 8
  %126 = extractvalue { i64, i1 } %125, 0
  %127 = extractvalue { i64, i1 } %125, 1
  br i1 %127, label %cmpxchg.continue.i.i, label %cmpxchg.store_expected.i.i

acquire_fail.i.i:                                 ; preds = %monotonic.i.i, %monotonic.i.i
  %128 = load i64, ptr %120, align 8
  %129 = load i64, ptr %.atomictmp.i.i, align 8
  %130 = cmpxchg ptr %this1.i.i, i64 %128, i64 %129 monotonic acquire, align 8
  %131 = extractvalue { i64, i1 } %130, 0
  %132 = extractvalue { i64, i1 } %130, 1
  br i1 %132, label %cmpxchg.continue4.i.i, label %cmpxchg.store_expected3.i.i

seqcst_fail.i.i:                                  ; preds = %monotonic.i.i
  %133 = load i64, ptr %120, align 8
  %134 = load i64, ptr %.atomictmp.i.i, align 8
  %135 = cmpxchg ptr %this1.i.i, i64 %133, i64 %134 monotonic seq_cst, align 8
  %136 = extractvalue { i64, i1 } %135, 0
  %137 = extractvalue { i64, i1 } %135, 1
  br i1 %137, label %cmpxchg.continue7.i.i, label %cmpxchg.store_expected6.i.i

atomic.continue2.i.i:                             ; preds = %cmpxchg.continue7.i.i, %cmpxchg.continue4.i.i, %cmpxchg.continue.i.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_order.exit

cmpxchg.store_expected.i.i:                       ; preds = %monotonic_fail.i.i
  store i64 %126, ptr %120, align 8
  br label %cmpxchg.continue.i.i

cmpxchg.continue.i.i:                             ; preds = %cmpxchg.store_expected.i.i, %monotonic_fail.i.i
  %frombool.i.i = zext i1 %127 to i8
  store i8 %frombool.i.i, ptr %cmpxchg.bool.i.i, align 1
  br label %atomic.continue2.i.i

cmpxchg.store_expected3.i.i:                      ; preds = %acquire_fail.i.i
  store i64 %131, ptr %120, align 8
  br label %cmpxchg.continue4.i.i

cmpxchg.continue4.i.i:                            ; preds = %cmpxchg.store_expected3.i.i, %acquire_fail.i.i
  %frombool5.i.i = zext i1 %132 to i8
  store i8 %frombool5.i.i, ptr %cmpxchg.bool.i.i, align 1
  br label %atomic.continue2.i.i

cmpxchg.store_expected6.i.i:                      ; preds = %seqcst_fail.i.i
  store i64 %136, ptr %120, align 8
  br label %cmpxchg.continue7.i.i

cmpxchg.continue7.i.i:                            ; preds = %cmpxchg.store_expected6.i.i, %seqcst_fail.i.i
  %frombool8.i.i = zext i1 %137 to i8
  store i8 %frombool8.i.i, ptr %cmpxchg.bool.i.i, align 1
  br label %atomic.continue2.i.i

monotonic_fail9.i.i:                              ; preds = %acquire.i.i
  %138 = load i64, ptr %120, align 8
  %139 = load i64, ptr %.atomictmp.i.i, align 8
  %140 = cmpxchg ptr %this1.i.i, i64 %138, i64 %139 acquire monotonic, align 8
  %141 = extractvalue { i64, i1 } %140, 0
  %142 = extractvalue { i64, i1 } %140, 1
  br i1 %142, label %cmpxchg.continue14.i.i, label %cmpxchg.store_expected13.i.i

acquire_fail10.i.i:                               ; preds = %acquire.i.i, %acquire.i.i
  %143 = load i64, ptr %120, align 8
  %144 = load i64, ptr %.atomictmp.i.i, align 8
  %145 = cmpxchg ptr %this1.i.i, i64 %143, i64 %144 acquire acquire, align 8
  %146 = extractvalue { i64, i1 } %145, 0
  %147 = extractvalue { i64, i1 } %145, 1
  br i1 %147, label %cmpxchg.continue17.i.i, label %cmpxchg.store_expected16.i.i

seqcst_fail11.i.i:                                ; preds = %acquire.i.i
  %148 = load i64, ptr %120, align 8
  %149 = load i64, ptr %.atomictmp.i.i, align 8
  %150 = cmpxchg ptr %this1.i.i, i64 %148, i64 %149 acquire seq_cst, align 8
  %151 = extractvalue { i64, i1 } %150, 0
  %152 = extractvalue { i64, i1 } %150, 1
  br i1 %152, label %cmpxchg.continue20.i.i, label %cmpxchg.store_expected19.i.i

atomic.continue12.i.i:                            ; preds = %cmpxchg.continue20.i.i, %cmpxchg.continue17.i.i, %cmpxchg.continue14.i.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_order.exit

cmpxchg.store_expected13.i.i:                     ; preds = %monotonic_fail9.i.i
  store i64 %141, ptr %120, align 8
  br label %cmpxchg.continue14.i.i

cmpxchg.continue14.i.i:                           ; preds = %cmpxchg.store_expected13.i.i, %monotonic_fail9.i.i
  %frombool15.i.i = zext i1 %142 to i8
  store i8 %frombool15.i.i, ptr %cmpxchg.bool.i.i, align 1
  br label %atomic.continue12.i.i

cmpxchg.store_expected16.i.i:                     ; preds = %acquire_fail10.i.i
  store i64 %146, ptr %120, align 8
  br label %cmpxchg.continue17.i.i

cmpxchg.continue17.i.i:                           ; preds = %cmpxchg.store_expected16.i.i, %acquire_fail10.i.i
  %frombool18.i.i = zext i1 %147 to i8
  store i8 %frombool18.i.i, ptr %cmpxchg.bool.i.i, align 1
  br label %atomic.continue12.i.i

cmpxchg.store_expected19.i.i:                     ; preds = %seqcst_fail11.i.i
  store i64 %151, ptr %120, align 8
  br label %cmpxchg.continue20.i.i

cmpxchg.continue20.i.i:                           ; preds = %cmpxchg.store_expected19.i.i, %seqcst_fail11.i.i
  %frombool21.i.i = zext i1 %152 to i8
  store i8 %frombool21.i.i, ptr %cmpxchg.bool.i.i, align 1
  br label %atomic.continue12.i.i

monotonic_fail22.i.i:                             ; preds = %release.i.i
  %153 = load i64, ptr %120, align 8
  %154 = load i64, ptr %.atomictmp.i.i, align 8
  %155 = cmpxchg ptr %this1.i.i, i64 %153, i64 %154 release monotonic, align 8
  %156 = extractvalue { i64, i1 } %155, 0
  %157 = extractvalue { i64, i1 } %155, 1
  br i1 %157, label %cmpxchg.continue27.i.i, label %cmpxchg.store_expected26.i.i

acquire_fail23.i.i:                               ; preds = %release.i.i, %release.i.i
  %158 = load i64, ptr %120, align 8
  %159 = load i64, ptr %.atomictmp.i.i, align 8
  %160 = cmpxchg ptr %this1.i.i, i64 %158, i64 %159 release acquire, align 8
  %161 = extractvalue { i64, i1 } %160, 0
  %162 = extractvalue { i64, i1 } %160, 1
  br i1 %162, label %cmpxchg.continue30.i.i, label %cmpxchg.store_expected29.i.i

seqcst_fail24.i.i:                                ; preds = %release.i.i
  %163 = load i64, ptr %120, align 8
  %164 = load i64, ptr %.atomictmp.i.i, align 8
  %165 = cmpxchg ptr %this1.i.i, i64 %163, i64 %164 release seq_cst, align 8
  %166 = extractvalue { i64, i1 } %165, 0
  %167 = extractvalue { i64, i1 } %165, 1
  br i1 %167, label %cmpxchg.continue33.i.i, label %cmpxchg.store_expected32.i.i

atomic.continue25.i.i:                            ; preds = %cmpxchg.continue33.i.i, %cmpxchg.continue30.i.i, %cmpxchg.continue27.i.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_order.exit

cmpxchg.store_expected26.i.i:                     ; preds = %monotonic_fail22.i.i
  store i64 %156, ptr %120, align 8
  br label %cmpxchg.continue27.i.i

cmpxchg.continue27.i.i:                           ; preds = %cmpxchg.store_expected26.i.i, %monotonic_fail22.i.i
  %frombool28.i.i = zext i1 %157 to i8
  store i8 %frombool28.i.i, ptr %cmpxchg.bool.i.i, align 1
  br label %atomic.continue25.i.i

cmpxchg.store_expected29.i.i:                     ; preds = %acquire_fail23.i.i
  store i64 %161, ptr %120, align 8
  br label %cmpxchg.continue30.i.i

cmpxchg.continue30.i.i:                           ; preds = %cmpxchg.store_expected29.i.i, %acquire_fail23.i.i
  %frombool31.i.i = zext i1 %162 to i8
  store i8 %frombool31.i.i, ptr %cmpxchg.bool.i.i, align 1
  br label %atomic.continue25.i.i

cmpxchg.store_expected32.i.i:                     ; preds = %seqcst_fail24.i.i
  store i64 %166, ptr %120, align 8
  br label %cmpxchg.continue33.i.i

cmpxchg.continue33.i.i:                           ; preds = %cmpxchg.store_expected32.i.i, %seqcst_fail24.i.i
  %frombool34.i.i = zext i1 %167 to i8
  store i8 %frombool34.i.i, ptr %cmpxchg.bool.i.i, align 1
  br label %atomic.continue25.i.i

monotonic_fail35.i.i:                             ; preds = %acqrel.i.i
  %168 = load i64, ptr %120, align 8
  %169 = load i64, ptr %.atomictmp.i.i, align 8
  %170 = cmpxchg ptr %this1.i.i, i64 %168, i64 %169 acq_rel monotonic, align 8
  %171 = extractvalue { i64, i1 } %170, 0
  %172 = extractvalue { i64, i1 } %170, 1
  br i1 %172, label %cmpxchg.continue40.i.i, label %cmpxchg.store_expected39.i.i

acquire_fail36.i.i:                               ; preds = %acqrel.i.i, %acqrel.i.i
  %173 = load i64, ptr %120, align 8
  %174 = load i64, ptr %.atomictmp.i.i, align 8
  %175 = cmpxchg ptr %this1.i.i, i64 %173, i64 %174 acq_rel acquire, align 8
  %176 = extractvalue { i64, i1 } %175, 0
  %177 = extractvalue { i64, i1 } %175, 1
  br i1 %177, label %cmpxchg.continue43.i.i, label %cmpxchg.store_expected42.i.i

seqcst_fail37.i.i:                                ; preds = %acqrel.i.i
  %178 = load i64, ptr %120, align 8
  %179 = load i64, ptr %.atomictmp.i.i, align 8
  %180 = cmpxchg ptr %this1.i.i, i64 %178, i64 %179 acq_rel seq_cst, align 8
  %181 = extractvalue { i64, i1 } %180, 0
  %182 = extractvalue { i64, i1 } %180, 1
  br i1 %182, label %cmpxchg.continue46.i.i, label %cmpxchg.store_expected45.i.i

atomic.continue38.i.i:                            ; preds = %cmpxchg.continue46.i.i, %cmpxchg.continue43.i.i, %cmpxchg.continue40.i.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_order.exit

cmpxchg.store_expected39.i.i:                     ; preds = %monotonic_fail35.i.i
  store i64 %171, ptr %120, align 8
  br label %cmpxchg.continue40.i.i

cmpxchg.continue40.i.i:                           ; preds = %cmpxchg.store_expected39.i.i, %monotonic_fail35.i.i
  %frombool41.i.i = zext i1 %172 to i8
  store i8 %frombool41.i.i, ptr %cmpxchg.bool.i.i, align 1
  br label %atomic.continue38.i.i

cmpxchg.store_expected42.i.i:                     ; preds = %acquire_fail36.i.i
  store i64 %176, ptr %120, align 8
  br label %cmpxchg.continue43.i.i

cmpxchg.continue43.i.i:                           ; preds = %cmpxchg.store_expected42.i.i, %acquire_fail36.i.i
  %frombool44.i.i = zext i1 %177 to i8
  store i8 %frombool44.i.i, ptr %cmpxchg.bool.i.i, align 1
  br label %atomic.continue38.i.i

cmpxchg.store_expected45.i.i:                     ; preds = %seqcst_fail37.i.i
  store i64 %181, ptr %120, align 8
  br label %cmpxchg.continue46.i.i

cmpxchg.continue46.i.i:                           ; preds = %cmpxchg.store_expected45.i.i, %seqcst_fail37.i.i
  %frombool47.i.i = zext i1 %182 to i8
  store i8 %frombool47.i.i, ptr %cmpxchg.bool.i.i, align 1
  br label %atomic.continue38.i.i

monotonic_fail48.i.i:                             ; preds = %seqcst.i.i
  %183 = load i64, ptr %120, align 8
  %184 = load i64, ptr %.atomictmp.i.i, align 8
  %185 = cmpxchg ptr %this1.i.i, i64 %183, i64 %184 seq_cst monotonic, align 8
  %186 = extractvalue { i64, i1 } %185, 0
  %187 = extractvalue { i64, i1 } %185, 1
  br i1 %187, label %cmpxchg.continue53.i.i, label %cmpxchg.store_expected52.i.i

acquire_fail49.i.i:                               ; preds = %seqcst.i.i, %seqcst.i.i
  %188 = load i64, ptr %120, align 8
  %189 = load i64, ptr %.atomictmp.i.i, align 8
  %190 = cmpxchg ptr %this1.i.i, i64 %188, i64 %189 seq_cst acquire, align 8
  %191 = extractvalue { i64, i1 } %190, 0
  %192 = extractvalue { i64, i1 } %190, 1
  br i1 %192, label %cmpxchg.continue56.i.i, label %cmpxchg.store_expected55.i.i

seqcst_fail50.i.i:                                ; preds = %seqcst.i.i
  %193 = load i64, ptr %120, align 8
  %194 = load i64, ptr %.atomictmp.i.i, align 8
  %195 = cmpxchg ptr %this1.i.i, i64 %193, i64 %194 seq_cst seq_cst, align 8
  %196 = extractvalue { i64, i1 } %195, 0
  %197 = extractvalue { i64, i1 } %195, 1
  br i1 %197, label %cmpxchg.continue59.i.i, label %cmpxchg.store_expected58.i.i

atomic.continue51.i.i:                            ; preds = %cmpxchg.continue59.i.i, %cmpxchg.continue56.i.i, %cmpxchg.continue53.i.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_order.exit

cmpxchg.store_expected52.i.i:                     ; preds = %monotonic_fail48.i.i
  store i64 %186, ptr %120, align 8
  br label %cmpxchg.continue53.i.i

cmpxchg.continue53.i.i:                           ; preds = %cmpxchg.store_expected52.i.i, %monotonic_fail48.i.i
  %frombool54.i.i = zext i1 %187 to i8
  store i8 %frombool54.i.i, ptr %cmpxchg.bool.i.i, align 1
  br label %atomic.continue51.i.i

cmpxchg.store_expected55.i.i:                     ; preds = %acquire_fail49.i.i
  store i64 %191, ptr %120, align 8
  br label %cmpxchg.continue56.i.i

cmpxchg.continue56.i.i:                           ; preds = %cmpxchg.store_expected55.i.i, %acquire_fail49.i.i
  %frombool57.i.i = zext i1 %192 to i8
  store i8 %frombool57.i.i, ptr %cmpxchg.bool.i.i, align 1
  br label %atomic.continue51.i.i

cmpxchg.store_expected58.i.i:                     ; preds = %seqcst_fail50.i.i
  store i64 %196, ptr %120, align 8
  br label %cmpxchg.continue59.i.i

cmpxchg.continue59.i.i:                           ; preds = %cmpxchg.store_expected58.i.i, %seqcst_fail50.i.i
  %frombool60.i.i = zext i1 %197 to i8
  store i8 %frombool60.i.i, ptr %cmpxchg.bool.i.i, align 1
  br label %atomic.continue51.i.i

_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_order.exit: ; preds = %atomic.continue51.i.i, %atomic.continue38.i.i, %atomic.continue25.i.i, %atomic.continue12.i.i, %atomic.continue2.i.i
  %198 = load i8, ptr %cmpxchg.bool.i.i, align 1
  %tobool.i.i = trunc i8 %198 to i1
  br i1 %tobool.i.i, label %if.then67, label %if.end101

if.then67:                                        ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_order.exit
  %199 = load i64, ptr %v, align 8
  %call69 = invoke noundef ptr @_ZN4abslL17GetPerThreadSynchEl(i64 noundef %199)
          to label %invoke.cont68 unwind label %lpad

invoke.cont68:                                    ; preds = %if.then67
  store ptr %call69, ptr %h, align 8
  %200 = load ptr, ptr %h, align 8
  %201 = load ptr, ptr %w.addr, align 8
  %waitp71 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %201, i32 0, i32 9
  %202 = load ptr, ptr %waitp71, align 8
  %203 = load i64, ptr %v, align 8
  %call73 = invoke noundef ptr @_ZN4abslL7EnqueueEPNS_13base_internal14PerThreadSynchEPNS_15SynchWaitParamsEli(ptr noundef %200, ptr noundef %202, i64 noundef %203, i32 noundef 6)
          to label %invoke.cont72 unwind label %lpad

invoke.cont72:                                    ; preds = %invoke.cont68
  store ptr %call73, ptr %new_h70, align 8
  br label %do.body74

do.body74:                                        ; preds = %invoke.cont72
  %204 = load ptr, ptr %new_h70, align 8
  %cmp75 = icmp ne ptr %204, null
  %lnot76 = xor i1 %cmp75, true
  br i1 %lnot76, label %if.then77, label %if.end86

if.then77:                                        ; preds = %do.body74
  br label %do.body78

do.body78:                                        ; preds = %if.then77
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename79, align 8
  invoke void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 2445, ptr noundef @.str.1, ptr noundef @.str.11, ptr noundef @.str.33)
          to label %invoke.cont80 unwind label %lpad

invoke.cont80:                                    ; preds = %do.body78
  br label %do.body81

do.body81:                                        ; preds = %invoke.cont80
  unreachable

do.cond82:                                        ; No predecessors!
  br label %do.end83

do.end83:                                         ; preds = %do.cond82
  br label %do.cond84

do.cond84:                                        ; preds = %do.end83
  br label %do.end85

do.end85:                                         ; preds = %do.cond84
  br label %if.end86

if.end86:                                         ; preds = %do.end85, %do.body74
  br label %do.cond87

do.cond87:                                        ; preds = %if.end86
  br label %do.end88

do.end88:                                         ; preds = %do.cond87
  br label %do.body89

do.body89:                                        ; preds = %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit, %do.end88
  %mu_90 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  store ptr %mu_90, ptr %this.addr.i, align 8
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %205 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %205, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %206 = load i32, ptr %__m.addr.i, align 4
  switch i32 %206, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %do.body89
  %207 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %207, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %do.body89, %do.body89
  %208 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %208, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %do.body89
  %209 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %209, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %210 = load i64, ptr %atomic-temp.i, align 8
  store i64 %210, ptr %v, align 8
  br label %do.cond92

do.cond92:                                        ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  %mu_93 = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  %211 = load i64, ptr %v, align 8
  %and94 = and i64 %211, 255
  %and95 = and i64 %and94, -65
  %or96 = or i64 %and95, 4
  %212 = load ptr, ptr %new_h70, align 8
  %213 = ptrtoint ptr %212 to i64
  %or97 = or i64 %or96, %213
  store ptr %mu_93, ptr %this.addr.i122, align 8
  store ptr %v, ptr %__i1.addr.i123, align 8
  store i64 %or97, ptr %__i2.addr.i124, align 8
  store i32 3, ptr %__m1.addr.i125, align 4
  store i32 0, ptr %__m2.addr.i126, align 4
  %this1.i129 = load ptr, ptr %this.addr.i122, align 8
  %214 = load i32, ptr %__m1.addr.i125, align 4
  %215 = load ptr, ptr %__i1.addr.i123, align 8
  %216 = load i64, ptr %__i2.addr.i124, align 8
  store i64 %216, ptr %.atomictmp.i127, align 8
  %217 = load i32, ptr %__m2.addr.i126, align 4
  switch i32 %214, label %monotonic.i187 [
    i32 1, label %acquire.i173
    i32 2, label %acquire.i173
    i32 3, label %release.i159
    i32 4, label %acqrel.i145
    i32 5, label %seqcst.i130
  ]

monotonic.i187:                                   ; preds = %do.cond92
  switch i32 %217, label %monotonic_fail.i197 [
    i32 1, label %acquire_fail.i193
    i32 2, label %acquire_fail.i193
    i32 5, label %seqcst_fail.i188
  ]

acquire.i173:                                     ; preds = %do.cond92, %do.cond92
  switch i32 %217, label %monotonic_fail9.i183 [
    i32 1, label %acquire_fail10.i179
    i32 2, label %acquire_fail10.i179
    i32 5, label %seqcst_fail11.i174
  ]

release.i159:                                     ; preds = %do.cond92
  switch i32 %217, label %monotonic_fail22.i169 [
    i32 1, label %acquire_fail23.i165
    i32 2, label %acquire_fail23.i165
    i32 5, label %seqcst_fail24.i160
  ]

acqrel.i145:                                      ; preds = %do.cond92
  switch i32 %217, label %monotonic_fail35.i155 [
    i32 1, label %acquire_fail36.i151
    i32 2, label %acquire_fail36.i151
    i32 5, label %seqcst_fail37.i146
  ]

seqcst.i130:                                      ; preds = %do.cond92
  switch i32 %217, label %monotonic_fail48.i141 [
    i32 1, label %acquire_fail49.i137
    i32 2, label %acquire_fail49.i137
    i32 5, label %seqcst_fail50.i131
  ]

monotonic_fail.i197:                              ; preds = %monotonic.i187
  %218 = load i64, ptr %215, align 8
  %219 = load i64, ptr %.atomictmp.i127, align 8
  %220 = cmpxchg weak ptr %this1.i129, i64 %218, i64 %219 monotonic monotonic, align 8
  %221 = extractvalue { i64, i1 } %220, 0
  %222 = extractvalue { i64, i1 } %220, 1
  br i1 %222, label %cmpxchg.continue.i199, label %cmpxchg.store_expected.i198

acquire_fail.i193:                                ; preds = %monotonic.i187, %monotonic.i187
  %223 = load i64, ptr %215, align 8
  %224 = load i64, ptr %.atomictmp.i127, align 8
  %225 = cmpxchg weak ptr %this1.i129, i64 %223, i64 %224 monotonic acquire, align 8
  %226 = extractvalue { i64, i1 } %225, 0
  %227 = extractvalue { i64, i1 } %225, 1
  br i1 %227, label %cmpxchg.continue4.i195, label %cmpxchg.store_expected3.i194

seqcst_fail.i188:                                 ; preds = %monotonic.i187
  %228 = load i64, ptr %215, align 8
  %229 = load i64, ptr %.atomictmp.i127, align 8
  %230 = cmpxchg weak ptr %this1.i129, i64 %228, i64 %229 monotonic seq_cst, align 8
  %231 = extractvalue { i64, i1 } %230, 0
  %232 = extractvalue { i64, i1 } %230, 1
  br i1 %232, label %cmpxchg.continue7.i190, label %cmpxchg.store_expected6.i189

atomic.continue2.i192:                            ; preds = %cmpxchg.continue7.i190, %cmpxchg.continue4.i195, %cmpxchg.continue.i199
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected.i198:                      ; preds = %monotonic_fail.i197
  store i64 %221, ptr %215, align 8
  br label %cmpxchg.continue.i199

cmpxchg.continue.i199:                            ; preds = %cmpxchg.store_expected.i198, %monotonic_fail.i197
  %frombool.i200 = zext i1 %222 to i8
  store i8 %frombool.i200, ptr %cmpxchg.bool.i128, align 1
  br label %atomic.continue2.i192

cmpxchg.store_expected3.i194:                     ; preds = %acquire_fail.i193
  store i64 %226, ptr %215, align 8
  br label %cmpxchg.continue4.i195

cmpxchg.continue4.i195:                           ; preds = %cmpxchg.store_expected3.i194, %acquire_fail.i193
  %frombool5.i196 = zext i1 %227 to i8
  store i8 %frombool5.i196, ptr %cmpxchg.bool.i128, align 1
  br label %atomic.continue2.i192

cmpxchg.store_expected6.i189:                     ; preds = %seqcst_fail.i188
  store i64 %231, ptr %215, align 8
  br label %cmpxchg.continue7.i190

cmpxchg.continue7.i190:                           ; preds = %cmpxchg.store_expected6.i189, %seqcst_fail.i188
  %frombool8.i191 = zext i1 %232 to i8
  store i8 %frombool8.i191, ptr %cmpxchg.bool.i128, align 1
  br label %atomic.continue2.i192

monotonic_fail9.i183:                             ; preds = %acquire.i173
  %233 = load i64, ptr %215, align 8
  %234 = load i64, ptr %.atomictmp.i127, align 8
  %235 = cmpxchg weak ptr %this1.i129, i64 %233, i64 %234 acquire monotonic, align 8
  %236 = extractvalue { i64, i1 } %235, 0
  %237 = extractvalue { i64, i1 } %235, 1
  br i1 %237, label %cmpxchg.continue14.i185, label %cmpxchg.store_expected13.i184

acquire_fail10.i179:                              ; preds = %acquire.i173, %acquire.i173
  %238 = load i64, ptr %215, align 8
  %239 = load i64, ptr %.atomictmp.i127, align 8
  %240 = cmpxchg weak ptr %this1.i129, i64 %238, i64 %239 acquire acquire, align 8
  %241 = extractvalue { i64, i1 } %240, 0
  %242 = extractvalue { i64, i1 } %240, 1
  br i1 %242, label %cmpxchg.continue17.i181, label %cmpxchg.store_expected16.i180

seqcst_fail11.i174:                               ; preds = %acquire.i173
  %243 = load i64, ptr %215, align 8
  %244 = load i64, ptr %.atomictmp.i127, align 8
  %245 = cmpxchg weak ptr %this1.i129, i64 %243, i64 %244 acquire seq_cst, align 8
  %246 = extractvalue { i64, i1 } %245, 0
  %247 = extractvalue { i64, i1 } %245, 1
  br i1 %247, label %cmpxchg.continue20.i176, label %cmpxchg.store_expected19.i175

atomic.continue12.i178:                           ; preds = %cmpxchg.continue20.i176, %cmpxchg.continue17.i181, %cmpxchg.continue14.i185
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected13.i184:                    ; preds = %monotonic_fail9.i183
  store i64 %236, ptr %215, align 8
  br label %cmpxchg.continue14.i185

cmpxchg.continue14.i185:                          ; preds = %cmpxchg.store_expected13.i184, %monotonic_fail9.i183
  %frombool15.i186 = zext i1 %237 to i8
  store i8 %frombool15.i186, ptr %cmpxchg.bool.i128, align 1
  br label %atomic.continue12.i178

cmpxchg.store_expected16.i180:                    ; preds = %acquire_fail10.i179
  store i64 %241, ptr %215, align 8
  br label %cmpxchg.continue17.i181

cmpxchg.continue17.i181:                          ; preds = %cmpxchg.store_expected16.i180, %acquire_fail10.i179
  %frombool18.i182 = zext i1 %242 to i8
  store i8 %frombool18.i182, ptr %cmpxchg.bool.i128, align 1
  br label %atomic.continue12.i178

cmpxchg.store_expected19.i175:                    ; preds = %seqcst_fail11.i174
  store i64 %246, ptr %215, align 8
  br label %cmpxchg.continue20.i176

cmpxchg.continue20.i176:                          ; preds = %cmpxchg.store_expected19.i175, %seqcst_fail11.i174
  %frombool21.i177 = zext i1 %247 to i8
  store i8 %frombool21.i177, ptr %cmpxchg.bool.i128, align 1
  br label %atomic.continue12.i178

monotonic_fail22.i169:                            ; preds = %release.i159
  %248 = load i64, ptr %215, align 8
  %249 = load i64, ptr %.atomictmp.i127, align 8
  %250 = cmpxchg weak ptr %this1.i129, i64 %248, i64 %249 release monotonic, align 8
  %251 = extractvalue { i64, i1 } %250, 0
  %252 = extractvalue { i64, i1 } %250, 1
  br i1 %252, label %cmpxchg.continue27.i171, label %cmpxchg.store_expected26.i170

acquire_fail23.i165:                              ; preds = %release.i159, %release.i159
  %253 = load i64, ptr %215, align 8
  %254 = load i64, ptr %.atomictmp.i127, align 8
  %255 = cmpxchg weak ptr %this1.i129, i64 %253, i64 %254 release acquire, align 8
  %256 = extractvalue { i64, i1 } %255, 0
  %257 = extractvalue { i64, i1 } %255, 1
  br i1 %257, label %cmpxchg.continue30.i167, label %cmpxchg.store_expected29.i166

seqcst_fail24.i160:                               ; preds = %release.i159
  %258 = load i64, ptr %215, align 8
  %259 = load i64, ptr %.atomictmp.i127, align 8
  %260 = cmpxchg weak ptr %this1.i129, i64 %258, i64 %259 release seq_cst, align 8
  %261 = extractvalue { i64, i1 } %260, 0
  %262 = extractvalue { i64, i1 } %260, 1
  br i1 %262, label %cmpxchg.continue33.i162, label %cmpxchg.store_expected32.i161

atomic.continue25.i164:                           ; preds = %cmpxchg.continue33.i162, %cmpxchg.continue30.i167, %cmpxchg.continue27.i171
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected26.i170:                    ; preds = %monotonic_fail22.i169
  store i64 %251, ptr %215, align 8
  br label %cmpxchg.continue27.i171

cmpxchg.continue27.i171:                          ; preds = %cmpxchg.store_expected26.i170, %monotonic_fail22.i169
  %frombool28.i172 = zext i1 %252 to i8
  store i8 %frombool28.i172, ptr %cmpxchg.bool.i128, align 1
  br label %atomic.continue25.i164

cmpxchg.store_expected29.i166:                    ; preds = %acquire_fail23.i165
  store i64 %256, ptr %215, align 8
  br label %cmpxchg.continue30.i167

cmpxchg.continue30.i167:                          ; preds = %cmpxchg.store_expected29.i166, %acquire_fail23.i165
  %frombool31.i168 = zext i1 %257 to i8
  store i8 %frombool31.i168, ptr %cmpxchg.bool.i128, align 1
  br label %atomic.continue25.i164

cmpxchg.store_expected32.i161:                    ; preds = %seqcst_fail24.i160
  store i64 %261, ptr %215, align 8
  br label %cmpxchg.continue33.i162

cmpxchg.continue33.i162:                          ; preds = %cmpxchg.store_expected32.i161, %seqcst_fail24.i160
  %frombool34.i163 = zext i1 %262 to i8
  store i8 %frombool34.i163, ptr %cmpxchg.bool.i128, align 1
  br label %atomic.continue25.i164

monotonic_fail35.i155:                            ; preds = %acqrel.i145
  %263 = load i64, ptr %215, align 8
  %264 = load i64, ptr %.atomictmp.i127, align 8
  %265 = cmpxchg weak ptr %this1.i129, i64 %263, i64 %264 acq_rel monotonic, align 8
  %266 = extractvalue { i64, i1 } %265, 0
  %267 = extractvalue { i64, i1 } %265, 1
  br i1 %267, label %cmpxchg.continue40.i157, label %cmpxchg.store_expected39.i156

acquire_fail36.i151:                              ; preds = %acqrel.i145, %acqrel.i145
  %268 = load i64, ptr %215, align 8
  %269 = load i64, ptr %.atomictmp.i127, align 8
  %270 = cmpxchg weak ptr %this1.i129, i64 %268, i64 %269 acq_rel acquire, align 8
  %271 = extractvalue { i64, i1 } %270, 0
  %272 = extractvalue { i64, i1 } %270, 1
  br i1 %272, label %cmpxchg.continue43.i153, label %cmpxchg.store_expected42.i152

seqcst_fail37.i146:                               ; preds = %acqrel.i145
  %273 = load i64, ptr %215, align 8
  %274 = load i64, ptr %.atomictmp.i127, align 8
  %275 = cmpxchg weak ptr %this1.i129, i64 %273, i64 %274 acq_rel seq_cst, align 8
  %276 = extractvalue { i64, i1 } %275, 0
  %277 = extractvalue { i64, i1 } %275, 1
  br i1 %277, label %cmpxchg.continue46.i148, label %cmpxchg.store_expected45.i147

atomic.continue38.i150:                           ; preds = %cmpxchg.continue46.i148, %cmpxchg.continue43.i153, %cmpxchg.continue40.i157
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected39.i156:                    ; preds = %monotonic_fail35.i155
  store i64 %266, ptr %215, align 8
  br label %cmpxchg.continue40.i157

cmpxchg.continue40.i157:                          ; preds = %cmpxchg.store_expected39.i156, %monotonic_fail35.i155
  %frombool41.i158 = zext i1 %267 to i8
  store i8 %frombool41.i158, ptr %cmpxchg.bool.i128, align 1
  br label %atomic.continue38.i150

cmpxchg.store_expected42.i152:                    ; preds = %acquire_fail36.i151
  store i64 %271, ptr %215, align 8
  br label %cmpxchg.continue43.i153

cmpxchg.continue43.i153:                          ; preds = %cmpxchg.store_expected42.i152, %acquire_fail36.i151
  %frombool44.i154 = zext i1 %272 to i8
  store i8 %frombool44.i154, ptr %cmpxchg.bool.i128, align 1
  br label %atomic.continue38.i150

cmpxchg.store_expected45.i147:                    ; preds = %seqcst_fail37.i146
  store i64 %276, ptr %215, align 8
  br label %cmpxchg.continue46.i148

cmpxchg.continue46.i148:                          ; preds = %cmpxchg.store_expected45.i147, %seqcst_fail37.i146
  %frombool47.i149 = zext i1 %277 to i8
  store i8 %frombool47.i149, ptr %cmpxchg.bool.i128, align 1
  br label %atomic.continue38.i150

monotonic_fail48.i141:                            ; preds = %seqcst.i130
  %278 = load i64, ptr %215, align 8
  %279 = load i64, ptr %.atomictmp.i127, align 8
  %280 = cmpxchg weak ptr %this1.i129, i64 %278, i64 %279 seq_cst monotonic, align 8
  %281 = extractvalue { i64, i1 } %280, 0
  %282 = extractvalue { i64, i1 } %280, 1
  br i1 %282, label %cmpxchg.continue53.i143, label %cmpxchg.store_expected52.i142

acquire_fail49.i137:                              ; preds = %seqcst.i130, %seqcst.i130
  %283 = load i64, ptr %215, align 8
  %284 = load i64, ptr %.atomictmp.i127, align 8
  %285 = cmpxchg weak ptr %this1.i129, i64 %283, i64 %284 seq_cst acquire, align 8
  %286 = extractvalue { i64, i1 } %285, 0
  %287 = extractvalue { i64, i1 } %285, 1
  br i1 %287, label %cmpxchg.continue56.i139, label %cmpxchg.store_expected55.i138

seqcst_fail50.i131:                               ; preds = %seqcst.i130
  %288 = load i64, ptr %215, align 8
  %289 = load i64, ptr %.atomictmp.i127, align 8
  %290 = cmpxchg weak ptr %this1.i129, i64 %288, i64 %289 seq_cst seq_cst, align 8
  %291 = extractvalue { i64, i1 } %290, 0
  %292 = extractvalue { i64, i1 } %290, 1
  br i1 %292, label %cmpxchg.continue59.i133, label %cmpxchg.store_expected58.i132

atomic.continue51.i135:                           ; preds = %cmpxchg.continue59.i133, %cmpxchg.continue56.i139, %cmpxchg.continue53.i143
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected52.i142:                    ; preds = %monotonic_fail48.i141
  store i64 %281, ptr %215, align 8
  br label %cmpxchg.continue53.i143

cmpxchg.continue53.i143:                          ; preds = %cmpxchg.store_expected52.i142, %monotonic_fail48.i141
  %frombool54.i144 = zext i1 %282 to i8
  store i8 %frombool54.i144, ptr %cmpxchg.bool.i128, align 1
  br label %atomic.continue51.i135

cmpxchg.store_expected55.i138:                    ; preds = %acquire_fail49.i137
  store i64 %286, ptr %215, align 8
  br label %cmpxchg.continue56.i139

cmpxchg.continue56.i139:                          ; preds = %cmpxchg.store_expected55.i138, %acquire_fail49.i137
  %frombool57.i140 = zext i1 %287 to i8
  store i8 %frombool57.i140, ptr %cmpxchg.bool.i128, align 1
  br label %atomic.continue51.i135

cmpxchg.store_expected58.i132:                    ; preds = %seqcst_fail50.i131
  store i64 %291, ptr %215, align 8
  br label %cmpxchg.continue59.i133

cmpxchg.continue59.i133:                          ; preds = %cmpxchg.store_expected58.i132, %seqcst_fail50.i131
  %frombool60.i134 = zext i1 %292 to i8
  store i8 %frombool60.i134, ptr %cmpxchg.bool.i128, align 1
  br label %atomic.continue51.i135

_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit: ; preds = %atomic.continue51.i135, %atomic.continue38.i150, %atomic.continue25.i164, %atomic.continue12.i178, %atomic.continue2.i192
  %293 = load i8, ptr %cmpxchg.bool.i128, align 1
  %tobool.i136 = trunc i8 %293 to i1
  %lnot99 = xor i1 %tobool.i136, true
  br i1 %lnot99, label %do.body89, label %do.end100, !llvm.loop !29

do.end100:                                        ; preds = %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end101:                                        ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_order.exit, %if.else60
  br label %if.end102

if.end102:                                        ; preds = %if.end101, %if.end59
  br label %if.end103

if.end103:                                        ; preds = %if.end102
  %294 = load i32, ptr %c, align 4
  %call105 = invoke noundef i32 @_ZN4absl24synchronization_internal10MutexDelayEii(i32 noundef %294, i32 noundef 1)
          to label %invoke.cont104 unwind label %lpad

invoke.cont104:                                   ; preds = %if.end103
  store i32 %call105, ptr %c, align 4
  br label %for.cond, !llvm.loop !30

cleanup:                                          ; preds = %do.end100, %if.then58, %invoke.cont31
  call void @_ZN4absl13base_internal15SchedulingGuard13ScopedDisableD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %disable_rescheduling) #13
  ret void

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val106 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val106
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN4absl24synchronization_internal13KernelTimeoutC2Ev(ptr noundef nonnull align 8 dereferenceable(8) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %rep_ = getelementptr inbounds %"class.absl::synchronization_internal::KernelTimeout", ptr %this1, i32 0, i32 0
  store i64 -1, ptr %rep_, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZNK4absl5Mutex10AssertHeldEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 align 2 {
entry:
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i64, align 8
  %this.addr = alloca ptr, align 8
  %e = alloca ptr, align 8
  %absl_raw_log_internal_basename = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mu_ = getelementptr inbounds %"class.absl::Mutex", ptr %this1, i32 0, i32 0
  store ptr %mu_, ptr %this.addr.i, align 8
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %0 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %0, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %1 = load i32, ptr %__m.addr.i, align 4
  switch i32 %1, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %entry
  %2 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %2, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %entry, %entry
  %3 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %3, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %entry
  %4 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %4, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %5 = load i64, ptr %atomic-temp.i, align 8
  %and = and i64 %5, 8
  %cmp = icmp eq i64 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  %call2 = call noundef ptr @_ZN4abslL13GetSynchEventEPKv(ptr noundef %this1)
  store ptr %call2, ptr %e, align 8
  br label %do.body

do.body:                                          ; preds = %if.then
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename, align 8
  %6 = load ptr, ptr %e, align 8
  %cmp3 = icmp eq ptr %6, null
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %do.body
  br label %cond.end

cond.false:                                       ; preds = %do.body
  %7 = load ptr, ptr %e, align 8
  %name = getelementptr inbounds %"struct.absl::SynchEvent", ptr %7, i32 0, i32 6
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond-lvalue = phi ptr [ @.str.35, %cond.true ], [ %name, %cond.false ]
  %arraydecay = getelementptr inbounds [1 x i8], ptr %cond-lvalue, i64 0, i64 0
  call void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 2464, ptr noundef @.str.34, ptr noundef %this1, ptr noundef %arraydecay)
  br label %do.body4

do.body4:                                         ; preds = %cond.end
  unreachable

do.end:                                           ; No predecessors!
  br label %do.end5

do.end5:                                          ; preds = %do.end
  br label %if.end

if.end:                                           ; preds = %do.end5, %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  ret void
}

; Function Attrs: mustprogress uwtable
define internal noundef ptr @_ZN4abslL13GetSynchEventEPKv(ptr noundef %addr) #0 {
entry:
  %addr.addr = alloca ptr, align 8
  %h = alloca i32, align 4
  %e = alloca ptr, align 8
  store ptr %addr, ptr %addr.addr, align 8
  %0 = load ptr, ptr %addr.addr, align 8
  %1 = ptrtoint ptr %0 to i64
  %rem = urem i64 %1, 1031
  %conv = trunc i64 %rem to i32
  store i32 %conv, ptr %h, align 4
  call void @_ZN4absl13base_internal8SpinLock4LockEv(ptr noundef nonnull align 4 dereferenceable(4) @_ZN4abslL14synch_event_muE)
  %2 = load i32, ptr %h, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr inbounds [1031 x ptr], ptr @_ZN4abslL11synch_eventE, i64 0, i64 %idxprom
  %3 = load ptr, ptr %arrayidx, align 8
  store ptr %3, ptr %e, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load ptr, ptr %e, align 8
  %cmp = icmp ne ptr %4, null
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %5 = load ptr, ptr %e, align 8
  %masked_addr = getelementptr inbounds %"struct.absl::SynchEvent", ptr %5, i32 0, i32 2
  %6 = load i64, ptr %masked_addr, align 8
  %7 = load ptr, ptr %addr.addr, align 8
  %call = call noundef i64 @_ZN4absl13base_internal7HidePtrIKvEEmPT_(ptr noundef %7)
  %cmp1 = icmp ne i64 %6, %call
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %8 = phi i1 [ false, %for.cond ], [ %cmp1, %land.rhs ]
  br i1 %8, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load ptr, ptr %e, align 8
  %next = getelementptr inbounds %"struct.absl::SynchEvent", ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %next, align 8
  store ptr %10, ptr %e, align 8
  br label %for.cond, !llvm.loop !31

for.end:                                          ; preds = %land.end
  %11 = load ptr, ptr %e, align 8
  %cmp2 = icmp ne ptr %11, null
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  %12 = load ptr, ptr %e, align 8
  %refcount = getelementptr inbounds %"struct.absl::SynchEvent", ptr %12, i32 0, i32 0
  %13 = load i32, ptr %refcount, align 8
  %inc = add nsw i32 %13, 1
  store i32 %inc, ptr %refcount, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end
  call void @_ZN4absl13base_internal8SpinLock6UnlockEv(ptr noundef nonnull align 4 dereferenceable(4) @_ZN4abslL14synch_event_muE)
  %14 = load ptr, ptr %e, align 8
  ret ptr %14
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN4absl7CondVar14EnableDebugLogEPKc(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %name) #0 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %e = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %cv_ = getelementptr inbounds %"class.absl::CondVar", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %name.addr, align 8
  %call = call noundef ptr @_ZN4abslL16EnsureSynchEventEPSt6atomicIlEPKcll(ptr noundef %cv_, ptr noundef %0, i64 noundef 2, i64 noundef 1)
  store ptr %call, ptr %e, align 8
  %1 = load ptr, ptr %e, align 8
  %log = getelementptr inbounds %"struct.absl::SynchEvent", ptr %1, i32 0, i32 5
  store i8 1, ptr %log, align 8
  %2 = load ptr, ptr %e, align 8
  call void @_ZN4abslL15UnrefSynchEventEPNS_10SynchEventE(ptr noundef %2)
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN4absl7CondVar6RemoveEPNS_13base_internal14PerThreadSynchE(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %s) #0 align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr.i45 = alloca ptr, align 8
  %__i.addr.i = alloca i64, align 8
  %__m.addr.i46 = alloca i32, align 4
  %__b.i47 = alloca i32, align 4
  %.atomictmp.i48 = alloca i64, align 8
  %this.addr.i40 = alloca ptr, align 8
  %__i1.addr.i = alloca ptr, align 8
  %__i2.addr.i = alloca i64, align 8
  %__m1.addr.i = alloca i32, align 4
  %__m2.addr.i = alloca i32, align 4
  %.atomictmp.i = alloca i64, align 8
  %cmpxchg.bool.i = alloca i8, align 1
  %this.addr.i30 = alloca ptr, align 8
  %__m.addr.i31 = alloca i32, align 4
  %__b.i32 = alloca i32, align 4
  %atomic-temp.i33 = alloca i64, align 8
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i64, align 8
  %this.addr = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %disable_rescheduling = alloca %"struct.absl::base_internal::SchedulingGuard::ScopedDisable", align 1
  %v = alloca i64, align 8
  %c = alloca i32, align 4
  %h = alloca ptr, align 8
  %w = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4absl13base_internal15SchedulingGuard13ScopedDisableC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %disable_rescheduling)
  store i32 0, ptr %c, align 4
  %cv_ = getelementptr inbounds %"class.absl::CondVar", ptr %this1, i32 0, i32 0
  store ptr %cv_, ptr %this.addr.i30, align 8
  store i32 0, ptr %__m.addr.i31, align 4
  %this1.i34 = load ptr, ptr %this.addr.i30, align 8
  %0 = load i32, ptr %__m.addr.i31, align 4
  %call.i35 = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %0, i32 noundef 65535)
  store i32 %call.i35, ptr %__b.i32, align 4
  %1 = load i32, ptr %__m.addr.i31, align 4
  switch i32 %1, label %monotonic.i38 [
    i32 1, label %acquire.i37
    i32 2, label %acquire.i37
    i32 5, label %seqcst.i36
  ]

monotonic.i38:                                    ; preds = %entry
  %2 = load atomic i64, ptr %this1.i34 monotonic, align 8
  store i64 %2, ptr %atomic-temp.i33, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit39

acquire.i37:                                      ; preds = %entry, %entry
  %3 = load atomic i64, ptr %this1.i34 acquire, align 8
  store i64 %3, ptr %atomic-temp.i33, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit39

seqcst.i36:                                       ; preds = %entry
  %4 = load atomic i64, ptr %this1.i34 seq_cst, align 8
  store i64 %4, ptr %atomic-temp.i33, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit39

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit39: ; preds = %seqcst.i36, %acquire.i37, %monotonic.i38
  %5 = load i64, ptr %atomic-temp.i33, align 8
  store i64 %5, ptr %v, align 8
  br label %for.cond

for.cond:                                         ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit, %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit39
  %6 = load i64, ptr %v, align 8
  %and = and i64 %6, 1
  %cmp = icmp eq i64 %and, 0
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %for.cond
  %cv_2 = getelementptr inbounds %"class.absl::CondVar", ptr %this1, i32 0, i32 0
  %7 = load i64, ptr %v, align 8
  %or = or i64 %7, 1
  store ptr %cv_2, ptr %this.addr.i40, align 8
  store ptr %v, ptr %__i1.addr.i, align 8
  store i64 %or, ptr %__i2.addr.i, align 8
  store i32 2, ptr %__m1.addr.i, align 4
  store i32 0, ptr %__m2.addr.i, align 4
  %this1.i41 = load ptr, ptr %this.addr.i40, align 8
  %8 = load i32, ptr %__m1.addr.i, align 4
  %9 = load ptr, ptr %__i1.addr.i, align 8
  %10 = load i64, ptr %__i2.addr.i, align 8
  store i64 %10, ptr %.atomictmp.i, align 8
  %11 = load i32, ptr %__m2.addr.i, align 4
  switch i32 %8, label %monotonic.i44 [
    i32 1, label %acquire.i43
    i32 2, label %acquire.i43
    i32 3, label %release.i
    i32 4, label %acqrel.i
    i32 5, label %seqcst.i42
  ]

monotonic.i44:                                    ; preds = %land.lhs.true
  switch i32 %11, label %monotonic_fail.i [
    i32 1, label %acquire_fail.i
    i32 2, label %acquire_fail.i
    i32 5, label %seqcst_fail.i
  ]

acquire.i43:                                      ; preds = %land.lhs.true, %land.lhs.true
  switch i32 %11, label %monotonic_fail9.i [
    i32 1, label %acquire_fail10.i
    i32 2, label %acquire_fail10.i
    i32 5, label %seqcst_fail11.i
  ]

release.i:                                        ; preds = %land.lhs.true
  switch i32 %11, label %monotonic_fail22.i [
    i32 1, label %acquire_fail23.i
    i32 2, label %acquire_fail23.i
    i32 5, label %seqcst_fail24.i
  ]

acqrel.i:                                         ; preds = %land.lhs.true
  switch i32 %11, label %monotonic_fail35.i [
    i32 1, label %acquire_fail36.i
    i32 2, label %acquire_fail36.i
    i32 5, label %seqcst_fail37.i
  ]

seqcst.i42:                                       ; preds = %land.lhs.true
  switch i32 %11, label %monotonic_fail48.i [
    i32 1, label %acquire_fail49.i
    i32 2, label %acquire_fail49.i
    i32 5, label %seqcst_fail50.i
  ]

monotonic_fail.i:                                 ; preds = %monotonic.i44
  %12 = load i64, ptr %9, align 8
  %13 = load i64, ptr %.atomictmp.i, align 8
  %14 = cmpxchg ptr %this1.i41, i64 %12, i64 %13 monotonic monotonic, align 8
  %15 = extractvalue { i64, i1 } %14, 0
  %16 = extractvalue { i64, i1 } %14, 1
  br i1 %16, label %cmpxchg.continue.i, label %cmpxchg.store_expected.i

acquire_fail.i:                                   ; preds = %monotonic.i44, %monotonic.i44
  %17 = load i64, ptr %9, align 8
  %18 = load i64, ptr %.atomictmp.i, align 8
  %19 = cmpxchg ptr %this1.i41, i64 %17, i64 %18 monotonic acquire, align 8
  %20 = extractvalue { i64, i1 } %19, 0
  %21 = extractvalue { i64, i1 } %19, 1
  br i1 %21, label %cmpxchg.continue4.i, label %cmpxchg.store_expected3.i

seqcst_fail.i:                                    ; preds = %monotonic.i44
  %22 = load i64, ptr %9, align 8
  %23 = load i64, ptr %.atomictmp.i, align 8
  %24 = cmpxchg ptr %this1.i41, i64 %22, i64 %23 monotonic seq_cst, align 8
  %25 = extractvalue { i64, i1 } %24, 0
  %26 = extractvalue { i64, i1 } %24, 1
  br i1 %26, label %cmpxchg.continue7.i, label %cmpxchg.store_expected6.i

atomic.continue2.i:                               ; preds = %cmpxchg.continue7.i, %cmpxchg.continue4.i, %cmpxchg.continue.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected.i:                         ; preds = %monotonic_fail.i
  store i64 %15, ptr %9, align 8
  br label %cmpxchg.continue.i

cmpxchg.continue.i:                               ; preds = %cmpxchg.store_expected.i, %monotonic_fail.i
  %frombool.i = zext i1 %16 to i8
  store i8 %frombool.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected3.i:                        ; preds = %acquire_fail.i
  store i64 %20, ptr %9, align 8
  br label %cmpxchg.continue4.i

cmpxchg.continue4.i:                              ; preds = %cmpxchg.store_expected3.i, %acquire_fail.i
  %frombool5.i = zext i1 %21 to i8
  store i8 %frombool5.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected6.i:                        ; preds = %seqcst_fail.i
  store i64 %25, ptr %9, align 8
  br label %cmpxchg.continue7.i

cmpxchg.continue7.i:                              ; preds = %cmpxchg.store_expected6.i, %seqcst_fail.i
  %frombool8.i = zext i1 %26 to i8
  store i8 %frombool8.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

monotonic_fail9.i:                                ; preds = %acquire.i43
  %27 = load i64, ptr %9, align 8
  %28 = load i64, ptr %.atomictmp.i, align 8
  %29 = cmpxchg ptr %this1.i41, i64 %27, i64 %28 acquire monotonic, align 8
  %30 = extractvalue { i64, i1 } %29, 0
  %31 = extractvalue { i64, i1 } %29, 1
  br i1 %31, label %cmpxchg.continue14.i, label %cmpxchg.store_expected13.i

acquire_fail10.i:                                 ; preds = %acquire.i43, %acquire.i43
  %32 = load i64, ptr %9, align 8
  %33 = load i64, ptr %.atomictmp.i, align 8
  %34 = cmpxchg ptr %this1.i41, i64 %32, i64 %33 acquire acquire, align 8
  %35 = extractvalue { i64, i1 } %34, 0
  %36 = extractvalue { i64, i1 } %34, 1
  br i1 %36, label %cmpxchg.continue17.i, label %cmpxchg.store_expected16.i

seqcst_fail11.i:                                  ; preds = %acquire.i43
  %37 = load i64, ptr %9, align 8
  %38 = load i64, ptr %.atomictmp.i, align 8
  %39 = cmpxchg ptr %this1.i41, i64 %37, i64 %38 acquire seq_cst, align 8
  %40 = extractvalue { i64, i1 } %39, 0
  %41 = extractvalue { i64, i1 } %39, 1
  br i1 %41, label %cmpxchg.continue20.i, label %cmpxchg.store_expected19.i

atomic.continue12.i:                              ; preds = %cmpxchg.continue20.i, %cmpxchg.continue17.i, %cmpxchg.continue14.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected13.i:                       ; preds = %monotonic_fail9.i
  store i64 %30, ptr %9, align 8
  br label %cmpxchg.continue14.i

cmpxchg.continue14.i:                             ; preds = %cmpxchg.store_expected13.i, %monotonic_fail9.i
  %frombool15.i = zext i1 %31 to i8
  store i8 %frombool15.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected16.i:                       ; preds = %acquire_fail10.i
  store i64 %35, ptr %9, align 8
  br label %cmpxchg.continue17.i

cmpxchg.continue17.i:                             ; preds = %cmpxchg.store_expected16.i, %acquire_fail10.i
  %frombool18.i = zext i1 %36 to i8
  store i8 %frombool18.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected19.i:                       ; preds = %seqcst_fail11.i
  store i64 %40, ptr %9, align 8
  br label %cmpxchg.continue20.i

cmpxchg.continue20.i:                             ; preds = %cmpxchg.store_expected19.i, %seqcst_fail11.i
  %frombool21.i = zext i1 %41 to i8
  store i8 %frombool21.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

monotonic_fail22.i:                               ; preds = %release.i
  %42 = load i64, ptr %9, align 8
  %43 = load i64, ptr %.atomictmp.i, align 8
  %44 = cmpxchg ptr %this1.i41, i64 %42, i64 %43 release monotonic, align 8
  %45 = extractvalue { i64, i1 } %44, 0
  %46 = extractvalue { i64, i1 } %44, 1
  br i1 %46, label %cmpxchg.continue27.i, label %cmpxchg.store_expected26.i

acquire_fail23.i:                                 ; preds = %release.i, %release.i
  %47 = load i64, ptr %9, align 8
  %48 = load i64, ptr %.atomictmp.i, align 8
  %49 = cmpxchg ptr %this1.i41, i64 %47, i64 %48 release acquire, align 8
  %50 = extractvalue { i64, i1 } %49, 0
  %51 = extractvalue { i64, i1 } %49, 1
  br i1 %51, label %cmpxchg.continue30.i, label %cmpxchg.store_expected29.i

seqcst_fail24.i:                                  ; preds = %release.i
  %52 = load i64, ptr %9, align 8
  %53 = load i64, ptr %.atomictmp.i, align 8
  %54 = cmpxchg ptr %this1.i41, i64 %52, i64 %53 release seq_cst, align 8
  %55 = extractvalue { i64, i1 } %54, 0
  %56 = extractvalue { i64, i1 } %54, 1
  br i1 %56, label %cmpxchg.continue33.i, label %cmpxchg.store_expected32.i

atomic.continue25.i:                              ; preds = %cmpxchg.continue33.i, %cmpxchg.continue30.i, %cmpxchg.continue27.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected26.i:                       ; preds = %monotonic_fail22.i
  store i64 %45, ptr %9, align 8
  br label %cmpxchg.continue27.i

cmpxchg.continue27.i:                             ; preds = %cmpxchg.store_expected26.i, %monotonic_fail22.i
  %frombool28.i = zext i1 %46 to i8
  store i8 %frombool28.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected29.i:                       ; preds = %acquire_fail23.i
  store i64 %50, ptr %9, align 8
  br label %cmpxchg.continue30.i

cmpxchg.continue30.i:                             ; preds = %cmpxchg.store_expected29.i, %acquire_fail23.i
  %frombool31.i = zext i1 %51 to i8
  store i8 %frombool31.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected32.i:                       ; preds = %seqcst_fail24.i
  store i64 %55, ptr %9, align 8
  br label %cmpxchg.continue33.i

cmpxchg.continue33.i:                             ; preds = %cmpxchg.store_expected32.i, %seqcst_fail24.i
  %frombool34.i = zext i1 %56 to i8
  store i8 %frombool34.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

monotonic_fail35.i:                               ; preds = %acqrel.i
  %57 = load i64, ptr %9, align 8
  %58 = load i64, ptr %.atomictmp.i, align 8
  %59 = cmpxchg ptr %this1.i41, i64 %57, i64 %58 acq_rel monotonic, align 8
  %60 = extractvalue { i64, i1 } %59, 0
  %61 = extractvalue { i64, i1 } %59, 1
  br i1 %61, label %cmpxchg.continue40.i, label %cmpxchg.store_expected39.i

acquire_fail36.i:                                 ; preds = %acqrel.i, %acqrel.i
  %62 = load i64, ptr %9, align 8
  %63 = load i64, ptr %.atomictmp.i, align 8
  %64 = cmpxchg ptr %this1.i41, i64 %62, i64 %63 acq_rel acquire, align 8
  %65 = extractvalue { i64, i1 } %64, 0
  %66 = extractvalue { i64, i1 } %64, 1
  br i1 %66, label %cmpxchg.continue43.i, label %cmpxchg.store_expected42.i

seqcst_fail37.i:                                  ; preds = %acqrel.i
  %67 = load i64, ptr %9, align 8
  %68 = load i64, ptr %.atomictmp.i, align 8
  %69 = cmpxchg ptr %this1.i41, i64 %67, i64 %68 acq_rel seq_cst, align 8
  %70 = extractvalue { i64, i1 } %69, 0
  %71 = extractvalue { i64, i1 } %69, 1
  br i1 %71, label %cmpxchg.continue46.i, label %cmpxchg.store_expected45.i

atomic.continue38.i:                              ; preds = %cmpxchg.continue46.i, %cmpxchg.continue43.i, %cmpxchg.continue40.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected39.i:                       ; preds = %monotonic_fail35.i
  store i64 %60, ptr %9, align 8
  br label %cmpxchg.continue40.i

cmpxchg.continue40.i:                             ; preds = %cmpxchg.store_expected39.i, %monotonic_fail35.i
  %frombool41.i = zext i1 %61 to i8
  store i8 %frombool41.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected42.i:                       ; preds = %acquire_fail36.i
  store i64 %65, ptr %9, align 8
  br label %cmpxchg.continue43.i

cmpxchg.continue43.i:                             ; preds = %cmpxchg.store_expected42.i, %acquire_fail36.i
  %frombool44.i = zext i1 %66 to i8
  store i8 %frombool44.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected45.i:                       ; preds = %seqcst_fail37.i
  store i64 %70, ptr %9, align 8
  br label %cmpxchg.continue46.i

cmpxchg.continue46.i:                             ; preds = %cmpxchg.store_expected45.i, %seqcst_fail37.i
  %frombool47.i = zext i1 %71 to i8
  store i8 %frombool47.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

monotonic_fail48.i:                               ; preds = %seqcst.i42
  %72 = load i64, ptr %9, align 8
  %73 = load i64, ptr %.atomictmp.i, align 8
  %74 = cmpxchg ptr %this1.i41, i64 %72, i64 %73 seq_cst monotonic, align 8
  %75 = extractvalue { i64, i1 } %74, 0
  %76 = extractvalue { i64, i1 } %74, 1
  br i1 %76, label %cmpxchg.continue53.i, label %cmpxchg.store_expected52.i

acquire_fail49.i:                                 ; preds = %seqcst.i42, %seqcst.i42
  %77 = load i64, ptr %9, align 8
  %78 = load i64, ptr %.atomictmp.i, align 8
  %79 = cmpxchg ptr %this1.i41, i64 %77, i64 %78 seq_cst acquire, align 8
  %80 = extractvalue { i64, i1 } %79, 0
  %81 = extractvalue { i64, i1 } %79, 1
  br i1 %81, label %cmpxchg.continue56.i, label %cmpxchg.store_expected55.i

seqcst_fail50.i:                                  ; preds = %seqcst.i42
  %82 = load i64, ptr %9, align 8
  %83 = load i64, ptr %.atomictmp.i, align 8
  %84 = cmpxchg ptr %this1.i41, i64 %82, i64 %83 seq_cst seq_cst, align 8
  %85 = extractvalue { i64, i1 } %84, 0
  %86 = extractvalue { i64, i1 } %84, 1
  br i1 %86, label %cmpxchg.continue59.i, label %cmpxchg.store_expected58.i

atomic.continue51.i:                              ; preds = %cmpxchg.continue59.i, %cmpxchg.continue56.i, %cmpxchg.continue53.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected52.i:                       ; preds = %monotonic_fail48.i
  store i64 %75, ptr %9, align 8
  br label %cmpxchg.continue53.i

cmpxchg.continue53.i:                             ; preds = %cmpxchg.store_expected52.i, %monotonic_fail48.i
  %frombool54.i = zext i1 %76 to i8
  store i8 %frombool54.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected55.i:                       ; preds = %acquire_fail49.i
  store i64 %80, ptr %9, align 8
  br label %cmpxchg.continue56.i

cmpxchg.continue56.i:                             ; preds = %cmpxchg.store_expected55.i, %acquire_fail49.i
  %frombool57.i = zext i1 %81 to i8
  store i8 %frombool57.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected58.i:                       ; preds = %seqcst_fail50.i
  store i64 %85, ptr %9, align 8
  br label %cmpxchg.continue59.i

cmpxchg.continue59.i:                             ; preds = %cmpxchg.store_expected58.i, %seqcst_fail50.i
  %frombool60.i = zext i1 %86 to i8
  store i8 %frombool60.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit: ; preds = %atomic.continue51.i, %atomic.continue38.i, %atomic.continue25.i, %atomic.continue12.i, %atomic.continue2.i
  %87 = load i8, ptr %cmpxchg.bool.i, align 1
  %tobool.i = trunc i8 %87 to i1
  br i1 %tobool.i, label %if.then, label %if.else

if.then:                                          ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit
  %88 = load i64, ptr %v, align 8
  %and4 = and i64 %88, -4
  %89 = inttoptr i64 %and4 to ptr
  store ptr %89, ptr %h, align 8
  %90 = load ptr, ptr %h, align 8
  %cmp5 = icmp ne ptr %90, null
  br i1 %cmp5, label %if.then6, label %if.end21

if.then6:                                         ; preds = %if.then
  %91 = load ptr, ptr %h, align 8
  store ptr %91, ptr %w, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then6
  %92 = load ptr, ptr %w, align 8
  %next = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %92, i32 0, i32 0
  %93 = load ptr, ptr %next, align 8
  %94 = load ptr, ptr %s.addr, align 8
  %cmp7 = icmp ne ptr %93, %94
  br i1 %cmp7, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %95 = load ptr, ptr %w, align 8
  %next8 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %95, i32 0, i32 0
  %96 = load ptr, ptr %next8, align 8
  %97 = load ptr, ptr %h, align 8
  %cmp9 = icmp ne ptr %96, %97
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %98 = phi i1 [ false, %while.cond ], [ %cmp9, %land.rhs ]
  br i1 %98, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %99 = load ptr, ptr %w, align 8
  %next10 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %99, i32 0, i32 0
  %100 = load ptr, ptr %next10, align 8
  store ptr %100, ptr %w, align 8
  br label %while.cond, !llvm.loop !32

while.end:                                        ; preds = %land.end
  %101 = load ptr, ptr %w, align 8
  %next11 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %101, i32 0, i32 0
  %102 = load ptr, ptr %next11, align 8
  %103 = load ptr, ptr %s.addr, align 8
  %cmp12 = icmp eq ptr %102, %103
  br i1 %cmp12, label %if.then13, label %if.end20

if.then13:                                        ; preds = %while.end
  %104 = load ptr, ptr %s.addr, align 8
  %next14 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %104, i32 0, i32 0
  %105 = load ptr, ptr %next14, align 8
  %106 = load ptr, ptr %w, align 8
  %next15 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %106, i32 0, i32 0
  store ptr %105, ptr %next15, align 8
  %107 = load ptr, ptr %h, align 8
  %108 = load ptr, ptr %s.addr, align 8
  %cmp16 = icmp eq ptr %107, %108
  br i1 %cmp16, label %if.then17, label %if.end

if.then17:                                        ; preds = %if.then13
  %109 = load ptr, ptr %w, align 8
  %110 = load ptr, ptr %s.addr, align 8
  %cmp18 = icmp eq ptr %109, %110
  br i1 %cmp18, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then17
  br label %cond.end

cond.false:                                       ; preds = %if.then17
  %111 = load ptr, ptr %w, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ null, %cond.true ], [ %111, %cond.false ]
  store ptr %cond, ptr %h, align 8
  br label %if.end

if.end:                                           ; preds = %cond.end, %if.then13
  %112 = load ptr, ptr %s.addr, align 8
  %next19 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %112, i32 0, i32 0
  store ptr null, ptr %next19, align 8
  %113 = load ptr, ptr %s.addr, align 8
  %state = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %113, i32 0, i32 8
  call void @_ZNSt6atomicIN4absl13base_internal14PerThreadSynch5StateEE5storeES3_St12memory_order(ptr noundef nonnull align 4 dereferenceable(4) %state, i32 noundef 0, i32 noundef 3) #13
  br label %if.end20

if.end20:                                         ; preds = %if.end, %while.end
  br label %if.end21

if.end21:                                         ; preds = %if.end20, %if.then
  %cv_22 = getelementptr inbounds %"class.absl::CondVar", ptr %this1, i32 0, i32 0
  %114 = load i64, ptr %v, align 8
  %and23 = and i64 %114, 2
  %115 = load ptr, ptr %h, align 8
  %116 = ptrtoint ptr %115 to i64
  %or24 = or i64 %and23, %116
  store ptr %cv_22, ptr %this.addr.i45, align 8
  store i64 %or24, ptr %__i.addr.i, align 8
  store i32 3, ptr %__m.addr.i46, align 4
  %this1.i49 = load ptr, ptr %this.addr.i45, align 8
  %117 = load i32, ptr %__m.addr.i46, align 4
  %call.i50 = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %117, i32 noundef 65535)
  store i32 %call.i50, ptr %__b.i47, align 4
  %118 = load i32, ptr %__m.addr.i46, align 4
  %119 = load i64, ptr %__i.addr.i, align 8
  store i64 %119, ptr %.atomictmp.i48, align 8
  switch i32 %118, label %monotonic.i53 [
    i32 3, label %release.i52
    i32 5, label %seqcst.i51
  ]

monotonic.i53:                                    ; preds = %if.end21
  %120 = load i64, ptr %.atomictmp.i48, align 8
  store atomic i64 %120, ptr %this1.i49 monotonic, align 8
  br label %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit

release.i52:                                      ; preds = %if.end21
  %121 = load i64, ptr %.atomictmp.i48, align 8
  store atomic i64 %121, ptr %this1.i49 release, align 8
  br label %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit

seqcst.i51:                                       ; preds = %if.end21
  %122 = load i64, ptr %.atomictmp.i48, align 8
  store atomic i64 %122, ptr %this1.i49 seq_cst, align 8
  br label %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit

_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit: ; preds = %seqcst.i51, %release.i52, %monotonic.i53
  call void @_ZN4absl13base_internal15SchedulingGuard13ScopedDisableD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %disable_rescheduling) #13
  ret void

if.else:                                          ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit, %for.cond
  %123 = load i32, ptr %c, align 4
  %call25 = invoke noundef i32 @_ZN4absl24synchronization_internal10MutexDelayEii(i32 noundef %123, i32 noundef 1)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %if.else
  store i32 %call25, ptr %c, align 4
  br label %if.end26

lpad:                                             ; preds = %if.else
  %124 = landingpad { ptr, i32 }
          cleanup
  %125 = extractvalue { ptr, i32 } %124, 0
  store ptr %125, ptr %exn.slot, align 8
  %126 = extractvalue { ptr, i32 } %124, 1
  store i32 %126, ptr %ehselector.slot, align 4
  call void @_ZN4absl13base_internal15SchedulingGuard13ScopedDisableD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %disable_rescheduling) #13
  br label %eh.resume

if.end26:                                         ; preds = %invoke.cont
  br label %for.inc

for.inc:                                          ; preds = %if.end26
  %cv_27 = getelementptr inbounds %"class.absl::CondVar", ptr %this1, i32 0, i32 0
  store ptr %cv_27, ptr %this.addr.i, align 8
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %127 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %127, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %128 = load i32, ptr %__m.addr.i, align 4
  switch i32 %128, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %for.inc
  %129 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %129, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %for.inc, %for.inc
  %130 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %130, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %for.inc
  %131 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %131, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %132 = load i64, ptr %atomic-temp.i, align 8
  store i64 %132, ptr %v, align 8
  br label %for.cond, !llvm.loop !33

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val29 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val29
}

; Function Attrs: mustprogress uwtable
define dso_local noundef zeroext i1 @_ZN4absl7CondVar10WaitCommonEPNS_5MutexENS_24synchronization_internal13KernelTimeoutE(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %mutex, i64 %t.coerce) #0 align 2 {
entry:
  %this.addr.i36 = alloca ptr, align 8
  %__m.addr.i37 = alloca i32, align 4
  %__b.i38 = alloca i32, align 4
  %atomic-temp.i39 = alloca i64, align 8
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i64, align 8
  %t = alloca %"class.absl::synchronization_internal::KernelTimeout", align 8
  %this.addr = alloca ptr, align 8
  %mutex.addr = alloca ptr, align 8
  %rc = alloca i8, align 1
  %mutex_v = alloca i64, align 8
  %mutex_how = alloca ptr, align 8
  %v = alloca i64, align 8
  %ref.tmp = alloca ptr, align 8
  %waitp = alloca %"struct.absl::SynchWaitParams", align 8
  %agg.tmp = alloca %"class.absl::synchronization_internal::KernelTimeout", align 8
  %agg.tmp11 = alloca %"class.absl::synchronization_internal::KernelTimeout", align 8
  %ref.tmp15 = alloca %"class.absl::synchronization_internal::KernelTimeout", align 8
  %absl_raw_log_internal_basename = alloca ptr, align 8
  %ref.tmp31 = alloca ptr, align 8
  %coerce.dive = getelementptr inbounds %"class.absl::synchronization_internal::KernelTimeout", ptr %t, i32 0, i32 0
  store i64 %t.coerce, ptr %coerce.dive, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %mutex, ptr %mutex.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store i8 0, ptr %rc, align 1
  %0 = load ptr, ptr %mutex.addr, align 8
  %mu_ = getelementptr inbounds %"class.absl::Mutex", ptr %0, i32 0, i32 0
  store ptr %mu_, ptr %this.addr.i36, align 8
  store i32 0, ptr %__m.addr.i37, align 4
  %this1.i40 = load ptr, ptr %this.addr.i36, align 8
  %1 = load i32, ptr %__m.addr.i37, align 4
  %call.i41 = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %1, i32 noundef 65535)
  store i32 %call.i41, ptr %__b.i38, align 4
  %2 = load i32, ptr %__m.addr.i37, align 4
  switch i32 %2, label %monotonic.i44 [
    i32 1, label %acquire.i43
    i32 2, label %acquire.i43
    i32 5, label %seqcst.i42
  ]

monotonic.i44:                                    ; preds = %entry
  %3 = load atomic i64, ptr %this1.i40 monotonic, align 8
  store i64 %3, ptr %atomic-temp.i39, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit45

acquire.i43:                                      ; preds = %entry, %entry
  %4 = load atomic i64, ptr %this1.i40 acquire, align 8
  store i64 %4, ptr %atomic-temp.i39, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit45

seqcst.i42:                                       ; preds = %entry
  %5 = load atomic i64, ptr %this1.i40 seq_cst, align 8
  store i64 %5, ptr %atomic-temp.i39, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit45

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit45: ; preds = %seqcst.i42, %acquire.i43, %monotonic.i44
  %6 = load i64, ptr %atomic-temp.i39, align 8
  store i64 %6, ptr %mutex_v, align 8
  %7 = load i64, ptr %mutex_v, align 8
  %and = and i64 %7, 8
  %cmp = icmp ne i64 %and, 0
  %cond = select i1 %cmp, ptr @_ZN4abslL11kExclusiveSE, ptr @_ZN4abslL8kSharedSE
  store ptr %cond, ptr %mutex_how, align 8
  %cv_ = getelementptr inbounds %"class.absl::CondVar", ptr %this1, i32 0, i32 0
  store ptr %cv_, ptr %this.addr.i, align 8
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %8 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %8, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %9 = load i32, ptr %__m.addr.i, align 4
  switch i32 %9, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit45
  %10 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %10, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit45, %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit45
  %11 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %11, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit45
  %12 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %12, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %13 = load i64, ptr %atomic-temp.i, align 8
  store i64 %13, ptr %v, align 8
  store ptr %this1, ptr %ref.tmp, align 8
  call void @_ZNK4absl13base_internal10AtomicHookIPFvPKcPKvEEclIJRA5_S2_PNS_7CondVarEEEEvDpOT_(ptr noundef nonnull align 8 dereferenceable(16) @_ZN4absl12_GLOBAL__N_115cond_var_tracerE, ptr noundef nonnull align 1 dereferenceable(5) @.str.37, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp)
  %14 = load i64, ptr %v, align 8
  %and3 = and i64 %14, 2
  %cmp4 = icmp ne i64 %and3, 0
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  call void @_ZN4abslL14PostSynchEventEPvi(ptr noundef %this1, i32 noundef 10)
  br label %if.end

if.end:                                           ; preds = %if.then, %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  %15 = load ptr, ptr %mutex_how, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %t, i64 8, i1 false)
  %16 = load ptr, ptr %mutex.addr, align 8
  %17 = load ptr, ptr %mutex.addr, align 8
  %call5 = call noundef ptr @_ZN4abslL27Synch_GetPerThreadAnnotatedEPNS_5MutexE(ptr noundef %17)
  %cv_6 = getelementptr inbounds %"class.absl::CondVar", ptr %this1, i32 0, i32 0
  %coerce.dive7 = getelementptr inbounds %"class.absl::synchronization_internal::KernelTimeout", ptr %agg.tmp, i32 0, i32 0
  %18 = load i64, ptr %coerce.dive7, align 8
  call void @_ZN4absl15SynchWaitParamsC2EPKNS_6MuHowSEPKNS_9ConditionENS_24synchronization_internal13KernelTimeoutEPNS_5MutexEPNS_13base_internal14PerThreadSynchEPSt6atomicIlE(ptr noundef nonnull align 8 dereferenceable(57) %waitp, ptr noundef %15, ptr noundef null, i64 %18, ptr noundef %16, ptr noundef %call5, ptr noundef %cv_6)
  %19 = load ptr, ptr %mutex.addr, align 8
  call void @_ZN4absl5Mutex10UnlockSlowEPNS_15SynchWaitParamsE(ptr noundef nonnull align 8 dereferenceable(8) %19, ptr noundef %waitp) #16
  br label %while.cond

while.cond:                                       ; preds = %if.end19, %if.end
  %thread = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %waitp, i32 0, i32 4
  %20 = load ptr, ptr %thread, align 8
  %state = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %20, i32 0, i32 8
  %call8 = call noundef i32 @_ZNKSt6atomicIN4absl13base_internal14PerThreadSynch5StateEE4loadESt12memory_order(ptr noundef nonnull align 4 dereferenceable(4) %state, i32 noundef 2) #13
  %cmp9 = icmp eq i32 %call8, 1
  br i1 %cmp9, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %21 = load ptr, ptr %mutex.addr, align 8
  %thread10 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %waitp, i32 0, i32 4
  %22 = load ptr, ptr %thread10, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp11, ptr align 8 %t, i64 8, i1 false)
  %coerce.dive12 = getelementptr inbounds %"class.absl::synchronization_internal::KernelTimeout", ptr %agg.tmp11, i32 0, i32 0
  %23 = load i64, ptr %coerce.dive12, align 8
  %call13 = call noundef zeroext i1 @_ZN4absl5Mutex17DecrementSynchSemEPS0_PNS_13base_internal14PerThreadSynchENS_24synchronization_internal13KernelTimeoutE(ptr noundef %21, ptr noundef %22, i64 %23)
  br i1 %call13, label %if.end19, label %if.then14

if.then14:                                        ; preds = %while.body
  %call16 = call i64 @_ZN4absl24synchronization_internal13KernelTimeout5NeverEv()
  %coerce.dive17 = getelementptr inbounds %"class.absl::synchronization_internal::KernelTimeout", ptr %ref.tmp15, i32 0, i32 0
  store i64 %call16, ptr %coerce.dive17, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %t, ptr align 8 %ref.tmp15, i64 8, i1 false)
  %thread18 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %waitp, i32 0, i32 4
  %24 = load ptr, ptr %thread18, align 8
  call void @_ZN4absl7CondVar6RemoveEPNS_13base_internal14PerThreadSynchE(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef %24)
  store i8 1, ptr %rc, align 1
  br label %if.end19

if.end19:                                         ; preds = %if.then14, %while.body
  br label %while.cond, !llvm.loop !34

while.end:                                        ; preds = %while.cond
  br label %do.body

do.body:                                          ; preds = %while.end
  %thread20 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %waitp, i32 0, i32 4
  %25 = load ptr, ptr %thread20, align 8
  %waitp21 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %25, i32 0, i32 9
  %26 = load ptr, ptr %waitp21, align 8
  %cmp22 = icmp ne ptr %26, null
  %lnot = xor i1 %cmp22, true
  br i1 %lnot, label %if.then23, label %if.end27

if.then23:                                        ; preds = %do.body
  br label %do.body24

do.body24:                                        ; preds = %if.then23
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename, align 8
  call void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 2629, ptr noundef @.str.1, ptr noundef @.str.38, ptr noundef @.str.39)
  br label %do.body25

do.body25:                                        ; preds = %do.body24
  unreachable

do.end:                                           ; No predecessors!
  br label %do.end26

do.end26:                                         ; preds = %do.end
  br label %if.end27

if.end27:                                         ; preds = %do.end26, %do.body
  br label %do.end28

do.end28:                                         ; preds = %if.end27
  %thread29 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %waitp, i32 0, i32 4
  %27 = load ptr, ptr %thread29, align 8
  %waitp30 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %27, i32 0, i32 9
  store ptr null, ptr %waitp30, align 8
  store ptr %this1, ptr %ref.tmp31, align 8
  call void @_ZNK4absl13base_internal10AtomicHookIPFvPKcPKvEEclIJRA7_S2_PNS_7CondVarEEEEvDpOT_(ptr noundef nonnull align 8 dereferenceable(16) @_ZN4absl12_GLOBAL__N_115cond_var_tracerE, ptr noundef nonnull align 1 dereferenceable(7) @.str.40, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp31)
  %28 = load i64, ptr %v, align 8
  %and32 = and i64 %28, 2
  %cmp33 = icmp ne i64 %and32, 0
  br i1 %cmp33, label %if.then34, label %if.end35

if.then34:                                        ; preds = %do.end28
  call void @_ZN4abslL14PostSynchEventEPvi(ptr noundef %this1, i32 noundef 11)
  br label %if.end35

if.end35:                                         ; preds = %if.then34, %do.end28
  %29 = load ptr, ptr %mutex.addr, align 8
  %30 = load ptr, ptr %mutex_how, align 8
  call void @_ZN4absl5Mutex5TransEPKNS_6MuHowSE(ptr noundef nonnull align 8 dereferenceable(8) %29, ptr noundef %30)
  %31 = load i8, ptr %rc, align 1
  %tobool = trunc i8 %31 to i1
  ret i1 %tobool
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK4absl13base_internal10AtomicHookIPFvPKcPKvEEclIJRA5_S2_PNS_7CondVarEEEEvDpOT_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 1 dereferenceable(5) %args, ptr noundef nonnull align 8 dereferenceable(8) %args1) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %args.addr2 = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store ptr %args1, ptr %args.addr2, align 8
  %this3 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZNK4absl13base_internal10AtomicHookIPFvPKcPKvEE6DoLoadEv(ptr noundef nonnull align 8 dereferenceable(16) %this3)
  %0 = load ptr, ptr %args.addr, align 8
  %arraydecay = getelementptr inbounds [5 x i8], ptr %0, i64 0, i64 0
  %1 = load ptr, ptr %args.addr2, align 8
  %2 = load ptr, ptr %1, align 8
  call void %call(ptr noundef %arraydecay, ptr noundef %2)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK4absl13base_internal10AtomicHookIPFvPKcPKvEEclIJRA7_S2_PNS_7CondVarEEEEvDpOT_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 1 dereferenceable(7) %args, ptr noundef nonnull align 8 dereferenceable(8) %args1) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %args.addr2 = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store ptr %args1, ptr %args.addr2, align 8
  %this3 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZNK4absl13base_internal10AtomicHookIPFvPKcPKvEE6DoLoadEv(ptr noundef nonnull align 8 dereferenceable(16) %this3)
  %0 = load ptr, ptr %args.addr, align 8
  %arraydecay = getelementptr inbounds [7 x i8], ptr %0, i64 0, i64 0
  %1 = load ptr, ptr %args.addr2, align 8
  %2 = load ptr, ptr %1, align 8
  call void %call(ptr noundef %arraydecay, ptr noundef %2)
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN4absl7CondVar6SignalEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr.i47 = alloca ptr, align 8
  %__i.addr.i = alloca i64, align 8
  %__m.addr.i48 = alloca i32, align 4
  %__b.i49 = alloca i32, align 4
  %.atomictmp.i50 = alloca i64, align 8
  %this.addr.i42 = alloca ptr, align 8
  %__i1.addr.i = alloca ptr, align 8
  %__i2.addr.i = alloca i64, align 8
  %__m1.addr.i = alloca i32, align 4
  %__m2.addr.i = alloca i32, align 4
  %.atomictmp.i = alloca i64, align 8
  %cmpxchg.bool.i = alloca i8, align 1
  %this.addr.i32 = alloca ptr, align 8
  %__m.addr.i33 = alloca i32, align 4
  %__b.i34 = alloca i32, align 4
  %atomic-temp.i35 = alloca i64, align 8
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i64, align 8
  %this.addr = alloca ptr, align 8
  %disable_rescheduling = alloca %"struct.absl::base_internal::SchedulingGuard::ScopedDisable", align 1
  %v = alloca i64, align 8
  %c = alloca i32, align 4
  %h = alloca ptr, align 8
  %w = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %ref.tmp = alloca ptr, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4absl13base_internal15SchedulingGuard13ScopedDisableC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %disable_rescheduling)
  store i32 0, ptr %c, align 4
  %cv_ = getelementptr inbounds %"class.absl::CondVar", ptr %this1, i32 0, i32 0
  store ptr %cv_, ptr %this.addr.i32, align 8
  store i32 0, ptr %__m.addr.i33, align 4
  %this1.i36 = load ptr, ptr %this.addr.i32, align 8
  %0 = load i32, ptr %__m.addr.i33, align 4
  %call.i37 = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %0, i32 noundef 65535)
  store i32 %call.i37, ptr %__b.i34, align 4
  %1 = load i32, ptr %__m.addr.i33, align 4
  switch i32 %1, label %monotonic.i40 [
    i32 1, label %acquire.i39
    i32 2, label %acquire.i39
    i32 5, label %seqcst.i38
  ]

monotonic.i40:                                    ; preds = %entry
  %2 = load atomic i64, ptr %this1.i36 monotonic, align 8
  store i64 %2, ptr %atomic-temp.i35, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit41

acquire.i39:                                      ; preds = %entry, %entry
  %3 = load atomic i64, ptr %this1.i36 acquire, align 8
  store i64 %3, ptr %atomic-temp.i35, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit41

seqcst.i38:                                       ; preds = %entry
  %4 = load atomic i64, ptr %this1.i36 seq_cst, align 8
  store i64 %4, ptr %atomic-temp.i35, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit41

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit41: ; preds = %seqcst.i38, %acquire.i39, %monotonic.i40
  %5 = load i64, ptr %atomic-temp.i35, align 8
  store i64 %5, ptr %v, align 8
  br label %for.cond

for.cond:                                         ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit, %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit41
  %6 = load i64, ptr %v, align 8
  %cmp = icmp ne i64 %6, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i64, ptr %v, align 8
  %and = and i64 %7, 1
  %cmp2 = icmp eq i64 %and, 0
  br i1 %cmp2, label %land.lhs.true, label %if.else25

land.lhs.true:                                    ; preds = %for.body
  %cv_3 = getelementptr inbounds %"class.absl::CondVar", ptr %this1, i32 0, i32 0
  %8 = load i64, ptr %v, align 8
  %or = or i64 %8, 1
  store ptr %cv_3, ptr %this.addr.i42, align 8
  store ptr %v, ptr %__i1.addr.i, align 8
  store i64 %or, ptr %__i2.addr.i, align 8
  store i32 2, ptr %__m1.addr.i, align 4
  store i32 0, ptr %__m2.addr.i, align 4
  %this1.i43 = load ptr, ptr %this.addr.i42, align 8
  %9 = load i32, ptr %__m1.addr.i, align 4
  %10 = load ptr, ptr %__i1.addr.i, align 8
  %11 = load i64, ptr %__i2.addr.i, align 8
  store i64 %11, ptr %.atomictmp.i, align 8
  %12 = load i32, ptr %__m2.addr.i, align 4
  switch i32 %9, label %monotonic.i46 [
    i32 1, label %acquire.i45
    i32 2, label %acquire.i45
    i32 3, label %release.i
    i32 4, label %acqrel.i
    i32 5, label %seqcst.i44
  ]

monotonic.i46:                                    ; preds = %land.lhs.true
  switch i32 %12, label %monotonic_fail.i [
    i32 1, label %acquire_fail.i
    i32 2, label %acquire_fail.i
    i32 5, label %seqcst_fail.i
  ]

acquire.i45:                                      ; preds = %land.lhs.true, %land.lhs.true
  switch i32 %12, label %monotonic_fail9.i [
    i32 1, label %acquire_fail10.i
    i32 2, label %acquire_fail10.i
    i32 5, label %seqcst_fail11.i
  ]

release.i:                                        ; preds = %land.lhs.true
  switch i32 %12, label %monotonic_fail22.i [
    i32 1, label %acquire_fail23.i
    i32 2, label %acquire_fail23.i
    i32 5, label %seqcst_fail24.i
  ]

acqrel.i:                                         ; preds = %land.lhs.true
  switch i32 %12, label %monotonic_fail35.i [
    i32 1, label %acquire_fail36.i
    i32 2, label %acquire_fail36.i
    i32 5, label %seqcst_fail37.i
  ]

seqcst.i44:                                       ; preds = %land.lhs.true
  switch i32 %12, label %monotonic_fail48.i [
    i32 1, label %acquire_fail49.i
    i32 2, label %acquire_fail49.i
    i32 5, label %seqcst_fail50.i
  ]

monotonic_fail.i:                                 ; preds = %monotonic.i46
  %13 = load i64, ptr %10, align 8
  %14 = load i64, ptr %.atomictmp.i, align 8
  %15 = cmpxchg ptr %this1.i43, i64 %13, i64 %14 monotonic monotonic, align 8
  %16 = extractvalue { i64, i1 } %15, 0
  %17 = extractvalue { i64, i1 } %15, 1
  br i1 %17, label %cmpxchg.continue.i, label %cmpxchg.store_expected.i

acquire_fail.i:                                   ; preds = %monotonic.i46, %monotonic.i46
  %18 = load i64, ptr %10, align 8
  %19 = load i64, ptr %.atomictmp.i, align 8
  %20 = cmpxchg ptr %this1.i43, i64 %18, i64 %19 monotonic acquire, align 8
  %21 = extractvalue { i64, i1 } %20, 0
  %22 = extractvalue { i64, i1 } %20, 1
  br i1 %22, label %cmpxchg.continue4.i, label %cmpxchg.store_expected3.i

seqcst_fail.i:                                    ; preds = %monotonic.i46
  %23 = load i64, ptr %10, align 8
  %24 = load i64, ptr %.atomictmp.i, align 8
  %25 = cmpxchg ptr %this1.i43, i64 %23, i64 %24 monotonic seq_cst, align 8
  %26 = extractvalue { i64, i1 } %25, 0
  %27 = extractvalue { i64, i1 } %25, 1
  br i1 %27, label %cmpxchg.continue7.i, label %cmpxchg.store_expected6.i

atomic.continue2.i:                               ; preds = %cmpxchg.continue7.i, %cmpxchg.continue4.i, %cmpxchg.continue.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected.i:                         ; preds = %monotonic_fail.i
  store i64 %16, ptr %10, align 8
  br label %cmpxchg.continue.i

cmpxchg.continue.i:                               ; preds = %cmpxchg.store_expected.i, %monotonic_fail.i
  %frombool.i = zext i1 %17 to i8
  store i8 %frombool.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected3.i:                        ; preds = %acquire_fail.i
  store i64 %21, ptr %10, align 8
  br label %cmpxchg.continue4.i

cmpxchg.continue4.i:                              ; preds = %cmpxchg.store_expected3.i, %acquire_fail.i
  %frombool5.i = zext i1 %22 to i8
  store i8 %frombool5.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected6.i:                        ; preds = %seqcst_fail.i
  store i64 %26, ptr %10, align 8
  br label %cmpxchg.continue7.i

cmpxchg.continue7.i:                              ; preds = %cmpxchg.store_expected6.i, %seqcst_fail.i
  %frombool8.i = zext i1 %27 to i8
  store i8 %frombool8.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

monotonic_fail9.i:                                ; preds = %acquire.i45
  %28 = load i64, ptr %10, align 8
  %29 = load i64, ptr %.atomictmp.i, align 8
  %30 = cmpxchg ptr %this1.i43, i64 %28, i64 %29 acquire monotonic, align 8
  %31 = extractvalue { i64, i1 } %30, 0
  %32 = extractvalue { i64, i1 } %30, 1
  br i1 %32, label %cmpxchg.continue14.i, label %cmpxchg.store_expected13.i

acquire_fail10.i:                                 ; preds = %acquire.i45, %acquire.i45
  %33 = load i64, ptr %10, align 8
  %34 = load i64, ptr %.atomictmp.i, align 8
  %35 = cmpxchg ptr %this1.i43, i64 %33, i64 %34 acquire acquire, align 8
  %36 = extractvalue { i64, i1 } %35, 0
  %37 = extractvalue { i64, i1 } %35, 1
  br i1 %37, label %cmpxchg.continue17.i, label %cmpxchg.store_expected16.i

seqcst_fail11.i:                                  ; preds = %acquire.i45
  %38 = load i64, ptr %10, align 8
  %39 = load i64, ptr %.atomictmp.i, align 8
  %40 = cmpxchg ptr %this1.i43, i64 %38, i64 %39 acquire seq_cst, align 8
  %41 = extractvalue { i64, i1 } %40, 0
  %42 = extractvalue { i64, i1 } %40, 1
  br i1 %42, label %cmpxchg.continue20.i, label %cmpxchg.store_expected19.i

atomic.continue12.i:                              ; preds = %cmpxchg.continue20.i, %cmpxchg.continue17.i, %cmpxchg.continue14.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected13.i:                       ; preds = %monotonic_fail9.i
  store i64 %31, ptr %10, align 8
  br label %cmpxchg.continue14.i

cmpxchg.continue14.i:                             ; preds = %cmpxchg.store_expected13.i, %monotonic_fail9.i
  %frombool15.i = zext i1 %32 to i8
  store i8 %frombool15.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected16.i:                       ; preds = %acquire_fail10.i
  store i64 %36, ptr %10, align 8
  br label %cmpxchg.continue17.i

cmpxchg.continue17.i:                             ; preds = %cmpxchg.store_expected16.i, %acquire_fail10.i
  %frombool18.i = zext i1 %37 to i8
  store i8 %frombool18.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected19.i:                       ; preds = %seqcst_fail11.i
  store i64 %41, ptr %10, align 8
  br label %cmpxchg.continue20.i

cmpxchg.continue20.i:                             ; preds = %cmpxchg.store_expected19.i, %seqcst_fail11.i
  %frombool21.i = zext i1 %42 to i8
  store i8 %frombool21.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

monotonic_fail22.i:                               ; preds = %release.i
  %43 = load i64, ptr %10, align 8
  %44 = load i64, ptr %.atomictmp.i, align 8
  %45 = cmpxchg ptr %this1.i43, i64 %43, i64 %44 release monotonic, align 8
  %46 = extractvalue { i64, i1 } %45, 0
  %47 = extractvalue { i64, i1 } %45, 1
  br i1 %47, label %cmpxchg.continue27.i, label %cmpxchg.store_expected26.i

acquire_fail23.i:                                 ; preds = %release.i, %release.i
  %48 = load i64, ptr %10, align 8
  %49 = load i64, ptr %.atomictmp.i, align 8
  %50 = cmpxchg ptr %this1.i43, i64 %48, i64 %49 release acquire, align 8
  %51 = extractvalue { i64, i1 } %50, 0
  %52 = extractvalue { i64, i1 } %50, 1
  br i1 %52, label %cmpxchg.continue30.i, label %cmpxchg.store_expected29.i

seqcst_fail24.i:                                  ; preds = %release.i
  %53 = load i64, ptr %10, align 8
  %54 = load i64, ptr %.atomictmp.i, align 8
  %55 = cmpxchg ptr %this1.i43, i64 %53, i64 %54 release seq_cst, align 8
  %56 = extractvalue { i64, i1 } %55, 0
  %57 = extractvalue { i64, i1 } %55, 1
  br i1 %57, label %cmpxchg.continue33.i, label %cmpxchg.store_expected32.i

atomic.continue25.i:                              ; preds = %cmpxchg.continue33.i, %cmpxchg.continue30.i, %cmpxchg.continue27.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected26.i:                       ; preds = %monotonic_fail22.i
  store i64 %46, ptr %10, align 8
  br label %cmpxchg.continue27.i

cmpxchg.continue27.i:                             ; preds = %cmpxchg.store_expected26.i, %monotonic_fail22.i
  %frombool28.i = zext i1 %47 to i8
  store i8 %frombool28.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected29.i:                       ; preds = %acquire_fail23.i
  store i64 %51, ptr %10, align 8
  br label %cmpxchg.continue30.i

cmpxchg.continue30.i:                             ; preds = %cmpxchg.store_expected29.i, %acquire_fail23.i
  %frombool31.i = zext i1 %52 to i8
  store i8 %frombool31.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected32.i:                       ; preds = %seqcst_fail24.i
  store i64 %56, ptr %10, align 8
  br label %cmpxchg.continue33.i

cmpxchg.continue33.i:                             ; preds = %cmpxchg.store_expected32.i, %seqcst_fail24.i
  %frombool34.i = zext i1 %57 to i8
  store i8 %frombool34.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

monotonic_fail35.i:                               ; preds = %acqrel.i
  %58 = load i64, ptr %10, align 8
  %59 = load i64, ptr %.atomictmp.i, align 8
  %60 = cmpxchg ptr %this1.i43, i64 %58, i64 %59 acq_rel monotonic, align 8
  %61 = extractvalue { i64, i1 } %60, 0
  %62 = extractvalue { i64, i1 } %60, 1
  br i1 %62, label %cmpxchg.continue40.i, label %cmpxchg.store_expected39.i

acquire_fail36.i:                                 ; preds = %acqrel.i, %acqrel.i
  %63 = load i64, ptr %10, align 8
  %64 = load i64, ptr %.atomictmp.i, align 8
  %65 = cmpxchg ptr %this1.i43, i64 %63, i64 %64 acq_rel acquire, align 8
  %66 = extractvalue { i64, i1 } %65, 0
  %67 = extractvalue { i64, i1 } %65, 1
  br i1 %67, label %cmpxchg.continue43.i, label %cmpxchg.store_expected42.i

seqcst_fail37.i:                                  ; preds = %acqrel.i
  %68 = load i64, ptr %10, align 8
  %69 = load i64, ptr %.atomictmp.i, align 8
  %70 = cmpxchg ptr %this1.i43, i64 %68, i64 %69 acq_rel seq_cst, align 8
  %71 = extractvalue { i64, i1 } %70, 0
  %72 = extractvalue { i64, i1 } %70, 1
  br i1 %72, label %cmpxchg.continue46.i, label %cmpxchg.store_expected45.i

atomic.continue38.i:                              ; preds = %cmpxchg.continue46.i, %cmpxchg.continue43.i, %cmpxchg.continue40.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected39.i:                       ; preds = %monotonic_fail35.i
  store i64 %61, ptr %10, align 8
  br label %cmpxchg.continue40.i

cmpxchg.continue40.i:                             ; preds = %cmpxchg.store_expected39.i, %monotonic_fail35.i
  %frombool41.i = zext i1 %62 to i8
  store i8 %frombool41.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected42.i:                       ; preds = %acquire_fail36.i
  store i64 %66, ptr %10, align 8
  br label %cmpxchg.continue43.i

cmpxchg.continue43.i:                             ; preds = %cmpxchg.store_expected42.i, %acquire_fail36.i
  %frombool44.i = zext i1 %67 to i8
  store i8 %frombool44.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected45.i:                       ; preds = %seqcst_fail37.i
  store i64 %71, ptr %10, align 8
  br label %cmpxchg.continue46.i

cmpxchg.continue46.i:                             ; preds = %cmpxchg.store_expected45.i, %seqcst_fail37.i
  %frombool47.i = zext i1 %72 to i8
  store i8 %frombool47.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

monotonic_fail48.i:                               ; preds = %seqcst.i44
  %73 = load i64, ptr %10, align 8
  %74 = load i64, ptr %.atomictmp.i, align 8
  %75 = cmpxchg ptr %this1.i43, i64 %73, i64 %74 seq_cst monotonic, align 8
  %76 = extractvalue { i64, i1 } %75, 0
  %77 = extractvalue { i64, i1 } %75, 1
  br i1 %77, label %cmpxchg.continue53.i, label %cmpxchg.store_expected52.i

acquire_fail49.i:                                 ; preds = %seqcst.i44, %seqcst.i44
  %78 = load i64, ptr %10, align 8
  %79 = load i64, ptr %.atomictmp.i, align 8
  %80 = cmpxchg ptr %this1.i43, i64 %78, i64 %79 seq_cst acquire, align 8
  %81 = extractvalue { i64, i1 } %80, 0
  %82 = extractvalue { i64, i1 } %80, 1
  br i1 %82, label %cmpxchg.continue56.i, label %cmpxchg.store_expected55.i

seqcst_fail50.i:                                  ; preds = %seqcst.i44
  %83 = load i64, ptr %10, align 8
  %84 = load i64, ptr %.atomictmp.i, align 8
  %85 = cmpxchg ptr %this1.i43, i64 %83, i64 %84 seq_cst seq_cst, align 8
  %86 = extractvalue { i64, i1 } %85, 0
  %87 = extractvalue { i64, i1 } %85, 1
  br i1 %87, label %cmpxchg.continue59.i, label %cmpxchg.store_expected58.i

atomic.continue51.i:                              ; preds = %cmpxchg.continue59.i, %cmpxchg.continue56.i, %cmpxchg.continue53.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected52.i:                       ; preds = %monotonic_fail48.i
  store i64 %76, ptr %10, align 8
  br label %cmpxchg.continue53.i

cmpxchg.continue53.i:                             ; preds = %cmpxchg.store_expected52.i, %monotonic_fail48.i
  %frombool54.i = zext i1 %77 to i8
  store i8 %frombool54.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected55.i:                       ; preds = %acquire_fail49.i
  store i64 %81, ptr %10, align 8
  br label %cmpxchg.continue56.i

cmpxchg.continue56.i:                             ; preds = %cmpxchg.store_expected55.i, %acquire_fail49.i
  %frombool57.i = zext i1 %82 to i8
  store i8 %frombool57.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected58.i:                       ; preds = %seqcst_fail50.i
  store i64 %86, ptr %10, align 8
  br label %cmpxchg.continue59.i

cmpxchg.continue59.i:                             ; preds = %cmpxchg.store_expected58.i, %seqcst_fail50.i
  %frombool60.i = zext i1 %87 to i8
  store i8 %frombool60.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit: ; preds = %atomic.continue51.i, %atomic.continue38.i, %atomic.continue25.i, %atomic.continue12.i, %atomic.continue2.i
  %88 = load i8, ptr %cmpxchg.bool.i, align 1
  %tobool.i = trunc i8 %88 to i1
  br i1 %tobool.i, label %if.then, label %if.else25

if.then:                                          ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit
  %89 = load i64, ptr %v, align 8
  %and5 = and i64 %89, -4
  %90 = inttoptr i64 %and5 to ptr
  store ptr %90, ptr %h, align 8
  store ptr null, ptr %w, align 8
  %91 = load ptr, ptr %h, align 8
  %cmp6 = icmp ne ptr %91, null
  br i1 %cmp6, label %if.then7, label %if.end12

if.then7:                                         ; preds = %if.then
  %92 = load ptr, ptr %h, align 8
  %next = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %92, i32 0, i32 0
  %93 = load ptr, ptr %next, align 8
  store ptr %93, ptr %w, align 8
  %94 = load ptr, ptr %w, align 8
  %95 = load ptr, ptr %h, align 8
  %cmp8 = icmp eq ptr %94, %95
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.then7
  store ptr null, ptr %h, align 8
  br label %if.end

if.else:                                          ; preds = %if.then7
  %96 = load ptr, ptr %w, align 8
  %next10 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %96, i32 0, i32 0
  %97 = load ptr, ptr %next10, align 8
  %98 = load ptr, ptr %h, align 8
  %next11 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %98, i32 0, i32 0
  store ptr %97, ptr %next11, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then9
  br label %if.end12

if.end12:                                         ; preds = %if.end, %if.then
  %cv_13 = getelementptr inbounds %"class.absl::CondVar", ptr %this1, i32 0, i32 0
  %99 = load i64, ptr %v, align 8
  %and14 = and i64 %99, 2
  %100 = load ptr, ptr %h, align 8
  %101 = ptrtoint ptr %100 to i64
  %or15 = or i64 %and14, %101
  store ptr %cv_13, ptr %this.addr.i47, align 8
  store i64 %or15, ptr %__i.addr.i, align 8
  store i32 3, ptr %__m.addr.i48, align 4
  %this1.i51 = load ptr, ptr %this.addr.i47, align 8
  %102 = load i32, ptr %__m.addr.i48, align 4
  %call.i52 = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %102, i32 noundef 65535)
  store i32 %call.i52, ptr %__b.i49, align 4
  %103 = load i32, ptr %__m.addr.i48, align 4
  %104 = load i64, ptr %__i.addr.i, align 8
  store i64 %104, ptr %.atomictmp.i50, align 8
  switch i32 %103, label %monotonic.i55 [
    i32 3, label %release.i54
    i32 5, label %seqcst.i53
  ]

monotonic.i55:                                    ; preds = %if.end12
  %105 = load i64, ptr %.atomictmp.i50, align 8
  store atomic i64 %105, ptr %this1.i51 monotonic, align 8
  br label %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit

release.i54:                                      ; preds = %if.end12
  %106 = load i64, ptr %.atomictmp.i50, align 8
  store atomic i64 %106, ptr %this1.i51 release, align 8
  br label %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit

seqcst.i53:                                       ; preds = %if.end12
  %107 = load i64, ptr %.atomictmp.i50, align 8
  store atomic i64 %107, ptr %this1.i51 seq_cst, align 8
  br label %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit

_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit: ; preds = %seqcst.i53, %release.i54, %monotonic.i55
  %108 = load ptr, ptr %w, align 8
  %cmp16 = icmp ne ptr %108, null
  br i1 %cmp16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit
  %109 = load ptr, ptr %w, align 8
  %waitp = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %109, i32 0, i32 9
  %110 = load ptr, ptr %waitp, align 8
  %cvmu = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %110, i32 0, i32 3
  %111 = load ptr, ptr %cvmu, align 8
  %112 = load ptr, ptr %w, align 8
  invoke void @_ZN4absl5Mutex3FerEPNS_13base_internal14PerThreadSynchE(ptr noundef nonnull align 8 dereferenceable(8) %111, ptr noundef %112)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %if.then17
  store ptr %this1, ptr %ref.tmp, align 8
  invoke void @_ZNK4absl13base_internal10AtomicHookIPFvPKcPKvEEclIJRA14_S2_PNS_7CondVarEEEEvDpOT_(ptr noundef nonnull align 8 dereferenceable(16) @_ZN4absl12_GLOBAL__N_115cond_var_tracerE, ptr noundef nonnull align 1 dereferenceable(14) @.str.41, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp)
          to label %invoke.cont18 unwind label %lpad

invoke.cont18:                                    ; preds = %invoke.cont
  br label %if.end19

lpad:                                             ; preds = %if.else25, %if.then22, %invoke.cont, %if.then17
  %113 = landingpad { ptr, i32 }
          cleanup
  %114 = extractvalue { ptr, i32 } %113, 0
  store ptr %114, ptr %exn.slot, align 8
  %115 = extractvalue { ptr, i32 } %113, 1
  store i32 %115, ptr %ehselector.slot, align 4
  call void @_ZN4absl13base_internal15SchedulingGuard13ScopedDisableD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %disable_rescheduling) #13
  br label %eh.resume

if.end19:                                         ; preds = %invoke.cont18, %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit
  %116 = load i64, ptr %v, align 8
  %and20 = and i64 %116, 2
  %cmp21 = icmp ne i64 %and20, 0
  br i1 %cmp21, label %if.then22, label %if.end24

if.then22:                                        ; preds = %if.end19
  invoke void @_ZN4abslL14PostSynchEventEPvi(ptr noundef %this1, i32 noundef 12)
          to label %invoke.cont23 unwind label %lpad

invoke.cont23:                                    ; preds = %if.then22
  br label %if.end24

if.end24:                                         ; preds = %invoke.cont23, %if.end19
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.else25:                                        ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit, %for.body
  %117 = load i32, ptr %c, align 4
  %call27 = invoke noundef i32 @_ZN4absl24synchronization_internal10MutexDelayEii(i32 noundef %117, i32 noundef 1)
          to label %invoke.cont26 unwind label %lpad

invoke.cont26:                                    ; preds = %if.else25
  store i32 %call27, ptr %c, align 4
  br label %if.end28

if.end28:                                         ; preds = %invoke.cont26
  br label %for.inc

for.inc:                                          ; preds = %if.end28
  %cv_29 = getelementptr inbounds %"class.absl::CondVar", ptr %this1, i32 0, i32 0
  store ptr %cv_29, ptr %this.addr.i, align 8
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %118 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %118, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %119 = load i32, ptr %__m.addr.i, align 4
  switch i32 %119, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %for.inc
  %120 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %120, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %for.inc, %for.inc
  %121 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %121, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %for.inc
  %122 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %122, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %123 = load i64, ptr %atomic-temp.i, align 8
  store i64 %123, ptr %v, align 8
  br label %for.cond, !llvm.loop !35

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.end24
  call void @_ZN4absl13base_internal15SchedulingGuard13ScopedDisableD2Ev(ptr noundef nonnull align 1 dereferenceable(1) %disable_rescheduling) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup, %cleanup
  ret void

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val31 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val31

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK4absl13base_internal10AtomicHookIPFvPKcPKvEEclIJRA14_S2_PNS_7CondVarEEEEvDpOT_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 1 dereferenceable(14) %args, ptr noundef nonnull align 8 dereferenceable(8) %args1) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %args.addr2 = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store ptr %args1, ptr %args.addr2, align 8
  %this3 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZNK4absl13base_internal10AtomicHookIPFvPKcPKvEE6DoLoadEv(ptr noundef nonnull align 8 dereferenceable(16) %this3)
  %0 = load ptr, ptr %args.addr, align 8
  %arraydecay = getelementptr inbounds [14 x i8], ptr %0, i64 0, i64 0
  %1 = load ptr, ptr %args.addr2, align 8
  %2 = load ptr, ptr %1, align 8
  call void %call(ptr noundef %arraydecay, ptr noundef %2)
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN4absl7CondVar9SignalAllEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 align 2 {
entry:
  %this.addr.i29 = alloca ptr, align 8
  %__i1.addr.i = alloca ptr, align 8
  %__i2.addr.i = alloca i64, align 8
  %__m1.addr.i = alloca i32, align 4
  %__m2.addr.i = alloca i32, align 4
  %.atomictmp.i = alloca i64, align 8
  %cmpxchg.bool.i = alloca i8, align 1
  %this.addr.i19 = alloca ptr, align 8
  %__m.addr.i20 = alloca i32, align 4
  %__b.i21 = alloca i32, align 4
  %atomic-temp.i22 = alloca i64, align 8
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i64, align 8
  %this.addr = alloca ptr, align 8
  %v = alloca i64, align 8
  %c = alloca i32, align 4
  %h = alloca ptr, align 8
  %w = alloca ptr, align 8
  %n = alloca ptr, align 8
  %ref.tmp = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store i32 0, ptr %c, align 4
  %cv_ = getelementptr inbounds %"class.absl::CondVar", ptr %this1, i32 0, i32 0
  store ptr %cv_, ptr %this.addr.i19, align 8
  store i32 0, ptr %__m.addr.i20, align 4
  %this1.i23 = load ptr, ptr %this.addr.i19, align 8
  %0 = load i32, ptr %__m.addr.i20, align 4
  %call.i24 = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %0, i32 noundef 65535)
  store i32 %call.i24, ptr %__b.i21, align 4
  %1 = load i32, ptr %__m.addr.i20, align 4
  switch i32 %1, label %monotonic.i27 [
    i32 1, label %acquire.i26
    i32 2, label %acquire.i26
    i32 5, label %seqcst.i25
  ]

monotonic.i27:                                    ; preds = %entry
  %2 = load atomic i64, ptr %this1.i23 monotonic, align 8
  store i64 %2, ptr %atomic-temp.i22, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit28

acquire.i26:                                      ; preds = %entry, %entry
  %3 = load atomic i64, ptr %this1.i23 acquire, align 8
  store i64 %3, ptr %atomic-temp.i22, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit28

seqcst.i25:                                       ; preds = %entry
  %4 = load atomic i64, ptr %this1.i23 seq_cst, align 8
  store i64 %4, ptr %atomic-temp.i22, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit28

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit28: ; preds = %seqcst.i25, %acquire.i26, %monotonic.i27
  %5 = load i64, ptr %atomic-temp.i22, align 8
  store i64 %5, ptr %v, align 8
  br label %for.cond

for.cond:                                         ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit, %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit28
  %6 = load i64, ptr %v, align 8
  %cmp = icmp ne i64 %6, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i64, ptr %v, align 8
  %and = and i64 %7, 1
  %cmp2 = icmp eq i64 %and, 0
  br i1 %cmp2, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %for.body
  %cv_3 = getelementptr inbounds %"class.absl::CondVar", ptr %this1, i32 0, i32 0
  %8 = load i64, ptr %v, align 8
  %and4 = and i64 %8, 2
  store ptr %cv_3, ptr %this.addr.i29, align 8
  store ptr %v, ptr %__i1.addr.i, align 8
  store i64 %and4, ptr %__i2.addr.i, align 8
  store i32 2, ptr %__m1.addr.i, align 4
  store i32 0, ptr %__m2.addr.i, align 4
  %this1.i30 = load ptr, ptr %this.addr.i29, align 8
  %9 = load i32, ptr %__m1.addr.i, align 4
  %10 = load ptr, ptr %__i1.addr.i, align 8
  %11 = load i64, ptr %__i2.addr.i, align 8
  store i64 %11, ptr %.atomictmp.i, align 8
  %12 = load i32, ptr %__m2.addr.i, align 4
  switch i32 %9, label %monotonic.i33 [
    i32 1, label %acquire.i32
    i32 2, label %acquire.i32
    i32 3, label %release.i
    i32 4, label %acqrel.i
    i32 5, label %seqcst.i31
  ]

monotonic.i33:                                    ; preds = %land.lhs.true
  switch i32 %12, label %monotonic_fail.i [
    i32 1, label %acquire_fail.i
    i32 2, label %acquire_fail.i
    i32 5, label %seqcst_fail.i
  ]

acquire.i32:                                      ; preds = %land.lhs.true, %land.lhs.true
  switch i32 %12, label %monotonic_fail9.i [
    i32 1, label %acquire_fail10.i
    i32 2, label %acquire_fail10.i
    i32 5, label %seqcst_fail11.i
  ]

release.i:                                        ; preds = %land.lhs.true
  switch i32 %12, label %monotonic_fail22.i [
    i32 1, label %acquire_fail23.i
    i32 2, label %acquire_fail23.i
    i32 5, label %seqcst_fail24.i
  ]

acqrel.i:                                         ; preds = %land.lhs.true
  switch i32 %12, label %monotonic_fail35.i [
    i32 1, label %acquire_fail36.i
    i32 2, label %acquire_fail36.i
    i32 5, label %seqcst_fail37.i
  ]

seqcst.i31:                                       ; preds = %land.lhs.true
  switch i32 %12, label %monotonic_fail48.i [
    i32 1, label %acquire_fail49.i
    i32 2, label %acquire_fail49.i
    i32 5, label %seqcst_fail50.i
  ]

monotonic_fail.i:                                 ; preds = %monotonic.i33
  %13 = load i64, ptr %10, align 8
  %14 = load i64, ptr %.atomictmp.i, align 8
  %15 = cmpxchg ptr %this1.i30, i64 %13, i64 %14 monotonic monotonic, align 8
  %16 = extractvalue { i64, i1 } %15, 0
  %17 = extractvalue { i64, i1 } %15, 1
  br i1 %17, label %cmpxchg.continue.i, label %cmpxchg.store_expected.i

acquire_fail.i:                                   ; preds = %monotonic.i33, %monotonic.i33
  %18 = load i64, ptr %10, align 8
  %19 = load i64, ptr %.atomictmp.i, align 8
  %20 = cmpxchg ptr %this1.i30, i64 %18, i64 %19 monotonic acquire, align 8
  %21 = extractvalue { i64, i1 } %20, 0
  %22 = extractvalue { i64, i1 } %20, 1
  br i1 %22, label %cmpxchg.continue4.i, label %cmpxchg.store_expected3.i

seqcst_fail.i:                                    ; preds = %monotonic.i33
  %23 = load i64, ptr %10, align 8
  %24 = load i64, ptr %.atomictmp.i, align 8
  %25 = cmpxchg ptr %this1.i30, i64 %23, i64 %24 monotonic seq_cst, align 8
  %26 = extractvalue { i64, i1 } %25, 0
  %27 = extractvalue { i64, i1 } %25, 1
  br i1 %27, label %cmpxchg.continue7.i, label %cmpxchg.store_expected6.i

atomic.continue2.i:                               ; preds = %cmpxchg.continue7.i, %cmpxchg.continue4.i, %cmpxchg.continue.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected.i:                         ; preds = %monotonic_fail.i
  store i64 %16, ptr %10, align 8
  br label %cmpxchg.continue.i

cmpxchg.continue.i:                               ; preds = %cmpxchg.store_expected.i, %monotonic_fail.i
  %frombool.i = zext i1 %17 to i8
  store i8 %frombool.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected3.i:                        ; preds = %acquire_fail.i
  store i64 %21, ptr %10, align 8
  br label %cmpxchg.continue4.i

cmpxchg.continue4.i:                              ; preds = %cmpxchg.store_expected3.i, %acquire_fail.i
  %frombool5.i = zext i1 %22 to i8
  store i8 %frombool5.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected6.i:                        ; preds = %seqcst_fail.i
  store i64 %26, ptr %10, align 8
  br label %cmpxchg.continue7.i

cmpxchg.continue7.i:                              ; preds = %cmpxchg.store_expected6.i, %seqcst_fail.i
  %frombool8.i = zext i1 %27 to i8
  store i8 %frombool8.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

monotonic_fail9.i:                                ; preds = %acquire.i32
  %28 = load i64, ptr %10, align 8
  %29 = load i64, ptr %.atomictmp.i, align 8
  %30 = cmpxchg ptr %this1.i30, i64 %28, i64 %29 acquire monotonic, align 8
  %31 = extractvalue { i64, i1 } %30, 0
  %32 = extractvalue { i64, i1 } %30, 1
  br i1 %32, label %cmpxchg.continue14.i, label %cmpxchg.store_expected13.i

acquire_fail10.i:                                 ; preds = %acquire.i32, %acquire.i32
  %33 = load i64, ptr %10, align 8
  %34 = load i64, ptr %.atomictmp.i, align 8
  %35 = cmpxchg ptr %this1.i30, i64 %33, i64 %34 acquire acquire, align 8
  %36 = extractvalue { i64, i1 } %35, 0
  %37 = extractvalue { i64, i1 } %35, 1
  br i1 %37, label %cmpxchg.continue17.i, label %cmpxchg.store_expected16.i

seqcst_fail11.i:                                  ; preds = %acquire.i32
  %38 = load i64, ptr %10, align 8
  %39 = load i64, ptr %.atomictmp.i, align 8
  %40 = cmpxchg ptr %this1.i30, i64 %38, i64 %39 acquire seq_cst, align 8
  %41 = extractvalue { i64, i1 } %40, 0
  %42 = extractvalue { i64, i1 } %40, 1
  br i1 %42, label %cmpxchg.continue20.i, label %cmpxchg.store_expected19.i

atomic.continue12.i:                              ; preds = %cmpxchg.continue20.i, %cmpxchg.continue17.i, %cmpxchg.continue14.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected13.i:                       ; preds = %monotonic_fail9.i
  store i64 %31, ptr %10, align 8
  br label %cmpxchg.continue14.i

cmpxchg.continue14.i:                             ; preds = %cmpxchg.store_expected13.i, %monotonic_fail9.i
  %frombool15.i = zext i1 %32 to i8
  store i8 %frombool15.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected16.i:                       ; preds = %acquire_fail10.i
  store i64 %36, ptr %10, align 8
  br label %cmpxchg.continue17.i

cmpxchg.continue17.i:                             ; preds = %cmpxchg.store_expected16.i, %acquire_fail10.i
  %frombool18.i = zext i1 %37 to i8
  store i8 %frombool18.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected19.i:                       ; preds = %seqcst_fail11.i
  store i64 %41, ptr %10, align 8
  br label %cmpxchg.continue20.i

cmpxchg.continue20.i:                             ; preds = %cmpxchg.store_expected19.i, %seqcst_fail11.i
  %frombool21.i = zext i1 %42 to i8
  store i8 %frombool21.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

monotonic_fail22.i:                               ; preds = %release.i
  %43 = load i64, ptr %10, align 8
  %44 = load i64, ptr %.atomictmp.i, align 8
  %45 = cmpxchg ptr %this1.i30, i64 %43, i64 %44 release monotonic, align 8
  %46 = extractvalue { i64, i1 } %45, 0
  %47 = extractvalue { i64, i1 } %45, 1
  br i1 %47, label %cmpxchg.continue27.i, label %cmpxchg.store_expected26.i

acquire_fail23.i:                                 ; preds = %release.i, %release.i
  %48 = load i64, ptr %10, align 8
  %49 = load i64, ptr %.atomictmp.i, align 8
  %50 = cmpxchg ptr %this1.i30, i64 %48, i64 %49 release acquire, align 8
  %51 = extractvalue { i64, i1 } %50, 0
  %52 = extractvalue { i64, i1 } %50, 1
  br i1 %52, label %cmpxchg.continue30.i, label %cmpxchg.store_expected29.i

seqcst_fail24.i:                                  ; preds = %release.i
  %53 = load i64, ptr %10, align 8
  %54 = load i64, ptr %.atomictmp.i, align 8
  %55 = cmpxchg ptr %this1.i30, i64 %53, i64 %54 release seq_cst, align 8
  %56 = extractvalue { i64, i1 } %55, 0
  %57 = extractvalue { i64, i1 } %55, 1
  br i1 %57, label %cmpxchg.continue33.i, label %cmpxchg.store_expected32.i

atomic.continue25.i:                              ; preds = %cmpxchg.continue33.i, %cmpxchg.continue30.i, %cmpxchg.continue27.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected26.i:                       ; preds = %monotonic_fail22.i
  store i64 %46, ptr %10, align 8
  br label %cmpxchg.continue27.i

cmpxchg.continue27.i:                             ; preds = %cmpxchg.store_expected26.i, %monotonic_fail22.i
  %frombool28.i = zext i1 %47 to i8
  store i8 %frombool28.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected29.i:                       ; preds = %acquire_fail23.i
  store i64 %51, ptr %10, align 8
  br label %cmpxchg.continue30.i

cmpxchg.continue30.i:                             ; preds = %cmpxchg.store_expected29.i, %acquire_fail23.i
  %frombool31.i = zext i1 %52 to i8
  store i8 %frombool31.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected32.i:                       ; preds = %seqcst_fail24.i
  store i64 %56, ptr %10, align 8
  br label %cmpxchg.continue33.i

cmpxchg.continue33.i:                             ; preds = %cmpxchg.store_expected32.i, %seqcst_fail24.i
  %frombool34.i = zext i1 %57 to i8
  store i8 %frombool34.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

monotonic_fail35.i:                               ; preds = %acqrel.i
  %58 = load i64, ptr %10, align 8
  %59 = load i64, ptr %.atomictmp.i, align 8
  %60 = cmpxchg ptr %this1.i30, i64 %58, i64 %59 acq_rel monotonic, align 8
  %61 = extractvalue { i64, i1 } %60, 0
  %62 = extractvalue { i64, i1 } %60, 1
  br i1 %62, label %cmpxchg.continue40.i, label %cmpxchg.store_expected39.i

acquire_fail36.i:                                 ; preds = %acqrel.i, %acqrel.i
  %63 = load i64, ptr %10, align 8
  %64 = load i64, ptr %.atomictmp.i, align 8
  %65 = cmpxchg ptr %this1.i30, i64 %63, i64 %64 acq_rel acquire, align 8
  %66 = extractvalue { i64, i1 } %65, 0
  %67 = extractvalue { i64, i1 } %65, 1
  br i1 %67, label %cmpxchg.continue43.i, label %cmpxchg.store_expected42.i

seqcst_fail37.i:                                  ; preds = %acqrel.i
  %68 = load i64, ptr %10, align 8
  %69 = load i64, ptr %.atomictmp.i, align 8
  %70 = cmpxchg ptr %this1.i30, i64 %68, i64 %69 acq_rel seq_cst, align 8
  %71 = extractvalue { i64, i1 } %70, 0
  %72 = extractvalue { i64, i1 } %70, 1
  br i1 %72, label %cmpxchg.continue46.i, label %cmpxchg.store_expected45.i

atomic.continue38.i:                              ; preds = %cmpxchg.continue46.i, %cmpxchg.continue43.i, %cmpxchg.continue40.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected39.i:                       ; preds = %monotonic_fail35.i
  store i64 %61, ptr %10, align 8
  br label %cmpxchg.continue40.i

cmpxchg.continue40.i:                             ; preds = %cmpxchg.store_expected39.i, %monotonic_fail35.i
  %frombool41.i = zext i1 %62 to i8
  store i8 %frombool41.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected42.i:                       ; preds = %acquire_fail36.i
  store i64 %66, ptr %10, align 8
  br label %cmpxchg.continue43.i

cmpxchg.continue43.i:                             ; preds = %cmpxchg.store_expected42.i, %acquire_fail36.i
  %frombool44.i = zext i1 %67 to i8
  store i8 %frombool44.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected45.i:                       ; preds = %seqcst_fail37.i
  store i64 %71, ptr %10, align 8
  br label %cmpxchg.continue46.i

cmpxchg.continue46.i:                             ; preds = %cmpxchg.store_expected45.i, %seqcst_fail37.i
  %frombool47.i = zext i1 %72 to i8
  store i8 %frombool47.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

monotonic_fail48.i:                               ; preds = %seqcst.i31
  %73 = load i64, ptr %10, align 8
  %74 = load i64, ptr %.atomictmp.i, align 8
  %75 = cmpxchg ptr %this1.i30, i64 %73, i64 %74 seq_cst monotonic, align 8
  %76 = extractvalue { i64, i1 } %75, 0
  %77 = extractvalue { i64, i1 } %75, 1
  br i1 %77, label %cmpxchg.continue53.i, label %cmpxchg.store_expected52.i

acquire_fail49.i:                                 ; preds = %seqcst.i31, %seqcst.i31
  %78 = load i64, ptr %10, align 8
  %79 = load i64, ptr %.atomictmp.i, align 8
  %80 = cmpxchg ptr %this1.i30, i64 %78, i64 %79 seq_cst acquire, align 8
  %81 = extractvalue { i64, i1 } %80, 0
  %82 = extractvalue { i64, i1 } %80, 1
  br i1 %82, label %cmpxchg.continue56.i, label %cmpxchg.store_expected55.i

seqcst_fail50.i:                                  ; preds = %seqcst.i31
  %83 = load i64, ptr %10, align 8
  %84 = load i64, ptr %.atomictmp.i, align 8
  %85 = cmpxchg ptr %this1.i30, i64 %83, i64 %84 seq_cst seq_cst, align 8
  %86 = extractvalue { i64, i1 } %85, 0
  %87 = extractvalue { i64, i1 } %85, 1
  br i1 %87, label %cmpxchg.continue59.i, label %cmpxchg.store_expected58.i

atomic.continue51.i:                              ; preds = %cmpxchg.continue59.i, %cmpxchg.continue56.i, %cmpxchg.continue53.i
  br label %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit

cmpxchg.store_expected52.i:                       ; preds = %monotonic_fail48.i
  store i64 %76, ptr %10, align 8
  br label %cmpxchg.continue53.i

cmpxchg.continue53.i:                             ; preds = %cmpxchg.store_expected52.i, %monotonic_fail48.i
  %frombool54.i = zext i1 %77 to i8
  store i8 %frombool54.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected55.i:                       ; preds = %acquire_fail49.i
  store i64 %81, ptr %10, align 8
  br label %cmpxchg.continue56.i

cmpxchg.continue56.i:                             ; preds = %cmpxchg.store_expected55.i, %acquire_fail49.i
  %frombool57.i = zext i1 %82 to i8
  store i8 %frombool57.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected58.i:                       ; preds = %seqcst_fail50.i
  store i64 %86, ptr %10, align 8
  br label %cmpxchg.continue59.i

cmpxchg.continue59.i:                             ; preds = %cmpxchg.store_expected58.i, %seqcst_fail50.i
  %frombool60.i = zext i1 %87 to i8
  store i8 %frombool60.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit: ; preds = %atomic.continue51.i, %atomic.continue38.i, %atomic.continue25.i, %atomic.continue12.i, %atomic.continue2.i
  %88 = load i8, ptr %cmpxchg.bool.i, align 1
  %tobool.i = trunc i8 %88 to i1
  br i1 %tobool.i, label %if.then, label %if.else

if.then:                                          ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit
  %89 = load i64, ptr %v, align 8
  %and6 = and i64 %89, -4
  %90 = inttoptr i64 %and6 to ptr
  store ptr %90, ptr %h, align 8
  %91 = load ptr, ptr %h, align 8
  %cmp7 = icmp ne ptr %91, null
  br i1 %cmp7, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.then
  %92 = load ptr, ptr %h, align 8
  %next = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %92, i32 0, i32 0
  %93 = load ptr, ptr %next, align 8
  store ptr %93, ptr %n, align 8
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.then8
  %94 = load ptr, ptr %n, align 8
  store ptr %94, ptr %w, align 8
  %95 = load ptr, ptr %n, align 8
  %next9 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %95, i32 0, i32 0
  %96 = load ptr, ptr %next9, align 8
  store ptr %96, ptr %n, align 8
  %97 = load ptr, ptr %w, align 8
  %waitp = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %97, i32 0, i32 9
  %98 = load ptr, ptr %waitp, align 8
  %cvmu = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %98, i32 0, i32 3
  %99 = load ptr, ptr %cvmu, align 8
  %100 = load ptr, ptr %w, align 8
  call void @_ZN4absl5Mutex3FerEPNS_13base_internal14PerThreadSynchE(ptr noundef nonnull align 8 dereferenceable(8) %99, ptr noundef %100)
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %101 = load ptr, ptr %w, align 8
  %102 = load ptr, ptr %h, align 8
  %cmp10 = icmp ne ptr %101, %102
  br i1 %cmp10, label %do.body, label %do.end, !llvm.loop !36

do.end:                                           ; preds = %do.cond
  store ptr %this1, ptr %ref.tmp, align 8
  call void @_ZNK4absl13base_internal10AtomicHookIPFvPKcPKvEEclIJRA17_S2_PNS_7CondVarEEEEvDpOT_(ptr noundef nonnull align 8 dereferenceable(16) @_ZN4absl12_GLOBAL__N_115cond_var_tracerE, ptr noundef nonnull align 1 dereferenceable(17) @.str.42, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp)
  br label %if.end

if.end:                                           ; preds = %do.end, %if.then
  %103 = load i64, ptr %v, align 8
  %and11 = and i64 %103, 2
  %cmp12 = icmp ne i64 %and11, 0
  br i1 %cmp12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end
  call void @_ZN4abslL14PostSynchEventEPvi(ptr noundef %this1, i32 noundef 13)
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end
  br label %for.end

if.else:                                          ; preds = %_ZNSt13__atomic_baseIlE23compare_exchange_strongERllSt12memory_orderS2_.exit, %for.body
  %104 = load i32, ptr %c, align 4
  %call15 = call noundef i32 @_ZN4absl24synchronization_internal10MutexDelayEii(i32 noundef %104, i32 noundef 1)
  store i32 %call15, ptr %c, align 4
  br label %if.end16

if.end16:                                         ; preds = %if.else
  br label %for.inc

for.inc:                                          ; preds = %if.end16
  %cv_17 = getelementptr inbounds %"class.absl::CondVar", ptr %this1, i32 0, i32 0
  store ptr %cv_17, ptr %this.addr.i, align 8
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %105 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %105, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %106 = load i32, ptr %__m.addr.i, align 4
  switch i32 %106, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %for.inc
  %107 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %107, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %for.inc, %for.inc
  %108 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %108, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %for.inc
  %109 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %109, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %110 = load i64, ptr %atomic-temp.i, align 8
  store i64 %110, ptr %v, align 8
  br label %for.cond, !llvm.loop !37

for.end:                                          ; preds = %if.end14, %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZNK4absl13base_internal10AtomicHookIPFvPKcPKvEEclIJRA17_S2_PNS_7CondVarEEEEvDpOT_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 1 dereferenceable(17) %args, ptr noundef nonnull align 8 dereferenceable(8) %args1) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %args.addr2 = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store ptr %args1, ptr %args.addr2, align 8
  %this3 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZNK4absl13base_internal10AtomicHookIPFvPKcPKvEE6DoLoadEv(ptr noundef nonnull align 8 dereferenceable(16) %this3)
  %0 = load ptr, ptr %args.addr, align 8
  %arraydecay = getelementptr inbounds [17 x i8], ptr %0, i64 0, i64 0
  %1 = load ptr, ptr %args.addr2, align 8
  %2 = load ptr, ptr %1, align 8
  call void %call(ptr noundef %arraydecay, ptr noundef %2)
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN4absl19ReleasableMutexLock7ReleaseEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %absl_raw_log_internal_basename = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %mu_ = getelementptr inbounds %"class.absl::ReleasableMutexLock", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mu_, align 8
  %cmp = icmp ne ptr %0, null
  %lnot = xor i1 %cmp, true
  br i1 %lnot, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  br label %do.body2

do.body2:                                         ; preds = %if.then
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename, align 8
  call void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 2728, ptr noundef @.str.1, ptr noundef @.str.43, ptr noundef @.str.44)
  br label %do.body3

do.body3:                                         ; preds = %do.body2
  unreachable

do.end:                                           ; No predecessors!
  br label %do.end4

do.end4:                                          ; preds = %do.end
  br label %if.end

if.end:                                           ; preds = %do.end4, %do.body
  br label %do.end5

do.end5:                                          ; preds = %if.end
  %mu_6 = getelementptr inbounds %"class.absl::ReleasableMutexLock", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mu_6, align 8
  call void @_ZN4absl5Mutex6UnlockEv(ptr noundef nonnull align 8 dereferenceable(8) %1)
  %mu_7 = getelementptr inbounds %"class.absl::ReleasableMutexLock", ptr %this1, i32 0, i32 0
  store ptr null, ptr %mu_7, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN4absl9Condition10AlwaysTrueEPKS0_(ptr noundef %0) #1 comdat align 2 {
entry:
  %.addr = alloca ptr, align 8
  store ptr %0, ptr %.addr, align 8
  ret i1 true
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN4absl9ConditionC2EPFbPvES1_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef %func, ptr noundef %arg) unnamed_addr #0 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %func.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %func, ptr %func.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %callback_ = getelementptr inbounds %"class.absl::Condition", ptr %this1, i32 0, i32 0
  %arrayinit.begin = getelementptr inbounds [16 x i8], ptr %callback_, i64 0, i64 0
  store i8 0, ptr %arrayinit.begin, align 1
  %arrayinit.start = getelementptr inbounds i8, ptr %arrayinit.begin, i64 1
  %arrayinit.end = getelementptr inbounds i8, ptr %arrayinit.begin, i64 16
  br label %arrayinit.body

arrayinit.body:                                   ; preds = %arrayinit.body, %entry
  %arrayinit.cur = phi ptr [ %arrayinit.start, %entry ], [ %arrayinit.next, %arrayinit.body ]
  store i8 0, ptr %arrayinit.cur, align 1
  %arrayinit.next = getelementptr inbounds i8, ptr %arrayinit.cur, i64 1
  %arrayinit.done = icmp eq ptr %arrayinit.next, %arrayinit.end
  br i1 %arrayinit.done, label %arrayinit.end2, label %arrayinit.body

arrayinit.end2:                                   ; preds = %arrayinit.body
  %eval_ = getelementptr inbounds %"class.absl::Condition", ptr %this1, i32 0, i32 1
  store ptr @_ZN4absl9Condition19CallVoidPtrFunctionEPKS0_, ptr %eval_, align 8
  %arg_ = getelementptr inbounds %"class.absl::Condition", ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %arg.addr, align 8
  store ptr %0, ptr %arg_, align 8
  %1 = load ptr, ptr %func.addr, align 8
  call void @_ZN4absl9Condition13StoreCallbackIPFbPvEEEvT_(ptr noundef nonnull align 8 dereferenceable(32) %this1, ptr noundef %1)
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local noundef zeroext i1 @_ZN4absl9Condition19CallVoidPtrFunctionEPKS0_(ptr noundef %c) #0 align 2 {
entry:
  %c.addr = alloca ptr, align 8
  %function_pointer = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %callback_ = getelementptr inbounds %"class.absl::Condition", ptr %0, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i8], ptr %callback_, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %function_pointer, ptr align 8 %arraydecay, i64 8, i1 false)
  %1 = load ptr, ptr %function_pointer, align 8
  %2 = load ptr, ptr %c.addr, align 8
  %arg_ = getelementptr inbounds %"class.absl::Condition", ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %arg_, align 8
  %call = call noundef zeroext i1 %1(ptr noundef %3)
  ret i1 %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN4absl9Condition13StoreCallbackIPFbPvEEEvT_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef %callback) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %callback.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %callback, ptr %callback.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %callback_ = getelementptr inbounds %"class.absl::Condition", ptr %this1, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i8], ptr %callback_, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay, ptr align 8 %callback.addr, i64 8, i1 false)
  ret void
}

; Function Attrs: mustprogress uwtable
define dso_local void @_ZN4absl9ConditionC2EPKb(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef %cond) unnamed_addr #0 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %cond.addr = alloca ptr, align 8
  %dereference = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %cond, ptr %cond.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %callback_ = getelementptr inbounds %"class.absl::Condition", ptr %this1, i32 0, i32 0
  %arrayinit.begin = getelementptr inbounds [16 x i8], ptr %callback_, i64 0, i64 0
  store i8 0, ptr %arrayinit.begin, align 1
  %arrayinit.start = getelementptr inbounds i8, ptr %arrayinit.begin, i64 1
  %arrayinit.end = getelementptr inbounds i8, ptr %arrayinit.begin, i64 16
  br label %arrayinit.body

arrayinit.body:                                   ; preds = %arrayinit.body, %entry
  %arrayinit.cur = phi ptr [ %arrayinit.start, %entry ], [ %arrayinit.next, %arrayinit.body ]
  store i8 0, ptr %arrayinit.cur, align 1
  %arrayinit.next = getelementptr inbounds i8, ptr %arrayinit.cur, i64 1
  %arrayinit.done = icmp eq ptr %arrayinit.next, %arrayinit.end
  br i1 %arrayinit.done, label %arrayinit.end2, label %arrayinit.body

arrayinit.end2:                                   ; preds = %arrayinit.body
  %eval_ = getelementptr inbounds %"class.absl::Condition", ptr %this1, i32 0, i32 1
  store ptr @_ZN4absl9Condition19CallVoidPtrFunctionEPKS0_, ptr %eval_, align 8
  %arg_ = getelementptr inbounds %"class.absl::Condition", ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %cond.addr, align 8
  store ptr %0, ptr %arg_, align 8
  store ptr @_ZN4abslL11DereferenceEPv, ptr %dereference, align 8
  call void @_ZN4absl9Condition13StoreCallbackIPFbPvEEEvT_(ptr noundef nonnull align 8 dereferenceable(32) %this1, ptr noundef @_ZN4abslL11DereferenceEPv)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef zeroext i1 @_ZN4abslL11DereferenceEPv(ptr noundef %arg) #1 {
entry:
  %arg.addr = alloca ptr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %1 = load i8, ptr %0, align 1
  %tobool = trunc i8 %1 to i1
  ret i1 %tobool
}

; Function Attrs: mustprogress nounwind uwtable
define dso_local noundef zeroext i1 @_ZN4absl9Condition15GuaranteedEqualEPKS0_S2_(ptr noundef %a, ptr noundef %b) #1 align 2 {
entry:
  %retval = alloca i1, align 1
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %b.addr, align 8
  %cmp1 = icmp eq ptr %1, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %2 = load ptr, ptr %a.addr, align 8
  %3 = load ptr, ptr %b.addr, align 8
  %cmp2 = icmp eq ptr %2, %3
  store i1 %cmp2, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %a.addr, align 8
  %eval_ = getelementptr inbounds %"class.absl::Condition", ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %eval_, align 8
  %6 = load ptr, ptr %b.addr, align 8
  %eval_3 = getelementptr inbounds %"class.absl::Condition", ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %eval_3, align 8
  %cmp4 = icmp eq ptr %5, %7
  br i1 %cmp4, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %if.end
  %8 = load ptr, ptr %a.addr, align 8
  %arg_ = getelementptr inbounds %"class.absl::Condition", ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %arg_, align 8
  %10 = load ptr, ptr %b.addr, align 8
  %arg_5 = getelementptr inbounds %"class.absl::Condition", ptr %10, i32 0, i32 2
  %11 = load ptr, ptr %arg_5, align 8
  %cmp6 = icmp eq ptr %9, %11
  br i1 %cmp6, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %12 = load ptr, ptr %a.addr, align 8
  %callback_ = getelementptr inbounds %"class.absl::Condition", ptr %12, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i8], ptr %callback_, i64 0, i64 0
  %13 = load ptr, ptr %b.addr, align 8
  %callback_7 = getelementptr inbounds %"class.absl::Condition", ptr %13, i32 0, i32 0
  %arraydecay8 = getelementptr inbounds [16 x i8], ptr %callback_7, i64 0, i64 0
  %call = call i32 @memcmp(ptr noundef %arraydecay, ptr noundef %arraydecay8, i64 noundef 16) #15
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %if.end
  %14 = phi i1 [ false, %land.lhs.true ], [ false, %if.end ], [ %lnot, %land.rhs ]
  store i1 %14, ptr %retval, align 1
  br label %return

return:                                           ; preds = %land.end, %if.then
  %15 = load i1, ptr %retval, align 1
  ret i1 %15
}

; Function Attrs: nounwind willreturn memory(read)
declare i32 @memcmp(ptr noundef, ptr noundef, i64 noundef) #6

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZL15__gthread_yieldv() #1 {
entry:
  %call = call i32 @sched_yield() #13
  ret i32 %call
}

; Function Attrs: noreturn nounwind uwtable
define linkonce_odr hidden void @__clang_call_terminate(ptr noundef %0) #7 comdat {
  %2 = call ptr @__cxa_begin_catch(ptr %0) #13
  call void @_ZSt9terminatev() #14
  unreachable
}

declare ptr @__cxa_begin_catch(ptr)

declare void @_ZSt9terminatev()

; Function Attrs: nounwind
declare i32 @sched_yield() #8

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN4absl13base_internal10AtomicHookIPFvlEE13DummyFunctionEl(i64 noundef %0) #1 comdat align 2 {
entry:
  %.addr = alloca i64, align 8
  store i64 %0, ptr %.addr, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN4absl13base_internal10AtomicHookIPFvPKcPKvlEE13DummyFunctionES3_S5_l(ptr noundef %0, ptr noundef %1, i64 noundef %2) #1 comdat align 2 {
entry:
  %.addr = alloca ptr, align 8
  %.addr1 = alloca ptr, align 8
  %.addr2 = alloca i64, align 8
  store ptr %0, ptr %.addr, align 8
  store ptr %1, ptr %.addr1, align 8
  store i64 %2, ptr %.addr2, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN4absl13base_internal10AtomicHookIPFvPKcPKvEE13DummyFunctionES3_S5_(ptr noundef %0, ptr noundef %1) #1 comdat align 2 {
entry:
  %.addr = alloca ptr, align 8
  %.addr1 = alloca ptr, align 8
  store ptr %0, ptr %.addr, align 8
  store ptr %1, ptr %.addr1, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define internal void @"_ZN4absl13base_internal16LowLevelCallOnceIZNS_12_GLOBAL__N_115GetMutexGlobalsEvE3$_0JEEEvPNS_9once_flagEOT_DpOT0_"(ptr noundef %flag, ptr noundef nonnull align 1 dereferenceable(1) %fn) #0 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i32, align 4
  %flag.addr = alloca ptr, align 8
  %fn.addr = alloca ptr, align 8
  %once = alloca ptr, align 8
  %s = alloca i32, align 4
  store ptr %flag, ptr %flag.addr, align 8
  store ptr %fn, ptr %fn.addr, align 8
  %0 = load ptr, ptr %flag.addr, align 8
  %call = call noundef ptr @_ZN4absl13base_internal11ControlWordEPNS_9once_flagE(ptr noundef %0)
  store ptr %call, ptr %once, align 8
  %1 = load ptr, ptr %once, align 8
  store ptr %1, ptr %this.addr.i, align 8
  store i32 2, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %2 = load i32, ptr %__m.addr.i, align 4
  %call.i = invoke noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %2, i32 noundef 65535)
          to label %invoke.cont.i unwind label %terminate.lpad.i

invoke.cont.i:                                    ; preds = %entry
  store i32 %call.i, ptr %__b.i, align 4
  %3 = load i32, ptr %__m.addr.i, align 4
  switch i32 %3, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %invoke.cont.i
  %4 = load atomic i32, ptr %this1.i monotonic, align 4
  store i32 %4, ptr %atomic-temp.i, align 4
  br label %_ZNKSt13__atomic_baseIjE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %invoke.cont.i, %invoke.cont.i
  %5 = load atomic i32, ptr %this1.i acquire, align 4
  store i32 %5, ptr %atomic-temp.i, align 4
  br label %_ZNKSt13__atomic_baseIjE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %invoke.cont.i
  %6 = load atomic i32, ptr %this1.i seq_cst, align 4
  store i32 %6, ptr %atomic-temp.i, align 4
  br label %_ZNKSt13__atomic_baseIjE4loadESt12memory_order.exit

terminate.lpad.i:                                 ; preds = %entry
  %7 = landingpad { ptr, i32 }
          catch ptr null
  %8 = extractvalue { ptr, i32 } %7, 0
  call void @__clang_call_terminate(ptr %8) #14
  unreachable

_ZNKSt13__atomic_baseIjE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %9 = load i32, ptr %atomic-temp.i, align 4
  store i32 %9, ptr %s, align 4
  %10 = load i32, ptr %s, align 4
  %cmp = icmp ne i32 %10, 221
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %_ZNKSt13__atomic_baseIjE4loadESt12memory_order.exit
  %11 = load ptr, ptr %once, align 8
  %12 = load ptr, ptr %fn.addr, align 8
  call void @"_ZN4absl13base_internal12CallOnceImplIZNS_12_GLOBAL__N_115GetMutexGlobalsEvE3$_0JEEEvPSt6atomicIjENS0_14SchedulingModeEOT_DpOT0_"(ptr noundef %11, i32 noundef 0, ptr noundef nonnull align 1 dereferenceable(1) %12)
  br label %if.end

if.end:                                           ; preds = %if.then, %_ZNKSt13__atomic_baseIjE4loadESt12memory_order.exit
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN4absl13base_internal11ControlWordEPNS_9once_flagE(ptr noundef %flag) #1 comdat {
entry:
  %flag.addr = alloca ptr, align 8
  store ptr %flag, ptr %flag.addr, align 8
  %0 = load ptr, ptr %flag.addr, align 8
  %control_ = getelementptr inbounds %"class.absl::once_flag", ptr %0, i32 0, i32 0
  ret ptr %control_
}

; Function Attrs: mustprogress uwtable
define internal void @"_ZN4absl13base_internal12CallOnceImplIZNS_12_GLOBAL__N_115GetMutexGlobalsEvE3$_0JEEEvPSt6atomicIjENS0_14SchedulingModeEOT_DpOT0_"(ptr noundef %control, i32 noundef %scheduling_mode, ptr noundef nonnull align 1 dereferenceable(1) %fn) #0 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr.i12 = alloca ptr, align 8
  %__i1.addr.i13 = alloca ptr, align 8
  %__i2.addr.i14 = alloca i32, align 4
  %__m1.addr.i = alloca i32, align 4
  %__m2.addr.i = alloca i32, align 4
  %.atomictmp.i15 = alloca i32, align 4
  %cmpxchg.bool.i = alloca i8, align 1
  %this.addr.i9 = alloca ptr, align 8
  %__i.addr.i = alloca i32, align 4
  %__m.addr.i10 = alloca i32, align 4
  %.atomictmp.i = alloca i32, align 4
  %atomic-temp.i = alloca i32, align 4
  %this.addr.i = alloca ptr, align 8
  %__i1.addr.i = alloca ptr, align 8
  %__i2.addr.i = alloca i32, align 4
  %__m.addr.i = alloca i32, align 4
  %control.addr = alloca ptr, align 8
  %scheduling_mode.addr = alloca i32, align 4
  %fn.addr = alloca ptr, align 8
  %maybe_disable_scheduling = alloca %"class.absl::base_internal::SchedulingHelper", align 4
  %old_control = alloca i32, align 4
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %control, ptr %control.addr, align 8
  store i32 %scheduling_mode, ptr %scheduling_mode.addr, align 4
  store ptr %fn, ptr %fn.addr, align 8
  %0 = load i32, ptr %scheduling_mode.addr, align 4
  call void @_ZN4absl13base_internal16SchedulingHelperC2ENS0_14SchedulingModeE(ptr noundef nonnull align 4 dereferenceable(5) %maybe_disable_scheduling, i32 noundef %0)
  store i32 0, ptr %old_control, align 4
  %1 = load ptr, ptr %control.addr, align 8
  store ptr %1, ptr %this.addr.i, align 8
  store ptr %old_control, ptr %__i1.addr.i, align 8
  store i32 1707250555, ptr %__i2.addr.i, align 4
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %2 = load ptr, ptr %__i1.addr.i, align 8
  %3 = load i32, ptr %__i2.addr.i, align 4
  %4 = load i32, ptr %__m.addr.i, align 4
  %5 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZSt23__cmpexch_failure_orderSt12memory_order(i32 noundef %5) #13
  store ptr %this1.i, ptr %this.addr.i12, align 8
  store ptr %2, ptr %__i1.addr.i13, align 8
  store i32 %3, ptr %__i2.addr.i14, align 4
  store i32 %4, ptr %__m1.addr.i, align 4
  store i32 %call.i, ptr %__m2.addr.i, align 4
  %this1.i16 = load ptr, ptr %this.addr.i12, align 8
  %6 = load i32, ptr %__m1.addr.i, align 4
  %7 = load ptr, ptr %__i1.addr.i13, align 8
  %8 = load i32, ptr %__i2.addr.i14, align 4
  store i32 %8, ptr %.atomictmp.i15, align 4
  %9 = load i32, ptr %__m2.addr.i, align 4
  switch i32 %6, label %monotonic.i21 [
    i32 1, label %acquire.i20
    i32 2, label %acquire.i20
    i32 3, label %release.i19
    i32 4, label %acqrel.i18
    i32 5, label %seqcst.i17
  ]

monotonic.i21:                                    ; preds = %entry
  switch i32 %9, label %monotonic_fail.i [
    i32 1, label %acquire_fail.i
    i32 2, label %acquire_fail.i
    i32 5, label %seqcst_fail.i
  ]

acquire.i20:                                      ; preds = %entry, %entry
  switch i32 %9, label %monotonic_fail9.i [
    i32 1, label %acquire_fail10.i
    i32 2, label %acquire_fail10.i
    i32 5, label %seqcst_fail11.i
  ]

release.i19:                                      ; preds = %entry
  switch i32 %9, label %monotonic_fail22.i [
    i32 1, label %acquire_fail23.i
    i32 2, label %acquire_fail23.i
    i32 5, label %seqcst_fail24.i
  ]

acqrel.i18:                                       ; preds = %entry
  switch i32 %9, label %monotonic_fail35.i [
    i32 1, label %acquire_fail36.i
    i32 2, label %acquire_fail36.i
    i32 5, label %seqcst_fail37.i
  ]

seqcst.i17:                                       ; preds = %entry
  switch i32 %9, label %monotonic_fail48.i [
    i32 1, label %acquire_fail49.i
    i32 2, label %acquire_fail49.i
    i32 5, label %seqcst_fail50.i
  ]

monotonic_fail.i:                                 ; preds = %monotonic.i21
  %10 = load i32, ptr %7, align 4
  %11 = load i32, ptr %.atomictmp.i15, align 4
  %12 = cmpxchg ptr %this1.i16, i32 %10, i32 %11 monotonic monotonic, align 4
  %13 = extractvalue { i32, i1 } %12, 0
  %14 = extractvalue { i32, i1 } %12, 1
  br i1 %14, label %cmpxchg.continue.i, label %cmpxchg.store_expected.i

acquire_fail.i:                                   ; preds = %monotonic.i21, %monotonic.i21
  %15 = load i32, ptr %7, align 4
  %16 = load i32, ptr %.atomictmp.i15, align 4
  %17 = cmpxchg ptr %this1.i16, i32 %15, i32 %16 monotonic acquire, align 4
  %18 = extractvalue { i32, i1 } %17, 0
  %19 = extractvalue { i32, i1 } %17, 1
  br i1 %19, label %cmpxchg.continue4.i, label %cmpxchg.store_expected3.i

seqcst_fail.i:                                    ; preds = %monotonic.i21
  %20 = load i32, ptr %7, align 4
  %21 = load i32, ptr %.atomictmp.i15, align 4
  %22 = cmpxchg ptr %this1.i16, i32 %20, i32 %21 monotonic seq_cst, align 4
  %23 = extractvalue { i32, i1 } %22, 0
  %24 = extractvalue { i32, i1 } %22, 1
  br i1 %24, label %cmpxchg.continue7.i, label %cmpxchg.store_expected6.i

atomic.continue2.i:                               ; preds = %cmpxchg.continue7.i, %cmpxchg.continue4.i, %cmpxchg.continue.i
  br label %_ZNSt13__atomic_baseIjE23compare_exchange_strongERjjSt12memory_orderS2_.exit

cmpxchg.store_expected.i:                         ; preds = %monotonic_fail.i
  store i32 %13, ptr %7, align 4
  br label %cmpxchg.continue.i

cmpxchg.continue.i:                               ; preds = %cmpxchg.store_expected.i, %monotonic_fail.i
  %frombool.i = zext i1 %14 to i8
  store i8 %frombool.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected3.i:                        ; preds = %acquire_fail.i
  store i32 %18, ptr %7, align 4
  br label %cmpxchg.continue4.i

cmpxchg.continue4.i:                              ; preds = %cmpxchg.store_expected3.i, %acquire_fail.i
  %frombool5.i = zext i1 %19 to i8
  store i8 %frombool5.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected6.i:                        ; preds = %seqcst_fail.i
  store i32 %23, ptr %7, align 4
  br label %cmpxchg.continue7.i

cmpxchg.continue7.i:                              ; preds = %cmpxchg.store_expected6.i, %seqcst_fail.i
  %frombool8.i = zext i1 %24 to i8
  store i8 %frombool8.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

monotonic_fail9.i:                                ; preds = %acquire.i20
  %25 = load i32, ptr %7, align 4
  %26 = load i32, ptr %.atomictmp.i15, align 4
  %27 = cmpxchg ptr %this1.i16, i32 %25, i32 %26 acquire monotonic, align 4
  %28 = extractvalue { i32, i1 } %27, 0
  %29 = extractvalue { i32, i1 } %27, 1
  br i1 %29, label %cmpxchg.continue14.i, label %cmpxchg.store_expected13.i

acquire_fail10.i:                                 ; preds = %acquire.i20, %acquire.i20
  %30 = load i32, ptr %7, align 4
  %31 = load i32, ptr %.atomictmp.i15, align 4
  %32 = cmpxchg ptr %this1.i16, i32 %30, i32 %31 acquire acquire, align 4
  %33 = extractvalue { i32, i1 } %32, 0
  %34 = extractvalue { i32, i1 } %32, 1
  br i1 %34, label %cmpxchg.continue17.i, label %cmpxchg.store_expected16.i

seqcst_fail11.i:                                  ; preds = %acquire.i20
  %35 = load i32, ptr %7, align 4
  %36 = load i32, ptr %.atomictmp.i15, align 4
  %37 = cmpxchg ptr %this1.i16, i32 %35, i32 %36 acquire seq_cst, align 4
  %38 = extractvalue { i32, i1 } %37, 0
  %39 = extractvalue { i32, i1 } %37, 1
  br i1 %39, label %cmpxchg.continue20.i, label %cmpxchg.store_expected19.i

atomic.continue12.i:                              ; preds = %cmpxchg.continue20.i, %cmpxchg.continue17.i, %cmpxchg.continue14.i
  br label %_ZNSt13__atomic_baseIjE23compare_exchange_strongERjjSt12memory_orderS2_.exit

cmpxchg.store_expected13.i:                       ; preds = %monotonic_fail9.i
  store i32 %28, ptr %7, align 4
  br label %cmpxchg.continue14.i

cmpxchg.continue14.i:                             ; preds = %cmpxchg.store_expected13.i, %monotonic_fail9.i
  %frombool15.i = zext i1 %29 to i8
  store i8 %frombool15.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected16.i:                       ; preds = %acquire_fail10.i
  store i32 %33, ptr %7, align 4
  br label %cmpxchg.continue17.i

cmpxchg.continue17.i:                             ; preds = %cmpxchg.store_expected16.i, %acquire_fail10.i
  %frombool18.i = zext i1 %34 to i8
  store i8 %frombool18.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected19.i:                       ; preds = %seqcst_fail11.i
  store i32 %38, ptr %7, align 4
  br label %cmpxchg.continue20.i

cmpxchg.continue20.i:                             ; preds = %cmpxchg.store_expected19.i, %seqcst_fail11.i
  %frombool21.i = zext i1 %39 to i8
  store i8 %frombool21.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

monotonic_fail22.i:                               ; preds = %release.i19
  %40 = load i32, ptr %7, align 4
  %41 = load i32, ptr %.atomictmp.i15, align 4
  %42 = cmpxchg ptr %this1.i16, i32 %40, i32 %41 release monotonic, align 4
  %43 = extractvalue { i32, i1 } %42, 0
  %44 = extractvalue { i32, i1 } %42, 1
  br i1 %44, label %cmpxchg.continue27.i, label %cmpxchg.store_expected26.i

acquire_fail23.i:                                 ; preds = %release.i19, %release.i19
  %45 = load i32, ptr %7, align 4
  %46 = load i32, ptr %.atomictmp.i15, align 4
  %47 = cmpxchg ptr %this1.i16, i32 %45, i32 %46 release acquire, align 4
  %48 = extractvalue { i32, i1 } %47, 0
  %49 = extractvalue { i32, i1 } %47, 1
  br i1 %49, label %cmpxchg.continue30.i, label %cmpxchg.store_expected29.i

seqcst_fail24.i:                                  ; preds = %release.i19
  %50 = load i32, ptr %7, align 4
  %51 = load i32, ptr %.atomictmp.i15, align 4
  %52 = cmpxchg ptr %this1.i16, i32 %50, i32 %51 release seq_cst, align 4
  %53 = extractvalue { i32, i1 } %52, 0
  %54 = extractvalue { i32, i1 } %52, 1
  br i1 %54, label %cmpxchg.continue33.i, label %cmpxchg.store_expected32.i

atomic.continue25.i:                              ; preds = %cmpxchg.continue33.i, %cmpxchg.continue30.i, %cmpxchg.continue27.i
  br label %_ZNSt13__atomic_baseIjE23compare_exchange_strongERjjSt12memory_orderS2_.exit

cmpxchg.store_expected26.i:                       ; preds = %monotonic_fail22.i
  store i32 %43, ptr %7, align 4
  br label %cmpxchg.continue27.i

cmpxchg.continue27.i:                             ; preds = %cmpxchg.store_expected26.i, %monotonic_fail22.i
  %frombool28.i = zext i1 %44 to i8
  store i8 %frombool28.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected29.i:                       ; preds = %acquire_fail23.i
  store i32 %48, ptr %7, align 4
  br label %cmpxchg.continue30.i

cmpxchg.continue30.i:                             ; preds = %cmpxchg.store_expected29.i, %acquire_fail23.i
  %frombool31.i = zext i1 %49 to i8
  store i8 %frombool31.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected32.i:                       ; preds = %seqcst_fail24.i
  store i32 %53, ptr %7, align 4
  br label %cmpxchg.continue33.i

cmpxchg.continue33.i:                             ; preds = %cmpxchg.store_expected32.i, %seqcst_fail24.i
  %frombool34.i = zext i1 %54 to i8
  store i8 %frombool34.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

monotonic_fail35.i:                               ; preds = %acqrel.i18
  %55 = load i32, ptr %7, align 4
  %56 = load i32, ptr %.atomictmp.i15, align 4
  %57 = cmpxchg ptr %this1.i16, i32 %55, i32 %56 acq_rel monotonic, align 4
  %58 = extractvalue { i32, i1 } %57, 0
  %59 = extractvalue { i32, i1 } %57, 1
  br i1 %59, label %cmpxchg.continue40.i, label %cmpxchg.store_expected39.i

acquire_fail36.i:                                 ; preds = %acqrel.i18, %acqrel.i18
  %60 = load i32, ptr %7, align 4
  %61 = load i32, ptr %.atomictmp.i15, align 4
  %62 = cmpxchg ptr %this1.i16, i32 %60, i32 %61 acq_rel acquire, align 4
  %63 = extractvalue { i32, i1 } %62, 0
  %64 = extractvalue { i32, i1 } %62, 1
  br i1 %64, label %cmpxchg.continue43.i, label %cmpxchg.store_expected42.i

seqcst_fail37.i:                                  ; preds = %acqrel.i18
  %65 = load i32, ptr %7, align 4
  %66 = load i32, ptr %.atomictmp.i15, align 4
  %67 = cmpxchg ptr %this1.i16, i32 %65, i32 %66 acq_rel seq_cst, align 4
  %68 = extractvalue { i32, i1 } %67, 0
  %69 = extractvalue { i32, i1 } %67, 1
  br i1 %69, label %cmpxchg.continue46.i, label %cmpxchg.store_expected45.i

atomic.continue38.i:                              ; preds = %cmpxchg.continue46.i, %cmpxchg.continue43.i, %cmpxchg.continue40.i
  br label %_ZNSt13__atomic_baseIjE23compare_exchange_strongERjjSt12memory_orderS2_.exit

cmpxchg.store_expected39.i:                       ; preds = %monotonic_fail35.i
  store i32 %58, ptr %7, align 4
  br label %cmpxchg.continue40.i

cmpxchg.continue40.i:                             ; preds = %cmpxchg.store_expected39.i, %monotonic_fail35.i
  %frombool41.i = zext i1 %59 to i8
  store i8 %frombool41.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected42.i:                       ; preds = %acquire_fail36.i
  store i32 %63, ptr %7, align 4
  br label %cmpxchg.continue43.i

cmpxchg.continue43.i:                             ; preds = %cmpxchg.store_expected42.i, %acquire_fail36.i
  %frombool44.i = zext i1 %64 to i8
  store i8 %frombool44.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected45.i:                       ; preds = %seqcst_fail37.i
  store i32 %68, ptr %7, align 4
  br label %cmpxchg.continue46.i

cmpxchg.continue46.i:                             ; preds = %cmpxchg.store_expected45.i, %seqcst_fail37.i
  %frombool47.i = zext i1 %69 to i8
  store i8 %frombool47.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

monotonic_fail48.i:                               ; preds = %seqcst.i17
  %70 = load i32, ptr %7, align 4
  %71 = load i32, ptr %.atomictmp.i15, align 4
  %72 = cmpxchg ptr %this1.i16, i32 %70, i32 %71 seq_cst monotonic, align 4
  %73 = extractvalue { i32, i1 } %72, 0
  %74 = extractvalue { i32, i1 } %72, 1
  br i1 %74, label %cmpxchg.continue53.i, label %cmpxchg.store_expected52.i

acquire_fail49.i:                                 ; preds = %seqcst.i17, %seqcst.i17
  %75 = load i32, ptr %7, align 4
  %76 = load i32, ptr %.atomictmp.i15, align 4
  %77 = cmpxchg ptr %this1.i16, i32 %75, i32 %76 seq_cst acquire, align 4
  %78 = extractvalue { i32, i1 } %77, 0
  %79 = extractvalue { i32, i1 } %77, 1
  br i1 %79, label %cmpxchg.continue56.i, label %cmpxchg.store_expected55.i

seqcst_fail50.i:                                  ; preds = %seqcst.i17
  %80 = load i32, ptr %7, align 4
  %81 = load i32, ptr %.atomictmp.i15, align 4
  %82 = cmpxchg ptr %this1.i16, i32 %80, i32 %81 seq_cst seq_cst, align 4
  %83 = extractvalue { i32, i1 } %82, 0
  %84 = extractvalue { i32, i1 } %82, 1
  br i1 %84, label %cmpxchg.continue59.i, label %cmpxchg.store_expected58.i

atomic.continue51.i:                              ; preds = %cmpxchg.continue59.i, %cmpxchg.continue56.i, %cmpxchg.continue53.i
  br label %_ZNSt13__atomic_baseIjE23compare_exchange_strongERjjSt12memory_orderS2_.exit

cmpxchg.store_expected52.i:                       ; preds = %monotonic_fail48.i
  store i32 %73, ptr %7, align 4
  br label %cmpxchg.continue53.i

cmpxchg.continue53.i:                             ; preds = %cmpxchg.store_expected52.i, %monotonic_fail48.i
  %frombool54.i = zext i1 %74 to i8
  store i8 %frombool54.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected55.i:                       ; preds = %acquire_fail49.i
  store i32 %78, ptr %7, align 4
  br label %cmpxchg.continue56.i

cmpxchg.continue56.i:                             ; preds = %cmpxchg.store_expected55.i, %acquire_fail49.i
  %frombool57.i = zext i1 %79 to i8
  store i8 %frombool57.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected58.i:                       ; preds = %seqcst_fail50.i
  store i32 %83, ptr %7, align 4
  br label %cmpxchg.continue59.i

cmpxchg.continue59.i:                             ; preds = %cmpxchg.store_expected58.i, %seqcst_fail50.i
  %frombool60.i = zext i1 %84 to i8
  store i8 %frombool60.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

_ZNSt13__atomic_baseIjE23compare_exchange_strongERjjSt12memory_orderS2_.exit: ; preds = %atomic.continue51.i, %atomic.continue38.i, %atomic.continue25.i, %atomic.continue12.i, %atomic.continue2.i
  %85 = load i8, ptr %cmpxchg.bool.i, align 1
  %tobool.i = trunc i8 %85 to i1
  br i1 %tobool.i, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %_ZNSt13__atomic_baseIjE23compare_exchange_strongERjjSt12memory_orderS2_.exit
  %86 = load ptr, ptr %control.addr, align 8
  %87 = load i32, ptr %scheduling_mode.addr, align 4
  %call1 = invoke noundef i32 @_ZN4absl13base_internal12SpinLockWaitEPSt6atomicIjEiPKNS0_22SpinLockWaitTransitionENS0_14SchedulingModeE(ptr noundef %86, i32 noundef 3, ptr noundef @"_ZZN4absl13base_internal12CallOnceImplIZNS_12_GLOBAL__N_115GetMutexGlobalsEvE3$_0JEEEvPSt6atomicIjENS0_14SchedulingModeEOT_DpOT0_E5trans", i32 noundef %87)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %lor.lhs.false
  %cmp = icmp eq i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %invoke.cont, %_ZNSt13__atomic_baseIjE23compare_exchange_strongERjjSt12memory_orderS2_.exit
  %88 = load ptr, ptr %fn.addr, align 8
  invoke void @"_ZSt6invokeIZN4absl12_GLOBAL__N_115GetMutexGlobalsEvE3$_0JEENSt13invoke_resultIT_JDpT0_EE4typeEOS4_DpOS5_"(ptr noundef nonnull align 1 dereferenceable(1) %88)
          to label %invoke.cont2 unwind label %lpad

invoke.cont2:                                     ; preds = %if.then
  %89 = load ptr, ptr %control.addr, align 8
  store ptr %89, ptr %this.addr.i9, align 8
  store i32 221, ptr %__i.addr.i, align 4
  store i32 3, ptr %__m.addr.i10, align 4
  %this1.i11 = load ptr, ptr %this.addr.i9, align 8
  %90 = load i32, ptr %__m.addr.i10, align 4
  %91 = load i32, ptr %__i.addr.i, align 4
  store i32 %91, ptr %.atomictmp.i, align 4
  switch i32 %90, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 3, label %release.i
    i32 4, label %acqrel.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %invoke.cont2
  %92 = load i32, ptr %.atomictmp.i, align 4
  %93 = atomicrmw xchg ptr %this1.i11, i32 %92 monotonic, align 4
  store i32 %93, ptr %atomic-temp.i, align 4
  br label %_ZNSt13__atomic_baseIjE8exchangeEjSt12memory_order.exit

acquire.i:                                        ; preds = %invoke.cont2, %invoke.cont2
  %94 = load i32, ptr %.atomictmp.i, align 4
  %95 = atomicrmw xchg ptr %this1.i11, i32 %94 acquire, align 4
  store i32 %95, ptr %atomic-temp.i, align 4
  br label %_ZNSt13__atomic_baseIjE8exchangeEjSt12memory_order.exit

release.i:                                        ; preds = %invoke.cont2
  %96 = load i32, ptr %.atomictmp.i, align 4
  %97 = atomicrmw xchg ptr %this1.i11, i32 %96 release, align 4
  store i32 %97, ptr %atomic-temp.i, align 4
  br label %_ZNSt13__atomic_baseIjE8exchangeEjSt12memory_order.exit

acqrel.i:                                         ; preds = %invoke.cont2
  %98 = load i32, ptr %.atomictmp.i, align 4
  %99 = atomicrmw xchg ptr %this1.i11, i32 %98 acq_rel, align 4
  store i32 %99, ptr %atomic-temp.i, align 4
  br label %_ZNSt13__atomic_baseIjE8exchangeEjSt12memory_order.exit

seqcst.i:                                         ; preds = %invoke.cont2
  %100 = load i32, ptr %.atomictmp.i, align 4
  %101 = atomicrmw xchg ptr %this1.i11, i32 %100 seq_cst, align 4
  store i32 %101, ptr %atomic-temp.i, align 4
  br label %_ZNSt13__atomic_baseIjE8exchangeEjSt12memory_order.exit

_ZNSt13__atomic_baseIjE8exchangeEjSt12memory_order.exit: ; preds = %seqcst.i, %acqrel.i, %release.i, %acquire.i, %monotonic.i
  %102 = load i32, ptr %atomic-temp.i, align 4
  store i32 %102, ptr %old_control, align 4
  %103 = load i32, ptr %old_control, align 4
  %cmp4 = icmp eq i32 %103, 94570706
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %_ZNSt13__atomic_baseIjE8exchangeEjSt12memory_order.exit
  %104 = load ptr, ptr %control.addr, align 8
  invoke void @_ZN4absl13base_internal12SpinLockWakeEPSt6atomicIjEb(ptr noundef %104, i1 noundef zeroext true)
          to label %invoke.cont6 unwind label %lpad

invoke.cont6:                                     ; preds = %if.then5
  br label %if.end

lpad:                                             ; preds = %if.then5, %if.then, %lor.lhs.false
  %105 = landingpad { ptr, i32 }
          cleanup
  %106 = extractvalue { ptr, i32 } %105, 0
  store ptr %106, ptr %exn.slot, align 8
  %107 = extractvalue { ptr, i32 } %105, 1
  store i32 %107, ptr %ehselector.slot, align 4
  call void @_ZN4absl13base_internal16SchedulingHelperD2Ev(ptr noundef nonnull align 4 dereferenceable(5) %maybe_disable_scheduling) #13
  br label %eh.resume

if.end:                                           ; preds = %invoke.cont6, %_ZNSt13__atomic_baseIjE8exchangeEjSt12memory_order.exit
  br label %if.end7

if.end7:                                          ; preds = %if.end, %invoke.cont
  call void @_ZN4absl13base_internal16SchedulingHelperD2Ev(ptr noundef nonnull align 4 dereferenceable(5) %maybe_disable_scheduling) #13
  ret void

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val8 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val8
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %__m, i32 noundef %__mod) #1 comdat {
entry:
  %__m.addr = alloca i32, align 4
  %__mod.addr = alloca i32, align 4
  store i32 %__m, ptr %__m.addr, align 4
  store i32 %__mod, ptr %__mod.addr, align 4
  %0 = load i32, ptr %__m.addr, align 4
  %1 = load i32, ptr %__mod.addr, align 4
  %and = and i32 %0, %1
  ret i32 %and
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN4absl13base_internal16SchedulingHelperC2ENS0_14SchedulingModeE(ptr noundef nonnull align 4 dereferenceable(5) %this, i32 noundef %mode) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %mode.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %mode, ptr %mode.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %mode_ = getelementptr inbounds %"class.absl::base_internal::SchedulingHelper", ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %mode.addr, align 4
  store i32 %0, ptr %mode_, align 4
  %guard_result_ = getelementptr inbounds %"class.absl::base_internal::SchedulingHelper", ptr %this1, i32 0, i32 1
  store i8 0, ptr %guard_result_, align 4
  %mode_2 = getelementptr inbounds %"class.absl::base_internal::SchedulingHelper", ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %mode_2, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call noundef zeroext i1 @_ZN4absl13base_internal15SchedulingGuard19DisableReschedulingEv()
  %guard_result_3 = getelementptr inbounds %"class.absl::base_internal::SchedulingHelper", ptr %this1, i32 0, i32 1
  %frombool = zext i1 %call to i8
  store i8 %frombool, ptr %guard_result_3, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare noundef i32 @_ZN4absl13base_internal12SpinLockWaitEPSt6atomicIjEiPKNS0_22SpinLockWaitTransitionENS0_14SchedulingModeE(ptr noundef, i32 noundef, ptr noundef, i32 noundef) #3

; Function Attrs: mustprogress uwtable
define internal void @"_ZSt6invokeIZN4absl12_GLOBAL__N_115GetMutexGlobalsEvE3$_0JEENSt13invoke_resultIT_JDpT0_EE4typeEOS4_DpOS5_"(ptr noundef nonnull align 1 dereferenceable(1) %__fn) #0 {
entry:
  %__fn.addr = alloca ptr, align 8
  store ptr %__fn, ptr %__fn.addr, align 8
  %0 = load ptr, ptr %__fn.addr, align 8
  call void @"_ZSt8__invokeIZN4absl12_GLOBAL__N_115GetMutexGlobalsEvE3$_0JEENSt15__invoke_resultIT_JDpT0_EE4typeEOS4_DpOS5_"(ptr noundef nonnull align 1 dereferenceable(1) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN4absl13base_internal12SpinLockWakeEPSt6atomicIjEb(ptr noundef %w, i1 noundef zeroext %all) #0 comdat {
entry:
  %w.addr = alloca ptr, align 8
  %all.addr = alloca i8, align 1
  store ptr %w, ptr %w.addr, align 8
  %frombool = zext i1 %all to i8
  store i8 %frombool, ptr %all.addr, align 1
  %0 = load ptr, ptr %w.addr, align 8
  %1 = load i8, ptr %all.addr, align 1
  %tobool = trunc i8 %1 to i1
  call void @AbslInternalSpinLockWake(ptr noundef %0, i1 noundef zeroext %tobool)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN4absl13base_internal16SchedulingHelperD2Ev(ptr noundef nonnull align 4 dereferenceable(5) %this) unnamed_addr #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mode_ = getelementptr inbounds %"class.absl::base_internal::SchedulingHelper", ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %mode_, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %guard_result_ = getelementptr inbounds %"class.absl::base_internal::SchedulingHelper", ptr %this1, i32 0, i32 1
  %1 = load i8, ptr %guard_result_, align 4
  %tobool = trunc i8 %1 to i1
  invoke void @_ZN4absl13base_internal15SchedulingGuard18EnableReschedulingEb(i1 noundef zeroext %tobool)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %invoke.cont, %entry
  ret void

terminate.lpad:                                   ; preds = %if.then
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #14
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN4absl13base_internal15SchedulingGuard19DisableReschedulingEv() #1 comdat align 2 {
entry:
  ret i1 false
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZSt23__cmpexch_failure_orderSt12memory_order(i32 noundef %__m) #1 comdat personality ptr @__gxx_personality_v0 {
entry:
  %__m.addr = alloca i32, align 4
  store i32 %__m, ptr %__m.addr, align 4
  %0 = load i32, ptr %__m.addr, align 4
  %call = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %0, i32 noundef 65535)
  %call1 = call noundef i32 @_ZSt24__cmpexch_failure_order2St12memory_order(i32 noundef %call) #13
  %1 = load i32, ptr %__m.addr, align 4
  %call2 = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %1, i32 noundef -65536)
  %call3 = invoke noundef i32 @_ZStorSt12memory_orderSt23__memory_order_modifier(i32 noundef %call1, i32 noundef %call2)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret i32 %call3

terminate.lpad:                                   ; preds = %entry
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #14
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZStorSt12memory_orderSt23__memory_order_modifier(i32 noundef %__m, i32 noundef %__mod) #1 comdat {
entry:
  %__m.addr = alloca i32, align 4
  %__mod.addr = alloca i32, align 4
  store i32 %__m, ptr %__m.addr, align 4
  store i32 %__mod, ptr %__mod.addr, align 4
  %0 = load i32, ptr %__m.addr, align 4
  %1 = load i32, ptr %__mod.addr, align 4
  %or = or i32 %0, %1
  ret i32 %or
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZSt24__cmpexch_failure_order2St12memory_order(i32 noundef %__m) #1 comdat {
entry:
  %__m.addr = alloca i32, align 4
  store i32 %__m, ptr %__m.addr, align 4
  %0 = load i32, ptr %__m.addr, align 4
  %cmp = icmp eq i32 %0, 4
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load i32, ptr %__m.addr, align 4
  %cmp1 = icmp eq i32 %1, 3
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  %2 = load i32, ptr %__m.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi i32 [ 0, %cond.true2 ], [ %2, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi i32 [ 2, %cond.true ], [ %cond, %cond.end ]
  ret i32 %cond5
}

; Function Attrs: mustprogress uwtable
define internal void @"_ZSt8__invokeIZN4absl12_GLOBAL__N_115GetMutexGlobalsEvE3$_0JEENSt15__invoke_resultIT_JDpT0_EE4typeEOS4_DpOS5_"(ptr noundef nonnull align 1 dereferenceable(1) %__fn) #0 {
entry:
  %__fn.addr = alloca ptr, align 8
  store ptr %__fn, ptr %__fn.addr, align 8
  %0 = load ptr, ptr %__fn.addr, align 8
  call void @"_ZSt13__invoke_implIvZN4absl12_GLOBAL__N_115GetMutexGlobalsEvE3$_0JEET_St14__invoke_otherOT0_DpOT1_"(ptr noundef nonnull align 1 dereferenceable(1) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define internal void @"_ZSt13__invoke_implIvZN4absl12_GLOBAL__N_115GetMutexGlobalsEvE3$_0JEET_St14__invoke_otherOT0_DpOT1_"(ptr noundef nonnull align 1 dereferenceable(1) %__f) #0 {
entry:
  %__f.addr = alloca ptr, align 8
  store ptr %__f, ptr %__f.addr, align 8
  %0 = load ptr, ptr %__f.addr, align 8
  call void @"_ZZN4absl12_GLOBAL__N_115GetMutexGlobalsEvENK3$_0clEv"(ptr noundef nonnull align 1 dereferenceable(1) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define internal void @"_ZZN4absl12_GLOBAL__N_115GetMutexGlobalsEvENK3$_0clEv"(ptr noundef nonnull align 1 dereferenceable(1) %this) #0 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.absl::Duration", align 4
  %tmp.coerce = alloca { i64, i32 }, align 8
  %ref.tmp3 = alloca %"class.absl::Duration", align 4
  %agg.tmp = alloca %"class.absl::Duration", align 4
  %tmp.coerce5 = alloca { i64, i32 }, align 8
  %agg.tmp.coerce = alloca { i64, i32 }, align 4
  %tmp.coerce7 = alloca { i64, i32 }, align 8
  %ref.tmp8 = alloca %"class.absl::Duration", align 4
  %tmp.coerce10 = alloca { i64, i32 }, align 8
  %ref.tmp12 = alloca %"class.absl::Duration", align 4
  %tmp.coerce14 = alloca { i64, i32 }, align 8
  store ptr %this, ptr %this.addr, align 8
  %call = call noundef i32 @_ZN4absl13base_internal7NumCPUsEv()
  %cmp = icmp sgt i32 %call, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 5000, ptr getelementptr inbounds (%"struct.absl::(anonymous namespace)::MutexGlobals", ptr @_ZN4absl12_GLOBAL__N_17globalsE, i32 0, i32 2), align 8
  store i32 250, ptr getelementptr inbounds (%"struct.absl::(anonymous namespace)::MutexGlobals", ptr @_ZN4absl12_GLOBAL__N_17globalsE, i32 0, i32 2, i64 1), align 4
  %call2 = call { i64, i32 } @_ZN4absl12MicrosecondsIiTnNSt9enable_ifIXoosr3std11is_integralIT_EE5valuesr3std7is_enumIS2_EE5valueEiE4typeELi0EEENS_8DurationES2_(i32 noundef 10) #17
  store { i64, i32 } %call2, ptr %tmp.coerce, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %ref.tmp, ptr align 8 %tmp.coerce, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 getelementptr inbounds (%"struct.absl::(anonymous namespace)::MutexGlobals", ptr @_ZN4absl12_GLOBAL__N_17globalsE, i32 0, i32 3), ptr align 4 %ref.tmp, i64 12, i1 false)
  br label %if.end

if.else:                                          ; preds = %entry
  store i32 0, ptr getelementptr inbounds (%"struct.absl::(anonymous namespace)::MutexGlobals", ptr @_ZN4absl12_GLOBAL__N_17globalsE, i32 0, i32 2), align 8
  store i32 0, ptr getelementptr inbounds (%"struct.absl::(anonymous namespace)::MutexGlobals", ptr @_ZN4absl12_GLOBAL__N_17globalsE, i32 0, i32 2, i64 1), align 4
  %call4 = call { i64, i32 } @_ZN4absl12_GLOBAL__N_118MeasureTimeToYieldEv()
  store { i64, i32 } %call4, ptr %tmp.coerce5, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp, ptr align 8 %tmp.coerce5, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp.coerce, ptr align 4 %agg.tmp, i64 12, i1 false)
  %0 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp.coerce, i32 0, i32 0
  %1 = load i64, ptr %0, align 4
  %2 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp.coerce, i32 0, i32 1
  %3 = load i32, ptr %2, align 4
  %call6 = call { i64, i32 } @_ZN4abslmlIiEENS_8DurationES1_T_(i64 %1, i32 %3, i32 noundef 5) #17
  store { i64, i32 } %call6, ptr %tmp.coerce7, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %ref.tmp3, ptr align 8 %tmp.coerce7, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 getelementptr inbounds (%"struct.absl::(anonymous namespace)::MutexGlobals", ptr @_ZN4absl12_GLOBAL__N_17globalsE, i32 0, i32 3), ptr align 4 %ref.tmp3, i64 12, i1 false)
  %call9 = call { i64, i32 } @_ZN4absl12MillisecondsIiTnNSt9enable_ifIXoosr3std11is_integralIT_EE5valuesr3std7is_enumIS2_EE5valueEiE4typeELi0EEENS_8DurationES2_(i32 noundef 1) #17
  store { i64, i32 } %call9, ptr %tmp.coerce10, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %ref.tmp8, ptr align 8 %tmp.coerce10, i64 12, i1 false)
  %call11 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZSt3minIN4absl8DurationEERKT_S4_S4_(ptr noundef nonnull align 4 dereferenceable(12) getelementptr inbounds (%"struct.absl::(anonymous namespace)::MutexGlobals", ptr @_ZN4absl12_GLOBAL__N_17globalsE, i32 0, i32 3), ptr noundef nonnull align 4 dereferenceable(12) %ref.tmp8)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 getelementptr inbounds (%"struct.absl::(anonymous namespace)::MutexGlobals", ptr @_ZN4absl12_GLOBAL__N_17globalsE, i32 0, i32 3), ptr align 4 %call11, i64 12, i1 false)
  %call13 = call { i64, i32 } @_ZN4absl12MicrosecondsIiTnNSt9enable_ifIXoosr3std11is_integralIT_EE5valuesr3std7is_enumIS2_EE5valueEiE4typeELi0EEENS_8DurationES2_(i32 noundef 10) #17
  store { i64, i32 } %call13, ptr %tmp.coerce14, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %ref.tmp12, ptr align 8 %tmp.coerce14, i64 12, i1 false)
  %call15 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZSt3maxIN4absl8DurationEERKT_S4_S4_(ptr noundef nonnull align 4 dereferenceable(12) getelementptr inbounds (%"struct.absl::(anonymous namespace)::MutexGlobals", ptr @_ZN4absl12_GLOBAL__N_17globalsE, i32 0, i32 3), ptr noundef nonnull align 4 dereferenceable(12) %ref.tmp12)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 getelementptr inbounds (%"struct.absl::(anonymous namespace)::MutexGlobals", ptr @_ZN4absl12_GLOBAL__N_17globalsE, i32 0, i32 3), ptr align 4 %call15, i64 12, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(none) uwtable
define linkonce_odr dso_local { i64, i32 } @_ZN4absl12MicrosecondsIiTnNSt9enable_ifIXoosr3std11is_integralIT_EE5valuesr3std7is_enumIS2_EE5valueEiE4typeELi0EEENS_8DurationES2_(i32 noundef %n) #9 comdat {
entry:
  %retval = alloca %"class.absl::Duration", align 4
  %n.addr = alloca i32, align 4
  %tmp.coerce = alloca { i64, i32 }, align 8
  %retval.coerce = alloca { i64, i32 }, align 8
  store i32 %n, ptr %n.addr, align 4
  %0 = load i32, ptr %n.addr, align 4
  %conv = sext i32 %0 to i64
  %call = call { i64, i32 } @_ZN4absl13time_internal9FromInt64ILl1000000EEENS_8DurationElSt5ratioILl1EXT_EE(i64 noundef %conv) #17
  store { i64, i32 } %call, ptr %tmp.coerce, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %retval, ptr align 8 %tmp.coerce, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval.coerce, ptr align 4 %retval, i64 12, i1 false)
  %1 = load { i64, i32 }, ptr %retval.coerce, align 8
  ret { i64, i32 } %1
}

; Function Attrs: mustprogress nounwind willreturn memory(none) uwtable
define linkonce_odr dso_local { i64, i32 } @_ZN4abslmlIiEENS_8DurationES1_T_(i64 %lhs.coerce0, i32 %lhs.coerce1, i32 noundef %rhs) #9 comdat {
entry:
  %retval = alloca %"class.absl::Duration", align 4
  %lhs = alloca %"class.absl::Duration", align 4
  %coerce = alloca { i64, i32 }, align 4
  %rhs.addr = alloca i32, align 4
  %retval.coerce = alloca { i64, i32 }, align 8
  %0 = getelementptr inbounds { i64, i32 }, ptr %coerce, i32 0, i32 0
  store i64 %lhs.coerce0, ptr %0, align 4
  %1 = getelementptr inbounds { i64, i32 }, ptr %coerce, i32 0, i32 1
  store i32 %lhs.coerce1, ptr %1, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %lhs, ptr align 4 %coerce, i64 12, i1 false)
  store i32 %rhs, ptr %rhs.addr, align 4
  %2 = load i32, ptr %rhs.addr, align 4
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZN4absl8DurationmLIiTnNSt9enable_ifIXoosr3std11is_integralIT_EE5valuesr3std7is_enumIS3_EE5valueEiE4typeELi0EEERS0_S3_(ptr noundef nonnull align 4 dereferenceable(12) %lhs, i32 noundef %2)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %retval, ptr align 4 %call, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval.coerce, ptr align 4 %retval, i64 12, i1 false)
  %3 = load { i64, i32 }, ptr %retval.coerce, align 8
  ret { i64, i32 } %3
}

; Function Attrs: mustprogress uwtable
define internal { i64, i32 } @_ZN4absl12_GLOBAL__N_118MeasureTimeToYieldEv() #0 {
entry:
  %retval = alloca %"class.absl::Duration", align 4
  %before = alloca %"class.absl::Time", align 4
  %tmp.coerce = alloca { i64, i32 }, align 8
  %agg.tmp = alloca %"class.absl::Time", align 4
  %tmp.coerce3 = alloca { i64, i32 }, align 8
  %agg.tmp4 = alloca %"class.absl::Time", align 4
  %agg.tmp.coerce = alloca { i64, i32 }, align 4
  %agg.tmp4.coerce = alloca { i64, i32 }, align 4
  %tmp.coerce6 = alloca { i64, i32 }, align 8
  %retval.coerce = alloca { i64, i32 }, align 8
  %call = call { i64, i32 } @_ZN4absl3NowEv()
  %coerce.dive = getelementptr inbounds %"class.absl::Time", ptr %before, i32 0, i32 0
  store { i64, i32 } %call, ptr %tmp.coerce, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %coerce.dive, ptr align 8 %tmp.coerce, i64 12, i1 false)
  call void @AbslInternalMutexYield()
  %call1 = call { i64, i32 } @_ZN4absl3NowEv()
  %coerce.dive2 = getelementptr inbounds %"class.absl::Time", ptr %agg.tmp, i32 0, i32 0
  store { i64, i32 } %call1, ptr %tmp.coerce3, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %coerce.dive2, ptr align 8 %tmp.coerce3, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp4, ptr align 4 %before, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp.coerce, ptr align 4 %agg.tmp, i64 12, i1 false)
  %0 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp.coerce, i32 0, i32 0
  %1 = load i64, ptr %0, align 4
  %2 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp.coerce, i32 0, i32 1
  %3 = load i32, ptr %2, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp4.coerce, ptr align 4 %agg.tmp4, i64 12, i1 false)
  %4 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp4.coerce, i32 0, i32 0
  %5 = load i64, ptr %4, align 4
  %6 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp4.coerce, i32 0, i32 1
  %7 = load i32, ptr %6, align 4
  %call5 = call { i64, i32 } @_ZN4abslmiENS_4TimeES0_(i64 %1, i32 %3, i64 %5, i32 %7) #17
  store { i64, i32 } %call5, ptr %tmp.coerce6, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %retval, ptr align 8 %tmp.coerce6, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval.coerce, ptr align 4 %retval, i64 12, i1 false)
  %8 = load { i64, i32 }, ptr %retval.coerce, align 8
  ret { i64, i32 } %8
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 4 dereferenceable(12) ptr @_ZSt3minIN4absl8DurationEERKT_S4_S4_(ptr noundef nonnull align 4 dereferenceable(12) %__a, ptr noundef nonnull align 4 dereferenceable(12) %__b) #1 comdat {
entry:
  %retval = alloca ptr, align 8
  %__a.addr = alloca ptr, align 8
  %__b.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.absl::Duration", align 4
  %agg.tmp1 = alloca %"class.absl::Duration", align 4
  %agg.tmp.coerce = alloca { i64, i32 }, align 4
  %agg.tmp1.coerce = alloca { i64, i32 }, align 4
  store ptr %__a, ptr %__a.addr, align 8
  store ptr %__b, ptr %__b.addr, align 8
  %0 = load ptr, ptr %__b.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp, ptr align 4 %0, i64 12, i1 false)
  %1 = load ptr, ptr %__a.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp1, ptr align 4 %1, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp.coerce, ptr align 4 %agg.tmp, i64 12, i1 false)
  %2 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp.coerce, i32 0, i32 0
  %3 = load i64, ptr %2, align 4
  %4 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp.coerce, i32 0, i32 1
  %5 = load i32, ptr %4, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp1.coerce, ptr align 4 %agg.tmp1, i64 12, i1 false)
  %6 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp1.coerce, i32 0, i32 0
  %7 = load i64, ptr %6, align 4
  %8 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp1.coerce, i32 0, i32 1
  %9 = load i32, ptr %8, align 4
  %call = call noundef zeroext i1 @_ZN4abslltENS_8DurationES0_(i64 %3, i32 %5, i64 %7, i32 %9) #17
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load ptr, ptr %__b.addr, align 8
  store ptr %10, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %11 = load ptr, ptr %__a.addr, align 8
  store ptr %11, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load ptr, ptr %retval, align 8
  ret ptr %12
}

; Function Attrs: mustprogress nounwind willreturn memory(none) uwtable
define linkonce_odr dso_local { i64, i32 } @_ZN4absl12MillisecondsIiTnNSt9enable_ifIXoosr3std11is_integralIT_EE5valuesr3std7is_enumIS2_EE5valueEiE4typeELi0EEENS_8DurationES2_(i32 noundef %n) #9 comdat {
entry:
  %retval = alloca %"class.absl::Duration", align 4
  %n.addr = alloca i32, align 4
  %tmp.coerce = alloca { i64, i32 }, align 8
  %retval.coerce = alloca { i64, i32 }, align 8
  store i32 %n, ptr %n.addr, align 4
  %0 = load i32, ptr %n.addr, align 4
  %conv = sext i32 %0 to i64
  %call = call { i64, i32 } @_ZN4absl13time_internal9FromInt64ILl1000EEENS_8DurationElSt5ratioILl1EXT_EE(i64 noundef %conv) #17
  store { i64, i32 } %call, ptr %tmp.coerce, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %retval, ptr align 8 %tmp.coerce, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval.coerce, ptr align 4 %retval, i64 12, i1 false)
  %1 = load { i64, i32 }, ptr %retval.coerce, align 8
  ret { i64, i32 } %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 4 dereferenceable(12) ptr @_ZSt3maxIN4absl8DurationEERKT_S4_S4_(ptr noundef nonnull align 4 dereferenceable(12) %__a, ptr noundef nonnull align 4 dereferenceable(12) %__b) #1 comdat {
entry:
  %retval = alloca ptr, align 8
  %__a.addr = alloca ptr, align 8
  %__b.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.absl::Duration", align 4
  %agg.tmp1 = alloca %"class.absl::Duration", align 4
  %agg.tmp.coerce = alloca { i64, i32 }, align 4
  %agg.tmp1.coerce = alloca { i64, i32 }, align 4
  store ptr %__a, ptr %__a.addr, align 8
  store ptr %__b, ptr %__b.addr, align 8
  %0 = load ptr, ptr %__a.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp, ptr align 4 %0, i64 12, i1 false)
  %1 = load ptr, ptr %__b.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp1, ptr align 4 %1, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp.coerce, ptr align 4 %agg.tmp, i64 12, i1 false)
  %2 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp.coerce, i32 0, i32 0
  %3 = load i64, ptr %2, align 4
  %4 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp.coerce, i32 0, i32 1
  %5 = load i32, ptr %4, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp1.coerce, ptr align 4 %agg.tmp1, i64 12, i1 false)
  %6 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp1.coerce, i32 0, i32 0
  %7 = load i64, ptr %6, align 4
  %8 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp1.coerce, i32 0, i32 1
  %9 = load i32, ptr %8, align 4
  %call = call noundef zeroext i1 @_ZN4abslltENS_8DurationES0_(i64 %3, i32 %5, i64 %7, i32 %9) #17
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load ptr, ptr %__b.addr, align 8
  store ptr %10, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %11 = load ptr, ptr %__a.addr, align 8
  store ptr %11, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load ptr, ptr %retval, align 8
  ret ptr %12
}

; Function Attrs: mustprogress nounwind willreturn memory(none) uwtable
define linkonce_odr dso_local { i64, i32 } @_ZN4absl13time_internal9FromInt64ILl1000000EEENS_8DurationElSt5ratioILl1EXT_EE(i64 noundef %v) #9 comdat {
entry:
  %retval = alloca %"class.absl::Duration", align 4
  %v.addr = alloca i64, align 8
  %tmp.coerce = alloca { i64, i32 }, align 8
  %retval.coerce = alloca { i64, i32 }, align 8
  store i64 %v, ptr %v.addr, align 8
  %0 = load i64, ptr %v.addr, align 8
  %div = sdiv i64 %0, 1000000
  %1 = load i64, ptr %v.addr, align 8
  %rem = srem i64 %1, 1000000
  %mul = mul nsw i64 %rem, 4
  %mul1 = mul nsw i64 %mul, 1000
  %mul2 = mul nsw i64 %mul1, 1000
  %mul3 = mul nsw i64 %mul2, 1000
  %div4 = sdiv i64 %mul3, 1000000
  %call = call { i64, i32 } @_ZN4absl13time_internal22MakeNormalizedDurationEll(i64 noundef %div, i64 noundef %div4) #17
  store { i64, i32 } %call, ptr %tmp.coerce, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %retval, ptr align 8 %tmp.coerce, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval.coerce, ptr align 4 %retval, i64 12, i1 false)
  %2 = load { i64, i32 }, ptr %retval.coerce, align 8
  ret { i64, i32 } %2
}

; Function Attrs: mustprogress nounwind willreturn memory(none) uwtable
define linkonce_odr dso_local { i64, i32 } @_ZN4absl13time_internal22MakeNormalizedDurationEll(i64 noundef %sec, i64 noundef %ticks) #9 comdat {
entry:
  %retval = alloca %"class.absl::Duration", align 4
  %sec.addr = alloca i64, align 8
  %ticks.addr = alloca i64, align 8
  %tmp.coerce = alloca { i64, i32 }, align 8
  %tmp.coerce2 = alloca { i64, i32 }, align 8
  %retval.coerce = alloca { i64, i32 }, align 8
  store i64 %sec, ptr %sec.addr, align 8
  store i64 %ticks, ptr %ticks.addr, align 8
  %0 = load i64, ptr %ticks.addr, align 8
  %cmp = icmp slt i64 %0, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i64, ptr %sec.addr, align 8
  %sub = sub nsw i64 %1, 1
  %2 = load i64, ptr %ticks.addr, align 8
  %add = add nsw i64 %2, 4000000000
  %call = call { i64, i32 } @_ZN4absl13time_internal12MakeDurationEll(i64 noundef %sub, i64 noundef %add) #17
  store { i64, i32 } %call, ptr %tmp.coerce, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %retval, ptr align 8 %tmp.coerce, i64 12, i1 false)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load i64, ptr %sec.addr, align 8
  %4 = load i64, ptr %ticks.addr, align 8
  %call1 = call { i64, i32 } @_ZN4absl13time_internal12MakeDurationEll(i64 noundef %3, i64 noundef %4) #17
  store { i64, i32 } %call1, ptr %tmp.coerce2, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %retval, ptr align 8 %tmp.coerce2, i64 12, i1 false)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval.coerce, ptr align 4 %retval, i64 12, i1 false)
  %5 = load { i64, i32 }, ptr %retval.coerce, align 8
  ret { i64, i32 } %5
}

; Function Attrs: mustprogress nounwind willreturn memory(none) uwtable
define linkonce_odr dso_local { i64, i32 } @_ZN4absl13time_internal12MakeDurationEll(i64 noundef %hi, i64 noundef %lo) #9 comdat {
entry:
  %retval = alloca %"class.absl::Duration", align 4
  %hi.addr = alloca i64, align 8
  %lo.addr = alloca i64, align 8
  %tmp.coerce = alloca { i64, i32 }, align 8
  %retval.coerce = alloca { i64, i32 }, align 8
  store i64 %hi, ptr %hi.addr, align 8
  store i64 %lo, ptr %lo.addr, align 8
  %0 = load i64, ptr %hi.addr, align 8
  %1 = load i64, ptr %lo.addr, align 8
  %conv = trunc i64 %1 to i32
  %call = call { i64, i32 } @_ZN4absl13time_internal12MakeDurationElj(i64 noundef %0, i32 noundef %conv) #17
  store { i64, i32 } %call, ptr %tmp.coerce, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %retval, ptr align 8 %tmp.coerce, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval.coerce, ptr align 4 %retval, i64 12, i1 false)
  %2 = load { i64, i32 }, ptr %retval.coerce, align 8
  ret { i64, i32 } %2
}

; Function Attrs: mustprogress nounwind willreturn memory(none) uwtable
define linkonce_odr dso_local { i64, i32 } @_ZN4absl13time_internal12MakeDurationElj(i64 noundef %hi, i32 noundef %lo) #9 comdat {
entry:
  %retval = alloca %"class.absl::Duration", align 4
  %hi.addr = alloca i64, align 8
  %lo.addr = alloca i32, align 4
  %retval.coerce = alloca { i64, i32 }, align 8
  store i64 %hi, ptr %hi.addr, align 8
  store i32 %lo, ptr %lo.addr, align 4
  %0 = load i64, ptr %hi.addr, align 8
  %1 = load i32, ptr %lo.addr, align 4
  call void @_ZN4absl8DurationC2Elj(ptr noundef nonnull align 4 dereferenceable(12) %retval, i64 noundef %0, i32 noundef %1)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval.coerce, ptr align 4 %retval, i64 12, i1 false)
  %2 = load { i64, i32 }, ptr %retval.coerce, align 8
  ret { i64, i32 } %2
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN4absl8DurationC2Elj(ptr noundef nonnull align 4 dereferenceable(12) %this, i64 noundef %hi, i32 noundef %lo) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %hi.addr = alloca i64, align 8
  %lo.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i64 %hi, ptr %hi.addr, align 8
  store i32 %lo, ptr %lo.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %rep_hi_ = getelementptr inbounds %"class.absl::Duration", ptr %this1, i32 0, i32 0
  %0 = load i64, ptr %hi.addr, align 8
  call void @_ZN4absl8Duration5HiRepC2El(ptr noundef nonnull align 4 dereferenceable(8) %rep_hi_, i64 noundef %0)
  %rep_lo_ = getelementptr inbounds %"class.absl::Duration", ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %lo.addr, align 4
  store i32 %1, ptr %rep_lo_, align 4
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN4absl8Duration5HiRepC2El(ptr noundef nonnull align 4 dereferenceable(8) %this, i64 noundef %value) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %value.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %value, ptr %value.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %lo_ = getelementptr inbounds %"class.absl::Duration::HiRep", ptr %this1, i32 0, i32 0
  store i32 0, ptr %lo_, align 4
  %hi_ = getelementptr inbounds %"class.absl::Duration::HiRep", ptr %this1, i32 0, i32 1
  store i32 0, ptr %hi_, align 4
  %0 = load i64, ptr %value.addr, align 8
  %call = call noundef nonnull align 4 dereferenceable(8) ptr @_ZN4absl8Duration5HiRepaSEl(ptr noundef nonnull align 4 dereferenceable(8) %this1, i64 noundef %0)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 4 dereferenceable(8) ptr @_ZN4absl8Duration5HiRepaSEl(ptr noundef nonnull align 4 dereferenceable(8) %this, i64 noundef %value) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %value.addr = alloca i64, align 8
  %unsigned_value = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %value, ptr %value.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %value.addr, align 8
  store i64 %0, ptr %unsigned_value, align 8
  %1 = load i64, ptr %unsigned_value, align 8
  %shr = lshr i64 %1, 32
  %conv = trunc i64 %shr to i32
  %hi_ = getelementptr inbounds %"class.absl::Duration::HiRep", ptr %this1, i32 0, i32 1
  store i32 %conv, ptr %hi_, align 4
  %2 = load i64, ptr %unsigned_value, align 8
  %conv2 = trunc i64 %2 to i32
  %lo_ = getelementptr inbounds %"class.absl::Duration::HiRep", ptr %this1, i32 0, i32 0
  store i32 %conv2, ptr %lo_, align 4
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 4 dereferenceable(12) ptr @_ZN4absl8DurationmLIiTnNSt9enable_ifIXoosr3std11is_integralIT_EE5valuesr3std7is_enumIS3_EE5valueEiE4typeELi0EEERS0_S3_(ptr noundef nonnull align 4 dereferenceable(12) %this, i32 noundef %r) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %r.addr = alloca i32, align 4
  %x = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %r, ptr %r.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %r.addr, align 4
  %conv = sext i32 %0 to i64
  store i64 %conv, ptr %x, align 8
  %1 = load i64, ptr %x, align 8
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZN4absl8DurationmLEl(ptr noundef nonnull align 4 dereferenceable(12) %this1, i64 noundef %1)
  ret ptr %call
}

declare noundef nonnull align 4 dereferenceable(12) ptr @_ZN4absl8DurationmLEl(ptr noundef nonnull align 4 dereferenceable(12), i64 noundef) #3

declare { i64, i32 } @_ZN4absl3NowEv() #3

; Function Attrs: mustprogress nounwind willreturn memory(none) uwtable
define linkonce_odr dso_local { i64, i32 } @_ZN4abslmiENS_4TimeES0_(i64 %lhs.coerce0, i32 %lhs.coerce1, i64 %rhs.coerce0, i32 %rhs.coerce1) #9 comdat {
entry:
  %retval = alloca %"class.absl::Duration", align 4
  %lhs = alloca %"class.absl::Time", align 4
  %coerce = alloca { i64, i32 }, align 4
  %rhs = alloca %"class.absl::Time", align 4
  %coerce1 = alloca { i64, i32 }, align 4
  %agg.tmp = alloca %"class.absl::Duration", align 4
  %agg.tmp2 = alloca %"class.absl::Duration", align 4
  %agg.tmp.coerce = alloca { i64, i32 }, align 4
  %agg.tmp2.coerce = alloca { i64, i32 }, align 4
  %tmp.coerce = alloca { i64, i32 }, align 8
  %retval.coerce = alloca { i64, i32 }, align 8
  %0 = getelementptr inbounds { i64, i32 }, ptr %coerce, i32 0, i32 0
  store i64 %lhs.coerce0, ptr %0, align 4
  %1 = getelementptr inbounds { i64, i32 }, ptr %coerce, i32 0, i32 1
  store i32 %lhs.coerce1, ptr %1, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %lhs, ptr align 4 %coerce, i64 12, i1 false)
  %2 = getelementptr inbounds { i64, i32 }, ptr %coerce1, i32 0, i32 0
  store i64 %rhs.coerce0, ptr %2, align 4
  %3 = getelementptr inbounds { i64, i32 }, ptr %coerce1, i32 0, i32 1
  store i32 %rhs.coerce1, ptr %3, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %rhs, ptr align 4 %coerce1, i64 12, i1 false)
  %rep_ = getelementptr inbounds %"class.absl::Time", ptr %lhs, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp, ptr align 4 %rep_, i64 12, i1 false)
  %rep_3 = getelementptr inbounds %"class.absl::Time", ptr %rhs, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp2, ptr align 4 %rep_3, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp.coerce, ptr align 4 %agg.tmp, i64 12, i1 false)
  %4 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp.coerce, i32 0, i32 0
  %5 = load i64, ptr %4, align 4
  %6 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp.coerce, i32 0, i32 1
  %7 = load i32, ptr %6, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp2.coerce, ptr align 4 %agg.tmp2, i64 12, i1 false)
  %8 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp2.coerce, i32 0, i32 0
  %9 = load i64, ptr %8, align 4
  %10 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp2.coerce, i32 0, i32 1
  %11 = load i32, ptr %10, align 4
  %call = call { i64, i32 } @_ZN4abslmiENS_8DurationES0_(i64 %5, i32 %7, i64 %9, i32 %11) #17
  store { i64, i32 } %call, ptr %tmp.coerce, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %retval, ptr align 8 %tmp.coerce, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval.coerce, ptr align 4 %retval, i64 12, i1 false)
  %12 = load { i64, i32 }, ptr %retval.coerce, align 8
  ret { i64, i32 } %12
}

; Function Attrs: mustprogress nounwind willreturn memory(none) uwtable
define linkonce_odr dso_local { i64, i32 } @_ZN4abslmiENS_8DurationES0_(i64 %lhs.coerce0, i32 %lhs.coerce1, i64 %rhs.coerce0, i32 %rhs.coerce1) #9 comdat {
entry:
  %retval = alloca %"class.absl::Duration", align 4
  %lhs = alloca %"class.absl::Duration", align 4
  %coerce = alloca { i64, i32 }, align 4
  %rhs = alloca %"class.absl::Duration", align 4
  %coerce1 = alloca { i64, i32 }, align 4
  %agg.tmp = alloca %"class.absl::Duration", align 4
  %agg.tmp.coerce = alloca { i64, i32 }, align 4
  %retval.coerce = alloca { i64, i32 }, align 8
  %0 = getelementptr inbounds { i64, i32 }, ptr %coerce, i32 0, i32 0
  store i64 %lhs.coerce0, ptr %0, align 4
  %1 = getelementptr inbounds { i64, i32 }, ptr %coerce, i32 0, i32 1
  store i32 %lhs.coerce1, ptr %1, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %lhs, ptr align 4 %coerce, i64 12, i1 false)
  %2 = getelementptr inbounds { i64, i32 }, ptr %coerce1, i32 0, i32 0
  store i64 %rhs.coerce0, ptr %2, align 4
  %3 = getelementptr inbounds { i64, i32 }, ptr %coerce1, i32 0, i32 1
  store i32 %rhs.coerce1, ptr %3, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %rhs, ptr align 4 %coerce1, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp, ptr align 4 %rhs, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp.coerce, ptr align 4 %agg.tmp, i64 12, i1 false)
  %4 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp.coerce, i32 0, i32 0
  %5 = load i64, ptr %4, align 4
  %6 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp.coerce, i32 0, i32 1
  %7 = load i32, ptr %6, align 4
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZN4absl8DurationmIES0_(ptr noundef nonnull align 4 dereferenceable(12) %lhs, i64 %5, i32 %7)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %retval, ptr align 4 %call, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval.coerce, ptr align 4 %retval, i64 12, i1 false)
  %8 = load { i64, i32 }, ptr %retval.coerce, align 8
  ret { i64, i32 } %8
}

declare noundef nonnull align 4 dereferenceable(12) ptr @_ZN4absl8DurationmIES0_(ptr noundef nonnull align 4 dereferenceable(12), i64, i32) #3

; Function Attrs: mustprogress nounwind willreturn memory(none) uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN4abslltENS_8DurationES0_(i64 %lhs.coerce0, i32 %lhs.coerce1, i64 %rhs.coerce0, i32 %rhs.coerce1) #9 comdat {
entry:
  %lhs = alloca %"class.absl::Duration", align 4
  %coerce = alloca { i64, i32 }, align 4
  %rhs = alloca %"class.absl::Duration", align 4
  %coerce1 = alloca { i64, i32 }, align 4
  %agg.tmp = alloca %"class.absl::Duration", align 4
  %agg.tmp.coerce = alloca { i64, i32 }, align 4
  %agg.tmp2 = alloca %"class.absl::Duration", align 4
  %agg.tmp2.coerce = alloca { i64, i32 }, align 4
  %agg.tmp4 = alloca %"class.absl::Duration", align 4
  %agg.tmp4.coerce = alloca { i64, i32 }, align 4
  %agg.tmp6 = alloca %"class.absl::Duration", align 4
  %agg.tmp6.coerce = alloca { i64, i32 }, align 4
  %agg.tmp9 = alloca %"class.absl::Duration", align 4
  %agg.tmp9.coerce = alloca { i64, i32 }, align 4
  %agg.tmp14 = alloca %"class.absl::Duration", align 4
  %agg.tmp14.coerce = alloca { i64, i32 }, align 4
  %agg.tmp16 = alloca %"class.absl::Duration", align 4
  %agg.tmp16.coerce = alloca { i64, i32 }, align 4
  %agg.tmp21 = alloca %"class.absl::Duration", align 4
  %agg.tmp21.coerce = alloca { i64, i32 }, align 4
  %agg.tmp23 = alloca %"class.absl::Duration", align 4
  %agg.tmp23.coerce = alloca { i64, i32 }, align 4
  %0 = getelementptr inbounds { i64, i32 }, ptr %coerce, i32 0, i32 0
  store i64 %lhs.coerce0, ptr %0, align 4
  %1 = getelementptr inbounds { i64, i32 }, ptr %coerce, i32 0, i32 1
  store i32 %lhs.coerce1, ptr %1, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %lhs, ptr align 4 %coerce, i64 12, i1 false)
  %2 = getelementptr inbounds { i64, i32 }, ptr %coerce1, i32 0, i32 0
  store i64 %rhs.coerce0, ptr %2, align 4
  %3 = getelementptr inbounds { i64, i32 }, ptr %coerce1, i32 0, i32 1
  store i32 %rhs.coerce1, ptr %3, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %rhs, ptr align 4 %coerce1, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp, ptr align 4 %lhs, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp.coerce, ptr align 4 %agg.tmp, i64 12, i1 false)
  %4 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp.coerce, i32 0, i32 0
  %5 = load i64, ptr %4, align 4
  %6 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp.coerce, i32 0, i32 1
  %7 = load i32, ptr %6, align 4
  %call = call noundef i64 @_ZN4absl13time_internal8GetRepHiENS_8DurationE(i64 %5, i32 %7) #17
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp2, ptr align 4 %rhs, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp2.coerce, ptr align 4 %agg.tmp2, i64 12, i1 false)
  %8 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp2.coerce, i32 0, i32 0
  %9 = load i64, ptr %8, align 4
  %10 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp2.coerce, i32 0, i32 1
  %11 = load i32, ptr %10, align 4
  %call3 = call noundef i64 @_ZN4absl13time_internal8GetRepHiENS_8DurationE(i64 %9, i32 %11) #17
  %cmp = icmp ne i64 %call, %call3
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp4, ptr align 4 %lhs, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp4.coerce, ptr align 4 %agg.tmp4, i64 12, i1 false)
  %12 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp4.coerce, i32 0, i32 0
  %13 = load i64, ptr %12, align 4
  %14 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp4.coerce, i32 0, i32 1
  %15 = load i32, ptr %14, align 4
  %call5 = call noundef i64 @_ZN4absl13time_internal8GetRepHiENS_8DurationE(i64 %13, i32 %15) #17
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp6, ptr align 4 %rhs, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp6.coerce, ptr align 4 %agg.tmp6, i64 12, i1 false)
  %16 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp6.coerce, i32 0, i32 0
  %17 = load i64, ptr %16, align 4
  %18 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp6.coerce, i32 0, i32 1
  %19 = load i32, ptr %18, align 4
  %call7 = call noundef i64 @_ZN4absl13time_internal8GetRepHiENS_8DurationE(i64 %17, i32 %19) #17
  %cmp8 = icmp slt i64 %call5, %call7
  br label %cond.end26

cond.false:                                       ; preds = %entry
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp9, ptr align 4 %lhs, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp9.coerce, ptr align 4 %agg.tmp9, i64 12, i1 false)
  %20 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp9.coerce, i32 0, i32 0
  %21 = load i64, ptr %20, align 4
  %22 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp9.coerce, i32 0, i32 1
  %23 = load i32, ptr %22, align 4
  %call10 = call noundef i64 @_ZN4absl13time_internal8GetRepHiENS_8DurationE(i64 %21, i32 %23) #17
  %call11 = call noundef i64 @_ZNSt14numeric_limitsIlE3minEv() #13
  %cmp12 = icmp eq i64 %call10, %call11
  br i1 %cmp12, label %cond.true13, label %cond.false20

cond.true13:                                      ; preds = %cond.false
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp14, ptr align 4 %lhs, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp14.coerce, ptr align 4 %agg.tmp14, i64 12, i1 false)
  %24 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp14.coerce, i32 0, i32 0
  %25 = load i64, ptr %24, align 4
  %26 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp14.coerce, i32 0, i32 1
  %27 = load i32, ptr %26, align 4
  %call15 = call noundef i32 @_ZN4absl13time_internal8GetRepLoENS_8DurationE(i64 %25, i32 %27) #17
  %add = add i32 %call15, 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp16, ptr align 4 %rhs, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp16.coerce, ptr align 4 %agg.tmp16, i64 12, i1 false)
  %28 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp16.coerce, i32 0, i32 0
  %29 = load i64, ptr %28, align 4
  %30 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp16.coerce, i32 0, i32 1
  %31 = load i32, ptr %30, align 4
  %call17 = call noundef i32 @_ZN4absl13time_internal8GetRepLoENS_8DurationE(i64 %29, i32 %31) #17
  %add18 = add i32 %call17, 1
  %cmp19 = icmp ult i32 %add, %add18
  br label %cond.end

cond.false20:                                     ; preds = %cond.false
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp21, ptr align 4 %lhs, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp21.coerce, ptr align 4 %agg.tmp21, i64 12, i1 false)
  %32 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp21.coerce, i32 0, i32 0
  %33 = load i64, ptr %32, align 4
  %34 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp21.coerce, i32 0, i32 1
  %35 = load i32, ptr %34, align 4
  %call22 = call noundef i32 @_ZN4absl13time_internal8GetRepLoENS_8DurationE(i64 %33, i32 %35) #17
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp23, ptr align 4 %rhs, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp23.coerce, ptr align 4 %agg.tmp23, i64 12, i1 false)
  %36 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp23.coerce, i32 0, i32 0
  %37 = load i64, ptr %36, align 4
  %38 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp23.coerce, i32 0, i32 1
  %39 = load i32, ptr %38, align 4
  %call24 = call noundef i32 @_ZN4absl13time_internal8GetRepLoENS_8DurationE(i64 %37, i32 %39) #17
  %cmp25 = icmp ult i32 %call22, %call24
  br label %cond.end

cond.end:                                         ; preds = %cond.false20, %cond.true13
  %cond = phi i1 [ %cmp19, %cond.true13 ], [ %cmp25, %cond.false20 ]
  br label %cond.end26

cond.end26:                                       ; preds = %cond.end, %cond.true
  %cond27 = phi i1 [ %cmp8, %cond.true ], [ %cond, %cond.end ]
  ret i1 %cond27
}

; Function Attrs: mustprogress nounwind willreturn memory(none) uwtable
define linkonce_odr dso_local noundef i64 @_ZN4absl13time_internal8GetRepHiENS_8DurationE(i64 %d.coerce0, i32 %d.coerce1) #9 comdat {
entry:
  %d = alloca %"class.absl::Duration", align 4
  %coerce = alloca { i64, i32 }, align 4
  %0 = getelementptr inbounds { i64, i32 }, ptr %coerce, i32 0, i32 0
  store i64 %d.coerce0, ptr %0, align 4
  %1 = getelementptr inbounds { i64, i32 }, ptr %coerce, i32 0, i32 1
  store i32 %d.coerce1, ptr %1, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %d, ptr align 4 %coerce, i64 12, i1 false)
  %rep_hi_ = getelementptr inbounds %"class.absl::Duration", ptr %d, i32 0, i32 0
  %call = call noundef i64 @_ZNK4absl8Duration5HiRep3GetEv(ptr noundef nonnull align 4 dereferenceable(8) %rep_hi_)
  ret i64 %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNSt14numeric_limitsIlE3minEv() #1 comdat align 2 {
entry:
  ret i64 -9223372036854775808
}

; Function Attrs: mustprogress nounwind willreturn memory(none) uwtable
define linkonce_odr dso_local noundef i32 @_ZN4absl13time_internal8GetRepLoENS_8DurationE(i64 %d.coerce0, i32 %d.coerce1) #9 comdat {
entry:
  %d = alloca %"class.absl::Duration", align 4
  %coerce = alloca { i64, i32 }, align 4
  %0 = getelementptr inbounds { i64, i32 }, ptr %coerce, i32 0, i32 0
  store i64 %d.coerce0, ptr %0, align 4
  %1 = getelementptr inbounds { i64, i32 }, ptr %coerce, i32 0, i32 1
  store i32 %d.coerce1, ptr %1, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %d, ptr align 4 %coerce, i64 12, i1 false)
  %rep_lo_ = getelementptr inbounds %"class.absl::Duration", ptr %d, i32 0, i32 1
  %2 = load i32, ptr %rep_lo_, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK4absl8Duration5HiRep3GetEv(ptr noundef nonnull align 4 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %unsigned_value = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %hi_ = getelementptr inbounds %"class.absl::Duration::HiRep", ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %hi_, align 4
  %conv = zext i32 %0 to i64
  %shl = shl i64 %conv, 32
  %lo_ = getelementptr inbounds %"class.absl::Duration::HiRep", ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %lo_, align 4
  %conv2 = zext i32 %1 to i64
  %or = or i64 %shl, %conv2
  store i64 %or, ptr %unsigned_value, align 8
  %2 = load i64, ptr %unsigned_value, align 8
  ret i64 %2
}

; Function Attrs: mustprogress nounwind willreturn memory(none) uwtable
define linkonce_odr dso_local { i64, i32 } @_ZN4absl13time_internal9FromInt64ILl1000EEENS_8DurationElSt5ratioILl1EXT_EE(i64 noundef %v) #9 comdat {
entry:
  %retval = alloca %"class.absl::Duration", align 4
  %v.addr = alloca i64, align 8
  %tmp.coerce = alloca { i64, i32 }, align 8
  %retval.coerce = alloca { i64, i32 }, align 8
  store i64 %v, ptr %v.addr, align 8
  %0 = load i64, ptr %v.addr, align 8
  %div = sdiv i64 %0, 1000
  %1 = load i64, ptr %v.addr, align 8
  %rem = srem i64 %1, 1000
  %mul = mul nsw i64 %rem, 4
  %mul1 = mul nsw i64 %mul, 1000
  %mul2 = mul nsw i64 %mul1, 1000
  %mul3 = mul nsw i64 %mul2, 1000
  %div4 = sdiv i64 %mul3, 1000
  %call = call { i64, i32 } @_ZN4absl13time_internal22MakeNormalizedDurationEll(i64 noundef %div, i64 noundef %div4) #17
  store { i64, i32 } %call, ptr %tmp.coerce, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %retval, ptr align 8 %tmp.coerce, i64 12, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval.coerce, ptr align 4 %retval, i64 12, i1 false)
  %2 = load { i64, i32 }, ptr %retval.coerce, align 8
  ret { i64, i32 } %2
}

declare void @AbslInternalSpinLockWake(ptr noundef, i1 noundef zeroext) #3

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN4absl13base_internal15SchedulingGuard18EnableReschedulingEb(i1 noundef zeroext %0) #1 comdat align 2 {
entry:
  %.addr = alloca i8, align 1
  %frombool = zext i1 %0 to i8
  store i8 %frombool, ptr %.addr, align 1
  ret void
}

declare void @AbslInternalSleepFor(i64, i32) #3

declare void @AbslInternalPerThreadSemPost(ptr noundef) #3

declare zeroext i1 @AbslInternalPerThreadSemWait(i64) #3

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN4absl13base_internal8SpinLock4LockEv(ptr noundef nonnull align 4 dereferenceable(4) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZN4absl13base_internal8SpinLock11TryLockImplEv(ptr noundef nonnull align 4 dereferenceable(4) %this1)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @_ZN4absl13base_internal8SpinLock8SlowLockEv(ptr noundef nonnull align 4 dereferenceable(4) %this1) #16
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @_ZN4absl13base_internal13LowLevelAlloc4FreeEPv(ptr noundef) #3 section "malloc_hook"

; Function Attrs: mustprogress nounwind uwtable
define internal noundef zeroext i1 @_ZN4abslL13AtomicSetBitsEPSt6atomicIlEll(ptr noundef %pv, i64 noundef %bits, i64 noundef %wait_until_clear) #1 {
entry:
  %this.addr.i8 = alloca ptr, align 8
  %__i1.addr.i = alloca ptr, align 8
  %__i2.addr.i = alloca i64, align 8
  %__m1.addr.i = alloca i32, align 4
  %__m2.addr.i = alloca i32, align 4
  %.atomictmp.i = alloca i64, align 8
  %cmpxchg.bool.i = alloca i8, align 1
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i64, align 8
  %retval = alloca i1, align 1
  %pv.addr = alloca ptr, align 8
  %bits.addr = alloca i64, align 8
  %wait_until_clear.addr = alloca i64, align 8
  %v = alloca i64, align 8
  store ptr %pv, ptr %pv.addr, align 8
  store i64 %bits, ptr %bits.addr, align 8
  store i64 %wait_until_clear, ptr %wait_until_clear.addr, align 8
  br label %for.cond

for.cond:                                         ; preds = %if.end7, %if.then3, %entry
  %0 = load ptr, ptr %pv.addr, align 8
  store ptr %0, ptr %this.addr.i, align 8
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %1 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %1, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %2 = load i32, ptr %__m.addr.i, align 4
  switch i32 %2, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %for.cond
  %3 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %3, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %for.cond, %for.cond
  %4 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %4, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %for.cond
  %5 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %5, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %6 = load i64, ptr %atomic-temp.i, align 8
  store i64 %6, ptr %v, align 8
  %7 = load i64, ptr %v, align 8
  %8 = load i64, ptr %bits.addr, align 8
  %and = and i64 %7, %8
  %9 = load i64, ptr %bits.addr, align 8
  %cmp = icmp eq i64 %and, %9
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit
  %10 = load i64, ptr %v, align 8
  %11 = load i64, ptr %wait_until_clear.addr, align 8
  %and1 = and i64 %10, %11
  %cmp2 = icmp ne i64 %and1, 0
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  br label %for.cond, !llvm.loop !38

if.end4:                                          ; preds = %if.end
  %12 = load ptr, ptr %pv.addr, align 8
  %13 = load i64, ptr %v, align 8
  %14 = load i64, ptr %bits.addr, align 8
  %or = or i64 %13, %14
  store ptr %12, ptr %this.addr.i8, align 8
  store ptr %v, ptr %__i1.addr.i, align 8
  store i64 %or, ptr %__i2.addr.i, align 8
  store i32 3, ptr %__m1.addr.i, align 4
  store i32 0, ptr %__m2.addr.i, align 4
  %this1.i9 = load ptr, ptr %this.addr.i8, align 8
  %15 = load i32, ptr %__m1.addr.i, align 4
  %16 = load ptr, ptr %__i1.addr.i, align 8
  %17 = load i64, ptr %__i2.addr.i, align 8
  store i64 %17, ptr %.atomictmp.i, align 8
  %18 = load i32, ptr %__m2.addr.i, align 4
  switch i32 %15, label %monotonic.i12 [
    i32 1, label %acquire.i11
    i32 2, label %acquire.i11
    i32 3, label %release.i
    i32 4, label %acqrel.i
    i32 5, label %seqcst.i10
  ]

monotonic.i12:                                    ; preds = %if.end4
  switch i32 %18, label %monotonic_fail.i [
    i32 1, label %acquire_fail.i
    i32 2, label %acquire_fail.i
    i32 5, label %seqcst_fail.i
  ]

acquire.i11:                                      ; preds = %if.end4, %if.end4
  switch i32 %18, label %monotonic_fail9.i [
    i32 1, label %acquire_fail10.i
    i32 2, label %acquire_fail10.i
    i32 5, label %seqcst_fail11.i
  ]

release.i:                                        ; preds = %if.end4
  switch i32 %18, label %monotonic_fail22.i [
    i32 1, label %acquire_fail23.i
    i32 2, label %acquire_fail23.i
    i32 5, label %seqcst_fail24.i
  ]

acqrel.i:                                         ; preds = %if.end4
  switch i32 %18, label %monotonic_fail35.i [
    i32 1, label %acquire_fail36.i
    i32 2, label %acquire_fail36.i
    i32 5, label %seqcst_fail37.i
  ]

seqcst.i10:                                       ; preds = %if.end4
  switch i32 %18, label %monotonic_fail48.i [
    i32 1, label %acquire_fail49.i
    i32 2, label %acquire_fail49.i
    i32 5, label %seqcst_fail50.i
  ]

monotonic_fail.i:                                 ; preds = %monotonic.i12
  %19 = load i64, ptr %16, align 8
  %20 = load i64, ptr %.atomictmp.i, align 8
  %21 = cmpxchg weak ptr %this1.i9, i64 %19, i64 %20 monotonic monotonic, align 8
  %22 = extractvalue { i64, i1 } %21, 0
  %23 = extractvalue { i64, i1 } %21, 1
  br i1 %23, label %cmpxchg.continue.i, label %cmpxchg.store_expected.i

acquire_fail.i:                                   ; preds = %monotonic.i12, %monotonic.i12
  %24 = load i64, ptr %16, align 8
  %25 = load i64, ptr %.atomictmp.i, align 8
  %26 = cmpxchg weak ptr %this1.i9, i64 %24, i64 %25 monotonic acquire, align 8
  %27 = extractvalue { i64, i1 } %26, 0
  %28 = extractvalue { i64, i1 } %26, 1
  br i1 %28, label %cmpxchg.continue4.i, label %cmpxchg.store_expected3.i

seqcst_fail.i:                                    ; preds = %monotonic.i12
  %29 = load i64, ptr %16, align 8
  %30 = load i64, ptr %.atomictmp.i, align 8
  %31 = cmpxchg weak ptr %this1.i9, i64 %29, i64 %30 monotonic seq_cst, align 8
  %32 = extractvalue { i64, i1 } %31, 0
  %33 = extractvalue { i64, i1 } %31, 1
  br i1 %33, label %cmpxchg.continue7.i, label %cmpxchg.store_expected6.i

atomic.continue2.i:                               ; preds = %cmpxchg.continue7.i, %cmpxchg.continue4.i, %cmpxchg.continue.i
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected.i:                         ; preds = %monotonic_fail.i
  store i64 %22, ptr %16, align 8
  br label %cmpxchg.continue.i

cmpxchg.continue.i:                               ; preds = %cmpxchg.store_expected.i, %monotonic_fail.i
  %frombool.i = zext i1 %23 to i8
  store i8 %frombool.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected3.i:                        ; preds = %acquire_fail.i
  store i64 %27, ptr %16, align 8
  br label %cmpxchg.continue4.i

cmpxchg.continue4.i:                              ; preds = %cmpxchg.store_expected3.i, %acquire_fail.i
  %frombool5.i = zext i1 %28 to i8
  store i8 %frombool5.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected6.i:                        ; preds = %seqcst_fail.i
  store i64 %32, ptr %16, align 8
  br label %cmpxchg.continue7.i

cmpxchg.continue7.i:                              ; preds = %cmpxchg.store_expected6.i, %seqcst_fail.i
  %frombool8.i = zext i1 %33 to i8
  store i8 %frombool8.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

monotonic_fail9.i:                                ; preds = %acquire.i11
  %34 = load i64, ptr %16, align 8
  %35 = load i64, ptr %.atomictmp.i, align 8
  %36 = cmpxchg weak ptr %this1.i9, i64 %34, i64 %35 acquire monotonic, align 8
  %37 = extractvalue { i64, i1 } %36, 0
  %38 = extractvalue { i64, i1 } %36, 1
  br i1 %38, label %cmpxchg.continue14.i, label %cmpxchg.store_expected13.i

acquire_fail10.i:                                 ; preds = %acquire.i11, %acquire.i11
  %39 = load i64, ptr %16, align 8
  %40 = load i64, ptr %.atomictmp.i, align 8
  %41 = cmpxchg weak ptr %this1.i9, i64 %39, i64 %40 acquire acquire, align 8
  %42 = extractvalue { i64, i1 } %41, 0
  %43 = extractvalue { i64, i1 } %41, 1
  br i1 %43, label %cmpxchg.continue17.i, label %cmpxchg.store_expected16.i

seqcst_fail11.i:                                  ; preds = %acquire.i11
  %44 = load i64, ptr %16, align 8
  %45 = load i64, ptr %.atomictmp.i, align 8
  %46 = cmpxchg weak ptr %this1.i9, i64 %44, i64 %45 acquire seq_cst, align 8
  %47 = extractvalue { i64, i1 } %46, 0
  %48 = extractvalue { i64, i1 } %46, 1
  br i1 %48, label %cmpxchg.continue20.i, label %cmpxchg.store_expected19.i

atomic.continue12.i:                              ; preds = %cmpxchg.continue20.i, %cmpxchg.continue17.i, %cmpxchg.continue14.i
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected13.i:                       ; preds = %monotonic_fail9.i
  store i64 %37, ptr %16, align 8
  br label %cmpxchg.continue14.i

cmpxchg.continue14.i:                             ; preds = %cmpxchg.store_expected13.i, %monotonic_fail9.i
  %frombool15.i = zext i1 %38 to i8
  store i8 %frombool15.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected16.i:                       ; preds = %acquire_fail10.i
  store i64 %42, ptr %16, align 8
  br label %cmpxchg.continue17.i

cmpxchg.continue17.i:                             ; preds = %cmpxchg.store_expected16.i, %acquire_fail10.i
  %frombool18.i = zext i1 %43 to i8
  store i8 %frombool18.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected19.i:                       ; preds = %seqcst_fail11.i
  store i64 %47, ptr %16, align 8
  br label %cmpxchg.continue20.i

cmpxchg.continue20.i:                             ; preds = %cmpxchg.store_expected19.i, %seqcst_fail11.i
  %frombool21.i = zext i1 %48 to i8
  store i8 %frombool21.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

monotonic_fail22.i:                               ; preds = %release.i
  %49 = load i64, ptr %16, align 8
  %50 = load i64, ptr %.atomictmp.i, align 8
  %51 = cmpxchg weak ptr %this1.i9, i64 %49, i64 %50 release monotonic, align 8
  %52 = extractvalue { i64, i1 } %51, 0
  %53 = extractvalue { i64, i1 } %51, 1
  br i1 %53, label %cmpxchg.continue27.i, label %cmpxchg.store_expected26.i

acquire_fail23.i:                                 ; preds = %release.i, %release.i
  %54 = load i64, ptr %16, align 8
  %55 = load i64, ptr %.atomictmp.i, align 8
  %56 = cmpxchg weak ptr %this1.i9, i64 %54, i64 %55 release acquire, align 8
  %57 = extractvalue { i64, i1 } %56, 0
  %58 = extractvalue { i64, i1 } %56, 1
  br i1 %58, label %cmpxchg.continue30.i, label %cmpxchg.store_expected29.i

seqcst_fail24.i:                                  ; preds = %release.i
  %59 = load i64, ptr %16, align 8
  %60 = load i64, ptr %.atomictmp.i, align 8
  %61 = cmpxchg weak ptr %this1.i9, i64 %59, i64 %60 release seq_cst, align 8
  %62 = extractvalue { i64, i1 } %61, 0
  %63 = extractvalue { i64, i1 } %61, 1
  br i1 %63, label %cmpxchg.continue33.i, label %cmpxchg.store_expected32.i

atomic.continue25.i:                              ; preds = %cmpxchg.continue33.i, %cmpxchg.continue30.i, %cmpxchg.continue27.i
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected26.i:                       ; preds = %monotonic_fail22.i
  store i64 %52, ptr %16, align 8
  br label %cmpxchg.continue27.i

cmpxchg.continue27.i:                             ; preds = %cmpxchg.store_expected26.i, %monotonic_fail22.i
  %frombool28.i = zext i1 %53 to i8
  store i8 %frombool28.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected29.i:                       ; preds = %acquire_fail23.i
  store i64 %57, ptr %16, align 8
  br label %cmpxchg.continue30.i

cmpxchg.continue30.i:                             ; preds = %cmpxchg.store_expected29.i, %acquire_fail23.i
  %frombool31.i = zext i1 %58 to i8
  store i8 %frombool31.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected32.i:                       ; preds = %seqcst_fail24.i
  store i64 %62, ptr %16, align 8
  br label %cmpxchg.continue33.i

cmpxchg.continue33.i:                             ; preds = %cmpxchg.store_expected32.i, %seqcst_fail24.i
  %frombool34.i = zext i1 %63 to i8
  store i8 %frombool34.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

monotonic_fail35.i:                               ; preds = %acqrel.i
  %64 = load i64, ptr %16, align 8
  %65 = load i64, ptr %.atomictmp.i, align 8
  %66 = cmpxchg weak ptr %this1.i9, i64 %64, i64 %65 acq_rel monotonic, align 8
  %67 = extractvalue { i64, i1 } %66, 0
  %68 = extractvalue { i64, i1 } %66, 1
  br i1 %68, label %cmpxchg.continue40.i, label %cmpxchg.store_expected39.i

acquire_fail36.i:                                 ; preds = %acqrel.i, %acqrel.i
  %69 = load i64, ptr %16, align 8
  %70 = load i64, ptr %.atomictmp.i, align 8
  %71 = cmpxchg weak ptr %this1.i9, i64 %69, i64 %70 acq_rel acquire, align 8
  %72 = extractvalue { i64, i1 } %71, 0
  %73 = extractvalue { i64, i1 } %71, 1
  br i1 %73, label %cmpxchg.continue43.i, label %cmpxchg.store_expected42.i

seqcst_fail37.i:                                  ; preds = %acqrel.i
  %74 = load i64, ptr %16, align 8
  %75 = load i64, ptr %.atomictmp.i, align 8
  %76 = cmpxchg weak ptr %this1.i9, i64 %74, i64 %75 acq_rel seq_cst, align 8
  %77 = extractvalue { i64, i1 } %76, 0
  %78 = extractvalue { i64, i1 } %76, 1
  br i1 %78, label %cmpxchg.continue46.i, label %cmpxchg.store_expected45.i

atomic.continue38.i:                              ; preds = %cmpxchg.continue46.i, %cmpxchg.continue43.i, %cmpxchg.continue40.i
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected39.i:                       ; preds = %monotonic_fail35.i
  store i64 %67, ptr %16, align 8
  br label %cmpxchg.continue40.i

cmpxchg.continue40.i:                             ; preds = %cmpxchg.store_expected39.i, %monotonic_fail35.i
  %frombool41.i = zext i1 %68 to i8
  store i8 %frombool41.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected42.i:                       ; preds = %acquire_fail36.i
  store i64 %72, ptr %16, align 8
  br label %cmpxchg.continue43.i

cmpxchg.continue43.i:                             ; preds = %cmpxchg.store_expected42.i, %acquire_fail36.i
  %frombool44.i = zext i1 %73 to i8
  store i8 %frombool44.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected45.i:                       ; preds = %seqcst_fail37.i
  store i64 %77, ptr %16, align 8
  br label %cmpxchg.continue46.i

cmpxchg.continue46.i:                             ; preds = %cmpxchg.store_expected45.i, %seqcst_fail37.i
  %frombool47.i = zext i1 %78 to i8
  store i8 %frombool47.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

monotonic_fail48.i:                               ; preds = %seqcst.i10
  %79 = load i64, ptr %16, align 8
  %80 = load i64, ptr %.atomictmp.i, align 8
  %81 = cmpxchg weak ptr %this1.i9, i64 %79, i64 %80 seq_cst monotonic, align 8
  %82 = extractvalue { i64, i1 } %81, 0
  %83 = extractvalue { i64, i1 } %81, 1
  br i1 %83, label %cmpxchg.continue53.i, label %cmpxchg.store_expected52.i

acquire_fail49.i:                                 ; preds = %seqcst.i10, %seqcst.i10
  %84 = load i64, ptr %16, align 8
  %85 = load i64, ptr %.atomictmp.i, align 8
  %86 = cmpxchg weak ptr %this1.i9, i64 %84, i64 %85 seq_cst acquire, align 8
  %87 = extractvalue { i64, i1 } %86, 0
  %88 = extractvalue { i64, i1 } %86, 1
  br i1 %88, label %cmpxchg.continue56.i, label %cmpxchg.store_expected55.i

seqcst_fail50.i:                                  ; preds = %seqcst.i10
  %89 = load i64, ptr %16, align 8
  %90 = load i64, ptr %.atomictmp.i, align 8
  %91 = cmpxchg weak ptr %this1.i9, i64 %89, i64 %90 seq_cst seq_cst, align 8
  %92 = extractvalue { i64, i1 } %91, 0
  %93 = extractvalue { i64, i1 } %91, 1
  br i1 %93, label %cmpxchg.continue59.i, label %cmpxchg.store_expected58.i

atomic.continue51.i:                              ; preds = %cmpxchg.continue59.i, %cmpxchg.continue56.i, %cmpxchg.continue53.i
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected52.i:                       ; preds = %monotonic_fail48.i
  store i64 %82, ptr %16, align 8
  br label %cmpxchg.continue53.i

cmpxchg.continue53.i:                             ; preds = %cmpxchg.store_expected52.i, %monotonic_fail48.i
  %frombool54.i = zext i1 %83 to i8
  store i8 %frombool54.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected55.i:                       ; preds = %acquire_fail49.i
  store i64 %87, ptr %16, align 8
  br label %cmpxchg.continue56.i

cmpxchg.continue56.i:                             ; preds = %cmpxchg.store_expected55.i, %acquire_fail49.i
  %frombool57.i = zext i1 %88 to i8
  store i8 %frombool57.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected58.i:                       ; preds = %seqcst_fail50.i
  store i64 %92, ptr %16, align 8
  br label %cmpxchg.continue59.i

cmpxchg.continue59.i:                             ; preds = %cmpxchg.store_expected58.i, %seqcst_fail50.i
  %frombool60.i = zext i1 %93 to i8
  store i8 %frombool60.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit: ; preds = %atomic.continue51.i, %atomic.continue38.i, %atomic.continue25.i, %atomic.continue12.i, %atomic.continue2.i
  %94 = load i8, ptr %cmpxchg.bool.i, align 1
  %tobool.i = trunc i8 %94 to i1
  br i1 %tobool.i, label %if.then6, label %if.end7

if.then6:                                         ; preds = %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit
  store i1 true, ptr %retval, align 1
  br label %return

if.end7:                                          ; preds = %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit
  br label %for.cond, !llvm.loop !38

return:                                           ; preds = %if.then6, %if.then
  %95 = load i1, ptr %retval, align 1
  ret i1 %95
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i64 @_ZN4absl13base_internal7HidePtrISt6atomicIlEEEmPT_(ptr noundef %ptr) #0 comdat {
entry:
  %ptr.addr = alloca ptr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  %1 = ptrtoint ptr %0 to i64
  %call = call noundef i64 @_ZN4absl13base_internal8HideMaskEv()
  %xor = xor i64 %1, %call
  ret i64 %xor
}

; Function Attrs: nounwind willreturn memory(read)
declare i64 @strlen(ptr noundef) #6

declare noundef ptr @_ZN4absl13base_internal13LowLevelAlloc5AllocEm(i64 noundef) #3 section "malloc_hook"

; Function Attrs: nounwind
declare ptr @strcpy(ptr noundef, ptr noundef) #8

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN4absl13base_internal8SpinLock6UnlockEv(ptr noundef nonnull align 4 dereferenceable(4) %this) #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr.i9 = alloca ptr, align 8
  %__i.addr.i = alloca i32, align 4
  %__m.addr.i10 = alloca i32, align 4
  %.atomictmp.i = alloca i32, align 4
  %atomic-temp.i11 = alloca i32, align 4
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %lock_value = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %lockword_ = getelementptr inbounds %"class.absl::base_internal::SpinLock", ptr %this1, i32 0, i32 0
  store ptr %lockword_, ptr %this.addr.i, align 8
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %0 = load i32, ptr %__m.addr.i, align 4
  %call.i = invoke noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %0, i32 noundef 65535)
          to label %invoke.cont.i unwind label %terminate.lpad.i

invoke.cont.i:                                    ; preds = %entry
  store i32 %call.i, ptr %__b.i, align 4
  %1 = load i32, ptr %__m.addr.i, align 4
  switch i32 %1, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %invoke.cont.i
  %2 = load atomic i32, ptr %this1.i monotonic, align 4
  store i32 %2, ptr %atomic-temp.i, align 4
  br label %_ZNKSt13__atomic_baseIjE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %invoke.cont.i, %invoke.cont.i
  %3 = load atomic i32, ptr %this1.i acquire, align 4
  store i32 %3, ptr %atomic-temp.i, align 4
  br label %_ZNKSt13__atomic_baseIjE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %invoke.cont.i
  %4 = load atomic i32, ptr %this1.i seq_cst, align 4
  store i32 %4, ptr %atomic-temp.i, align 4
  br label %_ZNKSt13__atomic_baseIjE4loadESt12memory_order.exit

terminate.lpad.i:                                 ; preds = %entry
  %5 = landingpad { ptr, i32 }
          catch ptr null
  %6 = extractvalue { ptr, i32 } %5, 0
  call void @__clang_call_terminate(ptr %6) #14
  unreachable

_ZNKSt13__atomic_baseIjE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %7 = load i32, ptr %atomic-temp.i, align 4
  store i32 %7, ptr %lock_value, align 4
  %lockword_2 = getelementptr inbounds %"class.absl::base_internal::SpinLock", ptr %this1, i32 0, i32 0
  %8 = load i32, ptr %lock_value, align 4
  %and = and i32 %8, 2
  store ptr %lockword_2, ptr %this.addr.i9, align 8
  store i32 %and, ptr %__i.addr.i, align 4
  store i32 3, ptr %__m.addr.i10, align 4
  %this1.i12 = load ptr, ptr %this.addr.i9, align 8
  %9 = load i32, ptr %__m.addr.i10, align 4
  %10 = load i32, ptr %__i.addr.i, align 4
  store i32 %10, ptr %.atomictmp.i, align 4
  switch i32 %9, label %monotonic.i15 [
    i32 1, label %acquire.i14
    i32 2, label %acquire.i14
    i32 3, label %release.i
    i32 4, label %acqrel.i
    i32 5, label %seqcst.i13
  ]

monotonic.i15:                                    ; preds = %_ZNKSt13__atomic_baseIjE4loadESt12memory_order.exit
  %11 = load i32, ptr %.atomictmp.i, align 4
  %12 = atomicrmw xchg ptr %this1.i12, i32 %11 monotonic, align 4
  store i32 %12, ptr %atomic-temp.i11, align 4
  br label %_ZNSt13__atomic_baseIjE8exchangeEjSt12memory_order.exit

acquire.i14:                                      ; preds = %_ZNKSt13__atomic_baseIjE4loadESt12memory_order.exit, %_ZNKSt13__atomic_baseIjE4loadESt12memory_order.exit
  %13 = load i32, ptr %.atomictmp.i, align 4
  %14 = atomicrmw xchg ptr %this1.i12, i32 %13 acquire, align 4
  store i32 %14, ptr %atomic-temp.i11, align 4
  br label %_ZNSt13__atomic_baseIjE8exchangeEjSt12memory_order.exit

release.i:                                        ; preds = %_ZNKSt13__atomic_baseIjE4loadESt12memory_order.exit
  %15 = load i32, ptr %.atomictmp.i, align 4
  %16 = atomicrmw xchg ptr %this1.i12, i32 %15 release, align 4
  store i32 %16, ptr %atomic-temp.i11, align 4
  br label %_ZNSt13__atomic_baseIjE8exchangeEjSt12memory_order.exit

acqrel.i:                                         ; preds = %_ZNKSt13__atomic_baseIjE4loadESt12memory_order.exit
  %17 = load i32, ptr %.atomictmp.i, align 4
  %18 = atomicrmw xchg ptr %this1.i12, i32 %17 acq_rel, align 4
  store i32 %18, ptr %atomic-temp.i11, align 4
  br label %_ZNSt13__atomic_baseIjE8exchangeEjSt12memory_order.exit

seqcst.i13:                                       ; preds = %_ZNKSt13__atomic_baseIjE4loadESt12memory_order.exit
  %19 = load i32, ptr %.atomictmp.i, align 4
  %20 = atomicrmw xchg ptr %this1.i12, i32 %19 seq_cst, align 4
  store i32 %20, ptr %atomic-temp.i11, align 4
  br label %_ZNSt13__atomic_baseIjE8exchangeEjSt12memory_order.exit

_ZNSt13__atomic_baseIjE8exchangeEjSt12memory_order.exit: ; preds = %seqcst.i13, %acqrel.i, %release.i, %acquire.i14, %monotonic.i15
  %21 = load i32, ptr %atomic-temp.i11, align 4
  store i32 %21, ptr %lock_value, align 4
  %22 = load i32, ptr %lock_value, align 4
  %and4 = and i32 %22, 4
  %cmp = icmp ne i32 %and4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %_ZNSt13__atomic_baseIjE8exchangeEjSt12memory_order.exit
  call void @_ZN4absl13base_internal15SchedulingGuard18EnableReschedulingEb(i1 noundef zeroext true)
  br label %if.end

if.end:                                           ; preds = %if.then, %_ZNSt13__atomic_baseIjE8exchangeEjSt12memory_order.exit
  %23 = load i32, ptr %lock_value, align 4
  %and5 = and i32 %23, -8
  %cmp6 = icmp ne i32 %and5, 0
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  %24 = load i32, ptr %lock_value, align 4
  call void @_ZN4absl13base_internal8SpinLock10SlowUnlockEj(ptr noundef nonnull align 4 dereferenceable(4) %this1, i32 noundef %24) #16
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.end
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN4absl13base_internal8SpinLock11TryLockImplEv(ptr noundef nonnull align 4 dereferenceable(4) %this) #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %lock_value = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %lockword_ = getelementptr inbounds %"class.absl::base_internal::SpinLock", ptr %this1, i32 0, i32 0
  store ptr %lockword_, ptr %this.addr.i, align 8
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %0 = load i32, ptr %__m.addr.i, align 4
  %call.i = invoke noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %0, i32 noundef 65535)
          to label %invoke.cont.i unwind label %terminate.lpad.i

invoke.cont.i:                                    ; preds = %entry
  store i32 %call.i, ptr %__b.i, align 4
  %1 = load i32, ptr %__m.addr.i, align 4
  switch i32 %1, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %invoke.cont.i
  %2 = load atomic i32, ptr %this1.i monotonic, align 4
  store i32 %2, ptr %atomic-temp.i, align 4
  br label %_ZNKSt13__atomic_baseIjE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %invoke.cont.i, %invoke.cont.i
  %3 = load atomic i32, ptr %this1.i acquire, align 4
  store i32 %3, ptr %atomic-temp.i, align 4
  br label %_ZNKSt13__atomic_baseIjE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %invoke.cont.i
  %4 = load atomic i32, ptr %this1.i seq_cst, align 4
  store i32 %4, ptr %atomic-temp.i, align 4
  br label %_ZNKSt13__atomic_baseIjE4loadESt12memory_order.exit

terminate.lpad.i:                                 ; preds = %entry
  %5 = landingpad { ptr, i32 }
          catch ptr null
  %6 = extractvalue { ptr, i32 } %5, 0
  call void @__clang_call_terminate(ptr %6) #14
  unreachable

_ZNKSt13__atomic_baseIjE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %7 = load i32, ptr %atomic-temp.i, align 4
  store i32 %7, ptr %lock_value, align 4
  %8 = load i32, ptr %lock_value, align 4
  %call2 = call noundef i32 @_ZN4absl13base_internal8SpinLock15TryLockInternalEjj(ptr noundef nonnull align 4 dereferenceable(4) %this1, i32 noundef %8, i32 noundef 0)
  %and = and i32 %call2, 1
  %cmp = icmp eq i32 %and, 0
  ret i1 %cmp
}

; Function Attrs: cold
declare void @_ZN4absl13base_internal8SpinLock8SlowLockEv(ptr noundef nonnull align 4 dereferenceable(4)) #10

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZN4absl13base_internal8SpinLock15TryLockInternalEjj(ptr noundef nonnull align 4 dereferenceable(4) %this, i32 noundef %lock_value, i32 noundef %wait_cycles) #1 comdat align 2 {
entry:
  %this.addr.i = alloca ptr, align 8
  %__i1.addr.i = alloca ptr, align 8
  %__i2.addr.i = alloca i32, align 4
  %__m1.addr.i = alloca i32, align 4
  %__m2.addr.i = alloca i32, align 4
  %.atomictmp.i = alloca i32, align 4
  %cmpxchg.bool.i = alloca i8, align 1
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %lock_value.addr = alloca i32, align 4
  %wait_cycles.addr = alloca i32, align 4
  %sched_disabled_bit = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %lock_value, ptr %lock_value.addr, align 4
  store i32 %wait_cycles, ptr %wait_cycles.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %lock_value.addr, align 4
  %and = and i32 %0, 1
  %cmp = icmp ne i32 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %lock_value.addr, align 4
  store i32 %1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %sched_disabled_bit, align 4
  %2 = load i32, ptr %lock_value.addr, align 4
  %and2 = and i32 %2, 2
  %cmp3 = icmp eq i32 %and2, 0
  br i1 %cmp3, label %if.then4, label %if.end7

if.then4:                                         ; preds = %if.end
  %call = call noundef zeroext i1 @_ZN4absl13base_internal15SchedulingGuard19DisableReschedulingEv()
  br i1 %call, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.then4
  store i32 4, ptr %sched_disabled_bit, align 4
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.then4
  br label %if.end7

if.end7:                                          ; preds = %if.end6, %if.end
  %lockword_ = getelementptr inbounds %"class.absl::base_internal::SpinLock", ptr %this1, i32 0, i32 0
  %3 = load i32, ptr %lock_value.addr, align 4
  %or = or i32 1, %3
  %4 = load i32, ptr %wait_cycles.addr, align 4
  %or8 = or i32 %or, %4
  %5 = load i32, ptr %sched_disabled_bit, align 4
  %or9 = or i32 %or8, %5
  store ptr %lockword_, ptr %this.addr.i, align 8
  store ptr %lock_value.addr, ptr %__i1.addr.i, align 8
  store i32 %or9, ptr %__i2.addr.i, align 4
  store i32 2, ptr %__m1.addr.i, align 4
  store i32 0, ptr %__m2.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %6 = load i32, ptr %__m1.addr.i, align 4
  %7 = load ptr, ptr %__i1.addr.i, align 8
  %8 = load i32, ptr %__i2.addr.i, align 4
  store i32 %8, ptr %.atomictmp.i, align 4
  %9 = load i32, ptr %__m2.addr.i, align 4
  switch i32 %6, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 3, label %release.i
    i32 4, label %acqrel.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %if.end7
  switch i32 %9, label %monotonic_fail.i [
    i32 1, label %acquire_fail.i
    i32 2, label %acquire_fail.i
    i32 5, label %seqcst_fail.i
  ]

acquire.i:                                        ; preds = %if.end7, %if.end7
  switch i32 %9, label %monotonic_fail9.i [
    i32 1, label %acquire_fail10.i
    i32 2, label %acquire_fail10.i
    i32 5, label %seqcst_fail11.i
  ]

release.i:                                        ; preds = %if.end7
  switch i32 %9, label %monotonic_fail22.i [
    i32 1, label %acquire_fail23.i
    i32 2, label %acquire_fail23.i
    i32 5, label %seqcst_fail24.i
  ]

acqrel.i:                                         ; preds = %if.end7
  switch i32 %9, label %monotonic_fail35.i [
    i32 1, label %acquire_fail36.i
    i32 2, label %acquire_fail36.i
    i32 5, label %seqcst_fail37.i
  ]

seqcst.i:                                         ; preds = %if.end7
  switch i32 %9, label %monotonic_fail48.i [
    i32 1, label %acquire_fail49.i
    i32 2, label %acquire_fail49.i
    i32 5, label %seqcst_fail50.i
  ]

monotonic_fail.i:                                 ; preds = %monotonic.i
  %10 = load i32, ptr %7, align 4
  %11 = load i32, ptr %.atomictmp.i, align 4
  %12 = cmpxchg ptr %this1.i, i32 %10, i32 %11 monotonic monotonic, align 4
  %13 = extractvalue { i32, i1 } %12, 0
  %14 = extractvalue { i32, i1 } %12, 1
  br i1 %14, label %cmpxchg.continue.i, label %cmpxchg.store_expected.i

acquire_fail.i:                                   ; preds = %monotonic.i, %monotonic.i
  %15 = load i32, ptr %7, align 4
  %16 = load i32, ptr %.atomictmp.i, align 4
  %17 = cmpxchg ptr %this1.i, i32 %15, i32 %16 monotonic acquire, align 4
  %18 = extractvalue { i32, i1 } %17, 0
  %19 = extractvalue { i32, i1 } %17, 1
  br i1 %19, label %cmpxchg.continue4.i, label %cmpxchg.store_expected3.i

seqcst_fail.i:                                    ; preds = %monotonic.i
  %20 = load i32, ptr %7, align 4
  %21 = load i32, ptr %.atomictmp.i, align 4
  %22 = cmpxchg ptr %this1.i, i32 %20, i32 %21 monotonic seq_cst, align 4
  %23 = extractvalue { i32, i1 } %22, 0
  %24 = extractvalue { i32, i1 } %22, 1
  br i1 %24, label %cmpxchg.continue7.i, label %cmpxchg.store_expected6.i

atomic.continue2.i:                               ; preds = %cmpxchg.continue7.i, %cmpxchg.continue4.i, %cmpxchg.continue.i
  br label %_ZNSt13__atomic_baseIjE23compare_exchange_strongERjjSt12memory_orderS2_.exit

cmpxchg.store_expected.i:                         ; preds = %monotonic_fail.i
  store i32 %13, ptr %7, align 4
  br label %cmpxchg.continue.i

cmpxchg.continue.i:                               ; preds = %cmpxchg.store_expected.i, %monotonic_fail.i
  %frombool.i = zext i1 %14 to i8
  store i8 %frombool.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected3.i:                        ; preds = %acquire_fail.i
  store i32 %18, ptr %7, align 4
  br label %cmpxchg.continue4.i

cmpxchg.continue4.i:                              ; preds = %cmpxchg.store_expected3.i, %acquire_fail.i
  %frombool5.i = zext i1 %19 to i8
  store i8 %frombool5.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected6.i:                        ; preds = %seqcst_fail.i
  store i32 %23, ptr %7, align 4
  br label %cmpxchg.continue7.i

cmpxchg.continue7.i:                              ; preds = %cmpxchg.store_expected6.i, %seqcst_fail.i
  %frombool8.i = zext i1 %24 to i8
  store i8 %frombool8.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

monotonic_fail9.i:                                ; preds = %acquire.i
  %25 = load i32, ptr %7, align 4
  %26 = load i32, ptr %.atomictmp.i, align 4
  %27 = cmpxchg ptr %this1.i, i32 %25, i32 %26 acquire monotonic, align 4
  %28 = extractvalue { i32, i1 } %27, 0
  %29 = extractvalue { i32, i1 } %27, 1
  br i1 %29, label %cmpxchg.continue14.i, label %cmpxchg.store_expected13.i

acquire_fail10.i:                                 ; preds = %acquire.i, %acquire.i
  %30 = load i32, ptr %7, align 4
  %31 = load i32, ptr %.atomictmp.i, align 4
  %32 = cmpxchg ptr %this1.i, i32 %30, i32 %31 acquire acquire, align 4
  %33 = extractvalue { i32, i1 } %32, 0
  %34 = extractvalue { i32, i1 } %32, 1
  br i1 %34, label %cmpxchg.continue17.i, label %cmpxchg.store_expected16.i

seqcst_fail11.i:                                  ; preds = %acquire.i
  %35 = load i32, ptr %7, align 4
  %36 = load i32, ptr %.atomictmp.i, align 4
  %37 = cmpxchg ptr %this1.i, i32 %35, i32 %36 acquire seq_cst, align 4
  %38 = extractvalue { i32, i1 } %37, 0
  %39 = extractvalue { i32, i1 } %37, 1
  br i1 %39, label %cmpxchg.continue20.i, label %cmpxchg.store_expected19.i

atomic.continue12.i:                              ; preds = %cmpxchg.continue20.i, %cmpxchg.continue17.i, %cmpxchg.continue14.i
  br label %_ZNSt13__atomic_baseIjE23compare_exchange_strongERjjSt12memory_orderS2_.exit

cmpxchg.store_expected13.i:                       ; preds = %monotonic_fail9.i
  store i32 %28, ptr %7, align 4
  br label %cmpxchg.continue14.i

cmpxchg.continue14.i:                             ; preds = %cmpxchg.store_expected13.i, %monotonic_fail9.i
  %frombool15.i = zext i1 %29 to i8
  store i8 %frombool15.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected16.i:                       ; preds = %acquire_fail10.i
  store i32 %33, ptr %7, align 4
  br label %cmpxchg.continue17.i

cmpxchg.continue17.i:                             ; preds = %cmpxchg.store_expected16.i, %acquire_fail10.i
  %frombool18.i = zext i1 %34 to i8
  store i8 %frombool18.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected19.i:                       ; preds = %seqcst_fail11.i
  store i32 %38, ptr %7, align 4
  br label %cmpxchg.continue20.i

cmpxchg.continue20.i:                             ; preds = %cmpxchg.store_expected19.i, %seqcst_fail11.i
  %frombool21.i = zext i1 %39 to i8
  store i8 %frombool21.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

monotonic_fail22.i:                               ; preds = %release.i
  %40 = load i32, ptr %7, align 4
  %41 = load i32, ptr %.atomictmp.i, align 4
  %42 = cmpxchg ptr %this1.i, i32 %40, i32 %41 release monotonic, align 4
  %43 = extractvalue { i32, i1 } %42, 0
  %44 = extractvalue { i32, i1 } %42, 1
  br i1 %44, label %cmpxchg.continue27.i, label %cmpxchg.store_expected26.i

acquire_fail23.i:                                 ; preds = %release.i, %release.i
  %45 = load i32, ptr %7, align 4
  %46 = load i32, ptr %.atomictmp.i, align 4
  %47 = cmpxchg ptr %this1.i, i32 %45, i32 %46 release acquire, align 4
  %48 = extractvalue { i32, i1 } %47, 0
  %49 = extractvalue { i32, i1 } %47, 1
  br i1 %49, label %cmpxchg.continue30.i, label %cmpxchg.store_expected29.i

seqcst_fail24.i:                                  ; preds = %release.i
  %50 = load i32, ptr %7, align 4
  %51 = load i32, ptr %.atomictmp.i, align 4
  %52 = cmpxchg ptr %this1.i, i32 %50, i32 %51 release seq_cst, align 4
  %53 = extractvalue { i32, i1 } %52, 0
  %54 = extractvalue { i32, i1 } %52, 1
  br i1 %54, label %cmpxchg.continue33.i, label %cmpxchg.store_expected32.i

atomic.continue25.i:                              ; preds = %cmpxchg.continue33.i, %cmpxchg.continue30.i, %cmpxchg.continue27.i
  br label %_ZNSt13__atomic_baseIjE23compare_exchange_strongERjjSt12memory_orderS2_.exit

cmpxchg.store_expected26.i:                       ; preds = %monotonic_fail22.i
  store i32 %43, ptr %7, align 4
  br label %cmpxchg.continue27.i

cmpxchg.continue27.i:                             ; preds = %cmpxchg.store_expected26.i, %monotonic_fail22.i
  %frombool28.i = zext i1 %44 to i8
  store i8 %frombool28.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected29.i:                       ; preds = %acquire_fail23.i
  store i32 %48, ptr %7, align 4
  br label %cmpxchg.continue30.i

cmpxchg.continue30.i:                             ; preds = %cmpxchg.store_expected29.i, %acquire_fail23.i
  %frombool31.i = zext i1 %49 to i8
  store i8 %frombool31.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected32.i:                       ; preds = %seqcst_fail24.i
  store i32 %53, ptr %7, align 4
  br label %cmpxchg.continue33.i

cmpxchg.continue33.i:                             ; preds = %cmpxchg.store_expected32.i, %seqcst_fail24.i
  %frombool34.i = zext i1 %54 to i8
  store i8 %frombool34.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

monotonic_fail35.i:                               ; preds = %acqrel.i
  %55 = load i32, ptr %7, align 4
  %56 = load i32, ptr %.atomictmp.i, align 4
  %57 = cmpxchg ptr %this1.i, i32 %55, i32 %56 acq_rel monotonic, align 4
  %58 = extractvalue { i32, i1 } %57, 0
  %59 = extractvalue { i32, i1 } %57, 1
  br i1 %59, label %cmpxchg.continue40.i, label %cmpxchg.store_expected39.i

acquire_fail36.i:                                 ; preds = %acqrel.i, %acqrel.i
  %60 = load i32, ptr %7, align 4
  %61 = load i32, ptr %.atomictmp.i, align 4
  %62 = cmpxchg ptr %this1.i, i32 %60, i32 %61 acq_rel acquire, align 4
  %63 = extractvalue { i32, i1 } %62, 0
  %64 = extractvalue { i32, i1 } %62, 1
  br i1 %64, label %cmpxchg.continue43.i, label %cmpxchg.store_expected42.i

seqcst_fail37.i:                                  ; preds = %acqrel.i
  %65 = load i32, ptr %7, align 4
  %66 = load i32, ptr %.atomictmp.i, align 4
  %67 = cmpxchg ptr %this1.i, i32 %65, i32 %66 acq_rel seq_cst, align 4
  %68 = extractvalue { i32, i1 } %67, 0
  %69 = extractvalue { i32, i1 } %67, 1
  br i1 %69, label %cmpxchg.continue46.i, label %cmpxchg.store_expected45.i

atomic.continue38.i:                              ; preds = %cmpxchg.continue46.i, %cmpxchg.continue43.i, %cmpxchg.continue40.i
  br label %_ZNSt13__atomic_baseIjE23compare_exchange_strongERjjSt12memory_orderS2_.exit

cmpxchg.store_expected39.i:                       ; preds = %monotonic_fail35.i
  store i32 %58, ptr %7, align 4
  br label %cmpxchg.continue40.i

cmpxchg.continue40.i:                             ; preds = %cmpxchg.store_expected39.i, %monotonic_fail35.i
  %frombool41.i = zext i1 %59 to i8
  store i8 %frombool41.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected42.i:                       ; preds = %acquire_fail36.i
  store i32 %63, ptr %7, align 4
  br label %cmpxchg.continue43.i

cmpxchg.continue43.i:                             ; preds = %cmpxchg.store_expected42.i, %acquire_fail36.i
  %frombool44.i = zext i1 %64 to i8
  store i8 %frombool44.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected45.i:                       ; preds = %seqcst_fail37.i
  store i32 %68, ptr %7, align 4
  br label %cmpxchg.continue46.i

cmpxchg.continue46.i:                             ; preds = %cmpxchg.store_expected45.i, %seqcst_fail37.i
  %frombool47.i = zext i1 %69 to i8
  store i8 %frombool47.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

monotonic_fail48.i:                               ; preds = %seqcst.i
  %70 = load i32, ptr %7, align 4
  %71 = load i32, ptr %.atomictmp.i, align 4
  %72 = cmpxchg ptr %this1.i, i32 %70, i32 %71 seq_cst monotonic, align 4
  %73 = extractvalue { i32, i1 } %72, 0
  %74 = extractvalue { i32, i1 } %72, 1
  br i1 %74, label %cmpxchg.continue53.i, label %cmpxchg.store_expected52.i

acquire_fail49.i:                                 ; preds = %seqcst.i, %seqcst.i
  %75 = load i32, ptr %7, align 4
  %76 = load i32, ptr %.atomictmp.i, align 4
  %77 = cmpxchg ptr %this1.i, i32 %75, i32 %76 seq_cst acquire, align 4
  %78 = extractvalue { i32, i1 } %77, 0
  %79 = extractvalue { i32, i1 } %77, 1
  br i1 %79, label %cmpxchg.continue56.i, label %cmpxchg.store_expected55.i

seqcst_fail50.i:                                  ; preds = %seqcst.i
  %80 = load i32, ptr %7, align 4
  %81 = load i32, ptr %.atomictmp.i, align 4
  %82 = cmpxchg ptr %this1.i, i32 %80, i32 %81 seq_cst seq_cst, align 4
  %83 = extractvalue { i32, i1 } %82, 0
  %84 = extractvalue { i32, i1 } %82, 1
  br i1 %84, label %cmpxchg.continue59.i, label %cmpxchg.store_expected58.i

atomic.continue51.i:                              ; preds = %cmpxchg.continue59.i, %cmpxchg.continue56.i, %cmpxchg.continue53.i
  br label %_ZNSt13__atomic_baseIjE23compare_exchange_strongERjjSt12memory_orderS2_.exit

cmpxchg.store_expected52.i:                       ; preds = %monotonic_fail48.i
  store i32 %73, ptr %7, align 4
  br label %cmpxchg.continue53.i

cmpxchg.continue53.i:                             ; preds = %cmpxchg.store_expected52.i, %monotonic_fail48.i
  %frombool54.i = zext i1 %74 to i8
  store i8 %frombool54.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected55.i:                       ; preds = %acquire_fail49.i
  store i32 %78, ptr %7, align 4
  br label %cmpxchg.continue56.i

cmpxchg.continue56.i:                             ; preds = %cmpxchg.store_expected55.i, %acquire_fail49.i
  %frombool57.i = zext i1 %79 to i8
  store i8 %frombool57.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected58.i:                       ; preds = %seqcst_fail50.i
  store i32 %83, ptr %7, align 4
  br label %cmpxchg.continue59.i

cmpxchg.continue59.i:                             ; preds = %cmpxchg.store_expected58.i, %seqcst_fail50.i
  %frombool60.i = zext i1 %84 to i8
  store i8 %frombool60.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

_ZNSt13__atomic_baseIjE23compare_exchange_strongERjjSt12memory_orderS2_.exit: ; preds = %atomic.continue51.i, %atomic.continue38.i, %atomic.continue25.i, %atomic.continue12.i, %atomic.continue2.i
  %85 = load i8, ptr %cmpxchg.bool.i, align 1
  %tobool.i = trunc i8 %85 to i1
  br i1 %tobool.i, label %if.end13, label %if.then11

if.then11:                                        ; preds = %_ZNSt13__atomic_baseIjE23compare_exchange_strongERjjSt12memory_orderS2_.exit
  %86 = load i32, ptr %sched_disabled_bit, align 4
  %cmp12 = icmp ne i32 %86, 0
  call void @_ZN4absl13base_internal15SchedulingGuard18EnableReschedulingEb(i1 noundef zeroext %cmp12)
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %_ZNSt13__atomic_baseIjE23compare_exchange_strongERjjSt12memory_orderS2_.exit
  %87 = load i32, ptr %lock_value.addr, align 4
  store i32 %87, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end13, %if.then
  %88 = load i32, ptr %retval, align 4
  ret i32 %88
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZN4absl13base_internal8HideMaskEv() #1 comdat {
entry:
  ret i64 -1136490970041655429
}

; Function Attrs: cold
declare void @_ZN4absl13base_internal8SpinLock10SlowUnlockEj(ptr noundef nonnull align 4 dereferenceable(4), i32 noundef) #10

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local i64 @_ZN4absl24synchronization_internal14InvalidGraphIdEv() #1 comdat {
entry:
  %retval = alloca %"struct.absl::synchronization_internal::GraphId", align 8
  %handle = getelementptr inbounds %"struct.absl::synchronization_internal::GraphId", ptr %retval, i32 0, i32 0
  store i64 0, ptr %handle, align 8
  %coerce.dive = getelementptr inbounds %"struct.absl::synchronization_internal::GraphId", ptr %retval, i32 0, i32 0
  %0 = load i64, ptr %coerce.dive, align 8
  ret i64 %0
}

; Function Attrs: mustprogress uwtable
define internal noundef ptr @_ZN4abslL18Synch_GetPerThreadEv() #0 {
entry:
  %identity = alloca ptr, align 8
  %call = call noundef ptr @_ZN4absl24synchronization_internal32GetOrCreateCurrentThreadIdentityEv()
  store ptr %call, ptr %identity, align 8
  %0 = load ptr, ptr %identity, align 8
  %per_thread_synch = getelementptr inbounds %"struct.absl::base_internal::ThreadIdentity", ptr %0, i32 0, i32 0
  ret ptr %per_thread_synch
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN4absl24synchronization_internal32GetOrCreateCurrentThreadIdentityEv() #0 comdat {
entry:
  %retval = alloca ptr, align 8
  %identity = alloca ptr, align 8
  %call = call noundef ptr @_ZN4absl13base_internal30CurrentThreadIdentityIfPresentEv()
  store ptr %call, ptr %identity, align 8
  %0 = load ptr, ptr %identity, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call noundef ptr @_ZN4absl24synchronization_internal20CreateThreadIdentityEv()
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %identity, align 8
  store ptr %1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

declare noundef ptr @_ZN4absl24synchronization_internal20CreateThreadIdentityEv() #3

declare noundef i32 @_ZN4absl13GetStackTraceEPPvii(ptr noundef, i32 noundef, i32 noundef) #3

; Function Attrs: nounwind
declare i32 @snprintf(ptr noundef, i64 noundef, ptr noundef, ...) #8

; Function Attrs: mustprogress uwtable
define internal noundef zeroext i1 @_ZZN4abslL14PostSynchEventEPviEN5local4predEPNS_10SynchEventE(ptr noundef %ev) #0 align 2 {
entry:
  %ev.addr = alloca ptr, align 8
  store ptr %ev, ptr %ev.addr, align 8
  %0 = load ptr, ptr %ev.addr, align 8
  %invariant = getelementptr inbounds %"struct.absl::SynchEvent", ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %invariant, align 8
  %2 = load ptr, ptr %ev.addr, align 8
  %arg = getelementptr inbounds %"struct.absl::SynchEvent", ptr %2, i32 0, i32 4
  %3 = load ptr, ptr %arg, align 8
  call void %1(ptr noundef %3)
  ret i1 false
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN4absl9ConditionC2INS_10SynchEventEEEPFbPT_ES4_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef %func, ptr noundef %arg) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %func.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %func, ptr %func.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %callback_ = getelementptr inbounds %"class.absl::Condition", ptr %this1, i32 0, i32 0
  %arrayinit.begin = getelementptr inbounds [16 x i8], ptr %callback_, i64 0, i64 0
  store i8 0, ptr %arrayinit.begin, align 1
  %arrayinit.start = getelementptr inbounds i8, ptr %arrayinit.begin, i64 1
  %arrayinit.end = getelementptr inbounds i8, ptr %arrayinit.begin, i64 16
  br label %arrayinit.body

arrayinit.body:                                   ; preds = %arrayinit.body, %entry
  %arrayinit.cur = phi ptr [ %arrayinit.start, %entry ], [ %arrayinit.next, %arrayinit.body ]
  store i8 0, ptr %arrayinit.cur, align 1
  %arrayinit.next = getelementptr inbounds i8, ptr %arrayinit.cur, i64 1
  %arrayinit.done = icmp eq ptr %arrayinit.next, %arrayinit.end
  br i1 %arrayinit.done, label %arrayinit.end2, label %arrayinit.body

arrayinit.end2:                                   ; preds = %arrayinit.body
  %eval_ = getelementptr inbounds %"class.absl::Condition", ptr %this1, i32 0, i32 1
  store ptr @_ZN4absl9Condition19CastAndCallFunctionINS_10SynchEventEEEbPKS0_, ptr %eval_, align 8
  %arg_ = getelementptr inbounds %"class.absl::Condition", ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %arg.addr, align 8
  store ptr %0, ptr %arg_, align 8
  %1 = load ptr, ptr %func.addr, align 8
  call void @_ZN4absl9Condition13StoreCallbackIPFbPNS_10SynchEventEEEEvT_(ptr noundef nonnull align 8 dereferenceable(32) %this1, ptr noundef %1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN4absl9Condition19CastAndCallFunctionINS_10SynchEventEEEbPKS0_(ptr noundef %c) #0 comdat align 2 {
entry:
  %c.addr = alloca ptr, align 8
  %function = alloca ptr, align 8
  %argument = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  call void @_ZNK4absl9Condition12ReadCallbackIPFbPNS_10SynchEventEEEEvPT_(ptr noundef nonnull align 8 dereferenceable(32) %0, ptr noundef %function)
  %1 = load ptr, ptr %c.addr, align 8
  %arg_ = getelementptr inbounds %"class.absl::Condition", ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %arg_, align 8
  store ptr %2, ptr %argument, align 8
  %3 = load ptr, ptr %function, align 8
  %4 = load ptr, ptr %argument, align 8
  %call = call noundef zeroext i1 %3(ptr noundef %4)
  ret i1 %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN4absl9Condition13StoreCallbackIPFbPNS_10SynchEventEEEEvT_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef %callback) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %callback.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %callback, ptr %callback.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %callback_ = getelementptr inbounds %"class.absl::Condition", ptr %this1, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i8], ptr %callback_, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay, ptr align 8 %callback.addr, i64 8, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZNK4absl9Condition12ReadCallbackIPFbPNS_10SynchEventEEEEvPT_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef %callback) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %callback.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %callback, ptr %callback.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %callback.addr, align 8
  %callback_ = getelementptr inbounds %"class.absl::Condition", ptr %this1, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i8], ptr %callback_, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %0, ptr align 8 %arraydecay, i64 8, i1 false)
  ret void
}

; Function Attrs: cold noreturn nounwind memory(inaccessiblemem: write)
declare void @llvm.trap() #11

; Function Attrs: mustprogress uwtable
define internal void @_ZN4abslL14CondVarEnqueueEPNS_15SynchWaitParamsE(ptr noundef %waitp) #0 {
entry:
  %this.addr.i45 = alloca ptr, align 8
  %__i.addr.i = alloca i64, align 8
  %__m.addr.i46 = alloca i32, align 4
  %__b.i47 = alloca i32, align 4
  %.atomictmp.i48 = alloca i64, align 8
  %this.addr.i40 = alloca ptr, align 8
  %__i1.addr.i = alloca ptr, align 8
  %__i2.addr.i = alloca i64, align 8
  %__m1.addr.i = alloca i32, align 4
  %__m2.addr.i = alloca i32, align 4
  %.atomictmp.i = alloca i64, align 8
  %cmpxchg.bool.i = alloca i8, align 1
  %this.addr.i30 = alloca ptr, align 8
  %__m.addr.i31 = alloca i32, align 4
  %__b.i32 = alloca i32, align 4
  %atomic-temp.i33 = alloca i64, align 8
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca i64, align 8
  %waitp.addr = alloca ptr, align 8
  %cv_word = alloca ptr, align 8
  %v = alloca i64, align 8
  %c = alloca i32, align 4
  %absl_raw_log_internal_basename = alloca ptr, align 8
  %h = alloca ptr, align 8
  store ptr %waitp, ptr %waitp.addr, align 8
  %0 = load ptr, ptr %waitp.addr, align 8
  %cv_word1 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %0, i32 0, i32 5
  %1 = load ptr, ptr %cv_word1, align 8
  store ptr %1, ptr %cv_word, align 8
  %2 = load ptr, ptr %waitp.addr, align 8
  %cv_word2 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %2, i32 0, i32 5
  store ptr null, ptr %cv_word2, align 8
  %3 = load ptr, ptr %cv_word, align 8
  store ptr %3, ptr %this.addr.i30, align 8
  store i32 0, ptr %__m.addr.i31, align 4
  %this1.i34 = load ptr, ptr %this.addr.i30, align 8
  %4 = load i32, ptr %__m.addr.i31, align 4
  %call.i35 = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %4, i32 noundef 65535)
  store i32 %call.i35, ptr %__b.i32, align 4
  %5 = load i32, ptr %__m.addr.i31, align 4
  switch i32 %5, label %monotonic.i38 [
    i32 1, label %acquire.i37
    i32 2, label %acquire.i37
    i32 5, label %seqcst.i36
  ]

monotonic.i38:                                    ; preds = %entry
  %6 = load atomic i64, ptr %this1.i34 monotonic, align 8
  store i64 %6, ptr %atomic-temp.i33, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit39

acquire.i37:                                      ; preds = %entry, %entry
  %7 = load atomic i64, ptr %this1.i34 acquire, align 8
  store i64 %7, ptr %atomic-temp.i33, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit39

seqcst.i36:                                       ; preds = %entry
  %8 = load atomic i64, ptr %this1.i34 seq_cst, align 8
  store i64 %8, ptr %atomic-temp.i33, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit39

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit39: ; preds = %seqcst.i36, %acquire.i37, %monotonic.i38
  %9 = load i64, ptr %atomic-temp.i33, align 8
  store i64 %9, ptr %v, align 8
  store i32 0, ptr %c, align 4
  br label %while.cond

while.cond:                                       ; preds = %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit, %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit39
  %10 = load i64, ptr %v, align 8
  %and = and i64 %10, 1
  %cmp = icmp ne i64 %and, 0
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %while.cond
  %11 = load ptr, ptr %cv_word, align 8
  %12 = load i64, ptr %v, align 8
  %or = or i64 %12, 1
  store ptr %11, ptr %this.addr.i40, align 8
  store ptr %v, ptr %__i1.addr.i, align 8
  store i64 %or, ptr %__i2.addr.i, align 8
  store i32 2, ptr %__m1.addr.i, align 4
  store i32 0, ptr %__m2.addr.i, align 4
  %this1.i41 = load ptr, ptr %this.addr.i40, align 8
  %13 = load i32, ptr %__m1.addr.i, align 4
  %14 = load ptr, ptr %__i1.addr.i, align 8
  %15 = load i64, ptr %__i2.addr.i, align 8
  store i64 %15, ptr %.atomictmp.i, align 8
  %16 = load i32, ptr %__m2.addr.i, align 4
  switch i32 %13, label %monotonic.i44 [
    i32 1, label %acquire.i43
    i32 2, label %acquire.i43
    i32 3, label %release.i
    i32 4, label %acqrel.i
    i32 5, label %seqcst.i42
  ]

monotonic.i44:                                    ; preds = %lor.rhs
  switch i32 %16, label %monotonic_fail.i [
    i32 1, label %acquire_fail.i
    i32 2, label %acquire_fail.i
    i32 5, label %seqcst_fail.i
  ]

acquire.i43:                                      ; preds = %lor.rhs, %lor.rhs
  switch i32 %16, label %monotonic_fail9.i [
    i32 1, label %acquire_fail10.i
    i32 2, label %acquire_fail10.i
    i32 5, label %seqcst_fail11.i
  ]

release.i:                                        ; preds = %lor.rhs
  switch i32 %16, label %monotonic_fail22.i [
    i32 1, label %acquire_fail23.i
    i32 2, label %acquire_fail23.i
    i32 5, label %seqcst_fail24.i
  ]

acqrel.i:                                         ; preds = %lor.rhs
  switch i32 %16, label %monotonic_fail35.i [
    i32 1, label %acquire_fail36.i
    i32 2, label %acquire_fail36.i
    i32 5, label %seqcst_fail37.i
  ]

seqcst.i42:                                       ; preds = %lor.rhs
  switch i32 %16, label %monotonic_fail48.i [
    i32 1, label %acquire_fail49.i
    i32 2, label %acquire_fail49.i
    i32 5, label %seqcst_fail50.i
  ]

monotonic_fail.i:                                 ; preds = %monotonic.i44
  %17 = load i64, ptr %14, align 8
  %18 = load i64, ptr %.atomictmp.i, align 8
  %19 = cmpxchg weak ptr %this1.i41, i64 %17, i64 %18 monotonic monotonic, align 8
  %20 = extractvalue { i64, i1 } %19, 0
  %21 = extractvalue { i64, i1 } %19, 1
  br i1 %21, label %cmpxchg.continue.i, label %cmpxchg.store_expected.i

acquire_fail.i:                                   ; preds = %monotonic.i44, %monotonic.i44
  %22 = load i64, ptr %14, align 8
  %23 = load i64, ptr %.atomictmp.i, align 8
  %24 = cmpxchg weak ptr %this1.i41, i64 %22, i64 %23 monotonic acquire, align 8
  %25 = extractvalue { i64, i1 } %24, 0
  %26 = extractvalue { i64, i1 } %24, 1
  br i1 %26, label %cmpxchg.continue4.i, label %cmpxchg.store_expected3.i

seqcst_fail.i:                                    ; preds = %monotonic.i44
  %27 = load i64, ptr %14, align 8
  %28 = load i64, ptr %.atomictmp.i, align 8
  %29 = cmpxchg weak ptr %this1.i41, i64 %27, i64 %28 monotonic seq_cst, align 8
  %30 = extractvalue { i64, i1 } %29, 0
  %31 = extractvalue { i64, i1 } %29, 1
  br i1 %31, label %cmpxchg.continue7.i, label %cmpxchg.store_expected6.i

atomic.continue2.i:                               ; preds = %cmpxchg.continue7.i, %cmpxchg.continue4.i, %cmpxchg.continue.i
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected.i:                         ; preds = %monotonic_fail.i
  store i64 %20, ptr %14, align 8
  br label %cmpxchg.continue.i

cmpxchg.continue.i:                               ; preds = %cmpxchg.store_expected.i, %monotonic_fail.i
  %frombool.i = zext i1 %21 to i8
  store i8 %frombool.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected3.i:                        ; preds = %acquire_fail.i
  store i64 %25, ptr %14, align 8
  br label %cmpxchg.continue4.i

cmpxchg.continue4.i:                              ; preds = %cmpxchg.store_expected3.i, %acquire_fail.i
  %frombool5.i = zext i1 %26 to i8
  store i8 %frombool5.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected6.i:                        ; preds = %seqcst_fail.i
  store i64 %30, ptr %14, align 8
  br label %cmpxchg.continue7.i

cmpxchg.continue7.i:                              ; preds = %cmpxchg.store_expected6.i, %seqcst_fail.i
  %frombool8.i = zext i1 %31 to i8
  store i8 %frombool8.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

monotonic_fail9.i:                                ; preds = %acquire.i43
  %32 = load i64, ptr %14, align 8
  %33 = load i64, ptr %.atomictmp.i, align 8
  %34 = cmpxchg weak ptr %this1.i41, i64 %32, i64 %33 acquire monotonic, align 8
  %35 = extractvalue { i64, i1 } %34, 0
  %36 = extractvalue { i64, i1 } %34, 1
  br i1 %36, label %cmpxchg.continue14.i, label %cmpxchg.store_expected13.i

acquire_fail10.i:                                 ; preds = %acquire.i43, %acquire.i43
  %37 = load i64, ptr %14, align 8
  %38 = load i64, ptr %.atomictmp.i, align 8
  %39 = cmpxchg weak ptr %this1.i41, i64 %37, i64 %38 acquire acquire, align 8
  %40 = extractvalue { i64, i1 } %39, 0
  %41 = extractvalue { i64, i1 } %39, 1
  br i1 %41, label %cmpxchg.continue17.i, label %cmpxchg.store_expected16.i

seqcst_fail11.i:                                  ; preds = %acquire.i43
  %42 = load i64, ptr %14, align 8
  %43 = load i64, ptr %.atomictmp.i, align 8
  %44 = cmpxchg weak ptr %this1.i41, i64 %42, i64 %43 acquire seq_cst, align 8
  %45 = extractvalue { i64, i1 } %44, 0
  %46 = extractvalue { i64, i1 } %44, 1
  br i1 %46, label %cmpxchg.continue20.i, label %cmpxchg.store_expected19.i

atomic.continue12.i:                              ; preds = %cmpxchg.continue20.i, %cmpxchg.continue17.i, %cmpxchg.continue14.i
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected13.i:                       ; preds = %monotonic_fail9.i
  store i64 %35, ptr %14, align 8
  br label %cmpxchg.continue14.i

cmpxchg.continue14.i:                             ; preds = %cmpxchg.store_expected13.i, %monotonic_fail9.i
  %frombool15.i = zext i1 %36 to i8
  store i8 %frombool15.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected16.i:                       ; preds = %acquire_fail10.i
  store i64 %40, ptr %14, align 8
  br label %cmpxchg.continue17.i

cmpxchg.continue17.i:                             ; preds = %cmpxchg.store_expected16.i, %acquire_fail10.i
  %frombool18.i = zext i1 %41 to i8
  store i8 %frombool18.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected19.i:                       ; preds = %seqcst_fail11.i
  store i64 %45, ptr %14, align 8
  br label %cmpxchg.continue20.i

cmpxchg.continue20.i:                             ; preds = %cmpxchg.store_expected19.i, %seqcst_fail11.i
  %frombool21.i = zext i1 %46 to i8
  store i8 %frombool21.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

monotonic_fail22.i:                               ; preds = %release.i
  %47 = load i64, ptr %14, align 8
  %48 = load i64, ptr %.atomictmp.i, align 8
  %49 = cmpxchg weak ptr %this1.i41, i64 %47, i64 %48 release monotonic, align 8
  %50 = extractvalue { i64, i1 } %49, 0
  %51 = extractvalue { i64, i1 } %49, 1
  br i1 %51, label %cmpxchg.continue27.i, label %cmpxchg.store_expected26.i

acquire_fail23.i:                                 ; preds = %release.i, %release.i
  %52 = load i64, ptr %14, align 8
  %53 = load i64, ptr %.atomictmp.i, align 8
  %54 = cmpxchg weak ptr %this1.i41, i64 %52, i64 %53 release acquire, align 8
  %55 = extractvalue { i64, i1 } %54, 0
  %56 = extractvalue { i64, i1 } %54, 1
  br i1 %56, label %cmpxchg.continue30.i, label %cmpxchg.store_expected29.i

seqcst_fail24.i:                                  ; preds = %release.i
  %57 = load i64, ptr %14, align 8
  %58 = load i64, ptr %.atomictmp.i, align 8
  %59 = cmpxchg weak ptr %this1.i41, i64 %57, i64 %58 release seq_cst, align 8
  %60 = extractvalue { i64, i1 } %59, 0
  %61 = extractvalue { i64, i1 } %59, 1
  br i1 %61, label %cmpxchg.continue33.i, label %cmpxchg.store_expected32.i

atomic.continue25.i:                              ; preds = %cmpxchg.continue33.i, %cmpxchg.continue30.i, %cmpxchg.continue27.i
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected26.i:                       ; preds = %monotonic_fail22.i
  store i64 %50, ptr %14, align 8
  br label %cmpxchg.continue27.i

cmpxchg.continue27.i:                             ; preds = %cmpxchg.store_expected26.i, %monotonic_fail22.i
  %frombool28.i = zext i1 %51 to i8
  store i8 %frombool28.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected29.i:                       ; preds = %acquire_fail23.i
  store i64 %55, ptr %14, align 8
  br label %cmpxchg.continue30.i

cmpxchg.continue30.i:                             ; preds = %cmpxchg.store_expected29.i, %acquire_fail23.i
  %frombool31.i = zext i1 %56 to i8
  store i8 %frombool31.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected32.i:                       ; preds = %seqcst_fail24.i
  store i64 %60, ptr %14, align 8
  br label %cmpxchg.continue33.i

cmpxchg.continue33.i:                             ; preds = %cmpxchg.store_expected32.i, %seqcst_fail24.i
  %frombool34.i = zext i1 %61 to i8
  store i8 %frombool34.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

monotonic_fail35.i:                               ; preds = %acqrel.i
  %62 = load i64, ptr %14, align 8
  %63 = load i64, ptr %.atomictmp.i, align 8
  %64 = cmpxchg weak ptr %this1.i41, i64 %62, i64 %63 acq_rel monotonic, align 8
  %65 = extractvalue { i64, i1 } %64, 0
  %66 = extractvalue { i64, i1 } %64, 1
  br i1 %66, label %cmpxchg.continue40.i, label %cmpxchg.store_expected39.i

acquire_fail36.i:                                 ; preds = %acqrel.i, %acqrel.i
  %67 = load i64, ptr %14, align 8
  %68 = load i64, ptr %.atomictmp.i, align 8
  %69 = cmpxchg weak ptr %this1.i41, i64 %67, i64 %68 acq_rel acquire, align 8
  %70 = extractvalue { i64, i1 } %69, 0
  %71 = extractvalue { i64, i1 } %69, 1
  br i1 %71, label %cmpxchg.continue43.i, label %cmpxchg.store_expected42.i

seqcst_fail37.i:                                  ; preds = %acqrel.i
  %72 = load i64, ptr %14, align 8
  %73 = load i64, ptr %.atomictmp.i, align 8
  %74 = cmpxchg weak ptr %this1.i41, i64 %72, i64 %73 acq_rel seq_cst, align 8
  %75 = extractvalue { i64, i1 } %74, 0
  %76 = extractvalue { i64, i1 } %74, 1
  br i1 %76, label %cmpxchg.continue46.i, label %cmpxchg.store_expected45.i

atomic.continue38.i:                              ; preds = %cmpxchg.continue46.i, %cmpxchg.continue43.i, %cmpxchg.continue40.i
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected39.i:                       ; preds = %monotonic_fail35.i
  store i64 %65, ptr %14, align 8
  br label %cmpxchg.continue40.i

cmpxchg.continue40.i:                             ; preds = %cmpxchg.store_expected39.i, %monotonic_fail35.i
  %frombool41.i = zext i1 %66 to i8
  store i8 %frombool41.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected42.i:                       ; preds = %acquire_fail36.i
  store i64 %70, ptr %14, align 8
  br label %cmpxchg.continue43.i

cmpxchg.continue43.i:                             ; preds = %cmpxchg.store_expected42.i, %acquire_fail36.i
  %frombool44.i = zext i1 %71 to i8
  store i8 %frombool44.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected45.i:                       ; preds = %seqcst_fail37.i
  store i64 %75, ptr %14, align 8
  br label %cmpxchg.continue46.i

cmpxchg.continue46.i:                             ; preds = %cmpxchg.store_expected45.i, %seqcst_fail37.i
  %frombool47.i = zext i1 %76 to i8
  store i8 %frombool47.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

monotonic_fail48.i:                               ; preds = %seqcst.i42
  %77 = load i64, ptr %14, align 8
  %78 = load i64, ptr %.atomictmp.i, align 8
  %79 = cmpxchg weak ptr %this1.i41, i64 %77, i64 %78 seq_cst monotonic, align 8
  %80 = extractvalue { i64, i1 } %79, 0
  %81 = extractvalue { i64, i1 } %79, 1
  br i1 %81, label %cmpxchg.continue53.i, label %cmpxchg.store_expected52.i

acquire_fail49.i:                                 ; preds = %seqcst.i42, %seqcst.i42
  %82 = load i64, ptr %14, align 8
  %83 = load i64, ptr %.atomictmp.i, align 8
  %84 = cmpxchg weak ptr %this1.i41, i64 %82, i64 %83 seq_cst acquire, align 8
  %85 = extractvalue { i64, i1 } %84, 0
  %86 = extractvalue { i64, i1 } %84, 1
  br i1 %86, label %cmpxchg.continue56.i, label %cmpxchg.store_expected55.i

seqcst_fail50.i:                                  ; preds = %seqcst.i42
  %87 = load i64, ptr %14, align 8
  %88 = load i64, ptr %.atomictmp.i, align 8
  %89 = cmpxchg weak ptr %this1.i41, i64 %87, i64 %88 seq_cst seq_cst, align 8
  %90 = extractvalue { i64, i1 } %89, 0
  %91 = extractvalue { i64, i1 } %89, 1
  br i1 %91, label %cmpxchg.continue59.i, label %cmpxchg.store_expected58.i

atomic.continue51.i:                              ; preds = %cmpxchg.continue59.i, %cmpxchg.continue56.i, %cmpxchg.continue53.i
  br label %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit

cmpxchg.store_expected52.i:                       ; preds = %monotonic_fail48.i
  store i64 %80, ptr %14, align 8
  br label %cmpxchg.continue53.i

cmpxchg.continue53.i:                             ; preds = %cmpxchg.store_expected52.i, %monotonic_fail48.i
  %frombool54.i = zext i1 %81 to i8
  store i8 %frombool54.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected55.i:                       ; preds = %acquire_fail49.i
  store i64 %85, ptr %14, align 8
  br label %cmpxchg.continue56.i

cmpxchg.continue56.i:                             ; preds = %cmpxchg.store_expected55.i, %acquire_fail49.i
  %frombool57.i = zext i1 %86 to i8
  store i8 %frombool57.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected58.i:                       ; preds = %seqcst_fail50.i
  store i64 %90, ptr %14, align 8
  br label %cmpxchg.continue59.i

cmpxchg.continue59.i:                             ; preds = %cmpxchg.store_expected58.i, %seqcst_fail50.i
  %frombool60.i = zext i1 %91 to i8
  store i8 %frombool60.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit: ; preds = %atomic.continue51.i, %atomic.continue38.i, %atomic.continue25.i, %atomic.continue12.i, %atomic.continue2.i
  %92 = load i8, ptr %cmpxchg.bool.i, align 1
  %tobool.i = trunc i8 %92 to i1
  %lnot = xor i1 %tobool.i, true
  br label %lor.end

lor.end:                                          ; preds = %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit, %while.cond
  %93 = phi i1 [ true, %while.cond ], [ %lnot, %_ZNSt13__atomic_baseIlE21compare_exchange_weakERllSt12memory_orderS2_.exit ]
  br i1 %93, label %while.body, label %while.end

while.body:                                       ; preds = %lor.end
  %94 = load i32, ptr %c, align 4
  %call4 = call noundef i32 @_ZN4absl24synchronization_internal10MutexDelayEii(i32 noundef %94, i32 noundef 1)
  store i32 %call4, ptr %c, align 4
  %95 = load ptr, ptr %cv_word, align 8
  store ptr %95, ptr %this.addr.i, align 8
  store i32 0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %96 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %96, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %97 = load i32, ptr %__m.addr.i, align 4
  switch i32 %97, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %while.body
  %98 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %98, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %while.body, %while.body
  %99 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %99, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %while.body
  %100 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %100, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIlE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %101 = load i64, ptr %atomic-temp.i, align 8
  store i64 %101, ptr %v, align 8
  br label %while.cond, !llvm.loop !39

while.end:                                        ; preds = %lor.end
  br label %do.body

do.body:                                          ; preds = %while.end
  %102 = load ptr, ptr %waitp.addr, align 8
  %thread = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %102, i32 0, i32 4
  %103 = load ptr, ptr %thread, align 8
  %waitp6 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %103, i32 0, i32 9
  %104 = load ptr, ptr %waitp6, align 8
  %cmp7 = icmp eq ptr %104, null
  %lnot8 = xor i1 %cmp7, true
  br i1 %lnot8, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  br label %do.body9

do.body9:                                         ; preds = %if.then
  store ptr getelementptr (i8, ptr @.str, i64 120), ptr %absl_raw_log_internal_basename, align 8
  call void (i32, ptr, i32, ptr, ...) @_ZN4absl16raw_log_internal6RawLogENS_11LogSeverityEPKciS3_z(i32 noundef 3, ptr noundef getelementptr (i8, ptr @.str, i64 120), i32 noundef 2566, ptr noundef @.str.1, ptr noundef @.str.74, ptr noundef @.str.75)
  br label %do.body10

do.body10:                                        ; preds = %do.body9
  unreachable

do.end:                                           ; No predecessors!
  br label %do.end11

do.end11:                                         ; preds = %do.end
  br label %if.end

if.end:                                           ; preds = %do.end11, %do.body
  br label %do.end12

do.end12:                                         ; preds = %if.end
  %105 = load ptr, ptr %waitp.addr, align 8
  %106 = load ptr, ptr %waitp.addr, align 8
  %thread13 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %106, i32 0, i32 4
  %107 = load ptr, ptr %thread13, align 8
  %waitp14 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %107, i32 0, i32 9
  store ptr %105, ptr %waitp14, align 8
  %108 = load i64, ptr %v, align 8
  %and15 = and i64 %108, -4
  %109 = inttoptr i64 %and15 to ptr
  store ptr %109, ptr %h, align 8
  %110 = load ptr, ptr %h, align 8
  %cmp16 = icmp eq ptr %110, null
  br i1 %cmp16, label %if.then17, label %if.else

if.then17:                                        ; preds = %do.end12
  %111 = load ptr, ptr %waitp.addr, align 8
  %thread18 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %111, i32 0, i32 4
  %112 = load ptr, ptr %thread18, align 8
  %113 = load ptr, ptr %waitp.addr, align 8
  %thread19 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %113, i32 0, i32 4
  %114 = load ptr, ptr %thread19, align 8
  %next = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %114, i32 0, i32 0
  store ptr %112, ptr %next, align 8
  br label %if.end25

if.else:                                          ; preds = %do.end12
  %115 = load ptr, ptr %h, align 8
  %next20 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %115, i32 0, i32 0
  %116 = load ptr, ptr %next20, align 8
  %117 = load ptr, ptr %waitp.addr, align 8
  %thread21 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %117, i32 0, i32 4
  %118 = load ptr, ptr %thread21, align 8
  %next22 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %118, i32 0, i32 0
  store ptr %116, ptr %next22, align 8
  %119 = load ptr, ptr %waitp.addr, align 8
  %thread23 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %119, i32 0, i32 4
  %120 = load ptr, ptr %thread23, align 8
  %121 = load ptr, ptr %h, align 8
  %next24 = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %121, i32 0, i32 0
  store ptr %120, ptr %next24, align 8
  br label %if.end25

if.end25:                                         ; preds = %if.else, %if.then17
  %122 = load ptr, ptr %waitp.addr, align 8
  %thread26 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %122, i32 0, i32 4
  %123 = load ptr, ptr %thread26, align 8
  %state = getelementptr inbounds %"struct.absl::base_internal::PerThreadSynch", ptr %123, i32 0, i32 8
  call void @_ZNSt6atomicIN4absl13base_internal14PerThreadSynch5StateEE5storeES3_St12memory_order(ptr noundef nonnull align 4 dereferenceable(4) %state, i32 noundef 1, i32 noundef 0) #13
  %124 = load ptr, ptr %cv_word, align 8
  %125 = load i64, ptr %v, align 8
  %and27 = and i64 %125, 2
  %126 = load ptr, ptr %waitp.addr, align 8
  %thread28 = getelementptr inbounds %"struct.absl::SynchWaitParams", ptr %126, i32 0, i32 4
  %127 = load ptr, ptr %thread28, align 8
  %128 = ptrtoint ptr %127 to i64
  %or29 = or i64 %and27, %128
  store ptr %124, ptr %this.addr.i45, align 8
  store i64 %or29, ptr %__i.addr.i, align 8
  store i32 3, ptr %__m.addr.i46, align 4
  %this1.i49 = load ptr, ptr %this.addr.i45, align 8
  %129 = load i32, ptr %__m.addr.i46, align 4
  %call.i50 = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %129, i32 noundef 65535)
  store i32 %call.i50, ptr %__b.i47, align 4
  %130 = load i32, ptr %__m.addr.i46, align 4
  %131 = load i64, ptr %__i.addr.i, align 8
  store i64 %131, ptr %.atomictmp.i48, align 8
  switch i32 %130, label %monotonic.i53 [
    i32 3, label %release.i52
    i32 5, label %seqcst.i51
  ]

monotonic.i53:                                    ; preds = %if.end25
  %132 = load i64, ptr %.atomictmp.i48, align 8
  store atomic i64 %132, ptr %this1.i49 monotonic, align 8
  br label %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit

release.i52:                                      ; preds = %if.end25
  %133 = load i64, ptr %.atomictmp.i48, align 8
  store atomic i64 %133, ptr %this1.i49 release, align 8
  br label %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit

seqcst.i51:                                       ; preds = %if.end25
  %134 = load i64, ptr %.atomictmp.i48, align 8
  store atomic i64 %134, ptr %this1.i49 seq_cst, align 8
  br label %_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit

_ZNSt13__atomic_baseIlE5storeElSt12memory_order.exit: ; preds = %seqcst.i51, %release.i52, %monotonic.i53
  ret void
}

; Function Attrs: nounwind
declare i32 @pthread_getschedparam(i64 noundef, ptr noundef, ptr noundef) #8

; Function Attrs: nounwind willreturn memory(none)
declare i64 @pthread_self() #12

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef double @_ZN4absl13base_internal10CycleClock9FrequencyEv() #0 comdat align 2 {
entry:
  %call = call noundef double @_ZN4absl13base_internal18UnscaledCycleClock9FrequencyEv()
  %mul = fmul double 5.000000e-01, %call
  ret double %mul
}

declare noundef double @_ZN4absl13base_internal18UnscaledCycleClock9FrequencyEv() #3

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN4absl13base_internal10CycleClock20LoadCycleClockSourceEv() #1 comdat align 2 {
entry:
  %call = call noundef ptr @_ZNKSt6atomicIPFlvEE4loadESt12memory_order(ptr noundef nonnull align 8 dereferenceable(8) @_ZN4absl13base_internal10CycleClock19cycle_clock_source_E, i32 noundef 2) #13
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZN4absl13base_internal18UnscaledCycleClock3NowEv() #1 comdat align 2 {
entry:
  %low = alloca i64, align 8
  %high = alloca i64, align 8
  %0 = call { i64, i64 } asm sideeffect "rdtsc", "={ax},={dx},~{dirflag},~{fpsr},~{flags}"() #13, !srcloc !40
  %asmresult = extractvalue { i64, i64 } %0, 0
  %asmresult1 = extractvalue { i64, i64 } %0, 1
  store i64 %asmresult, ptr %low, align 8
  store i64 %asmresult1, ptr %high, align 8
  %1 = load i64, ptr %high, align 8
  %shl = shl i64 %1, 32
  %2 = load i64, ptr %low, align 8
  %or = or i64 %shl, %2
  ret i64 %or
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNKSt6atomicIPFlvEE4loadESt12memory_order(ptr noundef nonnull align 8 dereferenceable(8) %this, i32 noundef %__m) #1 comdat align 2 {
entry:
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %__m.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %__m, ptr %__m.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %_M_b = getelementptr inbounds %"struct.std::atomic.17", ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %__m.addr, align 4
  store ptr %_M_b, ptr %this.addr.i, align 8
  store i32 %0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %1 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %1, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %2 = load i32, ptr %__m.addr.i, align 4
  switch i32 %2, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %entry
  %3 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %3, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIPFlvEE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %entry, %entry
  %4 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %4, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIPFlvEE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %entry
  %5 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %5, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIPFlvEE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIPFlvEE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %6 = load ptr, ptr %atomic-temp.i, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZN4absl13base_internal7HidePtrIKvEEmPT_(ptr noundef %ptr) #1 comdat {
entry:
  %ptr.addr = alloca ptr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  %1 = ptrtoint ptr %0 to i64
  %call = call noundef i64 @_ZN4absl13base_internal8HideMaskEv()
  %xor = xor i64 %1, %call
  ret i64 %xor
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN4absl13base_internal10AtomicHookIPFvlEE7DoStoreES3_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %fn) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %fn.addr = alloca ptr, align 8
  %expected = alloca ptr, align 8
  %store_succeeded = alloca i8, align 1
  %same_value_already_stored = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  store ptr %fn, ptr %fn.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %default_fn_ = getelementptr inbounds %"class.absl::base_internal::AtomicHook", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %default_fn_, align 8
  store ptr %0, ptr %expected, align 8
  %hook_ = getelementptr inbounds %"class.absl::base_internal::AtomicHook", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %fn.addr, align 8
  %call = call noundef zeroext i1 @_ZNSt6atomicIPFvlEE23compare_exchange_strongERS1_S1_St12memory_orderS4_(ptr noundef nonnull align 8 dereferenceable(8) %hook_, ptr noundef nonnull align 8 dereferenceable(8) %expected, ptr noundef %1, i32 noundef 4, i32 noundef 2) #13
  %frombool = zext i1 %call to i8
  store i8 %frombool, ptr %store_succeeded, align 1
  %2 = load ptr, ptr %expected, align 8
  %3 = load ptr, ptr %fn.addr, align 8
  %cmp = icmp eq ptr %2, %3
  %frombool2 = zext i1 %cmp to i8
  store i8 %frombool2, ptr %same_value_already_stored, align 1
  %4 = load i8, ptr %store_succeeded, align 1
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %5 = load i8, ptr %same_value_already_stored, align 1
  %tobool3 = trunc i8 %5 to i1
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %6 = phi i1 [ true, %entry ], [ %tobool3, %lor.rhs ]
  ret i1 %6
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNSt6atomicIPFvlEE23compare_exchange_strongERS1_S1_St12memory_orderS4_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 8 dereferenceable(8) %__p1, ptr noundef %__p2, i32 noundef %__m1, i32 noundef %__m2) #1 comdat align 2 {
entry:
  %this.addr.i = alloca ptr, align 8
  %__p1.addr.i = alloca ptr, align 8
  %__p2.addr.i = alloca ptr, align 8
  %__m1.addr.i = alloca i32, align 4
  %__m2.addr.i = alloca i32, align 4
  %.atomictmp.i = alloca ptr, align 8
  %cmpxchg.bool.i = alloca i8, align 1
  %this.addr = alloca ptr, align 8
  %__p1.addr = alloca ptr, align 8
  %__p2.addr = alloca ptr, align 8
  %__m1.addr = alloca i32, align 4
  %__m2.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %__p1, ptr %__p1.addr, align 8
  store ptr %__p2, ptr %__p2.addr, align 8
  store i32 %__m1, ptr %__m1.addr, align 4
  store i32 %__m2, ptr %__m2.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %_M_b = getelementptr inbounds %"struct.std::atomic", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %__p1.addr, align 8
  %1 = load ptr, ptr %__p2.addr, align 8
  %2 = load i32, ptr %__m1.addr, align 4
  %3 = load i32, ptr %__m2.addr, align 4
  store ptr %_M_b, ptr %this.addr.i, align 8
  store ptr %0, ptr %__p1.addr.i, align 8
  store ptr %1, ptr %__p2.addr.i, align 8
  store i32 %2, ptr %__m1.addr.i, align 4
  store i32 %3, ptr %__m2.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %4 = load i32, ptr %__m1.addr.i, align 4
  %5 = load ptr, ptr %__p1.addr.i, align 8
  %6 = load ptr, ptr %__p2.addr.i, align 8
  store ptr %6, ptr %.atomictmp.i, align 8
  %7 = load i32, ptr %__m2.addr.i, align 4
  switch i32 %4, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 3, label %release.i
    i32 4, label %acqrel.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %entry
  switch i32 %7, label %monotonic_fail.i [
    i32 1, label %acquire_fail.i
    i32 2, label %acquire_fail.i
    i32 5, label %seqcst_fail.i
  ]

acquire.i:                                        ; preds = %entry, %entry
  switch i32 %7, label %monotonic_fail9.i [
    i32 1, label %acquire_fail10.i
    i32 2, label %acquire_fail10.i
    i32 5, label %seqcst_fail11.i
  ]

release.i:                                        ; preds = %entry
  switch i32 %7, label %monotonic_fail22.i [
    i32 1, label %acquire_fail23.i
    i32 2, label %acquire_fail23.i
    i32 5, label %seqcst_fail24.i
  ]

acqrel.i:                                         ; preds = %entry
  switch i32 %7, label %monotonic_fail35.i [
    i32 1, label %acquire_fail36.i
    i32 2, label %acquire_fail36.i
    i32 5, label %seqcst_fail37.i
  ]

seqcst.i:                                         ; preds = %entry
  switch i32 %7, label %monotonic_fail48.i [
    i32 1, label %acquire_fail49.i
    i32 2, label %acquire_fail49.i
    i32 5, label %seqcst_fail50.i
  ]

monotonic_fail.i:                                 ; preds = %monotonic.i
  %8 = load i64, ptr %5, align 8
  %9 = load i64, ptr %.atomictmp.i, align 8
  %10 = cmpxchg ptr %this1.i, i64 %8, i64 %9 monotonic monotonic, align 8
  %11 = extractvalue { i64, i1 } %10, 0
  %12 = extractvalue { i64, i1 } %10, 1
  br i1 %12, label %cmpxchg.continue.i, label %cmpxchg.store_expected.i

acquire_fail.i:                                   ; preds = %monotonic.i, %monotonic.i
  %13 = load i64, ptr %5, align 8
  %14 = load i64, ptr %.atomictmp.i, align 8
  %15 = cmpxchg ptr %this1.i, i64 %13, i64 %14 monotonic acquire, align 8
  %16 = extractvalue { i64, i1 } %15, 0
  %17 = extractvalue { i64, i1 } %15, 1
  br i1 %17, label %cmpxchg.continue4.i, label %cmpxchg.store_expected3.i

seqcst_fail.i:                                    ; preds = %monotonic.i
  %18 = load i64, ptr %5, align 8
  %19 = load i64, ptr %.atomictmp.i, align 8
  %20 = cmpxchg ptr %this1.i, i64 %18, i64 %19 monotonic seq_cst, align 8
  %21 = extractvalue { i64, i1 } %20, 0
  %22 = extractvalue { i64, i1 } %20, 1
  br i1 %22, label %cmpxchg.continue7.i, label %cmpxchg.store_expected6.i

atomic.continue2.i:                               ; preds = %cmpxchg.continue7.i, %cmpxchg.continue4.i, %cmpxchg.continue.i
  br label %_ZNSt13__atomic_baseIPFvlEE23compare_exchange_strongERS1_S1_St12memory_orderS4_.exit

cmpxchg.store_expected.i:                         ; preds = %monotonic_fail.i
  store i64 %11, ptr %5, align 8
  br label %cmpxchg.continue.i

cmpxchg.continue.i:                               ; preds = %cmpxchg.store_expected.i, %monotonic_fail.i
  %frombool.i = zext i1 %12 to i8
  store i8 %frombool.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected3.i:                        ; preds = %acquire_fail.i
  store i64 %16, ptr %5, align 8
  br label %cmpxchg.continue4.i

cmpxchg.continue4.i:                              ; preds = %cmpxchg.store_expected3.i, %acquire_fail.i
  %frombool5.i = zext i1 %17 to i8
  store i8 %frombool5.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected6.i:                        ; preds = %seqcst_fail.i
  store i64 %21, ptr %5, align 8
  br label %cmpxchg.continue7.i

cmpxchg.continue7.i:                              ; preds = %cmpxchg.store_expected6.i, %seqcst_fail.i
  %frombool8.i = zext i1 %22 to i8
  store i8 %frombool8.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

monotonic_fail9.i:                                ; preds = %acquire.i
  %23 = load i64, ptr %5, align 8
  %24 = load i64, ptr %.atomictmp.i, align 8
  %25 = cmpxchg ptr %this1.i, i64 %23, i64 %24 acquire monotonic, align 8
  %26 = extractvalue { i64, i1 } %25, 0
  %27 = extractvalue { i64, i1 } %25, 1
  br i1 %27, label %cmpxchg.continue14.i, label %cmpxchg.store_expected13.i

acquire_fail10.i:                                 ; preds = %acquire.i, %acquire.i
  %28 = load i64, ptr %5, align 8
  %29 = load i64, ptr %.atomictmp.i, align 8
  %30 = cmpxchg ptr %this1.i, i64 %28, i64 %29 acquire acquire, align 8
  %31 = extractvalue { i64, i1 } %30, 0
  %32 = extractvalue { i64, i1 } %30, 1
  br i1 %32, label %cmpxchg.continue17.i, label %cmpxchg.store_expected16.i

seqcst_fail11.i:                                  ; preds = %acquire.i
  %33 = load i64, ptr %5, align 8
  %34 = load i64, ptr %.atomictmp.i, align 8
  %35 = cmpxchg ptr %this1.i, i64 %33, i64 %34 acquire seq_cst, align 8
  %36 = extractvalue { i64, i1 } %35, 0
  %37 = extractvalue { i64, i1 } %35, 1
  br i1 %37, label %cmpxchg.continue20.i, label %cmpxchg.store_expected19.i

atomic.continue12.i:                              ; preds = %cmpxchg.continue20.i, %cmpxchg.continue17.i, %cmpxchg.continue14.i
  br label %_ZNSt13__atomic_baseIPFvlEE23compare_exchange_strongERS1_S1_St12memory_orderS4_.exit

cmpxchg.store_expected13.i:                       ; preds = %monotonic_fail9.i
  store i64 %26, ptr %5, align 8
  br label %cmpxchg.continue14.i

cmpxchg.continue14.i:                             ; preds = %cmpxchg.store_expected13.i, %monotonic_fail9.i
  %frombool15.i = zext i1 %27 to i8
  store i8 %frombool15.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected16.i:                       ; preds = %acquire_fail10.i
  store i64 %31, ptr %5, align 8
  br label %cmpxchg.continue17.i

cmpxchg.continue17.i:                             ; preds = %cmpxchg.store_expected16.i, %acquire_fail10.i
  %frombool18.i = zext i1 %32 to i8
  store i8 %frombool18.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected19.i:                       ; preds = %seqcst_fail11.i
  store i64 %36, ptr %5, align 8
  br label %cmpxchg.continue20.i

cmpxchg.continue20.i:                             ; preds = %cmpxchg.store_expected19.i, %seqcst_fail11.i
  %frombool21.i = zext i1 %37 to i8
  store i8 %frombool21.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

monotonic_fail22.i:                               ; preds = %release.i
  %38 = load i64, ptr %5, align 8
  %39 = load i64, ptr %.atomictmp.i, align 8
  %40 = cmpxchg ptr %this1.i, i64 %38, i64 %39 release monotonic, align 8
  %41 = extractvalue { i64, i1 } %40, 0
  %42 = extractvalue { i64, i1 } %40, 1
  br i1 %42, label %cmpxchg.continue27.i, label %cmpxchg.store_expected26.i

acquire_fail23.i:                                 ; preds = %release.i, %release.i
  %43 = load i64, ptr %5, align 8
  %44 = load i64, ptr %.atomictmp.i, align 8
  %45 = cmpxchg ptr %this1.i, i64 %43, i64 %44 release acquire, align 8
  %46 = extractvalue { i64, i1 } %45, 0
  %47 = extractvalue { i64, i1 } %45, 1
  br i1 %47, label %cmpxchg.continue30.i, label %cmpxchg.store_expected29.i

seqcst_fail24.i:                                  ; preds = %release.i
  %48 = load i64, ptr %5, align 8
  %49 = load i64, ptr %.atomictmp.i, align 8
  %50 = cmpxchg ptr %this1.i, i64 %48, i64 %49 release seq_cst, align 8
  %51 = extractvalue { i64, i1 } %50, 0
  %52 = extractvalue { i64, i1 } %50, 1
  br i1 %52, label %cmpxchg.continue33.i, label %cmpxchg.store_expected32.i

atomic.continue25.i:                              ; preds = %cmpxchg.continue33.i, %cmpxchg.continue30.i, %cmpxchg.continue27.i
  br label %_ZNSt13__atomic_baseIPFvlEE23compare_exchange_strongERS1_S1_St12memory_orderS4_.exit

cmpxchg.store_expected26.i:                       ; preds = %monotonic_fail22.i
  store i64 %41, ptr %5, align 8
  br label %cmpxchg.continue27.i

cmpxchg.continue27.i:                             ; preds = %cmpxchg.store_expected26.i, %monotonic_fail22.i
  %frombool28.i = zext i1 %42 to i8
  store i8 %frombool28.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected29.i:                       ; preds = %acquire_fail23.i
  store i64 %46, ptr %5, align 8
  br label %cmpxchg.continue30.i

cmpxchg.continue30.i:                             ; preds = %cmpxchg.store_expected29.i, %acquire_fail23.i
  %frombool31.i = zext i1 %47 to i8
  store i8 %frombool31.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected32.i:                       ; preds = %seqcst_fail24.i
  store i64 %51, ptr %5, align 8
  br label %cmpxchg.continue33.i

cmpxchg.continue33.i:                             ; preds = %cmpxchg.store_expected32.i, %seqcst_fail24.i
  %frombool34.i = zext i1 %52 to i8
  store i8 %frombool34.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

monotonic_fail35.i:                               ; preds = %acqrel.i
  %53 = load i64, ptr %5, align 8
  %54 = load i64, ptr %.atomictmp.i, align 8
  %55 = cmpxchg ptr %this1.i, i64 %53, i64 %54 acq_rel monotonic, align 8
  %56 = extractvalue { i64, i1 } %55, 0
  %57 = extractvalue { i64, i1 } %55, 1
  br i1 %57, label %cmpxchg.continue40.i, label %cmpxchg.store_expected39.i

acquire_fail36.i:                                 ; preds = %acqrel.i, %acqrel.i
  %58 = load i64, ptr %5, align 8
  %59 = load i64, ptr %.atomictmp.i, align 8
  %60 = cmpxchg ptr %this1.i, i64 %58, i64 %59 acq_rel acquire, align 8
  %61 = extractvalue { i64, i1 } %60, 0
  %62 = extractvalue { i64, i1 } %60, 1
  br i1 %62, label %cmpxchg.continue43.i, label %cmpxchg.store_expected42.i

seqcst_fail37.i:                                  ; preds = %acqrel.i
  %63 = load i64, ptr %5, align 8
  %64 = load i64, ptr %.atomictmp.i, align 8
  %65 = cmpxchg ptr %this1.i, i64 %63, i64 %64 acq_rel seq_cst, align 8
  %66 = extractvalue { i64, i1 } %65, 0
  %67 = extractvalue { i64, i1 } %65, 1
  br i1 %67, label %cmpxchg.continue46.i, label %cmpxchg.store_expected45.i

atomic.continue38.i:                              ; preds = %cmpxchg.continue46.i, %cmpxchg.continue43.i, %cmpxchg.continue40.i
  br label %_ZNSt13__atomic_baseIPFvlEE23compare_exchange_strongERS1_S1_St12memory_orderS4_.exit

cmpxchg.store_expected39.i:                       ; preds = %monotonic_fail35.i
  store i64 %56, ptr %5, align 8
  br label %cmpxchg.continue40.i

cmpxchg.continue40.i:                             ; preds = %cmpxchg.store_expected39.i, %monotonic_fail35.i
  %frombool41.i = zext i1 %57 to i8
  store i8 %frombool41.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected42.i:                       ; preds = %acquire_fail36.i
  store i64 %61, ptr %5, align 8
  br label %cmpxchg.continue43.i

cmpxchg.continue43.i:                             ; preds = %cmpxchg.store_expected42.i, %acquire_fail36.i
  %frombool44.i = zext i1 %62 to i8
  store i8 %frombool44.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected45.i:                       ; preds = %seqcst_fail37.i
  store i64 %66, ptr %5, align 8
  br label %cmpxchg.continue46.i

cmpxchg.continue46.i:                             ; preds = %cmpxchg.store_expected45.i, %seqcst_fail37.i
  %frombool47.i = zext i1 %67 to i8
  store i8 %frombool47.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

monotonic_fail48.i:                               ; preds = %seqcst.i
  %68 = load i64, ptr %5, align 8
  %69 = load i64, ptr %.atomictmp.i, align 8
  %70 = cmpxchg ptr %this1.i, i64 %68, i64 %69 seq_cst monotonic, align 8
  %71 = extractvalue { i64, i1 } %70, 0
  %72 = extractvalue { i64, i1 } %70, 1
  br i1 %72, label %cmpxchg.continue53.i, label %cmpxchg.store_expected52.i

acquire_fail49.i:                                 ; preds = %seqcst.i, %seqcst.i
  %73 = load i64, ptr %5, align 8
  %74 = load i64, ptr %.atomictmp.i, align 8
  %75 = cmpxchg ptr %this1.i, i64 %73, i64 %74 seq_cst acquire, align 8
  %76 = extractvalue { i64, i1 } %75, 0
  %77 = extractvalue { i64, i1 } %75, 1
  br i1 %77, label %cmpxchg.continue56.i, label %cmpxchg.store_expected55.i

seqcst_fail50.i:                                  ; preds = %seqcst.i
  %78 = load i64, ptr %5, align 8
  %79 = load i64, ptr %.atomictmp.i, align 8
  %80 = cmpxchg ptr %this1.i, i64 %78, i64 %79 seq_cst seq_cst, align 8
  %81 = extractvalue { i64, i1 } %80, 0
  %82 = extractvalue { i64, i1 } %80, 1
  br i1 %82, label %cmpxchg.continue59.i, label %cmpxchg.store_expected58.i

atomic.continue51.i:                              ; preds = %cmpxchg.continue59.i, %cmpxchg.continue56.i, %cmpxchg.continue53.i
  br label %_ZNSt13__atomic_baseIPFvlEE23compare_exchange_strongERS1_S1_St12memory_orderS4_.exit

cmpxchg.store_expected52.i:                       ; preds = %monotonic_fail48.i
  store i64 %71, ptr %5, align 8
  br label %cmpxchg.continue53.i

cmpxchg.continue53.i:                             ; preds = %cmpxchg.store_expected52.i, %monotonic_fail48.i
  %frombool54.i = zext i1 %72 to i8
  store i8 %frombool54.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected55.i:                       ; preds = %acquire_fail49.i
  store i64 %76, ptr %5, align 8
  br label %cmpxchg.continue56.i

cmpxchg.continue56.i:                             ; preds = %cmpxchg.store_expected55.i, %acquire_fail49.i
  %frombool57.i = zext i1 %77 to i8
  store i8 %frombool57.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected58.i:                       ; preds = %seqcst_fail50.i
  store i64 %81, ptr %5, align 8
  br label %cmpxchg.continue59.i

cmpxchg.continue59.i:                             ; preds = %cmpxchg.store_expected58.i, %seqcst_fail50.i
  %frombool60.i = zext i1 %82 to i8
  store i8 %frombool60.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

_ZNSt13__atomic_baseIPFvlEE23compare_exchange_strongERS1_S1_St12memory_orderS4_.exit: ; preds = %atomic.continue51.i, %atomic.continue38.i, %atomic.continue25.i, %atomic.continue12.i, %atomic.continue2.i
  %83 = load i8, ptr %cmpxchg.bool.i, align 1
  %tobool.i = trunc i8 %83 to i1
  ret i1 %tobool.i
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN4absl13base_internal10AtomicHookIPFvPKcPKvlEE7DoStoreES7_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %fn) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %fn.addr = alloca ptr, align 8
  %expected = alloca ptr, align 8
  %store_succeeded = alloca i8, align 1
  %same_value_already_stored = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  store ptr %fn, ptr %fn.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %default_fn_ = getelementptr inbounds %"class.absl::base_internal::AtomicHook.0", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %default_fn_, align 8
  store ptr %0, ptr %expected, align 8
  %hook_ = getelementptr inbounds %"class.absl::base_internal::AtomicHook.0", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %fn.addr, align 8
  %call = call noundef zeroext i1 @_ZNSt6atomicIPFvPKcPKvlEE23compare_exchange_strongERS5_S5_St12memory_orderS8_(ptr noundef nonnull align 8 dereferenceable(8) %hook_, ptr noundef nonnull align 8 dereferenceable(8) %expected, ptr noundef %1, i32 noundef 4, i32 noundef 2) #13
  %frombool = zext i1 %call to i8
  store i8 %frombool, ptr %store_succeeded, align 1
  %2 = load ptr, ptr %expected, align 8
  %3 = load ptr, ptr %fn.addr, align 8
  %cmp = icmp eq ptr %2, %3
  %frombool2 = zext i1 %cmp to i8
  store i8 %frombool2, ptr %same_value_already_stored, align 1
  %4 = load i8, ptr %store_succeeded, align 1
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %5 = load i8, ptr %same_value_already_stored, align 1
  %tobool3 = trunc i8 %5 to i1
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %6 = phi i1 [ true, %entry ], [ %tobool3, %lor.rhs ]
  ret i1 %6
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNSt6atomicIPFvPKcPKvlEE23compare_exchange_strongERS5_S5_St12memory_orderS8_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 8 dereferenceable(8) %__p1, ptr noundef %__p2, i32 noundef %__m1, i32 noundef %__m2) #1 comdat align 2 {
entry:
  %this.addr.i = alloca ptr, align 8
  %__p1.addr.i = alloca ptr, align 8
  %__p2.addr.i = alloca ptr, align 8
  %__m1.addr.i = alloca i32, align 4
  %__m2.addr.i = alloca i32, align 4
  %.atomictmp.i = alloca ptr, align 8
  %cmpxchg.bool.i = alloca i8, align 1
  %this.addr = alloca ptr, align 8
  %__p1.addr = alloca ptr, align 8
  %__p2.addr = alloca ptr, align 8
  %__m1.addr = alloca i32, align 4
  %__m2.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %__p1, ptr %__p1.addr, align 8
  store ptr %__p2, ptr %__p2.addr, align 8
  store i32 %__m1, ptr %__m1.addr, align 4
  store i32 %__m2, ptr %__m2.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %_M_b = getelementptr inbounds %"struct.std::atomic.1", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %__p1.addr, align 8
  %1 = load ptr, ptr %__p2.addr, align 8
  %2 = load i32, ptr %__m1.addr, align 4
  %3 = load i32, ptr %__m2.addr, align 4
  store ptr %_M_b, ptr %this.addr.i, align 8
  store ptr %0, ptr %__p1.addr.i, align 8
  store ptr %1, ptr %__p2.addr.i, align 8
  store i32 %2, ptr %__m1.addr.i, align 4
  store i32 %3, ptr %__m2.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %4 = load i32, ptr %__m1.addr.i, align 4
  %5 = load ptr, ptr %__p1.addr.i, align 8
  %6 = load ptr, ptr %__p2.addr.i, align 8
  store ptr %6, ptr %.atomictmp.i, align 8
  %7 = load i32, ptr %__m2.addr.i, align 4
  switch i32 %4, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 3, label %release.i
    i32 4, label %acqrel.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %entry
  switch i32 %7, label %monotonic_fail.i [
    i32 1, label %acquire_fail.i
    i32 2, label %acquire_fail.i
    i32 5, label %seqcst_fail.i
  ]

acquire.i:                                        ; preds = %entry, %entry
  switch i32 %7, label %monotonic_fail9.i [
    i32 1, label %acquire_fail10.i
    i32 2, label %acquire_fail10.i
    i32 5, label %seqcst_fail11.i
  ]

release.i:                                        ; preds = %entry
  switch i32 %7, label %monotonic_fail22.i [
    i32 1, label %acquire_fail23.i
    i32 2, label %acquire_fail23.i
    i32 5, label %seqcst_fail24.i
  ]

acqrel.i:                                         ; preds = %entry
  switch i32 %7, label %monotonic_fail35.i [
    i32 1, label %acquire_fail36.i
    i32 2, label %acquire_fail36.i
    i32 5, label %seqcst_fail37.i
  ]

seqcst.i:                                         ; preds = %entry
  switch i32 %7, label %monotonic_fail48.i [
    i32 1, label %acquire_fail49.i
    i32 2, label %acquire_fail49.i
    i32 5, label %seqcst_fail50.i
  ]

monotonic_fail.i:                                 ; preds = %monotonic.i
  %8 = load i64, ptr %5, align 8
  %9 = load i64, ptr %.atomictmp.i, align 8
  %10 = cmpxchg ptr %this1.i, i64 %8, i64 %9 monotonic monotonic, align 8
  %11 = extractvalue { i64, i1 } %10, 0
  %12 = extractvalue { i64, i1 } %10, 1
  br i1 %12, label %cmpxchg.continue.i, label %cmpxchg.store_expected.i

acquire_fail.i:                                   ; preds = %monotonic.i, %monotonic.i
  %13 = load i64, ptr %5, align 8
  %14 = load i64, ptr %.atomictmp.i, align 8
  %15 = cmpxchg ptr %this1.i, i64 %13, i64 %14 monotonic acquire, align 8
  %16 = extractvalue { i64, i1 } %15, 0
  %17 = extractvalue { i64, i1 } %15, 1
  br i1 %17, label %cmpxchg.continue4.i, label %cmpxchg.store_expected3.i

seqcst_fail.i:                                    ; preds = %monotonic.i
  %18 = load i64, ptr %5, align 8
  %19 = load i64, ptr %.atomictmp.i, align 8
  %20 = cmpxchg ptr %this1.i, i64 %18, i64 %19 monotonic seq_cst, align 8
  %21 = extractvalue { i64, i1 } %20, 0
  %22 = extractvalue { i64, i1 } %20, 1
  br i1 %22, label %cmpxchg.continue7.i, label %cmpxchg.store_expected6.i

atomic.continue2.i:                               ; preds = %cmpxchg.continue7.i, %cmpxchg.continue4.i, %cmpxchg.continue.i
  br label %_ZNSt13__atomic_baseIPFvPKcPKvlEE23compare_exchange_strongERS5_S5_St12memory_orderS8_.exit

cmpxchg.store_expected.i:                         ; preds = %monotonic_fail.i
  store i64 %11, ptr %5, align 8
  br label %cmpxchg.continue.i

cmpxchg.continue.i:                               ; preds = %cmpxchg.store_expected.i, %monotonic_fail.i
  %frombool.i = zext i1 %12 to i8
  store i8 %frombool.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected3.i:                        ; preds = %acquire_fail.i
  store i64 %16, ptr %5, align 8
  br label %cmpxchg.continue4.i

cmpxchg.continue4.i:                              ; preds = %cmpxchg.store_expected3.i, %acquire_fail.i
  %frombool5.i = zext i1 %17 to i8
  store i8 %frombool5.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected6.i:                        ; preds = %seqcst_fail.i
  store i64 %21, ptr %5, align 8
  br label %cmpxchg.continue7.i

cmpxchg.continue7.i:                              ; preds = %cmpxchg.store_expected6.i, %seqcst_fail.i
  %frombool8.i = zext i1 %22 to i8
  store i8 %frombool8.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

monotonic_fail9.i:                                ; preds = %acquire.i
  %23 = load i64, ptr %5, align 8
  %24 = load i64, ptr %.atomictmp.i, align 8
  %25 = cmpxchg ptr %this1.i, i64 %23, i64 %24 acquire monotonic, align 8
  %26 = extractvalue { i64, i1 } %25, 0
  %27 = extractvalue { i64, i1 } %25, 1
  br i1 %27, label %cmpxchg.continue14.i, label %cmpxchg.store_expected13.i

acquire_fail10.i:                                 ; preds = %acquire.i, %acquire.i
  %28 = load i64, ptr %5, align 8
  %29 = load i64, ptr %.atomictmp.i, align 8
  %30 = cmpxchg ptr %this1.i, i64 %28, i64 %29 acquire acquire, align 8
  %31 = extractvalue { i64, i1 } %30, 0
  %32 = extractvalue { i64, i1 } %30, 1
  br i1 %32, label %cmpxchg.continue17.i, label %cmpxchg.store_expected16.i

seqcst_fail11.i:                                  ; preds = %acquire.i
  %33 = load i64, ptr %5, align 8
  %34 = load i64, ptr %.atomictmp.i, align 8
  %35 = cmpxchg ptr %this1.i, i64 %33, i64 %34 acquire seq_cst, align 8
  %36 = extractvalue { i64, i1 } %35, 0
  %37 = extractvalue { i64, i1 } %35, 1
  br i1 %37, label %cmpxchg.continue20.i, label %cmpxchg.store_expected19.i

atomic.continue12.i:                              ; preds = %cmpxchg.continue20.i, %cmpxchg.continue17.i, %cmpxchg.continue14.i
  br label %_ZNSt13__atomic_baseIPFvPKcPKvlEE23compare_exchange_strongERS5_S5_St12memory_orderS8_.exit

cmpxchg.store_expected13.i:                       ; preds = %monotonic_fail9.i
  store i64 %26, ptr %5, align 8
  br label %cmpxchg.continue14.i

cmpxchg.continue14.i:                             ; preds = %cmpxchg.store_expected13.i, %monotonic_fail9.i
  %frombool15.i = zext i1 %27 to i8
  store i8 %frombool15.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected16.i:                       ; preds = %acquire_fail10.i
  store i64 %31, ptr %5, align 8
  br label %cmpxchg.continue17.i

cmpxchg.continue17.i:                             ; preds = %cmpxchg.store_expected16.i, %acquire_fail10.i
  %frombool18.i = zext i1 %32 to i8
  store i8 %frombool18.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected19.i:                       ; preds = %seqcst_fail11.i
  store i64 %36, ptr %5, align 8
  br label %cmpxchg.continue20.i

cmpxchg.continue20.i:                             ; preds = %cmpxchg.store_expected19.i, %seqcst_fail11.i
  %frombool21.i = zext i1 %37 to i8
  store i8 %frombool21.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

monotonic_fail22.i:                               ; preds = %release.i
  %38 = load i64, ptr %5, align 8
  %39 = load i64, ptr %.atomictmp.i, align 8
  %40 = cmpxchg ptr %this1.i, i64 %38, i64 %39 release monotonic, align 8
  %41 = extractvalue { i64, i1 } %40, 0
  %42 = extractvalue { i64, i1 } %40, 1
  br i1 %42, label %cmpxchg.continue27.i, label %cmpxchg.store_expected26.i

acquire_fail23.i:                                 ; preds = %release.i, %release.i
  %43 = load i64, ptr %5, align 8
  %44 = load i64, ptr %.atomictmp.i, align 8
  %45 = cmpxchg ptr %this1.i, i64 %43, i64 %44 release acquire, align 8
  %46 = extractvalue { i64, i1 } %45, 0
  %47 = extractvalue { i64, i1 } %45, 1
  br i1 %47, label %cmpxchg.continue30.i, label %cmpxchg.store_expected29.i

seqcst_fail24.i:                                  ; preds = %release.i
  %48 = load i64, ptr %5, align 8
  %49 = load i64, ptr %.atomictmp.i, align 8
  %50 = cmpxchg ptr %this1.i, i64 %48, i64 %49 release seq_cst, align 8
  %51 = extractvalue { i64, i1 } %50, 0
  %52 = extractvalue { i64, i1 } %50, 1
  br i1 %52, label %cmpxchg.continue33.i, label %cmpxchg.store_expected32.i

atomic.continue25.i:                              ; preds = %cmpxchg.continue33.i, %cmpxchg.continue30.i, %cmpxchg.continue27.i
  br label %_ZNSt13__atomic_baseIPFvPKcPKvlEE23compare_exchange_strongERS5_S5_St12memory_orderS8_.exit

cmpxchg.store_expected26.i:                       ; preds = %monotonic_fail22.i
  store i64 %41, ptr %5, align 8
  br label %cmpxchg.continue27.i

cmpxchg.continue27.i:                             ; preds = %cmpxchg.store_expected26.i, %monotonic_fail22.i
  %frombool28.i = zext i1 %42 to i8
  store i8 %frombool28.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected29.i:                       ; preds = %acquire_fail23.i
  store i64 %46, ptr %5, align 8
  br label %cmpxchg.continue30.i

cmpxchg.continue30.i:                             ; preds = %cmpxchg.store_expected29.i, %acquire_fail23.i
  %frombool31.i = zext i1 %47 to i8
  store i8 %frombool31.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected32.i:                       ; preds = %seqcst_fail24.i
  store i64 %51, ptr %5, align 8
  br label %cmpxchg.continue33.i

cmpxchg.continue33.i:                             ; preds = %cmpxchg.store_expected32.i, %seqcst_fail24.i
  %frombool34.i = zext i1 %52 to i8
  store i8 %frombool34.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

monotonic_fail35.i:                               ; preds = %acqrel.i
  %53 = load i64, ptr %5, align 8
  %54 = load i64, ptr %.atomictmp.i, align 8
  %55 = cmpxchg ptr %this1.i, i64 %53, i64 %54 acq_rel monotonic, align 8
  %56 = extractvalue { i64, i1 } %55, 0
  %57 = extractvalue { i64, i1 } %55, 1
  br i1 %57, label %cmpxchg.continue40.i, label %cmpxchg.store_expected39.i

acquire_fail36.i:                                 ; preds = %acqrel.i, %acqrel.i
  %58 = load i64, ptr %5, align 8
  %59 = load i64, ptr %.atomictmp.i, align 8
  %60 = cmpxchg ptr %this1.i, i64 %58, i64 %59 acq_rel acquire, align 8
  %61 = extractvalue { i64, i1 } %60, 0
  %62 = extractvalue { i64, i1 } %60, 1
  br i1 %62, label %cmpxchg.continue43.i, label %cmpxchg.store_expected42.i

seqcst_fail37.i:                                  ; preds = %acqrel.i
  %63 = load i64, ptr %5, align 8
  %64 = load i64, ptr %.atomictmp.i, align 8
  %65 = cmpxchg ptr %this1.i, i64 %63, i64 %64 acq_rel seq_cst, align 8
  %66 = extractvalue { i64, i1 } %65, 0
  %67 = extractvalue { i64, i1 } %65, 1
  br i1 %67, label %cmpxchg.continue46.i, label %cmpxchg.store_expected45.i

atomic.continue38.i:                              ; preds = %cmpxchg.continue46.i, %cmpxchg.continue43.i, %cmpxchg.continue40.i
  br label %_ZNSt13__atomic_baseIPFvPKcPKvlEE23compare_exchange_strongERS5_S5_St12memory_orderS8_.exit

cmpxchg.store_expected39.i:                       ; preds = %monotonic_fail35.i
  store i64 %56, ptr %5, align 8
  br label %cmpxchg.continue40.i

cmpxchg.continue40.i:                             ; preds = %cmpxchg.store_expected39.i, %monotonic_fail35.i
  %frombool41.i = zext i1 %57 to i8
  store i8 %frombool41.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected42.i:                       ; preds = %acquire_fail36.i
  store i64 %61, ptr %5, align 8
  br label %cmpxchg.continue43.i

cmpxchg.continue43.i:                             ; preds = %cmpxchg.store_expected42.i, %acquire_fail36.i
  %frombool44.i = zext i1 %62 to i8
  store i8 %frombool44.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected45.i:                       ; preds = %seqcst_fail37.i
  store i64 %66, ptr %5, align 8
  br label %cmpxchg.continue46.i

cmpxchg.continue46.i:                             ; preds = %cmpxchg.store_expected45.i, %seqcst_fail37.i
  %frombool47.i = zext i1 %67 to i8
  store i8 %frombool47.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

monotonic_fail48.i:                               ; preds = %seqcst.i
  %68 = load i64, ptr %5, align 8
  %69 = load i64, ptr %.atomictmp.i, align 8
  %70 = cmpxchg ptr %this1.i, i64 %68, i64 %69 seq_cst monotonic, align 8
  %71 = extractvalue { i64, i1 } %70, 0
  %72 = extractvalue { i64, i1 } %70, 1
  br i1 %72, label %cmpxchg.continue53.i, label %cmpxchg.store_expected52.i

acquire_fail49.i:                                 ; preds = %seqcst.i, %seqcst.i
  %73 = load i64, ptr %5, align 8
  %74 = load i64, ptr %.atomictmp.i, align 8
  %75 = cmpxchg ptr %this1.i, i64 %73, i64 %74 seq_cst acquire, align 8
  %76 = extractvalue { i64, i1 } %75, 0
  %77 = extractvalue { i64, i1 } %75, 1
  br i1 %77, label %cmpxchg.continue56.i, label %cmpxchg.store_expected55.i

seqcst_fail50.i:                                  ; preds = %seqcst.i
  %78 = load i64, ptr %5, align 8
  %79 = load i64, ptr %.atomictmp.i, align 8
  %80 = cmpxchg ptr %this1.i, i64 %78, i64 %79 seq_cst seq_cst, align 8
  %81 = extractvalue { i64, i1 } %80, 0
  %82 = extractvalue { i64, i1 } %80, 1
  br i1 %82, label %cmpxchg.continue59.i, label %cmpxchg.store_expected58.i

atomic.continue51.i:                              ; preds = %cmpxchg.continue59.i, %cmpxchg.continue56.i, %cmpxchg.continue53.i
  br label %_ZNSt13__atomic_baseIPFvPKcPKvlEE23compare_exchange_strongERS5_S5_St12memory_orderS8_.exit

cmpxchg.store_expected52.i:                       ; preds = %monotonic_fail48.i
  store i64 %71, ptr %5, align 8
  br label %cmpxchg.continue53.i

cmpxchg.continue53.i:                             ; preds = %cmpxchg.store_expected52.i, %monotonic_fail48.i
  %frombool54.i = zext i1 %72 to i8
  store i8 %frombool54.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected55.i:                       ; preds = %acquire_fail49.i
  store i64 %76, ptr %5, align 8
  br label %cmpxchg.continue56.i

cmpxchg.continue56.i:                             ; preds = %cmpxchg.store_expected55.i, %acquire_fail49.i
  %frombool57.i = zext i1 %77 to i8
  store i8 %frombool57.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected58.i:                       ; preds = %seqcst_fail50.i
  store i64 %81, ptr %5, align 8
  br label %cmpxchg.continue59.i

cmpxchg.continue59.i:                             ; preds = %cmpxchg.store_expected58.i, %seqcst_fail50.i
  %frombool60.i = zext i1 %82 to i8
  store i8 %frombool60.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

_ZNSt13__atomic_baseIPFvPKcPKvlEE23compare_exchange_strongERS5_S5_St12memory_orderS8_.exit: ; preds = %atomic.continue51.i, %atomic.continue38.i, %atomic.continue25.i, %atomic.continue12.i, %atomic.continue2.i
  %83 = load i8, ptr %cmpxchg.bool.i, align 1
  %tobool.i = trunc i8 %83 to i1
  ret i1 %tobool.i
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN4absl13base_internal10AtomicHookIPFvPKcPKvEE7DoStoreES7_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %fn) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %fn.addr = alloca ptr, align 8
  %expected = alloca ptr, align 8
  %store_succeeded = alloca i8, align 1
  %same_value_already_stored = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  store ptr %fn, ptr %fn.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %default_fn_ = getelementptr inbounds %"class.absl::base_internal::AtomicHook.3", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %default_fn_, align 8
  store ptr %0, ptr %expected, align 8
  %hook_ = getelementptr inbounds %"class.absl::base_internal::AtomicHook.3", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %fn.addr, align 8
  %call = call noundef zeroext i1 @_ZNSt6atomicIPFvPKcPKvEE23compare_exchange_strongERS5_S5_St12memory_orderS8_(ptr noundef nonnull align 8 dereferenceable(8) %hook_, ptr noundef nonnull align 8 dereferenceable(8) %expected, ptr noundef %1, i32 noundef 4, i32 noundef 2) #13
  %frombool = zext i1 %call to i8
  store i8 %frombool, ptr %store_succeeded, align 1
  %2 = load ptr, ptr %expected, align 8
  %3 = load ptr, ptr %fn.addr, align 8
  %cmp = icmp eq ptr %2, %3
  %frombool2 = zext i1 %cmp to i8
  store i8 %frombool2, ptr %same_value_already_stored, align 1
  %4 = load i8, ptr %store_succeeded, align 1
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %5 = load i8, ptr %same_value_already_stored, align 1
  %tobool3 = trunc i8 %5 to i1
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %6 = phi i1 [ true, %entry ], [ %tobool3, %lor.rhs ]
  ret i1 %6
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNSt6atomicIPFvPKcPKvEE23compare_exchange_strongERS5_S5_St12memory_orderS8_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 8 dereferenceable(8) %__p1, ptr noundef %__p2, i32 noundef %__m1, i32 noundef %__m2) #1 comdat align 2 {
entry:
  %this.addr.i = alloca ptr, align 8
  %__p1.addr.i = alloca ptr, align 8
  %__p2.addr.i = alloca ptr, align 8
  %__m1.addr.i = alloca i32, align 4
  %__m2.addr.i = alloca i32, align 4
  %.atomictmp.i = alloca ptr, align 8
  %cmpxchg.bool.i = alloca i8, align 1
  %this.addr = alloca ptr, align 8
  %__p1.addr = alloca ptr, align 8
  %__p2.addr = alloca ptr, align 8
  %__m1.addr = alloca i32, align 4
  %__m2.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %__p1, ptr %__p1.addr, align 8
  store ptr %__p2, ptr %__p2.addr, align 8
  store i32 %__m1, ptr %__m1.addr, align 4
  store i32 %__m2, ptr %__m2.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %_M_b = getelementptr inbounds %"struct.std::atomic.4", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %__p1.addr, align 8
  %1 = load ptr, ptr %__p2.addr, align 8
  %2 = load i32, ptr %__m1.addr, align 4
  %3 = load i32, ptr %__m2.addr, align 4
  store ptr %_M_b, ptr %this.addr.i, align 8
  store ptr %0, ptr %__p1.addr.i, align 8
  store ptr %1, ptr %__p2.addr.i, align 8
  store i32 %2, ptr %__m1.addr.i, align 4
  store i32 %3, ptr %__m2.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %4 = load i32, ptr %__m1.addr.i, align 4
  %5 = load ptr, ptr %__p1.addr.i, align 8
  %6 = load ptr, ptr %__p2.addr.i, align 8
  store ptr %6, ptr %.atomictmp.i, align 8
  %7 = load i32, ptr %__m2.addr.i, align 4
  switch i32 %4, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 3, label %release.i
    i32 4, label %acqrel.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %entry
  switch i32 %7, label %monotonic_fail.i [
    i32 1, label %acquire_fail.i
    i32 2, label %acquire_fail.i
    i32 5, label %seqcst_fail.i
  ]

acquire.i:                                        ; preds = %entry, %entry
  switch i32 %7, label %monotonic_fail9.i [
    i32 1, label %acquire_fail10.i
    i32 2, label %acquire_fail10.i
    i32 5, label %seqcst_fail11.i
  ]

release.i:                                        ; preds = %entry
  switch i32 %7, label %monotonic_fail22.i [
    i32 1, label %acquire_fail23.i
    i32 2, label %acquire_fail23.i
    i32 5, label %seqcst_fail24.i
  ]

acqrel.i:                                         ; preds = %entry
  switch i32 %7, label %monotonic_fail35.i [
    i32 1, label %acquire_fail36.i
    i32 2, label %acquire_fail36.i
    i32 5, label %seqcst_fail37.i
  ]

seqcst.i:                                         ; preds = %entry
  switch i32 %7, label %monotonic_fail48.i [
    i32 1, label %acquire_fail49.i
    i32 2, label %acquire_fail49.i
    i32 5, label %seqcst_fail50.i
  ]

monotonic_fail.i:                                 ; preds = %monotonic.i
  %8 = load i64, ptr %5, align 8
  %9 = load i64, ptr %.atomictmp.i, align 8
  %10 = cmpxchg ptr %this1.i, i64 %8, i64 %9 monotonic monotonic, align 8
  %11 = extractvalue { i64, i1 } %10, 0
  %12 = extractvalue { i64, i1 } %10, 1
  br i1 %12, label %cmpxchg.continue.i, label %cmpxchg.store_expected.i

acquire_fail.i:                                   ; preds = %monotonic.i, %monotonic.i
  %13 = load i64, ptr %5, align 8
  %14 = load i64, ptr %.atomictmp.i, align 8
  %15 = cmpxchg ptr %this1.i, i64 %13, i64 %14 monotonic acquire, align 8
  %16 = extractvalue { i64, i1 } %15, 0
  %17 = extractvalue { i64, i1 } %15, 1
  br i1 %17, label %cmpxchg.continue4.i, label %cmpxchg.store_expected3.i

seqcst_fail.i:                                    ; preds = %monotonic.i
  %18 = load i64, ptr %5, align 8
  %19 = load i64, ptr %.atomictmp.i, align 8
  %20 = cmpxchg ptr %this1.i, i64 %18, i64 %19 monotonic seq_cst, align 8
  %21 = extractvalue { i64, i1 } %20, 0
  %22 = extractvalue { i64, i1 } %20, 1
  br i1 %22, label %cmpxchg.continue7.i, label %cmpxchg.store_expected6.i

atomic.continue2.i:                               ; preds = %cmpxchg.continue7.i, %cmpxchg.continue4.i, %cmpxchg.continue.i
  br label %_ZNSt13__atomic_baseIPFvPKcPKvEE23compare_exchange_strongERS5_S5_St12memory_orderS8_.exit

cmpxchg.store_expected.i:                         ; preds = %monotonic_fail.i
  store i64 %11, ptr %5, align 8
  br label %cmpxchg.continue.i

cmpxchg.continue.i:                               ; preds = %cmpxchg.store_expected.i, %monotonic_fail.i
  %frombool.i = zext i1 %12 to i8
  store i8 %frombool.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected3.i:                        ; preds = %acquire_fail.i
  store i64 %16, ptr %5, align 8
  br label %cmpxchg.continue4.i

cmpxchg.continue4.i:                              ; preds = %cmpxchg.store_expected3.i, %acquire_fail.i
  %frombool5.i = zext i1 %17 to i8
  store i8 %frombool5.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

cmpxchg.store_expected6.i:                        ; preds = %seqcst_fail.i
  store i64 %21, ptr %5, align 8
  br label %cmpxchg.continue7.i

cmpxchg.continue7.i:                              ; preds = %cmpxchg.store_expected6.i, %seqcst_fail.i
  %frombool8.i = zext i1 %22 to i8
  store i8 %frombool8.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue2.i

monotonic_fail9.i:                                ; preds = %acquire.i
  %23 = load i64, ptr %5, align 8
  %24 = load i64, ptr %.atomictmp.i, align 8
  %25 = cmpxchg ptr %this1.i, i64 %23, i64 %24 acquire monotonic, align 8
  %26 = extractvalue { i64, i1 } %25, 0
  %27 = extractvalue { i64, i1 } %25, 1
  br i1 %27, label %cmpxchg.continue14.i, label %cmpxchg.store_expected13.i

acquire_fail10.i:                                 ; preds = %acquire.i, %acquire.i
  %28 = load i64, ptr %5, align 8
  %29 = load i64, ptr %.atomictmp.i, align 8
  %30 = cmpxchg ptr %this1.i, i64 %28, i64 %29 acquire acquire, align 8
  %31 = extractvalue { i64, i1 } %30, 0
  %32 = extractvalue { i64, i1 } %30, 1
  br i1 %32, label %cmpxchg.continue17.i, label %cmpxchg.store_expected16.i

seqcst_fail11.i:                                  ; preds = %acquire.i
  %33 = load i64, ptr %5, align 8
  %34 = load i64, ptr %.atomictmp.i, align 8
  %35 = cmpxchg ptr %this1.i, i64 %33, i64 %34 acquire seq_cst, align 8
  %36 = extractvalue { i64, i1 } %35, 0
  %37 = extractvalue { i64, i1 } %35, 1
  br i1 %37, label %cmpxchg.continue20.i, label %cmpxchg.store_expected19.i

atomic.continue12.i:                              ; preds = %cmpxchg.continue20.i, %cmpxchg.continue17.i, %cmpxchg.continue14.i
  br label %_ZNSt13__atomic_baseIPFvPKcPKvEE23compare_exchange_strongERS5_S5_St12memory_orderS8_.exit

cmpxchg.store_expected13.i:                       ; preds = %monotonic_fail9.i
  store i64 %26, ptr %5, align 8
  br label %cmpxchg.continue14.i

cmpxchg.continue14.i:                             ; preds = %cmpxchg.store_expected13.i, %monotonic_fail9.i
  %frombool15.i = zext i1 %27 to i8
  store i8 %frombool15.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected16.i:                       ; preds = %acquire_fail10.i
  store i64 %31, ptr %5, align 8
  br label %cmpxchg.continue17.i

cmpxchg.continue17.i:                             ; preds = %cmpxchg.store_expected16.i, %acquire_fail10.i
  %frombool18.i = zext i1 %32 to i8
  store i8 %frombool18.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

cmpxchg.store_expected19.i:                       ; preds = %seqcst_fail11.i
  store i64 %36, ptr %5, align 8
  br label %cmpxchg.continue20.i

cmpxchg.continue20.i:                             ; preds = %cmpxchg.store_expected19.i, %seqcst_fail11.i
  %frombool21.i = zext i1 %37 to i8
  store i8 %frombool21.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue12.i

monotonic_fail22.i:                               ; preds = %release.i
  %38 = load i64, ptr %5, align 8
  %39 = load i64, ptr %.atomictmp.i, align 8
  %40 = cmpxchg ptr %this1.i, i64 %38, i64 %39 release monotonic, align 8
  %41 = extractvalue { i64, i1 } %40, 0
  %42 = extractvalue { i64, i1 } %40, 1
  br i1 %42, label %cmpxchg.continue27.i, label %cmpxchg.store_expected26.i

acquire_fail23.i:                                 ; preds = %release.i, %release.i
  %43 = load i64, ptr %5, align 8
  %44 = load i64, ptr %.atomictmp.i, align 8
  %45 = cmpxchg ptr %this1.i, i64 %43, i64 %44 release acquire, align 8
  %46 = extractvalue { i64, i1 } %45, 0
  %47 = extractvalue { i64, i1 } %45, 1
  br i1 %47, label %cmpxchg.continue30.i, label %cmpxchg.store_expected29.i

seqcst_fail24.i:                                  ; preds = %release.i
  %48 = load i64, ptr %5, align 8
  %49 = load i64, ptr %.atomictmp.i, align 8
  %50 = cmpxchg ptr %this1.i, i64 %48, i64 %49 release seq_cst, align 8
  %51 = extractvalue { i64, i1 } %50, 0
  %52 = extractvalue { i64, i1 } %50, 1
  br i1 %52, label %cmpxchg.continue33.i, label %cmpxchg.store_expected32.i

atomic.continue25.i:                              ; preds = %cmpxchg.continue33.i, %cmpxchg.continue30.i, %cmpxchg.continue27.i
  br label %_ZNSt13__atomic_baseIPFvPKcPKvEE23compare_exchange_strongERS5_S5_St12memory_orderS8_.exit

cmpxchg.store_expected26.i:                       ; preds = %monotonic_fail22.i
  store i64 %41, ptr %5, align 8
  br label %cmpxchg.continue27.i

cmpxchg.continue27.i:                             ; preds = %cmpxchg.store_expected26.i, %monotonic_fail22.i
  %frombool28.i = zext i1 %42 to i8
  store i8 %frombool28.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected29.i:                       ; preds = %acquire_fail23.i
  store i64 %46, ptr %5, align 8
  br label %cmpxchg.continue30.i

cmpxchg.continue30.i:                             ; preds = %cmpxchg.store_expected29.i, %acquire_fail23.i
  %frombool31.i = zext i1 %47 to i8
  store i8 %frombool31.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

cmpxchg.store_expected32.i:                       ; preds = %seqcst_fail24.i
  store i64 %51, ptr %5, align 8
  br label %cmpxchg.continue33.i

cmpxchg.continue33.i:                             ; preds = %cmpxchg.store_expected32.i, %seqcst_fail24.i
  %frombool34.i = zext i1 %52 to i8
  store i8 %frombool34.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue25.i

monotonic_fail35.i:                               ; preds = %acqrel.i
  %53 = load i64, ptr %5, align 8
  %54 = load i64, ptr %.atomictmp.i, align 8
  %55 = cmpxchg ptr %this1.i, i64 %53, i64 %54 acq_rel monotonic, align 8
  %56 = extractvalue { i64, i1 } %55, 0
  %57 = extractvalue { i64, i1 } %55, 1
  br i1 %57, label %cmpxchg.continue40.i, label %cmpxchg.store_expected39.i

acquire_fail36.i:                                 ; preds = %acqrel.i, %acqrel.i
  %58 = load i64, ptr %5, align 8
  %59 = load i64, ptr %.atomictmp.i, align 8
  %60 = cmpxchg ptr %this1.i, i64 %58, i64 %59 acq_rel acquire, align 8
  %61 = extractvalue { i64, i1 } %60, 0
  %62 = extractvalue { i64, i1 } %60, 1
  br i1 %62, label %cmpxchg.continue43.i, label %cmpxchg.store_expected42.i

seqcst_fail37.i:                                  ; preds = %acqrel.i
  %63 = load i64, ptr %5, align 8
  %64 = load i64, ptr %.atomictmp.i, align 8
  %65 = cmpxchg ptr %this1.i, i64 %63, i64 %64 acq_rel seq_cst, align 8
  %66 = extractvalue { i64, i1 } %65, 0
  %67 = extractvalue { i64, i1 } %65, 1
  br i1 %67, label %cmpxchg.continue46.i, label %cmpxchg.store_expected45.i

atomic.continue38.i:                              ; preds = %cmpxchg.continue46.i, %cmpxchg.continue43.i, %cmpxchg.continue40.i
  br label %_ZNSt13__atomic_baseIPFvPKcPKvEE23compare_exchange_strongERS5_S5_St12memory_orderS8_.exit

cmpxchg.store_expected39.i:                       ; preds = %monotonic_fail35.i
  store i64 %56, ptr %5, align 8
  br label %cmpxchg.continue40.i

cmpxchg.continue40.i:                             ; preds = %cmpxchg.store_expected39.i, %monotonic_fail35.i
  %frombool41.i = zext i1 %57 to i8
  store i8 %frombool41.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected42.i:                       ; preds = %acquire_fail36.i
  store i64 %61, ptr %5, align 8
  br label %cmpxchg.continue43.i

cmpxchg.continue43.i:                             ; preds = %cmpxchg.store_expected42.i, %acquire_fail36.i
  %frombool44.i = zext i1 %62 to i8
  store i8 %frombool44.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

cmpxchg.store_expected45.i:                       ; preds = %seqcst_fail37.i
  store i64 %66, ptr %5, align 8
  br label %cmpxchg.continue46.i

cmpxchg.continue46.i:                             ; preds = %cmpxchg.store_expected45.i, %seqcst_fail37.i
  %frombool47.i = zext i1 %67 to i8
  store i8 %frombool47.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue38.i

monotonic_fail48.i:                               ; preds = %seqcst.i
  %68 = load i64, ptr %5, align 8
  %69 = load i64, ptr %.atomictmp.i, align 8
  %70 = cmpxchg ptr %this1.i, i64 %68, i64 %69 seq_cst monotonic, align 8
  %71 = extractvalue { i64, i1 } %70, 0
  %72 = extractvalue { i64, i1 } %70, 1
  br i1 %72, label %cmpxchg.continue53.i, label %cmpxchg.store_expected52.i

acquire_fail49.i:                                 ; preds = %seqcst.i, %seqcst.i
  %73 = load i64, ptr %5, align 8
  %74 = load i64, ptr %.atomictmp.i, align 8
  %75 = cmpxchg ptr %this1.i, i64 %73, i64 %74 seq_cst acquire, align 8
  %76 = extractvalue { i64, i1 } %75, 0
  %77 = extractvalue { i64, i1 } %75, 1
  br i1 %77, label %cmpxchg.continue56.i, label %cmpxchg.store_expected55.i

seqcst_fail50.i:                                  ; preds = %seqcst.i
  %78 = load i64, ptr %5, align 8
  %79 = load i64, ptr %.atomictmp.i, align 8
  %80 = cmpxchg ptr %this1.i, i64 %78, i64 %79 seq_cst seq_cst, align 8
  %81 = extractvalue { i64, i1 } %80, 0
  %82 = extractvalue { i64, i1 } %80, 1
  br i1 %82, label %cmpxchg.continue59.i, label %cmpxchg.store_expected58.i

atomic.continue51.i:                              ; preds = %cmpxchg.continue59.i, %cmpxchg.continue56.i, %cmpxchg.continue53.i
  br label %_ZNSt13__atomic_baseIPFvPKcPKvEE23compare_exchange_strongERS5_S5_St12memory_orderS8_.exit

cmpxchg.store_expected52.i:                       ; preds = %monotonic_fail48.i
  store i64 %71, ptr %5, align 8
  br label %cmpxchg.continue53.i

cmpxchg.continue53.i:                             ; preds = %cmpxchg.store_expected52.i, %monotonic_fail48.i
  %frombool54.i = zext i1 %72 to i8
  store i8 %frombool54.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected55.i:                       ; preds = %acquire_fail49.i
  store i64 %76, ptr %5, align 8
  br label %cmpxchg.continue56.i

cmpxchg.continue56.i:                             ; preds = %cmpxchg.store_expected55.i, %acquire_fail49.i
  %frombool57.i = zext i1 %77 to i8
  store i8 %frombool57.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

cmpxchg.store_expected58.i:                       ; preds = %seqcst_fail50.i
  store i64 %81, ptr %5, align 8
  br label %cmpxchg.continue59.i

cmpxchg.continue59.i:                             ; preds = %cmpxchg.store_expected58.i, %seqcst_fail50.i
  %frombool60.i = zext i1 %82 to i8
  store i8 %frombool60.i, ptr %cmpxchg.bool.i, align 1
  br label %atomic.continue51.i

_ZNSt13__atomic_baseIPFvPKcPKvEE23compare_exchange_strongERS5_S5_St12memory_orderS8_.exit: ; preds = %atomic.continue51.i, %atomic.continue38.i, %atomic.continue25.i, %atomic.continue12.i, %atomic.continue2.i
  %83 = load i8, ptr %cmpxchg.bool.i, align 1
  %tobool.i = trunc i8 %83 to i1
  ret i1 %tobool.i
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK4absl13base_internal10AtomicHookIPFvPKcPKvlEE6DoLoadEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %hook_ = getelementptr inbounds %"class.absl::base_internal::AtomicHook.0", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNKSt6atomicIPFvPKcPKvlEE4loadESt12memory_order(ptr noundef nonnull align 8 dereferenceable(8) %hook_, i32 noundef 2) #13
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNKSt6atomicIPFvPKcPKvlEE4loadESt12memory_order(ptr noundef nonnull align 8 dereferenceable(8) %this, i32 noundef %__m) #1 comdat align 2 {
entry:
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %__m.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %__m, ptr %__m.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %_M_b = getelementptr inbounds %"struct.std::atomic.1", ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %__m.addr, align 4
  store ptr %_M_b, ptr %this.addr.i, align 8
  store i32 %0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %1 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %1, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %2 = load i32, ptr %__m.addr.i, align 4
  switch i32 %2, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %entry
  %3 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %3, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIPFvPKcPKvlEE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %entry, %entry
  %4 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %4, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIPFvPKcPKvlEE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %entry
  %5 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %5, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIPFvPKcPKvlEE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIPFvPKcPKvlEE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %6 = load ptr, ptr %atomic-temp.i, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK4absl13base_internal10AtomicHookIPFvlEE6DoLoadEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %hook_ = getelementptr inbounds %"class.absl::base_internal::AtomicHook", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNKSt6atomicIPFvlEE4loadESt12memory_order(ptr noundef nonnull align 8 dereferenceable(8) %hook_, i32 noundef 2) #13
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNKSt6atomicIPFvlEE4loadESt12memory_order(ptr noundef nonnull align 8 dereferenceable(8) %this, i32 noundef %__m) #1 comdat align 2 {
entry:
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %__m.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %__m, ptr %__m.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %_M_b = getelementptr inbounds %"struct.std::atomic", ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %__m.addr, align 4
  store ptr %_M_b, ptr %this.addr.i, align 8
  store i32 %0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %1 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %1, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %2 = load i32, ptr %__m.addr.i, align 4
  switch i32 %2, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %entry
  %3 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %3, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIPFvlEE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %entry, %entry
  %4 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %4, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIPFvlEE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %entry
  %5 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %5, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIPFvlEE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIPFvlEE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %6 = load ptr, ptr %atomic-temp.i, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK4absl13base_internal10AtomicHookIPFvPKcPKvEE6DoLoadEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %hook_ = getelementptr inbounds %"class.absl::base_internal::AtomicHook.3", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNKSt6atomicIPFvPKcPKvEE4loadESt12memory_order(ptr noundef nonnull align 8 dereferenceable(8) %hook_, i32 noundef 2) #13
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNKSt6atomicIPFvPKcPKvEE4loadESt12memory_order(ptr noundef nonnull align 8 dereferenceable(8) %this, i32 noundef %__m) #1 comdat align 2 {
entry:
  %this.addr.i = alloca ptr, align 8
  %__m.addr.i = alloca i32, align 4
  %__b.i = alloca i32, align 4
  %atomic-temp.i = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %__m.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %__m, ptr %__m.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %_M_b = getelementptr inbounds %"struct.std::atomic.4", ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %__m.addr, align 4
  store ptr %_M_b, ptr %this.addr.i, align 8
  store i32 %0, ptr %__m.addr.i, align 4
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %1 = load i32, ptr %__m.addr.i, align 4
  %call.i = call noundef i32 @_ZStanSt12memory_orderSt23__memory_order_modifier(i32 noundef %1, i32 noundef 65535)
  store i32 %call.i, ptr %__b.i, align 4
  %2 = load i32, ptr %__m.addr.i, align 4
  switch i32 %2, label %monotonic.i [
    i32 1, label %acquire.i
    i32 2, label %acquire.i
    i32 5, label %seqcst.i
  ]

monotonic.i:                                      ; preds = %entry
  %3 = load atomic i64, ptr %this1.i monotonic, align 8
  store i64 %3, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIPFvPKcPKvEE4loadESt12memory_order.exit

acquire.i:                                        ; preds = %entry, %entry
  %4 = load atomic i64, ptr %this1.i acquire, align 8
  store i64 %4, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIPFvPKcPKvEE4loadESt12memory_order.exit

seqcst.i:                                         ; preds = %entry
  %5 = load atomic i64, ptr %this1.i seq_cst, align 8
  store i64 %5, ptr %atomic-temp.i, align 8
  br label %_ZNKSt13__atomic_baseIPFvPKcPKvEE4loadESt12memory_order.exit

_ZNKSt13__atomic_baseIPFvPKcPKvEE4loadESt12memory_order.exit: ; preds = %seqcst.i, %acquire.i, %monotonic.i
  %6 = load ptr, ptr %atomic-temp.i, align 8
  ret ptr %6
}

attributes #0 = { mustprogress uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #3 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { alwaysinline mustprogress nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { cold mustprogress uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #6 = { nounwind willreturn memory(read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #7 = { noreturn nounwind uwtable "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #8 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #9 = { mustprogress nounwind willreturn memory(none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { cold "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #11 = { cold noreturn nounwind memory(inaccessiblemem: write) }
attributes #12 = { nounwind willreturn memory(none) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #13 = { nounwind }
attributes #14 = { noreturn nounwind }
attributes #15 = { nounwind willreturn memory(read) }
attributes #16 = { cold }
attributes #17 = { nounwind willreturn memory(none) }

!llvm.module.flags = !{!0, !1, !2, !3, !4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = distinct !{!5, !6}
!6 = !{!"llvm.loop.mustprogress"}
!7 = distinct !{!7, !6}
!8 = distinct !{!8, !6}
!9 = distinct !{!9, !6}
!10 = distinct !{!10, !6}
!11 = distinct !{!11, !6}
!12 = distinct !{!12, !6}
!13 = distinct !{!13, !6}
!14 = distinct !{!14, !6}
!15 = distinct !{!15, !6}
!16 = distinct !{!16, !6}
!17 = distinct !{!17, !6}
!18 = distinct !{!18, !6}
!19 = distinct !{!19, !6}
!20 = distinct !{!20, !6}
!21 = distinct !{!21, !6}
!22 = distinct !{!22, !6}
!23 = distinct !{!23, !6, !24}
!24 = !{!"llvm.loop.unroll.disable"}
!25 = distinct !{!25, !6, !24}
!26 = distinct !{!26, !6}
!27 = distinct !{!27, !6}
!28 = distinct !{!28, !6}
!29 = distinct !{!29, !6}
!30 = distinct !{!30, !6}
!31 = distinct !{!31, !6}
!32 = distinct !{!32, !6}
!33 = distinct !{!33, !6}
!34 = distinct !{!34, !6}
!35 = distinct !{!35, !6}
!36 = distinct !{!36, !6}
!37 = distinct !{!37, !6}
!38 = distinct !{!38, !6}
!39 = distinct !{!39, !6}
!40 = !{i64 5679136}
