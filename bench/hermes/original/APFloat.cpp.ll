target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%"struct.llvh::fltSemantics" = type { i16, i16, i32, i32 }
%"class.llvh::detail::IEEEFloat" = type <{ ptr, %"union.llvh::detail::IEEEFloat::Significand", i16, i8, [5 x i8] }>
%"union.llvh::detail::IEEEFloat::Significand" = type { i64 }
%"class.llvh::APInt" = type <{ %union.anon, i32, [4 x i8] }>
%union.anon = type { i64 }
%"class.llvh::MutableArrayRef" = type { %"class.llvh::ArrayRef" }
%"class.llvh::ArrayRef" = type { ptr, i64 }
%"class.llvh::StringRef" = type { ptr, i64 }
%"struct.llvh::decimalInfo" = type { ptr, ptr, i32, i32 }
%"class.llvh::hash_code" = type { i64 }
%"struct.llvh::hashing::detail::hash_combine_recursive_helper" = type { [64 x i8], %"struct.llvh::hashing::detail::hash_state", i64 }
%"struct.llvh::hashing::detail::hash_state" = type { i64, i64, i64, i64, i64, i64, i64 }
%"class.llvh::SmallVector" = type { %"class.llvh::SmallVectorImpl", %"struct.llvh::SmallVectorStorage" }
%"class.llvh::SmallVectorImpl" = type { %"class.llvh::SmallVectorTemplateBase" }
%"class.llvh::SmallVectorTemplateBase" = type { %"class.llvh::SmallVectorTemplateCommon" }
%"class.llvh::SmallVectorTemplateCommon" = type { %"class.llvh::SmallVectorBase" }
%"class.llvh::SmallVectorBase" = type { ptr, i32, i32 }
%"struct.llvh::SmallVectorStorage" = type { [256 x %"struct.llvh::AlignedCharArrayUnion"] }
%"struct.llvh::AlignedCharArrayUnion" = type { %"struct.llvh::AlignedCharArray" }
%"struct.llvh::AlignedCharArray" = type { [1 x i8] }
%"class.llvh::SmallVector.0" = type <{ %"class.llvh::SmallVectorImpl", %"struct.llvh::SmallVectorStorage.1", [2 x i8] }>
%"struct.llvh::SmallVectorStorage.1" = type { [6 x %"struct.llvh::AlignedCharArrayUnion"] }
%"class.llvh::APFloat" = type { [8 x i8], %"union.llvh::APFloat::Storage" }
%"union.llvh::APFloat::Storage" = type { %"class.llvh::detail::DoubleAPFloat", [8 x i8] }
%"class.llvh::detail::DoubleAPFloat" = type { ptr, %"class.std::unique_ptr" }
%"class.std::unique_ptr" = type { %"struct.std::__uniq_ptr_data" }
%"struct.std::__uniq_ptr_data" = type { %"class.std::__uniq_ptr_impl" }
%"class.std::__uniq_ptr_impl" = type { %"class.std::tuple" }
%"class.std::tuple" = type { %"struct.std::_Tuple_impl" }
%"struct.std::_Tuple_impl" = type { %"struct.std::_Head_base.3" }
%"struct.std::_Head_base.3" = type { ptr }
%"class.llvh::SmallVector.4" = type { %"class.llvh::SmallVectorImpl", %"struct.llvh::SmallVectorStorage.5" }
%"struct.llvh::SmallVectorStorage.5" = type { [16 x %"struct.llvh::AlignedCharArrayUnion"] }
%"class.llvh::SmallVector.13" = type { %"class.llvh::SmallVectorImpl.14", %"struct.llvh::SmallVectorStorage.17" }
%"class.llvh::SmallVectorImpl.14" = type { %"class.llvh::SmallVectorTemplateBase.15" }
%"class.llvh::SmallVectorTemplateBase.15" = type { %"class.llvh::SmallVectorTemplateCommon.16" }
%"class.llvh::SmallVectorTemplateCommon.16" = type { %"class.llvh::SmallVectorBase" }
%"struct.llvh::SmallVectorStorage.17" = type { [4 x %"struct.llvh::AlignedCharArrayUnion.18"] }
%"struct.llvh::AlignedCharArrayUnion.18" = type { %"struct.llvh::AlignedCharArray.19" }
%"struct.llvh::AlignedCharArray.19" = type { [8 x i8] }
%"class.llvh::APSInt" = type { %"class.llvh::APInt.base", i8, [3 x i8] }
%"class.llvh::APInt.base" = type <{ %union.anon, i32 }>
%"class.llvh::raw_ostream" = type <{ ptr, ptr, ptr, ptr, i32, [4 x i8] }>

$_ZNK4llvh6detail9IEEEFloat12needsCleanupEv = comdat any

$_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv = comdat any

$_ZNK4llvh5APInt11getNumWordsEv = comdat any

$_ZNK4llvh5APInt10getRawDataEv = comdat any

$_ZSt3minIjERKT_S2_S2_ = comdat any

$_ZNK4llvh6detail9IEEEFloat8isFiniteEv = comdat any

$_ZSt5equalIPKmS1_EbT_S2_T0_ = comdat any

$_ZN4llvh5APInt11tcIncrementEPmj = comdat any

$_ZNK4llvh6detail9IEEEFloat9isNonZeroEv = comdat any

$_ZN4llvh19makeMutableArrayRefImEENS_15MutableArrayRefIT_EEPS2_m = comdat any

$_ZNK4llvh6detail9IEEEFloat6isZeroEv = comdat any

$_ZN4llvh12NextPowerOf2Em = comdat any

$_ZN4llvh5APIntC2Ejmb = comdat any

$_ZN4llvh5APIntlSEj = comdat any

$_ZNK4llvh6detail9IEEEFloat10isNegativeEv = comdat any

$_ZN4llvh5APIntD2Ev = comdat any

$_ZNK4llvh15MutableArrayRefImE4dataEv = comdat any

$_ZN4llvh5APIntC2ERKS0_ = comdat any

$_ZNK4llvh5APInt10isNegativeEv = comdat any

$_ZN4llvhngENS_5APIntE = comdat any

$_ZN4llvh5APIntaSEOS0_ = comdat any

$_ZN4llvh12makeArrayRefImEENS_8ArrayRefIT_EEPKS2_m = comdat any

$_ZNK4llvh9StringRef5beginEv = comdat any

$_ZNK4llvh9StringRef3endEv = comdat any

$_ZN4llvh13hexDigitValueEc = comdat any

$_ZN4llvh12hash_combineIJhhjEEENS_9hash_codeEDpRKT_ = comdat any

$_ZNK4llvh6detail9IEEEFloat5isNaNEv = comdat any

$_ZN4llvh12hash_combineIJhhjsNS_9hash_codeEEEES1_DpRKT_ = comdat any

$_ZN4llvh18hash_combine_rangeIPKmEENS_9hash_codeET_S4_ = comdat any

$_ZN4llvh8ArrayRefImEC2ILm2EEERAT__Km = comdat any

$_ZNK4llvh5APInt11bitsToFloatEv = comdat any

$_ZNK4llvh5APInt12bitsToDoubleEv = comdat any

$_ZN4llvh5APInt11floatToBitsEf = comdat any

$_ZN4llvh5APInt12doubleToBitsEd = comdat any

$_ZN4llvh23SmallVectorTemplateBaseIcLb1EE9push_backERKc = comdat any

$_ZN4llvh15SmallVectorImplIcE6appendEmRKc = comdat any

$_ZNK4llvh5APInt18countTrailingZerosEv = comdat any

$_ZN4llvh5APInt11lshrInPlaceEj = comdat any

$_ZN4llvh11SmallVectorIcLj256EEC2Ev = comdat any

$_ZNK4llvh5APInt11getBitWidthEv = comdat any

$_ZNK4llvh5APIntneEm = comdat any

$_ZNK4llvh5APInt12getZExtValueEv = comdat any

$_ZNK4llvh15SmallVectorBase4sizeEv = comdat any

$_ZN4llvh11SmallVectorIcLj6EEC2Ev = comdat any

$_ZN4llvh11SmallVectorIcLj6EED2Ev = comdat any

$_ZN4llvh11SmallVectorIcLj256EED2Ev = comdat any

$_ZN4llvh7APFloatC2ENS_6detail9IEEEFloatERKNS_12fltSemanticsE = comdat any

$_ZN4llvh7APFloataSEOS0_ = comdat any

$_ZN4llvh7APFloatD2Ev = comdat any

$_ZN4llvh5APInt11tcDecrementEPmj = comdat any

$_ZNK4llvh6detail9IEEEFloat10isInfinityEv = comdat any

$_ZNK4llvh6detail9IEEEFloat12getSemanticsEv = comdat any

$_ZSt3minIiERKT_S2_S2_ = comdat any

$_ZSt3maxIiERKT_S2_S2_ = comdat any

$_ZN4llvh7APFloatC2ERKNS_12fltSemanticsE = comdat any

$_ZNSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEC2IPS1_S4_vbEET_ = comdat any

$_ZN4llvh7APFloatC2ERKNS_12fltSemanticsENS_11APFloatBase16uninitializedTagE = comdat any

$_ZN4llvh7APFloatC2ERKNS_12fltSemanticsEm = comdat any

$_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE = comdat any

$_ZN4llvh7APFloatC2EOS0_ = comdat any

$_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEcvbEv = comdat any

$_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm = comdat any

$_ZN4llvh7APFloatC2ERKS0_ = comdat any

$_ZNSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEC2EOS5_ = comdat any

$_ZN4llvh7APFloataSERKS0_ = comdat any

$_ZN4llvh6detail13DoubleAPFloatD2Ev = comdat any

$_ZN4llvh7APFloat3addERKS0_NS_11APFloatBase12roundingModeE = comdat any

$_ZNK4llvh7APFloat8isFiniteEv = comdat any

$_ZNK4llvh7APFloat10isInfinityEv = comdat any

$_ZN4llvh7APFloat8makeZeroEb = comdat any

$_ZNK4llvh7APFloat20compareAbsoluteValueERKS0_ = comdat any

$_ZN4llvh7APFloat8subtractERKS0_NS_11APFloatBase12roundingModeE = comdat any

$_ZN4llvh7APFloat10changeSignEv = comdat any

$_ZNK4llvh7APFloat6isZeroEv = comdat any

$_ZNK4llvh7APFloat10isNegativeEv = comdat any

$_ZN4llvh7APFloat8multiplyERKS0_NS_11APFloatBase12roundingModeE = comdat any

$_ZNK4llvh7APFloat15isFiniteNonZeroEv = comdat any

$_ZN4llvh7APFloat16fusedMultiplyAddERKS0_S2_NS_11APFloatBase12roundingModeE = comdat any

$_ZN4llvh7APFloat6divideERKS0_NS_11APFloatBase12roundingModeE = comdat any

$_ZNK4llvh7APFloat14bitcastToAPIntEv = comdat any

$_ZN4llvh6detail13DoubleAPFloataSEOS1_ = comdat any

$_ZN4llvh7APFloat9remainderERKS0_ = comdat any

$_ZN4llvh7APFloat3modERKS0_ = comdat any

$_ZN4llvh7APFloat15roundToIntegralENS_11APFloatBase12roundingModeE = comdat any

$_ZNK4llvh7APFloat11getCategoryEv = comdat any

$_ZN4llvh7APFloat7makeInfEb = comdat any

$_ZN4llvh7APFloat12makeSmallestEb = comdat any

$_ZN4llvh7APFloat7makeNaNEbbPKNS_5APIntE = comdat any

$_ZNK4llvh7APFloat7compareERKS0_ = comdat any

$_ZNK4llvh7APFloat14bitwiseIsEqualERKS0_ = comdat any

$_ZN4llvh12hash_combineIJNS_9hash_codeES1_EEES1_DpRKT_ = comdat any

$_ZN4llvh12hash_combineIJPKNS_12fltSemanticsEEEENS_9hash_codeEDpRKT_ = comdat any

$_ZN4llvh7APFloat4nextEb = comdat any

$_ZNK4llvh7APFloat16convertToIntegerENS_15MutableArrayRefImEEjbNS_11APFloatBase12roundingModeEPb = comdat any

$_ZN4llvh7APFloat16convertFromAPIntERKNS_5APIntEbNS_11APFloatBase12roundingModeE = comdat any

$_ZN4llvh7APFloat30convertFromSignExtendedIntegerEPKmjbNS_11APFloatBase12roundingModeE = comdat any

$_ZN4llvh7APFloat30convertFromZeroExtendedIntegerEPKmjbNS_11APFloatBase12roundingModeE = comdat any

$_ZNK4llvh7APFloat18convertToHexStringEPcjbNS_11APFloatBase12roundingModeE = comdat any

$_ZNK4llvh7APFloat10isDenormalEv = comdat any

$_ZNK4llvh7APFloatplERKS0_ = comdat any

$_ZNK4llvh7APFloat9isIntegerEv = comdat any

$_ZNK4llvh7APFloat8toStringERNS_15SmallVectorImplIcEEjjb = comdat any

$_ZNK4llvh7APFloat15getExactInverseEPS0_ = comdat any

$_ZN4llvh6scalbnENS_7APFloatEiNS_11APFloatBase12roundingModeE = comdat any

$_ZN4llvh5frexpERKNS_7APFloatERiNS_11APFloatBase12roundingModeE = comdat any

$_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE = comdat any

$_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE = comdat any

$_ZNK4llvh7APFloat12getSemanticsEv = comdat any

$_ZN4llvh7APFloat7getIEEEEv = comdat any

$_ZN4llvh5APInt15getAllOnesValueEj = comdat any

$_ZN4llvh11SmallVectorIcLj16EEC2Ev = comdat any

$_ZN4llvh11raw_ostreamlsERKNS_15SmallVectorImplIcEE = comdat any

$_ZN4llvh11raw_ostreamlsEPKc = comdat any

$_ZN4llvh11SmallVectorIcLj16EED2Ev = comdat any

$_ZN4llvh16FoldingSetNodeID3AddINS_5APIntEEEvRKT_ = comdat any

$_ZN4llvh11SmallVectorImLj4EEC2EmRKm = comdat any

$_ZN4llvh15MutableArrayRefImEC2ERNS_15SmallVectorImplImEE = comdat any

$_ZNK4llvh6APSInt8isSignedEv = comdat any

$_ZN4llvh8ArrayRefImEC2IvEERKNS_25SmallVectorTemplateCommonImT_EE = comdat any

$_ZN4llvh6APSIntaSENS_5APIntE = comdat any

$_ZN4llvh11SmallVectorImLj4EED2Ev = comdat any

$_ZN4llvh5APInt11getNumWordsEj = comdat any

$_ZNK4llvh5APInt12isSingleWordEv = comdat any

$_ZN4llvh5APInt15clearUnusedBitsEv = comdat any

$_ZNK4llvh5APInt12needsCleanupEv = comdat any

$_ZNK4llvh5APIntixEj = comdat any

$_ZN4llvh5APInt7maskBitEj = comdat any

$_ZNK4llvh5APInt7getWordEj = comdat any

$_ZN4llvh5APInt8whichBitEj = comdat any

$_ZN4llvh5APInt9whichWordEj = comdat any

$_ZN4llvh5APInt6negateEv = comdat any

$_ZN4llvh5APIntC2EOS0_ = comdat any

$_ZN4llvh5APInt11flipAllBitsEv = comdat any

$_ZN4llvh11BitsToFloatEj = comdat any

$_ZN4llvh12BitsToDoubleEm = comdat any

$_ZN4llvh11FloatToBitsEf = comdat any

$_ZN4llvh12DoubleToBitsEd = comdat any

$_ZN4llvh15SmallVectorImplIcE6appendIPKcvEEvT_S5_ = comdat any

$_ZSt8distanceIPKcENSt15iterator_traitsIT_E15difference_typeES3_S3_ = comdat any

$_ZNK4llvh15SmallVectorBase8capacityEv = comdat any

$_ZN4llvh23SmallVectorTemplateBaseIcLb1EE4growEm = comdat any

$_ZN4llvh23SmallVectorTemplateBaseIcLb1EE18uninitialized_copyIKccEEvPT_S5_PT0_PNSt9enable_ifIXsr3std7is_sameINSt12remove_constIS4_E4typeES6_EE5valueEvE4typeE = comdat any

$_ZN4llvh15SmallVectorBase8set_sizeEm = comdat any

$_ZSt10__distanceIPKcENSt15iterator_traitsIT_E15difference_typeES3_S3_St26random_access_iterator_tag = comdat any

$_ZSt19__iterator_categoryIPKcENSt15iterator_traitsIT_E17iterator_categoryERKS3_ = comdat any

$_ZN4llvh25SmallVectorTemplateCommonIcvE8grow_podEmm = comdat any

$_ZNK4llvh25SmallVectorTemplateCommonIcvE10getFirstElEv = comdat any

$_ZN4llvh18countTrailingZerosImEEmT_NS_12ZeroBehaviorE = comdat any

$_ZN4llvh6detail20TrailingZerosCounterImLm8EE5countEmNS_12ZeroBehaviorE = comdat any

$_ZNK4llvh5APInt13getActiveBitsEv = comdat any

$_ZNK4llvh5APInt17countLeadingZerosEv = comdat any

$_ZN4llvh17countLeadingZerosImEEmT_NS_12ZeroBehaviorE = comdat any

$_ZN4llvh6detail19LeadingZerosCounterImLm8EE5countEmNS_12ZeroBehaviorE = comdat any

$_ZNK4llvh5APInteqEm = comdat any

$_ZN4llvh15SmallVectorImplIcE5eraseEPKcS3_ = comdat any

$_ZN4llvh15SmallVectorImplIcE5clearEv = comdat any

$_ZSt4moveIPcS0_ET0_T_S2_S1_ = comdat any

$_ZN4llvh23SmallVectorTemplateBaseIcLb1EE13destroy_rangeEPcS2_ = comdat any

$_ZSt13__copy_move_aILb1EPcS0_ET1_T0_S2_S1_ = comdat any

$_ZSt12__miter_baseIPcET_S1_ = comdat any

$_ZSt12__niter_wrapIPcET_RKS1_S1_ = comdat any

$_ZSt14__copy_move_a1ILb1EPcS0_ET1_T0_S2_S1_ = comdat any

$_ZSt12__niter_baseIPcET_S1_ = comdat any

$_ZSt14__copy_move_a2ILb1EPcS0_ET1_T0_S2_S1_ = comdat any

$_ZNSt11__copy_moveILb1ELb1ESt26random_access_iterator_tagE8__copy_mIcEEPT_PKS3_S6_S4_ = comdat any

$_ZN4llvh7APFloat7StorageaSEOS1_ = comdat any

$_ZN4llvh7APFloat7StorageD2Ev = comdat any

$_ZN4llvh7APFloat7StorageC2EOS1_ = comdat any

$_ZN4llvh7APFloat7StorageC2IJNS_11APFloatBase16uninitializedTagEEEERKNS_12fltSemanticsEDpOT_ = comdat any

$_ZN4llvh7APFloat7StorageC2IJRmEEERKNS_12fltSemanticsEDpOT_ = comdat any

$_ZN4llvh7APFloat7StorageC2IJRKNS_5APIntEEEERKNS_12fltSemanticsEDpOT_ = comdat any

$_ZN4llvh7APFloat7StorageC2ERKS1_ = comdat any

$_ZNSt15__uniq_ptr_dataIN4llvh7APFloatESt14default_deleteIA_S1_ELb1ELb1EEC2EOS5_ = comdat any

$_ZNSt15__uniq_ptr_implIN4llvh7APFloatESt14default_deleteIA_S1_EEC2EOS5_ = comdat any

$_ZNSt5tupleIJPN4llvh7APFloatESt14default_deleteIA_S1_EEEC2EOS6_ = comdat any

$_ZNSt15__uniq_ptr_implIN4llvh7APFloatESt14default_deleteIA_S1_EE6_M_ptrEv = comdat any

$_ZNSt11_Tuple_implILm0EJPN4llvh7APFloatESt14default_deleteIA_S1_EEEC2EOS6_ = comdat any

$_ZNSt11_Tuple_implILm1EJSt14default_deleteIA_N4llvh7APFloatEEEEC2EOS5_ = comdat any

$_ZSt3getILm0EJPN4llvh7APFloatESt14default_deleteIA_S1_EEERNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERSA_ = comdat any

$_ZSt12__get_helperILm0EPN4llvh7APFloatEJSt14default_deleteIA_S1_EEERT0_RSt11_Tuple_implIXT_EJS6_DpT1_EE = comdat any

$_ZNSt11_Tuple_implILm0EJPN4llvh7APFloatESt14default_deleteIA_S1_EEE7_M_headERS6_ = comdat any

$_ZNSt10_Head_baseILm0EPN4llvh7APFloatELb0EE7_M_headERS3_ = comdat any

$_ZN4llvh7APFloat7StorageaSERKS1_ = comdat any

$_ZNSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EED2Ev = comdat any

$_ZNSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EE11get_deleterEv = comdat any

$_ZNKSt14default_deleteIA_N4llvh7APFloatEEclIS1_EENSt9enable_ifIXsr14is_convertibleIPA_T_PS2_EE5valueEvE4typeEPS6_ = comdat any

$_ZNSt15__uniq_ptr_implIN4llvh7APFloatESt14default_deleteIA_S1_EE10_M_deleterEv = comdat any

$_ZSt3getILm1EJPN4llvh7APFloatESt14default_deleteIA_S1_EEERNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERSA_ = comdat any

$_ZSt12__get_helperILm1ESt14default_deleteIA_N4llvh7APFloatEEJEERT0_RSt11_Tuple_implIXT_EJS5_DpT1_EE = comdat any

$_ZNSt11_Tuple_implILm1EJSt14default_deleteIA_N4llvh7APFloatEEEE7_M_headERS5_ = comdat any

$_ZNSt10_Head_baseILm1ESt14default_deleteIA_N4llvh7APFloatEELb1EE7_M_headERS5_ = comdat any

$_ZNK4llvh7APFloat5isNaNEv = comdat any

$_ZNK4llvh7APFloat7getIEEEEv = comdat any

$_ZNK4llvh6detail13DoubleAPFloat8getFirstEv = comdat any

$_ZNK4llvh6detail9IEEEFloat11getCategoryEv = comdat any

$_ZN4llvh7APFloatC2ENS_6detail13DoubleAPFloatERKNS_12fltSemanticsE = comdat any

$_ZN4llvh7APFloat7StorageC2ENS_6detail13DoubleAPFloatERKNS_12fltSemanticsE = comdat any

$_ZN4llvh7APFloat7StorageC2IJEEERKNS_12fltSemanticsEDpOT_ = comdat any

$_ZN4llvh6detail13DoubleAPFloat8getFirstEv = comdat any

$_ZNK4llvh25SmallVectorTemplateCommonIcvE4dataEv = comdat any

$_ZN4llvh11raw_ostreamlsENS_9StringRefE = comdat any

$_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EE3getEv = comdat any

$_ZNKSt15__uniq_ptr_implIN4llvh7APFloatESt14default_deleteIA_S1_EE6_M_ptrEv = comdat any

$_ZSt3getILm0EJPN4llvh7APFloatESt14default_deleteIA_S1_EEERKNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERKSA_ = comdat any

$_ZSt12__get_helperILm0EPN4llvh7APFloatEJSt14default_deleteIA_S1_EEERKT0_RKSt11_Tuple_implIXT_EJS6_DpT1_EE = comdat any

$_ZNSt11_Tuple_implILm0EJPN4llvh7APFloatESt14default_deleteIA_S1_EEE7_M_headERKS6_ = comdat any

$_ZNSt10_Head_baseILm0EPN4llvh7APFloatELb0EE7_M_headERKS3_ = comdat any

$_ZSt11__equal_auxIPKmS1_EbT_S2_T0_ = comdat any

$_ZSt12__equal_aux1IPKmS1_EbT_S2_T0_ = comdat any

$_ZSt12__niter_baseIPKmET_S2_ = comdat any

$_ZNSt7__equalILb1EE5equalImEEbPKT_S4_S4_ = comdat any

$_ZSt8__memcmpImmEiPKT_PKT0_m = comdat any

$_ZN4llvh15MutableArrayRefImEC2EPmm = comdat any

$_ZNK4llvh8ArrayRefImE4dataEv = comdat any

$_ZN4llvh8ArrayRefImEC2EPKmm = comdat any

$_ZN4llvh7hashing6detail29hash_combine_recursive_helperC2Ev = comdat any

$_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineIhJhjEEENS_9hash_codeEmPcS5_RKT_DpRKT0_ = comdat any

$_ZN4llvh7hashing6detail18get_execution_seedEv = comdat any

$_ZN4llvh7hashing6detail29hash_combine_recursive_helper12combine_dataIhEEPcRmS4_S4_T_ = comdat any

$_ZN4llvh7hashing6detail17get_hashable_dataIhEENSt9enable_ifIXsr16is_hashable_dataIT_EE5valueES4_E4typeERKS4_ = comdat any

$_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineIhJjEEENS_9hash_codeEmPcS5_RKT_DpRKT0_ = comdat any

$_ZN4llvh7hashing6detail17store_and_advanceIhEEbRPcS3_RKT_m = comdat any

$_ZN4llvh7hashing6detail10hash_state6createEPKcm = comdat any

$_ZN4llvh7hashing6detail10hash_state3mixEPKc = comdat any

$_ZN4llvh7hashing6detail13hash_16_bytesEmm = comdat any

$_ZN4llvh7hashing6detail6rotateEmm = comdat any

$_ZN4llvh7hashing6detail9shift_mixEm = comdat any

$_ZN4llvh7hashing6detail7fetch64EPKc = comdat any

$_ZN4llvh7hashing6detail10hash_state12mix_32_bytesEPKcRmS5_ = comdat any

$_ZSt4swapImENSt9enable_ifIXsr6__and_ISt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS3_ESt18is_move_assignableIS3_EEE5valueEvE4typeERS3_SC_ = comdat any

$_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineIjJEEENS_9hash_codeEmPcS5_RKT_DpRKT0_ = comdat any

$_ZN4llvh7hashing6detail29hash_combine_recursive_helper12combine_dataIjEEPcRmS4_S4_T_ = comdat any

$_ZN4llvh7hashing6detail17get_hashable_dataIjEENSt9enable_ifIXsr16is_hashable_dataIT_EE5valueES4_E4typeERKS4_ = comdat any

$_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineEmPcS3_ = comdat any

$_ZN4llvh7hashing6detail17store_and_advanceIjEEbRPcS3_RKT_m = comdat any

$_ZN4llvh7hashing6detail10hash_shortEPKcmm = comdat any

$_ZN4llvh9hash_codeC2Em = comdat any

$_ZNSt3_V26rotateIPcEET_S2_S2_S2_ = comdat any

$_ZN4llvh7hashing6detail10hash_state8finalizeEm = comdat any

$_ZN4llvh7hashing6detail15hash_4to8_bytesEPKcmm = comdat any

$_ZN4llvh7hashing6detail16hash_9to16_bytesEPKcmm = comdat any

$_ZN4llvh7hashing6detail17hash_17to32_bytesEPKcmm = comdat any

$_ZN4llvh7hashing6detail17hash_33to64_bytesEPKcmm = comdat any

$_ZN4llvh7hashing6detail15hash_1to3_bytesEPKcmm = comdat any

$_ZN4llvh7hashing6detail7fetch32EPKc = comdat any

$_ZNSt3_V28__rotateIPcEET_S2_S2_S2_St26random_access_iterator_tag = comdat any

$_ZSt19__iterator_categoryIPcENSt15iterator_traitsIT_E17iterator_categoryERKS2_ = comdat any

$_ZSt11swap_rangesIPcS0_ET0_T_S2_S1_ = comdat any

$_ZSt9iter_swapIPcS0_EvT_T0_ = comdat any

$_ZSt4swapIlENSt9enable_ifIXsr6__and_ISt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS3_ESt18is_move_assignableIS3_EEE5valueEvE4typeERS3_SC_ = comdat any

$_ZSt13move_backwardIPcS0_ET0_T_S2_S1_ = comdat any

$_ZSt4swapIcENSt9enable_ifIXsr6__and_ISt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS3_ESt18is_move_assignableIS3_EEE5valueEvE4typeERS3_SC_ = comdat any

$_ZSt22__copy_move_backward_aILb1EPcS0_ET1_T0_S2_S1_ = comdat any

$_ZSt23__copy_move_backward_a1ILb1EPcS0_ET1_T0_S2_S1_ = comdat any

$_ZSt23__copy_move_backward_a2ILb1EPcS0_ET1_T0_S2_S1_ = comdat any

$_ZNSt20__copy_move_backwardILb1ELb1ESt26random_access_iterator_tagE13__copy_move_bIcEEPT_PKS3_S6_S4_ = comdat any

$_ZN4llvh7hashing6detail23hash_combine_range_implIKmEENSt9enable_ifIXsr16is_hashable_dataIT_EE5valueENS_9hash_codeEE4typeEPS5_S9_ = comdat any

$_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineIhJhjsNS_9hash_codeEEEES4_mPcS5_RKT_DpRKT0_ = comdat any

$_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineIhJjsNS_9hash_codeEEEES4_mPcS5_RKT_DpRKT0_ = comdat any

$_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineIjJsNS_9hash_codeEEEES4_mPcS5_RKT_DpRKT0_ = comdat any

$_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineIsJNS_9hash_codeEEEES4_mPcS5_RKT_DpRKT0_ = comdat any

$_ZN4llvh7hashing6detail29hash_combine_recursive_helper12combine_dataIsEEPcRmS4_S4_T_ = comdat any

$_ZN4llvh7hashing6detail17get_hashable_dataIsEENSt9enable_ifIXsr16is_hashable_dataIT_EE5valueES4_E4typeERKS4_ = comdat any

$_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineINS_9hash_codeEJEEES4_mPcS5_RKT_DpRKT0_ = comdat any

$_ZN4llvh7hashing6detail17store_and_advanceIsEEbRPcS3_RKT_m = comdat any

$_ZN4llvh7hashing6detail29hash_combine_recursive_helper12combine_dataImEEPcRmS4_S4_T_ = comdat any

$_ZN4llvh7hashing6detail17get_hashable_dataINS_9hash_codeEEENSt9enable_ifIXntsr16is_hashable_dataIT_EE5valueEmE4typeERKS5_ = comdat any

$_ZN4llvh7hashing6detail17store_and_advanceImEEbRPcS3_RKT_m = comdat any

$_ZN4llvh10hash_valueERKNS_9hash_codeE = comdat any

$_ZSt20uninitialized_fill_nIPcmcET_S1_T0_RKT1_ = comdat any

$_ZNSt22__uninitialized_fill_nILb1EE15__uninit_fill_nIPcmcEET_S3_T0_RKT1_ = comdat any

$_ZSt6fill_nIPcmcET_S1_T0_RKT1_ = comdat any

$_ZSt10__fill_n_aIPcmcET_S1_T0_RKT1_St26random_access_iterator_tag = comdat any

$_ZSt17__size_to_integerm = comdat any

$_ZSt8__fill_aIPccEvT_S1_RKT0_ = comdat any

$_ZSt9__fill_a1IcEN9__gnu_cxx11__enable_ifIXsr9__is_byteIT_EE7__valueEvE6__typeEPS2_S5_RKS2_ = comdat any

$_ZN4llvh15SmallVectorImplIcEC2Ej = comdat any

$_ZN4llvh23SmallVectorTemplateBaseIcLb1EEC2Em = comdat any

$_ZN4llvh25SmallVectorTemplateCommonIcvEC2Em = comdat any

$_ZN4llvh15SmallVectorBaseC2EPvm = comdat any

$_ZN4llvh15SmallVectorImplIcED2Ev = comdat any

$_ZNK4llvh25SmallVectorTemplateCommonIcvE7isSmallEv = comdat any

$_ZNSt15__uniq_ptr_dataIN4llvh7APFloatESt14default_deleteIA_S1_ELb1ELb1EECI2St15__uniq_ptr_implIS1_S4_EEPS1_ = comdat any

$_ZNSt15__uniq_ptr_implIN4llvh7APFloatESt14default_deleteIA_S1_EEC2EPS1_ = comdat any

$_ZNSt5tupleIJPN4llvh7APFloatESt14default_deleteIA_S1_EEEC2ILb1ETnNSt9enable_ifIXclsr17_TupleConstraintsIXT_ES2_S5_EE37__is_implicitly_default_constructibleEEbE4typeELb1EEEv = comdat any

$_ZNSt11_Tuple_implILm0EJPN4llvh7APFloatESt14default_deleteIA_S1_EEEC2Ev = comdat any

$_ZNSt11_Tuple_implILm1EJSt14default_deleteIA_N4llvh7APFloatEEEEC2Ev = comdat any

$_ZNSt10_Head_baseILm0EPN4llvh7APFloatELb0EEC2Ev = comdat any

$_ZNSt10_Head_baseILm1ESt14default_deleteIA_N4llvh7APFloatEELb1EEC2Ev = comdat any

$_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineINS_9hash_codeEJS4_EEES4_mPcS5_RKT_DpRKT0_ = comdat any

$_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineIPKNS_12fltSemanticsEJEEENS_9hash_codeEmPcS8_RKT_DpRKT0_ = comdat any

$_ZN4llvh7hashing6detail29hash_combine_recursive_helper12combine_dataIPKNS_12fltSemanticsEEEPcRmS7_S7_T_ = comdat any

$_ZN4llvh7hashing6detail17get_hashable_dataIPKNS_12fltSemanticsEEENSt9enable_ifIXsr16is_hashable_dataIT_EE5valueES7_E4typeERKS7_ = comdat any

$_ZN4llvh7hashing6detail17store_and_advanceIPKNS_12fltSemanticsEEEbRPcS6_RKT_m = comdat any

$_ZN4llvh22DefaultFoldingSetTraitINS_5APIntEE7ProfileERKS1_RNS_16FoldingSetNodeIDE = comdat any

$_ZN4llvh15SmallVectorImplImEC2Ej = comdat any

$_ZN4llvh15SmallVectorImplImE6assignEmRKm = comdat any

$_ZN4llvh23SmallVectorTemplateBaseImLb1EEC2Em = comdat any

$_ZN4llvh25SmallVectorTemplateCommonImvEC2Em = comdat any

$_ZNK4llvh25SmallVectorTemplateCommonImvE10getFirstElEv = comdat any

$_ZN4llvh15SmallVectorImplImE5clearEv = comdat any

$_ZN4llvh23SmallVectorTemplateBaseImLb1EE4growEm = comdat any

$_ZSt18uninitialized_fillIPmmEvT_S1_RKT0_ = comdat any

$_ZN4llvh23SmallVectorTemplateBaseImLb1EE13destroy_rangeEPmS2_ = comdat any

$_ZN4llvh25SmallVectorTemplateCommonImvE8grow_podEmm = comdat any

$_ZNSt20__uninitialized_fillILb1EE13__uninit_fillIPmmEEvT_S3_RKT0_ = comdat any

$_ZSt4fillIPmmEvT_S1_RKT0_ = comdat any

$_ZSt8__fill_aIPmmEvT_S1_RKT0_ = comdat any

$_ZSt9__fill_a1IPmmEN9__gnu_cxx11__enable_ifIXsr11__is_scalarIT0_EE7__valueEvE6__typeET_S6_RKS3_ = comdat any

$_ZN4llvh15SmallVectorImplImED2Ev = comdat any

$_ZNK4llvh25SmallVectorTemplateCommonImvE7isSmallEv = comdat any

$_ZNK4llvh25SmallVectorTemplateCommonImvE4dataEv = comdat any

$_ZZN4llvh7hashing6detail18get_execution_seedEvE4seed = comdat any

$_ZGVZN4llvh7hashing6detail18get_execution_seedEvE4seed = comdat any

@_ZN4llvhL11semIEEEhalfE = internal constant %"struct.llvh::fltSemantics" { i16 15, i16 -14, i32 11, i32 16 }, align 4
@_ZN4llvhL13semIEEEsingleE = internal constant %"struct.llvh::fltSemantics" { i16 127, i16 -126, i32 24, i32 32 }, align 4
@_ZN4llvhL13semIEEEdoubleE = internal constant %"struct.llvh::fltSemantics" { i16 1023, i16 -1022, i32 53, i32 64 }, align 4
@_ZN4llvhL11semIEEEquadE = internal constant %"struct.llvh::fltSemantics" { i16 16383, i16 -16382, i32 113, i32 128 }, align 4
@_ZN4llvhL20semX87DoubleExtendedE = internal constant %"struct.llvh::fltSemantics" { i16 16383, i16 -16382, i32 64, i32 80 }, align 4
@_ZN4llvhL8semBogusE = internal constant %"struct.llvh::fltSemantics" zeroinitializer, align 4
@_ZN4llvhL18semPPCDoubleDoubleE = internal constant %"struct.llvh::fltSemantics" { i16 -1, i16 0, i32 0, i32 0 }, align 4
@__const._ZN4llvh6detail9IEEEFloat28roundSignificandWithExponentEPKmjiNS_11APFloatBase12roundingModeE.calcSemantics = private unnamed_addr constant %"struct.llvh::fltSemantics" { i16 32767, i16 -32767, i32 0, i32 0 }, align 4
@.str = private unnamed_addr constant [4 x i8] c"inf\00", align 1
@.str.1 = private unnamed_addr constant [9 x i8] c"INFINITY\00", align 1
@.str.2 = private unnamed_addr constant [5 x i8] c"+Inf\00", align 1
@.str.3 = private unnamed_addr constant [5 x i8] c"-inf\00", align 1
@.str.4 = private unnamed_addr constant [10 x i8] c"-INFINITY\00", align 1
@.str.5 = private unnamed_addr constant [5 x i8] c"-Inf\00", align 1
@.str.6 = private unnamed_addr constant [4 x i8] c"nan\00", align 1
@.str.7 = private unnamed_addr constant [4 x i8] c"NaN\00", align 1
@.str.8 = private unnamed_addr constant [5 x i8] c"-nan\00", align 1
@.str.9 = private unnamed_addr constant [5 x i8] c"-NaN\00", align 1
@_ZN4llvhL9infinityUE = internal constant [9 x i8] c"INFINITY\00", align 1
@_ZN4llvhL9infinityLE = internal constant [9 x i8] c"infinity\00", align 1
@_ZN4llvhL4NaNUE = internal constant [4 x i8] c"NAN\00", align 1
@_ZN4llvhL4NaNLE = internal constant [4 x i8] c"nan\00", align 1
@_ZN4llvhL14hexDigitsUpperE = internal constant [18 x i8] c"0123456789ABCDEF0\00", align 16
@_ZN4llvhL14hexDigitsLowerE = internal constant [18 x i8] c"0123456789abcdef0\00", align 16
@_ZN4llvhL24semPPCDoubleDoubleLegacyE = internal constant %"struct.llvh::fltSemantics" { i16 1023, i16 -969, i32 106, i32 128 }, align 4
@.str.10 = private unnamed_addr constant [7 x i8] c"0.0E+0\00", align 1
@.str.11 = private unnamed_addr constant [4 x i8] c"0.0\00", align 1
@.str.12 = private unnamed_addr constant [5 x i8] c"e+00\00", align 1
@.str.13 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@_ZZN4llvhL8powerOf5EPmjE16firstEightPowers = internal constant [8 x i64] [i64 1, i64 5, i64 25, i64 125, i64 625, i64 3125, i64 15625, i64 78125], align 16
@_ZZN4llvh7hashing6detail18get_execution_seedEvE4seed = linkonce_odr hidden global i64 0, comdat, align 8
@_ZGVZN4llvh7hashing6detail18get_execution_seedEvE4seed = linkonce_odr hidden global i64 0, comdat, align 8
@_ZN4llvh7hashing6detail19fixed_seed_overrideE = external global i64, align 8

@_ZN4llvh6detail9IEEEFloatC1ERKNS_12fltSemanticsEm = hidden unnamed_addr alias void (ptr, ptr, i64), ptr @_ZN4llvh6detail9IEEEFloatC2ERKNS_12fltSemanticsEm
@_ZN4llvh6detail9IEEEFloatC1ERKNS_12fltSemanticsE = hidden unnamed_addr alias void (ptr, ptr), ptr @_ZN4llvh6detail9IEEEFloatC2ERKNS_12fltSemanticsE
@_ZN4llvh6detail9IEEEFloatC1ERKNS_12fltSemanticsENS_11APFloatBase16uninitializedTagE = hidden unnamed_addr alias void (ptr, ptr, i32), ptr @_ZN4llvh6detail9IEEEFloatC2ERKNS_12fltSemanticsENS_11APFloatBase16uninitializedTagE
@_ZN4llvh6detail9IEEEFloatC1ERKS1_ = hidden unnamed_addr alias void (ptr, ptr), ptr @_ZN4llvh6detail9IEEEFloatC2ERKS1_
@_ZN4llvh6detail9IEEEFloatC1EOS1_ = hidden unnamed_addr alias void (ptr, ptr), ptr @_ZN4llvh6detail9IEEEFloatC2EOS1_
@_ZN4llvh6detail9IEEEFloatD1Ev = hidden unnamed_addr alias void (ptr), ptr @_ZN4llvh6detail9IEEEFloatD2Ev
@_ZN4llvh6detail9IEEEFloatC1ERKNS_12fltSemanticsERKNS_5APIntE = hidden unnamed_addr alias void (ptr, ptr, ptr), ptr @_ZN4llvh6detail9IEEEFloatC2ERKNS_12fltSemanticsERKNS_5APIntE
@_ZN4llvh6detail9IEEEFloatC1Ef = hidden unnamed_addr alias void (ptr, float), ptr @_ZN4llvh6detail9IEEEFloatC2Ef
@_ZN4llvh6detail9IEEEFloatC1Ed = hidden unnamed_addr alias void (ptr, double), ptr @_ZN4llvh6detail9IEEEFloatC2Ed
@_ZN4llvh6detail13DoubleAPFloatC1ERKNS_12fltSemanticsE = hidden unnamed_addr alias void (ptr, ptr), ptr @_ZN4llvh6detail13DoubleAPFloatC2ERKNS_12fltSemanticsE
@_ZN4llvh6detail13DoubleAPFloatC1ERKNS_12fltSemanticsENS_11APFloatBase16uninitializedTagE = hidden unnamed_addr alias void (ptr, ptr, i32), ptr @_ZN4llvh6detail13DoubleAPFloatC2ERKNS_12fltSemanticsENS_11APFloatBase16uninitializedTagE
@_ZN4llvh6detail13DoubleAPFloatC1ERKNS_12fltSemanticsEm = hidden unnamed_addr alias void (ptr, ptr, i64), ptr @_ZN4llvh6detail13DoubleAPFloatC2ERKNS_12fltSemanticsEm
@_ZN4llvh6detail13DoubleAPFloatC1ERKNS_12fltSemanticsERKNS_5APIntE = hidden unnamed_addr alias void (ptr, ptr, ptr), ptr @_ZN4llvh6detail13DoubleAPFloatC2ERKNS_12fltSemanticsERKNS_5APIntE
@_ZN4llvh6detail13DoubleAPFloatC1ERKNS_12fltSemanticsEONS_7APFloatES6_ = hidden unnamed_addr alias void (ptr, ptr, ptr, ptr), ptr @_ZN4llvh6detail13DoubleAPFloatC2ERKNS_12fltSemanticsEONS_7APFloatES6_
@_ZN4llvh6detail13DoubleAPFloatC1ERKS1_ = hidden unnamed_addr alias void (ptr, ptr), ptr @_ZN4llvh6detail13DoubleAPFloatC2ERKS1_
@_ZN4llvh6detail13DoubleAPFloatC1EOS1_ = hidden unnamed_addr alias void (ptr, ptr), ptr @_ZN4llvh6detail13DoubleAPFloatC2EOS1_
@_ZN4llvh7APFloat7StorageC1ENS_6detail9IEEEFloatERKNS_12fltSemanticsE = hidden unnamed_addr alias void (ptr, ptr, ptr), ptr @_ZN4llvh7APFloat7StorageC2ENS_6detail9IEEEFloatERKNS_12fltSemanticsE
@_ZN4llvh7APFloatC1ERKNS_12fltSemanticsENS_9StringRefE = hidden unnamed_addr alias void (ptr, ptr, ptr, i64), ptr @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsENS_9StringRefE

; Function Attrs: mustprogress nounwind willreturn memory(none) uwtable
define hidden noundef nonnull align 4 dereferenceable(12) ptr @_ZN4llvh11APFloatBase8IEEEhalfEv() #0 align 2 {
entry:
  ret ptr @_ZN4llvhL11semIEEEhalfE
}

; Function Attrs: mustprogress nounwind willreturn memory(none) uwtable
define hidden noundef nonnull align 4 dereferenceable(12) ptr @_ZN4llvh11APFloatBase10IEEEsingleEv() #0 align 2 {
entry:
  ret ptr @_ZN4llvhL13semIEEEsingleE
}

; Function Attrs: mustprogress nounwind willreturn memory(none) uwtable
define hidden noundef nonnull align 4 dereferenceable(12) ptr @_ZN4llvh11APFloatBase10IEEEdoubleEv() #0 align 2 {
entry:
  ret ptr @_ZN4llvhL13semIEEEdoubleE
}

; Function Attrs: mustprogress nounwind willreturn memory(none) uwtable
define hidden noundef nonnull align 4 dereferenceable(12) ptr @_ZN4llvh11APFloatBase8IEEEquadEv() #0 align 2 {
entry:
  ret ptr @_ZN4llvhL11semIEEEquadE
}

; Function Attrs: mustprogress nounwind willreturn memory(none) uwtable
define hidden noundef nonnull align 4 dereferenceable(12) ptr @_ZN4llvh11APFloatBase17x87DoubleExtendedEv() #0 align 2 {
entry:
  ret ptr @_ZN4llvhL20semX87DoubleExtendedE
}

; Function Attrs: mustprogress nounwind willreturn memory(none) uwtable
define hidden noundef nonnull align 4 dereferenceable(12) ptr @_ZN4llvh11APFloatBase5BogusEv() #0 align 2 {
entry:
  ret ptr @_ZN4llvhL8semBogusE
}

; Function Attrs: mustprogress nounwind willreturn memory(none) uwtable
define hidden noundef nonnull align 4 dereferenceable(12) ptr @_ZN4llvh11APFloatBase15PPCDoubleDoubleEv() #0 align 2 {
entry:
  ret ptr @_ZN4llvhL18semPPCDoubleDoubleE
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh11APFloatBase18semanticsPrecisionERKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %semantics) #1 align 2 {
entry:
  %semantics.addr = alloca ptr, align 8
  store ptr %semantics, ptr %semantics.addr, align 8
  %0 = load ptr, ptr %semantics.addr, align 8
  %precision = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %0, i32 0, i32 2
  %1 = load i32, ptr %precision, align 4
  ret i32 %1
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef signext i16 @_ZN4llvh11APFloatBase20semanticsMaxExponentERKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %semantics) #1 align 2 {
entry:
  %semantics.addr = alloca ptr, align 8
  store ptr %semantics, ptr %semantics.addr, align 8
  %0 = load ptr, ptr %semantics.addr, align 8
  %maxExponent = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %0, i32 0, i32 0
  %1 = load i16, ptr %maxExponent, align 4
  ret i16 %1
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef signext i16 @_ZN4llvh11APFloatBase20semanticsMinExponentERKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %semantics) #1 align 2 {
entry:
  %semantics.addr = alloca ptr, align 8
  store ptr %semantics, ptr %semantics.addr, align 8
  %0 = load ptr, ptr %semantics.addr, align 8
  %minExponent = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %0, i32 0, i32 1
  %1 = load i16, ptr %minExponent, align 2
  ret i16 %1
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh11APFloatBase19semanticsSizeInBitsERKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %semantics) #1 align 2 {
entry:
  %semantics.addr = alloca ptr, align 8
  store ptr %semantics, ptr %semantics.addr, align 8
  %0 = load ptr, ptr %semantics.addr, align 8
  %sizeInBits = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %0, i32 0, i32 3
  %1 = load i32, ptr %sizeInBits, align 4
  ret i32 %1
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh11APFloatBase13getSizeInBitsERKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %Sem) #1 align 2 {
entry:
  %Sem.addr = alloca ptr, align 8
  store ptr %Sem, ptr %Sem.addr, align 8
  %0 = load ptr, ptr %Sem.addr, align 8
  %sizeInBits = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %0, i32 0, i32 3
  %1 = load i32, ptr %sizeInBits, align 4
  ret i32 %1
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloat10initializeEPKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %ourSemantics) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ourSemantics.addr = alloca ptr, align 8
  %count = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %ourSemantics, ptr %ourSemantics.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %ourSemantics.addr, align 8
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  store ptr %0, ptr %semantics, align 8
  %call = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store i32 %call, ptr %count, align 4
  %1 = load i32, ptr %count, align 4
  %cmp = icmp ugt i32 %1, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %count, align 4
  %conv = zext i32 %2 to i64
  %3 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %conv, i64 8)
  %4 = extractvalue { i64, i1 } %3, 1
  %5 = extractvalue { i64, i1 } %3, 0
  %6 = select i1 %4, i64 -1, i64 %5
  %call2 = call noalias noundef nonnull ptr @_Znam(i64 noundef %6) #13
  %significand = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 1
  store ptr %call2, ptr %significand, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %semantics, align 8
  %precision = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %0, i32 0, i32 2
  %1 = load i32, ptr %precision, align 4
  %add = add i32 %1, 1
  %call = call noundef i32 @_ZN4llvhL16partCountForBitsEj(i32 noundef %add)
  ret i32 %call
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare { i64, i1 } @llvm.umul.with.overflow.i64(i64, i64) #2

; Function Attrs: nobuiltin allocsize(0)
declare noundef nonnull ptr @_Znam(i64 noundef) #3

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloat15freeSignificandEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat12needsCleanupEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %significand = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %significand, align 8
  %isnull = icmp eq ptr %0, null
  br i1 %isnull, label %delete.end, label %delete.notnull

delete.notnull:                                   ; preds = %if.then
  call void @_ZdaPv(ptr noundef %0) #14
  br label %delete.end

delete.end:                                       ; preds = %delete.notnull, %if.then
  br label %if.end

if.end:                                           ; preds = %delete.end, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat12needsCleanupEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %cmp = icmp ugt i32 %call, 1
  ret i1 %cmp
}

; Function Attrs: nobuiltin nounwind
declare void @_ZdaPv(ptr noundef) #4

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloat6assignERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %rhs) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %0, i32 0, i32 3
  %bf.load = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load, 3
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %sign2 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %1 = trunc i32 %bf.cast to i8
  %bf.load3 = load i8, ptr %sign2, align 2
  %bf.value = and i8 %1, 1
  %bf.shl = shl i8 %bf.value, 3
  %bf.clear4 = and i8 %bf.load3, -9
  %bf.set = or i8 %bf.clear4, %bf.shl
  store i8 %bf.set, ptr %sign2, align 2
  %2 = load ptr, ptr %rhs.addr, align 8
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %2, i32 0, i32 3
  %bf.load5 = load i8, ptr %category, align 2
  %bf.clear6 = and i8 %bf.load5, 7
  %bf.cast7 = zext i8 %bf.clear6 to i32
  %category8 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %3 = trunc i32 %bf.cast7 to i8
  %bf.load9 = load i8, ptr %category8, align 2
  %bf.value10 = and i8 %3, 7
  %bf.clear11 = and i8 %bf.load9, -8
  %bf.set12 = or i8 %bf.clear11, %bf.value10
  store i8 %bf.set12, ptr %category8, align 2
  %4 = load ptr, ptr %rhs.addr, align 8
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %4, i32 0, i32 2
  %5 = load i16, ptr %exponent, align 8
  %exponent13 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 %5, ptr %exponent13, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %category14 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load15 = load i8, ptr %category14, align 2
  %bf.clear16 = and i8 %bf.load15, 7
  %bf.cast17 = zext i8 %bf.clear16 to i32
  %cmp = icmp eq i32 %bf.cast17, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %6 = load ptr, ptr %rhs.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloat15copySignificandERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %6)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat8isFiniteEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %call2 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat6isZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %lnot = xor i1 %call2, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %0 = phi i1 [ false, %entry ], [ %lnot, %land.rhs ]
  ret i1 %0
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloat15copySignificandERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %rhs) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %0 = load ptr, ptr %rhs.addr, align 8
  %call2 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %0)
  %call3 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  call void @_ZN4llvh5APInt8tcAssignEPmPKmj(ptr noundef %call, ptr noundef %call2, i32 noundef %call3)
  ret void
}

declare void @_ZN4llvh5APInt8tcAssignEPmPKmj(ptr noundef, ptr noundef, i32 noundef) #5

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %cmp = icmp ugt i32 %call, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %significand = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %significand, align 8
  store ptr %0, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %significand2 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 1
  store ptr %significand2, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %1 = load ptr, ptr %retval, align 8
  ret ptr %1
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloat7makeNaNEbbPKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this, i1 noundef zeroext %SNaN, i1 noundef zeroext %Negative, ptr noundef %fill) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %SNaN.addr = alloca i8, align 1
  %Negative.addr = alloca i8, align 1
  %fill.addr = alloca ptr, align 8
  %significand = alloca ptr, align 8
  %numParts = alloca i32, align 4
  %ref.tmp = alloca i32, align 4
  %bitsToPreserve = alloca i32, align 4
  %part = alloca i32, align 4
  %QNaNBit = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %SNaN to i8
  store i8 %frombool, ptr %SNaN.addr, align 1
  %frombool1 = zext i1 %Negative to i8
  store i8 %frombool1, ptr %Negative.addr, align 1
  store ptr %fill, ptr %fill.addr, align 8
  %this2 = load ptr, ptr %this.addr, align 8
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this2, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, -8
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, ptr %category, align 2
  %0 = load i8, ptr %Negative.addr, align 1
  %tobool = trunc i8 %0 to i1
  %conv = zext i1 %tobool to i32
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this2, i32 0, i32 3
  %1 = trunc i32 %conv to i8
  %bf.load3 = load i8, ptr %sign, align 2
  %bf.value = and i8 %1, 1
  %bf.shl = shl i8 %bf.value, 3
  %bf.clear4 = and i8 %bf.load3, -9
  %bf.set5 = or i8 %bf.clear4, %bf.shl
  store i8 %bf.set5, ptr %sign, align 2
  %call = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this2)
  store ptr %call, ptr %significand, align 8
  %call6 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this2)
  store i32 %call6, ptr %numParts, align 4
  %2 = load ptr, ptr %fill.addr, align 8
  %tobool7 = icmp ne ptr %2, null
  br i1 %tobool7, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %3 = load ptr, ptr %fill.addr, align 8
  %call8 = call noundef i32 @_ZNK4llvh5APInt11getNumWordsEv(ptr noundef nonnull align 8 dereferenceable(12) %3)
  %4 = load i32, ptr %numParts, align 4
  %cmp = icmp ult i32 %call8, %4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %5 = load ptr, ptr %significand, align 8
  %6 = load i32, ptr %numParts, align 4
  call void @_ZN4llvh5APInt5tcSetEPmmj(ptr noundef %5, i64 noundef 0, i32 noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %7 = load ptr, ptr %fill.addr, align 8
  %tobool9 = icmp ne ptr %7, null
  br i1 %tobool9, label %if.then10, label %if.end19

if.then10:                                        ; preds = %if.end
  %8 = load ptr, ptr %significand, align 8
  %9 = load ptr, ptr %fill.addr, align 8
  %call11 = call noundef ptr @_ZNK4llvh5APInt10getRawDataEv(ptr noundef nonnull align 8 dereferenceable(12) %9)
  %10 = load ptr, ptr %fill.addr, align 8
  %call12 = call noundef i32 @_ZNK4llvh5APInt11getNumWordsEv(ptr noundef nonnull align 8 dereferenceable(12) %10)
  store i32 %call12, ptr %ref.tmp, align 4
  %call13 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZSt3minIjERKT_S2_S2_(ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(4) %numParts)
  %11 = load i32, ptr %call13, align 4
  call void @_ZN4llvh5APInt8tcAssignEPmPKmj(ptr noundef %8, ptr noundef %call11, i32 noundef %11)
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this2, i32 0, i32 0
  %12 = load ptr, ptr %semantics, align 8
  %precision = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %12, i32 0, i32 2
  %13 = load i32, ptr %precision, align 4
  %sub = sub i32 %13, 1
  store i32 %sub, ptr %bitsToPreserve, align 4
  %14 = load i32, ptr %bitsToPreserve, align 4
  %div = udiv i32 %14, 64
  store i32 %div, ptr %part, align 4
  %15 = load i32, ptr %bitsToPreserve, align 4
  %rem = urem i32 %15, 64
  store i32 %rem, ptr %bitsToPreserve, align 4
  %16 = load i32, ptr %bitsToPreserve, align 4
  %sh_prom = zext i32 %16 to i64
  %shl = shl i64 1, %sh_prom
  %sub14 = sub i64 %shl, 1
  %17 = load ptr, ptr %significand, align 8
  %18 = load i32, ptr %part, align 4
  %idxprom = zext i32 %18 to i64
  %arrayidx = getelementptr inbounds i64, ptr %17, i64 %idxprom
  %19 = load i64, ptr %arrayidx, align 8
  %and = and i64 %19, %sub14
  store i64 %and, ptr %arrayidx, align 8
  %20 = load i32, ptr %part, align 4
  %inc = add i32 %20, 1
  store i32 %inc, ptr %part, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then10
  %21 = load i32, ptr %part, align 4
  %22 = load i32, ptr %numParts, align 4
  %cmp15 = icmp ne i32 %21, %22
  br i1 %cmp15, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %23 = load ptr, ptr %significand, align 8
  %24 = load i32, ptr %part, align 4
  %idxprom16 = zext i32 %24 to i64
  %arrayidx17 = getelementptr inbounds i64, ptr %23, i64 %idxprom16
  store i64 0, ptr %arrayidx17, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %25 = load i32, ptr %part, align 4
  %inc18 = add i32 %25, 1
  store i32 %inc18, ptr %part, align 4
  br label %for.cond, !llvm.loop !4

for.end:                                          ; preds = %for.cond
  br label %if.end19

if.end19:                                         ; preds = %for.end, %if.end
  %semantics20 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this2, i32 0, i32 0
  %26 = load ptr, ptr %semantics20, align 8
  %precision21 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %26, i32 0, i32 2
  %27 = load i32, ptr %precision21, align 4
  %sub22 = sub i32 %27, 2
  store i32 %sub22, ptr %QNaNBit, align 4
  %28 = load i8, ptr %SNaN.addr, align 1
  %tobool23 = trunc i8 %28 to i1
  br i1 %tobool23, label %if.then24, label %if.else

if.then24:                                        ; preds = %if.end19
  %29 = load ptr, ptr %significand, align 8
  %30 = load i32, ptr %QNaNBit, align 4
  call void @_ZN4llvh5APInt10tcClearBitEPmj(ptr noundef %29, i32 noundef %30)
  %31 = load ptr, ptr %significand, align 8
  %32 = load i32, ptr %numParts, align 4
  %call25 = call noundef zeroext i1 @_ZN4llvh5APInt8tcIsZeroEPKmj(ptr noundef %31, i32 noundef %32)
  br i1 %call25, label %if.then26, label %if.end28

if.then26:                                        ; preds = %if.then24
  %33 = load ptr, ptr %significand, align 8
  %34 = load i32, ptr %QNaNBit, align 4
  %sub27 = sub i32 %34, 1
  call void @_ZN4llvh5APInt8tcSetBitEPmj(ptr noundef %33, i32 noundef %sub27)
  br label %if.end28

if.end28:                                         ; preds = %if.then26, %if.then24
  br label %if.end29

if.else:                                          ; preds = %if.end19
  %35 = load ptr, ptr %significand, align 8
  %36 = load i32, ptr %QNaNBit, align 4
  call void @_ZN4llvh5APInt8tcSetBitEPmj(ptr noundef %35, i32 noundef %36)
  br label %if.end29

if.end29:                                         ; preds = %if.else, %if.end28
  %semantics30 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this2, i32 0, i32 0
  %37 = load ptr, ptr %semantics30, align 8
  %cmp31 = icmp eq ptr %37, @_ZN4llvhL20semX87DoubleExtendedE
  br i1 %cmp31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.end29
  %38 = load ptr, ptr %significand, align 8
  %39 = load i32, ptr %QNaNBit, align 4
  %add = add i32 %39, 1
  call void @_ZN4llvh5APInt8tcSetBitEPmj(ptr noundef %38, i32 noundef %add)
  br label %if.end33

if.end33:                                         ; preds = %if.then32, %if.end29
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZNK4llvh5APInt11getNumWordsEv(ptr noundef nonnull align 8 dereferenceable(12) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %BitWidth = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %BitWidth, align 8
  %call = call noundef i32 @_ZN4llvh5APInt11getNumWordsEj(i32 noundef %0)
  ret i32 %call
}

declare void @_ZN4llvh5APInt5tcSetEPmmj(ptr noundef, i64 noundef, i32 noundef) #5

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef ptr @_ZNK4llvh5APInt10getRawDataEv(ptr noundef nonnull align 8 dereferenceable(12) %this) #1 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh5APInt12isSingleWordEv(ptr noundef nonnull align 8 dereferenceable(12) %this1)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %U = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 0
  store ptr %U, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %U2 = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %U2, align 8
  %arrayidx = getelementptr inbounds i64, ptr %0, i64 0
  store ptr %arrayidx, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %1 = load ptr, ptr %retval, align 8
  ret ptr %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 4 dereferenceable(4) ptr @_ZSt3minIjERKT_S2_S2_(ptr noundef nonnull align 4 dereferenceable(4) %__a, ptr noundef nonnull align 4 dereferenceable(4) %__b) #1 comdat {
entry:
  %retval = alloca ptr, align 8
  %__a.addr = alloca ptr, align 8
  %__b.addr = alloca ptr, align 8
  store ptr %__a, ptr %__a.addr, align 8
  store ptr %__b, ptr %__b.addr, align 8
  %0 = load ptr, ptr %__b.addr, align 8
  %1 = load i32, ptr %0, align 4
  %2 = load ptr, ptr %__a.addr, align 8
  %3 = load i32, ptr %2, align 4
  %cmp = icmp ult i32 %1, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %__b.addr, align 8
  store ptr %4, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %__a.addr, align 8
  store ptr %5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load ptr, ptr %retval, align 8
  ret ptr %6
}

declare void @_ZN4llvh5APInt10tcClearBitEPmj(ptr noundef, i32 noundef) #5

declare noundef zeroext i1 @_ZN4llvh5APInt8tcIsZeroEPKmj(ptr noundef, i32 noundef) #5

declare void @_ZN4llvh5APInt8tcSetBitEPmj(ptr noundef, i32 noundef) #5

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef nonnull align 8 dereferenceable(24) ptr @_ZN4llvh6detail9IEEEFloataSERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %rhs) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %cmp = icmp ne ptr %this1, %0
  br i1 %cmp, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %semantics, align 8
  %2 = load ptr, ptr %rhs.addr, align 8
  %semantics2 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %semantics2, align 8
  %cmp3 = icmp ne ptr %1, %3
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  call void @_ZN4llvh6detail9IEEEFloat15freeSignificandEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %4 = load ptr, ptr %rhs.addr, align 8
  %semantics5 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %semantics5, align 8
  call void @_ZN4llvh6detail9IEEEFloat10initializeEPKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %5)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  %6 = load ptr, ptr %rhs.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloat6assignERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %6)
  br label %if.end6

if.end6:                                          ; preds = %if.end, %entry
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef nonnull align 8 dereferenceable(24) ptr @_ZN4llvh6detail9IEEEFloataSEOS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %rhs) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloat15freeSignificandEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %0 = load ptr, ptr %rhs.addr, align 8
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %semantics, align 8
  %semantics2 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  store ptr %1, ptr %semantics2, align 8
  %2 = load ptr, ptr %rhs.addr, align 8
  %significand = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %2, i32 0, i32 1
  %significand3 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %significand3, ptr align 8 %significand, i64 8, i1 false)
  %3 = load ptr, ptr %rhs.addr, align 8
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %3, i32 0, i32 2
  %4 = load i16, ptr %exponent, align 8
  %exponent4 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 %4, ptr %exponent4, align 8
  %5 = load ptr, ptr %rhs.addr, align 8
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %5, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, 7
  %bf.cast = zext i8 %bf.clear to i32
  %category5 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %6 = trunc i32 %bf.cast to i8
  %bf.load6 = load i8, ptr %category5, align 2
  %bf.value = and i8 %6, 7
  %bf.clear7 = and i8 %bf.load6, -8
  %bf.set = or i8 %bf.clear7, %bf.value
  store i8 %bf.set, ptr %category5, align 2
  %7 = load ptr, ptr %rhs.addr, align 8
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %7, i32 0, i32 3
  %bf.load8 = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load8, 3
  %bf.clear9 = and i8 %bf.lshr, 1
  %bf.cast10 = zext i8 %bf.clear9 to i32
  %sign11 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %8 = trunc i32 %bf.cast10 to i8
  %bf.load12 = load i8, ptr %sign11, align 2
  %bf.value13 = and i8 %8, 1
  %bf.shl = shl i8 %bf.value13, 3
  %bf.clear14 = and i8 %bf.load12, -9
  %bf.set15 = or i8 %bf.clear14, %bf.shl
  store i8 %bf.set15, ptr %sign11, align 2
  %9 = load ptr, ptr %rhs.addr, align 8
  %semantics16 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %9, i32 0, i32 0
  store ptr @_ZN4llvhL8semBogusE, ptr %semantics16, align 8
  ret ptr %this1
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #6

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat10isDenormalEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %0 = load i16, ptr %exponent, align 8
  %conv = sext i16 %0 to i32
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %semantics, align 8
  %minExponent = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %1, i32 0, i32 1
  %2 = load i16, ptr %minExponent, align 2
  %conv2 = sext i16 %2 to i32
  %cmp = icmp eq i32 %conv, %conv2
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %call3 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %semantics4 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %semantics4, align 8
  %precision = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %3, i32 0, i32 2
  %4 = load i32, ptr %precision, align 4
  %sub = sub i32 %4, 1
  %call5 = call noundef i32 @_ZN4llvh5APInt12tcExtractBitEPKmj(ptr noundef %call3, i32 noundef %sub)
  %cmp6 = icmp eq i32 %call5, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %5 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %cmp6, %land.rhs ]
  ret i1 %5
}

declare noundef i32 @_ZN4llvh5APInt12tcExtractBitEPKmj(ptr noundef, i32 noundef) #5

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat10isSmallestEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %0 = load i16, ptr %exponent, align 8
  %conv = sext i16 %0 to i32
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %semantics, align 8
  %minExponent = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %1, i32 0, i32 1
  %2 = load i16, ptr %minExponent, align 2
  %conv2 = sext i16 %2 to i32
  %cmp = icmp eq i32 %conv, %conv2
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %call3 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat14significandMSBEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %cmp4 = icmp eq i32 %call3, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %3 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %cmp4, %land.rhs ]
  ret i1 %3
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZNK4llvh6detail9IEEEFloat14significandMSBEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call2 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call3 = call noundef i32 @_ZN4llvh5APInt5tcMSBEPKmj(ptr noundef %call, i32 noundef %call2)
  ret i32 %call3
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat20isSignificandAllOnesEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  %Parts = alloca ptr, align 8
  %PartCount = alloca i32, align 4
  %i = alloca i32, align 4
  %NumHighBits = alloca i32, align 4
  %HighBitFill = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store ptr %call, ptr %Parts, align 8
  %call2 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store i32 %call2, ptr %PartCount, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %1 = load i32, ptr %PartCount, align 4
  %sub = sub i32 %1, 1
  %cmp = icmp ult i32 %0, %sub
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %Parts, align 8
  %3 = load i32, ptr %i, align 4
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr inbounds i64, ptr %2, i64 %idxprom
  %4 = load i64, ptr %arrayidx, align 8
  %not = xor i64 %4, -1
  %tobool = icmp ne i64 %not, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %5 = load i32, ptr %i, align 4
  %inc = add i32 %5, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !6

for.end:                                          ; preds = %for.cond
  %6 = load i32, ptr %PartCount, align 4
  %mul = mul i32 %6, 64
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %7 = load ptr, ptr %semantics, align 8
  %precision = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %7, i32 0, i32 2
  %8 = load i32, ptr %precision, align 4
  %sub3 = sub i32 %mul, %8
  %add = add i32 %sub3, 1
  store i32 %add, ptr %NumHighBits, align 4
  %9 = load i32, ptr %NumHighBits, align 4
  %sub4 = sub i32 64, %9
  %sh_prom = zext i32 %sub4 to i64
  %shl = shl i64 -1, %sh_prom
  store i64 %shl, ptr %HighBitFill, align 8
  %10 = load ptr, ptr %Parts, align 8
  %11 = load i32, ptr %PartCount, align 4
  %sub5 = sub i32 %11, 1
  %idxprom6 = zext i32 %sub5 to i64
  %arrayidx7 = getelementptr inbounds i64, ptr %10, i64 %idxprom6
  %12 = load i64, ptr %arrayidx7, align 8
  %13 = load i64, ptr %HighBitFill, align 8
  %or = or i64 %12, %13
  %not8 = xor i64 %or, -1
  %tobool9 = icmp ne i64 %not8, 0
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %for.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end11:                                         ; preds = %for.end
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end11, %if.then10, %if.then
  %14 = load i1, ptr %retval, align 1
  ret i1 %14
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat21isSignificandAllZerosEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  %Parts = alloca ptr, align 8
  %PartCount = alloca i32, align 4
  %i = alloca i32, align 4
  %NumHighBits = alloca i32, align 4
  %HighBitMask = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store ptr %call, ptr %Parts, align 8
  %call2 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store i32 %call2, ptr %PartCount, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %1 = load i32, ptr %PartCount, align 4
  %sub = sub i32 %1, 1
  %cmp = icmp ult i32 %0, %sub
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %Parts, align 8
  %3 = load i32, ptr %i, align 4
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr inbounds i64, ptr %2, i64 %idxprom
  %4 = load i64, ptr %arrayidx, align 8
  %tobool = icmp ne i64 %4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %5 = load i32, ptr %i, align 4
  %inc = add i32 %5, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !7

for.end:                                          ; preds = %for.cond
  %6 = load i32, ptr %PartCount, align 4
  %mul = mul i32 %6, 64
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %7 = load ptr, ptr %semantics, align 8
  %precision = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %7, i32 0, i32 2
  %8 = load i32, ptr %precision, align 4
  %sub3 = sub i32 %mul, %8
  %add = add i32 %sub3, 1
  store i32 %add, ptr %NumHighBits, align 4
  %9 = load i32, ptr %NumHighBits, align 4
  %sh_prom = zext i32 %9 to i64
  %shr = lshr i64 -1, %sh_prom
  store i64 %shr, ptr %HighBitMask, align 8
  %10 = load ptr, ptr %Parts, align 8
  %11 = load i32, ptr %PartCount, align 4
  %sub4 = sub i32 %11, 1
  %idxprom5 = zext i32 %sub4 to i64
  %arrayidx6 = getelementptr inbounds i64, ptr %10, i64 %idxprom5
  %12 = load i64, ptr %arrayidx6, align 8
  %13 = load i64, ptr %HighBitMask, align 8
  %and = and i64 %12, %13
  %tobool7 = icmp ne i64 %and, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %for.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end9:                                          ; preds = %for.end
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end9, %if.then8, %if.then
  %14 = load i1, ptr %retval, align 1
  ret i1 %14
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat9isLargestEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %0 = load i16, ptr %exponent, align 8
  %conv = sext i16 %0 to i32
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %semantics, align 8
  %maxExponent = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %1, i32 0, i32 0
  %2 = load i16, ptr %maxExponent, align 4
  %conv2 = sext i16 %2 to i32
  %cmp = icmp eq i32 %conv, %conv2
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %call3 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat20isSignificandAllOnesEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %3 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %call3, %land.rhs ]
  ret i1 %3
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat9isIntegerEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  %truncated = alloca %"class.llvh::detail::IEEEFloat", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat8isFiniteEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  call void @_ZN4llvh6detail9IEEEFloatC1ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %truncated, ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call2 = call noundef i32 @_ZN4llvh6detail9IEEEFloat15roundToIntegralENS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %truncated, i32 noundef 3)
  %call3 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat7compareERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %truncated)
  %cmp = icmp eq i32 %call3, 1
  store i1 %cmp, ptr %retval, align 1
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %truncated) #10
  br label %return

return:                                           ; preds = %if.end, %if.then
  %0 = load i1, ptr %retval, align 1
  ret i1 %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat8isFiniteEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat5isNaNEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %call2 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat10isInfinityEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %lnot = xor i1 %call2, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %0 = phi i1 [ false, %entry ], [ %lnot, %land.rhs ]
  ret i1 %0
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat15roundToIntegralENS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this, i32 noundef %rounding_mode) #1 align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %rounding_mode.addr = alloca i32, align 4
  %fs = alloca i32, align 4
  %IntegerConstant = alloca %"class.llvh::APInt", align 8
  %MagicConstant = alloca %"class.llvh::detail::IEEEFloat", align 8
  %cleanup.dest.slot = alloca i32, align 4
  %inputSign = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  store i32 %rounding_mode, ptr %rounding_mode.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %0 = load i16, ptr %exponent, align 8
  %conv = sext i16 %0 to i32
  %add = add nsw i32 %conv, 1
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %semantics, align 8
  %call2 = call noundef i32 @_ZN4llvh11APFloatBase18semanticsPrecisionERKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %1)
  %cmp = icmp sge i32 %add, %call2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %semantics3 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %semantics3, align 8
  %call4 = call noundef i32 @_ZN4llvh11APFloatBase18semanticsPrecisionERKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %2)
  %conv5 = zext i32 %call4 to i64
  %call6 = call noundef i64 @_ZN4llvh12NextPowerOf2Em(i64 noundef %conv5)
  %conv7 = trunc i64 %call6 to i32
  call void @_ZN4llvh5APIntC2Ejmb(ptr noundef nonnull align 8 dereferenceable(12) %IntegerConstant, i32 noundef %conv7, i64 noundef 1, i1 noundef zeroext false)
  %semantics8 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %semantics8, align 8
  %call9 = call noundef i32 @_ZN4llvh11APFloatBase18semanticsPrecisionERKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %3)
  %sub = sub i32 %call9, 1
  %call10 = call noundef nonnull align 8 dereferenceable(12) ptr @_ZN4llvh5APIntlSEj(ptr noundef nonnull align 8 dereferenceable(12) %IntegerConstant, i32 noundef %sub)
  %semantics11 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %semantics11, align 8
  call void @_ZN4llvh6detail9IEEEFloatC1ERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(24) %MagicConstant, ptr noundef nonnull align 4 dereferenceable(12) %4)
  %call12 = call noundef i32 @_ZN4llvh6detail9IEEEFloat16convertFromAPIntERKNS_5APIntEbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %MagicConstant, ptr noundef nonnull align 8 dereferenceable(12) %IntegerConstant, i1 noundef zeroext false, i32 noundef 0)
  store i32 %call12, ptr %fs, align 4
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load, 3
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %sign13 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %MagicConstant, i32 0, i32 3
  %5 = trunc i32 %bf.cast to i8
  %bf.load14 = load i8, ptr %sign13, align 2
  %bf.value = and i8 %5, 1
  %bf.shl = shl i8 %bf.value, 3
  %bf.clear15 = and i8 %bf.load14, -9
  %bf.set = or i8 %bf.clear15, %bf.shl
  store i8 %bf.set, ptr %sign13, align 2
  %6 = load i32, ptr %fs, align 4
  %cmp16 = icmp ne i32 %6, 0
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end
  %7 = load i32, ptr %fs, align 4
  store i32 %7, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end18:                                         ; preds = %if.end
  %call19 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %frombool = zext i1 %call19 to i8
  store i8 %frombool, ptr %inputSign, align 1
  %8 = load i32, ptr %rounding_mode.addr, align 4
  %call20 = call noundef i32 @_ZN4llvh6detail9IEEEFloat3addERKS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %MagicConstant, i32 noundef %8)
  store i32 %call20, ptr %fs, align 4
  %9 = load i32, ptr %fs, align 4
  %cmp21 = icmp ne i32 %9, 0
  br i1 %cmp21, label %land.lhs.true22, label %if.end25

land.lhs.true22:                                  ; preds = %if.end18
  %10 = load i32, ptr %fs, align 4
  %cmp23 = icmp ne i32 %10, 16
  br i1 %cmp23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %land.lhs.true22
  %11 = load i32, ptr %fs, align 4
  store i32 %11, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end25:                                         ; preds = %land.lhs.true22, %if.end18
  %12 = load i32, ptr %rounding_mode.addr, align 4
  %call26 = call noundef i32 @_ZN4llvh6detail9IEEEFloat8subtractERKS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %MagicConstant, i32 noundef %12)
  store i32 %call26, ptr %fs, align 4
  %13 = load i8, ptr %inputSign, align 1
  %tobool = trunc i8 %13 to i1
  %conv27 = zext i1 %tobool to i32
  %call28 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %conv29 = zext i1 %call28 to i32
  %cmp30 = icmp ne i32 %conv27, %conv29
  br i1 %cmp30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.end25
  call void @_ZN4llvh6detail9IEEEFloat10changeSignEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br label %if.end32

if.end32:                                         ; preds = %if.then31, %if.end25
  %14 = load i32, ptr %fs, align 4
  store i32 %14, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end32, %if.then24, %if.then17
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %MagicConstant) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %IntegerConstant) #10
  br label %return

return:                                           ; preds = %cleanup, %if.then
  %15 = load i32, ptr %retval, align 4
  ret i32 %15
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZNK4llvh6detail9IEEEFloat7compareERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %rhs) #1 align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  %result = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, 7
  %bf.cast = zext i8 %bf.clear to i32
  %mul = mul nsw i32 %bf.cast, 4
  %0 = load ptr, ptr %rhs.addr, align 8
  %category2 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %0, i32 0, i32 3
  %bf.load3 = load i8, ptr %category2, align 2
  %bf.clear4 = and i8 %bf.load3, 7
  %bf.cast5 = zext i8 %bf.clear4 to i32
  %add = add nsw i32 %mul, %bf.cast5
  switch i32 %add, label %sw.default [
    i32 7, label %sw.bb
    i32 6, label %sw.bb
    i32 4, label %sw.bb
    i32 5, label %sw.bb
    i32 13, label %sw.bb
    i32 9, label %sw.bb
    i32 1, label %sw.bb
    i32 2, label %sw.bb6
    i32 3, label %sw.bb6
    i32 11, label %sw.bb6
    i32 8, label %sw.bb10
    i32 12, label %sw.bb10
    i32 14, label %sw.bb10
    i32 0, label %sw.bb19
    i32 15, label %sw.bb40
    i32 10, label %sw.bb41
  ]

sw.default:                                       ; preds = %entry
  unreachable

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry
  store i32 3, ptr %retval, align 4
  br label %return

sw.bb6:                                           ; preds = %entry, %entry, %entry
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load7 = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load7, 3
  %bf.clear8 = and i8 %bf.lshr, 1
  %bf.cast9 = zext i8 %bf.clear8 to i32
  %tobool = icmp ne i32 %bf.cast9, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb6
  store i32 0, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %sw.bb6
  store i32 2, ptr %retval, align 4
  br label %return

sw.bb10:                                          ; preds = %entry, %entry, %entry
  %1 = load ptr, ptr %rhs.addr, align 8
  %sign11 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %1, i32 0, i32 3
  %bf.load12 = load i8, ptr %sign11, align 2
  %bf.lshr13 = lshr i8 %bf.load12, 3
  %bf.clear14 = and i8 %bf.lshr13, 1
  %bf.cast15 = zext i8 %bf.clear14 to i32
  %tobool16 = icmp ne i32 %bf.cast15, 0
  br i1 %tobool16, label %if.then17, label %if.else18

if.then17:                                        ; preds = %sw.bb10
  store i32 2, ptr %retval, align 4
  br label %return

if.else18:                                        ; preds = %sw.bb10
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb19:                                          ; preds = %entry
  %sign20 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load21 = load i8, ptr %sign20, align 2
  %bf.lshr22 = lshr i8 %bf.load21, 3
  %bf.clear23 = and i8 %bf.lshr22, 1
  %bf.cast24 = zext i8 %bf.clear23 to i32
  %2 = load ptr, ptr %rhs.addr, align 8
  %sign25 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %2, i32 0, i32 3
  %bf.load26 = load i8, ptr %sign25, align 2
  %bf.lshr27 = lshr i8 %bf.load26, 3
  %bf.clear28 = and i8 %bf.lshr27, 1
  %bf.cast29 = zext i8 %bf.clear28 to i32
  %cmp = icmp eq i32 %bf.cast24, %bf.cast29
  br i1 %cmp, label %if.then30, label %if.else31

if.then30:                                        ; preds = %sw.bb19
  store i32 1, ptr %retval, align 4
  br label %return

if.else31:                                        ; preds = %sw.bb19
  %sign32 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load33 = load i8, ptr %sign32, align 2
  %bf.lshr34 = lshr i8 %bf.load33, 3
  %bf.clear35 = and i8 %bf.lshr34, 1
  %bf.cast36 = zext i8 %bf.clear35 to i32
  %tobool37 = icmp ne i32 %bf.cast36, 0
  br i1 %tobool37, label %if.then38, label %if.else39

if.then38:                                        ; preds = %if.else31
  store i32 0, ptr %retval, align 4
  br label %return

if.else39:                                        ; preds = %if.else31
  store i32 2, ptr %retval, align 4
  br label %return

sw.bb40:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

sw.bb41:                                          ; preds = %entry
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb41
  %sign42 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load43 = load i8, ptr %sign42, align 2
  %bf.lshr44 = lshr i8 %bf.load43, 3
  %bf.clear45 = and i8 %bf.lshr44, 1
  %bf.cast46 = zext i8 %bf.clear45 to i32
  %3 = load ptr, ptr %rhs.addr, align 8
  %sign47 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %3, i32 0, i32 3
  %bf.load48 = load i8, ptr %sign47, align 2
  %bf.lshr49 = lshr i8 %bf.load48, 3
  %bf.clear50 = and i8 %bf.lshr49, 1
  %bf.cast51 = zext i8 %bf.clear50 to i32
  %cmp52 = icmp ne i32 %bf.cast46, %bf.cast51
  br i1 %cmp52, label %if.then53, label %if.else62

if.then53:                                        ; preds = %sw.epilog
  %sign54 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load55 = load i8, ptr %sign54, align 2
  %bf.lshr56 = lshr i8 %bf.load55, 3
  %bf.clear57 = and i8 %bf.lshr56, 1
  %bf.cast58 = zext i8 %bf.clear57 to i32
  %tobool59 = icmp ne i32 %bf.cast58, 0
  br i1 %tobool59, label %if.then60, label %if.else61

if.then60:                                        ; preds = %if.then53
  store i32 0, ptr %result, align 4
  br label %if.end

if.else61:                                        ; preds = %if.then53
  store i32 2, ptr %result, align 4
  br label %if.end

if.end:                                           ; preds = %if.else61, %if.then60
  br label %if.end78

if.else62:                                        ; preds = %sw.epilog
  %4 = load ptr, ptr %rhs.addr, align 8
  %call = call noundef i32 @_ZNK4llvh6detail9IEEEFloat20compareAbsoluteValueERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %4)
  store i32 %call, ptr %result, align 4
  %sign63 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load64 = load i8, ptr %sign63, align 2
  %bf.lshr65 = lshr i8 %bf.load64, 3
  %bf.clear66 = and i8 %bf.lshr65, 1
  %bf.cast67 = zext i8 %bf.clear66 to i32
  %tobool68 = icmp ne i32 %bf.cast67, 0
  br i1 %tobool68, label %if.then69, label %if.end77

if.then69:                                        ; preds = %if.else62
  %5 = load i32, ptr %result, align 4
  %cmp70 = icmp eq i32 %5, 0
  br i1 %cmp70, label %if.then71, label %if.else72

if.then71:                                        ; preds = %if.then69
  store i32 2, ptr %result, align 4
  br label %if.end76

if.else72:                                        ; preds = %if.then69
  %6 = load i32, ptr %result, align 4
  %cmp73 = icmp eq i32 %6, 2
  br i1 %cmp73, label %if.then74, label %if.end75

if.then74:                                        ; preds = %if.else72
  store i32 0, ptr %result, align 4
  br label %if.end75

if.end75:                                         ; preds = %if.then74, %if.else72
  br label %if.end76

if.end76:                                         ; preds = %if.end75, %if.then71
  br label %if.end77

if.end77:                                         ; preds = %if.end76, %if.else62
  br label %if.end78

if.end78:                                         ; preds = %if.end77, %if.end
  %7 = load i32, ptr %result, align 4
  store i32 %7, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end78, %sw.bb40, %if.else39, %if.then38, %if.then30, %if.else18, %if.then17, %if.else, %if.then, %sw.bb
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat14bitwiseIsEqualERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %rhs) #1 align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %cmp = icmp eq ptr %this1, %0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %semantics, align 8
  %2 = load ptr, ptr %rhs.addr, align 8
  %semantics2 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %semantics2, align 8
  %cmp3 = icmp ne ptr %1, %3
  br i1 %cmp3, label %if.then19, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, 7
  %bf.cast = zext i8 %bf.clear to i32
  %4 = load ptr, ptr %rhs.addr, align 8
  %category4 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %4, i32 0, i32 3
  %bf.load5 = load i8, ptr %category4, align 2
  %bf.clear6 = and i8 %bf.load5, 7
  %bf.cast7 = zext i8 %bf.clear6 to i32
  %cmp8 = icmp ne i32 %bf.cast, %bf.cast7
  br i1 %cmp8, label %if.then19, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %lor.lhs.false
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load10 = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load10, 3
  %bf.clear11 = and i8 %bf.lshr, 1
  %bf.cast12 = zext i8 %bf.clear11 to i32
  %5 = load ptr, ptr %rhs.addr, align 8
  %sign13 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %5, i32 0, i32 3
  %bf.load14 = load i8, ptr %sign13, align 2
  %bf.lshr15 = lshr i8 %bf.load14, 3
  %bf.clear16 = and i8 %bf.lshr15, 1
  %bf.cast17 = zext i8 %bf.clear16 to i32
  %cmp18 = icmp ne i32 %bf.cast12, %bf.cast17
  br i1 %cmp18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %lor.lhs.false9, %lor.lhs.false, %if.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end20:                                         ; preds = %lor.lhs.false9
  %category21 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load22 = load i8, ptr %category21, align 2
  %bf.clear23 = and i8 %bf.load22, 7
  %bf.cast24 = zext i8 %bf.clear23 to i32
  %cmp25 = icmp eq i32 %bf.cast24, 3
  br i1 %cmp25, label %if.then32, label %lor.lhs.false26

lor.lhs.false26:                                  ; preds = %if.end20
  %category27 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load28 = load i8, ptr %category27, align 2
  %bf.clear29 = and i8 %bf.load28, 7
  %bf.cast30 = zext i8 %bf.clear29 to i32
  %cmp31 = icmp eq i32 %bf.cast30, 0
  br i1 %cmp31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %lor.lhs.false26, %if.end20
  store i1 true, ptr %retval, align 1
  br label %return

if.end33:                                         ; preds = %lor.lhs.false26
  %call = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call, label %land.lhs.true, label %if.end38

land.lhs.true:                                    ; preds = %if.end33
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %6 = load i16, ptr %exponent, align 8
  %conv = sext i16 %6 to i32
  %7 = load ptr, ptr %rhs.addr, align 8
  %exponent34 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %7, i32 0, i32 2
  %8 = load i16, ptr %exponent34, align 8
  %conv35 = sext i16 %8 to i32
  %cmp36 = icmp ne i32 %conv, %conv35
  br i1 %cmp36, label %if.then37, label %if.end38

if.then37:                                        ; preds = %land.lhs.true
  store i1 false, ptr %retval, align 1
  br label %return

if.end38:                                         ; preds = %land.lhs.true, %if.end33
  %call39 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call40 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call41 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %idx.ext = zext i32 %call41 to i64
  %add.ptr = getelementptr inbounds i64, ptr %call40, i64 %idx.ext
  %9 = load ptr, ptr %rhs.addr, align 8
  %call42 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %9)
  %call43 = call noundef zeroext i1 @_ZSt5equalIPKmS1_EbT_S2_T0_(ptr noundef %call39, ptr noundef %add.ptr, ptr noundef %call42)
  store i1 %call43, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end38, %if.then37, %if.then32, %if.then19, %if.then
  %10 = load i1, ptr %retval, align 1
  ret i1 %10
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef zeroext i1 @_ZSt5equalIPKmS1_EbT_S2_T0_(ptr noundef %__first1, ptr noundef %__last1, ptr noundef %__first2) #1 comdat {
entry:
  %__first1.addr = alloca ptr, align 8
  %__last1.addr = alloca ptr, align 8
  %__first2.addr = alloca ptr, align 8
  store ptr %__first1, ptr %__first1.addr, align 8
  store ptr %__last1, ptr %__last1.addr, align 8
  store ptr %__first2, ptr %__first2.addr, align 8
  %0 = load ptr, ptr %__first1.addr, align 8
  %1 = load ptr, ptr %__last1.addr, align 8
  %2 = load ptr, ptr %__first2.addr, align 8
  %call = call noundef zeroext i1 @_ZSt11__equal_auxIPKmS1_EbT_S2_T0_(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret i1 %call
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloatC2ERKNS_12fltSemanticsEm(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 4 dereferenceable(12) %ourSemantics, i64 noundef %value) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ourSemantics.addr = alloca ptr, align 8
  %value.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %ourSemantics, ptr %ourSemantics.addr, align 8
  store i64 %value, ptr %value.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %ourSemantics.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloat10initializeEPKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %0)
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %sign, align 2
  %bf.clear = and i8 %bf.load, -9
  %bf.set = or i8 %bf.clear, 0
  store i8 %bf.set, ptr %sign, align 2
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load2 = load i8, ptr %category, align 2
  %bf.clear3 = and i8 %bf.load2, -8
  %bf.set4 = or i8 %bf.clear3, 2
  store i8 %bf.set4, ptr %category, align 2
  call void @_ZN4llvh6detail9IEEEFloat15zeroSignificandEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %1 = load ptr, ptr %ourSemantics.addr, align 8
  %precision = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %1, i32 0, i32 2
  %2 = load i32, ptr %precision, align 4
  %sub = sub i32 %2, 1
  %conv = trunc i32 %sub to i16
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 %conv, ptr %exponent, align 8
  %3 = load i64, ptr %value.addr, align 8
  %call = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %arrayidx = getelementptr inbounds i64, ptr %call, i64 0
  store i64 %3, ptr %arrayidx, align 8
  %call5 = call noundef i32 @_ZN4llvh6detail9IEEEFloat9normalizeENS_11APFloatBase12roundingModeENS_12lostFractionE(ptr noundef nonnull align 8 dereferenceable(24) %this1, i32 noundef 0, i32 noundef 0)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloat15zeroSignificandEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call2 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  call void @_ZN4llvh5APInt5tcSetEPmmj(ptr noundef %call, i64 noundef 0, i32 noundef %call2)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat9normalizeENS_11APFloatBase12roundingModeENS_12lostFractionE(ptr noundef nonnull align 8 dereferenceable(24) %this, i32 noundef %rounding_mode, i32 noundef %lost_fraction) #1 align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %rounding_mode.addr = alloca i32, align 4
  %lost_fraction.addr = alloca i32, align 4
  %omsb = alloca i32, align 4
  %exponentChange = alloca i32, align 4
  %lf = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %rounding_mode, ptr %rounding_mode.addr, align 4
  store i32 %lost_fraction, ptr %lost_fraction.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %call2 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat14significandMSBEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %add = add i32 %call2, 1
  store i32 %add, ptr %omsb, align 4
  %0 = load i32, ptr %omsb, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then3, label %if.end37

if.then3:                                         ; preds = %if.end
  %1 = load i32, ptr %omsb, align 4
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %semantics, align 8
  %precision = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %2, i32 0, i32 2
  %3 = load i32, ptr %precision, align 4
  %sub = sub i32 %1, %3
  store i32 %sub, ptr %exponentChange, align 4
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %4 = load i16, ptr %exponent, align 8
  %conv = sext i16 %4 to i32
  %5 = load i32, ptr %exponentChange, align 4
  %add4 = add nsw i32 %conv, %5
  %semantics5 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %6 = load ptr, ptr %semantics5, align 8
  %maxExponent = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %6, i32 0, i32 0
  %7 = load i16, ptr %maxExponent, align 4
  %conv6 = sext i16 %7 to i32
  %cmp = icmp sgt i32 %add4, %conv6
  br i1 %cmp, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.then3
  %8 = load i32, ptr %rounding_mode.addr, align 4
  %call8 = call noundef i32 @_ZN4llvh6detail9IEEEFloat14handleOverflowENS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this1, i32 noundef %8)
  store i32 %call8, ptr %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.then3
  %exponent10 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %9 = load i16, ptr %exponent10, align 8
  %conv11 = sext i16 %9 to i32
  %10 = load i32, ptr %exponentChange, align 4
  %add12 = add nsw i32 %conv11, %10
  %semantics13 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %11 = load ptr, ptr %semantics13, align 8
  %minExponent = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %11, i32 0, i32 1
  %12 = load i16, ptr %minExponent, align 2
  %conv14 = sext i16 %12 to i32
  %cmp15 = icmp slt i32 %add12, %conv14
  br i1 %cmp15, label %if.then16, label %if.end23

if.then16:                                        ; preds = %if.end9
  %semantics17 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %13 = load ptr, ptr %semantics17, align 8
  %minExponent18 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %13, i32 0, i32 1
  %14 = load i16, ptr %minExponent18, align 2
  %conv19 = sext i16 %14 to i32
  %exponent20 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %15 = load i16, ptr %exponent20, align 8
  %conv21 = sext i16 %15 to i32
  %sub22 = sub nsw i32 %conv19, %conv21
  store i32 %sub22, ptr %exponentChange, align 4
  br label %if.end23

if.end23:                                         ; preds = %if.then16, %if.end9
  %16 = load i32, ptr %exponentChange, align 4
  %cmp24 = icmp slt i32 %16, 0
  br i1 %cmp24, label %if.then25, label %if.end27

if.then25:                                        ; preds = %if.end23
  %17 = load i32, ptr %exponentChange, align 4
  %sub26 = sub nsw i32 0, %17
  call void @_ZN4llvh6detail9IEEEFloat20shiftSignificandLeftEj(ptr noundef nonnull align 8 dereferenceable(24) %this1, i32 noundef %sub26)
  store i32 0, ptr %retval, align 4
  br label %return

if.end27:                                         ; preds = %if.end23
  %18 = load i32, ptr %exponentChange, align 4
  %cmp28 = icmp sgt i32 %18, 0
  br i1 %cmp28, label %if.then29, label %if.end36

if.then29:                                        ; preds = %if.end27
  %19 = load i32, ptr %exponentChange, align 4
  %call30 = call noundef i32 @_ZN4llvh6detail9IEEEFloat21shiftSignificandRightEj(ptr noundef nonnull align 8 dereferenceable(24) %this1, i32 noundef %19)
  store i32 %call30, ptr %lf, align 4
  %20 = load i32, ptr %lf, align 4
  %21 = load i32, ptr %lost_fraction.addr, align 4
  %call31 = call noundef i32 @_ZN4llvhL20combineLostFractionsENS_12lostFractionES0_(i32 noundef %20, i32 noundef %21)
  store i32 %call31, ptr %lost_fraction.addr, align 4
  %22 = load i32, ptr %omsb, align 4
  %23 = load i32, ptr %exponentChange, align 4
  %cmp32 = icmp ugt i32 %22, %23
  br i1 %cmp32, label %if.then33, label %if.else

if.then33:                                        ; preds = %if.then29
  %24 = load i32, ptr %exponentChange, align 4
  %25 = load i32, ptr %omsb, align 4
  %sub34 = sub i32 %25, %24
  store i32 %sub34, ptr %omsb, align 4
  br label %if.end35

if.else:                                          ; preds = %if.then29
  store i32 0, ptr %omsb, align 4
  br label %if.end35

if.end35:                                         ; preds = %if.else, %if.then33
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.end27
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.end
  %26 = load i32, ptr %lost_fraction.addr, align 4
  %cmp38 = icmp eq i32 %26, 0
  br i1 %cmp38, label %if.then39, label %if.end43

if.then39:                                        ; preds = %if.end37
  %27 = load i32, ptr %omsb, align 4
  %cmp40 = icmp eq i32 %27, 0
  br i1 %cmp40, label %if.then41, label %if.end42

if.then41:                                        ; preds = %if.then39
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, -8
  %bf.set = or i8 %bf.clear, 3
  store i8 %bf.set, ptr %category, align 2
  br label %if.end42

if.end42:                                         ; preds = %if.then41, %if.then39
  store i32 0, ptr %retval, align 4
  br label %return

if.end43:                                         ; preds = %if.end37
  %28 = load i32, ptr %rounding_mode.addr, align 4
  %29 = load i32, ptr %lost_fraction.addr, align 4
  %call44 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat17roundAwayFromZeroENS_11APFloatBase12roundingModeENS_12lostFractionEj(ptr noundef nonnull align 8 dereferenceable(24) %this1, i32 noundef %28, i32 noundef %29, i32 noundef 0)
  br i1 %call44, label %if.then45, label %if.end73

if.then45:                                        ; preds = %if.end43
  %30 = load i32, ptr %omsb, align 4
  %cmp46 = icmp eq i32 %30, 0
  br i1 %cmp46, label %if.then47, label %if.end51

if.then47:                                        ; preds = %if.then45
  %semantics48 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %31 = load ptr, ptr %semantics48, align 8
  %minExponent49 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %31, i32 0, i32 1
  %32 = load i16, ptr %minExponent49, align 2
  %exponent50 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 %32, ptr %exponent50, align 8
  br label %if.end51

if.end51:                                         ; preds = %if.then47, %if.then45
  call void @_ZN4llvh6detail9IEEEFloat20incrementSignificandEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call52 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat14significandMSBEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %add53 = add i32 %call52, 1
  store i32 %add53, ptr %omsb, align 4
  %33 = load i32, ptr %omsb, align 4
  %semantics54 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %34 = load ptr, ptr %semantics54, align 8
  %precision55 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %34, i32 0, i32 2
  %35 = load i32, ptr %precision55, align 4
  %add56 = add i32 %35, 1
  %cmp57 = icmp eq i32 %33, %add56
  br i1 %cmp57, label %if.then58, label %if.end72

if.then58:                                        ; preds = %if.end51
  %exponent59 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %36 = load i16, ptr %exponent59, align 8
  %conv60 = sext i16 %36 to i32
  %semantics61 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %37 = load ptr, ptr %semantics61, align 8
  %maxExponent62 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %37, i32 0, i32 0
  %38 = load i16, ptr %maxExponent62, align 4
  %conv63 = sext i16 %38 to i32
  %cmp64 = icmp eq i32 %conv60, %conv63
  br i1 %cmp64, label %if.then65, label %if.end70

if.then65:                                        ; preds = %if.then58
  %category66 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load67 = load i8, ptr %category66, align 2
  %bf.clear68 = and i8 %bf.load67, -8
  %bf.set69 = or i8 %bf.clear68, 0
  store i8 %bf.set69, ptr %category66, align 2
  store i32 20, ptr %retval, align 4
  br label %return

if.end70:                                         ; preds = %if.then58
  %call71 = call noundef i32 @_ZN4llvh6detail9IEEEFloat21shiftSignificandRightEj(ptr noundef nonnull align 8 dereferenceable(24) %this1, i32 noundef 1)
  store i32 16, ptr %retval, align 4
  br label %return

if.end72:                                         ; preds = %if.end51
  br label %if.end73

if.end73:                                         ; preds = %if.end72, %if.end43
  %39 = load i32, ptr %omsb, align 4
  %semantics74 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %40 = load ptr, ptr %semantics74, align 8
  %precision75 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %40, i32 0, i32 2
  %41 = load i32, ptr %precision75, align 4
  %cmp76 = icmp eq i32 %39, %41
  br i1 %cmp76, label %if.then77, label %if.end78

if.then77:                                        ; preds = %if.end73
  store i32 16, ptr %retval, align 4
  br label %return

if.end78:                                         ; preds = %if.end73
  %42 = load i32, ptr %omsb, align 4
  %cmp79 = icmp eq i32 %42, 0
  br i1 %cmp79, label %if.then80, label %if.end85

if.then80:                                        ; preds = %if.end78
  %category81 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load82 = load i8, ptr %category81, align 2
  %bf.clear83 = and i8 %bf.load82, -8
  %bf.set84 = or i8 %bf.clear83, 3
  store i8 %bf.set84, ptr %category81, align 2
  br label %if.end85

if.end85:                                         ; preds = %if.then80, %if.end78
  store i32 24, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end85, %if.then77, %if.end70, %if.then65, %if.end42, %if.then25, %if.then7, %if.then
  %43 = load i32, ptr %retval, align 4
  ret i32 %43
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloatC2ERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 4 dereferenceable(12) %ourSemantics) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ourSemantics.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %ourSemantics, ptr %ourSemantics.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %ourSemantics.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloat10initializeEPKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %0)
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, -8
  %bf.set = or i8 %bf.clear, 3
  store i8 %bf.set, ptr %category, align 2
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load2 = load i8, ptr %sign, align 2
  %bf.clear3 = and i8 %bf.load2, -9
  %bf.set4 = or i8 %bf.clear3, 0
  store i8 %bf.set4, ptr %sign, align 2
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloatC2ERKNS_12fltSemanticsENS_11APFloatBase16uninitializedTagE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 4 dereferenceable(12) %ourSemantics, i32 noundef %tag) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ourSemantics.addr = alloca ptr, align 8
  %tag.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %ourSemantics, ptr %ourSemantics.addr, align 8
  store i32 %tag, ptr %tag.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %ourSemantics.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloatC2ERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 4 dereferenceable(12) %0)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloatC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %rhs) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %semantics, align 8
  call void @_ZN4llvh6detail9IEEEFloat10initializeEPKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %1)
  %2 = load ptr, ptr %rhs.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloat6assignERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %2)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloatC2EOS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %rhs) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  store ptr @_ZN4llvhL8semBogusE, ptr %semantics, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN4llvh6detail9IEEEFloataSEOS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %0)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloat15freeSignificandEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZN4llvhL16partCountForBitsEj(i32 noundef %bits) #1 {
entry:
  %bits.addr = alloca i32, align 4
  store i32 %bits, ptr %bits.addr, align 4
  %0 = load i32, ptr %bits.addr, align 4
  %add = add i32 %0, 64
  %sub = sub i32 %add, 1
  %div = udiv i32 %sub, 64
  ret i32 %div
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloat20incrementSignificandEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %carry = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call2 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call3 = call noundef i64 @_ZN4llvh5APInt11tcIncrementEPmj(ptr noundef %call, i32 noundef %call2)
  store i64 %call3, ptr %carry, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZN4llvh5APInt11tcIncrementEPmj(ptr noundef %dst, i32 noundef %parts) #1 comdat align 2 {
entry:
  %dst.addr = alloca ptr, align 8
  %parts.addr = alloca i32, align 4
  store ptr %dst, ptr %dst.addr, align 8
  store i32 %parts, ptr %parts.addr, align 4
  %0 = load ptr, ptr %dst.addr, align 8
  %1 = load i32, ptr %parts.addr, align 4
  %call = call noundef i64 @_ZN4llvh5APInt9tcAddPartEPmmj(ptr noundef %0, i64 noundef 1, i32 noundef %1)
  ret i64 %call
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i64 @_ZN4llvh6detail9IEEEFloat14addSignificandERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %rhs) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  %parts = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store ptr %call, ptr %parts, align 8
  %0 = load ptr, ptr %parts, align 8
  %1 = load ptr, ptr %rhs.addr, align 8
  %call2 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %1)
  %call3 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call4 = call noundef i64 @_ZN4llvh5APInt5tcAddEPmPKmmj(ptr noundef %0, ptr noundef %call2, i64 noundef 0, i32 noundef %call3)
  ret i64 %call4
}

declare noundef i64 @_ZN4llvh5APInt5tcAddEPmPKmmj(ptr noundef, ptr noundef, i64 noundef, i32 noundef) #5

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i64 @_ZN4llvh6detail9IEEEFloat19subtractSignificandERKS1_m(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %rhs, i64 noundef %borrow) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  %borrow.addr = alloca i64, align 8
  %parts = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  store i64 %borrow, ptr %borrow.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store ptr %call, ptr %parts, align 8
  %0 = load ptr, ptr %parts, align 8
  %1 = load ptr, ptr %rhs.addr, align 8
  %call2 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %1)
  %2 = load i64, ptr %borrow.addr, align 8
  %call3 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call4 = call noundef i64 @_ZN4llvh5APInt10tcSubtractEPmPKmmj(ptr noundef %0, ptr noundef %call2, i64 noundef %2, i32 noundef %call3)
  ret i64 %call4
}

declare noundef i64 @_ZN4llvh5APInt10tcSubtractEPmPKmmj(ptr noundef, ptr noundef, i64 noundef, i32 noundef) #5

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat19multiplySignificandERKS1_PS2_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %rhs, ptr noundef %addend) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  %addend.addr = alloca ptr, align 8
  %omsb = alloca i32, align 4
  %partsCount = alloca i32, align 4
  %newPartsCount = alloca i32, align 4
  %precision = alloca i32, align 4
  %lhsSignificand = alloca ptr, align 8
  %scratch = alloca [4 x i64], align 16
  %fullSignificand = alloca ptr, align 8
  %lost_fraction = alloca i32, align 4
  %ignored = alloca i8, align 1
  %savedSignificand = alloca %"union.llvh::detail::IEEEFloat::Significand", align 8
  %savedSemantics = alloca ptr, align 8
  %extendedSemantics = alloca %"struct.llvh::fltSemantics", align 4
  %status = alloca i32, align 4
  %extendedPrecision = alloca i32, align 4
  %extendedAddend = alloca %"class.llvh::detail::IEEEFloat", align 8
  %bits = alloca i32, align 4
  %significantParts = alloca i32, align 4
  %lf = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  store ptr %addend, ptr %addend.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %semantics, align 8
  %precision2 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %0, i32 0, i32 2
  %1 = load i32, ptr %precision2, align 4
  store i32 %1, ptr %precision, align 4
  %2 = load i32, ptr %precision, align 4
  %mul = mul i32 %2, 2
  %add = add i32 %mul, 1
  %call = call noundef i32 @_ZN4llvhL16partCountForBitsEj(i32 noundef %add)
  store i32 %call, ptr %newPartsCount, align 4
  %3 = load i32, ptr %newPartsCount, align 4
  %cmp = icmp ugt i32 %3, 4
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load i32, ptr %newPartsCount, align 4
  %conv = zext i32 %4 to i64
  %5 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %conv, i64 8)
  %6 = extractvalue { i64, i1 } %5, 1
  %7 = extractvalue { i64, i1 } %5, 0
  %8 = select i1 %6, i64 -1, i64 %7
  %call3 = call noalias noundef nonnull ptr @_Znam(i64 noundef %8) #13
  store ptr %call3, ptr %fullSignificand, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %arraydecay = getelementptr inbounds [4 x i64], ptr %scratch, i64 0, i64 0
  store ptr %arraydecay, ptr %fullSignificand, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %call4 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store ptr %call4, ptr %lhsSignificand, align 8
  %call5 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store i32 %call5, ptr %partsCount, align 4
  %9 = load ptr, ptr %fullSignificand, align 8
  %10 = load ptr, ptr %lhsSignificand, align 8
  %11 = load ptr, ptr %rhs.addr, align 8
  %call6 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %11)
  %12 = load i32, ptr %partsCount, align 4
  %13 = load i32, ptr %partsCount, align 4
  call void @_ZN4llvh5APInt14tcFullMultiplyEPmPKmS3_jj(ptr noundef %9, ptr noundef %10, ptr noundef %call6, i32 noundef %12, i32 noundef %13)
  store i32 0, ptr %lost_fraction, align 4
  %14 = load ptr, ptr %fullSignificand, align 8
  %15 = load i32, ptr %newPartsCount, align 4
  %call7 = call noundef i32 @_ZN4llvh5APInt5tcMSBEPKmj(ptr noundef %14, i32 noundef %15)
  %add8 = add i32 %call7, 1
  store i32 %add8, ptr %omsb, align 4
  %16 = load ptr, ptr %rhs.addr, align 8
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %16, i32 0, i32 2
  %17 = load i16, ptr %exponent, align 8
  %conv9 = sext i16 %17 to i32
  %exponent10 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %18 = load i16, ptr %exponent10, align 8
  %conv11 = sext i16 %18 to i32
  %add12 = add nsw i32 %conv11, %conv9
  %conv13 = trunc i32 %add12 to i16
  store i16 %conv13, ptr %exponent10, align 8
  %exponent14 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %19 = load i16, ptr %exponent14, align 8
  %conv15 = sext i16 %19 to i32
  %add16 = add nsw i32 %conv15, 2
  %conv17 = trunc i32 %add16 to i16
  store i16 %conv17, ptr %exponent14, align 8
  %20 = load ptr, ptr %addend.addr, align 8
  %tobool = icmp ne ptr %20, null
  br i1 %tobool, label %land.lhs.true, label %if.end55

land.lhs.true:                                    ; preds = %if.end
  %21 = load ptr, ptr %addend.addr, align 8
  %call18 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat9isNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %21)
  br i1 %call18, label %if.then19, label %if.end55

if.then19:                                        ; preds = %land.lhs.true
  %significand = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %savedSignificand, ptr align 8 %significand, i64 8, i1 false)
  %semantics20 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %22 = load ptr, ptr %semantics20, align 8
  store ptr %22, ptr %savedSemantics, align 8
  %23 = load i32, ptr %precision, align 4
  %mul21 = mul i32 2, %23
  %add22 = add i32 %mul21, 1
  store i32 %add22, ptr %extendedPrecision, align 4
  %24 = load i32, ptr %omsb, align 4
  %25 = load i32, ptr %extendedPrecision, align 4
  %sub = sub i32 %25, 1
  %cmp23 = icmp ne i32 %24, %sub
  br i1 %cmp23, label %if.then24, label %if.end33

if.then24:                                        ; preds = %if.then19
  %26 = load ptr, ptr %fullSignificand, align 8
  %27 = load i32, ptr %newPartsCount, align 4
  %28 = load i32, ptr %extendedPrecision, align 4
  %sub25 = sub i32 %28, 1
  %29 = load i32, ptr %omsb, align 4
  %sub26 = sub i32 %sub25, %29
  call void @_ZN4llvh5APInt11tcShiftLeftEPmjj(ptr noundef %26, i32 noundef %27, i32 noundef %sub26)
  %30 = load i32, ptr %extendedPrecision, align 4
  %sub27 = sub i32 %30, 1
  %31 = load i32, ptr %omsb, align 4
  %sub28 = sub i32 %sub27, %31
  %exponent29 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %32 = load i16, ptr %exponent29, align 8
  %conv30 = sext i16 %32 to i32
  %sub31 = sub i32 %conv30, %sub28
  %conv32 = trunc i32 %sub31 to i16
  store i16 %conv32, ptr %exponent29, align 8
  br label %if.end33

if.end33:                                         ; preds = %if.then24, %if.then19
  %semantics34 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %33 = load ptr, ptr %semantics34, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %extendedSemantics, ptr align 4 %33, i64 12, i1 false)
  %34 = load i32, ptr %extendedPrecision, align 4
  %precision35 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %extendedSemantics, i32 0, i32 2
  store i32 %34, ptr %precision35, align 4
  %35 = load i32, ptr %newPartsCount, align 4
  %cmp36 = icmp eq i32 %35, 1
  br i1 %cmp36, label %if.then37, label %if.else39

if.then37:                                        ; preds = %if.end33
  %36 = load ptr, ptr %fullSignificand, align 8
  %arrayidx = getelementptr inbounds i64, ptr %36, i64 0
  %37 = load i64, ptr %arrayidx, align 8
  %significand38 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 1
  store i64 %37, ptr %significand38, align 8
  br label %if.end41

if.else39:                                        ; preds = %if.end33
  %38 = load ptr, ptr %fullSignificand, align 8
  %significand40 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 1
  store ptr %38, ptr %significand40, align 8
  br label %if.end41

if.end41:                                         ; preds = %if.else39, %if.then37
  %semantics42 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  store ptr %extendedSemantics, ptr %semantics42, align 8
  %39 = load ptr, ptr %addend.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloatC1ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %extendedAddend, ptr noundef nonnull align 8 dereferenceable(24) %39)
  %call43 = call noundef i32 @_ZN4llvh6detail9IEEEFloat7convertERKNS_12fltSemanticsENS_11APFloatBase12roundingModeEPb(ptr noundef nonnull align 8 dereferenceable(24) %extendedAddend, ptr noundef nonnull align 4 dereferenceable(12) %extendedSemantics, i32 noundef 3, ptr noundef %ignored)
  store i32 %call43, ptr %status, align 4
  %call44 = call noundef i32 @_ZN4llvh6detail9IEEEFloat21shiftSignificandRightEj(ptr noundef nonnull align 8 dereferenceable(24) %extendedAddend, i32 noundef 1)
  store i32 %call44, ptr %lost_fraction, align 4
  %call45 = call noundef i32 @_ZN4llvh6detail9IEEEFloat24addOrSubtractSignificandERKS1_b(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %extendedAddend, i1 noundef zeroext false)
  store i32 %call45, ptr %lost_fraction, align 4
  %40 = load i32, ptr %newPartsCount, align 4
  %cmp46 = icmp eq i32 %40, 1
  br i1 %cmp46, label %if.then47, label %if.end50

if.then47:                                        ; preds = %if.end41
  %significand48 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 1
  %41 = load i64, ptr %significand48, align 8
  %42 = load ptr, ptr %fullSignificand, align 8
  %arrayidx49 = getelementptr inbounds i64, ptr %42, i64 0
  store i64 %41, ptr %arrayidx49, align 8
  br label %if.end50

if.end50:                                         ; preds = %if.then47, %if.end41
  %significand51 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %significand51, ptr align 8 %savedSignificand, i64 8, i1 false)
  %43 = load ptr, ptr %savedSemantics, align 8
  %semantics52 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  store ptr %43, ptr %semantics52, align 8
  %44 = load ptr, ptr %fullSignificand, align 8
  %45 = load i32, ptr %newPartsCount, align 4
  %call53 = call noundef i32 @_ZN4llvh5APInt5tcMSBEPKmj(ptr noundef %44, i32 noundef %45)
  %add54 = add i32 %call53, 1
  store i32 %add54, ptr %omsb, align 4
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %extendedAddend) #10
  br label %if.end55

if.end55:                                         ; preds = %if.end50, %land.lhs.true, %if.end
  %46 = load i32, ptr %precision, align 4
  %add56 = add i32 %46, 1
  %exponent57 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %47 = load i16, ptr %exponent57, align 8
  %conv58 = sext i16 %47 to i32
  %sub59 = sub i32 %conv58, %add56
  %conv60 = trunc i32 %sub59 to i16
  store i16 %conv60, ptr %exponent57, align 8
  %48 = load i32, ptr %omsb, align 4
  %49 = load i32, ptr %precision, align 4
  %cmp61 = icmp ugt i32 %48, %49
  br i1 %cmp61, label %if.then62, label %if.end71

if.then62:                                        ; preds = %if.end55
  %50 = load i32, ptr %omsb, align 4
  %51 = load i32, ptr %precision, align 4
  %sub63 = sub i32 %50, %51
  store i32 %sub63, ptr %bits, align 4
  %52 = load i32, ptr %omsb, align 4
  %call64 = call noundef i32 @_ZN4llvhL16partCountForBitsEj(i32 noundef %52)
  store i32 %call64, ptr %significantParts, align 4
  %53 = load ptr, ptr %fullSignificand, align 8
  %54 = load i32, ptr %significantParts, align 4
  %55 = load i32, ptr %bits, align 4
  %call65 = call noundef i32 @_ZN4llvhL10shiftRightEPmjj(ptr noundef %53, i32 noundef %54, i32 noundef %55)
  store i32 %call65, ptr %lf, align 4
  %56 = load i32, ptr %lf, align 4
  %57 = load i32, ptr %lost_fraction, align 4
  %call66 = call noundef i32 @_ZN4llvhL20combineLostFractionsENS_12lostFractionES0_(i32 noundef %56, i32 noundef %57)
  store i32 %call66, ptr %lost_fraction, align 4
  %58 = load i32, ptr %bits, align 4
  %exponent67 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %59 = load i16, ptr %exponent67, align 8
  %conv68 = sext i16 %59 to i32
  %add69 = add i32 %conv68, %58
  %conv70 = trunc i32 %add69 to i16
  store i16 %conv70, ptr %exponent67, align 8
  br label %if.end71

if.end71:                                         ; preds = %if.then62, %if.end55
  %60 = load ptr, ptr %lhsSignificand, align 8
  %61 = load ptr, ptr %fullSignificand, align 8
  %62 = load i32, ptr %partsCount, align 4
  call void @_ZN4llvh5APInt8tcAssignEPmPKmj(ptr noundef %60, ptr noundef %61, i32 noundef %62)
  %63 = load i32, ptr %newPartsCount, align 4
  %cmp72 = icmp ugt i32 %63, 4
  br i1 %cmp72, label %if.then73, label %if.end74

if.then73:                                        ; preds = %if.end71
  %64 = load ptr, ptr %fullSignificand, align 8
  %isnull = icmp eq ptr %64, null
  br i1 %isnull, label %delete.end, label %delete.notnull

delete.notnull:                                   ; preds = %if.then73
  call void @_ZdaPv(ptr noundef %64) #14
  br label %delete.end

delete.end:                                       ; preds = %delete.notnull, %if.then73
  br label %if.end74

if.end74:                                         ; preds = %delete.end, %if.end71
  %65 = load i32, ptr %lost_fraction, align 4
  ret i32 %65
}

declare void @_ZN4llvh5APInt14tcFullMultiplyEPmPKmS3_jj(ptr noundef, ptr noundef, ptr noundef, i32 noundef, i32 noundef) #5

declare noundef i32 @_ZN4llvh5APInt5tcMSBEPKmj(ptr noundef, i32 noundef) #5

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat9isNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, 7
  %bf.cast = zext i8 %bf.clear to i32
  %cmp = icmp ne i32 %bf.cast, 3
  ret i1 %cmp
}

declare void @_ZN4llvh5APInt11tcShiftLeftEPmjj(ptr noundef, i32 noundef, i32 noundef) #5

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat7convertERKNS_12fltSemanticsENS_11APFloatBase12roundingModeEPb(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 4 dereferenceable(12) %toSemantics, i32 noundef %rounding_mode, ptr noundef %losesInfo) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %toSemantics.addr = alloca ptr, align 8
  %rounding_mode.addr = alloca i32, align 4
  %losesInfo.addr = alloca ptr, align 8
  %lostFraction = alloca i32, align 4
  %newPartCount = alloca i32, align 4
  %oldPartCount = alloca i32, align 4
  %fs = alloca i32, align 4
  %shift = alloca i32, align 4
  %fromSemantics = alloca ptr, align 8
  %X86SpecialNan = alloca i8, align 1
  %exponentChange = alloca i32, align 4
  %newParts = alloca ptr, align 8
  %newPart = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %toSemantics, ptr %toSemantics.addr, align 8
  store i32 %rounding_mode, ptr %rounding_mode.addr, align 4
  store ptr %losesInfo, ptr %losesInfo.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %semantics, align 8
  store ptr %0, ptr %fromSemantics, align 8
  store i32 0, ptr %lostFraction, align 4
  %1 = load ptr, ptr %toSemantics.addr, align 8
  %precision = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %1, i32 0, i32 2
  %2 = load i32, ptr %precision, align 4
  %add = add i32 %2, 1
  %call = call noundef i32 @_ZN4llvhL16partCountForBitsEj(i32 noundef %add)
  store i32 %call, ptr %newPartCount, align 4
  %call2 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store i32 %call2, ptr %oldPartCount, align 4
  %3 = load ptr, ptr %toSemantics.addr, align 8
  %precision3 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %3, i32 0, i32 2
  %4 = load i32, ptr %precision3, align 4
  %5 = load ptr, ptr %fromSemantics, align 8
  %precision4 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %5, i32 0, i32 2
  %6 = load i32, ptr %precision4, align 4
  %sub = sub i32 %4, %6
  store i32 %sub, ptr %shift, align 4
  store i8 0, ptr %X86SpecialNan, align 1
  %7 = load ptr, ptr %fromSemantics, align 8
  %cmp = icmp eq ptr %7, @_ZN4llvhL20semX87DoubleExtendedE
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %8 = load ptr, ptr %toSemantics.addr, align 8
  %cmp5 = icmp ne ptr %8, @_ZN4llvhL20semX87DoubleExtendedE
  br i1 %cmp5, label %land.lhs.true6, label %if.end

land.lhs.true6:                                   ; preds = %land.lhs.true
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, 7
  %bf.cast = zext i8 %bf.clear to i32
  %cmp7 = icmp eq i32 %bf.cast, 1
  br i1 %cmp7, label %land.lhs.true8, label %if.end

land.lhs.true8:                                   ; preds = %land.lhs.true6
  %call9 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %9 = load i64, ptr %call9, align 8
  %and = and i64 %9, -9223372036854775808
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %land.lhs.true8
  %call10 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %10 = load i64, ptr %call10, align 8
  %and11 = and i64 %10, 4611686018427387904
  %tobool12 = icmp ne i64 %and11, 0
  br i1 %tobool12, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true8
  store i8 1, ptr %X86SpecialNan, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false, %land.lhs.true6, %land.lhs.true, %entry
  %11 = load i32, ptr %shift, align 4
  %cmp13 = icmp slt i32 %11, 0
  br i1 %cmp13, label %land.lhs.true14, label %if.end42

land.lhs.true14:                                  ; preds = %if.end
  %call15 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call15, label %if.then16, label %if.end42

if.then16:                                        ; preds = %land.lhs.true14
  %call17 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat14significandMSBEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %add18 = add i32 %call17, 1
  %12 = load ptr, ptr %fromSemantics, align 8
  %precision19 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %12, i32 0, i32 2
  %13 = load i32, ptr %precision19, align 4
  %sub20 = sub i32 %add18, %13
  store i32 %sub20, ptr %exponentChange, align 4
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %14 = load i16, ptr %exponent, align 8
  %conv = sext i16 %14 to i32
  %15 = load i32, ptr %exponentChange, align 4
  %add21 = add nsw i32 %conv, %15
  %16 = load ptr, ptr %toSemantics.addr, align 8
  %minExponent = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %16, i32 0, i32 1
  %17 = load i16, ptr %minExponent, align 2
  %conv22 = sext i16 %17 to i32
  %cmp23 = icmp slt i32 %add21, %conv22
  br i1 %cmp23, label %if.then24, label %if.end30

if.then24:                                        ; preds = %if.then16
  %18 = load ptr, ptr %toSemantics.addr, align 8
  %minExponent25 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %18, i32 0, i32 1
  %19 = load i16, ptr %minExponent25, align 2
  %conv26 = sext i16 %19 to i32
  %exponent27 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %20 = load i16, ptr %exponent27, align 8
  %conv28 = sext i16 %20 to i32
  %sub29 = sub nsw i32 %conv26, %conv28
  store i32 %sub29, ptr %exponentChange, align 4
  br label %if.end30

if.end30:                                         ; preds = %if.then24, %if.then16
  %21 = load i32, ptr %exponentChange, align 4
  %22 = load i32, ptr %shift, align 4
  %cmp31 = icmp slt i32 %21, %22
  br i1 %cmp31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.end30
  %23 = load i32, ptr %shift, align 4
  store i32 %23, ptr %exponentChange, align 4
  br label %if.end33

if.end33:                                         ; preds = %if.then32, %if.end30
  %24 = load i32, ptr %exponentChange, align 4
  %cmp34 = icmp slt i32 %24, 0
  br i1 %cmp34, label %if.then35, label %if.end41

if.then35:                                        ; preds = %if.end33
  %25 = load i32, ptr %exponentChange, align 4
  %26 = load i32, ptr %shift, align 4
  %sub36 = sub nsw i32 %26, %25
  store i32 %sub36, ptr %shift, align 4
  %27 = load i32, ptr %exponentChange, align 4
  %exponent37 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %28 = load i16, ptr %exponent37, align 8
  %conv38 = sext i16 %28 to i32
  %add39 = add nsw i32 %conv38, %27
  %conv40 = trunc i32 %add39 to i16
  store i16 %conv40, ptr %exponent37, align 8
  br label %if.end41

if.end41:                                         ; preds = %if.then35, %if.end33
  br label %if.end42

if.end42:                                         ; preds = %if.end41, %land.lhs.true14, %if.end
  %29 = load i32, ptr %shift, align 4
  %cmp43 = icmp slt i32 %29, 0
  br i1 %cmp43, label %land.lhs.true44, label %if.end56

land.lhs.true44:                                  ; preds = %if.end42
  %call45 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call45, label %if.then52, label %lor.lhs.false46

lor.lhs.false46:                                  ; preds = %land.lhs.true44
  %category47 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load48 = load i8, ptr %category47, align 2
  %bf.clear49 = and i8 %bf.load48, 7
  %bf.cast50 = zext i8 %bf.clear49 to i32
  %cmp51 = icmp eq i32 %bf.cast50, 1
  br i1 %cmp51, label %if.then52, label %if.end56

if.then52:                                        ; preds = %lor.lhs.false46, %land.lhs.true44
  %call53 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %30 = load i32, ptr %oldPartCount, align 4
  %31 = load i32, ptr %shift, align 4
  %sub54 = sub nsw i32 0, %31
  %call55 = call noundef i32 @_ZN4llvhL10shiftRightEPmjj(ptr noundef %call53, i32 noundef %30, i32 noundef %sub54)
  store i32 %call55, ptr %lostFraction, align 4
  br label %if.end56

if.end56:                                         ; preds = %if.then52, %lor.lhs.false46, %if.end42
  %32 = load i32, ptr %newPartCount, align 4
  %33 = load i32, ptr %oldPartCount, align 4
  %cmp57 = icmp ugt i32 %32, %33
  br i1 %cmp57, label %if.then58, label %if.else

if.then58:                                        ; preds = %if.end56
  %34 = load i32, ptr %newPartCount, align 4
  %conv59 = zext i32 %34 to i64
  %35 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %conv59, i64 8)
  %36 = extractvalue { i64, i1 } %35, 1
  %37 = extractvalue { i64, i1 } %35, 0
  %38 = select i1 %36, i64 -1, i64 %37
  %call60 = call noalias noundef nonnull ptr @_Znam(i64 noundef %38) #13
  store ptr %call60, ptr %newParts, align 8
  %39 = load ptr, ptr %newParts, align 8
  %40 = load i32, ptr %newPartCount, align 4
  call void @_ZN4llvh5APInt5tcSetEPmmj(ptr noundef %39, i64 noundef 0, i32 noundef %40)
  %call61 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call61, label %if.then68, label %lor.lhs.false62

lor.lhs.false62:                                  ; preds = %if.then58
  %category63 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load64 = load i8, ptr %category63, align 2
  %bf.clear65 = and i8 %bf.load64, 7
  %bf.cast66 = zext i8 %bf.clear65 to i32
  %cmp67 = icmp eq i32 %bf.cast66, 1
  br i1 %cmp67, label %if.then68, label %if.end70

if.then68:                                        ; preds = %lor.lhs.false62, %if.then58
  %41 = load ptr, ptr %newParts, align 8
  %call69 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %42 = load i32, ptr %oldPartCount, align 4
  call void @_ZN4llvh5APInt8tcAssignEPmPKmj(ptr noundef %41, ptr noundef %call69, i32 noundef %42)
  br label %if.end70

if.end70:                                         ; preds = %if.then68, %lor.lhs.false62
  call void @_ZN4llvh6detail9IEEEFloat15freeSignificandEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %43 = load ptr, ptr %newParts, align 8
  %significand = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 1
  store ptr %43, ptr %significand, align 8
  br label %if.end87

if.else:                                          ; preds = %if.end56
  %44 = load i32, ptr %newPartCount, align 4
  %cmp71 = icmp eq i32 %44, 1
  br i1 %cmp71, label %land.lhs.true72, label %if.end86

land.lhs.true72:                                  ; preds = %if.else
  %45 = load i32, ptr %oldPartCount, align 4
  %cmp73 = icmp ne i32 %45, 1
  br i1 %cmp73, label %if.then74, label %if.end86

if.then74:                                        ; preds = %land.lhs.true72
  store i64 0, ptr %newPart, align 8
  %call75 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call75, label %if.then82, label %lor.lhs.false76

lor.lhs.false76:                                  ; preds = %if.then74
  %category77 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load78 = load i8, ptr %category77, align 2
  %bf.clear79 = and i8 %bf.load78, 7
  %bf.cast80 = zext i8 %bf.clear79 to i32
  %cmp81 = icmp eq i32 %bf.cast80, 1
  br i1 %cmp81, label %if.then82, label %if.end84

if.then82:                                        ; preds = %lor.lhs.false76, %if.then74
  %call83 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %arrayidx = getelementptr inbounds i64, ptr %call83, i64 0
  %46 = load i64, ptr %arrayidx, align 8
  store i64 %46, ptr %newPart, align 8
  br label %if.end84

if.end84:                                         ; preds = %if.then82, %lor.lhs.false76
  call void @_ZN4llvh6detail9IEEEFloat15freeSignificandEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %47 = load i64, ptr %newPart, align 8
  %significand85 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 1
  store i64 %47, ptr %significand85, align 8
  br label %if.end86

if.end86:                                         ; preds = %if.end84, %land.lhs.true72, %if.else
  br label %if.end87

if.end87:                                         ; preds = %if.end86, %if.end70
  %48 = load ptr, ptr %toSemantics.addr, align 8
  %semantics88 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  store ptr %48, ptr %semantics88, align 8
  %49 = load i32, ptr %shift, align 4
  %cmp89 = icmp sgt i32 %49, 0
  br i1 %cmp89, label %land.lhs.true90, label %if.end100

land.lhs.true90:                                  ; preds = %if.end87
  %call91 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call91, label %if.then98, label %lor.lhs.false92

lor.lhs.false92:                                  ; preds = %land.lhs.true90
  %category93 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load94 = load i8, ptr %category93, align 2
  %bf.clear95 = and i8 %bf.load94, 7
  %bf.cast96 = zext i8 %bf.clear95 to i32
  %cmp97 = icmp eq i32 %bf.cast96, 1
  br i1 %cmp97, label %if.then98, label %if.end100

if.then98:                                        ; preds = %lor.lhs.false92, %land.lhs.true90
  %call99 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %50 = load i32, ptr %newPartCount, align 4
  %51 = load i32, ptr %shift, align 4
  call void @_ZN4llvh5APInt11tcShiftLeftEPmjj(ptr noundef %call99, i32 noundef %50, i32 noundef %51)
  br label %if.end100

if.end100:                                        ; preds = %if.then98, %lor.lhs.false92, %if.end87
  %call101 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call101, label %if.then102, label %if.else105

if.then102:                                       ; preds = %if.end100
  %52 = load i32, ptr %rounding_mode.addr, align 4
  %53 = load i32, ptr %lostFraction, align 4
  %call103 = call noundef i32 @_ZN4llvh6detail9IEEEFloat9normalizeENS_11APFloatBase12roundingModeENS_12lostFractionE(ptr noundef nonnull align 8 dereferenceable(24) %this1, i32 noundef %52, i32 noundef %53)
  store i32 %call103, ptr %fs, align 4
  %54 = load i32, ptr %fs, align 4
  %cmp104 = icmp ne i32 %54, 0
  %55 = load ptr, ptr %losesInfo.addr, align 8
  %frombool = zext i1 %cmp104 to i8
  store i8 %frombool, ptr %55, align 1
  br label %if.end127

if.else105:                                       ; preds = %if.end100
  %category106 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load107 = load i8, ptr %category106, align 2
  %bf.clear108 = and i8 %bf.load107, 7
  %bf.cast109 = zext i8 %bf.clear108 to i32
  %cmp110 = icmp eq i32 %bf.cast109, 1
  br i1 %cmp110, label %if.then111, label %if.else125

if.then111:                                       ; preds = %if.else105
  %56 = load i32, ptr %lostFraction, align 4
  %cmp112 = icmp ne i32 %56, 0
  br i1 %cmp112, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.then111
  %57 = load i8, ptr %X86SpecialNan, align 1
  %tobool113 = trunc i8 %57 to i1
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.then111
  %58 = phi i1 [ true, %if.then111 ], [ %tobool113, %lor.rhs ]
  %59 = load ptr, ptr %losesInfo.addr, align 8
  %frombool114 = zext i1 %58 to i8
  store i8 %frombool114, ptr %59, align 1
  %60 = load i8, ptr %X86SpecialNan, align 1
  %tobool115 = trunc i8 %60 to i1
  br i1 %tobool115, label %if.end124, label %land.lhs.true116

land.lhs.true116:                                 ; preds = %lor.end
  %semantics117 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %61 = load ptr, ptr %semantics117, align 8
  %cmp118 = icmp eq ptr %61, @_ZN4llvhL20semX87DoubleExtendedE
  br i1 %cmp118, label %if.then119, label %if.end124

if.then119:                                       ; preds = %land.lhs.true116
  %call120 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %semantics121 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %62 = load ptr, ptr %semantics121, align 8
  %precision122 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %62, i32 0, i32 2
  %63 = load i32, ptr %precision122, align 4
  %sub123 = sub i32 %63, 1
  call void @_ZN4llvh5APInt8tcSetBitEPmj(ptr noundef %call120, i32 noundef %sub123)
  br label %if.end124

if.end124:                                        ; preds = %if.then119, %land.lhs.true116, %lor.end
  store i32 0, ptr %fs, align 4
  br label %if.end126

if.else125:                                       ; preds = %if.else105
  %64 = load ptr, ptr %losesInfo.addr, align 8
  store i8 0, ptr %64, align 1
  store i32 0, ptr %fs, align 4
  br label %if.end126

if.end126:                                        ; preds = %if.else125, %if.end124
  br label %if.end127

if.end127:                                        ; preds = %if.end126, %if.then102
  %65 = load i32, ptr %fs, align 4
  ret i32 %65
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat21shiftSignificandRightEj(ptr noundef nonnull align 8 dereferenceable(24) %this, i32 noundef %bits) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %bits.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %bits, ptr %bits.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %bits.addr, align 4
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %1 = load i16, ptr %exponent, align 8
  %conv = sext i16 %1 to i32
  %add = add i32 %conv, %0
  %conv2 = trunc i32 %add to i16
  store i16 %conv2, ptr %exponent, align 8
  %call = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call3 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %2 = load i32, ptr %bits.addr, align 4
  %call4 = call noundef i32 @_ZN4llvhL10shiftRightEPmjj(ptr noundef %call, i32 noundef %call3, i32 noundef %2)
  ret i32 %call4
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat24addOrSubtractSignificandERKS1_b(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %rhs, i1 noundef zeroext %subtract) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  %subtract.addr = alloca i8, align 1
  %carry = alloca i64, align 8
  %lost_fraction = alloca i32, align 4
  %bits = alloca i32, align 4
  %temp_rhs = alloca %"class.llvh::detail::IEEEFloat", align 8
  %reverse = alloca i8, align 1
  %temp_rhs58 = alloca %"class.llvh::detail::IEEEFloat", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %frombool = zext i1 %subtract to i8
  store i8 %frombool, ptr %subtract.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load, 3
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %0 = load ptr, ptr %rhs.addr, align 8
  %sign2 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %0, i32 0, i32 3
  %bf.load3 = load i8, ptr %sign2, align 2
  %bf.lshr4 = lshr i8 %bf.load3, 3
  %bf.clear5 = and i8 %bf.lshr4, 1
  %bf.cast6 = zext i8 %bf.clear5 to i32
  %xor = xor i32 %bf.cast, %bf.cast6
  %tobool = icmp ne i32 %xor, 0
  %conv = zext i1 %tobool to i32
  %1 = load i8, ptr %subtract.addr, align 1
  %tobool7 = trunc i8 %1 to i1
  %conv8 = zext i1 %tobool7 to i32
  %xor9 = xor i32 %conv8, %conv
  %tobool10 = icmp ne i32 %xor9, 0
  %frombool11 = zext i1 %tobool10 to i8
  store i8 %frombool11, ptr %subtract.addr, align 1
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %2 = load i16, ptr %exponent, align 8
  %conv12 = sext i16 %2 to i32
  %3 = load ptr, ptr %rhs.addr, align 8
  %exponent13 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %3, i32 0, i32 2
  %4 = load i16, ptr %exponent13, align 8
  %conv14 = sext i16 %4 to i32
  %sub = sub nsw i32 %conv12, %conv14
  store i32 %sub, ptr %bits, align 4
  %5 = load i8, ptr %subtract.addr, align 1
  %tobool15 = trunc i8 %5 to i1
  br i1 %tobool15, label %if.then, label %if.else55

if.then:                                          ; preds = %entry
  %6 = load ptr, ptr %rhs.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloatC1ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %temp_rhs, ptr noundef nonnull align 8 dereferenceable(24) %6)
  %7 = load i32, ptr %bits, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.then
  %call = call noundef i32 @_ZNK4llvh6detail9IEEEFloat20compareAbsoluteValueERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %temp_rhs)
  %cmp17 = icmp eq i32 %call, 0
  %frombool18 = zext i1 %cmp17 to i8
  store i8 %frombool18, ptr %reverse, align 1
  store i32 0, ptr %lost_fraction, align 4
  br label %if.end27

if.else:                                          ; preds = %if.then
  %8 = load i32, ptr %bits, align 4
  %cmp19 = icmp sgt i32 %8, 0
  br i1 %cmp19, label %if.then20, label %if.else23

if.then20:                                        ; preds = %if.else
  %9 = load i32, ptr %bits, align 4
  %sub21 = sub nsw i32 %9, 1
  %call22 = call noundef i32 @_ZN4llvh6detail9IEEEFloat21shiftSignificandRightEj(ptr noundef nonnull align 8 dereferenceable(24) %temp_rhs, i32 noundef %sub21)
  store i32 %call22, ptr %lost_fraction, align 4
  call void @_ZN4llvh6detail9IEEEFloat20shiftSignificandLeftEj(ptr noundef nonnull align 8 dereferenceable(24) %this1, i32 noundef 1)
  store i8 0, ptr %reverse, align 1
  br label %if.end

if.else23:                                        ; preds = %if.else
  %10 = load i32, ptr %bits, align 4
  %sub24 = sub nsw i32 0, %10
  %sub25 = sub nsw i32 %sub24, 1
  %call26 = call noundef i32 @_ZN4llvh6detail9IEEEFloat21shiftSignificandRightEj(ptr noundef nonnull align 8 dereferenceable(24) %this1, i32 noundef %sub25)
  store i32 %call26, ptr %lost_fraction, align 4
  call void @_ZN4llvh6detail9IEEEFloat20shiftSignificandLeftEj(ptr noundef nonnull align 8 dereferenceable(24) %temp_rhs, i32 noundef 1)
  store i8 1, ptr %reverse, align 1
  br label %if.end

if.end:                                           ; preds = %if.else23, %if.then20
  br label %if.end27

if.end27:                                         ; preds = %if.end, %if.then16
  %11 = load i8, ptr %reverse, align 1
  %tobool28 = trunc i8 %11 to i1
  br i1 %tobool28, label %if.then29, label %if.else43

if.then29:                                        ; preds = %if.end27
  %12 = load i32, ptr %lost_fraction, align 4
  %cmp30 = icmp ne i32 %12, 0
  %conv31 = zext i1 %cmp30 to i64
  %call32 = call noundef i64 @_ZN4llvh6detail9IEEEFloat19subtractSignificandERKS1_m(ptr noundef nonnull align 8 dereferenceable(24) %temp_rhs, ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %conv31)
  store i64 %call32, ptr %carry, align 8
  call void @_ZN4llvh6detail9IEEEFloat15copySignificandERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %temp_rhs)
  %sign33 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load34 = load i8, ptr %sign33, align 2
  %bf.lshr35 = lshr i8 %bf.load34, 3
  %bf.clear36 = and i8 %bf.lshr35, 1
  %bf.cast37 = zext i8 %bf.clear36 to i32
  %tobool38 = icmp ne i32 %bf.cast37, 0
  %lnot = xor i1 %tobool38, true
  %conv39 = zext i1 %lnot to i32
  %sign40 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %13 = trunc i32 %conv39 to i8
  %bf.load41 = load i8, ptr %sign40, align 2
  %bf.value = and i8 %13, 1
  %bf.shl = shl i8 %bf.value, 3
  %bf.clear42 = and i8 %bf.load41, -9
  %bf.set = or i8 %bf.clear42, %bf.shl
  store i8 %bf.set, ptr %sign40, align 2
  br label %if.end47

if.else43:                                        ; preds = %if.end27
  %14 = load i32, ptr %lost_fraction, align 4
  %cmp44 = icmp ne i32 %14, 0
  %conv45 = zext i1 %cmp44 to i64
  %call46 = call noundef i64 @_ZN4llvh6detail9IEEEFloat19subtractSignificandERKS1_m(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %temp_rhs, i64 noundef %conv45)
  store i64 %call46, ptr %carry, align 8
  br label %if.end47

if.end47:                                         ; preds = %if.else43, %if.then29
  %15 = load i32, ptr %lost_fraction, align 4
  %cmp48 = icmp eq i32 %15, 1
  br i1 %cmp48, label %if.then49, label %if.else50

if.then49:                                        ; preds = %if.end47
  store i32 3, ptr %lost_fraction, align 4
  br label %if.end54

if.else50:                                        ; preds = %if.end47
  %16 = load i32, ptr %lost_fraction, align 4
  %cmp51 = icmp eq i32 %16, 3
  br i1 %cmp51, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.else50
  store i32 1, ptr %lost_fraction, align 4
  br label %if.end53

if.end53:                                         ; preds = %if.then52, %if.else50
  br label %if.end54

if.end54:                                         ; preds = %if.end53, %if.then49
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %temp_rhs) #10
  br label %if.end66

if.else55:                                        ; preds = %entry
  %17 = load i32, ptr %bits, align 4
  %cmp56 = icmp sgt i32 %17, 0
  br i1 %cmp56, label %if.then57, label %if.else61

if.then57:                                        ; preds = %if.else55
  %18 = load ptr, ptr %rhs.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloatC1ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %temp_rhs58, ptr noundef nonnull align 8 dereferenceable(24) %18)
  %19 = load i32, ptr %bits, align 4
  %call59 = call noundef i32 @_ZN4llvh6detail9IEEEFloat21shiftSignificandRightEj(ptr noundef nonnull align 8 dereferenceable(24) %temp_rhs58, i32 noundef %19)
  store i32 %call59, ptr %lost_fraction, align 4
  %call60 = call noundef i64 @_ZN4llvh6detail9IEEEFloat14addSignificandERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %temp_rhs58)
  store i64 %call60, ptr %carry, align 8
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %temp_rhs58) #10
  br label %if.end65

if.else61:                                        ; preds = %if.else55
  %20 = load i32, ptr %bits, align 4
  %sub62 = sub nsw i32 0, %20
  %call63 = call noundef i32 @_ZN4llvh6detail9IEEEFloat21shiftSignificandRightEj(ptr noundef nonnull align 8 dereferenceable(24) %this1, i32 noundef %sub62)
  store i32 %call63, ptr %lost_fraction, align 4
  %21 = load ptr, ptr %rhs.addr, align 8
  %call64 = call noundef i64 @_ZN4llvh6detail9IEEEFloat14addSignificandERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %21)
  store i64 %call64, ptr %carry, align 8
  br label %if.end65

if.end65:                                         ; preds = %if.else61, %if.then57
  br label %if.end66

if.end66:                                         ; preds = %if.end65, %if.end54
  %22 = load i32, ptr %lost_fraction, align 4
  ret i32 %22
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZN4llvhL10shiftRightEPmjj(ptr noundef %dst, i32 noundef %parts, i32 noundef %bits) #1 {
entry:
  %dst.addr = alloca ptr, align 8
  %parts.addr = alloca i32, align 4
  %bits.addr = alloca i32, align 4
  %lost_fraction = alloca i32, align 4
  store ptr %dst, ptr %dst.addr, align 8
  store i32 %parts, ptr %parts.addr, align 4
  store i32 %bits, ptr %bits.addr, align 4
  %0 = load ptr, ptr %dst.addr, align 8
  %1 = load i32, ptr %parts.addr, align 4
  %2 = load i32, ptr %bits.addr, align 4
  %call = call noundef i32 @_ZN4llvhL29lostFractionThroughTruncationEPKmjj(ptr noundef %0, i32 noundef %1, i32 noundef %2)
  store i32 %call, ptr %lost_fraction, align 4
  %3 = load ptr, ptr %dst.addr, align 8
  %4 = load i32, ptr %parts.addr, align 4
  %5 = load i32, ptr %bits.addr, align 4
  call void @_ZN4llvh5APInt12tcShiftRightEPmjj(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  %6 = load i32, ptr %lost_fraction, align 4
  ret i32 %6
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZN4llvhL20combineLostFractionsENS_12lostFractionES0_(i32 noundef %moreSignificant, i32 noundef %lessSignificant) #1 {
entry:
  %moreSignificant.addr = alloca i32, align 4
  %lessSignificant.addr = alloca i32, align 4
  store i32 %moreSignificant, ptr %moreSignificant.addr, align 4
  store i32 %lessSignificant, ptr %lessSignificant.addr, align 4
  %0 = load i32, ptr %lessSignificant.addr, align 4
  %cmp = icmp ne i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %moreSignificant.addr, align 4
  %cmp1 = icmp eq i32 %1, 0
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  store i32 1, ptr %moreSignificant.addr, align 4
  br label %if.end5

if.else:                                          ; preds = %if.then
  %2 = load i32, ptr %moreSignificant.addr, align 4
  %cmp3 = icmp eq i32 %2, 2
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  store i32 3, ptr %moreSignificant.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.else
  br label %if.end5

if.end5:                                          ; preds = %if.end, %if.then2
  br label %if.end6

if.end6:                                          ; preds = %if.end5, %entry
  %3 = load i32, ptr %moreSignificant.addr, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat17divideSignificandERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %rhs) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  %bit = alloca i32, align 4
  %i = alloca i32, align 4
  %partsCount = alloca i32, align 4
  %rhsSignificand = alloca ptr, align 8
  %lhsSignificand = alloca ptr, align 8
  %dividend = alloca ptr, align 8
  %divisor = alloca ptr, align 8
  %scratch = alloca [4 x i64], align 16
  %lost_fraction = alloca i32, align 4
  %precision = alloca i32, align 4
  %cmp54 = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store ptr %call, ptr %lhsSignificand, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %call2 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %0)
  store ptr %call2, ptr %rhsSignificand, align 8
  %call3 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store i32 %call3, ptr %partsCount, align 4
  %1 = load i32, ptr %partsCount, align 4
  %cmp = icmp ugt i32 %1, 2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %partsCount, align 4
  %mul = mul i32 %2, 2
  %conv = zext i32 %mul to i64
  %3 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %conv, i64 8)
  %4 = extractvalue { i64, i1 } %3, 1
  %5 = extractvalue { i64, i1 } %3, 0
  %6 = select i1 %4, i64 -1, i64 %5
  %call4 = call noalias noundef nonnull ptr @_Znam(i64 noundef %6) #13
  store ptr %call4, ptr %dividend, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %arraydecay = getelementptr inbounds [4 x i64], ptr %scratch, i64 0, i64 0
  store ptr %arraydecay, ptr %dividend, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %7 = load ptr, ptr %dividend, align 8
  %8 = load i32, ptr %partsCount, align 4
  %idx.ext = zext i32 %8 to i64
  %add.ptr = getelementptr inbounds i64, ptr %7, i64 %idx.ext
  store ptr %add.ptr, ptr %divisor, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %partsCount, align 4
  %cmp5 = icmp ult i32 %9, %10
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %lhsSignificand, align 8
  %12 = load i32, ptr %i, align 4
  %idxprom = zext i32 %12 to i64
  %arrayidx = getelementptr inbounds i64, ptr %11, i64 %idxprom
  %13 = load i64, ptr %arrayidx, align 8
  %14 = load ptr, ptr %dividend, align 8
  %15 = load i32, ptr %i, align 4
  %idxprom6 = zext i32 %15 to i64
  %arrayidx7 = getelementptr inbounds i64, ptr %14, i64 %idxprom6
  store i64 %13, ptr %arrayidx7, align 8
  %16 = load ptr, ptr %rhsSignificand, align 8
  %17 = load i32, ptr %i, align 4
  %idxprom8 = zext i32 %17 to i64
  %arrayidx9 = getelementptr inbounds i64, ptr %16, i64 %idxprom8
  %18 = load i64, ptr %arrayidx9, align 8
  %19 = load ptr, ptr %divisor, align 8
  %20 = load i32, ptr %i, align 4
  %idxprom10 = zext i32 %20 to i64
  %arrayidx11 = getelementptr inbounds i64, ptr %19, i64 %idxprom10
  store i64 %18, ptr %arrayidx11, align 8
  %21 = load ptr, ptr %lhsSignificand, align 8
  %22 = load i32, ptr %i, align 4
  %idxprom12 = zext i32 %22 to i64
  %arrayidx13 = getelementptr inbounds i64, ptr %21, i64 %idxprom12
  store i64 0, ptr %arrayidx13, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %23 = load i32, ptr %i, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !8

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %rhs.addr, align 8
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %24, i32 0, i32 2
  %25 = load i16, ptr %exponent, align 8
  %conv14 = sext i16 %25 to i32
  %exponent15 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %26 = load i16, ptr %exponent15, align 8
  %conv16 = sext i16 %26 to i32
  %sub = sub nsw i32 %conv16, %conv14
  %conv17 = trunc i32 %sub to i16
  store i16 %conv17, ptr %exponent15, align 8
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %27 = load ptr, ptr %semantics, align 8
  %precision18 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %27, i32 0, i32 2
  %28 = load i32, ptr %precision18, align 4
  store i32 %28, ptr %precision, align 4
  %29 = load i32, ptr %precision, align 4
  %30 = load ptr, ptr %divisor, align 8
  %31 = load i32, ptr %partsCount, align 4
  %call19 = call noundef i32 @_ZN4llvh5APInt5tcMSBEPKmj(ptr noundef %30, i32 noundef %31)
  %sub20 = sub i32 %29, %call19
  %sub21 = sub i32 %sub20, 1
  store i32 %sub21, ptr %bit, align 4
  %32 = load i32, ptr %bit, align 4
  %tobool = icmp ne i32 %32, 0
  br i1 %tobool, label %if.then22, label %if.end26

if.then22:                                        ; preds = %for.end
  %33 = load i32, ptr %bit, align 4
  %exponent23 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %34 = load i16, ptr %exponent23, align 8
  %conv24 = sext i16 %34 to i32
  %add = add i32 %conv24, %33
  %conv25 = trunc i32 %add to i16
  store i16 %conv25, ptr %exponent23, align 8
  %35 = load ptr, ptr %divisor, align 8
  %36 = load i32, ptr %partsCount, align 4
  %37 = load i32, ptr %bit, align 4
  call void @_ZN4llvh5APInt11tcShiftLeftEPmjj(ptr noundef %35, i32 noundef %36, i32 noundef %37)
  br label %if.end26

if.end26:                                         ; preds = %if.then22, %for.end
  %38 = load i32, ptr %precision, align 4
  %39 = load ptr, ptr %dividend, align 8
  %40 = load i32, ptr %partsCount, align 4
  %call27 = call noundef i32 @_ZN4llvh5APInt5tcMSBEPKmj(ptr noundef %39, i32 noundef %40)
  %sub28 = sub i32 %38, %call27
  %sub29 = sub i32 %sub28, 1
  store i32 %sub29, ptr %bit, align 4
  %41 = load i32, ptr %bit, align 4
  %tobool30 = icmp ne i32 %41, 0
  br i1 %tobool30, label %if.then31, label %if.end36

if.then31:                                        ; preds = %if.end26
  %42 = load i32, ptr %bit, align 4
  %exponent32 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %43 = load i16, ptr %exponent32, align 8
  %conv33 = sext i16 %43 to i32
  %sub34 = sub i32 %conv33, %42
  %conv35 = trunc i32 %sub34 to i16
  store i16 %conv35, ptr %exponent32, align 8
  %44 = load ptr, ptr %dividend, align 8
  %45 = load i32, ptr %partsCount, align 4
  %46 = load i32, ptr %bit, align 4
  call void @_ZN4llvh5APInt11tcShiftLeftEPmjj(ptr noundef %44, i32 noundef %45, i32 noundef %46)
  br label %if.end36

if.end36:                                         ; preds = %if.then31, %if.end26
  %47 = load ptr, ptr %dividend, align 8
  %48 = load ptr, ptr %divisor, align 8
  %49 = load i32, ptr %partsCount, align 4
  %call37 = call noundef i32 @_ZN4llvh5APInt9tcCompareEPKmS2_j(ptr noundef %47, ptr noundef %48, i32 noundef %49)
  %cmp38 = icmp slt i32 %call37, 0
  br i1 %cmp38, label %if.then39, label %if.end41

if.then39:                                        ; preds = %if.end36
  %exponent40 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %50 = load i16, ptr %exponent40, align 8
  %dec = add i16 %50, -1
  store i16 %dec, ptr %exponent40, align 8
  %51 = load ptr, ptr %dividend, align 8
  %52 = load i32, ptr %partsCount, align 4
  call void @_ZN4llvh5APInt11tcShiftLeftEPmjj(ptr noundef %51, i32 noundef %52, i32 noundef 1)
  br label %if.end41

if.end41:                                         ; preds = %if.then39, %if.end36
  %53 = load i32, ptr %precision, align 4
  store i32 %53, ptr %bit, align 4
  br label %for.cond42

for.cond42:                                       ; preds = %for.inc51, %if.end41
  %54 = load i32, ptr %bit, align 4
  %tobool43 = icmp ne i32 %54, 0
  br i1 %tobool43, label %for.body44, label %for.end53

for.body44:                                       ; preds = %for.cond42
  %55 = load ptr, ptr %dividend, align 8
  %56 = load ptr, ptr %divisor, align 8
  %57 = load i32, ptr %partsCount, align 4
  %call45 = call noundef i32 @_ZN4llvh5APInt9tcCompareEPKmS2_j(ptr noundef %55, ptr noundef %56, i32 noundef %57)
  %cmp46 = icmp sge i32 %call45, 0
  br i1 %cmp46, label %if.then47, label %if.end50

if.then47:                                        ; preds = %for.body44
  %58 = load ptr, ptr %dividend, align 8
  %59 = load ptr, ptr %divisor, align 8
  %60 = load i32, ptr %partsCount, align 4
  %call48 = call noundef i64 @_ZN4llvh5APInt10tcSubtractEPmPKmmj(ptr noundef %58, ptr noundef %59, i64 noundef 0, i32 noundef %60)
  %61 = load ptr, ptr %lhsSignificand, align 8
  %62 = load i32, ptr %bit, align 4
  %sub49 = sub i32 %62, 1
  call void @_ZN4llvh5APInt8tcSetBitEPmj(ptr noundef %61, i32 noundef %sub49)
  br label %if.end50

if.end50:                                         ; preds = %if.then47, %for.body44
  %63 = load ptr, ptr %dividend, align 8
  %64 = load i32, ptr %partsCount, align 4
  call void @_ZN4llvh5APInt11tcShiftLeftEPmjj(ptr noundef %63, i32 noundef %64, i32 noundef 1)
  br label %for.inc51

for.inc51:                                        ; preds = %if.end50
  %65 = load i32, ptr %bit, align 4
  %sub52 = sub i32 %65, 1
  store i32 %sub52, ptr %bit, align 4
  br label %for.cond42, !llvm.loop !9

for.end53:                                        ; preds = %for.cond42
  %66 = load ptr, ptr %dividend, align 8
  %67 = load ptr, ptr %divisor, align 8
  %68 = load i32, ptr %partsCount, align 4
  %call55 = call noundef i32 @_ZN4llvh5APInt9tcCompareEPKmS2_j(ptr noundef %66, ptr noundef %67, i32 noundef %68)
  store i32 %call55, ptr %cmp54, align 4
  %69 = load i32, ptr %cmp54, align 4
  %cmp56 = icmp sgt i32 %69, 0
  br i1 %cmp56, label %if.then57, label %if.else58

if.then57:                                        ; preds = %for.end53
  store i32 3, ptr %lost_fraction, align 4
  br label %if.end67

if.else58:                                        ; preds = %for.end53
  %70 = load i32, ptr %cmp54, align 4
  %cmp59 = icmp eq i32 %70, 0
  br i1 %cmp59, label %if.then60, label %if.else61

if.then60:                                        ; preds = %if.else58
  store i32 2, ptr %lost_fraction, align 4
  br label %if.end66

if.else61:                                        ; preds = %if.else58
  %71 = load ptr, ptr %dividend, align 8
  %72 = load i32, ptr %partsCount, align 4
  %call62 = call noundef zeroext i1 @_ZN4llvh5APInt8tcIsZeroEPKmj(ptr noundef %71, i32 noundef %72)
  br i1 %call62, label %if.then63, label %if.else64

if.then63:                                        ; preds = %if.else61
  store i32 0, ptr %lost_fraction, align 4
  br label %if.end65

if.else64:                                        ; preds = %if.else61
  store i32 1, ptr %lost_fraction, align 4
  br label %if.end65

if.end65:                                         ; preds = %if.else64, %if.then63
  br label %if.end66

if.end66:                                         ; preds = %if.end65, %if.then60
  br label %if.end67

if.end67:                                         ; preds = %if.end66, %if.then57
  %73 = load i32, ptr %partsCount, align 4
  %cmp68 = icmp ugt i32 %73, 2
  br i1 %cmp68, label %if.then69, label %if.end70

if.then69:                                        ; preds = %if.end67
  %74 = load ptr, ptr %dividend, align 8
  %isnull = icmp eq ptr %74, null
  br i1 %isnull, label %delete.end, label %delete.notnull

delete.notnull:                                   ; preds = %if.then69
  call void @_ZdaPv(ptr noundef %74) #14
  br label %delete.end

delete.end:                                       ; preds = %delete.notnull, %if.then69
  br label %if.end70

if.end70:                                         ; preds = %delete.end, %if.end67
  %75 = load i32, ptr %lost_fraction, align 4
  ret i32 %75
}

declare noundef i32 @_ZN4llvh5APInt9tcCompareEPKmS2_j(ptr noundef, ptr noundef, i32 noundef) #5

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZNK4llvh6detail9IEEEFloat14significandLSBEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call2 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call3 = call noundef i32 @_ZN4llvh5APInt5tcLSBEPKmj(ptr noundef %call, i32 noundef %call2)
  ret i32 %call3
}

declare noundef i32 @_ZN4llvh5APInt5tcLSBEPKmj(ptr noundef, i32 noundef) #5

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloat20shiftSignificandLeftEj(ptr noundef nonnull align 8 dereferenceable(24) %this, i32 noundef %bits) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %bits.addr = alloca i32, align 4
  %partsCount = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %bits, ptr %bits.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %bits.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store i32 %call, ptr %partsCount, align 4
  %call2 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %1 = load i32, ptr %partsCount, align 4
  %2 = load i32, ptr %bits.addr, align 4
  call void @_ZN4llvh5APInt11tcShiftLeftEPmjj(ptr noundef %call2, i32 noundef %1, i32 noundef %2)
  %3 = load i32, ptr %bits.addr, align 4
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %4 = load i16, ptr %exponent, align 8
  %conv = sext i16 %4 to i32
  %sub = sub i32 %conv, %3
  %conv3 = trunc i32 %sub to i16
  store i16 %conv3, ptr %exponent, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZNK4llvh6detail9IEEEFloat20compareAbsoluteValueERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %rhs) #1 align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  %compare = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %0 = load i16, ptr %exponent, align 8
  %conv = sext i16 %0 to i32
  %1 = load ptr, ptr %rhs.addr, align 8
  %exponent2 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %1, i32 0, i32 2
  %2 = load i16, ptr %exponent2, align 8
  %conv3 = sext i16 %2 to i32
  %sub = sub nsw i32 %conv, %conv3
  store i32 %sub, ptr %compare, align 4
  %3 = load i32, ptr %compare, align 4
  %cmp = icmp eq i32 %3, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %4 = load ptr, ptr %rhs.addr, align 8
  %call4 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %4)
  %call5 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call6 = call noundef i32 @_ZN4llvh5APInt9tcCompareEPKmS2_j(ptr noundef %call, ptr noundef %call4, i32 noundef %call5)
  store i32 %call6, ptr %compare, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i32, ptr %compare, align 4
  %cmp7 = icmp sgt i32 %5, 0
  br i1 %cmp7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.end
  store i32 2, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %if.end
  %6 = load i32, ptr %compare, align 4
  %cmp9 = icmp slt i32 %6, 0
  br i1 %cmp9, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.else
  store i32 0, ptr %retval, align 4
  br label %return

if.else11:                                        ; preds = %if.else
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else11, %if.then10, %if.then8
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat14handleOverflowENS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this, i32 noundef %rounding_mode) #1 align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %rounding_mode.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %rounding_mode, ptr %rounding_mode.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %rounding_mode.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %rounding_mode.addr, align 4
  %cmp2 = icmp eq i32 %1, 4
  br i1 %cmp2, label %if.then, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %lor.lhs.false
  %2 = load i32, ptr %rounding_mode.addr, align 4
  %cmp4 = icmp eq i32 %2, 1
  br i1 %cmp4, label %land.lhs.true, label %lor.lhs.false5

land.lhs.true:                                    ; preds = %lor.lhs.false3
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load, 3
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %lor.lhs.false5, label %if.then

lor.lhs.false5:                                   ; preds = %land.lhs.true, %lor.lhs.false3
  %3 = load i32, ptr %rounding_mode.addr, align 4
  %cmp6 = icmp eq i32 %3, 2
  br i1 %cmp6, label %land.lhs.true7, label %if.end

land.lhs.true7:                                   ; preds = %lor.lhs.false5
  %sign8 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load9 = load i8, ptr %sign8, align 2
  %bf.lshr10 = lshr i8 %bf.load9, 3
  %bf.clear11 = and i8 %bf.lshr10, 1
  %bf.cast12 = zext i8 %bf.clear11 to i32
  %tobool13 = icmp ne i32 %bf.cast12, 0
  br i1 %tobool13, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true7, %land.lhs.true, %lor.lhs.false, %entry
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load14 = load i8, ptr %category, align 2
  %bf.clear15 = and i8 %bf.load14, -8
  %bf.set = or i8 %bf.clear15, 0
  store i8 %bf.set, ptr %category, align 2
  store i32 20, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true7, %lor.lhs.false5
  %category16 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load17 = load i8, ptr %category16, align 2
  %bf.clear18 = and i8 %bf.load17, -8
  %bf.set19 = or i8 %bf.clear18, 2
  store i8 %bf.set19, ptr %category16, align 2
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %semantics, align 8
  %maxExponent = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %4, i32 0, i32 0
  %5 = load i16, ptr %maxExponent, align 4
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 %5, ptr %exponent, align 8
  %call = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call20 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %semantics21 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %6 = load ptr, ptr %semantics21, align 8
  %precision = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %6, i32 0, i32 2
  %7 = load i32, ptr %precision, align 4
  call void @_ZN4llvh5APInt25tcSetLeastSignificantBitsEPmjj(ptr noundef %call, i32 noundef %call20, i32 noundef %7)
  store i32 16, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

declare void @_ZN4llvh5APInt25tcSetLeastSignificantBitsEPmjj(ptr noundef, i32 noundef, i32 noundef) #5

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat17roundAwayFromZeroENS_11APFloatBase12roundingModeENS_12lostFractionEj(ptr noundef nonnull align 8 dereferenceable(24) %this, i32 noundef %rounding_mode, i32 noundef %lost_fraction, i32 noundef %bit) #1 align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  %rounding_mode.addr = alloca i32, align 4
  %lost_fraction.addr = alloca i32, align 4
  %bit.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %rounding_mode, ptr %rounding_mode.addr, align 4
  store i32 %lost_fraction, ptr %lost_fraction.addr, align 4
  store i32 %bit, ptr %bit.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %rounding_mode.addr, align 4
  switch i32 %0, label %sw.epilog [
    i32 4, label %sw.bb
    i32 0, label %sw.bb3
    i32 3, label %sw.bb10
    i32 1, label %sw.bb11
    i32 2, label %sw.bb16
  ]

sw.bb:                                            ; preds = %entry
  %1 = load i32, ptr %lost_fraction.addr, align 4
  %cmp = icmp eq i32 %1, 2
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %sw.bb
  %2 = load i32, ptr %lost_fraction.addr, align 4
  %cmp2 = icmp eq i32 %2, 3
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %sw.bb
  %3 = phi i1 [ true, %sw.bb ], [ %cmp2, %lor.rhs ]
  store i1 %3, ptr %retval, align 1
  br label %return

sw.bb3:                                           ; preds = %entry
  %4 = load i32, ptr %lost_fraction.addr, align 4
  %cmp4 = icmp eq i32 %4, 3
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb3
  store i1 true, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %sw.bb3
  %5 = load i32, ptr %lost_fraction.addr, align 4
  %cmp5 = icmp eq i32 %5, 2
  br i1 %cmp5, label %land.lhs.true, label %if.end9

land.lhs.true:                                    ; preds = %if.end
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, 7
  %bf.cast = zext i8 %bf.clear to i32
  %cmp6 = icmp ne i32 %bf.cast, 3
  br i1 %cmp6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %land.lhs.true
  %call = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %6 = load i32, ptr %bit.addr, align 4
  %call8 = call noundef i32 @_ZN4llvh5APInt12tcExtractBitEPKmj(ptr noundef %call, i32 noundef %6)
  %tobool = icmp ne i32 %call8, 0
  store i1 %tobool, ptr %retval, align 1
  br label %return

if.end9:                                          ; preds = %land.lhs.true, %if.end
  store i1 false, ptr %retval, align 1
  br label %return

sw.bb10:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

sw.bb11:                                          ; preds = %entry
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load12 = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load12, 3
  %bf.clear13 = and i8 %bf.lshr, 1
  %bf.cast14 = zext i8 %bf.clear13 to i32
  %tobool15 = icmp ne i32 %bf.cast14, 0
  %lnot = xor i1 %tobool15, true
  store i1 %lnot, ptr %retval, align 1
  br label %return

sw.bb16:                                          ; preds = %entry
  %sign17 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load18 = load i8, ptr %sign17, align 2
  %bf.lshr19 = lshr i8 %bf.load18, 3
  %bf.clear20 = and i8 %bf.lshr19, 1
  %bf.cast21 = zext i8 %bf.clear20 to i32
  %tobool22 = icmp ne i32 %bf.cast21, 0
  store i1 %tobool22, ptr %retval, align 1
  br label %return

sw.epilog:                                        ; preds = %entry
  unreachable

return:                                           ; preds = %sw.bb16, %sw.bb11, %sw.bb10, %if.end9, %if.then7, %if.then, %lor.end
  %7 = load i1, ptr %retval, align 1
  ret i1 %7
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat21addOrSubtractSpecialsERKS1_b(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %rhs, i1 noundef zeroext %subtract) #1 align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  %subtract.addr = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %frombool = zext i1 %subtract to i8
  store i8 %frombool, ptr %subtract.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, 7
  %bf.cast = zext i8 %bf.clear to i32
  %mul = mul nsw i32 %bf.cast, 4
  %0 = load ptr, ptr %rhs.addr, align 8
  %category2 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %0, i32 0, i32 3
  %bf.load3 = load i8, ptr %category2, align 2
  %bf.clear4 = and i8 %bf.load3, 7
  %bf.cast5 = zext i8 %bf.clear4 to i32
  %add = add nsw i32 %mul, %bf.cast5
  switch i32 %add, label %sw.default [
    i32 7, label %sw.bb
    i32 6, label %sw.bb
    i32 4, label %sw.bb
    i32 5, label %sw.bb
    i32 11, label %sw.bb
    i32 2, label %sw.bb
    i32 3, label %sw.bb
    i32 13, label %sw.bb6
    i32 9, label %sw.bb6
    i32 1, label %sw.bb6
    i32 8, label %sw.bb17
    i32 12, label %sw.bb17
    i32 14, label %sw.bb36
    i32 15, label %sw.bb51
    i32 0, label %sw.bb52
    i32 10, label %sw.bb68
  ]

sw.default:                                       ; preds = %entry
  unreachable

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb6:                                           ; preds = %entry, %entry, %entry
  %1 = load ptr, ptr %rhs.addr, align 8
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %1, i32 0, i32 3
  %bf.load7 = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load7, 3
  %bf.clear8 = and i8 %bf.lshr, 1
  %bf.cast9 = zext i8 %bf.clear8 to i32
  %2 = load i8, ptr %subtract.addr, align 1
  %tobool = trunc i8 %2 to i1
  %conv = zext i1 %tobool to i32
  %xor = xor i32 %bf.cast9, %conv
  %sign10 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %3 = trunc i32 %xor to i8
  %bf.load11 = load i8, ptr %sign10, align 2
  %bf.value = and i8 %3, 1
  %bf.shl = shl i8 %bf.value, 3
  %bf.clear12 = and i8 %bf.load11, -9
  %bf.set = or i8 %bf.clear12, %bf.shl
  store i8 %bf.set, ptr %sign10, align 2
  %category13 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load14 = load i8, ptr %category13, align 2
  %bf.clear15 = and i8 %bf.load14, -8
  %bf.set16 = or i8 %bf.clear15, 1
  store i8 %bf.set16, ptr %category13, align 2
  %4 = load ptr, ptr %rhs.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloat15copySignificandERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %4)
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb17:                                          ; preds = %entry, %entry
  %category18 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load19 = load i8, ptr %category18, align 2
  %bf.clear20 = and i8 %bf.load19, -8
  %bf.set21 = or i8 %bf.clear20, 0
  store i8 %bf.set21, ptr %category18, align 2
  %5 = load ptr, ptr %rhs.addr, align 8
  %sign22 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %5, i32 0, i32 3
  %bf.load23 = load i8, ptr %sign22, align 2
  %bf.lshr24 = lshr i8 %bf.load23, 3
  %bf.clear25 = and i8 %bf.lshr24, 1
  %bf.cast26 = zext i8 %bf.clear25 to i32
  %6 = load i8, ptr %subtract.addr, align 1
  %tobool27 = trunc i8 %6 to i1
  %conv28 = zext i1 %tobool27 to i32
  %xor29 = xor i32 %bf.cast26, %conv28
  %sign30 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %7 = trunc i32 %xor29 to i8
  %bf.load31 = load i8, ptr %sign30, align 2
  %bf.value32 = and i8 %7, 1
  %bf.shl33 = shl i8 %bf.value32, 3
  %bf.clear34 = and i8 %bf.load31, -9
  %bf.set35 = or i8 %bf.clear34, %bf.shl33
  store i8 %bf.set35, ptr %sign30, align 2
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb36:                                          ; preds = %entry
  %8 = load ptr, ptr %rhs.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloat6assignERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %8)
  %9 = load ptr, ptr %rhs.addr, align 8
  %sign37 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %9, i32 0, i32 3
  %bf.load38 = load i8, ptr %sign37, align 2
  %bf.lshr39 = lshr i8 %bf.load38, 3
  %bf.clear40 = and i8 %bf.lshr39, 1
  %bf.cast41 = zext i8 %bf.clear40 to i32
  %10 = load i8, ptr %subtract.addr, align 1
  %tobool42 = trunc i8 %10 to i1
  %conv43 = zext i1 %tobool42 to i32
  %xor44 = xor i32 %bf.cast41, %conv43
  %sign45 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %11 = trunc i32 %xor44 to i8
  %bf.load46 = load i8, ptr %sign45, align 2
  %bf.value47 = and i8 %11, 1
  %bf.shl48 = shl i8 %bf.value47, 3
  %bf.clear49 = and i8 %bf.load46, -9
  %bf.set50 = or i8 %bf.clear49, %bf.shl48
  store i8 %bf.set50, ptr %sign45, align 2
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb51:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb52:                                          ; preds = %entry
  %sign53 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load54 = load i8, ptr %sign53, align 2
  %bf.lshr55 = lshr i8 %bf.load54, 3
  %bf.clear56 = and i8 %bf.lshr55, 1
  %bf.cast57 = zext i8 %bf.clear56 to i32
  %12 = load ptr, ptr %rhs.addr, align 8
  %sign58 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %12, i32 0, i32 3
  %bf.load59 = load i8, ptr %sign58, align 2
  %bf.lshr60 = lshr i8 %bf.load59, 3
  %bf.clear61 = and i8 %bf.lshr60, 1
  %bf.cast62 = zext i8 %bf.clear61 to i32
  %xor63 = xor i32 %bf.cast57, %bf.cast62
  %cmp = icmp ne i32 %xor63, 0
  %conv64 = zext i1 %cmp to i32
  %13 = load i8, ptr %subtract.addr, align 1
  %tobool65 = trunc i8 %13 to i1
  %conv66 = zext i1 %tobool65 to i32
  %cmp67 = icmp ne i32 %conv64, %conv66
  br i1 %cmp67, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb52
  call void @_ZN4llvh6detail9IEEEFloat7makeNaNEbbPKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this1, i1 noundef zeroext false, i1 noundef zeroext false, ptr noundef null)
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %sw.bb52
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb68:                                          ; preds = %entry
  store i32 2, ptr %retval, align 4
  br label %return

return:                                           ; preds = %sw.bb68, %if.end, %if.then, %sw.bb51, %sw.bb36, %sw.bb17, %sw.bb6, %sw.bb
  %14 = load i32, ptr %retval, align 4
  ret i32 %14
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat16multiplySpecialsERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %rhs) #1 align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, 7
  %bf.cast = zext i8 %bf.clear to i32
  %mul = mul nsw i32 %bf.cast, 4
  %0 = load ptr, ptr %rhs.addr, align 8
  %category2 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %0, i32 0, i32 3
  %bf.load3 = load i8, ptr %category2, align 2
  %bf.clear4 = and i8 %bf.load3, 7
  %bf.cast5 = zext i8 %bf.clear4 to i32
  %add = add nsw i32 %mul, %bf.cast5
  switch i32 %add, label %sw.default [
    i32 7, label %sw.bb
    i32 6, label %sw.bb
    i32 4, label %sw.bb
    i32 5, label %sw.bb
    i32 13, label %sw.bb8
    i32 9, label %sw.bb8
    i32 1, label %sw.bb8
    i32 8, label %sw.bb17
    i32 2, label %sw.bb17
    i32 0, label %sw.bb17
    i32 14, label %sw.bb22
    i32 11, label %sw.bb22
    i32 15, label %sw.bb22
    i32 12, label %sw.bb27
    i32 3, label %sw.bb27
    i32 10, label %sw.bb28
  ]

sw.default:                                       ; preds = %entry
  unreachable

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load6 = load i8, ptr %sign, align 2
  %bf.clear7 = and i8 %bf.load6, -9
  %bf.set = or i8 %bf.clear7, 0
  store i8 %bf.set, ptr %sign, align 2
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb8:                                           ; preds = %entry, %entry, %entry
  %sign9 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load10 = load i8, ptr %sign9, align 2
  %bf.clear11 = and i8 %bf.load10, -9
  %bf.set12 = or i8 %bf.clear11, 0
  store i8 %bf.set12, ptr %sign9, align 2
  %category13 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load14 = load i8, ptr %category13, align 2
  %bf.clear15 = and i8 %bf.load14, -8
  %bf.set16 = or i8 %bf.clear15, 1
  store i8 %bf.set16, ptr %category13, align 2
  %1 = load ptr, ptr %rhs.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloat15copySignificandERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %1)
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb17:                                          ; preds = %entry, %entry, %entry
  %category18 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load19 = load i8, ptr %category18, align 2
  %bf.clear20 = and i8 %bf.load19, -8
  %bf.set21 = or i8 %bf.clear20, 0
  store i8 %bf.set21, ptr %category18, align 2
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb22:                                          ; preds = %entry, %entry, %entry
  %category23 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load24 = load i8, ptr %category23, align 2
  %bf.clear25 = and i8 %bf.load24, -8
  %bf.set26 = or i8 %bf.clear25, 3
  store i8 %bf.set26, ptr %category23, align 2
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb27:                                          ; preds = %entry, %entry
  call void @_ZN4llvh6detail9IEEEFloat7makeNaNEbbPKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this1, i1 noundef zeroext false, i1 noundef zeroext false, ptr noundef null)
  store i32 1, ptr %retval, align 4
  br label %return

sw.bb28:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %sw.bb28, %sw.bb27, %sw.bb22, %sw.bb17, %sw.bb8, %sw.bb
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat14divideSpecialsERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %rhs) #1 align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, 7
  %bf.cast = zext i8 %bf.clear to i32
  %mul = mul nsw i32 %bf.cast, 4
  %0 = load ptr, ptr %rhs.addr, align 8
  %category2 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %0, i32 0, i32 3
  %bf.load3 = load i8, ptr %category2, align 2
  %bf.clear4 = and i8 %bf.load3, 7
  %bf.cast5 = zext i8 %bf.clear4 to i32
  %add = add nsw i32 %mul, %bf.cast5
  switch i32 %add, label %sw.default [
    i32 13, label %sw.bb
    i32 9, label %sw.bb
    i32 1, label %sw.bb
    i32 7, label %sw.bb9
    i32 6, label %sw.bb9
    i32 4, label %sw.bb9
    i32 5, label %sw.bb9
    i32 3, label %sw.bb13
    i32 2, label %sw.bb13
    i32 12, label %sw.bb13
    i32 14, label %sw.bb13
    i32 8, label %sw.bb14
    i32 11, label %sw.bb19
    i32 0, label %sw.bb24
    i32 15, label %sw.bb24
    i32 10, label %sw.bb25
  ]

sw.default:                                       ; preds = %entry
  unreachable

sw.bb:                                            ; preds = %entry, %entry, %entry
  %category6 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load7 = load i8, ptr %category6, align 2
  %bf.clear8 = and i8 %bf.load7, -8
  %bf.set = or i8 %bf.clear8, 1
  store i8 %bf.set, ptr %category6, align 2
  %1 = load ptr, ptr %rhs.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloat15copySignificandERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %1)
  br label %sw.bb9

sw.bb9:                                           ; preds = %sw.bb, %entry, %entry, %entry, %entry
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load10 = load i8, ptr %sign, align 2
  %bf.clear11 = and i8 %bf.load10, -9
  %bf.set12 = or i8 %bf.clear11, 0
  store i8 %bf.set12, ptr %sign, align 2
  br label %sw.bb13

sw.bb13:                                          ; preds = %sw.bb9, %entry, %entry, %entry, %entry
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb14:                                          ; preds = %entry
  %category15 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load16 = load i8, ptr %category15, align 2
  %bf.clear17 = and i8 %bf.load16, -8
  %bf.set18 = or i8 %bf.clear17, 3
  store i8 %bf.set18, ptr %category15, align 2
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb19:                                          ; preds = %entry
  %category20 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load21 = load i8, ptr %category20, align 2
  %bf.clear22 = and i8 %bf.load21, -8
  %bf.set23 = or i8 %bf.clear22, 0
  store i8 %bf.set23, ptr %category20, align 2
  store i32 2, ptr %retval, align 4
  br label %return

sw.bb24:                                          ; preds = %entry, %entry
  call void @_ZN4llvh6detail9IEEEFloat7makeNaNEbbPKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this1, i1 noundef zeroext false, i1 noundef zeroext false, ptr noundef null)
  store i32 1, ptr %retval, align 4
  br label %return

sw.bb25:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %sw.bb25, %sw.bb24, %sw.bb19, %sw.bb14, %sw.bb13
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat11modSpecialsERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %rhs) #1 align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, 7
  %bf.cast = zext i8 %bf.clear to i32
  %mul = mul nsw i32 %bf.cast, 4
  %0 = load ptr, ptr %rhs.addr, align 8
  %category2 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %0, i32 0, i32 3
  %bf.load3 = load i8, ptr %category2, align 2
  %bf.clear4 = and i8 %bf.load3, 7
  %bf.cast5 = zext i8 %bf.clear4 to i32
  %add = add nsw i32 %mul, %bf.cast5
  switch i32 %add, label %sw.default [
    i32 7, label %sw.bb
    i32 6, label %sw.bb
    i32 4, label %sw.bb
    i32 5, label %sw.bb
    i32 12, label %sw.bb
    i32 14, label %sw.bb
    i32 8, label %sw.bb
    i32 13, label %sw.bb6
    i32 9, label %sw.bb6
    i32 1, label %sw.bb6
    i32 11, label %sw.bb13
    i32 3, label %sw.bb13
    i32 2, label %sw.bb13
    i32 0, label %sw.bb13
    i32 15, label %sw.bb13
    i32 10, label %sw.bb14
  ]

sw.default:                                       ; preds = %entry
  unreachable

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb6:                                           ; preds = %entry, %entry, %entry
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load7 = load i8, ptr %sign, align 2
  %bf.clear8 = and i8 %bf.load7, -9
  %bf.set = or i8 %bf.clear8, 0
  store i8 %bf.set, ptr %sign, align 2
  %category9 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load10 = load i8, ptr %category9, align 2
  %bf.clear11 = and i8 %bf.load10, -8
  %bf.set12 = or i8 %bf.clear11, 1
  store i8 %bf.set12, ptr %category9, align 2
  %1 = load ptr, ptr %rhs.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloat15copySignificandERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %1)
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb13:                                          ; preds = %entry, %entry, %entry, %entry, %entry
  call void @_ZN4llvh6detail9IEEEFloat7makeNaNEbbPKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this1, i1 noundef zeroext false, i1 noundef zeroext false, ptr noundef null)
  store i32 1, ptr %retval, align 4
  br label %return

sw.bb14:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %sw.bb14, %sw.bb13, %sw.bb6, %sw.bb
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloat10changeSignEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load, 3
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  %lnot = xor i1 %tobool, true
  %conv = zext i1 %lnot to i32
  %sign2 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %0 = trunc i32 %conv to i8
  %bf.load3 = load i8, ptr %sign2, align 2
  %bf.value = and i8 %0, 1
  %bf.shl = shl i8 %bf.value, 3
  %bf.clear4 = and i8 %bf.load3, -9
  %bf.set = or i8 %bf.clear4, %bf.shl
  store i8 %bf.set, ptr %sign2, align 2
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat13addOrSubtractERKS1_NS_11APFloatBase12roundingModeEb(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %rhs, i32 noundef %rounding_mode, i1 noundef zeroext %subtract) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  %rounding_mode.addr = alloca i32, align 4
  %subtract.addr = alloca i8, align 1
  %fs = alloca i32, align 4
  %lost_fraction = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  store i32 %rounding_mode, ptr %rounding_mode.addr, align 4
  %frombool = zext i1 %subtract to i8
  store i8 %frombool, ptr %subtract.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %1 = load i8, ptr %subtract.addr, align 1
  %tobool = trunc i8 %1 to i1
  %call = call noundef i32 @_ZN4llvh6detail9IEEEFloat21addOrSubtractSpecialsERKS1_b(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %0, i1 noundef zeroext %tobool)
  store i32 %call, ptr %fs, align 4
  %2 = load i32, ptr %fs, align 4
  %cmp = icmp eq i32 %2, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %rhs.addr, align 8
  %4 = load i8, ptr %subtract.addr, align 1
  %tobool2 = trunc i8 %4 to i1
  %call3 = call noundef i32 @_ZN4llvh6detail9IEEEFloat24addOrSubtractSignificandERKS1_b(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %3, i1 noundef zeroext %tobool2)
  store i32 %call3, ptr %lost_fraction, align 4
  %5 = load i32, ptr %rounding_mode.addr, align 4
  %6 = load i32, ptr %lost_fraction, align 4
  %call4 = call noundef i32 @_ZN4llvh6detail9IEEEFloat9normalizeENS_11APFloatBase12roundingModeENS_12lostFractionE(ptr noundef nonnull align 8 dereferenceable(24) %this1, i32 noundef %5, i32 noundef %6)
  store i32 %call4, ptr %fs, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, 7
  %bf.cast = zext i8 %bf.clear to i32
  %cmp5 = icmp eq i32 %bf.cast, 3
  br i1 %cmp5, label %if.then6, label %if.end31

if.then6:                                         ; preds = %if.end
  %7 = load ptr, ptr %rhs.addr, align 8
  %category7 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %7, i32 0, i32 3
  %bf.load8 = load i8, ptr %category7, align 2
  %bf.clear9 = and i8 %bf.load8, 7
  %bf.cast10 = zext i8 %bf.clear9 to i32
  %cmp11 = icmp ne i32 %bf.cast10, 3
  br i1 %cmp11, label %if.then24, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then6
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load12 = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load12, 3
  %bf.clear13 = and i8 %bf.lshr, 1
  %bf.cast14 = zext i8 %bf.clear13 to i32
  %8 = load ptr, ptr %rhs.addr, align 8
  %sign15 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %8, i32 0, i32 3
  %bf.load16 = load i8, ptr %sign15, align 2
  %bf.lshr17 = lshr i8 %bf.load16, 3
  %bf.clear18 = and i8 %bf.lshr17, 1
  %bf.cast19 = zext i8 %bf.clear18 to i32
  %cmp20 = icmp eq i32 %bf.cast14, %bf.cast19
  %conv = zext i1 %cmp20 to i32
  %9 = load i8, ptr %subtract.addr, align 1
  %tobool21 = trunc i8 %9 to i1
  %conv22 = zext i1 %tobool21 to i32
  %cmp23 = icmp eq i32 %conv, %conv22
  br i1 %cmp23, label %if.then24, label %if.end30

if.then24:                                        ; preds = %lor.lhs.false, %if.then6
  %10 = load i32, ptr %rounding_mode.addr, align 4
  %cmp25 = icmp eq i32 %10, 2
  %conv26 = zext i1 %cmp25 to i32
  %sign27 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %11 = trunc i32 %conv26 to i8
  %bf.load28 = load i8, ptr %sign27, align 2
  %bf.value = and i8 %11, 1
  %bf.shl = shl i8 %bf.value, 3
  %bf.clear29 = and i8 %bf.load28, -9
  %bf.set = or i8 %bf.clear29, %bf.shl
  store i8 %bf.set, ptr %sign27, align 2
  br label %if.end30

if.end30:                                         ; preds = %if.then24, %lor.lhs.false
  br label %if.end31

if.end31:                                         ; preds = %if.end30, %if.end
  %12 = load i32, ptr %fs, align 4
  ret i32 %12
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat3addERKS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %rhs, i32 noundef %rounding_mode) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  %rounding_mode.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  store i32 %rounding_mode, ptr %rounding_mode.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %1 = load i32, ptr %rounding_mode.addr, align 4
  %call = call noundef i32 @_ZN4llvh6detail9IEEEFloat13addOrSubtractERKS1_NS_11APFloatBase12roundingModeEb(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %0, i32 noundef %1, i1 noundef zeroext false)
  ret i32 %call
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat8subtractERKS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %rhs, i32 noundef %rounding_mode) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  %rounding_mode.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  store i32 %rounding_mode, ptr %rounding_mode.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %1 = load i32, ptr %rounding_mode.addr, align 4
  %call = call noundef i32 @_ZN4llvh6detail9IEEEFloat13addOrSubtractERKS1_NS_11APFloatBase12roundingModeEb(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %0, i32 noundef %1, i1 noundef zeroext true)
  ret i32 %call
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat8multiplyERKS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %rhs, i32 noundef %rounding_mode) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  %rounding_mode.addr = alloca i32, align 4
  %fs = alloca i32, align 4
  %lost_fraction = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  store i32 %rounding_mode, ptr %rounding_mode.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %0, i32 0, i32 3
  %bf.load = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load, 3
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %sign2 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load3 = load i8, ptr %sign2, align 2
  %bf.lshr4 = lshr i8 %bf.load3, 3
  %bf.clear5 = and i8 %bf.lshr4, 1
  %bf.cast6 = zext i8 %bf.clear5 to i32
  %xor = xor i32 %bf.cast6, %bf.cast
  %1 = trunc i32 %xor to i8
  %bf.load7 = load i8, ptr %sign2, align 2
  %bf.value = and i8 %1, 1
  %bf.shl = shl i8 %bf.value, 3
  %bf.clear8 = and i8 %bf.load7, -9
  %bf.set = or i8 %bf.clear8, %bf.shl
  store i8 %bf.set, ptr %sign2, align 2
  %2 = load ptr, ptr %rhs.addr, align 8
  %call = call noundef i32 @_ZN4llvh6detail9IEEEFloat16multiplySpecialsERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %2)
  store i32 %call, ptr %fs, align 4
  %call9 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call9, label %if.then, label %if.end13

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %rhs.addr, align 8
  %call10 = call noundef i32 @_ZN4llvh6detail9IEEEFloat19multiplySignificandERKS1_PS2_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %3, ptr noundef null)
  store i32 %call10, ptr %lost_fraction, align 4
  %4 = load i32, ptr %rounding_mode.addr, align 4
  %5 = load i32, ptr %lost_fraction, align 4
  %call11 = call noundef i32 @_ZN4llvh6detail9IEEEFloat9normalizeENS_11APFloatBase12roundingModeENS_12lostFractionE(ptr noundef nonnull align 8 dereferenceable(24) %this1, i32 noundef %4, i32 noundef %5)
  store i32 %call11, ptr %fs, align 4
  %6 = load i32, ptr %lost_fraction, align 4
  %cmp = icmp ne i32 %6, 0
  br i1 %cmp, label %if.then12, label %if.end

if.then12:                                        ; preds = %if.then
  %7 = load i32, ptr %fs, align 4
  %or = or i32 %7, 16
  store i32 %or, ptr %fs, align 4
  br label %if.end

if.end:                                           ; preds = %if.then12, %if.then
  br label %if.end13

if.end13:                                         ; preds = %if.end, %entry
  %8 = load i32, ptr %fs, align 4
  ret i32 %8
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat6divideERKS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %rhs, i32 noundef %rounding_mode) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  %rounding_mode.addr = alloca i32, align 4
  %fs = alloca i32, align 4
  %lost_fraction = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  store i32 %rounding_mode, ptr %rounding_mode.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %0, i32 0, i32 3
  %bf.load = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load, 3
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %sign2 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load3 = load i8, ptr %sign2, align 2
  %bf.lshr4 = lshr i8 %bf.load3, 3
  %bf.clear5 = and i8 %bf.lshr4, 1
  %bf.cast6 = zext i8 %bf.clear5 to i32
  %xor = xor i32 %bf.cast6, %bf.cast
  %1 = trunc i32 %xor to i8
  %bf.load7 = load i8, ptr %sign2, align 2
  %bf.value = and i8 %1, 1
  %bf.shl = shl i8 %bf.value, 3
  %bf.clear8 = and i8 %bf.load7, -9
  %bf.set = or i8 %bf.clear8, %bf.shl
  store i8 %bf.set, ptr %sign2, align 2
  %2 = load ptr, ptr %rhs.addr, align 8
  %call = call noundef i32 @_ZN4llvh6detail9IEEEFloat14divideSpecialsERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %2)
  store i32 %call, ptr %fs, align 4
  %call9 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call9, label %if.then, label %if.end13

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %rhs.addr, align 8
  %call10 = call noundef i32 @_ZN4llvh6detail9IEEEFloat17divideSignificandERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %3)
  store i32 %call10, ptr %lost_fraction, align 4
  %4 = load i32, ptr %rounding_mode.addr, align 4
  %5 = load i32, ptr %lost_fraction, align 4
  %call11 = call noundef i32 @_ZN4llvh6detail9IEEEFloat9normalizeENS_11APFloatBase12roundingModeENS_12lostFractionE(ptr noundef nonnull align 8 dereferenceable(24) %this1, i32 noundef %4, i32 noundef %5)
  store i32 %call11, ptr %fs, align 4
  %6 = load i32, ptr %lost_fraction, align 4
  %cmp = icmp ne i32 %6, 0
  br i1 %cmp, label %if.then12, label %if.end

if.then12:                                        ; preds = %if.then
  %7 = load i32, ptr %fs, align 4
  %or = or i32 %7, 16
  store i32 %or, ptr %fs, align 4
  br label %if.end

if.end:                                           ; preds = %if.then12, %if.then
  br label %if.end13

if.end13:                                         ; preds = %if.end, %entry
  %8 = load i32, ptr %fs, align 4
  ret i32 %8
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat9remainderERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %rhs) #1 align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  %fs = alloca i32, align 4
  %V = alloca %"class.llvh::detail::IEEEFloat", align 8
  %origSign = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  %parts = alloca i32, align 4
  %x = alloca ptr, align 8
  %ignored = alloca i8, align 1
  %agg.tmp = alloca %"class.llvh::MutableArrayRef", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloatC1ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %V, ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load, 3
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  store i32 %bf.cast, ptr %origSign, align 4
  %0 = load ptr, ptr %rhs.addr, align 8
  %call = call noundef i32 @_ZN4llvh6detail9IEEEFloat6divideERKS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %V, ptr noundef nonnull align 8 dereferenceable(24) %0, i32 noundef 0)
  store i32 %call, ptr %fs, align 4
  %1 = load i32, ptr %fs, align 4
  %cmp = icmp eq i32 %1, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %fs, align 4
  store i32 %2, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %entry
  %call2 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store i32 %call2, ptr %parts, align 4
  %3 = load i32, ptr %parts, align 4
  %conv = sext i32 %3 to i64
  %4 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %conv, i64 8)
  %5 = extractvalue { i64, i1 } %4, 1
  %6 = extractvalue { i64, i1 } %4, 0
  %7 = select i1 %5, i64 -1, i64 %6
  %call3 = call noalias noundef nonnull ptr @_Znam(i64 noundef %7) #13
  store ptr %call3, ptr %x, align 8
  %8 = load ptr, ptr %x, align 8
  %9 = load i32, ptr %parts, align 4
  %conv4 = sext i32 %9 to i64
  %call5 = call { ptr, i64 } @_ZN4llvh19makeMutableArrayRefImEENS_15MutableArrayRefIT_EEPS2_m(ptr noundef %8, i64 noundef %conv4)
  %coerce.dive = getelementptr inbounds %"class.llvh::MutableArrayRef", ptr %agg.tmp, i32 0, i32 0
  %10 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %11 = extractvalue { ptr, i64 } %call5, 0
  store ptr %11, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %13 = extractvalue { ptr, i64 } %call5, 1
  store i64 %13, ptr %12, align 8
  %14 = load i32, ptr %parts, align 4
  %mul = mul i32 %14, 64
  %15 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %18 = load i64, ptr %17, align 8
  %call6 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat16convertToIntegerENS_15MutableArrayRefImEEjbNS_11APFloatBase12roundingModeEPb(ptr noundef nonnull align 8 dereferenceable(24) %V, ptr %16, i64 %18, i32 noundef %mul, i1 noundef zeroext true, i32 noundef 0, ptr noundef %ignored)
  store i32 %call6, ptr %fs, align 4
  %19 = load i32, ptr %fs, align 4
  %cmp7 = icmp eq i32 %19, 1
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end
  %20 = load ptr, ptr %x, align 8
  %isnull = icmp eq ptr %20, null
  br i1 %isnull, label %delete.end, label %delete.notnull

delete.notnull:                                   ; preds = %if.then8
  call void @_ZdaPv(ptr noundef %20) #14
  br label %delete.end

delete.end:                                       ; preds = %delete.notnull, %if.then8
  %21 = load i32, ptr %fs, align 4
  store i32 %21, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end9:                                          ; preds = %if.end
  %22 = load ptr, ptr %x, align 8
  %23 = load i32, ptr %parts, align 4
  %mul10 = mul i32 %23, 64
  %call11 = call noundef i32 @_ZN4llvh6detail9IEEEFloat30convertFromZeroExtendedIntegerEPKmjbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %V, ptr noundef %22, i32 noundef %mul10, i1 noundef zeroext true, i32 noundef 0)
  store i32 %call11, ptr %fs, align 4
  %24 = load ptr, ptr %rhs.addr, align 8
  %call12 = call noundef i32 @_ZN4llvh6detail9IEEEFloat8multiplyERKS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %V, ptr noundef nonnull align 8 dereferenceable(24) %24, i32 noundef 0)
  store i32 %call12, ptr %fs, align 4
  %call13 = call noundef i32 @_ZN4llvh6detail9IEEEFloat8subtractERKS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %V, i32 noundef 0)
  store i32 %call13, ptr %fs, align 4
  %call14 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat6isZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call14, label %if.then15, label %if.end19

if.then15:                                        ; preds = %if.end9
  %25 = load i32, ptr %origSign, align 4
  %sign16 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %26 = trunc i32 %25 to i8
  %bf.load17 = load i8, ptr %sign16, align 2
  %bf.value = and i8 %26, 1
  %bf.shl = shl i8 %bf.value, 3
  %bf.clear18 = and i8 %bf.load17, -9
  %bf.set = or i8 %bf.clear18, %bf.shl
  store i8 %bf.set, ptr %sign16, align 2
  br label %if.end19

if.end19:                                         ; preds = %if.then15, %if.end9
  %27 = load ptr, ptr %x, align 8
  %isnull20 = icmp eq ptr %27, null
  br i1 %isnull20, label %delete.end22, label %delete.notnull21

delete.notnull21:                                 ; preds = %if.end19
  call void @_ZdaPv(ptr noundef %27) #14
  br label %delete.end22

delete.end22:                                     ; preds = %delete.notnull21, %if.end19
  %28 = load i32, ptr %fs, align 4
  store i32 %28, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %delete.end22, %delete.end, %if.then
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %V) #10
  %29 = load i32, ptr %retval, align 4
  ret i32 %29
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZNK4llvh6detail9IEEEFloat16convertToIntegerENS_15MutableArrayRefImEEjbNS_11APFloatBase12roundingModeEPb(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr %parts.coerce0, i64 %parts.coerce1, i32 noundef %width, i1 noundef zeroext %isSigned, i32 noundef %rounding_mode, ptr noundef %isExact) #1 align 2 {
entry:
  %parts = alloca %"class.llvh::MutableArrayRef", align 8
  %this.addr = alloca ptr, align 8
  %width.addr = alloca i32, align 4
  %isSigned.addr = alloca i8, align 1
  %rounding_mode.addr = alloca i32, align 4
  %isExact.addr = alloca ptr, align 8
  %fs = alloca i32, align 4
  %agg.tmp = alloca %"class.llvh::MutableArrayRef", align 8
  %bits = alloca i32, align 4
  %dstPartsCount = alloca i32, align 4
  %0 = getelementptr inbounds { ptr, i64 }, ptr %parts, i32 0, i32 0
  store ptr %parts.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %parts, i32 0, i32 1
  store i64 %parts.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %width, ptr %width.addr, align 4
  %frombool = zext i1 %isSigned to i8
  store i8 %frombool, ptr %isSigned.addr, align 1
  store i32 %rounding_mode, ptr %rounding_mode.addr, align 4
  store ptr %isExact, ptr %isExact.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %parts, i64 16, i1 false)
  %2 = load i32, ptr %width.addr, align 4
  %3 = load i8, ptr %isSigned.addr, align 1
  %tobool = trunc i8 %3 to i1
  %4 = load i32, ptr %rounding_mode.addr, align 4
  %5 = load ptr, ptr %isExact.addr, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %9 = load i64, ptr %8, align 8
  %call = call noundef i32 @_ZNK4llvh6detail9IEEEFloat28convertToSignExtendedIntegerENS_15MutableArrayRefImEEjbNS_11APFloatBase12roundingModeEPb(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr %7, i64 %9, i32 noundef %2, i1 noundef zeroext %tobool, i32 noundef %4, ptr noundef %5)
  store i32 %call, ptr %fs, align 4
  %10 = load i32, ptr %fs, align 4
  %cmp = icmp eq i32 %10, 1
  br i1 %cmp, label %if.then, label %if.end27

if.then:                                          ; preds = %entry
  %11 = load i32, ptr %width.addr, align 4
  %call2 = call noundef i32 @_ZN4llvhL16partCountForBitsEj(i32 noundef %11)
  store i32 %call2, ptr %dstPartsCount, align 4
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, 7
  %bf.cast = zext i8 %bf.clear to i32
  %cmp3 = icmp eq i32 %bf.cast, 1
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.then
  store i32 0, ptr %bits, align 4
  br label %if.end14

if.else:                                          ; preds = %if.then
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load5 = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load5, 3
  %bf.clear6 = and i8 %bf.lshr, 1
  %bf.cast7 = zext i8 %bf.clear6 to i32
  %tobool8 = icmp ne i32 %bf.cast7, 0
  br i1 %tobool8, label %if.then9, label %if.else11

if.then9:                                         ; preds = %if.else
  %12 = load i8, ptr %isSigned.addr, align 1
  %tobool10 = trunc i8 %12 to i1
  %conv = zext i1 %tobool10 to i32
  store i32 %conv, ptr %bits, align 4
  br label %if.end

if.else11:                                        ; preds = %if.else
  %13 = load i32, ptr %width.addr, align 4
  %14 = load i8, ptr %isSigned.addr, align 1
  %tobool12 = trunc i8 %14 to i1
  %conv13 = zext i1 %tobool12 to i32
  %sub = sub i32 %13, %conv13
  store i32 %sub, ptr %bits, align 4
  br label %if.end

if.end:                                           ; preds = %if.else11, %if.then9
  br label %if.end14

if.end14:                                         ; preds = %if.end, %if.then4
  %call15 = call noundef ptr @_ZNK4llvh15MutableArrayRefImE4dataEv(ptr noundef nonnull align 8 dereferenceable(16) %parts)
  %15 = load i32, ptr %dstPartsCount, align 4
  %16 = load i32, ptr %bits, align 4
  call void @_ZN4llvh5APInt25tcSetLeastSignificantBitsEPmjj(ptr noundef %call15, i32 noundef %15, i32 noundef %16)
  %sign16 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load17 = load i8, ptr %sign16, align 2
  %bf.lshr18 = lshr i8 %bf.load17, 3
  %bf.clear19 = and i8 %bf.lshr18, 1
  %bf.cast20 = zext i8 %bf.clear19 to i32
  %tobool21 = icmp ne i32 %bf.cast20, 0
  br i1 %tobool21, label %land.lhs.true, label %if.end26

land.lhs.true:                                    ; preds = %if.end14
  %17 = load i8, ptr %isSigned.addr, align 1
  %tobool22 = trunc i8 %17 to i1
  br i1 %tobool22, label %if.then23, label %if.end26

if.then23:                                        ; preds = %land.lhs.true
  %call24 = call noundef ptr @_ZNK4llvh15MutableArrayRefImE4dataEv(ptr noundef nonnull align 8 dereferenceable(16) %parts)
  %18 = load i32, ptr %dstPartsCount, align 4
  %19 = load i32, ptr %width.addr, align 4
  %sub25 = sub i32 %19, 1
  call void @_ZN4llvh5APInt11tcShiftLeftEPmjj(ptr noundef %call24, i32 noundef %18, i32 noundef %sub25)
  br label %if.end26

if.end26:                                         ; preds = %if.then23, %land.lhs.true, %if.end14
  br label %if.end27

if.end27:                                         ; preds = %if.end26, %entry
  %20 = load i32, ptr %fs, align 4
  ret i32 %20
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden { ptr, i64 } @_ZN4llvh19makeMutableArrayRefImEENS_15MutableArrayRefIT_EEPS2_m(ptr noundef %data, i64 noundef %length) #1 comdat {
entry:
  %retval = alloca %"class.llvh::MutableArrayRef", align 8
  %data.addr = alloca ptr, align 8
  %length.addr = alloca i64, align 8
  store ptr %data, ptr %data.addr, align 8
  store i64 %length, ptr %length.addr, align 8
  %0 = load ptr, ptr %data.addr, align 8
  %1 = load i64, ptr %length.addr, align 8
  call void @_ZN4llvh15MutableArrayRefImEC2EPmm(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef %0, i64 noundef %1)
  %coerce.dive = getelementptr inbounds %"class.llvh::MutableArrayRef", ptr %retval, i32 0, i32 0
  %2 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %2
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat30convertFromZeroExtendedIntegerEPKmjbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %parts, i32 noundef %width, i1 noundef zeroext %isSigned, i32 noundef %rounding_mode) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %parts.addr = alloca ptr, align 8
  %width.addr = alloca i32, align 4
  %isSigned.addr = alloca i8, align 1
  %rounding_mode.addr = alloca i32, align 4
  %partCount = alloca i32, align 4
  %api = alloca %"class.llvh::APInt", align 8
  %agg.tmp = alloca %"class.llvh::ArrayRef", align 8
  %ref.tmp = alloca %"class.llvh::APInt", align 8
  %agg.tmp9 = alloca %"class.llvh::APInt", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %parts, ptr %parts.addr, align 8
  store i32 %width, ptr %width.addr, align 4
  %frombool = zext i1 %isSigned to i8
  store i8 %frombool, ptr %isSigned.addr, align 1
  store i32 %rounding_mode, ptr %rounding_mode.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %width.addr, align 4
  %call = call noundef i32 @_ZN4llvhL16partCountForBitsEj(i32 noundef %0)
  store i32 %call, ptr %partCount, align 4
  %1 = load i32, ptr %width.addr, align 4
  %2 = load ptr, ptr %parts.addr, align 8
  %3 = load i32, ptr %partCount, align 4
  %conv = zext i32 %3 to i64
  %call2 = call { ptr, i64 } @_ZN4llvh12makeArrayRefImEENS_8ArrayRefIT_EEPKS2_m(ptr noundef %2, i64 noundef %conv)
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = extractvalue { ptr, i64 } %call2, 0
  store ptr %5, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = extractvalue { ptr, i64 } %call2, 1
  store i64 %7, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  call void @_ZN4llvh5APIntC1EjNS_8ArrayRefImEE(ptr noundef nonnull align 8 dereferenceable(12) %api, i32 noundef %1, ptr %9, i64 %11)
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %sign, align 2
  %bf.clear = and i8 %bf.load, -9
  %bf.set = or i8 %bf.clear, 0
  store i8 %bf.set, ptr %sign, align 2
  %12 = load i8, ptr %isSigned.addr, align 1
  %tobool = trunc i8 %12 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %13 = load ptr, ptr %parts.addr, align 8
  %14 = load i32, ptr %width.addr, align 4
  %sub = sub i32 %14, 1
  %call3 = call noundef i32 @_ZN4llvh5APInt12tcExtractBitEPKmj(ptr noundef %13, i32 noundef %sub)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %sign5 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load6 = load i8, ptr %sign5, align 2
  %bf.clear7 = and i8 %bf.load6, -9
  %bf.set8 = or i8 %bf.clear7, 8
  store i8 %bf.set8, ptr %sign5, align 2
  call void @_ZN4llvh5APIntC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(12) %agg.tmp9, ptr noundef nonnull align 8 dereferenceable(12) %api)
  call void @_ZN4llvhngENS_5APIntE(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp, ptr noundef %agg.tmp9)
  %call10 = call noundef nonnull align 8 dereferenceable(12) ptr @_ZN4llvh5APIntaSEOS0_(ptr noundef nonnull align 8 dereferenceable(12) %api, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %agg.tmp9) #10
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %call11 = call noundef ptr @_ZNK4llvh5APInt10getRawDataEv(ptr noundef nonnull align 8 dereferenceable(12) %api)
  %15 = load i32, ptr %partCount, align 4
  %16 = load i32, ptr %rounding_mode.addr, align 4
  %call12 = call noundef i32 @_ZN4llvh6detail9IEEEFloat24convertFromUnsignedPartsEPKmjNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %call11, i32 noundef %15, i32 noundef %16)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %api) #10
  ret i32 %call12
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat6isZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, 7
  %bf.cast = zext i8 %bf.clear to i32
  %cmp = icmp eq i32 %bf.cast, 3
  ret i1 %cmp
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat3modERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %rhs) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  %fs = alloca i32, align 4
  %origSign = alloca i32, align 4
  %V = alloca %"class.llvh::detail::IEEEFloat", align 8
  %agg.tmp = alloca %"class.llvh::detail::IEEEFloat", align 8
  %ref.tmp = alloca %"class.llvh::detail::IEEEFloat", align 8
  %agg.tmp9 = alloca %"class.llvh::detail::IEEEFloat", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %call = call noundef i32 @_ZN4llvh6detail9IEEEFloat11modSpecialsERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %0)
  store i32 %call, ptr %fs, align 4
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load, 3
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  store i32 %bf.cast, ptr %origSign, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %call2 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call2, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %while.cond
  %1 = load ptr, ptr %rhs.addr, align 8
  %call3 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %1)
  br i1 %call3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %2 = load ptr, ptr %rhs.addr, align 8
  %call4 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat20compareAbsoluteValueERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %2)
  %cmp = icmp ne i32 %call4, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %while.cond
  %3 = phi i1 [ false, %land.lhs.true ], [ false, %while.cond ], [ %cmp, %land.rhs ]
  br i1 %3, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %4 = load ptr, ptr %rhs.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloatC1ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %4)
  %call5 = call noundef i32 @_ZN4llvh6detail5ilogbERKNS0_9IEEEFloatE(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %5 = load ptr, ptr %rhs.addr, align 8
  %call6 = call noundef i32 @_ZN4llvh6detail5ilogbERKNS0_9IEEEFloatE(ptr noundef nonnull align 8 dereferenceable(24) %5)
  %sub = sub nsw i32 %call5, %call6
  call void @_ZN4llvh6detail6scalbnENS0_9IEEEFloatEiNS_11APFloatBase12roundingModeE(ptr sret(%"class.llvh::detail::IEEEFloat") align 8 %V, ptr noundef %agg.tmp, i32 noundef %sub, i32 noundef 0)
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp) #10
  %call7 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat20compareAbsoluteValueERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %V)
  %cmp8 = icmp eq i32 %call7, 0
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  call void @_ZN4llvh6detail9IEEEFloatC1ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp9, ptr noundef nonnull align 8 dereferenceable(24) %V)
  call void @_ZN4llvh6detail6scalbnENS0_9IEEEFloatEiNS_11APFloatBase12roundingModeE(ptr sret(%"class.llvh::detail::IEEEFloat") align 8 %ref.tmp, ptr noundef %agg.tmp9, i32 noundef -1, i32 noundef 0)
  %call10 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN4llvh6detail9IEEEFloataSEOS1_(ptr noundef nonnull align 8 dereferenceable(24) %V, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp)
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp) #10
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp9) #10
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %sign11 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load12 = load i8, ptr %sign11, align 2
  %bf.lshr13 = lshr i8 %bf.load12, 3
  %bf.clear14 = and i8 %bf.lshr13, 1
  %bf.cast15 = zext i8 %bf.clear14 to i32
  %sign16 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %V, i32 0, i32 3
  %6 = trunc i32 %bf.cast15 to i8
  %bf.load17 = load i8, ptr %sign16, align 2
  %bf.value = and i8 %6, 1
  %bf.shl = shl i8 %bf.value, 3
  %bf.clear18 = and i8 %bf.load17, -9
  %bf.set = or i8 %bf.clear18, %bf.shl
  store i8 %bf.set, ptr %sign16, align 2
  %call19 = call noundef i32 @_ZN4llvh6detail9IEEEFloat8subtractERKS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %V, i32 noundef 0)
  store i32 %call19, ptr %fs, align 4
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %V) #10
  br label %while.cond, !llvm.loop !10

while.end:                                        ; preds = %land.end
  %call20 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat6isZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call20, label %if.then21, label %if.end28

if.then21:                                        ; preds = %while.end
  %7 = load i32, ptr %origSign, align 4
  %sign22 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %8 = trunc i32 %7 to i8
  %bf.load23 = load i8, ptr %sign22, align 2
  %bf.value24 = and i8 %8, 1
  %bf.shl25 = shl i8 %bf.value24, 3
  %bf.clear26 = and i8 %bf.load23, -9
  %bf.set27 = or i8 %bf.clear26, %bf.shl25
  store i8 %bf.set27, ptr %sign22, align 2
  br label %if.end28

if.end28:                                         ; preds = %if.then21, %while.end
  %9 = load i32, ptr %fs, align 4
  ret i32 %9
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail6scalbnENS0_9IEEEFloatEiNS_11APFloatBase12roundingModeE(ptr noalias sret(%"class.llvh::detail::IEEEFloat") align 8 %agg.result, ptr noundef %X, i32 noundef %Exp, i32 noundef %RoundingMode) #1 {
entry:
  %result.ptr = alloca ptr, align 8
  %X.indirect_addr = alloca ptr, align 8
  %Exp.addr = alloca i32, align 4
  %RoundingMode.addr = alloca i32, align 4
  %MaxExp = alloca i16, align 2
  %MinExp = alloca i16, align 2
  %SignificandBits = alloca i32, align 4
  %MaxIncrement = alloca i32, align 4
  %ref.tmp = alloca i32, align 4
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %X, ptr %X.indirect_addr, align 8
  store i32 %Exp, ptr %Exp.addr, align 4
  store i32 %RoundingMode, ptr %RoundingMode.addr, align 4
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh6detail9IEEEFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(24) %X)
  %maxExponent = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %call, i32 0, i32 0
  %0 = load i16, ptr %maxExponent, align 4
  store i16 %0, ptr %MaxExp, align 2
  %call1 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh6detail9IEEEFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(24) %X)
  %minExponent = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %call1, i32 0, i32 1
  %1 = load i16, ptr %minExponent, align 2
  store i16 %1, ptr %MinExp, align 2
  %call2 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh6detail9IEEEFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(24) %X)
  %precision = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %call2, i32 0, i32 2
  %2 = load i32, ptr %precision, align 4
  %sub = sub i32 %2, 1
  store i32 %sub, ptr %SignificandBits, align 4
  %3 = load i16, ptr %MaxExp, align 2
  %conv = sext i16 %3 to i32
  %4 = load i16, ptr %MinExp, align 2
  %conv3 = sext i16 %4 to i32
  %5 = load i32, ptr %SignificandBits, align 4
  %sub4 = sub nsw i32 %conv3, %5
  %sub5 = sub nsw i32 %conv, %sub4
  %add = add nsw i32 %sub5, 1
  store i32 %add, ptr %MaxIncrement, align 4
  %6 = load i32, ptr %MaxIncrement, align 4
  %sub6 = sub nsw i32 0, %6
  %sub7 = sub nsw i32 %sub6, 1
  store i32 %sub7, ptr %ref.tmp, align 4
  %call8 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZSt3maxIiERKT_S2_S2_(ptr noundef nonnull align 4 dereferenceable(4) %Exp.addr, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp)
  %call9 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZSt3minIiERKT_S2_S2_(ptr noundef nonnull align 4 dereferenceable(4) %call8, ptr noundef nonnull align 4 dereferenceable(4) %MaxIncrement)
  %7 = load i32, ptr %call9, align 4
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %X, i32 0, i32 2
  %8 = load i16, ptr %exponent, align 8
  %conv10 = sext i16 %8 to i32
  %add11 = add nsw i32 %conv10, %7
  %conv12 = trunc i32 %add11 to i16
  store i16 %conv12, ptr %exponent, align 8
  %9 = load i32, ptr %RoundingMode.addr, align 4
  %call13 = call noundef i32 @_ZN4llvh6detail9IEEEFloat9normalizeENS_11APFloatBase12roundingModeENS_12lostFractionE(ptr noundef nonnull align 8 dereferenceable(24) %X, i32 noundef %9, i32 noundef 0)
  %call14 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat5isNaNEv(ptr noundef nonnull align 8 dereferenceable(24) %X)
  br i1 %call14, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @_ZN4llvh6detail9IEEEFloat9makeQuietEv(ptr noundef nonnull align 8 dereferenceable(24) %X)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @_ZN4llvh6detail9IEEEFloatC1EOS1_(ptr noundef nonnull align 8 dereferenceable(24) %agg.result, ptr noundef nonnull align 8 dereferenceable(24) %X)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail5ilogbERKNS0_9IEEEFloatE(ptr noundef nonnull align 8 dereferenceable(24) %Arg) #1 {
entry:
  %retval = alloca i32, align 4
  %Arg.addr = alloca ptr, align 8
  %Normalized = alloca %"class.llvh::detail::IEEEFloat", align 8
  %SignificandBits = alloca i32, align 4
  store ptr %Arg, ptr %Arg.addr, align 8
  %0 = load ptr, ptr %Arg.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat5isNaNEv(ptr noundef nonnull align 8 dereferenceable(24) %0)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -2147483648, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %Arg.addr, align 8
  %call1 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat6isZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %1)
  br i1 %call1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 -2147483647, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %2 = load ptr, ptr %Arg.addr, align 8
  %call4 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat10isInfinityEv(ptr noundef nonnull align 8 dereferenceable(24) %2)
  br i1 %call4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  store i32 2147483647, ptr %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end3
  %3 = load ptr, ptr %Arg.addr, align 8
  %call7 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat10isDenormalEv(ptr noundef nonnull align 8 dereferenceable(24) %3)
  br i1 %call7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end6
  %4 = load ptr, ptr %Arg.addr, align 8
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %4, i32 0, i32 2
  %5 = load i16, ptr %exponent, align 8
  %conv = sext i16 %5 to i32
  store i32 %conv, ptr %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end6
  %6 = load ptr, ptr %Arg.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloatC1ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %Normalized, ptr noundef nonnull align 8 dereferenceable(24) %6)
  %7 = load ptr, ptr %Arg.addr, align 8
  %call10 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh6detail9IEEEFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(24) %7)
  %precision = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %call10, i32 0, i32 2
  %8 = load i32, ptr %precision, align 4
  %sub = sub i32 %8, 1
  store i32 %sub, ptr %SignificandBits, align 4
  %9 = load i32, ptr %SignificandBits, align 4
  %exponent11 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %Normalized, i32 0, i32 2
  %10 = load i16, ptr %exponent11, align 8
  %conv12 = sext i16 %10 to i32
  %add = add nsw i32 %conv12, %9
  %conv13 = trunc i32 %add to i16
  store i16 %conv13, ptr %exponent11, align 8
  %call14 = call noundef i32 @_ZN4llvh6detail9IEEEFloat9normalizeENS_11APFloatBase12roundingModeENS_12lostFractionE(ptr noundef nonnull align 8 dereferenceable(24) %Normalized, i32 noundef 0, i32 noundef 0)
  %exponent15 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %Normalized, i32 0, i32 2
  %11 = load i16, ptr %exponent15, align 8
  %conv16 = sext i16 %11 to i32
  %12 = load i32, ptr %SignificandBits, align 4
  %sub17 = sub nsw i32 %conv16, %12
  store i32 %sub17, ptr %retval, align 4
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %Normalized) #10
  br label %return

return:                                           ; preds = %if.end9, %if.then8, %if.then5, %if.then2, %if.then
  %13 = load i32, ptr %retval, align 4
  ret i32 %13
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat16fusedMultiplyAddERKS1_S3_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %multiplicand, ptr noundef nonnull align 8 dereferenceable(24) %addend, i32 noundef %rounding_mode) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %multiplicand.addr = alloca ptr, align 8
  %addend.addr = alloca ptr, align 8
  %rounding_mode.addr = alloca i32, align 4
  %fs = alloca i32, align 4
  %lost_fraction = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %multiplicand, ptr %multiplicand.addr, align 8
  store ptr %addend, ptr %addend.addr, align 8
  store i32 %rounding_mode, ptr %rounding_mode.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %multiplicand.addr, align 8
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %0, i32 0, i32 3
  %bf.load = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load, 3
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %sign2 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load3 = load i8, ptr %sign2, align 2
  %bf.lshr4 = lshr i8 %bf.load3, 3
  %bf.clear5 = and i8 %bf.lshr4, 1
  %bf.cast6 = zext i8 %bf.clear5 to i32
  %xor = xor i32 %bf.cast6, %bf.cast
  %1 = trunc i32 %xor to i8
  %bf.load7 = load i8, ptr %sign2, align 2
  %bf.value = and i8 %1, 1
  %bf.shl = shl i8 %bf.value, 3
  %bf.clear8 = and i8 %bf.load7, -9
  %bf.set = or i8 %bf.clear8, %bf.shl
  store i8 %bf.set, ptr %sign2, align 2
  %call = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %2 = load ptr, ptr %multiplicand.addr, align 8
  %call9 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %2)
  br i1 %call9, label %land.lhs.true10, label %if.else

land.lhs.true10:                                  ; preds = %land.lhs.true
  %3 = load ptr, ptr %addend.addr, align 8
  %call11 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat8isFiniteEv(ptr noundef nonnull align 8 dereferenceable(24) %3)
  br i1 %call11, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true10
  %4 = load ptr, ptr %multiplicand.addr, align 8
  %5 = load ptr, ptr %addend.addr, align 8
  %call12 = call noundef i32 @_ZN4llvh6detail9IEEEFloat19multiplySignificandERKS1_PS2_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %4, ptr noundef %5)
  store i32 %call12, ptr %lost_fraction, align 4
  %6 = load i32, ptr %rounding_mode.addr, align 4
  %7 = load i32, ptr %lost_fraction, align 4
  %call13 = call noundef i32 @_ZN4llvh6detail9IEEEFloat9normalizeENS_11APFloatBase12roundingModeENS_12lostFractionE(ptr noundef nonnull align 8 dereferenceable(24) %this1, i32 noundef %6, i32 noundef %7)
  store i32 %call13, ptr %fs, align 4
  %8 = load i32, ptr %lost_fraction, align 4
  %cmp = icmp ne i32 %8, 0
  br i1 %cmp, label %if.then14, label %if.end

if.then14:                                        ; preds = %if.then
  %9 = load i32, ptr %fs, align 4
  %or = or i32 %9, 16
  store i32 %or, ptr %fs, align 4
  br label %if.end

if.end:                                           ; preds = %if.then14, %if.then
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load15 = load i8, ptr %category, align 2
  %bf.clear16 = and i8 %bf.load15, 7
  %bf.cast17 = zext i8 %bf.clear16 to i32
  %cmp18 = icmp eq i32 %bf.cast17, 3
  br i1 %cmp18, label %land.lhs.true19, label %if.end40

land.lhs.true19:                                  ; preds = %if.end
  %10 = load i32, ptr %fs, align 4
  %and = and i32 %10, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end40, label %land.lhs.true20

land.lhs.true20:                                  ; preds = %land.lhs.true19
  %sign21 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load22 = load i8, ptr %sign21, align 2
  %bf.lshr23 = lshr i8 %bf.load22, 3
  %bf.clear24 = and i8 %bf.lshr23, 1
  %bf.cast25 = zext i8 %bf.clear24 to i32
  %11 = load ptr, ptr %addend.addr, align 8
  %sign26 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %11, i32 0, i32 3
  %bf.load27 = load i8, ptr %sign26, align 2
  %bf.lshr28 = lshr i8 %bf.load27, 3
  %bf.clear29 = and i8 %bf.lshr28, 1
  %bf.cast30 = zext i8 %bf.clear29 to i32
  %cmp31 = icmp ne i32 %bf.cast25, %bf.cast30
  br i1 %cmp31, label %if.then32, label %if.end40

if.then32:                                        ; preds = %land.lhs.true20
  %12 = load i32, ptr %rounding_mode.addr, align 4
  %cmp33 = icmp eq i32 %12, 2
  %conv = zext i1 %cmp33 to i32
  %sign34 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %13 = trunc i32 %conv to i8
  %bf.load35 = load i8, ptr %sign34, align 2
  %bf.value36 = and i8 %13, 1
  %bf.shl37 = shl i8 %bf.value36, 3
  %bf.clear38 = and i8 %bf.load35, -9
  %bf.set39 = or i8 %bf.clear38, %bf.shl37
  store i8 %bf.set39, ptr %sign34, align 2
  br label %if.end40

if.end40:                                         ; preds = %if.then32, %land.lhs.true20, %land.lhs.true19, %if.end
  br label %if.end46

if.else:                                          ; preds = %land.lhs.true10, %land.lhs.true, %entry
  %14 = load ptr, ptr %multiplicand.addr, align 8
  %call41 = call noundef i32 @_ZN4llvh6detail9IEEEFloat16multiplySpecialsERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %14)
  store i32 %call41, ptr %fs, align 4
  %15 = load i32, ptr %fs, align 4
  %cmp42 = icmp eq i32 %15, 0
  br i1 %cmp42, label %if.then43, label %if.end45

if.then43:                                        ; preds = %if.else
  %16 = load ptr, ptr %addend.addr, align 8
  %17 = load i32, ptr %rounding_mode.addr, align 4
  %call44 = call noundef i32 @_ZN4llvh6detail9IEEEFloat13addOrSubtractERKS1_NS_11APFloatBase12roundingModeEb(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %16, i32 noundef %17, i1 noundef zeroext false)
  store i32 %call44, ptr %fs, align 4
  br label %if.end45

if.end45:                                         ; preds = %if.then43, %if.else
  br label %if.end46

if.end46:                                         ; preds = %if.end45, %if.end40
  %18 = load i32, ptr %fs, align 4
  ret i32 %18
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZN4llvh12NextPowerOf2Em(i64 noundef %A) #1 comdat {
entry:
  %A.addr = alloca i64, align 8
  store i64 %A, ptr %A.addr, align 8
  %0 = load i64, ptr %A.addr, align 8
  %shr = lshr i64 %0, 1
  %1 = load i64, ptr %A.addr, align 8
  %or = or i64 %1, %shr
  store i64 %or, ptr %A.addr, align 8
  %2 = load i64, ptr %A.addr, align 8
  %shr1 = lshr i64 %2, 2
  %3 = load i64, ptr %A.addr, align 8
  %or2 = or i64 %3, %shr1
  store i64 %or2, ptr %A.addr, align 8
  %4 = load i64, ptr %A.addr, align 8
  %shr3 = lshr i64 %4, 4
  %5 = load i64, ptr %A.addr, align 8
  %or4 = or i64 %5, %shr3
  store i64 %or4, ptr %A.addr, align 8
  %6 = load i64, ptr %A.addr, align 8
  %shr5 = lshr i64 %6, 8
  %7 = load i64, ptr %A.addr, align 8
  %or6 = or i64 %7, %shr5
  store i64 %or6, ptr %A.addr, align 8
  %8 = load i64, ptr %A.addr, align 8
  %shr7 = lshr i64 %8, 16
  %9 = load i64, ptr %A.addr, align 8
  %or8 = or i64 %9, %shr7
  store i64 %or8, ptr %A.addr, align 8
  %10 = load i64, ptr %A.addr, align 8
  %shr9 = lshr i64 %10, 32
  %11 = load i64, ptr %A.addr, align 8
  %or10 = or i64 %11, %shr9
  store i64 %or10, ptr %A.addr, align 8
  %12 = load i64, ptr %A.addr, align 8
  %add = add i64 %12, 1
  ret i64 %add
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh5APIntC2Ejmb(ptr noundef nonnull align 8 dereferenceable(12) %this, i32 noundef %numBits, i64 noundef %val, i1 noundef zeroext %isSigned) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %numBits.addr = alloca i32, align 4
  %val.addr = alloca i64, align 8
  %isSigned.addr = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  store i32 %numBits, ptr %numBits.addr, align 4
  store i64 %val, ptr %val.addr, align 8
  %frombool = zext i1 %isSigned to i8
  store i8 %frombool, ptr %isSigned.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %BitWidth = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %numBits.addr, align 4
  store i32 %0, ptr %BitWidth, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh5APInt12isSingleWordEv(ptr noundef nonnull align 8 dereferenceable(12) %this1)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %val.addr, align 8
  %U2 = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 0
  store i64 %1, ptr %U2, align 8
  %call3 = call noundef nonnull align 8 dereferenceable(12) ptr @_ZN4llvh5APInt15clearUnusedBitsEv(ptr noundef nonnull align 8 dereferenceable(12) %this1)
  br label %if.end

if.else:                                          ; preds = %entry
  %2 = load i64, ptr %val.addr, align 8
  %3 = load i8, ptr %isSigned.addr, align 1
  %tobool = trunc i8 %3 to i1
  call void @_ZN4llvh5APInt12initSlowCaseEmb(ptr noundef nonnull align 8 dereferenceable(12) %this1, i64 noundef %2, i1 noundef zeroext %tobool)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 8 dereferenceable(12) ptr @_ZN4llvh5APIntlSEj(ptr noundef nonnull align 8 dereferenceable(12) %this, i32 noundef %ShiftAmt) #1 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %ShiftAmt.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %ShiftAmt, ptr %ShiftAmt.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh5APInt12isSingleWordEv(ptr noundef nonnull align 8 dereferenceable(12) %this1)
  br i1 %call, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %0 = load i32, ptr %ShiftAmt.addr, align 4
  %BitWidth = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %BitWidth, align 8
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %U = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 0
  store i64 0, ptr %U, align 8
  br label %if.end

if.else:                                          ; preds = %if.then
  %2 = load i32, ptr %ShiftAmt.addr, align 4
  %U3 = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 0
  %3 = load i64, ptr %U3, align 8
  %sh_prom = zext i32 %2 to i64
  %shl = shl i64 %3, %sh_prom
  store i64 %shl, ptr %U3, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then2
  %call4 = call noundef nonnull align 8 dereferenceable(12) ptr @_ZN4llvh5APInt15clearUnusedBitsEv(ptr noundef nonnull align 8 dereferenceable(12) %this1)
  store ptr %call4, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %entry
  %4 = load i32, ptr %ShiftAmt.addr, align 4
  call void @_ZN4llvh5APInt11shlSlowCaseEj(ptr noundef nonnull align 8 dereferenceable(12) %this1, i32 noundef %4)
  store ptr %this1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end5, %if.end
  %5 = load ptr, ptr %retval, align 8
  ret ptr %5
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat16convertFromAPIntERKNS_5APIntEbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(12) %Val, i1 noundef zeroext %isSigned, i32 noundef %rounding_mode) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Val.addr = alloca ptr, align 8
  %isSigned.addr = alloca i8, align 1
  %rounding_mode.addr = alloca i32, align 4
  %partCount = alloca i32, align 4
  %api = alloca %"class.llvh::APInt", align 8
  %ref.tmp = alloca %"class.llvh::APInt", align 8
  %agg.tmp = alloca %"class.llvh::APInt", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %Val, ptr %Val.addr, align 8
  %frombool = zext i1 %isSigned to i8
  store i8 %frombool, ptr %isSigned.addr, align 1
  store i32 %rounding_mode, ptr %rounding_mode.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %Val.addr, align 8
  %call = call noundef i32 @_ZNK4llvh5APInt11getNumWordsEv(ptr noundef nonnull align 8 dereferenceable(12) %0)
  store i32 %call, ptr %partCount, align 4
  %1 = load ptr, ptr %Val.addr, align 8
  call void @_ZN4llvh5APIntC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(12) %api, ptr noundef nonnull align 8 dereferenceable(12) %1)
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %sign, align 2
  %bf.clear = and i8 %bf.load, -9
  %bf.set = or i8 %bf.clear, 0
  store i8 %bf.set, ptr %sign, align 2
  %2 = load i8, ptr %isSigned.addr, align 1
  %tobool = trunc i8 %2 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call2 = call noundef zeroext i1 @_ZNK4llvh5APInt10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(12) %api)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %sign3 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load4 = load i8, ptr %sign3, align 2
  %bf.clear5 = and i8 %bf.load4, -9
  %bf.set6 = or i8 %bf.clear5, 8
  store i8 %bf.set6, ptr %sign3, align 2
  call void @_ZN4llvh5APIntC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(12) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(12) %api)
  call void @_ZN4llvhngENS_5APIntE(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp, ptr noundef %agg.tmp)
  %call7 = call noundef nonnull align 8 dereferenceable(12) ptr @_ZN4llvh5APIntaSEOS0_(ptr noundef nonnull align 8 dereferenceable(12) %api, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %agg.tmp) #10
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %call8 = call noundef ptr @_ZNK4llvh5APInt10getRawDataEv(ptr noundef nonnull align 8 dereferenceable(12) %api)
  %3 = load i32, ptr %partCount, align 4
  %4 = load i32, ptr %rounding_mode.addr, align 4
  %call9 = call noundef i32 @_ZN4llvh6detail9IEEEFloat24convertFromUnsignedPartsEPKmjNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %call8, i32 noundef %3, i32 noundef %4)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %api) #10
  ret i32 %call9
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load, 3
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  ret i1 %tobool
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh5APInt12needsCleanupEv(ptr noundef nonnull align 8 dereferenceable(12) %this1)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %U = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %U, align 8
  %isnull = icmp eq ptr %0, null
  br i1 %isnull, label %delete.end, label %delete.notnull

delete.notnull:                                   ; preds = %if.then
  call void @_ZdaPv(ptr noundef %0) #14
  br label %delete.end

delete.end:                                       ; preds = %delete.notnull, %if.then
  br label %if.end

if.end:                                           ; preds = %delete.end, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZNK4llvh6detail9IEEEFloat28convertToSignExtendedIntegerENS_15MutableArrayRefImEEjbNS_11APFloatBase12roundingModeEPb(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr %parts.coerce0, i64 %parts.coerce1, i32 noundef %width, i1 noundef zeroext %isSigned, i32 noundef %rounding_mode, ptr noundef %isExact) #1 align 2 {
entry:
  %retval = alloca i32, align 4
  %parts = alloca %"class.llvh::MutableArrayRef", align 8
  %this.addr = alloca ptr, align 8
  %width.addr = alloca i32, align 4
  %isSigned.addr = alloca i8, align 1
  %rounding_mode.addr = alloca i32, align 4
  %isExact.addr = alloca ptr, align 8
  %lost_fraction = alloca i32, align 4
  %src = alloca ptr, align 8
  %dstPartsCount = alloca i32, align 4
  %truncatedBits = alloca i32, align 4
  %bits = alloca i32, align 4
  %omsb = alloca i32, align 4
  %0 = getelementptr inbounds { ptr, i64 }, ptr %parts, i32 0, i32 0
  store ptr %parts.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %parts, i32 0, i32 1
  store i64 %parts.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %width, ptr %width.addr, align 4
  %frombool = zext i1 %isSigned to i8
  store i8 %frombool, ptr %isSigned.addr, align 1
  store i32 %rounding_mode, ptr %rounding_mode.addr, align 4
  store ptr %isExact, ptr %isExact.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %2 = load ptr, ptr %isExact.addr, align 8
  store i8 0, ptr %2, align 1
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, 7
  %bf.cast = zext i8 %bf.clear to i32
  %cmp = icmp eq i32 %bf.cast, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %category2 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load3 = load i8, ptr %category2, align 2
  %bf.clear4 = and i8 %bf.load3, 7
  %bf.cast5 = zext i8 %bf.clear4 to i32
  %cmp6 = icmp eq i32 %bf.cast5, 1
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %3 = load i32, ptr %width.addr, align 4
  %call = call noundef i32 @_ZN4llvhL16partCountForBitsEj(i32 noundef %3)
  store i32 %call, ptr %dstPartsCount, align 4
  %category7 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load8 = load i8, ptr %category7, align 2
  %bf.clear9 = and i8 %bf.load8, 7
  %bf.cast10 = zext i8 %bf.clear9 to i32
  %cmp11 = icmp eq i32 %bf.cast10, 3
  br i1 %cmp11, label %if.then12, label %if.end18

if.then12:                                        ; preds = %if.end
  %call13 = call noundef ptr @_ZNK4llvh15MutableArrayRefImE4dataEv(ptr noundef nonnull align 8 dereferenceable(16) %parts)
  %4 = load i32, ptr %dstPartsCount, align 4
  call void @_ZN4llvh5APInt5tcSetEPmmj(ptr noundef %call13, i64 noundef 0, i32 noundef %4)
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load14 = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load14, 3
  %bf.clear15 = and i8 %bf.lshr, 1
  %bf.cast16 = zext i8 %bf.clear15 to i32
  %tobool = icmp ne i32 %bf.cast16, 0
  %lnot = xor i1 %tobool, true
  %5 = load ptr, ptr %isExact.addr, align 8
  %frombool17 = zext i1 %lnot to i8
  store i8 %frombool17, ptr %5, align 1
  store i32 0, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.end
  %call19 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store ptr %call19, ptr %src, align 8
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %6 = load i16, ptr %exponent, align 8
  %conv = sext i16 %6 to i32
  %cmp20 = icmp slt i32 %conv, 0
  br i1 %cmp20, label %if.then21, label %if.else

if.then21:                                        ; preds = %if.end18
  %call22 = call noundef ptr @_ZNK4llvh15MutableArrayRefImE4dataEv(ptr noundef nonnull align 8 dereferenceable(16) %parts)
  %7 = load i32, ptr %dstPartsCount, align 4
  call void @_ZN4llvh5APInt5tcSetEPmmj(ptr noundef %call22, i64 noundef 0, i32 noundef %7)
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %8 = load ptr, ptr %semantics, align 8
  %precision = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %8, i32 0, i32 2
  %9 = load i32, ptr %precision, align 4
  %sub = sub i32 %9, 1
  %exponent23 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %10 = load i16, ptr %exponent23, align 8
  %conv24 = sext i16 %10 to i32
  %sub25 = sub i32 %sub, %conv24
  store i32 %sub25, ptr %truncatedBits, align 4
  br label %if.end48

if.else:                                          ; preds = %if.end18
  %exponent26 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %11 = load i16, ptr %exponent26, align 8
  %conv27 = sext i16 %11 to i32
  %add = add i32 %conv27, 1
  store i32 %add, ptr %bits, align 4
  %12 = load i32, ptr %bits, align 4
  %13 = load i32, ptr %width.addr, align 4
  %cmp28 = icmp ugt i32 %12, %13
  br i1 %cmp28, label %if.then29, label %if.end30

if.then29:                                        ; preds = %if.else
  store i32 1, ptr %retval, align 4
  br label %return

if.end30:                                         ; preds = %if.else
  %14 = load i32, ptr %bits, align 4
  %semantics31 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %15 = load ptr, ptr %semantics31, align 8
  %precision32 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %15, i32 0, i32 2
  %16 = load i32, ptr %precision32, align 4
  %cmp33 = icmp ult i32 %14, %16
  br i1 %cmp33, label %if.then34, label %if.else39

if.then34:                                        ; preds = %if.end30
  %semantics35 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %17 = load ptr, ptr %semantics35, align 8
  %precision36 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %17, i32 0, i32 2
  %18 = load i32, ptr %precision36, align 4
  %19 = load i32, ptr %bits, align 4
  %sub37 = sub i32 %18, %19
  store i32 %sub37, ptr %truncatedBits, align 4
  %call38 = call noundef ptr @_ZNK4llvh15MutableArrayRefImE4dataEv(ptr noundef nonnull align 8 dereferenceable(16) %parts)
  %20 = load i32, ptr %dstPartsCount, align 4
  %21 = load ptr, ptr %src, align 8
  %22 = load i32, ptr %bits, align 4
  %23 = load i32, ptr %truncatedBits, align 4
  call void @_ZN4llvh5APInt9tcExtractEPmjPKmjj(ptr noundef %call38, i32 noundef %20, ptr noundef %21, i32 noundef %22, i32 noundef %23)
  br label %if.end47

if.else39:                                        ; preds = %if.end30
  %call40 = call noundef ptr @_ZNK4llvh15MutableArrayRefImE4dataEv(ptr noundef nonnull align 8 dereferenceable(16) %parts)
  %24 = load i32, ptr %dstPartsCount, align 4
  %25 = load ptr, ptr %src, align 8
  %semantics41 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %26 = load ptr, ptr %semantics41, align 8
  %precision42 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %26, i32 0, i32 2
  %27 = load i32, ptr %precision42, align 4
  call void @_ZN4llvh5APInt9tcExtractEPmjPKmjj(ptr noundef %call40, i32 noundef %24, ptr noundef %25, i32 noundef %27, i32 noundef 0)
  %call43 = call noundef ptr @_ZNK4llvh15MutableArrayRefImE4dataEv(ptr noundef nonnull align 8 dereferenceable(16) %parts)
  %28 = load i32, ptr %dstPartsCount, align 4
  %29 = load i32, ptr %bits, align 4
  %semantics44 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %30 = load ptr, ptr %semantics44, align 8
  %precision45 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %30, i32 0, i32 2
  %31 = load i32, ptr %precision45, align 4
  %sub46 = sub i32 %29, %31
  call void @_ZN4llvh5APInt11tcShiftLeftEPmjj(ptr noundef %call43, i32 noundef %28, i32 noundef %sub46)
  store i32 0, ptr %truncatedBits, align 4
  br label %if.end47

if.end47:                                         ; preds = %if.else39, %if.then34
  br label %if.end48

if.end48:                                         ; preds = %if.end47, %if.then21
  %32 = load i32, ptr %truncatedBits, align 4
  %tobool49 = icmp ne i32 %32, 0
  br i1 %tobool49, label %if.then50, label %if.else62

if.then50:                                        ; preds = %if.end48
  %33 = load ptr, ptr %src, align 8
  %call51 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %34 = load i32, ptr %truncatedBits, align 4
  %call52 = call noundef i32 @_ZN4llvhL29lostFractionThroughTruncationEPKmjj(ptr noundef %33, i32 noundef %call51, i32 noundef %34)
  store i32 %call52, ptr %lost_fraction, align 4
  %35 = load i32, ptr %lost_fraction, align 4
  %cmp53 = icmp ne i32 %35, 0
  br i1 %cmp53, label %land.lhs.true, label %if.end61

land.lhs.true:                                    ; preds = %if.then50
  %36 = load i32, ptr %rounding_mode.addr, align 4
  %37 = load i32, ptr %lost_fraction, align 4
  %38 = load i32, ptr %truncatedBits, align 4
  %call54 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat17roundAwayFromZeroENS_11APFloatBase12roundingModeENS_12lostFractionEj(ptr noundef nonnull align 8 dereferenceable(24) %this1, i32 noundef %36, i32 noundef %37, i32 noundef %38)
  br i1 %call54, label %if.then55, label %if.end61

if.then55:                                        ; preds = %land.lhs.true
  %call56 = call noundef ptr @_ZNK4llvh15MutableArrayRefImE4dataEv(ptr noundef nonnull align 8 dereferenceable(16) %parts)
  %39 = load i32, ptr %dstPartsCount, align 4
  %call57 = call noundef i64 @_ZN4llvh5APInt11tcIncrementEPmj(ptr noundef %call56, i32 noundef %39)
  %tobool58 = icmp ne i64 %call57, 0
  br i1 %tobool58, label %if.then59, label %if.end60

if.then59:                                        ; preds = %if.then55
  store i32 1, ptr %retval, align 4
  br label %return

if.end60:                                         ; preds = %if.then55
  br label %if.end61

if.end61:                                         ; preds = %if.end60, %land.lhs.true, %if.then50
  br label %if.end63

if.else62:                                        ; preds = %if.end48
  store i32 0, ptr %lost_fraction, align 4
  br label %if.end63

if.end63:                                         ; preds = %if.else62, %if.end61
  %call64 = call noundef ptr @_ZNK4llvh15MutableArrayRefImE4dataEv(ptr noundef nonnull align 8 dereferenceable(16) %parts)
  %40 = load i32, ptr %dstPartsCount, align 4
  %call65 = call noundef i32 @_ZN4llvh5APInt5tcMSBEPKmj(ptr noundef %call64, i32 noundef %40)
  %add66 = add i32 %call65, 1
  store i32 %add66, ptr %omsb, align 4
  %sign67 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load68 = load i8, ptr %sign67, align 2
  %bf.lshr69 = lshr i8 %bf.load68, 3
  %bf.clear70 = and i8 %bf.lshr69, 1
  %bf.cast71 = zext i8 %bf.clear70 to i32
  %tobool72 = icmp ne i32 %bf.cast71, 0
  br i1 %tobool72, label %if.then73, label %if.else93

if.then73:                                        ; preds = %if.end63
  %41 = load i8, ptr %isSigned.addr, align 1
  %tobool74 = trunc i8 %41 to i1
  br i1 %tobool74, label %if.else79, label %if.then75

if.then75:                                        ; preds = %if.then73
  %42 = load i32, ptr %omsb, align 4
  %cmp76 = icmp ne i32 %42, 0
  br i1 %cmp76, label %if.then77, label %if.end78

if.then77:                                        ; preds = %if.then75
  store i32 1, ptr %retval, align 4
  br label %return

if.end78:                                         ; preds = %if.then75
  br label %if.end91

if.else79:                                        ; preds = %if.then73
  %43 = load i32, ptr %omsb, align 4
  %44 = load i32, ptr %width.addr, align 4
  %cmp80 = icmp eq i32 %43, %44
  br i1 %cmp80, label %land.lhs.true81, label %if.end87

land.lhs.true81:                                  ; preds = %if.else79
  %call82 = call noundef ptr @_ZNK4llvh15MutableArrayRefImE4dataEv(ptr noundef nonnull align 8 dereferenceable(16) %parts)
  %45 = load i32, ptr %dstPartsCount, align 4
  %call83 = call noundef i32 @_ZN4llvh5APInt5tcLSBEPKmj(ptr noundef %call82, i32 noundef %45)
  %add84 = add i32 %call83, 1
  %46 = load i32, ptr %omsb, align 4
  %cmp85 = icmp ne i32 %add84, %46
  br i1 %cmp85, label %if.then86, label %if.end87

if.then86:                                        ; preds = %land.lhs.true81
  store i32 1, ptr %retval, align 4
  br label %return

if.end87:                                         ; preds = %land.lhs.true81, %if.else79
  %47 = load i32, ptr %omsb, align 4
  %48 = load i32, ptr %width.addr, align 4
  %cmp88 = icmp ugt i32 %47, %48
  br i1 %cmp88, label %if.then89, label %if.end90

if.then89:                                        ; preds = %if.end87
  store i32 1, ptr %retval, align 4
  br label %return

if.end90:                                         ; preds = %if.end87
  br label %if.end91

if.end91:                                         ; preds = %if.end90, %if.end78
  %call92 = call noundef ptr @_ZNK4llvh15MutableArrayRefImE4dataEv(ptr noundef nonnull align 8 dereferenceable(16) %parts)
  %49 = load i32, ptr %dstPartsCount, align 4
  call void @_ZN4llvh5APInt8tcNegateEPmj(ptr noundef %call92, i32 noundef %49)
  br label %if.end101

if.else93:                                        ; preds = %if.end63
  %50 = load i32, ptr %omsb, align 4
  %51 = load i32, ptr %width.addr, align 4
  %52 = load i8, ptr %isSigned.addr, align 1
  %tobool94 = trunc i8 %52 to i1
  %lnot95 = xor i1 %tobool94, true
  %conv96 = zext i1 %lnot95 to i32
  %add97 = add i32 %51, %conv96
  %cmp98 = icmp uge i32 %50, %add97
  br i1 %cmp98, label %if.then99, label %if.end100

if.then99:                                        ; preds = %if.else93
  store i32 1, ptr %retval, align 4
  br label %return

if.end100:                                        ; preds = %if.else93
  br label %if.end101

if.end101:                                        ; preds = %if.end100, %if.end91
  %53 = load i32, ptr %lost_fraction, align 4
  %cmp102 = icmp eq i32 %53, 0
  br i1 %cmp102, label %if.then103, label %if.else104

if.then103:                                       ; preds = %if.end101
  %54 = load ptr, ptr %isExact.addr, align 8
  store i8 1, ptr %54, align 1
  store i32 0, ptr %retval, align 4
  br label %return

if.else104:                                       ; preds = %if.end101
  store i32 16, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else104, %if.then103, %if.then99, %if.then89, %if.then86, %if.then77, %if.then59, %if.then29, %if.then12, %if.then
  %55 = load i32, ptr %retval, align 4
  ret i32 %55
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef ptr @_ZNK4llvh15MutableArrayRefImE4dataEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZNK4llvh8ArrayRefImE4dataEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  ret ptr %call
}

declare void @_ZN4llvh5APInt9tcExtractEPmjPKmjj(ptr noundef, i32 noundef, ptr noundef, i32 noundef, i32 noundef) #5

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZN4llvhL29lostFractionThroughTruncationEPKmjj(ptr noundef %parts, i32 noundef %partCount, i32 noundef %bits) #1 {
entry:
  %retval = alloca i32, align 4
  %parts.addr = alloca ptr, align 8
  %partCount.addr = alloca i32, align 4
  %bits.addr = alloca i32, align 4
  %lsb = alloca i32, align 4
  store ptr %parts, ptr %parts.addr, align 8
  store i32 %partCount, ptr %partCount.addr, align 4
  store i32 %bits, ptr %bits.addr, align 4
  %0 = load ptr, ptr %parts.addr, align 8
  %1 = load i32, ptr %partCount.addr, align 4
  %call = call noundef i32 @_ZN4llvh5APInt5tcLSBEPKmj(ptr noundef %0, i32 noundef %1)
  store i32 %call, ptr %lsb, align 4
  %2 = load i32, ptr %bits.addr, align 4
  %3 = load i32, ptr %lsb, align 4
  %cmp = icmp ule i32 %2, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load i32, ptr %bits.addr, align 4
  %5 = load i32, ptr %lsb, align 4
  %add = add i32 %5, 1
  %cmp1 = icmp eq i32 %4, %add
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 2, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %6 = load i32, ptr %bits.addr, align 4
  %7 = load i32, ptr %partCount.addr, align 4
  %mul = mul i32 %7, 64
  %cmp4 = icmp ule i32 %6, %mul
  br i1 %cmp4, label %land.lhs.true, label %if.end7

land.lhs.true:                                    ; preds = %if.end3
  %8 = load ptr, ptr %parts.addr, align 8
  %9 = load i32, ptr %bits.addr, align 4
  %sub = sub i32 %9, 1
  %call5 = call noundef i32 @_ZN4llvh5APInt12tcExtractBitEPKmj(ptr noundef %8, i32 noundef %sub)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %if.then6, label %if.end7

if.then6:                                         ; preds = %land.lhs.true
  store i32 3, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %if.end3
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then6, %if.then2, %if.then
  %10 = load i32, ptr %retval, align 4
  ret i32 %10
}

declare void @_ZN4llvh5APInt8tcNegateEPmj(ptr noundef, i32 noundef) #5

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat24convertFromUnsignedPartsEPKmjNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %src, i32 noundef %srcCount, i32 noundef %rounding_mode) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %src.addr = alloca ptr, align 8
  %srcCount.addr = alloca i32, align 4
  %rounding_mode.addr = alloca i32, align 4
  %omsb = alloca i32, align 4
  %precision = alloca i32, align 4
  %dstCount = alloca i32, align 4
  %dst = alloca ptr, align 8
  %lost_fraction = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %src, ptr %src.addr, align 8
  store i32 %srcCount, ptr %srcCount.addr, align 4
  store i32 %rounding_mode, ptr %rounding_mode.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, -8
  %bf.set = or i8 %bf.clear, 2
  store i8 %bf.set, ptr %category, align 2
  %0 = load ptr, ptr %src.addr, align 8
  %1 = load i32, ptr %srcCount.addr, align 4
  %call = call noundef i32 @_ZN4llvh5APInt5tcMSBEPKmj(ptr noundef %0, i32 noundef %1)
  %add = add i32 %call, 1
  store i32 %add, ptr %omsb, align 4
  %call2 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store ptr %call2, ptr %dst, align 8
  %call3 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store i32 %call3, ptr %dstCount, align 4
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %semantics, align 8
  %precision4 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %2, i32 0, i32 2
  %3 = load i32, ptr %precision4, align 4
  store i32 %3, ptr %precision, align 4
  %4 = load i32, ptr %precision, align 4
  %5 = load i32, ptr %omsb, align 4
  %cmp = icmp ule i32 %4, %5
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %6 = load i32, ptr %omsb, align 4
  %sub = sub i32 %6, 1
  %conv = trunc i32 %sub to i16
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 %conv, ptr %exponent, align 8
  %7 = load ptr, ptr %src.addr, align 8
  %8 = load i32, ptr %srcCount.addr, align 4
  %9 = load i32, ptr %omsb, align 4
  %10 = load i32, ptr %precision, align 4
  %sub5 = sub i32 %9, %10
  %call6 = call noundef i32 @_ZN4llvhL29lostFractionThroughTruncationEPKmjj(ptr noundef %7, i32 noundef %8, i32 noundef %sub5)
  store i32 %call6, ptr %lost_fraction, align 4
  %11 = load ptr, ptr %dst, align 8
  %12 = load i32, ptr %dstCount, align 4
  %13 = load ptr, ptr %src.addr, align 8
  %14 = load i32, ptr %precision, align 4
  %15 = load i32, ptr %omsb, align 4
  %16 = load i32, ptr %precision, align 4
  %sub7 = sub i32 %15, %16
  call void @_ZN4llvh5APInt9tcExtractEPmjPKmjj(ptr noundef %11, i32 noundef %12, ptr noundef %13, i32 noundef %14, i32 noundef %sub7)
  br label %if.end

if.else:                                          ; preds = %entry
  %17 = load i32, ptr %precision, align 4
  %sub8 = sub i32 %17, 1
  %conv9 = trunc i32 %sub8 to i16
  %exponent10 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 %conv9, ptr %exponent10, align 8
  store i32 0, ptr %lost_fraction, align 4
  %18 = load ptr, ptr %dst, align 8
  %19 = load i32, ptr %dstCount, align 4
  %20 = load ptr, ptr %src.addr, align 8
  %21 = load i32, ptr %omsb, align 4
  call void @_ZN4llvh5APInt9tcExtractEPmjPKmjj(ptr noundef %18, i32 noundef %19, ptr noundef %20, i32 noundef %21, i32 noundef 0)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %22 = load i32, ptr %rounding_mode.addr, align 4
  %23 = load i32, ptr %lost_fraction, align 4
  %call11 = call noundef i32 @_ZN4llvh6detail9IEEEFloat9normalizeENS_11APFloatBase12roundingModeENS_12lostFractionE(ptr noundef nonnull align 8 dereferenceable(24) %this1, i32 noundef %22, i32 noundef %23)
  ret i32 %call11
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh5APIntC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(12) %this, ptr noundef nonnull align 8 dereferenceable(12) %that) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %that.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %that, ptr %that.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %BitWidth = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %that.addr, align 8
  %BitWidth2 = getelementptr inbounds %"class.llvh::APInt", ptr %0, i32 0, i32 1
  %1 = load i32, ptr %BitWidth2, align 8
  store i32 %1, ptr %BitWidth, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh5APInt12isSingleWordEv(ptr noundef nonnull align 8 dereferenceable(12) %this1)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %that.addr, align 8
  %U3 = getelementptr inbounds %"class.llvh::APInt", ptr %2, i32 0, i32 0
  %3 = load i64, ptr %U3, align 8
  %U4 = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 0
  store i64 %3, ptr %U4, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %4 = load ptr, ptr %that.addr, align 8
  call void @_ZN4llvh5APInt12initSlowCaseERKS0_(ptr noundef nonnull align 8 dereferenceable(12) %this1, ptr noundef nonnull align 8 dereferenceable(12) %4)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh5APInt10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(12) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %BitWidth = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %BitWidth, align 8
  %sub = sub i32 %0, 1
  %call = call noundef zeroext i1 @_ZNK4llvh5APIntixEj(ptr noundef nonnull align 8 dereferenceable(12) %this1, i32 noundef %sub)
  ret i1 %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvhngENS_5APIntE(ptr noalias sret(%"class.llvh::APInt") align 8 %agg.result, ptr noundef %v) #1 comdat {
entry:
  %result.ptr = alloca ptr, align 8
  %v.indirect_addr = alloca ptr, align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %v, ptr %v.indirect_addr, align 8
  call void @_ZN4llvh5APInt6negateEv(ptr noundef nonnull align 8 dereferenceable(12) %v)
  call void @_ZN4llvh5APIntC2EOS0_(ptr noundef nonnull align 8 dereferenceable(12) %agg.result, ptr noundef nonnull align 8 dereferenceable(12) %v)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 8 dereferenceable(12) ptr @_ZN4llvh5APIntaSEOS0_(ptr noundef nonnull align 8 dereferenceable(12) %this, ptr noundef nonnull align 8 dereferenceable(12) %that) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %that.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %that, ptr %that.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh5APInt12isSingleWordEv(ptr noundef nonnull align 8 dereferenceable(12) %this1)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %U = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %U, align 8
  %isnull = icmp eq ptr %0, null
  br i1 %isnull, label %delete.end, label %delete.notnull

delete.notnull:                                   ; preds = %if.then
  call void @_ZdaPv(ptr noundef %0) #14
  br label %delete.end

delete.end:                                       ; preds = %delete.notnull, %if.then
  br label %if.end

if.end:                                           ; preds = %delete.end, %entry
  %U2 = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %that.addr, align 8
  %U3 = getelementptr inbounds %"class.llvh::APInt", ptr %1, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %U2, ptr align 8 %U3, i64 8, i1 false)
  %2 = load ptr, ptr %that.addr, align 8
  %BitWidth = getelementptr inbounds %"class.llvh::APInt", ptr %2, i32 0, i32 1
  %3 = load i32, ptr %BitWidth, align 8
  %BitWidth4 = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 1
  store i32 %3, ptr %BitWidth4, align 8
  %4 = load ptr, ptr %that.addr, align 8
  %BitWidth5 = getelementptr inbounds %"class.llvh::APInt", ptr %4, i32 0, i32 1
  store i32 0, ptr %BitWidth5, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat30convertFromSignExtendedIntegerEPKmjbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %src, i32 noundef %srcCount, i1 noundef zeroext %isSigned, i32 noundef %rounding_mode) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %src.addr = alloca ptr, align 8
  %srcCount.addr = alloca i32, align 4
  %isSigned.addr = alloca i8, align 1
  %rounding_mode.addr = alloca i32, align 4
  %status = alloca i32, align 4
  %copy = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %src, ptr %src.addr, align 8
  store i32 %srcCount, ptr %srcCount.addr, align 4
  %frombool = zext i1 %isSigned to i8
  store i8 %frombool, ptr %isSigned.addr, align 1
  store i32 %rounding_mode, ptr %rounding_mode.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i8, ptr %isSigned.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %src.addr, align 8
  %2 = load i32, ptr %srcCount.addr, align 4
  %mul = mul i32 %2, 64
  %sub = sub i32 %mul, 1
  %call = call noundef i32 @_ZN4llvh5APInt12tcExtractBitEPKmj(ptr noundef %1, i32 noundef %sub)
  %tobool2 = icmp ne i32 %call, 0
  br i1 %tobool2, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %sign, align 2
  %bf.clear = and i8 %bf.load, -9
  %bf.set = or i8 %bf.clear, 8
  store i8 %bf.set, ptr %sign, align 2
  %3 = load i32, ptr %srcCount.addr, align 4
  %conv = zext i32 %3 to i64
  %4 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %conv, i64 8)
  %5 = extractvalue { i64, i1 } %4, 1
  %6 = extractvalue { i64, i1 } %4, 0
  %7 = select i1 %5, i64 -1, i64 %6
  %call3 = call noalias noundef nonnull ptr @_Znam(i64 noundef %7) #13
  store ptr %call3, ptr %copy, align 8
  %8 = load ptr, ptr %copy, align 8
  %9 = load ptr, ptr %src.addr, align 8
  %10 = load i32, ptr %srcCount.addr, align 4
  call void @_ZN4llvh5APInt8tcAssignEPmPKmj(ptr noundef %8, ptr noundef %9, i32 noundef %10)
  %11 = load ptr, ptr %copy, align 8
  %12 = load i32, ptr %srcCount.addr, align 4
  call void @_ZN4llvh5APInt8tcNegateEPmj(ptr noundef %11, i32 noundef %12)
  %13 = load ptr, ptr %copy, align 8
  %14 = load i32, ptr %srcCount.addr, align 4
  %15 = load i32, ptr %rounding_mode.addr, align 4
  %call4 = call noundef i32 @_ZN4llvh6detail9IEEEFloat24convertFromUnsignedPartsEPKmjNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %13, i32 noundef %14, i32 noundef %15)
  store i32 %call4, ptr %status, align 4
  %16 = load ptr, ptr %copy, align 8
  %isnull = icmp eq ptr %16, null
  br i1 %isnull, label %delete.end, label %delete.notnull

delete.notnull:                                   ; preds = %if.then
  call void @_ZdaPv(ptr noundef %16) #14
  br label %delete.end

delete.end:                                       ; preds = %delete.notnull, %if.then
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  %sign5 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load6 = load i8, ptr %sign5, align 2
  %bf.clear7 = and i8 %bf.load6, -9
  %bf.set8 = or i8 %bf.clear7, 0
  store i8 %bf.set8, ptr %sign5, align 2
  %17 = load ptr, ptr %src.addr, align 8
  %18 = load i32, ptr %srcCount.addr, align 4
  %19 = load i32, ptr %rounding_mode.addr, align 4
  %call9 = call noundef i32 @_ZN4llvh6detail9IEEEFloat24convertFromUnsignedPartsEPKmjNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %17, i32 noundef %18, i32 noundef %19)
  store i32 %call9, ptr %status, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %delete.end
  %20 = load i32, ptr %status, align 4
  ret i32 %20
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden { ptr, i64 } @_ZN4llvh12makeArrayRefImEENS_8ArrayRefIT_EEPKS2_m(ptr noundef %data, i64 noundef %length) #1 comdat {
entry:
  %retval = alloca %"class.llvh::ArrayRef", align 8
  %data.addr = alloca ptr, align 8
  %length.addr = alloca i64, align 8
  store ptr %data, ptr %data.addr, align 8
  store i64 %length, ptr %length.addr, align 8
  %0 = load ptr, ptr %data.addr, align 8
  %1 = load i64, ptr %length.addr, align 8
  call void @_ZN4llvh8ArrayRefImEC2EPKmm(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef %0, i64 noundef %1)
  %2 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %2
}

declare void @_ZN4llvh5APIntC1EjNS_8ArrayRefImEE(ptr noundef nonnull align 8 dereferenceable(12), i32 noundef, ptr, i64) unnamed_addr #5

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat28convertFromHexadecimalStringENS_9StringRefENS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr %s.coerce0, i64 %s.coerce1, i32 noundef %rounding_mode) #1 align 2 {
entry:
  %s = alloca %"class.llvh::StringRef", align 8
  %this.addr = alloca ptr, align 8
  %rounding_mode.addr = alloca i32, align 4
  %lost_fraction = alloca i32, align 4
  %significand = alloca ptr, align 8
  %partsCount = alloca i32, align 4
  %bitPos = alloca i32, align 4
  %computedTrailingFraction = alloca i8, align 1
  %begin = alloca ptr, align 8
  %end = alloca ptr, align 8
  %dot = alloca ptr, align 8
  %p = alloca ptr, align 8
  %firstSignificantDigit = alloca ptr, align 8
  %hex_value = alloca i64, align 8
  %expAdjustment = alloca i32, align 4
  %0 = getelementptr inbounds { ptr, i64 }, ptr %s, i32 0, i32 0
  store ptr %s.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %s, i32 0, i32 1
  store i64 %s.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %rounding_mode, ptr %rounding_mode.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  store i32 0, ptr %lost_fraction, align 4
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, -8
  %bf.set = or i8 %bf.clear, 2
  store i8 %bf.set, ptr %category, align 2
  call void @_ZN4llvh6detail9IEEEFloat15zeroSignificandEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 0, ptr %exponent, align 8
  %call = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store ptr %call, ptr %significand, align 8
  %call2 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store i32 %call2, ptr %partsCount, align 4
  %2 = load i32, ptr %partsCount, align 4
  %mul = mul i32 %2, 64
  store i32 %mul, ptr %bitPos, align 4
  store i8 0, ptr %computedTrailingFraction, align 1
  %call3 = call noundef ptr @_ZNK4llvh9StringRef5beginEv(ptr noundef nonnull align 8 dereferenceable(16) %s)
  store ptr %call3, ptr %begin, align 8
  %call4 = call noundef ptr @_ZNK4llvh9StringRef3endEv(ptr noundef nonnull align 8 dereferenceable(16) %s)
  store ptr %call4, ptr %end, align 8
  %3 = load ptr, ptr %begin, align 8
  %4 = load ptr, ptr %end, align 8
  %call5 = call noundef ptr @_ZN4llvhL26skipLeadingZeroesAndAnyDotEPKcS1_PS1_(ptr noundef %3, ptr noundef %4, ptr noundef %dot)
  store ptr %call5, ptr %p, align 8
  %5 = load ptr, ptr %p, align 8
  store ptr %5, ptr %firstSignificantDigit, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end19, %if.then, %entry
  %6 = load ptr, ptr %p, align 8
  %7 = load ptr, ptr %end, align 8
  %cmp = icmp ne ptr %6, %7
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %8 = load ptr, ptr %p, align 8
  %9 = load i8, ptr %8, align 1
  %conv = sext i8 %9 to i32
  %cmp6 = icmp eq i32 %conv, 46
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %10 = load ptr, ptr %p, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %10, i32 1
  store ptr %incdec.ptr, ptr %p, align 8
  store ptr %10, ptr %dot, align 8
  br label %while.cond, !llvm.loop !11

if.end:                                           ; preds = %while.body
  %11 = load ptr, ptr %p, align 8
  %12 = load i8, ptr %11, align 1
  %call7 = call noundef i32 @_ZN4llvh13hexDigitValueEc(i8 noundef signext %12)
  %conv8 = zext i32 %call7 to i64
  store i64 %conv8, ptr %hex_value, align 8
  %13 = load i64, ptr %hex_value, align 8
  %cmp9 = icmp eq i64 %13, 4294967295
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end
  br label %while.end

if.end11:                                         ; preds = %if.end
  %14 = load ptr, ptr %p, align 8
  %incdec.ptr12 = getelementptr inbounds i8, ptr %14, i32 1
  store ptr %incdec.ptr12, ptr %p, align 8
  %15 = load i32, ptr %bitPos, align 4
  %tobool = icmp ne i32 %15, 0
  br i1 %tobool, label %if.then13, label %if.else

if.then13:                                        ; preds = %if.end11
  %16 = load i32, ptr %bitPos, align 4
  %sub = sub i32 %16, 4
  store i32 %sub, ptr %bitPos, align 4
  %17 = load i32, ptr %bitPos, align 4
  %rem = urem i32 %17, 64
  %18 = load i64, ptr %hex_value, align 8
  %sh_prom = zext i32 %rem to i64
  %shl = shl i64 %18, %sh_prom
  store i64 %shl, ptr %hex_value, align 8
  %19 = load i64, ptr %hex_value, align 8
  %20 = load ptr, ptr %significand, align 8
  %21 = load i32, ptr %bitPos, align 4
  %div = udiv i32 %21, 64
  %idxprom = zext i32 %div to i64
  %arrayidx = getelementptr inbounds i64, ptr %20, i64 %idxprom
  %22 = load i64, ptr %arrayidx, align 8
  %or = or i64 %22, %19
  store i64 %or, ptr %arrayidx, align 8
  br label %if.end19

if.else:                                          ; preds = %if.end11
  %23 = load i8, ptr %computedTrailingFraction, align 1
  %tobool14 = trunc i8 %23 to i1
  br i1 %tobool14, label %if.end18, label %if.then15

if.then15:                                        ; preds = %if.else
  %24 = load ptr, ptr %p, align 8
  %25 = load ptr, ptr %end, align 8
  %26 = load i64, ptr %hex_value, align 8
  %conv16 = trunc i64 %26 to i32
  %call17 = call noundef i32 @_ZN4llvhL27trailingHexadecimalFractionEPKcS1_j(ptr noundef %24, ptr noundef %25, i32 noundef %conv16)
  store i32 %call17, ptr %lost_fraction, align 4
  store i8 1, ptr %computedTrailingFraction, align 1
  br label %if.end18

if.end18:                                         ; preds = %if.then15, %if.else
  br label %if.end19

if.end19:                                         ; preds = %if.end18, %if.then13
  br label %while.cond, !llvm.loop !11

while.end:                                        ; preds = %if.then10, %while.cond
  %27 = load ptr, ptr %p, align 8
  %28 = load ptr, ptr %firstSignificantDigit, align 8
  %cmp20 = icmp ne ptr %27, %28
  br i1 %cmp20, label %if.then21, label %if.end36

if.then21:                                        ; preds = %while.end
  %29 = load ptr, ptr %dot, align 8
  %30 = load ptr, ptr %end, align 8
  %cmp22 = icmp eq ptr %29, %30
  br i1 %cmp22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.then21
  %31 = load ptr, ptr %p, align 8
  store ptr %31, ptr %dot, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.then23, %if.then21
  %32 = load ptr, ptr %dot, align 8
  %33 = load ptr, ptr %firstSignificantDigit, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %32 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %33 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv25 = trunc i64 %sub.ptr.sub to i32
  store i32 %conv25, ptr %expAdjustment, align 4
  %34 = load i32, ptr %expAdjustment, align 4
  %cmp26 = icmp slt i32 %34, 0
  br i1 %cmp26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end24
  %35 = load i32, ptr %expAdjustment, align 4
  %inc = add nsw i32 %35, 1
  store i32 %inc, ptr %expAdjustment, align 4
  br label %if.end28

if.end28:                                         ; preds = %if.then27, %if.end24
  %36 = load i32, ptr %expAdjustment, align 4
  %mul29 = mul nsw i32 %36, 4
  %sub30 = sub nsw i32 %mul29, 1
  store i32 %sub30, ptr %expAdjustment, align 4
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %37 = load ptr, ptr %semantics, align 8
  %precision = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %37, i32 0, i32 2
  %38 = load i32, ptr %precision, align 4
  %39 = load i32, ptr %expAdjustment, align 4
  %add = add i32 %39, %38
  store i32 %add, ptr %expAdjustment, align 4
  %40 = load i32, ptr %partsCount, align 4
  %mul31 = mul i32 %40, 64
  %41 = load i32, ptr %expAdjustment, align 4
  %sub32 = sub i32 %41, %mul31
  store i32 %sub32, ptr %expAdjustment, align 4
  %42 = load ptr, ptr %p, align 8
  %add.ptr = getelementptr inbounds i8, ptr %42, i64 1
  %43 = load ptr, ptr %end, align 8
  %44 = load i32, ptr %expAdjustment, align 4
  %call33 = call noundef i32 @_ZN4llvhL13totalExponentEPKcS1_i(ptr noundef %add.ptr, ptr noundef %43, i32 noundef %44)
  %conv34 = trunc i32 %call33 to i16
  %exponent35 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 %conv34, ptr %exponent35, align 8
  br label %if.end36

if.end36:                                         ; preds = %if.end28, %while.end
  %45 = load i32, ptr %rounding_mode.addr, align 4
  %46 = load i32, ptr %lost_fraction, align 4
  %call37 = call noundef i32 @_ZN4llvh6detail9IEEEFloat9normalizeENS_11APFloatBase12roundingModeENS_12lostFractionE(ptr noundef nonnull align 8 dereferenceable(24) %this1, i32 noundef %45, i32 noundef %46)
  ret i32 %call37
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef ptr @_ZNK4llvh9StringRef5beginEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %"class.llvh::StringRef", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %Data, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef ptr @_ZNK4llvh9StringRef3endEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %"class.llvh::StringRef", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %Data, align 8
  %Length = getelementptr inbounds %"class.llvh::StringRef", ptr %this1, i32 0, i32 1
  %1 = load i64, ptr %Length, align 8
  %add.ptr = getelementptr inbounds i8, ptr %0, i64 %1
  ret ptr %add.ptr
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef ptr @_ZN4llvhL26skipLeadingZeroesAndAnyDotEPKcS1_PS1_(ptr noundef %begin, ptr noundef %end, ptr noundef %dot) #1 {
entry:
  %begin.addr = alloca ptr, align 8
  %end.addr = alloca ptr, align 8
  %dot.addr = alloca ptr, align 8
  %p = alloca ptr, align 8
  store ptr %begin, ptr %begin.addr, align 8
  store ptr %end, ptr %end.addr, align 8
  store ptr %dot, ptr %dot.addr, align 8
  %0 = load ptr, ptr %begin.addr, align 8
  store ptr %0, ptr %p, align 8
  %1 = load ptr, ptr %end.addr, align 8
  %2 = load ptr, ptr %dot.addr, align 8
  store ptr %1, ptr %2, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %3 = load ptr, ptr %p, align 8
  %4 = load ptr, ptr %end.addr, align 8
  %cmp = icmp ne ptr %3, %4
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %5 = load ptr, ptr %p, align 8
  %6 = load i8, ptr %5, align 1
  %conv = sext i8 %6 to i32
  %cmp1 = icmp eq i32 %conv, 48
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %7 = phi i1 [ false, %while.cond ], [ %cmp1, %land.rhs ]
  br i1 %7, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %8 = load ptr, ptr %p, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %8, i32 1
  store ptr %incdec.ptr, ptr %p, align 8
  br label %while.cond, !llvm.loop !12

while.end:                                        ; preds = %land.end
  %9 = load ptr, ptr %p, align 8
  %10 = load ptr, ptr %end.addr, align 8
  %cmp2 = icmp ne ptr %9, %10
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %while.end
  %11 = load ptr, ptr %p, align 8
  %12 = load i8, ptr %11, align 1
  %conv3 = sext i8 %12 to i32
  %cmp4 = icmp eq i32 %conv3, 46
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %13 = load ptr, ptr %p, align 8
  %incdec.ptr5 = getelementptr inbounds i8, ptr %13, i32 1
  store ptr %incdec.ptr5, ptr %p, align 8
  %14 = load ptr, ptr %dot.addr, align 8
  store ptr %13, ptr %14, align 8
  br label %while.cond6

while.cond6:                                      ; preds = %while.body12, %if.then
  %15 = load ptr, ptr %p, align 8
  %16 = load ptr, ptr %end.addr, align 8
  %cmp7 = icmp ne ptr %15, %16
  br i1 %cmp7, label %land.rhs8, label %land.end11

land.rhs8:                                        ; preds = %while.cond6
  %17 = load ptr, ptr %p, align 8
  %18 = load i8, ptr %17, align 1
  %conv9 = sext i8 %18 to i32
  %cmp10 = icmp eq i32 %conv9, 48
  br label %land.end11

land.end11:                                       ; preds = %land.rhs8, %while.cond6
  %19 = phi i1 [ false, %while.cond6 ], [ %cmp10, %land.rhs8 ]
  br i1 %19, label %while.body12, label %while.end14

while.body12:                                     ; preds = %land.end11
  %20 = load ptr, ptr %p, align 8
  %incdec.ptr13 = getelementptr inbounds i8, ptr %20, i32 1
  store ptr %incdec.ptr13, ptr %p, align 8
  br label %while.cond6, !llvm.loop !13

while.end14:                                      ; preds = %land.end11
  br label %if.end

if.end:                                           ; preds = %while.end14, %land.lhs.true, %while.end
  %21 = load ptr, ptr %p, align 8
  ret ptr %21
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZN4llvh13hexDigitValueEc(i8 noundef signext %C) #1 comdat {
entry:
  %retval = alloca i32, align 4
  %C.addr = alloca i8, align 1
  store i8 %C, ptr %C.addr, align 1
  %0 = load i8, ptr %C.addr, align 1
  %conv = sext i8 %0 to i32
  %cmp = icmp sge i32 %conv, 48
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i8, ptr %C.addr, align 1
  %conv1 = sext i8 %1 to i32
  %cmp2 = icmp sle i32 %conv1, 57
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %2 = load i8, ptr %C.addr, align 1
  %conv3 = sext i8 %2 to i32
  %sub = sub nsw i32 %conv3, 48
  store i32 %sub, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %3 = load i8, ptr %C.addr, align 1
  %conv4 = sext i8 %3 to i32
  %cmp5 = icmp sge i32 %conv4, 97
  br i1 %cmp5, label %land.lhs.true6, label %if.end12

land.lhs.true6:                                   ; preds = %if.end
  %4 = load i8, ptr %C.addr, align 1
  %conv7 = sext i8 %4 to i32
  %cmp8 = icmp sle i32 %conv7, 102
  br i1 %cmp8, label %if.then9, label %if.end12

if.then9:                                         ; preds = %land.lhs.true6
  %5 = load i8, ptr %C.addr, align 1
  %conv10 = sext i8 %5 to i32
  %sub11 = sub nsw i32 %conv10, 97
  %add = add i32 %sub11, 10
  store i32 %add, ptr %retval, align 4
  br label %return

if.end12:                                         ; preds = %land.lhs.true6, %if.end
  %6 = load i8, ptr %C.addr, align 1
  %conv13 = sext i8 %6 to i32
  %cmp14 = icmp sge i32 %conv13, 65
  br i1 %cmp14, label %land.lhs.true15, label %if.end22

land.lhs.true15:                                  ; preds = %if.end12
  %7 = load i8, ptr %C.addr, align 1
  %conv16 = sext i8 %7 to i32
  %cmp17 = icmp sle i32 %conv16, 70
  br i1 %cmp17, label %if.then18, label %if.end22

if.then18:                                        ; preds = %land.lhs.true15
  %8 = load i8, ptr %C.addr, align 1
  %conv19 = sext i8 %8 to i32
  %sub20 = sub nsw i32 %conv19, 65
  %add21 = add i32 %sub20, 10
  store i32 %add21, ptr %retval, align 4
  br label %return

if.end22:                                         ; preds = %land.lhs.true15, %if.end12
  store i32 -1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end22, %if.then18, %if.then9, %if.then
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZN4llvhL27trailingHexadecimalFractionEPKcS1_j(ptr noundef %p, ptr noundef %end, i32 noundef %digitValue) #1 {
entry:
  %retval = alloca i32, align 4
  %p.addr = alloca ptr, align 8
  %end.addr = alloca ptr, align 8
  %digitValue.addr = alloca i32, align 4
  %hexDigit = alloca i32, align 4
  store ptr %p, ptr %p.addr, align 8
  store ptr %end, ptr %end.addr, align 8
  store i32 %digitValue, ptr %digitValue.addr, align 4
  %0 = load i32, ptr %digitValue.addr, align 4
  %cmp = icmp ugt i32 %0, 8
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 3, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %1 = load i32, ptr %digitValue.addr, align 4
  %cmp1 = icmp ult i32 %1, 8
  br i1 %cmp1, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %2 = load i32, ptr %digitValue.addr, align 4
  %cmp2 = icmp ugt i32 %2, 0
  br i1 %cmp2, label %if.then3, label %if.end

if.then3:                                         ; preds = %land.lhs.true
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %if.else
  br label %if.end4

if.end4:                                          ; preds = %if.end
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end4
  %3 = load ptr, ptr %p.addr, align 8
  %4 = load ptr, ptr %end.addr, align 8
  %cmp5 = icmp ne ptr %3, %4
  br i1 %cmp5, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %5 = load ptr, ptr %p.addr, align 8
  %6 = load i8, ptr %5, align 1
  %conv = sext i8 %6 to i32
  %cmp6 = icmp eq i32 %conv, 48
  br i1 %cmp6, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.rhs
  %7 = load ptr, ptr %p.addr, align 8
  %8 = load i8, ptr %7, align 1
  %conv7 = sext i8 %8 to i32
  %cmp8 = icmp eq i32 %conv7, 46
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.rhs
  %9 = phi i1 [ true, %land.rhs ], [ %cmp8, %lor.rhs ]
  br label %land.end

land.end:                                         ; preds = %lor.end, %while.cond
  %10 = phi i1 [ false, %while.cond ], [ %9, %lor.end ]
  br i1 %10, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %11 = load ptr, ptr %p.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %11, i32 1
  store ptr %incdec.ptr, ptr %p.addr, align 8
  br label %while.cond, !llvm.loop !14

while.end:                                        ; preds = %land.end
  %12 = load ptr, ptr %p.addr, align 8
  %13 = load i8, ptr %12, align 1
  %call = call noundef i32 @_ZN4llvh13hexDigitValueEc(i8 noundef signext %13)
  store i32 %call, ptr %hexDigit, align 4
  %14 = load i32, ptr %hexDigit, align 4
  %cmp9 = icmp eq i32 %14, -1
  br i1 %cmp9, label %if.then10, label %if.else12

if.then10:                                        ; preds = %while.end
  %15 = load i32, ptr %digitValue.addr, align 4
  %cmp11 = icmp eq i32 %15, 0
  %cond = select i1 %cmp11, i32 0, i32 2
  store i32 %cond, ptr %retval, align 4
  br label %return

if.else12:                                        ; preds = %while.end
  %16 = load i32, ptr %digitValue.addr, align 4
  %cmp13 = icmp eq i32 %16, 0
  %cond14 = select i1 %cmp13, i32 1, i32 3
  store i32 %cond14, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else12, %if.then10, %if.then3, %if.then
  %17 = load i32, ptr %retval, align 4
  ret i32 %17
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZN4llvhL13totalExponentEPKcS1_i(ptr noundef %p, ptr noundef %end, i32 noundef %exponentAdjustment) #1 {
entry:
  %p.addr = alloca ptr, align 8
  %end.addr = alloca ptr, align 8
  %exponentAdjustment.addr = alloca i32, align 4
  %unsignedExponent = alloca i32, align 4
  %negative = alloca i8, align 1
  %overflow = alloca i8, align 1
  %exponent = alloca i32, align 4
  %value = alloca i32, align 4
  store ptr %p, ptr %p.addr, align 8
  store ptr %end, ptr %end.addr, align 8
  store i32 %exponentAdjustment, ptr %exponentAdjustment.addr, align 4
  store i32 0, ptr %exponent, align 4
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i8, ptr %0, align 1
  %conv = sext i8 %1 to i32
  %cmp = icmp eq i32 %conv, 45
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, ptr %negative, align 1
  %2 = load ptr, ptr %p.addr, align 8
  %3 = load i8, ptr %2, align 1
  %conv1 = sext i8 %3 to i32
  %cmp2 = icmp eq i32 %conv1, 45
  br i1 %cmp2, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load ptr, ptr %p.addr, align 8
  %5 = load i8, ptr %4, align 1
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv3, 43
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %6 = load ptr, ptr %p.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %6, i32 1
  store ptr %incdec.ptr, ptr %p.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  store i32 0, ptr %unsignedExponent, align 4
  store i8 0, ptr %overflow, align 1
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %7 = load ptr, ptr %p.addr, align 8
  %8 = load ptr, ptr %end.addr, align 8
  %cmp5 = icmp ne ptr %7, %8
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr %p.addr, align 8
  %10 = load i8, ptr %9, align 1
  %conv6 = sext i8 %10 to i32
  %call = call noundef i32 @_ZN4llvhL13decDigitValueEj(i32 noundef %conv6)
  store i32 %call, ptr %value, align 4
  %11 = load i32, ptr %unsignedExponent, align 4
  %mul = mul nsw i32 %11, 10
  %12 = load i32, ptr %value, align 4
  %add = add i32 %mul, %12
  store i32 %add, ptr %unsignedExponent, align 4
  %13 = load i32, ptr %unsignedExponent, align 4
  %cmp7 = icmp sgt i32 %13, 32767
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %for.body
  store i8 1, ptr %overflow, align 1
  br label %for.end

if.end9:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end9
  %14 = load ptr, ptr %p.addr, align 8
  %incdec.ptr10 = getelementptr inbounds i8, ptr %14, i32 1
  store ptr %incdec.ptr10, ptr %p.addr, align 8
  br label %for.cond, !llvm.loop !15

for.end:                                          ; preds = %if.then8, %for.cond
  %15 = load i32, ptr %exponentAdjustment.addr, align 4
  %cmp11 = icmp sgt i32 %15, 32767
  br i1 %cmp11, label %if.then14, label %lor.lhs.false12

lor.lhs.false12:                                  ; preds = %for.end
  %16 = load i32, ptr %exponentAdjustment.addr, align 4
  %cmp13 = icmp slt i32 %16, -32768
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %lor.lhs.false12, %for.end
  store i8 1, ptr %overflow, align 1
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %lor.lhs.false12
  %17 = load i8, ptr %overflow, align 1
  %tobool = trunc i8 %17 to i1
  br i1 %tobool, label %if.end26, label %if.then16

if.then16:                                        ; preds = %if.end15
  %18 = load i32, ptr %unsignedExponent, align 4
  store i32 %18, ptr %exponent, align 4
  %19 = load i8, ptr %negative, align 1
  %tobool17 = trunc i8 %19 to i1
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.then16
  %20 = load i32, ptr %exponent, align 4
  %sub = sub nsw i32 0, %20
  store i32 %sub, ptr %exponent, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.then16
  %21 = load i32, ptr %exponentAdjustment.addr, align 4
  %22 = load i32, ptr %exponent, align 4
  %add20 = add nsw i32 %22, %21
  store i32 %add20, ptr %exponent, align 4
  %23 = load i32, ptr %exponent, align 4
  %cmp21 = icmp sgt i32 %23, 32767
  br i1 %cmp21, label %if.then24, label %lor.lhs.false22

lor.lhs.false22:                                  ; preds = %if.end19
  %24 = load i32, ptr %exponent, align 4
  %cmp23 = icmp slt i32 %24, -32768
  br i1 %cmp23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %lor.lhs.false22, %if.end19
  store i8 1, ptr %overflow, align 1
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %lor.lhs.false22
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %if.end15
  %25 = load i8, ptr %overflow, align 1
  %tobool27 = trunc i8 %25 to i1
  br i1 %tobool27, label %if.then28, label %if.end30

if.then28:                                        ; preds = %if.end26
  %26 = load i8, ptr %negative, align 1
  %tobool29 = trunc i8 %26 to i1
  %cond = select i1 %tobool29, i32 -32768, i32 32767
  store i32 %cond, ptr %exponent, align 4
  br label %if.end30

if.end30:                                         ; preds = %if.then28, %if.end26
  %27 = load i32, ptr %exponent, align 4
  ret i32 %27
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat28roundSignificandWithExponentEPKmjiNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %decSigParts, i32 noundef %sigPartCount, i32 noundef %exp, i32 noundef %rounding_mode) #1 align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %decSigParts.addr = alloca ptr, align 8
  %sigPartCount.addr = alloca i32, align 4
  %exp.addr = alloca i32, align 4
  %rounding_mode.addr = alloca i32, align 4
  %parts = alloca i32, align 4
  %pow5PartCount = alloca i32, align 4
  %calcSemantics = alloca %"struct.llvh::fltSemantics", align 4
  %pow5Parts = alloca [600 x i64], align 16
  %isNearest = alloca i8, align 1
  %sigStatus = alloca i32, align 4
  %powStatus = alloca i32, align 4
  %excessPrecision = alloca i32, align 4
  %truncatedBits = alloca i32, align 4
  %decSig = alloca %"class.llvh::detail::IEEEFloat", align 8
  %pow5 = alloca %"class.llvh::detail::IEEEFloat", align 8
  %calcLostFraction = alloca i32, align 4
  %HUerr = alloca i64, align 8
  %HUdistance = alloca i64, align 8
  %powHUerr = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %decSigParts, ptr %decSigParts.addr, align 8
  store i32 %sigPartCount, ptr %sigPartCount.addr, align 4
  store i32 %exp, ptr %exp.addr, align 4
  store i32 %rounding_mode, ptr %rounding_mode.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %calcSemantics, ptr align 4 @__const._ZN4llvh6detail9IEEEFloat28roundSignificandWithExponentEPKmjiNS_11APFloatBase12roundingModeE.calcSemantics, i64 12, i1 false)
  %0 = load i32, ptr %rounding_mode.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load i32, ptr %rounding_mode.addr, align 4
  %cmp2 = icmp eq i32 %1, 4
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %cmp2, %lor.rhs ]
  %frombool = zext i1 %2 to i8
  store i8 %frombool, ptr %isNearest, align 1
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %semantics, align 8
  %precision = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %3, i32 0, i32 2
  %4 = load i32, ptr %precision, align 4
  %add = add i32 %4, 11
  %call = call noundef i32 @_ZN4llvhL16partCountForBitsEj(i32 noundef %add)
  store i32 %call, ptr %parts, align 4
  %arraydecay = getelementptr inbounds [600 x i64], ptr %pow5Parts, i64 0, i64 0
  %5 = load i32, ptr %exp.addr, align 4
  %cmp3 = icmp sge i32 %5, 0
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %lor.end
  %6 = load i32, ptr %exp.addr, align 4
  br label %cond.end

cond.false:                                       ; preds = %lor.end
  %7 = load i32, ptr %exp.addr, align 4
  %sub = sub nsw i32 0, %7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %6, %cond.true ], [ %sub, %cond.false ]
  %call4 = call noundef i32 @_ZN4llvhL8powerOf5EPmj(ptr noundef %arraydecay, i32 noundef %cond)
  store i32 %call4, ptr %pow5PartCount, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %8 = load i32, ptr %parts, align 4
  %mul = mul i32 %8, 64
  %sub5 = sub i32 %mul, 1
  %precision6 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %calcSemantics, i32 0, i32 2
  store i32 %sub5, ptr %precision6, align 4
  %precision7 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %calcSemantics, i32 0, i32 2
  %9 = load i32, ptr %precision7, align 4
  %semantics8 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %semantics8, align 8
  %precision9 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %10, i32 0, i32 2
  %11 = load i32, ptr %precision9, align 4
  %sub10 = sub i32 %9, %11
  store i32 %sub10, ptr %excessPrecision, align 4
  %12 = load i32, ptr %excessPrecision, align 4
  store i32 %12, ptr %truncatedBits, align 4
  call void @_ZN4llvh6detail9IEEEFloatC1ERKNS_12fltSemanticsENS_11APFloatBase16uninitializedTagE(ptr noundef nonnull align 8 dereferenceable(24) %decSig, ptr noundef nonnull align 4 dereferenceable(12) %calcSemantics, i32 noundef 0)
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load, 3
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  call void @_ZN4llvh6detail9IEEEFloat8makeZeroEb(ptr noundef nonnull align 8 dereferenceable(24) %decSig, i1 noundef zeroext %tobool)
  call void @_ZN4llvh6detail9IEEEFloatC1ERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(24) %pow5, ptr noundef nonnull align 4 dereferenceable(12) %calcSemantics)
  %13 = load ptr, ptr %decSigParts.addr, align 8
  %14 = load i32, ptr %sigPartCount.addr, align 4
  %call11 = call noundef i32 @_ZN4llvh6detail9IEEEFloat24convertFromUnsignedPartsEPKmjNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %decSig, ptr noundef %13, i32 noundef %14, i32 noundef 0)
  store i32 %call11, ptr %sigStatus, align 4
  %arraydecay12 = getelementptr inbounds [600 x i64], ptr %pow5Parts, i64 0, i64 0
  %15 = load i32, ptr %pow5PartCount, align 4
  %call13 = call noundef i32 @_ZN4llvh6detail9IEEEFloat24convertFromUnsignedPartsEPKmjNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %pow5, ptr noundef %arraydecay12, i32 noundef %15, i32 noundef 0)
  store i32 %call13, ptr %powStatus, align 4
  %16 = load i32, ptr %exp.addr, align 4
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %decSig, i32 0, i32 2
  %17 = load i16, ptr %exponent, align 8
  %conv = sext i16 %17 to i32
  %add14 = add nsw i32 %conv, %16
  %conv15 = trunc i32 %add14 to i16
  store i16 %conv15, ptr %exponent, align 8
  %18 = load i32, ptr %exp.addr, align 4
  %cmp16 = icmp sge i32 %18, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %for.cond
  %call17 = call noundef i32 @_ZN4llvh6detail9IEEEFloat19multiplySignificandERKS1_PS2_(ptr noundef nonnull align 8 dereferenceable(24) %decSig, ptr noundef nonnull align 8 dereferenceable(24) %pow5, ptr noundef null)
  store i32 %call17, ptr %calcLostFraction, align 4
  %19 = load i32, ptr %powStatus, align 4
  %cmp18 = icmp ne i32 %19, 0
  %conv19 = zext i1 %cmp18 to i32
  store i32 %conv19, ptr %powHUerr, align 4
  br label %if.end42

if.else:                                          ; preds = %for.cond
  %call20 = call noundef i32 @_ZN4llvh6detail9IEEEFloat17divideSignificandERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %decSig, ptr noundef nonnull align 8 dereferenceable(24) %pow5)
  store i32 %call20, ptr %calcLostFraction, align 4
  %exponent21 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %decSig, i32 0, i32 2
  %20 = load i16, ptr %exponent21, align 8
  %conv22 = sext i16 %20 to i32
  %semantics23 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %21 = load ptr, ptr %semantics23, align 8
  %minExponent = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %21, i32 0, i32 1
  %22 = load i16, ptr %minExponent, align 2
  %conv24 = sext i16 %22 to i32
  %cmp25 = icmp slt i32 %conv22, %conv24
  br i1 %cmp25, label %if.then26, label %if.end38

if.then26:                                        ; preds = %if.else
  %semantics27 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %23 = load ptr, ptr %semantics27, align 8
  %minExponent28 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %23, i32 0, i32 1
  %24 = load i16, ptr %minExponent28, align 2
  %conv29 = sext i16 %24 to i32
  %exponent30 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %decSig, i32 0, i32 2
  %25 = load i16, ptr %exponent30, align 8
  %conv31 = sext i16 %25 to i32
  %sub32 = sub nsw i32 %conv29, %conv31
  %26 = load i32, ptr %excessPrecision, align 4
  %add33 = add i32 %26, %sub32
  store i32 %add33, ptr %excessPrecision, align 4
  %27 = load i32, ptr %excessPrecision, align 4
  store i32 %27, ptr %truncatedBits, align 4
  %28 = load i32, ptr %excessPrecision, align 4
  %precision34 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %calcSemantics, i32 0, i32 2
  %29 = load i32, ptr %precision34, align 4
  %cmp35 = icmp ugt i32 %28, %29
  br i1 %cmp35, label %if.then36, label %if.end

if.then36:                                        ; preds = %if.then26
  %precision37 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %calcSemantics, i32 0, i32 2
  %30 = load i32, ptr %precision37, align 4
  store i32 %30, ptr %excessPrecision, align 4
  br label %if.end

if.end:                                           ; preds = %if.then36, %if.then26
  br label %if.end38

if.end38:                                         ; preds = %if.end, %if.else
  %31 = load i32, ptr %powStatus, align 4
  %cmp39 = icmp eq i32 %31, 0
  br i1 %cmp39, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end38
  %32 = load i32, ptr %calcLostFraction, align 4
  %cmp40 = icmp eq i32 %32, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end38
  %33 = phi i1 [ false, %if.end38 ], [ %cmp40, %land.rhs ]
  %cond41 = select i1 %33, i32 0, i32 2
  store i32 %cond41, ptr %powHUerr, align 4
  br label %if.end42

if.end42:                                         ; preds = %land.end, %if.then
  %34 = load i32, ptr %calcLostFraction, align 4
  %cmp43 = icmp ne i32 %34, 0
  %35 = load i32, ptr %sigStatus, align 4
  %cmp44 = icmp ne i32 %35, 0
  %conv45 = zext i1 %cmp44 to i32
  %36 = load i32, ptr %powHUerr, align 4
  %call46 = call noundef i32 @_ZN4llvhL10HUerrBoundEbjj(i1 noundef zeroext %cmp43, i32 noundef %conv45, i32 noundef %36)
  %conv47 = zext i32 %call46 to i64
  store i64 %conv47, ptr %HUerr, align 8
  %call48 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %decSig)
  %37 = load i32, ptr %excessPrecision, align 4
  %38 = load i8, ptr %isNearest, align 1
  %tobool49 = trunc i8 %38 to i1
  %call50 = call noundef i64 @_ZN4llvhL16ulpsFromBoundaryEPKmjb(ptr noundef %call48, i32 noundef %37, i1 noundef zeroext %tobool49)
  %mul51 = mul i64 2, %call50
  store i64 %mul51, ptr %HUdistance, align 8
  %39 = load i64, ptr %HUdistance, align 8
  %40 = load i64, ptr %HUerr, align 8
  %cmp52 = icmp uge i64 %39, %40
  br i1 %cmp52, label %if.then53, label %if.end73

if.then53:                                        ; preds = %if.end42
  %call54 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call55 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call56 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %decSig)
  %precision57 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %calcSemantics, i32 0, i32 2
  %41 = load i32, ptr %precision57, align 4
  %42 = load i32, ptr %excessPrecision, align 4
  %sub58 = sub i32 %41, %42
  %43 = load i32, ptr %excessPrecision, align 4
  call void @_ZN4llvh5APInt9tcExtractEPmjPKmjj(ptr noundef %call54, i32 noundef %call55, ptr noundef %call56, i32 noundef %sub58, i32 noundef %43)
  %exponent59 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %decSig, i32 0, i32 2
  %44 = load i16, ptr %exponent59, align 8
  %conv60 = sext i16 %44 to i32
  %semantics61 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %45 = load ptr, ptr %semantics61, align 8
  %precision62 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %45, i32 0, i32 2
  %46 = load i32, ptr %precision62, align 4
  %add63 = add i32 %conv60, %46
  %precision64 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %calcSemantics, i32 0, i32 2
  %47 = load i32, ptr %precision64, align 4
  %48 = load i32, ptr %excessPrecision, align 4
  %sub65 = sub i32 %47, %48
  %sub66 = sub i32 %add63, %sub65
  %conv67 = trunc i32 %sub66 to i16
  %exponent68 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 %conv67, ptr %exponent68, align 8
  %call69 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %decSig)
  %call70 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %decSig)
  %49 = load i32, ptr %truncatedBits, align 4
  %call71 = call noundef i32 @_ZN4llvhL29lostFractionThroughTruncationEPKmjj(ptr noundef %call69, i32 noundef %call70, i32 noundef %49)
  store i32 %call71, ptr %calcLostFraction, align 4
  %50 = load i32, ptr %rounding_mode.addr, align 4
  %51 = load i32, ptr %calcLostFraction, align 4
  %call72 = call noundef i32 @_ZN4llvh6detail9IEEEFloat9normalizeENS_11APFloatBase12roundingModeENS_12lostFractionE(ptr noundef nonnull align 8 dereferenceable(24) %this1, i32 noundef %50, i32 noundef %51)
  store i32 %call72, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end73:                                         ; preds = %if.end42
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end73, %if.then53
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %pow5) #10
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %decSig) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %return
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %52 = load i32, ptr %parts, align 4
  %mul75 = mul i32 %52, 2
  store i32 %mul75, ptr %parts, align 4
  br label %for.cond, !llvm.loop !16

return:                                           ; preds = %cleanup
  %53 = load i32, ptr %retval, align 4
  ret i32 %53

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZN4llvhL8powerOf5EPmj(ptr noundef %dst, i32 noundef %power) #1 {
entry:
  %dst.addr = alloca ptr, align 8
  %power.addr = alloca i32, align 4
  %pow5s = alloca [1205 x i64], align 16
  %partsCount = alloca [16 x i32], align 16
  %scratch = alloca [600 x i64], align 16
  %p1 = alloca ptr, align 8
  %p2 = alloca ptr, align 8
  %pow5 = alloca ptr, align 8
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  %pc = alloca i32, align 4
  %tmp = alloca ptr, align 8
  store ptr %dst, ptr %dst.addr, align 8
  store i32 %power, ptr %power.addr, align 4
  %arrayidx = getelementptr inbounds [1205 x i64], ptr %pow5s, i64 0, i64 0
  store i64 390625, ptr %arrayidx, align 16
  call void @llvm.memset.p0.i64(ptr align 16 %partsCount, i8 0, i64 64, i1 false)
  %0 = getelementptr inbounds <{ i32, [15 x i32] }>, ptr %partsCount, i32 0, i32 0
  store i32 1, ptr %0, align 16
  %1 = load ptr, ptr %dst.addr, align 8
  store ptr %1, ptr %p1, align 8
  %arraydecay = getelementptr inbounds [600 x i64], ptr %scratch, i64 0, i64 0
  store ptr %arraydecay, ptr %p2, align 8
  %2 = load i32, ptr %power.addr, align 4
  %and = and i32 %2, 7
  %idxprom = zext i32 %and to i64
  %arrayidx1 = getelementptr inbounds [8 x i64], ptr @_ZZN4llvhL8powerOf5EPmjE16firstEightPowers, i64 0, i64 %idxprom
  %3 = load i64, ptr %arrayidx1, align 8
  %4 = load ptr, ptr %p1, align 8
  store i64 %3, ptr %4, align 8
  %5 = load i32, ptr %power.addr, align 4
  %shr = lshr i32 %5, 3
  store i32 %shr, ptr %power.addr, align 4
  store i32 1, ptr %result, align 4
  %arraydecay2 = getelementptr inbounds [1205 x i64], ptr %pow5s, i64 0, i64 0
  store ptr %arraydecay2, ptr %pow5, align 8
  store i32 0, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load i32, ptr %power.addr, align 4
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i32, ptr %n, align 4
  %idxprom3 = zext i32 %7 to i64
  %arrayidx4 = getelementptr inbounds [16 x i32], ptr %partsCount, i64 0, i64 %idxprom3
  %8 = load i32, ptr %arrayidx4, align 4
  store i32 %8, ptr %pc, align 4
  %9 = load i32, ptr %pc, align 4
  %cmp = icmp eq i32 %9, 0
  br i1 %cmp, label %if.then, label %if.end17

if.then:                                          ; preds = %for.body
  %10 = load i32, ptr %n, align 4
  %sub = sub i32 %10, 1
  %idxprom5 = zext i32 %sub to i64
  %arrayidx6 = getelementptr inbounds [16 x i32], ptr %partsCount, i64 0, i64 %idxprom5
  %11 = load i32, ptr %arrayidx6, align 4
  store i32 %11, ptr %pc, align 4
  %12 = load ptr, ptr %pow5, align 8
  %13 = load ptr, ptr %pow5, align 8
  %14 = load i32, ptr %pc, align 4
  %idx.ext = zext i32 %14 to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr = getelementptr inbounds i64, ptr %13, i64 %idx.neg
  %15 = load ptr, ptr %pow5, align 8
  %16 = load i32, ptr %pc, align 4
  %idx.ext7 = zext i32 %16 to i64
  %idx.neg8 = sub i64 0, %idx.ext7
  %add.ptr9 = getelementptr inbounds i64, ptr %15, i64 %idx.neg8
  %17 = load i32, ptr %pc, align 4
  %18 = load i32, ptr %pc, align 4
  call void @_ZN4llvh5APInt14tcFullMultiplyEPmPKmS3_jj(ptr noundef %12, ptr noundef %add.ptr, ptr noundef %add.ptr9, i32 noundef %17, i32 noundef %18)
  %19 = load i32, ptr %pc, align 4
  %mul = mul i32 %19, 2
  store i32 %mul, ptr %pc, align 4
  %20 = load ptr, ptr %pow5, align 8
  %21 = load i32, ptr %pc, align 4
  %sub10 = sub i32 %21, 1
  %idxprom11 = zext i32 %sub10 to i64
  %arrayidx12 = getelementptr inbounds i64, ptr %20, i64 %idxprom11
  %22 = load i64, ptr %arrayidx12, align 8
  %cmp13 = icmp eq i64 %22, 0
  br i1 %cmp13, label %if.then14, label %if.end

if.then14:                                        ; preds = %if.then
  %23 = load i32, ptr %pc, align 4
  %dec = add i32 %23, -1
  store i32 %dec, ptr %pc, align 4
  br label %if.end

if.end:                                           ; preds = %if.then14, %if.then
  %24 = load i32, ptr %pc, align 4
  %25 = load i32, ptr %n, align 4
  %idxprom15 = zext i32 %25 to i64
  %arrayidx16 = getelementptr inbounds [16 x i32], ptr %partsCount, i64 0, i64 %idxprom15
  store i32 %24, ptr %arrayidx16, align 4
  br label %if.end17

if.end17:                                         ; preds = %if.end, %for.body
  %26 = load i32, ptr %power.addr, align 4
  %and18 = and i32 %26, 1
  %tobool19 = icmp ne i32 %and18, 0
  br i1 %tobool19, label %if.then20, label %if.end28

if.then20:                                        ; preds = %if.end17
  %27 = load ptr, ptr %p2, align 8
  %28 = load ptr, ptr %p1, align 8
  %29 = load ptr, ptr %pow5, align 8
  %30 = load i32, ptr %result, align 4
  %31 = load i32, ptr %pc, align 4
  call void @_ZN4llvh5APInt14tcFullMultiplyEPmPKmS3_jj(ptr noundef %27, ptr noundef %28, ptr noundef %29, i32 noundef %30, i32 noundef %31)
  %32 = load i32, ptr %pc, align 4
  %33 = load i32, ptr %result, align 4
  %add = add i32 %33, %32
  store i32 %add, ptr %result, align 4
  %34 = load ptr, ptr %p2, align 8
  %35 = load i32, ptr %result, align 4
  %sub21 = sub i32 %35, 1
  %idxprom22 = zext i32 %sub21 to i64
  %arrayidx23 = getelementptr inbounds i64, ptr %34, i64 %idxprom22
  %36 = load i64, ptr %arrayidx23, align 8
  %cmp24 = icmp eq i64 %36, 0
  br i1 %cmp24, label %if.then25, label %if.end27

if.then25:                                        ; preds = %if.then20
  %37 = load i32, ptr %result, align 4
  %dec26 = add i32 %37, -1
  store i32 %dec26, ptr %result, align 4
  br label %if.end27

if.end27:                                         ; preds = %if.then25, %if.then20
  %38 = load ptr, ptr %p1, align 8
  store ptr %38, ptr %tmp, align 8
  %39 = load ptr, ptr %p2, align 8
  store ptr %39, ptr %p1, align 8
  %40 = load ptr, ptr %tmp, align 8
  store ptr %40, ptr %p2, align 8
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.end17
  %41 = load i32, ptr %pc, align 4
  %42 = load ptr, ptr %pow5, align 8
  %idx.ext29 = zext i32 %41 to i64
  %add.ptr30 = getelementptr inbounds i64, ptr %42, i64 %idx.ext29
  store ptr %add.ptr30, ptr %pow5, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end28
  %43 = load i32, ptr %power.addr, align 4
  %shr31 = lshr i32 %43, 1
  store i32 %shr31, ptr %power.addr, align 4
  %44 = load i32, ptr %n, align 4
  %inc = add i32 %44, 1
  store i32 %inc, ptr %n, align 4
  br label %for.cond, !llvm.loop !17

for.end:                                          ; preds = %for.cond
  %45 = load ptr, ptr %p1, align 8
  %46 = load ptr, ptr %dst.addr, align 8
  %cmp32 = icmp ne ptr %45, %46
  br i1 %cmp32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %for.end
  %47 = load ptr, ptr %dst.addr, align 8
  %48 = load ptr, ptr %p1, align 8
  %49 = load i32, ptr %result, align 4
  call void @_ZN4llvh5APInt8tcAssignEPmPKmj(ptr noundef %47, ptr noundef %48, i32 noundef %49)
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %for.end
  %50 = load i32, ptr %result, align 4
  ret i32 %50
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloat8makeZeroEb(ptr noundef nonnull align 8 dereferenceable(24) %this, i1 noundef zeroext %Negative) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Negative.addr = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %Negative to i8
  store i8 %frombool, ptr %Negative.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, -8
  %bf.set = or i8 %bf.clear, 3
  store i8 %bf.set, ptr %category, align 2
  %0 = load i8, ptr %Negative.addr, align 1
  %tobool = trunc i8 %0 to i1
  %conv = zext i1 %tobool to i32
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %1 = trunc i32 %conv to i8
  %bf.load2 = load i8, ptr %sign, align 2
  %bf.value = and i8 %1, 1
  %bf.shl = shl i8 %bf.value, 3
  %bf.clear3 = and i8 %bf.load2, -9
  %bf.set4 = or i8 %bf.clear3, %bf.shl
  store i8 %bf.set4, ptr %sign, align 2
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %semantics, align 8
  %minExponent = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %2, i32 0, i32 1
  %3 = load i16, ptr %minExponent, align 2
  %conv5 = sext i16 %3 to i32
  %sub = sub nsw i32 %conv5, 1
  %conv6 = trunc i32 %sub to i16
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 %conv6, ptr %exponent, align 8
  %call = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call7 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  call void @_ZN4llvh5APInt5tcSetEPmmj(ptr noundef %call, i64 noundef 0, i32 noundef %call7)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZN4llvhL10HUerrBoundEbjj(i1 noundef zeroext %inexactMultiply, i32 noundef %HUerr1, i32 noundef %HUerr2) #1 {
entry:
  %retval = alloca i32, align 4
  %inexactMultiply.addr = alloca i8, align 1
  %HUerr1.addr = alloca i32, align 4
  %HUerr2.addr = alloca i32, align 4
  %frombool = zext i1 %inexactMultiply to i8
  store i8 %frombool, ptr %inexactMultiply.addr, align 1
  store i32 %HUerr1, ptr %HUerr1.addr, align 4
  store i32 %HUerr2, ptr %HUerr2.addr, align 4
  %0 = load i32, ptr %HUerr1.addr, align 4
  %1 = load i32, ptr %HUerr2.addr, align 4
  %add = add i32 %0, %1
  %cmp = icmp eq i32 %add, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i8, ptr %inexactMultiply.addr, align 1
  %tobool = trunc i8 %2 to i1
  %conv = zext i1 %tobool to i32
  %mul = mul nsw i32 %conv, 2
  store i32 %mul, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %3 = load i8, ptr %inexactMultiply.addr, align 1
  %tobool1 = trunc i8 %3 to i1
  %conv2 = zext i1 %tobool1 to i32
  %4 = load i32, ptr %HUerr1.addr, align 4
  %5 = load i32, ptr %HUerr2.addr, align 4
  %add3 = add i32 %4, %5
  %mul4 = mul i32 2, %add3
  %add5 = add i32 %conv2, %mul4
  store i32 %add5, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i64 @_ZN4llvhL16ulpsFromBoundaryEPKmjb(ptr noundef %parts, i32 noundef %bits, i1 noundef zeroext %isNearest) #1 {
entry:
  %retval = alloca i64, align 8
  %parts.addr = alloca ptr, align 8
  %bits.addr = alloca i32, align 4
  %isNearest.addr = alloca i8, align 1
  %count = alloca i32, align 4
  %partBits = alloca i32, align 4
  %part = alloca i64, align 8
  %boundary = alloca i64, align 8
  store ptr %parts, ptr %parts.addr, align 8
  store i32 %bits, ptr %bits.addr, align 4
  %frombool = zext i1 %isNearest to i8
  store i8 %frombool, ptr %isNearest.addr, align 1
  %0 = load i32, ptr %bits.addr, align 4
  %dec = add i32 %0, -1
  store i32 %dec, ptr %bits.addr, align 4
  %1 = load i32, ptr %bits.addr, align 4
  %div = udiv i32 %1, 64
  store i32 %div, ptr %count, align 4
  %2 = load i32, ptr %bits.addr, align 4
  %rem = urem i32 %2, 64
  %add = add i32 %rem, 1
  store i32 %add, ptr %partBits, align 4
  %3 = load ptr, ptr %parts.addr, align 8
  %4 = load i32, ptr %count, align 4
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr inbounds i64, ptr %3, i64 %idxprom
  %5 = load i64, ptr %arrayidx, align 8
  %6 = load i32, ptr %partBits, align 4
  %sub = sub i32 64, %6
  %sh_prom = zext i32 %sub to i64
  %shr = lshr i64 -1, %sh_prom
  %and = and i64 %5, %shr
  store i64 %and, ptr %part, align 8
  %7 = load i8, ptr %isNearest.addr, align 1
  %tobool = trunc i8 %7 to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %8 = load i32, ptr %partBits, align 4
  %sub1 = sub i32 %8, 1
  %sh_prom2 = zext i32 %sub1 to i64
  %shl = shl i64 1, %sh_prom2
  store i64 %shl, ptr %boundary, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  store i64 0, ptr %boundary, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %9 = load i32, ptr %count, align 4
  %cmp = icmp eq i32 %9, 0
  br i1 %cmp, label %if.then3, label %if.end11

if.then3:                                         ; preds = %if.end
  %10 = load i64, ptr %part, align 8
  %11 = load i64, ptr %boundary, align 8
  %sub4 = sub i64 %10, %11
  %12 = load i64, ptr %boundary, align 8
  %13 = load i64, ptr %part, align 8
  %sub5 = sub i64 %12, %13
  %cmp6 = icmp ule i64 %sub4, %sub5
  br i1 %cmp6, label %if.then7, label %if.else9

if.then7:                                         ; preds = %if.then3
  %14 = load i64, ptr %part, align 8
  %15 = load i64, ptr %boundary, align 8
  %sub8 = sub i64 %14, %15
  store i64 %sub8, ptr %retval, align 8
  br label %return

if.else9:                                         ; preds = %if.then3
  %16 = load i64, ptr %boundary, align 8
  %17 = load i64, ptr %part, align 8
  %sub10 = sub i64 %16, %17
  store i64 %sub10, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %if.end
  %18 = load i64, ptr %part, align 8
  %19 = load i64, ptr %boundary, align 8
  %cmp12 = icmp eq i64 %18, %19
  br i1 %cmp12, label %if.then13, label %if.else22

if.then13:                                        ; preds = %if.end11
  br label %while.cond

while.cond:                                       ; preds = %if.end20, %if.then13
  %20 = load i32, ptr %count, align 4
  %dec14 = add i32 %20, -1
  store i32 %dec14, ptr %count, align 4
  %tobool15 = icmp ne i32 %dec14, 0
  br i1 %tobool15, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %21 = load ptr, ptr %parts.addr, align 8
  %22 = load i32, ptr %count, align 4
  %idxprom16 = zext i32 %22 to i64
  %arrayidx17 = getelementptr inbounds i64, ptr %21, i64 %idxprom16
  %23 = load i64, ptr %arrayidx17, align 8
  %tobool18 = icmp ne i64 %23, 0
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %while.body
  store i64 -1, ptr %retval, align 8
  br label %return

if.end20:                                         ; preds = %while.body
  br label %while.cond, !llvm.loop !18

while.end:                                        ; preds = %while.cond
  %24 = load ptr, ptr %parts.addr, align 8
  %arrayidx21 = getelementptr inbounds i64, ptr %24, i64 0
  %25 = load i64, ptr %arrayidx21, align 8
  store i64 %25, ptr %retval, align 8
  br label %return

if.else22:                                        ; preds = %if.end11
  %26 = load i64, ptr %part, align 8
  %27 = load i64, ptr %boundary, align 8
  %sub23 = sub i64 %27, 1
  %cmp24 = icmp eq i64 %26, %sub23
  br i1 %cmp24, label %if.then25, label %if.end38

if.then25:                                        ; preds = %if.else22
  br label %while.cond26

while.cond26:                                     ; preds = %if.end34, %if.then25
  %28 = load i32, ptr %count, align 4
  %dec27 = add i32 %28, -1
  store i32 %dec27, ptr %count, align 4
  %tobool28 = icmp ne i32 %dec27, 0
  br i1 %tobool28, label %while.body29, label %while.end35

while.body29:                                     ; preds = %while.cond26
  %29 = load ptr, ptr %parts.addr, align 8
  %30 = load i32, ptr %count, align 4
  %idxprom30 = zext i32 %30 to i64
  %arrayidx31 = getelementptr inbounds i64, ptr %29, i64 %idxprom30
  %31 = load i64, ptr %arrayidx31, align 8
  %not = xor i64 %31, -1
  %tobool32 = icmp ne i64 %not, 0
  br i1 %tobool32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %while.body29
  store i64 -1, ptr %retval, align 8
  br label %return

if.end34:                                         ; preds = %while.body29
  br label %while.cond26, !llvm.loop !19

while.end35:                                      ; preds = %while.cond26
  %32 = load ptr, ptr %parts.addr, align 8
  %arrayidx36 = getelementptr inbounds i64, ptr %32, i64 0
  %33 = load i64, ptr %arrayidx36, align 8
  %sub37 = sub i64 0, %33
  store i64 %sub37, ptr %retval, align 8
  br label %return

if.end38:                                         ; preds = %if.else22
  br label %if.end39

if.end39:                                         ; preds = %if.end38
  store i64 -1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end39, %while.end35, %if.then33, %while.end, %if.then19, %if.else9, %if.then7
  %34 = load i64, ptr %retval, align 8
  ret i64 %34
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat24convertFromDecimalStringENS_9StringRefENS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr %str.coerce0, i64 %str.coerce1, i32 noundef %rounding_mode) #1 align 2 {
entry:
  %str = alloca %"class.llvh::StringRef", align 8
  %this.addr = alloca ptr, align 8
  %rounding_mode.addr = alloca i32, align 4
  %D = alloca %"struct.llvh::decimalInfo", align 8
  %fs = alloca i32, align 4
  %p = alloca ptr, align 8
  %decSignificand = alloca ptr, align 8
  %partCount = alloca i32, align 4
  %decValue = alloca i64, align 8
  %val = alloca i64, align 8
  %multiplier = alloca i64, align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %str, i32 0, i32 0
  store ptr %str.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %str, i32 0, i32 1
  store i64 %str.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %rounding_mode, ptr %rounding_mode.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZNK4llvh9StringRef5beginEv(ptr noundef nonnull align 8 dereferenceable(16) %str)
  store ptr %call, ptr %p, align 8
  %2 = load ptr, ptr %p, align 8
  %call2 = call noundef ptr @_ZNK4llvh9StringRef3endEv(ptr noundef nonnull align 8 dereferenceable(16) %str)
  call void @_ZN4llvhL16interpretDecimalEPKcS1_PNS_11decimalInfoE(ptr noundef %2, ptr noundef %call2, ptr noundef %D)
  %firstSigDigit = getelementptr inbounds %"struct.llvh::decimalInfo", ptr %D, i32 0, i32 0
  %3 = load ptr, ptr %firstSigDigit, align 8
  %call3 = call noundef ptr @_ZNK4llvh9StringRef3endEv(ptr noundef nonnull align 8 dereferenceable(16) %str)
  %cmp = icmp eq ptr %3, %call3
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %firstSigDigit4 = getelementptr inbounds %"struct.llvh::decimalInfo", ptr %D, i32 0, i32 0
  %4 = load ptr, ptr %firstSigDigit4, align 8
  %5 = load i8, ptr %4, align 1
  %conv = sext i8 %5 to i32
  %call5 = call noundef i32 @_ZN4llvhL13decDigitValueEj(i32 noundef %conv)
  %cmp6 = icmp uge i32 %call5, 10
  br i1 %cmp6, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, -8
  %bf.set = or i8 %bf.clear, 3
  store i8 %bf.set, ptr %category, align 2
  store i32 0, ptr %fs, align 4
  br label %if.end81

if.else:                                          ; preds = %lor.lhs.false
  %normalizedExponent = getelementptr inbounds %"struct.llvh::decimalInfo", ptr %D, i32 0, i32 3
  %6 = load i32, ptr %normalizedExponent, align 4
  %sub = sub nsw i32 %6, 1
  %cmp7 = icmp sgt i32 %sub, 51083
  br i1 %cmp7, label %if.then8, label %if.else10

if.then8:                                         ; preds = %if.else
  %7 = load i32, ptr %rounding_mode.addr, align 4
  %call9 = call noundef i32 @_ZN4llvh6detail9IEEEFloat14handleOverflowENS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this1, i32 noundef %7)
  store i32 %call9, ptr %fs, align 4
  br label %if.end80

if.else10:                                        ; preds = %if.else
  %normalizedExponent11 = getelementptr inbounds %"struct.llvh::decimalInfo", ptr %D, i32 0, i32 3
  %8 = load i32, ptr %normalizedExponent11, align 4
  %sub12 = sub nsw i32 %8, 1
  %cmp13 = icmp slt i32 %sub12, -51083
  br i1 %cmp13, label %if.then21, label %lor.lhs.false14

lor.lhs.false14:                                  ; preds = %if.else10
  %normalizedExponent15 = getelementptr inbounds %"struct.llvh::decimalInfo", ptr %D, i32 0, i32 3
  %9 = load i32, ptr %normalizedExponent15, align 4
  %add = add nsw i32 %9, 1
  %mul = mul nsw i32 %add, 28738
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %semantics, align 8
  %minExponent = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %10, i32 0, i32 1
  %11 = load i16, ptr %minExponent, align 2
  %conv16 = sext i16 %11 to i32
  %semantics17 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %12 = load ptr, ptr %semantics17, align 8
  %precision = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %12, i32 0, i32 2
  %13 = load i32, ptr %precision, align 4
  %sub18 = sub nsw i32 %conv16, %13
  %mul19 = mul nsw i32 8651, %sub18
  %cmp20 = icmp sle i32 %mul, %mul19
  br i1 %cmp20, label %if.then21, label %if.else27

if.then21:                                        ; preds = %lor.lhs.false14, %if.else10
  %category22 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load23 = load i8, ptr %category22, align 2
  %bf.clear24 = and i8 %bf.load23, -8
  %bf.set25 = or i8 %bf.clear24, 2
  store i8 %bf.set25, ptr %category22, align 2
  call void @_ZN4llvh6detail9IEEEFloat15zeroSignificandEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %14 = load i32, ptr %rounding_mode.addr, align 4
  %call26 = call noundef i32 @_ZN4llvh6detail9IEEEFloat9normalizeENS_11APFloatBase12roundingModeENS_12lostFractionE(ptr noundef nonnull align 8 dereferenceable(24) %this1, i32 noundef %14, i32 noundef 1)
  store i32 %call26, ptr %fs, align 4
  br label %if.end79

if.else27:                                        ; preds = %lor.lhs.false14
  %normalizedExponent28 = getelementptr inbounds %"struct.llvh::decimalInfo", ptr %D, i32 0, i32 3
  %15 = load i32, ptr %normalizedExponent28, align 4
  %sub29 = sub nsw i32 %15, 1
  %mul30 = mul nsw i32 %sub29, 42039
  %semantics31 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %16 = load ptr, ptr %semantics31, align 8
  %maxExponent = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %16, i32 0, i32 0
  %17 = load i16, ptr %maxExponent, align 4
  %conv32 = sext i16 %17 to i32
  %mul33 = mul nsw i32 12655, %conv32
  %cmp34 = icmp sge i32 %mul30, %mul33
  br i1 %cmp34, label %if.then35, label %if.else37

if.then35:                                        ; preds = %if.else27
  %18 = load i32, ptr %rounding_mode.addr, align 4
  %call36 = call noundef i32 @_ZN4llvh6detail9IEEEFloat14handleOverflowENS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this1, i32 noundef %18)
  store i32 %call36, ptr %fs, align 4
  br label %if.end78

if.else37:                                        ; preds = %if.else27
  %lastSigDigit = getelementptr inbounds %"struct.llvh::decimalInfo", ptr %D, i32 0, i32 1
  %19 = load ptr, ptr %lastSigDigit, align 8
  %firstSigDigit38 = getelementptr inbounds %"struct.llvh::decimalInfo", ptr %D, i32 0, i32 0
  %20 = load ptr, ptr %firstSigDigit38, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %19 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %20 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv39 = trunc i64 %sub.ptr.sub to i32
  %add40 = add i32 %conv39, 1
  store i32 %add40, ptr %partCount, align 4
  %21 = load i32, ptr %partCount, align 4
  %mul41 = mul i32 196, %21
  %div = udiv i32 %mul41, 59
  %add42 = add i32 1, %div
  %call43 = call noundef i32 @_ZN4llvhL16partCountForBitsEj(i32 noundef %add42)
  store i32 %call43, ptr %partCount, align 4
  %22 = load i32, ptr %partCount, align 4
  %add44 = add i32 %22, 1
  %conv45 = zext i32 %add44 to i64
  %23 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %conv45, i64 8)
  %24 = extractvalue { i64, i1 } %23, 1
  %25 = extractvalue { i64, i1 } %23, 0
  %26 = select i1 %24, i64 -1, i64 %25
  %call46 = call noalias noundef nonnull ptr @_Znam(i64 noundef %26) #13
  store ptr %call46, ptr %decSignificand, align 8
  store i32 0, ptr %partCount, align 4
  br label %do.body

do.body:                                          ; preds = %do.cond69, %if.else37
  store i64 0, ptr %val, align 8
  store i64 1, ptr %multiplier, align 8
  br label %do.body47

do.body47:                                        ; preds = %land.end, %do.body
  %27 = load ptr, ptr %p, align 8
  %28 = load i8, ptr %27, align 1
  %conv48 = sext i8 %28 to i32
  %cmp49 = icmp eq i32 %conv48, 46
  br i1 %cmp49, label %if.then50, label %if.end54

if.then50:                                        ; preds = %do.body47
  %29 = load ptr, ptr %p, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %29, i32 1
  store ptr %incdec.ptr, ptr %p, align 8
  %30 = load ptr, ptr %p, align 8
  %call51 = call noundef ptr @_ZNK4llvh9StringRef3endEv(ptr noundef nonnull align 8 dereferenceable(16) %str)
  %cmp52 = icmp eq ptr %30, %call51
  br i1 %cmp52, label %if.then53, label %if.end

if.then53:                                        ; preds = %if.then50
  br label %do.end

if.end:                                           ; preds = %if.then50
  br label %if.end54

if.end54:                                         ; preds = %if.end, %do.body47
  %31 = load ptr, ptr %p, align 8
  %incdec.ptr55 = getelementptr inbounds i8, ptr %31, i32 1
  store ptr %incdec.ptr55, ptr %p, align 8
  %32 = load i8, ptr %31, align 1
  %conv56 = sext i8 %32 to i32
  %call57 = call noundef i32 @_ZN4llvhL13decDigitValueEj(i32 noundef %conv56)
  %conv58 = zext i32 %call57 to i64
  store i64 %conv58, ptr %decValue, align 8
  %33 = load i64, ptr %multiplier, align 8
  %mul59 = mul i64 %33, 10
  store i64 %mul59, ptr %multiplier, align 8
  %34 = load i64, ptr %val, align 8
  %mul60 = mul i64 %34, 10
  %35 = load i64, ptr %decValue, align 8
  %add61 = add i64 %mul60, %35
  store i64 %add61, ptr %val, align 8
  br label %do.cond

do.cond:                                          ; preds = %if.end54
  %36 = load ptr, ptr %p, align 8
  %lastSigDigit62 = getelementptr inbounds %"struct.llvh::decimalInfo", ptr %D, i32 0, i32 1
  %37 = load ptr, ptr %lastSigDigit62, align 8
  %cmp63 = icmp ule ptr %36, %37
  br i1 %cmp63, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %do.cond
  %38 = load i64, ptr %multiplier, align 8
  %cmp64 = icmp ule i64 %38, 1844674407370955160
  br label %land.end

land.end:                                         ; preds = %land.rhs, %do.cond
  %39 = phi i1 [ false, %do.cond ], [ %cmp64, %land.rhs ]
  br i1 %39, label %do.body47, label %do.end, !llvm.loop !20

do.end:                                           ; preds = %land.end, %if.then53
  %40 = load ptr, ptr %decSignificand, align 8
  %41 = load ptr, ptr %decSignificand, align 8
  %42 = load i64, ptr %multiplier, align 8
  %43 = load i64, ptr %val, align 8
  %44 = load i32, ptr %partCount, align 4
  %45 = load i32, ptr %partCount, align 4
  %add65 = add i32 %45, 1
  %call66 = call noundef i32 @_ZN4llvh5APInt14tcMultiplyPartEPmPKmmmjjb(ptr noundef %40, ptr noundef %41, i64 noundef %42, i64 noundef %43, i32 noundef %44, i32 noundef %add65, i1 noundef zeroext false)
  %46 = load ptr, ptr %decSignificand, align 8
  %47 = load i32, ptr %partCount, align 4
  %idxprom = zext i32 %47 to i64
  %arrayidx = getelementptr inbounds i64, ptr %46, i64 %idxprom
  %48 = load i64, ptr %arrayidx, align 8
  %tobool = icmp ne i64 %48, 0
  br i1 %tobool, label %if.then67, label %if.end68

if.then67:                                        ; preds = %do.end
  %49 = load i32, ptr %partCount, align 4
  %inc = add i32 %49, 1
  store i32 %inc, ptr %partCount, align 4
  br label %if.end68

if.end68:                                         ; preds = %if.then67, %do.end
  br label %do.cond69

do.cond69:                                        ; preds = %if.end68
  %50 = load ptr, ptr %p, align 8
  %lastSigDigit70 = getelementptr inbounds %"struct.llvh::decimalInfo", ptr %D, i32 0, i32 1
  %51 = load ptr, ptr %lastSigDigit70, align 8
  %cmp71 = icmp ule ptr %50, %51
  br i1 %cmp71, label %do.body, label %do.end72, !llvm.loop !21

do.end72:                                         ; preds = %do.cond69
  %category73 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load74 = load i8, ptr %category73, align 2
  %bf.clear75 = and i8 %bf.load74, -8
  %bf.set76 = or i8 %bf.clear75, 2
  store i8 %bf.set76, ptr %category73, align 2
  %52 = load ptr, ptr %decSignificand, align 8
  %53 = load i32, ptr %partCount, align 4
  %exponent = getelementptr inbounds %"struct.llvh::decimalInfo", ptr %D, i32 0, i32 2
  %54 = load i32, ptr %exponent, align 8
  %55 = load i32, ptr %rounding_mode.addr, align 4
  %call77 = call noundef i32 @_ZN4llvh6detail9IEEEFloat28roundSignificandWithExponentEPKmjiNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %52, i32 noundef %53, i32 noundef %54, i32 noundef %55)
  store i32 %call77, ptr %fs, align 4
  %56 = load ptr, ptr %decSignificand, align 8
  %isnull = icmp eq ptr %56, null
  br i1 %isnull, label %delete.end, label %delete.notnull

delete.notnull:                                   ; preds = %do.end72
  call void @_ZdaPv(ptr noundef %56) #14
  br label %delete.end

delete.end:                                       ; preds = %delete.notnull, %do.end72
  br label %if.end78

if.end78:                                         ; preds = %delete.end, %if.then35
  br label %if.end79

if.end79:                                         ; preds = %if.end78, %if.then21
  br label %if.end80

if.end80:                                         ; preds = %if.end79, %if.then8
  br label %if.end81

if.end81:                                         ; preds = %if.end80, %if.then
  %57 = load i32, ptr %fs, align 4
  ret i32 %57
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZN4llvhL16interpretDecimalEPKcS1_PNS_11decimalInfoE(ptr noundef %begin, ptr noundef %end, ptr noundef %D) #1 {
entry:
  %begin.addr = alloca ptr, align 8
  %end.addr = alloca ptr, align 8
  %D.addr = alloca ptr, align 8
  %dot = alloca ptr, align 8
  %p = alloca ptr, align 8
  store ptr %begin, ptr %begin.addr, align 8
  store ptr %end, ptr %end.addr, align 8
  store ptr %D, ptr %D.addr, align 8
  %0 = load ptr, ptr %end.addr, align 8
  store ptr %0, ptr %dot, align 8
  %1 = load ptr, ptr %begin.addr, align 8
  %2 = load ptr, ptr %end.addr, align 8
  %call = call noundef ptr @_ZN4llvhL26skipLeadingZeroesAndAnyDotEPKcS1_PS1_(ptr noundef %1, ptr noundef %2, ptr noundef %dot)
  store ptr %call, ptr %p, align 8
  %3 = load ptr, ptr %p, align 8
  %4 = load ptr, ptr %D.addr, align 8
  %firstSigDigit = getelementptr inbounds %"struct.llvh::decimalInfo", ptr %4, i32 0, i32 0
  store ptr %3, ptr %firstSigDigit, align 8
  %5 = load ptr, ptr %D.addr, align 8
  %exponent = getelementptr inbounds %"struct.llvh::decimalInfo", ptr %5, i32 0, i32 2
  store i32 0, ptr %exponent, align 8
  %6 = load ptr, ptr %D.addr, align 8
  %normalizedExponent = getelementptr inbounds %"struct.llvh::decimalInfo", ptr %6, i32 0, i32 3
  store i32 0, ptr %normalizedExponent, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load ptr, ptr %p, align 8
  %8 = load ptr, ptr %end.addr, align 8
  %cmp = icmp ne ptr %7, %8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr %p, align 8
  %10 = load i8, ptr %9, align 1
  %conv = sext i8 %10 to i32
  %cmp1 = icmp eq i32 %conv, 46
  br i1 %cmp1, label %if.then, label %if.end4

if.then:                                          ; preds = %for.body
  %11 = load ptr, ptr %p, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %11, i32 1
  store ptr %incdec.ptr, ptr %p, align 8
  store ptr %11, ptr %dot, align 8
  %12 = load ptr, ptr %p, align 8
  %13 = load ptr, ptr %end.addr, align 8
  %cmp2 = icmp eq ptr %12, %13
  br i1 %cmp2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  br label %for.end

if.end:                                           ; preds = %if.then
  br label %if.end4

if.end4:                                          ; preds = %if.end, %for.body
  %14 = load ptr, ptr %p, align 8
  %15 = load i8, ptr %14, align 1
  %conv5 = sext i8 %15 to i32
  %call6 = call noundef i32 @_ZN4llvhL13decDigitValueEj(i32 noundef %conv5)
  %cmp7 = icmp uge i32 %call6, 10
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end4
  br label %for.end

if.end9:                                          ; preds = %if.end4
  br label %for.inc

for.inc:                                          ; preds = %if.end9
  %16 = load ptr, ptr %p, align 8
  %incdec.ptr10 = getelementptr inbounds i8, ptr %16, i32 1
  store ptr %incdec.ptr10, ptr %p, align 8
  br label %for.cond, !llvm.loop !22

for.end:                                          ; preds = %if.then8, %if.then3, %for.cond
  %17 = load ptr, ptr %p, align 8
  %18 = load ptr, ptr %end.addr, align 8
  %cmp11 = icmp ne ptr %17, %18
  br i1 %cmp11, label %if.then12, label %if.end18

if.then12:                                        ; preds = %for.end
  %19 = load ptr, ptr %p, align 8
  %add.ptr = getelementptr inbounds i8, ptr %19, i64 1
  %20 = load ptr, ptr %end.addr, align 8
  %call13 = call noundef i32 @_ZN4llvhL12readExponentEPKcS1_(ptr noundef %add.ptr, ptr noundef %20)
  %21 = load ptr, ptr %D.addr, align 8
  %exponent14 = getelementptr inbounds %"struct.llvh::decimalInfo", ptr %21, i32 0, i32 2
  store i32 %call13, ptr %exponent14, align 8
  %22 = load ptr, ptr %dot, align 8
  %23 = load ptr, ptr %end.addr, align 8
  %cmp15 = icmp eq ptr %22, %23
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.then12
  %24 = load ptr, ptr %p, align 8
  store ptr %24, ptr %dot, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %if.then12
  br label %if.end18

if.end18:                                         ; preds = %if.end17, %for.end
  %25 = load ptr, ptr %p, align 8
  %26 = load ptr, ptr %D.addr, align 8
  %firstSigDigit19 = getelementptr inbounds %"struct.llvh::decimalInfo", ptr %26, i32 0, i32 0
  %27 = load ptr, ptr %firstSigDigit19, align 8
  %cmp20 = icmp ne ptr %25, %27
  br i1 %cmp20, label %if.then21, label %if.end58

if.then21:                                        ; preds = %if.end18
  %28 = load ptr, ptr %p, align 8
  %29 = load ptr, ptr %begin.addr, align 8
  %cmp22 = icmp ne ptr %28, %29
  br i1 %cmp22, label %if.then23, label %if.end36

if.then23:                                        ; preds = %if.then21
  br label %do.body

do.body:                                          ; preds = %land.end34, %if.then23
  br label %do.body24

do.body24:                                        ; preds = %land.end, %do.body
  %30 = load ptr, ptr %p, align 8
  %incdec.ptr25 = getelementptr inbounds i8, ptr %30, i32 -1
  store ptr %incdec.ptr25, ptr %p, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body24
  %31 = load ptr, ptr %p, align 8
  %32 = load ptr, ptr %begin.addr, align 8
  %cmp26 = icmp ne ptr %31, %32
  br i1 %cmp26, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %do.cond
  %33 = load ptr, ptr %p, align 8
  %34 = load i8, ptr %33, align 1
  %conv27 = sext i8 %34 to i32
  %cmp28 = icmp eq i32 %conv27, 48
  br label %land.end

land.end:                                         ; preds = %land.rhs, %do.cond
  %35 = phi i1 [ false, %do.cond ], [ %cmp28, %land.rhs ]
  br i1 %35, label %do.body24, label %do.end, !llvm.loop !23

do.end:                                           ; preds = %land.end
  br label %do.cond29

do.cond29:                                        ; preds = %do.end
  %36 = load ptr, ptr %p, align 8
  %37 = load ptr, ptr %begin.addr, align 8
  %cmp30 = icmp ne ptr %36, %37
  br i1 %cmp30, label %land.rhs31, label %land.end34

land.rhs31:                                       ; preds = %do.cond29
  %38 = load ptr, ptr %p, align 8
  %39 = load i8, ptr %38, align 1
  %conv32 = sext i8 %39 to i32
  %cmp33 = icmp eq i32 %conv32, 46
  br label %land.end34

land.end34:                                       ; preds = %land.rhs31, %do.cond29
  %40 = phi i1 [ false, %do.cond29 ], [ %cmp33, %land.rhs31 ]
  br i1 %40, label %do.body, label %do.end35, !llvm.loop !24

do.end35:                                         ; preds = %land.end34
  br label %if.end36

if.end36:                                         ; preds = %do.end35, %if.then21
  %41 = load ptr, ptr %dot, align 8
  %42 = load ptr, ptr %p, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %41 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %42 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %43 = load ptr, ptr %dot, align 8
  %44 = load ptr, ptr %p, align 8
  %cmp37 = icmp ugt ptr %43, %44
  %conv38 = zext i1 %cmp37 to i64
  %sub = sub nsw i64 %sub.ptr.sub, %conv38
  %conv39 = trunc i64 %sub to i16
  %conv40 = sext i16 %conv39 to i32
  %45 = load ptr, ptr %D.addr, align 8
  %exponent41 = getelementptr inbounds %"struct.llvh::decimalInfo", ptr %45, i32 0, i32 2
  %46 = load i32, ptr %exponent41, align 8
  %add = add nsw i32 %46, %conv40
  store i32 %add, ptr %exponent41, align 8
  %47 = load ptr, ptr %D.addr, align 8
  %exponent42 = getelementptr inbounds %"struct.llvh::decimalInfo", ptr %47, i32 0, i32 2
  %48 = load i32, ptr %exponent42, align 8
  %49 = load ptr, ptr %p, align 8
  %50 = load ptr, ptr %D.addr, align 8
  %firstSigDigit43 = getelementptr inbounds %"struct.llvh::decimalInfo", ptr %50, i32 0, i32 0
  %51 = load ptr, ptr %firstSigDigit43, align 8
  %sub.ptr.lhs.cast44 = ptrtoint ptr %49 to i64
  %sub.ptr.rhs.cast45 = ptrtoint ptr %51 to i64
  %sub.ptr.sub46 = sub i64 %sub.ptr.lhs.cast44, %sub.ptr.rhs.cast45
  %52 = load ptr, ptr %dot, align 8
  %53 = load ptr, ptr %D.addr, align 8
  %firstSigDigit47 = getelementptr inbounds %"struct.llvh::decimalInfo", ptr %53, i32 0, i32 0
  %54 = load ptr, ptr %firstSigDigit47, align 8
  %cmp48 = icmp ugt ptr %52, %54
  br i1 %cmp48, label %land.rhs49, label %land.end51

land.rhs49:                                       ; preds = %if.end36
  %55 = load ptr, ptr %dot, align 8
  %56 = load ptr, ptr %p, align 8
  %cmp50 = icmp ult ptr %55, %56
  br label %land.end51

land.end51:                                       ; preds = %land.rhs49, %if.end36
  %57 = phi i1 [ false, %if.end36 ], [ %cmp50, %land.rhs49 ]
  %conv52 = zext i1 %57 to i64
  %sub53 = sub nsw i64 %sub.ptr.sub46, %conv52
  %conv54 = trunc i64 %sub53 to i16
  %conv55 = sext i16 %conv54 to i32
  %add56 = add nsw i32 %48, %conv55
  %58 = load ptr, ptr %D.addr, align 8
  %normalizedExponent57 = getelementptr inbounds %"struct.llvh::decimalInfo", ptr %58, i32 0, i32 3
  store i32 %add56, ptr %normalizedExponent57, align 4
  br label %if.end58

if.end58:                                         ; preds = %land.end51, %if.end18
  %59 = load ptr, ptr %p, align 8
  %60 = load ptr, ptr %D.addr, align 8
  %lastSigDigit = getelementptr inbounds %"struct.llvh::decimalInfo", ptr %60, i32 0, i32 1
  store ptr %59, ptr %lastSigDigit, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZN4llvhL13decDigitValueEj(i32 noundef %c) #1 {
entry:
  %c.addr = alloca i32, align 4
  store i32 %c, ptr %c.addr, align 4
  %0 = load i32, ptr %c.addr, align 4
  %sub = sub i32 %0, 48
  ret i32 %sub
}

declare noundef i32 @_ZN4llvh5APInt14tcMultiplyPartEPmPKmmmjjb(ptr noundef, ptr noundef, i64 noundef, i64 noundef, i32 noundef, i32 noundef, i1 noundef zeroext) #5

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef zeroext i1 @_ZN4llvh6detail9IEEEFloat25convertFromStringSpecialsENS_9StringRefE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr %str.coerce0, i64 %str.coerce1) #1 align 2 {
entry:
  %retval.i298 = alloca i32, align 4
  %Lhs.addr.i299 = alloca ptr, align 8
  %Rhs.addr.i300 = alloca ptr, align 8
  %Length.addr.i301 = alloca i64, align 8
  %retval.i289 = alloca i32, align 4
  %Lhs.addr.i290 = alloca ptr, align 8
  %Rhs.addr.i291 = alloca ptr, align 8
  %Length.addr.i292 = alloca i64, align 8
  %retval.i280 = alloca i32, align 4
  %Lhs.addr.i281 = alloca ptr, align 8
  %Rhs.addr.i282 = alloca ptr, align 8
  %Length.addr.i283 = alloca i64, align 8
  %retval.i271 = alloca i32, align 4
  %Lhs.addr.i272 = alloca ptr, align 8
  %Rhs.addr.i273 = alloca ptr, align 8
  %Length.addr.i274 = alloca i64, align 8
  %retval.i262 = alloca i32, align 4
  %Lhs.addr.i263 = alloca ptr, align 8
  %Rhs.addr.i264 = alloca ptr, align 8
  %Length.addr.i265 = alloca i64, align 8
  %retval.i253 = alloca i32, align 4
  %Lhs.addr.i254 = alloca ptr, align 8
  %Rhs.addr.i255 = alloca ptr, align 8
  %Length.addr.i256 = alloca i64, align 8
  %retval.i244 = alloca i32, align 4
  %Lhs.addr.i245 = alloca ptr, align 8
  %Rhs.addr.i246 = alloca ptr, align 8
  %Length.addr.i247 = alloca i64, align 8
  %retval.i235 = alloca i32, align 4
  %Lhs.addr.i236 = alloca ptr, align 8
  %Rhs.addr.i237 = alloca ptr, align 8
  %Length.addr.i238 = alloca i64, align 8
  %retval.i226 = alloca i32, align 4
  %Lhs.addr.i227 = alloca ptr, align 8
  %Rhs.addr.i228 = alloca ptr, align 8
  %Length.addr.i229 = alloca i64, align 8
  %retval.i = alloca i32, align 4
  %Lhs.addr.i = alloca ptr, align 8
  %Rhs.addr.i = alloca ptr, align 8
  %Length.addr.i = alloca i64, align 8
  %this.addr.i214 = alloca ptr, align 8
  %Str.addr.i215 = alloca ptr, align 8
  %this.addr.i204 = alloca ptr, align 8
  %Str.addr.i205 = alloca ptr, align 8
  %this.addr.i194 = alloca ptr, align 8
  %Str.addr.i195 = alloca ptr, align 8
  %this.addr.i184 = alloca ptr, align 8
  %Str.addr.i185 = alloca ptr, align 8
  %this.addr.i174 = alloca ptr, align 8
  %Str.addr.i175 = alloca ptr, align 8
  %this.addr.i164 = alloca ptr, align 8
  %Str.addr.i165 = alloca ptr, align 8
  %this.addr.i154 = alloca ptr, align 8
  %Str.addr.i155 = alloca ptr, align 8
  %this.addr.i144 = alloca ptr, align 8
  %Str.addr.i145 = alloca ptr, align 8
  %this.addr.i134 = alloca ptr, align 8
  %Str.addr.i135 = alloca ptr, align 8
  %this.addr.i130 = alloca ptr, align 8
  %Str.addr.i = alloca ptr, align 8
  %RHS.i119 = alloca %"class.llvh::StringRef", align 8
  %this.addr.i120 = alloca ptr, align 8
  %RHS.i108 = alloca %"class.llvh::StringRef", align 8
  %this.addr.i109 = alloca ptr, align 8
  %RHS.i97 = alloca %"class.llvh::StringRef", align 8
  %this.addr.i98 = alloca ptr, align 8
  %RHS.i86 = alloca %"class.llvh::StringRef", align 8
  %this.addr.i87 = alloca ptr, align 8
  %RHS.i75 = alloca %"class.llvh::StringRef", align 8
  %this.addr.i76 = alloca ptr, align 8
  %RHS.i64 = alloca %"class.llvh::StringRef", align 8
  %this.addr.i65 = alloca ptr, align 8
  %RHS.i53 = alloca %"class.llvh::StringRef", align 8
  %this.addr.i54 = alloca ptr, align 8
  %RHS.i42 = alloca %"class.llvh::StringRef", align 8
  %this.addr.i43 = alloca ptr, align 8
  %RHS.i31 = alloca %"class.llvh::StringRef", align 8
  %this.addr.i32 = alloca ptr, align 8
  %RHS.i = alloca %"class.llvh::StringRef", align 8
  %this.addr.i = alloca ptr, align 8
  %retval = alloca i1, align 1
  %str = alloca %"class.llvh::StringRef", align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.llvh::StringRef", align 8
  %agg.tmp2 = alloca %"class.llvh::StringRef", align 8
  %agg.tmp5 = alloca %"class.llvh::StringRef", align 8
  %agg.tmp7 = alloca %"class.llvh::StringRef", align 8
  %agg.tmp10 = alloca %"class.llvh::StringRef", align 8
  %agg.tmp13 = alloca %"class.llvh::StringRef", align 8
  %agg.tmp17 = alloca %"class.llvh::StringRef", align 8
  %agg.tmp20 = alloca %"class.llvh::StringRef", align 8
  %agg.tmp24 = alloca %"class.llvh::StringRef", align 8
  %agg.tmp27 = alloca %"class.llvh::StringRef", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %str, i32 0, i32 0
  store ptr %str.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %str, i32 0, i32 1
  store i64 %str.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store ptr %agg.tmp, ptr %this.addr.i130, align 8
  store ptr @.str, ptr %Str.addr.i, align 8
  %this1.i131 = load ptr, ptr %this.addr.i130, align 8
  %2 = load ptr, ptr %Str.addr.i, align 8
  store ptr %2, ptr %this1.i131, align 8
  %Length.i132 = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i131, i32 0, i32 1
  %3 = load ptr, ptr %Str.addr.i, align 8
  %tobool.i = icmp ne ptr %3, null
  br i1 %tobool.i, label %cond.true.i, label %cond.false.i

cond.true.i:                                      ; preds = %entry
  %4 = load ptr, ptr %Str.addr.i, align 8
  %call.i133 = call i64 @strlen(ptr noundef %4) #15
  br label %_ZN4llvh9StringRefC2EPKc.exit

cond.false.i:                                     ; preds = %entry
  br label %_ZN4llvh9StringRefC2EPKc.exit

_ZN4llvh9StringRefC2EPKc.exit:                    ; preds = %cond.false.i, %cond.true.i
  %cond.i = phi i64 [ %call.i133, %cond.true.i ], [ 0, %cond.false.i ]
  store i64 %cond.i, ptr %Length.i132, align 8
  %5 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %6 = load ptr, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %8 = load i64, ptr %7, align 8
  store ptr %6, ptr %RHS.i119, align 8
  %9 = getelementptr inbounds { ptr, i64 }, ptr %RHS.i119, i32 0, i32 1
  store i64 %8, ptr %9, align 8
  store ptr %str, ptr %this.addr.i120, align 8
  %this1.i121 = load ptr, ptr %this.addr.i120, align 8
  %Length.i122 = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i121, i32 0, i32 1
  %10 = load i64, ptr %Length.i122, align 8
  %Length2.i123 = getelementptr inbounds %"class.llvh::StringRef", ptr %RHS.i119, i32 0, i32 1
  %11 = load i64, ptr %Length2.i123, align 8
  %cmp.i124 = icmp eq i64 %10, %11
  br i1 %cmp.i124, label %land.rhs.i125, label %_ZNK4llvh9StringRef6equalsES0_.exit129

land.rhs.i125:                                    ; preds = %_ZN4llvh9StringRefC2EPKc.exit
  %12 = load ptr, ptr %this1.i121, align 8
  %13 = load ptr, ptr %RHS.i119, align 8
  %Length4.i126 = getelementptr inbounds %"class.llvh::StringRef", ptr %RHS.i119, i32 0, i32 1
  %14 = load i64, ptr %Length4.i126, align 8
  store ptr %12, ptr %Lhs.addr.i, align 8
  store ptr %13, ptr %Rhs.addr.i, align 8
  store i64 %14, ptr %Length.addr.i, align 8
  %15 = load i64, ptr %Length.addr.i, align 8
  %cmp.i224 = icmp eq i64 %15, 0
  br i1 %cmp.i224, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %land.rhs.i125
  store i32 0, ptr %retval.i, align 4
  br label %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit

if.end.i:                                         ; preds = %land.rhs.i125
  %16 = load ptr, ptr %Lhs.addr.i, align 8
  %17 = load ptr, ptr %Rhs.addr.i, align 8
  %18 = load i64, ptr %Length.addr.i, align 8
  %call.i225 = call i32 @memcmp(ptr noundef %16, ptr noundef %17, i64 noundef %18) #15
  store i32 %call.i225, ptr %retval.i, align 4
  br label %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit

_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit:   ; preds = %if.end.i, %if.then.i
  %19 = load i32, ptr %retval.i, align 4
  %cmp5.i128 = icmp eq i32 %19, 0
  br label %_ZNK4llvh9StringRef6equalsES0_.exit129

_ZNK4llvh9StringRef6equalsES0_.exit129:           ; preds = %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit, %_ZN4llvh9StringRefC2EPKc.exit
  %20 = phi i1 [ false, %_ZN4llvh9StringRefC2EPKc.exit ], [ %cmp5.i128, %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit ]
  br i1 %20, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %_ZNK4llvh9StringRef6equalsES0_.exit129
  store ptr %agg.tmp2, ptr %this.addr.i134, align 8
  store ptr @.str.1, ptr %Str.addr.i135, align 8
  %this1.i136 = load ptr, ptr %this.addr.i134, align 8
  %21 = load ptr, ptr %Str.addr.i135, align 8
  store ptr %21, ptr %this1.i136, align 8
  %Length.i137 = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i136, i32 0, i32 1
  %22 = load ptr, ptr %Str.addr.i135, align 8
  %tobool.i138 = icmp ne ptr %22, null
  br i1 %tobool.i138, label %cond.true.i141, label %cond.false.i139

cond.true.i141:                                   ; preds = %lor.lhs.false
  %23 = load ptr, ptr %Str.addr.i135, align 8
  %call.i142 = call i64 @strlen(ptr noundef %23) #15
  br label %_ZN4llvh9StringRefC2EPKc.exit143

cond.false.i139:                                  ; preds = %lor.lhs.false
  br label %_ZN4llvh9StringRefC2EPKc.exit143

_ZN4llvh9StringRefC2EPKc.exit143:                 ; preds = %cond.false.i139, %cond.true.i141
  %cond.i140 = phi i64 [ %call.i142, %cond.true.i141 ], [ 0, %cond.false.i139 ]
  store i64 %cond.i140, ptr %Length.i137, align 8
  %24 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 0
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 1
  %27 = load i64, ptr %26, align 8
  store ptr %25, ptr %RHS.i108, align 8
  %28 = getelementptr inbounds { ptr, i64 }, ptr %RHS.i108, i32 0, i32 1
  store i64 %27, ptr %28, align 8
  store ptr %str, ptr %this.addr.i109, align 8
  %this1.i110 = load ptr, ptr %this.addr.i109, align 8
  %Length.i111 = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i110, i32 0, i32 1
  %29 = load i64, ptr %Length.i111, align 8
  %Length2.i112 = getelementptr inbounds %"class.llvh::StringRef", ptr %RHS.i108, i32 0, i32 1
  %30 = load i64, ptr %Length2.i112, align 8
  %cmp.i113 = icmp eq i64 %29, %30
  br i1 %cmp.i113, label %land.rhs.i114, label %_ZNK4llvh9StringRef6equalsES0_.exit118

land.rhs.i114:                                    ; preds = %_ZN4llvh9StringRefC2EPKc.exit143
  %31 = load ptr, ptr %this1.i110, align 8
  %32 = load ptr, ptr %RHS.i108, align 8
  %Length4.i115 = getelementptr inbounds %"class.llvh::StringRef", ptr %RHS.i108, i32 0, i32 1
  %33 = load i64, ptr %Length4.i115, align 8
  store ptr %31, ptr %Lhs.addr.i227, align 8
  store ptr %32, ptr %Rhs.addr.i228, align 8
  store i64 %33, ptr %Length.addr.i229, align 8
  %34 = load i64, ptr %Length.addr.i229, align 8
  %cmp.i230 = icmp eq i64 %34, 0
  br i1 %cmp.i230, label %if.then.i233, label %if.end.i231

if.then.i233:                                     ; preds = %land.rhs.i114
  store i32 0, ptr %retval.i226, align 4
  br label %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit234

if.end.i231:                                      ; preds = %land.rhs.i114
  %35 = load ptr, ptr %Lhs.addr.i227, align 8
  %36 = load ptr, ptr %Rhs.addr.i228, align 8
  %37 = load i64, ptr %Length.addr.i229, align 8
  %call.i232 = call i32 @memcmp(ptr noundef %35, ptr noundef %36, i64 noundef %37) #15
  store i32 %call.i232, ptr %retval.i226, align 4
  br label %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit234

_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit234: ; preds = %if.end.i231, %if.then.i233
  %38 = load i32, ptr %retval.i226, align 4
  %cmp5.i117 = icmp eq i32 %38, 0
  br label %_ZNK4llvh9StringRef6equalsES0_.exit118

_ZNK4llvh9StringRef6equalsES0_.exit118:           ; preds = %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit234, %_ZN4llvh9StringRefC2EPKc.exit143
  %39 = phi i1 [ false, %_ZN4llvh9StringRefC2EPKc.exit143 ], [ %cmp5.i117, %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit234 ]
  br i1 %39, label %if.then, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %_ZNK4llvh9StringRef6equalsES0_.exit118
  store ptr %agg.tmp5, ptr %this.addr.i144, align 8
  store ptr @.str.2, ptr %Str.addr.i145, align 8
  %this1.i146 = load ptr, ptr %this.addr.i144, align 8
  %40 = load ptr, ptr %Str.addr.i145, align 8
  store ptr %40, ptr %this1.i146, align 8
  %Length.i147 = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i146, i32 0, i32 1
  %41 = load ptr, ptr %Str.addr.i145, align 8
  %tobool.i148 = icmp ne ptr %41, null
  br i1 %tobool.i148, label %cond.true.i151, label %cond.false.i149

cond.true.i151:                                   ; preds = %lor.lhs.false4
  %42 = load ptr, ptr %Str.addr.i145, align 8
  %call.i152 = call i64 @strlen(ptr noundef %42) #15
  br label %_ZN4llvh9StringRefC2EPKc.exit153

cond.false.i149:                                  ; preds = %lor.lhs.false4
  br label %_ZN4llvh9StringRefC2EPKc.exit153

_ZN4llvh9StringRefC2EPKc.exit153:                 ; preds = %cond.false.i149, %cond.true.i151
  %cond.i150 = phi i64 [ %call.i152, %cond.true.i151 ], [ 0, %cond.false.i149 ]
  store i64 %cond.i150, ptr %Length.i147, align 8
  %43 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp5, i32 0, i32 0
  %44 = load ptr, ptr %43, align 8
  %45 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp5, i32 0, i32 1
  %46 = load i64, ptr %45, align 8
  store ptr %44, ptr %RHS.i97, align 8
  %47 = getelementptr inbounds { ptr, i64 }, ptr %RHS.i97, i32 0, i32 1
  store i64 %46, ptr %47, align 8
  store ptr %str, ptr %this.addr.i98, align 8
  %this1.i99 = load ptr, ptr %this.addr.i98, align 8
  %Length.i100 = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i99, i32 0, i32 1
  %48 = load i64, ptr %Length.i100, align 8
  %Length2.i101 = getelementptr inbounds %"class.llvh::StringRef", ptr %RHS.i97, i32 0, i32 1
  %49 = load i64, ptr %Length2.i101, align 8
  %cmp.i102 = icmp eq i64 %48, %49
  br i1 %cmp.i102, label %land.rhs.i103, label %_ZNK4llvh9StringRef6equalsES0_.exit107

land.rhs.i103:                                    ; preds = %_ZN4llvh9StringRefC2EPKc.exit153
  %50 = load ptr, ptr %this1.i99, align 8
  %51 = load ptr, ptr %RHS.i97, align 8
  %Length4.i104 = getelementptr inbounds %"class.llvh::StringRef", ptr %RHS.i97, i32 0, i32 1
  %52 = load i64, ptr %Length4.i104, align 8
  store ptr %50, ptr %Lhs.addr.i236, align 8
  store ptr %51, ptr %Rhs.addr.i237, align 8
  store i64 %52, ptr %Length.addr.i238, align 8
  %53 = load i64, ptr %Length.addr.i238, align 8
  %cmp.i239 = icmp eq i64 %53, 0
  br i1 %cmp.i239, label %if.then.i242, label %if.end.i240

if.then.i242:                                     ; preds = %land.rhs.i103
  store i32 0, ptr %retval.i235, align 4
  br label %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit243

if.end.i240:                                      ; preds = %land.rhs.i103
  %54 = load ptr, ptr %Lhs.addr.i236, align 8
  %55 = load ptr, ptr %Rhs.addr.i237, align 8
  %56 = load i64, ptr %Length.addr.i238, align 8
  %call.i241 = call i32 @memcmp(ptr noundef %54, ptr noundef %55, i64 noundef %56) #15
  store i32 %call.i241, ptr %retval.i235, align 4
  br label %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit243

_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit243: ; preds = %if.end.i240, %if.then.i242
  %57 = load i32, ptr %retval.i235, align 4
  %cmp5.i106 = icmp eq i32 %57, 0
  br label %_ZNK4llvh9StringRef6equalsES0_.exit107

_ZNK4llvh9StringRef6equalsES0_.exit107:           ; preds = %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit243, %_ZN4llvh9StringRefC2EPKc.exit153
  %58 = phi i1 [ false, %_ZN4llvh9StringRefC2EPKc.exit153 ], [ %cmp5.i106, %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit243 ]
  br i1 %58, label %if.then, label %if.end

if.then:                                          ; preds = %_ZNK4llvh9StringRef6equalsES0_.exit107, %_ZNK4llvh9StringRef6equalsES0_.exit118, %_ZNK4llvh9StringRef6equalsES0_.exit129
  call void @_ZN4llvh6detail9IEEEFloat7makeInfEb(ptr noundef nonnull align 8 dereferenceable(24) %this1, i1 noundef zeroext false)
  store i1 true, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %_ZNK4llvh9StringRef6equalsES0_.exit107
  store ptr %agg.tmp7, ptr %this.addr.i154, align 8
  store ptr @.str.3, ptr %Str.addr.i155, align 8
  %this1.i156 = load ptr, ptr %this.addr.i154, align 8
  %59 = load ptr, ptr %Str.addr.i155, align 8
  store ptr %59, ptr %this1.i156, align 8
  %Length.i157 = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i156, i32 0, i32 1
  %60 = load ptr, ptr %Str.addr.i155, align 8
  %tobool.i158 = icmp ne ptr %60, null
  br i1 %tobool.i158, label %cond.true.i161, label %cond.false.i159

cond.true.i161:                                   ; preds = %if.end
  %61 = load ptr, ptr %Str.addr.i155, align 8
  %call.i162 = call i64 @strlen(ptr noundef %61) #15
  br label %_ZN4llvh9StringRefC2EPKc.exit163

cond.false.i159:                                  ; preds = %if.end
  br label %_ZN4llvh9StringRefC2EPKc.exit163

_ZN4llvh9StringRefC2EPKc.exit163:                 ; preds = %cond.false.i159, %cond.true.i161
  %cond.i160 = phi i64 [ %call.i162, %cond.true.i161 ], [ 0, %cond.false.i159 ]
  store i64 %cond.i160, ptr %Length.i157, align 8
  %62 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp7, i32 0, i32 0
  %63 = load ptr, ptr %62, align 8
  %64 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp7, i32 0, i32 1
  %65 = load i64, ptr %64, align 8
  store ptr %63, ptr %RHS.i86, align 8
  %66 = getelementptr inbounds { ptr, i64 }, ptr %RHS.i86, i32 0, i32 1
  store i64 %65, ptr %66, align 8
  store ptr %str, ptr %this.addr.i87, align 8
  %this1.i88 = load ptr, ptr %this.addr.i87, align 8
  %Length.i89 = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i88, i32 0, i32 1
  %67 = load i64, ptr %Length.i89, align 8
  %Length2.i90 = getelementptr inbounds %"class.llvh::StringRef", ptr %RHS.i86, i32 0, i32 1
  %68 = load i64, ptr %Length2.i90, align 8
  %cmp.i91 = icmp eq i64 %67, %68
  br i1 %cmp.i91, label %land.rhs.i92, label %_ZNK4llvh9StringRef6equalsES0_.exit96

land.rhs.i92:                                     ; preds = %_ZN4llvh9StringRefC2EPKc.exit163
  %69 = load ptr, ptr %this1.i88, align 8
  %70 = load ptr, ptr %RHS.i86, align 8
  %Length4.i93 = getelementptr inbounds %"class.llvh::StringRef", ptr %RHS.i86, i32 0, i32 1
  %71 = load i64, ptr %Length4.i93, align 8
  store ptr %69, ptr %Lhs.addr.i245, align 8
  store ptr %70, ptr %Rhs.addr.i246, align 8
  store i64 %71, ptr %Length.addr.i247, align 8
  %72 = load i64, ptr %Length.addr.i247, align 8
  %cmp.i248 = icmp eq i64 %72, 0
  br i1 %cmp.i248, label %if.then.i251, label %if.end.i249

if.then.i251:                                     ; preds = %land.rhs.i92
  store i32 0, ptr %retval.i244, align 4
  br label %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit252

if.end.i249:                                      ; preds = %land.rhs.i92
  %73 = load ptr, ptr %Lhs.addr.i245, align 8
  %74 = load ptr, ptr %Rhs.addr.i246, align 8
  %75 = load i64, ptr %Length.addr.i247, align 8
  %call.i250 = call i32 @memcmp(ptr noundef %73, ptr noundef %74, i64 noundef %75) #15
  store i32 %call.i250, ptr %retval.i244, align 4
  br label %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit252

_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit252: ; preds = %if.end.i249, %if.then.i251
  %76 = load i32, ptr %retval.i244, align 4
  %cmp5.i95 = icmp eq i32 %76, 0
  br label %_ZNK4llvh9StringRef6equalsES0_.exit96

_ZNK4llvh9StringRef6equalsES0_.exit96:            ; preds = %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit252, %_ZN4llvh9StringRefC2EPKc.exit163
  %77 = phi i1 [ false, %_ZN4llvh9StringRefC2EPKc.exit163 ], [ %cmp5.i95, %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit252 ]
  br i1 %77, label %if.then15, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %_ZNK4llvh9StringRef6equalsES0_.exit96
  store ptr %agg.tmp10, ptr %this.addr.i164, align 8
  store ptr @.str.4, ptr %Str.addr.i165, align 8
  %this1.i166 = load ptr, ptr %this.addr.i164, align 8
  %78 = load ptr, ptr %Str.addr.i165, align 8
  store ptr %78, ptr %this1.i166, align 8
  %Length.i167 = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i166, i32 0, i32 1
  %79 = load ptr, ptr %Str.addr.i165, align 8
  %tobool.i168 = icmp ne ptr %79, null
  br i1 %tobool.i168, label %cond.true.i171, label %cond.false.i169

cond.true.i171:                                   ; preds = %lor.lhs.false9
  %80 = load ptr, ptr %Str.addr.i165, align 8
  %call.i172 = call i64 @strlen(ptr noundef %80) #15
  br label %_ZN4llvh9StringRefC2EPKc.exit173

cond.false.i169:                                  ; preds = %lor.lhs.false9
  br label %_ZN4llvh9StringRefC2EPKc.exit173

_ZN4llvh9StringRefC2EPKc.exit173:                 ; preds = %cond.false.i169, %cond.true.i171
  %cond.i170 = phi i64 [ %call.i172, %cond.true.i171 ], [ 0, %cond.false.i169 ]
  store i64 %cond.i170, ptr %Length.i167, align 8
  %81 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp10, i32 0, i32 0
  %82 = load ptr, ptr %81, align 8
  %83 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp10, i32 0, i32 1
  %84 = load i64, ptr %83, align 8
  store ptr %82, ptr %RHS.i75, align 8
  %85 = getelementptr inbounds { ptr, i64 }, ptr %RHS.i75, i32 0, i32 1
  store i64 %84, ptr %85, align 8
  store ptr %str, ptr %this.addr.i76, align 8
  %this1.i77 = load ptr, ptr %this.addr.i76, align 8
  %Length.i78 = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i77, i32 0, i32 1
  %86 = load i64, ptr %Length.i78, align 8
  %Length2.i79 = getelementptr inbounds %"class.llvh::StringRef", ptr %RHS.i75, i32 0, i32 1
  %87 = load i64, ptr %Length2.i79, align 8
  %cmp.i80 = icmp eq i64 %86, %87
  br i1 %cmp.i80, label %land.rhs.i81, label %_ZNK4llvh9StringRef6equalsES0_.exit85

land.rhs.i81:                                     ; preds = %_ZN4llvh9StringRefC2EPKc.exit173
  %88 = load ptr, ptr %this1.i77, align 8
  %89 = load ptr, ptr %RHS.i75, align 8
  %Length4.i82 = getelementptr inbounds %"class.llvh::StringRef", ptr %RHS.i75, i32 0, i32 1
  %90 = load i64, ptr %Length4.i82, align 8
  store ptr %88, ptr %Lhs.addr.i254, align 8
  store ptr %89, ptr %Rhs.addr.i255, align 8
  store i64 %90, ptr %Length.addr.i256, align 8
  %91 = load i64, ptr %Length.addr.i256, align 8
  %cmp.i257 = icmp eq i64 %91, 0
  br i1 %cmp.i257, label %if.then.i260, label %if.end.i258

if.then.i260:                                     ; preds = %land.rhs.i81
  store i32 0, ptr %retval.i253, align 4
  br label %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit261

if.end.i258:                                      ; preds = %land.rhs.i81
  %92 = load ptr, ptr %Lhs.addr.i254, align 8
  %93 = load ptr, ptr %Rhs.addr.i255, align 8
  %94 = load i64, ptr %Length.addr.i256, align 8
  %call.i259 = call i32 @memcmp(ptr noundef %92, ptr noundef %93, i64 noundef %94) #15
  store i32 %call.i259, ptr %retval.i253, align 4
  br label %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit261

_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit261: ; preds = %if.end.i258, %if.then.i260
  %95 = load i32, ptr %retval.i253, align 4
  %cmp5.i84 = icmp eq i32 %95, 0
  br label %_ZNK4llvh9StringRef6equalsES0_.exit85

_ZNK4llvh9StringRef6equalsES0_.exit85:            ; preds = %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit261, %_ZN4llvh9StringRefC2EPKc.exit173
  %96 = phi i1 [ false, %_ZN4llvh9StringRefC2EPKc.exit173 ], [ %cmp5.i84, %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit261 ]
  br i1 %96, label %if.then15, label %lor.lhs.false12

lor.lhs.false12:                                  ; preds = %_ZNK4llvh9StringRef6equalsES0_.exit85
  store ptr %agg.tmp13, ptr %this.addr.i174, align 8
  store ptr @.str.5, ptr %Str.addr.i175, align 8
  %this1.i176 = load ptr, ptr %this.addr.i174, align 8
  %97 = load ptr, ptr %Str.addr.i175, align 8
  store ptr %97, ptr %this1.i176, align 8
  %Length.i177 = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i176, i32 0, i32 1
  %98 = load ptr, ptr %Str.addr.i175, align 8
  %tobool.i178 = icmp ne ptr %98, null
  br i1 %tobool.i178, label %cond.true.i181, label %cond.false.i179

cond.true.i181:                                   ; preds = %lor.lhs.false12
  %99 = load ptr, ptr %Str.addr.i175, align 8
  %call.i182 = call i64 @strlen(ptr noundef %99) #15
  br label %_ZN4llvh9StringRefC2EPKc.exit183

cond.false.i179:                                  ; preds = %lor.lhs.false12
  br label %_ZN4llvh9StringRefC2EPKc.exit183

_ZN4llvh9StringRefC2EPKc.exit183:                 ; preds = %cond.false.i179, %cond.true.i181
  %cond.i180 = phi i64 [ %call.i182, %cond.true.i181 ], [ 0, %cond.false.i179 ]
  store i64 %cond.i180, ptr %Length.i177, align 8
  %100 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp13, i32 0, i32 0
  %101 = load ptr, ptr %100, align 8
  %102 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp13, i32 0, i32 1
  %103 = load i64, ptr %102, align 8
  store ptr %101, ptr %RHS.i64, align 8
  %104 = getelementptr inbounds { ptr, i64 }, ptr %RHS.i64, i32 0, i32 1
  store i64 %103, ptr %104, align 8
  store ptr %str, ptr %this.addr.i65, align 8
  %this1.i66 = load ptr, ptr %this.addr.i65, align 8
  %Length.i67 = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i66, i32 0, i32 1
  %105 = load i64, ptr %Length.i67, align 8
  %Length2.i68 = getelementptr inbounds %"class.llvh::StringRef", ptr %RHS.i64, i32 0, i32 1
  %106 = load i64, ptr %Length2.i68, align 8
  %cmp.i69 = icmp eq i64 %105, %106
  br i1 %cmp.i69, label %land.rhs.i70, label %_ZNK4llvh9StringRef6equalsES0_.exit74

land.rhs.i70:                                     ; preds = %_ZN4llvh9StringRefC2EPKc.exit183
  %107 = load ptr, ptr %this1.i66, align 8
  %108 = load ptr, ptr %RHS.i64, align 8
  %Length4.i71 = getelementptr inbounds %"class.llvh::StringRef", ptr %RHS.i64, i32 0, i32 1
  %109 = load i64, ptr %Length4.i71, align 8
  store ptr %107, ptr %Lhs.addr.i263, align 8
  store ptr %108, ptr %Rhs.addr.i264, align 8
  store i64 %109, ptr %Length.addr.i265, align 8
  %110 = load i64, ptr %Length.addr.i265, align 8
  %cmp.i266 = icmp eq i64 %110, 0
  br i1 %cmp.i266, label %if.then.i269, label %if.end.i267

if.then.i269:                                     ; preds = %land.rhs.i70
  store i32 0, ptr %retval.i262, align 4
  br label %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit270

if.end.i267:                                      ; preds = %land.rhs.i70
  %111 = load ptr, ptr %Lhs.addr.i263, align 8
  %112 = load ptr, ptr %Rhs.addr.i264, align 8
  %113 = load i64, ptr %Length.addr.i265, align 8
  %call.i268 = call i32 @memcmp(ptr noundef %111, ptr noundef %112, i64 noundef %113) #15
  store i32 %call.i268, ptr %retval.i262, align 4
  br label %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit270

_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit270: ; preds = %if.end.i267, %if.then.i269
  %114 = load i32, ptr %retval.i262, align 4
  %cmp5.i73 = icmp eq i32 %114, 0
  br label %_ZNK4llvh9StringRef6equalsES0_.exit74

_ZNK4llvh9StringRef6equalsES0_.exit74:            ; preds = %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit270, %_ZN4llvh9StringRefC2EPKc.exit183
  %115 = phi i1 [ false, %_ZN4llvh9StringRefC2EPKc.exit183 ], [ %cmp5.i73, %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit270 ]
  br i1 %115, label %if.then15, label %if.end16

if.then15:                                        ; preds = %_ZNK4llvh9StringRef6equalsES0_.exit74, %_ZNK4llvh9StringRef6equalsES0_.exit85, %_ZNK4llvh9StringRef6equalsES0_.exit96
  call void @_ZN4llvh6detail9IEEEFloat7makeInfEb(ptr noundef nonnull align 8 dereferenceable(24) %this1, i1 noundef zeroext true)
  store i1 true, ptr %retval, align 1
  br label %return

if.end16:                                         ; preds = %_ZNK4llvh9StringRef6equalsES0_.exit74
  store ptr %agg.tmp17, ptr %this.addr.i184, align 8
  store ptr @.str.6, ptr %Str.addr.i185, align 8
  %this1.i186 = load ptr, ptr %this.addr.i184, align 8
  %116 = load ptr, ptr %Str.addr.i185, align 8
  store ptr %116, ptr %this1.i186, align 8
  %Length.i187 = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i186, i32 0, i32 1
  %117 = load ptr, ptr %Str.addr.i185, align 8
  %tobool.i188 = icmp ne ptr %117, null
  br i1 %tobool.i188, label %cond.true.i191, label %cond.false.i189

cond.true.i191:                                   ; preds = %if.end16
  %118 = load ptr, ptr %Str.addr.i185, align 8
  %call.i192 = call i64 @strlen(ptr noundef %118) #15
  br label %_ZN4llvh9StringRefC2EPKc.exit193

cond.false.i189:                                  ; preds = %if.end16
  br label %_ZN4llvh9StringRefC2EPKc.exit193

_ZN4llvh9StringRefC2EPKc.exit193:                 ; preds = %cond.false.i189, %cond.true.i191
  %cond.i190 = phi i64 [ %call.i192, %cond.true.i191 ], [ 0, %cond.false.i189 ]
  store i64 %cond.i190, ptr %Length.i187, align 8
  %119 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp17, i32 0, i32 0
  %120 = load ptr, ptr %119, align 8
  %121 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp17, i32 0, i32 1
  %122 = load i64, ptr %121, align 8
  store ptr %120, ptr %RHS.i53, align 8
  %123 = getelementptr inbounds { ptr, i64 }, ptr %RHS.i53, i32 0, i32 1
  store i64 %122, ptr %123, align 8
  store ptr %str, ptr %this.addr.i54, align 8
  %this1.i55 = load ptr, ptr %this.addr.i54, align 8
  %Length.i56 = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i55, i32 0, i32 1
  %124 = load i64, ptr %Length.i56, align 8
  %Length2.i57 = getelementptr inbounds %"class.llvh::StringRef", ptr %RHS.i53, i32 0, i32 1
  %125 = load i64, ptr %Length2.i57, align 8
  %cmp.i58 = icmp eq i64 %124, %125
  br i1 %cmp.i58, label %land.rhs.i59, label %_ZNK4llvh9StringRef6equalsES0_.exit63

land.rhs.i59:                                     ; preds = %_ZN4llvh9StringRefC2EPKc.exit193
  %126 = load ptr, ptr %this1.i55, align 8
  %127 = load ptr, ptr %RHS.i53, align 8
  %Length4.i60 = getelementptr inbounds %"class.llvh::StringRef", ptr %RHS.i53, i32 0, i32 1
  %128 = load i64, ptr %Length4.i60, align 8
  store ptr %126, ptr %Lhs.addr.i272, align 8
  store ptr %127, ptr %Rhs.addr.i273, align 8
  store i64 %128, ptr %Length.addr.i274, align 8
  %129 = load i64, ptr %Length.addr.i274, align 8
  %cmp.i275 = icmp eq i64 %129, 0
  br i1 %cmp.i275, label %if.then.i278, label %if.end.i276

if.then.i278:                                     ; preds = %land.rhs.i59
  store i32 0, ptr %retval.i271, align 4
  br label %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit279

if.end.i276:                                      ; preds = %land.rhs.i59
  %130 = load ptr, ptr %Lhs.addr.i272, align 8
  %131 = load ptr, ptr %Rhs.addr.i273, align 8
  %132 = load i64, ptr %Length.addr.i274, align 8
  %call.i277 = call i32 @memcmp(ptr noundef %130, ptr noundef %131, i64 noundef %132) #15
  store i32 %call.i277, ptr %retval.i271, align 4
  br label %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit279

_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit279: ; preds = %if.end.i276, %if.then.i278
  %133 = load i32, ptr %retval.i271, align 4
  %cmp5.i62 = icmp eq i32 %133, 0
  br label %_ZNK4llvh9StringRef6equalsES0_.exit63

_ZNK4llvh9StringRef6equalsES0_.exit63:            ; preds = %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit279, %_ZN4llvh9StringRefC2EPKc.exit193
  %134 = phi i1 [ false, %_ZN4llvh9StringRefC2EPKc.exit193 ], [ %cmp5.i62, %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit279 ]
  br i1 %134, label %if.then22, label %lor.lhs.false19

lor.lhs.false19:                                  ; preds = %_ZNK4llvh9StringRef6equalsES0_.exit63
  store ptr %agg.tmp20, ptr %this.addr.i194, align 8
  store ptr @.str.7, ptr %Str.addr.i195, align 8
  %this1.i196 = load ptr, ptr %this.addr.i194, align 8
  %135 = load ptr, ptr %Str.addr.i195, align 8
  store ptr %135, ptr %this1.i196, align 8
  %Length.i197 = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i196, i32 0, i32 1
  %136 = load ptr, ptr %Str.addr.i195, align 8
  %tobool.i198 = icmp ne ptr %136, null
  br i1 %tobool.i198, label %cond.true.i201, label %cond.false.i199

cond.true.i201:                                   ; preds = %lor.lhs.false19
  %137 = load ptr, ptr %Str.addr.i195, align 8
  %call.i202 = call i64 @strlen(ptr noundef %137) #15
  br label %_ZN4llvh9StringRefC2EPKc.exit203

cond.false.i199:                                  ; preds = %lor.lhs.false19
  br label %_ZN4llvh9StringRefC2EPKc.exit203

_ZN4llvh9StringRefC2EPKc.exit203:                 ; preds = %cond.false.i199, %cond.true.i201
  %cond.i200 = phi i64 [ %call.i202, %cond.true.i201 ], [ 0, %cond.false.i199 ]
  store i64 %cond.i200, ptr %Length.i197, align 8
  %138 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp20, i32 0, i32 0
  %139 = load ptr, ptr %138, align 8
  %140 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp20, i32 0, i32 1
  %141 = load i64, ptr %140, align 8
  store ptr %139, ptr %RHS.i42, align 8
  %142 = getelementptr inbounds { ptr, i64 }, ptr %RHS.i42, i32 0, i32 1
  store i64 %141, ptr %142, align 8
  store ptr %str, ptr %this.addr.i43, align 8
  %this1.i44 = load ptr, ptr %this.addr.i43, align 8
  %Length.i45 = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i44, i32 0, i32 1
  %143 = load i64, ptr %Length.i45, align 8
  %Length2.i46 = getelementptr inbounds %"class.llvh::StringRef", ptr %RHS.i42, i32 0, i32 1
  %144 = load i64, ptr %Length2.i46, align 8
  %cmp.i47 = icmp eq i64 %143, %144
  br i1 %cmp.i47, label %land.rhs.i48, label %_ZNK4llvh9StringRef6equalsES0_.exit52

land.rhs.i48:                                     ; preds = %_ZN4llvh9StringRefC2EPKc.exit203
  %145 = load ptr, ptr %this1.i44, align 8
  %146 = load ptr, ptr %RHS.i42, align 8
  %Length4.i49 = getelementptr inbounds %"class.llvh::StringRef", ptr %RHS.i42, i32 0, i32 1
  %147 = load i64, ptr %Length4.i49, align 8
  store ptr %145, ptr %Lhs.addr.i281, align 8
  store ptr %146, ptr %Rhs.addr.i282, align 8
  store i64 %147, ptr %Length.addr.i283, align 8
  %148 = load i64, ptr %Length.addr.i283, align 8
  %cmp.i284 = icmp eq i64 %148, 0
  br i1 %cmp.i284, label %if.then.i287, label %if.end.i285

if.then.i287:                                     ; preds = %land.rhs.i48
  store i32 0, ptr %retval.i280, align 4
  br label %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit288

if.end.i285:                                      ; preds = %land.rhs.i48
  %149 = load ptr, ptr %Lhs.addr.i281, align 8
  %150 = load ptr, ptr %Rhs.addr.i282, align 8
  %151 = load i64, ptr %Length.addr.i283, align 8
  %call.i286 = call i32 @memcmp(ptr noundef %149, ptr noundef %150, i64 noundef %151) #15
  store i32 %call.i286, ptr %retval.i280, align 4
  br label %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit288

_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit288: ; preds = %if.end.i285, %if.then.i287
  %152 = load i32, ptr %retval.i280, align 4
  %cmp5.i51 = icmp eq i32 %152, 0
  br label %_ZNK4llvh9StringRef6equalsES0_.exit52

_ZNK4llvh9StringRef6equalsES0_.exit52:            ; preds = %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit288, %_ZN4llvh9StringRefC2EPKc.exit203
  %153 = phi i1 [ false, %_ZN4llvh9StringRefC2EPKc.exit203 ], [ %cmp5.i51, %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit288 ]
  br i1 %153, label %if.then22, label %if.end23

if.then22:                                        ; preds = %_ZNK4llvh9StringRef6equalsES0_.exit52, %_ZNK4llvh9StringRef6equalsES0_.exit63
  call void @_ZN4llvh6detail9IEEEFloat7makeNaNEbbPKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this1, i1 noundef zeroext false, i1 noundef zeroext false, ptr noundef null)
  store i1 true, ptr %retval, align 1
  br label %return

if.end23:                                         ; preds = %_ZNK4llvh9StringRef6equalsES0_.exit52
  store ptr %agg.tmp24, ptr %this.addr.i204, align 8
  store ptr @.str.8, ptr %Str.addr.i205, align 8
  %this1.i206 = load ptr, ptr %this.addr.i204, align 8
  %154 = load ptr, ptr %Str.addr.i205, align 8
  store ptr %154, ptr %this1.i206, align 8
  %Length.i207 = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i206, i32 0, i32 1
  %155 = load ptr, ptr %Str.addr.i205, align 8
  %tobool.i208 = icmp ne ptr %155, null
  br i1 %tobool.i208, label %cond.true.i211, label %cond.false.i209

cond.true.i211:                                   ; preds = %if.end23
  %156 = load ptr, ptr %Str.addr.i205, align 8
  %call.i212 = call i64 @strlen(ptr noundef %156) #15
  br label %_ZN4llvh9StringRefC2EPKc.exit213

cond.false.i209:                                  ; preds = %if.end23
  br label %_ZN4llvh9StringRefC2EPKc.exit213

_ZN4llvh9StringRefC2EPKc.exit213:                 ; preds = %cond.false.i209, %cond.true.i211
  %cond.i210 = phi i64 [ %call.i212, %cond.true.i211 ], [ 0, %cond.false.i209 ]
  store i64 %cond.i210, ptr %Length.i207, align 8
  %157 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp24, i32 0, i32 0
  %158 = load ptr, ptr %157, align 8
  %159 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp24, i32 0, i32 1
  %160 = load i64, ptr %159, align 8
  store ptr %158, ptr %RHS.i31, align 8
  %161 = getelementptr inbounds { ptr, i64 }, ptr %RHS.i31, i32 0, i32 1
  store i64 %160, ptr %161, align 8
  store ptr %str, ptr %this.addr.i32, align 8
  %this1.i33 = load ptr, ptr %this.addr.i32, align 8
  %Length.i34 = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i33, i32 0, i32 1
  %162 = load i64, ptr %Length.i34, align 8
  %Length2.i35 = getelementptr inbounds %"class.llvh::StringRef", ptr %RHS.i31, i32 0, i32 1
  %163 = load i64, ptr %Length2.i35, align 8
  %cmp.i36 = icmp eq i64 %162, %163
  br i1 %cmp.i36, label %land.rhs.i37, label %_ZNK4llvh9StringRef6equalsES0_.exit41

land.rhs.i37:                                     ; preds = %_ZN4llvh9StringRefC2EPKc.exit213
  %164 = load ptr, ptr %this1.i33, align 8
  %165 = load ptr, ptr %RHS.i31, align 8
  %Length4.i38 = getelementptr inbounds %"class.llvh::StringRef", ptr %RHS.i31, i32 0, i32 1
  %166 = load i64, ptr %Length4.i38, align 8
  store ptr %164, ptr %Lhs.addr.i290, align 8
  store ptr %165, ptr %Rhs.addr.i291, align 8
  store i64 %166, ptr %Length.addr.i292, align 8
  %167 = load i64, ptr %Length.addr.i292, align 8
  %cmp.i293 = icmp eq i64 %167, 0
  br i1 %cmp.i293, label %if.then.i296, label %if.end.i294

if.then.i296:                                     ; preds = %land.rhs.i37
  store i32 0, ptr %retval.i289, align 4
  br label %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit297

if.end.i294:                                      ; preds = %land.rhs.i37
  %168 = load ptr, ptr %Lhs.addr.i290, align 8
  %169 = load ptr, ptr %Rhs.addr.i291, align 8
  %170 = load i64, ptr %Length.addr.i292, align 8
  %call.i295 = call i32 @memcmp(ptr noundef %168, ptr noundef %169, i64 noundef %170) #15
  store i32 %call.i295, ptr %retval.i289, align 4
  br label %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit297

_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit297: ; preds = %if.end.i294, %if.then.i296
  %171 = load i32, ptr %retval.i289, align 4
  %cmp5.i40 = icmp eq i32 %171, 0
  br label %_ZNK4llvh9StringRef6equalsES0_.exit41

_ZNK4llvh9StringRef6equalsES0_.exit41:            ; preds = %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit297, %_ZN4llvh9StringRefC2EPKc.exit213
  %172 = phi i1 [ false, %_ZN4llvh9StringRefC2EPKc.exit213 ], [ %cmp5.i40, %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit297 ]
  br i1 %172, label %if.then29, label %lor.lhs.false26

lor.lhs.false26:                                  ; preds = %_ZNK4llvh9StringRef6equalsES0_.exit41
  store ptr %agg.tmp27, ptr %this.addr.i214, align 8
  store ptr @.str.9, ptr %Str.addr.i215, align 8
  %this1.i216 = load ptr, ptr %this.addr.i214, align 8
  %173 = load ptr, ptr %Str.addr.i215, align 8
  store ptr %173, ptr %this1.i216, align 8
  %Length.i217 = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i216, i32 0, i32 1
  %174 = load ptr, ptr %Str.addr.i215, align 8
  %tobool.i218 = icmp ne ptr %174, null
  br i1 %tobool.i218, label %cond.true.i221, label %cond.false.i219

cond.true.i221:                                   ; preds = %lor.lhs.false26
  %175 = load ptr, ptr %Str.addr.i215, align 8
  %call.i222 = call i64 @strlen(ptr noundef %175) #15
  br label %_ZN4llvh9StringRefC2EPKc.exit223

cond.false.i219:                                  ; preds = %lor.lhs.false26
  br label %_ZN4llvh9StringRefC2EPKc.exit223

_ZN4llvh9StringRefC2EPKc.exit223:                 ; preds = %cond.false.i219, %cond.true.i221
  %cond.i220 = phi i64 [ %call.i222, %cond.true.i221 ], [ 0, %cond.false.i219 ]
  store i64 %cond.i220, ptr %Length.i217, align 8
  %176 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp27, i32 0, i32 0
  %177 = load ptr, ptr %176, align 8
  %178 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp27, i32 0, i32 1
  %179 = load i64, ptr %178, align 8
  store ptr %177, ptr %RHS.i, align 8
  %180 = getelementptr inbounds { ptr, i64 }, ptr %RHS.i, i32 0, i32 1
  store i64 %179, ptr %180, align 8
  store ptr %str, ptr %this.addr.i, align 8
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %Length.i = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i, i32 0, i32 1
  %181 = load i64, ptr %Length.i, align 8
  %Length2.i = getelementptr inbounds %"class.llvh::StringRef", ptr %RHS.i, i32 0, i32 1
  %182 = load i64, ptr %Length2.i, align 8
  %cmp.i = icmp eq i64 %181, %182
  br i1 %cmp.i, label %land.rhs.i, label %_ZNK4llvh9StringRef6equalsES0_.exit

land.rhs.i:                                       ; preds = %_ZN4llvh9StringRefC2EPKc.exit223
  %183 = load ptr, ptr %this1.i, align 8
  %184 = load ptr, ptr %RHS.i, align 8
  %Length4.i = getelementptr inbounds %"class.llvh::StringRef", ptr %RHS.i, i32 0, i32 1
  %185 = load i64, ptr %Length4.i, align 8
  store ptr %183, ptr %Lhs.addr.i299, align 8
  store ptr %184, ptr %Rhs.addr.i300, align 8
  store i64 %185, ptr %Length.addr.i301, align 8
  %186 = load i64, ptr %Length.addr.i301, align 8
  %cmp.i302 = icmp eq i64 %186, 0
  br i1 %cmp.i302, label %if.then.i305, label %if.end.i303

if.then.i305:                                     ; preds = %land.rhs.i
  store i32 0, ptr %retval.i298, align 4
  br label %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit306

if.end.i303:                                      ; preds = %land.rhs.i
  %187 = load ptr, ptr %Lhs.addr.i299, align 8
  %188 = load ptr, ptr %Rhs.addr.i300, align 8
  %189 = load i64, ptr %Length.addr.i301, align 8
  %call.i304 = call i32 @memcmp(ptr noundef %187, ptr noundef %188, i64 noundef %189) #15
  store i32 %call.i304, ptr %retval.i298, align 4
  br label %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit306

_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit306: ; preds = %if.end.i303, %if.then.i305
  %190 = load i32, ptr %retval.i298, align 4
  %cmp5.i = icmp eq i32 %190, 0
  br label %_ZNK4llvh9StringRef6equalsES0_.exit

_ZNK4llvh9StringRef6equalsES0_.exit:              ; preds = %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit306, %_ZN4llvh9StringRefC2EPKc.exit223
  %191 = phi i1 [ false, %_ZN4llvh9StringRefC2EPKc.exit223 ], [ %cmp5.i, %_ZN4llvh9StringRef13compareMemoryEPKcS2_m.exit306 ]
  br i1 %191, label %if.then29, label %if.end30

if.then29:                                        ; preds = %_ZNK4llvh9StringRef6equalsES0_.exit, %_ZNK4llvh9StringRef6equalsES0_.exit41
  call void @_ZN4llvh6detail9IEEEFloat7makeNaNEbbPKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this1, i1 noundef zeroext false, i1 noundef zeroext true, ptr noundef null)
  store i1 true, ptr %retval, align 1
  br label %return

if.end30:                                         ; preds = %_ZNK4llvh9StringRef6equalsES0_.exit
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end30, %if.then29, %if.then22, %if.then15, %if.then
  %192 = load i1, ptr %retval, align 1
  ret i1 %192
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloat7makeInfEb(ptr noundef nonnull align 8 dereferenceable(24) %this, i1 noundef zeroext %Negative) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Negative.addr = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %Negative to i8
  store i8 %frombool, ptr %Negative.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, -8
  %bf.set = or i8 %bf.clear, 0
  store i8 %bf.set, ptr %category, align 2
  %0 = load i8, ptr %Negative.addr, align 1
  %tobool = trunc i8 %0 to i1
  %conv = zext i1 %tobool to i32
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %1 = trunc i32 %conv to i8
  %bf.load2 = load i8, ptr %sign, align 2
  %bf.value = and i8 %1, 1
  %bf.shl = shl i8 %bf.value, 3
  %bf.clear3 = and i8 %bf.load2, -9
  %bf.set4 = or i8 %bf.clear3, %bf.shl
  store i8 %bf.set4, ptr %sign, align 2
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %semantics, align 8
  %maxExponent = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %2, i32 0, i32 0
  %3 = load i16, ptr %maxExponent, align 4
  %conv5 = sext i16 %3 to i32
  %add = add nsw i32 %conv5, 1
  %conv6 = trunc i32 %add to i16
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 %conv6, ptr %exponent, align 8
  %call = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call7 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  call void @_ZN4llvh5APInt5tcSetEPmmj(ptr noundef %call, i64 noundef 0, i32 noundef %call7)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat17convertFromStringENS_9StringRefENS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr %str.coerce0, i64 %str.coerce1, i32 noundef %rounding_mode) #1 align 2 {
entry:
  %this.addr.i30 = alloca ptr, align 8
  %data.addr.i31 = alloca ptr, align 8
  %length.addr.i32 = alloca i64, align 8
  %this.addr.i27 = alloca ptr, align 8
  %data.addr.i = alloca ptr, align 8
  %length.addr.i = alloca i64, align 8
  %this.addr.i = alloca ptr, align 8
  %retval = alloca i32, align 4
  %str = alloca %"class.llvh::StringRef", align 8
  %this.addr = alloca ptr, align 8
  %rounding_mode.addr = alloca i32, align 4
  %agg.tmp = alloca %"class.llvh::StringRef", align 8
  %p = alloca ptr, align 8
  %slen = alloca i64, align 8
  %agg.tmp22 = alloca %"class.llvh::StringRef", align 8
  %agg.tmp25 = alloca %"class.llvh::StringRef", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %str, i32 0, i32 0
  store ptr %str.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %str, i32 0, i32 1
  store i64 %str.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %rounding_mode, ptr %rounding_mode.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %str, i64 16, i1 false)
  %2 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %5 = load i64, ptr %4, align 8
  %call = call noundef zeroext i1 @_ZN4llvh6detail9IEEEFloat25convertFromStringSpecialsENS_9StringRefE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr %3, i64 %5)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %call2 = call noundef ptr @_ZNK4llvh9StringRef5beginEv(ptr noundef nonnull align 8 dereferenceable(16) %str)
  store ptr %call2, ptr %p, align 8
  store ptr %str, ptr %this.addr.i, align 8
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %Length.i = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i, i32 0, i32 1
  %6 = load i64, ptr %Length.i, align 8
  store i64 %6, ptr %slen, align 8
  %7 = load ptr, ptr %p, align 8
  %8 = load i8, ptr %7, align 1
  %conv = sext i8 %8 to i32
  %cmp = icmp eq i32 %conv, 45
  %cond = select i1 %cmp, i32 1, i32 0
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %9 = trunc i32 %cond to i8
  %bf.load = load i8, ptr %sign, align 2
  %bf.value = and i8 %9, 1
  %bf.shl = shl i8 %bf.value, 3
  %bf.clear = and i8 %bf.load, -9
  %bf.set = or i8 %bf.clear, %bf.shl
  store i8 %bf.set, ptr %sign, align 2
  %10 = load ptr, ptr %p, align 8
  %11 = load i8, ptr %10, align 1
  %conv4 = sext i8 %11 to i32
  %cmp5 = icmp eq i32 %conv4, 45
  br i1 %cmp5, label %if.then8, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %12 = load ptr, ptr %p, align 8
  %13 = load i8, ptr %12, align 1
  %conv6 = sext i8 %13 to i32
  %cmp7 = icmp eq i32 %conv6, 43
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %lor.lhs.false, %if.end
  %14 = load ptr, ptr %p, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %14, i32 1
  store ptr %incdec.ptr, ptr %p, align 8
  %15 = load i64, ptr %slen, align 8
  %dec = add i64 %15, -1
  store i64 %dec, ptr %slen, align 8
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %lor.lhs.false
  %16 = load i64, ptr %slen, align 8
  %cmp10 = icmp uge i64 %16, 2
  br i1 %cmp10, label %land.lhs.true, label %if.end24

land.lhs.true:                                    ; preds = %if.end9
  %17 = load ptr, ptr %p, align 8
  %arrayidx = getelementptr inbounds i8, ptr %17, i64 0
  %18 = load i8, ptr %arrayidx, align 1
  %conv11 = sext i8 %18 to i32
  %cmp12 = icmp eq i32 %conv11, 48
  br i1 %cmp12, label %land.lhs.true13, label %if.end24

land.lhs.true13:                                  ; preds = %land.lhs.true
  %19 = load ptr, ptr %p, align 8
  %arrayidx14 = getelementptr inbounds i8, ptr %19, i64 1
  %20 = load i8, ptr %arrayidx14, align 1
  %conv15 = sext i8 %20 to i32
  %cmp16 = icmp eq i32 %conv15, 120
  br i1 %cmp16, label %if.then21, label %lor.lhs.false17

lor.lhs.false17:                                  ; preds = %land.lhs.true13
  %21 = load ptr, ptr %p, align 8
  %arrayidx18 = getelementptr inbounds i8, ptr %21, i64 1
  %22 = load i8, ptr %arrayidx18, align 1
  %conv19 = sext i8 %22 to i32
  %cmp20 = icmp eq i32 %conv19, 88
  br i1 %cmp20, label %if.then21, label %if.end24

if.then21:                                        ; preds = %lor.lhs.false17, %land.lhs.true13
  %23 = load ptr, ptr %p, align 8
  %add.ptr = getelementptr inbounds i8, ptr %23, i64 2
  %24 = load i64, ptr %slen, align 8
  %sub = sub i64 %24, 2
  store ptr %agg.tmp22, ptr %this.addr.i27, align 8
  store ptr %add.ptr, ptr %data.addr.i, align 8
  store i64 %sub, ptr %length.addr.i, align 8
  %this1.i28 = load ptr, ptr %this.addr.i27, align 8
  %25 = load ptr, ptr %data.addr.i, align 8
  store ptr %25, ptr %this1.i28, align 8
  %Length.i29 = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i28, i32 0, i32 1
  %26 = load i64, ptr %length.addr.i, align 8
  store i64 %26, ptr %Length.i29, align 8
  %27 = load i32, ptr %rounding_mode.addr, align 4
  %28 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp22, i32 0, i32 0
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp22, i32 0, i32 1
  %31 = load i64, ptr %30, align 8
  %call23 = call noundef i32 @_ZN4llvh6detail9IEEEFloat28convertFromHexadecimalStringENS_9StringRefENS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr %29, i64 %31, i32 noundef %27)
  store i32 %call23, ptr %retval, align 4
  br label %return

if.end24:                                         ; preds = %lor.lhs.false17, %land.lhs.true, %if.end9
  %32 = load ptr, ptr %p, align 8
  %33 = load i64, ptr %slen, align 8
  store ptr %agg.tmp25, ptr %this.addr.i30, align 8
  store ptr %32, ptr %data.addr.i31, align 8
  store i64 %33, ptr %length.addr.i32, align 8
  %this1.i33 = load ptr, ptr %this.addr.i30, align 8
  %34 = load ptr, ptr %data.addr.i31, align 8
  store ptr %34, ptr %this1.i33, align 8
  %Length.i34 = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i33, i32 0, i32 1
  %35 = load i64, ptr %length.addr.i32, align 8
  store i64 %35, ptr %Length.i34, align 8
  %36 = load i32, ptr %rounding_mode.addr, align 4
  %37 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp25, i32 0, i32 0
  %38 = load ptr, ptr %37, align 8
  %39 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp25, i32 0, i32 1
  %40 = load i64, ptr %39, align 8
  %call26 = call noundef i32 @_ZN4llvh6detail9IEEEFloat24convertFromDecimalStringENS_9StringRefENS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr %38, i64 %40, i32 noundef %36)
  store i32 %call26, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end24, %if.then21, %if.then
  %41 = load i32, ptr %retval, align 4
  ret i32 %41
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZNK4llvh6detail9IEEEFloat18convertToHexStringEPcjbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %dst, i32 noundef %hexDigits, i1 noundef zeroext %upperCase, i32 noundef %rounding_mode) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %dst.addr = alloca ptr, align 8
  %hexDigits.addr = alloca i32, align 4
  %upperCase.addr = alloca i8, align 1
  %rounding_mode.addr = alloca i32, align 4
  %p = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %dst, ptr %dst.addr, align 8
  store i32 %hexDigits, ptr %hexDigits.addr, align 4
  %frombool = zext i1 %upperCase to i8
  store i8 %frombool, ptr %upperCase.addr, align 1
  store i32 %rounding_mode, ptr %rounding_mode.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %dst.addr, align 8
  store ptr %0, ptr %p, align 8
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load, 3
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %dst.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %1, i32 1
  store ptr %incdec.ptr, ptr %dst.addr, align 8
  store i8 45, ptr %1, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load2 = load i8, ptr %category, align 2
  %bf.clear3 = and i8 %bf.load2, 7
  %bf.cast4 = zext i8 %bf.clear3 to i32
  switch i32 %bf.cast4, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb6
    i32 3, label %sw.bb14
    i32 2, label %sw.bb28
  ]

sw.bb:                                            ; preds = %if.end
  %2 = load ptr, ptr %dst.addr, align 8
  %3 = load i8, ptr %upperCase.addr, align 1
  %tobool5 = trunc i8 %3 to i1
  br i1 %tobool5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.bb
  br label %cond.end

cond.false:                                       ; preds = %sw.bb
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond-lvalue = phi ptr [ @_ZN4llvhL9infinityUE, %cond.true ], [ @_ZN4llvhL9infinityLE, %cond.false ]
  %arraydecay = getelementptr inbounds [9 x i8], ptr %cond-lvalue, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %2, ptr align 1 %arraydecay, i64 8, i1 false)
  %4 = load ptr, ptr %dst.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %4, i64 8
  store ptr %add.ptr, ptr %dst.addr, align 8
  br label %sw.epilog

sw.bb6:                                           ; preds = %if.end
  %5 = load ptr, ptr %dst.addr, align 8
  %6 = load i8, ptr %upperCase.addr, align 1
  %tobool7 = trunc i8 %6 to i1
  br i1 %tobool7, label %cond.true8, label %cond.false9

cond.true8:                                       ; preds = %sw.bb6
  br label %cond.end10

cond.false9:                                      ; preds = %sw.bb6
  br label %cond.end10

cond.end10:                                       ; preds = %cond.false9, %cond.true8
  %cond-lvalue11 = phi ptr [ @_ZN4llvhL4NaNUE, %cond.true8 ], [ @_ZN4llvhL4NaNLE, %cond.false9 ]
  %arraydecay12 = getelementptr inbounds [4 x i8], ptr %cond-lvalue11, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %5, ptr align 1 %arraydecay12, i64 3, i1 false)
  %7 = load ptr, ptr %dst.addr, align 8
  %add.ptr13 = getelementptr inbounds i8, ptr %7, i64 3
  store ptr %add.ptr13, ptr %dst.addr, align 8
  br label %sw.epilog

sw.bb14:                                          ; preds = %if.end
  %8 = load ptr, ptr %dst.addr, align 8
  %incdec.ptr15 = getelementptr inbounds i8, ptr %8, i32 1
  store ptr %incdec.ptr15, ptr %dst.addr, align 8
  store i8 48, ptr %8, align 1
  %9 = load i8, ptr %upperCase.addr, align 1
  %tobool16 = trunc i8 %9 to i1
  %cond = select i1 %tobool16, i8 88, i8 120
  %10 = load ptr, ptr %dst.addr, align 8
  %incdec.ptr17 = getelementptr inbounds i8, ptr %10, i32 1
  store ptr %incdec.ptr17, ptr %dst.addr, align 8
  store i8 %cond, ptr %10, align 1
  %11 = load ptr, ptr %dst.addr, align 8
  %incdec.ptr18 = getelementptr inbounds i8, ptr %11, i32 1
  store ptr %incdec.ptr18, ptr %dst.addr, align 8
  store i8 48, ptr %11, align 1
  %12 = load i32, ptr %hexDigits.addr, align 4
  %cmp = icmp ugt i32 %12, 1
  br i1 %cmp, label %if.then19, label %if.end23

if.then19:                                        ; preds = %sw.bb14
  %13 = load ptr, ptr %dst.addr, align 8
  %incdec.ptr20 = getelementptr inbounds i8, ptr %13, i32 1
  store ptr %incdec.ptr20, ptr %dst.addr, align 8
  store i8 46, ptr %13, align 1
  %14 = load ptr, ptr %dst.addr, align 8
  %15 = load i32, ptr %hexDigits.addr, align 4
  %sub = sub i32 %15, 1
  %conv = zext i32 %sub to i64
  call void @llvm.memset.p0.i64(ptr align 1 %14, i8 48, i64 %conv, i1 false)
  %16 = load i32, ptr %hexDigits.addr, align 4
  %sub21 = sub i32 %16, 1
  %17 = load ptr, ptr %dst.addr, align 8
  %idx.ext = zext i32 %sub21 to i64
  %add.ptr22 = getelementptr inbounds i8, ptr %17, i64 %idx.ext
  store ptr %add.ptr22, ptr %dst.addr, align 8
  br label %if.end23

if.end23:                                         ; preds = %if.then19, %sw.bb14
  %18 = load i8, ptr %upperCase.addr, align 1
  %tobool24 = trunc i8 %18 to i1
  %cond25 = select i1 %tobool24, i8 80, i8 112
  %19 = load ptr, ptr %dst.addr, align 8
  %incdec.ptr26 = getelementptr inbounds i8, ptr %19, i32 1
  store ptr %incdec.ptr26, ptr %dst.addr, align 8
  store i8 %cond25, ptr %19, align 1
  %20 = load ptr, ptr %dst.addr, align 8
  %incdec.ptr27 = getelementptr inbounds i8, ptr %20, i32 1
  store ptr %incdec.ptr27, ptr %dst.addr, align 8
  store i8 48, ptr %20, align 1
  br label %sw.epilog

sw.bb28:                                          ; preds = %if.end
  %21 = load ptr, ptr %dst.addr, align 8
  %22 = load i32, ptr %hexDigits.addr, align 4
  %23 = load i8, ptr %upperCase.addr, align 1
  %tobool29 = trunc i8 %23 to i1
  %24 = load i32, ptr %rounding_mode.addr, align 4
  %call = call noundef ptr @_ZNK4llvh6detail9IEEEFloat24convertNormalToHexStringEPcjbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %21, i32 noundef %22, i1 noundef zeroext %tobool29, i32 noundef %24)
  store ptr %call, ptr %dst.addr, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb28, %if.end23, %cond.end10, %cond.end, %if.end
  %25 = load ptr, ptr %dst.addr, align 8
  store i8 0, ptr %25, align 1
  %26 = load ptr, ptr %dst.addr, align 8
  %27 = load ptr, ptr %p, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %26 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %27 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv30 = trunc i64 %sub.ptr.sub to i32
  ret i32 %conv30
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #7

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef ptr @_ZNK4llvh6detail9IEEEFloat24convertNormalToHexStringEPcjbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %dst, i32 noundef %hexDigits, i1 noundef zeroext %upperCase, i32 noundef %rounding_mode) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %dst.addr = alloca ptr, align 8
  %hexDigits.addr = alloca i32, align 4
  %upperCase.addr = alloca i8, align 1
  %rounding_mode.addr = alloca i32, align 4
  %count = alloca i32, align 4
  %valueBits = alloca i32, align 4
  %shift = alloca i32, align 4
  %partsCount = alloca i32, align 4
  %outputDigits = alloca i32, align 4
  %hexDigitChars = alloca ptr, align 8
  %significand = alloca ptr, align 8
  %p = alloca ptr, align 8
  %roundUp = alloca i8, align 1
  %bits = alloca i32, align 4
  %fraction = alloca i32, align 4
  %part = alloca i64, align 8
  %curDigits = alloca i32, align 4
  %q = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %dst, ptr %dst.addr, align 8
  store i32 %hexDigits, ptr %hexDigits.addr, align 4
  %frombool = zext i1 %upperCase to i8
  store i8 %frombool, ptr %upperCase.addr, align 1
  store i32 %rounding_mode, ptr %rounding_mode.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %dst.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %0, i32 1
  store ptr %incdec.ptr, ptr %dst.addr, align 8
  store i8 48, ptr %0, align 1
  %1 = load i8, ptr %upperCase.addr, align 1
  %tobool = trunc i8 %1 to i1
  %cond = select i1 %tobool, i8 88, i8 120
  %2 = load ptr, ptr %dst.addr, align 8
  %incdec.ptr2 = getelementptr inbounds i8, ptr %2, i32 1
  store ptr %incdec.ptr2, ptr %dst.addr, align 8
  store i8 %cond, ptr %2, align 1
  store i8 0, ptr %roundUp, align 1
  %3 = load i8, ptr %upperCase.addr, align 1
  %tobool3 = trunc i8 %3 to i1
  br i1 %tobool3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond-lvalue = phi ptr [ @_ZN4llvhL14hexDigitsUpperE, %cond.true ], [ @_ZN4llvhL14hexDigitsLowerE, %cond.false ]
  %arraydecay = getelementptr inbounds [18 x i8], ptr %cond-lvalue, i64 0, i64 0
  store ptr %arraydecay, ptr %hexDigitChars, align 8
  %call = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store ptr %call, ptr %significand, align 8
  %call4 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store i32 %call4, ptr %partsCount, align 4
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %semantics, align 8
  %precision = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %4, i32 0, i32 2
  %5 = load i32, ptr %precision, align 4
  %add = add i32 %5, 3
  store i32 %add, ptr %valueBits, align 4
  %6 = load i32, ptr %valueBits, align 4
  %rem = urem i32 %6, 64
  %sub = sub i32 64, %rem
  store i32 %sub, ptr %shift, align 4
  %7 = load i32, ptr %valueBits, align 4
  %call5 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat14significandLSBEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %sub6 = sub i32 %7, %call5
  %add7 = add i32 %sub6, 3
  %div = udiv i32 %add7, 4
  store i32 %div, ptr %outputDigits, align 4
  %8 = load i32, ptr %hexDigits.addr, align 4
  %tobool8 = icmp ne i32 %8, 0
  br i1 %tobool8, label %if.then, label %if.end14

if.then:                                          ; preds = %cond.end
  %9 = load i32, ptr %hexDigits.addr, align 4
  %10 = load i32, ptr %outputDigits, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %if.then9, label %if.end

if.then9:                                         ; preds = %if.then
  %11 = load i32, ptr %valueBits, align 4
  %12 = load i32, ptr %hexDigits.addr, align 4
  %mul = mul i32 %12, 4
  %sub10 = sub i32 %11, %mul
  store i32 %sub10, ptr %bits, align 4
  %13 = load ptr, ptr %significand, align 8
  %14 = load i32, ptr %partsCount, align 4
  %15 = load i32, ptr %bits, align 4
  %call11 = call noundef i32 @_ZN4llvhL29lostFractionThroughTruncationEPKmjj(ptr noundef %13, i32 noundef %14, i32 noundef %15)
  store i32 %call11, ptr %fraction, align 4
  %16 = load i32, ptr %rounding_mode.addr, align 4
  %17 = load i32, ptr %fraction, align 4
  %18 = load i32, ptr %bits, align 4
  %call12 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat17roundAwayFromZeroENS_11APFloatBase12roundingModeENS_12lostFractionEj(ptr noundef nonnull align 8 dereferenceable(24) %this1, i32 noundef %16, i32 noundef %17, i32 noundef %18)
  %frombool13 = zext i1 %call12 to i8
  store i8 %frombool13, ptr %roundUp, align 1
  br label %if.end

if.end:                                           ; preds = %if.then9, %if.then
  %19 = load i32, ptr %hexDigits.addr, align 4
  store i32 %19, ptr %outputDigits, align 4
  br label %if.end14

if.end14:                                         ; preds = %if.end, %cond.end
  %20 = load ptr, ptr %dst.addr, align 8
  %incdec.ptr15 = getelementptr inbounds i8, ptr %20, i32 1
  store ptr %incdec.ptr15, ptr %dst.addr, align 8
  store ptr %incdec.ptr15, ptr %p, align 8
  %21 = load i32, ptr %valueBits, align 4
  %add16 = add i32 %21, 64
  %sub17 = sub i32 %add16, 1
  %div18 = udiv i32 %sub17, 64
  store i32 %div18, ptr %count, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end35, %if.end14
  %22 = load i32, ptr %outputDigits, align 4
  %tobool19 = icmp ne i32 %22, 0
  br i1 %tobool19, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %23 = load i32, ptr %count, align 4
  %tobool20 = icmp ne i32 %23, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %24 = phi i1 [ false, %while.cond ], [ %tobool20, %land.rhs ]
  br i1 %24, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %25 = load i32, ptr %count, align 4
  %dec = add i32 %25, -1
  store i32 %dec, ptr %count, align 4
  %26 = load i32, ptr %partsCount, align 4
  %cmp21 = icmp eq i32 %dec, %26
  br i1 %cmp21, label %if.then22, label %if.else

if.then22:                                        ; preds = %while.body
  store i64 0, ptr %part, align 8
  br label %if.end23

if.else:                                          ; preds = %while.body
  %27 = load ptr, ptr %significand, align 8
  %28 = load i32, ptr %count, align 4
  %idxprom = zext i32 %28 to i64
  %arrayidx = getelementptr inbounds i64, ptr %27, i64 %idxprom
  %29 = load i64, ptr %arrayidx, align 8
  %30 = load i32, ptr %shift, align 4
  %sh_prom = zext i32 %30 to i64
  %shl = shl i64 %29, %sh_prom
  store i64 %shl, ptr %part, align 8
  br label %if.end23

if.end23:                                         ; preds = %if.else, %if.then22
  %31 = load i32, ptr %count, align 4
  %tobool24 = icmp ne i32 %31, 0
  br i1 %tobool24, label %land.lhs.true, label %if.end32

land.lhs.true:                                    ; preds = %if.end23
  %32 = load i32, ptr %shift, align 4
  %tobool25 = icmp ne i32 %32, 0
  br i1 %tobool25, label %if.then26, label %if.end32

if.then26:                                        ; preds = %land.lhs.true
  %33 = load ptr, ptr %significand, align 8
  %34 = load i32, ptr %count, align 4
  %sub27 = sub i32 %34, 1
  %idxprom28 = zext i32 %sub27 to i64
  %arrayidx29 = getelementptr inbounds i64, ptr %33, i64 %idxprom28
  %35 = load i64, ptr %arrayidx29, align 8
  %36 = load i32, ptr %shift, align 4
  %sub30 = sub i32 64, %36
  %sh_prom31 = zext i32 %sub30 to i64
  %shr = lshr i64 %35, %sh_prom31
  %37 = load i64, ptr %part, align 8
  %or = or i64 %37, %shr
  store i64 %or, ptr %part, align 8
  br label %if.end32

if.end32:                                         ; preds = %if.then26, %land.lhs.true, %if.end23
  store i32 16, ptr %curDigits, align 4
  %38 = load i32, ptr %curDigits, align 4
  %39 = load i32, ptr %outputDigits, align 4
  %cmp33 = icmp ugt i32 %38, %39
  br i1 %cmp33, label %if.then34, label %if.end35

if.then34:                                        ; preds = %if.end32
  %40 = load i32, ptr %outputDigits, align 4
  store i32 %40, ptr %curDigits, align 4
  br label %if.end35

if.end35:                                         ; preds = %if.then34, %if.end32
  %41 = load ptr, ptr %dst.addr, align 8
  %42 = load i64, ptr %part, align 8
  %43 = load i32, ptr %curDigits, align 4
  %44 = load ptr, ptr %hexDigitChars, align 8
  %call36 = call noundef i32 @_ZN4llvhL9partAsHexEPcmjPKc(ptr noundef %41, i64 noundef %42, i32 noundef %43, ptr noundef %44)
  %45 = load ptr, ptr %dst.addr, align 8
  %idx.ext = zext i32 %call36 to i64
  %add.ptr = getelementptr inbounds i8, ptr %45, i64 %idx.ext
  store ptr %add.ptr, ptr %dst.addr, align 8
  %46 = load i32, ptr %curDigits, align 4
  %47 = load i32, ptr %outputDigits, align 4
  %sub37 = sub i32 %47, %46
  store i32 %sub37, ptr %outputDigits, align 4
  br label %while.cond, !llvm.loop !25

while.end:                                        ; preds = %land.end
  %48 = load i8, ptr %roundUp, align 1
  %tobool38 = trunc i8 %48 to i1
  br i1 %tobool38, label %if.then39, label %if.else46

if.then39:                                        ; preds = %while.end
  %49 = load ptr, ptr %dst.addr, align 8
  store ptr %49, ptr %q, align 8
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.then39
  %50 = load ptr, ptr %q, align 8
  %incdec.ptr40 = getelementptr inbounds i8, ptr %50, i32 -1
  store ptr %incdec.ptr40, ptr %q, align 8
  %51 = load ptr, ptr %hexDigitChars, align 8
  %52 = load ptr, ptr %q, align 8
  %53 = load i8, ptr %52, align 1
  %call41 = call noundef i32 @_ZN4llvh13hexDigitValueEc(i8 noundef signext %53)
  %add42 = add i32 %call41, 1
  %idxprom43 = zext i32 %add42 to i64
  %arrayidx44 = getelementptr inbounds i8, ptr %51, i64 %idxprom43
  %54 = load i8, ptr %arrayidx44, align 1
  %55 = load ptr, ptr %q, align 8
  store i8 %54, ptr %55, align 1
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %56 = load ptr, ptr %q, align 8
  %57 = load i8, ptr %56, align 1
  %conv = sext i8 %57 to i32
  %cmp45 = icmp eq i32 %conv, 48
  br i1 %cmp45, label %do.body, label %do.end, !llvm.loop !26

do.end:                                           ; preds = %do.cond
  br label %if.end50

if.else46:                                        ; preds = %while.end
  %58 = load ptr, ptr %dst.addr, align 8
  %59 = load i32, ptr %outputDigits, align 4
  %conv47 = zext i32 %59 to i64
  call void @llvm.memset.p0.i64(ptr align 1 %58, i8 48, i64 %conv47, i1 false)
  %60 = load i32, ptr %outputDigits, align 4
  %61 = load ptr, ptr %dst.addr, align 8
  %idx.ext48 = zext i32 %60 to i64
  %add.ptr49 = getelementptr inbounds i8, ptr %61, i64 %idx.ext48
  store ptr %add.ptr49, ptr %dst.addr, align 8
  br label %if.end50

if.end50:                                         ; preds = %if.else46, %do.end
  %62 = load ptr, ptr %p, align 8
  %arrayidx51 = getelementptr inbounds i8, ptr %62, i64 0
  %63 = load i8, ptr %arrayidx51, align 1
  %64 = load ptr, ptr %p, align 8
  %arrayidx52 = getelementptr inbounds i8, ptr %64, i64 -1
  store i8 %63, ptr %arrayidx52, align 1
  %65 = load ptr, ptr %dst.addr, align 8
  %add.ptr53 = getelementptr inbounds i8, ptr %65, i64 -1
  %66 = load ptr, ptr %p, align 8
  %cmp54 = icmp eq ptr %add.ptr53, %66
  br i1 %cmp54, label %if.then55, label %if.else57

if.then55:                                        ; preds = %if.end50
  %67 = load ptr, ptr %dst.addr, align 8
  %incdec.ptr56 = getelementptr inbounds i8, ptr %67, i32 -1
  store ptr %incdec.ptr56, ptr %dst.addr, align 8
  br label %if.end59

if.else57:                                        ; preds = %if.end50
  %68 = load ptr, ptr %p, align 8
  %arrayidx58 = getelementptr inbounds i8, ptr %68, i64 0
  store i8 46, ptr %arrayidx58, align 1
  br label %if.end59

if.end59:                                         ; preds = %if.else57, %if.then55
  %69 = load i8, ptr %upperCase.addr, align 1
  %tobool60 = trunc i8 %69 to i1
  %cond61 = select i1 %tobool60, i8 80, i8 112
  %70 = load ptr, ptr %dst.addr, align 8
  %incdec.ptr62 = getelementptr inbounds i8, ptr %70, i32 1
  store ptr %incdec.ptr62, ptr %dst.addr, align 8
  store i8 %cond61, ptr %70, align 1
  %71 = load ptr, ptr %dst.addr, align 8
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %72 = load i16, ptr %exponent, align 8
  %conv63 = sext i16 %72 to i32
  %call64 = call noundef ptr @_ZN4llvhL18writeSignedDecimalEPci(ptr noundef %71, i32 noundef %conv63)
  ret ptr %call64
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZN4llvhL9partAsHexEPcmjPKc(ptr noundef %dst, i64 noundef %part, i32 noundef %count, ptr noundef %hexDigitChars) #1 {
entry:
  %dst.addr = alloca ptr, align 8
  %part.addr = alloca i64, align 8
  %count.addr = alloca i32, align 4
  %hexDigitChars.addr = alloca ptr, align 8
  %result = alloca i32, align 4
  store ptr %dst, ptr %dst.addr, align 8
  store i64 %part, ptr %part.addr, align 8
  store i32 %count, ptr %count.addr, align 4
  store ptr %hexDigitChars, ptr %hexDigitChars.addr, align 8
  %0 = load i32, ptr %count.addr, align 4
  store i32 %0, ptr %result, align 4
  %1 = load i32, ptr %count.addr, align 4
  %mul = mul i32 4, %1
  %sub = sub i32 64, %mul
  %2 = load i64, ptr %part.addr, align 8
  %sh_prom = zext i32 %sub to i64
  %shr = lshr i64 %2, %sh_prom
  store i64 %shr, ptr %part.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %3 = load i32, ptr %count.addr, align 4
  %dec = add i32 %3, -1
  store i32 %dec, ptr %count.addr, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load ptr, ptr %hexDigitChars.addr, align 8
  %5 = load i64, ptr %part.addr, align 8
  %and = and i64 %5, 15
  %arrayidx = getelementptr inbounds i8, ptr %4, i64 %and
  %6 = load i8, ptr %arrayidx, align 1
  %7 = load ptr, ptr %dst.addr, align 8
  %8 = load i32, ptr %count.addr, align 4
  %idxprom = zext i32 %8 to i64
  %arrayidx1 = getelementptr inbounds i8, ptr %7, i64 %idxprom
  store i8 %6, ptr %arrayidx1, align 1
  %9 = load i64, ptr %part.addr, align 8
  %shr2 = lshr i64 %9, 4
  store i64 %shr2, ptr %part.addr, align 8
  br label %while.cond, !llvm.loop !27

while.end:                                        ; preds = %while.cond
  %10 = load i32, ptr %result, align 4
  ret i32 %10
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef ptr @_ZN4llvhL18writeSignedDecimalEPci(ptr noundef %dst, i32 noundef %value) #1 {
entry:
  %dst.addr = alloca ptr, align 8
  %value.addr = alloca i32, align 4
  store ptr %dst, ptr %dst.addr, align 8
  store i32 %value, ptr %value.addr, align 4
  %0 = load i32, ptr %value.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %dst.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %1, i32 1
  store ptr %incdec.ptr, ptr %dst.addr, align 8
  store i8 45, ptr %1, align 1
  %2 = load ptr, ptr %dst.addr, align 8
  %3 = load i32, ptr %value.addr, align 4
  %sub = sub i32 0, %3
  %call = call noundef ptr @_ZN4llvhL20writeUnsignedDecimalEPcj(ptr noundef %2, i32 noundef %sub)
  store ptr %call, ptr %dst.addr, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %4 = load ptr, ptr %dst.addr, align 8
  %5 = load i32, ptr %value.addr, align 4
  %call1 = call noundef ptr @_ZN4llvhL20writeUnsignedDecimalEPcj(ptr noundef %4, i32 noundef %5)
  store ptr %call1, ptr %dst.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %6 = load ptr, ptr %dst.addr, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind uwtable
define hidden i64 @_ZN4llvh6detail10hash_valueERKNS0_9IEEEFloatE(ptr noundef nonnull align 8 dereferenceable(24) %Arg) #1 {
entry:
  %retval = alloca %"class.llvh::hash_code", align 8
  %Arg.addr = alloca ptr, align 8
  %ref.tmp = alloca i8, align 1
  %ref.tmp1 = alloca i8, align 1
  %ref.tmp8 = alloca i8, align 1
  %ref.tmp14 = alloca i8, align 1
  %ref.tmp23 = alloca %"class.llvh::hash_code", align 8
  store ptr %Arg, ptr %Arg.addr, align 8
  %0 = load ptr, ptr %Arg.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %0)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %Arg.addr, align 8
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, 7
  %bf.cast = zext i8 %bf.clear to i32
  %conv = trunc i32 %bf.cast to i8
  store i8 %conv, ptr %ref.tmp, align 1
  %2 = load ptr, ptr %Arg.addr, align 8
  %call2 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat5isNaNEv(ptr noundef nonnull align 8 dereferenceable(24) %2)
  br i1 %call2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %3 = load ptr, ptr %Arg.addr, align 8
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %3, i32 0, i32 3
  %bf.load3 = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load3, 3
  %bf.clear4 = and i8 %bf.lshr, 1
  %bf.cast5 = zext i8 %bf.clear4 to i32
  %conv6 = trunc i32 %bf.cast5 to i8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8 [ 0, %cond.true ], [ %conv6, %cond.false ]
  store i8 %cond, ptr %ref.tmp1, align 1
  %4 = load ptr, ptr %Arg.addr, align 8
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %semantics, align 8
  %precision = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %5, i32 0, i32 2
  %call7 = call i64 @_ZN4llvh12hash_combineIJhhjEEENS_9hash_codeEDpRKT_(ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp1, ptr noundef nonnull align 4 dereferenceable(4) %precision)
  %coerce.dive = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  store i64 %call7, ptr %coerce.dive, align 8
  br label %return

if.end:                                           ; preds = %entry
  %6 = load ptr, ptr %Arg.addr, align 8
  %category9 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %6, i32 0, i32 3
  %bf.load10 = load i8, ptr %category9, align 2
  %bf.clear11 = and i8 %bf.load10, 7
  %bf.cast12 = zext i8 %bf.clear11 to i32
  %conv13 = trunc i32 %bf.cast12 to i8
  store i8 %conv13, ptr %ref.tmp8, align 1
  %7 = load ptr, ptr %Arg.addr, align 8
  %sign15 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %7, i32 0, i32 3
  %bf.load16 = load i8, ptr %sign15, align 2
  %bf.lshr17 = lshr i8 %bf.load16, 3
  %bf.clear18 = and i8 %bf.lshr17, 1
  %bf.cast19 = zext i8 %bf.clear18 to i32
  %conv20 = trunc i32 %bf.cast19 to i8
  store i8 %conv20, ptr %ref.tmp14, align 1
  %8 = load ptr, ptr %Arg.addr, align 8
  %semantics21 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %8, i32 0, i32 0
  %9 = load ptr, ptr %semantics21, align 8
  %precision22 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %Arg.addr, align 8
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %10, i32 0, i32 2
  %11 = load ptr, ptr %Arg.addr, align 8
  %call24 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %11)
  %12 = load ptr, ptr %Arg.addr, align 8
  %call25 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %12)
  %13 = load ptr, ptr %Arg.addr, align 8
  %call26 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %13)
  %idx.ext = zext i32 %call26 to i64
  %add.ptr = getelementptr inbounds i64, ptr %call25, i64 %idx.ext
  %call27 = call i64 @_ZN4llvh18hash_combine_rangeIPKmEENS_9hash_codeET_S4_(ptr noundef %call24, ptr noundef %add.ptr)
  %coerce.dive28 = getelementptr inbounds %"class.llvh::hash_code", ptr %ref.tmp23, i32 0, i32 0
  store i64 %call27, ptr %coerce.dive28, align 8
  %call29 = call i64 @_ZN4llvh12hash_combineIJhhjsNS_9hash_codeEEEES1_DpRKT_(ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp8, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp14, ptr noundef nonnull align 4 dereferenceable(4) %precision22, ptr noundef nonnull align 2 dereferenceable(2) %exponent, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp23)
  %coerce.dive30 = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  store i64 %call29, ptr %coerce.dive30, align 8
  br label %return

return:                                           ; preds = %if.end, %cond.end
  %coerce.dive31 = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  %14 = load i64, ptr %coerce.dive31, align 8
  ret i64 %14
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden i64 @_ZN4llvh12hash_combineIJhhjEEENS_9hash_codeEDpRKT_(ptr noundef nonnull align 1 dereferenceable(1) %args, ptr noundef nonnull align 1 dereferenceable(1) %args1, ptr noundef nonnull align 4 dereferenceable(4) %args3) #1 comdat {
entry:
  %retval = alloca %"class.llvh::hash_code", align 8
  %args.addr = alloca ptr, align 8
  %args.addr2 = alloca ptr, align 8
  %args.addr4 = alloca ptr, align 8
  %helper = alloca %"struct.llvh::hashing::detail::hash_combine_recursive_helper", align 8
  store ptr %args, ptr %args.addr, align 8
  store ptr %args1, ptr %args.addr2, align 8
  store ptr %args3, ptr %args.addr4, align 8
  call void @_ZN4llvh7hashing6detail29hash_combine_recursive_helperC2Ev(ptr noundef nonnull align 8 dereferenceable(128) %helper)
  %buffer = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %helper, i32 0, i32 0
  %arraydecay = getelementptr inbounds [64 x i8], ptr %buffer, i64 0, i64 0
  %buffer5 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %helper, i32 0, i32 0
  %arraydecay6 = getelementptr inbounds [64 x i8], ptr %buffer5, i64 0, i64 0
  %add.ptr = getelementptr inbounds i8, ptr %arraydecay6, i64 64
  %0 = load ptr, ptr %args.addr, align 8
  %1 = load ptr, ptr %args.addr2, align 8
  %2 = load ptr, ptr %args.addr4, align 8
  %call = call i64 @_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineIhJhjEEENS_9hash_codeEmPcS5_RKT_DpRKT0_(ptr noundef nonnull align 8 dereferenceable(128) %helper, i64 noundef 0, ptr noundef %arraydecay, ptr noundef %add.ptr, ptr noundef nonnull align 1 dereferenceable(1) %0, ptr noundef nonnull align 1 dereferenceable(1) %1, ptr noundef nonnull align 4 dereferenceable(4) %2)
  %coerce.dive = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  store i64 %call, ptr %coerce.dive, align 8
  %coerce.dive7 = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  %3 = load i64, ptr %coerce.dive7, align 8
  ret i64 %3
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat5isNaNEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, 7
  %bf.cast = zext i8 %bf.clear to i32
  %cmp = icmp eq i32 %bf.cast, 1
  ret i1 %cmp
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden i64 @_ZN4llvh12hash_combineIJhhjsNS_9hash_codeEEEES1_DpRKT_(ptr noundef nonnull align 1 dereferenceable(1) %args, ptr noundef nonnull align 1 dereferenceable(1) %args1, ptr noundef nonnull align 4 dereferenceable(4) %args3, ptr noundef nonnull align 2 dereferenceable(2) %args5, ptr noundef nonnull align 8 dereferenceable(8) %args7) #1 comdat {
entry:
  %retval = alloca %"class.llvh::hash_code", align 8
  %args.addr = alloca ptr, align 8
  %args.addr2 = alloca ptr, align 8
  %args.addr4 = alloca ptr, align 8
  %args.addr6 = alloca ptr, align 8
  %args.addr8 = alloca ptr, align 8
  %helper = alloca %"struct.llvh::hashing::detail::hash_combine_recursive_helper", align 8
  store ptr %args, ptr %args.addr, align 8
  store ptr %args1, ptr %args.addr2, align 8
  store ptr %args3, ptr %args.addr4, align 8
  store ptr %args5, ptr %args.addr6, align 8
  store ptr %args7, ptr %args.addr8, align 8
  call void @_ZN4llvh7hashing6detail29hash_combine_recursive_helperC2Ev(ptr noundef nonnull align 8 dereferenceable(128) %helper)
  %buffer = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %helper, i32 0, i32 0
  %arraydecay = getelementptr inbounds [64 x i8], ptr %buffer, i64 0, i64 0
  %buffer9 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %helper, i32 0, i32 0
  %arraydecay10 = getelementptr inbounds [64 x i8], ptr %buffer9, i64 0, i64 0
  %add.ptr = getelementptr inbounds i8, ptr %arraydecay10, i64 64
  %0 = load ptr, ptr %args.addr, align 8
  %1 = load ptr, ptr %args.addr2, align 8
  %2 = load ptr, ptr %args.addr4, align 8
  %3 = load ptr, ptr %args.addr6, align 8
  %4 = load ptr, ptr %args.addr8, align 8
  %call = call i64 @_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineIhJhjsNS_9hash_codeEEEES4_mPcS5_RKT_DpRKT0_(ptr noundef nonnull align 8 dereferenceable(128) %helper, i64 noundef 0, ptr noundef %arraydecay, ptr noundef %add.ptr, ptr noundef nonnull align 1 dereferenceable(1) %0, ptr noundef nonnull align 1 dereferenceable(1) %1, ptr noundef nonnull align 4 dereferenceable(4) %2, ptr noundef nonnull align 2 dereferenceable(2) %3, ptr noundef nonnull align 8 dereferenceable(8) %4)
  %coerce.dive = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  store i64 %call, ptr %coerce.dive, align 8
  %coerce.dive11 = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  %5 = load i64, ptr %coerce.dive11, align 8
  ret i64 %5
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden i64 @_ZN4llvh18hash_combine_rangeIPKmEENS_9hash_codeET_S4_(ptr noundef %first, ptr noundef %last) #1 comdat {
entry:
  %retval = alloca %"class.llvh::hash_code", align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %call = call i64 @_ZN4llvh7hashing6detail23hash_combine_range_implIKmEENSt9enable_ifIXsr16is_hashable_dataIT_EE5valueENS_9hash_codeEE4typeEPS5_S9_(ptr noundef %0, ptr noundef %1)
  %coerce.dive = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  store i64 %call, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  %2 = load i64, ptr %coerce.dive1, align 8
  ret i64 %2
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZNK4llvh6detail9IEEEFloat34convertF80LongDoubleAPFloatToAPIntEv(ptr noalias sret(%"class.llvh::APInt") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(24) %this) #1 align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %myexponent = alloca i64, align 8
  %mysignificand = alloca i64, align 8
  %words = alloca [2 x i64], align 16
  %agg.tmp = alloca %"class.llvh::ArrayRef", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %0 = load i16, ptr %exponent, align 8
  %conv = sext i16 %0 to i32
  %add = add nsw i32 %conv, 16383
  %conv2 = sext i32 %add to i64
  store i64 %conv2, ptr %myexponent, align 8
  %call3 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %arrayidx = getelementptr inbounds i64, ptr %call3, i64 0
  %1 = load i64, ptr %arrayidx, align 8
  store i64 %1, ptr %mysignificand, align 8
  %2 = load i64, ptr %myexponent, align 8
  %cmp = icmp eq i64 %2, 1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %3 = load i64, ptr %mysignificand, align 8
  %and = and i64 %3, -9223372036854775808
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.end, label %if.then4

if.then4:                                         ; preds = %land.lhs.true
  store i64 0, ptr %myexponent, align 8
  br label %if.end

if.end:                                           ; preds = %if.then4, %land.lhs.true, %if.then
  br label %if.end19

if.else:                                          ; preds = %entry
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, 7
  %bf.cast = zext i8 %bf.clear to i32
  %cmp5 = icmp eq i32 %bf.cast, 3
  br i1 %cmp5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.else
  store i64 0, ptr %myexponent, align 8
  store i64 0, ptr %mysignificand, align 8
  br label %if.end18

if.else7:                                         ; preds = %if.else
  %category8 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load9 = load i8, ptr %category8, align 2
  %bf.clear10 = and i8 %bf.load9, 7
  %bf.cast11 = zext i8 %bf.clear10 to i32
  %cmp12 = icmp eq i32 %bf.cast11, 0
  br i1 %cmp12, label %if.then13, label %if.else14

if.then13:                                        ; preds = %if.else7
  store i64 32767, ptr %myexponent, align 8
  store i64 -9223372036854775808, ptr %mysignificand, align 8
  br label %if.end17

if.else14:                                        ; preds = %if.else7
  store i64 32767, ptr %myexponent, align 8
  %call15 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %arrayidx16 = getelementptr inbounds i64, ptr %call15, i64 0
  %4 = load i64, ptr %arrayidx16, align 8
  store i64 %4, ptr %mysignificand, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.else14, %if.then13
  br label %if.end18

if.end18:                                         ; preds = %if.end17, %if.then6
  br label %if.end19

if.end19:                                         ; preds = %if.end18, %if.end
  %5 = load i64, ptr %mysignificand, align 8
  %arrayidx20 = getelementptr inbounds [2 x i64], ptr %words, i64 0, i64 0
  store i64 %5, ptr %arrayidx20, align 16
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load21 = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load21, 3
  %bf.clear22 = and i8 %bf.lshr, 1
  %bf.cast23 = zext i8 %bf.clear22 to i32
  %and24 = and i32 %bf.cast23, 1
  %conv25 = sext i32 %and24 to i64
  %shl = shl i64 %conv25, 15
  %6 = load i64, ptr %myexponent, align 8
  %and26 = and i64 %6, 32767
  %or = or i64 %shl, %and26
  %arrayidx27 = getelementptr inbounds [2 x i64], ptr %words, i64 0, i64 1
  store i64 %or, ptr %arrayidx27, align 8
  call void @_ZN4llvh8ArrayRefImEC2ILm2EEERAT__Km(ptr noundef nonnull align 8 dereferenceable(16) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(16) %words)
  %7 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %10 = load i64, ptr %9, align 8
  call void @_ZN4llvh5APIntC1EjNS_8ArrayRefImEE(ptr noundef nonnull align 8 dereferenceable(12) %agg.result, i32 noundef 80, ptr %8, i64 %10)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh8ArrayRefImEC2ILm2EEERAT__Km(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %Arr) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Arr.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %Arr, ptr %Arr.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %"class.llvh::ArrayRef", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %Arr.addr, align 8
  %arraydecay = getelementptr inbounds [2 x i64], ptr %0, i64 0, i64 0
  store ptr %arraydecay, ptr %Data, align 8
  %Length = getelementptr inbounds %"class.llvh::ArrayRef", ptr %this1, i32 0, i32 1
  store i64 2, ptr %Length, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZNK4llvh6detail9IEEEFloat36convertPPCDoubleDoubleAPFloatToAPIntEv(ptr noalias sret(%"class.llvh::APInt") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(24) %this) #1 align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %words = alloca [2 x i64], align 16
  %fs = alloca i32, align 4
  %losesInfo = alloca i8, align 1
  %extendedSemantics = alloca %"struct.llvh::fltSemantics", align 4
  %extended = alloca %"class.llvh::detail::IEEEFloat", align 8
  %u = alloca %"class.llvh::detail::IEEEFloat", align 8
  %ref.tmp = alloca %"class.llvh::APInt", align 8
  %v = alloca %"class.llvh::detail::IEEEFloat", align 8
  %ref.tmp8 = alloca %"class.llvh::APInt", align 8
  %agg.tmp = alloca %"class.llvh::ArrayRef", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %semantics, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %extendedSemantics, ptr align 4 %0, i64 12, i1 false)
  %minExponent = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %extendedSemantics, i32 0, i32 1
  store i16 -1022, ptr %minExponent, align 2
  call void @_ZN4llvh6detail9IEEEFloatC1ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %extended, ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call = call noundef i32 @_ZN4llvh6detail9IEEEFloat7convertERKNS_12fltSemanticsENS_11APFloatBase12roundingModeEPb(ptr noundef nonnull align 8 dereferenceable(24) %extended, ptr noundef nonnull align 4 dereferenceable(12) %extendedSemantics, i32 noundef 0, ptr noundef %losesInfo)
  store i32 %call, ptr %fs, align 4
  call void @_ZN4llvh6detail9IEEEFloatC1ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %u, ptr noundef nonnull align 8 dereferenceable(24) %extended)
  %call2 = call noundef i32 @_ZN4llvh6detail9IEEEFloat7convertERKNS_12fltSemanticsENS_11APFloatBase12roundingModeEPb(ptr noundef nonnull align 8 dereferenceable(24) %u, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL13semIEEEdoubleE, i32 noundef 0, ptr noundef %losesInfo)
  store i32 %call2, ptr %fs, align 4
  call void @_ZNK4llvh6detail9IEEEFloat27convertDoubleAPFloatToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp, ptr noundef nonnull align 8 dereferenceable(24) %u)
  %call3 = call noundef ptr @_ZNK4llvh5APInt10getRawDataEv(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp)
  %1 = load i64, ptr %call3, align 8
  %arrayidx = getelementptr inbounds [2 x i64], ptr %words, i64 0, i64 0
  store i64 %1, ptr %arrayidx, align 16
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp) #10
  %call4 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %u)
  br i1 %call4, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %2 = load i8, ptr %losesInfo, align 1
  %tobool = trunc i8 %2 to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %call5 = call noundef i32 @_ZN4llvh6detail9IEEEFloat7convertERKNS_12fltSemanticsENS_11APFloatBase12roundingModeEPb(ptr noundef nonnull align 8 dereferenceable(24) %u, ptr noundef nonnull align 4 dereferenceable(12) %extendedSemantics, i32 noundef 0, ptr noundef %losesInfo)
  store i32 %call5, ptr %fs, align 4
  call void @_ZN4llvh6detail9IEEEFloatC1ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %v, ptr noundef nonnull align 8 dereferenceable(24) %extended)
  %call6 = call noundef i32 @_ZN4llvh6detail9IEEEFloat8subtractERKS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %v, ptr noundef nonnull align 8 dereferenceable(24) %u, i32 noundef 0)
  %call7 = call noundef i32 @_ZN4llvh6detail9IEEEFloat7convertERKNS_12fltSemanticsENS_11APFloatBase12roundingModeEPb(ptr noundef nonnull align 8 dereferenceable(24) %v, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL13semIEEEdoubleE, i32 noundef 0, ptr noundef %losesInfo)
  store i32 %call7, ptr %fs, align 4
  call void @_ZNK4llvh6detail9IEEEFloat27convertDoubleAPFloatToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp8, ptr noundef nonnull align 8 dereferenceable(24) %v)
  %call9 = call noundef ptr @_ZNK4llvh5APInt10getRawDataEv(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp8)
  %3 = load i64, ptr %call9, align 8
  %arrayidx10 = getelementptr inbounds [2 x i64], ptr %words, i64 0, i64 1
  store i64 %3, ptr %arrayidx10, align 8
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp8) #10
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %v) #10
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  %arrayidx11 = getelementptr inbounds [2 x i64], ptr %words, i64 0, i64 1
  store i64 0, ptr %arrayidx11, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  call void @_ZN4llvh8ArrayRefImEC2ILm2EEERAT__Km(ptr noundef nonnull align 8 dereferenceable(16) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(16) %words)
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  call void @_ZN4llvh5APIntC1EjNS_8ArrayRefImEE(ptr noundef nonnull align 8 dereferenceable(12) %agg.result, i32 noundef 128, ptr %5, i64 %7)
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %u) #10
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %extended) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZNK4llvh6detail9IEEEFloat27convertDoubleAPFloatToAPIntEv(ptr noalias sret(%"class.llvh::APInt") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(24) %this) #1 align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %myexponent = alloca i64, align 8
  %mysignificand = alloca i64, align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %0 = load i16, ptr %exponent, align 8
  %conv = sext i16 %0 to i32
  %add = add nsw i32 %conv, 1023
  %conv2 = sext i32 %add to i64
  store i64 %conv2, ptr %myexponent, align 8
  %call3 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %1 = load i64, ptr %call3, align 8
  store i64 %1, ptr %mysignificand, align 8
  %2 = load i64, ptr %myexponent, align 8
  %cmp = icmp eq i64 %2, 1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %3 = load i64, ptr %mysignificand, align 8
  %and = and i64 %3, 4503599627370496
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.end, label %if.then4

if.then4:                                         ; preds = %land.lhs.true
  store i64 0, ptr %myexponent, align 8
  br label %if.end

if.end:                                           ; preds = %if.then4, %land.lhs.true, %if.then
  br label %if.end18

if.else:                                          ; preds = %entry
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, 7
  %bf.cast = zext i8 %bf.clear to i32
  %cmp5 = icmp eq i32 %bf.cast, 3
  br i1 %cmp5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.else
  store i64 0, ptr %myexponent, align 8
  store i64 0, ptr %mysignificand, align 8
  br label %if.end17

if.else7:                                         ; preds = %if.else
  %category8 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load9 = load i8, ptr %category8, align 2
  %bf.clear10 = and i8 %bf.load9, 7
  %bf.cast11 = zext i8 %bf.clear10 to i32
  %cmp12 = icmp eq i32 %bf.cast11, 0
  br i1 %cmp12, label %if.then13, label %if.else14

if.then13:                                        ; preds = %if.else7
  store i64 2047, ptr %myexponent, align 8
  store i64 0, ptr %mysignificand, align 8
  br label %if.end16

if.else14:                                        ; preds = %if.else7
  store i64 2047, ptr %myexponent, align 8
  %call15 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %4 = load i64, ptr %call15, align 8
  store i64 %4, ptr %mysignificand, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.else14, %if.then13
  br label %if.end17

if.end17:                                         ; preds = %if.end16, %if.then6
  br label %if.end18

if.end18:                                         ; preds = %if.end17, %if.end
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load19 = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load19, 3
  %bf.clear20 = and i8 %bf.lshr, 1
  %bf.cast21 = zext i8 %bf.clear20 to i32
  %and22 = and i32 %bf.cast21, 1
  %conv23 = sext i32 %and22 to i64
  %shl = shl i64 %conv23, 63
  %5 = load i64, ptr %myexponent, align 8
  %and24 = and i64 %5, 2047
  %shl25 = shl i64 %and24, 52
  %or = or i64 %shl, %shl25
  %6 = load i64, ptr %mysignificand, align 8
  %and26 = and i64 %6, 4503599627370495
  %or27 = or i64 %or, %and26
  call void @_ZN4llvh5APIntC2Ejmb(ptr noundef nonnull align 8 dereferenceable(12) %agg.result, i32 noundef 64, i64 noundef %or27, i1 noundef zeroext false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZNK4llvh6detail9IEEEFloat30convertQuadrupleAPFloatToAPIntEv(ptr noalias sret(%"class.llvh::APInt") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(24) %this) #1 align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %myexponent = alloca i64, align 8
  %mysignificand = alloca i64, align 8
  %mysignificand2 = alloca i64, align 8
  %words = alloca [2 x i64], align 16
  %agg.tmp = alloca %"class.llvh::ArrayRef", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %0 = load i16, ptr %exponent, align 8
  %conv = sext i16 %0 to i32
  %add = add nsw i32 %conv, 16383
  %conv2 = sext i32 %add to i64
  store i64 %conv2, ptr %myexponent, align 8
  %call3 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %arrayidx = getelementptr inbounds i64, ptr %call3, i64 0
  %1 = load i64, ptr %arrayidx, align 8
  store i64 %1, ptr %mysignificand, align 8
  %call4 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %arrayidx5 = getelementptr inbounds i64, ptr %call4, i64 1
  %2 = load i64, ptr %arrayidx5, align 8
  store i64 %2, ptr %mysignificand2, align 8
  %3 = load i64, ptr %myexponent, align 8
  %cmp = icmp eq i64 %3, 1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %4 = load i64, ptr %mysignificand2, align 8
  %and = and i64 %4, 281474976710656
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.end, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  store i64 0, ptr %myexponent, align 8
  br label %if.end

if.end:                                           ; preds = %if.then6, %land.lhs.true, %if.then
  br label %if.end23

if.else:                                          ; preds = %entry
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, 7
  %bf.cast = zext i8 %bf.clear to i32
  %cmp7 = icmp eq i32 %bf.cast, 3
  br i1 %cmp7, label %if.then8, label %if.else9

if.then8:                                         ; preds = %if.else
  store i64 0, ptr %myexponent, align 8
  store i64 0, ptr %mysignificand2, align 8
  store i64 0, ptr %mysignificand, align 8
  br label %if.end22

if.else9:                                         ; preds = %if.else
  %category10 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load11 = load i8, ptr %category10, align 2
  %bf.clear12 = and i8 %bf.load11, 7
  %bf.cast13 = zext i8 %bf.clear12 to i32
  %cmp14 = icmp eq i32 %bf.cast13, 0
  br i1 %cmp14, label %if.then15, label %if.else16

if.then15:                                        ; preds = %if.else9
  store i64 32767, ptr %myexponent, align 8
  store i64 0, ptr %mysignificand2, align 8
  store i64 0, ptr %mysignificand, align 8
  br label %if.end21

if.else16:                                        ; preds = %if.else9
  store i64 32767, ptr %myexponent, align 8
  %call17 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %arrayidx18 = getelementptr inbounds i64, ptr %call17, i64 0
  %5 = load i64, ptr %arrayidx18, align 8
  store i64 %5, ptr %mysignificand, align 8
  %call19 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %arrayidx20 = getelementptr inbounds i64, ptr %call19, i64 1
  %6 = load i64, ptr %arrayidx20, align 8
  store i64 %6, ptr %mysignificand2, align 8
  br label %if.end21

if.end21:                                         ; preds = %if.else16, %if.then15
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %if.then8
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %if.end
  %7 = load i64, ptr %mysignificand, align 8
  %arrayidx24 = getelementptr inbounds [2 x i64], ptr %words, i64 0, i64 0
  store i64 %7, ptr %arrayidx24, align 16
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load25 = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load25, 3
  %bf.clear26 = and i8 %bf.lshr, 1
  %bf.cast27 = zext i8 %bf.clear26 to i32
  %and28 = and i32 %bf.cast27, 1
  %conv29 = sext i32 %and28 to i64
  %shl = shl i64 %conv29, 63
  %8 = load i64, ptr %myexponent, align 8
  %and30 = and i64 %8, 32767
  %shl31 = shl i64 %and30, 48
  %or = or i64 %shl, %shl31
  %9 = load i64, ptr %mysignificand2, align 8
  %and32 = and i64 %9, 281474976710655
  %or33 = or i64 %or, %and32
  %arrayidx34 = getelementptr inbounds [2 x i64], ptr %words, i64 0, i64 1
  store i64 %or33, ptr %arrayidx34, align 8
  call void @_ZN4llvh8ArrayRefImEC2ILm2EEERAT__Km(ptr noundef nonnull align 8 dereferenceable(16) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(16) %words)
  %10 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %13 = load i64, ptr %12, align 8
  call void @_ZN4llvh5APIntC1EjNS_8ArrayRefImEE(ptr noundef nonnull align 8 dereferenceable(12) %agg.result, i32 noundef 128, ptr %11, i64 %13)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZNK4llvh6detail9IEEEFloat26convertFloatAPFloatToAPIntEv(ptr noalias sret(%"class.llvh::APInt") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(24) %this) #1 align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %myexponent = alloca i32, align 4
  %mysignificand = alloca i32, align 4
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %0 = load i16, ptr %exponent, align 8
  %conv = sext i16 %0 to i32
  %add = add nsw i32 %conv, 127
  store i32 %add, ptr %myexponent, align 4
  %call2 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %1 = load i64, ptr %call2, align 8
  %conv3 = trunc i64 %1 to i32
  store i32 %conv3, ptr %mysignificand, align 4
  %2 = load i32, ptr %myexponent, align 4
  %cmp = icmp eq i32 %2, 1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %3 = load i32, ptr %mysignificand, align 4
  %and = and i32 %3, 8388608
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then4

if.then4:                                         ; preds = %land.lhs.true
  store i32 0, ptr %myexponent, align 4
  br label %if.end

if.end:                                           ; preds = %if.then4, %land.lhs.true, %if.then
  br label %if.end19

if.else:                                          ; preds = %entry
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, 7
  %bf.cast = zext i8 %bf.clear to i32
  %cmp5 = icmp eq i32 %bf.cast, 3
  br i1 %cmp5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.else
  store i32 0, ptr %myexponent, align 4
  store i32 0, ptr %mysignificand, align 4
  br label %if.end18

if.else7:                                         ; preds = %if.else
  %category8 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load9 = load i8, ptr %category8, align 2
  %bf.clear10 = and i8 %bf.load9, 7
  %bf.cast11 = zext i8 %bf.clear10 to i32
  %cmp12 = icmp eq i32 %bf.cast11, 0
  br i1 %cmp12, label %if.then13, label %if.else14

if.then13:                                        ; preds = %if.else7
  store i32 255, ptr %myexponent, align 4
  store i32 0, ptr %mysignificand, align 4
  br label %if.end17

if.else14:                                        ; preds = %if.else7
  store i32 255, ptr %myexponent, align 4
  %call15 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %4 = load i64, ptr %call15, align 8
  %conv16 = trunc i64 %4 to i32
  store i32 %conv16, ptr %mysignificand, align 4
  br label %if.end17

if.end17:                                         ; preds = %if.else14, %if.then13
  br label %if.end18

if.end18:                                         ; preds = %if.end17, %if.then6
  br label %if.end19

if.end19:                                         ; preds = %if.end18, %if.end
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load20 = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load20, 3
  %bf.clear21 = and i8 %bf.lshr, 1
  %bf.cast22 = zext i8 %bf.clear21 to i32
  %and23 = and i32 %bf.cast22, 1
  %shl = shl i32 %and23, 31
  %5 = load i32, ptr %myexponent, align 4
  %and24 = and i32 %5, 255
  %shl25 = shl i32 %and24, 23
  %or = or i32 %shl, %shl25
  %6 = load i32, ptr %mysignificand, align 4
  %and26 = and i32 %6, 8388607
  %or27 = or i32 %or, %and26
  %conv28 = zext i32 %or27 to i64
  call void @_ZN4llvh5APIntC2Ejmb(ptr noundef nonnull align 8 dereferenceable(12) %agg.result, i32 noundef 32, i64 noundef %conv28, i1 noundef zeroext false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZNK4llvh6detail9IEEEFloat25convertHalfAPFloatToAPIntEv(ptr noalias sret(%"class.llvh::APInt") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(24) %this) #1 align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %myexponent = alloca i32, align 4
  %mysignificand = alloca i32, align 4
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %0 = load i16, ptr %exponent, align 8
  %conv = sext i16 %0 to i32
  %add = add nsw i32 %conv, 15
  store i32 %add, ptr %myexponent, align 4
  %call2 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %1 = load i64, ptr %call2, align 8
  %conv3 = trunc i64 %1 to i32
  store i32 %conv3, ptr %mysignificand, align 4
  %2 = load i32, ptr %myexponent, align 4
  %cmp = icmp eq i32 %2, 1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %3 = load i32, ptr %mysignificand, align 4
  %and = and i32 %3, 1024
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then4

if.then4:                                         ; preds = %land.lhs.true
  store i32 0, ptr %myexponent, align 4
  br label %if.end

if.end:                                           ; preds = %if.then4, %land.lhs.true, %if.then
  br label %if.end19

if.else:                                          ; preds = %entry
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, 7
  %bf.cast = zext i8 %bf.clear to i32
  %cmp5 = icmp eq i32 %bf.cast, 3
  br i1 %cmp5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.else
  store i32 0, ptr %myexponent, align 4
  store i32 0, ptr %mysignificand, align 4
  br label %if.end18

if.else7:                                         ; preds = %if.else
  %category8 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load9 = load i8, ptr %category8, align 2
  %bf.clear10 = and i8 %bf.load9, 7
  %bf.cast11 = zext i8 %bf.clear10 to i32
  %cmp12 = icmp eq i32 %bf.cast11, 0
  br i1 %cmp12, label %if.then13, label %if.else14

if.then13:                                        ; preds = %if.else7
  store i32 31, ptr %myexponent, align 4
  store i32 0, ptr %mysignificand, align 4
  br label %if.end17

if.else14:                                        ; preds = %if.else7
  store i32 31, ptr %myexponent, align 4
  %call15 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %4 = load i64, ptr %call15, align 8
  %conv16 = trunc i64 %4 to i32
  store i32 %conv16, ptr %mysignificand, align 4
  br label %if.end17

if.end17:                                         ; preds = %if.else14, %if.then13
  br label %if.end18

if.end18:                                         ; preds = %if.end17, %if.then6
  br label %if.end19

if.end19:                                         ; preds = %if.end18, %if.end
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load20 = load i8, ptr %sign, align 2
  %bf.lshr = lshr i8 %bf.load20, 3
  %bf.clear21 = and i8 %bf.lshr, 1
  %bf.cast22 = zext i8 %bf.clear21 to i32
  %and23 = and i32 %bf.cast22, 1
  %shl = shl i32 %and23, 15
  %5 = load i32, ptr %myexponent, align 4
  %and24 = and i32 %5, 31
  %shl25 = shl i32 %and24, 10
  %or = or i32 %shl, %shl25
  %6 = load i32, ptr %mysignificand, align 4
  %and26 = and i32 %6, 1023
  %or27 = or i32 %or, %and26
  %conv28 = zext i32 %or27 to i64
  call void @_ZN4llvh5APIntC2Ejmb(ptr noundef nonnull align 8 dereferenceable(12) %agg.result, i32 noundef 16, i64 noundef %conv28, i1 noundef zeroext false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZNK4llvh6detail9IEEEFloat14bitcastToAPIntEv(ptr noalias sret(%"class.llvh::APInt") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(24) %this) #1 align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %semantics, align 8
  %cmp = icmp eq ptr %0, @_ZN4llvhL11semIEEEhalfE
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @_ZNK4llvh6detail9IEEEFloat25convertHalfAPFloatToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br label %return

if.end:                                           ; preds = %entry
  %semantics2 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %semantics2, align 8
  %cmp3 = icmp eq ptr %1, @_ZN4llvhL13semIEEEsingleE
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  call void @_ZNK4llvh6detail9IEEEFloat26convertFloatAPFloatToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br label %return

if.end5:                                          ; preds = %if.end
  %semantics6 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %semantics6, align 8
  %cmp7 = icmp eq ptr %2, @_ZN4llvhL13semIEEEdoubleE
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end5
  call void @_ZNK4llvh6detail9IEEEFloat27convertDoubleAPFloatToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br label %return

if.end9:                                          ; preds = %if.end5
  %semantics10 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %semantics10, align 8
  %cmp11 = icmp eq ptr %3, @_ZN4llvhL11semIEEEquadE
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end9
  call void @_ZNK4llvh6detail9IEEEFloat30convertQuadrupleAPFloatToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br label %return

if.end13:                                         ; preds = %if.end9
  %semantics14 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %semantics14, align 8
  %cmp15 = icmp eq ptr %4, @_ZN4llvhL24semPPCDoubleDoubleLegacyE
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end13
  call void @_ZNK4llvh6detail9IEEEFloat36convertPPCDoubleDoubleAPFloatToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br label %return

if.end17:                                         ; preds = %if.end13
  call void @_ZNK4llvh6detail9IEEEFloat34convertF80LongDoubleAPFloatToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br label %return

return:                                           ; preds = %if.end17, %if.then16, %if.then12, %if.then8, %if.then4, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef float @_ZNK4llvh6detail9IEEEFloat14convertToFloatEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %api = alloca %"class.llvh::APInt", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZNK4llvh6detail9IEEEFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %api, ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call = call noundef float @_ZNK4llvh5APInt11bitsToFloatEv(ptr noundef nonnull align 8 dereferenceable(12) %api)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %api) #10
  ret float %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef float @_ZNK4llvh5APInt11bitsToFloatEv(ptr noundef nonnull align 8 dereferenceable(12) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i64 @_ZNK4llvh5APInt7getWordEj(ptr noundef nonnull align 8 dereferenceable(12) %this1, i32 noundef 0)
  %conv = trunc i64 %call to i32
  %call2 = call noundef float @_ZN4llvh11BitsToFloatEj(i32 noundef %conv)
  ret float %call2
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef double @_ZNK4llvh6detail9IEEEFloat15convertToDoubleEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %api = alloca %"class.llvh::APInt", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZNK4llvh6detail9IEEEFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %api, ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call = call noundef double @_ZNK4llvh5APInt12bitsToDoubleEv(ptr noundef nonnull align 8 dereferenceable(12) %api)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %api) #10
  ret double %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef double @_ZNK4llvh5APInt12bitsToDoubleEv(ptr noundef nonnull align 8 dereferenceable(12) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i64 @_ZNK4llvh5APInt7getWordEj(ptr noundef nonnull align 8 dereferenceable(12) %this1, i32 noundef 0)
  %call2 = call noundef double @_ZN4llvh12BitsToDoubleEm(i64 noundef %call)
  ret double %call2
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloat26initFromF80LongDoubleAPIntERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(12) %api) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %api.addr = alloca ptr, align 8
  %i1 = alloca i64, align 8
  %i2 = alloca i64, align 8
  %myexponent = alloca i64, align 8
  %mysignificand = alloca i64, align 8
  %myintegerbit = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  store ptr %api, ptr %api.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %api.addr, align 8
  %call = call noundef ptr @_ZNK4llvh5APInt10getRawDataEv(ptr noundef nonnull align 8 dereferenceable(12) %0)
  %arrayidx = getelementptr inbounds i64, ptr %call, i64 0
  %1 = load i64, ptr %arrayidx, align 8
  store i64 %1, ptr %i1, align 8
  %2 = load ptr, ptr %api.addr, align 8
  %call2 = call noundef ptr @_ZNK4llvh5APInt10getRawDataEv(ptr noundef nonnull align 8 dereferenceable(12) %2)
  %arrayidx3 = getelementptr inbounds i64, ptr %call2, i64 1
  %3 = load i64, ptr %arrayidx3, align 8
  store i64 %3, ptr %i2, align 8
  %4 = load i64, ptr %i2, align 8
  %and = and i64 %4, 32767
  store i64 %and, ptr %myexponent, align 8
  %5 = load i64, ptr %i1, align 8
  store i64 %5, ptr %mysignificand, align 8
  %6 = load i64, ptr %mysignificand, align 8
  %shr = lshr i64 %6, 63
  %conv = trunc i64 %shr to i8
  store i8 %conv, ptr %myintegerbit, align 1
  call void @_ZN4llvh6detail9IEEEFloat10initializeEPKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef @_ZN4llvhL20semX87DoubleExtendedE)
  %7 = load i64, ptr %i2, align 8
  %shr4 = lshr i64 %7, 15
  %conv5 = trunc i64 %shr4 to i32
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %8 = trunc i32 %conv5 to i8
  %bf.load = load i8, ptr %sign, align 2
  %bf.value = and i8 %8, 1
  %bf.shl = shl i8 %bf.value, 3
  %bf.clear = and i8 %bf.load, -9
  %bf.set = or i8 %bf.clear, %bf.shl
  store i8 %bf.set, ptr %sign, align 2
  %9 = load i64, ptr %myexponent, align 8
  %cmp = icmp eq i64 %9, 0
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %10 = load i64, ptr %mysignificand, align 8
  %cmp6 = icmp eq i64 %10, 0
  br i1 %cmp6, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load7 = load i8, ptr %category, align 2
  %bf.clear8 = and i8 %bf.load7, -8
  %bf.set9 = or i8 %bf.clear8, 3
  store i8 %bf.set9, ptr %category, align 2
  br label %if.end52

if.else:                                          ; preds = %land.lhs.true, %entry
  %11 = load i64, ptr %myexponent, align 8
  %cmp10 = icmp eq i64 %11, 32767
  br i1 %cmp10, label %land.lhs.true11, label %if.else18

land.lhs.true11:                                  ; preds = %if.else
  %12 = load i64, ptr %mysignificand, align 8
  %cmp12 = icmp eq i64 %12, -9223372036854775808
  br i1 %cmp12, label %if.then13, label %if.else18

if.then13:                                        ; preds = %land.lhs.true11
  %category14 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load15 = load i8, ptr %category14, align 2
  %bf.clear16 = and i8 %bf.load15, -8
  %bf.set17 = or i8 %bf.clear16, 0
  store i8 %bf.set17, ptr %category14, align 2
  br label %if.end51

if.else18:                                        ; preds = %land.lhs.true11, %if.else
  %13 = load i64, ptr %myexponent, align 8
  %cmp19 = icmp eq i64 %13, 32767
  br i1 %cmp19, label %land.lhs.true20, label %lor.lhs.false

land.lhs.true20:                                  ; preds = %if.else18
  %14 = load i64, ptr %mysignificand, align 8
  %cmp21 = icmp ne i64 %14, -9223372036854775808
  br i1 %cmp21, label %if.then28, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true20, %if.else18
  %15 = load i64, ptr %myexponent, align 8
  %cmp22 = icmp ne i64 %15, 32767
  br i1 %cmp22, label %land.lhs.true23, label %if.else37

land.lhs.true23:                                  ; preds = %lor.lhs.false
  %16 = load i64, ptr %myexponent, align 8
  %cmp24 = icmp ne i64 %16, 0
  br i1 %cmp24, label %land.lhs.true25, label %if.else37

land.lhs.true25:                                  ; preds = %land.lhs.true23
  %17 = load i8, ptr %myintegerbit, align 1
  %conv26 = zext i8 %17 to i32
  %cmp27 = icmp eq i32 %conv26, 0
  br i1 %cmp27, label %if.then28, label %if.else37

if.then28:                                        ; preds = %land.lhs.true25, %land.lhs.true20
  %category29 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load30 = load i8, ptr %category29, align 2
  %bf.clear31 = and i8 %bf.load30, -8
  %bf.set32 = or i8 %bf.clear31, 1
  store i8 %bf.set32, ptr %category29, align 2
  %18 = load i64, ptr %mysignificand, align 8
  %call33 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %arrayidx34 = getelementptr inbounds i64, ptr %call33, i64 0
  store i64 %18, ptr %arrayidx34, align 8
  %call35 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %arrayidx36 = getelementptr inbounds i64, ptr %call35, i64 1
  store i64 0, ptr %arrayidx36, align 8
  br label %if.end50

if.else37:                                        ; preds = %land.lhs.true25, %land.lhs.true23, %lor.lhs.false
  %category38 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load39 = load i8, ptr %category38, align 2
  %bf.clear40 = and i8 %bf.load39, -8
  %bf.set41 = or i8 %bf.clear40, 2
  store i8 %bf.set41, ptr %category38, align 2
  %19 = load i64, ptr %myexponent, align 8
  %sub = sub i64 %19, 16383
  %conv42 = trunc i64 %sub to i16
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 %conv42, ptr %exponent, align 8
  %20 = load i64, ptr %mysignificand, align 8
  %call43 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %arrayidx44 = getelementptr inbounds i64, ptr %call43, i64 0
  store i64 %20, ptr %arrayidx44, align 8
  %call45 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %arrayidx46 = getelementptr inbounds i64, ptr %call45, i64 1
  store i64 0, ptr %arrayidx46, align 8
  %21 = load i64, ptr %myexponent, align 8
  %cmp47 = icmp eq i64 %21, 0
  br i1 %cmp47, label %if.then48, label %if.end

if.then48:                                        ; preds = %if.else37
  %exponent49 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 -16382, ptr %exponent49, align 8
  br label %if.end

if.end:                                           ; preds = %if.then48, %if.else37
  br label %if.end50

if.end50:                                         ; preds = %if.end, %if.then28
  br label %if.end51

if.end51:                                         ; preds = %if.end50, %if.then13
  br label %if.end52

if.end52:                                         ; preds = %if.end51, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloat28initFromPPCDoubleDoubleAPIntERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(12) %api) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %api.addr = alloca ptr, align 8
  %i1 = alloca i64, align 8
  %i2 = alloca i64, align 8
  %fs = alloca i32, align 4
  %losesInfo = alloca i8, align 1
  %ref.tmp = alloca %"class.llvh::APInt", align 8
  %v = alloca %"class.llvh::detail::IEEEFloat", align 8
  %ref.tmp6 = alloca %"class.llvh::APInt", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %api, ptr %api.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %api.addr, align 8
  %call = call noundef ptr @_ZNK4llvh5APInt10getRawDataEv(ptr noundef nonnull align 8 dereferenceable(12) %0)
  %arrayidx = getelementptr inbounds i64, ptr %call, i64 0
  %1 = load i64, ptr %arrayidx, align 8
  store i64 %1, ptr %i1, align 8
  %2 = load ptr, ptr %api.addr, align 8
  %call2 = call noundef ptr @_ZNK4llvh5APInt10getRawDataEv(ptr noundef nonnull align 8 dereferenceable(12) %2)
  %arrayidx3 = getelementptr inbounds i64, ptr %call2, i64 1
  %3 = load i64, ptr %arrayidx3, align 8
  store i64 %3, ptr %i2, align 8
  %4 = load i64, ptr %i1, align 8
  call void @_ZN4llvh5APIntC2Ejmb(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp, i32 noundef 64, i64 noundef %4, i1 noundef zeroext false)
  call void @_ZN4llvh6detail9IEEEFloat19initFromDoubleAPIntERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp) #10
  %call4 = call noundef i32 @_ZN4llvh6detail9IEEEFloat7convertERKNS_12fltSemanticsENS_11APFloatBase12roundingModeEPb(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL24semPPCDoubleDoubleLegacyE, i32 noundef 0, ptr noundef %losesInfo)
  store i32 %call4, ptr %fs, align 4
  %call5 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call5, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load i64, ptr %i2, align 8
  call void @_ZN4llvh5APIntC2Ejmb(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp6, i32 noundef 64, i64 noundef %5, i1 noundef zeroext false)
  call void @_ZN4llvh6detail9IEEEFloatC1ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %v, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL13semIEEEdoubleE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp6)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp6) #10
  %call7 = call noundef i32 @_ZN4llvh6detail9IEEEFloat7convertERKNS_12fltSemanticsENS_11APFloatBase12roundingModeEPb(ptr noundef nonnull align 8 dereferenceable(24) %v, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL24semPPCDoubleDoubleLegacyE, i32 noundef 0, ptr noundef %losesInfo)
  store i32 %call7, ptr %fs, align 4
  %call8 = call noundef i32 @_ZN4llvh6detail9IEEEFloat3addERKS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %v, i32 noundef 0)
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %v) #10
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloat19initFromDoubleAPIntERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(12) %api) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %api.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %myexponent = alloca i64, align 8
  %mysignificand = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %api, ptr %api.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %api.addr, align 8
  %call = call noundef ptr @_ZNK4llvh5APInt10getRawDataEv(ptr noundef nonnull align 8 dereferenceable(12) %0)
  %1 = load i64, ptr %call, align 8
  store i64 %1, ptr %i, align 8
  %2 = load i64, ptr %i, align 8
  %shr = lshr i64 %2, 52
  %and = and i64 %shr, 2047
  store i64 %and, ptr %myexponent, align 8
  %3 = load i64, ptr %i, align 8
  %and2 = and i64 %3, 4503599627370495
  store i64 %and2, ptr %mysignificand, align 8
  call void @_ZN4llvh6detail9IEEEFloat10initializeEPKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef @_ZN4llvhL13semIEEEdoubleE)
  %4 = load i64, ptr %i, align 8
  %shr3 = lshr i64 %4, 63
  %conv = trunc i64 %shr3 to i32
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %5 = trunc i32 %conv to i8
  %bf.load = load i8, ptr %sign, align 2
  %bf.value = and i8 %5, 1
  %bf.shl = shl i8 %bf.value, 3
  %bf.clear = and i8 %bf.load, -9
  %bf.set = or i8 %bf.clear, %bf.shl
  store i8 %bf.set, ptr %sign, align 2
  %6 = load i64, ptr %myexponent, align 8
  %cmp = icmp eq i64 %6, 0
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %7 = load i64, ptr %mysignificand, align 8
  %cmp4 = icmp eq i64 %7, 0
  br i1 %cmp4, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load5 = load i8, ptr %category, align 2
  %bf.clear6 = and i8 %bf.load5, -8
  %bf.set7 = or i8 %bf.clear6, 3
  store i8 %bf.set7, ptr %category, align 2
  br label %if.end40

if.else:                                          ; preds = %land.lhs.true, %entry
  %8 = load i64, ptr %myexponent, align 8
  %cmp8 = icmp eq i64 %8, 2047
  br i1 %cmp8, label %land.lhs.true9, label %if.else16

land.lhs.true9:                                   ; preds = %if.else
  %9 = load i64, ptr %mysignificand, align 8
  %cmp10 = icmp eq i64 %9, 0
  br i1 %cmp10, label %if.then11, label %if.else16

if.then11:                                        ; preds = %land.lhs.true9
  %category12 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load13 = load i8, ptr %category12, align 2
  %bf.clear14 = and i8 %bf.load13, -8
  %bf.set15 = or i8 %bf.clear14, 0
  store i8 %bf.set15, ptr %category12, align 2
  br label %if.end39

if.else16:                                        ; preds = %land.lhs.true9, %if.else
  %10 = load i64, ptr %myexponent, align 8
  %cmp17 = icmp eq i64 %10, 2047
  br i1 %cmp17, label %land.lhs.true18, label %if.else26

land.lhs.true18:                                  ; preds = %if.else16
  %11 = load i64, ptr %mysignificand, align 8
  %cmp19 = icmp ne i64 %11, 0
  br i1 %cmp19, label %if.then20, label %if.else26

if.then20:                                        ; preds = %land.lhs.true18
  %category21 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load22 = load i8, ptr %category21, align 2
  %bf.clear23 = and i8 %bf.load22, -8
  %bf.set24 = or i8 %bf.clear23, 1
  store i8 %bf.set24, ptr %category21, align 2
  %12 = load i64, ptr %mysignificand, align 8
  %call25 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store i64 %12, ptr %call25, align 8
  br label %if.end38

if.else26:                                        ; preds = %land.lhs.true18, %if.else16
  %category27 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load28 = load i8, ptr %category27, align 2
  %bf.clear29 = and i8 %bf.load28, -8
  %bf.set30 = or i8 %bf.clear29, 2
  store i8 %bf.set30, ptr %category27, align 2
  %13 = load i64, ptr %myexponent, align 8
  %sub = sub i64 %13, 1023
  %conv31 = trunc i64 %sub to i16
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 %conv31, ptr %exponent, align 8
  %14 = load i64, ptr %mysignificand, align 8
  %call32 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store i64 %14, ptr %call32, align 8
  %15 = load i64, ptr %myexponent, align 8
  %cmp33 = icmp eq i64 %15, 0
  br i1 %cmp33, label %if.then34, label %if.else36

if.then34:                                        ; preds = %if.else26
  %exponent35 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 -1022, ptr %exponent35, align 8
  br label %if.end

if.else36:                                        ; preds = %if.else26
  %call37 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %16 = load i64, ptr %call37, align 8
  %or = or i64 %16, 4503599627370496
  store i64 %or, ptr %call37, align 8
  br label %if.end

if.end:                                           ; preds = %if.else36, %if.then34
  br label %if.end38

if.end38:                                         ; preds = %if.end, %if.then20
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.then11
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloat22initFromQuadrupleAPIntERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(12) %api) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %api.addr = alloca ptr, align 8
  %i1 = alloca i64, align 8
  %i2 = alloca i64, align 8
  %myexponent = alloca i64, align 8
  %mysignificand = alloca i64, align 8
  %mysignificand2 = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %api, ptr %api.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %api.addr, align 8
  %call = call noundef ptr @_ZNK4llvh5APInt10getRawDataEv(ptr noundef nonnull align 8 dereferenceable(12) %0)
  %arrayidx = getelementptr inbounds i64, ptr %call, i64 0
  %1 = load i64, ptr %arrayidx, align 8
  store i64 %1, ptr %i1, align 8
  %2 = load ptr, ptr %api.addr, align 8
  %call2 = call noundef ptr @_ZNK4llvh5APInt10getRawDataEv(ptr noundef nonnull align 8 dereferenceable(12) %2)
  %arrayidx3 = getelementptr inbounds i64, ptr %call2, i64 1
  %3 = load i64, ptr %arrayidx3, align 8
  store i64 %3, ptr %i2, align 8
  %4 = load i64, ptr %i2, align 8
  %shr = lshr i64 %4, 48
  %and = and i64 %shr, 32767
  store i64 %and, ptr %myexponent, align 8
  %5 = load i64, ptr %i1, align 8
  store i64 %5, ptr %mysignificand, align 8
  %6 = load i64, ptr %i2, align 8
  %and4 = and i64 %6, 281474976710655
  store i64 %and4, ptr %mysignificand2, align 8
  call void @_ZN4llvh6detail9IEEEFloat10initializeEPKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef @_ZN4llvhL11semIEEEquadE)
  %7 = load i64, ptr %i2, align 8
  %shr5 = lshr i64 %7, 63
  %conv = trunc i64 %shr5 to i32
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %8 = trunc i32 %conv to i8
  %bf.load = load i8, ptr %sign, align 2
  %bf.value = and i8 %8, 1
  %bf.shl = shl i8 %bf.value, 3
  %bf.clear = and i8 %bf.load, -9
  %bf.set = or i8 %bf.clear, %bf.shl
  store i8 %bf.set, ptr %sign, align 2
  %9 = load i64, ptr %myexponent, align 8
  %cmp = icmp eq i64 %9, 0
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %10 = load i64, ptr %mysignificand, align 8
  %cmp6 = icmp eq i64 %10, 0
  br i1 %cmp6, label %land.lhs.true7, label %if.else

land.lhs.true7:                                   ; preds = %land.lhs.true
  %11 = load i64, ptr %mysignificand2, align 8
  %cmp8 = icmp eq i64 %11, 0
  br i1 %cmp8, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true7
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load9 = load i8, ptr %category, align 2
  %bf.clear10 = and i8 %bf.load9, -8
  %bf.set11 = or i8 %bf.clear10, 3
  store i8 %bf.set11, ptr %category, align 2
  br label %if.end54

if.else:                                          ; preds = %land.lhs.true7, %land.lhs.true, %entry
  %12 = load i64, ptr %myexponent, align 8
  %cmp12 = icmp eq i64 %12, 32767
  br i1 %cmp12, label %land.lhs.true13, label %if.else22

land.lhs.true13:                                  ; preds = %if.else
  %13 = load i64, ptr %mysignificand, align 8
  %cmp14 = icmp eq i64 %13, 0
  br i1 %cmp14, label %land.lhs.true15, label %if.else22

land.lhs.true15:                                  ; preds = %land.lhs.true13
  %14 = load i64, ptr %mysignificand2, align 8
  %cmp16 = icmp eq i64 %14, 0
  br i1 %cmp16, label %if.then17, label %if.else22

if.then17:                                        ; preds = %land.lhs.true15
  %category18 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load19 = load i8, ptr %category18, align 2
  %bf.clear20 = and i8 %bf.load19, -8
  %bf.set21 = or i8 %bf.clear20, 0
  store i8 %bf.set21, ptr %category18, align 2
  br label %if.end53

if.else22:                                        ; preds = %land.lhs.true15, %land.lhs.true13, %if.else
  %15 = load i64, ptr %myexponent, align 8
  %cmp23 = icmp eq i64 %15, 32767
  br i1 %cmp23, label %land.lhs.true24, label %if.else36

land.lhs.true24:                                  ; preds = %if.else22
  %16 = load i64, ptr %mysignificand, align 8
  %cmp25 = icmp ne i64 %16, 0
  br i1 %cmp25, label %if.then27, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true24
  %17 = load i64, ptr %mysignificand2, align 8
  %cmp26 = icmp ne i64 %17, 0
  br i1 %cmp26, label %if.then27, label %if.else36

if.then27:                                        ; preds = %lor.lhs.false, %land.lhs.true24
  %category28 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load29 = load i8, ptr %category28, align 2
  %bf.clear30 = and i8 %bf.load29, -8
  %bf.set31 = or i8 %bf.clear30, 1
  store i8 %bf.set31, ptr %category28, align 2
  %18 = load i64, ptr %mysignificand, align 8
  %call32 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %arrayidx33 = getelementptr inbounds i64, ptr %call32, i64 0
  store i64 %18, ptr %arrayidx33, align 8
  %19 = load i64, ptr %mysignificand2, align 8
  %call34 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %arrayidx35 = getelementptr inbounds i64, ptr %call34, i64 1
  store i64 %19, ptr %arrayidx35, align 8
  br label %if.end52

if.else36:                                        ; preds = %lor.lhs.false, %if.else22
  %category37 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load38 = load i8, ptr %category37, align 2
  %bf.clear39 = and i8 %bf.load38, -8
  %bf.set40 = or i8 %bf.clear39, 2
  store i8 %bf.set40, ptr %category37, align 2
  %20 = load i64, ptr %myexponent, align 8
  %sub = sub i64 %20, 16383
  %conv41 = trunc i64 %sub to i16
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 %conv41, ptr %exponent, align 8
  %21 = load i64, ptr %mysignificand, align 8
  %call42 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %arrayidx43 = getelementptr inbounds i64, ptr %call42, i64 0
  store i64 %21, ptr %arrayidx43, align 8
  %22 = load i64, ptr %mysignificand2, align 8
  %call44 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %arrayidx45 = getelementptr inbounds i64, ptr %call44, i64 1
  store i64 %22, ptr %arrayidx45, align 8
  %23 = load i64, ptr %myexponent, align 8
  %cmp46 = icmp eq i64 %23, 0
  br i1 %cmp46, label %if.then47, label %if.else49

if.then47:                                        ; preds = %if.else36
  %exponent48 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 -16382, ptr %exponent48, align 8
  br label %if.end

if.else49:                                        ; preds = %if.else36
  %call50 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %arrayidx51 = getelementptr inbounds i64, ptr %call50, i64 1
  %24 = load i64, ptr %arrayidx51, align 8
  %or = or i64 %24, 281474976710656
  store i64 %or, ptr %arrayidx51, align 8
  br label %if.end

if.end:                                           ; preds = %if.else49, %if.then47
  br label %if.end52

if.end52:                                         ; preds = %if.end, %if.then27
  br label %if.end53

if.end53:                                         ; preds = %if.end52, %if.then17
  br label %if.end54

if.end54:                                         ; preds = %if.end53, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloat18initFromFloatAPIntERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(12) %api) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %api.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  %myexponent = alloca i32, align 4
  %mysignificand = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %api, ptr %api.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %api.addr, align 8
  %call = call noundef ptr @_ZNK4llvh5APInt10getRawDataEv(ptr noundef nonnull align 8 dereferenceable(12) %0)
  %1 = load i64, ptr %call, align 8
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %i, align 4
  %2 = load i32, ptr %i, align 4
  %shr = lshr i32 %2, 23
  %and = and i32 %shr, 255
  store i32 %and, ptr %myexponent, align 4
  %3 = load i32, ptr %i, align 4
  %and2 = and i32 %3, 8388607
  store i32 %and2, ptr %mysignificand, align 4
  call void @_ZN4llvh6detail9IEEEFloat10initializeEPKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef @_ZN4llvhL13semIEEEsingleE)
  %4 = load i32, ptr %i, align 4
  %shr3 = lshr i32 %4, 31
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %5 = trunc i32 %shr3 to i8
  %bf.load = load i8, ptr %sign, align 2
  %bf.value = and i8 %5, 1
  %bf.shl = shl i8 %bf.value, 3
  %bf.clear = and i8 %bf.load, -9
  %bf.set = or i8 %bf.clear, %bf.shl
  store i8 %bf.set, ptr %sign, align 2
  %6 = load i32, ptr %myexponent, align 4
  %cmp = icmp eq i32 %6, 0
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %7 = load i32, ptr %mysignificand, align 4
  %cmp4 = icmp eq i32 %7, 0
  br i1 %cmp4, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load5 = load i8, ptr %category, align 2
  %bf.clear6 = and i8 %bf.load5, -8
  %bf.set7 = or i8 %bf.clear6, 3
  store i8 %bf.set7, ptr %category, align 2
  br label %if.end42

if.else:                                          ; preds = %land.lhs.true, %entry
  %8 = load i32, ptr %myexponent, align 4
  %cmp8 = icmp eq i32 %8, 255
  br i1 %cmp8, label %land.lhs.true9, label %if.else16

land.lhs.true9:                                   ; preds = %if.else
  %9 = load i32, ptr %mysignificand, align 4
  %cmp10 = icmp eq i32 %9, 0
  br i1 %cmp10, label %if.then11, label %if.else16

if.then11:                                        ; preds = %land.lhs.true9
  %category12 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load13 = load i8, ptr %category12, align 2
  %bf.clear14 = and i8 %bf.load13, -8
  %bf.set15 = or i8 %bf.clear14, 0
  store i8 %bf.set15, ptr %category12, align 2
  br label %if.end41

if.else16:                                        ; preds = %land.lhs.true9, %if.else
  %10 = load i32, ptr %myexponent, align 4
  %cmp17 = icmp eq i32 %10, 255
  br i1 %cmp17, label %land.lhs.true18, label %if.else27

land.lhs.true18:                                  ; preds = %if.else16
  %11 = load i32, ptr %mysignificand, align 4
  %cmp19 = icmp ne i32 %11, 0
  br i1 %cmp19, label %if.then20, label %if.else27

if.then20:                                        ; preds = %land.lhs.true18
  %category21 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load22 = load i8, ptr %category21, align 2
  %bf.clear23 = and i8 %bf.load22, -8
  %bf.set24 = or i8 %bf.clear23, 1
  store i8 %bf.set24, ptr %category21, align 2
  %12 = load i32, ptr %mysignificand, align 4
  %conv25 = zext i32 %12 to i64
  %call26 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store i64 %conv25, ptr %call26, align 8
  br label %if.end40

if.else27:                                        ; preds = %land.lhs.true18, %if.else16
  %category28 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load29 = load i8, ptr %category28, align 2
  %bf.clear30 = and i8 %bf.load29, -8
  %bf.set31 = or i8 %bf.clear30, 2
  store i8 %bf.set31, ptr %category28, align 2
  %13 = load i32, ptr %myexponent, align 4
  %sub = sub i32 %13, 127
  %conv32 = trunc i32 %sub to i16
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 %conv32, ptr %exponent, align 8
  %14 = load i32, ptr %mysignificand, align 4
  %conv33 = zext i32 %14 to i64
  %call34 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store i64 %conv33, ptr %call34, align 8
  %15 = load i32, ptr %myexponent, align 4
  %cmp35 = icmp eq i32 %15, 0
  br i1 %cmp35, label %if.then36, label %if.else38

if.then36:                                        ; preds = %if.else27
  %exponent37 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 -126, ptr %exponent37, align 8
  br label %if.end

if.else38:                                        ; preds = %if.else27
  %call39 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %16 = load i64, ptr %call39, align 8
  %or = or i64 %16, 8388608
  store i64 %or, ptr %call39, align 8
  br label %if.end

if.end:                                           ; preds = %if.else38, %if.then36
  br label %if.end40

if.end40:                                         ; preds = %if.end, %if.then20
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.then11
  br label %if.end42

if.end42:                                         ; preds = %if.end41, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloat17initFromHalfAPIntERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(12) %api) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %api.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  %myexponent = alloca i32, align 4
  %mysignificand = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %api, ptr %api.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %api.addr, align 8
  %call = call noundef ptr @_ZNK4llvh5APInt10getRawDataEv(ptr noundef nonnull align 8 dereferenceable(12) %0)
  %1 = load i64, ptr %call, align 8
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %i, align 4
  %2 = load i32, ptr %i, align 4
  %shr = lshr i32 %2, 10
  %and = and i32 %shr, 31
  store i32 %and, ptr %myexponent, align 4
  %3 = load i32, ptr %i, align 4
  %and2 = and i32 %3, 1023
  store i32 %and2, ptr %mysignificand, align 4
  call void @_ZN4llvh6detail9IEEEFloat10initializeEPKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef @_ZN4llvhL11semIEEEhalfE)
  %4 = load i32, ptr %i, align 4
  %shr3 = lshr i32 %4, 15
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %5 = trunc i32 %shr3 to i8
  %bf.load = load i8, ptr %sign, align 2
  %bf.value = and i8 %5, 1
  %bf.shl = shl i8 %bf.value, 3
  %bf.clear = and i8 %bf.load, -9
  %bf.set = or i8 %bf.clear, %bf.shl
  store i8 %bf.set, ptr %sign, align 2
  %6 = load i32, ptr %myexponent, align 4
  %cmp = icmp eq i32 %6, 0
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %7 = load i32, ptr %mysignificand, align 4
  %cmp4 = icmp eq i32 %7, 0
  br i1 %cmp4, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load5 = load i8, ptr %category, align 2
  %bf.clear6 = and i8 %bf.load5, -8
  %bf.set7 = or i8 %bf.clear6, 3
  store i8 %bf.set7, ptr %category, align 2
  br label %if.end42

if.else:                                          ; preds = %land.lhs.true, %entry
  %8 = load i32, ptr %myexponent, align 4
  %cmp8 = icmp eq i32 %8, 31
  br i1 %cmp8, label %land.lhs.true9, label %if.else16

land.lhs.true9:                                   ; preds = %if.else
  %9 = load i32, ptr %mysignificand, align 4
  %cmp10 = icmp eq i32 %9, 0
  br i1 %cmp10, label %if.then11, label %if.else16

if.then11:                                        ; preds = %land.lhs.true9
  %category12 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load13 = load i8, ptr %category12, align 2
  %bf.clear14 = and i8 %bf.load13, -8
  %bf.set15 = or i8 %bf.clear14, 0
  store i8 %bf.set15, ptr %category12, align 2
  br label %if.end41

if.else16:                                        ; preds = %land.lhs.true9, %if.else
  %10 = load i32, ptr %myexponent, align 4
  %cmp17 = icmp eq i32 %10, 31
  br i1 %cmp17, label %land.lhs.true18, label %if.else27

land.lhs.true18:                                  ; preds = %if.else16
  %11 = load i32, ptr %mysignificand, align 4
  %cmp19 = icmp ne i32 %11, 0
  br i1 %cmp19, label %if.then20, label %if.else27

if.then20:                                        ; preds = %land.lhs.true18
  %category21 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load22 = load i8, ptr %category21, align 2
  %bf.clear23 = and i8 %bf.load22, -8
  %bf.set24 = or i8 %bf.clear23, 1
  store i8 %bf.set24, ptr %category21, align 2
  %12 = load i32, ptr %mysignificand, align 4
  %conv25 = zext i32 %12 to i64
  %call26 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store i64 %conv25, ptr %call26, align 8
  br label %if.end40

if.else27:                                        ; preds = %land.lhs.true18, %if.else16
  %category28 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load29 = load i8, ptr %category28, align 2
  %bf.clear30 = and i8 %bf.load29, -8
  %bf.set31 = or i8 %bf.clear30, 2
  store i8 %bf.set31, ptr %category28, align 2
  %13 = load i32, ptr %myexponent, align 4
  %sub = sub i32 %13, 15
  %conv32 = trunc i32 %sub to i16
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 %conv32, ptr %exponent, align 8
  %14 = load i32, ptr %mysignificand, align 4
  %conv33 = zext i32 %14 to i64
  %call34 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store i64 %conv33, ptr %call34, align 8
  %15 = load i32, ptr %myexponent, align 4
  %cmp35 = icmp eq i32 %15, 0
  br i1 %cmp35, label %if.then36, label %if.else38

if.then36:                                        ; preds = %if.else27
  %exponent37 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 -14, ptr %exponent37, align 8
  br label %if.end

if.else38:                                        ; preds = %if.else27
  %call39 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %16 = load i64, ptr %call39, align 8
  %or = or i64 %16, 1024
  store i64 %or, ptr %call39, align 8
  br label %if.end

if.end:                                           ; preds = %if.else38, %if.then36
  br label %if.end40

if.end40:                                         ; preds = %if.end, %if.then20
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.then11
  br label %if.end42

if.end42:                                         ; preds = %if.end41, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloat13initFromAPIntEPKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %Sem, ptr noundef nonnull align 8 dereferenceable(12) %api) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Sem.addr = alloca ptr, align 8
  %api.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %Sem, ptr %Sem.addr, align 8
  store ptr %api, ptr %api.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %Sem.addr, align 8
  %cmp = icmp eq ptr %0, @_ZN4llvhL11semIEEEhalfE
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %api.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloat17initFromHalfAPIntERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(12) %1)
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %Sem.addr, align 8
  %cmp2 = icmp eq ptr %2, @_ZN4llvhL13semIEEEsingleE
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %3 = load ptr, ptr %api.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloat18initFromFloatAPIntERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(12) %3)
  br label %return

if.end4:                                          ; preds = %if.end
  %4 = load ptr, ptr %Sem.addr, align 8
  %cmp5 = icmp eq ptr %4, @_ZN4llvhL13semIEEEdoubleE
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  %5 = load ptr, ptr %api.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloat19initFromDoubleAPIntERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(12) %5)
  br label %return

if.end7:                                          ; preds = %if.end4
  %6 = load ptr, ptr %Sem.addr, align 8
  %cmp8 = icmp eq ptr %6, @_ZN4llvhL20semX87DoubleExtendedE
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end7
  %7 = load ptr, ptr %api.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloat26initFromF80LongDoubleAPIntERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(12) %7)
  br label %return

if.end10:                                         ; preds = %if.end7
  %8 = load ptr, ptr %Sem.addr, align 8
  %cmp11 = icmp eq ptr %8, @_ZN4llvhL11semIEEEquadE
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end10
  %9 = load ptr, ptr %api.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloat22initFromQuadrupleAPIntERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(12) %9)
  br label %return

if.end13:                                         ; preds = %if.end10
  %10 = load ptr, ptr %Sem.addr, align 8
  %cmp14 = icmp eq ptr %10, @_ZN4llvhL24semPPCDoubleDoubleLegacyE
  br i1 %cmp14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end13
  %11 = load ptr, ptr %api.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloat28initFromPPCDoubleDoubleAPIntERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(12) %11)
  br label %return

if.end16:                                         ; preds = %if.end13
  unreachable

return:                                           ; preds = %if.then15, %if.then12, %if.then9, %if.then6, %if.then3, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloat11makeLargestEb(ptr noundef nonnull align 8 dereferenceable(24) %this, i1 noundef zeroext %Negative) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Negative.addr = alloca i8, align 1
  %significand = alloca ptr, align 8
  %PartCount = alloca i32, align 4
  %NumUnusedHighBits = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %Negative to i8
  store i8 %frombool, ptr %Negative.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, -8
  %bf.set = or i8 %bf.clear, 2
  store i8 %bf.set, ptr %category, align 2
  %0 = load i8, ptr %Negative.addr, align 1
  %tobool = trunc i8 %0 to i1
  %conv = zext i1 %tobool to i32
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %1 = trunc i32 %conv to i8
  %bf.load2 = load i8, ptr %sign, align 2
  %bf.value = and i8 %1, 1
  %bf.shl = shl i8 %bf.value, 3
  %bf.clear3 = and i8 %bf.load2, -9
  %bf.set4 = or i8 %bf.clear3, %bf.shl
  store i8 %bf.set4, ptr %sign, align 2
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %semantics, align 8
  %maxExponent = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %2, i32 0, i32 0
  %3 = load i16, ptr %maxExponent, align 4
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 %3, ptr %exponent, align 8
  %call = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store ptr %call, ptr %significand, align 8
  %call5 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store i32 %call5, ptr %PartCount, align 4
  %4 = load ptr, ptr %significand, align 8
  %5 = load i32, ptr %PartCount, align 4
  %sub = sub i32 %5, 1
  %conv6 = zext i32 %sub to i64
  %mul = mul i64 8, %conv6
  call void @llvm.memset.p0.i64(ptr align 8 %4, i8 -1, i64 %mul, i1 false)
  %6 = load i32, ptr %PartCount, align 4
  %mul7 = mul i32 %6, 64
  %semantics8 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %7 = load ptr, ptr %semantics8, align 8
  %precision = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %7, i32 0, i32 2
  %8 = load i32, ptr %precision, align 4
  %sub9 = sub i32 %mul7, %8
  store i32 %sub9, ptr %NumUnusedHighBits, align 4
  %9 = load i32, ptr %NumUnusedHighBits, align 4
  %cmp = icmp ult i32 %9, 64
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %10 = load i32, ptr %NumUnusedHighBits, align 4
  %sh_prom = zext i32 %10 to i64
  %shr = lshr i64 -1, %sh_prom
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %shr, %cond.true ], [ 0, %cond.false ]
  %11 = load ptr, ptr %significand, align 8
  %12 = load i32, ptr %PartCount, align 4
  %sub10 = sub i32 %12, 1
  %idxprom = zext i32 %sub10 to i64
  %arrayidx = getelementptr inbounds i64, ptr %11, i64 %idxprom
  store i64 %cond, ptr %arrayidx, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloat12makeSmallestEb(ptr noundef nonnull align 8 dereferenceable(24) %this, i1 noundef zeroext %Negative) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Negative.addr = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %Negative to i8
  store i8 %frombool, ptr %Negative.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, -8
  %bf.set = or i8 %bf.clear, 2
  store i8 %bf.set, ptr %category, align 2
  %0 = load i8, ptr %Negative.addr, align 1
  %tobool = trunc i8 %0 to i1
  %conv = zext i1 %tobool to i32
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %1 = trunc i32 %conv to i8
  %bf.load2 = load i8, ptr %sign, align 2
  %bf.value = and i8 %1, 1
  %bf.shl = shl i8 %bf.value, 3
  %bf.clear3 = and i8 %bf.load2, -9
  %bf.set4 = or i8 %bf.clear3, %bf.shl
  store i8 %bf.set4, ptr %sign, align 2
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %semantics, align 8
  %minExponent = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %2, i32 0, i32 1
  %3 = load i16, ptr %minExponent, align 2
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 %3, ptr %exponent, align 8
  %call = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call5 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  call void @_ZN4llvh5APInt5tcSetEPmmj(ptr noundef %call, i64 noundef 1, i32 noundef %call5)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloat22makeSmallestNormalizedEb(ptr noundef nonnull align 8 dereferenceable(24) %this, i1 noundef zeroext %Negative) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Negative.addr = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %Negative to i8
  store i8 %frombool, ptr %Negative.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, -8
  %bf.set = or i8 %bf.clear, 2
  store i8 %bf.set, ptr %category, align 2
  call void @_ZN4llvh6detail9IEEEFloat15zeroSignificandEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %0 = load i8, ptr %Negative.addr, align 1
  %tobool = trunc i8 %0 to i1
  %conv = zext i1 %tobool to i32
  %sign = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %1 = trunc i32 %conv to i8
  %bf.load2 = load i8, ptr %sign, align 2
  %bf.value = and i8 %1, 1
  %bf.shl = shl i8 %bf.value, 3
  %bf.clear3 = and i8 %bf.load2, -9
  %bf.set4 = or i8 %bf.clear3, %bf.shl
  store i8 %bf.set4, ptr %sign, align 2
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %semantics, align 8
  %minExponent = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %2, i32 0, i32 1
  %3 = load i16, ptr %minExponent, align 2
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 %3, ptr %exponent, align 8
  %semantics5 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %semantics5, align 8
  %precision = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %4, i32 0, i32 2
  %5 = load i32, ptr %precision, align 4
  %sub = sub i32 %5, 1
  %rem = urem i32 %sub, 64
  %sh_prom = zext i32 %rem to i64
  %shl = shl i64 1, %sh_prom
  %call = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %semantics6 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %6 = load ptr, ptr %semantics6, align 8
  %precision7 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %6, i32 0, i32 2
  %7 = load i32, ptr %precision7, align 4
  %call8 = call noundef i32 @_ZN4llvhL16partCountForBitsEj(i32 noundef %7)
  %sub9 = sub i32 %call8, 1
  %idxprom = zext i32 %sub9 to i64
  %arrayidx = getelementptr inbounds i64, ptr %call, i64 %idxprom
  %8 = load i64, ptr %arrayidx, align 8
  %or = or i64 %8, %shl
  store i64 %or, ptr %arrayidx, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 4 dereferenceable(12) %Sem, ptr noundef nonnull align 8 dereferenceable(12) %API) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Sem.addr = alloca ptr, align 8
  %API.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %Sem, ptr %Sem.addr, align 8
  store ptr %API, ptr %API.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %Sem.addr, align 8
  %1 = load ptr, ptr %API.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloat13initFromAPIntEPKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %0, ptr noundef nonnull align 8 dereferenceable(12) %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloatC2Ef(ptr noundef nonnull align 8 dereferenceable(24) %this, float noundef %f) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %f.addr = alloca float, align 4
  %ref.tmp = alloca %"class.llvh::APInt", align 8
  store ptr %this, ptr %this.addr, align 8
  store float %f, ptr %f.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load float, ptr %f.addr, align 4
  call void @_ZN4llvh5APInt11floatToBitsEf(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp, float noundef %0)
  call void @_ZN4llvh6detail9IEEEFloat13initFromAPIntEPKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef @_ZN4llvhL13semIEEEsingleE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh5APInt11floatToBitsEf(ptr noalias sret(%"class.llvh::APInt") align 8 %agg.result, float noundef %V) #1 comdat align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %V.addr = alloca float, align 4
  store ptr %agg.result, ptr %result.ptr, align 8
  store float %V, ptr %V.addr, align 4
  %0 = load float, ptr %V.addr, align 4
  %call = call noundef i32 @_ZN4llvh11FloatToBitsEf(float noundef %0)
  %conv = zext i32 %call to i64
  call void @_ZN4llvh5APIntC2Ejmb(ptr noundef nonnull align 8 dereferenceable(12) %agg.result, i32 noundef 32, i64 noundef %conv, i1 noundef zeroext false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloatC2Ed(ptr noundef nonnull align 8 dereferenceable(24) %this, double noundef %d) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %d.addr = alloca double, align 8
  %ref.tmp = alloca %"class.llvh::APInt", align 8
  store ptr %this, ptr %this.addr, align 8
  store double %d, ptr %d.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load double, ptr %d.addr, align 8
  call void @_ZN4llvh5APInt12doubleToBitsEd(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp, double noundef %0)
  call void @_ZN4llvh6detail9IEEEFloat13initFromAPIntEPKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef @_ZN4llvhL13semIEEEdoubleE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh5APInt12doubleToBitsEd(ptr noalias sret(%"class.llvh::APInt") align 8 %agg.result, double noundef %V) #1 comdat align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %V.addr = alloca double, align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store double %V, ptr %V.addr, align 8
  %0 = load double, ptr %V.addr, align 8
  %call = call noundef i64 @_ZN4llvh12DoubleToBitsEd(double noundef %0)
  call void @_ZN4llvh5APIntC2Ejmb(ptr noundef nonnull align 8 dereferenceable(12) %agg.result, i32 noundef 64, i64 noundef %call, i1 noundef zeroext false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZNK4llvh6detail9IEEEFloat8toStringERNS_15SmallVectorImplIcEEjjb(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(16) %Str, i32 noundef %FormatPrecision, i32 noundef %FormatMaxPadding, i1 noundef zeroext %TruncateZero) #1 align 2 {
entry:
  %this.addr.i334 = alloca ptr, align 8
  %this.addr.i332 = alloca ptr, align 8
  %this.addr.i330 = alloca ptr, align 8
  %this.addr.i328 = alloca ptr, align 8
  %this.addr.i326 = alloca ptr, align 8
  %this.addr.i324 = alloca ptr, align 8
  %this.addr.i319 = alloca ptr, align 8
  %idx.addr.i320 = alloca i64, align 8
  %this.addr.i314 = alloca ptr, align 8
  %idx.addr.i315 = alloca i64, align 8
  %this.addr.i309 = alloca ptr, align 8
  %idx.addr.i310 = alloca i64, align 8
  %this.addr.i304 = alloca ptr, align 8
  %idx.addr.i305 = alloca i64, align 8
  %this.addr.i299 = alloca ptr, align 8
  %idx.addr.i300 = alloca i64, align 8
  %this.addr.i296 = alloca ptr, align 8
  %idx.addr.i = alloca i64, align 8
  %this.addr.i286 = alloca ptr, align 8
  %Str.addr.i287 = alloca ptr, align 8
  %this.addr.i276 = alloca ptr, align 8
  %Str.addr.i277 = alloca ptr, align 8
  %this.addr.i266 = alloca ptr, align 8
  %Str.addr.i267 = alloca ptr, align 8
  %this.addr.i256 = alloca ptr, align 8
  %Str.addr.i257 = alloca ptr, align 8
  %this.addr.i246 = alloca ptr, align 8
  %Str.addr.i247 = alloca ptr, align 8
  %this.addr.i = alloca ptr, align 8
  %Str.addr.i = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %Str.addr = alloca ptr, align 8
  %FormatPrecision.addr = alloca i32, align 4
  %FormatMaxPadding.addr = alloca i32, align 4
  %TruncateZero.addr = alloca i8, align 1
  %agg.tmp = alloca %"class.llvh::StringRef", align 8
  %agg.tmp2 = alloca %"class.llvh::StringRef", align 8
  %agg.tmp4 = alloca %"class.llvh::StringRef", align 8
  %ref.tmp = alloca i8, align 1
  %agg.tmp11 = alloca %"class.llvh::StringRef", align 8
  %agg.tmp13 = alloca %"class.llvh::StringRef", align 8
  %ref.tmp15 = alloca i8, align 1
  %agg.tmp17 = alloca %"class.llvh::StringRef", align 8
  %ref.tmp20 = alloca i8, align 1
  %ref.tmp25 = alloca i8, align 1
  %exp = alloca i32, align 4
  %significand = alloca %"class.llvh::APInt", align 8
  %agg.tmp32 = alloca %"class.llvh::ArrayRef", align 8
  %trailingZeros = alloca i32, align 4
  %ref.tmp51 = alloca %"class.llvh::APInt", align 8
  %texp = alloca i32, align 4
  %precision59 = alloca i32, align 4
  %ref.tmp66 = alloca %"class.llvh::APInt", align 8
  %five_to_the_i = alloca %"class.llvh::APInt", align 8
  %buffer = alloca %"class.llvh::SmallVector", align 8
  %precision78 = alloca i32, align 4
  %ten = alloca %"class.llvh::APInt", align 8
  %digit = alloca %"class.llvh::APInt", align 8
  %inTrail = alloca i8, align 1
  %d = alloca i32, align 4
  %ref.tmp89 = alloca i8, align 1
  %NDigits = alloca i32, align 4
  %FormatScientific = alloca i8, align 1
  %MSD = alloca i32, align 4
  %ref.tmp124 = alloca i8, align 1
  %ref.tmp129 = alloca i8, align 1
  %I = alloca i32, align 4
  %ref.tmp146 = alloca i8, align 1
  %ref.tmp148 = alloca i8, align 1
  %ref.tmp150 = alloca i8, align 1
  %expbuf = alloca %"class.llvh::SmallVector.0", align 8
  %ref.tmp157 = alloca i8, align 1
  %ref.tmp167 = alloca i8, align 1
  %I169 = alloca i32, align 4
  %E = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  %I185 = alloca i32, align 4
  %I196 = alloca i32, align 4
  %ref.tmp200 = alloca i8, align 1
  %NWholeDigits = alloca i32, align 4
  %I206 = alloca i32, align 4
  %ref.tmp219 = alloca i8, align 1
  %NZeros = alloca i32, align 4
  %ref.tmp223 = alloca i8, align 1
  %ref.tmp224 = alloca i8, align 1
  %Z = alloca i32, align 4
  %ref.tmp228 = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  store ptr %Str, ptr %Str.addr, align 8
  store i32 %FormatPrecision, ptr %FormatPrecision.addr, align 4
  store i32 %FormatMaxPadding, ptr %FormatMaxPadding.addr, align 4
  %frombool = zext i1 %TruncateZero to i8
  store i8 %frombool, ptr %TruncateZero.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, 7
  %bf.cast = zext i8 %bf.clear to i32
  switch i32 %bf.cast, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb3
    i32 3, label %sw.bb5
    i32 2, label %sw.bb22
  ]

sw.bb:                                            ; preds = %entry
  %call = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %0 = load ptr, ptr %Str.addr, align 8
  store ptr %agg.tmp, ptr %this.addr.i, align 8
  store ptr @.str.5, ptr %Str.addr.i, align 8
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %1 = load ptr, ptr %Str.addr.i, align 8
  store ptr %1, ptr %this1.i, align 8
  %Length.i = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i, i32 0, i32 1
  %2 = load ptr, ptr %Str.addr.i, align 8
  %tobool.i = icmp ne ptr %2, null
  br i1 %tobool.i, label %cond.true.i, label %cond.false.i

cond.true.i:                                      ; preds = %if.then
  %3 = load ptr, ptr %Str.addr.i, align 8
  %call.i = call i64 @strlen(ptr noundef %3) #15
  br label %_ZN4llvh9StringRefC2EPKc.exit

cond.false.i:                                     ; preds = %if.then
  br label %_ZN4llvh9StringRefC2EPKc.exit

_ZN4llvh9StringRefC2EPKc.exit:                    ; preds = %cond.false.i, %cond.true.i
  %cond.i = phi i64 [ %call.i, %cond.true.i ], [ 0, %cond.false.i ]
  store i64 %cond.i, ptr %Length.i, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  call void @_ZN4llvh6detail12_GLOBAL__N_16appendERNS_15SmallVectorImplIcEENS_9StringRefE(ptr noundef nonnull align 8 dereferenceable(16) %0, ptr %5, i64 %7)
  br label %cleanup.cont

if.else:                                          ; preds = %sw.bb
  %8 = load ptr, ptr %Str.addr, align 8
  store ptr %agg.tmp2, ptr %this.addr.i246, align 8
  store ptr @.str.2, ptr %Str.addr.i247, align 8
  %this1.i248 = load ptr, ptr %this.addr.i246, align 8
  %9 = load ptr, ptr %Str.addr.i247, align 8
  store ptr %9, ptr %this1.i248, align 8
  %Length.i249 = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i248, i32 0, i32 1
  %10 = load ptr, ptr %Str.addr.i247, align 8
  %tobool.i250 = icmp ne ptr %10, null
  br i1 %tobool.i250, label %cond.true.i253, label %cond.false.i251

cond.true.i253:                                   ; preds = %if.else
  %11 = load ptr, ptr %Str.addr.i247, align 8
  %call.i254 = call i64 @strlen(ptr noundef %11) #15
  br label %_ZN4llvh9StringRefC2EPKc.exit255

cond.false.i251:                                  ; preds = %if.else
  br label %_ZN4llvh9StringRefC2EPKc.exit255

_ZN4llvh9StringRefC2EPKc.exit255:                 ; preds = %cond.false.i251, %cond.true.i253
  %cond.i252 = phi i64 [ %call.i254, %cond.true.i253 ], [ 0, %cond.false.i251 ]
  store i64 %cond.i252, ptr %Length.i249, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 1
  %15 = load i64, ptr %14, align 8
  call void @_ZN4llvh6detail12_GLOBAL__N_16appendERNS_15SmallVectorImplIcEENS_9StringRefE(ptr noundef nonnull align 8 dereferenceable(16) %8, ptr %13, i64 %15)
  br label %cleanup.cont

sw.bb3:                                           ; preds = %entry
  %16 = load ptr, ptr %Str.addr, align 8
  store ptr %agg.tmp4, ptr %this.addr.i256, align 8
  store ptr @.str.7, ptr %Str.addr.i257, align 8
  %this1.i258 = load ptr, ptr %this.addr.i256, align 8
  %17 = load ptr, ptr %Str.addr.i257, align 8
  store ptr %17, ptr %this1.i258, align 8
  %Length.i259 = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i258, i32 0, i32 1
  %18 = load ptr, ptr %Str.addr.i257, align 8
  %tobool.i260 = icmp ne ptr %18, null
  br i1 %tobool.i260, label %cond.true.i263, label %cond.false.i261

cond.true.i263:                                   ; preds = %sw.bb3
  %19 = load ptr, ptr %Str.addr.i257, align 8
  %call.i264 = call i64 @strlen(ptr noundef %19) #15
  br label %_ZN4llvh9StringRefC2EPKc.exit265

cond.false.i261:                                  ; preds = %sw.bb3
  br label %_ZN4llvh9StringRefC2EPKc.exit265

_ZN4llvh9StringRefC2EPKc.exit265:                 ; preds = %cond.false.i261, %cond.true.i263
  %cond.i262 = phi i64 [ %call.i264, %cond.true.i263 ], [ 0, %cond.false.i261 ]
  store i64 %cond.i262, ptr %Length.i259, align 8
  %20 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp4, i32 0, i32 0
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp4, i32 0, i32 1
  %23 = load i64, ptr %22, align 8
  call void @_ZN4llvh6detail12_GLOBAL__N_16appendERNS_15SmallVectorImplIcEENS_9StringRefE(ptr noundef nonnull align 8 dereferenceable(16) %16, ptr %21, i64 %23)
  br label %cleanup.cont

sw.bb5:                                           ; preds = %entry
  %call6 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call6, label %if.then7, label %if.end

if.then7:                                         ; preds = %sw.bb5
  %24 = load ptr, ptr %Str.addr, align 8
  store i8 45, ptr %ref.tmp, align 1
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE9push_backERKc(ptr noundef nonnull align 8 dereferenceable(16) %24, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp)
  br label %if.end

if.end:                                           ; preds = %if.then7, %sw.bb5
  %25 = load i32, ptr %FormatMaxPadding.addr, align 4
  %tobool = icmp ne i32 %25, 0
  br i1 %tobool, label %if.else19, label %if.then8

if.then8:                                         ; preds = %if.end
  %26 = load i8, ptr %TruncateZero.addr, align 1
  %tobool9 = trunc i8 %26 to i1
  br i1 %tobool9, label %if.then10, label %if.else12

if.then10:                                        ; preds = %if.then8
  %27 = load ptr, ptr %Str.addr, align 8
  store ptr %agg.tmp11, ptr %this.addr.i266, align 8
  store ptr @.str.10, ptr %Str.addr.i267, align 8
  %this1.i268 = load ptr, ptr %this.addr.i266, align 8
  %28 = load ptr, ptr %Str.addr.i267, align 8
  store ptr %28, ptr %this1.i268, align 8
  %Length.i269 = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i268, i32 0, i32 1
  %29 = load ptr, ptr %Str.addr.i267, align 8
  %tobool.i270 = icmp ne ptr %29, null
  br i1 %tobool.i270, label %cond.true.i273, label %cond.false.i271

cond.true.i273:                                   ; preds = %if.then10
  %30 = load ptr, ptr %Str.addr.i267, align 8
  %call.i274 = call i64 @strlen(ptr noundef %30) #15
  br label %_ZN4llvh9StringRefC2EPKc.exit275

cond.false.i271:                                  ; preds = %if.then10
  br label %_ZN4llvh9StringRefC2EPKc.exit275

_ZN4llvh9StringRefC2EPKc.exit275:                 ; preds = %cond.false.i271, %cond.true.i273
  %cond.i272 = phi i64 [ %call.i274, %cond.true.i273 ], [ 0, %cond.false.i271 ]
  store i64 %cond.i272, ptr %Length.i269, align 8
  %31 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp11, i32 0, i32 0
  %32 = load ptr, ptr %31, align 8
  %33 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp11, i32 0, i32 1
  %34 = load i64, ptr %33, align 8
  call void @_ZN4llvh6detail12_GLOBAL__N_16appendERNS_15SmallVectorImplIcEENS_9StringRefE(ptr noundef nonnull align 8 dereferenceable(16) %27, ptr %32, i64 %34)
  br label %if.end18

if.else12:                                        ; preds = %if.then8
  %35 = load ptr, ptr %Str.addr, align 8
  store ptr %agg.tmp13, ptr %this.addr.i276, align 8
  store ptr @.str.11, ptr %Str.addr.i277, align 8
  %this1.i278 = load ptr, ptr %this.addr.i276, align 8
  %36 = load ptr, ptr %Str.addr.i277, align 8
  store ptr %36, ptr %this1.i278, align 8
  %Length.i279 = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i278, i32 0, i32 1
  %37 = load ptr, ptr %Str.addr.i277, align 8
  %tobool.i280 = icmp ne ptr %37, null
  br i1 %tobool.i280, label %cond.true.i283, label %cond.false.i281

cond.true.i283:                                   ; preds = %if.else12
  %38 = load ptr, ptr %Str.addr.i277, align 8
  %call.i284 = call i64 @strlen(ptr noundef %38) #15
  br label %_ZN4llvh9StringRefC2EPKc.exit285

cond.false.i281:                                  ; preds = %if.else12
  br label %_ZN4llvh9StringRefC2EPKc.exit285

_ZN4llvh9StringRefC2EPKc.exit285:                 ; preds = %cond.false.i281, %cond.true.i283
  %cond.i282 = phi i64 [ %call.i284, %cond.true.i283 ], [ 0, %cond.false.i281 ]
  store i64 %cond.i282, ptr %Length.i279, align 8
  %39 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp13, i32 0, i32 0
  %40 = load ptr, ptr %39, align 8
  %41 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp13, i32 0, i32 1
  %42 = load i64, ptr %41, align 8
  call void @_ZN4llvh6detail12_GLOBAL__N_16appendERNS_15SmallVectorImplIcEENS_9StringRefE(ptr noundef nonnull align 8 dereferenceable(16) %35, ptr %40, i64 %42)
  %43 = load i32, ptr %FormatPrecision.addr, align 4
  %cmp = icmp ugt i32 %43, 1
  br i1 %cmp, label %if.then14, label %if.end16

if.then14:                                        ; preds = %_ZN4llvh9StringRefC2EPKc.exit285
  %44 = load ptr, ptr %Str.addr, align 8
  %45 = load i32, ptr %FormatPrecision.addr, align 4
  %sub = sub i32 %45, 1
  %conv = zext i32 %sub to i64
  store i8 48, ptr %ref.tmp15, align 1
  call void @_ZN4llvh15SmallVectorImplIcE6appendEmRKc(ptr noundef nonnull align 8 dereferenceable(16) %44, i64 noundef %conv, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp15)
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %_ZN4llvh9StringRefC2EPKc.exit285
  %46 = load ptr, ptr %Str.addr, align 8
  store ptr %agg.tmp17, ptr %this.addr.i286, align 8
  store ptr @.str.12, ptr %Str.addr.i287, align 8
  %this1.i288 = load ptr, ptr %this.addr.i286, align 8
  %47 = load ptr, ptr %Str.addr.i287, align 8
  store ptr %47, ptr %this1.i288, align 8
  %Length.i289 = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i288, i32 0, i32 1
  %48 = load ptr, ptr %Str.addr.i287, align 8
  %tobool.i290 = icmp ne ptr %48, null
  br i1 %tobool.i290, label %cond.true.i293, label %cond.false.i291

cond.true.i293:                                   ; preds = %if.end16
  %49 = load ptr, ptr %Str.addr.i287, align 8
  %call.i294 = call i64 @strlen(ptr noundef %49) #15
  br label %_ZN4llvh9StringRefC2EPKc.exit295

cond.false.i291:                                  ; preds = %if.end16
  br label %_ZN4llvh9StringRefC2EPKc.exit295

_ZN4llvh9StringRefC2EPKc.exit295:                 ; preds = %cond.false.i291, %cond.true.i293
  %cond.i292 = phi i64 [ %call.i294, %cond.true.i293 ], [ 0, %cond.false.i291 ]
  store i64 %cond.i292, ptr %Length.i289, align 8
  %50 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp17, i32 0, i32 0
  %51 = load ptr, ptr %50, align 8
  %52 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp17, i32 0, i32 1
  %53 = load i64, ptr %52, align 8
  call void @_ZN4llvh6detail12_GLOBAL__N_16appendERNS_15SmallVectorImplIcEENS_9StringRefE(ptr noundef nonnull align 8 dereferenceable(16) %46, ptr %51, i64 %53)
  br label %if.end18

if.end18:                                         ; preds = %_ZN4llvh9StringRefC2EPKc.exit295, %_ZN4llvh9StringRefC2EPKc.exit275
  br label %if.end21

if.else19:                                        ; preds = %if.end
  %54 = load ptr, ptr %Str.addr, align 8
  store i8 48, ptr %ref.tmp20, align 1
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE9push_backERKc(ptr noundef nonnull align 8 dereferenceable(16) %54, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp20)
  br label %if.end21

if.end21:                                         ; preds = %if.else19, %if.end18
  br label %cleanup.cont

sw.bb22:                                          ; preds = %entry
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb22, %entry
  %call23 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call23, label %if.then24, label %if.end26

if.then24:                                        ; preds = %sw.epilog
  %55 = load ptr, ptr %Str.addr, align 8
  store i8 45, ptr %ref.tmp25, align 1
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE9push_backERKc(ptr noundef nonnull align 8 dereferenceable(16) %55, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp25)
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %sw.epilog
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %56 = load i16, ptr %exponent, align 8
  %conv27 = sext i16 %56 to i32
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %57 = load ptr, ptr %semantics, align 8
  %precision = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %57, i32 0, i32 2
  %58 = load i32, ptr %precision, align 4
  %sub28 = sub nsw i32 %58, 1
  %sub29 = sub nsw i32 %conv27, %sub28
  store i32 %sub29, ptr %exp, align 4
  %semantics30 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %59 = load ptr, ptr %semantics30, align 8
  %precision31 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %59, i32 0, i32 2
  %60 = load i32, ptr %precision31, align 4
  %call33 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %semantics34 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %61 = load ptr, ptr %semantics34, align 8
  %precision35 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %61, i32 0, i32 2
  %62 = load i32, ptr %precision35, align 4
  %call36 = call noundef i32 @_ZN4llvhL16partCountForBitsEj(i32 noundef %62)
  %conv37 = zext i32 %call36 to i64
  %call38 = call { ptr, i64 } @_ZN4llvh12makeArrayRefImEENS_8ArrayRefIT_EEPKS2_m(ptr noundef %call33, i64 noundef %conv37)
  %63 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp32, i32 0, i32 0
  %64 = extractvalue { ptr, i64 } %call38, 0
  store ptr %64, ptr %63, align 8
  %65 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp32, i32 0, i32 1
  %66 = extractvalue { ptr, i64 } %call38, 1
  store i64 %66, ptr %65, align 8
  %67 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp32, i32 0, i32 0
  %68 = load ptr, ptr %67, align 8
  %69 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp32, i32 0, i32 1
  %70 = load i64, ptr %69, align 8
  call void @_ZN4llvh5APIntC1EjNS_8ArrayRefImEE(ptr noundef nonnull align 8 dereferenceable(12) %significand, i32 noundef %60, ptr %68, i64 %70)
  %71 = load i32, ptr %FormatPrecision.addr, align 4
  %tobool39 = icmp ne i32 %71, 0
  br i1 %tobool39, label %if.end43, label %if.then40

if.then40:                                        ; preds = %if.end26
  %semantics41 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %72 = load ptr, ptr %semantics41, align 8
  %precision42 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %72, i32 0, i32 2
  %73 = load i32, ptr %precision42, align 4
  %mul = mul i32 %73, 59
  %div = udiv i32 %mul, 196
  %add = add i32 2, %div
  store i32 %add, ptr %FormatPrecision.addr, align 4
  br label %if.end43

if.end43:                                         ; preds = %if.then40, %if.end26
  %call44 = call noundef i32 @_ZNK4llvh5APInt18countTrailingZerosEv(ptr noundef nonnull align 8 dereferenceable(12) %significand)
  store i32 %call44, ptr %trailingZeros, align 4
  %74 = load i32, ptr %trailingZeros, align 4
  %75 = load i32, ptr %exp, align 4
  %add45 = add nsw i32 %75, %74
  store i32 %add45, ptr %exp, align 4
  %76 = load i32, ptr %trailingZeros, align 4
  call void @_ZN4llvh5APInt11lshrInPlaceEj(ptr noundef nonnull align 8 dereferenceable(12) %significand, i32 noundef %76)
  %77 = load i32, ptr %exp, align 4
  %cmp46 = icmp eq i32 %77, 0
  br i1 %cmp46, label %if.then47, label %if.else48

if.then47:                                        ; preds = %if.end43
  br label %if.end77

if.else48:                                        ; preds = %if.end43
  %78 = load i32, ptr %exp, align 4
  %cmp49 = icmp sgt i32 %78, 0
  br i1 %cmp49, label %if.then50, label %if.else57

if.then50:                                        ; preds = %if.else48
  %semantics52 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %79 = load ptr, ptr %semantics52, align 8
  %precision53 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %79, i32 0, i32 2
  %80 = load i32, ptr %precision53, align 4
  %81 = load i32, ptr %exp, align 4
  %add54 = add i32 %80, %81
  call void @_ZNK4llvh5APInt4zextEj(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp51, ptr noundef nonnull align 8 dereferenceable(12) %significand, i32 noundef %add54)
  %call55 = call noundef nonnull align 8 dereferenceable(12) ptr @_ZN4llvh5APIntaSEOS0_(ptr noundef nonnull align 8 dereferenceable(12) %significand, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp51)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp51) #10
  %82 = load i32, ptr %exp, align 4
  %call56 = call noundef nonnull align 8 dereferenceable(12) ptr @_ZN4llvh5APIntlSEj(ptr noundef nonnull align 8 dereferenceable(12) %significand, i32 noundef %82)
  store i32 0, ptr %exp, align 4
  br label %if.end76

if.else57:                                        ; preds = %if.else48
  %83 = load i32, ptr %exp, align 4
  %sub58 = sub nsw i32 0, %83
  store i32 %sub58, ptr %texp, align 4
  %semantics60 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %84 = load ptr, ptr %semantics60, align 8
  %precision61 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %84, i32 0, i32 2
  %85 = load i32, ptr %precision61, align 4
  %86 = load i32, ptr %texp, align 4
  %mul62 = mul nsw i32 137, %86
  %add63 = add nsw i32 %mul62, 136
  %div64 = sdiv i32 %add63, 59
  %add65 = add i32 %85, %div64
  store i32 %add65, ptr %precision59, align 4
  %87 = load i32, ptr %precision59, align 4
  call void @_ZNK4llvh5APInt4zextEj(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp66, ptr noundef nonnull align 8 dereferenceable(12) %significand, i32 noundef %87)
  %call67 = call noundef nonnull align 8 dereferenceable(12) ptr @_ZN4llvh5APIntaSEOS0_(ptr noundef nonnull align 8 dereferenceable(12) %significand, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp66)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp66) #10
  %88 = load i32, ptr %precision59, align 4
  call void @_ZN4llvh5APIntC2Ejmb(ptr noundef nonnull align 8 dereferenceable(12) %five_to_the_i, i32 noundef %88, i64 noundef 5, i1 noundef zeroext false)
  br label %while.cond

while.cond:                                       ; preds = %if.end74, %if.else57
  br label %while.body

while.body:                                       ; preds = %while.cond
  %89 = load i32, ptr %texp, align 4
  %and = and i32 %89, 1
  %tobool68 = icmp ne i32 %and, 0
  br i1 %tobool68, label %if.then69, label %if.end71

if.then69:                                        ; preds = %while.body
  %call70 = call noundef nonnull align 8 dereferenceable(12) ptr @_ZN4llvh5APIntmLERKS0_(ptr noundef nonnull align 8 dereferenceable(12) %significand, ptr noundef nonnull align 8 dereferenceable(12) %five_to_the_i)
  br label %if.end71

if.end71:                                         ; preds = %if.then69, %while.body
  %90 = load i32, ptr %texp, align 4
  %shr = ashr i32 %90, 1
  store i32 %shr, ptr %texp, align 4
  %91 = load i32, ptr %texp, align 4
  %tobool72 = icmp ne i32 %91, 0
  br i1 %tobool72, label %if.end74, label %if.then73

if.then73:                                        ; preds = %if.end71
  br label %while.end

if.end74:                                         ; preds = %if.end71
  %call75 = call noundef nonnull align 8 dereferenceable(12) ptr @_ZN4llvh5APIntmLERKS0_(ptr noundef nonnull align 8 dereferenceable(12) %five_to_the_i, ptr noundef nonnull align 8 dereferenceable(12) %five_to_the_i)
  br label %while.cond, !llvm.loop !28

while.end:                                        ; preds = %if.then73
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %five_to_the_i) #10
  br label %if.end76

if.end76:                                         ; preds = %while.end, %if.then50
  br label %if.end77

if.end77:                                         ; preds = %if.end76, %if.then47
  %92 = load i32, ptr %FormatPrecision.addr, align 4
  call void @_ZN4llvh6detail12_GLOBAL__N_117AdjustToPrecisionERNS_5APIntERij(ptr noundef nonnull align 8 dereferenceable(12) %significand, ptr noundef nonnull align 4 dereferenceable(4) %exp, i32 noundef %92)
  call void @_ZN4llvh11SmallVectorIcLj256EEC2Ev(ptr noundef nonnull align 8 dereferenceable(272) %buffer)
  %call79 = call noundef i32 @_ZNK4llvh5APInt11getBitWidthEv(ptr noundef nonnull align 8 dereferenceable(12) %significand)
  store i32 %call79, ptr %precision78, align 4
  %93 = load i32, ptr %precision78, align 4
  call void @_ZN4llvh5APIntC2Ejmb(ptr noundef nonnull align 8 dereferenceable(12) %ten, i32 noundef %93, i64 noundef 10, i1 noundef zeroext false)
  %94 = load i32, ptr %precision78, align 4
  call void @_ZN4llvh5APIntC2Ejmb(ptr noundef nonnull align 8 dereferenceable(12) %digit, i32 noundef %94, i64 noundef 0, i1 noundef zeroext false)
  store i8 1, ptr %inTrail, align 1
  br label %while.cond80

while.cond80:                                     ; preds = %if.end92, %if.end77
  %call81 = call noundef zeroext i1 @_ZNK4llvh5APIntneEm(ptr noundef nonnull align 8 dereferenceable(12) %significand, i64 noundef 0)
  br i1 %call81, label %while.body82, label %while.end93

while.body82:                                     ; preds = %while.cond80
  call void @_ZN4llvh5APInt7udivremERKS0_S2_RS0_S3_(ptr noundef nonnull align 8 dereferenceable(12) %significand, ptr noundef nonnull align 8 dereferenceable(12) %ten, ptr noundef nonnull align 8 dereferenceable(12) %significand, ptr noundef nonnull align 8 dereferenceable(12) %digit)
  %call83 = call noundef i64 @_ZNK4llvh5APInt12getZExtValueEv(ptr noundef nonnull align 8 dereferenceable(12) %digit)
  %conv84 = trunc i64 %call83 to i32
  store i32 %conv84, ptr %d, align 4
  %95 = load i8, ptr %inTrail, align 1
  %tobool85 = trunc i8 %95 to i1
  br i1 %tobool85, label %land.lhs.true, label %if.else88

land.lhs.true:                                    ; preds = %while.body82
  %96 = load i32, ptr %d, align 4
  %tobool86 = icmp ne i32 %96, 0
  br i1 %tobool86, label %if.else88, label %if.then87

if.then87:                                        ; preds = %land.lhs.true
  %97 = load i32, ptr %exp, align 4
  %inc = add nsw i32 %97, 1
  store i32 %inc, ptr %exp, align 4
  br label %if.end92

if.else88:                                        ; preds = %land.lhs.true, %while.body82
  %98 = load i32, ptr %d, align 4
  %add90 = add i32 48, %98
  %conv91 = trunc i32 %add90 to i8
  store i8 %conv91, ptr %ref.tmp89, align 1
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE9push_backERKc(ptr noundef nonnull align 8 dereferenceable(16) %buffer, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp89)
  store i8 0, ptr %inTrail, align 1
  br label %if.end92

if.end92:                                         ; preds = %if.else88, %if.then87
  br label %while.cond80, !llvm.loop !29

while.end93:                                      ; preds = %while.cond80
  %99 = load i32, ptr %FormatPrecision.addr, align 4
  call void @_ZN4llvh6detail12_GLOBAL__N_117AdjustToPrecisionERNS_15SmallVectorImplIcEERij(ptr noundef nonnull align 8 dereferenceable(16) %buffer, ptr noundef nonnull align 4 dereferenceable(4) %exp, i32 noundef %99)
  %call94 = call noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %buffer)
  %conv95 = trunc i64 %call94 to i32
  store i32 %conv95, ptr %NDigits, align 4
  %100 = load i32, ptr %FormatMaxPadding.addr, align 4
  %tobool96 = icmp ne i32 %100, 0
  br i1 %tobool96, label %if.else98, label %if.then97

if.then97:                                        ; preds = %while.end93
  store i8 1, ptr %FormatScientific, align 1
  br label %if.end116

if.else98:                                        ; preds = %while.end93
  %101 = load i32, ptr %exp, align 4
  %cmp99 = icmp sge i32 %101, 0
  br i1 %cmp99, label %if.then100, label %if.else105

if.then100:                                       ; preds = %if.else98
  %102 = load i32, ptr %exp, align 4
  %103 = load i32, ptr %FormatMaxPadding.addr, align 4
  %cmp101 = icmp ugt i32 %102, %103
  br i1 %cmp101, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.then100
  %104 = load i32, ptr %NDigits, align 4
  %105 = load i32, ptr %exp, align 4
  %add102 = add i32 %104, %105
  %106 = load i32, ptr %FormatPrecision.addr, align 4
  %cmp103 = icmp ugt i32 %add102, %106
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.then100
  %107 = phi i1 [ true, %if.then100 ], [ %cmp103, %lor.rhs ]
  %frombool104 = zext i1 %107 to i8
  store i8 %frombool104, ptr %FormatScientific, align 1
  br label %if.end115

if.else105:                                       ; preds = %if.else98
  %108 = load i32, ptr %exp, align 4
  %109 = load i32, ptr %NDigits, align 4
  %sub106 = sub i32 %109, 1
  %add107 = add nsw i32 %108, %sub106
  store i32 %add107, ptr %MSD, align 4
  %110 = load i32, ptr %MSD, align 4
  %cmp108 = icmp sge i32 %110, 0
  br i1 %cmp108, label %if.then109, label %if.else110

if.then109:                                       ; preds = %if.else105
  store i8 0, ptr %FormatScientific, align 1
  br label %if.end114

if.else110:                                       ; preds = %if.else105
  %111 = load i32, ptr %MSD, align 4
  %sub111 = sub nsw i32 0, %111
  %112 = load i32, ptr %FormatMaxPadding.addr, align 4
  %cmp112 = icmp ugt i32 %sub111, %112
  %frombool113 = zext i1 %cmp112 to i8
  store i8 %frombool113, ptr %FormatScientific, align 1
  br label %if.end114

if.end114:                                        ; preds = %if.else110, %if.then109
  br label %if.end115

if.end115:                                        ; preds = %if.end114, %lor.end
  br label %if.end116

if.end116:                                        ; preds = %if.end115, %if.then97
  %113 = load i8, ptr %FormatScientific, align 1
  %tobool117 = trunc i8 %113 to i1
  br i1 %tobool117, label %if.then118, label %if.end182

if.then118:                                       ; preds = %if.end116
  %114 = load i32, ptr %NDigits, align 4
  %sub119 = sub i32 %114, 1
  %115 = load i32, ptr %exp, align 4
  %add120 = add i32 %115, %sub119
  store i32 %add120, ptr %exp, align 4
  %116 = load ptr, ptr %Str.addr, align 8
  %117 = load i32, ptr %NDigits, align 4
  %sub121 = sub i32 %117, 1
  %conv122 = zext i32 %sub121 to i64
  store ptr %buffer, ptr %this.addr.i319, align 8
  store i64 %conv122, ptr %idx.addr.i320, align 8
  %this1.i321 = load ptr, ptr %this.addr.i319, align 8
  store ptr %this1.i321, ptr %this.addr.i324, align 8
  %this1.i325 = load ptr, ptr %this.addr.i324, align 8
  %118 = load ptr, ptr %this1.i325, align 8
  %119 = load i64, ptr %idx.addr.i320, align 8
  %arrayidx.i323 = getelementptr inbounds i8, ptr %118, i64 %119
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE9push_backERKc(ptr noundef nonnull align 8 dereferenceable(16) %116, ptr noundef nonnull align 1 dereferenceable(1) %arrayidx.i323)
  %120 = load ptr, ptr %Str.addr, align 8
  store i8 46, ptr %ref.tmp124, align 1
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE9push_backERKc(ptr noundef nonnull align 8 dereferenceable(16) %120, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp124)
  %121 = load i32, ptr %NDigits, align 4
  %cmp125 = icmp eq i32 %121, 1
  br i1 %cmp125, label %land.lhs.true126, label %if.else130

land.lhs.true126:                                 ; preds = %if.then118
  %122 = load i8, ptr %TruncateZero.addr, align 1
  %tobool127 = trunc i8 %122 to i1
  br i1 %tobool127, label %if.then128, label %if.else130

if.then128:                                       ; preds = %land.lhs.true126
  %123 = load ptr, ptr %Str.addr, align 8
  store i8 48, ptr %ref.tmp129, align 1
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE9push_backERKc(ptr noundef nonnull align 8 dereferenceable(16) %123, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp129)
  br label %if.end137

if.else130:                                       ; preds = %land.lhs.true126, %if.then118
  store i32 1, ptr %I, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else130
  %124 = load i32, ptr %I, align 4
  %125 = load i32, ptr %NDigits, align 4
  %cmp131 = icmp ne i32 %124, %125
  br i1 %cmp131, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %126 = load ptr, ptr %Str.addr, align 8
  %127 = load i32, ptr %NDigits, align 4
  %sub132 = sub i32 %127, 1
  %128 = load i32, ptr %I, align 4
  %sub133 = sub i32 %sub132, %128
  %conv134 = zext i32 %sub133 to i64
  store ptr %buffer, ptr %this.addr.i314, align 8
  store i64 %conv134, ptr %idx.addr.i315, align 8
  %this1.i316 = load ptr, ptr %this.addr.i314, align 8
  store ptr %this1.i316, ptr %this.addr.i326, align 8
  %this1.i327 = load ptr, ptr %this.addr.i326, align 8
  %129 = load ptr, ptr %this1.i327, align 8
  %130 = load i64, ptr %idx.addr.i315, align 8
  %arrayidx.i318 = getelementptr inbounds i8, ptr %129, i64 %130
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE9push_backERKc(ptr noundef nonnull align 8 dereferenceable(16) %126, ptr noundef nonnull align 1 dereferenceable(1) %arrayidx.i318)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %131 = load i32, ptr %I, align 4
  %inc136 = add i32 %131, 1
  store i32 %inc136, ptr %I, align 4
  br label %for.cond, !llvm.loop !30

for.end:                                          ; preds = %for.cond
  br label %if.end137

if.end137:                                        ; preds = %for.end, %if.then128
  %132 = load i8, ptr %TruncateZero.addr, align 1
  %tobool138 = trunc i8 %132 to i1
  br i1 %tobool138, label %if.end147, label %land.lhs.true139

land.lhs.true139:                                 ; preds = %if.end137
  %133 = load i32, ptr %FormatPrecision.addr, align 4
  %134 = load i32, ptr %NDigits, align 4
  %sub140 = sub i32 %134, 1
  %cmp141 = icmp ugt i32 %133, %sub140
  br i1 %cmp141, label %if.then142, label %if.end147

if.then142:                                       ; preds = %land.lhs.true139
  %135 = load ptr, ptr %Str.addr, align 8
  %136 = load i32, ptr %FormatPrecision.addr, align 4
  %137 = load i32, ptr %NDigits, align 4
  %sub143 = sub i32 %136, %137
  %add144 = add i32 %sub143, 1
  %conv145 = zext i32 %add144 to i64
  store i8 48, ptr %ref.tmp146, align 1
  call void @_ZN4llvh15SmallVectorImplIcE6appendEmRKc(ptr noundef nonnull align 8 dereferenceable(16) %135, i64 noundef %conv145, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp146)
  br label %if.end147

if.end147:                                        ; preds = %if.then142, %land.lhs.true139, %if.end137
  %138 = load ptr, ptr %Str.addr, align 8
  %139 = load i8, ptr %TruncateZero.addr, align 1
  %tobool149 = trunc i8 %139 to i1
  %cond = select i1 %tobool149, i8 69, i8 101
  store i8 %cond, ptr %ref.tmp148, align 1
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE9push_backERKc(ptr noundef nonnull align 8 dereferenceable(16) %138, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp148)
  %140 = load ptr, ptr %Str.addr, align 8
  %141 = load i32, ptr %exp, align 4
  %cmp151 = icmp sge i32 %141, 0
  %cond152 = select i1 %cmp151, i8 43, i8 45
  store i8 %cond152, ptr %ref.tmp150, align 1
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE9push_backERKc(ptr noundef nonnull align 8 dereferenceable(16) %140, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp150)
  %142 = load i32, ptr %exp, align 4
  %cmp153 = icmp slt i32 %142, 0
  br i1 %cmp153, label %if.then154, label %if.end156

if.then154:                                       ; preds = %if.end147
  %143 = load i32, ptr %exp, align 4
  %sub155 = sub nsw i32 0, %143
  store i32 %sub155, ptr %exp, align 4
  br label %if.end156

if.end156:                                        ; preds = %if.then154, %if.end147
  call void @_ZN4llvh11SmallVectorIcLj6EEC2Ev(ptr noundef nonnull align 8 dereferenceable(22) %expbuf)
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.end156
  %144 = load i32, ptr %exp, align 4
  %rem = srem i32 %144, 10
  %add158 = add nsw i32 48, %rem
  %conv159 = trunc i32 %add158 to i8
  store i8 %conv159, ptr %ref.tmp157, align 1
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE9push_backERKc(ptr noundef nonnull align 8 dereferenceable(16) %expbuf, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp157)
  %145 = load i32, ptr %exp, align 4
  %div160 = sdiv i32 %145, 10
  store i32 %div160, ptr %exp, align 4
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %146 = load i32, ptr %exp, align 4
  %tobool161 = icmp ne i32 %146, 0
  br i1 %tobool161, label %do.body, label %do.end, !llvm.loop !31

do.end:                                           ; preds = %do.cond
  %147 = load i8, ptr %TruncateZero.addr, align 1
  %tobool162 = trunc i8 %147 to i1
  br i1 %tobool162, label %if.end168, label %land.lhs.true163

land.lhs.true163:                                 ; preds = %do.end
  %call164 = call noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %expbuf)
  %cmp165 = icmp ult i64 %call164, 2
  br i1 %cmp165, label %if.then166, label %if.end168

if.then166:                                       ; preds = %land.lhs.true163
  store i8 48, ptr %ref.tmp167, align 1
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE9push_backERKc(ptr noundef nonnull align 8 dereferenceable(16) %expbuf, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp167)
  br label %if.end168

if.end168:                                        ; preds = %if.then166, %land.lhs.true163, %do.end
  store i32 0, ptr %I169, align 4
  %call170 = call noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %expbuf)
  %conv171 = trunc i64 %call170 to i32
  store i32 %conv171, ptr %E, align 4
  br label %for.cond172

for.cond172:                                      ; preds = %for.inc179, %if.end168
  %148 = load i32, ptr %I169, align 4
  %149 = load i32, ptr %E, align 4
  %cmp173 = icmp ne i32 %148, %149
  br i1 %cmp173, label %for.body174, label %for.end181

for.body174:                                      ; preds = %for.cond172
  %150 = load ptr, ptr %Str.addr, align 8
  %151 = load i32, ptr %E, align 4
  %sub175 = sub i32 %151, 1
  %152 = load i32, ptr %I169, align 4
  %sub176 = sub i32 %sub175, %152
  %conv177 = zext i32 %sub176 to i64
  store ptr %expbuf, ptr %this.addr.i309, align 8
  store i64 %conv177, ptr %idx.addr.i310, align 8
  %this1.i311 = load ptr, ptr %this.addr.i309, align 8
  store ptr %this1.i311, ptr %this.addr.i328, align 8
  %this1.i329 = load ptr, ptr %this.addr.i328, align 8
  %153 = load ptr, ptr %this1.i329, align 8
  %154 = load i64, ptr %idx.addr.i310, align 8
  %arrayidx.i313 = getelementptr inbounds i8, ptr %153, i64 %154
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE9push_backERKc(ptr noundef nonnull align 8 dereferenceable(16) %150, ptr noundef nonnull align 1 dereferenceable(1) %arrayidx.i313)
  br label %for.inc179

for.inc179:                                       ; preds = %for.body174
  %155 = load i32, ptr %I169, align 4
  %inc180 = add i32 %155, 1
  store i32 %inc180, ptr %I169, align 4
  br label %for.cond172, !llvm.loop !32

for.end181:                                       ; preds = %for.cond172
  store i32 1, ptr %cleanup.dest.slot, align 4
  call void @_ZN4llvh11SmallVectorIcLj6EED2Ev(ptr noundef nonnull align 8 dereferenceable(22) %expbuf) #10
  br label %cleanup

if.end182:                                        ; preds = %if.end116
  %156 = load i32, ptr %exp, align 4
  %cmp183 = icmp sge i32 %156, 0
  br i1 %cmp183, label %if.then184, label %if.end204

if.then184:                                       ; preds = %if.end182
  store i32 0, ptr %I185, align 4
  br label %for.cond186

for.cond186:                                      ; preds = %for.inc193, %if.then184
  %157 = load i32, ptr %I185, align 4
  %158 = load i32, ptr %NDigits, align 4
  %cmp187 = icmp ne i32 %157, %158
  br i1 %cmp187, label %for.body188, label %for.end195

for.body188:                                      ; preds = %for.cond186
  %159 = load ptr, ptr %Str.addr, align 8
  %160 = load i32, ptr %NDigits, align 4
  %sub189 = sub i32 %160, 1
  %161 = load i32, ptr %I185, align 4
  %sub190 = sub i32 %sub189, %161
  %conv191 = zext i32 %sub190 to i64
  store ptr %buffer, ptr %this.addr.i304, align 8
  store i64 %conv191, ptr %idx.addr.i305, align 8
  %this1.i306 = load ptr, ptr %this.addr.i304, align 8
  store ptr %this1.i306, ptr %this.addr.i330, align 8
  %this1.i331 = load ptr, ptr %this.addr.i330, align 8
  %162 = load ptr, ptr %this1.i331, align 8
  %163 = load i64, ptr %idx.addr.i305, align 8
  %arrayidx.i308 = getelementptr inbounds i8, ptr %162, i64 %163
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE9push_backERKc(ptr noundef nonnull align 8 dereferenceable(16) %159, ptr noundef nonnull align 1 dereferenceable(1) %arrayidx.i308)
  br label %for.inc193

for.inc193:                                       ; preds = %for.body188
  %164 = load i32, ptr %I185, align 4
  %inc194 = add i32 %164, 1
  store i32 %inc194, ptr %I185, align 4
  br label %for.cond186, !llvm.loop !33

for.end195:                                       ; preds = %for.cond186
  store i32 0, ptr %I196, align 4
  br label %for.cond197

for.cond197:                                      ; preds = %for.inc201, %for.end195
  %165 = load i32, ptr %I196, align 4
  %166 = load i32, ptr %exp, align 4
  %cmp198 = icmp ne i32 %165, %166
  br i1 %cmp198, label %for.body199, label %for.end203

for.body199:                                      ; preds = %for.cond197
  %167 = load ptr, ptr %Str.addr, align 8
  store i8 48, ptr %ref.tmp200, align 1
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE9push_backERKc(ptr noundef nonnull align 8 dereferenceable(16) %167, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp200)
  br label %for.inc201

for.inc201:                                       ; preds = %for.body199
  %168 = load i32, ptr %I196, align 4
  %inc202 = add i32 %168, 1
  store i32 %inc202, ptr %I196, align 4
  br label %for.cond197, !llvm.loop !34

for.end203:                                       ; preds = %for.cond197
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end204:                                        ; preds = %if.end182
  %169 = load i32, ptr %exp, align 4
  %170 = load i32, ptr %NDigits, align 4
  %add205 = add nsw i32 %169, %170
  store i32 %add205, ptr %NWholeDigits, align 4
  store i32 0, ptr %I206, align 4
  %171 = load i32, ptr %NWholeDigits, align 4
  %cmp207 = icmp sgt i32 %171, 0
  br i1 %cmp207, label %if.then208, label %if.else220

if.then208:                                       ; preds = %if.end204
  br label %for.cond209

for.cond209:                                      ; preds = %for.inc216, %if.then208
  %172 = load i32, ptr %I206, align 4
  %173 = load i32, ptr %NWholeDigits, align 4
  %cmp210 = icmp ne i32 %172, %173
  br i1 %cmp210, label %for.body211, label %for.end218

for.body211:                                      ; preds = %for.cond209
  %174 = load ptr, ptr %Str.addr, align 8
  %175 = load i32, ptr %NDigits, align 4
  %176 = load i32, ptr %I206, align 4
  %sub212 = sub i32 %175, %176
  %sub213 = sub i32 %sub212, 1
  %conv214 = zext i32 %sub213 to i64
  store ptr %buffer, ptr %this.addr.i299, align 8
  store i64 %conv214, ptr %idx.addr.i300, align 8
  %this1.i301 = load ptr, ptr %this.addr.i299, align 8
  store ptr %this1.i301, ptr %this.addr.i332, align 8
  %this1.i333 = load ptr, ptr %this.addr.i332, align 8
  %177 = load ptr, ptr %this1.i333, align 8
  %178 = load i64, ptr %idx.addr.i300, align 8
  %arrayidx.i303 = getelementptr inbounds i8, ptr %177, i64 %178
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE9push_backERKc(ptr noundef nonnull align 8 dereferenceable(16) %174, ptr noundef nonnull align 1 dereferenceable(1) %arrayidx.i303)
  br label %for.inc216

for.inc216:                                       ; preds = %for.body211
  %179 = load i32, ptr %I206, align 4
  %inc217 = add i32 %179, 1
  store i32 %inc217, ptr %I206, align 4
  br label %for.cond209, !llvm.loop !35

for.end218:                                       ; preds = %for.cond209
  %180 = load ptr, ptr %Str.addr, align 8
  store i8 46, ptr %ref.tmp219, align 1
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE9push_backERKc(ptr noundef nonnull align 8 dereferenceable(16) %180, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp219)
  br label %if.end232

if.else220:                                       ; preds = %if.end204
  %181 = load i32, ptr %NWholeDigits, align 4
  %sub221 = sub nsw i32 0, %181
  %add222 = add i32 1, %sub221
  store i32 %add222, ptr %NZeros, align 4
  %182 = load ptr, ptr %Str.addr, align 8
  store i8 48, ptr %ref.tmp223, align 1
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE9push_backERKc(ptr noundef nonnull align 8 dereferenceable(16) %182, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp223)
  %183 = load ptr, ptr %Str.addr, align 8
  store i8 46, ptr %ref.tmp224, align 1
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE9push_backERKc(ptr noundef nonnull align 8 dereferenceable(16) %183, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp224)
  store i32 1, ptr %Z, align 4
  br label %for.cond225

for.cond225:                                      ; preds = %for.inc229, %if.else220
  %184 = load i32, ptr %Z, align 4
  %185 = load i32, ptr %NZeros, align 4
  %cmp226 = icmp ne i32 %184, %185
  br i1 %cmp226, label %for.body227, label %for.end231

for.body227:                                      ; preds = %for.cond225
  %186 = load ptr, ptr %Str.addr, align 8
  store i8 48, ptr %ref.tmp228, align 1
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE9push_backERKc(ptr noundef nonnull align 8 dereferenceable(16) %186, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp228)
  br label %for.inc229

for.inc229:                                       ; preds = %for.body227
  %187 = load i32, ptr %Z, align 4
  %inc230 = add i32 %187, 1
  store i32 %inc230, ptr %Z, align 4
  br label %for.cond225, !llvm.loop !36

for.end231:                                       ; preds = %for.cond225
  br label %if.end232

if.end232:                                        ; preds = %for.end231, %for.end218
  br label %for.cond233

for.cond233:                                      ; preds = %for.inc240, %if.end232
  %188 = load i32, ptr %I206, align 4
  %189 = load i32, ptr %NDigits, align 4
  %cmp234 = icmp ne i32 %188, %189
  br i1 %cmp234, label %for.body235, label %for.end242

for.body235:                                      ; preds = %for.cond233
  %190 = load ptr, ptr %Str.addr, align 8
  %191 = load i32, ptr %NDigits, align 4
  %192 = load i32, ptr %I206, align 4
  %sub236 = sub i32 %191, %192
  %sub237 = sub i32 %sub236, 1
  %conv238 = zext i32 %sub237 to i64
  store ptr %buffer, ptr %this.addr.i296, align 8
  store i64 %conv238, ptr %idx.addr.i, align 8
  %this1.i297 = load ptr, ptr %this.addr.i296, align 8
  store ptr %this1.i297, ptr %this.addr.i334, align 8
  %this1.i335 = load ptr, ptr %this.addr.i334, align 8
  %193 = load ptr, ptr %this1.i335, align 8
  %194 = load i64, ptr %idx.addr.i, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %193, i64 %194
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE9push_backERKc(ptr noundef nonnull align 8 dereferenceable(16) %190, ptr noundef nonnull align 1 dereferenceable(1) %arrayidx.i)
  br label %for.inc240

for.inc240:                                       ; preds = %for.body235
  %195 = load i32, ptr %I206, align 4
  %inc241 = add i32 %195, 1
  store i32 %inc241, ptr %I206, align 4
  br label %for.cond233, !llvm.loop !37

for.end242:                                       ; preds = %for.cond233
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %for.end242, %for.end203, %for.end181
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %digit) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ten) #10
  call void @_ZN4llvh11SmallVectorIcLj256EED2Ev(ptr noundef nonnull align 8 dereferenceable(272) %buffer) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %significand) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup, %cleanup, %if.end21, %_ZN4llvh9StringRefC2EPKc.exit265, %_ZN4llvh9StringRefC2EPKc.exit255, %_ZN4llvh9StringRefC2EPKc.exit
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZN4llvh6detail12_GLOBAL__N_16appendERNS_15SmallVectorImplIcEENS_9StringRefE(ptr noundef nonnull align 8 dereferenceable(16) %Buffer, ptr %Str.coerce0, i64 %Str.coerce1) #1 {
entry:
  %Str = alloca %"class.llvh::StringRef", align 8
  %Buffer.addr = alloca ptr, align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %Str, i32 0, i32 0
  store ptr %Str.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %Str, i32 0, i32 1
  store i64 %Str.coerce1, ptr %1, align 8
  store ptr %Buffer, ptr %Buffer.addr, align 8
  %2 = load ptr, ptr %Buffer.addr, align 8
  %call = call noundef ptr @_ZNK4llvh9StringRef5beginEv(ptr noundef nonnull align 8 dereferenceable(16) %Str)
  %call1 = call noundef ptr @_ZNK4llvh9StringRef3endEv(ptr noundef nonnull align 8 dereferenceable(16) %Str)
  call void @_ZN4llvh15SmallVectorImplIcE6appendIPKcvEEvT_S5_(ptr noundef nonnull align 8 dereferenceable(16) %2, ptr noundef %call, ptr noundef %call1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE9push_backERKc(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 1 dereferenceable(1) %Elt) #1 comdat align 2 {
entry:
  %this.addr.i5 = alloca ptr, align 8
  %this.addr.i = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %Elt.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %Elt, ptr %Elt.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %call2 = call noundef i64 @_ZNK4llvh15SmallVectorBase8capacityEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %cmp = icmp uge i64 %call, %call2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE4growEm(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef 0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  store ptr %this1, ptr %this.addr.i, align 8
  %this1.i = load ptr, ptr %this.addr.i, align 8
  store ptr %this1.i, ptr %this.addr.i5, align 8
  %this1.i6 = load ptr, ptr %this.addr.i5, align 8
  %0 = load ptr, ptr %this1.i6, align 8
  %call2.i = call noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %this1.i)
  %add.ptr.i = getelementptr inbounds i8, ptr %0, i64 %call2.i
  %1 = load ptr, ptr %Elt.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %add.ptr.i, ptr align 1 %1, i64 1, i1 false)
  %call4 = call noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %add = add i64 %call4, 1
  call void @_ZN4llvh15SmallVectorBase8set_sizeEm(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %add)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh15SmallVectorImplIcE6appendEmRKc(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %NumInputs, ptr noundef nonnull align 1 dereferenceable(1) %Elt) #1 comdat align 2 {
entry:
  %this.addr.i8 = alloca ptr, align 8
  %this.addr.i = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %NumInputs.addr = alloca i64, align 8
  %Elt.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %NumInputs, ptr %NumInputs.addr, align 8
  store ptr %Elt, ptr %Elt.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %NumInputs.addr, align 8
  %call = call noundef i64 @_ZNK4llvh15SmallVectorBase8capacityEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %call2 = call noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %sub = sub i64 %call, %call2
  %cmp = icmp ugt i64 %0, %sub
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call3 = call noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %1 = load i64, ptr %NumInputs.addr, align 8
  %add = add i64 %call3, %1
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE4growEm(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %add)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  store ptr %this1, ptr %this.addr.i, align 8
  %this1.i = load ptr, ptr %this.addr.i, align 8
  store ptr %this1.i, ptr %this.addr.i8, align 8
  %this1.i9 = load ptr, ptr %this.addr.i8, align 8
  %2 = load ptr, ptr %this1.i9, align 8
  %call2.i = call noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %this1.i)
  %add.ptr.i = getelementptr inbounds i8, ptr %2, i64 %call2.i
  %3 = load i64, ptr %NumInputs.addr, align 8
  %4 = load ptr, ptr %Elt.addr, align 8
  %call5 = call noundef ptr @_ZSt20uninitialized_fill_nIPcmcET_S1_T0_RKT1_(ptr noundef %add.ptr.i, i64 noundef %3, ptr noundef nonnull align 1 dereferenceable(1) %4)
  %call6 = call noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %5 = load i64, ptr %NumInputs.addr, align 8
  %add7 = add i64 %call6, %5
  call void @_ZN4llvh15SmallVectorBase8set_sizeEm(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %add7)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZNK4llvh5APInt18countTrailingZerosEv(ptr noundef nonnull align 8 dereferenceable(12) %this) #1 comdat align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh5APInt12isSingleWordEv(ptr noundef nonnull align 8 dereferenceable(12) %this1)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %U = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 0
  %0 = load i64, ptr %U, align 8
  %call2 = call noundef i64 @_ZN4llvh18countTrailingZerosImEEmT_NS_12ZeroBehaviorE(i64 noundef %0, i32 noundef 2)
  %conv = trunc i64 %call2 to i32
  store i32 %conv, ptr %ref.tmp, align 4
  %BitWidth = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 1
  %call3 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZSt3minIjERKT_S2_S2_(ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(4) %BitWidth)
  %1 = load i32, ptr %call3, align 4
  store i32 %1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %call4 = call noundef i32 @_ZNK4llvh5APInt26countTrailingZerosSlowCaseEv(ptr noundef nonnull align 8 dereferenceable(12) %this1) #15
  store i32 %call4, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh5APInt11lshrInPlaceEj(ptr noundef nonnull align 8 dereferenceable(12) %this, i32 noundef %ShiftAmt) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ShiftAmt.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %ShiftAmt, ptr %ShiftAmt.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh5APInt12isSingleWordEv(ptr noundef nonnull align 8 dereferenceable(12) %this1)
  br i1 %call, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %0 = load i32, ptr %ShiftAmt.addr, align 4
  %BitWidth = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %BitWidth, align 8
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %U = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 0
  store i64 0, ptr %U, align 8
  br label %if.end

if.else:                                          ; preds = %if.then
  %2 = load i32, ptr %ShiftAmt.addr, align 4
  %U3 = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 0
  %3 = load i64, ptr %U3, align 8
  %sh_prom = zext i32 %2 to i64
  %shr = lshr i64 %3, %sh_prom
  store i64 %shr, ptr %U3, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then2
  br label %return

if.end4:                                          ; preds = %entry
  %4 = load i32, ptr %ShiftAmt.addr, align 4
  call void @_ZN4llvh5APInt12lshrSlowCaseEj(ptr noundef nonnull align 8 dereferenceable(12) %this1, i32 noundef %4)
  br label %return

return:                                           ; preds = %if.end4, %if.end
  ret void
}

declare void @_ZNK4llvh5APInt4zextEj(ptr sret(%"class.llvh::APInt") align 8, ptr noundef nonnull align 8 dereferenceable(12), i32 noundef) #5

declare noundef nonnull align 8 dereferenceable(12) ptr @_ZN4llvh5APIntmLERKS0_(ptr noundef nonnull align 8 dereferenceable(12), ptr noundef nonnull align 8 dereferenceable(12)) #5

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZN4llvh6detail12_GLOBAL__N_117AdjustToPrecisionERNS_5APIntERij(ptr noundef nonnull align 8 dereferenceable(12) %significand, ptr noundef nonnull align 4 dereferenceable(4) %exp, i32 noundef %FormatPrecision) #1 {
entry:
  %significand.addr = alloca ptr, align 8
  %exp.addr = alloca ptr, align 8
  %FormatPrecision.addr = alloca i32, align 4
  %bits = alloca i32, align 4
  %bitsRequired = alloca i32, align 4
  %tensRemovable = alloca i32, align 4
  %divisor = alloca %"class.llvh::APInt", align 8
  %powten = alloca %"class.llvh::APInt", align 8
  %ref.tmp = alloca %"class.llvh::APInt", align 8
  %ref.tmp17 = alloca %"class.llvh::APInt", align 8
  store ptr %significand, ptr %significand.addr, align 8
  store ptr %exp, ptr %exp.addr, align 8
  store i32 %FormatPrecision, ptr %FormatPrecision.addr, align 4
  %0 = load ptr, ptr %significand.addr, align 8
  %call = call noundef i32 @_ZNK4llvh5APInt13getActiveBitsEv(ptr noundef nonnull align 8 dereferenceable(12) %0)
  store i32 %call, ptr %bits, align 4
  %1 = load i32, ptr %FormatPrecision.addr, align 4
  %mul = mul i32 %1, 196
  %add = add i32 %mul, 58
  %div = udiv i32 %add, 59
  store i32 %div, ptr %bitsRequired, align 4
  %2 = load i32, ptr %bits, align 4
  %3 = load i32, ptr %bitsRequired, align 4
  %cmp = icmp ule i32 %2, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %4 = load i32, ptr %bits, align 4
  %5 = load i32, ptr %bitsRequired, align 4
  %sub = sub i32 %4, %5
  %mul1 = mul i32 %sub, 59
  %div2 = udiv i32 %mul1, 196
  store i32 %div2, ptr %tensRemovable, align 4
  %6 = load i32, ptr %tensRemovable, align 4
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  br label %return

if.end4:                                          ; preds = %if.end
  %7 = load i32, ptr %tensRemovable, align 4
  %8 = load ptr, ptr %exp.addr, align 8
  %9 = load i32, ptr %8, align 4
  %add5 = add i32 %9, %7
  store i32 %add5, ptr %8, align 4
  %10 = load ptr, ptr %significand.addr, align 8
  %call6 = call noundef i32 @_ZNK4llvh5APInt11getBitWidthEv(ptr noundef nonnull align 8 dereferenceable(12) %10)
  call void @_ZN4llvh5APIntC2Ejmb(ptr noundef nonnull align 8 dereferenceable(12) %divisor, i32 noundef %call6, i64 noundef 1, i1 noundef zeroext false)
  %11 = load ptr, ptr %significand.addr, align 8
  %call7 = call noundef i32 @_ZNK4llvh5APInt11getBitWidthEv(ptr noundef nonnull align 8 dereferenceable(12) %11)
  call void @_ZN4llvh5APIntC2Ejmb(ptr noundef nonnull align 8 dereferenceable(12) %powten, i32 noundef %call7, i64 noundef 10, i1 noundef zeroext false)
  br label %while.cond

while.cond:                                       ; preds = %if.end14, %if.end4
  br label %while.body

while.body:                                       ; preds = %while.cond
  %12 = load i32, ptr %tensRemovable, align 4
  %and = and i32 %12, 1
  %tobool8 = icmp ne i32 %and, 0
  br i1 %tobool8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %while.body
  %call10 = call noundef nonnull align 8 dereferenceable(12) ptr @_ZN4llvh5APIntmLERKS0_(ptr noundef nonnull align 8 dereferenceable(12) %divisor, ptr noundef nonnull align 8 dereferenceable(12) %powten)
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %while.body
  %13 = load i32, ptr %tensRemovable, align 4
  %shr = lshr i32 %13, 1
  store i32 %shr, ptr %tensRemovable, align 4
  %14 = load i32, ptr %tensRemovable, align 4
  %tobool12 = icmp ne i32 %14, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end11
  br label %while.end

if.end14:                                         ; preds = %if.end11
  %call15 = call noundef nonnull align 8 dereferenceable(12) ptr @_ZN4llvh5APIntmLERKS0_(ptr noundef nonnull align 8 dereferenceable(12) %powten, ptr noundef nonnull align 8 dereferenceable(12) %powten)
  br label %while.cond, !llvm.loop !38

while.end:                                        ; preds = %if.then13
  %15 = load ptr, ptr %significand.addr, align 8
  call void @_ZNK4llvh5APInt4udivERKS0_(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp, ptr noundef nonnull align 8 dereferenceable(12) %15, ptr noundef nonnull align 8 dereferenceable(12) %divisor)
  %16 = load ptr, ptr %significand.addr, align 8
  %call16 = call noundef nonnull align 8 dereferenceable(12) ptr @_ZN4llvh5APIntaSEOS0_(ptr noundef nonnull align 8 dereferenceable(12) %16, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp) #10
  %17 = load ptr, ptr %significand.addr, align 8
  %18 = load ptr, ptr %significand.addr, align 8
  %call18 = call noundef i32 @_ZNK4llvh5APInt13getActiveBitsEv(ptr noundef nonnull align 8 dereferenceable(12) %18)
  call void @_ZNK4llvh5APInt5truncEj(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp17, ptr noundef nonnull align 8 dereferenceable(12) %17, i32 noundef %call18)
  %19 = load ptr, ptr %significand.addr, align 8
  %call19 = call noundef nonnull align 8 dereferenceable(12) ptr @_ZN4llvh5APIntaSEOS0_(ptr noundef nonnull align 8 dereferenceable(12) %19, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp17)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp17) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %powten) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %divisor) #10
  br label %return

return:                                           ; preds = %while.end, %if.then3, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh11SmallVectorIcLj256EEC2Ev(ptr noundef nonnull align 8 dereferenceable(272) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4llvh15SmallVectorImplIcEC2Ej(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef 256)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZNK4llvh5APInt11getBitWidthEv(ptr noundef nonnull align 8 dereferenceable(12) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %BitWidth = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %BitWidth, align 8
  ret i32 %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh5APIntneEm(ptr noundef nonnull align 8 dereferenceable(12) %this, i64 noundef %Val) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Val.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %Val, ptr %Val.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %Val.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh5APInteqEm(ptr noundef nonnull align 8 dereferenceable(12) %this1, i64 noundef %0)
  %lnot = xor i1 %call, true
  ret i1 %lnot
}

declare void @_ZN4llvh5APInt7udivremERKS0_S2_RS0_S3_(ptr noundef nonnull align 8 dereferenceable(12), ptr noundef nonnull align 8 dereferenceable(12), ptr noundef nonnull align 8 dereferenceable(12), ptr noundef nonnull align 8 dereferenceable(12)) #5

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZNK4llvh5APInt12getZExtValueEv(ptr noundef nonnull align 8 dereferenceable(12) %this) #1 comdat align 2 {
entry:
  %retval = alloca i64, align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh5APInt12isSingleWordEv(ptr noundef nonnull align 8 dereferenceable(12) %this1)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %U = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 0
  %0 = load i64, ptr %U, align 8
  store i64 %0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %U2 = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %U2, align 8
  %arrayidx = getelementptr inbounds i64, ptr %1, i64 0
  %2 = load i64, ptr %arrayidx, align 8
  store i64 %2, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load i64, ptr %retval, align 8
  ret i64 %3
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZN4llvh6detail12_GLOBAL__N_117AdjustToPrecisionERNS_15SmallVectorImplIcEERij(ptr noundef nonnull align 8 dereferenceable(16) %buffer, ptr noundef nonnull align 4 dereferenceable(4) %exp, i32 noundef %FormatPrecision) #1 {
entry:
  %this.addr.i87 = alloca ptr, align 8
  %this.addr.i85 = alloca ptr, align 8
  %this.addr.i83 = alloca ptr, align 8
  %this.addr.i81 = alloca ptr, align 8
  %this.addr.i79 = alloca ptr, align 8
  %this.addr.i77 = alloca ptr, align 8
  %this.addr.i75 = alloca ptr, align 8
  %this.addr.i73 = alloca ptr, align 8
  %this.addr.i68 = alloca ptr, align 8
  %idx.addr.i69 = alloca i64, align 8
  %this.addr.i63 = alloca ptr, align 8
  %idx.addr.i64 = alloca i64, align 8
  %this.addr.i58 = alloca ptr, align 8
  %idx.addr.i59 = alloca i64, align 8
  %this.addr.i53 = alloca ptr, align 8
  %idx.addr.i54 = alloca i64, align 8
  %this.addr.i48 = alloca ptr, align 8
  %idx.addr.i49 = alloca i64, align 8
  %this.addr.i43 = alloca ptr, align 8
  %idx.addr.i44 = alloca i64, align 8
  %this.addr.i38 = alloca ptr, align 8
  %idx.addr.i39 = alloca i64, align 8
  %this.addr.i = alloca ptr, align 8
  %idx.addr.i = alloca i64, align 8
  %buffer.addr = alloca ptr, align 8
  %exp.addr = alloca ptr, align 8
  %FormatPrecision.addr = alloca i32, align 4
  %N = alloca i32, align 4
  %FirstSignificant = alloca i32, align 4
  %I = alloca i32, align 4
  %ref.tmp = alloca i8, align 1
  store ptr %buffer, ptr %buffer.addr, align 8
  store ptr %exp, ptr %exp.addr, align 8
  store i32 %FormatPrecision, ptr %FormatPrecision.addr, align 4
  %0 = load ptr, ptr %buffer.addr, align 8
  %call = call noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %0)
  %conv = trunc i64 %call to i32
  store i32 %conv, ptr %N, align 4
  %1 = load i32, ptr %N, align 4
  %2 = load i32, ptr %FormatPrecision.addr, align 4
  %cmp = icmp ule i32 %1, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, ptr %N, align 4
  %4 = load i32, ptr %FormatPrecision.addr, align 4
  %sub = sub i32 %3, %4
  store i32 %sub, ptr %FirstSignificant, align 4
  %5 = load ptr, ptr %buffer.addr, align 8
  %6 = load i32, ptr %FirstSignificant, align 4
  %sub1 = sub i32 %6, 1
  %conv2 = zext i32 %sub1 to i64
  store ptr %5, ptr %this.addr.i68, align 8
  store i64 %conv2, ptr %idx.addr.i69, align 8
  %this1.i70 = load ptr, ptr %this.addr.i68, align 8
  store ptr %this1.i70, ptr %this.addr.i73, align 8
  %this1.i74 = load ptr, ptr %this.addr.i73, align 8
  %7 = load ptr, ptr %this1.i74, align 8
  %8 = load i64, ptr %idx.addr.i69, align 8
  %arrayidx.i72 = getelementptr inbounds i8, ptr %7, i64 %8
  %9 = load i8, ptr %arrayidx.i72, align 1
  %conv4 = sext i8 %9 to i32
  %cmp5 = icmp slt i32 %conv4, 53
  br i1 %cmp5, label %if.then6, label %if.end16

if.then6:                                         ; preds = %if.end
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then6
  %10 = load i32, ptr %FirstSignificant, align 4
  %11 = load i32, ptr %N, align 4
  %cmp7 = icmp ult i32 %10, %11
  br i1 %cmp7, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %12 = load ptr, ptr %buffer.addr, align 8
  %13 = load i32, ptr %FirstSignificant, align 4
  %conv8 = zext i32 %13 to i64
  store ptr %12, ptr %this.addr.i63, align 8
  store i64 %conv8, ptr %idx.addr.i64, align 8
  %this1.i65 = load ptr, ptr %this.addr.i63, align 8
  store ptr %this1.i65, ptr %this.addr.i75, align 8
  %this1.i76 = load ptr, ptr %this.addr.i75, align 8
  %14 = load ptr, ptr %this1.i76, align 8
  %15 = load i64, ptr %idx.addr.i64, align 8
  %arrayidx.i67 = getelementptr inbounds i8, ptr %14, i64 %15
  %16 = load i8, ptr %arrayidx.i67, align 1
  %conv10 = sext i8 %16 to i32
  %cmp11 = icmp eq i32 %conv10, 48
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %17 = phi i1 [ false, %while.cond ], [ %cmp11, %land.rhs ]
  br i1 %17, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %18 = load i32, ptr %FirstSignificant, align 4
  %inc = add i32 %18, 1
  store i32 %inc, ptr %FirstSignificant, align 4
  br label %while.cond, !llvm.loop !39

while.end:                                        ; preds = %land.end
  %19 = load i32, ptr %FirstSignificant, align 4
  %20 = load ptr, ptr %exp.addr, align 8
  %21 = load i32, ptr %20, align 4
  %add = add i32 %21, %19
  store i32 %add, ptr %20, align 4
  %22 = load ptr, ptr %buffer.addr, align 8
  %23 = load ptr, ptr %buffer.addr, align 8
  store ptr %23, ptr %this.addr.i58, align 8
  store i64 0, ptr %idx.addr.i59, align 8
  %this1.i60 = load ptr, ptr %this.addr.i58, align 8
  store ptr %this1.i60, ptr %this.addr.i77, align 8
  %this1.i78 = load ptr, ptr %this.addr.i77, align 8
  %24 = load ptr, ptr %this1.i78, align 8
  %25 = load i64, ptr %idx.addr.i59, align 8
  %arrayidx.i62 = getelementptr inbounds i8, ptr %24, i64 %25
  %26 = load ptr, ptr %buffer.addr, align 8
  %27 = load i32, ptr %FirstSignificant, align 4
  %conv13 = zext i32 %27 to i64
  store ptr %26, ptr %this.addr.i53, align 8
  store i64 %conv13, ptr %idx.addr.i54, align 8
  %this1.i55 = load ptr, ptr %this.addr.i53, align 8
  store ptr %this1.i55, ptr %this.addr.i79, align 8
  %this1.i80 = load ptr, ptr %this.addr.i79, align 8
  %28 = load ptr, ptr %this1.i80, align 8
  %29 = load i64, ptr %idx.addr.i54, align 8
  %arrayidx.i57 = getelementptr inbounds i8, ptr %28, i64 %29
  %call15 = call noundef ptr @_ZN4llvh15SmallVectorImplIcE5eraseEPKcS3_(ptr noundef nonnull align 8 dereferenceable(16) %22, ptr noundef %arrayidx.i62, ptr noundef %arrayidx.i57)
  br label %return

if.end16:                                         ; preds = %if.end
  %30 = load i32, ptr %FirstSignificant, align 4
  store i32 %30, ptr %I, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end16
  %31 = load i32, ptr %I, align 4
  %32 = load i32, ptr %N, align 4
  %cmp17 = icmp ne i32 %31, %32
  br i1 %cmp17, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %33 = load ptr, ptr %buffer.addr, align 8
  %34 = load i32, ptr %I, align 4
  %conv18 = zext i32 %34 to i64
  store ptr %33, ptr %this.addr.i48, align 8
  store i64 %conv18, ptr %idx.addr.i49, align 8
  %this1.i50 = load ptr, ptr %this.addr.i48, align 8
  store ptr %this1.i50, ptr %this.addr.i81, align 8
  %this1.i82 = load ptr, ptr %this.addr.i81, align 8
  %35 = load ptr, ptr %this1.i82, align 8
  %36 = load i64, ptr %idx.addr.i49, align 8
  %arrayidx.i52 = getelementptr inbounds i8, ptr %35, i64 %36
  %37 = load i8, ptr %arrayidx.i52, align 1
  %conv20 = sext i8 %37 to i32
  %cmp21 = icmp eq i32 %conv20, 57
  br i1 %cmp21, label %if.then22, label %if.else

if.then22:                                        ; preds = %for.body
  %38 = load i32, ptr %FirstSignificant, align 4
  %inc23 = add i32 %38, 1
  store i32 %inc23, ptr %FirstSignificant, align 4
  br label %if.end27

if.else:                                          ; preds = %for.body
  %39 = load ptr, ptr %buffer.addr, align 8
  %40 = load i32, ptr %I, align 4
  %conv24 = zext i32 %40 to i64
  store ptr %39, ptr %this.addr.i43, align 8
  store i64 %conv24, ptr %idx.addr.i44, align 8
  %this1.i45 = load ptr, ptr %this.addr.i43, align 8
  store ptr %this1.i45, ptr %this.addr.i83, align 8
  %this1.i84 = load ptr, ptr %this.addr.i83, align 8
  %41 = load ptr, ptr %this1.i84, align 8
  %42 = load i64, ptr %idx.addr.i44, align 8
  %arrayidx.i47 = getelementptr inbounds i8, ptr %41, i64 %42
  %43 = load i8, ptr %arrayidx.i47, align 1
  %inc26 = add i8 %43, 1
  store i8 %inc26, ptr %arrayidx.i47, align 1
  br label %for.end

if.end27:                                         ; preds = %if.then22
  br label %for.inc

for.inc:                                          ; preds = %if.end27
  %44 = load i32, ptr %I, align 4
  %inc28 = add i32 %44, 1
  store i32 %inc28, ptr %I, align 4
  br label %for.cond, !llvm.loop !40

for.end:                                          ; preds = %if.else, %for.cond
  %45 = load i32, ptr %FirstSignificant, align 4
  %46 = load i32, ptr %N, align 4
  %cmp29 = icmp eq i32 %45, %46
  br i1 %cmp29, label %if.then30, label %if.end32

if.then30:                                        ; preds = %for.end
  %47 = load i32, ptr %FirstSignificant, align 4
  %48 = load ptr, ptr %exp.addr, align 8
  %49 = load i32, ptr %48, align 4
  %add31 = add i32 %49, %47
  store i32 %add31, ptr %48, align 4
  %50 = load ptr, ptr %buffer.addr, align 8
  call void @_ZN4llvh15SmallVectorImplIcE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %50)
  %51 = load ptr, ptr %buffer.addr, align 8
  store i8 49, ptr %ref.tmp, align 1
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE9push_backERKc(ptr noundef nonnull align 8 dereferenceable(16) %51, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp)
  br label %return

if.end32:                                         ; preds = %for.end
  %52 = load i32, ptr %FirstSignificant, align 4
  %53 = load ptr, ptr %exp.addr, align 8
  %54 = load i32, ptr %53, align 4
  %add33 = add i32 %54, %52
  store i32 %add33, ptr %53, align 4
  %55 = load ptr, ptr %buffer.addr, align 8
  %56 = load ptr, ptr %buffer.addr, align 8
  store ptr %56, ptr %this.addr.i38, align 8
  store i64 0, ptr %idx.addr.i39, align 8
  %this1.i40 = load ptr, ptr %this.addr.i38, align 8
  store ptr %this1.i40, ptr %this.addr.i85, align 8
  %this1.i86 = load ptr, ptr %this.addr.i85, align 8
  %57 = load ptr, ptr %this1.i86, align 8
  %58 = load i64, ptr %idx.addr.i39, align 8
  %arrayidx.i42 = getelementptr inbounds i8, ptr %57, i64 %58
  %59 = load ptr, ptr %buffer.addr, align 8
  %60 = load i32, ptr %FirstSignificant, align 4
  %conv35 = zext i32 %60 to i64
  store ptr %59, ptr %this.addr.i, align 8
  store i64 %conv35, ptr %idx.addr.i, align 8
  %this1.i = load ptr, ptr %this.addr.i, align 8
  store ptr %this1.i, ptr %this.addr.i87, align 8
  %this1.i88 = load ptr, ptr %this.addr.i87, align 8
  %61 = load ptr, ptr %this1.i88, align 8
  %62 = load i64, ptr %idx.addr.i, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %61, i64 %62
  %call37 = call noundef ptr @_ZN4llvh15SmallVectorImplIcE5eraseEPKcS3_(ptr noundef nonnull align 8 dereferenceable(16) %55, ptr noundef %arrayidx.i42, ptr noundef %arrayidx.i)
  br label %return

return:                                           ; preds = %if.end32, %if.then30, %while.end, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Size = getelementptr inbounds %"class.llvh::SmallVectorBase", ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Size, align 8
  %conv = zext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh11SmallVectorIcLj6EEC2Ev(ptr noundef nonnull align 8 dereferenceable(22) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4llvh15SmallVectorImplIcEC2Ej(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef 6)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh11SmallVectorIcLj6EED2Ev(ptr noundef nonnull align 8 dereferenceable(22) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr.i5 = alloca ptr, align 8
  %this.addr.i3 = alloca ptr, align 8
  %this.addr.i = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store ptr %this1, ptr %this.addr.i5, align 8
  %this1.i6 = load ptr, ptr %this.addr.i5, align 8
  %0 = load ptr, ptr %this1.i6, align 8
  store ptr %this1, ptr %this.addr.i, align 8
  %this1.i = load ptr, ptr %this.addr.i, align 8
  store ptr %this1.i, ptr %this.addr.i3, align 8
  %this1.i4 = load ptr, ptr %this.addr.i3, align 8
  %1 = load ptr, ptr %this1.i4, align 8
  %call2.i = call noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %this1.i)
  %add.ptr.i = getelementptr inbounds i8, ptr %1, i64 %call2.i
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE13destroy_rangeEPcS2_(ptr noundef %0, ptr noundef %add.ptr.i)
  call void @_ZN4llvh15SmallVectorImplIcED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this1) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh11SmallVectorIcLj256EED2Ev(ptr noundef nonnull align 8 dereferenceable(272) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr.i5 = alloca ptr, align 8
  %this.addr.i3 = alloca ptr, align 8
  %this.addr.i = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store ptr %this1, ptr %this.addr.i5, align 8
  %this1.i6 = load ptr, ptr %this.addr.i5, align 8
  %0 = load ptr, ptr %this1.i6, align 8
  store ptr %this1, ptr %this.addr.i, align 8
  %this1.i = load ptr, ptr %this.addr.i, align 8
  store ptr %this1.i, ptr %this.addr.i3, align 8
  %this1.i4 = load ptr, ptr %this.addr.i3, align 8
  %1 = load ptr, ptr %this1.i4, align 8
  %call2.i = call noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %this1.i)
  %add.ptr.i = getelementptr inbounds i8, ptr %1, i64 %call2.i
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE13destroy_rangeEPcS2_(ptr noundef %0, ptr noundef %add.ptr.i)
  call void @_ZN4llvh15SmallVectorImplIcED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this1) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15getExactInverseEPNS_7APFloatE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %inv) #1 align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  %inv.addr = alloca ptr, align 8
  %reciprocal = alloca %"class.llvh::detail::IEEEFloat", align 8
  %cleanup.dest.slot = alloca i32, align 4
  %ref.tmp = alloca %"class.llvh::APFloat", align 8
  %agg.tmp = alloca %"class.llvh::detail::IEEEFloat", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %inv, ptr %inv.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %call2 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat14significandLSBEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %semantics, align 8
  %precision = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %0, i32 0, i32 2
  %1 = load i32, ptr %precision, align 4
  %sub = sub i32 %1, 1
  %cmp = icmp ne i32 %call2, %sub
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end4:                                          ; preds = %if.end
  %semantics5 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %semantics5, align 8
  call void @_ZN4llvh6detail9IEEEFloatC1ERKNS_12fltSemanticsEm(ptr noundef nonnull align 8 dereferenceable(24) %reciprocal, ptr noundef nonnull align 4 dereferenceable(12) %2, i64 noundef 1)
  %call6 = call noundef i32 @_ZN4llvh6detail9IEEEFloat6divideERKS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %reciprocal, ptr noundef nonnull align 8 dereferenceable(24) %this1, i32 noundef 0)
  %cmp7 = icmp ne i32 %call6, 0
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end4
  store i1 false, ptr %retval, align 1
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end9:                                          ; preds = %if.end4
  %call10 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat10isDenormalEv(ptr noundef nonnull align 8 dereferenceable(24) %reciprocal)
  br i1 %call10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end9
  store i1 false, ptr %retval, align 1
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end12:                                         ; preds = %if.end9
  %3 = load ptr, ptr %inv.addr, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then13, label %if.end16

if.then13:                                        ; preds = %if.end12
  call void @_ZN4llvh6detail9IEEEFloatC1ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %reciprocal)
  %semantics14 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %semantics14, align 8
  call void @_ZN4llvh7APFloatC2ENS_6detail9IEEEFloatERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp, ptr noundef %agg.tmp, ptr noundef nonnull align 4 dereferenceable(12) %4)
  %5 = load ptr, ptr %inv.addr, align 8
  %call15 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN4llvh7APFloataSEOS0_(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp)
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp) #10
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp) #10
  br label %if.end16

if.end16:                                         ; preds = %if.then13, %if.end12
  store i1 true, ptr %retval, align 1
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end16, %if.then11, %if.then8
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %reciprocal) #10
  br label %return

return:                                           ; preds = %cleanup, %if.then3, %if.then
  %6 = load i1, ptr %retval, align 1
  ret i1 %6
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh7APFloatC2ENS_6detail9IEEEFloatERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef %F, ptr noundef nonnull align 4 dereferenceable(12) %S) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %F.indirect_addr = alloca ptr, align 8
  %S.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.llvh::detail::IEEEFloat", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %F, ptr %F.indirect_addr, align 8
  store ptr %S, ptr %S.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  call void @_ZN4llvh6detail9IEEEFloatC1EOS1_(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %F)
  %0 = load ptr, ptr %S.addr, align 8
  call void @_ZN4llvh7APFloat7StorageC1ENS_6detail9IEEEFloatERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef %agg.tmp, ptr noundef nonnull align 4 dereferenceable(12) %0)
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 8 dereferenceable(32) ptr @_ZN4llvh7APFloataSEOS0_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(32) %RHS) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %RHS.addr, align 8
  %U2 = getelementptr inbounds %"class.llvh::APFloat", ptr %0, i32 0, i32 1
  %call = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN4llvh7APFloat7StorageaSEOS1_(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef nonnull align 8 dereferenceable(24) %U2)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  call void @_ZN4llvh7APFloat7StorageD2Ev(ptr noundef nonnull align 8 dereferenceable(24) %U) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat11isSignalingEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat5isNaNEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %call2 = call noundef ptr @_ZNK4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %semantics, align 8
  %precision = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %0, i32 0, i32 2
  %1 = load i32, ptr %precision, align 4
  %sub = sub i32 %1, 2
  %call3 = call noundef i32 @_ZN4llvh5APInt12tcExtractBitEPKmj(ptr noundef %call2, i32 noundef %sub)
  %tobool = icmp ne i32 %call3, 0
  %lnot = xor i1 %tobool, true
  store i1 %lnot, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i1, ptr %retval, align 1
  ret i1 %2
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail9IEEEFloat4nextEb(ptr noundef nonnull align 8 dereferenceable(24) %this, i1 noundef zeroext %nextDown) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %nextDown.addr = alloca i8, align 1
  %result = alloca i32, align 4
  %WillCrossBinadeBoundary = alloca i8, align 1
  %Parts = alloca ptr, align 8
  %WillCrossBinadeBoundary49 = alloca i8, align 1
  %Parts57 = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %nextDown to i8
  store i8 %frombool, ptr %nextDown.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i8, ptr %nextDown.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @_ZN4llvh6detail9IEEEFloat10changeSignEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  store i32 0, ptr %result, align 4
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, 7
  %bf.cast = zext i8 %bf.clear to i32
  switch i32 %bf.cast, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb4
    i32 3, label %sw.bb9
    i32 2, label %sw.bb10
  ]

sw.bb:                                            ; preds = %if.end
  %call = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call, label %if.end3, label %if.then2

if.then2:                                         ; preds = %sw.bb
  br label %sw.epilog

if.end3:                                          ; preds = %sw.bb
  call void @_ZN4llvh6detail9IEEEFloat11makeLargestEb(ptr noundef nonnull align 8 dereferenceable(24) %this1, i1 noundef zeroext true)
  br label %sw.epilog

sw.bb4:                                           ; preds = %if.end
  %call5 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat11isSignalingEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %sw.bb4
  store i32 1, ptr %result, align 4
  %call7 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  call void @_ZN4llvh6detail9IEEEFloat7makeNaNEbbPKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this1, i1 noundef zeroext false, i1 noundef zeroext %call7, ptr noundef null)
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %sw.bb4
  br label %sw.epilog

sw.bb9:                                           ; preds = %if.end
  call void @_ZN4llvh6detail9IEEEFloat12makeSmallestEb(ptr noundef nonnull align 8 dereferenceable(24) %this1, i1 noundef zeroext false)
  br label %sw.epilog

sw.bb10:                                          ; preds = %if.end
  %call11 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat10isSmallestEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call11, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %sw.bb10
  %call12 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call12, label %if.then13, label %if.end19

if.then13:                                        ; preds = %land.lhs.true
  %call14 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call15 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  call void @_ZN4llvh5APInt5tcSetEPmmj(ptr noundef %call14, i64 noundef 0, i32 noundef %call15)
  %category16 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load17 = load i8, ptr %category16, align 2
  %bf.clear18 = and i8 %bf.load17, -8
  %bf.set = or i8 %bf.clear18, 3
  store i8 %bf.set, ptr %category16, align 2
  %exponent = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 0, ptr %exponent, align 8
  br label %sw.epilog

if.end19:                                         ; preds = %land.lhs.true, %sw.bb10
  %call20 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat9isLargestEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call20, label %land.lhs.true21, label %if.end32

land.lhs.true21:                                  ; preds = %if.end19
  %call22 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call22, label %if.end32, label %if.then23

if.then23:                                        ; preds = %land.lhs.true21
  %call24 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call25 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  call void @_ZN4llvh5APInt5tcSetEPmmj(ptr noundef %call24, i64 noundef 0, i32 noundef %call25)
  %category26 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load27 = load i8, ptr %category26, align 2
  %bf.clear28 = and i8 %bf.load27, -8
  %bf.set29 = or i8 %bf.clear28, 0
  store i8 %bf.set29, ptr %category26, align 2
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %semantics, align 8
  %maxExponent = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %1, i32 0, i32 0
  %2 = load i16, ptr %maxExponent, align 4
  %conv = sext i16 %2 to i32
  %add = add nsw i32 %conv, 1
  %conv30 = trunc i32 %add to i16
  %exponent31 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  store i16 %conv30, ptr %exponent31, align 8
  br label %sw.epilog

if.end32:                                         ; preds = %land.lhs.true21, %if.end19
  %call33 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call33, label %if.then34, label %if.else

if.then34:                                        ; preds = %if.end32
  %exponent35 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %3 = load i16, ptr %exponent35, align 8
  %conv36 = sext i16 %3 to i32
  %semantics37 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %semantics37, align 8
  %minExponent = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %4, i32 0, i32 1
  %5 = load i16, ptr %minExponent, align 2
  %conv38 = sext i16 %5 to i32
  %cmp = icmp ne i32 %conv36, %conv38
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then34
  %call39 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat21isSignificandAllZerosEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then34
  %6 = phi i1 [ false, %if.then34 ], [ %call39, %land.rhs ]
  %frombool40 = zext i1 %6 to i8
  store i8 %frombool40, ptr %WillCrossBinadeBoundary, align 1
  %call41 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store ptr %call41, ptr %Parts, align 8
  %7 = load ptr, ptr %Parts, align 8
  %call42 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call43 = call noundef i64 @_ZN4llvh5APInt11tcDecrementEPmj(ptr noundef %7, i32 noundef %call42)
  %8 = load i8, ptr %WillCrossBinadeBoundary, align 1
  %tobool44 = trunc i8 %8 to i1
  br i1 %tobool44, label %if.then45, label %if.end48

if.then45:                                        ; preds = %land.end
  %9 = load ptr, ptr %Parts, align 8
  %semantics46 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %semantics46, align 8
  %precision = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %10, i32 0, i32 2
  %11 = load i32, ptr %precision, align 4
  %sub = sub i32 %11, 1
  call void @_ZN4llvh5APInt8tcSetBitEPmj(ptr noundef %9, i32 noundef %sub)
  %exponent47 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %12 = load i16, ptr %exponent47, align 8
  %dec = add i16 %12, -1
  store i16 %dec, ptr %exponent47, align 8
  br label %if.end48

if.end48:                                         ; preds = %if.then45, %land.end
  br label %if.end66

if.else:                                          ; preds = %if.end32
  %call50 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat10isDenormalEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br i1 %call50, label %land.end53, label %land.rhs51

land.rhs51:                                       ; preds = %if.else
  %call52 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat20isSignificandAllOnesEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br label %land.end53

land.end53:                                       ; preds = %land.rhs51, %if.else
  %13 = phi i1 [ false, %if.else ], [ %call52, %land.rhs51 ]
  %frombool54 = zext i1 %13 to i8
  store i8 %frombool54, ptr %WillCrossBinadeBoundary49, align 1
  %14 = load i8, ptr %WillCrossBinadeBoundary49, align 1
  %tobool55 = trunc i8 %14 to i1
  br i1 %tobool55, label %if.then56, label %if.else64

if.then56:                                        ; preds = %land.end53
  %call58 = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  store ptr %call58, ptr %Parts57, align 8
  %15 = load ptr, ptr %Parts57, align 8
  %call59 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat9partCountEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  call void @_ZN4llvh5APInt5tcSetEPmmj(ptr noundef %15, i64 noundef 0, i32 noundef %call59)
  %16 = load ptr, ptr %Parts57, align 8
  %semantics60 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %17 = load ptr, ptr %semantics60, align 8
  %precision61 = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %17, i32 0, i32 2
  %18 = load i32, ptr %precision61, align 4
  %sub62 = sub i32 %18, 1
  call void @_ZN4llvh5APInt8tcSetBitEPmj(ptr noundef %16, i32 noundef %sub62)
  %exponent63 = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 2
  %19 = load i16, ptr %exponent63, align 8
  %inc = add i16 %19, 1
  store i16 %inc, ptr %exponent63, align 8
  br label %if.end65

if.else64:                                        ; preds = %land.end53
  call void @_ZN4llvh6detail9IEEEFloat20incrementSignificandEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br label %if.end65

if.end65:                                         ; preds = %if.else64, %if.then56
  br label %if.end66

if.end66:                                         ; preds = %if.end65, %if.end48
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end66, %if.then23, %if.then13, %sw.bb9, %if.end8, %if.end3, %if.then2, %if.end
  %20 = load i8, ptr %nextDown.addr, align 1
  %tobool67 = trunc i8 %20 to i1
  br i1 %tobool67, label %if.then68, label %if.end69

if.then68:                                        ; preds = %sw.epilog
  call void @_ZN4llvh6detail9IEEEFloat10changeSignEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br label %if.end69

if.end69:                                         ; preds = %if.then68, %sw.epilog
  %21 = load i32, ptr %result, align 4
  ret i32 %21
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZN4llvh5APInt11tcDecrementEPmj(ptr noundef %dst, i32 noundef %parts) #1 comdat align 2 {
entry:
  %dst.addr = alloca ptr, align 8
  %parts.addr = alloca i32, align 4
  store ptr %dst, ptr %dst.addr, align 8
  store i32 %parts, ptr %parts.addr, align 4
  %0 = load ptr, ptr %dst.addr, align 8
  %1 = load i32, ptr %parts.addr, align 4
  %call = call noundef i64 @_ZN4llvh5APInt14tcSubtractPartEPmmj(ptr noundef %0, i64 noundef 1, i32 noundef %1)
  ret i64 %call
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail9IEEEFloat9makeQuietEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZN4llvh6detail9IEEEFloat16significandPartsEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %semantics, align 8
  %precision = getelementptr inbounds %"struct.llvh::fltSemantics", ptr %0, i32 0, i32 2
  %1 = load i32, ptr %precision, align 4
  %sub = sub i32 %1, 2
  call void @_ZN4llvh5APInt8tcSetBitEPmj(ptr noundef %call, i32 noundef %sub)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat10isInfinityEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, 7
  %bf.cast = zext i8 %bf.clear to i32
  %cmp = icmp eq i32 %bf.cast, 0
  ret i1 %cmp
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh6detail9IEEEFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %semantics = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %semantics, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 4 dereferenceable(4) ptr @_ZSt3minIiERKT_S2_S2_(ptr noundef nonnull align 4 dereferenceable(4) %__a, ptr noundef nonnull align 4 dereferenceable(4) %__b) #1 comdat {
entry:
  %retval = alloca ptr, align 8
  %__a.addr = alloca ptr, align 8
  %__b.addr = alloca ptr, align 8
  store ptr %__a, ptr %__a.addr, align 8
  store ptr %__b, ptr %__b.addr, align 8
  %0 = load ptr, ptr %__b.addr, align 8
  %1 = load i32, ptr %0, align 4
  %2 = load ptr, ptr %__a.addr, align 8
  %3 = load i32, ptr %2, align 4
  %cmp = icmp slt i32 %1, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %__b.addr, align 8
  store ptr %4, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %__a.addr, align 8
  store ptr %5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load ptr, ptr %retval, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 4 dereferenceable(4) ptr @_ZSt3maxIiERKT_S2_S2_(ptr noundef nonnull align 4 dereferenceable(4) %__a, ptr noundef nonnull align 4 dereferenceable(4) %__b) #1 comdat {
entry:
  %retval = alloca ptr, align 8
  %__a.addr = alloca ptr, align 8
  %__b.addr = alloca ptr, align 8
  store ptr %__a, ptr %__a.addr, align 8
  store ptr %__b, ptr %__b.addr, align 8
  %0 = load ptr, ptr %__a.addr, align 8
  %1 = load i32, ptr %0, align 4
  %2 = load ptr, ptr %__b.addr, align 8
  %3 = load i32, ptr %2, align 4
  %cmp = icmp slt i32 %1, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %__b.addr, align 8
  store ptr %4, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %__a.addr, align 8
  store ptr %5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load ptr, ptr %retval, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail5frexpERKNS0_9IEEEFloatERiNS_11APFloatBase12roundingModeE(ptr noalias sret(%"class.llvh::detail::IEEEFloat") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(24) %Val, ptr noundef nonnull align 4 dereferenceable(4) %Exp, i32 noundef %RM) #1 {
entry:
  %result.ptr = alloca ptr, align 8
  %Val.addr = alloca ptr, align 8
  %Exp.addr = alloca ptr, align 8
  %RM.addr = alloca i32, align 4
  %nrvo = alloca i1, align 1
  %agg.tmp = alloca %"class.llvh::detail::IEEEFloat", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %Val, ptr %Val.addr, align 8
  store ptr %Exp, ptr %Exp.addr, align 8
  store i32 %RM, ptr %RM.addr, align 4
  %0 = load ptr, ptr %Val.addr, align 8
  %call = call noundef i32 @_ZN4llvh6detail5ilogbERKNS0_9IEEEFloatE(ptr noundef nonnull align 8 dereferenceable(24) %0)
  %1 = load ptr, ptr %Exp.addr, align 8
  store i32 %call, ptr %1, align 4
  %2 = load ptr, ptr %Exp.addr, align 8
  %3 = load i32, ptr %2, align 4
  %cmp = icmp eq i32 %3, -2147483648
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %nrvo, align 1
  %4 = load ptr, ptr %Val.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloatC1ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %agg.result, ptr noundef nonnull align 8 dereferenceable(24) %4)
  call void @_ZN4llvh6detail9IEEEFloat9makeQuietEv(ptr noundef nonnull align 8 dereferenceable(24) %agg.result)
  store i1 true, ptr %nrvo, align 1
  %nrvo.val = load i1, ptr %nrvo, align 1
  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused

nrvo.unused:                                      ; preds = %if.then
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %agg.result) #10
  br label %nrvo.skipdtor

nrvo.skipdtor:                                    ; preds = %nrvo.unused, %if.then
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %Exp.addr, align 8
  %6 = load i32, ptr %5, align 4
  %cmp1 = icmp eq i32 %6, 2147483647
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %7 = load ptr, ptr %Val.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloatC1ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %agg.result, ptr noundef nonnull align 8 dereferenceable(24) %7)
  br label %return

if.end3:                                          ; preds = %if.end
  %8 = load ptr, ptr %Exp.addr, align 8
  %9 = load i32, ptr %8, align 4
  %cmp4 = icmp eq i32 %9, -2147483647
  br i1 %cmp4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end3
  br label %cond.end

cond.false:                                       ; preds = %if.end3
  %10 = load ptr, ptr %Exp.addr, align 8
  %11 = load i32, ptr %10, align 4
  %add = add nsw i32 %11, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 0, %cond.true ], [ %add, %cond.false ]
  %12 = load ptr, ptr %Exp.addr, align 8
  store i32 %cond, ptr %12, align 4
  %13 = load ptr, ptr %Val.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloatC1ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %13)
  %14 = load ptr, ptr %Exp.addr, align 8
  %15 = load i32, ptr %14, align 4
  %sub = sub nsw i32 0, %15
  %16 = load i32, ptr %RM.addr, align 4
  call void @_ZN4llvh6detail6scalbnENS0_9IEEEFloatEiNS_11APFloatBase12roundingModeE(ptr sret(%"class.llvh::detail::IEEEFloat") align 8 %agg.result, ptr noundef %agg.tmp, i32 noundef %sub, i32 noundef %16)
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp) #10
  br label %return

return:                                           ; preds = %cond.end, %if.then2, %nrvo.skipdtor
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail13DoubleAPFloatC2ERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 4 dereferenceable(12) %S) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %S.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %S, ptr %S.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Semantics = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %S.addr, align 8
  store ptr %0, ptr %Semantics, align 8
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call = call noalias noundef nonnull ptr @_Znam(i64 noundef 72) #13
  store i64 2, ptr %call, align 16
  %1 = getelementptr inbounds i8, ptr %call, i64 8
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(32) %1, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL13semIEEEdoubleE)
  %array.exp.next = getelementptr inbounds %"class.llvh::APFloat", ptr %1, i64 1
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(32) %array.exp.next, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL13semIEEEdoubleE)
  call void @_ZNSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEC2IPS1_S4_vbEET_(ptr noundef nonnull align 8 dereferenceable(8) %Floats, ptr noundef %1) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 4 dereferenceable(12) %Semantics) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Semantics.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %Semantics, ptr %Semantics.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %Semantics.addr, align 8
  call void @_ZN4llvh7APFloat7StorageC2IJEEERKNS_12fltSemanticsEDpOT_(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef nonnull align 4 dereferenceable(12) %0)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZNSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEC2IPS1_S4_vbEET_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %__p) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %__p.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %__p, ptr %__p.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %_M_t = getelementptr inbounds %"class.std::unique_ptr", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %__p.addr, align 8
  call void @_ZNSt15__uniq_ptr_dataIN4llvh7APFloatESt14default_deleteIA_S1_ELb1ELb1EECI2St15__uniq_ptr_implIS1_S4_EEPS1_(ptr noundef nonnull align 8 dereferenceable(8) %_M_t, ptr noundef %0)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail13DoubleAPFloatC2ERKNS_12fltSemanticsENS_11APFloatBase16uninitializedTagE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 4 dereferenceable(12) %S, i32 noundef %0) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %S.addr = alloca ptr, align 8
  %.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %S, ptr %S.addr, align 8
  store i32 %0, ptr %.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Semantics = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %S.addr, align 8
  store ptr %1, ptr %Semantics, align 8
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call = call noalias noundef nonnull ptr @_Znam(i64 noundef 72) #13
  store i64 2, ptr %call, align 16
  %2 = getelementptr inbounds i8, ptr %call, i64 8
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsENS_11APFloatBase16uninitializedTagE(ptr noundef nonnull align 8 dereferenceable(32) %2, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL13semIEEEdoubleE, i32 noundef 0)
  %array.exp.next = getelementptr inbounds %"class.llvh::APFloat", ptr %2, i64 1
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsENS_11APFloatBase16uninitializedTagE(ptr noundef nonnull align 8 dereferenceable(32) %array.exp.next, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL13semIEEEdoubleE, i32 noundef 0)
  call void @_ZNSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEC2IPS1_S4_vbEET_(ptr noundef nonnull align 8 dereferenceable(8) %Floats, ptr noundef %2) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsENS_11APFloatBase16uninitializedTagE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 4 dereferenceable(12) %Semantics, i32 noundef %0) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Semantics.addr = alloca ptr, align 8
  %.addr = alloca i32, align 4
  %ref.tmp = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %Semantics, ptr %Semantics.addr, align 8
  store i32 %0, ptr %.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %Semantics.addr, align 8
  store i32 0, ptr %ref.tmp, align 4
  call void @_ZN4llvh7APFloat7StorageC2IJNS_11APFloatBase16uninitializedTagEEEERKNS_12fltSemanticsEDpOT_(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef nonnull align 4 dereferenceable(12) %1, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail13DoubleAPFloatC2ERKNS_12fltSemanticsEm(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 4 dereferenceable(12) %S, i64 noundef %I) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %S.addr = alloca ptr, align 8
  %I.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %S, ptr %S.addr, align 8
  store i64 %I, ptr %I.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Semantics = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %S.addr, align 8
  store ptr %0, ptr %Semantics, align 8
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call = call noalias noundef nonnull ptr @_Znam(i64 noundef 72) #13
  store i64 2, ptr %call, align 16
  %1 = getelementptr inbounds i8, ptr %call, i64 8
  %2 = load i64, ptr %I.addr, align 8
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsEm(ptr noundef nonnull align 8 dereferenceable(32) %1, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL13semIEEEdoubleE, i64 noundef %2)
  %array.exp.next = getelementptr inbounds %"class.llvh::APFloat", ptr %1, i64 1
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(32) %array.exp.next, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL13semIEEEdoubleE)
  call void @_ZNSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEC2IPS1_S4_vbEET_(ptr noundef nonnull align 8 dereferenceable(8) %Floats, ptr noundef %1) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsEm(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 4 dereferenceable(12) %Semantics, i64 noundef %I) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Semantics.addr = alloca ptr, align 8
  %I.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %Semantics, ptr %Semantics.addr, align 8
  store i64 %I, ptr %I.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %Semantics.addr, align 8
  call void @_ZN4llvh7APFloat7StorageC2IJRmEEERKNS_12fltSemanticsEDpOT_(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef nonnull align 4 dereferenceable(12) %0, ptr noundef nonnull align 8 dereferenceable(8) %I.addr)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail13DoubleAPFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 4 dereferenceable(12) %S, ptr noundef nonnull align 8 dereferenceable(12) %I) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %S.addr = alloca ptr, align 8
  %I.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.llvh::APInt", align 8
  %ref.tmp3 = alloca %"class.llvh::APInt", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %S, ptr %S.addr, align 8
  store ptr %I, ptr %I.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Semantics = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %S.addr, align 8
  store ptr %0, ptr %Semantics, align 8
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call = call noalias noundef nonnull ptr @_Znam(i64 noundef 72) #13
  store i64 2, ptr %call, align 16
  %1 = getelementptr inbounds i8, ptr %call, i64 8
  %2 = load ptr, ptr %I.addr, align 8
  %call2 = call noundef ptr @_ZNK4llvh5APInt10getRawDataEv(ptr noundef nonnull align 8 dereferenceable(12) %2)
  %arrayidx = getelementptr inbounds i64, ptr %call2, i64 0
  %3 = load i64, ptr %arrayidx, align 8
  call void @_ZN4llvh5APIntC2Ejmb(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp, i32 noundef 64, i64 noundef %3, i1 noundef zeroext false)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %1, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL13semIEEEdoubleE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp)
  %array.exp.next = getelementptr inbounds %"class.llvh::APFloat", ptr %1, i64 1
  %4 = load ptr, ptr %I.addr, align 8
  %call4 = call noundef ptr @_ZNK4llvh5APInt10getRawDataEv(ptr noundef nonnull align 8 dereferenceable(12) %4)
  %arrayidx5 = getelementptr inbounds i64, ptr %call4, i64 1
  %5 = load i64, ptr %arrayidx5, align 8
  call void @_ZN4llvh5APIntC2Ejmb(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp3, i32 noundef 64, i64 noundef %5, i1 noundef zeroext false)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %array.exp.next, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL13semIEEEdoubleE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp3)
  call void @_ZNSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEC2IPS1_S4_vbEET_(ptr noundef nonnull align 8 dereferenceable(8) %Floats, ptr noundef %1) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp3) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 4 dereferenceable(12) %Semantics, ptr noundef nonnull align 8 dereferenceable(12) %I) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Semantics.addr = alloca ptr, align 8
  %I.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %Semantics, ptr %Semantics.addr, align 8
  store ptr %I, ptr %I.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %Semantics.addr, align 8
  %1 = load ptr, ptr %I.addr, align 8
  call void @_ZN4llvh7APFloat7StorageC2IJRKNS_5APIntEEEERKNS_12fltSemanticsEDpOT_(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef nonnull align 4 dereferenceable(12) %0, ptr noundef nonnull align 8 dereferenceable(12) %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail13DoubleAPFloatC2ERKNS_12fltSemanticsEONS_7APFloatES6_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 4 dereferenceable(12) %S, ptr noundef nonnull align 8 dereferenceable(32) %First, ptr noundef nonnull align 8 dereferenceable(32) %Second) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %S.addr = alloca ptr, align 8
  %First.addr = alloca ptr, align 8
  %Second.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %S, ptr %S.addr, align 8
  store ptr %First, ptr %First.addr, align 8
  store ptr %Second, ptr %Second.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Semantics = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %S.addr, align 8
  store ptr %0, ptr %Semantics, align 8
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call = call noalias noundef nonnull ptr @_Znam(i64 noundef 72) #13
  store i64 2, ptr %call, align 16
  %1 = getelementptr inbounds i8, ptr %call, i64 8
  %2 = load ptr, ptr %First.addr, align 8
  call void @_ZN4llvh7APFloatC2EOS0_(ptr noundef nonnull align 8 dereferenceable(32) %1, ptr noundef nonnull align 8 dereferenceable(32) %2)
  %array.exp.next = getelementptr inbounds %"class.llvh::APFloat", ptr %1, i64 1
  %3 = load ptr, ptr %Second.addr, align 8
  call void @_ZN4llvh7APFloatC2EOS0_(ptr noundef nonnull align 8 dereferenceable(32) %array.exp.next, ptr noundef nonnull align 8 dereferenceable(32) %3)
  call void @_ZNSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEC2IPS1_S4_vbEET_(ptr noundef nonnull align 8 dereferenceable(8) %Floats, ptr noundef %1) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh7APFloatC2EOS0_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(32) %RHS) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %RHS.addr, align 8
  %U2 = getelementptr inbounds %"class.llvh::APFloat", ptr %0, i32 0, i32 1
  call void @_ZN4llvh7APFloat7StorageC2EOS1_(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef nonnull align 8 dereferenceable(24) %U2)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail13DoubleAPFloatC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %RHS) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Semantics = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %RHS.addr, align 8
  %Semantics2 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %Semantics2, align 8
  store ptr %1, ptr %Semantics, align 8
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %RHS.addr, align 8
  %Floats3 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %2, i32 0, i32 1
  %call = call noundef zeroext i1 @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEcvbEv(ptr noundef nonnull align 8 dereferenceable(8) %Floats3) #10
  br i1 %call, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call4 = call noalias noundef nonnull ptr @_Znam(i64 noundef 72) #13
  store i64 2, ptr %call4, align 16
  %3 = getelementptr inbounds i8, ptr %call4, i64 8
  %4 = load ptr, ptr %RHS.addr, align 8
  %Floats5 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %4, i32 0, i32 1
  %call6 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats5, i64 noundef 0)
  call void @_ZN4llvh7APFloatC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %3, ptr noundef nonnull align 8 dereferenceable(32) %call6)
  %array.exp.next = getelementptr inbounds %"class.llvh::APFloat", ptr %3, i64 1
  %5 = load ptr, ptr %RHS.addr, align 8
  %Floats7 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %5, i32 0, i32 1
  %call8 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats7, i64 noundef 1)
  call void @_ZN4llvh7APFloatC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %array.exp.next, ptr noundef nonnull align 8 dereferenceable(32) %call8)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %3, %cond.true ], [ null, %cond.false ]
  call void @_ZNSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEC2IPS1_S4_vbEET_(ptr noundef nonnull align 8 dereferenceable(8) %Floats, ptr noundef %cond) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEcvbEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EE3getEv(ptr noundef nonnull align 8 dereferenceable(8) %this1) #10
  %cmp = icmp eq ptr %call, null
  %cond = select i1 %cmp, i1 false, i1 true
  ret i1 %cond
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %this, i64 noundef %__i) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %__i.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %__i, ptr %__i.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %call = call noundef ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EE3getEv(ptr noundef nonnull align 8 dereferenceable(8) %this1) #10
  %0 = load i64, ptr %__i.addr, align 8
  %arrayidx = getelementptr inbounds %"class.llvh::APFloat", ptr %call, i64 %0
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh7APFloatC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(32) %RHS) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %RHS.addr, align 8
  %U2 = getelementptr inbounds %"class.llvh::APFloat", ptr %0, i32 0, i32 1
  call void @_ZN4llvh7APFloat7StorageC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef nonnull align 8 dereferenceable(24) %U2)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail13DoubleAPFloatC2EOS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %RHS) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Semantics = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %RHS.addr, align 8
  %Semantics2 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %Semantics2, align 8
  store ptr %1, ptr %Semantics, align 8
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %RHS.addr, align 8
  %Floats3 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %2, i32 0, i32 1
  call void @_ZNSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEC2EOS5_(ptr noundef nonnull align 8 dereferenceable(8) %Floats, ptr noundef nonnull align 8 dereferenceable(8) %Floats3) #10
  %3 = load ptr, ptr %RHS.addr, align 8
  %Semantics4 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %3, i32 0, i32 0
  store ptr @_ZN4llvhL8semBogusE, ptr %Semantics4, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZNSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEC2EOS5_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 8 dereferenceable(8) %0) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %0, ptr %.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %_M_t = getelementptr inbounds %"class.std::unique_ptr", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %.addr, align 8
  %_M_t2 = getelementptr inbounds %"class.std::unique_ptr", ptr %1, i32 0, i32 0
  call void @_ZNSt15__uniq_ptr_dataIN4llvh7APFloatESt14default_deleteIA_S1_ELb1ELb1EEC2EOS5_(ptr noundef nonnull align 8 dereferenceable(8) %_M_t, ptr noundef nonnull align 8 dereferenceable(8) %_M_t2) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef nonnull align 8 dereferenceable(16) ptr @_ZN4llvh6detail13DoubleAPFloataSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %RHS) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Semantics = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %Semantics, align 8
  %1 = load ptr, ptr %RHS.addr, align 8
  %Semantics2 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %Semantics2, align 8
  %cmp = icmp eq ptr %0, %2
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %3 = load ptr, ptr %RHS.addr, align 8
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %3, i32 0, i32 1
  %call = call noundef zeroext i1 @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEcvbEv(ptr noundef nonnull align 8 dereferenceable(8) %Floats) #10
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %4 = load ptr, ptr %RHS.addr, align 8
  %Floats3 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %4, i32 0, i32 1
  %call4 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats3, i64 noundef 0)
  %Floats5 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call6 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats5, i64 noundef 0)
  %call7 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN4llvh7APFloataSERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %call6, ptr noundef nonnull align 8 dereferenceable(32) %call4)
  %5 = load ptr, ptr %RHS.addr, align 8
  %Floats8 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %5, i32 0, i32 1
  %call9 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats8, i64 noundef 1)
  %Floats10 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call11 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats10, i64 noundef 1)
  %call12 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN4llvh7APFloataSERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %call11, ptr noundef nonnull align 8 dereferenceable(32) %call9)
  br label %if.end15

if.else:                                          ; preds = %land.lhs.true, %entry
  %6 = load ptr, ptr %RHS.addr, align 8
  %cmp13 = icmp ne ptr %this1, %6
  br i1 %cmp13, label %if.then14, label %if.end

if.then14:                                        ; preds = %if.else
  call void @_ZN4llvh6detail13DoubleAPFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this1) #10
  %7 = load ptr, ptr %RHS.addr, align 8
  call void @_ZN4llvh6detail13DoubleAPFloatC1ERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %7)
  br label %if.end

if.end:                                           ; preds = %if.then14, %if.else
  br label %if.end15

if.end15:                                         ; preds = %if.end, %if.then
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 8 dereferenceable(32) ptr @_ZN4llvh7APFloataSERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(32) %RHS) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %RHS.addr, align 8
  %U2 = getelementptr inbounds %"class.llvh::APFloat", ptr %0, i32 0, i32 1
  %call = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN4llvh7APFloat7StorageaSERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef nonnull align 8 dereferenceable(24) %U2)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh6detail13DoubleAPFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  call void @_ZNSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EED2Ev(ptr noundef nonnull align 8 dereferenceable(8) %Floats) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail13DoubleAPFloat7addImplERKNS_7APFloatES4_S4_S4_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(32) %a, ptr noundef nonnull align 8 dereferenceable(32) %aa, ptr noundef nonnull align 8 dereferenceable(32) %c, ptr noundef nonnull align 8 dereferenceable(32) %cc, i32 noundef %RM) #1 align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %a.addr = alloca ptr, align 8
  %aa.addr = alloca ptr, align 8
  %c.addr = alloca ptr, align 8
  %cc.addr = alloca ptr, align 8
  %RM.addr = alloca i32, align 4
  %Status = alloca i32, align 4
  %z = alloca %"class.llvh::APFloat", align 8
  %cleanup.dest.slot = alloca i32, align 4
  %AComparedToC = alloca i32, align 4
  %zz = alloca %"class.llvh::APFloat", align 8
  %q = alloca %"class.llvh::APFloat", align 8
  %zz73 = alloca %"class.llvh::APFloat", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %aa, ptr %aa.addr, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %cc, ptr %cc.addr, align 8
  store i32 %RM, ptr %RM.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  store i32 0, ptr %Status, align 4
  %0 = load ptr, ptr %a.addr, align 8
  call void @_ZN4llvh7APFloatC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %z, ptr noundef nonnull align 8 dereferenceable(32) %0)
  %1 = load ptr, ptr %c.addr, align 8
  %2 = load i32, ptr %RM.addr, align 4
  %call = call noundef i32 @_ZN4llvh7APFloat3addERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %z, ptr noundef nonnull align 8 dereferenceable(32) %1, i32 noundef %2)
  %3 = load i32, ptr %Status, align 4
  %or = or i32 %3, %call
  store i32 %or, ptr %Status, align 4
  %call2 = call noundef zeroext i1 @_ZNK4llvh7APFloat8isFiniteEv(ptr noundef nonnull align 8 dereferenceable(32) %z)
  br i1 %call2, label %if.else70, label %if.then

if.then:                                          ; preds = %entry
  %call3 = call noundef zeroext i1 @_ZNK4llvh7APFloat10isInfinityEv(ptr noundef nonnull align 8 dereferenceable(32) %z)
  br i1 %call3, label %if.end, label %if.then4

if.then4:                                         ; preds = %if.then
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call5 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats, i64 noundef 0)
  %call6 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN4llvh7APFloataSEOS0_(ptr noundef nonnull align 8 dereferenceable(32) %call5, ptr noundef nonnull align 8 dereferenceable(32) %z)
  %Floats7 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call8 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats7, i64 noundef 1)
  call void @_ZN4llvh7APFloat8makeZeroEb(ptr noundef nonnull align 8 dereferenceable(32) %call8, i1 noundef zeroext false)
  %4 = load i32, ptr %Status, align 4
  store i32 %4, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup124

if.end:                                           ; preds = %if.then
  store i32 0, ptr %Status, align 4
  %5 = load ptr, ptr %a.addr, align 8
  %6 = load ptr, ptr %c.addr, align 8
  %call9 = call noundef i32 @_ZNK4llvh7APFloat20compareAbsoluteValueERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %5, ptr noundef nonnull align 8 dereferenceable(32) %6)
  store i32 %call9, ptr %AComparedToC, align 4
  %7 = load ptr, ptr %cc.addr, align 8
  %call10 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN4llvh7APFloataSERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %z, ptr noundef nonnull align 8 dereferenceable(32) %7)
  %8 = load ptr, ptr %aa.addr, align 8
  %9 = load i32, ptr %RM.addr, align 4
  %call11 = call noundef i32 @_ZN4llvh7APFloat3addERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %z, ptr noundef nonnull align 8 dereferenceable(32) %8, i32 noundef %9)
  %10 = load i32, ptr %Status, align 4
  %or12 = or i32 %10, %call11
  store i32 %or12, ptr %Status, align 4
  %11 = load i32, ptr %AComparedToC, align 4
  %cmp = icmp eq i32 %11, 2
  br i1 %cmp, label %if.then13, label %if.else

if.then13:                                        ; preds = %if.end
  %12 = load ptr, ptr %c.addr, align 8
  %13 = load i32, ptr %RM.addr, align 4
  %call14 = call noundef i32 @_ZN4llvh7APFloat3addERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %z, ptr noundef nonnull align 8 dereferenceable(32) %12, i32 noundef %13)
  %14 = load i32, ptr %Status, align 4
  %or15 = or i32 %14, %call14
  store i32 %or15, ptr %Status, align 4
  %15 = load ptr, ptr %a.addr, align 8
  %16 = load i32, ptr %RM.addr, align 4
  %call16 = call noundef i32 @_ZN4llvh7APFloat3addERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %z, ptr noundef nonnull align 8 dereferenceable(32) %15, i32 noundef %16)
  %17 = load i32, ptr %Status, align 4
  %or17 = or i32 %17, %call16
  store i32 %or17, ptr %Status, align 4
  br label %if.end22

if.else:                                          ; preds = %if.end
  %18 = load ptr, ptr %a.addr, align 8
  %19 = load i32, ptr %RM.addr, align 4
  %call18 = call noundef i32 @_ZN4llvh7APFloat3addERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %z, ptr noundef nonnull align 8 dereferenceable(32) %18, i32 noundef %19)
  %20 = load i32, ptr %Status, align 4
  %or19 = or i32 %20, %call18
  store i32 %or19, ptr %Status, align 4
  %21 = load ptr, ptr %c.addr, align 8
  %22 = load i32, ptr %RM.addr, align 4
  %call20 = call noundef i32 @_ZN4llvh7APFloat3addERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %z, ptr noundef nonnull align 8 dereferenceable(32) %21, i32 noundef %22)
  %23 = load i32, ptr %Status, align 4
  %or21 = or i32 %23, %call20
  store i32 %or21, ptr %Status, align 4
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.then13
  %call23 = call noundef zeroext i1 @_ZNK4llvh7APFloat8isFiniteEv(ptr noundef nonnull align 8 dereferenceable(32) %z)
  br i1 %call23, label %if.end30, label %if.then24

if.then24:                                        ; preds = %if.end22
  %Floats25 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call26 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats25, i64 noundef 0)
  %call27 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN4llvh7APFloataSEOS0_(ptr noundef nonnull align 8 dereferenceable(32) %call26, ptr noundef nonnull align 8 dereferenceable(32) %z)
  %Floats28 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call29 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats28, i64 noundef 1)
  call void @_ZN4llvh7APFloat8makeZeroEb(ptr noundef nonnull align 8 dereferenceable(32) %call29, i1 noundef zeroext false)
  %24 = load i32, ptr %Status, align 4
  store i32 %24, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup124

if.end30:                                         ; preds = %if.end22
  %Floats31 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call32 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats31, i64 noundef 0)
  %call33 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN4llvh7APFloataSERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %call32, ptr noundef nonnull align 8 dereferenceable(32) %z)
  %25 = load ptr, ptr %aa.addr, align 8
  call void @_ZN4llvh7APFloatC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %zz, ptr noundef nonnull align 8 dereferenceable(32) %25)
  %26 = load ptr, ptr %cc.addr, align 8
  %27 = load i32, ptr %RM.addr, align 4
  %call34 = call noundef i32 @_ZN4llvh7APFloat3addERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %zz, ptr noundef nonnull align 8 dereferenceable(32) %26, i32 noundef %27)
  %28 = load i32, ptr %Status, align 4
  %or35 = or i32 %28, %call34
  store i32 %or35, ptr %Status, align 4
  %29 = load i32, ptr %AComparedToC, align 4
  %cmp36 = icmp eq i32 %29, 2
  br i1 %cmp36, label %if.then37, label %if.else53

if.then37:                                        ; preds = %if.end30
  %30 = load ptr, ptr %a.addr, align 8
  %Floats38 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call39 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats38, i64 noundef 1)
  %call40 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN4llvh7APFloataSERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %call39, ptr noundef nonnull align 8 dereferenceable(32) %30)
  %Floats41 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call42 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats41, i64 noundef 1)
  %31 = load i32, ptr %RM.addr, align 4
  %call43 = call noundef i32 @_ZN4llvh7APFloat8subtractERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %call42, ptr noundef nonnull align 8 dereferenceable(32) %z, i32 noundef %31)
  %32 = load i32, ptr %Status, align 4
  %or44 = or i32 %32, %call43
  store i32 %or44, ptr %Status, align 4
  %Floats45 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call46 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats45, i64 noundef 1)
  %33 = load ptr, ptr %c.addr, align 8
  %34 = load i32, ptr %RM.addr, align 4
  %call47 = call noundef i32 @_ZN4llvh7APFloat3addERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %call46, ptr noundef nonnull align 8 dereferenceable(32) %33, i32 noundef %34)
  %35 = load i32, ptr %Status, align 4
  %or48 = or i32 %35, %call47
  store i32 %or48, ptr %Status, align 4
  %Floats49 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call50 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats49, i64 noundef 1)
  %36 = load i32, ptr %RM.addr, align 4
  %call51 = call noundef i32 @_ZN4llvh7APFloat3addERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %call50, ptr noundef nonnull align 8 dereferenceable(32) %zz, i32 noundef %36)
  %37 = load i32, ptr %Status, align 4
  %or52 = or i32 %37, %call51
  store i32 %or52, ptr %Status, align 4
  br label %if.end69

if.else53:                                        ; preds = %if.end30
  %38 = load ptr, ptr %c.addr, align 8
  %Floats54 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call55 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats54, i64 noundef 1)
  %call56 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN4llvh7APFloataSERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %call55, ptr noundef nonnull align 8 dereferenceable(32) %38)
  %Floats57 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call58 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats57, i64 noundef 1)
  %39 = load i32, ptr %RM.addr, align 4
  %call59 = call noundef i32 @_ZN4llvh7APFloat8subtractERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %call58, ptr noundef nonnull align 8 dereferenceable(32) %z, i32 noundef %39)
  %40 = load i32, ptr %Status, align 4
  %or60 = or i32 %40, %call59
  store i32 %or60, ptr %Status, align 4
  %Floats61 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call62 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats61, i64 noundef 1)
  %41 = load ptr, ptr %a.addr, align 8
  %42 = load i32, ptr %RM.addr, align 4
  %call63 = call noundef i32 @_ZN4llvh7APFloat3addERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %call62, ptr noundef nonnull align 8 dereferenceable(32) %41, i32 noundef %42)
  %43 = load i32, ptr %Status, align 4
  %or64 = or i32 %43, %call63
  store i32 %or64, ptr %Status, align 4
  %Floats65 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call66 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats65, i64 noundef 1)
  %44 = load i32, ptr %RM.addr, align 4
  %call67 = call noundef i32 @_ZN4llvh7APFloat3addERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %call66, ptr noundef nonnull align 8 dereferenceable(32) %zz, i32 noundef %44)
  %45 = load i32, ptr %Status, align 4
  %or68 = or i32 %45, %call67
  store i32 %or68, ptr %Status, align 4
  br label %if.end69

if.end69:                                         ; preds = %if.else53, %if.then37
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %zz) #10
  br label %if.end123

if.else70:                                        ; preds = %entry
  %46 = load ptr, ptr %a.addr, align 8
  call void @_ZN4llvh7APFloatC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %q, ptr noundef nonnull align 8 dereferenceable(32) %46)
  %47 = load i32, ptr %RM.addr, align 4
  %call71 = call noundef i32 @_ZN4llvh7APFloat8subtractERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %q, ptr noundef nonnull align 8 dereferenceable(32) %z, i32 noundef %47)
  %48 = load i32, ptr %Status, align 4
  %or72 = or i32 %48, %call71
  store i32 %or72, ptr %Status, align 4
  call void @_ZN4llvh7APFloatC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %zz73, ptr noundef nonnull align 8 dereferenceable(32) %q)
  %49 = load ptr, ptr %c.addr, align 8
  %50 = load i32, ptr %RM.addr, align 4
  %call74 = call noundef i32 @_ZN4llvh7APFloat3addERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %zz73, ptr noundef nonnull align 8 dereferenceable(32) %49, i32 noundef %50)
  %51 = load i32, ptr %Status, align 4
  %or75 = or i32 %51, %call74
  store i32 %or75, ptr %Status, align 4
  %52 = load i32, ptr %RM.addr, align 4
  %call76 = call noundef i32 @_ZN4llvh7APFloat3addERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %q, ptr noundef nonnull align 8 dereferenceable(32) %z, i32 noundef %52)
  %53 = load i32, ptr %Status, align 4
  %or77 = or i32 %53, %call76
  store i32 %or77, ptr %Status, align 4
  %54 = load ptr, ptr %a.addr, align 8
  %55 = load i32, ptr %RM.addr, align 4
  %call78 = call noundef i32 @_ZN4llvh7APFloat8subtractERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %q, ptr noundef nonnull align 8 dereferenceable(32) %54, i32 noundef %55)
  %56 = load i32, ptr %Status, align 4
  %or79 = or i32 %56, %call78
  store i32 %or79, ptr %Status, align 4
  call void @_ZN4llvh7APFloat10changeSignEv(ptr noundef nonnull align 8 dereferenceable(32) %q)
  %57 = load i32, ptr %RM.addr, align 4
  %call80 = call noundef i32 @_ZN4llvh7APFloat3addERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %zz73, ptr noundef nonnull align 8 dereferenceable(32) %q, i32 noundef %57)
  %58 = load i32, ptr %Status, align 4
  %or81 = or i32 %58, %call80
  store i32 %or81, ptr %Status, align 4
  %59 = load ptr, ptr %aa.addr, align 8
  %60 = load i32, ptr %RM.addr, align 4
  %call82 = call noundef i32 @_ZN4llvh7APFloat3addERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %zz73, ptr noundef nonnull align 8 dereferenceable(32) %59, i32 noundef %60)
  %61 = load i32, ptr %Status, align 4
  %or83 = or i32 %61, %call82
  store i32 %or83, ptr %Status, align 4
  %62 = load ptr, ptr %cc.addr, align 8
  %63 = load i32, ptr %RM.addr, align 4
  %call84 = call noundef i32 @_ZN4llvh7APFloat3addERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %zz73, ptr noundef nonnull align 8 dereferenceable(32) %62, i32 noundef %63)
  %64 = load i32, ptr %Status, align 4
  %or85 = or i32 %64, %call84
  store i32 %or85, ptr %Status, align 4
  %call86 = call noundef zeroext i1 @_ZNK4llvh7APFloat6isZeroEv(ptr noundef nonnull align 8 dereferenceable(32) %zz73)
  br i1 %call86, label %land.lhs.true, label %if.end94

land.lhs.true:                                    ; preds = %if.else70
  %call87 = call noundef zeroext i1 @_ZNK4llvh7APFloat10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(32) %zz73)
  br i1 %call87, label %if.end94, label %if.then88

if.then88:                                        ; preds = %land.lhs.true
  %Floats89 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call90 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats89, i64 noundef 0)
  %call91 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN4llvh7APFloataSEOS0_(ptr noundef nonnull align 8 dereferenceable(32) %call90, ptr noundef nonnull align 8 dereferenceable(32) %z)
  %Floats92 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call93 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats92, i64 noundef 1)
  call void @_ZN4llvh7APFloat8makeZeroEb(ptr noundef nonnull align 8 dereferenceable(32) %call93, i1 noundef zeroext false)
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end94:                                         ; preds = %land.lhs.true, %if.else70
  %Floats95 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call96 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats95, i64 noundef 0)
  %call97 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN4llvh7APFloataSERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %call96, ptr noundef nonnull align 8 dereferenceable(32) %z)
  %Floats98 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call99 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats98, i64 noundef 0)
  %65 = load i32, ptr %RM.addr, align 4
  %call100 = call noundef i32 @_ZN4llvh7APFloat3addERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %call99, ptr noundef nonnull align 8 dereferenceable(32) %zz73, i32 noundef %65)
  %66 = load i32, ptr %Status, align 4
  %or101 = or i32 %66, %call100
  store i32 %or101, ptr %Status, align 4
  %Floats102 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call103 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats102, i64 noundef 0)
  %call104 = call noundef zeroext i1 @_ZNK4llvh7APFloat8isFiniteEv(ptr noundef nonnull align 8 dereferenceable(32) %call103)
  br i1 %call104, label %if.end108, label %if.then105

if.then105:                                       ; preds = %if.end94
  %Floats106 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call107 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats106, i64 noundef 1)
  call void @_ZN4llvh7APFloat8makeZeroEb(ptr noundef nonnull align 8 dereferenceable(32) %call107, i1 noundef zeroext false)
  %67 = load i32, ptr %Status, align 4
  store i32 %67, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end108:                                        ; preds = %if.end94
  %Floats109 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call110 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats109, i64 noundef 1)
  %call111 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN4llvh7APFloataSEOS0_(ptr noundef nonnull align 8 dereferenceable(32) %call110, ptr noundef nonnull align 8 dereferenceable(32) %z)
  %Floats112 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call113 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats112, i64 noundef 1)
  %Floats114 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call115 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats114, i64 noundef 0)
  %68 = load i32, ptr %RM.addr, align 4
  %call116 = call noundef i32 @_ZN4llvh7APFloat8subtractERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %call113, ptr noundef nonnull align 8 dereferenceable(32) %call115, i32 noundef %68)
  %69 = load i32, ptr %Status, align 4
  %or117 = or i32 %69, %call116
  store i32 %or117, ptr %Status, align 4
  %Floats118 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call119 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats118, i64 noundef 1)
  %70 = load i32, ptr %RM.addr, align 4
  %call120 = call noundef i32 @_ZN4llvh7APFloat3addERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %call119, ptr noundef nonnull align 8 dereferenceable(32) %zz73, i32 noundef %70)
  %71 = load i32, ptr %Status, align 4
  %or121 = or i32 %71, %call120
  store i32 %or121, ptr %Status, align 4
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end108, %if.then105, %if.then88
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %zz73) #10
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %q) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup124 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %if.end123

if.end123:                                        ; preds = %cleanup.cont, %if.end69
  %72 = load i32, ptr %Status, align 4
  store i32 %72, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup124

cleanup124:                                       ; preds = %if.end123, %cleanup, %if.then24, %if.then4
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %z) #10
  %73 = load i32, ptr %retval, align 4
  ret i32 %73
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZN4llvh7APFloat3addERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(32) %RHS, i32 noundef %RM) #1 comdat align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  %RM.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  store i32 %RM, ptr %RM.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %RHS.addr, align 8
  %U3 = getelementptr inbounds %"class.llvh::APFloat", ptr %0, i32 0, i32 1
  %1 = load i32, ptr %RM.addr, align 4
  %call4 = call noundef i32 @_ZN4llvh6detail9IEEEFloat3addERKS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef nonnull align 8 dereferenceable(24) %U3, i32 noundef %1)
  store i32 %call4, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %call5 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call6 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call5)
  br i1 %call6, label %if.then7, label %if.end11

if.then7:                                         ; preds = %if.end
  %U8 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %RHS.addr, align 8
  %U9 = getelementptr inbounds %"class.llvh::APFloat", ptr %2, i32 0, i32 1
  %3 = load i32, ptr %RM.addr, align 4
  %call10 = call noundef i32 @_ZN4llvh6detail13DoubleAPFloat3addERKS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %U8, ptr noundef nonnull align 8 dereferenceable(16) %U9, i32 noundef %3)
  store i32 %call10, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end
  unreachable

return:                                           ; preds = %if.then7, %if.then
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh7APFloat8isFiniteEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh7APFloat5isNaNEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  br i1 %call, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %call2 = call noundef zeroext i1 @_ZNK4llvh7APFloat10isInfinityEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %lnot = xor i1 %call2, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %0 = phi i1 [ false, %entry ], [ %lnot, %land.rhs ]
  ret i1 %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh7APFloat10isInfinityEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK4llvh7APFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %cmp = icmp eq i32 %call, 0
  ret i1 %cmp
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh7APFloat8makeZeroEb(ptr noundef nonnull align 8 dereferenceable(32) %this, i1 noundef zeroext %Neg) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Neg.addr = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %Neg to i8
  store i8 %frombool, ptr %Neg.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load i8, ptr %Neg.addr, align 1
  %tobool = trunc i8 %0 to i1
  call void @_ZN4llvh6detail9IEEEFloat8makeZeroEb(ptr noundef nonnull align 8 dereferenceable(24) %U, i1 noundef zeroext %tobool)
  br label %do.end

if.end:                                           ; preds = %do.body
  %call3 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call4 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call3)
  br i1 %call4, label %if.then5, label %if.end8

if.then5:                                         ; preds = %if.end
  %U6 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %1 = load i8, ptr %Neg.addr, align 1
  %tobool7 = trunc i8 %1 to i1
  call void @_ZN4llvh6detail13DoubleAPFloat8makeZeroEb(ptr noundef nonnull align 8 dereferenceable(16) %U6, i1 noundef zeroext %tobool7)
  br label %do.end

if.end8:                                          ; preds = %if.end
  unreachable

do.end:                                           ; preds = %if.then5, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZNK4llvh7APFloat20compareAbsoluteValueERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(32) %RHS) #1 comdat align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %RHS.addr, align 8
  %U3 = getelementptr inbounds %"class.llvh::APFloat", ptr %0, i32 0, i32 1
  %call4 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat20compareAbsoluteValueERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef nonnull align 8 dereferenceable(24) %U3)
  store i32 %call4, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %call5 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call6 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call5)
  br i1 %call6, label %if.then7, label %if.end11

if.then7:                                         ; preds = %if.end
  %U8 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %RHS.addr, align 8
  %U9 = getelementptr inbounds %"class.llvh::APFloat", ptr %1, i32 0, i32 1
  %call10 = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat20compareAbsoluteValueERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %U8, ptr noundef nonnull align 8 dereferenceable(16) %U9)
  store i32 %call10, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end
  unreachable

return:                                           ; preds = %if.then7, %if.then
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZN4llvh7APFloat8subtractERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(32) %RHS, i32 noundef %RM) #1 comdat align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  %RM.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  store i32 %RM, ptr %RM.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %RHS.addr, align 8
  %U3 = getelementptr inbounds %"class.llvh::APFloat", ptr %0, i32 0, i32 1
  %1 = load i32, ptr %RM.addr, align 4
  %call4 = call noundef i32 @_ZN4llvh6detail9IEEEFloat8subtractERKS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef nonnull align 8 dereferenceable(24) %U3, i32 noundef %1)
  store i32 %call4, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %call5 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call6 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call5)
  br i1 %call6, label %if.then7, label %if.end11

if.then7:                                         ; preds = %if.end
  %U8 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %RHS.addr, align 8
  %U9 = getelementptr inbounds %"class.llvh::APFloat", ptr %2, i32 0, i32 1
  %3 = load i32, ptr %RM.addr, align 4
  %call10 = call noundef i32 @_ZN4llvh6detail13DoubleAPFloat8subtractERKS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %U8, ptr noundef nonnull align 8 dereferenceable(16) %U9, i32 noundef %3)
  store i32 %call10, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end
  unreachable

return:                                           ; preds = %if.then7, %if.then
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh7APFloat10changeSignEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  call void @_ZN4llvh6detail9IEEEFloat10changeSignEv(ptr noundef nonnull align 8 dereferenceable(24) %U)
  br label %do.end

if.end:                                           ; preds = %do.body
  %call3 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call4 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call3)
  br i1 %call4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %U6 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  call void @_ZN4llvh6detail13DoubleAPFloat10changeSignEv(ptr noundef nonnull align 8 dereferenceable(16) %U6)
  br label %do.end

if.end7:                                          ; preds = %if.end
  unreachable

do.end:                                           ; preds = %if.then5, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh7APFloat6isZeroEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK4llvh7APFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %cmp = icmp eq i32 %call, 3
  ret i1 %cmp
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh7APFloat10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(24) ptr @_ZNK4llvh7APFloat7getIEEEEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(24) %call)
  ret i1 %call2
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail13DoubleAPFloat14addWithSpecialERKS1_S3_RS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %LHS, ptr noundef nonnull align 8 dereferenceable(16) %RHS, ptr noundef nonnull align 8 dereferenceable(16) %Out, i32 noundef %RM) #1 align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %LHS.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  %Out.addr = alloca ptr, align 8
  %RM.addr = alloca i32, align 4
  %A = alloca %"class.llvh::APFloat", align 8
  %AA = alloca %"class.llvh::APFloat", align 8
  %C = alloca %"class.llvh::APFloat", align 8
  %CC = alloca %"class.llvh::APFloat", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %LHS, ptr %LHS.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  store ptr %Out, ptr %Out.addr, align 8
  store i32 %RM, ptr %RM.addr, align 4
  %0 = load ptr, ptr %LHS.addr, align 8
  %call = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(16) %0)
  %cmp = icmp eq i32 %call, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %LHS.addr, align 8
  %2 = load ptr, ptr %Out.addr, align 8
  %call2 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN4llvh6detail13DoubleAPFloataSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %2, ptr noundef nonnull align 8 dereferenceable(16) %1)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %RHS.addr, align 8
  %call3 = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(16) %3)
  %cmp4 = icmp eq i32 %call3, 1
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %4 = load ptr, ptr %RHS.addr, align 8
  %5 = load ptr, ptr %Out.addr, align 8
  %call6 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN4llvh6detail13DoubleAPFloataSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %5, ptr noundef nonnull align 8 dereferenceable(16) %4)
  store i32 0, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  %6 = load ptr, ptr %LHS.addr, align 8
  %call8 = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(16) %6)
  %cmp9 = icmp eq i32 %call8, 3
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end7
  %7 = load ptr, ptr %RHS.addr, align 8
  %8 = load ptr, ptr %Out.addr, align 8
  %call11 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN4llvh6detail13DoubleAPFloataSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %8, ptr noundef nonnull align 8 dereferenceable(16) %7)
  store i32 0, ptr %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end7
  %9 = load ptr, ptr %RHS.addr, align 8
  %call13 = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(16) %9)
  %cmp14 = icmp eq i32 %call13, 3
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end12
  %10 = load ptr, ptr %LHS.addr, align 8
  %11 = load ptr, ptr %Out.addr, align 8
  %call16 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN4llvh6detail13DoubleAPFloataSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %11, ptr noundef nonnull align 8 dereferenceable(16) %10)
  store i32 0, ptr %retval, align 4
  br label %return

if.end17:                                         ; preds = %if.end12
  %12 = load ptr, ptr %LHS.addr, align 8
  %call18 = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(16) %12)
  %cmp19 = icmp eq i32 %call18, 0
  br i1 %cmp19, label %land.lhs.true, label %if.end29

land.lhs.true:                                    ; preds = %if.end17
  %13 = load ptr, ptr %RHS.addr, align 8
  %call20 = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(16) %13)
  %cmp21 = icmp eq i32 %call20, 0
  br i1 %cmp21, label %land.lhs.true22, label %if.end29

land.lhs.true22:                                  ; preds = %land.lhs.true
  %14 = load ptr, ptr %LHS.addr, align 8
  %call23 = call noundef zeroext i1 @_ZNK4llvh6detail13DoubleAPFloat10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(16) %14)
  %conv = zext i1 %call23 to i32
  %15 = load ptr, ptr %RHS.addr, align 8
  %call24 = call noundef zeroext i1 @_ZNK4llvh6detail13DoubleAPFloat10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(16) %15)
  %conv25 = zext i1 %call24 to i32
  %cmp26 = icmp ne i32 %conv, %conv25
  br i1 %cmp26, label %if.then27, label %if.end29

if.then27:                                        ; preds = %land.lhs.true22
  %16 = load ptr, ptr %Out.addr, align 8
  %17 = load ptr, ptr %Out.addr, align 8
  %call28 = call noundef zeroext i1 @_ZNK4llvh6detail13DoubleAPFloat10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(16) %17)
  call void @_ZN4llvh6detail13DoubleAPFloat7makeNaNEbbPKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(16) %16, i1 noundef zeroext false, i1 noundef zeroext %call28, ptr noundef null)
  store i32 1, ptr %retval, align 4
  br label %return

if.end29:                                         ; preds = %land.lhs.true22, %land.lhs.true, %if.end17
  %18 = load ptr, ptr %LHS.addr, align 8
  %call30 = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(16) %18)
  %cmp31 = icmp eq i32 %call30, 0
  br i1 %cmp31, label %if.then32, label %if.end34

if.then32:                                        ; preds = %if.end29
  %19 = load ptr, ptr %LHS.addr, align 8
  %20 = load ptr, ptr %Out.addr, align 8
  %call33 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN4llvh6detail13DoubleAPFloataSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %20, ptr noundef nonnull align 8 dereferenceable(16) %19)
  store i32 0, ptr %retval, align 4
  br label %return

if.end34:                                         ; preds = %if.end29
  %21 = load ptr, ptr %RHS.addr, align 8
  %call35 = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(16) %21)
  %cmp36 = icmp eq i32 %call35, 0
  br i1 %cmp36, label %if.then37, label %if.end39

if.then37:                                        ; preds = %if.end34
  %22 = load ptr, ptr %RHS.addr, align 8
  %23 = load ptr, ptr %Out.addr, align 8
  %call38 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN4llvh6detail13DoubleAPFloataSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %23, ptr noundef nonnull align 8 dereferenceable(16) %22)
  store i32 0, ptr %retval, align 4
  br label %return

if.end39:                                         ; preds = %if.end34
  %24 = load ptr, ptr %LHS.addr, align 8
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %24, i32 0, i32 1
  %call40 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats, i64 noundef 0)
  call void @_ZN4llvh7APFloatC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %A, ptr noundef nonnull align 8 dereferenceable(32) %call40)
  %25 = load ptr, ptr %LHS.addr, align 8
  %Floats41 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %25, i32 0, i32 1
  %call42 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats41, i64 noundef 1)
  call void @_ZN4llvh7APFloatC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %AA, ptr noundef nonnull align 8 dereferenceable(32) %call42)
  %26 = load ptr, ptr %RHS.addr, align 8
  %Floats43 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %26, i32 0, i32 1
  %call44 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats43, i64 noundef 0)
  call void @_ZN4llvh7APFloatC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %C, ptr noundef nonnull align 8 dereferenceable(32) %call44)
  %27 = load ptr, ptr %RHS.addr, align 8
  %Floats45 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %27, i32 0, i32 1
  %call46 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats45, i64 noundef 1)
  call void @_ZN4llvh7APFloatC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %CC, ptr noundef nonnull align 8 dereferenceable(32) %call46)
  %28 = load ptr, ptr %Out.addr, align 8
  %29 = load i32, ptr %RM.addr, align 4
  %call47 = call noundef i32 @_ZN4llvh6detail13DoubleAPFloat7addImplERKNS_7APFloatES4_S4_S4_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %28, ptr noundef nonnull align 8 dereferenceable(32) %A, ptr noundef nonnull align 8 dereferenceable(32) %AA, ptr noundef nonnull align 8 dereferenceable(32) %C, ptr noundef nonnull align 8 dereferenceable(32) %CC, i32 noundef %29)
  store i32 %call47, ptr %retval, align 4
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %CC) #10
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %C) #10
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %AA) #10
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %A) #10
  br label %return

return:                                           ; preds = %if.end39, %if.then37, %if.then32, %if.then27, %if.then15, %if.then10, %if.then5, %if.then
  %30 = load i32, ptr %retval, align 4
  ret i32 %30
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZNK4llvh6detail13DoubleAPFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats, i64 noundef 0)
  %call2 = call noundef i32 @_ZNK4llvh7APFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(32) %call)
  ret i32 %call2
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef zeroext i1 @_ZNK4llvh6detail13DoubleAPFloat10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats, i64 noundef 0)
  %call2 = call noundef zeroext i1 @_ZNK4llvh7APFloat10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(32) %call)
  ret i1 %call2
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail13DoubleAPFloat7makeNaNEbbPKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(16) %this, i1 noundef zeroext %SNaN, i1 noundef zeroext %Neg, ptr noundef %fill) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %SNaN.addr = alloca i8, align 1
  %Neg.addr = alloca i8, align 1
  %fill.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %SNaN to i8
  store i8 %frombool, ptr %SNaN.addr, align 1
  %frombool1 = zext i1 %Neg to i8
  store i8 %frombool1, ptr %Neg.addr, align 1
  store ptr %fill, ptr %fill.addr, align 8
  %this2 = load ptr, ptr %this.addr, align 8
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this2, i32 0, i32 1
  %call = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats, i64 noundef 0)
  %0 = load i8, ptr %SNaN.addr, align 1
  %tobool = trunc i8 %0 to i1
  %1 = load i8, ptr %Neg.addr, align 1
  %tobool3 = trunc i8 %1 to i1
  %2 = load ptr, ptr %fill.addr, align 8
  call void @_ZN4llvh7APFloat7makeNaNEbbPKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %call, i1 noundef zeroext %tobool, i1 noundef zeroext %tobool3, ptr noundef %2)
  %Floats4 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this2, i32 0, i32 1
  %call5 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats4, i64 noundef 1)
  call void @_ZN4llvh7APFloat8makeZeroEb(ptr noundef nonnull align 8 dereferenceable(32) %call5, i1 noundef zeroext false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail13DoubleAPFloat3addERKS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %RHS, i32 noundef %RM) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  %RM.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  store i32 %RM, ptr %RM.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %RHS.addr, align 8
  %1 = load i32, ptr %RM.addr, align 4
  %call = call noundef i32 @_ZN4llvh6detail13DoubleAPFloat14addWithSpecialERKS1_S3_RS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %0, ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %1)
  ret i32 %call
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail13DoubleAPFloat8subtractERKS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %RHS, i32 noundef %RM) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  %RM.addr = alloca i32, align 4
  %Ret = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  store i32 %RM, ptr %RM.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4llvh6detail13DoubleAPFloat10changeSignEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %0 = load ptr, ptr %RHS.addr, align 8
  %1 = load i32, ptr %RM.addr, align 4
  %call = call noundef i32 @_ZN4llvh6detail13DoubleAPFloat3addERKS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %0, i32 noundef %1)
  store i32 %call, ptr %Ret, align 4
  call void @_ZN4llvh6detail13DoubleAPFloat10changeSignEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %2 = load i32, ptr %Ret, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail13DoubleAPFloat10changeSignEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats, i64 noundef 0)
  call void @_ZN4llvh7APFloat10changeSignEv(ptr noundef nonnull align 8 dereferenceable(32) %call)
  %Floats2 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call3 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats2, i64 noundef 1)
  call void @_ZN4llvh7APFloat10changeSignEv(ptr noundef nonnull align 8 dereferenceable(32) %call3)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail13DoubleAPFloat8multiplyERKS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %RHS, i32 noundef %RM) #1 align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  %RM.addr = alloca i32, align 4
  %LHS = alloca ptr, align 8
  %Out = alloca ptr, align 8
  %Status = alloca i32, align 4
  %A = alloca %"class.llvh::APFloat", align 8
  %B = alloca %"class.llvh::APFloat", align 8
  %C = alloca %"class.llvh::APFloat", align 8
  %D = alloca %"class.llvh::APFloat", align 8
  %T = alloca %"class.llvh::APFloat", align 8
  %cleanup.dest.slot = alloca i32, align 4
  %Tau = alloca %"class.llvh::APFloat", align 8
  %V = alloca %"class.llvh::APFloat", align 8
  %W = alloca %"class.llvh::APFloat", align 8
  %U = alloca %"class.llvh::APFloat", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  store i32 %RM, ptr %RM.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  store ptr %this1, ptr %LHS, align 8
  store ptr %this1, ptr %Out, align 8
  %0 = load ptr, ptr %LHS, align 8
  %call = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(16) %0)
  %cmp = icmp eq i32 %call, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %LHS, align 8
  %2 = load ptr, ptr %Out, align 8
  %call2 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN4llvh6detail13DoubleAPFloataSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %2, ptr noundef nonnull align 8 dereferenceable(16) %1)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %RHS.addr, align 8
  %call3 = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(16) %3)
  %cmp4 = icmp eq i32 %call3, 1
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %4 = load ptr, ptr %RHS.addr, align 8
  %5 = load ptr, ptr %Out, align 8
  %call6 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN4llvh6detail13DoubleAPFloataSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %5, ptr noundef nonnull align 8 dereferenceable(16) %4)
  store i32 0, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  %6 = load ptr, ptr %LHS, align 8
  %call8 = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(16) %6)
  %cmp9 = icmp eq i32 %call8, 3
  br i1 %cmp9, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %if.end7
  %7 = load ptr, ptr %RHS.addr, align 8
  %call10 = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(16) %7)
  %cmp11 = icmp eq i32 %call10, 0
  br i1 %cmp11, label %if.then17, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %if.end7
  %8 = load ptr, ptr %LHS, align 8
  %call12 = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(16) %8)
  %cmp13 = icmp eq i32 %call12, 0
  br i1 %cmp13, label %land.lhs.true14, label %if.end18

land.lhs.true14:                                  ; preds = %lor.lhs.false
  %9 = load ptr, ptr %RHS.addr, align 8
  %call15 = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(16) %9)
  %cmp16 = icmp eq i32 %call15, 3
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %land.lhs.true14, %land.lhs.true
  %10 = load ptr, ptr %Out, align 8
  call void @_ZN4llvh6detail13DoubleAPFloat7makeNaNEbbPKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(16) %10, i1 noundef zeroext false, i1 noundef zeroext false, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %land.lhs.true14, %lor.lhs.false
  %11 = load ptr, ptr %LHS, align 8
  %call19 = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(16) %11)
  %cmp20 = icmp eq i32 %call19, 3
  br i1 %cmp20, label %if.then24, label %lor.lhs.false21

lor.lhs.false21:                                  ; preds = %if.end18
  %12 = load ptr, ptr %LHS, align 8
  %call22 = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(16) %12)
  %cmp23 = icmp eq i32 %call22, 0
  br i1 %cmp23, label %if.then24, label %if.end26

if.then24:                                        ; preds = %lor.lhs.false21, %if.end18
  %13 = load ptr, ptr %LHS, align 8
  %14 = load ptr, ptr %Out, align 8
  %call25 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN4llvh6detail13DoubleAPFloataSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %14, ptr noundef nonnull align 8 dereferenceable(16) %13)
  store i32 0, ptr %retval, align 4
  br label %return

if.end26:                                         ; preds = %lor.lhs.false21
  %15 = load ptr, ptr %RHS.addr, align 8
  %call27 = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(16) %15)
  %cmp28 = icmp eq i32 %call27, 3
  br i1 %cmp28, label %if.then32, label %lor.lhs.false29

lor.lhs.false29:                                  ; preds = %if.end26
  %16 = load ptr, ptr %RHS.addr, align 8
  %call30 = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(16) %16)
  %cmp31 = icmp eq i32 %call30, 0
  br i1 %cmp31, label %if.then32, label %if.end34

if.then32:                                        ; preds = %lor.lhs.false29, %if.end26
  %17 = load ptr, ptr %RHS.addr, align 8
  %18 = load ptr, ptr %Out, align 8
  %call33 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN4llvh6detail13DoubleAPFloataSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %18, ptr noundef nonnull align 8 dereferenceable(16) %17)
  store i32 0, ptr %retval, align 4
  br label %return

if.end34:                                         ; preds = %lor.lhs.false29
  store i32 0, ptr %Status, align 4
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call35 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats, i64 noundef 0)
  call void @_ZN4llvh7APFloatC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %A, ptr noundef nonnull align 8 dereferenceable(32) %call35)
  %Floats36 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call37 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats36, i64 noundef 1)
  call void @_ZN4llvh7APFloatC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %B, ptr noundef nonnull align 8 dereferenceable(32) %call37)
  %19 = load ptr, ptr %RHS.addr, align 8
  %Floats38 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %19, i32 0, i32 1
  %call39 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats38, i64 noundef 0)
  call void @_ZN4llvh7APFloatC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %C, ptr noundef nonnull align 8 dereferenceable(32) %call39)
  %20 = load ptr, ptr %RHS.addr, align 8
  %Floats40 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %20, i32 0, i32 1
  %call41 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats40, i64 noundef 1)
  call void @_ZN4llvh7APFloatC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %D, ptr noundef nonnull align 8 dereferenceable(32) %call41)
  call void @_ZN4llvh7APFloatC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %T, ptr noundef nonnull align 8 dereferenceable(32) %A)
  %21 = load i32, ptr %RM.addr, align 4
  %call42 = call noundef i32 @_ZN4llvh7APFloat8multiplyERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %T, ptr noundef nonnull align 8 dereferenceable(32) %C, i32 noundef %21)
  %22 = load i32, ptr %Status, align 4
  %or = or i32 %22, %call42
  store i32 %or, ptr %Status, align 4
  %call43 = call noundef zeroext i1 @_ZNK4llvh7APFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(32) %T)
  br i1 %call43, label %if.end50, label %if.then44

if.then44:                                        ; preds = %if.end34
  %Floats45 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call46 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats45, i64 noundef 0)
  %call47 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN4llvh7APFloataSERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %call46, ptr noundef nonnull align 8 dereferenceable(32) %T)
  %Floats48 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call49 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats48, i64 noundef 1)
  call void @_ZN4llvh7APFloat8makeZeroEb(ptr noundef nonnull align 8 dereferenceable(32) %call49, i1 noundef zeroext false)
  %23 = load i32, ptr %Status, align 4
  store i32 %23, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end50:                                         ; preds = %if.end34
  call void @_ZN4llvh7APFloatC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %Tau, ptr noundef nonnull align 8 dereferenceable(32) %A)
  call void @_ZN4llvh7APFloat10changeSignEv(ptr noundef nonnull align 8 dereferenceable(32) %T)
  %24 = load i32, ptr %RM.addr, align 4
  %call51 = call noundef i32 @_ZN4llvh7APFloat16fusedMultiplyAddERKS0_S2_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %Tau, ptr noundef nonnull align 8 dereferenceable(32) %C, ptr noundef nonnull align 8 dereferenceable(32) %T, i32 noundef %24)
  %25 = load i32, ptr %Status, align 4
  %or52 = or i32 %25, %call51
  store i32 %or52, ptr %Status, align 4
  call void @_ZN4llvh7APFloat10changeSignEv(ptr noundef nonnull align 8 dereferenceable(32) %T)
  call void @_ZN4llvh7APFloatC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %V, ptr noundef nonnull align 8 dereferenceable(32) %A)
  %26 = load i32, ptr %RM.addr, align 4
  %call53 = call noundef i32 @_ZN4llvh7APFloat8multiplyERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %V, ptr noundef nonnull align 8 dereferenceable(32) %D, i32 noundef %26)
  %27 = load i32, ptr %Status, align 4
  %or54 = or i32 %27, %call53
  store i32 %or54, ptr %Status, align 4
  call void @_ZN4llvh7APFloatC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %W, ptr noundef nonnull align 8 dereferenceable(32) %B)
  %28 = load i32, ptr %RM.addr, align 4
  %call55 = call noundef i32 @_ZN4llvh7APFloat8multiplyERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %W, ptr noundef nonnull align 8 dereferenceable(32) %C, i32 noundef %28)
  %29 = load i32, ptr %Status, align 4
  %or56 = or i32 %29, %call55
  store i32 %or56, ptr %Status, align 4
  %30 = load i32, ptr %RM.addr, align 4
  %call57 = call noundef i32 @_ZN4llvh7APFloat3addERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %V, ptr noundef nonnull align 8 dereferenceable(32) %W, i32 noundef %30)
  %31 = load i32, ptr %Status, align 4
  %or58 = or i32 %31, %call57
  store i32 %or58, ptr %Status, align 4
  %32 = load i32, ptr %RM.addr, align 4
  %call59 = call noundef i32 @_ZN4llvh7APFloat3addERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %Tau, ptr noundef nonnull align 8 dereferenceable(32) %V, i32 noundef %32)
  %33 = load i32, ptr %Status, align 4
  %or60 = or i32 %33, %call59
  store i32 %or60, ptr %Status, align 4
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %W) #10
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %V) #10
  call void @_ZN4llvh7APFloatC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %U, ptr noundef nonnull align 8 dereferenceable(32) %T)
  %34 = load i32, ptr %RM.addr, align 4
  %call61 = call noundef i32 @_ZN4llvh7APFloat3addERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %U, ptr noundef nonnull align 8 dereferenceable(32) %Tau, i32 noundef %34)
  %35 = load i32, ptr %Status, align 4
  %or62 = or i32 %35, %call61
  store i32 %or62, ptr %Status, align 4
  %Floats63 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call64 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats63, i64 noundef 0)
  %call65 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN4llvh7APFloataSERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %call64, ptr noundef nonnull align 8 dereferenceable(32) %U)
  %call66 = call noundef zeroext i1 @_ZNK4llvh7APFloat8isFiniteEv(ptr noundef nonnull align 8 dereferenceable(32) %U)
  br i1 %call66, label %if.else, label %if.then67

if.then67:                                        ; preds = %if.end50
  %Floats68 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call69 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats68, i64 noundef 1)
  call void @_ZN4llvh7APFloat8makeZeroEb(ptr noundef nonnull align 8 dereferenceable(32) %call69, i1 noundef zeroext false)
  br label %if.end77

if.else:                                          ; preds = %if.end50
  %36 = load i32, ptr %RM.addr, align 4
  %call70 = call noundef i32 @_ZN4llvh7APFloat8subtractERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %T, ptr noundef nonnull align 8 dereferenceable(32) %U, i32 noundef %36)
  %37 = load i32, ptr %Status, align 4
  %or71 = or i32 %37, %call70
  store i32 %or71, ptr %Status, align 4
  %38 = load i32, ptr %RM.addr, align 4
  %call72 = call noundef i32 @_ZN4llvh7APFloat3addERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %T, ptr noundef nonnull align 8 dereferenceable(32) %Tau, i32 noundef %38)
  %39 = load i32, ptr %Status, align 4
  %or73 = or i32 %39, %call72
  store i32 %or73, ptr %Status, align 4
  %Floats74 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call75 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats74, i64 noundef 1)
  %call76 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN4llvh7APFloataSERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %call75, ptr noundef nonnull align 8 dereferenceable(32) %T)
  br label %if.end77

if.end77:                                         ; preds = %if.else, %if.then67
  %40 = load i32, ptr %Status, align 4
  store i32 %40, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %U) #10
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %Tau) #10
  br label %cleanup

cleanup:                                          ; preds = %if.end77, %if.then44
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %T) #10
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %D) #10
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %C) #10
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %B) #10
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %A) #10
  br label %return

return:                                           ; preds = %cleanup, %if.then32, %if.then24, %if.then17, %if.then5, %if.then
  %41 = load i32, ptr %retval, align 4
  ret i32 %41
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZN4llvh7APFloat8multiplyERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(32) %RHS, i32 noundef %RM) #1 comdat align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  %RM.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  store i32 %RM, ptr %RM.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %RHS.addr, align 8
  %U3 = getelementptr inbounds %"class.llvh::APFloat", ptr %0, i32 0, i32 1
  %1 = load i32, ptr %RM.addr, align 4
  %call4 = call noundef i32 @_ZN4llvh6detail9IEEEFloat8multiplyERKS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef nonnull align 8 dereferenceable(24) %U3, i32 noundef %1)
  store i32 %call4, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %call5 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call6 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call5)
  br i1 %call6, label %if.then7, label %if.end11

if.then7:                                         ; preds = %if.end
  %U8 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %RHS.addr, align 8
  %U9 = getelementptr inbounds %"class.llvh::APFloat", ptr %2, i32 0, i32 1
  %3 = load i32, ptr %RM.addr, align 4
  %call10 = call noundef i32 @_ZN4llvh6detail13DoubleAPFloat8multiplyERKS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %U8, ptr noundef nonnull align 8 dereferenceable(16) %U9, i32 noundef %3)
  store i32 %call10, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end
  unreachable

return:                                           ; preds = %if.then7, %if.then
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh7APFloat15isFiniteNonZeroEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh7APFloat8isFiniteEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  br i1 %call, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %call2 = call noundef zeroext i1 @_ZNK4llvh7APFloat6isZeroEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %lnot = xor i1 %call2, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %0 = phi i1 [ false, %entry ], [ %lnot, %land.rhs ]
  ret i1 %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZN4llvh7APFloat16fusedMultiplyAddERKS0_S2_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(32) %Multiplicand, ptr noundef nonnull align 8 dereferenceable(32) %Addend, i32 noundef %RM) #1 comdat align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %Multiplicand.addr = alloca ptr, align 8
  %Addend.addr = alloca ptr, align 8
  %RM.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %Multiplicand, ptr %Multiplicand.addr, align 8
  store ptr %Addend, ptr %Addend.addr, align 8
  store i32 %RM, ptr %RM.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %Multiplicand.addr, align 8
  %U3 = getelementptr inbounds %"class.llvh::APFloat", ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %Addend.addr, align 8
  %U4 = getelementptr inbounds %"class.llvh::APFloat", ptr %1, i32 0, i32 1
  %2 = load i32, ptr %RM.addr, align 4
  %call5 = call noundef i32 @_ZN4llvh6detail9IEEEFloat16fusedMultiplyAddERKS1_S3_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef nonnull align 8 dereferenceable(24) %U3, ptr noundef nonnull align 8 dereferenceable(24) %U4, i32 noundef %2)
  store i32 %call5, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %call6 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call7 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call6)
  br i1 %call7, label %if.then8, label %if.end13

if.then8:                                         ; preds = %if.end
  %U9 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %Multiplicand.addr, align 8
  %U10 = getelementptr inbounds %"class.llvh::APFloat", ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %Addend.addr, align 8
  %U11 = getelementptr inbounds %"class.llvh::APFloat", ptr %4, i32 0, i32 1
  %5 = load i32, ptr %RM.addr, align 4
  %call12 = call noundef i32 @_ZN4llvh6detail13DoubleAPFloat16fusedMultiplyAddERKS1_S3_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %U9, ptr noundef nonnull align 8 dereferenceable(16) %U10, ptr noundef nonnull align 8 dereferenceable(16) %U11, i32 noundef %5)
  store i32 %call12, ptr %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end
  unreachable

return:                                           ; preds = %if.then8, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail13DoubleAPFloat6divideERKS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %RHS, i32 noundef %RM) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  %RM.addr = alloca i32, align 4
  %Tmp = alloca %"class.llvh::APFloat", align 8
  %ref.tmp = alloca %"class.llvh::APInt", align 8
  %Ret = alloca i32, align 4
  %ref.tmp2 = alloca %"class.llvh::APFloat", align 8
  %ref.tmp3 = alloca %"class.llvh::APInt", align 8
  %ref.tmp4 = alloca %"class.llvh::detail::DoubleAPFloat", align 8
  %ref.tmp5 = alloca %"class.llvh::APInt", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  store i32 %RM, ptr %RM.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZNK4llvh6detail13DoubleAPFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp, ptr noundef nonnull align 8 dereferenceable(16) %this1)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %Tmp, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL24semPPCDoubleDoubleLegacyE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp) #10
  %0 = load ptr, ptr %RHS.addr, align 8
  call void @_ZNK4llvh6detail13DoubleAPFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp3, ptr noundef nonnull align 8 dereferenceable(16) %0)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp2, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL24semPPCDoubleDoubleLegacyE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp3)
  %1 = load i32, ptr %RM.addr, align 4
  %call = call noundef i32 @_ZN4llvh7APFloat6divideERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %Tmp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp2, i32 noundef %1)
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp2) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp3) #10
  store i32 %call, ptr %Ret, align 4
  call void @_ZNK4llvh7APFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp5, ptr noundef nonnull align 8 dereferenceable(32) %Tmp)
  call void @_ZN4llvh6detail13DoubleAPFloatC1ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp4, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL18semPPCDoubleDoubleE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp5)
  %call6 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN4llvh6detail13DoubleAPFloataSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp4)
  call void @_ZN4llvh6detail13DoubleAPFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp4) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp5) #10
  %2 = load i32, ptr %Ret, align 4
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %Tmp) #10
  ret i32 %2
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZNK4llvh6detail13DoubleAPFloat14bitcastToAPIntEv(ptr noalias sret(%"class.llvh::APInt") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(16) %this) #1 align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %Data = alloca [2 x i64], align 16
  %ref.tmp = alloca %"class.llvh::APInt", align 8
  %ref.tmp3 = alloca %"class.llvh::APInt", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %arrayinit.begin = getelementptr inbounds [2 x i64], ptr %Data, i64 0, i64 0
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats, i64 noundef 0)
  call void @_ZNK4llvh7APFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp, ptr noundef nonnull align 8 dereferenceable(32) %call)
  %call2 = call noundef ptr @_ZNK4llvh5APInt10getRawDataEv(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp)
  %arrayidx = getelementptr inbounds i64, ptr %call2, i64 0
  %0 = load i64, ptr %arrayidx, align 8
  store i64 %0, ptr %arrayinit.begin, align 8
  %arrayinit.element = getelementptr inbounds i64, ptr %arrayinit.begin, i64 1
  %Floats4 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call5 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats4, i64 noundef 1)
  call void @_ZNK4llvh7APFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp3, ptr noundef nonnull align 8 dereferenceable(32) %call5)
  %call6 = call noundef ptr @_ZNK4llvh5APInt10getRawDataEv(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp3)
  %arrayidx7 = getelementptr inbounds i64, ptr %call6, i64 0
  %1 = load i64, ptr %arrayidx7, align 8
  store i64 %1, ptr %arrayinit.element, align 8
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp3) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp) #10
  %arraydecay = getelementptr inbounds [2 x i64], ptr %Data, i64 0, i64 0
  call void @_ZN4llvh5APIntC1EjjPKm(ptr noundef nonnull align 8 dereferenceable(12) %agg.result, i32 noundef 128, i32 noundef 2, ptr noundef %arraydecay)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZN4llvh7APFloat6divideERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(32) %RHS, i32 noundef %RM) #1 comdat align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  %RM.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  store i32 %RM, ptr %RM.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %RHS.addr, align 8
  %U3 = getelementptr inbounds %"class.llvh::APFloat", ptr %0, i32 0, i32 1
  %1 = load i32, ptr %RM.addr, align 4
  %call4 = call noundef i32 @_ZN4llvh6detail9IEEEFloat6divideERKS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef nonnull align 8 dereferenceable(24) %U3, i32 noundef %1)
  store i32 %call4, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %call5 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call6 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call5)
  br i1 %call6, label %if.then7, label %if.end11

if.then7:                                         ; preds = %if.end
  %U8 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %RHS.addr, align 8
  %U9 = getelementptr inbounds %"class.llvh::APFloat", ptr %2, i32 0, i32 1
  %3 = load i32, ptr %RM.addr, align 4
  %call10 = call noundef i32 @_ZN4llvh6detail13DoubleAPFloat6divideERKS1_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %U8, ptr noundef nonnull align 8 dereferenceable(16) %U9, i32 noundef %3)
  store i32 %call10, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end
  unreachable

return:                                           ; preds = %if.then7, %if.then
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZNK4llvh7APFloat14bitcastToAPIntEv(ptr noalias sret(%"class.llvh::APInt") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  call void @_ZNK4llvh6detail9IEEEFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(24) %U)
  br label %return

if.end:                                           ; preds = %do.body
  %call3 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call4 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call3)
  br i1 %call4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %U6 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  call void @_ZNK4llvh6detail13DoubleAPFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(16) %U6)
  br label %return

if.end7:                                          ; preds = %if.end
  unreachable

do.end:                                           ; No predecessors!
  call void @llvm.trap()
  unreachable

return:                                           ; preds = %if.then5, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 8 dereferenceable(16) ptr @_ZN4llvh6detail13DoubleAPFloataSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %RHS) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %RHS.addr, align 8
  %cmp = icmp ne ptr %this1, %0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @_ZN4llvh6detail13DoubleAPFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this1) #10
  %1 = load ptr, ptr %RHS.addr, align 8
  call void @_ZN4llvh6detail13DoubleAPFloatC1EOS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail13DoubleAPFloat9remainderERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %RHS) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  %Tmp = alloca %"class.llvh::APFloat", align 8
  %ref.tmp = alloca %"class.llvh::APInt", align 8
  %Ret = alloca i32, align 4
  %ref.tmp2 = alloca %"class.llvh::APFloat", align 8
  %ref.tmp3 = alloca %"class.llvh::APInt", align 8
  %ref.tmp4 = alloca %"class.llvh::detail::DoubleAPFloat", align 8
  %ref.tmp5 = alloca %"class.llvh::APInt", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZNK4llvh6detail13DoubleAPFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp, ptr noundef nonnull align 8 dereferenceable(16) %this1)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %Tmp, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL24semPPCDoubleDoubleLegacyE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp) #10
  %0 = load ptr, ptr %RHS.addr, align 8
  call void @_ZNK4llvh6detail13DoubleAPFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp3, ptr noundef nonnull align 8 dereferenceable(16) %0)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp2, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL24semPPCDoubleDoubleLegacyE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp3)
  %call = call noundef i32 @_ZN4llvh7APFloat9remainderERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %Tmp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp2)
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp2) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp3) #10
  store i32 %call, ptr %Ret, align 4
  call void @_ZNK4llvh7APFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp5, ptr noundef nonnull align 8 dereferenceable(32) %Tmp)
  call void @_ZN4llvh6detail13DoubleAPFloatC1ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp4, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL18semPPCDoubleDoubleE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp5)
  %call6 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN4llvh6detail13DoubleAPFloataSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp4)
  call void @_ZN4llvh6detail13DoubleAPFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp4) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp5) #10
  %1 = load i32, ptr %Ret, align 4
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %Tmp) #10
  ret i32 %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZN4llvh7APFloat9remainderERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(32) %RHS) #1 comdat align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %RHS.addr, align 8
  %U3 = getelementptr inbounds %"class.llvh::APFloat", ptr %0, i32 0, i32 1
  %call4 = call noundef i32 @_ZN4llvh6detail9IEEEFloat9remainderERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef nonnull align 8 dereferenceable(24) %U3)
  store i32 %call4, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %call5 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call6 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call5)
  br i1 %call6, label %if.then7, label %if.end11

if.then7:                                         ; preds = %if.end
  %U8 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %RHS.addr, align 8
  %U9 = getelementptr inbounds %"class.llvh::APFloat", ptr %1, i32 0, i32 1
  %call10 = call noundef i32 @_ZN4llvh6detail13DoubleAPFloat9remainderERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %U8, ptr noundef nonnull align 8 dereferenceable(16) %U9)
  store i32 %call10, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end
  unreachable

return:                                           ; preds = %if.then7, %if.then
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail13DoubleAPFloat3modERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %RHS) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  %Tmp = alloca %"class.llvh::APFloat", align 8
  %ref.tmp = alloca %"class.llvh::APInt", align 8
  %Ret = alloca i32, align 4
  %ref.tmp2 = alloca %"class.llvh::APFloat", align 8
  %ref.tmp3 = alloca %"class.llvh::APInt", align 8
  %ref.tmp4 = alloca %"class.llvh::detail::DoubleAPFloat", align 8
  %ref.tmp5 = alloca %"class.llvh::APInt", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZNK4llvh6detail13DoubleAPFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp, ptr noundef nonnull align 8 dereferenceable(16) %this1)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %Tmp, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL24semPPCDoubleDoubleLegacyE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp) #10
  %0 = load ptr, ptr %RHS.addr, align 8
  call void @_ZNK4llvh6detail13DoubleAPFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp3, ptr noundef nonnull align 8 dereferenceable(16) %0)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp2, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL24semPPCDoubleDoubleLegacyE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp3)
  %call = call noundef i32 @_ZN4llvh7APFloat3modERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %Tmp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp2)
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp2) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp3) #10
  store i32 %call, ptr %Ret, align 4
  call void @_ZNK4llvh7APFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp5, ptr noundef nonnull align 8 dereferenceable(32) %Tmp)
  call void @_ZN4llvh6detail13DoubleAPFloatC1ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp4, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL18semPPCDoubleDoubleE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp5)
  %call6 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN4llvh6detail13DoubleAPFloataSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp4)
  call void @_ZN4llvh6detail13DoubleAPFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp4) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp5) #10
  %1 = load i32, ptr %Ret, align 4
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %Tmp) #10
  ret i32 %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZN4llvh7APFloat3modERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(32) %RHS) #1 comdat align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %RHS.addr, align 8
  %U3 = getelementptr inbounds %"class.llvh::APFloat", ptr %0, i32 0, i32 1
  %call4 = call noundef i32 @_ZN4llvh6detail9IEEEFloat3modERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef nonnull align 8 dereferenceable(24) %U3)
  store i32 %call4, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %call5 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call6 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call5)
  br i1 %call6, label %if.then7, label %if.end11

if.then7:                                         ; preds = %if.end
  %U8 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %RHS.addr, align 8
  %U9 = getelementptr inbounds %"class.llvh::APFloat", ptr %1, i32 0, i32 1
  %call10 = call noundef i32 @_ZN4llvh6detail13DoubleAPFloat3modERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %U8, ptr noundef nonnull align 8 dereferenceable(16) %U9)
  store i32 %call10, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end
  unreachable

return:                                           ; preds = %if.then7, %if.then
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail13DoubleAPFloat16fusedMultiplyAddERKS1_S3_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %Multiplicand, ptr noundef nonnull align 8 dereferenceable(16) %Addend, i32 noundef %RM) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Multiplicand.addr = alloca ptr, align 8
  %Addend.addr = alloca ptr, align 8
  %RM.addr = alloca i32, align 4
  %Tmp = alloca %"class.llvh::APFloat", align 8
  %ref.tmp = alloca %"class.llvh::APInt", align 8
  %Ret = alloca i32, align 4
  %ref.tmp2 = alloca %"class.llvh::APFloat", align 8
  %ref.tmp3 = alloca %"class.llvh::APInt", align 8
  %ref.tmp4 = alloca %"class.llvh::APFloat", align 8
  %ref.tmp5 = alloca %"class.llvh::APInt", align 8
  %ref.tmp6 = alloca %"class.llvh::detail::DoubleAPFloat", align 8
  %ref.tmp7 = alloca %"class.llvh::APInt", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %Multiplicand, ptr %Multiplicand.addr, align 8
  store ptr %Addend, ptr %Addend.addr, align 8
  store i32 %RM, ptr %RM.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZNK4llvh6detail13DoubleAPFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp, ptr noundef nonnull align 8 dereferenceable(16) %this1)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %Tmp, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL24semPPCDoubleDoubleLegacyE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp) #10
  %0 = load ptr, ptr %Multiplicand.addr, align 8
  call void @_ZNK4llvh6detail13DoubleAPFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp3, ptr noundef nonnull align 8 dereferenceable(16) %0)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp2, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL24semPPCDoubleDoubleLegacyE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp3)
  %1 = load ptr, ptr %Addend.addr, align 8
  call void @_ZNK4llvh6detail13DoubleAPFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp5, ptr noundef nonnull align 8 dereferenceable(16) %1)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp4, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL24semPPCDoubleDoubleLegacyE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp5)
  %2 = load i32, ptr %RM.addr, align 4
  %call = call noundef i32 @_ZN4llvh7APFloat16fusedMultiplyAddERKS0_S2_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %Tmp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp2, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp4, i32 noundef %2)
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp4) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp5) #10
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp2) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp3) #10
  store i32 %call, ptr %Ret, align 4
  call void @_ZNK4llvh7APFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %Tmp)
  call void @_ZN4llvh6detail13DoubleAPFloatC1ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp6, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL18semPPCDoubleDoubleE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp7)
  %call8 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN4llvh6detail13DoubleAPFloataSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp6)
  call void @_ZN4llvh6detail13DoubleAPFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp6) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp7) #10
  %3 = load i32, ptr %Ret, align 4
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %Tmp) #10
  ret i32 %3
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail13DoubleAPFloat15roundToIntegralENS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %RM) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %RM.addr = alloca i32, align 4
  %Tmp = alloca %"class.llvh::APFloat", align 8
  %ref.tmp = alloca %"class.llvh::APInt", align 8
  %Ret = alloca i32, align 4
  %ref.tmp2 = alloca %"class.llvh::detail::DoubleAPFloat", align 8
  %ref.tmp3 = alloca %"class.llvh::APInt", align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %RM, ptr %RM.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZNK4llvh6detail13DoubleAPFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp, ptr noundef nonnull align 8 dereferenceable(16) %this1)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %Tmp, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL24semPPCDoubleDoubleLegacyE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp) #10
  %0 = load i32, ptr %RM.addr, align 4
  %call = call noundef i32 @_ZN4llvh7APFloat15roundToIntegralENS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %Tmp, i32 noundef %0)
  store i32 %call, ptr %Ret, align 4
  call void @_ZNK4llvh7APFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp3, ptr noundef nonnull align 8 dereferenceable(32) %Tmp)
  call void @_ZN4llvh6detail13DoubleAPFloatC1ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL18semPPCDoubleDoubleE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp3)
  %call4 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN4llvh6detail13DoubleAPFloataSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2)
  call void @_ZN4llvh6detail13DoubleAPFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp3) #10
  %1 = load i32, ptr %Ret, align 4
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %Tmp) #10
  ret i32 %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZN4llvh7APFloat15roundToIntegralENS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %this, i32 noundef %RM) #1 comdat align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %RM.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %RM, ptr %RM.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %RM.addr, align 4
  %call3 = call noundef i32 @_ZN4llvh6detail9IEEEFloat15roundToIntegralENS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %U, i32 noundef %0)
  store i32 %call3, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %do.body
  %call4 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call5 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call4)
  br i1 %call5, label %if.then6, label %if.end9

if.then6:                                         ; preds = %if.end
  %U7 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %RM.addr, align 4
  %call8 = call noundef i32 @_ZN4llvh6detail13DoubleAPFloat15roundToIntegralENS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %U7, i32 noundef %1)
  store i32 %call8, ptr %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end
  unreachable

do.end:                                           ; No predecessors!
  call void @llvm.trap()
  unreachable

return:                                           ; preds = %if.then6, %if.then
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZNK4llvh6detail13DoubleAPFloat20compareAbsoluteValueERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %RHS) #1 align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  %Result = alloca i32, align 4
  %Against = alloca i32, align 4
  %RHSAgainst = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats, i64 noundef 0)
  %0 = load ptr, ptr %RHS.addr, align 8
  %Floats2 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %0, i32 0, i32 1
  %call3 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats2, i64 noundef 0)
  %call4 = call noundef i32 @_ZNK4llvh7APFloat20compareAbsoluteValueERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %call, ptr noundef nonnull align 8 dereferenceable(32) %call3)
  store i32 %call4, ptr %Result, align 4
  %1 = load i32, ptr %Result, align 4
  %cmp = icmp ne i32 %1, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %Result, align 4
  store i32 %2, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %Floats5 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call6 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats5, i64 noundef 1)
  %3 = load ptr, ptr %RHS.addr, align 8
  %Floats7 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %3, i32 0, i32 1
  %call8 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats7, i64 noundef 1)
  %call9 = call noundef i32 @_ZNK4llvh7APFloat20compareAbsoluteValueERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %call6, ptr noundef nonnull align 8 dereferenceable(32) %call8)
  store i32 %call9, ptr %Result, align 4
  %4 = load i32, ptr %Result, align 4
  %cmp10 = icmp eq i32 %4, 0
  br i1 %cmp10, label %if.then12, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %5 = load i32, ptr %Result, align 4
  %cmp11 = icmp eq i32 %5, 2
  br i1 %cmp11, label %if.then12, label %if.end47

if.then12:                                        ; preds = %lor.lhs.false, %if.end
  %Floats13 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call14 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats13, i64 noundef 0)
  %call15 = call noundef zeroext i1 @_ZNK4llvh7APFloat10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(32) %call14)
  %conv = zext i1 %call15 to i32
  %Floats16 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call17 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats16, i64 noundef 1)
  %call18 = call noundef zeroext i1 @_ZNK4llvh7APFloat10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(32) %call17)
  %conv19 = zext i1 %call18 to i32
  %xor = xor i32 %conv, %conv19
  store i32 %xor, ptr %Against, align 4
  %6 = load ptr, ptr %RHS.addr, align 8
  %Floats20 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %6, i32 0, i32 1
  %call21 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats20, i64 noundef 0)
  %call22 = call noundef zeroext i1 @_ZNK4llvh7APFloat10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(32) %call21)
  %conv23 = zext i1 %call22 to i32
  %7 = load ptr, ptr %RHS.addr, align 8
  %Floats24 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %7, i32 0, i32 1
  %call25 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats24, i64 noundef 1)
  %call26 = call noundef zeroext i1 @_ZNK4llvh7APFloat10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(32) %call25)
  %conv27 = zext i1 %call26 to i32
  %xor28 = xor i32 %conv23, %conv27
  store i32 %xor28, ptr %RHSAgainst, align 4
  %8 = load i32, ptr %Against, align 4
  %tobool = icmp ne i32 %8, 0
  br i1 %tobool, label %land.lhs.true, label %if.end31

land.lhs.true:                                    ; preds = %if.then12
  %9 = load i32, ptr %RHSAgainst, align 4
  %tobool29 = icmp ne i32 %9, 0
  br i1 %tobool29, label %if.end31, label %if.then30

if.then30:                                        ; preds = %land.lhs.true
  store i32 0, ptr %retval, align 4
  br label %return

if.end31:                                         ; preds = %land.lhs.true, %if.then12
  %10 = load i32, ptr %Against, align 4
  %tobool32 = icmp ne i32 %10, 0
  br i1 %tobool32, label %if.end36, label %land.lhs.true33

land.lhs.true33:                                  ; preds = %if.end31
  %11 = load i32, ptr %RHSAgainst, align 4
  %tobool34 = icmp ne i32 %11, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %land.lhs.true33
  store i32 2, ptr %retval, align 4
  br label %return

if.end36:                                         ; preds = %land.lhs.true33, %if.end31
  %12 = load i32, ptr %Against, align 4
  %tobool37 = icmp ne i32 %12, 0
  br i1 %tobool37, label %if.end41, label %land.lhs.true38

land.lhs.true38:                                  ; preds = %if.end36
  %13 = load i32, ptr %RHSAgainst, align 4
  %tobool39 = icmp ne i32 %13, 0
  br i1 %tobool39, label %if.end41, label %if.then40

if.then40:                                        ; preds = %land.lhs.true38
  %14 = load i32, ptr %Result, align 4
  store i32 %14, ptr %retval, align 4
  br label %return

if.end41:                                         ; preds = %land.lhs.true38, %if.end36
  %15 = load i32, ptr %Against, align 4
  %tobool42 = icmp ne i32 %15, 0
  br i1 %tobool42, label %land.lhs.true43, label %if.end46

land.lhs.true43:                                  ; preds = %if.end41
  %16 = load i32, ptr %RHSAgainst, align 4
  %tobool44 = icmp ne i32 %16, 0
  br i1 %tobool44, label %if.then45, label %if.end46

if.then45:                                        ; preds = %land.lhs.true43
  %17 = load i32, ptr %Result, align 4
  %sub = sub nsw i32 2, %17
  store i32 %sub, ptr %retval, align 4
  br label %return

if.end46:                                         ; preds = %land.lhs.true43, %if.end41
  br label %if.end47

if.end47:                                         ; preds = %if.end46, %lor.lhs.false
  %18 = load i32, ptr %Result, align 4
  store i32 %18, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end47, %if.then45, %if.then40, %if.then35, %if.then30, %if.then
  %19 = load i32, ptr %retval, align 4
  ret i32 %19
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZNK4llvh7APFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(24) ptr @_ZNK4llvh7APFloat7getIEEEEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(24) %call)
  ret i32 %call2
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail13DoubleAPFloat7makeInfEb(ptr noundef nonnull align 8 dereferenceable(16) %this, i1 noundef zeroext %Neg) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Neg.addr = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %Neg to i8
  store i8 %frombool, ptr %Neg.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats, i64 noundef 0)
  %0 = load i8, ptr %Neg.addr, align 1
  %tobool = trunc i8 %0 to i1
  call void @_ZN4llvh7APFloat7makeInfEb(ptr noundef nonnull align 8 dereferenceable(32) %call, i1 noundef zeroext %tobool)
  %Floats2 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call3 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats2, i64 noundef 1)
  call void @_ZN4llvh7APFloat8makeZeroEb(ptr noundef nonnull align 8 dereferenceable(32) %call3, i1 noundef zeroext false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh7APFloat7makeInfEb(ptr noundef nonnull align 8 dereferenceable(32) %this, i1 noundef zeroext %Neg) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Neg.addr = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %Neg to i8
  store i8 %frombool, ptr %Neg.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load i8, ptr %Neg.addr, align 1
  %tobool = trunc i8 %0 to i1
  call void @_ZN4llvh6detail9IEEEFloat7makeInfEb(ptr noundef nonnull align 8 dereferenceable(24) %U, i1 noundef zeroext %tobool)
  br label %do.end

if.end:                                           ; preds = %do.body
  %call3 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call4 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call3)
  br i1 %call4, label %if.then5, label %if.end8

if.then5:                                         ; preds = %if.end
  %U6 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %1 = load i8, ptr %Neg.addr, align 1
  %tobool7 = trunc i8 %1 to i1
  call void @_ZN4llvh6detail13DoubleAPFloat7makeInfEb(ptr noundef nonnull align 8 dereferenceable(16) %U6, i1 noundef zeroext %tobool7)
  br label %do.end

if.end8:                                          ; preds = %if.end
  unreachable

do.end:                                           ; preds = %if.then5, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail13DoubleAPFloat8makeZeroEb(ptr noundef nonnull align 8 dereferenceable(16) %this, i1 noundef zeroext %Neg) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Neg.addr = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %Neg to i8
  store i8 %frombool, ptr %Neg.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats, i64 noundef 0)
  %0 = load i8, ptr %Neg.addr, align 1
  %tobool = trunc i8 %0 to i1
  call void @_ZN4llvh7APFloat8makeZeroEb(ptr noundef nonnull align 8 dereferenceable(32) %call, i1 noundef zeroext %tobool)
  %Floats2 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call3 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats2, i64 noundef 1)
  call void @_ZN4llvh7APFloat8makeZeroEb(ptr noundef nonnull align 8 dereferenceable(32) %call3, i1 noundef zeroext false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail13DoubleAPFloat11makeLargestEb(ptr noundef nonnull align 8 dereferenceable(16) %this, i1 noundef zeroext %Neg) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Neg.addr = alloca i8, align 1
  %ref.tmp = alloca %"class.llvh::APFloat", align 8
  %ref.tmp2 = alloca %"class.llvh::APInt", align 8
  %ref.tmp4 = alloca %"class.llvh::APFloat", align 8
  %ref.tmp5 = alloca %"class.llvh::APInt", align 8
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %Neg to i8
  store i8 %frombool, ptr %Neg.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4llvh5APIntC2Ejmb(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp2, i32 noundef 64, i64 noundef 9218868437227405311, i1 noundef zeroext false)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL13semIEEEdoubleE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp2)
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats, i64 noundef 0)
  %call3 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN4llvh7APFloataSEOS0_(ptr noundef nonnull align 8 dereferenceable(32) %call, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp)
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp2) #10
  call void @_ZN4llvh5APIntC2Ejmb(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp5, i32 noundef 64, i64 noundef 8975674057349398526, i1 noundef zeroext false)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp4, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL13semIEEEdoubleE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp5)
  %Floats6 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call7 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats6, i64 noundef 1)
  %call8 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN4llvh7APFloataSEOS0_(ptr noundef nonnull align 8 dereferenceable(32) %call7, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp4)
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp4) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp5) #10
  %0 = load i8, ptr %Neg.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @_ZN4llvh6detail13DoubleAPFloat10changeSignEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail13DoubleAPFloat12makeSmallestEb(ptr noundef nonnull align 8 dereferenceable(16) %this, i1 noundef zeroext %Neg) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Neg.addr = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %Neg to i8
  store i8 %frombool, ptr %Neg.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats, i64 noundef 0)
  %0 = load i8, ptr %Neg.addr, align 1
  %tobool = trunc i8 %0 to i1
  call void @_ZN4llvh7APFloat12makeSmallestEb(ptr noundef nonnull align 8 dereferenceable(32) %call, i1 noundef zeroext %tobool)
  %Floats2 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call3 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats2, i64 noundef 1)
  call void @_ZN4llvh7APFloat8makeZeroEb(ptr noundef nonnull align 8 dereferenceable(32) %call3, i1 noundef zeroext false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh7APFloat12makeSmallestEb(ptr noundef nonnull align 8 dereferenceable(32) %this, i1 noundef zeroext %Neg) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Neg.addr = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %Neg to i8
  store i8 %frombool, ptr %Neg.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load i8, ptr %Neg.addr, align 1
  %tobool = trunc i8 %0 to i1
  call void @_ZN4llvh6detail9IEEEFloat12makeSmallestEb(ptr noundef nonnull align 8 dereferenceable(24) %U, i1 noundef zeroext %tobool)
  br label %do.end

if.end:                                           ; preds = %do.body
  %call3 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call4 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call3)
  br i1 %call4, label %if.then5, label %if.end8

if.then5:                                         ; preds = %if.end
  %U6 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %1 = load i8, ptr %Neg.addr, align 1
  %tobool7 = trunc i8 %1 to i1
  call void @_ZN4llvh6detail13DoubleAPFloat12makeSmallestEb(ptr noundef nonnull align 8 dereferenceable(16) %U6, i1 noundef zeroext %tobool7)
  br label %do.end

if.end8:                                          ; preds = %if.end
  unreachable

do.end:                                           ; preds = %if.then5, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail13DoubleAPFloat22makeSmallestNormalizedEb(ptr noundef nonnull align 8 dereferenceable(16) %this, i1 noundef zeroext %Neg) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Neg.addr = alloca i8, align 1
  %ref.tmp = alloca %"class.llvh::APFloat", align 8
  %ref.tmp2 = alloca %"class.llvh::APInt", align 8
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %Neg to i8
  store i8 %frombool, ptr %Neg.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4llvh5APIntC2Ejmb(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp2, i32 noundef 64, i64 noundef 243194379878006784, i1 noundef zeroext false)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL13semIEEEdoubleE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp2)
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats, i64 noundef 0)
  %call3 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN4llvh7APFloataSEOS0_(ptr noundef nonnull align 8 dereferenceable(32) %call, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp)
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp2) #10
  %0 = load i8, ptr %Neg.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Floats4 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call5 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats4, i64 noundef 0)
  call void @_ZN4llvh7APFloat10changeSignEv(ptr noundef nonnull align 8 dereferenceable(32) %call5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %Floats6 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call7 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats6, i64 noundef 1)
  call void @_ZN4llvh7APFloat8makeZeroEb(ptr noundef nonnull align 8 dereferenceable(32) %call7, i1 noundef zeroext false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh7APFloat7makeNaNEbbPKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %this, i1 noundef zeroext %SNaN, i1 noundef zeroext %Neg, ptr noundef %fill) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %SNaN.addr = alloca i8, align 1
  %Neg.addr = alloca i8, align 1
  %fill.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %SNaN to i8
  store i8 %frombool, ptr %SNaN.addr, align 1
  %frombool1 = zext i1 %Neg to i8
  store i8 %frombool1, ptr %Neg.addr, align 1
  store ptr %fill, ptr %fill.addr, align 8
  %this2 = load ptr, ptr %this.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this2)
  %call3 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call3, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this2, i32 0, i32 1
  %0 = load i8, ptr %SNaN.addr, align 1
  %tobool = trunc i8 %0 to i1
  %1 = load i8, ptr %Neg.addr, align 1
  %tobool4 = trunc i8 %1 to i1
  %2 = load ptr, ptr %fill.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloat7makeNaNEbbPKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %U, i1 noundef zeroext %tobool, i1 noundef zeroext %tobool4, ptr noundef %2)
  br label %do.end

if.end:                                           ; preds = %do.body
  %call5 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this2)
  %call6 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call5)
  br i1 %call6, label %if.then7, label %if.end11

if.then7:                                         ; preds = %if.end
  %U8 = getelementptr inbounds %"class.llvh::APFloat", ptr %this2, i32 0, i32 1
  %3 = load i8, ptr %SNaN.addr, align 1
  %tobool9 = trunc i8 %3 to i1
  %4 = load i8, ptr %Neg.addr, align 1
  %tobool10 = trunc i8 %4 to i1
  %5 = load ptr, ptr %fill.addr, align 8
  call void @_ZN4llvh6detail13DoubleAPFloat7makeNaNEbbPKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(16) %U8, i1 noundef zeroext %tobool9, i1 noundef zeroext %tobool10, ptr noundef %5)
  br label %do.end

if.end11:                                         ; preds = %if.end
  unreachable

do.end:                                           ; preds = %if.then7, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZNK4llvh6detail13DoubleAPFloat7compareERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %RHS) #1 align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  %Result = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats, i64 noundef 0)
  %0 = load ptr, ptr %RHS.addr, align 8
  %Floats2 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %0, i32 0, i32 1
  %call3 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats2, i64 noundef 0)
  %call4 = call noundef i32 @_ZNK4llvh7APFloat7compareERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %call, ptr noundef nonnull align 8 dereferenceable(32) %call3)
  store i32 %call4, ptr %Result, align 4
  %1 = load i32, ptr %Result, align 4
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Floats5 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call6 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats5, i64 noundef 1)
  %2 = load ptr, ptr %RHS.addr, align 8
  %Floats7 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %2, i32 0, i32 1
  %call8 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats7, i64 noundef 1)
  %call9 = call noundef i32 @_ZNK4llvh7APFloat7compareERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %call6, ptr noundef nonnull align 8 dereferenceable(32) %call8)
  store i32 %call9, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, ptr %Result, align 4
  store i32 %3, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZNK4llvh7APFloat7compareERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(32) %RHS) #1 comdat align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %RHS.addr, align 8
  %U3 = getelementptr inbounds %"class.llvh::APFloat", ptr %0, i32 0, i32 1
  %call4 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat7compareERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef nonnull align 8 dereferenceable(24) %U3)
  store i32 %call4, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %call5 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call6 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call5)
  br i1 %call6, label %if.then7, label %if.end11

if.then7:                                         ; preds = %if.end
  %U8 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %RHS.addr, align 8
  %U9 = getelementptr inbounds %"class.llvh::APFloat", ptr %1, i32 0, i32 1
  %call10 = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat7compareERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %U8, ptr noundef nonnull align 8 dereferenceable(16) %U9)
  store i32 %call10, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end
  unreachable

return:                                           ; preds = %if.then7, %if.then
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef zeroext i1 @_ZNK4llvh6detail13DoubleAPFloat14bitwiseIsEqualERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %RHS) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats, i64 noundef 0)
  %0 = load ptr, ptr %RHS.addr, align 8
  %Floats2 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %0, i32 0, i32 1
  %call3 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats2, i64 noundef 0)
  %call4 = call noundef zeroext i1 @_ZNK4llvh7APFloat14bitwiseIsEqualERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %call, ptr noundef nonnull align 8 dereferenceable(32) %call3)
  br i1 %call4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %Floats5 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call6 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats5, i64 noundef 1)
  %1 = load ptr, ptr %RHS.addr, align 8
  %Floats7 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %1, i32 0, i32 1
  %call8 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats7, i64 noundef 1)
  %call9 = call noundef zeroext i1 @_ZNK4llvh7APFloat14bitwiseIsEqualERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %call6, ptr noundef nonnull align 8 dereferenceable(32) %call8)
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %call9, %land.rhs ]
  ret i1 %2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh7APFloat14bitwiseIsEqualERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(32) %RHS) #1 comdat align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %0 = load ptr, ptr %RHS.addr, align 8
  %call2 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %0)
  %cmp = icmp ne ptr %call, %call2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %call3 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call4 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call3)
  br i1 %call4, label %if.then5, label %if.end8

if.then5:                                         ; preds = %if.end
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %RHS.addr, align 8
  %U6 = getelementptr inbounds %"class.llvh::APFloat", ptr %1, i32 0, i32 1
  %call7 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat14bitwiseIsEqualERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef nonnull align 8 dereferenceable(24) %U6)
  store i1 %call7, ptr %retval, align 1
  br label %return

if.end8:                                          ; preds = %if.end
  %call9 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call10 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call9)
  br i1 %call10, label %if.then11, label %if.end15

if.then11:                                        ; preds = %if.end8
  %U12 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %RHS.addr, align 8
  %U13 = getelementptr inbounds %"class.llvh::APFloat", ptr %2, i32 0, i32 1
  %call14 = call noundef zeroext i1 @_ZNK4llvh6detail13DoubleAPFloat14bitwiseIsEqualERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %U12, ptr noundef nonnull align 8 dereferenceable(16) %U13)
  store i1 %call14, ptr %retval, align 1
  br label %return

if.end15:                                         ; preds = %if.end8
  unreachable

return:                                           ; preds = %if.then11, %if.then5, %if.then
  %3 = load i1, ptr %retval, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nounwind uwtable
define hidden i64 @_ZN4llvh6detail10hash_valueERKNS0_13DoubleAPFloatE(ptr noundef nonnull align 8 dereferenceable(16) %Arg) #1 {
entry:
  %retval = alloca %"class.llvh::hash_code", align 8
  %Arg.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.llvh::hash_code", align 8
  %ref.tmp4 = alloca %"class.llvh::hash_code", align 8
  store ptr %Arg, ptr %Arg.addr, align 8
  %0 = load ptr, ptr %Arg.addr, align 8
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %0, i32 0, i32 1
  %call = call noundef zeroext i1 @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEcvbEv(ptr noundef nonnull align 8 dereferenceable(8) %Floats) #10
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %Arg.addr, align 8
  %Floats1 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %1, i32 0, i32 1
  %call2 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats1, i64 noundef 0)
  %call3 = call i64 @_ZN4llvh10hash_valueERKNS_7APFloatE(ptr noundef nonnull align 8 dereferenceable(32) %call2)
  %coerce.dive = getelementptr inbounds %"class.llvh::hash_code", ptr %ref.tmp, i32 0, i32 0
  store i64 %call3, ptr %coerce.dive, align 8
  %2 = load ptr, ptr %Arg.addr, align 8
  %Floats5 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %2, i32 0, i32 1
  %call6 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats5, i64 noundef 1)
  %call7 = call i64 @_ZN4llvh10hash_valueERKNS_7APFloatE(ptr noundef nonnull align 8 dereferenceable(32) %call6)
  %coerce.dive8 = getelementptr inbounds %"class.llvh::hash_code", ptr %ref.tmp4, i32 0, i32 0
  store i64 %call7, ptr %coerce.dive8, align 8
  %call9 = call i64 @_ZN4llvh12hash_combineIJNS_9hash_codeES1_EEES1_DpRKT_(ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp4)
  %coerce.dive10 = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  store i64 %call9, ptr %coerce.dive10, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %Arg.addr, align 8
  %Semantics = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %3, i32 0, i32 0
  %call11 = call i64 @_ZN4llvh12hash_combineIJPKNS_12fltSemanticsEEEENS_9hash_codeEDpRKT_(ptr noundef nonnull align 8 dereferenceable(8) %Semantics)
  %coerce.dive12 = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  store i64 %call11, ptr %coerce.dive12, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %coerce.dive13 = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  %4 = load i64, ptr %coerce.dive13, align 8
  ret i64 %4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden i64 @_ZN4llvh12hash_combineIJNS_9hash_codeES1_EEES1_DpRKT_(ptr noundef nonnull align 8 dereferenceable(8) %args, ptr noundef nonnull align 8 dereferenceable(8) %args1) #1 comdat {
entry:
  %retval = alloca %"class.llvh::hash_code", align 8
  %args.addr = alloca ptr, align 8
  %args.addr2 = alloca ptr, align 8
  %helper = alloca %"struct.llvh::hashing::detail::hash_combine_recursive_helper", align 8
  store ptr %args, ptr %args.addr, align 8
  store ptr %args1, ptr %args.addr2, align 8
  call void @_ZN4llvh7hashing6detail29hash_combine_recursive_helperC2Ev(ptr noundef nonnull align 8 dereferenceable(128) %helper)
  %buffer = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %helper, i32 0, i32 0
  %arraydecay = getelementptr inbounds [64 x i8], ptr %buffer, i64 0, i64 0
  %buffer3 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %helper, i32 0, i32 0
  %arraydecay4 = getelementptr inbounds [64 x i8], ptr %buffer3, i64 0, i64 0
  %add.ptr = getelementptr inbounds i8, ptr %arraydecay4, i64 64
  %0 = load ptr, ptr %args.addr, align 8
  %1 = load ptr, ptr %args.addr2, align 8
  %call = call i64 @_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineINS_9hash_codeEJS4_EEES4_mPcS5_RKT_DpRKT0_(ptr noundef nonnull align 8 dereferenceable(128) %helper, i64 noundef 0, ptr noundef %arraydecay, ptr noundef %add.ptr, ptr noundef nonnull align 8 dereferenceable(8) %0, ptr noundef nonnull align 8 dereferenceable(8) %1)
  %coerce.dive = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  store i64 %call, ptr %coerce.dive, align 8
  %coerce.dive5 = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  %2 = load i64, ptr %coerce.dive5, align 8
  ret i64 %2
}

; Function Attrs: mustprogress nounwind uwtable
define hidden i64 @_ZN4llvh10hash_valueERKNS_7APFloatE(ptr noundef nonnull align 8 dereferenceable(32) %Arg) #1 {
entry:
  %retval = alloca %"class.llvh::hash_code", align 8
  %Arg.addr = alloca ptr, align 8
  store ptr %Arg, ptr %Arg.addr, align 8
  %0 = load ptr, ptr %Arg.addr, align 8
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %0)
  %call1 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %Arg.addr, align 8
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %1, i32 0, i32 1
  %call2 = call i64 @_ZN4llvh6detail10hash_valueERKNS0_9IEEEFloatE(ptr noundef nonnull align 8 dereferenceable(24) %U)
  %coerce.dive = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  store i64 %call2, ptr %coerce.dive, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %Arg.addr, align 8
  %call3 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %2)
  %call4 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call3)
  br i1 %call4, label %if.then5, label %if.end9

if.then5:                                         ; preds = %if.end
  %3 = load ptr, ptr %Arg.addr, align 8
  %U6 = getelementptr inbounds %"class.llvh::APFloat", ptr %3, i32 0, i32 1
  %call7 = call i64 @_ZN4llvh6detail10hash_valueERKNS0_13DoubleAPFloatE(ptr noundef nonnull align 8 dereferenceable(16) %U6)
  %coerce.dive8 = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  store i64 %call7, ptr %coerce.dive8, align 8
  br label %return

if.end9:                                          ; preds = %if.end
  unreachable

return:                                           ; preds = %if.then5, %if.then
  %coerce.dive10 = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  %4 = load i64, ptr %coerce.dive10, align 8
  ret i64 %4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden i64 @_ZN4llvh12hash_combineIJPKNS_12fltSemanticsEEEENS_9hash_codeEDpRKT_(ptr noundef nonnull align 8 dereferenceable(8) %args) #1 comdat {
entry:
  %retval = alloca %"class.llvh::hash_code", align 8
  %args.addr = alloca ptr, align 8
  %helper = alloca %"struct.llvh::hashing::detail::hash_combine_recursive_helper", align 8
  store ptr %args, ptr %args.addr, align 8
  call void @_ZN4llvh7hashing6detail29hash_combine_recursive_helperC2Ev(ptr noundef nonnull align 8 dereferenceable(128) %helper)
  %buffer = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %helper, i32 0, i32 0
  %arraydecay = getelementptr inbounds [64 x i8], ptr %buffer, i64 0, i64 0
  %buffer1 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %helper, i32 0, i32 0
  %arraydecay2 = getelementptr inbounds [64 x i8], ptr %buffer1, i64 0, i64 0
  %add.ptr = getelementptr inbounds i8, ptr %arraydecay2, i64 64
  %0 = load ptr, ptr %args.addr, align 8
  %call = call i64 @_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineIPKNS_12fltSemanticsEJEEENS_9hash_codeEmPcS8_RKT_DpRKT0_(ptr noundef nonnull align 8 dereferenceable(128) %helper, i64 noundef 0, ptr noundef %arraydecay, ptr noundef %add.ptr, ptr noundef nonnull align 8 dereferenceable(8) %0)
  %coerce.dive = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  store i64 %call, ptr %coerce.dive, align 8
  %coerce.dive3 = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  %1 = load i64, ptr %coerce.dive3, align 8
  ret i64 %1
}

declare void @_ZN4llvh5APIntC1EjjPKm(ptr noundef nonnull align 8 dereferenceable(12), i32 noundef, i32 noundef, ptr noundef) unnamed_addr #5

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail13DoubleAPFloat17convertFromStringENS_9StringRefENS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr %S.coerce0, i64 %S.coerce1, i32 noundef %RM) #1 align 2 {
entry:
  %S = alloca %"class.llvh::StringRef", align 8
  %this.addr = alloca ptr, align 8
  %RM.addr = alloca i32, align 4
  %Tmp = alloca %"class.llvh::APFloat", align 8
  %Ret = alloca i32, align 4
  %agg.tmp = alloca %"class.llvh::StringRef", align 8
  %ref.tmp = alloca %"class.llvh::detail::DoubleAPFloat", align 8
  %ref.tmp2 = alloca %"class.llvh::APInt", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %S, i32 0, i32 0
  store ptr %S.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %S, i32 0, i32 1
  store i64 %S.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %RM, ptr %RM.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(32) %Tmp, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL24semPPCDoubleDoubleLegacyE)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %S, i64 16, i1 false)
  %2 = load i32, ptr %RM.addr, align 4
  %3 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %6 = load i64, ptr %5, align 8
  %call = call noundef i32 @_ZN4llvh7APFloat17convertFromStringENS_9StringRefENS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %Tmp, ptr %4, i64 %6, i32 noundef %2)
  store i32 %call, ptr %Ret, align 4
  call void @_ZNK4llvh7APFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp2, ptr noundef nonnull align 8 dereferenceable(32) %Tmp)
  call void @_ZN4llvh6detail13DoubleAPFloatC1ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL18semPPCDoubleDoubleE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp2)
  %call3 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN4llvh6detail13DoubleAPFloataSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  call void @_ZN4llvh6detail13DoubleAPFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp2) #10
  %7 = load i32, ptr %Ret, align 4
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %Tmp) #10
  ret i32 %7
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh7APFloat17convertFromStringENS_9StringRefENS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %Str.coerce0, i64 %Str.coerce1, i32 noundef %RM) #1 align 2 {
entry:
  %retval = alloca i32, align 4
  %Str = alloca %"class.llvh::StringRef", align 8
  %this.addr = alloca ptr, align 8
  %RM.addr = alloca i32, align 4
  %agg.tmp = alloca %"class.llvh::StringRef", align 8
  %agg.tmp8 = alloca %"class.llvh::StringRef", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %Str, i32 0, i32 0
  store ptr %Str.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %Str, i32 0, i32 1
  store i64 %Str.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %RM, ptr %RM.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %Str, i64 16, i1 false)
  %2 = load i32, ptr %RM.addr, align 4
  %3 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %6 = load i64, ptr %5, align 8
  %call3 = call noundef i32 @_ZN4llvh6detail9IEEEFloat17convertFromStringENS_9StringRefENS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr %4, i64 %6, i32 noundef %2)
  store i32 %call3, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %do.body
  %call4 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call5 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call4)
  br i1 %call5, label %if.then6, label %if.end10

if.then6:                                         ; preds = %if.end
  %U7 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp8, ptr align 8 %Str, i64 16, i1 false)
  %7 = load i32, ptr %RM.addr, align 4
  %8 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp8, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp8, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  %call9 = call noundef i32 @_ZN4llvh6detail13DoubleAPFloat17convertFromStringENS_9StringRefENS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %U7, ptr %9, i64 %11, i32 noundef %7)
  store i32 %call9, ptr %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end
  unreachable

do.end:                                           ; No predecessors!
  call void @llvm.trap()
  unreachable

return:                                           ; preds = %if.then6, %if.then
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail13DoubleAPFloat4nextEb(ptr noundef nonnull align 8 dereferenceable(16) %this, i1 noundef zeroext %nextDown) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %nextDown.addr = alloca i8, align 1
  %Tmp = alloca %"class.llvh::APFloat", align 8
  %ref.tmp = alloca %"class.llvh::APInt", align 8
  %Ret = alloca i32, align 4
  %ref.tmp2 = alloca %"class.llvh::detail::DoubleAPFloat", align 8
  %ref.tmp3 = alloca %"class.llvh::APInt", align 8
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %nextDown to i8
  store i8 %frombool, ptr %nextDown.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZNK4llvh6detail13DoubleAPFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp, ptr noundef nonnull align 8 dereferenceable(16) %this1)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %Tmp, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL24semPPCDoubleDoubleLegacyE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp) #10
  %0 = load i8, ptr %nextDown.addr, align 1
  %tobool = trunc i8 %0 to i1
  %call = call noundef i32 @_ZN4llvh7APFloat4nextEb(ptr noundef nonnull align 8 dereferenceable(32) %Tmp, i1 noundef zeroext %tobool)
  store i32 %call, ptr %Ret, align 4
  call void @_ZNK4llvh7APFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp3, ptr noundef nonnull align 8 dereferenceable(32) %Tmp)
  call void @_ZN4llvh6detail13DoubleAPFloatC1ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL18semPPCDoubleDoubleE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp3)
  %call4 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN4llvh6detail13DoubleAPFloataSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2)
  call void @_ZN4llvh6detail13DoubleAPFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp3) #10
  %1 = load i32, ptr %Ret, align 4
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %Tmp) #10
  ret i32 %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZN4llvh7APFloat4nextEb(ptr noundef nonnull align 8 dereferenceable(32) %this, i1 noundef zeroext %nextDown) #1 comdat align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %nextDown.addr = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %nextDown to i8
  store i8 %frombool, ptr %nextDown.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load i8, ptr %nextDown.addr, align 1
  %tobool = trunc i8 %0 to i1
  %call3 = call noundef i32 @_ZN4llvh6detail9IEEEFloat4nextEb(ptr noundef nonnull align 8 dereferenceable(24) %U, i1 noundef zeroext %tobool)
  store i32 %call3, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %do.body
  %call4 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call5 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call4)
  br i1 %call5, label %if.then6, label %if.end10

if.then6:                                         ; preds = %if.end
  %U7 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %1 = load i8, ptr %nextDown.addr, align 1
  %tobool8 = trunc i8 %1 to i1
  %call9 = call noundef i32 @_ZN4llvh6detail13DoubleAPFloat4nextEb(ptr noundef nonnull align 8 dereferenceable(16) %U7, i1 noundef zeroext %tobool8)
  store i32 %call9, ptr %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end
  unreachable

do.end:                                           ; No predecessors!
  call void @llvm.trap()
  unreachable

return:                                           ; preds = %if.then6, %if.then
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZNK4llvh6detail13DoubleAPFloat16convertToIntegerENS_15MutableArrayRefImEEjbNS_11APFloatBase12roundingModeEPb(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr %Input.coerce0, i64 %Input.coerce1, i32 noundef %Width, i1 noundef zeroext %IsSigned, i32 noundef %RM, ptr noundef %IsExact) #1 align 2 {
entry:
  %Input = alloca %"class.llvh::MutableArrayRef", align 8
  %this.addr = alloca ptr, align 8
  %Width.addr = alloca i32, align 4
  %IsSigned.addr = alloca i8, align 1
  %RM.addr = alloca i32, align 4
  %IsExact.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.llvh::APFloat", align 8
  %ref.tmp2 = alloca %"class.llvh::APInt", align 8
  %agg.tmp = alloca %"class.llvh::MutableArrayRef", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %Input, i32 0, i32 0
  store ptr %Input.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %Input, i32 0, i32 1
  store i64 %Input.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %Width, ptr %Width.addr, align 4
  %frombool = zext i1 %IsSigned to i8
  store i8 %frombool, ptr %IsSigned.addr, align 1
  store i32 %RM, ptr %RM.addr, align 4
  store ptr %IsExact, ptr %IsExact.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZNK4llvh6detail13DoubleAPFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp2, ptr noundef nonnull align 8 dereferenceable(16) %this1)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL24semPPCDoubleDoubleLegacyE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp2)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %Input, i64 16, i1 false)
  %2 = load i32, ptr %Width.addr, align 4
  %3 = load i8, ptr %IsSigned.addr, align 1
  %tobool = trunc i8 %3 to i1
  %4 = load i32, ptr %RM.addr, align 4
  %5 = load ptr, ptr %IsExact.addr, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %9 = load i64, ptr %8, align 8
  %call = call noundef i32 @_ZNK4llvh7APFloat16convertToIntegerENS_15MutableArrayRefImEEjbNS_11APFloatBase12roundingModeEPb(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp, ptr %7, i64 %9, i32 noundef %2, i1 noundef zeroext %tobool, i32 noundef %4, ptr noundef %5)
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp2) #10
  ret i32 %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZNK4llvh7APFloat16convertToIntegerENS_15MutableArrayRefImEEjbNS_11APFloatBase12roundingModeEPb(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %Input.coerce0, i64 %Input.coerce1, i32 noundef %Width, i1 noundef zeroext %IsSigned, i32 noundef %RM, ptr noundef %IsExact) #1 comdat align 2 {
entry:
  %retval = alloca i32, align 4
  %Input = alloca %"class.llvh::MutableArrayRef", align 8
  %this.addr = alloca ptr, align 8
  %Width.addr = alloca i32, align 4
  %IsSigned.addr = alloca i8, align 1
  %RM.addr = alloca i32, align 4
  %IsExact.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.llvh::MutableArrayRef", align 8
  %agg.tmp8 = alloca %"class.llvh::MutableArrayRef", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %Input, i32 0, i32 0
  store ptr %Input.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %Input, i32 0, i32 1
  store i64 %Input.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %Width, ptr %Width.addr, align 4
  %frombool = zext i1 %IsSigned to i8
  store i8 %frombool, ptr %IsSigned.addr, align 1
  store i32 %RM, ptr %RM.addr, align 4
  store ptr %IsExact, ptr %IsExact.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %Input, i64 16, i1 false)
  %2 = load i32, ptr %Width.addr, align 4
  %3 = load i8, ptr %IsSigned.addr, align 1
  %tobool = trunc i8 %3 to i1
  %4 = load i32, ptr %RM.addr, align 4
  %5 = load ptr, ptr %IsExact.addr, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %9 = load i64, ptr %8, align 8
  %call3 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat16convertToIntegerENS_15MutableArrayRefImEEjbNS_11APFloatBase12roundingModeEPb(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr %7, i64 %9, i32 noundef %2, i1 noundef zeroext %tobool, i32 noundef %4, ptr noundef %5)
  store i32 %call3, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %do.body
  %call4 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call5 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call4)
  br i1 %call5, label %if.then6, label %if.end11

if.then6:                                         ; preds = %if.end
  %U7 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp8, ptr align 8 %Input, i64 16, i1 false)
  %10 = load i32, ptr %Width.addr, align 4
  %11 = load i8, ptr %IsSigned.addr, align 1
  %tobool9 = trunc i8 %11 to i1
  %12 = load i32, ptr %RM.addr, align 4
  %13 = load ptr, ptr %IsExact.addr, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp8, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp8, i32 0, i32 1
  %17 = load i64, ptr %16, align 8
  %call10 = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat16convertToIntegerENS_15MutableArrayRefImEEjbNS_11APFloatBase12roundingModeEPb(ptr noundef nonnull align 8 dereferenceable(16) %U7, ptr %15, i64 %17, i32 noundef %10, i1 noundef zeroext %tobool9, i32 noundef %12, ptr noundef %13)
  store i32 %call10, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end
  unreachable

do.end:                                           ; No predecessors!
  call void @llvm.trap()
  unreachable

return:                                           ; preds = %if.then6, %if.then
  %18 = load i32, ptr %retval, align 4
  ret i32 %18
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail13DoubleAPFloat16convertFromAPIntERKNS_5APIntEbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(12) %Input, i1 noundef zeroext %IsSigned, i32 noundef %RM) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Input.addr = alloca ptr, align 8
  %IsSigned.addr = alloca i8, align 1
  %RM.addr = alloca i32, align 4
  %Tmp = alloca %"class.llvh::APFloat", align 8
  %Ret = alloca i32, align 4
  %ref.tmp = alloca %"class.llvh::detail::DoubleAPFloat", align 8
  %ref.tmp2 = alloca %"class.llvh::APInt", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %Input, ptr %Input.addr, align 8
  %frombool = zext i1 %IsSigned to i8
  store i8 %frombool, ptr %IsSigned.addr, align 1
  store i32 %RM, ptr %RM.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(32) %Tmp, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL24semPPCDoubleDoubleLegacyE)
  %0 = load ptr, ptr %Input.addr, align 8
  %1 = load i8, ptr %IsSigned.addr, align 1
  %tobool = trunc i8 %1 to i1
  %2 = load i32, ptr %RM.addr, align 4
  %call = call noundef i32 @_ZN4llvh7APFloat16convertFromAPIntERKNS_5APIntEbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %Tmp, ptr noundef nonnull align 8 dereferenceable(12) %0, i1 noundef zeroext %tobool, i32 noundef %2)
  store i32 %call, ptr %Ret, align 4
  call void @_ZNK4llvh7APFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp2, ptr noundef nonnull align 8 dereferenceable(32) %Tmp)
  call void @_ZN4llvh6detail13DoubleAPFloatC1ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL18semPPCDoubleDoubleE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp2)
  %call3 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN4llvh6detail13DoubleAPFloataSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  call void @_ZN4llvh6detail13DoubleAPFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp2) #10
  %3 = load i32, ptr %Ret, align 4
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %Tmp) #10
  ret i32 %3
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZN4llvh7APFloat16convertFromAPIntERKNS_5APIntEbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(12) %Input, i1 noundef zeroext %IsSigned, i32 noundef %RM) #1 comdat align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %Input.addr = alloca ptr, align 8
  %IsSigned.addr = alloca i8, align 1
  %RM.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %Input, ptr %Input.addr, align 8
  %frombool = zext i1 %IsSigned to i8
  store i8 %frombool, ptr %IsSigned.addr, align 1
  store i32 %RM, ptr %RM.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %Input.addr, align 8
  %1 = load i8, ptr %IsSigned.addr, align 1
  %tobool = trunc i8 %1 to i1
  %2 = load i32, ptr %RM.addr, align 4
  %call3 = call noundef i32 @_ZN4llvh6detail9IEEEFloat16convertFromAPIntERKNS_5APIntEbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef nonnull align 8 dereferenceable(12) %0, i1 noundef zeroext %tobool, i32 noundef %2)
  store i32 %call3, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %do.body
  %call4 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call5 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call4)
  br i1 %call5, label %if.then6, label %if.end10

if.then6:                                         ; preds = %if.end
  %U7 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %Input.addr, align 8
  %4 = load i8, ptr %IsSigned.addr, align 1
  %tobool8 = trunc i8 %4 to i1
  %5 = load i32, ptr %RM.addr, align 4
  %call9 = call noundef i32 @_ZN4llvh6detail13DoubleAPFloat16convertFromAPIntERKNS_5APIntEbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %U7, ptr noundef nonnull align 8 dereferenceable(12) %3, i1 noundef zeroext %tobool8, i32 noundef %5)
  store i32 %call9, ptr %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end
  unreachable

do.end:                                           ; No predecessors!
  call void @llvm.trap()
  unreachable

return:                                           ; preds = %if.then6, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail13DoubleAPFloat30convertFromSignExtendedIntegerEPKmjbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %Input, i32 noundef %InputSize, i1 noundef zeroext %IsSigned, i32 noundef %RM) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Input.addr = alloca ptr, align 8
  %InputSize.addr = alloca i32, align 4
  %IsSigned.addr = alloca i8, align 1
  %RM.addr = alloca i32, align 4
  %Tmp = alloca %"class.llvh::APFloat", align 8
  %Ret = alloca i32, align 4
  %ref.tmp = alloca %"class.llvh::detail::DoubleAPFloat", align 8
  %ref.tmp2 = alloca %"class.llvh::APInt", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %Input, ptr %Input.addr, align 8
  store i32 %InputSize, ptr %InputSize.addr, align 4
  %frombool = zext i1 %IsSigned to i8
  store i8 %frombool, ptr %IsSigned.addr, align 1
  store i32 %RM, ptr %RM.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(32) %Tmp, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL24semPPCDoubleDoubleLegacyE)
  %0 = load ptr, ptr %Input.addr, align 8
  %1 = load i32, ptr %InputSize.addr, align 4
  %2 = load i8, ptr %IsSigned.addr, align 1
  %tobool = trunc i8 %2 to i1
  %3 = load i32, ptr %RM.addr, align 4
  %call = call noundef i32 @_ZN4llvh7APFloat30convertFromSignExtendedIntegerEPKmjbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %Tmp, ptr noundef %0, i32 noundef %1, i1 noundef zeroext %tobool, i32 noundef %3)
  store i32 %call, ptr %Ret, align 4
  call void @_ZNK4llvh7APFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp2, ptr noundef nonnull align 8 dereferenceable(32) %Tmp)
  call void @_ZN4llvh6detail13DoubleAPFloatC1ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL18semPPCDoubleDoubleE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp2)
  %call3 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN4llvh6detail13DoubleAPFloataSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  call void @_ZN4llvh6detail13DoubleAPFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp2) #10
  %4 = load i32, ptr %Ret, align 4
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %Tmp) #10
  ret i32 %4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZN4llvh7APFloat30convertFromSignExtendedIntegerEPKmjbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef %Input, i32 noundef %InputSize, i1 noundef zeroext %IsSigned, i32 noundef %RM) #1 comdat align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %Input.addr = alloca ptr, align 8
  %InputSize.addr = alloca i32, align 4
  %IsSigned.addr = alloca i8, align 1
  %RM.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %Input, ptr %Input.addr, align 8
  store i32 %InputSize, ptr %InputSize.addr, align 4
  %frombool = zext i1 %IsSigned to i8
  store i8 %frombool, ptr %IsSigned.addr, align 1
  store i32 %RM, ptr %RM.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %Input.addr, align 8
  %1 = load i32, ptr %InputSize.addr, align 4
  %2 = load i8, ptr %IsSigned.addr, align 1
  %tobool = trunc i8 %2 to i1
  %3 = load i32, ptr %RM.addr, align 4
  %call3 = call noundef i32 @_ZN4llvh6detail9IEEEFloat30convertFromSignExtendedIntegerEPKmjbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef %0, i32 noundef %1, i1 noundef zeroext %tobool, i32 noundef %3)
  store i32 %call3, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %do.body
  %call4 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call5 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call4)
  br i1 %call5, label %if.then6, label %if.end10

if.then6:                                         ; preds = %if.end
  %U7 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %4 = load ptr, ptr %Input.addr, align 8
  %5 = load i32, ptr %InputSize.addr, align 4
  %6 = load i8, ptr %IsSigned.addr, align 1
  %tobool8 = trunc i8 %6 to i1
  %7 = load i32, ptr %RM.addr, align 4
  %call9 = call noundef i32 @_ZN4llvh6detail13DoubleAPFloat30convertFromSignExtendedIntegerEPKmjbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %U7, ptr noundef %4, i32 noundef %5, i1 noundef zeroext %tobool8, i32 noundef %7)
  store i32 %call9, ptr %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end
  unreachable

do.end:                                           ; No predecessors!
  call void @llvm.trap()
  unreachable

return:                                           ; preds = %if.then6, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh6detail13DoubleAPFloat30convertFromZeroExtendedIntegerEPKmjbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %Input, i32 noundef %InputSize, i1 noundef zeroext %IsSigned, i32 noundef %RM) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Input.addr = alloca ptr, align 8
  %InputSize.addr = alloca i32, align 4
  %IsSigned.addr = alloca i8, align 1
  %RM.addr = alloca i32, align 4
  %Tmp = alloca %"class.llvh::APFloat", align 8
  %Ret = alloca i32, align 4
  %ref.tmp = alloca %"class.llvh::detail::DoubleAPFloat", align 8
  %ref.tmp2 = alloca %"class.llvh::APInt", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %Input, ptr %Input.addr, align 8
  store i32 %InputSize, ptr %InputSize.addr, align 4
  %frombool = zext i1 %IsSigned to i8
  store i8 %frombool, ptr %IsSigned.addr, align 1
  store i32 %RM, ptr %RM.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(32) %Tmp, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL24semPPCDoubleDoubleLegacyE)
  %0 = load ptr, ptr %Input.addr, align 8
  %1 = load i32, ptr %InputSize.addr, align 4
  %2 = load i8, ptr %IsSigned.addr, align 1
  %tobool = trunc i8 %2 to i1
  %3 = load i32, ptr %RM.addr, align 4
  %call = call noundef i32 @_ZN4llvh7APFloat30convertFromZeroExtendedIntegerEPKmjbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %Tmp, ptr noundef %0, i32 noundef %1, i1 noundef zeroext %tobool, i32 noundef %3)
  store i32 %call, ptr %Ret, align 4
  call void @_ZNK4llvh7APFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp2, ptr noundef nonnull align 8 dereferenceable(32) %Tmp)
  call void @_ZN4llvh6detail13DoubleAPFloatC1ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL18semPPCDoubleDoubleE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp2)
  %call3 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN4llvh6detail13DoubleAPFloataSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  call void @_ZN4llvh6detail13DoubleAPFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp2) #10
  %4 = load i32, ptr %Ret, align 4
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %Tmp) #10
  ret i32 %4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZN4llvh7APFloat30convertFromZeroExtendedIntegerEPKmjbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef %Input, i32 noundef %InputSize, i1 noundef zeroext %IsSigned, i32 noundef %RM) #1 comdat align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %Input.addr = alloca ptr, align 8
  %InputSize.addr = alloca i32, align 4
  %IsSigned.addr = alloca i8, align 1
  %RM.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %Input, ptr %Input.addr, align 8
  store i32 %InputSize, ptr %InputSize.addr, align 4
  %frombool = zext i1 %IsSigned to i8
  store i8 %frombool, ptr %IsSigned.addr, align 1
  store i32 %RM, ptr %RM.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %Input.addr, align 8
  %1 = load i32, ptr %InputSize.addr, align 4
  %2 = load i8, ptr %IsSigned.addr, align 1
  %tobool = trunc i8 %2 to i1
  %3 = load i32, ptr %RM.addr, align 4
  %call3 = call noundef i32 @_ZN4llvh6detail9IEEEFloat30convertFromZeroExtendedIntegerEPKmjbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef %0, i32 noundef %1, i1 noundef zeroext %tobool, i32 noundef %3)
  store i32 %call3, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %do.body
  %call4 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call5 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call4)
  br i1 %call5, label %if.then6, label %if.end10

if.then6:                                         ; preds = %if.end
  %U7 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %4 = load ptr, ptr %Input.addr, align 8
  %5 = load i32, ptr %InputSize.addr, align 4
  %6 = load i8, ptr %IsSigned.addr, align 1
  %tobool8 = trunc i8 %6 to i1
  %7 = load i32, ptr %RM.addr, align 4
  %call9 = call noundef i32 @_ZN4llvh6detail13DoubleAPFloat30convertFromZeroExtendedIntegerEPKmjbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %U7, ptr noundef %4, i32 noundef %5, i1 noundef zeroext %tobool8, i32 noundef %7)
  store i32 %call9, ptr %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end
  unreachable

do.end:                                           ; No predecessors!
  call void @llvm.trap()
  unreachable

return:                                           ; preds = %if.then6, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZNK4llvh6detail13DoubleAPFloat18convertToHexStringEPcjbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %DST, i32 noundef %HexDigits, i1 noundef zeroext %UpperCase, i32 noundef %RM) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %DST.addr = alloca ptr, align 8
  %HexDigits.addr = alloca i32, align 4
  %UpperCase.addr = alloca i8, align 1
  %RM.addr = alloca i32, align 4
  %ref.tmp = alloca %"class.llvh::APFloat", align 8
  %ref.tmp2 = alloca %"class.llvh::APInt", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %DST, ptr %DST.addr, align 8
  store i32 %HexDigits, ptr %HexDigits.addr, align 4
  %frombool = zext i1 %UpperCase to i8
  store i8 %frombool, ptr %UpperCase.addr, align 1
  store i32 %RM, ptr %RM.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZNK4llvh6detail13DoubleAPFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp2, ptr noundef nonnull align 8 dereferenceable(16) %this1)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL24semPPCDoubleDoubleLegacyE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp2)
  %0 = load ptr, ptr %DST.addr, align 8
  %1 = load i32, ptr %HexDigits.addr, align 4
  %2 = load i8, ptr %UpperCase.addr, align 1
  %tobool = trunc i8 %2 to i1
  %3 = load i32, ptr %RM.addr, align 4
  %call = call noundef i32 @_ZNK4llvh7APFloat18convertToHexStringEPcjbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp, ptr noundef %0, i32 noundef %1, i1 noundef zeroext %tobool, i32 noundef %3)
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp2) #10
  ret i32 %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZNK4llvh7APFloat18convertToHexStringEPcjbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef %DST, i32 noundef %HexDigits, i1 noundef zeroext %UpperCase, i32 noundef %RM) #1 comdat align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %DST.addr = alloca ptr, align 8
  %HexDigits.addr = alloca i32, align 4
  %UpperCase.addr = alloca i8, align 1
  %RM.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %DST, ptr %DST.addr, align 8
  store i32 %HexDigits, ptr %HexDigits.addr, align 4
  %frombool = zext i1 %UpperCase to i8
  store i8 %frombool, ptr %UpperCase.addr, align 1
  store i32 %RM, ptr %RM.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %DST.addr, align 8
  %1 = load i32, ptr %HexDigits.addr, align 4
  %2 = load i8, ptr %UpperCase.addr, align 1
  %tobool = trunc i8 %2 to i1
  %3 = load i32, ptr %RM.addr, align 4
  %call3 = call noundef i32 @_ZNK4llvh6detail9IEEEFloat18convertToHexStringEPcjbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef %0, i32 noundef %1, i1 noundef zeroext %tobool, i32 noundef %3)
  store i32 %call3, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %do.body
  %call4 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call5 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call4)
  br i1 %call5, label %if.then6, label %if.end10

if.then6:                                         ; preds = %if.end
  %U7 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %4 = load ptr, ptr %DST.addr, align 8
  %5 = load i32, ptr %HexDigits.addr, align 4
  %6 = load i8, ptr %UpperCase.addr, align 1
  %tobool8 = trunc i8 %6 to i1
  %7 = load i32, ptr %RM.addr, align 4
  %call9 = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat18convertToHexStringEPcjbNS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(16) %U7, ptr noundef %4, i32 noundef %5, i1 noundef zeroext %tobool8, i32 noundef %7)
  store i32 %call9, ptr %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end
  unreachable

do.end:                                           ; No predecessors!
  call void @llvm.trap()
  unreachable

return:                                           ; preds = %if.then6, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef zeroext i1 @_ZNK4llvh6detail13DoubleAPFloat10isDenormalEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.llvh::APFloat", align 8
  %cleanup.cond = alloca i1, align 1
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %cmp = icmp eq i32 %call, 2
  store i1 false, ptr %cleanup.cond, align 1
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call2 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats, i64 noundef 0)
  %call3 = call noundef zeroext i1 @_ZNK4llvh7APFloat10isDenormalEv(ptr noundef nonnull align 8 dereferenceable(32) %call2)
  br i1 %call3, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.rhs
  %Floats4 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call5 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats4, i64 noundef 1)
  %call6 = call noundef zeroext i1 @_ZNK4llvh7APFloat10isDenormalEv(ptr noundef nonnull align 8 dereferenceable(32) %call5)
  br i1 %call6, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false
  %Floats7 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call8 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats7, i64 noundef 0)
  %Floats9 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call10 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats9, i64 noundef 0)
  %Floats11 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call12 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats11, i64 noundef 1)
  call void @_ZNK4llvh7APFloatplERKS0_(ptr sret(%"class.llvh::APFloat") align 8 %ref.tmp, ptr noundef nonnull align 8 dereferenceable(32) %call10, ptr noundef nonnull align 8 dereferenceable(32) %call12)
  store i1 true, ptr %cleanup.cond, align 1
  %call13 = call noundef i32 @_ZNK4llvh7APFloat7compareERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %call8, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp)
  %cmp14 = icmp ne i32 %call13, 1
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false, %land.rhs
  %0 = phi i1 [ true, %lor.lhs.false ], [ true, %land.rhs ], [ %cmp14, %lor.rhs ]
  br label %land.end

land.end:                                         ; preds = %lor.end, %entry
  %1 = phi i1 [ false, %entry ], [ %0, %lor.end ]
  store i1 %1, ptr %retval, align 1
  %cleanup.is_active = load i1, ptr %cleanup.cond, align 1
  br i1 %cleanup.is_active, label %cleanup.action, label %cleanup.done

cleanup.action:                                   ; preds = %land.end
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp) #10
  br label %cleanup.done

cleanup.done:                                     ; preds = %cleanup.action, %land.end
  %2 = load i1, ptr %retval, align 1
  ret i1 %2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh7APFloat10isDenormalEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %call3 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat10isDenormalEv(ptr noundef nonnull align 8 dereferenceable(24) %U)
  store i1 %call3, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %do.body
  %call4 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call5 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call4)
  br i1 %call5, label %if.then6, label %if.end9

if.then6:                                         ; preds = %if.end
  %U7 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %call8 = call noundef zeroext i1 @_ZNK4llvh6detail13DoubleAPFloat10isDenormalEv(ptr noundef nonnull align 8 dereferenceable(16) %U7)
  store i1 %call8, ptr %retval, align 1
  br label %return

if.end9:                                          ; preds = %if.end
  unreachable

do.end:                                           ; No predecessors!
  call void @llvm.trap()
  unreachable

return:                                           ; preds = %if.then6, %if.then
  %0 = load i1, ptr %retval, align 1
  ret i1 %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZNK4llvh7APFloatplERKS0_(ptr noalias sret(%"class.llvh::APFloat") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(32) %RHS) #1 comdat align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  %nrvo = alloca i1, align 1
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store i1 false, ptr %nrvo, align 1
  call void @_ZN4llvh7APFloatC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %0 = load ptr, ptr %RHS.addr, align 8
  %call = call noundef i32 @_ZN4llvh7APFloat3addERKS0_NS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %0, i32 noundef 0)
  store i1 true, ptr %nrvo, align 1
  %nrvo.val = load i1, ptr %nrvo, align 1
  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused

nrvo.unused:                                      ; preds = %entry
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %agg.result) #10
  br label %nrvo.skipdtor

nrvo.skipdtor:                                    ; preds = %nrvo.unused, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef zeroext i1 @_ZNK4llvh6detail13DoubleAPFloat10isSmallestEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  %Tmp = alloca %"class.llvh::detail::DoubleAPFloat", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %cmp = icmp ne i32 %call, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  call void @_ZN4llvh6detail13DoubleAPFloatC1ERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %Tmp, ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %call2 = call noundef zeroext i1 @_ZNK4llvh6detail13DoubleAPFloat10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  call void @_ZN4llvh6detail13DoubleAPFloat12makeSmallestEb(ptr noundef nonnull align 8 dereferenceable(16) %Tmp, i1 noundef zeroext %call2)
  %call3 = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat7compareERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %Tmp, ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %cmp4 = icmp eq i32 %call3, 1
  store i1 %cmp4, ptr %retval, align 1
  call void @_ZN4llvh6detail13DoubleAPFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(16) %Tmp) #10
  br label %return

return:                                           ; preds = %if.end, %if.then
  %0 = load i1, ptr %retval, align 1
  ret i1 %0
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef zeroext i1 @_ZNK4llvh6detail13DoubleAPFloat9isLargestEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  %Tmp = alloca %"class.llvh::detail::DoubleAPFloat", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %cmp = icmp ne i32 %call, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  call void @_ZN4llvh6detail13DoubleAPFloatC1ERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %Tmp, ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %call2 = call noundef zeroext i1 @_ZNK4llvh6detail13DoubleAPFloat10isNegativeEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  call void @_ZN4llvh6detail13DoubleAPFloat11makeLargestEb(ptr noundef nonnull align 8 dereferenceable(16) %Tmp, i1 noundef zeroext %call2)
  %call3 = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat7compareERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %Tmp, ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %cmp4 = icmp eq i32 %call3, 1
  store i1 %cmp4, ptr %retval, align 1
  call void @_ZN4llvh6detail13DoubleAPFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(16) %Tmp) #10
  br label %return

return:                                           ; preds = %if.end, %if.then
  %0 = load i1, ptr %retval, align 1
  ret i1 %0
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef zeroext i1 @_ZNK4llvh6detail13DoubleAPFloat9isIntegerEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats, i64 noundef 0)
  %call2 = call noundef zeroext i1 @_ZNK4llvh7APFloat9isIntegerEv(ptr noundef nonnull align 8 dereferenceable(32) %call)
  br i1 %call2, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %Floats3 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call4 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats3, i64 noundef 1)
  %call5 = call noundef zeroext i1 @_ZNK4llvh7APFloat9isIntegerEv(ptr noundef nonnull align 8 dereferenceable(32) %call4)
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %0 = phi i1 [ false, %entry ], [ %call5, %land.rhs ]
  ret i1 %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh7APFloat9isIntegerEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %call3 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat9isIntegerEv(ptr noundef nonnull align 8 dereferenceable(24) %U)
  store i1 %call3, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %do.body
  %call4 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call5 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call4)
  br i1 %call5, label %if.then6, label %if.end9

if.then6:                                         ; preds = %if.end
  %U7 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %call8 = call noundef zeroext i1 @_ZNK4llvh6detail13DoubleAPFloat9isIntegerEv(ptr noundef nonnull align 8 dereferenceable(16) %U7)
  store i1 %call8, ptr %retval, align 1
  br label %return

if.end9:                                          ; preds = %if.end
  unreachable

do.end:                                           ; No predecessors!
  call void @llvm.trap()
  unreachable

return:                                           ; preds = %if.then6, %if.then
  %0 = load i1, ptr %retval, align 1
  ret i1 %0
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZNK4llvh6detail13DoubleAPFloat8toStringERNS_15SmallVectorImplIcEEjjb(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %Str, i32 noundef %FormatPrecision, i32 noundef %FormatMaxPadding, i1 noundef zeroext %TruncateZero) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Str.addr = alloca ptr, align 8
  %FormatPrecision.addr = alloca i32, align 4
  %FormatMaxPadding.addr = alloca i32, align 4
  %TruncateZero.addr = alloca i8, align 1
  %ref.tmp = alloca %"class.llvh::APFloat", align 8
  %ref.tmp2 = alloca %"class.llvh::APInt", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %Str, ptr %Str.addr, align 8
  store i32 %FormatPrecision, ptr %FormatPrecision.addr, align 4
  store i32 %FormatMaxPadding, ptr %FormatMaxPadding.addr, align 4
  %frombool = zext i1 %TruncateZero to i8
  store i8 %frombool, ptr %TruncateZero.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZNK4llvh6detail13DoubleAPFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp2, ptr noundef nonnull align 8 dereferenceable(16) %this1)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL24semPPCDoubleDoubleLegacyE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp2)
  %0 = load ptr, ptr %Str.addr, align 8
  %1 = load i32, ptr %FormatPrecision.addr, align 4
  %2 = load i32, ptr %FormatMaxPadding.addr, align 4
  %3 = load i8, ptr %TruncateZero.addr, align 1
  %tobool = trunc i8 %3 to i1
  call void @_ZNK4llvh7APFloat8toStringERNS_15SmallVectorImplIcEEjjb(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp, ptr noundef nonnull align 8 dereferenceable(16) %0, i32 noundef %1, i32 noundef %2, i1 noundef zeroext %tobool)
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp2) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZNK4llvh7APFloat8toStringERNS_15SmallVectorImplIcEEjjb(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(16) %Str, i32 noundef %FormatPrecision, i32 noundef %FormatMaxPadding, i1 noundef zeroext %TruncateZero) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Str.addr = alloca ptr, align 8
  %FormatPrecision.addr = alloca i32, align 4
  %FormatMaxPadding.addr = alloca i32, align 4
  %TruncateZero.addr = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  store ptr %Str, ptr %Str.addr, align 8
  store i32 %FormatPrecision, ptr %FormatPrecision.addr, align 4
  store i32 %FormatMaxPadding, ptr %FormatMaxPadding.addr, align 4
  %frombool = zext i1 %TruncateZero to i8
  store i8 %frombool, ptr %TruncateZero.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %Str.addr, align 8
  %1 = load i32, ptr %FormatPrecision.addr, align 4
  %2 = load i32, ptr %FormatMaxPadding.addr, align 4
  %3 = load i8, ptr %TruncateZero.addr, align 1
  %tobool = trunc i8 %3 to i1
  call void @_ZNK4llvh6detail9IEEEFloat8toStringERNS_15SmallVectorImplIcEEjjb(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef nonnull align 8 dereferenceable(16) %0, i32 noundef %1, i32 noundef %2, i1 noundef zeroext %tobool)
  br label %do.end

if.end:                                           ; preds = %do.body
  %call3 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call4 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call3)
  br i1 %call4, label %if.then5, label %if.end8

if.then5:                                         ; preds = %if.end
  %U6 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %4 = load ptr, ptr %Str.addr, align 8
  %5 = load i32, ptr %FormatPrecision.addr, align 4
  %6 = load i32, ptr %FormatMaxPadding.addr, align 4
  %7 = load i8, ptr %TruncateZero.addr, align 1
  %tobool7 = trunc i8 %7 to i1
  call void @_ZNK4llvh6detail13DoubleAPFloat8toStringERNS_15SmallVectorImplIcEEjjb(ptr noundef nonnull align 8 dereferenceable(16) %U6, ptr noundef nonnull align 8 dereferenceable(16) %4, i32 noundef %5, i32 noundef %6, i1 noundef zeroext %tobool7)
  br label %do.end

if.end8:                                          ; preds = %if.end
  unreachable

do.end:                                           ; preds = %if.then5, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef zeroext i1 @_ZNK4llvh6detail13DoubleAPFloat15getExactInverseEPNS_7APFloatE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %inv) #1 align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  %inv.addr = alloca ptr, align 8
  %Tmp = alloca %"class.llvh::APFloat", align 8
  %ref.tmp = alloca %"class.llvh::APInt", align 8
  %cleanup.dest.slot = alloca i32, align 4
  %Inv = alloca %"class.llvh::APFloat", align 8
  %Ret = alloca i8, align 1
  %ref.tmp3 = alloca %"class.llvh::APFloat", align 8
  %ref.tmp4 = alloca %"class.llvh::APInt", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %inv, ptr %inv.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZNK4llvh6detail13DoubleAPFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp, ptr noundef nonnull align 8 dereferenceable(16) %this1)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %Tmp, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL24semPPCDoubleDoubleLegacyE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp) #10
  %0 = load ptr, ptr %inv.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = call noundef zeroext i1 @_ZNK4llvh7APFloat15getExactInverseEPS0_(ptr noundef nonnull align 8 dereferenceable(32) %Tmp, ptr noundef null)
  store i1 %call, ptr %retval, align 1
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %entry
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(32) %Inv, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL24semPPCDoubleDoubleLegacyE)
  %call2 = call noundef zeroext i1 @_ZNK4llvh7APFloat15getExactInverseEPS0_(ptr noundef nonnull align 8 dereferenceable(32) %Tmp, ptr noundef %Inv)
  %frombool = zext i1 %call2 to i8
  store i8 %frombool, ptr %Ret, align 1
  call void @_ZNK4llvh7APFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp4, ptr noundef nonnull align 8 dereferenceable(32) %Inv)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp3, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL18semPPCDoubleDoubleE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp4)
  %1 = load ptr, ptr %inv.addr, align 8
  %call5 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN4llvh7APFloataSEOS0_(ptr noundef nonnull align 8 dereferenceable(32) %1, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp3)
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp3) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp4) #10
  %2 = load i8, ptr %Ret, align 1
  %tobool6 = trunc i8 %2 to i1
  store i1 %tobool6, ptr %retval, align 1
  store i32 1, ptr %cleanup.dest.slot, align 4
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %Inv) #10
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %Tmp) #10
  %3 = load i1, ptr %retval, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh7APFloat15getExactInverseEPS0_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef %inv) #1 comdat align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  %inv.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %inv, ptr %inv.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %inv.addr, align 8
  %call3 = call noundef zeroext i1 @_ZNK4llvh6detail9IEEEFloat15getExactInverseEPNS_7APFloatE(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef %0)
  store i1 %call3, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %do.body
  %call4 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call5 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call4)
  br i1 %call5, label %if.then6, label %if.end9

if.then6:                                         ; preds = %if.end
  %U7 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %inv.addr, align 8
  %call8 = call noundef zeroext i1 @_ZNK4llvh6detail13DoubleAPFloat15getExactInverseEPNS_7APFloatE(ptr noundef nonnull align 8 dereferenceable(16) %U7, ptr noundef %1)
  store i1 %call8, ptr %retval, align 1
  br label %return

if.end9:                                          ; preds = %if.end
  unreachable

do.end:                                           ; No predecessors!
  call void @llvm.trap()
  unreachable

return:                                           ; preds = %if.then6, %if.then
  %2 = load i1, ptr %retval, align 1
  ret i1 %2
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail6scalbnENS0_13DoubleAPFloatEiNS_11APFloatBase12roundingModeE(ptr noalias sret(%"class.llvh::detail::DoubleAPFloat") align 8 %agg.result, ptr noundef %Arg, i32 noundef %Exp, i32 noundef %RM) #1 {
entry:
  %result.ptr = alloca ptr, align 8
  %Arg.indirect_addr = alloca ptr, align 8
  %Exp.addr = alloca i32, align 4
  %RM.addr = alloca i32, align 4
  %ref.tmp = alloca %"class.llvh::APFloat", align 8
  %agg.tmp = alloca %"class.llvh::APFloat", align 8
  %ref.tmp1 = alloca %"class.llvh::APFloat", align 8
  %agg.tmp2 = alloca %"class.llvh::APFloat", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %Arg, ptr %Arg.indirect_addr, align 8
  store i32 %Exp, ptr %Exp.addr, align 4
  store i32 %RM, ptr %RM.addr, align 4
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %Arg, i32 0, i32 1
  %call = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats, i64 noundef 0)
  call void @_ZN4llvh7APFloatC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(32) %call)
  %0 = load i32, ptr %Exp.addr, align 4
  %1 = load i32, ptr %RM.addr, align 4
  call void @_ZN4llvh6scalbnENS_7APFloatEiNS_11APFloatBase12roundingModeE(ptr sret(%"class.llvh::APFloat") align 8 %ref.tmp, ptr noundef %agg.tmp, i32 noundef %0, i32 noundef %1)
  %Floats3 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %Arg, i32 0, i32 1
  %call4 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats3, i64 noundef 1)
  call void @_ZN4llvh7APFloatC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(32) %call4)
  %2 = load i32, ptr %Exp.addr, align 4
  %3 = load i32, ptr %RM.addr, align 4
  call void @_ZN4llvh6scalbnENS_7APFloatEiNS_11APFloatBase12roundingModeE(ptr sret(%"class.llvh::APFloat") align 8 %ref.tmp1, ptr noundef %agg.tmp2, i32 noundef %2, i32 noundef %3)
  call void @_ZN4llvh6detail13DoubleAPFloatC1ERKNS_12fltSemanticsEONS_7APFloatES6_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL18semPPCDoubleDoubleE, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp1)
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp1) #10
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp2) #10
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp) #10
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh6scalbnENS_7APFloatEiNS_11APFloatBase12roundingModeE(ptr noalias sret(%"class.llvh::APFloat") align 8 %agg.result, ptr noundef %X, i32 noundef %Exp, i32 noundef %RM) #1 comdat {
entry:
  %result.ptr = alloca ptr, align 8
  %X.indirect_addr = alloca ptr, align 8
  %Exp.addr = alloca i32, align 4
  %RM.addr = alloca i32, align 4
  %agg.tmp = alloca %"class.llvh::detail::IEEEFloat", align 8
  %agg.tmp2 = alloca %"class.llvh::detail::IEEEFloat", align 8
  %agg.tmp7 = alloca %"class.llvh::detail::DoubleAPFloat", align 8
  %agg.tmp8 = alloca %"class.llvh::detail::DoubleAPFloat", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %X, ptr %X.indirect_addr, align 8
  store i32 %Exp, ptr %Exp.addr, align 4
  store i32 %RM, ptr %RM.addr, align 4
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %X)
  %call1 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %X, i32 0, i32 1
  call void @_ZN4llvh6detail9IEEEFloatC1ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(24) %U)
  %0 = load i32, ptr %Exp.addr, align 4
  %1 = load i32, ptr %RM.addr, align 4
  call void @_ZN4llvh6detail6scalbnENS0_9IEEEFloatEiNS_11APFloatBase12roundingModeE(ptr sret(%"class.llvh::detail::IEEEFloat") align 8 %agg.tmp, ptr noundef %agg.tmp2, i32 noundef %0, i32 noundef %1)
  %call3 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %X)
  call void @_ZN4llvh7APFloatC2ENS_6detail9IEEEFloatERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(32) %agg.result, ptr noundef %agg.tmp, ptr noundef nonnull align 4 dereferenceable(12) %call3)
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp) #10
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp2) #10
  br label %return

if.end:                                           ; preds = %entry
  %call4 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %X)
  %call5 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call4)
  br i1 %call5, label %if.then6, label %if.end11

if.then6:                                         ; preds = %if.end
  %U9 = getelementptr inbounds %"class.llvh::APFloat", ptr %X, i32 0, i32 1
  call void @_ZN4llvh6detail13DoubleAPFloatC1ERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %agg.tmp8, ptr noundef nonnull align 8 dereferenceable(16) %U9)
  %2 = load i32, ptr %Exp.addr, align 4
  %3 = load i32, ptr %RM.addr, align 4
  call void @_ZN4llvh6detail6scalbnENS0_13DoubleAPFloatEiNS_11APFloatBase12roundingModeE(ptr sret(%"class.llvh::detail::DoubleAPFloat") align 8 %agg.tmp7, ptr noundef %agg.tmp8, i32 noundef %2, i32 noundef %3)
  %call10 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %X)
  call void @_ZN4llvh7APFloatC2ENS_6detail13DoubleAPFloatERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(32) %agg.result, ptr noundef %agg.tmp7, ptr noundef nonnull align 4 dereferenceable(12) %call10)
  call void @_ZN4llvh6detail13DoubleAPFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(16) %agg.tmp7) #10
  call void @_ZN4llvh6detail13DoubleAPFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(16) %agg.tmp8) #10
  br label %return

if.end11:                                         ; preds = %if.end
  unreachable

return:                                           ; preds = %if.then6, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh6detail5frexpERKNS0_13DoubleAPFloatERiNS_11APFloatBase12roundingModeE(ptr noalias sret(%"class.llvh::detail::DoubleAPFloat") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(16) %Arg, ptr noundef nonnull align 4 dereferenceable(4) %Exp, i32 noundef %RM) #1 {
entry:
  %result.ptr = alloca ptr, align 8
  %Arg.addr = alloca ptr, align 8
  %Exp.addr = alloca ptr, align 8
  %RM.addr = alloca i32, align 4
  %First = alloca %"class.llvh::APFloat", align 8
  %Second = alloca %"class.llvh::APFloat", align 8
  %ref.tmp = alloca %"class.llvh::APFloat", align 8
  %agg.tmp = alloca %"class.llvh::APFloat", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %Arg, ptr %Arg.addr, align 8
  store ptr %Exp, ptr %Exp.addr, align 8
  store i32 %RM, ptr %RM.addr, align 4
  %0 = load ptr, ptr %Arg.addr, align 8
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %0, i32 0, i32 1
  %call = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats, i64 noundef 0)
  %1 = load ptr, ptr %Exp.addr, align 8
  %2 = load i32, ptr %RM.addr, align 4
  call void @_ZN4llvh5frexpERKNS_7APFloatERiNS_11APFloatBase12roundingModeE(ptr sret(%"class.llvh::APFloat") align 8 %First, ptr noundef nonnull align 8 dereferenceable(32) %call, ptr noundef nonnull align 4 dereferenceable(4) %1, i32 noundef %2)
  %3 = load ptr, ptr %Arg.addr, align 8
  %Floats1 = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %3, i32 0, i32 1
  %call2 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats1, i64 noundef 1)
  call void @_ZN4llvh7APFloatC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %Second, ptr noundef nonnull align 8 dereferenceable(32) %call2)
  %4 = load ptr, ptr %Arg.addr, align 8
  %call3 = call noundef i32 @_ZNK4llvh6detail13DoubleAPFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(16) %4)
  %cmp = icmp eq i32 %call3, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @_ZN4llvh7APFloatC2ERKS0_(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(32) %Second)
  %5 = load ptr, ptr %Exp.addr, align 8
  %6 = load i32, ptr %5, align 4
  %sub = sub nsw i32 0, %6
  %7 = load i32, ptr %RM.addr, align 4
  call void @_ZN4llvh6scalbnENS_7APFloatEiNS_11APFloatBase12roundingModeE(ptr sret(%"class.llvh::APFloat") align 8 %ref.tmp, ptr noundef %agg.tmp, i32 noundef %sub, i32 noundef %7)
  %call4 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN4llvh7APFloataSEOS0_(ptr noundef nonnull align 8 dereferenceable(32) %Second, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp)
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp) #10
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp) #10
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @_ZN4llvh6detail13DoubleAPFloatC1ERKNS_12fltSemanticsEONS_7APFloatES6_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL18semPPCDoubleDoubleE, ptr noundef nonnull align 8 dereferenceable(32) %First, ptr noundef nonnull align 8 dereferenceable(32) %Second)
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %Second) #10
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %First) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh5frexpERKNS_7APFloatERiNS_11APFloatBase12roundingModeE(ptr noalias sret(%"class.llvh::APFloat") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %X, ptr noundef nonnull align 4 dereferenceable(4) %Exp, i32 noundef %RM) #1 comdat {
entry:
  %result.ptr = alloca ptr, align 8
  %X.addr = alloca ptr, align 8
  %Exp.addr = alloca ptr, align 8
  %RM.addr = alloca i32, align 4
  %agg.tmp = alloca %"class.llvh::detail::IEEEFloat", align 8
  %agg.tmp6 = alloca %"class.llvh::detail::DoubleAPFloat", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %X, ptr %X.addr, align 8
  store ptr %Exp, ptr %Exp.addr, align 8
  store i32 %RM, ptr %RM.addr, align 4
  %0 = load ptr, ptr %X.addr, align 8
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %0)
  %call1 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call)
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %X.addr, align 8
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %Exp.addr, align 8
  %3 = load i32, ptr %RM.addr, align 4
  call void @_ZN4llvh6detail5frexpERKNS0_9IEEEFloatERiNS_11APFloatBase12roundingModeE(ptr sret(%"class.llvh::detail::IEEEFloat") align 8 %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef nonnull align 4 dereferenceable(4) %2, i32 noundef %3)
  %4 = load ptr, ptr %X.addr, align 8
  %call2 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %4)
  call void @_ZN4llvh7APFloatC2ENS_6detail9IEEEFloatERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(32) %agg.result, ptr noundef %agg.tmp, ptr noundef nonnull align 4 dereferenceable(12) %call2)
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp) #10
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %X.addr, align 8
  %call3 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %5)
  %call4 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call3)
  br i1 %call4, label %if.then5, label %if.end9

if.then5:                                         ; preds = %if.end
  %6 = load ptr, ptr %X.addr, align 8
  %U7 = getelementptr inbounds %"class.llvh::APFloat", ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %Exp.addr, align 8
  %8 = load i32, ptr %RM.addr, align 4
  call void @_ZN4llvh6detail5frexpERKNS0_13DoubleAPFloatERiNS_11APFloatBase12roundingModeE(ptr sret(%"class.llvh::detail::DoubleAPFloat") align 8 %agg.tmp6, ptr noundef nonnull align 8 dereferenceable(16) %U7, ptr noundef nonnull align 4 dereferenceable(4) %7, i32 noundef %8)
  %9 = load ptr, ptr %X.addr, align 8
  %call8 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %9)
  call void @_ZN4llvh7APFloatC2ENS_6detail13DoubleAPFloatERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(32) %agg.result, ptr noundef %agg.tmp6, ptr noundef nonnull align 4 dereferenceable(12) %call8)
  call void @_ZN4llvh6detail13DoubleAPFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(16) %agg.tmp6) #10
  br label %return

if.end9:                                          ; preds = %if.end
  unreachable

return:                                           ; preds = %if.then5, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh7APFloat7StorageC2ENS_6detail9IEEEFloatERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %F, ptr noundef nonnull align 4 dereferenceable(12) %Semantics) unnamed_addr #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %F.indirect_addr = alloca ptr, align 8
  %Semantics.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.llvh::APFloat", align 8
  %agg.tmp = alloca %"class.llvh::detail::IEEEFloat", align 8
  %ref.tmp5 = alloca %"class.llvh::APFloat", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %F, ptr %F.indirect_addr, align 8
  store ptr %Semantics, ptr %Semantics.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %Semantics.addr, align 8
  %call = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %0)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @_ZN4llvh6detail9IEEEFloatC1EOS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %F)
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %Semantics.addr, align 8
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %1)
  br i1 %call2, label %if.then3, label %if.end6

if.then3:                                         ; preds = %if.end
  %2 = load ptr, ptr %Semantics.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloatC1EOS1_(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %F)
  %call4 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh6detail9IEEEFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(24) %F)
  call void @_ZN4llvh7APFloatC2ENS_6detail9IEEEFloatERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp, ptr noundef %agg.tmp, ptr noundef nonnull align 4 dereferenceable(12) %call4)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp5, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL13semIEEEdoubleE)
  call void @_ZN4llvh6detail13DoubleAPFloatC1ERKNS_12fltSemanticsEONS_7APFloatES6_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 4 dereferenceable(12) %2, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp5)
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp5) #10
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp) #10
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp) #10
  br label %return

if.end6:                                          ; preds = %if.end
  unreachable

return:                                           ; preds = %if.then3, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %Semantics) #1 comdat align 2 {
entry:
  %Semantics.addr = alloca ptr, align 8
  store ptr %Semantics, ptr %Semantics.addr, align 8
  %0 = load ptr, ptr %Semantics.addr, align 8
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZN4llvh11APFloatBase15PPCDoubleDoubleEv() #16
  %cmp = icmp ne ptr %0, %call
  ret i1 %cmp
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %Semantics) #1 comdat align 2 {
entry:
  %Semantics.addr = alloca ptr, align 8
  store ptr %Semantics, ptr %Semantics.addr, align 8
  %0 = load ptr, ptr %Semantics.addr, align 8
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZN4llvh11APFloatBase15PPCDoubleDoubleEv() #16
  %cmp = icmp eq ptr %0, %call
  ret i1 %cmp
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %U, align 8
  ret ptr %0
}

; Function Attrs: cold noreturn nounwind memory(inaccessiblemem: write)
declare void @llvm.trap() #8

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsENS_9StringRefE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 4 dereferenceable(12) %Semantics, ptr %S.coerce0, i64 %S.coerce1) unnamed_addr #1 align 2 {
entry:
  %S = alloca %"class.llvh::StringRef", align 8
  %this.addr = alloca ptr, align 8
  %Semantics.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.llvh::StringRef", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %S, i32 0, i32 0
  store ptr %S.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %S, i32 0, i32 1
  store i64 %S.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %Semantics, ptr %Semantics.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %2 = load ptr, ptr %Semantics.addr, align 8
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(32) %this1, ptr noundef nonnull align 4 dereferenceable(12) %2)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %S, i64 16, i1 false)
  %3 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %6 = load i64, ptr %5, align 8
  %call = call noundef i32 @_ZN4llvh7APFloat17convertFromStringENS_9StringRefENS_11APFloatBase12roundingModeE(ptr noundef nonnull align 8 dereferenceable(32) %this1, ptr %4, i64 %6, i32 noundef 0)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZN4llvh7APFloat7convertERKNS_12fltSemanticsENS_11APFloatBase12roundingModeEPb(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 4 dereferenceable(12) %ToSemantics, i32 noundef %RM, ptr noundef %losesInfo) #1 align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %ToSemantics.addr = alloca ptr, align 8
  %RM.addr = alloca i32, align 4
  %losesInfo.addr = alloca ptr, align 8
  %Ret = alloca i32, align 4
  %ref.tmp = alloca %"class.llvh::APFloat", align 8
  %ref.tmp15 = alloca %"class.llvh::APInt", align 8
  %Ret24 = alloca i32, align 4
  %ref.tmp27 = alloca %"class.llvh::APFloat", align 8
  %agg.tmp = alloca %"class.llvh::detail::IEEEFloat", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %ToSemantics, ptr %ToSemantics.addr, align 8
  store i32 %RM, ptr %RM.addr, align 4
  store ptr %losesInfo, ptr %losesInfo.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %0 = load ptr, ptr %ToSemantics.addr, align 8
  %cmp = icmp eq ptr %call, %0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %losesInfo.addr, align 8
  store i8 0, ptr %1, align 1
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %call2 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call3 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call2)
  br i1 %call3, label %land.lhs.true, label %if.end7

land.lhs.true:                                    ; preds = %if.end
  %2 = load ptr, ptr %ToSemantics.addr, align 8
  %call4 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %2)
  br i1 %call4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %land.lhs.true
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %ToSemantics.addr, align 8
  %4 = load i32, ptr %RM.addr, align 4
  %5 = load ptr, ptr %losesInfo.addr, align 8
  %call6 = call noundef i32 @_ZN4llvh6detail9IEEEFloat7convertERKNS_12fltSemanticsENS_11APFloatBase12roundingModeEPb(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef nonnull align 4 dereferenceable(12) %3, i32 noundef %4, ptr noundef %5)
  store i32 %call6, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %if.end
  %call8 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call9 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call8)
  br i1 %call9, label %land.lhs.true10, label %if.end18

land.lhs.true10:                                  ; preds = %if.end7
  %6 = load ptr, ptr %ToSemantics.addr, align 8
  %call11 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %6)
  br i1 %call11, label %if.then12, label %if.end18

if.then12:                                        ; preds = %land.lhs.true10
  %U13 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %7 = load i32, ptr %RM.addr, align 4
  %8 = load ptr, ptr %losesInfo.addr, align 8
  %call14 = call noundef i32 @_ZN4llvh6detail9IEEEFloat7convertERKNS_12fltSemanticsENS_11APFloatBase12roundingModeEPb(ptr noundef nonnull align 8 dereferenceable(24) %U13, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL24semPPCDoubleDoubleLegacyE, i32 noundef %7, ptr noundef %8)
  store i32 %call14, ptr %Ret, align 4
  %9 = load ptr, ptr %ToSemantics.addr, align 8
  %U16 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  call void @_ZNK4llvh6detail9IEEEFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp15, ptr noundef nonnull align 8 dereferenceable(24) %U16)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(12) %9, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp15)
  %call17 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN4llvh7APFloataSEOS0_(ptr noundef nonnull align 8 dereferenceable(32) %this1, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp)
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp) #10
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp15) #10
  %10 = load i32, ptr %Ret, align 4
  store i32 %10, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %land.lhs.true10, %if.end7
  %call19 = call noundef nonnull align 4 dereferenceable(12) ptr @_ZNK4llvh7APFloat12getSemanticsEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call20 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %call19)
  br i1 %call20, label %land.lhs.true21, label %if.end30

land.lhs.true21:                                  ; preds = %if.end18
  %11 = load ptr, ptr %ToSemantics.addr, align 8
  %call22 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %11)
  br i1 %call22, label %if.then23, label %if.end30

if.then23:                                        ; preds = %land.lhs.true21
  %call25 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN4llvh7APFloat7getIEEEEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %12 = load ptr, ptr %ToSemantics.addr, align 8
  %13 = load i32, ptr %RM.addr, align 4
  %14 = load ptr, ptr %losesInfo.addr, align 8
  %call26 = call noundef i32 @_ZN4llvh6detail9IEEEFloat7convertERKNS_12fltSemanticsENS_11APFloatBase12roundingModeEPb(ptr noundef nonnull align 8 dereferenceable(24) %call25, ptr noundef nonnull align 4 dereferenceable(12) %12, i32 noundef %13, ptr noundef %14)
  store i32 %call26, ptr %Ret24, align 4
  %call28 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN4llvh7APFloat7getIEEEEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  call void @_ZN4llvh6detail9IEEEFloatC1EOS1_(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %call28)
  %15 = load ptr, ptr %ToSemantics.addr, align 8
  call void @_ZN4llvh7APFloatC2ENS_6detail9IEEEFloatERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp27, ptr noundef %agg.tmp, ptr noundef nonnull align 4 dereferenceable(12) %15)
  %call29 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN4llvh7APFloataSEOS0_(ptr noundef nonnull align 8 dereferenceable(32) %this1, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp27)
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp27) #10
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp) #10
  %16 = load i32, ptr %Ret24, align 4
  store i32 %16, ptr %retval, align 4
  br label %return

if.end30:                                         ; preds = %land.lhs.true21, %if.end18
  unreachable

return:                                           ; preds = %if.then23, %if.then12, %if.then5, %if.then
  %17 = load i32, ptr %retval, align 4
  ret i32 %17
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 8 dereferenceable(24) ptr @_ZN4llvh7APFloat7getIEEEEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %U, align 8
  %call = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %0)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %U2 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  store ptr %U2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %U3 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %U3, align 8
  %call4 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %1)
  br i1 %call4, label %if.then5, label %if.end9

if.then5:                                         ; preds = %if.end
  %U6 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %call7 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN4llvh6detail13DoubleAPFloat8getFirstEv(ptr noundef nonnull align 8 dereferenceable(16) %U6)
  %U8 = getelementptr inbounds %"class.llvh::APFloat", ptr %call7, i32 0, i32 1
  store ptr %U8, ptr %retval, align 8
  br label %return

if.end9:                                          ; preds = %if.end
  unreachable

return:                                           ; preds = %if.then5, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZN4llvh7APFloat15getAllOnesValueEjb(ptr noalias sret(%"class.llvh::APFloat") align 8 %agg.result, i32 noundef %BitWidth, i1 noundef zeroext %isIEEE) #1 align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %BitWidth.addr = alloca i32, align 4
  %isIEEE.addr = alloca i8, align 1
  %ref.tmp = alloca %"class.llvh::APInt", align 8
  %ref.tmp2 = alloca %"class.llvh::APInt", align 8
  %ref.tmp4 = alloca %"class.llvh::APInt", align 8
  %ref.tmp6 = alloca %"class.llvh::APInt", align 8
  %ref.tmp8 = alloca %"class.llvh::APInt", align 8
  %ref.tmp9 = alloca %"class.llvh::APInt", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store i32 %BitWidth, ptr %BitWidth.addr, align 4
  %frombool = zext i1 %isIEEE to i8
  store i8 %frombool, ptr %isIEEE.addr, align 1
  %0 = load i8, ptr %isIEEE.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %BitWidth.addr, align 4
  switch i32 %1, label %sw.default [
    i32 16, label %sw.bb
    i32 32, label %sw.bb1
    i32 64, label %sw.bb3
    i32 80, label %sw.bb5
    i32 128, label %sw.bb7
  ]

sw.bb:                                            ; preds = %if.then
  %2 = load i32, ptr %BitWidth.addr, align 4
  call void @_ZN4llvh5APInt15getAllOnesValueEj(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp, i32 noundef %2)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %agg.result, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL11semIEEEhalfE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp) #10
  br label %return

sw.bb1:                                           ; preds = %if.then
  %3 = load i32, ptr %BitWidth.addr, align 4
  call void @_ZN4llvh5APInt15getAllOnesValueEj(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp2, i32 noundef %3)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %agg.result, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL13semIEEEsingleE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp2)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp2) #10
  br label %return

sw.bb3:                                           ; preds = %if.then
  %4 = load i32, ptr %BitWidth.addr, align 4
  call void @_ZN4llvh5APInt15getAllOnesValueEj(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp4, i32 noundef %4)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %agg.result, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL13semIEEEdoubleE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp4)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp4) #10
  br label %return

sw.bb5:                                           ; preds = %if.then
  %5 = load i32, ptr %BitWidth.addr, align 4
  call void @_ZN4llvh5APInt15getAllOnesValueEj(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp6, i32 noundef %5)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %agg.result, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL20semX87DoubleExtendedE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp6)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp6) #10
  br label %return

sw.bb7:                                           ; preds = %if.then
  %6 = load i32, ptr %BitWidth.addr, align 4
  call void @_ZN4llvh5APInt15getAllOnesValueEj(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp8, i32 noundef %6)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %agg.result, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL11semIEEEquadE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp8)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp8) #10
  br label %return

sw.default:                                       ; preds = %if.then
  unreachable

if.else:                                          ; preds = %entry
  %7 = load i32, ptr %BitWidth.addr, align 4
  call void @_ZN4llvh5APInt15getAllOnesValueEj(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp9, i32 noundef %7)
  call void @_ZN4llvh7APFloatC2ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(32) %agg.result, ptr noundef nonnull align 4 dereferenceable(12) @_ZN4llvhL18semPPCDoubleDoubleE, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp9)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp9) #10
  br label %return

return:                                           ; preds = %if.else, %sw.bb7, %sw.bb5, %sw.bb3, %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh5APInt15getAllOnesValueEj(ptr noalias sret(%"class.llvh::APInt") align 8 %agg.result, i32 noundef %numBits) #1 comdat align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %numBits.addr = alloca i32, align 4
  store ptr %agg.result, ptr %result.ptr, align 8
  store i32 %numBits, ptr %numBits.addr, align 4
  %0 = load i32, ptr %numBits.addr, align 4
  call void @_ZN4llvh5APIntC2Ejmb(ptr noundef nonnull align 8 dereferenceable(12) %agg.result, i32 noundef %0, i64 noundef -1, i1 noundef zeroext true)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZNK4llvh7APFloat5printERNS_11raw_ostreamE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(36) %OS) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %OS.addr = alloca ptr, align 8
  %Buffer = alloca %"class.llvh::SmallVector.4", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %OS, ptr %OS.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4llvh11SmallVectorIcLj16EEC2Ev(ptr noundef nonnull align 8 dereferenceable(32) %Buffer)
  call void @_ZNK4llvh7APFloat8toStringERNS_15SmallVectorImplIcEEjjb(ptr noundef nonnull align 8 dereferenceable(32) %this1, ptr noundef nonnull align 8 dereferenceable(16) %Buffer, i32 noundef 0, i32 noundef 3, i1 noundef zeroext true)
  %0 = load ptr, ptr %OS.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(36) ptr @_ZN4llvh11raw_ostreamlsERKNS_15SmallVectorImplIcEE(ptr noundef nonnull align 8 dereferenceable(36) %0, ptr noundef nonnull align 8 dereferenceable(16) %Buffer)
  %call2 = call noundef nonnull align 8 dereferenceable(36) ptr @_ZN4llvh11raw_ostreamlsEPKc(ptr noundef nonnull align 8 dereferenceable(36) %call, ptr noundef @.str.13)
  call void @_ZN4llvh11SmallVectorIcLj16EED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %Buffer) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh11SmallVectorIcLj16EEC2Ev(ptr noundef nonnull align 8 dereferenceable(32) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4llvh15SmallVectorImplIcEC2Ej(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef 16)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 8 dereferenceable(36) ptr @_ZN4llvh11raw_ostreamlsERKNS_15SmallVectorImplIcEE(ptr noundef nonnull align 8 dereferenceable(36) %this, ptr noundef nonnull align 8 dereferenceable(16) %Str) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Str.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %Str, ptr %Str.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %Str.addr, align 8
  %call = call noundef ptr @_ZNK4llvh25SmallVectorTemplateCommonIcvE4dataEv(ptr noundef nonnull align 8 dereferenceable(16) %0)
  %1 = load ptr, ptr %Str.addr, align 8
  %call2 = call noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %1)
  %call3 = call noundef nonnull align 8 dereferenceable(36) ptr @_ZN4llvh11raw_ostream5writeEPKcm(ptr noundef nonnull align 8 dereferenceable(36) %this1, ptr noundef %call, i64 noundef %call2)
  ret ptr %call3
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 8 dereferenceable(36) ptr @_ZN4llvh11raw_ostreamlsEPKc(ptr noundef nonnull align 8 dereferenceable(36) %this, ptr noundef %Str) #1 comdat align 2 {
entry:
  %this.addr.i = alloca ptr, align 8
  %Str.addr.i = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %Str.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.llvh::StringRef", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %Str, ptr %Str.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %Str.addr, align 8
  store ptr %agg.tmp, ptr %this.addr.i, align 8
  store ptr %0, ptr %Str.addr.i, align 8
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %1 = load ptr, ptr %Str.addr.i, align 8
  store ptr %1, ptr %this1.i, align 8
  %Length.i = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i, i32 0, i32 1
  %2 = load ptr, ptr %Str.addr.i, align 8
  %tobool.i = icmp ne ptr %2, null
  br i1 %tobool.i, label %cond.true.i, label %cond.false.i

cond.true.i:                                      ; preds = %entry
  %3 = load ptr, ptr %Str.addr.i, align 8
  %call.i = call i64 @strlen(ptr noundef %3) #15
  br label %_ZN4llvh9StringRefC2EPKc.exit

cond.false.i:                                     ; preds = %entry
  br label %_ZN4llvh9StringRefC2EPKc.exit

_ZN4llvh9StringRefC2EPKc.exit:                    ; preds = %cond.false.i, %cond.true.i
  %cond.i = phi i64 [ %call.i, %cond.true.i ], [ 0, %cond.false.i ]
  store i64 %cond.i, ptr %Length.i, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  %call = call noundef nonnull align 8 dereferenceable(36) ptr @_ZN4llvh11raw_ostreamlsENS_9StringRefE(ptr noundef nonnull align 8 dereferenceable(36) %this1, ptr %5, i64 %7)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh11SmallVectorIcLj16EED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr.i5 = alloca ptr, align 8
  %this.addr.i3 = alloca ptr, align 8
  %this.addr.i = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store ptr %this1, ptr %this.addr.i5, align 8
  %this1.i6 = load ptr, ptr %this.addr.i5, align 8
  %0 = load ptr, ptr %this1.i6, align 8
  store ptr %this1, ptr %this.addr.i, align 8
  %this1.i = load ptr, ptr %this.addr.i, align 8
  store ptr %this1.i, ptr %this.addr.i3, align 8
  %this1.i4 = load ptr, ptr %this.addr.i3, align 8
  %1 = load ptr, ptr %this1.i4, align 8
  %call2.i = call noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %this1.i)
  %add.ptr.i = getelementptr inbounds i8, ptr %1, i64 %call2.i
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE13destroy_rangeEPcS2_(ptr noundef %0, ptr noundef %add.ptr.i)
  call void @_ZN4llvh15SmallVectorImplIcED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this1) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden void @_ZNK4llvh7APFloat7ProfileERNS_16FoldingSetNodeIDE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(144) %NID) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %NID.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.llvh::APInt", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %NID, ptr %NID.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %NID.addr, align 8
  call void @_ZNK4llvh7APFloat14bitcastToAPIntEv(ptr sret(%"class.llvh::APInt") align 8 %ref.tmp, ptr noundef nonnull align 8 dereferenceable(32) %this1)
  call void @_ZN4llvh16FoldingSetNodeID3AddINS_5APIntEEEvRKT_(ptr noundef nonnull align 8 dereferenceable(144) %0, ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %ref.tmp) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh16FoldingSetNodeID3AddINS_5APIntEEEvRKT_(ptr noundef nonnull align 8 dereferenceable(144) %this, ptr noundef nonnull align 8 dereferenceable(12) %x) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  call void @_ZN4llvh22DefaultFoldingSetTraitINS_5APIntEE7ProfileERKS1_RNS_16FoldingSetNodeIDE(ptr noundef nonnull align 8 dereferenceable(12) %0, ptr noundef nonnull align 8 dereferenceable(144) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define hidden noundef i32 @_ZNK4llvh7APFloat16convertToIntegerERNS_6APSIntENS_11APFloatBase12roundingModeEPb(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(13) %result, i32 noundef %rounding_mode, ptr noundef %isExact) #1 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %result.addr = alloca ptr, align 8
  %rounding_mode.addr = alloca i32, align 4
  %isExact.addr = alloca ptr, align 8
  %bitWidth = alloca i32, align 4
  %parts = alloca %"class.llvh::SmallVector.13", align 8
  %ref.tmp = alloca i64, align 8
  %status = alloca i32, align 4
  %agg.tmp = alloca %"class.llvh::MutableArrayRef", align 8
  %agg.tmp5 = alloca %"class.llvh::APInt", align 8
  %agg.tmp6 = alloca %"class.llvh::ArrayRef", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %result, ptr %result.addr, align 8
  store i32 %rounding_mode, ptr %rounding_mode.addr, align 4
  store ptr %isExact, ptr %isExact.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %result.addr, align 8
  %call = call noundef i32 @_ZNK4llvh5APInt11getBitWidthEv(ptr noundef nonnull align 8 dereferenceable(12) %0)
  store i32 %call, ptr %bitWidth, align 4
  %1 = load ptr, ptr %result.addr, align 8
  %call2 = call noundef i32 @_ZNK4llvh5APInt11getNumWordsEv(ptr noundef nonnull align 8 dereferenceable(12) %1)
  %conv = zext i32 %call2 to i64
  store i64 0, ptr %ref.tmp, align 8
  call void @_ZN4llvh11SmallVectorImLj4EEC2EmRKm(ptr noundef nonnull align 8 dereferenceable(48) %parts, i64 noundef %conv, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp)
  call void @_ZN4llvh15MutableArrayRefImEC2ERNS_15SmallVectorImplImEE(ptr noundef nonnull align 8 dereferenceable(16) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(16) %parts)
  %2 = load i32, ptr %bitWidth, align 4
  %3 = load ptr, ptr %result.addr, align 8
  %call3 = call noundef zeroext i1 @_ZNK4llvh6APSInt8isSignedEv(ptr noundef nonnull align 8 dereferenceable(13) %3)
  %4 = load i32, ptr %rounding_mode.addr, align 4
  %5 = load ptr, ptr %isExact.addr, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %9 = load i64, ptr %8, align 8
  %call4 = call noundef i32 @_ZNK4llvh7APFloat16convertToIntegerENS_15MutableArrayRefImEEjbNS_11APFloatBase12roundingModeEPb(ptr noundef nonnull align 8 dereferenceable(32) %this1, ptr %7, i64 %9, i32 noundef %2, i1 noundef zeroext %call3, i32 noundef %4, ptr noundef %5)
  store i32 %call4, ptr %status, align 4
  %10 = load i32, ptr %bitWidth, align 4
  call void @_ZN4llvh8ArrayRefImEC2IvEERKNS_25SmallVectorTemplateCommonImT_EE(ptr noundef nonnull align 8 dereferenceable(16) %agg.tmp6, ptr noundef nonnull align 8 dereferenceable(16) %parts)
  %11 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp6, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  %13 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp6, i32 0, i32 1
  %14 = load i64, ptr %13, align 8
  call void @_ZN4llvh5APIntC1EjNS_8ArrayRefImEE(ptr noundef nonnull align 8 dereferenceable(12) %agg.tmp5, i32 noundef %10, ptr %12, i64 %14)
  %15 = load ptr, ptr %result.addr, align 8
  %call7 = call noundef nonnull align 8 dereferenceable(13) ptr @_ZN4llvh6APSIntaSENS_5APIntE(ptr noundef nonnull align 8 dereferenceable(13) %15, ptr noundef %agg.tmp5)
  call void @_ZN4llvh5APIntD2Ev(ptr noundef nonnull align 8 dereferenceable(12) %agg.tmp5) #10
  %16 = load i32, ptr %status, align 4
  call void @_ZN4llvh11SmallVectorImLj4EED2Ev(ptr noundef nonnull align 8 dereferenceable(48) %parts) #10
  ret i32 %16
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh11SmallVectorImLj4EEC2EmRKm(ptr noundef nonnull align 8 dereferenceable(48) %this, i64 noundef %Size, ptr noundef nonnull align 8 dereferenceable(8) %Value) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Size.addr = alloca i64, align 8
  %Value.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %Size, ptr %Size.addr, align 8
  store ptr %Value, ptr %Value.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4llvh15SmallVectorImplImEC2Ej(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef 4)
  %0 = load i64, ptr %Size.addr, align 8
  %1 = load ptr, ptr %Value.addr, align 8
  call void @_ZN4llvh15SmallVectorImplImE6assignEmRKm(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %0, ptr noundef nonnull align 8 dereferenceable(8) %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh15MutableArrayRefImEC2ERNS_15SmallVectorImplImEE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %Vec) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Vec.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %Vec, ptr %Vec.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %Vec.addr, align 8
  call void @_ZN4llvh8ArrayRefImEC2IvEERKNS_25SmallVectorTemplateCommonImT_EE(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %0)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh6APSInt8isSignedEv(ptr noundef nonnull align 8 dereferenceable(13) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %IsUnsigned = getelementptr inbounds %"class.llvh::APSInt", ptr %this1, i32 0, i32 1
  %0 = load i8, ptr %IsUnsigned, align 4
  %tobool = trunc i8 %0 to i1
  %lnot = xor i1 %tobool, true
  ret i1 %lnot
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh8ArrayRefImEC2IvEERKNS_25SmallVectorTemplateCommonImT_EE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %Vec) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Vec.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %Vec, ptr %Vec.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %"class.llvh::ArrayRef", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %Vec.addr, align 8
  %call = call noundef ptr @_ZNK4llvh25SmallVectorTemplateCommonImvE4dataEv(ptr noundef nonnull align 8 dereferenceable(16) %0)
  store ptr %call, ptr %Data, align 8
  %Length = getelementptr inbounds %"class.llvh::ArrayRef", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %Vec.addr, align 8
  %call2 = call noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %1)
  store i64 %call2, ptr %Length, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 8 dereferenceable(13) ptr @_ZN4llvh6APSIntaSENS_5APIntE(ptr noundef nonnull align 8 dereferenceable(13) %this, ptr noundef %RHS) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %RHS.indirect_addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.indirect_addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(12) ptr @_ZN4llvh5APIntaSEOS0_(ptr noundef nonnull align 8 dereferenceable(12) %this1, ptr noundef nonnull align 8 dereferenceable(12) %RHS)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh11SmallVectorImLj4EED2Ev(ptr noundef nonnull align 8 dereferenceable(48) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr.i.i = alloca ptr, align 8
  %this.addr.i3 = alloca ptr, align 8
  %this.addr.i = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store ptr %this1, ptr %this.addr.i, align 8
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %0 = load ptr, ptr %this1.i, align 8
  store ptr %this1, ptr %this.addr.i3, align 8
  %this1.i4 = load ptr, ptr %this.addr.i3, align 8
  store ptr %this1.i4, ptr %this.addr.i.i, align 8
  %this1.i.i = load ptr, ptr %this.addr.i.i, align 8
  %1 = load ptr, ptr %this1.i.i, align 8
  %call2.i = call noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %this1.i4)
  %add.ptr.i = getelementptr inbounds i64, ptr %1, i64 %call2.i
  call void @_ZN4llvh23SmallVectorTemplateBaseImLb1EE13destroy_rangeEPmS2_(ptr noundef %0, ptr noundef %add.ptr.i)
  call void @_ZN4llvh15SmallVectorImplImED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this1) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZN4llvh5APInt11getNumWordsEj(i32 noundef %BitWidth) #1 comdat align 2 {
entry:
  %BitWidth.addr = alloca i32, align 4
  store i32 %BitWidth, ptr %BitWidth.addr, align 4
  %0 = load i32, ptr %BitWidth.addr, align 4
  %conv = zext i32 %0 to i64
  %add = add i64 %conv, 64
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 64
  %conv1 = trunc i64 %div to i32
  ret i32 %conv1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh5APInt12isSingleWordEv(ptr noundef nonnull align 8 dereferenceable(12) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %BitWidth = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %BitWidth, align 8
  %cmp = icmp ule i32 %0, 64
  ret i1 %cmp
}

declare noundef i64 @_ZN4llvh5APInt9tcAddPartEPmmj(ptr noundef, i64 noundef, i32 noundef) #5

declare void @_ZN4llvh5APInt12tcShiftRightEPmjj(ptr noundef, i32 noundef, i32 noundef) #5

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 8 dereferenceable(12) ptr @_ZN4llvh5APInt15clearUnusedBitsEv(ptr noundef nonnull align 8 dereferenceable(12) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %WordBits = alloca i32, align 4
  %mask = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %BitWidth = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %BitWidth, align 8
  %sub = sub i32 %0, 1
  %rem = urem i32 %sub, 64
  %add = add i32 %rem, 1
  store i32 %add, ptr %WordBits, align 4
  %1 = load i32, ptr %WordBits, align 4
  %sub2 = sub i32 64, %1
  %sh_prom = zext i32 %sub2 to i64
  %shr = lshr i64 -1, %sh_prom
  store i64 %shr, ptr %mask, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh5APInt12isSingleWordEv(ptr noundef nonnull align 8 dereferenceable(12) %this1)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i64, ptr %mask, align 8
  %U = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 0
  %3 = load i64, ptr %U, align 8
  %and = and i64 %3, %2
  store i64 %and, ptr %U, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %4 = load i64, ptr %mask, align 8
  %U3 = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 0
  %5 = load ptr, ptr %U3, align 8
  %call4 = call noundef i32 @_ZNK4llvh5APInt11getNumWordsEv(ptr noundef nonnull align 8 dereferenceable(12) %this1)
  %sub5 = sub i32 %call4, 1
  %idxprom = zext i32 %sub5 to i64
  %arrayidx = getelementptr inbounds i64, ptr %5, i64 %idxprom
  %6 = load i64, ptr %arrayidx, align 8
  %and6 = and i64 %6, %4
  store i64 %and6, ptr %arrayidx, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret ptr %this1
}

declare void @_ZN4llvh5APInt12initSlowCaseEmb(ptr noundef nonnull align 8 dereferenceable(12), i64 noundef, i1 noundef zeroext) #5

declare void @_ZN4llvh5APInt11shlSlowCaseEj(ptr noundef nonnull align 8 dereferenceable(12), i32 noundef) #5

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh5APInt12needsCleanupEv(ptr noundef nonnull align 8 dereferenceable(12) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh5APInt12isSingleWordEv(ptr noundef nonnull align 8 dereferenceable(12) %this1)
  %lnot = xor i1 %call, true
  ret i1 %lnot
}

declare void @_ZN4llvh5APInt12initSlowCaseERKS0_(ptr noundef nonnull align 8 dereferenceable(12), ptr noundef nonnull align 8 dereferenceable(12)) #5

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh5APIntixEj(ptr noundef nonnull align 8 dereferenceable(12) %this, i32 noundef %bitPosition) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %bitPosition.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %bitPosition, ptr %bitPosition.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %bitPosition.addr, align 4
  %call = call noundef i64 @_ZN4llvh5APInt7maskBitEj(i32 noundef %0)
  %1 = load i32, ptr %bitPosition.addr, align 4
  %call2 = call noundef i64 @_ZNK4llvh5APInt7getWordEj(ptr noundef nonnull align 8 dereferenceable(12) %this1, i32 noundef %1)
  %and = and i64 %call, %call2
  %cmp = icmp ne i64 %and, 0
  ret i1 %cmp
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZN4llvh5APInt7maskBitEj(i32 noundef %bitPosition) #1 comdat align 2 {
entry:
  %bitPosition.addr = alloca i32, align 4
  store i32 %bitPosition, ptr %bitPosition.addr, align 4
  %0 = load i32, ptr %bitPosition.addr, align 4
  %call = call noundef i32 @_ZN4llvh5APInt8whichBitEj(i32 noundef %0)
  %sh_prom = zext i32 %call to i64
  %shl = shl i64 1, %sh_prom
  ret i64 %shl
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZNK4llvh5APInt7getWordEj(ptr noundef nonnull align 8 dereferenceable(12) %this, i32 noundef %bitPosition) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %bitPosition.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %bitPosition, ptr %bitPosition.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh5APInt12isSingleWordEv(ptr noundef nonnull align 8 dereferenceable(12) %this1)
  br i1 %call, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %U = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 0
  %0 = load i64, ptr %U, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %U2 = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %U2, align 8
  %2 = load i32, ptr %bitPosition.addr, align 4
  %call3 = call noundef i32 @_ZN4llvh5APInt9whichWordEj(i32 noundef %2)
  %idxprom = zext i32 %call3 to i64
  %arrayidx = getelementptr inbounds i64, ptr %1, i64 %idxprom
  %3 = load i64, ptr %arrayidx, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %0, %cond.true ], [ %3, %cond.false ]
  ret i64 %cond
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZN4llvh5APInt8whichBitEj(i32 noundef %bitPosition) #1 comdat align 2 {
entry:
  %bitPosition.addr = alloca i32, align 4
  store i32 %bitPosition, ptr %bitPosition.addr, align 4
  %0 = load i32, ptr %bitPosition.addr, align 4
  %rem = urem i32 %0, 64
  ret i32 %rem
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZN4llvh5APInt9whichWordEj(i32 noundef %bitPosition) #1 comdat align 2 {
entry:
  %bitPosition.addr = alloca i32, align 4
  store i32 %bitPosition, ptr %bitPosition.addr, align 4
  %0 = load i32, ptr %bitPosition.addr, align 4
  %div = udiv i32 %0, 64
  ret i32 %div
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh5APInt6negateEv(ptr noundef nonnull align 8 dereferenceable(12) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4llvh5APInt11flipAllBitsEv(ptr noundef nonnull align 8 dereferenceable(12) %this1)
  %call = call noundef nonnull align 8 dereferenceable(12) ptr @_ZN4llvh5APIntppEv(ptr noundef nonnull align 8 dereferenceable(12) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh5APIntC2EOS0_(ptr noundef nonnull align 8 dereferenceable(12) %this, ptr noundef nonnull align 8 dereferenceable(12) %that) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %that.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %that, ptr %that.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %BitWidth = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %that.addr, align 8
  %BitWidth2 = getelementptr inbounds %"class.llvh::APInt", ptr %0, i32 0, i32 1
  %1 = load i32, ptr %BitWidth2, align 8
  store i32 %1, ptr %BitWidth, align 8
  %U3 = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %that.addr, align 8
  %U4 = getelementptr inbounds %"class.llvh::APInt", ptr %2, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %U3, ptr align 8 %U4, i64 8, i1 false)
  %3 = load ptr, ptr %that.addr, align 8
  %BitWidth5 = getelementptr inbounds %"class.llvh::APInt", ptr %3, i32 0, i32 1
  store i32 0, ptr %BitWidth5, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh5APInt11flipAllBitsEv(ptr noundef nonnull align 8 dereferenceable(12) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh5APInt12isSingleWordEv(ptr noundef nonnull align 8 dereferenceable(12) %this1)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %U = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 0
  %0 = load i64, ptr %U, align 8
  %xor = xor i64 %0, -1
  store i64 %xor, ptr %U, align 8
  %call2 = call noundef nonnull align 8 dereferenceable(12) ptr @_ZN4llvh5APInt15clearUnusedBitsEv(ptr noundef nonnull align 8 dereferenceable(12) %this1)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @_ZN4llvh5APInt19flipAllBitsSlowCaseEv(ptr noundef nonnull align 8 dereferenceable(12) %this1)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

declare noundef nonnull align 8 dereferenceable(12) ptr @_ZN4llvh5APIntppEv(ptr noundef nonnull align 8 dereferenceable(12)) #5

declare void @_ZN4llvh5APInt19flipAllBitsSlowCaseEv(ptr noundef nonnull align 8 dereferenceable(12)) #5

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZN4llvhL12readExponentEPKcS1_(ptr noundef %begin, ptr noundef %end) #1 {
entry:
  %retval = alloca i32, align 4
  %begin.addr = alloca ptr, align 8
  %end.addr = alloca ptr, align 8
  %isNegative = alloca i8, align 1
  %absExponent = alloca i32, align 4
  %overlargeExponent = alloca i32, align 4
  %p = alloca ptr, align 8
  %value = alloca i32, align 4
  store ptr %begin, ptr %begin.addr, align 8
  store ptr %end, ptr %end.addr, align 8
  store i32 24000, ptr %overlargeExponent, align 4
  %0 = load ptr, ptr %begin.addr, align 8
  store ptr %0, ptr %p, align 8
  %1 = load ptr, ptr %p, align 8
  %2 = load i8, ptr %1, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp eq i32 %conv, 45
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, ptr %isNegative, align 1
  %3 = load ptr, ptr %p, align 8
  %4 = load i8, ptr %3, align 1
  %conv1 = sext i8 %4 to i32
  %cmp2 = icmp eq i32 %conv1, 45
  br i1 %cmp2, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %5 = load ptr, ptr %p, align 8
  %6 = load i8, ptr %5, align 1
  %conv3 = sext i8 %6 to i32
  %cmp4 = icmp eq i32 %conv3, 43
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %7 = load ptr, ptr %p, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %7, i32 1
  store ptr %incdec.ptr, ptr %p, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %8 = load ptr, ptr %p, align 8
  %incdec.ptr5 = getelementptr inbounds i8, ptr %8, i32 1
  store ptr %incdec.ptr5, ptr %p, align 8
  %9 = load i8, ptr %8, align 1
  %conv6 = sext i8 %9 to i32
  %call = call noundef i32 @_ZN4llvhL13decDigitValueEj(i32 noundef %conv6)
  store i32 %call, ptr %absExponent, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load ptr, ptr %p, align 8
  %11 = load ptr, ptr %end.addr, align 8
  %cmp7 = icmp ne ptr %10, %11
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load ptr, ptr %p, align 8
  %13 = load i8, ptr %12, align 1
  %conv8 = sext i8 %13 to i32
  %call9 = call noundef i32 @_ZN4llvhL13decDigitValueEj(i32 noundef %conv8)
  store i32 %call9, ptr %value, align 4
  %14 = load i32, ptr %absExponent, align 4
  %mul = mul i32 %14, 10
  %15 = load i32, ptr %value, align 4
  %add = add i32 %15, %mul
  store i32 %add, ptr %value, align 4
  %16 = load i32, ptr %absExponent, align 4
  %cmp10 = icmp uge i32 %16, 24000
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %for.body
  store i32 24000, ptr %absExponent, align 4
  %17 = load ptr, ptr %end.addr, align 8
  store ptr %17, ptr %p, align 8
  br label %for.end

if.end12:                                         ; preds = %for.body
  %18 = load i32, ptr %value, align 4
  store i32 %18, ptr %absExponent, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %19 = load ptr, ptr %p, align 8
  %incdec.ptr13 = getelementptr inbounds i8, ptr %19, i32 1
  store ptr %incdec.ptr13, ptr %p, align 8
  br label %for.cond, !llvm.loop !41

for.end:                                          ; preds = %if.then11, %for.cond
  %20 = load i8, ptr %isNegative, align 1
  %tobool = trunc i8 %20 to i1
  br i1 %tobool, label %if.then14, label %if.else

if.then14:                                        ; preds = %for.end
  %21 = load i32, ptr %absExponent, align 4
  %sub = sub nsw i32 0, %21
  store i32 %sub, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %for.end
  %22 = load i32, ptr %absExponent, align 4
  store i32 %22, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %if.then14
  %23 = load i32, ptr %retval, align 4
  ret i32 %23
}

; Function Attrs: nounwind willreturn memory(read)
declare i32 @memcmp(ptr noundef, ptr noundef, i64 noundef) #9

; Function Attrs: nounwind willreturn memory(read)
declare i64 @strlen(ptr noundef) #9

; Function Attrs: mustprogress nounwind uwtable
define internal noundef ptr @_ZN4llvhL20writeUnsignedDecimalEPcj(ptr noundef %dst, i32 noundef %n) #1 {
entry:
  %dst.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %buff = alloca [40 x i8], align 16
  %p = alloca ptr, align 8
  store ptr %dst, ptr %dst.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %arraydecay = getelementptr inbounds [40 x i8], ptr %buff, i64 0, i64 0
  store ptr %arraydecay, ptr %p, align 8
  br label %do.body

do.body:                                          ; preds = %do.cond, %entry
  %0 = load i32, ptr %n.addr, align 4
  %rem = urem i32 %0, 10
  %add = add i32 48, %rem
  %conv = trunc i32 %add to i8
  %1 = load ptr, ptr %p, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %1, i32 1
  store ptr %incdec.ptr, ptr %p, align 8
  store i8 %conv, ptr %1, align 1
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %2 = load i32, ptr %n.addr, align 4
  %div = udiv i32 %2, 10
  store i32 %div, ptr %n.addr, align 4
  %tobool = icmp ne i32 %div, 0
  br i1 %tobool, label %do.body, label %do.end, !llvm.loop !42

do.end:                                           ; preds = %do.cond
  br label %do.body1

do.body1:                                         ; preds = %do.cond4, %do.end
  %3 = load ptr, ptr %p, align 8
  %incdec.ptr2 = getelementptr inbounds i8, ptr %3, i32 -1
  store ptr %incdec.ptr2, ptr %p, align 8
  %4 = load i8, ptr %incdec.ptr2, align 1
  %5 = load ptr, ptr %dst.addr, align 8
  %incdec.ptr3 = getelementptr inbounds i8, ptr %5, i32 1
  store ptr %incdec.ptr3, ptr %dst.addr, align 8
  store i8 %4, ptr %5, align 1
  br label %do.cond4

do.cond4:                                         ; preds = %do.body1
  %6 = load ptr, ptr %p, align 8
  %arraydecay5 = getelementptr inbounds [40 x i8], ptr %buff, i64 0, i64 0
  %cmp = icmp ne ptr %6, %arraydecay5
  br i1 %cmp, label %do.body1, label %do.end6, !llvm.loop !43

do.end6:                                          ; preds = %do.cond4
  %7 = load ptr, ptr %dst.addr, align 8
  ret ptr %7
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef float @_ZN4llvh11BitsToFloatEj(i32 noundef %Bits) #1 comdat {
entry:
  %Bits.addr = alloca i32, align 4
  %F = alloca float, align 4
  store i32 %Bits, ptr %Bits.addr, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %F, ptr align 4 %Bits.addr, i64 4, i1 false)
  %0 = load float, ptr %F, align 4
  ret float %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef double @_ZN4llvh12BitsToDoubleEm(i64 noundef %Bits) #1 comdat {
entry:
  %Bits.addr = alloca i64, align 8
  %D = alloca double, align 8
  store i64 %Bits, ptr %Bits.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %D, ptr align 8 %Bits.addr, i64 8, i1 false)
  %0 = load double, ptr %D, align 8
  ret double %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZN4llvh11FloatToBitsEf(float noundef %Float) #1 comdat {
entry:
  %Float.addr = alloca float, align 4
  %Bits = alloca i32, align 4
  store float %Float, ptr %Float.addr, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %Bits, ptr align 4 %Float.addr, i64 4, i1 false)
  %0 = load i32, ptr %Bits, align 4
  ret i32 %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZN4llvh12DoubleToBitsEd(double noundef %Double) #1 comdat {
entry:
  %Double.addr = alloca double, align 8
  %Bits = alloca i64, align 8
  store double %Double, ptr %Double.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %Bits, ptr align 8 %Double.addr, i64 8, i1 false)
  %0 = load i64, ptr %Bits, align 8
  ret i64 %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh15SmallVectorImplIcE6appendIPKcvEEvT_S5_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %in_start, ptr noundef %in_end) #1 comdat align 2 {
entry:
  %this.addr.i8 = alloca ptr, align 8
  %this.addr.i = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %in_start.addr = alloca ptr, align 8
  %in_end.addr = alloca ptr, align 8
  %NumInputs = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %in_start, ptr %in_start.addr, align 8
  store ptr %in_end, ptr %in_end.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %in_start.addr, align 8
  %1 = load ptr, ptr %in_end.addr, align 8
  %call = call noundef i64 @_ZSt8distanceIPKcENSt15iterator_traitsIT_E15difference_typeES3_S3_(ptr noundef %0, ptr noundef %1)
  store i64 %call, ptr %NumInputs, align 8
  %2 = load i64, ptr %NumInputs, align 8
  %call2 = call noundef i64 @_ZNK4llvh15SmallVectorBase8capacityEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %call3 = call noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %sub = sub i64 %call2, %call3
  %cmp = icmp ugt i64 %2, %sub
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call4 = call noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %3 = load i64, ptr %NumInputs, align 8
  %add = add i64 %call4, %3
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE4growEm(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %add)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load ptr, ptr %in_start.addr, align 8
  %5 = load ptr, ptr %in_end.addr, align 8
  store ptr %this1, ptr %this.addr.i, align 8
  %this1.i = load ptr, ptr %this.addr.i, align 8
  store ptr %this1.i, ptr %this.addr.i8, align 8
  %this1.i9 = load ptr, ptr %this.addr.i8, align 8
  %6 = load ptr, ptr %this1.i9, align 8
  %call2.i = call noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %this1.i)
  %add.ptr.i = getelementptr inbounds i8, ptr %6, i64 %call2.i
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE18uninitialized_copyIKccEEvPT_S5_PT0_PNSt9enable_ifIXsr3std7is_sameINSt12remove_constIS4_E4typeES6_EE5valueEvE4typeE(ptr noundef %4, ptr noundef %5, ptr noundef %add.ptr.i, ptr noundef null)
  %call6 = call noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %7 = load i64, ptr %NumInputs, align 8
  %add7 = add i64 %call6, %7
  call void @_ZN4llvh15SmallVectorBase8set_sizeEm(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %add7)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i64 @_ZSt8distanceIPKcENSt15iterator_traitsIT_E15difference_typeES3_S3_(ptr noundef %__first, ptr noundef %__last) #1 comdat {
entry:
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store ptr %__last, ptr %__last.addr, align 8
  %0 = load ptr, ptr %__first.addr, align 8
  %1 = load ptr, ptr %__last.addr, align 8
  call void @_ZSt19__iterator_categoryIPKcENSt15iterator_traitsIT_E17iterator_categoryERKS3_(ptr noundef nonnull align 8 dereferenceable(8) %__first.addr)
  %call = call noundef i64 @_ZSt10__distanceIPKcENSt15iterator_traitsIT_E15difference_typeES3_S3_St26random_access_iterator_tag(ptr noundef %0, ptr noundef %1)
  ret i64 %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZNK4llvh15SmallVectorBase8capacityEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %"class.llvh::SmallVectorBase", ptr %this1, i32 0, i32 2
  %0 = load i32, ptr %Capacity, align 4
  %conv = zext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE4growEm(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %MinSize) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %MinSize.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %MinSize, ptr %MinSize.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %MinSize.addr, align 8
  call void @_ZN4llvh25SmallVectorTemplateCommonIcvE8grow_podEmm(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %0, i64 noundef 1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE18uninitialized_copyIKccEEvPT_S5_PT0_PNSt9enable_ifIXsr3std7is_sameINSt12remove_constIS4_E4typeES6_EE5valueEvE4typeE(ptr noundef %I, ptr noundef %E, ptr noundef %Dest, ptr noundef %0) #1 comdat align 2 {
entry:
  %I.addr = alloca ptr, align 8
  %E.addr = alloca ptr, align 8
  %Dest.addr = alloca ptr, align 8
  %.addr = alloca ptr, align 8
  store ptr %I, ptr %I.addr, align 8
  store ptr %E, ptr %E.addr, align 8
  store ptr %Dest, ptr %Dest.addr, align 8
  store ptr %0, ptr %.addr, align 8
  %1 = load ptr, ptr %I.addr, align 8
  %2 = load ptr, ptr %E.addr, align 8
  %cmp = icmp ne ptr %1, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %Dest.addr, align 8
  %4 = load ptr, ptr %I.addr, align 8
  %5 = load ptr, ptr %E.addr, align 8
  %6 = load ptr, ptr %I.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %5 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %6 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %mul = mul i64 %sub.ptr.sub, 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %3, ptr align 1 %4, i64 %mul, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh15SmallVectorBase8set_sizeEm(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %Size) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Size.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %Size, ptr %Size.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %Size.addr, align 8
  %conv = trunc i64 %0 to i32
  %Size2 = getelementptr inbounds %"class.llvh::SmallVectorBase", ptr %this1, i32 0, i32 1
  store i32 %conv, ptr %Size2, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i64 @_ZSt10__distanceIPKcENSt15iterator_traitsIT_E15difference_typeES3_S3_St26random_access_iterator_tag(ptr noundef %__first, ptr noundef %__last) #1 comdat {
entry:
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store ptr %__last, ptr %__last.addr, align 8
  %0 = load ptr, ptr %__last.addr, align 8
  %1 = load ptr, ptr %__first.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  ret i64 %sub.ptr.sub
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZSt19__iterator_categoryIPKcENSt15iterator_traitsIT_E17iterator_categoryERKS3_(ptr noundef nonnull align 8 dereferenceable(8) %0) #1 comdat {
entry:
  %.addr = alloca ptr, align 8
  store ptr %0, ptr %.addr, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh25SmallVectorTemplateCommonIcvE8grow_podEmm(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %MinCapacity, i64 noundef %TSize) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %MinCapacity.addr = alloca i64, align 8
  %TSize.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %MinCapacity, ptr %MinCapacity.addr, align 8
  store i64 %TSize, ptr %TSize.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZNK4llvh25SmallVectorTemplateCommonIcvE10getFirstElEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %0 = load i64, ptr %MinCapacity.addr, align 8
  %1 = load i64, ptr %TSize.addr, align 8
  call void @_ZN4llvh15SmallVectorBase8grow_podEPvmm(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef %call, i64 noundef %0, i64 noundef %1)
  ret void
}

declare void @_ZN4llvh15SmallVectorBase8grow_podEPvmm(ptr noundef nonnull align 8 dereferenceable(16), ptr noundef, i64 noundef, i64 noundef) #5

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef ptr @_ZNK4llvh25SmallVectorTemplateCommonIcvE10getFirstElEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %this1, i64 16
  ret ptr %add.ptr
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZN4llvh18countTrailingZerosImEEmT_NS_12ZeroBehaviorE(i64 noundef %Val, i32 noundef %ZB) #1 comdat {
entry:
  %Val.addr = alloca i64, align 8
  %ZB.addr = alloca i32, align 4
  store i64 %Val, ptr %Val.addr, align 8
  store i32 %ZB, ptr %ZB.addr, align 4
  %0 = load i64, ptr %Val.addr, align 8
  %1 = load i32, ptr %ZB.addr, align 4
  %call = call noundef i64 @_ZN4llvh6detail20TrailingZerosCounterImLm8EE5countEmNS_12ZeroBehaviorE(i64 noundef %0, i32 noundef %1)
  ret i64 %call
}

; Function Attrs: nounwind willreturn memory(read)
declare noundef i32 @_ZNK4llvh5APInt26countTrailingZerosSlowCaseEv(ptr noundef nonnull align 8 dereferenceable(12)) #9

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZN4llvh6detail20TrailingZerosCounterImLm8EE5countEmNS_12ZeroBehaviorE(i64 noundef %Val, i32 noundef %ZB) #1 comdat align 2 {
entry:
  %retval = alloca i64, align 8
  %Val.addr = alloca i64, align 8
  %ZB.addr = alloca i32, align 4
  store i64 %Val, ptr %Val.addr, align 8
  store i32 %ZB, ptr %ZB.addr, align 4
  %0 = load i32, ptr %ZB.addr, align 4
  %cmp = icmp ne i32 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %Val.addr, align 8
  %cmp1 = icmp eq i64 %1, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i64 64, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %Val.addr, align 8
  %3 = call i64 @llvm.cttz.i64(i64 %2, i1 true)
  %cast = trunc i64 %3 to i32
  %conv = sext i32 %cast to i64
  store i64 %conv, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i64, ptr %retval, align 8
  ret i64 %4
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.cttz.i64(i64, i1 immarg) #2

declare void @_ZN4llvh5APInt12lshrSlowCaseEj(ptr noundef nonnull align 8 dereferenceable(12), i32 noundef) #5

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZNK4llvh5APInt13getActiveBitsEv(ptr noundef nonnull align 8 dereferenceable(12) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %BitWidth = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %BitWidth, align 8
  %call = call noundef i32 @_ZNK4llvh5APInt17countLeadingZerosEv(ptr noundef nonnull align 8 dereferenceable(12) %this1)
  %sub = sub i32 %0, %call
  ret i32 %sub
}

declare void @_ZNK4llvh5APInt4udivERKS0_(ptr sret(%"class.llvh::APInt") align 8, ptr noundef nonnull align 8 dereferenceable(12), ptr noundef nonnull align 8 dereferenceable(12)) #5

declare void @_ZNK4llvh5APInt5truncEj(ptr sret(%"class.llvh::APInt") align 8, ptr noundef nonnull align 8 dereferenceable(12), i32 noundef) #5

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZNK4llvh5APInt17countLeadingZerosEv(ptr noundef nonnull align 8 dereferenceable(12) %this) #1 comdat align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %unusedBits = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh5APInt12isSingleWordEv(ptr noundef nonnull align 8 dereferenceable(12) %this1)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %BitWidth = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %BitWidth, align 8
  %sub = sub i32 64, %0
  store i32 %sub, ptr %unusedBits, align 4
  %U = getelementptr inbounds %"class.llvh::APInt", ptr %this1, i32 0, i32 0
  %1 = load i64, ptr %U, align 8
  %call2 = call noundef i64 @_ZN4llvh17countLeadingZerosImEEmT_NS_12ZeroBehaviorE(i64 noundef %1, i32 noundef 2)
  %2 = load i32, ptr %unusedBits, align 4
  %conv = zext i32 %2 to i64
  %sub3 = sub i64 %call2, %conv
  %conv4 = trunc i64 %sub3 to i32
  store i32 %conv4, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %call5 = call noundef i32 @_ZNK4llvh5APInt25countLeadingZerosSlowCaseEv(ptr noundef nonnull align 8 dereferenceable(12) %this1) #15
  store i32 %call5, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load i32, ptr %retval, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZN4llvh17countLeadingZerosImEEmT_NS_12ZeroBehaviorE(i64 noundef %Val, i32 noundef %ZB) #1 comdat {
entry:
  %Val.addr = alloca i64, align 8
  %ZB.addr = alloca i32, align 4
  store i64 %Val, ptr %Val.addr, align 8
  store i32 %ZB, ptr %ZB.addr, align 4
  %0 = load i64, ptr %Val.addr, align 8
  %1 = load i32, ptr %ZB.addr, align 4
  %call = call noundef i64 @_ZN4llvh6detail19LeadingZerosCounterImLm8EE5countEmNS_12ZeroBehaviorE(i64 noundef %0, i32 noundef %1)
  ret i64 %call
}

; Function Attrs: nounwind willreturn memory(read)
declare noundef i32 @_ZNK4llvh5APInt25countLeadingZerosSlowCaseEv(ptr noundef nonnull align 8 dereferenceable(12)) #9

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZN4llvh6detail19LeadingZerosCounterImLm8EE5countEmNS_12ZeroBehaviorE(i64 noundef %Val, i32 noundef %ZB) #1 comdat align 2 {
entry:
  %retval = alloca i64, align 8
  %Val.addr = alloca i64, align 8
  %ZB.addr = alloca i32, align 4
  store i64 %Val, ptr %Val.addr, align 8
  store i32 %ZB, ptr %ZB.addr, align 4
  %0 = load i32, ptr %ZB.addr, align 4
  %cmp = icmp ne i32 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %Val.addr, align 8
  %cmp1 = icmp eq i64 %1, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i64 64, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = load i64, ptr %Val.addr, align 8
  %3 = call i64 @llvm.ctlz.i64(i64 %2, i1 true)
  %cast = trunc i64 %3 to i32
  %conv = sext i32 %cast to i64
  store i64 %conv, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i64, ptr %retval, align 8
  ret i64 %4
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.ctlz.i64(i64, i1 immarg) #2

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh5APInteqEm(ptr noundef nonnull align 8 dereferenceable(12) %this, i64 noundef %Val) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Val.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %Val, ptr %Val.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh5APInt12isSingleWordEv(ptr noundef nonnull align 8 dereferenceable(12) %this1)
  br i1 %call, label %land.rhs, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %call2 = call noundef i32 @_ZNK4llvh5APInt13getActiveBitsEv(ptr noundef nonnull align 8 dereferenceable(12) %this1)
  %cmp = icmp ule i32 %call2, 64
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.lhs.false, %entry
  %call3 = call noundef i64 @_ZNK4llvh5APInt12getZExtValueEv(ptr noundef nonnull align 8 dereferenceable(12) %this1)
  %0 = load i64, ptr %Val.addr, align 8
  %cmp4 = icmp eq i64 %call3, %0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.lhs.false
  %1 = phi i1 [ false, %lor.lhs.false ], [ %cmp4, %land.rhs ]
  ret i1 %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef ptr @_ZN4llvh15SmallVectorImplIcE5eraseEPKcS3_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %CS, ptr noundef %CE) #1 comdat align 2 {
entry:
  %this.addr.i14 = alloca ptr, align 8
  %this.addr.i12 = alloca ptr, align 8
  %this.addr.i10 = alloca ptr, align 8
  %this.addr.i5 = alloca ptr, align 8
  %this.addr.i = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %CS.addr = alloca ptr, align 8
  %CE.addr = alloca ptr, align 8
  %S = alloca ptr, align 8
  %E = alloca ptr, align 8
  %N = alloca ptr, align 8
  %I = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %CS, ptr %CS.addr, align 8
  store ptr %CE, ptr %CE.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %CS.addr, align 8
  store ptr %0, ptr %S, align 8
  %1 = load ptr, ptr %CE.addr, align 8
  store ptr %1, ptr %E, align 8
  %2 = load ptr, ptr %S, align 8
  store ptr %2, ptr %N, align 8
  %3 = load ptr, ptr %E, align 8
  store ptr %this1, ptr %this.addr.i5, align 8
  %this1.i6 = load ptr, ptr %this.addr.i5, align 8
  store ptr %this1.i6, ptr %this.addr.i10, align 8
  %this1.i11 = load ptr, ptr %this.addr.i10, align 8
  %4 = load ptr, ptr %this1.i11, align 8
  %call2.i8 = call noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %this1.i6)
  %add.ptr.i9 = getelementptr inbounds i8, ptr %4, i64 %call2.i8
  %5 = load ptr, ptr %S, align 8
  %call2 = call noundef ptr @_ZSt4moveIPcS0_ET0_T_S2_S1_(ptr noundef %3, ptr noundef %add.ptr.i9, ptr noundef %5)
  store ptr %call2, ptr %I, align 8
  %6 = load ptr, ptr %I, align 8
  store ptr %this1, ptr %this.addr.i, align 8
  %this1.i = load ptr, ptr %this.addr.i, align 8
  store ptr %this1.i, ptr %this.addr.i12, align 8
  %this1.i13 = load ptr, ptr %this.addr.i12, align 8
  %7 = load ptr, ptr %this1.i13, align 8
  %call2.i = call noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %this1.i)
  %add.ptr.i = getelementptr inbounds i8, ptr %7, i64 %call2.i
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE13destroy_rangeEPcS2_(ptr noundef %6, ptr noundef %add.ptr.i)
  %8 = load ptr, ptr %I, align 8
  store ptr %this1, ptr %this.addr.i14, align 8
  %this1.i15 = load ptr, ptr %this.addr.i14, align 8
  %9 = load ptr, ptr %this1.i15, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %8 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %9 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  call void @_ZN4llvh15SmallVectorBase8set_sizeEm(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %sub.ptr.sub)
  %10 = load ptr, ptr %N, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh15SmallVectorImplIcE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr.i5 = alloca ptr, align 8
  %this.addr.i3 = alloca ptr, align 8
  %this.addr.i = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store ptr %this1, ptr %this.addr.i5, align 8
  %this1.i6 = load ptr, ptr %this.addr.i5, align 8
  %0 = load ptr, ptr %this1.i6, align 8
  store ptr %this1, ptr %this.addr.i, align 8
  %this1.i = load ptr, ptr %this.addr.i, align 8
  store ptr %this1.i, ptr %this.addr.i3, align 8
  %this1.i4 = load ptr, ptr %this.addr.i3, align 8
  %1 = load ptr, ptr %this1.i4, align 8
  %call2.i = call noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %this1.i)
  %add.ptr.i = getelementptr inbounds i8, ptr %1, i64 %call2.i
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE13destroy_rangeEPcS2_(ptr noundef %0, ptr noundef %add.ptr.i)
  %Size = getelementptr inbounds %"class.llvh::SmallVectorBase", ptr %this1, i32 0, i32 1
  store i32 0, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZSt4moveIPcS0_ET0_T_S2_S1_(ptr noundef %__first, ptr noundef %__last, ptr noundef %__result) #1 comdat {
entry:
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__result.addr = alloca ptr, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store ptr %__last, ptr %__last.addr, align 8
  store ptr %__result, ptr %__result.addr, align 8
  %0 = load ptr, ptr %__first.addr, align 8
  %call = call noundef ptr @_ZSt12__miter_baseIPcET_S1_(ptr noundef %0)
  %1 = load ptr, ptr %__last.addr, align 8
  %call1 = call noundef ptr @_ZSt12__miter_baseIPcET_S1_(ptr noundef %1)
  %2 = load ptr, ptr %__result.addr, align 8
  %call2 = call noundef ptr @_ZSt13__copy_move_aILb1EPcS0_ET1_T0_S2_S1_(ptr noundef %call, ptr noundef %call1, ptr noundef %2)
  ret ptr %call2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EE13destroy_rangeEPcS2_(ptr noundef %0, ptr noundef %1) #1 comdat align 2 {
entry:
  %.addr = alloca ptr, align 8
  %.addr1 = alloca ptr, align 8
  store ptr %0, ptr %.addr, align 8
  store ptr %1, ptr %.addr1, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZSt13__copy_move_aILb1EPcS0_ET1_T0_S2_S1_(ptr noundef %__first, ptr noundef %__last, ptr noundef %__result) #1 comdat {
entry:
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__result.addr = alloca ptr, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store ptr %__last, ptr %__last.addr, align 8
  store ptr %__result, ptr %__result.addr, align 8
  %0 = load ptr, ptr %__first.addr, align 8
  %call = call noundef ptr @_ZSt12__niter_baseIPcET_S1_(ptr noundef %0) #10
  %1 = load ptr, ptr %__last.addr, align 8
  %call1 = call noundef ptr @_ZSt12__niter_baseIPcET_S1_(ptr noundef %1) #10
  %2 = load ptr, ptr %__result.addr, align 8
  %call2 = call noundef ptr @_ZSt12__niter_baseIPcET_S1_(ptr noundef %2) #10
  %call3 = call noundef ptr @_ZSt14__copy_move_a1ILb1EPcS0_ET1_T0_S2_S1_(ptr noundef %call, ptr noundef %call1, ptr noundef %call2)
  %call4 = call noundef ptr @_ZSt12__niter_wrapIPcET_RKS1_S1_(ptr noundef nonnull align 8 dereferenceable(8) %__result.addr, ptr noundef %call3)
  ret ptr %call4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZSt12__miter_baseIPcET_S1_(ptr noundef %__it) #1 comdat {
entry:
  %__it.addr = alloca ptr, align 8
  store ptr %__it, ptr %__it.addr, align 8
  %0 = load ptr, ptr %__it.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZSt12__niter_wrapIPcET_RKS1_S1_(ptr noundef nonnull align 8 dereferenceable(8) %0, ptr noundef %__res) #1 comdat {
entry:
  %.addr = alloca ptr, align 8
  %__res.addr = alloca ptr, align 8
  store ptr %0, ptr %.addr, align 8
  store ptr %__res, ptr %__res.addr, align 8
  %1 = load ptr, ptr %__res.addr, align 8
  ret ptr %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZSt14__copy_move_a1ILb1EPcS0_ET1_T0_S2_S1_(ptr noundef %__first, ptr noundef %__last, ptr noundef %__result) #1 comdat {
entry:
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__result.addr = alloca ptr, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store ptr %__last, ptr %__last.addr, align 8
  store ptr %__result, ptr %__result.addr, align 8
  %0 = load ptr, ptr %__first.addr, align 8
  %1 = load ptr, ptr %__last.addr, align 8
  %2 = load ptr, ptr %__result.addr, align 8
  %call = call noundef ptr @_ZSt14__copy_move_a2ILb1EPcS0_ET1_T0_S2_S1_(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZSt12__niter_baseIPcET_S1_(ptr noundef %__it) #1 comdat {
entry:
  %__it.addr = alloca ptr, align 8
  store ptr %__it, ptr %__it.addr, align 8
  %0 = load ptr, ptr %__it.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZSt14__copy_move_a2ILb1EPcS0_ET1_T0_S2_S1_(ptr noundef %__first, ptr noundef %__last, ptr noundef %__result) #1 comdat {
entry:
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__result.addr = alloca ptr, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store ptr %__last, ptr %__last.addr, align 8
  store ptr %__result, ptr %__result.addr, align 8
  %0 = load ptr, ptr %__first.addr, align 8
  %1 = load ptr, ptr %__last.addr, align 8
  %2 = load ptr, ptr %__result.addr, align 8
  %call = call noundef ptr @_ZNSt11__copy_moveILb1ELb1ESt26random_access_iterator_tagE8__copy_mIcEEPT_PKS3_S6_S4_(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZNSt11__copy_moveILb1ELb1ESt26random_access_iterator_tagE8__copy_mIcEEPT_PKS3_S6_S4_(ptr noundef %__first, ptr noundef %__last, ptr noundef %__result) #1 comdat align 2 {
entry:
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__result.addr = alloca ptr, align 8
  %_Num = alloca i64, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store ptr %__last, ptr %__last.addr, align 8
  store ptr %__result, ptr %__result.addr, align 8
  %0 = load ptr, ptr %__last.addr, align 8
  %1 = load ptr, ptr %__first.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %_Num, align 8
  %2 = load i64, ptr %_Num, align 8
  %tobool = icmp ne i64 %2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %__result.addr, align 8
  %4 = load ptr, ptr %__first.addr, align 8
  %5 = load i64, ptr %_Num, align 8
  %mul = mul i64 1, %5
  call void @llvm.memmove.p0.p0.i64(ptr align 1 %3, ptr align 1 %4, i64 %mul, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load ptr, ptr %__result.addr, align 8
  %7 = load i64, ptr %_Num, align 8
  %add.ptr = getelementptr inbounds i8, ptr %6, i64 %7
  ret ptr %add.ptr
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memmove.p0.p0.i64(ptr nocapture writeonly, ptr nocapture readonly, i64, i1 immarg) #6

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 8 dereferenceable(24) ptr @_ZN4llvh7APFloat7StorageaSEOS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %RHS) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %this1, align 8
  %call = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %0)
  br i1 %call, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %RHS.addr, align 8
  %2 = load ptr, ptr %1, align 8
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %2)
  br i1 %call2, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %3 = load ptr, ptr %RHS.addr, align 8
  %call3 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN4llvh6detail9IEEEFloataSEOS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %3)
  br label %if.end12

if.else:                                          ; preds = %land.lhs.true, %entry
  %4 = load ptr, ptr %this1, align 8
  %call4 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %4)
  br i1 %call4, label %land.lhs.true5, label %if.else9

land.lhs.true5:                                   ; preds = %if.else
  %5 = load ptr, ptr %RHS.addr, align 8
  %6 = load ptr, ptr %5, align 8
  %call6 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %6)
  br i1 %call6, label %if.then7, label %if.else9

if.then7:                                         ; preds = %land.lhs.true5
  %7 = load ptr, ptr %RHS.addr, align 8
  %call8 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN4llvh6detail13DoubleAPFloataSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %7)
  br label %if.end11

if.else9:                                         ; preds = %land.lhs.true5, %if.else
  %8 = load ptr, ptr %RHS.addr, align 8
  %cmp = icmp ne ptr %this1, %8
  br i1 %cmp, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.else9
  call void @_ZN4llvh7APFloat7StorageD2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this1) #10
  %9 = load ptr, ptr %RHS.addr, align 8
  call void @_ZN4llvh7APFloat7StorageC2EOS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %9)
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.else9
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then7
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %if.then
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh7APFloat7StorageD2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %this1, align 8
  %call = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %0)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @_ZN4llvh6detail9IEEEFloatD1Ev(ptr noundef nonnull align 8 dereferenceable(24) %this1) #10
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %this1, align 8
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %1)
  br i1 %call2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  call void @_ZN4llvh6detail13DoubleAPFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this1) #10
  br label %return

if.end4:                                          ; preds = %if.end
  unreachable

return:                                           ; preds = %if.then3, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh7APFloat7StorageC2EOS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %RHS) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %RHS.addr, align 8
  %1 = load ptr, ptr %0, align 8
  %call = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %1)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %RHS.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloatC1EOS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %2)
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %RHS.addr, align 8
  %4 = load ptr, ptr %3, align 8
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %4)
  br i1 %call2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %5 = load ptr, ptr %RHS.addr, align 8
  call void @_ZN4llvh6detail13DoubleAPFloatC1EOS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %5)
  br label %return

if.end4:                                          ; preds = %if.end
  unreachable

return:                                           ; preds = %if.then3, %if.then
  ret void
}

declare noundef i64 @_ZN4llvh5APInt14tcSubtractPartEPmmj(ptr noundef, i64 noundef, i32 noundef) #5

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh7APFloat7StorageC2IJNS_11APFloatBase16uninitializedTagEEEERKNS_12fltSemanticsEDpOT_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 4 dereferenceable(12) %Semantics, ptr noundef nonnull align 4 dereferenceable(4) %Args) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Semantics.addr = alloca ptr, align 8
  %Args.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %Semantics, ptr %Semantics.addr, align 8
  store ptr %Args, ptr %Args.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %Semantics.addr, align 8
  %call = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %0)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %Semantics.addr, align 8
  %2 = load ptr, ptr %Args.addr, align 8
  %3 = load i32, ptr %2, align 4
  call void @_ZN4llvh6detail9IEEEFloatC1ERKNS_12fltSemanticsENS_11APFloatBase16uninitializedTagE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 4 dereferenceable(12) %1, i32 noundef %3)
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %Semantics.addr, align 8
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %4)
  br i1 %call2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %5 = load ptr, ptr %Semantics.addr, align 8
  %6 = load ptr, ptr %Args.addr, align 8
  %7 = load i32, ptr %6, align 4
  call void @_ZN4llvh6detail13DoubleAPFloatC1ERKNS_12fltSemanticsENS_11APFloatBase16uninitializedTagE(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 4 dereferenceable(12) %5, i32 noundef %7)
  br label %return

if.end4:                                          ; preds = %if.end
  unreachable

return:                                           ; preds = %if.then3, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh7APFloat7StorageC2IJRmEEERKNS_12fltSemanticsEDpOT_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 4 dereferenceable(12) %Semantics, ptr noundef nonnull align 8 dereferenceable(8) %Args) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Semantics.addr = alloca ptr, align 8
  %Args.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %Semantics, ptr %Semantics.addr, align 8
  store ptr %Args, ptr %Args.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %Semantics.addr, align 8
  %call = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %0)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %Semantics.addr, align 8
  %2 = load ptr, ptr %Args.addr, align 8
  %3 = load i64, ptr %2, align 8
  call void @_ZN4llvh6detail9IEEEFloatC1ERKNS_12fltSemanticsEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 4 dereferenceable(12) %1, i64 noundef %3)
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %Semantics.addr, align 8
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %4)
  br i1 %call2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %5 = load ptr, ptr %Semantics.addr, align 8
  %6 = load ptr, ptr %Args.addr, align 8
  %7 = load i64, ptr %6, align 8
  call void @_ZN4llvh6detail13DoubleAPFloatC1ERKNS_12fltSemanticsEm(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 4 dereferenceable(12) %5, i64 noundef %7)
  br label %return

if.end4:                                          ; preds = %if.end
  unreachable

return:                                           ; preds = %if.then3, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh7APFloat7StorageC2IJRKNS_5APIntEEEERKNS_12fltSemanticsEDpOT_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 4 dereferenceable(12) %Semantics, ptr noundef nonnull align 8 dereferenceable(12) %Args) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Semantics.addr = alloca ptr, align 8
  %Args.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %Semantics, ptr %Semantics.addr, align 8
  store ptr %Args, ptr %Args.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %Semantics.addr, align 8
  %call = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %0)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %Semantics.addr, align 8
  %2 = load ptr, ptr %Args.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloatC1ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 4 dereferenceable(12) %1, ptr noundef nonnull align 8 dereferenceable(12) %2)
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %Semantics.addr, align 8
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %3)
  br i1 %call2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %4 = load ptr, ptr %Semantics.addr, align 8
  %5 = load ptr, ptr %Args.addr, align 8
  call void @_ZN4llvh6detail13DoubleAPFloatC1ERKNS_12fltSemanticsERKNS_5APIntE(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 4 dereferenceable(12) %4, ptr noundef nonnull align 8 dereferenceable(12) %5)
  br label %return

if.end4:                                          ; preds = %if.end
  unreachable

return:                                           ; preds = %if.then3, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh7APFloat7StorageC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %RHS) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %RHS.addr, align 8
  %1 = load ptr, ptr %0, align 8
  %call = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %1)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %RHS.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloatC1ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %2)
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %RHS.addr, align 8
  %4 = load ptr, ptr %3, align 8
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %4)
  br i1 %call2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %5 = load ptr, ptr %RHS.addr, align 8
  call void @_ZN4llvh6detail13DoubleAPFloatC1ERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %5)
  br label %return

if.end4:                                          ; preds = %if.end
  unreachable

return:                                           ; preds = %if.then3, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZNSt15__uniq_ptr_dataIN4llvh7APFloatESt14default_deleteIA_S1_ELb1ELb1EEC2EOS5_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 8 dereferenceable(8) %0) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %0, ptr %.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %1 = load ptr, ptr %.addr, align 8
  call void @_ZNSt15__uniq_ptr_implIN4llvh7APFloatESt14default_deleteIA_S1_EEC2EOS5_(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef nonnull align 8 dereferenceable(8) %1) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZNSt15__uniq_ptr_implIN4llvh7APFloatESt14default_deleteIA_S1_EEC2EOS5_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 8 dereferenceable(8) %__u) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %__u.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %__u, ptr %__u.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %_M_t = getelementptr inbounds %"class.std::__uniq_ptr_impl", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %__u.addr, align 8
  %_M_t2 = getelementptr inbounds %"class.std::__uniq_ptr_impl", ptr %0, i32 0, i32 0
  call void @_ZNSt5tupleIJPN4llvh7APFloatESt14default_deleteIA_S1_EEEC2EOS6_(ptr noundef nonnull align 8 dereferenceable(8) %_M_t, ptr noundef nonnull align 8 dereferenceable(8) %_M_t2) #10
  %1 = load ptr, ptr %__u.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNSt15__uniq_ptr_implIN4llvh7APFloatESt14default_deleteIA_S1_EE6_M_ptrEv(ptr noundef nonnull align 8 dereferenceable(8) %1) #10
  store ptr null, ptr %call, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZNSt5tupleIJPN4llvh7APFloatESt14default_deleteIA_S1_EEEC2EOS6_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 8 dereferenceable(8) %0) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %0, ptr %.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %1 = load ptr, ptr %.addr, align 8
  call void @_ZNSt11_Tuple_implILm0EJPN4llvh7APFloatESt14default_deleteIA_S1_EEEC2EOS6_(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef nonnull align 8 dereferenceable(8) %1) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 8 dereferenceable(8) ptr @_ZNSt15__uniq_ptr_implIN4llvh7APFloatESt14default_deleteIA_S1_EE6_M_ptrEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %_M_t = getelementptr inbounds %"class.std::__uniq_ptr_impl", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZSt3getILm0EJPN4llvh7APFloatESt14default_deleteIA_S1_EEERNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERSA_(ptr noundef nonnull align 8 dereferenceable(8) %_M_t) #10
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZNSt11_Tuple_implILm0EJPN4llvh7APFloatESt14default_deleteIA_S1_EEEC2EOS6_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 8 dereferenceable(8) %0) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %0, ptr %.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %1 = load ptr, ptr %.addr, align 8
  call void @_ZNSt11_Tuple_implILm1EJSt14default_deleteIA_N4llvh7APFloatEEEEC2EOS5_(ptr noundef nonnull align 1 dereferenceable(1) %this1, ptr noundef nonnull align 1 dereferenceable(1) %1) #10
  %2 = load ptr, ptr %.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %this1, ptr align 8 %2, i64 8, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZNSt11_Tuple_implILm1EJSt14default_deleteIA_N4llvh7APFloatEEEEC2EOS5_(ptr noundef nonnull align 1 dereferenceable(1) %this, ptr noundef nonnull align 1 dereferenceable(1) %__in) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %__in.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %__in, ptr %__in.addr, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 8 dereferenceable(8) ptr @_ZSt3getILm0EJPN4llvh7APFloatESt14default_deleteIA_S1_EEERNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERSA_(ptr noundef nonnull align 8 dereferenceable(8) %__t) #1 comdat {
entry:
  %__t.addr = alloca ptr, align 8
  store ptr %__t, ptr %__t.addr, align 8
  %0 = load ptr, ptr %__t.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZSt12__get_helperILm0EPN4llvh7APFloatEJSt14default_deleteIA_S1_EEERT0_RSt11_Tuple_implIXT_EJS6_DpT1_EE(ptr noundef nonnull align 8 dereferenceable(8) %0) #10
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 8 dereferenceable(8) ptr @_ZSt12__get_helperILm0EPN4llvh7APFloatEJSt14default_deleteIA_S1_EEERT0_RSt11_Tuple_implIXT_EJS6_DpT1_EE(ptr noundef nonnull align 8 dereferenceable(8) %__t) #1 comdat {
entry:
  %__t.addr = alloca ptr, align 8
  store ptr %__t, ptr %__t.addr, align 8
  %0 = load ptr, ptr %__t.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNSt11_Tuple_implILm0EJPN4llvh7APFloatESt14default_deleteIA_S1_EEE7_M_headERS6_(ptr noundef nonnull align 8 dereferenceable(8) %0) #10
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 8 dereferenceable(8) ptr @_ZNSt11_Tuple_implILm0EJPN4llvh7APFloatESt14default_deleteIA_S1_EEE7_M_headERS6_(ptr noundef nonnull align 8 dereferenceable(8) %__t) #1 comdat align 2 {
entry:
  %__t.addr = alloca ptr, align 8
  store ptr %__t, ptr %__t.addr, align 8
  %0 = load ptr, ptr %__t.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNSt10_Head_baseILm0EPN4llvh7APFloatELb0EE7_M_headERS3_(ptr noundef nonnull align 8 dereferenceable(8) %0) #10
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 8 dereferenceable(8) ptr @_ZNSt10_Head_baseILm0EPN4llvh7APFloatELb0EE7_M_headERS3_(ptr noundef nonnull align 8 dereferenceable(8) %__b) #1 comdat align 2 {
entry:
  %__b.addr = alloca ptr, align 8
  store ptr %__b, ptr %__b.addr, align 8
  %0 = load ptr, ptr %__b.addr, align 8
  %_M_head_impl = getelementptr inbounds %"struct.std::_Head_base.3", ptr %0, i32 0, i32 0
  ret ptr %_M_head_impl
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 8 dereferenceable(24) ptr @_ZN4llvh7APFloat7StorageaSERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %RHS) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %RHS.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %RHS, ptr %RHS.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %this1, align 8
  %call = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %0)
  br i1 %call, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %RHS.addr, align 8
  %2 = load ptr, ptr %1, align 8
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %2)
  br i1 %call2, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %3 = load ptr, ptr %RHS.addr, align 8
  %call3 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN4llvh6detail9IEEEFloataSERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %3)
  br label %if.end12

if.else:                                          ; preds = %land.lhs.true, %entry
  %4 = load ptr, ptr %this1, align 8
  %call4 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %4)
  br i1 %call4, label %land.lhs.true5, label %if.else9

land.lhs.true5:                                   ; preds = %if.else
  %5 = load ptr, ptr %RHS.addr, align 8
  %6 = load ptr, ptr %5, align 8
  %call6 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %6)
  br i1 %call6, label %if.then7, label %if.else9

if.then7:                                         ; preds = %land.lhs.true5
  %7 = load ptr, ptr %RHS.addr, align 8
  %call8 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN4llvh6detail13DoubleAPFloataSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %7)
  br label %if.end11

if.else9:                                         ; preds = %land.lhs.true5, %if.else
  %8 = load ptr, ptr %RHS.addr, align 8
  %cmp = icmp ne ptr %this1, %8
  br i1 %cmp, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.else9
  call void @_ZN4llvh7APFloat7StorageD2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this1) #10
  %9 = load ptr, ptr %RHS.addr, align 8
  call void @_ZN4llvh7APFloat7StorageC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %9)
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.else9
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then7
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %if.then
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZNSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EED2Ev(ptr noundef nonnull align 8 dereferenceable(8) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %__ptr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %_M_t = getelementptr inbounds %"class.std::unique_ptr", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNSt15__uniq_ptr_implIN4llvh7APFloatESt14default_deleteIA_S1_EE6_M_ptrEv(ptr noundef nonnull align 8 dereferenceable(8) %_M_t) #10
  store ptr %call, ptr %__ptr, align 8
  %0 = load ptr, ptr %__ptr, align 8
  %1 = load ptr, ptr %0, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call noundef nonnull align 1 dereferenceable(1) ptr @_ZNSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EE11get_deleterEv(ptr noundef nonnull align 8 dereferenceable(8) %this1) #10
  %2 = load ptr, ptr %__ptr, align 8
  %3 = load ptr, ptr %2, align 8
  call void @_ZNKSt14default_deleteIA_N4llvh7APFloatEEclIS1_EENSt9enable_ifIXsr14is_convertibleIPA_T_PS2_EE5valueEvE4typeEPS6_(ptr noundef nonnull align 1 dereferenceable(1) %call2, ptr noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load ptr, ptr %__ptr, align 8
  store ptr null, ptr %4, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 1 dereferenceable(1) ptr @_ZNSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EE11get_deleterEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %_M_t = getelementptr inbounds %"class.std::unique_ptr", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZNSt15__uniq_ptr_implIN4llvh7APFloatESt14default_deleteIA_S1_EE10_M_deleterEv(ptr noundef nonnull align 8 dereferenceable(8) %_M_t) #10
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZNKSt14default_deleteIA_N4llvh7APFloatEEclIS1_EENSt9enable_ifIXsr14is_convertibleIPA_T_PS2_EE5valueEvE4typeEPS6_(ptr noundef nonnull align 1 dereferenceable(1) %this, ptr noundef %__ptr) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %__ptr.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %__ptr, ptr %__ptr.addr, align 8
  %0 = load ptr, ptr %__ptr.addr, align 8
  %isnull = icmp eq ptr %0, null
  br i1 %isnull, label %delete.end3, label %delete.notnull

delete.notnull:                                   ; preds = %entry
  %1 = getelementptr inbounds i8, ptr %0, i64 -8
  %2 = load i64, ptr %1, align 8
  %delete.end = getelementptr inbounds %"class.llvh::APFloat", ptr %0, i64 %2
  %arraydestroy.isempty = icmp eq ptr %0, %delete.end
  br i1 %arraydestroy.isempty, label %arraydestroy.done2, label %arraydestroy.body

arraydestroy.body:                                ; preds = %arraydestroy.body, %delete.notnull
  %arraydestroy.elementPast = phi ptr [ %delete.end, %delete.notnull ], [ %arraydestroy.element, %arraydestroy.body ]
  %arraydestroy.element = getelementptr inbounds %"class.llvh::APFloat", ptr %arraydestroy.elementPast, i64 -1
  call void @_ZN4llvh7APFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(32) %arraydestroy.element) #10
  %arraydestroy.done = icmp eq ptr %arraydestroy.element, %0
  br i1 %arraydestroy.done, label %arraydestroy.done2, label %arraydestroy.body

arraydestroy.done2:                               ; preds = %arraydestroy.body, %delete.notnull
  call void @_ZdaPv(ptr noundef %1) #14
  br label %delete.end3

delete.end3:                                      ; preds = %arraydestroy.done2, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 1 dereferenceable(1) ptr @_ZNSt15__uniq_ptr_implIN4llvh7APFloatESt14default_deleteIA_S1_EE10_M_deleterEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %_M_t = getelementptr inbounds %"class.std::__uniq_ptr_impl", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZSt3getILm1EJPN4llvh7APFloatESt14default_deleteIA_S1_EEERNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERSA_(ptr noundef nonnull align 8 dereferenceable(8) %_M_t) #10
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 1 dereferenceable(1) ptr @_ZSt3getILm1EJPN4llvh7APFloatESt14default_deleteIA_S1_EEERNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERSA_(ptr noundef nonnull align 8 dereferenceable(8) %__t) #1 comdat {
entry:
  %__t.addr = alloca ptr, align 8
  store ptr %__t, ptr %__t.addr, align 8
  %0 = load ptr, ptr %__t.addr, align 8
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZSt12__get_helperILm1ESt14default_deleteIA_N4llvh7APFloatEEJEERT0_RSt11_Tuple_implIXT_EJS5_DpT1_EE(ptr noundef nonnull align 1 dereferenceable(1) %0) #10
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 1 dereferenceable(1) ptr @_ZSt12__get_helperILm1ESt14default_deleteIA_N4llvh7APFloatEEJEERT0_RSt11_Tuple_implIXT_EJS5_DpT1_EE(ptr noundef nonnull align 1 dereferenceable(1) %__t) #1 comdat {
entry:
  %__t.addr = alloca ptr, align 8
  store ptr %__t, ptr %__t.addr, align 8
  %0 = load ptr, ptr %__t.addr, align 8
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZNSt11_Tuple_implILm1EJSt14default_deleteIA_N4llvh7APFloatEEEE7_M_headERS5_(ptr noundef nonnull align 1 dereferenceable(1) %0) #10
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 1 dereferenceable(1) ptr @_ZNSt11_Tuple_implILm1EJSt14default_deleteIA_N4llvh7APFloatEEEE7_M_headERS5_(ptr noundef nonnull align 1 dereferenceable(1) %__t) #1 comdat align 2 {
entry:
  %__t.addr = alloca ptr, align 8
  store ptr %__t, ptr %__t.addr, align 8
  %0 = load ptr, ptr %__t.addr, align 8
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZNSt10_Head_baseILm1ESt14default_deleteIA_N4llvh7APFloatEELb1EE7_M_headERS5_(ptr noundef nonnull align 1 dereferenceable(1) %0) #10
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 1 dereferenceable(1) ptr @_ZNSt10_Head_baseILm1ESt14default_deleteIA_N4llvh7APFloatEELb1EE7_M_headERS5_(ptr noundef nonnull align 1 dereferenceable(1) %__b) #1 comdat align 2 {
entry:
  %__b.addr = alloca ptr, align 8
  store ptr %__b, ptr %__b.addr, align 8
  %0 = load ptr, ptr %__b.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh7APFloat5isNaNEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i32 @_ZNK4llvh7APFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %cmp = icmp eq i32 %call, 1
  ret i1 %cmp
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 8 dereferenceable(24) ptr @_ZNK4llvh7APFloat7getIEEEEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %U, align 8
  %call = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %0)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %U2 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  store ptr %U2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %U3 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %U3, align 8
  %call4 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %1)
  br i1 %call4, label %if.then5, label %if.end9

if.then5:                                         ; preds = %if.end
  %U6 = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  %call7 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNK4llvh6detail13DoubleAPFloat8getFirstEv(ptr noundef nonnull align 8 dereferenceable(16) %U6)
  %U8 = getelementptr inbounds %"class.llvh::APFloat", ptr %call7, i32 0, i32 1
  store ptr %U8, ptr %retval, align 8
  br label %return

if.end9:                                          ; preds = %if.end
  unreachable

return:                                           ; preds = %if.then5, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 8 dereferenceable(32) ptr @_ZNK4llvh6detail13DoubleAPFloat8getFirstEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats, i64 noundef 0)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZNK4llvh6detail9IEEEFloat11getCategoryEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %category = getelementptr inbounds %"class.llvh::detail::IEEEFloat", ptr %this1, i32 0, i32 3
  %bf.load = load i8, ptr %category, align 2
  %bf.clear = and i8 %bf.load, 7
  %bf.cast = zext i8 %bf.clear to i32
  ret i32 %bf.cast
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh7APFloatC2ENS_6detail13DoubleAPFloatERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef %F, ptr noundef nonnull align 4 dereferenceable(12) %S) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %F.indirect_addr = alloca ptr, align 8
  %S.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.llvh::detail::DoubleAPFloat", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %F, ptr %F.indirect_addr, align 8
  store ptr %S, ptr %S.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %U = getelementptr inbounds %"class.llvh::APFloat", ptr %this1, i32 0, i32 1
  call void @_ZN4llvh6detail13DoubleAPFloatC1EOS1_(ptr noundef nonnull align 8 dereferenceable(16) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(16) %F)
  %0 = load ptr, ptr %S.addr, align 8
  call void @_ZN4llvh7APFloat7StorageC2ENS_6detail13DoubleAPFloatERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(24) %U, ptr noundef %agg.tmp, ptr noundef nonnull align 4 dereferenceable(12) %0)
  call void @_ZN4llvh6detail13DoubleAPFloatD2Ev(ptr noundef nonnull align 8 dereferenceable(16) %agg.tmp) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh7APFloat7StorageC2ENS_6detail13DoubleAPFloatERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %F, ptr noundef nonnull align 4 dereferenceable(12) %S) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %F.indirect_addr = alloca ptr, align 8
  %S.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %F, ptr %F.indirect_addr, align 8
  store ptr %S, ptr %S.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4llvh6detail13DoubleAPFloatC1EOS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %F)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh7APFloat7StorageC2IJEEERKNS_12fltSemanticsEDpOT_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 4 dereferenceable(12) %Semantics) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Semantics.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %Semantics, ptr %Semantics.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %Semantics.addr, align 8
  %call = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail9IEEEFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %0)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %Semantics.addr, align 8
  call void @_ZN4llvh6detail9IEEEFloatC1ERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 4 dereferenceable(12) %1)
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %Semantics.addr, align 8
  %call2 = call noundef zeroext i1 @_ZN4llvh7APFloat10usesLayoutINS_6detail13DoubleAPFloatEEEbRKNS_12fltSemanticsE(ptr noundef nonnull align 4 dereferenceable(12) %2)
  br i1 %call2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %3 = load ptr, ptr %Semantics.addr, align 8
  call void @_ZN4llvh6detail13DoubleAPFloatC1ERKNS_12fltSemanticsE(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 4 dereferenceable(12) %3)
  br label %return

if.end4:                                          ; preds = %if.end
  unreachable

return:                                           ; preds = %if.then3, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 8 dereferenceable(32) ptr @_ZN4llvh6detail13DoubleAPFloat8getFirstEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Floats = getelementptr inbounds %"class.llvh::detail::DoubleAPFloat", ptr %this1, i32 0, i32 1
  %call = call noundef nonnull align 8 dereferenceable(32) ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EEixEm(ptr noundef nonnull align 8 dereferenceable(8) %Floats, i64 noundef 0)
  ret ptr %call
}

declare noundef nonnull align 8 dereferenceable(36) ptr @_ZN4llvh11raw_ostream5writeEPKcm(ptr noundef nonnull align 8 dereferenceable(36), ptr noundef, i64 noundef) #5

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef ptr @_ZNK4llvh25SmallVectorTemplateCommonIcvE4dataEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr.i = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store ptr %this1, ptr %this.addr.i, align 8
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %0 = load ptr, ptr %this1.i, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 8 dereferenceable(36) ptr @_ZN4llvh11raw_ostreamlsENS_9StringRefE(ptr noundef nonnull align 8 dereferenceable(36) %this, ptr %Str.coerce0, i64 %Str.coerce1) #1 comdat align 2 {
entry:
  %this.addr.i11 = alloca ptr, align 8
  %this.addr.i9 = alloca ptr, align 8
  %this.addr.i = alloca ptr, align 8
  %retval = alloca ptr, align 8
  %Str = alloca %"class.llvh::StringRef", align 8
  %this.addr = alloca ptr, align 8
  %Size = alloca i64, align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %Str, i32 0, i32 0
  store ptr %Str.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %Str, i32 0, i32 1
  store i64 %Str.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store ptr %Str, ptr %this.addr.i, align 8
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %Length.i = getelementptr inbounds %"class.llvh::StringRef", ptr %this1.i, i32 0, i32 1
  %2 = load i64, ptr %Length.i, align 8
  store i64 %2, ptr %Size, align 8
  %3 = load i64, ptr %Size, align 8
  %OutBufEnd = getelementptr inbounds %"class.llvh::raw_ostream", ptr %this1, i32 0, i32 2
  %4 = load ptr, ptr %OutBufEnd, align 8
  %OutBufCur = getelementptr inbounds %"class.llvh::raw_ostream", ptr %this1, i32 0, i32 3
  %5 = load ptr, ptr %OutBufCur, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %4 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %5 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp = icmp ugt i64 %3, %sub.ptr.sub
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr %Str, ptr %this.addr.i11, align 8
  %this1.i12 = load ptr, ptr %this.addr.i11, align 8
  %6 = load ptr, ptr %this1.i12, align 8
  %7 = load i64, ptr %Size, align 8
  %call3 = call noundef nonnull align 8 dereferenceable(36) ptr @_ZN4llvh11raw_ostream5writeEPKcm(ptr noundef nonnull align 8 dereferenceable(36) %this1, ptr noundef %6, i64 noundef %7)
  store ptr %call3, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %8 = load i64, ptr %Size, align 8
  %tobool = icmp ne i64 %8, 0
  br i1 %tobool, label %if.then4, label %if.end8

if.then4:                                         ; preds = %if.end
  %OutBufCur5 = getelementptr inbounds %"class.llvh::raw_ostream", ptr %this1, i32 0, i32 3
  %9 = load ptr, ptr %OutBufCur5, align 8
  store ptr %Str, ptr %this.addr.i9, align 8
  %this1.i10 = load ptr, ptr %this.addr.i9, align 8
  %10 = load ptr, ptr %this1.i10, align 8
  %11 = load i64, ptr %Size, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %9, ptr align 1 %10, i64 %11, i1 false)
  %12 = load i64, ptr %Size, align 8
  %OutBufCur7 = getelementptr inbounds %"class.llvh::raw_ostream", ptr %this1, i32 0, i32 3
  %13 = load ptr, ptr %OutBufCur7, align 8
  %add.ptr = getelementptr inbounds i8, ptr %13, i64 %12
  store ptr %add.ptr, ptr %OutBufCur7, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then4, %if.end
  store ptr %this1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end8, %if.then
  %14 = load ptr, ptr %retval, align 8
  ret ptr %14
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef ptr @_ZNKSt10unique_ptrIA_N4llvh7APFloatESt14default_deleteIS2_EE3getEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %_M_t = getelementptr inbounds %"class.std::unique_ptr", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNKSt15__uniq_ptr_implIN4llvh7APFloatESt14default_deleteIA_S1_EE6_M_ptrEv(ptr noundef nonnull align 8 dereferenceable(8) %_M_t) #10
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef ptr @_ZNKSt15__uniq_ptr_implIN4llvh7APFloatESt14default_deleteIA_S1_EE6_M_ptrEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %_M_t = getelementptr inbounds %"class.std::__uniq_ptr_impl", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZSt3getILm0EJPN4llvh7APFloatESt14default_deleteIA_S1_EEERKNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERKSA_(ptr noundef nonnull align 8 dereferenceable(8) %_M_t) #10
  %0 = load ptr, ptr %call, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 8 dereferenceable(8) ptr @_ZSt3getILm0EJPN4llvh7APFloatESt14default_deleteIA_S1_EEERKNSt13tuple_elementIXT_ESt5tupleIJDpT0_EEE4typeERKSA_(ptr noundef nonnull align 8 dereferenceable(8) %__t) #1 comdat {
entry:
  %__t.addr = alloca ptr, align 8
  store ptr %__t, ptr %__t.addr, align 8
  %0 = load ptr, ptr %__t.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZSt12__get_helperILm0EPN4llvh7APFloatEJSt14default_deleteIA_S1_EEERKT0_RKSt11_Tuple_implIXT_EJS6_DpT1_EE(ptr noundef nonnull align 8 dereferenceable(8) %0) #10
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 8 dereferenceable(8) ptr @_ZSt12__get_helperILm0EPN4llvh7APFloatEJSt14default_deleteIA_S1_EEERKT0_RKSt11_Tuple_implIXT_EJS6_DpT1_EE(ptr noundef nonnull align 8 dereferenceable(8) %__t) #1 comdat {
entry:
  %__t.addr = alloca ptr, align 8
  store ptr %__t, ptr %__t.addr, align 8
  %0 = load ptr, ptr %__t.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNSt11_Tuple_implILm0EJPN4llvh7APFloatESt14default_deleteIA_S1_EEE7_M_headERKS6_(ptr noundef nonnull align 8 dereferenceable(8) %0) #10
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 8 dereferenceable(8) ptr @_ZNSt11_Tuple_implILm0EJPN4llvh7APFloatESt14default_deleteIA_S1_EEE7_M_headERKS6_(ptr noundef nonnull align 8 dereferenceable(8) %__t) #1 comdat align 2 {
entry:
  %__t.addr = alloca ptr, align 8
  store ptr %__t, ptr %__t.addr, align 8
  %0 = load ptr, ptr %__t.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNSt10_Head_baseILm0EPN4llvh7APFloatELb0EE7_M_headERKS3_(ptr noundef nonnull align 8 dereferenceable(8) %0) #10
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef nonnull align 8 dereferenceable(8) ptr @_ZNSt10_Head_baseILm0EPN4llvh7APFloatELb0EE7_M_headERKS3_(ptr noundef nonnull align 8 dereferenceable(8) %__b) #1 comdat align 2 {
entry:
  %__b.addr = alloca ptr, align 8
  store ptr %__b, ptr %__b.addr, align 8
  %0 = load ptr, ptr %__b.addr, align 8
  %_M_head_impl = getelementptr inbounds %"struct.std::_Head_base.3", ptr %0, i32 0, i32 0
  ret ptr %_M_head_impl
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef zeroext i1 @_ZSt11__equal_auxIPKmS1_EbT_S2_T0_(ptr noundef %__first1, ptr noundef %__last1, ptr noundef %__first2) #1 comdat {
entry:
  %__first1.addr = alloca ptr, align 8
  %__last1.addr = alloca ptr, align 8
  %__first2.addr = alloca ptr, align 8
  store ptr %__first1, ptr %__first1.addr, align 8
  store ptr %__last1, ptr %__last1.addr, align 8
  store ptr %__first2, ptr %__first2.addr, align 8
  %0 = load ptr, ptr %__first1.addr, align 8
  %call = call noundef ptr @_ZSt12__niter_baseIPKmET_S2_(ptr noundef %0) #10
  %1 = load ptr, ptr %__last1.addr, align 8
  %call1 = call noundef ptr @_ZSt12__niter_baseIPKmET_S2_(ptr noundef %1) #10
  %2 = load ptr, ptr %__first2.addr, align 8
  %call2 = call noundef ptr @_ZSt12__niter_baseIPKmET_S2_(ptr noundef %2) #10
  %call3 = call noundef zeroext i1 @_ZSt12__equal_aux1IPKmS1_EbT_S2_T0_(ptr noundef %call, ptr noundef %call1, ptr noundef %call2)
  ret i1 %call3
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef zeroext i1 @_ZSt12__equal_aux1IPKmS1_EbT_S2_T0_(ptr noundef %__first1, ptr noundef %__last1, ptr noundef %__first2) #1 comdat {
entry:
  %__first1.addr = alloca ptr, align 8
  %__last1.addr = alloca ptr, align 8
  %__first2.addr = alloca ptr, align 8
  %__simple = alloca i8, align 1
  store ptr %__first1, ptr %__first1.addr, align 8
  store ptr %__last1, ptr %__last1.addr, align 8
  store ptr %__first2, ptr %__first2.addr, align 8
  store i8 1, ptr %__simple, align 1
  %0 = load ptr, ptr %__first1.addr, align 8
  %1 = load ptr, ptr %__last1.addr, align 8
  %2 = load ptr, ptr %__first2.addr, align 8
  %call = call noundef zeroext i1 @_ZNSt7__equalILb1EE5equalImEEbPKT_S4_S4_(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret i1 %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZSt12__niter_baseIPKmET_S2_(ptr noundef %__it) #1 comdat {
entry:
  %__it.addr = alloca ptr, align 8
  store ptr %__it, ptr %__it.addr, align 8
  %0 = load ptr, ptr %__it.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef zeroext i1 @_ZNSt7__equalILb1EE5equalImEEbPKT_S4_S4_(ptr noundef %__first1, ptr noundef %__last1, ptr noundef %__first2) #1 comdat align 2 {
entry:
  %retval = alloca i1, align 1
  %__first1.addr = alloca ptr, align 8
  %__last1.addr = alloca ptr, align 8
  %__first2.addr = alloca ptr, align 8
  %__len = alloca i64, align 8
  store ptr %__first1, ptr %__first1.addr, align 8
  store ptr %__last1, ptr %__last1.addr, align 8
  store ptr %__first2, ptr %__first2.addr, align 8
  %0 = load ptr, ptr %__last1.addr, align 8
  %1 = load ptr, ptr %__first1.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  store i64 %sub.ptr.div, ptr %__len, align 8
  %2 = load i64, ptr %__len, align 8
  %tobool = icmp ne i64 %2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %__first1.addr, align 8
  %4 = load ptr, ptr %__first2.addr, align 8
  %5 = load i64, ptr %__len, align 8
  %call = call noundef i32 @_ZSt8__memcmpImmEiPKT_PKT0_m(ptr noundef %3, ptr noundef %4, i64 noundef %5)
  %tobool1 = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool1, true
  store i1 %lnot, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i1, ptr %retval, align 1
  ret i1 %6
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZSt8__memcmpImmEiPKT_PKT0_m(ptr noundef %__first1, ptr noundef %__first2, i64 noundef %__num) #1 comdat {
entry:
  %__first1.addr = alloca ptr, align 8
  %__first2.addr = alloca ptr, align 8
  %__num.addr = alloca i64, align 8
  store ptr %__first1, ptr %__first1.addr, align 8
  store ptr %__first2, ptr %__first2.addr, align 8
  store i64 %__num, ptr %__num.addr, align 8
  %0 = load ptr, ptr %__first1.addr, align 8
  %1 = load ptr, ptr %__first2.addr, align 8
  %2 = load i64, ptr %__num.addr, align 8
  %mul = mul i64 8, %2
  %call = call i32 @memcmp(ptr noundef %0, ptr noundef %1, i64 noundef %mul) #10
  ret i32 %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh15MutableArrayRefImEC2EPmm(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %data, i64 noundef %length) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  %length.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  store i64 %length, ptr %length.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %data.addr, align 8
  %1 = load i64, ptr %length.addr, align 8
  call void @_ZN4llvh8ArrayRefImEC2EPKmm(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef %0, i64 noundef %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef ptr @_ZNK4llvh8ArrayRefImE4dataEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %"class.llvh::ArrayRef", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %Data, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh8ArrayRefImEC2EPKmm(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %data, i64 noundef %length) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  %length.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  store i64 %length, ptr %length.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %"class.llvh::ArrayRef", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %data.addr, align 8
  store ptr %0, ptr %Data, align 8
  %Length = getelementptr inbounds %"class.llvh::ArrayRef", ptr %this1, i32 0, i32 1
  %1 = load i64, ptr %length.addr, align 8
  store i64 %1, ptr %Length, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh7hashing6detail29hash_combine_recursive_helperC2Ev(ptr noundef nonnull align 8 dereferenceable(128) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %seed = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 2
  %call = call noundef i64 @_ZN4llvh7hashing6detail18get_execution_seedEv()
  store i64 %call, ptr %seed, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden i64 @_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineIhJhjEEENS_9hash_codeEmPcS5_RKT_DpRKT0_(ptr noundef nonnull align 8 dereferenceable(128) %this, i64 noundef %length, ptr noundef %buffer_ptr, ptr noundef %buffer_end, ptr noundef nonnull align 1 dereferenceable(1) %arg, ptr noundef nonnull align 1 dereferenceable(1) %args, ptr noundef nonnull align 4 dereferenceable(4) %args1) #1 comdat align 2 {
entry:
  %retval = alloca %"class.llvh::hash_code", align 8
  %this.addr = alloca ptr, align 8
  %length.addr = alloca i64, align 8
  %buffer_ptr.addr = alloca ptr, align 8
  %buffer_end.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %args.addr2 = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %length, ptr %length.addr, align 8
  store ptr %buffer_ptr, ptr %buffer_ptr.addr, align 8
  store ptr %buffer_end, ptr %buffer_end.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store ptr %args1, ptr %args.addr2, align 8
  %this3 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %buffer_ptr.addr, align 8
  %1 = load ptr, ptr %buffer_end.addr, align 8
  %2 = load ptr, ptr %arg.addr, align 8
  %call = call noundef zeroext i8 @_ZN4llvh7hashing6detail17get_hashable_dataIhEENSt9enable_ifIXsr16is_hashable_dataIT_EE5valueES4_E4typeERKS4_(ptr noundef nonnull align 1 dereferenceable(1) %2)
  %call4 = call noundef ptr @_ZN4llvh7hashing6detail29hash_combine_recursive_helper12combine_dataIhEEPcRmS4_S4_T_(ptr noundef nonnull align 8 dereferenceable(128) %this3, ptr noundef nonnull align 8 dereferenceable(8) %length.addr, ptr noundef %0, ptr noundef %1, i8 noundef zeroext %call)
  store ptr %call4, ptr %buffer_ptr.addr, align 8
  %3 = load i64, ptr %length.addr, align 8
  %4 = load ptr, ptr %buffer_ptr.addr, align 8
  %5 = load ptr, ptr %buffer_end.addr, align 8
  %6 = load ptr, ptr %args.addr, align 8
  %7 = load ptr, ptr %args.addr2, align 8
  %call5 = call i64 @_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineIhJjEEENS_9hash_codeEmPcS5_RKT_DpRKT0_(ptr noundef nonnull align 8 dereferenceable(128) %this3, i64 noundef %3, ptr noundef %4, ptr noundef %5, ptr noundef nonnull align 1 dereferenceable(1) %6, ptr noundef nonnull align 4 dereferenceable(4) %7)
  %coerce.dive = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  store i64 %call5, ptr %coerce.dive, align 8
  %coerce.dive6 = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  %8 = load i64, ptr %coerce.dive6, align 8
  ret i64 %8
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZN4llvh7hashing6detail18get_execution_seedEv() #1 comdat {
entry:
  %seed_prime = alloca i64, align 8
  store i64 -49064778989728563, ptr %seed_prime, align 8
  %0 = load atomic i8, ptr @_ZGVZN4llvh7hashing6detail18get_execution_seedEvE4seed acquire, align 8
  %guard.uninitialized = icmp eq i8 %0, 0
  br i1 %guard.uninitialized, label %init.check, label %init.end, !prof !44

init.check:                                       ; preds = %entry
  %1 = call i32 @__cxa_guard_acquire(ptr @_ZGVZN4llvh7hashing6detail18get_execution_seedEvE4seed) #10
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %init, label %init.end

init:                                             ; preds = %init.check
  %2 = load i64, ptr @_ZN4llvh7hashing6detail19fixed_seed_overrideE, align 8
  %tobool1 = icmp ne i64 %2, 0
  br i1 %tobool1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %init
  %3 = load i64, ptr @_ZN4llvh7hashing6detail19fixed_seed_overrideE, align 8
  br label %cond.end

cond.false:                                       ; preds = %init
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %3, %cond.true ], [ -49064778989728563, %cond.false ]
  store i64 %cond, ptr @_ZZN4llvh7hashing6detail18get_execution_seedEvE4seed, align 8
  call void @__cxa_guard_release(ptr @_ZGVZN4llvh7hashing6detail18get_execution_seedEvE4seed) #10
  br label %init.end

init.end:                                         ; preds = %cond.end, %init.check, %entry
  %4 = load i64, ptr @_ZZN4llvh7hashing6detail18get_execution_seedEvE4seed, align 8
  ret i64 %4
}

; Function Attrs: nounwind
declare i32 @__cxa_guard_acquire(ptr) #10

; Function Attrs: nounwind
declare void @__cxa_guard_release(ptr) #10

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef ptr @_ZN4llvh7hashing6detail29hash_combine_recursive_helper12combine_dataIhEEPcRmS4_S4_T_(ptr noundef nonnull align 8 dereferenceable(128) %this, ptr noundef nonnull align 8 dereferenceable(8) %length, ptr noundef %buffer_ptr, ptr noundef %buffer_end, i8 noundef zeroext %data) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %length.addr = alloca ptr, align 8
  %buffer_ptr.addr = alloca ptr, align 8
  %buffer_end.addr = alloca ptr, align 8
  %data.addr = alloca i8, align 1
  %partial_store_size = alloca i64, align 8
  %ref.tmp = alloca %"struct.llvh::hashing::detail::hash_state", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %length, ptr %length.addr, align 8
  store ptr %buffer_ptr, ptr %buffer_ptr.addr, align 8
  store ptr %buffer_end, ptr %buffer_end.addr, align 8
  store i8 %data, ptr %data.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %buffer_end.addr, align 8
  %call = call noundef zeroext i1 @_ZN4llvh7hashing6detail17store_and_advanceIhEEbRPcS3_RKT_m(ptr noundef nonnull align 8 dereferenceable(8) %buffer_ptr.addr, ptr noundef %0, ptr noundef nonnull align 1 dereferenceable(1) %data.addr, i64 noundef 0)
  br i1 %call, label %if.end12, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %buffer_end.addr, align 8
  %2 = load ptr, ptr %buffer_ptr.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %partial_store_size, align 8
  %3 = load ptr, ptr %buffer_ptr.addr, align 8
  %4 = load i64, ptr %partial_store_size, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %3, ptr align 1 %data.addr, i64 %4, i1 false)
  %5 = load ptr, ptr %length.addr, align 8
  %6 = load i64, ptr %5, align 8
  %cmp = icmp eq i64 %6, 0
  br i1 %cmp, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %buffer = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 0
  %arraydecay = getelementptr inbounds [64 x i8], ptr %buffer, i64 0, i64 0
  %seed = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 2
  %7 = load i64, ptr %seed, align 8
  call void @_ZN4llvh7hashing6detail10hash_state6createEPKcm(ptr sret(%"struct.llvh::hashing::detail::hash_state") align 8 %ref.tmp, ptr noundef %arraydecay, i64 noundef %7)
  %state3 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %state3, ptr align 8 %ref.tmp, i64 56, i1 false)
  %8 = load ptr, ptr %length.addr, align 8
  store i64 64, ptr %8, align 8
  br label %if.end

if.else:                                          ; preds = %if.then
  %state4 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 1
  %buffer5 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 0
  %arraydecay6 = getelementptr inbounds [64 x i8], ptr %buffer5, i64 0, i64 0
  call void @_ZN4llvh7hashing6detail10hash_state3mixEPKc(ptr noundef nonnull align 8 dereferenceable(56) %state4, ptr noundef %arraydecay6)
  %9 = load ptr, ptr %length.addr, align 8
  %10 = load i64, ptr %9, align 8
  %add = add i64 %10, 64
  store i64 %add, ptr %9, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then2
  %buffer7 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 0
  %arraydecay8 = getelementptr inbounds [64 x i8], ptr %buffer7, i64 0, i64 0
  store ptr %arraydecay8, ptr %buffer_ptr.addr, align 8
  %11 = load ptr, ptr %buffer_end.addr, align 8
  %12 = load i64, ptr %partial_store_size, align 8
  %call9 = call noundef zeroext i1 @_ZN4llvh7hashing6detail17store_and_advanceIhEEbRPcS3_RKT_m(ptr noundef nonnull align 8 dereferenceable(8) %buffer_ptr.addr, ptr noundef %11, ptr noundef nonnull align 1 dereferenceable(1) %data.addr, i64 noundef %12)
  br i1 %call9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end
  call void @abort() #17
  unreachable

if.end11:                                         ; preds = %if.end
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %entry
  %13 = load ptr, ptr %buffer_ptr.addr, align 8
  ret ptr %13
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i8 @_ZN4llvh7hashing6detail17get_hashable_dataIhEENSt9enable_ifIXsr16is_hashable_dataIT_EE5valueES4_E4typeERKS4_(ptr noundef nonnull align 1 dereferenceable(1) %value) #1 comdat {
entry:
  %value.addr = alloca ptr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %value.addr, align 8
  %1 = load i8, ptr %0, align 1
  ret i8 %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden i64 @_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineIhJjEEENS_9hash_codeEmPcS5_RKT_DpRKT0_(ptr noundef nonnull align 8 dereferenceable(128) %this, i64 noundef %length, ptr noundef %buffer_ptr, ptr noundef %buffer_end, ptr noundef nonnull align 1 dereferenceable(1) %arg, ptr noundef nonnull align 4 dereferenceable(4) %args) #1 comdat align 2 {
entry:
  %retval = alloca %"class.llvh::hash_code", align 8
  %this.addr = alloca ptr, align 8
  %length.addr = alloca i64, align 8
  %buffer_ptr.addr = alloca ptr, align 8
  %buffer_end.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %length, ptr %length.addr, align 8
  store ptr %buffer_ptr, ptr %buffer_ptr.addr, align 8
  store ptr %buffer_end, ptr %buffer_end.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %buffer_ptr.addr, align 8
  %1 = load ptr, ptr %buffer_end.addr, align 8
  %2 = load ptr, ptr %arg.addr, align 8
  %call = call noundef zeroext i8 @_ZN4llvh7hashing6detail17get_hashable_dataIhEENSt9enable_ifIXsr16is_hashable_dataIT_EE5valueES4_E4typeERKS4_(ptr noundef nonnull align 1 dereferenceable(1) %2)
  %call2 = call noundef ptr @_ZN4llvh7hashing6detail29hash_combine_recursive_helper12combine_dataIhEEPcRmS4_S4_T_(ptr noundef nonnull align 8 dereferenceable(128) %this1, ptr noundef nonnull align 8 dereferenceable(8) %length.addr, ptr noundef %0, ptr noundef %1, i8 noundef zeroext %call)
  store ptr %call2, ptr %buffer_ptr.addr, align 8
  %3 = load i64, ptr %length.addr, align 8
  %4 = load ptr, ptr %buffer_ptr.addr, align 8
  %5 = load ptr, ptr %buffer_end.addr, align 8
  %6 = load ptr, ptr %args.addr, align 8
  %call3 = call i64 @_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineIjJEEENS_9hash_codeEmPcS5_RKT_DpRKT0_(ptr noundef nonnull align 8 dereferenceable(128) %this1, i64 noundef %3, ptr noundef %4, ptr noundef %5, ptr noundef nonnull align 4 dereferenceable(4) %6)
  %coerce.dive = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  store i64 %call3, ptr %coerce.dive, align 8
  %coerce.dive4 = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  %7 = load i64, ptr %coerce.dive4, align 8
  ret i64 %7
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZN4llvh7hashing6detail17store_and_advanceIhEEbRPcS3_RKT_m(ptr noundef nonnull align 8 dereferenceable(8) %buffer_ptr, ptr noundef %buffer_end, ptr noundef nonnull align 1 dereferenceable(1) %value, i64 noundef %offset) #1 comdat {
entry:
  %retval = alloca i1, align 1
  %buffer_ptr.addr = alloca ptr, align 8
  %buffer_end.addr = alloca ptr, align 8
  %value.addr = alloca ptr, align 8
  %offset.addr = alloca i64, align 8
  %store_size = alloca i64, align 8
  %value_data = alloca ptr, align 8
  store ptr %buffer_ptr, ptr %buffer_ptr.addr, align 8
  store ptr %buffer_end, ptr %buffer_end.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load i64, ptr %offset.addr, align 8
  %sub = sub i64 1, %0
  store i64 %sub, ptr %store_size, align 8
  %1 = load ptr, ptr %buffer_ptr.addr, align 8
  %2 = load ptr, ptr %1, align 8
  %3 = load i64, ptr %store_size, align 8
  %add.ptr = getelementptr inbounds i8, ptr %2, i64 %3
  %4 = load ptr, ptr %buffer_end.addr, align 8
  %cmp = icmp ugt ptr %add.ptr, %4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %value.addr, align 8
  store ptr %5, ptr %value_data, align 8
  %6 = load ptr, ptr %buffer_ptr.addr, align 8
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %value_data, align 8
  %9 = load i64, ptr %offset.addr, align 8
  %add.ptr1 = getelementptr inbounds i8, ptr %8, i64 %9
  %10 = load i64, ptr %store_size, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %7, ptr align 1 %add.ptr1, i64 %10, i1 false)
  %11 = load i64, ptr %store_size, align 8
  %12 = load ptr, ptr %buffer_ptr.addr, align 8
  %13 = load ptr, ptr %12, align 8
  %add.ptr2 = getelementptr inbounds i8, ptr %13, i64 %11
  store ptr %add.ptr2, ptr %12, align 8
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %14 = load i1, ptr %retval, align 1
  ret i1 %14
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh7hashing6detail10hash_state6createEPKcm(ptr noalias sret(%"struct.llvh::hashing::detail::hash_state") align 8 %agg.result, ptr noundef %s, i64 noundef %seed) #1 comdat align 2 {
entry:
  %s.addr = alloca ptr, align 8
  %seed.addr = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %seed, ptr %seed.addr, align 8
  %h0 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %agg.result, i32 0, i32 0
  store i64 0, ptr %h0, align 8
  %h1 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %agg.result, i32 0, i32 1
  %0 = load i64, ptr %seed.addr, align 8
  store i64 %0, ptr %h1, align 8
  %h2 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %agg.result, i32 0, i32 2
  %1 = load i64, ptr %seed.addr, align 8
  %call = call noundef i64 @_ZN4llvh7hashing6detail13hash_16_bytesEmm(i64 noundef %1, i64 noundef -5435081209227447693)
  store i64 %call, ptr %h2, align 8
  %h3 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %agg.result, i32 0, i32 3
  %2 = load i64, ptr %seed.addr, align 8
  %xor = xor i64 %2, -5435081209227447693
  %call1 = call noundef i64 @_ZN4llvh7hashing6detail6rotateEmm(i64 noundef %xor, i64 noundef 49)
  store i64 %call1, ptr %h3, align 8
  %h4 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %agg.result, i32 0, i32 4
  %3 = load i64, ptr %seed.addr, align 8
  %mul = mul i64 %3, -5435081209227447693
  store i64 %mul, ptr %h4, align 8
  %h5 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %agg.result, i32 0, i32 5
  %4 = load i64, ptr %seed.addr, align 8
  %call2 = call noundef i64 @_ZN4llvh7hashing6detail9shift_mixEm(i64 noundef %4)
  store i64 %call2, ptr %h5, align 8
  %h6 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %agg.result, i32 0, i32 6
  store i64 0, ptr %h6, align 8
  %h43 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %agg.result, i32 0, i32 4
  %5 = load i64, ptr %h43, align 8
  %h54 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %agg.result, i32 0, i32 5
  %6 = load i64, ptr %h54, align 8
  %call5 = call noundef i64 @_ZN4llvh7hashing6detail13hash_16_bytesEmm(i64 noundef %5, i64 noundef %6)
  %h66 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %agg.result, i32 0, i32 6
  store i64 %call5, ptr %h66, align 8
  %7 = load ptr, ptr %s.addr, align 8
  call void @_ZN4llvh7hashing6detail10hash_state3mixEPKc(ptr noundef nonnull align 8 dereferenceable(56) %agg.result, ptr noundef %7)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh7hashing6detail10hash_state3mixEPKc(ptr noundef nonnull align 8 dereferenceable(56) %this, ptr noundef %s) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %h0 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 0
  %0 = load i64, ptr %h0, align 8
  %h1 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 1
  %1 = load i64, ptr %h1, align 8
  %add = add i64 %0, %1
  %h3 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 3
  %2 = load i64, ptr %h3, align 8
  %add2 = add i64 %add, %2
  %3 = load ptr, ptr %s.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %3, i64 8
  %call = call noundef i64 @_ZN4llvh7hashing6detail7fetch64EPKc(ptr noundef %add.ptr)
  %add3 = add i64 %add2, %call
  %call4 = call noundef i64 @_ZN4llvh7hashing6detail6rotateEmm(i64 noundef %add3, i64 noundef 37)
  %mul = mul i64 %call4, -5435081209227447693
  %h05 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 0
  store i64 %mul, ptr %h05, align 8
  %h16 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 1
  %4 = load i64, ptr %h16, align 8
  %h4 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 4
  %5 = load i64, ptr %h4, align 8
  %add7 = add i64 %4, %5
  %6 = load ptr, ptr %s.addr, align 8
  %add.ptr8 = getelementptr inbounds i8, ptr %6, i64 48
  %call9 = call noundef i64 @_ZN4llvh7hashing6detail7fetch64EPKc(ptr noundef %add.ptr8)
  %add10 = add i64 %add7, %call9
  %call11 = call noundef i64 @_ZN4llvh7hashing6detail6rotateEmm(i64 noundef %add10, i64 noundef 42)
  %mul12 = mul i64 %call11, -5435081209227447693
  %h113 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 1
  store i64 %mul12, ptr %h113, align 8
  %h6 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 6
  %7 = load i64, ptr %h6, align 8
  %h014 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 0
  %8 = load i64, ptr %h014, align 8
  %xor = xor i64 %8, %7
  store i64 %xor, ptr %h014, align 8
  %h315 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 3
  %9 = load i64, ptr %h315, align 8
  %10 = load ptr, ptr %s.addr, align 8
  %add.ptr16 = getelementptr inbounds i8, ptr %10, i64 40
  %call17 = call noundef i64 @_ZN4llvh7hashing6detail7fetch64EPKc(ptr noundef %add.ptr16)
  %add18 = add i64 %9, %call17
  %h119 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 1
  %11 = load i64, ptr %h119, align 8
  %add20 = add i64 %11, %add18
  store i64 %add20, ptr %h119, align 8
  %h2 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 2
  %12 = load i64, ptr %h2, align 8
  %h5 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 5
  %13 = load i64, ptr %h5, align 8
  %add21 = add i64 %12, %13
  %call22 = call noundef i64 @_ZN4llvh7hashing6detail6rotateEmm(i64 noundef %add21, i64 noundef 33)
  %mul23 = mul i64 %call22, -5435081209227447693
  %h224 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 2
  store i64 %mul23, ptr %h224, align 8
  %h425 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 4
  %14 = load i64, ptr %h425, align 8
  %mul26 = mul i64 %14, -5435081209227447693
  %h327 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 3
  store i64 %mul26, ptr %h327, align 8
  %h028 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 0
  %15 = load i64, ptr %h028, align 8
  %h529 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 5
  %16 = load i64, ptr %h529, align 8
  %add30 = add i64 %15, %16
  %h431 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 4
  store i64 %add30, ptr %h431, align 8
  %17 = load ptr, ptr %s.addr, align 8
  %h332 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 3
  %h433 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 4
  call void @_ZN4llvh7hashing6detail10hash_state12mix_32_bytesEPKcRmS5_(ptr noundef %17, ptr noundef nonnull align 8 dereferenceable(8) %h332, ptr noundef nonnull align 8 dereferenceable(8) %h433)
  %h234 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 2
  %18 = load i64, ptr %h234, align 8
  %h635 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 6
  %19 = load i64, ptr %h635, align 8
  %add36 = add i64 %18, %19
  %h537 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 5
  store i64 %add36, ptr %h537, align 8
  %h138 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 1
  %20 = load i64, ptr %h138, align 8
  %21 = load ptr, ptr %s.addr, align 8
  %add.ptr39 = getelementptr inbounds i8, ptr %21, i64 16
  %call40 = call noundef i64 @_ZN4llvh7hashing6detail7fetch64EPKc(ptr noundef %add.ptr39)
  %add41 = add i64 %20, %call40
  %h642 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 6
  store i64 %add41, ptr %h642, align 8
  %22 = load ptr, ptr %s.addr, align 8
  %add.ptr43 = getelementptr inbounds i8, ptr %22, i64 32
  %h544 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 5
  %h645 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 6
  call void @_ZN4llvh7hashing6detail10hash_state12mix_32_bytesEPKcRmS5_(ptr noundef %add.ptr43, ptr noundef nonnull align 8 dereferenceable(8) %h544, ptr noundef nonnull align 8 dereferenceable(8) %h645)
  %h246 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 2
  %h047 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 0
  call void @_ZSt4swapImENSt9enable_ifIXsr6__and_ISt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS3_ESt18is_move_assignableIS3_EEE5valueEvE4typeERS3_SC_(ptr noundef nonnull align 8 dereferenceable(8) %h246, ptr noundef nonnull align 8 dereferenceable(8) %h047) #10
  ret void
}

; Function Attrs: noreturn nounwind
declare void @abort() #11

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZN4llvh7hashing6detail13hash_16_bytesEmm(i64 noundef %low, i64 noundef %high) #1 comdat {
entry:
  %low.addr = alloca i64, align 8
  %high.addr = alloca i64, align 8
  %kMul = alloca i64, align 8
  %a = alloca i64, align 8
  %b = alloca i64, align 8
  store i64 %low, ptr %low.addr, align 8
  store i64 %high, ptr %high.addr, align 8
  store i64 -7070675565921424023, ptr %kMul, align 8
  %0 = load i64, ptr %low.addr, align 8
  %1 = load i64, ptr %high.addr, align 8
  %xor = xor i64 %0, %1
  %mul = mul i64 %xor, -7070675565921424023
  store i64 %mul, ptr %a, align 8
  %2 = load i64, ptr %a, align 8
  %shr = lshr i64 %2, 47
  %3 = load i64, ptr %a, align 8
  %xor1 = xor i64 %3, %shr
  store i64 %xor1, ptr %a, align 8
  %4 = load i64, ptr %high.addr, align 8
  %5 = load i64, ptr %a, align 8
  %xor2 = xor i64 %4, %5
  %mul3 = mul i64 %xor2, -7070675565921424023
  store i64 %mul3, ptr %b, align 8
  %6 = load i64, ptr %b, align 8
  %shr4 = lshr i64 %6, 47
  %7 = load i64, ptr %b, align 8
  %xor5 = xor i64 %7, %shr4
  store i64 %xor5, ptr %b, align 8
  %8 = load i64, ptr %b, align 8
  %mul6 = mul i64 %8, -7070675565921424023
  store i64 %mul6, ptr %b, align 8
  %9 = load i64, ptr %b, align 8
  ret i64 %9
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZN4llvh7hashing6detail6rotateEmm(i64 noundef %val, i64 noundef %shift) #1 comdat {
entry:
  %val.addr = alloca i64, align 8
  %shift.addr = alloca i64, align 8
  store i64 %val, ptr %val.addr, align 8
  store i64 %shift, ptr %shift.addr, align 8
  %0 = load i64, ptr %shift.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i64, ptr %val.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load i64, ptr %val.addr, align 8
  %3 = load i64, ptr %shift.addr, align 8
  %shr = lshr i64 %2, %3
  %4 = load i64, ptr %val.addr, align 8
  %5 = load i64, ptr %shift.addr, align 8
  %sub = sub i64 64, %5
  %shl = shl i64 %4, %sub
  %or = or i64 %shr, %shl
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %1, %cond.true ], [ %or, %cond.false ]
  ret i64 %cond
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZN4llvh7hashing6detail9shift_mixEm(i64 noundef %val) #1 comdat {
entry:
  %val.addr = alloca i64, align 8
  store i64 %val, ptr %val.addr, align 8
  %0 = load i64, ptr %val.addr, align 8
  %1 = load i64, ptr %val.addr, align 8
  %shr = lshr i64 %1, 47
  %xor = xor i64 %0, %shr
  ret i64 %xor
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZN4llvh7hashing6detail7fetch64EPKc(ptr noundef %p) #1 comdat {
entry:
  %p.addr = alloca ptr, align 8
  %result = alloca i64, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %result, ptr align 1 %0, i64 8, i1 false)
  %1 = load i64, ptr %result, align 8
  ret i64 %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh7hashing6detail10hash_state12mix_32_bytesEPKcRmS5_(ptr noundef %s, ptr noundef nonnull align 8 dereferenceable(8) %a, ptr noundef nonnull align 8 dereferenceable(8) %b) #1 comdat align 2 {
entry:
  %s.addr = alloca ptr, align 8
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %c = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %call = call noundef i64 @_ZN4llvh7hashing6detail7fetch64EPKc(ptr noundef %0)
  %1 = load ptr, ptr %a.addr, align 8
  %2 = load i64, ptr %1, align 8
  %add = add i64 %2, %call
  store i64 %add, ptr %1, align 8
  %3 = load ptr, ptr %s.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %3, i64 24
  %call1 = call noundef i64 @_ZN4llvh7hashing6detail7fetch64EPKc(ptr noundef %add.ptr)
  store i64 %call1, ptr %c, align 8
  %4 = load ptr, ptr %b.addr, align 8
  %5 = load i64, ptr %4, align 8
  %6 = load ptr, ptr %a.addr, align 8
  %7 = load i64, ptr %6, align 8
  %add2 = add i64 %5, %7
  %8 = load i64, ptr %c, align 8
  %add3 = add i64 %add2, %8
  %call4 = call noundef i64 @_ZN4llvh7hashing6detail6rotateEmm(i64 noundef %add3, i64 noundef 21)
  %9 = load ptr, ptr %b.addr, align 8
  store i64 %call4, ptr %9, align 8
  %10 = load ptr, ptr %a.addr, align 8
  %11 = load i64, ptr %10, align 8
  store i64 %11, ptr %d, align 8
  %12 = load ptr, ptr %s.addr, align 8
  %add.ptr5 = getelementptr inbounds i8, ptr %12, i64 8
  %call6 = call noundef i64 @_ZN4llvh7hashing6detail7fetch64EPKc(ptr noundef %add.ptr5)
  %13 = load ptr, ptr %s.addr, align 8
  %add.ptr7 = getelementptr inbounds i8, ptr %13, i64 16
  %call8 = call noundef i64 @_ZN4llvh7hashing6detail7fetch64EPKc(ptr noundef %add.ptr7)
  %add9 = add i64 %call6, %call8
  %14 = load ptr, ptr %a.addr, align 8
  %15 = load i64, ptr %14, align 8
  %add10 = add i64 %15, %add9
  store i64 %add10, ptr %14, align 8
  %16 = load ptr, ptr %a.addr, align 8
  %17 = load i64, ptr %16, align 8
  %call11 = call noundef i64 @_ZN4llvh7hashing6detail6rotateEmm(i64 noundef %17, i64 noundef 44)
  %18 = load i64, ptr %d, align 8
  %add12 = add i64 %call11, %18
  %19 = load ptr, ptr %b.addr, align 8
  %20 = load i64, ptr %19, align 8
  %add13 = add i64 %20, %add12
  store i64 %add13, ptr %19, align 8
  %21 = load i64, ptr %c, align 8
  %22 = load ptr, ptr %a.addr, align 8
  %23 = load i64, ptr %22, align 8
  %add14 = add i64 %23, %21
  store i64 %add14, ptr %22, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZSt4swapImENSt9enable_ifIXsr6__and_ISt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS3_ESt18is_move_assignableIS3_EEE5valueEvE4typeERS3_SC_(ptr noundef nonnull align 8 dereferenceable(8) %__a, ptr noundef nonnull align 8 dereferenceable(8) %__b) #1 comdat {
entry:
  %__a.addr = alloca ptr, align 8
  %__b.addr = alloca ptr, align 8
  %__tmp = alloca i64, align 8
  store ptr %__a, ptr %__a.addr, align 8
  store ptr %__b, ptr %__b.addr, align 8
  %0 = load ptr, ptr %__a.addr, align 8
  %1 = load i64, ptr %0, align 8
  store i64 %1, ptr %__tmp, align 8
  %2 = load ptr, ptr %__b.addr, align 8
  %3 = load i64, ptr %2, align 8
  %4 = load ptr, ptr %__a.addr, align 8
  store i64 %3, ptr %4, align 8
  %5 = load i64, ptr %__tmp, align 8
  %6 = load ptr, ptr %__b.addr, align 8
  store i64 %5, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden i64 @_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineIjJEEENS_9hash_codeEmPcS5_RKT_DpRKT0_(ptr noundef nonnull align 8 dereferenceable(128) %this, i64 noundef %length, ptr noundef %buffer_ptr, ptr noundef %buffer_end, ptr noundef nonnull align 4 dereferenceable(4) %arg) #1 comdat align 2 {
entry:
  %retval = alloca %"class.llvh::hash_code", align 8
  %this.addr = alloca ptr, align 8
  %length.addr = alloca i64, align 8
  %buffer_ptr.addr = alloca ptr, align 8
  %buffer_end.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %length, ptr %length.addr, align 8
  store ptr %buffer_ptr, ptr %buffer_ptr.addr, align 8
  store ptr %buffer_end, ptr %buffer_end.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %buffer_ptr.addr, align 8
  %1 = load ptr, ptr %buffer_end.addr, align 8
  %2 = load ptr, ptr %arg.addr, align 8
  %call = call noundef i32 @_ZN4llvh7hashing6detail17get_hashable_dataIjEENSt9enable_ifIXsr16is_hashable_dataIT_EE5valueES4_E4typeERKS4_(ptr noundef nonnull align 4 dereferenceable(4) %2)
  %call2 = call noundef ptr @_ZN4llvh7hashing6detail29hash_combine_recursive_helper12combine_dataIjEEPcRmS4_S4_T_(ptr noundef nonnull align 8 dereferenceable(128) %this1, ptr noundef nonnull align 8 dereferenceable(8) %length.addr, ptr noundef %0, ptr noundef %1, i32 noundef %call)
  store ptr %call2, ptr %buffer_ptr.addr, align 8
  %3 = load i64, ptr %length.addr, align 8
  %4 = load ptr, ptr %buffer_ptr.addr, align 8
  %5 = load ptr, ptr %buffer_end.addr, align 8
  %call3 = call i64 @_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineEmPcS3_(ptr noundef nonnull align 8 dereferenceable(128) %this1, i64 noundef %3, ptr noundef %4, ptr noundef %5)
  %coerce.dive = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  store i64 %call3, ptr %coerce.dive, align 8
  %coerce.dive4 = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  %6 = load i64, ptr %coerce.dive4, align 8
  ret i64 %6
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef ptr @_ZN4llvh7hashing6detail29hash_combine_recursive_helper12combine_dataIjEEPcRmS4_S4_T_(ptr noundef nonnull align 8 dereferenceable(128) %this, ptr noundef nonnull align 8 dereferenceable(8) %length, ptr noundef %buffer_ptr, ptr noundef %buffer_end, i32 noundef %data) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %length.addr = alloca ptr, align 8
  %buffer_ptr.addr = alloca ptr, align 8
  %buffer_end.addr = alloca ptr, align 8
  %data.addr = alloca i32, align 4
  %partial_store_size = alloca i64, align 8
  %ref.tmp = alloca %"struct.llvh::hashing::detail::hash_state", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %length, ptr %length.addr, align 8
  store ptr %buffer_ptr, ptr %buffer_ptr.addr, align 8
  store ptr %buffer_end, ptr %buffer_end.addr, align 8
  store i32 %data, ptr %data.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %buffer_end.addr, align 8
  %call = call noundef zeroext i1 @_ZN4llvh7hashing6detail17store_and_advanceIjEEbRPcS3_RKT_m(ptr noundef nonnull align 8 dereferenceable(8) %buffer_ptr.addr, ptr noundef %0, ptr noundef nonnull align 4 dereferenceable(4) %data.addr, i64 noundef 0)
  br i1 %call, label %if.end12, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %buffer_end.addr, align 8
  %2 = load ptr, ptr %buffer_ptr.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %partial_store_size, align 8
  %3 = load ptr, ptr %buffer_ptr.addr, align 8
  %4 = load i64, ptr %partial_store_size, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %3, ptr align 4 %data.addr, i64 %4, i1 false)
  %5 = load ptr, ptr %length.addr, align 8
  %6 = load i64, ptr %5, align 8
  %cmp = icmp eq i64 %6, 0
  br i1 %cmp, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %buffer = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 0
  %arraydecay = getelementptr inbounds [64 x i8], ptr %buffer, i64 0, i64 0
  %seed = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 2
  %7 = load i64, ptr %seed, align 8
  call void @_ZN4llvh7hashing6detail10hash_state6createEPKcm(ptr sret(%"struct.llvh::hashing::detail::hash_state") align 8 %ref.tmp, ptr noundef %arraydecay, i64 noundef %7)
  %state3 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %state3, ptr align 8 %ref.tmp, i64 56, i1 false)
  %8 = load ptr, ptr %length.addr, align 8
  store i64 64, ptr %8, align 8
  br label %if.end

if.else:                                          ; preds = %if.then
  %state4 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 1
  %buffer5 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 0
  %arraydecay6 = getelementptr inbounds [64 x i8], ptr %buffer5, i64 0, i64 0
  call void @_ZN4llvh7hashing6detail10hash_state3mixEPKc(ptr noundef nonnull align 8 dereferenceable(56) %state4, ptr noundef %arraydecay6)
  %9 = load ptr, ptr %length.addr, align 8
  %10 = load i64, ptr %9, align 8
  %add = add i64 %10, 64
  store i64 %add, ptr %9, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then2
  %buffer7 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 0
  %arraydecay8 = getelementptr inbounds [64 x i8], ptr %buffer7, i64 0, i64 0
  store ptr %arraydecay8, ptr %buffer_ptr.addr, align 8
  %11 = load ptr, ptr %buffer_end.addr, align 8
  %12 = load i64, ptr %partial_store_size, align 8
  %call9 = call noundef zeroext i1 @_ZN4llvh7hashing6detail17store_and_advanceIjEEbRPcS3_RKT_m(ptr noundef nonnull align 8 dereferenceable(8) %buffer_ptr.addr, ptr noundef %11, ptr noundef nonnull align 4 dereferenceable(4) %data.addr, i64 noundef %12)
  br i1 %call9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end
  call void @abort() #17
  unreachable

if.end11:                                         ; preds = %if.end
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %entry
  %13 = load ptr, ptr %buffer_ptr.addr, align 8
  ret ptr %13
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZN4llvh7hashing6detail17get_hashable_dataIjEENSt9enable_ifIXsr16is_hashable_dataIT_EE5valueES4_E4typeERKS4_(ptr noundef nonnull align 4 dereferenceable(4) %value) #1 comdat {
entry:
  %value.addr = alloca ptr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %value.addr, align 8
  %1 = load i32, ptr %0, align 4
  ret i32 %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden i64 @_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineEmPcS3_(ptr noundef nonnull align 8 dereferenceable(128) %this, i64 noundef %length, ptr noundef %buffer_ptr, ptr noundef %buffer_end) #1 comdat align 2 {
entry:
  %retval = alloca %"class.llvh::hash_code", align 8
  %this.addr = alloca ptr, align 8
  %length.addr = alloca i64, align 8
  %buffer_ptr.addr = alloca ptr, align 8
  %buffer_end.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %length, ptr %length.addr, align 8
  store ptr %buffer_ptr, ptr %buffer_ptr.addr, align 8
  store ptr %buffer_end, ptr %buffer_end.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %length.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %buffer = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 0
  %arraydecay = getelementptr inbounds [64 x i8], ptr %buffer, i64 0, i64 0
  %1 = load ptr, ptr %buffer_ptr.addr, align 8
  %buffer2 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 0
  %arraydecay3 = getelementptr inbounds [64 x i8], ptr %buffer2, i64 0, i64 0
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %arraydecay3 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %seed = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 2
  %2 = load i64, ptr %seed, align 8
  %call = call noundef i64 @_ZN4llvh7hashing6detail10hash_shortEPKcmm(ptr noundef %arraydecay, i64 noundef %sub.ptr.sub, i64 noundef %2)
  call void @_ZN4llvh9hash_codeC2Em(ptr noundef nonnull align 8 dereferenceable(8) %retval, i64 noundef %call)
  br label %return

if.end:                                           ; preds = %entry
  %buffer4 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 0
  %arraydecay5 = getelementptr inbounds [64 x i8], ptr %buffer4, i64 0, i64 0
  %3 = load ptr, ptr %buffer_ptr.addr, align 8
  %4 = load ptr, ptr %buffer_end.addr, align 8
  %call6 = call noundef ptr @_ZNSt3_V26rotateIPcEET_S2_S2_S2_(ptr noundef %arraydecay5, ptr noundef %3, ptr noundef %4)
  %state = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 1
  %buffer7 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 0
  %arraydecay8 = getelementptr inbounds [64 x i8], ptr %buffer7, i64 0, i64 0
  call void @_ZN4llvh7hashing6detail10hash_state3mixEPKc(ptr noundef nonnull align 8 dereferenceable(56) %state, ptr noundef %arraydecay8)
  %5 = load ptr, ptr %buffer_ptr.addr, align 8
  %buffer9 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 0
  %arraydecay10 = getelementptr inbounds [64 x i8], ptr %buffer9, i64 0, i64 0
  %sub.ptr.lhs.cast11 = ptrtoint ptr %5 to i64
  %sub.ptr.rhs.cast12 = ptrtoint ptr %arraydecay10 to i64
  %sub.ptr.sub13 = sub i64 %sub.ptr.lhs.cast11, %sub.ptr.rhs.cast12
  %6 = load i64, ptr %length.addr, align 8
  %add = add i64 %6, %sub.ptr.sub13
  store i64 %add, ptr %length.addr, align 8
  %state14 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 1
  %7 = load i64, ptr %length.addr, align 8
  %call15 = call noundef i64 @_ZN4llvh7hashing6detail10hash_state8finalizeEm(ptr noundef nonnull align 8 dereferenceable(56) %state14, i64 noundef %7)
  call void @_ZN4llvh9hash_codeC2Em(ptr noundef nonnull align 8 dereferenceable(8) %retval, i64 noundef %call15)
  br label %return

return:                                           ; preds = %if.end, %if.then
  %coerce.dive = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  %8 = load i64, ptr %coerce.dive, align 8
  ret i64 %8
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZN4llvh7hashing6detail17store_and_advanceIjEEbRPcS3_RKT_m(ptr noundef nonnull align 8 dereferenceable(8) %buffer_ptr, ptr noundef %buffer_end, ptr noundef nonnull align 4 dereferenceable(4) %value, i64 noundef %offset) #1 comdat {
entry:
  %retval = alloca i1, align 1
  %buffer_ptr.addr = alloca ptr, align 8
  %buffer_end.addr = alloca ptr, align 8
  %value.addr = alloca ptr, align 8
  %offset.addr = alloca i64, align 8
  %store_size = alloca i64, align 8
  %value_data = alloca ptr, align 8
  store ptr %buffer_ptr, ptr %buffer_ptr.addr, align 8
  store ptr %buffer_end, ptr %buffer_end.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load i64, ptr %offset.addr, align 8
  %sub = sub i64 4, %0
  store i64 %sub, ptr %store_size, align 8
  %1 = load ptr, ptr %buffer_ptr.addr, align 8
  %2 = load ptr, ptr %1, align 8
  %3 = load i64, ptr %store_size, align 8
  %add.ptr = getelementptr inbounds i8, ptr %2, i64 %3
  %4 = load ptr, ptr %buffer_end.addr, align 8
  %cmp = icmp ugt ptr %add.ptr, %4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %value.addr, align 8
  store ptr %5, ptr %value_data, align 8
  %6 = load ptr, ptr %buffer_ptr.addr, align 8
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %value_data, align 8
  %9 = load i64, ptr %offset.addr, align 8
  %add.ptr1 = getelementptr inbounds i8, ptr %8, i64 %9
  %10 = load i64, ptr %store_size, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %7, ptr align 1 %add.ptr1, i64 %10, i1 false)
  %11 = load i64, ptr %store_size, align 8
  %12 = load ptr, ptr %buffer_ptr.addr, align 8
  %13 = load ptr, ptr %12, align 8
  %add.ptr2 = getelementptr inbounds i8, ptr %13, i64 %11
  store ptr %add.ptr2, ptr %12, align 8
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %14 = load i1, ptr %retval, align 1
  ret i1 %14
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZN4llvh7hashing6detail10hash_shortEPKcmm(ptr noundef %s, i64 noundef %length, i64 noundef %seed) #1 comdat {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %length.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %length, ptr %length.addr, align 8
  store i64 %seed, ptr %seed.addr, align 8
  %0 = load i64, ptr %length.addr, align 8
  %cmp = icmp uge i64 %0, 4
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %length.addr, align 8
  %cmp1 = icmp ule i64 %1, 8
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %2 = load ptr, ptr %s.addr, align 8
  %3 = load i64, ptr %length.addr, align 8
  %4 = load i64, ptr %seed.addr, align 8
  %call = call noundef i64 @_ZN4llvh7hashing6detail15hash_4to8_bytesEPKcmm(ptr noundef %2, i64 noundef %3, i64 noundef %4)
  store i64 %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %5 = load i64, ptr %length.addr, align 8
  %cmp2 = icmp ugt i64 %5, 8
  br i1 %cmp2, label %land.lhs.true3, label %if.end7

land.lhs.true3:                                   ; preds = %if.end
  %6 = load i64, ptr %length.addr, align 8
  %cmp4 = icmp ule i64 %6, 16
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %land.lhs.true3
  %7 = load ptr, ptr %s.addr, align 8
  %8 = load i64, ptr %length.addr, align 8
  %9 = load i64, ptr %seed.addr, align 8
  %call6 = call noundef i64 @_ZN4llvh7hashing6detail16hash_9to16_bytesEPKcmm(ptr noundef %7, i64 noundef %8, i64 noundef %9)
  store i64 %call6, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %land.lhs.true3, %if.end
  %10 = load i64, ptr %length.addr, align 8
  %cmp8 = icmp ugt i64 %10, 16
  br i1 %cmp8, label %land.lhs.true9, label %if.end13

land.lhs.true9:                                   ; preds = %if.end7
  %11 = load i64, ptr %length.addr, align 8
  %cmp10 = icmp ule i64 %11, 32
  br i1 %cmp10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %land.lhs.true9
  %12 = load ptr, ptr %s.addr, align 8
  %13 = load i64, ptr %length.addr, align 8
  %14 = load i64, ptr %seed.addr, align 8
  %call12 = call noundef i64 @_ZN4llvh7hashing6detail17hash_17to32_bytesEPKcmm(ptr noundef %12, i64 noundef %13, i64 noundef %14)
  store i64 %call12, ptr %retval, align 8
  br label %return

if.end13:                                         ; preds = %land.lhs.true9, %if.end7
  %15 = load i64, ptr %length.addr, align 8
  %cmp14 = icmp ugt i64 %15, 32
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end13
  %16 = load ptr, ptr %s.addr, align 8
  %17 = load i64, ptr %length.addr, align 8
  %18 = load i64, ptr %seed.addr, align 8
  %call16 = call noundef i64 @_ZN4llvh7hashing6detail17hash_33to64_bytesEPKcmm(ptr noundef %16, i64 noundef %17, i64 noundef %18)
  store i64 %call16, ptr %retval, align 8
  br label %return

if.end17:                                         ; preds = %if.end13
  %19 = load i64, ptr %length.addr, align 8
  %cmp18 = icmp ne i64 %19, 0
  br i1 %cmp18, label %if.then19, label %if.end21

if.then19:                                        ; preds = %if.end17
  %20 = load ptr, ptr %s.addr, align 8
  %21 = load i64, ptr %length.addr, align 8
  %22 = load i64, ptr %seed.addr, align 8
  %call20 = call noundef i64 @_ZN4llvh7hashing6detail15hash_1to3_bytesEPKcmm(ptr noundef %20, i64 noundef %21, i64 noundef %22)
  store i64 %call20, ptr %retval, align 8
  br label %return

if.end21:                                         ; preds = %if.end17
  %23 = load i64, ptr %seed.addr, align 8
  %xor = xor i64 -7286425919675154353, %23
  store i64 %xor, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end21, %if.then19, %if.then15, %if.then11, %if.then5, %if.then
  %24 = load i64, ptr %retval, align 8
  ret i64 %24
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh9hash_codeC2Em(ptr noundef nonnull align 8 dereferenceable(8) %this, i64 noundef %value) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %value.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %value, ptr %value.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %value2 = getelementptr inbounds %"class.llvh::hash_code", ptr %this1, i32 0, i32 0
  %0 = load i64, ptr %value.addr, align 8
  store i64 %0, ptr %value2, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZNSt3_V26rotateIPcEET_S2_S2_S2_(ptr noundef %__first, ptr noundef %__middle, ptr noundef %__last) #1 comdat {
entry:
  %__first.addr = alloca ptr, align 8
  %__middle.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store ptr %__middle, ptr %__middle.addr, align 8
  store ptr %__last, ptr %__last.addr, align 8
  %0 = load ptr, ptr %__first.addr, align 8
  %1 = load ptr, ptr %__middle.addr, align 8
  %2 = load ptr, ptr %__last.addr, align 8
  call void @_ZSt19__iterator_categoryIPcENSt15iterator_traitsIT_E17iterator_categoryERKS2_(ptr noundef nonnull align 8 dereferenceable(8) %__first.addr)
  %call = call noundef ptr @_ZNSt3_V28__rotateIPcEET_S2_S2_S2_St26random_access_iterator_tag(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZN4llvh7hashing6detail10hash_state8finalizeEm(ptr noundef nonnull align 8 dereferenceable(56) %this, i64 noundef %length) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %length.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %length, ptr %length.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %h3 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 3
  %0 = load i64, ptr %h3, align 8
  %h5 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 5
  %1 = load i64, ptr %h5, align 8
  %call = call noundef i64 @_ZN4llvh7hashing6detail13hash_16_bytesEmm(i64 noundef %0, i64 noundef %1)
  %h1 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 1
  %2 = load i64, ptr %h1, align 8
  %call2 = call noundef i64 @_ZN4llvh7hashing6detail9shift_mixEm(i64 noundef %2)
  %mul = mul i64 %call2, -5435081209227447693
  %add = add i64 %call, %mul
  %h2 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 2
  %3 = load i64, ptr %h2, align 8
  %add3 = add i64 %add, %3
  %h4 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 4
  %4 = load i64, ptr %h4, align 8
  %h6 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 6
  %5 = load i64, ptr %h6, align 8
  %call4 = call noundef i64 @_ZN4llvh7hashing6detail13hash_16_bytesEmm(i64 noundef %4, i64 noundef %5)
  %6 = load i64, ptr %length.addr, align 8
  %call5 = call noundef i64 @_ZN4llvh7hashing6detail9shift_mixEm(i64 noundef %6)
  %mul6 = mul i64 %call5, -5435081209227447693
  %add7 = add i64 %call4, %mul6
  %h0 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_state", ptr %this1, i32 0, i32 0
  %7 = load i64, ptr %h0, align 8
  %add8 = add i64 %add7, %7
  %call9 = call noundef i64 @_ZN4llvh7hashing6detail13hash_16_bytesEmm(i64 noundef %add3, i64 noundef %add8)
  ret i64 %call9
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZN4llvh7hashing6detail15hash_4to8_bytesEPKcmm(ptr noundef %s, i64 noundef %len, i64 noundef %seed) #1 comdat {
entry:
  %s.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %a = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store i64 %seed, ptr %seed.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %call = call noundef i32 @_ZN4llvh7hashing6detail7fetch32EPKc(ptr noundef %0)
  %conv = zext i32 %call to i64
  store i64 %conv, ptr %a, align 8
  %1 = load i64, ptr %len.addr, align 8
  %2 = load i64, ptr %a, align 8
  %shl = shl i64 %2, 3
  %add = add i64 %1, %shl
  %3 = load i64, ptr %seed.addr, align 8
  %4 = load ptr, ptr %s.addr, align 8
  %5 = load i64, ptr %len.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %4, i64 %5
  %add.ptr1 = getelementptr inbounds i8, ptr %add.ptr, i64 -4
  %call2 = call noundef i32 @_ZN4llvh7hashing6detail7fetch32EPKc(ptr noundef %add.ptr1)
  %conv3 = zext i32 %call2 to i64
  %xor = xor i64 %3, %conv3
  %call4 = call noundef i64 @_ZN4llvh7hashing6detail13hash_16_bytesEmm(i64 noundef %add, i64 noundef %xor)
  ret i64 %call4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZN4llvh7hashing6detail16hash_9to16_bytesEPKcmm(ptr noundef %s, i64 noundef %len, i64 noundef %seed) #1 comdat {
entry:
  %s.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %a = alloca i64, align 8
  %b = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store i64 %seed, ptr %seed.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %call = call noundef i64 @_ZN4llvh7hashing6detail7fetch64EPKc(ptr noundef %0)
  store i64 %call, ptr %a, align 8
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i64, ptr %len.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %1, i64 %2
  %add.ptr1 = getelementptr inbounds i8, ptr %add.ptr, i64 -8
  %call2 = call noundef i64 @_ZN4llvh7hashing6detail7fetch64EPKc(ptr noundef %add.ptr1)
  store i64 %call2, ptr %b, align 8
  %3 = load i64, ptr %seed.addr, align 8
  %4 = load i64, ptr %a, align 8
  %xor = xor i64 %3, %4
  %5 = load i64, ptr %b, align 8
  %6 = load i64, ptr %len.addr, align 8
  %add = add i64 %5, %6
  %7 = load i64, ptr %len.addr, align 8
  %call3 = call noundef i64 @_ZN4llvh7hashing6detail6rotateEmm(i64 noundef %add, i64 noundef %7)
  %call4 = call noundef i64 @_ZN4llvh7hashing6detail13hash_16_bytesEmm(i64 noundef %xor, i64 noundef %call3)
  %8 = load i64, ptr %b, align 8
  %xor5 = xor i64 %call4, %8
  ret i64 %xor5
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZN4llvh7hashing6detail17hash_17to32_bytesEPKcmm(ptr noundef %s, i64 noundef %len, i64 noundef %seed) #1 comdat {
entry:
  %s.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %a = alloca i64, align 8
  %b = alloca i64, align 8
  %c = alloca i64, align 8
  %d = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store i64 %seed, ptr %seed.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %call = call noundef i64 @_ZN4llvh7hashing6detail7fetch64EPKc(ptr noundef %0)
  %mul = mul i64 %call, -5435081209227447693
  store i64 %mul, ptr %a, align 8
  %1 = load ptr, ptr %s.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %1, i64 8
  %call1 = call noundef i64 @_ZN4llvh7hashing6detail7fetch64EPKc(ptr noundef %add.ptr)
  store i64 %call1, ptr %b, align 8
  %2 = load ptr, ptr %s.addr, align 8
  %3 = load i64, ptr %len.addr, align 8
  %add.ptr2 = getelementptr inbounds i8, ptr %2, i64 %3
  %add.ptr3 = getelementptr inbounds i8, ptr %add.ptr2, i64 -8
  %call4 = call noundef i64 @_ZN4llvh7hashing6detail7fetch64EPKc(ptr noundef %add.ptr3)
  %mul5 = mul i64 %call4, -7286425919675154353
  store i64 %mul5, ptr %c, align 8
  %4 = load ptr, ptr %s.addr, align 8
  %5 = load i64, ptr %len.addr, align 8
  %add.ptr6 = getelementptr inbounds i8, ptr %4, i64 %5
  %add.ptr7 = getelementptr inbounds i8, ptr %add.ptr6, i64 -16
  %call8 = call noundef i64 @_ZN4llvh7hashing6detail7fetch64EPKc(ptr noundef %add.ptr7)
  %mul9 = mul i64 %call8, -4348849565147123417
  store i64 %mul9, ptr %d, align 8
  %6 = load i64, ptr %a, align 8
  %7 = load i64, ptr %b, align 8
  %sub = sub i64 %6, %7
  %call10 = call noundef i64 @_ZN4llvh7hashing6detail6rotateEmm(i64 noundef %sub, i64 noundef 43)
  %8 = load i64, ptr %c, align 8
  %9 = load i64, ptr %seed.addr, align 8
  %xor = xor i64 %8, %9
  %call11 = call noundef i64 @_ZN4llvh7hashing6detail6rotateEmm(i64 noundef %xor, i64 noundef 30)
  %add = add i64 %call10, %call11
  %10 = load i64, ptr %d, align 8
  %add12 = add i64 %add, %10
  %11 = load i64, ptr %a, align 8
  %12 = load i64, ptr %b, align 8
  %xor13 = xor i64 %12, -3942382747735136937
  %call14 = call noundef i64 @_ZN4llvh7hashing6detail6rotateEmm(i64 noundef %xor13, i64 noundef 20)
  %add15 = add i64 %11, %call14
  %13 = load i64, ptr %c, align 8
  %sub16 = sub i64 %add15, %13
  %14 = load i64, ptr %len.addr, align 8
  %add17 = add i64 %sub16, %14
  %15 = load i64, ptr %seed.addr, align 8
  %add18 = add i64 %add17, %15
  %call19 = call noundef i64 @_ZN4llvh7hashing6detail13hash_16_bytesEmm(i64 noundef %add12, i64 noundef %add18)
  ret i64 %call19
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZN4llvh7hashing6detail17hash_33to64_bytesEPKcmm(ptr noundef %s, i64 noundef %len, i64 noundef %seed) #1 comdat {
entry:
  %s.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %z = alloca i64, align 8
  %a = alloca i64, align 8
  %b = alloca i64, align 8
  %c = alloca i64, align 8
  %vf = alloca i64, align 8
  %vs = alloca i64, align 8
  %wf = alloca i64, align 8
  %ws = alloca i64, align 8
  %r = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store i64 %seed, ptr %seed.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %0, i64 24
  %call = call noundef i64 @_ZN4llvh7hashing6detail7fetch64EPKc(ptr noundef %add.ptr)
  store i64 %call, ptr %z, align 8
  %1 = load ptr, ptr %s.addr, align 8
  %call1 = call noundef i64 @_ZN4llvh7hashing6detail7fetch64EPKc(ptr noundef %1)
  %2 = load i64, ptr %len.addr, align 8
  %3 = load ptr, ptr %s.addr, align 8
  %4 = load i64, ptr %len.addr, align 8
  %add.ptr2 = getelementptr inbounds i8, ptr %3, i64 %4
  %add.ptr3 = getelementptr inbounds i8, ptr %add.ptr2, i64 -16
  %call4 = call noundef i64 @_ZN4llvh7hashing6detail7fetch64EPKc(ptr noundef %add.ptr3)
  %add = add i64 %2, %call4
  %mul = mul i64 %add, -4348849565147123417
  %add5 = add i64 %call1, %mul
  store i64 %add5, ptr %a, align 8
  %5 = load i64, ptr %a, align 8
  %6 = load i64, ptr %z, align 8
  %add6 = add i64 %5, %6
  %call7 = call noundef i64 @_ZN4llvh7hashing6detail6rotateEmm(i64 noundef %add6, i64 noundef 52)
  store i64 %call7, ptr %b, align 8
  %7 = load i64, ptr %a, align 8
  %call8 = call noundef i64 @_ZN4llvh7hashing6detail6rotateEmm(i64 noundef %7, i64 noundef 37)
  store i64 %call8, ptr %c, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %add.ptr9 = getelementptr inbounds i8, ptr %8, i64 8
  %call10 = call noundef i64 @_ZN4llvh7hashing6detail7fetch64EPKc(ptr noundef %add.ptr9)
  %9 = load i64, ptr %a, align 8
  %add11 = add i64 %9, %call10
  store i64 %add11, ptr %a, align 8
  %10 = load i64, ptr %a, align 8
  %call12 = call noundef i64 @_ZN4llvh7hashing6detail6rotateEmm(i64 noundef %10, i64 noundef 7)
  %11 = load i64, ptr %c, align 8
  %add13 = add i64 %11, %call12
  store i64 %add13, ptr %c, align 8
  %12 = load ptr, ptr %s.addr, align 8
  %add.ptr14 = getelementptr inbounds i8, ptr %12, i64 16
  %call15 = call noundef i64 @_ZN4llvh7hashing6detail7fetch64EPKc(ptr noundef %add.ptr14)
  %13 = load i64, ptr %a, align 8
  %add16 = add i64 %13, %call15
  store i64 %add16, ptr %a, align 8
  %14 = load i64, ptr %a, align 8
  %15 = load i64, ptr %z, align 8
  %add17 = add i64 %14, %15
  store i64 %add17, ptr %vf, align 8
  %16 = load i64, ptr %b, align 8
  %17 = load i64, ptr %a, align 8
  %call18 = call noundef i64 @_ZN4llvh7hashing6detail6rotateEmm(i64 noundef %17, i64 noundef 31)
  %add19 = add i64 %16, %call18
  %18 = load i64, ptr %c, align 8
  %add20 = add i64 %add19, %18
  store i64 %add20, ptr %vs, align 8
  %19 = load ptr, ptr %s.addr, align 8
  %add.ptr21 = getelementptr inbounds i8, ptr %19, i64 16
  %call22 = call noundef i64 @_ZN4llvh7hashing6detail7fetch64EPKc(ptr noundef %add.ptr21)
  %20 = load ptr, ptr %s.addr, align 8
  %21 = load i64, ptr %len.addr, align 8
  %add.ptr23 = getelementptr inbounds i8, ptr %20, i64 %21
  %add.ptr24 = getelementptr inbounds i8, ptr %add.ptr23, i64 -32
  %call25 = call noundef i64 @_ZN4llvh7hashing6detail7fetch64EPKc(ptr noundef %add.ptr24)
  %add26 = add i64 %call22, %call25
  store i64 %add26, ptr %a, align 8
  %22 = load ptr, ptr %s.addr, align 8
  %23 = load i64, ptr %len.addr, align 8
  %add.ptr27 = getelementptr inbounds i8, ptr %22, i64 %23
  %add.ptr28 = getelementptr inbounds i8, ptr %add.ptr27, i64 -8
  %call29 = call noundef i64 @_ZN4llvh7hashing6detail7fetch64EPKc(ptr noundef %add.ptr28)
  store i64 %call29, ptr %z, align 8
  %24 = load i64, ptr %a, align 8
  %25 = load i64, ptr %z, align 8
  %add30 = add i64 %24, %25
  %call31 = call noundef i64 @_ZN4llvh7hashing6detail6rotateEmm(i64 noundef %add30, i64 noundef 52)
  store i64 %call31, ptr %b, align 8
  %26 = load i64, ptr %a, align 8
  %call32 = call noundef i64 @_ZN4llvh7hashing6detail6rotateEmm(i64 noundef %26, i64 noundef 37)
  store i64 %call32, ptr %c, align 8
  %27 = load ptr, ptr %s.addr, align 8
  %28 = load i64, ptr %len.addr, align 8
  %add.ptr33 = getelementptr inbounds i8, ptr %27, i64 %28
  %add.ptr34 = getelementptr inbounds i8, ptr %add.ptr33, i64 -24
  %call35 = call noundef i64 @_ZN4llvh7hashing6detail7fetch64EPKc(ptr noundef %add.ptr34)
  %29 = load i64, ptr %a, align 8
  %add36 = add i64 %29, %call35
  store i64 %add36, ptr %a, align 8
  %30 = load i64, ptr %a, align 8
  %call37 = call noundef i64 @_ZN4llvh7hashing6detail6rotateEmm(i64 noundef %30, i64 noundef 7)
  %31 = load i64, ptr %c, align 8
  %add38 = add i64 %31, %call37
  store i64 %add38, ptr %c, align 8
  %32 = load ptr, ptr %s.addr, align 8
  %33 = load i64, ptr %len.addr, align 8
  %add.ptr39 = getelementptr inbounds i8, ptr %32, i64 %33
  %add.ptr40 = getelementptr inbounds i8, ptr %add.ptr39, i64 -16
  %call41 = call noundef i64 @_ZN4llvh7hashing6detail7fetch64EPKc(ptr noundef %add.ptr40)
  %34 = load i64, ptr %a, align 8
  %add42 = add i64 %34, %call41
  store i64 %add42, ptr %a, align 8
  %35 = load i64, ptr %a, align 8
  %36 = load i64, ptr %z, align 8
  %add43 = add i64 %35, %36
  store i64 %add43, ptr %wf, align 8
  %37 = load i64, ptr %b, align 8
  %38 = load i64, ptr %a, align 8
  %call44 = call noundef i64 @_ZN4llvh7hashing6detail6rotateEmm(i64 noundef %38, i64 noundef 31)
  %add45 = add i64 %37, %call44
  %39 = load i64, ptr %c, align 8
  %add46 = add i64 %add45, %39
  store i64 %add46, ptr %ws, align 8
  %40 = load i64, ptr %vf, align 8
  %41 = load i64, ptr %ws, align 8
  %add47 = add i64 %40, %41
  %mul48 = mul i64 %add47, -7286425919675154353
  %42 = load i64, ptr %wf, align 8
  %43 = load i64, ptr %vs, align 8
  %add49 = add i64 %42, %43
  %mul50 = mul i64 %add49, -4348849565147123417
  %add51 = add i64 %mul48, %mul50
  %call52 = call noundef i64 @_ZN4llvh7hashing6detail9shift_mixEm(i64 noundef %add51)
  store i64 %call52, ptr %r, align 8
  %44 = load i64, ptr %seed.addr, align 8
  %45 = load i64, ptr %r, align 8
  %mul53 = mul i64 %45, -4348849565147123417
  %xor = xor i64 %44, %mul53
  %46 = load i64, ptr %vs, align 8
  %add54 = add i64 %xor, %46
  %call55 = call noundef i64 @_ZN4llvh7hashing6detail9shift_mixEm(i64 noundef %add54)
  %mul56 = mul i64 %call55, -7286425919675154353
  ret i64 %mul56
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZN4llvh7hashing6detail15hash_1to3_bytesEPKcmm(ptr noundef %s, i64 noundef %len, i64 noundef %seed) #1 comdat {
entry:
  %s.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %seed.addr = alloca i64, align 8
  %a = alloca i8, align 1
  %b = alloca i8, align 1
  %c = alloca i8, align 1
  %y = alloca i32, align 4
  %z = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store i64 %seed, ptr %seed.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %0, i64 0
  %1 = load i8, ptr %arrayidx, align 1
  store i8 %1, ptr %a, align 1
  %2 = load ptr, ptr %s.addr, align 8
  %3 = load i64, ptr %len.addr, align 8
  %shr = lshr i64 %3, 1
  %arrayidx1 = getelementptr inbounds i8, ptr %2, i64 %shr
  %4 = load i8, ptr %arrayidx1, align 1
  store i8 %4, ptr %b, align 1
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load i64, ptr %len.addr, align 8
  %sub = sub i64 %6, 1
  %arrayidx2 = getelementptr inbounds i8, ptr %5, i64 %sub
  %7 = load i8, ptr %arrayidx2, align 1
  store i8 %7, ptr %c, align 1
  %8 = load i8, ptr %a, align 1
  %conv = zext i8 %8 to i32
  %9 = load i8, ptr %b, align 1
  %conv3 = zext i8 %9 to i32
  %shl = shl i32 %conv3, 8
  %add = add i32 %conv, %shl
  store i32 %add, ptr %y, align 4
  %10 = load i64, ptr %len.addr, align 8
  %11 = load i8, ptr %c, align 1
  %conv4 = zext i8 %11 to i32
  %shl5 = shl i32 %conv4, 2
  %conv6 = zext i32 %shl5 to i64
  %add7 = add i64 %10, %conv6
  %conv8 = trunc i64 %add7 to i32
  store i32 %conv8, ptr %z, align 4
  %12 = load i32, ptr %y, align 4
  %conv9 = zext i32 %12 to i64
  %mul = mul i64 %conv9, -7286425919675154353
  %13 = load i32, ptr %z, align 4
  %conv10 = zext i32 %13 to i64
  %mul11 = mul i64 %conv10, -3942382747735136937
  %xor = xor i64 %mul, %mul11
  %14 = load i64, ptr %seed.addr, align 8
  %xor12 = xor i64 %xor, %14
  %call = call noundef i64 @_ZN4llvh7hashing6detail9shift_mixEm(i64 noundef %xor12)
  %mul13 = mul i64 %call, -7286425919675154353
  ret i64 %mul13
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i32 @_ZN4llvh7hashing6detail7fetch32EPKc(ptr noundef %p) #1 comdat {
entry:
  %p.addr = alloca ptr, align 8
  %result = alloca i32, align 4
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %result, ptr align 1 %0, i64 4, i1 false)
  %1 = load i32, ptr %result, align 4
  ret i32 %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZNSt3_V28__rotateIPcEET_S2_S2_S2_St26random_access_iterator_tag(ptr noundef %__first, ptr noundef %__middle, ptr noundef %__last) #1 comdat {
entry:
  %retval = alloca ptr, align 8
  %__first.addr = alloca ptr, align 8
  %__middle.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__n = alloca i64, align 8
  %__k = alloca i64, align 8
  %__p = alloca ptr, align 8
  %__ret = alloca ptr, align 8
  %__t = alloca i8, align 1
  %__q = alloca ptr, align 8
  %__i = alloca i64, align 8
  %__t37 = alloca i8, align 1
  %__q45 = alloca ptr, align 8
  %__i48 = alloca i64, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store ptr %__middle, ptr %__middle.addr, align 8
  store ptr %__last, ptr %__last.addr, align 8
  %0 = load ptr, ptr %__first.addr, align 8
  %1 = load ptr, ptr %__middle.addr, align 8
  %cmp = icmp eq ptr %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %__last.addr, align 8
  store ptr %2, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %3 = load ptr, ptr %__last.addr, align 8
  %4 = load ptr, ptr %__middle.addr, align 8
  %cmp1 = icmp eq ptr %3, %4
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  %5 = load ptr, ptr %__first.addr, align 8
  store ptr %5, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end3

if.end3:                                          ; preds = %if.end
  %6 = load ptr, ptr %__last.addr, align 8
  %7 = load ptr, ptr %__first.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %6 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %7 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %__n, align 8
  %8 = load ptr, ptr %__middle.addr, align 8
  %9 = load ptr, ptr %__first.addr, align 8
  %sub.ptr.lhs.cast4 = ptrtoint ptr %8 to i64
  %sub.ptr.rhs.cast5 = ptrtoint ptr %9 to i64
  %sub.ptr.sub6 = sub i64 %sub.ptr.lhs.cast4, %sub.ptr.rhs.cast5
  store i64 %sub.ptr.sub6, ptr %__k, align 8
  %10 = load i64, ptr %__k, align 8
  %11 = load i64, ptr %__n, align 8
  %12 = load i64, ptr %__k, align 8
  %sub = sub nsw i64 %11, %12
  %cmp7 = icmp eq i64 %10, %sub
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end3
  %13 = load ptr, ptr %__first.addr, align 8
  %14 = load ptr, ptr %__middle.addr, align 8
  %15 = load ptr, ptr %__middle.addr, align 8
  %call = call noundef ptr @_ZSt11swap_rangesIPcS0_ET0_T_S2_S1_(ptr noundef %13, ptr noundef %14, ptr noundef %15)
  %16 = load ptr, ptr %__middle.addr, align 8
  store ptr %16, ptr %retval, align 8
  br label %return

if.end9:                                          ; preds = %if.end3
  %17 = load ptr, ptr %__first.addr, align 8
  store ptr %17, ptr %__p, align 8
  %18 = load ptr, ptr %__first.addr, align 8
  %19 = load ptr, ptr %__last.addr, align 8
  %20 = load ptr, ptr %__middle.addr, align 8
  %sub.ptr.lhs.cast10 = ptrtoint ptr %19 to i64
  %sub.ptr.rhs.cast11 = ptrtoint ptr %20 to i64
  %sub.ptr.sub12 = sub i64 %sub.ptr.lhs.cast10, %sub.ptr.rhs.cast11
  %add.ptr = getelementptr inbounds i8, ptr %18, i64 %sub.ptr.sub12
  store ptr %add.ptr, ptr %__ret, align 8
  br label %for.cond

for.cond:                                         ; preds = %if.end62, %if.end9
  %21 = load i64, ptr %__k, align 8
  %22 = load i64, ptr %__n, align 8
  %23 = load i64, ptr %__k, align 8
  %sub13 = sub nsw i64 %22, %23
  %cmp14 = icmp slt i64 %21, %sub13
  br i1 %cmp14, label %if.then15, label %if.else33

if.then15:                                        ; preds = %for.cond
  %24 = load i64, ptr %__k, align 8
  %cmp16 = icmp eq i64 %24, 1
  br i1 %cmp16, label %if.then17, label %if.end23

if.then17:                                        ; preds = %if.then15
  %25 = load ptr, ptr %__p, align 8
  %26 = load i8, ptr %25, align 1
  store i8 %26, ptr %__t, align 1
  %27 = load ptr, ptr %__p, align 8
  %add.ptr18 = getelementptr inbounds i8, ptr %27, i64 1
  %28 = load ptr, ptr %__p, align 8
  %29 = load i64, ptr %__n, align 8
  %add.ptr19 = getelementptr inbounds i8, ptr %28, i64 %29
  %30 = load ptr, ptr %__p, align 8
  %call20 = call noundef ptr @_ZSt4moveIPcS0_ET0_T_S2_S1_(ptr noundef %add.ptr18, ptr noundef %add.ptr19, ptr noundef %30)
  %31 = load i8, ptr %__t, align 1
  %32 = load ptr, ptr %__p, align 8
  %33 = load i64, ptr %__n, align 8
  %add.ptr21 = getelementptr inbounds i8, ptr %32, i64 %33
  %add.ptr22 = getelementptr inbounds i8, ptr %add.ptr21, i64 -1
  store i8 %31, ptr %add.ptr22, align 1
  %34 = load ptr, ptr %__ret, align 8
  store ptr %34, ptr %retval, align 8
  br label %return

if.end23:                                         ; preds = %if.then15
  %35 = load ptr, ptr %__p, align 8
  %36 = load i64, ptr %__k, align 8
  %add.ptr24 = getelementptr inbounds i8, ptr %35, i64 %36
  store ptr %add.ptr24, ptr %__q, align 8
  store i64 0, ptr %__i, align 8
  br label %for.cond25

for.cond25:                                       ; preds = %for.inc, %if.end23
  %37 = load i64, ptr %__i, align 8
  %38 = load i64, ptr %__n, align 8
  %39 = load i64, ptr %__k, align 8
  %sub26 = sub nsw i64 %38, %39
  %cmp27 = icmp slt i64 %37, %sub26
  br i1 %cmp27, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond25
  %40 = load ptr, ptr %__p, align 8
  %41 = load ptr, ptr %__q, align 8
  call void @_ZSt9iter_swapIPcS0_EvT_T0_(ptr noundef %40, ptr noundef %41)
  %42 = load ptr, ptr %__p, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %42, i32 1
  store ptr %incdec.ptr, ptr %__p, align 8
  %43 = load ptr, ptr %__q, align 8
  %incdec.ptr28 = getelementptr inbounds i8, ptr %43, i32 1
  store ptr %incdec.ptr28, ptr %__q, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %44 = load i64, ptr %__i, align 8
  %inc = add nsw i64 %44, 1
  store i64 %inc, ptr %__i, align 8
  br label %for.cond25, !llvm.loop !45

for.end:                                          ; preds = %for.cond25
  %45 = load i64, ptr %__k, align 8
  %46 = load i64, ptr %__n, align 8
  %rem = srem i64 %46, %45
  store i64 %rem, ptr %__n, align 8
  %47 = load i64, ptr %__n, align 8
  %cmp29 = icmp eq i64 %47, 0
  br i1 %cmp29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %for.end
  %48 = load ptr, ptr %__ret, align 8
  store ptr %48, ptr %retval, align 8
  br label %return

if.end31:                                         ; preds = %for.end
  call void @_ZSt4swapIlENSt9enable_ifIXsr6__and_ISt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS3_ESt18is_move_assignableIS3_EEE5valueEvE4typeERS3_SC_(ptr noundef nonnull align 8 dereferenceable(8) %__n, ptr noundef nonnull align 8 dereferenceable(8) %__k) #10
  %49 = load i64, ptr %__n, align 8
  %50 = load i64, ptr %__k, align 8
  %sub32 = sub nsw i64 %49, %50
  store i64 %sub32, ptr %__k, align 8
  br label %if.end62

if.else33:                                        ; preds = %for.cond
  %51 = load i64, ptr %__n, align 8
  %52 = load i64, ptr %__k, align 8
  %sub34 = sub nsw i64 %51, %52
  store i64 %sub34, ptr %__k, align 8
  %53 = load i64, ptr %__k, align 8
  %cmp35 = icmp eq i64 %53, 1
  br i1 %cmp35, label %if.then36, label %if.end44

if.then36:                                        ; preds = %if.else33
  %54 = load ptr, ptr %__p, align 8
  %55 = load i64, ptr %__n, align 8
  %add.ptr38 = getelementptr inbounds i8, ptr %54, i64 %55
  %add.ptr39 = getelementptr inbounds i8, ptr %add.ptr38, i64 -1
  %56 = load i8, ptr %add.ptr39, align 1
  store i8 %56, ptr %__t37, align 1
  %57 = load ptr, ptr %__p, align 8
  %58 = load ptr, ptr %__p, align 8
  %59 = load i64, ptr %__n, align 8
  %add.ptr40 = getelementptr inbounds i8, ptr %58, i64 %59
  %add.ptr41 = getelementptr inbounds i8, ptr %add.ptr40, i64 -1
  %60 = load ptr, ptr %__p, align 8
  %61 = load i64, ptr %__n, align 8
  %add.ptr42 = getelementptr inbounds i8, ptr %60, i64 %61
  %call43 = call noundef ptr @_ZSt13move_backwardIPcS0_ET0_T_S2_S1_(ptr noundef %57, ptr noundef %add.ptr41, ptr noundef %add.ptr42)
  %62 = load i8, ptr %__t37, align 1
  %63 = load ptr, ptr %__p, align 8
  store i8 %62, ptr %63, align 1
  %64 = load ptr, ptr %__ret, align 8
  store ptr %64, ptr %retval, align 8
  br label %return

if.end44:                                         ; preds = %if.else33
  %65 = load ptr, ptr %__p, align 8
  %66 = load i64, ptr %__n, align 8
  %add.ptr46 = getelementptr inbounds i8, ptr %65, i64 %66
  store ptr %add.ptr46, ptr %__q45, align 8
  %67 = load ptr, ptr %__q45, align 8
  %68 = load i64, ptr %__k, align 8
  %idx.neg = sub i64 0, %68
  %add.ptr47 = getelementptr inbounds i8, ptr %67, i64 %idx.neg
  store ptr %add.ptr47, ptr %__p, align 8
  store i64 0, ptr %__i48, align 8
  br label %for.cond49

for.cond49:                                       ; preds = %for.inc55, %if.end44
  %69 = load i64, ptr %__i48, align 8
  %70 = load i64, ptr %__n, align 8
  %71 = load i64, ptr %__k, align 8
  %sub50 = sub nsw i64 %70, %71
  %cmp51 = icmp slt i64 %69, %sub50
  br i1 %cmp51, label %for.body52, label %for.end57

for.body52:                                       ; preds = %for.cond49
  %72 = load ptr, ptr %__p, align 8
  %incdec.ptr53 = getelementptr inbounds i8, ptr %72, i32 -1
  store ptr %incdec.ptr53, ptr %__p, align 8
  %73 = load ptr, ptr %__q45, align 8
  %incdec.ptr54 = getelementptr inbounds i8, ptr %73, i32 -1
  store ptr %incdec.ptr54, ptr %__q45, align 8
  %74 = load ptr, ptr %__p, align 8
  %75 = load ptr, ptr %__q45, align 8
  call void @_ZSt9iter_swapIPcS0_EvT_T0_(ptr noundef %74, ptr noundef %75)
  br label %for.inc55

for.inc55:                                        ; preds = %for.body52
  %76 = load i64, ptr %__i48, align 8
  %inc56 = add nsw i64 %76, 1
  store i64 %inc56, ptr %__i48, align 8
  br label %for.cond49, !llvm.loop !46

for.end57:                                        ; preds = %for.cond49
  %77 = load i64, ptr %__k, align 8
  %78 = load i64, ptr %__n, align 8
  %rem58 = srem i64 %78, %77
  store i64 %rem58, ptr %__n, align 8
  %79 = load i64, ptr %__n, align 8
  %cmp59 = icmp eq i64 %79, 0
  br i1 %cmp59, label %if.then60, label %if.end61

if.then60:                                        ; preds = %for.end57
  %80 = load ptr, ptr %__ret, align 8
  store ptr %80, ptr %retval, align 8
  br label %return

if.end61:                                         ; preds = %for.end57
  call void @_ZSt4swapIlENSt9enable_ifIXsr6__and_ISt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS3_ESt18is_move_assignableIS3_EEE5valueEvE4typeERS3_SC_(ptr noundef nonnull align 8 dereferenceable(8) %__n, ptr noundef nonnull align 8 dereferenceable(8) %__k) #10
  br label %if.end62

if.end62:                                         ; preds = %if.end61, %if.end31
  br label %for.cond, !llvm.loop !47

return:                                           ; preds = %if.then60, %if.then36, %if.then30, %if.then17, %if.then8, %if.then2, %if.then
  %81 = load ptr, ptr %retval, align 8
  ret ptr %81
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZSt19__iterator_categoryIPcENSt15iterator_traitsIT_E17iterator_categoryERKS2_(ptr noundef nonnull align 8 dereferenceable(8) %0) #1 comdat {
entry:
  %.addr = alloca ptr, align 8
  store ptr %0, ptr %.addr, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZSt11swap_rangesIPcS0_ET0_T_S2_S1_(ptr noundef %__first1, ptr noundef %__last1, ptr noundef %__first2) #1 comdat {
entry:
  %__first1.addr = alloca ptr, align 8
  %__last1.addr = alloca ptr, align 8
  %__first2.addr = alloca ptr, align 8
  store ptr %__first1, ptr %__first1.addr, align 8
  store ptr %__last1, ptr %__last1.addr, align 8
  store ptr %__first2, ptr %__first2.addr, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load ptr, ptr %__first1.addr, align 8
  %1 = load ptr, ptr %__last1.addr, align 8
  %cmp = icmp ne ptr %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %__first1.addr, align 8
  %3 = load ptr, ptr %__first2.addr, align 8
  call void @_ZSt9iter_swapIPcS0_EvT_T0_(ptr noundef %2, ptr noundef %3)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %4 = load ptr, ptr %__first1.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %4, i32 1
  store ptr %incdec.ptr, ptr %__first1.addr, align 8
  %5 = load ptr, ptr %__first2.addr, align 8
  %incdec.ptr1 = getelementptr inbounds i8, ptr %5, i32 1
  store ptr %incdec.ptr1, ptr %__first2.addr, align 8
  br label %for.cond, !llvm.loop !48

for.end:                                          ; preds = %for.cond
  %6 = load ptr, ptr %__first2.addr, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZSt9iter_swapIPcS0_EvT_T0_(ptr noundef %__a, ptr noundef %__b) #1 comdat {
entry:
  %__a.addr = alloca ptr, align 8
  %__b.addr = alloca ptr, align 8
  store ptr %__a, ptr %__a.addr, align 8
  store ptr %__b, ptr %__b.addr, align 8
  %0 = load ptr, ptr %__a.addr, align 8
  %1 = load ptr, ptr %__b.addr, align 8
  call void @_ZSt4swapIcENSt9enable_ifIXsr6__and_ISt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS3_ESt18is_move_assignableIS3_EEE5valueEvE4typeERS3_SC_(ptr noundef nonnull align 1 dereferenceable(1) %0, ptr noundef nonnull align 1 dereferenceable(1) %1) #10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZSt4swapIlENSt9enable_ifIXsr6__and_ISt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS3_ESt18is_move_assignableIS3_EEE5valueEvE4typeERS3_SC_(ptr noundef nonnull align 8 dereferenceable(8) %__a, ptr noundef nonnull align 8 dereferenceable(8) %__b) #1 comdat {
entry:
  %__a.addr = alloca ptr, align 8
  %__b.addr = alloca ptr, align 8
  %__tmp = alloca i64, align 8
  store ptr %__a, ptr %__a.addr, align 8
  store ptr %__b, ptr %__b.addr, align 8
  %0 = load ptr, ptr %__a.addr, align 8
  %1 = load i64, ptr %0, align 8
  store i64 %1, ptr %__tmp, align 8
  %2 = load ptr, ptr %__b.addr, align 8
  %3 = load i64, ptr %2, align 8
  %4 = load ptr, ptr %__a.addr, align 8
  store i64 %3, ptr %4, align 8
  %5 = load i64, ptr %__tmp, align 8
  %6 = load ptr, ptr %__b.addr, align 8
  store i64 %5, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZSt13move_backwardIPcS0_ET0_T_S2_S1_(ptr noundef %__first, ptr noundef %__last, ptr noundef %__result) #1 comdat {
entry:
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__result.addr = alloca ptr, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store ptr %__last, ptr %__last.addr, align 8
  store ptr %__result, ptr %__result.addr, align 8
  %0 = load ptr, ptr %__first.addr, align 8
  %call = call noundef ptr @_ZSt12__miter_baseIPcET_S1_(ptr noundef %0)
  %1 = load ptr, ptr %__last.addr, align 8
  %call1 = call noundef ptr @_ZSt12__miter_baseIPcET_S1_(ptr noundef %1)
  %2 = load ptr, ptr %__result.addr, align 8
  %call2 = call noundef ptr @_ZSt22__copy_move_backward_aILb1EPcS0_ET1_T0_S2_S1_(ptr noundef %call, ptr noundef %call1, ptr noundef %2)
  ret ptr %call2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZSt4swapIcENSt9enable_ifIXsr6__and_ISt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS3_ESt18is_move_assignableIS3_EEE5valueEvE4typeERS3_SC_(ptr noundef nonnull align 1 dereferenceable(1) %__a, ptr noundef nonnull align 1 dereferenceable(1) %__b) #1 comdat {
entry:
  %__a.addr = alloca ptr, align 8
  %__b.addr = alloca ptr, align 8
  %__tmp = alloca i8, align 1
  store ptr %__a, ptr %__a.addr, align 8
  store ptr %__b, ptr %__b.addr, align 8
  %0 = load ptr, ptr %__a.addr, align 8
  %1 = load i8, ptr %0, align 1
  store i8 %1, ptr %__tmp, align 1
  %2 = load ptr, ptr %__b.addr, align 8
  %3 = load i8, ptr %2, align 1
  %4 = load ptr, ptr %__a.addr, align 8
  store i8 %3, ptr %4, align 1
  %5 = load i8, ptr %__tmp, align 1
  %6 = load ptr, ptr %__b.addr, align 8
  store i8 %5, ptr %6, align 1
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZSt22__copy_move_backward_aILb1EPcS0_ET1_T0_S2_S1_(ptr noundef %__first, ptr noundef %__last, ptr noundef %__result) #1 comdat {
entry:
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__result.addr = alloca ptr, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store ptr %__last, ptr %__last.addr, align 8
  store ptr %__result, ptr %__result.addr, align 8
  %0 = load ptr, ptr %__first.addr, align 8
  %call = call noundef ptr @_ZSt12__niter_baseIPcET_S1_(ptr noundef %0) #10
  %1 = load ptr, ptr %__last.addr, align 8
  %call1 = call noundef ptr @_ZSt12__niter_baseIPcET_S1_(ptr noundef %1) #10
  %2 = load ptr, ptr %__result.addr, align 8
  %call2 = call noundef ptr @_ZSt12__niter_baseIPcET_S1_(ptr noundef %2) #10
  %call3 = call noundef ptr @_ZSt23__copy_move_backward_a1ILb1EPcS0_ET1_T0_S2_S1_(ptr noundef %call, ptr noundef %call1, ptr noundef %call2)
  %call4 = call noundef ptr @_ZSt12__niter_wrapIPcET_RKS1_S1_(ptr noundef nonnull align 8 dereferenceable(8) %__result.addr, ptr noundef %call3)
  ret ptr %call4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZSt23__copy_move_backward_a1ILb1EPcS0_ET1_T0_S2_S1_(ptr noundef %__first, ptr noundef %__last, ptr noundef %__result) #1 comdat {
entry:
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__result.addr = alloca ptr, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store ptr %__last, ptr %__last.addr, align 8
  store ptr %__result, ptr %__result.addr, align 8
  %0 = load ptr, ptr %__first.addr, align 8
  %1 = load ptr, ptr %__last.addr, align 8
  %2 = load ptr, ptr %__result.addr, align 8
  %call = call noundef ptr @_ZSt23__copy_move_backward_a2ILb1EPcS0_ET1_T0_S2_S1_(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZSt23__copy_move_backward_a2ILb1EPcS0_ET1_T0_S2_S1_(ptr noundef %__first, ptr noundef %__last, ptr noundef %__result) #1 comdat {
entry:
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__result.addr = alloca ptr, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store ptr %__last, ptr %__last.addr, align 8
  store ptr %__result, ptr %__result.addr, align 8
  %0 = load ptr, ptr %__first.addr, align 8
  %1 = load ptr, ptr %__last.addr, align 8
  %2 = load ptr, ptr %__result.addr, align 8
  %call = call noundef ptr @_ZNSt20__copy_move_backwardILb1ELb1ESt26random_access_iterator_tagE13__copy_move_bIcEEPT_PKS3_S6_S4_(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZNSt20__copy_move_backwardILb1ELb1ESt26random_access_iterator_tagE13__copy_move_bIcEEPT_PKS3_S6_S4_(ptr noundef %__first, ptr noundef %__last, ptr noundef %__result) #1 comdat align 2 {
entry:
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__result.addr = alloca ptr, align 8
  %_Num = alloca i64, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store ptr %__last, ptr %__last.addr, align 8
  store ptr %__result, ptr %__result.addr, align 8
  %0 = load ptr, ptr %__last.addr, align 8
  %1 = load ptr, ptr %__first.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %_Num, align 8
  %2 = load i64, ptr %_Num, align 8
  %tobool = icmp ne i64 %2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %__result.addr, align 8
  %4 = load i64, ptr %_Num, align 8
  %idx.neg = sub i64 0, %4
  %add.ptr = getelementptr inbounds i8, ptr %3, i64 %idx.neg
  %5 = load ptr, ptr %__first.addr, align 8
  %6 = load i64, ptr %_Num, align 8
  %mul = mul i64 1, %6
  call void @llvm.memmove.p0.p0.i64(ptr align 1 %add.ptr, ptr align 1 %5, i64 %mul, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load ptr, ptr %__result.addr, align 8
  %8 = load i64, ptr %_Num, align 8
  %idx.neg1 = sub i64 0, %8
  %add.ptr2 = getelementptr inbounds i8, ptr %7, i64 %idx.neg1
  ret ptr %add.ptr2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden i64 @_ZN4llvh7hashing6detail23hash_combine_range_implIKmEENSt9enable_ifIXsr16is_hashable_dataIT_EE5valueENS_9hash_codeEE4typeEPS5_S9_(ptr noundef %first, ptr noundef %last) #1 comdat {
entry:
  %retval = alloca %"class.llvh::hash_code", align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %seed = alloca i64, align 8
  %s_begin = alloca ptr, align 8
  %s_end = alloca ptr, align 8
  %length = alloca i64, align 8
  %s_aligned_end = alloca ptr, align 8
  %state = alloca %"struct.llvh::hashing::detail::hash_state", align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  %call = call noundef i64 @_ZN4llvh7hashing6detail18get_execution_seedEv()
  store i64 %call, ptr %seed, align 8
  %0 = load ptr, ptr %first.addr, align 8
  store ptr %0, ptr %s_begin, align 8
  %1 = load ptr, ptr %last.addr, align 8
  store ptr %1, ptr %s_end, align 8
  %2 = load ptr, ptr %s_begin, align 8
  %3 = load ptr, ptr %s_end, align 8
  %call1 = call noundef i64 @_ZSt8distanceIPKcENSt15iterator_traitsIT_E15difference_typeES3_S3_(ptr noundef %2, ptr noundef %3)
  store i64 %call1, ptr %length, align 8
  %4 = load i64, ptr %length, align 8
  %cmp = icmp ule i64 %4, 64
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load ptr, ptr %s_begin, align 8
  %6 = load i64, ptr %length, align 8
  %7 = load i64, ptr %seed, align 8
  %call2 = call noundef i64 @_ZN4llvh7hashing6detail10hash_shortEPKcmm(ptr noundef %5, i64 noundef %6, i64 noundef %7)
  call void @_ZN4llvh9hash_codeC2Em(ptr noundef nonnull align 8 dereferenceable(8) %retval, i64 noundef %call2)
  br label %return

if.end:                                           ; preds = %entry
  %8 = load ptr, ptr %s_begin, align 8
  %9 = load i64, ptr %length, align 8
  %and = and i64 %9, -64
  %add.ptr = getelementptr inbounds i8, ptr %8, i64 %and
  store ptr %add.ptr, ptr %s_aligned_end, align 8
  %10 = load ptr, ptr %s_begin, align 8
  %11 = load i64, ptr %seed, align 8
  call void @_ZN4llvh7hashing6detail10hash_state6createEPKcm(ptr sret(%"struct.llvh::hashing::detail::hash_state") align 8 %state, ptr noundef %10, i64 noundef %11)
  %12 = load ptr, ptr %s_begin, align 8
  %add.ptr3 = getelementptr inbounds i8, ptr %12, i64 64
  store ptr %add.ptr3, ptr %s_begin, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %13 = load ptr, ptr %s_begin, align 8
  %14 = load ptr, ptr %s_aligned_end, align 8
  %cmp4 = icmp ne ptr %13, %14
  br i1 %cmp4, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %15 = load ptr, ptr %s_begin, align 8
  call void @_ZN4llvh7hashing6detail10hash_state3mixEPKc(ptr noundef nonnull align 8 dereferenceable(56) %state, ptr noundef %15)
  %16 = load ptr, ptr %s_begin, align 8
  %add.ptr5 = getelementptr inbounds i8, ptr %16, i64 64
  store ptr %add.ptr5, ptr %s_begin, align 8
  br label %while.cond, !llvm.loop !49

while.end:                                        ; preds = %while.cond
  %17 = load i64, ptr %length, align 8
  %and6 = and i64 %17, 63
  %tobool = icmp ne i64 %and6, 0
  br i1 %tobool, label %if.then7, label %if.end9

if.then7:                                         ; preds = %while.end
  %18 = load ptr, ptr %s_end, align 8
  %add.ptr8 = getelementptr inbounds i8, ptr %18, i64 -64
  call void @_ZN4llvh7hashing6detail10hash_state3mixEPKc(ptr noundef nonnull align 8 dereferenceable(56) %state, ptr noundef %add.ptr8)
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %while.end
  %19 = load i64, ptr %length, align 8
  %call10 = call noundef i64 @_ZN4llvh7hashing6detail10hash_state8finalizeEm(ptr noundef nonnull align 8 dereferenceable(56) %state, i64 noundef %19)
  call void @_ZN4llvh9hash_codeC2Em(ptr noundef nonnull align 8 dereferenceable(8) %retval, i64 noundef %call10)
  br label %return

return:                                           ; preds = %if.end9, %if.then
  %coerce.dive = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  %20 = load i64, ptr %coerce.dive, align 8
  ret i64 %20
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden i64 @_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineIhJhjsNS_9hash_codeEEEES4_mPcS5_RKT_DpRKT0_(ptr noundef nonnull align 8 dereferenceable(128) %this, i64 noundef %length, ptr noundef %buffer_ptr, ptr noundef %buffer_end, ptr noundef nonnull align 1 dereferenceable(1) %arg, ptr noundef nonnull align 1 dereferenceable(1) %args, ptr noundef nonnull align 4 dereferenceable(4) %args1, ptr noundef nonnull align 2 dereferenceable(2) %args3, ptr noundef nonnull align 8 dereferenceable(8) %args5) #1 comdat align 2 {
entry:
  %retval = alloca %"class.llvh::hash_code", align 8
  %this.addr = alloca ptr, align 8
  %length.addr = alloca i64, align 8
  %buffer_ptr.addr = alloca ptr, align 8
  %buffer_end.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %args.addr2 = alloca ptr, align 8
  %args.addr4 = alloca ptr, align 8
  %args.addr6 = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %length, ptr %length.addr, align 8
  store ptr %buffer_ptr, ptr %buffer_ptr.addr, align 8
  store ptr %buffer_end, ptr %buffer_end.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store ptr %args1, ptr %args.addr2, align 8
  store ptr %args3, ptr %args.addr4, align 8
  store ptr %args5, ptr %args.addr6, align 8
  %this7 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %buffer_ptr.addr, align 8
  %1 = load ptr, ptr %buffer_end.addr, align 8
  %2 = load ptr, ptr %arg.addr, align 8
  %call = call noundef zeroext i8 @_ZN4llvh7hashing6detail17get_hashable_dataIhEENSt9enable_ifIXsr16is_hashable_dataIT_EE5valueES4_E4typeERKS4_(ptr noundef nonnull align 1 dereferenceable(1) %2)
  %call8 = call noundef ptr @_ZN4llvh7hashing6detail29hash_combine_recursive_helper12combine_dataIhEEPcRmS4_S4_T_(ptr noundef nonnull align 8 dereferenceable(128) %this7, ptr noundef nonnull align 8 dereferenceable(8) %length.addr, ptr noundef %0, ptr noundef %1, i8 noundef zeroext %call)
  store ptr %call8, ptr %buffer_ptr.addr, align 8
  %3 = load i64, ptr %length.addr, align 8
  %4 = load ptr, ptr %buffer_ptr.addr, align 8
  %5 = load ptr, ptr %buffer_end.addr, align 8
  %6 = load ptr, ptr %args.addr, align 8
  %7 = load ptr, ptr %args.addr2, align 8
  %8 = load ptr, ptr %args.addr4, align 8
  %9 = load ptr, ptr %args.addr6, align 8
  %call9 = call i64 @_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineIhJjsNS_9hash_codeEEEES4_mPcS5_RKT_DpRKT0_(ptr noundef nonnull align 8 dereferenceable(128) %this7, i64 noundef %3, ptr noundef %4, ptr noundef %5, ptr noundef nonnull align 1 dereferenceable(1) %6, ptr noundef nonnull align 4 dereferenceable(4) %7, ptr noundef nonnull align 2 dereferenceable(2) %8, ptr noundef nonnull align 8 dereferenceable(8) %9)
  %coerce.dive = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  store i64 %call9, ptr %coerce.dive, align 8
  %coerce.dive10 = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  %10 = load i64, ptr %coerce.dive10, align 8
  ret i64 %10
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden i64 @_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineIhJjsNS_9hash_codeEEEES4_mPcS5_RKT_DpRKT0_(ptr noundef nonnull align 8 dereferenceable(128) %this, i64 noundef %length, ptr noundef %buffer_ptr, ptr noundef %buffer_end, ptr noundef nonnull align 1 dereferenceable(1) %arg, ptr noundef nonnull align 4 dereferenceable(4) %args, ptr noundef nonnull align 2 dereferenceable(2) %args1, ptr noundef nonnull align 8 dereferenceable(8) %args3) #1 comdat align 2 {
entry:
  %retval = alloca %"class.llvh::hash_code", align 8
  %this.addr = alloca ptr, align 8
  %length.addr = alloca i64, align 8
  %buffer_ptr.addr = alloca ptr, align 8
  %buffer_end.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %args.addr2 = alloca ptr, align 8
  %args.addr4 = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %length, ptr %length.addr, align 8
  store ptr %buffer_ptr, ptr %buffer_ptr.addr, align 8
  store ptr %buffer_end, ptr %buffer_end.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store ptr %args1, ptr %args.addr2, align 8
  store ptr %args3, ptr %args.addr4, align 8
  %this5 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %buffer_ptr.addr, align 8
  %1 = load ptr, ptr %buffer_end.addr, align 8
  %2 = load ptr, ptr %arg.addr, align 8
  %call = call noundef zeroext i8 @_ZN4llvh7hashing6detail17get_hashable_dataIhEENSt9enable_ifIXsr16is_hashable_dataIT_EE5valueES4_E4typeERKS4_(ptr noundef nonnull align 1 dereferenceable(1) %2)
  %call6 = call noundef ptr @_ZN4llvh7hashing6detail29hash_combine_recursive_helper12combine_dataIhEEPcRmS4_S4_T_(ptr noundef nonnull align 8 dereferenceable(128) %this5, ptr noundef nonnull align 8 dereferenceable(8) %length.addr, ptr noundef %0, ptr noundef %1, i8 noundef zeroext %call)
  store ptr %call6, ptr %buffer_ptr.addr, align 8
  %3 = load i64, ptr %length.addr, align 8
  %4 = load ptr, ptr %buffer_ptr.addr, align 8
  %5 = load ptr, ptr %buffer_end.addr, align 8
  %6 = load ptr, ptr %args.addr, align 8
  %7 = load ptr, ptr %args.addr2, align 8
  %8 = load ptr, ptr %args.addr4, align 8
  %call7 = call i64 @_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineIjJsNS_9hash_codeEEEES4_mPcS5_RKT_DpRKT0_(ptr noundef nonnull align 8 dereferenceable(128) %this5, i64 noundef %3, ptr noundef %4, ptr noundef %5, ptr noundef nonnull align 4 dereferenceable(4) %6, ptr noundef nonnull align 2 dereferenceable(2) %7, ptr noundef nonnull align 8 dereferenceable(8) %8)
  %coerce.dive = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  store i64 %call7, ptr %coerce.dive, align 8
  %coerce.dive8 = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  %9 = load i64, ptr %coerce.dive8, align 8
  ret i64 %9
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden i64 @_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineIjJsNS_9hash_codeEEEES4_mPcS5_RKT_DpRKT0_(ptr noundef nonnull align 8 dereferenceable(128) %this, i64 noundef %length, ptr noundef %buffer_ptr, ptr noundef %buffer_end, ptr noundef nonnull align 4 dereferenceable(4) %arg, ptr noundef nonnull align 2 dereferenceable(2) %args, ptr noundef nonnull align 8 dereferenceable(8) %args1) #1 comdat align 2 {
entry:
  %retval = alloca %"class.llvh::hash_code", align 8
  %this.addr = alloca ptr, align 8
  %length.addr = alloca i64, align 8
  %buffer_ptr.addr = alloca ptr, align 8
  %buffer_end.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %args.addr2 = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %length, ptr %length.addr, align 8
  store ptr %buffer_ptr, ptr %buffer_ptr.addr, align 8
  store ptr %buffer_end, ptr %buffer_end.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store ptr %args1, ptr %args.addr2, align 8
  %this3 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %buffer_ptr.addr, align 8
  %1 = load ptr, ptr %buffer_end.addr, align 8
  %2 = load ptr, ptr %arg.addr, align 8
  %call = call noundef i32 @_ZN4llvh7hashing6detail17get_hashable_dataIjEENSt9enable_ifIXsr16is_hashable_dataIT_EE5valueES4_E4typeERKS4_(ptr noundef nonnull align 4 dereferenceable(4) %2)
  %call4 = call noundef ptr @_ZN4llvh7hashing6detail29hash_combine_recursive_helper12combine_dataIjEEPcRmS4_S4_T_(ptr noundef nonnull align 8 dereferenceable(128) %this3, ptr noundef nonnull align 8 dereferenceable(8) %length.addr, ptr noundef %0, ptr noundef %1, i32 noundef %call)
  store ptr %call4, ptr %buffer_ptr.addr, align 8
  %3 = load i64, ptr %length.addr, align 8
  %4 = load ptr, ptr %buffer_ptr.addr, align 8
  %5 = load ptr, ptr %buffer_end.addr, align 8
  %6 = load ptr, ptr %args.addr, align 8
  %7 = load ptr, ptr %args.addr2, align 8
  %call5 = call i64 @_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineIsJNS_9hash_codeEEEES4_mPcS5_RKT_DpRKT0_(ptr noundef nonnull align 8 dereferenceable(128) %this3, i64 noundef %3, ptr noundef %4, ptr noundef %5, ptr noundef nonnull align 2 dereferenceable(2) %6, ptr noundef nonnull align 8 dereferenceable(8) %7)
  %coerce.dive = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  store i64 %call5, ptr %coerce.dive, align 8
  %coerce.dive6 = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  %8 = load i64, ptr %coerce.dive6, align 8
  ret i64 %8
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden i64 @_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineIsJNS_9hash_codeEEEES4_mPcS5_RKT_DpRKT0_(ptr noundef nonnull align 8 dereferenceable(128) %this, i64 noundef %length, ptr noundef %buffer_ptr, ptr noundef %buffer_end, ptr noundef nonnull align 2 dereferenceable(2) %arg, ptr noundef nonnull align 8 dereferenceable(8) %args) #1 comdat align 2 {
entry:
  %retval = alloca %"class.llvh::hash_code", align 8
  %this.addr = alloca ptr, align 8
  %length.addr = alloca i64, align 8
  %buffer_ptr.addr = alloca ptr, align 8
  %buffer_end.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %length, ptr %length.addr, align 8
  store ptr %buffer_ptr, ptr %buffer_ptr.addr, align 8
  store ptr %buffer_end, ptr %buffer_end.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %buffer_ptr.addr, align 8
  %1 = load ptr, ptr %buffer_end.addr, align 8
  %2 = load ptr, ptr %arg.addr, align 8
  %call = call noundef signext i16 @_ZN4llvh7hashing6detail17get_hashable_dataIsEENSt9enable_ifIXsr16is_hashable_dataIT_EE5valueES4_E4typeERKS4_(ptr noundef nonnull align 2 dereferenceable(2) %2)
  %call2 = call noundef ptr @_ZN4llvh7hashing6detail29hash_combine_recursive_helper12combine_dataIsEEPcRmS4_S4_T_(ptr noundef nonnull align 8 dereferenceable(128) %this1, ptr noundef nonnull align 8 dereferenceable(8) %length.addr, ptr noundef %0, ptr noundef %1, i16 noundef signext %call)
  store ptr %call2, ptr %buffer_ptr.addr, align 8
  %3 = load i64, ptr %length.addr, align 8
  %4 = load ptr, ptr %buffer_ptr.addr, align 8
  %5 = load ptr, ptr %buffer_end.addr, align 8
  %6 = load ptr, ptr %args.addr, align 8
  %call3 = call i64 @_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineINS_9hash_codeEJEEES4_mPcS5_RKT_DpRKT0_(ptr noundef nonnull align 8 dereferenceable(128) %this1, i64 noundef %3, ptr noundef %4, ptr noundef %5, ptr noundef nonnull align 8 dereferenceable(8) %6)
  %coerce.dive = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  store i64 %call3, ptr %coerce.dive, align 8
  %coerce.dive4 = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  %7 = load i64, ptr %coerce.dive4, align 8
  ret i64 %7
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef ptr @_ZN4llvh7hashing6detail29hash_combine_recursive_helper12combine_dataIsEEPcRmS4_S4_T_(ptr noundef nonnull align 8 dereferenceable(128) %this, ptr noundef nonnull align 8 dereferenceable(8) %length, ptr noundef %buffer_ptr, ptr noundef %buffer_end, i16 noundef signext %data) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %length.addr = alloca ptr, align 8
  %buffer_ptr.addr = alloca ptr, align 8
  %buffer_end.addr = alloca ptr, align 8
  %data.addr = alloca i16, align 2
  %partial_store_size = alloca i64, align 8
  %ref.tmp = alloca %"struct.llvh::hashing::detail::hash_state", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %length, ptr %length.addr, align 8
  store ptr %buffer_ptr, ptr %buffer_ptr.addr, align 8
  store ptr %buffer_end, ptr %buffer_end.addr, align 8
  store i16 %data, ptr %data.addr, align 2
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %buffer_end.addr, align 8
  %call = call noundef zeroext i1 @_ZN4llvh7hashing6detail17store_and_advanceIsEEbRPcS3_RKT_m(ptr noundef nonnull align 8 dereferenceable(8) %buffer_ptr.addr, ptr noundef %0, ptr noundef nonnull align 2 dereferenceable(2) %data.addr, i64 noundef 0)
  br i1 %call, label %if.end12, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %buffer_end.addr, align 8
  %2 = load ptr, ptr %buffer_ptr.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %partial_store_size, align 8
  %3 = load ptr, ptr %buffer_ptr.addr, align 8
  %4 = load i64, ptr %partial_store_size, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %3, ptr align 2 %data.addr, i64 %4, i1 false)
  %5 = load ptr, ptr %length.addr, align 8
  %6 = load i64, ptr %5, align 8
  %cmp = icmp eq i64 %6, 0
  br i1 %cmp, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %buffer = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 0
  %arraydecay = getelementptr inbounds [64 x i8], ptr %buffer, i64 0, i64 0
  %seed = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 2
  %7 = load i64, ptr %seed, align 8
  call void @_ZN4llvh7hashing6detail10hash_state6createEPKcm(ptr sret(%"struct.llvh::hashing::detail::hash_state") align 8 %ref.tmp, ptr noundef %arraydecay, i64 noundef %7)
  %state3 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %state3, ptr align 8 %ref.tmp, i64 56, i1 false)
  %8 = load ptr, ptr %length.addr, align 8
  store i64 64, ptr %8, align 8
  br label %if.end

if.else:                                          ; preds = %if.then
  %state4 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 1
  %buffer5 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 0
  %arraydecay6 = getelementptr inbounds [64 x i8], ptr %buffer5, i64 0, i64 0
  call void @_ZN4llvh7hashing6detail10hash_state3mixEPKc(ptr noundef nonnull align 8 dereferenceable(56) %state4, ptr noundef %arraydecay6)
  %9 = load ptr, ptr %length.addr, align 8
  %10 = load i64, ptr %9, align 8
  %add = add i64 %10, 64
  store i64 %add, ptr %9, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then2
  %buffer7 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 0
  %arraydecay8 = getelementptr inbounds [64 x i8], ptr %buffer7, i64 0, i64 0
  store ptr %arraydecay8, ptr %buffer_ptr.addr, align 8
  %11 = load ptr, ptr %buffer_end.addr, align 8
  %12 = load i64, ptr %partial_store_size, align 8
  %call9 = call noundef zeroext i1 @_ZN4llvh7hashing6detail17store_and_advanceIsEEbRPcS3_RKT_m(ptr noundef nonnull align 8 dereferenceable(8) %buffer_ptr.addr, ptr noundef %11, ptr noundef nonnull align 2 dereferenceable(2) %data.addr, i64 noundef %12)
  br i1 %call9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end
  call void @abort() #17
  unreachable

if.end11:                                         ; preds = %if.end
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %entry
  %13 = load ptr, ptr %buffer_ptr.addr, align 8
  ret ptr %13
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef signext i16 @_ZN4llvh7hashing6detail17get_hashable_dataIsEENSt9enable_ifIXsr16is_hashable_dataIT_EE5valueES4_E4typeERKS4_(ptr noundef nonnull align 2 dereferenceable(2) %value) #1 comdat {
entry:
  %value.addr = alloca ptr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %value.addr, align 8
  %1 = load i16, ptr %0, align 2
  ret i16 %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden i64 @_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineINS_9hash_codeEJEEES4_mPcS5_RKT_DpRKT0_(ptr noundef nonnull align 8 dereferenceable(128) %this, i64 noundef %length, ptr noundef %buffer_ptr, ptr noundef %buffer_end, ptr noundef nonnull align 8 dereferenceable(8) %arg) #1 comdat align 2 {
entry:
  %retval = alloca %"class.llvh::hash_code", align 8
  %this.addr = alloca ptr, align 8
  %length.addr = alloca i64, align 8
  %buffer_ptr.addr = alloca ptr, align 8
  %buffer_end.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %length, ptr %length.addr, align 8
  store ptr %buffer_ptr, ptr %buffer_ptr.addr, align 8
  store ptr %buffer_end, ptr %buffer_end.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %buffer_ptr.addr, align 8
  %1 = load ptr, ptr %buffer_end.addr, align 8
  %2 = load ptr, ptr %arg.addr, align 8
  %call = call noundef i64 @_ZN4llvh7hashing6detail17get_hashable_dataINS_9hash_codeEEENSt9enable_ifIXntsr16is_hashable_dataIT_EE5valueEmE4typeERKS5_(ptr noundef nonnull align 8 dereferenceable(8) %2)
  %call2 = call noundef ptr @_ZN4llvh7hashing6detail29hash_combine_recursive_helper12combine_dataImEEPcRmS4_S4_T_(ptr noundef nonnull align 8 dereferenceable(128) %this1, ptr noundef nonnull align 8 dereferenceable(8) %length.addr, ptr noundef %0, ptr noundef %1, i64 noundef %call)
  store ptr %call2, ptr %buffer_ptr.addr, align 8
  %3 = load i64, ptr %length.addr, align 8
  %4 = load ptr, ptr %buffer_ptr.addr, align 8
  %5 = load ptr, ptr %buffer_end.addr, align 8
  %call3 = call i64 @_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineEmPcS3_(ptr noundef nonnull align 8 dereferenceable(128) %this1, i64 noundef %3, ptr noundef %4, ptr noundef %5)
  %coerce.dive = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  store i64 %call3, ptr %coerce.dive, align 8
  %coerce.dive4 = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  %6 = load i64, ptr %coerce.dive4, align 8
  ret i64 %6
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZN4llvh7hashing6detail17store_and_advanceIsEEbRPcS3_RKT_m(ptr noundef nonnull align 8 dereferenceable(8) %buffer_ptr, ptr noundef %buffer_end, ptr noundef nonnull align 2 dereferenceable(2) %value, i64 noundef %offset) #1 comdat {
entry:
  %retval = alloca i1, align 1
  %buffer_ptr.addr = alloca ptr, align 8
  %buffer_end.addr = alloca ptr, align 8
  %value.addr = alloca ptr, align 8
  %offset.addr = alloca i64, align 8
  %store_size = alloca i64, align 8
  %value_data = alloca ptr, align 8
  store ptr %buffer_ptr, ptr %buffer_ptr.addr, align 8
  store ptr %buffer_end, ptr %buffer_end.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load i64, ptr %offset.addr, align 8
  %sub = sub i64 2, %0
  store i64 %sub, ptr %store_size, align 8
  %1 = load ptr, ptr %buffer_ptr.addr, align 8
  %2 = load ptr, ptr %1, align 8
  %3 = load i64, ptr %store_size, align 8
  %add.ptr = getelementptr inbounds i8, ptr %2, i64 %3
  %4 = load ptr, ptr %buffer_end.addr, align 8
  %cmp = icmp ugt ptr %add.ptr, %4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %value.addr, align 8
  store ptr %5, ptr %value_data, align 8
  %6 = load ptr, ptr %buffer_ptr.addr, align 8
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %value_data, align 8
  %9 = load i64, ptr %offset.addr, align 8
  %add.ptr1 = getelementptr inbounds i8, ptr %8, i64 %9
  %10 = load i64, ptr %store_size, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %7, ptr align 1 %add.ptr1, i64 %10, i1 false)
  %11 = load i64, ptr %store_size, align 8
  %12 = load ptr, ptr %buffer_ptr.addr, align 8
  %13 = load ptr, ptr %12, align 8
  %add.ptr2 = getelementptr inbounds i8, ptr %13, i64 %11
  store ptr %add.ptr2, ptr %12, align 8
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %14 = load i1, ptr %retval, align 1
  ret i1 %14
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef ptr @_ZN4llvh7hashing6detail29hash_combine_recursive_helper12combine_dataImEEPcRmS4_S4_T_(ptr noundef nonnull align 8 dereferenceable(128) %this, ptr noundef nonnull align 8 dereferenceable(8) %length, ptr noundef %buffer_ptr, ptr noundef %buffer_end, i64 noundef %data) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %length.addr = alloca ptr, align 8
  %buffer_ptr.addr = alloca ptr, align 8
  %buffer_end.addr = alloca ptr, align 8
  %data.addr = alloca i64, align 8
  %partial_store_size = alloca i64, align 8
  %ref.tmp = alloca %"struct.llvh::hashing::detail::hash_state", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %length, ptr %length.addr, align 8
  store ptr %buffer_ptr, ptr %buffer_ptr.addr, align 8
  store ptr %buffer_end, ptr %buffer_end.addr, align 8
  store i64 %data, ptr %data.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %buffer_end.addr, align 8
  %call = call noundef zeroext i1 @_ZN4llvh7hashing6detail17store_and_advanceImEEbRPcS3_RKT_m(ptr noundef nonnull align 8 dereferenceable(8) %buffer_ptr.addr, ptr noundef %0, ptr noundef nonnull align 8 dereferenceable(8) %data.addr, i64 noundef 0)
  br i1 %call, label %if.end12, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %buffer_end.addr, align 8
  %2 = load ptr, ptr %buffer_ptr.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %partial_store_size, align 8
  %3 = load ptr, ptr %buffer_ptr.addr, align 8
  %4 = load i64, ptr %partial_store_size, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %3, ptr align 8 %data.addr, i64 %4, i1 false)
  %5 = load ptr, ptr %length.addr, align 8
  %6 = load i64, ptr %5, align 8
  %cmp = icmp eq i64 %6, 0
  br i1 %cmp, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %buffer = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 0
  %arraydecay = getelementptr inbounds [64 x i8], ptr %buffer, i64 0, i64 0
  %seed = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 2
  %7 = load i64, ptr %seed, align 8
  call void @_ZN4llvh7hashing6detail10hash_state6createEPKcm(ptr sret(%"struct.llvh::hashing::detail::hash_state") align 8 %ref.tmp, ptr noundef %arraydecay, i64 noundef %7)
  %state3 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %state3, ptr align 8 %ref.tmp, i64 56, i1 false)
  %8 = load ptr, ptr %length.addr, align 8
  store i64 64, ptr %8, align 8
  br label %if.end

if.else:                                          ; preds = %if.then
  %state4 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 1
  %buffer5 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 0
  %arraydecay6 = getelementptr inbounds [64 x i8], ptr %buffer5, i64 0, i64 0
  call void @_ZN4llvh7hashing6detail10hash_state3mixEPKc(ptr noundef nonnull align 8 dereferenceable(56) %state4, ptr noundef %arraydecay6)
  %9 = load ptr, ptr %length.addr, align 8
  %10 = load i64, ptr %9, align 8
  %add = add i64 %10, 64
  store i64 %add, ptr %9, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then2
  %buffer7 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 0
  %arraydecay8 = getelementptr inbounds [64 x i8], ptr %buffer7, i64 0, i64 0
  store ptr %arraydecay8, ptr %buffer_ptr.addr, align 8
  %11 = load ptr, ptr %buffer_end.addr, align 8
  %12 = load i64, ptr %partial_store_size, align 8
  %call9 = call noundef zeroext i1 @_ZN4llvh7hashing6detail17store_and_advanceImEEbRPcS3_RKT_m(ptr noundef nonnull align 8 dereferenceable(8) %buffer_ptr.addr, ptr noundef %11, ptr noundef nonnull align 8 dereferenceable(8) %data.addr, i64 noundef %12)
  br i1 %call9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end
  call void @abort() #17
  unreachable

if.end11:                                         ; preds = %if.end
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %entry
  %13 = load ptr, ptr %buffer_ptr.addr, align 8
  ret ptr %13
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZN4llvh7hashing6detail17get_hashable_dataINS_9hash_codeEEENSt9enable_ifIXntsr16is_hashable_dataIT_EE5valueEmE4typeERKS5_(ptr noundef nonnull align 8 dereferenceable(8) %value) #1 comdat {
entry:
  %value.addr = alloca ptr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %value.addr, align 8
  %call = call noundef i64 @_ZN4llvh10hash_valueERKNS_9hash_codeE(ptr noundef nonnull align 8 dereferenceable(8) %0)
  ret i64 %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZN4llvh7hashing6detail17store_and_advanceImEEbRPcS3_RKT_m(ptr noundef nonnull align 8 dereferenceable(8) %buffer_ptr, ptr noundef %buffer_end, ptr noundef nonnull align 8 dereferenceable(8) %value, i64 noundef %offset) #1 comdat {
entry:
  %retval = alloca i1, align 1
  %buffer_ptr.addr = alloca ptr, align 8
  %buffer_end.addr = alloca ptr, align 8
  %value.addr = alloca ptr, align 8
  %offset.addr = alloca i64, align 8
  %store_size = alloca i64, align 8
  %value_data = alloca ptr, align 8
  store ptr %buffer_ptr, ptr %buffer_ptr.addr, align 8
  store ptr %buffer_end, ptr %buffer_end.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load i64, ptr %offset.addr, align 8
  %sub = sub i64 8, %0
  store i64 %sub, ptr %store_size, align 8
  %1 = load ptr, ptr %buffer_ptr.addr, align 8
  %2 = load ptr, ptr %1, align 8
  %3 = load i64, ptr %store_size, align 8
  %add.ptr = getelementptr inbounds i8, ptr %2, i64 %3
  %4 = load ptr, ptr %buffer_end.addr, align 8
  %cmp = icmp ugt ptr %add.ptr, %4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %value.addr, align 8
  store ptr %5, ptr %value_data, align 8
  %6 = load ptr, ptr %buffer_ptr.addr, align 8
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %value_data, align 8
  %9 = load i64, ptr %offset.addr, align 8
  %add.ptr1 = getelementptr inbounds i8, ptr %8, i64 %9
  %10 = load i64, ptr %store_size, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %7, ptr align 1 %add.ptr1, i64 %10, i1 false)
  %11 = load i64, ptr %store_size, align 8
  %12 = load ptr, ptr %buffer_ptr.addr, align 8
  %13 = load ptr, ptr %12, align 8
  %add.ptr2 = getelementptr inbounds i8, ptr %13, i64 %11
  store ptr %add.ptr2, ptr %12, align 8
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %14 = load i1, ptr %retval, align 1
  ret i1 %14
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef i64 @_ZN4llvh10hash_valueERKNS_9hash_codeE(ptr noundef nonnull align 8 dereferenceable(8) %code) #1 comdat {
entry:
  %code.addr = alloca ptr, align 8
  store ptr %code, ptr %code.addr, align 8
  %0 = load ptr, ptr %code.addr, align 8
  %value = getelementptr inbounds %"class.llvh::hash_code", ptr %0, i32 0, i32 0
  %1 = load i64, ptr %value, align 8
  ret i64 %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZSt20uninitialized_fill_nIPcmcET_S1_T0_RKT1_(ptr noundef %__first, i64 noundef %__n, ptr noundef nonnull align 1 dereferenceable(1) %__x) #1 comdat {
entry:
  %__first.addr = alloca ptr, align 8
  %__n.addr = alloca i64, align 8
  %__x.addr = alloca ptr, align 8
  %__can_fill = alloca i8, align 1
  store ptr %__first, ptr %__first.addr, align 8
  store i64 %__n, ptr %__n.addr, align 8
  store ptr %__x, ptr %__x.addr, align 8
  store i8 1, ptr %__can_fill, align 1
  %0 = load ptr, ptr %__first.addr, align 8
  %1 = load i64, ptr %__n.addr, align 8
  %2 = load ptr, ptr %__x.addr, align 8
  %call = call noundef ptr @_ZNSt22__uninitialized_fill_nILb1EE15__uninit_fill_nIPcmcEET_S3_T0_RKT1_(ptr noundef %0, i64 noundef %1, ptr noundef nonnull align 1 dereferenceable(1) %2)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZNSt22__uninitialized_fill_nILb1EE15__uninit_fill_nIPcmcEET_S3_T0_RKT1_(ptr noundef %__first, i64 noundef %__n, ptr noundef nonnull align 1 dereferenceable(1) %__x) #1 comdat align 2 {
entry:
  %__first.addr = alloca ptr, align 8
  %__n.addr = alloca i64, align 8
  %__x.addr = alloca ptr, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store i64 %__n, ptr %__n.addr, align 8
  store ptr %__x, ptr %__x.addr, align 8
  %0 = load ptr, ptr %__first.addr, align 8
  %1 = load i64, ptr %__n.addr, align 8
  %2 = load ptr, ptr %__x.addr, align 8
  %call = call noundef ptr @_ZSt6fill_nIPcmcET_S1_T0_RKT1_(ptr noundef %0, i64 noundef %1, ptr noundef nonnull align 1 dereferenceable(1) %2)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZSt6fill_nIPcmcET_S1_T0_RKT1_(ptr noundef %__first, i64 noundef %__n, ptr noundef nonnull align 1 dereferenceable(1) %__value) #1 comdat {
entry:
  %__first.addr = alloca ptr, align 8
  %__n.addr = alloca i64, align 8
  %__value.addr = alloca ptr, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store i64 %__n, ptr %__n.addr, align 8
  store ptr %__value, ptr %__value.addr, align 8
  %0 = load ptr, ptr %__first.addr, align 8
  %1 = load i64, ptr %__n.addr, align 8
  %call = call noundef i64 @_ZSt17__size_to_integerm(i64 noundef %1)
  %2 = load ptr, ptr %__value.addr, align 8
  call void @_ZSt19__iterator_categoryIPcENSt15iterator_traitsIT_E17iterator_categoryERKS2_(ptr noundef nonnull align 8 dereferenceable(8) %__first.addr)
  %call1 = call noundef ptr @_ZSt10__fill_n_aIPcmcET_S1_T0_RKT1_St26random_access_iterator_tag(ptr noundef %0, i64 noundef %call, ptr noundef nonnull align 1 dereferenceable(1) %2)
  ret ptr %call1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZSt10__fill_n_aIPcmcET_S1_T0_RKT1_St26random_access_iterator_tag(ptr noundef %__first, i64 noundef %__n, ptr noundef nonnull align 1 dereferenceable(1) %__value) #1 comdat {
entry:
  %retval = alloca ptr, align 8
  %__first.addr = alloca ptr, align 8
  %__n.addr = alloca i64, align 8
  %__value.addr = alloca ptr, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store i64 %__n, ptr %__n.addr, align 8
  store ptr %__value, ptr %__value.addr, align 8
  %0 = load i64, ptr %__n.addr, align 8
  %cmp = icmp ule i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %__first.addr, align 8
  store ptr %1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %__first.addr, align 8
  %3 = load ptr, ptr %__first.addr, align 8
  %4 = load i64, ptr %__n.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %3, i64 %4
  %5 = load ptr, ptr %__value.addr, align 8
  call void @_ZSt8__fill_aIPccEvT_S1_RKT0_(ptr noundef %2, ptr noundef %add.ptr, ptr noundef nonnull align 1 dereferenceable(1) %5)
  %6 = load ptr, ptr %__first.addr, align 8
  %7 = load i64, ptr %__n.addr, align 8
  %add.ptr1 = getelementptr inbounds i8, ptr %6, i64 %7
  store ptr %add.ptr1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load ptr, ptr %retval, align 8
  ret ptr %8
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i64 @_ZSt17__size_to_integerm(i64 noundef %__n) #1 comdat {
entry:
  %__n.addr = alloca i64, align 8
  store i64 %__n, ptr %__n.addr, align 8
  %0 = load i64, ptr %__n.addr, align 8
  ret i64 %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZSt8__fill_aIPccEvT_S1_RKT0_(ptr noundef %__first, ptr noundef %__last, ptr noundef nonnull align 1 dereferenceable(1) %__value) #1 comdat {
entry:
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__value.addr = alloca ptr, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store ptr %__last, ptr %__last.addr, align 8
  store ptr %__value, ptr %__value.addr, align 8
  %0 = load ptr, ptr %__first.addr, align 8
  %1 = load ptr, ptr %__last.addr, align 8
  %2 = load ptr, ptr %__value.addr, align 8
  call void @_ZSt9__fill_a1IcEN9__gnu_cxx11__enable_ifIXsr9__is_byteIT_EE7__valueEvE6__typeEPS2_S5_RKS2_(ptr noundef %0, ptr noundef %1, ptr noundef nonnull align 1 dereferenceable(1) %2)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZSt9__fill_a1IcEN9__gnu_cxx11__enable_ifIXsr9__is_byteIT_EE7__valueEvE6__typeEPS2_S5_RKS2_(ptr noundef %__first, ptr noundef %__last, ptr noundef nonnull align 1 dereferenceable(1) %__c) #1 comdat {
entry:
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__c.addr = alloca ptr, align 8
  %__tmp = alloca i8, align 1
  %__len = alloca i64, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store ptr %__last, ptr %__last.addr, align 8
  store ptr %__c, ptr %__c.addr, align 8
  %0 = load ptr, ptr %__c.addr, align 8
  %1 = load i8, ptr %0, align 1
  store i8 %1, ptr %__tmp, align 1
  %2 = load ptr, ptr %__last.addr, align 8
  %3 = load ptr, ptr %__first.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %3 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %__len, align 8
  %4 = load i64, ptr %__len, align 8
  %tobool = icmp ne i64 %4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load ptr, ptr %__first.addr, align 8
  %6 = load i8, ptr %__tmp, align 1
  %conv = zext i8 %6 to i32
  %7 = trunc i32 %conv to i8
  %8 = load i64, ptr %__len, align 8
  call void @llvm.memset.p0.i64(ptr align 1 %5, i8 %7, i64 %8, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh15SmallVectorImplIcEC2Ej(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %N) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %N.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %N, ptr %N.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %N.addr, align 4
  %conv = zext i32 %0 to i64
  call void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EEC2Em(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %conv)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh23SmallVectorTemplateBaseIcLb1EEC2Em(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %Size) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Size.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %Size, ptr %Size.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %Size.addr, align 8
  call void @_ZN4llvh25SmallVectorTemplateCommonIcvEC2Em(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %0)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh25SmallVectorTemplateCommonIcvEC2Em(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %Size) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Size.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %Size, ptr %Size.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZNK4llvh25SmallVectorTemplateCommonIcvE10getFirstElEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %0 = load i64, ptr %Size.addr, align 8
  call void @_ZN4llvh15SmallVectorBaseC2EPvm(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef %call, i64 noundef %0)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh15SmallVectorBaseC2EPvm(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %FirstEl, i64 noundef %Capacity) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %FirstEl.addr = alloca ptr, align 8
  %Capacity.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %FirstEl, ptr %FirstEl.addr, align 8
  store i64 %Capacity, ptr %Capacity.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %BeginX = getelementptr inbounds %"class.llvh::SmallVectorBase", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %FirstEl.addr, align 8
  store ptr %0, ptr %BeginX, align 8
  %Size = getelementptr inbounds %"class.llvh::SmallVectorBase", ptr %this1, i32 0, i32 1
  store i32 0, ptr %Size, align 8
  %Capacity2 = getelementptr inbounds %"class.llvh::SmallVectorBase", ptr %this1, i32 0, i32 2
  %1 = load i64, ptr %Capacity.addr, align 8
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %Capacity2, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh15SmallVectorImplIcED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr.i = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh25SmallVectorTemplateCommonIcvE7isSmallEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr %this1, ptr %this.addr.i, align 8
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %0 = load ptr, ptr %this1.i, align 8
  call void @free(ptr noundef %0) #10
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh25SmallVectorTemplateCommonIcvE7isSmallEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %BeginX = getelementptr inbounds %"class.llvh::SmallVectorBase", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %BeginX, align 8
  %call = call noundef ptr @_ZNK4llvh25SmallVectorTemplateCommonIcvE10getFirstElEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %cmp = icmp eq ptr %0, %call
  ret i1 %cmp
}

; Function Attrs: nounwind
declare void @free(ptr noundef) #12

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZNSt15__uniq_ptr_dataIN4llvh7APFloatESt14default_deleteIA_S1_ELb1ELb1EECI2St15__uniq_ptr_implIS1_S4_EEPS1_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %0) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %0, ptr %.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %1 = load ptr, ptr %.addr, align 8
  call void @_ZNSt15__uniq_ptr_implIN4llvh7APFloatESt14default_deleteIA_S1_EEC2EPS1_(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZNSt15__uniq_ptr_implIN4llvh7APFloatESt14default_deleteIA_S1_EEC2EPS1_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %__p) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %__p.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %__p, ptr %__p.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %_M_t = getelementptr inbounds %"class.std::__uniq_ptr_impl", ptr %this1, i32 0, i32 0
  call void @_ZNSt5tupleIJPN4llvh7APFloatESt14default_deleteIA_S1_EEEC2ILb1ETnNSt9enable_ifIXclsr17_TupleConstraintsIXT_ES2_S5_EE37__is_implicitly_default_constructibleEEbE4typeELb1EEEv(ptr noundef nonnull align 8 dereferenceable(8) %_M_t) #10
  %0 = load ptr, ptr %__p.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNSt15__uniq_ptr_implIN4llvh7APFloatESt14default_deleteIA_S1_EE6_M_ptrEv(ptr noundef nonnull align 8 dereferenceable(8) %this1) #10
  store ptr %0, ptr %call, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZNSt5tupleIJPN4llvh7APFloatESt14default_deleteIA_S1_EEEC2ILb1ETnNSt9enable_ifIXclsr17_TupleConstraintsIXT_ES2_S5_EE37__is_implicitly_default_constructibleEEbE4typeELb1EEEv(ptr noundef nonnull align 8 dereferenceable(8) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZNSt11_Tuple_implILm0EJPN4llvh7APFloatESt14default_deleteIA_S1_EEEC2Ev(ptr noundef nonnull align 8 dereferenceable(8) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZNSt11_Tuple_implILm0EJPN4llvh7APFloatESt14default_deleteIA_S1_EEEC2Ev(ptr noundef nonnull align 8 dereferenceable(8) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZNSt11_Tuple_implILm1EJSt14default_deleteIA_N4llvh7APFloatEEEEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %this1)
  call void @_ZNSt10_Head_baseILm0EPN4llvh7APFloatELb0EEC2Ev(ptr noundef nonnull align 8 dereferenceable(8) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZNSt11_Tuple_implILm1EJSt14default_deleteIA_N4llvh7APFloatEEEEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZNSt10_Head_baseILm1ESt14default_deleteIA_N4llvh7APFloatEELb1EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZNSt10_Head_baseILm0EPN4llvh7APFloatELb0EEC2Ev(ptr noundef nonnull align 8 dereferenceable(8) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %_M_head_impl = getelementptr inbounds %"struct.std::_Head_base.3", ptr %this1, i32 0, i32 0
  store ptr null, ptr %_M_head_impl, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZNSt10_Head_baseILm1ESt14default_deleteIA_N4llvh7APFloatEELb1EEC2Ev(ptr noundef nonnull align 1 dereferenceable(1) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden i64 @_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineINS_9hash_codeEJS4_EEES4_mPcS5_RKT_DpRKT0_(ptr noundef nonnull align 8 dereferenceable(128) %this, i64 noundef %length, ptr noundef %buffer_ptr, ptr noundef %buffer_end, ptr noundef nonnull align 8 dereferenceable(8) %arg, ptr noundef nonnull align 8 dereferenceable(8) %args) #1 comdat align 2 {
entry:
  %retval = alloca %"class.llvh::hash_code", align 8
  %this.addr = alloca ptr, align 8
  %length.addr = alloca i64, align 8
  %buffer_ptr.addr = alloca ptr, align 8
  %buffer_end.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %length, ptr %length.addr, align 8
  store ptr %buffer_ptr, ptr %buffer_ptr.addr, align 8
  store ptr %buffer_end, ptr %buffer_end.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %buffer_ptr.addr, align 8
  %1 = load ptr, ptr %buffer_end.addr, align 8
  %2 = load ptr, ptr %arg.addr, align 8
  %call = call noundef i64 @_ZN4llvh7hashing6detail17get_hashable_dataINS_9hash_codeEEENSt9enable_ifIXntsr16is_hashable_dataIT_EE5valueEmE4typeERKS5_(ptr noundef nonnull align 8 dereferenceable(8) %2)
  %call2 = call noundef ptr @_ZN4llvh7hashing6detail29hash_combine_recursive_helper12combine_dataImEEPcRmS4_S4_T_(ptr noundef nonnull align 8 dereferenceable(128) %this1, ptr noundef nonnull align 8 dereferenceable(8) %length.addr, ptr noundef %0, ptr noundef %1, i64 noundef %call)
  store ptr %call2, ptr %buffer_ptr.addr, align 8
  %3 = load i64, ptr %length.addr, align 8
  %4 = load ptr, ptr %buffer_ptr.addr, align 8
  %5 = load ptr, ptr %buffer_end.addr, align 8
  %6 = load ptr, ptr %args.addr, align 8
  %call3 = call i64 @_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineINS_9hash_codeEJEEES4_mPcS5_RKT_DpRKT0_(ptr noundef nonnull align 8 dereferenceable(128) %this1, i64 noundef %3, ptr noundef %4, ptr noundef %5, ptr noundef nonnull align 8 dereferenceable(8) %6)
  %coerce.dive = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  store i64 %call3, ptr %coerce.dive, align 8
  %coerce.dive4 = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  %7 = load i64, ptr %coerce.dive4, align 8
  ret i64 %7
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden i64 @_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineIPKNS_12fltSemanticsEJEEENS_9hash_codeEmPcS8_RKT_DpRKT0_(ptr noundef nonnull align 8 dereferenceable(128) %this, i64 noundef %length, ptr noundef %buffer_ptr, ptr noundef %buffer_end, ptr noundef nonnull align 8 dereferenceable(8) %arg) #1 comdat align 2 {
entry:
  %retval = alloca %"class.llvh::hash_code", align 8
  %this.addr = alloca ptr, align 8
  %length.addr = alloca i64, align 8
  %buffer_ptr.addr = alloca ptr, align 8
  %buffer_end.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %length, ptr %length.addr, align 8
  store ptr %buffer_ptr, ptr %buffer_ptr.addr, align 8
  store ptr %buffer_end, ptr %buffer_end.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %buffer_ptr.addr, align 8
  %1 = load ptr, ptr %buffer_end.addr, align 8
  %2 = load ptr, ptr %arg.addr, align 8
  %call = call noundef ptr @_ZN4llvh7hashing6detail17get_hashable_dataIPKNS_12fltSemanticsEEENSt9enable_ifIXsr16is_hashable_dataIT_EE5valueES7_E4typeERKS7_(ptr noundef nonnull align 8 dereferenceable(8) %2)
  %call2 = call noundef ptr @_ZN4llvh7hashing6detail29hash_combine_recursive_helper12combine_dataIPKNS_12fltSemanticsEEEPcRmS7_S7_T_(ptr noundef nonnull align 8 dereferenceable(128) %this1, ptr noundef nonnull align 8 dereferenceable(8) %length.addr, ptr noundef %0, ptr noundef %1, ptr noundef %call)
  store ptr %call2, ptr %buffer_ptr.addr, align 8
  %3 = load i64, ptr %length.addr, align 8
  %4 = load ptr, ptr %buffer_ptr.addr, align 8
  %5 = load ptr, ptr %buffer_end.addr, align 8
  %call3 = call i64 @_ZN4llvh7hashing6detail29hash_combine_recursive_helper7combineEmPcS3_(ptr noundef nonnull align 8 dereferenceable(128) %this1, i64 noundef %3, ptr noundef %4, ptr noundef %5)
  %coerce.dive = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  store i64 %call3, ptr %coerce.dive, align 8
  %coerce.dive4 = getelementptr inbounds %"class.llvh::hash_code", ptr %retval, i32 0, i32 0
  %6 = load i64, ptr %coerce.dive4, align 8
  ret i64 %6
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef ptr @_ZN4llvh7hashing6detail29hash_combine_recursive_helper12combine_dataIPKNS_12fltSemanticsEEEPcRmS7_S7_T_(ptr noundef nonnull align 8 dereferenceable(128) %this, ptr noundef nonnull align 8 dereferenceable(8) %length, ptr noundef %buffer_ptr, ptr noundef %buffer_end, ptr noundef %data) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %length.addr = alloca ptr, align 8
  %buffer_ptr.addr = alloca ptr, align 8
  %buffer_end.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  %partial_store_size = alloca i64, align 8
  %ref.tmp = alloca %"struct.llvh::hashing::detail::hash_state", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %length, ptr %length.addr, align 8
  store ptr %buffer_ptr, ptr %buffer_ptr.addr, align 8
  store ptr %buffer_end, ptr %buffer_end.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %buffer_end.addr, align 8
  %call = call noundef zeroext i1 @_ZN4llvh7hashing6detail17store_and_advanceIPKNS_12fltSemanticsEEEbRPcS6_RKT_m(ptr noundef nonnull align 8 dereferenceable(8) %buffer_ptr.addr, ptr noundef %0, ptr noundef nonnull align 8 dereferenceable(8) %data.addr, i64 noundef 0)
  br i1 %call, label %if.end12, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %buffer_end.addr, align 8
  %2 = load ptr, ptr %buffer_ptr.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %partial_store_size, align 8
  %3 = load ptr, ptr %buffer_ptr.addr, align 8
  %4 = load i64, ptr %partial_store_size, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %3, ptr align 8 %data.addr, i64 %4, i1 false)
  %5 = load ptr, ptr %length.addr, align 8
  %6 = load i64, ptr %5, align 8
  %cmp = icmp eq i64 %6, 0
  br i1 %cmp, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %buffer = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 0
  %arraydecay = getelementptr inbounds [64 x i8], ptr %buffer, i64 0, i64 0
  %seed = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 2
  %7 = load i64, ptr %seed, align 8
  call void @_ZN4llvh7hashing6detail10hash_state6createEPKcm(ptr sret(%"struct.llvh::hashing::detail::hash_state") align 8 %ref.tmp, ptr noundef %arraydecay, i64 noundef %7)
  %state3 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %state3, ptr align 8 %ref.tmp, i64 56, i1 false)
  %8 = load ptr, ptr %length.addr, align 8
  store i64 64, ptr %8, align 8
  br label %if.end

if.else:                                          ; preds = %if.then
  %state4 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 1
  %buffer5 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 0
  %arraydecay6 = getelementptr inbounds [64 x i8], ptr %buffer5, i64 0, i64 0
  call void @_ZN4llvh7hashing6detail10hash_state3mixEPKc(ptr noundef nonnull align 8 dereferenceable(56) %state4, ptr noundef %arraydecay6)
  %9 = load ptr, ptr %length.addr, align 8
  %10 = load i64, ptr %9, align 8
  %add = add i64 %10, 64
  store i64 %add, ptr %9, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then2
  %buffer7 = getelementptr inbounds %"struct.llvh::hashing::detail::hash_combine_recursive_helper", ptr %this1, i32 0, i32 0
  %arraydecay8 = getelementptr inbounds [64 x i8], ptr %buffer7, i64 0, i64 0
  store ptr %arraydecay8, ptr %buffer_ptr.addr, align 8
  %11 = load ptr, ptr %buffer_end.addr, align 8
  %12 = load i64, ptr %partial_store_size, align 8
  %call9 = call noundef zeroext i1 @_ZN4llvh7hashing6detail17store_and_advanceIPKNS_12fltSemanticsEEEbRPcS6_RKT_m(ptr noundef nonnull align 8 dereferenceable(8) %buffer_ptr.addr, ptr noundef %11, ptr noundef nonnull align 8 dereferenceable(8) %data.addr, i64 noundef %12)
  br i1 %call9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end
  call void @abort() #17
  unreachable

if.end11:                                         ; preds = %if.end
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %entry
  %13 = load ptr, ptr %buffer_ptr.addr, align 8
  ret ptr %13
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef ptr @_ZN4llvh7hashing6detail17get_hashable_dataIPKNS_12fltSemanticsEEENSt9enable_ifIXsr16is_hashable_dataIT_EE5valueES7_E4typeERKS7_(ptr noundef nonnull align 8 dereferenceable(8) %value) #1 comdat {
entry:
  %value.addr = alloca ptr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %value.addr, align 8
  %1 = load ptr, ptr %0, align 8
  ret ptr %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZN4llvh7hashing6detail17store_and_advanceIPKNS_12fltSemanticsEEEbRPcS6_RKT_m(ptr noundef nonnull align 8 dereferenceable(8) %buffer_ptr, ptr noundef %buffer_end, ptr noundef nonnull align 8 dereferenceable(8) %value, i64 noundef %offset) #1 comdat {
entry:
  %retval = alloca i1, align 1
  %buffer_ptr.addr = alloca ptr, align 8
  %buffer_end.addr = alloca ptr, align 8
  %value.addr = alloca ptr, align 8
  %offset.addr = alloca i64, align 8
  %store_size = alloca i64, align 8
  %value_data = alloca ptr, align 8
  store ptr %buffer_ptr, ptr %buffer_ptr.addr, align 8
  store ptr %buffer_end, ptr %buffer_end.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load i64, ptr %offset.addr, align 8
  %sub = sub i64 8, %0
  store i64 %sub, ptr %store_size, align 8
  %1 = load ptr, ptr %buffer_ptr.addr, align 8
  %2 = load ptr, ptr %1, align 8
  %3 = load i64, ptr %store_size, align 8
  %add.ptr = getelementptr inbounds i8, ptr %2, i64 %3
  %4 = load ptr, ptr %buffer_end.addr, align 8
  %cmp = icmp ugt ptr %add.ptr, %4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %value.addr, align 8
  store ptr %5, ptr %value_data, align 8
  %6 = load ptr, ptr %buffer_ptr.addr, align 8
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %value_data, align 8
  %9 = load i64, ptr %offset.addr, align 8
  %add.ptr1 = getelementptr inbounds i8, ptr %8, i64 %9
  %10 = load i64, ptr %store_size, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %7, ptr align 1 %add.ptr1, i64 %10, i1 false)
  %11 = load i64, ptr %store_size, align 8
  %12 = load ptr, ptr %buffer_ptr.addr, align 8
  %13 = load ptr, ptr %12, align 8
  %add.ptr2 = getelementptr inbounds i8, ptr %13, i64 %11
  store ptr %add.ptr2, ptr %12, align 8
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %14 = load i1, ptr %retval, align 1
  ret i1 %14
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh22DefaultFoldingSetTraitINS_5APIntEE7ProfileERKS1_RNS_16FoldingSetNodeIDE(ptr noundef nonnull align 8 dereferenceable(12) %X, ptr noundef nonnull align 8 dereferenceable(144) %ID) #1 comdat align 2 {
entry:
  %X.addr = alloca ptr, align 8
  %ID.addr = alloca ptr, align 8
  store ptr %X, ptr %X.addr, align 8
  store ptr %ID, ptr %ID.addr, align 8
  %0 = load ptr, ptr %X.addr, align 8
  %1 = load ptr, ptr %ID.addr, align 8
  call void @_ZNK4llvh5APInt7ProfileERNS_16FoldingSetNodeIDE(ptr noundef nonnull align 8 dereferenceable(12) %0, ptr noundef nonnull align 8 dereferenceable(144) %1)
  ret void
}

declare void @_ZNK4llvh5APInt7ProfileERNS_16FoldingSetNodeIDE(ptr noundef nonnull align 8 dereferenceable(12), ptr noundef nonnull align 8 dereferenceable(144)) #5

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh15SmallVectorImplImEC2Ej(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %N) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %N.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %N, ptr %N.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %N.addr, align 4
  %conv = zext i32 %0 to i64
  call void @_ZN4llvh23SmallVectorTemplateBaseImLb1EEC2Em(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %conv)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh15SmallVectorImplImE6assignEmRKm(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %NumElts, ptr noundef nonnull align 8 dereferenceable(8) %Elt) #1 comdat align 2 {
entry:
  %this.addr.i.i = alloca ptr, align 8
  %this.addr.i4 = alloca ptr, align 8
  %this.addr.i = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %NumElts.addr = alloca i64, align 8
  %Elt.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %NumElts, ptr %NumElts.addr, align 8
  store ptr %Elt, ptr %Elt.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN4llvh15SmallVectorImplImE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %call = call noundef i64 @_ZNK4llvh15SmallVectorBase8capacityEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %0 = load i64, ptr %NumElts.addr, align 8
  %cmp = icmp ult i64 %call, %0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %NumElts.addr, align 8
  call void @_ZN4llvh23SmallVectorTemplateBaseImLb1EE4growEm(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i64, ptr %NumElts.addr, align 8
  call void @_ZN4llvh15SmallVectorBase8set_sizeEm(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %2)
  store ptr %this1, ptr %this.addr.i, align 8
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %3 = load ptr, ptr %this1.i, align 8
  store ptr %this1, ptr %this.addr.i4, align 8
  %this1.i5 = load ptr, ptr %this.addr.i4, align 8
  store ptr %this1.i5, ptr %this.addr.i.i, align 8
  %this1.i.i = load ptr, ptr %this.addr.i.i, align 8
  %4 = load ptr, ptr %this1.i.i, align 8
  %call2.i = call noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %this1.i5)
  %add.ptr.i = getelementptr inbounds i64, ptr %4, i64 %call2.i
  %5 = load ptr, ptr %Elt.addr, align 8
  call void @_ZSt18uninitialized_fillIPmmEvT_S1_RKT0_(ptr noundef %3, ptr noundef %add.ptr.i, ptr noundef nonnull align 8 dereferenceable(8) %5)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh23SmallVectorTemplateBaseImLb1EEC2Em(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %Size) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Size.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %Size, ptr %Size.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %Size.addr, align 8
  call void @_ZN4llvh25SmallVectorTemplateCommonImvEC2Em(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %0)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh25SmallVectorTemplateCommonImvEC2Em(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %Size) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %Size.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %Size, ptr %Size.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZNK4llvh25SmallVectorTemplateCommonImvE10getFirstElEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %0 = load i64, ptr %Size.addr, align 8
  call void @_ZN4llvh15SmallVectorBaseC2EPvm(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef %call, i64 noundef %0)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef ptr @_ZNK4llvh25SmallVectorTemplateCommonImvE10getFirstElEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %this1, i64 16
  ret ptr %add.ptr
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh15SmallVectorImplImE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr.i.i = alloca ptr, align 8
  %this.addr.i3 = alloca ptr, align 8
  %this.addr.i = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store ptr %this1, ptr %this.addr.i, align 8
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %0 = load ptr, ptr %this1.i, align 8
  store ptr %this1, ptr %this.addr.i3, align 8
  %this1.i4 = load ptr, ptr %this.addr.i3, align 8
  store ptr %this1.i4, ptr %this.addr.i.i, align 8
  %this1.i.i = load ptr, ptr %this.addr.i.i, align 8
  %1 = load ptr, ptr %this1.i.i, align 8
  %call2.i = call noundef i64 @_ZNK4llvh15SmallVectorBase4sizeEv(ptr noundef nonnull align 8 dereferenceable(16) %this1.i4)
  %add.ptr.i = getelementptr inbounds i64, ptr %1, i64 %call2.i
  call void @_ZN4llvh23SmallVectorTemplateBaseImLb1EE13destroy_rangeEPmS2_(ptr noundef %0, ptr noundef %add.ptr.i)
  %Size = getelementptr inbounds %"class.llvh::SmallVectorBase", ptr %this1, i32 0, i32 1
  store i32 0, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh23SmallVectorTemplateBaseImLb1EE4growEm(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %MinSize) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %MinSize.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %MinSize, ptr %MinSize.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %MinSize.addr, align 8
  call void @_ZN4llvh25SmallVectorTemplateCommonImvE8grow_podEmm(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %0, i64 noundef 8)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZSt18uninitialized_fillIPmmEvT_S1_RKT0_(ptr noundef %__first, ptr noundef %__last, ptr noundef nonnull align 8 dereferenceable(8) %__x) #1 comdat {
entry:
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__x.addr = alloca ptr, align 8
  %__can_fill = alloca i8, align 1
  store ptr %__first, ptr %__first.addr, align 8
  store ptr %__last, ptr %__last.addr, align 8
  store ptr %__x, ptr %__x.addr, align 8
  store i8 1, ptr %__can_fill, align 1
  %0 = load ptr, ptr %__first.addr, align 8
  %1 = load ptr, ptr %__last.addr, align 8
  %2 = load ptr, ptr %__x.addr, align 8
  call void @_ZNSt20__uninitialized_fillILb1EE13__uninit_fillIPmmEEvT_S3_RKT0_(ptr noundef %0, ptr noundef %1, ptr noundef nonnull align 8 dereferenceable(8) %2)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh23SmallVectorTemplateBaseImLb1EE13destroy_rangeEPmS2_(ptr noundef %0, ptr noundef %1) #1 comdat align 2 {
entry:
  %.addr = alloca ptr, align 8
  %.addr1 = alloca ptr, align 8
  store ptr %0, ptr %.addr, align 8
  store ptr %1, ptr %.addr1, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh25SmallVectorTemplateCommonImvE8grow_podEmm(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %MinCapacity, i64 noundef %TSize) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %MinCapacity.addr = alloca i64, align 8
  %TSize.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %MinCapacity, ptr %MinCapacity.addr, align 8
  store i64 %TSize, ptr %TSize.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZNK4llvh25SmallVectorTemplateCommonImvE10getFirstElEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %0 = load i64, ptr %MinCapacity.addr, align 8
  %1 = load i64, ptr %TSize.addr, align 8
  call void @_ZN4llvh15SmallVectorBase8grow_podEPvmm(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef %call, i64 noundef %0, i64 noundef %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZNSt20__uninitialized_fillILb1EE13__uninit_fillIPmmEEvT_S3_RKT0_(ptr noundef %__first, ptr noundef %__last, ptr noundef nonnull align 8 dereferenceable(8) %__x) #1 comdat align 2 {
entry:
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__x.addr = alloca ptr, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store ptr %__last, ptr %__last.addr, align 8
  store ptr %__x, ptr %__x.addr, align 8
  %0 = load ptr, ptr %__first.addr, align 8
  %1 = load ptr, ptr %__last.addr, align 8
  %2 = load ptr, ptr %__x.addr, align 8
  call void @_ZSt4fillIPmmEvT_S1_RKT0_(ptr noundef %0, ptr noundef %1, ptr noundef nonnull align 8 dereferenceable(8) %2)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZSt4fillIPmmEvT_S1_RKT0_(ptr noundef %__first, ptr noundef %__last, ptr noundef nonnull align 8 dereferenceable(8) %__value) #1 comdat {
entry:
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__value.addr = alloca ptr, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store ptr %__last, ptr %__last.addr, align 8
  store ptr %__value, ptr %__value.addr, align 8
  %0 = load ptr, ptr %__first.addr, align 8
  %1 = load ptr, ptr %__last.addr, align 8
  %2 = load ptr, ptr %__value.addr, align 8
  call void @_ZSt8__fill_aIPmmEvT_S1_RKT0_(ptr noundef %0, ptr noundef %1, ptr noundef nonnull align 8 dereferenceable(8) %2)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZSt8__fill_aIPmmEvT_S1_RKT0_(ptr noundef %__first, ptr noundef %__last, ptr noundef nonnull align 8 dereferenceable(8) %__value) #1 comdat {
entry:
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__value.addr = alloca ptr, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store ptr %__last, ptr %__last.addr, align 8
  store ptr %__value, ptr %__value.addr, align 8
  %0 = load ptr, ptr %__first.addr, align 8
  %1 = load ptr, ptr %__last.addr, align 8
  %2 = load ptr, ptr %__value.addr, align 8
  call void @_ZSt9__fill_a1IPmmEN9__gnu_cxx11__enable_ifIXsr11__is_scalarIT0_EE7__valueEvE6__typeET_S6_RKS3_(ptr noundef %0, ptr noundef %1, ptr noundef nonnull align 8 dereferenceable(8) %2)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZSt9__fill_a1IPmmEN9__gnu_cxx11__enable_ifIXsr11__is_scalarIT0_EE7__valueEvE6__typeET_S6_RKS3_(ptr noundef %__first, ptr noundef %__last, ptr noundef nonnull align 8 dereferenceable(8) %__value) #1 comdat {
entry:
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__value.addr = alloca ptr, align 8
  %__tmp = alloca i64, align 8
  store ptr %__first, ptr %__first.addr, align 8
  store ptr %__last, ptr %__last.addr, align 8
  store ptr %__value, ptr %__value.addr, align 8
  %0 = load ptr, ptr %__value.addr, align 8
  %1 = load i64, ptr %0, align 8
  store i64 %1, ptr %__tmp, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load ptr, ptr %__first.addr, align 8
  %3 = load ptr, ptr %__last.addr, align 8
  %cmp = icmp ne ptr %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i64, ptr %__tmp, align 8
  %5 = load ptr, ptr %__first.addr, align 8
  store i64 %4, ptr %5, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load ptr, ptr %__first.addr, align 8
  %incdec.ptr = getelementptr inbounds i64, ptr %6, i32 1
  store ptr %incdec.ptr, ptr %__first.addr, align 8
  br label %for.cond, !llvm.loop !50

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden void @_ZN4llvh15SmallVectorImplImED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr.i = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK4llvh25SmallVectorTemplateCommonImvE7isSmallEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr %this1, ptr %this.addr.i, align 8
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %0 = load ptr, ptr %this1.i, align 8
  call void @free(ptr noundef %0) #10
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef zeroext i1 @_ZNK4llvh25SmallVectorTemplateCommonImvE7isSmallEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %BeginX = getelementptr inbounds %"class.llvh::SmallVectorBase", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %BeginX, align 8
  %call = call noundef ptr @_ZNK4llvh25SmallVectorTemplateCommonImvE10getFirstElEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %cmp = icmp eq ptr %0, %call
  ret i1 %cmp
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr hidden noundef ptr @_ZNK4llvh25SmallVectorTemplateCommonImvE4dataEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr.i = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store ptr %this1, ptr %this.addr.i, align 8
  %this1.i = load ptr, ptr %this.addr.i, align 8
  %0 = load ptr, ptr %this1.i, align 8
  ret ptr %0
}

attributes #0 = { mustprogress nounwind willreturn memory(none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #3 = { nobuiltin allocsize(0) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { nobuiltin nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #6 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #7 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #8 = { cold noreturn nounwind memory(inaccessiblemem: write) }
attributes #9 = { nounwind willreturn memory(read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { nounwind }
attributes #11 = { noreturn nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #12 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #13 = { builtin allocsize(0) }
attributes #14 = { builtin nounwind }
attributes #15 = { nounwind willreturn memory(read) }
attributes #16 = { nounwind willreturn memory(none) }
attributes #17 = { noreturn nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"uwtable", i32 2}
!3 = !{i32 7, !"frame-pointer", i32 2}
!4 = distinct !{!4, !5}
!5 = !{!"llvm.loop.mustprogress"}
!6 = distinct !{!6, !5}
!7 = distinct !{!7, !5}
!8 = distinct !{!8, !5}
!9 = distinct !{!9, !5}
!10 = distinct !{!10, !5}
!11 = distinct !{!11, !5}
!12 = distinct !{!12, !5}
!13 = distinct !{!13, !5}
!14 = distinct !{!14, !5}
!15 = distinct !{!15, !5}
!16 = distinct !{!16, !5}
!17 = distinct !{!17, !5}
!18 = distinct !{!18, !5}
!19 = distinct !{!19, !5}
!20 = distinct !{!20, !5}
!21 = distinct !{!21, !5}
!22 = distinct !{!22, !5}
!23 = distinct !{!23, !5}
!24 = distinct !{!24, !5}
!25 = distinct !{!25, !5}
!26 = distinct !{!26, !5}
!27 = distinct !{!27, !5}
!28 = distinct !{!28, !5}
!29 = distinct !{!29, !5}
!30 = distinct !{!30, !5}
!31 = distinct !{!31, !5}
!32 = distinct !{!32, !5}
!33 = distinct !{!33, !5}
!34 = distinct !{!34, !5}
!35 = distinct !{!35, !5}
!36 = distinct !{!36, !5}
!37 = distinct !{!37, !5}
!38 = distinct !{!38, !5}
!39 = distinct !{!39, !5}
!40 = distinct !{!40, !5}
!41 = distinct !{!41, !5}
!42 = distinct !{!42, !5}
!43 = distinct !{!43, !5}
!44 = !{!"branch_weights", i32 1, i32 1048575}
!45 = distinct !{!45, !5}
!46 = distinct !{!46, !5}
!47 = distinct !{!47, !5}
!48 = distinct !{!48, !5}
!49 = distinct !{!49, !5}
!50 = distinct !{!50, !5}
