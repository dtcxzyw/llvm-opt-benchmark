target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.ImVec2 = type { float, float }
%struct.ImFontBuilderIO = type { ptr }
%struct.ImVec4 = type { float, float, float, float }
%struct.ImGuiStyle = type { float, float, %struct.ImVec2, float, float, %struct.ImVec2, %struct.ImVec2, i32, float, float, float, float, %struct.ImVec2, float, float, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, float, float, float, float, float, float, float, float, float, float, float, float, i32, %struct.ImVec2, %struct.ImVec2, float, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, float, i8, i8, i8, float, float, [53 x %struct.ImVec4], float, float, float, i32, i32 }
%struct.ImDrawListSharedData = type { %struct.ImVec2, ptr, float, float, float, %struct.ImVec4, i32, %struct.ImVector, [48 x %struct.ImVec2], float, [64 x i8], ptr }
%struct.ImVector = type { i32, i32, ptr }
%struct.ImDrawCmd = type { %struct.ImVec4, ptr, i32, i32, i32, ptr, ptr }
%struct.ImDrawList = type <{ %struct.ImVector.0, %struct.ImVector.1, %struct.ImVector.2, i32, i32, ptr, ptr, ptr, ptr, %struct.ImVector.3, %struct.ImVector.4, %struct.ImVector, %struct.ImDrawCmdHeader, %struct.ImDrawListSplitter, float, [4 x i8] }>
%struct.ImVector.0 = type { i32, i32, ptr }
%struct.ImVector.1 = type { i32, i32, ptr }
%struct.ImVector.2 = type { i32, i32, ptr }
%struct.ImVector.3 = type { i32, i32, ptr }
%struct.ImVector.4 = type { i32, i32, ptr }
%struct.ImDrawCmdHeader = type <{ %struct.ImVec4, ptr, i32, [4 x i8] }>
%struct.ImDrawListSplitter = type { i32, i32, %struct.ImVector.5 }
%struct.ImVector.5 = type { i32, i32, ptr }
%struct.ImDrawChannel = type { %struct.ImVector.0, %struct.ImVector.1 }
%struct.ImDrawVert = type { %struct.ImVec2, %struct.ImVec2, i32 }
%struct.ImFont = type <{ %struct.ImVector.6, float, float, %struct.ImVector.1, %struct.ImVector.7, ptr, ptr, ptr, i16, i16, i16, i16, float, float, i8, [3 x i8], float, float, float, i32, [2 x i8], [2 x i8] }>
%struct.ImVector.6 = type { i32, i32, ptr }
%struct.ImVector.7 = type { i32, i32, ptr }
%struct.ImFontGlyph = type { i32, float, float, float, float, float, float, float, float, float }
%struct.ImDrawData = type { i8, i32, i32, i32, %struct.ImVector.8, %struct.ImVec2, %struct.ImVec2, %struct.ImVec2, ptr }
%struct.ImVector.8 = type { i32, i32, ptr }
%struct.ImFontConfig = type { ptr, i32, i8, i32, float, i32, i32, i8, %struct.ImVec2, %struct.ImVec2, ptr, float, float, i8, i32, float, float, i16, [40 x i8], ptr }
%struct.ImFontAtlas = type <{ i32, [4 x i8], ptr, i32, i32, i8, [7 x i8], ptr, i8, i8, [6 x i8], ptr, ptr, i32, i32, %struct.ImVec2, %struct.ImVec2, %struct.ImVector.9, %struct.ImVector.10, %struct.ImVector.11, [64 x %struct.ImVec4], ptr, i32, i32, i32, [4 x i8] }>
%struct.ImVector.9 = type { i32, i32, ptr }
%struct.ImVector.10 = type { i32, i32, ptr }
%struct.ImVector.11 = type { i32, i32, ptr }
%struct.ImFontAtlasCustomRect = type { i16, i16, i16, i16, i32, float, %struct.ImVec2, ptr }
%struct.ImVector.14 = type { i32, i32, ptr }
%struct.ImVector.15 = type { i32, i32, ptr }
%struct.ImVector.12 = type { i32, i32, ptr }
%struct.ImVector.17 = type { i32, i32, ptr }
%struct.stbtt_pack_context = type { ptr, ptr, i32, i32, i32, i32, i32, i32, i32, ptr, ptr }
%struct.stbtt_aligned_quad = type { float, float, float, float, float, float, float, float }
%struct.ImFontBuildSrcData = type { %struct.stbtt_fontinfo, %struct.stbtt_pack_range, ptr, ptr, ptr, i32, i32, i32, %struct.ImBitVector, %struct.ImVector.16 }
%struct.stbtt_fontinfo = type { ptr, ptr, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.stbtt__buf, %struct.stbtt__buf, %struct.stbtt__buf, %struct.stbtt__buf, %struct.stbtt__buf, %struct.stbtt__buf }
%struct.stbtt__buf = type { ptr, i32, i32 }
%struct.stbtt_pack_range = type { float, i32, ptr, i32, ptr, i8, i8 }
%struct.ImBitVector = type { %struct.ImVector.13 }
%struct.ImVector.13 = type { i32, i32, ptr }
%struct.ImVector.16 = type { i32, i32, ptr }
%struct.ImFontBuildDstData = type { i32, i32, i32, %struct.ImBitVector }
%struct.stbrp_rect = type { i32, i32, i32, i32, i32, i32 }
%struct.stbtt_packedchar = type { i16, i16, i16, i16, float, float, float, float, float }
%struct.stbrp__findresult = type { i32, i32, ptr }
%struct.ImFontGlyphRangesBuilder = type { %struct.ImVector.13 }
%struct.ImRect = type { %struct.ImVec2, %struct.ImVec2 }
%struct.stbtt__csctx = type { i32, i32, float, float, float, float, i32, i32, i32, i32, ptr, i32 }
%struct.stbtt_vertex = type { i16, i16, i16, i16, i16, i16, i8, i8 }
%struct.stbrp_node = type { i32, i32, ptr }
%struct.stbrp_context = type { i32, i32, i32, i32, i32, i32, ptr, ptr, [2 x %struct.stbrp_node] }
%struct.stbtt__bitmap = type { i32, i32, i32, ptr }
%struct.stbtt__point = type { float, float }
%struct.stbtt__edge = type { float, float, float, float, i32 }
%struct.stbtt__hheap = type { ptr, ptr, i32 }
%struct.stbtt__active_edge = type { ptr, float, float, float, float, float, float }
%struct.stbtt__hheap_chunk = type { ptr }

$_ZN6ImVec4C2Effff = comdat any

$_ZN6ImVec2C2Ev = comdat any

$_ZN6ImVec4C2Ev = comdat any

$_ZN8ImVectorI6ImVec2EC2Ev = comdat any

$_ZN6ImVec2C2Eff = comdat any

$_ZN8ImVectorI6ImVec2ED2Ev = comdat any

$_ZN8ImVectorI9ImDrawCmdE6resizeEi = comdat any

$_ZN8ImVectorItE6resizeEi = comdat any

$_ZN8ImVectorI10ImDrawVertE6resizeEi = comdat any

$_ZN8ImVectorI6ImVec4E6resizeEi = comdat any

$_ZN8ImVectorIPvE6resizeEi = comdat any

$_ZN8ImVectorI6ImVec2E6resizeEi = comdat any

$_ZN18ImDrawListSplitter5ClearEv = comdat any

$_ZN8ImVectorI9ImDrawCmdE9push_backERKS0_ = comdat any

$_ZN9ImDrawCmdC2Ev = comdat any

$_ZN8ImVectorI9ImDrawCmdE5clearEv = comdat any

$_ZN8ImVectorItE5clearEv = comdat any

$_ZN8ImVectorI10ImDrawVertE5clearEv = comdat any

$_ZN8ImVectorI6ImVec4E5clearEv = comdat any

$_ZN8ImVectorIPvE5clearEv = comdat any

$_ZN8ImVectorI6ImVec2E5clearEv = comdat any

$_Znwm12ImNewWrapperPv = comdat any

$_ZN10ImDrawListC2EP20ImDrawListSharedData = comdat any

$_ZdlPv12ImNewWrapperS_ = comdat any

$_ZN8ImVectorI9ImDrawCmdEaSERKS1_ = comdat any

$_ZN8ImVectorItEaSERKS0_ = comdat any

$_ZN8ImVectorI10ImDrawVertEaSERKS1_ = comdat any

$_ZN8ImVectorI9ImDrawCmdE8pop_backEv = comdat any

$_ZN8ImVectorI6ImVec4E9push_backERKS0_ = comdat any

$_ZN8ImVectorI6ImVec4E8pop_backEv = comdat any

$_ZN8ImVectorIPvE9push_backERKS0_ = comdat any

$_ZN8ImVectorIPvE8pop_backEv = comdat any

$_ZN8ImVectorI10ImDrawVertE6shrinkEi = comdat any

$_ZN8ImVectorItE6shrinkEi = comdat any

$_ZN8ImVectorI6ImVec2E15reserve_discardEi = comdat any

$_ZN8ImVectorI6ImVec2E9push_backERKS0_ = comdat any

$_ZN8ImVectorI6ImVec2E7reserveEi = comdat any

$_ZN8ImVectorI6ImVec2E4backEv = comdat any

$_ZN10ImDrawList10PathLineToERK6ImVec2 = comdat any

$_ZN10ImDrawList10PathStrokeEjif = comdat any

$_ZN10ImDrawList14PathFillConvexEj = comdat any

$_ZN10ImDrawList12PrimWriteIdxEt = comdat any

$_ZN10ImDrawList12PrimWriteVtxERK6ImVec2S2_j = comdat any

$_ZN8ImVectorI13ImDrawChannelEixEi = comdat any

$_ZN8ImVectorI13ImDrawChannelE5clearEv = comdat any

$_ZN8ImVectorI13ImDrawChannelE7reserveEi = comdat any

$_ZN8ImVectorI13ImDrawChannelE6resizeEi = comdat any

$_ZN13ImDrawChannelC2Ev = comdat any

$_ZN8ImVectorI9ImDrawCmdE4backEv = comdat any

$_ZN8ImVectorI9ImDrawCmdEixEi = comdat any

$_ZN8ImVectorI9ImDrawCmdE5eraseEPKS0_ = comdat any

$_ZN8ImVectorIP10ImDrawListE6resizeEi = comdat any

$_ZN8ImVectorIP10ImDrawListE9push_backERKS1_ = comdat any

$_ZN8ImVectorI10ImDrawVertEC2Ev = comdat any

$_ZN8ImVectorIP10ImDrawListEixEi = comdat any

$_ZNK8ImVectorItE5emptyEv = comdat any

$_ZN8ImVectorI10ImDrawVertEixEi = comdat any

$_ZN8ImVectorItEixEi = comdat any

$_ZN8ImVectorI10ImDrawVertE4swapERS1_ = comdat any

$_ZN8ImVectorI10ImDrawVertED2Ev = comdat any

$_ZN8ImVectorIP10ImDrawListE5beginEv = comdat any

$_ZN8ImVectorIP10ImDrawListE3endEv = comdat any

$_ZN8ImVectorI9ImDrawCmdE5beginEv = comdat any

$_ZN8ImVectorI9ImDrawCmdE3endEv = comdat any

$_ZN8ImVectorIP6ImFontEC2Ev = comdat any

$_ZN8ImVectorI21ImFontAtlasCustomRectEC2Ev = comdat any

$_ZN8ImVectorI12ImFontConfigEC2Ev = comdat any

$_ZN8ImVectorI12ImFontConfigED2Ev = comdat any

$_ZN8ImVectorI21ImFontAtlasCustomRectED2Ev = comdat any

$_ZN8ImVectorIP6ImFontED2Ev = comdat any

$__clang_call_terminate = comdat any

$_ZN8ImVectorI12ImFontConfigE5beginEv = comdat any

$_ZN8ImVectorI12ImFontConfigE3endEv = comdat any

$_ZN8ImVectorIP6ImFontE5beginEv = comdat any

$_ZN8ImVectorIP6ImFontE3endEv = comdat any

$_ZN8ImVectorI12ImFontConfigE5clearEv = comdat any

$_ZN8ImVectorI21ImFontAtlasCustomRectE5clearEv = comdat any

$_ZN8ImVectorIP6ImFontE12clear_deleteEv = comdat any

$_ZN8ImVectorIP6ImFontE9push_backERKS1_ = comdat any

$_ZN8ImVectorI12ImFontConfigE9push_backERKS0_ = comdat any

$_ZN8ImVectorI12ImFontConfigE4backEv = comdat any

$_ZN8ImVectorIP6ImFontE4backEv = comdat any

$_ZN21ImFontAtlasCustomRectC2Ev = comdat any

$_ZN8ImVectorI21ImFontAtlasCustomRectE9push_backERKS0_ = comdat any

$_ZN11ImFontAtlas20GetCustomRectByIndexEi = comdat any

$_ZN8ImVectorI10stbrp_rectEC2Ev = comdat any

$_ZN8ImVectorI10stbrp_rectE6resizeEi = comdat any

$_ZNK8ImVectorI10stbrp_rectE13size_in_bytesEv = comdat any

$_ZN8ImVectorI21ImFontAtlasCustomRectEixEi = comdat any

$_ZN8ImVectorI10stbrp_rectEixEi = comdat any

$_ZN8ImVectorI10stbrp_rectED2Ev = comdat any

$_ZN24ImFontGlyphRangesBuilder7AddCharEt = comdat any

$_ZNK24ImFontGlyphRangesBuilder6GetBitEm = comdat any

$_ZN8ImVectorItE9push_backERKt = comdat any

$_ZN8ImVectorIfEC2Ev = comdat any

$_ZN8ImVectorItEC2Ev = comdat any

$_ZN8ImVectorI11ImFontGlyphEC2Ev = comdat any

$_ZN8ImVectorItED2Ev = comdat any

$_ZN8ImVectorIfED2Ev = comdat any

$_ZN8ImVectorI11ImFontGlyphED2Ev = comdat any

$_ZN8ImVectorI11ImFontGlyphE5clearEv = comdat any

$_ZN8ImVectorIfE5clearEv = comdat any

$_ZN8ImVectorI11ImFontGlyphEixEi = comdat any

$_ZN8ImVectorIfEixEi = comdat any

$_ZN8ImVectorI11ImFontGlyphE4backEv = comdat any

$_ZN8ImVectorI11ImFontGlyphE6resizeEi = comdat any

$_ZN8ImVectorIfE6resizeEiRKf = comdat any

$_ZN8ImVectorItE6resizeEiRKt = comdat any

$_ZN8ImVectorI9ImDrawCmdEC2Ev = comdat any

$_ZN8ImVectorI6ImVec4EC2Ev = comdat any

$_ZN8ImVectorIPvEC2Ev = comdat any

$_ZN15ImDrawCmdHeaderC2Ev = comdat any

$_ZN18ImDrawListSplitterC2Ev = comdat any

$_ZN8ImVectorIPvED2Ev = comdat any

$_ZN8ImVectorI6ImVec4ED2Ev = comdat any

$_ZN8ImVectorI9ImDrawCmdED2Ev = comdat any

$_ZN8ImVectorI13ImDrawChannelEC2Ev = comdat any

$_ZN8ImVectorI18ImFontBuildSrcDataEC2Ev = comdat any

$_ZN8ImVectorI18ImFontBuildDstDataEC2Ev = comdat any

$_ZN8ImVectorI18ImFontBuildSrcDataE6resizeEi = comdat any

$_ZN8ImVectorI18ImFontBuildDstDataE6resizeEi = comdat any

$_ZNK8ImVectorI18ImFontBuildSrcDataE13size_in_bytesEv = comdat any

$_ZNK8ImVectorI18ImFontBuildDstDataE13size_in_bytesEv = comdat any

$_ZN8ImVectorI18ImFontBuildSrcDataEixEi = comdat any

$_ZN8ImVectorI12ImFontConfigEixEi = comdat any

$_ZN8ImVectorIP6ImFontEixEi = comdat any

$_ZN8ImVectorI18ImFontBuildDstDataEixEi = comdat any

$_ZN11ImBitVector6CreateEi = comdat any

$_ZNK8ImVectorIjE5emptyEv = comdat any

$_ZNK11ImBitVector7TestBitEi = comdat any

$_ZN11ImBitVector6SetBitEi = comdat any

$_ZN8ImVectorIiE7reserveEi = comdat any

$_ZN11ImBitVector5ClearEv = comdat any

$_ZN8ImVectorI18ImFontBuildDstDataE5clearEv = comdat any

$_ZN8ImVectorI16stbtt_packedcharEC2Ev = comdat any

$_ZN8ImVectorI16stbtt_packedcharE6resizeEi = comdat any

$_ZNK8ImVectorI16stbtt_packedcharE13size_in_bytesEv = comdat any

$_ZN8ImVectorI16stbtt_packedcharEixEi = comdat any

$_ZN8ImVectorIiEixEi = comdat any

$_ZN8ImVectorI10stbrp_rectE5clearEv = comdat any

$_ZN8ImVectorI18ImFontBuildSrcDataE14clear_destructEv = comdat any

$_ZN8ImVectorI16stbtt_packedcharED2Ev = comdat any

$_ZN8ImVectorI18ImFontBuildDstDataED2Ev = comdat any

$_ZN8ImVectorI18ImFontBuildSrcDataED2Ev = comdat any

$_ZN8ImVectorI18ImFontBuildSrcDataE7reserveEi = comdat any

$_ZNK8ImVectorI18ImFontBuildSrcDataE14_grow_capacityEi = comdat any

$_ZN8ImVectorI18ImFontBuildDstDataE7reserveEi = comdat any

$_ZNK8ImVectorI18ImFontBuildDstDataE14_grow_capacityEi = comdat any

$_ZN8ImVectorIjE6resizeEi = comdat any

$_ZN8ImVectorIjE7reserveEi = comdat any

$_ZNK8ImVectorIjE14_grow_capacityEi = comdat any

$_Z16ImBitArraySetBitPji = comdat any

$_ZNK8ImVectorIjE5beginEv = comdat any

$_ZNK8ImVectorIjE3endEv = comdat any

$_ZN8ImVectorIiE9push_backERKi = comdat any

$_ZNK8ImVectorIiE14_grow_capacityEi = comdat any

$_ZN8ImVectorIjE5clearEv = comdat any

$_ZN8ImVectorI16stbtt_packedcharE7reserveEi = comdat any

$_ZNK8ImVectorI16stbtt_packedcharE14_grow_capacityEi = comdat any

$_ZN18ImFontBuildSrcDataD2Ev = comdat any

$_ZN8ImVectorI18ImFontBuildSrcDataE5clearEv = comdat any

$_ZN8ImVectorIiED2Ev = comdat any

$_ZN11ImBitVectorD2Ev = comdat any

$_ZN8ImVectorIjED2Ev = comdat any

$_ZN24ImFontGlyphRangesBuilder6SetBitEm = comdat any

$_ZN8ImVectorIjEixEi = comdat any

$_ZNK8ImVectorIjEixEi = comdat any

$_ZNK8ImVectorI6ImVec2E14_grow_capacityEi = comdat any

$_ZN8ImVectorI9ImDrawCmdE7reserveEi = comdat any

$_ZNK8ImVectorI9ImDrawCmdE14_grow_capacityEi = comdat any

$_ZN8ImVectorItE7reserveEi = comdat any

$_ZNK8ImVectorItE14_grow_capacityEi = comdat any

$_ZN8ImVectorI10ImDrawVertE7reserveEi = comdat any

$_ZNK8ImVectorI10ImDrawVertE14_grow_capacityEi = comdat any

$_ZN8ImVectorI6ImVec4E7reserveEi = comdat any

$_ZNK8ImVectorI6ImVec4E14_grow_capacityEi = comdat any

$_ZN8ImVectorIPvE7reserveEi = comdat any

$_ZNK8ImVectorIPvE14_grow_capacityEi = comdat any

$_ZNK8ImVectorI13ImDrawChannelE14_grow_capacityEi = comdat any

$_ZN8ImVectorIP10ImDrawListE7reserveEi = comdat any

$_ZNK8ImVectorIP10ImDrawListE14_grow_capacityEi = comdat any

$_Z9IM_DELETEI6ImFontEvPT_ = comdat any

$_ZN8ImVectorIP6ImFontE5clearEv = comdat any

$_ZN8ImVectorIP6ImFontE7reserveEi = comdat any

$_ZNK8ImVectorIP6ImFontE14_grow_capacityEi = comdat any

$_ZN8ImVectorI12ImFontConfigE7reserveEi = comdat any

$_ZNK8ImVectorI12ImFontConfigE14_grow_capacityEi = comdat any

$_ZN8ImVectorI21ImFontAtlasCustomRectE7reserveEi = comdat any

$_ZNK8ImVectorI21ImFontAtlasCustomRectE14_grow_capacityEi = comdat any

$_ZN8ImVectorI10stbrp_rectE7reserveEi = comdat any

$_ZNK8ImVectorI10stbrp_rectE14_grow_capacityEi = comdat any

$_ZN8ImVectorI11ImFontGlyphE7reserveEi = comdat any

$_ZNK8ImVectorI11ImFontGlyphE14_grow_capacityEi = comdat any

$_ZN8ImVectorIfE7reserveEi = comdat any

$_ZNK8ImVectorIfE14_grow_capacityEi = comdat any

@.str = private unnamed_addr constant [22 x i8] c"ProggyClean.ttf, %dpx\00", align 1
@.str.1 = private unnamed_addr constant [3 x i8] c"rb\00", align 1
@.str.2 = private unnamed_addr constant [11 x i8] c"%s, %.0fpx\00", align 1
@_ZL34FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA = internal constant [9 x [3 x %struct.ImVec2]] [[3 x %struct.ImVec2] [%struct.ImVec2 { float 0.000000e+00, float 3.000000e+00 }, %struct.ImVec2 { float 1.200000e+01, float 1.900000e+01 }, %struct.ImVec2 zeroinitializer], [3 x %struct.ImVec2] [%struct.ImVec2 { float 1.300000e+01, float 0.000000e+00 }, %struct.ImVec2 { float 7.000000e+00, float 1.600000e+01 }, %struct.ImVec2 { float 1.000000e+00, float 8.000000e+00 }], [3 x %struct.ImVec2] [%struct.ImVec2 { float 3.100000e+01, float 0.000000e+00 }, %struct.ImVec2 { float 2.300000e+01, float 2.300000e+01 }, %struct.ImVec2 { float 1.100000e+01, float 1.100000e+01 }], [3 x %struct.ImVec2] [%struct.ImVec2 { float 2.100000e+01, float 0.000000e+00 }, %struct.ImVec2 { float 9.000000e+00, float 2.300000e+01 }, %struct.ImVec2 { float 4.000000e+00, float 1.100000e+01 }], [3 x %struct.ImVec2] [%struct.ImVec2 { float 5.500000e+01, float 1.800000e+01 }, %struct.ImVec2 { float 2.300000e+01, float 9.000000e+00 }, %struct.ImVec2 { float 1.100000e+01, float 4.000000e+00 }], [3 x %struct.ImVec2] [%struct.ImVec2 { float 7.300000e+01, float 0.000000e+00 }, %struct.ImVec2 { float 1.700000e+01, float 1.700000e+01 }, %struct.ImVec2 { float 8.000000e+00, float 8.000000e+00 }], [3 x %struct.ImVec2] [%struct.ImVec2 { float 5.500000e+01, float 0.000000e+00 }, %struct.ImVec2 { float 1.700000e+01, float 1.700000e+01 }, %struct.ImVec2 { float 8.000000e+00, float 8.000000e+00 }], [3 x %struct.ImVec2] [%struct.ImVec2 { float 9.100000e+01, float 0.000000e+00 }, %struct.ImVec2 { float 1.700000e+01, float 2.200000e+01 }, %struct.ImVec2 { float 5.000000e+00, float 0.000000e+00 }], [3 x %struct.ImVec2] [%struct.ImVec2 { float 1.090000e+02, float 0.000000e+00 }, %struct.ImVec2 { float 1.300000e+01, float 1.500000e+01 }, %struct.ImVec2 { float 6.000000e+00, float 7.000000e+00 }]], align 16
@_ZZ35ImFontAtlasGetBuilderForStbTruetypevE2io = internal global %struct.ImFontBuilderIO zeroinitializer, align 8
@_ZZN11ImFontAtlas21GetGlyphRangesDefaultEvE6ranges = internal constant [3 x i16] [i16 32, i16 255, i16 0], align 2
@_ZZN11ImFontAtlas19GetGlyphRangesGreekEvE6ranges = internal constant [5 x i16] [i16 32, i16 255, i16 880, i16 1023, i16 0], align 2
@_ZZN11ImFontAtlas20GetGlyphRangesKoreanEvE6ranges = internal constant [9 x i16] [i16 32, i16 255, i16 12593, i16 12643, i16 -21504, i16 -10333, i16 -3, i16 -3, i16 0], align 16
@_ZZN11ImFontAtlas25GetGlyphRangesChineseFullEvE6ranges = internal constant [15 x i16] [i16 32, i16 255, i16 8192, i16 8303, i16 12288, i16 12543, i16 12784, i16 12799, i16 -256, i16 -17, i16 -3, i16 -3, i16 19968, i16 -24657, i16 0], align 16
@_ZZN11ImFontAtlas37GetGlyphRangesChineseSimplifiedCommonEvE32accumulative_offsets_from_0x4E00 = internal constant [2500 x i16] [i16 0, i16 1, i16 2, i16 4, i16 1, i16 1, i16 1, i16 1, i16 2, i16 1, i16 3, i16 2, i16 1, i16 2, i16 2, i16 1, i16 1, i16 1, i16 1, i16 1, i16 5, i16 2, i16 1, i16 2, i16 3, i16 3, i16 3, i16 2, i16 2, i16 4, i16 1, i16 1, i16 1, i16 2, i16 1, i16 5, i16 2, i16 3, i16 1, i16 2, i16 1, i16 2, i16 1, i16 1, i16 2, i16 1, i16 1, i16 2, i16 2, i16 1, i16 4, i16 1, i16 1, i16 1, i16 1, i16 5, i16 10, i16 1, i16 2, i16 19, i16 2, i16 1, i16 2, i16 1, i16 2, i16 1, i16 2, i16 1, i16 2, i16 1, i16 5, i16 1, i16 6, i16 3, i16 2, i16 1, i16 2, i16 2, i16 1, i16 1, i16 1, i16 4, i16 8, i16 5, i16 1, i16 1, i16 4, i16 1, i16 1, i16 3, i16 1, i16 2, i16 1, i16 5, i16 1, i16 2, i16 1, i16 1, i16 1, i16 10, i16 1, i16 1, i16 5, i16 2, i16 4, i16 6, i16 1, i16 4, i16 2, i16 2, i16 2, i16 12, i16 2, i16 1, i16 1, i16 6, i16 1, i16 1, i16 1, i16 4, i16 1, i16 1, i16 4, i16 6, i16 5, i16 1, i16 4, i16 2, i16 2, i16 4, i16 10, i16 7, i16 1, i16 1, i16 4, i16 2, i16 4, i16 2, i16 1, i16 4, i16 3, i16 6, i16 10, i16 12, i16 5, i16 7, i16 2, i16 14, i16 2, i16 9, i16 1, i16 1, i16 6, i16 7, i16 10, i16 4, i16 7, i16 13, i16 1, i16 5, i16 4, i16 8, i16 4, i16 1, i16 1, i16 2, i16 28, i16 5, i16 6, i16 1, i16 1, i16 5, i16 2, i16 5, i16 20, i16 2, i16 2, i16 9, i16 8, i16 11, i16 2, i16 9, i16 17, i16 1, i16 8, i16 6, i16 8, i16 27, i16 4, i16 6, i16 9, i16 20, i16 11, i16 27, i16 6, i16 68, i16 2, i16 2, i16 1, i16 1, i16 1, i16 2, i16 1, i16 2, i16 2, i16 7, i16 6, i16 11, i16 3, i16 3, i16 1, i16 1, i16 3, i16 1, i16 2, i16 1, i16 1, i16 1, i16 1, i16 1, i16 3, i16 1, i16 1, i16 8, i16 3, i16 4, i16 1, i16 5, i16 7, i16 2, i16 1, i16 4, i16 4, i16 8, i16 4, i16 2, i16 1, i16 2, i16 1, i16 1, i16 4, i16 5, i16 6, i16 3, i16 6, i16 2, i16 12, i16 3, i16 1, i16 3, i16 9, i16 2, i16 4, i16 3, i16 4, i16 1, i16 5, i16 3, i16 3, i16 1, i16 3, i16 7, i16 1, i16 5, i16 1, i16 1, i16 1, i16 1, i16 2, i16 3, i16 4, i16 5, i16 2, i16 3, i16 2, i16 6, i16 1, i16 1, i16 2, i16 1, i16 7, i16 1, i16 7, i16 3, i16 4, i16 5, i16 15, i16 2, i16 2, i16 1, i16 5, i16 3, i16 22, i16 19, i16 2, i16 1, i16 1, i16 1, i16 1, i16 2, i16 5, i16 1, i16 1, i16 1, i16 6, i16 1, i16 1, i16 12, i16 8, i16 2, i16 9, i16 18, i16 22, i16 4, i16 1, i16 1, i16 5, i16 1, i16 16, i16 1, i16 2, i16 7, i16 10, i16 15, i16 1, i16 1, i16 6, i16 2, i16 4, i16 1, i16 2, i16 4, i16 1, i16 6, i16 1, i16 1, i16 3, i16 2, i16 4, i16 1, i16 6, i16 4, i16 5, i16 1, i16 2, i16 1, i16 1, i16 2, i16 1, i16 10, i16 3, i16 1, i16 3, i16 2, i16 1, i16 9, i16 3, i16 2, i16 5, i16 7, i16 2, i16 19, i16 4, i16 3, i16 6, i16 1, i16 1, i16 1, i16 1, i16 1, i16 4, i16 3, i16 2, i16 1, i16 1, i16 1, i16 2, i16 5, i16 3, i16 1, i16 1, i16 1, i16 2, i16 2, i16 1, i16 1, i16 2, i16 1, i16 1, i16 2, i16 1, i16 3, i16 1, i16 1, i16 1, i16 3, i16 7, i16 1, i16 4, i16 1, i16 1, i16 2, i16 1, i16 1, i16 2, i16 1, i16 2, i16 4, i16 4, i16 3, i16 8, i16 1, i16 1, i16 1, i16 2, i16 1, i16 3, i16 5, i16 1, i16 3, i16 1, i16 3, i16 4, i16 6, i16 2, i16 2, i16 14, i16 4, i16 6, i16 6, i16 11, i16 9, i16 1, i16 15, i16 3, i16 1, i16 28, i16 5, i16 2, i16 5, i16 5, i16 3, i16 1, i16 3, i16 4, i16 5, i16 4, i16 6, i16 14, i16 3, i16 2, i16 3, i16 5, i16 21, i16 2, i16 7, i16 20, i16 10, i16 1, i16 2, i16 19, i16 2, i16 4, i16 28, i16 28, i16 2, i16 3, i16 2, i16 1, i16 14, i16 4, i16 1, i16 26, i16 28, i16 42, i16 12, i16 40, i16 3, i16 52, i16 79, i16 5, i16 14, i16 17, i16 3, i16 2, i16 2, i16 11, i16 3, i16 4, i16 6, i16 3, i16 1, i16 8, i16 2, i16 23, i16 4, i16 5, i16 8, i16 10, i16 4, i16 2, i16 7, i16 3, i16 5, i16 1, i16 1, i16 6, i16 3, i16 1, i16 2, i16 2, i16 2, i16 5, i16 28, i16 1, i16 1, i16 7, i16 7, i16 20, i16 5, i16 3, i16 29, i16 3, i16 17, i16 26, i16 1, i16 8, i16 4, i16 27, i16 3, i16 6, i16 11, i16 23, i16 5, i16 3, i16 4, i16 6, i16 13, i16 24, i16 16, i16 6, i16 5, i16 10, i16 25, i16 35, i16 7, i16 3, i16 2, i16 3, i16 3, i16 14, i16 3, i16 6, i16 2, i16 6, i16 1, i16 4, i16 2, i16 3, i16 8, i16 2, i16 1, i16 1, i16 3, i16 3, i16 3, i16 4, i16 1, i16 1, i16 13, i16 2, i16 2, i16 4, i16 5, i16 2, i16 1, i16 14, i16 14, i16 1, i16 2, i16 2, i16 1, i16 4, i16 5, i16 2, i16 3, i16 1, i16 14, i16 3, i16 12, i16 3, i16 17, i16 2, i16 16, i16 5, i16 1, i16 2, i16 1, i16 8, i16 9, i16 3, i16 19, i16 4, i16 2, i16 2, i16 4, i16 17, i16 25, i16 21, i16 20, i16 28, i16 75, i16 1, i16 10, i16 29, i16 103, i16 4, i16 1, i16 2, i16 1, i16 1, i16 4, i16 2, i16 4, i16 1, i16 2, i16 3, i16 24, i16 2, i16 2, i16 2, i16 1, i16 1, i16 2, i16 1, i16 3, i16 8, i16 1, i16 1, i16 1, i16 2, i16 1, i16 1, i16 3, i16 1, i16 1, i16 1, i16 6, i16 1, i16 5, i16 3, i16 1, i16 1, i16 1, i16 3, i16 4, i16 1, i16 1, i16 5, i16 2, i16 1, i16 5, i16 6, i16 13, i16 9, i16 16, i16 1, i16 1, i16 1, i16 1, i16 3, i16 2, i16 3, i16 2, i16 4, i16 5, i16 2, i16 5, i16 2, i16 2, i16 3, i16 7, i16 13, i16 7, i16 2, i16 2, i16 1, i16 1, i16 1, i16 1, i16 2, i16 3, i16 3, i16 2, i16 1, i16 6, i16 4, i16 9, i16 2, i16 1, i16 14, i16 2, i16 14, i16 2, i16 1, i16 18, i16 3, i16 4, i16 14, i16 4, i16 11, i16 41, i16 15, i16 23, i16 15, i16 23, i16 176, i16 1, i16 3, i16 4, i16 1, i16 1, i16 1, i16 1, i16 5, i16 3, i16 1, i16 2, i16 3, i16 7, i16 3, i16 1, i16 1, i16 2, i16 1, i16 2, i16 4, i16 4, i16 6, i16 2, i16 4, i16 1, i16 9, i16 7, i16 1, i16 10, i16 5, i16 8, i16 16, i16 29, i16 1, i16 1, i16 2, i16 2, i16 3, i16 1, i16 3, i16 5, i16 2, i16 4, i16 5, i16 4, i16 1, i16 1, i16 2, i16 2, i16 3, i16 3, i16 7, i16 1, i16 6, i16 10, i16 1, i16 17, i16 1, i16 44, i16 4, i16 6, i16 2, i16 1, i16 1, i16 6, i16 5, i16 4, i16 2, i16 10, i16 1, i16 6, i16 9, i16 2, i16 8, i16 1, i16 24, i16 1, i16 2, i16 13, i16 7, i16 8, i16 8, i16 2, i16 1, i16 4, i16 1, i16 3, i16 1, i16 3, i16 3, i16 5, i16 2, i16 5, i16 10, i16 9, i16 4, i16 9, i16 12, i16 2, i16 1, i16 6, i16 1, i16 10, i16 1, i16 1, i16 7, i16 7, i16 4, i16 10, i16 8, i16 3, i16 1, i16 13, i16 4, i16 3, i16 1, i16 6, i16 1, i16 3, i16 5, i16 2, i16 1, i16 2, i16 17, i16 16, i16 5, i16 2, i16 16, i16 6, i16 1, i16 4, i16 2, i16 1, i16 3, i16 3, i16 6, i16 8, i16 5, i16 11, i16 11, i16 1, i16 3, i16 3, i16 2, i16 4, i16 6, i16 10, i16 9, i16 5, i16 7, i16 4, i16 7, i16 4, i16 7, i16 1, i16 1, i16 4, i16 2, i16 1, i16 3, i16 6, i16 8, i16 7, i16 1, i16 6, i16 11, i16 5, i16 5, i16 3, i16 24, i16 9, i16 4, i16 2, i16 7, i16 13, i16 5, i16 1, i16 8, i16 82, i16 16, i16 61, i16 1, i16 1, i16 1, i16 4, i16 2, i16 2, i16 16, i16 10, i16 3, i16 8, i16 1, i16 1, i16 6, i16 4, i16 2, i16 1, i16 3, i16 1, i16 1, i16 1, i16 4, i16 3, i16 8, i16 4, i16 2, i16 2, i16 1, i16 1, i16 1, i16 1, i16 1, i16 6, i16 3, i16 5, i16 1, i16 1, i16 4, i16 6, i16 9, i16 2, i16 1, i16 1, i16 1, i16 2, i16 1, i16 7, i16 2, i16 1, i16 6, i16 1, i16 5, i16 4, i16 4, i16 3, i16 1, i16 8, i16 1, i16 3, i16 3, i16 1, i16 3, i16 2, i16 2, i16 2, i16 2, i16 3, i16 1, i16 6, i16 1, i16 2, i16 1, i16 2, i16 1, i16 3, i16 7, i16 1, i16 8, i16 2, i16 1, i16 2, i16 1, i16 5, i16 2, i16 5, i16 3, i16 5, i16 10, i16 1, i16 2, i16 1, i16 1, i16 3, i16 2, i16 5, i16 11, i16 3, i16 9, i16 3, i16 5, i16 1, i16 1, i16 5, i16 9, i16 1, i16 2, i16 1, i16 5, i16 7, i16 9, i16 9, i16 8, i16 1, i16 3, i16 3, i16 3, i16 6, i16 8, i16 2, i16 3, i16 2, i16 1, i16 1, i16 32, i16 6, i16 1, i16 2, i16 15, i16 9, i16 3, i16 7, i16 13, i16 1, i16 3, i16 10, i16 13, i16 2, i16 14, i16 1, i16 13, i16 10, i16 2, i16 1, i16 3, i16 10, i16 4, i16 15, i16 2, i16 15, i16 15, i16 10, i16 1, i16 3, i16 9, i16 6, i16 9, i16 32, i16 25, i16 26, i16 47, i16 7, i16 3, i16 2, i16 3, i16 1, i16 6, i16 3, i16 4, i16 3, i16 2, i16 8, i16 5, i16 4, i16 1, i16 9, i16 4, i16 2, i16 2, i16 19, i16 10, i16 6, i16 2, i16 3, i16 8, i16 1, i16 2, i16 2, i16 4, i16 2, i16 1, i16 9, i16 4, i16 4, i16 4, i16 6, i16 4, i16 8, i16 9, i16 2, i16 3, i16 1, i16 1, i16 1, i16 1, i16 3, i16 5, i16 5, i16 1, i16 3, i16 8, i16 4, i16 6, i16 2, i16 1, i16 4, i16 12, i16 1, i16 5, i16 3, i16 7, i16 13, i16 2, i16 5, i16 8, i16 1, i16 6, i16 1, i16 2, i16 5, i16 14, i16 6, i16 1, i16 5, i16 2, i16 4, i16 8, i16 15, i16 5, i16 1, i16 23, i16 6, i16 62, i16 2, i16 10, i16 1, i16 1, i16 8, i16 1, i16 2, i16 2, i16 10, i16 4, i16 2, i16 2, i16 9, i16 2, i16 1, i16 1, i16 3, i16 2, i16 3, i16 1, i16 5, i16 3, i16 3, i16 2, i16 1, i16 3, i16 8, i16 1, i16 1, i16 1, i16 11, i16 3, i16 1, i16 1, i16 4, i16 3, i16 7, i16 1, i16 14, i16 1, i16 2, i16 3, i16 12, i16 5, i16 2, i16 5, i16 1, i16 6, i16 7, i16 5, i16 7, i16 14, i16 11, i16 1, i16 3, i16 1, i16 8, i16 9, i16 12, i16 2, i16 1, i16 11, i16 8, i16 4, i16 4, i16 2, i16 6, i16 10, i16 9, i16 13, i16 1, i16 1, i16 3, i16 1, i16 5, i16 1, i16 3, i16 2, i16 4, i16 4, i16 1, i16 18, i16 2, i16 3, i16 14, i16 11, i16 4, i16 29, i16 4, i16 2, i16 7, i16 1, i16 3, i16 13, i16 9, i16 2, i16 2, i16 5, i16 3, i16 5, i16 20, i16 7, i16 16, i16 8, i16 5, i16 72, i16 34, i16 6, i16 4, i16 22, i16 12, i16 12, i16 28, i16 45, i16 36, i16 9, i16 7, i16 39, i16 9, i16 191, i16 1, i16 1, i16 1, i16 4, i16 11, i16 8, i16 4, i16 9, i16 2, i16 3, i16 22, i16 1, i16 1, i16 1, i16 1, i16 4, i16 17, i16 1, i16 7, i16 7, i16 1, i16 11, i16 31, i16 10, i16 2, i16 4, i16 8, i16 2, i16 3, i16 2, i16 1, i16 4, i16 2, i16 16, i16 4, i16 32, i16 2, i16 3, i16 19, i16 13, i16 4, i16 9, i16 1, i16 5, i16 2, i16 14, i16 8, i16 1, i16 1, i16 3, i16 6, i16 19, i16 6, i16 5, i16 1, i16 16, i16 6, i16 2, i16 10, i16 8, i16 5, i16 1, i16 2, i16 3, i16 1, i16 5, i16 5, i16 1, i16 11, i16 6, i16 6, i16 1, i16 3, i16 3, i16 2, i16 6, i16 3, i16 8, i16 1, i16 1, i16 4, i16 10, i16 7, i16 5, i16 7, i16 7, i16 5, i16 8, i16 9, i16 2, i16 1, i16 3, i16 4, i16 1, i16 1, i16 3, i16 1, i16 3, i16 3, i16 2, i16 6, i16 16, i16 1, i16 4, i16 6, i16 3, i16 1, i16 10, i16 6, i16 1, i16 3, i16 15, i16 2, i16 9, i16 2, i16 10, i16 25, i16 13, i16 9, i16 16, i16 6, i16 2, i16 2, i16 10, i16 11, i16 4, i16 3, i16 9, i16 1, i16 2, i16 6, i16 6, i16 5, i16 4, i16 30, i16 40, i16 1, i16 10, i16 7, i16 12, i16 14, i16 33, i16 6, i16 3, i16 6, i16 7, i16 3, i16 1, i16 3, i16 1, i16 11, i16 14, i16 4, i16 9, i16 5, i16 12, i16 11, i16 49, i16 18, i16 51, i16 31, i16 140, i16 31, i16 2, i16 2, i16 1, i16 5, i16 1, i16 8, i16 1, i16 10, i16 1, i16 4, i16 4, i16 3, i16 24, i16 1, i16 10, i16 1, i16 3, i16 6, i16 6, i16 16, i16 3, i16 4, i16 5, i16 2, i16 1, i16 4, i16 2, i16 57, i16 10, i16 6, i16 22, i16 2, i16 22, i16 3, i16 7, i16 22, i16 6, i16 10, i16 11, i16 36, i16 18, i16 16, i16 33, i16 36, i16 2, i16 5, i16 5, i16 1, i16 1, i16 1, i16 4, i16 10, i16 1, i16 4, i16 13, i16 2, i16 7, i16 5, i16 2, i16 9, i16 3, i16 4, i16 1, i16 7, i16 43, i16 3, i16 7, i16 3, i16 9, i16 14, i16 7, i16 9, i16 1, i16 11, i16 1, i16 1, i16 3, i16 7, i16 4, i16 18, i16 13, i16 1, i16 14, i16 1, i16 3, i16 6, i16 10, i16 73, i16 2, i16 2, i16 30, i16 6, i16 1, i16 11, i16 18, i16 19, i16 13, i16 22, i16 3, i16 46, i16 42, i16 37, i16 89, i16 7, i16 3, i16 16, i16 34, i16 2, i16 2, i16 3, i16 9, i16 1, i16 7, i16 1, i16 1, i16 1, i16 2, i16 2, i16 4, i16 10, i16 7, i16 3, i16 10, i16 3, i16 9, i16 5, i16 28, i16 9, i16 2, i16 6, i16 13, i16 7, i16 3, i16 1, i16 3, i16 10, i16 2, i16 7, i16 2, i16 11, i16 3, i16 6, i16 21, i16 54, i16 85, i16 2, i16 1, i16 4, i16 2, i16 2, i16 1, i16 39, i16 3, i16 21, i16 2, i16 2, i16 5, i16 1, i16 1, i16 1, i16 4, i16 1, i16 1, i16 3, i16 4, i16 15, i16 1, i16 3, i16 2, i16 4, i16 4, i16 2, i16 3, i16 8, i16 2, i16 20, i16 1, i16 8, i16 7, i16 13, i16 4, i16 1, i16 26, i16 6, i16 2, i16 9, i16 34, i16 4, i16 21, i16 52, i16 10, i16 4, i16 4, i16 1, i16 5, i16 12, i16 2, i16 11, i16 1, i16 7, i16 2, i16 30, i16 12, i16 44, i16 2, i16 30, i16 1, i16 1, i16 3, i16 6, i16 16, i16 9, i16 17, i16 39, i16 82, i16 2, i16 2, i16 24, i16 7, i16 1, i16 7, i16 3, i16 16, i16 9, i16 14, i16 44, i16 2, i16 1, i16 2, i16 1, i16 2, i16 3, i16 5, i16 2, i16 4, i16 1, i16 6, i16 7, i16 5, i16 3, i16 2, i16 6, i16 1, i16 11, i16 5, i16 11, i16 2, i16 1, i16 18, i16 19, i16 8, i16 1, i16 3, i16 24, i16 29, i16 2, i16 1, i16 3, i16 5, i16 2, i16 2, i16 1, i16 13, i16 6, i16 5, i16 1, i16 46, i16 11, i16 3, i16 5, i16 1, i16 1, i16 5, i16 8, i16 2, i16 10, i16 6, i16 12, i16 6, i16 3, i16 7, i16 11, i16 2, i16 4, i16 16, i16 13, i16 2, i16 5, i16 1, i16 1, i16 2, i16 2, i16 5, i16 2, i16 28, i16 5, i16 2, i16 23, i16 10, i16 8, i16 4, i16 4, i16 22, i16 39, i16 95, i16 38, i16 8, i16 14, i16 9, i16 5, i16 1, i16 13, i16 5, i16 4, i16 3, i16 13, i16 12, i16 11, i16 1, i16 9, i16 1, i16 27, i16 37, i16 2, i16 5, i16 4, i16 4, i16 63, i16 211, i16 95, i16 2, i16 2, i16 2, i16 1, i16 3, i16 5, i16 2, i16 1, i16 1, i16 2, i16 2, i16 1, i16 1, i16 1, i16 3, i16 2, i16 4, i16 1, i16 2, i16 1, i16 1, i16 5, i16 2, i16 2, i16 1, i16 1, i16 2, i16 3, i16 1, i16 3, i16 1, i16 1, i16 1, i16 3, i16 1, i16 4, i16 2, i16 1, i16 3, i16 6, i16 1, i16 1, i16 3, i16 7, i16 15, i16 5, i16 3, i16 2, i16 5, i16 3, i16 9, i16 11, i16 4, i16 2, i16 22, i16 1, i16 6, i16 3, i16 8, i16 7, i16 1, i16 4, i16 28, i16 4, i16 16, i16 3, i16 3, i16 25, i16 4, i16 4, i16 27, i16 27, i16 1, i16 4, i16 1, i16 2, i16 2, i16 7, i16 1, i16 3, i16 5, i16 2, i16 28, i16 8, i16 2, i16 14, i16 1, i16 8, i16 6, i16 16, i16 25, i16 3, i16 3, i16 3, i16 14, i16 3, i16 3, i16 1, i16 1, i16 2, i16 1, i16 4, i16 6, i16 3, i16 8, i16 4, i16 1, i16 1, i16 1, i16 2, i16 3, i16 6, i16 10, i16 6, i16 2, i16 3, i16 18, i16 3, i16 2, i16 5, i16 5, i16 4, i16 3, i16 1, i16 5, i16 2, i16 5, i16 4, i16 23, i16 7, i16 6, i16 12, i16 6, i16 4, i16 17, i16 11, i16 9, i16 5, i16 1, i16 1, i16 10, i16 5, i16 12, i16 1, i16 1, i16 11, i16 26, i16 33, i16 7, i16 3, i16 6, i16 1, i16 17, i16 7, i16 1, i16 5, i16 12, i16 1, i16 11, i16 2, i16 4, i16 1, i16 8, i16 14, i16 17, i16 23, i16 1, i16 2, i16 1, i16 7, i16 8, i16 16, i16 11, i16 9, i16 6, i16 5, i16 2, i16 6, i16 4, i16 16, i16 2, i16 8, i16 14, i16 1, i16 11, i16 8, i16 9, i16 1, i16 1, i16 1, i16 9, i16 25, i16 4, i16 11, i16 19, i16 7, i16 2, i16 15, i16 2, i16 12, i16 8, i16 52, i16 7, i16 5, i16 19, i16 2, i16 16, i16 4, i16 36, i16 8, i16 1, i16 16, i16 8, i16 24, i16 26, i16 4, i16 6, i16 2, i16 9, i16 5, i16 4, i16 36, i16 3, i16 28, i16 12, i16 25, i16 15, i16 37, i16 27, i16 17, i16 12, i16 59, i16 38, i16 5, i16 32, i16 127, i16 1, i16 2, i16 9, i16 17, i16 14, i16 4, i16 1, i16 2, i16 1, i16 1, i16 8, i16 11, i16 50, i16 4, i16 14, i16 2, i16 19, i16 16, i16 4, i16 17, i16 5, i16 4, i16 5, i16 26, i16 12, i16 45, i16 2, i16 23, i16 45, i16 104, i16 30, i16 12, i16 8, i16 3, i16 10, i16 2, i16 2, i16 3, i16 3, i16 1, i16 4, i16 20, i16 7, i16 2, i16 9, i16 6, i16 15, i16 2, i16 20, i16 1, i16 3, i16 16, i16 4, i16 11, i16 15, i16 6, i16 134, i16 2, i16 5, i16 59, i16 1, i16 2, i16 2, i16 2, i16 1, i16 9, i16 17, i16 3, i16 26, i16 137, i16 10, i16 211, i16 59, i16 1, i16 2, i16 4, i16 1, i16 4, i16 1, i16 1, i16 1, i16 2, i16 6, i16 2, i16 3, i16 1, i16 1, i16 2, i16 3, i16 2, i16 3, i16 1, i16 3, i16 4, i16 4, i16 2, i16 3, i16 3, i16 1, i16 4, i16 3, i16 1, i16 7, i16 2, i16 2, i16 3, i16 1, i16 2, i16 1, i16 3, i16 3, i16 3, i16 2, i16 2, i16 3, i16 2, i16 1, i16 3, i16 14, i16 6, i16 1, i16 3, i16 2, i16 9, i16 6, i16 15, i16 27, i16 9, i16 34, i16 145, i16 1, i16 1, i16 2, i16 1, i16 1, i16 1, i16 1, i16 2, i16 1, i16 1, i16 1, i16 1, i16 2, i16 2, i16 2, i16 3, i16 1, i16 2, i16 1, i16 1, i16 1, i16 2, i16 3, i16 5, i16 8, i16 3, i16 5, i16 2, i16 4, i16 1, i16 3, i16 2, i16 2, i16 2, i16 12, i16 4, i16 1, i16 1, i16 1, i16 10, i16 4, i16 5, i16 1, i16 20, i16 4, i16 16, i16 1, i16 15, i16 9, i16 5, i16 12, i16 2, i16 9, i16 2, i16 5, i16 4, i16 2, i16 26, i16 19, i16 7, i16 1, i16 26, i16 4, i16 30, i16 12, i16 15, i16 42, i16 1, i16 6, i16 8, i16 172, i16 1, i16 1, i16 4, i16 2, i16 1, i16 1, i16 11, i16 2, i16 2, i16 4, i16 2, i16 1, i16 2, i16 1, i16 10, i16 8, i16 1, i16 2, i16 1, i16 4, i16 5, i16 1, i16 2, i16 5, i16 1, i16 8, i16 4, i16 1, i16 3, i16 4, i16 2, i16 1, i16 6, i16 2, i16 1, i16 3, i16 4, i16 1, i16 2, i16 1, i16 1, i16 1, i16 1, i16 12, i16 5, i16 7, i16 2, i16 4, i16 3, i16 1, i16 1, i16 1, i16 3, i16 3, i16 6, i16 1, i16 2, i16 2, i16 3, i16 3, i16 3, i16 2, i16 1, i16 2, i16 12, i16 14, i16 11, i16 6, i16 6, i16 4, i16 12, i16 2, i16 8, i16 1, i16 7, i16 10, i16 1, i16 35, i16 7, i16 4, i16 13, i16 15, i16 4, i16 3, i16 23, i16 21, i16 28, i16 52, i16 5, i16 26, i16 5, i16 6, i16 1, i16 7, i16 10, i16 2, i16 7, i16 53, i16 3, i16 2, i16 1, i16 1, i16 1, i16 2, i16 163, i16 532, i16 1, i16 10, i16 11, i16 1, i16 3, i16 3, i16 4, i16 8, i16 2, i16 8, i16 6, i16 2, i16 2, i16 23, i16 22, i16 4, i16 2, i16 2, i16 4, i16 2, i16 1, i16 3, i16 1, i16 3, i16 3, i16 5, i16 9, i16 8, i16 2, i16 1, i16 2, i16 8, i16 1, i16 10, i16 2, i16 12, i16 21, i16 20, i16 15, i16 105, i16 2, i16 3, i16 1, i16 1, i16 3, i16 2, i16 3, i16 1, i16 1, i16 2, i16 5, i16 1, i16 4, i16 15, i16 11, i16 19, i16 1, i16 1, i16 1, i16 1, i16 5, i16 4, i16 5, i16 1, i16 1, i16 2, i16 5, i16 3, i16 5, i16 12, i16 1, i16 2, i16 5, i16 1, i16 11, i16 1, i16 1, i16 15, i16 9, i16 1, i16 4, i16 5, i16 3, i16 26, i16 8, i16 2, i16 1, i16 3, i16 1, i16 1, i16 15, i16 19, i16 2, i16 12, i16 1, i16 2, i16 5, i16 2, i16 7, i16 2, i16 19, i16 2, i16 20, i16 6, i16 26, i16 7, i16 5, i16 2, i16 2, i16 7, i16 34, i16 21, i16 13, i16 70, i16 2, i16 128, i16 1, i16 1, i16 2, i16 1, i16 1, i16 2, i16 1, i16 1, i16 3, i16 2, i16 2, i16 2, i16 15, i16 1, i16 4, i16 1, i16 3, i16 4, i16 42, i16 10, i16 6, i16 1, i16 49, i16 85, i16 8, i16 1, i16 2, i16 1, i16 1, i16 4, i16 4, i16 2, i16 3, i16 6, i16 1, i16 5, i16 7, i16 4, i16 3, i16 211, i16 4, i16 1, i16 2, i16 1, i16 2, i16 5, i16 1, i16 2, i16 4, i16 2, i16 2, i16 6, i16 5, i16 6, i16 10, i16 3, i16 4, i16 48, i16 100, i16 6, i16 2, i16 16, i16 296, i16 5, i16 27, i16 387, i16 2, i16 2, i16 3, i16 7, i16 16, i16 8, i16 5, i16 38, i16 15, i16 39, i16 21, i16 9, i16 10, i16 3, i16 7, i16 59, i16 13, i16 27, i16 21, i16 47, i16 5, i16 21, i16 6], align 16
@_ZZN11ImFontAtlas37GetGlyphRangesChineseSimplifiedCommonEvE11base_ranges = internal global [12 x i16] [i16 32, i16 255, i16 8192, i16 8303, i16 12288, i16 12543, i16 12784, i16 12799, i16 -256, i16 -17, i16 -3, i16 -3], align 16
@_ZZN11ImFontAtlas37GetGlyphRangesChineseSimplifiedCommonEvE11full_ranges = internal global [5013 x i16] zeroinitializer, align 16
@_ZZN11ImFontAtlas22GetGlyphRangesJapaneseEvE32accumulative_offsets_from_0x4E00 = internal constant [2999 x i16] [i16 0, i16 1, i16 2, i16 4, i16 1, i16 1, i16 1, i16 1, i16 2, i16 1, i16 3, i16 3, i16 2, i16 2, i16 1, i16 5, i16 3, i16 5, i16 7, i16 5, i16 6, i16 1, i16 2, i16 1, i16 7, i16 2, i16 6, i16 3, i16 1, i16 8, i16 1, i16 1, i16 4, i16 1, i16 1, i16 18, i16 2, i16 11, i16 2, i16 6, i16 2, i16 1, i16 2, i16 1, i16 5, i16 1, i16 2, i16 1, i16 3, i16 1, i16 2, i16 1, i16 2, i16 3, i16 3, i16 1, i16 1, i16 2, i16 3, i16 1, i16 1, i16 1, i16 12, i16 7, i16 9, i16 1, i16 4, i16 5, i16 1, i16 1, i16 2, i16 1, i16 10, i16 1, i16 1, i16 9, i16 2, i16 2, i16 4, i16 5, i16 6, i16 9, i16 3, i16 1, i16 1, i16 1, i16 1, i16 9, i16 3, i16 18, i16 5, i16 2, i16 2, i16 2, i16 2, i16 1, i16 6, i16 3, i16 7, i16 1, i16 1, i16 1, i16 1, i16 2, i16 2, i16 4, i16 2, i16 1, i16 23, i16 2, i16 10, i16 4, i16 3, i16 5, i16 2, i16 4, i16 10, i16 2, i16 4, i16 13, i16 1, i16 6, i16 1, i16 9, i16 3, i16 1, i16 1, i16 6, i16 6, i16 7, i16 6, i16 3, i16 1, i16 2, i16 11, i16 3, i16 2, i16 2, i16 3, i16 2, i16 15, i16 2, i16 2, i16 5, i16 4, i16 3, i16 6, i16 4, i16 1, i16 2, i16 5, i16 2, i16 12, i16 16, i16 6, i16 13, i16 9, i16 13, i16 2, i16 1, i16 1, i16 7, i16 16, i16 4, i16 7, i16 1, i16 19, i16 1, i16 5, i16 1, i16 2, i16 2, i16 7, i16 7, i16 8, i16 2, i16 6, i16 5, i16 4, i16 9, i16 18, i16 7, i16 4, i16 5, i16 9, i16 13, i16 11, i16 8, i16 15, i16 2, i16 1, i16 1, i16 1, i16 2, i16 1, i16 2, i16 2, i16 1, i16 2, i16 2, i16 8, i16 2, i16 9, i16 3, i16 3, i16 1, i16 1, i16 4, i16 4, i16 1, i16 1, i16 1, i16 4, i16 9, i16 1, i16 4, i16 3, i16 5, i16 5, i16 2, i16 7, i16 5, i16 3, i16 4, i16 8, i16 2, i16 1, i16 13, i16 2, i16 3, i16 3, i16 1, i16 14, i16 1, i16 1, i16 4, i16 5, i16 1, i16 3, i16 6, i16 1, i16 5, i16 2, i16 1, i16 1, i16 3, i16 3, i16 3, i16 3, i16 1, i16 1, i16 2, i16 7, i16 6, i16 6, i16 7, i16 1, i16 4, i16 7, i16 6, i16 1, i16 1, i16 1, i16 1, i16 1, i16 12, i16 3, i16 3, i16 9, i16 5, i16 2, i16 6, i16 1, i16 5, i16 6, i16 1, i16 2, i16 3, i16 18, i16 2, i16 4, i16 14, i16 4, i16 1, i16 3, i16 6, i16 1, i16 1, i16 6, i16 3, i16 5, i16 5, i16 3, i16 2, i16 2, i16 2, i16 2, i16 12, i16 3, i16 1, i16 4, i16 2, i16 3, i16 2, i16 3, i16 11, i16 1, i16 7, i16 4, i16 1, i16 2, i16 1, i16 3, i16 17, i16 1, i16 9, i16 1, i16 24, i16 1, i16 1, i16 4, i16 2, i16 2, i16 4, i16 1, i16 2, i16 7, i16 1, i16 1, i16 1, i16 3, i16 1, i16 2, i16 2, i16 4, i16 15, i16 1, i16 1, i16 2, i16 1, i16 1, i16 2, i16 1, i16 5, i16 2, i16 5, i16 20, i16 2, i16 5, i16 9, i16 1, i16 10, i16 8, i16 7, i16 6, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 6, i16 2, i16 1, i16 2, i16 8, i16 1, i16 1, i16 1, i16 1, i16 5, i16 1, i16 1, i16 3, i16 1, i16 1, i16 1, i16 1, i16 3, i16 1, i16 1, i16 12, i16 4, i16 1, i16 3, i16 1, i16 1, i16 1, i16 1, i16 1, i16 10, i16 3, i16 1, i16 7, i16 5, i16 13, i16 1, i16 2, i16 3, i16 4, i16 6, i16 1, i16 1, i16 30, i16 2, i16 9, i16 9, i16 1, i16 15, i16 38, i16 11, i16 3, i16 1, i16 8, i16 24, i16 7, i16 1, i16 9, i16 8, i16 10, i16 2, i16 1, i16 9, i16 31, i16 2, i16 13, i16 6, i16 2, i16 9, i16 4, i16 49, i16 5, i16 2, i16 15, i16 2, i16 1, i16 10, i16 2, i16 1, i16 1, i16 1, i16 2, i16 2, i16 6, i16 15, i16 30, i16 35, i16 3, i16 14, i16 18, i16 8, i16 1, i16 16, i16 10, i16 28, i16 12, i16 19, i16 45, i16 38, i16 1, i16 3, i16 2, i16 3, i16 13, i16 2, i16 1, i16 7, i16 3, i16 6, i16 5, i16 3, i16 4, i16 3, i16 1, i16 5, i16 7, i16 8, i16 1, i16 5, i16 3, i16 18, i16 5, i16 3, i16 6, i16 1, i16 21, i16 4, i16 24, i16 9, i16 24, i16 40, i16 3, i16 14, i16 3, i16 21, i16 3, i16 2, i16 1, i16 2, i16 4, i16 2, i16 3, i16 1, i16 15, i16 15, i16 6, i16 5, i16 1, i16 1, i16 3, i16 1, i16 5, i16 6, i16 1, i16 9, i16 7, i16 3, i16 3, i16 2, i16 1, i16 4, i16 3, i16 8, i16 21, i16 5, i16 16, i16 4, i16 5, i16 2, i16 10, i16 11, i16 11, i16 3, i16 6, i16 3, i16 2, i16 9, i16 3, i16 6, i16 13, i16 1, i16 2, i16 1, i16 1, i16 1, i16 1, i16 11, i16 12, i16 6, i16 6, i16 1, i16 4, i16 2, i16 6, i16 5, i16 2, i16 1, i16 1, i16 3, i16 3, i16 6, i16 13, i16 3, i16 1, i16 1, i16 5, i16 1, i16 2, i16 3, i16 3, i16 14, i16 2, i16 1, i16 2, i16 2, i16 2, i16 5, i16 1, i16 9, i16 5, i16 1, i16 1, i16 6, i16 12, i16 3, i16 12, i16 3, i16 4, i16 13, i16 2, i16 14, i16 2, i16 8, i16 1, i16 17, i16 5, i16 1, i16 16, i16 4, i16 2, i16 2, i16 21, i16 8, i16 9, i16 6, i16 23, i16 20, i16 12, i16 25, i16 19, i16 9, i16 38, i16 8, i16 3, i16 21, i16 40, i16 25, i16 33, i16 13, i16 4, i16 3, i16 1, i16 4, i16 1, i16 2, i16 4, i16 1, i16 2, i16 5, i16 26, i16 2, i16 1, i16 1, i16 2, i16 1, i16 3, i16 6, i16 2, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 2, i16 3, i16 1, i16 1, i16 1, i16 9, i16 2, i16 3, i16 1, i16 1, i16 1, i16 3, i16 6, i16 3, i16 2, i16 1, i16 1, i16 6, i16 6, i16 1, i16 8, i16 2, i16 2, i16 2, i16 1, i16 4, i16 1, i16 2, i16 3, i16 2, i16 7, i16 3, i16 2, i16 4, i16 1, i16 2, i16 1, i16 2, i16 2, i16 1, i16 1, i16 1, i16 1, i16 1, i16 3, i16 1, i16 2, i16 5, i16 4, i16 10, i16 9, i16 4, i16 9, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 5, i16 3, i16 2, i16 1, i16 6, i16 4, i16 9, i16 6, i16 1, i16 10, i16 2, i16 31, i16 17, i16 8, i16 3, i16 7, i16 5, i16 40, i16 1, i16 7, i16 7, i16 1, i16 6, i16 5, i16 2, i16 10, i16 7, i16 8, i16 4, i16 15, i16 39, i16 25, i16 6, i16 28, i16 47, i16 18, i16 10, i16 7, i16 1, i16 3, i16 1, i16 1, i16 2, i16 1, i16 1, i16 1, i16 3, i16 3, i16 3, i16 1, i16 1, i16 1, i16 3, i16 4, i16 2, i16 1, i16 4, i16 1, i16 3, i16 6, i16 10, i16 7, i16 8, i16 6, i16 2, i16 2, i16 1, i16 3, i16 3, i16 2, i16 5, i16 8, i16 7, i16 9, i16 12, i16 2, i16 15, i16 1, i16 1, i16 4, i16 1, i16 2, i16 1, i16 1, i16 1, i16 3, i16 2, i16 1, i16 3, i16 3, i16 5, i16 6, i16 2, i16 3, i16 2, i16 10, i16 1, i16 4, i16 2, i16 8, i16 1, i16 1, i16 1, i16 11, i16 6, i16 1, i16 21, i16 4, i16 16, i16 3, i16 1, i16 3, i16 1, i16 4, i16 2, i16 3, i16 6, i16 5, i16 1, i16 3, i16 1, i16 1, i16 3, i16 3, i16 4, i16 6, i16 1, i16 1, i16 10, i16 4, i16 2, i16 7, i16 10, i16 4, i16 7, i16 4, i16 2, i16 9, i16 4, i16 3, i16 1, i16 1, i16 1, i16 4, i16 1, i16 8, i16 3, i16 4, i16 1, i16 3, i16 1, i16 6, i16 1, i16 4, i16 2, i16 1, i16 4, i16 7, i16 2, i16 1, i16 8, i16 1, i16 4, i16 5, i16 1, i16 1, i16 2, i16 2, i16 4, i16 6, i16 2, i16 7, i16 1, i16 10, i16 1, i16 1, i16 3, i16 4, i16 11, i16 10, i16 8, i16 21, i16 4, i16 6, i16 1, i16 3, i16 5, i16 2, i16 1, i16 2, i16 28, i16 5, i16 5, i16 2, i16 3, i16 13, i16 1, i16 2, i16 3, i16 1, i16 4, i16 2, i16 1, i16 5, i16 20, i16 3, i16 8, i16 11, i16 1, i16 3, i16 3, i16 3, i16 1, i16 8, i16 10, i16 9, i16 2, i16 10, i16 9, i16 2, i16 3, i16 1, i16 1, i16 2, i16 4, i16 1, i16 8, i16 3, i16 6, i16 1, i16 7, i16 8, i16 6, i16 11, i16 1, i16 4, i16 29, i16 8, i16 4, i16 3, i16 1, i16 2, i16 7, i16 13, i16 1, i16 4, i16 1, i16 6, i16 2, i16 6, i16 12, i16 12, i16 2, i16 20, i16 3, i16 2, i16 3, i16 6, i16 4, i16 8, i16 9, i16 2, i16 7, i16 34, i16 5, i16 1, i16 18, i16 6, i16 1, i16 1, i16 4, i16 4, i16 5, i16 7, i16 9, i16 1, i16 2, i16 2, i16 4, i16 3, i16 4, i16 1, i16 7, i16 2, i16 2, i16 2, i16 6, i16 2, i16 3, i16 25, i16 5, i16 3, i16 6, i16 1, i16 4, i16 6, i16 7, i16 4, i16 2, i16 1, i16 4, i16 2, i16 13, i16 6, i16 4, i16 4, i16 3, i16 1, i16 5, i16 3, i16 4, i16 4, i16 3, i16 2, i16 1, i16 1, i16 4, i16 1, i16 2, i16 1, i16 1, i16 3, i16 1, i16 11, i16 1, i16 6, i16 3, i16 1, i16 7, i16 3, i16 6, i16 2, i16 8, i16 8, i16 6, i16 9, i16 3, i16 4, i16 11, i16 3, i16 2, i16 10, i16 12, i16 2, i16 5, i16 11, i16 1, i16 6, i16 4, i16 5, i16 3, i16 1, i16 8, i16 5, i16 4, i16 6, i16 6, i16 3, i16 5, i16 1, i16 1, i16 3, i16 2, i16 1, i16 2, i16 2, i16 6, i16 17, i16 12, i16 1, i16 10, i16 1, i16 6, i16 12, i16 1, i16 6, i16 6, i16 19, i16 9, i16 6, i16 16, i16 1, i16 13, i16 4, i16 4, i16 15, i16 7, i16 17, i16 6, i16 11, i16 9, i16 15, i16 12, i16 6, i16 7, i16 2, i16 1, i16 2, i16 2, i16 15, i16 9, i16 3, i16 21, i16 4, i16 6, i16 49, i16 18, i16 7, i16 3, i16 2, i16 3, i16 1, i16 6, i16 8, i16 2, i16 2, i16 6, i16 2, i16 9, i16 1, i16 3, i16 6, i16 4, i16 4, i16 1, i16 2, i16 16, i16 2, i16 5, i16 2, i16 1, i16 6, i16 2, i16 3, i16 5, i16 3, i16 1, i16 2, i16 5, i16 1, i16 2, i16 1, i16 9, i16 3, i16 1, i16 8, i16 6, i16 4, i16 8, i16 11, i16 3, i16 1, i16 1, i16 1, i16 1, i16 3, i16 1, i16 13, i16 8, i16 4, i16 1, i16 3, i16 2, i16 2, i16 1, i16 4, i16 1, i16 11, i16 1, i16 5, i16 2, i16 1, i16 5, i16 2, i16 5, i16 8, i16 6, i16 1, i16 1, i16 7, i16 4, i16 3, i16 8, i16 3, i16 2, i16 7, i16 2, i16 1, i16 5, i16 1, i16 5, i16 2, i16 4, i16 7, i16 6, i16 2, i16 8, i16 5, i16 1, i16 11, i16 4, i16 5, i16 3, i16 6, i16 18, i16 1, i16 2, i16 13, i16 3, i16 3, i16 1, i16 21, i16 1, i16 1, i16 4, i16 1, i16 4, i16 1, i16 1, i16 1, i16 8, i16 1, i16 2, i16 2, i16 7, i16 1, i16 2, i16 4, i16 2, i16 2, i16 9, i16 2, i16 1, i16 1, i16 1, i16 4, i16 3, i16 6, i16 3, i16 12, i16 5, i16 1, i16 1, i16 1, i16 5, i16 6, i16 3, i16 2, i16 4, i16 8, i16 2, i16 2, i16 4, i16 2, i16 7, i16 1, i16 8, i16 9, i16 5, i16 2, i16 3, i16 2, i16 1, i16 3, i16 2, i16 13, i16 7, i16 14, i16 6, i16 5, i16 1, i16 1, i16 2, i16 1, i16 4, i16 2, i16 23, i16 2, i16 1, i16 1, i16 6, i16 3, i16 1, i16 4, i16 1, i16 15, i16 3, i16 1, i16 7, i16 3, i16 9, i16 14, i16 1, i16 3, i16 1, i16 4, i16 1, i16 1, i16 5, i16 8, i16 1, i16 3, i16 8, i16 3, i16 8, i16 15, i16 11, i16 4, i16 14, i16 4, i16 4, i16 2, i16 5, i16 5, i16 1, i16 7, i16 1, i16 6, i16 14, i16 7, i16 7, i16 8, i16 5, i16 15, i16 4, i16 8, i16 6, i16 5, i16 6, i16 2, i16 1, i16 13, i16 1, i16 20, i16 15, i16 11, i16 9, i16 2, i16 5, i16 6, i16 2, i16 11, i16 2, i16 6, i16 2, i16 5, i16 1, i16 5, i16 8, i16 4, i16 13, i16 19, i16 25, i16 4, i16 1, i16 1, i16 11, i16 1, i16 34, i16 2, i16 5, i16 9, i16 14, i16 6, i16 2, i16 2, i16 6, i16 1, i16 1, i16 14, i16 1, i16 3, i16 14, i16 13, i16 1, i16 6, i16 12, i16 21, i16 14, i16 14, i16 6, i16 32, i16 17, i16 8, i16 32, i16 9, i16 28, i16 1, i16 2, i16 4, i16 11, i16 8, i16 3, i16 1, i16 14, i16 2, i16 5, i16 15, i16 1, i16 1, i16 1, i16 1, i16 3, i16 6, i16 4, i16 1, i16 3, i16 4, i16 11, i16 3, i16 1, i16 1, i16 11, i16 30, i16 1, i16 5, i16 1, i16 4, i16 1, i16 5, i16 8, i16 1, i16 1, i16 3, i16 2, i16 4, i16 3, i16 17, i16 35, i16 2, i16 6, i16 12, i16 17, i16 3, i16 1, i16 6, i16 2, i16 1, i16 1, i16 12, i16 2, i16 7, i16 3, i16 3, i16 2, i16 1, i16 16, i16 2, i16 8, i16 3, i16 6, i16 5, i16 4, i16 7, i16 3, i16 3, i16 8, i16 1, i16 9, i16 8, i16 5, i16 1, i16 2, i16 1, i16 3, i16 2, i16 8, i16 1, i16 2, i16 9, i16 12, i16 1, i16 1, i16 2, i16 3, i16 8, i16 3, i16 24, i16 12, i16 4, i16 3, i16 7, i16 5, i16 8, i16 3, i16 3, i16 3, i16 3, i16 3, i16 3, i16 1, i16 23, i16 10, i16 3, i16 1, i16 2, i16 2, i16 6, i16 3, i16 1, i16 16, i16 1, i16 16, i16 22, i16 3, i16 10, i16 4, i16 11, i16 6, i16 9, i16 7, i16 7, i16 3, i16 6, i16 2, i16 2, i16 2, i16 4, i16 10, i16 2, i16 1, i16 1, i16 2, i16 8, i16 7, i16 1, i16 6, i16 4, i16 1, i16 3, i16 3, i16 3, i16 5, i16 10, i16 12, i16 12, i16 2, i16 3, i16 12, i16 8, i16 15, i16 1, i16 1, i16 16, i16 6, i16 6, i16 1, i16 5, i16 9, i16 11, i16 4, i16 11, i16 4, i16 2, i16 6, i16 12, i16 1, i16 17, i16 5, i16 13, i16 1, i16 4, i16 9, i16 5, i16 1, i16 11, i16 2, i16 1, i16 8, i16 1, i16 5, i16 7, i16 28, i16 8, i16 3, i16 5, i16 10, i16 2, i16 17, i16 3, i16 38, i16 22, i16 1, i16 2, i16 18, i16 12, i16 10, i16 4, i16 38, i16 18, i16 1, i16 4, i16 44, i16 19, i16 4, i16 1, i16 8, i16 4, i16 1, i16 12, i16 1, i16 4, i16 31, i16 12, i16 1, i16 14, i16 7, i16 75, i16 7, i16 5, i16 10, i16 6, i16 6, i16 13, i16 3, i16 2, i16 11, i16 11, i16 3, i16 2, i16 5, i16 28, i16 15, i16 6, i16 18, i16 18, i16 5, i16 6, i16 4, i16 3, i16 16, i16 1, i16 7, i16 18, i16 7, i16 36, i16 3, i16 5, i16 3, i16 1, i16 7, i16 1, i16 9, i16 1, i16 10, i16 7, i16 2, i16 4, i16 2, i16 6, i16 2, i16 9, i16 7, i16 4, i16 3, i16 32, i16 12, i16 3, i16 7, i16 10, i16 2, i16 23, i16 16, i16 3, i16 1, i16 12, i16 3, i16 31, i16 4, i16 11, i16 1, i16 3, i16 8, i16 9, i16 5, i16 1, i16 30, i16 15, i16 6, i16 12, i16 3, i16 2, i16 2, i16 11, i16 19, i16 9, i16 14, i16 2, i16 6, i16 2, i16 3, i16 19, i16 13, i16 17, i16 5, i16 3, i16 3, i16 25, i16 3, i16 14, i16 1, i16 1, i16 1, i16 36, i16 1, i16 3, i16 2, i16 19, i16 3, i16 13, i16 36, i16 9, i16 13, i16 31, i16 6, i16 4, i16 16, i16 34, i16 2, i16 5, i16 4, i16 2, i16 3, i16 3, i16 5, i16 1, i16 1, i16 1, i16 4, i16 3, i16 1, i16 17, i16 3, i16 2, i16 3, i16 5, i16 3, i16 1, i16 3, i16 2, i16 3, i16 5, i16 6, i16 3, i16 12, i16 11, i16 1, i16 3, i16 1, i16 2, i16 26, i16 7, i16 12, i16 7, i16 2, i16 14, i16 3, i16 3, i16 7, i16 7, i16 11, i16 25, i16 25, i16 28, i16 16, i16 4, i16 36, i16 1, i16 2, i16 1, i16 6, i16 2, i16 1, i16 9, i16 3, i16 27, i16 17, i16 4, i16 3, i16 4, i16 13, i16 4, i16 1, i16 3, i16 2, i16 2, i16 1, i16 10, i16 4, i16 2, i16 4, i16 6, i16 3, i16 8, i16 2, i16 1, i16 18, i16 1, i16 1, i16 24, i16 2, i16 2, i16 4, i16 33, i16 2, i16 3, i16 63, i16 7, i16 1, i16 6, i16 40, i16 7, i16 3, i16 4, i16 4, i16 2, i16 4, i16 15, i16 18, i16 1, i16 16, i16 1, i16 1, i16 11, i16 2, i16 41, i16 14, i16 1, i16 3, i16 18, i16 13, i16 3, i16 2, i16 4, i16 16, i16 2, i16 17, i16 7, i16 15, i16 24, i16 7, i16 18, i16 13, i16 44, i16 2, i16 2, i16 3, i16 6, i16 1, i16 1, i16 7, i16 5, i16 1, i16 7, i16 1, i16 4, i16 3, i16 3, i16 5, i16 10, i16 8, i16 2, i16 3, i16 1, i16 8, i16 1, i16 1, i16 27, i16 4, i16 2, i16 1, i16 12, i16 1, i16 2, i16 1, i16 10, i16 6, i16 1, i16 6, i16 7, i16 5, i16 2, i16 3, i16 7, i16 11, i16 5, i16 11, i16 3, i16 6, i16 6, i16 2, i16 3, i16 15, i16 4, i16 9, i16 1, i16 1, i16 2, i16 1, i16 2, i16 11, i16 2, i16 8, i16 12, i16 8, i16 5, i16 4, i16 2, i16 3, i16 1, i16 5, i16 2, i16 2, i16 1, i16 14, i16 1, i16 12, i16 11, i16 4, i16 1, i16 11, i16 17, i16 17, i16 4, i16 3, i16 2, i16 5, i16 5, i16 7, i16 3, i16 1, i16 5, i16 9, i16 9, i16 8, i16 2, i16 5, i16 6, i16 6, i16 13, i16 13, i16 2, i16 1, i16 2, i16 6, i16 1, i16 2, i16 2, i16 49, i16 4, i16 9, i16 1, i16 2, i16 10, i16 16, i16 7, i16 8, i16 4, i16 3, i16 2, i16 23, i16 4, i16 58, i16 3, i16 29, i16 1, i16 14, i16 19, i16 19, i16 11, i16 11, i16 2, i16 7, i16 5, i16 1, i16 3, i16 4, i16 6, i16 2, i16 18, i16 5, i16 12, i16 12, i16 17, i16 17, i16 3, i16 3, i16 2, i16 4, i16 1, i16 6, i16 2, i16 3, i16 4, i16 3, i16 1, i16 1, i16 1, i16 1, i16 5, i16 1, i16 1, i16 9, i16 1, i16 3, i16 1, i16 3, i16 6, i16 1, i16 8, i16 1, i16 1, i16 2, i16 6, i16 4, i16 14, i16 3, i16 1, i16 4, i16 11, i16 4, i16 1, i16 3, i16 32, i16 1, i16 2, i16 4, i16 13, i16 4, i16 1, i16 2, i16 4, i16 2, i16 1, i16 3, i16 1, i16 11, i16 1, i16 4, i16 2, i16 1, i16 4, i16 4, i16 6, i16 3, i16 5, i16 1, i16 6, i16 5, i16 7, i16 6, i16 3, i16 23, i16 3, i16 5, i16 3, i16 5, i16 3, i16 3, i16 13, i16 3, i16 9, i16 10, i16 1, i16 12, i16 10, i16 2, i16 3, i16 18, i16 13, i16 7, i16 160, i16 52, i16 4, i16 2, i16 2, i16 3, i16 2, i16 14, i16 5, i16 4, i16 12, i16 4, i16 6, i16 4, i16 1, i16 20, i16 4, i16 11, i16 6, i16 2, i16 12, i16 27, i16 1, i16 4, i16 1, i16 2, i16 2, i16 7, i16 4, i16 5, i16 2, i16 28, i16 3, i16 7, i16 25, i16 8, i16 3, i16 19, i16 3, i16 6, i16 10, i16 2, i16 2, i16 1, i16 10, i16 2, i16 5, i16 4, i16 1, i16 3, i16 4, i16 1, i16 5, i16 3, i16 2, i16 6, i16 9, i16 3, i16 6, i16 2, i16 16, i16 3, i16 3, i16 16, i16 4, i16 5, i16 5, i16 3, i16 2, i16 1, i16 2, i16 16, i16 15, i16 8, i16 2, i16 6, i16 21, i16 2, i16 4, i16 1, i16 22, i16 5, i16 8, i16 1, i16 1, i16 21, i16 11, i16 2, i16 1, i16 11, i16 11, i16 19, i16 13, i16 12, i16 4, i16 2, i16 3, i16 2, i16 3, i16 6, i16 1, i16 8, i16 11, i16 1, i16 4, i16 2, i16 9, i16 5, i16 2, i16 1, i16 11, i16 2, i16 9, i16 1, i16 1, i16 2, i16 14, i16 31, i16 9, i16 3, i16 4, i16 21, i16 14, i16 4, i16 8, i16 1, i16 7, i16 2, i16 2, i16 2, i16 5, i16 1, i16 4, i16 20, i16 3, i16 3, i16 4, i16 10, i16 1, i16 11, i16 9, i16 8, i16 2, i16 1, i16 4, i16 5, i16 14, i16 12, i16 14, i16 2, i16 17, i16 9, i16 6, i16 31, i16 4, i16 14, i16 1, i16 20, i16 13, i16 26, i16 5, i16 2, i16 7, i16 3, i16 6, i16 13, i16 2, i16 4, i16 2, i16 19, i16 6, i16 2, i16 2, i16 18, i16 9, i16 3, i16 5, i16 12, i16 12, i16 14, i16 4, i16 6, i16 2, i16 3, i16 6, i16 9, i16 5, i16 22, i16 4, i16 5, i16 25, i16 6, i16 4, i16 8, i16 5, i16 2, i16 6, i16 27, i16 2, i16 35, i16 2, i16 16, i16 3, i16 7, i16 8, i16 8, i16 6, i16 6, i16 5, i16 9, i16 17, i16 2, i16 20, i16 6, i16 19, i16 2, i16 13, i16 3, i16 1, i16 1, i16 1, i16 4, i16 17, i16 12, i16 2, i16 14, i16 7, i16 1, i16 4, i16 18, i16 12, i16 38, i16 33, i16 2, i16 10, i16 1, i16 1, i16 2, i16 13, i16 14, i16 17, i16 11, i16 50, i16 6, i16 33, i16 20, i16 26, i16 74, i16 16, i16 23, i16 45, i16 50, i16 13, i16 38, i16 33, i16 6, i16 6, i16 7, i16 4, i16 4, i16 2, i16 1, i16 3, i16 2, i16 5, i16 8, i16 7, i16 8, i16 9, i16 3, i16 11, i16 21, i16 9, i16 13, i16 1, i16 3, i16 10, i16 6, i16 7, i16 1, i16 2, i16 2, i16 18, i16 5, i16 5, i16 1, i16 9, i16 9, i16 2, i16 68, i16 9, i16 19, i16 13, i16 2, i16 5, i16 1, i16 4, i16 4, i16 7, i16 4, i16 13, i16 3, i16 9, i16 10, i16 21, i16 17, i16 3, i16 26, i16 2, i16 1, i16 5, i16 2, i16 4, i16 5, i16 4, i16 1, i16 7, i16 4, i16 7, i16 3, i16 4, i16 2, i16 1, i16 6, i16 1, i16 1, i16 20, i16 4, i16 1, i16 9, i16 2, i16 2, i16 1, i16 3, i16 3, i16 2, i16 3, i16 2, i16 1, i16 1, i16 1, i16 20, i16 2, i16 3, i16 1, i16 6, i16 2, i16 3, i16 6, i16 2, i16 4, i16 8, i16 1, i16 3, i16 2, i16 10, i16 3, i16 5, i16 3, i16 4, i16 4, i16 3, i16 4, i16 16, i16 1, i16 6, i16 1, i16 10, i16 2, i16 4, i16 2, i16 1, i16 1, i16 2, i16 10, i16 11, i16 2, i16 2, i16 3, i16 1, i16 24, i16 31, i16 4, i16 10, i16 10, i16 2, i16 5, i16 12, i16 16, i16 164, i16 15, i16 4, i16 16, i16 7, i16 9, i16 15, i16 19, i16 17, i16 1, i16 2, i16 1, i16 1, i16 5, i16 1, i16 1, i16 1, i16 1, i16 1, i16 3, i16 1, i16 4, i16 3, i16 1, i16 3, i16 1, i16 3, i16 1, i16 2, i16 1, i16 1, i16 3, i16 3, i16 7, i16 2, i16 8, i16 1, i16 2, i16 2, i16 2, i16 1, i16 3, i16 4, i16 3, i16 7, i16 8, i16 12, i16 92, i16 2, i16 10, i16 3, i16 1, i16 3, i16 14, i16 5, i16 25, i16 16, i16 42, i16 4, i16 7, i16 7, i16 4, i16 2, i16 21, i16 5, i16 27, i16 26, i16 27, i16 21, i16 25, i16 30, i16 31, i16 2, i16 1, i16 5, i16 13, i16 3, i16 22, i16 5, i16 6, i16 6, i16 11, i16 9, i16 12, i16 1, i16 5, i16 9, i16 7, i16 5, i16 5, i16 22, i16 60, i16 3, i16 5, i16 13, i16 1, i16 1, i16 8, i16 1, i16 1, i16 3, i16 3, i16 2, i16 1, i16 9, i16 3, i16 3, i16 18, i16 4, i16 1, i16 2, i16 3, i16 7, i16 6, i16 3, i16 1, i16 2, i16 3, i16 9, i16 1, i16 3, i16 1, i16 3, i16 2, i16 1, i16 3, i16 1, i16 1, i16 1, i16 2, i16 1, i16 11, i16 3, i16 1, i16 6, i16 9, i16 1, i16 3, i16 2, i16 3, i16 1, i16 2, i16 1, i16 5, i16 1, i16 1, i16 4, i16 3, i16 4, i16 1, i16 2, i16 2, i16 4, i16 4, i16 1, i16 7, i16 2, i16 1, i16 2, i16 2, i16 3, i16 5, i16 13, i16 18, i16 3, i16 4, i16 14, i16 9, i16 9, i16 4, i16 16, i16 3, i16 7, i16 5, i16 8, i16 2, i16 6, i16 48, i16 28, i16 3, i16 1, i16 1, i16 4, i16 2, i16 14, i16 8, i16 2, i16 9, i16 2, i16 1, i16 15, i16 2, i16 4, i16 3, i16 2, i16 10, i16 16, i16 12, i16 8, i16 7, i16 1, i16 1, i16 3, i16 1, i16 1, i16 1, i16 2, i16 7, i16 4, i16 1, i16 6, i16 4, i16 38, i16 39, i16 16, i16 23, i16 7, i16 15, i16 15, i16 3, i16 2, i16 12, i16 7, i16 21, i16 37, i16 27, i16 6, i16 5, i16 4, i16 8, i16 2, i16 10, i16 8, i16 8, i16 6, i16 5, i16 1, i16 2, i16 1, i16 3, i16 24, i16 1, i16 16, i16 17, i16 9, i16 23, i16 10, i16 17, i16 6, i16 1, i16 51, i16 55, i16 44, i16 13, i16 294, i16 9, i16 3, i16 6, i16 2, i16 4, i16 2, i16 2, i16 15, i16 1, i16 1, i16 1, i16 13, i16 21, i16 17, i16 68, i16 14, i16 8, i16 9, i16 4, i16 1, i16 4, i16 9, i16 3, i16 11, i16 7, i16 1, i16 1, i16 1, i16 5, i16 6, i16 3, i16 2, i16 1, i16 1, i16 1, i16 2, i16 3, i16 8, i16 1, i16 2, i16 2, i16 4, i16 1, i16 5, i16 5, i16 2, i16 1, i16 4, i16 3, i16 7, i16 13, i16 4, i16 1, i16 4, i16 1, i16 3, i16 1, i16 1, i16 1, i16 5, i16 5, i16 10, i16 1, i16 6, i16 1, i16 5, i16 2, i16 1, i16 5, i16 2, i16 4, i16 1, i16 4, i16 5, i16 7, i16 3, i16 18, i16 2, i16 9, i16 11, i16 32, i16 4, i16 3, i16 3, i16 2, i16 4, i16 7, i16 11, i16 16, i16 9, i16 11, i16 8, i16 13, i16 38, i16 32, i16 8, i16 4, i16 2, i16 1, i16 1, i16 2, i16 1, i16 2, i16 4, i16 4, i16 1, i16 1, i16 1, i16 4, i16 1, i16 21, i16 3, i16 11, i16 1, i16 16, i16 1, i16 1, i16 6, i16 1, i16 3, i16 2, i16 4, i16 9, i16 8, i16 57, i16 7, i16 44, i16 1, i16 3, i16 3, i16 13, i16 3, i16 10, i16 1, i16 1, i16 7, i16 5, i16 2, i16 7, i16 21, i16 47, i16 63, i16 3, i16 15, i16 4, i16 7, i16 1, i16 16, i16 1, i16 1, i16 2, i16 8, i16 2, i16 3, i16 42, i16 15, i16 4, i16 1, i16 29, i16 7, i16 22, i16 10, i16 3, i16 78, i16 16, i16 12, i16 20, i16 18, i16 4, i16 67, i16 11, i16 5, i16 1, i16 3, i16 15, i16 6, i16 21, i16 31, i16 32, i16 27, i16 18, i16 13, i16 71, i16 35, i16 5, i16 142, i16 4, i16 10, i16 1, i16 2, i16 50, i16 19, i16 33, i16 16, i16 35, i16 37, i16 16, i16 19, i16 27, i16 7, i16 1, i16 133, i16 19, i16 1, i16 4, i16 8, i16 7, i16 20, i16 1, i16 4, i16 4, i16 1, i16 10, i16 3, i16 1, i16 6, i16 1, i16 2, i16 51, i16 5, i16 40, i16 15, i16 24, i16 43, i16 22928, i16 11, i16 1, i16 13, i16 154, i16 70, i16 3, i16 1, i16 1, i16 7, i16 4, i16 10, i16 1, i16 2, i16 1, i16 1, i16 2, i16 1, i16 2, i16 1, i16 2, i16 2, i16 1, i16 1, i16 2, i16 1, i16 1, i16 1, i16 1, i16 1, i16 2, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 2, i16 1, i16 1, i16 1, i16 3, i16 2, i16 1, i16 1, i16 1, i16 1, i16 2, i16 1, i16 1], align 16
@_ZZN11ImFontAtlas22GetGlyphRangesJapaneseEvE11base_ranges = internal global [10 x i16] [i16 32, i16 255, i16 12288, i16 12543, i16 12784, i16 12799, i16 -256, i16 -17, i16 -3, i16 -3], align 16
@_ZZN11ImFontAtlas22GetGlyphRangesJapaneseEvE11full_ranges = internal global [6009 x i16] zeroinitializer, align 16
@_ZZN11ImFontAtlas22GetGlyphRangesCyrillicEvE6ranges = internal constant [9 x i16] [i16 32, i16 255, i16 1024, i16 1327, i16 11744, i16 11775, i16 -22976, i16 -22881, i16 0], align 16
@_ZZN11ImFontAtlas18GetGlyphRangesThaiEvE6ranges = internal constant [7 x i16] [i16 32, i16 255, i16 8208, i16 8286, i16 3584, i16 3711, i16 0], align 2
@_ZZN11ImFontAtlas24GetGlyphRangesVietnameseEvE6ranges = internal constant [17 x i16] [i16 32, i16 255, i16 258, i16 259, i16 272, i16 273, i16 296, i16 297, i16 360, i16 361, i16 416, i16 417, i16 431, i16 432, i16 7840, i16 7929, i16 0], align 16
@__const._ZN6ImFont16BuildLookupTableEv.fallback_chars = private unnamed_addr constant [3 x i16] [i16 -3, i16 63, i16 32], align 2
@__const._ZN6ImFont16BuildLookupTableEv.ellipsis_chars = private unnamed_addr constant [2 x i16] [i16 8230, i16 133], align 2
@__const._ZN6ImFont16BuildLookupTableEv.dots_chars = private unnamed_addr constant [2 x i16] [i16 46, i16 -242], align 2
@.str.3 = private unnamed_addr constant [5 x i8] c"ttcf\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c"typ1\00", align 1
@.str.5 = private unnamed_addr constant [5 x i8] c"OTTO\00", align 1
@.str.6 = private unnamed_addr constant [5 x i8] c"true\00", align 1
@.str.7 = private unnamed_addr constant [5 x i8] c"cmap\00", align 1
@.str.8 = private unnamed_addr constant [5 x i8] c"loca\00", align 1
@.str.9 = private unnamed_addr constant [5 x i8] c"head\00", align 1
@.str.10 = private unnamed_addr constant [5 x i8] c"glyf\00", align 1
@.str.11 = private unnamed_addr constant [5 x i8] c"hhea\00", align 1
@.str.12 = private unnamed_addr constant [5 x i8] c"hmtx\00", align 1
@.str.13 = private unnamed_addr constant [5 x i8] c"kern\00", align 1
@.str.14 = private unnamed_addr constant [5 x i8] c"GPOS\00", align 1
@.str.15 = private unnamed_addr constant [5 x i8] c"CFF \00", align 1
@.str.16 = private unnamed_addr constant [5 x i8] c"maxp\00", align 1
@__const._ZL22stbtt__GetGlyphShapeTTPK14stbtt_fontinfoiPP12stbtt_vertex.mtx = private unnamed_addr constant [6 x float] [float 1.000000e+00, float 0.000000e+00, float 0.000000e+00, float 1.000000e+00, float 0.000000e+00, float 0.000000e+00], align 16
@_ZL34FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS = internal constant [3295 x i8] c"..-         -XXXXXXX-    X    -           X           -XXXXXXX          -          XXXXXXX-     XX          - XX       XX ..-         -X.....X-   X.X   -          X.X          -X.....X          -          X.....X-    X..X         -X..X     X..X---         -XXX.XXX-  X...X  -         X...X         -X....X           -           X....X-    X..X         -X...X   X...XX           -  X.X  - X.....X -        X.....X        -X...X            -            X...X-    X..X         - X...X X...X XX          -  X.X  -X.......X-       X.......X       -X..X.X           -           X.X..X-    X..X         -  X...X...X  X.X         -  X.X  -XXXX.XXXX-       XXXX.XXXX       -X.X X.X          -          X.X X.X-    X..XXX       -   X.....X   X..X        -  X.X  -   X.X   -          X.X          -XX   X.X         -         X.X   XX-    X..X..XXX    -    X...X    X...X       -  X.X  -   X.X   -    XX    X.X    XX    -      X.X        -        X.X      -    X..X..X..XX  -     X.X     X....X      -  X.X  -   X.X   -   X.X    X.X    X.X   -       X.X       -       X.X       -    X..X..X..X.X -    X...X    X.....X     -  X.X  -   X.X   -  X..X    X.X    X..X  -        X.X      -      X.X        -XXX X..X..X..X..X-   X.....X   X......X    -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -         X.X   XX-XX   X.X         -X..XX........X..X-  X...X...X  X.......X   -  X.X  -   X.X   -X.....................X-          X.X X.X-X.X X.X          -X...X...........X- X...X X...X X........X  -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -           X.X..X-X..X.X           - X..............X-X...X   X...XX.........X -XXX.XXX-   X.X   -  X..X    X.X    X..X  -            X...X-X...X            -  X.............X-X..X     X..XX..........X-X.....X-   X.X   -   X.X    X.X    X.X   -           X....X-X....X           -  X.............X- XX       XX X......XXXXX-XXXXXXX-   X.X   -    XX    X.X    XX    -          X.....X-X.....X          -   X............X--------------X...X..X    ---------   X.X   -          X.X          -          XXXXXXX-XXXXXXX          -   X...........X -             X..X X..X   -       -XXXX.XXXX-       XXXX.XXXX       -------------------------------------    X..........X -             X.X  X..X   -       -X.......X-       X.......X       -    XX           XX    -           -    X..........X -             XX    X..X  -       - X.....X -        X.....X        -   X.X           X.X   -           -     X........X  -                   X..X  -       -  X...X  -         X...X         -  X..X           X..X  -           -     X........X  -                    XX   -       -   X.X   -          X.X          - X...XXXXXXXXXXXXX...X -           -     XXXXXXXXXX  -             -------------       -    X    -           X           -X.....................X-           -------------------                                 ----------------------------------- X...XXXXXXXXXXXXX...X -                                                                                                 -  X..X           X..X  -                                                                                                 -   X.X           X.X   -                                                                                                 -    XX           XX    -                                           \00", align 16
@_ZL17stb__barrier_in_b = internal global ptr null, align 8
@_ZL18stb__barrier_out_e = internal global ptr null, align 8
@_ZL18stb__barrier_out_b = internal global ptr null, align 8
@_ZL9stb__dout = internal global ptr null, align 8
@_ZL39proggy_clean_ttf_compressed_data_base85 = internal constant [11981 x i8] c"7])#######hV0qs'/###[),##/l:$#Q6>##5[n42>c-TH`->>#/e>11NNV=Bv(*:.F?uu#(gRU.o0XGH`$vhLG1hxt9?W`#,5LsCp#-i>.r$<$6pD>Lb';9Crc6tgXmKVeU2cD4Eo3R/2*>]b(MC;$jPfY.;h^`IWM9<Lh2TlS+f-s$o6Q<BWH`YiU.xfLq$N;$0iR/GX:U(jcW2p/W*q?-qmnUCI;jHSAiFWM.R*kU@C=GH?a9wp8f$e.-4^Qg1)Q-GL(lf(r/7GrRgwV%MS=C#`8ND>Qo#t'X#(v#Y9w0#1D$CIf;W'#pWUPXOuxXuU(H9M(1<q-UE31#^-V'8IRUo7Qf./L>=Ke$$'5F%)]0^#0X@U.a<r:QLtFsLcL6##lOj)#.Y5<-R&KgLwqJfLgN&;Q?gI^#DY2uLi@^rMl9t=cWq6##weg>$FBjVQTSDgEKnIS7EM9>ZY9w0#L;>>#Mx&4Mvt//L[MkA#W@lK.N'[0#7RL_&#w+F%HtG9M#XL`N&.,GM4Pg;-<nLENhvx>-VsM.M0rJfLH2eTM`*oJMHRC`NkfimM2J,W-jXS:)r0wK#@Fge$U>`w'N7G#$#fB#$E^$#:9:hk+eOe--6x)F7*E%?76%^GMHePW-Z5l'&GiF#$956:rS?dA#fiK:)Yr+`&#0j@'DbG&#^$PG.Ll+DNa<XCMKEV*N)LN/N*b=%Q6pia-Xg8I$<MR&,VdJe$<(7G;Ckl'&hF;;$<_=X(b.RS%%)###MPBuuE1V:v&cX&#2m#(&cV]`k9OhLMbn%s$G2,B$BfD3X*sp5#l,$R#]x_X1xKX%b5U*[r5iMfUo9U`N99hG)tm+/Us9pG)XPu`<0s-)WTt(gCRxIg(%6sfh=ktMKn3j)<6<b5Sk_/0(^]AaN#(p/L>&VZ>1i%h1S9u5o@YaaW$e+b<TWFn/Z:Oh(Cx2$lNEoN^e)#CFY@@I;BOQ*sRwZtZxRcU7uW6CXow0i(?$Q[cjOd[P4d)]>ROPOpxTO7Stwi1::iB1q)C_=dV26J;2,]7op$]uQr@_V7$q^%lQwtuHY]=DX,n3L#0PHDO4f9>dC@O>HBuKPpP*E,N+b3L#lpR/MrTEH.IAQk.a>D[.e;mc.x]Ip.PH^'/aqUO/$1WxLoW0[iLA<QT;5HKD+@qQ'NQ(3_PLhE48R.qAPSwQ0/WK?Z,[x?-J;jQTWA0X@KJ(_Y8N-:/M74:/-ZpKrUss?d#dZq]DAbkU*JqkL+nwX@@47`5>w=4h(9.`GCRUxHPeR`5Mjol(dUWxZa(>STrPkrJiWx`5U7F#.g*jrohGg`cg:lSTvEY/EV_7H4Q9[Z%cnv;JQYZ5q.l7Zeas:HOIZOB?G<Nald$qs]@]L<J7bR*>gv:[7MI2k).'2($5FNP&EQ(,)U]W]+fh18.vsai00);D3@4ku5P?DP8aJt+;qUM]=+b'8@;mViBKx0DE[-auGl8:PJ&Dj+M6OC]O^((##]`0i)drT;-7X`=-H3[igUnPG-NZlo.#k@h#=Ork$m>a>$-?Tm$UV(?#P6YY#'/###xe7q.73rI3*pP/$1>s9)W,JrM7SN]'/4C#v$U`0#V.[0>xQsH$fEmPMgY2u7Kh(G%siIfLSoS+MK2eTM$=5,M8p`A.;_R%#u[K#$x4AG8.kK/HSB==-'Ie/QTtG?-.*^N-4B/ZM_3YlQC7(p7q)&](`6_c)$/*JL(L-^(]$wIM`dPtOdGA,U3:w2M-0<q-]L_?^)1vw'.,MRsqVr.L;aN&#/EgJ)PBc[-f>+WomX2u7lqM2iEumMTcsF?-aT=Z-97UEnXglEn1K-bnEO`guFt(c%=;Am_Qs@jLooI&NX;]0#j4#F14;gl8-GQpgwhrq8'=l_f-b49'UOqkLu7-##oDY2L(te+Mch&gLYtJ,MEtJfLh'x'M=$CS-ZZ%P]8bZ>#S?YY#%Q&q'3^Fw&?D)UDNrocM3A76//oL?#h7gl85[qW/NDOk%16ij;+:1a'iNIdb-ou8.P*w,v5#EI$TWS>Pot-R*H'-SEpA:g)f+O$%%`kA#G=8RMmG1&O`>to8bC]T&$,n.LoO>29sp3dt-52U%VM#q7'DHpg+#Z9%H[K<L%a2E-grWVM3@2=-k22tL]4$##6We'8UJCKE[d_=%wI;'6X-GsLX4j^SgJ$##R*w,vP3wK#iiW&#*h^D&R?jp7+/u&#(AP##XU8c$fSYW-J95_-Dp[g9wcO&#M-h1OcJlc-*vpw0xUX&#OQFKNX@QI'IoPp7nb,QU//MQ&ZDkKP)X<WSVL(68uVl&#c'[0#(s1X&xm$Y%B7*K:eDA323j998GXbA#pwMs-jgD$9QISB-A_(aN4xoFM^@C58D0+Q+q3n0#3U1InDjF682-SjMXJK)(h$hxua_K]ul92%'BOU&#BRRh-slg8KDlr:%L71Ka:.A;%YULjDPmL<LYs8i#XwJOYaKPKc1h:'9Ke,g)b),78=I39B;xiY$bgGw-&.Zi9InXDuYa%G*f2Bq7mn9^#p1vv%#(Wi-;/Z5ho;#2:;%d&#x9v68C5g?ntX0X)pT`;%pB3q7mgGN)3%(P8nTd5L7GeA-GL@+%J3u2:(Yf>et`e;)f#Km8&+DC$I46>#Kr]]u-[=99tts1.qb#q72g1WJO81q+eN'03'eM>&1XxY-caEnOj%2n8)),?ILR5^.Ibn<-X-Mq7[a82Lq:F&#ce+S9wsCK*x`569E8ew'He]h:sI[2LM$[guka3ZRd6:t%IG:;$%YiJ:Nq=?eAw;/:nnDq0(CYcMpG)qLN4$##&J<j$UpK<Q4a1]MupW^-sj_$%[HK%'F####QRZJ::Y3EGl4'@%FkiAOg#p[##O`gukTfBHagL<LHw%q&OV0##F=6/:chIm0@eCP8X]:kFI%hl8hgO@RcBhS-@Qb$%+m=hPDLg*%K8ln(wcf3/'DW-$.lR?n[nCH-eXOONTJlh:.RYF%3'p6sq:UIMA945&^HFS87@$EP2iG<-lCO$%c`uKGD3rC$x0BL8aFn--`ke%#HMP'vh1/R&O_J9'um,.<tx[@%wsJk&bUT2`0uMv7gg#qp/ij.L56'hl;.s5CUrxjOM7-##.l+Au'A&O:-T72L]P`&=;ctp'XScX*rU.>-XTt,%OVU4)S1+R-#dg0/Nn?Ku1^0f$B*P:Rowwm-`0PKjYDDM'3]d39VZHEl4,.j']Pk-M.h^&:0FACm$maq-&sgw0t7/6(^xtk%LuH88Fj-ekm>GA#_>568x6(OFRl-IZp`&b,_P'$M<Jnq79VsJW/mWS*PUiq76;]/NM_>hLbxfc$mj`,O;&%W2m`Zh:/)Uetw:aJ%]K9h:TcF]u_-Sj9,VK3M.*'&0D[Ca]J9gp8,kAW]%(?A%R$f<->Zts'^kn=-^@c4%-pY6qI%J%1IGxfLU9CP8cbPlXv);C=b),<2mOvP8up,UVf3839acAWAW-W?#ao/^#%KYo8fRULNd2.>%m]UK:n%r$'sw]J;5pAoO_#2mO3n,'=H5(etHg*`+RLgv>=4U8guD$I%D:W>-r5V*%j*W:Kvej.Lp$<M-SGZ':+Q_k+uvOSLiEo(<aD/K<CCc`'Lx>'?;++O'>()jLR-^u68PHm8ZFWe+ej8h:9r6L*0//c&iH&R8pRbA#Kjm%upV1g:a_#Ur7FuA#(tRh#.Y5K+@?3<-8m0$PEn;J:rh6?I6uG<-`wMU'ircp0LaE_OtlMb&1#6T.#FDKu#1Lw%u%+GM+X'e?YLfjM[VO0MbuFp7;>Q&#WIo)0@F%q7c#4XAXN-U&VB<HFF*qL($/V,;(kXZejWO`<[5??ewY(*9=%wDc;,u<'9t3W-(H1th3+G]ucQ]kLs7df($/*JL]@*t7Bu_G3_7mp7<iaQjO@.kLg;x3B0lqp7Hf,^Ze7-##@/c58Mo(3;knp0%)A7?-W+eI'o8)b<nKnw'Ho8C=Y>pqB>0ie&jhZ[?iLR@@_AvA-iQC(=ksRZRVp7`.=+NpBC%rh&3]R:8XDmE5^V8O(x<<aG/1N$#FX$0V5Y6x'aErI3I$7x%E`v<-BY,)%-?Psf*l?%C3.mM(=/M0:JxG'?7WhH%o'a<-80g0NBxoO(GH<dM]n.+%q@jH?f.UsJ2Ggs&4<-e47&Kl+f//9@`b+?.TeN_&B8Ss?v;^Trk;f#YvJkl&w$]>-+k?'(<S:68tq*WoDfZu';mM?8X[ma8W%*`-=;D.(nc7/;)g:T1=^J$&BRV(-lTmNB6xqB[@0*o.erM*<SWF]u2=st-*(6v>^](H.aREZSi,#1:[IXaZFOm<-ui#qUq2$##Ri;u75OK#(RtaW-K-F`S+cF]uN`-KMQ%rP/Xri.LRcB##=YL3BgM/3MD?@f&1'BW-)Ju<L25gl8uhVm1hL$##*8###'A3/LkKW+(^rWX?5W_8g)a(m&K8P>#bmmWCMkk&#TR`C,5d>g)F;t,4:@_l8G/5h4vUd%&%950:VXD'QdWoY-F$BtUwmfe$YqL'8(PWX(P?^@Po3$##`MSs?DWBZ/S>+4%>fX,VWv/w'KD`LP5IbH;rTV>n3cEK8U#bX]l-/V+^lj3;vlMb&[5YQ8#pekX9JP3XUC72L,,?+Ni&co7ApnO*5NK,((W-i:$,kp'UDAO(G0Sq7MVjJsbIu)'Z,*[>br5fX^:FPAWr-m2KgL<LUN098kTF&#lvo58=/vjDo;.;)Ka*hLR#/k=rKbxuV`>Q_nN6'8uTG&#1T5g)uLv:873UpTLgH+#FgpH'_o1780Ph8KmxQJ8#H72L4@768@Tm&Qh4CB/5OvmA&,Q&QbUoi$a_%3M01H)4x7I^&KQVgtFnV+;[Pc>[m4k//,]1?#`VY[Jr*3&&slRfLiVZJ:]?=K3Sw=[$=uRB?3xk48@aeg<Z'<$#4H)6,>e0jT6'N#(q%.O=?2S]u*(m<-V8J'(1)G][68hW$5'q[GC&5j`TE?m'esFGNRM)j,ffZ?-qx8;->g4t*:CIP/[Qap7/9'#(1sao7w-.qNUdkJ)tCF&#B^;xGvn2r9FEPFFFcL@.iFNkTve$m%#QvQS8U@)2Z+3K:AKM5isZ88+dKQ)W6>J%CL<KE>`.d*(B`-n8D9oK<Up]c$X$(,)M8Zt7/[rdkqTgl-0cuGMv'?>-XV1q['-5k'cAZ69e;D_?$ZPP&s^+7])$*$#@QYi9,5P&#9r+$%CE=68>K8r0=dSC%%(@p7.m7jilQ02'0-VWAg<a/''3u.=4L$Y)6k/K:_[3=&jvL<L0C/2'v:^;-DIBW,B4E68:kZ;%?8(Q8BH=kO65BW?xSG&#@uU,DS*,?.+(o(#1vCS8#CHF>TlGW'b)Tq7VT9q^*^$$.:&N@@$&)WHtPm*5_rO0&e%K&#-30j(E4#'Zb.o/(Tpm$>K'f@[PvFl,hfINTNU6u'0pao7%XUp9]5.>%h`8_=VYbxuel.NTSsJfLacFu3B'lQSu/m6-Oqem8T+oE--$0a/k]uj9EwsG>%veR*hv^BFpQj:K'#SJ,sB-'#](j.Lg92rTw-*n%@/;39rrJF,l#qV%OrtBeC6/,;qB3ebNW[?,Hqj2L.1NP&GjUR=1D8QaS3Up&@*9wP?+lo7b?@%'k4`p0Z$22%K3+iCZj?XJN4Nm&+YF]u@-W$U%VEQ/,,>>#)D<h#`)h0:<Q6909ua+&VU%n2:cG3FJ-%@Bj-DgLr`Hw&HAKjKjseK</xKT*)B,N9X3]krc12t'pgTV(Lv-tL[xg_%=M_q7a^x?7Ubd>#%8cY#YZ?=,`Wdxu/ae&#w6)R89tI#6@s'(6Bf7a&?S=^ZI_kS&ai`&=tE72L_D,;^R)7[$s<Eh#c&)q.MXI%#v9ROa5FZO%sF7q7Nwb&#ptUJ:aqJe$Sl68%.D###EC><?-aF&#RNQv>o8lKN%5/$(vdfq7+ebA#u1p]ovUKW&Y%q]'>$1@-[xfn$7ZTp7mM,G,Ko7a&Gu%G[RMxJs[0MM%wci.LFDK)(<c`Q8N)jEIF*+?P2a8g%)$q]o2aH8C&<SibC/q,(e:v;-b#6[$NtDZ84Je2KNvB#$P5?tQ3nt(0d=j.LQf./Ll33+(;q3L-w=8dX$#WF&uIJ@-bfI>%:_i2B5CsR8&9Z&#=mPEnm0f`<&c)QL5uJ#%u%lJj+D-r;BoF&#4DoS97h5g)E#o:&S4weDF,9^Hoe`h*L+_a*NrLW-1pG_&2UdB86e%B/:=>)N4xeW.*wft-;$'58-ESqr<b?UI(_%@[P46>#U`'6AQ]m&6/`Z>#S?YY#Vc;r7U2&326d=w&H####?TZ`*4?&.MK?LP8Vxg>$[QXc%QJv92.(Db*B)gb*BM9dM*hJMAo*c&#b0v=Pjer]$gG&JXDf->'StvU7505l9$AFvgYRI^&<^b68?j#q9QX4SM'RO#&sL1IM.rJfLUAj221]d##DW=m83u5;'bYx,*Sl0hL(W;;$doB&O/TQ:(Z^xBdLjL<Lni;''X.`$#8+1GD:k$YUWsbn8ogh6rxZ2Z9]%nd+>V#*8U_72Lh+2Q8Cj0i:6hp&$C/:p(HK>T8Y[gHQ4`4)'$Ab(Nof%V'8hL&#<NEdtg(n'=S1A(Q1/I&4([%dM`,Iu'1:_hL>SfD07&6D<fp8dHM7/g+tlPN9J*rKaPct&?'uBCem^jn%9_K)<,C5K3s=5g&GmJb*[SYq7K;TRLGCsM-$$;S%:Y@r7AK0pprpL<Lrh,q7e/%KWK:50I^+m'vi`3?%Zp+<-d+$L-Sv:@.o19n$s0&39;kn;S%BSq*$3WoJSCLweV[aZ'MQIjO<7;X-X;&+dMLvu#^UsGEC9WEc[X(wI7#2.(F0jV*eZf<-Qv3J-c+J5AlrB#$p(H68LvEA'q3n0#m,[`*8Ft)FcYgEud]CWfm68,(aLA$@EFTgLXoBq/UPlp7:d[/;r_ix=:TF`S5H-b<LI&HY(K=h#)]Lk$K14lVfm:x$H<3^Ql<M`$OhapBnkup'D#L$Pb_`N*g]2e;X/Dtg,bsj&K#2[-:iYr'_wgH)NUIR8a1n#S?Yej'h8^58UbZd+^FKD*T@;6A7aQC[K8d-(v6GI$x:T<&'Gp5Uf>@M.*J:;$-rv29'M]8qMv-tLp,'886iaC=Hb*YJoKJ,(j%K=H`K.v9HggqBIiZu'QvBT.#=)0ukruV&.)3=(^1`o*Pj4<-<aN((^7('#Z0wK#5GX@7u][`*S^43933A4rl][`*O4CgLEl]v$1Q3AeF37dbXk,.)vj#x'd`;qgbQR%FW,2(?LO=s%Sc68%NP'##Aotl8x=BE#j1UD([3$M(]UI2LX3RpKN@;/#f'f/&_mt&F)XdF<9t4)Qa.*kTLwQ'(TTB9.xH'>#MJ+gLq9-##@HuZPN0]u:h7.T..G:;$/Usj(T7`Q8tT72LnYl<-qx8;-HV7Q-&Xdx%1a,hC=0u+HlsV>nuIQL-5<N?)NBS)QN*_I,?&)2'IM%L3I)X((e/dl2&8'<M:^#M*Q+[T.Xri.LYS3v%fF`68h;b-X[/En'CR.q7E)p'/kle2HM,u;^%OKC-N+Ll%F9CF<Nf'^#t2L,;27W:0O@6##U6W7:$rJfLWHj$#)woqBefIZ.PK<b*t7ed;p*_m;4ExK#h@&]>_>@kXQtMacfD.m-VAb8;IReM3$wf0''hra*so568'Ip&vRs849'MRYSp%:t:h5qSgwpEr$B>Q,;s(C#$)`svQuF$##-D,##,g68@2[T;.XSdN9Qe)rpt._K-#5wF)sP'##p#C0c%-Gb%hd+<-j'Ai*x&&HMkT]C'OSl##5RG[JXaHN;d'uA#x._U;.`PU@(Z3dt4r152@:v,'R.Sj'w#0<-;kPI)FfJ&#AYJ&#//)>-k=m=*XnK$>=)72L]0I%>.G690a:$##<,);?;72#?x9+d;^V'9;jY@;)br#q^YQpx:X#Te$Z^'=-=bGhLf:D6&bNwZ9-ZD#n^9HhLMr5G;']d&6'wYmTFmL<LD)F^%[tC'8;+9E#C$g%#5Y>q9wI>P(9mI[>kC-ekLC/R&CH+s'B;K-M6$EB%is00:+A4[7xks.LrNk0&E)wILYF@2L'0Nb$+pv<(2.768/FrY&h$^3i&@+G%JT'<-,v`3;_)I9M^AE]CN?Cl2AZg+%4iTpT3<n-&%H%b<FDj2M<hH=&Eh<2Len$b*aTX=-8QxN)k11IM1c^j%9s<L<NFSo)B?+<-(GxsF,^-Eh@$4dXhN$+#rxK8'je'D7k`e;)2pYwPA'_p9&@^18ml1^[@g4t*[JOa*[=Qp7(qJ_oOL^('7fB&Hq-:sf,sNj8xq^>$U4O]GKx'm9)b@p7YsvK3w^YR-CdQ*:Ir<($u&)#(&?L9Rg3H)4fiEp^iI9O8KnTj,]H?D*r7'M;PwZ9K0E^k&-cpI;.p/6_vwoFMV<->#%Xi.LxVnrU(4&8/P+:hLSKj$#U%]49t'I:rgMi'FL@a:0Y-uA[39',(vbma*hU%<-SRF`Tt:542R_VV$p@[p8DV[A,?1839FWdF<TddF<9Ah-6&9tWoDlh]&1SpGMq>Ti1O*H&#(AL8[_P%.M>v^-))qOT*F5Cq0`Ye%+$B6i:7@0IX<N+T+0MlMBPQ*Vj>SsD<U4JHY8kD2)2fU/M#$e.)T4,_=8hLim[&);?UkK'-x?'(:siIfL<$pFM`i<?%W(mGDHM%>iWP,##P`%/L<eXi:@Z9C.7o=@(pXdAO/NLQ8lPl+HPOQa8wD8=^GlPa8TKI1CjhsCTSLJM'/Wl>-S(qw%sf/@%#B6;/U7K]uZbi^Oc^2n<bhPmUkMw>%t<)'mEVE''n`WnJra$^TKvX5B>;_aSEK',(hwa0:i4G?.Bci.(X[?b*($,=-n<.Q%`(X=?+@Am*Js0&=3bh8K]mL<LoNs'6,'85`0?t/'_U59@]ddF<#LdF<eWdF<OuN/45rY<-L@&#+fm>69=Lb,OcZV/);TTm8VI;?%OtJ<(b4mq7M6:u?KRdF<gR@2L=FNU-<b[(9c/ML3m;Z[$oF3g)GAWqpARc=<ROu7cL5l;-[A]%/+fsd;l#SafT/f*W]0=O'$(Tb<[)*@e775R-:Yob%g*>l*:xP?Yb.5)%w_I?7uk5JC+FS(m#i'k.'a0i)9<7b'fs'59hq$*5Uhv##pi^8+hIEBF`nvo`;'l0.^S1<-wUK2/Coh58KKhLjM=SO*rfO`+qC`W-On.=AJ56>>i2@2LH6A:&5q`?9I3@@'04&p2/LVa*T-4<-i3;M9UvZd+N7>b*eIwg:CC)c<>nO&#<IGe;__.thjZl<%w(Wk2xmp4Q@I#I9,DF]u7-P=.-_:YJ]aS@V?6*C()dOp7:WL,b&3Rg/.cmM9&r^>$(>.Z-I&J(Q0Hd5Q%7Co-b`-c<N(6r@ip+AurK<m86QIth*#v;-OBqi+L7wDE-Ir8K['m+DDSLwK&/.?-V%U_%3:qKNu$_b*B-kp7NaD'QdWQPKYq[@>P)hI;*_F]u`Rb[.j8_Q/<&>uu+VsH$sM9TA%?)(vmJ80),P7E>)tjD%2L=-t#fK[%`v=Q8<FfNkgg^oIbah*#8/Qt$F&:K*-(N/'+1vMB,u()-a.VUU*#[e%gAAO(S>WlA2);Sa>gXm8YB`1d@K#n]76-a$U,mF<fX]idqd)<3,]J7JmW4`6]uks=4-72L(jEk+:bJ0M^q-8Dm_Z?0olP1C9Sa&H[d&c$ooQUj]Exd*3ZM@-WGW2%s',B-_M%>%Ul:#/'xoFM9QX-$.QN'>[%$Z$uF6pA6Ki2O5:8w*vP1<-1`[G,)-m#>0`P&#eb#.3i)rtB61(o'$?X3B</R90;eZ]%Ncq;-Tl]#F>2Qft^ae_5tKL9MUe9b*sLEQ95C&`=G?@Mj=wh*'3E>=-<)Gt*Iw)'QG:`@IwOf7&]1i'S01B+Ev/Nac#9S;=;YQpg_6U`*kVY39xK,[/6Aj7:'1Bm-_1EYfa1+o&o4hp7KN_Q(OlIo@S%;jVdn0'1<Vc52=u`3^o-n1'g4v58Hj&6_t7$##?M)c<$bgQ_'SY((-xkA#Y(,p'H9rIVY-b,'%bCPF7.J<Up^,(dU1VY*5#WkTU>h19w,WQhLI)3S#f$2(eb,jr*b;3Vw]*7NH%$c4Vs,eD9>XW8?N]o+(*pgC%/72LV-u<Hp,3@e^9UB1J+ak9-TN/mhKPg+AJYd$MlvAF_jCK*.O-^(63adMT->W%iewS8W6m2rtCpo'RS1R84=@paTKt)>=%&1[)*vp'u+x,VrwN;&]kuO9JDbg=pO$J*.jVe;u'm0dr9l,<*wMK*Oe=g8lV_KEBFkO'oU]^=[-792#ok,)i]lR8qQ2oA8wcRCZ^7w/Njh;?.stX?Q1>S1q4Bn$)K1<-rGdO'$Wr.Lc.CG)$/*JL4tNR/,SVO3,aUw'DJN:)Ss;wGn9A32ijw%FL+Z0Fn.U9;reSq)bmI32U==5ALuG&#Vf1398/pVo1*c-(aY168o<`JsSbk-,1N;$>0:OUas(3:8Z972LSfF8eb=c-;>SPw7.6hn3m`9^Xkn(r.qS[0;T%&Qc=+STRxX'q1BNk3&*eu2;&8q$&x>Q#Q7^Tf+6<(d%ZVmj2bDi%.3L2n+4W'$PiDDG)g,r%+?,$@?uou5tSe2aN_AQU*<h`e-GI7)?OK2A.d7_c)?wQ5AS@DL3r#7fSkgl6-++D:'A,uq7SvlB$pcpH'q3n0#_%dY#xCpr-l<F0NR@-##FEV6NTF6##$l84N1w?AO>'IAOURQ##V^Fv-XFbGM7Fl(N<3DhLGF%q.1rC$#:T__&Pi68%0xi_&[qFJ(77j_&JWoF.V735&T,[R*:xFR*K5>>#`bW-?4Ne_&6Ne_&6Ne_&n`kr-#GJcM6X;uM6X;uM(.a..^2TkL%oR(#;u.T%fAr%4tJ8&><1=GHZ_+m9/#H1F^R#SC#*N=BA9(D?v[UiFY>>^8p,KKF.W]L29uLkLlu/+4T<XoIB&hx=T1PcDaB&;HH+-AFr?(m9HZV)FKS8JCw;SD=6[^/DZUL`EUDf]GGlG&>w$)F./^n3+rlo+DB;5sIYGNk+i1t-69Jg--0pao7Sm#K)pdHW&;LuDNH@H>#/X-TI(;P>#,Gc>#0Su>#4`1?#8lC?#<xU?#@.i?#D:%@#HF7@#LRI@#P_[@#Tkn@#Xw*A#]-=A#a9OA#d<F&#*;G##.GY##2Sl##6`($#:l:$#>xL$#B.`$#F:r$#JF.%#NR@%#R_R%#Vke%#Zww%#_-4&#3^Rh%Sflr-k'MS.o?.5/sWel/wpEM0%3'/1)K^f1-d>G21&v(35>V`39V7A4=onx4A1OY5EI0;6Ibgr6M$HS7Q<)58C5w,;WoA*#[%T*#`1g*#d=#+#hI5+#lUG+#pbY+#tnl+#x$),#&1;,#*=M,#.I`,#2Ur,#6b.-#;w[H#iQtA#m^0B#qjBB#uvTB##-hB#'9$C#+E6C#/QHC#3^ZC#7jmC#;v)D#?,<D#C8ND#GDaD#KPsD#O]/E#g1A5#KA*1#gC17#MGd;#8(02#L-d3#rWM4#Hga1#,<w0#T.j<#O#'2#CYN1#qa^:#_4m3#o@/=#eG8=#t8J5#`+78#4uI-#m3B2#SB[8#Q0@8#i[*9#iOn8#1Nm;#^sN9#qh<9#:=x-#P;K2#$%X9#bC+.#Rg;<#mN=.#MTF.#RZO.#2?)4#Y#(/#[)1/#b;L/#dAU/#0Sv;#lY$0#n`-0#sf60#(F24#wrH0#%/e0#TmD<#%JSMFove:CTBEXI:<eh2g)B,3h2^G3i;#d3jD>)4kMYD4lVu`4m`:&5niUA5@(A5BA1]PBB:xlBCC=2CDLXMCEUtiCf&0g2'tN?PGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CP-qekC`.9kEg^+F$kwViFJTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5o,^<-28ZI'O?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xp;7q-#lLYI:xvD=#\00", align 16

@_ZN20ImDrawListSharedDataC1Ev = unnamed_addr alias void (ptr), ptr @_ZN20ImDrawListSharedDataC2Ev
@_ZN12ImFontConfigC1Ev = unnamed_addr alias void (ptr), ptr @_ZN12ImFontConfigC2Ev
@_ZN11ImFontAtlasC1Ev = unnamed_addr alias void (ptr), ptr @_ZN11ImFontAtlasC2Ev
@_ZN11ImFontAtlasD1Ev = unnamed_addr alias void (ptr), ptr @_ZN11ImFontAtlasD2Ev
@_ZN6ImFontC1Ev = unnamed_addr alias void (ptr), ptr @_ZN6ImFontC2Ev
@_ZN6ImFontD1Ev = unnamed_addr alias void (ptr), ptr @_ZN6ImFontD2Ev

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui15StyleColorsDarkEP10ImGuiStyle(ptr noundef %dst) #0 {
entry:
  %dst.addr = alloca ptr, align 8
  %style = alloca ptr, align 8
  %colors = alloca ptr, align 8
  %ref.tmp = alloca %struct.ImVec4, align 4
  %ref.tmp1 = alloca %struct.ImVec4, align 4
  %ref.tmp3 = alloca %struct.ImVec4, align 4
  %ref.tmp5 = alloca %struct.ImVec4, align 4
  %ref.tmp7 = alloca %struct.ImVec4, align 4
  %ref.tmp9 = alloca %struct.ImVec4, align 4
  %ref.tmp11 = alloca %struct.ImVec4, align 4
  %ref.tmp13 = alloca %struct.ImVec4, align 4
  %ref.tmp15 = alloca %struct.ImVec4, align 4
  %ref.tmp17 = alloca %struct.ImVec4, align 4
  %ref.tmp19 = alloca %struct.ImVec4, align 4
  %ref.tmp21 = alloca %struct.ImVec4, align 4
  %ref.tmp23 = alloca %struct.ImVec4, align 4
  %ref.tmp25 = alloca %struct.ImVec4, align 4
  %ref.tmp27 = alloca %struct.ImVec4, align 4
  %ref.tmp29 = alloca %struct.ImVec4, align 4
  %ref.tmp31 = alloca %struct.ImVec4, align 4
  %ref.tmp33 = alloca %struct.ImVec4, align 4
  %ref.tmp35 = alloca %struct.ImVec4, align 4
  %ref.tmp37 = alloca %struct.ImVec4, align 4
  %ref.tmp39 = alloca %struct.ImVec4, align 4
  %ref.tmp41 = alloca %struct.ImVec4, align 4
  %ref.tmp43 = alloca %struct.ImVec4, align 4
  %ref.tmp45 = alloca %struct.ImVec4, align 4
  %ref.tmp47 = alloca %struct.ImVec4, align 4
  %ref.tmp49 = alloca %struct.ImVec4, align 4
  %ref.tmp51 = alloca %struct.ImVec4, align 4
  %ref.tmp55 = alloca %struct.ImVec4, align 4
  %ref.tmp57 = alloca %struct.ImVec4, align 4
  %ref.tmp59 = alloca %struct.ImVec4, align 4
  %ref.tmp61 = alloca %struct.ImVec4, align 4
  %ref.tmp63 = alloca %struct.ImVec4, align 4
  %ref.tmp65 = alloca %struct.ImVec4, align 4
  %ref.tmp72 = alloca %struct.ImVec4, align 4
  %ref.tmp77 = alloca %struct.ImVec4, align 4
  %ref.tmp82 = alloca %struct.ImVec4, align 4
  %ref.tmp87 = alloca %struct.ImVec4, align 4
  %ref.tmp89 = alloca %struct.ImVec4, align 4
  %ref.tmp91 = alloca %struct.ImVec4, align 4
  %ref.tmp93 = alloca %struct.ImVec4, align 4
  %ref.tmp95 = alloca %struct.ImVec4, align 4
  %ref.tmp97 = alloca %struct.ImVec4, align 4
  %ref.tmp99 = alloca %struct.ImVec4, align 4
  %ref.tmp101 = alloca %struct.ImVec4, align 4
  %ref.tmp103 = alloca %struct.ImVec4, align 4
  %ref.tmp105 = alloca %struct.ImVec4, align 4
  %ref.tmp107 = alloca %struct.ImVec4, align 4
  %ref.tmp109 = alloca %struct.ImVec4, align 4
  %ref.tmp111 = alloca %struct.ImVec4, align 4
  %ref.tmp113 = alloca %struct.ImVec4, align 4
  %ref.tmp115 = alloca %struct.ImVec4, align 4
  store ptr %dst, ptr %dst.addr, align 8
  %0 = load ptr, ptr %dst.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load ptr, ptr %dst.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call noundef nonnull align 4 dereferenceable(1096) ptr @_ZN5ImGui8GetStyleEv()
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %1, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %style, align 8
  %2 = load ptr, ptr %style, align 8
  %Colors = getelementptr inbounds %struct.ImGuiStyle, ptr %2, i32 0, i32 45
  %arraydecay = getelementptr inbounds [53 x %struct.ImVec4], ptr %Colors, i64 0, i64 0
  store ptr %arraydecay, ptr %colors, align 8
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp, float noundef 1.000000e+00, float noundef 1.000000e+00, float noundef 1.000000e+00, float noundef 1.000000e+00)
  %3 = load ptr, ptr %colors, align 8
  %arrayidx = getelementptr inbounds %struct.ImVec4, ptr %3, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx, ptr align 4 %ref.tmp, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp1, float noundef 5.000000e-01, float noundef 5.000000e-01, float noundef 5.000000e-01, float noundef 1.000000e+00)
  %4 = load ptr, ptr %colors, align 8
  %arrayidx2 = getelementptr inbounds %struct.ImVec4, ptr %4, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx2, ptr align 4 %ref.tmp1, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp3, float noundef 0x3FAEB851E0000000, float noundef 0x3FAEB851E0000000, float noundef 0x3FAEB851E0000000, float noundef 0x3FEE147AE0000000)
  %5 = load ptr, ptr %colors, align 8
  %arrayidx4 = getelementptr inbounds %struct.ImVec4, ptr %5, i64 2
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx4, ptr align 4 %ref.tmp3, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp5, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %6 = load ptr, ptr %colors, align 8
  %arrayidx6 = getelementptr inbounds %struct.ImVec4, ptr %6, i64 3
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx6, ptr align 4 %ref.tmp5, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp7, float noundef 0x3FB47AE140000000, float noundef 0x3FB47AE140000000, float noundef 0x3FB47AE140000000, float noundef 0x3FEE147AE0000000)
  %7 = load ptr, ptr %colors, align 8
  %arrayidx8 = getelementptr inbounds %struct.ImVec4, ptr %7, i64 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx8, ptr align 4 %ref.tmp7, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp9, float noundef 0x3FDB851EC0000000, float noundef 0x3FDB851EC0000000, float noundef 5.000000e-01, float noundef 5.000000e-01)
  %8 = load ptr, ptr %colors, align 8
  %arrayidx10 = getelementptr inbounds %struct.ImVec4, ptr %8, i64 5
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx10, ptr align 4 %ref.tmp9, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp11, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %9 = load ptr, ptr %colors, align 8
  %arrayidx12 = getelementptr inbounds %struct.ImVec4, ptr %9, i64 6
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx12, ptr align 4 %ref.tmp11, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp13, float noundef 0x3FC47AE140000000, float noundef 0x3FD28F5C20000000, float noundef 0x3FDEB851E0000000, float noundef 0x3FE147AE20000000)
  %10 = load ptr, ptr %colors, align 8
  %arrayidx14 = getelementptr inbounds %struct.ImVec4, ptr %10, i64 7
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx14, ptr align 4 %ref.tmp13, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp15, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 0x3FD99999A0000000)
  %11 = load ptr, ptr %colors, align 8
  %arrayidx16 = getelementptr inbounds %struct.ImVec4, ptr %11, i64 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx16, ptr align 4 %ref.tmp15, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp17, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 0x3FE570A3E0000000)
  %12 = load ptr, ptr %colors, align 8
  %arrayidx18 = getelementptr inbounds %struct.ImVec4, ptr %12, i64 9
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx18, ptr align 4 %ref.tmp17, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp19, float noundef 0x3FA47AE140000000, float noundef 0x3FA47AE140000000, float noundef 0x3FA47AE140000000, float noundef 1.000000e+00)
  %13 = load ptr, ptr %colors, align 8
  %arrayidx20 = getelementptr inbounds %struct.ImVec4, ptr %13, i64 10
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx20, ptr align 4 %ref.tmp19, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp21, float noundef 0x3FC47AE140000000, float noundef 0x3FD28F5C20000000, float noundef 0x3FDEB851E0000000, float noundef 1.000000e+00)
  %14 = load ptr, ptr %colors, align 8
  %arrayidx22 = getelementptr inbounds %struct.ImVec4, ptr %14, i64 11
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx22, ptr align 4 %ref.tmp21, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp23, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0x3FE051EB80000000)
  %15 = load ptr, ptr %colors, align 8
  %arrayidx24 = getelementptr inbounds %struct.ImVec4, ptr %15, i64 12
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx24, ptr align 4 %ref.tmp23, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp25, float noundef 0x3FC1EB8520000000, float noundef 0x3FC1EB8520000000, float noundef 0x3FC1EB8520000000, float noundef 1.000000e+00)
  %16 = load ptr, ptr %colors, align 8
  %arrayidx26 = getelementptr inbounds %struct.ImVec4, ptr %16, i64 13
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx26, ptr align 4 %ref.tmp25, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp27, float noundef 0x3F947AE140000000, float noundef 0x3F947AE140000000, float noundef 0x3F947AE140000000, float noundef 0x3FE0F5C280000000)
  %17 = load ptr, ptr %colors, align 8
  %arrayidx28 = getelementptr inbounds %struct.ImVec4, ptr %17, i64 14
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx28, ptr align 4 %ref.tmp27, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp29, float noundef 0x3FD3D70A40000000, float noundef 0x3FD3D70A40000000, float noundef 0x3FD3D70A40000000, float noundef 1.000000e+00)
  %18 = load ptr, ptr %colors, align 8
  %arrayidx30 = getelementptr inbounds %struct.ImVec4, ptr %18, i64 15
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx30, ptr align 4 %ref.tmp29, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp31, float noundef 0x3FDA3D70A0000000, float noundef 0x3FDA3D70A0000000, float noundef 0x3FDA3D70A0000000, float noundef 1.000000e+00)
  %19 = load ptr, ptr %colors, align 8
  %arrayidx32 = getelementptr inbounds %struct.ImVec4, ptr %19, i64 16
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx32, ptr align 4 %ref.tmp31, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp33, float noundef 0x3FE051EB80000000, float noundef 0x3FE051EB80000000, float noundef 0x3FE051EB80000000, float noundef 1.000000e+00)
  %20 = load ptr, ptr %colors, align 8
  %arrayidx34 = getelementptr inbounds %struct.ImVec4, ptr %20, i64 17
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx34, ptr align 4 %ref.tmp33, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp35, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 1.000000e+00)
  %21 = load ptr, ptr %colors, align 8
  %arrayidx36 = getelementptr inbounds %struct.ImVec4, ptr %21, i64 18
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx36, ptr align 4 %ref.tmp35, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp37, float noundef 0x3FCEB851E0000000, float noundef 0x3FE0A3D700000000, float noundef 0x3FEC28F5C0000000, float noundef 1.000000e+00)
  %22 = load ptr, ptr %colors, align 8
  %arrayidx38 = getelementptr inbounds %struct.ImVec4, ptr %22, i64 19
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx38, ptr align 4 %ref.tmp37, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp39, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 1.000000e+00)
  %23 = load ptr, ptr %colors, align 8
  %arrayidx40 = getelementptr inbounds %struct.ImVec4, ptr %23, i64 20
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx40, ptr align 4 %ref.tmp39, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp41, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 0x3FD99999A0000000)
  %24 = load ptr, ptr %colors, align 8
  %arrayidx42 = getelementptr inbounds %struct.ImVec4, ptr %24, i64 21
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx42, ptr align 4 %ref.tmp41, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp43, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 1.000000e+00)
  %25 = load ptr, ptr %colors, align 8
  %arrayidx44 = getelementptr inbounds %struct.ImVec4, ptr %25, i64 22
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx44, ptr align 4 %ref.tmp43, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp45, float noundef 0x3FAEB851E0000000, float noundef 0x3FE0F5C280000000, float noundef 0x3FEF5C2900000000, float noundef 1.000000e+00)
  %26 = load ptr, ptr %colors, align 8
  %arrayidx46 = getelementptr inbounds %struct.ImVec4, ptr %26, i64 23
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx46, ptr align 4 %ref.tmp45, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp47, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 0x3FD3D70A40000000)
  %27 = load ptr, ptr %colors, align 8
  %arrayidx48 = getelementptr inbounds %struct.ImVec4, ptr %27, i64 24
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx48, ptr align 4 %ref.tmp47, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp49, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 0x3FE99999A0000000)
  %28 = load ptr, ptr %colors, align 8
  %arrayidx50 = getelementptr inbounds %struct.ImVec4, ptr %28, i64 25
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx50, ptr align 4 %ref.tmp49, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp51, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 1.000000e+00)
  %29 = load ptr, ptr %colors, align 8
  %arrayidx52 = getelementptr inbounds %struct.ImVec4, ptr %29, i64 26
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx52, ptr align 4 %ref.tmp51, i64 16, i1 false)
  %30 = load ptr, ptr %colors, align 8
  %arrayidx53 = getelementptr inbounds %struct.ImVec4, ptr %30, i64 5
  %31 = load ptr, ptr %colors, align 8
  %arrayidx54 = getelementptr inbounds %struct.ImVec4, ptr %31, i64 27
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx54, ptr align 4 %arrayidx53, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp55, float noundef 0x3FB99999A0000000, float noundef 0x3FD99999A0000000, float noundef 7.500000e-01, float noundef 0x3FE8F5C280000000)
  %32 = load ptr, ptr %colors, align 8
  %arrayidx56 = getelementptr inbounds %struct.ImVec4, ptr %32, i64 28
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx56, ptr align 4 %ref.tmp55, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp57, float noundef 0x3FB99999A0000000, float noundef 0x3FD99999A0000000, float noundef 7.500000e-01, float noundef 1.000000e+00)
  %33 = load ptr, ptr %colors, align 8
  %arrayidx58 = getelementptr inbounds %struct.ImVec4, ptr %33, i64 29
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx58, ptr align 4 %ref.tmp57, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp59, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 0x3FC99999A0000000)
  %34 = load ptr, ptr %colors, align 8
  %arrayidx60 = getelementptr inbounds %struct.ImVec4, ptr %34, i64 30
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx60, ptr align 4 %ref.tmp59, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp61, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 0x3FE570A3E0000000)
  %35 = load ptr, ptr %colors, align 8
  %arrayidx62 = getelementptr inbounds %struct.ImVec4, ptr %35, i64 31
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx62, ptr align 4 %ref.tmp61, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp63, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 0x3FEE666660000000)
  %36 = load ptr, ptr %colors, align 8
  %arrayidx64 = getelementptr inbounds %struct.ImVec4, ptr %36, i64 32
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx64, ptr align 4 %ref.tmp63, i64 16, i1 false)
  %37 = load ptr, ptr %colors, align 8
  %arrayidx66 = getelementptr inbounds %struct.ImVec4, ptr %37, i64 24
  %38 = load ptr, ptr %colors, align 8
  %arrayidx67 = getelementptr inbounds %struct.ImVec4, ptr %38, i64 11
  %call68 = call { <2 x float>, <2 x float> } @_ZL6ImLerpRK6ImVec4S1_f(ptr noundef nonnull align 4 dereferenceable(16) %arrayidx66, ptr noundef nonnull align 4 dereferenceable(16) %arrayidx67, float noundef 0x3FE99999A0000000)
  %39 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp65, i32 0, i32 0
  %40 = extractvalue { <2 x float>, <2 x float> } %call68, 0
  store <2 x float> %40, ptr %39, align 4
  %41 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp65, i32 0, i32 1
  %42 = extractvalue { <2 x float>, <2 x float> } %call68, 1
  store <2 x float> %42, ptr %41, align 4
  %43 = load ptr, ptr %colors, align 8
  %arrayidx69 = getelementptr inbounds %struct.ImVec4, ptr %43, i64 33
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx69, ptr align 4 %ref.tmp65, i64 16, i1 false)
  %44 = load ptr, ptr %colors, align 8
  %arrayidx70 = getelementptr inbounds %struct.ImVec4, ptr %44, i64 25
  %45 = load ptr, ptr %colors, align 8
  %arrayidx71 = getelementptr inbounds %struct.ImVec4, ptr %45, i64 34
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx71, ptr align 4 %arrayidx70, i64 16, i1 false)
  %46 = load ptr, ptr %colors, align 8
  %arrayidx73 = getelementptr inbounds %struct.ImVec4, ptr %46, i64 26
  %47 = load ptr, ptr %colors, align 8
  %arrayidx74 = getelementptr inbounds %struct.ImVec4, ptr %47, i64 11
  %call75 = call { <2 x float>, <2 x float> } @_ZL6ImLerpRK6ImVec4S1_f(ptr noundef nonnull align 4 dereferenceable(16) %arrayidx73, ptr noundef nonnull align 4 dereferenceable(16) %arrayidx74, float noundef 0x3FE3333340000000)
  %48 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp72, i32 0, i32 0
  %49 = extractvalue { <2 x float>, <2 x float> } %call75, 0
  store <2 x float> %49, ptr %48, align 4
  %50 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp72, i32 0, i32 1
  %51 = extractvalue { <2 x float>, <2 x float> } %call75, 1
  store <2 x float> %51, ptr %50, align 4
  %52 = load ptr, ptr %colors, align 8
  %arrayidx76 = getelementptr inbounds %struct.ImVec4, ptr %52, i64 35
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx76, ptr align 4 %ref.tmp72, i64 16, i1 false)
  %53 = load ptr, ptr %colors, align 8
  %arrayidx78 = getelementptr inbounds %struct.ImVec4, ptr %53, i64 33
  %54 = load ptr, ptr %colors, align 8
  %arrayidx79 = getelementptr inbounds %struct.ImVec4, ptr %54, i64 10
  %call80 = call { <2 x float>, <2 x float> } @_ZL6ImLerpRK6ImVec4S1_f(ptr noundef nonnull align 4 dereferenceable(16) %arrayidx78, ptr noundef nonnull align 4 dereferenceable(16) %arrayidx79, float noundef 0x3FE99999A0000000)
  %55 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp77, i32 0, i32 0
  %56 = extractvalue { <2 x float>, <2 x float> } %call80, 0
  store <2 x float> %56, ptr %55, align 4
  %57 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp77, i32 0, i32 1
  %58 = extractvalue { <2 x float>, <2 x float> } %call80, 1
  store <2 x float> %58, ptr %57, align 4
  %59 = load ptr, ptr %colors, align 8
  %arrayidx81 = getelementptr inbounds %struct.ImVec4, ptr %59, i64 36
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx81, ptr align 4 %ref.tmp77, i64 16, i1 false)
  %60 = load ptr, ptr %colors, align 8
  %arrayidx83 = getelementptr inbounds %struct.ImVec4, ptr %60, i64 35
  %61 = load ptr, ptr %colors, align 8
  %arrayidx84 = getelementptr inbounds %struct.ImVec4, ptr %61, i64 10
  %call85 = call { <2 x float>, <2 x float> } @_ZL6ImLerpRK6ImVec4S1_f(ptr noundef nonnull align 4 dereferenceable(16) %arrayidx83, ptr noundef nonnull align 4 dereferenceable(16) %arrayidx84, float noundef 0x3FD99999A0000000)
  %62 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp82, i32 0, i32 0
  %63 = extractvalue { <2 x float>, <2 x float> } %call85, 0
  store <2 x float> %63, ptr %62, align 4
  %64 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp82, i32 0, i32 1
  %65 = extractvalue { <2 x float>, <2 x float> } %call85, 1
  store <2 x float> %65, ptr %64, align 4
  %66 = load ptr, ptr %colors, align 8
  %arrayidx86 = getelementptr inbounds %struct.ImVec4, ptr %66, i64 37
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx86, ptr align 4 %ref.tmp82, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp87, float noundef 0x3FE3851EC0000000, float noundef 0x3FE3851EC0000000, float noundef 0x3FE3851EC0000000, float noundef 1.000000e+00)
  %67 = load ptr, ptr %colors, align 8
  %arrayidx88 = getelementptr inbounds %struct.ImVec4, ptr %67, i64 38
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx88, ptr align 4 %ref.tmp87, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp89, float noundef 1.000000e+00, float noundef 0x3FDB851EC0000000, float noundef 0x3FD6666660000000, float noundef 1.000000e+00)
  %68 = load ptr, ptr %colors, align 8
  %arrayidx90 = getelementptr inbounds %struct.ImVec4, ptr %68, i64 39
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx90, ptr align 4 %ref.tmp89, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp91, float noundef 0x3FECCCCCC0000000, float noundef 0x3FE6666660000000, float noundef 0.000000e+00, float noundef 1.000000e+00)
  %69 = load ptr, ptr %colors, align 8
  %arrayidx92 = getelementptr inbounds %struct.ImVec4, ptr %69, i64 40
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx92, ptr align 4 %ref.tmp91, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp93, float noundef 1.000000e+00, float noundef 0x3FE3333340000000, float noundef 0.000000e+00, float noundef 1.000000e+00)
  %70 = load ptr, ptr %colors, align 8
  %arrayidx94 = getelementptr inbounds %struct.ImVec4, ptr %70, i64 41
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx94, ptr align 4 %ref.tmp93, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp95, float noundef 0x3FC851EB80000000, float noundef 0x3FC851EB80000000, float noundef 0x3FC99999A0000000, float noundef 1.000000e+00)
  %71 = load ptr, ptr %colors, align 8
  %arrayidx96 = getelementptr inbounds %struct.ImVec4, ptr %71, i64 42
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx96, ptr align 4 %ref.tmp95, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp97, float noundef 0x3FD3D70A40000000, float noundef 0x3FD3D70A40000000, float noundef 0x3FD6666660000000, float noundef 1.000000e+00)
  %72 = load ptr, ptr %colors, align 8
  %arrayidx98 = getelementptr inbounds %struct.ImVec4, ptr %72, i64 43
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx98, ptr align 4 %ref.tmp97, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp99, float noundef 0x3FCD70A3E0000000, float noundef 0x3FCD70A3E0000000, float noundef 2.500000e-01, float noundef 1.000000e+00)
  %73 = load ptr, ptr %colors, align 8
  %arrayidx100 = getelementptr inbounds %struct.ImVec4, ptr %73, i64 44
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx100, ptr align 4 %ref.tmp99, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp101, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %74 = load ptr, ptr %colors, align 8
  %arrayidx102 = getelementptr inbounds %struct.ImVec4, ptr %74, i64 45
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx102, ptr align 4 %ref.tmp101, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp103, float noundef 1.000000e+00, float noundef 1.000000e+00, float noundef 1.000000e+00, float noundef 0x3FAEB851E0000000)
  %75 = load ptr, ptr %colors, align 8
  %arrayidx104 = getelementptr inbounds %struct.ImVec4, ptr %75, i64 46
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx104, ptr align 4 %ref.tmp103, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp105, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 0x3FD6666660000000)
  %76 = load ptr, ptr %colors, align 8
  %arrayidx106 = getelementptr inbounds %struct.ImVec4, ptr %76, i64 47
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx106, ptr align 4 %ref.tmp105, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp107, float noundef 1.000000e+00, float noundef 1.000000e+00, float noundef 0.000000e+00, float noundef 0x3FECCCCCC0000000)
  %77 = load ptr, ptr %colors, align 8
  %arrayidx108 = getelementptr inbounds %struct.ImVec4, ptr %77, i64 48
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx108, ptr align 4 %ref.tmp107, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp109, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 1.000000e+00)
  %78 = load ptr, ptr %colors, align 8
  %arrayidx110 = getelementptr inbounds %struct.ImVec4, ptr %78, i64 49
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx110, ptr align 4 %ref.tmp109, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp111, float noundef 1.000000e+00, float noundef 1.000000e+00, float noundef 1.000000e+00, float noundef 0x3FE6666660000000)
  %79 = load ptr, ptr %colors, align 8
  %arrayidx112 = getelementptr inbounds %struct.ImVec4, ptr %79, i64 50
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx112, ptr align 4 %ref.tmp111, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp113, float noundef 0x3FE99999A0000000, float noundef 0x3FE99999A0000000, float noundef 0x3FE99999A0000000, float noundef 0x3FC99999A0000000)
  %80 = load ptr, ptr %colors, align 8
  %arrayidx114 = getelementptr inbounds %struct.ImVec4, ptr %80, i64 51
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx114, ptr align 4 %ref.tmp113, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp115, float noundef 0x3FE99999A0000000, float noundef 0x3FE99999A0000000, float noundef 0x3FE99999A0000000, float noundef 0x3FD6666660000000)
  %81 = load ptr, ptr %colors, align 8
  %arrayidx116 = getelementptr inbounds %struct.ImVec4, ptr %81, i64 52
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx116, ptr align 4 %ref.tmp115, i64 16, i1 false)
  ret void
}

declare noundef nonnull align 4 dereferenceable(1096) ptr @_ZN5ImGui8GetStyleEv() #1

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %this, float noundef %_x, float noundef %_y, float noundef %_z, float noundef %_w) unnamed_addr #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_x.addr = alloca float, align 4
  %_y.addr = alloca float, align 4
  %_z.addr = alloca float, align 4
  %_w.addr = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  store float %_x, ptr %_x.addr, align 4
  store float %_y, ptr %_y.addr, align 4
  store float %_z, ptr %_z.addr, align 4
  store float %_w, ptr %_w.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %x = getelementptr inbounds %struct.ImVec4, ptr %this1, i32 0, i32 0
  %0 = load float, ptr %_x.addr, align 4
  store float %0, ptr %x, align 4
  %y = getelementptr inbounds %struct.ImVec4, ptr %this1, i32 0, i32 1
  %1 = load float, ptr %_y.addr, align 4
  store float %1, ptr %y, align 4
  %z = getelementptr inbounds %struct.ImVec4, ptr %this1, i32 0, i32 2
  %2 = load float, ptr %_z.addr, align 4
  store float %2, ptr %z, align 4
  %w = getelementptr inbounds %struct.ImVec4, ptr %this1, i32 0, i32 3
  %3 = load float, ptr %_w.addr, align 4
  store float %3, ptr %w, align 4
  ret void
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #3

; Function Attrs: mustprogress uwtable
define internal { <2 x float>, <2 x float> } @_ZL6ImLerpRK6ImVec4S1_f(ptr noundef nonnull align 4 dereferenceable(16) %a, ptr noundef nonnull align 4 dereferenceable(16) %b, float noundef %t) #4 {
entry:
  %retval = alloca %struct.ImVec4, align 4
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %t.addr = alloca float, align 4
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  store float %t, ptr %t.addr, align 4
  %0 = load ptr, ptr %a.addr, align 8
  %x = getelementptr inbounds %struct.ImVec4, ptr %0, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %2 = load ptr, ptr %b.addr, align 8
  %x1 = getelementptr inbounds %struct.ImVec4, ptr %2, i32 0, i32 0
  %3 = load float, ptr %x1, align 4
  %4 = load ptr, ptr %a.addr, align 8
  %x2 = getelementptr inbounds %struct.ImVec4, ptr %4, i32 0, i32 0
  %5 = load float, ptr %x2, align 4
  %sub = fsub float %3, %5
  %6 = load float, ptr %t.addr, align 4
  %7 = call float @llvm.fmuladd.f32(float %sub, float %6, float %1)
  %8 = load ptr, ptr %a.addr, align 8
  %y = getelementptr inbounds %struct.ImVec4, ptr %8, i32 0, i32 1
  %9 = load float, ptr %y, align 4
  %10 = load ptr, ptr %b.addr, align 8
  %y3 = getelementptr inbounds %struct.ImVec4, ptr %10, i32 0, i32 1
  %11 = load float, ptr %y3, align 4
  %12 = load ptr, ptr %a.addr, align 8
  %y4 = getelementptr inbounds %struct.ImVec4, ptr %12, i32 0, i32 1
  %13 = load float, ptr %y4, align 4
  %sub5 = fsub float %11, %13
  %14 = load float, ptr %t.addr, align 4
  %15 = call float @llvm.fmuladd.f32(float %sub5, float %14, float %9)
  %16 = load ptr, ptr %a.addr, align 8
  %z = getelementptr inbounds %struct.ImVec4, ptr %16, i32 0, i32 2
  %17 = load float, ptr %z, align 4
  %18 = load ptr, ptr %b.addr, align 8
  %z6 = getelementptr inbounds %struct.ImVec4, ptr %18, i32 0, i32 2
  %19 = load float, ptr %z6, align 4
  %20 = load ptr, ptr %a.addr, align 8
  %z7 = getelementptr inbounds %struct.ImVec4, ptr %20, i32 0, i32 2
  %21 = load float, ptr %z7, align 4
  %sub8 = fsub float %19, %21
  %22 = load float, ptr %t.addr, align 4
  %23 = call float @llvm.fmuladd.f32(float %sub8, float %22, float %17)
  %24 = load ptr, ptr %a.addr, align 8
  %w = getelementptr inbounds %struct.ImVec4, ptr %24, i32 0, i32 3
  %25 = load float, ptr %w, align 4
  %26 = load ptr, ptr %b.addr, align 8
  %w9 = getelementptr inbounds %struct.ImVec4, ptr %26, i32 0, i32 3
  %27 = load float, ptr %w9, align 4
  %28 = load ptr, ptr %a.addr, align 8
  %w10 = getelementptr inbounds %struct.ImVec4, ptr %28, i32 0, i32 3
  %29 = load float, ptr %w10, align 4
  %sub11 = fsub float %27, %29
  %30 = load float, ptr %t.addr, align 4
  %31 = call float @llvm.fmuladd.f32(float %sub11, float %30, float %25)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %retval, float noundef %7, float noundef %15, float noundef %23, float noundef %31)
  %32 = load { <2 x float>, <2 x float> }, ptr %retval, align 4
  ret { <2 x float>, <2 x float> } %32
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui18StyleColorsClassicEP10ImGuiStyle(ptr noundef %dst) #0 {
entry:
  %dst.addr = alloca ptr, align 8
  %style = alloca ptr, align 8
  %colors = alloca ptr, align 8
  %ref.tmp = alloca %struct.ImVec4, align 4
  %ref.tmp1 = alloca %struct.ImVec4, align 4
  %ref.tmp3 = alloca %struct.ImVec4, align 4
  %ref.tmp5 = alloca %struct.ImVec4, align 4
  %ref.tmp7 = alloca %struct.ImVec4, align 4
  %ref.tmp9 = alloca %struct.ImVec4, align 4
  %ref.tmp11 = alloca %struct.ImVec4, align 4
  %ref.tmp13 = alloca %struct.ImVec4, align 4
  %ref.tmp15 = alloca %struct.ImVec4, align 4
  %ref.tmp17 = alloca %struct.ImVec4, align 4
  %ref.tmp19 = alloca %struct.ImVec4, align 4
  %ref.tmp21 = alloca %struct.ImVec4, align 4
  %ref.tmp23 = alloca %struct.ImVec4, align 4
  %ref.tmp25 = alloca %struct.ImVec4, align 4
  %ref.tmp27 = alloca %struct.ImVec4, align 4
  %ref.tmp29 = alloca %struct.ImVec4, align 4
  %ref.tmp31 = alloca %struct.ImVec4, align 4
  %ref.tmp33 = alloca %struct.ImVec4, align 4
  %ref.tmp35 = alloca %struct.ImVec4, align 4
  %ref.tmp37 = alloca %struct.ImVec4, align 4
  %ref.tmp39 = alloca %struct.ImVec4, align 4
  %ref.tmp41 = alloca %struct.ImVec4, align 4
  %ref.tmp43 = alloca %struct.ImVec4, align 4
  %ref.tmp45 = alloca %struct.ImVec4, align 4
  %ref.tmp47 = alloca %struct.ImVec4, align 4
  %ref.tmp49 = alloca %struct.ImVec4, align 4
  %ref.tmp51 = alloca %struct.ImVec4, align 4
  %ref.tmp53 = alloca %struct.ImVec4, align 4
  %ref.tmp55 = alloca %struct.ImVec4, align 4
  %ref.tmp57 = alloca %struct.ImVec4, align 4
  %ref.tmp59 = alloca %struct.ImVec4, align 4
  %ref.tmp61 = alloca %struct.ImVec4, align 4
  %ref.tmp63 = alloca %struct.ImVec4, align 4
  %ref.tmp65 = alloca %struct.ImVec4, align 4
  %ref.tmp72 = alloca %struct.ImVec4, align 4
  %ref.tmp77 = alloca %struct.ImVec4, align 4
  %ref.tmp82 = alloca %struct.ImVec4, align 4
  %ref.tmp87 = alloca %struct.ImVec4, align 4
  %ref.tmp89 = alloca %struct.ImVec4, align 4
  %ref.tmp91 = alloca %struct.ImVec4, align 4
  %ref.tmp93 = alloca %struct.ImVec4, align 4
  %ref.tmp95 = alloca %struct.ImVec4, align 4
  %ref.tmp97 = alloca %struct.ImVec4, align 4
  %ref.tmp99 = alloca %struct.ImVec4, align 4
  %ref.tmp101 = alloca %struct.ImVec4, align 4
  %ref.tmp103 = alloca %struct.ImVec4, align 4
  %ref.tmp105 = alloca %struct.ImVec4, align 4
  %ref.tmp107 = alloca %struct.ImVec4, align 4
  %ref.tmp111 = alloca %struct.ImVec4, align 4
  %ref.tmp113 = alloca %struct.ImVec4, align 4
  %ref.tmp115 = alloca %struct.ImVec4, align 4
  store ptr %dst, ptr %dst.addr, align 8
  %0 = load ptr, ptr %dst.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load ptr, ptr %dst.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call noundef nonnull align 4 dereferenceable(1096) ptr @_ZN5ImGui8GetStyleEv()
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %1, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %style, align 8
  %2 = load ptr, ptr %style, align 8
  %Colors = getelementptr inbounds %struct.ImGuiStyle, ptr %2, i32 0, i32 45
  %arraydecay = getelementptr inbounds [53 x %struct.ImVec4], ptr %Colors, i64 0, i64 0
  store ptr %arraydecay, ptr %colors, align 8
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp, float noundef 0x3FECCCCCC0000000, float noundef 0x3FECCCCCC0000000, float noundef 0x3FECCCCCC0000000, float noundef 1.000000e+00)
  %3 = load ptr, ptr %colors, align 8
  %arrayidx = getelementptr inbounds %struct.ImVec4, ptr %3, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx, ptr align 4 %ref.tmp, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp1, float noundef 0x3FE3333340000000, float noundef 0x3FE3333340000000, float noundef 0x3FE3333340000000, float noundef 1.000000e+00)
  %4 = load ptr, ptr %colors, align 8
  %arrayidx2 = getelementptr inbounds %struct.ImVec4, ptr %4, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx2, ptr align 4 %ref.tmp1, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp3, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0x3FEB333340000000)
  %5 = load ptr, ptr %colors, align 8
  %arrayidx4 = getelementptr inbounds %struct.ImVec4, ptr %5, i64 2
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx4, ptr align 4 %ref.tmp3, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp5, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %6 = load ptr, ptr %colors, align 8
  %arrayidx6 = getelementptr inbounds %struct.ImVec4, ptr %6, i64 3
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx6, ptr align 4 %ref.tmp5, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp7, float noundef 0x3FBC28F5C0000000, float noundef 0x3FBC28F5C0000000, float noundef 0x3FC1EB8520000000, float noundef 0x3FED70A3E0000000)
  %7 = load ptr, ptr %colors, align 8
  %arrayidx8 = getelementptr inbounds %struct.ImVec4, ptr %7, i64 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx8, ptr align 4 %ref.tmp7, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp9, float noundef 5.000000e-01, float noundef 5.000000e-01, float noundef 5.000000e-01, float noundef 5.000000e-01)
  %8 = load ptr, ptr %colors, align 8
  %arrayidx10 = getelementptr inbounds %struct.ImVec4, ptr %8, i64 5
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx10, ptr align 4 %ref.tmp9, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp11, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %9 = load ptr, ptr %colors, align 8
  %arrayidx12 = getelementptr inbounds %struct.ImVec4, ptr %9, i64 6
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx12, ptr align 4 %ref.tmp11, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp13, float noundef 0x3FDB851EC0000000, float noundef 0x3FDB851EC0000000, float noundef 0x3FDB851EC0000000, float noundef 0x3FD8F5C280000000)
  %10 = load ptr, ptr %colors, align 8
  %arrayidx14 = getelementptr inbounds %struct.ImVec4, ptr %10, i64 7
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx14, ptr align 4 %ref.tmp13, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp15, float noundef 0x3FDE147AE0000000, float noundef 0x3FDE147AE0000000, float noundef 0x3FE6147AE0000000, float noundef 0x3FD99999A0000000)
  %11 = load ptr, ptr %colors, align 8
  %arrayidx16 = getelementptr inbounds %struct.ImVec4, ptr %11, i64 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx16, ptr align 4 %ref.tmp15, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp17, float noundef 0x3FDAE147A0000000, float noundef 0x3FDA3D70A0000000, float noundef 0x3FE47AE140000000, float noundef 0x3FE6147AE0000000)
  %12 = load ptr, ptr %colors, align 8
  %arrayidx18 = getelementptr inbounds %struct.ImVec4, ptr %12, i64 9
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx18, ptr align 4 %ref.tmp17, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp19, float noundef 0x3FD147AE20000000, float noundef 0x3FD147AE20000000, float noundef 0x3FE147AE20000000, float noundef 0x3FEA8F5C20000000)
  %13 = load ptr, ptr %colors, align 8
  %arrayidx20 = getelementptr inbounds %struct.ImVec4, ptr %13, i64 10
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx20, ptr align 4 %ref.tmp19, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp21, float noundef 0x3FD47AE140000000, float noundef 0x3FD47AE140000000, float noundef 0x3FE428F5C0000000, float noundef 0x3FEBD70A40000000)
  %14 = load ptr, ptr %colors, align 8
  %arrayidx22 = getelementptr inbounds %struct.ImVec4, ptr %14, i64 11
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx22, ptr align 4 %ref.tmp21, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp23, float noundef 0x3FD99999A0000000, float noundef 0x3FD99999A0000000, float noundef 0x3FE99999A0000000, float noundef 0x3FC99999A0000000)
  %15 = load ptr, ptr %colors, align 8
  %arrayidx24 = getelementptr inbounds %struct.ImVec4, ptr %15, i64 12
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx24, ptr align 4 %ref.tmp23, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp25, float noundef 0x3FD99999A0000000, float noundef 0x3FD99999A0000000, float noundef 0x3FE19999A0000000, float noundef 0x3FE99999A0000000)
  %16 = load ptr, ptr %colors, align 8
  %arrayidx26 = getelementptr inbounds %struct.ImVec4, ptr %16, i64 13
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx26, ptr align 4 %ref.tmp25, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp27, float noundef 0x3FC99999A0000000, float noundef 2.500000e-01, float noundef 0x3FD3333340000000, float noundef 0x3FE3333340000000)
  %17 = load ptr, ptr %colors, align 8
  %arrayidx28 = getelementptr inbounds %struct.ImVec4, ptr %17, i64 14
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx28, ptr align 4 %ref.tmp27, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp29, float noundef 0x3FD99999A0000000, float noundef 0x3FD99999A0000000, float noundef 0x3FE99999A0000000, float noundef 0x3FD3333340000000)
  %18 = load ptr, ptr %colors, align 8
  %arrayidx30 = getelementptr inbounds %struct.ImVec4, ptr %18, i64 15
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx30, ptr align 4 %ref.tmp29, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp31, float noundef 0x3FD99999A0000000, float noundef 0x3FD99999A0000000, float noundef 0x3FE99999A0000000, float noundef 0x3FD99999A0000000)
  %19 = load ptr, ptr %colors, align 8
  %arrayidx32 = getelementptr inbounds %struct.ImVec4, ptr %19, i64 16
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx32, ptr align 4 %ref.tmp31, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp33, float noundef 0x3FDA3D70A0000000, float noundef 0x3FD8F5C280000000, float noundef 0x3FE99999A0000000, float noundef 0x3FE3333340000000)
  %20 = load ptr, ptr %colors, align 8
  %arrayidx34 = getelementptr inbounds %struct.ImVec4, ptr %20, i64 17
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx34, ptr align 4 %ref.tmp33, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp35, float noundef 0x3FECCCCCC0000000, float noundef 0x3FECCCCCC0000000, float noundef 0x3FECCCCCC0000000, float noundef 5.000000e-01)
  %21 = load ptr, ptr %colors, align 8
  %arrayidx36 = getelementptr inbounds %struct.ImVec4, ptr %21, i64 18
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx36, ptr align 4 %ref.tmp35, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp37, float noundef 1.000000e+00, float noundef 1.000000e+00, float noundef 1.000000e+00, float noundef 0x3FD3333340000000)
  %22 = load ptr, ptr %colors, align 8
  %arrayidx38 = getelementptr inbounds %struct.ImVec4, ptr %22, i64 19
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx38, ptr align 4 %ref.tmp37, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp39, float noundef 0x3FDA3D70A0000000, float noundef 0x3FD8F5C280000000, float noundef 0x3FE99999A0000000, float noundef 0x3FE3333340000000)
  %23 = load ptr, ptr %colors, align 8
  %arrayidx40 = getelementptr inbounds %struct.ImVec4, ptr %23, i64 20
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx40, ptr align 4 %ref.tmp39, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp41, float noundef 0x3FD6666660000000, float noundef 0x3FD99999A0000000, float noundef 0x3FE3851EC0000000, float noundef 0x3FE3D70A40000000)
  %24 = load ptr, ptr %colors, align 8
  %arrayidx42 = getelementptr inbounds %struct.ImVec4, ptr %24, i64 21
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx42, ptr align 4 %ref.tmp41, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp43, float noundef 0x3FD99999A0000000, float noundef 0x3FDEB851E0000000, float noundef 0x3FE6B851E0000000, float noundef 0x3FE947AE20000000)
  %25 = load ptr, ptr %colors, align 8
  %arrayidx44 = getelementptr inbounds %struct.ImVec4, ptr %25, i64 22
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx44, ptr align 4 %ref.tmp43, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp45, float noundef 0x3FDD70A3E0000000, float noundef 0x3FE147AE20000000, float noundef 0x3FE99999A0000000, float noundef 1.000000e+00)
  %26 = load ptr, ptr %colors, align 8
  %arrayidx46 = getelementptr inbounds %struct.ImVec4, ptr %26, i64 23
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx46, ptr align 4 %ref.tmp45, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp47, float noundef 0x3FD99999A0000000, float noundef 0x3FD99999A0000000, float noundef 0x3FECCCCCC0000000, float noundef 0x3FDCCCCCC0000000)
  %27 = load ptr, ptr %colors, align 8
  %arrayidx48 = getelementptr inbounds %struct.ImVec4, ptr %27, i64 24
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx48, ptr align 4 %ref.tmp47, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp49, float noundef 0x3FDCCCCCC0000000, float noundef 0x3FDCCCCCC0000000, float noundef 0x3FECCCCCC0000000, float noundef 0x3FE99999A0000000)
  %28 = load ptr, ptr %colors, align 8
  %arrayidx50 = getelementptr inbounds %struct.ImVec4, ptr %28, i64 25
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx50, ptr align 4 %ref.tmp49, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp51, float noundef 0x3FE0F5C280000000, float noundef 0x3FE0F5C280000000, float noundef 0x3FEBD70A40000000, float noundef 0x3FE99999A0000000)
  %29 = load ptr, ptr %colors, align 8
  %arrayidx52 = getelementptr inbounds %struct.ImVec4, ptr %29, i64 26
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx52, ptr align 4 %ref.tmp51, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp53, float noundef 5.000000e-01, float noundef 5.000000e-01, float noundef 5.000000e-01, float noundef 0x3FE3333340000000)
  %30 = load ptr, ptr %colors, align 8
  %arrayidx54 = getelementptr inbounds %struct.ImVec4, ptr %30, i64 27
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx54, ptr align 4 %ref.tmp53, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp55, float noundef 0x3FE3333340000000, float noundef 0x3FE3333340000000, float noundef 0x3FE6666660000000, float noundef 1.000000e+00)
  %31 = load ptr, ptr %colors, align 8
  %arrayidx56 = getelementptr inbounds %struct.ImVec4, ptr %31, i64 28
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx56, ptr align 4 %ref.tmp55, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp57, float noundef 0x3FE6666660000000, float noundef 0x3FE6666660000000, float noundef 0x3FECCCCCC0000000, float noundef 1.000000e+00)
  %32 = load ptr, ptr %colors, align 8
  %arrayidx58 = getelementptr inbounds %struct.ImVec4, ptr %32, i64 29
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx58, ptr align 4 %ref.tmp57, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp59, float noundef 1.000000e+00, float noundef 1.000000e+00, float noundef 1.000000e+00, float noundef 0x3FB99999A0000000)
  %33 = load ptr, ptr %colors, align 8
  %arrayidx60 = getelementptr inbounds %struct.ImVec4, ptr %33, i64 30
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx60, ptr align 4 %ref.tmp59, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp61, float noundef 0x3FE8F5C280000000, float noundef 0x3FEA3D70A0000000, float noundef 1.000000e+00, float noundef 0x3FE3333340000000)
  %34 = load ptr, ptr %colors, align 8
  %arrayidx62 = getelementptr inbounds %struct.ImVec4, ptr %34, i64 31
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx62, ptr align 4 %ref.tmp61, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp63, float noundef 0x3FE8F5C280000000, float noundef 0x3FEA3D70A0000000, float noundef 1.000000e+00, float noundef 0x3FECCCCCC0000000)
  %35 = load ptr, ptr %colors, align 8
  %arrayidx64 = getelementptr inbounds %struct.ImVec4, ptr %35, i64 32
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx64, ptr align 4 %ref.tmp63, i64 16, i1 false)
  %36 = load ptr, ptr %colors, align 8
  %arrayidx66 = getelementptr inbounds %struct.ImVec4, ptr %36, i64 24
  %37 = load ptr, ptr %colors, align 8
  %arrayidx67 = getelementptr inbounds %struct.ImVec4, ptr %37, i64 11
  %call68 = call { <2 x float>, <2 x float> } @_ZL6ImLerpRK6ImVec4S1_f(ptr noundef nonnull align 4 dereferenceable(16) %arrayidx66, ptr noundef nonnull align 4 dereferenceable(16) %arrayidx67, float noundef 0x3FE99999A0000000)
  %38 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp65, i32 0, i32 0
  %39 = extractvalue { <2 x float>, <2 x float> } %call68, 0
  store <2 x float> %39, ptr %38, align 4
  %40 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp65, i32 0, i32 1
  %41 = extractvalue { <2 x float>, <2 x float> } %call68, 1
  store <2 x float> %41, ptr %40, align 4
  %42 = load ptr, ptr %colors, align 8
  %arrayidx69 = getelementptr inbounds %struct.ImVec4, ptr %42, i64 33
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx69, ptr align 4 %ref.tmp65, i64 16, i1 false)
  %43 = load ptr, ptr %colors, align 8
  %arrayidx70 = getelementptr inbounds %struct.ImVec4, ptr %43, i64 25
  %44 = load ptr, ptr %colors, align 8
  %arrayidx71 = getelementptr inbounds %struct.ImVec4, ptr %44, i64 34
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx71, ptr align 4 %arrayidx70, i64 16, i1 false)
  %45 = load ptr, ptr %colors, align 8
  %arrayidx73 = getelementptr inbounds %struct.ImVec4, ptr %45, i64 26
  %46 = load ptr, ptr %colors, align 8
  %arrayidx74 = getelementptr inbounds %struct.ImVec4, ptr %46, i64 11
  %call75 = call { <2 x float>, <2 x float> } @_ZL6ImLerpRK6ImVec4S1_f(ptr noundef nonnull align 4 dereferenceable(16) %arrayidx73, ptr noundef nonnull align 4 dereferenceable(16) %arrayidx74, float noundef 0x3FE3333340000000)
  %47 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp72, i32 0, i32 0
  %48 = extractvalue { <2 x float>, <2 x float> } %call75, 0
  store <2 x float> %48, ptr %47, align 4
  %49 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp72, i32 0, i32 1
  %50 = extractvalue { <2 x float>, <2 x float> } %call75, 1
  store <2 x float> %50, ptr %49, align 4
  %51 = load ptr, ptr %colors, align 8
  %arrayidx76 = getelementptr inbounds %struct.ImVec4, ptr %51, i64 35
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx76, ptr align 4 %ref.tmp72, i64 16, i1 false)
  %52 = load ptr, ptr %colors, align 8
  %arrayidx78 = getelementptr inbounds %struct.ImVec4, ptr %52, i64 33
  %53 = load ptr, ptr %colors, align 8
  %arrayidx79 = getelementptr inbounds %struct.ImVec4, ptr %53, i64 10
  %call80 = call { <2 x float>, <2 x float> } @_ZL6ImLerpRK6ImVec4S1_f(ptr noundef nonnull align 4 dereferenceable(16) %arrayidx78, ptr noundef nonnull align 4 dereferenceable(16) %arrayidx79, float noundef 0x3FE99999A0000000)
  %54 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp77, i32 0, i32 0
  %55 = extractvalue { <2 x float>, <2 x float> } %call80, 0
  store <2 x float> %55, ptr %54, align 4
  %56 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp77, i32 0, i32 1
  %57 = extractvalue { <2 x float>, <2 x float> } %call80, 1
  store <2 x float> %57, ptr %56, align 4
  %58 = load ptr, ptr %colors, align 8
  %arrayidx81 = getelementptr inbounds %struct.ImVec4, ptr %58, i64 36
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx81, ptr align 4 %ref.tmp77, i64 16, i1 false)
  %59 = load ptr, ptr %colors, align 8
  %arrayidx83 = getelementptr inbounds %struct.ImVec4, ptr %59, i64 35
  %60 = load ptr, ptr %colors, align 8
  %arrayidx84 = getelementptr inbounds %struct.ImVec4, ptr %60, i64 10
  %call85 = call { <2 x float>, <2 x float> } @_ZL6ImLerpRK6ImVec4S1_f(ptr noundef nonnull align 4 dereferenceable(16) %arrayidx83, ptr noundef nonnull align 4 dereferenceable(16) %arrayidx84, float noundef 0x3FD99999A0000000)
  %61 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp82, i32 0, i32 0
  %62 = extractvalue { <2 x float>, <2 x float> } %call85, 0
  store <2 x float> %62, ptr %61, align 4
  %63 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp82, i32 0, i32 1
  %64 = extractvalue { <2 x float>, <2 x float> } %call85, 1
  store <2 x float> %64, ptr %63, align 4
  %65 = load ptr, ptr %colors, align 8
  %arrayidx86 = getelementptr inbounds %struct.ImVec4, ptr %65, i64 37
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx86, ptr align 4 %ref.tmp82, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp87, float noundef 1.000000e+00, float noundef 1.000000e+00, float noundef 1.000000e+00, float noundef 1.000000e+00)
  %66 = load ptr, ptr %colors, align 8
  %arrayidx88 = getelementptr inbounds %struct.ImVec4, ptr %66, i64 38
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx88, ptr align 4 %ref.tmp87, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp89, float noundef 0x3FECCCCCC0000000, float noundef 0x3FE6666660000000, float noundef 0.000000e+00, float noundef 1.000000e+00)
  %67 = load ptr, ptr %colors, align 8
  %arrayidx90 = getelementptr inbounds %struct.ImVec4, ptr %67, i64 39
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx90, ptr align 4 %ref.tmp89, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp91, float noundef 0x3FECCCCCC0000000, float noundef 0x3FE6666660000000, float noundef 0.000000e+00, float noundef 1.000000e+00)
  %68 = load ptr, ptr %colors, align 8
  %arrayidx92 = getelementptr inbounds %struct.ImVec4, ptr %68, i64 40
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx92, ptr align 4 %ref.tmp91, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp93, float noundef 1.000000e+00, float noundef 0x3FE3333340000000, float noundef 0.000000e+00, float noundef 1.000000e+00)
  %69 = load ptr, ptr %colors, align 8
  %arrayidx94 = getelementptr inbounds %struct.ImVec4, ptr %69, i64 41
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx94, ptr align 4 %ref.tmp93, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp95, float noundef 0x3FD147AE20000000, float noundef 0x3FD147AE20000000, float noundef 0x3FD851EB80000000, float noundef 1.000000e+00)
  %70 = load ptr, ptr %colors, align 8
  %arrayidx96 = getelementptr inbounds %struct.ImVec4, ptr %70, i64 42
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx96, ptr align 4 %ref.tmp95, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp97, float noundef 0x3FD3D70A40000000, float noundef 0x3FD3D70A40000000, float noundef 0x3FDCCCCCC0000000, float noundef 1.000000e+00)
  %71 = load ptr, ptr %colors, align 8
  %arrayidx98 = getelementptr inbounds %struct.ImVec4, ptr %71, i64 43
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx98, ptr align 4 %ref.tmp97, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp99, float noundef 0x3FD0A3D700000000, float noundef 0x3FD0A3D700000000, float noundef 0x3FD1EB8520000000, float noundef 1.000000e+00)
  %72 = load ptr, ptr %colors, align 8
  %arrayidx100 = getelementptr inbounds %struct.ImVec4, ptr %72, i64 44
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx100, ptr align 4 %ref.tmp99, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp101, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %73 = load ptr, ptr %colors, align 8
  %arrayidx102 = getelementptr inbounds %struct.ImVec4, ptr %73, i64 45
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx102, ptr align 4 %ref.tmp101, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp103, float noundef 1.000000e+00, float noundef 1.000000e+00, float noundef 1.000000e+00, float noundef 0x3FB1EB8520000000)
  %74 = load ptr, ptr %colors, align 8
  %arrayidx104 = getelementptr inbounds %struct.ImVec4, ptr %74, i64 46
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx104, ptr align 4 %ref.tmp103, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp105, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 1.000000e+00, float noundef 0x3FD6666660000000)
  %75 = load ptr, ptr %colors, align 8
  %arrayidx106 = getelementptr inbounds %struct.ImVec4, ptr %75, i64 47
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx106, ptr align 4 %ref.tmp105, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp107, float noundef 1.000000e+00, float noundef 1.000000e+00, float noundef 0.000000e+00, float noundef 0x3FECCCCCC0000000)
  %76 = load ptr, ptr %colors, align 8
  %arrayidx108 = getelementptr inbounds %struct.ImVec4, ptr %76, i64 48
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx108, ptr align 4 %ref.tmp107, i64 16, i1 false)
  %77 = load ptr, ptr %colors, align 8
  %arrayidx109 = getelementptr inbounds %struct.ImVec4, ptr %77, i64 25
  %78 = load ptr, ptr %colors, align 8
  %arrayidx110 = getelementptr inbounds %struct.ImVec4, ptr %78, i64 49
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx110, ptr align 4 %arrayidx109, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp111, float noundef 1.000000e+00, float noundef 1.000000e+00, float noundef 1.000000e+00, float noundef 0x3FE6666660000000)
  %79 = load ptr, ptr %colors, align 8
  %arrayidx112 = getelementptr inbounds %struct.ImVec4, ptr %79, i64 50
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx112, ptr align 4 %ref.tmp111, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp113, float noundef 0x3FE99999A0000000, float noundef 0x3FE99999A0000000, float noundef 0x3FE99999A0000000, float noundef 0x3FC99999A0000000)
  %80 = load ptr, ptr %colors, align 8
  %arrayidx114 = getelementptr inbounds %struct.ImVec4, ptr %80, i64 51
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx114, ptr align 4 %ref.tmp113, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp115, float noundef 0x3FC99999A0000000, float noundef 0x3FC99999A0000000, float noundef 0x3FC99999A0000000, float noundef 0x3FD6666660000000)
  %81 = load ptr, ptr %colors, align 8
  %arrayidx116 = getelementptr inbounds %struct.ImVec4, ptr %81, i64 52
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx116, ptr align 4 %ref.tmp115, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui16StyleColorsLightEP10ImGuiStyle(ptr noundef %dst) #0 {
entry:
  %dst.addr = alloca ptr, align 8
  %style = alloca ptr, align 8
  %colors = alloca ptr, align 8
  %ref.tmp = alloca %struct.ImVec4, align 4
  %ref.tmp1 = alloca %struct.ImVec4, align 4
  %ref.tmp3 = alloca %struct.ImVec4, align 4
  %ref.tmp5 = alloca %struct.ImVec4, align 4
  %ref.tmp7 = alloca %struct.ImVec4, align 4
  %ref.tmp9 = alloca %struct.ImVec4, align 4
  %ref.tmp11 = alloca %struct.ImVec4, align 4
  %ref.tmp13 = alloca %struct.ImVec4, align 4
  %ref.tmp15 = alloca %struct.ImVec4, align 4
  %ref.tmp17 = alloca %struct.ImVec4, align 4
  %ref.tmp19 = alloca %struct.ImVec4, align 4
  %ref.tmp21 = alloca %struct.ImVec4, align 4
  %ref.tmp23 = alloca %struct.ImVec4, align 4
  %ref.tmp25 = alloca %struct.ImVec4, align 4
  %ref.tmp27 = alloca %struct.ImVec4, align 4
  %ref.tmp29 = alloca %struct.ImVec4, align 4
  %ref.tmp31 = alloca %struct.ImVec4, align 4
  %ref.tmp33 = alloca %struct.ImVec4, align 4
  %ref.tmp35 = alloca %struct.ImVec4, align 4
  %ref.tmp37 = alloca %struct.ImVec4, align 4
  %ref.tmp39 = alloca %struct.ImVec4, align 4
  %ref.tmp41 = alloca %struct.ImVec4, align 4
  %ref.tmp43 = alloca %struct.ImVec4, align 4
  %ref.tmp45 = alloca %struct.ImVec4, align 4
  %ref.tmp47 = alloca %struct.ImVec4, align 4
  %ref.tmp49 = alloca %struct.ImVec4, align 4
  %ref.tmp51 = alloca %struct.ImVec4, align 4
  %ref.tmp53 = alloca %struct.ImVec4, align 4
  %ref.tmp55 = alloca %struct.ImVec4, align 4
  %ref.tmp57 = alloca %struct.ImVec4, align 4
  %ref.tmp59 = alloca %struct.ImVec4, align 4
  %ref.tmp61 = alloca %struct.ImVec4, align 4
  %ref.tmp63 = alloca %struct.ImVec4, align 4
  %ref.tmp65 = alloca %struct.ImVec4, align 4
  %ref.tmp72 = alloca %struct.ImVec4, align 4
  %ref.tmp77 = alloca %struct.ImVec4, align 4
  %ref.tmp82 = alloca %struct.ImVec4, align 4
  %ref.tmp87 = alloca %struct.ImVec4, align 4
  %ref.tmp89 = alloca %struct.ImVec4, align 4
  %ref.tmp91 = alloca %struct.ImVec4, align 4
  %ref.tmp93 = alloca %struct.ImVec4, align 4
  %ref.tmp95 = alloca %struct.ImVec4, align 4
  %ref.tmp97 = alloca %struct.ImVec4, align 4
  %ref.tmp99 = alloca %struct.ImVec4, align 4
  %ref.tmp101 = alloca %struct.ImVec4, align 4
  %ref.tmp103 = alloca %struct.ImVec4, align 4
  %ref.tmp105 = alloca %struct.ImVec4, align 4
  %ref.tmp107 = alloca %struct.ImVec4, align 4
  %ref.tmp111 = alloca %struct.ImVec4, align 4
  %ref.tmp113 = alloca %struct.ImVec4, align 4
  %ref.tmp115 = alloca %struct.ImVec4, align 4
  store ptr %dst, ptr %dst.addr, align 8
  %0 = load ptr, ptr %dst.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load ptr, ptr %dst.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call noundef nonnull align 4 dereferenceable(1096) ptr @_ZN5ImGui8GetStyleEv()
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %1, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %style, align 8
  %2 = load ptr, ptr %style, align 8
  %Colors = getelementptr inbounds %struct.ImGuiStyle, ptr %2, i32 0, i32 45
  %arraydecay = getelementptr inbounds [53 x %struct.ImVec4], ptr %Colors, i64 0, i64 0
  store ptr %arraydecay, ptr %colors, align 8
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 1.000000e+00)
  %3 = load ptr, ptr %colors, align 8
  %arrayidx = getelementptr inbounds %struct.ImVec4, ptr %3, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx, ptr align 4 %ref.tmp, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp1, float noundef 0x3FE3333340000000, float noundef 0x3FE3333340000000, float noundef 0x3FE3333340000000, float noundef 1.000000e+00)
  %4 = load ptr, ptr %colors, align 8
  %arrayidx2 = getelementptr inbounds %struct.ImVec4, ptr %4, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx2, ptr align 4 %ref.tmp1, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp3, float noundef 0x3FEE147AE0000000, float noundef 0x3FEE147AE0000000, float noundef 0x3FEE147AE0000000, float noundef 1.000000e+00)
  %5 = load ptr, ptr %colors, align 8
  %arrayidx4 = getelementptr inbounds %struct.ImVec4, ptr %5, i64 2
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx4, ptr align 4 %ref.tmp3, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp5, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %6 = load ptr, ptr %colors, align 8
  %arrayidx6 = getelementptr inbounds %struct.ImVec4, ptr %6, i64 3
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx6, ptr align 4 %ref.tmp5, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp7, float noundef 1.000000e+00, float noundef 1.000000e+00, float noundef 1.000000e+00, float noundef 0x3FEF5C2900000000)
  %7 = load ptr, ptr %colors, align 8
  %arrayidx8 = getelementptr inbounds %struct.ImVec4, ptr %7, i64 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx8, ptr align 4 %ref.tmp7, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp9, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0x3FD3333340000000)
  %8 = load ptr, ptr %colors, align 8
  %arrayidx10 = getelementptr inbounds %struct.ImVec4, ptr %8, i64 5
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx10, ptr align 4 %ref.tmp9, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp11, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %9 = load ptr, ptr %colors, align 8
  %arrayidx12 = getelementptr inbounds %struct.ImVec4, ptr %9, i64 6
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx12, ptr align 4 %ref.tmp11, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp13, float noundef 1.000000e+00, float noundef 1.000000e+00, float noundef 1.000000e+00, float noundef 1.000000e+00)
  %10 = load ptr, ptr %colors, align 8
  %arrayidx14 = getelementptr inbounds %struct.ImVec4, ptr %10, i64 7
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx14, ptr align 4 %ref.tmp13, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp15, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 0x3FD99999A0000000)
  %11 = load ptr, ptr %colors, align 8
  %arrayidx16 = getelementptr inbounds %struct.ImVec4, ptr %11, i64 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx16, ptr align 4 %ref.tmp15, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp17, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 0x3FE570A3E0000000)
  %12 = load ptr, ptr %colors, align 8
  %arrayidx18 = getelementptr inbounds %struct.ImVec4, ptr %12, i64 9
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx18, ptr align 4 %ref.tmp17, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp19, float noundef 0x3FEEB851E0000000, float noundef 0x3FEEB851E0000000, float noundef 0x3FEEB851E0000000, float noundef 1.000000e+00)
  %13 = load ptr, ptr %colors, align 8
  %arrayidx20 = getelementptr inbounds %struct.ImVec4, ptr %13, i64 10
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx20, ptr align 4 %ref.tmp19, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp21, float noundef 0x3FEA3D70A0000000, float noundef 0x3FEA3D70A0000000, float noundef 0x3FEA3D70A0000000, float noundef 1.000000e+00)
  %14 = load ptr, ptr %colors, align 8
  %arrayidx22 = getelementptr inbounds %struct.ImVec4, ptr %14, i64 11
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx22, ptr align 4 %ref.tmp21, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp23, float noundef 1.000000e+00, float noundef 1.000000e+00, float noundef 1.000000e+00, float noundef 0x3FE051EB80000000)
  %15 = load ptr, ptr %colors, align 8
  %arrayidx24 = getelementptr inbounds %struct.ImVec4, ptr %15, i64 12
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx24, ptr align 4 %ref.tmp23, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp25, float noundef 0x3FEB851EC0000000, float noundef 0x3FEB851EC0000000, float noundef 0x3FEB851EC0000000, float noundef 1.000000e+00)
  %16 = load ptr, ptr %colors, align 8
  %arrayidx26 = getelementptr inbounds %struct.ImVec4, ptr %16, i64 13
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx26, ptr align 4 %ref.tmp25, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp27, float noundef 0x3FEF5C2900000000, float noundef 0x3FEF5C2900000000, float noundef 0x3FEF5C2900000000, float noundef 0x3FE0F5C280000000)
  %17 = load ptr, ptr %colors, align 8
  %arrayidx28 = getelementptr inbounds %struct.ImVec4, ptr %17, i64 14
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx28, ptr align 4 %ref.tmp27, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp29, float noundef 0x3FE6147AE0000000, float noundef 0x3FE6147AE0000000, float noundef 0x3FE6147AE0000000, float noundef 0x3FE99999A0000000)
  %18 = load ptr, ptr %colors, align 8
  %arrayidx30 = getelementptr inbounds %struct.ImVec4, ptr %18, i64 15
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx30, ptr align 4 %ref.tmp29, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp31, float noundef 0x3FDF5C2900000000, float noundef 0x3FDF5C2900000000, float noundef 0x3FDF5C2900000000, float noundef 0x3FE99999A0000000)
  %19 = load ptr, ptr %colors, align 8
  %arrayidx32 = getelementptr inbounds %struct.ImVec4, ptr %19, i64 16
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx32, ptr align 4 %ref.tmp31, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp33, float noundef 0x3FDF5C2900000000, float noundef 0x3FDF5C2900000000, float noundef 0x3FDF5C2900000000, float noundef 1.000000e+00)
  %20 = load ptr, ptr %colors, align 8
  %arrayidx34 = getelementptr inbounds %struct.ImVec4, ptr %20, i64 17
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx34, ptr align 4 %ref.tmp33, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp35, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 1.000000e+00)
  %21 = load ptr, ptr %colors, align 8
  %arrayidx36 = getelementptr inbounds %struct.ImVec4, ptr %21, i64 18
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx36, ptr align 4 %ref.tmp35, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp37, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 0x3FE8F5C280000000)
  %22 = load ptr, ptr %colors, align 8
  %arrayidx38 = getelementptr inbounds %struct.ImVec4, ptr %22, i64 19
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx38, ptr align 4 %ref.tmp37, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp39, float noundef 0x3FDD70A3E0000000, float noundef 0x3FE147AE20000000, float noundef 0x3FE99999A0000000, float noundef 0x3FE3333340000000)
  %23 = load ptr, ptr %colors, align 8
  %arrayidx40 = getelementptr inbounds %struct.ImVec4, ptr %23, i64 20
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx40, ptr align 4 %ref.tmp39, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp41, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 0x3FD99999A0000000)
  %24 = load ptr, ptr %colors, align 8
  %arrayidx42 = getelementptr inbounds %struct.ImVec4, ptr %24, i64 21
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx42, ptr align 4 %ref.tmp41, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp43, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 1.000000e+00)
  %25 = load ptr, ptr %colors, align 8
  %arrayidx44 = getelementptr inbounds %struct.ImVec4, ptr %25, i64 22
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx44, ptr align 4 %ref.tmp43, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp45, float noundef 0x3FAEB851E0000000, float noundef 0x3FE0F5C280000000, float noundef 0x3FEF5C2900000000, float noundef 1.000000e+00)
  %26 = load ptr, ptr %colors, align 8
  %arrayidx46 = getelementptr inbounds %struct.ImVec4, ptr %26, i64 23
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx46, ptr align 4 %ref.tmp45, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp47, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 0x3FD3D70A40000000)
  %27 = load ptr, ptr %colors, align 8
  %arrayidx48 = getelementptr inbounds %struct.ImVec4, ptr %27, i64 24
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx48, ptr align 4 %ref.tmp47, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp49, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 0x3FE99999A0000000)
  %28 = load ptr, ptr %colors, align 8
  %arrayidx50 = getelementptr inbounds %struct.ImVec4, ptr %28, i64 25
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx50, ptr align 4 %ref.tmp49, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp51, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 1.000000e+00)
  %29 = load ptr, ptr %colors, align 8
  %arrayidx52 = getelementptr inbounds %struct.ImVec4, ptr %29, i64 26
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx52, ptr align 4 %ref.tmp51, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp53, float noundef 0x3FD8F5C280000000, float noundef 0x3FD8F5C280000000, float noundef 0x3FD8F5C280000000, float noundef 0x3FE3D70A40000000)
  %30 = load ptr, ptr %colors, align 8
  %arrayidx54 = getelementptr inbounds %struct.ImVec4, ptr %30, i64 27
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx54, ptr align 4 %ref.tmp53, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp55, float noundef 0x3FC1EB8520000000, float noundef 0x3FDC28F5C0000000, float noundef 0x3FE99999A0000000, float noundef 0x3FE8F5C280000000)
  %31 = load ptr, ptr %colors, align 8
  %arrayidx56 = getelementptr inbounds %struct.ImVec4, ptr %31, i64 28
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx56, ptr align 4 %ref.tmp55, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp57, float noundef 0x3FC1EB8520000000, float noundef 0x3FDC28F5C0000000, float noundef 0x3FE99999A0000000, float noundef 1.000000e+00)
  %32 = load ptr, ptr %colors, align 8
  %arrayidx58 = getelementptr inbounds %struct.ImVec4, ptr %32, i64 29
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx58, ptr align 4 %ref.tmp57, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp59, float noundef 0x3FD6666660000000, float noundef 0x3FD6666660000000, float noundef 0x3FD6666660000000, float noundef 0x3FC5C28F60000000)
  %33 = load ptr, ptr %colors, align 8
  %arrayidx60 = getelementptr inbounds %struct.ImVec4, ptr %33, i64 30
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx60, ptr align 4 %ref.tmp59, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp61, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 0x3FE570A3E0000000)
  %34 = load ptr, ptr %colors, align 8
  %arrayidx62 = getelementptr inbounds %struct.ImVec4, ptr %34, i64 31
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx62, ptr align 4 %ref.tmp61, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp63, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 0x3FEE666660000000)
  %35 = load ptr, ptr %colors, align 8
  %arrayidx64 = getelementptr inbounds %struct.ImVec4, ptr %35, i64 32
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx64, ptr align 4 %ref.tmp63, i64 16, i1 false)
  %36 = load ptr, ptr %colors, align 8
  %arrayidx66 = getelementptr inbounds %struct.ImVec4, ptr %36, i64 24
  %37 = load ptr, ptr %colors, align 8
  %arrayidx67 = getelementptr inbounds %struct.ImVec4, ptr %37, i64 11
  %call68 = call { <2 x float>, <2 x float> } @_ZL6ImLerpRK6ImVec4S1_f(ptr noundef nonnull align 4 dereferenceable(16) %arrayidx66, ptr noundef nonnull align 4 dereferenceable(16) %arrayidx67, float noundef 0x3FECCCCCC0000000)
  %38 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp65, i32 0, i32 0
  %39 = extractvalue { <2 x float>, <2 x float> } %call68, 0
  store <2 x float> %39, ptr %38, align 4
  %40 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp65, i32 0, i32 1
  %41 = extractvalue { <2 x float>, <2 x float> } %call68, 1
  store <2 x float> %41, ptr %40, align 4
  %42 = load ptr, ptr %colors, align 8
  %arrayidx69 = getelementptr inbounds %struct.ImVec4, ptr %42, i64 33
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx69, ptr align 4 %ref.tmp65, i64 16, i1 false)
  %43 = load ptr, ptr %colors, align 8
  %arrayidx70 = getelementptr inbounds %struct.ImVec4, ptr %43, i64 25
  %44 = load ptr, ptr %colors, align 8
  %arrayidx71 = getelementptr inbounds %struct.ImVec4, ptr %44, i64 34
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx71, ptr align 4 %arrayidx70, i64 16, i1 false)
  %45 = load ptr, ptr %colors, align 8
  %arrayidx73 = getelementptr inbounds %struct.ImVec4, ptr %45, i64 26
  %46 = load ptr, ptr %colors, align 8
  %arrayidx74 = getelementptr inbounds %struct.ImVec4, ptr %46, i64 11
  %call75 = call { <2 x float>, <2 x float> } @_ZL6ImLerpRK6ImVec4S1_f(ptr noundef nonnull align 4 dereferenceable(16) %arrayidx73, ptr noundef nonnull align 4 dereferenceable(16) %arrayidx74, float noundef 0x3FE3333340000000)
  %47 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp72, i32 0, i32 0
  %48 = extractvalue { <2 x float>, <2 x float> } %call75, 0
  store <2 x float> %48, ptr %47, align 4
  %49 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp72, i32 0, i32 1
  %50 = extractvalue { <2 x float>, <2 x float> } %call75, 1
  store <2 x float> %50, ptr %49, align 4
  %51 = load ptr, ptr %colors, align 8
  %arrayidx76 = getelementptr inbounds %struct.ImVec4, ptr %51, i64 35
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx76, ptr align 4 %ref.tmp72, i64 16, i1 false)
  %52 = load ptr, ptr %colors, align 8
  %arrayidx78 = getelementptr inbounds %struct.ImVec4, ptr %52, i64 33
  %53 = load ptr, ptr %colors, align 8
  %arrayidx79 = getelementptr inbounds %struct.ImVec4, ptr %53, i64 10
  %call80 = call { <2 x float>, <2 x float> } @_ZL6ImLerpRK6ImVec4S1_f(ptr noundef nonnull align 4 dereferenceable(16) %arrayidx78, ptr noundef nonnull align 4 dereferenceable(16) %arrayidx79, float noundef 0x3FE99999A0000000)
  %54 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp77, i32 0, i32 0
  %55 = extractvalue { <2 x float>, <2 x float> } %call80, 0
  store <2 x float> %55, ptr %54, align 4
  %56 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp77, i32 0, i32 1
  %57 = extractvalue { <2 x float>, <2 x float> } %call80, 1
  store <2 x float> %57, ptr %56, align 4
  %58 = load ptr, ptr %colors, align 8
  %arrayidx81 = getelementptr inbounds %struct.ImVec4, ptr %58, i64 36
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx81, ptr align 4 %ref.tmp77, i64 16, i1 false)
  %59 = load ptr, ptr %colors, align 8
  %arrayidx83 = getelementptr inbounds %struct.ImVec4, ptr %59, i64 35
  %60 = load ptr, ptr %colors, align 8
  %arrayidx84 = getelementptr inbounds %struct.ImVec4, ptr %60, i64 10
  %call85 = call { <2 x float>, <2 x float> } @_ZL6ImLerpRK6ImVec4S1_f(ptr noundef nonnull align 4 dereferenceable(16) %arrayidx83, ptr noundef nonnull align 4 dereferenceable(16) %arrayidx84, float noundef 0x3FD99999A0000000)
  %61 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp82, i32 0, i32 0
  %62 = extractvalue { <2 x float>, <2 x float> } %call85, 0
  store <2 x float> %62, ptr %61, align 4
  %63 = getelementptr inbounds { <2 x float>, <2 x float> }, ptr %ref.tmp82, i32 0, i32 1
  %64 = extractvalue { <2 x float>, <2 x float> } %call85, 1
  store <2 x float> %64, ptr %63, align 4
  %65 = load ptr, ptr %colors, align 8
  %arrayidx86 = getelementptr inbounds %struct.ImVec4, ptr %65, i64 37
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx86, ptr align 4 %ref.tmp82, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp87, float noundef 0x3FD8F5C280000000, float noundef 0x3FD8F5C280000000, float noundef 0x3FD8F5C280000000, float noundef 1.000000e+00)
  %66 = load ptr, ptr %colors, align 8
  %arrayidx88 = getelementptr inbounds %struct.ImVec4, ptr %66, i64 38
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx88, ptr align 4 %ref.tmp87, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp89, float noundef 1.000000e+00, float noundef 0x3FDB851EC0000000, float noundef 0x3FD6666660000000, float noundef 1.000000e+00)
  %67 = load ptr, ptr %colors, align 8
  %arrayidx90 = getelementptr inbounds %struct.ImVec4, ptr %67, i64 39
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx90, ptr align 4 %ref.tmp89, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp91, float noundef 0x3FECCCCCC0000000, float noundef 0x3FE6666660000000, float noundef 0.000000e+00, float noundef 1.000000e+00)
  %68 = load ptr, ptr %colors, align 8
  %arrayidx92 = getelementptr inbounds %struct.ImVec4, ptr %68, i64 40
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx92, ptr align 4 %ref.tmp91, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp93, float noundef 1.000000e+00, float noundef 0x3FDCCCCCC0000000, float noundef 0.000000e+00, float noundef 1.000000e+00)
  %69 = load ptr, ptr %colors, align 8
  %arrayidx94 = getelementptr inbounds %struct.ImVec4, ptr %69, i64 41
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx94, ptr align 4 %ref.tmp93, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp95, float noundef 0x3FE8F5C280000000, float noundef 0x3FEBD70A40000000, float noundef 0x3FEF5C2900000000, float noundef 1.000000e+00)
  %70 = load ptr, ptr %colors, align 8
  %arrayidx96 = getelementptr inbounds %struct.ImVec4, ptr %70, i64 42
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx96, ptr align 4 %ref.tmp95, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp97, float noundef 0x3FE23D70A0000000, float noundef 0x3FE23D70A0000000, float noundef 0x3FE47AE140000000, float noundef 1.000000e+00)
  %71 = load ptr, ptr %colors, align 8
  %arrayidx98 = getelementptr inbounds %struct.ImVec4, ptr %71, i64 43
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx98, ptr align 4 %ref.tmp97, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp99, float noundef 0x3FE5C28F60000000, float noundef 0x3FE5C28F60000000, float noundef 0x3FE7AE1480000000, float noundef 1.000000e+00)
  %72 = load ptr, ptr %colors, align 8
  %arrayidx100 = getelementptr inbounds %struct.ImVec4, ptr %72, i64 44
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx100, ptr align 4 %ref.tmp99, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp101, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %73 = load ptr, ptr %colors, align 8
  %arrayidx102 = getelementptr inbounds %struct.ImVec4, ptr %73, i64 45
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx102, ptr align 4 %ref.tmp101, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp103, float noundef 0x3FD3333340000000, float noundef 0x3FD3333340000000, float noundef 0x3FD3333340000000, float noundef 0x3FB70A3D80000000)
  %74 = load ptr, ptr %colors, align 8
  %arrayidx104 = getelementptr inbounds %struct.ImVec4, ptr %74, i64 46
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx104, ptr align 4 %ref.tmp103, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp105, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 0x3FD6666660000000)
  %75 = load ptr, ptr %colors, align 8
  %arrayidx106 = getelementptr inbounds %struct.ImVec4, ptr %75, i64 47
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx106, ptr align 4 %ref.tmp105, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp107, float noundef 0x3FD0A3D700000000, float noundef 0x3FE2E147A0000000, float noundef 0x3FEF5C2900000000, float noundef 0x3FEE666660000000)
  %76 = load ptr, ptr %colors, align 8
  %arrayidx108 = getelementptr inbounds %struct.ImVec4, ptr %76, i64 48
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx108, ptr align 4 %ref.tmp107, i64 16, i1 false)
  %77 = load ptr, ptr %colors, align 8
  %arrayidx109 = getelementptr inbounds %struct.ImVec4, ptr %77, i64 25
  %78 = load ptr, ptr %colors, align 8
  %arrayidx110 = getelementptr inbounds %struct.ImVec4, ptr %78, i64 49
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx110, ptr align 4 %arrayidx109, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp111, float noundef 0x3FE6666660000000, float noundef 0x3FE6666660000000, float noundef 0x3FE6666660000000, float noundef 0x3FE6666660000000)
  %79 = load ptr, ptr %colors, align 8
  %arrayidx112 = getelementptr inbounds %struct.ImVec4, ptr %79, i64 50
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx112, ptr align 4 %ref.tmp111, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp113, float noundef 0x3FC99999A0000000, float noundef 0x3FC99999A0000000, float noundef 0x3FC99999A0000000, float noundef 0x3FC99999A0000000)
  %80 = load ptr, ptr %colors, align 8
  %arrayidx114 = getelementptr inbounds %struct.ImVec4, ptr %80, i64 51
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx114, ptr align 4 %ref.tmp113, i64 16, i1 false)
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp115, float noundef 0x3FC99999A0000000, float noundef 0x3FC99999A0000000, float noundef 0x3FC99999A0000000, float noundef 0x3FD6666660000000)
  %81 = load ptr, ptr %colors, align 8
  %arrayidx116 = getelementptr inbounds %struct.ImVec4, ptr %81, i64 52
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx116, ptr align 4 %ref.tmp115, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN20ImDrawListSharedDataC2Ev(ptr noundef nonnull align 8 dereferenceable(528) %this) unnamed_addr #4 align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %i = alloca i32, align 4
  %a = alloca float, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %TexUvWhitePixel = getelementptr inbounds %struct.ImDrawListSharedData, ptr %this1, i32 0, i32 0
  call void @_ZN6ImVec2C2Ev(ptr noundef nonnull align 4 dereferenceable(8) %TexUvWhitePixel)
  %ClipRectFullscreen = getelementptr inbounds %struct.ImDrawListSharedData, ptr %this1, i32 0, i32 5
  call void @_ZN6ImVec4C2Ev(ptr noundef nonnull align 4 dereferenceable(16) %ClipRectFullscreen)
  %TempBuffer = getelementptr inbounds %struct.ImDrawListSharedData, ptr %this1, i32 0, i32 7
  call void @_ZN8ImVectorI6ImVec2EC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %TempBuffer)
  %ArcFastVtx = getelementptr inbounds %struct.ImDrawListSharedData, ptr %this1, i32 0, i32 8
  %array.begin = getelementptr inbounds [48 x %struct.ImVec2], ptr %ArcFastVtx, i32 0, i32 0
  %arrayctor.end = getelementptr inbounds %struct.ImVec2, ptr %array.begin, i64 48
  br label %arrayctor.loop

arrayctor.loop:                                   ; preds = %invoke.cont, %entry
  %arrayctor.cur = phi ptr [ %array.begin, %entry ], [ %arrayctor.next, %invoke.cont ]
  invoke void @_ZN6ImVec2C2Ev(ptr noundef nonnull align 4 dereferenceable(8) %arrayctor.cur)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %arrayctor.loop
  %arrayctor.next = getelementptr inbounds %struct.ImVec2, ptr %arrayctor.cur, i64 1
  %arrayctor.done = icmp eq ptr %arrayctor.next, %arrayctor.end
  br i1 %arrayctor.done, label %arrayctor.cont, label %arrayctor.loop

arrayctor.cont:                                   ; preds = %invoke.cont
  call void @llvm.memset.p0.i64(ptr align 8 %this1, i8 0, i64 528, i1 false)
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %arrayctor.cont
  %0 = load i32, ptr %i, align 4
  %cmp = icmp slt i32 %0, 48
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %i, align 4
  %conv = sitofp i32 %1 to float
  %mul = fmul float %conv, 2.000000e+00
  %mul2 = fmul float %mul, 0x400921FB60000000
  %div = fdiv float %mul2, 4.800000e+01
  store float %div, ptr %a, align 4
  %2 = load float, ptr %a, align 4
  %call = call float @cosf(float noundef %2) #12
  %3 = load float, ptr %a, align 4
  %call3 = call float @sinf(float noundef %3) #12
  invoke void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef %call, float noundef %call3)
          to label %invoke.cont4 unwind label %lpad

invoke.cont4:                                     ; preds = %for.body
  %ArcFastVtx5 = getelementptr inbounds %struct.ImDrawListSharedData, ptr %this1, i32 0, i32 8
  %4 = load i32, ptr %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds [48 x %struct.ImVec2], ptr %ArcFastVtx5, i64 0, i64 %idxprom
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arrayidx, ptr align 4 %ref.tmp, i64 8, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %invoke.cont4
  %5 = load i32, ptr %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !4

lpad:                                             ; preds = %for.end, %for.body, %arrayctor.loop
  %6 = landingpad { ptr, i32 }
          cleanup
  %7 = extractvalue { ptr, i32 } %6, 0
  store ptr %7, ptr %exn.slot, align 8
  %8 = extractvalue { ptr, i32 } %6, 1
  store i32 %8, ptr %ehselector.slot, align 4
  call void @_ZN8ImVectorI6ImVec2ED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %TempBuffer) #12
  br label %eh.resume

for.end:                                          ; preds = %for.cond
  %CircleSegmentMaxError = getelementptr inbounds %struct.ImDrawListSharedData, ptr %this1, i32 0, i32 4
  %9 = load float, ptr %CircleSegmentMaxError, align 8
  %call7 = invoke noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef 4.800000e+01, float noundef 0x400921FB60000000)
          to label %invoke.cont6 unwind label %lpad

invoke.cont6:                                     ; preds = %for.end
  %div8 = fdiv float 0x400921FB60000000, %call7
  %call9 = call float @cosf(float noundef %div8) #12
  %sub = fsub float 1.000000e+00, %call9
  %div10 = fdiv float %9, %sub
  %ArcFastRadiusCutoff = getelementptr inbounds %struct.ImDrawListSharedData, ptr %this1, i32 0, i32 9
  store float %div10, ptr %ArcFastRadiusCutoff, align 8
  ret void

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val11 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val11
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN6ImVec2C2Ev(ptr noundef nonnull align 4 dereferenceable(8) %this) unnamed_addr #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %this1, i32 0, i32 0
  store float 0.000000e+00, ptr %x, align 4
  %y = getelementptr inbounds %struct.ImVec2, ptr %this1, i32 0, i32 1
  store float 0.000000e+00, ptr %y, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN6ImVec4C2Ev(ptr noundef nonnull align 4 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %x = getelementptr inbounds %struct.ImVec4, ptr %this1, i32 0, i32 0
  store float 0.000000e+00, ptr %x, align 4
  %y = getelementptr inbounds %struct.ImVec4, ptr %this1, i32 0, i32 1
  store float 0.000000e+00, ptr %y, align 4
  %z = getelementptr inbounds %struct.ImVec4, ptr %this1, i32 0, i32 2
  store float 0.000000e+00, ptr %z, align 4
  %w = getelementptr inbounds %struct.ImVec4, ptr %this1, i32 0, i32 3
  store float 0.000000e+00, ptr %w, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI6ImVec2EC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data, align 8
  ret void
}

declare i32 @__gxx_personality_v0(...)

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #5

; Function Attrs: nounwind
declare float @cosf(float noundef) #6

; Function Attrs: nounwind
declare float @sinf(float noundef) #6

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %this, float noundef %_x, float noundef %_y) unnamed_addr #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %_x.addr = alloca float, align 4
  %_y.addr = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  store float %_x, ptr %_x.addr, align 4
  store float %_y, ptr %_y.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %this1, i32 0, i32 0
  %0 = load float, ptr %_x.addr, align 4
  store float %0, ptr %x, align 4
  %y = getelementptr inbounds %struct.ImVec2, ptr %this1, i32 0, i32 1
  %1 = load float, ptr %_y.addr, align 4
  store float %1, ptr %y, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %lhs, float noundef %rhs) #2 {
entry:
  %lhs.addr = alloca float, align 4
  %rhs.addr = alloca float, align 4
  store float %lhs, ptr %lhs.addr, align 4
  store float %rhs, ptr %rhs.addr, align 4
  %0 = load float, ptr %lhs.addr, align 4
  %1 = load float, ptr %rhs.addr, align 4
  %cmp = fcmp oge float %0, %1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load float, ptr %lhs.addr, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load float, ptr %rhs.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %2, %cond.true ], [ %3, %cond.false ]
  ret float %cond
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI6ImVec2ED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Data2 = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  invoke void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %invoke.cont, %entry
  ret void

terminate.lpad:                                   ; preds = %if.then
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #13
  unreachable
}

; Function Attrs: mustprogress uwtable
define void @_ZN20ImDrawListSharedData29SetCircleTessellationMaxErrorEf(ptr noundef nonnull align 8 dereferenceable(528) %this, float noundef %max_error) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %max_error.addr = alloca float, align 4
  %i = alloca i32, align 4
  %radius = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  store float %max_error, ptr %max_error.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %CircleSegmentMaxError = getelementptr inbounds %struct.ImDrawListSharedData, ptr %this1, i32 0, i32 4
  %0 = load float, ptr %CircleSegmentMaxError, align 8
  %1 = load float, ptr %max_error.addr, align 4
  %cmp = fcmp oeq float %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load float, ptr %max_error.addr, align 4
  %CircleSegmentMaxError2 = getelementptr inbounds %struct.ImDrawListSharedData, ptr %this1, i32 0, i32 4
  store float %2, ptr %CircleSegmentMaxError2, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, ptr %i, align 4
  %cmp3 = icmp slt i32 %3, 64
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i32, ptr %i, align 4
  %conv = sitofp i32 %4 to float
  store float %conv, ptr %radius, align 4
  %5 = load i32, ptr %i, align 4
  %cmp4 = icmp sgt i32 %5, 0
  br i1 %cmp4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %CircleSegmentMaxError5 = getelementptr inbounds %struct.ImDrawListSharedData, ptr %this1, i32 0, i32 4
  %6 = load float, ptr %CircleSegmentMaxError5, align 8
  %7 = load float, ptr %radius, align 4
  %call = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %6, float noundef %7)
  %8 = load float, ptr %radius, align 4
  %div = fdiv float %call, %8
  %sub = fsub float 1.000000e+00, %div
  %call6 = call float @acosf(float noundef %sub) #12
  %div7 = fdiv float 0x400921FB60000000, %call6
  %9 = call float @llvm.ceil.f32(float %div7)
  %conv8 = fptosi float %9 to i32
  %add = add nsw i32 %conv8, 1
  %div9 = sdiv i32 %add, 2
  %mul = mul nsw i32 %div9, 2
  %call10 = call noundef i32 @_ZL7ImClampIiET_S0_S0_S0_(i32 noundef %mul, i32 noundef 4, i32 noundef 512)
  br label %cond.end

cond.false:                                       ; preds = %for.body
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %call10, %cond.true ], [ 48, %cond.false ]
  %conv11 = trunc i32 %cond to i8
  %CircleSegmentCounts = getelementptr inbounds %struct.ImDrawListSharedData, ptr %this1, i32 0, i32 10
  %10 = load i32, ptr %i, align 4
  %idxprom = sext i32 %10 to i64
  %arrayidx = getelementptr inbounds [64 x i8], ptr %CircleSegmentCounts, i64 0, i64 %idxprom
  store i8 %conv11, ptr %arrayidx, align 1
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %11 = load i32, ptr %i, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !6

for.end:                                          ; preds = %for.cond
  %CircleSegmentMaxError12 = getelementptr inbounds %struct.ImDrawListSharedData, ptr %this1, i32 0, i32 4
  %12 = load float, ptr %CircleSegmentMaxError12, align 8
  %call13 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef 4.800000e+01, float noundef 0x400921FB60000000)
  %div14 = fdiv float 0x400921FB60000000, %call13
  %call15 = call float @cosf(float noundef %div14) #12
  %sub16 = fsub float 1.000000e+00, %call15
  %div17 = fdiv float %12, %sub16
  %ArcFastRadiusCutoff = getelementptr inbounds %struct.ImDrawListSharedData, ptr %this1, i32 0, i32 9
  store float %div17, ptr %ArcFastRadiusCutoff, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZL7ImClampIiET_S0_S0_S0_(i32 noundef %v, i32 noundef %mn, i32 noundef %mx) #2 {
entry:
  %v.addr = alloca i32, align 4
  %mn.addr = alloca i32, align 4
  %mx.addr = alloca i32, align 4
  store i32 %v, ptr %v.addr, align 4
  store i32 %mn, ptr %mn.addr, align 4
  store i32 %mx, ptr %mx.addr, align 4
  %0 = load i32, ptr %v.addr, align 4
  %1 = load i32, ptr %mn.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load i32, ptr %mn.addr, align 4
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %3 = load i32, ptr %v.addr, align 4
  %4 = load i32, ptr %mx.addr, align 4
  %cmp1 = icmp sgt i32 %3, %4
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %5 = load i32, ptr %mx.addr, align 4
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  %6 = load i32, ptr %v.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi i32 [ %5, %cond.true2 ], [ %6, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi i32 [ %2, %cond.true ], [ %cond, %cond.end ]
  ret i32 %cond5
}

; Function Attrs: nounwind
declare float @acosf(float noundef) #6

; Function Attrs: mustprogress nounwind uwtable
define internal noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %lhs, float noundef %rhs) #2 {
entry:
  %lhs.addr = alloca float, align 4
  %rhs.addr = alloca float, align 4
  store float %lhs, ptr %lhs.addr, align 4
  store float %rhs, ptr %rhs.addr, align 4
  %0 = load float, ptr %lhs.addr, align 4
  %1 = load float, ptr %rhs.addr, align 4
  %cmp = fcmp olt float %0, %1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load float, ptr %lhs.addr, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load float, ptr %rhs.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %2, %cond.true ], [ %3, %cond.false ]
  ret float %cond
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.ceil.f32(float) #7

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList17_ResetForNewFrameEv(ptr noundef nonnull align 8 dereferenceable(196) %this) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %struct.ImDrawCmd, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %_Splitter = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 13
  %_Count = getelementptr inbounds %struct.ImDrawListSplitter, ptr %_Splitter, i32 0, i32 1
  %0 = load i32, ptr %_Count, align 4
  %cmp = icmp sgt i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %_Splitter2 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 13
  call void @_ZN18ImDrawListSplitter5MergeEP10ImDrawList(ptr noundef nonnull align 8 dereferenceable(24) %_Splitter2, ptr noundef %this1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %CmdBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  call void @_ZN8ImVectorI9ImDrawCmdE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %CmdBuffer, i32 noundef 0)
  %IdxBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 1
  call void @_ZN8ImVectorItE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %IdxBuffer, i32 noundef 0)
  %VtxBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 2
  call void @_ZN8ImVectorI10ImDrawVertE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %VtxBuffer, i32 noundef 0)
  %_Data = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  %1 = load ptr, ptr %_Data, align 8
  %InitialFlags = getelementptr inbounds %struct.ImDrawListSharedData, ptr %1, i32 0, i32 6
  %2 = load i32, ptr %InitialFlags, align 4
  %Flags = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 3
  store i32 %2, ptr %Flags, align 8
  %_CmdHeader = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 12
  call void @llvm.memset.p0.i64(ptr align 8 %_CmdHeader, i8 0, i64 32, i1 false)
  %_VtxCurrentIdx = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  store i32 0, ptr %_VtxCurrentIdx, align 4
  %_VtxWritePtr = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  store ptr null, ptr %_VtxWritePtr, align 8
  %_IdxWritePtr = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  store ptr null, ptr %_IdxWritePtr, align 8
  %_ClipRectStack = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 9
  call void @_ZN8ImVectorI6ImVec4E6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %_ClipRectStack, i32 noundef 0)
  %_TextureIdStack = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 10
  call void @_ZN8ImVectorIPvE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %_TextureIdStack, i32 noundef 0)
  %_Path = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  call void @_ZN8ImVectorI6ImVec2E6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %_Path, i32 noundef 0)
  %_Splitter3 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 13
  call void @_ZN18ImDrawListSplitter5ClearEv(ptr noundef nonnull align 8 dereferenceable(24) %_Splitter3)
  %CmdBuffer4 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  call void @_ZN9ImDrawCmdC2Ev(ptr noundef nonnull align 8 dereferenceable(56) %ref.tmp)
  call void @_ZN8ImVectorI9ImDrawCmdE9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %CmdBuffer4, ptr noundef nonnull align 8 dereferenceable(56) %ref.tmp)
  %_FringeScale = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 14
  store float 1.000000e+00, ptr %_FringeScale, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN18ImDrawListSplitter5MergeEP10ImDrawList(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %draw_list) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %draw_list.addr = alloca ptr, align 8
  %new_cmd_buffer_count = alloca i32, align 4
  %new_idx_buffer_count = alloca i32, align 4
  %last_cmd = alloca ptr, align 8
  %idx_offset = alloca i32, align 4
  %i = alloca i32, align 4
  %ch = alloca ptr, align 8
  %next_cmd = alloca ptr, align 8
  %cmd_n = alloca i32, align 4
  %cmd_write = alloca ptr, align 8
  %idx_write = alloca ptr, align 8
  %i105 = alloca i32, align 4
  %ch110 = alloca ptr, align 8
  %sz = alloca i32, align 4
  %sz122 = alloca i32, align 4
  %curr_cmd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %draw_list, ptr %draw_list.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %_Count = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %_Count, align 4
  %cmp = icmp sle i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %draw_list.addr, align 8
  call void @_ZN18ImDrawListSplitter17SetCurrentChannelEP10ImDrawListi(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %1, i32 noundef 0)
  %2 = load ptr, ptr %draw_list.addr, align 8
  call void @_ZN10ImDrawList17_PopUnusedDrawCmdEv(ptr noundef nonnull align 8 dereferenceable(196) %2)
  store i32 0, ptr %new_cmd_buffer_count, align 4
  store i32 0, ptr %new_idx_buffer_count, align 4
  %_Count2 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 1
  %3 = load i32, ptr %_Count2, align 4
  %cmp3 = icmp sgt i32 %3, 0
  br i1 %cmp3, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %if.end
  %4 = load ptr, ptr %draw_list.addr, align 8
  %CmdBuffer = getelementptr inbounds %struct.ImDrawList, ptr %4, i32 0, i32 0
  %Size = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer, i32 0, i32 0
  %5 = load i32, ptr %Size, align 8
  %cmp4 = icmp sgt i32 %5, 0
  br i1 %cmp4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %6 = load ptr, ptr %draw_list.addr, align 8
  %CmdBuffer5 = getelementptr inbounds %struct.ImDrawList, ptr %6, i32 0, i32 0
  %call = call noundef nonnull align 8 dereferenceable(56) ptr @_ZN8ImVectorI9ImDrawCmdE4backEv(ptr noundef nonnull align 8 dereferenceable(16) %CmdBuffer5)
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %last_cmd, align 8
  %7 = load ptr, ptr %last_cmd, align 8
  %tobool = icmp ne ptr %7, null
  br i1 %tobool, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.end
  %8 = load ptr, ptr %last_cmd, align 8
  %IdxOffset = getelementptr inbounds %struct.ImDrawCmd, ptr %8, i32 0, i32 3
  %9 = load i32, ptr %IdxOffset, align 4
  %10 = load ptr, ptr %last_cmd, align 8
  %ElemCount = getelementptr inbounds %struct.ImDrawCmd, ptr %10, i32 0, i32 4
  %11 = load i32, ptr %ElemCount, align 8
  %add = add i32 %9, %11
  br label %cond.end8

cond.false7:                                      ; preds = %cond.end
  br label %cond.end8

cond.end8:                                        ; preds = %cond.false7, %cond.true6
  %cond9 = phi i32 [ %add, %cond.true6 ], [ 0, %cond.false7 ]
  store i32 %cond9, ptr %idx_offset, align 4
  store i32 1, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc80, %cond.end8
  %12 = load i32, ptr %i, align 4
  %_Count10 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 1
  %13 = load i32, ptr %_Count10, align 4
  %cmp11 = icmp slt i32 %12, %13
  br i1 %cmp11, label %for.body, label %for.end82

for.body:                                         ; preds = %for.cond
  %_Channels = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 2
  %14 = load i32, ptr %i, align 4
  %call12 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN8ImVectorI13ImDrawChannelEixEi(ptr noundef nonnull align 8 dereferenceable(16) %_Channels, i32 noundef %14)
  store ptr %call12, ptr %ch, align 8
  %15 = load ptr, ptr %ch, align 8
  %_CmdBuffer = getelementptr inbounds %struct.ImDrawChannel, ptr %15, i32 0, i32 0
  %Size13 = getelementptr inbounds %struct.ImVector.0, ptr %_CmdBuffer, i32 0, i32 0
  %16 = load i32, ptr %Size13, align 8
  %cmp14 = icmp sgt i32 %16, 0
  br i1 %cmp14, label %land.lhs.true15, label %if.end26

land.lhs.true15:                                  ; preds = %for.body
  %17 = load ptr, ptr %ch, align 8
  %_CmdBuffer16 = getelementptr inbounds %struct.ImDrawChannel, ptr %17, i32 0, i32 0
  %call17 = call noundef nonnull align 8 dereferenceable(56) ptr @_ZN8ImVectorI9ImDrawCmdE4backEv(ptr noundef nonnull align 8 dereferenceable(16) %_CmdBuffer16)
  %ElemCount18 = getelementptr inbounds %struct.ImDrawCmd, ptr %call17, i32 0, i32 4
  %18 = load i32, ptr %ElemCount18, align 8
  %cmp19 = icmp eq i32 %18, 0
  br i1 %cmp19, label %land.lhs.true20, label %if.end26

land.lhs.true20:                                  ; preds = %land.lhs.true15
  %19 = load ptr, ptr %ch, align 8
  %_CmdBuffer21 = getelementptr inbounds %struct.ImDrawChannel, ptr %19, i32 0, i32 0
  %call22 = call noundef nonnull align 8 dereferenceable(56) ptr @_ZN8ImVectorI9ImDrawCmdE4backEv(ptr noundef nonnull align 8 dereferenceable(16) %_CmdBuffer21)
  %UserCallback = getelementptr inbounds %struct.ImDrawCmd, ptr %call22, i32 0, i32 5
  %20 = load ptr, ptr %UserCallback, align 8
  %cmp23 = icmp eq ptr %20, null
  br i1 %cmp23, label %if.then24, label %if.end26

if.then24:                                        ; preds = %land.lhs.true20
  %21 = load ptr, ptr %ch, align 8
  %_CmdBuffer25 = getelementptr inbounds %struct.ImDrawChannel, ptr %21, i32 0, i32 0
  call void @_ZN8ImVectorI9ImDrawCmdE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(16) %_CmdBuffer25)
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %land.lhs.true20, %land.lhs.true15, %for.body
  %22 = load ptr, ptr %ch, align 8
  %_CmdBuffer27 = getelementptr inbounds %struct.ImDrawChannel, ptr %22, i32 0, i32 0
  %Size28 = getelementptr inbounds %struct.ImVector.0, ptr %_CmdBuffer27, i32 0, i32 0
  %23 = load i32, ptr %Size28, align 8
  %cmp29 = icmp sgt i32 %23, 0
  br i1 %cmp29, label %land.lhs.true30, label %if.end53

land.lhs.true30:                                  ; preds = %if.end26
  %24 = load ptr, ptr %last_cmd, align 8
  %cmp31 = icmp ne ptr %24, null
  br i1 %cmp31, label %if.then32, label %if.end53

if.then32:                                        ; preds = %land.lhs.true30
  %25 = load ptr, ptr %ch, align 8
  %_CmdBuffer33 = getelementptr inbounds %struct.ImDrawChannel, ptr %25, i32 0, i32 0
  %call34 = call noundef nonnull align 8 dereferenceable(56) ptr @_ZN8ImVectorI9ImDrawCmdEixEi(ptr noundef nonnull align 8 dereferenceable(16) %_CmdBuffer33, i32 noundef 0)
  store ptr %call34, ptr %next_cmd, align 8
  %26 = load ptr, ptr %last_cmd, align 8
  %27 = load ptr, ptr %next_cmd, align 8
  %call35 = call i32 @memcmp(ptr noundef %26, ptr noundef %27, i64 noundef 28) #14
  %cmp36 = icmp eq i32 %call35, 0
  br i1 %cmp36, label %land.lhs.true37, label %if.end52

land.lhs.true37:                                  ; preds = %if.then32
  %28 = load ptr, ptr %last_cmd, align 8
  %UserCallback38 = getelementptr inbounds %struct.ImDrawCmd, ptr %28, i32 0, i32 5
  %29 = load ptr, ptr %UserCallback38, align 8
  %cmp39 = icmp eq ptr %29, null
  br i1 %cmp39, label %land.lhs.true40, label %if.end52

land.lhs.true40:                                  ; preds = %land.lhs.true37
  %30 = load ptr, ptr %next_cmd, align 8
  %UserCallback41 = getelementptr inbounds %struct.ImDrawCmd, ptr %30, i32 0, i32 5
  %31 = load ptr, ptr %UserCallback41, align 8
  %cmp42 = icmp eq ptr %31, null
  br i1 %cmp42, label %if.then43, label %if.end52

if.then43:                                        ; preds = %land.lhs.true40
  %32 = load ptr, ptr %next_cmd, align 8
  %ElemCount44 = getelementptr inbounds %struct.ImDrawCmd, ptr %32, i32 0, i32 4
  %33 = load i32, ptr %ElemCount44, align 8
  %34 = load ptr, ptr %last_cmd, align 8
  %ElemCount45 = getelementptr inbounds %struct.ImDrawCmd, ptr %34, i32 0, i32 4
  %35 = load i32, ptr %ElemCount45, align 8
  %add46 = add i32 %35, %33
  store i32 %add46, ptr %ElemCount45, align 8
  %36 = load ptr, ptr %next_cmd, align 8
  %ElemCount47 = getelementptr inbounds %struct.ImDrawCmd, ptr %36, i32 0, i32 4
  %37 = load i32, ptr %ElemCount47, align 8
  %38 = load i32, ptr %idx_offset, align 4
  %add48 = add i32 %38, %37
  store i32 %add48, ptr %idx_offset, align 4
  %39 = load ptr, ptr %ch, align 8
  %_CmdBuffer49 = getelementptr inbounds %struct.ImDrawChannel, ptr %39, i32 0, i32 0
  %40 = load ptr, ptr %ch, align 8
  %_CmdBuffer50 = getelementptr inbounds %struct.ImDrawChannel, ptr %40, i32 0, i32 0
  %Data = getelementptr inbounds %struct.ImVector.0, ptr %_CmdBuffer50, i32 0, i32 2
  %41 = load ptr, ptr %Data, align 8
  %call51 = call noundef ptr @_ZN8ImVectorI9ImDrawCmdE5eraseEPKS0_(ptr noundef nonnull align 8 dereferenceable(16) %_CmdBuffer49, ptr noundef %41)
  br label %if.end52

if.end52:                                         ; preds = %if.then43, %land.lhs.true40, %land.lhs.true37, %if.then32
  br label %if.end53

if.end53:                                         ; preds = %if.end52, %land.lhs.true30, %if.end26
  %42 = load ptr, ptr %ch, align 8
  %_CmdBuffer54 = getelementptr inbounds %struct.ImDrawChannel, ptr %42, i32 0, i32 0
  %Size55 = getelementptr inbounds %struct.ImVector.0, ptr %_CmdBuffer54, i32 0, i32 0
  %43 = load i32, ptr %Size55, align 8
  %cmp56 = icmp sgt i32 %43, 0
  br i1 %cmp56, label %if.then57, label %if.end60

if.then57:                                        ; preds = %if.end53
  %44 = load ptr, ptr %ch, align 8
  %_CmdBuffer58 = getelementptr inbounds %struct.ImDrawChannel, ptr %44, i32 0, i32 0
  %call59 = call noundef nonnull align 8 dereferenceable(56) ptr @_ZN8ImVectorI9ImDrawCmdE4backEv(ptr noundef nonnull align 8 dereferenceable(16) %_CmdBuffer58)
  store ptr %call59, ptr %last_cmd, align 8
  br label %if.end60

if.end60:                                         ; preds = %if.then57, %if.end53
  %45 = load ptr, ptr %ch, align 8
  %_CmdBuffer61 = getelementptr inbounds %struct.ImDrawChannel, ptr %45, i32 0, i32 0
  %Size62 = getelementptr inbounds %struct.ImVector.0, ptr %_CmdBuffer61, i32 0, i32 0
  %46 = load i32, ptr %Size62, align 8
  %47 = load i32, ptr %new_cmd_buffer_count, align 4
  %add63 = add nsw i32 %47, %46
  store i32 %add63, ptr %new_cmd_buffer_count, align 4
  %48 = load ptr, ptr %ch, align 8
  %_IdxBuffer = getelementptr inbounds %struct.ImDrawChannel, ptr %48, i32 0, i32 1
  %Size64 = getelementptr inbounds %struct.ImVector.1, ptr %_IdxBuffer, i32 0, i32 0
  %49 = load i32, ptr %Size64, align 8
  %50 = load i32, ptr %new_idx_buffer_count, align 4
  %add65 = add nsw i32 %50, %49
  store i32 %add65, ptr %new_idx_buffer_count, align 4
  store i32 0, ptr %cmd_n, align 4
  br label %for.cond66

for.cond66:                                       ; preds = %for.inc, %if.end60
  %51 = load i32, ptr %cmd_n, align 4
  %52 = load ptr, ptr %ch, align 8
  %_CmdBuffer67 = getelementptr inbounds %struct.ImDrawChannel, ptr %52, i32 0, i32 0
  %Size68 = getelementptr inbounds %struct.ImVector.0, ptr %_CmdBuffer67, i32 0, i32 0
  %53 = load i32, ptr %Size68, align 8
  %cmp69 = icmp slt i32 %51, %53
  br i1 %cmp69, label %for.body70, label %for.end

for.body70:                                       ; preds = %for.cond66
  %54 = load i32, ptr %idx_offset, align 4
  %55 = load ptr, ptr %ch, align 8
  %_CmdBuffer71 = getelementptr inbounds %struct.ImDrawChannel, ptr %55, i32 0, i32 0
  %Data72 = getelementptr inbounds %struct.ImVector.0, ptr %_CmdBuffer71, i32 0, i32 2
  %56 = load ptr, ptr %Data72, align 8
  %57 = load i32, ptr %cmd_n, align 4
  %idxprom = sext i32 %57 to i64
  %arrayidx = getelementptr inbounds %struct.ImDrawCmd, ptr %56, i64 %idxprom
  %IdxOffset73 = getelementptr inbounds %struct.ImDrawCmd, ptr %arrayidx, i32 0, i32 3
  store i32 %54, ptr %IdxOffset73, align 4
  %58 = load ptr, ptr %ch, align 8
  %_CmdBuffer74 = getelementptr inbounds %struct.ImDrawChannel, ptr %58, i32 0, i32 0
  %Data75 = getelementptr inbounds %struct.ImVector.0, ptr %_CmdBuffer74, i32 0, i32 2
  %59 = load ptr, ptr %Data75, align 8
  %60 = load i32, ptr %cmd_n, align 4
  %idxprom76 = sext i32 %60 to i64
  %arrayidx77 = getelementptr inbounds %struct.ImDrawCmd, ptr %59, i64 %idxprom76
  %ElemCount78 = getelementptr inbounds %struct.ImDrawCmd, ptr %arrayidx77, i32 0, i32 4
  %61 = load i32, ptr %ElemCount78, align 8
  %62 = load i32, ptr %idx_offset, align 4
  %add79 = add i32 %62, %61
  store i32 %add79, ptr %idx_offset, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body70
  %63 = load i32, ptr %cmd_n, align 4
  %inc = add nsw i32 %63, 1
  store i32 %inc, ptr %cmd_n, align 4
  br label %for.cond66, !llvm.loop !7

for.end:                                          ; preds = %for.cond66
  br label %for.inc80

for.inc80:                                        ; preds = %for.end
  %64 = load i32, ptr %i, align 4
  %inc81 = add nsw i32 %64, 1
  store i32 %inc81, ptr %i, align 4
  br label %for.cond, !llvm.loop !8

for.end82:                                        ; preds = %for.cond
  %65 = load ptr, ptr %draw_list.addr, align 8
  %CmdBuffer83 = getelementptr inbounds %struct.ImDrawList, ptr %65, i32 0, i32 0
  %66 = load ptr, ptr %draw_list.addr, align 8
  %CmdBuffer84 = getelementptr inbounds %struct.ImDrawList, ptr %66, i32 0, i32 0
  %Size85 = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer84, i32 0, i32 0
  %67 = load i32, ptr %Size85, align 8
  %68 = load i32, ptr %new_cmd_buffer_count, align 4
  %add86 = add nsw i32 %67, %68
  call void @_ZN8ImVectorI9ImDrawCmdE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %CmdBuffer83, i32 noundef %add86)
  %69 = load ptr, ptr %draw_list.addr, align 8
  %IdxBuffer = getelementptr inbounds %struct.ImDrawList, ptr %69, i32 0, i32 1
  %70 = load ptr, ptr %draw_list.addr, align 8
  %IdxBuffer87 = getelementptr inbounds %struct.ImDrawList, ptr %70, i32 0, i32 1
  %Size88 = getelementptr inbounds %struct.ImVector.1, ptr %IdxBuffer87, i32 0, i32 0
  %71 = load i32, ptr %Size88, align 8
  %72 = load i32, ptr %new_idx_buffer_count, align 4
  %add89 = add nsw i32 %71, %72
  call void @_ZN8ImVectorItE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %IdxBuffer, i32 noundef %add89)
  %73 = load ptr, ptr %draw_list.addr, align 8
  %CmdBuffer90 = getelementptr inbounds %struct.ImDrawList, ptr %73, i32 0, i32 0
  %Data91 = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer90, i32 0, i32 2
  %74 = load ptr, ptr %Data91, align 8
  %75 = load ptr, ptr %draw_list.addr, align 8
  %CmdBuffer92 = getelementptr inbounds %struct.ImDrawList, ptr %75, i32 0, i32 0
  %Size93 = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer92, i32 0, i32 0
  %76 = load i32, ptr %Size93, align 8
  %idx.ext = sext i32 %76 to i64
  %add.ptr = getelementptr inbounds %struct.ImDrawCmd, ptr %74, i64 %idx.ext
  %77 = load i32, ptr %new_cmd_buffer_count, align 4
  %idx.ext94 = sext i32 %77 to i64
  %idx.neg = sub i64 0, %idx.ext94
  %add.ptr95 = getelementptr inbounds %struct.ImDrawCmd, ptr %add.ptr, i64 %idx.neg
  store ptr %add.ptr95, ptr %cmd_write, align 8
  %78 = load ptr, ptr %draw_list.addr, align 8
  %IdxBuffer96 = getelementptr inbounds %struct.ImDrawList, ptr %78, i32 0, i32 1
  %Data97 = getelementptr inbounds %struct.ImVector.1, ptr %IdxBuffer96, i32 0, i32 2
  %79 = load ptr, ptr %Data97, align 8
  %80 = load ptr, ptr %draw_list.addr, align 8
  %IdxBuffer98 = getelementptr inbounds %struct.ImDrawList, ptr %80, i32 0, i32 1
  %Size99 = getelementptr inbounds %struct.ImVector.1, ptr %IdxBuffer98, i32 0, i32 0
  %81 = load i32, ptr %Size99, align 8
  %idx.ext100 = sext i32 %81 to i64
  %add.ptr101 = getelementptr inbounds i16, ptr %79, i64 %idx.ext100
  %82 = load i32, ptr %new_idx_buffer_count, align 4
  %idx.ext102 = sext i32 %82 to i64
  %idx.neg103 = sub i64 0, %idx.ext102
  %add.ptr104 = getelementptr inbounds i16, ptr %add.ptr101, i64 %idx.neg103
  store ptr %add.ptr104, ptr %idx_write, align 8
  store i32 1, ptr %i105, align 4
  br label %for.cond106

for.cond106:                                      ; preds = %for.inc134, %for.end82
  %83 = load i32, ptr %i105, align 4
  %_Count107 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 1
  %84 = load i32, ptr %_Count107, align 4
  %cmp108 = icmp slt i32 %83, %84
  br i1 %cmp108, label %for.body109, label %for.end136

for.body109:                                      ; preds = %for.cond106
  %_Channels111 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 2
  %85 = load i32, ptr %i105, align 4
  %call112 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN8ImVectorI13ImDrawChannelEixEi(ptr noundef nonnull align 8 dereferenceable(16) %_Channels111, i32 noundef %85)
  store ptr %call112, ptr %ch110, align 8
  %86 = load ptr, ptr %ch110, align 8
  %_CmdBuffer113 = getelementptr inbounds %struct.ImDrawChannel, ptr %86, i32 0, i32 0
  %Size114 = getelementptr inbounds %struct.ImVector.0, ptr %_CmdBuffer113, i32 0, i32 0
  %87 = load i32, ptr %Size114, align 8
  store i32 %87, ptr %sz, align 4
  %88 = load i32, ptr %sz, align 4
  %tobool115 = icmp ne i32 %88, 0
  br i1 %tobool115, label %if.then116, label %if.end121

if.then116:                                       ; preds = %for.body109
  %89 = load ptr, ptr %cmd_write, align 8
  %90 = load ptr, ptr %ch110, align 8
  %_CmdBuffer117 = getelementptr inbounds %struct.ImDrawChannel, ptr %90, i32 0, i32 0
  %Data118 = getelementptr inbounds %struct.ImVector.0, ptr %_CmdBuffer117, i32 0, i32 2
  %91 = load ptr, ptr %Data118, align 8
  %92 = load i32, ptr %sz, align 4
  %conv = sext i32 %92 to i64
  %mul = mul i64 %conv, 56
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %89, ptr align 8 %91, i64 %mul, i1 false)
  %93 = load i32, ptr %sz, align 4
  %94 = load ptr, ptr %cmd_write, align 8
  %idx.ext119 = sext i32 %93 to i64
  %add.ptr120 = getelementptr inbounds %struct.ImDrawCmd, ptr %94, i64 %idx.ext119
  store ptr %add.ptr120, ptr %cmd_write, align 8
  br label %if.end121

if.end121:                                        ; preds = %if.then116, %for.body109
  %95 = load ptr, ptr %ch110, align 8
  %_IdxBuffer123 = getelementptr inbounds %struct.ImDrawChannel, ptr %95, i32 0, i32 1
  %Size124 = getelementptr inbounds %struct.ImVector.1, ptr %_IdxBuffer123, i32 0, i32 0
  %96 = load i32, ptr %Size124, align 8
  store i32 %96, ptr %sz122, align 4
  %97 = load i32, ptr %sz122, align 4
  %tobool125 = icmp ne i32 %97, 0
  br i1 %tobool125, label %if.then126, label %if.end133

if.then126:                                       ; preds = %if.end121
  %98 = load ptr, ptr %idx_write, align 8
  %99 = load ptr, ptr %ch110, align 8
  %_IdxBuffer127 = getelementptr inbounds %struct.ImDrawChannel, ptr %99, i32 0, i32 1
  %Data128 = getelementptr inbounds %struct.ImVector.1, ptr %_IdxBuffer127, i32 0, i32 2
  %100 = load ptr, ptr %Data128, align 8
  %101 = load i32, ptr %sz122, align 4
  %conv129 = sext i32 %101 to i64
  %mul130 = mul i64 %conv129, 2
  call void @llvm.memcpy.p0.p0.i64(ptr align 2 %98, ptr align 2 %100, i64 %mul130, i1 false)
  %102 = load i32, ptr %sz122, align 4
  %103 = load ptr, ptr %idx_write, align 8
  %idx.ext131 = sext i32 %102 to i64
  %add.ptr132 = getelementptr inbounds i16, ptr %103, i64 %idx.ext131
  store ptr %add.ptr132, ptr %idx_write, align 8
  br label %if.end133

if.end133:                                        ; preds = %if.then126, %if.end121
  br label %for.inc134

for.inc134:                                       ; preds = %if.end133
  %104 = load i32, ptr %i105, align 4
  %inc135 = add nsw i32 %104, 1
  store i32 %inc135, ptr %i105, align 4
  br label %for.cond106, !llvm.loop !9

for.end136:                                       ; preds = %for.cond106
  %105 = load ptr, ptr %idx_write, align 8
  %106 = load ptr, ptr %draw_list.addr, align 8
  %_IdxWritePtr = getelementptr inbounds %struct.ImDrawList, ptr %106, i32 0, i32 8
  store ptr %105, ptr %_IdxWritePtr, align 8
  %107 = load ptr, ptr %draw_list.addr, align 8
  %CmdBuffer137 = getelementptr inbounds %struct.ImDrawList, ptr %107, i32 0, i32 0
  %Size138 = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer137, i32 0, i32 0
  %108 = load i32, ptr %Size138, align 8
  %cmp139 = icmp eq i32 %108, 0
  br i1 %cmp139, label %if.then144, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end136
  %109 = load ptr, ptr %draw_list.addr, align 8
  %CmdBuffer140 = getelementptr inbounds %struct.ImDrawList, ptr %109, i32 0, i32 0
  %call141 = call noundef nonnull align 8 dereferenceable(56) ptr @_ZN8ImVectorI9ImDrawCmdE4backEv(ptr noundef nonnull align 8 dereferenceable(16) %CmdBuffer140)
  %UserCallback142 = getelementptr inbounds %struct.ImDrawCmd, ptr %call141, i32 0, i32 5
  %110 = load ptr, ptr %UserCallback142, align 8
  %cmp143 = icmp ne ptr %110, null
  br i1 %cmp143, label %if.then144, label %if.end145

if.then144:                                       ; preds = %lor.lhs.false, %for.end136
  %111 = load ptr, ptr %draw_list.addr, align 8
  call void @_ZN10ImDrawList10AddDrawCmdEv(ptr noundef nonnull align 8 dereferenceable(196) %111)
  br label %if.end145

if.end145:                                        ; preds = %if.then144, %lor.lhs.false
  %112 = load ptr, ptr %draw_list.addr, align 8
  %CmdBuffer146 = getelementptr inbounds %struct.ImDrawList, ptr %112, i32 0, i32 0
  %Data147 = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer146, i32 0, i32 2
  %113 = load ptr, ptr %Data147, align 8
  %114 = load ptr, ptr %draw_list.addr, align 8
  %CmdBuffer148 = getelementptr inbounds %struct.ImDrawList, ptr %114, i32 0, i32 0
  %Size149 = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer148, i32 0, i32 0
  %115 = load i32, ptr %Size149, align 8
  %sub = sub nsw i32 %115, 1
  %idxprom150 = sext i32 %sub to i64
  %arrayidx151 = getelementptr inbounds %struct.ImDrawCmd, ptr %113, i64 %idxprom150
  store ptr %arrayidx151, ptr %curr_cmd, align 8
  %116 = load ptr, ptr %curr_cmd, align 8
  %ElemCount152 = getelementptr inbounds %struct.ImDrawCmd, ptr %116, i32 0, i32 4
  %117 = load i32, ptr %ElemCount152, align 8
  %cmp153 = icmp eq i32 %117, 0
  br i1 %cmp153, label %if.then154, label %if.else

if.then154:                                       ; preds = %if.end145
  %118 = load ptr, ptr %curr_cmd, align 8
  %119 = load ptr, ptr %draw_list.addr, align 8
  %_CmdHeader = getelementptr inbounds %struct.ImDrawList, ptr %119, i32 0, i32 12
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %118, ptr align 8 %_CmdHeader, i64 28, i1 false)
  br label %if.end160

if.else:                                          ; preds = %if.end145
  %120 = load ptr, ptr %curr_cmd, align 8
  %121 = load ptr, ptr %draw_list.addr, align 8
  %_CmdHeader155 = getelementptr inbounds %struct.ImDrawList, ptr %121, i32 0, i32 12
  %call156 = call i32 @memcmp(ptr noundef %120, ptr noundef %_CmdHeader155, i64 noundef 28) #14
  %cmp157 = icmp ne i32 %call156, 0
  br i1 %cmp157, label %if.then158, label %if.end159

if.then158:                                       ; preds = %if.else
  %122 = load ptr, ptr %draw_list.addr, align 8
  call void @_ZN10ImDrawList10AddDrawCmdEv(ptr noundef nonnull align 8 dereferenceable(196) %122)
  br label %if.end159

if.end159:                                        ; preds = %if.then158, %if.else
  br label %if.end160

if.end160:                                        ; preds = %if.end159, %if.then154
  %_Count161 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 1
  store i32 1, ptr %_Count161, align 4
  br label %return

return:                                           ; preds = %if.end160, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI9ImDrawCmdE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_size) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_size, ptr %new_size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_size.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sgt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %new_size.addr, align 4
  %call = call noundef i32 @_ZNK8ImVectorI9ImDrawCmdE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %2)
  call void @_ZN8ImVectorI9ImDrawCmdE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %new_size.addr, align 4
  %Size = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 0
  store i32 %3, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorItE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_size) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_size, ptr %new_size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_size.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sgt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %new_size.addr, align 4
  %call = call noundef i32 @_ZNK8ImVectorItE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %2)
  call void @_ZN8ImVectorItE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %new_size.addr, align 4
  %Size = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 0
  store i32 %3, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI10ImDrawVertE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_size) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_size, ptr %new_size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_size.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sgt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %new_size.addr, align 4
  %call = call noundef i32 @_ZNK8ImVectorI10ImDrawVertE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %2)
  call void @_ZN8ImVectorI10ImDrawVertE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %new_size.addr, align 4
  %Size = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 0
  store i32 %3, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI6ImVec4E6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_size) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_size, ptr %new_size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_size.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sgt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %new_size.addr, align 4
  %call = call noundef i32 @_ZNK8ImVectorI6ImVec4E14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %2)
  call void @_ZN8ImVectorI6ImVec4E7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %new_size.addr, align 4
  %Size = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 0
  store i32 %3, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorIPvE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_size) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_size, ptr %new_size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_size.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sgt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %new_size.addr, align 4
  %call = call noundef i32 @_ZNK8ImVectorIPvE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %2)
  call void @_ZN8ImVectorIPvE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %new_size.addr, align 4
  %Size = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 0
  store i32 %3, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI6ImVec2E6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_size) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_size, ptr %new_size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_size.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sgt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %new_size.addr, align 4
  %call = call noundef i32 @_ZNK8ImVectorI6ImVec2E14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %2)
  call void @_ZN8ImVectorI6ImVec2E7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %new_size.addr, align 4
  %Size = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 0
  store i32 %3, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN18ImDrawListSplitter5ClearEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %_Current = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 0
  store i32 0, ptr %_Current, align 8
  %_Count = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 1
  store i32 1, ptr %_Count, align 4
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI9ImDrawCmdE9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(56) %v) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Size2 = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 0
  %2 = load i32, ptr %Size2, align 8
  %add = add nsw i32 %2, 1
  %call = call noundef i32 @_ZNK8ImVectorI9ImDrawCmdE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %add)
  call void @_ZN8ImVectorI9ImDrawCmdE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %Data = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %Size3 = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 0
  %4 = load i32, ptr %Size3, align 8
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds %struct.ImDrawCmd, ptr %3, i64 %idxprom
  %5 = load ptr, ptr %v.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arrayidx, ptr align 8 %5, i64 56, i1 false)
  %Size4 = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size4, align 8
  %inc = add nsw i32 %6, 1
  store i32 %inc, ptr %Size4, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN9ImDrawCmdC2Ev(ptr noundef nonnull align 8 dereferenceable(56) %this) unnamed_addr #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %ClipRect = getelementptr inbounds %struct.ImDrawCmd, ptr %this1, i32 0, i32 0
  call void @_ZN6ImVec4C2Ev(ptr noundef nonnull align 4 dereferenceable(16) %ClipRect)
  call void @llvm.memset.p0.i64(ptr align 8 %this1, i8 0, i64 56, i1 false)
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList16_ClearFreeMemoryEv(ptr noundef nonnull align 8 dereferenceable(196) %this) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %CmdBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  call void @_ZN8ImVectorI9ImDrawCmdE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %CmdBuffer)
  %IdxBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 1
  call void @_ZN8ImVectorItE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %IdxBuffer)
  %VtxBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 2
  call void @_ZN8ImVectorI10ImDrawVertE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %VtxBuffer)
  %Flags = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 3
  store i32 0, ptr %Flags, align 8
  %_VtxCurrentIdx = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  store i32 0, ptr %_VtxCurrentIdx, align 4
  %_VtxWritePtr = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  store ptr null, ptr %_VtxWritePtr, align 8
  %_IdxWritePtr = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  store ptr null, ptr %_IdxWritePtr, align 8
  %_ClipRectStack = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 9
  call void @_ZN8ImVectorI6ImVec4E5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %_ClipRectStack)
  %_TextureIdStack = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 10
  call void @_ZN8ImVectorIPvE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %_TextureIdStack)
  %_Path = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  call void @_ZN8ImVectorI6ImVec2E5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %_Path)
  %_Splitter = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 13
  call void @_ZN18ImDrawListSplitter15ClearFreeMemoryEv(ptr noundef nonnull align 8 dereferenceable(24) %_Splitter)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI9ImDrawCmdE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Capacity = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data2 = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
  %Data3 = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorItE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Capacity = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data2 = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
  %Data3 = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI10ImDrawVertE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Capacity = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data2 = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
  %Data3 = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI6ImVec4E5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Capacity = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data2 = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
  %Data3 = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorIPvE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Capacity = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data2 = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
  %Data3 = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI6ImVec2E5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Capacity = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data2 = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
  %Data3 = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN18ImDrawListSplitter15ClearFreeMemoryEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %_Channels = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 2
  %Size = getelementptr inbounds %struct.ImVector.5, ptr %_Channels, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32, ptr %i, align 4
  %_Current = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 0
  %3 = load i32, ptr %_Current, align 8
  %cmp2 = icmp eq i32 %2, %3
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %_Channels3 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 2
  %4 = load i32, ptr %i, align 4
  %call = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN8ImVectorI13ImDrawChannelEixEi(ptr noundef nonnull align 8 dereferenceable(16) %_Channels3, i32 noundef %4)
  call void @llvm.memset.p0.i64(ptr align 8 %call, i8 0, i64 32, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %_Channels4 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 2
  %5 = load i32, ptr %i, align 4
  %call5 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN8ImVectorI13ImDrawChannelEixEi(ptr noundef nonnull align 8 dereferenceable(16) %_Channels4, i32 noundef %5)
  %_CmdBuffer = getelementptr inbounds %struct.ImDrawChannel, ptr %call5, i32 0, i32 0
  call void @_ZN8ImVectorI9ImDrawCmdE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %_CmdBuffer)
  %_Channels6 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 2
  %6 = load i32, ptr %i, align 4
  %call7 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN8ImVectorI13ImDrawChannelEixEi(ptr noundef nonnull align 8 dereferenceable(16) %_Channels6, i32 noundef %6)
  %_IdxBuffer = getelementptr inbounds %struct.ImDrawChannel, ptr %call7, i32 0, i32 1
  call void @_ZN8ImVectorItE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %_IdxBuffer)
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load i32, ptr %i, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !10

for.end:                                          ; preds = %for.cond
  %_Current8 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 0
  store i32 0, ptr %_Current8, align 8
  %_Count = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 1
  store i32 1, ptr %_Count, align 4
  %_Channels9 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 2
  call void @_ZN8ImVectorI13ImDrawChannelE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %_Channels9)
  ret void
}

; Function Attrs: mustprogress uwtable
define noundef ptr @_ZNK10ImDrawList11CloneOutputEv(ptr noundef nonnull align 8 dereferenceable(196) %this) #4 align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %dst = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef 200)
  %call2 = call noundef ptr @_Znwm12ImNewWrapperPv(i64 noundef 200, ptr noundef %call)
  %_Data = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %_Data, align 8
  invoke void @_ZN10ImDrawListC2EP20ImDrawListSharedData(ptr noundef nonnull align 8 dereferenceable(196) %call2, ptr noundef %0)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  store ptr %call2, ptr %dst, align 8
  %CmdBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %dst, align 8
  %CmdBuffer3 = getelementptr inbounds %struct.ImDrawList, ptr %1, i32 0, i32 0
  %call4 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN8ImVectorI9ImDrawCmdEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %CmdBuffer3, ptr noundef nonnull align 8 dereferenceable(16) %CmdBuffer)
  %IdxBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %dst, align 8
  %IdxBuffer5 = getelementptr inbounds %struct.ImDrawList, ptr %2, i32 0, i32 1
  %call6 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN8ImVectorItEaSERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %IdxBuffer5, ptr noundef nonnull align 8 dereferenceable(16) %IdxBuffer)
  %VtxBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %dst, align 8
  %VtxBuffer7 = getelementptr inbounds %struct.ImDrawList, ptr %3, i32 0, i32 2
  %call8 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN8ImVectorI10ImDrawVertEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %VtxBuffer7, ptr noundef nonnull align 8 dereferenceable(16) %VtxBuffer)
  %Flags = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 3
  %4 = load i32, ptr %Flags, align 8
  %5 = load ptr, ptr %dst, align 8
  %Flags9 = getelementptr inbounds %struct.ImDrawList, ptr %5, i32 0, i32 3
  store i32 %4, ptr %Flags9, align 8
  %6 = load ptr, ptr %dst, align 8
  ret ptr %6

lpad:                                             ; preds = %entry
  %7 = landingpad { ptr, i32 }
          cleanup
  %8 = extractvalue { ptr, i32 } %7, 0
  store ptr %8, ptr %exn.slot, align 8
  %9 = extractvalue { ptr, i32 } %7, 1
  store i32 %9, ptr %ehselector.slot, align 4
  call void @_ZdlPv12ImNewWrapperS_(ptr noundef %call2, ptr noundef %call) #12
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val10 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val10
}

declare noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef) #1

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_Znwm12ImNewWrapperPv(i64 noundef %0, ptr noundef %ptr) #2 comdat {
entry:
  %.addr = alloca i64, align 8
  %ptr.addr = alloca ptr, align 8
  store i64 %0, ptr %.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %1 = load ptr, ptr %ptr.addr, align 8
  ret ptr %1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN10ImDrawListC2EP20ImDrawListSharedData(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef %shared_data) unnamed_addr #4 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %shared_data.addr = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %shared_data, ptr %shared_data.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %CmdBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  call void @_ZN8ImVectorI9ImDrawCmdEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %CmdBuffer)
  %IdxBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 1
  invoke void @_ZN8ImVectorItEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %IdxBuffer)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  %VtxBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 2
  invoke void @_ZN8ImVectorI10ImDrawVertEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %VtxBuffer)
          to label %invoke.cont3 unwind label %lpad2

invoke.cont3:                                     ; preds = %invoke.cont
  %_ClipRectStack = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 9
  invoke void @_ZN8ImVectorI6ImVec4EC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %_ClipRectStack)
          to label %invoke.cont5 unwind label %lpad4

invoke.cont5:                                     ; preds = %invoke.cont3
  %_TextureIdStack = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 10
  invoke void @_ZN8ImVectorIPvEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %_TextureIdStack)
          to label %invoke.cont7 unwind label %lpad6

invoke.cont7:                                     ; preds = %invoke.cont5
  %_Path = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  invoke void @_ZN8ImVectorI6ImVec2EC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %_Path)
          to label %invoke.cont9 unwind label %lpad8

invoke.cont9:                                     ; preds = %invoke.cont7
  %_CmdHeader = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 12
  invoke void @_ZN15ImDrawCmdHeaderC2Ev(ptr noundef nonnull align 8 dereferenceable(28) %_CmdHeader)
          to label %invoke.cont11 unwind label %lpad10

invoke.cont11:                                    ; preds = %invoke.cont9
  %_Splitter = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 13
  invoke void @_ZN18ImDrawListSplitterC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %_Splitter)
          to label %invoke.cont12 unwind label %lpad10

invoke.cont12:                                    ; preds = %invoke.cont11
  call void @llvm.memset.p0.i64(ptr align 8 %this1, i8 0, i64 200, i1 false)
  %0 = load ptr, ptr %shared_data.addr, align 8
  %_Data = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  store ptr %0, ptr %_Data, align 8
  ret void

lpad:                                             ; preds = %entry
  %1 = landingpad { ptr, i32 }
          cleanup
  %2 = extractvalue { ptr, i32 } %1, 0
  store ptr %2, ptr %exn.slot, align 8
  %3 = extractvalue { ptr, i32 } %1, 1
  store i32 %3, ptr %ehselector.slot, align 4
  br label %ehcleanup16

lpad2:                                            ; preds = %invoke.cont
  %4 = landingpad { ptr, i32 }
          cleanup
  %5 = extractvalue { ptr, i32 } %4, 0
  store ptr %5, ptr %exn.slot, align 8
  %6 = extractvalue { ptr, i32 } %4, 1
  store i32 %6, ptr %ehselector.slot, align 4
  br label %ehcleanup15

lpad4:                                            ; preds = %invoke.cont3
  %7 = landingpad { ptr, i32 }
          cleanup
  %8 = extractvalue { ptr, i32 } %7, 0
  store ptr %8, ptr %exn.slot, align 8
  %9 = extractvalue { ptr, i32 } %7, 1
  store i32 %9, ptr %ehselector.slot, align 4
  br label %ehcleanup14

lpad6:                                            ; preds = %invoke.cont5
  %10 = landingpad { ptr, i32 }
          cleanup
  %11 = extractvalue { ptr, i32 } %10, 0
  store ptr %11, ptr %exn.slot, align 8
  %12 = extractvalue { ptr, i32 } %10, 1
  store i32 %12, ptr %ehselector.slot, align 4
  br label %ehcleanup13

lpad8:                                            ; preds = %invoke.cont7
  %13 = landingpad { ptr, i32 }
          cleanup
  %14 = extractvalue { ptr, i32 } %13, 0
  store ptr %14, ptr %exn.slot, align 8
  %15 = extractvalue { ptr, i32 } %13, 1
  store i32 %15, ptr %ehselector.slot, align 4
  br label %ehcleanup

lpad10:                                           ; preds = %invoke.cont11, %invoke.cont9
  %16 = landingpad { ptr, i32 }
          cleanup
  %17 = extractvalue { ptr, i32 } %16, 0
  store ptr %17, ptr %exn.slot, align 8
  %18 = extractvalue { ptr, i32 } %16, 1
  store i32 %18, ptr %ehselector.slot, align 4
  call void @_ZN8ImVectorI6ImVec2ED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %_Path) #12
  br label %ehcleanup

ehcleanup:                                        ; preds = %lpad10, %lpad8
  call void @_ZN8ImVectorIPvED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %_TextureIdStack) #12
  br label %ehcleanup13

ehcleanup13:                                      ; preds = %ehcleanup, %lpad6
  call void @_ZN8ImVectorI6ImVec4ED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %_ClipRectStack) #12
  br label %ehcleanup14

ehcleanup14:                                      ; preds = %ehcleanup13, %lpad4
  call void @_ZN8ImVectorI10ImDrawVertED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %VtxBuffer) #12
  br label %ehcleanup15

ehcleanup15:                                      ; preds = %ehcleanup14, %lpad2
  call void @_ZN8ImVectorItED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %IdxBuffer) #12
  br label %ehcleanup16

ehcleanup16:                                      ; preds = %ehcleanup15, %lpad
  call void @_ZN8ImVectorI9ImDrawCmdED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %CmdBuffer) #12
  br label %eh.resume

eh.resume:                                        ; preds = %ehcleanup16
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val17 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val17
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZdlPv12ImNewWrapperS_(ptr noundef %0, ptr noundef %1) #2 comdat {
entry:
  %.addr = alloca ptr, align 8
  %.addr1 = alloca ptr, align 8
  store ptr %0, ptr %.addr, align 8
  store ptr %1, ptr %.addr1, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr noundef nonnull align 8 dereferenceable(16) ptr @_ZN8ImVectorI9ImDrawCmdEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %src) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %src.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %src, ptr %src.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN8ImVectorI9ImDrawCmdE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %0 = load ptr, ptr %src.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.0, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  call void @_ZN8ImVectorI9ImDrawCmdE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %1)
  %2 = load ptr, ptr %src.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.0, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Data2 = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 2
  %4 = load ptr, ptr %Data2, align 8
  %5 = load ptr, ptr %src.addr, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.0, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %Data3, align 8
  %Size4 = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 0
  %7 = load i32, ptr %Size4, align 8
  %conv = sext i32 %7 to i64
  %mul = mul i64 %conv, 56
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %4, ptr align 8 %6, i64 %mul, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr noundef nonnull align 8 dereferenceable(16) ptr @_ZN8ImVectorItEaSERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %src) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %src.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %src, ptr %src.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN8ImVectorItE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %0 = load ptr, ptr %src.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.1, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  call void @_ZN8ImVectorItE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %1)
  %2 = load ptr, ptr %src.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.1, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Data2 = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 2
  %4 = load ptr, ptr %Data2, align 8
  %5 = load ptr, ptr %src.addr, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.1, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %Data3, align 8
  %Size4 = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 0
  %7 = load i32, ptr %Size4, align 8
  %conv = sext i32 %7 to i64
  %mul = mul i64 %conv, 2
  call void @llvm.memcpy.p0.p0.i64(ptr align 2 %4, ptr align 2 %6, i64 %mul, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr noundef nonnull align 8 dereferenceable(16) ptr @_ZN8ImVectorI10ImDrawVertEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %src) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %src.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %src, ptr %src.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN8ImVectorI10ImDrawVertE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  %0 = load ptr, ptr %src.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.2, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  call void @_ZN8ImVectorI10ImDrawVertE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %1)
  %2 = load ptr, ptr %src.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.2, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Data2 = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 2
  %4 = load ptr, ptr %Data2, align 8
  %5 = load ptr, ptr %src.addr, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.2, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %Data3, align 8
  %Size4 = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 0
  %7 = load i32, ptr %Size4, align 8
  %conv = sext i32 %7 to i64
  %mul = mul i64 %conv, 20
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %4, ptr align 4 %6, i64 %mul, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList10AddDrawCmdEv(ptr noundef nonnull align 8 dereferenceable(196) %this) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %draw_cmd = alloca %struct.ImDrawCmd, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN9ImDrawCmdC2Ev(ptr noundef nonnull align 8 dereferenceable(56) %draw_cmd)
  %_CmdHeader = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 12
  %ClipRect = getelementptr inbounds %struct.ImDrawCmdHeader, ptr %_CmdHeader, i32 0, i32 0
  %ClipRect2 = getelementptr inbounds %struct.ImDrawCmd, ptr %draw_cmd, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ClipRect2, ptr align 8 %ClipRect, i64 16, i1 false)
  %_CmdHeader3 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 12
  %TextureId = getelementptr inbounds %struct.ImDrawCmdHeader, ptr %_CmdHeader3, i32 0, i32 1
  %0 = load ptr, ptr %TextureId, align 8
  %TextureId4 = getelementptr inbounds %struct.ImDrawCmd, ptr %draw_cmd, i32 0, i32 1
  store ptr %0, ptr %TextureId4, align 8
  %_CmdHeader5 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 12
  %VtxOffset = getelementptr inbounds %struct.ImDrawCmdHeader, ptr %_CmdHeader5, i32 0, i32 2
  %1 = load i32, ptr %VtxOffset, align 8
  %VtxOffset6 = getelementptr inbounds %struct.ImDrawCmd, ptr %draw_cmd, i32 0, i32 2
  store i32 %1, ptr %VtxOffset6, align 8
  %IdxBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 1
  %Size = getelementptr inbounds %struct.ImVector.1, ptr %IdxBuffer, i32 0, i32 0
  %2 = load i32, ptr %Size, align 8
  %IdxOffset = getelementptr inbounds %struct.ImDrawCmd, ptr %draw_cmd, i32 0, i32 3
  store i32 %2, ptr %IdxOffset, align 4
  %CmdBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  call void @_ZN8ImVectorI9ImDrawCmdE9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %CmdBuffer, ptr noundef nonnull align 8 dereferenceable(56) %draw_cmd)
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList17_PopUnusedDrawCmdEv(ptr noundef nonnull align 8 dereferenceable(196) %this) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %curr_cmd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %CmdBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  %Size = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %cmp = icmp sgt i32 %0, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %CmdBuffer2 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  %Data = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer2, i32 0, i32 2
  %1 = load ptr, ptr %Data, align 8
  %CmdBuffer3 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  %Size4 = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer3, i32 0, i32 0
  %2 = load i32, ptr %Size4, align 8
  %sub = sub nsw i32 %2, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.ImDrawCmd, ptr %1, i64 %idxprom
  store ptr %arrayidx, ptr %curr_cmd, align 8
  %3 = load ptr, ptr %curr_cmd, align 8
  %ElemCount = getelementptr inbounds %struct.ImDrawCmd, ptr %3, i32 0, i32 4
  %4 = load i32, ptr %ElemCount, align 8
  %cmp5 = icmp ne i32 %4, 0
  br i1 %cmp5, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %5 = load ptr, ptr %curr_cmd, align 8
  %UserCallback = getelementptr inbounds %struct.ImDrawCmd, ptr %5, i32 0, i32 5
  %6 = load ptr, ptr %UserCallback, align 8
  %cmp6 = icmp ne ptr %6, null
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %while.body
  br label %while.end

if.end:                                           ; preds = %lor.lhs.false
  %CmdBuffer7 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  call void @_ZN8ImVectorI9ImDrawCmdE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(16) %CmdBuffer7)
  br label %while.cond, !llvm.loop !11

while.end:                                        ; preds = %if.then, %while.cond
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI9ImDrawCmdE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %dec = add nsw i32 %0, -1
  store i32 %dec, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList11AddCallbackEPFvPKS_PK9ImDrawCmdEPv(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef %callback, ptr noundef %callback_data) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %callback.addr = alloca ptr, align 8
  %callback_data.addr = alloca ptr, align 8
  %curr_cmd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %callback, ptr %callback.addr, align 8
  store ptr %callback_data, ptr %callback_data.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %CmdBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  %Data = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %CmdBuffer2 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  %Size = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer2, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %sub = sub nsw i32 %1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.ImDrawCmd, ptr %0, i64 %idxprom
  store ptr %arrayidx, ptr %curr_cmd, align 8
  %2 = load ptr, ptr %curr_cmd, align 8
  %ElemCount = getelementptr inbounds %struct.ImDrawCmd, ptr %2, i32 0, i32 4
  %3 = load i32, ptr %ElemCount, align 8
  %cmp = icmp ne i32 %3, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @_ZN10ImDrawList10AddDrawCmdEv(ptr noundef nonnull align 8 dereferenceable(196) %this1)
  %CmdBuffer3 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  %Data4 = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer3, i32 0, i32 2
  %4 = load ptr, ptr %Data4, align 8
  %CmdBuffer5 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  %Size6 = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer5, i32 0, i32 0
  %5 = load i32, ptr %Size6, align 8
  %sub7 = sub nsw i32 %5, 1
  %idxprom8 = sext i32 %sub7 to i64
  %arrayidx9 = getelementptr inbounds %struct.ImDrawCmd, ptr %4, i64 %idxprom8
  store ptr %arrayidx9, ptr %curr_cmd, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load ptr, ptr %callback.addr, align 8
  %7 = load ptr, ptr %curr_cmd, align 8
  %UserCallback = getelementptr inbounds %struct.ImDrawCmd, ptr %7, i32 0, i32 5
  store ptr %6, ptr %UserCallback, align 8
  %8 = load ptr, ptr %callback_data.addr, align 8
  %9 = load ptr, ptr %curr_cmd, align 8
  %UserCallbackData = getelementptr inbounds %struct.ImDrawCmd, ptr %9, i32 0, i32 6
  store ptr %8, ptr %UserCallbackData, align 8
  call void @_ZN10ImDrawList10AddDrawCmdEv(ptr noundef nonnull align 8 dereferenceable(196) %this1)
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList17_TryMergeDrawCmdsEv(ptr noundef nonnull align 8 dereferenceable(196) %this) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %curr_cmd = alloca ptr, align 8
  %prev_cmd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %CmdBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  %Data = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %CmdBuffer2 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  %Size = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer2, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %sub = sub nsw i32 %1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.ImDrawCmd, ptr %0, i64 %idxprom
  store ptr %arrayidx, ptr %curr_cmd, align 8
  %2 = load ptr, ptr %curr_cmd, align 8
  %add.ptr = getelementptr inbounds %struct.ImDrawCmd, ptr %2, i64 -1
  store ptr %add.ptr, ptr %prev_cmd, align 8
  %3 = load ptr, ptr %curr_cmd, align 8
  %4 = load ptr, ptr %prev_cmd, align 8
  %call = call i32 @memcmp(ptr noundef %3, ptr noundef %4, i64 noundef 28) #14
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %5 = load ptr, ptr %prev_cmd, align 8
  %IdxOffset = getelementptr inbounds %struct.ImDrawCmd, ptr %5, i32 0, i32 3
  %6 = load i32, ptr %IdxOffset, align 4
  %7 = load ptr, ptr %prev_cmd, align 8
  %ElemCount = getelementptr inbounds %struct.ImDrawCmd, ptr %7, i32 0, i32 4
  %8 = load i32, ptr %ElemCount, align 8
  %add = add i32 %6, %8
  %9 = load ptr, ptr %curr_cmd, align 8
  %IdxOffset3 = getelementptr inbounds %struct.ImDrawCmd, ptr %9, i32 0, i32 3
  %10 = load i32, ptr %IdxOffset3, align 4
  %cmp4 = icmp eq i32 %add, %10
  br i1 %cmp4, label %land.lhs.true5, label %if.end

land.lhs.true5:                                   ; preds = %land.lhs.true
  %11 = load ptr, ptr %curr_cmd, align 8
  %UserCallback = getelementptr inbounds %struct.ImDrawCmd, ptr %11, i32 0, i32 5
  %12 = load ptr, ptr %UserCallback, align 8
  %cmp6 = icmp eq ptr %12, null
  br i1 %cmp6, label %land.lhs.true7, label %if.end

land.lhs.true7:                                   ; preds = %land.lhs.true5
  %13 = load ptr, ptr %prev_cmd, align 8
  %UserCallback8 = getelementptr inbounds %struct.ImDrawCmd, ptr %13, i32 0, i32 5
  %14 = load ptr, ptr %UserCallback8, align 8
  %cmp9 = icmp eq ptr %14, null
  br i1 %cmp9, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true7
  %15 = load ptr, ptr %curr_cmd, align 8
  %ElemCount10 = getelementptr inbounds %struct.ImDrawCmd, ptr %15, i32 0, i32 4
  %16 = load i32, ptr %ElemCount10, align 8
  %17 = load ptr, ptr %prev_cmd, align 8
  %ElemCount11 = getelementptr inbounds %struct.ImDrawCmd, ptr %17, i32 0, i32 4
  %18 = load i32, ptr %ElemCount11, align 8
  %add12 = add i32 %18, %16
  store i32 %add12, ptr %ElemCount11, align 8
  %CmdBuffer13 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  call void @_ZN8ImVectorI9ImDrawCmdE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(16) %CmdBuffer13)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true7, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind willreturn memory(read)
declare i32 @memcmp(ptr noundef, ptr noundef, i64 noundef) #8

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList18_OnChangedClipRectEv(ptr noundef nonnull align 8 dereferenceable(196) %this) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %curr_cmd = alloca ptr, align 8
  %prev_cmd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %CmdBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  %Data = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %CmdBuffer2 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  %Size = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer2, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %sub = sub nsw i32 %1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.ImDrawCmd, ptr %0, i64 %idxprom
  store ptr %arrayidx, ptr %curr_cmd, align 8
  %2 = load ptr, ptr %curr_cmd, align 8
  %ElemCount = getelementptr inbounds %struct.ImDrawCmd, ptr %2, i32 0, i32 4
  %3 = load i32, ptr %ElemCount, align 8
  %cmp = icmp ne i32 %3, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %4 = load ptr, ptr %curr_cmd, align 8
  %ClipRect = getelementptr inbounds %struct.ImDrawCmd, ptr %4, i32 0, i32 0
  %_CmdHeader = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 12
  %ClipRect3 = getelementptr inbounds %struct.ImDrawCmdHeader, ptr %_CmdHeader, i32 0, i32 0
  %call = call i32 @memcmp(ptr noundef %ClipRect, ptr noundef %ClipRect3, i64 noundef 16) #14
  %cmp4 = icmp ne i32 %call, 0
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @_ZN10ImDrawList10AddDrawCmdEv(ptr noundef nonnull align 8 dereferenceable(196) %this1)
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %5 = load ptr, ptr %curr_cmd, align 8
  %add.ptr = getelementptr inbounds %struct.ImDrawCmd, ptr %5, i64 -1
  store ptr %add.ptr, ptr %prev_cmd, align 8
  %6 = load ptr, ptr %curr_cmd, align 8
  %ElemCount5 = getelementptr inbounds %struct.ImDrawCmd, ptr %6, i32 0, i32 4
  %7 = load i32, ptr %ElemCount5, align 8
  %cmp6 = icmp eq i32 %7, 0
  br i1 %cmp6, label %land.lhs.true7, label %if.end23

land.lhs.true7:                                   ; preds = %if.end
  %CmdBuffer8 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  %Size9 = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer8, i32 0, i32 0
  %8 = load i32, ptr %Size9, align 8
  %cmp10 = icmp sgt i32 %8, 1
  br i1 %cmp10, label %land.lhs.true11, label %if.end23

land.lhs.true11:                                  ; preds = %land.lhs.true7
  %_CmdHeader12 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 12
  %9 = load ptr, ptr %prev_cmd, align 8
  %call13 = call i32 @memcmp(ptr noundef %_CmdHeader12, ptr noundef %9, i64 noundef 28) #14
  %cmp14 = icmp eq i32 %call13, 0
  br i1 %cmp14, label %land.lhs.true15, label %if.end23

land.lhs.true15:                                  ; preds = %land.lhs.true11
  %10 = load ptr, ptr %prev_cmd, align 8
  %IdxOffset = getelementptr inbounds %struct.ImDrawCmd, ptr %10, i32 0, i32 3
  %11 = load i32, ptr %IdxOffset, align 4
  %12 = load ptr, ptr %prev_cmd, align 8
  %ElemCount16 = getelementptr inbounds %struct.ImDrawCmd, ptr %12, i32 0, i32 4
  %13 = load i32, ptr %ElemCount16, align 8
  %add = add i32 %11, %13
  %14 = load ptr, ptr %curr_cmd, align 8
  %IdxOffset17 = getelementptr inbounds %struct.ImDrawCmd, ptr %14, i32 0, i32 3
  %15 = load i32, ptr %IdxOffset17, align 4
  %cmp18 = icmp eq i32 %add, %15
  br i1 %cmp18, label %land.lhs.true19, label %if.end23

land.lhs.true19:                                  ; preds = %land.lhs.true15
  %16 = load ptr, ptr %prev_cmd, align 8
  %UserCallback = getelementptr inbounds %struct.ImDrawCmd, ptr %16, i32 0, i32 5
  %17 = load ptr, ptr %UserCallback, align 8
  %cmp20 = icmp eq ptr %17, null
  br i1 %cmp20, label %if.then21, label %if.end23

if.then21:                                        ; preds = %land.lhs.true19
  %CmdBuffer22 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  call void @_ZN8ImVectorI9ImDrawCmdE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(16) %CmdBuffer22)
  br label %return

if.end23:                                         ; preds = %land.lhs.true19, %land.lhs.true15, %land.lhs.true11, %land.lhs.true7, %if.end
  %_CmdHeader24 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 12
  %ClipRect25 = getelementptr inbounds %struct.ImDrawCmdHeader, ptr %_CmdHeader24, i32 0, i32 0
  %18 = load ptr, ptr %curr_cmd, align 8
  %ClipRect26 = getelementptr inbounds %struct.ImDrawCmd, ptr %18, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ClipRect26, ptr align 8 %ClipRect25, i64 16, i1 false)
  br label %return

return:                                           ; preds = %if.end23, %if.then21, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList19_OnChangedTextureIDEv(ptr noundef nonnull align 8 dereferenceable(196) %this) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %curr_cmd = alloca ptr, align 8
  %prev_cmd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %CmdBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  %Data = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %CmdBuffer2 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  %Size = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer2, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %sub = sub nsw i32 %1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.ImDrawCmd, ptr %0, i64 %idxprom
  store ptr %arrayidx, ptr %curr_cmd, align 8
  %2 = load ptr, ptr %curr_cmd, align 8
  %ElemCount = getelementptr inbounds %struct.ImDrawCmd, ptr %2, i32 0, i32 4
  %3 = load i32, ptr %ElemCount, align 8
  %cmp = icmp ne i32 %3, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %4 = load ptr, ptr %curr_cmd, align 8
  %TextureId = getelementptr inbounds %struct.ImDrawCmd, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %TextureId, align 8
  %_CmdHeader = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 12
  %TextureId3 = getelementptr inbounds %struct.ImDrawCmdHeader, ptr %_CmdHeader, i32 0, i32 1
  %6 = load ptr, ptr %TextureId3, align 8
  %cmp4 = icmp ne ptr %5, %6
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @_ZN10ImDrawList10AddDrawCmdEv(ptr noundef nonnull align 8 dereferenceable(196) %this1)
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %7 = load ptr, ptr %curr_cmd, align 8
  %add.ptr = getelementptr inbounds %struct.ImDrawCmd, ptr %7, i64 -1
  store ptr %add.ptr, ptr %prev_cmd, align 8
  %8 = load ptr, ptr %curr_cmd, align 8
  %ElemCount5 = getelementptr inbounds %struct.ImDrawCmd, ptr %8, i32 0, i32 4
  %9 = load i32, ptr %ElemCount5, align 8
  %cmp6 = icmp eq i32 %9, 0
  br i1 %cmp6, label %land.lhs.true7, label %if.end22

land.lhs.true7:                                   ; preds = %if.end
  %CmdBuffer8 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  %Size9 = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer8, i32 0, i32 0
  %10 = load i32, ptr %Size9, align 8
  %cmp10 = icmp sgt i32 %10, 1
  br i1 %cmp10, label %land.lhs.true11, label %if.end22

land.lhs.true11:                                  ; preds = %land.lhs.true7
  %_CmdHeader12 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 12
  %11 = load ptr, ptr %prev_cmd, align 8
  %call = call i32 @memcmp(ptr noundef %_CmdHeader12, ptr noundef %11, i64 noundef 28) #14
  %cmp13 = icmp eq i32 %call, 0
  br i1 %cmp13, label %land.lhs.true14, label %if.end22

land.lhs.true14:                                  ; preds = %land.lhs.true11
  %12 = load ptr, ptr %prev_cmd, align 8
  %IdxOffset = getelementptr inbounds %struct.ImDrawCmd, ptr %12, i32 0, i32 3
  %13 = load i32, ptr %IdxOffset, align 4
  %14 = load ptr, ptr %prev_cmd, align 8
  %ElemCount15 = getelementptr inbounds %struct.ImDrawCmd, ptr %14, i32 0, i32 4
  %15 = load i32, ptr %ElemCount15, align 8
  %add = add i32 %13, %15
  %16 = load ptr, ptr %curr_cmd, align 8
  %IdxOffset16 = getelementptr inbounds %struct.ImDrawCmd, ptr %16, i32 0, i32 3
  %17 = load i32, ptr %IdxOffset16, align 4
  %cmp17 = icmp eq i32 %add, %17
  br i1 %cmp17, label %land.lhs.true18, label %if.end22

land.lhs.true18:                                  ; preds = %land.lhs.true14
  %18 = load ptr, ptr %prev_cmd, align 8
  %UserCallback = getelementptr inbounds %struct.ImDrawCmd, ptr %18, i32 0, i32 5
  %19 = load ptr, ptr %UserCallback, align 8
  %cmp19 = icmp eq ptr %19, null
  br i1 %cmp19, label %if.then20, label %if.end22

if.then20:                                        ; preds = %land.lhs.true18
  %CmdBuffer21 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  call void @_ZN8ImVectorI9ImDrawCmdE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(16) %CmdBuffer21)
  br label %return

if.end22:                                         ; preds = %land.lhs.true18, %land.lhs.true14, %land.lhs.true11, %land.lhs.true7, %if.end
  %_CmdHeader23 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 12
  %TextureId24 = getelementptr inbounds %struct.ImDrawCmdHeader, ptr %_CmdHeader23, i32 0, i32 1
  %20 = load ptr, ptr %TextureId24, align 8
  %21 = load ptr, ptr %curr_cmd, align 8
  %TextureId25 = getelementptr inbounds %struct.ImDrawCmd, ptr %21, i32 0, i32 1
  store ptr %20, ptr %TextureId25, align 8
  br label %return

return:                                           ; preds = %if.end22, %if.then20, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList19_OnChangedVtxOffsetEv(ptr noundef nonnull align 8 dereferenceable(196) %this) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %curr_cmd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %_VtxCurrentIdx = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  store i32 0, ptr %_VtxCurrentIdx, align 4
  %CmdBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  %Data = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %CmdBuffer2 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  %Size = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer2, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %sub = sub nsw i32 %1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.ImDrawCmd, ptr %0, i64 %idxprom
  store ptr %arrayidx, ptr %curr_cmd, align 8
  %2 = load ptr, ptr %curr_cmd, align 8
  %ElemCount = getelementptr inbounds %struct.ImDrawCmd, ptr %2, i32 0, i32 4
  %3 = load i32, ptr %ElemCount, align 8
  %cmp = icmp ne i32 %3, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @_ZN10ImDrawList10AddDrawCmdEv(ptr noundef nonnull align 8 dereferenceable(196) %this1)
  br label %return

if.end:                                           ; preds = %entry
  %_CmdHeader = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 12
  %VtxOffset = getelementptr inbounds %struct.ImDrawCmdHeader, ptr %_CmdHeader, i32 0, i32 2
  %4 = load i32, ptr %VtxOffset, align 8
  %5 = load ptr, ptr %curr_cmd, align 8
  %VtxOffset3 = getelementptr inbounds %struct.ImDrawCmd, ptr %5, i32 0, i32 2
  store i32 %4, ptr %VtxOffset3, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define noundef i32 @_ZNK10ImDrawList27_CalcCircleAutoSegmentCountEf(ptr noundef nonnull align 8 dereferenceable(196) %this, float noundef %radius) #4 align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %radius.addr = alloca float, align 4
  %radius_idx = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store float %radius, ptr %radius.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load float, ptr %radius.addr, align 4
  %add = fadd float %0, 0x3FEFFFFDE0000000
  %conv = fptosi float %add to i32
  store i32 %conv, ptr %radius_idx, align 4
  %1 = load i32, ptr %radius_idx, align 4
  %cmp = icmp sge i32 %1, 0
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %2 = load i32, ptr %radius_idx, align 4
  %cmp2 = icmp slt i32 %2, 64
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %_Data = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  %3 = load ptr, ptr %_Data, align 8
  %CircleSegmentCounts = getelementptr inbounds %struct.ImDrawListSharedData, ptr %3, i32 0, i32 10
  %4 = load i32, ptr %radius_idx, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds [64 x i8], ptr %CircleSegmentCounts, i64 0, i64 %idxprom
  %5 = load i8, ptr %arrayidx, align 1
  %conv3 = zext i8 %5 to i32
  store i32 %conv3, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %land.lhs.true, %entry
  %_Data4 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  %6 = load ptr, ptr %_Data4, align 8
  %CircleSegmentMaxError = getelementptr inbounds %struct.ImDrawListSharedData, ptr %6, i32 0, i32 4
  %7 = load float, ptr %CircleSegmentMaxError, align 8
  %8 = load float, ptr %radius.addr, align 4
  %call = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %7, float noundef %8)
  %9 = load float, ptr %radius.addr, align 4
  %div = fdiv float %call, %9
  %sub = fsub float 1.000000e+00, %div
  %call5 = call float @acosf(float noundef %sub) #12
  %div6 = fdiv float 0x400921FB60000000, %call5
  %10 = call float @llvm.ceil.f32(float %div6)
  %conv7 = fptosi float %10 to i32
  %add8 = add nsw i32 %conv7, 1
  %div9 = sdiv i32 %add8, 2
  %mul = mul nsw i32 %div9, 2
  %call10 = call noundef i32 @_ZL7ImClampIiET_S0_S0_S0_(i32 noundef %mul, i32 noundef 4, i32 noundef 512)
  store i32 %call10, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList12PushClipRectERK6ImVec2S2_b(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %cr_min, ptr noundef nonnull align 4 dereferenceable(8) %cr_max, i1 noundef zeroext %intersect_with_current_clip_rect) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %cr_min.addr = alloca ptr, align 8
  %cr_max.addr = alloca ptr, align 8
  %intersect_with_current_clip_rect.addr = alloca i8, align 1
  %cr = alloca %struct.ImVec4, align 4
  %current = alloca %struct.ImVec4, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %cr_min, ptr %cr_min.addr, align 8
  store ptr %cr_max, ptr %cr_max.addr, align 8
  %frombool = zext i1 %intersect_with_current_clip_rect to i8
  store i8 %frombool, ptr %intersect_with_current_clip_rect.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %cr_min.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %0, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %2 = load ptr, ptr %cr_min.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %2, i32 0, i32 1
  %3 = load float, ptr %y, align 4
  %4 = load ptr, ptr %cr_max.addr, align 8
  %x2 = getelementptr inbounds %struct.ImVec2, ptr %4, i32 0, i32 0
  %5 = load float, ptr %x2, align 4
  %6 = load ptr, ptr %cr_max.addr, align 8
  %y3 = getelementptr inbounds %struct.ImVec2, ptr %6, i32 0, i32 1
  %7 = load float, ptr %y3, align 4
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %cr, float noundef %1, float noundef %3, float noundef %5, float noundef %7)
  %8 = load i8, ptr %intersect_with_current_clip_rect.addr, align 1
  %tobool = trunc i8 %8 to i1
  br i1 %tobool, label %if.then, label %if.end28

if.then:                                          ; preds = %entry
  %_CmdHeader = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 12
  %ClipRect = getelementptr inbounds %struct.ImDrawCmdHeader, ptr %_CmdHeader, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %current, ptr align 8 %ClipRect, i64 16, i1 false)
  %x4 = getelementptr inbounds %struct.ImVec4, ptr %cr, i32 0, i32 0
  %9 = load float, ptr %x4, align 4
  %x5 = getelementptr inbounds %struct.ImVec4, ptr %current, i32 0, i32 0
  %10 = load float, ptr %x5, align 4
  %cmp = fcmp olt float %9, %10
  br i1 %cmp, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then
  %x7 = getelementptr inbounds %struct.ImVec4, ptr %current, i32 0, i32 0
  %11 = load float, ptr %x7, align 4
  %x8 = getelementptr inbounds %struct.ImVec4, ptr %cr, i32 0, i32 0
  store float %11, ptr %x8, align 4
  br label %if.end

if.end:                                           ; preds = %if.then6, %if.then
  %y9 = getelementptr inbounds %struct.ImVec4, ptr %cr, i32 0, i32 1
  %12 = load float, ptr %y9, align 4
  %y10 = getelementptr inbounds %struct.ImVec4, ptr %current, i32 0, i32 1
  %13 = load float, ptr %y10, align 4
  %cmp11 = fcmp olt float %12, %13
  br i1 %cmp11, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.end
  %y13 = getelementptr inbounds %struct.ImVec4, ptr %current, i32 0, i32 1
  %14 = load float, ptr %y13, align 4
  %y14 = getelementptr inbounds %struct.ImVec4, ptr %cr, i32 0, i32 1
  store float %14, ptr %y14, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.then12, %if.end
  %z = getelementptr inbounds %struct.ImVec4, ptr %cr, i32 0, i32 2
  %15 = load float, ptr %z, align 4
  %z16 = getelementptr inbounds %struct.ImVec4, ptr %current, i32 0, i32 2
  %16 = load float, ptr %z16, align 4
  %cmp17 = fcmp ogt float %15, %16
  br i1 %cmp17, label %if.then18, label %if.end21

if.then18:                                        ; preds = %if.end15
  %z19 = getelementptr inbounds %struct.ImVec4, ptr %current, i32 0, i32 2
  %17 = load float, ptr %z19, align 4
  %z20 = getelementptr inbounds %struct.ImVec4, ptr %cr, i32 0, i32 2
  store float %17, ptr %z20, align 4
  br label %if.end21

if.end21:                                         ; preds = %if.then18, %if.end15
  %w = getelementptr inbounds %struct.ImVec4, ptr %cr, i32 0, i32 3
  %18 = load float, ptr %w, align 4
  %w22 = getelementptr inbounds %struct.ImVec4, ptr %current, i32 0, i32 3
  %19 = load float, ptr %w22, align 4
  %cmp23 = fcmp ogt float %18, %19
  br i1 %cmp23, label %if.then24, label %if.end27

if.then24:                                        ; preds = %if.end21
  %w25 = getelementptr inbounds %struct.ImVec4, ptr %current, i32 0, i32 3
  %20 = load float, ptr %w25, align 4
  %w26 = getelementptr inbounds %struct.ImVec4, ptr %cr, i32 0, i32 3
  store float %20, ptr %w26, align 4
  br label %if.end27

if.end27:                                         ; preds = %if.then24, %if.end21
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %entry
  %x29 = getelementptr inbounds %struct.ImVec4, ptr %cr, i32 0, i32 0
  %21 = load float, ptr %x29, align 4
  %z30 = getelementptr inbounds %struct.ImVec4, ptr %cr, i32 0, i32 2
  %22 = load float, ptr %z30, align 4
  %call = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %21, float noundef %22)
  %z31 = getelementptr inbounds %struct.ImVec4, ptr %cr, i32 0, i32 2
  store float %call, ptr %z31, align 4
  %y32 = getelementptr inbounds %struct.ImVec4, ptr %cr, i32 0, i32 1
  %23 = load float, ptr %y32, align 4
  %w33 = getelementptr inbounds %struct.ImVec4, ptr %cr, i32 0, i32 3
  %24 = load float, ptr %w33, align 4
  %call34 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %23, float noundef %24)
  %w35 = getelementptr inbounds %struct.ImVec4, ptr %cr, i32 0, i32 3
  store float %call34, ptr %w35, align 4
  %_ClipRectStack = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 9
  call void @_ZN8ImVectorI6ImVec4E9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %_ClipRectStack, ptr noundef nonnull align 4 dereferenceable(16) %cr)
  %_CmdHeader36 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 12
  %ClipRect37 = getelementptr inbounds %struct.ImDrawCmdHeader, ptr %_CmdHeader36, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ClipRect37, ptr align 4 %cr, i64 16, i1 false)
  call void @_ZN10ImDrawList18_OnChangedClipRectEv(ptr noundef nonnull align 8 dereferenceable(196) %this1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI6ImVec4E9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 4 dereferenceable(16) %v) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Size2 = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 0
  %2 = load i32, ptr %Size2, align 8
  %add = add nsw i32 %2, 1
  %call = call noundef i32 @_ZNK8ImVectorI6ImVec4E14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %add)
  call void @_ZN8ImVectorI6ImVec4E7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %Data = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %Size3 = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 0
  %4 = load i32, ptr %Size3, align 8
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds %struct.ImVec4, ptr %3, i64 %idxprom
  %5 = load ptr, ptr %v.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx, ptr align 4 %5, i64 16, i1 false)
  %Size4 = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size4, align 8
  %inc = add nsw i32 %6, 1
  store i32 %inc, ptr %Size4, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList22PushClipRectFullScreenEv(ptr noundef nonnull align 8 dereferenceable(196) %this) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %struct.ImVec2, align 4
  %ref.tmp4 = alloca %struct.ImVec2, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %_Data = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  %0 = load ptr, ptr %_Data, align 8
  %ClipRectFullscreen = getelementptr inbounds %struct.ImDrawListSharedData, ptr %0, i32 0, i32 5
  %x = getelementptr inbounds %struct.ImVec4, ptr %ClipRectFullscreen, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %_Data2 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  %2 = load ptr, ptr %_Data2, align 8
  %ClipRectFullscreen3 = getelementptr inbounds %struct.ImDrawListSharedData, ptr %2, i32 0, i32 5
  %y = getelementptr inbounds %struct.ImVec4, ptr %ClipRectFullscreen3, i32 0, i32 1
  %3 = load float, ptr %y, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef %1, float noundef %3)
  %_Data5 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  %4 = load ptr, ptr %_Data5, align 8
  %ClipRectFullscreen6 = getelementptr inbounds %struct.ImDrawListSharedData, ptr %4, i32 0, i32 5
  %z = getelementptr inbounds %struct.ImVec4, ptr %ClipRectFullscreen6, i32 0, i32 2
  %5 = load float, ptr %z, align 4
  %_Data7 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  %6 = load ptr, ptr %_Data7, align 8
  %ClipRectFullscreen8 = getelementptr inbounds %struct.ImDrawListSharedData, ptr %6, i32 0, i32 5
  %w = getelementptr inbounds %struct.ImVec4, ptr %ClipRectFullscreen8, i32 0, i32 3
  %7 = load float, ptr %w, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp4, float noundef %5, float noundef %7)
  call void @_ZN10ImDrawList12PushClipRectERK6ImVec2S2_b(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp4, i1 noundef zeroext false)
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList11PopClipRectEv(ptr noundef nonnull align 8 dereferenceable(196) %this) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %_ClipRectStack = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 9
  call void @_ZN8ImVectorI6ImVec4E8pop_backEv(ptr noundef nonnull align 8 dereferenceable(16) %_ClipRectStack)
  %_ClipRectStack2 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 9
  %Size = getelementptr inbounds %struct.ImVector.3, ptr %_ClipRectStack2, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %_Data = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  %1 = load ptr, ptr %_Data, align 8
  %ClipRectFullscreen = getelementptr inbounds %struct.ImDrawListSharedData, ptr %1, i32 0, i32 5
  br label %cond.end

cond.false:                                       ; preds = %entry
  %_ClipRectStack3 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 9
  %Data = getelementptr inbounds %struct.ImVector.3, ptr %_ClipRectStack3, i32 0, i32 2
  %2 = load ptr, ptr %Data, align 8
  %_ClipRectStack4 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 9
  %Size5 = getelementptr inbounds %struct.ImVector.3, ptr %_ClipRectStack4, i32 0, i32 0
  %3 = load i32, ptr %Size5, align 8
  %sub = sub nsw i32 %3, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.ImVec4, ptr %2, i64 %idxprom
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond-lvalue = phi ptr [ %ClipRectFullscreen, %cond.true ], [ %arrayidx, %cond.false ]
  %_CmdHeader = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 12
  %ClipRect = getelementptr inbounds %struct.ImDrawCmdHeader, ptr %_CmdHeader, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ClipRect, ptr align 4 %cond-lvalue, i64 16, i1 false)
  call void @_ZN10ImDrawList18_OnChangedClipRectEv(ptr noundef nonnull align 8 dereferenceable(196) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI6ImVec4E8pop_backEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %dec = add nsw i32 %0, -1
  store i32 %dec, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList13PushTextureIDEPv(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef %texture_id) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %texture_id.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %texture_id, ptr %texture_id.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %_TextureIdStack = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 10
  call void @_ZN8ImVectorIPvE9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %_TextureIdStack, ptr noundef nonnull align 8 dereferenceable(8) %texture_id.addr)
  %0 = load ptr, ptr %texture_id.addr, align 8
  %_CmdHeader = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 12
  %TextureId = getelementptr inbounds %struct.ImDrawCmdHeader, ptr %_CmdHeader, i32 0, i32 1
  store ptr %0, ptr %TextureId, align 8
  call void @_ZN10ImDrawList19_OnChangedTextureIDEv(ptr noundef nonnull align 8 dereferenceable(196) %this1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorIPvE9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(8) %v) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Size2 = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 0
  %2 = load i32, ptr %Size2, align 8
  %add = add nsw i32 %2, 1
  %call = call noundef i32 @_ZNK8ImVectorIPvE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %add)
  call void @_ZN8ImVectorIPvE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %Data = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %Size3 = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 0
  %4 = load i32, ptr %Size3, align 8
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %3, i64 %idxprom
  %5 = load ptr, ptr %v.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arrayidx, ptr align 8 %5, i64 8, i1 false)
  %Size4 = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size4, align 8
  %inc = add nsw i32 %6, 1
  store i32 %inc, ptr %Size4, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList12PopTextureIDEv(ptr noundef nonnull align 8 dereferenceable(196) %this) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %_TextureIdStack = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 10
  call void @_ZN8ImVectorIPvE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(16) %_TextureIdStack)
  %_TextureIdStack2 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 10
  %Size = getelementptr inbounds %struct.ImVector.4, ptr %_TextureIdStack2, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %_TextureIdStack3 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 10
  %Data = getelementptr inbounds %struct.ImVector.4, ptr %_TextureIdStack3, i32 0, i32 2
  %1 = load ptr, ptr %Data, align 8
  %_TextureIdStack4 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 10
  %Size5 = getelementptr inbounds %struct.ImVector.4, ptr %_TextureIdStack4, i32 0, i32 0
  %2 = load i32, ptr %Size5, align 8
  %sub = sub nsw i32 %2, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 %idxprom
  %3 = load ptr, ptr %arrayidx, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ null, %cond.true ], [ %3, %cond.false ]
  %_CmdHeader = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 12
  %TextureId = getelementptr inbounds %struct.ImDrawCmdHeader, ptr %_CmdHeader, i32 0, i32 1
  store ptr %cond, ptr %TextureId, align 8
  call void @_ZN10ImDrawList19_OnChangedTextureIDEv(ptr noundef nonnull align 8 dereferenceable(196) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorIPvE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %dec = add nsw i32 %0, -1
  store i32 %dec, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList11PrimReserveEii(ptr noundef nonnull align 8 dereferenceable(196) %this, i32 noundef %idx_count, i32 noundef %vtx_count) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %idx_count.addr = alloca i32, align 4
  %vtx_count.addr = alloca i32, align 4
  %draw_cmd = alloca ptr, align 8
  %vtx_buffer_old_size = alloca i32, align 4
  %idx_buffer_old_size = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %idx_count, ptr %idx_count.addr, align 4
  store i32 %vtx_count, ptr %vtx_count.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %_VtxCurrentIdx = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %0 = load i32, ptr %_VtxCurrentIdx, align 4
  %1 = load i32, ptr %vtx_count.addr, align 4
  %add = add i32 %0, %1
  %cmp = icmp uge i32 %add, 65536
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %Flags = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 3
  %2 = load i32, ptr %Flags, align 8
  %and = and i32 %2, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %VtxBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 2
  %Size = getelementptr inbounds %struct.ImVector.2, ptr %VtxBuffer, i32 0, i32 0
  %3 = load i32, ptr %Size, align 8
  %_CmdHeader = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 12
  %VtxOffset = getelementptr inbounds %struct.ImDrawCmdHeader, ptr %_CmdHeader, i32 0, i32 2
  store i32 %3, ptr %VtxOffset, align 8
  call void @_ZN10ImDrawList19_OnChangedVtxOffsetEv(ptr noundef nonnull align 8 dereferenceable(196) %this1)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %CmdBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  %Data = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer, i32 0, i32 2
  %4 = load ptr, ptr %Data, align 8
  %CmdBuffer2 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  %Size3 = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer2, i32 0, i32 0
  %5 = load i32, ptr %Size3, align 8
  %sub = sub nsw i32 %5, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.ImDrawCmd, ptr %4, i64 %idxprom
  store ptr %arrayidx, ptr %draw_cmd, align 8
  %6 = load i32, ptr %idx_count.addr, align 4
  %7 = load ptr, ptr %draw_cmd, align 8
  %ElemCount = getelementptr inbounds %struct.ImDrawCmd, ptr %7, i32 0, i32 4
  %8 = load i32, ptr %ElemCount, align 8
  %add4 = add i32 %8, %6
  store i32 %add4, ptr %ElemCount, align 8
  %VtxBuffer5 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 2
  %Size6 = getelementptr inbounds %struct.ImVector.2, ptr %VtxBuffer5, i32 0, i32 0
  %9 = load i32, ptr %Size6, align 8
  store i32 %9, ptr %vtx_buffer_old_size, align 4
  %VtxBuffer7 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 2
  %10 = load i32, ptr %vtx_buffer_old_size, align 4
  %11 = load i32, ptr %vtx_count.addr, align 4
  %add8 = add nsw i32 %10, %11
  call void @_ZN8ImVectorI10ImDrawVertE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %VtxBuffer7, i32 noundef %add8)
  %VtxBuffer9 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 2
  %Data10 = getelementptr inbounds %struct.ImVector.2, ptr %VtxBuffer9, i32 0, i32 2
  %12 = load ptr, ptr %Data10, align 8
  %13 = load i32, ptr %vtx_buffer_old_size, align 4
  %idx.ext = sext i32 %13 to i64
  %add.ptr = getelementptr inbounds %struct.ImDrawVert, ptr %12, i64 %idx.ext
  %_VtxWritePtr = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  store ptr %add.ptr, ptr %_VtxWritePtr, align 8
  %IdxBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 1
  %Size11 = getelementptr inbounds %struct.ImVector.1, ptr %IdxBuffer, i32 0, i32 0
  %14 = load i32, ptr %Size11, align 8
  store i32 %14, ptr %idx_buffer_old_size, align 4
  %IdxBuffer12 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 1
  %15 = load i32, ptr %idx_buffer_old_size, align 4
  %16 = load i32, ptr %idx_count.addr, align 4
  %add13 = add nsw i32 %15, %16
  call void @_ZN8ImVectorItE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %IdxBuffer12, i32 noundef %add13)
  %IdxBuffer14 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 1
  %Data15 = getelementptr inbounds %struct.ImVector.1, ptr %IdxBuffer14, i32 0, i32 2
  %17 = load ptr, ptr %Data15, align 8
  %18 = load i32, ptr %idx_buffer_old_size, align 4
  %idx.ext16 = sext i32 %18 to i64
  %add.ptr17 = getelementptr inbounds i16, ptr %17, i64 %idx.ext16
  %_IdxWritePtr = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  store ptr %add.ptr17, ptr %_IdxWritePtr, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList13PrimUnreserveEii(ptr noundef nonnull align 8 dereferenceable(196) %this, i32 noundef %idx_count, i32 noundef %vtx_count) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %idx_count.addr = alloca i32, align 4
  %vtx_count.addr = alloca i32, align 4
  %draw_cmd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %idx_count, ptr %idx_count.addr, align 4
  store i32 %vtx_count, ptr %vtx_count.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %CmdBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  %Data = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %CmdBuffer2 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 0
  %Size = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer2, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %sub = sub nsw i32 %1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.ImDrawCmd, ptr %0, i64 %idxprom
  store ptr %arrayidx, ptr %draw_cmd, align 8
  %2 = load i32, ptr %idx_count.addr, align 4
  %3 = load ptr, ptr %draw_cmd, align 8
  %ElemCount = getelementptr inbounds %struct.ImDrawCmd, ptr %3, i32 0, i32 4
  %4 = load i32, ptr %ElemCount, align 8
  %sub3 = sub i32 %4, %2
  store i32 %sub3, ptr %ElemCount, align 8
  %VtxBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 2
  %VtxBuffer4 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 2
  %Size5 = getelementptr inbounds %struct.ImVector.2, ptr %VtxBuffer4, i32 0, i32 0
  %5 = load i32, ptr %Size5, align 8
  %6 = load i32, ptr %vtx_count.addr, align 4
  %sub6 = sub nsw i32 %5, %6
  call void @_ZN8ImVectorI10ImDrawVertE6shrinkEi(ptr noundef nonnull align 8 dereferenceable(16) %VtxBuffer, i32 noundef %sub6)
  %IdxBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 1
  %IdxBuffer7 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 1
  %Size8 = getelementptr inbounds %struct.ImVector.1, ptr %IdxBuffer7, i32 0, i32 0
  %7 = load i32, ptr %Size8, align 8
  %8 = load i32, ptr %idx_count.addr, align 4
  %sub9 = sub nsw i32 %7, %8
  call void @_ZN8ImVectorItE6shrinkEi(ptr noundef nonnull align 8 dereferenceable(16) %IdxBuffer, i32 noundef %sub9)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI10ImDrawVertE6shrinkEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_size) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_size, ptr %new_size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_size.addr, align 4
  %Size = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 0
  store i32 %0, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorItE6shrinkEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_size) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_size, ptr %new_size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_size.addr, align 4
  %Size = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 0
  store i32 %0, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList8PrimRectERK6ImVec2S2_j(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %a, ptr noundef nonnull align 4 dereferenceable(8) %c, i32 noundef %col) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %a.addr = alloca ptr, align 8
  %c.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  %b = alloca %struct.ImVec2, align 4
  %d = alloca %struct.ImVec2, align 4
  %uv = alloca %struct.ImVec2, align 4
  %idx = alloca i16, align 2
  store ptr %this, ptr %this.addr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %c, ptr %c.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %0, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %2 = load ptr, ptr %a.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %2, i32 0, i32 1
  %3 = load float, ptr %y, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %b, float noundef %1, float noundef %3)
  %4 = load ptr, ptr %a.addr, align 8
  %x2 = getelementptr inbounds %struct.ImVec2, ptr %4, i32 0, i32 0
  %5 = load float, ptr %x2, align 4
  %6 = load ptr, ptr %c.addr, align 8
  %y3 = getelementptr inbounds %struct.ImVec2, ptr %6, i32 0, i32 1
  %7 = load float, ptr %y3, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %d, float noundef %5, float noundef %7)
  %_Data = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  %8 = load ptr, ptr %_Data, align 8
  %TexUvWhitePixel = getelementptr inbounds %struct.ImDrawListSharedData, ptr %8, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv, ptr align 8 %TexUvWhitePixel, i64 8, i1 false)
  %_VtxCurrentIdx = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %9 = load i32, ptr %_VtxCurrentIdx, align 4
  %conv = trunc i32 %9 to i16
  store i16 %conv, ptr %idx, align 2
  %10 = load i16, ptr %idx, align 2
  %_IdxWritePtr = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %11 = load ptr, ptr %_IdxWritePtr, align 8
  %arrayidx = getelementptr inbounds i16, ptr %11, i64 0
  store i16 %10, ptr %arrayidx, align 2
  %12 = load i16, ptr %idx, align 2
  %conv4 = zext i16 %12 to i32
  %add = add nsw i32 %conv4, 1
  %conv5 = trunc i32 %add to i16
  %_IdxWritePtr6 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %13 = load ptr, ptr %_IdxWritePtr6, align 8
  %arrayidx7 = getelementptr inbounds i16, ptr %13, i64 1
  store i16 %conv5, ptr %arrayidx7, align 2
  %14 = load i16, ptr %idx, align 2
  %conv8 = zext i16 %14 to i32
  %add9 = add nsw i32 %conv8, 2
  %conv10 = trunc i32 %add9 to i16
  %_IdxWritePtr11 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %15 = load ptr, ptr %_IdxWritePtr11, align 8
  %arrayidx12 = getelementptr inbounds i16, ptr %15, i64 2
  store i16 %conv10, ptr %arrayidx12, align 2
  %16 = load i16, ptr %idx, align 2
  %_IdxWritePtr13 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %17 = load ptr, ptr %_IdxWritePtr13, align 8
  %arrayidx14 = getelementptr inbounds i16, ptr %17, i64 3
  store i16 %16, ptr %arrayidx14, align 2
  %18 = load i16, ptr %idx, align 2
  %conv15 = zext i16 %18 to i32
  %add16 = add nsw i32 %conv15, 2
  %conv17 = trunc i32 %add16 to i16
  %_IdxWritePtr18 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %19 = load ptr, ptr %_IdxWritePtr18, align 8
  %arrayidx19 = getelementptr inbounds i16, ptr %19, i64 4
  store i16 %conv17, ptr %arrayidx19, align 2
  %20 = load i16, ptr %idx, align 2
  %conv20 = zext i16 %20 to i32
  %add21 = add nsw i32 %conv20, 3
  %conv22 = trunc i32 %add21 to i16
  %_IdxWritePtr23 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %21 = load ptr, ptr %_IdxWritePtr23, align 8
  %arrayidx24 = getelementptr inbounds i16, ptr %21, i64 5
  store i16 %conv22, ptr %arrayidx24, align 2
  %22 = load ptr, ptr %a.addr, align 8
  %_VtxWritePtr = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %23 = load ptr, ptr %_VtxWritePtr, align 8
  %arrayidx25 = getelementptr inbounds %struct.ImDrawVert, ptr %23, i64 0
  %pos = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx25, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %pos, ptr align 4 %22, i64 8, i1 false)
  %_VtxWritePtr26 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %24 = load ptr, ptr %_VtxWritePtr26, align 8
  %arrayidx27 = getelementptr inbounds %struct.ImDrawVert, ptr %24, i64 0
  %uv28 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx27, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv28, ptr align 4 %uv, i64 8, i1 false)
  %25 = load i32, ptr %col.addr, align 4
  %_VtxWritePtr29 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %26 = load ptr, ptr %_VtxWritePtr29, align 8
  %arrayidx30 = getelementptr inbounds %struct.ImDrawVert, ptr %26, i64 0
  %col31 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx30, i32 0, i32 2
  store i32 %25, ptr %col31, align 4
  %_VtxWritePtr32 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %27 = load ptr, ptr %_VtxWritePtr32, align 8
  %arrayidx33 = getelementptr inbounds %struct.ImDrawVert, ptr %27, i64 1
  %pos34 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx33, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %pos34, ptr align 4 %b, i64 8, i1 false)
  %_VtxWritePtr35 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %28 = load ptr, ptr %_VtxWritePtr35, align 8
  %arrayidx36 = getelementptr inbounds %struct.ImDrawVert, ptr %28, i64 1
  %uv37 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx36, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv37, ptr align 4 %uv, i64 8, i1 false)
  %29 = load i32, ptr %col.addr, align 4
  %_VtxWritePtr38 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %30 = load ptr, ptr %_VtxWritePtr38, align 8
  %arrayidx39 = getelementptr inbounds %struct.ImDrawVert, ptr %30, i64 1
  %col40 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx39, i32 0, i32 2
  store i32 %29, ptr %col40, align 4
  %31 = load ptr, ptr %c.addr, align 8
  %_VtxWritePtr41 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %32 = load ptr, ptr %_VtxWritePtr41, align 8
  %arrayidx42 = getelementptr inbounds %struct.ImDrawVert, ptr %32, i64 2
  %pos43 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx42, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %pos43, ptr align 4 %31, i64 8, i1 false)
  %_VtxWritePtr44 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %33 = load ptr, ptr %_VtxWritePtr44, align 8
  %arrayidx45 = getelementptr inbounds %struct.ImDrawVert, ptr %33, i64 2
  %uv46 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx45, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv46, ptr align 4 %uv, i64 8, i1 false)
  %34 = load i32, ptr %col.addr, align 4
  %_VtxWritePtr47 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %35 = load ptr, ptr %_VtxWritePtr47, align 8
  %arrayidx48 = getelementptr inbounds %struct.ImDrawVert, ptr %35, i64 2
  %col49 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx48, i32 0, i32 2
  store i32 %34, ptr %col49, align 4
  %_VtxWritePtr50 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %36 = load ptr, ptr %_VtxWritePtr50, align 8
  %arrayidx51 = getelementptr inbounds %struct.ImDrawVert, ptr %36, i64 3
  %pos52 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx51, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %pos52, ptr align 4 %d, i64 8, i1 false)
  %_VtxWritePtr53 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %37 = load ptr, ptr %_VtxWritePtr53, align 8
  %arrayidx54 = getelementptr inbounds %struct.ImDrawVert, ptr %37, i64 3
  %uv55 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx54, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv55, ptr align 4 %uv, i64 8, i1 false)
  %38 = load i32, ptr %col.addr, align 4
  %_VtxWritePtr56 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %39 = load ptr, ptr %_VtxWritePtr56, align 8
  %arrayidx57 = getelementptr inbounds %struct.ImDrawVert, ptr %39, i64 3
  %col58 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx57, i32 0, i32 2
  store i32 %38, ptr %col58, align 4
  %_VtxWritePtr59 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %40 = load ptr, ptr %_VtxWritePtr59, align 8
  %add.ptr = getelementptr inbounds %struct.ImDrawVert, ptr %40, i64 4
  store ptr %add.ptr, ptr %_VtxWritePtr59, align 8
  %_VtxCurrentIdx60 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %41 = load i32, ptr %_VtxCurrentIdx60, align 4
  %add61 = add i32 %41, 4
  store i32 %add61, ptr %_VtxCurrentIdx60, align 4
  %_IdxWritePtr62 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %42 = load ptr, ptr %_IdxWritePtr62, align 8
  %add.ptr63 = getelementptr inbounds i16, ptr %42, i64 6
  store ptr %add.ptr63, ptr %_IdxWritePtr62, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList10PrimRectUVERK6ImVec2S2_S2_S2_j(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %a, ptr noundef nonnull align 4 dereferenceable(8) %c, ptr noundef nonnull align 4 dereferenceable(8) %uv_a, ptr noundef nonnull align 4 dereferenceable(8) %uv_c, i32 noundef %col) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %a.addr = alloca ptr, align 8
  %c.addr = alloca ptr, align 8
  %uv_a.addr = alloca ptr, align 8
  %uv_c.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  %b = alloca %struct.ImVec2, align 4
  %d = alloca %struct.ImVec2, align 4
  %uv_b = alloca %struct.ImVec2, align 4
  %uv_d = alloca %struct.ImVec2, align 4
  %idx = alloca i16, align 2
  store ptr %this, ptr %this.addr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %uv_a, ptr %uv_a.addr, align 8
  store ptr %uv_c, ptr %uv_c.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %0, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %2 = load ptr, ptr %a.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %2, i32 0, i32 1
  %3 = load float, ptr %y, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %b, float noundef %1, float noundef %3)
  %4 = load ptr, ptr %a.addr, align 8
  %x2 = getelementptr inbounds %struct.ImVec2, ptr %4, i32 0, i32 0
  %5 = load float, ptr %x2, align 4
  %6 = load ptr, ptr %c.addr, align 8
  %y3 = getelementptr inbounds %struct.ImVec2, ptr %6, i32 0, i32 1
  %7 = load float, ptr %y3, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %d, float noundef %5, float noundef %7)
  %8 = load ptr, ptr %uv_c.addr, align 8
  %x4 = getelementptr inbounds %struct.ImVec2, ptr %8, i32 0, i32 0
  %9 = load float, ptr %x4, align 4
  %10 = load ptr, ptr %uv_a.addr, align 8
  %y5 = getelementptr inbounds %struct.ImVec2, ptr %10, i32 0, i32 1
  %11 = load float, ptr %y5, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %uv_b, float noundef %9, float noundef %11)
  %12 = load ptr, ptr %uv_a.addr, align 8
  %x6 = getelementptr inbounds %struct.ImVec2, ptr %12, i32 0, i32 0
  %13 = load float, ptr %x6, align 4
  %14 = load ptr, ptr %uv_c.addr, align 8
  %y7 = getelementptr inbounds %struct.ImVec2, ptr %14, i32 0, i32 1
  %15 = load float, ptr %y7, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %uv_d, float noundef %13, float noundef %15)
  %_VtxCurrentIdx = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %16 = load i32, ptr %_VtxCurrentIdx, align 4
  %conv = trunc i32 %16 to i16
  store i16 %conv, ptr %idx, align 2
  %17 = load i16, ptr %idx, align 2
  %_IdxWritePtr = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %18 = load ptr, ptr %_IdxWritePtr, align 8
  %arrayidx = getelementptr inbounds i16, ptr %18, i64 0
  store i16 %17, ptr %arrayidx, align 2
  %19 = load i16, ptr %idx, align 2
  %conv8 = zext i16 %19 to i32
  %add = add nsw i32 %conv8, 1
  %conv9 = trunc i32 %add to i16
  %_IdxWritePtr10 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %20 = load ptr, ptr %_IdxWritePtr10, align 8
  %arrayidx11 = getelementptr inbounds i16, ptr %20, i64 1
  store i16 %conv9, ptr %arrayidx11, align 2
  %21 = load i16, ptr %idx, align 2
  %conv12 = zext i16 %21 to i32
  %add13 = add nsw i32 %conv12, 2
  %conv14 = trunc i32 %add13 to i16
  %_IdxWritePtr15 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %22 = load ptr, ptr %_IdxWritePtr15, align 8
  %arrayidx16 = getelementptr inbounds i16, ptr %22, i64 2
  store i16 %conv14, ptr %arrayidx16, align 2
  %23 = load i16, ptr %idx, align 2
  %_IdxWritePtr17 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %24 = load ptr, ptr %_IdxWritePtr17, align 8
  %arrayidx18 = getelementptr inbounds i16, ptr %24, i64 3
  store i16 %23, ptr %arrayidx18, align 2
  %25 = load i16, ptr %idx, align 2
  %conv19 = zext i16 %25 to i32
  %add20 = add nsw i32 %conv19, 2
  %conv21 = trunc i32 %add20 to i16
  %_IdxWritePtr22 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %26 = load ptr, ptr %_IdxWritePtr22, align 8
  %arrayidx23 = getelementptr inbounds i16, ptr %26, i64 4
  store i16 %conv21, ptr %arrayidx23, align 2
  %27 = load i16, ptr %idx, align 2
  %conv24 = zext i16 %27 to i32
  %add25 = add nsw i32 %conv24, 3
  %conv26 = trunc i32 %add25 to i16
  %_IdxWritePtr27 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %28 = load ptr, ptr %_IdxWritePtr27, align 8
  %arrayidx28 = getelementptr inbounds i16, ptr %28, i64 5
  store i16 %conv26, ptr %arrayidx28, align 2
  %29 = load ptr, ptr %a.addr, align 8
  %_VtxWritePtr = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %30 = load ptr, ptr %_VtxWritePtr, align 8
  %arrayidx29 = getelementptr inbounds %struct.ImDrawVert, ptr %30, i64 0
  %pos = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx29, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %pos, ptr align 4 %29, i64 8, i1 false)
  %31 = load ptr, ptr %uv_a.addr, align 8
  %_VtxWritePtr30 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %32 = load ptr, ptr %_VtxWritePtr30, align 8
  %arrayidx31 = getelementptr inbounds %struct.ImDrawVert, ptr %32, i64 0
  %uv = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx31, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv, ptr align 4 %31, i64 8, i1 false)
  %33 = load i32, ptr %col.addr, align 4
  %_VtxWritePtr32 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %34 = load ptr, ptr %_VtxWritePtr32, align 8
  %arrayidx33 = getelementptr inbounds %struct.ImDrawVert, ptr %34, i64 0
  %col34 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx33, i32 0, i32 2
  store i32 %33, ptr %col34, align 4
  %_VtxWritePtr35 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %35 = load ptr, ptr %_VtxWritePtr35, align 8
  %arrayidx36 = getelementptr inbounds %struct.ImDrawVert, ptr %35, i64 1
  %pos37 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx36, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %pos37, ptr align 4 %b, i64 8, i1 false)
  %_VtxWritePtr38 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %36 = load ptr, ptr %_VtxWritePtr38, align 8
  %arrayidx39 = getelementptr inbounds %struct.ImDrawVert, ptr %36, i64 1
  %uv40 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx39, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv40, ptr align 4 %uv_b, i64 8, i1 false)
  %37 = load i32, ptr %col.addr, align 4
  %_VtxWritePtr41 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %38 = load ptr, ptr %_VtxWritePtr41, align 8
  %arrayidx42 = getelementptr inbounds %struct.ImDrawVert, ptr %38, i64 1
  %col43 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx42, i32 0, i32 2
  store i32 %37, ptr %col43, align 4
  %39 = load ptr, ptr %c.addr, align 8
  %_VtxWritePtr44 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %40 = load ptr, ptr %_VtxWritePtr44, align 8
  %arrayidx45 = getelementptr inbounds %struct.ImDrawVert, ptr %40, i64 2
  %pos46 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx45, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %pos46, ptr align 4 %39, i64 8, i1 false)
  %41 = load ptr, ptr %uv_c.addr, align 8
  %_VtxWritePtr47 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %42 = load ptr, ptr %_VtxWritePtr47, align 8
  %arrayidx48 = getelementptr inbounds %struct.ImDrawVert, ptr %42, i64 2
  %uv49 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx48, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv49, ptr align 4 %41, i64 8, i1 false)
  %43 = load i32, ptr %col.addr, align 4
  %_VtxWritePtr50 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %44 = load ptr, ptr %_VtxWritePtr50, align 8
  %arrayidx51 = getelementptr inbounds %struct.ImDrawVert, ptr %44, i64 2
  %col52 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx51, i32 0, i32 2
  store i32 %43, ptr %col52, align 4
  %_VtxWritePtr53 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %45 = load ptr, ptr %_VtxWritePtr53, align 8
  %arrayidx54 = getelementptr inbounds %struct.ImDrawVert, ptr %45, i64 3
  %pos55 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx54, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %pos55, ptr align 4 %d, i64 8, i1 false)
  %_VtxWritePtr56 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %46 = load ptr, ptr %_VtxWritePtr56, align 8
  %arrayidx57 = getelementptr inbounds %struct.ImDrawVert, ptr %46, i64 3
  %uv58 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx57, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv58, ptr align 4 %uv_d, i64 8, i1 false)
  %47 = load i32, ptr %col.addr, align 4
  %_VtxWritePtr59 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %48 = load ptr, ptr %_VtxWritePtr59, align 8
  %arrayidx60 = getelementptr inbounds %struct.ImDrawVert, ptr %48, i64 3
  %col61 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx60, i32 0, i32 2
  store i32 %47, ptr %col61, align 4
  %_VtxWritePtr62 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %49 = load ptr, ptr %_VtxWritePtr62, align 8
  %add.ptr = getelementptr inbounds %struct.ImDrawVert, ptr %49, i64 4
  store ptr %add.ptr, ptr %_VtxWritePtr62, align 8
  %_VtxCurrentIdx63 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %50 = load i32, ptr %_VtxCurrentIdx63, align 4
  %add64 = add i32 %50, 4
  store i32 %add64, ptr %_VtxCurrentIdx63, align 4
  %_IdxWritePtr65 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %51 = load ptr, ptr %_IdxWritePtr65, align 8
  %add.ptr66 = getelementptr inbounds i16, ptr %51, i64 6
  store ptr %add.ptr66, ptr %_IdxWritePtr65, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define void @_ZN10ImDrawList10PrimQuadUVERK6ImVec2S2_S2_S2_S2_S2_S2_S2_j(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %a, ptr noundef nonnull align 4 dereferenceable(8) %b, ptr noundef nonnull align 4 dereferenceable(8) %c, ptr noundef nonnull align 4 dereferenceable(8) %d, ptr noundef nonnull align 4 dereferenceable(8) %uv_a, ptr noundef nonnull align 4 dereferenceable(8) %uv_b, ptr noundef nonnull align 4 dereferenceable(8) %uv_c, ptr noundef nonnull align 4 dereferenceable(8) %uv_d, i32 noundef %col) #2 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %c.addr = alloca ptr, align 8
  %d.addr = alloca ptr, align 8
  %uv_a.addr = alloca ptr, align 8
  %uv_b.addr = alloca ptr, align 8
  %uv_c.addr = alloca ptr, align 8
  %uv_d.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  %idx = alloca i16, align 2
  store ptr %this, ptr %this.addr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %d, ptr %d.addr, align 8
  store ptr %uv_a, ptr %uv_a.addr, align 8
  store ptr %uv_b, ptr %uv_b.addr, align 8
  store ptr %uv_c, ptr %uv_c.addr, align 8
  store ptr %uv_d, ptr %uv_d.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %_VtxCurrentIdx = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %0 = load i32, ptr %_VtxCurrentIdx, align 4
  %conv = trunc i32 %0 to i16
  store i16 %conv, ptr %idx, align 2
  %1 = load i16, ptr %idx, align 2
  %_IdxWritePtr = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %2 = load ptr, ptr %_IdxWritePtr, align 8
  %arrayidx = getelementptr inbounds i16, ptr %2, i64 0
  store i16 %1, ptr %arrayidx, align 2
  %3 = load i16, ptr %idx, align 2
  %conv2 = zext i16 %3 to i32
  %add = add nsw i32 %conv2, 1
  %conv3 = trunc i32 %add to i16
  %_IdxWritePtr4 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %4 = load ptr, ptr %_IdxWritePtr4, align 8
  %arrayidx5 = getelementptr inbounds i16, ptr %4, i64 1
  store i16 %conv3, ptr %arrayidx5, align 2
  %5 = load i16, ptr %idx, align 2
  %conv6 = zext i16 %5 to i32
  %add7 = add nsw i32 %conv6, 2
  %conv8 = trunc i32 %add7 to i16
  %_IdxWritePtr9 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %6 = load ptr, ptr %_IdxWritePtr9, align 8
  %arrayidx10 = getelementptr inbounds i16, ptr %6, i64 2
  store i16 %conv8, ptr %arrayidx10, align 2
  %7 = load i16, ptr %idx, align 2
  %_IdxWritePtr11 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %8 = load ptr, ptr %_IdxWritePtr11, align 8
  %arrayidx12 = getelementptr inbounds i16, ptr %8, i64 3
  store i16 %7, ptr %arrayidx12, align 2
  %9 = load i16, ptr %idx, align 2
  %conv13 = zext i16 %9 to i32
  %add14 = add nsw i32 %conv13, 2
  %conv15 = trunc i32 %add14 to i16
  %_IdxWritePtr16 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %10 = load ptr, ptr %_IdxWritePtr16, align 8
  %arrayidx17 = getelementptr inbounds i16, ptr %10, i64 4
  store i16 %conv15, ptr %arrayidx17, align 2
  %11 = load i16, ptr %idx, align 2
  %conv18 = zext i16 %11 to i32
  %add19 = add nsw i32 %conv18, 3
  %conv20 = trunc i32 %add19 to i16
  %_IdxWritePtr21 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %12 = load ptr, ptr %_IdxWritePtr21, align 8
  %arrayidx22 = getelementptr inbounds i16, ptr %12, i64 5
  store i16 %conv20, ptr %arrayidx22, align 2
  %13 = load ptr, ptr %a.addr, align 8
  %_VtxWritePtr = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %14 = load ptr, ptr %_VtxWritePtr, align 8
  %arrayidx23 = getelementptr inbounds %struct.ImDrawVert, ptr %14, i64 0
  %pos = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx23, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %pos, ptr align 4 %13, i64 8, i1 false)
  %15 = load ptr, ptr %uv_a.addr, align 8
  %_VtxWritePtr24 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %16 = load ptr, ptr %_VtxWritePtr24, align 8
  %arrayidx25 = getelementptr inbounds %struct.ImDrawVert, ptr %16, i64 0
  %uv = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx25, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv, ptr align 4 %15, i64 8, i1 false)
  %17 = load i32, ptr %col.addr, align 4
  %_VtxWritePtr26 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %18 = load ptr, ptr %_VtxWritePtr26, align 8
  %arrayidx27 = getelementptr inbounds %struct.ImDrawVert, ptr %18, i64 0
  %col28 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx27, i32 0, i32 2
  store i32 %17, ptr %col28, align 4
  %19 = load ptr, ptr %b.addr, align 8
  %_VtxWritePtr29 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %20 = load ptr, ptr %_VtxWritePtr29, align 8
  %arrayidx30 = getelementptr inbounds %struct.ImDrawVert, ptr %20, i64 1
  %pos31 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx30, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %pos31, ptr align 4 %19, i64 8, i1 false)
  %21 = load ptr, ptr %uv_b.addr, align 8
  %_VtxWritePtr32 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %22 = load ptr, ptr %_VtxWritePtr32, align 8
  %arrayidx33 = getelementptr inbounds %struct.ImDrawVert, ptr %22, i64 1
  %uv34 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx33, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv34, ptr align 4 %21, i64 8, i1 false)
  %23 = load i32, ptr %col.addr, align 4
  %_VtxWritePtr35 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %24 = load ptr, ptr %_VtxWritePtr35, align 8
  %arrayidx36 = getelementptr inbounds %struct.ImDrawVert, ptr %24, i64 1
  %col37 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx36, i32 0, i32 2
  store i32 %23, ptr %col37, align 4
  %25 = load ptr, ptr %c.addr, align 8
  %_VtxWritePtr38 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %26 = load ptr, ptr %_VtxWritePtr38, align 8
  %arrayidx39 = getelementptr inbounds %struct.ImDrawVert, ptr %26, i64 2
  %pos40 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx39, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %pos40, ptr align 4 %25, i64 8, i1 false)
  %27 = load ptr, ptr %uv_c.addr, align 8
  %_VtxWritePtr41 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %28 = load ptr, ptr %_VtxWritePtr41, align 8
  %arrayidx42 = getelementptr inbounds %struct.ImDrawVert, ptr %28, i64 2
  %uv43 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx42, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv43, ptr align 4 %27, i64 8, i1 false)
  %29 = load i32, ptr %col.addr, align 4
  %_VtxWritePtr44 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %30 = load ptr, ptr %_VtxWritePtr44, align 8
  %arrayidx45 = getelementptr inbounds %struct.ImDrawVert, ptr %30, i64 2
  %col46 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx45, i32 0, i32 2
  store i32 %29, ptr %col46, align 4
  %31 = load ptr, ptr %d.addr, align 8
  %_VtxWritePtr47 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %32 = load ptr, ptr %_VtxWritePtr47, align 8
  %arrayidx48 = getelementptr inbounds %struct.ImDrawVert, ptr %32, i64 3
  %pos49 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx48, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %pos49, ptr align 4 %31, i64 8, i1 false)
  %33 = load ptr, ptr %uv_d.addr, align 8
  %_VtxWritePtr50 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %34 = load ptr, ptr %_VtxWritePtr50, align 8
  %arrayidx51 = getelementptr inbounds %struct.ImDrawVert, ptr %34, i64 3
  %uv52 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx51, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv52, ptr align 4 %33, i64 8, i1 false)
  %35 = load i32, ptr %col.addr, align 4
  %_VtxWritePtr53 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %36 = load ptr, ptr %_VtxWritePtr53, align 8
  %arrayidx54 = getelementptr inbounds %struct.ImDrawVert, ptr %36, i64 3
  %col55 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx54, i32 0, i32 2
  store i32 %35, ptr %col55, align 4
  %_VtxWritePtr56 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %37 = load ptr, ptr %_VtxWritePtr56, align 8
  %add.ptr = getelementptr inbounds %struct.ImDrawVert, ptr %37, i64 4
  store ptr %add.ptr, ptr %_VtxWritePtr56, align 8
  %_VtxCurrentIdx57 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %38 = load i32, ptr %_VtxCurrentIdx57, align 4
  %add58 = add i32 %38, 4
  store i32 %add58, ptr %_VtxCurrentIdx57, align 4
  %_IdxWritePtr59 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %39 = load ptr, ptr %_IdxWritePtr59, align 8
  %add.ptr60 = getelementptr inbounds i16, ptr %39, i64 6
  store ptr %add.ptr60, ptr %_IdxWritePtr59, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList11AddPolylineEPK6ImVec2ijif(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef %points, i32 noundef %points_count, i32 noundef %col, i32 noundef %flags, float noundef %thickness) #0 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %points.addr = alloca ptr, align 8
  %points_count.addr = alloca i32, align 4
  %col.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %thickness.addr = alloca float, align 4
  %closed = alloca i8, align 1
  %opaque_uv = alloca %struct.ImVec2, align 4
  %count = alloca i32, align 4
  %thick_line = alloca i8, align 1
  %AA_SIZE = alloca float, align 4
  %col_trans = alloca i32, align 4
  %integer_thickness = alloca i32, align 4
  %fractional_thickness = alloca float, align 4
  %use_texture = alloca i8, align 1
  %idx_count = alloca i32, align 4
  %vtx_count = alloca i32, align 4
  %temp_normals = alloca ptr, align 8
  %temp_points = alloca ptr, align 8
  %i1 = alloca i32, align 4
  %i2 = alloca i32, align 4
  %dx = alloca float, align 4
  %dy = alloca float, align 4
  %d2 = alloca float, align 4
  %inv_len = alloca float, align 4
  %half_draw_size = alloca float, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  %ref.tmp107 = alloca %struct.ImVec2, align 4
  %ref.tmp112 = alloca %struct.ImVec2, align 4
  %ref.tmp114 = alloca %struct.ImVec2, align 4
  %ref.tmp119 = alloca %struct.ImVec2, align 4
  %ref.tmp123 = alloca %struct.ImVec2, align 4
  %ref.tmp134 = alloca %struct.ImVec2, align 4
  %ref.tmp138 = alloca %struct.ImVec2, align 4
  %idx1 = alloca i32, align 4
  %i1150 = alloca i32, align 4
  %i2154 = alloca i32, align 4
  %idx2 = alloca i32, align 4
  %dm_x = alloca float, align 4
  %dm_y = alloca float, align 4
  %d2188 = alloca float, align 4
  %inv_len2 = alloca float, align 4
  %out_vtx = alloca ptr, align 8
  %tex_uvs = alloca %struct.ImVec4, align 4
  %tex_uv0 = alloca %struct.ImVec2, align 4
  %tex_uv1 = alloca %struct.ImVec2, align 4
  %i = alloca i32, align 4
  %i348 = alloca i32, align 4
  %half_inner_thickness = alloca float, align 4
  %points_last = alloca i32, align 4
  %ref.tmp401 = alloca %struct.ImVec2, align 4
  %ref.tmp403 = alloca %struct.ImVec2, align 4
  %ref.tmp409 = alloca %struct.ImVec2, align 4
  %ref.tmp411 = alloca %struct.ImVec2, align 4
  %ref.tmp416 = alloca %struct.ImVec2, align 4
  %ref.tmp418 = alloca %struct.ImVec2, align 4
  %ref.tmp423 = alloca %struct.ImVec2, align 4
  %ref.tmp425 = alloca %struct.ImVec2, align 4
  %ref.tmp431 = alloca %struct.ImVec2, align 4
  %ref.tmp434 = alloca %struct.ImVec2, align 4
  %ref.tmp444 = alloca %struct.ImVec2, align 4
  %ref.tmp447 = alloca %struct.ImVec2, align 4
  %ref.tmp456 = alloca %struct.ImVec2, align 4
  %ref.tmp459 = alloca %struct.ImVec2, align 4
  %ref.tmp468 = alloca %struct.ImVec2, align 4
  %ref.tmp471 = alloca %struct.ImVec2, align 4
  %idx1482 = alloca i32, align 4
  %i1484 = alloca i32, align 4
  %i2488 = alloca i32, align 4
  %idx2496 = alloca i32, align 4
  %dm_x505 = alloca float, align 4
  %dm_y514 = alloca float, align 4
  %d2523 = alloca float, align 4
  %inv_len2528 = alloca float, align 4
  %dm_out_x = alloca float, align 4
  %dm_out_y = alloca float, align 4
  %dm_in_x = alloca float, align 4
  %dm_in_y = alloca float, align 4
  %out_vtx542 = alloca ptr, align 8
  %i671 = alloca i32, align 4
  %idx_count738 = alloca i32, align 4
  %vtx_count740 = alloca i32, align 4
  %i1742 = alloca i32, align 4
  %i2746 = alloca i32, align 4
  %p1 = alloca ptr, align 8
  %p2 = alloca ptr, align 8
  %dx758 = alloca float, align 4
  %dy762 = alloca float, align 4
  %d2766 = alloca float, align 4
  %inv_len771 = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %points, ptr %points.addr, align 8
  store i32 %points_count, ptr %points_count.addr, align 4
  store i32 %col, ptr %col.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  store float %thickness, ptr %thickness.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %points_count.addr, align 4
  %cmp = icmp slt i32 %0, 2
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %col.addr, align 4
  %and = and i32 %1, -16777216
  %cmp2 = icmp eq i32 %and, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %if.end889

if.end:                                           ; preds = %lor.lhs.false
  %2 = load i32, ptr %flags.addr, align 4
  %and3 = and i32 %2, 1
  %cmp4 = icmp ne i32 %and3, 0
  %frombool = zext i1 %cmp4 to i8
  store i8 %frombool, ptr %closed, align 1
  %_Data = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  %3 = load ptr, ptr %_Data, align 8
  %TexUvWhitePixel = getelementptr inbounds %struct.ImDrawListSharedData, ptr %3, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %opaque_uv, ptr align 8 %TexUvWhitePixel, i64 8, i1 false)
  %4 = load i8, ptr %closed, align 1
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %5 = load i32, ptr %points_count.addr, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %6 = load i32, ptr %points_count.addr, align 4
  %sub = sub nsw i32 %6, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %5, %cond.true ], [ %sub, %cond.false ]
  store i32 %cond, ptr %count, align 4
  %7 = load float, ptr %thickness.addr, align 4
  %_FringeScale = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 14
  %8 = load float, ptr %_FringeScale, align 8
  %cmp5 = fcmp ogt float %7, %8
  %frombool6 = zext i1 %cmp5 to i8
  store i8 %frombool6, ptr %thick_line, align 1
  %Flags = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 3
  %9 = load i32, ptr %Flags, align 8
  %and7 = and i32 %9, 1
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %if.then9, label %if.else737

if.then9:                                         ; preds = %cond.end
  %_FringeScale10 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 14
  %10 = load float, ptr %_FringeScale10, align 8
  store float %10, ptr %AA_SIZE, align 4
  %11 = load i32, ptr %col.addr, align 4
  %and11 = and i32 %11, 16777215
  store i32 %and11, ptr %col_trans, align 4
  %12 = load float, ptr %thickness.addr, align 4
  %call = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %12, float noundef 1.000000e+00)
  store float %call, ptr %thickness.addr, align 4
  %13 = load float, ptr %thickness.addr, align 4
  %conv = fptosi float %13 to i32
  store i32 %conv, ptr %integer_thickness, align 4
  %14 = load float, ptr %thickness.addr, align 4
  %15 = load i32, ptr %integer_thickness, align 4
  %conv12 = sitofp i32 %15 to float
  %sub13 = fsub float %14, %conv12
  store float %sub13, ptr %fractional_thickness, align 4
  %Flags14 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 3
  %16 = load i32, ptr %Flags14, align 8
  %and15 = and i32 %16, 2
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %if.then9
  %17 = load i32, ptr %integer_thickness, align 4
  %cmp17 = icmp slt i32 %17, 63
  br i1 %cmp17, label %land.lhs.true18, label %land.end

land.lhs.true18:                                  ; preds = %land.lhs.true
  %18 = load float, ptr %fractional_thickness, align 4
  %cmp19 = fcmp ole float %18, 0x3EE4F8B580000000
  br i1 %cmp19, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true18
  %19 = load float, ptr %AA_SIZE, align 4
  %cmp20 = fcmp oeq float %19, 1.000000e+00
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true18, %land.lhs.true, %if.then9
  %20 = phi i1 [ false, %land.lhs.true18 ], [ false, %land.lhs.true ], [ false, %if.then9 ], [ %cmp20, %land.rhs ]
  %frombool21 = zext i1 %20 to i8
  store i8 %frombool21, ptr %use_texture, align 1
  %21 = load i8, ptr %use_texture, align 1
  %tobool22 = trunc i8 %21 to i1
  br i1 %tobool22, label %cond.true23, label %cond.false24

cond.true23:                                      ; preds = %land.end
  %22 = load i32, ptr %count, align 4
  %mul = mul nsw i32 %22, 6
  br label %cond.end32

cond.false24:                                     ; preds = %land.end
  %23 = load i8, ptr %thick_line, align 1
  %tobool25 = trunc i8 %23 to i1
  br i1 %tobool25, label %cond.true26, label %cond.false28

cond.true26:                                      ; preds = %cond.false24
  %24 = load i32, ptr %count, align 4
  %mul27 = mul nsw i32 %24, 18
  br label %cond.end30

cond.false28:                                     ; preds = %cond.false24
  %25 = load i32, ptr %count, align 4
  %mul29 = mul nsw i32 %25, 12
  br label %cond.end30

cond.end30:                                       ; preds = %cond.false28, %cond.true26
  %cond31 = phi i32 [ %mul27, %cond.true26 ], [ %mul29, %cond.false28 ]
  br label %cond.end32

cond.end32:                                       ; preds = %cond.end30, %cond.true23
  %cond33 = phi i32 [ %mul, %cond.true23 ], [ %cond31, %cond.end30 ]
  store i32 %cond33, ptr %idx_count, align 4
  %26 = load i8, ptr %use_texture, align 1
  %tobool34 = trunc i8 %26 to i1
  br i1 %tobool34, label %cond.true35, label %cond.false37

cond.true35:                                      ; preds = %cond.end32
  %27 = load i32, ptr %points_count.addr, align 4
  %mul36 = mul nsw i32 %27, 2
  br label %cond.end45

cond.false37:                                     ; preds = %cond.end32
  %28 = load i8, ptr %thick_line, align 1
  %tobool38 = trunc i8 %28 to i1
  br i1 %tobool38, label %cond.true39, label %cond.false41

cond.true39:                                      ; preds = %cond.false37
  %29 = load i32, ptr %points_count.addr, align 4
  %mul40 = mul nsw i32 %29, 4
  br label %cond.end43

cond.false41:                                     ; preds = %cond.false37
  %30 = load i32, ptr %points_count.addr, align 4
  %mul42 = mul nsw i32 %30, 3
  br label %cond.end43

cond.end43:                                       ; preds = %cond.false41, %cond.true39
  %cond44 = phi i32 [ %mul40, %cond.true39 ], [ %mul42, %cond.false41 ]
  br label %cond.end45

cond.end45:                                       ; preds = %cond.end43, %cond.true35
  %cond46 = phi i32 [ %mul36, %cond.true35 ], [ %cond44, %cond.end43 ]
  store i32 %cond46, ptr %vtx_count, align 4
  %31 = load i32, ptr %idx_count, align 4
  %32 = load i32, ptr %vtx_count, align 4
  call void @_ZN10ImDrawList11PrimReserveEii(ptr noundef nonnull align 8 dereferenceable(196) %this1, i32 noundef %31, i32 noundef %32)
  %_Data47 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  %33 = load ptr, ptr %_Data47, align 8
  %TempBuffer = getelementptr inbounds %struct.ImDrawListSharedData, ptr %33, i32 0, i32 7
  %34 = load i32, ptr %points_count.addr, align 4
  %35 = load i8, ptr %use_texture, align 1
  %tobool48 = trunc i8 %35 to i1
  br i1 %tobool48, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %cond.end45
  %36 = load i8, ptr %thick_line, align 1
  %tobool49 = trunc i8 %36 to i1
  %lnot = xor i1 %tobool49, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %cond.end45
  %37 = phi i1 [ true, %cond.end45 ], [ %lnot, %lor.rhs ]
  %cond50 = select i1 %37, i32 3, i32 5
  %mul51 = mul nsw i32 %34, %cond50
  call void @_ZN8ImVectorI6ImVec2E15reserve_discardEi(ptr noundef nonnull align 8 dereferenceable(16) %TempBuffer, i32 noundef %mul51)
  %_Data52 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  %38 = load ptr, ptr %_Data52, align 8
  %TempBuffer53 = getelementptr inbounds %struct.ImDrawListSharedData, ptr %38, i32 0, i32 7
  %Data = getelementptr inbounds %struct.ImVector, ptr %TempBuffer53, i32 0, i32 2
  %39 = load ptr, ptr %Data, align 8
  store ptr %39, ptr %temp_normals, align 8
  %40 = load ptr, ptr %temp_normals, align 8
  %41 = load i32, ptr %points_count.addr, align 4
  %idx.ext = sext i32 %41 to i64
  %add.ptr = getelementptr inbounds %struct.ImVec2, ptr %40, i64 %idx.ext
  store ptr %add.ptr, ptr %temp_points, align 8
  store i32 0, ptr %i1, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %lor.end
  %42 = load i32, ptr %i1, align 4
  %43 = load i32, ptr %count, align 4
  %cmp54 = icmp slt i32 %42, %43
  br i1 %cmp54, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %44 = load i32, ptr %i1, align 4
  %add = add nsw i32 %44, 1
  %45 = load i32, ptr %points_count.addr, align 4
  %cmp55 = icmp eq i32 %add, %45
  br i1 %cmp55, label %cond.true56, label %cond.false57

cond.true56:                                      ; preds = %for.body
  br label %cond.end59

cond.false57:                                     ; preds = %for.body
  %46 = load i32, ptr %i1, align 4
  %add58 = add nsw i32 %46, 1
  br label %cond.end59

cond.end59:                                       ; preds = %cond.false57, %cond.true56
  %cond60 = phi i32 [ 0, %cond.true56 ], [ %add58, %cond.false57 ]
  store i32 %cond60, ptr %i2, align 4
  %47 = load ptr, ptr %points.addr, align 8
  %48 = load i32, ptr %i2, align 4
  %idxprom = sext i32 %48 to i64
  %arrayidx = getelementptr inbounds %struct.ImVec2, ptr %47, i64 %idxprom
  %x = getelementptr inbounds %struct.ImVec2, ptr %arrayidx, i32 0, i32 0
  %49 = load float, ptr %x, align 4
  %50 = load ptr, ptr %points.addr, align 8
  %51 = load i32, ptr %i1, align 4
  %idxprom61 = sext i32 %51 to i64
  %arrayidx62 = getelementptr inbounds %struct.ImVec2, ptr %50, i64 %idxprom61
  %x63 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx62, i32 0, i32 0
  %52 = load float, ptr %x63, align 4
  %sub64 = fsub float %49, %52
  store float %sub64, ptr %dx, align 4
  %53 = load ptr, ptr %points.addr, align 8
  %54 = load i32, ptr %i2, align 4
  %idxprom65 = sext i32 %54 to i64
  %arrayidx66 = getelementptr inbounds %struct.ImVec2, ptr %53, i64 %idxprom65
  %y = getelementptr inbounds %struct.ImVec2, ptr %arrayidx66, i32 0, i32 1
  %55 = load float, ptr %y, align 4
  %56 = load ptr, ptr %points.addr, align 8
  %57 = load i32, ptr %i1, align 4
  %idxprom67 = sext i32 %57 to i64
  %arrayidx68 = getelementptr inbounds %struct.ImVec2, ptr %56, i64 %idxprom67
  %y69 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx68, i32 0, i32 1
  %58 = load float, ptr %y69, align 4
  %sub70 = fsub float %55, %58
  store float %sub70, ptr %dy, align 4
  %59 = load float, ptr %dx, align 4
  %60 = load float, ptr %dx, align 4
  %61 = load float, ptr %dy, align 4
  %62 = load float, ptr %dy, align 4
  %mul72 = fmul float %61, %62
  %63 = call float @llvm.fmuladd.f32(float %59, float %60, float %mul72)
  store float %63, ptr %d2, align 4
  %64 = load float, ptr %d2, align 4
  %cmp73 = fcmp ogt float %64, 0.000000e+00
  br i1 %cmp73, label %if.then74, label %if.end78

if.then74:                                        ; preds = %cond.end59
  %65 = load float, ptr %d2, align 4
  %call75 = call noundef float @_ZL7ImRsqrtf(float noundef %65)
  store float %call75, ptr %inv_len, align 4
  %66 = load float, ptr %inv_len, align 4
  %67 = load float, ptr %dx, align 4
  %mul76 = fmul float %67, %66
  store float %mul76, ptr %dx, align 4
  %68 = load float, ptr %inv_len, align 4
  %69 = load float, ptr %dy, align 4
  %mul77 = fmul float %69, %68
  store float %mul77, ptr %dy, align 4
  br label %if.end78

if.end78:                                         ; preds = %if.then74, %cond.end59
  %70 = load float, ptr %dy, align 4
  %71 = load ptr, ptr %temp_normals, align 8
  %72 = load i32, ptr %i1, align 4
  %idxprom79 = sext i32 %72 to i64
  %arrayidx80 = getelementptr inbounds %struct.ImVec2, ptr %71, i64 %idxprom79
  %x81 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx80, i32 0, i32 0
  store float %70, ptr %x81, align 4
  %73 = load float, ptr %dx, align 4
  %fneg = fneg float %73
  %74 = load ptr, ptr %temp_normals, align 8
  %75 = load i32, ptr %i1, align 4
  %idxprom82 = sext i32 %75 to i64
  %arrayidx83 = getelementptr inbounds %struct.ImVec2, ptr %74, i64 %idxprom82
  %y84 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx83, i32 0, i32 1
  store float %fneg, ptr %y84, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end78
  %76 = load i32, ptr %i1, align 4
  %inc = add nsw i32 %76, 1
  store i32 %inc, ptr %i1, align 4
  br label %for.cond, !llvm.loop !12

for.end:                                          ; preds = %for.cond
  %77 = load i8, ptr %closed, align 1
  %tobool85 = trunc i8 %77 to i1
  br i1 %tobool85, label %if.end93, label %if.then86

if.then86:                                        ; preds = %for.end
  %78 = load ptr, ptr %temp_normals, align 8
  %79 = load i32, ptr %points_count.addr, align 4
  %sub87 = sub nsw i32 %79, 2
  %idxprom88 = sext i32 %sub87 to i64
  %arrayidx89 = getelementptr inbounds %struct.ImVec2, ptr %78, i64 %idxprom88
  %80 = load ptr, ptr %temp_normals, align 8
  %81 = load i32, ptr %points_count.addr, align 4
  %sub90 = sub nsw i32 %81, 1
  %idxprom91 = sext i32 %sub90 to i64
  %arrayidx92 = getelementptr inbounds %struct.ImVec2, ptr %80, i64 %idxprom91
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx92, ptr align 4 %arrayidx89, i64 8, i1 false)
  br label %if.end93

if.end93:                                         ; preds = %if.then86, %for.end
  %82 = load i8, ptr %use_texture, align 1
  %tobool94 = trunc i8 %82 to i1
  br i1 %tobool94, label %if.then97, label %lor.lhs.false95

lor.lhs.false95:                                  ; preds = %if.end93
  %83 = load i8, ptr %thick_line, align 1
  %tobool96 = trunc i8 %83 to i1
  br i1 %tobool96, label %if.else395, label %if.then97

if.then97:                                        ; preds = %lor.lhs.false95, %if.end93
  %84 = load i8, ptr %use_texture, align 1
  %tobool98 = trunc i8 %84 to i1
  br i1 %tobool98, label %cond.true99, label %cond.false101

cond.true99:                                      ; preds = %if.then97
  %85 = load float, ptr %thickness.addr, align 4
  %86 = call float @llvm.fmuladd.f32(float %85, float 5.000000e-01, float 1.000000e+00)
  br label %cond.end102

cond.false101:                                    ; preds = %if.then97
  %87 = load float, ptr %AA_SIZE, align 4
  br label %cond.end102

cond.end102:                                      ; preds = %cond.false101, %cond.true99
  %cond103 = phi float [ %86, %cond.true99 ], [ %87, %cond.false101 ]
  store float %cond103, ptr %half_draw_size, align 4
  %88 = load i8, ptr %closed, align 1
  %tobool104 = trunc i8 %88 to i1
  br i1 %tobool104, label %if.end149, label %if.then105

if.then105:                                       ; preds = %cond.end102
  %89 = load ptr, ptr %points.addr, align 8
  %arrayidx106 = getelementptr inbounds %struct.ImVec2, ptr %89, i64 0
  %90 = load ptr, ptr %temp_normals, align 8
  %arrayidx108 = getelementptr inbounds %struct.ImVec2, ptr %90, i64 0
  %91 = load float, ptr %half_draw_size, align 4
  %call109 = call <2 x float> @_ZmlRK6ImVec2f(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx108, float noundef %91)
  store <2 x float> %call109, ptr %ref.tmp107, align 4
  %call110 = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx106, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp107)
  store <2 x float> %call110, ptr %ref.tmp, align 4
  %92 = load ptr, ptr %temp_points, align 8
  %arrayidx111 = getelementptr inbounds %struct.ImVec2, ptr %92, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx111, ptr align 4 %ref.tmp, i64 8, i1 false)
  %93 = load ptr, ptr %points.addr, align 8
  %arrayidx113 = getelementptr inbounds %struct.ImVec2, ptr %93, i64 0
  %94 = load ptr, ptr %temp_normals, align 8
  %arrayidx115 = getelementptr inbounds %struct.ImVec2, ptr %94, i64 0
  %95 = load float, ptr %half_draw_size, align 4
  %call116 = call <2 x float> @_ZmlRK6ImVec2f(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx115, float noundef %95)
  store <2 x float> %call116, ptr %ref.tmp114, align 4
  %call117 = call <2 x float> @_ZmiRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx113, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp114)
  store <2 x float> %call117, ptr %ref.tmp112, align 4
  %96 = load ptr, ptr %temp_points, align 8
  %arrayidx118 = getelementptr inbounds %struct.ImVec2, ptr %96, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx118, ptr align 4 %ref.tmp112, i64 8, i1 false)
  %97 = load ptr, ptr %points.addr, align 8
  %98 = load i32, ptr %points_count.addr, align 4
  %sub120 = sub nsw i32 %98, 1
  %idxprom121 = sext i32 %sub120 to i64
  %arrayidx122 = getelementptr inbounds %struct.ImVec2, ptr %97, i64 %idxprom121
  %99 = load ptr, ptr %temp_normals, align 8
  %100 = load i32, ptr %points_count.addr, align 4
  %sub124 = sub nsw i32 %100, 1
  %idxprom125 = sext i32 %sub124 to i64
  %arrayidx126 = getelementptr inbounds %struct.ImVec2, ptr %99, i64 %idxprom125
  %101 = load float, ptr %half_draw_size, align 4
  %call127 = call <2 x float> @_ZmlRK6ImVec2f(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx126, float noundef %101)
  store <2 x float> %call127, ptr %ref.tmp123, align 4
  %call128 = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx122, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp123)
  store <2 x float> %call128, ptr %ref.tmp119, align 4
  %102 = load ptr, ptr %temp_points, align 8
  %103 = load i32, ptr %points_count.addr, align 4
  %sub129 = sub nsw i32 %103, 1
  %mul130 = mul nsw i32 %sub129, 2
  %add131 = add nsw i32 %mul130, 0
  %idxprom132 = sext i32 %add131 to i64
  %arrayidx133 = getelementptr inbounds %struct.ImVec2, ptr %102, i64 %idxprom132
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx133, ptr align 4 %ref.tmp119, i64 8, i1 false)
  %104 = load ptr, ptr %points.addr, align 8
  %105 = load i32, ptr %points_count.addr, align 4
  %sub135 = sub nsw i32 %105, 1
  %idxprom136 = sext i32 %sub135 to i64
  %arrayidx137 = getelementptr inbounds %struct.ImVec2, ptr %104, i64 %idxprom136
  %106 = load ptr, ptr %temp_normals, align 8
  %107 = load i32, ptr %points_count.addr, align 4
  %sub139 = sub nsw i32 %107, 1
  %idxprom140 = sext i32 %sub139 to i64
  %arrayidx141 = getelementptr inbounds %struct.ImVec2, ptr %106, i64 %idxprom140
  %108 = load float, ptr %half_draw_size, align 4
  %call142 = call <2 x float> @_ZmlRK6ImVec2f(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx141, float noundef %108)
  store <2 x float> %call142, ptr %ref.tmp138, align 4
  %call143 = call <2 x float> @_ZmiRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx137, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp138)
  store <2 x float> %call143, ptr %ref.tmp134, align 4
  %109 = load ptr, ptr %temp_points, align 8
  %110 = load i32, ptr %points_count.addr, align 4
  %sub144 = sub nsw i32 %110, 1
  %mul145 = mul nsw i32 %sub144, 2
  %add146 = add nsw i32 %mul145, 1
  %idxprom147 = sext i32 %add146 to i64
  %arrayidx148 = getelementptr inbounds %struct.ImVec2, ptr %109, i64 %idxprom147
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx148, ptr align 4 %ref.tmp134, i64 8, i1 false)
  br label %if.end149

if.end149:                                        ; preds = %if.then105, %cond.end102
  %_VtxCurrentIdx = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %111 = load i32, ptr %_VtxCurrentIdx, align 4
  store i32 %111, ptr %idx1, align 4
  store i32 0, ptr %i1150, align 4
  br label %for.cond151

for.cond151:                                      ; preds = %for.inc306, %if.end149
  %112 = load i32, ptr %i1150, align 4
  %113 = load i32, ptr %count, align 4
  %cmp152 = icmp slt i32 %112, %113
  br i1 %cmp152, label %for.body153, label %for.end308

for.body153:                                      ; preds = %for.cond151
  %114 = load i32, ptr %i1150, align 4
  %add155 = add nsw i32 %114, 1
  %115 = load i32, ptr %points_count.addr, align 4
  %cmp156 = icmp eq i32 %add155, %115
  br i1 %cmp156, label %cond.true157, label %cond.false158

cond.true157:                                     ; preds = %for.body153
  br label %cond.end160

cond.false158:                                    ; preds = %for.body153
  %116 = load i32, ptr %i1150, align 4
  %add159 = add nsw i32 %116, 1
  br label %cond.end160

cond.end160:                                      ; preds = %cond.false158, %cond.true157
  %cond161 = phi i32 [ 0, %cond.true157 ], [ %add159, %cond.false158 ]
  store i32 %cond161, ptr %i2154, align 4
  %117 = load i32, ptr %i1150, align 4
  %add162 = add nsw i32 %117, 1
  %118 = load i32, ptr %points_count.addr, align 4
  %cmp163 = icmp eq i32 %add162, %118
  br i1 %cmp163, label %cond.true164, label %cond.false166

cond.true164:                                     ; preds = %cond.end160
  %_VtxCurrentIdx165 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %119 = load i32, ptr %_VtxCurrentIdx165, align 4
  br label %cond.end170

cond.false166:                                    ; preds = %cond.end160
  %120 = load i32, ptr %idx1, align 4
  %121 = load i8, ptr %use_texture, align 1
  %tobool167 = trunc i8 %121 to i1
  %cond168 = select i1 %tobool167, i32 2, i32 3
  %add169 = add i32 %120, %cond168
  br label %cond.end170

cond.end170:                                      ; preds = %cond.false166, %cond.true164
  %cond171 = phi i32 [ %119, %cond.true164 ], [ %add169, %cond.false166 ]
  store i32 %cond171, ptr %idx2, align 4
  %122 = load ptr, ptr %temp_normals, align 8
  %123 = load i32, ptr %i1150, align 4
  %idxprom172 = sext i32 %123 to i64
  %arrayidx173 = getelementptr inbounds %struct.ImVec2, ptr %122, i64 %idxprom172
  %x174 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx173, i32 0, i32 0
  %124 = load float, ptr %x174, align 4
  %125 = load ptr, ptr %temp_normals, align 8
  %126 = load i32, ptr %i2154, align 4
  %idxprom175 = sext i32 %126 to i64
  %arrayidx176 = getelementptr inbounds %struct.ImVec2, ptr %125, i64 %idxprom175
  %x177 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx176, i32 0, i32 0
  %127 = load float, ptr %x177, align 4
  %add178 = fadd float %124, %127
  %mul179 = fmul float %add178, 5.000000e-01
  store float %mul179, ptr %dm_x, align 4
  %128 = load ptr, ptr %temp_normals, align 8
  %129 = load i32, ptr %i1150, align 4
  %idxprom180 = sext i32 %129 to i64
  %arrayidx181 = getelementptr inbounds %struct.ImVec2, ptr %128, i64 %idxprom180
  %y182 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx181, i32 0, i32 1
  %130 = load float, ptr %y182, align 4
  %131 = load ptr, ptr %temp_normals, align 8
  %132 = load i32, ptr %i2154, align 4
  %idxprom183 = sext i32 %132 to i64
  %arrayidx184 = getelementptr inbounds %struct.ImVec2, ptr %131, i64 %idxprom183
  %y185 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx184, i32 0, i32 1
  %133 = load float, ptr %y185, align 4
  %add186 = fadd float %130, %133
  %mul187 = fmul float %add186, 5.000000e-01
  store float %mul187, ptr %dm_y, align 4
  %134 = load float, ptr %dm_x, align 4
  %135 = load float, ptr %dm_x, align 4
  %136 = load float, ptr %dm_y, align 4
  %137 = load float, ptr %dm_y, align 4
  %mul190 = fmul float %136, %137
  %138 = call float @llvm.fmuladd.f32(float %134, float %135, float %mul190)
  store float %138, ptr %d2188, align 4
  %139 = load float, ptr %d2188, align 4
  %cmp191 = fcmp ogt float %139, 0x3EB0C6F7A0000000
  br i1 %cmp191, label %if.then192, label %if.end198

if.then192:                                       ; preds = %cond.end170
  %140 = load float, ptr %d2188, align 4
  %div = fdiv float 1.000000e+00, %140
  store float %div, ptr %inv_len2, align 4
  %141 = load float, ptr %inv_len2, align 4
  %cmp193 = fcmp ogt float %141, 1.000000e+02
  br i1 %cmp193, label %if.then194, label %if.end195

if.then194:                                       ; preds = %if.then192
  store float 1.000000e+02, ptr %inv_len2, align 4
  br label %if.end195

if.end195:                                        ; preds = %if.then194, %if.then192
  %142 = load float, ptr %inv_len2, align 4
  %143 = load float, ptr %dm_x, align 4
  %mul196 = fmul float %143, %142
  store float %mul196, ptr %dm_x, align 4
  %144 = load float, ptr %inv_len2, align 4
  %145 = load float, ptr %dm_y, align 4
  %mul197 = fmul float %145, %144
  store float %mul197, ptr %dm_y, align 4
  br label %if.end198

if.end198:                                        ; preds = %if.end195, %cond.end170
  %146 = load float, ptr %half_draw_size, align 4
  %147 = load float, ptr %dm_x, align 4
  %mul199 = fmul float %147, %146
  store float %mul199, ptr %dm_x, align 4
  %148 = load float, ptr %half_draw_size, align 4
  %149 = load float, ptr %dm_y, align 4
  %mul200 = fmul float %149, %148
  store float %mul200, ptr %dm_y, align 4
  %150 = load ptr, ptr %temp_points, align 8
  %151 = load i32, ptr %i2154, align 4
  %mul201 = mul nsw i32 %151, 2
  %idxprom202 = sext i32 %mul201 to i64
  %arrayidx203 = getelementptr inbounds %struct.ImVec2, ptr %150, i64 %idxprom202
  store ptr %arrayidx203, ptr %out_vtx, align 8
  %152 = load ptr, ptr %points.addr, align 8
  %153 = load i32, ptr %i2154, align 4
  %idxprom204 = sext i32 %153 to i64
  %arrayidx205 = getelementptr inbounds %struct.ImVec2, ptr %152, i64 %idxprom204
  %x206 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx205, i32 0, i32 0
  %154 = load float, ptr %x206, align 4
  %155 = load float, ptr %dm_x, align 4
  %add207 = fadd float %154, %155
  %156 = load ptr, ptr %out_vtx, align 8
  %arrayidx208 = getelementptr inbounds %struct.ImVec2, ptr %156, i64 0
  %x209 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx208, i32 0, i32 0
  store float %add207, ptr %x209, align 4
  %157 = load ptr, ptr %points.addr, align 8
  %158 = load i32, ptr %i2154, align 4
  %idxprom210 = sext i32 %158 to i64
  %arrayidx211 = getelementptr inbounds %struct.ImVec2, ptr %157, i64 %idxprom210
  %y212 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx211, i32 0, i32 1
  %159 = load float, ptr %y212, align 4
  %160 = load float, ptr %dm_y, align 4
  %add213 = fadd float %159, %160
  %161 = load ptr, ptr %out_vtx, align 8
  %arrayidx214 = getelementptr inbounds %struct.ImVec2, ptr %161, i64 0
  %y215 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx214, i32 0, i32 1
  store float %add213, ptr %y215, align 4
  %162 = load ptr, ptr %points.addr, align 8
  %163 = load i32, ptr %i2154, align 4
  %idxprom216 = sext i32 %163 to i64
  %arrayidx217 = getelementptr inbounds %struct.ImVec2, ptr %162, i64 %idxprom216
  %x218 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx217, i32 0, i32 0
  %164 = load float, ptr %x218, align 4
  %165 = load float, ptr %dm_x, align 4
  %sub219 = fsub float %164, %165
  %166 = load ptr, ptr %out_vtx, align 8
  %arrayidx220 = getelementptr inbounds %struct.ImVec2, ptr %166, i64 1
  %x221 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx220, i32 0, i32 0
  store float %sub219, ptr %x221, align 4
  %167 = load ptr, ptr %points.addr, align 8
  %168 = load i32, ptr %i2154, align 4
  %idxprom222 = sext i32 %168 to i64
  %arrayidx223 = getelementptr inbounds %struct.ImVec2, ptr %167, i64 %idxprom222
  %y224 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx223, i32 0, i32 1
  %169 = load float, ptr %y224, align 4
  %170 = load float, ptr %dm_y, align 4
  %sub225 = fsub float %169, %170
  %171 = load ptr, ptr %out_vtx, align 8
  %arrayidx226 = getelementptr inbounds %struct.ImVec2, ptr %171, i64 1
  %y227 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx226, i32 0, i32 1
  store float %sub225, ptr %y227, align 4
  %172 = load i8, ptr %use_texture, align 1
  %tobool228 = trunc i8 %172 to i1
  br i1 %tobool228, label %if.then229, label %if.else

if.then229:                                       ; preds = %if.end198
  %173 = load i32, ptr %idx2, align 4
  %add230 = add i32 %173, 0
  %conv231 = trunc i32 %add230 to i16
  %_IdxWritePtr = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %174 = load ptr, ptr %_IdxWritePtr, align 8
  %arrayidx232 = getelementptr inbounds i16, ptr %174, i64 0
  store i16 %conv231, ptr %arrayidx232, align 2
  %175 = load i32, ptr %idx1, align 4
  %add233 = add i32 %175, 0
  %conv234 = trunc i32 %add233 to i16
  %_IdxWritePtr235 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %176 = load ptr, ptr %_IdxWritePtr235, align 8
  %arrayidx236 = getelementptr inbounds i16, ptr %176, i64 1
  store i16 %conv234, ptr %arrayidx236, align 2
  %177 = load i32, ptr %idx1, align 4
  %add237 = add i32 %177, 1
  %conv238 = trunc i32 %add237 to i16
  %_IdxWritePtr239 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %178 = load ptr, ptr %_IdxWritePtr239, align 8
  %arrayidx240 = getelementptr inbounds i16, ptr %178, i64 2
  store i16 %conv238, ptr %arrayidx240, align 2
  %179 = load i32, ptr %idx2, align 4
  %add241 = add i32 %179, 1
  %conv242 = trunc i32 %add241 to i16
  %_IdxWritePtr243 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %180 = load ptr, ptr %_IdxWritePtr243, align 8
  %arrayidx244 = getelementptr inbounds i16, ptr %180, i64 3
  store i16 %conv242, ptr %arrayidx244, align 2
  %181 = load i32, ptr %idx1, align 4
  %add245 = add i32 %181, 1
  %conv246 = trunc i32 %add245 to i16
  %_IdxWritePtr247 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %182 = load ptr, ptr %_IdxWritePtr247, align 8
  %arrayidx248 = getelementptr inbounds i16, ptr %182, i64 4
  store i16 %conv246, ptr %arrayidx248, align 2
  %183 = load i32, ptr %idx2, align 4
  %add249 = add i32 %183, 0
  %conv250 = trunc i32 %add249 to i16
  %_IdxWritePtr251 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %184 = load ptr, ptr %_IdxWritePtr251, align 8
  %arrayidx252 = getelementptr inbounds i16, ptr %184, i64 5
  store i16 %conv250, ptr %arrayidx252, align 2
  %_IdxWritePtr253 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %185 = load ptr, ptr %_IdxWritePtr253, align 8
  %add.ptr254 = getelementptr inbounds i16, ptr %185, i64 6
  store ptr %add.ptr254, ptr %_IdxWritePtr253, align 8
  br label %if.end305

if.else:                                          ; preds = %if.end198
  %186 = load i32, ptr %idx2, align 4
  %add255 = add i32 %186, 0
  %conv256 = trunc i32 %add255 to i16
  %_IdxWritePtr257 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %187 = load ptr, ptr %_IdxWritePtr257, align 8
  %arrayidx258 = getelementptr inbounds i16, ptr %187, i64 0
  store i16 %conv256, ptr %arrayidx258, align 2
  %188 = load i32, ptr %idx1, align 4
  %add259 = add i32 %188, 0
  %conv260 = trunc i32 %add259 to i16
  %_IdxWritePtr261 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %189 = load ptr, ptr %_IdxWritePtr261, align 8
  %arrayidx262 = getelementptr inbounds i16, ptr %189, i64 1
  store i16 %conv260, ptr %arrayidx262, align 2
  %190 = load i32, ptr %idx1, align 4
  %add263 = add i32 %190, 2
  %conv264 = trunc i32 %add263 to i16
  %_IdxWritePtr265 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %191 = load ptr, ptr %_IdxWritePtr265, align 8
  %arrayidx266 = getelementptr inbounds i16, ptr %191, i64 2
  store i16 %conv264, ptr %arrayidx266, align 2
  %192 = load i32, ptr %idx1, align 4
  %add267 = add i32 %192, 2
  %conv268 = trunc i32 %add267 to i16
  %_IdxWritePtr269 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %193 = load ptr, ptr %_IdxWritePtr269, align 8
  %arrayidx270 = getelementptr inbounds i16, ptr %193, i64 3
  store i16 %conv268, ptr %arrayidx270, align 2
  %194 = load i32, ptr %idx2, align 4
  %add271 = add i32 %194, 2
  %conv272 = trunc i32 %add271 to i16
  %_IdxWritePtr273 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %195 = load ptr, ptr %_IdxWritePtr273, align 8
  %arrayidx274 = getelementptr inbounds i16, ptr %195, i64 4
  store i16 %conv272, ptr %arrayidx274, align 2
  %196 = load i32, ptr %idx2, align 4
  %add275 = add i32 %196, 0
  %conv276 = trunc i32 %add275 to i16
  %_IdxWritePtr277 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %197 = load ptr, ptr %_IdxWritePtr277, align 8
  %arrayidx278 = getelementptr inbounds i16, ptr %197, i64 5
  store i16 %conv276, ptr %arrayidx278, align 2
  %198 = load i32, ptr %idx2, align 4
  %add279 = add i32 %198, 1
  %conv280 = trunc i32 %add279 to i16
  %_IdxWritePtr281 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %199 = load ptr, ptr %_IdxWritePtr281, align 8
  %arrayidx282 = getelementptr inbounds i16, ptr %199, i64 6
  store i16 %conv280, ptr %arrayidx282, align 2
  %200 = load i32, ptr %idx1, align 4
  %add283 = add i32 %200, 1
  %conv284 = trunc i32 %add283 to i16
  %_IdxWritePtr285 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %201 = load ptr, ptr %_IdxWritePtr285, align 8
  %arrayidx286 = getelementptr inbounds i16, ptr %201, i64 7
  store i16 %conv284, ptr %arrayidx286, align 2
  %202 = load i32, ptr %idx1, align 4
  %add287 = add i32 %202, 0
  %conv288 = trunc i32 %add287 to i16
  %_IdxWritePtr289 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %203 = load ptr, ptr %_IdxWritePtr289, align 8
  %arrayidx290 = getelementptr inbounds i16, ptr %203, i64 8
  store i16 %conv288, ptr %arrayidx290, align 2
  %204 = load i32, ptr %idx1, align 4
  %add291 = add i32 %204, 0
  %conv292 = trunc i32 %add291 to i16
  %_IdxWritePtr293 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %205 = load ptr, ptr %_IdxWritePtr293, align 8
  %arrayidx294 = getelementptr inbounds i16, ptr %205, i64 9
  store i16 %conv292, ptr %arrayidx294, align 2
  %206 = load i32, ptr %idx2, align 4
  %add295 = add i32 %206, 0
  %conv296 = trunc i32 %add295 to i16
  %_IdxWritePtr297 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %207 = load ptr, ptr %_IdxWritePtr297, align 8
  %arrayidx298 = getelementptr inbounds i16, ptr %207, i64 10
  store i16 %conv296, ptr %arrayidx298, align 2
  %208 = load i32, ptr %idx2, align 4
  %add299 = add i32 %208, 1
  %conv300 = trunc i32 %add299 to i16
  %_IdxWritePtr301 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %209 = load ptr, ptr %_IdxWritePtr301, align 8
  %arrayidx302 = getelementptr inbounds i16, ptr %209, i64 11
  store i16 %conv300, ptr %arrayidx302, align 2
  %_IdxWritePtr303 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %210 = load ptr, ptr %_IdxWritePtr303, align 8
  %add.ptr304 = getelementptr inbounds i16, ptr %210, i64 12
  store ptr %add.ptr304, ptr %_IdxWritePtr303, align 8
  br label %if.end305

if.end305:                                        ; preds = %if.else, %if.then229
  %211 = load i32, ptr %idx2, align 4
  store i32 %211, ptr %idx1, align 4
  br label %for.inc306

for.inc306:                                       ; preds = %if.end305
  %212 = load i32, ptr %i1150, align 4
  %inc307 = add nsw i32 %212, 1
  store i32 %inc307, ptr %i1150, align 4
  br label %for.cond151, !llvm.loop !13

for.end308:                                       ; preds = %for.cond151
  %213 = load i8, ptr %use_texture, align 1
  %tobool309 = trunc i8 %213 to i1
  br i1 %tobool309, label %if.then310, label %if.else347

if.then310:                                       ; preds = %for.end308
  %_Data311 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  %214 = load ptr, ptr %_Data311, align 8
  %TexUvLines = getelementptr inbounds %struct.ImDrawListSharedData, ptr %214, i32 0, i32 11
  %215 = load ptr, ptr %TexUvLines, align 8
  %216 = load i32, ptr %integer_thickness, align 4
  %idxprom312 = sext i32 %216 to i64
  %arrayidx313 = getelementptr inbounds %struct.ImVec4, ptr %215, i64 %idxprom312
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %tex_uvs, ptr align 4 %arrayidx313, i64 16, i1 false)
  %x314 = getelementptr inbounds %struct.ImVec4, ptr %tex_uvs, i32 0, i32 0
  %217 = load float, ptr %x314, align 4
  %y315 = getelementptr inbounds %struct.ImVec4, ptr %tex_uvs, i32 0, i32 1
  %218 = load float, ptr %y315, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %tex_uv0, float noundef %217, float noundef %218)
  %z = getelementptr inbounds %struct.ImVec4, ptr %tex_uvs, i32 0, i32 2
  %219 = load float, ptr %z, align 4
  %w = getelementptr inbounds %struct.ImVec4, ptr %tex_uvs, i32 0, i32 3
  %220 = load float, ptr %w, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %tex_uv1, float noundef %219, float noundef %220)
  store i32 0, ptr %i, align 4
  br label %for.cond316

for.cond316:                                      ; preds = %for.inc344, %if.then310
  %221 = load i32, ptr %i, align 4
  %222 = load i32, ptr %points_count.addr, align 4
  %cmp317 = icmp slt i32 %221, %222
  br i1 %cmp317, label %for.body318, label %for.end346

for.body318:                                      ; preds = %for.cond316
  %223 = load ptr, ptr %temp_points, align 8
  %224 = load i32, ptr %i, align 4
  %mul319 = mul nsw i32 %224, 2
  %add320 = add nsw i32 %mul319, 0
  %idxprom321 = sext i32 %add320 to i64
  %arrayidx322 = getelementptr inbounds %struct.ImVec2, ptr %223, i64 %idxprom321
  %_VtxWritePtr = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %225 = load ptr, ptr %_VtxWritePtr, align 8
  %arrayidx323 = getelementptr inbounds %struct.ImDrawVert, ptr %225, i64 0
  %pos = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx323, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %pos, ptr align 4 %arrayidx322, i64 8, i1 false)
  %_VtxWritePtr324 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %226 = load ptr, ptr %_VtxWritePtr324, align 8
  %arrayidx325 = getelementptr inbounds %struct.ImDrawVert, ptr %226, i64 0
  %uv = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx325, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv, ptr align 4 %tex_uv0, i64 8, i1 false)
  %227 = load i32, ptr %col.addr, align 4
  %_VtxWritePtr326 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %228 = load ptr, ptr %_VtxWritePtr326, align 8
  %arrayidx327 = getelementptr inbounds %struct.ImDrawVert, ptr %228, i64 0
  %col328 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx327, i32 0, i32 2
  store i32 %227, ptr %col328, align 4
  %229 = load ptr, ptr %temp_points, align 8
  %230 = load i32, ptr %i, align 4
  %mul329 = mul nsw i32 %230, 2
  %add330 = add nsw i32 %mul329, 1
  %idxprom331 = sext i32 %add330 to i64
  %arrayidx332 = getelementptr inbounds %struct.ImVec2, ptr %229, i64 %idxprom331
  %_VtxWritePtr333 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %231 = load ptr, ptr %_VtxWritePtr333, align 8
  %arrayidx334 = getelementptr inbounds %struct.ImDrawVert, ptr %231, i64 1
  %pos335 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx334, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %pos335, ptr align 4 %arrayidx332, i64 8, i1 false)
  %_VtxWritePtr336 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %232 = load ptr, ptr %_VtxWritePtr336, align 8
  %arrayidx337 = getelementptr inbounds %struct.ImDrawVert, ptr %232, i64 1
  %uv338 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx337, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv338, ptr align 4 %tex_uv1, i64 8, i1 false)
  %233 = load i32, ptr %col.addr, align 4
  %_VtxWritePtr339 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %234 = load ptr, ptr %_VtxWritePtr339, align 8
  %arrayidx340 = getelementptr inbounds %struct.ImDrawVert, ptr %234, i64 1
  %col341 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx340, i32 0, i32 2
  store i32 %233, ptr %col341, align 4
  %_VtxWritePtr342 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %235 = load ptr, ptr %_VtxWritePtr342, align 8
  %add.ptr343 = getelementptr inbounds %struct.ImDrawVert, ptr %235, i64 2
  store ptr %add.ptr343, ptr %_VtxWritePtr342, align 8
  br label %for.inc344

for.inc344:                                       ; preds = %for.body318
  %236 = load i32, ptr %i, align 4
  %inc345 = add nsw i32 %236, 1
  store i32 %inc345, ptr %i, align 4
  br label %for.cond316, !llvm.loop !14

for.end346:                                       ; preds = %for.cond316
  br label %if.end394

if.else347:                                       ; preds = %for.end308
  store i32 0, ptr %i348, align 4
  br label %for.cond349

for.cond349:                                      ; preds = %for.inc391, %if.else347
  %237 = load i32, ptr %i348, align 4
  %238 = load i32, ptr %points_count.addr, align 4
  %cmp350 = icmp slt i32 %237, %238
  br i1 %cmp350, label %for.body351, label %for.end393

for.body351:                                      ; preds = %for.cond349
  %239 = load ptr, ptr %points.addr, align 8
  %240 = load i32, ptr %i348, align 4
  %idxprom352 = sext i32 %240 to i64
  %arrayidx353 = getelementptr inbounds %struct.ImVec2, ptr %239, i64 %idxprom352
  %_VtxWritePtr354 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %241 = load ptr, ptr %_VtxWritePtr354, align 8
  %arrayidx355 = getelementptr inbounds %struct.ImDrawVert, ptr %241, i64 0
  %pos356 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx355, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %pos356, ptr align 4 %arrayidx353, i64 8, i1 false)
  %_VtxWritePtr357 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %242 = load ptr, ptr %_VtxWritePtr357, align 8
  %arrayidx358 = getelementptr inbounds %struct.ImDrawVert, ptr %242, i64 0
  %uv359 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx358, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv359, ptr align 4 %opaque_uv, i64 8, i1 false)
  %243 = load i32, ptr %col.addr, align 4
  %_VtxWritePtr360 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %244 = load ptr, ptr %_VtxWritePtr360, align 8
  %arrayidx361 = getelementptr inbounds %struct.ImDrawVert, ptr %244, i64 0
  %col362 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx361, i32 0, i32 2
  store i32 %243, ptr %col362, align 4
  %245 = load ptr, ptr %temp_points, align 8
  %246 = load i32, ptr %i348, align 4
  %mul363 = mul nsw i32 %246, 2
  %add364 = add nsw i32 %mul363, 0
  %idxprom365 = sext i32 %add364 to i64
  %arrayidx366 = getelementptr inbounds %struct.ImVec2, ptr %245, i64 %idxprom365
  %_VtxWritePtr367 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %247 = load ptr, ptr %_VtxWritePtr367, align 8
  %arrayidx368 = getelementptr inbounds %struct.ImDrawVert, ptr %247, i64 1
  %pos369 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx368, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %pos369, ptr align 4 %arrayidx366, i64 8, i1 false)
  %_VtxWritePtr370 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %248 = load ptr, ptr %_VtxWritePtr370, align 8
  %arrayidx371 = getelementptr inbounds %struct.ImDrawVert, ptr %248, i64 1
  %uv372 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx371, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv372, ptr align 4 %opaque_uv, i64 8, i1 false)
  %249 = load i32, ptr %col_trans, align 4
  %_VtxWritePtr373 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %250 = load ptr, ptr %_VtxWritePtr373, align 8
  %arrayidx374 = getelementptr inbounds %struct.ImDrawVert, ptr %250, i64 1
  %col375 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx374, i32 0, i32 2
  store i32 %249, ptr %col375, align 4
  %251 = load ptr, ptr %temp_points, align 8
  %252 = load i32, ptr %i348, align 4
  %mul376 = mul nsw i32 %252, 2
  %add377 = add nsw i32 %mul376, 1
  %idxprom378 = sext i32 %add377 to i64
  %arrayidx379 = getelementptr inbounds %struct.ImVec2, ptr %251, i64 %idxprom378
  %_VtxWritePtr380 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %253 = load ptr, ptr %_VtxWritePtr380, align 8
  %arrayidx381 = getelementptr inbounds %struct.ImDrawVert, ptr %253, i64 2
  %pos382 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx381, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %pos382, ptr align 4 %arrayidx379, i64 8, i1 false)
  %_VtxWritePtr383 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %254 = load ptr, ptr %_VtxWritePtr383, align 8
  %arrayidx384 = getelementptr inbounds %struct.ImDrawVert, ptr %254, i64 2
  %uv385 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx384, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv385, ptr align 4 %opaque_uv, i64 8, i1 false)
  %255 = load i32, ptr %col_trans, align 4
  %_VtxWritePtr386 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %256 = load ptr, ptr %_VtxWritePtr386, align 8
  %arrayidx387 = getelementptr inbounds %struct.ImDrawVert, ptr %256, i64 2
  %col388 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx387, i32 0, i32 2
  store i32 %255, ptr %col388, align 4
  %_VtxWritePtr389 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %257 = load ptr, ptr %_VtxWritePtr389, align 8
  %add.ptr390 = getelementptr inbounds %struct.ImDrawVert, ptr %257, i64 3
  store ptr %add.ptr390, ptr %_VtxWritePtr389, align 8
  br label %for.inc391

for.inc391:                                       ; preds = %for.body351
  %258 = load i32, ptr %i348, align 4
  %inc392 = add nsw i32 %258, 1
  store i32 %inc392, ptr %i348, align 4
  br label %for.cond349, !llvm.loop !15

for.end393:                                       ; preds = %for.cond349
  br label %if.end394

if.end394:                                        ; preds = %for.end393, %for.end346
  br label %if.end732

if.else395:                                       ; preds = %lor.lhs.false95
  %259 = load float, ptr %thickness.addr, align 4
  %260 = load float, ptr %AA_SIZE, align 4
  %sub396 = fsub float %259, %260
  %mul397 = fmul float %sub396, 5.000000e-01
  store float %mul397, ptr %half_inner_thickness, align 4
  %261 = load i8, ptr %closed, align 1
  %tobool398 = trunc i8 %261 to i1
  br i1 %tobool398, label %if.end481, label %if.then399

if.then399:                                       ; preds = %if.else395
  %262 = load i32, ptr %points_count.addr, align 4
  %sub400 = sub nsw i32 %262, 1
  store i32 %sub400, ptr %points_last, align 4
  %263 = load ptr, ptr %points.addr, align 8
  %arrayidx402 = getelementptr inbounds %struct.ImVec2, ptr %263, i64 0
  %264 = load ptr, ptr %temp_normals, align 8
  %arrayidx404 = getelementptr inbounds %struct.ImVec2, ptr %264, i64 0
  %265 = load float, ptr %half_inner_thickness, align 4
  %266 = load float, ptr %AA_SIZE, align 4
  %add405 = fadd float %265, %266
  %call406 = call <2 x float> @_ZmlRK6ImVec2f(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx404, float noundef %add405)
  store <2 x float> %call406, ptr %ref.tmp403, align 4
  %call407 = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx402, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp403)
  store <2 x float> %call407, ptr %ref.tmp401, align 4
  %267 = load ptr, ptr %temp_points, align 8
  %arrayidx408 = getelementptr inbounds %struct.ImVec2, ptr %267, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx408, ptr align 4 %ref.tmp401, i64 8, i1 false)
  %268 = load ptr, ptr %points.addr, align 8
  %arrayidx410 = getelementptr inbounds %struct.ImVec2, ptr %268, i64 0
  %269 = load ptr, ptr %temp_normals, align 8
  %arrayidx412 = getelementptr inbounds %struct.ImVec2, ptr %269, i64 0
  %270 = load float, ptr %half_inner_thickness, align 4
  %call413 = call <2 x float> @_ZmlRK6ImVec2f(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx412, float noundef %270)
  store <2 x float> %call413, ptr %ref.tmp411, align 4
  %call414 = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx410, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp411)
  store <2 x float> %call414, ptr %ref.tmp409, align 4
  %271 = load ptr, ptr %temp_points, align 8
  %arrayidx415 = getelementptr inbounds %struct.ImVec2, ptr %271, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx415, ptr align 4 %ref.tmp409, i64 8, i1 false)
  %272 = load ptr, ptr %points.addr, align 8
  %arrayidx417 = getelementptr inbounds %struct.ImVec2, ptr %272, i64 0
  %273 = load ptr, ptr %temp_normals, align 8
  %arrayidx419 = getelementptr inbounds %struct.ImVec2, ptr %273, i64 0
  %274 = load float, ptr %half_inner_thickness, align 4
  %call420 = call <2 x float> @_ZmlRK6ImVec2f(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx419, float noundef %274)
  store <2 x float> %call420, ptr %ref.tmp418, align 4
  %call421 = call <2 x float> @_ZmiRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx417, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp418)
  store <2 x float> %call421, ptr %ref.tmp416, align 4
  %275 = load ptr, ptr %temp_points, align 8
  %arrayidx422 = getelementptr inbounds %struct.ImVec2, ptr %275, i64 2
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx422, ptr align 4 %ref.tmp416, i64 8, i1 false)
  %276 = load ptr, ptr %points.addr, align 8
  %arrayidx424 = getelementptr inbounds %struct.ImVec2, ptr %276, i64 0
  %277 = load ptr, ptr %temp_normals, align 8
  %arrayidx426 = getelementptr inbounds %struct.ImVec2, ptr %277, i64 0
  %278 = load float, ptr %half_inner_thickness, align 4
  %279 = load float, ptr %AA_SIZE, align 4
  %add427 = fadd float %278, %279
  %call428 = call <2 x float> @_ZmlRK6ImVec2f(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx426, float noundef %add427)
  store <2 x float> %call428, ptr %ref.tmp425, align 4
  %call429 = call <2 x float> @_ZmiRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx424, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp425)
  store <2 x float> %call429, ptr %ref.tmp423, align 4
  %280 = load ptr, ptr %temp_points, align 8
  %arrayidx430 = getelementptr inbounds %struct.ImVec2, ptr %280, i64 3
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx430, ptr align 4 %ref.tmp423, i64 8, i1 false)
  %281 = load ptr, ptr %points.addr, align 8
  %282 = load i32, ptr %points_last, align 4
  %idxprom432 = sext i32 %282 to i64
  %arrayidx433 = getelementptr inbounds %struct.ImVec2, ptr %281, i64 %idxprom432
  %283 = load ptr, ptr %temp_normals, align 8
  %284 = load i32, ptr %points_last, align 4
  %idxprom435 = sext i32 %284 to i64
  %arrayidx436 = getelementptr inbounds %struct.ImVec2, ptr %283, i64 %idxprom435
  %285 = load float, ptr %half_inner_thickness, align 4
  %286 = load float, ptr %AA_SIZE, align 4
  %add437 = fadd float %285, %286
  %call438 = call <2 x float> @_ZmlRK6ImVec2f(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx436, float noundef %add437)
  store <2 x float> %call438, ptr %ref.tmp434, align 4
  %call439 = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx433, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp434)
  store <2 x float> %call439, ptr %ref.tmp431, align 4
  %287 = load ptr, ptr %temp_points, align 8
  %288 = load i32, ptr %points_last, align 4
  %mul440 = mul nsw i32 %288, 4
  %add441 = add nsw i32 %mul440, 0
  %idxprom442 = sext i32 %add441 to i64
  %arrayidx443 = getelementptr inbounds %struct.ImVec2, ptr %287, i64 %idxprom442
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx443, ptr align 4 %ref.tmp431, i64 8, i1 false)
  %289 = load ptr, ptr %points.addr, align 8
  %290 = load i32, ptr %points_last, align 4
  %idxprom445 = sext i32 %290 to i64
  %arrayidx446 = getelementptr inbounds %struct.ImVec2, ptr %289, i64 %idxprom445
  %291 = load ptr, ptr %temp_normals, align 8
  %292 = load i32, ptr %points_last, align 4
  %idxprom448 = sext i32 %292 to i64
  %arrayidx449 = getelementptr inbounds %struct.ImVec2, ptr %291, i64 %idxprom448
  %293 = load float, ptr %half_inner_thickness, align 4
  %call450 = call <2 x float> @_ZmlRK6ImVec2f(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx449, float noundef %293)
  store <2 x float> %call450, ptr %ref.tmp447, align 4
  %call451 = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx446, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp447)
  store <2 x float> %call451, ptr %ref.tmp444, align 4
  %294 = load ptr, ptr %temp_points, align 8
  %295 = load i32, ptr %points_last, align 4
  %mul452 = mul nsw i32 %295, 4
  %add453 = add nsw i32 %mul452, 1
  %idxprom454 = sext i32 %add453 to i64
  %arrayidx455 = getelementptr inbounds %struct.ImVec2, ptr %294, i64 %idxprom454
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx455, ptr align 4 %ref.tmp444, i64 8, i1 false)
  %296 = load ptr, ptr %points.addr, align 8
  %297 = load i32, ptr %points_last, align 4
  %idxprom457 = sext i32 %297 to i64
  %arrayidx458 = getelementptr inbounds %struct.ImVec2, ptr %296, i64 %idxprom457
  %298 = load ptr, ptr %temp_normals, align 8
  %299 = load i32, ptr %points_last, align 4
  %idxprom460 = sext i32 %299 to i64
  %arrayidx461 = getelementptr inbounds %struct.ImVec2, ptr %298, i64 %idxprom460
  %300 = load float, ptr %half_inner_thickness, align 4
  %call462 = call <2 x float> @_ZmlRK6ImVec2f(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx461, float noundef %300)
  store <2 x float> %call462, ptr %ref.tmp459, align 4
  %call463 = call <2 x float> @_ZmiRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx458, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp459)
  store <2 x float> %call463, ptr %ref.tmp456, align 4
  %301 = load ptr, ptr %temp_points, align 8
  %302 = load i32, ptr %points_last, align 4
  %mul464 = mul nsw i32 %302, 4
  %add465 = add nsw i32 %mul464, 2
  %idxprom466 = sext i32 %add465 to i64
  %arrayidx467 = getelementptr inbounds %struct.ImVec2, ptr %301, i64 %idxprom466
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx467, ptr align 4 %ref.tmp456, i64 8, i1 false)
  %303 = load ptr, ptr %points.addr, align 8
  %304 = load i32, ptr %points_last, align 4
  %idxprom469 = sext i32 %304 to i64
  %arrayidx470 = getelementptr inbounds %struct.ImVec2, ptr %303, i64 %idxprom469
  %305 = load ptr, ptr %temp_normals, align 8
  %306 = load i32, ptr %points_last, align 4
  %idxprom472 = sext i32 %306 to i64
  %arrayidx473 = getelementptr inbounds %struct.ImVec2, ptr %305, i64 %idxprom472
  %307 = load float, ptr %half_inner_thickness, align 4
  %308 = load float, ptr %AA_SIZE, align 4
  %add474 = fadd float %307, %308
  %call475 = call <2 x float> @_ZmlRK6ImVec2f(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx473, float noundef %add474)
  store <2 x float> %call475, ptr %ref.tmp471, align 4
  %call476 = call <2 x float> @_ZmiRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx470, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp471)
  store <2 x float> %call476, ptr %ref.tmp468, align 4
  %309 = load ptr, ptr %temp_points, align 8
  %310 = load i32, ptr %points_last, align 4
  %mul477 = mul nsw i32 %310, 4
  %add478 = add nsw i32 %mul477, 3
  %idxprom479 = sext i32 %add478 to i64
  %arrayidx480 = getelementptr inbounds %struct.ImVec2, ptr %309, i64 %idxprom479
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx480, ptr align 4 %ref.tmp468, i64 8, i1 false)
  br label %if.end481

if.end481:                                        ; preds = %if.then399, %if.else395
  %_VtxCurrentIdx483 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %311 = load i32, ptr %_VtxCurrentIdx483, align 4
  store i32 %311, ptr %idx1482, align 4
  store i32 0, ptr %i1484, align 4
  br label %for.cond485

for.cond485:                                      ; preds = %for.inc668, %if.end481
  %312 = load i32, ptr %i1484, align 4
  %313 = load i32, ptr %count, align 4
  %cmp486 = icmp slt i32 %312, %313
  br i1 %cmp486, label %for.body487, label %for.end670

for.body487:                                      ; preds = %for.cond485
  %314 = load i32, ptr %i1484, align 4
  %add489 = add nsw i32 %314, 1
  %315 = load i32, ptr %points_count.addr, align 4
  %cmp490 = icmp eq i32 %add489, %315
  br i1 %cmp490, label %cond.true491, label %cond.false492

cond.true491:                                     ; preds = %for.body487
  br label %cond.end494

cond.false492:                                    ; preds = %for.body487
  %316 = load i32, ptr %i1484, align 4
  %add493 = add nsw i32 %316, 1
  br label %cond.end494

cond.end494:                                      ; preds = %cond.false492, %cond.true491
  %cond495 = phi i32 [ 0, %cond.true491 ], [ %add493, %cond.false492 ]
  store i32 %cond495, ptr %i2488, align 4
  %317 = load i32, ptr %i1484, align 4
  %add497 = add nsw i32 %317, 1
  %318 = load i32, ptr %points_count.addr, align 4
  %cmp498 = icmp eq i32 %add497, %318
  br i1 %cmp498, label %cond.true499, label %cond.false501

cond.true499:                                     ; preds = %cond.end494
  %_VtxCurrentIdx500 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %319 = load i32, ptr %_VtxCurrentIdx500, align 4
  br label %cond.end503

cond.false501:                                    ; preds = %cond.end494
  %320 = load i32, ptr %idx1482, align 4
  %add502 = add i32 %320, 4
  br label %cond.end503

cond.end503:                                      ; preds = %cond.false501, %cond.true499
  %cond504 = phi i32 [ %319, %cond.true499 ], [ %add502, %cond.false501 ]
  store i32 %cond504, ptr %idx2496, align 4
  %321 = load ptr, ptr %temp_normals, align 8
  %322 = load i32, ptr %i1484, align 4
  %idxprom506 = sext i32 %322 to i64
  %arrayidx507 = getelementptr inbounds %struct.ImVec2, ptr %321, i64 %idxprom506
  %x508 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx507, i32 0, i32 0
  %323 = load float, ptr %x508, align 4
  %324 = load ptr, ptr %temp_normals, align 8
  %325 = load i32, ptr %i2488, align 4
  %idxprom509 = sext i32 %325 to i64
  %arrayidx510 = getelementptr inbounds %struct.ImVec2, ptr %324, i64 %idxprom509
  %x511 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx510, i32 0, i32 0
  %326 = load float, ptr %x511, align 4
  %add512 = fadd float %323, %326
  %mul513 = fmul float %add512, 5.000000e-01
  store float %mul513, ptr %dm_x505, align 4
  %327 = load ptr, ptr %temp_normals, align 8
  %328 = load i32, ptr %i1484, align 4
  %idxprom515 = sext i32 %328 to i64
  %arrayidx516 = getelementptr inbounds %struct.ImVec2, ptr %327, i64 %idxprom515
  %y517 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx516, i32 0, i32 1
  %329 = load float, ptr %y517, align 4
  %330 = load ptr, ptr %temp_normals, align 8
  %331 = load i32, ptr %i2488, align 4
  %idxprom518 = sext i32 %331 to i64
  %arrayidx519 = getelementptr inbounds %struct.ImVec2, ptr %330, i64 %idxprom518
  %y520 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx519, i32 0, i32 1
  %332 = load float, ptr %y520, align 4
  %add521 = fadd float %329, %332
  %mul522 = fmul float %add521, 5.000000e-01
  store float %mul522, ptr %dm_y514, align 4
  %333 = load float, ptr %dm_x505, align 4
  %334 = load float, ptr %dm_x505, align 4
  %335 = load float, ptr %dm_y514, align 4
  %336 = load float, ptr %dm_y514, align 4
  %mul525 = fmul float %335, %336
  %337 = call float @llvm.fmuladd.f32(float %333, float %334, float %mul525)
  store float %337, ptr %d2523, align 4
  %338 = load float, ptr %d2523, align 4
  %cmp526 = fcmp ogt float %338, 0x3EB0C6F7A0000000
  br i1 %cmp526, label %if.then527, label %if.end535

if.then527:                                       ; preds = %cond.end503
  %339 = load float, ptr %d2523, align 4
  %div529 = fdiv float 1.000000e+00, %339
  store float %div529, ptr %inv_len2528, align 4
  %340 = load float, ptr %inv_len2528, align 4
  %cmp530 = fcmp ogt float %340, 1.000000e+02
  br i1 %cmp530, label %if.then531, label %if.end532

if.then531:                                       ; preds = %if.then527
  store float 1.000000e+02, ptr %inv_len2528, align 4
  br label %if.end532

if.end532:                                        ; preds = %if.then531, %if.then527
  %341 = load float, ptr %inv_len2528, align 4
  %342 = load float, ptr %dm_x505, align 4
  %mul533 = fmul float %342, %341
  store float %mul533, ptr %dm_x505, align 4
  %343 = load float, ptr %inv_len2528, align 4
  %344 = load float, ptr %dm_y514, align 4
  %mul534 = fmul float %344, %343
  store float %mul534, ptr %dm_y514, align 4
  br label %if.end535

if.end535:                                        ; preds = %if.end532, %cond.end503
  %345 = load float, ptr %dm_x505, align 4
  %346 = load float, ptr %half_inner_thickness, align 4
  %347 = load float, ptr %AA_SIZE, align 4
  %add536 = fadd float %346, %347
  %mul537 = fmul float %345, %add536
  store float %mul537, ptr %dm_out_x, align 4
  %348 = load float, ptr %dm_y514, align 4
  %349 = load float, ptr %half_inner_thickness, align 4
  %350 = load float, ptr %AA_SIZE, align 4
  %add538 = fadd float %349, %350
  %mul539 = fmul float %348, %add538
  store float %mul539, ptr %dm_out_y, align 4
  %351 = load float, ptr %dm_x505, align 4
  %352 = load float, ptr %half_inner_thickness, align 4
  %mul540 = fmul float %351, %352
  store float %mul540, ptr %dm_in_x, align 4
  %353 = load float, ptr %dm_y514, align 4
  %354 = load float, ptr %half_inner_thickness, align 4
  %mul541 = fmul float %353, %354
  store float %mul541, ptr %dm_in_y, align 4
  %355 = load ptr, ptr %temp_points, align 8
  %356 = load i32, ptr %i2488, align 4
  %mul543 = mul nsw i32 %356, 4
  %idxprom544 = sext i32 %mul543 to i64
  %arrayidx545 = getelementptr inbounds %struct.ImVec2, ptr %355, i64 %idxprom544
  store ptr %arrayidx545, ptr %out_vtx542, align 8
  %357 = load ptr, ptr %points.addr, align 8
  %358 = load i32, ptr %i2488, align 4
  %idxprom546 = sext i32 %358 to i64
  %arrayidx547 = getelementptr inbounds %struct.ImVec2, ptr %357, i64 %idxprom546
  %x548 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx547, i32 0, i32 0
  %359 = load float, ptr %x548, align 4
  %360 = load float, ptr %dm_out_x, align 4
  %add549 = fadd float %359, %360
  %361 = load ptr, ptr %out_vtx542, align 8
  %arrayidx550 = getelementptr inbounds %struct.ImVec2, ptr %361, i64 0
  %x551 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx550, i32 0, i32 0
  store float %add549, ptr %x551, align 4
  %362 = load ptr, ptr %points.addr, align 8
  %363 = load i32, ptr %i2488, align 4
  %idxprom552 = sext i32 %363 to i64
  %arrayidx553 = getelementptr inbounds %struct.ImVec2, ptr %362, i64 %idxprom552
  %y554 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx553, i32 0, i32 1
  %364 = load float, ptr %y554, align 4
  %365 = load float, ptr %dm_out_y, align 4
  %add555 = fadd float %364, %365
  %366 = load ptr, ptr %out_vtx542, align 8
  %arrayidx556 = getelementptr inbounds %struct.ImVec2, ptr %366, i64 0
  %y557 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx556, i32 0, i32 1
  store float %add555, ptr %y557, align 4
  %367 = load ptr, ptr %points.addr, align 8
  %368 = load i32, ptr %i2488, align 4
  %idxprom558 = sext i32 %368 to i64
  %arrayidx559 = getelementptr inbounds %struct.ImVec2, ptr %367, i64 %idxprom558
  %x560 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx559, i32 0, i32 0
  %369 = load float, ptr %x560, align 4
  %370 = load float, ptr %dm_in_x, align 4
  %add561 = fadd float %369, %370
  %371 = load ptr, ptr %out_vtx542, align 8
  %arrayidx562 = getelementptr inbounds %struct.ImVec2, ptr %371, i64 1
  %x563 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx562, i32 0, i32 0
  store float %add561, ptr %x563, align 4
  %372 = load ptr, ptr %points.addr, align 8
  %373 = load i32, ptr %i2488, align 4
  %idxprom564 = sext i32 %373 to i64
  %arrayidx565 = getelementptr inbounds %struct.ImVec2, ptr %372, i64 %idxprom564
  %y566 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx565, i32 0, i32 1
  %374 = load float, ptr %y566, align 4
  %375 = load float, ptr %dm_in_y, align 4
  %add567 = fadd float %374, %375
  %376 = load ptr, ptr %out_vtx542, align 8
  %arrayidx568 = getelementptr inbounds %struct.ImVec2, ptr %376, i64 1
  %y569 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx568, i32 0, i32 1
  store float %add567, ptr %y569, align 4
  %377 = load ptr, ptr %points.addr, align 8
  %378 = load i32, ptr %i2488, align 4
  %idxprom570 = sext i32 %378 to i64
  %arrayidx571 = getelementptr inbounds %struct.ImVec2, ptr %377, i64 %idxprom570
  %x572 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx571, i32 0, i32 0
  %379 = load float, ptr %x572, align 4
  %380 = load float, ptr %dm_in_x, align 4
  %sub573 = fsub float %379, %380
  %381 = load ptr, ptr %out_vtx542, align 8
  %arrayidx574 = getelementptr inbounds %struct.ImVec2, ptr %381, i64 2
  %x575 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx574, i32 0, i32 0
  store float %sub573, ptr %x575, align 4
  %382 = load ptr, ptr %points.addr, align 8
  %383 = load i32, ptr %i2488, align 4
  %idxprom576 = sext i32 %383 to i64
  %arrayidx577 = getelementptr inbounds %struct.ImVec2, ptr %382, i64 %idxprom576
  %y578 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx577, i32 0, i32 1
  %384 = load float, ptr %y578, align 4
  %385 = load float, ptr %dm_in_y, align 4
  %sub579 = fsub float %384, %385
  %386 = load ptr, ptr %out_vtx542, align 8
  %arrayidx580 = getelementptr inbounds %struct.ImVec2, ptr %386, i64 2
  %y581 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx580, i32 0, i32 1
  store float %sub579, ptr %y581, align 4
  %387 = load ptr, ptr %points.addr, align 8
  %388 = load i32, ptr %i2488, align 4
  %idxprom582 = sext i32 %388 to i64
  %arrayidx583 = getelementptr inbounds %struct.ImVec2, ptr %387, i64 %idxprom582
  %x584 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx583, i32 0, i32 0
  %389 = load float, ptr %x584, align 4
  %390 = load float, ptr %dm_out_x, align 4
  %sub585 = fsub float %389, %390
  %391 = load ptr, ptr %out_vtx542, align 8
  %arrayidx586 = getelementptr inbounds %struct.ImVec2, ptr %391, i64 3
  %x587 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx586, i32 0, i32 0
  store float %sub585, ptr %x587, align 4
  %392 = load ptr, ptr %points.addr, align 8
  %393 = load i32, ptr %i2488, align 4
  %idxprom588 = sext i32 %393 to i64
  %arrayidx589 = getelementptr inbounds %struct.ImVec2, ptr %392, i64 %idxprom588
  %y590 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx589, i32 0, i32 1
  %394 = load float, ptr %y590, align 4
  %395 = load float, ptr %dm_out_y, align 4
  %sub591 = fsub float %394, %395
  %396 = load ptr, ptr %out_vtx542, align 8
  %arrayidx592 = getelementptr inbounds %struct.ImVec2, ptr %396, i64 3
  %y593 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx592, i32 0, i32 1
  store float %sub591, ptr %y593, align 4
  %397 = load i32, ptr %idx2496, align 4
  %add594 = add i32 %397, 1
  %conv595 = trunc i32 %add594 to i16
  %_IdxWritePtr596 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %398 = load ptr, ptr %_IdxWritePtr596, align 8
  %arrayidx597 = getelementptr inbounds i16, ptr %398, i64 0
  store i16 %conv595, ptr %arrayidx597, align 2
  %399 = load i32, ptr %idx1482, align 4
  %add598 = add i32 %399, 1
  %conv599 = trunc i32 %add598 to i16
  %_IdxWritePtr600 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %400 = load ptr, ptr %_IdxWritePtr600, align 8
  %arrayidx601 = getelementptr inbounds i16, ptr %400, i64 1
  store i16 %conv599, ptr %arrayidx601, align 2
  %401 = load i32, ptr %idx1482, align 4
  %add602 = add i32 %401, 2
  %conv603 = trunc i32 %add602 to i16
  %_IdxWritePtr604 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %402 = load ptr, ptr %_IdxWritePtr604, align 8
  %arrayidx605 = getelementptr inbounds i16, ptr %402, i64 2
  store i16 %conv603, ptr %arrayidx605, align 2
  %403 = load i32, ptr %idx1482, align 4
  %add606 = add i32 %403, 2
  %conv607 = trunc i32 %add606 to i16
  %_IdxWritePtr608 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %404 = load ptr, ptr %_IdxWritePtr608, align 8
  %arrayidx609 = getelementptr inbounds i16, ptr %404, i64 3
  store i16 %conv607, ptr %arrayidx609, align 2
  %405 = load i32, ptr %idx2496, align 4
  %add610 = add i32 %405, 2
  %conv611 = trunc i32 %add610 to i16
  %_IdxWritePtr612 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %406 = load ptr, ptr %_IdxWritePtr612, align 8
  %arrayidx613 = getelementptr inbounds i16, ptr %406, i64 4
  store i16 %conv611, ptr %arrayidx613, align 2
  %407 = load i32, ptr %idx2496, align 4
  %add614 = add i32 %407, 1
  %conv615 = trunc i32 %add614 to i16
  %_IdxWritePtr616 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %408 = load ptr, ptr %_IdxWritePtr616, align 8
  %arrayidx617 = getelementptr inbounds i16, ptr %408, i64 5
  store i16 %conv615, ptr %arrayidx617, align 2
  %409 = load i32, ptr %idx2496, align 4
  %add618 = add i32 %409, 1
  %conv619 = trunc i32 %add618 to i16
  %_IdxWritePtr620 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %410 = load ptr, ptr %_IdxWritePtr620, align 8
  %arrayidx621 = getelementptr inbounds i16, ptr %410, i64 6
  store i16 %conv619, ptr %arrayidx621, align 2
  %411 = load i32, ptr %idx1482, align 4
  %add622 = add i32 %411, 1
  %conv623 = trunc i32 %add622 to i16
  %_IdxWritePtr624 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %412 = load ptr, ptr %_IdxWritePtr624, align 8
  %arrayidx625 = getelementptr inbounds i16, ptr %412, i64 7
  store i16 %conv623, ptr %arrayidx625, align 2
  %413 = load i32, ptr %idx1482, align 4
  %add626 = add i32 %413, 0
  %conv627 = trunc i32 %add626 to i16
  %_IdxWritePtr628 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %414 = load ptr, ptr %_IdxWritePtr628, align 8
  %arrayidx629 = getelementptr inbounds i16, ptr %414, i64 8
  store i16 %conv627, ptr %arrayidx629, align 2
  %415 = load i32, ptr %idx1482, align 4
  %add630 = add i32 %415, 0
  %conv631 = trunc i32 %add630 to i16
  %_IdxWritePtr632 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %416 = load ptr, ptr %_IdxWritePtr632, align 8
  %arrayidx633 = getelementptr inbounds i16, ptr %416, i64 9
  store i16 %conv631, ptr %arrayidx633, align 2
  %417 = load i32, ptr %idx2496, align 4
  %add634 = add i32 %417, 0
  %conv635 = trunc i32 %add634 to i16
  %_IdxWritePtr636 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %418 = load ptr, ptr %_IdxWritePtr636, align 8
  %arrayidx637 = getelementptr inbounds i16, ptr %418, i64 10
  store i16 %conv635, ptr %arrayidx637, align 2
  %419 = load i32, ptr %idx2496, align 4
  %add638 = add i32 %419, 1
  %conv639 = trunc i32 %add638 to i16
  %_IdxWritePtr640 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %420 = load ptr, ptr %_IdxWritePtr640, align 8
  %arrayidx641 = getelementptr inbounds i16, ptr %420, i64 11
  store i16 %conv639, ptr %arrayidx641, align 2
  %421 = load i32, ptr %idx2496, align 4
  %add642 = add i32 %421, 2
  %conv643 = trunc i32 %add642 to i16
  %_IdxWritePtr644 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %422 = load ptr, ptr %_IdxWritePtr644, align 8
  %arrayidx645 = getelementptr inbounds i16, ptr %422, i64 12
  store i16 %conv643, ptr %arrayidx645, align 2
  %423 = load i32, ptr %idx1482, align 4
  %add646 = add i32 %423, 2
  %conv647 = trunc i32 %add646 to i16
  %_IdxWritePtr648 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %424 = load ptr, ptr %_IdxWritePtr648, align 8
  %arrayidx649 = getelementptr inbounds i16, ptr %424, i64 13
  store i16 %conv647, ptr %arrayidx649, align 2
  %425 = load i32, ptr %idx1482, align 4
  %add650 = add i32 %425, 3
  %conv651 = trunc i32 %add650 to i16
  %_IdxWritePtr652 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %426 = load ptr, ptr %_IdxWritePtr652, align 8
  %arrayidx653 = getelementptr inbounds i16, ptr %426, i64 14
  store i16 %conv651, ptr %arrayidx653, align 2
  %427 = load i32, ptr %idx1482, align 4
  %add654 = add i32 %427, 3
  %conv655 = trunc i32 %add654 to i16
  %_IdxWritePtr656 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %428 = load ptr, ptr %_IdxWritePtr656, align 8
  %arrayidx657 = getelementptr inbounds i16, ptr %428, i64 15
  store i16 %conv655, ptr %arrayidx657, align 2
  %429 = load i32, ptr %idx2496, align 4
  %add658 = add i32 %429, 3
  %conv659 = trunc i32 %add658 to i16
  %_IdxWritePtr660 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %430 = load ptr, ptr %_IdxWritePtr660, align 8
  %arrayidx661 = getelementptr inbounds i16, ptr %430, i64 16
  store i16 %conv659, ptr %arrayidx661, align 2
  %431 = load i32, ptr %idx2496, align 4
  %add662 = add i32 %431, 2
  %conv663 = trunc i32 %add662 to i16
  %_IdxWritePtr664 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %432 = load ptr, ptr %_IdxWritePtr664, align 8
  %arrayidx665 = getelementptr inbounds i16, ptr %432, i64 17
  store i16 %conv663, ptr %arrayidx665, align 2
  %_IdxWritePtr666 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %433 = load ptr, ptr %_IdxWritePtr666, align 8
  %add.ptr667 = getelementptr inbounds i16, ptr %433, i64 18
  store ptr %add.ptr667, ptr %_IdxWritePtr666, align 8
  %434 = load i32, ptr %idx2496, align 4
  store i32 %434, ptr %idx1482, align 4
  br label %for.inc668

for.inc668:                                       ; preds = %if.end535
  %435 = load i32, ptr %i1484, align 4
  %inc669 = add nsw i32 %435, 1
  store i32 %inc669, ptr %i1484, align 4
  br label %for.cond485, !llvm.loop !16

for.end670:                                       ; preds = %for.cond485
  store i32 0, ptr %i671, align 4
  br label %for.cond672

for.cond672:                                      ; preds = %for.inc729, %for.end670
  %436 = load i32, ptr %i671, align 4
  %437 = load i32, ptr %points_count.addr, align 4
  %cmp673 = icmp slt i32 %436, %437
  br i1 %cmp673, label %for.body674, label %for.end731

for.body674:                                      ; preds = %for.cond672
  %438 = load ptr, ptr %temp_points, align 8
  %439 = load i32, ptr %i671, align 4
  %mul675 = mul nsw i32 %439, 4
  %add676 = add nsw i32 %mul675, 0
  %idxprom677 = sext i32 %add676 to i64
  %arrayidx678 = getelementptr inbounds %struct.ImVec2, ptr %438, i64 %idxprom677
  %_VtxWritePtr679 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %440 = load ptr, ptr %_VtxWritePtr679, align 8
  %arrayidx680 = getelementptr inbounds %struct.ImDrawVert, ptr %440, i64 0
  %pos681 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx680, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %pos681, ptr align 4 %arrayidx678, i64 8, i1 false)
  %_VtxWritePtr682 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %441 = load ptr, ptr %_VtxWritePtr682, align 8
  %arrayidx683 = getelementptr inbounds %struct.ImDrawVert, ptr %441, i64 0
  %uv684 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx683, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv684, ptr align 4 %opaque_uv, i64 8, i1 false)
  %442 = load i32, ptr %col_trans, align 4
  %_VtxWritePtr685 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %443 = load ptr, ptr %_VtxWritePtr685, align 8
  %arrayidx686 = getelementptr inbounds %struct.ImDrawVert, ptr %443, i64 0
  %col687 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx686, i32 0, i32 2
  store i32 %442, ptr %col687, align 4
  %444 = load ptr, ptr %temp_points, align 8
  %445 = load i32, ptr %i671, align 4
  %mul688 = mul nsw i32 %445, 4
  %add689 = add nsw i32 %mul688, 1
  %idxprom690 = sext i32 %add689 to i64
  %arrayidx691 = getelementptr inbounds %struct.ImVec2, ptr %444, i64 %idxprom690
  %_VtxWritePtr692 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %446 = load ptr, ptr %_VtxWritePtr692, align 8
  %arrayidx693 = getelementptr inbounds %struct.ImDrawVert, ptr %446, i64 1
  %pos694 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx693, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %pos694, ptr align 4 %arrayidx691, i64 8, i1 false)
  %_VtxWritePtr695 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %447 = load ptr, ptr %_VtxWritePtr695, align 8
  %arrayidx696 = getelementptr inbounds %struct.ImDrawVert, ptr %447, i64 1
  %uv697 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx696, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv697, ptr align 4 %opaque_uv, i64 8, i1 false)
  %448 = load i32, ptr %col.addr, align 4
  %_VtxWritePtr698 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %449 = load ptr, ptr %_VtxWritePtr698, align 8
  %arrayidx699 = getelementptr inbounds %struct.ImDrawVert, ptr %449, i64 1
  %col700 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx699, i32 0, i32 2
  store i32 %448, ptr %col700, align 4
  %450 = load ptr, ptr %temp_points, align 8
  %451 = load i32, ptr %i671, align 4
  %mul701 = mul nsw i32 %451, 4
  %add702 = add nsw i32 %mul701, 2
  %idxprom703 = sext i32 %add702 to i64
  %arrayidx704 = getelementptr inbounds %struct.ImVec2, ptr %450, i64 %idxprom703
  %_VtxWritePtr705 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %452 = load ptr, ptr %_VtxWritePtr705, align 8
  %arrayidx706 = getelementptr inbounds %struct.ImDrawVert, ptr %452, i64 2
  %pos707 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx706, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %pos707, ptr align 4 %arrayidx704, i64 8, i1 false)
  %_VtxWritePtr708 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %453 = load ptr, ptr %_VtxWritePtr708, align 8
  %arrayidx709 = getelementptr inbounds %struct.ImDrawVert, ptr %453, i64 2
  %uv710 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx709, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv710, ptr align 4 %opaque_uv, i64 8, i1 false)
  %454 = load i32, ptr %col.addr, align 4
  %_VtxWritePtr711 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %455 = load ptr, ptr %_VtxWritePtr711, align 8
  %arrayidx712 = getelementptr inbounds %struct.ImDrawVert, ptr %455, i64 2
  %col713 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx712, i32 0, i32 2
  store i32 %454, ptr %col713, align 4
  %456 = load ptr, ptr %temp_points, align 8
  %457 = load i32, ptr %i671, align 4
  %mul714 = mul nsw i32 %457, 4
  %add715 = add nsw i32 %mul714, 3
  %idxprom716 = sext i32 %add715 to i64
  %arrayidx717 = getelementptr inbounds %struct.ImVec2, ptr %456, i64 %idxprom716
  %_VtxWritePtr718 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %458 = load ptr, ptr %_VtxWritePtr718, align 8
  %arrayidx719 = getelementptr inbounds %struct.ImDrawVert, ptr %458, i64 3
  %pos720 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx719, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %pos720, ptr align 4 %arrayidx717, i64 8, i1 false)
  %_VtxWritePtr721 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %459 = load ptr, ptr %_VtxWritePtr721, align 8
  %arrayidx722 = getelementptr inbounds %struct.ImDrawVert, ptr %459, i64 3
  %uv723 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx722, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv723, ptr align 4 %opaque_uv, i64 8, i1 false)
  %460 = load i32, ptr %col_trans, align 4
  %_VtxWritePtr724 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %461 = load ptr, ptr %_VtxWritePtr724, align 8
  %arrayidx725 = getelementptr inbounds %struct.ImDrawVert, ptr %461, i64 3
  %col726 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx725, i32 0, i32 2
  store i32 %460, ptr %col726, align 4
  %_VtxWritePtr727 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %462 = load ptr, ptr %_VtxWritePtr727, align 8
  %add.ptr728 = getelementptr inbounds %struct.ImDrawVert, ptr %462, i64 4
  store ptr %add.ptr728, ptr %_VtxWritePtr727, align 8
  br label %for.inc729

for.inc729:                                       ; preds = %for.body674
  %463 = load i32, ptr %i671, align 4
  %inc730 = add nsw i32 %463, 1
  store i32 %inc730, ptr %i671, align 4
  br label %for.cond672, !llvm.loop !17

for.end731:                                       ; preds = %for.cond672
  br label %if.end732

if.end732:                                        ; preds = %for.end731, %if.end394
  %464 = load i32, ptr %vtx_count, align 4
  %conv733 = trunc i32 %464 to i16
  %conv734 = zext i16 %conv733 to i32
  %_VtxCurrentIdx735 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %465 = load i32, ptr %_VtxCurrentIdx735, align 4
  %add736 = add i32 %465, %conv734
  store i32 %add736, ptr %_VtxCurrentIdx735, align 4
  br label %if.end889

if.else737:                                       ; preds = %cond.end
  %466 = load i32, ptr %count, align 4
  %mul739 = mul nsw i32 %466, 6
  store i32 %mul739, ptr %idx_count738, align 4
  %467 = load i32, ptr %count, align 4
  %mul741 = mul nsw i32 %467, 4
  store i32 %mul741, ptr %vtx_count740, align 4
  %468 = load i32, ptr %idx_count738, align 4
  %469 = load i32, ptr %vtx_count740, align 4
  call void @_ZN10ImDrawList11PrimReserveEii(ptr noundef nonnull align 8 dereferenceable(196) %this1, i32 noundef %468, i32 noundef %469)
  store i32 0, ptr %i1742, align 4
  br label %for.cond743

for.cond743:                                      ; preds = %for.inc886, %if.else737
  %470 = load i32, ptr %i1742, align 4
  %471 = load i32, ptr %count, align 4
  %cmp744 = icmp slt i32 %470, %471
  br i1 %cmp744, label %for.body745, label %for.end888

for.body745:                                      ; preds = %for.cond743
  %472 = load i32, ptr %i1742, align 4
  %add747 = add nsw i32 %472, 1
  %473 = load i32, ptr %points_count.addr, align 4
  %cmp748 = icmp eq i32 %add747, %473
  br i1 %cmp748, label %cond.true749, label %cond.false750

cond.true749:                                     ; preds = %for.body745
  br label %cond.end752

cond.false750:                                    ; preds = %for.body745
  %474 = load i32, ptr %i1742, align 4
  %add751 = add nsw i32 %474, 1
  br label %cond.end752

cond.end752:                                      ; preds = %cond.false750, %cond.true749
  %cond753 = phi i32 [ 0, %cond.true749 ], [ %add751, %cond.false750 ]
  store i32 %cond753, ptr %i2746, align 4
  %475 = load ptr, ptr %points.addr, align 8
  %476 = load i32, ptr %i1742, align 4
  %idxprom754 = sext i32 %476 to i64
  %arrayidx755 = getelementptr inbounds %struct.ImVec2, ptr %475, i64 %idxprom754
  store ptr %arrayidx755, ptr %p1, align 8
  %477 = load ptr, ptr %points.addr, align 8
  %478 = load i32, ptr %i2746, align 4
  %idxprom756 = sext i32 %478 to i64
  %arrayidx757 = getelementptr inbounds %struct.ImVec2, ptr %477, i64 %idxprom756
  store ptr %arrayidx757, ptr %p2, align 8
  %479 = load ptr, ptr %p2, align 8
  %x759 = getelementptr inbounds %struct.ImVec2, ptr %479, i32 0, i32 0
  %480 = load float, ptr %x759, align 4
  %481 = load ptr, ptr %p1, align 8
  %x760 = getelementptr inbounds %struct.ImVec2, ptr %481, i32 0, i32 0
  %482 = load float, ptr %x760, align 4
  %sub761 = fsub float %480, %482
  store float %sub761, ptr %dx758, align 4
  %483 = load ptr, ptr %p2, align 8
  %y763 = getelementptr inbounds %struct.ImVec2, ptr %483, i32 0, i32 1
  %484 = load float, ptr %y763, align 4
  %485 = load ptr, ptr %p1, align 8
  %y764 = getelementptr inbounds %struct.ImVec2, ptr %485, i32 0, i32 1
  %486 = load float, ptr %y764, align 4
  %sub765 = fsub float %484, %486
  store float %sub765, ptr %dy762, align 4
  %487 = load float, ptr %dx758, align 4
  %488 = load float, ptr %dx758, align 4
  %489 = load float, ptr %dy762, align 4
  %490 = load float, ptr %dy762, align 4
  %mul768 = fmul float %489, %490
  %491 = call float @llvm.fmuladd.f32(float %487, float %488, float %mul768)
  store float %491, ptr %d2766, align 4
  %492 = load float, ptr %d2766, align 4
  %cmp769 = fcmp ogt float %492, 0.000000e+00
  br i1 %cmp769, label %if.then770, label %if.end775

if.then770:                                       ; preds = %cond.end752
  %493 = load float, ptr %d2766, align 4
  %call772 = call noundef float @_ZL7ImRsqrtf(float noundef %493)
  store float %call772, ptr %inv_len771, align 4
  %494 = load float, ptr %inv_len771, align 4
  %495 = load float, ptr %dx758, align 4
  %mul773 = fmul float %495, %494
  store float %mul773, ptr %dx758, align 4
  %496 = load float, ptr %inv_len771, align 4
  %497 = load float, ptr %dy762, align 4
  %mul774 = fmul float %497, %496
  store float %mul774, ptr %dy762, align 4
  br label %if.end775

if.end775:                                        ; preds = %if.then770, %cond.end752
  %498 = load float, ptr %thickness.addr, align 4
  %mul776 = fmul float %498, 5.000000e-01
  %499 = load float, ptr %dx758, align 4
  %mul777 = fmul float %499, %mul776
  store float %mul777, ptr %dx758, align 4
  %500 = load float, ptr %thickness.addr, align 4
  %mul778 = fmul float %500, 5.000000e-01
  %501 = load float, ptr %dy762, align 4
  %mul779 = fmul float %501, %mul778
  store float %mul779, ptr %dy762, align 4
  %502 = load ptr, ptr %p1, align 8
  %x780 = getelementptr inbounds %struct.ImVec2, ptr %502, i32 0, i32 0
  %503 = load float, ptr %x780, align 4
  %504 = load float, ptr %dy762, align 4
  %add781 = fadd float %503, %504
  %_VtxWritePtr782 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %505 = load ptr, ptr %_VtxWritePtr782, align 8
  %arrayidx783 = getelementptr inbounds %struct.ImDrawVert, ptr %505, i64 0
  %pos784 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx783, i32 0, i32 0
  %x785 = getelementptr inbounds %struct.ImVec2, ptr %pos784, i32 0, i32 0
  store float %add781, ptr %x785, align 4
  %506 = load ptr, ptr %p1, align 8
  %y786 = getelementptr inbounds %struct.ImVec2, ptr %506, i32 0, i32 1
  %507 = load float, ptr %y786, align 4
  %508 = load float, ptr %dx758, align 4
  %sub787 = fsub float %507, %508
  %_VtxWritePtr788 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %509 = load ptr, ptr %_VtxWritePtr788, align 8
  %arrayidx789 = getelementptr inbounds %struct.ImDrawVert, ptr %509, i64 0
  %pos790 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx789, i32 0, i32 0
  %y791 = getelementptr inbounds %struct.ImVec2, ptr %pos790, i32 0, i32 1
  store float %sub787, ptr %y791, align 4
  %_VtxWritePtr792 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %510 = load ptr, ptr %_VtxWritePtr792, align 8
  %arrayidx793 = getelementptr inbounds %struct.ImDrawVert, ptr %510, i64 0
  %uv794 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx793, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv794, ptr align 4 %opaque_uv, i64 8, i1 false)
  %511 = load i32, ptr %col.addr, align 4
  %_VtxWritePtr795 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %512 = load ptr, ptr %_VtxWritePtr795, align 8
  %arrayidx796 = getelementptr inbounds %struct.ImDrawVert, ptr %512, i64 0
  %col797 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx796, i32 0, i32 2
  store i32 %511, ptr %col797, align 4
  %513 = load ptr, ptr %p2, align 8
  %x798 = getelementptr inbounds %struct.ImVec2, ptr %513, i32 0, i32 0
  %514 = load float, ptr %x798, align 4
  %515 = load float, ptr %dy762, align 4
  %add799 = fadd float %514, %515
  %_VtxWritePtr800 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %516 = load ptr, ptr %_VtxWritePtr800, align 8
  %arrayidx801 = getelementptr inbounds %struct.ImDrawVert, ptr %516, i64 1
  %pos802 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx801, i32 0, i32 0
  %x803 = getelementptr inbounds %struct.ImVec2, ptr %pos802, i32 0, i32 0
  store float %add799, ptr %x803, align 4
  %517 = load ptr, ptr %p2, align 8
  %y804 = getelementptr inbounds %struct.ImVec2, ptr %517, i32 0, i32 1
  %518 = load float, ptr %y804, align 4
  %519 = load float, ptr %dx758, align 4
  %sub805 = fsub float %518, %519
  %_VtxWritePtr806 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %520 = load ptr, ptr %_VtxWritePtr806, align 8
  %arrayidx807 = getelementptr inbounds %struct.ImDrawVert, ptr %520, i64 1
  %pos808 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx807, i32 0, i32 0
  %y809 = getelementptr inbounds %struct.ImVec2, ptr %pos808, i32 0, i32 1
  store float %sub805, ptr %y809, align 4
  %_VtxWritePtr810 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %521 = load ptr, ptr %_VtxWritePtr810, align 8
  %arrayidx811 = getelementptr inbounds %struct.ImDrawVert, ptr %521, i64 1
  %uv812 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx811, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv812, ptr align 4 %opaque_uv, i64 8, i1 false)
  %522 = load i32, ptr %col.addr, align 4
  %_VtxWritePtr813 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %523 = load ptr, ptr %_VtxWritePtr813, align 8
  %arrayidx814 = getelementptr inbounds %struct.ImDrawVert, ptr %523, i64 1
  %col815 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx814, i32 0, i32 2
  store i32 %522, ptr %col815, align 4
  %524 = load ptr, ptr %p2, align 8
  %x816 = getelementptr inbounds %struct.ImVec2, ptr %524, i32 0, i32 0
  %525 = load float, ptr %x816, align 4
  %526 = load float, ptr %dy762, align 4
  %sub817 = fsub float %525, %526
  %_VtxWritePtr818 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %527 = load ptr, ptr %_VtxWritePtr818, align 8
  %arrayidx819 = getelementptr inbounds %struct.ImDrawVert, ptr %527, i64 2
  %pos820 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx819, i32 0, i32 0
  %x821 = getelementptr inbounds %struct.ImVec2, ptr %pos820, i32 0, i32 0
  store float %sub817, ptr %x821, align 4
  %528 = load ptr, ptr %p2, align 8
  %y822 = getelementptr inbounds %struct.ImVec2, ptr %528, i32 0, i32 1
  %529 = load float, ptr %y822, align 4
  %530 = load float, ptr %dx758, align 4
  %add823 = fadd float %529, %530
  %_VtxWritePtr824 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %531 = load ptr, ptr %_VtxWritePtr824, align 8
  %arrayidx825 = getelementptr inbounds %struct.ImDrawVert, ptr %531, i64 2
  %pos826 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx825, i32 0, i32 0
  %y827 = getelementptr inbounds %struct.ImVec2, ptr %pos826, i32 0, i32 1
  store float %add823, ptr %y827, align 4
  %_VtxWritePtr828 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %532 = load ptr, ptr %_VtxWritePtr828, align 8
  %arrayidx829 = getelementptr inbounds %struct.ImDrawVert, ptr %532, i64 2
  %uv830 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx829, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv830, ptr align 4 %opaque_uv, i64 8, i1 false)
  %533 = load i32, ptr %col.addr, align 4
  %_VtxWritePtr831 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %534 = load ptr, ptr %_VtxWritePtr831, align 8
  %arrayidx832 = getelementptr inbounds %struct.ImDrawVert, ptr %534, i64 2
  %col833 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx832, i32 0, i32 2
  store i32 %533, ptr %col833, align 4
  %535 = load ptr, ptr %p1, align 8
  %x834 = getelementptr inbounds %struct.ImVec2, ptr %535, i32 0, i32 0
  %536 = load float, ptr %x834, align 4
  %537 = load float, ptr %dy762, align 4
  %sub835 = fsub float %536, %537
  %_VtxWritePtr836 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %538 = load ptr, ptr %_VtxWritePtr836, align 8
  %arrayidx837 = getelementptr inbounds %struct.ImDrawVert, ptr %538, i64 3
  %pos838 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx837, i32 0, i32 0
  %x839 = getelementptr inbounds %struct.ImVec2, ptr %pos838, i32 0, i32 0
  store float %sub835, ptr %x839, align 4
  %539 = load ptr, ptr %p1, align 8
  %y840 = getelementptr inbounds %struct.ImVec2, ptr %539, i32 0, i32 1
  %540 = load float, ptr %y840, align 4
  %541 = load float, ptr %dx758, align 4
  %add841 = fadd float %540, %541
  %_VtxWritePtr842 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %542 = load ptr, ptr %_VtxWritePtr842, align 8
  %arrayidx843 = getelementptr inbounds %struct.ImDrawVert, ptr %542, i64 3
  %pos844 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx843, i32 0, i32 0
  %y845 = getelementptr inbounds %struct.ImVec2, ptr %pos844, i32 0, i32 1
  store float %add841, ptr %y845, align 4
  %_VtxWritePtr846 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %543 = load ptr, ptr %_VtxWritePtr846, align 8
  %arrayidx847 = getelementptr inbounds %struct.ImDrawVert, ptr %543, i64 3
  %uv848 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx847, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv848, ptr align 4 %opaque_uv, i64 8, i1 false)
  %544 = load i32, ptr %col.addr, align 4
  %_VtxWritePtr849 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %545 = load ptr, ptr %_VtxWritePtr849, align 8
  %arrayidx850 = getelementptr inbounds %struct.ImDrawVert, ptr %545, i64 3
  %col851 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx850, i32 0, i32 2
  store i32 %544, ptr %col851, align 4
  %_VtxWritePtr852 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %546 = load ptr, ptr %_VtxWritePtr852, align 8
  %add.ptr853 = getelementptr inbounds %struct.ImDrawVert, ptr %546, i64 4
  store ptr %add.ptr853, ptr %_VtxWritePtr852, align 8
  %_VtxCurrentIdx854 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %547 = load i32, ptr %_VtxCurrentIdx854, align 4
  %conv855 = trunc i32 %547 to i16
  %_IdxWritePtr856 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %548 = load ptr, ptr %_IdxWritePtr856, align 8
  %arrayidx857 = getelementptr inbounds i16, ptr %548, i64 0
  store i16 %conv855, ptr %arrayidx857, align 2
  %_VtxCurrentIdx858 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %549 = load i32, ptr %_VtxCurrentIdx858, align 4
  %add859 = add i32 %549, 1
  %conv860 = trunc i32 %add859 to i16
  %_IdxWritePtr861 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %550 = load ptr, ptr %_IdxWritePtr861, align 8
  %arrayidx862 = getelementptr inbounds i16, ptr %550, i64 1
  store i16 %conv860, ptr %arrayidx862, align 2
  %_VtxCurrentIdx863 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %551 = load i32, ptr %_VtxCurrentIdx863, align 4
  %add864 = add i32 %551, 2
  %conv865 = trunc i32 %add864 to i16
  %_IdxWritePtr866 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %552 = load ptr, ptr %_IdxWritePtr866, align 8
  %arrayidx867 = getelementptr inbounds i16, ptr %552, i64 2
  store i16 %conv865, ptr %arrayidx867, align 2
  %_VtxCurrentIdx868 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %553 = load i32, ptr %_VtxCurrentIdx868, align 4
  %conv869 = trunc i32 %553 to i16
  %_IdxWritePtr870 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %554 = load ptr, ptr %_IdxWritePtr870, align 8
  %arrayidx871 = getelementptr inbounds i16, ptr %554, i64 3
  store i16 %conv869, ptr %arrayidx871, align 2
  %_VtxCurrentIdx872 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %555 = load i32, ptr %_VtxCurrentIdx872, align 4
  %add873 = add i32 %555, 2
  %conv874 = trunc i32 %add873 to i16
  %_IdxWritePtr875 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %556 = load ptr, ptr %_IdxWritePtr875, align 8
  %arrayidx876 = getelementptr inbounds i16, ptr %556, i64 4
  store i16 %conv874, ptr %arrayidx876, align 2
  %_VtxCurrentIdx877 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %557 = load i32, ptr %_VtxCurrentIdx877, align 4
  %add878 = add i32 %557, 3
  %conv879 = trunc i32 %add878 to i16
  %_IdxWritePtr880 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %558 = load ptr, ptr %_IdxWritePtr880, align 8
  %arrayidx881 = getelementptr inbounds i16, ptr %558, i64 5
  store i16 %conv879, ptr %arrayidx881, align 2
  %_IdxWritePtr882 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %559 = load ptr, ptr %_IdxWritePtr882, align 8
  %add.ptr883 = getelementptr inbounds i16, ptr %559, i64 6
  store ptr %add.ptr883, ptr %_IdxWritePtr882, align 8
  %_VtxCurrentIdx884 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %560 = load i32, ptr %_VtxCurrentIdx884, align 4
  %add885 = add i32 %560, 4
  store i32 %add885, ptr %_VtxCurrentIdx884, align 4
  br label %for.inc886

for.inc886:                                       ; preds = %if.end775
  %561 = load i32, ptr %i1742, align 4
  %inc887 = add nsw i32 %561, 1
  store i32 %inc887, ptr %i1742, align 4
  br label %for.cond743, !llvm.loop !18

for.end888:                                       ; preds = %for.cond743
  br label %if.end889

if.end889:                                        ; preds = %for.end888, %if.end732, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI6ImVec2E15reserve_discardEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %Data = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 2
  %2 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %Data3 = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data3, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %3)
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %4 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %4 to i64
  %mul = mul i64 %conv, 8
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  %Data5 = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 2
  store ptr %call, ptr %Data5, align 8
  %5 = load i32, ptr %new_capacity.addr, align 4
  %Capacity6 = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 1
  store i32 %5, ptr %Capacity6, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.fmuladd.f32(float, float, float) #7

; Function Attrs: mustprogress uwtable
define internal noundef float @_ZL7ImRsqrtf(float noundef %x) #9 {
entry:
  %__w.addr.i = alloca float, align 4
  %.compoundliteral.i = alloca <4 x float>, align 16
  %__a.addr.i3 = alloca <4 x float>, align 16
  %__a.addr.i = alloca <4 x float>, align 16
  %x.addr = alloca float, align 4
  store float %x, ptr %x.addr, align 4
  %0 = load float, ptr %x.addr, align 4
  store float %0, ptr %__w.addr.i, align 4
  %1 = load float, ptr %__w.addr.i, align 4
  %vecinit.i = insertelement <4 x float> undef, float %1, i32 0
  %vecinit1.i = insertelement <4 x float> %vecinit.i, float 0.000000e+00, i32 1
  %vecinit2.i = insertelement <4 x float> %vecinit1.i, float 0.000000e+00, i32 2
  %vecinit3.i = insertelement <4 x float> %vecinit2.i, float 0.000000e+00, i32 3
  store <4 x float> %vecinit3.i, ptr %.compoundliteral.i, align 16
  %2 = load <4 x float>, ptr %.compoundliteral.i, align 16
  store <4 x float> %2, ptr %__a.addr.i3, align 16
  %3 = load <4 x float>, ptr %__a.addr.i3, align 16
  %4 = call noundef <4 x float> @llvm.x86.sse.rsqrt.ss(<4 x float> %3)
  store <4 x float> %4, ptr %__a.addr.i, align 16
  %5 = load <4 x float>, ptr %__a.addr.i, align 16
  %vecext.i = extractelement <4 x float> %5, i32 0
  ret float %vecext.i
}

; Function Attrs: mustprogress uwtable
define internal <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %lhs, ptr noundef nonnull align 4 dereferenceable(8) %rhs) #0 {
entry:
  %retval = alloca %struct.ImVec2, align 4
  %lhs.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %lhs, ptr %lhs.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %0 = load ptr, ptr %lhs.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %0, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %2 = load ptr, ptr %rhs.addr, align 8
  %x1 = getelementptr inbounds %struct.ImVec2, ptr %2, i32 0, i32 0
  %3 = load float, ptr %x1, align 4
  %add = fadd float %1, %3
  %4 = load ptr, ptr %lhs.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %4, i32 0, i32 1
  %5 = load float, ptr %y, align 4
  %6 = load ptr, ptr %rhs.addr, align 8
  %y2 = getelementptr inbounds %struct.ImVec2, ptr %6, i32 0, i32 1
  %7 = load float, ptr %y2, align 4
  %add3 = fadd float %5, %7
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %retval, float noundef %add, float noundef %add3)
  %8 = load <2 x float>, ptr %retval, align 4
  ret <2 x float> %8
}

; Function Attrs: mustprogress uwtable
define internal <2 x float> @_ZmlRK6ImVec2f(ptr noundef nonnull align 4 dereferenceable(8) %lhs, float noundef %rhs) #0 {
entry:
  %retval = alloca %struct.ImVec2, align 4
  %lhs.addr = alloca ptr, align 8
  %rhs.addr = alloca float, align 4
  store ptr %lhs, ptr %lhs.addr, align 8
  store float %rhs, ptr %rhs.addr, align 4
  %0 = load ptr, ptr %lhs.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %0, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %2 = load float, ptr %rhs.addr, align 4
  %mul = fmul float %1, %2
  %3 = load ptr, ptr %lhs.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %3, i32 0, i32 1
  %4 = load float, ptr %y, align 4
  %5 = load float, ptr %rhs.addr, align 4
  %mul1 = fmul float %4, %5
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %retval, float noundef %mul, float noundef %mul1)
  %6 = load <2 x float>, ptr %retval, align 4
  ret <2 x float> %6
}

; Function Attrs: mustprogress uwtable
define internal <2 x float> @_ZmiRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %lhs, ptr noundef nonnull align 4 dereferenceable(8) %rhs) #0 {
entry:
  %retval = alloca %struct.ImVec2, align 4
  %lhs.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %lhs, ptr %lhs.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %0 = load ptr, ptr %lhs.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %0, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %2 = load ptr, ptr %rhs.addr, align 8
  %x1 = getelementptr inbounds %struct.ImVec2, ptr %2, i32 0, i32 0
  %3 = load float, ptr %x1, align 4
  %sub = fsub float %1, %3
  %4 = load ptr, ptr %lhs.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %4, i32 0, i32 1
  %5 = load float, ptr %y, align 4
  %6 = load ptr, ptr %rhs.addr, align 8
  %y2 = getelementptr inbounds %struct.ImVec2, ptr %6, i32 0, i32 1
  %7 = load float, ptr %y2, align 4
  %sub3 = fsub float %5, %7
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %retval, float noundef %sub, float noundef %sub3)
  %8 = load <2 x float>, ptr %retval, align 4
  ret <2 x float> %8
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList19AddConvexPolyFilledEPK6ImVec2ij(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef %points, i32 noundef %points_count, i32 noundef %col) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %points.addr = alloca ptr, align 8
  %points_count.addr = alloca i32, align 4
  %col.addr = alloca i32, align 4
  %uv = alloca %struct.ImVec2, align 4
  %AA_SIZE = alloca float, align 4
  %col_trans = alloca i32, align 4
  %idx_count = alloca i32, align 4
  %vtx_count = alloca i32, align 4
  %vtx_inner_idx = alloca i32, align 4
  %vtx_outer_idx = alloca i32, align 4
  %i = alloca i32, align 4
  %temp_normals = alloca ptr, align 8
  %i0 = alloca i32, align 4
  %i1 = alloca i32, align 4
  %p0 = alloca ptr, align 8
  %p1 = alloca ptr, align 8
  %dx = alloca float, align 4
  %dy = alloca float, align 4
  %d2 = alloca float, align 4
  %inv_len = alloca float, align 4
  %i052 = alloca i32, align 4
  %i154 = alloca i32, align 4
  %n0 = alloca ptr, align 8
  %n1 = alloca ptr, align 8
  %dm_x = alloca float, align 4
  %dm_y = alloca float, align 4
  %d270 = alloca float, align 4
  %inv_len2 = alloca float, align 4
  %idx_count168 = alloca i32, align 4
  %vtx_count171 = alloca i32, align 4
  %i172 = alloca i32, align 4
  %i191 = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %points, ptr %points.addr, align 8
  store i32 %points_count, ptr %points_count.addr, align 4
  store i32 %col, ptr %col.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %points_count.addr, align 4
  %cmp = icmp slt i32 %0, 3
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %col.addr, align 4
  %and = and i32 %1, -16777216
  %cmp2 = icmp eq i32 %and, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %if.end219

if.end:                                           ; preds = %lor.lhs.false
  %_Data = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  %2 = load ptr, ptr %_Data, align 8
  %TexUvWhitePixel = getelementptr inbounds %struct.ImDrawListSharedData, ptr %2, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv, ptr align 8 %TexUvWhitePixel, i64 8, i1 false)
  %Flags = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 3
  %3 = load i32, ptr %Flags, align 8
  %and3 = and i32 %3, 4
  %tobool = icmp ne i32 %and3, 0
  br i1 %tobool, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  %_FringeScale = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 14
  %4 = load float, ptr %_FringeScale, align 8
  store float %4, ptr %AA_SIZE, align 4
  %5 = load i32, ptr %col.addr, align 4
  %and5 = and i32 %5, 16777215
  store i32 %and5, ptr %col_trans, align 4
  %6 = load i32, ptr %points_count.addr, align 4
  %sub = sub nsw i32 %6, 2
  %mul = mul nsw i32 %sub, 3
  %7 = load i32, ptr %points_count.addr, align 4
  %mul6 = mul nsw i32 %7, 6
  %add = add nsw i32 %mul, %mul6
  store i32 %add, ptr %idx_count, align 4
  %8 = load i32, ptr %points_count.addr, align 4
  %mul7 = mul nsw i32 %8, 2
  store i32 %mul7, ptr %vtx_count, align 4
  %9 = load i32, ptr %idx_count, align 4
  %10 = load i32, ptr %vtx_count, align 4
  call void @_ZN10ImDrawList11PrimReserveEii(ptr noundef nonnull align 8 dereferenceable(196) %this1, i32 noundef %9, i32 noundef %10)
  %_VtxCurrentIdx = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %11 = load i32, ptr %_VtxCurrentIdx, align 4
  store i32 %11, ptr %vtx_inner_idx, align 4
  %_VtxCurrentIdx8 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %12 = load i32, ptr %_VtxCurrentIdx8, align 4
  %add9 = add i32 %12, 1
  store i32 %add9, ptr %vtx_outer_idx, align 4
  store i32 2, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then4
  %13 = load i32, ptr %i, align 4
  %14 = load i32, ptr %points_count.addr, align 4
  %cmp10 = icmp slt i32 %13, %14
  br i1 %cmp10, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %15 = load i32, ptr %vtx_inner_idx, align 4
  %conv = trunc i32 %15 to i16
  %_IdxWritePtr = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %16 = load ptr, ptr %_IdxWritePtr, align 8
  %arrayidx = getelementptr inbounds i16, ptr %16, i64 0
  store i16 %conv, ptr %arrayidx, align 2
  %17 = load i32, ptr %vtx_inner_idx, align 4
  %18 = load i32, ptr %i, align 4
  %sub11 = sub nsw i32 %18, 1
  %shl = shl i32 %sub11, 1
  %add12 = add i32 %17, %shl
  %conv13 = trunc i32 %add12 to i16
  %_IdxWritePtr14 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %19 = load ptr, ptr %_IdxWritePtr14, align 8
  %arrayidx15 = getelementptr inbounds i16, ptr %19, i64 1
  store i16 %conv13, ptr %arrayidx15, align 2
  %20 = load i32, ptr %vtx_inner_idx, align 4
  %21 = load i32, ptr %i, align 4
  %shl16 = shl i32 %21, 1
  %add17 = add i32 %20, %shl16
  %conv18 = trunc i32 %add17 to i16
  %_IdxWritePtr19 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %22 = load ptr, ptr %_IdxWritePtr19, align 8
  %arrayidx20 = getelementptr inbounds i16, ptr %22, i64 2
  store i16 %conv18, ptr %arrayidx20, align 2
  %_IdxWritePtr21 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %23 = load ptr, ptr %_IdxWritePtr21, align 8
  %add.ptr = getelementptr inbounds i16, ptr %23, i64 3
  store ptr %add.ptr, ptr %_IdxWritePtr21, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %24 = load i32, ptr %i, align 4
  %inc = add nsw i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !19

for.end:                                          ; preds = %for.cond
  %_Data22 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  %25 = load ptr, ptr %_Data22, align 8
  %TempBuffer = getelementptr inbounds %struct.ImDrawListSharedData, ptr %25, i32 0, i32 7
  %26 = load i32, ptr %points_count.addr, align 4
  call void @_ZN8ImVectorI6ImVec2E15reserve_discardEi(ptr noundef nonnull align 8 dereferenceable(16) %TempBuffer, i32 noundef %26)
  %_Data23 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  %27 = load ptr, ptr %_Data23, align 8
  %TempBuffer24 = getelementptr inbounds %struct.ImDrawListSharedData, ptr %27, i32 0, i32 7
  %Data = getelementptr inbounds %struct.ImVector, ptr %TempBuffer24, i32 0, i32 2
  %28 = load ptr, ptr %Data, align 8
  store ptr %28, ptr %temp_normals, align 8
  %29 = load i32, ptr %points_count.addr, align 4
  %sub25 = sub nsw i32 %29, 1
  store i32 %sub25, ptr %i0, align 4
  store i32 0, ptr %i1, align 4
  br label %for.cond26

for.cond26:                                       ; preds = %for.inc49, %for.end
  %30 = load i32, ptr %i1, align 4
  %31 = load i32, ptr %points_count.addr, align 4
  %cmp27 = icmp slt i32 %30, %31
  br i1 %cmp27, label %for.body28, label %for.end51

for.body28:                                       ; preds = %for.cond26
  %32 = load ptr, ptr %points.addr, align 8
  %33 = load i32, ptr %i0, align 4
  %idxprom = sext i32 %33 to i64
  %arrayidx29 = getelementptr inbounds %struct.ImVec2, ptr %32, i64 %idxprom
  store ptr %arrayidx29, ptr %p0, align 8
  %34 = load ptr, ptr %points.addr, align 8
  %35 = load i32, ptr %i1, align 4
  %idxprom30 = sext i32 %35 to i64
  %arrayidx31 = getelementptr inbounds %struct.ImVec2, ptr %34, i64 %idxprom30
  store ptr %arrayidx31, ptr %p1, align 8
  %36 = load ptr, ptr %p1, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %36, i32 0, i32 0
  %37 = load float, ptr %x, align 4
  %38 = load ptr, ptr %p0, align 8
  %x32 = getelementptr inbounds %struct.ImVec2, ptr %38, i32 0, i32 0
  %39 = load float, ptr %x32, align 4
  %sub33 = fsub float %37, %39
  store float %sub33, ptr %dx, align 4
  %40 = load ptr, ptr %p1, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %40, i32 0, i32 1
  %41 = load float, ptr %y, align 4
  %42 = load ptr, ptr %p0, align 8
  %y34 = getelementptr inbounds %struct.ImVec2, ptr %42, i32 0, i32 1
  %43 = load float, ptr %y34, align 4
  %sub35 = fsub float %41, %43
  store float %sub35, ptr %dy, align 4
  %44 = load float, ptr %dx, align 4
  %45 = load float, ptr %dx, align 4
  %46 = load float, ptr %dy, align 4
  %47 = load float, ptr %dy, align 4
  %mul37 = fmul float %46, %47
  %48 = call float @llvm.fmuladd.f32(float %44, float %45, float %mul37)
  store float %48, ptr %d2, align 4
  %49 = load float, ptr %d2, align 4
  %cmp38 = fcmp ogt float %49, 0.000000e+00
  br i1 %cmp38, label %if.then39, label %if.end42

if.then39:                                        ; preds = %for.body28
  %50 = load float, ptr %d2, align 4
  %call = call noundef float @_ZL7ImRsqrtf(float noundef %50)
  store float %call, ptr %inv_len, align 4
  %51 = load float, ptr %inv_len, align 4
  %52 = load float, ptr %dx, align 4
  %mul40 = fmul float %52, %51
  store float %mul40, ptr %dx, align 4
  %53 = load float, ptr %inv_len, align 4
  %54 = load float, ptr %dy, align 4
  %mul41 = fmul float %54, %53
  store float %mul41, ptr %dy, align 4
  br label %if.end42

if.end42:                                         ; preds = %if.then39, %for.body28
  %55 = load float, ptr %dy, align 4
  %56 = load ptr, ptr %temp_normals, align 8
  %57 = load i32, ptr %i0, align 4
  %idxprom43 = sext i32 %57 to i64
  %arrayidx44 = getelementptr inbounds %struct.ImVec2, ptr %56, i64 %idxprom43
  %x45 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx44, i32 0, i32 0
  store float %55, ptr %x45, align 4
  %58 = load float, ptr %dx, align 4
  %fneg = fneg float %58
  %59 = load ptr, ptr %temp_normals, align 8
  %60 = load i32, ptr %i0, align 4
  %idxprom46 = sext i32 %60 to i64
  %arrayidx47 = getelementptr inbounds %struct.ImVec2, ptr %59, i64 %idxprom46
  %y48 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx47, i32 0, i32 1
  store float %fneg, ptr %y48, align 4
  br label %for.inc49

for.inc49:                                        ; preds = %if.end42
  %61 = load i32, ptr %i1, align 4
  %inc50 = add nsw i32 %61, 1
  store i32 %inc50, ptr %i1, align 4
  store i32 %61, ptr %i0, align 4
  br label %for.cond26, !llvm.loop !20

for.end51:                                        ; preds = %for.cond26
  %62 = load i32, ptr %points_count.addr, align 4
  %sub53 = sub nsw i32 %62, 1
  store i32 %sub53, ptr %i052, align 4
  store i32 0, ptr %i154, align 4
  br label %for.cond55

for.cond55:                                       ; preds = %for.inc161, %for.end51
  %63 = load i32, ptr %i154, align 4
  %64 = load i32, ptr %points_count.addr, align 4
  %cmp56 = icmp slt i32 %63, %64
  br i1 %cmp56, label %for.body57, label %for.end163

for.body57:                                       ; preds = %for.cond55
  %65 = load ptr, ptr %temp_normals, align 8
  %66 = load i32, ptr %i052, align 4
  %idxprom58 = sext i32 %66 to i64
  %arrayidx59 = getelementptr inbounds %struct.ImVec2, ptr %65, i64 %idxprom58
  store ptr %arrayidx59, ptr %n0, align 8
  %67 = load ptr, ptr %temp_normals, align 8
  %68 = load i32, ptr %i154, align 4
  %idxprom60 = sext i32 %68 to i64
  %arrayidx61 = getelementptr inbounds %struct.ImVec2, ptr %67, i64 %idxprom60
  store ptr %arrayidx61, ptr %n1, align 8
  %69 = load ptr, ptr %n0, align 8
  %x62 = getelementptr inbounds %struct.ImVec2, ptr %69, i32 0, i32 0
  %70 = load float, ptr %x62, align 4
  %71 = load ptr, ptr %n1, align 8
  %x63 = getelementptr inbounds %struct.ImVec2, ptr %71, i32 0, i32 0
  %72 = load float, ptr %x63, align 4
  %add64 = fadd float %70, %72
  %mul65 = fmul float %add64, 5.000000e-01
  store float %mul65, ptr %dm_x, align 4
  %73 = load ptr, ptr %n0, align 8
  %y66 = getelementptr inbounds %struct.ImVec2, ptr %73, i32 0, i32 1
  %74 = load float, ptr %y66, align 4
  %75 = load ptr, ptr %n1, align 8
  %y67 = getelementptr inbounds %struct.ImVec2, ptr %75, i32 0, i32 1
  %76 = load float, ptr %y67, align 4
  %add68 = fadd float %74, %76
  %mul69 = fmul float %add68, 5.000000e-01
  store float %mul69, ptr %dm_y, align 4
  %77 = load float, ptr %dm_x, align 4
  %78 = load float, ptr %dm_x, align 4
  %79 = load float, ptr %dm_y, align 4
  %80 = load float, ptr %dm_y, align 4
  %mul72 = fmul float %79, %80
  %81 = call float @llvm.fmuladd.f32(float %77, float %78, float %mul72)
  store float %81, ptr %d270, align 4
  %82 = load float, ptr %d270, align 4
  %cmp73 = fcmp ogt float %82, 0x3EB0C6F7A0000000
  br i1 %cmp73, label %if.then74, label %if.end80

if.then74:                                        ; preds = %for.body57
  %83 = load float, ptr %d270, align 4
  %div = fdiv float 1.000000e+00, %83
  store float %div, ptr %inv_len2, align 4
  %84 = load float, ptr %inv_len2, align 4
  %cmp75 = fcmp ogt float %84, 1.000000e+02
  br i1 %cmp75, label %if.then76, label %if.end77

if.then76:                                        ; preds = %if.then74
  store float 1.000000e+02, ptr %inv_len2, align 4
  br label %if.end77

if.end77:                                         ; preds = %if.then76, %if.then74
  %85 = load float, ptr %inv_len2, align 4
  %86 = load float, ptr %dm_x, align 4
  %mul78 = fmul float %86, %85
  store float %mul78, ptr %dm_x, align 4
  %87 = load float, ptr %inv_len2, align 4
  %88 = load float, ptr %dm_y, align 4
  %mul79 = fmul float %88, %87
  store float %mul79, ptr %dm_y, align 4
  br label %if.end80

if.end80:                                         ; preds = %if.end77, %for.body57
  %89 = load float, ptr %AA_SIZE, align 4
  %mul81 = fmul float %89, 5.000000e-01
  %90 = load float, ptr %dm_x, align 4
  %mul82 = fmul float %90, %mul81
  store float %mul82, ptr %dm_x, align 4
  %91 = load float, ptr %AA_SIZE, align 4
  %mul83 = fmul float %91, 5.000000e-01
  %92 = load float, ptr %dm_y, align 4
  %mul84 = fmul float %92, %mul83
  store float %mul84, ptr %dm_y, align 4
  %93 = load ptr, ptr %points.addr, align 8
  %94 = load i32, ptr %i154, align 4
  %idxprom85 = sext i32 %94 to i64
  %arrayidx86 = getelementptr inbounds %struct.ImVec2, ptr %93, i64 %idxprom85
  %x87 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx86, i32 0, i32 0
  %95 = load float, ptr %x87, align 4
  %96 = load float, ptr %dm_x, align 4
  %sub88 = fsub float %95, %96
  %_VtxWritePtr = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %97 = load ptr, ptr %_VtxWritePtr, align 8
  %arrayidx89 = getelementptr inbounds %struct.ImDrawVert, ptr %97, i64 0
  %pos = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx89, i32 0, i32 0
  %x90 = getelementptr inbounds %struct.ImVec2, ptr %pos, i32 0, i32 0
  store float %sub88, ptr %x90, align 4
  %98 = load ptr, ptr %points.addr, align 8
  %99 = load i32, ptr %i154, align 4
  %idxprom91 = sext i32 %99 to i64
  %arrayidx92 = getelementptr inbounds %struct.ImVec2, ptr %98, i64 %idxprom91
  %y93 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx92, i32 0, i32 1
  %100 = load float, ptr %y93, align 4
  %101 = load float, ptr %dm_y, align 4
  %sub94 = fsub float %100, %101
  %_VtxWritePtr95 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %102 = load ptr, ptr %_VtxWritePtr95, align 8
  %arrayidx96 = getelementptr inbounds %struct.ImDrawVert, ptr %102, i64 0
  %pos97 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx96, i32 0, i32 0
  %y98 = getelementptr inbounds %struct.ImVec2, ptr %pos97, i32 0, i32 1
  store float %sub94, ptr %y98, align 4
  %_VtxWritePtr99 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %103 = load ptr, ptr %_VtxWritePtr99, align 8
  %arrayidx100 = getelementptr inbounds %struct.ImDrawVert, ptr %103, i64 0
  %uv101 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx100, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv101, ptr align 4 %uv, i64 8, i1 false)
  %104 = load i32, ptr %col.addr, align 4
  %_VtxWritePtr102 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %105 = load ptr, ptr %_VtxWritePtr102, align 8
  %arrayidx103 = getelementptr inbounds %struct.ImDrawVert, ptr %105, i64 0
  %col104 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx103, i32 0, i32 2
  store i32 %104, ptr %col104, align 4
  %106 = load ptr, ptr %points.addr, align 8
  %107 = load i32, ptr %i154, align 4
  %idxprom105 = sext i32 %107 to i64
  %arrayidx106 = getelementptr inbounds %struct.ImVec2, ptr %106, i64 %idxprom105
  %x107 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx106, i32 0, i32 0
  %108 = load float, ptr %x107, align 4
  %109 = load float, ptr %dm_x, align 4
  %add108 = fadd float %108, %109
  %_VtxWritePtr109 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %110 = load ptr, ptr %_VtxWritePtr109, align 8
  %arrayidx110 = getelementptr inbounds %struct.ImDrawVert, ptr %110, i64 1
  %pos111 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx110, i32 0, i32 0
  %x112 = getelementptr inbounds %struct.ImVec2, ptr %pos111, i32 0, i32 0
  store float %add108, ptr %x112, align 4
  %111 = load ptr, ptr %points.addr, align 8
  %112 = load i32, ptr %i154, align 4
  %idxprom113 = sext i32 %112 to i64
  %arrayidx114 = getelementptr inbounds %struct.ImVec2, ptr %111, i64 %idxprom113
  %y115 = getelementptr inbounds %struct.ImVec2, ptr %arrayidx114, i32 0, i32 1
  %113 = load float, ptr %y115, align 4
  %114 = load float, ptr %dm_y, align 4
  %add116 = fadd float %113, %114
  %_VtxWritePtr117 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %115 = load ptr, ptr %_VtxWritePtr117, align 8
  %arrayidx118 = getelementptr inbounds %struct.ImDrawVert, ptr %115, i64 1
  %pos119 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx118, i32 0, i32 0
  %y120 = getelementptr inbounds %struct.ImVec2, ptr %pos119, i32 0, i32 1
  store float %add116, ptr %y120, align 4
  %_VtxWritePtr121 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %116 = load ptr, ptr %_VtxWritePtr121, align 8
  %arrayidx122 = getelementptr inbounds %struct.ImDrawVert, ptr %116, i64 1
  %uv123 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx122, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv123, ptr align 4 %uv, i64 8, i1 false)
  %117 = load i32, ptr %col_trans, align 4
  %_VtxWritePtr124 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %118 = load ptr, ptr %_VtxWritePtr124, align 8
  %arrayidx125 = getelementptr inbounds %struct.ImDrawVert, ptr %118, i64 1
  %col126 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx125, i32 0, i32 2
  store i32 %117, ptr %col126, align 4
  %_VtxWritePtr127 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %119 = load ptr, ptr %_VtxWritePtr127, align 8
  %add.ptr128 = getelementptr inbounds %struct.ImDrawVert, ptr %119, i64 2
  store ptr %add.ptr128, ptr %_VtxWritePtr127, align 8
  %120 = load i32, ptr %vtx_inner_idx, align 4
  %121 = load i32, ptr %i154, align 4
  %shl129 = shl i32 %121, 1
  %add130 = add i32 %120, %shl129
  %conv131 = trunc i32 %add130 to i16
  %_IdxWritePtr132 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %122 = load ptr, ptr %_IdxWritePtr132, align 8
  %arrayidx133 = getelementptr inbounds i16, ptr %122, i64 0
  store i16 %conv131, ptr %arrayidx133, align 2
  %123 = load i32, ptr %vtx_inner_idx, align 4
  %124 = load i32, ptr %i052, align 4
  %shl134 = shl i32 %124, 1
  %add135 = add i32 %123, %shl134
  %conv136 = trunc i32 %add135 to i16
  %_IdxWritePtr137 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %125 = load ptr, ptr %_IdxWritePtr137, align 8
  %arrayidx138 = getelementptr inbounds i16, ptr %125, i64 1
  store i16 %conv136, ptr %arrayidx138, align 2
  %126 = load i32, ptr %vtx_outer_idx, align 4
  %127 = load i32, ptr %i052, align 4
  %shl139 = shl i32 %127, 1
  %add140 = add i32 %126, %shl139
  %conv141 = trunc i32 %add140 to i16
  %_IdxWritePtr142 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %128 = load ptr, ptr %_IdxWritePtr142, align 8
  %arrayidx143 = getelementptr inbounds i16, ptr %128, i64 2
  store i16 %conv141, ptr %arrayidx143, align 2
  %129 = load i32, ptr %vtx_outer_idx, align 4
  %130 = load i32, ptr %i052, align 4
  %shl144 = shl i32 %130, 1
  %add145 = add i32 %129, %shl144
  %conv146 = trunc i32 %add145 to i16
  %_IdxWritePtr147 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %131 = load ptr, ptr %_IdxWritePtr147, align 8
  %arrayidx148 = getelementptr inbounds i16, ptr %131, i64 3
  store i16 %conv146, ptr %arrayidx148, align 2
  %132 = load i32, ptr %vtx_outer_idx, align 4
  %133 = load i32, ptr %i154, align 4
  %shl149 = shl i32 %133, 1
  %add150 = add i32 %132, %shl149
  %conv151 = trunc i32 %add150 to i16
  %_IdxWritePtr152 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %134 = load ptr, ptr %_IdxWritePtr152, align 8
  %arrayidx153 = getelementptr inbounds i16, ptr %134, i64 4
  store i16 %conv151, ptr %arrayidx153, align 2
  %135 = load i32, ptr %vtx_inner_idx, align 4
  %136 = load i32, ptr %i154, align 4
  %shl154 = shl i32 %136, 1
  %add155 = add i32 %135, %shl154
  %conv156 = trunc i32 %add155 to i16
  %_IdxWritePtr157 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %137 = load ptr, ptr %_IdxWritePtr157, align 8
  %arrayidx158 = getelementptr inbounds i16, ptr %137, i64 5
  store i16 %conv156, ptr %arrayidx158, align 2
  %_IdxWritePtr159 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %138 = load ptr, ptr %_IdxWritePtr159, align 8
  %add.ptr160 = getelementptr inbounds i16, ptr %138, i64 6
  store ptr %add.ptr160, ptr %_IdxWritePtr159, align 8
  br label %for.inc161

for.inc161:                                       ; preds = %if.end80
  %139 = load i32, ptr %i154, align 4
  %inc162 = add nsw i32 %139, 1
  store i32 %inc162, ptr %i154, align 4
  store i32 %139, ptr %i052, align 4
  br label %for.cond55, !llvm.loop !21

for.end163:                                       ; preds = %for.cond55
  %140 = load i32, ptr %vtx_count, align 4
  %conv164 = trunc i32 %140 to i16
  %conv165 = zext i16 %conv164 to i32
  %_VtxCurrentIdx166 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %141 = load i32, ptr %_VtxCurrentIdx166, align 4
  %add167 = add i32 %141, %conv165
  store i32 %add167, ptr %_VtxCurrentIdx166, align 4
  br label %if.end219

if.else:                                          ; preds = %if.end
  %142 = load i32, ptr %points_count.addr, align 4
  %sub169 = sub nsw i32 %142, 2
  %mul170 = mul nsw i32 %sub169, 3
  store i32 %mul170, ptr %idx_count168, align 4
  %143 = load i32, ptr %points_count.addr, align 4
  store i32 %143, ptr %vtx_count171, align 4
  %144 = load i32, ptr %idx_count168, align 4
  %145 = load i32, ptr %vtx_count171, align 4
  call void @_ZN10ImDrawList11PrimReserveEii(ptr noundef nonnull align 8 dereferenceable(196) %this1, i32 noundef %144, i32 noundef %145)
  store i32 0, ptr %i172, align 4
  br label %for.cond173

for.cond173:                                      ; preds = %for.inc188, %if.else
  %146 = load i32, ptr %i172, align 4
  %147 = load i32, ptr %vtx_count171, align 4
  %cmp174 = icmp slt i32 %146, %147
  br i1 %cmp174, label %for.body175, label %for.end190

for.body175:                                      ; preds = %for.cond173
  %148 = load ptr, ptr %points.addr, align 8
  %149 = load i32, ptr %i172, align 4
  %idxprom176 = sext i32 %149 to i64
  %arrayidx177 = getelementptr inbounds %struct.ImVec2, ptr %148, i64 %idxprom176
  %_VtxWritePtr178 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %150 = load ptr, ptr %_VtxWritePtr178, align 8
  %arrayidx179 = getelementptr inbounds %struct.ImDrawVert, ptr %150, i64 0
  %pos180 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx179, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %pos180, ptr align 4 %arrayidx177, i64 8, i1 false)
  %_VtxWritePtr181 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %151 = load ptr, ptr %_VtxWritePtr181, align 8
  %arrayidx182 = getelementptr inbounds %struct.ImDrawVert, ptr %151, i64 0
  %uv183 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx182, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv183, ptr align 4 %uv, i64 8, i1 false)
  %152 = load i32, ptr %col.addr, align 4
  %_VtxWritePtr184 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %153 = load ptr, ptr %_VtxWritePtr184, align 8
  %arrayidx185 = getelementptr inbounds %struct.ImDrawVert, ptr %153, i64 0
  %col186 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx185, i32 0, i32 2
  store i32 %152, ptr %col186, align 4
  %_VtxWritePtr187 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %154 = load ptr, ptr %_VtxWritePtr187, align 8
  %incdec.ptr = getelementptr inbounds %struct.ImDrawVert, ptr %154, i32 1
  store ptr %incdec.ptr, ptr %_VtxWritePtr187, align 8
  br label %for.inc188

for.inc188:                                       ; preds = %for.body175
  %155 = load i32, ptr %i172, align 4
  %inc189 = add nsw i32 %155, 1
  store i32 %inc189, ptr %i172, align 4
  br label %for.cond173, !llvm.loop !22

for.end190:                                       ; preds = %for.cond173
  store i32 2, ptr %i191, align 4
  br label %for.cond192

for.cond192:                                      ; preds = %for.inc212, %for.end190
  %156 = load i32, ptr %i191, align 4
  %157 = load i32, ptr %points_count.addr, align 4
  %cmp193 = icmp slt i32 %156, %157
  br i1 %cmp193, label %for.body194, label %for.end214

for.body194:                                      ; preds = %for.cond192
  %_VtxCurrentIdx195 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %158 = load i32, ptr %_VtxCurrentIdx195, align 4
  %conv196 = trunc i32 %158 to i16
  %_IdxWritePtr197 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %159 = load ptr, ptr %_IdxWritePtr197, align 8
  %arrayidx198 = getelementptr inbounds i16, ptr %159, i64 0
  store i16 %conv196, ptr %arrayidx198, align 2
  %_VtxCurrentIdx199 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %160 = load i32, ptr %_VtxCurrentIdx199, align 4
  %161 = load i32, ptr %i191, align 4
  %add200 = add i32 %160, %161
  %sub201 = sub i32 %add200, 1
  %conv202 = trunc i32 %sub201 to i16
  %_IdxWritePtr203 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %162 = load ptr, ptr %_IdxWritePtr203, align 8
  %arrayidx204 = getelementptr inbounds i16, ptr %162, i64 1
  store i16 %conv202, ptr %arrayidx204, align 2
  %_VtxCurrentIdx205 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %163 = load i32, ptr %_VtxCurrentIdx205, align 4
  %164 = load i32, ptr %i191, align 4
  %add206 = add i32 %163, %164
  %conv207 = trunc i32 %add206 to i16
  %_IdxWritePtr208 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %165 = load ptr, ptr %_IdxWritePtr208, align 8
  %arrayidx209 = getelementptr inbounds i16, ptr %165, i64 2
  store i16 %conv207, ptr %arrayidx209, align 2
  %_IdxWritePtr210 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %166 = load ptr, ptr %_IdxWritePtr210, align 8
  %add.ptr211 = getelementptr inbounds i16, ptr %166, i64 3
  store ptr %add.ptr211, ptr %_IdxWritePtr210, align 8
  br label %for.inc212

for.inc212:                                       ; preds = %for.body194
  %167 = load i32, ptr %i191, align 4
  %inc213 = add nsw i32 %167, 1
  store i32 %inc213, ptr %i191, align 4
  br label %for.cond192, !llvm.loop !23

for.end214:                                       ; preds = %for.cond192
  %168 = load i32, ptr %vtx_count171, align 4
  %conv215 = trunc i32 %168 to i16
  %conv216 = zext i16 %conv215 to i32
  %_VtxCurrentIdx217 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %169 = load i32, ptr %_VtxCurrentIdx217, align 4
  %add218 = add i32 %169, %conv216
  store i32 %add218, ptr %_VtxCurrentIdx217, align 4
  br label %if.end219

if.end219:                                        ; preds = %for.end214, %for.end163, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList16_PathArcToFastExERK6ImVec2fiii(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %center, float noundef %radius, i32 noundef %a_min_sample, i32 noundef %a_max_sample, i32 noundef %a_step) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %center.addr = alloca ptr, align 8
  %radius.addr = alloca float, align 4
  %a_min_sample.addr = alloca i32, align 4
  %a_max_sample.addr = alloca i32, align 4
  %a_step.addr = alloca i32, align 4
  %sample_range = alloca i32, align 4
  %a_next_step = alloca i32, align 4
  %samples = alloca i32, align 4
  %extra_max_sample = alloca i8, align 1
  %overstep = alloca i32, align 4
  %out_ptr = alloca ptr, align 8
  %sample_index = alloca i32, align 4
  %a = alloca i32, align 4
  %s = alloca %struct.ImVec2, align 4
  %a50 = alloca i32, align 4
  %s58 = alloca %struct.ImVec2, align 4
  %normalized_max_sample = alloca i32, align 4
  %s81 = alloca %struct.ImVec2, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %center, ptr %center.addr, align 8
  store float %radius, ptr %radius.addr, align 4
  store i32 %a_min_sample, ptr %a_min_sample.addr, align 4
  store i32 %a_max_sample, ptr %a_max_sample.addr, align 4
  store i32 %a_step, ptr %a_step.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load float, ptr %radius.addr, align 4
  %cmp = fcmp olt float %0, 5.000000e-01
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %_Path = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %1 = load ptr, ptr %center.addr, align 8
  call void @_ZN8ImVectorI6ImVec2E9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %_Path, ptr noundef nonnull align 4 dereferenceable(8) %1)
  br label %if.end93

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %a_step.addr, align 4
  %cmp2 = icmp sle i32 %2, 0
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %3 = load float, ptr %radius.addr, align 4
  %call = call noundef i32 @_ZNK10ImDrawList27_CalcCircleAutoSegmentCountEf(ptr noundef nonnull align 8 dereferenceable(196) %this1, float noundef %3)
  %div = sdiv i32 48, %call
  store i32 %div, ptr %a_step.addr, align 4
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %4 = load i32, ptr %a_step.addr, align 4
  %call5 = call noundef i32 @_ZL7ImClampIiET_S0_S0_S0_(i32 noundef %4, i32 noundef 1, i32 noundef 12)
  store i32 %call5, ptr %a_step.addr, align 4
  %5 = load i32, ptr %a_max_sample.addr, align 4
  %6 = load i32, ptr %a_min_sample.addr, align 4
  %sub = sub nsw i32 %5, %6
  %call6 = call noundef i32 @_ZL5ImAbsi(i32 noundef %sub)
  store i32 %call6, ptr %sample_range, align 4
  %7 = load i32, ptr %a_step.addr, align 4
  store i32 %7, ptr %a_next_step, align 4
  %8 = load i32, ptr %sample_range, align 4
  %add = add nsw i32 %8, 1
  store i32 %add, ptr %samples, align 4
  store i8 0, ptr %extra_max_sample, align 1
  %9 = load i32, ptr %a_step.addr, align 4
  %cmp7 = icmp sgt i32 %9, 1
  br i1 %cmp7, label %if.then8, label %if.end20

if.then8:                                         ; preds = %if.end4
  %10 = load i32, ptr %sample_range, align 4
  %11 = load i32, ptr %a_step.addr, align 4
  %div9 = sdiv i32 %10, %11
  %add10 = add nsw i32 %div9, 1
  store i32 %add10, ptr %samples, align 4
  %12 = load i32, ptr %sample_range, align 4
  %13 = load i32, ptr %a_step.addr, align 4
  %rem = srem i32 %12, %13
  store i32 %rem, ptr %overstep, align 4
  %14 = load i32, ptr %overstep, align 4
  %cmp11 = icmp sgt i32 %14, 0
  br i1 %cmp11, label %if.then12, label %if.end19

if.then12:                                        ; preds = %if.then8
  store i8 1, ptr %extra_max_sample, align 1
  %15 = load i32, ptr %samples, align 4
  %inc = add nsw i32 %15, 1
  store i32 %inc, ptr %samples, align 4
  %16 = load i32, ptr %sample_range, align 4
  %cmp13 = icmp sgt i32 %16, 0
  br i1 %cmp13, label %if.then14, label %if.end18

if.then14:                                        ; preds = %if.then12
  %17 = load i32, ptr %a_step.addr, align 4
  %18 = load i32, ptr %overstep, align 4
  %sub15 = sub nsw i32 %17, %18
  %div16 = sdiv i32 %sub15, 2
  %19 = load i32, ptr %a_step.addr, align 4
  %sub17 = sub nsw i32 %19, %div16
  store i32 %sub17, ptr %a_step.addr, align 4
  br label %if.end18

if.end18:                                         ; preds = %if.then14, %if.then12
  br label %if.end19

if.end19:                                         ; preds = %if.end18, %if.then8
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.end4
  %_Path21 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %_Path22 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %Size = getelementptr inbounds %struct.ImVector, ptr %_Path22, i32 0, i32 0
  %20 = load i32, ptr %Size, align 8
  %21 = load i32, ptr %samples, align 4
  %add23 = add nsw i32 %20, %21
  call void @_ZN8ImVectorI6ImVec2E6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %_Path21, i32 noundef %add23)
  %_Path24 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %Data = getelementptr inbounds %struct.ImVector, ptr %_Path24, i32 0, i32 2
  %22 = load ptr, ptr %Data, align 8
  %_Path25 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %Size26 = getelementptr inbounds %struct.ImVector, ptr %_Path25, i32 0, i32 0
  %23 = load i32, ptr %Size26, align 8
  %24 = load i32, ptr %samples, align 4
  %sub27 = sub nsw i32 %23, %24
  %idx.ext = sext i32 %sub27 to i64
  %add.ptr = getelementptr inbounds %struct.ImVec2, ptr %22, i64 %idx.ext
  store ptr %add.ptr, ptr %out_ptr, align 8
  %25 = load i32, ptr %a_min_sample.addr, align 4
  store i32 %25, ptr %sample_index, align 4
  %26 = load i32, ptr %sample_index, align 4
  %cmp28 = icmp slt i32 %26, 0
  br i1 %cmp28, label %if.then30, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end20
  %27 = load i32, ptr %sample_index, align 4
  %cmp29 = icmp sge i32 %27, 48
  br i1 %cmp29, label %if.then30, label %if.end36

if.then30:                                        ; preds = %lor.lhs.false, %if.end20
  %28 = load i32, ptr %sample_index, align 4
  %rem31 = srem i32 %28, 48
  store i32 %rem31, ptr %sample_index, align 4
  %29 = load i32, ptr %sample_index, align 4
  %cmp32 = icmp slt i32 %29, 0
  br i1 %cmp32, label %if.then33, label %if.end35

if.then33:                                        ; preds = %if.then30
  %30 = load i32, ptr %sample_index, align 4
  %add34 = add nsw i32 %30, 48
  store i32 %add34, ptr %sample_index, align 4
  br label %if.end35

if.end35:                                         ; preds = %if.then33, %if.then30
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %lor.lhs.false
  %31 = load i32, ptr %a_max_sample.addr, align 4
  %32 = load i32, ptr %a_min_sample.addr, align 4
  %cmp37 = icmp sge i32 %31, %32
  br i1 %cmp37, label %if.then38, label %if.else

if.then38:                                        ; preds = %if.end36
  %33 = load i32, ptr %a_min_sample.addr, align 4
  store i32 %33, ptr %a, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then38
  %34 = load i32, ptr %a, align 4
  %35 = load i32, ptr %a_max_sample.addr, align 4
  %cmp39 = icmp sle i32 %34, %35
  br i1 %cmp39, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %36 = load i32, ptr %sample_index, align 4
  %cmp40 = icmp sge i32 %36, 48
  br i1 %cmp40, label %if.then41, label %if.end43

if.then41:                                        ; preds = %for.body
  %37 = load i32, ptr %sample_index, align 4
  %sub42 = sub nsw i32 %37, 48
  store i32 %sub42, ptr %sample_index, align 4
  br label %if.end43

if.end43:                                         ; preds = %if.then41, %for.body
  %_Data = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  %38 = load ptr, ptr %_Data, align 8
  %ArcFastVtx = getelementptr inbounds %struct.ImDrawListSharedData, ptr %38, i32 0, i32 8
  %39 = load i32, ptr %sample_index, align 4
  %idxprom = sext i32 %39 to i64
  %arrayidx = getelementptr inbounds [48 x %struct.ImVec2], ptr %ArcFastVtx, i64 0, i64 %idxprom
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %s, ptr align 8 %arrayidx, i64 8, i1 false)
  %40 = load ptr, ptr %center.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %40, i32 0, i32 0
  %41 = load float, ptr %x, align 4
  %x44 = getelementptr inbounds %struct.ImVec2, ptr %s, i32 0, i32 0
  %42 = load float, ptr %x44, align 4
  %43 = load float, ptr %radius.addr, align 4
  %44 = call float @llvm.fmuladd.f32(float %42, float %43, float %41)
  %45 = load ptr, ptr %out_ptr, align 8
  %x45 = getelementptr inbounds %struct.ImVec2, ptr %45, i32 0, i32 0
  store float %44, ptr %x45, align 4
  %46 = load ptr, ptr %center.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %46, i32 0, i32 1
  %47 = load float, ptr %y, align 4
  %y46 = getelementptr inbounds %struct.ImVec2, ptr %s, i32 0, i32 1
  %48 = load float, ptr %y46, align 4
  %49 = load float, ptr %radius.addr, align 4
  %50 = call float @llvm.fmuladd.f32(float %48, float %49, float %47)
  %51 = load ptr, ptr %out_ptr, align 8
  %y47 = getelementptr inbounds %struct.ImVec2, ptr %51, i32 0, i32 1
  store float %50, ptr %y47, align 4
  %52 = load ptr, ptr %out_ptr, align 8
  %incdec.ptr = getelementptr inbounds %struct.ImVec2, ptr %52, i32 1
  store ptr %incdec.ptr, ptr %out_ptr, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end43
  %53 = load i32, ptr %a_step.addr, align 4
  %54 = load i32, ptr %a, align 4
  %add48 = add nsw i32 %54, %53
  store i32 %add48, ptr %a, align 4
  %55 = load i32, ptr %a_step.addr, align 4
  %56 = load i32, ptr %sample_index, align 4
  %add49 = add nsw i32 %56, %55
  store i32 %add49, ptr %sample_index, align 4
  %57 = load i32, ptr %a_next_step, align 4
  store i32 %57, ptr %a_step.addr, align 4
  br label %for.cond, !llvm.loop !24

for.end:                                          ; preds = %for.cond
  br label %if.end74

if.else:                                          ; preds = %if.end36
  %58 = load i32, ptr %a_min_sample.addr, align 4
  store i32 %58, ptr %a50, align 4
  br label %for.cond51

for.cond51:                                       ; preds = %for.inc70, %if.else
  %59 = load i32, ptr %a50, align 4
  %60 = load i32, ptr %a_max_sample.addr, align 4
  %cmp52 = icmp sge i32 %59, %60
  br i1 %cmp52, label %for.body53, label %for.end73

for.body53:                                       ; preds = %for.cond51
  %61 = load i32, ptr %sample_index, align 4
  %cmp54 = icmp slt i32 %61, 0
  br i1 %cmp54, label %if.then55, label %if.end57

if.then55:                                        ; preds = %for.body53
  %62 = load i32, ptr %sample_index, align 4
  %add56 = add nsw i32 %62, 48
  store i32 %add56, ptr %sample_index, align 4
  br label %if.end57

if.end57:                                         ; preds = %if.then55, %for.body53
  %_Data59 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  %63 = load ptr, ptr %_Data59, align 8
  %ArcFastVtx60 = getelementptr inbounds %struct.ImDrawListSharedData, ptr %63, i32 0, i32 8
  %64 = load i32, ptr %sample_index, align 4
  %idxprom61 = sext i32 %64 to i64
  %arrayidx62 = getelementptr inbounds [48 x %struct.ImVec2], ptr %ArcFastVtx60, i64 0, i64 %idxprom61
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %s58, ptr align 8 %arrayidx62, i64 8, i1 false)
  %65 = load ptr, ptr %center.addr, align 8
  %x63 = getelementptr inbounds %struct.ImVec2, ptr %65, i32 0, i32 0
  %66 = load float, ptr %x63, align 4
  %x64 = getelementptr inbounds %struct.ImVec2, ptr %s58, i32 0, i32 0
  %67 = load float, ptr %x64, align 4
  %68 = load float, ptr %radius.addr, align 4
  %69 = call float @llvm.fmuladd.f32(float %67, float %68, float %66)
  %70 = load ptr, ptr %out_ptr, align 8
  %x65 = getelementptr inbounds %struct.ImVec2, ptr %70, i32 0, i32 0
  store float %69, ptr %x65, align 4
  %71 = load ptr, ptr %center.addr, align 8
  %y66 = getelementptr inbounds %struct.ImVec2, ptr %71, i32 0, i32 1
  %72 = load float, ptr %y66, align 4
  %y67 = getelementptr inbounds %struct.ImVec2, ptr %s58, i32 0, i32 1
  %73 = load float, ptr %y67, align 4
  %74 = load float, ptr %radius.addr, align 4
  %75 = call float @llvm.fmuladd.f32(float %73, float %74, float %72)
  %76 = load ptr, ptr %out_ptr, align 8
  %y68 = getelementptr inbounds %struct.ImVec2, ptr %76, i32 0, i32 1
  store float %75, ptr %y68, align 4
  %77 = load ptr, ptr %out_ptr, align 8
  %incdec.ptr69 = getelementptr inbounds %struct.ImVec2, ptr %77, i32 1
  store ptr %incdec.ptr69, ptr %out_ptr, align 8
  br label %for.inc70

for.inc70:                                        ; preds = %if.end57
  %78 = load i32, ptr %a_step.addr, align 4
  %79 = load i32, ptr %a50, align 4
  %sub71 = sub nsw i32 %79, %78
  store i32 %sub71, ptr %a50, align 4
  %80 = load i32, ptr %a_step.addr, align 4
  %81 = load i32, ptr %sample_index, align 4
  %sub72 = sub nsw i32 %81, %80
  store i32 %sub72, ptr %sample_index, align 4
  %82 = load i32, ptr %a_next_step, align 4
  store i32 %82, ptr %a_step.addr, align 4
  br label %for.cond51, !llvm.loop !25

for.end73:                                        ; preds = %for.cond51
  br label %if.end74

if.end74:                                         ; preds = %for.end73, %for.end
  %83 = load i8, ptr %extra_max_sample, align 1
  %tobool = trunc i8 %83 to i1
  br i1 %tobool, label %if.then75, label %if.end93

if.then75:                                        ; preds = %if.end74
  %84 = load i32, ptr %a_max_sample.addr, align 4
  %rem76 = srem i32 %84, 48
  store i32 %rem76, ptr %normalized_max_sample, align 4
  %85 = load i32, ptr %normalized_max_sample, align 4
  %cmp77 = icmp slt i32 %85, 0
  br i1 %cmp77, label %if.then78, label %if.end80

if.then78:                                        ; preds = %if.then75
  %86 = load i32, ptr %normalized_max_sample, align 4
  %add79 = add nsw i32 %86, 48
  store i32 %add79, ptr %normalized_max_sample, align 4
  br label %if.end80

if.end80:                                         ; preds = %if.then78, %if.then75
  %_Data82 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  %87 = load ptr, ptr %_Data82, align 8
  %ArcFastVtx83 = getelementptr inbounds %struct.ImDrawListSharedData, ptr %87, i32 0, i32 8
  %88 = load i32, ptr %normalized_max_sample, align 4
  %idxprom84 = sext i32 %88 to i64
  %arrayidx85 = getelementptr inbounds [48 x %struct.ImVec2], ptr %ArcFastVtx83, i64 0, i64 %idxprom84
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %s81, ptr align 8 %arrayidx85, i64 8, i1 false)
  %89 = load ptr, ptr %center.addr, align 8
  %x86 = getelementptr inbounds %struct.ImVec2, ptr %89, i32 0, i32 0
  %90 = load float, ptr %x86, align 4
  %x87 = getelementptr inbounds %struct.ImVec2, ptr %s81, i32 0, i32 0
  %91 = load float, ptr %x87, align 4
  %92 = load float, ptr %radius.addr, align 4
  %93 = call float @llvm.fmuladd.f32(float %91, float %92, float %90)
  %94 = load ptr, ptr %out_ptr, align 8
  %x88 = getelementptr inbounds %struct.ImVec2, ptr %94, i32 0, i32 0
  store float %93, ptr %x88, align 4
  %95 = load ptr, ptr %center.addr, align 8
  %y89 = getelementptr inbounds %struct.ImVec2, ptr %95, i32 0, i32 1
  %96 = load float, ptr %y89, align 4
  %y90 = getelementptr inbounds %struct.ImVec2, ptr %s81, i32 0, i32 1
  %97 = load float, ptr %y90, align 4
  %98 = load float, ptr %radius.addr, align 4
  %99 = call float @llvm.fmuladd.f32(float %97, float %98, float %96)
  %100 = load ptr, ptr %out_ptr, align 8
  %y91 = getelementptr inbounds %struct.ImVec2, ptr %100, i32 0, i32 1
  store float %99, ptr %y91, align 4
  %101 = load ptr, ptr %out_ptr, align 8
  %incdec.ptr92 = getelementptr inbounds %struct.ImVec2, ptr %101, i32 1
  store ptr %incdec.ptr92, ptr %out_ptr, align 8
  br label %if.end93

if.end93:                                         ; preds = %if.end80, %if.end74, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI6ImVec2E9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 4 dereferenceable(8) %v) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %Capacity = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Size2 = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 0
  %2 = load i32, ptr %Size2, align 8
  %add = add nsw i32 %2, 1
  %call = call noundef i32 @_ZNK8ImVectorI6ImVec2E14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %add)
  call void @_ZN8ImVectorI6ImVec2E7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %Data = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %Size3 = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 0
  %4 = load i32, ptr %Size3, align 8
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds %struct.ImVec2, ptr %3, i64 %idxprom
  %5 = load ptr, ptr %v.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx, ptr align 4 %5, i64 8, i1 false)
  %Size4 = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size4, align 8
  %inc = add nsw i32 %6, 1
  store i32 %inc, ptr %Size4, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZL5ImAbsi(i32 noundef %x) #2 {
entry:
  %x.addr = alloca i32, align 4
  store i32 %x, ptr %x.addr, align 4
  %0 = load i32, ptr %x.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i32, ptr %x.addr, align 4
  %sub = sub nsw i32 0, %1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load i32, ptr %x.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %sub, %cond.true ], [ %2, %cond.false ]
  ret i32 %cond
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList11_PathArcToNERK6ImVec2fffi(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %center, float noundef %radius, float noundef %a_min, float noundef %a_max, i32 noundef %num_segments) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %center.addr = alloca ptr, align 8
  %radius.addr = alloca float, align 4
  %a_min.addr = alloca float, align 4
  %a_max.addr = alloca float, align 4
  %num_segments.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %a = alloca float, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %center, ptr %center.addr, align 8
  store float %radius, ptr %radius.addr, align 4
  store float %a_min, ptr %a_min.addr, align 4
  store float %a_max, ptr %a_max.addr, align 4
  store i32 %num_segments, ptr %num_segments.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load float, ptr %radius.addr, align 4
  %cmp = fcmp olt float %0, 5.000000e-01
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %_Path = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %1 = load ptr, ptr %center.addr, align 8
  call void @_ZN8ImVectorI6ImVec2E9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %_Path, ptr noundef nonnull align 4 dereferenceable(8) %1)
  br label %for.end

if.end:                                           ; preds = %entry
  %_Path2 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %_Path3 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %Size = getelementptr inbounds %struct.ImVector, ptr %_Path3, i32 0, i32 0
  %2 = load i32, ptr %Size, align 8
  %3 = load i32, ptr %num_segments.addr, align 4
  %add = add nsw i32 %3, 1
  %add4 = add nsw i32 %2, %add
  call void @_ZN8ImVectorI6ImVec2E7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %_Path2, i32 noundef %add4)
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load i32, ptr %i, align 4
  %5 = load i32, ptr %num_segments.addr, align 4
  %cmp5 = icmp sle i32 %4, %5
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load float, ptr %a_min.addr, align 4
  %7 = load i32, ptr %i, align 4
  %conv = sitofp i32 %7 to float
  %8 = load i32, ptr %num_segments.addr, align 4
  %conv6 = sitofp i32 %8 to float
  %div = fdiv float %conv, %conv6
  %9 = load float, ptr %a_max.addr, align 4
  %10 = load float, ptr %a_min.addr, align 4
  %sub = fsub float %9, %10
  %11 = call float @llvm.fmuladd.f32(float %div, float %sub, float %6)
  store float %11, ptr %a, align 4
  %_Path7 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %12 = load ptr, ptr %center.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %12, i32 0, i32 0
  %13 = load float, ptr %x, align 4
  %14 = load float, ptr %a, align 4
  %call = call float @cosf(float noundef %14) #12
  %15 = load float, ptr %radius.addr, align 4
  %16 = call float @llvm.fmuladd.f32(float %call, float %15, float %13)
  %17 = load ptr, ptr %center.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %17, i32 0, i32 1
  %18 = load float, ptr %y, align 4
  %19 = load float, ptr %a, align 4
  %call8 = call float @sinf(float noundef %19) #12
  %20 = load float, ptr %radius.addr, align 4
  %21 = call float @llvm.fmuladd.f32(float %call8, float %20, float %18)
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef %16, float noundef %21)
  call void @_ZN8ImVectorI6ImVec2E9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %_Path7, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %22 = load i32, ptr %i, align 4
  %inc = add nsw i32 %22, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !26

for.end:                                          ; preds = %for.cond, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI6ImVec2E7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 8
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %4, ptr align 4 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList13PathArcToFastERK6ImVec2fii(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %center, float noundef %radius, i32 noundef %a_min_of_12, i32 noundef %a_max_of_12) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %center.addr = alloca ptr, align 8
  %radius.addr = alloca float, align 4
  %a_min_of_12.addr = alloca i32, align 4
  %a_max_of_12.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %center, ptr %center.addr, align 8
  store float %radius, ptr %radius.addr, align 4
  store i32 %a_min_of_12, ptr %a_min_of_12.addr, align 4
  store i32 %a_max_of_12, ptr %a_max_of_12.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load float, ptr %radius.addr, align 4
  %cmp = fcmp olt float %0, 5.000000e-01
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %_Path = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %1 = load ptr, ptr %center.addr, align 8
  call void @_ZN8ImVectorI6ImVec2E9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %_Path, ptr noundef nonnull align 4 dereferenceable(8) %1)
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %center.addr, align 8
  %3 = load float, ptr %radius.addr, align 4
  %4 = load i32, ptr %a_min_of_12.addr, align 4
  %mul = mul nsw i32 %4, 48
  %div = sdiv i32 %mul, 12
  %5 = load i32, ptr %a_max_of_12.addr, align 4
  %mul2 = mul nsw i32 %5, 48
  %div3 = sdiv i32 %mul2, 12
  call void @_ZN10ImDrawList16_PathArcToFastExERK6ImVec2fiii(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %2, float noundef %3, i32 noundef %div, i32 noundef %div3, i32 noundef 0)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList9PathArcToERK6ImVec2fffi(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %center, float noundef %radius, float noundef %a_min, float noundef %a_max, i32 noundef %num_segments) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %center.addr = alloca ptr, align 8
  %radius.addr = alloca float, align 4
  %a_min.addr = alloca float, align 4
  %a_max.addr = alloca float, align 4
  %num_segments.addr = alloca i32, align 4
  %a_is_reverse = alloca i8, align 1
  %a_min_sample_f = alloca float, align 4
  %a_max_sample_f = alloca float, align 4
  %a_min_sample = alloca i32, align 4
  %a_max_sample = alloca i32, align 4
  %a_mid_samples = alloca i32, align 4
  %a_min_segment_angle = alloca float, align 4
  %a_max_segment_angle = alloca float, align 4
  %a_emit_start = alloca i8, align 1
  %a_emit_end = alloca i8, align 1
  %ref.tmp = alloca %struct.ImVec2, align 4
  %ref.tmp66 = alloca %struct.ImVec2, align 4
  %arc_length = alloca float, align 4
  %circle_segment_count = alloca i32, align 4
  %arc_segment_count = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %center, ptr %center.addr, align 8
  store float %radius, ptr %radius.addr, align 4
  store float %a_min, ptr %a_min.addr, align 4
  store float %a_max, ptr %a_max.addr, align 4
  store i32 %num_segments, ptr %num_segments.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load float, ptr %radius.addr, align 4
  %cmp = fcmp olt float %0, 5.000000e-01
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %_Path = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %1 = load ptr, ptr %center.addr, align 8
  call void @_ZN8ImVectorI6ImVec2E9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %_Path, ptr noundef nonnull align 4 dereferenceable(8) %1)
  br label %if.end84

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %num_segments.addr, align 4
  %cmp2 = icmp sgt i32 %2, 0
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %3 = load ptr, ptr %center.addr, align 8
  %4 = load float, ptr %radius.addr, align 4
  %5 = load float, ptr %a_min.addr, align 4
  %6 = load float, ptr %a_max.addr, align 4
  %7 = load i32, ptr %num_segments.addr, align 4
  call void @_ZN10ImDrawList11_PathArcToNERK6ImVec2fffi(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %3, float noundef %4, float noundef %5, float noundef %6, i32 noundef %7)
  br label %if.end84

if.end4:                                          ; preds = %if.end
  %8 = load float, ptr %radius.addr, align 4
  %_Data = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  %9 = load ptr, ptr %_Data, align 8
  %ArcFastRadiusCutoff = getelementptr inbounds %struct.ImDrawListSharedData, ptr %9, i32 0, i32 9
  %10 = load float, ptr %ArcFastRadiusCutoff, align 8
  %cmp5 = fcmp ole float %8, %10
  br i1 %cmp5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end4
  %11 = load float, ptr %a_max.addr, align 4
  %12 = load float, ptr %a_min.addr, align 4
  %cmp7 = fcmp olt float %11, %12
  %frombool = zext i1 %cmp7 to i8
  store i8 %frombool, ptr %a_is_reverse, align 1
  %13 = load float, ptr %a_min.addr, align 4
  %mul = fmul float 4.800000e+01, %13
  %div = fdiv float %mul, 0x401921FB60000000
  store float %div, ptr %a_min_sample_f, align 4
  %14 = load float, ptr %a_max.addr, align 4
  %mul8 = fmul float 4.800000e+01, %14
  %div9 = fdiv float %mul8, 0x401921FB60000000
  store float %div9, ptr %a_max_sample_f, align 4
  %15 = load i8, ptr %a_is_reverse, align 1
  %tobool = trunc i8 %15 to i1
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then6
  %16 = load float, ptr %a_min_sample_f, align 4
  %call = call noundef float @_ZL7ImFloorf(float noundef %16)
  %conv = fptosi float %call to i32
  br label %cond.end

cond.false:                                       ; preds = %if.then6
  %17 = load float, ptr %a_min_sample_f, align 4
  %18 = call float @llvm.ceil.f32(float %17)
  %conv10 = fptosi float %18 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv, %cond.true ], [ %conv10, %cond.false ]
  store i32 %cond, ptr %a_min_sample, align 4
  %19 = load i8, ptr %a_is_reverse, align 1
  %tobool11 = trunc i8 %19 to i1
  br i1 %tobool11, label %cond.true12, label %cond.false14

cond.true12:                                      ; preds = %cond.end
  %20 = load float, ptr %a_max_sample_f, align 4
  %21 = call float @llvm.ceil.f32(float %20)
  %conv13 = fptosi float %21 to i32
  br label %cond.end17

cond.false14:                                     ; preds = %cond.end
  %22 = load float, ptr %a_max_sample_f, align 4
  %call15 = call noundef float @_ZL7ImFloorf(float noundef %22)
  %conv16 = fptosi float %call15 to i32
  br label %cond.end17

cond.end17:                                       ; preds = %cond.false14, %cond.true12
  %cond18 = phi i32 [ %conv13, %cond.true12 ], [ %conv16, %cond.false14 ]
  store i32 %cond18, ptr %a_max_sample, align 4
  %23 = load i8, ptr %a_is_reverse, align 1
  %tobool19 = trunc i8 %23 to i1
  br i1 %tobool19, label %cond.true20, label %cond.false22

cond.true20:                                      ; preds = %cond.end17
  %24 = load i32, ptr %a_min_sample, align 4
  %25 = load i32, ptr %a_max_sample, align 4
  %sub = sub nsw i32 %24, %25
  %call21 = call noundef i32 @_ZL5ImMaxIiET_S0_S0_(i32 noundef %sub, i32 noundef 0)
  br label %cond.end25

cond.false22:                                     ; preds = %cond.end17
  %26 = load i32, ptr %a_max_sample, align 4
  %27 = load i32, ptr %a_min_sample, align 4
  %sub23 = sub nsw i32 %26, %27
  %call24 = call noundef i32 @_ZL5ImMaxIiET_S0_S0_(i32 noundef %sub23, i32 noundef 0)
  br label %cond.end25

cond.end25:                                       ; preds = %cond.false22, %cond.true20
  %cond26 = phi i32 [ %call21, %cond.true20 ], [ %call24, %cond.false22 ]
  store i32 %cond26, ptr %a_mid_samples, align 4
  %28 = load i32, ptr %a_min_sample, align 4
  %conv27 = sitofp i32 %28 to float
  %mul28 = fmul float %conv27, 0x400921FB60000000
  %mul29 = fmul float %mul28, 2.000000e+00
  %div30 = fdiv float %mul29, 4.800000e+01
  store float %div30, ptr %a_min_segment_angle, align 4
  %29 = load i32, ptr %a_max_sample, align 4
  %conv31 = sitofp i32 %29 to float
  %mul32 = fmul float %conv31, 0x400921FB60000000
  %mul33 = fmul float %mul32, 2.000000e+00
  %div34 = fdiv float %mul33, 4.800000e+01
  store float %div34, ptr %a_max_segment_angle, align 4
  %30 = load float, ptr %a_min_segment_angle, align 4
  %31 = load float, ptr %a_min.addr, align 4
  %sub35 = fsub float %30, %31
  %call36 = call noundef float @_ZL5ImAbsf(float noundef %sub35)
  %cmp37 = fcmp oge float %call36, 0x3EE4F8B580000000
  %frombool38 = zext i1 %cmp37 to i8
  store i8 %frombool38, ptr %a_emit_start, align 1
  %32 = load float, ptr %a_max.addr, align 4
  %33 = load float, ptr %a_max_segment_angle, align 4
  %sub39 = fsub float %32, %33
  %call40 = call noundef float @_ZL5ImAbsf(float noundef %sub39)
  %cmp41 = fcmp oge float %call40, 0x3EE4F8B580000000
  %frombool42 = zext i1 %cmp41 to i8
  store i8 %frombool42, ptr %a_emit_end, align 1
  %_Path43 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %_Path44 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %Size = getelementptr inbounds %struct.ImVector, ptr %_Path44, i32 0, i32 0
  %34 = load i32, ptr %Size, align 8
  %35 = load i32, ptr %a_mid_samples, align 4
  %add = add nsw i32 %35, 1
  %36 = load i8, ptr %a_emit_start, align 1
  %tobool45 = trunc i8 %36 to i1
  %cond46 = select i1 %tobool45, i32 1, i32 0
  %add47 = add nsw i32 %add, %cond46
  %37 = load i8, ptr %a_emit_end, align 1
  %tobool48 = trunc i8 %37 to i1
  %cond49 = select i1 %tobool48, i32 1, i32 0
  %add50 = add nsw i32 %add47, %cond49
  %add51 = add nsw i32 %34, %add50
  call void @_ZN8ImVectorI6ImVec2E7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %_Path43, i32 noundef %add51)
  %38 = load i8, ptr %a_emit_start, align 1
  %tobool52 = trunc i8 %38 to i1
  br i1 %tobool52, label %if.then53, label %if.end59

if.then53:                                        ; preds = %cond.end25
  %_Path54 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %39 = load ptr, ptr %center.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %39, i32 0, i32 0
  %40 = load float, ptr %x, align 4
  %41 = load float, ptr %a_min.addr, align 4
  %call55 = call float @cosf(float noundef %41) #12
  %42 = load float, ptr %radius.addr, align 4
  %43 = call float @llvm.fmuladd.f32(float %call55, float %42, float %40)
  %44 = load ptr, ptr %center.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %44, i32 0, i32 1
  %45 = load float, ptr %y, align 4
  %46 = load float, ptr %a_min.addr, align 4
  %call57 = call float @sinf(float noundef %46) #12
  %47 = load float, ptr %radius.addr, align 4
  %48 = call float @llvm.fmuladd.f32(float %call57, float %47, float %45)
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef %43, float noundef %48)
  call void @_ZN8ImVectorI6ImVec2E9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %_Path54, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp)
  br label %if.end59

if.end59:                                         ; preds = %if.then53, %cond.end25
  %49 = load i32, ptr %a_mid_samples, align 4
  %cmp60 = icmp sgt i32 %49, 0
  br i1 %cmp60, label %if.then61, label %if.end62

if.then61:                                        ; preds = %if.end59
  %50 = load ptr, ptr %center.addr, align 8
  %51 = load float, ptr %radius.addr, align 4
  %52 = load i32, ptr %a_min_sample, align 4
  %53 = load i32, ptr %a_max_sample, align 4
  call void @_ZN10ImDrawList16_PathArcToFastExERK6ImVec2fiii(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %50, float noundef %51, i32 noundef %52, i32 noundef %53, i32 noundef 0)
  br label %if.end62

if.end62:                                         ; preds = %if.then61, %if.end59
  %54 = load i8, ptr %a_emit_end, align 1
  %tobool63 = trunc i8 %54 to i1
  br i1 %tobool63, label %if.then64, label %if.end73

if.then64:                                        ; preds = %if.end62
  %_Path65 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %55 = load ptr, ptr %center.addr, align 8
  %x67 = getelementptr inbounds %struct.ImVec2, ptr %55, i32 0, i32 0
  %56 = load float, ptr %x67, align 4
  %57 = load float, ptr %a_max.addr, align 4
  %call68 = call float @cosf(float noundef %57) #12
  %58 = load float, ptr %radius.addr, align 4
  %59 = call float @llvm.fmuladd.f32(float %call68, float %58, float %56)
  %60 = load ptr, ptr %center.addr, align 8
  %y70 = getelementptr inbounds %struct.ImVec2, ptr %60, i32 0, i32 1
  %61 = load float, ptr %y70, align 4
  %62 = load float, ptr %a_max.addr, align 4
  %call71 = call float @sinf(float noundef %62) #12
  %63 = load float, ptr %radius.addr, align 4
  %64 = call float @llvm.fmuladd.f32(float %call71, float %63, float %61)
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp66, float noundef %59, float noundef %64)
  call void @_ZN8ImVectorI6ImVec2E9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %_Path65, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp66)
  br label %if.end73

if.end73:                                         ; preds = %if.then64, %if.end62
  br label %if.end84

if.else:                                          ; preds = %if.end4
  %65 = load float, ptr %a_max.addr, align 4
  %66 = load float, ptr %a_min.addr, align 4
  %sub74 = fsub float %65, %66
  %call75 = call noundef float @_ZL5ImAbsf(float noundef %sub74)
  store float %call75, ptr %arc_length, align 4
  %67 = load float, ptr %radius.addr, align 4
  %call76 = call noundef i32 @_ZNK10ImDrawList27_CalcCircleAutoSegmentCountEf(ptr noundef nonnull align 8 dereferenceable(196) %this1, float noundef %67)
  store i32 %call76, ptr %circle_segment_count, align 4
  %68 = load i32, ptr %circle_segment_count, align 4
  %conv77 = sitofp i32 %68 to float
  %69 = load float, ptr %arc_length, align 4
  %mul78 = fmul float %conv77, %69
  %div79 = fdiv float %mul78, 0x401921FB60000000
  %70 = call float @llvm.ceil.f32(float %div79)
  %conv80 = fptosi float %70 to i32
  %71 = load float, ptr %arc_length, align 4
  %div81 = fdiv float 0x401921FB60000000, %71
  %conv82 = fptosi float %div81 to i32
  %call83 = call noundef i32 @_ZL5ImMaxIiET_S0_S0_(i32 noundef %conv80, i32 noundef %conv82)
  store i32 %call83, ptr %arc_segment_count, align 4
  %72 = load ptr, ptr %center.addr, align 8
  %73 = load float, ptr %radius.addr, align 4
  %74 = load float, ptr %a_min.addr, align 4
  %75 = load float, ptr %a_max.addr, align 4
  %76 = load i32, ptr %arc_segment_count, align 4
  call void @_ZN10ImDrawList11_PathArcToNERK6ImVec2fffi(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %72, float noundef %73, float noundef %74, float noundef %75, i32 noundef %76)
  br label %if.end84

if.end84:                                         ; preds = %if.else, %if.end73, %if.then3, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef float @_ZL7ImFloorf(float noundef %f) #2 {
entry:
  %f.addr = alloca float, align 4
  store float %f, ptr %f.addr, align 4
  %0 = load float, ptr %f.addr, align 4
  %cmp = fcmp oge float %0, 0.000000e+00
  br i1 %cmp, label %cond.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load float, ptr %f.addr, align 4
  %conv = fptosi float %1 to i32
  %conv1 = sitofp i32 %conv to float
  %2 = load float, ptr %f.addr, align 4
  %cmp2 = fcmp oeq float %conv1, %2
  br i1 %cmp2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %lor.lhs.false, %entry
  %3 = load float, ptr %f.addr, align 4
  %conv3 = fptosi float %3 to i32
  br label %cond.end

cond.false:                                       ; preds = %lor.lhs.false
  %4 = load float, ptr %f.addr, align 4
  %conv4 = fptosi float %4 to i32
  %sub = sub nsw i32 %conv4, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv3, %cond.true ], [ %sub, %cond.false ]
  %conv5 = sitofp i32 %cond to float
  ret float %conv5
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZL5ImMaxIiET_S0_S0_(i32 noundef %lhs, i32 noundef %rhs) #2 {
entry:
  %lhs.addr = alloca i32, align 4
  %rhs.addr = alloca i32, align 4
  store i32 %lhs, ptr %lhs.addr, align 4
  store i32 %rhs, ptr %rhs.addr, align 4
  %0 = load i32, ptr %lhs.addr, align 4
  %1 = load i32, ptr %rhs.addr, align 4
  %cmp = icmp sge i32 %0, %1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load i32, ptr %lhs.addr, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load i32, ptr %rhs.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %2, %cond.true ], [ %3, %cond.false ]
  ret i32 %cond
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef float @_ZL5ImAbsf(float noundef %x) #2 {
entry:
  %x.addr = alloca float, align 4
  store float %x, ptr %x.addr, align 4
  %0 = load float, ptr %x.addr, align 4
  %1 = call float @llvm.fabs.f32(float %0)
  ret float %1
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList19PathEllipticalArcToERK6ImVec2fffffi(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %center, float noundef %radius_x, float noundef %radius_y, float noundef %rot, float noundef %a_min, float noundef %a_max, i32 noundef %num_segments) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %center.addr = alloca ptr, align 8
  %radius_x.addr = alloca float, align 4
  %radius_y.addr = alloca float, align 4
  %rot.addr = alloca float, align 4
  %a_min.addr = alloca float, align 4
  %a_max.addr = alloca float, align 4
  %num_segments.addr = alloca i32, align 4
  %cos_rot = alloca float, align 4
  %sin_rot = alloca float, align 4
  %i = alloca i32, align 4
  %a = alloca float, align 4
  %point = alloca %struct.ImVec2, align 4
  %rel_x = alloca float, align 4
  %rel_y = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %center, ptr %center.addr, align 8
  store float %radius_x, ptr %radius_x.addr, align 4
  store float %radius_y, ptr %radius_y.addr, align 4
  store float %rot, ptr %rot.addr, align 4
  store float %a_min, ptr %a_min.addr, align 4
  store float %a_max, ptr %a_max.addr, align 4
  store i32 %num_segments, ptr %num_segments.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %num_segments.addr, align 4
  %cmp = icmp sle i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load float, ptr %radius_x.addr, align 4
  %2 = load float, ptr %radius_y.addr, align 4
  %call = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %1, float noundef %2)
  %call2 = call noundef i32 @_ZNK10ImDrawList27_CalcCircleAutoSegmentCountEf(ptr noundef nonnull align 8 dereferenceable(196) %this1, float noundef %call)
  store i32 %call2, ptr %num_segments.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %_Path = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %_Path3 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %Size = getelementptr inbounds %struct.ImVector, ptr %_Path3, i32 0, i32 0
  %3 = load i32, ptr %Size, align 8
  %4 = load i32, ptr %num_segments.addr, align 4
  %add = add nsw i32 %4, 1
  %add4 = add nsw i32 %3, %add
  call void @_ZN8ImVectorI6ImVec2E7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %_Path, i32 noundef %add4)
  %5 = load float, ptr %rot.addr, align 4
  %call5 = call float @cosf(float noundef %5) #12
  store float %call5, ptr %cos_rot, align 4
  %6 = load float, ptr %rot.addr, align 4
  %call6 = call float @sinf(float noundef %6) #12
  store float %call6, ptr %sin_rot, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %7 = load i32, ptr %i, align 4
  %8 = load i32, ptr %num_segments.addr, align 4
  %cmp7 = icmp sle i32 %7, %8
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load float, ptr %a_min.addr, align 4
  %10 = load i32, ptr %i, align 4
  %conv = sitofp i32 %10 to float
  %11 = load i32, ptr %num_segments.addr, align 4
  %conv8 = sitofp i32 %11 to float
  %div = fdiv float %conv, %conv8
  %12 = load float, ptr %a_max.addr, align 4
  %13 = load float, ptr %a_min.addr, align 4
  %sub = fsub float %12, %13
  %14 = call float @llvm.fmuladd.f32(float %div, float %sub, float %9)
  store float %14, ptr %a, align 4
  %15 = load float, ptr %a, align 4
  %call9 = call float @cosf(float noundef %15) #12
  %16 = load float, ptr %radius_x.addr, align 4
  %mul = fmul float %call9, %16
  %17 = load float, ptr %a, align 4
  %call10 = call float @sinf(float noundef %17) #12
  %18 = load float, ptr %radius_y.addr, align 4
  %mul11 = fmul float %call10, %18
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %point, float noundef %mul, float noundef %mul11)
  %x = getelementptr inbounds %struct.ImVec2, ptr %point, i32 0, i32 0
  %19 = load float, ptr %x, align 4
  %20 = load float, ptr %cos_rot, align 4
  %y = getelementptr inbounds %struct.ImVec2, ptr %point, i32 0, i32 1
  %21 = load float, ptr %y, align 4
  %22 = load float, ptr %sin_rot, align 4
  %mul13 = fmul float %21, %22
  %neg = fneg float %mul13
  %23 = call float @llvm.fmuladd.f32(float %19, float %20, float %neg)
  store float %23, ptr %rel_x, align 4
  %x14 = getelementptr inbounds %struct.ImVec2, ptr %point, i32 0, i32 0
  %24 = load float, ptr %x14, align 4
  %25 = load float, ptr %sin_rot, align 4
  %y16 = getelementptr inbounds %struct.ImVec2, ptr %point, i32 0, i32 1
  %26 = load float, ptr %y16, align 4
  %27 = load float, ptr %cos_rot, align 4
  %mul17 = fmul float %26, %27
  %28 = call float @llvm.fmuladd.f32(float %24, float %25, float %mul17)
  store float %28, ptr %rel_y, align 4
  %29 = load float, ptr %rel_x, align 4
  %30 = load ptr, ptr %center.addr, align 8
  %x18 = getelementptr inbounds %struct.ImVec2, ptr %30, i32 0, i32 0
  %31 = load float, ptr %x18, align 4
  %add19 = fadd float %29, %31
  %x20 = getelementptr inbounds %struct.ImVec2, ptr %point, i32 0, i32 0
  store float %add19, ptr %x20, align 4
  %32 = load float, ptr %rel_y, align 4
  %33 = load ptr, ptr %center.addr, align 8
  %y21 = getelementptr inbounds %struct.ImVec2, ptr %33, i32 0, i32 1
  %34 = load float, ptr %y21, align 4
  %add22 = fadd float %32, %34
  %y23 = getelementptr inbounds %struct.ImVec2, ptr %point, i32 0, i32 1
  store float %add22, ptr %y23, align 4
  %_Path24 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  call void @_ZN8ImVectorI6ImVec2E9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %_Path24, ptr noundef nonnull align 4 dereferenceable(8) %point)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %35 = load i32, ptr %i, align 4
  %inc = add nsw i32 %35, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !27

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define <2 x float> @_Z17ImBezierCubicCalcRK6ImVec2S1_S1_S1_f(ptr noundef nonnull align 4 dereferenceable(8) %p1, ptr noundef nonnull align 4 dereferenceable(8) %p2, ptr noundef nonnull align 4 dereferenceable(8) %p3, ptr noundef nonnull align 4 dereferenceable(8) %p4, float noundef %t) #0 {
entry:
  %retval = alloca %struct.ImVec2, align 4
  %p1.addr = alloca ptr, align 8
  %p2.addr = alloca ptr, align 8
  %p3.addr = alloca ptr, align 8
  %p4.addr = alloca ptr, align 8
  %t.addr = alloca float, align 4
  %u = alloca float, align 4
  %w1 = alloca float, align 4
  %w2 = alloca float, align 4
  %w3 = alloca float, align 4
  %w4 = alloca float, align 4
  store ptr %p1, ptr %p1.addr, align 8
  store ptr %p2, ptr %p2.addr, align 8
  store ptr %p3, ptr %p3.addr, align 8
  store ptr %p4, ptr %p4.addr, align 8
  store float %t, ptr %t.addr, align 4
  %0 = load float, ptr %t.addr, align 4
  %sub = fsub float 1.000000e+00, %0
  store float %sub, ptr %u, align 4
  %1 = load float, ptr %u, align 4
  %2 = load float, ptr %u, align 4
  %mul = fmul float %1, %2
  %3 = load float, ptr %u, align 4
  %mul1 = fmul float %mul, %3
  store float %mul1, ptr %w1, align 4
  %4 = load float, ptr %u, align 4
  %mul2 = fmul float 3.000000e+00, %4
  %5 = load float, ptr %u, align 4
  %mul3 = fmul float %mul2, %5
  %6 = load float, ptr %t.addr, align 4
  %mul4 = fmul float %mul3, %6
  store float %mul4, ptr %w2, align 4
  %7 = load float, ptr %u, align 4
  %mul5 = fmul float 3.000000e+00, %7
  %8 = load float, ptr %t.addr, align 4
  %mul6 = fmul float %mul5, %8
  %9 = load float, ptr %t.addr, align 4
  %mul7 = fmul float %mul6, %9
  store float %mul7, ptr %w3, align 4
  %10 = load float, ptr %t.addr, align 4
  %11 = load float, ptr %t.addr, align 4
  %mul8 = fmul float %10, %11
  %12 = load float, ptr %t.addr, align 4
  %mul9 = fmul float %mul8, %12
  store float %mul9, ptr %w4, align 4
  %13 = load float, ptr %w1, align 4
  %14 = load ptr, ptr %p1.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %14, i32 0, i32 0
  %15 = load float, ptr %x, align 4
  %16 = load float, ptr %w2, align 4
  %17 = load ptr, ptr %p2.addr, align 8
  %x11 = getelementptr inbounds %struct.ImVec2, ptr %17, i32 0, i32 0
  %18 = load float, ptr %x11, align 4
  %mul12 = fmul float %16, %18
  %19 = call float @llvm.fmuladd.f32(float %13, float %15, float %mul12)
  %20 = load float, ptr %w3, align 4
  %21 = load ptr, ptr %p3.addr, align 8
  %x13 = getelementptr inbounds %struct.ImVec2, ptr %21, i32 0, i32 0
  %22 = load float, ptr %x13, align 4
  %23 = call float @llvm.fmuladd.f32(float %20, float %22, float %19)
  %24 = load float, ptr %w4, align 4
  %25 = load ptr, ptr %p4.addr, align 8
  %x15 = getelementptr inbounds %struct.ImVec2, ptr %25, i32 0, i32 0
  %26 = load float, ptr %x15, align 4
  %27 = call float @llvm.fmuladd.f32(float %24, float %26, float %23)
  %28 = load float, ptr %w1, align 4
  %29 = load ptr, ptr %p1.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %29, i32 0, i32 1
  %30 = load float, ptr %y, align 4
  %31 = load float, ptr %w2, align 4
  %32 = load ptr, ptr %p2.addr, align 8
  %y18 = getelementptr inbounds %struct.ImVec2, ptr %32, i32 0, i32 1
  %33 = load float, ptr %y18, align 4
  %mul19 = fmul float %31, %33
  %34 = call float @llvm.fmuladd.f32(float %28, float %30, float %mul19)
  %35 = load float, ptr %w3, align 4
  %36 = load ptr, ptr %p3.addr, align 8
  %y20 = getelementptr inbounds %struct.ImVec2, ptr %36, i32 0, i32 1
  %37 = load float, ptr %y20, align 4
  %38 = call float @llvm.fmuladd.f32(float %35, float %37, float %34)
  %39 = load float, ptr %w4, align 4
  %40 = load ptr, ptr %p4.addr, align 8
  %y22 = getelementptr inbounds %struct.ImVec2, ptr %40, i32 0, i32 1
  %41 = load float, ptr %y22, align 4
  %42 = call float @llvm.fmuladd.f32(float %39, float %41, float %38)
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %retval, float noundef %27, float noundef %42)
  %43 = load <2 x float>, ptr %retval, align 4
  ret <2 x float> %43
}

; Function Attrs: mustprogress uwtable
define <2 x float> @_Z21ImBezierQuadraticCalcRK6ImVec2S1_S1_f(ptr noundef nonnull align 4 dereferenceable(8) %p1, ptr noundef nonnull align 4 dereferenceable(8) %p2, ptr noundef nonnull align 4 dereferenceable(8) %p3, float noundef %t) #0 {
entry:
  %retval = alloca %struct.ImVec2, align 4
  %p1.addr = alloca ptr, align 8
  %p2.addr = alloca ptr, align 8
  %p3.addr = alloca ptr, align 8
  %t.addr = alloca float, align 4
  %u = alloca float, align 4
  %w1 = alloca float, align 4
  %w2 = alloca float, align 4
  %w3 = alloca float, align 4
  store ptr %p1, ptr %p1.addr, align 8
  store ptr %p2, ptr %p2.addr, align 8
  store ptr %p3, ptr %p3.addr, align 8
  store float %t, ptr %t.addr, align 4
  %0 = load float, ptr %t.addr, align 4
  %sub = fsub float 1.000000e+00, %0
  store float %sub, ptr %u, align 4
  %1 = load float, ptr %u, align 4
  %2 = load float, ptr %u, align 4
  %mul = fmul float %1, %2
  store float %mul, ptr %w1, align 4
  %3 = load float, ptr %u, align 4
  %mul1 = fmul float 2.000000e+00, %3
  %4 = load float, ptr %t.addr, align 4
  %mul2 = fmul float %mul1, %4
  store float %mul2, ptr %w2, align 4
  %5 = load float, ptr %t.addr, align 4
  %6 = load float, ptr %t.addr, align 4
  %mul3 = fmul float %5, %6
  store float %mul3, ptr %w3, align 4
  %7 = load float, ptr %w1, align 4
  %8 = load ptr, ptr %p1.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %8, i32 0, i32 0
  %9 = load float, ptr %x, align 4
  %10 = load float, ptr %w2, align 4
  %11 = load ptr, ptr %p2.addr, align 8
  %x5 = getelementptr inbounds %struct.ImVec2, ptr %11, i32 0, i32 0
  %12 = load float, ptr %x5, align 4
  %mul6 = fmul float %10, %12
  %13 = call float @llvm.fmuladd.f32(float %7, float %9, float %mul6)
  %14 = load float, ptr %w3, align 4
  %15 = load ptr, ptr %p3.addr, align 8
  %x7 = getelementptr inbounds %struct.ImVec2, ptr %15, i32 0, i32 0
  %16 = load float, ptr %x7, align 4
  %17 = call float @llvm.fmuladd.f32(float %14, float %16, float %13)
  %18 = load float, ptr %w1, align 4
  %19 = load ptr, ptr %p1.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %19, i32 0, i32 1
  %20 = load float, ptr %y, align 4
  %21 = load float, ptr %w2, align 4
  %22 = load ptr, ptr %p2.addr, align 8
  %y10 = getelementptr inbounds %struct.ImVec2, ptr %22, i32 0, i32 1
  %23 = load float, ptr %y10, align 4
  %mul11 = fmul float %21, %23
  %24 = call float @llvm.fmuladd.f32(float %18, float %20, float %mul11)
  %25 = load float, ptr %w3, align 4
  %26 = load ptr, ptr %p3.addr, align 8
  %y12 = getelementptr inbounds %struct.ImVec2, ptr %26, i32 0, i32 1
  %27 = load float, ptr %y12, align 4
  %28 = call float @llvm.fmuladd.f32(float %25, float %27, float %24)
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %retval, float noundef %17, float noundef %28)
  %29 = load <2 x float>, ptr %retval, align 4
  ret <2 x float> %29
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList22PathBezierCubicCurveToERK6ImVec2S2_S2_i(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %p2, ptr noundef nonnull align 4 dereferenceable(8) %p3, ptr noundef nonnull align 4 dereferenceable(8) %p4, i32 noundef %num_segments) #0 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p2.addr = alloca ptr, align 8
  %p3.addr = alloca ptr, align 8
  %p4.addr = alloca ptr, align 8
  %num_segments.addr = alloca i32, align 4
  %p1 = alloca %struct.ImVec2, align 4
  %t_step = alloca float, align 4
  %i_step = alloca i32, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %p2, ptr %p2.addr, align 8
  store ptr %p3, ptr %p3.addr, align 8
  store ptr %p4, ptr %p4.addr, align 8
  store i32 %num_segments, ptr %num_segments.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %_Path = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %call = call noundef nonnull align 4 dereferenceable(8) ptr @_ZN8ImVectorI6ImVec2E4backEv(ptr noundef nonnull align 8 dereferenceable(16) %_Path)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %p1, ptr align 4 %call, i64 8, i1 false)
  %0 = load i32, ptr %num_segments.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %_Path2 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %x = getelementptr inbounds %struct.ImVec2, ptr %p1, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %y = getelementptr inbounds %struct.ImVec2, ptr %p1, i32 0, i32 1
  %2 = load float, ptr %y, align 4
  %3 = load ptr, ptr %p2.addr, align 8
  %x3 = getelementptr inbounds %struct.ImVec2, ptr %3, i32 0, i32 0
  %4 = load float, ptr %x3, align 4
  %5 = load ptr, ptr %p2.addr, align 8
  %y4 = getelementptr inbounds %struct.ImVec2, ptr %5, i32 0, i32 1
  %6 = load float, ptr %y4, align 4
  %7 = load ptr, ptr %p3.addr, align 8
  %x5 = getelementptr inbounds %struct.ImVec2, ptr %7, i32 0, i32 0
  %8 = load float, ptr %x5, align 4
  %9 = load ptr, ptr %p3.addr, align 8
  %y6 = getelementptr inbounds %struct.ImVec2, ptr %9, i32 0, i32 1
  %10 = load float, ptr %y6, align 4
  %11 = load ptr, ptr %p4.addr, align 8
  %x7 = getelementptr inbounds %struct.ImVec2, ptr %11, i32 0, i32 0
  %12 = load float, ptr %x7, align 4
  %13 = load ptr, ptr %p4.addr, align 8
  %y8 = getelementptr inbounds %struct.ImVec2, ptr %13, i32 0, i32 1
  %14 = load float, ptr %y8, align 4
  %_Data = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  %15 = load ptr, ptr %_Data, align 8
  %CurveTessellationTol = getelementptr inbounds %struct.ImDrawListSharedData, ptr %15, i32 0, i32 3
  %16 = load float, ptr %CurveTessellationTol, align 4
  call void @_ZL31PathBezierCubicCurveToCasteljauP8ImVectorI6ImVec2Efffffffffi(ptr noundef %_Path2, float noundef %1, float noundef %2, float noundef %4, float noundef %6, float noundef %8, float noundef %10, float noundef %12, float noundef %14, float noundef %16, i32 noundef 0)
  br label %if.end

if.else:                                          ; preds = %entry
  %17 = load i32, ptr %num_segments.addr, align 4
  %conv = sitofp i32 %17 to float
  %div = fdiv float 1.000000e+00, %conv
  store float %div, ptr %t_step, align 4
  store i32 1, ptr %i_step, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else
  %18 = load i32, ptr %i_step, align 4
  %19 = load i32, ptr %num_segments.addr, align 4
  %cmp9 = icmp sle i32 %18, %19
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %_Path10 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %20 = load ptr, ptr %p2.addr, align 8
  %21 = load ptr, ptr %p3.addr, align 8
  %22 = load ptr, ptr %p4.addr, align 8
  %23 = load float, ptr %t_step, align 4
  %24 = load i32, ptr %i_step, align 4
  %conv11 = sitofp i32 %24 to float
  %mul = fmul float %23, %conv11
  %call12 = call <2 x float> @_Z17ImBezierCubicCalcRK6ImVec2S1_S1_S1_f(ptr noundef nonnull align 4 dereferenceable(8) %p1, ptr noundef nonnull align 4 dereferenceable(8) %20, ptr noundef nonnull align 4 dereferenceable(8) %21, ptr noundef nonnull align 4 dereferenceable(8) %22, float noundef %mul)
  store <2 x float> %call12, ptr %ref.tmp, align 4
  call void @_ZN8ImVectorI6ImVec2E9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %_Path10, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %25 = load i32, ptr %i_step, align 4
  %inc = add nsw i32 %25, 1
  store i32 %inc, ptr %i_step, align 4
  br label %for.cond, !llvm.loop !28

for.end:                                          ; preds = %for.cond
  br label %if.end

if.end:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 4 dereferenceable(8) ptr @_ZN8ImVectorI6ImVec2E4backEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %Size = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %sub = sub nsw i32 %1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.ImVec2, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL31PathBezierCubicCurveToCasteljauP8ImVectorI6ImVec2Efffffffffi(ptr noundef %path, float noundef %x1, float noundef %y1, float noundef %x2, float noundef %y2, float noundef %x3, float noundef %y3, float noundef %x4, float noundef %y4, float noundef %tess_tol, i32 noundef %level) #4 {
entry:
  %path.addr = alloca ptr, align 8
  %x1.addr = alloca float, align 4
  %y1.addr = alloca float, align 4
  %x2.addr = alloca float, align 4
  %y2.addr = alloca float, align 4
  %x3.addr = alloca float, align 4
  %y3.addr = alloca float, align 4
  %x4.addr = alloca float, align 4
  %y4.addr = alloca float, align 4
  %tess_tol.addr = alloca float, align 4
  %level.addr = alloca i32, align 4
  %dx = alloca float, align 4
  %dy = alloca float, align 4
  %d2 = alloca float, align 4
  %d3 = alloca float, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  %x12 = alloca float, align 4
  %y12 = alloca float, align 4
  %x23 = alloca float, align 4
  %y23 = alloca float, align 4
  %x34 = alloca float, align 4
  %y34 = alloca float, align 4
  %x123 = alloca float, align 4
  %y123 = alloca float, align 4
  %x234 = alloca float, align 4
  %y234 = alloca float, align 4
  %x1234 = alloca float, align 4
  %y1234 = alloca float, align 4
  store ptr %path, ptr %path.addr, align 8
  store float %x1, ptr %x1.addr, align 4
  store float %y1, ptr %y1.addr, align 4
  store float %x2, ptr %x2.addr, align 4
  store float %y2, ptr %y2.addr, align 4
  store float %x3, ptr %x3.addr, align 4
  store float %y3, ptr %y3.addr, align 4
  store float %x4, ptr %x4.addr, align 4
  store float %y4, ptr %y4.addr, align 4
  store float %tess_tol, ptr %tess_tol.addr, align 4
  store i32 %level, ptr %level.addr, align 4
  %0 = load float, ptr %x4.addr, align 4
  %1 = load float, ptr %x1.addr, align 4
  %sub = fsub float %0, %1
  store float %sub, ptr %dx, align 4
  %2 = load float, ptr %y4.addr, align 4
  %3 = load float, ptr %y1.addr, align 4
  %sub1 = fsub float %2, %3
  store float %sub1, ptr %dy, align 4
  %4 = load float, ptr %x2.addr, align 4
  %5 = load float, ptr %x4.addr, align 4
  %sub2 = fsub float %4, %5
  %6 = load float, ptr %dy, align 4
  %7 = load float, ptr %y2.addr, align 4
  %8 = load float, ptr %y4.addr, align 4
  %sub3 = fsub float %7, %8
  %9 = load float, ptr %dx, align 4
  %mul4 = fmul float %sub3, %9
  %neg = fneg float %mul4
  %10 = call float @llvm.fmuladd.f32(float %sub2, float %6, float %neg)
  store float %10, ptr %d2, align 4
  %11 = load float, ptr %x3.addr, align 4
  %12 = load float, ptr %x4.addr, align 4
  %sub5 = fsub float %11, %12
  %13 = load float, ptr %dy, align 4
  %14 = load float, ptr %y3.addr, align 4
  %15 = load float, ptr %y4.addr, align 4
  %sub6 = fsub float %14, %15
  %16 = load float, ptr %dx, align 4
  %mul7 = fmul float %sub6, %16
  %neg8 = fneg float %mul7
  %17 = call float @llvm.fmuladd.f32(float %sub5, float %13, float %neg8)
  store float %17, ptr %d3, align 4
  %18 = load float, ptr %d2, align 4
  %cmp = fcmp oge float %18, 0.000000e+00
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %19 = load float, ptr %d2, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %20 = load float, ptr %d2, align 4
  %fneg = fneg float %20
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %19, %cond.true ], [ %fneg, %cond.false ]
  store float %cond, ptr %d2, align 4
  %21 = load float, ptr %d3, align 4
  %cmp9 = fcmp oge float %21, 0.000000e+00
  br i1 %cmp9, label %cond.true10, label %cond.false11

cond.true10:                                      ; preds = %cond.end
  %22 = load float, ptr %d3, align 4
  br label %cond.end13

cond.false11:                                     ; preds = %cond.end
  %23 = load float, ptr %d3, align 4
  %fneg12 = fneg float %23
  br label %cond.end13

cond.end13:                                       ; preds = %cond.false11, %cond.true10
  %cond14 = phi float [ %22, %cond.true10 ], [ %fneg12, %cond.false11 ]
  store float %cond14, ptr %d3, align 4
  %24 = load float, ptr %d2, align 4
  %25 = load float, ptr %d3, align 4
  %add = fadd float %24, %25
  %26 = load float, ptr %d2, align 4
  %27 = load float, ptr %d3, align 4
  %add15 = fadd float %26, %27
  %mul = fmul float %add, %add15
  %28 = load float, ptr %tess_tol.addr, align 4
  %29 = load float, ptr %dx, align 4
  %30 = load float, ptr %dx, align 4
  %31 = load float, ptr %dy, align 4
  %32 = load float, ptr %dy, align 4
  %mul17 = fmul float %31, %32
  %33 = call float @llvm.fmuladd.f32(float %29, float %30, float %mul17)
  %mul18 = fmul float %28, %33
  %cmp19 = fcmp olt float %mul, %mul18
  br i1 %cmp19, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end13
  %34 = load ptr, ptr %path.addr, align 8
  %35 = load float, ptr %x4.addr, align 4
  %36 = load float, ptr %y4.addr, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef %35, float noundef %36)
  call void @_ZN8ImVectorI6ImVec2E9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %34, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp)
  br label %if.end48

if.else:                                          ; preds = %cond.end13
  %37 = load i32, ptr %level.addr, align 4
  %cmp20 = icmp slt i32 %37, 10
  br i1 %cmp20, label %if.then21, label %if.end

if.then21:                                        ; preds = %if.else
  %38 = load float, ptr %x1.addr, align 4
  %39 = load float, ptr %x2.addr, align 4
  %add22 = fadd float %38, %39
  %mul23 = fmul float %add22, 5.000000e-01
  store float %mul23, ptr %x12, align 4
  %40 = load float, ptr %y1.addr, align 4
  %41 = load float, ptr %y2.addr, align 4
  %add24 = fadd float %40, %41
  %mul25 = fmul float %add24, 5.000000e-01
  store float %mul25, ptr %y12, align 4
  %42 = load float, ptr %x2.addr, align 4
  %43 = load float, ptr %x3.addr, align 4
  %add26 = fadd float %42, %43
  %mul27 = fmul float %add26, 5.000000e-01
  store float %mul27, ptr %x23, align 4
  %44 = load float, ptr %y2.addr, align 4
  %45 = load float, ptr %y3.addr, align 4
  %add28 = fadd float %44, %45
  %mul29 = fmul float %add28, 5.000000e-01
  store float %mul29, ptr %y23, align 4
  %46 = load float, ptr %x3.addr, align 4
  %47 = load float, ptr %x4.addr, align 4
  %add30 = fadd float %46, %47
  %mul31 = fmul float %add30, 5.000000e-01
  store float %mul31, ptr %x34, align 4
  %48 = load float, ptr %y3.addr, align 4
  %49 = load float, ptr %y4.addr, align 4
  %add32 = fadd float %48, %49
  %mul33 = fmul float %add32, 5.000000e-01
  store float %mul33, ptr %y34, align 4
  %50 = load float, ptr %x12, align 4
  %51 = load float, ptr %x23, align 4
  %add34 = fadd float %50, %51
  %mul35 = fmul float %add34, 5.000000e-01
  store float %mul35, ptr %x123, align 4
  %52 = load float, ptr %y12, align 4
  %53 = load float, ptr %y23, align 4
  %add36 = fadd float %52, %53
  %mul37 = fmul float %add36, 5.000000e-01
  store float %mul37, ptr %y123, align 4
  %54 = load float, ptr %x23, align 4
  %55 = load float, ptr %x34, align 4
  %add38 = fadd float %54, %55
  %mul39 = fmul float %add38, 5.000000e-01
  store float %mul39, ptr %x234, align 4
  %56 = load float, ptr %y23, align 4
  %57 = load float, ptr %y34, align 4
  %add40 = fadd float %56, %57
  %mul41 = fmul float %add40, 5.000000e-01
  store float %mul41, ptr %y234, align 4
  %58 = load float, ptr %x123, align 4
  %59 = load float, ptr %x234, align 4
  %add42 = fadd float %58, %59
  %mul43 = fmul float %add42, 5.000000e-01
  store float %mul43, ptr %x1234, align 4
  %60 = load float, ptr %y123, align 4
  %61 = load float, ptr %y234, align 4
  %add44 = fadd float %60, %61
  %mul45 = fmul float %add44, 5.000000e-01
  store float %mul45, ptr %y1234, align 4
  %62 = load ptr, ptr %path.addr, align 8
  %63 = load float, ptr %x1.addr, align 4
  %64 = load float, ptr %y1.addr, align 4
  %65 = load float, ptr %x12, align 4
  %66 = load float, ptr %y12, align 4
  %67 = load float, ptr %x123, align 4
  %68 = load float, ptr %y123, align 4
  %69 = load float, ptr %x1234, align 4
  %70 = load float, ptr %y1234, align 4
  %71 = load float, ptr %tess_tol.addr, align 4
  %72 = load i32, ptr %level.addr, align 4
  %add46 = add nsw i32 %72, 1
  call void @_ZL31PathBezierCubicCurveToCasteljauP8ImVectorI6ImVec2Efffffffffi(ptr noundef %62, float noundef %63, float noundef %64, float noundef %65, float noundef %66, float noundef %67, float noundef %68, float noundef %69, float noundef %70, float noundef %71, i32 noundef %add46)
  %73 = load ptr, ptr %path.addr, align 8
  %74 = load float, ptr %x1234, align 4
  %75 = load float, ptr %y1234, align 4
  %76 = load float, ptr %x234, align 4
  %77 = load float, ptr %y234, align 4
  %78 = load float, ptr %x34, align 4
  %79 = load float, ptr %y34, align 4
  %80 = load float, ptr %x4.addr, align 4
  %81 = load float, ptr %y4.addr, align 4
  %82 = load float, ptr %tess_tol.addr, align 4
  %83 = load i32, ptr %level.addr, align 4
  %add47 = add nsw i32 %83, 1
  call void @_ZL31PathBezierCubicCurveToCasteljauP8ImVectorI6ImVec2Efffffffffi(ptr noundef %73, float noundef %74, float noundef %75, float noundef %76, float noundef %77, float noundef %78, float noundef %79, float noundef %80, float noundef %81, float noundef %82, i32 noundef %add47)
  br label %if.end

if.end:                                           ; preds = %if.then21, %if.else
  br label %if.end48

if.end48:                                         ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList26PathBezierQuadraticCurveToERK6ImVec2S2_i(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %p2, ptr noundef nonnull align 4 dereferenceable(8) %p3, i32 noundef %num_segments) #0 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p2.addr = alloca ptr, align 8
  %p3.addr = alloca ptr, align 8
  %num_segments.addr = alloca i32, align 4
  %p1 = alloca %struct.ImVec2, align 4
  %t_step = alloca float, align 4
  %i_step = alloca i32, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %p2, ptr %p2.addr, align 8
  store ptr %p3, ptr %p3.addr, align 8
  store i32 %num_segments, ptr %num_segments.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %_Path = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %call = call noundef nonnull align 4 dereferenceable(8) ptr @_ZN8ImVectorI6ImVec2E4backEv(ptr noundef nonnull align 8 dereferenceable(16) %_Path)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %p1, ptr align 4 %call, i64 8, i1 false)
  %0 = load i32, ptr %num_segments.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %_Path2 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %x = getelementptr inbounds %struct.ImVec2, ptr %p1, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %y = getelementptr inbounds %struct.ImVec2, ptr %p1, i32 0, i32 1
  %2 = load float, ptr %y, align 4
  %3 = load ptr, ptr %p2.addr, align 8
  %x3 = getelementptr inbounds %struct.ImVec2, ptr %3, i32 0, i32 0
  %4 = load float, ptr %x3, align 4
  %5 = load ptr, ptr %p2.addr, align 8
  %y4 = getelementptr inbounds %struct.ImVec2, ptr %5, i32 0, i32 1
  %6 = load float, ptr %y4, align 4
  %7 = load ptr, ptr %p3.addr, align 8
  %x5 = getelementptr inbounds %struct.ImVec2, ptr %7, i32 0, i32 0
  %8 = load float, ptr %x5, align 4
  %9 = load ptr, ptr %p3.addr, align 8
  %y6 = getelementptr inbounds %struct.ImVec2, ptr %9, i32 0, i32 1
  %10 = load float, ptr %y6, align 4
  %_Data = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  %11 = load ptr, ptr %_Data, align 8
  %CurveTessellationTol = getelementptr inbounds %struct.ImDrawListSharedData, ptr %11, i32 0, i32 3
  %12 = load float, ptr %CurveTessellationTol, align 4
  call void @_ZL35PathBezierQuadraticCurveToCasteljauP8ImVectorI6ImVec2Efffffffi(ptr noundef %_Path2, float noundef %1, float noundef %2, float noundef %4, float noundef %6, float noundef %8, float noundef %10, float noundef %12, i32 noundef 0)
  br label %if.end

if.else:                                          ; preds = %entry
  %13 = load i32, ptr %num_segments.addr, align 4
  %conv = sitofp i32 %13 to float
  %div = fdiv float 1.000000e+00, %conv
  store float %div, ptr %t_step, align 4
  store i32 1, ptr %i_step, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else
  %14 = load i32, ptr %i_step, align 4
  %15 = load i32, ptr %num_segments.addr, align 4
  %cmp7 = icmp sle i32 %14, %15
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %_Path8 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %16 = load ptr, ptr %p2.addr, align 8
  %17 = load ptr, ptr %p3.addr, align 8
  %18 = load float, ptr %t_step, align 4
  %19 = load i32, ptr %i_step, align 4
  %conv9 = sitofp i32 %19 to float
  %mul = fmul float %18, %conv9
  %call10 = call <2 x float> @_Z21ImBezierQuadraticCalcRK6ImVec2S1_S1_f(ptr noundef nonnull align 4 dereferenceable(8) %p1, ptr noundef nonnull align 4 dereferenceable(8) %16, ptr noundef nonnull align 4 dereferenceable(8) %17, float noundef %mul)
  store <2 x float> %call10, ptr %ref.tmp, align 4
  call void @_ZN8ImVectorI6ImVec2E9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %_Path8, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %20 = load i32, ptr %i_step, align 4
  %inc = add nsw i32 %20, 1
  store i32 %inc, ptr %i_step, align 4
  br label %for.cond, !llvm.loop !29

for.end:                                          ; preds = %for.cond
  br label %if.end

if.end:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL35PathBezierQuadraticCurveToCasteljauP8ImVectorI6ImVec2Efffffffi(ptr noundef %path, float noundef %x1, float noundef %y1, float noundef %x2, float noundef %y2, float noundef %x3, float noundef %y3, float noundef %tess_tol, i32 noundef %level) #4 {
entry:
  %path.addr = alloca ptr, align 8
  %x1.addr = alloca float, align 4
  %y1.addr = alloca float, align 4
  %x2.addr = alloca float, align 4
  %y2.addr = alloca float, align 4
  %x3.addr = alloca float, align 4
  %y3.addr = alloca float, align 4
  %tess_tol.addr = alloca float, align 4
  %level.addr = alloca i32, align 4
  %dx = alloca float, align 4
  %dy = alloca float, align 4
  %det = alloca float, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  %x12 = alloca float, align 4
  %y12 = alloca float, align 4
  %x23 = alloca float, align 4
  %y23 = alloca float, align 4
  %x123 = alloca float, align 4
  %y123 = alloca float, align 4
  store ptr %path, ptr %path.addr, align 8
  store float %x1, ptr %x1.addr, align 4
  store float %y1, ptr %y1.addr, align 4
  store float %x2, ptr %x2.addr, align 4
  store float %y2, ptr %y2.addr, align 4
  store float %x3, ptr %x3.addr, align 4
  store float %y3, ptr %y3.addr, align 4
  store float %tess_tol, ptr %tess_tol.addr, align 4
  store i32 %level, ptr %level.addr, align 4
  %0 = load float, ptr %x3.addr, align 4
  %1 = load float, ptr %x1.addr, align 4
  %sub = fsub float %0, %1
  store float %sub, ptr %dx, align 4
  %2 = load float, ptr %y3.addr, align 4
  %3 = load float, ptr %y1.addr, align 4
  %sub1 = fsub float %2, %3
  store float %sub1, ptr %dy, align 4
  %4 = load float, ptr %x2.addr, align 4
  %5 = load float, ptr %x3.addr, align 4
  %sub2 = fsub float %4, %5
  %6 = load float, ptr %dy, align 4
  %7 = load float, ptr %y2.addr, align 4
  %8 = load float, ptr %y3.addr, align 4
  %sub3 = fsub float %7, %8
  %9 = load float, ptr %dx, align 4
  %mul4 = fmul float %sub3, %9
  %neg = fneg float %mul4
  %10 = call float @llvm.fmuladd.f32(float %sub2, float %6, float %neg)
  store float %10, ptr %det, align 4
  %11 = load float, ptr %det, align 4
  %12 = load float, ptr %det, align 4
  %mul = fmul float %11, %12
  %mul5 = fmul float %mul, 4.000000e+00
  %13 = load float, ptr %tess_tol.addr, align 4
  %14 = load float, ptr %dx, align 4
  %15 = load float, ptr %dx, align 4
  %16 = load float, ptr %dy, align 4
  %17 = load float, ptr %dy, align 4
  %mul7 = fmul float %16, %17
  %18 = call float @llvm.fmuladd.f32(float %14, float %15, float %mul7)
  %mul8 = fmul float %13, %18
  %cmp = fcmp olt float %mul5, %mul8
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %19 = load ptr, ptr %path.addr, align 8
  %20 = load float, ptr %x3.addr, align 4
  %21 = load float, ptr %y3.addr, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef %20, float noundef %21)
  call void @_ZN8ImVectorI6ImVec2E9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %19, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp)
  br label %if.end24

if.else:                                          ; preds = %entry
  %22 = load i32, ptr %level.addr, align 4
  %cmp9 = icmp slt i32 %22, 10
  br i1 %cmp9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.else
  %23 = load float, ptr %x1.addr, align 4
  %24 = load float, ptr %x2.addr, align 4
  %add = fadd float %23, %24
  %mul11 = fmul float %add, 5.000000e-01
  store float %mul11, ptr %x12, align 4
  %25 = load float, ptr %y1.addr, align 4
  %26 = load float, ptr %y2.addr, align 4
  %add12 = fadd float %25, %26
  %mul13 = fmul float %add12, 5.000000e-01
  store float %mul13, ptr %y12, align 4
  %27 = load float, ptr %x2.addr, align 4
  %28 = load float, ptr %x3.addr, align 4
  %add14 = fadd float %27, %28
  %mul15 = fmul float %add14, 5.000000e-01
  store float %mul15, ptr %x23, align 4
  %29 = load float, ptr %y2.addr, align 4
  %30 = load float, ptr %y3.addr, align 4
  %add16 = fadd float %29, %30
  %mul17 = fmul float %add16, 5.000000e-01
  store float %mul17, ptr %y23, align 4
  %31 = load float, ptr %x12, align 4
  %32 = load float, ptr %x23, align 4
  %add18 = fadd float %31, %32
  %mul19 = fmul float %add18, 5.000000e-01
  store float %mul19, ptr %x123, align 4
  %33 = load float, ptr %y12, align 4
  %34 = load float, ptr %y23, align 4
  %add20 = fadd float %33, %34
  %mul21 = fmul float %add20, 5.000000e-01
  store float %mul21, ptr %y123, align 4
  %35 = load ptr, ptr %path.addr, align 8
  %36 = load float, ptr %x1.addr, align 4
  %37 = load float, ptr %y1.addr, align 4
  %38 = load float, ptr %x12, align 4
  %39 = load float, ptr %y12, align 4
  %40 = load float, ptr %x123, align 4
  %41 = load float, ptr %y123, align 4
  %42 = load float, ptr %tess_tol.addr, align 4
  %43 = load i32, ptr %level.addr, align 4
  %add22 = add nsw i32 %43, 1
  call void @_ZL35PathBezierQuadraticCurveToCasteljauP8ImVectorI6ImVec2Efffffffi(ptr noundef %35, float noundef %36, float noundef %37, float noundef %38, float noundef %39, float noundef %40, float noundef %41, float noundef %42, i32 noundef %add22)
  %44 = load ptr, ptr %path.addr, align 8
  %45 = load float, ptr %x123, align 4
  %46 = load float, ptr %y123, align 4
  %47 = load float, ptr %x23, align 4
  %48 = load float, ptr %y23, align 4
  %49 = load float, ptr %x3.addr, align 4
  %50 = load float, ptr %y3.addr, align 4
  %51 = load float, ptr %tess_tol.addr, align 4
  %52 = load i32, ptr %level.addr, align 4
  %add23 = add nsw i32 %52, 1
  call void @_ZL35PathBezierQuadraticCurveToCasteljauP8ImVectorI6ImVec2Efffffffi(ptr noundef %44, float noundef %45, float noundef %46, float noundef %47, float noundef %48, float noundef %49, float noundef %50, float noundef %51, i32 noundef %add23)
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.else
  br label %if.end24

if.end24:                                         ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList8PathRectERK6ImVec2S2_fi(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %a, ptr noundef nonnull align 4 dereferenceable(8) %b, float noundef %rounding, i32 noundef %flags) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %rounding.addr = alloca float, align 4
  %flags.addr = alloca i32, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  %ref.tmp23 = alloca %struct.ImVec2, align 4
  %rounding_tl = alloca float, align 4
  %rounding_tr = alloca float, align 4
  %rounding_br = alloca float, align 4
  %rounding_bl = alloca float, align 4
  %ref.tmp46 = alloca %struct.ImVec2, align 4
  %ref.tmp50 = alloca %struct.ImVec2, align 4
  %ref.tmp55 = alloca %struct.ImVec2, align 4
  %ref.tmp60 = alloca %struct.ImVec2, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  store float %rounding, ptr %rounding.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load float, ptr %rounding.addr, align 4
  %cmp = fcmp oge float %0, 5.000000e-01
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %flags.addr, align 4
  %call = call noundef i32 @_ZL18FixRectCornerFlagsi(i32 noundef %1)
  store i32 %call, ptr %flags.addr, align 4
  %2 = load float, ptr %rounding.addr, align 4
  %3 = load ptr, ptr %b.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %3, i32 0, i32 0
  %4 = load float, ptr %x, align 4
  %5 = load ptr, ptr %a.addr, align 8
  %x2 = getelementptr inbounds %struct.ImVec2, ptr %5, i32 0, i32 0
  %6 = load float, ptr %x2, align 4
  %sub = fsub float %4, %6
  %7 = call float @llvm.fabs.f32(float %sub)
  %8 = load i32, ptr %flags.addr, align 4
  %and = and i32 %8, 48
  %cmp3 = icmp eq i32 %and, 48
  br i1 %cmp3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.then
  %9 = load i32, ptr %flags.addr, align 4
  %and4 = and i32 %9, 192
  %cmp5 = icmp eq i32 %and4, 192
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.then
  %10 = phi i1 [ true, %if.then ], [ %cmp5, %lor.rhs ]
  %cond = select i1 %10, float 5.000000e-01, float 1.000000e+00
  %11 = call float @llvm.fmuladd.f32(float %7, float %cond, float -1.000000e+00)
  %call6 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %2, float noundef %11)
  store float %call6, ptr %rounding.addr, align 4
  %12 = load float, ptr %rounding.addr, align 4
  %13 = load ptr, ptr %b.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %13, i32 0, i32 1
  %14 = load float, ptr %y, align 4
  %15 = load ptr, ptr %a.addr, align 8
  %y7 = getelementptr inbounds %struct.ImVec2, ptr %15, i32 0, i32 1
  %16 = load float, ptr %y7, align 4
  %sub8 = fsub float %14, %16
  %17 = call float @llvm.fabs.f32(float %sub8)
  %18 = load i32, ptr %flags.addr, align 4
  %and9 = and i32 %18, 80
  %cmp10 = icmp eq i32 %and9, 80
  br i1 %cmp10, label %lor.end14, label %lor.rhs11

lor.rhs11:                                        ; preds = %lor.end
  %19 = load i32, ptr %flags.addr, align 4
  %and12 = and i32 %19, 160
  %cmp13 = icmp eq i32 %and12, 160
  br label %lor.end14

lor.end14:                                        ; preds = %lor.rhs11, %lor.end
  %20 = phi i1 [ true, %lor.end ], [ %cmp13, %lor.rhs11 ]
  %cond15 = select i1 %20, float 5.000000e-01, float 1.000000e+00
  %21 = call float @llvm.fmuladd.f32(float %17, float %cond15, float -1.000000e+00)
  %call16 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %12, float noundef %21)
  store float %call16, ptr %rounding.addr, align 4
  br label %if.end

if.end:                                           ; preds = %lor.end14, %entry
  %22 = load float, ptr %rounding.addr, align 4
  %cmp17 = fcmp olt float %22, 5.000000e-01
  br i1 %cmp17, label %if.then20, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %23 = load i32, ptr %flags.addr, align 4
  %and18 = and i32 %23, 496
  %cmp19 = icmp eq i32 %and18, 256
  br i1 %cmp19, label %if.then20, label %if.else

if.then20:                                        ; preds = %lor.lhs.false, %if.end
  %24 = load ptr, ptr %a.addr, align 8
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %24)
  %25 = load ptr, ptr %b.addr, align 8
  %x21 = getelementptr inbounds %struct.ImVec2, ptr %25, i32 0, i32 0
  %26 = load float, ptr %x21, align 4
  %27 = load ptr, ptr %a.addr, align 8
  %y22 = getelementptr inbounds %struct.ImVec2, ptr %27, i32 0, i32 1
  %28 = load float, ptr %y22, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef %26, float noundef %28)
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp)
  %29 = load ptr, ptr %b.addr, align 8
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %29)
  %30 = load ptr, ptr %a.addr, align 8
  %x24 = getelementptr inbounds %struct.ImVec2, ptr %30, i32 0, i32 0
  %31 = load float, ptr %x24, align 4
  %32 = load ptr, ptr %b.addr, align 8
  %y25 = getelementptr inbounds %struct.ImVec2, ptr %32, i32 0, i32 1
  %33 = load float, ptr %y25, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp23, float noundef %31, float noundef %33)
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp23)
  br label %if.end65

if.else:                                          ; preds = %lor.lhs.false
  %34 = load i32, ptr %flags.addr, align 4
  %and26 = and i32 %34, 16
  %tobool = icmp ne i32 %and26, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else
  %35 = load float, ptr %rounding.addr, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.else
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond27 = phi float [ %35, %cond.true ], [ 0.000000e+00, %cond.false ]
  store float %cond27, ptr %rounding_tl, align 4
  %36 = load i32, ptr %flags.addr, align 4
  %and28 = and i32 %36, 32
  %tobool29 = icmp ne i32 %and28, 0
  br i1 %tobool29, label %cond.true30, label %cond.false31

cond.true30:                                      ; preds = %cond.end
  %37 = load float, ptr %rounding.addr, align 4
  br label %cond.end32

cond.false31:                                     ; preds = %cond.end
  br label %cond.end32

cond.end32:                                       ; preds = %cond.false31, %cond.true30
  %cond33 = phi float [ %37, %cond.true30 ], [ 0.000000e+00, %cond.false31 ]
  store float %cond33, ptr %rounding_tr, align 4
  %38 = load i32, ptr %flags.addr, align 4
  %and34 = and i32 %38, 128
  %tobool35 = icmp ne i32 %and34, 0
  br i1 %tobool35, label %cond.true36, label %cond.false37

cond.true36:                                      ; preds = %cond.end32
  %39 = load float, ptr %rounding.addr, align 4
  br label %cond.end38

cond.false37:                                     ; preds = %cond.end32
  br label %cond.end38

cond.end38:                                       ; preds = %cond.false37, %cond.true36
  %cond39 = phi float [ %39, %cond.true36 ], [ 0.000000e+00, %cond.false37 ]
  store float %cond39, ptr %rounding_br, align 4
  %40 = load i32, ptr %flags.addr, align 4
  %and40 = and i32 %40, 64
  %tobool41 = icmp ne i32 %and40, 0
  br i1 %tobool41, label %cond.true42, label %cond.false43

cond.true42:                                      ; preds = %cond.end38
  %41 = load float, ptr %rounding.addr, align 4
  br label %cond.end44

cond.false43:                                     ; preds = %cond.end38
  br label %cond.end44

cond.end44:                                       ; preds = %cond.false43, %cond.true42
  %cond45 = phi float [ %41, %cond.true42 ], [ 0.000000e+00, %cond.false43 ]
  store float %cond45, ptr %rounding_bl, align 4
  %42 = load ptr, ptr %a.addr, align 8
  %x47 = getelementptr inbounds %struct.ImVec2, ptr %42, i32 0, i32 0
  %43 = load float, ptr %x47, align 4
  %44 = load float, ptr %rounding_tl, align 4
  %add = fadd float %43, %44
  %45 = load ptr, ptr %a.addr, align 8
  %y48 = getelementptr inbounds %struct.ImVec2, ptr %45, i32 0, i32 1
  %46 = load float, ptr %y48, align 4
  %47 = load float, ptr %rounding_tl, align 4
  %add49 = fadd float %46, %47
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp46, float noundef %add, float noundef %add49)
  %48 = load float, ptr %rounding_tl, align 4
  call void @_ZN10ImDrawList13PathArcToFastERK6ImVec2fii(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp46, float noundef %48, i32 noundef 6, i32 noundef 9)
  %49 = load ptr, ptr %b.addr, align 8
  %x51 = getelementptr inbounds %struct.ImVec2, ptr %49, i32 0, i32 0
  %50 = load float, ptr %x51, align 4
  %51 = load float, ptr %rounding_tr, align 4
  %sub52 = fsub float %50, %51
  %52 = load ptr, ptr %a.addr, align 8
  %y53 = getelementptr inbounds %struct.ImVec2, ptr %52, i32 0, i32 1
  %53 = load float, ptr %y53, align 4
  %54 = load float, ptr %rounding_tr, align 4
  %add54 = fadd float %53, %54
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp50, float noundef %sub52, float noundef %add54)
  %55 = load float, ptr %rounding_tr, align 4
  call void @_ZN10ImDrawList13PathArcToFastERK6ImVec2fii(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp50, float noundef %55, i32 noundef 9, i32 noundef 12)
  %56 = load ptr, ptr %b.addr, align 8
  %x56 = getelementptr inbounds %struct.ImVec2, ptr %56, i32 0, i32 0
  %57 = load float, ptr %x56, align 4
  %58 = load float, ptr %rounding_br, align 4
  %sub57 = fsub float %57, %58
  %59 = load ptr, ptr %b.addr, align 8
  %y58 = getelementptr inbounds %struct.ImVec2, ptr %59, i32 0, i32 1
  %60 = load float, ptr %y58, align 4
  %61 = load float, ptr %rounding_br, align 4
  %sub59 = fsub float %60, %61
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp55, float noundef %sub57, float noundef %sub59)
  %62 = load float, ptr %rounding_br, align 4
  call void @_ZN10ImDrawList13PathArcToFastERK6ImVec2fii(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp55, float noundef %62, i32 noundef 0, i32 noundef 3)
  %63 = load ptr, ptr %a.addr, align 8
  %x61 = getelementptr inbounds %struct.ImVec2, ptr %63, i32 0, i32 0
  %64 = load float, ptr %x61, align 4
  %65 = load float, ptr %rounding_bl, align 4
  %add62 = fadd float %64, %65
  %66 = load ptr, ptr %b.addr, align 8
  %y63 = getelementptr inbounds %struct.ImVec2, ptr %66, i32 0, i32 1
  %67 = load float, ptr %y63, align 4
  %68 = load float, ptr %rounding_bl, align 4
  %sub64 = fsub float %67, %68
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp60, float noundef %add62, float noundef %sub64)
  %69 = load float, ptr %rounding_bl, align 4
  call void @_ZN10ImDrawList13PathArcToFastERK6ImVec2fii(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp60, float noundef %69, i32 noundef 3, i32 noundef 6)
  br label %if.end65

if.end65:                                         ; preds = %cond.end44, %if.then20
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZL18FixRectCornerFlagsi(i32 noundef %flags) #2 {
entry:
  %flags.addr = alloca i32, align 4
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load i32, ptr %flags.addr, align 4
  %and = and i32 %0, 496
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %flags.addr, align 4
  %or = or i32 %1, 240
  store i32 %or, ptr %flags.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i32, ptr %flags.addr, align 4
  ret i32 %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.fabs.f32(float) #7

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %pos) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %pos.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %pos, ptr %pos.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %_Path = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %0 = load ptr, ptr %pos.addr, align 8
  call void @_ZN8ImVectorI6ImVec2E9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %_Path, ptr noundef nonnull align 4 dereferenceable(8) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList7AddLineERK6ImVec2S2_jf(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %p1, ptr noundef nonnull align 4 dereferenceable(8) %p2, i32 noundef %col, float noundef %thickness) #0 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p1.addr = alloca ptr, align 8
  %p2.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  %thickness.addr = alloca float, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  %ref.tmp2 = alloca %struct.ImVec2, align 4
  %ref.tmp3 = alloca %struct.ImVec2, align 4
  %ref.tmp4 = alloca %struct.ImVec2, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %p1, ptr %p1.addr, align 8
  store ptr %p2, ptr %p2.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  store float %thickness, ptr %thickness.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %col.addr, align 4
  %and = and i32 %0, -16777216
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %p1.addr, align 8
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp2, float noundef 5.000000e-01, float noundef 5.000000e-01)
  %call = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %1, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp2)
  store <2 x float> %call, ptr %ref.tmp, align 4
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp)
  %2 = load ptr, ptr %p2.addr, align 8
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp4, float noundef 5.000000e-01, float noundef 5.000000e-01)
  %call5 = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %2, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp4)
  store <2 x float> %call5, ptr %ref.tmp3, align 4
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp3)
  %3 = load i32, ptr %col.addr, align 4
  %4 = load float, ptr %thickness.addr, align 4
  call void @_ZN10ImDrawList10PathStrokeEjif(ptr noundef nonnull align 8 dereferenceable(196) %this1, i32 noundef %3, i32 noundef 0, float noundef %4)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN10ImDrawList10PathStrokeEjif(ptr noundef nonnull align 8 dereferenceable(196) %this, i32 noundef %col, i32 noundef %flags, float noundef %thickness) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %thickness.addr = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  store float %thickness, ptr %thickness.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %_Path = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %Data = getelementptr inbounds %struct.ImVector, ptr %_Path, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %_Path2 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %Size = getelementptr inbounds %struct.ImVector, ptr %_Path2, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %2 = load i32, ptr %col.addr, align 4
  %3 = load i32, ptr %flags.addr, align 4
  %4 = load float, ptr %thickness.addr, align 4
  call void @_ZN10ImDrawList11AddPolylineEPK6ImVec2ijif(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, float noundef %4)
  %_Path3 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %Size4 = getelementptr inbounds %struct.ImVector, ptr %_Path3, i32 0, i32 0
  store i32 0, ptr %Size4, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList7AddRectERK6ImVec2S2_jfif(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %p_min, ptr noundef nonnull align 4 dereferenceable(8) %p_max, i32 noundef %col, float noundef %rounding, i32 noundef %flags, float noundef %thickness) #0 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p_min.addr = alloca ptr, align 8
  %p_max.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  %rounding.addr = alloca float, align 4
  %flags.addr = alloca i32, align 4
  %thickness.addr = alloca float, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  %ref.tmp4 = alloca %struct.ImVec2, align 4
  %ref.tmp5 = alloca %struct.ImVec2, align 4
  %ref.tmp6 = alloca %struct.ImVec2, align 4
  %ref.tmp8 = alloca %struct.ImVec2, align 4
  %ref.tmp9 = alloca %struct.ImVec2, align 4
  %ref.tmp11 = alloca %struct.ImVec2, align 4
  %ref.tmp12 = alloca %struct.ImVec2, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %p_min, ptr %p_min.addr, align 8
  store ptr %p_max, ptr %p_max.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  store float %rounding, ptr %rounding.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  store float %thickness, ptr %thickness.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %col.addr, align 4
  %and = and i32 %0, -16777216
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %Flags = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 3
  %1 = load i32, ptr %Flags, align 8
  %and2 = and i32 %1, 1
  %tobool = icmp ne i32 %and2, 0
  br i1 %tobool, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %2 = load ptr, ptr %p_min.addr, align 8
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp4, float noundef 5.000000e-01, float noundef 5.000000e-01)
  %call = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %2, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp4)
  store <2 x float> %call, ptr %ref.tmp, align 4
  %3 = load ptr, ptr %p_max.addr, align 8
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp6, float noundef 5.000000e-01, float noundef 5.000000e-01)
  %call7 = call <2 x float> @_ZmiRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %3, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp6)
  store <2 x float> %call7, ptr %ref.tmp5, align 4
  %4 = load float, ptr %rounding.addr, align 4
  %5 = load i32, ptr %flags.addr, align 4
  call void @_ZN10ImDrawList8PathRectERK6ImVec2S2_fi(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp5, float noundef %4, i32 noundef %5)
  br label %if.end14

if.else:                                          ; preds = %if.end
  %6 = load ptr, ptr %p_min.addr, align 8
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp9, float noundef 5.000000e-01, float noundef 5.000000e-01)
  %call10 = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %6, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp9)
  store <2 x float> %call10, ptr %ref.tmp8, align 4
  %7 = load ptr, ptr %p_max.addr, align 8
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp12, float noundef 0x3FDF5C2900000000, float noundef 0x3FDF5C2900000000)
  %call13 = call <2 x float> @_ZmiRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %7, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp12)
  store <2 x float> %call13, ptr %ref.tmp11, align 4
  %8 = load float, ptr %rounding.addr, align 4
  %9 = load i32, ptr %flags.addr, align 4
  call void @_ZN10ImDrawList8PathRectERK6ImVec2S2_fi(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp8, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp11, float noundef %8, i32 noundef %9)
  br label %if.end14

if.end14:                                         ; preds = %if.else, %if.then3
  %10 = load i32, ptr %col.addr, align 4
  %11 = load float, ptr %thickness.addr, align 4
  call void @_ZN10ImDrawList10PathStrokeEjif(ptr noundef nonnull align 8 dereferenceable(196) %this1, i32 noundef %10, i32 noundef 1, float noundef %11)
  br label %return

return:                                           ; preds = %if.end14, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList13AddRectFilledERK6ImVec2S2_jfi(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %p_min, ptr noundef nonnull align 4 dereferenceable(8) %p_max, i32 noundef %col, float noundef %rounding, i32 noundef %flags) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p_min.addr = alloca ptr, align 8
  %p_max.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  %rounding.addr = alloca float, align 4
  %flags.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %p_min, ptr %p_min.addr, align 8
  store ptr %p_max, ptr %p_max.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  store float %rounding, ptr %rounding.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %col.addr, align 4
  %and = and i32 %0, -16777216
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end6

if.end:                                           ; preds = %entry
  %1 = load float, ptr %rounding.addr, align 4
  %cmp2 = fcmp olt float %1, 5.000000e-01
  br i1 %cmp2, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %2 = load i32, ptr %flags.addr, align 4
  %and3 = and i32 %2, 496
  %cmp4 = icmp eq i32 %and3, 256
  br i1 %cmp4, label %if.then5, label %if.else

if.then5:                                         ; preds = %lor.lhs.false, %if.end
  call void @_ZN10ImDrawList11PrimReserveEii(ptr noundef nonnull align 8 dereferenceable(196) %this1, i32 noundef 6, i32 noundef 4)
  %3 = load ptr, ptr %p_min.addr, align 8
  %4 = load ptr, ptr %p_max.addr, align 8
  %5 = load i32, ptr %col.addr, align 4
  call void @_ZN10ImDrawList8PrimRectERK6ImVec2S2_j(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %3, ptr noundef nonnull align 4 dereferenceable(8) %4, i32 noundef %5)
  br label %if.end6

if.else:                                          ; preds = %lor.lhs.false
  %6 = load ptr, ptr %p_min.addr, align 8
  %7 = load ptr, ptr %p_max.addr, align 8
  %8 = load float, ptr %rounding.addr, align 4
  %9 = load i32, ptr %flags.addr, align 4
  call void @_ZN10ImDrawList8PathRectERK6ImVec2S2_fi(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %6, ptr noundef nonnull align 4 dereferenceable(8) %7, float noundef %8, i32 noundef %9)
  %10 = load i32, ptr %col.addr, align 4
  call void @_ZN10ImDrawList14PathFillConvexEj(ptr noundef nonnull align 8 dereferenceable(196) %this1, i32 noundef %10)
  br label %if.end6

if.end6:                                          ; preds = %if.else, %if.then5, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN10ImDrawList14PathFillConvexEj(ptr noundef nonnull align 8 dereferenceable(196) %this, i32 noundef %col) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %_Path = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %Data = getelementptr inbounds %struct.ImVector, ptr %_Path, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %_Path2 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %Size = getelementptr inbounds %struct.ImVector, ptr %_Path2, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %2 = load i32, ptr %col.addr, align 4
  call void @_ZN10ImDrawList19AddConvexPolyFilledEPK6ImVec2ij(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef %0, i32 noundef %1, i32 noundef %2)
  %_Path3 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %Size4 = getelementptr inbounds %struct.ImVector, ptr %_Path3, i32 0, i32 0
  store i32 0, ptr %Size4, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList23AddRectFilledMultiColorERK6ImVec2S2_jjjj(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %p_min, ptr noundef nonnull align 4 dereferenceable(8) %p_max, i32 noundef %col_upr_left, i32 noundef %col_upr_right, i32 noundef %col_bot_right, i32 noundef %col_bot_left) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p_min.addr = alloca ptr, align 8
  %p_max.addr = alloca ptr, align 8
  %col_upr_left.addr = alloca i32, align 4
  %col_upr_right.addr = alloca i32, align 4
  %col_bot_right.addr = alloca i32, align 4
  %col_bot_left.addr = alloca i32, align 4
  %uv = alloca %struct.ImVec2, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  %ref.tmp17 = alloca %struct.ImVec2, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %p_min, ptr %p_min.addr, align 8
  store ptr %p_max, ptr %p_max.addr, align 8
  store i32 %col_upr_left, ptr %col_upr_left.addr, align 4
  store i32 %col_upr_right, ptr %col_upr_right.addr, align 4
  store i32 %col_bot_right, ptr %col_bot_right.addr, align 4
  store i32 %col_bot_left, ptr %col_bot_left.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %col_upr_left.addr, align 4
  %1 = load i32, ptr %col_upr_right.addr, align 4
  %or = or i32 %0, %1
  %2 = load i32, ptr %col_bot_right.addr, align 4
  %or2 = or i32 %or, %2
  %3 = load i32, ptr %col_bot_left.addr, align 4
  %or3 = or i32 %or2, %3
  %and = and i32 %or3, -16777216
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %_Data = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  %4 = load ptr, ptr %_Data, align 8
  %TexUvWhitePixel = getelementptr inbounds %struct.ImDrawListSharedData, ptr %4, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv, ptr align 8 %TexUvWhitePixel, i64 8, i1 false)
  call void @_ZN10ImDrawList11PrimReserveEii(ptr noundef nonnull align 8 dereferenceable(196) %this1, i32 noundef 6, i32 noundef 4)
  %_VtxCurrentIdx = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %5 = load i32, ptr %_VtxCurrentIdx, align 4
  %conv = trunc i32 %5 to i16
  call void @_ZN10ImDrawList12PrimWriteIdxEt(ptr noundef nonnull align 8 dereferenceable(196) %this1, i16 noundef zeroext %conv)
  %_VtxCurrentIdx4 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %6 = load i32, ptr %_VtxCurrentIdx4, align 4
  %add = add i32 %6, 1
  %conv5 = trunc i32 %add to i16
  call void @_ZN10ImDrawList12PrimWriteIdxEt(ptr noundef nonnull align 8 dereferenceable(196) %this1, i16 noundef zeroext %conv5)
  %_VtxCurrentIdx6 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %7 = load i32, ptr %_VtxCurrentIdx6, align 4
  %add7 = add i32 %7, 2
  %conv8 = trunc i32 %add7 to i16
  call void @_ZN10ImDrawList12PrimWriteIdxEt(ptr noundef nonnull align 8 dereferenceable(196) %this1, i16 noundef zeroext %conv8)
  %_VtxCurrentIdx9 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %8 = load i32, ptr %_VtxCurrentIdx9, align 4
  %conv10 = trunc i32 %8 to i16
  call void @_ZN10ImDrawList12PrimWriteIdxEt(ptr noundef nonnull align 8 dereferenceable(196) %this1, i16 noundef zeroext %conv10)
  %_VtxCurrentIdx11 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %9 = load i32, ptr %_VtxCurrentIdx11, align 4
  %add12 = add i32 %9, 2
  %conv13 = trunc i32 %add12 to i16
  call void @_ZN10ImDrawList12PrimWriteIdxEt(ptr noundef nonnull align 8 dereferenceable(196) %this1, i16 noundef zeroext %conv13)
  %_VtxCurrentIdx14 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %10 = load i32, ptr %_VtxCurrentIdx14, align 4
  %add15 = add i32 %10, 3
  %conv16 = trunc i32 %add15 to i16
  call void @_ZN10ImDrawList12PrimWriteIdxEt(ptr noundef nonnull align 8 dereferenceable(196) %this1, i16 noundef zeroext %conv16)
  %11 = load ptr, ptr %p_min.addr, align 8
  %12 = load i32, ptr %col_upr_left.addr, align 4
  call void @_ZN10ImDrawList12PrimWriteVtxERK6ImVec2S2_j(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %11, ptr noundef nonnull align 4 dereferenceable(8) %uv, i32 noundef %12)
  %13 = load ptr, ptr %p_max.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %13, i32 0, i32 0
  %14 = load float, ptr %x, align 4
  %15 = load ptr, ptr %p_min.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %15, i32 0, i32 1
  %16 = load float, ptr %y, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef %14, float noundef %16)
  %17 = load i32, ptr %col_upr_right.addr, align 4
  call void @_ZN10ImDrawList12PrimWriteVtxERK6ImVec2S2_j(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(8) %uv, i32 noundef %17)
  %18 = load ptr, ptr %p_max.addr, align 8
  %19 = load i32, ptr %col_bot_right.addr, align 4
  call void @_ZN10ImDrawList12PrimWriteVtxERK6ImVec2S2_j(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %18, ptr noundef nonnull align 4 dereferenceable(8) %uv, i32 noundef %19)
  %20 = load ptr, ptr %p_min.addr, align 8
  %x18 = getelementptr inbounds %struct.ImVec2, ptr %20, i32 0, i32 0
  %21 = load float, ptr %x18, align 4
  %22 = load ptr, ptr %p_max.addr, align 8
  %y19 = getelementptr inbounds %struct.ImVec2, ptr %22, i32 0, i32 1
  %23 = load float, ptr %y19, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp17, float noundef %21, float noundef %23)
  %24 = load i32, ptr %col_bot_left.addr, align 4
  call void @_ZN10ImDrawList12PrimWriteVtxERK6ImVec2S2_j(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp17, ptr noundef nonnull align 4 dereferenceable(8) %uv, i32 noundef %24)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN10ImDrawList12PrimWriteIdxEt(ptr noundef nonnull align 8 dereferenceable(196) %this, i16 noundef zeroext %idx) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %idx.addr = alloca i16, align 2
  store ptr %this, ptr %this.addr, align 8
  store i16 %idx, ptr %idx.addr, align 2
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i16, ptr %idx.addr, align 2
  %_IdxWritePtr = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %1 = load ptr, ptr %_IdxWritePtr, align 8
  store i16 %0, ptr %1, align 2
  %_IdxWritePtr2 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 8
  %2 = load ptr, ptr %_IdxWritePtr2, align 8
  %incdec.ptr = getelementptr inbounds i16, ptr %2, i32 1
  store ptr %incdec.ptr, ptr %_IdxWritePtr2, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN10ImDrawList12PrimWriteVtxERK6ImVec2S2_j(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %pos, ptr noundef nonnull align 4 dereferenceable(8) %uv, i32 noundef %col) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %pos.addr = alloca ptr, align 8
  %uv.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %pos, ptr %pos.addr, align 8
  store ptr %uv, ptr %uv.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %pos.addr, align 8
  %_VtxWritePtr = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %1 = load ptr, ptr %_VtxWritePtr, align 8
  %pos2 = getelementptr inbounds %struct.ImDrawVert, ptr %1, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %pos2, ptr align 4 %0, i64 8, i1 false)
  %2 = load ptr, ptr %uv.addr, align 8
  %_VtxWritePtr3 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %3 = load ptr, ptr %_VtxWritePtr3, align 8
  %uv4 = getelementptr inbounds %struct.ImDrawVert, ptr %3, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv4, ptr align 4 %2, i64 8, i1 false)
  %4 = load i32, ptr %col.addr, align 4
  %_VtxWritePtr5 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %5 = load ptr, ptr %_VtxWritePtr5, align 8
  %col6 = getelementptr inbounds %struct.ImDrawVert, ptr %5, i32 0, i32 2
  store i32 %4, ptr %col6, align 4
  %_VtxWritePtr7 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 7
  %6 = load ptr, ptr %_VtxWritePtr7, align 8
  %incdec.ptr = getelementptr inbounds %struct.ImDrawVert, ptr %6, i32 1
  store ptr %incdec.ptr, ptr %_VtxWritePtr7, align 8
  %_VtxCurrentIdx = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 4
  %7 = load i32, ptr %_VtxCurrentIdx, align 4
  %inc = add i32 %7, 1
  store i32 %inc, ptr %_VtxCurrentIdx, align 4
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList7AddQuadERK6ImVec2S2_S2_S2_jf(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %p1, ptr noundef nonnull align 4 dereferenceable(8) %p2, ptr noundef nonnull align 4 dereferenceable(8) %p3, ptr noundef nonnull align 4 dereferenceable(8) %p4, i32 noundef %col, float noundef %thickness) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p1.addr = alloca ptr, align 8
  %p2.addr = alloca ptr, align 8
  %p3.addr = alloca ptr, align 8
  %p4.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  %thickness.addr = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %p1, ptr %p1.addr, align 8
  store ptr %p2, ptr %p2.addr, align 8
  store ptr %p3, ptr %p3.addr, align 8
  store ptr %p4, ptr %p4.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  store float %thickness, ptr %thickness.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %col.addr, align 4
  %and = and i32 %0, -16777216
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %p1.addr, align 8
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %1)
  %2 = load ptr, ptr %p2.addr, align 8
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %2)
  %3 = load ptr, ptr %p3.addr, align 8
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %3)
  %4 = load ptr, ptr %p4.addr, align 8
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %4)
  %5 = load i32, ptr %col.addr, align 4
  %6 = load float, ptr %thickness.addr, align 4
  call void @_ZN10ImDrawList10PathStrokeEjif(ptr noundef nonnull align 8 dereferenceable(196) %this1, i32 noundef %5, i32 noundef 1, float noundef %6)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList13AddQuadFilledERK6ImVec2S2_S2_S2_j(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %p1, ptr noundef nonnull align 4 dereferenceable(8) %p2, ptr noundef nonnull align 4 dereferenceable(8) %p3, ptr noundef nonnull align 4 dereferenceable(8) %p4, i32 noundef %col) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p1.addr = alloca ptr, align 8
  %p2.addr = alloca ptr, align 8
  %p3.addr = alloca ptr, align 8
  %p4.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %p1, ptr %p1.addr, align 8
  store ptr %p2, ptr %p2.addr, align 8
  store ptr %p3, ptr %p3.addr, align 8
  store ptr %p4, ptr %p4.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %col.addr, align 4
  %and = and i32 %0, -16777216
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %p1.addr, align 8
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %1)
  %2 = load ptr, ptr %p2.addr, align 8
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %2)
  %3 = load ptr, ptr %p3.addr, align 8
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %3)
  %4 = load ptr, ptr %p4.addr, align 8
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %4)
  %5 = load i32, ptr %col.addr, align 4
  call void @_ZN10ImDrawList14PathFillConvexEj(ptr noundef nonnull align 8 dereferenceable(196) %this1, i32 noundef %5)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList11AddTriangleERK6ImVec2S2_S2_jf(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %p1, ptr noundef nonnull align 4 dereferenceable(8) %p2, ptr noundef nonnull align 4 dereferenceable(8) %p3, i32 noundef %col, float noundef %thickness) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p1.addr = alloca ptr, align 8
  %p2.addr = alloca ptr, align 8
  %p3.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  %thickness.addr = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %p1, ptr %p1.addr, align 8
  store ptr %p2, ptr %p2.addr, align 8
  store ptr %p3, ptr %p3.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  store float %thickness, ptr %thickness.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %col.addr, align 4
  %and = and i32 %0, -16777216
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %p1.addr, align 8
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %1)
  %2 = load ptr, ptr %p2.addr, align 8
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %2)
  %3 = load ptr, ptr %p3.addr, align 8
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %3)
  %4 = load i32, ptr %col.addr, align 4
  %5 = load float, ptr %thickness.addr, align 4
  call void @_ZN10ImDrawList10PathStrokeEjif(ptr noundef nonnull align 8 dereferenceable(196) %this1, i32 noundef %4, i32 noundef 1, float noundef %5)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList17AddTriangleFilledERK6ImVec2S2_S2_j(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %p1, ptr noundef nonnull align 4 dereferenceable(8) %p2, ptr noundef nonnull align 4 dereferenceable(8) %p3, i32 noundef %col) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p1.addr = alloca ptr, align 8
  %p2.addr = alloca ptr, align 8
  %p3.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %p1, ptr %p1.addr, align 8
  store ptr %p2, ptr %p2.addr, align 8
  store ptr %p3, ptr %p3.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %col.addr, align 4
  %and = and i32 %0, -16777216
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %p1.addr, align 8
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %1)
  %2 = load ptr, ptr %p2.addr, align 8
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %2)
  %3 = load ptr, ptr %p3.addr, align 8
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %3)
  %4 = load i32, ptr %col.addr, align 4
  call void @_ZN10ImDrawList14PathFillConvexEj(ptr noundef nonnull align 8 dereferenceable(196) %this1, i32 noundef %4)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList9AddCircleERK6ImVec2fjif(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %center, float noundef %radius, i32 noundef %col, i32 noundef %num_segments, float noundef %thickness) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %center.addr = alloca ptr, align 8
  %radius.addr = alloca float, align 4
  %col.addr = alloca i32, align 4
  %num_segments.addr = alloca i32, align 4
  %thickness.addr = alloca float, align 4
  %a_max = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %center, ptr %center.addr, align 8
  store float %radius, ptr %radius.addr, align 4
  store i32 %col, ptr %col.addr, align 4
  store i32 %num_segments, ptr %num_segments.addr, align 4
  store float %thickness, ptr %thickness.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %col.addr, align 4
  %and = and i32 %0, -16777216
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load float, ptr %radius.addr, align 4
  %cmp2 = fcmp olt float %1, 5.000000e-01
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load i32, ptr %num_segments.addr, align 4
  %cmp3 = icmp sle i32 %2, 0
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  %3 = load ptr, ptr %center.addr, align 8
  %4 = load float, ptr %radius.addr, align 4
  %sub = fsub float %4, 5.000000e-01
  call void @_ZN10ImDrawList16_PathArcToFastExERK6ImVec2fiii(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %3, float noundef %sub, i32 noundef 0, i32 noundef 48, i32 noundef 0)
  %_Path = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %Size = getelementptr inbounds %struct.ImVector, ptr %_Path, i32 0, i32 0
  %5 = load i32, ptr %Size, align 8
  %dec = add nsw i32 %5, -1
  store i32 %dec, ptr %Size, align 8
  br label %if.end9

if.else:                                          ; preds = %if.end
  %6 = load i32, ptr %num_segments.addr, align 4
  %call = call noundef i32 @_ZL7ImClampIiET_S0_S0_S0_(i32 noundef %6, i32 noundef 3, i32 noundef 512)
  store i32 %call, ptr %num_segments.addr, align 4
  %7 = load i32, ptr %num_segments.addr, align 4
  %conv = sitofp i32 %7 to float
  %sub5 = fsub float %conv, 1.000000e+00
  %mul = fmul float 0x401921FB60000000, %sub5
  %8 = load i32, ptr %num_segments.addr, align 4
  %conv6 = sitofp i32 %8 to float
  %div = fdiv float %mul, %conv6
  store float %div, ptr %a_max, align 4
  %9 = load ptr, ptr %center.addr, align 8
  %10 = load float, ptr %radius.addr, align 4
  %sub7 = fsub float %10, 5.000000e-01
  %11 = load float, ptr %a_max, align 4
  %12 = load i32, ptr %num_segments.addr, align 4
  %sub8 = sub nsw i32 %12, 1
  call void @_ZN10ImDrawList9PathArcToERK6ImVec2fffi(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %9, float noundef %sub7, float noundef 0.000000e+00, float noundef %11, i32 noundef %sub8)
  br label %if.end9

if.end9:                                          ; preds = %if.else, %if.then4
  %13 = load i32, ptr %col.addr, align 4
  %14 = load float, ptr %thickness.addr, align 4
  call void @_ZN10ImDrawList10PathStrokeEjif(ptr noundef nonnull align 8 dereferenceable(196) %this1, i32 noundef %13, i32 noundef 1, float noundef %14)
  br label %return

return:                                           ; preds = %if.end9, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList15AddCircleFilledERK6ImVec2fji(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %center, float noundef %radius, i32 noundef %col, i32 noundef %num_segments) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %center.addr = alloca ptr, align 8
  %radius.addr = alloca float, align 4
  %col.addr = alloca i32, align 4
  %num_segments.addr = alloca i32, align 4
  %a_max = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %center, ptr %center.addr, align 8
  store float %radius, ptr %radius.addr, align 4
  store i32 %col, ptr %col.addr, align 4
  store i32 %num_segments, ptr %num_segments.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %col.addr, align 4
  %and = and i32 %0, -16777216
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load float, ptr %radius.addr, align 4
  %cmp2 = fcmp olt float %1, 5.000000e-01
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load i32, ptr %num_segments.addr, align 4
  %cmp3 = icmp sle i32 %2, 0
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  %3 = load ptr, ptr %center.addr, align 8
  %4 = load float, ptr %radius.addr, align 4
  call void @_ZN10ImDrawList16_PathArcToFastExERK6ImVec2fiii(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %3, float noundef %4, i32 noundef 0, i32 noundef 48, i32 noundef 0)
  %_Path = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 11
  %Size = getelementptr inbounds %struct.ImVector, ptr %_Path, i32 0, i32 0
  %5 = load i32, ptr %Size, align 8
  %dec = add nsw i32 %5, -1
  store i32 %dec, ptr %Size, align 8
  br label %if.end7

if.else:                                          ; preds = %if.end
  %6 = load i32, ptr %num_segments.addr, align 4
  %call = call noundef i32 @_ZL7ImClampIiET_S0_S0_S0_(i32 noundef %6, i32 noundef 3, i32 noundef 512)
  store i32 %call, ptr %num_segments.addr, align 4
  %7 = load i32, ptr %num_segments.addr, align 4
  %conv = sitofp i32 %7 to float
  %sub = fsub float %conv, 1.000000e+00
  %mul = fmul float 0x401921FB60000000, %sub
  %8 = load i32, ptr %num_segments.addr, align 4
  %conv5 = sitofp i32 %8 to float
  %div = fdiv float %mul, %conv5
  store float %div, ptr %a_max, align 4
  %9 = load ptr, ptr %center.addr, align 8
  %10 = load float, ptr %radius.addr, align 4
  %11 = load float, ptr %a_max, align 4
  %12 = load i32, ptr %num_segments.addr, align 4
  %sub6 = sub nsw i32 %12, 1
  call void @_ZN10ImDrawList9PathArcToERK6ImVec2fffi(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %9, float noundef %10, float noundef 0.000000e+00, float noundef %11, i32 noundef %sub6)
  br label %if.end7

if.end7:                                          ; preds = %if.else, %if.then4
  %13 = load i32, ptr %col.addr, align 4
  call void @_ZN10ImDrawList14PathFillConvexEj(ptr noundef nonnull align 8 dereferenceable(196) %this1, i32 noundef %13)
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList7AddNgonERK6ImVec2fjif(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %center, float noundef %radius, i32 noundef %col, i32 noundef %num_segments, float noundef %thickness) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %center.addr = alloca ptr, align 8
  %radius.addr = alloca float, align 4
  %col.addr = alloca i32, align 4
  %num_segments.addr = alloca i32, align 4
  %thickness.addr = alloca float, align 4
  %a_max = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %center, ptr %center.addr, align 8
  store float %radius, ptr %radius.addr, align 4
  store i32 %col, ptr %col.addr, align 4
  store i32 %num_segments, ptr %num_segments.addr, align 4
  store float %thickness, ptr %thickness.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %col.addr, align 4
  %and = and i32 %0, -16777216
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %num_segments.addr, align 4
  %cmp2 = icmp sle i32 %1, 2
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load i32, ptr %num_segments.addr, align 4
  %conv = sitofp i32 %2 to float
  %sub = fsub float %conv, 1.000000e+00
  %mul = fmul float 0x401921FB60000000, %sub
  %3 = load i32, ptr %num_segments.addr, align 4
  %conv3 = sitofp i32 %3 to float
  %div = fdiv float %mul, %conv3
  store float %div, ptr %a_max, align 4
  %4 = load ptr, ptr %center.addr, align 8
  %5 = load float, ptr %radius.addr, align 4
  %sub4 = fsub float %5, 5.000000e-01
  %6 = load float, ptr %a_max, align 4
  %7 = load i32, ptr %num_segments.addr, align 4
  %sub5 = sub nsw i32 %7, 1
  call void @_ZN10ImDrawList9PathArcToERK6ImVec2fffi(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %4, float noundef %sub4, float noundef 0.000000e+00, float noundef %6, i32 noundef %sub5)
  %8 = load i32, ptr %col.addr, align 4
  %9 = load float, ptr %thickness.addr, align 4
  call void @_ZN10ImDrawList10PathStrokeEjif(ptr noundef nonnull align 8 dereferenceable(196) %this1, i32 noundef %8, i32 noundef 1, float noundef %9)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList13AddNgonFilledERK6ImVec2fji(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %center, float noundef %radius, i32 noundef %col, i32 noundef %num_segments) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %center.addr = alloca ptr, align 8
  %radius.addr = alloca float, align 4
  %col.addr = alloca i32, align 4
  %num_segments.addr = alloca i32, align 4
  %a_max = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %center, ptr %center.addr, align 8
  store float %radius, ptr %radius.addr, align 4
  store i32 %col, ptr %col.addr, align 4
  store i32 %num_segments, ptr %num_segments.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %col.addr, align 4
  %and = and i32 %0, -16777216
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %num_segments.addr, align 4
  %cmp2 = icmp sle i32 %1, 2
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load i32, ptr %num_segments.addr, align 4
  %conv = sitofp i32 %2 to float
  %sub = fsub float %conv, 1.000000e+00
  %mul = fmul float 0x401921FB60000000, %sub
  %3 = load i32, ptr %num_segments.addr, align 4
  %conv3 = sitofp i32 %3 to float
  %div = fdiv float %mul, %conv3
  store float %div, ptr %a_max, align 4
  %4 = load ptr, ptr %center.addr, align 8
  %5 = load float, ptr %radius.addr, align 4
  %6 = load float, ptr %a_max, align 4
  %7 = load i32, ptr %num_segments.addr, align 4
  %sub4 = sub nsw i32 %7, 1
  call void @_ZN10ImDrawList9PathArcToERK6ImVec2fffi(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %4, float noundef %5, float noundef 0.000000e+00, float noundef %6, i32 noundef %sub4)
  %8 = load i32, ptr %col.addr, align 4
  call void @_ZN10ImDrawList14PathFillConvexEj(ptr noundef nonnull align 8 dereferenceable(196) %this1, i32 noundef %8)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList10AddEllipseERK6ImVec2ffjfif(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %center, float noundef %radius_x, float noundef %radius_y, i32 noundef %col, float noundef %rot, i32 noundef %num_segments, float noundef %thickness) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %center.addr = alloca ptr, align 8
  %radius_x.addr = alloca float, align 4
  %radius_y.addr = alloca float, align 4
  %col.addr = alloca i32, align 4
  %rot.addr = alloca float, align 4
  %num_segments.addr = alloca i32, align 4
  %thickness.addr = alloca float, align 4
  %a_max = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %center, ptr %center.addr, align 8
  store float %radius_x, ptr %radius_x.addr, align 4
  store float %radius_y, ptr %radius_y.addr, align 4
  store i32 %col, ptr %col.addr, align 4
  store float %rot, ptr %rot.addr, align 4
  store i32 %num_segments, ptr %num_segments.addr, align 4
  store float %thickness, ptr %thickness.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %col.addr, align 4
  %and = and i32 %0, -16777216
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, ptr %num_segments.addr, align 4
  %cmp2 = icmp sle i32 %1, 0
  br i1 %cmp2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %2 = load float, ptr %radius_x.addr, align 4
  %3 = load float, ptr %radius_y.addr, align 4
  %call = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %2, float noundef %3)
  %call4 = call noundef i32 @_ZNK10ImDrawList27_CalcCircleAutoSegmentCountEf(ptr noundef nonnull align 8 dereferenceable(196) %this1, float noundef %call)
  store i32 %call4, ptr %num_segments.addr, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %4 = load i32, ptr %num_segments.addr, align 4
  %conv = sitofp i32 %4 to float
  %sub = fsub float %conv, 1.000000e+00
  %mul = fmul float 0x401921FB60000000, %sub
  %5 = load i32, ptr %num_segments.addr, align 4
  %conv6 = sitofp i32 %5 to float
  %div = fdiv float %mul, %conv6
  store float %div, ptr %a_max, align 4
  %6 = load ptr, ptr %center.addr, align 8
  %7 = load float, ptr %radius_x.addr, align 4
  %8 = load float, ptr %radius_y.addr, align 4
  %9 = load float, ptr %rot.addr, align 4
  %10 = load float, ptr %a_max, align 4
  %11 = load i32, ptr %num_segments.addr, align 4
  %sub7 = sub nsw i32 %11, 1
  call void @_ZN10ImDrawList19PathEllipticalArcToERK6ImVec2fffffi(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %6, float noundef %7, float noundef %8, float noundef %9, float noundef 0.000000e+00, float noundef %10, i32 noundef %sub7)
  %12 = load i32, ptr %col.addr, align 4
  %13 = load float, ptr %thickness.addr, align 4
  call void @_ZN10ImDrawList10PathStrokeEjif(ptr noundef nonnull align 8 dereferenceable(196) %this1, i32 noundef %12, i32 noundef 1, float noundef %13)
  br label %return

return:                                           ; preds = %if.end5, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList16AddEllipseFilledERK6ImVec2ffjfi(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %center, float noundef %radius_x, float noundef %radius_y, i32 noundef %col, float noundef %rot, i32 noundef %num_segments) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %center.addr = alloca ptr, align 8
  %radius_x.addr = alloca float, align 4
  %radius_y.addr = alloca float, align 4
  %col.addr = alloca i32, align 4
  %rot.addr = alloca float, align 4
  %num_segments.addr = alloca i32, align 4
  %a_max = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %center, ptr %center.addr, align 8
  store float %radius_x, ptr %radius_x.addr, align 4
  store float %radius_y, ptr %radius_y.addr, align 4
  store i32 %col, ptr %col.addr, align 4
  store float %rot, ptr %rot.addr, align 4
  store i32 %num_segments, ptr %num_segments.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %col.addr, align 4
  %and = and i32 %0, -16777216
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, ptr %num_segments.addr, align 4
  %cmp2 = icmp sle i32 %1, 0
  br i1 %cmp2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %2 = load float, ptr %radius_x.addr, align 4
  %3 = load float, ptr %radius_y.addr, align 4
  %call = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %2, float noundef %3)
  %call4 = call noundef i32 @_ZNK10ImDrawList27_CalcCircleAutoSegmentCountEf(ptr noundef nonnull align 8 dereferenceable(196) %this1, float noundef %call)
  store i32 %call4, ptr %num_segments.addr, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %4 = load i32, ptr %num_segments.addr, align 4
  %conv = sitofp i32 %4 to float
  %sub = fsub float %conv, 1.000000e+00
  %mul = fmul float 0x401921FB60000000, %sub
  %5 = load i32, ptr %num_segments.addr, align 4
  %conv6 = sitofp i32 %5 to float
  %div = fdiv float %mul, %conv6
  store float %div, ptr %a_max, align 4
  %6 = load ptr, ptr %center.addr, align 8
  %7 = load float, ptr %radius_x.addr, align 4
  %8 = load float, ptr %radius_y.addr, align 4
  %9 = load float, ptr %rot.addr, align 4
  %10 = load float, ptr %a_max, align 4
  %11 = load i32, ptr %num_segments.addr, align 4
  %sub7 = sub nsw i32 %11, 1
  call void @_ZN10ImDrawList19PathEllipticalArcToERK6ImVec2fffffi(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %6, float noundef %7, float noundef %8, float noundef %9, float noundef 0.000000e+00, float noundef %10, i32 noundef %sub7)
  %12 = load i32, ptr %col.addr, align 4
  call void @_ZN10ImDrawList14PathFillConvexEj(ptr noundef nonnull align 8 dereferenceable(196) %this1, i32 noundef %12)
  br label %return

return:                                           ; preds = %if.end5, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList14AddBezierCubicERK6ImVec2S2_S2_S2_jfi(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %p1, ptr noundef nonnull align 4 dereferenceable(8) %p2, ptr noundef nonnull align 4 dereferenceable(8) %p3, ptr noundef nonnull align 4 dereferenceable(8) %p4, i32 noundef %col, float noundef %thickness, i32 noundef %num_segments) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p1.addr = alloca ptr, align 8
  %p2.addr = alloca ptr, align 8
  %p3.addr = alloca ptr, align 8
  %p4.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  %thickness.addr = alloca float, align 4
  %num_segments.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %p1, ptr %p1.addr, align 8
  store ptr %p2, ptr %p2.addr, align 8
  store ptr %p3, ptr %p3.addr, align 8
  store ptr %p4, ptr %p4.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  store float %thickness, ptr %thickness.addr, align 4
  store i32 %num_segments, ptr %num_segments.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %col.addr, align 4
  %and = and i32 %0, -16777216
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %p1.addr, align 8
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %1)
  %2 = load ptr, ptr %p2.addr, align 8
  %3 = load ptr, ptr %p3.addr, align 8
  %4 = load ptr, ptr %p4.addr, align 8
  %5 = load i32, ptr %num_segments.addr, align 4
  call void @_ZN10ImDrawList22PathBezierCubicCurveToERK6ImVec2S2_S2_i(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %2, ptr noundef nonnull align 4 dereferenceable(8) %3, ptr noundef nonnull align 4 dereferenceable(8) %4, i32 noundef %5)
  %6 = load i32, ptr %col.addr, align 4
  %7 = load float, ptr %thickness.addr, align 4
  call void @_ZN10ImDrawList10PathStrokeEjif(ptr noundef nonnull align 8 dereferenceable(196) %this1, i32 noundef %6, i32 noundef 0, float noundef %7)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList18AddBezierQuadraticERK6ImVec2S2_S2_jfi(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %p1, ptr noundef nonnull align 4 dereferenceable(8) %p2, ptr noundef nonnull align 4 dereferenceable(8) %p3, i32 noundef %col, float noundef %thickness, i32 noundef %num_segments) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p1.addr = alloca ptr, align 8
  %p2.addr = alloca ptr, align 8
  %p3.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  %thickness.addr = alloca float, align 4
  %num_segments.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %p1, ptr %p1.addr, align 8
  store ptr %p2, ptr %p2.addr, align 8
  store ptr %p3, ptr %p3.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  store float %thickness, ptr %thickness.addr, align 4
  store i32 %num_segments, ptr %num_segments.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %col.addr, align 4
  %and = and i32 %0, -16777216
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %p1.addr, align 8
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %1)
  %2 = load ptr, ptr %p2.addr, align 8
  %3 = load ptr, ptr %p3.addr, align 8
  %4 = load i32, ptr %num_segments.addr, align 4
  call void @_ZN10ImDrawList26PathBezierQuadraticCurveToERK6ImVec2S2_i(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %2, ptr noundef nonnull align 4 dereferenceable(8) %3, i32 noundef %4)
  %5 = load i32, ptr %col.addr, align 4
  %6 = load float, ptr %thickness.addr, align 4
  call void @_ZN10ImDrawList10PathStrokeEjif(ptr noundef nonnull align 8 dereferenceable(196) %this1, i32 noundef %5, i32 noundef 0, float noundef %6)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList7AddTextEPK6ImFontfRK6ImVec2jPKcS7_fPK6ImVec4(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef %font, float noundef %font_size, ptr noundef nonnull align 4 dereferenceable(8) %pos, i32 noundef %col, ptr noundef %text_begin, ptr noundef %text_end, float noundef %wrap_width, ptr noundef %cpu_fine_clip_rect) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %font.addr = alloca ptr, align 8
  %font_size.addr = alloca float, align 4
  %pos.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  %text_begin.addr = alloca ptr, align 8
  %text_end.addr = alloca ptr, align 8
  %wrap_width.addr = alloca float, align 4
  %cpu_fine_clip_rect.addr = alloca ptr, align 8
  %clip_rect = alloca %struct.ImVec4, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %font, ptr %font.addr, align 8
  store float %font_size, ptr %font_size.addr, align 4
  store ptr %pos, ptr %pos.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  store ptr %text_begin, ptr %text_begin.addr, align 8
  store ptr %text_end, ptr %text_end.addr, align 8
  store float %wrap_width, ptr %wrap_width.addr, align 4
  store ptr %cpu_fine_clip_rect, ptr %cpu_fine_clip_rect.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %col.addr, align 4
  %and = and i32 %0, -16777216
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %text_end.addr, align 8
  %cmp2 = icmp eq ptr %1, null
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %2 = load ptr, ptr %text_begin.addr, align 8
  %3 = load ptr, ptr %text_begin.addr, align 8
  %call = call i64 @strlen(ptr noundef %3) #14
  %add.ptr = getelementptr inbounds i8, ptr %2, i64 %call
  store ptr %add.ptr, ptr %text_end.addr, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %4 = load ptr, ptr %text_begin.addr, align 8
  %5 = load ptr, ptr %text_end.addr, align 8
  %cmp5 = icmp eq ptr %4, %5
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  br label %return

if.end7:                                          ; preds = %if.end4
  %6 = load ptr, ptr %font.addr, align 8
  %cmp8 = icmp eq ptr %6, null
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end7
  %_Data = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  %7 = load ptr, ptr %_Data, align 8
  %Font = getelementptr inbounds %struct.ImDrawListSharedData, ptr %7, i32 0, i32 1
  %8 = load ptr, ptr %Font, align 8
  store ptr %8, ptr %font.addr, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.end7
  %9 = load float, ptr %font_size.addr, align 4
  %cmp11 = fcmp oeq float %9, 0.000000e+00
  br i1 %cmp11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end10
  %_Data13 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 5
  %10 = load ptr, ptr %_Data13, align 8
  %FontSize = getelementptr inbounds %struct.ImDrawListSharedData, ptr %10, i32 0, i32 2
  %11 = load float, ptr %FontSize, align 8
  store float %11, ptr %font_size.addr, align 4
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end10
  %_CmdHeader = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 12
  %ClipRect = getelementptr inbounds %struct.ImDrawCmdHeader, ptr %_CmdHeader, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %clip_rect, ptr align 8 %ClipRect, i64 16, i1 false)
  %12 = load ptr, ptr %cpu_fine_clip_rect.addr, align 8
  %tobool = icmp ne ptr %12, null
  br i1 %tobool, label %if.then15, label %if.end28

if.then15:                                        ; preds = %if.end14
  %x = getelementptr inbounds %struct.ImVec4, ptr %clip_rect, i32 0, i32 0
  %13 = load float, ptr %x, align 4
  %14 = load ptr, ptr %cpu_fine_clip_rect.addr, align 8
  %x16 = getelementptr inbounds %struct.ImVec4, ptr %14, i32 0, i32 0
  %15 = load float, ptr %x16, align 4
  %call17 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %13, float noundef %15)
  %x18 = getelementptr inbounds %struct.ImVec4, ptr %clip_rect, i32 0, i32 0
  store float %call17, ptr %x18, align 4
  %y = getelementptr inbounds %struct.ImVec4, ptr %clip_rect, i32 0, i32 1
  %16 = load float, ptr %y, align 4
  %17 = load ptr, ptr %cpu_fine_clip_rect.addr, align 8
  %y19 = getelementptr inbounds %struct.ImVec4, ptr %17, i32 0, i32 1
  %18 = load float, ptr %y19, align 4
  %call20 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %16, float noundef %18)
  %y21 = getelementptr inbounds %struct.ImVec4, ptr %clip_rect, i32 0, i32 1
  store float %call20, ptr %y21, align 4
  %z = getelementptr inbounds %struct.ImVec4, ptr %clip_rect, i32 0, i32 2
  %19 = load float, ptr %z, align 4
  %20 = load ptr, ptr %cpu_fine_clip_rect.addr, align 8
  %z22 = getelementptr inbounds %struct.ImVec4, ptr %20, i32 0, i32 2
  %21 = load float, ptr %z22, align 4
  %call23 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %19, float noundef %21)
  %z24 = getelementptr inbounds %struct.ImVec4, ptr %clip_rect, i32 0, i32 2
  store float %call23, ptr %z24, align 4
  %w = getelementptr inbounds %struct.ImVec4, ptr %clip_rect, i32 0, i32 3
  %22 = load float, ptr %w, align 4
  %23 = load ptr, ptr %cpu_fine_clip_rect.addr, align 8
  %w25 = getelementptr inbounds %struct.ImVec4, ptr %23, i32 0, i32 3
  %24 = load float, ptr %w25, align 4
  %call26 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %22, float noundef %24)
  %w27 = getelementptr inbounds %struct.ImVec4, ptr %clip_rect, i32 0, i32 3
  store float %call26, ptr %w27, align 4
  br label %if.end28

if.end28:                                         ; preds = %if.then15, %if.end14
  %25 = load ptr, ptr %font.addr, align 8
  %26 = load float, ptr %font_size.addr, align 4
  %27 = load ptr, ptr %pos.addr, align 8
  %28 = load i32, ptr %col.addr, align 4
  %29 = load ptr, ptr %text_begin.addr, align 8
  %30 = load ptr, ptr %text_end.addr, align 8
  %31 = load float, ptr %wrap_width.addr, align 4
  %32 = load ptr, ptr %cpu_fine_clip_rect.addr, align 8
  %cmp29 = icmp ne ptr %32, null
  call void @_ZNK6ImFont10RenderTextEP10ImDrawListfRK6ImVec2jRK6ImVec4PKcS9_fb(ptr noundef nonnull align 8 dereferenceable(118) %25, ptr noundef %this1, float noundef %26, ptr noundef nonnull align 4 dereferenceable(8) %27, i32 noundef %28, ptr noundef nonnull align 4 dereferenceable(16) %clip_rect, ptr noundef %29, ptr noundef %30, float noundef %31, i1 noundef zeroext %cmp29)
  br label %return

return:                                           ; preds = %if.end28, %if.then6, %if.then
  ret void
}

; Function Attrs: nounwind willreturn memory(read)
declare i64 @strlen(ptr noundef) #8

; Function Attrs: mustprogress uwtable
define void @_ZNK6ImFont10RenderTextEP10ImDrawListfRK6ImVec2jRK6ImVec4PKcS9_fb(ptr noundef nonnull align 8 dereferenceable(118) %this, ptr noundef %draw_list, float noundef %size, ptr noundef nonnull align 4 dereferenceable(8) %pos, i32 noundef %col, ptr noundef nonnull align 4 dereferenceable(16) %clip_rect, ptr noundef %text_begin, ptr noundef %text_end, float noundef %wrap_width, i1 noundef zeroext %cpu_fine_clip) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %draw_list.addr = alloca ptr, align 8
  %size.addr = alloca float, align 4
  %pos.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  %clip_rect.addr = alloca ptr, align 8
  %text_begin.addr = alloca ptr, align 8
  %text_end.addr = alloca ptr, align 8
  %wrap_width.addr = alloca float, align 4
  %cpu_fine_clip.addr = alloca i8, align 1
  %x = alloca float, align 4
  %y = alloca float, align 4
  %start_x = alloca float, align 4
  %scale = alloca float, align 4
  %line_height = alloca float, align 4
  %word_wrap_enabled = alloca i8, align 1
  %s = alloca ptr, align 8
  %line_end = alloca ptr, align 8
  %s_end = alloca ptr, align 8
  %y_end = alloca float, align 4
  %vtx_count_max = alloca i32, align 4
  %idx_count_max = alloca i32, align 4
  %idx_expected_size = alloca i32, align 4
  %vtx_write = alloca ptr, align 8
  %idx_write = alloca ptr, align 8
  %vtx_index = alloca i32, align 4
  %col_untinted = alloca i32, align 4
  %word_wrap_eol = alloca ptr, align 8
  %c = alloca i32, align 4
  %glyph = alloca ptr, align 8
  %char_width = alloca float, align 4
  %x1 = alloca float, align 4
  %x2121 = alloca float, align 4
  %y1 = alloca float, align 4
  %y2 = alloca float, align 4
  %u1 = alloca float, align 4
  %v1 = alloca float, align 4
  %u2 = alloca float, align 4
  %v2 = alloca float, align 4
  %glyph_col = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %draw_list, ptr %draw_list.addr, align 8
  store float %size, ptr %size.addr, align 4
  store ptr %pos, ptr %pos.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  store ptr %clip_rect, ptr %clip_rect.addr, align 8
  store ptr %text_begin, ptr %text_begin.addr, align 8
  store ptr %text_end, ptr %text_end.addr, align 8
  store float %wrap_width, ptr %wrap_width.addr, align 4
  %frombool = zext i1 %cpu_fine_clip to i8
  store i8 %frombool, ptr %cpu_fine_clip.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %text_end.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %text_begin.addr, align 8
  %2 = load ptr, ptr %text_begin.addr, align 8
  %call = call i64 @strlen(ptr noundef %2) #14
  %add.ptr = getelementptr inbounds i8, ptr %1, i64 %call
  store ptr %add.ptr, ptr %text_end.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load ptr, ptr %pos.addr, align 8
  %x2 = getelementptr inbounds %struct.ImVec2, ptr %3, i32 0, i32 0
  %4 = load float, ptr %x2, align 4
  %conv = fptosi float %4 to i32
  %conv3 = sitofp i32 %conv to float
  store float %conv3, ptr %x, align 4
  %5 = load ptr, ptr %pos.addr, align 8
  %y4 = getelementptr inbounds %struct.ImVec2, ptr %5, i32 0, i32 1
  %6 = load float, ptr %y4, align 4
  %conv5 = fptosi float %6 to i32
  %conv6 = sitofp i32 %conv5 to float
  store float %conv6, ptr %y, align 4
  %7 = load float, ptr %y, align 4
  %8 = load ptr, ptr %clip_rect.addr, align 8
  %w = getelementptr inbounds %struct.ImVec4, ptr %8, i32 0, i32 3
  %9 = load float, ptr %w, align 4
  %cmp = fcmp ogt float %7, %9
  br i1 %cmp, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  br label %return

if.end8:                                          ; preds = %if.end
  %10 = load float, ptr %x, align 4
  store float %10, ptr %start_x, align 4
  %11 = load float, ptr %size.addr, align 4
  %FontSize = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 2
  %12 = load float, ptr %FontSize, align 4
  %div = fdiv float %11, %12
  store float %div, ptr %scale, align 4
  %FontSize9 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 2
  %13 = load float, ptr %FontSize9, align 4
  %14 = load float, ptr %scale, align 4
  %mul = fmul float %13, %14
  store float %mul, ptr %line_height, align 4
  %15 = load float, ptr %wrap_width.addr, align 4
  %cmp10 = fcmp ogt float %15, 0.000000e+00
  %frombool11 = zext i1 %cmp10 to i8
  store i8 %frombool11, ptr %word_wrap_enabled, align 1
  %16 = load ptr, ptr %text_begin.addr, align 8
  store ptr %16, ptr %s, align 8
  %17 = load float, ptr %y, align 4
  %18 = load float, ptr %line_height, align 4
  %add = fadd float %17, %18
  %19 = load ptr, ptr %clip_rect.addr, align 8
  %y12 = getelementptr inbounds %struct.ImVec4, ptr %19, i32 0, i32 1
  %20 = load float, ptr %y12, align 4
  %cmp13 = fcmp olt float %add, %20
  br i1 %cmp13, label %if.then14, label %if.end33

if.then14:                                        ; preds = %if.end8
  br label %while.cond

while.cond:                                       ; preds = %if.end31, %if.then14
  %21 = load float, ptr %y, align 4
  %22 = load float, ptr %line_height, align 4
  %add15 = fadd float %21, %22
  %23 = load ptr, ptr %clip_rect.addr, align 8
  %y16 = getelementptr inbounds %struct.ImVec4, ptr %23, i32 0, i32 1
  %24 = load float, ptr %y16, align 4
  %cmp17 = fcmp olt float %add15, %24
  br i1 %cmp17, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %25 = load ptr, ptr %s, align 8
  %26 = load ptr, ptr %text_end.addr, align 8
  %cmp18 = icmp ult ptr %25, %26
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %27 = phi i1 [ false, %while.cond ], [ %cmp18, %land.rhs ]
  br i1 %27, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %28 = load ptr, ptr %s, align 8
  %29 = load ptr, ptr %text_end.addr, align 8
  %30 = load ptr, ptr %s, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %29 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %30 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call19 = call noundef ptr @memchr(ptr noundef %28, i32 noundef 10, i64 noundef %sub.ptr.sub) #14
  store ptr %call19, ptr %line_end, align 8
  %31 = load i8, ptr %word_wrap_enabled, align 1
  %tobool20 = trunc i8 %31 to i1
  br i1 %tobool20, label %if.then21, label %if.else

if.then21:                                        ; preds = %while.body
  %32 = load float, ptr %scale, align 4
  %33 = load ptr, ptr %s, align 8
  %34 = load ptr, ptr %line_end, align 8
  %tobool22 = icmp ne ptr %34, null
  br i1 %tobool22, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then21
  %35 = load ptr, ptr %line_end, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then21
  %36 = load ptr, ptr %text_end.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %35, %cond.true ], [ %36, %cond.false ]
  %37 = load float, ptr %wrap_width.addr, align 4
  %call23 = call noundef ptr @_ZNK6ImFont21CalcWordWrapPositionAEfPKcS1_f(ptr noundef nonnull align 8 dereferenceable(118) %this1, float noundef %32, ptr noundef %33, ptr noundef %cond, float noundef %37)
  store ptr %call23, ptr %s, align 8
  %38 = load ptr, ptr %s, align 8
  %39 = load ptr, ptr %text_end.addr, align 8
  %call24 = call noundef ptr @_ZL26CalcWordWrapNextLineStartAPKcS0_(ptr noundef %38, ptr noundef %39)
  store ptr %call24, ptr %s, align 8
  br label %if.end31

if.else:                                          ; preds = %while.body
  %40 = load ptr, ptr %line_end, align 8
  %tobool25 = icmp ne ptr %40, null
  br i1 %tobool25, label %cond.true26, label %cond.false28

cond.true26:                                      ; preds = %if.else
  %41 = load ptr, ptr %line_end, align 8
  %add.ptr27 = getelementptr inbounds i8, ptr %41, i64 1
  br label %cond.end29

cond.false28:                                     ; preds = %if.else
  %42 = load ptr, ptr %text_end.addr, align 8
  br label %cond.end29

cond.end29:                                       ; preds = %cond.false28, %cond.true26
  %cond30 = phi ptr [ %add.ptr27, %cond.true26 ], [ %42, %cond.false28 ]
  store ptr %cond30, ptr %s, align 8
  br label %if.end31

if.end31:                                         ; preds = %cond.end29, %cond.end
  %43 = load float, ptr %line_height, align 4
  %44 = load float, ptr %y, align 4
  %add32 = fadd float %44, %43
  store float %add32, ptr %y, align 4
  br label %while.cond, !llvm.loop !30

while.end:                                        ; preds = %land.end
  br label %if.end33

if.end33:                                         ; preds = %while.end, %if.end8
  %45 = load ptr, ptr %text_end.addr, align 8
  %46 = load ptr, ptr %s, align 8
  %sub.ptr.lhs.cast34 = ptrtoint ptr %45 to i64
  %sub.ptr.rhs.cast35 = ptrtoint ptr %46 to i64
  %sub.ptr.sub36 = sub i64 %sub.ptr.lhs.cast34, %sub.ptr.rhs.cast35
  %cmp37 = icmp sgt i64 %sub.ptr.sub36, 10000
  br i1 %cmp37, label %land.lhs.true, label %if.end59

land.lhs.true:                                    ; preds = %if.end33
  %47 = load i8, ptr %word_wrap_enabled, align 1
  %tobool38 = trunc i8 %47 to i1
  br i1 %tobool38, label %if.end59, label %if.then39

if.then39:                                        ; preds = %land.lhs.true
  %48 = load ptr, ptr %s, align 8
  store ptr %48, ptr %s_end, align 8
  %49 = load float, ptr %y, align 4
  store float %49, ptr %y_end, align 4
  br label %while.cond40

while.cond40:                                     ; preds = %cond.end55, %if.then39
  %50 = load float, ptr %y_end, align 4
  %51 = load ptr, ptr %clip_rect.addr, align 8
  %w41 = getelementptr inbounds %struct.ImVec4, ptr %51, i32 0, i32 3
  %52 = load float, ptr %w41, align 4
  %cmp42 = fcmp olt float %50, %52
  br i1 %cmp42, label %land.rhs43, label %land.end45

land.rhs43:                                       ; preds = %while.cond40
  %53 = load ptr, ptr %s_end, align 8
  %54 = load ptr, ptr %text_end.addr, align 8
  %cmp44 = icmp ult ptr %53, %54
  br label %land.end45

land.end45:                                       ; preds = %land.rhs43, %while.cond40
  %55 = phi i1 [ false, %while.cond40 ], [ %cmp44, %land.rhs43 ]
  br i1 %55, label %while.body46, label %while.end58

while.body46:                                     ; preds = %land.end45
  %56 = load ptr, ptr %s_end, align 8
  %57 = load ptr, ptr %text_end.addr, align 8
  %58 = load ptr, ptr %s_end, align 8
  %sub.ptr.lhs.cast47 = ptrtoint ptr %57 to i64
  %sub.ptr.rhs.cast48 = ptrtoint ptr %58 to i64
  %sub.ptr.sub49 = sub i64 %sub.ptr.lhs.cast47, %sub.ptr.rhs.cast48
  %call50 = call noundef ptr @memchr(ptr noundef %56, i32 noundef 10, i64 noundef %sub.ptr.sub49) #14
  store ptr %call50, ptr %s_end, align 8
  %59 = load ptr, ptr %s_end, align 8
  %tobool51 = icmp ne ptr %59, null
  br i1 %tobool51, label %cond.true52, label %cond.false54

cond.true52:                                      ; preds = %while.body46
  %60 = load ptr, ptr %s_end, align 8
  %add.ptr53 = getelementptr inbounds i8, ptr %60, i64 1
  br label %cond.end55

cond.false54:                                     ; preds = %while.body46
  %61 = load ptr, ptr %text_end.addr, align 8
  br label %cond.end55

cond.end55:                                       ; preds = %cond.false54, %cond.true52
  %cond56 = phi ptr [ %add.ptr53, %cond.true52 ], [ %61, %cond.false54 ]
  store ptr %cond56, ptr %s_end, align 8
  %62 = load float, ptr %line_height, align 4
  %63 = load float, ptr %y_end, align 4
  %add57 = fadd float %63, %62
  store float %add57, ptr %y_end, align 4
  br label %while.cond40, !llvm.loop !31

while.end58:                                      ; preds = %land.end45
  %64 = load ptr, ptr %s_end, align 8
  store ptr %64, ptr %text_end.addr, align 8
  br label %if.end59

if.end59:                                         ; preds = %while.end58, %land.lhs.true, %if.end33
  %65 = load ptr, ptr %s, align 8
  %66 = load ptr, ptr %text_end.addr, align 8
  %cmp60 = icmp eq ptr %65, %66
  br i1 %cmp60, label %if.then61, label %if.end62

if.then61:                                        ; preds = %if.end59
  br label %return

if.end62:                                         ; preds = %if.end59
  %67 = load ptr, ptr %text_end.addr, align 8
  %68 = load ptr, ptr %s, align 8
  %sub.ptr.lhs.cast63 = ptrtoint ptr %67 to i64
  %sub.ptr.rhs.cast64 = ptrtoint ptr %68 to i64
  %sub.ptr.sub65 = sub i64 %sub.ptr.lhs.cast63, %sub.ptr.rhs.cast64
  %conv66 = trunc i64 %sub.ptr.sub65 to i32
  %mul67 = mul nsw i32 %conv66, 4
  store i32 %mul67, ptr %vtx_count_max, align 4
  %69 = load ptr, ptr %text_end.addr, align 8
  %70 = load ptr, ptr %s, align 8
  %sub.ptr.lhs.cast68 = ptrtoint ptr %69 to i64
  %sub.ptr.rhs.cast69 = ptrtoint ptr %70 to i64
  %sub.ptr.sub70 = sub i64 %sub.ptr.lhs.cast68, %sub.ptr.rhs.cast69
  %conv71 = trunc i64 %sub.ptr.sub70 to i32
  %mul72 = mul nsw i32 %conv71, 6
  store i32 %mul72, ptr %idx_count_max, align 4
  %71 = load ptr, ptr %draw_list.addr, align 8
  %IdxBuffer = getelementptr inbounds %struct.ImDrawList, ptr %71, i32 0, i32 1
  %Size = getelementptr inbounds %struct.ImVector.1, ptr %IdxBuffer, i32 0, i32 0
  %72 = load i32, ptr %Size, align 8
  %73 = load i32, ptr %idx_count_max, align 4
  %add73 = add nsw i32 %72, %73
  store i32 %add73, ptr %idx_expected_size, align 4
  %74 = load ptr, ptr %draw_list.addr, align 8
  %75 = load i32, ptr %idx_count_max, align 4
  %76 = load i32, ptr %vtx_count_max, align 4
  call void @_ZN10ImDrawList11PrimReserveEii(ptr noundef nonnull align 8 dereferenceable(196) %74, i32 noundef %75, i32 noundef %76)
  %77 = load ptr, ptr %draw_list.addr, align 8
  %_VtxWritePtr = getelementptr inbounds %struct.ImDrawList, ptr %77, i32 0, i32 7
  %78 = load ptr, ptr %_VtxWritePtr, align 8
  store ptr %78, ptr %vtx_write, align 8
  %79 = load ptr, ptr %draw_list.addr, align 8
  %_IdxWritePtr = getelementptr inbounds %struct.ImDrawList, ptr %79, i32 0, i32 8
  %80 = load ptr, ptr %_IdxWritePtr, align 8
  store ptr %80, ptr %idx_write, align 8
  %81 = load ptr, ptr %draw_list.addr, align 8
  %_VtxCurrentIdx = getelementptr inbounds %struct.ImDrawList, ptr %81, i32 0, i32 4
  %82 = load i32, ptr %_VtxCurrentIdx, align 4
  store i32 %82, ptr %vtx_index, align 4
  %83 = load i32, ptr %col.addr, align 4
  %or = or i32 %83, 16777215
  store i32 %or, ptr %col_untinted, align 4
  store ptr null, ptr %word_wrap_eol, align 8
  br label %while.cond74

while.cond74:                                     ; preds = %if.end264, %if.then179, %if.then115, %if.then109, %if.end106, %if.then85, %if.end62
  %84 = load ptr, ptr %s, align 8
  %85 = load ptr, ptr %text_end.addr, align 8
  %cmp75 = icmp ult ptr %84, %85
  br i1 %cmp75, label %while.body76, label %while.end266

while.body76:                                     ; preds = %while.cond74
  %86 = load i8, ptr %word_wrap_enabled, align 1
  %tobool77 = trunc i8 %86 to i1
  br i1 %tobool77, label %if.then78, label %if.end89

if.then78:                                        ; preds = %while.body76
  %87 = load ptr, ptr %word_wrap_eol, align 8
  %tobool79 = icmp ne ptr %87, null
  br i1 %tobool79, label %if.end83, label %if.then80

if.then80:                                        ; preds = %if.then78
  %88 = load float, ptr %scale, align 4
  %89 = load ptr, ptr %s, align 8
  %90 = load ptr, ptr %text_end.addr, align 8
  %91 = load float, ptr %wrap_width.addr, align 4
  %92 = load float, ptr %x, align 4
  %93 = load float, ptr %start_x, align 4
  %sub = fsub float %92, %93
  %sub81 = fsub float %91, %sub
  %call82 = call noundef ptr @_ZNK6ImFont21CalcWordWrapPositionAEfPKcS1_f(ptr noundef nonnull align 8 dereferenceable(118) %this1, float noundef %88, ptr noundef %89, ptr noundef %90, float noundef %sub81)
  store ptr %call82, ptr %word_wrap_eol, align 8
  br label %if.end83

if.end83:                                         ; preds = %if.then80, %if.then78
  %94 = load ptr, ptr %s, align 8
  %95 = load ptr, ptr %word_wrap_eol, align 8
  %cmp84 = icmp uge ptr %94, %95
  br i1 %cmp84, label %if.then85, label %if.end88

if.then85:                                        ; preds = %if.end83
  %96 = load float, ptr %start_x, align 4
  store float %96, ptr %x, align 4
  %97 = load float, ptr %line_height, align 4
  %98 = load float, ptr %y, align 4
  %add86 = fadd float %98, %97
  store float %add86, ptr %y, align 4
  store ptr null, ptr %word_wrap_eol, align 8
  %99 = load ptr, ptr %s, align 8
  %100 = load ptr, ptr %text_end.addr, align 8
  %call87 = call noundef ptr @_ZL26CalcWordWrapNextLineStartAPKcS0_(ptr noundef %99, ptr noundef %100)
  store ptr %call87, ptr %s, align 8
  br label %while.cond74, !llvm.loop !32

if.end88:                                         ; preds = %if.end83
  br label %if.end89

if.end89:                                         ; preds = %if.end88, %while.body76
  %101 = load ptr, ptr %s, align 8
  %102 = load i8, ptr %101, align 1
  %conv90 = sext i8 %102 to i32
  store i32 %conv90, ptr %c, align 4
  %103 = load i32, ptr %c, align 4
  %cmp91 = icmp ult i32 %103, 128
  br i1 %cmp91, label %if.then92, label %if.else94

if.then92:                                        ; preds = %if.end89
  %104 = load ptr, ptr %s, align 8
  %add.ptr93 = getelementptr inbounds i8, ptr %104, i64 1
  store ptr %add.ptr93, ptr %s, align 8
  br label %if.end97

if.else94:                                        ; preds = %if.end89
  %105 = load ptr, ptr %s, align 8
  %106 = load ptr, ptr %text_end.addr, align 8
  %call95 = call noundef i32 @_Z18ImTextCharFromUtf8PjPKcS1_(ptr noundef %c, ptr noundef %105, ptr noundef %106)
  %107 = load ptr, ptr %s, align 8
  %idx.ext = sext i32 %call95 to i64
  %add.ptr96 = getelementptr inbounds i8, ptr %107, i64 %idx.ext
  store ptr %add.ptr96, ptr %s, align 8
  br label %if.end97

if.end97:                                         ; preds = %if.else94, %if.then92
  %108 = load i32, ptr %c, align 4
  %cmp98 = icmp ult i32 %108, 32
  br i1 %cmp98, label %if.then99, label %if.end111

if.then99:                                        ; preds = %if.end97
  %109 = load i32, ptr %c, align 4
  %cmp100 = icmp eq i32 %109, 10
  br i1 %cmp100, label %if.then101, label %if.end107

if.then101:                                       ; preds = %if.then99
  %110 = load float, ptr %start_x, align 4
  store float %110, ptr %x, align 4
  %111 = load float, ptr %line_height, align 4
  %112 = load float, ptr %y, align 4
  %add102 = fadd float %112, %111
  store float %add102, ptr %y, align 4
  %113 = load float, ptr %y, align 4
  %114 = load ptr, ptr %clip_rect.addr, align 8
  %w103 = getelementptr inbounds %struct.ImVec4, ptr %114, i32 0, i32 3
  %115 = load float, ptr %w103, align 4
  %cmp104 = fcmp ogt float %113, %115
  br i1 %cmp104, label %if.then105, label %if.end106

if.then105:                                       ; preds = %if.then101
  br label %while.end266

if.end106:                                        ; preds = %if.then101
  br label %while.cond74, !llvm.loop !32

if.end107:                                        ; preds = %if.then99
  %116 = load i32, ptr %c, align 4
  %cmp108 = icmp eq i32 %116, 13
  br i1 %cmp108, label %if.then109, label %if.end110

if.then109:                                       ; preds = %if.end107
  br label %while.cond74, !llvm.loop !32

if.end110:                                        ; preds = %if.end107
  br label %if.end111

if.end111:                                        ; preds = %if.end110, %if.end97
  %117 = load i32, ptr %c, align 4
  %conv112 = trunc i32 %117 to i16
  %call113 = call noundef ptr @_ZNK6ImFont9FindGlyphEt(ptr noundef nonnull align 8 dereferenceable(118) %this1, i16 noundef zeroext %conv112)
  store ptr %call113, ptr %glyph, align 8
  %118 = load ptr, ptr %glyph, align 8
  %cmp114 = icmp eq ptr %118, null
  br i1 %cmp114, label %if.then115, label %if.end116

if.then115:                                       ; preds = %if.end111
  br label %while.cond74, !llvm.loop !32

if.end116:                                        ; preds = %if.end111
  %119 = load ptr, ptr %glyph, align 8
  %AdvanceX = getelementptr inbounds %struct.ImFontGlyph, ptr %119, i32 0, i32 1
  %120 = load float, ptr %AdvanceX, align 4
  %121 = load float, ptr %scale, align 4
  %mul117 = fmul float %120, %121
  store float %mul117, ptr %char_width, align 4
  %122 = load ptr, ptr %glyph, align 8
  %bf.load = load i32, ptr %122, align 4
  %bf.lshr = lshr i32 %bf.load, 1
  %bf.clear = and i32 %bf.lshr, 1
  %tobool118 = icmp ne i32 %bf.clear, 0
  br i1 %tobool118, label %if.then119, label %if.end264

if.then119:                                       ; preds = %if.end116
  %123 = load float, ptr %x, align 4
  %124 = load ptr, ptr %glyph, align 8
  %X0 = getelementptr inbounds %struct.ImFontGlyph, ptr %124, i32 0, i32 2
  %125 = load float, ptr %X0, align 4
  %126 = load float, ptr %scale, align 4
  %127 = call float @llvm.fmuladd.f32(float %125, float %126, float %123)
  store float %127, ptr %x1, align 4
  %128 = load float, ptr %x, align 4
  %129 = load ptr, ptr %glyph, align 8
  %X1 = getelementptr inbounds %struct.ImFontGlyph, ptr %129, i32 0, i32 4
  %130 = load float, ptr %X1, align 4
  %131 = load float, ptr %scale, align 4
  %132 = call float @llvm.fmuladd.f32(float %130, float %131, float %128)
  store float %132, ptr %x2121, align 4
  %133 = load float, ptr %y, align 4
  %134 = load ptr, ptr %glyph, align 8
  %Y0 = getelementptr inbounds %struct.ImFontGlyph, ptr %134, i32 0, i32 3
  %135 = load float, ptr %Y0, align 4
  %136 = load float, ptr %scale, align 4
  %137 = call float @llvm.fmuladd.f32(float %135, float %136, float %133)
  store float %137, ptr %y1, align 4
  %138 = load float, ptr %y, align 4
  %139 = load ptr, ptr %glyph, align 8
  %Y1 = getelementptr inbounds %struct.ImFontGlyph, ptr %139, i32 0, i32 5
  %140 = load float, ptr %Y1, align 4
  %141 = load float, ptr %scale, align 4
  %142 = call float @llvm.fmuladd.f32(float %140, float %141, float %138)
  store float %142, ptr %y2, align 4
  %143 = load float, ptr %x1, align 4
  %144 = load ptr, ptr %clip_rect.addr, align 8
  %z = getelementptr inbounds %struct.ImVec4, ptr %144, i32 0, i32 2
  %145 = load float, ptr %z, align 4
  %cmp125 = fcmp ole float %143, %145
  br i1 %cmp125, label %land.lhs.true126, label %if.end263

land.lhs.true126:                                 ; preds = %if.then119
  %146 = load float, ptr %x2121, align 4
  %147 = load ptr, ptr %clip_rect.addr, align 8
  %x127 = getelementptr inbounds %struct.ImVec4, ptr %147, i32 0, i32 0
  %148 = load float, ptr %x127, align 4
  %cmp128 = fcmp oge float %146, %148
  br i1 %cmp128, label %if.then129, label %if.end263

if.then129:                                       ; preds = %land.lhs.true126
  %149 = load ptr, ptr %glyph, align 8
  %U0 = getelementptr inbounds %struct.ImFontGlyph, ptr %149, i32 0, i32 6
  %150 = load float, ptr %U0, align 4
  store float %150, ptr %u1, align 4
  %151 = load ptr, ptr %glyph, align 8
  %V0 = getelementptr inbounds %struct.ImFontGlyph, ptr %151, i32 0, i32 7
  %152 = load float, ptr %V0, align 4
  store float %152, ptr %v1, align 4
  %153 = load ptr, ptr %glyph, align 8
  %U1 = getelementptr inbounds %struct.ImFontGlyph, ptr %153, i32 0, i32 8
  %154 = load float, ptr %U1, align 4
  store float %154, ptr %u2, align 4
  %155 = load ptr, ptr %glyph, align 8
  %V1 = getelementptr inbounds %struct.ImFontGlyph, ptr %155, i32 0, i32 9
  %156 = load float, ptr %V1, align 4
  store float %156, ptr %v2, align 4
  %157 = load i8, ptr %cpu_fine_clip.addr, align 1
  %tobool130 = trunc i8 %157 to i1
  br i1 %tobool130, label %if.then131, label %if.end182

if.then131:                                       ; preds = %if.then129
  %158 = load float, ptr %x1, align 4
  %159 = load ptr, ptr %clip_rect.addr, align 8
  %x132 = getelementptr inbounds %struct.ImVec4, ptr %159, i32 0, i32 0
  %160 = load float, ptr %x132, align 4
  %cmp133 = fcmp olt float %158, %160
  br i1 %cmp133, label %if.then134, label %if.end143

if.then134:                                       ; preds = %if.then131
  %161 = load float, ptr %u1, align 4
  %162 = load float, ptr %x2121, align 4
  %163 = load ptr, ptr %clip_rect.addr, align 8
  %x135 = getelementptr inbounds %struct.ImVec4, ptr %163, i32 0, i32 0
  %164 = load float, ptr %x135, align 4
  %sub136 = fsub float %162, %164
  %165 = load float, ptr %x2121, align 4
  %166 = load float, ptr %x1, align 4
  %sub137 = fsub float %165, %166
  %div138 = fdiv float %sub136, %sub137
  %sub139 = fsub float 1.000000e+00, %div138
  %167 = load float, ptr %u2, align 4
  %168 = load float, ptr %u1, align 4
  %sub140 = fsub float %167, %168
  %169 = call float @llvm.fmuladd.f32(float %sub139, float %sub140, float %161)
  store float %169, ptr %u1, align 4
  %170 = load ptr, ptr %clip_rect.addr, align 8
  %x142 = getelementptr inbounds %struct.ImVec4, ptr %170, i32 0, i32 0
  %171 = load float, ptr %x142, align 4
  store float %171, ptr %x1, align 4
  br label %if.end143

if.end143:                                        ; preds = %if.then134, %if.then131
  %172 = load float, ptr %y1, align 4
  %173 = load ptr, ptr %clip_rect.addr, align 8
  %y144 = getelementptr inbounds %struct.ImVec4, ptr %173, i32 0, i32 1
  %174 = load float, ptr %y144, align 4
  %cmp145 = fcmp olt float %172, %174
  br i1 %cmp145, label %if.then146, label %if.end155

if.then146:                                       ; preds = %if.end143
  %175 = load float, ptr %v1, align 4
  %176 = load float, ptr %y2, align 4
  %177 = load ptr, ptr %clip_rect.addr, align 8
  %y147 = getelementptr inbounds %struct.ImVec4, ptr %177, i32 0, i32 1
  %178 = load float, ptr %y147, align 4
  %sub148 = fsub float %176, %178
  %179 = load float, ptr %y2, align 4
  %180 = load float, ptr %y1, align 4
  %sub149 = fsub float %179, %180
  %div150 = fdiv float %sub148, %sub149
  %sub151 = fsub float 1.000000e+00, %div150
  %181 = load float, ptr %v2, align 4
  %182 = load float, ptr %v1, align 4
  %sub152 = fsub float %181, %182
  %183 = call float @llvm.fmuladd.f32(float %sub151, float %sub152, float %175)
  store float %183, ptr %v1, align 4
  %184 = load ptr, ptr %clip_rect.addr, align 8
  %y154 = getelementptr inbounds %struct.ImVec4, ptr %184, i32 0, i32 1
  %185 = load float, ptr %y154, align 4
  store float %185, ptr %y1, align 4
  br label %if.end155

if.end155:                                        ; preds = %if.then146, %if.end143
  %186 = load float, ptr %x2121, align 4
  %187 = load ptr, ptr %clip_rect.addr, align 8
  %z156 = getelementptr inbounds %struct.ImVec4, ptr %187, i32 0, i32 2
  %188 = load float, ptr %z156, align 4
  %cmp157 = fcmp ogt float %186, %188
  br i1 %cmp157, label %if.then158, label %if.end166

if.then158:                                       ; preds = %if.end155
  %189 = load float, ptr %u1, align 4
  %190 = load ptr, ptr %clip_rect.addr, align 8
  %z159 = getelementptr inbounds %struct.ImVec4, ptr %190, i32 0, i32 2
  %191 = load float, ptr %z159, align 4
  %192 = load float, ptr %x1, align 4
  %sub160 = fsub float %191, %192
  %193 = load float, ptr %x2121, align 4
  %194 = load float, ptr %x1, align 4
  %sub161 = fsub float %193, %194
  %div162 = fdiv float %sub160, %sub161
  %195 = load float, ptr %u2, align 4
  %196 = load float, ptr %u1, align 4
  %sub163 = fsub float %195, %196
  %197 = call float @llvm.fmuladd.f32(float %div162, float %sub163, float %189)
  store float %197, ptr %u2, align 4
  %198 = load ptr, ptr %clip_rect.addr, align 8
  %z165 = getelementptr inbounds %struct.ImVec4, ptr %198, i32 0, i32 2
  %199 = load float, ptr %z165, align 4
  store float %199, ptr %x2121, align 4
  br label %if.end166

if.end166:                                        ; preds = %if.then158, %if.end155
  %200 = load float, ptr %y2, align 4
  %201 = load ptr, ptr %clip_rect.addr, align 8
  %w167 = getelementptr inbounds %struct.ImVec4, ptr %201, i32 0, i32 3
  %202 = load float, ptr %w167, align 4
  %cmp168 = fcmp ogt float %200, %202
  br i1 %cmp168, label %if.then169, label %if.end177

if.then169:                                       ; preds = %if.end166
  %203 = load float, ptr %v1, align 4
  %204 = load ptr, ptr %clip_rect.addr, align 8
  %w170 = getelementptr inbounds %struct.ImVec4, ptr %204, i32 0, i32 3
  %205 = load float, ptr %w170, align 4
  %206 = load float, ptr %y1, align 4
  %sub171 = fsub float %205, %206
  %207 = load float, ptr %y2, align 4
  %208 = load float, ptr %y1, align 4
  %sub172 = fsub float %207, %208
  %div173 = fdiv float %sub171, %sub172
  %209 = load float, ptr %v2, align 4
  %210 = load float, ptr %v1, align 4
  %sub174 = fsub float %209, %210
  %211 = call float @llvm.fmuladd.f32(float %div173, float %sub174, float %203)
  store float %211, ptr %v2, align 4
  %212 = load ptr, ptr %clip_rect.addr, align 8
  %w176 = getelementptr inbounds %struct.ImVec4, ptr %212, i32 0, i32 3
  %213 = load float, ptr %w176, align 4
  store float %213, ptr %y2, align 4
  br label %if.end177

if.end177:                                        ; preds = %if.then169, %if.end166
  %214 = load float, ptr %y1, align 4
  %215 = load float, ptr %y2, align 4
  %cmp178 = fcmp oge float %214, %215
  br i1 %cmp178, label %if.then179, label %if.end181

if.then179:                                       ; preds = %if.end177
  %216 = load float, ptr %char_width, align 4
  %217 = load float, ptr %x, align 4
  %add180 = fadd float %217, %216
  store float %add180, ptr %x, align 4
  br label %while.cond74, !llvm.loop !32

if.end181:                                        ; preds = %if.end177
  br label %if.end182

if.end182:                                        ; preds = %if.end181, %if.then129
  %218 = load ptr, ptr %glyph, align 8
  %bf.load183 = load i32, ptr %218, align 4
  %bf.clear184 = and i32 %bf.load183, 1
  %tobool185 = icmp ne i32 %bf.clear184, 0
  br i1 %tobool185, label %cond.true186, label %cond.false187

cond.true186:                                     ; preds = %if.end182
  %219 = load i32, ptr %col_untinted, align 4
  br label %cond.end188

cond.false187:                                    ; preds = %if.end182
  %220 = load i32, ptr %col.addr, align 4
  br label %cond.end188

cond.end188:                                      ; preds = %cond.false187, %cond.true186
  %cond189 = phi i32 [ %219, %cond.true186 ], [ %220, %cond.false187 ]
  store i32 %cond189, ptr %glyph_col, align 4
  %221 = load float, ptr %x1, align 4
  %222 = load ptr, ptr %vtx_write, align 8
  %arrayidx = getelementptr inbounds %struct.ImDrawVert, ptr %222, i64 0
  %pos190 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx, i32 0, i32 0
  %x191 = getelementptr inbounds %struct.ImVec2, ptr %pos190, i32 0, i32 0
  store float %221, ptr %x191, align 4
  %223 = load float, ptr %y1, align 4
  %224 = load ptr, ptr %vtx_write, align 8
  %arrayidx192 = getelementptr inbounds %struct.ImDrawVert, ptr %224, i64 0
  %pos193 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx192, i32 0, i32 0
  %y194 = getelementptr inbounds %struct.ImVec2, ptr %pos193, i32 0, i32 1
  store float %223, ptr %y194, align 4
  %225 = load i32, ptr %glyph_col, align 4
  %226 = load ptr, ptr %vtx_write, align 8
  %arrayidx195 = getelementptr inbounds %struct.ImDrawVert, ptr %226, i64 0
  %col196 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx195, i32 0, i32 2
  store i32 %225, ptr %col196, align 4
  %227 = load float, ptr %u1, align 4
  %228 = load ptr, ptr %vtx_write, align 8
  %arrayidx197 = getelementptr inbounds %struct.ImDrawVert, ptr %228, i64 0
  %uv = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx197, i32 0, i32 1
  %x198 = getelementptr inbounds %struct.ImVec2, ptr %uv, i32 0, i32 0
  store float %227, ptr %x198, align 4
  %229 = load float, ptr %v1, align 4
  %230 = load ptr, ptr %vtx_write, align 8
  %arrayidx199 = getelementptr inbounds %struct.ImDrawVert, ptr %230, i64 0
  %uv200 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx199, i32 0, i32 1
  %y201 = getelementptr inbounds %struct.ImVec2, ptr %uv200, i32 0, i32 1
  store float %229, ptr %y201, align 4
  %231 = load float, ptr %x2121, align 4
  %232 = load ptr, ptr %vtx_write, align 8
  %arrayidx202 = getelementptr inbounds %struct.ImDrawVert, ptr %232, i64 1
  %pos203 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx202, i32 0, i32 0
  %x204 = getelementptr inbounds %struct.ImVec2, ptr %pos203, i32 0, i32 0
  store float %231, ptr %x204, align 4
  %233 = load float, ptr %y1, align 4
  %234 = load ptr, ptr %vtx_write, align 8
  %arrayidx205 = getelementptr inbounds %struct.ImDrawVert, ptr %234, i64 1
  %pos206 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx205, i32 0, i32 0
  %y207 = getelementptr inbounds %struct.ImVec2, ptr %pos206, i32 0, i32 1
  store float %233, ptr %y207, align 4
  %235 = load i32, ptr %glyph_col, align 4
  %236 = load ptr, ptr %vtx_write, align 8
  %arrayidx208 = getelementptr inbounds %struct.ImDrawVert, ptr %236, i64 1
  %col209 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx208, i32 0, i32 2
  store i32 %235, ptr %col209, align 4
  %237 = load float, ptr %u2, align 4
  %238 = load ptr, ptr %vtx_write, align 8
  %arrayidx210 = getelementptr inbounds %struct.ImDrawVert, ptr %238, i64 1
  %uv211 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx210, i32 0, i32 1
  %x212 = getelementptr inbounds %struct.ImVec2, ptr %uv211, i32 0, i32 0
  store float %237, ptr %x212, align 4
  %239 = load float, ptr %v1, align 4
  %240 = load ptr, ptr %vtx_write, align 8
  %arrayidx213 = getelementptr inbounds %struct.ImDrawVert, ptr %240, i64 1
  %uv214 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx213, i32 0, i32 1
  %y215 = getelementptr inbounds %struct.ImVec2, ptr %uv214, i32 0, i32 1
  store float %239, ptr %y215, align 4
  %241 = load float, ptr %x2121, align 4
  %242 = load ptr, ptr %vtx_write, align 8
  %arrayidx216 = getelementptr inbounds %struct.ImDrawVert, ptr %242, i64 2
  %pos217 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx216, i32 0, i32 0
  %x218 = getelementptr inbounds %struct.ImVec2, ptr %pos217, i32 0, i32 0
  store float %241, ptr %x218, align 4
  %243 = load float, ptr %y2, align 4
  %244 = load ptr, ptr %vtx_write, align 8
  %arrayidx219 = getelementptr inbounds %struct.ImDrawVert, ptr %244, i64 2
  %pos220 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx219, i32 0, i32 0
  %y221 = getelementptr inbounds %struct.ImVec2, ptr %pos220, i32 0, i32 1
  store float %243, ptr %y221, align 4
  %245 = load i32, ptr %glyph_col, align 4
  %246 = load ptr, ptr %vtx_write, align 8
  %arrayidx222 = getelementptr inbounds %struct.ImDrawVert, ptr %246, i64 2
  %col223 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx222, i32 0, i32 2
  store i32 %245, ptr %col223, align 4
  %247 = load float, ptr %u2, align 4
  %248 = load ptr, ptr %vtx_write, align 8
  %arrayidx224 = getelementptr inbounds %struct.ImDrawVert, ptr %248, i64 2
  %uv225 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx224, i32 0, i32 1
  %x226 = getelementptr inbounds %struct.ImVec2, ptr %uv225, i32 0, i32 0
  store float %247, ptr %x226, align 4
  %249 = load float, ptr %v2, align 4
  %250 = load ptr, ptr %vtx_write, align 8
  %arrayidx227 = getelementptr inbounds %struct.ImDrawVert, ptr %250, i64 2
  %uv228 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx227, i32 0, i32 1
  %y229 = getelementptr inbounds %struct.ImVec2, ptr %uv228, i32 0, i32 1
  store float %249, ptr %y229, align 4
  %251 = load float, ptr %x1, align 4
  %252 = load ptr, ptr %vtx_write, align 8
  %arrayidx230 = getelementptr inbounds %struct.ImDrawVert, ptr %252, i64 3
  %pos231 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx230, i32 0, i32 0
  %x232 = getelementptr inbounds %struct.ImVec2, ptr %pos231, i32 0, i32 0
  store float %251, ptr %x232, align 4
  %253 = load float, ptr %y2, align 4
  %254 = load ptr, ptr %vtx_write, align 8
  %arrayidx233 = getelementptr inbounds %struct.ImDrawVert, ptr %254, i64 3
  %pos234 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx233, i32 0, i32 0
  %y235 = getelementptr inbounds %struct.ImVec2, ptr %pos234, i32 0, i32 1
  store float %253, ptr %y235, align 4
  %255 = load i32, ptr %glyph_col, align 4
  %256 = load ptr, ptr %vtx_write, align 8
  %arrayidx236 = getelementptr inbounds %struct.ImDrawVert, ptr %256, i64 3
  %col237 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx236, i32 0, i32 2
  store i32 %255, ptr %col237, align 4
  %257 = load float, ptr %u1, align 4
  %258 = load ptr, ptr %vtx_write, align 8
  %arrayidx238 = getelementptr inbounds %struct.ImDrawVert, ptr %258, i64 3
  %uv239 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx238, i32 0, i32 1
  %x240 = getelementptr inbounds %struct.ImVec2, ptr %uv239, i32 0, i32 0
  store float %257, ptr %x240, align 4
  %259 = load float, ptr %v2, align 4
  %260 = load ptr, ptr %vtx_write, align 8
  %arrayidx241 = getelementptr inbounds %struct.ImDrawVert, ptr %260, i64 3
  %uv242 = getelementptr inbounds %struct.ImDrawVert, ptr %arrayidx241, i32 0, i32 1
  %y243 = getelementptr inbounds %struct.ImVec2, ptr %uv242, i32 0, i32 1
  store float %259, ptr %y243, align 4
  %261 = load i32, ptr %vtx_index, align 4
  %conv244 = trunc i32 %261 to i16
  %262 = load ptr, ptr %idx_write, align 8
  %arrayidx245 = getelementptr inbounds i16, ptr %262, i64 0
  store i16 %conv244, ptr %arrayidx245, align 2
  %263 = load i32, ptr %vtx_index, align 4
  %add246 = add i32 %263, 1
  %conv247 = trunc i32 %add246 to i16
  %264 = load ptr, ptr %idx_write, align 8
  %arrayidx248 = getelementptr inbounds i16, ptr %264, i64 1
  store i16 %conv247, ptr %arrayidx248, align 2
  %265 = load i32, ptr %vtx_index, align 4
  %add249 = add i32 %265, 2
  %conv250 = trunc i32 %add249 to i16
  %266 = load ptr, ptr %idx_write, align 8
  %arrayidx251 = getelementptr inbounds i16, ptr %266, i64 2
  store i16 %conv250, ptr %arrayidx251, align 2
  %267 = load i32, ptr %vtx_index, align 4
  %conv252 = trunc i32 %267 to i16
  %268 = load ptr, ptr %idx_write, align 8
  %arrayidx253 = getelementptr inbounds i16, ptr %268, i64 3
  store i16 %conv252, ptr %arrayidx253, align 2
  %269 = load i32, ptr %vtx_index, align 4
  %add254 = add i32 %269, 2
  %conv255 = trunc i32 %add254 to i16
  %270 = load ptr, ptr %idx_write, align 8
  %arrayidx256 = getelementptr inbounds i16, ptr %270, i64 4
  store i16 %conv255, ptr %arrayidx256, align 2
  %271 = load i32, ptr %vtx_index, align 4
  %add257 = add i32 %271, 3
  %conv258 = trunc i32 %add257 to i16
  %272 = load ptr, ptr %idx_write, align 8
  %arrayidx259 = getelementptr inbounds i16, ptr %272, i64 5
  store i16 %conv258, ptr %arrayidx259, align 2
  %273 = load ptr, ptr %vtx_write, align 8
  %add.ptr260 = getelementptr inbounds %struct.ImDrawVert, ptr %273, i64 4
  store ptr %add.ptr260, ptr %vtx_write, align 8
  %274 = load i32, ptr %vtx_index, align 4
  %add261 = add i32 %274, 4
  store i32 %add261, ptr %vtx_index, align 4
  %275 = load ptr, ptr %idx_write, align 8
  %add.ptr262 = getelementptr inbounds i16, ptr %275, i64 6
  store ptr %add.ptr262, ptr %idx_write, align 8
  br label %if.end263

if.end263:                                        ; preds = %cond.end188, %land.lhs.true126, %if.then119
  br label %if.end264

if.end264:                                        ; preds = %if.end263, %if.end116
  %276 = load float, ptr %char_width, align 4
  %277 = load float, ptr %x, align 4
  %add265 = fadd float %277, %276
  store float %add265, ptr %x, align 4
  br label %while.cond74, !llvm.loop !32

while.end266:                                     ; preds = %if.then105, %while.cond74
  %278 = load ptr, ptr %vtx_write, align 8
  %279 = load ptr, ptr %draw_list.addr, align 8
  %VtxBuffer = getelementptr inbounds %struct.ImDrawList, ptr %279, i32 0, i32 2
  %Data = getelementptr inbounds %struct.ImVector.2, ptr %VtxBuffer, i32 0, i32 2
  %280 = load ptr, ptr %Data, align 8
  %sub.ptr.lhs.cast267 = ptrtoint ptr %278 to i64
  %sub.ptr.rhs.cast268 = ptrtoint ptr %280 to i64
  %sub.ptr.sub269 = sub i64 %sub.ptr.lhs.cast267, %sub.ptr.rhs.cast268
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub269, 20
  %conv270 = trunc i64 %sub.ptr.div to i32
  %281 = load ptr, ptr %draw_list.addr, align 8
  %VtxBuffer271 = getelementptr inbounds %struct.ImDrawList, ptr %281, i32 0, i32 2
  %Size272 = getelementptr inbounds %struct.ImVector.2, ptr %VtxBuffer271, i32 0, i32 0
  store i32 %conv270, ptr %Size272, align 8
  %282 = load ptr, ptr %idx_write, align 8
  %283 = load ptr, ptr %draw_list.addr, align 8
  %IdxBuffer273 = getelementptr inbounds %struct.ImDrawList, ptr %283, i32 0, i32 1
  %Data274 = getelementptr inbounds %struct.ImVector.1, ptr %IdxBuffer273, i32 0, i32 2
  %284 = load ptr, ptr %Data274, align 8
  %sub.ptr.lhs.cast275 = ptrtoint ptr %282 to i64
  %sub.ptr.rhs.cast276 = ptrtoint ptr %284 to i64
  %sub.ptr.sub277 = sub i64 %sub.ptr.lhs.cast275, %sub.ptr.rhs.cast276
  %sub.ptr.div278 = sdiv exact i64 %sub.ptr.sub277, 2
  %conv279 = trunc i64 %sub.ptr.div278 to i32
  %285 = load ptr, ptr %draw_list.addr, align 8
  %IdxBuffer280 = getelementptr inbounds %struct.ImDrawList, ptr %285, i32 0, i32 1
  %Size281 = getelementptr inbounds %struct.ImVector.1, ptr %IdxBuffer280, i32 0, i32 0
  store i32 %conv279, ptr %Size281, align 8
  %286 = load i32, ptr %idx_expected_size, align 4
  %287 = load ptr, ptr %draw_list.addr, align 8
  %IdxBuffer282 = getelementptr inbounds %struct.ImDrawList, ptr %287, i32 0, i32 1
  %Size283 = getelementptr inbounds %struct.ImVector.1, ptr %IdxBuffer282, i32 0, i32 0
  %288 = load i32, ptr %Size283, align 8
  %sub284 = sub nsw i32 %286, %288
  %289 = load ptr, ptr %draw_list.addr, align 8
  %CmdBuffer = getelementptr inbounds %struct.ImDrawList, ptr %289, i32 0, i32 0
  %290 = load ptr, ptr %draw_list.addr, align 8
  %CmdBuffer285 = getelementptr inbounds %struct.ImDrawList, ptr %290, i32 0, i32 0
  %Size286 = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer285, i32 0, i32 0
  %291 = load i32, ptr %Size286, align 8
  %sub287 = sub nsw i32 %291, 1
  %call288 = call noundef nonnull align 8 dereferenceable(56) ptr @_ZN8ImVectorI9ImDrawCmdEixEi(ptr noundef nonnull align 8 dereferenceable(16) %CmdBuffer, i32 noundef %sub287)
  %ElemCount = getelementptr inbounds %struct.ImDrawCmd, ptr %call288, i32 0, i32 4
  %292 = load i32, ptr %ElemCount, align 8
  %sub289 = sub i32 %292, %sub284
  store i32 %sub289, ptr %ElemCount, align 8
  %293 = load ptr, ptr %vtx_write, align 8
  %294 = load ptr, ptr %draw_list.addr, align 8
  %_VtxWritePtr290 = getelementptr inbounds %struct.ImDrawList, ptr %294, i32 0, i32 7
  store ptr %293, ptr %_VtxWritePtr290, align 8
  %295 = load ptr, ptr %idx_write, align 8
  %296 = load ptr, ptr %draw_list.addr, align 8
  %_IdxWritePtr291 = getelementptr inbounds %struct.ImDrawList, ptr %296, i32 0, i32 8
  store ptr %295, ptr %_IdxWritePtr291, align 8
  %297 = load i32, ptr %vtx_index, align 4
  %298 = load ptr, ptr %draw_list.addr, align 8
  %_VtxCurrentIdx292 = getelementptr inbounds %struct.ImDrawList, ptr %298, i32 0, i32 4
  store i32 %297, ptr %_VtxCurrentIdx292, align 4
  br label %return

return:                                           ; preds = %while.end266, %if.then61, %if.then7
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList7AddTextERK6ImVec2jPKcS4_(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef nonnull align 4 dereferenceable(8) %pos, i32 noundef %col, ptr noundef %text_begin, ptr noundef %text_end) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %pos.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  %text_begin.addr = alloca ptr, align 8
  %text_end.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %pos, ptr %pos.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  store ptr %text_begin, ptr %text_begin.addr, align 8
  store ptr %text_end, ptr %text_end.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %pos.addr, align 8
  %1 = load i32, ptr %col.addr, align 4
  %2 = load ptr, ptr %text_begin.addr, align 8
  %3 = load ptr, ptr %text_end.addr, align 8
  call void @_ZN10ImDrawList7AddTextEPK6ImFontfRK6ImVec2jPKcS7_fPK6ImVec4(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef null, float noundef 0.000000e+00, ptr noundef nonnull align 4 dereferenceable(8) %0, i32 noundef %1, ptr noundef %2, ptr noundef %3, float noundef 0.000000e+00, ptr noundef null)
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList8AddImageEPvRK6ImVec2S3_S3_S3_j(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef %user_texture_id, ptr noundef nonnull align 4 dereferenceable(8) %p_min, ptr noundef nonnull align 4 dereferenceable(8) %p_max, ptr noundef nonnull align 4 dereferenceable(8) %uv_min, ptr noundef nonnull align 4 dereferenceable(8) %uv_max, i32 noundef %col) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %user_texture_id.addr = alloca ptr, align 8
  %p_min.addr = alloca ptr, align 8
  %p_max.addr = alloca ptr, align 8
  %uv_min.addr = alloca ptr, align 8
  %uv_max.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  %push_texture_id = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  store ptr %user_texture_id, ptr %user_texture_id.addr, align 8
  store ptr %p_min, ptr %p_min.addr, align 8
  store ptr %p_max, ptr %p_max.addr, align 8
  store ptr %uv_min, ptr %uv_min.addr, align 8
  store ptr %uv_max, ptr %uv_max.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %col.addr, align 4
  %and = and i32 %0, -16777216
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end7

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %user_texture_id.addr, align 8
  %_CmdHeader = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 12
  %TextureId = getelementptr inbounds %struct.ImDrawCmdHeader, ptr %_CmdHeader, i32 0, i32 1
  %2 = load ptr, ptr %TextureId, align 8
  %cmp2 = icmp ne ptr %1, %2
  %frombool = zext i1 %cmp2 to i8
  store i8 %frombool, ptr %push_texture_id, align 1
  %3 = load i8, ptr %push_texture_id, align 1
  %tobool = trunc i8 %3 to i1
  br i1 %tobool, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %4 = load ptr, ptr %user_texture_id.addr, align 8
  call void @_ZN10ImDrawList13PushTextureIDEPv(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef %4)
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  call void @_ZN10ImDrawList11PrimReserveEii(ptr noundef nonnull align 8 dereferenceable(196) %this1, i32 noundef 6, i32 noundef 4)
  %5 = load ptr, ptr %p_min.addr, align 8
  %6 = load ptr, ptr %p_max.addr, align 8
  %7 = load ptr, ptr %uv_min.addr, align 8
  %8 = load ptr, ptr %uv_max.addr, align 8
  %9 = load i32, ptr %col.addr, align 4
  call void @_ZN10ImDrawList10PrimRectUVERK6ImVec2S2_S2_S2_j(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %5, ptr noundef nonnull align 4 dereferenceable(8) %6, ptr noundef nonnull align 4 dereferenceable(8) %7, ptr noundef nonnull align 4 dereferenceable(8) %8, i32 noundef %9)
  %10 = load i8, ptr %push_texture_id, align 1
  %tobool5 = trunc i8 %10 to i1
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  call void @_ZN10ImDrawList12PopTextureIDEv(ptr noundef nonnull align 8 dereferenceable(196) %this1)
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end4, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList12AddImageQuadEPvRK6ImVec2S3_S3_S3_S3_S3_S3_S3_j(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef %user_texture_id, ptr noundef nonnull align 4 dereferenceable(8) %p1, ptr noundef nonnull align 4 dereferenceable(8) %p2, ptr noundef nonnull align 4 dereferenceable(8) %p3, ptr noundef nonnull align 4 dereferenceable(8) %p4, ptr noundef nonnull align 4 dereferenceable(8) %uv1, ptr noundef nonnull align 4 dereferenceable(8) %uv2, ptr noundef nonnull align 4 dereferenceable(8) %uv3, ptr noundef nonnull align 4 dereferenceable(8) %uv4, i32 noundef %col) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %user_texture_id.addr = alloca ptr, align 8
  %p1.addr = alloca ptr, align 8
  %p2.addr = alloca ptr, align 8
  %p3.addr = alloca ptr, align 8
  %p4.addr = alloca ptr, align 8
  %uv1.addr = alloca ptr, align 8
  %uv2.addr = alloca ptr, align 8
  %uv3.addr = alloca ptr, align 8
  %uv4.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  %push_texture_id = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  store ptr %user_texture_id, ptr %user_texture_id.addr, align 8
  store ptr %p1, ptr %p1.addr, align 8
  store ptr %p2, ptr %p2.addr, align 8
  store ptr %p3, ptr %p3.addr, align 8
  store ptr %p4, ptr %p4.addr, align 8
  store ptr %uv1, ptr %uv1.addr, align 8
  store ptr %uv2, ptr %uv2.addr, align 8
  store ptr %uv3, ptr %uv3.addr, align 8
  store ptr %uv4, ptr %uv4.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %col.addr, align 4
  %and = and i32 %0, -16777216
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end7

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %user_texture_id.addr, align 8
  %_CmdHeader = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 12
  %TextureId = getelementptr inbounds %struct.ImDrawCmdHeader, ptr %_CmdHeader, i32 0, i32 1
  %2 = load ptr, ptr %TextureId, align 8
  %cmp2 = icmp ne ptr %1, %2
  %frombool = zext i1 %cmp2 to i8
  store i8 %frombool, ptr %push_texture_id, align 1
  %3 = load i8, ptr %push_texture_id, align 1
  %tobool = trunc i8 %3 to i1
  br i1 %tobool, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %4 = load ptr, ptr %user_texture_id.addr, align 8
  call void @_ZN10ImDrawList13PushTextureIDEPv(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef %4)
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  call void @_ZN10ImDrawList11PrimReserveEii(ptr noundef nonnull align 8 dereferenceable(196) %this1, i32 noundef 6, i32 noundef 4)
  %5 = load ptr, ptr %p1.addr, align 8
  %6 = load ptr, ptr %p2.addr, align 8
  %7 = load ptr, ptr %p3.addr, align 8
  %8 = load ptr, ptr %p4.addr, align 8
  %9 = load ptr, ptr %uv1.addr, align 8
  %10 = load ptr, ptr %uv2.addr, align 8
  %11 = load ptr, ptr %uv3.addr, align 8
  %12 = load ptr, ptr %uv4.addr, align 8
  %13 = load i32, ptr %col.addr, align 4
  call void @_ZN10ImDrawList10PrimQuadUVERK6ImVec2S2_S2_S2_S2_S2_S2_S2_j(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %5, ptr noundef nonnull align 4 dereferenceable(8) %6, ptr noundef nonnull align 4 dereferenceable(8) %7, ptr noundef nonnull align 4 dereferenceable(8) %8, ptr noundef nonnull align 4 dereferenceable(8) %9, ptr noundef nonnull align 4 dereferenceable(8) %10, ptr noundef nonnull align 4 dereferenceable(8) %11, ptr noundef nonnull align 4 dereferenceable(8) %12, i32 noundef %13)
  %14 = load i8, ptr %push_texture_id, align 1
  %tobool5 = trunc i8 %14 to i1
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  call void @_ZN10ImDrawList12PopTextureIDEv(ptr noundef nonnull align 8 dereferenceable(196) %this1)
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end4, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawList15AddImageRoundedEPvRK6ImVec2S3_S3_S3_jfi(ptr noundef nonnull align 8 dereferenceable(196) %this, ptr noundef %user_texture_id, ptr noundef nonnull align 4 dereferenceable(8) %p_min, ptr noundef nonnull align 4 dereferenceable(8) %p_max, ptr noundef nonnull align 4 dereferenceable(8) %uv_min, ptr noundef nonnull align 4 dereferenceable(8) %uv_max, i32 noundef %col, float noundef %rounding, i32 noundef %flags) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %user_texture_id.addr = alloca ptr, align 8
  %p_min.addr = alloca ptr, align 8
  %p_max.addr = alloca ptr, align 8
  %uv_min.addr = alloca ptr, align 8
  %uv_max.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  %rounding.addr = alloca float, align 4
  %flags.addr = alloca i32, align 4
  %push_texture_id = alloca i8, align 1
  %vert_start_idx = alloca i32, align 4
  %vert_end_idx = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %user_texture_id, ptr %user_texture_id.addr, align 8
  store ptr %p_min, ptr %p_min.addr, align 8
  store ptr %p_max, ptr %p_max.addr, align 8
  store ptr %uv_min, ptr %uv_min.addr, align 8
  store ptr %uv_max, ptr %uv_max.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  store float %rounding, ptr %rounding.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %col.addr, align 4
  %and = and i32 %0, -16777216
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end14

if.end:                                           ; preds = %entry
  %1 = load i32, ptr %flags.addr, align 4
  %call = call noundef i32 @_ZL18FixRectCornerFlagsi(i32 noundef %1)
  store i32 %call, ptr %flags.addr, align 4
  %2 = load float, ptr %rounding.addr, align 4
  %cmp2 = fcmp olt float %2, 5.000000e-01
  br i1 %cmp2, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %3 = load i32, ptr %flags.addr, align 4
  %and3 = and i32 %3, 496
  %cmp4 = icmp eq i32 %and3, 256
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %lor.lhs.false, %if.end
  %4 = load ptr, ptr %user_texture_id.addr, align 8
  %5 = load ptr, ptr %p_min.addr, align 8
  %6 = load ptr, ptr %p_max.addr, align 8
  %7 = load ptr, ptr %uv_min.addr, align 8
  %8 = load ptr, ptr %uv_max.addr, align 8
  %9 = load i32, ptr %col.addr, align 4
  call void @_ZN10ImDrawList8AddImageEPvRK6ImVec2S3_S3_S3_j(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef %4, ptr noundef nonnull align 4 dereferenceable(8) %5, ptr noundef nonnull align 4 dereferenceable(8) %6, ptr noundef nonnull align 4 dereferenceable(8) %7, ptr noundef nonnull align 4 dereferenceable(8) %8, i32 noundef %9)
  br label %if.end14

if.end6:                                          ; preds = %lor.lhs.false
  %10 = load ptr, ptr %user_texture_id.addr, align 8
  %_CmdHeader = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 12
  %TextureId = getelementptr inbounds %struct.ImDrawCmdHeader, ptr %_CmdHeader, i32 0, i32 1
  %11 = load ptr, ptr %TextureId, align 8
  %cmp7 = icmp ne ptr %10, %11
  %frombool = zext i1 %cmp7 to i8
  store i8 %frombool, ptr %push_texture_id, align 1
  %12 = load i8, ptr %push_texture_id, align 1
  %tobool = trunc i8 %12 to i1
  br i1 %tobool, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  %13 = load ptr, ptr %user_texture_id.addr, align 8
  call void @_ZN10ImDrawList13PushTextureIDEPv(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef %13)
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end6
  %VtxBuffer = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 2
  %Size = getelementptr inbounds %struct.ImVector.2, ptr %VtxBuffer, i32 0, i32 0
  %14 = load i32, ptr %Size, align 8
  store i32 %14, ptr %vert_start_idx, align 4
  %15 = load ptr, ptr %p_min.addr, align 8
  %16 = load ptr, ptr %p_max.addr, align 8
  %17 = load float, ptr %rounding.addr, align 4
  %18 = load i32, ptr %flags.addr, align 4
  call void @_ZN10ImDrawList8PathRectERK6ImVec2S2_fi(ptr noundef nonnull align 8 dereferenceable(196) %this1, ptr noundef nonnull align 4 dereferenceable(8) %15, ptr noundef nonnull align 4 dereferenceable(8) %16, float noundef %17, i32 noundef %18)
  %19 = load i32, ptr %col.addr, align 4
  call void @_ZN10ImDrawList14PathFillConvexEj(ptr noundef nonnull align 8 dereferenceable(196) %this1, i32 noundef %19)
  %VtxBuffer10 = getelementptr inbounds %struct.ImDrawList, ptr %this1, i32 0, i32 2
  %Size11 = getelementptr inbounds %struct.ImVector.2, ptr %VtxBuffer10, i32 0, i32 0
  %20 = load i32, ptr %Size11, align 8
  store i32 %20, ptr %vert_end_idx, align 4
  %21 = load i32, ptr %vert_start_idx, align 4
  %22 = load i32, ptr %vert_end_idx, align 4
  %23 = load ptr, ptr %p_min.addr, align 8
  %24 = load ptr, ptr %p_max.addr, align 8
  %25 = load ptr, ptr %uv_min.addr, align 8
  %26 = load ptr, ptr %uv_max.addr, align 8
  call void @_ZN5ImGui18ShadeVertsLinearUVEP10ImDrawListiiRK6ImVec2S4_S4_S4_b(ptr noundef %this1, i32 noundef %21, i32 noundef %22, ptr noundef nonnull align 4 dereferenceable(8) %23, ptr noundef nonnull align 4 dereferenceable(8) %24, ptr noundef nonnull align 4 dereferenceable(8) %25, ptr noundef nonnull align 4 dereferenceable(8) %26, i1 noundef zeroext true)
  %27 = load i8, ptr %push_texture_id, align 1
  %tobool12 = trunc i8 %27 to i1
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end9
  call void @_ZN10ImDrawList12PopTextureIDEv(ptr noundef nonnull align 8 dereferenceable(196) %this1)
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end9, %if.then5, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui18ShadeVertsLinearUVEP10ImDrawListiiRK6ImVec2S4_S4_S4_b(ptr noundef %draw_list, i32 noundef %vert_start_idx, i32 noundef %vert_end_idx, ptr noundef nonnull align 4 dereferenceable(8) %a, ptr noundef nonnull align 4 dereferenceable(8) %b, ptr noundef nonnull align 4 dereferenceable(8) %uv_a, ptr noundef nonnull align 4 dereferenceable(8) %uv_b, i1 noundef zeroext %clamp) #0 {
entry:
  %draw_list.addr = alloca ptr, align 8
  %vert_start_idx.addr = alloca i32, align 4
  %vert_end_idx.addr = alloca i32, align 4
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %uv_a.addr = alloca ptr, align 8
  %uv_b.addr = alloca ptr, align 8
  %clamp.addr = alloca i8, align 1
  %size = alloca %struct.ImVec2, align 4
  %uv_size = alloca %struct.ImVec2, align 4
  %scale = alloca %struct.ImVec2, align 4
  %vert_start = alloca ptr, align 8
  %vert_end = alloca ptr, align 8
  %min = alloca %struct.ImVec2, align 4
  %max = alloca %struct.ImVec2, align 4
  %vertex = alloca ptr, align 8
  %ref.tmp = alloca %struct.ImVec2, align 4
  %ref.tmp19 = alloca %struct.ImVec2, align 4
  %ref.tmp20 = alloca %struct.ImVec2, align 4
  %ref.tmp21 = alloca %struct.ImVec2, align 4
  %ref.tmp22 = alloca %struct.ImVec2, align 4
  %agg.tmp = alloca %struct.ImVec2, align 4
  %vertex30 = alloca ptr, align 8
  %ref.tmp34 = alloca %struct.ImVec2, align 4
  %ref.tmp35 = alloca %struct.ImVec2, align 4
  %ref.tmp36 = alloca %struct.ImVec2, align 4
  %ref.tmp37 = alloca %struct.ImVec2, align 4
  store ptr %draw_list, ptr %draw_list.addr, align 8
  store i32 %vert_start_idx, ptr %vert_start_idx.addr, align 4
  store i32 %vert_end_idx, ptr %vert_end_idx.addr, align 4
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  store ptr %uv_a, ptr %uv_a.addr, align 8
  store ptr %uv_b, ptr %uv_b.addr, align 8
  %frombool = zext i1 %clamp to i8
  store i8 %frombool, ptr %clamp.addr, align 1
  %0 = load ptr, ptr %b.addr, align 8
  %1 = load ptr, ptr %a.addr, align 8
  %call = call <2 x float> @_ZmiRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %0, ptr noundef nonnull align 4 dereferenceable(8) %1)
  store <2 x float> %call, ptr %size, align 4
  %2 = load ptr, ptr %uv_b.addr, align 8
  %3 = load ptr, ptr %uv_a.addr, align 8
  %call1 = call <2 x float> @_ZmiRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %2, ptr noundef nonnull align 4 dereferenceable(8) %3)
  store <2 x float> %call1, ptr %uv_size, align 4
  %x = getelementptr inbounds %struct.ImVec2, ptr %size, i32 0, i32 0
  %4 = load float, ptr %x, align 4
  %cmp = fcmp une float %4, 0.000000e+00
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %x2 = getelementptr inbounds %struct.ImVec2, ptr %uv_size, i32 0, i32 0
  %5 = load float, ptr %x2, align 4
  %x3 = getelementptr inbounds %struct.ImVec2, ptr %size, i32 0, i32 0
  %6 = load float, ptr %x3, align 4
  %div = fdiv float %5, %6
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %div, %cond.true ], [ 0.000000e+00, %cond.false ]
  %y = getelementptr inbounds %struct.ImVec2, ptr %size, i32 0, i32 1
  %7 = load float, ptr %y, align 4
  %cmp4 = fcmp une float %7, 0.000000e+00
  br i1 %cmp4, label %cond.true5, label %cond.false9

cond.true5:                                       ; preds = %cond.end
  %y6 = getelementptr inbounds %struct.ImVec2, ptr %uv_size, i32 0, i32 1
  %8 = load float, ptr %y6, align 4
  %y7 = getelementptr inbounds %struct.ImVec2, ptr %size, i32 0, i32 1
  %9 = load float, ptr %y7, align 4
  %div8 = fdiv float %8, %9
  br label %cond.end10

cond.false9:                                      ; preds = %cond.end
  br label %cond.end10

cond.end10:                                       ; preds = %cond.false9, %cond.true5
  %cond11 = phi float [ %div8, %cond.true5 ], [ 0.000000e+00, %cond.false9 ]
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %scale, float noundef %cond, float noundef %cond11)
  %10 = load ptr, ptr %draw_list.addr, align 8
  %VtxBuffer = getelementptr inbounds %struct.ImDrawList, ptr %10, i32 0, i32 2
  %Data = getelementptr inbounds %struct.ImVector.2, ptr %VtxBuffer, i32 0, i32 2
  %11 = load ptr, ptr %Data, align 8
  %12 = load i32, ptr %vert_start_idx.addr, align 4
  %idx.ext = sext i32 %12 to i64
  %add.ptr = getelementptr inbounds %struct.ImDrawVert, ptr %11, i64 %idx.ext
  store ptr %add.ptr, ptr %vert_start, align 8
  %13 = load ptr, ptr %draw_list.addr, align 8
  %VtxBuffer12 = getelementptr inbounds %struct.ImDrawList, ptr %13, i32 0, i32 2
  %Data13 = getelementptr inbounds %struct.ImVector.2, ptr %VtxBuffer12, i32 0, i32 2
  %14 = load ptr, ptr %Data13, align 8
  %15 = load i32, ptr %vert_end_idx.addr, align 4
  %idx.ext14 = sext i32 %15 to i64
  %add.ptr15 = getelementptr inbounds %struct.ImDrawVert, ptr %14, i64 %idx.ext14
  store ptr %add.ptr15, ptr %vert_end, align 8
  %16 = load i8, ptr %clamp.addr, align 1
  %tobool = trunc i8 %16 to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end10
  %17 = load ptr, ptr %uv_a.addr, align 8
  %18 = load ptr, ptr %uv_b.addr, align 8
  %call16 = call <2 x float> @_ZL5ImMinRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %17, ptr noundef nonnull align 4 dereferenceable(8) %18)
  store <2 x float> %call16, ptr %min, align 4
  %19 = load ptr, ptr %uv_a.addr, align 8
  %20 = load ptr, ptr %uv_b.addr, align 8
  %call17 = call <2 x float> @_ZL5ImMaxRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %19, ptr noundef nonnull align 4 dereferenceable(8) %20)
  store <2 x float> %call17, ptr %max, align 4
  %21 = load ptr, ptr %vert_start, align 8
  store ptr %21, ptr %vertex, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %22 = load ptr, ptr %vertex, align 8
  %23 = load ptr, ptr %vert_end, align 8
  %cmp18 = icmp ult ptr %22, %23
  br i1 %cmp18, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %24 = load ptr, ptr %uv_a.addr, align 8
  %25 = load ptr, ptr %vertex, align 8
  %pos = getelementptr inbounds %struct.ImDrawVert, ptr %25, i32 0, i32 0
  %x23 = getelementptr inbounds %struct.ImVec2, ptr %pos, i32 0, i32 0
  %26 = load float, ptr %x23, align 4
  %27 = load ptr, ptr %vertex, align 8
  %pos24 = getelementptr inbounds %struct.ImDrawVert, ptr %27, i32 0, i32 0
  %y25 = getelementptr inbounds %struct.ImVec2, ptr %pos24, i32 0, i32 1
  %28 = load float, ptr %y25, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp22, float noundef %26, float noundef %28)
  %29 = load ptr, ptr %a.addr, align 8
  %call26 = call <2 x float> @_ZmiRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp22, ptr noundef nonnull align 4 dereferenceable(8) %29)
  store <2 x float> %call26, ptr %ref.tmp21, align 4
  %call27 = call <2 x float> @_ZL5ImMulRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp21, ptr noundef nonnull align 4 dereferenceable(8) %scale)
  store <2 x float> %call27, ptr %ref.tmp20, align 4
  %call28 = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %24, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp20)
  store <2 x float> %call28, ptr %ref.tmp19, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp, ptr align 4 %max, i64 8, i1 false)
  %30 = load <2 x float>, ptr %agg.tmp, align 4
  %call29 = call <2 x float> @_ZL7ImClampRK6ImVec2S1_S_(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp19, ptr noundef nonnull align 4 dereferenceable(8) %min, <2 x float> %30)
  store <2 x float> %call29, ptr %ref.tmp, align 4
  %31 = load ptr, ptr %vertex, align 8
  %uv = getelementptr inbounds %struct.ImDrawVert, ptr %31, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv, ptr align 4 %ref.tmp, i64 8, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %32 = load ptr, ptr %vertex, align 8
  %incdec.ptr = getelementptr inbounds %struct.ImDrawVert, ptr %32, i32 1
  store ptr %incdec.ptr, ptr %vertex, align 8
  br label %for.cond, !llvm.loop !33

for.end:                                          ; preds = %for.cond
  br label %if.end

if.else:                                          ; preds = %cond.end10
  %33 = load ptr, ptr %vert_start, align 8
  store ptr %33, ptr %vertex30, align 8
  br label %for.cond31

for.cond31:                                       ; preds = %for.inc46, %if.else
  %34 = load ptr, ptr %vertex30, align 8
  %35 = load ptr, ptr %vert_end, align 8
  %cmp32 = icmp ult ptr %34, %35
  br i1 %cmp32, label %for.body33, label %for.end48

for.body33:                                       ; preds = %for.cond31
  %36 = load ptr, ptr %uv_a.addr, align 8
  %37 = load ptr, ptr %vertex30, align 8
  %pos38 = getelementptr inbounds %struct.ImDrawVert, ptr %37, i32 0, i32 0
  %x39 = getelementptr inbounds %struct.ImVec2, ptr %pos38, i32 0, i32 0
  %38 = load float, ptr %x39, align 4
  %39 = load ptr, ptr %vertex30, align 8
  %pos40 = getelementptr inbounds %struct.ImDrawVert, ptr %39, i32 0, i32 0
  %y41 = getelementptr inbounds %struct.ImVec2, ptr %pos40, i32 0, i32 1
  %40 = load float, ptr %y41, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp37, float noundef %38, float noundef %40)
  %41 = load ptr, ptr %a.addr, align 8
  %call42 = call <2 x float> @_ZmiRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp37, ptr noundef nonnull align 4 dereferenceable(8) %41)
  store <2 x float> %call42, ptr %ref.tmp36, align 4
  %call43 = call <2 x float> @_ZL5ImMulRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp36, ptr noundef nonnull align 4 dereferenceable(8) %scale)
  store <2 x float> %call43, ptr %ref.tmp35, align 4
  %call44 = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %36, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp35)
  store <2 x float> %call44, ptr %ref.tmp34, align 4
  %42 = load ptr, ptr %vertex30, align 8
  %uv45 = getelementptr inbounds %struct.ImDrawVert, ptr %42, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %uv45, ptr align 4 %ref.tmp34, i64 8, i1 false)
  br label %for.inc46

for.inc46:                                        ; preds = %for.body33
  %43 = load ptr, ptr %vertex30, align 8
  %incdec.ptr47 = getelementptr inbounds %struct.ImDrawVert, ptr %43, i32 1
  store ptr %incdec.ptr47, ptr %vertex30, align 8
  br label %for.cond31, !llvm.loop !34

for.end48:                                        ; preds = %for.cond31
  br label %if.end

if.end:                                           ; preds = %for.end48, %for.end
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 8 dereferenceable(32) ptr @_ZN8ImVectorI13ImDrawChannelEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.5, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.ImDrawChannel, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI13ImDrawChannelE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.5, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Capacity = getelementptr inbounds %struct.ImVector.5, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.5, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data2 = getelementptr inbounds %struct.ImVector.5, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
  %Data3 = getelementptr inbounds %struct.ImVector.5, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN18ImDrawListSplitter5SplitEP10ImDrawListi(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %draw_list, i32 noundef %channels_count) #4 align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %draw_list.addr = alloca ptr, align 8
  %channels_count.addr = alloca i32, align 4
  %old_channels_count = alloca i32, align 4
  %i = alloca i32, align 4
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %draw_list, ptr %draw_list.addr, align 8
  store i32 %channels_count, ptr %channels_count.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %_Channels = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 2
  %Size = getelementptr inbounds %struct.ImVector.5, ptr %_Channels, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  store i32 %0, ptr %old_channels_count, align 4
  %1 = load i32, ptr %old_channels_count, align 4
  %2 = load i32, ptr %channels_count.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %_Channels2 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 2
  %3 = load i32, ptr %channels_count.addr, align 4
  call void @_ZN8ImVectorI13ImDrawChannelE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %_Channels2, i32 noundef %3)
  %_Channels3 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 2
  %4 = load i32, ptr %channels_count.addr, align 4
  call void @_ZN8ImVectorI13ImDrawChannelE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %_Channels3, i32 noundef %4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i32, ptr %channels_count.addr, align 4
  %_Count = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 1
  store i32 %5, ptr %_Count, align 4
  %_Channels4 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 2
  %call = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN8ImVectorI13ImDrawChannelEixEi(ptr noundef nonnull align 8 dereferenceable(16) %_Channels4, i32 noundef 0)
  call void @llvm.memset.p0.i64(ptr align 8 %call, i8 0, i64 32, i1 false)
  store i32 1, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %6 = load i32, ptr %i, align 4
  %7 = load i32, ptr %channels_count.addr, align 4
  %cmp5 = icmp slt i32 %6, %7
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %old_channels_count, align 4
  %cmp6 = icmp sge i32 %8, %9
  br i1 %cmp6, label %if.then7, label %if.else

if.then7:                                         ; preds = %for.body
  %_Channels8 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 2
  %10 = load i32, ptr %i, align 4
  %call9 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN8ImVectorI13ImDrawChannelEixEi(ptr noundef nonnull align 8 dereferenceable(16) %_Channels8, i32 noundef %10)
  %call10 = call noundef ptr @_Znwm12ImNewWrapperPv(i64 noundef 32, ptr noundef %call9)
  call void @llvm.memset.p0.i64(ptr align 8 %call10, i8 0, i64 32, i1 false)
  invoke void @_ZN13ImDrawChannelC2Ev(ptr noundef nonnull align 8 dereferenceable(32) %call10)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %if.then7
  br label %if.end15

lpad:                                             ; preds = %if.then7
  %11 = landingpad { ptr, i32 }
          cleanup
  %12 = extractvalue { ptr, i32 } %11, 0
  store ptr %12, ptr %exn.slot, align 8
  %13 = extractvalue { ptr, i32 } %11, 1
  store i32 %13, ptr %ehselector.slot, align 4
  call void @_ZdlPv12ImNewWrapperS_(ptr noundef %call10, ptr noundef %call9) #12
  br label %eh.resume

if.else:                                          ; preds = %for.body
  %_Channels11 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 2
  %14 = load i32, ptr %i, align 4
  %call12 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN8ImVectorI13ImDrawChannelEixEi(ptr noundef nonnull align 8 dereferenceable(16) %_Channels11, i32 noundef %14)
  %_CmdBuffer = getelementptr inbounds %struct.ImDrawChannel, ptr %call12, i32 0, i32 0
  call void @_ZN8ImVectorI9ImDrawCmdE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %_CmdBuffer, i32 noundef 0)
  %_Channels13 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 2
  %15 = load i32, ptr %i, align 4
  %call14 = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN8ImVectorI13ImDrawChannelEixEi(ptr noundef nonnull align 8 dereferenceable(16) %_Channels13, i32 noundef %15)
  %_IdxBuffer = getelementptr inbounds %struct.ImDrawChannel, ptr %call14, i32 0, i32 1
  call void @_ZN8ImVectorItE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %_IdxBuffer, i32 noundef 0)
  br label %if.end15

if.end15:                                         ; preds = %if.else, %invoke.cont
  br label %for.inc

for.inc:                                          ; preds = %if.end15
  %16 = load i32, ptr %i, align 4
  %inc = add nsw i32 %16, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !35

for.end:                                          ; preds = %for.cond
  ret void

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val16 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val16
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI13ImDrawChannelE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.5, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 32
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.5, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.5, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.5, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 32
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %4, ptr align 8 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.5, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.5, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.5, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI13ImDrawChannelE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_size) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_size, ptr %new_size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_size.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.5, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sgt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %new_size.addr, align 4
  %call = call noundef i32 @_ZNK8ImVectorI13ImDrawChannelE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %2)
  call void @_ZN8ImVectorI13ImDrawChannelE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %new_size.addr, align 4
  %Size = getelementptr inbounds %struct.ImVector.5, ptr %this1, i32 0, i32 0
  store i32 %3, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN13ImDrawChannelC2Ev(ptr noundef nonnull align 8 dereferenceable(32) %this) unnamed_addr #4 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %_CmdBuffer = getelementptr inbounds %struct.ImDrawChannel, ptr %this1, i32 0, i32 0
  call void @_ZN8ImVectorI9ImDrawCmdEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %_CmdBuffer)
  %_IdxBuffer = getelementptr inbounds %struct.ImDrawChannel, ptr %this1, i32 0, i32 1
  invoke void @_ZN8ImVectorItEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %_IdxBuffer)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  ret void

lpad:                                             ; preds = %entry
  %0 = landingpad { ptr, i32 }
          cleanup
  %1 = extractvalue { ptr, i32 } %0, 0
  store ptr %1, ptr %exn.slot, align 8
  %2 = extractvalue { ptr, i32 } %0, 1
  store i32 %2, ptr %ehselector.slot, align 4
  call void @_ZN8ImVectorI9ImDrawCmdED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %_CmdBuffer) #12
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val2 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val2
}

; Function Attrs: mustprogress uwtable
define void @_ZN18ImDrawListSplitter17SetCurrentChannelEP10ImDrawListi(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %draw_list, i32 noundef %idx) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %draw_list.addr = alloca ptr, align 8
  %idx.addr = alloca i32, align 4
  %curr_cmd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %draw_list, ptr %draw_list.addr, align 8
  store i32 %idx, ptr %idx.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %_Current = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %_Current, align 8
  %1 = load i32, ptr %idx.addr, align 4
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end43

if.end:                                           ; preds = %entry
  %_Channels = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 2
  %Data = getelementptr inbounds %struct.ImVector.5, ptr %_Channels, i32 0, i32 2
  %2 = load ptr, ptr %Data, align 8
  %_Current2 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 0
  %3 = load i32, ptr %_Current2, align 8
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds %struct.ImDrawChannel, ptr %2, i64 %idxprom
  %_CmdBuffer = getelementptr inbounds %struct.ImDrawChannel, ptr %arrayidx, i32 0, i32 0
  %4 = load ptr, ptr %draw_list.addr, align 8
  %CmdBuffer = getelementptr inbounds %struct.ImDrawList, ptr %4, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %_CmdBuffer, ptr align 8 %CmdBuffer, i64 16, i1 false)
  %_Channels3 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 2
  %Data4 = getelementptr inbounds %struct.ImVector.5, ptr %_Channels3, i32 0, i32 2
  %5 = load ptr, ptr %Data4, align 8
  %_Current5 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %_Current5, align 8
  %idxprom6 = sext i32 %6 to i64
  %arrayidx7 = getelementptr inbounds %struct.ImDrawChannel, ptr %5, i64 %idxprom6
  %_IdxBuffer = getelementptr inbounds %struct.ImDrawChannel, ptr %arrayidx7, i32 0, i32 1
  %7 = load ptr, ptr %draw_list.addr, align 8
  %IdxBuffer = getelementptr inbounds %struct.ImDrawList, ptr %7, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %_IdxBuffer, ptr align 8 %IdxBuffer, i64 16, i1 false)
  %8 = load i32, ptr %idx.addr, align 4
  %_Current8 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 0
  store i32 %8, ptr %_Current8, align 8
  %9 = load ptr, ptr %draw_list.addr, align 8
  %CmdBuffer9 = getelementptr inbounds %struct.ImDrawList, ptr %9, i32 0, i32 0
  %_Channels10 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 2
  %Data11 = getelementptr inbounds %struct.ImVector.5, ptr %_Channels10, i32 0, i32 2
  %10 = load ptr, ptr %Data11, align 8
  %11 = load i32, ptr %idx.addr, align 4
  %idxprom12 = sext i32 %11 to i64
  %arrayidx13 = getelementptr inbounds %struct.ImDrawChannel, ptr %10, i64 %idxprom12
  %_CmdBuffer14 = getelementptr inbounds %struct.ImDrawChannel, ptr %arrayidx13, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %CmdBuffer9, ptr align 8 %_CmdBuffer14, i64 16, i1 false)
  %12 = load ptr, ptr %draw_list.addr, align 8
  %IdxBuffer15 = getelementptr inbounds %struct.ImDrawList, ptr %12, i32 0, i32 1
  %_Channels16 = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 2
  %Data17 = getelementptr inbounds %struct.ImVector.5, ptr %_Channels16, i32 0, i32 2
  %13 = load ptr, ptr %Data17, align 8
  %14 = load i32, ptr %idx.addr, align 4
  %idxprom18 = sext i32 %14 to i64
  %arrayidx19 = getelementptr inbounds %struct.ImDrawChannel, ptr %13, i64 %idxprom18
  %_IdxBuffer20 = getelementptr inbounds %struct.ImDrawChannel, ptr %arrayidx19, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %IdxBuffer15, ptr align 8 %_IdxBuffer20, i64 16, i1 false)
  %15 = load ptr, ptr %draw_list.addr, align 8
  %IdxBuffer21 = getelementptr inbounds %struct.ImDrawList, ptr %15, i32 0, i32 1
  %Data22 = getelementptr inbounds %struct.ImVector.1, ptr %IdxBuffer21, i32 0, i32 2
  %16 = load ptr, ptr %Data22, align 8
  %17 = load ptr, ptr %draw_list.addr, align 8
  %IdxBuffer23 = getelementptr inbounds %struct.ImDrawList, ptr %17, i32 0, i32 1
  %Size = getelementptr inbounds %struct.ImVector.1, ptr %IdxBuffer23, i32 0, i32 0
  %18 = load i32, ptr %Size, align 8
  %idx.ext = sext i32 %18 to i64
  %add.ptr = getelementptr inbounds i16, ptr %16, i64 %idx.ext
  %19 = load ptr, ptr %draw_list.addr, align 8
  %_IdxWritePtr = getelementptr inbounds %struct.ImDrawList, ptr %19, i32 0, i32 8
  store ptr %add.ptr, ptr %_IdxWritePtr, align 8
  %20 = load ptr, ptr %draw_list.addr, align 8
  %CmdBuffer24 = getelementptr inbounds %struct.ImDrawList, ptr %20, i32 0, i32 0
  %Size25 = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer24, i32 0, i32 0
  %21 = load i32, ptr %Size25, align 8
  %cmp26 = icmp eq i32 %21, 0
  br i1 %cmp26, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %22 = load ptr, ptr %draw_list.addr, align 8
  %CmdBuffer27 = getelementptr inbounds %struct.ImDrawList, ptr %22, i32 0, i32 0
  %Data28 = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer27, i32 0, i32 2
  %23 = load ptr, ptr %Data28, align 8
  %24 = load ptr, ptr %draw_list.addr, align 8
  %CmdBuffer29 = getelementptr inbounds %struct.ImDrawList, ptr %24, i32 0, i32 0
  %Size30 = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer29, i32 0, i32 0
  %25 = load i32, ptr %Size30, align 8
  %sub = sub nsw i32 %25, 1
  %idxprom31 = sext i32 %sub to i64
  %arrayidx32 = getelementptr inbounds %struct.ImDrawCmd, ptr %23, i64 %idxprom31
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ null, %cond.true ], [ %arrayidx32, %cond.false ]
  store ptr %cond, ptr %curr_cmd, align 8
  %26 = load ptr, ptr %curr_cmd, align 8
  %cmp33 = icmp eq ptr %26, null
  br i1 %cmp33, label %if.then34, label %if.else

if.then34:                                        ; preds = %cond.end
  %27 = load ptr, ptr %draw_list.addr, align 8
  call void @_ZN10ImDrawList10AddDrawCmdEv(ptr noundef nonnull align 8 dereferenceable(196) %27)
  br label %if.end43

if.else:                                          ; preds = %cond.end
  %28 = load ptr, ptr %curr_cmd, align 8
  %ElemCount = getelementptr inbounds %struct.ImDrawCmd, ptr %28, i32 0, i32 4
  %29 = load i32, ptr %ElemCount, align 8
  %cmp35 = icmp eq i32 %29, 0
  br i1 %cmp35, label %if.then36, label %if.else37

if.then36:                                        ; preds = %if.else
  %30 = load ptr, ptr %curr_cmd, align 8
  %31 = load ptr, ptr %draw_list.addr, align 8
  %_CmdHeader = getelementptr inbounds %struct.ImDrawList, ptr %31, i32 0, i32 12
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %30, ptr align 8 %_CmdHeader, i64 28, i1 false)
  br label %if.end42

if.else37:                                        ; preds = %if.else
  %32 = load ptr, ptr %curr_cmd, align 8
  %33 = load ptr, ptr %draw_list.addr, align 8
  %_CmdHeader38 = getelementptr inbounds %struct.ImDrawList, ptr %33, i32 0, i32 12
  %call = call i32 @memcmp(ptr noundef %32, ptr noundef %_CmdHeader38, i64 noundef 28) #14
  %cmp39 = icmp ne i32 %call, 0
  br i1 %cmp39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %if.else37
  %34 = load ptr, ptr %draw_list.addr, align 8
  call void @_ZN10ImDrawList10AddDrawCmdEv(ptr noundef nonnull align 8 dereferenceable(196) %34)
  br label %if.end41

if.end41:                                         ; preds = %if.then40, %if.else37
  br label %if.end42

if.end42:                                         ; preds = %if.end41, %if.then36
  br label %if.end43

if.end43:                                         ; preds = %if.end42, %if.then34, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 8 dereferenceable(56) ptr @_ZN8ImVectorI9ImDrawCmdE4backEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %Size = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %sub = sub nsw i32 %1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.ImDrawCmd, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 8 dereferenceable(56) ptr @_ZN8ImVectorI9ImDrawCmdEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.ImDrawCmd, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZN8ImVectorI9ImDrawCmdE5eraseEPKS0_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %it) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %it.addr = alloca ptr, align 8
  %off = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %it, ptr %it.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %it.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 56
  store i64 %sub.ptr.div, ptr %off, align 8
  %Data2 = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 2
  %2 = load ptr, ptr %Data2, align 8
  %3 = load i64, ptr %off, align 8
  %add.ptr = getelementptr inbounds %struct.ImDrawCmd, ptr %2, i64 %3
  %Data3 = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 2
  %4 = load ptr, ptr %Data3, align 8
  %5 = load i64, ptr %off, align 8
  %add.ptr4 = getelementptr inbounds %struct.ImDrawCmd, ptr %4, i64 %5
  %add.ptr5 = getelementptr inbounds %struct.ImDrawCmd, ptr %add.ptr4, i64 1
  %Size = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv = sext i32 %6 to i64
  %7 = load i64, ptr %off, align 8
  %sub = sub i64 %conv, %7
  %sub6 = sub i64 %sub, 1
  %mul = mul i64 %sub6, 56
  call void @llvm.memmove.p0.p0.i64(ptr align 8 %add.ptr, ptr align 8 %add.ptr5, i64 %mul, i1 false)
  %Size7 = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 0
  %8 = load i32, ptr %Size7, align 8
  %dec = add nsw i32 %8, -1
  store i32 %dec, ptr %Size7, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 2
  %9 = load ptr, ptr %Data8, align 8
  %10 = load i64, ptr %off, align 8
  %add.ptr9 = getelementptr inbounds %struct.ImDrawCmd, ptr %9, i64 %10
  ret ptr %add.ptr9
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawData5ClearEv(ptr noundef nonnull align 8 dereferenceable(64) %this) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %struct.ImVec2, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Valid = getelementptr inbounds %struct.ImDrawData, ptr %this1, i32 0, i32 0
  store i8 0, ptr %Valid, align 8
  %TotalVtxCount = getelementptr inbounds %struct.ImDrawData, ptr %this1, i32 0, i32 3
  store i32 0, ptr %TotalVtxCount, align 4
  %TotalIdxCount = getelementptr inbounds %struct.ImDrawData, ptr %this1, i32 0, i32 2
  store i32 0, ptr %TotalIdxCount, align 8
  %CmdListsCount = getelementptr inbounds %struct.ImDrawData, ptr %this1, i32 0, i32 1
  store i32 0, ptr %CmdListsCount, align 4
  %CmdLists = getelementptr inbounds %struct.ImDrawData, ptr %this1, i32 0, i32 4
  call void @_ZN8ImVectorIP10ImDrawListE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %CmdLists, i32 noundef 0)
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %FramebufferScale = getelementptr inbounds %struct.ImDrawData, ptr %this1, i32 0, i32 7
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %FramebufferScale, ptr align 4 %ref.tmp, i64 8, i1 false)
  %DisplaySize = getelementptr inbounds %struct.ImDrawData, ptr %this1, i32 0, i32 6
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %DisplaySize, ptr align 4 %FramebufferScale, i64 8, i1 false)
  %DisplayPos = getelementptr inbounds %struct.ImDrawData, ptr %this1, i32 0, i32 5
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %DisplayPos, ptr align 4 %DisplaySize, i64 8, i1 false)
  %OwnerViewport = getelementptr inbounds %struct.ImDrawData, ptr %this1, i32 0, i32 8
  store ptr null, ptr %OwnerViewport, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorIP10ImDrawListE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_size) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_size, ptr %new_size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_size.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.8, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sgt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %new_size.addr, align 4
  %call = call noundef i32 @_ZNK8ImVectorIP10ImDrawListE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %2)
  call void @_ZN8ImVectorIP10ImDrawListE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %new_size.addr, align 4
  %Size = getelementptr inbounds %struct.ImVector.8, ptr %this1, i32 0, i32 0
  store i32 %3, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui23AddDrawListToDrawDataExEP10ImDrawDataP8ImVectorIP10ImDrawListES4_(ptr noundef %draw_data, ptr noundef %out_list, ptr noundef %draw_list) #4 {
entry:
  %draw_data.addr = alloca ptr, align 8
  %out_list.addr = alloca ptr, align 8
  %draw_list.addr = alloca ptr, align 8
  store ptr %draw_data, ptr %draw_data.addr, align 8
  store ptr %out_list, ptr %out_list.addr, align 8
  store ptr %draw_list, ptr %draw_list.addr, align 8
  %0 = load ptr, ptr %draw_list.addr, align 8
  %CmdBuffer = getelementptr inbounds %struct.ImDrawList, ptr %0, i32 0, i32 0
  %Size = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %draw_list.addr, align 8
  %CmdBuffer1 = getelementptr inbounds %struct.ImDrawList, ptr %2, i32 0, i32 0
  %Size2 = getelementptr inbounds %struct.ImVector.0, ptr %CmdBuffer1, i32 0, i32 0
  %3 = load i32, ptr %Size2, align 8
  %cmp3 = icmp eq i32 %3, 1
  br i1 %cmp3, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %if.end
  %4 = load ptr, ptr %draw_list.addr, align 8
  %CmdBuffer4 = getelementptr inbounds %struct.ImDrawList, ptr %4, i32 0, i32 0
  %call = call noundef nonnull align 8 dereferenceable(56) ptr @_ZN8ImVectorI9ImDrawCmdEixEi(ptr noundef nonnull align 8 dereferenceable(16) %CmdBuffer4, i32 noundef 0)
  %ElemCount = getelementptr inbounds %struct.ImDrawCmd, ptr %call, i32 0, i32 4
  %5 = load i32, ptr %ElemCount, align 8
  %cmp5 = icmp eq i32 %5, 0
  br i1 %cmp5, label %land.lhs.true6, label %if.end11

land.lhs.true6:                                   ; preds = %land.lhs.true
  %6 = load ptr, ptr %draw_list.addr, align 8
  %CmdBuffer7 = getelementptr inbounds %struct.ImDrawList, ptr %6, i32 0, i32 0
  %call8 = call noundef nonnull align 8 dereferenceable(56) ptr @_ZN8ImVectorI9ImDrawCmdEixEi(ptr noundef nonnull align 8 dereferenceable(16) %CmdBuffer7, i32 noundef 0)
  %UserCallback = getelementptr inbounds %struct.ImDrawCmd, ptr %call8, i32 0, i32 5
  %7 = load ptr, ptr %UserCallback, align 8
  %cmp9 = icmp eq ptr %7, null
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %land.lhs.true6
  br label %return

if.end11:                                         ; preds = %land.lhs.true6, %land.lhs.true, %if.end
  %8 = load ptr, ptr %draw_list.addr, align 8
  %Flags = getelementptr inbounds %struct.ImDrawList, ptr %8, i32 0, i32 3
  %9 = load i32, ptr %Flags, align 8
  %and = and i32 %9, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end13, label %if.then12

if.then12:                                        ; preds = %if.end11
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.end11
  %10 = load ptr, ptr %out_list.addr, align 8
  call void @_ZN8ImVectorIP10ImDrawListE9push_backERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %10, ptr noundef nonnull align 8 dereferenceable(8) %draw_list.addr)
  %11 = load ptr, ptr %draw_data.addr, align 8
  %CmdListsCount = getelementptr inbounds %struct.ImDrawData, ptr %11, i32 0, i32 1
  %12 = load i32, ptr %CmdListsCount, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, ptr %CmdListsCount, align 4
  %13 = load ptr, ptr %draw_list.addr, align 8
  %VtxBuffer = getelementptr inbounds %struct.ImDrawList, ptr %13, i32 0, i32 2
  %Size14 = getelementptr inbounds %struct.ImVector.2, ptr %VtxBuffer, i32 0, i32 0
  %14 = load i32, ptr %Size14, align 8
  %15 = load ptr, ptr %draw_data.addr, align 8
  %TotalVtxCount = getelementptr inbounds %struct.ImDrawData, ptr %15, i32 0, i32 3
  %16 = load i32, ptr %TotalVtxCount, align 4
  %add = add nsw i32 %16, %14
  store i32 %add, ptr %TotalVtxCount, align 4
  %17 = load ptr, ptr %draw_list.addr, align 8
  %IdxBuffer = getelementptr inbounds %struct.ImDrawList, ptr %17, i32 0, i32 1
  %Size15 = getelementptr inbounds %struct.ImVector.1, ptr %IdxBuffer, i32 0, i32 0
  %18 = load i32, ptr %Size15, align 8
  %19 = load ptr, ptr %draw_data.addr, align 8
  %TotalIdxCount = getelementptr inbounds %struct.ImDrawData, ptr %19, i32 0, i32 2
  %20 = load i32, ptr %TotalIdxCount, align 8
  %add16 = add nsw i32 %20, %18
  store i32 %add16, ptr %TotalIdxCount, align 8
  br label %return

return:                                           ; preds = %if.end13, %if.then10, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorIP10ImDrawListE9push_backERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(8) %v) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.8, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.8, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Size2 = getelementptr inbounds %struct.ImVector.8, ptr %this1, i32 0, i32 0
  %2 = load i32, ptr %Size2, align 8
  %add = add nsw i32 %2, 1
  %call = call noundef i32 @_ZNK8ImVectorIP10ImDrawListE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %add)
  call void @_ZN8ImVectorIP10ImDrawListE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %Data = getelementptr inbounds %struct.ImVector.8, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %Size3 = getelementptr inbounds %struct.ImVector.8, ptr %this1, i32 0, i32 0
  %4 = load i32, ptr %Size3, align 8
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %3, i64 %idxprom
  %5 = load ptr, ptr %v.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arrayidx, ptr align 8 %5, i64 8, i1 false)
  %Size4 = getelementptr inbounds %struct.ImVector.8, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size4, align 8
  %inc = add nsw i32 %6, 1
  store i32 %inc, ptr %Size4, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawData11AddDrawListEP10ImDrawList(ptr noundef nonnull align 8 dereferenceable(64) %this, ptr noundef %draw_list) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %draw_list.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %draw_list, ptr %draw_list.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %draw_list.addr, align 8
  call void @_ZN10ImDrawList17_PopUnusedDrawCmdEv(ptr noundef nonnull align 8 dereferenceable(196) %0)
  %CmdLists = getelementptr inbounds %struct.ImDrawData, ptr %this1, i32 0, i32 4
  %1 = load ptr, ptr %draw_list.addr, align 8
  call void @_ZN5ImGui23AddDrawListToDrawDataExEP10ImDrawDataP8ImVectorIP10ImDrawListES4_(ptr noundef %this1, ptr noundef %CmdLists, ptr noundef %1)
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawData17DeIndexAllBuffersEv(ptr noundef nonnull align 8 dereferenceable(64) %this) #4 align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %new_vtx_buffer = alloca %struct.ImVector.2, align 8
  %i = alloca i32, align 4
  %cmd_list = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %j = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN8ImVectorI10ImDrawVertEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %new_vtx_buffer)
  %TotalIdxCount = getelementptr inbounds %struct.ImDrawData, ptr %this1, i32 0, i32 2
  store i32 0, ptr %TotalIdxCount, align 8
  %TotalVtxCount = getelementptr inbounds %struct.ImDrawData, ptr %this1, i32 0, i32 3
  store i32 0, ptr %TotalVtxCount, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc25, %entry
  %0 = load i32, ptr %i, align 4
  %CmdListsCount = getelementptr inbounds %struct.ImDrawData, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %CmdListsCount, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end27

for.body:                                         ; preds = %for.cond
  %CmdLists = getelementptr inbounds %struct.ImDrawData, ptr %this1, i32 0, i32 4
  %2 = load i32, ptr %i, align 4
  %call = invoke noundef nonnull align 8 dereferenceable(8) ptr @_ZN8ImVectorIP10ImDrawListEixEi(ptr noundef nonnull align 8 dereferenceable(16) %CmdLists, i32 noundef %2)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %for.body
  %3 = load ptr, ptr %call, align 8
  store ptr %3, ptr %cmd_list, align 8
  %4 = load ptr, ptr %cmd_list, align 8
  %IdxBuffer = getelementptr inbounds %struct.ImDrawList, ptr %4, i32 0, i32 1
  %call3 = invoke noundef zeroext i1 @_ZNK8ImVectorItE5emptyEv(ptr noundef nonnull align 8 dereferenceable(16) %IdxBuffer)
          to label %invoke.cont2 unwind label %lpad

invoke.cont2:                                     ; preds = %invoke.cont
  br i1 %call3, label %if.then, label %if.end

if.then:                                          ; preds = %invoke.cont2
  br label %for.inc25

lpad:                                             ; preds = %invoke.cont19, %for.end, %invoke.cont14, %invoke.cont12, %for.body10, %if.end, %invoke.cont, %for.body
  %5 = landingpad { ptr, i32 }
          cleanup
  %6 = extractvalue { ptr, i32 } %5, 0
  store ptr %6, ptr %exn.slot, align 8
  %7 = extractvalue { ptr, i32 } %5, 1
  store i32 %7, ptr %ehselector.slot, align 4
  call void @_ZN8ImVectorI10ImDrawVertED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %new_vtx_buffer) #12
  br label %eh.resume

if.end:                                           ; preds = %invoke.cont2
  %8 = load ptr, ptr %cmd_list, align 8
  %IdxBuffer4 = getelementptr inbounds %struct.ImDrawList, ptr %8, i32 0, i32 1
  %Size = getelementptr inbounds %struct.ImVector.1, ptr %IdxBuffer4, i32 0, i32 0
  %9 = load i32, ptr %Size, align 8
  invoke void @_ZN8ImVectorI10ImDrawVertE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %new_vtx_buffer, i32 noundef %9)
          to label %invoke.cont5 unwind label %lpad

invoke.cont5:                                     ; preds = %if.end
  store i32 0, ptr %j, align 4
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc, %invoke.cont5
  %10 = load i32, ptr %j, align 4
  %11 = load ptr, ptr %cmd_list, align 8
  %IdxBuffer7 = getelementptr inbounds %struct.ImDrawList, ptr %11, i32 0, i32 1
  %Size8 = getelementptr inbounds %struct.ImVector.1, ptr %IdxBuffer7, i32 0, i32 0
  %12 = load i32, ptr %Size8, align 8
  %cmp9 = icmp slt i32 %10, %12
  br i1 %cmp9, label %for.body10, label %for.end

for.body10:                                       ; preds = %for.cond6
  %13 = load ptr, ptr %cmd_list, align 8
  %VtxBuffer = getelementptr inbounds %struct.ImDrawList, ptr %13, i32 0, i32 2
  %14 = load ptr, ptr %cmd_list, align 8
  %IdxBuffer11 = getelementptr inbounds %struct.ImDrawList, ptr %14, i32 0, i32 1
  %15 = load i32, ptr %j, align 4
  %call13 = invoke noundef nonnull align 2 dereferenceable(2) ptr @_ZN8ImVectorItEixEi(ptr noundef nonnull align 8 dereferenceable(16) %IdxBuffer11, i32 noundef %15)
          to label %invoke.cont12 unwind label %lpad

invoke.cont12:                                    ; preds = %for.body10
  %16 = load i16, ptr %call13, align 2
  %conv = zext i16 %16 to i32
  %call15 = invoke noundef nonnull align 4 dereferenceable(20) ptr @_ZN8ImVectorI10ImDrawVertEixEi(ptr noundef nonnull align 8 dereferenceable(16) %VtxBuffer, i32 noundef %conv)
          to label %invoke.cont14 unwind label %lpad

invoke.cont14:                                    ; preds = %invoke.cont12
  %17 = load i32, ptr %j, align 4
  %call17 = invoke noundef nonnull align 4 dereferenceable(20) ptr @_ZN8ImVectorI10ImDrawVertEixEi(ptr noundef nonnull align 8 dereferenceable(16) %new_vtx_buffer, i32 noundef %17)
          to label %invoke.cont16 unwind label %lpad

invoke.cont16:                                    ; preds = %invoke.cont14
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %call17, ptr align 4 %call15, i64 20, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %invoke.cont16
  %18 = load i32, ptr %j, align 4
  %inc = add nsw i32 %18, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond6, !llvm.loop !36

for.end:                                          ; preds = %for.cond6
  %19 = load ptr, ptr %cmd_list, align 8
  %VtxBuffer18 = getelementptr inbounds %struct.ImDrawList, ptr %19, i32 0, i32 2
  invoke void @_ZN8ImVectorI10ImDrawVertE4swapERS1_(ptr noundef nonnull align 8 dereferenceable(16) %VtxBuffer18, ptr noundef nonnull align 8 dereferenceable(16) %new_vtx_buffer)
          to label %invoke.cont19 unwind label %lpad

invoke.cont19:                                    ; preds = %for.end
  %20 = load ptr, ptr %cmd_list, align 8
  %IdxBuffer20 = getelementptr inbounds %struct.ImDrawList, ptr %20, i32 0, i32 1
  invoke void @_ZN8ImVectorItE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %IdxBuffer20, i32 noundef 0)
          to label %invoke.cont21 unwind label %lpad

invoke.cont21:                                    ; preds = %invoke.cont19
  %21 = load ptr, ptr %cmd_list, align 8
  %VtxBuffer22 = getelementptr inbounds %struct.ImDrawList, ptr %21, i32 0, i32 2
  %Size23 = getelementptr inbounds %struct.ImVector.2, ptr %VtxBuffer22, i32 0, i32 0
  %22 = load i32, ptr %Size23, align 8
  %TotalVtxCount24 = getelementptr inbounds %struct.ImDrawData, ptr %this1, i32 0, i32 3
  %23 = load i32, ptr %TotalVtxCount24, align 4
  %add = add nsw i32 %23, %22
  store i32 %add, ptr %TotalVtxCount24, align 4
  br label %for.inc25

for.inc25:                                        ; preds = %invoke.cont21, %if.then
  %24 = load i32, ptr %i, align 4
  %inc26 = add nsw i32 %24, 1
  store i32 %inc26, ptr %i, align 4
  br label %for.cond, !llvm.loop !37

for.end27:                                        ; preds = %for.cond
  call void @_ZN8ImVectorI10ImDrawVertED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %new_vtx_buffer) #12
  ret void

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val28 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val28
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI10ImDrawVertEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 8 dereferenceable(8) ptr @_ZN8ImVectorIP10ImDrawListEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.8, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef zeroext i1 @_ZNK8ImVectorItE5emptyEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %cmp = icmp eq i32 %0, 0
  ret i1 %cmp
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 4 dereferenceable(20) ptr @_ZN8ImVectorI10ImDrawVertEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.ImDrawVert, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 2 dereferenceable(2) ptr @_ZN8ImVectorItEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds i16, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI10ImDrawVertE4swapERS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  %rhs_size = alloca i32, align 4
  %rhs_cap = alloca i32, align 4
  %rhs_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.2, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  store i32 %1, ptr %rhs_size, align 4
  %Size2 = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 0
  %2 = load i32, ptr %Size2, align 8
  %3 = load ptr, ptr %rhs.addr, align 8
  %Size3 = getelementptr inbounds %struct.ImVector.2, ptr %3, i32 0, i32 0
  store i32 %2, ptr %Size3, align 8
  %4 = load i32, ptr %rhs_size, align 4
  %Size4 = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 0
  store i32 %4, ptr %Size4, align 8
  %5 = load ptr, ptr %rhs.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.2, ptr %5, i32 0, i32 1
  %6 = load i32, ptr %Capacity, align 4
  store i32 %6, ptr %rhs_cap, align 4
  %Capacity5 = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 1
  %7 = load i32, ptr %Capacity5, align 4
  %8 = load ptr, ptr %rhs.addr, align 8
  %Capacity6 = getelementptr inbounds %struct.ImVector.2, ptr %8, i32 0, i32 1
  store i32 %7, ptr %Capacity6, align 4
  %9 = load i32, ptr %rhs_cap, align 4
  %Capacity7 = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity7, align 4
  %10 = load ptr, ptr %rhs.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.2, ptr %10, i32 0, i32 2
  %11 = load ptr, ptr %Data, align 8
  store ptr %11, ptr %rhs_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 2
  %12 = load ptr, ptr %Data8, align 8
  %13 = load ptr, ptr %rhs.addr, align 8
  %Data9 = getelementptr inbounds %struct.ImVector.2, ptr %13, i32 0, i32 2
  store ptr %12, ptr %Data9, align 8
  %14 = load ptr, ptr %rhs_data, align 8
  %Data10 = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 2
  store ptr %14, ptr %Data10, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI10ImDrawVertED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Data2 = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  invoke void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %invoke.cont, %entry
  ret void

terminate.lpad:                                   ; preds = %if.then
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #13
  unreachable
}

; Function Attrs: mustprogress uwtable
define void @_ZN10ImDrawData14ScaleClipRectsERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(64) %this, ptr noundef nonnull align 4 dereferenceable(8) %fb_scale) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %fb_scale.addr = alloca ptr, align 8
  %__range1 = alloca ptr, align 8
  %__begin1 = alloca ptr, align 8
  %__end1 = alloca ptr, align 8
  %draw_list = alloca ptr, align 8
  %__range2 = alloca ptr, align 8
  %__begin2 = alloca ptr, align 8
  %__end2 = alloca ptr, align 8
  %cmd = alloca ptr, align 8
  %ref.tmp = alloca %struct.ImVec4, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %fb_scale, ptr %fb_scale.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %CmdLists = getelementptr inbounds %struct.ImDrawData, ptr %this1, i32 0, i32 4
  store ptr %CmdLists, ptr %__range1, align 8
  %0 = load ptr, ptr %__range1, align 8
  %call = call noundef ptr @_ZN8ImVectorIP10ImDrawListE5beginEv(ptr noundef nonnull align 8 dereferenceable(16) %0)
  store ptr %call, ptr %__begin1, align 8
  %1 = load ptr, ptr %__range1, align 8
  %call2 = call noundef ptr @_ZN8ImVectorIP10ImDrawListE3endEv(ptr noundef nonnull align 8 dereferenceable(16) %1)
  store ptr %call2, ptr %__end1, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc19, %entry
  %2 = load ptr, ptr %__begin1, align 8
  %3 = load ptr, ptr %__end1, align 8
  %cmp = icmp ne ptr %2, %3
  br i1 %cmp, label %for.body, label %for.end21

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %__begin1, align 8
  %5 = load ptr, ptr %4, align 8
  store ptr %5, ptr %draw_list, align 8
  %6 = load ptr, ptr %draw_list, align 8
  %CmdBuffer = getelementptr inbounds %struct.ImDrawList, ptr %6, i32 0, i32 0
  store ptr %CmdBuffer, ptr %__range2, align 8
  %7 = load ptr, ptr %__range2, align 8
  %call3 = call noundef ptr @_ZN8ImVectorI9ImDrawCmdE5beginEv(ptr noundef nonnull align 8 dereferenceable(16) %7)
  store ptr %call3, ptr %__begin2, align 8
  %8 = load ptr, ptr %__range2, align 8
  %call4 = call noundef ptr @_ZN8ImVectorI9ImDrawCmdE3endEv(ptr noundef nonnull align 8 dereferenceable(16) %8)
  store ptr %call4, ptr %__end2, align 8
  br label %for.cond5

for.cond5:                                        ; preds = %for.inc, %for.body
  %9 = load ptr, ptr %__begin2, align 8
  %10 = load ptr, ptr %__end2, align 8
  %cmp6 = icmp ne ptr %9, %10
  br i1 %cmp6, label %for.body7, label %for.end

for.body7:                                        ; preds = %for.cond5
  %11 = load ptr, ptr %__begin2, align 8
  store ptr %11, ptr %cmd, align 8
  %12 = load ptr, ptr %cmd, align 8
  %ClipRect = getelementptr inbounds %struct.ImDrawCmd, ptr %12, i32 0, i32 0
  %x = getelementptr inbounds %struct.ImVec4, ptr %ClipRect, i32 0, i32 0
  %13 = load float, ptr %x, align 8
  %14 = load ptr, ptr %fb_scale.addr, align 8
  %x8 = getelementptr inbounds %struct.ImVec2, ptr %14, i32 0, i32 0
  %15 = load float, ptr %x8, align 4
  %mul = fmul float %13, %15
  %16 = load ptr, ptr %cmd, align 8
  %ClipRect9 = getelementptr inbounds %struct.ImDrawCmd, ptr %16, i32 0, i32 0
  %y = getelementptr inbounds %struct.ImVec4, ptr %ClipRect9, i32 0, i32 1
  %17 = load float, ptr %y, align 4
  %18 = load ptr, ptr %fb_scale.addr, align 8
  %y10 = getelementptr inbounds %struct.ImVec2, ptr %18, i32 0, i32 1
  %19 = load float, ptr %y10, align 4
  %mul11 = fmul float %17, %19
  %20 = load ptr, ptr %cmd, align 8
  %ClipRect12 = getelementptr inbounds %struct.ImDrawCmd, ptr %20, i32 0, i32 0
  %z = getelementptr inbounds %struct.ImVec4, ptr %ClipRect12, i32 0, i32 2
  %21 = load float, ptr %z, align 8
  %22 = load ptr, ptr %fb_scale.addr, align 8
  %x13 = getelementptr inbounds %struct.ImVec2, ptr %22, i32 0, i32 0
  %23 = load float, ptr %x13, align 4
  %mul14 = fmul float %21, %23
  %24 = load ptr, ptr %cmd, align 8
  %ClipRect15 = getelementptr inbounds %struct.ImDrawCmd, ptr %24, i32 0, i32 0
  %w = getelementptr inbounds %struct.ImVec4, ptr %ClipRect15, i32 0, i32 3
  %25 = load float, ptr %w, align 4
  %26 = load ptr, ptr %fb_scale.addr, align 8
  %y16 = getelementptr inbounds %struct.ImVec2, ptr %26, i32 0, i32 1
  %27 = load float, ptr %y16, align 4
  %mul17 = fmul float %25, %27
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp, float noundef %mul, float noundef %mul11, float noundef %mul14, float noundef %mul17)
  %28 = load ptr, ptr %cmd, align 8
  %ClipRect18 = getelementptr inbounds %struct.ImDrawCmd, ptr %28, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ClipRect18, ptr align 4 %ref.tmp, i64 16, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body7
  %29 = load ptr, ptr %__begin2, align 8
  %incdec.ptr = getelementptr inbounds %struct.ImDrawCmd, ptr %29, i32 1
  store ptr %incdec.ptr, ptr %__begin2, align 8
  br label %for.cond5

for.end:                                          ; preds = %for.cond5
  br label %for.inc19

for.inc19:                                        ; preds = %for.end
  %30 = load ptr, ptr %__begin1, align 8
  %incdec.ptr20 = getelementptr inbounds ptr, ptr %30, i32 1
  store ptr %incdec.ptr20, ptr %__begin1, align 8
  br label %for.cond

for.end21:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZN8ImVectorIP10ImDrawListE5beginEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.8, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZN8ImVectorIP10ImDrawListE3endEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.8, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %Size = getelementptr inbounds %struct.ImVector.8, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr inbounds ptr, ptr %0, i64 %idx.ext
  ret ptr %add.ptr
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZN8ImVectorI9ImDrawCmdE5beginEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZN8ImVectorI9ImDrawCmdE3endEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %Size = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr inbounds %struct.ImDrawCmd, ptr %0, i64 %idx.ext
  ret ptr %add.ptr
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui38ShadeVertsLinearColorGradientKeepAlphaEP10ImDrawListii6ImVec2S2_jj(ptr noundef %draw_list, i32 noundef %vert_start_idx, i32 noundef %vert_end_idx, <2 x float> %gradient_p0.coerce, <2 x float> %gradient_p1.coerce, i32 noundef %col0, i32 noundef %col1) #0 {
entry:
  %gradient_p0 = alloca %struct.ImVec2, align 4
  %gradient_p1 = alloca %struct.ImVec2, align 4
  %draw_list.addr = alloca ptr, align 8
  %vert_start_idx.addr = alloca i32, align 4
  %vert_end_idx.addr = alloca i32, align 4
  %col0.addr = alloca i32, align 4
  %col1.addr = alloca i32, align 4
  %gradient_extent = alloca %struct.ImVec2, align 4
  %gradient_inv_length2 = alloca float, align 4
  %vert_start = alloca ptr, align 8
  %vert_end = alloca ptr, align 8
  %col0_r = alloca i32, align 4
  %col0_g = alloca i32, align 4
  %col0_b = alloca i32, align 4
  %col_delta_r = alloca i32, align 4
  %col_delta_g = alloca i32, align 4
  %col_delta_b = alloca i32, align 4
  %vert = alloca ptr, align 8
  %d = alloca float, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  %t = alloca float, align 4
  %r = alloca i32, align 4
  %g = alloca i32, align 4
  %b = alloca i32, align 4
  store <2 x float> %gradient_p0.coerce, ptr %gradient_p0, align 4
  store <2 x float> %gradient_p1.coerce, ptr %gradient_p1, align 4
  store ptr %draw_list, ptr %draw_list.addr, align 8
  store i32 %vert_start_idx, ptr %vert_start_idx.addr, align 4
  store i32 %vert_end_idx, ptr %vert_end_idx.addr, align 4
  store i32 %col0, ptr %col0.addr, align 4
  store i32 %col1, ptr %col1.addr, align 4
  %call = call <2 x float> @_ZmiRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %gradient_p1, ptr noundef nonnull align 4 dereferenceable(8) %gradient_p0)
  store <2 x float> %call, ptr %gradient_extent, align 4
  %call1 = call noundef float @_ZL11ImLengthSqrRK6ImVec2(ptr noundef nonnull align 4 dereferenceable(8) %gradient_extent)
  %div = fdiv float 1.000000e+00, %call1
  store float %div, ptr %gradient_inv_length2, align 4
  %0 = load ptr, ptr %draw_list.addr, align 8
  %VtxBuffer = getelementptr inbounds %struct.ImDrawList, ptr %0, i32 0, i32 2
  %Data = getelementptr inbounds %struct.ImVector.2, ptr %VtxBuffer, i32 0, i32 2
  %1 = load ptr, ptr %Data, align 8
  %2 = load i32, ptr %vert_start_idx.addr, align 4
  %idx.ext = sext i32 %2 to i64
  %add.ptr = getelementptr inbounds %struct.ImDrawVert, ptr %1, i64 %idx.ext
  store ptr %add.ptr, ptr %vert_start, align 8
  %3 = load ptr, ptr %draw_list.addr, align 8
  %VtxBuffer2 = getelementptr inbounds %struct.ImDrawList, ptr %3, i32 0, i32 2
  %Data3 = getelementptr inbounds %struct.ImVector.2, ptr %VtxBuffer2, i32 0, i32 2
  %4 = load ptr, ptr %Data3, align 8
  %5 = load i32, ptr %vert_end_idx.addr, align 4
  %idx.ext4 = sext i32 %5 to i64
  %add.ptr5 = getelementptr inbounds %struct.ImDrawVert, ptr %4, i64 %idx.ext4
  store ptr %add.ptr5, ptr %vert_end, align 8
  %6 = load i32, ptr %col0.addr, align 4
  %shr = lshr i32 %6, 0
  %and = and i32 %shr, 255
  store i32 %and, ptr %col0_r, align 4
  %7 = load i32, ptr %col0.addr, align 4
  %shr6 = lshr i32 %7, 8
  %and7 = and i32 %shr6, 255
  store i32 %and7, ptr %col0_g, align 4
  %8 = load i32, ptr %col0.addr, align 4
  %shr8 = lshr i32 %8, 16
  %and9 = and i32 %shr8, 255
  store i32 %and9, ptr %col0_b, align 4
  %9 = load i32, ptr %col1.addr, align 4
  %shr10 = lshr i32 %9, 0
  %and11 = and i32 %shr10, 255
  %10 = load i32, ptr %col0_r, align 4
  %sub = sub nsw i32 %and11, %10
  store i32 %sub, ptr %col_delta_r, align 4
  %11 = load i32, ptr %col1.addr, align 4
  %shr12 = lshr i32 %11, 8
  %and13 = and i32 %shr12, 255
  %12 = load i32, ptr %col0_g, align 4
  %sub14 = sub nsw i32 %and13, %12
  store i32 %sub14, ptr %col_delta_g, align 4
  %13 = load i32, ptr %col1.addr, align 4
  %shr15 = lshr i32 %13, 16
  %and16 = and i32 %shr15, 255
  %14 = load i32, ptr %col0_b, align 4
  %sub17 = sub nsw i32 %and16, %14
  store i32 %sub17, ptr %col_delta_b, align 4
  %15 = load ptr, ptr %vert_start, align 8
  store ptr %15, ptr %vert, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %16 = load ptr, ptr %vert, align 8
  %17 = load ptr, ptr %vert_end, align 8
  %cmp = icmp ult ptr %16, %17
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %18 = load ptr, ptr %vert, align 8
  %pos = getelementptr inbounds %struct.ImDrawVert, ptr %18, i32 0, i32 0
  %call18 = call <2 x float> @_ZmiRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %pos, ptr noundef nonnull align 4 dereferenceable(8) %gradient_p0)
  store <2 x float> %call18, ptr %ref.tmp, align 4
  %call19 = call noundef float @_ZL5ImDotRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(8) %gradient_extent)
  store float %call19, ptr %d, align 4
  %19 = load float, ptr %d, align 4
  %20 = load float, ptr %gradient_inv_length2, align 4
  %mul = fmul float %19, %20
  %call20 = call noundef float @_ZL7ImClampIfET_S0_S0_S0_(float noundef %mul, float noundef 0.000000e+00, float noundef 1.000000e+00)
  store float %call20, ptr %t, align 4
  %21 = load i32, ptr %col0_r, align 4
  %conv = sitofp i32 %21 to float
  %22 = load i32, ptr %col_delta_r, align 4
  %conv21 = sitofp i32 %22 to float
  %23 = load float, ptr %t, align 4
  %24 = call float @llvm.fmuladd.f32(float %conv21, float %23, float %conv)
  %conv23 = fptosi float %24 to i32
  store i32 %conv23, ptr %r, align 4
  %25 = load i32, ptr %col0_g, align 4
  %conv24 = sitofp i32 %25 to float
  %26 = load i32, ptr %col_delta_g, align 4
  %conv25 = sitofp i32 %26 to float
  %27 = load float, ptr %t, align 4
  %28 = call float @llvm.fmuladd.f32(float %conv25, float %27, float %conv24)
  %conv27 = fptosi float %28 to i32
  store i32 %conv27, ptr %g, align 4
  %29 = load i32, ptr %col0_b, align 4
  %conv28 = sitofp i32 %29 to float
  %30 = load i32, ptr %col_delta_b, align 4
  %conv29 = sitofp i32 %30 to float
  %31 = load float, ptr %t, align 4
  %32 = call float @llvm.fmuladd.f32(float %conv29, float %31, float %conv28)
  %conv31 = fptosi float %32 to i32
  store i32 %conv31, ptr %b, align 4
  %33 = load i32, ptr %r, align 4
  %shl = shl i32 %33, 0
  %34 = load i32, ptr %g, align 4
  %shl32 = shl i32 %34, 8
  %or = or i32 %shl, %shl32
  %35 = load i32, ptr %b, align 4
  %shl33 = shl i32 %35, 16
  %or34 = or i32 %or, %shl33
  %36 = load ptr, ptr %vert, align 8
  %col = getelementptr inbounds %struct.ImDrawVert, ptr %36, i32 0, i32 2
  %37 = load i32, ptr %col, align 4
  %and35 = and i32 %37, -16777216
  %or36 = or i32 %or34, %and35
  %38 = load ptr, ptr %vert, align 8
  %col37 = getelementptr inbounds %struct.ImDrawVert, ptr %38, i32 0, i32 2
  store i32 %or36, ptr %col37, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %39 = load ptr, ptr %vert, align 8
  %incdec.ptr = getelementptr inbounds %struct.ImDrawVert, ptr %39, i32 1
  store ptr %incdec.ptr, ptr %vert, align 8
  br label %for.cond, !llvm.loop !38

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef float @_ZL11ImLengthSqrRK6ImVec2(ptr noundef nonnull align 4 dereferenceable(8) %lhs) #2 {
entry:
  %lhs.addr = alloca ptr, align 8
  store ptr %lhs, ptr %lhs.addr, align 8
  %0 = load ptr, ptr %lhs.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %0, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %2 = load ptr, ptr %lhs.addr, align 8
  %x1 = getelementptr inbounds %struct.ImVec2, ptr %2, i32 0, i32 0
  %3 = load float, ptr %x1, align 4
  %4 = load ptr, ptr %lhs.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %4, i32 0, i32 1
  %5 = load float, ptr %y, align 4
  %6 = load ptr, ptr %lhs.addr, align 8
  %y2 = getelementptr inbounds %struct.ImVec2, ptr %6, i32 0, i32 1
  %7 = load float, ptr %y2, align 4
  %mul3 = fmul float %5, %7
  %8 = call float @llvm.fmuladd.f32(float %1, float %3, float %mul3)
  ret float %8
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef float @_ZL5ImDotRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %a, ptr noundef nonnull align 4 dereferenceable(8) %b) #2 {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %0, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %2 = load ptr, ptr %b.addr, align 8
  %x1 = getelementptr inbounds %struct.ImVec2, ptr %2, i32 0, i32 0
  %3 = load float, ptr %x1, align 4
  %4 = load ptr, ptr %a.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %4, i32 0, i32 1
  %5 = load float, ptr %y, align 4
  %6 = load ptr, ptr %b.addr, align 8
  %y2 = getelementptr inbounds %struct.ImVec2, ptr %6, i32 0, i32 1
  %7 = load float, ptr %y2, align 4
  %mul3 = fmul float %5, %7
  %8 = call float @llvm.fmuladd.f32(float %1, float %3, float %mul3)
  ret float %8
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef float @_ZL7ImClampIfET_S0_S0_S0_(float noundef %v, float noundef %mn, float noundef %mx) #2 {
entry:
  %v.addr = alloca float, align 4
  %mn.addr = alloca float, align 4
  %mx.addr = alloca float, align 4
  store float %v, ptr %v.addr, align 4
  store float %mn, ptr %mn.addr, align 4
  store float %mx, ptr %mx.addr, align 4
  %0 = load float, ptr %v.addr, align 4
  %1 = load float, ptr %mn.addr, align 4
  %cmp = fcmp olt float %0, %1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load float, ptr %mn.addr, align 4
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %3 = load float, ptr %v.addr, align 4
  %4 = load float, ptr %mx.addr, align 4
  %cmp1 = fcmp ogt float %3, %4
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %5 = load float, ptr %mx.addr, align 4
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  %6 = load float, ptr %v.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi float [ %5, %cond.true2 ], [ %6, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi float [ %2, %cond.true ], [ %cond, %cond.end ]
  ret float %cond5
}

; Function Attrs: mustprogress uwtable
define internal <2 x float> @_ZL5ImMinRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %lhs, ptr noundef nonnull align 4 dereferenceable(8) %rhs) #0 {
entry:
  %retval = alloca %struct.ImVec2, align 4
  %lhs.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %lhs, ptr %lhs.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %0 = load ptr, ptr %lhs.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %0, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %2 = load ptr, ptr %rhs.addr, align 8
  %x1 = getelementptr inbounds %struct.ImVec2, ptr %2, i32 0, i32 0
  %3 = load float, ptr %x1, align 4
  %cmp = fcmp olt float %1, %3
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load ptr, ptr %lhs.addr, align 8
  %x2 = getelementptr inbounds %struct.ImVec2, ptr %4, i32 0, i32 0
  %5 = load float, ptr %x2, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load ptr, ptr %rhs.addr, align 8
  %x3 = getelementptr inbounds %struct.ImVec2, ptr %6, i32 0, i32 0
  %7 = load float, ptr %x3, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %5, %cond.true ], [ %7, %cond.false ]
  %8 = load ptr, ptr %lhs.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %8, i32 0, i32 1
  %9 = load float, ptr %y, align 4
  %10 = load ptr, ptr %rhs.addr, align 8
  %y4 = getelementptr inbounds %struct.ImVec2, ptr %10, i32 0, i32 1
  %11 = load float, ptr %y4, align 4
  %cmp5 = fcmp olt float %9, %11
  br i1 %cmp5, label %cond.true6, label %cond.false8

cond.true6:                                       ; preds = %cond.end
  %12 = load ptr, ptr %lhs.addr, align 8
  %y7 = getelementptr inbounds %struct.ImVec2, ptr %12, i32 0, i32 1
  %13 = load float, ptr %y7, align 4
  br label %cond.end10

cond.false8:                                      ; preds = %cond.end
  %14 = load ptr, ptr %rhs.addr, align 8
  %y9 = getelementptr inbounds %struct.ImVec2, ptr %14, i32 0, i32 1
  %15 = load float, ptr %y9, align 4
  br label %cond.end10

cond.end10:                                       ; preds = %cond.false8, %cond.true6
  %cond11 = phi float [ %13, %cond.true6 ], [ %15, %cond.false8 ]
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %retval, float noundef %cond, float noundef %cond11)
  %16 = load <2 x float>, ptr %retval, align 4
  ret <2 x float> %16
}

; Function Attrs: mustprogress uwtable
define internal <2 x float> @_ZL5ImMaxRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %lhs, ptr noundef nonnull align 4 dereferenceable(8) %rhs) #0 {
entry:
  %retval = alloca %struct.ImVec2, align 4
  %lhs.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %lhs, ptr %lhs.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %0 = load ptr, ptr %lhs.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %0, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %2 = load ptr, ptr %rhs.addr, align 8
  %x1 = getelementptr inbounds %struct.ImVec2, ptr %2, i32 0, i32 0
  %3 = load float, ptr %x1, align 4
  %cmp = fcmp oge float %1, %3
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load ptr, ptr %lhs.addr, align 8
  %x2 = getelementptr inbounds %struct.ImVec2, ptr %4, i32 0, i32 0
  %5 = load float, ptr %x2, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load ptr, ptr %rhs.addr, align 8
  %x3 = getelementptr inbounds %struct.ImVec2, ptr %6, i32 0, i32 0
  %7 = load float, ptr %x3, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %5, %cond.true ], [ %7, %cond.false ]
  %8 = load ptr, ptr %lhs.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %8, i32 0, i32 1
  %9 = load float, ptr %y, align 4
  %10 = load ptr, ptr %rhs.addr, align 8
  %y4 = getelementptr inbounds %struct.ImVec2, ptr %10, i32 0, i32 1
  %11 = load float, ptr %y4, align 4
  %cmp5 = fcmp oge float %9, %11
  br i1 %cmp5, label %cond.true6, label %cond.false8

cond.true6:                                       ; preds = %cond.end
  %12 = load ptr, ptr %lhs.addr, align 8
  %y7 = getelementptr inbounds %struct.ImVec2, ptr %12, i32 0, i32 1
  %13 = load float, ptr %y7, align 4
  br label %cond.end10

cond.false8:                                      ; preds = %cond.end
  %14 = load ptr, ptr %rhs.addr, align 8
  %y9 = getelementptr inbounds %struct.ImVec2, ptr %14, i32 0, i32 1
  %15 = load float, ptr %y9, align 4
  br label %cond.end10

cond.end10:                                       ; preds = %cond.false8, %cond.true6
  %cond11 = phi float [ %13, %cond.true6 ], [ %15, %cond.false8 ]
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %retval, float noundef %cond, float noundef %cond11)
  %16 = load <2 x float>, ptr %retval, align 4
  ret <2 x float> %16
}

; Function Attrs: mustprogress uwtable
define internal <2 x float> @_ZL7ImClampRK6ImVec2S1_S_(ptr noundef nonnull align 4 dereferenceable(8) %v, ptr noundef nonnull align 4 dereferenceable(8) %mn, <2 x float> %mx.coerce) #0 {
entry:
  %retval = alloca %struct.ImVec2, align 4
  %mx = alloca %struct.ImVec2, align 4
  %v.addr = alloca ptr, align 8
  %mn.addr = alloca ptr, align 8
  store <2 x float> %mx.coerce, ptr %mx, align 4
  store ptr %v, ptr %v.addr, align 8
  store ptr %mn, ptr %mn.addr, align 8
  %0 = load ptr, ptr %v.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %0, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %2 = load ptr, ptr %mn.addr, align 8
  %x1 = getelementptr inbounds %struct.ImVec2, ptr %2, i32 0, i32 0
  %3 = load float, ptr %x1, align 4
  %cmp = fcmp olt float %1, %3
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load ptr, ptr %mn.addr, align 8
  %x2 = getelementptr inbounds %struct.ImVec2, ptr %4, i32 0, i32 0
  %5 = load float, ptr %x2, align 4
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %6 = load ptr, ptr %v.addr, align 8
  %x3 = getelementptr inbounds %struct.ImVec2, ptr %6, i32 0, i32 0
  %7 = load float, ptr %x3, align 4
  %x4 = getelementptr inbounds %struct.ImVec2, ptr %mx, i32 0, i32 0
  %8 = load float, ptr %x4, align 4
  %cmp5 = fcmp ogt float %7, %8
  br i1 %cmp5, label %cond.true6, label %cond.false8

cond.true6:                                       ; preds = %cond.false
  %x7 = getelementptr inbounds %struct.ImVec2, ptr %mx, i32 0, i32 0
  %9 = load float, ptr %x7, align 4
  br label %cond.end

cond.false8:                                      ; preds = %cond.false
  %10 = load ptr, ptr %v.addr, align 8
  %x9 = getelementptr inbounds %struct.ImVec2, ptr %10, i32 0, i32 0
  %11 = load float, ptr %x9, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false8, %cond.true6
  %cond = phi float [ %9, %cond.true6 ], [ %11, %cond.false8 ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end, %cond.true
  %cond11 = phi float [ %5, %cond.true ], [ %cond, %cond.end ]
  %12 = load ptr, ptr %v.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %12, i32 0, i32 1
  %13 = load float, ptr %y, align 4
  %14 = load ptr, ptr %mn.addr, align 8
  %y12 = getelementptr inbounds %struct.ImVec2, ptr %14, i32 0, i32 1
  %15 = load float, ptr %y12, align 4
  %cmp13 = fcmp olt float %13, %15
  br i1 %cmp13, label %cond.true14, label %cond.false16

cond.true14:                                      ; preds = %cond.end10
  %16 = load ptr, ptr %mn.addr, align 8
  %y15 = getelementptr inbounds %struct.ImVec2, ptr %16, i32 0, i32 1
  %17 = load float, ptr %y15, align 4
  br label %cond.end26

cond.false16:                                     ; preds = %cond.end10
  %18 = load ptr, ptr %v.addr, align 8
  %y17 = getelementptr inbounds %struct.ImVec2, ptr %18, i32 0, i32 1
  %19 = load float, ptr %y17, align 4
  %y18 = getelementptr inbounds %struct.ImVec2, ptr %mx, i32 0, i32 1
  %20 = load float, ptr %y18, align 4
  %cmp19 = fcmp ogt float %19, %20
  br i1 %cmp19, label %cond.true20, label %cond.false22

cond.true20:                                      ; preds = %cond.false16
  %y21 = getelementptr inbounds %struct.ImVec2, ptr %mx, i32 0, i32 1
  %21 = load float, ptr %y21, align 4
  br label %cond.end24

cond.false22:                                     ; preds = %cond.false16
  %22 = load ptr, ptr %v.addr, align 8
  %y23 = getelementptr inbounds %struct.ImVec2, ptr %22, i32 0, i32 1
  %23 = load float, ptr %y23, align 4
  br label %cond.end24

cond.end24:                                       ; preds = %cond.false22, %cond.true20
  %cond25 = phi float [ %21, %cond.true20 ], [ %23, %cond.false22 ]
  br label %cond.end26

cond.end26:                                       ; preds = %cond.end24, %cond.true14
  %cond27 = phi float [ %17, %cond.true14 ], [ %cond25, %cond.end24 ]
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %retval, float noundef %cond11, float noundef %cond27)
  %24 = load <2 x float>, ptr %retval, align 4
  ret <2 x float> %24
}

; Function Attrs: mustprogress uwtable
define internal <2 x float> @_ZL5ImMulRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %lhs, ptr noundef nonnull align 4 dereferenceable(8) %rhs) #0 {
entry:
  %retval = alloca %struct.ImVec2, align 4
  %lhs.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %lhs, ptr %lhs.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %0 = load ptr, ptr %lhs.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %0, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %2 = load ptr, ptr %rhs.addr, align 8
  %x1 = getelementptr inbounds %struct.ImVec2, ptr %2, i32 0, i32 0
  %3 = load float, ptr %x1, align 4
  %mul = fmul float %1, %3
  %4 = load ptr, ptr %lhs.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %4, i32 0, i32 1
  %5 = load float, ptr %y, align 4
  %6 = load ptr, ptr %rhs.addr, align 8
  %y2 = getelementptr inbounds %struct.ImVec2, ptr %6, i32 0, i32 1
  %7 = load float, ptr %y2, align 4
  %mul3 = fmul float %5, %7
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %retval, float noundef %mul, float noundef %mul3)
  %8 = load <2 x float>, ptr %retval, align 4
  ret <2 x float> %8
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui22ShadeVertsTransformPosEP10ImDrawListiiRK6ImVec2ffS4_(ptr noundef %draw_list, i32 noundef %vert_start_idx, i32 noundef %vert_end_idx, ptr noundef nonnull align 4 dereferenceable(8) %pivot_in, float noundef %cos_a, float noundef %sin_a, ptr noundef nonnull align 4 dereferenceable(8) %pivot_out) #0 {
entry:
  %draw_list.addr = alloca ptr, align 8
  %vert_start_idx.addr = alloca i32, align 4
  %vert_end_idx.addr = alloca i32, align 4
  %pivot_in.addr = alloca ptr, align 8
  %cos_a.addr = alloca float, align 4
  %sin_a.addr = alloca float, align 4
  %pivot_out.addr = alloca ptr, align 8
  %vert_start = alloca ptr, align 8
  %vert_end = alloca ptr, align 8
  %vertex = alloca ptr, align 8
  %ref.tmp = alloca %struct.ImVec2, align 4
  %ref.tmp5 = alloca %struct.ImVec2, align 4
  %ref.tmp6 = alloca %struct.ImVec2, align 4
  store ptr %draw_list, ptr %draw_list.addr, align 8
  store i32 %vert_start_idx, ptr %vert_start_idx.addr, align 4
  store i32 %vert_end_idx, ptr %vert_end_idx.addr, align 4
  store ptr %pivot_in, ptr %pivot_in.addr, align 8
  store float %cos_a, ptr %cos_a.addr, align 4
  store float %sin_a, ptr %sin_a.addr, align 4
  store ptr %pivot_out, ptr %pivot_out.addr, align 8
  %0 = load ptr, ptr %draw_list.addr, align 8
  %VtxBuffer = getelementptr inbounds %struct.ImDrawList, ptr %0, i32 0, i32 2
  %Data = getelementptr inbounds %struct.ImVector.2, ptr %VtxBuffer, i32 0, i32 2
  %1 = load ptr, ptr %Data, align 8
  %2 = load i32, ptr %vert_start_idx.addr, align 4
  %idx.ext = sext i32 %2 to i64
  %add.ptr = getelementptr inbounds %struct.ImDrawVert, ptr %1, i64 %idx.ext
  store ptr %add.ptr, ptr %vert_start, align 8
  %3 = load ptr, ptr %draw_list.addr, align 8
  %VtxBuffer1 = getelementptr inbounds %struct.ImDrawList, ptr %3, i32 0, i32 2
  %Data2 = getelementptr inbounds %struct.ImVector.2, ptr %VtxBuffer1, i32 0, i32 2
  %4 = load ptr, ptr %Data2, align 8
  %5 = load i32, ptr %vert_end_idx.addr, align 4
  %idx.ext3 = sext i32 %5 to i64
  %add.ptr4 = getelementptr inbounds %struct.ImDrawVert, ptr %4, i64 %idx.ext3
  store ptr %add.ptr4, ptr %vert_end, align 8
  %6 = load ptr, ptr %vert_start, align 8
  store ptr %6, ptr %vertex, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load ptr, ptr %vertex, align 8
  %8 = load ptr, ptr %vert_end, align 8
  %cmp = icmp ult ptr %7, %8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr %vertex, align 8
  %pos = getelementptr inbounds %struct.ImDrawVert, ptr %9, i32 0, i32 0
  %10 = load ptr, ptr %pivot_in.addr, align 8
  %call = call <2 x float> @_ZmiRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %pos, ptr noundef nonnull align 4 dereferenceable(8) %10)
  store <2 x float> %call, ptr %ref.tmp6, align 4
  %11 = load float, ptr %cos_a.addr, align 4
  %12 = load float, ptr %sin_a.addr, align 4
  %call7 = call <2 x float> @_ZL8ImRotateRK6ImVec2ff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp6, float noundef %11, float noundef %12)
  store <2 x float> %call7, ptr %ref.tmp5, align 4
  %13 = load ptr, ptr %pivot_out.addr, align 8
  %call8 = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp5, ptr noundef nonnull align 4 dereferenceable(8) %13)
  store <2 x float> %call8, ptr %ref.tmp, align 4
  %14 = load ptr, ptr %vertex, align 8
  %pos9 = getelementptr inbounds %struct.ImDrawVert, ptr %14, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %pos9, ptr align 4 %ref.tmp, i64 8, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %15 = load ptr, ptr %vertex, align 8
  %incdec.ptr = getelementptr inbounds %struct.ImDrawVert, ptr %15, i32 1
  store ptr %incdec.ptr, ptr %vertex, align 8
  br label %for.cond, !llvm.loop !39

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define internal <2 x float> @_ZL8ImRotateRK6ImVec2ff(ptr noundef nonnull align 4 dereferenceable(8) %v, float noundef %cos_a, float noundef %sin_a) #0 {
entry:
  %retval = alloca %struct.ImVec2, align 4
  %v.addr = alloca ptr, align 8
  %cos_a.addr = alloca float, align 4
  %sin_a.addr = alloca float, align 4
  store ptr %v, ptr %v.addr, align 8
  store float %cos_a, ptr %cos_a.addr, align 4
  store float %sin_a, ptr %sin_a.addr, align 4
  %0 = load ptr, ptr %v.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %0, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %2 = load float, ptr %cos_a.addr, align 4
  %3 = load ptr, ptr %v.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %3, i32 0, i32 1
  %4 = load float, ptr %y, align 4
  %5 = load float, ptr %sin_a.addr, align 4
  %mul1 = fmul float %4, %5
  %neg = fneg float %mul1
  %6 = call float @llvm.fmuladd.f32(float %1, float %2, float %neg)
  %7 = load ptr, ptr %v.addr, align 8
  %x2 = getelementptr inbounds %struct.ImVec2, ptr %7, i32 0, i32 0
  %8 = load float, ptr %x2, align 4
  %9 = load float, ptr %sin_a.addr, align 4
  %10 = load ptr, ptr %v.addr, align 8
  %y3 = getelementptr inbounds %struct.ImVec2, ptr %10, i32 0, i32 1
  %11 = load float, ptr %y3, align 4
  %12 = load float, ptr %cos_a.addr, align 4
  %mul4 = fmul float %11, %12
  %13 = call float @llvm.fmuladd.f32(float %8, float %9, float %mul4)
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %retval, float noundef %6, float noundef %13)
  %14 = load <2 x float>, ptr %retval, align 4
  ret <2 x float> %14
}

; Function Attrs: mustprogress uwtable
define void @_ZN12ImFontConfigC2Ev(ptr noundef nonnull align 8 dereferenceable(144) %this) unnamed_addr #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %GlyphExtraSpacing = getelementptr inbounds %struct.ImFontConfig, ptr %this1, i32 0, i32 8
  call void @_ZN6ImVec2C2Ev(ptr noundef nonnull align 4 dereferenceable(8) %GlyphExtraSpacing)
  %GlyphOffset = getelementptr inbounds %struct.ImFontConfig, ptr %this1, i32 0, i32 9
  call void @_ZN6ImVec2C2Ev(ptr noundef nonnull align 4 dereferenceable(8) %GlyphOffset)
  call void @llvm.memset.p0.i64(ptr align 8 %this1, i8 0, i64 144, i1 false)
  %FontDataOwnedByAtlas = getelementptr inbounds %struct.ImFontConfig, ptr %this1, i32 0, i32 2
  store i8 1, ptr %FontDataOwnedByAtlas, align 4
  %OversampleH = getelementptr inbounds %struct.ImFontConfig, ptr %this1, i32 0, i32 5
  store i32 2, ptr %OversampleH, align 8
  %OversampleV = getelementptr inbounds %struct.ImFontConfig, ptr %this1, i32 0, i32 6
  store i32 1, ptr %OversampleV, align 4
  %GlyphMaxAdvanceX = getelementptr inbounds %struct.ImFontConfig, ptr %this1, i32 0, i32 12
  store float 0x47EFFFFFE0000000, ptr %GlyphMaxAdvanceX, align 4
  %RasterizerMultiply = getelementptr inbounds %struct.ImFontConfig, ptr %this1, i32 0, i32 15
  store float 1.000000e+00, ptr %RasterizerMultiply, align 8
  %RasterizerDensity = getelementptr inbounds %struct.ImFontConfig, ptr %this1, i32 0, i32 16
  store float 1.000000e+00, ptr %RasterizerDensity, align 4
  %EllipsisChar = getelementptr inbounds %struct.ImFontConfig, ptr %this1, i32 0, i32 17
  store i16 -1, ptr %EllipsisChar, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN11ImFontAtlasC2Ev(ptr noundef nonnull align 8 dereferenceable(1180) %this) unnamed_addr #4 align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %TexUvScale = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 15
  call void @_ZN6ImVec2C2Ev(ptr noundef nonnull align 4 dereferenceable(8) %TexUvScale)
  %TexUvWhitePixel = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 16
  call void @_ZN6ImVec2C2Ev(ptr noundef nonnull align 4 dereferenceable(8) %TexUvWhitePixel)
  %Fonts = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 17
  call void @_ZN8ImVectorIP6ImFontEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %Fonts)
  %CustomRects = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 18
  invoke void @_ZN8ImVectorI21ImFontAtlasCustomRectEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %CustomRects)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  %ConfigData = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 19
  invoke void @_ZN8ImVectorI12ImFontConfigEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %ConfigData)
          to label %invoke.cont3 unwind label %lpad2

invoke.cont3:                                     ; preds = %invoke.cont
  %TexUvLines = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 20
  %array.begin = getelementptr inbounds [64 x %struct.ImVec4], ptr %TexUvLines, i32 0, i32 0
  %arrayctor.end = getelementptr inbounds %struct.ImVec4, ptr %array.begin, i64 64
  br label %arrayctor.loop

arrayctor.loop:                                   ; preds = %invoke.cont5, %invoke.cont3
  %arrayctor.cur = phi ptr [ %array.begin, %invoke.cont3 ], [ %arrayctor.next, %invoke.cont5 ]
  invoke void @_ZN6ImVec4C2Ev(ptr noundef nonnull align 4 dereferenceable(16) %arrayctor.cur)
          to label %invoke.cont5 unwind label %lpad4

invoke.cont5:                                     ; preds = %arrayctor.loop
  %arrayctor.next = getelementptr inbounds %struct.ImVec4, ptr %arrayctor.cur, i64 1
  %arrayctor.done = icmp eq ptr %arrayctor.next, %arrayctor.end
  br i1 %arrayctor.done, label %arrayctor.cont, label %arrayctor.loop

arrayctor.cont:                                   ; preds = %invoke.cont5
  call void @llvm.memset.p0.i64(ptr align 8 %this1, i8 0, i64 1184, i1 false)
  %TexGlyphPadding = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 4
  store i32 1, ptr %TexGlyphPadding, align 4
  %PackIdLines = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 24
  store i32 -1, ptr %PackIdLines, align 8
  %PackIdMouseCursors = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 23
  store i32 -1, ptr %PackIdMouseCursors, align 4
  ret void

lpad:                                             ; preds = %entry
  %0 = landingpad { ptr, i32 }
          cleanup
  %1 = extractvalue { ptr, i32 } %0, 0
  store ptr %1, ptr %exn.slot, align 8
  %2 = extractvalue { ptr, i32 } %0, 1
  store i32 %2, ptr %ehselector.slot, align 4
  br label %ehcleanup6

lpad2:                                            ; preds = %invoke.cont
  %3 = landingpad { ptr, i32 }
          cleanup
  %4 = extractvalue { ptr, i32 } %3, 0
  store ptr %4, ptr %exn.slot, align 8
  %5 = extractvalue { ptr, i32 } %3, 1
  store i32 %5, ptr %ehselector.slot, align 4
  br label %ehcleanup

lpad4:                                            ; preds = %arrayctor.loop
  %6 = landingpad { ptr, i32 }
          cleanup
  %7 = extractvalue { ptr, i32 } %6, 0
  store ptr %7, ptr %exn.slot, align 8
  %8 = extractvalue { ptr, i32 } %6, 1
  store i32 %8, ptr %ehselector.slot, align 4
  call void @_ZN8ImVectorI12ImFontConfigED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %ConfigData) #12
  br label %ehcleanup

ehcleanup:                                        ; preds = %lpad4, %lpad2
  call void @_ZN8ImVectorI21ImFontAtlasCustomRectED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %CustomRects) #12
  br label %ehcleanup6

ehcleanup6:                                       ; preds = %ehcleanup, %lpad
  call void @_ZN8ImVectorIP6ImFontED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %Fonts) #12
  br label %eh.resume

eh.resume:                                        ; preds = %ehcleanup6
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val7 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val7
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorIP6ImFontEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI21ImFontAtlasCustomRectEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI12ImFontConfigEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI12ImFontConfigED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Data2 = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  invoke void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %invoke.cont, %entry
  ret void

terminate.lpad:                                   ; preds = %if.then
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #13
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI21ImFontAtlasCustomRectED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Data2 = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  invoke void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %invoke.cont, %entry
  ret void

terminate.lpad:                                   ; preds = %if.then
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #13
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorIP6ImFontED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Data2 = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  invoke void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %invoke.cont, %entry
  ret void

terminate.lpad:                                   ; preds = %if.then
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #13
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define void @_ZN11ImFontAtlasD2Ev(ptr noundef nonnull align 8 dereferenceable(1180) %this) unnamed_addr #2 align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  invoke void @_ZN11ImFontAtlas5ClearEv(ptr noundef nonnull align 8 dereferenceable(1180) %this1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %ConfigData = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 19
  call void @_ZN8ImVectorI12ImFontConfigED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %ConfigData) #12
  %CustomRects = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 18
  call void @_ZN8ImVectorI21ImFontAtlasCustomRectED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %CustomRects) #12
  %Fonts = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 17
  call void @_ZN8ImVectorIP6ImFontED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %Fonts) #12
  ret void

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #13
  unreachable
}

; Function Attrs: mustprogress uwtable
define void @_ZN11ImFontAtlas5ClearEv(ptr noundef nonnull align 8 dereferenceable(1180) %this) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN11ImFontAtlas14ClearInputDataEv(ptr noundef nonnull align 8 dereferenceable(1180) %this1)
  call void @_ZN11ImFontAtlas12ClearTexDataEv(ptr noundef nonnull align 8 dereferenceable(1180) %this1)
  call void @_ZN11ImFontAtlas10ClearFontsEv(ptr noundef nonnull align 8 dereferenceable(1180) %this1)
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define linkonce_odr hidden void @__clang_call_terminate(ptr noundef %0) #10 comdat {
  %2 = call ptr @__cxa_begin_catch(ptr %0) #12
  call void @_ZSt9terminatev() #13
  unreachable
}

declare ptr @__cxa_begin_catch(ptr)

declare void @_ZSt9terminatev()

; Function Attrs: mustprogress uwtable
define void @_ZN11ImFontAtlas14ClearInputDataEv(ptr noundef nonnull align 8 dereferenceable(1180) %this) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %__range1 = alloca ptr, align 8
  %__begin1 = alloca ptr, align 8
  %__end1 = alloca ptr, align 8
  %font_cfg = alloca ptr, align 8
  %__range16 = alloca ptr, align 8
  %__begin17 = alloca ptr, align 8
  %__end19 = alloca ptr, align 8
  %font = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %ConfigData = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 19
  store ptr %ConfigData, ptr %__range1, align 8
  %0 = load ptr, ptr %__range1, align 8
  %call = call noundef ptr @_ZN8ImVectorI12ImFontConfigE5beginEv(ptr noundef nonnull align 8 dereferenceable(16) %0)
  store ptr %call, ptr %__begin1, align 8
  %1 = load ptr, ptr %__range1, align 8
  %call2 = call noundef ptr @_ZN8ImVectorI12ImFontConfigE3endEv(ptr noundef nonnull align 8 dereferenceable(16) %1)
  store ptr %call2, ptr %__end1, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load ptr, ptr %__begin1, align 8
  %3 = load ptr, ptr %__end1, align 8
  %cmp = icmp ne ptr %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %__begin1, align 8
  store ptr %4, ptr %font_cfg, align 8
  %5 = load ptr, ptr %font_cfg, align 8
  %FontData = getelementptr inbounds %struct.ImFontConfig, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %FontData, align 8
  %tobool = icmp ne ptr %6, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %7 = load ptr, ptr %font_cfg, align 8
  %FontDataOwnedByAtlas = getelementptr inbounds %struct.ImFontConfig, ptr %7, i32 0, i32 2
  %8 = load i8, ptr %FontDataOwnedByAtlas, align 4
  %tobool3 = trunc i8 %8 to i1
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %9 = load ptr, ptr %font_cfg, align 8
  %FontData4 = getelementptr inbounds %struct.ImFontConfig, ptr %9, i32 0, i32 0
  %10 = load ptr, ptr %FontData4, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %10)
  %11 = load ptr, ptr %font_cfg, align 8
  %FontData5 = getelementptr inbounds %struct.ImFontConfig, ptr %11, i32 0, i32 0
  store ptr null, ptr %FontData5, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %12 = load ptr, ptr %__begin1, align 8
  %incdec.ptr = getelementptr inbounds %struct.ImFontConfig, ptr %12, i32 1
  store ptr %incdec.ptr, ptr %__begin1, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %Fonts = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 17
  store ptr %Fonts, ptr %__range16, align 8
  %13 = load ptr, ptr %__range16, align 8
  %call8 = call noundef ptr @_ZN8ImVectorIP6ImFontE5beginEv(ptr noundef nonnull align 8 dereferenceable(16) %13)
  store ptr %call8, ptr %__begin17, align 8
  %14 = load ptr, ptr %__range16, align 8
  %call10 = call noundef ptr @_ZN8ImVectorIP6ImFontE3endEv(ptr noundef nonnull align 8 dereferenceable(16) %14)
  store ptr %call10, ptr %__end19, align 8
  br label %for.cond11

for.cond11:                                       ; preds = %for.inc26, %for.end
  %15 = load ptr, ptr %__begin17, align 8
  %16 = load ptr, ptr %__end19, align 8
  %cmp12 = icmp ne ptr %15, %16
  br i1 %cmp12, label %for.body13, label %for.end28

for.body13:                                       ; preds = %for.cond11
  %17 = load ptr, ptr %__begin17, align 8
  %18 = load ptr, ptr %17, align 8
  store ptr %18, ptr %font, align 8
  %19 = load ptr, ptr %font, align 8
  %ConfigData14 = getelementptr inbounds %struct.ImFont, ptr %19, i32 0, i32 7
  %20 = load ptr, ptr %ConfigData14, align 8
  %ConfigData15 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 19
  %Data = getelementptr inbounds %struct.ImVector.11, ptr %ConfigData15, i32 0, i32 2
  %21 = load ptr, ptr %Data, align 8
  %cmp16 = icmp uge ptr %20, %21
  br i1 %cmp16, label %land.lhs.true17, label %if.end25

land.lhs.true17:                                  ; preds = %for.body13
  %22 = load ptr, ptr %font, align 8
  %ConfigData18 = getelementptr inbounds %struct.ImFont, ptr %22, i32 0, i32 7
  %23 = load ptr, ptr %ConfigData18, align 8
  %ConfigData19 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 19
  %Data20 = getelementptr inbounds %struct.ImVector.11, ptr %ConfigData19, i32 0, i32 2
  %24 = load ptr, ptr %Data20, align 8
  %ConfigData21 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 19
  %Size = getelementptr inbounds %struct.ImVector.11, ptr %ConfigData21, i32 0, i32 0
  %25 = load i32, ptr %Size, align 8
  %idx.ext = sext i32 %25 to i64
  %add.ptr = getelementptr inbounds %struct.ImFontConfig, ptr %24, i64 %idx.ext
  %cmp22 = icmp ult ptr %23, %add.ptr
  br i1 %cmp22, label %if.then23, label %if.end25

if.then23:                                        ; preds = %land.lhs.true17
  %26 = load ptr, ptr %font, align 8
  %ConfigData24 = getelementptr inbounds %struct.ImFont, ptr %26, i32 0, i32 7
  store ptr null, ptr %ConfigData24, align 8
  %27 = load ptr, ptr %font, align 8
  %ConfigDataCount = getelementptr inbounds %struct.ImFont, ptr %27, i32 0, i32 8
  store i16 0, ptr %ConfigDataCount, align 8
  br label %if.end25

if.end25:                                         ; preds = %if.then23, %land.lhs.true17, %for.body13
  br label %for.inc26

for.inc26:                                        ; preds = %if.end25
  %28 = load ptr, ptr %__begin17, align 8
  %incdec.ptr27 = getelementptr inbounds ptr, ptr %28, i32 1
  store ptr %incdec.ptr27, ptr %__begin17, align 8
  br label %for.cond11

for.end28:                                        ; preds = %for.cond11
  %ConfigData29 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 19
  call void @_ZN8ImVectorI12ImFontConfigE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %ConfigData29)
  %CustomRects = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 18
  call void @_ZN8ImVectorI21ImFontAtlasCustomRectE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %CustomRects)
  %PackIdLines = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 24
  store i32 -1, ptr %PackIdLines, align 8
  %PackIdMouseCursors = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 23
  store i32 -1, ptr %PackIdMouseCursors, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZN8ImVectorI12ImFontConfigE5beginEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZN8ImVectorI12ImFontConfigE3endEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %Size = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr inbounds %struct.ImFontConfig, ptr %0, i64 %idx.ext
  ret ptr %add.ptr
}

declare void @_ZN5ImGui7MemFreeEPv(ptr noundef) #1

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZN8ImVectorIP6ImFontE5beginEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZN8ImVectorIP6ImFontE3endEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %Size = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr inbounds ptr, ptr %0, i64 %idx.ext
  ret ptr %add.ptr
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI12ImFontConfigE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Capacity = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data2 = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
  %Data3 = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI21ImFontAtlasCustomRectE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Capacity = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data2 = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
  %Data3 = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN11ImFontAtlas12ClearTexDataEv(ptr noundef nonnull align 8 dereferenceable(1180) %this) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %TexPixelsAlpha8 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 11
  %0 = load ptr, ptr %TexPixelsAlpha8, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %TexPixelsAlpha82 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 11
  %1 = load ptr, ptr %TexPixelsAlpha82, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %TexPixelsRGBA32 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 12
  %2 = load ptr, ptr %TexPixelsRGBA32, align 8
  %tobool3 = icmp ne ptr %2, null
  br i1 %tobool3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %TexPixelsRGBA325 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 12
  %3 = load ptr, ptr %TexPixelsRGBA325, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %3)
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.end
  %TexPixelsAlpha87 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 11
  store ptr null, ptr %TexPixelsAlpha87, align 8
  %TexPixelsRGBA328 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 12
  store ptr null, ptr %TexPixelsRGBA328, align 8
  %TexPixelsUseColors = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 9
  store i8 0, ptr %TexPixelsUseColors, align 1
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN11ImFontAtlas10ClearFontsEv(ptr noundef nonnull align 8 dereferenceable(1180) %this) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Fonts = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 17
  call void @_ZN8ImVectorIP6ImFontE12clear_deleteEv(ptr noundef nonnull align 8 dereferenceable(16) %Fonts)
  %TexReady = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 8
  store i8 0, ptr %TexReady, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorIP6ImFontE12clear_deleteEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store i32 0, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %n, align 4
  %Size = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %Data = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 2
  %2 = load ptr, ptr %Data, align 8
  %3 = load i32, ptr %n, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %2, i64 %idxprom
  %4 = load ptr, ptr %arrayidx, align 8
  call void @_Z9IM_DELETEI6ImFontEvPT_(ptr noundef %4)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, ptr %n, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, ptr %n, align 4
  br label %for.cond, !llvm.loop !40

for.end:                                          ; preds = %for.cond
  call void @_ZN8ImVectorIP6ImFontE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN11ImFontAtlas18GetTexDataAsAlpha8EPPhPiS2_S2_(ptr noundef nonnull align 8 dereferenceable(1180) %this, ptr noundef %out_pixels, ptr noundef %out_width, ptr noundef %out_height, ptr noundef %out_bytes_per_pixel) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %out_pixels.addr = alloca ptr, align 8
  %out_width.addr = alloca ptr, align 8
  %out_height.addr = alloca ptr, align 8
  %out_bytes_per_pixel.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %out_pixels, ptr %out_pixels.addr, align 8
  store ptr %out_width, ptr %out_width.addr, align 8
  store ptr %out_height, ptr %out_height.addr, align 8
  store ptr %out_bytes_per_pixel, ptr %out_bytes_per_pixel.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %TexPixelsAlpha8 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 11
  %0 = load ptr, ptr %TexPixelsAlpha8, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call noundef zeroext i1 @_ZN11ImFontAtlas5BuildEv(ptr noundef nonnull align 8 dereferenceable(1180) %this1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %TexPixelsAlpha82 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 11
  %1 = load ptr, ptr %TexPixelsAlpha82, align 8
  %2 = load ptr, ptr %out_pixels.addr, align 8
  store ptr %1, ptr %2, align 8
  %3 = load ptr, ptr %out_width.addr, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %TexWidth = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 13
  %4 = load i32, ptr %TexWidth, align 8
  %5 = load ptr, ptr %out_width.addr, align 8
  store i32 %4, ptr %5, align 4
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %6 = load ptr, ptr %out_height.addr, align 8
  %tobool5 = icmp ne ptr %6, null
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  %TexHeight = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 14
  %7 = load i32, ptr %TexHeight, align 4
  %8 = load ptr, ptr %out_height.addr, align 8
  store i32 %7, ptr %8, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end4
  %9 = load ptr, ptr %out_bytes_per_pixel.addr, align 8
  %tobool8 = icmp ne ptr %9, null
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end7
  %10 = load ptr, ptr %out_bytes_per_pixel.addr, align 8
  store i32 1, ptr %10, align 4
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.end7
  ret void
}

; Function Attrs: mustprogress uwtable
define noundef zeroext i1 @_ZN11ImFontAtlas5BuildEv(ptr noundef nonnull align 8 dereferenceable(1180) %this) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %builder_io = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %ConfigData = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 19
  %Size = getelementptr inbounds %struct.ImVector.11, ptr %ConfigData, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call noundef ptr @_ZN11ImFontAtlas14AddFontDefaultEPK12ImFontConfig(ptr noundef nonnull align 8 dereferenceable(1180) %this1, ptr noundef null)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %FontBuilderIO = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 21
  %1 = load ptr, ptr %FontBuilderIO, align 8
  store ptr %1, ptr %builder_io, align 8
  %2 = load ptr, ptr %builder_io, align 8
  %cmp2 = icmp eq ptr %2, null
  br i1 %cmp2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %call4 = call noundef ptr @_Z35ImFontAtlasGetBuilderForStbTruetypev()
  store ptr %call4, ptr %builder_io, align 8
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %3 = load ptr, ptr %builder_io, align 8
  %FontBuilder_Build = getelementptr inbounds %struct.ImFontBuilderIO, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %FontBuilder_Build, align 8
  %call6 = call noundef zeroext i1 %4(ptr noundef %this1)
  ret i1 %call6
}

; Function Attrs: mustprogress uwtable
define void @_ZN11ImFontAtlas18GetTexDataAsRGBA32EPPhPiS2_S2_(ptr noundef nonnull align 8 dereferenceable(1180) %this, ptr noundef %out_pixels, ptr noundef %out_width, ptr noundef %out_height, ptr noundef %out_bytes_per_pixel) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %out_pixels.addr = alloca ptr, align 8
  %out_width.addr = alloca ptr, align 8
  %out_height.addr = alloca ptr, align 8
  %out_bytes_per_pixel.addr = alloca ptr, align 8
  %pixels = alloca ptr, align 8
  %src = alloca ptr, align 8
  %dst = alloca ptr, align 8
  %n = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %out_pixels, ptr %out_pixels.addr, align 8
  store ptr %out_width, ptr %out_width.addr, align 8
  store ptr %out_height, ptr %out_height.addr, align 8
  store ptr %out_bytes_per_pixel, ptr %out_bytes_per_pixel.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %TexPixelsRGBA32 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 12
  %0 = load ptr, ptr %TexPixelsRGBA32, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end15, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %pixels, align 8
  call void @_ZN11ImFontAtlas18GetTexDataAsAlpha8EPPhPiS2_S2_(ptr noundef nonnull align 8 dereferenceable(1180) %this1, ptr noundef %pixels, ptr noundef null, ptr noundef null, ptr noundef null)
  %1 = load ptr, ptr %pixels, align 8
  %tobool2 = icmp ne ptr %1, null
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %TexWidth = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 13
  %2 = load i32, ptr %TexWidth, align 8
  %conv = sext i32 %2 to i64
  %TexHeight = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 14
  %3 = load i32, ptr %TexHeight, align 4
  %conv4 = sext i32 %3 to i64
  %mul = mul i64 %conv, %conv4
  %mul5 = mul i64 %mul, 4
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul5)
  %TexPixelsRGBA326 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 12
  store ptr %call, ptr %TexPixelsRGBA326, align 8
  %4 = load ptr, ptr %pixels, align 8
  store ptr %4, ptr %src, align 8
  %TexPixelsRGBA327 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 12
  %5 = load ptr, ptr %TexPixelsRGBA327, align 8
  store ptr %5, ptr %dst, align 8
  %TexWidth8 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 13
  %6 = load i32, ptr %TexWidth8, align 8
  %TexHeight9 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 14
  %7 = load i32, ptr %TexHeight9, align 4
  %mul10 = mul nsw i32 %6, %7
  store i32 %mul10, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then3
  %8 = load i32, ptr %n, align 4
  %cmp = icmp sgt i32 %8, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr %src, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %9, i32 1
  store ptr %incdec.ptr, ptr %src, align 8
  %10 = load i8, ptr %9, align 1
  %conv11 = zext i8 %10 to i32
  %shl = shl i32 %conv11, 24
  %or = or i32 %shl, 16711680
  %or12 = or i32 %or, 65280
  %or13 = or i32 %or12, 255
  %11 = load ptr, ptr %dst, align 8
  %incdec.ptr14 = getelementptr inbounds i32, ptr %11, i32 1
  store ptr %incdec.ptr14, ptr %dst, align 8
  store i32 %or13, ptr %11, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, ptr %n, align 4
  %dec = add nsw i32 %12, -1
  store i32 %dec, ptr %n, align 4
  br label %for.cond, !llvm.loop !41

for.end:                                          ; preds = %for.cond
  br label %if.end

if.end:                                           ; preds = %for.end, %if.then
  br label %if.end15

if.end15:                                         ; preds = %if.end, %entry
  %TexPixelsRGBA3216 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 12
  %13 = load ptr, ptr %TexPixelsRGBA3216, align 8
  %14 = load ptr, ptr %out_pixels.addr, align 8
  store ptr %13, ptr %14, align 8
  %15 = load ptr, ptr %out_width.addr, align 8
  %tobool17 = icmp ne ptr %15, null
  br i1 %tobool17, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.end15
  %TexWidth19 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 13
  %16 = load i32, ptr %TexWidth19, align 8
  %17 = load ptr, ptr %out_width.addr, align 8
  store i32 %16, ptr %17, align 4
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %if.end15
  %18 = load ptr, ptr %out_height.addr, align 8
  %tobool21 = icmp ne ptr %18, null
  br i1 %tobool21, label %if.then22, label %if.end24

if.then22:                                        ; preds = %if.end20
  %TexHeight23 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 14
  %19 = load i32, ptr %TexHeight23, align 4
  %20 = load ptr, ptr %out_height.addr, align 8
  store i32 %19, ptr %20, align 4
  br label %if.end24

if.end24:                                         ; preds = %if.then22, %if.end20
  %21 = load ptr, ptr %out_bytes_per_pixel.addr, align 8
  %tobool25 = icmp ne ptr %21, null
  br i1 %tobool25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %if.end24
  %22 = load ptr, ptr %out_bytes_per_pixel.addr, align 8
  store i32 4, ptr %22, align 4
  br label %if.end27

if.end27:                                         ; preds = %if.then26, %if.end24
  ret void
}

; Function Attrs: mustprogress uwtable
define noundef ptr @_ZN11ImFontAtlas7AddFontEPK12ImFontConfig(ptr noundef nonnull align 8 dereferenceable(1180) %this, ptr noundef %font_cfg) #4 align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %font_cfg.addr = alloca ptr, align 8
  %ref.tmp = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %new_font_cfg = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %font_cfg, ptr %font_cfg.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %font_cfg.addr, align 8
  %MergeMode = getelementptr inbounds %struct.ImFontConfig, ptr %0, i32 0, i32 13
  %1 = load i8, ptr %MergeMode, align 8
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %Fonts = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 17
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef 120)
  %call2 = call noundef ptr @_Znwm12ImNewWrapperPv(i64 noundef 120, ptr noundef %call)
  invoke void @_ZN6ImFontC1Ev(ptr noundef nonnull align 8 dereferenceable(118) %call2)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %if.then
  store ptr %call2, ptr %ref.tmp, align 8
  call void @_ZN8ImVectorIP6ImFontE9push_backERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %Fonts, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp)
  br label %if.end

lpad:                                             ; preds = %if.then
  %2 = landingpad { ptr, i32 }
          cleanup
  %3 = extractvalue { ptr, i32 } %2, 0
  store ptr %3, ptr %exn.slot, align 8
  %4 = extractvalue { ptr, i32 } %2, 1
  store i32 %4, ptr %ehselector.slot, align 4
  call void @_ZdlPv12ImNewWrapperS_(ptr noundef %call2, ptr noundef %call) #12
  br label %eh.resume

if.else:                                          ; preds = %entry
  br label %if.end

if.end:                                           ; preds = %if.else, %invoke.cont
  %ConfigData = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 19
  %5 = load ptr, ptr %font_cfg.addr, align 8
  call void @_ZN8ImVectorI12ImFontConfigE9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %ConfigData, ptr noundef nonnull align 8 dereferenceable(144) %5)
  %ConfigData3 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 19
  %call4 = call noundef nonnull align 8 dereferenceable(144) ptr @_ZN8ImVectorI12ImFontConfigE4backEv(ptr noundef nonnull align 8 dereferenceable(16) %ConfigData3)
  store ptr %call4, ptr %new_font_cfg, align 8
  %6 = load ptr, ptr %new_font_cfg, align 8
  %DstFont = getelementptr inbounds %struct.ImFontConfig, ptr %6, i32 0, i32 19
  %7 = load ptr, ptr %DstFont, align 8
  %cmp = icmp eq ptr %7, null
  br i1 %cmp, label %if.then5, label %if.end9

if.then5:                                         ; preds = %if.end
  %Fonts6 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 17
  %call7 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN8ImVectorIP6ImFontE4backEv(ptr noundef nonnull align 8 dereferenceable(16) %Fonts6)
  %8 = load ptr, ptr %call7, align 8
  %9 = load ptr, ptr %new_font_cfg, align 8
  %DstFont8 = getelementptr inbounds %struct.ImFontConfig, ptr %9, i32 0, i32 19
  store ptr %8, ptr %DstFont8, align 8
  br label %if.end9

if.end9:                                          ; preds = %if.then5, %if.end
  %10 = load ptr, ptr %new_font_cfg, align 8
  %FontDataOwnedByAtlas = getelementptr inbounds %struct.ImFontConfig, ptr %10, i32 0, i32 2
  %11 = load i8, ptr %FontDataOwnedByAtlas, align 4
  %tobool10 = trunc i8 %11 to i1
  br i1 %tobool10, label %if.end18, label %if.then11

if.then11:                                        ; preds = %if.end9
  %12 = load ptr, ptr %new_font_cfg, align 8
  %FontDataSize = getelementptr inbounds %struct.ImFontConfig, ptr %12, i32 0, i32 1
  %13 = load i32, ptr %FontDataSize, align 8
  %conv = sext i32 %13 to i64
  %call12 = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %conv)
  %14 = load ptr, ptr %new_font_cfg, align 8
  %FontData = getelementptr inbounds %struct.ImFontConfig, ptr %14, i32 0, i32 0
  store ptr %call12, ptr %FontData, align 8
  %15 = load ptr, ptr %new_font_cfg, align 8
  %FontDataOwnedByAtlas13 = getelementptr inbounds %struct.ImFontConfig, ptr %15, i32 0, i32 2
  store i8 1, ptr %FontDataOwnedByAtlas13, align 4
  %16 = load ptr, ptr %new_font_cfg, align 8
  %FontData14 = getelementptr inbounds %struct.ImFontConfig, ptr %16, i32 0, i32 0
  %17 = load ptr, ptr %FontData14, align 8
  %18 = load ptr, ptr %font_cfg.addr, align 8
  %FontData15 = getelementptr inbounds %struct.ImFontConfig, ptr %18, i32 0, i32 0
  %19 = load ptr, ptr %FontData15, align 8
  %20 = load ptr, ptr %new_font_cfg, align 8
  %FontDataSize16 = getelementptr inbounds %struct.ImFontConfig, ptr %20, i32 0, i32 1
  %21 = load i32, ptr %FontDataSize16, align 8
  %conv17 = sext i32 %21 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %17, ptr align 1 %19, i64 %conv17, i1 false)
  br label %if.end18

if.end18:                                         ; preds = %if.then11, %if.end9
  %22 = load ptr, ptr %new_font_cfg, align 8
  %DstFont19 = getelementptr inbounds %struct.ImFontConfig, ptr %22, i32 0, i32 19
  %23 = load ptr, ptr %DstFont19, align 8
  %EllipsisChar = getelementptr inbounds %struct.ImFont, ptr %23, i32 0, i32 10
  %24 = load i16, ptr %EllipsisChar, align 4
  %conv20 = zext i16 %24 to i32
  %cmp21 = icmp eq i32 %conv20, 65535
  br i1 %cmp21, label %if.then22, label %if.end26

if.then22:                                        ; preds = %if.end18
  %25 = load ptr, ptr %font_cfg.addr, align 8
  %EllipsisChar23 = getelementptr inbounds %struct.ImFontConfig, ptr %25, i32 0, i32 17
  %26 = load i16, ptr %EllipsisChar23, align 8
  %27 = load ptr, ptr %new_font_cfg, align 8
  %DstFont24 = getelementptr inbounds %struct.ImFontConfig, ptr %27, i32 0, i32 19
  %28 = load ptr, ptr %DstFont24, align 8
  %EllipsisChar25 = getelementptr inbounds %struct.ImFont, ptr %28, i32 0, i32 10
  store i16 %26, ptr %EllipsisChar25, align 4
  br label %if.end26

if.end26:                                         ; preds = %if.then22, %if.end18
  call void @_Z35ImFontAtlasUpdateConfigDataPointersP11ImFontAtlas(ptr noundef %this1)
  %TexReady = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 8
  store i8 0, ptr %TexReady, align 8
  call void @_ZN11ImFontAtlas12ClearTexDataEv(ptr noundef nonnull align 8 dereferenceable(1180) %this1)
  %29 = load ptr, ptr %new_font_cfg, align 8
  %DstFont27 = getelementptr inbounds %struct.ImFontConfig, ptr %29, i32 0, i32 19
  %30 = load ptr, ptr %DstFont27, align 8
  ret ptr %30

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val28 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val28
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorIP6ImFontE9push_backERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(8) %v) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Size2 = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 0
  %2 = load i32, ptr %Size2, align 8
  %add = add nsw i32 %2, 1
  %call = call noundef i32 @_ZNK8ImVectorIP6ImFontE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %add)
  call void @_ZN8ImVectorIP6ImFontE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %Data = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %Size3 = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 0
  %4 = load i32, ptr %Size3, align 8
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %3, i64 %idxprom
  %5 = load ptr, ptr %v.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arrayidx, ptr align 8 %5, i64 8, i1 false)
  %Size4 = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size4, align 8
  %inc = add nsw i32 %6, 1
  store i32 %inc, ptr %Size4, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI12ImFontConfigE9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(144) %v) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Size2 = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 0
  %2 = load i32, ptr %Size2, align 8
  %add = add nsw i32 %2, 1
  %call = call noundef i32 @_ZNK8ImVectorI12ImFontConfigE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %add)
  call void @_ZN8ImVectorI12ImFontConfigE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %Data = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %Size3 = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 0
  %4 = load i32, ptr %Size3, align 8
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds %struct.ImFontConfig, ptr %3, i64 %idxprom
  %5 = load ptr, ptr %v.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arrayidx, ptr align 8 %5, i64 144, i1 false)
  %Size4 = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size4, align 8
  %inc = add nsw i32 %6, 1
  store i32 %inc, ptr %Size4, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 8 dereferenceable(144) ptr @_ZN8ImVectorI12ImFontConfigE4backEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %Size = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %sub = sub nsw i32 %1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.ImFontConfig, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 8 dereferenceable(8) ptr @_ZN8ImVectorIP6ImFontE4backEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %Size = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %sub = sub nsw i32 %1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds ptr, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define void @_Z35ImFontAtlasUpdateConfigDataPointersP11ImFontAtlas(ptr noundef %atlas) #4 {
entry:
  %atlas.addr = alloca ptr, align 8
  %__range1 = alloca ptr, align 8
  %__begin1 = alloca ptr, align 8
  %__end1 = alloca ptr, align 8
  %font_cfg = alloca ptr, align 8
  %font = alloca ptr, align 8
  store ptr %atlas, ptr %atlas.addr, align 8
  %0 = load ptr, ptr %atlas.addr, align 8
  %ConfigData = getelementptr inbounds %struct.ImFontAtlas, ptr %0, i32 0, i32 19
  store ptr %ConfigData, ptr %__range1, align 8
  %1 = load ptr, ptr %__range1, align 8
  %call = call noundef ptr @_ZN8ImVectorI12ImFontConfigE5beginEv(ptr noundef nonnull align 8 dereferenceable(16) %1)
  store ptr %call, ptr %__begin1, align 8
  %2 = load ptr, ptr %__range1, align 8
  %call1 = call noundef ptr @_ZN8ImVectorI12ImFontConfigE3endEv(ptr noundef nonnull align 8 dereferenceable(16) %2)
  store ptr %call1, ptr %__end1, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load ptr, ptr %__begin1, align 8
  %4 = load ptr, ptr %__end1, align 8
  %cmp = icmp ne ptr %3, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %__begin1, align 8
  store ptr %5, ptr %font_cfg, align 8
  %6 = load ptr, ptr %font_cfg, align 8
  %DstFont = getelementptr inbounds %struct.ImFontConfig, ptr %6, i32 0, i32 19
  %7 = load ptr, ptr %DstFont, align 8
  store ptr %7, ptr %font, align 8
  %8 = load ptr, ptr %font_cfg, align 8
  %MergeMode = getelementptr inbounds %struct.ImFontConfig, ptr %8, i32 0, i32 13
  %9 = load i8, ptr %MergeMode, align 8
  %tobool = trunc i8 %9 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %10 = load ptr, ptr %font_cfg, align 8
  %11 = load ptr, ptr %font, align 8
  %ConfigData2 = getelementptr inbounds %struct.ImFont, ptr %11, i32 0, i32 7
  store ptr %10, ptr %ConfigData2, align 8
  %12 = load ptr, ptr %font, align 8
  %ConfigDataCount = getelementptr inbounds %struct.ImFont, ptr %12, i32 0, i32 8
  store i16 0, ptr %ConfigDataCount, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %13 = load ptr, ptr %font, align 8
  %ConfigDataCount3 = getelementptr inbounds %struct.ImFont, ptr %13, i32 0, i32 8
  %14 = load i16, ptr %ConfigDataCount3, align 8
  %inc = add i16 %14, 1
  store i16 %inc, ptr %ConfigDataCount3, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %15 = load ptr, ptr %__begin1, align 8
  %incdec.ptr = getelementptr inbounds %struct.ImFontConfig, ptr %15, i32 1
  store ptr %incdec.ptr, ptr %__begin1, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define noundef ptr @_ZN11ImFontAtlas14AddFontDefaultEPK12ImFontConfig(ptr noundef nonnull align 8 dereferenceable(1180) %this, ptr noundef %font_cfg_template) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %font_cfg_template.addr = alloca ptr, align 8
  %font_cfg = alloca %struct.ImFontConfig, align 8
  %ttf_compressed_base85 = alloca ptr, align 8
  %glyph_ranges = alloca ptr, align 8
  %font = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %font_cfg_template, ptr %font_cfg_template.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %font_cfg_template.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load ptr, ptr %font_cfg_template.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %font_cfg, ptr align 8 %1, i64 144, i1 false)
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @_ZN12ImFontConfigC1Ev(ptr noundef nonnull align 8 dereferenceable(144) %font_cfg)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %2 = load ptr, ptr %font_cfg_template.addr, align 8
  %tobool2 = icmp ne ptr %2, null
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  %OversampleV = getelementptr inbounds %struct.ImFontConfig, ptr %font_cfg, i32 0, i32 6
  store i32 1, ptr %OversampleV, align 4
  %OversampleH = getelementptr inbounds %struct.ImFontConfig, ptr %font_cfg, i32 0, i32 5
  store i32 1, ptr %OversampleH, align 8
  %PixelSnapH = getelementptr inbounds %struct.ImFontConfig, ptr %font_cfg, i32 0, i32 7
  store i8 1, ptr %PixelSnapH, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  %SizePixels = getelementptr inbounds %struct.ImFontConfig, ptr %font_cfg, i32 0, i32 4
  %3 = load float, ptr %SizePixels, align 4
  %cmp = fcmp ole float %3, 0.000000e+00
  br i1 %cmp, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %SizePixels4 = getelementptr inbounds %struct.ImFontConfig, ptr %font_cfg, i32 0, i32 4
  store float 1.300000e+01, ptr %SizePixels4, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %Name = getelementptr inbounds %struct.ImFontConfig, ptr %font_cfg, i32 0, i32 18
  %arrayidx = getelementptr inbounds [40 x i8], ptr %Name, i64 0, i64 0
  %4 = load i8, ptr %arrayidx, align 2
  %conv = sext i8 %4 to i32
  %cmp6 = icmp eq i32 %conv, 0
  br i1 %cmp6, label %if.then7, label %if.end11

if.then7:                                         ; preds = %if.end5
  %Name8 = getelementptr inbounds %struct.ImFontConfig, ptr %font_cfg, i32 0, i32 18
  %arraydecay = getelementptr inbounds [40 x i8], ptr %Name8, i64 0, i64 0
  %SizePixels9 = getelementptr inbounds %struct.ImFontConfig, ptr %font_cfg, i32 0, i32 4
  %5 = load float, ptr %SizePixels9, align 4
  %conv10 = fptosi float %5 to i32
  %call = call noundef i32 (ptr, i64, ptr, ...) @_Z14ImFormatStringPcmPKcz(ptr noundef %arraydecay, i64 noundef 40, ptr noundef @.str, i32 noundef %conv10)
  br label %if.end11

if.end11:                                         ; preds = %if.then7, %if.end5
  %EllipsisChar = getelementptr inbounds %struct.ImFontConfig, ptr %font_cfg, i32 0, i32 17
  store i16 133, ptr %EllipsisChar, align 8
  %SizePixels12 = getelementptr inbounds %struct.ImFontConfig, ptr %font_cfg, i32 0, i32 4
  %6 = load float, ptr %SizePixels12, align 4
  %div = fdiv float %6, 1.300000e+01
  %conv13 = fptosi float %div to i32
  %conv14 = sitofp i32 %conv13 to float
  %mul = fmul float 1.000000e+00, %conv14
  %GlyphOffset = getelementptr inbounds %struct.ImFontConfig, ptr %font_cfg, i32 0, i32 9
  %y = getelementptr inbounds %struct.ImVec2, ptr %GlyphOffset, i32 0, i32 1
  store float %mul, ptr %y, align 4
  %call15 = call noundef ptr @_ZL37GetDefaultCompressedFontDataTTFBase85v()
  store ptr %call15, ptr %ttf_compressed_base85, align 8
  %GlyphRanges = getelementptr inbounds %struct.ImFontConfig, ptr %font_cfg, i32 0, i32 10
  %7 = load ptr, ptr %GlyphRanges, align 8
  %cmp16 = icmp ne ptr %7, null
  br i1 %cmp16, label %cond.true17, label %cond.false19

cond.true17:                                      ; preds = %if.end11
  %GlyphRanges18 = getelementptr inbounds %struct.ImFontConfig, ptr %font_cfg, i32 0, i32 10
  %8 = load ptr, ptr %GlyphRanges18, align 8
  br label %cond.end21

cond.false19:                                     ; preds = %if.end11
  %call20 = call noundef ptr @_ZN11ImFontAtlas21GetGlyphRangesDefaultEv(ptr noundef nonnull align 8 dereferenceable(1180) %this1)
  br label %cond.end21

cond.end21:                                       ; preds = %cond.false19, %cond.true17
  %cond = phi ptr [ %8, %cond.true17 ], [ %call20, %cond.false19 ]
  store ptr %cond, ptr %glyph_ranges, align 8
  %9 = load ptr, ptr %ttf_compressed_base85, align 8
  %SizePixels22 = getelementptr inbounds %struct.ImFontConfig, ptr %font_cfg, i32 0, i32 4
  %10 = load float, ptr %SizePixels22, align 4
  %11 = load ptr, ptr %glyph_ranges, align 8
  %call23 = call noundef ptr @_ZN11ImFontAtlas36AddFontFromMemoryCompressedBase85TTFEPKcfPK12ImFontConfigPKt(ptr noundef nonnull align 8 dereferenceable(1180) %this1, ptr noundef %9, float noundef %10, ptr noundef %font_cfg, ptr noundef %11)
  store ptr %call23, ptr %font, align 8
  %12 = load ptr, ptr %font, align 8
  ret ptr %12
}

declare noundef i32 @_Z14ImFormatStringPcmPKcz(ptr noundef, i64 noundef, ptr noundef, ...) #1

; Function Attrs: mustprogress nounwind uwtable
define internal noundef ptr @_ZL37GetDefaultCompressedFontDataTTFBase85v() #2 {
entry:
  ret ptr @_ZL39proggy_clean_ttf_compressed_data_base85
}

; Function Attrs: mustprogress nounwind uwtable
define noundef ptr @_ZN11ImFontAtlas21GetGlyphRangesDefaultEv(ptr noundef nonnull align 8 dereferenceable(1180) %this) #2 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret ptr @_ZZN11ImFontAtlas21GetGlyphRangesDefaultEvE6ranges
}

; Function Attrs: mustprogress uwtable
define noundef ptr @_ZN11ImFontAtlas36AddFontFromMemoryCompressedBase85TTFEPKcfPK12ImFontConfigPKt(ptr noundef nonnull align 8 dereferenceable(1180) %this, ptr noundef %compressed_ttf_data_base85, float noundef %size_pixels, ptr noundef %font_cfg, ptr noundef %glyph_ranges) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %compressed_ttf_data_base85.addr = alloca ptr, align 8
  %size_pixels.addr = alloca float, align 4
  %font_cfg.addr = alloca ptr, align 8
  %glyph_ranges.addr = alloca ptr, align 8
  %compressed_ttf_size = alloca i32, align 4
  %compressed_ttf = alloca ptr, align 8
  %font = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %compressed_ttf_data_base85, ptr %compressed_ttf_data_base85.addr, align 8
  store float %size_pixels, ptr %size_pixels.addr, align 4
  store ptr %font_cfg, ptr %font_cfg.addr, align 8
  store ptr %glyph_ranges, ptr %glyph_ranges.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %compressed_ttf_data_base85.addr, align 8
  %call = call i64 @strlen(ptr noundef %0) #14
  %conv = trunc i64 %call to i32
  %add = add nsw i32 %conv, 4
  %div = sdiv i32 %add, 5
  %mul = mul nsw i32 %div, 4
  store i32 %mul, ptr %compressed_ttf_size, align 4
  %1 = load i32, ptr %compressed_ttf_size, align 4
  %conv2 = sext i32 %1 to i64
  %call3 = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %conv2)
  store ptr %call3, ptr %compressed_ttf, align 8
  %2 = load ptr, ptr %compressed_ttf_data_base85.addr, align 8
  %3 = load ptr, ptr %compressed_ttf, align 8
  call void @_ZL8Decode85PKhPh(ptr noundef %2, ptr noundef %3)
  %4 = load ptr, ptr %compressed_ttf, align 8
  %5 = load i32, ptr %compressed_ttf_size, align 4
  %6 = load float, ptr %size_pixels.addr, align 4
  %7 = load ptr, ptr %font_cfg.addr, align 8
  %8 = load ptr, ptr %glyph_ranges.addr, align 8
  %call4 = call noundef ptr @_ZN11ImFontAtlas30AddFontFromMemoryCompressedTTFEPKvifPK12ImFontConfigPKt(ptr noundef nonnull align 8 dereferenceable(1180) %this1, ptr noundef %4, i32 noundef %5, float noundef %6, ptr noundef %7, ptr noundef %8)
  store ptr %call4, ptr %font, align 8
  %9 = load ptr, ptr %compressed_ttf, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %9)
  %10 = load ptr, ptr %font, align 8
  ret ptr %10
}

; Function Attrs: mustprogress uwtable
define noundef ptr @_ZN11ImFontAtlas18AddFontFromFileTTFEPKcfPK12ImFontConfigPKt(ptr noundef nonnull align 8 dereferenceable(1180) %this, ptr noundef %filename, float noundef %size_pixels, ptr noundef %font_cfg_template, ptr noundef %glyph_ranges) #4 align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %filename.addr = alloca ptr, align 8
  %size_pixels.addr = alloca float, align 4
  %font_cfg_template.addr = alloca ptr, align 8
  %glyph_ranges.addr = alloca ptr, align 8
  %data_size = alloca i64, align 8
  %data = alloca ptr, align 8
  %font_cfg = alloca %struct.ImFontConfig, align 8
  %p = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  store float %size_pixels, ptr %size_pixels.addr, align 4
  store ptr %font_cfg_template, ptr %font_cfg_template.addr, align 8
  store ptr %glyph_ranges, ptr %glyph_ranges.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store i64 0, ptr %data_size, align 8
  %0 = load ptr, ptr %filename.addr, align 8
  %call = call noundef ptr @_Z18ImFileLoadToMemoryPKcS0_Pmi(ptr noundef %0, ptr noundef @.str.1, ptr noundef %data_size, i32 noundef 0)
  store ptr %call, ptr %data, align 8
  %1 = load ptr, ptr %data, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %font_cfg_template.addr, align 8
  %tobool2 = icmp ne ptr %2, null
  br i1 %tobool2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %3 = load ptr, ptr %font_cfg_template.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %font_cfg, ptr align 8 %3, i64 144, i1 false)
  br label %cond.end

cond.false:                                       ; preds = %if.end
  call void @_ZN12ImFontConfigC1Ev(ptr noundef nonnull align 8 dereferenceable(144) %font_cfg)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %Name = getelementptr inbounds %struct.ImFontConfig, ptr %font_cfg, i32 0, i32 18
  %arrayidx = getelementptr inbounds [40 x i8], ptr %Name, i64 0, i64 0
  %4 = load i8, ptr %arrayidx, align 2
  %conv = sext i8 %4 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %if.then3, label %if.end15

if.then3:                                         ; preds = %cond.end
  %5 = load ptr, ptr %filename.addr, align 8
  %6 = load ptr, ptr %filename.addr, align 8
  %call4 = call i64 @strlen(ptr noundef %6) #14
  %add.ptr = getelementptr inbounds i8, ptr %5, i64 %call4
  store ptr %add.ptr, ptr %p, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then3
  %7 = load ptr, ptr %p, align 8
  %8 = load ptr, ptr %filename.addr, align 8
  %cmp5 = icmp ugt ptr %7, %8
  br i1 %cmp5, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %for.cond
  %9 = load ptr, ptr %p, align 8
  %arrayidx6 = getelementptr inbounds i8, ptr %9, i64 -1
  %10 = load i8, ptr %arrayidx6, align 1
  %conv7 = sext i8 %10 to i32
  %cmp8 = icmp ne i32 %conv7, 47
  br i1 %cmp8, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %11 = load ptr, ptr %p, align 8
  %arrayidx9 = getelementptr inbounds i8, ptr %11, i64 -1
  %12 = load i8, ptr %arrayidx9, align 1
  %conv10 = sext i8 %12 to i32
  %cmp11 = icmp ne i32 %conv10, 92
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %for.cond
  %13 = phi i1 [ false, %land.lhs.true ], [ false, %for.cond ], [ %cmp11, %land.rhs ]
  br i1 %13, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %14 = load ptr, ptr %p, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %14, i32 -1
  store ptr %incdec.ptr, ptr %p, align 8
  br label %for.cond, !llvm.loop !42

for.end:                                          ; preds = %land.end
  %Name12 = getelementptr inbounds %struct.ImFontConfig, ptr %font_cfg, i32 0, i32 18
  %arraydecay = getelementptr inbounds [40 x i8], ptr %Name12, i64 0, i64 0
  %15 = load ptr, ptr %p, align 8
  %16 = load float, ptr %size_pixels.addr, align 4
  %conv13 = fpext float %16 to double
  %call14 = call noundef i32 (ptr, i64, ptr, ...) @_Z14ImFormatStringPcmPKcz(ptr noundef %arraydecay, i64 noundef 40, ptr noundef @.str.2, ptr noundef %15, double noundef %conv13)
  br label %if.end15

if.end15:                                         ; preds = %for.end, %cond.end
  %17 = load ptr, ptr %data, align 8
  %18 = load i64, ptr %data_size, align 8
  %conv16 = trunc i64 %18 to i32
  %19 = load float, ptr %size_pixels.addr, align 4
  %20 = load ptr, ptr %glyph_ranges.addr, align 8
  %call17 = call noundef ptr @_ZN11ImFontAtlas20AddFontFromMemoryTTFEPvifPK12ImFontConfigPKt(ptr noundef nonnull align 8 dereferenceable(1180) %this1, ptr noundef %17, i32 noundef %conv16, float noundef %19, ptr noundef %font_cfg, ptr noundef %20)
  store ptr %call17, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end15, %if.then
  %21 = load ptr, ptr %retval, align 8
  ret ptr %21
}

declare noundef ptr @_Z18ImFileLoadToMemoryPKcS0_Pmi(ptr noundef, ptr noundef, ptr noundef, i32 noundef) #1

; Function Attrs: mustprogress uwtable
define noundef ptr @_ZN11ImFontAtlas20AddFontFromMemoryTTFEPvifPK12ImFontConfigPKt(ptr noundef nonnull align 8 dereferenceable(1180) %this, ptr noundef %font_data, i32 noundef %font_data_size, float noundef %size_pixels, ptr noundef %font_cfg_template, ptr noundef %glyph_ranges) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %font_data.addr = alloca ptr, align 8
  %font_data_size.addr = alloca i32, align 4
  %size_pixels.addr = alloca float, align 4
  %font_cfg_template.addr = alloca ptr, align 8
  %glyph_ranges.addr = alloca ptr, align 8
  %font_cfg = alloca %struct.ImFontConfig, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %font_data, ptr %font_data.addr, align 8
  store i32 %font_data_size, ptr %font_data_size.addr, align 4
  store float %size_pixels, ptr %size_pixels.addr, align 4
  store ptr %font_cfg_template, ptr %font_cfg_template.addr, align 8
  store ptr %glyph_ranges, ptr %glyph_ranges.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %font_cfg_template.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load ptr, ptr %font_cfg_template.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %font_cfg, ptr align 8 %1, i64 144, i1 false)
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @_ZN12ImFontConfigC1Ev(ptr noundef nonnull align 8 dereferenceable(144) %font_cfg)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %2 = load ptr, ptr %font_data.addr, align 8
  %FontData = getelementptr inbounds %struct.ImFontConfig, ptr %font_cfg, i32 0, i32 0
  store ptr %2, ptr %FontData, align 8
  %3 = load i32, ptr %font_data_size.addr, align 4
  %FontDataSize = getelementptr inbounds %struct.ImFontConfig, ptr %font_cfg, i32 0, i32 1
  store i32 %3, ptr %FontDataSize, align 8
  %4 = load float, ptr %size_pixels.addr, align 4
  %cmp = fcmp ogt float %4, 0.000000e+00
  br i1 %cmp, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.end
  %5 = load float, ptr %size_pixels.addr, align 4
  br label %cond.end4

cond.false3:                                      ; preds = %cond.end
  %SizePixels = getelementptr inbounds %struct.ImFontConfig, ptr %font_cfg, i32 0, i32 4
  %6 = load float, ptr %SizePixels, align 4
  br label %cond.end4

cond.end4:                                        ; preds = %cond.false3, %cond.true2
  %cond = phi float [ %5, %cond.true2 ], [ %6, %cond.false3 ]
  %SizePixels5 = getelementptr inbounds %struct.ImFontConfig, ptr %font_cfg, i32 0, i32 4
  store float %cond, ptr %SizePixels5, align 4
  %7 = load ptr, ptr %glyph_ranges.addr, align 8
  %tobool6 = icmp ne ptr %7, null
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end4
  %8 = load ptr, ptr %glyph_ranges.addr, align 8
  %GlyphRanges = getelementptr inbounds %struct.ImFontConfig, ptr %font_cfg, i32 0, i32 10
  store ptr %8, ptr %GlyphRanges, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end4
  %call = call noundef ptr @_ZN11ImFontAtlas7AddFontEPK12ImFontConfig(ptr noundef nonnull align 8 dereferenceable(1180) %this1, ptr noundef %font_cfg)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define noundef ptr @_ZN11ImFontAtlas30AddFontFromMemoryCompressedTTFEPKvifPK12ImFontConfigPKt(ptr noundef nonnull align 8 dereferenceable(1180) %this, ptr noundef %compressed_ttf_data, i32 noundef %compressed_ttf_size, float noundef %size_pixels, ptr noundef %font_cfg_template, ptr noundef %glyph_ranges) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %compressed_ttf_data.addr = alloca ptr, align 8
  %compressed_ttf_size.addr = alloca i32, align 4
  %size_pixels.addr = alloca float, align 4
  %font_cfg_template.addr = alloca ptr, align 8
  %glyph_ranges.addr = alloca ptr, align 8
  %buf_decompressed_size = alloca i32, align 4
  %buf_decompressed_data = alloca ptr, align 8
  %font_cfg = alloca %struct.ImFontConfig, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %compressed_ttf_data, ptr %compressed_ttf_data.addr, align 8
  store i32 %compressed_ttf_size, ptr %compressed_ttf_size.addr, align 4
  store float %size_pixels, ptr %size_pixels.addr, align 4
  store ptr %font_cfg_template, ptr %font_cfg_template.addr, align 8
  store ptr %glyph_ranges, ptr %glyph_ranges.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %compressed_ttf_data.addr, align 8
  %call = call noundef i32 @_ZL21stb_decompress_lengthPKh(ptr noundef %0)
  store i32 %call, ptr %buf_decompressed_size, align 4
  %1 = load i32, ptr %buf_decompressed_size, align 4
  %conv = zext i32 %1 to i64
  %call2 = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %conv)
  store ptr %call2, ptr %buf_decompressed_data, align 8
  %2 = load ptr, ptr %buf_decompressed_data, align 8
  %3 = load ptr, ptr %compressed_ttf_data.addr, align 8
  %4 = load i32, ptr %compressed_ttf_size.addr, align 4
  %call3 = call noundef i32 @_ZL14stb_decompressPhPKhj(ptr noundef %2, ptr noundef %3, i32 noundef %4)
  %5 = load ptr, ptr %font_cfg_template.addr, align 8
  %tobool = icmp ne ptr %5, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %6 = load ptr, ptr %font_cfg_template.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %font_cfg, ptr align 8 %6, i64 144, i1 false)
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @_ZN12ImFontConfigC1Ev(ptr noundef nonnull align 8 dereferenceable(144) %font_cfg)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %FontDataOwnedByAtlas = getelementptr inbounds %struct.ImFontConfig, ptr %font_cfg, i32 0, i32 2
  store i8 1, ptr %FontDataOwnedByAtlas, align 4
  %7 = load ptr, ptr %buf_decompressed_data, align 8
  %8 = load i32, ptr %buf_decompressed_size, align 4
  %9 = load float, ptr %size_pixels.addr, align 4
  %10 = load ptr, ptr %glyph_ranges.addr, align 8
  %call4 = call noundef ptr @_ZN11ImFontAtlas20AddFontFromMemoryTTFEPvifPK12ImFontConfigPKt(ptr noundef nonnull align 8 dereferenceable(1180) %this1, ptr noundef %7, i32 noundef %8, float noundef %9, ptr noundef %font_cfg, ptr noundef %10)
  ret ptr %call4
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZL21stb_decompress_lengthPKh(ptr noundef %input) #2 {
entry:
  %input.addr = alloca ptr, align 8
  store ptr %input, ptr %input.addr, align 8
  %0 = load ptr, ptr %input.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %0, i64 8
  %1 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %1 to i32
  %shl = shl i32 %conv, 24
  %2 = load ptr, ptr %input.addr, align 8
  %arrayidx1 = getelementptr inbounds i8, ptr %2, i64 9
  %3 = load i8, ptr %arrayidx1, align 1
  %conv2 = zext i8 %3 to i32
  %shl3 = shl i32 %conv2, 16
  %add = add nsw i32 %shl, %shl3
  %4 = load ptr, ptr %input.addr, align 8
  %arrayidx4 = getelementptr inbounds i8, ptr %4, i64 10
  %5 = load i8, ptr %arrayidx4, align 1
  %conv5 = zext i8 %5 to i32
  %shl6 = shl i32 %conv5, 8
  %add7 = add nsw i32 %add, %shl6
  %6 = load ptr, ptr %input.addr, align 8
  %arrayidx8 = getelementptr inbounds i8, ptr %6, i64 11
  %7 = load i8, ptr %arrayidx8, align 1
  %conv9 = zext i8 %7 to i32
  %add10 = add nsw i32 %add7, %conv9
  ret i32 %add10
}

; Function Attrs: mustprogress uwtable
define internal noundef i32 @_ZL14stb_decompressPhPKhj(ptr noundef %output, ptr noundef %i, i32 noundef %0) #4 {
entry:
  %retval = alloca i32, align 4
  %output.addr = alloca ptr, align 8
  %i.addr = alloca ptr, align 8
  %.addr = alloca i32, align 4
  %olen = alloca i32, align 4
  %old_i = alloca ptr, align 8
  store ptr %output, ptr %output.addr, align 8
  store ptr %i, ptr %i.addr, align 8
  store i32 %0, ptr %.addr, align 4
  %1 = load ptr, ptr %i.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %1, i64 0
  %2 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %2 to i32
  %shl = shl i32 %conv, 24
  %3 = load ptr, ptr %i.addr, align 8
  %arrayidx1 = getelementptr inbounds i8, ptr %3, i64 1
  %4 = load i8, ptr %arrayidx1, align 1
  %conv2 = zext i8 %4 to i32
  %shl3 = shl i32 %conv2, 16
  %5 = load ptr, ptr %i.addr, align 8
  %arrayidx4 = getelementptr inbounds i8, ptr %5, i64 2
  %6 = load i8, ptr %arrayidx4, align 1
  %conv5 = zext i8 %6 to i32
  %shl6 = shl i32 %conv5, 8
  %7 = load ptr, ptr %i.addr, align 8
  %arrayidx7 = getelementptr inbounds i8, ptr %7, i64 3
  %8 = load i8, ptr %arrayidx7, align 1
  %conv8 = zext i8 %8 to i32
  %add = add nsw i32 %shl6, %conv8
  %add9 = add nsw i32 %shl3, %add
  %add10 = add nsw i32 %shl, %add9
  %cmp = icmp ne i32 %add10, 1471938560
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %9 = load ptr, ptr %i.addr, align 8
  %arrayidx11 = getelementptr inbounds i8, ptr %9, i64 4
  %10 = load i8, ptr %arrayidx11, align 1
  %conv12 = zext i8 %10 to i32
  %shl13 = shl i32 %conv12, 24
  %11 = load ptr, ptr %i.addr, align 8
  %arrayidx14 = getelementptr inbounds i8, ptr %11, i64 5
  %12 = load i8, ptr %arrayidx14, align 1
  %conv15 = zext i8 %12 to i32
  %shl16 = shl i32 %conv15, 16
  %13 = load ptr, ptr %i.addr, align 8
  %arrayidx17 = getelementptr inbounds i8, ptr %13, i64 6
  %14 = load i8, ptr %arrayidx17, align 1
  %conv18 = zext i8 %14 to i32
  %shl19 = shl i32 %conv18, 8
  %15 = load ptr, ptr %i.addr, align 8
  %arrayidx20 = getelementptr inbounds i8, ptr %15, i64 7
  %16 = load i8, ptr %arrayidx20, align 1
  %conv21 = zext i8 %16 to i32
  %add22 = add nsw i32 %shl19, %conv21
  %add23 = add nsw i32 %shl16, %add22
  %add24 = add nsw i32 %shl13, %add23
  %cmp25 = icmp ne i32 %add24, 0
  br i1 %cmp25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end27:                                         ; preds = %if.end
  %17 = load ptr, ptr %i.addr, align 8
  %call = call noundef i32 @_ZL21stb_decompress_lengthPKh(ptr noundef %17)
  store i32 %call, ptr %olen, align 4
  %18 = load ptr, ptr %i.addr, align 8
  store ptr %18, ptr @_ZL17stb__barrier_in_b, align 8
  %19 = load ptr, ptr %output.addr, align 8
  %20 = load i32, ptr %olen, align 4
  %idx.ext = zext i32 %20 to i64
  %add.ptr = getelementptr inbounds i8, ptr %19, i64 %idx.ext
  store ptr %add.ptr, ptr @_ZL18stb__barrier_out_e, align 8
  %21 = load ptr, ptr %output.addr, align 8
  store ptr %21, ptr @_ZL18stb__barrier_out_b, align 8
  %22 = load ptr, ptr %i.addr, align 8
  %add.ptr28 = getelementptr inbounds i8, ptr %22, i64 16
  store ptr %add.ptr28, ptr %i.addr, align 8
  %23 = load ptr, ptr %output.addr, align 8
  store ptr %23, ptr @_ZL9stb__dout, align 8
  br label %for.cond

for.cond:                                         ; preds = %if.end66, %if.end27
  %24 = load ptr, ptr %i.addr, align 8
  store ptr %24, ptr %old_i, align 8
  %25 = load ptr, ptr %i.addr, align 8
  %call29 = call noundef ptr @_ZL20stb_decompress_tokenPKh(ptr noundef %25)
  store ptr %call29, ptr %i.addr, align 8
  %26 = load ptr, ptr %i.addr, align 8
  %27 = load ptr, ptr %old_i, align 8
  %cmp30 = icmp eq ptr %26, %27
  br i1 %cmp30, label %if.then31, label %if.end61

if.then31:                                        ; preds = %for.cond
  %28 = load ptr, ptr %i.addr, align 8
  %29 = load i8, ptr %28, align 1
  %conv32 = zext i8 %29 to i32
  %cmp33 = icmp eq i32 %conv32, 5
  br i1 %cmp33, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then31
  %30 = load ptr, ptr %i.addr, align 8
  %arrayidx34 = getelementptr inbounds i8, ptr %30, i64 1
  %31 = load i8, ptr %arrayidx34, align 1
  %conv35 = zext i8 %31 to i32
  %cmp36 = icmp eq i32 %conv35, 250
  br i1 %cmp36, label %if.then37, label %if.else

if.then37:                                        ; preds = %land.lhs.true
  %32 = load ptr, ptr @_ZL9stb__dout, align 8
  %33 = load ptr, ptr %output.addr, align 8
  %34 = load i32, ptr %olen, align 4
  %idx.ext38 = zext i32 %34 to i64
  %add.ptr39 = getelementptr inbounds i8, ptr %33, i64 %idx.ext38
  %cmp40 = icmp ne ptr %32, %add.ptr39
  br i1 %cmp40, label %if.then41, label %if.end42

if.then41:                                        ; preds = %if.then37
  store i32 0, ptr %retval, align 4
  br label %return

if.end42:                                         ; preds = %if.then37
  %35 = load ptr, ptr %output.addr, align 8
  %36 = load i32, ptr %olen, align 4
  %call43 = call noundef i32 @_ZL11stb_adler32jPhj(i32 noundef 1, ptr noundef %35, i32 noundef %36)
  %37 = load ptr, ptr %i.addr, align 8
  %arrayidx44 = getelementptr inbounds i8, ptr %37, i64 2
  %38 = load i8, ptr %arrayidx44, align 1
  %conv45 = zext i8 %38 to i32
  %shl46 = shl i32 %conv45, 24
  %39 = load ptr, ptr %i.addr, align 8
  %arrayidx47 = getelementptr inbounds i8, ptr %39, i64 3
  %40 = load i8, ptr %arrayidx47, align 1
  %conv48 = zext i8 %40 to i32
  %shl49 = shl i32 %conv48, 16
  %41 = load ptr, ptr %i.addr, align 8
  %arrayidx50 = getelementptr inbounds i8, ptr %41, i64 4
  %42 = load i8, ptr %arrayidx50, align 1
  %conv51 = zext i8 %42 to i32
  %shl52 = shl i32 %conv51, 8
  %43 = load ptr, ptr %i.addr, align 8
  %arrayidx53 = getelementptr inbounds i8, ptr %43, i64 5
  %44 = load i8, ptr %arrayidx53, align 1
  %conv54 = zext i8 %44 to i32
  %add55 = add nsw i32 %shl52, %conv54
  %add56 = add nsw i32 %shl49, %add55
  %add57 = add nsw i32 %shl46, %add56
  %cmp58 = icmp ne i32 %call43, %add57
  br i1 %cmp58, label %if.then59, label %if.end60

if.then59:                                        ; preds = %if.end42
  store i32 0, ptr %retval, align 4
  br label %return

if.end60:                                         ; preds = %if.end42
  %45 = load i32, ptr %olen, align 4
  store i32 %45, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %land.lhs.true, %if.then31
  store i32 0, ptr %retval, align 4
  br label %return

if.end61:                                         ; preds = %for.cond
  %46 = load ptr, ptr @_ZL9stb__dout, align 8
  %47 = load ptr, ptr %output.addr, align 8
  %48 = load i32, ptr %olen, align 4
  %idx.ext62 = zext i32 %48 to i64
  %add.ptr63 = getelementptr inbounds i8, ptr %47, i64 %idx.ext62
  %cmp64 = icmp ugt ptr %46, %add.ptr63
  br i1 %cmp64, label %if.then65, label %if.end66

if.then65:                                        ; preds = %if.end61
  store i32 0, ptr %retval, align 4
  br label %return

if.end66:                                         ; preds = %if.end61
  br label %for.cond, !llvm.loop !43

return:                                           ; preds = %if.then65, %if.else, %if.end60, %if.then59, %if.then41, %if.then26, %if.then
  %49 = load i32, ptr %retval, align 4
  ret i32 %49
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL8Decode85PKhPh(ptr noundef %src, ptr noundef %dst) #4 {
entry:
  %src.addr = alloca ptr, align 8
  %dst.addr = alloca ptr, align 8
  %tmp = alloca i32, align 4
  store ptr %src, ptr %src.addr, align 8
  store ptr %dst, ptr %dst.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load ptr, ptr %src.addr, align 8
  %1 = load i8, ptr %0, align 1
  %tobool = icmp ne i8 %1, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %src.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %2, i64 0
  %3 = load i8, ptr %arrayidx, align 1
  %call = call noundef i32 @_ZL12Decode85Bytec(i8 noundef signext %3)
  %4 = load ptr, ptr %src.addr, align 8
  %arrayidx1 = getelementptr inbounds i8, ptr %4, i64 1
  %5 = load i8, ptr %arrayidx1, align 1
  %call2 = call noundef i32 @_ZL12Decode85Bytec(i8 noundef signext %5)
  %6 = load ptr, ptr %src.addr, align 8
  %arrayidx3 = getelementptr inbounds i8, ptr %6, i64 2
  %7 = load i8, ptr %arrayidx3, align 1
  %call4 = call noundef i32 @_ZL12Decode85Bytec(i8 noundef signext %7)
  %8 = load ptr, ptr %src.addr, align 8
  %arrayidx5 = getelementptr inbounds i8, ptr %8, i64 3
  %9 = load i8, ptr %arrayidx5, align 1
  %call6 = call noundef i32 @_ZL12Decode85Bytec(i8 noundef signext %9)
  %10 = load ptr, ptr %src.addr, align 8
  %arrayidx7 = getelementptr inbounds i8, ptr %10, i64 4
  %11 = load i8, ptr %arrayidx7, align 1
  %call8 = call noundef i32 @_ZL12Decode85Bytec(i8 noundef signext %11)
  %mul = mul i32 85, %call8
  %add = add i32 %call6, %mul
  %mul9 = mul i32 85, %add
  %add10 = add i32 %call4, %mul9
  %mul11 = mul i32 85, %add10
  %add12 = add i32 %call2, %mul11
  %mul13 = mul i32 85, %add12
  %add14 = add i32 %call, %mul13
  store i32 %add14, ptr %tmp, align 4
  %12 = load i32, ptr %tmp, align 4
  %shr = lshr i32 %12, 0
  %and = and i32 %shr, 255
  %conv = trunc i32 %and to i8
  %13 = load ptr, ptr %dst.addr, align 8
  %arrayidx15 = getelementptr inbounds i8, ptr %13, i64 0
  store i8 %conv, ptr %arrayidx15, align 1
  %14 = load i32, ptr %tmp, align 4
  %shr16 = lshr i32 %14, 8
  %and17 = and i32 %shr16, 255
  %conv18 = trunc i32 %and17 to i8
  %15 = load ptr, ptr %dst.addr, align 8
  %arrayidx19 = getelementptr inbounds i8, ptr %15, i64 1
  store i8 %conv18, ptr %arrayidx19, align 1
  %16 = load i32, ptr %tmp, align 4
  %shr20 = lshr i32 %16, 16
  %and21 = and i32 %shr20, 255
  %conv22 = trunc i32 %and21 to i8
  %17 = load ptr, ptr %dst.addr, align 8
  %arrayidx23 = getelementptr inbounds i8, ptr %17, i64 2
  store i8 %conv22, ptr %arrayidx23, align 1
  %18 = load i32, ptr %tmp, align 4
  %shr24 = lshr i32 %18, 24
  %and25 = and i32 %shr24, 255
  %conv26 = trunc i32 %and25 to i8
  %19 = load ptr, ptr %dst.addr, align 8
  %arrayidx27 = getelementptr inbounds i8, ptr %19, i64 3
  store i8 %conv26, ptr %arrayidx27, align 1
  %20 = load ptr, ptr %src.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %20, i64 5
  store ptr %add.ptr, ptr %src.addr, align 8
  %21 = load ptr, ptr %dst.addr, align 8
  %add.ptr28 = getelementptr inbounds i8, ptr %21, i64 4
  store ptr %add.ptr28, ptr %dst.addr, align 8
  br label %while.cond, !llvm.loop !44

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define noundef i32 @_ZN11ImFontAtlas20AddCustomRectRegularEii(ptr noundef nonnull align 8 dereferenceable(1180) %this, i32 noundef %width, i32 noundef %height) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %width.addr = alloca i32, align 4
  %height.addr = alloca i32, align 4
  %r = alloca %struct.ImFontAtlasCustomRect, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %width, ptr %width.addr, align 4
  store i32 %height, ptr %height.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN21ImFontAtlasCustomRectC2Ev(ptr noundef nonnull align 8 dereferenceable(32) %r)
  %0 = load i32, ptr %width.addr, align 4
  %conv = trunc i32 %0 to i16
  %Width = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %r, i32 0, i32 0
  store i16 %conv, ptr %Width, align 8
  %1 = load i32, ptr %height.addr, align 4
  %conv2 = trunc i32 %1 to i16
  %Height = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %r, i32 0, i32 1
  store i16 %conv2, ptr %Height, align 2
  %CustomRects = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 18
  call void @_ZN8ImVectorI21ImFontAtlasCustomRectE9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %CustomRects, ptr noundef nonnull align 8 dereferenceable(32) %r)
  %CustomRects3 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 18
  %Size = getelementptr inbounds %struct.ImVector.10, ptr %CustomRects3, i32 0, i32 0
  %2 = load i32, ptr %Size, align 8
  %sub = sub nsw i32 %2, 1
  ret i32 %sub
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN21ImFontAtlasCustomRectC2Ev(ptr noundef nonnull align 8 dereferenceable(32) %this) unnamed_addr #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %struct.ImVec2, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %GlyphOffset = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %this1, i32 0, i32 6
  call void @_ZN6ImVec2C2Ev(ptr noundef nonnull align 4 dereferenceable(8) %GlyphOffset)
  %Height = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %this1, i32 0, i32 1
  store i16 0, ptr %Height, align 2
  %Width = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %this1, i32 0, i32 0
  store i16 0, ptr %Width, align 8
  %Y = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %this1, i32 0, i32 3
  store i16 -1, ptr %Y, align 2
  %X = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %this1, i32 0, i32 2
  store i16 -1, ptr %X, align 4
  %GlyphID = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %this1, i32 0, i32 4
  store i32 0, ptr %GlyphID, align 8
  %GlyphAdvanceX = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %this1, i32 0, i32 5
  store float 0.000000e+00, ptr %GlyphAdvanceX, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %GlyphOffset2 = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %this1, i32 0, i32 6
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %GlyphOffset2, ptr align 4 %ref.tmp, i64 8, i1 false)
  %Font = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %this1, i32 0, i32 7
  store ptr null, ptr %Font, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI21ImFontAtlasCustomRectE9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(32) %v) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Size2 = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 0
  %2 = load i32, ptr %Size2, align 8
  %add = add nsw i32 %2, 1
  %call = call noundef i32 @_ZNK8ImVectorI21ImFontAtlasCustomRectE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %add)
  call void @_ZN8ImVectorI21ImFontAtlasCustomRectE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %Data = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %Size3 = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 0
  %4 = load i32, ptr %Size3, align 8
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %3, i64 %idxprom
  %5 = load ptr, ptr %v.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arrayidx, ptr align 8 %5, i64 32, i1 false)
  %Size4 = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size4, align 8
  %inc = add nsw i32 %6, 1
  store i32 %inc, ptr %Size4, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define noundef i32 @_ZN11ImFontAtlas22AddCustomRectFontGlyphEP6ImFonttiifRK6ImVec2(ptr noundef nonnull align 8 dereferenceable(1180) %this, ptr noundef %font, i16 noundef zeroext %id, i32 noundef %width, i32 noundef %height, float noundef %advance_x, ptr noundef nonnull align 4 dereferenceable(8) %offset) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %font.addr = alloca ptr, align 8
  %id.addr = alloca i16, align 2
  %width.addr = alloca i32, align 4
  %height.addr = alloca i32, align 4
  %advance_x.addr = alloca float, align 4
  %offset.addr = alloca ptr, align 8
  %r = alloca %struct.ImFontAtlasCustomRect, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %font, ptr %font.addr, align 8
  store i16 %id, ptr %id.addr, align 2
  store i32 %width, ptr %width.addr, align 4
  store i32 %height, ptr %height.addr, align 4
  store float %advance_x, ptr %advance_x.addr, align 4
  store ptr %offset, ptr %offset.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN21ImFontAtlasCustomRectC2Ev(ptr noundef nonnull align 8 dereferenceable(32) %r)
  %0 = load i32, ptr %width.addr, align 4
  %conv = trunc i32 %0 to i16
  %Width = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %r, i32 0, i32 0
  store i16 %conv, ptr %Width, align 8
  %1 = load i32, ptr %height.addr, align 4
  %conv2 = trunc i32 %1 to i16
  %Height = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %r, i32 0, i32 1
  store i16 %conv2, ptr %Height, align 2
  %2 = load i16, ptr %id.addr, align 2
  %conv3 = zext i16 %2 to i32
  %GlyphID = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %r, i32 0, i32 4
  store i32 %conv3, ptr %GlyphID, align 8
  %3 = load float, ptr %advance_x.addr, align 4
  %GlyphAdvanceX = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %r, i32 0, i32 5
  store float %3, ptr %GlyphAdvanceX, align 4
  %4 = load ptr, ptr %offset.addr, align 8
  %GlyphOffset = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %r, i32 0, i32 6
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %GlyphOffset, ptr align 4 %4, i64 8, i1 false)
  %5 = load ptr, ptr %font.addr, align 8
  %Font = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %r, i32 0, i32 7
  store ptr %5, ptr %Font, align 8
  %CustomRects = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 18
  call void @_ZN8ImVectorI21ImFontAtlasCustomRectE9push_backERKS0_(ptr noundef nonnull align 8 dereferenceable(16) %CustomRects, ptr noundef nonnull align 8 dereferenceable(32) %r)
  %CustomRects4 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 18
  %Size = getelementptr inbounds %struct.ImVector.10, ptr %CustomRects4, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %sub = sub nsw i32 %6, 1
  ret i32 %sub
}

; Function Attrs: mustprogress uwtable
define void @_ZNK11ImFontAtlas16CalcCustomRectUVEPK21ImFontAtlasCustomRectP6ImVec2S4_(ptr noundef nonnull align 8 dereferenceable(1180) %this, ptr noundef %rect, ptr noundef %out_uv_min, ptr noundef %out_uv_max) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rect.addr = alloca ptr, align 8
  %out_uv_min.addr = alloca ptr, align 8
  %out_uv_max.addr = alloca ptr, align 8
  %ref.tmp = alloca %struct.ImVec2, align 4
  %ref.tmp5 = alloca %struct.ImVec2, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %rect, ptr %rect.addr, align 8
  store ptr %out_uv_min, ptr %out_uv_min.addr, align 8
  store ptr %out_uv_max, ptr %out_uv_max.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rect.addr, align 8
  %X = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %0, i32 0, i32 2
  %1 = load i16, ptr %X, align 4
  %conv = uitofp i16 %1 to float
  %TexUvScale = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 15
  %x = getelementptr inbounds %struct.ImVec2, ptr %TexUvScale, i32 0, i32 0
  %2 = load float, ptr %x, align 8
  %mul = fmul float %conv, %2
  %3 = load ptr, ptr %rect.addr, align 8
  %Y = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %3, i32 0, i32 3
  %4 = load i16, ptr %Y, align 2
  %conv2 = uitofp i16 %4 to float
  %TexUvScale3 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 15
  %y = getelementptr inbounds %struct.ImVec2, ptr %TexUvScale3, i32 0, i32 1
  %5 = load float, ptr %y, align 4
  %mul4 = fmul float %conv2, %5
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef %mul, float noundef %mul4)
  %6 = load ptr, ptr %out_uv_min.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %6, ptr align 4 %ref.tmp, i64 8, i1 false)
  %7 = load ptr, ptr %rect.addr, align 8
  %X6 = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %7, i32 0, i32 2
  %8 = load i16, ptr %X6, align 4
  %conv7 = zext i16 %8 to i32
  %9 = load ptr, ptr %rect.addr, align 8
  %Width = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %9, i32 0, i32 0
  %10 = load i16, ptr %Width, align 8
  %conv8 = zext i16 %10 to i32
  %add = add nsw i32 %conv7, %conv8
  %conv9 = sitofp i32 %add to float
  %TexUvScale10 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 15
  %x11 = getelementptr inbounds %struct.ImVec2, ptr %TexUvScale10, i32 0, i32 0
  %11 = load float, ptr %x11, align 8
  %mul12 = fmul float %conv9, %11
  %12 = load ptr, ptr %rect.addr, align 8
  %Y13 = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %12, i32 0, i32 3
  %13 = load i16, ptr %Y13, align 2
  %conv14 = zext i16 %13 to i32
  %14 = load ptr, ptr %rect.addr, align 8
  %Height = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %14, i32 0, i32 1
  %15 = load i16, ptr %Height, align 2
  %conv15 = zext i16 %15 to i32
  %add16 = add nsw i32 %conv14, %conv15
  %conv17 = sitofp i32 %add16 to float
  %TexUvScale18 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 15
  %y19 = getelementptr inbounds %struct.ImVec2, ptr %TexUvScale18, i32 0, i32 1
  %16 = load float, ptr %y19, align 4
  %mul20 = fmul float %conv17, %16
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp5, float noundef %mul12, float noundef %mul20)
  %17 = load ptr, ptr %out_uv_max.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %17, ptr align 4 %ref.tmp5, i64 8, i1 false)
  ret void
}

; Function Attrs: mustprogress uwtable
define noundef zeroext i1 @_ZN11ImFontAtlas21GetMouseCursorTexDataEiP6ImVec2S1_S1_S1_(ptr noundef nonnull align 8 dereferenceable(1180) %this, i32 noundef %cursor_type, ptr noundef %out_offset, ptr noundef %out_size, ptr noundef %out_uv_border, ptr noundef %out_uv_fill) #0 align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  %cursor_type.addr = alloca i32, align 4
  %out_offset.addr = alloca ptr, align 8
  %out_size.addr = alloca ptr, align 8
  %out_uv_border.addr = alloca ptr, align 8
  %out_uv_fill.addr = alloca ptr, align 8
  %r = alloca ptr, align 8
  %pos = alloca %struct.ImVec2, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  %size = alloca %struct.ImVec2, align 4
  %ref.tmp14 = alloca %struct.ImVec2, align 4
  %ref.tmp17 = alloca %struct.ImVec2, align 4
  %ref.tmp18 = alloca %struct.ImVec2, align 4
  %ref.tmp23 = alloca %struct.ImVec2, align 4
  %ref.tmp27 = alloca %struct.ImVec2, align 4
  %ref.tmp28 = alloca %struct.ImVec2, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %cursor_type, ptr %cursor_type.addr, align 4
  store ptr %out_offset, ptr %out_offset.addr, align 8
  store ptr %out_size, ptr %out_size.addr, align 8
  store ptr %out_uv_border, ptr %out_uv_border.addr, align 8
  store ptr %out_uv_fill, ptr %out_uv_fill.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %cursor_type.addr, align 4
  %cmp = icmp sle i32 %0, -1
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %cursor_type.addr, align 4
  %cmp2 = icmp sge i32 %1, 9
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %Flags = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 0
  %2 = load i32, ptr %Flags, align 8
  %and = and i32 %2, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end4:                                          ; preds = %if.end
  %PackIdMouseCursors = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 23
  %3 = load i32, ptr %PackIdMouseCursors, align 4
  %call = call noundef ptr @_ZN11ImFontAtlas20GetCustomRectByIndexEi(ptr noundef nonnull align 8 dereferenceable(1180) %this1, i32 noundef %3)
  store ptr %call, ptr %r, align 8
  %4 = load i32, ptr %cursor_type.addr, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds [9 x [3 x %struct.ImVec2]], ptr @_ZL34FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA, i64 0, i64 %idxprom
  %arrayidx5 = getelementptr inbounds [3 x %struct.ImVec2], ptr %arrayidx, i64 0, i64 0
  %5 = load ptr, ptr %r, align 8
  %X = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %5, i32 0, i32 2
  %6 = load i16, ptr %X, align 4
  %conv = uitofp i16 %6 to float
  %7 = load ptr, ptr %r, align 8
  %Y = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %7, i32 0, i32 3
  %8 = load i16, ptr %Y, align 2
  %conv6 = uitofp i16 %8 to float
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef %conv, float noundef %conv6)
  %call7 = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %arrayidx5, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp)
  store <2 x float> %call7, ptr %pos, align 4
  %9 = load i32, ptr %cursor_type.addr, align 4
  %idxprom8 = sext i32 %9 to i64
  %arrayidx9 = getelementptr inbounds [9 x [3 x %struct.ImVec2]], ptr @_ZL34FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA, i64 0, i64 %idxprom8
  %arrayidx10 = getelementptr inbounds [3 x %struct.ImVec2], ptr %arrayidx9, i64 0, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %size, ptr align 8 %arrayidx10, i64 8, i1 false)
  %10 = load ptr, ptr %out_size.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %10, ptr align 4 %size, i64 8, i1 false)
  %11 = load i32, ptr %cursor_type.addr, align 4
  %idxprom11 = sext i32 %11 to i64
  %arrayidx12 = getelementptr inbounds [9 x [3 x %struct.ImVec2]], ptr @_ZL34FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA, i64 0, i64 %idxprom11
  %arrayidx13 = getelementptr inbounds [3 x %struct.ImVec2], ptr %arrayidx12, i64 0, i64 2
  %12 = load ptr, ptr %out_offset.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %12, ptr align 8 %arrayidx13, i64 8, i1 false)
  %TexUvScale = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 15
  %call15 = call <2 x float> @_ZmlRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %pos, ptr noundef nonnull align 4 dereferenceable(8) %TexUvScale)
  store <2 x float> %call15, ptr %ref.tmp14, align 4
  %13 = load ptr, ptr %out_uv_border.addr, align 8
  %arrayidx16 = getelementptr inbounds %struct.ImVec2, ptr %13, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx16, ptr align 4 %ref.tmp14, i64 8, i1 false)
  %call19 = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %pos, ptr noundef nonnull align 4 dereferenceable(8) %size)
  store <2 x float> %call19, ptr %ref.tmp18, align 4
  %TexUvScale20 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 15
  %call21 = call <2 x float> @_ZmlRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp18, ptr noundef nonnull align 4 dereferenceable(8) %TexUvScale20)
  store <2 x float> %call21, ptr %ref.tmp17, align 4
  %14 = load ptr, ptr %out_uv_border.addr, align 8
  %arrayidx22 = getelementptr inbounds %struct.ImVec2, ptr %14, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx22, ptr align 4 %ref.tmp17, i64 8, i1 false)
  %x = getelementptr inbounds %struct.ImVec2, ptr %pos, i32 0, i32 0
  %15 = load float, ptr %x, align 4
  %add = fadd float %15, 1.230000e+02
  store float %add, ptr %x, align 4
  %TexUvScale24 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 15
  %call25 = call <2 x float> @_ZmlRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %pos, ptr noundef nonnull align 4 dereferenceable(8) %TexUvScale24)
  store <2 x float> %call25, ptr %ref.tmp23, align 4
  %16 = load ptr, ptr %out_uv_fill.addr, align 8
  %arrayidx26 = getelementptr inbounds %struct.ImVec2, ptr %16, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx26, ptr align 4 %ref.tmp23, i64 8, i1 false)
  %call29 = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %pos, ptr noundef nonnull align 4 dereferenceable(8) %size)
  store <2 x float> %call29, ptr %ref.tmp28, align 4
  %TexUvScale30 = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 15
  %call31 = call <2 x float> @_ZmlRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp28, ptr noundef nonnull align 4 dereferenceable(8) %TexUvScale30)
  store <2 x float> %call31, ptr %ref.tmp27, align 4
  %17 = load ptr, ptr %out_uv_fill.addr, align 8
  %arrayidx32 = getelementptr inbounds %struct.ImVec2, ptr %17, i64 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx32, ptr align 4 %ref.tmp27, i64 8, i1 false)
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %18 = load i1, ptr %retval, align 1
  ret i1 %18
}

; Function Attrs: mustprogress uwtable
define linkonce_odr noundef ptr @_ZN11ImFontAtlas20GetCustomRectByIndexEi(ptr noundef nonnull align 8 dereferenceable(1180) %this, i32 noundef %index) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %index.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %index, ptr %index.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %CustomRects = getelementptr inbounds %struct.ImFontAtlas, ptr %this1, i32 0, i32 18
  %0 = load i32, ptr %index.addr, align 4
  %call = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN8ImVectorI21ImFontAtlasCustomRectEixEi(ptr noundef nonnull align 8 dereferenceable(16) %CustomRects, i32 noundef %0)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define internal <2 x float> @_ZmlRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %lhs, ptr noundef nonnull align 4 dereferenceable(8) %rhs) #0 {
entry:
  %retval = alloca %struct.ImVec2, align 4
  %lhs.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %lhs, ptr %lhs.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %0 = load ptr, ptr %lhs.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %0, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %2 = load ptr, ptr %rhs.addr, align 8
  %x1 = getelementptr inbounds %struct.ImVec2, ptr %2, i32 0, i32 0
  %3 = load float, ptr %x1, align 4
  %mul = fmul float %1, %3
  %4 = load ptr, ptr %lhs.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %4, i32 0, i32 1
  %5 = load float, ptr %y, align 4
  %6 = load ptr, ptr %rhs.addr, align 8
  %y2 = getelementptr inbounds %struct.ImVec2, ptr %6, i32 0, i32 1
  %7 = load float, ptr %y2, align 4
  %mul3 = fmul float %5, %7
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %retval, float noundef %mul, float noundef %mul3)
  %8 = load <2 x float>, ptr %retval, align 4
  ret <2 x float> %8
}

; Function Attrs: mustprogress nounwind uwtable
define noundef ptr @_Z35ImFontAtlasGetBuilderForStbTruetypev() #2 {
entry:
  store ptr @_ZL31ImFontAtlasBuildWithStbTruetypeP11ImFontAtlas, ptr @_ZZ35ImFontAtlasGetBuilderForStbTruetypevE2io, align 8
  ret ptr @_ZZ35ImFontAtlasGetBuilderForStbTruetypevE2io
}

; Function Attrs: mustprogress nounwind uwtable
define void @_Z39ImFontAtlasBuildMultiplyCalcLookupTablePhf(ptr noundef %out_table, float noundef %in_brighten_factor) #2 {
entry:
  %out_table.addr = alloca ptr, align 8
  %in_brighten_factor.addr = alloca float, align 4
  %i = alloca i32, align 4
  %value = alloca i32, align 4
  store ptr %out_table, ptr %out_table.addr, align 8
  store float %in_brighten_factor, ptr %in_brighten_factor.addr, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %cmp = icmp ult i32 %0, 256
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %i, align 4
  %conv = uitofp i32 %1 to float
  %2 = load float, ptr %in_brighten_factor.addr, align 4
  %mul = fmul float %conv, %2
  %conv1 = fptoui float %mul to i32
  store i32 %conv1, ptr %value, align 4
  %3 = load i32, ptr %value, align 4
  %cmp2 = icmp ugt i32 %3, 255
  br i1 %cmp2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %4 = load i32, ptr %value, align 4
  %and = and i32 %4, 255
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 255, %cond.true ], [ %and, %cond.false ]
  %conv3 = trunc i32 %cond to i8
  %5 = load ptr, ptr %out_table.addr, align 8
  %6 = load i32, ptr %i, align 4
  %idxprom = zext i32 %6 to i64
  %arrayidx = getelementptr inbounds i8, ptr %5, i64 %idxprom
  store i8 %conv3, ptr %arrayidx, align 1
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %7 = load i32, ptr %i, align 4
  %inc = add i32 %7, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !45

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define void @_Z34ImFontAtlasBuildMultiplyRectAlpha8PKhPhiiiii(ptr noundef %table, ptr noundef %pixels, i32 noundef %x, i32 noundef %y, i32 noundef %w, i32 noundef %h, i32 noundef %stride) #2 {
entry:
  %table.addr = alloca ptr, align 8
  %pixels.addr = alloca ptr, align 8
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %stride.addr = alloca i32, align 4
  %data = alloca ptr, align 8
  %j = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %table, ptr %table.addr, align 8
  store ptr %pixels, ptr %pixels.addr, align 8
  store i32 %x, ptr %x.addr, align 4
  store i32 %y, ptr %y.addr, align 4
  store i32 %w, ptr %w.addr, align 4
  store i32 %h, ptr %h.addr, align 4
  store i32 %stride, ptr %stride.addr, align 4
  %0 = load ptr, ptr %pixels.addr, align 8
  %1 = load i32, ptr %x.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr inbounds i8, ptr %0, i64 %idx.ext
  %2 = load i32, ptr %y.addr, align 4
  %3 = load i32, ptr %stride.addr, align 4
  %mul = mul nsw i32 %2, %3
  %idx.ext1 = sext i32 %mul to i64
  %add.ptr2 = getelementptr inbounds i8, ptr %add.ptr, i64 %idx.ext1
  store ptr %add.ptr2, ptr %data, align 8
  %4 = load i32, ptr %h.addr, align 4
  store i32 %4, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %5 = load i32, ptr %j, align 4
  %cmp = icmp sgt i32 %5, 0
  br i1 %cmp, label %for.body, label %for.end10

for.body:                                         ; preds = %for.cond
  %6 = load i32, ptr %w.addr, align 4
  store i32 %6, ptr %i, align 4
  br label %for.cond3

for.cond3:                                        ; preds = %for.inc, %for.body
  %7 = load i32, ptr %i, align 4
  %cmp4 = icmp sgt i32 %7, 0
  br i1 %cmp4, label %for.body5, label %for.end

for.body5:                                        ; preds = %for.cond3
  %8 = load ptr, ptr %table.addr, align 8
  %9 = load ptr, ptr %data, align 8
  %10 = load i8, ptr %9, align 1
  %idxprom = zext i8 %10 to i64
  %arrayidx = getelementptr inbounds i8, ptr %8, i64 %idxprom
  %11 = load i8, ptr %arrayidx, align 1
  %12 = load ptr, ptr %data, align 8
  store i8 %11, ptr %12, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body5
  %13 = load i32, ptr %i, align 4
  %dec = add nsw i32 %13, -1
  store i32 %dec, ptr %i, align 4
  %14 = load ptr, ptr %data, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %14, i32 1
  store ptr %incdec.ptr, ptr %data, align 8
  br label %for.cond3, !llvm.loop !46

for.end:                                          ; preds = %for.cond3
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %15 = load i32, ptr %j, align 4
  %dec7 = add nsw i32 %15, -1
  store i32 %dec7, ptr %j, align 4
  %16 = load i32, ptr %stride.addr, align 4
  %17 = load i32, ptr %w.addr, align 4
  %sub = sub nsw i32 %16, %17
  %18 = load ptr, ptr %data, align 8
  %idx.ext8 = sext i32 %sub to i64
  %add.ptr9 = getelementptr inbounds i8, ptr %18, i64 %idx.ext8
  store ptr %add.ptr9, ptr %data, align 8
  br label %for.cond, !llvm.loop !47

for.end10:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define internal noundef zeroext i1 @_ZL31ImFontAtlasBuildWithStbTruetypeP11ImFontAtlas(ptr noundef %atlas) #4 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca i1, align 1
  %atlas.addr = alloca ptr, align 8
  %ref.tmp = alloca %struct.ImVec2, align 4
  %ref.tmp1 = alloca %struct.ImVec2, align 4
  %src_tmp_array = alloca %struct.ImVector.14, align 8
  %dst_tmp_array = alloca %struct.ImVector.15, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %src_i = alloca i32, align 4
  %src_tmp = alloca ptr, align 8
  %cfg = alloca ptr, align 8
  %output_i = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  %font_offset = alloca i32, align 4
  %dst_tmp = alloca ptr, align 8
  %src_range = alloca ptr, align 8
  %total_glyphs_count = alloca i32, align 4
  %src_i71 = alloca i32, align 4
  %src_tmp76 = alloca ptr, align 8
  %dst_tmp79 = alloca ptr, align 8
  %src_range94 = alloca ptr, align 8
  %codepoint = alloca i32, align 4
  %src_i139 = alloca i32, align 4
  %src_tmp144 = alloca ptr, align 8
  %dst_i = alloca i32, align 4
  %buf_rects = alloca %struct.ImVector.12, align 8
  %buf_packedchars = alloca %struct.ImVector.17, align 8
  %total_surface = alloca i32, align 4
  %buf_rects_out_n = alloca i32, align 4
  %buf_packedchars_out_n = alloca i32, align 4
  %src_i183 = alloca i32, align 4
  %src_tmp188 = alloca ptr, align 8
  %cfg203 = alloca ptr, align 8
  %scale = alloca float, align 4
  %padding = alloca i32, align 4
  %glyph_i = alloca i32, align 4
  %x0 = alloca i32, align 4
  %y0 = alloca i32, align 4
  %x1 = alloca i32, align 4
  %y1 = alloca i32, align 4
  %glyph_index_in_font = alloca i32, align 4
  %surface_sqrt = alloca i32, align 4
  %TEX_HEIGHT_MAX = alloca i32, align 4
  %spc = alloca %struct.stbtt_pack_context, align 8
  %src_i318 = alloca i32, align 4
  %src_tmp323 = alloca ptr, align 8
  %glyph_i335 = alloca i32, align 4
  %ref.tmp375 = alloca %struct.ImVec2, align 4
  %src_i396 = alloca i32, align 4
  %cfg401 = alloca ptr, align 8
  %src_tmp405 = alloca ptr, align 8
  %multiply_table = alloca [256 x i8], align 16
  %r = alloca ptr, align 8
  %glyph_i422 = alloca i32, align 4
  %src_i448 = alloca i32, align 4
  %src_tmp453 = alloca ptr, align 8
  %cfg456 = alloca ptr, align 8
  %dst_font = alloca ptr, align 8
  %font_scale = alloca float, align 4
  %unscaled_ascent = alloca i32, align 4
  %unscaled_descent = alloca i32, align 4
  %unscaled_line_gap = alloca i32, align 4
  %ascent = alloca float, align 4
  %descent = alloca float, align 4
  %font_off_x = alloca float, align 4
  %font_off_y = alloca float, align 4
  %inv_rasterization_scale = alloca float, align 4
  %glyph_i493 = alloca i32, align 4
  %codepoint498 = alloca i32, align 4
  %pc = alloca ptr, align 8
  %q = alloca %struct.stbtt_aligned_quad, align 4
  %unused_x = alloca float, align 4
  %unused_y = alloca float, align 4
  %x0509 = alloca float, align 4
  %y0512 = alloca float, align 4
  %x1515 = alloca float, align 4
  %y1518 = alloca float, align 4
  store ptr %atlas, ptr %atlas.addr, align 8
  %0 = load ptr, ptr %atlas.addr, align 8
  call void @_Z20ImFontAtlasBuildInitP11ImFontAtlas(ptr noundef %0)
  %1 = load ptr, ptr %atlas.addr, align 8
  %TexID = getelementptr inbounds %struct.ImFontAtlas, ptr %1, i32 0, i32 2
  store ptr null, ptr %TexID, align 8
  %2 = load ptr, ptr %atlas.addr, align 8
  %TexHeight = getelementptr inbounds %struct.ImFontAtlas, ptr %2, i32 0, i32 14
  store i32 0, ptr %TexHeight, align 4
  %3 = load ptr, ptr %atlas.addr, align 8
  %TexWidth = getelementptr inbounds %struct.ImFontAtlas, ptr %3, i32 0, i32 13
  store i32 0, ptr %TexWidth, align 8
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %4 = load ptr, ptr %atlas.addr, align 8
  %TexUvScale = getelementptr inbounds %struct.ImFontAtlas, ptr %4, i32 0, i32 15
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %TexUvScale, ptr align 4 %ref.tmp, i64 8, i1 false)
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp1, float noundef 0.000000e+00, float noundef 0.000000e+00)
  %5 = load ptr, ptr %atlas.addr, align 8
  %TexUvWhitePixel = getelementptr inbounds %struct.ImFontAtlas, ptr %5, i32 0, i32 16
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %TexUvWhitePixel, ptr align 4 %ref.tmp1, i64 8, i1 false)
  %6 = load ptr, ptr %atlas.addr, align 8
  call void @_ZN11ImFontAtlas12ClearTexDataEv(ptr noundef nonnull align 8 dereferenceable(1180) %6)
  call void @_ZN8ImVectorI18ImFontBuildSrcDataEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %src_tmp_array)
  invoke void @_ZN8ImVectorI18ImFontBuildDstDataEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %dst_tmp_array)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  %7 = load ptr, ptr %atlas.addr, align 8
  %ConfigData = getelementptr inbounds %struct.ImFontAtlas, ptr %7, i32 0, i32 19
  %Size = getelementptr inbounds %struct.ImVector.11, ptr %ConfigData, i32 0, i32 0
  %8 = load i32, ptr %Size, align 8
  invoke void @_ZN8ImVectorI18ImFontBuildSrcDataE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %src_tmp_array, i32 noundef %8)
          to label %invoke.cont3 unwind label %lpad2

invoke.cont3:                                     ; preds = %invoke.cont
  %9 = load ptr, ptr %atlas.addr, align 8
  %Fonts = getelementptr inbounds %struct.ImFontAtlas, ptr %9, i32 0, i32 17
  %Size4 = getelementptr inbounds %struct.ImVector.9, ptr %Fonts, i32 0, i32 0
  %10 = load i32, ptr %Size4, align 8
  invoke void @_ZN8ImVectorI18ImFontBuildDstDataE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %dst_tmp_array, i32 noundef %10)
          to label %invoke.cont5 unwind label %lpad2

invoke.cont5:                                     ; preds = %invoke.cont3
  %Data = getelementptr inbounds %struct.ImVector.14, ptr %src_tmp_array, i32 0, i32 2
  %11 = load ptr, ptr %Data, align 8
  %call = invoke noundef i32 @_ZNK8ImVectorI18ImFontBuildSrcDataE13size_in_bytesEv(ptr noundef nonnull align 8 dereferenceable(16) %src_tmp_array)
          to label %invoke.cont6 unwind label %lpad2

invoke.cont6:                                     ; preds = %invoke.cont5
  %conv = sext i32 %call to i64
  call void @llvm.memset.p0.i64(ptr align 8 %11, i8 0, i64 %conv, i1 false)
  %Data7 = getelementptr inbounds %struct.ImVector.15, ptr %dst_tmp_array, i32 0, i32 2
  %12 = load ptr, ptr %Data7, align 8
  %call9 = invoke noundef i32 @_ZNK8ImVectorI18ImFontBuildDstDataE13size_in_bytesEv(ptr noundef nonnull align 8 dereferenceable(16) %dst_tmp_array)
          to label %invoke.cont8 unwind label %lpad2

invoke.cont8:                                     ; preds = %invoke.cont6
  %conv10 = sext i32 %call9 to i64
  call void @llvm.memset.p0.i64(ptr align 8 %12, i8 0, i64 %conv10, i1 false)
  store i32 0, ptr %src_i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc68, %invoke.cont8
  %13 = load i32, ptr %src_i, align 4
  %14 = load ptr, ptr %atlas.addr, align 8
  %ConfigData11 = getelementptr inbounds %struct.ImFontAtlas, ptr %14, i32 0, i32 19
  %Size12 = getelementptr inbounds %struct.ImVector.11, ptr %ConfigData11, i32 0, i32 0
  %15 = load i32, ptr %Size12, align 8
  %cmp = icmp slt i32 %13, %15
  br i1 %cmp, label %for.body, label %for.end70

for.body:                                         ; preds = %for.cond
  %16 = load i32, ptr %src_i, align 4
  %call14 = invoke noundef nonnull align 8 dereferenceable(272) ptr @_ZN8ImVectorI18ImFontBuildSrcDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %src_tmp_array, i32 noundef %16)
          to label %invoke.cont13 unwind label %lpad2

invoke.cont13:                                    ; preds = %for.body
  store ptr %call14, ptr %src_tmp, align 8
  %17 = load ptr, ptr %atlas.addr, align 8
  %ConfigData15 = getelementptr inbounds %struct.ImFontAtlas, ptr %17, i32 0, i32 19
  %18 = load i32, ptr %src_i, align 4
  %call17 = invoke noundef nonnull align 8 dereferenceable(144) ptr @_ZN8ImVectorI12ImFontConfigEixEi(ptr noundef nonnull align 8 dereferenceable(16) %ConfigData15, i32 noundef %18)
          to label %invoke.cont16 unwind label %lpad2

invoke.cont16:                                    ; preds = %invoke.cont13
  store ptr %call17, ptr %cfg, align 8
  %19 = load ptr, ptr %src_tmp, align 8
  %DstIndex = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %19, i32 0, i32 5
  store i32 -1, ptr %DstIndex, align 8
  store i32 0, ptr %output_i, align 4
  br label %for.cond18

for.cond18:                                       ; preds = %for.inc, %invoke.cont16
  %20 = load i32, ptr %output_i, align 4
  %21 = load ptr, ptr %atlas.addr, align 8
  %Fonts19 = getelementptr inbounds %struct.ImFontAtlas, ptr %21, i32 0, i32 17
  %Size20 = getelementptr inbounds %struct.ImVector.9, ptr %Fonts19, i32 0, i32 0
  %22 = load i32, ptr %Size20, align 8
  %cmp21 = icmp slt i32 %20, %22
  br i1 %cmp21, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond18
  %23 = load ptr, ptr %src_tmp, align 8
  %DstIndex22 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %23, i32 0, i32 5
  %24 = load i32, ptr %DstIndex22, align 8
  %cmp23 = icmp eq i32 %24, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond18
  %25 = phi i1 [ false, %for.cond18 ], [ %cmp23, %land.rhs ]
  br i1 %25, label %for.body24, label %for.end

for.body24:                                       ; preds = %land.end
  %26 = load ptr, ptr %cfg, align 8
  %DstFont = getelementptr inbounds %struct.ImFontConfig, ptr %26, i32 0, i32 19
  %27 = load ptr, ptr %DstFont, align 8
  %28 = load ptr, ptr %atlas.addr, align 8
  %Fonts25 = getelementptr inbounds %struct.ImFontAtlas, ptr %28, i32 0, i32 17
  %29 = load i32, ptr %output_i, align 4
  %call27 = invoke noundef nonnull align 8 dereferenceable(8) ptr @_ZN8ImVectorIP6ImFontEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Fonts25, i32 noundef %29)
          to label %invoke.cont26 unwind label %lpad2

invoke.cont26:                                    ; preds = %for.body24
  %30 = load ptr, ptr %call27, align 8
  %cmp28 = icmp eq ptr %27, %30
  br i1 %cmp28, label %if.then, label %if.end

if.then:                                          ; preds = %invoke.cont26
  %31 = load i32, ptr %output_i, align 4
  %32 = load ptr, ptr %src_tmp, align 8
  %DstIndex29 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %32, i32 0, i32 5
  store i32 %31, ptr %DstIndex29, align 8
  br label %if.end

lpad:                                             ; preds = %entry
  %33 = landingpad { ptr, i32 }
          cleanup
  %34 = extractvalue { ptr, i32 } %33, 0
  store ptr %34, ptr %exn.slot, align 8
  %35 = extractvalue { ptr, i32 } %33, 1
  store i32 %35, ptr %ehselector.slot, align 4
  br label %ehcleanup534

lpad2:                                            ; preds = %invoke.cont168, %for.end167, %invoke.cont161, %for.body160, %invoke.cont151, %invoke.cont148, %invoke.cont145, %for.body143, %invoke.cont126, %if.end121, %if.end115, %for.body110, %if.then88, %invoke.cont84, %invoke.cont81, %invoke.cont77, %for.body75, %for.end61, %for.body54, %if.end40, %invoke.cont34, %if.end33, %for.body24, %invoke.cont13, %for.body, %invoke.cont6, %invoke.cont5, %invoke.cont3, %invoke.cont
  %36 = landingpad { ptr, i32 }
          cleanup
  %37 = extractvalue { ptr, i32 } %36, 0
  store ptr %37, ptr %exn.slot, align 8
  %38 = extractvalue { ptr, i32 } %36, 1
  store i32 %38, ptr %ehselector.slot, align 4
  br label %ehcleanup532

if.end:                                           ; preds = %if.then, %invoke.cont26
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %39 = load i32, ptr %output_i, align 4
  %inc = add nsw i32 %39, 1
  store i32 %inc, ptr %output_i, align 4
  br label %for.cond18, !llvm.loop !48

for.end:                                          ; preds = %land.end
  %40 = load ptr, ptr %src_tmp, align 8
  %DstIndex30 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %40, i32 0, i32 5
  %41 = load i32, ptr %DstIndex30, align 8
  %cmp31 = icmp eq i32 %41, -1
  br i1 %cmp31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %for.end
  store i1 false, ptr %retval, align 1
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end33:                                         ; preds = %for.end
  %42 = load ptr, ptr %cfg, align 8
  %FontData = getelementptr inbounds %struct.ImFontConfig, ptr %42, i32 0, i32 0
  %43 = load ptr, ptr %FontData, align 8
  %44 = load ptr, ptr %cfg, align 8
  %FontNo = getelementptr inbounds %struct.ImFontConfig, ptr %44, i32 0, i32 3
  %45 = load i32, ptr %FontNo, align 8
  %call35 = invoke noundef i32 @_ZL27stbtt_GetFontOffsetForIndexPKhi(ptr noundef %43, i32 noundef %45)
          to label %invoke.cont34 unwind label %lpad2

invoke.cont34:                                    ; preds = %if.end33
  store i32 %call35, ptr %font_offset, align 4
  %46 = load ptr, ptr %src_tmp, align 8
  %FontInfo = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %46, i32 0, i32 0
  %47 = load ptr, ptr %cfg, align 8
  %FontData36 = getelementptr inbounds %struct.ImFontConfig, ptr %47, i32 0, i32 0
  %48 = load ptr, ptr %FontData36, align 8
  %49 = load i32, ptr %font_offset, align 4
  %call38 = invoke noundef i32 @_ZL14stbtt_InitFontP14stbtt_fontinfoPKhi(ptr noundef %FontInfo, ptr noundef %48, i32 noundef %49)
          to label %invoke.cont37 unwind label %lpad2

invoke.cont37:                                    ; preds = %invoke.cont34
  %tobool = icmp ne i32 %call38, 0
  br i1 %tobool, label %if.end40, label %if.then39

if.then39:                                        ; preds = %invoke.cont37
  store i1 false, ptr %retval, align 1
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end40:                                         ; preds = %invoke.cont37
  %50 = load ptr, ptr %src_tmp, align 8
  %DstIndex41 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %50, i32 0, i32 5
  %51 = load i32, ptr %DstIndex41, align 8
  %call43 = invoke noundef nonnull align 8 dereferenceable(32) ptr @_ZN8ImVectorI18ImFontBuildDstDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %dst_tmp_array, i32 noundef %51)
          to label %invoke.cont42 unwind label %lpad2

invoke.cont42:                                    ; preds = %if.end40
  store ptr %call43, ptr %dst_tmp, align 8
  %52 = load ptr, ptr %cfg, align 8
  %GlyphRanges = getelementptr inbounds %struct.ImFontConfig, ptr %52, i32 0, i32 10
  %53 = load ptr, ptr %GlyphRanges, align 8
  %tobool44 = icmp ne ptr %53, null
  br i1 %tobool44, label %cond.true, label %cond.false

cond.true:                                        ; preds = %invoke.cont42
  %54 = load ptr, ptr %cfg, align 8
  %GlyphRanges45 = getelementptr inbounds %struct.ImFontConfig, ptr %54, i32 0, i32 10
  %55 = load ptr, ptr %GlyphRanges45, align 8
  br label %cond.end

cond.false:                                       ; preds = %invoke.cont42
  %56 = load ptr, ptr %atlas.addr, align 8
  %call46 = call noundef ptr @_ZN11ImFontAtlas21GetGlyphRangesDefaultEv(ptr noundef nonnull align 8 dereferenceable(1180) %56)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %55, %cond.true ], [ %call46, %cond.false ]
  %57 = load ptr, ptr %src_tmp, align 8
  %SrcRanges = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %57, i32 0, i32 4
  store ptr %cond, ptr %SrcRanges, align 8
  %58 = load ptr, ptr %src_tmp, align 8
  %SrcRanges47 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %58, i32 0, i32 4
  %59 = load ptr, ptr %SrcRanges47, align 8
  store ptr %59, ptr %src_range, align 8
  br label %for.cond48

for.cond48:                                       ; preds = %for.inc60, %cond.end
  %60 = load ptr, ptr %src_range, align 8
  %arrayidx = getelementptr inbounds i16, ptr %60, i64 0
  %61 = load i16, ptr %arrayidx, align 2
  %tobool49 = icmp ne i16 %61, 0
  br i1 %tobool49, label %land.rhs50, label %land.end53

land.rhs50:                                       ; preds = %for.cond48
  %62 = load ptr, ptr %src_range, align 8
  %arrayidx51 = getelementptr inbounds i16, ptr %62, i64 1
  %63 = load i16, ptr %arrayidx51, align 2
  %tobool52 = icmp ne i16 %63, 0
  br label %land.end53

land.end53:                                       ; preds = %land.rhs50, %for.cond48
  %64 = phi i1 [ false, %for.cond48 ], [ %tobool52, %land.rhs50 ]
  br i1 %64, label %for.body54, label %for.end61

for.body54:                                       ; preds = %land.end53
  %65 = load ptr, ptr %src_tmp, align 8
  %GlyphsHighest = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %65, i32 0, i32 6
  %66 = load i32, ptr %GlyphsHighest, align 4
  %67 = load ptr, ptr %src_range, align 8
  %arrayidx55 = getelementptr inbounds i16, ptr %67, i64 1
  %68 = load i16, ptr %arrayidx55, align 2
  %conv56 = zext i16 %68 to i32
  %call58 = invoke noundef i32 @_ZL5ImMaxIiET_S0_S0_(i32 noundef %66, i32 noundef %conv56)
          to label %invoke.cont57 unwind label %lpad2

invoke.cont57:                                    ; preds = %for.body54
  %69 = load ptr, ptr %src_tmp, align 8
  %GlyphsHighest59 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %69, i32 0, i32 6
  store i32 %call58, ptr %GlyphsHighest59, align 4
  br label %for.inc60

for.inc60:                                        ; preds = %invoke.cont57
  %70 = load ptr, ptr %src_range, align 8
  %add.ptr = getelementptr inbounds i16, ptr %70, i64 2
  store ptr %add.ptr, ptr %src_range, align 8
  br label %for.cond48, !llvm.loop !49

for.end61:                                        ; preds = %land.end53
  %71 = load ptr, ptr %dst_tmp, align 8
  %SrcCount = getelementptr inbounds %struct.ImFontBuildDstData, ptr %71, i32 0, i32 0
  %72 = load i32, ptr %SrcCount, align 8
  %inc62 = add nsw i32 %72, 1
  store i32 %inc62, ptr %SrcCount, align 8
  %73 = load ptr, ptr %dst_tmp, align 8
  %GlyphsHighest63 = getelementptr inbounds %struct.ImFontBuildDstData, ptr %73, i32 0, i32 1
  %74 = load i32, ptr %GlyphsHighest63, align 4
  %75 = load ptr, ptr %src_tmp, align 8
  %GlyphsHighest64 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %75, i32 0, i32 6
  %76 = load i32, ptr %GlyphsHighest64, align 4
  %call66 = invoke noundef i32 @_ZL5ImMaxIiET_S0_S0_(i32 noundef %74, i32 noundef %76)
          to label %invoke.cont65 unwind label %lpad2

invoke.cont65:                                    ; preds = %for.end61
  %77 = load ptr, ptr %dst_tmp, align 8
  %GlyphsHighest67 = getelementptr inbounds %struct.ImFontBuildDstData, ptr %77, i32 0, i32 1
  store i32 %call66, ptr %GlyphsHighest67, align 4
  br label %for.inc68

for.inc68:                                        ; preds = %invoke.cont65
  %78 = load i32, ptr %src_i, align 4
  %inc69 = add nsw i32 %78, 1
  store i32 %inc69, ptr %src_i, align 4
  br label %for.cond, !llvm.loop !50

for.end70:                                        ; preds = %for.cond
  store i32 0, ptr %total_glyphs_count, align 4
  store i32 0, ptr %src_i71, align 4
  br label %for.cond72

for.cond72:                                       ; preds = %for.inc136, %for.end70
  %79 = load i32, ptr %src_i71, align 4
  %Size73 = getelementptr inbounds %struct.ImVector.14, ptr %src_tmp_array, i32 0, i32 0
  %80 = load i32, ptr %Size73, align 8
  %cmp74 = icmp slt i32 %79, %80
  br i1 %cmp74, label %for.body75, label %for.end138

for.body75:                                       ; preds = %for.cond72
  %81 = load i32, ptr %src_i71, align 4
  %call78 = invoke noundef nonnull align 8 dereferenceable(272) ptr @_ZN8ImVectorI18ImFontBuildSrcDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %src_tmp_array, i32 noundef %81)
          to label %invoke.cont77 unwind label %lpad2

invoke.cont77:                                    ; preds = %for.body75
  store ptr %call78, ptr %src_tmp76, align 8
  %82 = load ptr, ptr %src_tmp76, align 8
  %DstIndex80 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %82, i32 0, i32 5
  %83 = load i32, ptr %DstIndex80, align 8
  %call82 = invoke noundef nonnull align 8 dereferenceable(32) ptr @_ZN8ImVectorI18ImFontBuildDstDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %dst_tmp_array, i32 noundef %83)
          to label %invoke.cont81 unwind label %lpad2

invoke.cont81:                                    ; preds = %invoke.cont77
  store ptr %call82, ptr %dst_tmp79, align 8
  %84 = load ptr, ptr %src_tmp76, align 8
  %GlyphsSet = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %84, i32 0, i32 8
  %85 = load ptr, ptr %src_tmp76, align 8
  %GlyphsHighest83 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %85, i32 0, i32 6
  %86 = load i32, ptr %GlyphsHighest83, align 4
  %add = add nsw i32 %86, 1
  invoke void @_ZN11ImBitVector6CreateEi(ptr noundef nonnull align 8 dereferenceable(16) %GlyphsSet, i32 noundef %add)
          to label %invoke.cont84 unwind label %lpad2

invoke.cont84:                                    ; preds = %invoke.cont81
  %87 = load ptr, ptr %dst_tmp79, align 8
  %GlyphsSet85 = getelementptr inbounds %struct.ImFontBuildDstData, ptr %87, i32 0, i32 3
  %Storage = getelementptr inbounds %struct.ImBitVector, ptr %GlyphsSet85, i32 0, i32 0
  %call87 = invoke noundef zeroext i1 @_ZNK8ImVectorIjE5emptyEv(ptr noundef nonnull align 8 dereferenceable(16) %Storage)
          to label %invoke.cont86 unwind label %lpad2

invoke.cont86:                                    ; preds = %invoke.cont84
  br i1 %call87, label %if.then88, label %if.end93

if.then88:                                        ; preds = %invoke.cont86
  %88 = load ptr, ptr %dst_tmp79, align 8
  %GlyphsSet89 = getelementptr inbounds %struct.ImFontBuildDstData, ptr %88, i32 0, i32 3
  %89 = load ptr, ptr %dst_tmp79, align 8
  %GlyphsHighest90 = getelementptr inbounds %struct.ImFontBuildDstData, ptr %89, i32 0, i32 1
  %90 = load i32, ptr %GlyphsHighest90, align 4
  %add91 = add nsw i32 %90, 1
  invoke void @_ZN11ImBitVector6CreateEi(ptr noundef nonnull align 8 dereferenceable(16) %GlyphsSet89, i32 noundef %add91)
          to label %invoke.cont92 unwind label %lpad2

invoke.cont92:                                    ; preds = %if.then88
  br label %if.end93

if.end93:                                         ; preds = %invoke.cont92, %invoke.cont86
  %91 = load ptr, ptr %src_tmp76, align 8
  %SrcRanges95 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %91, i32 0, i32 4
  %92 = load ptr, ptr %SrcRanges95, align 8
  store ptr %92, ptr %src_range94, align 8
  br label %for.cond96

for.cond96:                                       ; preds = %for.inc133, %if.end93
  %93 = load ptr, ptr %src_range94, align 8
  %arrayidx97 = getelementptr inbounds i16, ptr %93, i64 0
  %94 = load i16, ptr %arrayidx97, align 2
  %tobool98 = icmp ne i16 %94, 0
  br i1 %tobool98, label %land.rhs99, label %land.end102

land.rhs99:                                       ; preds = %for.cond96
  %95 = load ptr, ptr %src_range94, align 8
  %arrayidx100 = getelementptr inbounds i16, ptr %95, i64 1
  %96 = load i16, ptr %arrayidx100, align 2
  %tobool101 = icmp ne i16 %96, 0
  br label %land.end102

land.end102:                                      ; preds = %land.rhs99, %for.cond96
  %97 = phi i1 [ false, %for.cond96 ], [ %tobool101, %land.rhs99 ]
  br i1 %97, label %for.body103, label %for.end135

for.body103:                                      ; preds = %land.end102
  %98 = load ptr, ptr %src_range94, align 8
  %arrayidx104 = getelementptr inbounds i16, ptr %98, i64 0
  %99 = load i16, ptr %arrayidx104, align 2
  %conv105 = zext i16 %99 to i32
  store i32 %conv105, ptr %codepoint, align 4
  br label %for.cond106

for.cond106:                                      ; preds = %for.inc130, %for.body103
  %100 = load i32, ptr %codepoint, align 4
  %101 = load ptr, ptr %src_range94, align 8
  %arrayidx107 = getelementptr inbounds i16, ptr %101, i64 1
  %102 = load i16, ptr %arrayidx107, align 2
  %conv108 = zext i16 %102 to i32
  %cmp109 = icmp ule i32 %100, %conv108
  br i1 %cmp109, label %for.body110, label %for.end132

for.body110:                                      ; preds = %for.cond106
  %103 = load ptr, ptr %dst_tmp79, align 8
  %GlyphsSet111 = getelementptr inbounds %struct.ImFontBuildDstData, ptr %103, i32 0, i32 3
  %104 = load i32, ptr %codepoint, align 4
  %call113 = invoke noundef zeroext i1 @_ZNK11ImBitVector7TestBitEi(ptr noundef nonnull align 8 dereferenceable(16) %GlyphsSet111, i32 noundef %104)
          to label %invoke.cont112 unwind label %lpad2

invoke.cont112:                                   ; preds = %for.body110
  br i1 %call113, label %if.then114, label %if.end115

if.then114:                                       ; preds = %invoke.cont112
  br label %for.inc130

if.end115:                                        ; preds = %invoke.cont112
  %105 = load ptr, ptr %src_tmp76, align 8
  %FontInfo116 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %105, i32 0, i32 0
  %106 = load i32, ptr %codepoint, align 4
  %call118 = invoke noundef i32 @_ZL20stbtt_FindGlyphIndexPK14stbtt_fontinfoi(ptr noundef %FontInfo116, i32 noundef %106)
          to label %invoke.cont117 unwind label %lpad2

invoke.cont117:                                   ; preds = %if.end115
  %tobool119 = icmp ne i32 %call118, 0
  br i1 %tobool119, label %if.end121, label %if.then120

if.then120:                                       ; preds = %invoke.cont117
  br label %for.inc130

if.end121:                                        ; preds = %invoke.cont117
  %107 = load ptr, ptr %src_tmp76, align 8
  %GlyphsCount = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %107, i32 0, i32 7
  %108 = load i32, ptr %GlyphsCount, align 8
  %inc122 = add nsw i32 %108, 1
  store i32 %inc122, ptr %GlyphsCount, align 8
  %109 = load ptr, ptr %dst_tmp79, align 8
  %GlyphsCount123 = getelementptr inbounds %struct.ImFontBuildDstData, ptr %109, i32 0, i32 2
  %110 = load i32, ptr %GlyphsCount123, align 8
  %inc124 = add nsw i32 %110, 1
  store i32 %inc124, ptr %GlyphsCount123, align 8
  %111 = load ptr, ptr %src_tmp76, align 8
  %GlyphsSet125 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %111, i32 0, i32 8
  %112 = load i32, ptr %codepoint, align 4
  invoke void @_ZN11ImBitVector6SetBitEi(ptr noundef nonnull align 8 dereferenceable(16) %GlyphsSet125, i32 noundef %112)
          to label %invoke.cont126 unwind label %lpad2

invoke.cont126:                                   ; preds = %if.end121
  %113 = load ptr, ptr %dst_tmp79, align 8
  %GlyphsSet127 = getelementptr inbounds %struct.ImFontBuildDstData, ptr %113, i32 0, i32 3
  %114 = load i32, ptr %codepoint, align 4
  invoke void @_ZN11ImBitVector6SetBitEi(ptr noundef nonnull align 8 dereferenceable(16) %GlyphsSet127, i32 noundef %114)
          to label %invoke.cont128 unwind label %lpad2

invoke.cont128:                                   ; preds = %invoke.cont126
  %115 = load i32, ptr %total_glyphs_count, align 4
  %inc129 = add nsw i32 %115, 1
  store i32 %inc129, ptr %total_glyphs_count, align 4
  br label %for.inc130

for.inc130:                                       ; preds = %invoke.cont128, %if.then120, %if.then114
  %116 = load i32, ptr %codepoint, align 4
  %inc131 = add i32 %116, 1
  store i32 %inc131, ptr %codepoint, align 4
  br label %for.cond106, !llvm.loop !51

for.end132:                                       ; preds = %for.cond106
  br label %for.inc133

for.inc133:                                       ; preds = %for.end132
  %117 = load ptr, ptr %src_range94, align 8
  %add.ptr134 = getelementptr inbounds i16, ptr %117, i64 2
  store ptr %add.ptr134, ptr %src_range94, align 8
  br label %for.cond96, !llvm.loop !52

for.end135:                                       ; preds = %land.end102
  br label %for.inc136

for.inc136:                                       ; preds = %for.end135
  %118 = load i32, ptr %src_i71, align 4
  %inc137 = add nsw i32 %118, 1
  store i32 %inc137, ptr %src_i71, align 4
  br label %for.cond72, !llvm.loop !53

for.end138:                                       ; preds = %for.cond72
  store i32 0, ptr %src_i139, align 4
  br label %for.cond140

for.cond140:                                      ; preds = %for.inc154, %for.end138
  %119 = load i32, ptr %src_i139, align 4
  %Size141 = getelementptr inbounds %struct.ImVector.14, ptr %src_tmp_array, i32 0, i32 0
  %120 = load i32, ptr %Size141, align 8
  %cmp142 = icmp slt i32 %119, %120
  br i1 %cmp142, label %for.body143, label %for.end156

for.body143:                                      ; preds = %for.cond140
  %121 = load i32, ptr %src_i139, align 4
  %call146 = invoke noundef nonnull align 8 dereferenceable(272) ptr @_ZN8ImVectorI18ImFontBuildSrcDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %src_tmp_array, i32 noundef %121)
          to label %invoke.cont145 unwind label %lpad2

invoke.cont145:                                   ; preds = %for.body143
  store ptr %call146, ptr %src_tmp144, align 8
  %122 = load ptr, ptr %src_tmp144, align 8
  %GlyphsList = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %122, i32 0, i32 9
  %123 = load ptr, ptr %src_tmp144, align 8
  %GlyphsCount147 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %123, i32 0, i32 7
  %124 = load i32, ptr %GlyphsCount147, align 8
  invoke void @_ZN8ImVectorIiE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %GlyphsList, i32 noundef %124)
          to label %invoke.cont148 unwind label %lpad2

invoke.cont148:                                   ; preds = %invoke.cont145
  %125 = load ptr, ptr %src_tmp144, align 8
  %GlyphsSet149 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %125, i32 0, i32 8
  %126 = load ptr, ptr %src_tmp144, align 8
  %GlyphsList150 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %126, i32 0, i32 9
  invoke void @_ZL30UnpackBitVectorToFlatIndexListPK11ImBitVectorP8ImVectorIiE(ptr noundef %GlyphsSet149, ptr noundef %GlyphsList150)
          to label %invoke.cont151 unwind label %lpad2

invoke.cont151:                                   ; preds = %invoke.cont148
  %127 = load ptr, ptr %src_tmp144, align 8
  %GlyphsSet152 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %127, i32 0, i32 8
  invoke void @_ZN11ImBitVector5ClearEv(ptr noundef nonnull align 8 dereferenceable(16) %GlyphsSet152)
          to label %invoke.cont153 unwind label %lpad2

invoke.cont153:                                   ; preds = %invoke.cont151
  br label %for.inc154

for.inc154:                                       ; preds = %invoke.cont153
  %128 = load i32, ptr %src_i139, align 4
  %inc155 = add nsw i32 %128, 1
  store i32 %inc155, ptr %src_i139, align 4
  br label %for.cond140, !llvm.loop !54

for.end156:                                       ; preds = %for.cond140
  store i32 0, ptr %dst_i, align 4
  br label %for.cond157

for.cond157:                                      ; preds = %for.inc165, %for.end156
  %129 = load i32, ptr %dst_i, align 4
  %Size158 = getelementptr inbounds %struct.ImVector.15, ptr %dst_tmp_array, i32 0, i32 0
  %130 = load i32, ptr %Size158, align 8
  %cmp159 = icmp slt i32 %129, %130
  br i1 %cmp159, label %for.body160, label %for.end167

for.body160:                                      ; preds = %for.cond157
  %131 = load i32, ptr %dst_i, align 4
  %call162 = invoke noundef nonnull align 8 dereferenceable(32) ptr @_ZN8ImVectorI18ImFontBuildDstDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %dst_tmp_array, i32 noundef %131)
          to label %invoke.cont161 unwind label %lpad2

invoke.cont161:                                   ; preds = %for.body160
  %GlyphsSet163 = getelementptr inbounds %struct.ImFontBuildDstData, ptr %call162, i32 0, i32 3
  invoke void @_ZN11ImBitVector5ClearEv(ptr noundef nonnull align 8 dereferenceable(16) %GlyphsSet163)
          to label %invoke.cont164 unwind label %lpad2

invoke.cont164:                                   ; preds = %invoke.cont161
  br label %for.inc165

for.inc165:                                       ; preds = %invoke.cont164
  %132 = load i32, ptr %dst_i, align 4
  %inc166 = add nsw i32 %132, 1
  store i32 %inc166, ptr %dst_i, align 4
  br label %for.cond157, !llvm.loop !55

for.end167:                                       ; preds = %for.cond157
  invoke void @_ZN8ImVectorI18ImFontBuildDstDataE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %dst_tmp_array)
          to label %invoke.cont168 unwind label %lpad2

invoke.cont168:                                   ; preds = %for.end167
  invoke void @_ZN8ImVectorI10stbrp_rectEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %buf_rects)
          to label %invoke.cont169 unwind label %lpad2

invoke.cont169:                                   ; preds = %invoke.cont168
  invoke void @_ZN8ImVectorI16stbtt_packedcharEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %buf_packedchars)
          to label %invoke.cont171 unwind label %lpad170

invoke.cont171:                                   ; preds = %invoke.cont169
  %133 = load i32, ptr %total_glyphs_count, align 4
  invoke void @_ZN8ImVectorI10stbrp_rectE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %buf_rects, i32 noundef %133)
          to label %invoke.cont173 unwind label %lpad172

invoke.cont173:                                   ; preds = %invoke.cont171
  %134 = load i32, ptr %total_glyphs_count, align 4
  invoke void @_ZN8ImVectorI16stbtt_packedcharE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %buf_packedchars, i32 noundef %134)
          to label %invoke.cont174 unwind label %lpad172

invoke.cont174:                                   ; preds = %invoke.cont173
  %Data175 = getelementptr inbounds %struct.ImVector.12, ptr %buf_rects, i32 0, i32 2
  %135 = load ptr, ptr %Data175, align 8
  %call177 = invoke noundef i32 @_ZNK8ImVectorI10stbrp_rectE13size_in_bytesEv(ptr noundef nonnull align 8 dereferenceable(16) %buf_rects)
          to label %invoke.cont176 unwind label %lpad172

invoke.cont176:                                   ; preds = %invoke.cont174
  %conv178 = sext i32 %call177 to i64
  call void @llvm.memset.p0.i64(ptr align 4 %135, i8 0, i64 %conv178, i1 false)
  %Data179 = getelementptr inbounds %struct.ImVector.17, ptr %buf_packedchars, i32 0, i32 2
  %136 = load ptr, ptr %Data179, align 8
  %call181 = invoke noundef i32 @_ZNK8ImVectorI16stbtt_packedcharE13size_in_bytesEv(ptr noundef nonnull align 8 dereferenceable(16) %buf_packedchars)
          to label %invoke.cont180 unwind label %lpad172

invoke.cont180:                                   ; preds = %invoke.cont176
  %conv182 = sext i32 %call181 to i64
  call void @llvm.memset.p0.i64(ptr align 4 %136, i8 0, i64 %conv182, i1 false)
  store i32 0, ptr %total_surface, align 4
  store i32 0, ptr %buf_rects_out_n, align 4
  store i32 0, ptr %buf_packedchars_out_n, align 4
  store i32 0, ptr %src_i183, align 4
  br label %for.cond184

for.cond184:                                      ; preds = %for.inc284, %invoke.cont180
  %137 = load i32, ptr %src_i183, align 4
  %Size185 = getelementptr inbounds %struct.ImVector.14, ptr %src_tmp_array, i32 0, i32 0
  %138 = load i32, ptr %Size185, align 8
  %cmp186 = icmp slt i32 %137, %138
  br i1 %cmp186, label %for.body187, label %for.end286

for.body187:                                      ; preds = %for.cond184
  %139 = load i32, ptr %src_i183, align 4
  %call190 = invoke noundef nonnull align 8 dereferenceable(272) ptr @_ZN8ImVectorI18ImFontBuildSrcDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %src_tmp_array, i32 noundef %139)
          to label %invoke.cont189 unwind label %lpad172

invoke.cont189:                                   ; preds = %for.body187
  store ptr %call190, ptr %src_tmp188, align 8
  %140 = load ptr, ptr %src_tmp188, align 8
  %GlyphsCount191 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %140, i32 0, i32 7
  %141 = load i32, ptr %GlyphsCount191, align 8
  %cmp192 = icmp eq i32 %141, 0
  br i1 %cmp192, label %if.then193, label %if.end194

if.then193:                                       ; preds = %invoke.cont189
  br label %for.inc284

lpad170:                                          ; preds = %invoke.cont169
  %142 = landingpad { ptr, i32 }
          cleanup
  %143 = extractvalue { ptr, i32 } %142, 0
  store ptr %143, ptr %exn.slot, align 8
  %144 = extractvalue { ptr, i32 } %142, 1
  store i32 %144, ptr %ehselector.slot, align 4
  br label %ehcleanup

lpad172:                                          ; preds = %invoke.cont530, %for.end529, %invoke.cont508, %invoke.cont500, %for.body497, %invoke.cont481, %invoke.cont473, %invoke.cont466, %invoke.cont463, %invoke.cont458, %invoke.cont454, %for.body452, %invoke.cont446, %for.end445, %if.end411, %invoke.cont403, %for.body400, %invoke.cont381, %cond.end372, %cond.false368, %if.then344, %if.end329, %for.body322, %invoke.cont315, %if.end312, %invoke.cont247, %invoke.cont245, %for.body242, %cond.false229, %cond.true222, %invoke.cont197, %invoke.cont195, %if.end194, %for.body187, %invoke.cont176, %invoke.cont174, %invoke.cont173, %invoke.cont171
  %145 = landingpad { ptr, i32 }
          cleanup
  %146 = extractvalue { ptr, i32 } %145, 0
  store ptr %146, ptr %exn.slot, align 8
  %147 = extractvalue { ptr, i32 } %145, 1
  store i32 %147, ptr %ehselector.slot, align 4
  call void @_ZN8ImVectorI16stbtt_packedcharED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %buf_packedchars) #12
  br label %ehcleanup

if.end194:                                        ; preds = %invoke.cont189
  %148 = load i32, ptr %buf_rects_out_n, align 4
  %call196 = invoke noundef nonnull align 4 dereferenceable(24) ptr @_ZN8ImVectorI10stbrp_rectEixEi(ptr noundef nonnull align 8 dereferenceable(16) %buf_rects, i32 noundef %148)
          to label %invoke.cont195 unwind label %lpad172

invoke.cont195:                                   ; preds = %if.end194
  %149 = load ptr, ptr %src_tmp188, align 8
  %Rects = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %149, i32 0, i32 2
  store ptr %call196, ptr %Rects, align 8
  %150 = load i32, ptr %buf_packedchars_out_n, align 4
  %call198 = invoke noundef nonnull align 4 dereferenceable(28) ptr @_ZN8ImVectorI16stbtt_packedcharEixEi(ptr noundef nonnull align 8 dereferenceable(16) %buf_packedchars, i32 noundef %150)
          to label %invoke.cont197 unwind label %lpad172

invoke.cont197:                                   ; preds = %invoke.cont195
  %151 = load ptr, ptr %src_tmp188, align 8
  %PackedChars = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %151, i32 0, i32 3
  store ptr %call198, ptr %PackedChars, align 8
  %152 = load ptr, ptr %src_tmp188, align 8
  %GlyphsCount199 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %152, i32 0, i32 7
  %153 = load i32, ptr %GlyphsCount199, align 8
  %154 = load i32, ptr %buf_rects_out_n, align 4
  %add200 = add nsw i32 %154, %153
  store i32 %add200, ptr %buf_rects_out_n, align 4
  %155 = load ptr, ptr %src_tmp188, align 8
  %GlyphsCount201 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %155, i32 0, i32 7
  %156 = load i32, ptr %GlyphsCount201, align 8
  %157 = load i32, ptr %buf_packedchars_out_n, align 4
  %add202 = add nsw i32 %157, %156
  store i32 %add202, ptr %buf_packedchars_out_n, align 4
  %158 = load ptr, ptr %atlas.addr, align 8
  %ConfigData204 = getelementptr inbounds %struct.ImFontAtlas, ptr %158, i32 0, i32 19
  %159 = load i32, ptr %src_i183, align 4
  %call206 = invoke noundef nonnull align 8 dereferenceable(144) ptr @_ZN8ImVectorI12ImFontConfigEixEi(ptr noundef nonnull align 8 dereferenceable(16) %ConfigData204, i32 noundef %159)
          to label %invoke.cont205 unwind label %lpad172

invoke.cont205:                                   ; preds = %invoke.cont197
  store ptr %call206, ptr %cfg203, align 8
  %160 = load ptr, ptr %cfg203, align 8
  %SizePixels = getelementptr inbounds %struct.ImFontConfig, ptr %160, i32 0, i32 4
  %161 = load float, ptr %SizePixels, align 4
  %162 = load ptr, ptr %cfg203, align 8
  %RasterizerDensity = getelementptr inbounds %struct.ImFontConfig, ptr %162, i32 0, i32 16
  %163 = load float, ptr %RasterizerDensity, align 4
  %mul = fmul float %161, %163
  %164 = load ptr, ptr %src_tmp188, align 8
  %PackRange = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %164, i32 0, i32 1
  %font_size = getelementptr inbounds %struct.stbtt_pack_range, ptr %PackRange, i32 0, i32 0
  store float %mul, ptr %font_size, align 8
  %165 = load ptr, ptr %src_tmp188, align 8
  %PackRange207 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %165, i32 0, i32 1
  %first_unicode_codepoint_in_range = getelementptr inbounds %struct.stbtt_pack_range, ptr %PackRange207, i32 0, i32 1
  store i32 0, ptr %first_unicode_codepoint_in_range, align 4
  %166 = load ptr, ptr %src_tmp188, align 8
  %GlyphsList208 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %166, i32 0, i32 9
  %Data209 = getelementptr inbounds %struct.ImVector.16, ptr %GlyphsList208, i32 0, i32 2
  %167 = load ptr, ptr %Data209, align 8
  %168 = load ptr, ptr %src_tmp188, align 8
  %PackRange210 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %168, i32 0, i32 1
  %array_of_unicode_codepoints = getelementptr inbounds %struct.stbtt_pack_range, ptr %PackRange210, i32 0, i32 2
  store ptr %167, ptr %array_of_unicode_codepoints, align 8
  %169 = load ptr, ptr %src_tmp188, align 8
  %GlyphsList211 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %169, i32 0, i32 9
  %Size212 = getelementptr inbounds %struct.ImVector.16, ptr %GlyphsList211, i32 0, i32 0
  %170 = load i32, ptr %Size212, align 8
  %171 = load ptr, ptr %src_tmp188, align 8
  %PackRange213 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %171, i32 0, i32 1
  %num_chars = getelementptr inbounds %struct.stbtt_pack_range, ptr %PackRange213, i32 0, i32 3
  store i32 %170, ptr %num_chars, align 8
  %172 = load ptr, ptr %src_tmp188, align 8
  %PackedChars214 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %172, i32 0, i32 3
  %173 = load ptr, ptr %PackedChars214, align 8
  %174 = load ptr, ptr %src_tmp188, align 8
  %PackRange215 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %174, i32 0, i32 1
  %chardata_for_range = getelementptr inbounds %struct.stbtt_pack_range, ptr %PackRange215, i32 0, i32 4
  store ptr %173, ptr %chardata_for_range, align 8
  %175 = load ptr, ptr %cfg203, align 8
  %OversampleH = getelementptr inbounds %struct.ImFontConfig, ptr %175, i32 0, i32 5
  %176 = load i32, ptr %OversampleH, align 8
  %conv216 = trunc i32 %176 to i8
  %177 = load ptr, ptr %src_tmp188, align 8
  %PackRange217 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %177, i32 0, i32 1
  %h_oversample = getelementptr inbounds %struct.stbtt_pack_range, ptr %PackRange217, i32 0, i32 5
  store i8 %conv216, ptr %h_oversample, align 8
  %178 = load ptr, ptr %cfg203, align 8
  %OversampleV = getelementptr inbounds %struct.ImFontConfig, ptr %178, i32 0, i32 6
  %179 = load i32, ptr %OversampleV, align 4
  %conv218 = trunc i32 %179 to i8
  %180 = load ptr, ptr %src_tmp188, align 8
  %PackRange219 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %180, i32 0, i32 1
  %v_oversample = getelementptr inbounds %struct.stbtt_pack_range, ptr %PackRange219, i32 0, i32 6
  store i8 %conv218, ptr %v_oversample, align 1
  %181 = load ptr, ptr %cfg203, align 8
  %SizePixels220 = getelementptr inbounds %struct.ImFontConfig, ptr %181, i32 0, i32 4
  %182 = load float, ptr %SizePixels220, align 4
  %cmp221 = fcmp ogt float %182, 0.000000e+00
  br i1 %cmp221, label %cond.true222, label %cond.false229

cond.true222:                                     ; preds = %invoke.cont205
  %183 = load ptr, ptr %src_tmp188, align 8
  %FontInfo223 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %183, i32 0, i32 0
  %184 = load ptr, ptr %cfg203, align 8
  %SizePixels224 = getelementptr inbounds %struct.ImFontConfig, ptr %184, i32 0, i32 4
  %185 = load float, ptr %SizePixels224, align 4
  %186 = load ptr, ptr %cfg203, align 8
  %RasterizerDensity225 = getelementptr inbounds %struct.ImFontConfig, ptr %186, i32 0, i32 16
  %187 = load float, ptr %RasterizerDensity225, align 4
  %mul226 = fmul float %185, %187
  %call228 = invoke noundef float @_ZL25stbtt_ScaleForPixelHeightPK14stbtt_fontinfof(ptr noundef %FontInfo223, float noundef %mul226)
          to label %invoke.cont227 unwind label %lpad172

invoke.cont227:                                   ; preds = %cond.true222
  br label %cond.end236

cond.false229:                                    ; preds = %invoke.cont205
  %188 = load ptr, ptr %src_tmp188, align 8
  %FontInfo230 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %188, i32 0, i32 0
  %189 = load ptr, ptr %cfg203, align 8
  %SizePixels231 = getelementptr inbounds %struct.ImFontConfig, ptr %189, i32 0, i32 4
  %190 = load float, ptr %SizePixels231, align 4
  %fneg = fneg float %190
  %191 = load ptr, ptr %cfg203, align 8
  %RasterizerDensity232 = getelementptr inbounds %struct.ImFontConfig, ptr %191, i32 0, i32 16
  %192 = load float, ptr %RasterizerDensity232, align 4
  %mul233 = fmul float %fneg, %192
  %call235 = invoke noundef float @_ZL31stbtt_ScaleForMappingEmToPixelsPK14stbtt_fontinfof(ptr noundef %FontInfo230, float noundef %mul233)
          to label %invoke.cont234 unwind label %lpad172

invoke.cont234:                                   ; preds = %cond.false229
  br label %cond.end236

cond.end236:                                      ; preds = %invoke.cont234, %invoke.cont227
  %cond237 = phi float [ %call228, %invoke.cont227 ], [ %call235, %invoke.cont234 ]
  store float %cond237, ptr %scale, align 4
  %193 = load ptr, ptr %atlas.addr, align 8
  %TexGlyphPadding = getelementptr inbounds %struct.ImFontAtlas, ptr %193, i32 0, i32 4
  %194 = load i32, ptr %TexGlyphPadding, align 4
  store i32 %194, ptr %padding, align 4
  store i32 0, ptr %glyph_i, align 4
  br label %for.cond238

for.cond238:                                      ; preds = %for.inc281, %cond.end236
  %195 = load i32, ptr %glyph_i, align 4
  %196 = load ptr, ptr %src_tmp188, align 8
  %GlyphsList239 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %196, i32 0, i32 9
  %Size240 = getelementptr inbounds %struct.ImVector.16, ptr %GlyphsList239, i32 0, i32 0
  %197 = load i32, ptr %Size240, align 8
  %cmp241 = icmp slt i32 %195, %197
  br i1 %cmp241, label %for.body242, label %for.end283

for.body242:                                      ; preds = %for.cond238
  %198 = load ptr, ptr %src_tmp188, align 8
  %FontInfo243 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %198, i32 0, i32 0
  %199 = load ptr, ptr %src_tmp188, align 8
  %GlyphsList244 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %199, i32 0, i32 9
  %200 = load i32, ptr %glyph_i, align 4
  %call246 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN8ImVectorIiEixEi(ptr noundef nonnull align 8 dereferenceable(16) %GlyphsList244, i32 noundef %200)
          to label %invoke.cont245 unwind label %lpad172

invoke.cont245:                                   ; preds = %for.body242
  %201 = load i32, ptr %call246, align 4
  %call248 = invoke noundef i32 @_ZL20stbtt_FindGlyphIndexPK14stbtt_fontinfoi(ptr noundef %FontInfo243, i32 noundef %201)
          to label %invoke.cont247 unwind label %lpad172

invoke.cont247:                                   ; preds = %invoke.cont245
  store i32 %call248, ptr %glyph_index_in_font, align 4
  %202 = load ptr, ptr %src_tmp188, align 8
  %FontInfo249 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %202, i32 0, i32 0
  %203 = load i32, ptr %glyph_index_in_font, align 4
  %204 = load float, ptr %scale, align 4
  %205 = load ptr, ptr %cfg203, align 8
  %OversampleH250 = getelementptr inbounds %struct.ImFontConfig, ptr %205, i32 0, i32 5
  %206 = load i32, ptr %OversampleH250, align 8
  %conv251 = sitofp i32 %206 to float
  %mul252 = fmul float %204, %conv251
  %207 = load float, ptr %scale, align 4
  %208 = load ptr, ptr %cfg203, align 8
  %OversampleV253 = getelementptr inbounds %struct.ImFontConfig, ptr %208, i32 0, i32 6
  %209 = load i32, ptr %OversampleV253, align 4
  %conv254 = sitofp i32 %209 to float
  %mul255 = fmul float %207, %conv254
  invoke void @_ZL31stbtt_GetGlyphBitmapBoxSubpixelPK14stbtt_fontinfoiffffPiS2_S2_S2_(ptr noundef %FontInfo249, i32 noundef %203, float noundef %mul252, float noundef %mul255, float noundef 0.000000e+00, float noundef 0.000000e+00, ptr noundef %x0, ptr noundef %y0, ptr noundef %x1, ptr noundef %y1)
          to label %invoke.cont256 unwind label %lpad172

invoke.cont256:                                   ; preds = %invoke.cont247
  %210 = load i32, ptr %x1, align 4
  %211 = load i32, ptr %x0, align 4
  %sub = sub nsw i32 %210, %211
  %212 = load i32, ptr %padding, align 4
  %add257 = add nsw i32 %sub, %212
  %213 = load ptr, ptr %cfg203, align 8
  %OversampleH258 = getelementptr inbounds %struct.ImFontConfig, ptr %213, i32 0, i32 5
  %214 = load i32, ptr %OversampleH258, align 8
  %add259 = add nsw i32 %add257, %214
  %sub260 = sub nsw i32 %add259, 1
  %215 = load ptr, ptr %src_tmp188, align 8
  %Rects261 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %215, i32 0, i32 2
  %216 = load ptr, ptr %Rects261, align 8
  %217 = load i32, ptr %glyph_i, align 4
  %idxprom = sext i32 %217 to i64
  %arrayidx262 = getelementptr inbounds %struct.stbrp_rect, ptr %216, i64 %idxprom
  %w = getelementptr inbounds %struct.stbrp_rect, ptr %arrayidx262, i32 0, i32 1
  store i32 %sub260, ptr %w, align 4
  %218 = load i32, ptr %y1, align 4
  %219 = load i32, ptr %y0, align 4
  %sub263 = sub nsw i32 %218, %219
  %220 = load i32, ptr %padding, align 4
  %add264 = add nsw i32 %sub263, %220
  %221 = load ptr, ptr %cfg203, align 8
  %OversampleV265 = getelementptr inbounds %struct.ImFontConfig, ptr %221, i32 0, i32 6
  %222 = load i32, ptr %OversampleV265, align 4
  %add266 = add nsw i32 %add264, %222
  %sub267 = sub nsw i32 %add266, 1
  %223 = load ptr, ptr %src_tmp188, align 8
  %Rects268 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %223, i32 0, i32 2
  %224 = load ptr, ptr %Rects268, align 8
  %225 = load i32, ptr %glyph_i, align 4
  %idxprom269 = sext i32 %225 to i64
  %arrayidx270 = getelementptr inbounds %struct.stbrp_rect, ptr %224, i64 %idxprom269
  %h = getelementptr inbounds %struct.stbrp_rect, ptr %arrayidx270, i32 0, i32 2
  store i32 %sub267, ptr %h, align 4
  %226 = load ptr, ptr %src_tmp188, align 8
  %Rects271 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %226, i32 0, i32 2
  %227 = load ptr, ptr %Rects271, align 8
  %228 = load i32, ptr %glyph_i, align 4
  %idxprom272 = sext i32 %228 to i64
  %arrayidx273 = getelementptr inbounds %struct.stbrp_rect, ptr %227, i64 %idxprom272
  %w274 = getelementptr inbounds %struct.stbrp_rect, ptr %arrayidx273, i32 0, i32 1
  %229 = load i32, ptr %w274, align 4
  %230 = load ptr, ptr %src_tmp188, align 8
  %Rects275 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %230, i32 0, i32 2
  %231 = load ptr, ptr %Rects275, align 8
  %232 = load i32, ptr %glyph_i, align 4
  %idxprom276 = sext i32 %232 to i64
  %arrayidx277 = getelementptr inbounds %struct.stbrp_rect, ptr %231, i64 %idxprom276
  %h278 = getelementptr inbounds %struct.stbrp_rect, ptr %arrayidx277, i32 0, i32 2
  %233 = load i32, ptr %h278, align 4
  %mul279 = mul nsw i32 %229, %233
  %234 = load i32, ptr %total_surface, align 4
  %add280 = add nsw i32 %234, %mul279
  store i32 %add280, ptr %total_surface, align 4
  br label %for.inc281

for.inc281:                                       ; preds = %invoke.cont256
  %235 = load i32, ptr %glyph_i, align 4
  %inc282 = add nsw i32 %235, 1
  store i32 %inc282, ptr %glyph_i, align 4
  br label %for.cond238, !llvm.loop !56

for.end283:                                       ; preds = %for.cond238
  br label %for.inc284

for.inc284:                                       ; preds = %for.end283, %if.then193
  %236 = load i32, ptr %src_i183, align 4
  %inc285 = add nsw i32 %236, 1
  store i32 %inc285, ptr %src_i183, align 4
  br label %for.cond184, !llvm.loop !57

for.end286:                                       ; preds = %for.cond184
  %237 = load i32, ptr %total_surface, align 4
  %conv287 = sitofp i32 %237 to float
  %call288 = call float @sqrtf(float noundef %conv287) #12
  %conv289 = fptosi float %call288 to i32
  %add290 = add nsw i32 %conv289, 1
  store i32 %add290, ptr %surface_sqrt, align 4
  %238 = load ptr, ptr %atlas.addr, align 8
  %TexHeight291 = getelementptr inbounds %struct.ImFontAtlas, ptr %238, i32 0, i32 14
  store i32 0, ptr %TexHeight291, align 4
  %239 = load ptr, ptr %atlas.addr, align 8
  %TexDesiredWidth = getelementptr inbounds %struct.ImFontAtlas, ptr %239, i32 0, i32 3
  %240 = load i32, ptr %TexDesiredWidth, align 8
  %cmp292 = icmp sgt i32 %240, 0
  br i1 %cmp292, label %if.then293, label %if.else

if.then293:                                       ; preds = %for.end286
  %241 = load ptr, ptr %atlas.addr, align 8
  %TexDesiredWidth294 = getelementptr inbounds %struct.ImFontAtlas, ptr %241, i32 0, i32 3
  %242 = load i32, ptr %TexDesiredWidth294, align 8
  %243 = load ptr, ptr %atlas.addr, align 8
  %TexWidth295 = getelementptr inbounds %struct.ImFontAtlas, ptr %243, i32 0, i32 13
  store i32 %242, ptr %TexWidth295, align 8
  br label %if.end312

if.else:                                          ; preds = %for.end286
  %244 = load i32, ptr %surface_sqrt, align 4
  %conv296 = sitofp i32 %244 to float
  %cmp297 = fcmp oge float %conv296, 0x40A6666660000000
  br i1 %cmp297, label %cond.true298, label %cond.false299

cond.true298:                                     ; preds = %if.else
  br label %cond.end309

cond.false299:                                    ; preds = %if.else
  %245 = load i32, ptr %surface_sqrt, align 4
  %conv300 = sitofp i32 %245 to float
  %cmp301 = fcmp oge float %conv300, 0x4096666660000000
  br i1 %cmp301, label %cond.true302, label %cond.false303

cond.true302:                                     ; preds = %cond.false299
  br label %cond.end307

cond.false303:                                    ; preds = %cond.false299
  %246 = load i32, ptr %surface_sqrt, align 4
  %conv304 = sitofp i32 %246 to float
  %cmp305 = fcmp oge float %conv304, 0x4086666660000000
  %cond306 = select i1 %cmp305, i32 1024, i32 512
  br label %cond.end307

cond.end307:                                      ; preds = %cond.false303, %cond.true302
  %cond308 = phi i32 [ 2048, %cond.true302 ], [ %cond306, %cond.false303 ]
  br label %cond.end309

cond.end309:                                      ; preds = %cond.end307, %cond.true298
  %cond310 = phi i32 [ 4096, %cond.true298 ], [ %cond308, %cond.end307 ]
  %247 = load ptr, ptr %atlas.addr, align 8
  %TexWidth311 = getelementptr inbounds %struct.ImFontAtlas, ptr %247, i32 0, i32 13
  store i32 %cond310, ptr %TexWidth311, align 8
  br label %if.end312

if.end312:                                        ; preds = %cond.end309, %if.then293
  store i32 32768, ptr %TEX_HEIGHT_MAX, align 4
  call void @llvm.memset.p0.i64(ptr align 8 %spc, i8 0, i64 64, i1 false)
  %248 = load ptr, ptr %atlas.addr, align 8
  %TexWidth313 = getelementptr inbounds %struct.ImFontAtlas, ptr %248, i32 0, i32 13
  %249 = load i32, ptr %TexWidth313, align 8
  %250 = load ptr, ptr %atlas.addr, align 8
  %TexGlyphPadding314 = getelementptr inbounds %struct.ImFontAtlas, ptr %250, i32 0, i32 4
  %251 = load i32, ptr %TexGlyphPadding314, align 4
  %call316 = invoke noundef i32 @_ZL15stbtt_PackBeginP18stbtt_pack_contextPhiiiiPv(ptr noundef %spc, ptr noundef null, i32 noundef %249, i32 noundef 32768, i32 noundef 0, i32 noundef %251, ptr noundef null)
          to label %invoke.cont315 unwind label %lpad172

invoke.cont315:                                   ; preds = %if.end312
  %252 = load ptr, ptr %atlas.addr, align 8
  %pack_info = getelementptr inbounds %struct.stbtt_pack_context, ptr %spc, i32 0, i32 1
  %253 = load ptr, ptr %pack_info, align 8
  invoke void @_Z31ImFontAtlasBuildPackCustomRectsP11ImFontAtlasPv(ptr noundef %252, ptr noundef %253)
          to label %invoke.cont317 unwind label %lpad172

invoke.cont317:                                   ; preds = %invoke.cont315
  store i32 0, ptr %src_i318, align 4
  br label %for.cond319

for.cond319:                                      ; preds = %for.inc361, %invoke.cont317
  %254 = load i32, ptr %src_i318, align 4
  %Size320 = getelementptr inbounds %struct.ImVector.14, ptr %src_tmp_array, i32 0, i32 0
  %255 = load i32, ptr %Size320, align 8
  %cmp321 = icmp slt i32 %254, %255
  br i1 %cmp321, label %for.body322, label %for.end363

for.body322:                                      ; preds = %for.cond319
  %256 = load i32, ptr %src_i318, align 4
  %call325 = invoke noundef nonnull align 8 dereferenceable(272) ptr @_ZN8ImVectorI18ImFontBuildSrcDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %src_tmp_array, i32 noundef %256)
          to label %invoke.cont324 unwind label %lpad172

invoke.cont324:                                   ; preds = %for.body322
  store ptr %call325, ptr %src_tmp323, align 8
  %257 = load ptr, ptr %src_tmp323, align 8
  %GlyphsCount326 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %257, i32 0, i32 7
  %258 = load i32, ptr %GlyphsCount326, align 8
  %cmp327 = icmp eq i32 %258, 0
  br i1 %cmp327, label %if.then328, label %if.end329

if.then328:                                       ; preds = %invoke.cont324
  br label %for.inc361

if.end329:                                        ; preds = %invoke.cont324
  %pack_info330 = getelementptr inbounds %struct.stbtt_pack_context, ptr %spc, i32 0, i32 1
  %259 = load ptr, ptr %pack_info330, align 8
  %260 = load ptr, ptr %src_tmp323, align 8
  %Rects331 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %260, i32 0, i32 2
  %261 = load ptr, ptr %Rects331, align 8
  %262 = load ptr, ptr %src_tmp323, align 8
  %GlyphsCount332 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %262, i32 0, i32 7
  %263 = load i32, ptr %GlyphsCount332, align 8
  %call334 = invoke noundef i32 @_ZL16stbrp_pack_rectsP13stbrp_contextP10stbrp_recti(ptr noundef %259, ptr noundef %261, i32 noundef %263)
          to label %invoke.cont333 unwind label %lpad172

invoke.cont333:                                   ; preds = %if.end329
  store i32 0, ptr %glyph_i335, align 4
  br label %for.cond336

for.cond336:                                      ; preds = %for.inc358, %invoke.cont333
  %264 = load i32, ptr %glyph_i335, align 4
  %265 = load ptr, ptr %src_tmp323, align 8
  %GlyphsCount337 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %265, i32 0, i32 7
  %266 = load i32, ptr %GlyphsCount337, align 8
  %cmp338 = icmp slt i32 %264, %266
  br i1 %cmp338, label %for.body339, label %for.end360

for.body339:                                      ; preds = %for.cond336
  %267 = load ptr, ptr %src_tmp323, align 8
  %Rects340 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %267, i32 0, i32 2
  %268 = load ptr, ptr %Rects340, align 8
  %269 = load i32, ptr %glyph_i335, align 4
  %idxprom341 = sext i32 %269 to i64
  %arrayidx342 = getelementptr inbounds %struct.stbrp_rect, ptr %268, i64 %idxprom341
  %was_packed = getelementptr inbounds %struct.stbrp_rect, ptr %arrayidx342, i32 0, i32 5
  %270 = load i32, ptr %was_packed, align 4
  %tobool343 = icmp ne i32 %270, 0
  br i1 %tobool343, label %if.then344, label %if.end357

if.then344:                                       ; preds = %for.body339
  %271 = load ptr, ptr %atlas.addr, align 8
  %TexHeight345 = getelementptr inbounds %struct.ImFontAtlas, ptr %271, i32 0, i32 14
  %272 = load i32, ptr %TexHeight345, align 4
  %273 = load ptr, ptr %src_tmp323, align 8
  %Rects346 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %273, i32 0, i32 2
  %274 = load ptr, ptr %Rects346, align 8
  %275 = load i32, ptr %glyph_i335, align 4
  %idxprom347 = sext i32 %275 to i64
  %arrayidx348 = getelementptr inbounds %struct.stbrp_rect, ptr %274, i64 %idxprom347
  %y = getelementptr inbounds %struct.stbrp_rect, ptr %arrayidx348, i32 0, i32 4
  %276 = load i32, ptr %y, align 4
  %277 = load ptr, ptr %src_tmp323, align 8
  %Rects349 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %277, i32 0, i32 2
  %278 = load ptr, ptr %Rects349, align 8
  %279 = load i32, ptr %glyph_i335, align 4
  %idxprom350 = sext i32 %279 to i64
  %arrayidx351 = getelementptr inbounds %struct.stbrp_rect, ptr %278, i64 %idxprom350
  %h352 = getelementptr inbounds %struct.stbrp_rect, ptr %arrayidx351, i32 0, i32 2
  %280 = load i32, ptr %h352, align 4
  %add353 = add nsw i32 %276, %280
  %call355 = invoke noundef i32 @_ZL5ImMaxIiET_S0_S0_(i32 noundef %272, i32 noundef %add353)
          to label %invoke.cont354 unwind label %lpad172

invoke.cont354:                                   ; preds = %if.then344
  %281 = load ptr, ptr %atlas.addr, align 8
  %TexHeight356 = getelementptr inbounds %struct.ImFontAtlas, ptr %281, i32 0, i32 14
  store i32 %call355, ptr %TexHeight356, align 4
  br label %if.end357

if.end357:                                        ; preds = %invoke.cont354, %for.body339
  br label %for.inc358

for.inc358:                                       ; preds = %if.end357
  %282 = load i32, ptr %glyph_i335, align 4
  %inc359 = add nsw i32 %282, 1
  store i32 %inc359, ptr %glyph_i335, align 4
  br label %for.cond336, !llvm.loop !58

for.end360:                                       ; preds = %for.cond336
  br label %for.inc361

for.inc361:                                       ; preds = %for.end360, %if.then328
  %283 = load i32, ptr %src_i318, align 4
  %inc362 = add nsw i32 %283, 1
  store i32 %inc362, ptr %src_i318, align 4
  br label %for.cond319, !llvm.loop !59

for.end363:                                       ; preds = %for.cond319
  %284 = load ptr, ptr %atlas.addr, align 8
  %Flags = getelementptr inbounds %struct.ImFontAtlas, ptr %284, i32 0, i32 0
  %285 = load i32, ptr %Flags, align 8
  %and = and i32 %285, 1
  %tobool364 = icmp ne i32 %and, 0
  br i1 %tobool364, label %cond.true365, label %cond.false368

cond.true365:                                     ; preds = %for.end363
  %286 = load ptr, ptr %atlas.addr, align 8
  %TexHeight366 = getelementptr inbounds %struct.ImFontAtlas, ptr %286, i32 0, i32 14
  %287 = load i32, ptr %TexHeight366, align 4
  %add367 = add nsw i32 %287, 1
  br label %cond.end372

cond.false368:                                    ; preds = %for.end363
  %288 = load ptr, ptr %atlas.addr, align 8
  %TexHeight369 = getelementptr inbounds %struct.ImFontAtlas, ptr %288, i32 0, i32 14
  %289 = load i32, ptr %TexHeight369, align 4
  %call371 = invoke noundef i32 @_ZL17ImUpperPowerOfTwoi(i32 noundef %289)
          to label %invoke.cont370 unwind label %lpad172

invoke.cont370:                                   ; preds = %cond.false368
  br label %cond.end372

cond.end372:                                      ; preds = %invoke.cont370, %cond.true365
  %cond373 = phi i32 [ %add367, %cond.true365 ], [ %call371, %invoke.cont370 ]
  %290 = load ptr, ptr %atlas.addr, align 8
  %TexHeight374 = getelementptr inbounds %struct.ImFontAtlas, ptr %290, i32 0, i32 14
  store i32 %cond373, ptr %TexHeight374, align 4
  %291 = load ptr, ptr %atlas.addr, align 8
  %TexWidth376 = getelementptr inbounds %struct.ImFontAtlas, ptr %291, i32 0, i32 13
  %292 = load i32, ptr %TexWidth376, align 8
  %conv377 = sitofp i32 %292 to float
  %div = fdiv float 1.000000e+00, %conv377
  %293 = load ptr, ptr %atlas.addr, align 8
  %TexHeight378 = getelementptr inbounds %struct.ImFontAtlas, ptr %293, i32 0, i32 14
  %294 = load i32, ptr %TexHeight378, align 4
  %conv379 = sitofp i32 %294 to float
  %div380 = fdiv float 1.000000e+00, %conv379
  invoke void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp375, float noundef %div, float noundef %div380)
          to label %invoke.cont381 unwind label %lpad172

invoke.cont381:                                   ; preds = %cond.end372
  %295 = load ptr, ptr %atlas.addr, align 8
  %TexUvScale382 = getelementptr inbounds %struct.ImFontAtlas, ptr %295, i32 0, i32 15
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %TexUvScale382, ptr align 4 %ref.tmp375, i64 8, i1 false)
  %296 = load ptr, ptr %atlas.addr, align 8
  %TexWidth383 = getelementptr inbounds %struct.ImFontAtlas, ptr %296, i32 0, i32 13
  %297 = load i32, ptr %TexWidth383, align 8
  %298 = load ptr, ptr %atlas.addr, align 8
  %TexHeight384 = getelementptr inbounds %struct.ImFontAtlas, ptr %298, i32 0, i32 14
  %299 = load i32, ptr %TexHeight384, align 4
  %mul385 = mul nsw i32 %297, %299
  %conv386 = sext i32 %mul385 to i64
  %call388 = invoke noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %conv386)
          to label %invoke.cont387 unwind label %lpad172

invoke.cont387:                                   ; preds = %invoke.cont381
  %300 = load ptr, ptr %atlas.addr, align 8
  %TexPixelsAlpha8 = getelementptr inbounds %struct.ImFontAtlas, ptr %300, i32 0, i32 11
  store ptr %call388, ptr %TexPixelsAlpha8, align 8
  %301 = load ptr, ptr %atlas.addr, align 8
  %TexPixelsAlpha8389 = getelementptr inbounds %struct.ImFontAtlas, ptr %301, i32 0, i32 11
  %302 = load ptr, ptr %TexPixelsAlpha8389, align 8
  %303 = load ptr, ptr %atlas.addr, align 8
  %TexWidth390 = getelementptr inbounds %struct.ImFontAtlas, ptr %303, i32 0, i32 13
  %304 = load i32, ptr %TexWidth390, align 8
  %305 = load ptr, ptr %atlas.addr, align 8
  %TexHeight391 = getelementptr inbounds %struct.ImFontAtlas, ptr %305, i32 0, i32 14
  %306 = load i32, ptr %TexHeight391, align 4
  %mul392 = mul nsw i32 %304, %306
  %conv393 = sext i32 %mul392 to i64
  call void @llvm.memset.p0.i64(ptr align 1 %302, i8 0, i64 %conv393, i1 false)
  %307 = load ptr, ptr %atlas.addr, align 8
  %TexPixelsAlpha8394 = getelementptr inbounds %struct.ImFontAtlas, ptr %307, i32 0, i32 11
  %308 = load ptr, ptr %TexPixelsAlpha8394, align 8
  %pixels = getelementptr inbounds %struct.stbtt_pack_context, ptr %spc, i32 0, i32 9
  store ptr %308, ptr %pixels, align 8
  %309 = load ptr, ptr %atlas.addr, align 8
  %TexHeight395 = getelementptr inbounds %struct.ImFontAtlas, ptr %309, i32 0, i32 14
  %310 = load i32, ptr %TexHeight395, align 4
  %height = getelementptr inbounds %struct.stbtt_pack_context, ptr %spc, i32 0, i32 3
  store i32 %310, ptr %height, align 4
  store i32 0, ptr %src_i396, align 4
  br label %for.cond397

for.cond397:                                      ; preds = %for.inc443, %invoke.cont387
  %311 = load i32, ptr %src_i396, align 4
  %Size398 = getelementptr inbounds %struct.ImVector.14, ptr %src_tmp_array, i32 0, i32 0
  %312 = load i32, ptr %Size398, align 8
  %cmp399 = icmp slt i32 %311, %312
  br i1 %cmp399, label %for.body400, label %for.end445

for.body400:                                      ; preds = %for.cond397
  %313 = load ptr, ptr %atlas.addr, align 8
  %ConfigData402 = getelementptr inbounds %struct.ImFontAtlas, ptr %313, i32 0, i32 19
  %314 = load i32, ptr %src_i396, align 4
  %call404 = invoke noundef nonnull align 8 dereferenceable(144) ptr @_ZN8ImVectorI12ImFontConfigEixEi(ptr noundef nonnull align 8 dereferenceable(16) %ConfigData402, i32 noundef %314)
          to label %invoke.cont403 unwind label %lpad172

invoke.cont403:                                   ; preds = %for.body400
  store ptr %call404, ptr %cfg401, align 8
  %315 = load i32, ptr %src_i396, align 4
  %call407 = invoke noundef nonnull align 8 dereferenceable(272) ptr @_ZN8ImVectorI18ImFontBuildSrcDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %src_tmp_array, i32 noundef %315)
          to label %invoke.cont406 unwind label %lpad172

invoke.cont406:                                   ; preds = %invoke.cont403
  store ptr %call407, ptr %src_tmp405, align 8
  %316 = load ptr, ptr %src_tmp405, align 8
  %GlyphsCount408 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %316, i32 0, i32 7
  %317 = load i32, ptr %GlyphsCount408, align 8
  %cmp409 = icmp eq i32 %317, 0
  br i1 %cmp409, label %if.then410, label %if.end411

if.then410:                                       ; preds = %invoke.cont406
  br label %for.inc443

if.end411:                                        ; preds = %invoke.cont406
  %318 = load ptr, ptr %src_tmp405, align 8
  %FontInfo412 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %318, i32 0, i32 0
  %319 = load ptr, ptr %src_tmp405, align 8
  %PackRange413 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %319, i32 0, i32 1
  %320 = load ptr, ptr %src_tmp405, align 8
  %Rects414 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %320, i32 0, i32 2
  %321 = load ptr, ptr %Rects414, align 8
  %call416 = invoke noundef i32 @_ZL35stbtt_PackFontRangesRenderIntoRectsP18stbtt_pack_contextPK14stbtt_fontinfoP16stbtt_pack_rangeiP10stbrp_rect(ptr noundef %spc, ptr noundef %FontInfo412, ptr noundef %PackRange413, i32 noundef 1, ptr noundef %321)
          to label %invoke.cont415 unwind label %lpad172

invoke.cont415:                                   ; preds = %if.end411
  %322 = load ptr, ptr %cfg401, align 8
  %RasterizerMultiply = getelementptr inbounds %struct.ImFontConfig, ptr %322, i32 0, i32 15
  %323 = load float, ptr %RasterizerMultiply, align 8
  %cmp417 = fcmp une float %323, 1.000000e+00
  br i1 %cmp417, label %if.then418, label %if.end441

if.then418:                                       ; preds = %invoke.cont415
  %arraydecay = getelementptr inbounds [256 x i8], ptr %multiply_table, i64 0, i64 0
  %324 = load ptr, ptr %cfg401, align 8
  %RasterizerMultiply419 = getelementptr inbounds %struct.ImFontConfig, ptr %324, i32 0, i32 15
  %325 = load float, ptr %RasterizerMultiply419, align 8
  call void @_Z39ImFontAtlasBuildMultiplyCalcLookupTablePhf(ptr noundef %arraydecay, float noundef %325)
  %326 = load ptr, ptr %src_tmp405, align 8
  %Rects420 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %326, i32 0, i32 2
  %327 = load ptr, ptr %Rects420, align 8
  %arrayidx421 = getelementptr inbounds %struct.stbrp_rect, ptr %327, i64 0
  store ptr %arrayidx421, ptr %r, align 8
  store i32 0, ptr %glyph_i422, align 4
  br label %for.cond423

for.cond423:                                      ; preds = %for.inc438, %if.then418
  %328 = load i32, ptr %glyph_i422, align 4
  %329 = load ptr, ptr %src_tmp405, align 8
  %GlyphsCount424 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %329, i32 0, i32 7
  %330 = load i32, ptr %GlyphsCount424, align 8
  %cmp425 = icmp slt i32 %328, %330
  br i1 %cmp425, label %for.body426, label %for.end440

for.body426:                                      ; preds = %for.cond423
  %331 = load ptr, ptr %r, align 8
  %was_packed427 = getelementptr inbounds %struct.stbrp_rect, ptr %331, i32 0, i32 5
  %332 = load i32, ptr %was_packed427, align 4
  %tobool428 = icmp ne i32 %332, 0
  br i1 %tobool428, label %if.then429, label %if.end437

if.then429:                                       ; preds = %for.body426
  %arraydecay430 = getelementptr inbounds [256 x i8], ptr %multiply_table, i64 0, i64 0
  %333 = load ptr, ptr %atlas.addr, align 8
  %TexPixelsAlpha8431 = getelementptr inbounds %struct.ImFontAtlas, ptr %333, i32 0, i32 11
  %334 = load ptr, ptr %TexPixelsAlpha8431, align 8
  %335 = load ptr, ptr %r, align 8
  %x = getelementptr inbounds %struct.stbrp_rect, ptr %335, i32 0, i32 3
  %336 = load i32, ptr %x, align 4
  %337 = load ptr, ptr %r, align 8
  %y432 = getelementptr inbounds %struct.stbrp_rect, ptr %337, i32 0, i32 4
  %338 = load i32, ptr %y432, align 4
  %339 = load ptr, ptr %r, align 8
  %w433 = getelementptr inbounds %struct.stbrp_rect, ptr %339, i32 0, i32 1
  %340 = load i32, ptr %w433, align 4
  %341 = load ptr, ptr %r, align 8
  %h434 = getelementptr inbounds %struct.stbrp_rect, ptr %341, i32 0, i32 2
  %342 = load i32, ptr %h434, align 4
  %343 = load ptr, ptr %atlas.addr, align 8
  %TexWidth435 = getelementptr inbounds %struct.ImFontAtlas, ptr %343, i32 0, i32 13
  %344 = load i32, ptr %TexWidth435, align 8
  %mul436 = mul nsw i32 %344, 1
  call void @_Z34ImFontAtlasBuildMultiplyRectAlpha8PKhPhiiiii(ptr noundef %arraydecay430, ptr noundef %334, i32 noundef %336, i32 noundef %338, i32 noundef %340, i32 noundef %342, i32 noundef %mul436)
  br label %if.end437

if.end437:                                        ; preds = %if.then429, %for.body426
  br label %for.inc438

for.inc438:                                       ; preds = %if.end437
  %345 = load i32, ptr %glyph_i422, align 4
  %inc439 = add nsw i32 %345, 1
  store i32 %inc439, ptr %glyph_i422, align 4
  %346 = load ptr, ptr %r, align 8
  %incdec.ptr = getelementptr inbounds %struct.stbrp_rect, ptr %346, i32 1
  store ptr %incdec.ptr, ptr %r, align 8
  br label %for.cond423, !llvm.loop !60

for.end440:                                       ; preds = %for.cond423
  br label %if.end441

if.end441:                                        ; preds = %for.end440, %invoke.cont415
  %347 = load ptr, ptr %src_tmp405, align 8
  %Rects442 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %347, i32 0, i32 2
  store ptr null, ptr %Rects442, align 8
  br label %for.inc443

for.inc443:                                       ; preds = %if.end441, %if.then410
  %348 = load i32, ptr %src_i396, align 4
  %inc444 = add nsw i32 %348, 1
  store i32 %inc444, ptr %src_i396, align 4
  br label %for.cond397, !llvm.loop !61

for.end445:                                       ; preds = %for.cond397
  invoke void @_ZL13stbtt_PackEndP18stbtt_pack_context(ptr noundef %spc)
          to label %invoke.cont446 unwind label %lpad172

invoke.cont446:                                   ; preds = %for.end445
  invoke void @_ZN8ImVectorI10stbrp_rectE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %buf_rects)
          to label %invoke.cont447 unwind label %lpad172

invoke.cont447:                                   ; preds = %invoke.cont446
  store i32 0, ptr %src_i448, align 4
  br label %for.cond449

for.cond449:                                      ; preds = %for.inc527, %invoke.cont447
  %349 = load i32, ptr %src_i448, align 4
  %Size450 = getelementptr inbounds %struct.ImVector.14, ptr %src_tmp_array, i32 0, i32 0
  %350 = load i32, ptr %Size450, align 8
  %cmp451 = icmp slt i32 %349, %350
  br i1 %cmp451, label %for.body452, label %for.end529

for.body452:                                      ; preds = %for.cond449
  %351 = load i32, ptr %src_i448, align 4
  %call455 = invoke noundef nonnull align 8 dereferenceable(272) ptr @_ZN8ImVectorI18ImFontBuildSrcDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %src_tmp_array, i32 noundef %351)
          to label %invoke.cont454 unwind label %lpad172

invoke.cont454:                                   ; preds = %for.body452
  store ptr %call455, ptr %src_tmp453, align 8
  %352 = load ptr, ptr %atlas.addr, align 8
  %ConfigData457 = getelementptr inbounds %struct.ImFontAtlas, ptr %352, i32 0, i32 19
  %353 = load i32, ptr %src_i448, align 4
  %call459 = invoke noundef nonnull align 8 dereferenceable(144) ptr @_ZN8ImVectorI12ImFontConfigEixEi(ptr noundef nonnull align 8 dereferenceable(16) %ConfigData457, i32 noundef %353)
          to label %invoke.cont458 unwind label %lpad172

invoke.cont458:                                   ; preds = %invoke.cont454
  store ptr %call459, ptr %cfg456, align 8
  %354 = load ptr, ptr %cfg456, align 8
  %DstFont460 = getelementptr inbounds %struct.ImFontConfig, ptr %354, i32 0, i32 19
  %355 = load ptr, ptr %DstFont460, align 8
  store ptr %355, ptr %dst_font, align 8
  %356 = load ptr, ptr %src_tmp453, align 8
  %FontInfo461 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %356, i32 0, i32 0
  %357 = load ptr, ptr %cfg456, align 8
  %SizePixels462 = getelementptr inbounds %struct.ImFontConfig, ptr %357, i32 0, i32 4
  %358 = load float, ptr %SizePixels462, align 4
  %call464 = invoke noundef float @_ZL25stbtt_ScaleForPixelHeightPK14stbtt_fontinfof(ptr noundef %FontInfo461, float noundef %358)
          to label %invoke.cont463 unwind label %lpad172

invoke.cont463:                                   ; preds = %invoke.cont458
  store float %call464, ptr %font_scale, align 4
  %359 = load ptr, ptr %src_tmp453, align 8
  %FontInfo465 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %359, i32 0, i32 0
  invoke void @_ZL21stbtt_GetFontVMetricsPK14stbtt_fontinfoPiS2_S2_(ptr noundef %FontInfo465, ptr noundef %unscaled_ascent, ptr noundef %unscaled_descent, ptr noundef %unscaled_line_gap)
          to label %invoke.cont466 unwind label %lpad172

invoke.cont466:                                   ; preds = %invoke.cont463
  %360 = load i32, ptr %unscaled_ascent, align 4
  %conv467 = sitofp i32 %360 to float
  %361 = load float, ptr %font_scale, align 4
  %362 = load i32, ptr %unscaled_ascent, align 4
  %conv469 = sitofp i32 %362 to float
  %cmp470 = fcmp ogt float %conv469, 0.000000e+00
  %cond471 = select i1 %cmp470, i32 1, i32 -1
  %conv472 = sitofp i32 %cond471 to float
  %363 = call float @llvm.fmuladd.f32(float %conv467, float %361, float %conv472)
  %call474 = invoke noundef float @_ZL7ImTruncf(float noundef %363)
          to label %invoke.cont473 unwind label %lpad172

invoke.cont473:                                   ; preds = %invoke.cont466
  store float %call474, ptr %ascent, align 4
  %364 = load i32, ptr %unscaled_descent, align 4
  %conv475 = sitofp i32 %364 to float
  %365 = load float, ptr %font_scale, align 4
  %366 = load i32, ptr %unscaled_descent, align 4
  %conv477 = sitofp i32 %366 to float
  %cmp478 = fcmp ogt float %conv477, 0.000000e+00
  %cond479 = select i1 %cmp478, i32 1, i32 -1
  %conv480 = sitofp i32 %cond479 to float
  %367 = call float @llvm.fmuladd.f32(float %conv475, float %365, float %conv480)
  %call482 = invoke noundef float @_ZL7ImTruncf(float noundef %367)
          to label %invoke.cont481 unwind label %lpad172

invoke.cont481:                                   ; preds = %invoke.cont473
  store float %call482, ptr %descent, align 4
  %368 = load ptr, ptr %atlas.addr, align 8
  %369 = load ptr, ptr %dst_font, align 8
  %370 = load ptr, ptr %cfg456, align 8
  %371 = load float, ptr %ascent, align 4
  %372 = load float, ptr %descent, align 4
  invoke void @_Z25ImFontAtlasBuildSetupFontP11ImFontAtlasP6ImFontP12ImFontConfigff(ptr noundef %368, ptr noundef %369, ptr noundef %370, float noundef %371, float noundef %372)
          to label %invoke.cont483 unwind label %lpad172

invoke.cont483:                                   ; preds = %invoke.cont481
  %373 = load ptr, ptr %cfg456, align 8
  %GlyphOffset = getelementptr inbounds %struct.ImFontConfig, ptr %373, i32 0, i32 9
  %x484 = getelementptr inbounds %struct.ImVec2, ptr %GlyphOffset, i32 0, i32 0
  %374 = load float, ptr %x484, align 4
  store float %374, ptr %font_off_x, align 4
  %375 = load ptr, ptr %cfg456, align 8
  %GlyphOffset485 = getelementptr inbounds %struct.ImFontConfig, ptr %375, i32 0, i32 9
  %y486 = getelementptr inbounds %struct.ImVec2, ptr %GlyphOffset485, i32 0, i32 1
  %376 = load float, ptr %y486, align 4
  %377 = load ptr, ptr %dst_font, align 8
  %Ascent = getelementptr inbounds %struct.ImFont, ptr %377, i32 0, i32 17
  %378 = load float, ptr %Ascent, align 8
  %add487 = fadd float %378, 5.000000e-01
  %conv488 = fptosi float %add487 to i32
  %conv489 = sitofp i32 %conv488 to float
  %add490 = fadd float %376, %conv489
  store float %add490, ptr %font_off_y, align 4
  %379 = load ptr, ptr %cfg456, align 8
  %RasterizerDensity491 = getelementptr inbounds %struct.ImFontConfig, ptr %379, i32 0, i32 16
  %380 = load float, ptr %RasterizerDensity491, align 4
  %div492 = fdiv float 1.000000e+00, %380
  store float %div492, ptr %inv_rasterization_scale, align 4
  store i32 0, ptr %glyph_i493, align 4
  br label %for.cond494

for.cond494:                                      ; preds = %for.inc524, %invoke.cont483
  %381 = load i32, ptr %glyph_i493, align 4
  %382 = load ptr, ptr %src_tmp453, align 8
  %GlyphsCount495 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %382, i32 0, i32 7
  %383 = load i32, ptr %GlyphsCount495, align 8
  %cmp496 = icmp slt i32 %381, %383
  br i1 %cmp496, label %for.body497, label %for.end526

for.body497:                                      ; preds = %for.cond494
  %384 = load ptr, ptr %src_tmp453, align 8
  %GlyphsList499 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %384, i32 0, i32 9
  %385 = load i32, ptr %glyph_i493, align 4
  %call501 = invoke noundef nonnull align 4 dereferenceable(4) ptr @_ZN8ImVectorIiEixEi(ptr noundef nonnull align 8 dereferenceable(16) %GlyphsList499, i32 noundef %385)
          to label %invoke.cont500 unwind label %lpad172

invoke.cont500:                                   ; preds = %for.body497
  %386 = load i32, ptr %call501, align 4
  store i32 %386, ptr %codepoint498, align 4
  %387 = load ptr, ptr %src_tmp453, align 8
  %PackedChars502 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %387, i32 0, i32 3
  %388 = load ptr, ptr %PackedChars502, align 8
  %389 = load i32, ptr %glyph_i493, align 4
  %idxprom503 = sext i32 %389 to i64
  %arrayidx504 = getelementptr inbounds %struct.stbtt_packedchar, ptr %388, i64 %idxprom503
  store ptr %arrayidx504, ptr %pc, align 8
  store float 0.000000e+00, ptr %unused_x, align 4
  store float 0.000000e+00, ptr %unused_y, align 4
  %390 = load ptr, ptr %src_tmp453, align 8
  %PackedChars505 = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %390, i32 0, i32 3
  %391 = load ptr, ptr %PackedChars505, align 8
  %392 = load ptr, ptr %atlas.addr, align 8
  %TexWidth506 = getelementptr inbounds %struct.ImFontAtlas, ptr %392, i32 0, i32 13
  %393 = load i32, ptr %TexWidth506, align 8
  %394 = load ptr, ptr %atlas.addr, align 8
  %TexHeight507 = getelementptr inbounds %struct.ImFontAtlas, ptr %394, i32 0, i32 14
  %395 = load i32, ptr %TexHeight507, align 4
  %396 = load i32, ptr %glyph_i493, align 4
  invoke void @_ZL19stbtt_GetPackedQuadPK16stbtt_packedchariiiPfS2_P18stbtt_aligned_quadi(ptr noundef %391, i32 noundef %393, i32 noundef %395, i32 noundef %396, ptr noundef %unused_x, ptr noundef %unused_y, ptr noundef %q, i32 noundef 0)
          to label %invoke.cont508 unwind label %lpad172

invoke.cont508:                                   ; preds = %invoke.cont500
  %x0510 = getelementptr inbounds %struct.stbtt_aligned_quad, ptr %q, i32 0, i32 0
  %397 = load float, ptr %x0510, align 4
  %398 = load float, ptr %inv_rasterization_scale, align 4
  %399 = load float, ptr %font_off_x, align 4
  %400 = call float @llvm.fmuladd.f32(float %397, float %398, float %399)
  store float %400, ptr %x0509, align 4
  %y0513 = getelementptr inbounds %struct.stbtt_aligned_quad, ptr %q, i32 0, i32 1
  %401 = load float, ptr %y0513, align 4
  %402 = load float, ptr %inv_rasterization_scale, align 4
  %403 = load float, ptr %font_off_y, align 4
  %404 = call float @llvm.fmuladd.f32(float %401, float %402, float %403)
  store float %404, ptr %y0512, align 4
  %x1516 = getelementptr inbounds %struct.stbtt_aligned_quad, ptr %q, i32 0, i32 4
  %405 = load float, ptr %x1516, align 4
  %406 = load float, ptr %inv_rasterization_scale, align 4
  %407 = load float, ptr %font_off_x, align 4
  %408 = call float @llvm.fmuladd.f32(float %405, float %406, float %407)
  store float %408, ptr %x1515, align 4
  %y1519 = getelementptr inbounds %struct.stbtt_aligned_quad, ptr %q, i32 0, i32 5
  %409 = load float, ptr %y1519, align 4
  %410 = load float, ptr %inv_rasterization_scale, align 4
  %411 = load float, ptr %font_off_y, align 4
  %412 = call float @llvm.fmuladd.f32(float %409, float %410, float %411)
  store float %412, ptr %y1518, align 4
  %413 = load ptr, ptr %dst_font, align 8
  %414 = load ptr, ptr %cfg456, align 8
  %415 = load i32, ptr %codepoint498, align 4
  %conv521 = trunc i32 %415 to i16
  %416 = load float, ptr %x0509, align 4
  %417 = load float, ptr %y0512, align 4
  %418 = load float, ptr %x1515, align 4
  %419 = load float, ptr %y1518, align 4
  %s0 = getelementptr inbounds %struct.stbtt_aligned_quad, ptr %q, i32 0, i32 2
  %420 = load float, ptr %s0, align 4
  %t0 = getelementptr inbounds %struct.stbtt_aligned_quad, ptr %q, i32 0, i32 3
  %421 = load float, ptr %t0, align 4
  %s1 = getelementptr inbounds %struct.stbtt_aligned_quad, ptr %q, i32 0, i32 6
  %422 = load float, ptr %s1, align 4
  %t1 = getelementptr inbounds %struct.stbtt_aligned_quad, ptr %q, i32 0, i32 7
  %423 = load float, ptr %t1, align 4
  %424 = load ptr, ptr %pc, align 8
  %xadvance = getelementptr inbounds %struct.stbtt_packedchar, ptr %424, i32 0, i32 6
  %425 = load float, ptr %xadvance, align 4
  %426 = load float, ptr %inv_rasterization_scale, align 4
  %mul522 = fmul float %425, %426
  invoke void @_ZN6ImFont8AddGlyphEPK12ImFontConfigtfffffffff(ptr noundef nonnull align 8 dereferenceable(118) %413, ptr noundef %414, i16 noundef zeroext %conv521, float noundef %416, float noundef %417, float noundef %418, float noundef %419, float noundef %420, float noundef %421, float noundef %422, float noundef %423, float noundef %mul522)
          to label %invoke.cont523 unwind label %lpad172

invoke.cont523:                                   ; preds = %invoke.cont508
  br label %for.inc524

for.inc524:                                       ; preds = %invoke.cont523
  %427 = load i32, ptr %glyph_i493, align 4
  %inc525 = add nsw i32 %427, 1
  store i32 %inc525, ptr %glyph_i493, align 4
  br label %for.cond494, !llvm.loop !62

for.end526:                                       ; preds = %for.cond494
  br label %for.inc527

for.inc527:                                       ; preds = %for.end526
  %428 = load i32, ptr %src_i448, align 4
  %inc528 = add nsw i32 %428, 1
  store i32 %inc528, ptr %src_i448, align 4
  br label %for.cond449, !llvm.loop !63

for.end529:                                       ; preds = %for.cond449
  invoke void @_ZN8ImVectorI18ImFontBuildSrcDataE14clear_destructEv(ptr noundef nonnull align 8 dereferenceable(16) %src_tmp_array)
          to label %invoke.cont530 unwind label %lpad172

invoke.cont530:                                   ; preds = %for.end529
  %429 = load ptr, ptr %atlas.addr, align 8
  invoke void @_Z22ImFontAtlasBuildFinishP11ImFontAtlas(ptr noundef %429)
          to label %invoke.cont531 unwind label %lpad172

invoke.cont531:                                   ; preds = %invoke.cont530
  store i1 true, ptr %retval, align 1
  store i32 1, ptr %cleanup.dest.slot, align 4
  call void @_ZN8ImVectorI16stbtt_packedcharED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %buf_packedchars) #12
  call void @_ZN8ImVectorI10stbrp_rectED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %buf_rects) #12
  br label %cleanup

ehcleanup:                                        ; preds = %lpad172, %lpad170
  call void @_ZN8ImVectorI10stbrp_rectED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %buf_rects) #12
  br label %ehcleanup532

cleanup:                                          ; preds = %invoke.cont531, %if.then39, %if.then32
  call void @_ZN8ImVectorI18ImFontBuildDstDataED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %dst_tmp_array) #12
  call void @_ZN8ImVectorI18ImFontBuildSrcDataED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %src_tmp_array) #12
  %430 = load i1, ptr %retval, align 1
  ret i1 %430

ehcleanup532:                                     ; preds = %ehcleanup, %lpad2
  call void @_ZN8ImVectorI18ImFontBuildDstDataED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %dst_tmp_array) #12
  br label %ehcleanup534

ehcleanup534:                                     ; preds = %ehcleanup532, %lpad
  call void @_ZN8ImVectorI18ImFontBuildSrcDataED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %src_tmp_array) #12
  br label %eh.resume

eh.resume:                                        ; preds = %ehcleanup534
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val535 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val535
}

; Function Attrs: mustprogress uwtable
define void @_Z25ImFontAtlasBuildSetupFontP11ImFontAtlasP6ImFontP12ImFontConfigff(ptr noundef %atlas, ptr noundef %font, ptr noundef %font_config, float noundef %ascent, float noundef %descent) #4 {
entry:
  %atlas.addr = alloca ptr, align 8
  %font.addr = alloca ptr, align 8
  %font_config.addr = alloca ptr, align 8
  %ascent.addr = alloca float, align 4
  %descent.addr = alloca float, align 4
  store ptr %atlas, ptr %atlas.addr, align 8
  store ptr %font, ptr %font.addr, align 8
  store ptr %font_config, ptr %font_config.addr, align 8
  store float %ascent, ptr %ascent.addr, align 4
  store float %descent, ptr %descent.addr, align 4
  %0 = load ptr, ptr %font_config.addr, align 8
  %MergeMode = getelementptr inbounds %struct.ImFontConfig, ptr %0, i32 0, i32 13
  %1 = load i8, ptr %MergeMode, align 8
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %font.addr, align 8
  call void @_ZN6ImFont15ClearOutputDataEv(ptr noundef nonnull align 8 dereferenceable(118) %2)
  %3 = load ptr, ptr %font_config.addr, align 8
  %SizePixels = getelementptr inbounds %struct.ImFontConfig, ptr %3, i32 0, i32 4
  %4 = load float, ptr %SizePixels, align 4
  %5 = load ptr, ptr %font.addr, align 8
  %FontSize = getelementptr inbounds %struct.ImFont, ptr %5, i32 0, i32 2
  store float %4, ptr %FontSize, align 4
  %6 = load ptr, ptr %atlas.addr, align 8
  %7 = load ptr, ptr %font.addr, align 8
  %ContainerAtlas = getelementptr inbounds %struct.ImFont, ptr %7, i32 0, i32 6
  store ptr %6, ptr %ContainerAtlas, align 8
  %8 = load float, ptr %ascent.addr, align 4
  %9 = load ptr, ptr %font.addr, align 8
  %Ascent = getelementptr inbounds %struct.ImFont, ptr %9, i32 0, i32 17
  store float %8, ptr %Ascent, align 8
  %10 = load float, ptr %descent.addr, align 4
  %11 = load ptr, ptr %font.addr, align 8
  %Descent = getelementptr inbounds %struct.ImFont, ptr %11, i32 0, i32 18
  store float %10, ptr %Descent, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN6ImFont15ClearOutputDataEv(ptr noundef nonnull align 8 dereferenceable(118) %this) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %FontSize = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 2
  store float 0.000000e+00, ptr %FontSize, align 4
  %FallbackAdvanceX = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 1
  store float 0.000000e+00, ptr %FallbackAdvanceX, align 8
  %Glyphs = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 4
  call void @_ZN8ImVectorI11ImFontGlyphE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %Glyphs)
  %IndexAdvanceX = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 0
  call void @_ZN8ImVectorIfE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %IndexAdvanceX)
  %IndexLookup = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 3
  call void @_ZN8ImVectorItE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %IndexLookup)
  %FallbackGlyph = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 5
  store ptr null, ptr %FallbackGlyph, align 8
  %ContainerAtlas = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 6
  store ptr null, ptr %ContainerAtlas, align 8
  %DirtyLookupTables = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 14
  store i8 1, ptr %DirtyLookupTables, align 8
  %Descent = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 18
  store float 0.000000e+00, ptr %Descent, align 4
  %Ascent = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 17
  store float 0.000000e+00, ptr %Ascent, align 8
  %MetricsTotalSurface = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 19
  store i32 0, ptr %MetricsTotalSurface, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_Z31ImFontAtlasBuildPackCustomRectsP11ImFontAtlasPv(ptr noundef %atlas, ptr noundef %stbrp_context_opaque) #4 personality ptr @__gxx_personality_v0 {
entry:
  %atlas.addr = alloca ptr, align 8
  %stbrp_context_opaque.addr = alloca ptr, align 8
  %pack_context = alloca ptr, align 8
  %user_rects = alloca ptr, align 8
  %pack_rects = alloca %struct.ImVector.12, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %i = alloca i32, align 4
  %i20 = alloca i32, align 4
  store ptr %atlas, ptr %atlas.addr, align 8
  store ptr %stbrp_context_opaque, ptr %stbrp_context_opaque.addr, align 8
  %0 = load ptr, ptr %stbrp_context_opaque.addr, align 8
  store ptr %0, ptr %pack_context, align 8
  %1 = load ptr, ptr %atlas.addr, align 8
  %CustomRects = getelementptr inbounds %struct.ImFontAtlas, ptr %1, i32 0, i32 18
  store ptr %CustomRects, ptr %user_rects, align 8
  %2 = load ptr, ptr %user_rects, align 8
  %Size = getelementptr inbounds %struct.ImVector.10, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %Size, align 8
  %cmp = icmp slt i32 %3, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  unreachable

if.end:                                           ; preds = %entry
  call void @_ZN8ImVectorI10stbrp_rectEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %pack_rects)
  %4 = load ptr, ptr %user_rects, align 8
  %Size1 = getelementptr inbounds %struct.ImVector.10, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %Size1, align 8
  invoke void @_ZN8ImVectorI10stbrp_rectE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %pack_rects, i32 noundef %5)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %if.end
  %Data = getelementptr inbounds %struct.ImVector.12, ptr %pack_rects, i32 0, i32 2
  %6 = load ptr, ptr %Data, align 8
  %call = invoke noundef i32 @_ZNK8ImVectorI10stbrp_rectE13size_in_bytesEv(ptr noundef nonnull align 8 dereferenceable(16) %pack_rects)
          to label %invoke.cont2 unwind label %lpad

invoke.cont2:                                     ; preds = %invoke.cont
  %conv = sext i32 %call to i64
  call void @llvm.memset.p0.i64(ptr align 4 %6, i8 0, i64 %conv, i1 false)
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %invoke.cont2
  %7 = load i32, ptr %i, align 4
  %8 = load ptr, ptr %user_rects, align 8
  %Size3 = getelementptr inbounds %struct.ImVector.10, ptr %8, i32 0, i32 0
  %9 = load i32, ptr %Size3, align 8
  %cmp4 = icmp slt i32 %7, %9
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %user_rects, align 8
  %11 = load i32, ptr %i, align 4
  %call6 = invoke noundef nonnull align 8 dereferenceable(32) ptr @_ZN8ImVectorI21ImFontAtlasCustomRectEixEi(ptr noundef nonnull align 8 dereferenceable(16) %10, i32 noundef %11)
          to label %invoke.cont5 unwind label %lpad

invoke.cont5:                                     ; preds = %for.body
  %Width = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %call6, i32 0, i32 0
  %12 = load i16, ptr %Width, align 8
  %conv7 = zext i16 %12 to i32
  %13 = load i32, ptr %i, align 4
  %call9 = invoke noundef nonnull align 4 dereferenceable(24) ptr @_ZN8ImVectorI10stbrp_rectEixEi(ptr noundef nonnull align 8 dereferenceable(16) %pack_rects, i32 noundef %13)
          to label %invoke.cont8 unwind label %lpad

invoke.cont8:                                     ; preds = %invoke.cont5
  %w = getelementptr inbounds %struct.stbrp_rect, ptr %call9, i32 0, i32 1
  store i32 %conv7, ptr %w, align 4
  %14 = load ptr, ptr %user_rects, align 8
  %15 = load i32, ptr %i, align 4
  %call11 = invoke noundef nonnull align 8 dereferenceable(32) ptr @_ZN8ImVectorI21ImFontAtlasCustomRectEixEi(ptr noundef nonnull align 8 dereferenceable(16) %14, i32 noundef %15)
          to label %invoke.cont10 unwind label %lpad

invoke.cont10:                                    ; preds = %invoke.cont8
  %Height = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %call11, i32 0, i32 1
  %16 = load i16, ptr %Height, align 2
  %conv12 = zext i16 %16 to i32
  %17 = load i32, ptr %i, align 4
  %call14 = invoke noundef nonnull align 4 dereferenceable(24) ptr @_ZN8ImVectorI10stbrp_rectEixEi(ptr noundef nonnull align 8 dereferenceable(16) %pack_rects, i32 noundef %17)
          to label %invoke.cont13 unwind label %lpad

invoke.cont13:                                    ; preds = %invoke.cont10
  %h = getelementptr inbounds %struct.stbrp_rect, ptr %call14, i32 0, i32 2
  store i32 %conv12, ptr %h, align 4
  br label %for.inc

for.inc:                                          ; preds = %invoke.cont13
  %18 = load i32, ptr %i, align 4
  %inc = add nsw i32 %18, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !64

lpad:                                             ; preds = %invoke.cont41, %invoke.cont38, %invoke.cont36, %invoke.cont33, %invoke.cont31, %invoke.cont28, %if.then27, %for.body24, %invoke.cont15, %for.end, %invoke.cont10, %invoke.cont8, %invoke.cont5, %for.body, %invoke.cont, %if.end
  %19 = landingpad { ptr, i32 }
          cleanup
  %20 = extractvalue { ptr, i32 } %19, 0
  store ptr %20, ptr %exn.slot, align 8
  %21 = extractvalue { ptr, i32 } %19, 1
  store i32 %21, ptr %ehselector.slot, align 4
  call void @_ZN8ImVectorI10stbrp_rectED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %pack_rects) #12
  br label %eh.resume

for.end:                                          ; preds = %for.cond
  %22 = load ptr, ptr %pack_context, align 8
  %call16 = invoke noundef nonnull align 4 dereferenceable(24) ptr @_ZN8ImVectorI10stbrp_rectEixEi(ptr noundef nonnull align 8 dereferenceable(16) %pack_rects, i32 noundef 0)
          to label %invoke.cont15 unwind label %lpad

invoke.cont15:                                    ; preds = %for.end
  %Size17 = getelementptr inbounds %struct.ImVector.12, ptr %pack_rects, i32 0, i32 0
  %23 = load i32, ptr %Size17, align 8
  %call19 = invoke noundef i32 @_ZL16stbrp_pack_rectsP13stbrp_contextP10stbrp_recti(ptr noundef %22, ptr noundef %call16, i32 noundef %23)
          to label %invoke.cont18 unwind label %lpad

invoke.cont18:                                    ; preds = %invoke.cont15
  store i32 0, ptr %i20, align 4
  br label %for.cond21

for.cond21:                                       ; preds = %for.inc48, %invoke.cont18
  %24 = load i32, ptr %i20, align 4
  %Size22 = getelementptr inbounds %struct.ImVector.12, ptr %pack_rects, i32 0, i32 0
  %25 = load i32, ptr %Size22, align 8
  %cmp23 = icmp slt i32 %24, %25
  br i1 %cmp23, label %for.body24, label %for.end50

for.body24:                                       ; preds = %for.cond21
  %26 = load i32, ptr %i20, align 4
  %call26 = invoke noundef nonnull align 4 dereferenceable(24) ptr @_ZN8ImVectorI10stbrp_rectEixEi(ptr noundef nonnull align 8 dereferenceable(16) %pack_rects, i32 noundef %26)
          to label %invoke.cont25 unwind label %lpad

invoke.cont25:                                    ; preds = %for.body24
  %was_packed = getelementptr inbounds %struct.stbrp_rect, ptr %call26, i32 0, i32 5
  %27 = load i32, ptr %was_packed, align 4
  %tobool = icmp ne i32 %27, 0
  br i1 %tobool, label %if.then27, label %if.end47

if.then27:                                        ; preds = %invoke.cont25
  %28 = load i32, ptr %i20, align 4
  %call29 = invoke noundef nonnull align 4 dereferenceable(24) ptr @_ZN8ImVectorI10stbrp_rectEixEi(ptr noundef nonnull align 8 dereferenceable(16) %pack_rects, i32 noundef %28)
          to label %invoke.cont28 unwind label %lpad

invoke.cont28:                                    ; preds = %if.then27
  %x = getelementptr inbounds %struct.stbrp_rect, ptr %call29, i32 0, i32 3
  %29 = load i32, ptr %x, align 4
  %conv30 = trunc i32 %29 to i16
  %30 = load ptr, ptr %user_rects, align 8
  %31 = load i32, ptr %i20, align 4
  %call32 = invoke noundef nonnull align 8 dereferenceable(32) ptr @_ZN8ImVectorI21ImFontAtlasCustomRectEixEi(ptr noundef nonnull align 8 dereferenceable(16) %30, i32 noundef %31)
          to label %invoke.cont31 unwind label %lpad

invoke.cont31:                                    ; preds = %invoke.cont28
  %X = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %call32, i32 0, i32 2
  store i16 %conv30, ptr %X, align 4
  %32 = load i32, ptr %i20, align 4
  %call34 = invoke noundef nonnull align 4 dereferenceable(24) ptr @_ZN8ImVectorI10stbrp_rectEixEi(ptr noundef nonnull align 8 dereferenceable(16) %pack_rects, i32 noundef %32)
          to label %invoke.cont33 unwind label %lpad

invoke.cont33:                                    ; preds = %invoke.cont31
  %y = getelementptr inbounds %struct.stbrp_rect, ptr %call34, i32 0, i32 4
  %33 = load i32, ptr %y, align 4
  %conv35 = trunc i32 %33 to i16
  %34 = load ptr, ptr %user_rects, align 8
  %35 = load i32, ptr %i20, align 4
  %call37 = invoke noundef nonnull align 8 dereferenceable(32) ptr @_ZN8ImVectorI21ImFontAtlasCustomRectEixEi(ptr noundef nonnull align 8 dereferenceable(16) %34, i32 noundef %35)
          to label %invoke.cont36 unwind label %lpad

invoke.cont36:                                    ; preds = %invoke.cont33
  %Y = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %call37, i32 0, i32 3
  store i16 %conv35, ptr %Y, align 2
  %36 = load ptr, ptr %atlas.addr, align 8
  %TexHeight = getelementptr inbounds %struct.ImFontAtlas, ptr %36, i32 0, i32 14
  %37 = load i32, ptr %TexHeight, align 4
  %38 = load i32, ptr %i20, align 4
  %call39 = invoke noundef nonnull align 4 dereferenceable(24) ptr @_ZN8ImVectorI10stbrp_rectEixEi(ptr noundef nonnull align 8 dereferenceable(16) %pack_rects, i32 noundef %38)
          to label %invoke.cont38 unwind label %lpad

invoke.cont38:                                    ; preds = %invoke.cont36
  %y40 = getelementptr inbounds %struct.stbrp_rect, ptr %call39, i32 0, i32 4
  %39 = load i32, ptr %y40, align 4
  %40 = load i32, ptr %i20, align 4
  %call42 = invoke noundef nonnull align 4 dereferenceable(24) ptr @_ZN8ImVectorI10stbrp_rectEixEi(ptr noundef nonnull align 8 dereferenceable(16) %pack_rects, i32 noundef %40)
          to label %invoke.cont41 unwind label %lpad

invoke.cont41:                                    ; preds = %invoke.cont38
  %h43 = getelementptr inbounds %struct.stbrp_rect, ptr %call42, i32 0, i32 2
  %41 = load i32, ptr %h43, align 4
  %add = add nsw i32 %39, %41
  %call45 = invoke noundef i32 @_ZL5ImMaxIiET_S0_S0_(i32 noundef %37, i32 noundef %add)
          to label %invoke.cont44 unwind label %lpad

invoke.cont44:                                    ; preds = %invoke.cont41
  %42 = load ptr, ptr %atlas.addr, align 8
  %TexHeight46 = getelementptr inbounds %struct.ImFontAtlas, ptr %42, i32 0, i32 14
  store i32 %call45, ptr %TexHeight46, align 4
  br label %if.end47

if.end47:                                         ; preds = %invoke.cont44, %invoke.cont25
  br label %for.inc48

for.inc48:                                        ; preds = %if.end47
  %43 = load i32, ptr %i20, align 4
  %inc49 = add nsw i32 %43, 1
  store i32 %inc49, ptr %i20, align 4
  br label %for.cond21, !llvm.loop !65

for.end50:                                        ; preds = %for.cond21
  call void @_ZN8ImVectorI10stbrp_rectED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %pack_rects) #12
  ret void

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val51 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val51
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI10stbrp_rectEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.12, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.12, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data = getelementptr inbounds %struct.ImVector.12, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI10stbrp_rectE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_size) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_size, ptr %new_size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_size.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.12, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sgt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %new_size.addr, align 4
  %call = call noundef i32 @_ZNK8ImVectorI10stbrp_rectE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %2)
  call void @_ZN8ImVectorI10stbrp_rectE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %new_size.addr, align 4
  %Size = getelementptr inbounds %struct.ImVector.12, ptr %this1, i32 0, i32 0
  store i32 %3, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorI10stbrp_rectE13size_in_bytesEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.12, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %mul = mul nsw i32 %0, 24
  ret i32 %mul
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 8 dereferenceable(32) ptr @_ZN8ImVectorI21ImFontAtlasCustomRectEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 4 dereferenceable(24) ptr @_ZN8ImVectorI10stbrp_rectEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.12, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.stbrp_rect, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define internal noundef i32 @_ZL16stbrp_pack_rectsP13stbrp_contextP10stbrp_recti(ptr noundef %context, ptr noundef %rects, i32 noundef %num_rects) #4 {
entry:
  %context.addr = alloca ptr, align 8
  %rects.addr = alloca ptr, align 8
  %num_rects.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %all_rects_packed = alloca i32, align 4
  %fr = alloca %struct.stbrp__findresult, align 8
  store ptr %context, ptr %context.addr, align 8
  store ptr %rects, ptr %rects.addr, align 8
  store i32 %num_rects, ptr %num_rects.addr, align 4
  store i32 1, ptr %all_rects_packed, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %1 = load i32, ptr %num_rects.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32, ptr %i, align 4
  %3 = load ptr, ptr %rects.addr, align 8
  %4 = load i32, ptr %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds %struct.stbrp_rect, ptr %3, i64 %idxprom
  %was_packed = getelementptr inbounds %struct.stbrp_rect, ptr %arrayidx, i32 0, i32 5
  store i32 %2, ptr %was_packed, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, ptr %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !66

for.end:                                          ; preds = %for.cond
  %6 = load ptr, ptr %rects.addr, align 8
  %7 = load i32, ptr %num_rects.addr, align 4
  %conv = sext i32 %7 to i64
  call void @_ZL7ImQsortPvmmPFiPKvS1_E(ptr noundef %6, i64 noundef %conv, i64 noundef 24, ptr noundef @_ZL19rect_height_comparePKvS0_)
  store i32 0, ptr %i, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc37, %for.end
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %num_rects.addr, align 4
  %cmp2 = icmp slt i32 %8, %9
  br i1 %cmp2, label %for.body3, label %for.end39

for.body3:                                        ; preds = %for.cond1
  %10 = load ptr, ptr %rects.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idxprom4 = sext i32 %11 to i64
  %arrayidx5 = getelementptr inbounds %struct.stbrp_rect, ptr %10, i64 %idxprom4
  %w = getelementptr inbounds %struct.stbrp_rect, ptr %arrayidx5, i32 0, i32 1
  %12 = load i32, ptr %w, align 4
  %cmp6 = icmp eq i32 %12, 0
  br i1 %cmp6, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body3
  %13 = load ptr, ptr %rects.addr, align 8
  %14 = load i32, ptr %i, align 4
  %idxprom7 = sext i32 %14 to i64
  %arrayidx8 = getelementptr inbounds %struct.stbrp_rect, ptr %13, i64 %idxprom7
  %h = getelementptr inbounds %struct.stbrp_rect, ptr %arrayidx8, i32 0, i32 2
  %15 = load i32, ptr %h, align 4
  %cmp9 = icmp eq i32 %15, 0
  br i1 %cmp9, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %for.body3
  %16 = load ptr, ptr %rects.addr, align 8
  %17 = load i32, ptr %i, align 4
  %idxprom10 = sext i32 %17 to i64
  %arrayidx11 = getelementptr inbounds %struct.stbrp_rect, ptr %16, i64 %idxprom10
  %y = getelementptr inbounds %struct.stbrp_rect, ptr %arrayidx11, i32 0, i32 4
  store i32 0, ptr %y, align 4
  %18 = load ptr, ptr %rects.addr, align 8
  %19 = load i32, ptr %i, align 4
  %idxprom12 = sext i32 %19 to i64
  %arrayidx13 = getelementptr inbounds %struct.stbrp_rect, ptr %18, i64 %idxprom12
  %x = getelementptr inbounds %struct.stbrp_rect, ptr %arrayidx13, i32 0, i32 3
  store i32 0, ptr %x, align 4
  br label %if.end36

if.else:                                          ; preds = %lor.lhs.false
  %20 = load ptr, ptr %context.addr, align 8
  %21 = load ptr, ptr %rects.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idxprom14 = sext i32 %22 to i64
  %arrayidx15 = getelementptr inbounds %struct.stbrp_rect, ptr %21, i64 %idxprom14
  %w16 = getelementptr inbounds %struct.stbrp_rect, ptr %arrayidx15, i32 0, i32 1
  %23 = load i32, ptr %w16, align 4
  %24 = load ptr, ptr %rects.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idxprom17 = sext i32 %25 to i64
  %arrayidx18 = getelementptr inbounds %struct.stbrp_rect, ptr %24, i64 %idxprom17
  %h19 = getelementptr inbounds %struct.stbrp_rect, ptr %arrayidx18, i32 0, i32 2
  %26 = load i32, ptr %h19, align 4
  %call = call { i64, ptr } @_ZL29stbrp__skyline_pack_rectangleP13stbrp_contextii(ptr noundef %20, i32 noundef %23, i32 noundef %26)
  %27 = getelementptr inbounds { i64, ptr }, ptr %fr, i32 0, i32 0
  %28 = extractvalue { i64, ptr } %call, 0
  store i64 %28, ptr %27, align 8
  %29 = getelementptr inbounds { i64, ptr }, ptr %fr, i32 0, i32 1
  %30 = extractvalue { i64, ptr } %call, 1
  store ptr %30, ptr %29, align 8
  %prev_link = getelementptr inbounds %struct.stbrp__findresult, ptr %fr, i32 0, i32 2
  %31 = load ptr, ptr %prev_link, align 8
  %tobool = icmp ne ptr %31, null
  br i1 %tobool, label %if.then20, label %if.else29

if.then20:                                        ; preds = %if.else
  %x21 = getelementptr inbounds %struct.stbrp__findresult, ptr %fr, i32 0, i32 0
  %32 = load i32, ptr %x21, align 8
  %33 = load ptr, ptr %rects.addr, align 8
  %34 = load i32, ptr %i, align 4
  %idxprom22 = sext i32 %34 to i64
  %arrayidx23 = getelementptr inbounds %struct.stbrp_rect, ptr %33, i64 %idxprom22
  %x24 = getelementptr inbounds %struct.stbrp_rect, ptr %arrayidx23, i32 0, i32 3
  store i32 %32, ptr %x24, align 4
  %y25 = getelementptr inbounds %struct.stbrp__findresult, ptr %fr, i32 0, i32 1
  %35 = load i32, ptr %y25, align 4
  %36 = load ptr, ptr %rects.addr, align 8
  %37 = load i32, ptr %i, align 4
  %idxprom26 = sext i32 %37 to i64
  %arrayidx27 = getelementptr inbounds %struct.stbrp_rect, ptr %36, i64 %idxprom26
  %y28 = getelementptr inbounds %struct.stbrp_rect, ptr %arrayidx27, i32 0, i32 4
  store i32 %35, ptr %y28, align 4
  br label %if.end

if.else29:                                        ; preds = %if.else
  %38 = load ptr, ptr %rects.addr, align 8
  %39 = load i32, ptr %i, align 4
  %idxprom30 = sext i32 %39 to i64
  %arrayidx31 = getelementptr inbounds %struct.stbrp_rect, ptr %38, i64 %idxprom30
  %y32 = getelementptr inbounds %struct.stbrp_rect, ptr %arrayidx31, i32 0, i32 4
  store i32 2147483647, ptr %y32, align 4
  %40 = load ptr, ptr %rects.addr, align 8
  %41 = load i32, ptr %i, align 4
  %idxprom33 = sext i32 %41 to i64
  %arrayidx34 = getelementptr inbounds %struct.stbrp_rect, ptr %40, i64 %idxprom33
  %x35 = getelementptr inbounds %struct.stbrp_rect, ptr %arrayidx34, i32 0, i32 3
  store i32 2147483647, ptr %x35, align 4
  br label %if.end

if.end:                                           ; preds = %if.else29, %if.then20
  br label %if.end36

if.end36:                                         ; preds = %if.end, %if.then
  br label %for.inc37

for.inc37:                                        ; preds = %if.end36
  %42 = load i32, ptr %i, align 4
  %inc38 = add nsw i32 %42, 1
  store i32 %inc38, ptr %i, align 4
  br label %for.cond1, !llvm.loop !67

for.end39:                                        ; preds = %for.cond1
  %43 = load ptr, ptr %rects.addr, align 8
  %44 = load i32, ptr %num_rects.addr, align 4
  %conv40 = sext i32 %44 to i64
  call void @_ZL7ImQsortPvmmPFiPKvS1_E(ptr noundef %43, i64 noundef %conv40, i64 noundef 24, ptr noundef @_ZL19rect_original_orderPKvS0_)
  store i32 0, ptr %i, align 4
  br label %for.cond41

for.cond41:                                       ; preds = %for.inc62, %for.end39
  %45 = load i32, ptr %i, align 4
  %46 = load i32, ptr %num_rects.addr, align 4
  %cmp42 = icmp slt i32 %45, %46
  br i1 %cmp42, label %for.body43, label %for.end64

for.body43:                                       ; preds = %for.cond41
  %47 = load ptr, ptr %rects.addr, align 8
  %48 = load i32, ptr %i, align 4
  %idxprom44 = sext i32 %48 to i64
  %arrayidx45 = getelementptr inbounds %struct.stbrp_rect, ptr %47, i64 %idxprom44
  %x46 = getelementptr inbounds %struct.stbrp_rect, ptr %arrayidx45, i32 0, i32 3
  %49 = load i32, ptr %x46, align 4
  %cmp47 = icmp eq i32 %49, 2147483647
  br i1 %cmp47, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.body43
  %50 = load ptr, ptr %rects.addr, align 8
  %51 = load i32, ptr %i, align 4
  %idxprom48 = sext i32 %51 to i64
  %arrayidx49 = getelementptr inbounds %struct.stbrp_rect, ptr %50, i64 %idxprom48
  %y50 = getelementptr inbounds %struct.stbrp_rect, ptr %arrayidx49, i32 0, i32 4
  %52 = load i32, ptr %y50, align 4
  %cmp51 = icmp eq i32 %52, 2147483647
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.body43
  %53 = phi i1 [ false, %for.body43 ], [ %cmp51, %land.rhs ]
  %lnot = xor i1 %53, true
  %conv52 = zext i1 %lnot to i32
  %54 = load ptr, ptr %rects.addr, align 8
  %55 = load i32, ptr %i, align 4
  %idxprom53 = sext i32 %55 to i64
  %arrayidx54 = getelementptr inbounds %struct.stbrp_rect, ptr %54, i64 %idxprom53
  %was_packed55 = getelementptr inbounds %struct.stbrp_rect, ptr %arrayidx54, i32 0, i32 5
  store i32 %conv52, ptr %was_packed55, align 4
  %56 = load ptr, ptr %rects.addr, align 8
  %57 = load i32, ptr %i, align 4
  %idxprom56 = sext i32 %57 to i64
  %arrayidx57 = getelementptr inbounds %struct.stbrp_rect, ptr %56, i64 %idxprom56
  %was_packed58 = getelementptr inbounds %struct.stbrp_rect, ptr %arrayidx57, i32 0, i32 5
  %58 = load i32, ptr %was_packed58, align 4
  %tobool59 = icmp ne i32 %58, 0
  br i1 %tobool59, label %if.end61, label %if.then60

if.then60:                                        ; preds = %land.end
  store i32 0, ptr %all_rects_packed, align 4
  br label %if.end61

if.end61:                                         ; preds = %if.then60, %land.end
  br label %for.inc62

for.inc62:                                        ; preds = %if.end61
  %59 = load i32, ptr %i, align 4
  %inc63 = add nsw i32 %59, 1
  store i32 %inc63, ptr %i, align 4
  br label %for.cond41, !llvm.loop !68

for.end64:                                        ; preds = %for.cond41
  %60 = load i32, ptr %all_rects_packed, align 4
  ret i32 %60
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI10stbrp_rectED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.12, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Data2 = getelementptr inbounds %struct.ImVector.12, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  invoke void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %invoke.cont, %entry
  ret void

terminate.lpad:                                   ; preds = %if.then
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #13
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define void @_Z40ImFontAtlasBuildRender8bppRectFromStringP11ImFontAtlasiiiiPKcch(ptr noundef %atlas, i32 noundef %x, i32 noundef %y, i32 noundef %w, i32 noundef %h, ptr noundef %in_str, i8 noundef signext %in_marker_char, i8 noundef zeroext %in_marker_pixel_value) #2 {
entry:
  %atlas.addr = alloca ptr, align 8
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %in_str.addr = alloca ptr, align 8
  %in_marker_char.addr = alloca i8, align 1
  %in_marker_pixel_value.addr = alloca i8, align 1
  %out_pixel = alloca ptr, align 8
  %off_y = alloca i32, align 4
  %off_x = alloca i32, align 4
  store ptr %atlas, ptr %atlas.addr, align 8
  store i32 %x, ptr %x.addr, align 4
  store i32 %y, ptr %y.addr, align 4
  store i32 %w, ptr %w.addr, align 4
  store i32 %h, ptr %h.addr, align 4
  store ptr %in_str, ptr %in_str.addr, align 8
  store i8 %in_marker_char, ptr %in_marker_char.addr, align 1
  store i8 %in_marker_pixel_value, ptr %in_marker_pixel_value.addr, align 1
  %0 = load ptr, ptr %atlas.addr, align 8
  %TexPixelsAlpha8 = getelementptr inbounds %struct.ImFontAtlas, ptr %0, i32 0, i32 11
  %1 = load ptr, ptr %TexPixelsAlpha8, align 8
  %2 = load i32, ptr %x.addr, align 4
  %idx.ext = sext i32 %2 to i64
  %add.ptr = getelementptr inbounds i8, ptr %1, i64 %idx.ext
  %3 = load i32, ptr %y.addr, align 4
  %4 = load ptr, ptr %atlas.addr, align 8
  %TexWidth = getelementptr inbounds %struct.ImFontAtlas, ptr %4, i32 0, i32 13
  %5 = load i32, ptr %TexWidth, align 8
  %mul = mul nsw i32 %3, %5
  %idx.ext1 = sext i32 %mul to i64
  %add.ptr2 = getelementptr inbounds i8, ptr %add.ptr, i64 %idx.ext1
  store ptr %add.ptr2, ptr %out_pixel, align 8
  store i32 0, ptr %off_y, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc12, %entry
  %6 = load i32, ptr %off_y, align 4
  %7 = load i32, ptr %h.addr, align 4
  %cmp = icmp slt i32 %6, %7
  br i1 %cmp, label %for.body, label %for.end19

for.body:                                         ; preds = %for.cond
  store i32 0, ptr %off_x, align 4
  br label %for.cond3

for.cond3:                                        ; preds = %for.inc, %for.body
  %8 = load i32, ptr %off_x, align 4
  %9 = load i32, ptr %w.addr, align 4
  %cmp4 = icmp slt i32 %8, %9
  br i1 %cmp4, label %for.body5, label %for.end

for.body5:                                        ; preds = %for.cond3
  %10 = load ptr, ptr %in_str.addr, align 8
  %11 = load i32, ptr %off_x, align 4
  %idxprom = sext i32 %11 to i64
  %arrayidx = getelementptr inbounds i8, ptr %10, i64 %idxprom
  %12 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %12 to i32
  %13 = load i8, ptr %in_marker_char.addr, align 1
  %conv6 = sext i8 %13 to i32
  %cmp7 = icmp eq i32 %conv, %conv6
  br i1 %cmp7, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body5
  %14 = load i8, ptr %in_marker_pixel_value.addr, align 1
  %conv8 = zext i8 %14 to i32
  br label %cond.end

cond.false:                                       ; preds = %for.body5
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv8, %cond.true ], [ 0, %cond.false ]
  %conv9 = trunc i32 %cond to i8
  %15 = load ptr, ptr %out_pixel, align 8
  %16 = load i32, ptr %off_x, align 4
  %idxprom10 = sext i32 %16 to i64
  %arrayidx11 = getelementptr inbounds i8, ptr %15, i64 %idxprom10
  store i8 %conv9, ptr %arrayidx11, align 1
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %17 = load i32, ptr %off_x, align 4
  %inc = add nsw i32 %17, 1
  store i32 %inc, ptr %off_x, align 4
  br label %for.cond3, !llvm.loop !69

for.end:                                          ; preds = %for.cond3
  br label %for.inc12

for.inc12:                                        ; preds = %for.end
  %18 = load i32, ptr %off_y, align 4
  %inc13 = add nsw i32 %18, 1
  store i32 %inc13, ptr %off_y, align 4
  %19 = load ptr, ptr %atlas.addr, align 8
  %TexWidth14 = getelementptr inbounds %struct.ImFontAtlas, ptr %19, i32 0, i32 13
  %20 = load i32, ptr %TexWidth14, align 8
  %21 = load ptr, ptr %out_pixel, align 8
  %idx.ext15 = sext i32 %20 to i64
  %add.ptr16 = getelementptr inbounds i8, ptr %21, i64 %idx.ext15
  store ptr %add.ptr16, ptr %out_pixel, align 8
  %22 = load i32, ptr %w.addr, align 4
  %23 = load ptr, ptr %in_str.addr, align 8
  %idx.ext17 = sext i32 %22 to i64
  %add.ptr18 = getelementptr inbounds i8, ptr %23, i64 %idx.ext17
  store ptr %add.ptr18, ptr %in_str.addr, align 8
  br label %for.cond, !llvm.loop !70

for.end19:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define void @_Z41ImFontAtlasBuildRender32bppRectFromStringP11ImFontAtlasiiiiPKccj(ptr noundef %atlas, i32 noundef %x, i32 noundef %y, i32 noundef %w, i32 noundef %h, ptr noundef %in_str, i8 noundef signext %in_marker_char, i32 noundef %in_marker_pixel_value) #2 {
entry:
  %atlas.addr = alloca ptr, align 8
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %in_str.addr = alloca ptr, align 8
  %in_marker_char.addr = alloca i8, align 1
  %in_marker_pixel_value.addr = alloca i32, align 4
  %out_pixel = alloca ptr, align 8
  %off_y = alloca i32, align 4
  %off_x = alloca i32, align 4
  store ptr %atlas, ptr %atlas.addr, align 8
  store i32 %x, ptr %x.addr, align 4
  store i32 %y, ptr %y.addr, align 4
  store i32 %w, ptr %w.addr, align 4
  store i32 %h, ptr %h.addr, align 4
  store ptr %in_str, ptr %in_str.addr, align 8
  store i8 %in_marker_char, ptr %in_marker_char.addr, align 1
  store i32 %in_marker_pixel_value, ptr %in_marker_pixel_value.addr, align 4
  %0 = load ptr, ptr %atlas.addr, align 8
  %TexPixelsRGBA32 = getelementptr inbounds %struct.ImFontAtlas, ptr %0, i32 0, i32 12
  %1 = load ptr, ptr %TexPixelsRGBA32, align 8
  %2 = load i32, ptr %x.addr, align 4
  %idx.ext = sext i32 %2 to i64
  %add.ptr = getelementptr inbounds i32, ptr %1, i64 %idx.ext
  %3 = load i32, ptr %y.addr, align 4
  %4 = load ptr, ptr %atlas.addr, align 8
  %TexWidth = getelementptr inbounds %struct.ImFontAtlas, ptr %4, i32 0, i32 13
  %5 = load i32, ptr %TexWidth, align 8
  %mul = mul nsw i32 %3, %5
  %idx.ext1 = sext i32 %mul to i64
  %add.ptr2 = getelementptr inbounds i32, ptr %add.ptr, i64 %idx.ext1
  store ptr %add.ptr2, ptr %out_pixel, align 8
  store i32 0, ptr %off_y, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc10, %entry
  %6 = load i32, ptr %off_y, align 4
  %7 = load i32, ptr %h.addr, align 4
  %cmp = icmp slt i32 %6, %7
  br i1 %cmp, label %for.body, label %for.end17

for.body:                                         ; preds = %for.cond
  store i32 0, ptr %off_x, align 4
  br label %for.cond3

for.cond3:                                        ; preds = %for.inc, %for.body
  %8 = load i32, ptr %off_x, align 4
  %9 = load i32, ptr %w.addr, align 4
  %cmp4 = icmp slt i32 %8, %9
  br i1 %cmp4, label %for.body5, label %for.end

for.body5:                                        ; preds = %for.cond3
  %10 = load ptr, ptr %in_str.addr, align 8
  %11 = load i32, ptr %off_x, align 4
  %idxprom = sext i32 %11 to i64
  %arrayidx = getelementptr inbounds i8, ptr %10, i64 %idxprom
  %12 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %12 to i32
  %13 = load i8, ptr %in_marker_char.addr, align 1
  %conv6 = sext i8 %13 to i32
  %cmp7 = icmp eq i32 %conv, %conv6
  br i1 %cmp7, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body5
  %14 = load i32, ptr %in_marker_pixel_value.addr, align 4
  br label %cond.end

cond.false:                                       ; preds = %for.body5
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %14, %cond.true ], [ 0, %cond.false ]
  %15 = load ptr, ptr %out_pixel, align 8
  %16 = load i32, ptr %off_x, align 4
  %idxprom8 = sext i32 %16 to i64
  %arrayidx9 = getelementptr inbounds i32, ptr %15, i64 %idxprom8
  store i32 %cond, ptr %arrayidx9, align 4
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %17 = load i32, ptr %off_x, align 4
  %inc = add nsw i32 %17, 1
  store i32 %inc, ptr %off_x, align 4
  br label %for.cond3, !llvm.loop !71

for.end:                                          ; preds = %for.cond3
  br label %for.inc10

for.inc10:                                        ; preds = %for.end
  %18 = load i32, ptr %off_y, align 4
  %inc11 = add nsw i32 %18, 1
  store i32 %inc11, ptr %off_y, align 4
  %19 = load ptr, ptr %atlas.addr, align 8
  %TexWidth12 = getelementptr inbounds %struct.ImFontAtlas, ptr %19, i32 0, i32 13
  %20 = load i32, ptr %TexWidth12, align 8
  %21 = load ptr, ptr %out_pixel, align 8
  %idx.ext13 = sext i32 %20 to i64
  %add.ptr14 = getelementptr inbounds i32, ptr %21, i64 %idx.ext13
  store ptr %add.ptr14, ptr %out_pixel, align 8
  %22 = load i32, ptr %w.addr, align 4
  %23 = load ptr, ptr %in_str.addr, align 8
  %idx.ext15 = sext i32 %22 to i64
  %add.ptr16 = getelementptr inbounds i8, ptr %23, i64 %idx.ext15
  store ptr %add.ptr16, ptr %in_str.addr, align 8
  br label %for.cond, !llvm.loop !72

for.end17:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_Z20ImFontAtlasBuildInitP11ImFontAtlas(ptr noundef %atlas) #4 {
entry:
  %atlas.addr = alloca ptr, align 8
  %__range1 = alloca ptr, align 8
  %__begin1 = alloca ptr, align 8
  %__end1 = alloca ptr, align 8
  %cfg = alloca ptr, align 8
  store ptr %atlas, ptr %atlas.addr, align 8
  %0 = load ptr, ptr %atlas.addr, align 8
  %ConfigData = getelementptr inbounds %struct.ImFontAtlas, ptr %0, i32 0, i32 19
  store ptr %ConfigData, ptr %__range1, align 8
  %1 = load ptr, ptr %__range1, align 8
  %call = call noundef ptr @_ZN8ImVectorI12ImFontConfigE5beginEv(ptr noundef nonnull align 8 dereferenceable(16) %1)
  store ptr %call, ptr %__begin1, align 8
  %2 = load ptr, ptr %__range1, align 8
  %call1 = call noundef ptr @_ZN8ImVectorI12ImFontConfigE3endEv(ptr noundef nonnull align 8 dereferenceable(16) %2)
  store ptr %call1, ptr %__end1, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load ptr, ptr %__begin1, align 8
  %4 = load ptr, ptr %__end1, align 8
  %cmp = icmp ne ptr %3, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %__begin1, align 8
  store ptr %5, ptr %cfg, align 8
  %6 = load ptr, ptr %cfg, align 8
  %SizePixels = getelementptr inbounds %struct.ImFontConfig, ptr %6, i32 0, i32 4
  %7 = load float, ptr %SizePixels, align 4
  %call2 = call noundef float @_ZL7ImTruncf(float noundef %7)
  %8 = load ptr, ptr %cfg, align 8
  %SizePixels3 = getelementptr inbounds %struct.ImFontConfig, ptr %8, i32 0, i32 4
  store float %call2, ptr %SizePixels3, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load ptr, ptr %__begin1, align 8
  %incdec.ptr = getelementptr inbounds %struct.ImFontConfig, ptr %9, i32 1
  store ptr %incdec.ptr, ptr %__begin1, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %10 = load ptr, ptr %atlas.addr, align 8
  %PackIdMouseCursors = getelementptr inbounds %struct.ImFontAtlas, ptr %10, i32 0, i32 23
  %11 = load i32, ptr %PackIdMouseCursors, align 4
  %cmp4 = icmp slt i32 %11, 0
  br i1 %cmp4, label %if.then, label %if.end10

if.then:                                          ; preds = %for.end
  %12 = load ptr, ptr %atlas.addr, align 8
  %Flags = getelementptr inbounds %struct.ImFontAtlas, ptr %12, i32 0, i32 0
  %13 = load i32, ptr %Flags, align 8
  %and = and i32 %13, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.else, label %if.then5

if.then5:                                         ; preds = %if.then
  %14 = load ptr, ptr %atlas.addr, align 8
  %call6 = call noundef i32 @_ZN11ImFontAtlas20AddCustomRectRegularEii(ptr noundef nonnull align 8 dereferenceable(1180) %14, i32 noundef 245, i32 noundef 27)
  %15 = load ptr, ptr %atlas.addr, align 8
  %PackIdMouseCursors7 = getelementptr inbounds %struct.ImFontAtlas, ptr %15, i32 0, i32 23
  store i32 %call6, ptr %PackIdMouseCursors7, align 4
  br label %if.end

if.else:                                          ; preds = %if.then
  %16 = load ptr, ptr %atlas.addr, align 8
  %call8 = call noundef i32 @_ZN11ImFontAtlas20AddCustomRectRegularEii(ptr noundef nonnull align 8 dereferenceable(1180) %16, i32 noundef 2, i32 noundef 2)
  %17 = load ptr, ptr %atlas.addr, align 8
  %PackIdMouseCursors9 = getelementptr inbounds %struct.ImFontAtlas, ptr %17, i32 0, i32 23
  store i32 %call8, ptr %PackIdMouseCursors9, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then5
  br label %if.end10

if.end10:                                         ; preds = %if.end, %for.end
  %18 = load ptr, ptr %atlas.addr, align 8
  %PackIdLines = getelementptr inbounds %struct.ImFontAtlas, ptr %18, i32 0, i32 24
  %19 = load i32, ptr %PackIdLines, align 8
  %cmp11 = icmp slt i32 %19, 0
  br i1 %cmp11, label %if.then12, label %if.end20

if.then12:                                        ; preds = %if.end10
  %20 = load ptr, ptr %atlas.addr, align 8
  %Flags13 = getelementptr inbounds %struct.ImFontAtlas, ptr %20, i32 0, i32 0
  %21 = load i32, ptr %Flags13, align 8
  %and14 = and i32 %21, 4
  %tobool15 = icmp ne i32 %and14, 0
  br i1 %tobool15, label %if.end19, label %if.then16

if.then16:                                        ; preds = %if.then12
  %22 = load ptr, ptr %atlas.addr, align 8
  %call17 = call noundef i32 @_ZN11ImFontAtlas20AddCustomRectRegularEii(ptr noundef nonnull align 8 dereferenceable(1180) %22, i32 noundef 65, i32 noundef 64)
  %23 = load ptr, ptr %atlas.addr, align 8
  %PackIdLines18 = getelementptr inbounds %struct.ImFontAtlas, ptr %23, i32 0, i32 24
  store i32 %call17, ptr %PackIdLines18, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.then16, %if.then12
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.end10
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef float @_ZL7ImTruncf(float noundef %f) #2 {
entry:
  %f.addr = alloca float, align 4
  store float %f, ptr %f.addr, align 4
  %0 = load float, ptr %f.addr, align 4
  %conv = fptosi float %0 to i32
  %conv1 = sitofp i32 %conv to float
  ret float %conv1
}

; Function Attrs: mustprogress uwtable
define void @_Z22ImFontAtlasBuildFinishP11ImFontAtlas(ptr noundef %atlas) #4 {
entry:
  %atlas.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  %r = alloca ptr, align 8
  %uv0 = alloca %struct.ImVec2, align 4
  %uv1 = alloca %struct.ImVec2, align 4
  %__range1 = alloca ptr, align 8
  %__begin1 = alloca ptr, align 8
  %__end1 = alloca ptr, align 8
  %font = alloca ptr, align 8
  store ptr %atlas, ptr %atlas.addr, align 8
  %0 = load ptr, ptr %atlas.addr, align 8
  call void @_ZL36ImFontAtlasBuildRenderDefaultTexDataP11ImFontAtlas(ptr noundef %0)
  %1 = load ptr, ptr %atlas.addr, align 8
  call void @_ZL34ImFontAtlasBuildRenderLinesTexDataP11ImFontAtlas(ptr noundef %1)
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, ptr %i, align 4
  %3 = load ptr, ptr %atlas.addr, align 8
  %CustomRects = getelementptr inbounds %struct.ImFontAtlas, ptr %3, i32 0, i32 18
  %Size = getelementptr inbounds %struct.ImVector.10, ptr %CustomRects, i32 0, i32 0
  %4 = load i32, ptr %Size, align 8
  %cmp = icmp slt i32 %2, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %atlas.addr, align 8
  %CustomRects1 = getelementptr inbounds %struct.ImFontAtlas, ptr %5, i32 0, i32 18
  %6 = load i32, ptr %i, align 4
  %call = call noundef nonnull align 8 dereferenceable(32) ptr @_ZN8ImVectorI21ImFontAtlasCustomRectEixEi(ptr noundef nonnull align 8 dereferenceable(16) %CustomRects1, i32 noundef %6)
  store ptr %call, ptr %r, align 8
  %7 = load ptr, ptr %r, align 8
  %Font = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %7, i32 0, i32 7
  %8 = load ptr, ptr %Font, align 8
  %cmp2 = icmp eq ptr %8, null
  br i1 %cmp2, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %9 = load ptr, ptr %r, align 8
  %GlyphID = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %9, i32 0, i32 4
  %10 = load i32, ptr %GlyphID, align 8
  %cmp3 = icmp eq i32 %10, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %for.body
  br label %for.inc

if.end:                                           ; preds = %lor.lhs.false
  call void @_ZN6ImVec2C2Ev(ptr noundef nonnull align 4 dereferenceable(8) %uv0)
  call void @_ZN6ImVec2C2Ev(ptr noundef nonnull align 4 dereferenceable(8) %uv1)
  %11 = load ptr, ptr %atlas.addr, align 8
  %12 = load ptr, ptr %r, align 8
  call void @_ZNK11ImFontAtlas16CalcCustomRectUVEPK21ImFontAtlasCustomRectP6ImVec2S4_(ptr noundef nonnull align 8 dereferenceable(1180) %11, ptr noundef %12, ptr noundef %uv0, ptr noundef %uv1)
  %13 = load ptr, ptr %r, align 8
  %Font4 = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %13, i32 0, i32 7
  %14 = load ptr, ptr %Font4, align 8
  %15 = load ptr, ptr %r, align 8
  %GlyphID5 = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %15, i32 0, i32 4
  %16 = load i32, ptr %GlyphID5, align 8
  %conv = trunc i32 %16 to i16
  %17 = load ptr, ptr %r, align 8
  %GlyphOffset = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %17, i32 0, i32 6
  %x = getelementptr inbounds %struct.ImVec2, ptr %GlyphOffset, i32 0, i32 0
  %18 = load float, ptr %x, align 8
  %19 = load ptr, ptr %r, align 8
  %GlyphOffset6 = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %19, i32 0, i32 6
  %y = getelementptr inbounds %struct.ImVec2, ptr %GlyphOffset6, i32 0, i32 1
  %20 = load float, ptr %y, align 4
  %21 = load ptr, ptr %r, align 8
  %GlyphOffset7 = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %21, i32 0, i32 6
  %x8 = getelementptr inbounds %struct.ImVec2, ptr %GlyphOffset7, i32 0, i32 0
  %22 = load float, ptr %x8, align 8
  %23 = load ptr, ptr %r, align 8
  %Width = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %23, i32 0, i32 0
  %24 = load i16, ptr %Width, align 8
  %conv9 = zext i16 %24 to i32
  %conv10 = sitofp i32 %conv9 to float
  %add = fadd float %22, %conv10
  %25 = load ptr, ptr %r, align 8
  %GlyphOffset11 = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %25, i32 0, i32 6
  %y12 = getelementptr inbounds %struct.ImVec2, ptr %GlyphOffset11, i32 0, i32 1
  %26 = load float, ptr %y12, align 4
  %27 = load ptr, ptr %r, align 8
  %Height = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %27, i32 0, i32 1
  %28 = load i16, ptr %Height, align 2
  %conv13 = zext i16 %28 to i32
  %conv14 = sitofp i32 %conv13 to float
  %add15 = fadd float %26, %conv14
  %x16 = getelementptr inbounds %struct.ImVec2, ptr %uv0, i32 0, i32 0
  %29 = load float, ptr %x16, align 4
  %y17 = getelementptr inbounds %struct.ImVec2, ptr %uv0, i32 0, i32 1
  %30 = load float, ptr %y17, align 4
  %x18 = getelementptr inbounds %struct.ImVec2, ptr %uv1, i32 0, i32 0
  %31 = load float, ptr %x18, align 4
  %y19 = getelementptr inbounds %struct.ImVec2, ptr %uv1, i32 0, i32 1
  %32 = load float, ptr %y19, align 4
  %33 = load ptr, ptr %r, align 8
  %GlyphAdvanceX = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %33, i32 0, i32 5
  %34 = load float, ptr %GlyphAdvanceX, align 4
  call void @_ZN6ImFont8AddGlyphEPK12ImFontConfigtfffffffff(ptr noundef nonnull align 8 dereferenceable(118) %14, ptr noundef null, i16 noundef zeroext %conv, float noundef %18, float noundef %20, float noundef %add, float noundef %add15, float noundef %29, float noundef %30, float noundef %31, float noundef %32, float noundef %34)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %35 = load i32, ptr %i, align 4
  %inc = add nsw i32 %35, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !73

for.end:                                          ; preds = %for.cond
  %36 = load ptr, ptr %atlas.addr, align 8
  %Fonts = getelementptr inbounds %struct.ImFontAtlas, ptr %36, i32 0, i32 17
  store ptr %Fonts, ptr %__range1, align 8
  %37 = load ptr, ptr %__range1, align 8
  %call20 = call noundef ptr @_ZN8ImVectorIP6ImFontE5beginEv(ptr noundef nonnull align 8 dereferenceable(16) %37)
  store ptr %call20, ptr %__begin1, align 8
  %38 = load ptr, ptr %__range1, align 8
  %call21 = call noundef ptr @_ZN8ImVectorIP6ImFontE3endEv(ptr noundef nonnull align 8 dereferenceable(16) %38)
  store ptr %call21, ptr %__end1, align 8
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc27, %for.end
  %39 = load ptr, ptr %__begin1, align 8
  %40 = load ptr, ptr %__end1, align 8
  %cmp23 = icmp ne ptr %39, %40
  br i1 %cmp23, label %for.body24, label %for.end28

for.body24:                                       ; preds = %for.cond22
  %41 = load ptr, ptr %__begin1, align 8
  %42 = load ptr, ptr %41, align 8
  store ptr %42, ptr %font, align 8
  %43 = load ptr, ptr %font, align 8
  %DirtyLookupTables = getelementptr inbounds %struct.ImFont, ptr %43, i32 0, i32 14
  %44 = load i8, ptr %DirtyLookupTables, align 8
  %tobool = trunc i8 %44 to i1
  br i1 %tobool, label %if.then25, label %if.end26

if.then25:                                        ; preds = %for.body24
  %45 = load ptr, ptr %font, align 8
  call void @_ZN6ImFont16BuildLookupTableEv(ptr noundef nonnull align 8 dereferenceable(118) %45)
  br label %if.end26

if.end26:                                         ; preds = %if.then25, %for.body24
  br label %for.inc27

for.inc27:                                        ; preds = %if.end26
  %46 = load ptr, ptr %__begin1, align 8
  %incdec.ptr = getelementptr inbounds ptr, ptr %46, i32 1
  store ptr %incdec.ptr, ptr %__begin1, align 8
  br label %for.cond22

for.end28:                                        ; preds = %for.cond22
  %47 = load ptr, ptr %atlas.addr, align 8
  %TexReady = getelementptr inbounds %struct.ImFontAtlas, ptr %47, i32 0, i32 8
  store i8 1, ptr %TexReady, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL36ImFontAtlasBuildRenderDefaultTexDataP11ImFontAtlas(ptr noundef %atlas) #4 {
entry:
  %atlas.addr = alloca ptr, align 8
  %r = alloca ptr, align 8
  %w = alloca i32, align 4
  %x_for_white = alloca i32, align 4
  %x_for_black = alloca i32, align 4
  %offset = alloca i32, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  store ptr %atlas, ptr %atlas.addr, align 8
  %0 = load ptr, ptr %atlas.addr, align 8
  %1 = load ptr, ptr %atlas.addr, align 8
  %PackIdMouseCursors = getelementptr inbounds %struct.ImFontAtlas, ptr %1, i32 0, i32 23
  %2 = load i32, ptr %PackIdMouseCursors, align 4
  %call = call noundef ptr @_ZN11ImFontAtlas20GetCustomRectByIndexEi(ptr noundef nonnull align 8 dereferenceable(1180) %0, i32 noundef %2)
  store ptr %call, ptr %r, align 8
  %3 = load ptr, ptr %atlas.addr, align 8
  %TexWidth = getelementptr inbounds %struct.ImFontAtlas, ptr %3, i32 0, i32 13
  %4 = load i32, ptr %TexWidth, align 8
  store i32 %4, ptr %w, align 4
  %5 = load ptr, ptr %atlas.addr, align 8
  %Flags = getelementptr inbounds %struct.ImFontAtlas, ptr %5, i32 0, i32 0
  %6 = load i32, ptr %Flags, align 8
  %and = and i32 %6, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.else12, label %if.then

if.then:                                          ; preds = %entry
  %7 = load ptr, ptr %r, align 8
  %X = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %7, i32 0, i32 2
  %8 = load i16, ptr %X, align 4
  %conv = zext i16 %8 to i32
  store i32 %conv, ptr %x_for_white, align 4
  %9 = load ptr, ptr %r, align 8
  %X1 = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %9, i32 0, i32 2
  %10 = load i16, ptr %X1, align 4
  %conv2 = zext i16 %10 to i32
  %add = add nsw i32 %conv2, 122
  %add3 = add nsw i32 %add, 1
  store i32 %add3, ptr %x_for_black, align 4
  %11 = load ptr, ptr %atlas.addr, align 8
  %TexPixelsAlpha8 = getelementptr inbounds %struct.ImFontAtlas, ptr %11, i32 0, i32 11
  %12 = load ptr, ptr %TexPixelsAlpha8, align 8
  %cmp = icmp ne ptr %12, null
  br i1 %cmp, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.then
  %13 = load ptr, ptr %atlas.addr, align 8
  %14 = load i32, ptr %x_for_white, align 4
  %15 = load ptr, ptr %r, align 8
  %Y = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %15, i32 0, i32 3
  %16 = load i16, ptr %Y, align 2
  %conv5 = zext i16 %16 to i32
  call void @_Z40ImFontAtlasBuildRender8bppRectFromStringP11ImFontAtlasiiiiPKcch(ptr noundef %13, i32 noundef %14, i32 noundef %conv5, i32 noundef 122, i32 noundef 27, ptr noundef @_ZL34FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, i8 noundef signext 46, i8 noundef zeroext -1)
  %17 = load ptr, ptr %atlas.addr, align 8
  %18 = load i32, ptr %x_for_black, align 4
  %19 = load ptr, ptr %r, align 8
  %Y6 = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %19, i32 0, i32 3
  %20 = load i16, ptr %Y6, align 2
  %conv7 = zext i16 %20 to i32
  call void @_Z40ImFontAtlasBuildRender8bppRectFromStringP11ImFontAtlasiiiiPKcch(ptr noundef %17, i32 noundef %18, i32 noundef %conv7, i32 noundef 122, i32 noundef 27, ptr noundef @_ZL34FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, i8 noundef signext 88, i8 noundef zeroext -1)
  br label %if.end

if.else:                                          ; preds = %if.then
  %21 = load ptr, ptr %atlas.addr, align 8
  %22 = load i32, ptr %x_for_white, align 4
  %23 = load ptr, ptr %r, align 8
  %Y8 = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %23, i32 0, i32 3
  %24 = load i16, ptr %Y8, align 2
  %conv9 = zext i16 %24 to i32
  call void @_Z41ImFontAtlasBuildRender32bppRectFromStringP11ImFontAtlasiiiiPKccj(ptr noundef %21, i32 noundef %22, i32 noundef %conv9, i32 noundef 122, i32 noundef 27, ptr noundef @_ZL34FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, i8 noundef signext 46, i32 noundef -1)
  %25 = load ptr, ptr %atlas.addr, align 8
  %26 = load i32, ptr %x_for_black, align 4
  %27 = load ptr, ptr %r, align 8
  %Y10 = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %27, i32 0, i32 3
  %28 = load i16, ptr %Y10, align 2
  %conv11 = zext i16 %28 to i32
  call void @_Z41ImFontAtlasBuildRender32bppRectFromStringP11ImFontAtlasiiiiPKccj(ptr noundef %25, i32 noundef %26, i32 noundef %conv11, i32 noundef 122, i32 noundef 27, ptr noundef @_ZL34FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, i8 noundef signext 88, i32 noundef -1)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then4
  br label %if.end52

if.else12:                                        ; preds = %entry
  %29 = load ptr, ptr %r, align 8
  %X13 = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %29, i32 0, i32 2
  %30 = load i16, ptr %X13, align 4
  %conv14 = zext i16 %30 to i32
  %31 = load ptr, ptr %r, align 8
  %Y15 = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %31, i32 0, i32 3
  %32 = load i16, ptr %Y15, align 2
  %conv16 = zext i16 %32 to i32
  %33 = load i32, ptr %w, align 4
  %mul = mul nsw i32 %conv16, %33
  %add17 = add nsw i32 %conv14, %mul
  store i32 %add17, ptr %offset, align 4
  %34 = load ptr, ptr %atlas.addr, align 8
  %TexPixelsAlpha818 = getelementptr inbounds %struct.ImFontAtlas, ptr %34, i32 0, i32 11
  %35 = load ptr, ptr %TexPixelsAlpha818, align 8
  %cmp19 = icmp ne ptr %35, null
  br i1 %cmp19, label %if.then20, label %if.else35

if.then20:                                        ; preds = %if.else12
  %36 = load ptr, ptr %atlas.addr, align 8
  %TexPixelsAlpha821 = getelementptr inbounds %struct.ImFontAtlas, ptr %36, i32 0, i32 11
  %37 = load ptr, ptr %TexPixelsAlpha821, align 8
  %38 = load i32, ptr %offset, align 4
  %39 = load i32, ptr %w, align 4
  %add22 = add nsw i32 %38, %39
  %add23 = add nsw i32 %add22, 1
  %idxprom = sext i32 %add23 to i64
  %arrayidx = getelementptr inbounds i8, ptr %37, i64 %idxprom
  store i8 -1, ptr %arrayidx, align 1
  %40 = load ptr, ptr %atlas.addr, align 8
  %TexPixelsAlpha824 = getelementptr inbounds %struct.ImFontAtlas, ptr %40, i32 0, i32 11
  %41 = load ptr, ptr %TexPixelsAlpha824, align 8
  %42 = load i32, ptr %offset, align 4
  %43 = load i32, ptr %w, align 4
  %add25 = add nsw i32 %42, %43
  %idxprom26 = sext i32 %add25 to i64
  %arrayidx27 = getelementptr inbounds i8, ptr %41, i64 %idxprom26
  store i8 -1, ptr %arrayidx27, align 1
  %44 = load ptr, ptr %atlas.addr, align 8
  %TexPixelsAlpha828 = getelementptr inbounds %struct.ImFontAtlas, ptr %44, i32 0, i32 11
  %45 = load ptr, ptr %TexPixelsAlpha828, align 8
  %46 = load i32, ptr %offset, align 4
  %add29 = add nsw i32 %46, 1
  %idxprom30 = sext i32 %add29 to i64
  %arrayidx31 = getelementptr inbounds i8, ptr %45, i64 %idxprom30
  store i8 -1, ptr %arrayidx31, align 1
  %47 = load ptr, ptr %atlas.addr, align 8
  %TexPixelsAlpha832 = getelementptr inbounds %struct.ImFontAtlas, ptr %47, i32 0, i32 11
  %48 = load ptr, ptr %TexPixelsAlpha832, align 8
  %49 = load i32, ptr %offset, align 4
  %idxprom33 = sext i32 %49 to i64
  %arrayidx34 = getelementptr inbounds i8, ptr %48, i64 %idxprom33
  store i8 -1, ptr %arrayidx34, align 1
  br label %if.end51

if.else35:                                        ; preds = %if.else12
  %50 = load ptr, ptr %atlas.addr, align 8
  %TexPixelsRGBA32 = getelementptr inbounds %struct.ImFontAtlas, ptr %50, i32 0, i32 12
  %51 = load ptr, ptr %TexPixelsRGBA32, align 8
  %52 = load i32, ptr %offset, align 4
  %53 = load i32, ptr %w, align 4
  %add36 = add nsw i32 %52, %53
  %add37 = add nsw i32 %add36, 1
  %idxprom38 = sext i32 %add37 to i64
  %arrayidx39 = getelementptr inbounds i32, ptr %51, i64 %idxprom38
  store i32 -1, ptr %arrayidx39, align 4
  %54 = load ptr, ptr %atlas.addr, align 8
  %TexPixelsRGBA3240 = getelementptr inbounds %struct.ImFontAtlas, ptr %54, i32 0, i32 12
  %55 = load ptr, ptr %TexPixelsRGBA3240, align 8
  %56 = load i32, ptr %offset, align 4
  %57 = load i32, ptr %w, align 4
  %add41 = add nsw i32 %56, %57
  %idxprom42 = sext i32 %add41 to i64
  %arrayidx43 = getelementptr inbounds i32, ptr %55, i64 %idxprom42
  store i32 -1, ptr %arrayidx43, align 4
  %58 = load ptr, ptr %atlas.addr, align 8
  %TexPixelsRGBA3244 = getelementptr inbounds %struct.ImFontAtlas, ptr %58, i32 0, i32 12
  %59 = load ptr, ptr %TexPixelsRGBA3244, align 8
  %60 = load i32, ptr %offset, align 4
  %add45 = add nsw i32 %60, 1
  %idxprom46 = sext i32 %add45 to i64
  %arrayidx47 = getelementptr inbounds i32, ptr %59, i64 %idxprom46
  store i32 -1, ptr %arrayidx47, align 4
  %61 = load ptr, ptr %atlas.addr, align 8
  %TexPixelsRGBA3248 = getelementptr inbounds %struct.ImFontAtlas, ptr %61, i32 0, i32 12
  %62 = load ptr, ptr %TexPixelsRGBA3248, align 8
  %63 = load i32, ptr %offset, align 4
  %idxprom49 = sext i32 %63 to i64
  %arrayidx50 = getelementptr inbounds i32, ptr %62, i64 %idxprom49
  store i32 -1, ptr %arrayidx50, align 4
  br label %if.end51

if.end51:                                         ; preds = %if.else35, %if.then20
  br label %if.end52

if.end52:                                         ; preds = %if.end51, %if.end
  %64 = load ptr, ptr %r, align 8
  %X53 = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %64, i32 0, i32 2
  %65 = load i16, ptr %X53, align 4
  %conv54 = zext i16 %65 to i32
  %conv55 = sitofp i32 %conv54 to float
  %add56 = fadd float %conv55, 5.000000e-01
  %66 = load ptr, ptr %atlas.addr, align 8
  %TexUvScale = getelementptr inbounds %struct.ImFontAtlas, ptr %66, i32 0, i32 15
  %x = getelementptr inbounds %struct.ImVec2, ptr %TexUvScale, i32 0, i32 0
  %67 = load float, ptr %x, align 8
  %mul57 = fmul float %add56, %67
  %68 = load ptr, ptr %r, align 8
  %Y58 = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %68, i32 0, i32 3
  %69 = load i16, ptr %Y58, align 2
  %conv59 = zext i16 %69 to i32
  %conv60 = sitofp i32 %conv59 to float
  %add61 = fadd float %conv60, 5.000000e-01
  %70 = load ptr, ptr %atlas.addr, align 8
  %TexUvScale62 = getelementptr inbounds %struct.ImFontAtlas, ptr %70, i32 0, i32 15
  %y = getelementptr inbounds %struct.ImVec2, ptr %TexUvScale62, i32 0, i32 1
  %71 = load float, ptr %y, align 4
  %mul63 = fmul float %add61, %71
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef %mul57, float noundef %mul63)
  %72 = load ptr, ptr %atlas.addr, align 8
  %TexUvWhitePixel = getelementptr inbounds %struct.ImFontAtlas, ptr %72, i32 0, i32 16
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %TexUvWhitePixel, ptr align 4 %ref.tmp, i64 8, i1 false)
  ret void
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL34ImFontAtlasBuildRenderLinesTexDataP11ImFontAtlas(ptr noundef %atlas) #0 {
entry:
  %atlas.addr = alloca ptr, align 8
  %r = alloca ptr, align 8
  %n = alloca i32, align 4
  %y = alloca i32, align 4
  %line_width = alloca i32, align 4
  %pad_left = alloca i32, align 4
  %pad_right = alloca i32, align 4
  %write_ptr = alloca ptr, align 8
  %i = alloca i32, align 4
  %i14 = alloca i32, align 4
  %i25 = alloca i32, align 4
  %write_ptr38 = alloca ptr, align 8
  %i49 = alloca i32, align 4
  %i58 = alloca i32, align 4
  %i69 = alloca i32, align 4
  %uv0 = alloca %struct.ImVec2, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  %uv1 = alloca %struct.ImVec2, align 4
  %ref.tmp93 = alloca %struct.ImVec2, align 4
  %half_v = alloca float, align 4
  %ref.tmp111 = alloca %struct.ImVec4, align 4
  store ptr %atlas, ptr %atlas.addr, align 8
  %0 = load ptr, ptr %atlas.addr, align 8
  %Flags = getelementptr inbounds %struct.ImFontAtlas, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %Flags, align 8
  %and = and i32 %1, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %for.end117

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %atlas.addr, align 8
  %3 = load ptr, ptr %atlas.addr, align 8
  %PackIdLines = getelementptr inbounds %struct.ImFontAtlas, ptr %3, i32 0, i32 24
  %4 = load i32, ptr %PackIdLines, align 8
  %call = call noundef ptr @_ZN11ImFontAtlas20GetCustomRectByIndexEi(ptr noundef nonnull align 8 dereferenceable(1180) %2, i32 noundef %4)
  store ptr %call, ptr %r, align 8
  store i32 0, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc115, %if.end
  %5 = load i32, ptr %n, align 4
  %cmp = icmp ult i32 %5, 64
  br i1 %cmp, label %for.body, label %for.end117

for.body:                                         ; preds = %for.cond
  %6 = load i32, ptr %n, align 4
  store i32 %6, ptr %y, align 4
  %7 = load i32, ptr %n, align 4
  store i32 %7, ptr %line_width, align 4
  %8 = load ptr, ptr %r, align 8
  %Width = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %8, i32 0, i32 0
  %9 = load i16, ptr %Width, align 8
  %conv = zext i16 %9 to i32
  %10 = load i32, ptr %line_width, align 4
  %sub = sub i32 %conv, %10
  %div = udiv i32 %sub, 2
  store i32 %div, ptr %pad_left, align 4
  %11 = load ptr, ptr %r, align 8
  %Width1 = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %11, i32 0, i32 0
  %12 = load i16, ptr %Width1, align 8
  %conv2 = zext i16 %12 to i32
  %13 = load i32, ptr %pad_left, align 4
  %14 = load i32, ptr %line_width, align 4
  %add = add i32 %13, %14
  %sub3 = sub i32 %conv2, %add
  store i32 %sub3, ptr %pad_right, align 4
  %15 = load ptr, ptr %atlas.addr, align 8
  %TexPixelsAlpha8 = getelementptr inbounds %struct.ImFontAtlas, ptr %15, i32 0, i32 11
  %16 = load ptr, ptr %TexPixelsAlpha8, align 8
  %cmp4 = icmp ne ptr %16, null
  br i1 %cmp4, label %if.then5, label %if.else

if.then5:                                         ; preds = %for.body
  %17 = load ptr, ptr %atlas.addr, align 8
  %TexPixelsAlpha86 = getelementptr inbounds %struct.ImFontAtlas, ptr %17, i32 0, i32 11
  %18 = load ptr, ptr %TexPixelsAlpha86, align 8
  %19 = load ptr, ptr %r, align 8
  %X = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %19, i32 0, i32 2
  %20 = load i16, ptr %X, align 4
  %conv7 = zext i16 %20 to i32
  %21 = load ptr, ptr %r, align 8
  %Y = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %21, i32 0, i32 3
  %22 = load i16, ptr %Y, align 2
  %conv8 = zext i16 %22 to i32
  %23 = load i32, ptr %y, align 4
  %add9 = add i32 %conv8, %23
  %24 = load ptr, ptr %atlas.addr, align 8
  %TexWidth = getelementptr inbounds %struct.ImFontAtlas, ptr %24, i32 0, i32 13
  %25 = load i32, ptr %TexWidth, align 8
  %mul = mul i32 %add9, %25
  %add10 = add i32 %conv7, %mul
  %idxprom = zext i32 %add10 to i64
  %arrayidx = getelementptr inbounds i8, ptr %18, i64 %idxprom
  store ptr %arrayidx, ptr %write_ptr, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond11

for.cond11:                                       ; preds = %for.inc, %if.then5
  %26 = load i32, ptr %i, align 4
  %27 = load i32, ptr %pad_left, align 4
  %cmp12 = icmp ult i32 %26, %27
  br i1 %cmp12, label %for.body13, label %for.end

for.body13:                                       ; preds = %for.cond11
  %28 = load ptr, ptr %write_ptr, align 8
  %29 = load i32, ptr %i, align 4
  %idx.ext = zext i32 %29 to i64
  %add.ptr = getelementptr inbounds i8, ptr %28, i64 %idx.ext
  store i8 0, ptr %add.ptr, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body13
  %30 = load i32, ptr %i, align 4
  %inc = add i32 %30, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond11, !llvm.loop !74

for.end:                                          ; preds = %for.cond11
  store i32 0, ptr %i14, align 4
  br label %for.cond15

for.cond15:                                       ; preds = %for.inc22, %for.end
  %31 = load i32, ptr %i14, align 4
  %32 = load i32, ptr %line_width, align 4
  %cmp16 = icmp ult i32 %31, %32
  br i1 %cmp16, label %for.body17, label %for.end24

for.body17:                                       ; preds = %for.cond15
  %33 = load ptr, ptr %write_ptr, align 8
  %34 = load i32, ptr %pad_left, align 4
  %idx.ext18 = zext i32 %34 to i64
  %add.ptr19 = getelementptr inbounds i8, ptr %33, i64 %idx.ext18
  %35 = load i32, ptr %i14, align 4
  %idx.ext20 = zext i32 %35 to i64
  %add.ptr21 = getelementptr inbounds i8, ptr %add.ptr19, i64 %idx.ext20
  store i8 -1, ptr %add.ptr21, align 1
  br label %for.inc22

for.inc22:                                        ; preds = %for.body17
  %36 = load i32, ptr %i14, align 4
  %inc23 = add i32 %36, 1
  store i32 %inc23, ptr %i14, align 4
  br label %for.cond15, !llvm.loop !75

for.end24:                                        ; preds = %for.cond15
  store i32 0, ptr %i25, align 4
  br label %for.cond26

for.cond26:                                       ; preds = %for.inc35, %for.end24
  %37 = load i32, ptr %i25, align 4
  %38 = load i32, ptr %pad_right, align 4
  %cmp27 = icmp ult i32 %37, %38
  br i1 %cmp27, label %for.body28, label %for.end37

for.body28:                                       ; preds = %for.cond26
  %39 = load ptr, ptr %write_ptr, align 8
  %40 = load i32, ptr %pad_left, align 4
  %idx.ext29 = zext i32 %40 to i64
  %add.ptr30 = getelementptr inbounds i8, ptr %39, i64 %idx.ext29
  %41 = load i32, ptr %line_width, align 4
  %idx.ext31 = zext i32 %41 to i64
  %add.ptr32 = getelementptr inbounds i8, ptr %add.ptr30, i64 %idx.ext31
  %42 = load i32, ptr %i25, align 4
  %idx.ext33 = zext i32 %42 to i64
  %add.ptr34 = getelementptr inbounds i8, ptr %add.ptr32, i64 %idx.ext33
  store i8 0, ptr %add.ptr34, align 1
  br label %for.inc35

for.inc35:                                        ; preds = %for.body28
  %43 = load i32, ptr %i25, align 4
  %inc36 = add i32 %43, 1
  store i32 %inc36, ptr %i25, align 4
  br label %for.cond26, !llvm.loop !76

for.end37:                                        ; preds = %for.cond26
  br label %if.end82

if.else:                                          ; preds = %for.body
  %44 = load ptr, ptr %atlas.addr, align 8
  %TexPixelsRGBA32 = getelementptr inbounds %struct.ImFontAtlas, ptr %44, i32 0, i32 12
  %45 = load ptr, ptr %TexPixelsRGBA32, align 8
  %46 = load ptr, ptr %r, align 8
  %X39 = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %46, i32 0, i32 2
  %47 = load i16, ptr %X39, align 4
  %conv40 = zext i16 %47 to i32
  %48 = load ptr, ptr %r, align 8
  %Y41 = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %48, i32 0, i32 3
  %49 = load i16, ptr %Y41, align 2
  %conv42 = zext i16 %49 to i32
  %50 = load i32, ptr %y, align 4
  %add43 = add i32 %conv42, %50
  %51 = load ptr, ptr %atlas.addr, align 8
  %TexWidth44 = getelementptr inbounds %struct.ImFontAtlas, ptr %51, i32 0, i32 13
  %52 = load i32, ptr %TexWidth44, align 8
  %mul45 = mul i32 %add43, %52
  %add46 = add i32 %conv40, %mul45
  %idxprom47 = zext i32 %add46 to i64
  %arrayidx48 = getelementptr inbounds i32, ptr %45, i64 %idxprom47
  store ptr %arrayidx48, ptr %write_ptr38, align 8
  store i32 0, ptr %i49, align 4
  br label %for.cond50

for.cond50:                                       ; preds = %for.inc55, %if.else
  %53 = load i32, ptr %i49, align 4
  %54 = load i32, ptr %pad_left, align 4
  %cmp51 = icmp ult i32 %53, %54
  br i1 %cmp51, label %for.body52, label %for.end57

for.body52:                                       ; preds = %for.cond50
  %55 = load ptr, ptr %write_ptr38, align 8
  %56 = load i32, ptr %i49, align 4
  %idx.ext53 = zext i32 %56 to i64
  %add.ptr54 = getelementptr inbounds i32, ptr %55, i64 %idx.ext53
  store i32 16777215, ptr %add.ptr54, align 4
  br label %for.inc55

for.inc55:                                        ; preds = %for.body52
  %57 = load i32, ptr %i49, align 4
  %inc56 = add i32 %57, 1
  store i32 %inc56, ptr %i49, align 4
  br label %for.cond50, !llvm.loop !77

for.end57:                                        ; preds = %for.cond50
  store i32 0, ptr %i58, align 4
  br label %for.cond59

for.cond59:                                       ; preds = %for.inc66, %for.end57
  %58 = load i32, ptr %i58, align 4
  %59 = load i32, ptr %line_width, align 4
  %cmp60 = icmp ult i32 %58, %59
  br i1 %cmp60, label %for.body61, label %for.end68

for.body61:                                       ; preds = %for.cond59
  %60 = load ptr, ptr %write_ptr38, align 8
  %61 = load i32, ptr %pad_left, align 4
  %idx.ext62 = zext i32 %61 to i64
  %add.ptr63 = getelementptr inbounds i32, ptr %60, i64 %idx.ext62
  %62 = load i32, ptr %i58, align 4
  %idx.ext64 = zext i32 %62 to i64
  %add.ptr65 = getelementptr inbounds i32, ptr %add.ptr63, i64 %idx.ext64
  store i32 -1, ptr %add.ptr65, align 4
  br label %for.inc66

for.inc66:                                        ; preds = %for.body61
  %63 = load i32, ptr %i58, align 4
  %inc67 = add i32 %63, 1
  store i32 %inc67, ptr %i58, align 4
  br label %for.cond59, !llvm.loop !78

for.end68:                                        ; preds = %for.cond59
  store i32 0, ptr %i69, align 4
  br label %for.cond70

for.cond70:                                       ; preds = %for.inc79, %for.end68
  %64 = load i32, ptr %i69, align 4
  %65 = load i32, ptr %pad_right, align 4
  %cmp71 = icmp ult i32 %64, %65
  br i1 %cmp71, label %for.body72, label %for.end81

for.body72:                                       ; preds = %for.cond70
  %66 = load ptr, ptr %write_ptr38, align 8
  %67 = load i32, ptr %pad_left, align 4
  %idx.ext73 = zext i32 %67 to i64
  %add.ptr74 = getelementptr inbounds i32, ptr %66, i64 %idx.ext73
  %68 = load i32, ptr %line_width, align 4
  %idx.ext75 = zext i32 %68 to i64
  %add.ptr76 = getelementptr inbounds i32, ptr %add.ptr74, i64 %idx.ext75
  %69 = load i32, ptr %i69, align 4
  %idx.ext77 = zext i32 %69 to i64
  %add.ptr78 = getelementptr inbounds i32, ptr %add.ptr76, i64 %idx.ext77
  store i32 16777215, ptr %add.ptr78, align 4
  br label %for.inc79

for.inc79:                                        ; preds = %for.body72
  %70 = load i32, ptr %i69, align 4
  %inc80 = add i32 %70, 1
  store i32 %inc80, ptr %i69, align 4
  br label %for.cond70, !llvm.loop !79

for.end81:                                        ; preds = %for.cond70
  br label %if.end82

if.end82:                                         ; preds = %for.end81, %for.end37
  %71 = load ptr, ptr %r, align 8
  %X83 = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %71, i32 0, i32 2
  %72 = load i16, ptr %X83, align 4
  %conv84 = zext i16 %72 to i32
  %73 = load i32, ptr %pad_left, align 4
  %add85 = add i32 %conv84, %73
  %sub86 = sub i32 %add85, 1
  %conv87 = uitofp i32 %sub86 to float
  %74 = load ptr, ptr %r, align 8
  %Y88 = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %74, i32 0, i32 3
  %75 = load i16, ptr %Y88, align 2
  %conv89 = zext i16 %75 to i32
  %76 = load i32, ptr %y, align 4
  %add90 = add i32 %conv89, %76
  %conv91 = uitofp i32 %add90 to float
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef %conv87, float noundef %conv91)
  %77 = load ptr, ptr %atlas.addr, align 8
  %TexUvScale = getelementptr inbounds %struct.ImFontAtlas, ptr %77, i32 0, i32 15
  %call92 = call <2 x float> @_ZmlRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(8) %TexUvScale)
  store <2 x float> %call92, ptr %uv0, align 4
  %78 = load ptr, ptr %r, align 8
  %X94 = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %78, i32 0, i32 2
  %79 = load i16, ptr %X94, align 4
  %conv95 = zext i16 %79 to i32
  %80 = load i32, ptr %pad_left, align 4
  %add96 = add i32 %conv95, %80
  %81 = load i32, ptr %line_width, align 4
  %add97 = add i32 %add96, %81
  %add98 = add i32 %add97, 1
  %conv99 = uitofp i32 %add98 to float
  %82 = load ptr, ptr %r, align 8
  %Y100 = getelementptr inbounds %struct.ImFontAtlasCustomRect, ptr %82, i32 0, i32 3
  %83 = load i16, ptr %Y100, align 2
  %conv101 = zext i16 %83 to i32
  %84 = load i32, ptr %y, align 4
  %add102 = add i32 %conv101, %84
  %add103 = add i32 %add102, 1
  %conv104 = uitofp i32 %add103 to float
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp93, float noundef %conv99, float noundef %conv104)
  %85 = load ptr, ptr %atlas.addr, align 8
  %TexUvScale105 = getelementptr inbounds %struct.ImFontAtlas, ptr %85, i32 0, i32 15
  %call106 = call <2 x float> @_ZmlRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp93, ptr noundef nonnull align 4 dereferenceable(8) %TexUvScale105)
  store <2 x float> %call106, ptr %uv1, align 4
  %y107 = getelementptr inbounds %struct.ImVec2, ptr %uv0, i32 0, i32 1
  %86 = load float, ptr %y107, align 4
  %y108 = getelementptr inbounds %struct.ImVec2, ptr %uv1, i32 0, i32 1
  %87 = load float, ptr %y108, align 4
  %add109 = fadd float %86, %87
  %mul110 = fmul float %add109, 5.000000e-01
  store float %mul110, ptr %half_v, align 4
  %x = getelementptr inbounds %struct.ImVec2, ptr %uv0, i32 0, i32 0
  %88 = load float, ptr %x, align 4
  %89 = load float, ptr %half_v, align 4
  %x112 = getelementptr inbounds %struct.ImVec2, ptr %uv1, i32 0, i32 0
  %90 = load float, ptr %x112, align 4
  %91 = load float, ptr %half_v, align 4
  call void @_ZN6ImVec4C2Effff(ptr noundef nonnull align 4 dereferenceable(16) %ref.tmp111, float noundef %88, float noundef %89, float noundef %90, float noundef %91)
  %92 = load ptr, ptr %atlas.addr, align 8
  %TexUvLines = getelementptr inbounds %struct.ImFontAtlas, ptr %92, i32 0, i32 20
  %93 = load i32, ptr %n, align 4
  %idxprom113 = zext i32 %93 to i64
  %arrayidx114 = getelementptr inbounds [64 x %struct.ImVec4], ptr %TexUvLines, i64 0, i64 %idxprom113
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arrayidx114, ptr align 4 %ref.tmp111, i64 16, i1 false)
  br label %for.inc115

for.inc115:                                       ; preds = %if.end82
  %94 = load i32, ptr %n, align 4
  %inc116 = add i32 %94, 1
  store i32 %inc116, ptr %n, align 4
  br label %for.cond, !llvm.loop !80

for.end117:                                       ; preds = %for.cond, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN6ImFont8AddGlyphEPK12ImFontConfigtfffffffff(ptr noundef nonnull align 8 dereferenceable(118) %this, ptr noundef %cfg, i16 noundef zeroext %codepoint, float noundef %x0, float noundef %y0, float noundef %x1, float noundef %y1, float noundef %u0, float noundef %v0, float noundef %u1, float noundef %v1, float noundef %advance_x) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %cfg.addr = alloca ptr, align 8
  %codepoint.addr = alloca i16, align 2
  %x0.addr = alloca float, align 4
  %y0.addr = alloca float, align 4
  %x1.addr = alloca float, align 4
  %y1.addr = alloca float, align 4
  %u0.addr = alloca float, align 4
  %v0.addr = alloca float, align 4
  %u1.addr = alloca float, align 4
  %v1.addr = alloca float, align 4
  %advance_x.addr = alloca float, align 4
  %advance_x_original = alloca float, align 4
  %char_off_x = alloca float, align 4
  %glyph = alloca ptr, align 8
  %pad = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %cfg, ptr %cfg.addr, align 8
  store i16 %codepoint, ptr %codepoint.addr, align 2
  store float %x0, ptr %x0.addr, align 4
  store float %y0, ptr %y0.addr, align 4
  store float %x1, ptr %x1.addr, align 4
  store float %y1, ptr %y1.addr, align 4
  store float %u0, ptr %u0.addr, align 4
  store float %v0, ptr %v0.addr, align 4
  store float %u1, ptr %u1.addr, align 4
  store float %v1, ptr %v1.addr, align 4
  store float %advance_x, ptr %advance_x.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %cfg.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end15

if.then:                                          ; preds = %entry
  %1 = load float, ptr %advance_x.addr, align 4
  store float %1, ptr %advance_x_original, align 4
  %2 = load float, ptr %advance_x.addr, align 4
  %3 = load ptr, ptr %cfg.addr, align 8
  %GlyphMinAdvanceX = getelementptr inbounds %struct.ImFontConfig, ptr %3, i32 0, i32 11
  %4 = load float, ptr %GlyphMinAdvanceX, align 8
  %5 = load ptr, ptr %cfg.addr, align 8
  %GlyphMaxAdvanceX = getelementptr inbounds %struct.ImFontConfig, ptr %5, i32 0, i32 12
  %6 = load float, ptr %GlyphMaxAdvanceX, align 4
  %call = call noundef float @_ZL7ImClampIfET_S0_S0_S0_(float noundef %2, float noundef %4, float noundef %6)
  store float %call, ptr %advance_x.addr, align 4
  %7 = load float, ptr %advance_x.addr, align 4
  %8 = load float, ptr %advance_x_original, align 4
  %cmp2 = fcmp une float %7, %8
  br i1 %cmp2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %9 = load ptr, ptr %cfg.addr, align 8
  %PixelSnapH = getelementptr inbounds %struct.ImFontConfig, ptr %9, i32 0, i32 7
  %10 = load i8, ptr %PixelSnapH, align 8
  %tobool = trunc i8 %10 to i1
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then3
  %11 = load float, ptr %advance_x.addr, align 4
  %12 = load float, ptr %advance_x_original, align 4
  %sub = fsub float %11, %12
  %mul = fmul float %sub, 5.000000e-01
  %call4 = call noundef float @_ZL7ImTruncf(float noundef %mul)
  br label %cond.end

cond.false:                                       ; preds = %if.then3
  %13 = load float, ptr %advance_x.addr, align 4
  %14 = load float, ptr %advance_x_original, align 4
  %sub5 = fsub float %13, %14
  %mul6 = fmul float %sub5, 5.000000e-01
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %call4, %cond.true ], [ %mul6, %cond.false ]
  store float %cond, ptr %char_off_x, align 4
  %15 = load float, ptr %char_off_x, align 4
  %16 = load float, ptr %x0.addr, align 4
  %add = fadd float %16, %15
  store float %add, ptr %x0.addr, align 4
  %17 = load float, ptr %char_off_x, align 4
  %18 = load float, ptr %x1.addr, align 4
  %add7 = fadd float %18, %17
  store float %add7, ptr %x1.addr, align 4
  br label %if.end

if.end:                                           ; preds = %cond.end, %if.then
  %19 = load ptr, ptr %cfg.addr, align 8
  %PixelSnapH8 = getelementptr inbounds %struct.ImFontConfig, ptr %19, i32 0, i32 7
  %20 = load i8, ptr %PixelSnapH8, align 8
  %tobool9 = trunc i8 %20 to i1
  br i1 %tobool9, label %if.then10, label %if.end13

if.then10:                                        ; preds = %if.end
  %21 = load float, ptr %advance_x.addr, align 4
  %add11 = fadd float %21, 5.000000e-01
  %conv = fptosi float %add11 to i32
  %conv12 = sitofp i32 %conv to float
  store float %conv12, ptr %advance_x.addr, align 4
  br label %if.end13

if.end13:                                         ; preds = %if.then10, %if.end
  %22 = load ptr, ptr %cfg.addr, align 8
  %GlyphExtraSpacing = getelementptr inbounds %struct.ImFontConfig, ptr %22, i32 0, i32 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %GlyphExtraSpacing, i32 0, i32 0
  %23 = load float, ptr %x, align 4
  %24 = load float, ptr %advance_x.addr, align 4
  %add14 = fadd float %24, %23
  store float %add14, ptr %advance_x.addr, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.end13, %entry
  %Glyphs = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 4
  %Glyphs16 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 4
  %Size = getelementptr inbounds %struct.ImVector.7, ptr %Glyphs16, i32 0, i32 0
  %25 = load i32, ptr %Size, align 8
  %add17 = add nsw i32 %25, 1
  call void @_ZN8ImVectorI11ImFontGlyphE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %Glyphs, i32 noundef %add17)
  %Glyphs18 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 4
  %call19 = call noundef nonnull align 4 dereferenceable(40) ptr @_ZN8ImVectorI11ImFontGlyphE4backEv(ptr noundef nonnull align 8 dereferenceable(16) %Glyphs18)
  store ptr %call19, ptr %glyph, align 8
  %26 = load i16, ptr %codepoint.addr, align 2
  %conv20 = zext i16 %26 to i32
  %27 = load ptr, ptr %glyph, align 8
  %bf.load = load i32, ptr %27, align 4
  %bf.value = and i32 %conv20, 1073741823
  %bf.shl = shl i32 %bf.value, 2
  %bf.clear = and i32 %bf.load, 3
  %bf.set = or i32 %bf.clear, %bf.shl
  store i32 %bf.set, ptr %27, align 4
  %28 = load float, ptr %x0.addr, align 4
  %29 = load float, ptr %x1.addr, align 4
  %cmp21 = fcmp une float %28, %29
  br i1 %cmp21, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end15
  %30 = load float, ptr %y0.addr, align 4
  %31 = load float, ptr %y1.addr, align 4
  %cmp22 = fcmp une float %30, %31
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end15
  %32 = phi i1 [ false, %if.end15 ], [ %cmp22, %land.rhs ]
  %conv23 = zext i1 %32 to i32
  %33 = load ptr, ptr %glyph, align 8
  %bf.load24 = load i32, ptr %33, align 4
  %bf.value25 = and i32 %conv23, 1
  %bf.shl26 = shl i32 %bf.value25, 1
  %bf.clear27 = and i32 %bf.load24, -3
  %bf.set28 = or i32 %bf.clear27, %bf.shl26
  store i32 %bf.set28, ptr %33, align 4
  %34 = load ptr, ptr %glyph, align 8
  %bf.load29 = load i32, ptr %34, align 4
  %bf.clear30 = and i32 %bf.load29, -2
  %bf.set31 = or i32 %bf.clear30, 0
  store i32 %bf.set31, ptr %34, align 4
  %35 = load float, ptr %x0.addr, align 4
  %36 = load ptr, ptr %glyph, align 8
  %X0 = getelementptr inbounds %struct.ImFontGlyph, ptr %36, i32 0, i32 2
  store float %35, ptr %X0, align 4
  %37 = load float, ptr %y0.addr, align 4
  %38 = load ptr, ptr %glyph, align 8
  %Y0 = getelementptr inbounds %struct.ImFontGlyph, ptr %38, i32 0, i32 3
  store float %37, ptr %Y0, align 4
  %39 = load float, ptr %x1.addr, align 4
  %40 = load ptr, ptr %glyph, align 8
  %X1 = getelementptr inbounds %struct.ImFontGlyph, ptr %40, i32 0, i32 4
  store float %39, ptr %X1, align 4
  %41 = load float, ptr %y1.addr, align 4
  %42 = load ptr, ptr %glyph, align 8
  %Y1 = getelementptr inbounds %struct.ImFontGlyph, ptr %42, i32 0, i32 5
  store float %41, ptr %Y1, align 4
  %43 = load float, ptr %u0.addr, align 4
  %44 = load ptr, ptr %glyph, align 8
  %U0 = getelementptr inbounds %struct.ImFontGlyph, ptr %44, i32 0, i32 6
  store float %43, ptr %U0, align 4
  %45 = load float, ptr %v0.addr, align 4
  %46 = load ptr, ptr %glyph, align 8
  %V0 = getelementptr inbounds %struct.ImFontGlyph, ptr %46, i32 0, i32 7
  store float %45, ptr %V0, align 4
  %47 = load float, ptr %u1.addr, align 4
  %48 = load ptr, ptr %glyph, align 8
  %U1 = getelementptr inbounds %struct.ImFontGlyph, ptr %48, i32 0, i32 8
  store float %47, ptr %U1, align 4
  %49 = load float, ptr %v1.addr, align 4
  %50 = load ptr, ptr %glyph, align 8
  %V1 = getelementptr inbounds %struct.ImFontGlyph, ptr %50, i32 0, i32 9
  store float %49, ptr %V1, align 4
  %51 = load float, ptr %advance_x.addr, align 4
  %52 = load ptr, ptr %glyph, align 8
  %AdvanceX = getelementptr inbounds %struct.ImFontGlyph, ptr %52, i32 0, i32 1
  store float %51, ptr %AdvanceX, align 4
  %ContainerAtlas = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 6
  %53 = load ptr, ptr %ContainerAtlas, align 8
  %TexGlyphPadding = getelementptr inbounds %struct.ImFontAtlas, ptr %53, i32 0, i32 4
  %54 = load i32, ptr %TexGlyphPadding, align 4
  %conv32 = sitofp i32 %54 to float
  %add33 = fadd float %conv32, 0x3FEFAE1480000000
  store float %add33, ptr %pad, align 4
  %DirtyLookupTables = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 14
  store i8 1, ptr %DirtyLookupTables, align 8
  %55 = load ptr, ptr %glyph, align 8
  %U134 = getelementptr inbounds %struct.ImFontGlyph, ptr %55, i32 0, i32 8
  %56 = load float, ptr %U134, align 4
  %57 = load ptr, ptr %glyph, align 8
  %U035 = getelementptr inbounds %struct.ImFontGlyph, ptr %57, i32 0, i32 6
  %58 = load float, ptr %U035, align 4
  %sub36 = fsub float %56, %58
  %ContainerAtlas37 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 6
  %59 = load ptr, ptr %ContainerAtlas37, align 8
  %TexWidth = getelementptr inbounds %struct.ImFontAtlas, ptr %59, i32 0, i32 13
  %60 = load i32, ptr %TexWidth, align 8
  %conv38 = sitofp i32 %60 to float
  %61 = load float, ptr %pad, align 4
  %62 = call float @llvm.fmuladd.f32(float %sub36, float %conv38, float %61)
  %conv40 = fptosi float %62 to i32
  %63 = load ptr, ptr %glyph, align 8
  %V141 = getelementptr inbounds %struct.ImFontGlyph, ptr %63, i32 0, i32 9
  %64 = load float, ptr %V141, align 4
  %65 = load ptr, ptr %glyph, align 8
  %V042 = getelementptr inbounds %struct.ImFontGlyph, ptr %65, i32 0, i32 7
  %66 = load float, ptr %V042, align 4
  %sub43 = fsub float %64, %66
  %ContainerAtlas44 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 6
  %67 = load ptr, ptr %ContainerAtlas44, align 8
  %TexHeight = getelementptr inbounds %struct.ImFontAtlas, ptr %67, i32 0, i32 14
  %68 = load i32, ptr %TexHeight, align 4
  %conv45 = sitofp i32 %68 to float
  %69 = load float, ptr %pad, align 4
  %70 = call float @llvm.fmuladd.f32(float %sub43, float %conv45, float %69)
  %conv47 = fptosi float %70 to i32
  %mul48 = mul nsw i32 %conv40, %conv47
  %MetricsTotalSurface = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 19
  %71 = load i32, ptr %MetricsTotalSurface, align 8
  %add49 = add nsw i32 %71, %mul48
  store i32 %add49, ptr %MetricsTotalSurface, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN6ImFont16BuildLookupTableEv(ptr noundef nonnull align 8 dereferenceable(118) %this) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %max_codepoint = alloca i32, align 4
  %i = alloca i32, align 4
  %i4 = alloca i32, align 4
  %codepoint = alloca i32, align 4
  %page_n = alloca i32, align 4
  %tab_glyph = alloca ptr, align 8
  %fallback_chars = alloca [3 x i16], align 2
  %i80 = alloca i32, align 4
  %ellipsis_chars = alloca [2 x i16], align 2
  %dots_chars = alloca [2 x i16], align 2
  %dot_char = alloca i16, align 2
  %glyph = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store i32 0, ptr %max_codepoint, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %Glyphs = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 4
  %Size = getelementptr inbounds %struct.ImVector.7, ptr %Glyphs, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %cmp = icmp ne i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32, ptr %max_codepoint, align 4
  %Glyphs2 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 4
  %3 = load i32, ptr %i, align 4
  %call = call noundef nonnull align 4 dereferenceable(40) ptr @_ZN8ImVectorI11ImFontGlyphEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Glyphs2, i32 noundef %3)
  %bf.load = load i32, ptr %call, align 4
  %bf.lshr = lshr i32 %bf.load, 2
  %call3 = call noundef i32 @_ZL5ImMaxIiET_S0_S0_(i32 noundef %2, i32 noundef %bf.lshr)
  store i32 %call3, ptr %max_codepoint, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %4 = load i32, ptr %i, align 4
  %inc = add nsw i32 %4, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !81

for.end:                                          ; preds = %for.cond
  %IndexAdvanceX = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 0
  call void @_ZN8ImVectorIfE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %IndexAdvanceX)
  %IndexLookup = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 3
  call void @_ZN8ImVectorItE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %IndexLookup)
  %DirtyLookupTables = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 14
  store i8 0, ptr %DirtyLookupTables, align 8
  %Used4kPagesMap = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 20
  %arraydecay = getelementptr inbounds [2 x i8], ptr %Used4kPagesMap, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 4 %arraydecay, i8 0, i64 2, i1 false)
  %5 = load i32, ptr %max_codepoint, align 4
  %add = add nsw i32 %5, 1
  call void @_ZN6ImFont9GrowIndexEi(ptr noundef nonnull align 8 dereferenceable(118) %this1, i32 noundef %add)
  store i32 0, ptr %i4, align 4
  br label %for.cond5

for.cond5:                                        ; preds = %for.inc23, %for.end
  %6 = load i32, ptr %i4, align 4
  %Glyphs6 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 4
  %Size7 = getelementptr inbounds %struct.ImVector.7, ptr %Glyphs6, i32 0, i32 0
  %7 = load i32, ptr %Size7, align 8
  %cmp8 = icmp slt i32 %6, %7
  br i1 %cmp8, label %for.body9, label %for.end25

for.body9:                                        ; preds = %for.cond5
  %Glyphs10 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 4
  %8 = load i32, ptr %i4, align 4
  %call11 = call noundef nonnull align 4 dereferenceable(40) ptr @_ZN8ImVectorI11ImFontGlyphEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Glyphs10, i32 noundef %8)
  %bf.load12 = load i32, ptr %call11, align 4
  %bf.lshr13 = lshr i32 %bf.load12, 2
  store i32 %bf.lshr13, ptr %codepoint, align 4
  %Glyphs14 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 4
  %9 = load i32, ptr %i4, align 4
  %call15 = call noundef nonnull align 4 dereferenceable(40) ptr @_ZN8ImVectorI11ImFontGlyphEixEi(ptr noundef nonnull align 8 dereferenceable(16) %Glyphs14, i32 noundef %9)
  %AdvanceX = getelementptr inbounds %struct.ImFontGlyph, ptr %call15, i32 0, i32 1
  %10 = load float, ptr %AdvanceX, align 4
  %IndexAdvanceX16 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 0
  %11 = load i32, ptr %codepoint, align 4
  %call17 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZN8ImVectorIfEixEi(ptr noundef nonnull align 8 dereferenceable(16) %IndexAdvanceX16, i32 noundef %11)
  store float %10, ptr %call17, align 4
  %12 = load i32, ptr %i4, align 4
  %conv = trunc i32 %12 to i16
  %IndexLookup18 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 3
  %13 = load i32, ptr %codepoint, align 4
  %call19 = call noundef nonnull align 2 dereferenceable(2) ptr @_ZN8ImVectorItEixEi(ptr noundef nonnull align 8 dereferenceable(16) %IndexLookup18, i32 noundef %13)
  store i16 %conv, ptr %call19, align 2
  %14 = load i32, ptr %codepoint, align 4
  %div = sdiv i32 %14, 4096
  store i32 %div, ptr %page_n, align 4
  %15 = load i32, ptr %page_n, align 4
  %and = and i32 %15, 7
  %shl = shl i32 1, %and
  %Used4kPagesMap20 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 20
  %16 = load i32, ptr %page_n, align 4
  %shr = ashr i32 %16, 3
  %idxprom = sext i32 %shr to i64
  %arrayidx = getelementptr inbounds [2 x i8], ptr %Used4kPagesMap20, i64 0, i64 %idxprom
  %17 = load i8, ptr %arrayidx, align 1
  %conv21 = zext i8 %17 to i32
  %or = or i32 %conv21, %shl
  %conv22 = trunc i32 %or to i8
  store i8 %conv22, ptr %arrayidx, align 1
  br label %for.inc23

for.inc23:                                        ; preds = %for.body9
  %18 = load i32, ptr %i4, align 4
  %inc24 = add nsw i32 %18, 1
  store i32 %inc24, ptr %i4, align 4
  br label %for.cond5, !llvm.loop !82

for.end25:                                        ; preds = %for.cond5
  %call26 = call noundef ptr @_ZNK6ImFont9FindGlyphEt(ptr noundef nonnull align 8 dereferenceable(118) %this1, i16 noundef zeroext 32)
  %tobool = icmp ne ptr %call26, null
  br i1 %tobool, label %if.then, label %if.end54

if.then:                                          ; preds = %for.end25
  %Glyphs27 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 4
  %call28 = call noundef nonnull align 4 dereferenceable(40) ptr @_ZN8ImVectorI11ImFontGlyphE4backEv(ptr noundef nonnull align 8 dereferenceable(16) %Glyphs27)
  %bf.load29 = load i32, ptr %call28, align 4
  %bf.lshr30 = lshr i32 %bf.load29, 2
  %cmp31 = icmp ne i32 %bf.lshr30, 9
  br i1 %cmp31, label %if.then32, label %if.end

if.then32:                                        ; preds = %if.then
  %Glyphs33 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 4
  %Glyphs34 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 4
  %Size35 = getelementptr inbounds %struct.ImVector.7, ptr %Glyphs34, i32 0, i32 0
  %19 = load i32, ptr %Size35, align 8
  %add36 = add nsw i32 %19, 1
  call void @_ZN8ImVectorI11ImFontGlyphE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %Glyphs33, i32 noundef %add36)
  br label %if.end

if.end:                                           ; preds = %if.then32, %if.then
  %Glyphs37 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 4
  %call38 = call noundef nonnull align 4 dereferenceable(40) ptr @_ZN8ImVectorI11ImFontGlyphE4backEv(ptr noundef nonnull align 8 dereferenceable(16) %Glyphs37)
  store ptr %call38, ptr %tab_glyph, align 8
  %call39 = call noundef ptr @_ZNK6ImFont9FindGlyphEt(ptr noundef nonnull align 8 dereferenceable(118) %this1, i16 noundef zeroext 32)
  %20 = load ptr, ptr %tab_glyph, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %20, ptr align 4 %call39, i64 40, i1 false)
  %21 = load ptr, ptr %tab_glyph, align 8
  %bf.load40 = load i32, ptr %21, align 4
  %bf.clear = and i32 %bf.load40, 3
  %bf.set = or i32 %bf.clear, 36
  store i32 %bf.set, ptr %21, align 4
  %22 = load ptr, ptr %tab_glyph, align 8
  %AdvanceX41 = getelementptr inbounds %struct.ImFontGlyph, ptr %22, i32 0, i32 1
  %23 = load float, ptr %AdvanceX41, align 4
  %mul = fmul float %23, 4.000000e+00
  store float %mul, ptr %AdvanceX41, align 4
  %24 = load ptr, ptr %tab_glyph, align 8
  %AdvanceX42 = getelementptr inbounds %struct.ImFontGlyph, ptr %24, i32 0, i32 1
  %25 = load float, ptr %AdvanceX42, align 4
  %IndexAdvanceX43 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 0
  %26 = load ptr, ptr %tab_glyph, align 8
  %bf.load44 = load i32, ptr %26, align 4
  %bf.lshr45 = lshr i32 %bf.load44, 2
  %call46 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZN8ImVectorIfEixEi(ptr noundef nonnull align 8 dereferenceable(16) %IndexAdvanceX43, i32 noundef %bf.lshr45)
  store float %25, ptr %call46, align 4
  %Glyphs47 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 4
  %Size48 = getelementptr inbounds %struct.ImVector.7, ptr %Glyphs47, i32 0, i32 0
  %27 = load i32, ptr %Size48, align 8
  %sub = sub nsw i32 %27, 1
  %conv49 = trunc i32 %sub to i16
  %IndexLookup50 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 3
  %28 = load ptr, ptr %tab_glyph, align 8
  %bf.load51 = load i32, ptr %28, align 4
  %bf.lshr52 = lshr i32 %bf.load51, 2
  %call53 = call noundef nonnull align 2 dereferenceable(2) ptr @_ZN8ImVectorItEixEi(ptr noundef nonnull align 8 dereferenceable(16) %IndexLookup50, i32 noundef %bf.lshr52)
  store i16 %conv49, ptr %call53, align 2
  br label %if.end54

if.end54:                                         ; preds = %if.end, %for.end25
  call void @_ZN6ImFont15SetGlyphVisibleEtb(ptr noundef nonnull align 8 dereferenceable(118) %this1, i16 noundef zeroext 32, i1 noundef zeroext false)
  call void @_ZN6ImFont15SetGlyphVisibleEtb(ptr noundef nonnull align 8 dereferenceable(118) %this1, i16 noundef zeroext 9, i1 noundef zeroext false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 2 %fallback_chars, ptr align 2 @__const._ZN6ImFont16BuildLookupTableEv.fallback_chars, i64 6, i1 false)
  %FallbackChar = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 9
  %29 = load i16, ptr %FallbackChar, align 2
  %call55 = call noundef ptr @_ZNK6ImFont19FindGlyphNoFallbackEt(ptr noundef nonnull align 8 dereferenceable(118) %this1, i16 noundef zeroext %29)
  %FallbackGlyph = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 5
  store ptr %call55, ptr %FallbackGlyph, align 8
  %FallbackGlyph56 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 5
  %30 = load ptr, ptr %FallbackGlyph56, align 8
  %cmp57 = icmp eq ptr %30, null
  br i1 %cmp57, label %if.then58, label %if.end77

if.then58:                                        ; preds = %if.end54
  %arraydecay59 = getelementptr inbounds [3 x i16], ptr %fallback_chars, i64 0, i64 0
  %call60 = call noundef zeroext i16 @_ZL22FindFirstExistingGlyphP6ImFontPKti(ptr noundef %this1, ptr noundef %arraydecay59, i32 noundef 3)
  %FallbackChar61 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 9
  store i16 %call60, ptr %FallbackChar61, align 2
  %FallbackChar62 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 9
  %31 = load i16, ptr %FallbackChar62, align 2
  %call63 = call noundef ptr @_ZNK6ImFont19FindGlyphNoFallbackEt(ptr noundef nonnull align 8 dereferenceable(118) %this1, i16 noundef zeroext %31)
  %FallbackGlyph64 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 5
  store ptr %call63, ptr %FallbackGlyph64, align 8
  %FallbackGlyph65 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 5
  %32 = load ptr, ptr %FallbackGlyph65, align 8
  %cmp66 = icmp eq ptr %32, null
  br i1 %cmp66, label %if.then67, label %if.end76

if.then67:                                        ; preds = %if.then58
  %Glyphs68 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 4
  %call69 = call noundef nonnull align 4 dereferenceable(40) ptr @_ZN8ImVectorI11ImFontGlyphE4backEv(ptr noundef nonnull align 8 dereferenceable(16) %Glyphs68)
  %FallbackGlyph70 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 5
  store ptr %call69, ptr %FallbackGlyph70, align 8
  %FallbackGlyph71 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 5
  %33 = load ptr, ptr %FallbackGlyph71, align 8
  %bf.load72 = load i32, ptr %33, align 4
  %bf.lshr73 = lshr i32 %bf.load72, 2
  %conv74 = trunc i32 %bf.lshr73 to i16
  %FallbackChar75 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 9
  store i16 %conv74, ptr %FallbackChar75, align 2
  br label %if.end76

if.end76:                                         ; preds = %if.then67, %if.then58
  br label %if.end77

if.end77:                                         ; preds = %if.end76, %if.end54
  %FallbackGlyph78 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 5
  %34 = load ptr, ptr %FallbackGlyph78, align 8
  %AdvanceX79 = getelementptr inbounds %struct.ImFontGlyph, ptr %34, i32 0, i32 1
  %35 = load float, ptr %AdvanceX79, align 4
  %FallbackAdvanceX = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 1
  store float %35, ptr %FallbackAdvanceX, align 8
  store i32 0, ptr %i80, align 4
  br label %for.cond81

for.cond81:                                       ; preds = %for.inc93, %if.end77
  %36 = load i32, ptr %i80, align 4
  %37 = load i32, ptr %max_codepoint, align 4
  %add82 = add nsw i32 %37, 1
  %cmp83 = icmp slt i32 %36, %add82
  br i1 %cmp83, label %for.body84, label %for.end95

for.body84:                                       ; preds = %for.cond81
  %IndexAdvanceX85 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 0
  %38 = load i32, ptr %i80, align 4
  %call86 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZN8ImVectorIfEixEi(ptr noundef nonnull align 8 dereferenceable(16) %IndexAdvanceX85, i32 noundef %38)
  %39 = load float, ptr %call86, align 4
  %cmp87 = fcmp olt float %39, 0.000000e+00
  br i1 %cmp87, label %if.then88, label %if.end92

if.then88:                                        ; preds = %for.body84
  %FallbackAdvanceX89 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 1
  %40 = load float, ptr %FallbackAdvanceX89, align 8
  %IndexAdvanceX90 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 0
  %41 = load i32, ptr %i80, align 4
  %call91 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZN8ImVectorIfEixEi(ptr noundef nonnull align 8 dereferenceable(16) %IndexAdvanceX90, i32 noundef %41)
  store float %40, ptr %call91, align 4
  br label %if.end92

if.end92:                                         ; preds = %if.then88, %for.body84
  br label %for.inc93

for.inc93:                                        ; preds = %if.end92
  %42 = load i32, ptr %i80, align 4
  %inc94 = add nsw i32 %42, 1
  store i32 %inc94, ptr %i80, align 4
  br label %for.cond81, !llvm.loop !83

for.end95:                                        ; preds = %for.cond81
  call void @llvm.memcpy.p0.p0.i64(ptr align 2 %ellipsis_chars, ptr align 2 @__const._ZN6ImFont16BuildLookupTableEv.ellipsis_chars, i64 4, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 2 %dots_chars, ptr align 2 @__const._ZN6ImFont16BuildLookupTableEv.dots_chars, i64 4, i1 false)
  %EllipsisChar = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 10
  %43 = load i16, ptr %EllipsisChar, align 4
  %conv96 = zext i16 %43 to i32
  %cmp97 = icmp eq i32 %conv96, 65535
  br i1 %cmp97, label %if.then98, label %if.end102

if.then98:                                        ; preds = %for.end95
  %arraydecay99 = getelementptr inbounds [2 x i16], ptr %ellipsis_chars, i64 0, i64 0
  %call100 = call noundef zeroext i16 @_ZL22FindFirstExistingGlyphP6ImFontPKti(ptr noundef %this1, ptr noundef %arraydecay99, i32 noundef 2)
  %EllipsisChar101 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 10
  store i16 %call100, ptr %EllipsisChar101, align 4
  br label %if.end102

if.end102:                                        ; preds = %if.then98, %for.end95
  %arraydecay103 = getelementptr inbounds [2 x i16], ptr %dots_chars, i64 0, i64 0
  %call104 = call noundef zeroext i16 @_ZL22FindFirstExistingGlyphP6ImFontPKti(ptr noundef %this1, ptr noundef %arraydecay103, i32 noundef 2)
  store i16 %call104, ptr %dot_char, align 2
  %EllipsisChar105 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 10
  %44 = load i16, ptr %EllipsisChar105, align 4
  %conv106 = zext i16 %44 to i32
  %cmp107 = icmp ne i32 %conv106, 65535
  br i1 %cmp107, label %if.then108, label %if.else

if.then108:                                       ; preds = %if.end102
  %EllipsisCharCount = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 11
  store i16 1, ptr %EllipsisCharCount, align 2
  %EllipsisChar109 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 10
  %45 = load i16, ptr %EllipsisChar109, align 4
  %call110 = call noundef ptr @_ZNK6ImFont9FindGlyphEt(ptr noundef nonnull align 8 dereferenceable(118) %this1, i16 noundef zeroext %45)
  %X1 = getelementptr inbounds %struct.ImFontGlyph, ptr %call110, i32 0, i32 4
  %46 = load float, ptr %X1, align 4
  %EllipsisCharStep = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 13
  store float %46, ptr %EllipsisCharStep, align 4
  %EllipsisWidth = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 12
  store float %46, ptr %EllipsisWidth, align 8
  br label %if.end125

if.else:                                          ; preds = %if.end102
  %47 = load i16, ptr %dot_char, align 2
  %conv111 = zext i16 %47 to i32
  %cmp112 = icmp ne i32 %conv111, 65535
  br i1 %cmp112, label %if.then113, label %if.end124

if.then113:                                       ; preds = %if.else
  %48 = load i16, ptr %dot_char, align 2
  %call114 = call noundef ptr @_ZNK6ImFont9FindGlyphEt(ptr noundef nonnull align 8 dereferenceable(118) %this1, i16 noundef zeroext %48)
  store ptr %call114, ptr %glyph, align 8
  %49 = load i16, ptr %dot_char, align 2
  %EllipsisChar115 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 10
  store i16 %49, ptr %EllipsisChar115, align 4
  %EllipsisCharCount116 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 11
  store i16 3, ptr %EllipsisCharCount116, align 2
  %50 = load ptr, ptr %glyph, align 8
  %X1117 = getelementptr inbounds %struct.ImFontGlyph, ptr %50, i32 0, i32 4
  %51 = load float, ptr %X1117, align 4
  %52 = load ptr, ptr %glyph, align 8
  %X0 = getelementptr inbounds %struct.ImFontGlyph, ptr %52, i32 0, i32 2
  %53 = load float, ptr %X0, align 4
  %sub118 = fsub float %51, %53
  %add119 = fadd float %sub118, 1.000000e+00
  %EllipsisCharStep120 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 13
  store float %add119, ptr %EllipsisCharStep120, align 4
  %EllipsisCharStep121 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 13
  %54 = load float, ptr %EllipsisCharStep121, align 4
  %55 = call float @llvm.fmuladd.f32(float %54, float 3.000000e+00, float -1.000000e+00)
  %EllipsisWidth123 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 12
  store float %55, ptr %EllipsisWidth123, align 8
  br label %if.end124

if.end124:                                        ; preds = %if.then113, %if.else
  br label %if.end125

if.end125:                                        ; preds = %if.end124, %if.then108
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define noundef ptr @_ZN11ImFontAtlas19GetGlyphRangesGreekEv(ptr noundef nonnull align 8 dereferenceable(1180) %this) #2 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret ptr @_ZZN11ImFontAtlas19GetGlyphRangesGreekEvE6ranges
}

; Function Attrs: mustprogress nounwind uwtable
define noundef ptr @_ZN11ImFontAtlas20GetGlyphRangesKoreanEv(ptr noundef nonnull align 8 dereferenceable(1180) %this) #2 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret ptr @_ZZN11ImFontAtlas20GetGlyphRangesKoreanEvE6ranges
}

; Function Attrs: mustprogress nounwind uwtable
define noundef ptr @_ZN11ImFontAtlas25GetGlyphRangesChineseFullEv(ptr noundef nonnull align 8 dereferenceable(1180) %this) #2 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret ptr @_ZZN11ImFontAtlas25GetGlyphRangesChineseFullEvE6ranges
}

; Function Attrs: mustprogress uwtable
define noundef ptr @_ZN11ImFontAtlas37GetGlyphRangesChineseSimplifiedCommonEv(ptr noundef nonnull align 8 dereferenceable(1180) %this) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %0 = load i16, ptr @_ZZN11ImFontAtlas37GetGlyphRangesChineseSimplifiedCommonEvE11full_ranges, align 16
  %tobool = icmp ne i16 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 @_ZZN11ImFontAtlas37GetGlyphRangesChineseSimplifiedCommonEvE11full_ranges, ptr align 16 @_ZZN11ImFontAtlas37GetGlyphRangesChineseSimplifiedCommonEvE11base_ranges, i64 24, i1 false)
  call void @_ZL35UnpackAccumulativeOffsetsIntoRangesiPKsiPt(i32 noundef 19968, ptr noundef @_ZZN11ImFontAtlas37GetGlyphRangesChineseSimplifiedCommonEvE32accumulative_offsets_from_0x4E00, i32 noundef 2500, ptr noundef getelementptr inbounds (i16, ptr @_ZZN11ImFontAtlas37GetGlyphRangesChineseSimplifiedCommonEvE11full_ranges, i64 12))
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret ptr @_ZZN11ImFontAtlas37GetGlyphRangesChineseSimplifiedCommonEvE11full_ranges
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZL35UnpackAccumulativeOffsetsIntoRangesiPKsiPt(i32 noundef %base_codepoint, ptr noundef %accumulative_offsets, i32 noundef %accumulative_offsets_count, ptr noundef %out_ranges) #2 {
entry:
  %base_codepoint.addr = alloca i32, align 4
  %accumulative_offsets.addr = alloca ptr, align 8
  %accumulative_offsets_count.addr = alloca i32, align 4
  %out_ranges.addr = alloca ptr, align 8
  %n = alloca i32, align 4
  store i32 %base_codepoint, ptr %base_codepoint.addr, align 4
  store ptr %accumulative_offsets, ptr %accumulative_offsets.addr, align 8
  store i32 %accumulative_offsets_count, ptr %accumulative_offsets_count.addr, align 4
  store ptr %out_ranges, ptr %out_ranges.addr, align 8
  store i32 0, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %n, align 4
  %1 = load i32, ptr %accumulative_offsets_count.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32, ptr %base_codepoint.addr, align 4
  %3 = load ptr, ptr %accumulative_offsets.addr, align 8
  %4 = load i32, ptr %n, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds i16, ptr %3, i64 %idxprom
  %5 = load i16, ptr %arrayidx, align 2
  %conv = sext i16 %5 to i32
  %add = add nsw i32 %2, %conv
  %conv1 = trunc i32 %add to i16
  %6 = load ptr, ptr %out_ranges.addr, align 8
  %arrayidx2 = getelementptr inbounds i16, ptr %6, i64 1
  store i16 %conv1, ptr %arrayidx2, align 2
  %7 = load ptr, ptr %out_ranges.addr, align 8
  %arrayidx3 = getelementptr inbounds i16, ptr %7, i64 0
  store i16 %conv1, ptr %arrayidx3, align 2
  %8 = load ptr, ptr %accumulative_offsets.addr, align 8
  %9 = load i32, ptr %n, align 4
  %idxprom4 = sext i32 %9 to i64
  %arrayidx5 = getelementptr inbounds i16, ptr %8, i64 %idxprom4
  %10 = load i16, ptr %arrayidx5, align 2
  %conv6 = sext i16 %10 to i32
  %11 = load i32, ptr %base_codepoint.addr, align 4
  %add7 = add nsw i32 %11, %conv6
  store i32 %add7, ptr %base_codepoint.addr, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, ptr %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, ptr %n, align 4
  %13 = load ptr, ptr %out_ranges.addr, align 8
  %add.ptr = getelementptr inbounds i16, ptr %13, i64 2
  store ptr %add.ptr, ptr %out_ranges.addr, align 8
  br label %for.cond, !llvm.loop !84

for.end:                                          ; preds = %for.cond
  %14 = load ptr, ptr %out_ranges.addr, align 8
  %arrayidx8 = getelementptr inbounds i16, ptr %14, i64 0
  store i16 0, ptr %arrayidx8, align 2
  ret void
}

; Function Attrs: mustprogress uwtable
define noundef ptr @_ZN11ImFontAtlas22GetGlyphRangesJapaneseEv(ptr noundef nonnull align 8 dereferenceable(1180) %this) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %0 = load i16, ptr @_ZZN11ImFontAtlas22GetGlyphRangesJapaneseEvE11full_ranges, align 16
  %tobool = icmp ne i16 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 @_ZZN11ImFontAtlas22GetGlyphRangesJapaneseEvE11full_ranges, ptr align 16 @_ZZN11ImFontAtlas22GetGlyphRangesJapaneseEvE11base_ranges, i64 20, i1 false)
  call void @_ZL35UnpackAccumulativeOffsetsIntoRangesiPKsiPt(i32 noundef 19968, ptr noundef @_ZZN11ImFontAtlas22GetGlyphRangesJapaneseEvE32accumulative_offsets_from_0x4E00, i32 noundef 2999, ptr noundef getelementptr inbounds (i16, ptr @_ZZN11ImFontAtlas22GetGlyphRangesJapaneseEvE11full_ranges, i64 10))
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret ptr @_ZZN11ImFontAtlas22GetGlyphRangesJapaneseEvE11full_ranges
}

; Function Attrs: mustprogress nounwind uwtable
define noundef ptr @_ZN11ImFontAtlas22GetGlyphRangesCyrillicEv(ptr noundef nonnull align 8 dereferenceable(1180) %this) #2 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret ptr @_ZZN11ImFontAtlas22GetGlyphRangesCyrillicEvE6ranges
}

; Function Attrs: mustprogress nounwind uwtable
define noundef ptr @_ZN11ImFontAtlas18GetGlyphRangesThaiEv(ptr noundef nonnull align 8 dereferenceable(1180) %this) #2 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret ptr @_ZZN11ImFontAtlas18GetGlyphRangesThaiEvE6ranges
}

; Function Attrs: mustprogress nounwind uwtable
define noundef ptr @_ZN11ImFontAtlas24GetGlyphRangesVietnameseEv(ptr noundef nonnull align 8 dereferenceable(1180) %this) #2 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  ret ptr @_ZZN11ImFontAtlas24GetGlyphRangesVietnameseEvE6ranges
}

; Function Attrs: mustprogress uwtable
define void @_ZN24ImFontGlyphRangesBuilder7AddTextEPKcS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %text, ptr noundef %text_end) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %text.addr = alloca ptr, align 8
  %text_end.addr = alloca ptr, align 8
  %c = alloca i32, align 4
  %c_len = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %text, ptr %text.addr, align 8
  store ptr %text_end, ptr %text_end.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %0 = load ptr, ptr %text_end.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %while.cond
  %1 = load ptr, ptr %text.addr, align 8
  %2 = load ptr, ptr %text_end.addr, align 8
  %cmp = icmp ult ptr %1, %2
  %conv = zext i1 %cmp to i32
  br label %cond.end

cond.false:                                       ; preds = %while.cond
  %3 = load ptr, ptr %text.addr, align 8
  %4 = load i8, ptr %3, align 1
  %conv2 = sext i8 %4 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv, %cond.true ], [ %conv2, %cond.false ]
  %tobool3 = icmp ne i32 %cond, 0
  br i1 %tobool3, label %while.body, label %while.end

while.body:                                       ; preds = %cond.end
  store i32 0, ptr %c, align 4
  %5 = load ptr, ptr %text.addr, align 8
  %6 = load ptr, ptr %text_end.addr, align 8
  %call = call noundef i32 @_Z18ImTextCharFromUtf8PjPKcS1_(ptr noundef %c, ptr noundef %5, ptr noundef %6)
  store i32 %call, ptr %c_len, align 4
  %7 = load i32, ptr %c_len, align 4
  %8 = load ptr, ptr %text.addr, align 8
  %idx.ext = sext i32 %7 to i64
  %add.ptr = getelementptr inbounds i8, ptr %8, i64 %idx.ext
  store ptr %add.ptr, ptr %text.addr, align 8
  %9 = load i32, ptr %c_len, align 4
  %cmp4 = icmp eq i32 %9, 0
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  br label %while.end

if.end:                                           ; preds = %while.body
  %10 = load i32, ptr %c, align 4
  %conv5 = trunc i32 %10 to i16
  call void @_ZN24ImFontGlyphRangesBuilder7AddCharEt(ptr noundef nonnull align 8 dereferenceable(16) %this1, i16 noundef zeroext %conv5)
  br label %while.cond, !llvm.loop !85

while.end:                                        ; preds = %if.then, %cond.end
  ret void
}

declare noundef i32 @_Z18ImTextCharFromUtf8PjPKcS1_(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN24ImFontGlyphRangesBuilder7AddCharEt(ptr noundef nonnull align 8 dereferenceable(16) %this, i16 noundef zeroext %c) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %c.addr = alloca i16, align 2
  store ptr %this, ptr %this.addr, align 8
  store i16 %c, ptr %c.addr, align 2
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i16, ptr %c.addr, align 2
  %conv = zext i16 %0 to i64
  call void @_ZN24ImFontGlyphRangesBuilder6SetBitEm(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %conv)
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN24ImFontGlyphRangesBuilder9AddRangesEPKt(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %ranges) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ranges.addr = alloca ptr, align 8
  %c = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %ranges, ptr %ranges.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc9, %entry
  %0 = load ptr, ptr %ranges.addr, align 8
  %arrayidx = getelementptr inbounds i16, ptr %0, i64 0
  %1 = load i16, ptr %arrayidx, align 2
  %tobool = icmp ne i16 %1, 0
  br i1 %tobool, label %for.body, label %for.end10

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %ranges.addr, align 8
  %arrayidx2 = getelementptr inbounds i16, ptr %2, i64 0
  %3 = load i16, ptr %arrayidx2, align 2
  %conv = zext i16 %3 to i32
  store i32 %conv, ptr %c, align 4
  br label %for.cond3

for.cond3:                                        ; preds = %for.inc, %for.body
  %4 = load i32, ptr %c, align 4
  %5 = load ptr, ptr %ranges.addr, align 8
  %arrayidx4 = getelementptr inbounds i16, ptr %5, i64 1
  %6 = load i16, ptr %arrayidx4, align 2
  %conv5 = zext i16 %6 to i32
  %cmp = icmp ule i32 %4, %conv5
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond3
  %7 = load i32, ptr %c, align 4
  %cmp6 = icmp ule i32 %7, 65535
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond3
  %8 = phi i1 [ false, %for.cond3 ], [ %cmp6, %land.rhs ]
  br i1 %8, label %for.body7, label %for.end

for.body7:                                        ; preds = %land.end
  %9 = load i32, ptr %c, align 4
  %conv8 = trunc i32 %9 to i16
  call void @_ZN24ImFontGlyphRangesBuilder7AddCharEt(ptr noundef nonnull align 8 dereferenceable(16) %this1, i16 noundef zeroext %conv8)
  br label %for.inc

for.inc:                                          ; preds = %for.body7
  %10 = load i32, ptr %c, align 4
  %inc = add i32 %10, 1
  store i32 %inc, ptr %c, align 4
  br label %for.cond3, !llvm.loop !86

for.end:                                          ; preds = %land.end
  br label %for.inc9

for.inc9:                                         ; preds = %for.end
  %11 = load ptr, ptr %ranges.addr, align 8
  %add.ptr = getelementptr inbounds i16, ptr %11, i64 2
  store ptr %add.ptr, ptr %ranges.addr, align 8
  br label %for.cond, !llvm.loop !87

for.end10:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN24ImFontGlyphRangesBuilder11BuildRangesEP8ImVectorItE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %out_ranges) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %out_ranges.addr = alloca ptr, align 8
  %max_codepoint = alloca i32, align 4
  %n = alloca i32, align 4
  %ref.tmp = alloca i16, align 2
  %ref.tmp6 = alloca i16, align 2
  %ref.tmp9 = alloca i16, align 2
  store ptr %this, ptr %this.addr, align 8
  store ptr %out_ranges, ptr %out_ranges.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store i32 65535, ptr %max_codepoint, align 4
  store i32 0, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %n, align 4
  %cmp = icmp sle i32 %0, 65535
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %n, align 4
  %conv = sext i32 %1 to i64
  %call = call noundef zeroext i1 @_ZNK24ImFontGlyphRangesBuilder6GetBitEm(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %conv)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %2 = load ptr, ptr %out_ranges.addr, align 8
  %3 = load i32, ptr %n, align 4
  %conv2 = trunc i32 %3 to i16
  store i16 %conv2, ptr %ref.tmp, align 2
  call void @_ZN8ImVectorItE9push_backERKt(ptr noundef nonnull align 8 dereferenceable(16) %2, ptr noundef nonnull align 2 dereferenceable(2) %ref.tmp)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %4 = load i32, ptr %n, align 4
  %cmp3 = icmp slt i32 %4, 65535
  br i1 %cmp3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %5 = load i32, ptr %n, align 4
  %add = add nsw i32 %5, 1
  %conv4 = sext i32 %add to i64
  %call5 = call noundef zeroext i1 @_ZNK24ImFontGlyphRangesBuilder6GetBitEm(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %conv4)
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %6 = phi i1 [ false, %while.cond ], [ %call5, %land.rhs ]
  br i1 %6, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %7 = load i32, ptr %n, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %n, align 4
  br label %while.cond, !llvm.loop !88

while.end:                                        ; preds = %land.end
  %8 = load ptr, ptr %out_ranges.addr, align 8
  %9 = load i32, ptr %n, align 4
  %conv7 = trunc i32 %9 to i16
  store i16 %conv7, ptr %ref.tmp6, align 2
  call void @_ZN8ImVectorItE9push_backERKt(ptr noundef nonnull align 8 dereferenceable(16) %8, ptr noundef nonnull align 2 dereferenceable(2) %ref.tmp6)
  br label %if.end

if.end:                                           ; preds = %while.end, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %10 = load i32, ptr %n, align 4
  %inc8 = add nsw i32 %10, 1
  store i32 %inc8, ptr %n, align 4
  br label %for.cond, !llvm.loop !89

for.end:                                          ; preds = %for.cond
  %11 = load ptr, ptr %out_ranges.addr, align 8
  store i16 0, ptr %ref.tmp9, align 2
  call void @_ZN8ImVectorItE9push_backERKt(ptr noundef nonnull align 8 dereferenceable(16) %11, ptr noundef nonnull align 2 dereferenceable(2) %ref.tmp9)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr noundef zeroext i1 @_ZNK24ImFontGlyphRangesBuilder6GetBitEm(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %off = alloca i32, align 4
  %mask = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %shr = lshr i64 %0, 5
  %conv = trunc i64 %shr to i32
  store i32 %conv, ptr %off, align 4
  %1 = load i64, ptr %n.addr, align 8
  %and = and i64 %1, 31
  %sh_prom = trunc i64 %and to i32
  %shl = shl i32 1, %sh_prom
  store i32 %shl, ptr %mask, align 4
  %UsedChars = getelementptr inbounds %struct.ImFontGlyphRangesBuilder, ptr %this1, i32 0, i32 0
  %2 = load i32, ptr %off, align 4
  %call = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK8ImVectorIjEixEi(ptr noundef nonnull align 8 dereferenceable(16) %UsedChars, i32 noundef %2)
  %3 = load i32, ptr %call, align 4
  %4 = load i32, ptr %mask, align 4
  %and2 = and i32 %3, %4
  %cmp = icmp ne i32 %and2, 0
  ret i1 %cmp
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorItE9push_backERKt(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 2 dereferenceable(2) %v) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Size2 = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 0
  %2 = load i32, ptr %Size2, align 8
  %add = add nsw i32 %2, 1
  %call = call noundef i32 @_ZNK8ImVectorItE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %add)
  call void @_ZN8ImVectorItE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %Data = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %Size3 = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 0
  %4 = load i32, ptr %Size3, align 8
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds i16, ptr %3, i64 %idxprom
  %5 = load ptr, ptr %v.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 2 %arrayidx, ptr align 2 %5, i64 2, i1 false)
  %Size4 = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size4, align 8
  %inc = add nsw i32 %6, 1
  store i32 %inc, ptr %Size4, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN6ImFontC2Ev(ptr noundef nonnull align 8 dereferenceable(118) %this) unnamed_addr #4 align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %IndexAdvanceX = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 0
  call void @_ZN8ImVectorIfEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %IndexAdvanceX)
  %IndexLookup = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 3
  invoke void @_ZN8ImVectorItEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %IndexLookup)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  %Glyphs = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 4
  invoke void @_ZN8ImVectorI11ImFontGlyphEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %Glyphs)
          to label %invoke.cont3 unwind label %lpad2

invoke.cont3:                                     ; preds = %invoke.cont
  %FontSize = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 2
  store float 0.000000e+00, ptr %FontSize, align 4
  %FallbackAdvanceX = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 1
  store float 0.000000e+00, ptr %FallbackAdvanceX, align 8
  %FallbackChar = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 9
  store i16 -1, ptr %FallbackChar, align 2
  %EllipsisChar = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 10
  store i16 -1, ptr %EllipsisChar, align 4
  %EllipsisCharStep = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 13
  store float 0.000000e+00, ptr %EllipsisCharStep, align 4
  %EllipsisWidth = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 12
  store float 0.000000e+00, ptr %EllipsisWidth, align 8
  %EllipsisCharCount = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 11
  store i16 0, ptr %EllipsisCharCount, align 2
  %FallbackGlyph = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 5
  store ptr null, ptr %FallbackGlyph, align 8
  %ContainerAtlas = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 6
  store ptr null, ptr %ContainerAtlas, align 8
  %ConfigData = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 7
  store ptr null, ptr %ConfigData, align 8
  %ConfigDataCount = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 8
  store i16 0, ptr %ConfigDataCount, align 8
  %DirtyLookupTables = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 14
  store i8 0, ptr %DirtyLookupTables, align 8
  %Scale = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 16
  store float 1.000000e+00, ptr %Scale, align 4
  %Descent = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 18
  store float 0.000000e+00, ptr %Descent, align 4
  %Ascent = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 17
  store float 0.000000e+00, ptr %Ascent, align 8
  %MetricsTotalSurface = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 19
  store i32 0, ptr %MetricsTotalSurface, align 8
  %Used4kPagesMap = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 20
  %arraydecay = getelementptr inbounds [2 x i8], ptr %Used4kPagesMap, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 4 %arraydecay, i8 0, i64 2, i1 false)
  ret void

lpad:                                             ; preds = %entry
  %0 = landingpad { ptr, i32 }
          cleanup
  %1 = extractvalue { ptr, i32 } %0, 0
  store ptr %1, ptr %exn.slot, align 8
  %2 = extractvalue { ptr, i32 } %0, 1
  store i32 %2, ptr %ehselector.slot, align 4
  br label %ehcleanup

lpad2:                                            ; preds = %invoke.cont
  %3 = landingpad { ptr, i32 }
          cleanup
  %4 = extractvalue { ptr, i32 } %3, 0
  store ptr %4, ptr %exn.slot, align 8
  %5 = extractvalue { ptr, i32 } %3, 1
  store i32 %5, ptr %ehselector.slot, align 4
  call void @_ZN8ImVectorItED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %IndexLookup) #12
  br label %ehcleanup

ehcleanup:                                        ; preds = %lpad2, %lpad
  call void @_ZN8ImVectorIfED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %IndexAdvanceX) #12
  br label %eh.resume

eh.resume:                                        ; preds = %ehcleanup
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val4 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorIfEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.6, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.6, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data = getelementptr inbounds %struct.ImVector.6, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorItEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI11ImFontGlyphEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.7, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.7, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data = getelementptr inbounds %struct.ImVector.7, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorItED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Data2 = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  invoke void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %invoke.cont, %entry
  ret void

terminate.lpad:                                   ; preds = %if.then
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #13
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorIfED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.6, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Data2 = getelementptr inbounds %struct.ImVector.6, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  invoke void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %invoke.cont, %entry
  ret void

terminate.lpad:                                   ; preds = %if.then
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #13
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define void @_ZN6ImFontD2Ev(ptr noundef nonnull align 8 dereferenceable(118) %this) unnamed_addr #2 align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  invoke void @_ZN6ImFont15ClearOutputDataEv(ptr noundef nonnull align 8 dereferenceable(118) %this1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %Glyphs = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 4
  call void @_ZN8ImVectorI11ImFontGlyphED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %Glyphs) #12
  %IndexLookup = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 3
  call void @_ZN8ImVectorItED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %IndexLookup) #12
  %IndexAdvanceX = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 0
  call void @_ZN8ImVectorIfED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %IndexAdvanceX) #12
  ret void

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #13
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI11ImFontGlyphED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.7, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Data2 = getelementptr inbounds %struct.ImVector.7, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  invoke void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %invoke.cont, %entry
  ret void

terminate.lpad:                                   ; preds = %if.then
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #13
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI11ImFontGlyphE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.7, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Capacity = getelementptr inbounds %struct.ImVector.7, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.7, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data2 = getelementptr inbounds %struct.ImVector.7, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
  %Data3 = getelementptr inbounds %struct.ImVector.7, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorIfE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.6, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Capacity = getelementptr inbounds %struct.ImVector.6, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.6, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data2 = getelementptr inbounds %struct.ImVector.6, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
  %Data3 = getelementptr inbounds %struct.ImVector.6, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 4 dereferenceable(40) ptr @_ZN8ImVectorI11ImFontGlyphEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.7, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.ImFontGlyph, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define void @_ZN6ImFont9GrowIndexEi(ptr noundef nonnull align 8 dereferenceable(118) %this, i32 noundef %new_size) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_size.addr = alloca i32, align 4
  %ref.tmp = alloca float, align 4
  %ref.tmp3 = alloca i16, align 2
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_size, ptr %new_size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_size.addr, align 4
  %IndexLookup = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 3
  %Size = getelementptr inbounds %struct.ImVector.1, ptr %IndexLookup, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %IndexAdvanceX = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 0
  %2 = load i32, ptr %new_size.addr, align 4
  store float -1.000000e+00, ptr %ref.tmp, align 4
  call void @_ZN8ImVectorIfE6resizeEiRKf(ptr noundef nonnull align 8 dereferenceable(16) %IndexAdvanceX, i32 noundef %2, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp)
  %IndexLookup2 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 3
  %3 = load i32, ptr %new_size.addr, align 4
  store i16 -1, ptr %ref.tmp3, align 2
  call void @_ZN8ImVectorItE6resizeEiRKt(ptr noundef nonnull align 8 dereferenceable(16) %IndexLookup2, i32 noundef %3, ptr noundef nonnull align 2 dereferenceable(2) %ref.tmp3)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 4 dereferenceable(4) ptr @_ZN8ImVectorIfEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.6, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds float, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define noundef ptr @_ZNK6ImFont9FindGlyphEt(ptr noundef nonnull align 8 dereferenceable(118) %this, i16 noundef zeroext %c) #2 align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %c.addr = alloca i16, align 2
  %i = alloca i16, align 2
  store ptr %this, ptr %this.addr, align 8
  store i16 %c, ptr %c.addr, align 2
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i16, ptr %c.addr, align 2
  %conv = zext i16 %0 to i64
  %IndexLookup = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 3
  %Size = getelementptr inbounds %struct.ImVector.1, ptr %IndexLookup, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %conv2 = sext i32 %1 to i64
  %cmp = icmp uge i64 %conv, %conv2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %FallbackGlyph = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 5
  %2 = load ptr, ptr %FallbackGlyph, align 8
  store ptr %2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %IndexLookup3 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 3
  %Data = getelementptr inbounds %struct.ImVector.1, ptr %IndexLookup3, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %4 = load i16, ptr %c.addr, align 2
  %idxprom = zext i16 %4 to i64
  %arrayidx = getelementptr inbounds i16, ptr %3, i64 %idxprom
  %5 = load i16, ptr %arrayidx, align 2
  store i16 %5, ptr %i, align 2
  %6 = load i16, ptr %i, align 2
  %conv4 = zext i16 %6 to i32
  %cmp5 = icmp eq i32 %conv4, 65535
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end
  %FallbackGlyph7 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 5
  %7 = load ptr, ptr %FallbackGlyph7, align 8
  store ptr %7, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.end
  %Glyphs = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 4
  %Data9 = getelementptr inbounds %struct.ImVector.7, ptr %Glyphs, i32 0, i32 2
  %8 = load ptr, ptr %Data9, align 8
  %9 = load i16, ptr %i, align 2
  %idxprom10 = zext i16 %9 to i64
  %arrayidx11 = getelementptr inbounds %struct.ImFontGlyph, ptr %8, i64 %idxprom10
  store ptr %arrayidx11, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end8, %if.then6, %if.then
  %10 = load ptr, ptr %retval, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 4 dereferenceable(40) ptr @_ZN8ImVectorI11ImFontGlyphE4backEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.7, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %Size = getelementptr inbounds %struct.ImVector.7, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %sub = sub nsw i32 %1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.ImFontGlyph, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI11ImFontGlyphE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_size) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_size, ptr %new_size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_size.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.7, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sgt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %new_size.addr, align 4
  %call = call noundef i32 @_ZNK8ImVectorI11ImFontGlyphE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %2)
  call void @_ZN8ImVectorI11ImFontGlyphE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %new_size.addr, align 4
  %Size = getelementptr inbounds %struct.ImVector.7, ptr %this1, i32 0, i32 0
  store i32 %3, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN6ImFont15SetGlyphVisibleEtb(ptr noundef nonnull align 8 dereferenceable(118) %this, i16 noundef zeroext %c, i1 noundef zeroext %visible) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %c.addr = alloca i16, align 2
  %visible.addr = alloca i8, align 1
  %glyph = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i16 %c, ptr %c.addr, align 2
  %frombool = zext i1 %visible to i8
  store i8 %frombool, ptr %visible.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i16, ptr %c.addr, align 2
  %call = call noundef ptr @_ZNK6ImFont9FindGlyphEt(ptr noundef nonnull align 8 dereferenceable(118) %this1, i16 noundef zeroext %0)
  store ptr %call, ptr %glyph, align 8
  %1 = load ptr, ptr %glyph, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i8, ptr %visible.addr, align 1
  %tobool2 = trunc i8 %2 to i1
  %cond = select i1 %tobool2, i32 1, i32 0
  %3 = load ptr, ptr %glyph, align 8
  %bf.load = load i32, ptr %3, align 4
  %bf.value = and i32 %cond, 1
  %bf.shl = shl i32 %bf.value, 1
  %bf.clear = and i32 %bf.load, -3
  %bf.set = or i32 %bf.clear, %bf.shl
  store i32 %bf.set, ptr %3, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define noundef ptr @_ZNK6ImFont19FindGlyphNoFallbackEt(ptr noundef nonnull align 8 dereferenceable(118) %this, i16 noundef zeroext %c) #2 align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %c.addr = alloca i16, align 2
  %i = alloca i16, align 2
  store ptr %this, ptr %this.addr, align 8
  store i16 %c, ptr %c.addr, align 2
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i16, ptr %c.addr, align 2
  %conv = zext i16 %0 to i64
  %IndexLookup = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 3
  %Size = getelementptr inbounds %struct.ImVector.1, ptr %IndexLookup, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %conv2 = sext i32 %1 to i64
  %cmp = icmp uge i64 %conv, %conv2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %IndexLookup3 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 3
  %Data = getelementptr inbounds %struct.ImVector.1, ptr %IndexLookup3, i32 0, i32 2
  %2 = load ptr, ptr %Data, align 8
  %3 = load i16, ptr %c.addr, align 2
  %idxprom = zext i16 %3 to i64
  %arrayidx = getelementptr inbounds i16, ptr %2, i64 %idxprom
  %4 = load i16, ptr %arrayidx, align 2
  store i16 %4, ptr %i, align 2
  %5 = load i16, ptr %i, align 2
  %conv4 = zext i16 %5 to i32
  %cmp5 = icmp eq i32 %conv4, 65535
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.end
  %Glyphs = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 4
  %Data8 = getelementptr inbounds %struct.ImVector.7, ptr %Glyphs, i32 0, i32 2
  %6 = load ptr, ptr %Data8, align 8
  %7 = load i16, ptr %i, align 2
  %idxprom9 = zext i16 %7 to i64
  %arrayidx10 = getelementptr inbounds %struct.ImFontGlyph, ptr %6, i64 %idxprom9
  store ptr %arrayidx10, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end7, %if.then6, %if.then
  %8 = load ptr, ptr %retval, align 8
  ret ptr %8
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef zeroext i16 @_ZL22FindFirstExistingGlyphP6ImFontPKti(ptr noundef %font, ptr noundef %candidate_chars, i32 noundef %candidate_chars_count) #2 {
entry:
  %retval = alloca i16, align 2
  %font.addr = alloca ptr, align 8
  %candidate_chars.addr = alloca ptr, align 8
  %candidate_chars_count.addr = alloca i32, align 4
  %n = alloca i32, align 4
  store ptr %font, ptr %font.addr, align 8
  store ptr %candidate_chars, ptr %candidate_chars.addr, align 8
  store i32 %candidate_chars_count, ptr %candidate_chars_count.addr, align 4
  store i32 0, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %n, align 4
  %1 = load i32, ptr %candidate_chars_count.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %font.addr, align 8
  %3 = load ptr, ptr %candidate_chars.addr, align 8
  %4 = load i32, ptr %n, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds i16, ptr %3, i64 %idxprom
  %5 = load i16, ptr %arrayidx, align 2
  %call = call noundef ptr @_ZNK6ImFont19FindGlyphNoFallbackEt(ptr noundef nonnull align 8 dereferenceable(118) %2, i16 noundef zeroext %5)
  %cmp1 = icmp ne ptr %call, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load ptr, ptr %candidate_chars.addr, align 8
  %7 = load i32, ptr %n, align 4
  %idxprom2 = sext i32 %7 to i64
  %arrayidx3 = getelementptr inbounds i16, ptr %6, i64 %idxprom2
  %8 = load i16, ptr %arrayidx3, align 2
  store i16 %8, ptr %retval, align 2
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, ptr %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, ptr %n, align 4
  br label %for.cond, !llvm.loop !90

for.end:                                          ; preds = %for.cond
  store i16 -1, ptr %retval, align 2
  br label %return

return:                                           ; preds = %for.end, %if.then
  %10 = load i16, ptr %retval, align 2
  ret i16 %10
}

; Function Attrs: mustprogress nounwind uwtable
define noundef zeroext i1 @_ZN6ImFont18IsGlyphRangeUnusedEjj(ptr noundef nonnull align 8 dereferenceable(118) %this, i32 noundef %c_begin, i32 noundef %c_last) #2 align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  %c_begin.addr = alloca i32, align 4
  %c_last.addr = alloca i32, align 4
  %page_begin = alloca i32, align 4
  %page_last = alloca i32, align 4
  %page_n = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %c_begin, ptr %c_begin.addr, align 4
  store i32 %c_last, ptr %c_last.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %c_begin.addr, align 4
  %div = udiv i32 %0, 4096
  store i32 %div, ptr %page_begin, align 4
  %1 = load i32, ptr %c_last.addr, align 4
  %div2 = udiv i32 %1, 4096
  store i32 %div2, ptr %page_last, align 4
  %2 = load i32, ptr %page_begin, align 4
  store i32 %2, ptr %page_n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i32, ptr %page_n, align 4
  %4 = load i32, ptr %page_last, align 4
  %cmp = icmp ule i32 %3, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i32, ptr %page_n, align 4
  %shr = lshr i32 %5, 3
  %conv = zext i32 %shr to i64
  %cmp3 = icmp ult i64 %conv, 2
  br i1 %cmp3, label %if.then, label %if.end8

if.then:                                          ; preds = %for.body
  %Used4kPagesMap = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 20
  %6 = load i32, ptr %page_n, align 4
  %shr4 = lshr i32 %6, 3
  %idxprom = zext i32 %shr4 to i64
  %arrayidx = getelementptr inbounds [2 x i8], ptr %Used4kPagesMap, i64 0, i64 %idxprom
  %7 = load i8, ptr %arrayidx, align 1
  %conv5 = zext i8 %7 to i32
  %8 = load i32, ptr %page_n, align 4
  %and = and i32 %8, 7
  %shl = shl i32 1, %and
  %and6 = and i32 %conv5, %shl
  %tobool = icmp ne i32 %and6, 0
  br i1 %tobool, label %if.then7, label %if.end

if.then7:                                         ; preds = %if.then
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end8

if.end8:                                          ; preds = %if.end, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end8
  %9 = load i32, ptr %page_n, align 4
  %inc = add i32 %9, 1
  store i32 %inc, ptr %page_n, align 4
  br label %for.cond, !llvm.loop !91

for.end:                                          ; preds = %for.cond
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then7
  %10 = load i1, ptr %retval, align 1
  ret i1 %10
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorIfE6resizeEiRKf(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_size, ptr noundef nonnull align 4 dereferenceable(4) %v) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_size.addr = alloca i32, align 4
  %v.addr = alloca ptr, align 8
  %n = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_size, ptr %new_size.addr, align 4
  store ptr %v, ptr %v.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_size.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.6, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sgt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %new_size.addr, align 4
  %call = call noundef i32 @_ZNK8ImVectorIfE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %2)
  call void @_ZN8ImVectorIfE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %new_size.addr, align 4
  %Size = getelementptr inbounds %struct.ImVector.6, ptr %this1, i32 0, i32 0
  %4 = load i32, ptr %Size, align 8
  %cmp2 = icmp sgt i32 %3, %4
  br i1 %cmp2, label %if.then3, label %if.end6

if.then3:                                         ; preds = %if.end
  %Size4 = getelementptr inbounds %struct.ImVector.6, ptr %this1, i32 0, i32 0
  %5 = load i32, ptr %Size4, align 8
  store i32 %5, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then3
  %6 = load i32, ptr %n, align 4
  %7 = load i32, ptr %new_size.addr, align 4
  %cmp5 = icmp slt i32 %6, %7
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %Data = getelementptr inbounds %struct.ImVector.6, ptr %this1, i32 0, i32 2
  %8 = load ptr, ptr %Data, align 8
  %9 = load i32, ptr %n, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr inbounds float, ptr %8, i64 %idxprom
  %10 = load ptr, ptr %v.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx, ptr align 4 %10, i64 4, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i32, ptr %n, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, ptr %n, align 4
  br label %for.cond, !llvm.loop !92

for.end:                                          ; preds = %for.cond
  br label %if.end6

if.end6:                                          ; preds = %for.end, %if.end
  %12 = load i32, ptr %new_size.addr, align 4
  %Size7 = getelementptr inbounds %struct.ImVector.6, ptr %this1, i32 0, i32 0
  store i32 %12, ptr %Size7, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorItE6resizeEiRKt(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_size, ptr noundef nonnull align 2 dereferenceable(2) %v) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_size.addr = alloca i32, align 4
  %v.addr = alloca ptr, align 8
  %n = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_size, ptr %new_size.addr, align 4
  store ptr %v, ptr %v.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_size.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sgt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %new_size.addr, align 4
  %call = call noundef i32 @_ZNK8ImVectorItE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %2)
  call void @_ZN8ImVectorItE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %new_size.addr, align 4
  %Size = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 0
  %4 = load i32, ptr %Size, align 8
  %cmp2 = icmp sgt i32 %3, %4
  br i1 %cmp2, label %if.then3, label %if.end6

if.then3:                                         ; preds = %if.end
  %Size4 = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 0
  %5 = load i32, ptr %Size4, align 8
  store i32 %5, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then3
  %6 = load i32, ptr %n, align 4
  %7 = load i32, ptr %new_size.addr, align 4
  %cmp5 = icmp slt i32 %6, %7
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %Data = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 2
  %8 = load ptr, ptr %Data, align 8
  %9 = load i32, ptr %n, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr inbounds i16, ptr %8, i64 %idxprom
  %10 = load ptr, ptr %v.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 2 %arrayidx, ptr align 2 %10, i64 2, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i32, ptr %n, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, ptr %n, align 4
  br label %for.cond, !llvm.loop !93

for.end:                                          ; preds = %for.cond
  br label %if.end6

if.end6:                                          ; preds = %for.end, %if.end
  %12 = load i32, ptr %new_size.addr, align 4
  %Size7 = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 0
  store i32 %12, ptr %Size7, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN6ImFont12AddRemapCharEttb(ptr noundef nonnull align 8 dereferenceable(118) %this, i16 noundef zeroext %dst, i16 noundef zeroext %src, i1 noundef zeroext %overwrite_dst) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %dst.addr = alloca i16, align 2
  %src.addr = alloca i16, align 2
  %overwrite_dst.addr = alloca i8, align 1
  %index_size = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i16 %dst, ptr %dst.addr, align 2
  store i16 %src, ptr %src.addr, align 2
  %frombool = zext i1 %overwrite_dst to i8
  store i8 %frombool, ptr %overwrite_dst.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %IndexLookup = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 3
  %Size = getelementptr inbounds %struct.ImVector.1, ptr %IndexLookup, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  store i32 %0, ptr %index_size, align 4
  %1 = load i16, ptr %dst.addr, align 2
  %conv = zext i16 %1 to i32
  %2 = load i32, ptr %index_size, align 4
  %cmp = icmp ult i32 %conv, %2
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %IndexLookup2 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 3
  %Data = getelementptr inbounds %struct.ImVector.1, ptr %IndexLookup2, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %4 = load i16, ptr %dst.addr, align 2
  %idxprom = zext i16 %4 to i64
  %arrayidx = getelementptr inbounds i16, ptr %3, i64 %idxprom
  %5 = load i16, ptr %arrayidx, align 2
  %conv3 = zext i16 %5 to i32
  %cmp4 = icmp eq i32 %conv3, 65535
  br i1 %cmp4, label %land.lhs.true5, label %if.end

land.lhs.true5:                                   ; preds = %land.lhs.true
  %6 = load i8, ptr %overwrite_dst.addr, align 1
  %tobool = trunc i8 %6 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true5
  br label %return

if.end:                                           ; preds = %land.lhs.true5, %land.lhs.true, %entry
  %7 = load i16, ptr %src.addr, align 2
  %conv6 = zext i16 %7 to i32
  %8 = load i32, ptr %index_size, align 4
  %cmp7 = icmp uge i32 %conv6, %8
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %if.end
  %9 = load i16, ptr %dst.addr, align 2
  %conv9 = zext i16 %9 to i32
  %10 = load i32, ptr %index_size, align 4
  %cmp10 = icmp uge i32 %conv9, %10
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  br label %return

if.end12:                                         ; preds = %land.lhs.true8, %if.end
  %11 = load i16, ptr %dst.addr, align 2
  %conv13 = zext i16 %11 to i32
  %add = add nsw i32 %conv13, 1
  call void @_ZN6ImFont9GrowIndexEi(ptr noundef nonnull align 8 dereferenceable(118) %this1, i32 noundef %add)
  %12 = load i16, ptr %src.addr, align 2
  %conv14 = zext i16 %12 to i32
  %13 = load i32, ptr %index_size, align 4
  %cmp15 = icmp ult i32 %conv14, %13
  br i1 %cmp15, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end12
  %IndexLookup16 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 3
  %Data17 = getelementptr inbounds %struct.ImVector.1, ptr %IndexLookup16, i32 0, i32 2
  %14 = load ptr, ptr %Data17, align 8
  %15 = load i16, ptr %src.addr, align 2
  %idxprom18 = zext i16 %15 to i64
  %arrayidx19 = getelementptr inbounds i16, ptr %14, i64 %idxprom18
  %16 = load i16, ptr %arrayidx19, align 2
  br label %cond.end

cond.false:                                       ; preds = %if.end12
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i16 [ %16, %cond.true ], [ -1, %cond.false ]
  %IndexLookup20 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 3
  %17 = load i16, ptr %dst.addr, align 2
  %conv21 = zext i16 %17 to i32
  %call = call noundef nonnull align 2 dereferenceable(2) ptr @_ZN8ImVectorItEixEi(ptr noundef nonnull align 8 dereferenceable(16) %IndexLookup20, i32 noundef %conv21)
  store i16 %cond, ptr %call, align 2
  %18 = load i16, ptr %src.addr, align 2
  %conv22 = zext i16 %18 to i32
  %19 = load i32, ptr %index_size, align 4
  %cmp23 = icmp ult i32 %conv22, %19
  br i1 %cmp23, label %cond.true24, label %cond.false28

cond.true24:                                      ; preds = %cond.end
  %IndexAdvanceX = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 0
  %Data25 = getelementptr inbounds %struct.ImVector.6, ptr %IndexAdvanceX, i32 0, i32 2
  %20 = load ptr, ptr %Data25, align 8
  %21 = load i16, ptr %src.addr, align 2
  %idxprom26 = zext i16 %21 to i64
  %arrayidx27 = getelementptr inbounds float, ptr %20, i64 %idxprom26
  %22 = load float, ptr %arrayidx27, align 4
  br label %cond.end29

cond.false28:                                     ; preds = %cond.end
  br label %cond.end29

cond.end29:                                       ; preds = %cond.false28, %cond.true24
  %cond30 = phi float [ %22, %cond.true24 ], [ 1.000000e+00, %cond.false28 ]
  %IndexAdvanceX31 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 0
  %23 = load i16, ptr %dst.addr, align 2
  %conv32 = zext i16 %23 to i32
  %call33 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZN8ImVectorIfEixEi(ptr noundef nonnull align 8 dereferenceable(16) %IndexAdvanceX31, i32 noundef %conv32)
  store float %cond30, ptr %call33, align 4
  br label %return

return:                                           ; preds = %cond.end29, %if.then11, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define noundef ptr @_ZNK6ImFont21CalcWordWrapPositionAEfPKcS1_f(ptr noundef nonnull align 8 dereferenceable(118) %this, float noundef %scale, ptr noundef %text, ptr noundef %text_end, float noundef %wrap_width) #4 align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %scale.addr = alloca float, align 4
  %text.addr = alloca ptr, align 8
  %text_end.addr = alloca ptr, align 8
  %wrap_width.addr = alloca float, align 4
  %line_width = alloca float, align 4
  %word_width = alloca float, align 4
  %blank_width = alloca float, align 4
  %word_end = alloca ptr, align 8
  %prev_word_end = alloca ptr, align 8
  %inside_word = alloca i8, align 1
  %s = alloca ptr, align 8
  %c = alloca i32, align 4
  %next_s = alloca ptr, align 8
  %char_width = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  store float %scale, ptr %scale.addr, align 4
  store ptr %text, ptr %text.addr, align 8
  store ptr %text_end, ptr %text_end.addr, align 8
  store float %wrap_width, ptr %wrap_width.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  store float 0.000000e+00, ptr %line_width, align 4
  store float 0.000000e+00, ptr %word_width, align 4
  store float 0.000000e+00, ptr %blank_width, align 4
  %0 = load float, ptr %scale.addr, align 4
  %1 = load float, ptr %wrap_width.addr, align 4
  %div = fdiv float %1, %0
  store float %div, ptr %wrap_width.addr, align 4
  %2 = load ptr, ptr %text.addr, align 8
  store ptr %2, ptr %word_end, align 8
  store ptr null, ptr %prev_word_end, align 8
  store i8 1, ptr %inside_word, align 1
  %3 = load ptr, ptr %text.addr, align 8
  store ptr %3, ptr %s, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end49, %if.then10, %if.then7, %entry
  %4 = load ptr, ptr %s, align 8
  %5 = load ptr, ptr %text_end.addr, align 8
  %cmp = icmp ult ptr %4, %5
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %6 = load ptr, ptr %s, align 8
  %7 = load i8, ptr %6, align 1
  %conv = sext i8 %7 to i32
  store i32 %conv, ptr %c, align 4
  %8 = load i32, ptr %c, align 4
  %cmp2 = icmp ult i32 %8, 128
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %while.body
  %9 = load ptr, ptr %s, align 8
  %add.ptr = getelementptr inbounds i8, ptr %9, i64 1
  store ptr %add.ptr, ptr %next_s, align 8
  br label %if.end

if.else:                                          ; preds = %while.body
  %10 = load ptr, ptr %s, align 8
  %11 = load ptr, ptr %s, align 8
  %12 = load ptr, ptr %text_end.addr, align 8
  %call = call noundef i32 @_Z18ImTextCharFromUtf8PjPKcS1_(ptr noundef %c, ptr noundef %11, ptr noundef %12)
  %idx.ext = sext i32 %call to i64
  %add.ptr3 = getelementptr inbounds i8, ptr %10, i64 %idx.ext
  store ptr %add.ptr3, ptr %next_s, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %13 = load i32, ptr %c, align 4
  %cmp4 = icmp ult i32 %13, 32
  br i1 %cmp4, label %if.then5, label %if.end12

if.then5:                                         ; preds = %if.end
  %14 = load i32, ptr %c, align 4
  %cmp6 = icmp eq i32 %14, 10
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.then5
  store float 0.000000e+00, ptr %blank_width, align 4
  store float 0.000000e+00, ptr %word_width, align 4
  store float 0.000000e+00, ptr %line_width, align 4
  store i8 1, ptr %inside_word, align 1
  %15 = load ptr, ptr %next_s, align 8
  store ptr %15, ptr %s, align 8
  br label %while.cond, !llvm.loop !94

if.end8:                                          ; preds = %if.then5
  %16 = load i32, ptr %c, align 4
  %cmp9 = icmp eq i32 %16, 13
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end8
  %17 = load ptr, ptr %next_s, align 8
  store ptr %17, ptr %s, align 8
  br label %while.cond, !llvm.loop !94

if.end11:                                         ; preds = %if.end8
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %if.end
  %18 = load i32, ptr %c, align 4
  %IndexAdvanceX = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 0
  %Size = getelementptr inbounds %struct.ImVector.6, ptr %IndexAdvanceX, i32 0, i32 0
  %19 = load i32, ptr %Size, align 8
  %cmp13 = icmp slt i32 %18, %19
  br i1 %cmp13, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end12
  %IndexAdvanceX14 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 0
  %Data = getelementptr inbounds %struct.ImVector.6, ptr %IndexAdvanceX14, i32 0, i32 2
  %20 = load ptr, ptr %Data, align 8
  %21 = load i32, ptr %c, align 4
  %idxprom = zext i32 %21 to i64
  %arrayidx = getelementptr inbounds float, ptr %20, i64 %idxprom
  %22 = load float, ptr %arrayidx, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end12
  %FallbackAdvanceX = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 1
  %23 = load float, ptr %FallbackAdvanceX, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %22, %cond.true ], [ %23, %cond.false ]
  store float %cond, ptr %char_width, align 4
  %24 = load i32, ptr %c, align 4
  %call15 = call noundef zeroext i1 @_ZL14ImCharIsBlankWj(i32 noundef %24)
  br i1 %call15, label %if.then16, label %if.else20

if.then16:                                        ; preds = %cond.end
  %25 = load i8, ptr %inside_word, align 1
  %tobool = trunc i8 %25 to i1
  br i1 %tobool, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.then16
  %26 = load float, ptr %blank_width, align 4
  %27 = load float, ptr %line_width, align 4
  %add = fadd float %27, %26
  store float %add, ptr %line_width, align 4
  store float 0.000000e+00, ptr %blank_width, align 4
  %28 = load ptr, ptr %s, align 8
  store ptr %28, ptr %word_end, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.then17, %if.then16
  %29 = load float, ptr %char_width, align 4
  %30 = load float, ptr %blank_width, align 4
  %add19 = fadd float %30, %29
  store float %add19, ptr %blank_width, align 4
  store i8 0, ptr %inside_word, align 1
  br label %if.end37

if.else20:                                        ; preds = %cond.end
  %31 = load float, ptr %char_width, align 4
  %32 = load float, ptr %word_width, align 4
  %add21 = fadd float %32, %31
  store float %add21, ptr %word_width, align 4
  %33 = load i8, ptr %inside_word, align 1
  %tobool22 = trunc i8 %33 to i1
  br i1 %tobool22, label %if.then23, label %if.else24

if.then23:                                        ; preds = %if.else20
  %34 = load ptr, ptr %next_s, align 8
  store ptr %34, ptr %word_end, align 8
  br label %if.end27

if.else24:                                        ; preds = %if.else20
  %35 = load ptr, ptr %word_end, align 8
  store ptr %35, ptr %prev_word_end, align 8
  %36 = load float, ptr %word_width, align 4
  %37 = load float, ptr %blank_width, align 4
  %add25 = fadd float %36, %37
  %38 = load float, ptr %line_width, align 4
  %add26 = fadd float %38, %add25
  store float %add26, ptr %line_width, align 4
  store float 0.000000e+00, ptr %blank_width, align 4
  store float 0.000000e+00, ptr %word_width, align 4
  br label %if.end27

if.end27:                                         ; preds = %if.else24, %if.then23
  %39 = load i32, ptr %c, align 4
  %cmp28 = icmp ne i32 %39, 46
  br i1 %cmp28, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %if.end27
  %40 = load i32, ptr %c, align 4
  %cmp29 = icmp ne i32 %40, 44
  br i1 %cmp29, label %land.lhs.true30, label %land.end

land.lhs.true30:                                  ; preds = %land.lhs.true
  %41 = load i32, ptr %c, align 4
  %cmp31 = icmp ne i32 %41, 59
  br i1 %cmp31, label %land.lhs.true32, label %land.end

land.lhs.true32:                                  ; preds = %land.lhs.true30
  %42 = load i32, ptr %c, align 4
  %cmp33 = icmp ne i32 %42, 33
  br i1 %cmp33, label %land.lhs.true34, label %land.end

land.lhs.true34:                                  ; preds = %land.lhs.true32
  %43 = load i32, ptr %c, align 4
  %cmp35 = icmp ne i32 %43, 63
  br i1 %cmp35, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true34
  %44 = load i32, ptr %c, align 4
  %cmp36 = icmp ne i32 %44, 34
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true34, %land.lhs.true32, %land.lhs.true30, %land.lhs.true, %if.end27
  %45 = phi i1 [ false, %land.lhs.true34 ], [ false, %land.lhs.true32 ], [ false, %land.lhs.true30 ], [ false, %land.lhs.true ], [ false, %if.end27 ], [ %cmp36, %land.rhs ]
  %frombool = zext i1 %45 to i8
  store i8 %frombool, ptr %inside_word, align 1
  br label %if.end37

if.end37:                                         ; preds = %land.end, %if.end18
  %46 = load float, ptr %line_width, align 4
  %47 = load float, ptr %word_width, align 4
  %add38 = fadd float %46, %47
  %48 = load float, ptr %wrap_width.addr, align 4
  %cmp39 = fcmp ogt float %add38, %48
  br i1 %cmp39, label %if.then40, label %if.end49

if.then40:                                        ; preds = %if.end37
  %49 = load float, ptr %word_width, align 4
  %50 = load float, ptr %wrap_width.addr, align 4
  %cmp41 = fcmp olt float %49, %50
  br i1 %cmp41, label %if.then42, label %if.end48

if.then42:                                        ; preds = %if.then40
  %51 = load ptr, ptr %prev_word_end, align 8
  %tobool43 = icmp ne ptr %51, null
  br i1 %tobool43, label %cond.true44, label %cond.false45

cond.true44:                                      ; preds = %if.then42
  %52 = load ptr, ptr %prev_word_end, align 8
  br label %cond.end46

cond.false45:                                     ; preds = %if.then42
  %53 = load ptr, ptr %word_end, align 8
  br label %cond.end46

cond.end46:                                       ; preds = %cond.false45, %cond.true44
  %cond47 = phi ptr [ %52, %cond.true44 ], [ %53, %cond.false45 ]
  store ptr %cond47, ptr %s, align 8
  br label %if.end48

if.end48:                                         ; preds = %cond.end46, %if.then40
  br label %while.end

if.end49:                                         ; preds = %if.end37
  %54 = load ptr, ptr %next_s, align 8
  store ptr %54, ptr %s, align 8
  br label %while.cond, !llvm.loop !94

while.end:                                        ; preds = %if.end48, %while.cond
  %55 = load ptr, ptr %s, align 8
  %56 = load ptr, ptr %text.addr, align 8
  %cmp50 = icmp eq ptr %55, %56
  br i1 %cmp50, label %land.lhs.true51, label %if.end55

land.lhs.true51:                                  ; preds = %while.end
  %57 = load ptr, ptr %text.addr, align 8
  %58 = load ptr, ptr %text_end.addr, align 8
  %cmp52 = icmp ult ptr %57, %58
  br i1 %cmp52, label %if.then53, label %if.end55

if.then53:                                        ; preds = %land.lhs.true51
  %59 = load ptr, ptr %s, align 8
  %add.ptr54 = getelementptr inbounds i8, ptr %59, i64 1
  store ptr %add.ptr54, ptr %retval, align 8
  br label %return

if.end55:                                         ; preds = %land.lhs.true51, %while.end
  %60 = load ptr, ptr %s, align 8
  store ptr %60, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end55, %if.then53
  %61 = load ptr, ptr %retval, align 8
  ret ptr %61
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef zeroext i1 @_ZL14ImCharIsBlankWj(i32 noundef %c) #2 {
entry:
  %c.addr = alloca i32, align 4
  store i32 %c, ptr %c.addr, align 4
  %0 = load i32, ptr %c.addr, align 4
  %cmp = icmp eq i32 %0, 32
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %c.addr, align 4
  %cmp1 = icmp eq i32 %1, 9
  br i1 %cmp1, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false
  %2 = load i32, ptr %c.addr, align 4
  %cmp2 = icmp eq i32 %2, 12288
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false, %entry
  %3 = phi i1 [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp2, %lor.rhs ]
  ret i1 %3
}

; Function Attrs: mustprogress uwtable
define <2 x float> @_ZNK6ImFont13CalcTextSizeAEfffPKcS1_PS1_(ptr noundef nonnull align 8 dereferenceable(118) %this, float noundef %size, float noundef %max_width, float noundef %wrap_width, ptr noundef %text_begin, ptr noundef %text_end, ptr noundef %remaining) #0 align 2 {
entry:
  %retval = alloca %struct.ImVec2, align 4
  %this.addr = alloca ptr, align 8
  %size.addr = alloca float, align 4
  %max_width.addr = alloca float, align 4
  %wrap_width.addr = alloca float, align 4
  %text_begin.addr = alloca ptr, align 8
  %text_end.addr = alloca ptr, align 8
  %remaining.addr = alloca ptr, align 8
  %line_height = alloca float, align 4
  %scale = alloca float, align 4
  %line_width = alloca float, align 4
  %word_wrap_enabled = alloca i8, align 1
  %word_wrap_eol = alloca ptr, align 8
  %s = alloca ptr, align 8
  %prev_s = alloca ptr, align 8
  %c = alloca i32, align 4
  %char_width = alloca float, align 4
  store ptr %this, ptr %this.addr, align 8
  store float %size, ptr %size.addr, align 4
  store float %max_width, ptr %max_width.addr, align 4
  store float %wrap_width, ptr %wrap_width.addr, align 4
  store ptr %text_begin, ptr %text_begin.addr, align 8
  store ptr %text_end, ptr %text_end.addr, align 8
  store ptr %remaining, ptr %remaining.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %text_end.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %text_begin.addr, align 8
  %2 = load ptr, ptr %text_begin.addr, align 8
  %call = call i64 @strlen(ptr noundef %2) #14
  %add.ptr = getelementptr inbounds i8, ptr %1, i64 %call
  store ptr %add.ptr, ptr %text_end.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load float, ptr %size.addr, align 4
  store float %3, ptr %line_height, align 4
  %4 = load float, ptr %size.addr, align 4
  %FontSize = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 2
  %5 = load float, ptr %FontSize, align 4
  %div = fdiv float %4, %5
  store float %div, ptr %scale, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %retval, float noundef 0.000000e+00, float noundef 0.000000e+00)
  store float 0.000000e+00, ptr %line_width, align 4
  %6 = load float, ptr %wrap_width.addr, align 4
  %cmp = fcmp ogt float %6, 0.000000e+00
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, ptr %word_wrap_enabled, align 1
  store ptr null, ptr %word_wrap_eol, align 8
  %7 = load ptr, ptr %text_begin.addr, align 8
  store ptr %7, ptr %s, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end43, %if.then35, %if.then27, %if.end14, %if.end
  %8 = load ptr, ptr %s, align 8
  %9 = load ptr, ptr %text_end.addr, align 8
  %cmp2 = icmp ult ptr %8, %9
  br i1 %cmp2, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %10 = load i8, ptr %word_wrap_enabled, align 1
  %tobool3 = trunc i8 %10 to i1
  br i1 %tobool3, label %if.then4, label %if.end17

if.then4:                                         ; preds = %while.body
  %11 = load ptr, ptr %word_wrap_eol, align 8
  %tobool5 = icmp ne ptr %11, null
  br i1 %tobool5, label %if.end8, label %if.then6

if.then6:                                         ; preds = %if.then4
  %12 = load float, ptr %scale, align 4
  %13 = load ptr, ptr %s, align 8
  %14 = load ptr, ptr %text_end.addr, align 8
  %15 = load float, ptr %wrap_width.addr, align 4
  %16 = load float, ptr %line_width, align 4
  %sub = fsub float %15, %16
  %call7 = call noundef ptr @_ZNK6ImFont21CalcWordWrapPositionAEfPKcS1_f(ptr noundef nonnull align 8 dereferenceable(118) %this1, float noundef %12, ptr noundef %13, ptr noundef %14, float noundef %sub)
  store ptr %call7, ptr %word_wrap_eol, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.then4
  %17 = load ptr, ptr %s, align 8
  %18 = load ptr, ptr %word_wrap_eol, align 8
  %cmp9 = icmp uge ptr %17, %18
  br i1 %cmp9, label %if.then10, label %if.end16

if.then10:                                        ; preds = %if.end8
  %x = getelementptr inbounds %struct.ImVec2, ptr %retval, i32 0, i32 0
  %19 = load float, ptr %x, align 4
  %20 = load float, ptr %line_width, align 4
  %cmp11 = fcmp olt float %19, %20
  br i1 %cmp11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.then10
  %21 = load float, ptr %line_width, align 4
  %x13 = getelementptr inbounds %struct.ImVec2, ptr %retval, i32 0, i32 0
  store float %21, ptr %x13, align 4
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.then10
  %22 = load float, ptr %line_height, align 4
  %y = getelementptr inbounds %struct.ImVec2, ptr %retval, i32 0, i32 1
  %23 = load float, ptr %y, align 4
  %add = fadd float %23, %22
  store float %add, ptr %y, align 4
  store float 0.000000e+00, ptr %line_width, align 4
  store ptr null, ptr %word_wrap_eol, align 8
  %24 = load ptr, ptr %s, align 8
  %25 = load ptr, ptr %text_end.addr, align 8
  %call15 = call noundef ptr @_ZL26CalcWordWrapNextLineStartAPKcS0_(ptr noundef %24, ptr noundef %25)
  store ptr %call15, ptr %s, align 8
  br label %while.cond, !llvm.loop !95

if.end16:                                         ; preds = %if.end8
  br label %if.end17

if.end17:                                         ; preds = %if.end16, %while.body
  %26 = load ptr, ptr %s, align 8
  store ptr %26, ptr %prev_s, align 8
  %27 = load ptr, ptr %s, align 8
  %28 = load i8, ptr %27, align 1
  %conv = sext i8 %28 to i32
  store i32 %conv, ptr %c, align 4
  %29 = load i32, ptr %c, align 4
  %cmp18 = icmp ult i32 %29, 128
  br i1 %cmp18, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end17
  %30 = load ptr, ptr %s, align 8
  %add.ptr20 = getelementptr inbounds i8, ptr %30, i64 1
  store ptr %add.ptr20, ptr %s, align 8
  br label %if.end23

if.else:                                          ; preds = %if.end17
  %31 = load ptr, ptr %s, align 8
  %32 = load ptr, ptr %text_end.addr, align 8
  %call21 = call noundef i32 @_Z18ImTextCharFromUtf8PjPKcS1_(ptr noundef %c, ptr noundef %31, ptr noundef %32)
  %33 = load ptr, ptr %s, align 8
  %idx.ext = sext i32 %call21 to i64
  %add.ptr22 = getelementptr inbounds i8, ptr %33, i64 %idx.ext
  store ptr %add.ptr22, ptr %s, align 8
  br label %if.end23

if.end23:                                         ; preds = %if.else, %if.then19
  %34 = load i32, ptr %c, align 4
  %cmp24 = icmp ult i32 %34, 32
  br i1 %cmp24, label %if.then25, label %if.end37

if.then25:                                        ; preds = %if.end23
  %35 = load i32, ptr %c, align 4
  %cmp26 = icmp eq i32 %35, 10
  br i1 %cmp26, label %if.then27, label %if.end33

if.then27:                                        ; preds = %if.then25
  %x28 = getelementptr inbounds %struct.ImVec2, ptr %retval, i32 0, i32 0
  %36 = load float, ptr %x28, align 4
  %37 = load float, ptr %line_width, align 4
  %call29 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %36, float noundef %37)
  %x30 = getelementptr inbounds %struct.ImVec2, ptr %retval, i32 0, i32 0
  store float %call29, ptr %x30, align 4
  %38 = load float, ptr %line_height, align 4
  %y31 = getelementptr inbounds %struct.ImVec2, ptr %retval, i32 0, i32 1
  %39 = load float, ptr %y31, align 4
  %add32 = fadd float %39, %38
  store float %add32, ptr %y31, align 4
  store float 0.000000e+00, ptr %line_width, align 4
  br label %while.cond, !llvm.loop !95

if.end33:                                         ; preds = %if.then25
  %40 = load i32, ptr %c, align 4
  %cmp34 = icmp eq i32 %40, 13
  br i1 %cmp34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.end33
  br label %while.cond, !llvm.loop !95

if.end36:                                         ; preds = %if.end33
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.end23
  %41 = load i32, ptr %c, align 4
  %IndexAdvanceX = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 0
  %Size = getelementptr inbounds %struct.ImVector.6, ptr %IndexAdvanceX, i32 0, i32 0
  %42 = load i32, ptr %Size, align 8
  %cmp38 = icmp slt i32 %41, %42
  br i1 %cmp38, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end37
  %IndexAdvanceX39 = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 0
  %Data = getelementptr inbounds %struct.ImVector.6, ptr %IndexAdvanceX39, i32 0, i32 2
  %43 = load ptr, ptr %Data, align 8
  %44 = load i32, ptr %c, align 4
  %idxprom = zext i32 %44 to i64
  %arrayidx = getelementptr inbounds float, ptr %43, i64 %idxprom
  %45 = load float, ptr %arrayidx, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end37
  %FallbackAdvanceX = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 1
  %46 = load float, ptr %FallbackAdvanceX, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %45, %cond.true ], [ %46, %cond.false ]
  %47 = load float, ptr %scale, align 4
  %mul = fmul float %cond, %47
  store float %mul, ptr %char_width, align 4
  %48 = load float, ptr %line_width, align 4
  %49 = load float, ptr %char_width, align 4
  %add40 = fadd float %48, %49
  %50 = load float, ptr %max_width.addr, align 4
  %cmp41 = fcmp oge float %add40, %50
  br i1 %cmp41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %cond.end
  %51 = load ptr, ptr %prev_s, align 8
  store ptr %51, ptr %s, align 8
  br label %while.end

if.end43:                                         ; preds = %cond.end
  %52 = load float, ptr %char_width, align 4
  %53 = load float, ptr %line_width, align 4
  %add44 = fadd float %53, %52
  store float %add44, ptr %line_width, align 4
  br label %while.cond, !llvm.loop !95

while.end:                                        ; preds = %if.then42, %while.cond
  %x45 = getelementptr inbounds %struct.ImVec2, ptr %retval, i32 0, i32 0
  %54 = load float, ptr %x45, align 4
  %55 = load float, ptr %line_width, align 4
  %cmp46 = fcmp olt float %54, %55
  br i1 %cmp46, label %if.then47, label %if.end49

if.then47:                                        ; preds = %while.end
  %56 = load float, ptr %line_width, align 4
  %x48 = getelementptr inbounds %struct.ImVec2, ptr %retval, i32 0, i32 0
  store float %56, ptr %x48, align 4
  br label %if.end49

if.end49:                                         ; preds = %if.then47, %while.end
  %57 = load float, ptr %line_width, align 4
  %cmp50 = fcmp ogt float %57, 0.000000e+00
  br i1 %cmp50, label %if.then53, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end49
  %y51 = getelementptr inbounds %struct.ImVec2, ptr %retval, i32 0, i32 1
  %58 = load float, ptr %y51, align 4
  %cmp52 = fcmp oeq float %58, 0.000000e+00
  br i1 %cmp52, label %if.then53, label %if.end56

if.then53:                                        ; preds = %lor.lhs.false, %if.end49
  %59 = load float, ptr %line_height, align 4
  %y54 = getelementptr inbounds %struct.ImVec2, ptr %retval, i32 0, i32 1
  %60 = load float, ptr %y54, align 4
  %add55 = fadd float %60, %59
  store float %add55, ptr %y54, align 4
  br label %if.end56

if.end56:                                         ; preds = %if.then53, %lor.lhs.false
  %61 = load ptr, ptr %remaining.addr, align 8
  %tobool57 = icmp ne ptr %61, null
  br i1 %tobool57, label %if.then58, label %if.end59

if.then58:                                        ; preds = %if.end56
  %62 = load ptr, ptr %s, align 8
  %63 = load ptr, ptr %remaining.addr, align 8
  store ptr %62, ptr %63, align 8
  br label %if.end59

if.end59:                                         ; preds = %if.then58, %if.end56
  %64 = load <2 x float>, ptr %retval, align 4
  ret <2 x float> %64
}

; Function Attrs: mustprogress uwtable
define internal noundef ptr @_ZL26CalcWordWrapNextLineStartAPKcS0_(ptr noundef %text, ptr noundef %text_end) #4 {
entry:
  %text.addr = alloca ptr, align 8
  %text_end.addr = alloca ptr, align 8
  store ptr %text, ptr %text.addr, align 8
  store ptr %text_end, ptr %text_end.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load ptr, ptr %text.addr, align 8
  %1 = load ptr, ptr %text_end.addr, align 8
  %cmp = icmp ult ptr %0, %1
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %2 = load ptr, ptr %text.addr, align 8
  %3 = load i8, ptr %2, align 1
  %call = call noundef zeroext i1 @_ZL14ImCharIsBlankAc(i8 noundef signext %3)
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %4 = phi i1 [ false, %while.cond ], [ %call, %land.rhs ]
  br i1 %4, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %5 = load ptr, ptr %text.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %5, i32 1
  store ptr %incdec.ptr, ptr %text.addr, align 8
  br label %while.cond, !llvm.loop !96

while.end:                                        ; preds = %land.end
  %6 = load ptr, ptr %text.addr, align 8
  %7 = load i8, ptr %6, align 1
  %conv = sext i8 %7 to i32
  %cmp1 = icmp eq i32 %conv, 10
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %while.end
  %8 = load ptr, ptr %text.addr, align 8
  %incdec.ptr2 = getelementptr inbounds i8, ptr %8, i32 1
  store ptr %incdec.ptr2, ptr %text.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %while.end
  %9 = load ptr, ptr %text.addr, align 8
  ret ptr %9
}

; Function Attrs: mustprogress uwtable
define void @_ZNK6ImFont10RenderCharEP10ImDrawListfRK6ImVec2jt(ptr noundef nonnull align 8 dereferenceable(118) %this, ptr noundef %draw_list, float noundef %size, ptr noundef nonnull align 4 dereferenceable(8) %pos, i32 noundef %col, i16 noundef zeroext %c) #4 align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %draw_list.addr = alloca ptr, align 8
  %size.addr = alloca float, align 4
  %pos.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  %c.addr = alloca i16, align 2
  %glyph = alloca ptr, align 8
  %scale = alloca float, align 4
  %x = alloca float, align 4
  %y = alloca float, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  %ref.tmp13 = alloca %struct.ImVec2, align 4
  %ref.tmp14 = alloca %struct.ImVec2, align 4
  %ref.tmp15 = alloca %struct.ImVec2, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %draw_list, ptr %draw_list.addr, align 8
  store float %size, ptr %size.addr, align 4
  store ptr %pos, ptr %pos.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  store i16 %c, ptr %c.addr, align 2
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i16, ptr %c.addr, align 2
  %call = call noundef ptr @_ZNK6ImFont9FindGlyphEt(ptr noundef nonnull align 8 dereferenceable(118) %this1, i16 noundef zeroext %0)
  store ptr %call, ptr %glyph, align 8
  %1 = load ptr, ptr %glyph, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %glyph, align 8
  %bf.load = load i32, ptr %2, align 4
  %bf.lshr = lshr i32 %bf.load, 1
  %bf.clear = and i32 %bf.lshr, 1
  %tobool2 = icmp ne i32 %bf.clear, 0
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %3 = load ptr, ptr %glyph, align 8
  %bf.load3 = load i32, ptr %3, align 4
  %bf.clear4 = and i32 %bf.load3, 1
  %tobool5 = icmp ne i32 %bf.clear4, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %4 = load i32, ptr %col.addr, align 4
  %or = or i32 %4, 16777215
  store i32 %or, ptr %col.addr, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end
  %5 = load float, ptr %size.addr, align 4
  %cmp = fcmp oge float %5, 0.000000e+00
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end7
  %6 = load float, ptr %size.addr, align 4
  %FontSize = getelementptr inbounds %struct.ImFont, ptr %this1, i32 0, i32 2
  %7 = load float, ptr %FontSize, align 4
  %div = fdiv float %6, %7
  br label %cond.end

cond.false:                                       ; preds = %if.end7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %div, %cond.true ], [ 1.000000e+00, %cond.false ]
  store float %cond, ptr %scale, align 4
  %8 = load ptr, ptr %pos.addr, align 8
  %x8 = getelementptr inbounds %struct.ImVec2, ptr %8, i32 0, i32 0
  %9 = load float, ptr %x8, align 4
  %conv = fptosi float %9 to i32
  %conv9 = sitofp i32 %conv to float
  store float %conv9, ptr %x, align 4
  %10 = load ptr, ptr %pos.addr, align 8
  %y10 = getelementptr inbounds %struct.ImVec2, ptr %10, i32 0, i32 1
  %11 = load float, ptr %y10, align 4
  %conv11 = fptosi float %11 to i32
  %conv12 = sitofp i32 %conv11 to float
  store float %conv12, ptr %y, align 4
  %12 = load ptr, ptr %draw_list.addr, align 8
  call void @_ZN10ImDrawList11PrimReserveEii(ptr noundef nonnull align 8 dereferenceable(196) %12, i32 noundef 6, i32 noundef 4)
  %13 = load ptr, ptr %draw_list.addr, align 8
  %14 = load float, ptr %x, align 4
  %15 = load ptr, ptr %glyph, align 8
  %X0 = getelementptr inbounds %struct.ImFontGlyph, ptr %15, i32 0, i32 2
  %16 = load float, ptr %X0, align 4
  %17 = load float, ptr %scale, align 4
  %18 = call float @llvm.fmuladd.f32(float %16, float %17, float %14)
  %19 = load float, ptr %y, align 4
  %20 = load ptr, ptr %glyph, align 8
  %Y0 = getelementptr inbounds %struct.ImFontGlyph, ptr %20, i32 0, i32 3
  %21 = load float, ptr %Y0, align 4
  %22 = load float, ptr %scale, align 4
  %23 = call float @llvm.fmuladd.f32(float %21, float %22, float %19)
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef %18, float noundef %23)
  %24 = load float, ptr %x, align 4
  %25 = load ptr, ptr %glyph, align 8
  %X1 = getelementptr inbounds %struct.ImFontGlyph, ptr %25, i32 0, i32 4
  %26 = load float, ptr %X1, align 4
  %27 = load float, ptr %scale, align 4
  %28 = call float @llvm.fmuladd.f32(float %26, float %27, float %24)
  %29 = load float, ptr %y, align 4
  %30 = load ptr, ptr %glyph, align 8
  %Y1 = getelementptr inbounds %struct.ImFontGlyph, ptr %30, i32 0, i32 5
  %31 = load float, ptr %Y1, align 4
  %32 = load float, ptr %scale, align 4
  %33 = call float @llvm.fmuladd.f32(float %31, float %32, float %29)
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp13, float noundef %28, float noundef %33)
  %34 = load ptr, ptr %glyph, align 8
  %U0 = getelementptr inbounds %struct.ImFontGlyph, ptr %34, i32 0, i32 6
  %35 = load float, ptr %U0, align 4
  %36 = load ptr, ptr %glyph, align 8
  %V0 = getelementptr inbounds %struct.ImFontGlyph, ptr %36, i32 0, i32 7
  %37 = load float, ptr %V0, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp14, float noundef %35, float noundef %37)
  %38 = load ptr, ptr %glyph, align 8
  %U1 = getelementptr inbounds %struct.ImFontGlyph, ptr %38, i32 0, i32 8
  %39 = load float, ptr %U1, align 4
  %40 = load ptr, ptr %glyph, align 8
  %V1 = getelementptr inbounds %struct.ImFontGlyph, ptr %40, i32 0, i32 9
  %41 = load float, ptr %V1, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp15, float noundef %39, float noundef %41)
  %42 = load i32, ptr %col.addr, align 4
  call void @_ZN10ImDrawList10PrimRectUVERK6ImVec2S2_S2_S2_j(ptr noundef nonnull align 8 dereferenceable(196) %13, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp13, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp14, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp15, i32 noundef %42)
  br label %return

return:                                           ; preds = %cond.end, %if.then
  ret void
}

; Function Attrs: nounwind willreturn memory(read)
declare noundef ptr @memchr(ptr noundef, i32 noundef, i64 noundef) #8

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui11RenderArrowEP10ImDrawList6ImVec2jif(ptr noundef %draw_list, <2 x float> %pos.coerce, i32 noundef %col, i32 noundef %dir, float noundef %scale) #0 {
entry:
  %pos = alloca %struct.ImVec2, align 4
  %draw_list.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  %dir.addr = alloca i32, align 4
  %scale.addr = alloca float, align 4
  %h = alloca float, align 4
  %r = alloca float, align 4
  %center = alloca %struct.ImVec2, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  %a = alloca %struct.ImVec2, align 4
  %b = alloca %struct.ImVec2, align 4
  %c = alloca %struct.ImVec2, align 4
  %ref.tmp6 = alloca %struct.ImVec2, align 4
  %ref.tmp7 = alloca %struct.ImVec2, align 4
  %ref.tmp9 = alloca %struct.ImVec2, align 4
  %ref.tmp10 = alloca %struct.ImVec2, align 4
  %ref.tmp12 = alloca %struct.ImVec2, align 4
  %ref.tmp13 = alloca %struct.ImVec2, align 4
  %ref.tmp20 = alloca %struct.ImVec2, align 4
  %ref.tmp21 = alloca %struct.ImVec2, align 4
  %ref.tmp23 = alloca %struct.ImVec2, align 4
  %ref.tmp24 = alloca %struct.ImVec2, align 4
  %ref.tmp26 = alloca %struct.ImVec2, align 4
  %ref.tmp27 = alloca %struct.ImVec2, align 4
  %ref.tmp30 = alloca %struct.ImVec2, align 4
  %ref.tmp32 = alloca %struct.ImVec2, align 4
  %ref.tmp34 = alloca %struct.ImVec2, align 4
  store <2 x float> %pos.coerce, ptr %pos, align 4
  store ptr %draw_list, ptr %draw_list.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  store i32 %dir, ptr %dir.addr, align 4
  store float %scale, ptr %scale.addr, align 4
  %0 = load ptr, ptr %draw_list.addr, align 8
  %_Data = getelementptr inbounds %struct.ImDrawList, ptr %0, i32 0, i32 5
  %1 = load ptr, ptr %_Data, align 8
  %FontSize = getelementptr inbounds %struct.ImDrawListSharedData, ptr %1, i32 0, i32 2
  %2 = load float, ptr %FontSize, align 8
  %mul = fmul float %2, 1.000000e+00
  store float %mul, ptr %h, align 4
  %3 = load float, ptr %h, align 4
  %mul1 = fmul float %3, 0x3FD99999A0000000
  %4 = load float, ptr %scale.addr, align 4
  %mul2 = fmul float %mul1, %4
  store float %mul2, ptr %r, align 4
  %5 = load float, ptr %h, align 4
  %mul3 = fmul float %5, 5.000000e-01
  %6 = load float, ptr %h, align 4
  %mul4 = fmul float %6, 5.000000e-01
  %7 = load float, ptr %scale.addr, align 4
  %mul5 = fmul float %mul4, %7
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef %mul3, float noundef %mul5)
  %call = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %pos, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp)
  store <2 x float> %call, ptr %center, align 4
  call void @_ZN6ImVec2C2Ev(ptr noundef nonnull align 4 dereferenceable(8) %a)
  call void @_ZN6ImVec2C2Ev(ptr noundef nonnull align 4 dereferenceable(8) %b)
  call void @_ZN6ImVec2C2Ev(ptr noundef nonnull align 4 dereferenceable(8) %c)
  %8 = load i32, ptr %dir.addr, align 4
  switch i32 %8, label %sw.epilog [
    i32 2, label %sw.bb
    i32 3, label %sw.bb
    i32 0, label %sw.bb15
    i32 1, label %sw.bb15
    i32 -1, label %sw.bb29
    i32 4, label %sw.bb29
  ]

sw.bb:                                            ; preds = %entry, %entry
  %9 = load i32, ptr %dir.addr, align 4
  %cmp = icmp eq i32 %9, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  %10 = load float, ptr %r, align 4
  %fneg = fneg float %10
  store float %fneg, ptr %r, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp7, float noundef 0.000000e+00, float noundef 7.500000e-01)
  %11 = load float, ptr %r, align 4
  %call8 = call <2 x float> @_ZmlRK6ImVec2f(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp7, float noundef %11)
  store <2 x float> %call8, ptr %ref.tmp6, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %a, ptr align 4 %ref.tmp6, i64 8, i1 false)
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp10, float noundef 0xBFEBB645A0000000, float noundef -7.500000e-01)
  %12 = load float, ptr %r, align 4
  %call11 = call <2 x float> @_ZmlRK6ImVec2f(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp10, float noundef %12)
  store <2 x float> %call11, ptr %ref.tmp9, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %b, ptr align 4 %ref.tmp9, i64 8, i1 false)
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp13, float noundef 0x3FEBB645A0000000, float noundef -7.500000e-01)
  %13 = load float, ptr %r, align 4
  %call14 = call <2 x float> @_ZmlRK6ImVec2f(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp13, float noundef %13)
  store <2 x float> %call14, ptr %ref.tmp12, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %c, ptr align 4 %ref.tmp12, i64 8, i1 false)
  br label %sw.epilog

sw.bb15:                                          ; preds = %entry, %entry
  %14 = load i32, ptr %dir.addr, align 4
  %cmp16 = icmp eq i32 %14, 0
  br i1 %cmp16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %sw.bb15
  %15 = load float, ptr %r, align 4
  %fneg18 = fneg float %15
  store float %fneg18, ptr %r, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %sw.bb15
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp21, float noundef 7.500000e-01, float noundef 0.000000e+00)
  %16 = load float, ptr %r, align 4
  %call22 = call <2 x float> @_ZmlRK6ImVec2f(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp21, float noundef %16)
  store <2 x float> %call22, ptr %ref.tmp20, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %a, ptr align 4 %ref.tmp20, i64 8, i1 false)
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp24, float noundef -7.500000e-01, float noundef 0x3FEBB645A0000000)
  %17 = load float, ptr %r, align 4
  %call25 = call <2 x float> @_ZmlRK6ImVec2f(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp24, float noundef %17)
  store <2 x float> %call25, ptr %ref.tmp23, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %b, ptr align 4 %ref.tmp23, i64 8, i1 false)
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp27, float noundef -7.500000e-01, float noundef 0xBFEBB645A0000000)
  %18 = load float, ptr %r, align 4
  %call28 = call <2 x float> @_ZmlRK6ImVec2f(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp27, float noundef %18)
  store <2 x float> %call28, ptr %ref.tmp26, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %c, ptr align 4 %ref.tmp26, i64 8, i1 false)
  br label %sw.epilog

sw.bb29:                                          ; preds = %entry, %entry
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb29, %if.end19, %if.end, %entry
  %19 = load ptr, ptr %draw_list.addr, align 8
  %call31 = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %center, ptr noundef nonnull align 4 dereferenceable(8) %a)
  store <2 x float> %call31, ptr %ref.tmp30, align 4
  %call33 = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %center, ptr noundef nonnull align 4 dereferenceable(8) %b)
  store <2 x float> %call33, ptr %ref.tmp32, align 4
  %call35 = call <2 x float> @_ZplRK6ImVec2S1_(ptr noundef nonnull align 4 dereferenceable(8) %center, ptr noundef nonnull align 4 dereferenceable(8) %c)
  store <2 x float> %call35, ptr %ref.tmp34, align 4
  %20 = load i32, ptr %col.addr, align 4
  call void @_ZN10ImDrawList17AddTriangleFilledERK6ImVec2S2_S2_j(ptr noundef nonnull align 8 dereferenceable(196) %19, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp30, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp32, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp34, i32 noundef %20)
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui12RenderBulletEP10ImDrawList6ImVec2j(ptr noundef %draw_list, <2 x float> %pos.coerce, i32 noundef %col) #0 {
entry:
  %pos = alloca %struct.ImVec2, align 4
  %draw_list.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  store <2 x float> %pos.coerce, ptr %pos, align 4
  store ptr %draw_list, ptr %draw_list.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  %0 = load ptr, ptr %draw_list.addr, align 8
  %1 = load ptr, ptr %draw_list.addr, align 8
  %_Data = getelementptr inbounds %struct.ImDrawList, ptr %1, i32 0, i32 5
  %2 = load ptr, ptr %_Data, align 8
  %FontSize = getelementptr inbounds %struct.ImDrawListSharedData, ptr %2, i32 0, i32 2
  %3 = load float, ptr %FontSize, align 8
  %mul = fmul float %3, 0x3FC99999A0000000
  %4 = load i32, ptr %col.addr, align 4
  call void @_ZN10ImDrawList15AddCircleFilledERK6ImVec2fji(ptr noundef nonnull align 8 dereferenceable(196) %0, ptr noundef nonnull align 4 dereferenceable(8) %pos, float noundef %mul, i32 noundef %4, i32 noundef 8)
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui15RenderCheckMarkEP10ImDrawList6ImVec2jf(ptr noundef %draw_list, <2 x float> %pos.coerce, i32 noundef %col, float noundef %sz) #0 {
entry:
  %pos = alloca %struct.ImVec2, align 4
  %draw_list.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  %sz.addr = alloca float, align 4
  %thickness = alloca float, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  %third = alloca float, align 4
  %bx = alloca float, align 4
  %by = alloca float, align 4
  %ref.tmp7 = alloca %struct.ImVec2, align 4
  %ref.tmp9 = alloca %struct.ImVec2, align 4
  %ref.tmp10 = alloca %struct.ImVec2, align 4
  store <2 x float> %pos.coerce, ptr %pos, align 4
  store ptr %draw_list, ptr %draw_list.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  store float %sz, ptr %sz.addr, align 4
  %0 = load float, ptr %sz.addr, align 4
  %div = fdiv float %0, 5.000000e+00
  %call = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %div, float noundef 1.000000e+00)
  store float %call, ptr %thickness, align 4
  %1 = load float, ptr %thickness, align 4
  %2 = load float, ptr %sz.addr, align 4
  %neg = fneg float %1
  %3 = call float @llvm.fmuladd.f32(float %neg, float 5.000000e-01, float %2)
  store float %3, ptr %sz.addr, align 4
  %4 = load float, ptr %thickness, align 4
  %mul = fmul float %4, 2.500000e-01
  %5 = load float, ptr %thickness, align 4
  %mul1 = fmul float %5, 2.500000e-01
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef %mul, float noundef %mul1)
  %call2 = call noundef nonnull align 4 dereferenceable(8) ptr @_ZpLR6ImVec2RKS_(ptr noundef nonnull align 4 dereferenceable(8) %pos, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp)
  %6 = load float, ptr %sz.addr, align 4
  %div3 = fdiv float %6, 3.000000e+00
  store float %div3, ptr %third, align 4
  %x = getelementptr inbounds %struct.ImVec2, ptr %pos, i32 0, i32 0
  %7 = load float, ptr %x, align 4
  %8 = load float, ptr %third, align 4
  %add = fadd float %7, %8
  store float %add, ptr %bx, align 4
  %y = getelementptr inbounds %struct.ImVec2, ptr %pos, i32 0, i32 1
  %9 = load float, ptr %y, align 4
  %10 = load float, ptr %sz.addr, align 4
  %add4 = fadd float %9, %10
  %11 = load float, ptr %third, align 4
  %neg6 = fneg float %11
  %12 = call float @llvm.fmuladd.f32(float %neg6, float 5.000000e-01, float %add4)
  store float %12, ptr %by, align 4
  %13 = load ptr, ptr %draw_list.addr, align 8
  %14 = load float, ptr %bx, align 4
  %15 = load float, ptr %third, align 4
  %sub = fsub float %14, %15
  %16 = load float, ptr %by, align 4
  %17 = load float, ptr %third, align 4
  %sub8 = fsub float %16, %17
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp7, float noundef %sub, float noundef %sub8)
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %13, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp7)
  %18 = load ptr, ptr %draw_list.addr, align 8
  %19 = load float, ptr %bx, align 4
  %20 = load float, ptr %by, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp9, float noundef %19, float noundef %20)
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %18, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp9)
  %21 = load ptr, ptr %draw_list.addr, align 8
  %22 = load float, ptr %bx, align 4
  %23 = load float, ptr %third, align 4
  %24 = call float @llvm.fmuladd.f32(float %23, float 2.000000e+00, float %22)
  %25 = load float, ptr %by, align 4
  %26 = load float, ptr %third, align 4
  %neg13 = fneg float %26
  %27 = call float @llvm.fmuladd.f32(float %neg13, float 2.000000e+00, float %25)
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp10, float noundef %24, float noundef %27)
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %21, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp10)
  %28 = load ptr, ptr %draw_list.addr, align 8
  %29 = load i32, ptr %col.addr, align 4
  %30 = load float, ptr %thickness, align 4
  call void @_ZN10ImDrawList10PathStrokeEjif(ptr noundef nonnull align 8 dereferenceable(196) %28, i32 noundef %29, i32 noundef 0, float noundef %30)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef nonnull align 4 dereferenceable(8) ptr @_ZpLR6ImVec2RKS_(ptr noundef nonnull align 4 dereferenceable(8) %lhs, ptr noundef nonnull align 4 dereferenceable(8) %rhs) #2 {
entry:
  %lhs.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %lhs, ptr %lhs.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %0, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %2 = load ptr, ptr %lhs.addr, align 8
  %x1 = getelementptr inbounds %struct.ImVec2, ptr %2, i32 0, i32 0
  %3 = load float, ptr %x1, align 4
  %add = fadd float %3, %1
  store float %add, ptr %x1, align 4
  %4 = load ptr, ptr %rhs.addr, align 8
  %y = getelementptr inbounds %struct.ImVec2, ptr %4, i32 0, i32 1
  %5 = load float, ptr %y, align 4
  %6 = load ptr, ptr %lhs.addr, align 8
  %y2 = getelementptr inbounds %struct.ImVec2, ptr %6, i32 0, i32 1
  %7 = load float, ptr %y2, align 4
  %add3 = fadd float %7, %5
  store float %add3, ptr %y2, align 4
  %8 = load ptr, ptr %lhs.addr, align 8
  ret ptr %8
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui21RenderArrowPointingAtEP10ImDrawList6ImVec2S2_ij(ptr noundef %draw_list, <2 x float> %pos.coerce, <2 x float> %half_sz.coerce, i32 noundef %direction, i32 noundef %col) #0 {
entry:
  %pos = alloca %struct.ImVec2, align 4
  %half_sz = alloca %struct.ImVec2, align 4
  %draw_list.addr = alloca ptr, align 8
  %direction.addr = alloca i32, align 4
  %col.addr = alloca i32, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  %ref.tmp3 = alloca %struct.ImVec2, align 4
  %ref.tmp11 = alloca %struct.ImVec2, align 4
  %ref.tmp18 = alloca %struct.ImVec2, align 4
  %ref.tmp26 = alloca %struct.ImVec2, align 4
  %ref.tmp33 = alloca %struct.ImVec2, align 4
  %ref.tmp41 = alloca %struct.ImVec2, align 4
  %ref.tmp48 = alloca %struct.ImVec2, align 4
  store <2 x float> %pos.coerce, ptr %pos, align 4
  store <2 x float> %half_sz.coerce, ptr %half_sz, align 4
  store ptr %draw_list, ptr %draw_list.addr, align 8
  store i32 %direction, ptr %direction.addr, align 4
  store i32 %col, ptr %col.addr, align 4
  %0 = load i32, ptr %direction.addr, align 4
  switch i32 %0, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb10
    i32 2, label %sw.bb25
    i32 3, label %sw.bb40
    i32 -1, label %sw.bb55
    i32 4, label %sw.bb55
  ]

sw.bb:                                            ; preds = %entry
  %1 = load ptr, ptr %draw_list.addr, align 8
  %x = getelementptr inbounds %struct.ImVec2, ptr %pos, i32 0, i32 0
  %2 = load float, ptr %x, align 4
  %x1 = getelementptr inbounds %struct.ImVec2, ptr %half_sz, i32 0, i32 0
  %3 = load float, ptr %x1, align 4
  %add = fadd float %2, %3
  %y = getelementptr inbounds %struct.ImVec2, ptr %pos, i32 0, i32 1
  %4 = load float, ptr %y, align 4
  %y2 = getelementptr inbounds %struct.ImVec2, ptr %half_sz, i32 0, i32 1
  %5 = load float, ptr %y2, align 4
  %sub = fsub float %4, %5
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef %add, float noundef %sub)
  %x4 = getelementptr inbounds %struct.ImVec2, ptr %pos, i32 0, i32 0
  %6 = load float, ptr %x4, align 4
  %x5 = getelementptr inbounds %struct.ImVec2, ptr %half_sz, i32 0, i32 0
  %7 = load float, ptr %x5, align 4
  %add6 = fadd float %6, %7
  %y7 = getelementptr inbounds %struct.ImVec2, ptr %pos, i32 0, i32 1
  %8 = load float, ptr %y7, align 4
  %y8 = getelementptr inbounds %struct.ImVec2, ptr %half_sz, i32 0, i32 1
  %9 = load float, ptr %y8, align 4
  %add9 = fadd float %8, %9
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp3, float noundef %add6, float noundef %add9)
  %10 = load i32, ptr %col.addr, align 4
  call void @_ZN10ImDrawList17AddTriangleFilledERK6ImVec2S2_S2_j(ptr noundef nonnull align 8 dereferenceable(196) %1, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp3, ptr noundef nonnull align 4 dereferenceable(8) %pos, i32 noundef %10)
  br label %sw.epilog

sw.bb10:                                          ; preds = %entry
  %11 = load ptr, ptr %draw_list.addr, align 8
  %x12 = getelementptr inbounds %struct.ImVec2, ptr %pos, i32 0, i32 0
  %12 = load float, ptr %x12, align 4
  %x13 = getelementptr inbounds %struct.ImVec2, ptr %half_sz, i32 0, i32 0
  %13 = load float, ptr %x13, align 4
  %sub14 = fsub float %12, %13
  %y15 = getelementptr inbounds %struct.ImVec2, ptr %pos, i32 0, i32 1
  %14 = load float, ptr %y15, align 4
  %y16 = getelementptr inbounds %struct.ImVec2, ptr %half_sz, i32 0, i32 1
  %15 = load float, ptr %y16, align 4
  %add17 = fadd float %14, %15
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp11, float noundef %sub14, float noundef %add17)
  %x19 = getelementptr inbounds %struct.ImVec2, ptr %pos, i32 0, i32 0
  %16 = load float, ptr %x19, align 4
  %x20 = getelementptr inbounds %struct.ImVec2, ptr %half_sz, i32 0, i32 0
  %17 = load float, ptr %x20, align 4
  %sub21 = fsub float %16, %17
  %y22 = getelementptr inbounds %struct.ImVec2, ptr %pos, i32 0, i32 1
  %18 = load float, ptr %y22, align 4
  %y23 = getelementptr inbounds %struct.ImVec2, ptr %half_sz, i32 0, i32 1
  %19 = load float, ptr %y23, align 4
  %sub24 = fsub float %18, %19
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp18, float noundef %sub21, float noundef %sub24)
  %20 = load i32, ptr %col.addr, align 4
  call void @_ZN10ImDrawList17AddTriangleFilledERK6ImVec2S2_S2_j(ptr noundef nonnull align 8 dereferenceable(196) %11, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp11, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp18, ptr noundef nonnull align 4 dereferenceable(8) %pos, i32 noundef %20)
  br label %sw.epilog

sw.bb25:                                          ; preds = %entry
  %21 = load ptr, ptr %draw_list.addr, align 8
  %x27 = getelementptr inbounds %struct.ImVec2, ptr %pos, i32 0, i32 0
  %22 = load float, ptr %x27, align 4
  %x28 = getelementptr inbounds %struct.ImVec2, ptr %half_sz, i32 0, i32 0
  %23 = load float, ptr %x28, align 4
  %add29 = fadd float %22, %23
  %y30 = getelementptr inbounds %struct.ImVec2, ptr %pos, i32 0, i32 1
  %24 = load float, ptr %y30, align 4
  %y31 = getelementptr inbounds %struct.ImVec2, ptr %half_sz, i32 0, i32 1
  %25 = load float, ptr %y31, align 4
  %add32 = fadd float %24, %25
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp26, float noundef %add29, float noundef %add32)
  %x34 = getelementptr inbounds %struct.ImVec2, ptr %pos, i32 0, i32 0
  %26 = load float, ptr %x34, align 4
  %x35 = getelementptr inbounds %struct.ImVec2, ptr %half_sz, i32 0, i32 0
  %27 = load float, ptr %x35, align 4
  %sub36 = fsub float %26, %27
  %y37 = getelementptr inbounds %struct.ImVec2, ptr %pos, i32 0, i32 1
  %28 = load float, ptr %y37, align 4
  %y38 = getelementptr inbounds %struct.ImVec2, ptr %half_sz, i32 0, i32 1
  %29 = load float, ptr %y38, align 4
  %add39 = fadd float %28, %29
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp33, float noundef %sub36, float noundef %add39)
  %30 = load i32, ptr %col.addr, align 4
  call void @_ZN10ImDrawList17AddTriangleFilledERK6ImVec2S2_S2_j(ptr noundef nonnull align 8 dereferenceable(196) %21, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp26, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp33, ptr noundef nonnull align 4 dereferenceable(8) %pos, i32 noundef %30)
  br label %sw.epilog

sw.bb40:                                          ; preds = %entry
  %31 = load ptr, ptr %draw_list.addr, align 8
  %x42 = getelementptr inbounds %struct.ImVec2, ptr %pos, i32 0, i32 0
  %32 = load float, ptr %x42, align 4
  %x43 = getelementptr inbounds %struct.ImVec2, ptr %half_sz, i32 0, i32 0
  %33 = load float, ptr %x43, align 4
  %sub44 = fsub float %32, %33
  %y45 = getelementptr inbounds %struct.ImVec2, ptr %pos, i32 0, i32 1
  %34 = load float, ptr %y45, align 4
  %y46 = getelementptr inbounds %struct.ImVec2, ptr %half_sz, i32 0, i32 1
  %35 = load float, ptr %y46, align 4
  %sub47 = fsub float %34, %35
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp41, float noundef %sub44, float noundef %sub47)
  %x49 = getelementptr inbounds %struct.ImVec2, ptr %pos, i32 0, i32 0
  %36 = load float, ptr %x49, align 4
  %x50 = getelementptr inbounds %struct.ImVec2, ptr %half_sz, i32 0, i32 0
  %37 = load float, ptr %x50, align 4
  %add51 = fadd float %36, %37
  %y52 = getelementptr inbounds %struct.ImVec2, ptr %pos, i32 0, i32 1
  %38 = load float, ptr %y52, align 4
  %y53 = getelementptr inbounds %struct.ImVec2, ptr %half_sz, i32 0, i32 1
  %39 = load float, ptr %y53, align 4
  %sub54 = fsub float %38, %39
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp48, float noundef %add51, float noundef %sub54)
  %40 = load i32, ptr %col.addr, align 4
  call void @_ZN10ImDrawList17AddTriangleFilledERK6ImVec2S2_S2_j(ptr noundef nonnull align 8 dereferenceable(196) %31, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp41, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp48, ptr noundef nonnull align 4 dereferenceable(8) %pos, i32 noundef %40)
  br label %sw.epilog

sw.bb55:                                          ; preds = %entry, %entry
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb55, %sw.bb40, %sw.bb25, %sw.bb10, %sw.bb, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui22RenderRectFilledRangeHEP10ImDrawListRK6ImRectjfff(ptr noundef %draw_list, ptr noundef nonnull align 4 dereferenceable(16) %rect, i32 noundef %col, float noundef %x_start_norm, float noundef %x_end_norm, float noundef %rounding) #4 {
entry:
  %draw_list.addr = alloca ptr, align 8
  %rect.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  %x_start_norm.addr = alloca float, align 4
  %x_end_norm.addr = alloca float, align 4
  %rounding.addr = alloca float, align 4
  %p0 = alloca %struct.ImVec2, align 4
  %p1 = alloca %struct.ImVec2, align 4
  %inv_rounding = alloca float, align 4
  %arc0_b = alloca float, align 4
  %arc0_e = alloca float, align 4
  %half_pi = alloca float, align 4
  %x0 = alloca float, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  %ref.tmp49 = alloca %struct.ImVec2, align 4
  %ref.tmp54 = alloca %struct.ImVec2, align 4
  %ref.tmp57 = alloca %struct.ImVec2, align 4
  %ref.tmp61 = alloca %struct.ImVec2, align 4
  %ref.tmp66 = alloca %struct.ImVec2, align 4
  %arc1_b = alloca float, align 4
  %arc1_e = alloca float, align 4
  %x1 = alloca float, align 4
  %ref.tmp100 = alloca %struct.ImVec2, align 4
  %ref.tmp102 = alloca %struct.ImVec2, align 4
  %ref.tmp109 = alloca %struct.ImVec2, align 4
  %ref.tmp112 = alloca %struct.ImVec2, align 4
  %ref.tmp116 = alloca %struct.ImVec2, align 4
  %ref.tmp120 = alloca %struct.ImVec2, align 4
  store ptr %draw_list, ptr %draw_list.addr, align 8
  store ptr %rect, ptr %rect.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  store float %x_start_norm, ptr %x_start_norm.addr, align 4
  store float %x_end_norm, ptr %x_end_norm.addr, align 4
  store float %rounding, ptr %rounding.addr, align 4
  %0 = load float, ptr %x_end_norm.addr, align 4
  %1 = load float, ptr %x_start_norm.addr, align 4
  %cmp = fcmp oeq float %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load float, ptr %x_start_norm.addr, align 4
  %3 = load float, ptr %x_end_norm.addr, align 4
  %cmp1 = fcmp ogt float %2, %3
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  call void @_ZL6ImSwapIfEvRT_S1_(ptr noundef nonnull align 4 dereferenceable(4) %x_start_norm.addr, ptr noundef nonnull align 4 dereferenceable(4) %x_end_norm.addr)
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %4 = load ptr, ptr %rect.addr, align 8
  %Min = getelementptr inbounds %struct.ImRect, ptr %4, i32 0, i32 0
  %x = getelementptr inbounds %struct.ImVec2, ptr %Min, i32 0, i32 0
  %5 = load float, ptr %x, align 4
  %6 = load ptr, ptr %rect.addr, align 8
  %Max = getelementptr inbounds %struct.ImRect, ptr %6, i32 0, i32 1
  %x4 = getelementptr inbounds %struct.ImVec2, ptr %Max, i32 0, i32 0
  %7 = load float, ptr %x4, align 4
  %8 = load float, ptr %x_start_norm.addr, align 4
  %call = call noundef float @_ZL6ImLerpIfET_S0_S0_f(float noundef %5, float noundef %7, float noundef %8)
  %9 = load ptr, ptr %rect.addr, align 8
  %Min5 = getelementptr inbounds %struct.ImRect, ptr %9, i32 0, i32 0
  %y = getelementptr inbounds %struct.ImVec2, ptr %Min5, i32 0, i32 1
  %10 = load float, ptr %y, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %p0, float noundef %call, float noundef %10)
  %11 = load ptr, ptr %rect.addr, align 8
  %Min6 = getelementptr inbounds %struct.ImRect, ptr %11, i32 0, i32 0
  %x7 = getelementptr inbounds %struct.ImVec2, ptr %Min6, i32 0, i32 0
  %12 = load float, ptr %x7, align 4
  %13 = load ptr, ptr %rect.addr, align 8
  %Max8 = getelementptr inbounds %struct.ImRect, ptr %13, i32 0, i32 1
  %x9 = getelementptr inbounds %struct.ImVec2, ptr %Max8, i32 0, i32 0
  %14 = load float, ptr %x9, align 4
  %15 = load float, ptr %x_end_norm.addr, align 4
  %call10 = call noundef float @_ZL6ImLerpIfET_S0_S0_f(float noundef %12, float noundef %14, float noundef %15)
  %16 = load ptr, ptr %rect.addr, align 8
  %Max11 = getelementptr inbounds %struct.ImRect, ptr %16, i32 0, i32 1
  %y12 = getelementptr inbounds %struct.ImVec2, ptr %Max11, i32 0, i32 1
  %17 = load float, ptr %y12, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %p1, float noundef %call10, float noundef %17)
  %18 = load float, ptr %rounding.addr, align 4
  %cmp13 = fcmp oeq float %18, 0.000000e+00
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end3
  %19 = load ptr, ptr %draw_list.addr, align 8
  %20 = load i32, ptr %col.addr, align 4
  call void @_ZN10ImDrawList13AddRectFilledERK6ImVec2S2_jfi(ptr noundef nonnull align 8 dereferenceable(196) %19, ptr noundef nonnull align 4 dereferenceable(8) %p0, ptr noundef nonnull align 4 dereferenceable(8) %p1, i32 noundef %20, float noundef 0.000000e+00, i32 noundef 0)
  br label %return

if.end15:                                         ; preds = %if.end3
  %21 = load ptr, ptr %rect.addr, align 8
  %Max16 = getelementptr inbounds %struct.ImRect, ptr %21, i32 0, i32 1
  %x17 = getelementptr inbounds %struct.ImVec2, ptr %Max16, i32 0, i32 0
  %22 = load float, ptr %x17, align 4
  %23 = load ptr, ptr %rect.addr, align 8
  %Min18 = getelementptr inbounds %struct.ImRect, ptr %23, i32 0, i32 0
  %x19 = getelementptr inbounds %struct.ImVec2, ptr %Min18, i32 0, i32 0
  %24 = load float, ptr %x19, align 4
  %sub = fsub float %22, %24
  %mul = fmul float %sub, 5.000000e-01
  %25 = load ptr, ptr %rect.addr, align 8
  %Max20 = getelementptr inbounds %struct.ImRect, ptr %25, i32 0, i32 1
  %y21 = getelementptr inbounds %struct.ImVec2, ptr %Max20, i32 0, i32 1
  %26 = load float, ptr %y21, align 4
  %27 = load ptr, ptr %rect.addr, align 8
  %Min22 = getelementptr inbounds %struct.ImRect, ptr %27, i32 0, i32 0
  %y23 = getelementptr inbounds %struct.ImVec2, ptr %Min22, i32 0, i32 1
  %28 = load float, ptr %y23, align 4
  %sub24 = fsub float %26, %28
  %mul25 = fmul float %sub24, 5.000000e-01
  %call26 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %mul, float noundef %mul25)
  %sub27 = fsub float %call26, 1.000000e+00
  %29 = load float, ptr %rounding.addr, align 4
  %call28 = call noundef float @_ZL7ImClampIfET_S0_S0_S0_(float noundef %sub27, float noundef 0.000000e+00, float noundef %29)
  store float %call28, ptr %rounding.addr, align 4
  %30 = load float, ptr %rounding.addr, align 4
  %div = fdiv float 1.000000e+00, %30
  store float %div, ptr %inv_rounding, align 4
  %x29 = getelementptr inbounds %struct.ImVec2, ptr %p0, i32 0, i32 0
  %31 = load float, ptr %x29, align 4
  %32 = load ptr, ptr %rect.addr, align 8
  %Min30 = getelementptr inbounds %struct.ImRect, ptr %32, i32 0, i32 0
  %x31 = getelementptr inbounds %struct.ImVec2, ptr %Min30, i32 0, i32 0
  %33 = load float, ptr %x31, align 4
  %sub32 = fsub float %31, %33
  %34 = load float, ptr %inv_rounding, align 4
  %neg = fneg float %sub32
  %35 = call float @llvm.fmuladd.f32(float %neg, float %34, float 1.000000e+00)
  %call34 = call noundef float @_ZL8ImAcos01f(float noundef %35)
  store float %call34, ptr %arc0_b, align 4
  %x35 = getelementptr inbounds %struct.ImVec2, ptr %p1, i32 0, i32 0
  %36 = load float, ptr %x35, align 4
  %37 = load ptr, ptr %rect.addr, align 8
  %Min36 = getelementptr inbounds %struct.ImRect, ptr %37, i32 0, i32 0
  %x37 = getelementptr inbounds %struct.ImVec2, ptr %Min36, i32 0, i32 0
  %38 = load float, ptr %x37, align 4
  %sub38 = fsub float %36, %38
  %39 = load float, ptr %inv_rounding, align 4
  %neg40 = fneg float %sub38
  %40 = call float @llvm.fmuladd.f32(float %neg40, float %39, float 1.000000e+00)
  %call41 = call noundef float @_ZL8ImAcos01f(float noundef %40)
  store float %call41, ptr %arc0_e, align 4
  store float 0x3FF921FB60000000, ptr %half_pi, align 4
  %x42 = getelementptr inbounds %struct.ImVec2, ptr %p0, i32 0, i32 0
  %41 = load float, ptr %x42, align 4
  %42 = load ptr, ptr %rect.addr, align 8
  %Min43 = getelementptr inbounds %struct.ImRect, ptr %42, i32 0, i32 0
  %x44 = getelementptr inbounds %struct.ImVec2, ptr %Min43, i32 0, i32 0
  %43 = load float, ptr %x44, align 4
  %44 = load float, ptr %rounding.addr, align 4
  %add = fadd float %43, %44
  %call45 = call noundef float @_ZL5ImMaxIfET_S0_S0_(float noundef %41, float noundef %add)
  store float %call45, ptr %x0, align 4
  %45 = load float, ptr %arc0_b, align 4
  %46 = load float, ptr %arc0_e, align 4
  %cmp46 = fcmp oeq float %45, %46
  br i1 %cmp46, label %if.then47, label %if.else

if.then47:                                        ; preds = %if.end15
  %47 = load ptr, ptr %draw_list.addr, align 8
  %48 = load float, ptr %x0, align 4
  %y48 = getelementptr inbounds %struct.ImVec2, ptr %p1, i32 0, i32 1
  %49 = load float, ptr %y48, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef %48, float noundef %49)
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %47, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp)
  %50 = load ptr, ptr %draw_list.addr, align 8
  %51 = load float, ptr %x0, align 4
  %y50 = getelementptr inbounds %struct.ImVec2, ptr %p0, i32 0, i32 1
  %52 = load float, ptr %y50, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp49, float noundef %51, float noundef %52)
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %50, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp49)
  br label %if.end72

if.else:                                          ; preds = %if.end15
  %53 = load float, ptr %arc0_b, align 4
  %cmp51 = fcmp oeq float %53, 0.000000e+00
  br i1 %cmp51, label %land.lhs.true, label %if.else60

land.lhs.true:                                    ; preds = %if.else
  %54 = load float, ptr %arc0_e, align 4
  %cmp52 = fcmp oeq float %54, 0x3FF921FB60000000
  br i1 %cmp52, label %if.then53, label %if.else60

if.then53:                                        ; preds = %land.lhs.true
  %55 = load ptr, ptr %draw_list.addr, align 8
  %56 = load float, ptr %x0, align 4
  %y55 = getelementptr inbounds %struct.ImVec2, ptr %p1, i32 0, i32 1
  %57 = load float, ptr %y55, align 4
  %58 = load float, ptr %rounding.addr, align 4
  %sub56 = fsub float %57, %58
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp54, float noundef %56, float noundef %sub56)
  %59 = load float, ptr %rounding.addr, align 4
  call void @_ZN10ImDrawList13PathArcToFastERK6ImVec2fii(ptr noundef nonnull align 8 dereferenceable(196) %55, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp54, float noundef %59, i32 noundef 3, i32 noundef 6)
  %60 = load ptr, ptr %draw_list.addr, align 8
  %61 = load float, ptr %x0, align 4
  %y58 = getelementptr inbounds %struct.ImVec2, ptr %p0, i32 0, i32 1
  %62 = load float, ptr %y58, align 4
  %63 = load float, ptr %rounding.addr, align 4
  %add59 = fadd float %62, %63
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp57, float noundef %61, float noundef %add59)
  %64 = load float, ptr %rounding.addr, align 4
  call void @_ZN10ImDrawList13PathArcToFastERK6ImVec2fii(ptr noundef nonnull align 8 dereferenceable(196) %60, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp57, float noundef %64, i32 noundef 6, i32 noundef 9)
  br label %if.end71

if.else60:                                        ; preds = %land.lhs.true, %if.else
  %65 = load ptr, ptr %draw_list.addr, align 8
  %66 = load float, ptr %x0, align 4
  %y62 = getelementptr inbounds %struct.ImVec2, ptr %p1, i32 0, i32 1
  %67 = load float, ptr %y62, align 4
  %68 = load float, ptr %rounding.addr, align 4
  %sub63 = fsub float %67, %68
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp61, float noundef %66, float noundef %sub63)
  %69 = load float, ptr %rounding.addr, align 4
  %70 = load float, ptr %arc0_e, align 4
  %sub64 = fsub float 0x400921FB60000000, %70
  %71 = load float, ptr %arc0_b, align 4
  %sub65 = fsub float 0x400921FB60000000, %71
  call void @_ZN10ImDrawList9PathArcToERK6ImVec2fffi(ptr noundef nonnull align 8 dereferenceable(196) %65, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp61, float noundef %69, float noundef %sub64, float noundef %sub65, i32 noundef 3)
  %72 = load ptr, ptr %draw_list.addr, align 8
  %73 = load float, ptr %x0, align 4
  %y67 = getelementptr inbounds %struct.ImVec2, ptr %p0, i32 0, i32 1
  %74 = load float, ptr %y67, align 4
  %75 = load float, ptr %rounding.addr, align 4
  %add68 = fadd float %74, %75
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp66, float noundef %73, float noundef %add68)
  %76 = load float, ptr %rounding.addr, align 4
  %77 = load float, ptr %arc0_b, align 4
  %add69 = fadd float 0x400921FB60000000, %77
  %78 = load float, ptr %arc0_e, align 4
  %add70 = fadd float 0x400921FB60000000, %78
  call void @_ZN10ImDrawList9PathArcToERK6ImVec2fffi(ptr noundef nonnull align 8 dereferenceable(196) %72, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp66, float noundef %76, float noundef %add69, float noundef %add70, i32 noundef 3)
  br label %if.end71

if.end71:                                         ; preds = %if.else60, %if.then53
  br label %if.end72

if.end72:                                         ; preds = %if.end71, %if.then47
  %x73 = getelementptr inbounds %struct.ImVec2, ptr %p1, i32 0, i32 0
  %79 = load float, ptr %x73, align 4
  %80 = load ptr, ptr %rect.addr, align 8
  %Min74 = getelementptr inbounds %struct.ImRect, ptr %80, i32 0, i32 0
  %x75 = getelementptr inbounds %struct.ImVec2, ptr %Min74, i32 0, i32 0
  %81 = load float, ptr %x75, align 4
  %82 = load float, ptr %rounding.addr, align 4
  %add76 = fadd float %81, %82
  %cmp77 = fcmp ogt float %79, %add76
  br i1 %cmp77, label %if.then78, label %if.end125

if.then78:                                        ; preds = %if.end72
  %83 = load ptr, ptr %rect.addr, align 8
  %Max79 = getelementptr inbounds %struct.ImRect, ptr %83, i32 0, i32 1
  %x80 = getelementptr inbounds %struct.ImVec2, ptr %Max79, i32 0, i32 0
  %84 = load float, ptr %x80, align 4
  %x81 = getelementptr inbounds %struct.ImVec2, ptr %p1, i32 0, i32 0
  %85 = load float, ptr %x81, align 4
  %sub82 = fsub float %84, %85
  %86 = load float, ptr %inv_rounding, align 4
  %neg84 = fneg float %sub82
  %87 = call float @llvm.fmuladd.f32(float %neg84, float %86, float 1.000000e+00)
  %call85 = call noundef float @_ZL8ImAcos01f(float noundef %87)
  store float %call85, ptr %arc1_b, align 4
  %88 = load ptr, ptr %rect.addr, align 8
  %Max86 = getelementptr inbounds %struct.ImRect, ptr %88, i32 0, i32 1
  %x87 = getelementptr inbounds %struct.ImVec2, ptr %Max86, i32 0, i32 0
  %89 = load float, ptr %x87, align 4
  %x88 = getelementptr inbounds %struct.ImVec2, ptr %p0, i32 0, i32 0
  %90 = load float, ptr %x88, align 4
  %sub89 = fsub float %89, %90
  %91 = load float, ptr %inv_rounding, align 4
  %neg91 = fneg float %sub89
  %92 = call float @llvm.fmuladd.f32(float %neg91, float %91, float 1.000000e+00)
  %call92 = call noundef float @_ZL8ImAcos01f(float noundef %92)
  store float %call92, ptr %arc1_e, align 4
  %x93 = getelementptr inbounds %struct.ImVec2, ptr %p1, i32 0, i32 0
  %93 = load float, ptr %x93, align 4
  %94 = load ptr, ptr %rect.addr, align 8
  %Max94 = getelementptr inbounds %struct.ImRect, ptr %94, i32 0, i32 1
  %x95 = getelementptr inbounds %struct.ImVec2, ptr %Max94, i32 0, i32 0
  %95 = load float, ptr %x95, align 4
  %96 = load float, ptr %rounding.addr, align 4
  %sub96 = fsub float %95, %96
  %call97 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %93, float noundef %sub96)
  store float %call97, ptr %x1, align 4
  %97 = load float, ptr %arc1_b, align 4
  %98 = load float, ptr %arc1_e, align 4
  %cmp98 = fcmp oeq float %97, %98
  br i1 %cmp98, label %if.then99, label %if.else104

if.then99:                                        ; preds = %if.then78
  %99 = load ptr, ptr %draw_list.addr, align 8
  %100 = load float, ptr %x1, align 4
  %y101 = getelementptr inbounds %struct.ImVec2, ptr %p0, i32 0, i32 1
  %101 = load float, ptr %y101, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp100, float noundef %100, float noundef %101)
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %99, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp100)
  %102 = load ptr, ptr %draw_list.addr, align 8
  %103 = load float, ptr %x1, align 4
  %y103 = getelementptr inbounds %struct.ImVec2, ptr %p1, i32 0, i32 1
  %104 = load float, ptr %y103, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp102, float noundef %103, float noundef %104)
  call void @_ZN10ImDrawList10PathLineToERK6ImVec2(ptr noundef nonnull align 8 dereferenceable(196) %102, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp102)
  br label %if.end124

if.else104:                                       ; preds = %if.then78
  %105 = load float, ptr %arc1_b, align 4
  %cmp105 = fcmp oeq float %105, 0.000000e+00
  br i1 %cmp105, label %land.lhs.true106, label %if.else115

land.lhs.true106:                                 ; preds = %if.else104
  %106 = load float, ptr %arc1_e, align 4
  %cmp107 = fcmp oeq float %106, 0x3FF921FB60000000
  br i1 %cmp107, label %if.then108, label %if.else115

if.then108:                                       ; preds = %land.lhs.true106
  %107 = load ptr, ptr %draw_list.addr, align 8
  %108 = load float, ptr %x1, align 4
  %y110 = getelementptr inbounds %struct.ImVec2, ptr %p0, i32 0, i32 1
  %109 = load float, ptr %y110, align 4
  %110 = load float, ptr %rounding.addr, align 4
  %add111 = fadd float %109, %110
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp109, float noundef %108, float noundef %add111)
  %111 = load float, ptr %rounding.addr, align 4
  call void @_ZN10ImDrawList13PathArcToFastERK6ImVec2fii(ptr noundef nonnull align 8 dereferenceable(196) %107, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp109, float noundef %111, i32 noundef 9, i32 noundef 12)
  %112 = load ptr, ptr %draw_list.addr, align 8
  %113 = load float, ptr %x1, align 4
  %y113 = getelementptr inbounds %struct.ImVec2, ptr %p1, i32 0, i32 1
  %114 = load float, ptr %y113, align 4
  %115 = load float, ptr %rounding.addr, align 4
  %sub114 = fsub float %114, %115
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp112, float noundef %113, float noundef %sub114)
  %116 = load float, ptr %rounding.addr, align 4
  call void @_ZN10ImDrawList13PathArcToFastERK6ImVec2fii(ptr noundef nonnull align 8 dereferenceable(196) %112, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp112, float noundef %116, i32 noundef 0, i32 noundef 3)
  br label %if.end123

if.else115:                                       ; preds = %land.lhs.true106, %if.else104
  %117 = load ptr, ptr %draw_list.addr, align 8
  %118 = load float, ptr %x1, align 4
  %y117 = getelementptr inbounds %struct.ImVec2, ptr %p0, i32 0, i32 1
  %119 = load float, ptr %y117, align 4
  %120 = load float, ptr %rounding.addr, align 4
  %add118 = fadd float %119, %120
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp116, float noundef %118, float noundef %add118)
  %121 = load float, ptr %rounding.addr, align 4
  %122 = load float, ptr %arc1_e, align 4
  %fneg = fneg float %122
  %123 = load float, ptr %arc1_b, align 4
  %fneg119 = fneg float %123
  call void @_ZN10ImDrawList9PathArcToERK6ImVec2fffi(ptr noundef nonnull align 8 dereferenceable(196) %117, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp116, float noundef %121, float noundef %fneg, float noundef %fneg119, i32 noundef 3)
  %124 = load ptr, ptr %draw_list.addr, align 8
  %125 = load float, ptr %x1, align 4
  %y121 = getelementptr inbounds %struct.ImVec2, ptr %p1, i32 0, i32 1
  %126 = load float, ptr %y121, align 4
  %127 = load float, ptr %rounding.addr, align 4
  %sub122 = fsub float %126, %127
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp120, float noundef %125, float noundef %sub122)
  %128 = load float, ptr %rounding.addr, align 4
  %129 = load float, ptr %arc1_b, align 4
  %130 = load float, ptr %arc1_e, align 4
  call void @_ZN10ImDrawList9PathArcToERK6ImVec2fffi(ptr noundef nonnull align 8 dereferenceable(196) %124, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp120, float noundef %128, float noundef %129, float noundef %130, i32 noundef 3)
  br label %if.end123

if.end123:                                        ; preds = %if.else115, %if.then108
  br label %if.end124

if.end124:                                        ; preds = %if.end123, %if.then99
  br label %if.end125

if.end125:                                        ; preds = %if.end124, %if.end72
  %131 = load ptr, ptr %draw_list.addr, align 8
  %132 = load i32, ptr %col.addr, align 4
  call void @_ZN10ImDrawList14PathFillConvexEj(ptr noundef nonnull align 8 dereferenceable(196) %131, i32 noundef %132)
  br label %return

return:                                           ; preds = %if.end125, %if.then14, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZL6ImSwapIfEvRT_S1_(ptr noundef nonnull align 4 dereferenceable(4) %a, ptr noundef nonnull align 4 dereferenceable(4) %b) #2 {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %tmp = alloca float, align 4
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %1 = load float, ptr %0, align 4
  store float %1, ptr %tmp, align 4
  %2 = load ptr, ptr %b.addr, align 8
  %3 = load float, ptr %2, align 4
  %4 = load ptr, ptr %a.addr, align 8
  store float %3, ptr %4, align 4
  %5 = load float, ptr %tmp, align 4
  %6 = load ptr, ptr %b.addr, align 8
  store float %5, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef float @_ZL6ImLerpIfET_S0_S0_f(float noundef %a, float noundef %b, float noundef %t) #2 {
entry:
  %a.addr = alloca float, align 4
  %b.addr = alloca float, align 4
  %t.addr = alloca float, align 4
  store float %a, ptr %a.addr, align 4
  store float %b, ptr %b.addr, align 4
  store float %t, ptr %t.addr, align 4
  %0 = load float, ptr %a.addr, align 4
  %1 = load float, ptr %b.addr, align 4
  %2 = load float, ptr %a.addr, align 4
  %sub = fsub float %1, %2
  %3 = load float, ptr %t.addr, align 4
  %4 = call float @llvm.fmuladd.f32(float %sub, float %3, float %0)
  ret float %4
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef float @_ZL8ImAcos01f(float noundef %x) #2 {
entry:
  %retval = alloca float, align 4
  %x.addr = alloca float, align 4
  store float %x, ptr %x.addr, align 4
  %0 = load float, ptr %x.addr, align 4
  %cmp = fcmp ole float %0, 0.000000e+00
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store float 0x3FF921FB60000000, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load float, ptr %x.addr, align 4
  %cmp1 = fcmp oge float %1, 1.000000e+00
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store float 0.000000e+00, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %2 = load float, ptr %x.addr, align 4
  %call = call float @acosf(float noundef %2) #12
  store float %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %3 = load float, ptr %retval, align 4
  ret float %3
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui24RenderRectFilledWithHoleEP10ImDrawListRK6ImRectS4_jf(ptr noundef %draw_list, ptr noundef nonnull align 4 dereferenceable(16) %outer, ptr noundef nonnull align 4 dereferenceable(16) %inner, i32 noundef %col, float noundef %rounding) #4 {
entry:
  %draw_list.addr = alloca ptr, align 8
  %outer.addr = alloca ptr, align 8
  %inner.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  %rounding.addr = alloca float, align 4
  %fill_L = alloca i8, align 1
  %fill_R = alloca i8, align 1
  %fill_U = alloca i8, align 1
  %fill_D = alloca i8, align 1
  %ref.tmp = alloca %struct.ImVec2, align 4
  %ref.tmp23 = alloca %struct.ImVec2, align 4
  %ref.tmp34 = alloca %struct.ImVec2, align 4
  %ref.tmp39 = alloca %struct.ImVec2, align 4
  %ref.tmp53 = alloca %struct.ImVec2, align 4
  %ref.tmp58 = alloca %struct.ImVec2, align 4
  %ref.tmp72 = alloca %struct.ImVec2, align 4
  %ref.tmp77 = alloca %struct.ImVec2, align 4
  %ref.tmp92 = alloca %struct.ImVec2, align 4
  %ref.tmp97 = alloca %struct.ImVec2, align 4
  %ref.tmp107 = alloca %struct.ImVec2, align 4
  %ref.tmp112 = alloca %struct.ImVec2, align 4
  %ref.tmp122 = alloca %struct.ImVec2, align 4
  %ref.tmp127 = alloca %struct.ImVec2, align 4
  %ref.tmp137 = alloca %struct.ImVec2, align 4
  %ref.tmp142 = alloca %struct.ImVec2, align 4
  store ptr %draw_list, ptr %draw_list.addr, align 8
  store ptr %outer, ptr %outer.addr, align 8
  store ptr %inner, ptr %inner.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  store float %rounding, ptr %rounding.addr, align 4
  %0 = load ptr, ptr %inner.addr, align 8
  %Min = getelementptr inbounds %struct.ImRect, ptr %0, i32 0, i32 0
  %x = getelementptr inbounds %struct.ImVec2, ptr %Min, i32 0, i32 0
  %1 = load float, ptr %x, align 4
  %2 = load ptr, ptr %outer.addr, align 8
  %Min1 = getelementptr inbounds %struct.ImRect, ptr %2, i32 0, i32 0
  %x2 = getelementptr inbounds %struct.ImVec2, ptr %Min1, i32 0, i32 0
  %3 = load float, ptr %x2, align 4
  %cmp = fcmp ogt float %1, %3
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, ptr %fill_L, align 1
  %4 = load ptr, ptr %inner.addr, align 8
  %Max = getelementptr inbounds %struct.ImRect, ptr %4, i32 0, i32 1
  %x3 = getelementptr inbounds %struct.ImVec2, ptr %Max, i32 0, i32 0
  %5 = load float, ptr %x3, align 4
  %6 = load ptr, ptr %outer.addr, align 8
  %Max4 = getelementptr inbounds %struct.ImRect, ptr %6, i32 0, i32 1
  %x5 = getelementptr inbounds %struct.ImVec2, ptr %Max4, i32 0, i32 0
  %7 = load float, ptr %x5, align 4
  %cmp6 = fcmp olt float %5, %7
  %frombool7 = zext i1 %cmp6 to i8
  store i8 %frombool7, ptr %fill_R, align 1
  %8 = load ptr, ptr %inner.addr, align 8
  %Min8 = getelementptr inbounds %struct.ImRect, ptr %8, i32 0, i32 0
  %y = getelementptr inbounds %struct.ImVec2, ptr %Min8, i32 0, i32 1
  %9 = load float, ptr %y, align 4
  %10 = load ptr, ptr %outer.addr, align 8
  %Min9 = getelementptr inbounds %struct.ImRect, ptr %10, i32 0, i32 0
  %y10 = getelementptr inbounds %struct.ImVec2, ptr %Min9, i32 0, i32 1
  %11 = load float, ptr %y10, align 4
  %cmp11 = fcmp ogt float %9, %11
  %frombool12 = zext i1 %cmp11 to i8
  store i8 %frombool12, ptr %fill_U, align 1
  %12 = load ptr, ptr %inner.addr, align 8
  %Max13 = getelementptr inbounds %struct.ImRect, ptr %12, i32 0, i32 1
  %y14 = getelementptr inbounds %struct.ImVec2, ptr %Max13, i32 0, i32 1
  %13 = load float, ptr %y14, align 4
  %14 = load ptr, ptr %outer.addr, align 8
  %Max15 = getelementptr inbounds %struct.ImRect, ptr %14, i32 0, i32 1
  %y16 = getelementptr inbounds %struct.ImVec2, ptr %Max15, i32 0, i32 1
  %15 = load float, ptr %y16, align 4
  %cmp17 = fcmp olt float %13, %15
  %frombool18 = zext i1 %cmp17 to i8
  store i8 %frombool18, ptr %fill_D, align 1
  %16 = load i8, ptr %fill_L, align 1
  %tobool = trunc i8 %16 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %17 = load ptr, ptr %draw_list.addr, align 8
  %18 = load ptr, ptr %outer.addr, align 8
  %Min19 = getelementptr inbounds %struct.ImRect, ptr %18, i32 0, i32 0
  %x20 = getelementptr inbounds %struct.ImVec2, ptr %Min19, i32 0, i32 0
  %19 = load float, ptr %x20, align 4
  %20 = load ptr, ptr %inner.addr, align 8
  %Min21 = getelementptr inbounds %struct.ImRect, ptr %20, i32 0, i32 0
  %y22 = getelementptr inbounds %struct.ImVec2, ptr %Min21, i32 0, i32 1
  %21 = load float, ptr %y22, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef %19, float noundef %21)
  %22 = load ptr, ptr %inner.addr, align 8
  %Min24 = getelementptr inbounds %struct.ImRect, ptr %22, i32 0, i32 0
  %x25 = getelementptr inbounds %struct.ImVec2, ptr %Min24, i32 0, i32 0
  %23 = load float, ptr %x25, align 4
  %24 = load ptr, ptr %inner.addr, align 8
  %Max26 = getelementptr inbounds %struct.ImRect, ptr %24, i32 0, i32 1
  %y27 = getelementptr inbounds %struct.ImVec2, ptr %Max26, i32 0, i32 1
  %25 = load float, ptr %y27, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp23, float noundef %23, float noundef %25)
  %26 = load i32, ptr %col.addr, align 4
  %27 = load float, ptr %rounding.addr, align 4
  %28 = load i8, ptr %fill_U, align 1
  %tobool28 = trunc i8 %28 to i1
  %cond = select i1 %tobool28, i32 0, i32 16
  %or = or i32 256, %cond
  %29 = load i8, ptr %fill_D, align 1
  %tobool29 = trunc i8 %29 to i1
  %cond30 = select i1 %tobool29, i32 0, i32 64
  %or31 = or i32 %or, %cond30
  call void @_ZN10ImDrawList13AddRectFilledERK6ImVec2S2_jfi(ptr noundef nonnull align 8 dereferenceable(196) %17, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp23, i32 noundef %26, float noundef %27, i32 noundef %or31)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %30 = load i8, ptr %fill_R, align 1
  %tobool32 = trunc i8 %30 to i1
  br i1 %tobool32, label %if.then33, label %if.end50

if.then33:                                        ; preds = %if.end
  %31 = load ptr, ptr %draw_list.addr, align 8
  %32 = load ptr, ptr %inner.addr, align 8
  %Max35 = getelementptr inbounds %struct.ImRect, ptr %32, i32 0, i32 1
  %x36 = getelementptr inbounds %struct.ImVec2, ptr %Max35, i32 0, i32 0
  %33 = load float, ptr %x36, align 4
  %34 = load ptr, ptr %inner.addr, align 8
  %Min37 = getelementptr inbounds %struct.ImRect, ptr %34, i32 0, i32 0
  %y38 = getelementptr inbounds %struct.ImVec2, ptr %Min37, i32 0, i32 1
  %35 = load float, ptr %y38, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp34, float noundef %33, float noundef %35)
  %36 = load ptr, ptr %outer.addr, align 8
  %Max40 = getelementptr inbounds %struct.ImRect, ptr %36, i32 0, i32 1
  %x41 = getelementptr inbounds %struct.ImVec2, ptr %Max40, i32 0, i32 0
  %37 = load float, ptr %x41, align 4
  %38 = load ptr, ptr %inner.addr, align 8
  %Max42 = getelementptr inbounds %struct.ImRect, ptr %38, i32 0, i32 1
  %y43 = getelementptr inbounds %struct.ImVec2, ptr %Max42, i32 0, i32 1
  %39 = load float, ptr %y43, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp39, float noundef %37, float noundef %39)
  %40 = load i32, ptr %col.addr, align 4
  %41 = load float, ptr %rounding.addr, align 4
  %42 = load i8, ptr %fill_U, align 1
  %tobool44 = trunc i8 %42 to i1
  %cond45 = select i1 %tobool44, i32 0, i32 32
  %or46 = or i32 256, %cond45
  %43 = load i8, ptr %fill_D, align 1
  %tobool47 = trunc i8 %43 to i1
  %cond48 = select i1 %tobool47, i32 0, i32 128
  %or49 = or i32 %or46, %cond48
  call void @_ZN10ImDrawList13AddRectFilledERK6ImVec2S2_jfi(ptr noundef nonnull align 8 dereferenceable(196) %31, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp34, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp39, i32 noundef %40, float noundef %41, i32 noundef %or49)
  br label %if.end50

if.end50:                                         ; preds = %if.then33, %if.end
  %44 = load i8, ptr %fill_U, align 1
  %tobool51 = trunc i8 %44 to i1
  br i1 %tobool51, label %if.then52, label %if.end69

if.then52:                                        ; preds = %if.end50
  %45 = load ptr, ptr %draw_list.addr, align 8
  %46 = load ptr, ptr %inner.addr, align 8
  %Min54 = getelementptr inbounds %struct.ImRect, ptr %46, i32 0, i32 0
  %x55 = getelementptr inbounds %struct.ImVec2, ptr %Min54, i32 0, i32 0
  %47 = load float, ptr %x55, align 4
  %48 = load ptr, ptr %outer.addr, align 8
  %Min56 = getelementptr inbounds %struct.ImRect, ptr %48, i32 0, i32 0
  %y57 = getelementptr inbounds %struct.ImVec2, ptr %Min56, i32 0, i32 1
  %49 = load float, ptr %y57, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp53, float noundef %47, float noundef %49)
  %50 = load ptr, ptr %inner.addr, align 8
  %Max59 = getelementptr inbounds %struct.ImRect, ptr %50, i32 0, i32 1
  %x60 = getelementptr inbounds %struct.ImVec2, ptr %Max59, i32 0, i32 0
  %51 = load float, ptr %x60, align 4
  %52 = load ptr, ptr %inner.addr, align 8
  %Min61 = getelementptr inbounds %struct.ImRect, ptr %52, i32 0, i32 0
  %y62 = getelementptr inbounds %struct.ImVec2, ptr %Min61, i32 0, i32 1
  %53 = load float, ptr %y62, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp58, float noundef %51, float noundef %53)
  %54 = load i32, ptr %col.addr, align 4
  %55 = load float, ptr %rounding.addr, align 4
  %56 = load i8, ptr %fill_L, align 1
  %tobool63 = trunc i8 %56 to i1
  %cond64 = select i1 %tobool63, i32 0, i32 16
  %or65 = or i32 256, %cond64
  %57 = load i8, ptr %fill_R, align 1
  %tobool66 = trunc i8 %57 to i1
  %cond67 = select i1 %tobool66, i32 0, i32 32
  %or68 = or i32 %or65, %cond67
  call void @_ZN10ImDrawList13AddRectFilledERK6ImVec2S2_jfi(ptr noundef nonnull align 8 dereferenceable(196) %45, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp53, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp58, i32 noundef %54, float noundef %55, i32 noundef %or68)
  br label %if.end69

if.end69:                                         ; preds = %if.then52, %if.end50
  %58 = load i8, ptr %fill_D, align 1
  %tobool70 = trunc i8 %58 to i1
  br i1 %tobool70, label %if.then71, label %if.end88

if.then71:                                        ; preds = %if.end69
  %59 = load ptr, ptr %draw_list.addr, align 8
  %60 = load ptr, ptr %inner.addr, align 8
  %Min73 = getelementptr inbounds %struct.ImRect, ptr %60, i32 0, i32 0
  %x74 = getelementptr inbounds %struct.ImVec2, ptr %Min73, i32 0, i32 0
  %61 = load float, ptr %x74, align 4
  %62 = load ptr, ptr %inner.addr, align 8
  %Max75 = getelementptr inbounds %struct.ImRect, ptr %62, i32 0, i32 1
  %y76 = getelementptr inbounds %struct.ImVec2, ptr %Max75, i32 0, i32 1
  %63 = load float, ptr %y76, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp72, float noundef %61, float noundef %63)
  %64 = load ptr, ptr %inner.addr, align 8
  %Max78 = getelementptr inbounds %struct.ImRect, ptr %64, i32 0, i32 1
  %x79 = getelementptr inbounds %struct.ImVec2, ptr %Max78, i32 0, i32 0
  %65 = load float, ptr %x79, align 4
  %66 = load ptr, ptr %outer.addr, align 8
  %Max80 = getelementptr inbounds %struct.ImRect, ptr %66, i32 0, i32 1
  %y81 = getelementptr inbounds %struct.ImVec2, ptr %Max80, i32 0, i32 1
  %67 = load float, ptr %y81, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp77, float noundef %65, float noundef %67)
  %68 = load i32, ptr %col.addr, align 4
  %69 = load float, ptr %rounding.addr, align 4
  %70 = load i8, ptr %fill_L, align 1
  %tobool82 = trunc i8 %70 to i1
  %cond83 = select i1 %tobool82, i32 0, i32 64
  %or84 = or i32 256, %cond83
  %71 = load i8, ptr %fill_R, align 1
  %tobool85 = trunc i8 %71 to i1
  %cond86 = select i1 %tobool85, i32 0, i32 128
  %or87 = or i32 %or84, %cond86
  call void @_ZN10ImDrawList13AddRectFilledERK6ImVec2S2_jfi(ptr noundef nonnull align 8 dereferenceable(196) %59, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp72, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp77, i32 noundef %68, float noundef %69, i32 noundef %or87)
  br label %if.end88

if.end88:                                         ; preds = %if.then71, %if.end69
  %72 = load i8, ptr %fill_L, align 1
  %tobool89 = trunc i8 %72 to i1
  br i1 %tobool89, label %land.lhs.true, label %if.end102

land.lhs.true:                                    ; preds = %if.end88
  %73 = load i8, ptr %fill_U, align 1
  %tobool90 = trunc i8 %73 to i1
  br i1 %tobool90, label %if.then91, label %if.end102

if.then91:                                        ; preds = %land.lhs.true
  %74 = load ptr, ptr %draw_list.addr, align 8
  %75 = load ptr, ptr %outer.addr, align 8
  %Min93 = getelementptr inbounds %struct.ImRect, ptr %75, i32 0, i32 0
  %x94 = getelementptr inbounds %struct.ImVec2, ptr %Min93, i32 0, i32 0
  %76 = load float, ptr %x94, align 4
  %77 = load ptr, ptr %outer.addr, align 8
  %Min95 = getelementptr inbounds %struct.ImRect, ptr %77, i32 0, i32 0
  %y96 = getelementptr inbounds %struct.ImVec2, ptr %Min95, i32 0, i32 1
  %78 = load float, ptr %y96, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp92, float noundef %76, float noundef %78)
  %79 = load ptr, ptr %inner.addr, align 8
  %Min98 = getelementptr inbounds %struct.ImRect, ptr %79, i32 0, i32 0
  %x99 = getelementptr inbounds %struct.ImVec2, ptr %Min98, i32 0, i32 0
  %80 = load float, ptr %x99, align 4
  %81 = load ptr, ptr %inner.addr, align 8
  %Min100 = getelementptr inbounds %struct.ImRect, ptr %81, i32 0, i32 0
  %y101 = getelementptr inbounds %struct.ImVec2, ptr %Min100, i32 0, i32 1
  %82 = load float, ptr %y101, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp97, float noundef %80, float noundef %82)
  %83 = load i32, ptr %col.addr, align 4
  %84 = load float, ptr %rounding.addr, align 4
  call void @_ZN10ImDrawList13AddRectFilledERK6ImVec2S2_jfi(ptr noundef nonnull align 8 dereferenceable(196) %74, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp92, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp97, i32 noundef %83, float noundef %84, i32 noundef 16)
  br label %if.end102

if.end102:                                        ; preds = %if.then91, %land.lhs.true, %if.end88
  %85 = load i8, ptr %fill_R, align 1
  %tobool103 = trunc i8 %85 to i1
  br i1 %tobool103, label %land.lhs.true104, label %if.end117

land.lhs.true104:                                 ; preds = %if.end102
  %86 = load i8, ptr %fill_U, align 1
  %tobool105 = trunc i8 %86 to i1
  br i1 %tobool105, label %if.then106, label %if.end117

if.then106:                                       ; preds = %land.lhs.true104
  %87 = load ptr, ptr %draw_list.addr, align 8
  %88 = load ptr, ptr %inner.addr, align 8
  %Max108 = getelementptr inbounds %struct.ImRect, ptr %88, i32 0, i32 1
  %x109 = getelementptr inbounds %struct.ImVec2, ptr %Max108, i32 0, i32 0
  %89 = load float, ptr %x109, align 4
  %90 = load ptr, ptr %outer.addr, align 8
  %Min110 = getelementptr inbounds %struct.ImRect, ptr %90, i32 0, i32 0
  %y111 = getelementptr inbounds %struct.ImVec2, ptr %Min110, i32 0, i32 1
  %91 = load float, ptr %y111, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp107, float noundef %89, float noundef %91)
  %92 = load ptr, ptr %outer.addr, align 8
  %Max113 = getelementptr inbounds %struct.ImRect, ptr %92, i32 0, i32 1
  %x114 = getelementptr inbounds %struct.ImVec2, ptr %Max113, i32 0, i32 0
  %93 = load float, ptr %x114, align 4
  %94 = load ptr, ptr %inner.addr, align 8
  %Min115 = getelementptr inbounds %struct.ImRect, ptr %94, i32 0, i32 0
  %y116 = getelementptr inbounds %struct.ImVec2, ptr %Min115, i32 0, i32 1
  %95 = load float, ptr %y116, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp112, float noundef %93, float noundef %95)
  %96 = load i32, ptr %col.addr, align 4
  %97 = load float, ptr %rounding.addr, align 4
  call void @_ZN10ImDrawList13AddRectFilledERK6ImVec2S2_jfi(ptr noundef nonnull align 8 dereferenceable(196) %87, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp107, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp112, i32 noundef %96, float noundef %97, i32 noundef 32)
  br label %if.end117

if.end117:                                        ; preds = %if.then106, %land.lhs.true104, %if.end102
  %98 = load i8, ptr %fill_L, align 1
  %tobool118 = trunc i8 %98 to i1
  br i1 %tobool118, label %land.lhs.true119, label %if.end132

land.lhs.true119:                                 ; preds = %if.end117
  %99 = load i8, ptr %fill_D, align 1
  %tobool120 = trunc i8 %99 to i1
  br i1 %tobool120, label %if.then121, label %if.end132

if.then121:                                       ; preds = %land.lhs.true119
  %100 = load ptr, ptr %draw_list.addr, align 8
  %101 = load ptr, ptr %outer.addr, align 8
  %Min123 = getelementptr inbounds %struct.ImRect, ptr %101, i32 0, i32 0
  %x124 = getelementptr inbounds %struct.ImVec2, ptr %Min123, i32 0, i32 0
  %102 = load float, ptr %x124, align 4
  %103 = load ptr, ptr %inner.addr, align 8
  %Max125 = getelementptr inbounds %struct.ImRect, ptr %103, i32 0, i32 1
  %y126 = getelementptr inbounds %struct.ImVec2, ptr %Max125, i32 0, i32 1
  %104 = load float, ptr %y126, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp122, float noundef %102, float noundef %104)
  %105 = load ptr, ptr %inner.addr, align 8
  %Min128 = getelementptr inbounds %struct.ImRect, ptr %105, i32 0, i32 0
  %x129 = getelementptr inbounds %struct.ImVec2, ptr %Min128, i32 0, i32 0
  %106 = load float, ptr %x129, align 4
  %107 = load ptr, ptr %outer.addr, align 8
  %Max130 = getelementptr inbounds %struct.ImRect, ptr %107, i32 0, i32 1
  %y131 = getelementptr inbounds %struct.ImVec2, ptr %Max130, i32 0, i32 1
  %108 = load float, ptr %y131, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp127, float noundef %106, float noundef %108)
  %109 = load i32, ptr %col.addr, align 4
  %110 = load float, ptr %rounding.addr, align 4
  call void @_ZN10ImDrawList13AddRectFilledERK6ImVec2S2_jfi(ptr noundef nonnull align 8 dereferenceable(196) %100, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp122, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp127, i32 noundef %109, float noundef %110, i32 noundef 64)
  br label %if.end132

if.end132:                                        ; preds = %if.then121, %land.lhs.true119, %if.end117
  %111 = load i8, ptr %fill_R, align 1
  %tobool133 = trunc i8 %111 to i1
  br i1 %tobool133, label %land.lhs.true134, label %if.end147

land.lhs.true134:                                 ; preds = %if.end132
  %112 = load i8, ptr %fill_D, align 1
  %tobool135 = trunc i8 %112 to i1
  br i1 %tobool135, label %if.then136, label %if.end147

if.then136:                                       ; preds = %land.lhs.true134
  %113 = load ptr, ptr %draw_list.addr, align 8
  %114 = load ptr, ptr %inner.addr, align 8
  %Max138 = getelementptr inbounds %struct.ImRect, ptr %114, i32 0, i32 1
  %x139 = getelementptr inbounds %struct.ImVec2, ptr %Max138, i32 0, i32 0
  %115 = load float, ptr %x139, align 4
  %116 = load ptr, ptr %inner.addr, align 8
  %Max140 = getelementptr inbounds %struct.ImRect, ptr %116, i32 0, i32 1
  %y141 = getelementptr inbounds %struct.ImVec2, ptr %Max140, i32 0, i32 1
  %117 = load float, ptr %y141, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp137, float noundef %115, float noundef %117)
  %118 = load ptr, ptr %outer.addr, align 8
  %Max143 = getelementptr inbounds %struct.ImRect, ptr %118, i32 0, i32 1
  %x144 = getelementptr inbounds %struct.ImVec2, ptr %Max143, i32 0, i32 0
  %119 = load float, ptr %x144, align 4
  %120 = load ptr, ptr %outer.addr, align 8
  %Max145 = getelementptr inbounds %struct.ImRect, ptr %120, i32 0, i32 1
  %y146 = getelementptr inbounds %struct.ImVec2, ptr %Max145, i32 0, i32 1
  %121 = load float, ptr %y146, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp142, float noundef %119, float noundef %121)
  %122 = load i32, ptr %col.addr, align 4
  %123 = load float, ptr %rounding.addr, align 4
  call void @_ZN10ImDrawList13AddRectFilledERK6ImVec2S2_jfi(ptr noundef nonnull align 8 dereferenceable(196) %113, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp137, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp142, i32 noundef %122, float noundef %123, i32 noundef 128)
  br label %if.end147

if.end147:                                        ; preds = %if.then136, %land.lhs.true134, %if.end132
  ret void
}

; Function Attrs: mustprogress uwtable
define void @_ZN5ImGui36RenderColorRectWithAlphaCheckerboardEP10ImDrawList6ImVec2S2_jfS2_fi(ptr noundef %draw_list, <2 x float> %p_min.coerce, <2 x float> %p_max.coerce, i32 noundef %col, float noundef %grid_step, <2 x float> %grid_off.coerce, float noundef %rounding, i32 noundef %flags) #0 {
entry:
  %p_min = alloca %struct.ImVec2, align 4
  %p_max = alloca %struct.ImVec2, align 4
  %grid_off = alloca %struct.ImVec2, align 4
  %draw_list.addr = alloca ptr, align 8
  %col.addr = alloca i32, align 4
  %grid_step.addr = alloca float, align 4
  %rounding.addr = alloca float, align 4
  %flags.addr = alloca i32, align 4
  %col_bg1 = alloca i32, align 4
  %col_bg2 = alloca i32, align 4
  %yi = alloca i32, align 4
  %y = alloca float, align 4
  %y1 = alloca float, align 4
  %y2 = alloca float, align 4
  %x = alloca float, align 4
  %x1 = alloca float, align 4
  %x2 = alloca float, align 4
  %cell_flags = alloca i32, align 4
  %ref.tmp = alloca %struct.ImVec2, align 4
  %ref.tmp67 = alloca %struct.ImVec2, align 4
  store <2 x float> %p_min.coerce, ptr %p_min, align 4
  store <2 x float> %p_max.coerce, ptr %p_max, align 4
  store <2 x float> %grid_off.coerce, ptr %grid_off, align 4
  store ptr %draw_list, ptr %draw_list.addr, align 8
  store i32 %col, ptr %col.addr, align 4
  store float %grid_step, ptr %grid_step.addr, align 4
  store float %rounding, ptr %rounding.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load i32, ptr %flags.addr, align 4
  %and = and i32 %0, 496
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 240, ptr %flags.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load i32, ptr %col.addr, align 4
  %and1 = and i32 %1, -16777216
  %shr = lshr i32 %and1, 24
  %cmp2 = icmp ult i32 %shr, 255
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %2 = load i32, ptr %col.addr, align 4
  %call = call noundef i32 @_Z18ImAlphaBlendColorsjj(i32 noundef -3355444, i32 noundef %2)
  %call4 = call noundef i32 @_ZN5ImGui11GetColorU32Ej(i32 noundef %call)
  store i32 %call4, ptr %col_bg1, align 4
  %3 = load i32, ptr %col.addr, align 4
  %call5 = call noundef i32 @_Z18ImAlphaBlendColorsjj(i32 noundef -8355712, i32 noundef %3)
  %call6 = call noundef i32 @_ZN5ImGui11GetColorU32Ej(i32 noundef %call5)
  store i32 %call6, ptr %col_bg2, align 4
  %4 = load ptr, ptr %draw_list.addr, align 8
  %5 = load i32, ptr %col_bg1, align 4
  %6 = load float, ptr %rounding.addr, align 4
  %7 = load i32, ptr %flags.addr, align 4
  call void @_ZN10ImDrawList13AddRectFilledERK6ImVec2S2_jfi(ptr noundef nonnull align 8 dereferenceable(196) %4, ptr noundef nonnull align 4 dereferenceable(8) %p_min, ptr noundef nonnull align 4 dereferenceable(8) %p_max, i32 noundef %5, float noundef %6, i32 noundef %7)
  store i32 0, ptr %yi, align 4
  %y7 = getelementptr inbounds %struct.ImVec2, ptr %p_min, i32 0, i32 1
  %8 = load float, ptr %y7, align 4
  %y8 = getelementptr inbounds %struct.ImVec2, ptr %grid_off, i32 0, i32 1
  %9 = load float, ptr %y8, align 4
  %add = fadd float %8, %9
  store float %add, ptr %y, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc68, %if.then3
  %10 = load float, ptr %y, align 4
  %y9 = getelementptr inbounds %struct.ImVec2, ptr %p_max, i32 0, i32 1
  %11 = load float, ptr %y9, align 4
  %cmp10 = fcmp olt float %10, %11
  br i1 %cmp10, label %for.body, label %for.end70

for.body:                                         ; preds = %for.cond
  %12 = load float, ptr %y, align 4
  %y11 = getelementptr inbounds %struct.ImVec2, ptr %p_min, i32 0, i32 1
  %13 = load float, ptr %y11, align 4
  %y12 = getelementptr inbounds %struct.ImVec2, ptr %p_max, i32 0, i32 1
  %14 = load float, ptr %y12, align 4
  %call13 = call noundef float @_ZL7ImClampIfET_S0_S0_S0_(float noundef %12, float noundef %13, float noundef %14)
  store float %call13, ptr %y1, align 4
  %15 = load float, ptr %y, align 4
  %16 = load float, ptr %grid_step.addr, align 4
  %add14 = fadd float %15, %16
  %y15 = getelementptr inbounds %struct.ImVec2, ptr %p_max, i32 0, i32 1
  %17 = load float, ptr %y15, align 4
  %call16 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %add14, float noundef %17)
  store float %call16, ptr %y2, align 4
  %18 = load float, ptr %y2, align 4
  %19 = load float, ptr %y1, align 4
  %cmp17 = fcmp ole float %18, %19
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %for.body
  br label %for.inc68

if.end19:                                         ; preds = %for.body
  %x20 = getelementptr inbounds %struct.ImVec2, ptr %p_min, i32 0, i32 0
  %20 = load float, ptr %x20, align 4
  %x21 = getelementptr inbounds %struct.ImVec2, ptr %grid_off, i32 0, i32 0
  %21 = load float, ptr %x21, align 4
  %add22 = fadd float %20, %21
  %22 = load i32, ptr %yi, align 4
  %and23 = and i32 %22, 1
  %conv = sitofp i32 %and23 to float
  %23 = load float, ptr %grid_step.addr, align 4
  %24 = call float @llvm.fmuladd.f32(float %conv, float %23, float %add22)
  store float %24, ptr %x, align 4
  br label %for.cond24

for.cond24:                                       ; preds = %for.inc, %if.end19
  %25 = load float, ptr %x, align 4
  %x25 = getelementptr inbounds %struct.ImVec2, ptr %p_max, i32 0, i32 0
  %26 = load float, ptr %x25, align 4
  %cmp26 = fcmp olt float %25, %26
  br i1 %cmp26, label %for.body27, label %for.end

for.body27:                                       ; preds = %for.cond24
  %27 = load float, ptr %x, align 4
  %x28 = getelementptr inbounds %struct.ImVec2, ptr %p_min, i32 0, i32 0
  %28 = load float, ptr %x28, align 4
  %x29 = getelementptr inbounds %struct.ImVec2, ptr %p_max, i32 0, i32 0
  %29 = load float, ptr %x29, align 4
  %call30 = call noundef float @_ZL7ImClampIfET_S0_S0_S0_(float noundef %27, float noundef %28, float noundef %29)
  store float %call30, ptr %x1, align 4
  %30 = load float, ptr %x, align 4
  %31 = load float, ptr %grid_step.addr, align 4
  %add31 = fadd float %30, %31
  %x32 = getelementptr inbounds %struct.ImVec2, ptr %p_max, i32 0, i32 0
  %32 = load float, ptr %x32, align 4
  %call33 = call noundef float @_ZL5ImMinIfET_S0_S0_(float noundef %add31, float noundef %32)
  store float %call33, ptr %x2, align 4
  %33 = load float, ptr %x2, align 4
  %34 = load float, ptr %x1, align 4
  %cmp34 = fcmp ole float %33, %34
  br i1 %cmp34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %for.body27
  br label %for.inc

if.end36:                                         ; preds = %for.body27
  store i32 256, ptr %cell_flags, align 4
  %35 = load float, ptr %y1, align 4
  %y37 = getelementptr inbounds %struct.ImVec2, ptr %p_min, i32 0, i32 1
  %36 = load float, ptr %y37, align 4
  %cmp38 = fcmp ole float %35, %36
  br i1 %cmp38, label %if.then39, label %if.end49

if.then39:                                        ; preds = %if.end36
  %37 = load float, ptr %x1, align 4
  %x40 = getelementptr inbounds %struct.ImVec2, ptr %p_min, i32 0, i32 0
  %38 = load float, ptr %x40, align 4
  %cmp41 = fcmp ole float %37, %38
  br i1 %cmp41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %if.then39
  %39 = load i32, ptr %cell_flags, align 4
  %or = or i32 %39, 16
  store i32 %or, ptr %cell_flags, align 4
  br label %if.end43

if.end43:                                         ; preds = %if.then42, %if.then39
  %40 = load float, ptr %x2, align 4
  %x44 = getelementptr inbounds %struct.ImVec2, ptr %p_max, i32 0, i32 0
  %41 = load float, ptr %x44, align 4
  %cmp45 = fcmp oge float %40, %41
  br i1 %cmp45, label %if.then46, label %if.end48

if.then46:                                        ; preds = %if.end43
  %42 = load i32, ptr %cell_flags, align 4
  %or47 = or i32 %42, 32
  store i32 %or47, ptr %cell_flags, align 4
  br label %if.end48

if.end48:                                         ; preds = %if.then46, %if.end43
  br label %if.end49

if.end49:                                         ; preds = %if.end48, %if.end36
  %43 = load float, ptr %y2, align 4
  %y50 = getelementptr inbounds %struct.ImVec2, ptr %p_max, i32 0, i32 1
  %44 = load float, ptr %y50, align 4
  %cmp51 = fcmp oge float %43, %44
  br i1 %cmp51, label %if.then52, label %if.end63

if.then52:                                        ; preds = %if.end49
  %45 = load float, ptr %x1, align 4
  %x53 = getelementptr inbounds %struct.ImVec2, ptr %p_min, i32 0, i32 0
  %46 = load float, ptr %x53, align 4
  %cmp54 = fcmp ole float %45, %46
  br i1 %cmp54, label %if.then55, label %if.end57

if.then55:                                        ; preds = %if.then52
  %47 = load i32, ptr %cell_flags, align 4
  %or56 = or i32 %47, 64
  store i32 %or56, ptr %cell_flags, align 4
  br label %if.end57

if.end57:                                         ; preds = %if.then55, %if.then52
  %48 = load float, ptr %x2, align 4
  %x58 = getelementptr inbounds %struct.ImVec2, ptr %p_max, i32 0, i32 0
  %49 = load float, ptr %x58, align 4
  %cmp59 = fcmp oge float %48, %49
  br i1 %cmp59, label %if.then60, label %if.end62

if.then60:                                        ; preds = %if.end57
  %50 = load i32, ptr %cell_flags, align 4
  %or61 = or i32 %50, 128
  store i32 %or61, ptr %cell_flags, align 4
  br label %if.end62

if.end62:                                         ; preds = %if.then60, %if.end57
  br label %if.end63

if.end63:                                         ; preds = %if.end62, %if.end49
  %51 = load i32, ptr %flags.addr, align 4
  %cmp64 = icmp eq i32 %51, 256
  br i1 %cmp64, label %cond.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end63
  %52 = load i32, ptr %cell_flags, align 4
  %cmp65 = icmp eq i32 %52, 256
  br i1 %cmp65, label %cond.true, label %cond.false

cond.true:                                        ; preds = %lor.lhs.false, %if.end63
  br label %cond.end

cond.false:                                       ; preds = %lor.lhs.false
  %53 = load i32, ptr %cell_flags, align 4
  %54 = load i32, ptr %flags.addr, align 4
  %and66 = and i32 %53, %54
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 256, %cond.true ], [ %and66, %cond.false ]
  store i32 %cond, ptr %cell_flags, align 4
  %55 = load ptr, ptr %draw_list.addr, align 8
  %56 = load float, ptr %x1, align 4
  %57 = load float, ptr %y1, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, float noundef %56, float noundef %57)
  %58 = load float, ptr %x2, align 4
  %59 = load float, ptr %y2, align 4
  call void @_ZN6ImVec2C2Eff(ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp67, float noundef %58, float noundef %59)
  %60 = load i32, ptr %col_bg2, align 4
  %61 = load float, ptr %rounding.addr, align 4
  %62 = load i32, ptr %cell_flags, align 4
  call void @_ZN10ImDrawList13AddRectFilledERK6ImVec2S2_jfi(ptr noundef nonnull align 8 dereferenceable(196) %55, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp, ptr noundef nonnull align 4 dereferenceable(8) %ref.tmp67, i32 noundef %60, float noundef %61, i32 noundef %62)
  br label %for.inc

for.inc:                                          ; preds = %cond.end, %if.then35
  %63 = load float, ptr %grid_step.addr, align 4
  %64 = load float, ptr %x, align 4
  %65 = call float @llvm.fmuladd.f32(float %63, float 2.000000e+00, float %64)
  store float %65, ptr %x, align 4
  br label %for.cond24, !llvm.loop !97

for.end:                                          ; preds = %for.cond24
  br label %for.inc68

for.inc68:                                        ; preds = %for.end, %if.then18
  %66 = load float, ptr %grid_step.addr, align 4
  %67 = load float, ptr %y, align 4
  %add69 = fadd float %67, %66
  store float %add69, ptr %y, align 4
  %68 = load i32, ptr %yi, align 4
  %inc = add nsw i32 %68, 1
  store i32 %inc, ptr %yi, align 4
  br label %for.cond, !llvm.loop !98

for.end70:                                        ; preds = %for.cond
  br label %if.end71

if.else:                                          ; preds = %if.end
  %69 = load ptr, ptr %draw_list.addr, align 8
  %70 = load i32, ptr %col.addr, align 4
  %71 = load float, ptr %rounding.addr, align 4
  %72 = load i32, ptr %flags.addr, align 4
  call void @_ZN10ImDrawList13AddRectFilledERK6ImVec2S2_jfi(ptr noundef nonnull align 8 dereferenceable(196) %69, ptr noundef nonnull align 4 dereferenceable(8) %p_min, ptr noundef nonnull align 4 dereferenceable(8) %p_max, i32 noundef %70, float noundef %71, i32 noundef %72)
  br label %if.end71

if.end71:                                         ; preds = %if.else, %for.end70
  ret void
}

declare noundef i32 @_ZN5ImGui11GetColorU32Ej(i32 noundef) #1

declare noundef i32 @_Z18ImAlphaBlendColorsjj(i32 noundef, i32 noundef) #1

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI9ImDrawCmdEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI6ImVec4EC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorIPvEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN15ImDrawCmdHeaderC2Ev(ptr noundef nonnull align 8 dereferenceable(28) %this) unnamed_addr #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %ClipRect = getelementptr inbounds %struct.ImDrawCmdHeader, ptr %this1, i32 0, i32 0
  call void @_ZN6ImVec4C2Ev(ptr noundef nonnull align 4 dereferenceable(16) %ClipRect)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN18ImDrawListSplitterC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %_Channels = getelementptr inbounds %struct.ImDrawListSplitter, ptr %this1, i32 0, i32 2
  call void @_ZN8ImVectorI13ImDrawChannelEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %_Channels)
  call void @llvm.memset.p0.i64(ptr align 8 %this1, i8 0, i64 24, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorIPvED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Data2 = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  invoke void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %invoke.cont, %entry
  ret void

terminate.lpad:                                   ; preds = %if.then
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #13
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI6ImVec4ED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Data2 = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  invoke void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %invoke.cont, %entry
  ret void

terminate.lpad:                                   ; preds = %if.then
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #13
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI9ImDrawCmdED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Data2 = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  invoke void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %invoke.cont, %entry
  ret void

terminate.lpad:                                   ; preds = %if.then
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #13
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI13ImDrawChannelEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.5, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.5, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data = getelementptr inbounds %struct.ImVector.5, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data, align 8
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(none)
declare <4 x float> @llvm.x86.sse.rsqrt.ss(<4 x float>) #11

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZL12Decode85Bytec(i8 noundef signext %c) #2 {
entry:
  %c.addr = alloca i8, align 1
  store i8 %c, ptr %c.addr, align 1
  %0 = load i8, ptr %c.addr, align 1
  %conv = sext i8 %0 to i32
  %cmp = icmp sge i32 %conv, 92
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i8, ptr %c.addr, align 1
  %conv1 = sext i8 %1 to i32
  %sub = sub nsw i32 %conv1, 36
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load i8, ptr %c.addr, align 1
  %conv2 = sext i8 %2 to i32
  %sub3 = sub nsw i32 %conv2, 35
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %sub, %cond.true ], [ %sub3, %cond.false ]
  ret i32 %cond
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI18ImFontBuildSrcDataEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.14, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.14, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data = getelementptr inbounds %struct.ImVector.14, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI18ImFontBuildDstDataEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.15, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.15, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data = getelementptr inbounds %struct.ImVector.15, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI18ImFontBuildSrcDataE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_size) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_size, ptr %new_size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_size.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.14, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sgt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %new_size.addr, align 4
  %call = call noundef i32 @_ZNK8ImVectorI18ImFontBuildSrcDataE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %2)
  call void @_ZN8ImVectorI18ImFontBuildSrcDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %new_size.addr, align 4
  %Size = getelementptr inbounds %struct.ImVector.14, ptr %this1, i32 0, i32 0
  store i32 %3, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI18ImFontBuildDstDataE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_size) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_size, ptr %new_size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_size.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.15, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sgt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %new_size.addr, align 4
  %call = call noundef i32 @_ZNK8ImVectorI18ImFontBuildDstDataE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %2)
  call void @_ZN8ImVectorI18ImFontBuildDstDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %new_size.addr, align 4
  %Size = getelementptr inbounds %struct.ImVector.15, ptr %this1, i32 0, i32 0
  store i32 %3, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorI18ImFontBuildSrcDataE13size_in_bytesEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.14, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %mul = mul nsw i32 %0, 272
  ret i32 %mul
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorI18ImFontBuildDstDataE13size_in_bytesEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.15, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %mul = mul nsw i32 %0, 32
  ret i32 %mul
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 8 dereferenceable(272) ptr @_ZN8ImVectorI18ImFontBuildSrcDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.14, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 8 dereferenceable(144) ptr @_ZN8ImVectorI12ImFontConfigEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.ImFontConfig, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 8 dereferenceable(8) ptr @_ZN8ImVectorIP6ImFontEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define internal noundef i32 @_ZL27stbtt_GetFontOffsetForIndexPKhi(ptr noundef %data, i32 noundef %index) #4 {
entry:
  %data.addr = alloca ptr, align 8
  %index.addr = alloca i32, align 4
  store ptr %data, ptr %data.addr, align 8
  store i32 %index, ptr %index.addr, align 4
  %0 = load ptr, ptr %data.addr, align 8
  %1 = load i32, ptr %index.addr, align 4
  %call = call noundef i32 @_ZL36stbtt_GetFontOffsetForIndex_internalPhi(ptr noundef %0, i32 noundef %1)
  ret i32 %call
}

; Function Attrs: mustprogress uwtable
define internal noundef i32 @_ZL14stbtt_InitFontP14stbtt_fontinfoPKhi(ptr noundef %info, ptr noundef %data, i32 noundef %offset) #4 {
entry:
  %info.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  %offset.addr = alloca i32, align 4
  store ptr %info, ptr %info.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  store i32 %offset, ptr %offset.addr, align 4
  %0 = load ptr, ptr %info.addr, align 8
  %1 = load ptr, ptr %data.addr, align 8
  %2 = load i32, ptr %offset.addr, align 4
  %call = call noundef i32 @_ZL23stbtt_InitFont_internalP14stbtt_fontinfoPhi(ptr noundef %0, ptr noundef %1, i32 noundef %2)
  ret i32 %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 8 dereferenceable(32) ptr @_ZN8ImVectorI18ImFontBuildDstDataEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.15, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.ImFontBuildDstData, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN11ImBitVector6CreateEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Storage = getelementptr inbounds %struct.ImBitVector, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %sz.addr, align 4
  %add = add nsw i32 %0, 31
  %shr = ashr i32 %add, 5
  call void @_ZN8ImVectorIjE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %Storage, i32 noundef %shr)
  %Storage2 = getelementptr inbounds %struct.ImBitVector, ptr %this1, i32 0, i32 0
  %Data = getelementptr inbounds %struct.ImVector.13, ptr %Storage2, i32 0, i32 2
  %1 = load ptr, ptr %Data, align 8
  %Storage3 = getelementptr inbounds %struct.ImBitVector, ptr %this1, i32 0, i32 0
  %Size = getelementptr inbounds %struct.ImVector.13, ptr %Storage3, i32 0, i32 0
  %2 = load i32, ptr %Size, align 8
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 4
  call void @llvm.memset.p0.i64(ptr align 4 %1, i8 0, i64 %mul, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef zeroext i1 @_ZNK8ImVectorIjE5emptyEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.13, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %cmp = icmp eq i32 %0, 0
  ret i1 %cmp
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef zeroext i1 @_ZNK11ImBitVector7TestBitEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %n) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Storage = getelementptr inbounds %struct.ImBitVector, ptr %this1, i32 0, i32 0
  %Data = getelementptr inbounds %struct.ImVector.13, ptr %Storage, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %n.addr, align 4
  %shr = ashr i32 %1, 5
  %idxprom = sext i32 %shr to i64
  %arrayidx = getelementptr inbounds i32, ptr %0, i64 %idxprom
  %2 = load i32, ptr %arrayidx, align 4
  %3 = load i32, ptr %n.addr, align 4
  %and = and i32 %3, 31
  %shl = shl i32 1, %and
  %and2 = and i32 %2, %shl
  %cmp = icmp ne i32 %and2, 0
  ret i1 %cmp
}

; Function Attrs: mustprogress uwtable
define internal noundef i32 @_ZL20stbtt_FindGlyphIndexPK14stbtt_fontinfoi(ptr noundef %info, i32 noundef %unicode_codepoint) #4 {
entry:
  %retval = alloca i32, align 4
  %info.addr = alloca ptr, align 8
  %unicode_codepoint.addr = alloca i32, align 4
  %data = alloca ptr, align 8
  %index_map = alloca i32, align 4
  %format = alloca i16, align 2
  %bytes = alloca i32, align 4
  %first = alloca i32, align 4
  %count = alloca i32, align 4
  %segcount = alloca i16, align 2
  %searchRange = alloca i16, align 2
  %entrySelector = alloca i16, align 2
  %rangeShift = alloca i16, align 2
  %endCount = alloca i32, align 4
  %search = alloca i32, align 4
  %end = alloca i16, align 2
  %offset = alloca i16, align 2
  %start = alloca i16, align 2
  %last = alloca i16, align 2
  %item = alloca i16, align 2
  %ngroups = alloca i32, align 4
  %low = alloca i32, align 4
  %high = alloca i32, align 4
  %mid = alloca i32, align 4
  %start_char = alloca i32, align 4
  %end_char = alloca i32, align 4
  %start_glyph = alloca i32, align 4
  store ptr %info, ptr %info.addr, align 8
  store i32 %unicode_codepoint, ptr %unicode_codepoint.addr, align 4
  %0 = load ptr, ptr %info.addr, align 8
  %data1 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %data1, align 8
  store ptr %1, ptr %data, align 8
  %2 = load ptr, ptr %info.addr, align 8
  %index_map2 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %2, i32 0, i32 12
  %3 = load i32, ptr %index_map2, align 8
  store i32 %3, ptr %index_map, align 4
  %4 = load ptr, ptr %data, align 8
  %5 = load i32, ptr %index_map, align 4
  %idx.ext = zext i32 %5 to i64
  %add.ptr = getelementptr inbounds i8, ptr %4, i64 %idx.ext
  %add.ptr3 = getelementptr inbounds i8, ptr %add.ptr, i64 0
  %call = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr3)
  store i16 %call, ptr %format, align 2
  %6 = load i16, ptr %format, align 2
  %conv = zext i16 %6 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %7 = load ptr, ptr %data, align 8
  %8 = load i32, ptr %index_map, align 4
  %idx.ext4 = zext i32 %8 to i64
  %add.ptr5 = getelementptr inbounds i8, ptr %7, i64 %idx.ext4
  %add.ptr6 = getelementptr inbounds i8, ptr %add.ptr5, i64 2
  %call7 = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr6)
  %conv8 = zext i16 %call7 to i32
  store i32 %conv8, ptr %bytes, align 4
  %9 = load i32, ptr %unicode_codepoint.addr, align 4
  %10 = load i32, ptr %bytes, align 4
  %sub = sub nsw i32 %10, 6
  %cmp9 = icmp slt i32 %9, %sub
  br i1 %cmp9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.then
  %11 = load ptr, ptr %data, align 8
  %12 = load i32, ptr %index_map, align 4
  %idx.ext11 = zext i32 %12 to i64
  %add.ptr12 = getelementptr inbounds i8, ptr %11, i64 %idx.ext11
  %add.ptr13 = getelementptr inbounds i8, ptr %add.ptr12, i64 6
  %13 = load i32, ptr %unicode_codepoint.addr, align 4
  %idx.ext14 = sext i32 %13 to i64
  %add.ptr15 = getelementptr inbounds i8, ptr %add.ptr13, i64 %idx.ext14
  %14 = load i8, ptr %add.ptr15, align 1
  %conv16 = zext i8 %14 to i32
  store i32 %conv16, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  store i32 0, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %15 = load i16, ptr %format, align 2
  %conv17 = zext i16 %15 to i32
  %cmp18 = icmp eq i32 %conv17, 6
  br i1 %cmp18, label %if.then19, label %if.else42

if.then19:                                        ; preds = %if.else
  %16 = load ptr, ptr %data, align 8
  %17 = load i32, ptr %index_map, align 4
  %idx.ext20 = zext i32 %17 to i64
  %add.ptr21 = getelementptr inbounds i8, ptr %16, i64 %idx.ext20
  %add.ptr22 = getelementptr inbounds i8, ptr %add.ptr21, i64 6
  %call23 = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr22)
  %conv24 = zext i16 %call23 to i32
  store i32 %conv24, ptr %first, align 4
  %18 = load ptr, ptr %data, align 8
  %19 = load i32, ptr %index_map, align 4
  %idx.ext25 = zext i32 %19 to i64
  %add.ptr26 = getelementptr inbounds i8, ptr %18, i64 %idx.ext25
  %add.ptr27 = getelementptr inbounds i8, ptr %add.ptr26, i64 8
  %call28 = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr27)
  %conv29 = zext i16 %call28 to i32
  store i32 %conv29, ptr %count, align 4
  %20 = load i32, ptr %unicode_codepoint.addr, align 4
  %21 = load i32, ptr %first, align 4
  %cmp30 = icmp uge i32 %20, %21
  br i1 %cmp30, label %land.lhs.true, label %if.end41

land.lhs.true:                                    ; preds = %if.then19
  %22 = load i32, ptr %unicode_codepoint.addr, align 4
  %23 = load i32, ptr %first, align 4
  %24 = load i32, ptr %count, align 4
  %add = add i32 %23, %24
  %cmp31 = icmp ult i32 %22, %add
  br i1 %cmp31, label %if.then32, label %if.end41

if.then32:                                        ; preds = %land.lhs.true
  %25 = load ptr, ptr %data, align 8
  %26 = load i32, ptr %index_map, align 4
  %idx.ext33 = zext i32 %26 to i64
  %add.ptr34 = getelementptr inbounds i8, ptr %25, i64 %idx.ext33
  %add.ptr35 = getelementptr inbounds i8, ptr %add.ptr34, i64 10
  %27 = load i32, ptr %unicode_codepoint.addr, align 4
  %28 = load i32, ptr %first, align 4
  %sub36 = sub i32 %27, %28
  %mul = mul i32 %sub36, 2
  %idx.ext37 = zext i32 %mul to i64
  %add.ptr38 = getelementptr inbounds i8, ptr %add.ptr35, i64 %idx.ext37
  %call39 = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr38)
  %conv40 = zext i16 %call39 to i32
  store i32 %conv40, ptr %retval, align 4
  br label %return

if.end41:                                         ; preds = %land.lhs.true, %if.then19
  store i32 0, ptr %retval, align 4
  br label %return

if.else42:                                        ; preds = %if.else
  %29 = load i16, ptr %format, align 2
  %conv43 = zext i16 %29 to i32
  %cmp44 = icmp eq i32 %conv43, 2
  br i1 %cmp44, label %if.then45, label %if.else46

if.then45:                                        ; preds = %if.else42
  br label %do.body

do.body:                                          ; preds = %if.then45
  br label %do.end

do.end:                                           ; preds = %do.body
  store i32 0, ptr %retval, align 4
  br label %return

if.else46:                                        ; preds = %if.else42
  %30 = load i16, ptr %format, align 2
  %conv47 = zext i16 %30 to i32
  %cmp48 = icmp eq i32 %conv47, 4
  br i1 %cmp48, label %if.then49, label %if.else196

if.then49:                                        ; preds = %if.else46
  %31 = load ptr, ptr %data, align 8
  %32 = load i32, ptr %index_map, align 4
  %idx.ext50 = zext i32 %32 to i64
  %add.ptr51 = getelementptr inbounds i8, ptr %31, i64 %idx.ext50
  %add.ptr52 = getelementptr inbounds i8, ptr %add.ptr51, i64 6
  %call53 = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr52)
  %conv54 = zext i16 %call53 to i32
  %shr = ashr i32 %conv54, 1
  %conv55 = trunc i32 %shr to i16
  store i16 %conv55, ptr %segcount, align 2
  %33 = load ptr, ptr %data, align 8
  %34 = load i32, ptr %index_map, align 4
  %idx.ext56 = zext i32 %34 to i64
  %add.ptr57 = getelementptr inbounds i8, ptr %33, i64 %idx.ext56
  %add.ptr58 = getelementptr inbounds i8, ptr %add.ptr57, i64 8
  %call59 = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr58)
  %conv60 = zext i16 %call59 to i32
  %shr61 = ashr i32 %conv60, 1
  %conv62 = trunc i32 %shr61 to i16
  store i16 %conv62, ptr %searchRange, align 2
  %35 = load ptr, ptr %data, align 8
  %36 = load i32, ptr %index_map, align 4
  %idx.ext63 = zext i32 %36 to i64
  %add.ptr64 = getelementptr inbounds i8, ptr %35, i64 %idx.ext63
  %add.ptr65 = getelementptr inbounds i8, ptr %add.ptr64, i64 10
  %call66 = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr65)
  store i16 %call66, ptr %entrySelector, align 2
  %37 = load ptr, ptr %data, align 8
  %38 = load i32, ptr %index_map, align 4
  %idx.ext67 = zext i32 %38 to i64
  %add.ptr68 = getelementptr inbounds i8, ptr %37, i64 %idx.ext67
  %add.ptr69 = getelementptr inbounds i8, ptr %add.ptr68, i64 12
  %call70 = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr69)
  %conv71 = zext i16 %call70 to i32
  %shr72 = ashr i32 %conv71, 1
  %conv73 = trunc i32 %shr72 to i16
  store i16 %conv73, ptr %rangeShift, align 2
  %39 = load i32, ptr %index_map, align 4
  %add74 = add i32 %39, 14
  store i32 %add74, ptr %endCount, align 4
  %40 = load i32, ptr %endCount, align 4
  store i32 %40, ptr %search, align 4
  %41 = load i32, ptr %unicode_codepoint.addr, align 4
  %cmp75 = icmp sgt i32 %41, 65535
  br i1 %cmp75, label %if.then76, label %if.end77

if.then76:                                        ; preds = %if.then49
  store i32 0, ptr %retval, align 4
  br label %return

if.end77:                                         ; preds = %if.then49
  %42 = load i32, ptr %unicode_codepoint.addr, align 4
  %43 = load ptr, ptr %data, align 8
  %44 = load i32, ptr %search, align 4
  %idx.ext78 = zext i32 %44 to i64
  %add.ptr79 = getelementptr inbounds i8, ptr %43, i64 %idx.ext78
  %45 = load i16, ptr %rangeShift, align 2
  %conv80 = zext i16 %45 to i32
  %mul81 = mul nsw i32 %conv80, 2
  %idx.ext82 = sext i32 %mul81 to i64
  %add.ptr83 = getelementptr inbounds i8, ptr %add.ptr79, i64 %idx.ext82
  %call84 = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr83)
  %conv85 = zext i16 %call84 to i32
  %cmp86 = icmp sge i32 %42, %conv85
  br i1 %cmp86, label %if.then87, label %if.end91

if.then87:                                        ; preds = %if.end77
  %46 = load i16, ptr %rangeShift, align 2
  %conv88 = zext i16 %46 to i32
  %mul89 = mul nsw i32 %conv88, 2
  %47 = load i32, ptr %search, align 4
  %add90 = add i32 %47, %mul89
  store i32 %add90, ptr %search, align 4
  br label %if.end91

if.end91:                                         ; preds = %if.then87, %if.end77
  %48 = load i32, ptr %search, align 4
  %sub92 = sub i32 %48, 2
  store i32 %sub92, ptr %search, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end109, %if.end91
  %49 = load i16, ptr %entrySelector, align 2
  %tobool = icmp ne i16 %49, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %50 = load i16, ptr %searchRange, align 2
  %conv93 = zext i16 %50 to i32
  %shr94 = ashr i32 %conv93, 1
  %conv95 = trunc i32 %shr94 to i16
  store i16 %conv95, ptr %searchRange, align 2
  %51 = load ptr, ptr %data, align 8
  %52 = load i32, ptr %search, align 4
  %idx.ext96 = zext i32 %52 to i64
  %add.ptr97 = getelementptr inbounds i8, ptr %51, i64 %idx.ext96
  %53 = load i16, ptr %searchRange, align 2
  %conv98 = zext i16 %53 to i32
  %mul99 = mul nsw i32 %conv98, 2
  %idx.ext100 = sext i32 %mul99 to i64
  %add.ptr101 = getelementptr inbounds i8, ptr %add.ptr97, i64 %idx.ext100
  %call102 = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr101)
  store i16 %call102, ptr %end, align 2
  %54 = load i32, ptr %unicode_codepoint.addr, align 4
  %55 = load i16, ptr %end, align 2
  %conv103 = zext i16 %55 to i32
  %cmp104 = icmp sgt i32 %54, %conv103
  br i1 %cmp104, label %if.then105, label %if.end109

if.then105:                                       ; preds = %while.body
  %56 = load i16, ptr %searchRange, align 2
  %conv106 = zext i16 %56 to i32
  %mul107 = mul nsw i32 %conv106, 2
  %57 = load i32, ptr %search, align 4
  %add108 = add i32 %57, %mul107
  store i32 %add108, ptr %search, align 4
  br label %if.end109

if.end109:                                        ; preds = %if.then105, %while.body
  %58 = load i16, ptr %entrySelector, align 2
  %dec = add i16 %58, -1
  store i16 %dec, ptr %entrySelector, align 2
  br label %while.cond, !llvm.loop !99

while.end:                                        ; preds = %while.cond
  %59 = load i32, ptr %search, align 4
  %add110 = add i32 %59, 2
  store i32 %add110, ptr %search, align 4
  %60 = load i32, ptr %search, align 4
  %61 = load i32, ptr %endCount, align 4
  %sub111 = sub i32 %60, %61
  %shr112 = lshr i32 %sub111, 1
  %conv113 = trunc i32 %shr112 to i16
  store i16 %conv113, ptr %item, align 2
  %62 = load ptr, ptr %data, align 8
  %63 = load i32, ptr %index_map, align 4
  %idx.ext114 = zext i32 %63 to i64
  %add.ptr115 = getelementptr inbounds i8, ptr %62, i64 %idx.ext114
  %add.ptr116 = getelementptr inbounds i8, ptr %add.ptr115, i64 14
  %64 = load i16, ptr %segcount, align 2
  %conv117 = zext i16 %64 to i32
  %mul118 = mul nsw i32 %conv117, 2
  %idx.ext119 = sext i32 %mul118 to i64
  %add.ptr120 = getelementptr inbounds i8, ptr %add.ptr116, i64 %idx.ext119
  %add.ptr121 = getelementptr inbounds i8, ptr %add.ptr120, i64 2
  %65 = load i16, ptr %item, align 2
  %conv122 = zext i16 %65 to i32
  %mul123 = mul nsw i32 2, %conv122
  %idx.ext124 = sext i32 %mul123 to i64
  %add.ptr125 = getelementptr inbounds i8, ptr %add.ptr121, i64 %idx.ext124
  %call126 = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr125)
  store i16 %call126, ptr %start, align 2
  %66 = load ptr, ptr %data, align 8
  %67 = load i32, ptr %endCount, align 4
  %idx.ext127 = zext i32 %67 to i64
  %add.ptr128 = getelementptr inbounds i8, ptr %66, i64 %idx.ext127
  %68 = load i16, ptr %item, align 2
  %conv129 = zext i16 %68 to i32
  %mul130 = mul nsw i32 2, %conv129
  %idx.ext131 = sext i32 %mul130 to i64
  %add.ptr132 = getelementptr inbounds i8, ptr %add.ptr128, i64 %idx.ext131
  %call133 = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr132)
  store i16 %call133, ptr %last, align 2
  %69 = load i32, ptr %unicode_codepoint.addr, align 4
  %70 = load i16, ptr %start, align 2
  %conv134 = zext i16 %70 to i32
  %cmp135 = icmp slt i32 %69, %conv134
  br i1 %cmp135, label %if.then138, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.end
  %71 = load i32, ptr %unicode_codepoint.addr, align 4
  %72 = load i16, ptr %last, align 2
  %conv136 = zext i16 %72 to i32
  %cmp137 = icmp sgt i32 %71, %conv136
  br i1 %cmp137, label %if.then138, label %if.end139

if.then138:                                       ; preds = %lor.lhs.false, %while.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end139:                                        ; preds = %lor.lhs.false
  %73 = load ptr, ptr %data, align 8
  %74 = load i32, ptr %index_map, align 4
  %idx.ext140 = zext i32 %74 to i64
  %add.ptr141 = getelementptr inbounds i8, ptr %73, i64 %idx.ext140
  %add.ptr142 = getelementptr inbounds i8, ptr %add.ptr141, i64 14
  %75 = load i16, ptr %segcount, align 2
  %conv143 = zext i16 %75 to i32
  %mul144 = mul nsw i32 %conv143, 6
  %idx.ext145 = sext i32 %mul144 to i64
  %add.ptr146 = getelementptr inbounds i8, ptr %add.ptr142, i64 %idx.ext145
  %add.ptr147 = getelementptr inbounds i8, ptr %add.ptr146, i64 2
  %76 = load i16, ptr %item, align 2
  %conv148 = zext i16 %76 to i32
  %mul149 = mul nsw i32 2, %conv148
  %idx.ext150 = sext i32 %mul149 to i64
  %add.ptr151 = getelementptr inbounds i8, ptr %add.ptr147, i64 %idx.ext150
  %call152 = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr151)
  store i16 %call152, ptr %offset, align 2
  %77 = load i16, ptr %offset, align 2
  %conv153 = zext i16 %77 to i32
  %cmp154 = icmp eq i32 %conv153, 0
  br i1 %cmp154, label %if.then155, label %if.end173

if.then155:                                       ; preds = %if.end139
  %78 = load i32, ptr %unicode_codepoint.addr, align 4
  %79 = load ptr, ptr %data, align 8
  %80 = load i32, ptr %index_map, align 4
  %idx.ext156 = zext i32 %80 to i64
  %add.ptr157 = getelementptr inbounds i8, ptr %79, i64 %idx.ext156
  %add.ptr158 = getelementptr inbounds i8, ptr %add.ptr157, i64 14
  %81 = load i16, ptr %segcount, align 2
  %conv159 = zext i16 %81 to i32
  %mul160 = mul nsw i32 %conv159, 4
  %idx.ext161 = sext i32 %mul160 to i64
  %add.ptr162 = getelementptr inbounds i8, ptr %add.ptr158, i64 %idx.ext161
  %add.ptr163 = getelementptr inbounds i8, ptr %add.ptr162, i64 2
  %82 = load i16, ptr %item, align 2
  %conv164 = zext i16 %82 to i32
  %mul165 = mul nsw i32 2, %conv164
  %idx.ext166 = sext i32 %mul165 to i64
  %add.ptr167 = getelementptr inbounds i8, ptr %add.ptr163, i64 %idx.ext166
  %call168 = call noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %add.ptr167)
  %conv169 = sext i16 %call168 to i32
  %add170 = add nsw i32 %78, %conv169
  %conv171 = trunc i32 %add170 to i16
  %conv172 = zext i16 %conv171 to i32
  store i32 %conv172, ptr %retval, align 4
  br label %return

if.end173:                                        ; preds = %if.end139
  %83 = load ptr, ptr %data, align 8
  %84 = load i16, ptr %offset, align 2
  %conv174 = zext i16 %84 to i32
  %idx.ext175 = sext i32 %conv174 to i64
  %add.ptr176 = getelementptr inbounds i8, ptr %83, i64 %idx.ext175
  %85 = load i32, ptr %unicode_codepoint.addr, align 4
  %86 = load i16, ptr %start, align 2
  %conv177 = zext i16 %86 to i32
  %sub178 = sub nsw i32 %85, %conv177
  %mul179 = mul nsw i32 %sub178, 2
  %idx.ext180 = sext i32 %mul179 to i64
  %add.ptr181 = getelementptr inbounds i8, ptr %add.ptr176, i64 %idx.ext180
  %87 = load i32, ptr %index_map, align 4
  %idx.ext182 = zext i32 %87 to i64
  %add.ptr183 = getelementptr inbounds i8, ptr %add.ptr181, i64 %idx.ext182
  %add.ptr184 = getelementptr inbounds i8, ptr %add.ptr183, i64 14
  %88 = load i16, ptr %segcount, align 2
  %conv185 = zext i16 %88 to i32
  %mul186 = mul nsw i32 %conv185, 6
  %idx.ext187 = sext i32 %mul186 to i64
  %add.ptr188 = getelementptr inbounds i8, ptr %add.ptr184, i64 %idx.ext187
  %add.ptr189 = getelementptr inbounds i8, ptr %add.ptr188, i64 2
  %89 = load i16, ptr %item, align 2
  %conv190 = zext i16 %89 to i32
  %mul191 = mul nsw i32 2, %conv190
  %idx.ext192 = sext i32 %mul191 to i64
  %add.ptr193 = getelementptr inbounds i8, ptr %add.ptr189, i64 %idx.ext192
  %call194 = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr193)
  %conv195 = zext i16 %call194 to i32
  store i32 %conv195, ptr %retval, align 4
  br label %return

if.else196:                                       ; preds = %if.else46
  %90 = load i16, ptr %format, align 2
  %conv197 = zext i16 %90 to i32
  %cmp198 = icmp eq i32 %conv197, 12
  br i1 %cmp198, label %if.then202, label %lor.lhs.false199

lor.lhs.false199:                                 ; preds = %if.else196
  %91 = load i16, ptr %format, align 2
  %conv200 = zext i16 %91 to i32
  %cmp201 = icmp eq i32 %conv200, 13
  br i1 %cmp201, label %if.then202, label %if.end252

if.then202:                                       ; preds = %lor.lhs.false199, %if.else196
  %92 = load ptr, ptr %data, align 8
  %93 = load i32, ptr %index_map, align 4
  %idx.ext203 = zext i32 %93 to i64
  %add.ptr204 = getelementptr inbounds i8, ptr %92, i64 %idx.ext203
  %add.ptr205 = getelementptr inbounds i8, ptr %add.ptr204, i64 12
  %call206 = call noundef i32 @_ZL7ttULONGPh(ptr noundef %add.ptr205)
  store i32 %call206, ptr %ngroups, align 4
  store i32 0, ptr %low, align 4
  %94 = load i32, ptr %ngroups, align 4
  store i32 %94, ptr %high, align 4
  br label %while.cond207

while.cond207:                                    ; preds = %if.end250, %if.then202
  %95 = load i32, ptr %low, align 4
  %96 = load i32, ptr %high, align 4
  %cmp208 = icmp slt i32 %95, %96
  br i1 %cmp208, label %while.body209, label %while.end251

while.body209:                                    ; preds = %while.cond207
  %97 = load i32, ptr %low, align 4
  %98 = load i32, ptr %high, align 4
  %99 = load i32, ptr %low, align 4
  %sub210 = sub nsw i32 %98, %99
  %shr211 = ashr i32 %sub210, 1
  %add212 = add nsw i32 %97, %shr211
  store i32 %add212, ptr %mid, align 4
  %100 = load ptr, ptr %data, align 8
  %101 = load i32, ptr %index_map, align 4
  %idx.ext213 = zext i32 %101 to i64
  %add.ptr214 = getelementptr inbounds i8, ptr %100, i64 %idx.ext213
  %add.ptr215 = getelementptr inbounds i8, ptr %add.ptr214, i64 16
  %102 = load i32, ptr %mid, align 4
  %mul216 = mul nsw i32 %102, 12
  %idx.ext217 = sext i32 %mul216 to i64
  %add.ptr218 = getelementptr inbounds i8, ptr %add.ptr215, i64 %idx.ext217
  %call219 = call noundef i32 @_ZL7ttULONGPh(ptr noundef %add.ptr218)
  store i32 %call219, ptr %start_char, align 4
  %103 = load ptr, ptr %data, align 8
  %104 = load i32, ptr %index_map, align 4
  %idx.ext220 = zext i32 %104 to i64
  %add.ptr221 = getelementptr inbounds i8, ptr %103, i64 %idx.ext220
  %add.ptr222 = getelementptr inbounds i8, ptr %add.ptr221, i64 16
  %105 = load i32, ptr %mid, align 4
  %mul223 = mul nsw i32 %105, 12
  %idx.ext224 = sext i32 %mul223 to i64
  %add.ptr225 = getelementptr inbounds i8, ptr %add.ptr222, i64 %idx.ext224
  %add.ptr226 = getelementptr inbounds i8, ptr %add.ptr225, i64 4
  %call227 = call noundef i32 @_ZL7ttULONGPh(ptr noundef %add.ptr226)
  store i32 %call227, ptr %end_char, align 4
  %106 = load i32, ptr %unicode_codepoint.addr, align 4
  %107 = load i32, ptr %start_char, align 4
  %cmp228 = icmp ult i32 %106, %107
  br i1 %cmp228, label %if.then229, label %if.else230

if.then229:                                       ; preds = %while.body209
  %108 = load i32, ptr %mid, align 4
  store i32 %108, ptr %high, align 4
  br label %if.end250

if.else230:                                       ; preds = %while.body209
  %109 = load i32, ptr %unicode_codepoint.addr, align 4
  %110 = load i32, ptr %end_char, align 4
  %cmp231 = icmp ugt i32 %109, %110
  br i1 %cmp231, label %if.then232, label %if.else234

if.then232:                                       ; preds = %if.else230
  %111 = load i32, ptr %mid, align 4
  %add233 = add nsw i32 %111, 1
  store i32 %add233, ptr %low, align 4
  br label %if.end249

if.else234:                                       ; preds = %if.else230
  %112 = load ptr, ptr %data, align 8
  %113 = load i32, ptr %index_map, align 4
  %idx.ext235 = zext i32 %113 to i64
  %add.ptr236 = getelementptr inbounds i8, ptr %112, i64 %idx.ext235
  %add.ptr237 = getelementptr inbounds i8, ptr %add.ptr236, i64 16
  %114 = load i32, ptr %mid, align 4
  %mul238 = mul nsw i32 %114, 12
  %idx.ext239 = sext i32 %mul238 to i64
  %add.ptr240 = getelementptr inbounds i8, ptr %add.ptr237, i64 %idx.ext239
  %add.ptr241 = getelementptr inbounds i8, ptr %add.ptr240, i64 8
  %call242 = call noundef i32 @_ZL7ttULONGPh(ptr noundef %add.ptr241)
  store i32 %call242, ptr %start_glyph, align 4
  %115 = load i16, ptr %format, align 2
  %conv243 = zext i16 %115 to i32
  %cmp244 = icmp eq i32 %conv243, 12
  br i1 %cmp244, label %if.then245, label %if.else248

if.then245:                                       ; preds = %if.else234
  %116 = load i32, ptr %start_glyph, align 4
  %117 = load i32, ptr %unicode_codepoint.addr, align 4
  %add246 = add i32 %116, %117
  %118 = load i32, ptr %start_char, align 4
  %sub247 = sub i32 %add246, %118
  store i32 %sub247, ptr %retval, align 4
  br label %return

if.else248:                                       ; preds = %if.else234
  %119 = load i32, ptr %start_glyph, align 4
  store i32 %119, ptr %retval, align 4
  br label %return

if.end249:                                        ; preds = %if.then232
  br label %if.end250

if.end250:                                        ; preds = %if.end249, %if.then229
  br label %while.cond207, !llvm.loop !100

while.end251:                                     ; preds = %while.cond207
  store i32 0, ptr %retval, align 4
  br label %return

if.end252:                                        ; preds = %lor.lhs.false199
  br label %if.end253

if.end253:                                        ; preds = %if.end252
  br label %if.end254

if.end254:                                        ; preds = %if.end253
  br label %if.end255

if.end255:                                        ; preds = %if.end254
  br label %if.end256

if.end256:                                        ; preds = %if.end255
  br label %do.body257

do.body257:                                       ; preds = %if.end256
  br label %do.end258

do.end258:                                        ; preds = %do.body257
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %do.end258, %while.end251, %if.else248, %if.then245, %if.end173, %if.then155, %if.then138, %if.then76, %do.end, %if.end41, %if.then32, %if.end, %if.then10
  %120 = load i32, ptr %retval, align 4
  ret i32 %120
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN11ImBitVector6SetBitEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %n) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Storage = getelementptr inbounds %struct.ImBitVector, ptr %this1, i32 0, i32 0
  %Data = getelementptr inbounds %struct.ImVector.13, ptr %Storage, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %n.addr, align 4
  call void @_Z16ImBitArraySetBitPji(ptr noundef %0, i32 noundef %1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorIiE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.16, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 4
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.16, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.16, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.16, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %4, ptr align 4 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.16, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.16, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.16, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL30UnpackBitVectorToFlatIndexListPK11ImBitVectorP8ImVectorIiE(ptr noundef %in, ptr noundef %out) #4 {
entry:
  %in.addr = alloca ptr, align 8
  %out.addr = alloca ptr, align 8
  %it_begin = alloca ptr, align 8
  %it_end = alloca ptr, align 8
  %it = alloca ptr, align 8
  %entries_32 = alloca i32, align 4
  %bit_n = alloca i32, align 4
  %ref.tmp = alloca i32, align 4
  store ptr %in, ptr %in.addr, align 8
  store ptr %out, ptr %out.addr, align 8
  %0 = load ptr, ptr %in.addr, align 8
  %Storage = getelementptr inbounds %struct.ImBitVector, ptr %0, i32 0, i32 0
  %call = call noundef ptr @_ZNK8ImVectorIjE5beginEv(ptr noundef nonnull align 8 dereferenceable(16) %Storage)
  store ptr %call, ptr %it_begin, align 8
  %1 = load ptr, ptr %in.addr, align 8
  %Storage1 = getelementptr inbounds %struct.ImBitVector, ptr %1, i32 0, i32 0
  %call2 = call noundef ptr @_ZNK8ImVectorIjE3endEv(ptr noundef nonnull align 8 dereferenceable(16) %Storage1)
  store ptr %call2, ptr %it_end, align 8
  %2 = load ptr, ptr %it_begin, align 8
  store ptr %2, ptr %it, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc11, %entry
  %3 = load ptr, ptr %it, align 8
  %4 = load ptr, ptr %it_end, align 8
  %cmp = icmp ult ptr %3, %4
  br i1 %cmp, label %for.body, label %for.end12

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %it, align 8
  %6 = load i32, ptr %5, align 4
  store i32 %6, ptr %entries_32, align 4
  %7 = load i32, ptr %entries_32, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.then, label %if.end10

if.then:                                          ; preds = %for.body
  store i32 0, ptr %bit_n, align 4
  br label %for.cond3

for.cond3:                                        ; preds = %for.inc, %if.then
  %8 = load i32, ptr %bit_n, align 4
  %cmp4 = icmp ult i32 %8, 32
  br i1 %cmp4, label %for.body5, label %for.end

for.body5:                                        ; preds = %for.cond3
  %9 = load i32, ptr %entries_32, align 4
  %10 = load i32, ptr %bit_n, align 4
  %shl = shl i32 1, %10
  %and = and i32 %9, %shl
  %tobool6 = icmp ne i32 %and, 0
  br i1 %tobool6, label %if.then7, label %if.end

if.then7:                                         ; preds = %for.body5
  %11 = load ptr, ptr %out.addr, align 8
  %12 = load ptr, ptr %it, align 8
  %13 = load ptr, ptr %it_begin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %12 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %13 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %shl8 = shl i64 %sub.ptr.div, 5
  %14 = load i32, ptr %bit_n, align 4
  %conv = zext i32 %14 to i64
  %add = add nsw i64 %shl8, %conv
  %conv9 = trunc i64 %add to i32
  store i32 %conv9, ptr %ref.tmp, align 4
  call void @_ZN8ImVectorIiE9push_backERKi(ptr noundef nonnull align 8 dereferenceable(16) %11, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp)
  br label %if.end

if.end:                                           ; preds = %if.then7, %for.body5
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %15 = load i32, ptr %bit_n, align 4
  %inc = add i32 %15, 1
  store i32 %inc, ptr %bit_n, align 4
  br label %for.cond3, !llvm.loop !101

for.end:                                          ; preds = %for.cond3
  br label %if.end10

if.end10:                                         ; preds = %for.end, %for.body
  br label %for.inc11

for.inc11:                                        ; preds = %if.end10
  %16 = load ptr, ptr %it, align 8
  %incdec.ptr = getelementptr inbounds i32, ptr %16, i32 1
  store ptr %incdec.ptr, ptr %it, align 8
  br label %for.cond, !llvm.loop !102

for.end12:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN11ImBitVector5ClearEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Storage = getelementptr inbounds %struct.ImBitVector, ptr %this1, i32 0, i32 0
  call void @_ZN8ImVectorIjE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %Storage)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI18ImFontBuildDstDataE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.15, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Capacity = getelementptr inbounds %struct.ImVector.15, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.15, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data2 = getelementptr inbounds %struct.ImVector.15, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
  %Data3 = getelementptr inbounds %struct.ImVector.15, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI16stbtt_packedcharEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI16stbtt_packedcharE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_size) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_size, ptr %new_size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_size.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sgt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %new_size.addr, align 4
  %call = call noundef i32 @_ZNK8ImVectorI16stbtt_packedcharE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %2)
  call void @_ZN8ImVectorI16stbtt_packedcharE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %new_size.addr, align 4
  %Size = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 0
  store i32 %3, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorI16stbtt_packedcharE13size_in_bytesEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %mul = mul nsw i32 %0, 28
  ret i32 %mul
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 4 dereferenceable(28) ptr @_ZN8ImVectorI16stbtt_packedcharEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.stbtt_packedchar, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef float @_ZL25stbtt_ScaleForPixelHeightPK14stbtt_fontinfof(ptr noundef %info, float noundef %height) #2 {
entry:
  %info.addr = alloca ptr, align 8
  %height.addr = alloca float, align 4
  %fheight = alloca i32, align 4
  store ptr %info, ptr %info.addr, align 8
  store float %height, ptr %height.addr, align 4
  %0 = load ptr, ptr %info.addr, align 8
  %data = getelementptr inbounds %struct.stbtt_fontinfo, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %data, align 8
  %2 = load ptr, ptr %info.addr, align 8
  %hhea = getelementptr inbounds %struct.stbtt_fontinfo, ptr %2, i32 0, i32 7
  %3 = load i32, ptr %hhea, align 4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds i8, ptr %1, i64 %idx.ext
  %add.ptr1 = getelementptr inbounds i8, ptr %add.ptr, i64 4
  %call = call noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %add.ptr1)
  %conv = sext i16 %call to i32
  %4 = load ptr, ptr %info.addr, align 8
  %data2 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %data2, align 8
  %6 = load ptr, ptr %info.addr, align 8
  %hhea3 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %6, i32 0, i32 7
  %7 = load i32, ptr %hhea3, align 4
  %idx.ext4 = sext i32 %7 to i64
  %add.ptr5 = getelementptr inbounds i8, ptr %5, i64 %idx.ext4
  %add.ptr6 = getelementptr inbounds i8, ptr %add.ptr5, i64 6
  %call7 = call noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %add.ptr6)
  %conv8 = sext i16 %call7 to i32
  %sub = sub nsw i32 %conv, %conv8
  store i32 %sub, ptr %fheight, align 4
  %8 = load float, ptr %height.addr, align 4
  %9 = load i32, ptr %fheight, align 4
  %conv9 = sitofp i32 %9 to float
  %div = fdiv float %8, %conv9
  ret float %div
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef float @_ZL31stbtt_ScaleForMappingEmToPixelsPK14stbtt_fontinfof(ptr noundef %info, float noundef %pixels) #2 {
entry:
  %info.addr = alloca ptr, align 8
  %pixels.addr = alloca float, align 4
  %unitsPerEm = alloca i32, align 4
  store ptr %info, ptr %info.addr, align 8
  store float %pixels, ptr %pixels.addr, align 4
  %0 = load ptr, ptr %info.addr, align 8
  %data = getelementptr inbounds %struct.stbtt_fontinfo, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %data, align 8
  %2 = load ptr, ptr %info.addr, align 8
  %head = getelementptr inbounds %struct.stbtt_fontinfo, ptr %2, i32 0, i32 5
  %3 = load i32, ptr %head, align 4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds i8, ptr %1, i64 %idx.ext
  %add.ptr1 = getelementptr inbounds i8, ptr %add.ptr, i64 18
  %call = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr1)
  %conv = zext i16 %call to i32
  store i32 %conv, ptr %unitsPerEm, align 4
  %4 = load float, ptr %pixels.addr, align 4
  %5 = load i32, ptr %unitsPerEm, align 4
  %conv2 = sitofp i32 %5 to float
  %div = fdiv float %4, %conv2
  ret float %div
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 4 dereferenceable(4) ptr @_ZN8ImVectorIiEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.16, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds i32, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL31stbtt_GetGlyphBitmapBoxSubpixelPK14stbtt_fontinfoiffffPiS2_S2_S2_(ptr noundef %font, i32 noundef %glyph, float noundef %scale_x, float noundef %scale_y, float noundef %shift_x, float noundef %shift_y, ptr noundef %ix0, ptr noundef %iy0, ptr noundef %ix1, ptr noundef %iy1) #4 {
entry:
  %font.addr = alloca ptr, align 8
  %glyph.addr = alloca i32, align 4
  %scale_x.addr = alloca float, align 4
  %scale_y.addr = alloca float, align 4
  %shift_x.addr = alloca float, align 4
  %shift_y.addr = alloca float, align 4
  %ix0.addr = alloca ptr, align 8
  %iy0.addr = alloca ptr, align 8
  %ix1.addr = alloca ptr, align 8
  %iy1.addr = alloca ptr, align 8
  %x0 = alloca i32, align 4
  %y0 = alloca i32, align 4
  %x1 = alloca i32, align 4
  %y1 = alloca i32, align 4
  store ptr %font, ptr %font.addr, align 8
  store i32 %glyph, ptr %glyph.addr, align 4
  store float %scale_x, ptr %scale_x.addr, align 4
  store float %scale_y, ptr %scale_y.addr, align 4
  store float %shift_x, ptr %shift_x.addr, align 4
  store float %shift_y, ptr %shift_y.addr, align 4
  store ptr %ix0, ptr %ix0.addr, align 8
  store ptr %iy0, ptr %iy0.addr, align 8
  store ptr %ix1, ptr %ix1.addr, align 8
  store ptr %iy1, ptr %iy1.addr, align 8
  store i32 0, ptr %x0, align 4
  store i32 0, ptr %y0, align 4
  %0 = load ptr, ptr %font.addr, align 8
  %1 = load i32, ptr %glyph.addr, align 4
  %call = call noundef i32 @_ZL17stbtt_GetGlyphBoxPK14stbtt_fontinfoiPiS2_S2_S2_(ptr noundef %0, i32 noundef %1, ptr noundef %x0, ptr noundef %y0, ptr noundef %x1, ptr noundef %y1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %ix0.addr, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %3 = load ptr, ptr %ix0.addr, align 8
  store i32 0, ptr %3, align 4
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %4 = load ptr, ptr %iy0.addr, align 8
  %tobool3 = icmp ne ptr %4, null
  br i1 %tobool3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %5 = load ptr, ptr %iy0.addr, align 8
  store i32 0, ptr %5, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.end
  %6 = load ptr, ptr %ix1.addr, align 8
  %tobool6 = icmp ne ptr %6, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end5
  %7 = load ptr, ptr %ix1.addr, align 8
  store i32 0, ptr %7, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.end5
  %8 = load ptr, ptr %iy1.addr, align 8
  %tobool9 = icmp ne ptr %8, null
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end8
  %9 = load ptr, ptr %iy1.addr, align 8
  store i32 0, ptr %9, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %if.end8
  br label %if.end34

if.else:                                          ; preds = %entry
  %10 = load ptr, ptr %ix0.addr, align 8
  %tobool12 = icmp ne ptr %10, null
  br i1 %tobool12, label %if.then13, label %if.end16

if.then13:                                        ; preds = %if.else
  %11 = load i32, ptr %x0, align 4
  %conv = sitofp i32 %11 to float
  %12 = load float, ptr %scale_x.addr, align 4
  %13 = load float, ptr %shift_x.addr, align 4
  %14 = call float @llvm.fmuladd.f32(float %conv, float %12, float %13)
  %call14 = call noundef float @_ZL7ImFloorf(float noundef %14)
  %conv15 = fptosi float %call14 to i32
  %15 = load ptr, ptr %ix0.addr, align 8
  store i32 %conv15, ptr %15, align 4
  br label %if.end16

if.end16:                                         ; preds = %if.then13, %if.else
  %16 = load ptr, ptr %iy0.addr, align 8
  %tobool17 = icmp ne ptr %16, null
  br i1 %tobool17, label %if.then18, label %if.end22

if.then18:                                        ; preds = %if.end16
  %17 = load i32, ptr %y1, align 4
  %sub = sub nsw i32 0, %17
  %conv19 = sitofp i32 %sub to float
  %18 = load float, ptr %scale_y.addr, align 4
  %19 = load float, ptr %shift_y.addr, align 4
  %20 = call float @llvm.fmuladd.f32(float %conv19, float %18, float %19)
  %call20 = call noundef float @_ZL7ImFloorf(float noundef %20)
  %conv21 = fptosi float %call20 to i32
  %21 = load ptr, ptr %iy0.addr, align 8
  store i32 %conv21, ptr %21, align 4
  br label %if.end22

if.end22:                                         ; preds = %if.then18, %if.end16
  %22 = load ptr, ptr %ix1.addr, align 8
  %tobool23 = icmp ne ptr %22, null
  br i1 %tobool23, label %if.then24, label %if.end27

if.then24:                                        ; preds = %if.end22
  %23 = load i32, ptr %x1, align 4
  %conv25 = sitofp i32 %23 to float
  %24 = load float, ptr %scale_x.addr, align 4
  %25 = load float, ptr %shift_x.addr, align 4
  %26 = call float @llvm.fmuladd.f32(float %conv25, float %24, float %25)
  %27 = call float @llvm.ceil.f32(float %26)
  %conv26 = fptosi float %27 to i32
  %28 = load ptr, ptr %ix1.addr, align 8
  store i32 %conv26, ptr %28, align 4
  br label %if.end27

if.end27:                                         ; preds = %if.then24, %if.end22
  %29 = load ptr, ptr %iy1.addr, align 8
  %tobool28 = icmp ne ptr %29, null
  br i1 %tobool28, label %if.then29, label %if.end33

if.then29:                                        ; preds = %if.end27
  %30 = load i32, ptr %y0, align 4
  %sub30 = sub nsw i32 0, %30
  %conv31 = sitofp i32 %sub30 to float
  %31 = load float, ptr %scale_y.addr, align 4
  %32 = load float, ptr %shift_y.addr, align 4
  %33 = call float @llvm.fmuladd.f32(float %conv31, float %31, float %32)
  %34 = call float @llvm.ceil.f32(float %33)
  %conv32 = fptosi float %34 to i32
  %35 = load ptr, ptr %iy1.addr, align 8
  store i32 %conv32, ptr %35, align 4
  br label %if.end33

if.end33:                                         ; preds = %if.then29, %if.end27
  br label %if.end34

if.end34:                                         ; preds = %if.end33, %if.end11
  ret void
}

; Function Attrs: nounwind
declare float @sqrtf(float noundef) #6

; Function Attrs: mustprogress uwtable
define internal noundef i32 @_ZL15stbtt_PackBeginP18stbtt_pack_contextPhiiiiPv(ptr noundef %spc, ptr noundef %pixels, i32 noundef %pw, i32 noundef %ph, i32 noundef %stride_in_bytes, i32 noundef %padding, ptr noundef %alloc_context) #4 {
entry:
  %retval = alloca i32, align 4
  %spc.addr = alloca ptr, align 8
  %pixels.addr = alloca ptr, align 8
  %pw.addr = alloca i32, align 4
  %ph.addr = alloca i32, align 4
  %stride_in_bytes.addr = alloca i32, align 4
  %padding.addr = alloca i32, align 4
  %alloc_context.addr = alloca ptr, align 8
  %context = alloca ptr, align 8
  %num_nodes = alloca i32, align 4
  %nodes = alloca ptr, align 8
  store ptr %spc, ptr %spc.addr, align 8
  store ptr %pixels, ptr %pixels.addr, align 8
  store i32 %pw, ptr %pw.addr, align 4
  store i32 %ph, ptr %ph.addr, align 4
  store i32 %stride_in_bytes, ptr %stride_in_bytes.addr, align 4
  store i32 %padding, ptr %padding.addr, align 4
  store ptr %alloc_context, ptr %alloc_context.addr, align 8
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef 72)
  store ptr %call, ptr %context, align 8
  %0 = load i32, ptr %pw.addr, align 4
  %1 = load i32, ptr %padding.addr, align 4
  %sub = sub nsw i32 %0, %1
  store i32 %sub, ptr %num_nodes, align 4
  %2 = load i32, ptr %num_nodes, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 16, %conv
  %call1 = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call1, ptr %nodes, align 8
  %3 = load ptr, ptr %context, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load ptr, ptr %nodes, align 8
  %cmp2 = icmp eq ptr %4, null
  br i1 %cmp2, label %if.then, label %if.end8

if.then:                                          ; preds = %lor.lhs.false, %entry
  %5 = load ptr, ptr %context, align 8
  %cmp3 = icmp ne ptr %5, null
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %6 = load ptr, ptr %context, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  %7 = load ptr, ptr %nodes, align 8
  %cmp5 = icmp ne ptr %7, null
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %8 = load ptr, ptr %nodes, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %8)
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end8:                                          ; preds = %lor.lhs.false
  %9 = load ptr, ptr %alloc_context.addr, align 8
  %10 = load ptr, ptr %spc.addr, align 8
  %user_allocator_context = getelementptr inbounds %struct.stbtt_pack_context, ptr %10, i32 0, i32 0
  store ptr %9, ptr %user_allocator_context, align 8
  %11 = load i32, ptr %pw.addr, align 4
  %12 = load ptr, ptr %spc.addr, align 8
  %width = getelementptr inbounds %struct.stbtt_pack_context, ptr %12, i32 0, i32 2
  store i32 %11, ptr %width, align 8
  %13 = load i32, ptr %ph.addr, align 4
  %14 = load ptr, ptr %spc.addr, align 8
  %height = getelementptr inbounds %struct.stbtt_pack_context, ptr %14, i32 0, i32 3
  store i32 %13, ptr %height, align 4
  %15 = load ptr, ptr %pixels.addr, align 8
  %16 = load ptr, ptr %spc.addr, align 8
  %pixels9 = getelementptr inbounds %struct.stbtt_pack_context, ptr %16, i32 0, i32 9
  store ptr %15, ptr %pixels9, align 8
  %17 = load ptr, ptr %context, align 8
  %18 = load ptr, ptr %spc.addr, align 8
  %pack_info = getelementptr inbounds %struct.stbtt_pack_context, ptr %18, i32 0, i32 1
  store ptr %17, ptr %pack_info, align 8
  %19 = load ptr, ptr %nodes, align 8
  %20 = load ptr, ptr %spc.addr, align 8
  %nodes10 = getelementptr inbounds %struct.stbtt_pack_context, ptr %20, i32 0, i32 10
  store ptr %19, ptr %nodes10, align 8
  %21 = load i32, ptr %padding.addr, align 4
  %22 = load ptr, ptr %spc.addr, align 8
  %padding11 = getelementptr inbounds %struct.stbtt_pack_context, ptr %22, i32 0, i32 5
  store i32 %21, ptr %padding11, align 4
  %23 = load i32, ptr %stride_in_bytes.addr, align 4
  %cmp12 = icmp ne i32 %23, 0
  br i1 %cmp12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end8
  %24 = load i32, ptr %stride_in_bytes.addr, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end8
  %25 = load i32, ptr %pw.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %24, %cond.true ], [ %25, %cond.false ]
  %26 = load ptr, ptr %spc.addr, align 8
  %stride_in_bytes13 = getelementptr inbounds %struct.stbtt_pack_context, ptr %26, i32 0, i32 4
  store i32 %cond, ptr %stride_in_bytes13, align 8
  %27 = load ptr, ptr %spc.addr, align 8
  %h_oversample = getelementptr inbounds %struct.stbtt_pack_context, ptr %27, i32 0, i32 7
  store i32 1, ptr %h_oversample, align 4
  %28 = load ptr, ptr %spc.addr, align 8
  %v_oversample = getelementptr inbounds %struct.stbtt_pack_context, ptr %28, i32 0, i32 8
  store i32 1, ptr %v_oversample, align 8
  %29 = load ptr, ptr %spc.addr, align 8
  %skip_missing = getelementptr inbounds %struct.stbtt_pack_context, ptr %29, i32 0, i32 6
  store i32 0, ptr %skip_missing, align 8
  %30 = load ptr, ptr %context, align 8
  %31 = load i32, ptr %pw.addr, align 4
  %32 = load i32, ptr %padding.addr, align 4
  %sub14 = sub nsw i32 %31, %32
  %33 = load i32, ptr %ph.addr, align 4
  %34 = load i32, ptr %padding.addr, align 4
  %sub15 = sub nsw i32 %33, %34
  %35 = load ptr, ptr %nodes, align 8
  %36 = load i32, ptr %num_nodes, align 4
  call void @_ZL17stbrp_init_targetP13stbrp_contextiiP10stbrp_nodei(ptr noundef %30, i32 noundef %sub14, i32 noundef %sub15, ptr noundef %35, i32 noundef %36)
  %37 = load ptr, ptr %pixels.addr, align 8
  %tobool = icmp ne ptr %37, null
  br i1 %tobool, label %if.then16, label %if.end19

if.then16:                                        ; preds = %cond.end
  %38 = load ptr, ptr %pixels.addr, align 8
  %39 = load i32, ptr %pw.addr, align 4
  %40 = load i32, ptr %ph.addr, align 4
  %mul17 = mul nsw i32 %39, %40
  %conv18 = sext i32 %mul17 to i64
  call void @llvm.memset.p0.i64(ptr align 1 %38, i8 0, i64 %conv18, i1 false)
  br label %if.end19

if.end19:                                         ; preds = %if.then16, %cond.end
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end19, %if.end7
  %41 = load i32, ptr %retval, align 4
  ret i32 %41
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZL17ImUpperPowerOfTwoi(i32 noundef %v) #2 {
entry:
  %v.addr = alloca i32, align 4
  store i32 %v, ptr %v.addr, align 4
  %0 = load i32, ptr %v.addr, align 4
  %dec = add nsw i32 %0, -1
  store i32 %dec, ptr %v.addr, align 4
  %1 = load i32, ptr %v.addr, align 4
  %shr = ashr i32 %1, 1
  %2 = load i32, ptr %v.addr, align 4
  %or = or i32 %2, %shr
  store i32 %or, ptr %v.addr, align 4
  %3 = load i32, ptr %v.addr, align 4
  %shr1 = ashr i32 %3, 2
  %4 = load i32, ptr %v.addr, align 4
  %or2 = or i32 %4, %shr1
  store i32 %or2, ptr %v.addr, align 4
  %5 = load i32, ptr %v.addr, align 4
  %shr3 = ashr i32 %5, 4
  %6 = load i32, ptr %v.addr, align 4
  %or4 = or i32 %6, %shr3
  store i32 %or4, ptr %v.addr, align 4
  %7 = load i32, ptr %v.addr, align 4
  %shr5 = ashr i32 %7, 8
  %8 = load i32, ptr %v.addr, align 4
  %or6 = or i32 %8, %shr5
  store i32 %or6, ptr %v.addr, align 4
  %9 = load i32, ptr %v.addr, align 4
  %shr7 = ashr i32 %9, 16
  %10 = load i32, ptr %v.addr, align 4
  %or8 = or i32 %10, %shr7
  store i32 %or8, ptr %v.addr, align 4
  %11 = load i32, ptr %v.addr, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, ptr %v.addr, align 4
  %12 = load i32, ptr %v.addr, align 4
  ret i32 %12
}

; Function Attrs: mustprogress uwtable
define internal noundef i32 @_ZL35stbtt_PackFontRangesRenderIntoRectsP18stbtt_pack_contextPK14stbtt_fontinfoP16stbtt_pack_rangeiP10stbrp_rect(ptr noundef %spc, ptr noundef %info, ptr noundef %ranges, i32 noundef %num_ranges, ptr noundef %rects) #4 {
entry:
  %spc.addr = alloca ptr, align 8
  %info.addr = alloca ptr, align 8
  %ranges.addr = alloca ptr, align 8
  %num_ranges.addr = alloca i32, align 4
  %rects.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %k = alloca i32, align 4
  %missing_glyph = alloca i32, align 4
  %return_value = alloca i32, align 4
  %old_h_over = alloca i32, align 4
  %old_v_over = alloca i32, align 4
  %fh = alloca float, align 4
  %scale = alloca float, align 4
  %recip_h = alloca float, align 4
  %recip_v = alloca float, align 4
  %sub_x = alloca float, align 4
  %sub_y = alloca float, align 4
  %r = alloca ptr, align 8
  %bc = alloca ptr, align 8
  %advance = alloca i32, align 4
  %lsb = alloca i32, align 4
  %x0 = alloca i32, align 4
  %y0 = alloca i32, align 4
  %x1 = alloca i32, align 4
  %y1 = alloca i32, align 4
  %codepoint = alloca i32, align 4
  %glyph = alloca i32, align 4
  %pad = alloca i32, align 4
  store ptr %spc, ptr %spc.addr, align 8
  store ptr %info, ptr %info.addr, align 8
  store ptr %ranges, ptr %ranges.addr, align 8
  store i32 %num_ranges, ptr %num_ranges.addr, align 4
  store ptr %rects, ptr %rects.addr, align 8
  store i32 -1, ptr %missing_glyph, align 4
  store i32 1, ptr %return_value, align 4
  %0 = load ptr, ptr %spc.addr, align 8
  %h_oversample = getelementptr inbounds %struct.stbtt_pack_context, ptr %0, i32 0, i32 7
  %1 = load i32, ptr %h_oversample, align 4
  store i32 %1, ptr %old_h_over, align 4
  %2 = load ptr, ptr %spc.addr, align 8
  %v_oversample = getelementptr inbounds %struct.stbtt_pack_context, ptr %2, i32 0, i32 8
  %3 = load i32, ptr %v_oversample, align 8
  store i32 %3, ptr %old_v_over, align 4
  store i32 0, ptr %k, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc175, %entry
  %4 = load i32, ptr %i, align 4
  %5 = load i32, ptr %num_ranges.addr, align 4
  %cmp = icmp slt i32 %4, %5
  br i1 %cmp, label %for.body, label %for.end177

for.body:                                         ; preds = %for.cond
  %6 = load ptr, ptr %ranges.addr, align 8
  %7 = load i32, ptr %i, align 4
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr inbounds %struct.stbtt_pack_range, ptr %6, i64 %idxprom
  %font_size = getelementptr inbounds %struct.stbtt_pack_range, ptr %arrayidx, i32 0, i32 0
  %8 = load float, ptr %font_size, align 8
  store float %8, ptr %fh, align 4
  %9 = load float, ptr %fh, align 4
  %cmp1 = fcmp ogt float %9, 0.000000e+00
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %10 = load ptr, ptr %info.addr, align 8
  %11 = load float, ptr %fh, align 4
  %call = call noundef float @_ZL25stbtt_ScaleForPixelHeightPK14stbtt_fontinfof(ptr noundef %10, float noundef %11)
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %12 = load ptr, ptr %info.addr, align 8
  %13 = load float, ptr %fh, align 4
  %fneg = fneg float %13
  %call2 = call noundef float @_ZL31stbtt_ScaleForMappingEmToPixelsPK14stbtt_fontinfof(ptr noundef %12, float noundef %fneg)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %call, %cond.true ], [ %call2, %cond.false ]
  store float %cond, ptr %scale, align 4
  %14 = load ptr, ptr %ranges.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idxprom3 = sext i32 %15 to i64
  %arrayidx4 = getelementptr inbounds %struct.stbtt_pack_range, ptr %14, i64 %idxprom3
  %h_oversample5 = getelementptr inbounds %struct.stbtt_pack_range, ptr %arrayidx4, i32 0, i32 5
  %16 = load i8, ptr %h_oversample5, align 8
  %conv = zext i8 %16 to i32
  %17 = load ptr, ptr %spc.addr, align 8
  %h_oversample6 = getelementptr inbounds %struct.stbtt_pack_context, ptr %17, i32 0, i32 7
  store i32 %conv, ptr %h_oversample6, align 4
  %18 = load ptr, ptr %ranges.addr, align 8
  %19 = load i32, ptr %i, align 4
  %idxprom7 = sext i32 %19 to i64
  %arrayidx8 = getelementptr inbounds %struct.stbtt_pack_range, ptr %18, i64 %idxprom7
  %v_oversample9 = getelementptr inbounds %struct.stbtt_pack_range, ptr %arrayidx8, i32 0, i32 6
  %20 = load i8, ptr %v_oversample9, align 1
  %conv10 = zext i8 %20 to i32
  %21 = load ptr, ptr %spc.addr, align 8
  %v_oversample11 = getelementptr inbounds %struct.stbtt_pack_context, ptr %21, i32 0, i32 8
  store i32 %conv10, ptr %v_oversample11, align 8
  %22 = load ptr, ptr %spc.addr, align 8
  %h_oversample12 = getelementptr inbounds %struct.stbtt_pack_context, ptr %22, i32 0, i32 7
  %23 = load i32, ptr %h_oversample12, align 4
  %conv13 = uitofp i32 %23 to float
  %div = fdiv float 1.000000e+00, %conv13
  store float %div, ptr %recip_h, align 4
  %24 = load ptr, ptr %spc.addr, align 8
  %v_oversample14 = getelementptr inbounds %struct.stbtt_pack_context, ptr %24, i32 0, i32 8
  %25 = load i32, ptr %v_oversample14, align 8
  %conv15 = uitofp i32 %25 to float
  %div16 = fdiv float 1.000000e+00, %conv15
  store float %div16, ptr %recip_v, align 4
  %26 = load ptr, ptr %spc.addr, align 8
  %h_oversample17 = getelementptr inbounds %struct.stbtt_pack_context, ptr %26, i32 0, i32 7
  %27 = load i32, ptr %h_oversample17, align 4
  %call18 = call noundef float @_ZL23stbtt__oversample_shifti(i32 noundef %27)
  store float %call18, ptr %sub_x, align 4
  %28 = load ptr, ptr %spc.addr, align 8
  %v_oversample19 = getelementptr inbounds %struct.stbtt_pack_context, ptr %28, i32 0, i32 8
  %29 = load i32, ptr %v_oversample19, align 8
  %call20 = call noundef float @_ZL23stbtt__oversample_shifti(i32 noundef %29)
  store float %call20, ptr %sub_y, align 4
  store i32 0, ptr %j, align 4
  br label %for.cond21

for.cond21:                                       ; preds = %for.inc, %cond.end
  %30 = load i32, ptr %j, align 4
  %31 = load ptr, ptr %ranges.addr, align 8
  %32 = load i32, ptr %i, align 4
  %idxprom22 = sext i32 %32 to i64
  %arrayidx23 = getelementptr inbounds %struct.stbtt_pack_range, ptr %31, i64 %idxprom22
  %num_chars = getelementptr inbounds %struct.stbtt_pack_range, ptr %arrayidx23, i32 0, i32 3
  %33 = load i32, ptr %num_chars, align 8
  %cmp24 = icmp slt i32 %30, %33
  br i1 %cmp24, label %for.body25, label %for.end

for.body25:                                       ; preds = %for.cond21
  %34 = load ptr, ptr %rects.addr, align 8
  %35 = load i32, ptr %k, align 4
  %idxprom26 = sext i32 %35 to i64
  %arrayidx27 = getelementptr inbounds %struct.stbrp_rect, ptr %34, i64 %idxprom26
  store ptr %arrayidx27, ptr %r, align 8
  %36 = load ptr, ptr %r, align 8
  %was_packed = getelementptr inbounds %struct.stbrp_rect, ptr %36, i32 0, i32 5
  %37 = load i32, ptr %was_packed, align 4
  %tobool = icmp ne i32 %37, 0
  br i1 %tobool, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %for.body25
  %38 = load ptr, ptr %r, align 8
  %w = getelementptr inbounds %struct.stbrp_rect, ptr %38, i32 0, i32 1
  %39 = load i32, ptr %w, align 4
  %cmp28 = icmp ne i32 %39, 0
  br i1 %cmp28, label %land.lhs.true29, label %if.else

land.lhs.true29:                                  ; preds = %land.lhs.true
  %40 = load ptr, ptr %r, align 8
  %h = getelementptr inbounds %struct.stbrp_rect, ptr %40, i32 0, i32 2
  %41 = load i32, ptr %h, align 4
  %cmp30 = icmp ne i32 %41, 0
  br i1 %cmp30, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true29
  %42 = load ptr, ptr %ranges.addr, align 8
  %43 = load i32, ptr %i, align 4
  %idxprom31 = sext i32 %43 to i64
  %arrayidx32 = getelementptr inbounds %struct.stbtt_pack_range, ptr %42, i64 %idxprom31
  %chardata_for_range = getelementptr inbounds %struct.stbtt_pack_range, ptr %arrayidx32, i32 0, i32 4
  %44 = load ptr, ptr %chardata_for_range, align 8
  %45 = load i32, ptr %j, align 4
  %idxprom33 = sext i32 %45 to i64
  %arrayidx34 = getelementptr inbounds %struct.stbtt_packedchar, ptr %44, i64 %idxprom33
  store ptr %arrayidx34, ptr %bc, align 8
  %46 = load ptr, ptr %ranges.addr, align 8
  %47 = load i32, ptr %i, align 4
  %idxprom35 = sext i32 %47 to i64
  %arrayidx36 = getelementptr inbounds %struct.stbtt_pack_range, ptr %46, i64 %idxprom35
  %array_of_unicode_codepoints = getelementptr inbounds %struct.stbtt_pack_range, ptr %arrayidx36, i32 0, i32 2
  %48 = load ptr, ptr %array_of_unicode_codepoints, align 8
  %cmp37 = icmp eq ptr %48, null
  br i1 %cmp37, label %cond.true38, label %cond.false41

cond.true38:                                      ; preds = %if.then
  %49 = load ptr, ptr %ranges.addr, align 8
  %50 = load i32, ptr %i, align 4
  %idxprom39 = sext i32 %50 to i64
  %arrayidx40 = getelementptr inbounds %struct.stbtt_pack_range, ptr %49, i64 %idxprom39
  %first_unicode_codepoint_in_range = getelementptr inbounds %struct.stbtt_pack_range, ptr %arrayidx40, i32 0, i32 1
  %51 = load i32, ptr %first_unicode_codepoint_in_range, align 4
  %52 = load i32, ptr %j, align 4
  %add = add nsw i32 %51, %52
  br label %cond.end47

cond.false41:                                     ; preds = %if.then
  %53 = load ptr, ptr %ranges.addr, align 8
  %54 = load i32, ptr %i, align 4
  %idxprom42 = sext i32 %54 to i64
  %arrayidx43 = getelementptr inbounds %struct.stbtt_pack_range, ptr %53, i64 %idxprom42
  %array_of_unicode_codepoints44 = getelementptr inbounds %struct.stbtt_pack_range, ptr %arrayidx43, i32 0, i32 2
  %55 = load ptr, ptr %array_of_unicode_codepoints44, align 8
  %56 = load i32, ptr %j, align 4
  %idxprom45 = sext i32 %56 to i64
  %arrayidx46 = getelementptr inbounds i32, ptr %55, i64 %idxprom45
  %57 = load i32, ptr %arrayidx46, align 4
  br label %cond.end47

cond.end47:                                       ; preds = %cond.false41, %cond.true38
  %cond48 = phi i32 [ %add, %cond.true38 ], [ %57, %cond.false41 ]
  store i32 %cond48, ptr %codepoint, align 4
  %58 = load ptr, ptr %info.addr, align 8
  %59 = load i32, ptr %codepoint, align 4
  %call49 = call noundef i32 @_ZL20stbtt_FindGlyphIndexPK14stbtt_fontinfoi(ptr noundef %58, i32 noundef %59)
  store i32 %call49, ptr %glyph, align 4
  %60 = load ptr, ptr %spc.addr, align 8
  %padding = getelementptr inbounds %struct.stbtt_pack_context, ptr %60, i32 0, i32 5
  %61 = load i32, ptr %padding, align 4
  store i32 %61, ptr %pad, align 4
  %62 = load i32, ptr %pad, align 4
  %63 = load ptr, ptr %r, align 8
  %x = getelementptr inbounds %struct.stbrp_rect, ptr %63, i32 0, i32 3
  %64 = load i32, ptr %x, align 4
  %add50 = add nsw i32 %64, %62
  store i32 %add50, ptr %x, align 4
  %65 = load i32, ptr %pad, align 4
  %66 = load ptr, ptr %r, align 8
  %y = getelementptr inbounds %struct.stbrp_rect, ptr %66, i32 0, i32 4
  %67 = load i32, ptr %y, align 4
  %add51 = add nsw i32 %67, %65
  store i32 %add51, ptr %y, align 4
  %68 = load i32, ptr %pad, align 4
  %69 = load ptr, ptr %r, align 8
  %w52 = getelementptr inbounds %struct.stbrp_rect, ptr %69, i32 0, i32 1
  %70 = load i32, ptr %w52, align 4
  %sub = sub nsw i32 %70, %68
  store i32 %sub, ptr %w52, align 4
  %71 = load i32, ptr %pad, align 4
  %72 = load ptr, ptr %r, align 8
  %h53 = getelementptr inbounds %struct.stbrp_rect, ptr %72, i32 0, i32 2
  %73 = load i32, ptr %h53, align 4
  %sub54 = sub nsw i32 %73, %71
  store i32 %sub54, ptr %h53, align 4
  %74 = load ptr, ptr %info.addr, align 8
  %75 = load i32, ptr %glyph, align 4
  call void @_ZL22stbtt_GetGlyphHMetricsPK14stbtt_fontinfoiPiS2_(ptr noundef %74, i32 noundef %75, ptr noundef %advance, ptr noundef %lsb)
  %76 = load ptr, ptr %info.addr, align 8
  %77 = load i32, ptr %glyph, align 4
  %78 = load float, ptr %scale, align 4
  %79 = load ptr, ptr %spc.addr, align 8
  %h_oversample55 = getelementptr inbounds %struct.stbtt_pack_context, ptr %79, i32 0, i32 7
  %80 = load i32, ptr %h_oversample55, align 4
  %conv56 = uitofp i32 %80 to float
  %mul = fmul float %78, %conv56
  %81 = load float, ptr %scale, align 4
  %82 = load ptr, ptr %spc.addr, align 8
  %v_oversample57 = getelementptr inbounds %struct.stbtt_pack_context, ptr %82, i32 0, i32 8
  %83 = load i32, ptr %v_oversample57, align 8
  %conv58 = uitofp i32 %83 to float
  %mul59 = fmul float %81, %conv58
  call void @_ZL23stbtt_GetGlyphBitmapBoxPK14stbtt_fontinfoiffPiS2_S2_S2_(ptr noundef %76, i32 noundef %77, float noundef %mul, float noundef %mul59, ptr noundef %x0, ptr noundef %y0, ptr noundef %x1, ptr noundef %y1)
  %84 = load ptr, ptr %info.addr, align 8
  %85 = load ptr, ptr %spc.addr, align 8
  %pixels = getelementptr inbounds %struct.stbtt_pack_context, ptr %85, i32 0, i32 9
  %86 = load ptr, ptr %pixels, align 8
  %87 = load ptr, ptr %r, align 8
  %x60 = getelementptr inbounds %struct.stbrp_rect, ptr %87, i32 0, i32 3
  %88 = load i32, ptr %x60, align 4
  %idx.ext = sext i32 %88 to i64
  %add.ptr = getelementptr inbounds i8, ptr %86, i64 %idx.ext
  %89 = load ptr, ptr %r, align 8
  %y61 = getelementptr inbounds %struct.stbrp_rect, ptr %89, i32 0, i32 4
  %90 = load i32, ptr %y61, align 4
  %91 = load ptr, ptr %spc.addr, align 8
  %stride_in_bytes = getelementptr inbounds %struct.stbtt_pack_context, ptr %91, i32 0, i32 4
  %92 = load i32, ptr %stride_in_bytes, align 8
  %mul62 = mul nsw i32 %90, %92
  %idx.ext63 = sext i32 %mul62 to i64
  %add.ptr64 = getelementptr inbounds i8, ptr %add.ptr, i64 %idx.ext63
  %93 = load ptr, ptr %r, align 8
  %w65 = getelementptr inbounds %struct.stbrp_rect, ptr %93, i32 0, i32 1
  %94 = load i32, ptr %w65, align 4
  %95 = load ptr, ptr %spc.addr, align 8
  %h_oversample66 = getelementptr inbounds %struct.stbtt_pack_context, ptr %95, i32 0, i32 7
  %96 = load i32, ptr %h_oversample66, align 4
  %sub67 = sub i32 %94, %96
  %add68 = add i32 %sub67, 1
  %97 = load ptr, ptr %r, align 8
  %h69 = getelementptr inbounds %struct.stbrp_rect, ptr %97, i32 0, i32 2
  %98 = load i32, ptr %h69, align 4
  %99 = load ptr, ptr %spc.addr, align 8
  %v_oversample70 = getelementptr inbounds %struct.stbtt_pack_context, ptr %99, i32 0, i32 8
  %100 = load i32, ptr %v_oversample70, align 8
  %sub71 = sub i32 %98, %100
  %add72 = add i32 %sub71, 1
  %101 = load ptr, ptr %spc.addr, align 8
  %stride_in_bytes73 = getelementptr inbounds %struct.stbtt_pack_context, ptr %101, i32 0, i32 4
  %102 = load i32, ptr %stride_in_bytes73, align 8
  %103 = load float, ptr %scale, align 4
  %104 = load ptr, ptr %spc.addr, align 8
  %h_oversample74 = getelementptr inbounds %struct.stbtt_pack_context, ptr %104, i32 0, i32 7
  %105 = load i32, ptr %h_oversample74, align 4
  %conv75 = uitofp i32 %105 to float
  %mul76 = fmul float %103, %conv75
  %106 = load float, ptr %scale, align 4
  %107 = load ptr, ptr %spc.addr, align 8
  %v_oversample77 = getelementptr inbounds %struct.stbtt_pack_context, ptr %107, i32 0, i32 8
  %108 = load i32, ptr %v_oversample77, align 8
  %conv78 = uitofp i32 %108 to float
  %mul79 = fmul float %106, %conv78
  %109 = load i32, ptr %glyph, align 4
  call void @_ZL29stbtt_MakeGlyphBitmapSubpixelPK14stbtt_fontinfoPhiiiffffi(ptr noundef %84, ptr noundef %add.ptr64, i32 noundef %add68, i32 noundef %add72, i32 noundef %102, float noundef %mul76, float noundef %mul79, float noundef 0.000000e+00, float noundef 0.000000e+00, i32 noundef %109)
  %110 = load ptr, ptr %spc.addr, align 8
  %h_oversample80 = getelementptr inbounds %struct.stbtt_pack_context, ptr %110, i32 0, i32 7
  %111 = load i32, ptr %h_oversample80, align 4
  %cmp81 = icmp ugt i32 %111, 1
  br i1 %cmp81, label %if.then82, label %if.end

if.then82:                                        ; preds = %cond.end47
  %112 = load ptr, ptr %spc.addr, align 8
  %pixels83 = getelementptr inbounds %struct.stbtt_pack_context, ptr %112, i32 0, i32 9
  %113 = load ptr, ptr %pixels83, align 8
  %114 = load ptr, ptr %r, align 8
  %x84 = getelementptr inbounds %struct.stbrp_rect, ptr %114, i32 0, i32 3
  %115 = load i32, ptr %x84, align 4
  %idx.ext85 = sext i32 %115 to i64
  %add.ptr86 = getelementptr inbounds i8, ptr %113, i64 %idx.ext85
  %116 = load ptr, ptr %r, align 8
  %y87 = getelementptr inbounds %struct.stbrp_rect, ptr %116, i32 0, i32 4
  %117 = load i32, ptr %y87, align 4
  %118 = load ptr, ptr %spc.addr, align 8
  %stride_in_bytes88 = getelementptr inbounds %struct.stbtt_pack_context, ptr %118, i32 0, i32 4
  %119 = load i32, ptr %stride_in_bytes88, align 8
  %mul89 = mul nsw i32 %117, %119
  %idx.ext90 = sext i32 %mul89 to i64
  %add.ptr91 = getelementptr inbounds i8, ptr %add.ptr86, i64 %idx.ext90
  %120 = load ptr, ptr %r, align 8
  %w92 = getelementptr inbounds %struct.stbrp_rect, ptr %120, i32 0, i32 1
  %121 = load i32, ptr %w92, align 4
  %122 = load ptr, ptr %r, align 8
  %h93 = getelementptr inbounds %struct.stbrp_rect, ptr %122, i32 0, i32 2
  %123 = load i32, ptr %h93, align 4
  %124 = load ptr, ptr %spc.addr, align 8
  %stride_in_bytes94 = getelementptr inbounds %struct.stbtt_pack_context, ptr %124, i32 0, i32 4
  %125 = load i32, ptr %stride_in_bytes94, align 8
  %126 = load ptr, ptr %spc.addr, align 8
  %h_oversample95 = getelementptr inbounds %struct.stbtt_pack_context, ptr %126, i32 0, i32 7
  %127 = load i32, ptr %h_oversample95, align 4
  call void @_ZL18stbtt__h_prefilterPhiiij(ptr noundef %add.ptr91, i32 noundef %121, i32 noundef %123, i32 noundef %125, i32 noundef %127)
  br label %if.end

if.end:                                           ; preds = %if.then82, %cond.end47
  %128 = load ptr, ptr %spc.addr, align 8
  %v_oversample96 = getelementptr inbounds %struct.stbtt_pack_context, ptr %128, i32 0, i32 8
  %129 = load i32, ptr %v_oversample96, align 8
  %cmp97 = icmp ugt i32 %129, 1
  br i1 %cmp97, label %if.then98, label %if.end112

if.then98:                                        ; preds = %if.end
  %130 = load ptr, ptr %spc.addr, align 8
  %pixels99 = getelementptr inbounds %struct.stbtt_pack_context, ptr %130, i32 0, i32 9
  %131 = load ptr, ptr %pixels99, align 8
  %132 = load ptr, ptr %r, align 8
  %x100 = getelementptr inbounds %struct.stbrp_rect, ptr %132, i32 0, i32 3
  %133 = load i32, ptr %x100, align 4
  %idx.ext101 = sext i32 %133 to i64
  %add.ptr102 = getelementptr inbounds i8, ptr %131, i64 %idx.ext101
  %134 = load ptr, ptr %r, align 8
  %y103 = getelementptr inbounds %struct.stbrp_rect, ptr %134, i32 0, i32 4
  %135 = load i32, ptr %y103, align 4
  %136 = load ptr, ptr %spc.addr, align 8
  %stride_in_bytes104 = getelementptr inbounds %struct.stbtt_pack_context, ptr %136, i32 0, i32 4
  %137 = load i32, ptr %stride_in_bytes104, align 8
  %mul105 = mul nsw i32 %135, %137
  %idx.ext106 = sext i32 %mul105 to i64
  %add.ptr107 = getelementptr inbounds i8, ptr %add.ptr102, i64 %idx.ext106
  %138 = load ptr, ptr %r, align 8
  %w108 = getelementptr inbounds %struct.stbrp_rect, ptr %138, i32 0, i32 1
  %139 = load i32, ptr %w108, align 4
  %140 = load ptr, ptr %r, align 8
  %h109 = getelementptr inbounds %struct.stbrp_rect, ptr %140, i32 0, i32 2
  %141 = load i32, ptr %h109, align 4
  %142 = load ptr, ptr %spc.addr, align 8
  %stride_in_bytes110 = getelementptr inbounds %struct.stbtt_pack_context, ptr %142, i32 0, i32 4
  %143 = load i32, ptr %stride_in_bytes110, align 8
  %144 = load ptr, ptr %spc.addr, align 8
  %v_oversample111 = getelementptr inbounds %struct.stbtt_pack_context, ptr %144, i32 0, i32 8
  %145 = load i32, ptr %v_oversample111, align 8
  call void @_ZL18stbtt__v_prefilterPhiiij(ptr noundef %add.ptr107, i32 noundef %139, i32 noundef %141, i32 noundef %143, i32 noundef %145)
  br label %if.end112

if.end112:                                        ; preds = %if.then98, %if.end
  %146 = load ptr, ptr %r, align 8
  %x113 = getelementptr inbounds %struct.stbrp_rect, ptr %146, i32 0, i32 3
  %147 = load i32, ptr %x113, align 4
  %conv114 = trunc i32 %147 to i16
  %148 = load ptr, ptr %bc, align 8
  %x0115 = getelementptr inbounds %struct.stbtt_packedchar, ptr %148, i32 0, i32 0
  store i16 %conv114, ptr %x0115, align 4
  %149 = load ptr, ptr %r, align 8
  %y116 = getelementptr inbounds %struct.stbrp_rect, ptr %149, i32 0, i32 4
  %150 = load i32, ptr %y116, align 4
  %conv117 = trunc i32 %150 to i16
  %151 = load ptr, ptr %bc, align 8
  %y0118 = getelementptr inbounds %struct.stbtt_packedchar, ptr %151, i32 0, i32 1
  store i16 %conv117, ptr %y0118, align 2
  %152 = load ptr, ptr %r, align 8
  %x119 = getelementptr inbounds %struct.stbrp_rect, ptr %152, i32 0, i32 3
  %153 = load i32, ptr %x119, align 4
  %154 = load ptr, ptr %r, align 8
  %w120 = getelementptr inbounds %struct.stbrp_rect, ptr %154, i32 0, i32 1
  %155 = load i32, ptr %w120, align 4
  %add121 = add nsw i32 %153, %155
  %conv122 = trunc i32 %add121 to i16
  %156 = load ptr, ptr %bc, align 8
  %x1123 = getelementptr inbounds %struct.stbtt_packedchar, ptr %156, i32 0, i32 2
  store i16 %conv122, ptr %x1123, align 4
  %157 = load ptr, ptr %r, align 8
  %y124 = getelementptr inbounds %struct.stbrp_rect, ptr %157, i32 0, i32 4
  %158 = load i32, ptr %y124, align 4
  %159 = load ptr, ptr %r, align 8
  %h125 = getelementptr inbounds %struct.stbrp_rect, ptr %159, i32 0, i32 2
  %160 = load i32, ptr %h125, align 4
  %add126 = add nsw i32 %158, %160
  %conv127 = trunc i32 %add126 to i16
  %161 = load ptr, ptr %bc, align 8
  %y1128 = getelementptr inbounds %struct.stbtt_packedchar, ptr %161, i32 0, i32 3
  store i16 %conv127, ptr %y1128, align 2
  %162 = load float, ptr %scale, align 4
  %163 = load i32, ptr %advance, align 4
  %conv129 = sitofp i32 %163 to float
  %mul130 = fmul float %162, %conv129
  %164 = load ptr, ptr %bc, align 8
  %xadvance = getelementptr inbounds %struct.stbtt_packedchar, ptr %164, i32 0, i32 6
  store float %mul130, ptr %xadvance, align 4
  %165 = load i32, ptr %x0, align 4
  %conv131 = sitofp i32 %165 to float
  %166 = load float, ptr %recip_h, align 4
  %167 = load float, ptr %sub_x, align 4
  %168 = call float @llvm.fmuladd.f32(float %conv131, float %166, float %167)
  %169 = load ptr, ptr %bc, align 8
  %xoff = getelementptr inbounds %struct.stbtt_packedchar, ptr %169, i32 0, i32 4
  store float %168, ptr %xoff, align 4
  %170 = load i32, ptr %y0, align 4
  %conv133 = sitofp i32 %170 to float
  %171 = load float, ptr %recip_v, align 4
  %172 = load float, ptr %sub_y, align 4
  %173 = call float @llvm.fmuladd.f32(float %conv133, float %171, float %172)
  %174 = load ptr, ptr %bc, align 8
  %yoff = getelementptr inbounds %struct.stbtt_packedchar, ptr %174, i32 0, i32 5
  store float %173, ptr %yoff, align 4
  %175 = load i32, ptr %x0, align 4
  %176 = load ptr, ptr %r, align 8
  %w135 = getelementptr inbounds %struct.stbrp_rect, ptr %176, i32 0, i32 1
  %177 = load i32, ptr %w135, align 4
  %add136 = add nsw i32 %175, %177
  %conv137 = sitofp i32 %add136 to float
  %178 = load float, ptr %recip_h, align 4
  %179 = load float, ptr %sub_x, align 4
  %180 = call float @llvm.fmuladd.f32(float %conv137, float %178, float %179)
  %181 = load ptr, ptr %bc, align 8
  %xoff2 = getelementptr inbounds %struct.stbtt_packedchar, ptr %181, i32 0, i32 7
  store float %180, ptr %xoff2, align 4
  %182 = load i32, ptr %y0, align 4
  %183 = load ptr, ptr %r, align 8
  %h139 = getelementptr inbounds %struct.stbrp_rect, ptr %183, i32 0, i32 2
  %184 = load i32, ptr %h139, align 4
  %add140 = add nsw i32 %182, %184
  %conv141 = sitofp i32 %add140 to float
  %185 = load float, ptr %recip_v, align 4
  %186 = load float, ptr %sub_y, align 4
  %187 = call float @llvm.fmuladd.f32(float %conv141, float %185, float %186)
  %188 = load ptr, ptr %bc, align 8
  %yoff2 = getelementptr inbounds %struct.stbtt_packedchar, ptr %188, i32 0, i32 8
  store float %187, ptr %yoff2, align 4
  %189 = load i32, ptr %glyph, align 4
  %cmp143 = icmp eq i32 %189, 0
  br i1 %cmp143, label %if.then144, label %if.end145

if.then144:                                       ; preds = %if.end112
  %190 = load i32, ptr %j, align 4
  store i32 %190, ptr %missing_glyph, align 4
  br label %if.end145

if.end145:                                        ; preds = %if.then144, %if.end112
  br label %if.end173

if.else:                                          ; preds = %land.lhs.true29, %land.lhs.true, %for.body25
  %191 = load ptr, ptr %spc.addr, align 8
  %skip_missing = getelementptr inbounds %struct.stbtt_pack_context, ptr %191, i32 0, i32 6
  %192 = load i32, ptr %skip_missing, align 8
  %tobool146 = icmp ne i32 %192, 0
  br i1 %tobool146, label %if.then147, label %if.else148

if.then147:                                       ; preds = %if.else
  store i32 0, ptr %return_value, align 4
  br label %if.end172

if.else148:                                       ; preds = %if.else
  %193 = load ptr, ptr %r, align 8
  %was_packed149 = getelementptr inbounds %struct.stbrp_rect, ptr %193, i32 0, i32 5
  %194 = load i32, ptr %was_packed149, align 4
  %tobool150 = icmp ne i32 %194, 0
  br i1 %tobool150, label %land.lhs.true151, label %if.else170

land.lhs.true151:                                 ; preds = %if.else148
  %195 = load ptr, ptr %r, align 8
  %w152 = getelementptr inbounds %struct.stbrp_rect, ptr %195, i32 0, i32 1
  %196 = load i32, ptr %w152, align 4
  %cmp153 = icmp eq i32 %196, 0
  br i1 %cmp153, label %land.lhs.true154, label %if.else170

land.lhs.true154:                                 ; preds = %land.lhs.true151
  %197 = load ptr, ptr %r, align 8
  %h155 = getelementptr inbounds %struct.stbrp_rect, ptr %197, i32 0, i32 2
  %198 = load i32, ptr %h155, align 4
  %cmp156 = icmp eq i32 %198, 0
  br i1 %cmp156, label %land.lhs.true157, label %if.else170

land.lhs.true157:                                 ; preds = %land.lhs.true154
  %199 = load i32, ptr %missing_glyph, align 4
  %cmp158 = icmp sge i32 %199, 0
  br i1 %cmp158, label %if.then159, label %if.else170

if.then159:                                       ; preds = %land.lhs.true157
  %200 = load ptr, ptr %ranges.addr, align 8
  %201 = load i32, ptr %i, align 4
  %idxprom160 = sext i32 %201 to i64
  %arrayidx161 = getelementptr inbounds %struct.stbtt_pack_range, ptr %200, i64 %idxprom160
  %chardata_for_range162 = getelementptr inbounds %struct.stbtt_pack_range, ptr %arrayidx161, i32 0, i32 4
  %202 = load ptr, ptr %chardata_for_range162, align 8
  %203 = load i32, ptr %missing_glyph, align 4
  %idxprom163 = sext i32 %203 to i64
  %arrayidx164 = getelementptr inbounds %struct.stbtt_packedchar, ptr %202, i64 %idxprom163
  %204 = load ptr, ptr %ranges.addr, align 8
  %205 = load i32, ptr %i, align 4
  %idxprom165 = sext i32 %205 to i64
  %arrayidx166 = getelementptr inbounds %struct.stbtt_pack_range, ptr %204, i64 %idxprom165
  %chardata_for_range167 = getelementptr inbounds %struct.stbtt_pack_range, ptr %arrayidx166, i32 0, i32 4
  %206 = load ptr, ptr %chardata_for_range167, align 8
  %207 = load i32, ptr %j, align 4
  %idxprom168 = sext i32 %207 to i64
  %arrayidx169 = getelementptr inbounds %struct.stbtt_packedchar, ptr %206, i64 %idxprom168
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx169, ptr align 4 %arrayidx164, i64 28, i1 false)
  br label %if.end171

if.else170:                                       ; preds = %land.lhs.true157, %land.lhs.true154, %land.lhs.true151, %if.else148
  store i32 0, ptr %return_value, align 4
  br label %if.end171

if.end171:                                        ; preds = %if.else170, %if.then159
  br label %if.end172

if.end172:                                        ; preds = %if.end171, %if.then147
  br label %if.end173

if.end173:                                        ; preds = %if.end172, %if.end145
  %208 = load i32, ptr %k, align 4
  %inc = add nsw i32 %208, 1
  store i32 %inc, ptr %k, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end173
  %209 = load i32, ptr %j, align 4
  %inc174 = add nsw i32 %209, 1
  store i32 %inc174, ptr %j, align 4
  br label %for.cond21, !llvm.loop !103

for.end:                                          ; preds = %for.cond21
  br label %for.inc175

for.inc175:                                       ; preds = %for.end
  %210 = load i32, ptr %i, align 4
  %inc176 = add nsw i32 %210, 1
  store i32 %inc176, ptr %i, align 4
  br label %for.cond, !llvm.loop !104

for.end177:                                       ; preds = %for.cond
  %211 = load i32, ptr %old_h_over, align 4
  %212 = load ptr, ptr %spc.addr, align 8
  %h_oversample178 = getelementptr inbounds %struct.stbtt_pack_context, ptr %212, i32 0, i32 7
  store i32 %211, ptr %h_oversample178, align 4
  %213 = load i32, ptr %old_v_over, align 4
  %214 = load ptr, ptr %spc.addr, align 8
  %v_oversample179 = getelementptr inbounds %struct.stbtt_pack_context, ptr %214, i32 0, i32 8
  store i32 %213, ptr %v_oversample179, align 8
  %215 = load i32, ptr %return_value, align 4
  ret i32 %215
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL13stbtt_PackEndP18stbtt_pack_context(ptr noundef %spc) #4 {
entry:
  %spc.addr = alloca ptr, align 8
  store ptr %spc, ptr %spc.addr, align 8
  %0 = load ptr, ptr %spc.addr, align 8
  %nodes = getelementptr inbounds %struct.stbtt_pack_context, ptr %0, i32 0, i32 10
  %1 = load ptr, ptr %nodes, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
  %2 = load ptr, ptr %spc.addr, align 8
  %pack_info = getelementptr inbounds %struct.stbtt_pack_context, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %pack_info, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %3)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI10stbrp_rectE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.12, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Capacity = getelementptr inbounds %struct.ImVector.12, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.12, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data2 = getelementptr inbounds %struct.ImVector.12, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
  %Data3 = getelementptr inbounds %struct.ImVector.12, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZL21stbtt_GetFontVMetricsPK14stbtt_fontinfoPiS2_S2_(ptr noundef %info, ptr noundef %ascent, ptr noundef %descent, ptr noundef %lineGap) #2 {
entry:
  %info.addr = alloca ptr, align 8
  %ascent.addr = alloca ptr, align 8
  %descent.addr = alloca ptr, align 8
  %lineGap.addr = alloca ptr, align 8
  store ptr %info, ptr %info.addr, align 8
  store ptr %ascent, ptr %ascent.addr, align 8
  store ptr %descent, ptr %descent.addr, align 8
  store ptr %lineGap, ptr %lineGap.addr, align 8
  %0 = load ptr, ptr %ascent.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %info.addr, align 8
  %data = getelementptr inbounds %struct.stbtt_fontinfo, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %data, align 8
  %3 = load ptr, ptr %info.addr, align 8
  %hhea = getelementptr inbounds %struct.stbtt_fontinfo, ptr %3, i32 0, i32 7
  %4 = load i32, ptr %hhea, align 4
  %idx.ext = sext i32 %4 to i64
  %add.ptr = getelementptr inbounds i8, ptr %2, i64 %idx.ext
  %add.ptr1 = getelementptr inbounds i8, ptr %add.ptr, i64 4
  %call = call noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %add.ptr1)
  %conv = sext i16 %call to i32
  %5 = load ptr, ptr %ascent.addr, align 8
  store i32 %conv, ptr %5, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load ptr, ptr %descent.addr, align 8
  %tobool2 = icmp ne ptr %6, null
  br i1 %tobool2, label %if.then3, label %if.end11

if.then3:                                         ; preds = %if.end
  %7 = load ptr, ptr %info.addr, align 8
  %data4 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %7, i32 0, i32 1
  %8 = load ptr, ptr %data4, align 8
  %9 = load ptr, ptr %info.addr, align 8
  %hhea5 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %9, i32 0, i32 7
  %10 = load i32, ptr %hhea5, align 4
  %idx.ext6 = sext i32 %10 to i64
  %add.ptr7 = getelementptr inbounds i8, ptr %8, i64 %idx.ext6
  %add.ptr8 = getelementptr inbounds i8, ptr %add.ptr7, i64 6
  %call9 = call noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %add.ptr8)
  %conv10 = sext i16 %call9 to i32
  %11 = load ptr, ptr %descent.addr, align 8
  store i32 %conv10, ptr %11, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then3, %if.end
  %12 = load ptr, ptr %lineGap.addr, align 8
  %tobool12 = icmp ne ptr %12, null
  br i1 %tobool12, label %if.then13, label %if.end21

if.then13:                                        ; preds = %if.end11
  %13 = load ptr, ptr %info.addr, align 8
  %data14 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %13, i32 0, i32 1
  %14 = load ptr, ptr %data14, align 8
  %15 = load ptr, ptr %info.addr, align 8
  %hhea15 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %15, i32 0, i32 7
  %16 = load i32, ptr %hhea15, align 4
  %idx.ext16 = sext i32 %16 to i64
  %add.ptr17 = getelementptr inbounds i8, ptr %14, i64 %idx.ext16
  %add.ptr18 = getelementptr inbounds i8, ptr %add.ptr17, i64 8
  %call19 = call noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %add.ptr18)
  %conv20 = sext i16 %call19 to i32
  %17 = load ptr, ptr %lineGap.addr, align 8
  store i32 %conv20, ptr %17, align 4
  br label %if.end21

if.end21:                                         ; preds = %if.then13, %if.end11
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZL19stbtt_GetPackedQuadPK16stbtt_packedchariiiPfS2_P18stbtt_aligned_quadi(ptr noundef %chardata, i32 noundef %pw, i32 noundef %ph, i32 noundef %char_index, ptr noundef %xpos, ptr noundef %ypos, ptr noundef %q, i32 noundef %align_to_integer) #2 {
entry:
  %chardata.addr = alloca ptr, align 8
  %pw.addr = alloca i32, align 4
  %ph.addr = alloca i32, align 4
  %char_index.addr = alloca i32, align 4
  %xpos.addr = alloca ptr, align 8
  %ypos.addr = alloca ptr, align 8
  %q.addr = alloca ptr, align 8
  %align_to_integer.addr = alloca i32, align 4
  %ipw = alloca float, align 4
  %iph = alloca float, align 4
  %b = alloca ptr, align 8
  %x = alloca float, align 4
  %y = alloca float, align 4
  store ptr %chardata, ptr %chardata.addr, align 8
  store i32 %pw, ptr %pw.addr, align 4
  store i32 %ph, ptr %ph.addr, align 4
  store i32 %char_index, ptr %char_index.addr, align 4
  store ptr %xpos, ptr %xpos.addr, align 8
  store ptr %ypos, ptr %ypos.addr, align 8
  store ptr %q, ptr %q.addr, align 8
  store i32 %align_to_integer, ptr %align_to_integer.addr, align 4
  %0 = load i32, ptr %pw.addr, align 4
  %conv = sitofp i32 %0 to float
  %div = fdiv float 1.000000e+00, %conv
  store float %div, ptr %ipw, align 4
  %1 = load i32, ptr %ph.addr, align 4
  %conv1 = sitofp i32 %1 to float
  %div2 = fdiv float 1.000000e+00, %conv1
  store float %div2, ptr %iph, align 4
  %2 = load ptr, ptr %chardata.addr, align 8
  %3 = load i32, ptr %char_index.addr, align 4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.stbtt_packedchar, ptr %2, i64 %idx.ext
  store ptr %add.ptr, ptr %b, align 8
  %4 = load i32, ptr %align_to_integer.addr, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = load ptr, ptr %xpos.addr, align 8
  %6 = load float, ptr %5, align 4
  %7 = load ptr, ptr %b, align 8
  %xoff = getelementptr inbounds %struct.stbtt_packedchar, ptr %7, i32 0, i32 4
  %8 = load float, ptr %xoff, align 4
  %add = fadd float %6, %8
  %add3 = fadd float %add, 5.000000e-01
  %call = call noundef float @_ZL7ImFloorf(float noundef %add3)
  %conv4 = fptosi float %call to i32
  %conv5 = sitofp i32 %conv4 to float
  store float %conv5, ptr %x, align 4
  %9 = load ptr, ptr %ypos.addr, align 8
  %10 = load float, ptr %9, align 4
  %11 = load ptr, ptr %b, align 8
  %yoff = getelementptr inbounds %struct.stbtt_packedchar, ptr %11, i32 0, i32 5
  %12 = load float, ptr %yoff, align 4
  %add6 = fadd float %10, %12
  %add7 = fadd float %add6, 5.000000e-01
  %call8 = call noundef float @_ZL7ImFloorf(float noundef %add7)
  %conv9 = fptosi float %call8 to i32
  %conv10 = sitofp i32 %conv9 to float
  store float %conv10, ptr %y, align 4
  %13 = load float, ptr %x, align 4
  %14 = load ptr, ptr %q.addr, align 8
  %x0 = getelementptr inbounds %struct.stbtt_aligned_quad, ptr %14, i32 0, i32 0
  store float %13, ptr %x0, align 4
  %15 = load float, ptr %y, align 4
  %16 = load ptr, ptr %q.addr, align 8
  %y0 = getelementptr inbounds %struct.stbtt_aligned_quad, ptr %16, i32 0, i32 1
  store float %15, ptr %y0, align 4
  %17 = load float, ptr %x, align 4
  %18 = load ptr, ptr %b, align 8
  %xoff2 = getelementptr inbounds %struct.stbtt_packedchar, ptr %18, i32 0, i32 7
  %19 = load float, ptr %xoff2, align 4
  %add11 = fadd float %17, %19
  %20 = load ptr, ptr %b, align 8
  %xoff12 = getelementptr inbounds %struct.stbtt_packedchar, ptr %20, i32 0, i32 4
  %21 = load float, ptr %xoff12, align 4
  %sub = fsub float %add11, %21
  %22 = load ptr, ptr %q.addr, align 8
  %x1 = getelementptr inbounds %struct.stbtt_aligned_quad, ptr %22, i32 0, i32 4
  store float %sub, ptr %x1, align 4
  %23 = load float, ptr %y, align 4
  %24 = load ptr, ptr %b, align 8
  %yoff2 = getelementptr inbounds %struct.stbtt_packedchar, ptr %24, i32 0, i32 8
  %25 = load float, ptr %yoff2, align 4
  %add13 = fadd float %23, %25
  %26 = load ptr, ptr %b, align 8
  %yoff14 = getelementptr inbounds %struct.stbtt_packedchar, ptr %26, i32 0, i32 5
  %27 = load float, ptr %yoff14, align 4
  %sub15 = fsub float %add13, %27
  %28 = load ptr, ptr %q.addr, align 8
  %y1 = getelementptr inbounds %struct.stbtt_aligned_quad, ptr %28, i32 0, i32 5
  store float %sub15, ptr %y1, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %29 = load ptr, ptr %xpos.addr, align 8
  %30 = load float, ptr %29, align 4
  %31 = load ptr, ptr %b, align 8
  %xoff16 = getelementptr inbounds %struct.stbtt_packedchar, ptr %31, i32 0, i32 4
  %32 = load float, ptr %xoff16, align 4
  %add17 = fadd float %30, %32
  %33 = load ptr, ptr %q.addr, align 8
  %x018 = getelementptr inbounds %struct.stbtt_aligned_quad, ptr %33, i32 0, i32 0
  store float %add17, ptr %x018, align 4
  %34 = load ptr, ptr %ypos.addr, align 8
  %35 = load float, ptr %34, align 4
  %36 = load ptr, ptr %b, align 8
  %yoff19 = getelementptr inbounds %struct.stbtt_packedchar, ptr %36, i32 0, i32 5
  %37 = load float, ptr %yoff19, align 4
  %add20 = fadd float %35, %37
  %38 = load ptr, ptr %q.addr, align 8
  %y021 = getelementptr inbounds %struct.stbtt_aligned_quad, ptr %38, i32 0, i32 1
  store float %add20, ptr %y021, align 4
  %39 = load ptr, ptr %xpos.addr, align 8
  %40 = load float, ptr %39, align 4
  %41 = load ptr, ptr %b, align 8
  %xoff222 = getelementptr inbounds %struct.stbtt_packedchar, ptr %41, i32 0, i32 7
  %42 = load float, ptr %xoff222, align 4
  %add23 = fadd float %40, %42
  %43 = load ptr, ptr %q.addr, align 8
  %x124 = getelementptr inbounds %struct.stbtt_aligned_quad, ptr %43, i32 0, i32 4
  store float %add23, ptr %x124, align 4
  %44 = load ptr, ptr %ypos.addr, align 8
  %45 = load float, ptr %44, align 4
  %46 = load ptr, ptr %b, align 8
  %yoff225 = getelementptr inbounds %struct.stbtt_packedchar, ptr %46, i32 0, i32 8
  %47 = load float, ptr %yoff225, align 4
  %add26 = fadd float %45, %47
  %48 = load ptr, ptr %q.addr, align 8
  %y127 = getelementptr inbounds %struct.stbtt_aligned_quad, ptr %48, i32 0, i32 5
  store float %add26, ptr %y127, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %49 = load ptr, ptr %b, align 8
  %x028 = getelementptr inbounds %struct.stbtt_packedchar, ptr %49, i32 0, i32 0
  %50 = load i16, ptr %x028, align 4
  %conv29 = zext i16 %50 to i32
  %conv30 = sitofp i32 %conv29 to float
  %51 = load float, ptr %ipw, align 4
  %mul = fmul float %conv30, %51
  %52 = load ptr, ptr %q.addr, align 8
  %s0 = getelementptr inbounds %struct.stbtt_aligned_quad, ptr %52, i32 0, i32 2
  store float %mul, ptr %s0, align 4
  %53 = load ptr, ptr %b, align 8
  %y031 = getelementptr inbounds %struct.stbtt_packedchar, ptr %53, i32 0, i32 1
  %54 = load i16, ptr %y031, align 2
  %conv32 = zext i16 %54 to i32
  %conv33 = sitofp i32 %conv32 to float
  %55 = load float, ptr %iph, align 4
  %mul34 = fmul float %conv33, %55
  %56 = load ptr, ptr %q.addr, align 8
  %t0 = getelementptr inbounds %struct.stbtt_aligned_quad, ptr %56, i32 0, i32 3
  store float %mul34, ptr %t0, align 4
  %57 = load ptr, ptr %b, align 8
  %x135 = getelementptr inbounds %struct.stbtt_packedchar, ptr %57, i32 0, i32 2
  %58 = load i16, ptr %x135, align 4
  %conv36 = zext i16 %58 to i32
  %conv37 = sitofp i32 %conv36 to float
  %59 = load float, ptr %ipw, align 4
  %mul38 = fmul float %conv37, %59
  %60 = load ptr, ptr %q.addr, align 8
  %s1 = getelementptr inbounds %struct.stbtt_aligned_quad, ptr %60, i32 0, i32 6
  store float %mul38, ptr %s1, align 4
  %61 = load ptr, ptr %b, align 8
  %y139 = getelementptr inbounds %struct.stbtt_packedchar, ptr %61, i32 0, i32 3
  %62 = load i16, ptr %y139, align 2
  %conv40 = zext i16 %62 to i32
  %conv41 = sitofp i32 %conv40 to float
  %63 = load float, ptr %iph, align 4
  %mul42 = fmul float %conv41, %63
  %64 = load ptr, ptr %q.addr, align 8
  %t1 = getelementptr inbounds %struct.stbtt_aligned_quad, ptr %64, i32 0, i32 7
  store float %mul42, ptr %t1, align 4
  %65 = load ptr, ptr %b, align 8
  %xadvance = getelementptr inbounds %struct.stbtt_packedchar, ptr %65, i32 0, i32 6
  %66 = load float, ptr %xadvance, align 4
  %67 = load ptr, ptr %xpos.addr, align 8
  %68 = load float, ptr %67, align 4
  %add43 = fadd float %68, %66
  store float %add43, ptr %67, align 4
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI18ImFontBuildSrcDataE14clear_destructEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  store i32 0, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %n, align 4
  %Size = getelementptr inbounds %struct.ImVector.14, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %Data = getelementptr inbounds %struct.ImVector.14, ptr %this1, i32 0, i32 2
  %2 = load ptr, ptr %Data, align 8
  %3 = load i32, ptr %n, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %2, i64 %idxprom
  call void @_ZN18ImFontBuildSrcDataD2Ev(ptr noundef nonnull align 8 dereferenceable(272) %arrayidx) #12
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %4 = load i32, ptr %n, align 4
  %inc = add nsw i32 %4, 1
  store i32 %inc, ptr %n, align 4
  br label %for.cond, !llvm.loop !105

for.end:                                          ; preds = %for.cond
  call void @_ZN8ImVectorI18ImFontBuildSrcDataE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI16stbtt_packedcharED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Data2 = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  invoke void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %invoke.cont, %entry
  ret void

terminate.lpad:                                   ; preds = %if.then
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #13
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI18ImFontBuildDstDataED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.15, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Data2 = getelementptr inbounds %struct.ImVector.15, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  invoke void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %invoke.cont, %entry
  ret void

terminate.lpad:                                   ; preds = %if.then
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #13
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorI18ImFontBuildSrcDataED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.14, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Data2 = getelementptr inbounds %struct.ImVector.14, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  invoke void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %invoke.cont, %entry
  ret void

terminate.lpad:                                   ; preds = %if.then
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #13
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI18ImFontBuildSrcDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.14, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 272
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.14, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.14, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.14, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 272
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %4, ptr align 8 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.14, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.14, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.14, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorI18ImFontBuildSrcDataE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.14, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.14, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.14, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI18ImFontBuildDstDataE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.15, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 32
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.15, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.15, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.15, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 32
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %4, ptr align 8 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.15, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.15, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.15, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorI18ImFontBuildDstDataE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.15, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.15, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.15, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

; Function Attrs: mustprogress uwtable
define internal noundef i32 @_ZL36stbtt_GetFontOffsetForIndex_internalPhi(ptr noundef %font_collection, i32 noundef %index) #4 {
entry:
  %retval = alloca i32, align 4
  %font_collection.addr = alloca ptr, align 8
  %index.addr = alloca i32, align 4
  %n = alloca i32, align 4
  store ptr %font_collection, ptr %font_collection.addr, align 8
  store i32 %index, ptr %index.addr, align 4
  %0 = load ptr, ptr %font_collection.addr, align 8
  %call = call noundef i32 @_ZL13stbtt__isfontPh(ptr noundef %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %index.addr, align 4
  %cmp = icmp eq i32 %1, 0
  %cond = select i1 %cmp, i32 0, i32 -1
  store i32 %cond, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %font_collection.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %2, i64 0
  %3 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %3 to i32
  %4 = load i8, ptr @.str.3, align 1
  %conv1 = sext i8 %4 to i32
  %cmp2 = icmp eq i32 %conv, %conv1
  br i1 %cmp2, label %land.lhs.true, label %if.end33

land.lhs.true:                                    ; preds = %if.end
  %5 = load ptr, ptr %font_collection.addr, align 8
  %arrayidx3 = getelementptr inbounds i8, ptr %5, i64 1
  %6 = load i8, ptr %arrayidx3, align 1
  %conv4 = zext i8 %6 to i32
  %7 = load i8, ptr getelementptr inbounds ([5 x i8], ptr @.str.3, i64 0, i64 1), align 1
  %conv5 = sext i8 %7 to i32
  %cmp6 = icmp eq i32 %conv4, %conv5
  br i1 %cmp6, label %land.lhs.true7, label %if.end33

land.lhs.true7:                                   ; preds = %land.lhs.true
  %8 = load ptr, ptr %font_collection.addr, align 8
  %arrayidx8 = getelementptr inbounds i8, ptr %8, i64 2
  %9 = load i8, ptr %arrayidx8, align 1
  %conv9 = zext i8 %9 to i32
  %10 = load i8, ptr getelementptr inbounds ([5 x i8], ptr @.str.3, i64 0, i64 2), align 1
  %conv10 = sext i8 %10 to i32
  %cmp11 = icmp eq i32 %conv9, %conv10
  br i1 %cmp11, label %land.lhs.true12, label %if.end33

land.lhs.true12:                                  ; preds = %land.lhs.true7
  %11 = load ptr, ptr %font_collection.addr, align 8
  %arrayidx13 = getelementptr inbounds i8, ptr %11, i64 3
  %12 = load i8, ptr %arrayidx13, align 1
  %conv14 = zext i8 %12 to i32
  %13 = load i8, ptr getelementptr inbounds ([5 x i8], ptr @.str.3, i64 0, i64 3), align 1
  %conv15 = sext i8 %13 to i32
  %cmp16 = icmp eq i32 %conv14, %conv15
  br i1 %cmp16, label %if.then17, label %if.end33

if.then17:                                        ; preds = %land.lhs.true12
  %14 = load ptr, ptr %font_collection.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %14, i64 4
  %call18 = call noundef i32 @_ZL7ttULONGPh(ptr noundef %add.ptr)
  %cmp19 = icmp eq i32 %call18, 65536
  br i1 %cmp19, label %if.then23, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then17
  %15 = load ptr, ptr %font_collection.addr, align 8
  %add.ptr20 = getelementptr inbounds i8, ptr %15, i64 4
  %call21 = call noundef i32 @_ZL7ttULONGPh(ptr noundef %add.ptr20)
  %cmp22 = icmp eq i32 %call21, 131072
  br i1 %cmp22, label %if.then23, label %if.end32

if.then23:                                        ; preds = %lor.lhs.false, %if.then17
  %16 = load ptr, ptr %font_collection.addr, align 8
  %add.ptr24 = getelementptr inbounds i8, ptr %16, i64 8
  %call25 = call noundef i32 @_ZL6ttLONGPh(ptr noundef %add.ptr24)
  store i32 %call25, ptr %n, align 4
  %17 = load i32, ptr %index.addr, align 4
  %18 = load i32, ptr %n, align 4
  %cmp26 = icmp sge i32 %17, %18
  br i1 %cmp26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.then23
  store i32 -1, ptr %retval, align 4
  br label %return

if.end28:                                         ; preds = %if.then23
  %19 = load ptr, ptr %font_collection.addr, align 8
  %add.ptr29 = getelementptr inbounds i8, ptr %19, i64 12
  %20 = load i32, ptr %index.addr, align 4
  %mul = mul nsw i32 %20, 4
  %idx.ext = sext i32 %mul to i64
  %add.ptr30 = getelementptr inbounds i8, ptr %add.ptr29, i64 %idx.ext
  %call31 = call noundef i32 @_ZL7ttULONGPh(ptr noundef %add.ptr30)
  store i32 %call31, ptr %retval, align 4
  br label %return

if.end32:                                         ; preds = %lor.lhs.false
  br label %if.end33

if.end33:                                         ; preds = %if.end32, %land.lhs.true12, %land.lhs.true7, %land.lhs.true, %if.end
  store i32 -1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end33, %if.end28, %if.then27, %if.then
  %21 = load i32, ptr %retval, align 4
  ret i32 %21
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZL13stbtt__isfontPh(ptr noundef %font) #2 {
entry:
  %retval = alloca i32, align 4
  %font.addr = alloca ptr, align 8
  store ptr %font, ptr %font.addr, align 8
  %0 = load ptr, ptr %font.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %0, i64 0
  %1 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %1 to i32
  %cmp = icmp eq i32 %conv, 49
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load ptr, ptr %font.addr, align 8
  %arrayidx1 = getelementptr inbounds i8, ptr %2, i64 1
  %3 = load i8, ptr %arrayidx1, align 1
  %conv2 = zext i8 %3 to i32
  %cmp3 = icmp eq i32 %conv2, 0
  br i1 %cmp3, label %land.lhs.true4, label %if.end

land.lhs.true4:                                   ; preds = %land.lhs.true
  %4 = load ptr, ptr %font.addr, align 8
  %arrayidx5 = getelementptr inbounds i8, ptr %4, i64 2
  %5 = load i8, ptr %arrayidx5, align 1
  %conv6 = zext i8 %5 to i32
  %cmp7 = icmp eq i32 %conv6, 0
  br i1 %cmp7, label %land.lhs.true8, label %if.end

land.lhs.true8:                                   ; preds = %land.lhs.true4
  %6 = load ptr, ptr %font.addr, align 8
  %arrayidx9 = getelementptr inbounds i8, ptr %6, i64 3
  %7 = load i8, ptr %arrayidx9, align 1
  %conv10 = zext i8 %7 to i32
  %cmp11 = icmp eq i32 %conv10, 0
  br i1 %cmp11, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true8
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true8, %land.lhs.true4, %land.lhs.true, %entry
  %8 = load ptr, ptr %font.addr, align 8
  %arrayidx12 = getelementptr inbounds i8, ptr %8, i64 0
  %9 = load i8, ptr %arrayidx12, align 1
  %conv13 = zext i8 %9 to i32
  %10 = load i8, ptr @.str.4, align 1
  %conv14 = sext i8 %10 to i32
  %cmp15 = icmp eq i32 %conv13, %conv14
  br i1 %cmp15, label %land.lhs.true16, label %if.end32

land.lhs.true16:                                  ; preds = %if.end
  %11 = load ptr, ptr %font.addr, align 8
  %arrayidx17 = getelementptr inbounds i8, ptr %11, i64 1
  %12 = load i8, ptr %arrayidx17, align 1
  %conv18 = zext i8 %12 to i32
  %13 = load i8, ptr getelementptr inbounds ([5 x i8], ptr @.str.4, i64 0, i64 1), align 1
  %conv19 = sext i8 %13 to i32
  %cmp20 = icmp eq i32 %conv18, %conv19
  br i1 %cmp20, label %land.lhs.true21, label %if.end32

land.lhs.true21:                                  ; preds = %land.lhs.true16
  %14 = load ptr, ptr %font.addr, align 8
  %arrayidx22 = getelementptr inbounds i8, ptr %14, i64 2
  %15 = load i8, ptr %arrayidx22, align 1
  %conv23 = zext i8 %15 to i32
  %16 = load i8, ptr getelementptr inbounds ([5 x i8], ptr @.str.4, i64 0, i64 2), align 1
  %conv24 = sext i8 %16 to i32
  %cmp25 = icmp eq i32 %conv23, %conv24
  br i1 %cmp25, label %land.lhs.true26, label %if.end32

land.lhs.true26:                                  ; preds = %land.lhs.true21
  %17 = load ptr, ptr %font.addr, align 8
  %arrayidx27 = getelementptr inbounds i8, ptr %17, i64 3
  %18 = load i8, ptr %arrayidx27, align 1
  %conv28 = zext i8 %18 to i32
  %19 = load i8, ptr getelementptr inbounds ([5 x i8], ptr @.str.4, i64 0, i64 3), align 1
  %conv29 = sext i8 %19 to i32
  %cmp30 = icmp eq i32 %conv28, %conv29
  br i1 %cmp30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %land.lhs.true26
  store i32 1, ptr %retval, align 4
  br label %return

if.end32:                                         ; preds = %land.lhs.true26, %land.lhs.true21, %land.lhs.true16, %if.end
  %20 = load ptr, ptr %font.addr, align 8
  %arrayidx33 = getelementptr inbounds i8, ptr %20, i64 0
  %21 = load i8, ptr %arrayidx33, align 1
  %conv34 = zext i8 %21 to i32
  %22 = load i8, ptr @.str.5, align 1
  %conv35 = sext i8 %22 to i32
  %cmp36 = icmp eq i32 %conv34, %conv35
  br i1 %cmp36, label %land.lhs.true37, label %if.end53

land.lhs.true37:                                  ; preds = %if.end32
  %23 = load ptr, ptr %font.addr, align 8
  %arrayidx38 = getelementptr inbounds i8, ptr %23, i64 1
  %24 = load i8, ptr %arrayidx38, align 1
  %conv39 = zext i8 %24 to i32
  %25 = load i8, ptr getelementptr inbounds ([5 x i8], ptr @.str.5, i64 0, i64 1), align 1
  %conv40 = sext i8 %25 to i32
  %cmp41 = icmp eq i32 %conv39, %conv40
  br i1 %cmp41, label %land.lhs.true42, label %if.end53

land.lhs.true42:                                  ; preds = %land.lhs.true37
  %26 = load ptr, ptr %font.addr, align 8
  %arrayidx43 = getelementptr inbounds i8, ptr %26, i64 2
  %27 = load i8, ptr %arrayidx43, align 1
  %conv44 = zext i8 %27 to i32
  %28 = load i8, ptr getelementptr inbounds ([5 x i8], ptr @.str.5, i64 0, i64 2), align 1
  %conv45 = sext i8 %28 to i32
  %cmp46 = icmp eq i32 %conv44, %conv45
  br i1 %cmp46, label %land.lhs.true47, label %if.end53

land.lhs.true47:                                  ; preds = %land.lhs.true42
  %29 = load ptr, ptr %font.addr, align 8
  %arrayidx48 = getelementptr inbounds i8, ptr %29, i64 3
  %30 = load i8, ptr %arrayidx48, align 1
  %conv49 = zext i8 %30 to i32
  %31 = load i8, ptr getelementptr inbounds ([5 x i8], ptr @.str.5, i64 0, i64 3), align 1
  %conv50 = sext i8 %31 to i32
  %cmp51 = icmp eq i32 %conv49, %conv50
  br i1 %cmp51, label %if.then52, label %if.end53

if.then52:                                        ; preds = %land.lhs.true47
  store i32 1, ptr %retval, align 4
  br label %return

if.end53:                                         ; preds = %land.lhs.true47, %land.lhs.true42, %land.lhs.true37, %if.end32
  %32 = load ptr, ptr %font.addr, align 8
  %arrayidx54 = getelementptr inbounds i8, ptr %32, i64 0
  %33 = load i8, ptr %arrayidx54, align 1
  %conv55 = zext i8 %33 to i32
  %cmp56 = icmp eq i32 %conv55, 0
  br i1 %cmp56, label %land.lhs.true57, label %if.end70

land.lhs.true57:                                  ; preds = %if.end53
  %34 = load ptr, ptr %font.addr, align 8
  %arrayidx58 = getelementptr inbounds i8, ptr %34, i64 1
  %35 = load i8, ptr %arrayidx58, align 1
  %conv59 = zext i8 %35 to i32
  %cmp60 = icmp eq i32 %conv59, 1
  br i1 %cmp60, label %land.lhs.true61, label %if.end70

land.lhs.true61:                                  ; preds = %land.lhs.true57
  %36 = load ptr, ptr %font.addr, align 8
  %arrayidx62 = getelementptr inbounds i8, ptr %36, i64 2
  %37 = load i8, ptr %arrayidx62, align 1
  %conv63 = zext i8 %37 to i32
  %cmp64 = icmp eq i32 %conv63, 0
  br i1 %cmp64, label %land.lhs.true65, label %if.end70

land.lhs.true65:                                  ; preds = %land.lhs.true61
  %38 = load ptr, ptr %font.addr, align 8
  %arrayidx66 = getelementptr inbounds i8, ptr %38, i64 3
  %39 = load i8, ptr %arrayidx66, align 1
  %conv67 = zext i8 %39 to i32
  %cmp68 = icmp eq i32 %conv67, 0
  br i1 %cmp68, label %if.then69, label %if.end70

if.then69:                                        ; preds = %land.lhs.true65
  store i32 1, ptr %retval, align 4
  br label %return

if.end70:                                         ; preds = %land.lhs.true65, %land.lhs.true61, %land.lhs.true57, %if.end53
  %40 = load ptr, ptr %font.addr, align 8
  %arrayidx71 = getelementptr inbounds i8, ptr %40, i64 0
  %41 = load i8, ptr %arrayidx71, align 1
  %conv72 = zext i8 %41 to i32
  %42 = load i8, ptr @.str.6, align 1
  %conv73 = sext i8 %42 to i32
  %cmp74 = icmp eq i32 %conv72, %conv73
  br i1 %cmp74, label %land.lhs.true75, label %if.end91

land.lhs.true75:                                  ; preds = %if.end70
  %43 = load ptr, ptr %font.addr, align 8
  %arrayidx76 = getelementptr inbounds i8, ptr %43, i64 1
  %44 = load i8, ptr %arrayidx76, align 1
  %conv77 = zext i8 %44 to i32
  %45 = load i8, ptr getelementptr inbounds ([5 x i8], ptr @.str.6, i64 0, i64 1), align 1
  %conv78 = sext i8 %45 to i32
  %cmp79 = icmp eq i32 %conv77, %conv78
  br i1 %cmp79, label %land.lhs.true80, label %if.end91

land.lhs.true80:                                  ; preds = %land.lhs.true75
  %46 = load ptr, ptr %font.addr, align 8
  %arrayidx81 = getelementptr inbounds i8, ptr %46, i64 2
  %47 = load i8, ptr %arrayidx81, align 1
  %conv82 = zext i8 %47 to i32
  %48 = load i8, ptr getelementptr inbounds ([5 x i8], ptr @.str.6, i64 0, i64 2), align 1
  %conv83 = sext i8 %48 to i32
  %cmp84 = icmp eq i32 %conv82, %conv83
  br i1 %cmp84, label %land.lhs.true85, label %if.end91

land.lhs.true85:                                  ; preds = %land.lhs.true80
  %49 = load ptr, ptr %font.addr, align 8
  %arrayidx86 = getelementptr inbounds i8, ptr %49, i64 3
  %50 = load i8, ptr %arrayidx86, align 1
  %conv87 = zext i8 %50 to i32
  %51 = load i8, ptr getelementptr inbounds ([5 x i8], ptr @.str.6, i64 0, i64 3), align 1
  %conv88 = sext i8 %51 to i32
  %cmp89 = icmp eq i32 %conv87, %conv88
  br i1 %cmp89, label %if.then90, label %if.end91

if.then90:                                        ; preds = %land.lhs.true85
  store i32 1, ptr %retval, align 4
  br label %return

if.end91:                                         ; preds = %land.lhs.true85, %land.lhs.true80, %land.lhs.true75, %if.end70
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end91, %if.then90, %if.then69, %if.then52, %if.then31, %if.then
  %52 = load i32, ptr %retval, align 4
  ret i32 %52
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZL7ttULONGPh(ptr noundef %p) #2 {
entry:
  %p.addr = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %0, i64 0
  %1 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %1 to i32
  %shl = shl i32 %conv, 24
  %2 = load ptr, ptr %p.addr, align 8
  %arrayidx1 = getelementptr inbounds i8, ptr %2, i64 1
  %3 = load i8, ptr %arrayidx1, align 1
  %conv2 = zext i8 %3 to i32
  %shl3 = shl i32 %conv2, 16
  %add = add nsw i32 %shl, %shl3
  %4 = load ptr, ptr %p.addr, align 8
  %arrayidx4 = getelementptr inbounds i8, ptr %4, i64 2
  %5 = load i8, ptr %arrayidx4, align 1
  %conv5 = zext i8 %5 to i32
  %shl6 = shl i32 %conv5, 8
  %add7 = add nsw i32 %add, %shl6
  %6 = load ptr, ptr %p.addr, align 8
  %arrayidx8 = getelementptr inbounds i8, ptr %6, i64 3
  %7 = load i8, ptr %arrayidx8, align 1
  %conv9 = zext i8 %7 to i32
  %add10 = add nsw i32 %add7, %conv9
  ret i32 %add10
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZL6ttLONGPh(ptr noundef %p) #2 {
entry:
  %p.addr = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %0, i64 0
  %1 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %1 to i32
  %shl = shl i32 %conv, 24
  %2 = load ptr, ptr %p.addr, align 8
  %arrayidx1 = getelementptr inbounds i8, ptr %2, i64 1
  %3 = load i8, ptr %arrayidx1, align 1
  %conv2 = zext i8 %3 to i32
  %shl3 = shl i32 %conv2, 16
  %add = add nsw i32 %shl, %shl3
  %4 = load ptr, ptr %p.addr, align 8
  %arrayidx4 = getelementptr inbounds i8, ptr %4, i64 2
  %5 = load i8, ptr %arrayidx4, align 1
  %conv5 = zext i8 %5 to i32
  %shl6 = shl i32 %conv5, 8
  %add7 = add nsw i32 %add, %shl6
  %6 = load ptr, ptr %p.addr, align 8
  %arrayidx8 = getelementptr inbounds i8, ptr %6, i64 3
  %7 = load i8, ptr %arrayidx8, align 1
  %conv9 = zext i8 %7 to i32
  %add10 = add nsw i32 %add7, %conv9
  ret i32 %add10
}

; Function Attrs: mustprogress uwtable
define internal noundef i32 @_ZL23stbtt_InitFont_internalP14stbtt_fontinfoPhi(ptr noundef %info, ptr noundef %data, i32 noundef %fontstart) #4 {
entry:
  %retval = alloca i32, align 4
  %info.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  %fontstart.addr = alloca i32, align 4
  %cmap = alloca i32, align 4
  %t = alloca i32, align 4
  %i = alloca i32, align 4
  %numTables = alloca i32, align 4
  %ref.tmp = alloca %struct.stbtt__buf, align 8
  %b = alloca %struct.stbtt__buf, align 8
  %topdict = alloca %struct.stbtt__buf, align 8
  %topdictidx = alloca %struct.stbtt__buf, align 8
  %cstype = alloca i32, align 4
  %charstrings = alloca i32, align 4
  %fdarrayoff = alloca i32, align 4
  %fdselectoff = alloca i32, align 4
  %cff26 = alloca i32, align 4
  %ref.tmp31 = alloca %struct.stbtt__buf, align 8
  %ref.tmp33 = alloca %struct.stbtt__buf, align 8
  %ref.tmp35 = alloca %struct.stbtt__buf, align 8
  %coerce = alloca %struct.stbtt__buf, align 8
  %ref.tmp41 = alloca %struct.stbtt__buf, align 8
  %ref.tmp43 = alloca %struct.stbtt__buf, align 8
  %agg.tmp = alloca %struct.stbtt__buf, align 8
  %coerce46 = alloca %struct.stbtt__buf, align 8
  %ref.tmp47 = alloca %struct.stbtt__buf, align 8
  %ref.tmp49 = alloca %struct.stbtt__buf, align 8
  %agg.tmp50 = alloca %struct.stbtt__buf, align 8
  %agg.tmp51 = alloca %struct.stbtt__buf, align 8
  %ref.tmp63 = alloca %struct.stbtt__buf, align 8
  %ref.tmp66 = alloca %struct.stbtt__buf, align 8
  %ref.tmp70 = alloca %struct.stbtt__buf, align 8
  %encoding_record = alloca i32, align 4
  store ptr %info, ptr %info.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  store i32 %fontstart, ptr %fontstart.addr, align 4
  %0 = load ptr, ptr %data.addr, align 8
  %1 = load ptr, ptr %info.addr, align 8
  %data1 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %1, i32 0, i32 1
  store ptr %0, ptr %data1, align 8
  %2 = load i32, ptr %fontstart.addr, align 4
  %3 = load ptr, ptr %info.addr, align 8
  %fontstart2 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %3, i32 0, i32 2
  store i32 %2, ptr %fontstart2, align 8
  %call = call { ptr, i64 } @_ZL14stbtt__new_bufPKvm(ptr noundef null, i64 noundef 0)
  %4 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 0
  %5 = extractvalue { ptr, i64 } %call, 0
  store ptr %5, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 1
  %7 = extractvalue { ptr, i64 } %call, 1
  store i64 %7, ptr %6, align 8
  %8 = load ptr, ptr %info.addr, align 8
  %cff = getelementptr inbounds %struct.stbtt_fontinfo, ptr %8, i32 0, i32 14
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %cff, ptr align 8 %ref.tmp, i64 16, i1 false)
  %9 = load ptr, ptr %data.addr, align 8
  %10 = load i32, ptr %fontstart.addr, align 4
  %call3 = call noundef i32 @_ZL17stbtt__find_tablePhjPKc(ptr noundef %9, i32 noundef %10, ptr noundef @.str.7)
  store i32 %call3, ptr %cmap, align 4
  %11 = load ptr, ptr %data.addr, align 8
  %12 = load i32, ptr %fontstart.addr, align 4
  %call4 = call noundef i32 @_ZL17stbtt__find_tablePhjPKc(ptr noundef %11, i32 noundef %12, ptr noundef @.str.8)
  %13 = load ptr, ptr %info.addr, align 8
  %loca = getelementptr inbounds %struct.stbtt_fontinfo, ptr %13, i32 0, i32 4
  store i32 %call4, ptr %loca, align 8
  %14 = load ptr, ptr %data.addr, align 8
  %15 = load i32, ptr %fontstart.addr, align 4
  %call5 = call noundef i32 @_ZL17stbtt__find_tablePhjPKc(ptr noundef %14, i32 noundef %15, ptr noundef @.str.9)
  %16 = load ptr, ptr %info.addr, align 8
  %head = getelementptr inbounds %struct.stbtt_fontinfo, ptr %16, i32 0, i32 5
  store i32 %call5, ptr %head, align 4
  %17 = load ptr, ptr %data.addr, align 8
  %18 = load i32, ptr %fontstart.addr, align 4
  %call6 = call noundef i32 @_ZL17stbtt__find_tablePhjPKc(ptr noundef %17, i32 noundef %18, ptr noundef @.str.10)
  %19 = load ptr, ptr %info.addr, align 8
  %glyf = getelementptr inbounds %struct.stbtt_fontinfo, ptr %19, i32 0, i32 6
  store i32 %call6, ptr %glyf, align 8
  %20 = load ptr, ptr %data.addr, align 8
  %21 = load i32, ptr %fontstart.addr, align 4
  %call7 = call noundef i32 @_ZL17stbtt__find_tablePhjPKc(ptr noundef %20, i32 noundef %21, ptr noundef @.str.11)
  %22 = load ptr, ptr %info.addr, align 8
  %hhea = getelementptr inbounds %struct.stbtt_fontinfo, ptr %22, i32 0, i32 7
  store i32 %call7, ptr %hhea, align 4
  %23 = load ptr, ptr %data.addr, align 8
  %24 = load i32, ptr %fontstart.addr, align 4
  %call8 = call noundef i32 @_ZL17stbtt__find_tablePhjPKc(ptr noundef %23, i32 noundef %24, ptr noundef @.str.12)
  %25 = load ptr, ptr %info.addr, align 8
  %hmtx = getelementptr inbounds %struct.stbtt_fontinfo, ptr %25, i32 0, i32 8
  store i32 %call8, ptr %hmtx, align 8
  %26 = load ptr, ptr %data.addr, align 8
  %27 = load i32, ptr %fontstart.addr, align 4
  %call9 = call noundef i32 @_ZL17stbtt__find_tablePhjPKc(ptr noundef %26, i32 noundef %27, ptr noundef @.str.13)
  %28 = load ptr, ptr %info.addr, align 8
  %kern = getelementptr inbounds %struct.stbtt_fontinfo, ptr %28, i32 0, i32 9
  store i32 %call9, ptr %kern, align 4
  %29 = load ptr, ptr %data.addr, align 8
  %30 = load i32, ptr %fontstart.addr, align 4
  %call10 = call noundef i32 @_ZL17stbtt__find_tablePhjPKc(ptr noundef %29, i32 noundef %30, ptr noundef @.str.14)
  %31 = load ptr, ptr %info.addr, align 8
  %gpos = getelementptr inbounds %struct.stbtt_fontinfo, ptr %31, i32 0, i32 10
  store i32 %call10, ptr %gpos, align 8
  %32 = load i32, ptr %cmap, align 4
  %tobool = icmp ne i32 %32, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %33 = load ptr, ptr %info.addr, align 8
  %head11 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %33, i32 0, i32 5
  %34 = load i32, ptr %head11, align 4
  %tobool12 = icmp ne i32 %34, 0
  br i1 %tobool12, label %lor.lhs.false13, label %if.then

lor.lhs.false13:                                  ; preds = %lor.lhs.false
  %35 = load ptr, ptr %info.addr, align 8
  %hhea14 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %35, i32 0, i32 7
  %36 = load i32, ptr %hhea14, align 4
  %tobool15 = icmp ne i32 %36, 0
  br i1 %tobool15, label %lor.lhs.false16, label %if.then

lor.lhs.false16:                                  ; preds = %lor.lhs.false13
  %37 = load ptr, ptr %info.addr, align 8
  %hmtx17 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %37, i32 0, i32 8
  %38 = load i32, ptr %hmtx17, align 8
  %tobool18 = icmp ne i32 %38, 0
  br i1 %tobool18, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false16, %lor.lhs.false13, %lor.lhs.false, %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false16
  %39 = load ptr, ptr %info.addr, align 8
  %glyf19 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %39, i32 0, i32 6
  %40 = load i32, ptr %glyf19, align 8
  %tobool20 = icmp ne i32 %40, 0
  br i1 %tobool20, label %if.then21, label %if.else

if.then21:                                        ; preds = %if.end
  %41 = load ptr, ptr %info.addr, align 8
  %loca22 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %41, i32 0, i32 4
  %42 = load i32, ptr %loca22, align 8
  %tobool23 = icmp ne i32 %42, 0
  br i1 %tobool23, label %if.end25, label %if.then24

if.then24:                                        ; preds = %if.then21
  store i32 0, ptr %retval, align 4
  br label %return

if.end25:                                         ; preds = %if.then21
  br label %if.end73

if.else:                                          ; preds = %if.end
  store i32 2, ptr %cstype, align 4
  store i32 0, ptr %charstrings, align 4
  store i32 0, ptr %fdarrayoff, align 4
  store i32 0, ptr %fdselectoff, align 4
  %43 = load ptr, ptr %data.addr, align 8
  %44 = load i32, ptr %fontstart.addr, align 4
  %call27 = call noundef i32 @_ZL17stbtt__find_tablePhjPKc(ptr noundef %43, i32 noundef %44, ptr noundef @.str.15)
  store i32 %call27, ptr %cff26, align 4
  %45 = load i32, ptr %cff26, align 4
  %tobool28 = icmp ne i32 %45, 0
  br i1 %tobool28, label %if.end30, label %if.then29

if.then29:                                        ; preds = %if.else
  store i32 0, ptr %retval, align 4
  br label %return

if.end30:                                         ; preds = %if.else
  %call32 = call { ptr, i64 } @_ZL14stbtt__new_bufPKvm(ptr noundef null, i64 noundef 0)
  %46 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp31, i32 0, i32 0
  %47 = extractvalue { ptr, i64 } %call32, 0
  store ptr %47, ptr %46, align 8
  %48 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp31, i32 0, i32 1
  %49 = extractvalue { ptr, i64 } %call32, 1
  store i64 %49, ptr %48, align 8
  %50 = load ptr, ptr %info.addr, align 8
  %fontdicts = getelementptr inbounds %struct.stbtt_fontinfo, ptr %50, i32 0, i32 18
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %fontdicts, ptr align 8 %ref.tmp31, i64 16, i1 false)
  %call34 = call { ptr, i64 } @_ZL14stbtt__new_bufPKvm(ptr noundef null, i64 noundef 0)
  %51 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp33, i32 0, i32 0
  %52 = extractvalue { ptr, i64 } %call34, 0
  store ptr %52, ptr %51, align 8
  %53 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp33, i32 0, i32 1
  %54 = extractvalue { ptr, i64 } %call34, 1
  store i64 %54, ptr %53, align 8
  %55 = load ptr, ptr %info.addr, align 8
  %fdselect = getelementptr inbounds %struct.stbtt_fontinfo, ptr %55, i32 0, i32 19
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %fdselect, ptr align 8 %ref.tmp33, i64 16, i1 false)
  %56 = load ptr, ptr %data.addr, align 8
  %57 = load i32, ptr %cff26, align 4
  %idx.ext = zext i32 %57 to i64
  %add.ptr = getelementptr inbounds i8, ptr %56, i64 %idx.ext
  %call36 = call { ptr, i64 } @_ZL14stbtt__new_bufPKvm(ptr noundef %add.ptr, i64 noundef 536870912)
  %58 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp35, i32 0, i32 0
  %59 = extractvalue { ptr, i64 } %call36, 0
  store ptr %59, ptr %58, align 8
  %60 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp35, i32 0, i32 1
  %61 = extractvalue { ptr, i64 } %call36, 1
  store i64 %61, ptr %60, align 8
  %62 = load ptr, ptr %info.addr, align 8
  %cff37 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %62, i32 0, i32 14
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %cff37, ptr align 8 %ref.tmp35, i64 16, i1 false)
  %63 = load ptr, ptr %info.addr, align 8
  %cff38 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %63, i32 0, i32 14
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %b, ptr align 8 %cff38, i64 16, i1 false)
  call void @_ZL15stbtt__buf_skipP10stbtt__bufi(ptr noundef %b, i32 noundef 2)
  %call39 = call noundef zeroext i8 @_ZL15stbtt__buf_get8P10stbtt__buf(ptr noundef %b)
  %conv = zext i8 %call39 to i32
  call void @_ZL15stbtt__buf_seekP10stbtt__bufi(ptr noundef %b, i32 noundef %conv)
  %call40 = call { ptr, i64 } @_ZL20stbtt__cff_get_indexP10stbtt__buf(ptr noundef %b)
  %64 = getelementptr inbounds { ptr, i64 }, ptr %coerce, i32 0, i32 0
  %65 = extractvalue { ptr, i64 } %call40, 0
  store ptr %65, ptr %64, align 8
  %66 = getelementptr inbounds { ptr, i64 }, ptr %coerce, i32 0, i32 1
  %67 = extractvalue { ptr, i64 } %call40, 1
  store i64 %67, ptr %66, align 8
  %call42 = call { ptr, i64 } @_ZL20stbtt__cff_get_indexP10stbtt__buf(ptr noundef %b)
  %68 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp41, i32 0, i32 0
  %69 = extractvalue { ptr, i64 } %call42, 0
  store ptr %69, ptr %68, align 8
  %70 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp41, i32 0, i32 1
  %71 = extractvalue { ptr, i64 } %call42, 1
  store i64 %71, ptr %70, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %topdictidx, ptr align 8 %ref.tmp41, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %topdictidx, i64 16, i1 false)
  %72 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %73 = load ptr, ptr %72, align 8
  %74 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %75 = load i64, ptr %74, align 8
  %call44 = call { ptr, i64 } @_ZL20stbtt__cff_index_get10stbtt__bufi(ptr %73, i64 %75, i32 noundef 0)
  %76 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp43, i32 0, i32 0
  %77 = extractvalue { ptr, i64 } %call44, 0
  store ptr %77, ptr %76, align 8
  %78 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp43, i32 0, i32 1
  %79 = extractvalue { ptr, i64 } %call44, 1
  store i64 %79, ptr %78, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %topdict, ptr align 8 %ref.tmp43, i64 16, i1 false)
  %call45 = call { ptr, i64 } @_ZL20stbtt__cff_get_indexP10stbtt__buf(ptr noundef %b)
  %80 = getelementptr inbounds { ptr, i64 }, ptr %coerce46, i32 0, i32 0
  %81 = extractvalue { ptr, i64 } %call45, 0
  store ptr %81, ptr %80, align 8
  %82 = getelementptr inbounds { ptr, i64 }, ptr %coerce46, i32 0, i32 1
  %83 = extractvalue { ptr, i64 } %call45, 1
  store i64 %83, ptr %82, align 8
  %call48 = call { ptr, i64 } @_ZL20stbtt__cff_get_indexP10stbtt__buf(ptr noundef %b)
  %84 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp47, i32 0, i32 0
  %85 = extractvalue { ptr, i64 } %call48, 0
  store ptr %85, ptr %84, align 8
  %86 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp47, i32 0, i32 1
  %87 = extractvalue { ptr, i64 } %call48, 1
  store i64 %87, ptr %86, align 8
  %88 = load ptr, ptr %info.addr, align 8
  %gsubrs = getelementptr inbounds %struct.stbtt_fontinfo, ptr %88, i32 0, i32 16
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %gsubrs, ptr align 8 %ref.tmp47, i64 16, i1 false)
  call void @_ZL20stbtt__dict_get_intsP10stbtt__bufiiPj(ptr noundef %topdict, i32 noundef 17, i32 noundef 1, ptr noundef %charstrings)
  call void @_ZL20stbtt__dict_get_intsP10stbtt__bufiiPj(ptr noundef %topdict, i32 noundef 262, i32 noundef 1, ptr noundef %cstype)
  call void @_ZL20stbtt__dict_get_intsP10stbtt__bufiiPj(ptr noundef %topdict, i32 noundef 292, i32 noundef 1, ptr noundef %fdarrayoff)
  call void @_ZL20stbtt__dict_get_intsP10stbtt__bufiiPj(ptr noundef %topdict, i32 noundef 293, i32 noundef 1, ptr noundef %fdselectoff)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp50, ptr align 8 %b, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp51, ptr align 8 %topdict, i64 16, i1 false)
  %89 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp50, i32 0, i32 0
  %90 = load ptr, ptr %89, align 8
  %91 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp50, i32 0, i32 1
  %92 = load i64, ptr %91, align 8
  %93 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp51, i32 0, i32 0
  %94 = load ptr, ptr %93, align 8
  %95 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp51, i32 0, i32 1
  %96 = load i64, ptr %95, align 8
  %call52 = call { ptr, i64 } @_ZL16stbtt__get_subrs10stbtt__bufS_(ptr %90, i64 %92, ptr %94, i64 %96)
  %97 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp49, i32 0, i32 0
  %98 = extractvalue { ptr, i64 } %call52, 0
  store ptr %98, ptr %97, align 8
  %99 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp49, i32 0, i32 1
  %100 = extractvalue { ptr, i64 } %call52, 1
  store i64 %100, ptr %99, align 8
  %101 = load ptr, ptr %info.addr, align 8
  %subrs = getelementptr inbounds %struct.stbtt_fontinfo, ptr %101, i32 0, i32 17
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %subrs, ptr align 8 %ref.tmp49, i64 16, i1 false)
  %102 = load i32, ptr %cstype, align 4
  %cmp = icmp ne i32 %102, 2
  br i1 %cmp, label %if.then53, label %if.end54

if.then53:                                        ; preds = %if.end30
  store i32 0, ptr %retval, align 4
  br label %return

if.end54:                                         ; preds = %if.end30
  %103 = load i32, ptr %charstrings, align 4
  %cmp55 = icmp eq i32 %103, 0
  br i1 %cmp55, label %if.then56, label %if.end57

if.then56:                                        ; preds = %if.end54
  store i32 0, ptr %retval, align 4
  br label %return

if.end57:                                         ; preds = %if.end54
  %104 = load i32, ptr %fdarrayoff, align 4
  %tobool58 = icmp ne i32 %104, 0
  br i1 %tobool58, label %if.then59, label %if.end69

if.then59:                                        ; preds = %if.end57
  %105 = load i32, ptr %fdselectoff, align 4
  %tobool60 = icmp ne i32 %105, 0
  br i1 %tobool60, label %if.end62, label %if.then61

if.then61:                                        ; preds = %if.then59
  store i32 0, ptr %retval, align 4
  br label %return

if.end62:                                         ; preds = %if.then59
  %106 = load i32, ptr %fdarrayoff, align 4
  call void @_ZL15stbtt__buf_seekP10stbtt__bufi(ptr noundef %b, i32 noundef %106)
  %call64 = call { ptr, i64 } @_ZL20stbtt__cff_get_indexP10stbtt__buf(ptr noundef %b)
  %107 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp63, i32 0, i32 0
  %108 = extractvalue { ptr, i64 } %call64, 0
  store ptr %108, ptr %107, align 8
  %109 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp63, i32 0, i32 1
  %110 = extractvalue { ptr, i64 } %call64, 1
  store i64 %110, ptr %109, align 8
  %111 = load ptr, ptr %info.addr, align 8
  %fontdicts65 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %111, i32 0, i32 18
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %fontdicts65, ptr align 8 %ref.tmp63, i64 16, i1 false)
  %112 = load i32, ptr %fdselectoff, align 4
  %size = getelementptr inbounds %struct.stbtt__buf, ptr %b, i32 0, i32 2
  %113 = load i32, ptr %size, align 4
  %114 = load i32, ptr %fdselectoff, align 4
  %sub = sub i32 %113, %114
  %call67 = call { ptr, i64 } @_ZL16stbtt__buf_rangePK10stbtt__bufii(ptr noundef %b, i32 noundef %112, i32 noundef %sub)
  %115 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp66, i32 0, i32 0
  %116 = extractvalue { ptr, i64 } %call67, 0
  store ptr %116, ptr %115, align 8
  %117 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp66, i32 0, i32 1
  %118 = extractvalue { ptr, i64 } %call67, 1
  store i64 %118, ptr %117, align 8
  %119 = load ptr, ptr %info.addr, align 8
  %fdselect68 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %119, i32 0, i32 19
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %fdselect68, ptr align 8 %ref.tmp66, i64 16, i1 false)
  br label %if.end69

if.end69:                                         ; preds = %if.end62, %if.end57
  %120 = load i32, ptr %charstrings, align 4
  call void @_ZL15stbtt__buf_seekP10stbtt__bufi(ptr noundef %b, i32 noundef %120)
  %call71 = call { ptr, i64 } @_ZL20stbtt__cff_get_indexP10stbtt__buf(ptr noundef %b)
  %121 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp70, i32 0, i32 0
  %122 = extractvalue { ptr, i64 } %call71, 0
  store ptr %122, ptr %121, align 8
  %123 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp70, i32 0, i32 1
  %124 = extractvalue { ptr, i64 } %call71, 1
  store i64 %124, ptr %123, align 8
  %125 = load ptr, ptr %info.addr, align 8
  %charstrings72 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %125, i32 0, i32 15
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %charstrings72, ptr align 8 %ref.tmp70, i64 16, i1 false)
  br label %if.end73

if.end73:                                         ; preds = %if.end69, %if.end25
  %126 = load ptr, ptr %data.addr, align 8
  %127 = load i32, ptr %fontstart.addr, align 4
  %call74 = call noundef i32 @_ZL17stbtt__find_tablePhjPKc(ptr noundef %126, i32 noundef %127, ptr noundef @.str.16)
  store i32 %call74, ptr %t, align 4
  %128 = load i32, ptr %t, align 4
  %tobool75 = icmp ne i32 %128, 0
  br i1 %tobool75, label %if.then76, label %if.else82

if.then76:                                        ; preds = %if.end73
  %129 = load ptr, ptr %data.addr, align 8
  %130 = load i32, ptr %t, align 4
  %idx.ext77 = zext i32 %130 to i64
  %add.ptr78 = getelementptr inbounds i8, ptr %129, i64 %idx.ext77
  %add.ptr79 = getelementptr inbounds i8, ptr %add.ptr78, i64 4
  %call80 = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr79)
  %conv81 = zext i16 %call80 to i32
  %131 = load ptr, ptr %info.addr, align 8
  %numGlyphs = getelementptr inbounds %struct.stbtt_fontinfo, ptr %131, i32 0, i32 3
  store i32 %conv81, ptr %numGlyphs, align 4
  br label %if.end84

if.else82:                                        ; preds = %if.end73
  %132 = load ptr, ptr %info.addr, align 8
  %numGlyphs83 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %132, i32 0, i32 3
  store i32 65535, ptr %numGlyphs83, align 4
  br label %if.end84

if.end84:                                         ; preds = %if.else82, %if.then76
  %133 = load ptr, ptr %info.addr, align 8
  %svg = getelementptr inbounds %struct.stbtt_fontinfo, ptr %133, i32 0, i32 11
  store i32 -1, ptr %svg, align 4
  %134 = load ptr, ptr %data.addr, align 8
  %135 = load i32, ptr %cmap, align 4
  %idx.ext85 = zext i32 %135 to i64
  %add.ptr86 = getelementptr inbounds i8, ptr %134, i64 %idx.ext85
  %add.ptr87 = getelementptr inbounds i8, ptr %add.ptr86, i64 2
  %call88 = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr87)
  %conv89 = zext i16 %call88 to i32
  store i32 %conv89, ptr %numTables, align 4
  %136 = load ptr, ptr %info.addr, align 8
  %index_map = getelementptr inbounds %struct.stbtt_fontinfo, ptr %136, i32 0, i32 12
  store i32 0, ptr %index_map, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end84
  %137 = load i32, ptr %i, align 4
  %138 = load i32, ptr %numTables, align 4
  %cmp90 = icmp slt i32 %137, %138
  br i1 %cmp90, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %139 = load i32, ptr %cmap, align 4
  %add = add i32 %139, 4
  %140 = load i32, ptr %i, align 4
  %mul = mul nsw i32 8, %140
  %add91 = add i32 %add, %mul
  store i32 %add91, ptr %encoding_record, align 4
  %141 = load ptr, ptr %data.addr, align 8
  %142 = load i32, ptr %encoding_record, align 4
  %idx.ext92 = zext i32 %142 to i64
  %add.ptr93 = getelementptr inbounds i8, ptr %141, i64 %idx.ext92
  %call94 = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr93)
  %conv95 = zext i16 %call94 to i32
  switch i32 %conv95, label %sw.epilog115 [
    i32 3, label %sw.bb
    i32 0, label %sw.bb108
  ]

sw.bb:                                            ; preds = %for.body
  %143 = load ptr, ptr %data.addr, align 8
  %144 = load i32, ptr %encoding_record, align 4
  %idx.ext96 = zext i32 %144 to i64
  %add.ptr97 = getelementptr inbounds i8, ptr %143, i64 %idx.ext96
  %add.ptr98 = getelementptr inbounds i8, ptr %add.ptr97, i64 2
  %call99 = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr98)
  %conv100 = zext i16 %call99 to i32
  switch i32 %conv100, label %sw.epilog [
    i32 1, label %sw.bb101
    i32 10, label %sw.bb101
  ]

sw.bb101:                                         ; preds = %sw.bb, %sw.bb
  %145 = load i32, ptr %cmap, align 4
  %146 = load ptr, ptr %data.addr, align 8
  %147 = load i32, ptr %encoding_record, align 4
  %idx.ext102 = zext i32 %147 to i64
  %add.ptr103 = getelementptr inbounds i8, ptr %146, i64 %idx.ext102
  %add.ptr104 = getelementptr inbounds i8, ptr %add.ptr103, i64 4
  %call105 = call noundef i32 @_ZL7ttULONGPh(ptr noundef %add.ptr104)
  %add106 = add i32 %145, %call105
  %148 = load ptr, ptr %info.addr, align 8
  %index_map107 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %148, i32 0, i32 12
  store i32 %add106, ptr %index_map107, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb101, %sw.bb
  br label %sw.epilog115

sw.bb108:                                         ; preds = %for.body
  %149 = load i32, ptr %cmap, align 4
  %150 = load ptr, ptr %data.addr, align 8
  %151 = load i32, ptr %encoding_record, align 4
  %idx.ext109 = zext i32 %151 to i64
  %add.ptr110 = getelementptr inbounds i8, ptr %150, i64 %idx.ext109
  %add.ptr111 = getelementptr inbounds i8, ptr %add.ptr110, i64 4
  %call112 = call noundef i32 @_ZL7ttULONGPh(ptr noundef %add.ptr111)
  %add113 = add i32 %149, %call112
  %152 = load ptr, ptr %info.addr, align 8
  %index_map114 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %152, i32 0, i32 12
  store i32 %add113, ptr %index_map114, align 8
  br label %sw.epilog115

sw.epilog115:                                     ; preds = %sw.bb108, %sw.epilog, %for.body
  br label %for.inc

for.inc:                                          ; preds = %sw.epilog115
  %153 = load i32, ptr %i, align 4
  %inc = add nsw i32 %153, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !106

for.end:                                          ; preds = %for.cond
  %154 = load ptr, ptr %info.addr, align 8
  %index_map116 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %154, i32 0, i32 12
  %155 = load i32, ptr %index_map116, align 8
  %cmp117 = icmp eq i32 %155, 0
  br i1 %cmp117, label %if.then118, label %if.end119

if.then118:                                       ; preds = %for.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end119:                                        ; preds = %for.end
  %156 = load ptr, ptr %data.addr, align 8
  %157 = load ptr, ptr %info.addr, align 8
  %head120 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %157, i32 0, i32 5
  %158 = load i32, ptr %head120, align 4
  %idx.ext121 = sext i32 %158 to i64
  %add.ptr122 = getelementptr inbounds i8, ptr %156, i64 %idx.ext121
  %add.ptr123 = getelementptr inbounds i8, ptr %add.ptr122, i64 50
  %call124 = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr123)
  %conv125 = zext i16 %call124 to i32
  %159 = load ptr, ptr %info.addr, align 8
  %indexToLocFormat = getelementptr inbounds %struct.stbtt_fontinfo, ptr %159, i32 0, i32 13
  store i32 %conv125, ptr %indexToLocFormat, align 4
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end119, %if.then118, %if.then61, %if.then56, %if.then53, %if.then29, %if.then24, %if.then
  %160 = load i32, ptr %retval, align 4
  ret i32 %160
}

; Function Attrs: mustprogress nounwind uwtable
define internal { ptr, i64 } @_ZL14stbtt__new_bufPKvm(ptr noundef %p, i64 noundef %size) #2 {
entry:
  %retval = alloca %struct.stbtt__buf, align 8
  %p.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %p.addr, align 8
  %data = getelementptr inbounds %struct.stbtt__buf, ptr %retval, i32 0, i32 0
  store ptr %0, ptr %data, align 8
  %1 = load i64, ptr %size.addr, align 8
  %conv = trunc i64 %1 to i32
  %size1 = getelementptr inbounds %struct.stbtt__buf, ptr %retval, i32 0, i32 2
  store i32 %conv, ptr %size1, align 4
  %cursor = getelementptr inbounds %struct.stbtt__buf, ptr %retval, i32 0, i32 1
  store i32 0, ptr %cursor, align 8
  %2 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %2
}

; Function Attrs: mustprogress uwtable
define internal noundef i32 @_ZL17stbtt__find_tablePhjPKc(ptr noundef %data, i32 noundef %fontstart, ptr noundef %tag) #4 {
entry:
  %retval = alloca i32, align 4
  %data.addr = alloca ptr, align 8
  %fontstart.addr = alloca i32, align 4
  %tag.addr = alloca ptr, align 8
  %num_tables = alloca i32, align 4
  %tabledir = alloca i32, align 4
  %i = alloca i32, align 4
  %loc = alloca i32, align 4
  store ptr %data, ptr %data.addr, align 8
  store i32 %fontstart, ptr %fontstart.addr, align 4
  store ptr %tag, ptr %tag.addr, align 8
  %0 = load ptr, ptr %data.addr, align 8
  %1 = load i32, ptr %fontstart.addr, align 4
  %idx.ext = zext i32 %1 to i64
  %add.ptr = getelementptr inbounds i8, ptr %0, i64 %idx.ext
  %add.ptr1 = getelementptr inbounds i8, ptr %add.ptr, i64 4
  %call = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr1)
  %conv = zext i16 %call to i32
  store i32 %conv, ptr %num_tables, align 4
  %2 = load i32, ptr %fontstart.addr, align 4
  %add = add i32 %2, 12
  store i32 %add, ptr %tabledir, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i32, ptr %i, align 4
  %4 = load i32, ptr %num_tables, align 4
  %cmp = icmp slt i32 %3, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i32, ptr %tabledir, align 4
  %6 = load i32, ptr %i, align 4
  %mul = mul nsw i32 16, %6
  %add2 = add i32 %5, %mul
  store i32 %add2, ptr %loc, align 4
  %7 = load ptr, ptr %data.addr, align 8
  %8 = load i32, ptr %loc, align 4
  %idx.ext3 = zext i32 %8 to i64
  %add.ptr4 = getelementptr inbounds i8, ptr %7, i64 %idx.ext3
  %add.ptr5 = getelementptr inbounds i8, ptr %add.ptr4, i64 0
  %arrayidx = getelementptr inbounds i8, ptr %add.ptr5, i64 0
  %9 = load i8, ptr %arrayidx, align 1
  %conv6 = zext i8 %9 to i32
  %10 = load ptr, ptr %tag.addr, align 8
  %arrayidx7 = getelementptr inbounds i8, ptr %10, i64 0
  %11 = load i8, ptr %arrayidx7, align 1
  %conv8 = sext i8 %11 to i32
  %cmp9 = icmp eq i32 %conv6, %conv8
  br i1 %cmp9, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %12 = load ptr, ptr %data.addr, align 8
  %13 = load i32, ptr %loc, align 4
  %idx.ext10 = zext i32 %13 to i64
  %add.ptr11 = getelementptr inbounds i8, ptr %12, i64 %idx.ext10
  %add.ptr12 = getelementptr inbounds i8, ptr %add.ptr11, i64 0
  %arrayidx13 = getelementptr inbounds i8, ptr %add.ptr12, i64 1
  %14 = load i8, ptr %arrayidx13, align 1
  %conv14 = zext i8 %14 to i32
  %15 = load ptr, ptr %tag.addr, align 8
  %arrayidx15 = getelementptr inbounds i8, ptr %15, i64 1
  %16 = load i8, ptr %arrayidx15, align 1
  %conv16 = sext i8 %16 to i32
  %cmp17 = icmp eq i32 %conv14, %conv16
  br i1 %cmp17, label %land.lhs.true18, label %if.end

land.lhs.true18:                                  ; preds = %land.lhs.true
  %17 = load ptr, ptr %data.addr, align 8
  %18 = load i32, ptr %loc, align 4
  %idx.ext19 = zext i32 %18 to i64
  %add.ptr20 = getelementptr inbounds i8, ptr %17, i64 %idx.ext19
  %add.ptr21 = getelementptr inbounds i8, ptr %add.ptr20, i64 0
  %arrayidx22 = getelementptr inbounds i8, ptr %add.ptr21, i64 2
  %19 = load i8, ptr %arrayidx22, align 1
  %conv23 = zext i8 %19 to i32
  %20 = load ptr, ptr %tag.addr, align 8
  %arrayidx24 = getelementptr inbounds i8, ptr %20, i64 2
  %21 = load i8, ptr %arrayidx24, align 1
  %conv25 = sext i8 %21 to i32
  %cmp26 = icmp eq i32 %conv23, %conv25
  br i1 %cmp26, label %land.lhs.true27, label %if.end

land.lhs.true27:                                  ; preds = %land.lhs.true18
  %22 = load ptr, ptr %data.addr, align 8
  %23 = load i32, ptr %loc, align 4
  %idx.ext28 = zext i32 %23 to i64
  %add.ptr29 = getelementptr inbounds i8, ptr %22, i64 %idx.ext28
  %add.ptr30 = getelementptr inbounds i8, ptr %add.ptr29, i64 0
  %arrayidx31 = getelementptr inbounds i8, ptr %add.ptr30, i64 3
  %24 = load i8, ptr %arrayidx31, align 1
  %conv32 = zext i8 %24 to i32
  %25 = load ptr, ptr %tag.addr, align 8
  %arrayidx33 = getelementptr inbounds i8, ptr %25, i64 3
  %26 = load i8, ptr %arrayidx33, align 1
  %conv34 = sext i8 %26 to i32
  %cmp35 = icmp eq i32 %conv32, %conv34
  br i1 %cmp35, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true27
  %27 = load ptr, ptr %data.addr, align 8
  %28 = load i32, ptr %loc, align 4
  %idx.ext36 = zext i32 %28 to i64
  %add.ptr37 = getelementptr inbounds i8, ptr %27, i64 %idx.ext36
  %add.ptr38 = getelementptr inbounds i8, ptr %add.ptr37, i64 8
  %call39 = call noundef i32 @_ZL7ttULONGPh(ptr noundef %add.ptr38)
  store i32 %call39, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true27, %land.lhs.true18, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %29 = load i32, ptr %i, align 4
  %inc = add nsw i32 %29, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !107

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %30 = load i32, ptr %retval, align 4
  ret i32 %30
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL15stbtt__buf_skipP10stbtt__bufi(ptr noundef %b, i32 noundef %o) #4 {
entry:
  %b.addr = alloca ptr, align 8
  %o.addr = alloca i32, align 4
  store ptr %b, ptr %b.addr, align 8
  store i32 %o, ptr %o.addr, align 4
  %0 = load ptr, ptr %b.addr, align 8
  %1 = load ptr, ptr %b.addr, align 8
  %cursor = getelementptr inbounds %struct.stbtt__buf, ptr %1, i32 0, i32 1
  %2 = load i32, ptr %cursor, align 8
  %3 = load i32, ptr %o.addr, align 4
  %add = add nsw i32 %2, %3
  call void @_ZL15stbtt__buf_seekP10stbtt__bufi(ptr noundef %0, i32 noundef %add)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZL15stbtt__buf_seekP10stbtt__bufi(ptr noundef %b, i32 noundef %o) #2 {
entry:
  %b.addr = alloca ptr, align 8
  %o.addr = alloca i32, align 4
  store ptr %b, ptr %b.addr, align 8
  store i32 %o, ptr %o.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load i32, ptr %o.addr, align 4
  %1 = load ptr, ptr %b.addr, align 8
  %size = getelementptr inbounds %struct.stbtt__buf, ptr %1, i32 0, i32 2
  %2 = load i32, ptr %size, align 4
  %cmp = icmp sgt i32 %0, %2
  br i1 %cmp, label %cond.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.end
  %3 = load i32, ptr %o.addr, align 4
  %cmp1 = icmp slt i32 %3, 0
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %lor.lhs.false, %do.end
  %4 = load ptr, ptr %b.addr, align 8
  %size2 = getelementptr inbounds %struct.stbtt__buf, ptr %4, i32 0, i32 2
  %5 = load i32, ptr %size2, align 4
  br label %cond.end

cond.false:                                       ; preds = %lor.lhs.false
  %6 = load i32, ptr %o.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %5, %cond.true ], [ %6, %cond.false ]
  %7 = load ptr, ptr %b.addr, align 8
  %cursor = getelementptr inbounds %struct.stbtt__buf, ptr %7, i32 0, i32 1
  store i32 %cond, ptr %cursor, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef zeroext i8 @_ZL15stbtt__buf_get8P10stbtt__buf(ptr noundef %b) #2 {
entry:
  %retval = alloca i8, align 1
  %b.addr = alloca ptr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %b.addr, align 8
  %cursor = getelementptr inbounds %struct.stbtt__buf, ptr %0, i32 0, i32 1
  %1 = load i32, ptr %cursor, align 8
  %2 = load ptr, ptr %b.addr, align 8
  %size = getelementptr inbounds %struct.stbtt__buf, ptr %2, i32 0, i32 2
  %3 = load i32, ptr %size, align 4
  %cmp = icmp sge i32 %1, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8 0, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %b.addr, align 8
  %data = getelementptr inbounds %struct.stbtt__buf, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %data, align 8
  %6 = load ptr, ptr %b.addr, align 8
  %cursor1 = getelementptr inbounds %struct.stbtt__buf, ptr %6, i32 0, i32 1
  %7 = load i32, ptr %cursor1, align 8
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %cursor1, align 8
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr inbounds i8, ptr %5, i64 %idxprom
  %8 = load i8, ptr %arrayidx, align 1
  store i8 %8, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %9 = load i8, ptr %retval, align 1
  ret i8 %9
}

; Function Attrs: mustprogress uwtable
define internal { ptr, i64 } @_ZL20stbtt__cff_get_indexP10stbtt__buf(ptr noundef %b) #4 {
entry:
  %retval = alloca %struct.stbtt__buf, align 8
  %b.addr = alloca ptr, align 8
  %count = alloca i32, align 4
  %start = alloca i32, align 4
  %offsize = alloca i32, align 4
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %b.addr, align 8
  %cursor = getelementptr inbounds %struct.stbtt__buf, ptr %0, i32 0, i32 1
  %1 = load i32, ptr %cursor, align 8
  store i32 %1, ptr %start, align 4
  %2 = load ptr, ptr %b.addr, align 8
  %call = call noundef i32 @_ZL14stbtt__buf_getP10stbtt__bufi(ptr noundef %2, i32 noundef 2)
  store i32 %call, ptr %count, align 4
  %3 = load i32, ptr %count, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %b.addr, align 8
  %call1 = call noundef zeroext i8 @_ZL15stbtt__buf_get8P10stbtt__buf(ptr noundef %4)
  %conv = zext i8 %call1 to i32
  store i32 %conv, ptr %offsize, align 4
  br label %do.body

do.body:                                          ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %do.body
  %5 = load ptr, ptr %b.addr, align 8
  %6 = load i32, ptr %offsize, align 4
  %7 = load i32, ptr %count, align 4
  %mul = mul nsw i32 %6, %7
  call void @_ZL15stbtt__buf_skipP10stbtt__bufi(ptr noundef %5, i32 noundef %mul)
  %8 = load ptr, ptr %b.addr, align 8
  %9 = load ptr, ptr %b.addr, align 8
  %10 = load i32, ptr %offsize, align 4
  %call2 = call noundef i32 @_ZL14stbtt__buf_getP10stbtt__bufi(ptr noundef %9, i32 noundef %10)
  %sub = sub i32 %call2, 1
  call void @_ZL15stbtt__buf_skipP10stbtt__bufi(ptr noundef %8, i32 noundef %sub)
  br label %if.end

if.end:                                           ; preds = %do.end, %entry
  %11 = load ptr, ptr %b.addr, align 8
  %12 = load i32, ptr %start, align 4
  %13 = load ptr, ptr %b.addr, align 8
  %cursor3 = getelementptr inbounds %struct.stbtt__buf, ptr %13, i32 0, i32 1
  %14 = load i32, ptr %cursor3, align 8
  %15 = load i32, ptr %start, align 4
  %sub4 = sub nsw i32 %14, %15
  %call5 = call { ptr, i64 } @_ZL16stbtt__buf_rangePK10stbtt__bufii(ptr noundef %11, i32 noundef %12, i32 noundef %sub4)
  %16 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %17 = extractvalue { ptr, i64 } %call5, 0
  store ptr %17, ptr %16, align 8
  %18 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %19 = extractvalue { ptr, i64 } %call5, 1
  store i64 %19, ptr %18, align 8
  %20 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %20
}

; Function Attrs: mustprogress uwtable
define internal { ptr, i64 } @_ZL20stbtt__cff_index_get10stbtt__bufi(ptr %b.coerce0, i64 %b.coerce1, i32 noundef %i) #4 {
entry:
  %retval = alloca %struct.stbtt__buf, align 8
  %b = alloca %struct.stbtt__buf, align 8
  %i.addr = alloca i32, align 4
  %count = alloca i32, align 4
  %offsize = alloca i32, align 4
  %start = alloca i32, align 4
  %end = alloca i32, align 4
  %0 = getelementptr inbounds { ptr, i64 }, ptr %b, i32 0, i32 0
  store ptr %b.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %b, i32 0, i32 1
  store i64 %b.coerce1, ptr %1, align 8
  store i32 %i, ptr %i.addr, align 4
  call void @_ZL15stbtt__buf_seekP10stbtt__bufi(ptr noundef %b, i32 noundef 0)
  %call = call noundef i32 @_ZL14stbtt__buf_getP10stbtt__bufi(ptr noundef %b, i32 noundef 2)
  store i32 %call, ptr %count, align 4
  %call1 = call noundef zeroext i8 @_ZL15stbtt__buf_get8P10stbtt__buf(ptr noundef %b)
  %conv = zext i8 %call1 to i32
  store i32 %conv, ptr %offsize, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body2

do.body2:                                         ; preds = %do.end
  br label %do.end3

do.end3:                                          ; preds = %do.body2
  %2 = load i32, ptr %i.addr, align 4
  %3 = load i32, ptr %offsize, align 4
  %mul = mul nsw i32 %2, %3
  call void @_ZL15stbtt__buf_skipP10stbtt__bufi(ptr noundef %b, i32 noundef %mul)
  %4 = load i32, ptr %offsize, align 4
  %call4 = call noundef i32 @_ZL14stbtt__buf_getP10stbtt__bufi(ptr noundef %b, i32 noundef %4)
  store i32 %call4, ptr %start, align 4
  %5 = load i32, ptr %offsize, align 4
  %call5 = call noundef i32 @_ZL14stbtt__buf_getP10stbtt__bufi(ptr noundef %b, i32 noundef %5)
  store i32 %call5, ptr %end, align 4
  %6 = load i32, ptr %count, align 4
  %add = add nsw i32 %6, 1
  %7 = load i32, ptr %offsize, align 4
  %mul6 = mul nsw i32 %add, %7
  %add7 = add nsw i32 2, %mul6
  %8 = load i32, ptr %start, align 4
  %add8 = add nsw i32 %add7, %8
  %9 = load i32, ptr %end, align 4
  %10 = load i32, ptr %start, align 4
  %sub = sub nsw i32 %9, %10
  %call9 = call { ptr, i64 } @_ZL16stbtt__buf_rangePK10stbtt__bufii(ptr noundef %b, i32 noundef %add8, i32 noundef %sub)
  %11 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %12 = extractvalue { ptr, i64 } %call9, 0
  store ptr %12, ptr %11, align 8
  %13 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %14 = extractvalue { ptr, i64 } %call9, 1
  store i64 %14, ptr %13, align 8
  %15 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %15
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL20stbtt__dict_get_intsP10stbtt__bufiiPj(ptr noundef %b, i32 noundef %key, i32 noundef %outcount, ptr noundef %out) #4 {
entry:
  %b.addr = alloca ptr, align 8
  %key.addr = alloca i32, align 4
  %outcount.addr = alloca i32, align 4
  %out.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  %operands = alloca %struct.stbtt__buf, align 8
  store ptr %b, ptr %b.addr, align 8
  store i32 %key, ptr %key.addr, align 4
  store i32 %outcount, ptr %outcount.addr, align 4
  store ptr %out, ptr %out.addr, align 8
  %0 = load ptr, ptr %b.addr, align 8
  %1 = load i32, ptr %key.addr, align 4
  %call = call { ptr, i64 } @_ZL15stbtt__dict_getP10stbtt__bufi(ptr noundef %0, i32 noundef %1)
  %2 = getelementptr inbounds { ptr, i64 }, ptr %operands, i32 0, i32 0
  %3 = extractvalue { ptr, i64 } %call, 0
  store ptr %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %operands, i32 0, i32 1
  %5 = extractvalue { ptr, i64 } %call, 1
  store i64 %5, ptr %4, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load i32, ptr %i, align 4
  %7 = load i32, ptr %outcount.addr, align 4
  %cmp = icmp slt i32 %6, %7
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %cursor = getelementptr inbounds %struct.stbtt__buf, ptr %operands, i32 0, i32 1
  %8 = load i32, ptr %cursor, align 8
  %size = getelementptr inbounds %struct.stbtt__buf, ptr %operands, i32 0, i32 2
  %9 = load i32, ptr %size, align 4
  %cmp1 = icmp slt i32 %8, %9
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %10 = phi i1 [ false, %for.cond ], [ %cmp1, %land.rhs ]
  br i1 %10, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %call2 = call noundef i32 @_ZL14stbtt__cff_intP10stbtt__buf(ptr noundef %operands)
  %11 = load ptr, ptr %out.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idxprom = sext i32 %12 to i64
  %arrayidx = getelementptr inbounds i32, ptr %11, i64 %idxprom
  store i32 %call2, ptr %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %13 = load i32, ptr %i, align 4
  %inc = add nsw i32 %13, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !108

for.end:                                          ; preds = %land.end
  ret void
}

; Function Attrs: mustprogress uwtable
define internal { ptr, i64 } @_ZL16stbtt__get_subrs10stbtt__bufS_(ptr %cff.coerce0, i64 %cff.coerce1, ptr %fontdict.coerce0, i64 %fontdict.coerce1) #4 {
entry:
  %retval = alloca %struct.stbtt__buf, align 8
  %cff = alloca %struct.stbtt__buf, align 8
  %fontdict = alloca %struct.stbtt__buf, align 8
  %subrsoff = alloca i32, align 4
  %private_loc = alloca [2 x i32], align 4
  %pdict = alloca %struct.stbtt__buf, align 8
  %ref.tmp = alloca %struct.stbtt__buf, align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %cff, i32 0, i32 0
  store ptr %cff.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %cff, i32 0, i32 1
  store i64 %cff.coerce1, ptr %1, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %fontdict, i32 0, i32 0
  store ptr %fontdict.coerce0, ptr %2, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %fontdict, i32 0, i32 1
  store i64 %fontdict.coerce1, ptr %3, align 8
  store i32 0, ptr %subrsoff, align 4
  call void @llvm.memset.p0.i64(ptr align 4 %private_loc, i8 0, i64 8, i1 false)
  %arraydecay = getelementptr inbounds [2 x i32], ptr %private_loc, i64 0, i64 0
  call void @_ZL20stbtt__dict_get_intsP10stbtt__bufiiPj(ptr noundef %fontdict, i32 noundef 18, i32 noundef 2, ptr noundef %arraydecay)
  %arrayidx = getelementptr inbounds [2 x i32], ptr %private_loc, i64 0, i64 1
  %4 = load i32, ptr %arrayidx, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %arrayidx1 = getelementptr inbounds [2 x i32], ptr %private_loc, i64 0, i64 0
  %5 = load i32, ptr %arrayidx1, align 4
  %tobool2 = icmp ne i32 %5, 0
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %call = call { ptr, i64 } @_ZL14stbtt__new_bufPKvm(ptr noundef null, i64 noundef 0)
  %6 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %7 = extractvalue { ptr, i64 } %call, 0
  store ptr %7, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %9 = extractvalue { ptr, i64 } %call, 1
  store i64 %9, ptr %8, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %arrayidx3 = getelementptr inbounds [2 x i32], ptr %private_loc, i64 0, i64 1
  %10 = load i32, ptr %arrayidx3, align 4
  %arrayidx4 = getelementptr inbounds [2 x i32], ptr %private_loc, i64 0, i64 0
  %11 = load i32, ptr %arrayidx4, align 4
  %call5 = call { ptr, i64 } @_ZL16stbtt__buf_rangePK10stbtt__bufii(ptr noundef %cff, i32 noundef %10, i32 noundef %11)
  %12 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 0
  %13 = extractvalue { ptr, i64 } %call5, 0
  store ptr %13, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 1
  %15 = extractvalue { ptr, i64 } %call5, 1
  store i64 %15, ptr %14, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %pdict, ptr align 8 %ref.tmp, i64 16, i1 false)
  call void @_ZL20stbtt__dict_get_intsP10stbtt__bufiiPj(ptr noundef %pdict, i32 noundef 19, i32 noundef 1, ptr noundef %subrsoff)
  %16 = load i32, ptr %subrsoff, align 4
  %tobool6 = icmp ne i32 %16, 0
  br i1 %tobool6, label %if.end9, label %if.then7

if.then7:                                         ; preds = %if.end
  %call8 = call { ptr, i64 } @_ZL14stbtt__new_bufPKvm(ptr noundef null, i64 noundef 0)
  %17 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %18 = extractvalue { ptr, i64 } %call8, 0
  store ptr %18, ptr %17, align 8
  %19 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %20 = extractvalue { ptr, i64 } %call8, 1
  store i64 %20, ptr %19, align 8
  br label %return

if.end9:                                          ; preds = %if.end
  %arrayidx10 = getelementptr inbounds [2 x i32], ptr %private_loc, i64 0, i64 1
  %21 = load i32, ptr %arrayidx10, align 4
  %22 = load i32, ptr %subrsoff, align 4
  %add = add i32 %21, %22
  call void @_ZL15stbtt__buf_seekP10stbtt__bufi(ptr noundef %cff, i32 noundef %add)
  %call11 = call { ptr, i64 } @_ZL20stbtt__cff_get_indexP10stbtt__buf(ptr noundef %cff)
  %23 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %24 = extractvalue { ptr, i64 } %call11, 0
  store ptr %24, ptr %23, align 8
  %25 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %26 = extractvalue { ptr, i64 } %call11, 1
  store i64 %26, ptr %25, align 8
  br label %return

return:                                           ; preds = %if.end9, %if.then7, %if.then
  %27 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %27
}

; Function Attrs: mustprogress nounwind uwtable
define internal { ptr, i64 } @_ZL16stbtt__buf_rangePK10stbtt__bufii(ptr noundef %b, i32 noundef %o, i32 noundef %s) #2 {
entry:
  %retval = alloca %struct.stbtt__buf, align 8
  %b.addr = alloca ptr, align 8
  %o.addr = alloca i32, align 4
  %s.addr = alloca i32, align 4
  store ptr %b, ptr %b.addr, align 8
  store i32 %o, ptr %o.addr, align 4
  store i32 %s, ptr %s.addr, align 4
  %call = call { ptr, i64 } @_ZL14stbtt__new_bufPKvm(ptr noundef null, i64 noundef 0)
  %0 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = load i32, ptr %o.addr, align 4
  %cmp = icmp slt i32 %4, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %5 = load i32, ptr %s.addr, align 4
  %cmp1 = icmp slt i32 %5, 0
  br i1 %cmp1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %6 = load i32, ptr %o.addr, align 4
  %7 = load ptr, ptr %b.addr, align 8
  %size = getelementptr inbounds %struct.stbtt__buf, ptr %7, i32 0, i32 2
  %8 = load i32, ptr %size, align 4
  %cmp3 = icmp sgt i32 %6, %8
  br i1 %cmp3, label %if.then, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false2
  %9 = load i32, ptr %s.addr, align 4
  %10 = load ptr, ptr %b.addr, align 8
  %size5 = getelementptr inbounds %struct.stbtt__buf, ptr %10, i32 0, i32 2
  %11 = load i32, ptr %size5, align 4
  %12 = load i32, ptr %o.addr, align 4
  %sub = sub nsw i32 %11, %12
  %cmp6 = icmp sgt i32 %9, %sub
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false4, %lor.lhs.false2, %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false4
  %13 = load ptr, ptr %b.addr, align 8
  %data = getelementptr inbounds %struct.stbtt__buf, ptr %13, i32 0, i32 0
  %14 = load ptr, ptr %data, align 8
  %15 = load i32, ptr %o.addr, align 4
  %idx.ext = sext i32 %15 to i64
  %add.ptr = getelementptr inbounds i8, ptr %14, i64 %idx.ext
  %data7 = getelementptr inbounds %struct.stbtt__buf, ptr %retval, i32 0, i32 0
  store ptr %add.ptr, ptr %data7, align 8
  %16 = load i32, ptr %s.addr, align 4
  %size8 = getelementptr inbounds %struct.stbtt__buf, ptr %retval, i32 0, i32 2
  store i32 %16, ptr %size8, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %17 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %17
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %p) #2 {
entry:
  %p.addr = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %0, i64 0
  %1 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %1 to i32
  %mul = mul nsw i32 %conv, 256
  %2 = load ptr, ptr %p.addr, align 8
  %arrayidx1 = getelementptr inbounds i8, ptr %2, i64 1
  %3 = load i8, ptr %arrayidx1, align 1
  %conv2 = zext i8 %3 to i32
  %add = add nsw i32 %mul, %conv2
  %conv3 = trunc i32 %add to i16
  ret i16 %conv3
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZL14stbtt__buf_getP10stbtt__bufi(ptr noundef %b, i32 noundef %n) #2 {
entry:
  %b.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %v = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %b, ptr %b.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  store i32 0, ptr %v, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %0 = load i32, ptr %i, align 4
  %1 = load i32, ptr %n.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32, ptr %v, align 4
  %shl = shl i32 %2, 8
  %3 = load ptr, ptr %b.addr, align 8
  %call = call noundef zeroext i8 @_ZL15stbtt__buf_get8P10stbtt__buf(ptr noundef %3)
  %conv = zext i8 %call to i32
  %or = or i32 %shl, %conv
  store i32 %or, ptr %v, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %4 = load i32, ptr %i, align 4
  %inc = add nsw i32 %4, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !109

for.end:                                          ; preds = %for.cond
  %5 = load i32, ptr %v, align 4
  ret i32 %5
}

; Function Attrs: mustprogress uwtable
define internal { ptr, i64 } @_ZL15stbtt__dict_getP10stbtt__bufi(ptr noundef %b, i32 noundef %key) #4 {
entry:
  %retval = alloca %struct.stbtt__buf, align 8
  %b.addr = alloca ptr, align 8
  %key.addr = alloca i32, align 4
  %start = alloca i32, align 4
  %end = alloca i32, align 4
  %op = alloca i32, align 4
  store ptr %b, ptr %b.addr, align 8
  store i32 %key, ptr %key.addr, align 4
  %0 = load ptr, ptr %b.addr, align 8
  call void @_ZL15stbtt__buf_seekP10stbtt__bufi(ptr noundef %0, i32 noundef 0)
  br label %while.cond

while.cond:                                       ; preds = %if.end14, %entry
  %1 = load ptr, ptr %b.addr, align 8
  %cursor = getelementptr inbounds %struct.stbtt__buf, ptr %1, i32 0, i32 1
  %2 = load i32, ptr %cursor, align 8
  %3 = load ptr, ptr %b.addr, align 8
  %size = getelementptr inbounds %struct.stbtt__buf, ptr %3, i32 0, i32 2
  %4 = load i32, ptr %size, align 4
  %cmp = icmp slt i32 %2, %4
  br i1 %cmp, label %while.body, label %while.end15

while.body:                                       ; preds = %while.cond
  %5 = load ptr, ptr %b.addr, align 8
  %cursor1 = getelementptr inbounds %struct.stbtt__buf, ptr %5, i32 0, i32 1
  %6 = load i32, ptr %cursor1, align 8
  store i32 %6, ptr %start, align 4
  br label %while.cond2

while.cond2:                                      ; preds = %while.body4, %while.body
  %7 = load ptr, ptr %b.addr, align 8
  %call = call noundef zeroext i8 @_ZL16stbtt__buf_peek8P10stbtt__buf(ptr noundef %7)
  %conv = zext i8 %call to i32
  %cmp3 = icmp sge i32 %conv, 28
  br i1 %cmp3, label %while.body4, label %while.end

while.body4:                                      ; preds = %while.cond2
  %8 = load ptr, ptr %b.addr, align 8
  call void @_ZL23stbtt__cff_skip_operandP10stbtt__buf(ptr noundef %8)
  br label %while.cond2, !llvm.loop !110

while.end:                                        ; preds = %while.cond2
  %9 = load ptr, ptr %b.addr, align 8
  %cursor5 = getelementptr inbounds %struct.stbtt__buf, ptr %9, i32 0, i32 1
  %10 = load i32, ptr %cursor5, align 8
  store i32 %10, ptr %end, align 4
  %11 = load ptr, ptr %b.addr, align 8
  %call6 = call noundef zeroext i8 @_ZL15stbtt__buf_get8P10stbtt__buf(ptr noundef %11)
  %conv7 = zext i8 %call6 to i32
  store i32 %conv7, ptr %op, align 4
  %12 = load i32, ptr %op, align 4
  %cmp8 = icmp eq i32 %12, 12
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %while.end
  %13 = load ptr, ptr %b.addr, align 8
  %call9 = call noundef zeroext i8 @_ZL15stbtt__buf_get8P10stbtt__buf(ptr noundef %13)
  %conv10 = zext i8 %call9 to i32
  %or = or i32 %conv10, 256
  store i32 %or, ptr %op, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %while.end
  %14 = load i32, ptr %op, align 4
  %15 = load i32, ptr %key.addr, align 4
  %cmp11 = icmp eq i32 %14, %15
  br i1 %cmp11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end
  %16 = load ptr, ptr %b.addr, align 8
  %17 = load i32, ptr %start, align 4
  %18 = load i32, ptr %end, align 4
  %19 = load i32, ptr %start, align 4
  %sub = sub nsw i32 %18, %19
  %call13 = call { ptr, i64 } @_ZL16stbtt__buf_rangePK10stbtt__bufii(ptr noundef %16, i32 noundef %17, i32 noundef %sub)
  %20 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %21 = extractvalue { ptr, i64 } %call13, 0
  store ptr %21, ptr %20, align 8
  %22 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %23 = extractvalue { ptr, i64 } %call13, 1
  store i64 %23, ptr %22, align 8
  br label %return

if.end14:                                         ; preds = %if.end
  br label %while.cond, !llvm.loop !111

while.end15:                                      ; preds = %while.cond
  %24 = load ptr, ptr %b.addr, align 8
  %call16 = call { ptr, i64 } @_ZL16stbtt__buf_rangePK10stbtt__bufii(ptr noundef %24, i32 noundef 0, i32 noundef 0)
  %25 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %26 = extractvalue { ptr, i64 } %call16, 0
  store ptr %26, ptr %25, align 8
  %27 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %28 = extractvalue { ptr, i64 } %call16, 1
  store i64 %28, ptr %27, align 8
  br label %return

return:                                           ; preds = %while.end15, %if.then12
  %29 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %29
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZL14stbtt__cff_intP10stbtt__buf(ptr noundef %b) #2 {
entry:
  %retval = alloca i32, align 4
  %b.addr = alloca ptr, align 8
  %b0 = alloca i32, align 4
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %b.addr, align 8
  %call = call noundef zeroext i8 @_ZL15stbtt__buf_get8P10stbtt__buf(ptr noundef %0)
  %conv = zext i8 %call to i32
  store i32 %conv, ptr %b0, align 4
  %1 = load i32, ptr %b0, align 4
  %cmp = icmp sge i32 %1, 32
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %2 = load i32, ptr %b0, align 4
  %cmp1 = icmp sle i32 %2, 246
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %3 = load i32, ptr %b0, align 4
  %sub = sub nsw i32 %3, 139
  store i32 %sub, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %land.lhs.true, %entry
  %4 = load i32, ptr %b0, align 4
  %cmp2 = icmp sge i32 %4, 247
  br i1 %cmp2, label %land.lhs.true3, label %if.else10

land.lhs.true3:                                   ; preds = %if.else
  %5 = load i32, ptr %b0, align 4
  %cmp4 = icmp sle i32 %5, 250
  br i1 %cmp4, label %if.then5, label %if.else10

if.then5:                                         ; preds = %land.lhs.true3
  %6 = load i32, ptr %b0, align 4
  %sub6 = sub nsw i32 %6, 247
  %mul = mul nsw i32 %sub6, 256
  %7 = load ptr, ptr %b.addr, align 8
  %call7 = call noundef zeroext i8 @_ZL15stbtt__buf_get8P10stbtt__buf(ptr noundef %7)
  %conv8 = zext i8 %call7 to i32
  %add = add nsw i32 %mul, %conv8
  %add9 = add nsw i32 %add, 108
  store i32 %add9, ptr %retval, align 4
  br label %return

if.else10:                                        ; preds = %land.lhs.true3, %if.else
  %8 = load i32, ptr %b0, align 4
  %cmp11 = icmp sge i32 %8, 251
  br i1 %cmp11, label %land.lhs.true12, label %if.else22

land.lhs.true12:                                  ; preds = %if.else10
  %9 = load i32, ptr %b0, align 4
  %cmp13 = icmp sle i32 %9, 254
  br i1 %cmp13, label %if.then14, label %if.else22

if.then14:                                        ; preds = %land.lhs.true12
  %10 = load i32, ptr %b0, align 4
  %sub15 = sub nsw i32 %10, 251
  %sub16 = sub nsw i32 0, %sub15
  %mul17 = mul nsw i32 %sub16, 256
  %11 = load ptr, ptr %b.addr, align 8
  %call18 = call noundef zeroext i8 @_ZL15stbtt__buf_get8P10stbtt__buf(ptr noundef %11)
  %conv19 = zext i8 %call18 to i32
  %sub20 = sub nsw i32 %mul17, %conv19
  %sub21 = sub nsw i32 %sub20, 108
  store i32 %sub21, ptr %retval, align 4
  br label %return

if.else22:                                        ; preds = %land.lhs.true12, %if.else10
  %12 = load i32, ptr %b0, align 4
  %cmp23 = icmp eq i32 %12, 28
  br i1 %cmp23, label %if.then24, label %if.else26

if.then24:                                        ; preds = %if.else22
  %13 = load ptr, ptr %b.addr, align 8
  %call25 = call noundef i32 @_ZL14stbtt__buf_getP10stbtt__bufi(ptr noundef %13, i32 noundef 2)
  store i32 %call25, ptr %retval, align 4
  br label %return

if.else26:                                        ; preds = %if.else22
  %14 = load i32, ptr %b0, align 4
  %cmp27 = icmp eq i32 %14, 29
  br i1 %cmp27, label %if.then28, label %if.end

if.then28:                                        ; preds = %if.else26
  %15 = load ptr, ptr %b.addr, align 8
  %call29 = call noundef i32 @_ZL14stbtt__buf_getP10stbtt__bufi(ptr noundef %15, i32 noundef 4)
  store i32 %call29, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else26
  br label %if.end30

if.end30:                                         ; preds = %if.end
  br label %if.end31

if.end31:                                         ; preds = %if.end30
  br label %if.end32

if.end32:                                         ; preds = %if.end31
  br label %if.end33

if.end33:                                         ; preds = %if.end32
  br label %do.body

do.body:                                          ; preds = %if.end33
  br label %do.end

do.end:                                           ; preds = %do.body
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %do.end, %if.then28, %if.then24, %if.then14, %if.then5, %if.then
  %16 = load i32, ptr %retval, align 4
  ret i32 %16
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef zeroext i8 @_ZL16stbtt__buf_peek8P10stbtt__buf(ptr noundef %b) #2 {
entry:
  %retval = alloca i8, align 1
  %b.addr = alloca ptr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %b.addr, align 8
  %cursor = getelementptr inbounds %struct.stbtt__buf, ptr %0, i32 0, i32 1
  %1 = load i32, ptr %cursor, align 8
  %2 = load ptr, ptr %b.addr, align 8
  %size = getelementptr inbounds %struct.stbtt__buf, ptr %2, i32 0, i32 2
  %3 = load i32, ptr %size, align 4
  %cmp = icmp sge i32 %1, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8 0, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %b.addr, align 8
  %data = getelementptr inbounds %struct.stbtt__buf, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %data, align 8
  %6 = load ptr, ptr %b.addr, align 8
  %cursor1 = getelementptr inbounds %struct.stbtt__buf, ptr %6, i32 0, i32 1
  %7 = load i32, ptr %cursor1, align 8
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr inbounds i8, ptr %5, i64 %idxprom
  %8 = load i8, ptr %arrayidx, align 1
  store i8 %8, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %9 = load i8, ptr %retval, align 1
  ret i8 %9
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL23stbtt__cff_skip_operandP10stbtt__buf(ptr noundef %b) #4 {
entry:
  %b.addr = alloca ptr, align 8
  %v = alloca i32, align 4
  %b0 = alloca i32, align 4
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %b.addr, align 8
  %call = call noundef zeroext i8 @_ZL16stbtt__buf_peek8P10stbtt__buf(ptr noundef %0)
  %conv = zext i8 %call to i32
  store i32 %conv, ptr %b0, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %1 = load i32, ptr %b0, align 4
  %cmp = icmp eq i32 %1, 30
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %do.end
  %2 = load ptr, ptr %b.addr, align 8
  call void @_ZL15stbtt__buf_skipP10stbtt__bufi(ptr noundef %2, i32 noundef 1)
  br label %while.cond

while.cond:                                       ; preds = %if.end, %if.then
  %3 = load ptr, ptr %b.addr, align 8
  %cursor = getelementptr inbounds %struct.stbtt__buf, ptr %3, i32 0, i32 1
  %4 = load i32, ptr %cursor, align 8
  %5 = load ptr, ptr %b.addr, align 8
  %size = getelementptr inbounds %struct.stbtt__buf, ptr %5, i32 0, i32 2
  %6 = load i32, ptr %size, align 4
  %cmp1 = icmp slt i32 %4, %6
  br i1 %cmp1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load ptr, ptr %b.addr, align 8
  %call2 = call noundef zeroext i8 @_ZL15stbtt__buf_get8P10stbtt__buf(ptr noundef %7)
  %conv3 = zext i8 %call2 to i32
  store i32 %conv3, ptr %v, align 4
  %8 = load i32, ptr %v, align 4
  %and = and i32 %8, 15
  %cmp4 = icmp eq i32 %and, 15
  br i1 %cmp4, label %if.then6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %9 = load i32, ptr %v, align 4
  %shr = ashr i32 %9, 4
  %cmp5 = icmp eq i32 %shr, 15
  br i1 %cmp5, label %if.then6, label %if.end

if.then6:                                         ; preds = %lor.lhs.false, %while.body
  br label %while.end

if.end:                                           ; preds = %lor.lhs.false
  br label %while.cond, !llvm.loop !112

while.end:                                        ; preds = %if.then6, %while.cond
  br label %if.end8

if.else:                                          ; preds = %do.end
  %10 = load ptr, ptr %b.addr, align 8
  %call7 = call noundef i32 @_ZL14stbtt__cff_intP10stbtt__buf(ptr noundef %10)
  br label %if.end8

if.end8:                                          ; preds = %if.else, %while.end
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorIjE6resizeEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_size) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_size.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_size, ptr %new_size.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_size.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.13, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sgt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %new_size.addr, align 4
  %call = call noundef i32 @_ZNK8ImVectorIjE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %2)
  call void @_ZN8ImVectorIjE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %new_size.addr, align 4
  %Size = getelementptr inbounds %struct.ImVector.13, ptr %this1, i32 0, i32 0
  store i32 %3, ptr %Size, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorIjE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.13, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 4
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.13, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.13, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.13, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %4, ptr align 4 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.13, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.13, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.13, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorIjE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.13, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.13, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.13, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %p) #2 {
entry:
  %p.addr = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %0, i64 0
  %1 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %1 to i32
  %mul = mul nsw i32 %conv, 256
  %2 = load ptr, ptr %p.addr, align 8
  %arrayidx1 = getelementptr inbounds i8, ptr %2, i64 1
  %3 = load i8, ptr %arrayidx1, align 1
  %conv2 = zext i8 %3 to i32
  %add = add nsw i32 %mul, %conv2
  %conv3 = trunc i32 %add to i16
  ret i16 %conv3
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_Z16ImBitArraySetBitPji(ptr noundef %arr, i32 noundef %n) #2 comdat {
entry:
  %arr.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %mask = alloca i32, align 4
  store ptr %arr, ptr %arr.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %0 = load i32, ptr %n.addr, align 4
  %and = and i32 %0, 31
  %shl = shl i32 1, %and
  store i32 %shl, ptr %mask, align 4
  %1 = load i32, ptr %mask, align 4
  %2 = load ptr, ptr %arr.addr, align 8
  %3 = load i32, ptr %n.addr, align 4
  %shr = ashr i32 %3, 5
  %idxprom = sext i32 %shr to i64
  %arrayidx = getelementptr inbounds i32, ptr %2, i64 %idxprom
  %4 = load i32, ptr %arrayidx, align 4
  %or = or i32 %4, %1
  store i32 %or, ptr %arrayidx, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZNK8ImVectorIjE5beginEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.13, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef ptr @_ZNK8ImVectorIjE3endEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.13, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %Size = getelementptr inbounds %struct.ImVector.13, ptr %this1, i32 0, i32 0
  %1 = load i32, ptr %Size, align 8
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr inbounds i32, ptr %0, i64 %idx.ext
  ret ptr %add.ptr
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorIiE9push_backERKi(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 4 dereferenceable(4) %v) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %v.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Size = getelementptr inbounds %struct.ImVector.16, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %Size, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.16, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Size2 = getelementptr inbounds %struct.ImVector.16, ptr %this1, i32 0, i32 0
  %2 = load i32, ptr %Size2, align 8
  %add = add nsw i32 %2, 1
  %call = call noundef i32 @_ZNK8ImVectorIiE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %add)
  call void @_ZN8ImVectorIiE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this1, i32 noundef %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %Data = getelementptr inbounds %struct.ImVector.16, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %Size3 = getelementptr inbounds %struct.ImVector.16, ptr %this1, i32 0, i32 0
  %4 = load i32, ptr %Size3, align 8
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds i32, ptr %3, i64 %idxprom
  %5 = load ptr, ptr %v.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx, ptr align 4 %5, i64 4, i1 false)
  %Size4 = getelementptr inbounds %struct.ImVector.16, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size4, align 8
  %inc = add nsw i32 %6, 1
  store i32 %inc, ptr %Size4, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorIiE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.16, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.16, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.16, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorIjE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.13, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Capacity = getelementptr inbounds %struct.ImVector.13, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.13, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data2 = getelementptr inbounds %struct.ImVector.13, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
  %Data3 = getelementptr inbounds %struct.ImVector.13, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI16stbtt_packedcharE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 28
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 28
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %4, ptr align 4 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorI16stbtt_packedcharE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.17, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

; Function Attrs: mustprogress uwtable
define internal noundef i32 @_ZL17stbtt_GetGlyphBoxPK14stbtt_fontinfoiPiS2_S2_S2_(ptr noundef %info, i32 noundef %glyph_index, ptr noundef %x0, ptr noundef %y0, ptr noundef %x1, ptr noundef %y1) #4 {
entry:
  %retval = alloca i32, align 4
  %info.addr = alloca ptr, align 8
  %glyph_index.addr = alloca i32, align 4
  %x0.addr = alloca ptr, align 8
  %y0.addr = alloca ptr, align 8
  %x1.addr = alloca ptr, align 8
  %y1.addr = alloca ptr, align 8
  %g = alloca i32, align 4
  store ptr %info, ptr %info.addr, align 8
  store i32 %glyph_index, ptr %glyph_index.addr, align 4
  store ptr %x0, ptr %x0.addr, align 8
  store ptr %y0, ptr %y0.addr, align 8
  store ptr %x1, ptr %x1.addr, align 8
  store ptr %y1, ptr %y1.addr, align 8
  %0 = load ptr, ptr %info.addr, align 8
  %cff = getelementptr inbounds %struct.stbtt_fontinfo, ptr %0, i32 0, i32 14
  %size = getelementptr inbounds %struct.stbtt__buf, ptr %cff, i32 0, i32 2
  %1 = load i32, ptr %size, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %info.addr, align 8
  %3 = load i32, ptr %glyph_index.addr, align 4
  %4 = load ptr, ptr %x0.addr, align 8
  %5 = load ptr, ptr %y0.addr, align 8
  %6 = load ptr, ptr %x1.addr, align 8
  %7 = load ptr, ptr %y1.addr, align 8
  %call = call noundef i32 @_ZL21stbtt__GetGlyphInfoT2PK14stbtt_fontinfoiPiS2_S2_S2_(ptr noundef %2, i32 noundef %3, ptr noundef %4, ptr noundef %5, ptr noundef %6, ptr noundef %7)
  br label %if.end35

if.else:                                          ; preds = %entry
  %8 = load ptr, ptr %info.addr, align 8
  %9 = load i32, ptr %glyph_index.addr, align 4
  %call1 = call noundef i32 @_ZL20stbtt__GetGlyfOffsetPK14stbtt_fontinfoi(ptr noundef %8, i32 noundef %9)
  store i32 %call1, ptr %g, align 4
  %10 = load i32, ptr %g, align 4
  %cmp = icmp slt i32 %10, 0
  br i1 %cmp, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else
  %11 = load ptr, ptr %x0.addr, align 8
  %tobool3 = icmp ne ptr %11, null
  br i1 %tobool3, label %if.then4, label %if.end7

if.then4:                                         ; preds = %if.end
  %12 = load ptr, ptr %info.addr, align 8
  %data = getelementptr inbounds %struct.stbtt_fontinfo, ptr %12, i32 0, i32 1
  %13 = load ptr, ptr %data, align 8
  %14 = load i32, ptr %g, align 4
  %idx.ext = sext i32 %14 to i64
  %add.ptr = getelementptr inbounds i8, ptr %13, i64 %idx.ext
  %add.ptr5 = getelementptr inbounds i8, ptr %add.ptr, i64 2
  %call6 = call noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %add.ptr5)
  %conv = sext i16 %call6 to i32
  %15 = load ptr, ptr %x0.addr, align 8
  store i32 %conv, ptr %15, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.then4, %if.end
  %16 = load ptr, ptr %y0.addr, align 8
  %tobool8 = icmp ne ptr %16, null
  br i1 %tobool8, label %if.then9, label %if.end16

if.then9:                                         ; preds = %if.end7
  %17 = load ptr, ptr %info.addr, align 8
  %data10 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %17, i32 0, i32 1
  %18 = load ptr, ptr %data10, align 8
  %19 = load i32, ptr %g, align 4
  %idx.ext11 = sext i32 %19 to i64
  %add.ptr12 = getelementptr inbounds i8, ptr %18, i64 %idx.ext11
  %add.ptr13 = getelementptr inbounds i8, ptr %add.ptr12, i64 4
  %call14 = call noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %add.ptr13)
  %conv15 = sext i16 %call14 to i32
  %20 = load ptr, ptr %y0.addr, align 8
  store i32 %conv15, ptr %20, align 4
  br label %if.end16

if.end16:                                         ; preds = %if.then9, %if.end7
  %21 = load ptr, ptr %x1.addr, align 8
  %tobool17 = icmp ne ptr %21, null
  br i1 %tobool17, label %if.then18, label %if.end25

if.then18:                                        ; preds = %if.end16
  %22 = load ptr, ptr %info.addr, align 8
  %data19 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %22, i32 0, i32 1
  %23 = load ptr, ptr %data19, align 8
  %24 = load i32, ptr %g, align 4
  %idx.ext20 = sext i32 %24 to i64
  %add.ptr21 = getelementptr inbounds i8, ptr %23, i64 %idx.ext20
  %add.ptr22 = getelementptr inbounds i8, ptr %add.ptr21, i64 6
  %call23 = call noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %add.ptr22)
  %conv24 = sext i16 %call23 to i32
  %25 = load ptr, ptr %x1.addr, align 8
  store i32 %conv24, ptr %25, align 4
  br label %if.end25

if.end25:                                         ; preds = %if.then18, %if.end16
  %26 = load ptr, ptr %y1.addr, align 8
  %tobool26 = icmp ne ptr %26, null
  br i1 %tobool26, label %if.then27, label %if.end34

if.then27:                                        ; preds = %if.end25
  %27 = load ptr, ptr %info.addr, align 8
  %data28 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %27, i32 0, i32 1
  %28 = load ptr, ptr %data28, align 8
  %29 = load i32, ptr %g, align 4
  %idx.ext29 = sext i32 %29 to i64
  %add.ptr30 = getelementptr inbounds i8, ptr %28, i64 %idx.ext29
  %add.ptr31 = getelementptr inbounds i8, ptr %add.ptr30, i64 8
  %call32 = call noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %add.ptr31)
  %conv33 = sext i16 %call32 to i32
  %30 = load ptr, ptr %y1.addr, align 8
  store i32 %conv33, ptr %30, align 4
  br label %if.end34

if.end34:                                         ; preds = %if.then27, %if.end25
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.then
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end35, %if.then2
  %31 = load i32, ptr %retval, align 4
  ret i32 %31
}

; Function Attrs: mustprogress uwtable
define internal noundef i32 @_ZL21stbtt__GetGlyphInfoT2PK14stbtt_fontinfoiPiS2_S2_S2_(ptr noundef %info, i32 noundef %glyph_index, ptr noundef %x0, ptr noundef %y0, ptr noundef %x1, ptr noundef %y1) #4 {
entry:
  %info.addr = alloca ptr, align 8
  %glyph_index.addr = alloca i32, align 4
  %x0.addr = alloca ptr, align 8
  %y0.addr = alloca ptr, align 8
  %x1.addr = alloca ptr, align 8
  %y1.addr = alloca ptr, align 8
  %c = alloca %struct.stbtt__csctx, align 8
  %r = alloca i32, align 4
  store ptr %info, ptr %info.addr, align 8
  store i32 %glyph_index, ptr %glyph_index.addr, align 4
  store ptr %x0, ptr %x0.addr, align 8
  store ptr %y0, ptr %y0.addr, align 8
  store ptr %x1, ptr %x1.addr, align 8
  store ptr %y1, ptr %y1.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %c, i8 0, i64 56, i1 false)
  %0 = getelementptr inbounds %struct.stbtt__csctx, ptr %c, i32 0, i32 0
  store i32 1, ptr %0, align 8
  %1 = load ptr, ptr %info.addr, align 8
  %2 = load i32, ptr %glyph_index.addr, align 4
  %call = call noundef i32 @_ZL21stbtt__run_charstringPK14stbtt_fontinfoiP12stbtt__csctx(ptr noundef %1, i32 noundef %2, ptr noundef %c)
  store i32 %call, ptr %r, align 4
  %3 = load ptr, ptr %x0.addr, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, ptr %r, align 4
  %tobool1 = icmp ne i32 %4, 0
  br i1 %tobool1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %min_x = getelementptr inbounds %struct.stbtt__csctx, ptr %c, i32 0, i32 6
  %5 = load i32, ptr %min_x, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %5, %cond.true ], [ 0, %cond.false ]
  %6 = load ptr, ptr %x0.addr, align 8
  store i32 %cond, ptr %6, align 4
  br label %if.end

if.end:                                           ; preds = %cond.end, %entry
  %7 = load ptr, ptr %y0.addr, align 8
  %tobool2 = icmp ne ptr %7, null
  br i1 %tobool2, label %if.then3, label %if.end9

if.then3:                                         ; preds = %if.end
  %8 = load i32, ptr %r, align 4
  %tobool4 = icmp ne i32 %8, 0
  br i1 %tobool4, label %cond.true5, label %cond.false6

cond.true5:                                       ; preds = %if.then3
  %min_y = getelementptr inbounds %struct.stbtt__csctx, ptr %c, i32 0, i32 8
  %9 = load i32, ptr %min_y, align 8
  br label %cond.end7

cond.false6:                                      ; preds = %if.then3
  br label %cond.end7

cond.end7:                                        ; preds = %cond.false6, %cond.true5
  %cond8 = phi i32 [ %9, %cond.true5 ], [ 0, %cond.false6 ]
  %10 = load ptr, ptr %y0.addr, align 8
  store i32 %cond8, ptr %10, align 4
  br label %if.end9

if.end9:                                          ; preds = %cond.end7, %if.end
  %11 = load ptr, ptr %x1.addr, align 8
  %tobool10 = icmp ne ptr %11, null
  br i1 %tobool10, label %if.then11, label %if.end17

if.then11:                                        ; preds = %if.end9
  %12 = load i32, ptr %r, align 4
  %tobool12 = icmp ne i32 %12, 0
  br i1 %tobool12, label %cond.true13, label %cond.false14

cond.true13:                                      ; preds = %if.then11
  %max_x = getelementptr inbounds %struct.stbtt__csctx, ptr %c, i32 0, i32 7
  %13 = load i32, ptr %max_x, align 4
  br label %cond.end15

cond.false14:                                     ; preds = %if.then11
  br label %cond.end15

cond.end15:                                       ; preds = %cond.false14, %cond.true13
  %cond16 = phi i32 [ %13, %cond.true13 ], [ 0, %cond.false14 ]
  %14 = load ptr, ptr %x1.addr, align 8
  store i32 %cond16, ptr %14, align 4
  br label %if.end17

if.end17:                                         ; preds = %cond.end15, %if.end9
  %15 = load ptr, ptr %y1.addr, align 8
  %tobool18 = icmp ne ptr %15, null
  br i1 %tobool18, label %if.then19, label %if.end25

if.then19:                                        ; preds = %if.end17
  %16 = load i32, ptr %r, align 4
  %tobool20 = icmp ne i32 %16, 0
  br i1 %tobool20, label %cond.true21, label %cond.false22

cond.true21:                                      ; preds = %if.then19
  %max_y = getelementptr inbounds %struct.stbtt__csctx, ptr %c, i32 0, i32 9
  %17 = load i32, ptr %max_y, align 4
  br label %cond.end23

cond.false22:                                     ; preds = %if.then19
  br label %cond.end23

cond.end23:                                       ; preds = %cond.false22, %cond.true21
  %cond24 = phi i32 [ %17, %cond.true21 ], [ 0, %cond.false22 ]
  %18 = load ptr, ptr %y1.addr, align 8
  store i32 %cond24, ptr %18, align 4
  br label %if.end25

if.end25:                                         ; preds = %cond.end23, %if.end17
  %19 = load i32, ptr %r, align 4
  %tobool26 = icmp ne i32 %19, 0
  br i1 %tobool26, label %cond.true27, label %cond.false28

cond.true27:                                      ; preds = %if.end25
  %num_vertices = getelementptr inbounds %struct.stbtt__csctx, ptr %c, i32 0, i32 11
  %20 = load i32, ptr %num_vertices, align 8
  br label %cond.end29

cond.false28:                                     ; preds = %if.end25
  br label %cond.end29

cond.end29:                                       ; preds = %cond.false28, %cond.true27
  %cond30 = phi i32 [ %20, %cond.true27 ], [ 0, %cond.false28 ]
  ret i32 %cond30
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZL20stbtt__GetGlyfOffsetPK14stbtt_fontinfoi(ptr noundef %info, i32 noundef %glyph_index) #2 {
entry:
  %retval = alloca i32, align 4
  %info.addr = alloca ptr, align 8
  %glyph_index.addr = alloca i32, align 4
  %g1 = alloca i32, align 4
  %g2 = alloca i32, align 4
  store ptr %info, ptr %info.addr, align 8
  store i32 %glyph_index, ptr %glyph_index.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load i32, ptr %glyph_index.addr, align 4
  %1 = load ptr, ptr %info.addr, align 8
  %numGlyphs = getelementptr inbounds %struct.stbtt_fontinfo, ptr %1, i32 0, i32 3
  %2 = load i32, ptr %numGlyphs, align 4
  %cmp = icmp sge i32 %0, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %do.end
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %do.end
  %3 = load ptr, ptr %info.addr, align 8
  %indexToLocFormat = getelementptr inbounds %struct.stbtt_fontinfo, ptr %3, i32 0, i32 13
  %4 = load i32, ptr %indexToLocFormat, align 4
  %cmp1 = icmp sge i32 %4, 2
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 -1, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %5 = load ptr, ptr %info.addr, align 8
  %indexToLocFormat4 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %5, i32 0, i32 13
  %6 = load i32, ptr %indexToLocFormat4, align 4
  %cmp5 = icmp eq i32 %6, 0
  br i1 %cmp5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end3
  %7 = load ptr, ptr %info.addr, align 8
  %glyf = getelementptr inbounds %struct.stbtt_fontinfo, ptr %7, i32 0, i32 6
  %8 = load i32, ptr %glyf, align 8
  %9 = load ptr, ptr %info.addr, align 8
  %data = getelementptr inbounds %struct.stbtt_fontinfo, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %data, align 8
  %11 = load ptr, ptr %info.addr, align 8
  %loca = getelementptr inbounds %struct.stbtt_fontinfo, ptr %11, i32 0, i32 4
  %12 = load i32, ptr %loca, align 8
  %idx.ext = sext i32 %12 to i64
  %add.ptr = getelementptr inbounds i8, ptr %10, i64 %idx.ext
  %13 = load i32, ptr %glyph_index.addr, align 4
  %mul = mul nsw i32 %13, 2
  %idx.ext7 = sext i32 %mul to i64
  %add.ptr8 = getelementptr inbounds i8, ptr %add.ptr, i64 %idx.ext7
  %call = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr8)
  %conv = zext i16 %call to i32
  %mul9 = mul nsw i32 %conv, 2
  %add = add nsw i32 %8, %mul9
  store i32 %add, ptr %g1, align 4
  %14 = load ptr, ptr %info.addr, align 8
  %glyf10 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %14, i32 0, i32 6
  %15 = load i32, ptr %glyf10, align 8
  %16 = load ptr, ptr %info.addr, align 8
  %data11 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %16, i32 0, i32 1
  %17 = load ptr, ptr %data11, align 8
  %18 = load ptr, ptr %info.addr, align 8
  %loca12 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %18, i32 0, i32 4
  %19 = load i32, ptr %loca12, align 8
  %idx.ext13 = sext i32 %19 to i64
  %add.ptr14 = getelementptr inbounds i8, ptr %17, i64 %idx.ext13
  %20 = load i32, ptr %glyph_index.addr, align 4
  %mul15 = mul nsw i32 %20, 2
  %idx.ext16 = sext i32 %mul15 to i64
  %add.ptr17 = getelementptr inbounds i8, ptr %add.ptr14, i64 %idx.ext16
  %add.ptr18 = getelementptr inbounds i8, ptr %add.ptr17, i64 2
  %call19 = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr18)
  %conv20 = zext i16 %call19 to i32
  %mul21 = mul nsw i32 %conv20, 2
  %add22 = add nsw i32 %15, %mul21
  store i32 %add22, ptr %g2, align 4
  br label %if.end44

if.else:                                          ; preds = %if.end3
  %21 = load ptr, ptr %info.addr, align 8
  %glyf23 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %21, i32 0, i32 6
  %22 = load i32, ptr %glyf23, align 8
  %23 = load ptr, ptr %info.addr, align 8
  %data24 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %23, i32 0, i32 1
  %24 = load ptr, ptr %data24, align 8
  %25 = load ptr, ptr %info.addr, align 8
  %loca25 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %25, i32 0, i32 4
  %26 = load i32, ptr %loca25, align 8
  %idx.ext26 = sext i32 %26 to i64
  %add.ptr27 = getelementptr inbounds i8, ptr %24, i64 %idx.ext26
  %27 = load i32, ptr %glyph_index.addr, align 4
  %mul28 = mul nsw i32 %27, 4
  %idx.ext29 = sext i32 %mul28 to i64
  %add.ptr30 = getelementptr inbounds i8, ptr %add.ptr27, i64 %idx.ext29
  %call31 = call noundef i32 @_ZL7ttULONGPh(ptr noundef %add.ptr30)
  %add32 = add i32 %22, %call31
  store i32 %add32, ptr %g1, align 4
  %28 = load ptr, ptr %info.addr, align 8
  %glyf33 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %28, i32 0, i32 6
  %29 = load i32, ptr %glyf33, align 8
  %30 = load ptr, ptr %info.addr, align 8
  %data34 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %30, i32 0, i32 1
  %31 = load ptr, ptr %data34, align 8
  %32 = load ptr, ptr %info.addr, align 8
  %loca35 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %32, i32 0, i32 4
  %33 = load i32, ptr %loca35, align 8
  %idx.ext36 = sext i32 %33 to i64
  %add.ptr37 = getelementptr inbounds i8, ptr %31, i64 %idx.ext36
  %34 = load i32, ptr %glyph_index.addr, align 4
  %mul38 = mul nsw i32 %34, 4
  %idx.ext39 = sext i32 %mul38 to i64
  %add.ptr40 = getelementptr inbounds i8, ptr %add.ptr37, i64 %idx.ext39
  %add.ptr41 = getelementptr inbounds i8, ptr %add.ptr40, i64 4
  %call42 = call noundef i32 @_ZL7ttULONGPh(ptr noundef %add.ptr41)
  %add43 = add i32 %29, %call42
  store i32 %add43, ptr %g2, align 4
  br label %if.end44

if.end44:                                         ; preds = %if.else, %if.then6
  %35 = load i32, ptr %g1, align 4
  %36 = load i32, ptr %g2, align 4
  %cmp45 = icmp eq i32 %35, %36
  br i1 %cmp45, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end44
  br label %cond.end

cond.false:                                       ; preds = %if.end44
  %37 = load i32, ptr %g1, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ -1, %cond.true ], [ %37, %cond.false ]
  store i32 %cond, ptr %retval, align 4
  br label %return

return:                                           ; preds = %cond.end, %if.then2, %if.then
  %38 = load i32, ptr %retval, align 4
  ret i32 %38
}

; Function Attrs: mustprogress uwtable
define internal noundef i32 @_ZL21stbtt__run_charstringPK14stbtt_fontinfoiP12stbtt__csctx(ptr noundef %info, i32 noundef %glyph_index, ptr noundef %c) #4 {
entry:
  %retval = alloca i32, align 4
  %info.addr = alloca ptr, align 8
  %glyph_index.addr = alloca i32, align 4
  %c.addr = alloca ptr, align 8
  %in_header = alloca i32, align 4
  %maskbits = alloca i32, align 4
  %subr_stack_height = alloca i32, align 4
  %sp = alloca i32, align 4
  %v = alloca i32, align 4
  %i = alloca i32, align 4
  %b0 = alloca i32, align 4
  %has_subrs = alloca i32, align 4
  %clear_stack = alloca i32, align 4
  %s = alloca [48 x float], align 16
  %subr_stack = alloca [10 x %struct.stbtt__buf], align 16
  %subrs = alloca %struct.stbtt__buf, align 8
  %b = alloca %struct.stbtt__buf, align 8
  %f = alloca float, align 4
  %ref.tmp = alloca %struct.stbtt__buf, align 8
  %agg.tmp = alloca %struct.stbtt__buf, align 8
  %ref.tmp270 = alloca %struct.stbtt__buf, align 8
  %ref.tmp287 = alloca %struct.stbtt__buf, align 8
  %agg.tmp288 = alloca %struct.stbtt__buf, align 8
  %dx1 = alloca float, align 4
  %dx2 = alloca float, align 4
  %dx3 = alloca float, align 4
  %dx4 = alloca float, align 4
  %dx5 = alloca float, align 4
  %dx6 = alloca float, align 4
  %dy1 = alloca float, align 4
  %dy2 = alloca float, align 4
  %dy3 = alloca float, align 4
  %dy4 = alloca float, align 4
  %dy5 = alloca float, align 4
  %dy6 = alloca float, align 4
  %dx = alloca float, align 4
  %dy = alloca float, align 4
  %b1 = alloca i32, align 4
  store ptr %info, ptr %info.addr, align 8
  store i32 %glyph_index, ptr %glyph_index.addr, align 4
  store ptr %c, ptr %c.addr, align 8
  store i32 1, ptr %in_header, align 4
  store i32 0, ptr %maskbits, align 4
  store i32 0, ptr %subr_stack_height, align 4
  store i32 0, ptr %sp, align 4
  store i32 0, ptr %has_subrs, align 4
  %0 = load ptr, ptr %info.addr, align 8
  %subrs1 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %0, i32 0, i32 17
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %subrs, ptr align 8 %subrs1, i64 16, i1 false)
  %1 = load ptr, ptr %info.addr, align 8
  %charstrings = getelementptr inbounds %struct.stbtt_fontinfo, ptr %1, i32 0, i32 15
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %charstrings, i64 16, i1 false)
  %2 = load i32, ptr %glyph_index.addr, align 4
  %3 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %6 = load i64, ptr %5, align 8
  %call = call { ptr, i64 } @_ZL20stbtt__cff_index_get10stbtt__bufi(ptr %4, i64 %6, i32 noundef %2)
  %7 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 0
  %8 = extractvalue { ptr, i64 } %call, 0
  store ptr %8, ptr %7, align 8
  %9 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 1
  %10 = extractvalue { ptr, i64 } %call, 1
  store i64 %10, ptr %9, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %b, ptr align 8 %ref.tmp, i64 16, i1 false)
  br label %while.cond

while.cond:                                       ; preds = %if.end408, %entry
  %cursor = getelementptr inbounds %struct.stbtt__buf, ptr %b, i32 0, i32 1
  %11 = load i32, ptr %cursor, align 8
  %size = getelementptr inbounds %struct.stbtt__buf, ptr %b, i32 0, i32 2
  %12 = load i32, ptr %size, align 4
  %cmp = icmp slt i32 %11, %12
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  store i32 0, ptr %i, align 4
  store i32 1, ptr %clear_stack, align 4
  %call2 = call noundef zeroext i8 @_ZL15stbtt__buf_get8P10stbtt__buf(ptr noundef %b)
  %conv = zext i8 %call2 to i32
  store i32 %conv, ptr %b0, align 4
  %13 = load i32, ptr %b0, align 4
  switch i32 %13, label %sw.default382 [
    i32 19, label %sw.bb
    i32 20, label %sw.bb
    i32 1, label %sw.bb5
    i32 3, label %sw.bb5
    i32 18, label %sw.bb5
    i32 23, label %sw.bb5
    i32 21, label %sw.bb8
    i32 4, label %sw.bb15
    i32 22, label %sw.bb22
    i32 5, label %sw.bb29
    i32 7, label %sw.bb41
    i32 6, label %sw.bb45
    i32 31, label %sw.bb62
    i32 30, label %sw.bb66
    i32 8, label %sw.bb118
    i32 24, label %sw.bb146
    i32 25, label %sw.bb184
    i32 26, label %sw.bb222
    i32 27, label %sw.bb222
    i32 10, label %sw.bb264
    i32 29, label %sw.bb274
    i32 11, label %sw.bb299
    i32 14, label %sw.bb306
    i32 12, label %sw.bb307
  ]

sw.bb:                                            ; preds = %while.body, %while.body
  %14 = load i32, ptr %in_header, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  %15 = load i32, ptr %sp, align 4
  %div = sdiv i32 %15, 2
  %16 = load i32, ptr %maskbits, align 4
  %add = add nsw i32 %16, %div
  store i32 %add, ptr %maskbits, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb
  store i32 0, ptr %in_header, align 4
  %17 = load i32, ptr %maskbits, align 4
  %add3 = add nsw i32 %17, 7
  %div4 = sdiv i32 %add3, 8
  call void @_ZL15stbtt__buf_skipP10stbtt__bufi(ptr noundef %b, i32 noundef %div4)
  br label %sw.epilog405

sw.bb5:                                           ; preds = %while.body, %while.body, %while.body, %while.body
  %18 = load i32, ptr %sp, align 4
  %div6 = sdiv i32 %18, 2
  %19 = load i32, ptr %maskbits, align 4
  %add7 = add nsw i32 %19, %div6
  store i32 %add7, ptr %maskbits, align 4
  br label %sw.epilog405

sw.bb8:                                           ; preds = %while.body
  store i32 0, ptr %in_header, align 4
  %20 = load i32, ptr %sp, align 4
  %cmp9 = icmp slt i32 %20, 2
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %sw.bb8
  store i32 0, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %sw.bb8
  %21 = load ptr, ptr %c.addr, align 8
  %22 = load i32, ptr %sp, align 4
  %sub = sub nsw i32 %22, 2
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom
  %23 = load float, ptr %arrayidx, align 4
  %24 = load i32, ptr %sp, align 4
  %sub12 = sub nsw i32 %24, 1
  %idxprom13 = sext i32 %sub12 to i64
  %arrayidx14 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom13
  %25 = load float, ptr %arrayidx14, align 4
  call void @_ZL21stbtt__csctx_rmove_toP12stbtt__csctxff(ptr noundef %21, float noundef %23, float noundef %25)
  br label %sw.epilog405

sw.bb15:                                          ; preds = %while.body
  store i32 0, ptr %in_header, align 4
  %26 = load i32, ptr %sp, align 4
  %cmp16 = icmp slt i32 %26, 1
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %sw.bb15
  store i32 0, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %sw.bb15
  %27 = load ptr, ptr %c.addr, align 8
  %28 = load i32, ptr %sp, align 4
  %sub19 = sub nsw i32 %28, 1
  %idxprom20 = sext i32 %sub19 to i64
  %arrayidx21 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom20
  %29 = load float, ptr %arrayidx21, align 4
  call void @_ZL21stbtt__csctx_rmove_toP12stbtt__csctxff(ptr noundef %27, float noundef 0.000000e+00, float noundef %29)
  br label %sw.epilog405

sw.bb22:                                          ; preds = %while.body
  store i32 0, ptr %in_header, align 4
  %30 = load i32, ptr %sp, align 4
  %cmp23 = icmp slt i32 %30, 1
  br i1 %cmp23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %sw.bb22
  store i32 0, ptr %retval, align 4
  br label %return

if.end25:                                         ; preds = %sw.bb22
  %31 = load ptr, ptr %c.addr, align 8
  %32 = load i32, ptr %sp, align 4
  %sub26 = sub nsw i32 %32, 1
  %idxprom27 = sext i32 %sub26 to i64
  %arrayidx28 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom27
  %33 = load float, ptr %arrayidx28, align 4
  call void @_ZL21stbtt__csctx_rmove_toP12stbtt__csctxff(ptr noundef %31, float noundef %33, float noundef 0.000000e+00)
  br label %sw.epilog405

sw.bb29:                                          ; preds = %while.body
  %34 = load i32, ptr %sp, align 4
  %cmp30 = icmp slt i32 %34, 2
  br i1 %cmp30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %sw.bb29
  store i32 0, ptr %retval, align 4
  br label %return

if.end32:                                         ; preds = %sw.bb29
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end32
  %35 = load i32, ptr %i, align 4
  %add33 = add nsw i32 %35, 1
  %36 = load i32, ptr %sp, align 4
  %cmp34 = icmp slt i32 %add33, %36
  br i1 %cmp34, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %37 = load ptr, ptr %c.addr, align 8
  %38 = load i32, ptr %i, align 4
  %idxprom35 = sext i32 %38 to i64
  %arrayidx36 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom35
  %39 = load float, ptr %arrayidx36, align 4
  %40 = load i32, ptr %i, align 4
  %add37 = add nsw i32 %40, 1
  %idxprom38 = sext i32 %add37 to i64
  %arrayidx39 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom38
  %41 = load float, ptr %arrayidx39, align 4
  call void @_ZL21stbtt__csctx_rline_toP12stbtt__csctxff(ptr noundef %37, float noundef %39, float noundef %41)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %42 = load i32, ptr %i, align 4
  %add40 = add nsw i32 %42, 2
  store i32 %add40, ptr %i, align 4
  br label %for.cond, !llvm.loop !113

for.end:                                          ; preds = %for.cond
  br label %sw.epilog405

sw.bb41:                                          ; preds = %while.body
  %43 = load i32, ptr %sp, align 4
  %cmp42 = icmp slt i32 %43, 1
  br i1 %cmp42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %sw.bb41
  store i32 0, ptr %retval, align 4
  br label %return

if.end44:                                         ; preds = %sw.bb41
  br label %vlineto

sw.bb45:                                          ; preds = %while.body
  %44 = load i32, ptr %sp, align 4
  %cmp46 = icmp slt i32 %44, 1
  br i1 %cmp46, label %if.then47, label %if.end48

if.then47:                                        ; preds = %sw.bb45
  store i32 0, ptr %retval, align 4
  br label %return

if.end48:                                         ; preds = %sw.bb45
  br label %for.cond49

for.cond49:                                       ; preds = %if.end57, %if.end48
  %45 = load i32, ptr %i, align 4
  %46 = load i32, ptr %sp, align 4
  %cmp50 = icmp sge i32 %45, %46
  br i1 %cmp50, label %if.then51, label %if.end52

if.then51:                                        ; preds = %for.cond49
  br label %for.end61

if.end52:                                         ; preds = %for.cond49
  %47 = load ptr, ptr %c.addr, align 8
  %48 = load i32, ptr %i, align 4
  %idxprom53 = sext i32 %48 to i64
  %arrayidx54 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom53
  %49 = load float, ptr %arrayidx54, align 4
  call void @_ZL21stbtt__csctx_rline_toP12stbtt__csctxff(ptr noundef %47, float noundef %49, float noundef 0.000000e+00)
  %50 = load i32, ptr %i, align 4
  %inc = add nsw i32 %50, 1
  store i32 %inc, ptr %i, align 4
  br label %vlineto

vlineto:                                          ; preds = %if.end52, %if.end44
  %51 = load i32, ptr %i, align 4
  %52 = load i32, ptr %sp, align 4
  %cmp55 = icmp sge i32 %51, %52
  br i1 %cmp55, label %if.then56, label %if.end57

if.then56:                                        ; preds = %vlineto
  br label %for.end61

if.end57:                                         ; preds = %vlineto
  %53 = load ptr, ptr %c.addr, align 8
  %54 = load i32, ptr %i, align 4
  %idxprom58 = sext i32 %54 to i64
  %arrayidx59 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom58
  %55 = load float, ptr %arrayidx59, align 4
  call void @_ZL21stbtt__csctx_rline_toP12stbtt__csctxff(ptr noundef %53, float noundef 0.000000e+00, float noundef %55)
  %56 = load i32, ptr %i, align 4
  %inc60 = add nsw i32 %56, 1
  store i32 %inc60, ptr %i, align 4
  br label %for.cond49, !llvm.loop !114

for.end61:                                        ; preds = %if.then56, %if.then51
  br label %sw.epilog405

sw.bb62:                                          ; preds = %while.body
  %57 = load i32, ptr %sp, align 4
  %cmp63 = icmp slt i32 %57, 4
  br i1 %cmp63, label %if.then64, label %if.end65

if.then64:                                        ; preds = %sw.bb62
  store i32 0, ptr %retval, align 4
  br label %return

if.end65:                                         ; preds = %sw.bb62
  br label %hvcurveto

sw.bb66:                                          ; preds = %while.body
  %58 = load i32, ptr %sp, align 4
  %cmp67 = icmp slt i32 %58, 4
  br i1 %cmp67, label %if.then68, label %if.end69

if.then68:                                        ; preds = %sw.bb66
  store i32 0, ptr %retval, align 4
  br label %return

if.end69:                                         ; preds = %sw.bb66
  br label %for.cond70

for.cond70:                                       ; preds = %cond.end111, %if.end69
  %59 = load i32, ptr %i, align 4
  %add71 = add nsw i32 %59, 3
  %60 = load i32, ptr %sp, align 4
  %cmp72 = icmp sge i32 %add71, %60
  br i1 %cmp72, label %if.then73, label %if.end74

if.then73:                                        ; preds = %for.cond70
  br label %for.end117

if.end74:                                         ; preds = %for.cond70
  %61 = load ptr, ptr %c.addr, align 8
  %62 = load i32, ptr %i, align 4
  %idxprom75 = sext i32 %62 to i64
  %arrayidx76 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom75
  %63 = load float, ptr %arrayidx76, align 4
  %64 = load i32, ptr %i, align 4
  %add77 = add nsw i32 %64, 1
  %idxprom78 = sext i32 %add77 to i64
  %arrayidx79 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom78
  %65 = load float, ptr %arrayidx79, align 4
  %66 = load i32, ptr %i, align 4
  %add80 = add nsw i32 %66, 2
  %idxprom81 = sext i32 %add80 to i64
  %arrayidx82 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom81
  %67 = load float, ptr %arrayidx82, align 4
  %68 = load i32, ptr %i, align 4
  %add83 = add nsw i32 %68, 3
  %idxprom84 = sext i32 %add83 to i64
  %arrayidx85 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom84
  %69 = load float, ptr %arrayidx85, align 4
  %70 = load i32, ptr %sp, align 4
  %71 = load i32, ptr %i, align 4
  %sub86 = sub nsw i32 %70, %71
  %cmp87 = icmp eq i32 %sub86, 5
  br i1 %cmp87, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end74
  %72 = load i32, ptr %i, align 4
  %add88 = add nsw i32 %72, 4
  %idxprom89 = sext i32 %add88 to i64
  %arrayidx90 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom89
  %73 = load float, ptr %arrayidx90, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end74
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %73, %cond.true ], [ 0.000000e+00, %cond.false ]
  call void @_ZL23stbtt__csctx_rccurve_toP12stbtt__csctxffffff(ptr noundef %61, float noundef 0.000000e+00, float noundef %63, float noundef %65, float noundef %67, float noundef %69, float noundef %cond)
  %74 = load i32, ptr %i, align 4
  %add91 = add nsw i32 %74, 4
  store i32 %add91, ptr %i, align 4
  br label %hvcurveto

hvcurveto:                                        ; preds = %cond.end, %if.end65
  %75 = load i32, ptr %i, align 4
  %add92 = add nsw i32 %75, 3
  %76 = load i32, ptr %sp, align 4
  %cmp93 = icmp sge i32 %add92, %76
  br i1 %cmp93, label %if.then94, label %if.end95

if.then94:                                        ; preds = %hvcurveto
  br label %for.end117

if.end95:                                         ; preds = %hvcurveto
  %77 = load ptr, ptr %c.addr, align 8
  %78 = load i32, ptr %i, align 4
  %idxprom96 = sext i32 %78 to i64
  %arrayidx97 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom96
  %79 = load float, ptr %arrayidx97, align 4
  %80 = load i32, ptr %i, align 4
  %add98 = add nsw i32 %80, 1
  %idxprom99 = sext i32 %add98 to i64
  %arrayidx100 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom99
  %81 = load float, ptr %arrayidx100, align 4
  %82 = load i32, ptr %i, align 4
  %add101 = add nsw i32 %82, 2
  %idxprom102 = sext i32 %add101 to i64
  %arrayidx103 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom102
  %83 = load float, ptr %arrayidx103, align 4
  %84 = load i32, ptr %sp, align 4
  %85 = load i32, ptr %i, align 4
  %sub104 = sub nsw i32 %84, %85
  %cmp105 = icmp eq i32 %sub104, 5
  br i1 %cmp105, label %cond.true106, label %cond.false110

cond.true106:                                     ; preds = %if.end95
  %86 = load i32, ptr %i, align 4
  %add107 = add nsw i32 %86, 4
  %idxprom108 = sext i32 %add107 to i64
  %arrayidx109 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom108
  %87 = load float, ptr %arrayidx109, align 4
  br label %cond.end111

cond.false110:                                    ; preds = %if.end95
  br label %cond.end111

cond.end111:                                      ; preds = %cond.false110, %cond.true106
  %cond112 = phi float [ %87, %cond.true106 ], [ 0.000000e+00, %cond.false110 ]
  %88 = load i32, ptr %i, align 4
  %add113 = add nsw i32 %88, 3
  %idxprom114 = sext i32 %add113 to i64
  %arrayidx115 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom114
  %89 = load float, ptr %arrayidx115, align 4
  call void @_ZL23stbtt__csctx_rccurve_toP12stbtt__csctxffffff(ptr noundef %77, float noundef %79, float noundef 0.000000e+00, float noundef %81, float noundef %83, float noundef %cond112, float noundef %89)
  %90 = load i32, ptr %i, align 4
  %add116 = add nsw i32 %90, 4
  store i32 %add116, ptr %i, align 4
  br label %for.cond70, !llvm.loop !115

for.end117:                                       ; preds = %if.then94, %if.then73
  br label %sw.epilog405

sw.bb118:                                         ; preds = %while.body
  %91 = load i32, ptr %sp, align 4
  %cmp119 = icmp slt i32 %91, 6
  br i1 %cmp119, label %if.then120, label %if.end121

if.then120:                                       ; preds = %sw.bb118
  store i32 0, ptr %retval, align 4
  br label %return

if.end121:                                        ; preds = %sw.bb118
  br label %for.cond122

for.cond122:                                      ; preds = %for.inc143, %if.end121
  %92 = load i32, ptr %i, align 4
  %add123 = add nsw i32 %92, 5
  %93 = load i32, ptr %sp, align 4
  %cmp124 = icmp slt i32 %add123, %93
  br i1 %cmp124, label %for.body125, label %for.end145

for.body125:                                      ; preds = %for.cond122
  %94 = load ptr, ptr %c.addr, align 8
  %95 = load i32, ptr %i, align 4
  %idxprom126 = sext i32 %95 to i64
  %arrayidx127 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom126
  %96 = load float, ptr %arrayidx127, align 4
  %97 = load i32, ptr %i, align 4
  %add128 = add nsw i32 %97, 1
  %idxprom129 = sext i32 %add128 to i64
  %arrayidx130 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom129
  %98 = load float, ptr %arrayidx130, align 4
  %99 = load i32, ptr %i, align 4
  %add131 = add nsw i32 %99, 2
  %idxprom132 = sext i32 %add131 to i64
  %arrayidx133 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom132
  %100 = load float, ptr %arrayidx133, align 4
  %101 = load i32, ptr %i, align 4
  %add134 = add nsw i32 %101, 3
  %idxprom135 = sext i32 %add134 to i64
  %arrayidx136 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom135
  %102 = load float, ptr %arrayidx136, align 4
  %103 = load i32, ptr %i, align 4
  %add137 = add nsw i32 %103, 4
  %idxprom138 = sext i32 %add137 to i64
  %arrayidx139 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom138
  %104 = load float, ptr %arrayidx139, align 4
  %105 = load i32, ptr %i, align 4
  %add140 = add nsw i32 %105, 5
  %idxprom141 = sext i32 %add140 to i64
  %arrayidx142 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom141
  %106 = load float, ptr %arrayidx142, align 4
  call void @_ZL23stbtt__csctx_rccurve_toP12stbtt__csctxffffff(ptr noundef %94, float noundef %96, float noundef %98, float noundef %100, float noundef %102, float noundef %104, float noundef %106)
  br label %for.inc143

for.inc143:                                       ; preds = %for.body125
  %107 = load i32, ptr %i, align 4
  %add144 = add nsw i32 %107, 6
  store i32 %add144, ptr %i, align 4
  br label %for.cond122, !llvm.loop !116

for.end145:                                       ; preds = %for.cond122
  br label %sw.epilog405

sw.bb146:                                         ; preds = %while.body
  %108 = load i32, ptr %sp, align 4
  %cmp147 = icmp slt i32 %108, 8
  br i1 %cmp147, label %if.then148, label %if.end149

if.then148:                                       ; preds = %sw.bb146
  store i32 0, ptr %retval, align 4
  br label %return

if.end149:                                        ; preds = %sw.bb146
  br label %for.cond150

for.cond150:                                      ; preds = %for.inc172, %if.end149
  %109 = load i32, ptr %i, align 4
  %add151 = add nsw i32 %109, 5
  %110 = load i32, ptr %sp, align 4
  %sub152 = sub nsw i32 %110, 2
  %cmp153 = icmp slt i32 %add151, %sub152
  br i1 %cmp153, label %for.body154, label %for.end174

for.body154:                                      ; preds = %for.cond150
  %111 = load ptr, ptr %c.addr, align 8
  %112 = load i32, ptr %i, align 4
  %idxprom155 = sext i32 %112 to i64
  %arrayidx156 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom155
  %113 = load float, ptr %arrayidx156, align 4
  %114 = load i32, ptr %i, align 4
  %add157 = add nsw i32 %114, 1
  %idxprom158 = sext i32 %add157 to i64
  %arrayidx159 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom158
  %115 = load float, ptr %arrayidx159, align 4
  %116 = load i32, ptr %i, align 4
  %add160 = add nsw i32 %116, 2
  %idxprom161 = sext i32 %add160 to i64
  %arrayidx162 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom161
  %117 = load float, ptr %arrayidx162, align 4
  %118 = load i32, ptr %i, align 4
  %add163 = add nsw i32 %118, 3
  %idxprom164 = sext i32 %add163 to i64
  %arrayidx165 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom164
  %119 = load float, ptr %arrayidx165, align 4
  %120 = load i32, ptr %i, align 4
  %add166 = add nsw i32 %120, 4
  %idxprom167 = sext i32 %add166 to i64
  %arrayidx168 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom167
  %121 = load float, ptr %arrayidx168, align 4
  %122 = load i32, ptr %i, align 4
  %add169 = add nsw i32 %122, 5
  %idxprom170 = sext i32 %add169 to i64
  %arrayidx171 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom170
  %123 = load float, ptr %arrayidx171, align 4
  call void @_ZL23stbtt__csctx_rccurve_toP12stbtt__csctxffffff(ptr noundef %111, float noundef %113, float noundef %115, float noundef %117, float noundef %119, float noundef %121, float noundef %123)
  br label %for.inc172

for.inc172:                                       ; preds = %for.body154
  %124 = load i32, ptr %i, align 4
  %add173 = add nsw i32 %124, 6
  store i32 %add173, ptr %i, align 4
  br label %for.cond150, !llvm.loop !117

for.end174:                                       ; preds = %for.cond150
  %125 = load i32, ptr %i, align 4
  %add175 = add nsw i32 %125, 1
  %126 = load i32, ptr %sp, align 4
  %cmp176 = icmp sge i32 %add175, %126
  br i1 %cmp176, label %if.then177, label %if.end178

if.then177:                                       ; preds = %for.end174
  store i32 0, ptr %retval, align 4
  br label %return

if.end178:                                        ; preds = %for.end174
  %127 = load ptr, ptr %c.addr, align 8
  %128 = load i32, ptr %i, align 4
  %idxprom179 = sext i32 %128 to i64
  %arrayidx180 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom179
  %129 = load float, ptr %arrayidx180, align 4
  %130 = load i32, ptr %i, align 4
  %add181 = add nsw i32 %130, 1
  %idxprom182 = sext i32 %add181 to i64
  %arrayidx183 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom182
  %131 = load float, ptr %arrayidx183, align 4
  call void @_ZL21stbtt__csctx_rline_toP12stbtt__csctxff(ptr noundef %127, float noundef %129, float noundef %131)
  br label %sw.epilog405

sw.bb184:                                         ; preds = %while.body
  %132 = load i32, ptr %sp, align 4
  %cmp185 = icmp slt i32 %132, 8
  br i1 %cmp185, label %if.then186, label %if.end187

if.then186:                                       ; preds = %sw.bb184
  store i32 0, ptr %retval, align 4
  br label %return

if.end187:                                        ; preds = %sw.bb184
  br label %for.cond188

for.cond188:                                      ; preds = %for.inc198, %if.end187
  %133 = load i32, ptr %i, align 4
  %add189 = add nsw i32 %133, 1
  %134 = load i32, ptr %sp, align 4
  %sub190 = sub nsw i32 %134, 6
  %cmp191 = icmp slt i32 %add189, %sub190
  br i1 %cmp191, label %for.body192, label %for.end200

for.body192:                                      ; preds = %for.cond188
  %135 = load ptr, ptr %c.addr, align 8
  %136 = load i32, ptr %i, align 4
  %idxprom193 = sext i32 %136 to i64
  %arrayidx194 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom193
  %137 = load float, ptr %arrayidx194, align 4
  %138 = load i32, ptr %i, align 4
  %add195 = add nsw i32 %138, 1
  %idxprom196 = sext i32 %add195 to i64
  %arrayidx197 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom196
  %139 = load float, ptr %arrayidx197, align 4
  call void @_ZL21stbtt__csctx_rline_toP12stbtt__csctxff(ptr noundef %135, float noundef %137, float noundef %139)
  br label %for.inc198

for.inc198:                                       ; preds = %for.body192
  %140 = load i32, ptr %i, align 4
  %add199 = add nsw i32 %140, 2
  store i32 %add199, ptr %i, align 4
  br label %for.cond188, !llvm.loop !118

for.end200:                                       ; preds = %for.cond188
  %141 = load i32, ptr %i, align 4
  %add201 = add nsw i32 %141, 5
  %142 = load i32, ptr %sp, align 4
  %cmp202 = icmp sge i32 %add201, %142
  br i1 %cmp202, label %if.then203, label %if.end204

if.then203:                                       ; preds = %for.end200
  store i32 0, ptr %retval, align 4
  br label %return

if.end204:                                        ; preds = %for.end200
  %143 = load ptr, ptr %c.addr, align 8
  %144 = load i32, ptr %i, align 4
  %idxprom205 = sext i32 %144 to i64
  %arrayidx206 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom205
  %145 = load float, ptr %arrayidx206, align 4
  %146 = load i32, ptr %i, align 4
  %add207 = add nsw i32 %146, 1
  %idxprom208 = sext i32 %add207 to i64
  %arrayidx209 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom208
  %147 = load float, ptr %arrayidx209, align 4
  %148 = load i32, ptr %i, align 4
  %add210 = add nsw i32 %148, 2
  %idxprom211 = sext i32 %add210 to i64
  %arrayidx212 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom211
  %149 = load float, ptr %arrayidx212, align 4
  %150 = load i32, ptr %i, align 4
  %add213 = add nsw i32 %150, 3
  %idxprom214 = sext i32 %add213 to i64
  %arrayidx215 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom214
  %151 = load float, ptr %arrayidx215, align 4
  %152 = load i32, ptr %i, align 4
  %add216 = add nsw i32 %152, 4
  %idxprom217 = sext i32 %add216 to i64
  %arrayidx218 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom217
  %153 = load float, ptr %arrayidx218, align 4
  %154 = load i32, ptr %i, align 4
  %add219 = add nsw i32 %154, 5
  %idxprom220 = sext i32 %add219 to i64
  %arrayidx221 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom220
  %155 = load float, ptr %arrayidx221, align 4
  call void @_ZL23stbtt__csctx_rccurve_toP12stbtt__csctxffffff(ptr noundef %143, float noundef %145, float noundef %147, float noundef %149, float noundef %151, float noundef %153, float noundef %155)
  br label %sw.epilog405

sw.bb222:                                         ; preds = %while.body, %while.body
  %156 = load i32, ptr %sp, align 4
  %cmp223 = icmp slt i32 %156, 4
  br i1 %cmp223, label %if.then224, label %if.end225

if.then224:                                       ; preds = %sw.bb222
  store i32 0, ptr %retval, align 4
  br label %return

if.end225:                                        ; preds = %sw.bb222
  store float 0.000000e+00, ptr %f, align 4
  %157 = load i32, ptr %sp, align 4
  %and = and i32 %157, 1
  %tobool226 = icmp ne i32 %and, 0
  br i1 %tobool226, label %if.then227, label %if.end231

if.then227:                                       ; preds = %if.end225
  %158 = load i32, ptr %i, align 4
  %idxprom228 = sext i32 %158 to i64
  %arrayidx229 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom228
  %159 = load float, ptr %arrayidx229, align 4
  store float %159, ptr %f, align 4
  %160 = load i32, ptr %i, align 4
  %inc230 = add nsw i32 %160, 1
  store i32 %inc230, ptr %i, align 4
  br label %if.end231

if.end231:                                        ; preds = %if.then227, %if.end225
  br label %for.cond232

for.cond232:                                      ; preds = %for.inc261, %if.end231
  %161 = load i32, ptr %i, align 4
  %add233 = add nsw i32 %161, 3
  %162 = load i32, ptr %sp, align 4
  %cmp234 = icmp slt i32 %add233, %162
  br i1 %cmp234, label %for.body235, label %for.end263

for.body235:                                      ; preds = %for.cond232
  %163 = load i32, ptr %b0, align 4
  %cmp236 = icmp eq i32 %163, 27
  br i1 %cmp236, label %if.then237, label %if.else

if.then237:                                       ; preds = %for.body235
  %164 = load ptr, ptr %c.addr, align 8
  %165 = load i32, ptr %i, align 4
  %idxprom238 = sext i32 %165 to i64
  %arrayidx239 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom238
  %166 = load float, ptr %arrayidx239, align 4
  %167 = load float, ptr %f, align 4
  %168 = load i32, ptr %i, align 4
  %add240 = add nsw i32 %168, 1
  %idxprom241 = sext i32 %add240 to i64
  %arrayidx242 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom241
  %169 = load float, ptr %arrayidx242, align 4
  %170 = load i32, ptr %i, align 4
  %add243 = add nsw i32 %170, 2
  %idxprom244 = sext i32 %add243 to i64
  %arrayidx245 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom244
  %171 = load float, ptr %arrayidx245, align 4
  %172 = load i32, ptr %i, align 4
  %add246 = add nsw i32 %172, 3
  %idxprom247 = sext i32 %add246 to i64
  %arrayidx248 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom247
  %173 = load float, ptr %arrayidx248, align 4
  call void @_ZL23stbtt__csctx_rccurve_toP12stbtt__csctxffffff(ptr noundef %164, float noundef %166, float noundef %167, float noundef %169, float noundef %171, float noundef %173, float noundef 0.000000e+00)
  br label %if.end260

if.else:                                          ; preds = %for.body235
  %174 = load ptr, ptr %c.addr, align 8
  %175 = load float, ptr %f, align 4
  %176 = load i32, ptr %i, align 4
  %idxprom249 = sext i32 %176 to i64
  %arrayidx250 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom249
  %177 = load float, ptr %arrayidx250, align 4
  %178 = load i32, ptr %i, align 4
  %add251 = add nsw i32 %178, 1
  %idxprom252 = sext i32 %add251 to i64
  %arrayidx253 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom252
  %179 = load float, ptr %arrayidx253, align 4
  %180 = load i32, ptr %i, align 4
  %add254 = add nsw i32 %180, 2
  %idxprom255 = sext i32 %add254 to i64
  %arrayidx256 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom255
  %181 = load float, ptr %arrayidx256, align 4
  %182 = load i32, ptr %i, align 4
  %add257 = add nsw i32 %182, 3
  %idxprom258 = sext i32 %add257 to i64
  %arrayidx259 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom258
  %183 = load float, ptr %arrayidx259, align 4
  call void @_ZL23stbtt__csctx_rccurve_toP12stbtt__csctxffffff(ptr noundef %174, float noundef %175, float noundef %177, float noundef %179, float noundef %181, float noundef 0.000000e+00, float noundef %183)
  br label %if.end260

if.end260:                                        ; preds = %if.else, %if.then237
  store float 0.000000e+00, ptr %f, align 4
  br label %for.inc261

for.inc261:                                       ; preds = %if.end260
  %184 = load i32, ptr %i, align 4
  %add262 = add nsw i32 %184, 4
  store i32 %add262, ptr %i, align 4
  br label %for.cond232, !llvm.loop !119

for.end263:                                       ; preds = %for.cond232
  br label %sw.epilog405

sw.bb264:                                         ; preds = %while.body
  %185 = load i32, ptr %has_subrs, align 4
  %tobool265 = icmp ne i32 %185, 0
  br i1 %tobool265, label %if.end273, label %if.then266

if.then266:                                       ; preds = %sw.bb264
  %186 = load ptr, ptr %info.addr, align 8
  %fdselect = getelementptr inbounds %struct.stbtt_fontinfo, ptr %186, i32 0, i32 19
  %size267 = getelementptr inbounds %struct.stbtt__buf, ptr %fdselect, i32 0, i32 2
  %187 = load i32, ptr %size267, align 4
  %tobool268 = icmp ne i32 %187, 0
  br i1 %tobool268, label %if.then269, label %if.end272

if.then269:                                       ; preds = %if.then266
  %188 = load ptr, ptr %info.addr, align 8
  %189 = load i32, ptr %glyph_index.addr, align 4
  %call271 = call { ptr, i64 } @_ZL26stbtt__cid_get_glyph_subrsPK14stbtt_fontinfoi(ptr noundef %188, i32 noundef %189)
  %190 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp270, i32 0, i32 0
  %191 = extractvalue { ptr, i64 } %call271, 0
  store ptr %191, ptr %190, align 8
  %192 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp270, i32 0, i32 1
  %193 = extractvalue { ptr, i64 } %call271, 1
  store i64 %193, ptr %192, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %subrs, ptr align 8 %ref.tmp270, i64 16, i1 false)
  br label %if.end272

if.end272:                                        ; preds = %if.then269, %if.then266
  store i32 1, ptr %has_subrs, align 4
  br label %if.end273

if.end273:                                        ; preds = %if.end272, %sw.bb264
  br label %sw.bb274

sw.bb274:                                         ; preds = %if.end273, %while.body
  %194 = load i32, ptr %sp, align 4
  %cmp275 = icmp slt i32 %194, 1
  br i1 %cmp275, label %if.then276, label %if.end277

if.then276:                                       ; preds = %sw.bb274
  store i32 0, ptr %retval, align 4
  br label %return

if.end277:                                        ; preds = %sw.bb274
  %195 = load i32, ptr %sp, align 4
  %dec = add nsw i32 %195, -1
  store i32 %dec, ptr %sp, align 4
  %idxprom278 = sext i32 %dec to i64
  %arrayidx279 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom278
  %196 = load float, ptr %arrayidx279, align 4
  %conv280 = fptosi float %196 to i32
  store i32 %conv280, ptr %v, align 4
  %197 = load i32, ptr %subr_stack_height, align 4
  %cmp281 = icmp sge i32 %197, 10
  br i1 %cmp281, label %if.then282, label %if.end283

if.then282:                                       ; preds = %if.end277
  store i32 0, ptr %retval, align 4
  br label %return

if.end283:                                        ; preds = %if.end277
  %198 = load i32, ptr %subr_stack_height, align 4
  %inc284 = add nsw i32 %198, 1
  store i32 %inc284, ptr %subr_stack_height, align 4
  %idxprom285 = sext i32 %198 to i64
  %arrayidx286 = getelementptr inbounds [10 x %struct.stbtt__buf], ptr %subr_stack, i64 0, i64 %idxprom285
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arrayidx286, ptr align 8 %b, i64 16, i1 false)
  %199 = load i32, ptr %b0, align 4
  %cmp289 = icmp eq i32 %199, 10
  br i1 %cmp289, label %cond.true290, label %cond.false291

cond.true290:                                     ; preds = %if.end283
  br label %cond.end292

cond.false291:                                    ; preds = %if.end283
  %200 = load ptr, ptr %info.addr, align 8
  %gsubrs = getelementptr inbounds %struct.stbtt_fontinfo, ptr %200, i32 0, i32 16
  br label %cond.end292

cond.end292:                                      ; preds = %cond.false291, %cond.true290
  %cond-lvalue = phi ptr [ %subrs, %cond.true290 ], [ %gsubrs, %cond.false291 ]
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp288, ptr align 8 %cond-lvalue, i64 16, i1 false)
  %201 = load i32, ptr %v, align 4
  %202 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp288, i32 0, i32 0
  %203 = load ptr, ptr %202, align 8
  %204 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp288, i32 0, i32 1
  %205 = load i64, ptr %204, align 8
  %call293 = call { ptr, i64 } @_ZL15stbtt__get_subr10stbtt__bufi(ptr %203, i64 %205, i32 noundef %201)
  %206 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp287, i32 0, i32 0
  %207 = extractvalue { ptr, i64 } %call293, 0
  store ptr %207, ptr %206, align 8
  %208 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp287, i32 0, i32 1
  %209 = extractvalue { ptr, i64 } %call293, 1
  store i64 %209, ptr %208, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %b, ptr align 8 %ref.tmp287, i64 16, i1 false)
  %size294 = getelementptr inbounds %struct.stbtt__buf, ptr %b, i32 0, i32 2
  %210 = load i32, ptr %size294, align 4
  %cmp295 = icmp eq i32 %210, 0
  br i1 %cmp295, label %if.then296, label %if.end297

if.then296:                                       ; preds = %cond.end292
  store i32 0, ptr %retval, align 4
  br label %return

if.end297:                                        ; preds = %cond.end292
  %cursor298 = getelementptr inbounds %struct.stbtt__buf, ptr %b, i32 0, i32 1
  store i32 0, ptr %cursor298, align 8
  store i32 0, ptr %clear_stack, align 4
  br label %sw.epilog405

sw.bb299:                                         ; preds = %while.body
  %211 = load i32, ptr %subr_stack_height, align 4
  %cmp300 = icmp sle i32 %211, 0
  br i1 %cmp300, label %if.then301, label %if.end302

if.then301:                                       ; preds = %sw.bb299
  store i32 0, ptr %retval, align 4
  br label %return

if.end302:                                        ; preds = %sw.bb299
  %212 = load i32, ptr %subr_stack_height, align 4
  %dec303 = add nsw i32 %212, -1
  store i32 %dec303, ptr %subr_stack_height, align 4
  %idxprom304 = sext i32 %dec303 to i64
  %arrayidx305 = getelementptr inbounds [10 x %struct.stbtt__buf], ptr %subr_stack, i64 0, i64 %idxprom304
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %b, ptr align 16 %arrayidx305, i64 16, i1 false)
  store i32 0, ptr %clear_stack, align 4
  br label %sw.epilog405

sw.bb306:                                         ; preds = %while.body
  %213 = load ptr, ptr %c.addr, align 8
  call void @_ZL24stbtt__csctx_close_shapeP12stbtt__csctx(ptr noundef %213)
  store i32 1, ptr %retval, align 4
  br label %return

sw.bb307:                                         ; preds = %while.body
  %call308 = call noundef zeroext i8 @_ZL15stbtt__buf_get8P10stbtt__buf(ptr noundef %b)
  %conv309 = zext i8 %call308 to i32
  store i32 %conv309, ptr %b1, align 4
  %214 = load i32, ptr %b1, align 4
  switch i32 %214, label %sw.default [
    i32 34, label %sw.bb310
    i32 35, label %sw.bb321
    i32 36, label %sw.bb337
    i32 37, label %sw.bb353
  ]

sw.bb310:                                         ; preds = %sw.bb307
  %215 = load i32, ptr %sp, align 4
  %cmp311 = icmp slt i32 %215, 7
  br i1 %cmp311, label %if.then312, label %if.end313

if.then312:                                       ; preds = %sw.bb310
  store i32 0, ptr %retval, align 4
  br label %return

if.end313:                                        ; preds = %sw.bb310
  %arrayidx314 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 0
  %216 = load float, ptr %arrayidx314, align 16
  store float %216, ptr %dx1, align 4
  %arrayidx315 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 1
  %217 = load float, ptr %arrayidx315, align 4
  store float %217, ptr %dx2, align 4
  %arrayidx316 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 2
  %218 = load float, ptr %arrayidx316, align 8
  store float %218, ptr %dy2, align 4
  %arrayidx317 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 3
  %219 = load float, ptr %arrayidx317, align 4
  store float %219, ptr %dx3, align 4
  %arrayidx318 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 4
  %220 = load float, ptr %arrayidx318, align 16
  store float %220, ptr %dx4, align 4
  %arrayidx319 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 5
  %221 = load float, ptr %arrayidx319, align 4
  store float %221, ptr %dx5, align 4
  %arrayidx320 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 6
  %222 = load float, ptr %arrayidx320, align 8
  store float %222, ptr %dx6, align 4
  %223 = load ptr, ptr %c.addr, align 8
  %224 = load float, ptr %dx1, align 4
  %225 = load float, ptr %dx2, align 4
  %226 = load float, ptr %dy2, align 4
  %227 = load float, ptr %dx3, align 4
  call void @_ZL23stbtt__csctx_rccurve_toP12stbtt__csctxffffff(ptr noundef %223, float noundef %224, float noundef 0.000000e+00, float noundef %225, float noundef %226, float noundef %227, float noundef 0.000000e+00)
  %228 = load ptr, ptr %c.addr, align 8
  %229 = load float, ptr %dx4, align 4
  %230 = load float, ptr %dx5, align 4
  %231 = load float, ptr %dy2, align 4
  %fneg = fneg float %231
  %232 = load float, ptr %dx6, align 4
  call void @_ZL23stbtt__csctx_rccurve_toP12stbtt__csctxffffff(ptr noundef %228, float noundef %229, float noundef 0.000000e+00, float noundef %230, float noundef %fneg, float noundef %232, float noundef 0.000000e+00)
  br label %sw.epilog

sw.bb321:                                         ; preds = %sw.bb307
  %233 = load i32, ptr %sp, align 4
  %cmp322 = icmp slt i32 %233, 13
  br i1 %cmp322, label %if.then323, label %if.end324

if.then323:                                       ; preds = %sw.bb321
  store i32 0, ptr %retval, align 4
  br label %return

if.end324:                                        ; preds = %sw.bb321
  %arrayidx325 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 0
  %234 = load float, ptr %arrayidx325, align 16
  store float %234, ptr %dx1, align 4
  %arrayidx326 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 1
  %235 = load float, ptr %arrayidx326, align 4
  store float %235, ptr %dy1, align 4
  %arrayidx327 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 2
  %236 = load float, ptr %arrayidx327, align 8
  store float %236, ptr %dx2, align 4
  %arrayidx328 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 3
  %237 = load float, ptr %arrayidx328, align 4
  store float %237, ptr %dy2, align 4
  %arrayidx329 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 4
  %238 = load float, ptr %arrayidx329, align 16
  store float %238, ptr %dx3, align 4
  %arrayidx330 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 5
  %239 = load float, ptr %arrayidx330, align 4
  store float %239, ptr %dy3, align 4
  %arrayidx331 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 6
  %240 = load float, ptr %arrayidx331, align 8
  store float %240, ptr %dx4, align 4
  %arrayidx332 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 7
  %241 = load float, ptr %arrayidx332, align 4
  store float %241, ptr %dy4, align 4
  %arrayidx333 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 8
  %242 = load float, ptr %arrayidx333, align 16
  store float %242, ptr %dx5, align 4
  %arrayidx334 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 9
  %243 = load float, ptr %arrayidx334, align 4
  store float %243, ptr %dy5, align 4
  %arrayidx335 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 10
  %244 = load float, ptr %arrayidx335, align 8
  store float %244, ptr %dx6, align 4
  %arrayidx336 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 11
  %245 = load float, ptr %arrayidx336, align 4
  store float %245, ptr %dy6, align 4
  %246 = load ptr, ptr %c.addr, align 8
  %247 = load float, ptr %dx1, align 4
  %248 = load float, ptr %dy1, align 4
  %249 = load float, ptr %dx2, align 4
  %250 = load float, ptr %dy2, align 4
  %251 = load float, ptr %dx3, align 4
  %252 = load float, ptr %dy3, align 4
  call void @_ZL23stbtt__csctx_rccurve_toP12stbtt__csctxffffff(ptr noundef %246, float noundef %247, float noundef %248, float noundef %249, float noundef %250, float noundef %251, float noundef %252)
  %253 = load ptr, ptr %c.addr, align 8
  %254 = load float, ptr %dx4, align 4
  %255 = load float, ptr %dy4, align 4
  %256 = load float, ptr %dx5, align 4
  %257 = load float, ptr %dy5, align 4
  %258 = load float, ptr %dx6, align 4
  %259 = load float, ptr %dy6, align 4
  call void @_ZL23stbtt__csctx_rccurve_toP12stbtt__csctxffffff(ptr noundef %253, float noundef %254, float noundef %255, float noundef %256, float noundef %257, float noundef %258, float noundef %259)
  br label %sw.epilog

sw.bb337:                                         ; preds = %sw.bb307
  %260 = load i32, ptr %sp, align 4
  %cmp338 = icmp slt i32 %260, 9
  br i1 %cmp338, label %if.then339, label %if.end340

if.then339:                                       ; preds = %sw.bb337
  store i32 0, ptr %retval, align 4
  br label %return

if.end340:                                        ; preds = %sw.bb337
  %arrayidx341 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 0
  %261 = load float, ptr %arrayidx341, align 16
  store float %261, ptr %dx1, align 4
  %arrayidx342 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 1
  %262 = load float, ptr %arrayidx342, align 4
  store float %262, ptr %dy1, align 4
  %arrayidx343 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 2
  %263 = load float, ptr %arrayidx343, align 8
  store float %263, ptr %dx2, align 4
  %arrayidx344 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 3
  %264 = load float, ptr %arrayidx344, align 4
  store float %264, ptr %dy2, align 4
  %arrayidx345 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 4
  %265 = load float, ptr %arrayidx345, align 16
  store float %265, ptr %dx3, align 4
  %arrayidx346 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 5
  %266 = load float, ptr %arrayidx346, align 4
  store float %266, ptr %dx4, align 4
  %arrayidx347 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 6
  %267 = load float, ptr %arrayidx347, align 8
  store float %267, ptr %dx5, align 4
  %arrayidx348 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 7
  %268 = load float, ptr %arrayidx348, align 4
  store float %268, ptr %dy5, align 4
  %arrayidx349 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 8
  %269 = load float, ptr %arrayidx349, align 16
  store float %269, ptr %dx6, align 4
  %270 = load ptr, ptr %c.addr, align 8
  %271 = load float, ptr %dx1, align 4
  %272 = load float, ptr %dy1, align 4
  %273 = load float, ptr %dx2, align 4
  %274 = load float, ptr %dy2, align 4
  %275 = load float, ptr %dx3, align 4
  call void @_ZL23stbtt__csctx_rccurve_toP12stbtt__csctxffffff(ptr noundef %270, float noundef %271, float noundef %272, float noundef %273, float noundef %274, float noundef %275, float noundef 0.000000e+00)
  %276 = load ptr, ptr %c.addr, align 8
  %277 = load float, ptr %dx4, align 4
  %278 = load float, ptr %dx5, align 4
  %279 = load float, ptr %dy5, align 4
  %280 = load float, ptr %dx6, align 4
  %281 = load float, ptr %dy1, align 4
  %282 = load float, ptr %dy2, align 4
  %add350 = fadd float %281, %282
  %283 = load float, ptr %dy5, align 4
  %add351 = fadd float %add350, %283
  %fneg352 = fneg float %add351
  call void @_ZL23stbtt__csctx_rccurve_toP12stbtt__csctxffffff(ptr noundef %276, float noundef %277, float noundef 0.000000e+00, float noundef %278, float noundef %279, float noundef %280, float noundef %fneg352)
  br label %sw.epilog

sw.bb353:                                         ; preds = %sw.bb307
  %284 = load i32, ptr %sp, align 4
  %cmp354 = icmp slt i32 %284, 11
  br i1 %cmp354, label %if.then355, label %if.end356

if.then355:                                       ; preds = %sw.bb353
  store i32 0, ptr %retval, align 4
  br label %return

if.end356:                                        ; preds = %sw.bb353
  %arrayidx357 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 0
  %285 = load float, ptr %arrayidx357, align 16
  store float %285, ptr %dx1, align 4
  %arrayidx358 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 1
  %286 = load float, ptr %arrayidx358, align 4
  store float %286, ptr %dy1, align 4
  %arrayidx359 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 2
  %287 = load float, ptr %arrayidx359, align 8
  store float %287, ptr %dx2, align 4
  %arrayidx360 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 3
  %288 = load float, ptr %arrayidx360, align 4
  store float %288, ptr %dy2, align 4
  %arrayidx361 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 4
  %289 = load float, ptr %arrayidx361, align 16
  store float %289, ptr %dx3, align 4
  %arrayidx362 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 5
  %290 = load float, ptr %arrayidx362, align 4
  store float %290, ptr %dy3, align 4
  %arrayidx363 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 6
  %291 = load float, ptr %arrayidx363, align 8
  store float %291, ptr %dx4, align 4
  %arrayidx364 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 7
  %292 = load float, ptr %arrayidx364, align 4
  store float %292, ptr %dy4, align 4
  %arrayidx365 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 8
  %293 = load float, ptr %arrayidx365, align 16
  store float %293, ptr %dx5, align 4
  %arrayidx366 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 9
  %294 = load float, ptr %arrayidx366, align 4
  store float %294, ptr %dy5, align 4
  %arrayidx367 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 10
  %295 = load float, ptr %arrayidx367, align 8
  store float %295, ptr %dy6, align 4
  store float %295, ptr %dx6, align 4
  %296 = load float, ptr %dx1, align 4
  %297 = load float, ptr %dx2, align 4
  %add368 = fadd float %296, %297
  %298 = load float, ptr %dx3, align 4
  %add369 = fadd float %add368, %298
  %299 = load float, ptr %dx4, align 4
  %add370 = fadd float %add369, %299
  %300 = load float, ptr %dx5, align 4
  %add371 = fadd float %add370, %300
  store float %add371, ptr %dx, align 4
  %301 = load float, ptr %dy1, align 4
  %302 = load float, ptr %dy2, align 4
  %add372 = fadd float %301, %302
  %303 = load float, ptr %dy3, align 4
  %add373 = fadd float %add372, %303
  %304 = load float, ptr %dy4, align 4
  %add374 = fadd float %add373, %304
  %305 = load float, ptr %dy5, align 4
  %add375 = fadd float %add374, %305
  store float %add375, ptr %dy, align 4
  %306 = load float, ptr %dx, align 4
  %307 = call float @llvm.fabs.f32(float %306)
  %308 = load float, ptr %dy, align 4
  %309 = call float @llvm.fabs.f32(float %308)
  %cmp376 = fcmp ogt float %307, %309
  br i1 %cmp376, label %if.then377, label %if.else379

if.then377:                                       ; preds = %if.end356
  %310 = load float, ptr %dy, align 4
  %fneg378 = fneg float %310
  store float %fneg378, ptr %dy6, align 4
  br label %if.end381

if.else379:                                       ; preds = %if.end356
  %311 = load float, ptr %dx, align 4
  %fneg380 = fneg float %311
  store float %fneg380, ptr %dx6, align 4
  br label %if.end381

if.end381:                                        ; preds = %if.else379, %if.then377
  %312 = load ptr, ptr %c.addr, align 8
  %313 = load float, ptr %dx1, align 4
  %314 = load float, ptr %dy1, align 4
  %315 = load float, ptr %dx2, align 4
  %316 = load float, ptr %dy2, align 4
  %317 = load float, ptr %dx3, align 4
  %318 = load float, ptr %dy3, align 4
  call void @_ZL23stbtt__csctx_rccurve_toP12stbtt__csctxffffff(ptr noundef %312, float noundef %313, float noundef %314, float noundef %315, float noundef %316, float noundef %317, float noundef %318)
  %319 = load ptr, ptr %c.addr, align 8
  %320 = load float, ptr %dx4, align 4
  %321 = load float, ptr %dy4, align 4
  %322 = load float, ptr %dx5, align 4
  %323 = load float, ptr %dy5, align 4
  %324 = load float, ptr %dx6, align 4
  %325 = load float, ptr %dy6, align 4
  call void @_ZL23stbtt__csctx_rccurve_toP12stbtt__csctxffffff(ptr noundef %319, float noundef %320, float noundef %321, float noundef %322, float noundef %323, float noundef %324, float noundef %325)
  br label %sw.epilog

sw.default:                                       ; preds = %sw.bb307
  store i32 0, ptr %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %if.end381, %if.end340, %if.end324, %if.end313
  br label %sw.epilog405

sw.default382:                                    ; preds = %while.body
  %326 = load i32, ptr %b0, align 4
  %cmp383 = icmp ne i32 %326, 255
  br i1 %cmp383, label %land.lhs.true, label %if.end388

land.lhs.true:                                    ; preds = %sw.default382
  %327 = load i32, ptr %b0, align 4
  %cmp384 = icmp ne i32 %327, 28
  br i1 %cmp384, label %land.lhs.true385, label %if.end388

land.lhs.true385:                                 ; preds = %land.lhs.true
  %328 = load i32, ptr %b0, align 4
  %cmp386 = icmp slt i32 %328, 32
  br i1 %cmp386, label %if.then387, label %if.end388

if.then387:                                       ; preds = %land.lhs.true385
  store i32 0, ptr %retval, align 4
  br label %return

if.end388:                                        ; preds = %land.lhs.true385, %land.lhs.true, %sw.default382
  %329 = load i32, ptr %b0, align 4
  %cmp389 = icmp eq i32 %329, 255
  br i1 %cmp389, label %if.then390, label %if.else394

if.then390:                                       ; preds = %if.end388
  %call391 = call noundef i32 @_ZL14stbtt__buf_getP10stbtt__bufi(ptr noundef %b, i32 noundef 4)
  %conv392 = sitofp i32 %call391 to float
  %div393 = fdiv float %conv392, 6.553600e+04
  store float %div393, ptr %f, align 4
  br label %if.end398

if.else394:                                       ; preds = %if.end388
  call void @_ZL15stbtt__buf_skipP10stbtt__bufi(ptr noundef %b, i32 noundef -1)
  %call395 = call noundef i32 @_ZL14stbtt__cff_intP10stbtt__buf(ptr noundef %b)
  %conv396 = trunc i32 %call395 to i16
  %conv397 = sitofp i16 %conv396 to float
  store float %conv397, ptr %f, align 4
  br label %if.end398

if.end398:                                        ; preds = %if.else394, %if.then390
  %330 = load i32, ptr %sp, align 4
  %cmp399 = icmp sge i32 %330, 48
  br i1 %cmp399, label %if.then400, label %if.end401

if.then400:                                       ; preds = %if.end398
  store i32 0, ptr %retval, align 4
  br label %return

if.end401:                                        ; preds = %if.end398
  %331 = load float, ptr %f, align 4
  %332 = load i32, ptr %sp, align 4
  %inc402 = add nsw i32 %332, 1
  store i32 %inc402, ptr %sp, align 4
  %idxprom403 = sext i32 %332 to i64
  %arrayidx404 = getelementptr inbounds [48 x float], ptr %s, i64 0, i64 %idxprom403
  store float %331, ptr %arrayidx404, align 4
  store i32 0, ptr %clear_stack, align 4
  br label %sw.epilog405

sw.epilog405:                                     ; preds = %if.end401, %sw.epilog, %if.end302, %if.end297, %for.end263, %if.end204, %if.end178, %for.end145, %for.end117, %for.end61, %for.end, %if.end25, %if.end18, %if.end11, %sw.bb5, %if.end
  %333 = load i32, ptr %clear_stack, align 4
  %tobool406 = icmp ne i32 %333, 0
  br i1 %tobool406, label %if.then407, label %if.end408

if.then407:                                       ; preds = %sw.epilog405
  store i32 0, ptr %sp, align 4
  br label %if.end408

if.end408:                                        ; preds = %if.then407, %sw.epilog405
  br label %while.cond, !llvm.loop !120

while.end:                                        ; preds = %while.cond
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %while.end, %if.then400, %if.then387, %sw.default, %if.then355, %if.then339, %if.then323, %if.then312, %sw.bb306, %if.then301, %if.then296, %if.then282, %if.then276, %if.then224, %if.then203, %if.then186, %if.then177, %if.then148, %if.then120, %if.then68, %if.then64, %if.then47, %if.then43, %if.then31, %if.then24, %if.then17, %if.then10
  %334 = load i32, ptr %retval, align 4
  ret i32 %334
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL21stbtt__csctx_rmove_toP12stbtt__csctxff(ptr noundef %ctx, float noundef %dx, float noundef %dy) #4 {
entry:
  %ctx.addr = alloca ptr, align 8
  %dx.addr = alloca float, align 4
  %dy.addr = alloca float, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store float %dx, ptr %dx.addr, align 4
  store float %dy, ptr %dy.addr, align 4
  %0 = load ptr, ptr %ctx.addr, align 8
  call void @_ZL24stbtt__csctx_close_shapeP12stbtt__csctx(ptr noundef %0)
  %1 = load ptr, ptr %ctx.addr, align 8
  %x = getelementptr inbounds %struct.stbtt__csctx, ptr %1, i32 0, i32 4
  %2 = load float, ptr %x, align 8
  %3 = load float, ptr %dx.addr, align 4
  %add = fadd float %2, %3
  %4 = load ptr, ptr %ctx.addr, align 8
  %x1 = getelementptr inbounds %struct.stbtt__csctx, ptr %4, i32 0, i32 4
  store float %add, ptr %x1, align 8
  %5 = load ptr, ptr %ctx.addr, align 8
  %first_x = getelementptr inbounds %struct.stbtt__csctx, ptr %5, i32 0, i32 2
  store float %add, ptr %first_x, align 8
  %6 = load ptr, ptr %ctx.addr, align 8
  %y = getelementptr inbounds %struct.stbtt__csctx, ptr %6, i32 0, i32 5
  %7 = load float, ptr %y, align 4
  %8 = load float, ptr %dy.addr, align 4
  %add2 = fadd float %7, %8
  %9 = load ptr, ptr %ctx.addr, align 8
  %y3 = getelementptr inbounds %struct.stbtt__csctx, ptr %9, i32 0, i32 5
  store float %add2, ptr %y3, align 4
  %10 = load ptr, ptr %ctx.addr, align 8
  %first_y = getelementptr inbounds %struct.stbtt__csctx, ptr %10, i32 0, i32 3
  store float %add2, ptr %first_y, align 4
  %11 = load ptr, ptr %ctx.addr, align 8
  %12 = load ptr, ptr %ctx.addr, align 8
  %x4 = getelementptr inbounds %struct.stbtt__csctx, ptr %12, i32 0, i32 4
  %13 = load float, ptr %x4, align 8
  %conv = fptosi float %13 to i32
  %14 = load ptr, ptr %ctx.addr, align 8
  %y5 = getelementptr inbounds %struct.stbtt__csctx, ptr %14, i32 0, i32 5
  %15 = load float, ptr %y5, align 4
  %conv6 = fptosi float %15 to i32
  call void @_ZL14stbtt__csctx_vP12stbtt__csctxhiiiiii(ptr noundef %11, i8 noundef zeroext 1, i32 noundef %conv, i32 noundef %conv6, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0)
  ret void
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL21stbtt__csctx_rline_toP12stbtt__csctxff(ptr noundef %ctx, float noundef %dx, float noundef %dy) #4 {
entry:
  %ctx.addr = alloca ptr, align 8
  %dx.addr = alloca float, align 4
  %dy.addr = alloca float, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store float %dx, ptr %dx.addr, align 4
  store float %dy, ptr %dy.addr, align 4
  %0 = load float, ptr %dx.addr, align 4
  %1 = load ptr, ptr %ctx.addr, align 8
  %x = getelementptr inbounds %struct.stbtt__csctx, ptr %1, i32 0, i32 4
  %2 = load float, ptr %x, align 8
  %add = fadd float %2, %0
  store float %add, ptr %x, align 8
  %3 = load float, ptr %dy.addr, align 4
  %4 = load ptr, ptr %ctx.addr, align 8
  %y = getelementptr inbounds %struct.stbtt__csctx, ptr %4, i32 0, i32 5
  %5 = load float, ptr %y, align 4
  %add1 = fadd float %5, %3
  store float %add1, ptr %y, align 4
  %6 = load ptr, ptr %ctx.addr, align 8
  %7 = load ptr, ptr %ctx.addr, align 8
  %x2 = getelementptr inbounds %struct.stbtt__csctx, ptr %7, i32 0, i32 4
  %8 = load float, ptr %x2, align 8
  %conv = fptosi float %8 to i32
  %9 = load ptr, ptr %ctx.addr, align 8
  %y3 = getelementptr inbounds %struct.stbtt__csctx, ptr %9, i32 0, i32 5
  %10 = load float, ptr %y3, align 4
  %conv4 = fptosi float %10 to i32
  call void @_ZL14stbtt__csctx_vP12stbtt__csctxhiiiiii(ptr noundef %6, i8 noundef zeroext 2, i32 noundef %conv, i32 noundef %conv4, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0)
  ret void
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL23stbtt__csctx_rccurve_toP12stbtt__csctxffffff(ptr noundef %ctx, float noundef %dx1, float noundef %dy1, float noundef %dx2, float noundef %dy2, float noundef %dx3, float noundef %dy3) #4 {
entry:
  %ctx.addr = alloca ptr, align 8
  %dx1.addr = alloca float, align 4
  %dy1.addr = alloca float, align 4
  %dx2.addr = alloca float, align 4
  %dy2.addr = alloca float, align 4
  %dx3.addr = alloca float, align 4
  %dy3.addr = alloca float, align 4
  %cx1 = alloca float, align 4
  %cy1 = alloca float, align 4
  %cx2 = alloca float, align 4
  %cy2 = alloca float, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store float %dx1, ptr %dx1.addr, align 4
  store float %dy1, ptr %dy1.addr, align 4
  store float %dx2, ptr %dx2.addr, align 4
  store float %dy2, ptr %dy2.addr, align 4
  store float %dx3, ptr %dx3.addr, align 4
  store float %dy3, ptr %dy3.addr, align 4
  %0 = load ptr, ptr %ctx.addr, align 8
  %x = getelementptr inbounds %struct.stbtt__csctx, ptr %0, i32 0, i32 4
  %1 = load float, ptr %x, align 8
  %2 = load float, ptr %dx1.addr, align 4
  %add = fadd float %1, %2
  store float %add, ptr %cx1, align 4
  %3 = load ptr, ptr %ctx.addr, align 8
  %y = getelementptr inbounds %struct.stbtt__csctx, ptr %3, i32 0, i32 5
  %4 = load float, ptr %y, align 4
  %5 = load float, ptr %dy1.addr, align 4
  %add1 = fadd float %4, %5
  store float %add1, ptr %cy1, align 4
  %6 = load float, ptr %cx1, align 4
  %7 = load float, ptr %dx2.addr, align 4
  %add2 = fadd float %6, %7
  store float %add2, ptr %cx2, align 4
  %8 = load float, ptr %cy1, align 4
  %9 = load float, ptr %dy2.addr, align 4
  %add3 = fadd float %8, %9
  store float %add3, ptr %cy2, align 4
  %10 = load float, ptr %cx2, align 4
  %11 = load float, ptr %dx3.addr, align 4
  %add4 = fadd float %10, %11
  %12 = load ptr, ptr %ctx.addr, align 8
  %x5 = getelementptr inbounds %struct.stbtt__csctx, ptr %12, i32 0, i32 4
  store float %add4, ptr %x5, align 8
  %13 = load float, ptr %cy2, align 4
  %14 = load float, ptr %dy3.addr, align 4
  %add6 = fadd float %13, %14
  %15 = load ptr, ptr %ctx.addr, align 8
  %y7 = getelementptr inbounds %struct.stbtt__csctx, ptr %15, i32 0, i32 5
  store float %add6, ptr %y7, align 4
  %16 = load ptr, ptr %ctx.addr, align 8
  %17 = load ptr, ptr %ctx.addr, align 8
  %x8 = getelementptr inbounds %struct.stbtt__csctx, ptr %17, i32 0, i32 4
  %18 = load float, ptr %x8, align 8
  %conv = fptosi float %18 to i32
  %19 = load ptr, ptr %ctx.addr, align 8
  %y9 = getelementptr inbounds %struct.stbtt__csctx, ptr %19, i32 0, i32 5
  %20 = load float, ptr %y9, align 4
  %conv10 = fptosi float %20 to i32
  %21 = load float, ptr %cx1, align 4
  %conv11 = fptosi float %21 to i32
  %22 = load float, ptr %cy1, align 4
  %conv12 = fptosi float %22 to i32
  %23 = load float, ptr %cx2, align 4
  %conv13 = fptosi float %23 to i32
  %24 = load float, ptr %cy2, align 4
  %conv14 = fptosi float %24 to i32
  call void @_ZL14stbtt__csctx_vP12stbtt__csctxhiiiiii(ptr noundef %16, i8 noundef zeroext 4, i32 noundef %conv, i32 noundef %conv10, i32 noundef %conv11, i32 noundef %conv12, i32 noundef %conv13, i32 noundef %conv14)
  ret void
}

; Function Attrs: mustprogress uwtable
define internal { ptr, i64 } @_ZL26stbtt__cid_get_glyph_subrsPK14stbtt_fontinfoi(ptr noundef %info, i32 noundef %glyph_index) #4 {
entry:
  %retval = alloca %struct.stbtt__buf, align 8
  %info.addr = alloca ptr, align 8
  %glyph_index.addr = alloca i32, align 4
  %fdselect = alloca %struct.stbtt__buf, align 8
  %nranges = alloca i32, align 4
  %start = alloca i32, align 4
  %end = alloca i32, align 4
  %v = alloca i32, align 4
  %fmt = alloca i32, align 4
  %fdselector = alloca i32, align 4
  %i = alloca i32, align 4
  %agg.tmp = alloca %struct.stbtt__buf, align 8
  %agg.tmp21 = alloca %struct.stbtt__buf, align 8
  %agg.tmp22 = alloca %struct.stbtt__buf, align 8
  store ptr %info, ptr %info.addr, align 8
  store i32 %glyph_index, ptr %glyph_index.addr, align 4
  %0 = load ptr, ptr %info.addr, align 8
  %fdselect1 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %0, i32 0, i32 19
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %fdselect, ptr align 8 %fdselect1, i64 16, i1 false)
  store i32 -1, ptr %fdselector, align 4
  call void @_ZL15stbtt__buf_seekP10stbtt__bufi(ptr noundef %fdselect, i32 noundef 0)
  %call = call noundef zeroext i8 @_ZL15stbtt__buf_get8P10stbtt__buf(ptr noundef %fdselect)
  %conv = zext i8 %call to i32
  store i32 %conv, ptr %fmt, align 4
  %1 = load i32, ptr %fmt, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %glyph_index.addr, align 4
  call void @_ZL15stbtt__buf_skipP10stbtt__bufi(ptr noundef %fdselect, i32 noundef %2)
  %call2 = call noundef zeroext i8 @_ZL15stbtt__buf_get8P10stbtt__buf(ptr noundef %fdselect)
  %conv3 = zext i8 %call2 to i32
  store i32 %conv3, ptr %fdselector, align 4
  br label %if.end16

if.else:                                          ; preds = %entry
  %3 = load i32, ptr %fmt, align 4
  %cmp4 = icmp eq i32 %3, 3
  br i1 %cmp4, label %if.then5, label %if.end15

if.then5:                                         ; preds = %if.else
  %call6 = call noundef i32 @_ZL14stbtt__buf_getP10stbtt__bufi(ptr noundef %fdselect, i32 noundef 2)
  store i32 %call6, ptr %nranges, align 4
  %call7 = call noundef i32 @_ZL14stbtt__buf_getP10stbtt__bufi(ptr noundef %fdselect, i32 noundef 2)
  store i32 %call7, ptr %start, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then5
  %4 = load i32, ptr %i, align 4
  %5 = load i32, ptr %nranges, align 4
  %cmp8 = icmp slt i32 %4, %5
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call9 = call noundef zeroext i8 @_ZL15stbtt__buf_get8P10stbtt__buf(ptr noundef %fdselect)
  %conv10 = zext i8 %call9 to i32
  store i32 %conv10, ptr %v, align 4
  %call11 = call noundef i32 @_ZL14stbtt__buf_getP10stbtt__bufi(ptr noundef %fdselect, i32 noundef 2)
  store i32 %call11, ptr %end, align 4
  %6 = load i32, ptr %glyph_index.addr, align 4
  %7 = load i32, ptr %start, align 4
  %cmp12 = icmp sge i32 %6, %7
  br i1 %cmp12, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %8 = load i32, ptr %glyph_index.addr, align 4
  %9 = load i32, ptr %end, align 4
  %cmp13 = icmp slt i32 %8, %9
  br i1 %cmp13, label %if.then14, label %if.end

if.then14:                                        ; preds = %land.lhs.true
  %10 = load i32, ptr %v, align 4
  store i32 %10, ptr %fdselector, align 4
  br label %for.end

if.end:                                           ; preds = %land.lhs.true, %for.body
  %11 = load i32, ptr %end, align 4
  store i32 %11, ptr %start, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %12 = load i32, ptr %i, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !121

for.end:                                          ; preds = %if.then14, %for.cond
  br label %if.end15

if.end15:                                         ; preds = %for.end, %if.else
  br label %if.end16

if.end16:                                         ; preds = %if.end15, %if.then
  %13 = load i32, ptr %fdselector, align 4
  %cmp17 = icmp eq i32 %13, -1
  br i1 %cmp17, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.end16
  %call19 = call { ptr, i64 } @_ZL14stbtt__new_bufPKvm(ptr noundef null, i64 noundef 0)
  %14 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %15 = extractvalue { ptr, i64 } %call19, 0
  store ptr %15, ptr %14, align 8
  %16 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %17 = extractvalue { ptr, i64 } %call19, 1
  store i64 %17, ptr %16, align 8
  br label %return

if.end20:                                         ; preds = %if.end16
  %18 = load ptr, ptr %info.addr, align 8
  %cff = getelementptr inbounds %struct.stbtt_fontinfo, ptr %18, i32 0, i32 14
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %cff, i64 16, i1 false)
  %19 = load ptr, ptr %info.addr, align 8
  %fontdicts = getelementptr inbounds %struct.stbtt_fontinfo, ptr %19, i32 0, i32 18
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp22, ptr align 8 %fontdicts, i64 16, i1 false)
  %20 = load i32, ptr %fdselector, align 4
  %21 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp22, i32 0, i32 0
  %22 = load ptr, ptr %21, align 8
  %23 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp22, i32 0, i32 1
  %24 = load i64, ptr %23, align 8
  %call23 = call { ptr, i64 } @_ZL20stbtt__cff_index_get10stbtt__bufi(ptr %22, i64 %24, i32 noundef %20)
  %25 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp21, i32 0, i32 0
  %26 = extractvalue { ptr, i64 } %call23, 0
  store ptr %26, ptr %25, align 8
  %27 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp21, i32 0, i32 1
  %28 = extractvalue { ptr, i64 } %call23, 1
  store i64 %28, ptr %27, align 8
  %29 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %30 = load ptr, ptr %29, align 8
  %31 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %32 = load i64, ptr %31, align 8
  %33 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp21, i32 0, i32 0
  %34 = load ptr, ptr %33, align 8
  %35 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp21, i32 0, i32 1
  %36 = load i64, ptr %35, align 8
  %call24 = call { ptr, i64 } @_ZL16stbtt__get_subrs10stbtt__bufS_(ptr %30, i64 %32, ptr %34, i64 %36)
  %37 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %38 = extractvalue { ptr, i64 } %call24, 0
  store ptr %38, ptr %37, align 8
  %39 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %40 = extractvalue { ptr, i64 } %call24, 1
  store i64 %40, ptr %39, align 8
  br label %return

return:                                           ; preds = %if.end20, %if.then18
  %41 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %41
}

; Function Attrs: mustprogress uwtable
define internal { ptr, i64 } @_ZL15stbtt__get_subr10stbtt__bufi(ptr %idx.coerce0, i64 %idx.coerce1, i32 noundef %n) #4 {
entry:
  %retval = alloca %struct.stbtt__buf, align 8
  %idx = alloca %struct.stbtt__buf, align 8
  %n.addr = alloca i32, align 4
  %count = alloca i32, align 4
  %bias = alloca i32, align 4
  %agg.tmp = alloca %struct.stbtt__buf, align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %idx, i32 0, i32 0
  store ptr %idx.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %idx, i32 0, i32 1
  store i64 %idx.coerce1, ptr %1, align 8
  store i32 %n, ptr %n.addr, align 4
  %call = call noundef i32 @_ZL22stbtt__cff_index_countP10stbtt__buf(ptr noundef %idx)
  store i32 %call, ptr %count, align 4
  store i32 107, ptr %bias, align 4
  %2 = load i32, ptr %count, align 4
  %cmp = icmp sge i32 %2, 33900
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 32768, ptr %bias, align 4
  br label %if.end3

if.else:                                          ; preds = %entry
  %3 = load i32, ptr %count, align 4
  %cmp1 = icmp sge i32 %3, 1240
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  store i32 1131, ptr %bias, align 4
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.else
  br label %if.end3

if.end3:                                          ; preds = %if.end, %if.then
  %4 = load i32, ptr %bias, align 4
  %5 = load i32, ptr %n.addr, align 4
  %add = add nsw i32 %5, %4
  store i32 %add, ptr %n.addr, align 4
  %6 = load i32, ptr %n.addr, align 4
  %cmp4 = icmp slt i32 %6, 0
  br i1 %cmp4, label %if.then6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end3
  %7 = load i32, ptr %n.addr, align 4
  %8 = load i32, ptr %count, align 4
  %cmp5 = icmp sge i32 %7, %8
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %lor.lhs.false, %if.end3
  %call7 = call { ptr, i64 } @_ZL14stbtt__new_bufPKvm(ptr noundef null, i64 noundef 0)
  %9 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %10 = extractvalue { ptr, i64 } %call7, 0
  store ptr %10, ptr %9, align 8
  %11 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %12 = extractvalue { ptr, i64 } %call7, 1
  store i64 %12, ptr %11, align 8
  br label %return

if.end8:                                          ; preds = %lor.lhs.false
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %idx, i64 16, i1 false)
  %13 = load i32, ptr %n.addr, align 4
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %17 = load i64, ptr %16, align 8
  %call9 = call { ptr, i64 } @_ZL20stbtt__cff_index_get10stbtt__bufi(ptr %15, i64 %17, i32 noundef %13)
  %18 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %19 = extractvalue { ptr, i64 } %call9, 0
  store ptr %19, ptr %18, align 8
  %20 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %21 = extractvalue { ptr, i64 } %call9, 1
  store i64 %21, ptr %20, align 8
  br label %return

return:                                           ; preds = %if.end8, %if.then6
  %22 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %22
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL24stbtt__csctx_close_shapeP12stbtt__csctx(ptr noundef %ctx) #4 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %first_x = getelementptr inbounds %struct.stbtt__csctx, ptr %0, i32 0, i32 2
  %1 = load float, ptr %first_x, align 8
  %2 = load ptr, ptr %ctx.addr, align 8
  %x = getelementptr inbounds %struct.stbtt__csctx, ptr %2, i32 0, i32 4
  %3 = load float, ptr %x, align 8
  %cmp = fcmp une float %1, %3
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load ptr, ptr %ctx.addr, align 8
  %first_y = getelementptr inbounds %struct.stbtt__csctx, ptr %4, i32 0, i32 3
  %5 = load float, ptr %first_y, align 4
  %6 = load ptr, ptr %ctx.addr, align 8
  %y = getelementptr inbounds %struct.stbtt__csctx, ptr %6, i32 0, i32 5
  %7 = load float, ptr %y, align 4
  %cmp1 = fcmp une float %5, %7
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %8 = load ptr, ptr %ctx.addr, align 8
  %9 = load ptr, ptr %ctx.addr, align 8
  %first_x2 = getelementptr inbounds %struct.stbtt__csctx, ptr %9, i32 0, i32 2
  %10 = load float, ptr %first_x2, align 8
  %conv = fptosi float %10 to i32
  %11 = load ptr, ptr %ctx.addr, align 8
  %first_y3 = getelementptr inbounds %struct.stbtt__csctx, ptr %11, i32 0, i32 3
  %12 = load float, ptr %first_y3, align 4
  %conv4 = fptosi float %12 to i32
  call void @_ZL14stbtt__csctx_vP12stbtt__csctxhiiiiii(ptr noundef %8, i8 noundef zeroext 2, i32 noundef %conv, i32 noundef %conv4, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  ret void
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL14stbtt__csctx_vP12stbtt__csctxhiiiiii(ptr noundef %c, i8 noundef zeroext %type, i32 noundef %x, i32 noundef %y, i32 noundef %cx, i32 noundef %cy, i32 noundef %cx1, i32 noundef %cy1) #4 {
entry:
  %c.addr = alloca ptr, align 8
  %type.addr = alloca i8, align 1
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %cx.addr = alloca i32, align 4
  %cy.addr = alloca i32, align 4
  %cx1.addr = alloca i32, align 4
  %cy1.addr = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  store i8 %type, ptr %type.addr, align 1
  store i32 %x, ptr %x.addr, align 4
  store i32 %y, ptr %y.addr, align 4
  store i32 %cx, ptr %cx.addr, align 4
  store i32 %cy, ptr %cy.addr, align 4
  store i32 %cx1, ptr %cx1.addr, align 4
  store i32 %cy1, ptr %cy1.addr, align 4
  %0 = load ptr, ptr %c.addr, align 8
  %bounds = getelementptr inbounds %struct.stbtt__csctx, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %bounds, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %c.addr, align 8
  %3 = load i32, ptr %x.addr, align 4
  %4 = load i32, ptr %y.addr, align 4
  call void @_ZL19stbtt__track_vertexP12stbtt__csctxii(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  %5 = load i8, ptr %type.addr, align 1
  %conv = zext i8 %5 to i32
  %cmp = icmp eq i32 %conv, 4
  br i1 %cmp, label %if.then1, label %if.end

if.then1:                                         ; preds = %if.then
  %6 = load ptr, ptr %c.addr, align 8
  %7 = load i32, ptr %cx.addr, align 4
  %8 = load i32, ptr %cy.addr, align 4
  call void @_ZL19stbtt__track_vertexP12stbtt__csctxii(ptr noundef %6, i32 noundef %7, i32 noundef %8)
  %9 = load ptr, ptr %c.addr, align 8
  %10 = load i32, ptr %cx1.addr, align 4
  %11 = load i32, ptr %cy1.addr, align 4
  call void @_ZL19stbtt__track_vertexP12stbtt__csctxii(ptr noundef %9, i32 noundef %10, i32 noundef %11)
  br label %if.end

if.end:                                           ; preds = %if.then1, %if.then
  br label %if.end14

if.else:                                          ; preds = %entry
  %12 = load ptr, ptr %c.addr, align 8
  %pvertices = getelementptr inbounds %struct.stbtt__csctx, ptr %12, i32 0, i32 10
  %13 = load ptr, ptr %pvertices, align 8
  %14 = load ptr, ptr %c.addr, align 8
  %num_vertices = getelementptr inbounds %struct.stbtt__csctx, ptr %14, i32 0, i32 11
  %15 = load i32, ptr %num_vertices, align 8
  %idxprom = sext i32 %15 to i64
  %arrayidx = getelementptr inbounds %struct.stbtt_vertex, ptr %13, i64 %idxprom
  %16 = load i8, ptr %type.addr, align 1
  %17 = load i32, ptr %x.addr, align 4
  %18 = load i32, ptr %y.addr, align 4
  %19 = load i32, ptr %cx.addr, align 4
  %20 = load i32, ptr %cy.addr, align 4
  call void @_ZL15stbtt_setvertexP12stbtt_vertexhiiii(ptr noundef %arrayidx, i8 noundef zeroext %16, i32 noundef %17, i32 noundef %18, i32 noundef %19, i32 noundef %20)
  %21 = load i32, ptr %cx1.addr, align 4
  %conv2 = trunc i32 %21 to i16
  %22 = load ptr, ptr %c.addr, align 8
  %pvertices3 = getelementptr inbounds %struct.stbtt__csctx, ptr %22, i32 0, i32 10
  %23 = load ptr, ptr %pvertices3, align 8
  %24 = load ptr, ptr %c.addr, align 8
  %num_vertices4 = getelementptr inbounds %struct.stbtt__csctx, ptr %24, i32 0, i32 11
  %25 = load i32, ptr %num_vertices4, align 8
  %idxprom5 = sext i32 %25 to i64
  %arrayidx6 = getelementptr inbounds %struct.stbtt_vertex, ptr %23, i64 %idxprom5
  %cx17 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx6, i32 0, i32 4
  store i16 %conv2, ptr %cx17, align 2
  %26 = load i32, ptr %cy1.addr, align 4
  %conv8 = trunc i32 %26 to i16
  %27 = load ptr, ptr %c.addr, align 8
  %pvertices9 = getelementptr inbounds %struct.stbtt__csctx, ptr %27, i32 0, i32 10
  %28 = load ptr, ptr %pvertices9, align 8
  %29 = load ptr, ptr %c.addr, align 8
  %num_vertices10 = getelementptr inbounds %struct.stbtt__csctx, ptr %29, i32 0, i32 11
  %30 = load i32, ptr %num_vertices10, align 8
  %idxprom11 = sext i32 %30 to i64
  %arrayidx12 = getelementptr inbounds %struct.stbtt_vertex, ptr %28, i64 %idxprom11
  %cy113 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx12, i32 0, i32 5
  store i16 %conv8, ptr %cy113, align 2
  br label %if.end14

if.end14:                                         ; preds = %if.else, %if.end
  %31 = load ptr, ptr %c.addr, align 8
  %num_vertices15 = getelementptr inbounds %struct.stbtt__csctx, ptr %31, i32 0, i32 11
  %32 = load i32, ptr %num_vertices15, align 8
  %inc = add nsw i32 %32, 1
  store i32 %inc, ptr %num_vertices15, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZL19stbtt__track_vertexP12stbtt__csctxii(ptr noundef %c, i32 noundef %x, i32 noundef %y) #2 {
entry:
  %c.addr = alloca ptr, align 8
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  store i32 %x, ptr %x.addr, align 4
  store i32 %y, ptr %y.addr, align 4
  %0 = load i32, ptr %x.addr, align 4
  %1 = load ptr, ptr %c.addr, align 8
  %max_x = getelementptr inbounds %struct.stbtt__csctx, ptr %1, i32 0, i32 7
  %2 = load i32, ptr %max_x, align 4
  %cmp = icmp sgt i32 %0, %2
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load ptr, ptr %c.addr, align 8
  %started = getelementptr inbounds %struct.stbtt__csctx, ptr %3, i32 0, i32 1
  %4 = load i32, ptr %started, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %5 = load i32, ptr %x.addr, align 4
  %6 = load ptr, ptr %c.addr, align 8
  %max_x1 = getelementptr inbounds %struct.stbtt__csctx, ptr %6, i32 0, i32 7
  store i32 %5, ptr %max_x1, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %7 = load i32, ptr %y.addr, align 4
  %8 = load ptr, ptr %c.addr, align 8
  %max_y = getelementptr inbounds %struct.stbtt__csctx, ptr %8, i32 0, i32 9
  %9 = load i32, ptr %max_y, align 4
  %cmp2 = icmp sgt i32 %7, %9
  br i1 %cmp2, label %if.then6, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %if.end
  %10 = load ptr, ptr %c.addr, align 8
  %started4 = getelementptr inbounds %struct.stbtt__csctx, ptr %10, i32 0, i32 1
  %11 = load i32, ptr %started4, align 4
  %tobool5 = icmp ne i32 %11, 0
  br i1 %tobool5, label %if.end8, label %if.then6

if.then6:                                         ; preds = %lor.lhs.false3, %if.end
  %12 = load i32, ptr %y.addr, align 4
  %13 = load ptr, ptr %c.addr, align 8
  %max_y7 = getelementptr inbounds %struct.stbtt__csctx, ptr %13, i32 0, i32 9
  store i32 %12, ptr %max_y7, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %lor.lhs.false3
  %14 = load i32, ptr %x.addr, align 4
  %15 = load ptr, ptr %c.addr, align 8
  %min_x = getelementptr inbounds %struct.stbtt__csctx, ptr %15, i32 0, i32 6
  %16 = load i32, ptr %min_x, align 8
  %cmp9 = icmp slt i32 %14, %16
  br i1 %cmp9, label %if.then13, label %lor.lhs.false10

lor.lhs.false10:                                  ; preds = %if.end8
  %17 = load ptr, ptr %c.addr, align 8
  %started11 = getelementptr inbounds %struct.stbtt__csctx, ptr %17, i32 0, i32 1
  %18 = load i32, ptr %started11, align 4
  %tobool12 = icmp ne i32 %18, 0
  br i1 %tobool12, label %if.end15, label %if.then13

if.then13:                                        ; preds = %lor.lhs.false10, %if.end8
  %19 = load i32, ptr %x.addr, align 4
  %20 = load ptr, ptr %c.addr, align 8
  %min_x14 = getelementptr inbounds %struct.stbtt__csctx, ptr %20, i32 0, i32 6
  store i32 %19, ptr %min_x14, align 8
  br label %if.end15

if.end15:                                         ; preds = %if.then13, %lor.lhs.false10
  %21 = load i32, ptr %y.addr, align 4
  %22 = load ptr, ptr %c.addr, align 8
  %min_y = getelementptr inbounds %struct.stbtt__csctx, ptr %22, i32 0, i32 8
  %23 = load i32, ptr %min_y, align 8
  %cmp16 = icmp slt i32 %21, %23
  br i1 %cmp16, label %if.then20, label %lor.lhs.false17

lor.lhs.false17:                                  ; preds = %if.end15
  %24 = load ptr, ptr %c.addr, align 8
  %started18 = getelementptr inbounds %struct.stbtt__csctx, ptr %24, i32 0, i32 1
  %25 = load i32, ptr %started18, align 4
  %tobool19 = icmp ne i32 %25, 0
  br i1 %tobool19, label %if.end22, label %if.then20

if.then20:                                        ; preds = %lor.lhs.false17, %if.end15
  %26 = load i32, ptr %y.addr, align 4
  %27 = load ptr, ptr %c.addr, align 8
  %min_y21 = getelementptr inbounds %struct.stbtt__csctx, ptr %27, i32 0, i32 8
  store i32 %26, ptr %min_y21, align 8
  br label %if.end22

if.end22:                                         ; preds = %if.then20, %lor.lhs.false17
  %28 = load ptr, ptr %c.addr, align 8
  %started23 = getelementptr inbounds %struct.stbtt__csctx, ptr %28, i32 0, i32 1
  store i32 1, ptr %started23, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZL15stbtt_setvertexP12stbtt_vertexhiiii(ptr noundef %v, i8 noundef zeroext %type, i32 noundef %x, i32 noundef %y, i32 noundef %cx, i32 noundef %cy) #2 {
entry:
  %v.addr = alloca ptr, align 8
  %type.addr = alloca i8, align 1
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %cx.addr = alloca i32, align 4
  %cy.addr = alloca i32, align 4
  store ptr %v, ptr %v.addr, align 8
  store i8 %type, ptr %type.addr, align 1
  store i32 %x, ptr %x.addr, align 4
  store i32 %y, ptr %y.addr, align 4
  store i32 %cx, ptr %cx.addr, align 4
  store i32 %cy, ptr %cy.addr, align 4
  %0 = load i8, ptr %type.addr, align 1
  %1 = load ptr, ptr %v.addr, align 8
  %type1 = getelementptr inbounds %struct.stbtt_vertex, ptr %1, i32 0, i32 6
  store i8 %0, ptr %type1, align 2
  %2 = load i32, ptr %x.addr, align 4
  %conv = trunc i32 %2 to i16
  %3 = load ptr, ptr %v.addr, align 8
  %x2 = getelementptr inbounds %struct.stbtt_vertex, ptr %3, i32 0, i32 0
  store i16 %conv, ptr %x2, align 2
  %4 = load i32, ptr %y.addr, align 4
  %conv3 = trunc i32 %4 to i16
  %5 = load ptr, ptr %v.addr, align 8
  %y4 = getelementptr inbounds %struct.stbtt_vertex, ptr %5, i32 0, i32 1
  store i16 %conv3, ptr %y4, align 2
  %6 = load i32, ptr %cx.addr, align 4
  %conv5 = trunc i32 %6 to i16
  %7 = load ptr, ptr %v.addr, align 8
  %cx6 = getelementptr inbounds %struct.stbtt_vertex, ptr %7, i32 0, i32 2
  store i16 %conv5, ptr %cx6, align 2
  %8 = load i32, ptr %cy.addr, align 4
  %conv7 = trunc i32 %8 to i16
  %9 = load ptr, ptr %v.addr, align 8
  %cy8 = getelementptr inbounds %struct.stbtt_vertex, ptr %9, i32 0, i32 3
  store i16 %conv7, ptr %cy8, align 2
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZL22stbtt__cff_index_countP10stbtt__buf(ptr noundef %b) #2 {
entry:
  %b.addr = alloca ptr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %b.addr, align 8
  call void @_ZL15stbtt__buf_seekP10stbtt__bufi(ptr noundef %0, i32 noundef 0)
  %1 = load ptr, ptr %b.addr, align 8
  %call = call noundef i32 @_ZL14stbtt__buf_getP10stbtt__bufi(ptr noundef %1, i32 noundef 2)
  ret i32 %call
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL17stbrp_init_targetP13stbrp_contextiiP10stbrp_nodei(ptr noundef %context, i32 noundef %width, i32 noundef %height, ptr noundef %nodes, i32 noundef %num_nodes) #4 {
entry:
  %context.addr = alloca ptr, align 8
  %width.addr = alloca i32, align 4
  %height.addr = alloca i32, align 4
  %nodes.addr = alloca ptr, align 8
  %num_nodes.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %context, ptr %context.addr, align 8
  store i32 %width, ptr %width.addr, align 4
  store i32 %height, ptr %height.addr, align 4
  store ptr %nodes, ptr %nodes.addr, align 8
  store i32 %num_nodes, ptr %num_nodes.addr, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %1 = load i32, ptr %num_nodes.addr, align 4
  %sub = sub nsw i32 %1, 1
  %cmp = icmp slt i32 %0, %sub
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %nodes.addr, align 8
  %3 = load i32, ptr %i, align 4
  %add = add nsw i32 %3, 1
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr inbounds %struct.stbrp_node, ptr %2, i64 %idxprom
  %4 = load ptr, ptr %nodes.addr, align 8
  %5 = load i32, ptr %i, align 4
  %idxprom1 = sext i32 %5 to i64
  %arrayidx2 = getelementptr inbounds %struct.stbrp_node, ptr %4, i64 %idxprom1
  %next = getelementptr inbounds %struct.stbrp_node, ptr %arrayidx2, i32 0, i32 2
  store ptr %arrayidx, ptr %next, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i32, ptr %i, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !122

for.end:                                          ; preds = %for.cond
  %7 = load ptr, ptr %nodes.addr, align 8
  %8 = load i32, ptr %i, align 4
  %idxprom3 = sext i32 %8 to i64
  %arrayidx4 = getelementptr inbounds %struct.stbrp_node, ptr %7, i64 %idxprom3
  %next5 = getelementptr inbounds %struct.stbrp_node, ptr %arrayidx4, i32 0, i32 2
  store ptr null, ptr %next5, align 8
  %9 = load ptr, ptr %context.addr, align 8
  %init_mode = getelementptr inbounds %struct.stbrp_context, ptr %9, i32 0, i32 3
  store i32 1, ptr %init_mode, align 4
  %10 = load ptr, ptr %context.addr, align 8
  %heuristic = getelementptr inbounds %struct.stbrp_context, ptr %10, i32 0, i32 4
  store i32 0, ptr %heuristic, align 8
  %11 = load ptr, ptr %nodes.addr, align 8
  %arrayidx6 = getelementptr inbounds %struct.stbrp_node, ptr %11, i64 0
  %12 = load ptr, ptr %context.addr, align 8
  %free_head = getelementptr inbounds %struct.stbrp_context, ptr %12, i32 0, i32 7
  store ptr %arrayidx6, ptr %free_head, align 8
  %13 = load ptr, ptr %context.addr, align 8
  %extra = getelementptr inbounds %struct.stbrp_context, ptr %13, i32 0, i32 8
  %arrayidx7 = getelementptr inbounds [2 x %struct.stbrp_node], ptr %extra, i64 0, i64 0
  %14 = load ptr, ptr %context.addr, align 8
  %active_head = getelementptr inbounds %struct.stbrp_context, ptr %14, i32 0, i32 6
  store ptr %arrayidx7, ptr %active_head, align 8
  %15 = load i32, ptr %width.addr, align 4
  %16 = load ptr, ptr %context.addr, align 8
  %width8 = getelementptr inbounds %struct.stbrp_context, ptr %16, i32 0, i32 0
  store i32 %15, ptr %width8, align 8
  %17 = load i32, ptr %height.addr, align 4
  %18 = load ptr, ptr %context.addr, align 8
  %height9 = getelementptr inbounds %struct.stbrp_context, ptr %18, i32 0, i32 1
  store i32 %17, ptr %height9, align 4
  %19 = load i32, ptr %num_nodes.addr, align 4
  %20 = load ptr, ptr %context.addr, align 8
  %num_nodes10 = getelementptr inbounds %struct.stbrp_context, ptr %20, i32 0, i32 5
  store i32 %19, ptr %num_nodes10, align 4
  %21 = load ptr, ptr %context.addr, align 8
  call void @_ZL28stbrp_setup_allow_out_of_memP13stbrp_contexti(ptr noundef %21, i32 noundef 0)
  %22 = load ptr, ptr %context.addr, align 8
  %extra11 = getelementptr inbounds %struct.stbrp_context, ptr %22, i32 0, i32 8
  %arrayidx12 = getelementptr inbounds [2 x %struct.stbrp_node], ptr %extra11, i64 0, i64 0
  %x = getelementptr inbounds %struct.stbrp_node, ptr %arrayidx12, i32 0, i32 0
  store i32 0, ptr %x, align 8
  %23 = load ptr, ptr %context.addr, align 8
  %extra13 = getelementptr inbounds %struct.stbrp_context, ptr %23, i32 0, i32 8
  %arrayidx14 = getelementptr inbounds [2 x %struct.stbrp_node], ptr %extra13, i64 0, i64 0
  %y = getelementptr inbounds %struct.stbrp_node, ptr %arrayidx14, i32 0, i32 1
  store i32 0, ptr %y, align 4
  %24 = load ptr, ptr %context.addr, align 8
  %extra15 = getelementptr inbounds %struct.stbrp_context, ptr %24, i32 0, i32 8
  %arrayidx16 = getelementptr inbounds [2 x %struct.stbrp_node], ptr %extra15, i64 0, i64 1
  %25 = load ptr, ptr %context.addr, align 8
  %extra17 = getelementptr inbounds %struct.stbrp_context, ptr %25, i32 0, i32 8
  %arrayidx18 = getelementptr inbounds [2 x %struct.stbrp_node], ptr %extra17, i64 0, i64 0
  %next19 = getelementptr inbounds %struct.stbrp_node, ptr %arrayidx18, i32 0, i32 2
  store ptr %arrayidx16, ptr %next19, align 8
  %26 = load i32, ptr %width.addr, align 4
  %27 = load ptr, ptr %context.addr, align 8
  %extra20 = getelementptr inbounds %struct.stbrp_context, ptr %27, i32 0, i32 8
  %arrayidx21 = getelementptr inbounds [2 x %struct.stbrp_node], ptr %extra20, i64 0, i64 1
  %x22 = getelementptr inbounds %struct.stbrp_node, ptr %arrayidx21, i32 0, i32 0
  store i32 %26, ptr %x22, align 8
  %28 = load ptr, ptr %context.addr, align 8
  %extra23 = getelementptr inbounds %struct.stbrp_context, ptr %28, i32 0, i32 8
  %arrayidx24 = getelementptr inbounds [2 x %struct.stbrp_node], ptr %extra23, i64 0, i64 1
  %y25 = getelementptr inbounds %struct.stbrp_node, ptr %arrayidx24, i32 0, i32 1
  store i32 1073741824, ptr %y25, align 4
  %29 = load ptr, ptr %context.addr, align 8
  %extra26 = getelementptr inbounds %struct.stbrp_context, ptr %29, i32 0, i32 8
  %arrayidx27 = getelementptr inbounds [2 x %struct.stbrp_node], ptr %extra26, i64 0, i64 1
  %next28 = getelementptr inbounds %struct.stbrp_node, ptr %arrayidx27, i32 0, i32 2
  store ptr null, ptr %next28, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZL28stbrp_setup_allow_out_of_memP13stbrp_contexti(ptr noundef %context, i32 noundef %allow_out_of_mem) #2 {
entry:
  %context.addr = alloca ptr, align 8
  %allow_out_of_mem.addr = alloca i32, align 4
  store ptr %context, ptr %context.addr, align 8
  store i32 %allow_out_of_mem, ptr %allow_out_of_mem.addr, align 4
  %0 = load i32, ptr %allow_out_of_mem.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %context.addr, align 8
  %align = getelementptr inbounds %struct.stbrp_context, ptr %1, i32 0, i32 2
  store i32 1, ptr %align, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %2 = load ptr, ptr %context.addr, align 8
  %width = getelementptr inbounds %struct.stbrp_context, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %width, align 8
  %4 = load ptr, ptr %context.addr, align 8
  %num_nodes = getelementptr inbounds %struct.stbrp_context, ptr %4, i32 0, i32 5
  %5 = load i32, ptr %num_nodes, align 4
  %add = add nsw i32 %3, %5
  %sub = sub nsw i32 %add, 1
  %6 = load ptr, ptr %context.addr, align 8
  %num_nodes1 = getelementptr inbounds %struct.stbrp_context, ptr %6, i32 0, i32 5
  %7 = load i32, ptr %num_nodes1, align 4
  %div = sdiv i32 %sub, %7
  %8 = load ptr, ptr %context.addr, align 8
  %align2 = getelementptr inbounds %struct.stbrp_context, ptr %8, i32 0, i32 2
  store i32 %div, ptr %align2, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef float @_ZL23stbtt__oversample_shifti(i32 noundef %oversample) #2 {
entry:
  %retval = alloca float, align 4
  %oversample.addr = alloca i32, align 4
  store i32 %oversample, ptr %oversample.addr, align 4
  %0 = load i32, ptr %oversample.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store float 0.000000e+00, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, ptr %oversample.addr, align 4
  %sub = sub nsw i32 %1, 1
  %sub1 = sub nsw i32 0, %sub
  %conv = sitofp i32 %sub1 to float
  %2 = load i32, ptr %oversample.addr, align 4
  %conv2 = sitofp i32 %2 to float
  %mul = fmul float 2.000000e+00, %conv2
  %div = fdiv float %conv, %mul
  store float %div, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load float, ptr %retval, align 4
  ret float %3
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZL22stbtt_GetGlyphHMetricsPK14stbtt_fontinfoiPiS2_(ptr noundef %info, i32 noundef %glyph_index, ptr noundef %advanceWidth, ptr noundef %leftSideBearing) #2 {
entry:
  %info.addr = alloca ptr, align 8
  %glyph_index.addr = alloca i32, align 4
  %advanceWidth.addr = alloca ptr, align 8
  %leftSideBearing.addr = alloca ptr, align 8
  %numOfLongHorMetrics = alloca i16, align 2
  store ptr %info, ptr %info.addr, align 8
  store i32 %glyph_index, ptr %glyph_index.addr, align 4
  store ptr %advanceWidth, ptr %advanceWidth.addr, align 8
  store ptr %leftSideBearing, ptr %leftSideBearing.addr, align 8
  %0 = load ptr, ptr %info.addr, align 8
  %data = getelementptr inbounds %struct.stbtt_fontinfo, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %data, align 8
  %2 = load ptr, ptr %info.addr, align 8
  %hhea = getelementptr inbounds %struct.stbtt_fontinfo, ptr %2, i32 0, i32 7
  %3 = load i32, ptr %hhea, align 4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds i8, ptr %1, i64 %idx.ext
  %add.ptr1 = getelementptr inbounds i8, ptr %add.ptr, i64 34
  %call = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr1)
  store i16 %call, ptr %numOfLongHorMetrics, align 2
  %4 = load i32, ptr %glyph_index.addr, align 4
  %5 = load i16, ptr %numOfLongHorMetrics, align 2
  %conv = zext i16 %5 to i32
  %cmp = icmp slt i32 %4, %conv
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %6 = load ptr, ptr %advanceWidth.addr, align 8
  %tobool = icmp ne ptr %6, null
  br i1 %tobool, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %7 = load ptr, ptr %info.addr, align 8
  %data3 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %7, i32 0, i32 1
  %8 = load ptr, ptr %data3, align 8
  %9 = load ptr, ptr %info.addr, align 8
  %hmtx = getelementptr inbounds %struct.stbtt_fontinfo, ptr %9, i32 0, i32 8
  %10 = load i32, ptr %hmtx, align 8
  %idx.ext4 = sext i32 %10 to i64
  %add.ptr5 = getelementptr inbounds i8, ptr %8, i64 %idx.ext4
  %11 = load i32, ptr %glyph_index.addr, align 4
  %mul = mul nsw i32 4, %11
  %idx.ext6 = sext i32 %mul to i64
  %add.ptr7 = getelementptr inbounds i8, ptr %add.ptr5, i64 %idx.ext6
  %call8 = call noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %add.ptr7)
  %conv9 = sext i16 %call8 to i32
  %12 = load ptr, ptr %advanceWidth.addr, align 8
  store i32 %conv9, ptr %12, align 4
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %13 = load ptr, ptr %leftSideBearing.addr, align 8
  %tobool10 = icmp ne ptr %13, null
  br i1 %tobool10, label %if.then11, label %if.end22

if.then11:                                        ; preds = %if.end
  %14 = load ptr, ptr %info.addr, align 8
  %data12 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %14, i32 0, i32 1
  %15 = load ptr, ptr %data12, align 8
  %16 = load ptr, ptr %info.addr, align 8
  %hmtx13 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %16, i32 0, i32 8
  %17 = load i32, ptr %hmtx13, align 8
  %idx.ext14 = sext i32 %17 to i64
  %add.ptr15 = getelementptr inbounds i8, ptr %15, i64 %idx.ext14
  %18 = load i32, ptr %glyph_index.addr, align 4
  %mul16 = mul nsw i32 4, %18
  %idx.ext17 = sext i32 %mul16 to i64
  %add.ptr18 = getelementptr inbounds i8, ptr %add.ptr15, i64 %idx.ext17
  %add.ptr19 = getelementptr inbounds i8, ptr %add.ptr18, i64 2
  %call20 = call noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %add.ptr19)
  %conv21 = sext i16 %call20 to i32
  %19 = load ptr, ptr %leftSideBearing.addr, align 8
  store i32 %conv21, ptr %19, align 4
  br label %if.end22

if.end22:                                         ; preds = %if.then11, %if.end
  br label %if.end54

if.else:                                          ; preds = %entry
  %20 = load ptr, ptr %advanceWidth.addr, align 8
  %tobool23 = icmp ne ptr %20, null
  br i1 %tobool23, label %if.then24, label %if.end35

if.then24:                                        ; preds = %if.else
  %21 = load ptr, ptr %info.addr, align 8
  %data25 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %21, i32 0, i32 1
  %22 = load ptr, ptr %data25, align 8
  %23 = load ptr, ptr %info.addr, align 8
  %hmtx26 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %23, i32 0, i32 8
  %24 = load i32, ptr %hmtx26, align 8
  %idx.ext27 = sext i32 %24 to i64
  %add.ptr28 = getelementptr inbounds i8, ptr %22, i64 %idx.ext27
  %25 = load i16, ptr %numOfLongHorMetrics, align 2
  %conv29 = zext i16 %25 to i32
  %sub = sub nsw i32 %conv29, 1
  %mul30 = mul nsw i32 4, %sub
  %idx.ext31 = sext i32 %mul30 to i64
  %add.ptr32 = getelementptr inbounds i8, ptr %add.ptr28, i64 %idx.ext31
  %call33 = call noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %add.ptr32)
  %conv34 = sext i16 %call33 to i32
  %26 = load ptr, ptr %advanceWidth.addr, align 8
  store i32 %conv34, ptr %26, align 4
  br label %if.end35

if.end35:                                         ; preds = %if.then24, %if.else
  %27 = load ptr, ptr %leftSideBearing.addr, align 8
  %tobool36 = icmp ne ptr %27, null
  br i1 %tobool36, label %if.then37, label %if.end53

if.then37:                                        ; preds = %if.end35
  %28 = load ptr, ptr %info.addr, align 8
  %data38 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %28, i32 0, i32 1
  %29 = load ptr, ptr %data38, align 8
  %30 = load ptr, ptr %info.addr, align 8
  %hmtx39 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %30, i32 0, i32 8
  %31 = load i32, ptr %hmtx39, align 8
  %idx.ext40 = sext i32 %31 to i64
  %add.ptr41 = getelementptr inbounds i8, ptr %29, i64 %idx.ext40
  %32 = load i16, ptr %numOfLongHorMetrics, align 2
  %conv42 = zext i16 %32 to i32
  %mul43 = mul nsw i32 4, %conv42
  %idx.ext44 = sext i32 %mul43 to i64
  %add.ptr45 = getelementptr inbounds i8, ptr %add.ptr41, i64 %idx.ext44
  %33 = load i32, ptr %glyph_index.addr, align 4
  %34 = load i16, ptr %numOfLongHorMetrics, align 2
  %conv46 = zext i16 %34 to i32
  %sub47 = sub nsw i32 %33, %conv46
  %mul48 = mul nsw i32 2, %sub47
  %idx.ext49 = sext i32 %mul48 to i64
  %add.ptr50 = getelementptr inbounds i8, ptr %add.ptr45, i64 %idx.ext49
  %call51 = call noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %add.ptr50)
  %conv52 = sext i16 %call51 to i32
  %35 = load ptr, ptr %leftSideBearing.addr, align 8
  store i32 %conv52, ptr %35, align 4
  br label %if.end53

if.end53:                                         ; preds = %if.then37, %if.end35
  br label %if.end54

if.end54:                                         ; preds = %if.end53, %if.end22
  ret void
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL23stbtt_GetGlyphBitmapBoxPK14stbtt_fontinfoiffPiS2_S2_S2_(ptr noundef %font, i32 noundef %glyph, float noundef %scale_x, float noundef %scale_y, ptr noundef %ix0, ptr noundef %iy0, ptr noundef %ix1, ptr noundef %iy1) #4 {
entry:
  %font.addr = alloca ptr, align 8
  %glyph.addr = alloca i32, align 4
  %scale_x.addr = alloca float, align 4
  %scale_y.addr = alloca float, align 4
  %ix0.addr = alloca ptr, align 8
  %iy0.addr = alloca ptr, align 8
  %ix1.addr = alloca ptr, align 8
  %iy1.addr = alloca ptr, align 8
  store ptr %font, ptr %font.addr, align 8
  store i32 %glyph, ptr %glyph.addr, align 4
  store float %scale_x, ptr %scale_x.addr, align 4
  store float %scale_y, ptr %scale_y.addr, align 4
  store ptr %ix0, ptr %ix0.addr, align 8
  store ptr %iy0, ptr %iy0.addr, align 8
  store ptr %ix1, ptr %ix1.addr, align 8
  store ptr %iy1, ptr %iy1.addr, align 8
  %0 = load ptr, ptr %font.addr, align 8
  %1 = load i32, ptr %glyph.addr, align 4
  %2 = load float, ptr %scale_x.addr, align 4
  %3 = load float, ptr %scale_y.addr, align 4
  %4 = load ptr, ptr %ix0.addr, align 8
  %5 = load ptr, ptr %iy0.addr, align 8
  %6 = load ptr, ptr %ix1.addr, align 8
  %7 = load ptr, ptr %iy1.addr, align 8
  call void @_ZL31stbtt_GetGlyphBitmapBoxSubpixelPK14stbtt_fontinfoiffffPiS2_S2_S2_(ptr noundef %0, i32 noundef %1, float noundef %2, float noundef %3, float noundef 0.000000e+00, float noundef 0.000000e+00, ptr noundef %4, ptr noundef %5, ptr noundef %6, ptr noundef %7)
  ret void
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL29stbtt_MakeGlyphBitmapSubpixelPK14stbtt_fontinfoPhiiiffffi(ptr noundef %info, ptr noundef %output, i32 noundef %out_w, i32 noundef %out_h, i32 noundef %out_stride, float noundef %scale_x, float noundef %scale_y, float noundef %shift_x, float noundef %shift_y, i32 noundef %glyph) #4 {
entry:
  %info.addr = alloca ptr, align 8
  %output.addr = alloca ptr, align 8
  %out_w.addr = alloca i32, align 4
  %out_h.addr = alloca i32, align 4
  %out_stride.addr = alloca i32, align 4
  %scale_x.addr = alloca float, align 4
  %scale_y.addr = alloca float, align 4
  %shift_x.addr = alloca float, align 4
  %shift_y.addr = alloca float, align 4
  %glyph.addr = alloca i32, align 4
  %ix0 = alloca i32, align 4
  %iy0 = alloca i32, align 4
  %vertices = alloca ptr, align 8
  %num_verts = alloca i32, align 4
  %gbm = alloca %struct.stbtt__bitmap, align 8
  store ptr %info, ptr %info.addr, align 8
  store ptr %output, ptr %output.addr, align 8
  store i32 %out_w, ptr %out_w.addr, align 4
  store i32 %out_h, ptr %out_h.addr, align 4
  store i32 %out_stride, ptr %out_stride.addr, align 4
  store float %scale_x, ptr %scale_x.addr, align 4
  store float %scale_y, ptr %scale_y.addr, align 4
  store float %shift_x, ptr %shift_x.addr, align 4
  store float %shift_y, ptr %shift_y.addr, align 4
  store i32 %glyph, ptr %glyph.addr, align 4
  %0 = load ptr, ptr %info.addr, align 8
  %1 = load i32, ptr %glyph.addr, align 4
  %call = call noundef i32 @_ZL19stbtt_GetGlyphShapePK14stbtt_fontinfoiPP12stbtt_vertex(ptr noundef %0, i32 noundef %1, ptr noundef %vertices)
  store i32 %call, ptr %num_verts, align 4
  %2 = load ptr, ptr %info.addr, align 8
  %3 = load i32, ptr %glyph.addr, align 4
  %4 = load float, ptr %scale_x.addr, align 4
  %5 = load float, ptr %scale_y.addr, align 4
  %6 = load float, ptr %shift_x.addr, align 4
  %7 = load float, ptr %shift_y.addr, align 4
  call void @_ZL31stbtt_GetGlyphBitmapBoxSubpixelPK14stbtt_fontinfoiffffPiS2_S2_S2_(ptr noundef %2, i32 noundef %3, float noundef %4, float noundef %5, float noundef %6, float noundef %7, ptr noundef %ix0, ptr noundef %iy0, ptr noundef null, ptr noundef null)
  %8 = load ptr, ptr %output.addr, align 8
  %pixels = getelementptr inbounds %struct.stbtt__bitmap, ptr %gbm, i32 0, i32 3
  store ptr %8, ptr %pixels, align 8
  %9 = load i32, ptr %out_w.addr, align 4
  %w = getelementptr inbounds %struct.stbtt__bitmap, ptr %gbm, i32 0, i32 0
  store i32 %9, ptr %w, align 8
  %10 = load i32, ptr %out_h.addr, align 4
  %h = getelementptr inbounds %struct.stbtt__bitmap, ptr %gbm, i32 0, i32 1
  store i32 %10, ptr %h, align 4
  %11 = load i32, ptr %out_stride.addr, align 4
  %stride = getelementptr inbounds %struct.stbtt__bitmap, ptr %gbm, i32 0, i32 2
  store i32 %11, ptr %stride, align 8
  %w1 = getelementptr inbounds %struct.stbtt__bitmap, ptr %gbm, i32 0, i32 0
  %12 = load i32, ptr %w1, align 8
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %h2 = getelementptr inbounds %struct.stbtt__bitmap, ptr %gbm, i32 0, i32 1
  %13 = load i32, ptr %h2, align 4
  %tobool3 = icmp ne i32 %13, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %14 = load ptr, ptr %vertices, align 8
  %15 = load i32, ptr %num_verts, align 4
  %16 = load float, ptr %scale_x.addr, align 4
  %17 = load float, ptr %scale_y.addr, align 4
  %18 = load float, ptr %shift_x.addr, align 4
  %19 = load float, ptr %shift_y.addr, align 4
  %20 = load i32, ptr %ix0, align 4
  %21 = load i32, ptr %iy0, align 4
  %22 = load ptr, ptr %info.addr, align 8
  %userdata = getelementptr inbounds %struct.stbtt_fontinfo, ptr %22, i32 0, i32 0
  %23 = load ptr, ptr %userdata, align 8
  call void @_ZL15stbtt_RasterizeP13stbtt__bitmapfP12stbtt_vertexiffffiiiPv(ptr noundef %gbm, float noundef 0x3FD6666660000000, ptr noundef %14, i32 noundef %15, float noundef %16, float noundef %17, float noundef %18, float noundef %19, i32 noundef %20, i32 noundef %21, i32 noundef 1, ptr noundef %23)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %24 = load ptr, ptr %vertices, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %24)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZL18stbtt__h_prefilterPhiiij(ptr noundef %pixels, i32 noundef %w, i32 noundef %h, i32 noundef %stride_in_bytes, i32 noundef %kernel_width) #2 {
entry:
  %pixels.addr = alloca ptr, align 8
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %stride_in_bytes.addr = alloca i32, align 4
  %kernel_width.addr = alloca i32, align 4
  %buffer = alloca [8 x i8], align 1
  %safe_w = alloca i32, align 4
  %j = alloca i32, align 4
  %i = alloca i32, align 4
  %total = alloca i32, align 4
  store ptr %pixels, ptr %pixels.addr, align 8
  store i32 %w, ptr %w.addr, align 4
  store i32 %h, ptr %h.addr, align 4
  store i32 %stride_in_bytes, ptr %stride_in_bytes.addr, align 4
  store i32 %kernel_width, ptr %kernel_width.addr, align 4
  %0 = load i32, ptr %w.addr, align 4
  %1 = load i32, ptr %kernel_width.addr, align 4
  %sub = sub i32 %0, %1
  store i32 %sub, ptr %safe_w, align 4
  %arraydecay = getelementptr inbounds [8 x i8], ptr %buffer, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 1 %arraydecay, i8 0, i64 8, i1 false)
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc137, %entry
  %2 = load i32, ptr %j, align 4
  %3 = load i32, ptr %h.addr, align 4
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end139

for.body:                                         ; preds = %for.cond
  %arraydecay1 = getelementptr inbounds [8 x i8], ptr %buffer, i64 0, i64 0
  %4 = load i32, ptr %kernel_width.addr, align 4
  %conv = zext i32 %4 to i64
  call void @llvm.memset.p0.i64(ptr align 1 %arraydecay1, i8 0, i64 %conv, i1 false)
  store i32 0, ptr %total, align 4
  %5 = load i32, ptr %kernel_width.addr, align 4
  switch i32 %5, label %sw.default [
    i32 2, label %sw.bb
    i32 3, label %sw.bb19
    i32 4, label %sw.bb45
    i32 5, label %sw.bb71
  ]

sw.bb:                                            ; preds = %for.body
  store i32 0, ptr %i, align 4
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc, %sw.bb
  %6 = load i32, ptr %i, align 4
  %7 = load i32, ptr %safe_w, align 4
  %cmp3 = icmp sle i32 %6, %7
  br i1 %cmp3, label %for.body4, label %for.end

for.body4:                                        ; preds = %for.cond2
  %8 = load ptr, ptr %pixels.addr, align 8
  %9 = load i32, ptr %i, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr inbounds i8, ptr %8, i64 %idxprom
  %10 = load i8, ptr %arrayidx, align 1
  %conv5 = zext i8 %10 to i32
  %11 = load i32, ptr %i, align 4
  %and = and i32 %11, 7
  %idxprom6 = sext i32 %and to i64
  %arrayidx7 = getelementptr inbounds [8 x i8], ptr %buffer, i64 0, i64 %idxprom6
  %12 = load i8, ptr %arrayidx7, align 1
  %conv8 = zext i8 %12 to i32
  %sub9 = sub nsw i32 %conv5, %conv8
  %13 = load i32, ptr %total, align 4
  %add = add i32 %13, %sub9
  store i32 %add, ptr %total, align 4
  %14 = load ptr, ptr %pixels.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idxprom10 = sext i32 %15 to i64
  %arrayidx11 = getelementptr inbounds i8, ptr %14, i64 %idxprom10
  %16 = load i8, ptr %arrayidx11, align 1
  %17 = load i32, ptr %i, align 4
  %18 = load i32, ptr %kernel_width.addr, align 4
  %add12 = add i32 %17, %18
  %and13 = and i32 %add12, 7
  %idxprom14 = zext i32 %and13 to i64
  %arrayidx15 = getelementptr inbounds [8 x i8], ptr %buffer, i64 0, i64 %idxprom14
  store i8 %16, ptr %arrayidx15, align 1
  %19 = load i32, ptr %total, align 4
  %div = udiv i32 %19, 2
  %conv16 = trunc i32 %div to i8
  %20 = load ptr, ptr %pixels.addr, align 8
  %21 = load i32, ptr %i, align 4
  %idxprom17 = sext i32 %21 to i64
  %arrayidx18 = getelementptr inbounds i8, ptr %20, i64 %idxprom17
  store i8 %conv16, ptr %arrayidx18, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body4
  %22 = load i32, ptr %i, align 4
  %inc = add nsw i32 %22, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond2, !llvm.loop !123

for.end:                                          ; preds = %for.cond2
  br label %sw.epilog

sw.bb19:                                          ; preds = %for.body
  store i32 0, ptr %i, align 4
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc42, %sw.bb19
  %23 = load i32, ptr %i, align 4
  %24 = load i32, ptr %safe_w, align 4
  %cmp21 = icmp sle i32 %23, %24
  br i1 %cmp21, label %for.body22, label %for.end44

for.body22:                                       ; preds = %for.cond20
  %25 = load ptr, ptr %pixels.addr, align 8
  %26 = load i32, ptr %i, align 4
  %idxprom23 = sext i32 %26 to i64
  %arrayidx24 = getelementptr inbounds i8, ptr %25, i64 %idxprom23
  %27 = load i8, ptr %arrayidx24, align 1
  %conv25 = zext i8 %27 to i32
  %28 = load i32, ptr %i, align 4
  %and26 = and i32 %28, 7
  %idxprom27 = sext i32 %and26 to i64
  %arrayidx28 = getelementptr inbounds [8 x i8], ptr %buffer, i64 0, i64 %idxprom27
  %29 = load i8, ptr %arrayidx28, align 1
  %conv29 = zext i8 %29 to i32
  %sub30 = sub nsw i32 %conv25, %conv29
  %30 = load i32, ptr %total, align 4
  %add31 = add i32 %30, %sub30
  store i32 %add31, ptr %total, align 4
  %31 = load ptr, ptr %pixels.addr, align 8
  %32 = load i32, ptr %i, align 4
  %idxprom32 = sext i32 %32 to i64
  %arrayidx33 = getelementptr inbounds i8, ptr %31, i64 %idxprom32
  %33 = load i8, ptr %arrayidx33, align 1
  %34 = load i32, ptr %i, align 4
  %35 = load i32, ptr %kernel_width.addr, align 4
  %add34 = add i32 %34, %35
  %and35 = and i32 %add34, 7
  %idxprom36 = zext i32 %and35 to i64
  %arrayidx37 = getelementptr inbounds [8 x i8], ptr %buffer, i64 0, i64 %idxprom36
  store i8 %33, ptr %arrayidx37, align 1
  %36 = load i32, ptr %total, align 4
  %div38 = udiv i32 %36, 3
  %conv39 = trunc i32 %div38 to i8
  %37 = load ptr, ptr %pixels.addr, align 8
  %38 = load i32, ptr %i, align 4
  %idxprom40 = sext i32 %38 to i64
  %arrayidx41 = getelementptr inbounds i8, ptr %37, i64 %idxprom40
  store i8 %conv39, ptr %arrayidx41, align 1
  br label %for.inc42

for.inc42:                                        ; preds = %for.body22
  %39 = load i32, ptr %i, align 4
  %inc43 = add nsw i32 %39, 1
  store i32 %inc43, ptr %i, align 4
  br label %for.cond20, !llvm.loop !124

for.end44:                                        ; preds = %for.cond20
  br label %sw.epilog

sw.bb45:                                          ; preds = %for.body
  store i32 0, ptr %i, align 4
  br label %for.cond46

for.cond46:                                       ; preds = %for.inc68, %sw.bb45
  %40 = load i32, ptr %i, align 4
  %41 = load i32, ptr %safe_w, align 4
  %cmp47 = icmp sle i32 %40, %41
  br i1 %cmp47, label %for.body48, label %for.end70

for.body48:                                       ; preds = %for.cond46
  %42 = load ptr, ptr %pixels.addr, align 8
  %43 = load i32, ptr %i, align 4
  %idxprom49 = sext i32 %43 to i64
  %arrayidx50 = getelementptr inbounds i8, ptr %42, i64 %idxprom49
  %44 = load i8, ptr %arrayidx50, align 1
  %conv51 = zext i8 %44 to i32
  %45 = load i32, ptr %i, align 4
  %and52 = and i32 %45, 7
  %idxprom53 = sext i32 %and52 to i64
  %arrayidx54 = getelementptr inbounds [8 x i8], ptr %buffer, i64 0, i64 %idxprom53
  %46 = load i8, ptr %arrayidx54, align 1
  %conv55 = zext i8 %46 to i32
  %sub56 = sub nsw i32 %conv51, %conv55
  %47 = load i32, ptr %total, align 4
  %add57 = add i32 %47, %sub56
  store i32 %add57, ptr %total, align 4
  %48 = load ptr, ptr %pixels.addr, align 8
  %49 = load i32, ptr %i, align 4
  %idxprom58 = sext i32 %49 to i64
  %arrayidx59 = getelementptr inbounds i8, ptr %48, i64 %idxprom58
  %50 = load i8, ptr %arrayidx59, align 1
  %51 = load i32, ptr %i, align 4
  %52 = load i32, ptr %kernel_width.addr, align 4
  %add60 = add i32 %51, %52
  %and61 = and i32 %add60, 7
  %idxprom62 = zext i32 %and61 to i64
  %arrayidx63 = getelementptr inbounds [8 x i8], ptr %buffer, i64 0, i64 %idxprom62
  store i8 %50, ptr %arrayidx63, align 1
  %53 = load i32, ptr %total, align 4
  %div64 = udiv i32 %53, 4
  %conv65 = trunc i32 %div64 to i8
  %54 = load ptr, ptr %pixels.addr, align 8
  %55 = load i32, ptr %i, align 4
  %idxprom66 = sext i32 %55 to i64
  %arrayidx67 = getelementptr inbounds i8, ptr %54, i64 %idxprom66
  store i8 %conv65, ptr %arrayidx67, align 1
  br label %for.inc68

for.inc68:                                        ; preds = %for.body48
  %56 = load i32, ptr %i, align 4
  %inc69 = add nsw i32 %56, 1
  store i32 %inc69, ptr %i, align 4
  br label %for.cond46, !llvm.loop !125

for.end70:                                        ; preds = %for.cond46
  br label %sw.epilog

sw.bb71:                                          ; preds = %for.body
  store i32 0, ptr %i, align 4
  br label %for.cond72

for.cond72:                                       ; preds = %for.inc94, %sw.bb71
  %57 = load i32, ptr %i, align 4
  %58 = load i32, ptr %safe_w, align 4
  %cmp73 = icmp sle i32 %57, %58
  br i1 %cmp73, label %for.body74, label %for.end96

for.body74:                                       ; preds = %for.cond72
  %59 = load ptr, ptr %pixels.addr, align 8
  %60 = load i32, ptr %i, align 4
  %idxprom75 = sext i32 %60 to i64
  %arrayidx76 = getelementptr inbounds i8, ptr %59, i64 %idxprom75
  %61 = load i8, ptr %arrayidx76, align 1
  %conv77 = zext i8 %61 to i32
  %62 = load i32, ptr %i, align 4
  %and78 = and i32 %62, 7
  %idxprom79 = sext i32 %and78 to i64
  %arrayidx80 = getelementptr inbounds [8 x i8], ptr %buffer, i64 0, i64 %idxprom79
  %63 = load i8, ptr %arrayidx80, align 1
  %conv81 = zext i8 %63 to i32
  %sub82 = sub nsw i32 %conv77, %conv81
  %64 = load i32, ptr %total, align 4
  %add83 = add i32 %64, %sub82
  store i32 %add83, ptr %total, align 4
  %65 = load ptr, ptr %pixels.addr, align 8
  %66 = load i32, ptr %i, align 4
  %idxprom84 = sext i32 %66 to i64
  %arrayidx85 = getelementptr inbounds i8, ptr %65, i64 %idxprom84
  %67 = load i8, ptr %arrayidx85, align 1
  %68 = load i32, ptr %i, align 4
  %69 = load i32, ptr %kernel_width.addr, align 4
  %add86 = add i32 %68, %69
  %and87 = and i32 %add86, 7
  %idxprom88 = zext i32 %and87 to i64
  %arrayidx89 = getelementptr inbounds [8 x i8], ptr %buffer, i64 0, i64 %idxprom88
  store i8 %67, ptr %arrayidx89, align 1
  %70 = load i32, ptr %total, align 4
  %div90 = udiv i32 %70, 5
  %conv91 = trunc i32 %div90 to i8
  %71 = load ptr, ptr %pixels.addr, align 8
  %72 = load i32, ptr %i, align 4
  %idxprom92 = sext i32 %72 to i64
  %arrayidx93 = getelementptr inbounds i8, ptr %71, i64 %idxprom92
  store i8 %conv91, ptr %arrayidx93, align 1
  br label %for.inc94

for.inc94:                                        ; preds = %for.body74
  %73 = load i32, ptr %i, align 4
  %inc95 = add nsw i32 %73, 1
  store i32 %inc95, ptr %i, align 4
  br label %for.cond72, !llvm.loop !126

for.end96:                                        ; preds = %for.cond72
  br label %sw.epilog

sw.default:                                       ; preds = %for.body
  store i32 0, ptr %i, align 4
  br label %for.cond97

for.cond97:                                       ; preds = %for.inc119, %sw.default
  %74 = load i32, ptr %i, align 4
  %75 = load i32, ptr %safe_w, align 4
  %cmp98 = icmp sle i32 %74, %75
  br i1 %cmp98, label %for.body99, label %for.end121

for.body99:                                       ; preds = %for.cond97
  %76 = load ptr, ptr %pixels.addr, align 8
  %77 = load i32, ptr %i, align 4
  %idxprom100 = sext i32 %77 to i64
  %arrayidx101 = getelementptr inbounds i8, ptr %76, i64 %idxprom100
  %78 = load i8, ptr %arrayidx101, align 1
  %conv102 = zext i8 %78 to i32
  %79 = load i32, ptr %i, align 4
  %and103 = and i32 %79, 7
  %idxprom104 = sext i32 %and103 to i64
  %arrayidx105 = getelementptr inbounds [8 x i8], ptr %buffer, i64 0, i64 %idxprom104
  %80 = load i8, ptr %arrayidx105, align 1
  %conv106 = zext i8 %80 to i32
  %sub107 = sub nsw i32 %conv102, %conv106
  %81 = load i32, ptr %total, align 4
  %add108 = add i32 %81, %sub107
  store i32 %add108, ptr %total, align 4
  %82 = load ptr, ptr %pixels.addr, align 8
  %83 = load i32, ptr %i, align 4
  %idxprom109 = sext i32 %83 to i64
  %arrayidx110 = getelementptr inbounds i8, ptr %82, i64 %idxprom109
  %84 = load i8, ptr %arrayidx110, align 1
  %85 = load i32, ptr %i, align 4
  %86 = load i32, ptr %kernel_width.addr, align 4
  %add111 = add i32 %85, %86
  %and112 = and i32 %add111, 7
  %idxprom113 = zext i32 %and112 to i64
  %arrayidx114 = getelementptr inbounds [8 x i8], ptr %buffer, i64 0, i64 %idxprom113
  store i8 %84, ptr %arrayidx114, align 1
  %87 = load i32, ptr %total, align 4
  %88 = load i32, ptr %kernel_width.addr, align 4
  %div115 = udiv i32 %87, %88
  %conv116 = trunc i32 %div115 to i8
  %89 = load ptr, ptr %pixels.addr, align 8
  %90 = load i32, ptr %i, align 4
  %idxprom117 = sext i32 %90 to i64
  %arrayidx118 = getelementptr inbounds i8, ptr %89, i64 %idxprom117
  store i8 %conv116, ptr %arrayidx118, align 1
  br label %for.inc119

for.inc119:                                       ; preds = %for.body99
  %91 = load i32, ptr %i, align 4
  %inc120 = add nsw i32 %91, 1
  store i32 %inc120, ptr %i, align 4
  br label %for.cond97, !llvm.loop !127

for.end121:                                       ; preds = %for.cond97
  br label %sw.epilog

sw.epilog:                                        ; preds = %for.end121, %for.end96, %for.end70, %for.end44, %for.end
  br label %for.cond122

for.cond122:                                      ; preds = %for.inc134, %sw.epilog
  %92 = load i32, ptr %i, align 4
  %93 = load i32, ptr %w.addr, align 4
  %cmp123 = icmp slt i32 %92, %93
  br i1 %cmp123, label %for.body124, label %for.end136

for.body124:                                      ; preds = %for.cond122
  br label %do.body

do.body:                                          ; preds = %for.body124
  br label %do.end

do.end:                                           ; preds = %do.body
  %94 = load i32, ptr %i, align 4
  %and125 = and i32 %94, 7
  %idxprom126 = sext i32 %and125 to i64
  %arrayidx127 = getelementptr inbounds [8 x i8], ptr %buffer, i64 0, i64 %idxprom126
  %95 = load i8, ptr %arrayidx127, align 1
  %conv128 = zext i8 %95 to i32
  %96 = load i32, ptr %total, align 4
  %sub129 = sub i32 %96, %conv128
  store i32 %sub129, ptr %total, align 4
  %97 = load i32, ptr %total, align 4
  %98 = load i32, ptr %kernel_width.addr, align 4
  %div130 = udiv i32 %97, %98
  %conv131 = trunc i32 %div130 to i8
  %99 = load ptr, ptr %pixels.addr, align 8
  %100 = load i32, ptr %i, align 4
  %idxprom132 = sext i32 %100 to i64
  %arrayidx133 = getelementptr inbounds i8, ptr %99, i64 %idxprom132
  store i8 %conv131, ptr %arrayidx133, align 1
  br label %for.inc134

for.inc134:                                       ; preds = %do.end
  %101 = load i32, ptr %i, align 4
  %inc135 = add nsw i32 %101, 1
  store i32 %inc135, ptr %i, align 4
  br label %for.cond122, !llvm.loop !128

for.end136:                                       ; preds = %for.cond122
  %102 = load i32, ptr %stride_in_bytes.addr, align 4
  %103 = load ptr, ptr %pixels.addr, align 8
  %idx.ext = sext i32 %102 to i64
  %add.ptr = getelementptr inbounds i8, ptr %103, i64 %idx.ext
  store ptr %add.ptr, ptr %pixels.addr, align 8
  br label %for.inc137

for.inc137:                                       ; preds = %for.end136
  %104 = load i32, ptr %j, align 4
  %inc138 = add nsw i32 %104, 1
  store i32 %inc138, ptr %j, align 4
  br label %for.cond, !llvm.loop !129

for.end139:                                       ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZL18stbtt__v_prefilterPhiiij(ptr noundef %pixels, i32 noundef %w, i32 noundef %h, i32 noundef %stride_in_bytes, i32 noundef %kernel_width) #2 {
entry:
  %pixels.addr = alloca ptr, align 8
  %w.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %stride_in_bytes.addr = alloca i32, align 4
  %kernel_width.addr = alloca i32, align 4
  %buffer = alloca [8 x i8], align 1
  %safe_h = alloca i32, align 4
  %j = alloca i32, align 4
  %i = alloca i32, align 4
  %total = alloca i32, align 4
  store ptr %pixels, ptr %pixels.addr, align 8
  store i32 %w, ptr %w.addr, align 4
  store i32 %h, ptr %h.addr, align 4
  store i32 %stride_in_bytes, ptr %stride_in_bytes.addr, align 4
  store i32 %kernel_width, ptr %kernel_width.addr, align 4
  %0 = load i32, ptr %h.addr, align 4
  %1 = load i32, ptr %kernel_width.addr, align 4
  %sub = sub i32 %0, %1
  store i32 %sub, ptr %safe_h, align 4
  %arraydecay = getelementptr inbounds [8 x i8], ptr %buffer, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 1 %arraydecay, i8 0, i64 8, i1 false)
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc152, %entry
  %2 = load i32, ptr %j, align 4
  %3 = load i32, ptr %w.addr, align 4
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end154

for.body:                                         ; preds = %for.cond
  %arraydecay1 = getelementptr inbounds [8 x i8], ptr %buffer, i64 0, i64 0
  %4 = load i32, ptr %kernel_width.addr, align 4
  %conv = zext i32 %4 to i64
  call void @llvm.memset.p0.i64(ptr align 1 %arraydecay1, i8 0, i64 %conv, i1 false)
  store i32 0, ptr %total, align 4
  %5 = load i32, ptr %kernel_width.addr, align 4
  switch i32 %5, label %sw.default [
    i32 2, label %sw.bb
    i32 3, label %sw.bb21
    i32 4, label %sw.bb50
    i32 5, label %sw.bb79
  ]

sw.bb:                                            ; preds = %for.body
  store i32 0, ptr %i, align 4
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc, %sw.bb
  %6 = load i32, ptr %i, align 4
  %7 = load i32, ptr %safe_h, align 4
  %cmp3 = icmp sle i32 %6, %7
  br i1 %cmp3, label %for.body4, label %for.end

for.body4:                                        ; preds = %for.cond2
  %8 = load ptr, ptr %pixels.addr, align 8
  %9 = load i32, ptr %i, align 4
  %10 = load i32, ptr %stride_in_bytes.addr, align 4
  %mul = mul nsw i32 %9, %10
  %idxprom = sext i32 %mul to i64
  %arrayidx = getelementptr inbounds i8, ptr %8, i64 %idxprom
  %11 = load i8, ptr %arrayidx, align 1
  %conv5 = zext i8 %11 to i32
  %12 = load i32, ptr %i, align 4
  %and = and i32 %12, 7
  %idxprom6 = sext i32 %and to i64
  %arrayidx7 = getelementptr inbounds [8 x i8], ptr %buffer, i64 0, i64 %idxprom6
  %13 = load i8, ptr %arrayidx7, align 1
  %conv8 = zext i8 %13 to i32
  %sub9 = sub nsw i32 %conv5, %conv8
  %14 = load i32, ptr %total, align 4
  %add = add i32 %14, %sub9
  store i32 %add, ptr %total, align 4
  %15 = load ptr, ptr %pixels.addr, align 8
  %16 = load i32, ptr %i, align 4
  %17 = load i32, ptr %stride_in_bytes.addr, align 4
  %mul10 = mul nsw i32 %16, %17
  %idxprom11 = sext i32 %mul10 to i64
  %arrayidx12 = getelementptr inbounds i8, ptr %15, i64 %idxprom11
  %18 = load i8, ptr %arrayidx12, align 1
  %19 = load i32, ptr %i, align 4
  %20 = load i32, ptr %kernel_width.addr, align 4
  %add13 = add i32 %19, %20
  %and14 = and i32 %add13, 7
  %idxprom15 = zext i32 %and14 to i64
  %arrayidx16 = getelementptr inbounds [8 x i8], ptr %buffer, i64 0, i64 %idxprom15
  store i8 %18, ptr %arrayidx16, align 1
  %21 = load i32, ptr %total, align 4
  %div = udiv i32 %21, 2
  %conv17 = trunc i32 %div to i8
  %22 = load ptr, ptr %pixels.addr, align 8
  %23 = load i32, ptr %i, align 4
  %24 = load i32, ptr %stride_in_bytes.addr, align 4
  %mul18 = mul nsw i32 %23, %24
  %idxprom19 = sext i32 %mul18 to i64
  %arrayidx20 = getelementptr inbounds i8, ptr %22, i64 %idxprom19
  store i8 %conv17, ptr %arrayidx20, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body4
  %25 = load i32, ptr %i, align 4
  %inc = add nsw i32 %25, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond2, !llvm.loop !130

for.end:                                          ; preds = %for.cond2
  br label %sw.epilog

sw.bb21:                                          ; preds = %for.body
  store i32 0, ptr %i, align 4
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc47, %sw.bb21
  %26 = load i32, ptr %i, align 4
  %27 = load i32, ptr %safe_h, align 4
  %cmp23 = icmp sle i32 %26, %27
  br i1 %cmp23, label %for.body24, label %for.end49

for.body24:                                       ; preds = %for.cond22
  %28 = load ptr, ptr %pixels.addr, align 8
  %29 = load i32, ptr %i, align 4
  %30 = load i32, ptr %stride_in_bytes.addr, align 4
  %mul25 = mul nsw i32 %29, %30
  %idxprom26 = sext i32 %mul25 to i64
  %arrayidx27 = getelementptr inbounds i8, ptr %28, i64 %idxprom26
  %31 = load i8, ptr %arrayidx27, align 1
  %conv28 = zext i8 %31 to i32
  %32 = load i32, ptr %i, align 4
  %and29 = and i32 %32, 7
  %idxprom30 = sext i32 %and29 to i64
  %arrayidx31 = getelementptr inbounds [8 x i8], ptr %buffer, i64 0, i64 %idxprom30
  %33 = load i8, ptr %arrayidx31, align 1
  %conv32 = zext i8 %33 to i32
  %sub33 = sub nsw i32 %conv28, %conv32
  %34 = load i32, ptr %total, align 4
  %add34 = add i32 %34, %sub33
  store i32 %add34, ptr %total, align 4
  %35 = load ptr, ptr %pixels.addr, align 8
  %36 = load i32, ptr %i, align 4
  %37 = load i32, ptr %stride_in_bytes.addr, align 4
  %mul35 = mul nsw i32 %36, %37
  %idxprom36 = sext i32 %mul35 to i64
  %arrayidx37 = getelementptr inbounds i8, ptr %35, i64 %idxprom36
  %38 = load i8, ptr %arrayidx37, align 1
  %39 = load i32, ptr %i, align 4
  %40 = load i32, ptr %kernel_width.addr, align 4
  %add38 = add i32 %39, %40
  %and39 = and i32 %add38, 7
  %idxprom40 = zext i32 %and39 to i64
  %arrayidx41 = getelementptr inbounds [8 x i8], ptr %buffer, i64 0, i64 %idxprom40
  store i8 %38, ptr %arrayidx41, align 1
  %41 = load i32, ptr %total, align 4
  %div42 = udiv i32 %41, 3
  %conv43 = trunc i32 %div42 to i8
  %42 = load ptr, ptr %pixels.addr, align 8
  %43 = load i32, ptr %i, align 4
  %44 = load i32, ptr %stride_in_bytes.addr, align 4
  %mul44 = mul nsw i32 %43, %44
  %idxprom45 = sext i32 %mul44 to i64
  %arrayidx46 = getelementptr inbounds i8, ptr %42, i64 %idxprom45
  store i8 %conv43, ptr %arrayidx46, align 1
  br label %for.inc47

for.inc47:                                        ; preds = %for.body24
  %45 = load i32, ptr %i, align 4
  %inc48 = add nsw i32 %45, 1
  store i32 %inc48, ptr %i, align 4
  br label %for.cond22, !llvm.loop !131

for.end49:                                        ; preds = %for.cond22
  br label %sw.epilog

sw.bb50:                                          ; preds = %for.body
  store i32 0, ptr %i, align 4
  br label %for.cond51

for.cond51:                                       ; preds = %for.inc76, %sw.bb50
  %46 = load i32, ptr %i, align 4
  %47 = load i32, ptr %safe_h, align 4
  %cmp52 = icmp sle i32 %46, %47
  br i1 %cmp52, label %for.body53, label %for.end78

for.body53:                                       ; preds = %for.cond51
  %48 = load ptr, ptr %pixels.addr, align 8
  %49 = load i32, ptr %i, align 4
  %50 = load i32, ptr %stride_in_bytes.addr, align 4
  %mul54 = mul nsw i32 %49, %50
  %idxprom55 = sext i32 %mul54 to i64
  %arrayidx56 = getelementptr inbounds i8, ptr %48, i64 %idxprom55
  %51 = load i8, ptr %arrayidx56, align 1
  %conv57 = zext i8 %51 to i32
  %52 = load i32, ptr %i, align 4
  %and58 = and i32 %52, 7
  %idxprom59 = sext i32 %and58 to i64
  %arrayidx60 = getelementptr inbounds [8 x i8], ptr %buffer, i64 0, i64 %idxprom59
  %53 = load i8, ptr %arrayidx60, align 1
  %conv61 = zext i8 %53 to i32
  %sub62 = sub nsw i32 %conv57, %conv61
  %54 = load i32, ptr %total, align 4
  %add63 = add i32 %54, %sub62
  store i32 %add63, ptr %total, align 4
  %55 = load ptr, ptr %pixels.addr, align 8
  %56 = load i32, ptr %i, align 4
  %57 = load i32, ptr %stride_in_bytes.addr, align 4
  %mul64 = mul nsw i32 %56, %57
  %idxprom65 = sext i32 %mul64 to i64
  %arrayidx66 = getelementptr inbounds i8, ptr %55, i64 %idxprom65
  %58 = load i8, ptr %arrayidx66, align 1
  %59 = load i32, ptr %i, align 4
  %60 = load i32, ptr %kernel_width.addr, align 4
  %add67 = add i32 %59, %60
  %and68 = and i32 %add67, 7
  %idxprom69 = zext i32 %and68 to i64
  %arrayidx70 = getelementptr inbounds [8 x i8], ptr %buffer, i64 0, i64 %idxprom69
  store i8 %58, ptr %arrayidx70, align 1
  %61 = load i32, ptr %total, align 4
  %div71 = udiv i32 %61, 4
  %conv72 = trunc i32 %div71 to i8
  %62 = load ptr, ptr %pixels.addr, align 8
  %63 = load i32, ptr %i, align 4
  %64 = load i32, ptr %stride_in_bytes.addr, align 4
  %mul73 = mul nsw i32 %63, %64
  %idxprom74 = sext i32 %mul73 to i64
  %arrayidx75 = getelementptr inbounds i8, ptr %62, i64 %idxprom74
  store i8 %conv72, ptr %arrayidx75, align 1
  br label %for.inc76

for.inc76:                                        ; preds = %for.body53
  %65 = load i32, ptr %i, align 4
  %inc77 = add nsw i32 %65, 1
  store i32 %inc77, ptr %i, align 4
  br label %for.cond51, !llvm.loop !132

for.end78:                                        ; preds = %for.cond51
  br label %sw.epilog

sw.bb79:                                          ; preds = %for.body
  store i32 0, ptr %i, align 4
  br label %for.cond80

for.cond80:                                       ; preds = %for.inc105, %sw.bb79
  %66 = load i32, ptr %i, align 4
  %67 = load i32, ptr %safe_h, align 4
  %cmp81 = icmp sle i32 %66, %67
  br i1 %cmp81, label %for.body82, label %for.end107

for.body82:                                       ; preds = %for.cond80
  %68 = load ptr, ptr %pixels.addr, align 8
  %69 = load i32, ptr %i, align 4
  %70 = load i32, ptr %stride_in_bytes.addr, align 4
  %mul83 = mul nsw i32 %69, %70
  %idxprom84 = sext i32 %mul83 to i64
  %arrayidx85 = getelementptr inbounds i8, ptr %68, i64 %idxprom84
  %71 = load i8, ptr %arrayidx85, align 1
  %conv86 = zext i8 %71 to i32
  %72 = load i32, ptr %i, align 4
  %and87 = and i32 %72, 7
  %idxprom88 = sext i32 %and87 to i64
  %arrayidx89 = getelementptr inbounds [8 x i8], ptr %buffer, i64 0, i64 %idxprom88
  %73 = load i8, ptr %arrayidx89, align 1
  %conv90 = zext i8 %73 to i32
  %sub91 = sub nsw i32 %conv86, %conv90
  %74 = load i32, ptr %total, align 4
  %add92 = add i32 %74, %sub91
  store i32 %add92, ptr %total, align 4
  %75 = load ptr, ptr %pixels.addr, align 8
  %76 = load i32, ptr %i, align 4
  %77 = load i32, ptr %stride_in_bytes.addr, align 4
  %mul93 = mul nsw i32 %76, %77
  %idxprom94 = sext i32 %mul93 to i64
  %arrayidx95 = getelementptr inbounds i8, ptr %75, i64 %idxprom94
  %78 = load i8, ptr %arrayidx95, align 1
  %79 = load i32, ptr %i, align 4
  %80 = load i32, ptr %kernel_width.addr, align 4
  %add96 = add i32 %79, %80
  %and97 = and i32 %add96, 7
  %idxprom98 = zext i32 %and97 to i64
  %arrayidx99 = getelementptr inbounds [8 x i8], ptr %buffer, i64 0, i64 %idxprom98
  store i8 %78, ptr %arrayidx99, align 1
  %81 = load i32, ptr %total, align 4
  %div100 = udiv i32 %81, 5
  %conv101 = trunc i32 %div100 to i8
  %82 = load ptr, ptr %pixels.addr, align 8
  %83 = load i32, ptr %i, align 4
  %84 = load i32, ptr %stride_in_bytes.addr, align 4
  %mul102 = mul nsw i32 %83, %84
  %idxprom103 = sext i32 %mul102 to i64
  %arrayidx104 = getelementptr inbounds i8, ptr %82, i64 %idxprom103
  store i8 %conv101, ptr %arrayidx104, align 1
  br label %for.inc105

for.inc105:                                       ; preds = %for.body82
  %85 = load i32, ptr %i, align 4
  %inc106 = add nsw i32 %85, 1
  store i32 %inc106, ptr %i, align 4
  br label %for.cond80, !llvm.loop !133

for.end107:                                       ; preds = %for.cond80
  br label %sw.epilog

sw.default:                                       ; preds = %for.body
  store i32 0, ptr %i, align 4
  br label %for.cond108

for.cond108:                                      ; preds = %for.inc133, %sw.default
  %86 = load i32, ptr %i, align 4
  %87 = load i32, ptr %safe_h, align 4
  %cmp109 = icmp sle i32 %86, %87
  br i1 %cmp109, label %for.body110, label %for.end135

for.body110:                                      ; preds = %for.cond108
  %88 = load ptr, ptr %pixels.addr, align 8
  %89 = load i32, ptr %i, align 4
  %90 = load i32, ptr %stride_in_bytes.addr, align 4
  %mul111 = mul nsw i32 %89, %90
  %idxprom112 = sext i32 %mul111 to i64
  %arrayidx113 = getelementptr inbounds i8, ptr %88, i64 %idxprom112
  %91 = load i8, ptr %arrayidx113, align 1
  %conv114 = zext i8 %91 to i32
  %92 = load i32, ptr %i, align 4
  %and115 = and i32 %92, 7
  %idxprom116 = sext i32 %and115 to i64
  %arrayidx117 = getelementptr inbounds [8 x i8], ptr %buffer, i64 0, i64 %idxprom116
  %93 = load i8, ptr %arrayidx117, align 1
  %conv118 = zext i8 %93 to i32
  %sub119 = sub nsw i32 %conv114, %conv118
  %94 = load i32, ptr %total, align 4
  %add120 = add i32 %94, %sub119
  store i32 %add120, ptr %total, align 4
  %95 = load ptr, ptr %pixels.addr, align 8
  %96 = load i32, ptr %i, align 4
  %97 = load i32, ptr %stride_in_bytes.addr, align 4
  %mul121 = mul nsw i32 %96, %97
  %idxprom122 = sext i32 %mul121 to i64
  %arrayidx123 = getelementptr inbounds i8, ptr %95, i64 %idxprom122
  %98 = load i8, ptr %arrayidx123, align 1
  %99 = load i32, ptr %i, align 4
  %100 = load i32, ptr %kernel_width.addr, align 4
  %add124 = add i32 %99, %100
  %and125 = and i32 %add124, 7
  %idxprom126 = zext i32 %and125 to i64
  %arrayidx127 = getelementptr inbounds [8 x i8], ptr %buffer, i64 0, i64 %idxprom126
  store i8 %98, ptr %arrayidx127, align 1
  %101 = load i32, ptr %total, align 4
  %102 = load i32, ptr %kernel_width.addr, align 4
  %div128 = udiv i32 %101, %102
  %conv129 = trunc i32 %div128 to i8
  %103 = load ptr, ptr %pixels.addr, align 8
  %104 = load i32, ptr %i, align 4
  %105 = load i32, ptr %stride_in_bytes.addr, align 4
  %mul130 = mul nsw i32 %104, %105
  %idxprom131 = sext i32 %mul130 to i64
  %arrayidx132 = getelementptr inbounds i8, ptr %103, i64 %idxprom131
  store i8 %conv129, ptr %arrayidx132, align 1
  br label %for.inc133

for.inc133:                                       ; preds = %for.body110
  %106 = load i32, ptr %i, align 4
  %inc134 = add nsw i32 %106, 1
  store i32 %inc134, ptr %i, align 4
  br label %for.cond108, !llvm.loop !134

for.end135:                                       ; preds = %for.cond108
  br label %sw.epilog

sw.epilog:                                        ; preds = %for.end135, %for.end107, %for.end78, %for.end49, %for.end
  br label %for.cond136

for.cond136:                                      ; preds = %for.inc149, %sw.epilog
  %107 = load i32, ptr %i, align 4
  %108 = load i32, ptr %h.addr, align 4
  %cmp137 = icmp slt i32 %107, %108
  br i1 %cmp137, label %for.body138, label %for.end151

for.body138:                                      ; preds = %for.cond136
  br label %do.body

do.body:                                          ; preds = %for.body138
  br label %do.end

do.end:                                           ; preds = %do.body
  %109 = load i32, ptr %i, align 4
  %and139 = and i32 %109, 7
  %idxprom140 = sext i32 %and139 to i64
  %arrayidx141 = getelementptr inbounds [8 x i8], ptr %buffer, i64 0, i64 %idxprom140
  %110 = load i8, ptr %arrayidx141, align 1
  %conv142 = zext i8 %110 to i32
  %111 = load i32, ptr %total, align 4
  %sub143 = sub i32 %111, %conv142
  store i32 %sub143, ptr %total, align 4
  %112 = load i32, ptr %total, align 4
  %113 = load i32, ptr %kernel_width.addr, align 4
  %div144 = udiv i32 %112, %113
  %conv145 = trunc i32 %div144 to i8
  %114 = load ptr, ptr %pixels.addr, align 8
  %115 = load i32, ptr %i, align 4
  %116 = load i32, ptr %stride_in_bytes.addr, align 4
  %mul146 = mul nsw i32 %115, %116
  %idxprom147 = sext i32 %mul146 to i64
  %arrayidx148 = getelementptr inbounds i8, ptr %114, i64 %idxprom147
  store i8 %conv145, ptr %arrayidx148, align 1
  br label %for.inc149

for.inc149:                                       ; preds = %do.end
  %117 = load i32, ptr %i, align 4
  %inc150 = add nsw i32 %117, 1
  store i32 %inc150, ptr %i, align 4
  br label %for.cond136, !llvm.loop !135

for.end151:                                       ; preds = %for.cond136
  %118 = load ptr, ptr %pixels.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %118, i64 1
  store ptr %add.ptr, ptr %pixels.addr, align 8
  br label %for.inc152

for.inc152:                                       ; preds = %for.end151
  %119 = load i32, ptr %j, align 4
  %inc153 = add nsw i32 %119, 1
  store i32 %inc153, ptr %j, align 4
  br label %for.cond, !llvm.loop !136

for.end154:                                       ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define internal noundef i32 @_ZL19stbtt_GetGlyphShapePK14stbtt_fontinfoiPP12stbtt_vertex(ptr noundef %info, i32 noundef %glyph_index, ptr noundef %pvertices) #4 {
entry:
  %retval = alloca i32, align 4
  %info.addr = alloca ptr, align 8
  %glyph_index.addr = alloca i32, align 4
  %pvertices.addr = alloca ptr, align 8
  store ptr %info, ptr %info.addr, align 8
  store i32 %glyph_index, ptr %glyph_index.addr, align 4
  store ptr %pvertices, ptr %pvertices.addr, align 8
  %0 = load ptr, ptr %info.addr, align 8
  %cff = getelementptr inbounds %struct.stbtt_fontinfo, ptr %0, i32 0, i32 14
  %size = getelementptr inbounds %struct.stbtt__buf, ptr %cff, i32 0, i32 2
  %1 = load i32, ptr %size, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %info.addr, align 8
  %3 = load i32, ptr %glyph_index.addr, align 4
  %4 = load ptr, ptr %pvertices.addr, align 8
  %call = call noundef i32 @_ZL22stbtt__GetGlyphShapeTTPK14stbtt_fontinfoiPP12stbtt_vertex(ptr noundef %2, i32 noundef %3, ptr noundef %4)
  store i32 %call, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %5 = load ptr, ptr %info.addr, align 8
  %6 = load i32, ptr %glyph_index.addr, align 4
  %7 = load ptr, ptr %pvertices.addr, align 8
  %call1 = call noundef i32 @_ZL22stbtt__GetGlyphShapeT2PK14stbtt_fontinfoiPP12stbtt_vertex(ptr noundef %5, i32 noundef %6, ptr noundef %7)
  store i32 %call1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL15stbtt_RasterizeP13stbtt__bitmapfP12stbtt_vertexiffffiiiPv(ptr noundef %result, float noundef %flatness_in_pixels, ptr noundef %vertices, i32 noundef %num_verts, float noundef %scale_x, float noundef %scale_y, float noundef %shift_x, float noundef %shift_y, i32 noundef %x_off, i32 noundef %y_off, i32 noundef %invert, ptr noundef %userdata) #4 {
entry:
  %result.addr = alloca ptr, align 8
  %flatness_in_pixels.addr = alloca float, align 4
  %vertices.addr = alloca ptr, align 8
  %num_verts.addr = alloca i32, align 4
  %scale_x.addr = alloca float, align 4
  %scale_y.addr = alloca float, align 4
  %shift_x.addr = alloca float, align 4
  %shift_y.addr = alloca float, align 4
  %x_off.addr = alloca i32, align 4
  %y_off.addr = alloca i32, align 4
  %invert.addr = alloca i32, align 4
  %userdata.addr = alloca ptr, align 8
  %scale = alloca float, align 4
  %winding_count = alloca i32, align 4
  %winding_lengths = alloca ptr, align 8
  %windings = alloca ptr, align 8
  store ptr %result, ptr %result.addr, align 8
  store float %flatness_in_pixels, ptr %flatness_in_pixels.addr, align 4
  store ptr %vertices, ptr %vertices.addr, align 8
  store i32 %num_verts, ptr %num_verts.addr, align 4
  store float %scale_x, ptr %scale_x.addr, align 4
  store float %scale_y, ptr %scale_y.addr, align 4
  store float %shift_x, ptr %shift_x.addr, align 4
  store float %shift_y, ptr %shift_y.addr, align 4
  store i32 %x_off, ptr %x_off.addr, align 4
  store i32 %y_off, ptr %y_off.addr, align 4
  store i32 %invert, ptr %invert.addr, align 4
  store ptr %userdata, ptr %userdata.addr, align 8
  %0 = load float, ptr %scale_x.addr, align 4
  %1 = load float, ptr %scale_y.addr, align 4
  %cmp = fcmp ogt float %0, %1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load float, ptr %scale_y.addr, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load float, ptr %scale_x.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %2, %cond.true ], [ %3, %cond.false ]
  store float %cond, ptr %scale, align 4
  store i32 0, ptr %winding_count, align 4
  store ptr null, ptr %winding_lengths, align 8
  %4 = load ptr, ptr %vertices.addr, align 8
  %5 = load i32, ptr %num_verts.addr, align 4
  %6 = load float, ptr %flatness_in_pixels.addr, align 4
  %7 = load float, ptr %scale, align 4
  %div = fdiv float %6, %7
  %8 = load ptr, ptr %userdata.addr, align 8
  %call = call noundef ptr @_ZL19stbtt_FlattenCurvesP12stbtt_vertexifPPiS1_Pv(ptr noundef %4, i32 noundef %5, float noundef %div, ptr noundef %winding_lengths, ptr noundef %winding_count, ptr noundef %8)
  store ptr %call, ptr %windings, align 8
  %9 = load ptr, ptr %windings, align 8
  %tobool = icmp ne ptr %9, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %10 = load ptr, ptr %result.addr, align 8
  %11 = load ptr, ptr %windings, align 8
  %12 = load ptr, ptr %winding_lengths, align 8
  %13 = load i32, ptr %winding_count, align 4
  %14 = load float, ptr %scale_x.addr, align 4
  %15 = load float, ptr %scale_y.addr, align 4
  %16 = load float, ptr %shift_x.addr, align 4
  %17 = load float, ptr %shift_y.addr, align 4
  %18 = load i32, ptr %x_off.addr, align 4
  %19 = load i32, ptr %y_off.addr, align 4
  %20 = load i32, ptr %invert.addr, align 4
  %21 = load ptr, ptr %userdata.addr, align 8
  call void @_ZL16stbtt__rasterizeP13stbtt__bitmapP12stbtt__pointPiiffffiiiPv(ptr noundef %10, ptr noundef %11, ptr noundef %12, i32 noundef %13, float noundef %14, float noundef %15, float noundef %16, float noundef %17, i32 noundef %18, i32 noundef %19, i32 noundef %20, ptr noundef %21)
  %22 = load ptr, ptr %winding_lengths, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %22)
  %23 = load ptr, ptr %windings, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %23)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  ret void
}

; Function Attrs: mustprogress uwtable
define internal noundef i32 @_ZL22stbtt__GetGlyphShapeTTPK14stbtt_fontinfoiPP12stbtt_vertex(ptr noundef %info, i32 noundef %glyph_index, ptr noundef %pvertices) #4 {
entry:
  %retval = alloca i32, align 4
  %info.addr = alloca ptr, align 8
  %glyph_index.addr = alloca i32, align 4
  %pvertices.addr = alloca ptr, align 8
  %numberOfContours = alloca i16, align 2
  %endPtsOfContours = alloca ptr, align 8
  %data = alloca ptr, align 8
  %vertices = alloca ptr, align 8
  %num_vertices = alloca i32, align 4
  %g = alloca i32, align 4
  %flags = alloca i8, align 1
  %flagcount = alloca i8, align 1
  %ins = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %m = alloca i32, align 4
  %n = alloca i32, align 4
  %next_move = alloca i32, align 4
  %was_off = alloca i32, align 4
  %off = alloca i32, align 4
  %start_off = alloca i32, align 4
  %x = alloca i32, align 4
  %y = alloca i32, align 4
  %cx = alloca i32, align 4
  %cy = alloca i32, align 4
  %sx = alloca i32, align 4
  %sy = alloca i32, align 4
  %scx = alloca i32, align 4
  %scy = alloca i32, align 4
  %points = alloca ptr, align 8
  %dx = alloca i16, align 2
  %dy = alloca i16, align 2
  %more = alloca i32, align 4
  %comp = alloca ptr, align 8
  %flags266 = alloca i16, align 2
  %gidx = alloca i16, align 2
  %comp_num_verts = alloca i32, align 4
  %i267 = alloca i32, align 4
  %comp_verts = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %mtx = alloca [6 x float], align 16
  %m268 = alloca float, align 4
  %n269 = alloca float, align 4
  %v = alloca ptr, align 8
  %x386 = alloca i16, align 2
  %y387 = alloca i16, align 2
  store ptr %info, ptr %info.addr, align 8
  store i32 %glyph_index, ptr %glyph_index.addr, align 4
  store ptr %pvertices, ptr %pvertices.addr, align 8
  %0 = load ptr, ptr %info.addr, align 8
  %data1 = getelementptr inbounds %struct.stbtt_fontinfo, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %data1, align 8
  store ptr %1, ptr %data, align 8
  store ptr null, ptr %vertices, align 8
  store i32 0, ptr %num_vertices, align 4
  %2 = load ptr, ptr %info.addr, align 8
  %3 = load i32, ptr %glyph_index.addr, align 4
  %call = call noundef i32 @_ZL20stbtt__GetGlyfOffsetPK14stbtt_fontinfoi(ptr noundef %2, i32 noundef %3)
  store i32 %call, ptr %g, align 4
  %4 = load ptr, ptr %pvertices.addr, align 8
  store ptr null, ptr %4, align 8
  %5 = load i32, ptr %g, align 4
  %cmp = icmp slt i32 %5, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load ptr, ptr %data, align 8
  %7 = load i32, ptr %g, align 4
  %idx.ext = sext i32 %7 to i64
  %add.ptr = getelementptr inbounds i8, ptr %6, i64 %idx.ext
  %call2 = call noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %add.ptr)
  store i16 %call2, ptr %numberOfContours, align 2
  %8 = load i16, ptr %numberOfContours, align 2
  %conv = sext i16 %8 to i32
  %cmp3 = icmp sgt i32 %conv, 0
  br i1 %cmp3, label %if.then4, label %if.else258

if.then4:                                         ; preds = %if.end
  store i8 0, ptr %flags, align 1
  store i32 0, ptr %j, align 4
  store i32 0, ptr %was_off, align 4
  store i32 0, ptr %start_off, align 4
  %9 = load ptr, ptr %data, align 8
  %10 = load i32, ptr %g, align 4
  %idx.ext5 = sext i32 %10 to i64
  %add.ptr6 = getelementptr inbounds i8, ptr %9, i64 %idx.ext5
  %add.ptr7 = getelementptr inbounds i8, ptr %add.ptr6, i64 10
  store ptr %add.ptr7, ptr %endPtsOfContours, align 8
  %11 = load ptr, ptr %data, align 8
  %12 = load i32, ptr %g, align 4
  %idx.ext8 = sext i32 %12 to i64
  %add.ptr9 = getelementptr inbounds i8, ptr %11, i64 %idx.ext8
  %add.ptr10 = getelementptr inbounds i8, ptr %add.ptr9, i64 10
  %13 = load i16, ptr %numberOfContours, align 2
  %conv11 = sext i16 %13 to i32
  %mul = mul nsw i32 %conv11, 2
  %idx.ext12 = sext i32 %mul to i64
  %add.ptr13 = getelementptr inbounds i8, ptr %add.ptr10, i64 %idx.ext12
  %call14 = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr13)
  %conv15 = zext i16 %call14 to i32
  store i32 %conv15, ptr %ins, align 4
  %14 = load ptr, ptr %data, align 8
  %15 = load i32, ptr %g, align 4
  %idx.ext16 = sext i32 %15 to i64
  %add.ptr17 = getelementptr inbounds i8, ptr %14, i64 %idx.ext16
  %add.ptr18 = getelementptr inbounds i8, ptr %add.ptr17, i64 10
  %16 = load i16, ptr %numberOfContours, align 2
  %conv19 = sext i16 %16 to i32
  %mul20 = mul nsw i32 %conv19, 2
  %idx.ext21 = sext i32 %mul20 to i64
  %add.ptr22 = getelementptr inbounds i8, ptr %add.ptr18, i64 %idx.ext21
  %add.ptr23 = getelementptr inbounds i8, ptr %add.ptr22, i64 2
  %17 = load i32, ptr %ins, align 4
  %idx.ext24 = sext i32 %17 to i64
  %add.ptr25 = getelementptr inbounds i8, ptr %add.ptr23, i64 %idx.ext24
  store ptr %add.ptr25, ptr %points, align 8
  %18 = load ptr, ptr %endPtsOfContours, align 8
  %19 = load i16, ptr %numberOfContours, align 2
  %conv26 = sext i16 %19 to i32
  %mul27 = mul nsw i32 %conv26, 2
  %idx.ext28 = sext i32 %mul27 to i64
  %add.ptr29 = getelementptr inbounds i8, ptr %18, i64 %idx.ext28
  %add.ptr30 = getelementptr inbounds i8, ptr %add.ptr29, i64 -2
  %call31 = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr30)
  %conv32 = zext i16 %call31 to i32
  %add = add nsw i32 1, %conv32
  store i32 %add, ptr %n, align 4
  %20 = load i32, ptr %n, align 4
  %21 = load i16, ptr %numberOfContours, align 2
  %conv33 = sext i16 %21 to i32
  %mul34 = mul nsw i32 2, %conv33
  %add35 = add nsw i32 %20, %mul34
  store i32 %add35, ptr %m, align 4
  %22 = load i32, ptr %m, align 4
  %conv36 = sext i32 %22 to i64
  %mul37 = mul i64 %conv36, 14
  %call38 = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul37)
  store ptr %call38, ptr %vertices, align 8
  %23 = load ptr, ptr %vertices, align 8
  %cmp39 = icmp eq ptr %23, null
  br i1 %cmp39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %if.then4
  store i32 0, ptr %retval, align 4
  br label %return

if.end41:                                         ; preds = %if.then4
  store i32 0, ptr %next_move, align 4
  store i8 0, ptr %flagcount, align 1
  %24 = load i32, ptr %m, align 4
  %25 = load i32, ptr %n, align 4
  %sub = sub nsw i32 %24, %25
  store i32 %sub, ptr %off, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end41
  %26 = load i32, ptr %i, align 4
  %27 = load i32, ptr %n, align 4
  %cmp42 = icmp slt i32 %26, %27
  br i1 %cmp42, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %28 = load i8, ptr %flagcount, align 1
  %conv43 = zext i8 %28 to i32
  %cmp44 = icmp eq i32 %conv43, 0
  br i1 %cmp44, label %if.then45, label %if.else

if.then45:                                        ; preds = %for.body
  %29 = load ptr, ptr %points, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %29, i32 1
  store ptr %incdec.ptr, ptr %points, align 8
  %30 = load i8, ptr %29, align 1
  store i8 %30, ptr %flags, align 1
  %31 = load i8, ptr %flags, align 1
  %conv46 = zext i8 %31 to i32
  %and = and i32 %conv46, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then47, label %if.end49

if.then47:                                        ; preds = %if.then45
  %32 = load ptr, ptr %points, align 8
  %incdec.ptr48 = getelementptr inbounds i8, ptr %32, i32 1
  store ptr %incdec.ptr48, ptr %points, align 8
  %33 = load i8, ptr %32, align 1
  store i8 %33, ptr %flagcount, align 1
  br label %if.end49

if.end49:                                         ; preds = %if.then47, %if.then45
  br label %if.end50

if.else:                                          ; preds = %for.body
  %34 = load i8, ptr %flagcount, align 1
  %dec = add i8 %34, -1
  store i8 %dec, ptr %flagcount, align 1
  br label %if.end50

if.end50:                                         ; preds = %if.else, %if.end49
  %35 = load i8, ptr %flags, align 1
  %36 = load ptr, ptr %vertices, align 8
  %37 = load i32, ptr %off, align 4
  %38 = load i32, ptr %i, align 4
  %add51 = add nsw i32 %37, %38
  %idxprom = sext i32 %add51 to i64
  %arrayidx = getelementptr inbounds %struct.stbtt_vertex, ptr %36, i64 %idxprom
  %type = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx, i32 0, i32 6
  store i8 %35, ptr %type, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.end50
  %39 = load i32, ptr %i, align 4
  %inc = add nsw i32 %39, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !137

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %x, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond52

for.cond52:                                       ; preds = %for.inc94, %for.end
  %40 = load i32, ptr %i, align 4
  %41 = load i32, ptr %n, align 4
  %cmp53 = icmp slt i32 %40, %41
  br i1 %cmp53, label %for.body54, label %for.end96

for.body54:                                       ; preds = %for.cond52
  %42 = load ptr, ptr %vertices, align 8
  %43 = load i32, ptr %off, align 4
  %44 = load i32, ptr %i, align 4
  %add55 = add nsw i32 %43, %44
  %idxprom56 = sext i32 %add55 to i64
  %arrayidx57 = getelementptr inbounds %struct.stbtt_vertex, ptr %42, i64 %idxprom56
  %type58 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx57, i32 0, i32 6
  %45 = load i8, ptr %type58, align 2
  store i8 %45, ptr %flags, align 1
  %46 = load i8, ptr %flags, align 1
  %conv59 = zext i8 %46 to i32
  %and60 = and i32 %conv59, 2
  %tobool61 = icmp ne i32 %and60, 0
  br i1 %tobool61, label %if.then62, label %if.else72

if.then62:                                        ; preds = %for.body54
  %47 = load ptr, ptr %points, align 8
  %incdec.ptr63 = getelementptr inbounds i8, ptr %47, i32 1
  store ptr %incdec.ptr63, ptr %points, align 8
  %48 = load i8, ptr %47, align 1
  %conv64 = zext i8 %48 to i16
  store i16 %conv64, ptr %dx, align 2
  %49 = load i8, ptr %flags, align 1
  %conv65 = zext i8 %49 to i32
  %and66 = and i32 %conv65, 16
  %tobool67 = icmp ne i32 %and66, 0
  br i1 %tobool67, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then62
  %50 = load i16, ptr %dx, align 2
  %conv68 = sext i16 %50 to i32
  br label %cond.end

cond.false:                                       ; preds = %if.then62
  %51 = load i16, ptr %dx, align 2
  %conv69 = sext i16 %51 to i32
  %sub70 = sub nsw i32 0, %conv69
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv68, %cond.true ], [ %sub70, %cond.false ]
  %52 = load i32, ptr %x, align 4
  %add71 = add nsw i32 %52, %cond
  store i32 %add71, ptr %x, align 4
  br label %if.end88

if.else72:                                        ; preds = %for.body54
  %53 = load i8, ptr %flags, align 1
  %conv73 = zext i8 %53 to i32
  %and74 = and i32 %conv73, 16
  %tobool75 = icmp ne i32 %and74, 0
  br i1 %tobool75, label %if.end87, label %if.then76

if.then76:                                        ; preds = %if.else72
  %54 = load i32, ptr %x, align 4
  %55 = load ptr, ptr %points, align 8
  %arrayidx77 = getelementptr inbounds i8, ptr %55, i64 0
  %56 = load i8, ptr %arrayidx77, align 1
  %conv78 = zext i8 %56 to i32
  %mul79 = mul nsw i32 %conv78, 256
  %57 = load ptr, ptr %points, align 8
  %arrayidx80 = getelementptr inbounds i8, ptr %57, i64 1
  %58 = load i8, ptr %arrayidx80, align 1
  %conv81 = zext i8 %58 to i32
  %add82 = add nsw i32 %mul79, %conv81
  %conv83 = trunc i32 %add82 to i16
  %conv84 = sext i16 %conv83 to i32
  %add85 = add nsw i32 %54, %conv84
  store i32 %add85, ptr %x, align 4
  %59 = load ptr, ptr %points, align 8
  %add.ptr86 = getelementptr inbounds i8, ptr %59, i64 2
  store ptr %add.ptr86, ptr %points, align 8
  br label %if.end87

if.end87:                                         ; preds = %if.then76, %if.else72
  br label %if.end88

if.end88:                                         ; preds = %if.end87, %cond.end
  %60 = load i32, ptr %x, align 4
  %conv89 = trunc i32 %60 to i16
  %61 = load ptr, ptr %vertices, align 8
  %62 = load i32, ptr %off, align 4
  %63 = load i32, ptr %i, align 4
  %add90 = add nsw i32 %62, %63
  %idxprom91 = sext i32 %add90 to i64
  %arrayidx92 = getelementptr inbounds %struct.stbtt_vertex, ptr %61, i64 %idxprom91
  %x93 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx92, i32 0, i32 0
  store i16 %conv89, ptr %x93, align 2
  br label %for.inc94

for.inc94:                                        ; preds = %if.end88
  %64 = load i32, ptr %i, align 4
  %inc95 = add nsw i32 %64, 1
  store i32 %inc95, ptr %i, align 4
  br label %for.cond52, !llvm.loop !138

for.end96:                                        ; preds = %for.cond52
  store i32 0, ptr %y, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond97

for.cond97:                                       ; preds = %for.inc143, %for.end96
  %65 = load i32, ptr %i, align 4
  %66 = load i32, ptr %n, align 4
  %cmp98 = icmp slt i32 %65, %66
  br i1 %cmp98, label %for.body99, label %for.end145

for.body99:                                       ; preds = %for.cond97
  %67 = load ptr, ptr %vertices, align 8
  %68 = load i32, ptr %off, align 4
  %69 = load i32, ptr %i, align 4
  %add100 = add nsw i32 %68, %69
  %idxprom101 = sext i32 %add100 to i64
  %arrayidx102 = getelementptr inbounds %struct.stbtt_vertex, ptr %67, i64 %idxprom101
  %type103 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx102, i32 0, i32 6
  %70 = load i8, ptr %type103, align 2
  store i8 %70, ptr %flags, align 1
  %71 = load i8, ptr %flags, align 1
  %conv104 = zext i8 %71 to i32
  %and105 = and i32 %conv104, 4
  %tobool106 = icmp ne i32 %and105, 0
  br i1 %tobool106, label %if.then107, label %if.else121

if.then107:                                       ; preds = %for.body99
  %72 = load ptr, ptr %points, align 8
  %incdec.ptr108 = getelementptr inbounds i8, ptr %72, i32 1
  store ptr %incdec.ptr108, ptr %points, align 8
  %73 = load i8, ptr %72, align 1
  %conv109 = zext i8 %73 to i16
  store i16 %conv109, ptr %dy, align 2
  %74 = load i8, ptr %flags, align 1
  %conv110 = zext i8 %74 to i32
  %and111 = and i32 %conv110, 32
  %tobool112 = icmp ne i32 %and111, 0
  br i1 %tobool112, label %cond.true113, label %cond.false115

cond.true113:                                     ; preds = %if.then107
  %75 = load i16, ptr %dy, align 2
  %conv114 = sext i16 %75 to i32
  br label %cond.end118

cond.false115:                                    ; preds = %if.then107
  %76 = load i16, ptr %dy, align 2
  %conv116 = sext i16 %76 to i32
  %sub117 = sub nsw i32 0, %conv116
  br label %cond.end118

cond.end118:                                      ; preds = %cond.false115, %cond.true113
  %cond119 = phi i32 [ %conv114, %cond.true113 ], [ %sub117, %cond.false115 ]
  %77 = load i32, ptr %y, align 4
  %add120 = add nsw i32 %77, %cond119
  store i32 %add120, ptr %y, align 4
  br label %if.end137

if.else121:                                       ; preds = %for.body99
  %78 = load i8, ptr %flags, align 1
  %conv122 = zext i8 %78 to i32
  %and123 = and i32 %conv122, 32
  %tobool124 = icmp ne i32 %and123, 0
  br i1 %tobool124, label %if.end136, label %if.then125

if.then125:                                       ; preds = %if.else121
  %79 = load i32, ptr %y, align 4
  %80 = load ptr, ptr %points, align 8
  %arrayidx126 = getelementptr inbounds i8, ptr %80, i64 0
  %81 = load i8, ptr %arrayidx126, align 1
  %conv127 = zext i8 %81 to i32
  %mul128 = mul nsw i32 %conv127, 256
  %82 = load ptr, ptr %points, align 8
  %arrayidx129 = getelementptr inbounds i8, ptr %82, i64 1
  %83 = load i8, ptr %arrayidx129, align 1
  %conv130 = zext i8 %83 to i32
  %add131 = add nsw i32 %mul128, %conv130
  %conv132 = trunc i32 %add131 to i16
  %conv133 = sext i16 %conv132 to i32
  %add134 = add nsw i32 %79, %conv133
  store i32 %add134, ptr %y, align 4
  %84 = load ptr, ptr %points, align 8
  %add.ptr135 = getelementptr inbounds i8, ptr %84, i64 2
  store ptr %add.ptr135, ptr %points, align 8
  br label %if.end136

if.end136:                                        ; preds = %if.then125, %if.else121
  br label %if.end137

if.end137:                                        ; preds = %if.end136, %cond.end118
  %85 = load i32, ptr %y, align 4
  %conv138 = trunc i32 %85 to i16
  %86 = load ptr, ptr %vertices, align 8
  %87 = load i32, ptr %off, align 4
  %88 = load i32, ptr %i, align 4
  %add139 = add nsw i32 %87, %88
  %idxprom140 = sext i32 %add139 to i64
  %arrayidx141 = getelementptr inbounds %struct.stbtt_vertex, ptr %86, i64 %idxprom140
  %y142 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx141, i32 0, i32 1
  store i16 %conv138, ptr %y142, align 2
  br label %for.inc143

for.inc143:                                       ; preds = %if.end137
  %89 = load i32, ptr %i, align 4
  %inc144 = add nsw i32 %89, 1
  store i32 %inc144, ptr %i, align 4
  br label %for.cond97, !llvm.loop !139

for.end145:                                       ; preds = %for.cond97
  store i32 0, ptr %num_vertices, align 4
  store i32 0, ptr %scy, align 4
  store i32 0, ptr %scx, align 4
  store i32 0, ptr %cy, align 4
  store i32 0, ptr %cx, align 4
  store i32 0, ptr %sy, align 4
  store i32 0, ptr %sx, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond146

for.cond146:                                      ; preds = %for.inc254, %for.end145
  %90 = load i32, ptr %i, align 4
  %91 = load i32, ptr %n, align 4
  %cmp147 = icmp slt i32 %90, %91
  br i1 %cmp147, label %for.body148, label %for.end256

for.body148:                                      ; preds = %for.cond146
  %92 = load ptr, ptr %vertices, align 8
  %93 = load i32, ptr %off, align 4
  %94 = load i32, ptr %i, align 4
  %add149 = add nsw i32 %93, %94
  %idxprom150 = sext i32 %add149 to i64
  %arrayidx151 = getelementptr inbounds %struct.stbtt_vertex, ptr %92, i64 %idxprom150
  %type152 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx151, i32 0, i32 6
  %95 = load i8, ptr %type152, align 2
  store i8 %95, ptr %flags, align 1
  %96 = load ptr, ptr %vertices, align 8
  %97 = load i32, ptr %off, align 4
  %98 = load i32, ptr %i, align 4
  %add153 = add nsw i32 %97, %98
  %idxprom154 = sext i32 %add153 to i64
  %arrayidx155 = getelementptr inbounds %struct.stbtt_vertex, ptr %96, i64 %idxprom154
  %x156 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx155, i32 0, i32 0
  %99 = load i16, ptr %x156, align 2
  %conv157 = sext i16 %99 to i32
  store i32 %conv157, ptr %x, align 4
  %100 = load ptr, ptr %vertices, align 8
  %101 = load i32, ptr %off, align 4
  %102 = load i32, ptr %i, align 4
  %add158 = add nsw i32 %101, %102
  %idxprom159 = sext i32 %add158 to i64
  %arrayidx160 = getelementptr inbounds %struct.stbtt_vertex, ptr %100, i64 %idxprom159
  %y161 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx160, i32 0, i32 1
  %103 = load i16, ptr %y161, align 2
  %conv162 = sext i16 %103 to i32
  store i32 %conv162, ptr %y, align 4
  %104 = load i32, ptr %next_move, align 4
  %105 = load i32, ptr %i, align 4
  %cmp163 = icmp eq i32 %104, %105
  br i1 %cmp163, label %if.then164, label %if.else226

if.then164:                                       ; preds = %for.body148
  %106 = load i32, ptr %i, align 4
  %cmp165 = icmp ne i32 %106, 0
  br i1 %cmp165, label %if.then166, label %if.end168

if.then166:                                       ; preds = %if.then164
  %107 = load ptr, ptr %vertices, align 8
  %108 = load i32, ptr %num_vertices, align 4
  %109 = load i32, ptr %was_off, align 4
  %110 = load i32, ptr %start_off, align 4
  %111 = load i32, ptr %sx, align 4
  %112 = load i32, ptr %sy, align 4
  %113 = load i32, ptr %scx, align 4
  %114 = load i32, ptr %scy, align 4
  %115 = load i32, ptr %cx, align 4
  %116 = load i32, ptr %cy, align 4
  %call167 = call noundef i32 @_ZL18stbtt__close_shapeP12stbtt_vertexiiiiiiiii(ptr noundef %107, i32 noundef %108, i32 noundef %109, i32 noundef %110, i32 noundef %111, i32 noundef %112, i32 noundef %113, i32 noundef %114, i32 noundef %115, i32 noundef %116)
  store i32 %call167, ptr %num_vertices, align 4
  br label %if.end168

if.end168:                                        ; preds = %if.then166, %if.then164
  %117 = load i8, ptr %flags, align 1
  %conv169 = zext i8 %117 to i32
  %and170 = and i32 %conv169, 1
  %tobool171 = icmp ne i32 %and170, 0
  %lnot = xor i1 %tobool171, true
  %conv172 = zext i1 %lnot to i32
  store i32 %conv172, ptr %start_off, align 4
  %118 = load i32, ptr %start_off, align 4
  %tobool173 = icmp ne i32 %118, 0
  br i1 %tobool173, label %if.then174, label %if.else214

if.then174:                                       ; preds = %if.end168
  %119 = load i32, ptr %x, align 4
  store i32 %119, ptr %scx, align 4
  %120 = load i32, ptr %y, align 4
  store i32 %120, ptr %scy, align 4
  %121 = load ptr, ptr %vertices, align 8
  %122 = load i32, ptr %off, align 4
  %123 = load i32, ptr %i, align 4
  %add175 = add nsw i32 %122, %123
  %add176 = add nsw i32 %add175, 1
  %idxprom177 = sext i32 %add176 to i64
  %arrayidx178 = getelementptr inbounds %struct.stbtt_vertex, ptr %121, i64 %idxprom177
  %type179 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx178, i32 0, i32 6
  %124 = load i8, ptr %type179, align 2
  %conv180 = zext i8 %124 to i32
  %and181 = and i32 %conv180, 1
  %tobool182 = icmp ne i32 %and181, 0
  br i1 %tobool182, label %if.else199, label %if.then183

if.then183:                                       ; preds = %if.then174
  %125 = load i32, ptr %x, align 4
  %126 = load ptr, ptr %vertices, align 8
  %127 = load i32, ptr %off, align 4
  %128 = load i32, ptr %i, align 4
  %add184 = add nsw i32 %127, %128
  %add185 = add nsw i32 %add184, 1
  %idxprom186 = sext i32 %add185 to i64
  %arrayidx187 = getelementptr inbounds %struct.stbtt_vertex, ptr %126, i64 %idxprom186
  %x188 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx187, i32 0, i32 0
  %129 = load i16, ptr %x188, align 2
  %conv189 = sext i16 %129 to i32
  %add190 = add nsw i32 %125, %conv189
  %shr = ashr i32 %add190, 1
  store i32 %shr, ptr %sx, align 4
  %130 = load i32, ptr %y, align 4
  %131 = load ptr, ptr %vertices, align 8
  %132 = load i32, ptr %off, align 4
  %133 = load i32, ptr %i, align 4
  %add191 = add nsw i32 %132, %133
  %add192 = add nsw i32 %add191, 1
  %idxprom193 = sext i32 %add192 to i64
  %arrayidx194 = getelementptr inbounds %struct.stbtt_vertex, ptr %131, i64 %idxprom193
  %y195 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx194, i32 0, i32 1
  %134 = load i16, ptr %y195, align 2
  %conv196 = sext i16 %134 to i32
  %add197 = add nsw i32 %130, %conv196
  %shr198 = ashr i32 %add197, 1
  store i32 %shr198, ptr %sy, align 4
  br label %if.end213

if.else199:                                       ; preds = %if.then174
  %135 = load ptr, ptr %vertices, align 8
  %136 = load i32, ptr %off, align 4
  %137 = load i32, ptr %i, align 4
  %add200 = add nsw i32 %136, %137
  %add201 = add nsw i32 %add200, 1
  %idxprom202 = sext i32 %add201 to i64
  %arrayidx203 = getelementptr inbounds %struct.stbtt_vertex, ptr %135, i64 %idxprom202
  %x204 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx203, i32 0, i32 0
  %138 = load i16, ptr %x204, align 2
  %conv205 = sext i16 %138 to i32
  store i32 %conv205, ptr %sx, align 4
  %139 = load ptr, ptr %vertices, align 8
  %140 = load i32, ptr %off, align 4
  %141 = load i32, ptr %i, align 4
  %add206 = add nsw i32 %140, %141
  %add207 = add nsw i32 %add206, 1
  %idxprom208 = sext i32 %add207 to i64
  %arrayidx209 = getelementptr inbounds %struct.stbtt_vertex, ptr %139, i64 %idxprom208
  %y210 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx209, i32 0, i32 1
  %142 = load i16, ptr %y210, align 2
  %conv211 = sext i16 %142 to i32
  store i32 %conv211, ptr %sy, align 4
  %143 = load i32, ptr %i, align 4
  %inc212 = add nsw i32 %143, 1
  store i32 %inc212, ptr %i, align 4
  br label %if.end213

if.end213:                                        ; preds = %if.else199, %if.then183
  br label %if.end215

if.else214:                                       ; preds = %if.end168
  %144 = load i32, ptr %x, align 4
  store i32 %144, ptr %sx, align 4
  %145 = load i32, ptr %y, align 4
  store i32 %145, ptr %sy, align 4
  br label %if.end215

if.end215:                                        ; preds = %if.else214, %if.end213
  %146 = load ptr, ptr %vertices, align 8
  %147 = load i32, ptr %num_vertices, align 4
  %inc216 = add nsw i32 %147, 1
  store i32 %inc216, ptr %num_vertices, align 4
  %idxprom217 = sext i32 %147 to i64
  %arrayidx218 = getelementptr inbounds %struct.stbtt_vertex, ptr %146, i64 %idxprom217
  %148 = load i32, ptr %sx, align 4
  %149 = load i32, ptr %sy, align 4
  call void @_ZL15stbtt_setvertexP12stbtt_vertexhiiii(ptr noundef %arrayidx218, i8 noundef zeroext 1, i32 noundef %148, i32 noundef %149, i32 noundef 0, i32 noundef 0)
  store i32 0, ptr %was_off, align 4
  %150 = load ptr, ptr %endPtsOfContours, align 8
  %151 = load i32, ptr %j, align 4
  %mul219 = mul nsw i32 %151, 2
  %idx.ext220 = sext i32 %mul219 to i64
  %add.ptr221 = getelementptr inbounds i8, ptr %150, i64 %idx.ext220
  %call222 = call noundef zeroext i16 @_ZL8ttUSHORTPh(ptr noundef %add.ptr221)
  %conv223 = zext i16 %call222 to i32
  %add224 = add nsw i32 1, %conv223
  store i32 %add224, ptr %next_move, align 4
  %152 = load i32, ptr %j, align 4
  %inc225 = add nsw i32 %152, 1
  store i32 %inc225, ptr %j, align 4
  br label %if.end253

if.else226:                                       ; preds = %for.body148
  %153 = load i8, ptr %flags, align 1
  %conv227 = zext i8 %153 to i32
  %and228 = and i32 %conv227, 1
  %tobool229 = icmp ne i32 %and228, 0
  br i1 %tobool229, label %if.else241, label %if.then230

if.then230:                                       ; preds = %if.else226
  %154 = load i32, ptr %was_off, align 4
  %tobool231 = icmp ne i32 %154, 0
  br i1 %tobool231, label %if.then232, label %if.end240

if.then232:                                       ; preds = %if.then230
  %155 = load ptr, ptr %vertices, align 8
  %156 = load i32, ptr %num_vertices, align 4
  %inc233 = add nsw i32 %156, 1
  store i32 %inc233, ptr %num_vertices, align 4
  %idxprom234 = sext i32 %156 to i64
  %arrayidx235 = getelementptr inbounds %struct.stbtt_vertex, ptr %155, i64 %idxprom234
  %157 = load i32, ptr %cx, align 4
  %158 = load i32, ptr %x, align 4
  %add236 = add nsw i32 %157, %158
  %shr237 = ashr i32 %add236, 1
  %159 = load i32, ptr %cy, align 4
  %160 = load i32, ptr %y, align 4
  %add238 = add nsw i32 %159, %160
  %shr239 = ashr i32 %add238, 1
  %161 = load i32, ptr %cx, align 4
  %162 = load i32, ptr %cy, align 4
  call void @_ZL15stbtt_setvertexP12stbtt_vertexhiiii(ptr noundef %arrayidx235, i8 noundef zeroext 3, i32 noundef %shr237, i32 noundef %shr239, i32 noundef %161, i32 noundef %162)
  br label %if.end240

if.end240:                                        ; preds = %if.then232, %if.then230
  %163 = load i32, ptr %x, align 4
  store i32 %163, ptr %cx, align 4
  %164 = load i32, ptr %y, align 4
  store i32 %164, ptr %cy, align 4
  store i32 1, ptr %was_off, align 4
  br label %if.end252

if.else241:                                       ; preds = %if.else226
  %165 = load i32, ptr %was_off, align 4
  %tobool242 = icmp ne i32 %165, 0
  br i1 %tobool242, label %if.then243, label %if.else247

if.then243:                                       ; preds = %if.else241
  %166 = load ptr, ptr %vertices, align 8
  %167 = load i32, ptr %num_vertices, align 4
  %inc244 = add nsw i32 %167, 1
  store i32 %inc244, ptr %num_vertices, align 4
  %idxprom245 = sext i32 %167 to i64
  %arrayidx246 = getelementptr inbounds %struct.stbtt_vertex, ptr %166, i64 %idxprom245
  %168 = load i32, ptr %x, align 4
  %169 = load i32, ptr %y, align 4
  %170 = load i32, ptr %cx, align 4
  %171 = load i32, ptr %cy, align 4
  call void @_ZL15stbtt_setvertexP12stbtt_vertexhiiii(ptr noundef %arrayidx246, i8 noundef zeroext 3, i32 noundef %168, i32 noundef %169, i32 noundef %170, i32 noundef %171)
  br label %if.end251

if.else247:                                       ; preds = %if.else241
  %172 = load ptr, ptr %vertices, align 8
  %173 = load i32, ptr %num_vertices, align 4
  %inc248 = add nsw i32 %173, 1
  store i32 %inc248, ptr %num_vertices, align 4
  %idxprom249 = sext i32 %173 to i64
  %arrayidx250 = getelementptr inbounds %struct.stbtt_vertex, ptr %172, i64 %idxprom249
  %174 = load i32, ptr %x, align 4
  %175 = load i32, ptr %y, align 4
  call void @_ZL15stbtt_setvertexP12stbtt_vertexhiiii(ptr noundef %arrayidx250, i8 noundef zeroext 2, i32 noundef %174, i32 noundef %175, i32 noundef 0, i32 noundef 0)
  br label %if.end251

if.end251:                                        ; preds = %if.else247, %if.then243
  store i32 0, ptr %was_off, align 4
  br label %if.end252

if.end252:                                        ; preds = %if.end251, %if.end240
  br label %if.end253

if.end253:                                        ; preds = %if.end252, %if.end215
  br label %for.inc254

for.inc254:                                       ; preds = %if.end253
  %176 = load i32, ptr %i, align 4
  %inc255 = add nsw i32 %176, 1
  store i32 %inc255, ptr %i, align 4
  br label %for.cond146, !llvm.loop !140

for.end256:                                       ; preds = %for.cond146
  %177 = load ptr, ptr %vertices, align 8
  %178 = load i32, ptr %num_vertices, align 4
  %179 = load i32, ptr %was_off, align 4
  %180 = load i32, ptr %start_off, align 4
  %181 = load i32, ptr %sx, align 4
  %182 = load i32, ptr %sy, align 4
  %183 = load i32, ptr %scx, align 4
  %184 = load i32, ptr %scy, align 4
  %185 = load i32, ptr %cx, align 4
  %186 = load i32, ptr %cy, align 4
  %call257 = call noundef i32 @_ZL18stbtt__close_shapeP12stbtt_vertexiiiiiiiii(ptr noundef %177, i32 noundef %178, i32 noundef %179, i32 noundef %180, i32 noundef %181, i32 noundef %182, i32 noundef %183, i32 noundef %184, i32 noundef %185, i32 noundef %186)
  store i32 %call257, ptr %num_vertices, align 4
  br label %if.end484

if.else258:                                       ; preds = %if.end
  %187 = load i16, ptr %numberOfContours, align 2
  %conv259 = sext i16 %187 to i32
  %cmp260 = icmp slt i32 %conv259, 0
  br i1 %cmp260, label %if.then261, label %if.else482

if.then261:                                       ; preds = %if.else258
  store i32 1, ptr %more, align 4
  %188 = load ptr, ptr %data, align 8
  %189 = load i32, ptr %g, align 4
  %idx.ext262 = sext i32 %189 to i64
  %add.ptr263 = getelementptr inbounds i8, ptr %188, i64 %idx.ext262
  %add.ptr264 = getelementptr inbounds i8, ptr %add.ptr263, i64 10
  store ptr %add.ptr264, ptr %comp, align 8
  store i32 0, ptr %num_vertices, align 4
  store ptr null, ptr %vertices, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end479, %if.then261
  %190 = load i32, ptr %more, align 4
  %tobool265 = icmp ne i32 %190, 0
  br i1 %tobool265, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  store i32 0, ptr %comp_num_verts, align 4
  store ptr null, ptr %comp_verts, align 8
  store ptr null, ptr %tmp, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %mtx, ptr align 16 @__const._ZL22stbtt__GetGlyphShapeTTPK14stbtt_fontinfoiPP12stbtt_vertex.mtx, i64 24, i1 false)
  %191 = load ptr, ptr %comp, align 8
  %call270 = call noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %191)
  store i16 %call270, ptr %flags266, align 2
  %192 = load ptr, ptr %comp, align 8
  %add.ptr271 = getelementptr inbounds i8, ptr %192, i64 2
  store ptr %add.ptr271, ptr %comp, align 8
  %193 = load ptr, ptr %comp, align 8
  %call272 = call noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %193)
  store i16 %call272, ptr %gidx, align 2
  %194 = load ptr, ptr %comp, align 8
  %add.ptr273 = getelementptr inbounds i8, ptr %194, i64 2
  store ptr %add.ptr273, ptr %comp, align 8
  %195 = load i16, ptr %flags266, align 2
  %conv274 = zext i16 %195 to i32
  %and275 = and i32 %conv274, 2
  %tobool276 = icmp ne i32 %and275, 0
  br i1 %tobool276, label %if.then277, label %if.else298

if.then277:                                       ; preds = %while.body
  %196 = load i16, ptr %flags266, align 2
  %conv278 = zext i16 %196 to i32
  %and279 = and i32 %conv278, 1
  %tobool280 = icmp ne i32 %and279, 0
  br i1 %tobool280, label %if.then281, label %if.else290

if.then281:                                       ; preds = %if.then277
  %197 = load ptr, ptr %comp, align 8
  %call282 = call noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %197)
  %conv283 = sitofp i16 %call282 to float
  %arrayidx284 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 4
  store float %conv283, ptr %arrayidx284, align 16
  %198 = load ptr, ptr %comp, align 8
  %add.ptr285 = getelementptr inbounds i8, ptr %198, i64 2
  store ptr %add.ptr285, ptr %comp, align 8
  %199 = load ptr, ptr %comp, align 8
  %call286 = call noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %199)
  %conv287 = sitofp i16 %call286 to float
  %arrayidx288 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 5
  store float %conv287, ptr %arrayidx288, align 4
  %200 = load ptr, ptr %comp, align 8
  %add.ptr289 = getelementptr inbounds i8, ptr %200, i64 2
  store ptr %add.ptr289, ptr %comp, align 8
  br label %if.end297

if.else290:                                       ; preds = %if.then277
  %201 = load ptr, ptr %comp, align 8
  %202 = load i8, ptr %201, align 1
  %conv291 = sitofp i8 %202 to float
  %arrayidx292 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 4
  store float %conv291, ptr %arrayidx292, align 16
  %203 = load ptr, ptr %comp, align 8
  %add.ptr293 = getelementptr inbounds i8, ptr %203, i64 1
  store ptr %add.ptr293, ptr %comp, align 8
  %204 = load ptr, ptr %comp, align 8
  %205 = load i8, ptr %204, align 1
  %conv294 = sitofp i8 %205 to float
  %arrayidx295 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 5
  store float %conv294, ptr %arrayidx295, align 4
  %206 = load ptr, ptr %comp, align 8
  %add.ptr296 = getelementptr inbounds i8, ptr %206, i64 1
  store ptr %add.ptr296, ptr %comp, align 8
  br label %if.end297

if.end297:                                        ; preds = %if.else290, %if.then281
  br label %if.end299

if.else298:                                       ; preds = %while.body
  br label %do.body

do.body:                                          ; preds = %if.else298
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %if.end299

if.end299:                                        ; preds = %do.end, %if.end297
  %207 = load i16, ptr %flags266, align 2
  %conv300 = zext i16 %207 to i32
  %and301 = and i32 %conv300, 8
  %tobool302 = icmp ne i32 %and301, 0
  br i1 %tobool302, label %if.then303, label %if.else312

if.then303:                                       ; preds = %if.end299
  %208 = load ptr, ptr %comp, align 8
  %call304 = call noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %208)
  %conv305 = sext i16 %call304 to i32
  %conv306 = sitofp i32 %conv305 to float
  %div = fdiv float %conv306, 1.638400e+04
  %arrayidx307 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 3
  store float %div, ptr %arrayidx307, align 4
  %arrayidx308 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 0
  store float %div, ptr %arrayidx308, align 16
  %209 = load ptr, ptr %comp, align 8
  %add.ptr309 = getelementptr inbounds i8, ptr %209, i64 2
  store ptr %add.ptr309, ptr %comp, align 8
  %arrayidx310 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 2
  store float 0.000000e+00, ptr %arrayidx310, align 8
  %arrayidx311 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 1
  store float 0.000000e+00, ptr %arrayidx311, align 4
  br label %if.end362

if.else312:                                       ; preds = %if.end299
  %210 = load i16, ptr %flags266, align 2
  %conv313 = zext i16 %210 to i32
  %and314 = and i32 %conv313, 64
  %tobool315 = icmp ne i32 %and314, 0
  br i1 %tobool315, label %if.then316, label %if.else331

if.then316:                                       ; preds = %if.else312
  %211 = load ptr, ptr %comp, align 8
  %call317 = call noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %211)
  %conv318 = sext i16 %call317 to i32
  %conv319 = sitofp i32 %conv318 to float
  %div320 = fdiv float %conv319, 1.638400e+04
  %arrayidx321 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 0
  store float %div320, ptr %arrayidx321, align 16
  %212 = load ptr, ptr %comp, align 8
  %add.ptr322 = getelementptr inbounds i8, ptr %212, i64 2
  store ptr %add.ptr322, ptr %comp, align 8
  %arrayidx323 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 2
  store float 0.000000e+00, ptr %arrayidx323, align 8
  %arrayidx324 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 1
  store float 0.000000e+00, ptr %arrayidx324, align 4
  %213 = load ptr, ptr %comp, align 8
  %call325 = call noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %213)
  %conv326 = sext i16 %call325 to i32
  %conv327 = sitofp i32 %conv326 to float
  %div328 = fdiv float %conv327, 1.638400e+04
  %arrayidx329 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 3
  store float %div328, ptr %arrayidx329, align 4
  %214 = load ptr, ptr %comp, align 8
  %add.ptr330 = getelementptr inbounds i8, ptr %214, i64 2
  store ptr %add.ptr330, ptr %comp, align 8
  br label %if.end361

if.else331:                                       ; preds = %if.else312
  %215 = load i16, ptr %flags266, align 2
  %conv332 = zext i16 %215 to i32
  %and333 = and i32 %conv332, 128
  %tobool334 = icmp ne i32 %and333, 0
  br i1 %tobool334, label %if.then335, label %if.end360

if.then335:                                       ; preds = %if.else331
  %216 = load ptr, ptr %comp, align 8
  %call336 = call noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %216)
  %conv337 = sext i16 %call336 to i32
  %conv338 = sitofp i32 %conv337 to float
  %div339 = fdiv float %conv338, 1.638400e+04
  %arrayidx340 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 0
  store float %div339, ptr %arrayidx340, align 16
  %217 = load ptr, ptr %comp, align 8
  %add.ptr341 = getelementptr inbounds i8, ptr %217, i64 2
  store ptr %add.ptr341, ptr %comp, align 8
  %218 = load ptr, ptr %comp, align 8
  %call342 = call noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %218)
  %conv343 = sext i16 %call342 to i32
  %conv344 = sitofp i32 %conv343 to float
  %div345 = fdiv float %conv344, 1.638400e+04
  %arrayidx346 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 1
  store float %div345, ptr %arrayidx346, align 4
  %219 = load ptr, ptr %comp, align 8
  %add.ptr347 = getelementptr inbounds i8, ptr %219, i64 2
  store ptr %add.ptr347, ptr %comp, align 8
  %220 = load ptr, ptr %comp, align 8
  %call348 = call noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %220)
  %conv349 = sext i16 %call348 to i32
  %conv350 = sitofp i32 %conv349 to float
  %div351 = fdiv float %conv350, 1.638400e+04
  %arrayidx352 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 2
  store float %div351, ptr %arrayidx352, align 8
  %221 = load ptr, ptr %comp, align 8
  %add.ptr353 = getelementptr inbounds i8, ptr %221, i64 2
  store ptr %add.ptr353, ptr %comp, align 8
  %222 = load ptr, ptr %comp, align 8
  %call354 = call noundef signext i16 @_ZL7ttSHORTPh(ptr noundef %222)
  %conv355 = sext i16 %call354 to i32
  %conv356 = sitofp i32 %conv355 to float
  %div357 = fdiv float %conv356, 1.638400e+04
  %arrayidx358 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 3
  store float %div357, ptr %arrayidx358, align 4
  %223 = load ptr, ptr %comp, align 8
  %add.ptr359 = getelementptr inbounds i8, ptr %223, i64 2
  store ptr %add.ptr359, ptr %comp, align 8
  br label %if.end360

if.end360:                                        ; preds = %if.then335, %if.else331
  br label %if.end361

if.end361:                                        ; preds = %if.end360, %if.then316
  br label %if.end362

if.end362:                                        ; preds = %if.end361, %if.then303
  %arrayidx363 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 0
  %224 = load float, ptr %arrayidx363, align 16
  %arrayidx364 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 0
  %225 = load float, ptr %arrayidx364, align 16
  %arrayidx366 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 1
  %226 = load float, ptr %arrayidx366, align 4
  %arrayidx367 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 1
  %227 = load float, ptr %arrayidx367, align 4
  %mul368 = fmul float %226, %227
  %228 = call float @llvm.fmuladd.f32(float %224, float %225, float %mul368)
  %call369 = call float @sqrtf(float noundef %228) #12
  store float %call369, ptr %m268, align 4
  %arrayidx370 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 2
  %229 = load float, ptr %arrayidx370, align 8
  %arrayidx371 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 2
  %230 = load float, ptr %arrayidx371, align 8
  %arrayidx373 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 3
  %231 = load float, ptr %arrayidx373, align 4
  %arrayidx374 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 3
  %232 = load float, ptr %arrayidx374, align 4
  %mul375 = fmul float %231, %232
  %233 = call float @llvm.fmuladd.f32(float %229, float %230, float %mul375)
  %call376 = call float @sqrtf(float noundef %233) #12
  store float %call376, ptr %n269, align 4
  %234 = load ptr, ptr %info.addr, align 8
  %235 = load i16, ptr %gidx, align 2
  %conv377 = zext i16 %235 to i32
  %call378 = call noundef i32 @_ZL19stbtt_GetGlyphShapePK14stbtt_fontinfoiPP12stbtt_vertex(ptr noundef %234, i32 noundef %conv377, ptr noundef %comp_verts)
  store i32 %call378, ptr %comp_num_verts, align 4
  %236 = load i32, ptr %comp_num_verts, align 4
  %cmp379 = icmp sgt i32 %236, 0
  br i1 %cmp379, label %if.then380, label %if.end479

if.then380:                                       ; preds = %if.end362
  store i32 0, ptr %i267, align 4
  br label %for.cond381

for.cond381:                                      ; preds = %for.inc444, %if.then380
  %237 = load i32, ptr %i267, align 4
  %238 = load i32, ptr %comp_num_verts, align 4
  %cmp382 = icmp slt i32 %237, %238
  br i1 %cmp382, label %for.body383, label %for.end446

for.body383:                                      ; preds = %for.cond381
  %239 = load ptr, ptr %comp_verts, align 8
  %240 = load i32, ptr %i267, align 4
  %idxprom384 = sext i32 %240 to i64
  %arrayidx385 = getelementptr inbounds %struct.stbtt_vertex, ptr %239, i64 %idxprom384
  store ptr %arrayidx385, ptr %v, align 8
  %241 = load ptr, ptr %v, align 8
  %x388 = getelementptr inbounds %struct.stbtt_vertex, ptr %241, i32 0, i32 0
  %242 = load i16, ptr %x388, align 2
  store i16 %242, ptr %x386, align 2
  %243 = load ptr, ptr %v, align 8
  %y389 = getelementptr inbounds %struct.stbtt_vertex, ptr %243, i32 0, i32 1
  %244 = load i16, ptr %y389, align 2
  store i16 %244, ptr %y387, align 2
  %245 = load float, ptr %m268, align 4
  %arrayidx390 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 0
  %246 = load float, ptr %arrayidx390, align 16
  %247 = load i16, ptr %x386, align 2
  %conv391 = sext i16 %247 to i32
  %conv392 = sitofp i32 %conv391 to float
  %arrayidx394 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 2
  %248 = load float, ptr %arrayidx394, align 8
  %249 = load i16, ptr %y387, align 2
  %conv395 = sext i16 %249 to i32
  %conv396 = sitofp i32 %conv395 to float
  %mul397 = fmul float %248, %conv396
  %250 = call float @llvm.fmuladd.f32(float %246, float %conv392, float %mul397)
  %arrayidx398 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 4
  %251 = load float, ptr %arrayidx398, align 16
  %add399 = fadd float %250, %251
  %mul400 = fmul float %245, %add399
  %conv401 = fptosi float %mul400 to i16
  %252 = load ptr, ptr %v, align 8
  %x402 = getelementptr inbounds %struct.stbtt_vertex, ptr %252, i32 0, i32 0
  store i16 %conv401, ptr %x402, align 2
  %253 = load float, ptr %n269, align 4
  %arrayidx403 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 1
  %254 = load float, ptr %arrayidx403, align 4
  %255 = load i16, ptr %x386, align 2
  %conv404 = sext i16 %255 to i32
  %conv405 = sitofp i32 %conv404 to float
  %arrayidx407 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 3
  %256 = load float, ptr %arrayidx407, align 4
  %257 = load i16, ptr %y387, align 2
  %conv408 = sext i16 %257 to i32
  %conv409 = sitofp i32 %conv408 to float
  %mul410 = fmul float %256, %conv409
  %258 = call float @llvm.fmuladd.f32(float %254, float %conv405, float %mul410)
  %arrayidx411 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 5
  %259 = load float, ptr %arrayidx411, align 4
  %add412 = fadd float %258, %259
  %mul413 = fmul float %253, %add412
  %conv414 = fptosi float %mul413 to i16
  %260 = load ptr, ptr %v, align 8
  %y415 = getelementptr inbounds %struct.stbtt_vertex, ptr %260, i32 0, i32 1
  store i16 %conv414, ptr %y415, align 2
  %261 = load ptr, ptr %v, align 8
  %cx416 = getelementptr inbounds %struct.stbtt_vertex, ptr %261, i32 0, i32 2
  %262 = load i16, ptr %cx416, align 2
  store i16 %262, ptr %x386, align 2
  %263 = load ptr, ptr %v, align 8
  %cy417 = getelementptr inbounds %struct.stbtt_vertex, ptr %263, i32 0, i32 3
  %264 = load i16, ptr %cy417, align 2
  store i16 %264, ptr %y387, align 2
  %265 = load float, ptr %m268, align 4
  %arrayidx418 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 0
  %266 = load float, ptr %arrayidx418, align 16
  %267 = load i16, ptr %x386, align 2
  %conv419 = sext i16 %267 to i32
  %conv420 = sitofp i32 %conv419 to float
  %arrayidx422 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 2
  %268 = load float, ptr %arrayidx422, align 8
  %269 = load i16, ptr %y387, align 2
  %conv423 = sext i16 %269 to i32
  %conv424 = sitofp i32 %conv423 to float
  %mul425 = fmul float %268, %conv424
  %270 = call float @llvm.fmuladd.f32(float %266, float %conv420, float %mul425)
  %arrayidx426 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 4
  %271 = load float, ptr %arrayidx426, align 16
  %add427 = fadd float %270, %271
  %mul428 = fmul float %265, %add427
  %conv429 = fptosi float %mul428 to i16
  %272 = load ptr, ptr %v, align 8
  %cx430 = getelementptr inbounds %struct.stbtt_vertex, ptr %272, i32 0, i32 2
  store i16 %conv429, ptr %cx430, align 2
  %273 = load float, ptr %n269, align 4
  %arrayidx431 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 1
  %274 = load float, ptr %arrayidx431, align 4
  %275 = load i16, ptr %x386, align 2
  %conv432 = sext i16 %275 to i32
  %conv433 = sitofp i32 %conv432 to float
  %arrayidx435 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 3
  %276 = load float, ptr %arrayidx435, align 4
  %277 = load i16, ptr %y387, align 2
  %conv436 = sext i16 %277 to i32
  %conv437 = sitofp i32 %conv436 to float
  %mul438 = fmul float %276, %conv437
  %278 = call float @llvm.fmuladd.f32(float %274, float %conv433, float %mul438)
  %arrayidx439 = getelementptr inbounds [6 x float], ptr %mtx, i64 0, i64 5
  %279 = load float, ptr %arrayidx439, align 4
  %add440 = fadd float %278, %279
  %mul441 = fmul float %273, %add440
  %conv442 = fptosi float %mul441 to i16
  %280 = load ptr, ptr %v, align 8
  %cy443 = getelementptr inbounds %struct.stbtt_vertex, ptr %280, i32 0, i32 3
  store i16 %conv442, ptr %cy443, align 2
  br label %for.inc444

for.inc444:                                       ; preds = %for.body383
  %281 = load i32, ptr %i267, align 4
  %inc445 = add nsw i32 %281, 1
  store i32 %inc445, ptr %i267, align 4
  br label %for.cond381, !llvm.loop !141

for.end446:                                       ; preds = %for.cond381
  %282 = load i32, ptr %num_vertices, align 4
  %283 = load i32, ptr %comp_num_verts, align 4
  %add448 = add nsw i32 %282, %283
  %conv449 = sext i32 %add448 to i64
  %mul450 = mul i64 %conv449, 14
  %call451 = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul450)
  store ptr %call451, ptr %tmp, align 8
  %284 = load ptr, ptr %tmp, align 8
  %tobool452 = icmp ne ptr %284, null
  br i1 %tobool452, label %if.end462, label %if.then453

if.then453:                                       ; preds = %for.end446
  %285 = load ptr, ptr %vertices, align 8
  %tobool454 = icmp ne ptr %285, null
  br i1 %tobool454, label %if.then455, label %if.end457

if.then455:                                       ; preds = %if.then453
  %286 = load ptr, ptr %vertices, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %286)
  br label %if.end457

if.end457:                                        ; preds = %if.then455, %if.then453
  %287 = load ptr, ptr %comp_verts, align 8
  %tobool458 = icmp ne ptr %287, null
  br i1 %tobool458, label %if.then459, label %if.end461

if.then459:                                       ; preds = %if.end457
  %288 = load ptr, ptr %comp_verts, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %288)
  br label %if.end461

if.end461:                                        ; preds = %if.then459, %if.end457
  store i32 0, ptr %retval, align 4
  br label %return

if.end462:                                        ; preds = %for.end446
  %289 = load i32, ptr %num_vertices, align 4
  %cmp463 = icmp sgt i32 %289, 0
  br i1 %cmp463, label %land.lhs.true, label %if.end468

land.lhs.true:                                    ; preds = %if.end462
  %290 = load ptr, ptr %vertices, align 8
  %tobool464 = icmp ne ptr %290, null
  br i1 %tobool464, label %if.then465, label %if.end468

if.then465:                                       ; preds = %land.lhs.true
  %291 = load ptr, ptr %tmp, align 8
  %292 = load ptr, ptr %vertices, align 8
  %293 = load i32, ptr %num_vertices, align 4
  %conv466 = sext i32 %293 to i64
  %mul467 = mul i64 %conv466, 14
  call void @llvm.memcpy.p0.p0.i64(ptr align 2 %291, ptr align 2 %292, i64 %mul467, i1 false)
  br label %if.end468

if.end468:                                        ; preds = %if.then465, %land.lhs.true, %if.end462
  %294 = load ptr, ptr %tmp, align 8
  %295 = load i32, ptr %num_vertices, align 4
  %idx.ext469 = sext i32 %295 to i64
  %add.ptr470 = getelementptr inbounds %struct.stbtt_vertex, ptr %294, i64 %idx.ext469
  %296 = load ptr, ptr %comp_verts, align 8
  %297 = load i32, ptr %comp_num_verts, align 4
  %conv471 = sext i32 %297 to i64
  %mul472 = mul i64 %conv471, 14
  call void @llvm.memcpy.p0.p0.i64(ptr align 2 %add.ptr470, ptr align 2 %296, i64 %mul472, i1 false)
  %298 = load ptr, ptr %vertices, align 8
  %tobool473 = icmp ne ptr %298, null
  br i1 %tobool473, label %if.then474, label %if.end476

if.then474:                                       ; preds = %if.end468
  %299 = load ptr, ptr %vertices, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %299)
  br label %if.end476

if.end476:                                        ; preds = %if.then474, %if.end468
  %300 = load ptr, ptr %tmp, align 8
  store ptr %300, ptr %vertices, align 8
  %301 = load ptr, ptr %comp_verts, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %301)
  %302 = load i32, ptr %comp_num_verts, align 4
  %303 = load i32, ptr %num_vertices, align 4
  %add478 = add nsw i32 %303, %302
  store i32 %add478, ptr %num_vertices, align 4
  br label %if.end479

if.end479:                                        ; preds = %if.end476, %if.end362
  %304 = load i16, ptr %flags266, align 2
  %conv480 = zext i16 %304 to i32
  %and481 = and i32 %conv480, 32
  store i32 %and481, ptr %more, align 4
  br label %while.cond, !llvm.loop !142

while.end:                                        ; preds = %while.cond
  br label %if.end483

if.else482:                                       ; preds = %if.else258
  br label %if.end483

if.end483:                                        ; preds = %if.else482, %while.end
  br label %if.end484

if.end484:                                        ; preds = %if.end483, %for.end256
  %305 = load ptr, ptr %vertices, align 8
  %306 = load ptr, ptr %pvertices.addr, align 8
  store ptr %305, ptr %306, align 8
  %307 = load i32, ptr %num_vertices, align 4
  store i32 %307, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end484, %if.end461, %if.then40, %if.then
  %308 = load i32, ptr %retval, align 4
  ret i32 %308
}

; Function Attrs: mustprogress uwtable
define internal noundef i32 @_ZL22stbtt__GetGlyphShapeT2PK14stbtt_fontinfoiPP12stbtt_vertex(ptr noundef %info, i32 noundef %glyph_index, ptr noundef %pvertices) #4 {
entry:
  %retval = alloca i32, align 4
  %info.addr = alloca ptr, align 8
  %glyph_index.addr = alloca i32, align 4
  %pvertices.addr = alloca ptr, align 8
  %count_ctx = alloca %struct.stbtt__csctx, align 8
  %output_ctx = alloca %struct.stbtt__csctx, align 8
  store ptr %info, ptr %info.addr, align 8
  store i32 %glyph_index, ptr %glyph_index.addr, align 4
  store ptr %pvertices, ptr %pvertices.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %count_ctx, i8 0, i64 56, i1 false)
  %0 = getelementptr inbounds %struct.stbtt__csctx, ptr %count_ctx, i32 0, i32 0
  store i32 1, ptr %0, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %output_ctx, i8 0, i64 56, i1 false)
  %1 = load ptr, ptr %info.addr, align 8
  %2 = load i32, ptr %glyph_index.addr, align 4
  %call = call noundef i32 @_ZL21stbtt__run_charstringPK14stbtt_fontinfoiP12stbtt__csctx(ptr noundef %1, i32 noundef %2, ptr noundef %count_ctx)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %num_vertices = getelementptr inbounds %struct.stbtt__csctx, ptr %count_ctx, i32 0, i32 11
  %3 = load i32, ptr %num_vertices, align 8
  %conv = sext i32 %3 to i64
  %mul = mul i64 %conv, 14
  %call1 = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  %4 = load ptr, ptr %pvertices.addr, align 8
  store ptr %call1, ptr %4, align 8
  %5 = load ptr, ptr %pvertices.addr, align 8
  %6 = load ptr, ptr %5, align 8
  %pvertices2 = getelementptr inbounds %struct.stbtt__csctx, ptr %output_ctx, i32 0, i32 10
  store ptr %6, ptr %pvertices2, align 8
  %7 = load ptr, ptr %info.addr, align 8
  %8 = load i32, ptr %glyph_index.addr, align 4
  %call3 = call noundef i32 @_ZL21stbtt__run_charstringPK14stbtt_fontinfoiP12stbtt__csctx(ptr noundef %7, i32 noundef %8, ptr noundef %output_ctx)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then5
  br label %do.end

do.end:                                           ; preds = %do.body
  %num_vertices6 = getelementptr inbounds %struct.stbtt__csctx, ptr %output_ctx, i32 0, i32 11
  %9 = load i32, ptr %num_vertices6, align 8
  store i32 %9, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  %10 = load ptr, ptr %pvertices.addr, align 8
  store ptr null, ptr %10, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end7, %do.end
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZL18stbtt__close_shapeP12stbtt_vertexiiiiiiiii(ptr noundef %vertices, i32 noundef %num_vertices, i32 noundef %was_off, i32 noundef %start_off, i32 noundef %sx, i32 noundef %sy, i32 noundef %scx, i32 noundef %scy, i32 noundef %cx, i32 noundef %cy) #2 {
entry:
  %vertices.addr = alloca ptr, align 8
  %num_vertices.addr = alloca i32, align 4
  %was_off.addr = alloca i32, align 4
  %start_off.addr = alloca i32, align 4
  %sx.addr = alloca i32, align 4
  %sy.addr = alloca i32, align 4
  %scx.addr = alloca i32, align 4
  %scy.addr = alloca i32, align 4
  %cx.addr = alloca i32, align 4
  %cy.addr = alloca i32, align 4
  store ptr %vertices, ptr %vertices.addr, align 8
  store i32 %num_vertices, ptr %num_vertices.addr, align 4
  store i32 %was_off, ptr %was_off.addr, align 4
  store i32 %start_off, ptr %start_off.addr, align 4
  store i32 %sx, ptr %sx.addr, align 4
  store i32 %sy, ptr %sy.addr, align 4
  store i32 %scx, ptr %scx.addr, align 4
  store i32 %scy, ptr %scy.addr, align 4
  store i32 %cx, ptr %cx.addr, align 4
  store i32 %cy, ptr %cy.addr, align 4
  %0 = load i32, ptr %start_off.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %was_off.addr, align 4
  %tobool1 = icmp ne i32 %1, 0
  br i1 %tobool1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %2 = load ptr, ptr %vertices.addr, align 8
  %3 = load i32, ptr %num_vertices.addr, align 4
  %inc = add nsw i32 %3, 1
  store i32 %inc, ptr %num_vertices.addr, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds %struct.stbtt_vertex, ptr %2, i64 %idxprom
  %4 = load i32, ptr %cx.addr, align 4
  %5 = load i32, ptr %scx.addr, align 4
  %add = add nsw i32 %4, %5
  %shr = ashr i32 %add, 1
  %6 = load i32, ptr %cy.addr, align 4
  %7 = load i32, ptr %scy.addr, align 4
  %add3 = add nsw i32 %6, %7
  %shr4 = ashr i32 %add3, 1
  %8 = load i32, ptr %cx.addr, align 4
  %9 = load i32, ptr %cy.addr, align 4
  call void @_ZL15stbtt_setvertexP12stbtt_vertexhiiii(ptr noundef %arrayidx, i8 noundef zeroext 3, i32 noundef %shr, i32 noundef %shr4, i32 noundef %8, i32 noundef %9)
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %10 = load ptr, ptr %vertices.addr, align 8
  %11 = load i32, ptr %num_vertices.addr, align 4
  %inc5 = add nsw i32 %11, 1
  store i32 %inc5, ptr %num_vertices.addr, align 4
  %idxprom6 = sext i32 %11 to i64
  %arrayidx7 = getelementptr inbounds %struct.stbtt_vertex, ptr %10, i64 %idxprom6
  %12 = load i32, ptr %sx.addr, align 4
  %13 = load i32, ptr %sy.addr, align 4
  %14 = load i32, ptr %scx.addr, align 4
  %15 = load i32, ptr %scy.addr, align 4
  call void @_ZL15stbtt_setvertexP12stbtt_vertexhiiii(ptr noundef %arrayidx7, i8 noundef zeroext 3, i32 noundef %12, i32 noundef %13, i32 noundef %14, i32 noundef %15)
  br label %if.end18

if.else:                                          ; preds = %entry
  %16 = load i32, ptr %was_off.addr, align 4
  %tobool8 = icmp ne i32 %16, 0
  br i1 %tobool8, label %if.then9, label %if.else13

if.then9:                                         ; preds = %if.else
  %17 = load ptr, ptr %vertices.addr, align 8
  %18 = load i32, ptr %num_vertices.addr, align 4
  %inc10 = add nsw i32 %18, 1
  store i32 %inc10, ptr %num_vertices.addr, align 4
  %idxprom11 = sext i32 %18 to i64
  %arrayidx12 = getelementptr inbounds %struct.stbtt_vertex, ptr %17, i64 %idxprom11
  %19 = load i32, ptr %sx.addr, align 4
  %20 = load i32, ptr %sy.addr, align 4
  %21 = load i32, ptr %cx.addr, align 4
  %22 = load i32, ptr %cy.addr, align 4
  call void @_ZL15stbtt_setvertexP12stbtt_vertexhiiii(ptr noundef %arrayidx12, i8 noundef zeroext 3, i32 noundef %19, i32 noundef %20, i32 noundef %21, i32 noundef %22)
  br label %if.end17

if.else13:                                        ; preds = %if.else
  %23 = load ptr, ptr %vertices.addr, align 8
  %24 = load i32, ptr %num_vertices.addr, align 4
  %inc14 = add nsw i32 %24, 1
  store i32 %inc14, ptr %num_vertices.addr, align 4
  %idxprom15 = sext i32 %24 to i64
  %arrayidx16 = getelementptr inbounds %struct.stbtt_vertex, ptr %23, i64 %idxprom15
  %25 = load i32, ptr %sx.addr, align 4
  %26 = load i32, ptr %sy.addr, align 4
  call void @_ZL15stbtt_setvertexP12stbtt_vertexhiiii(ptr noundef %arrayidx16, i8 noundef zeroext 2, i32 noundef %25, i32 noundef %26, i32 noundef 0, i32 noundef 0)
  br label %if.end17

if.end17:                                         ; preds = %if.else13, %if.then9
  br label %if.end18

if.end18:                                         ; preds = %if.end17, %if.end
  %27 = load i32, ptr %num_vertices.addr, align 4
  ret i32 %27
}

; Function Attrs: mustprogress uwtable
define internal noundef ptr @_ZL19stbtt_FlattenCurvesP12stbtt_vertexifPPiS1_Pv(ptr noundef %vertices, i32 noundef %num_verts, float noundef %objspace_flatness, ptr noundef %contour_lengths, ptr noundef %num_contours, ptr noundef %userdata) #4 {
entry:
  %retval = alloca ptr, align 8
  %vertices.addr = alloca ptr, align 8
  %num_verts.addr = alloca i32, align 4
  %objspace_flatness.addr = alloca float, align 4
  %contour_lengths.addr = alloca ptr, align 8
  %num_contours.addr = alloca ptr, align 8
  %userdata.addr = alloca ptr, align 8
  %points = alloca ptr, align 8
  %num_points = alloca i32, align 4
  %objspace_flatness_squared = alloca float, align 4
  %i = alloca i32, align 4
  %n = alloca i32, align 4
  %start = alloca i32, align 4
  %pass = alloca i32, align 4
  %x = alloca float, align 4
  %y = alloca float, align 4
  store ptr %vertices, ptr %vertices.addr, align 8
  store i32 %num_verts, ptr %num_verts.addr, align 4
  store float %objspace_flatness, ptr %objspace_flatness.addr, align 4
  store ptr %contour_lengths, ptr %contour_lengths.addr, align 8
  store ptr %num_contours, ptr %num_contours.addr, align 8
  store ptr %userdata, ptr %userdata.addr, align 8
  store ptr null, ptr %points, align 8
  store i32 0, ptr %num_points, align 4
  %0 = load float, ptr %objspace_flatness.addr, align 4
  %1 = load float, ptr %objspace_flatness.addr, align 4
  %mul = fmul float %0, %1
  store float %mul, ptr %objspace_flatness_squared, align 4
  store i32 0, ptr %n, align 4
  store i32 0, ptr %start, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, ptr %i, align 4
  %3 = load i32, ptr %num_verts.addr, align 4
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %vertices.addr, align 8
  %5 = load i32, ptr %i, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds %struct.stbtt_vertex, ptr %4, i64 %idxprom
  %type = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx, i32 0, i32 6
  %6 = load i8, ptr %type, align 2
  %conv = zext i8 %6 to i32
  %cmp1 = icmp eq i32 %conv, 1
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %7 = load i32, ptr %n, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %n, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i32, ptr %i, align 4
  %inc2 = add nsw i32 %8, 1
  store i32 %inc2, ptr %i, align 4
  br label %for.cond, !llvm.loop !143

for.end:                                          ; preds = %for.cond
  %9 = load i32, ptr %n, align 4
  %10 = load ptr, ptr %num_contours.addr, align 8
  store i32 %9, ptr %10, align 4
  %11 = load i32, ptr %n, align 4
  %cmp3 = icmp eq i32 %11, 0
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %for.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %for.end
  %12 = load i32, ptr %n, align 4
  %conv6 = sext i32 %12 to i64
  %mul7 = mul i64 4, %conv6
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul7)
  %13 = load ptr, ptr %contour_lengths.addr, align 8
  store ptr %call, ptr %13, align 8
  %14 = load ptr, ptr %contour_lengths.addr, align 8
  %15 = load ptr, ptr %14, align 8
  %cmp8 = icmp eq ptr %15, null
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end5
  %16 = load ptr, ptr %num_contours.addr, align 8
  store i32 0, ptr %16, align 4
  store ptr null, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %if.end5
  store i32 0, ptr %pass, align 4
  br label %for.cond11

for.cond11:                                       ; preds = %for.inc116, %if.end10
  %17 = load i32, ptr %pass, align 4
  %cmp12 = icmp slt i32 %17, 2
  br i1 %cmp12, label %for.body13, label %for.end118

for.body13:                                       ; preds = %for.cond11
  store float 0.000000e+00, ptr %x, align 4
  store float 0.000000e+00, ptr %y, align 4
  %18 = load i32, ptr %pass, align 4
  %cmp14 = icmp eq i32 %18, 1
  br i1 %cmp14, label %if.then15, label %if.end22

if.then15:                                        ; preds = %for.body13
  %19 = load i32, ptr %num_points, align 4
  %conv16 = sext i32 %19 to i64
  %mul17 = mul i64 %conv16, 8
  %call18 = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul17)
  store ptr %call18, ptr %points, align 8
  %20 = load ptr, ptr %points, align 8
  %cmp19 = icmp eq ptr %20, null
  br i1 %cmp19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.then15
  br label %error

if.end21:                                         ; preds = %if.then15
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %for.body13
  store i32 0, ptr %num_points, align 4
  store i32 -1, ptr %n, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc110, %if.end22
  %21 = load i32, ptr %i, align 4
  %22 = load i32, ptr %num_verts.addr, align 4
  %cmp24 = icmp slt i32 %21, %22
  br i1 %cmp24, label %for.body25, label %for.end112

for.body25:                                       ; preds = %for.cond23
  %23 = load ptr, ptr %vertices.addr, align 8
  %24 = load i32, ptr %i, align 4
  %idxprom26 = sext i32 %24 to i64
  %arrayidx27 = getelementptr inbounds %struct.stbtt_vertex, ptr %23, i64 %idxprom26
  %type28 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx27, i32 0, i32 6
  %25 = load i8, ptr %type28, align 2
  %conv29 = zext i8 %25 to i32
  switch i32 %conv29, label %sw.epilog [
    i32 1, label %sw.bb
    i32 2, label %sw.bb45
    i32 3, label %sw.bb55
    i32 4, label %sw.bb79
  ]

sw.bb:                                            ; preds = %for.body25
  %26 = load i32, ptr %n, align 4
  %cmp30 = icmp sge i32 %26, 0
  br i1 %cmp30, label %if.then31, label %if.end34

if.then31:                                        ; preds = %sw.bb
  %27 = load i32, ptr %num_points, align 4
  %28 = load i32, ptr %start, align 4
  %sub = sub nsw i32 %27, %28
  %29 = load ptr, ptr %contour_lengths.addr, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = load i32, ptr %n, align 4
  %idxprom32 = sext i32 %31 to i64
  %arrayidx33 = getelementptr inbounds i32, ptr %30, i64 %idxprom32
  store i32 %sub, ptr %arrayidx33, align 4
  br label %if.end34

if.end34:                                         ; preds = %if.then31, %sw.bb
  %32 = load i32, ptr %n, align 4
  %inc35 = add nsw i32 %32, 1
  store i32 %inc35, ptr %n, align 4
  %33 = load i32, ptr %num_points, align 4
  store i32 %33, ptr %start, align 4
  %34 = load ptr, ptr %vertices.addr, align 8
  %35 = load i32, ptr %i, align 4
  %idxprom36 = sext i32 %35 to i64
  %arrayidx37 = getelementptr inbounds %struct.stbtt_vertex, ptr %34, i64 %idxprom36
  %x38 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx37, i32 0, i32 0
  %36 = load i16, ptr %x38, align 2
  %conv39 = sitofp i16 %36 to float
  store float %conv39, ptr %x, align 4
  %37 = load ptr, ptr %vertices.addr, align 8
  %38 = load i32, ptr %i, align 4
  %idxprom40 = sext i32 %38 to i64
  %arrayidx41 = getelementptr inbounds %struct.stbtt_vertex, ptr %37, i64 %idxprom40
  %y42 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx41, i32 0, i32 1
  %39 = load i16, ptr %y42, align 2
  %conv43 = sitofp i16 %39 to float
  store float %conv43, ptr %y, align 4
  %40 = load ptr, ptr %points, align 8
  %41 = load i32, ptr %num_points, align 4
  %inc44 = add nsw i32 %41, 1
  store i32 %inc44, ptr %num_points, align 4
  %42 = load float, ptr %x, align 4
  %43 = load float, ptr %y, align 4
  call void @_ZL16stbtt__add_pointP12stbtt__pointiff(ptr noundef %40, i32 noundef %41, float noundef %42, float noundef %43)
  br label %sw.epilog

sw.bb45:                                          ; preds = %for.body25
  %44 = load ptr, ptr %vertices.addr, align 8
  %45 = load i32, ptr %i, align 4
  %idxprom46 = sext i32 %45 to i64
  %arrayidx47 = getelementptr inbounds %struct.stbtt_vertex, ptr %44, i64 %idxprom46
  %x48 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx47, i32 0, i32 0
  %46 = load i16, ptr %x48, align 2
  %conv49 = sitofp i16 %46 to float
  store float %conv49, ptr %x, align 4
  %47 = load ptr, ptr %vertices.addr, align 8
  %48 = load i32, ptr %i, align 4
  %idxprom50 = sext i32 %48 to i64
  %arrayidx51 = getelementptr inbounds %struct.stbtt_vertex, ptr %47, i64 %idxprom50
  %y52 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx51, i32 0, i32 1
  %49 = load i16, ptr %y52, align 2
  %conv53 = sitofp i16 %49 to float
  store float %conv53, ptr %y, align 4
  %50 = load ptr, ptr %points, align 8
  %51 = load i32, ptr %num_points, align 4
  %inc54 = add nsw i32 %51, 1
  store i32 %inc54, ptr %num_points, align 4
  %52 = load float, ptr %x, align 4
  %53 = load float, ptr %y, align 4
  call void @_ZL16stbtt__add_pointP12stbtt__pointiff(ptr noundef %50, i32 noundef %51, float noundef %52, float noundef %53)
  br label %sw.epilog

sw.bb55:                                          ; preds = %for.body25
  %54 = load ptr, ptr %points, align 8
  %55 = load float, ptr %x, align 4
  %56 = load float, ptr %y, align 4
  %57 = load ptr, ptr %vertices.addr, align 8
  %58 = load i32, ptr %i, align 4
  %idxprom56 = sext i32 %58 to i64
  %arrayidx57 = getelementptr inbounds %struct.stbtt_vertex, ptr %57, i64 %idxprom56
  %cx = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx57, i32 0, i32 2
  %59 = load i16, ptr %cx, align 2
  %conv58 = sitofp i16 %59 to float
  %60 = load ptr, ptr %vertices.addr, align 8
  %61 = load i32, ptr %i, align 4
  %idxprom59 = sext i32 %61 to i64
  %arrayidx60 = getelementptr inbounds %struct.stbtt_vertex, ptr %60, i64 %idxprom59
  %cy = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx60, i32 0, i32 3
  %62 = load i16, ptr %cy, align 2
  %conv61 = sitofp i16 %62 to float
  %63 = load ptr, ptr %vertices.addr, align 8
  %64 = load i32, ptr %i, align 4
  %idxprom62 = sext i32 %64 to i64
  %arrayidx63 = getelementptr inbounds %struct.stbtt_vertex, ptr %63, i64 %idxprom62
  %x64 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx63, i32 0, i32 0
  %65 = load i16, ptr %x64, align 2
  %conv65 = sitofp i16 %65 to float
  %66 = load ptr, ptr %vertices.addr, align 8
  %67 = load i32, ptr %i, align 4
  %idxprom66 = sext i32 %67 to i64
  %arrayidx67 = getelementptr inbounds %struct.stbtt_vertex, ptr %66, i64 %idxprom66
  %y68 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx67, i32 0, i32 1
  %68 = load i16, ptr %y68, align 2
  %conv69 = sitofp i16 %68 to float
  %69 = load float, ptr %objspace_flatness_squared, align 4
  %call70 = call noundef i32 @_ZL22stbtt__tesselate_curveP12stbtt__pointPifffffffi(ptr noundef %54, ptr noundef %num_points, float noundef %55, float noundef %56, float noundef %conv58, float noundef %conv61, float noundef %conv65, float noundef %conv69, float noundef %69, i32 noundef 0)
  %70 = load ptr, ptr %vertices.addr, align 8
  %71 = load i32, ptr %i, align 4
  %idxprom71 = sext i32 %71 to i64
  %arrayidx72 = getelementptr inbounds %struct.stbtt_vertex, ptr %70, i64 %idxprom71
  %x73 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx72, i32 0, i32 0
  %72 = load i16, ptr %x73, align 2
  %conv74 = sitofp i16 %72 to float
  store float %conv74, ptr %x, align 4
  %73 = load ptr, ptr %vertices.addr, align 8
  %74 = load i32, ptr %i, align 4
  %idxprom75 = sext i32 %74 to i64
  %arrayidx76 = getelementptr inbounds %struct.stbtt_vertex, ptr %73, i64 %idxprom75
  %y77 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx76, i32 0, i32 1
  %75 = load i16, ptr %y77, align 2
  %conv78 = sitofp i16 %75 to float
  store float %conv78, ptr %y, align 4
  br label %sw.epilog

sw.bb79:                                          ; preds = %for.body25
  %76 = load ptr, ptr %points, align 8
  %77 = load float, ptr %x, align 4
  %78 = load float, ptr %y, align 4
  %79 = load ptr, ptr %vertices.addr, align 8
  %80 = load i32, ptr %i, align 4
  %idxprom80 = sext i32 %80 to i64
  %arrayidx81 = getelementptr inbounds %struct.stbtt_vertex, ptr %79, i64 %idxprom80
  %cx82 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx81, i32 0, i32 2
  %81 = load i16, ptr %cx82, align 2
  %conv83 = sitofp i16 %81 to float
  %82 = load ptr, ptr %vertices.addr, align 8
  %83 = load i32, ptr %i, align 4
  %idxprom84 = sext i32 %83 to i64
  %arrayidx85 = getelementptr inbounds %struct.stbtt_vertex, ptr %82, i64 %idxprom84
  %cy86 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx85, i32 0, i32 3
  %84 = load i16, ptr %cy86, align 2
  %conv87 = sitofp i16 %84 to float
  %85 = load ptr, ptr %vertices.addr, align 8
  %86 = load i32, ptr %i, align 4
  %idxprom88 = sext i32 %86 to i64
  %arrayidx89 = getelementptr inbounds %struct.stbtt_vertex, ptr %85, i64 %idxprom88
  %cx1 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx89, i32 0, i32 4
  %87 = load i16, ptr %cx1, align 2
  %conv90 = sitofp i16 %87 to float
  %88 = load ptr, ptr %vertices.addr, align 8
  %89 = load i32, ptr %i, align 4
  %idxprom91 = sext i32 %89 to i64
  %arrayidx92 = getelementptr inbounds %struct.stbtt_vertex, ptr %88, i64 %idxprom91
  %cy1 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx92, i32 0, i32 5
  %90 = load i16, ptr %cy1, align 2
  %conv93 = sitofp i16 %90 to float
  %91 = load ptr, ptr %vertices.addr, align 8
  %92 = load i32, ptr %i, align 4
  %idxprom94 = sext i32 %92 to i64
  %arrayidx95 = getelementptr inbounds %struct.stbtt_vertex, ptr %91, i64 %idxprom94
  %x96 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx95, i32 0, i32 0
  %93 = load i16, ptr %x96, align 2
  %conv97 = sitofp i16 %93 to float
  %94 = load ptr, ptr %vertices.addr, align 8
  %95 = load i32, ptr %i, align 4
  %idxprom98 = sext i32 %95 to i64
  %arrayidx99 = getelementptr inbounds %struct.stbtt_vertex, ptr %94, i64 %idxprom98
  %y100 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx99, i32 0, i32 1
  %96 = load i16, ptr %y100, align 2
  %conv101 = sitofp i16 %96 to float
  %97 = load float, ptr %objspace_flatness_squared, align 4
  call void @_ZL22stbtt__tesselate_cubicP12stbtt__pointPifffffffffi(ptr noundef %76, ptr noundef %num_points, float noundef %77, float noundef %78, float noundef %conv83, float noundef %conv87, float noundef %conv90, float noundef %conv93, float noundef %conv97, float noundef %conv101, float noundef %97, i32 noundef 0)
  %98 = load ptr, ptr %vertices.addr, align 8
  %99 = load i32, ptr %i, align 4
  %idxprom102 = sext i32 %99 to i64
  %arrayidx103 = getelementptr inbounds %struct.stbtt_vertex, ptr %98, i64 %idxprom102
  %x104 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx103, i32 0, i32 0
  %100 = load i16, ptr %x104, align 2
  %conv105 = sitofp i16 %100 to float
  store float %conv105, ptr %x, align 4
  %101 = load ptr, ptr %vertices.addr, align 8
  %102 = load i32, ptr %i, align 4
  %idxprom106 = sext i32 %102 to i64
  %arrayidx107 = getelementptr inbounds %struct.stbtt_vertex, ptr %101, i64 %idxprom106
  %y108 = getelementptr inbounds %struct.stbtt_vertex, ptr %arrayidx107, i32 0, i32 1
  %103 = load i16, ptr %y108, align 2
  %conv109 = sitofp i16 %103 to float
  store float %conv109, ptr %y, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb79, %sw.bb55, %sw.bb45, %if.end34, %for.body25
  br label %for.inc110

for.inc110:                                       ; preds = %sw.epilog
  %104 = load i32, ptr %i, align 4
  %inc111 = add nsw i32 %104, 1
  store i32 %inc111, ptr %i, align 4
  br label %for.cond23, !llvm.loop !144

for.end112:                                       ; preds = %for.cond23
  %105 = load i32, ptr %num_points, align 4
  %106 = load i32, ptr %start, align 4
  %sub113 = sub nsw i32 %105, %106
  %107 = load ptr, ptr %contour_lengths.addr, align 8
  %108 = load ptr, ptr %107, align 8
  %109 = load i32, ptr %n, align 4
  %idxprom114 = sext i32 %109 to i64
  %arrayidx115 = getelementptr inbounds i32, ptr %108, i64 %idxprom114
  store i32 %sub113, ptr %arrayidx115, align 4
  br label %for.inc116

for.inc116:                                       ; preds = %for.end112
  %110 = load i32, ptr %pass, align 4
  %inc117 = add nsw i32 %110, 1
  store i32 %inc117, ptr %pass, align 4
  br label %for.cond11, !llvm.loop !145

for.end118:                                       ; preds = %for.cond11
  %111 = load ptr, ptr %points, align 8
  store ptr %111, ptr %retval, align 8
  br label %return

error:                                            ; preds = %if.then20
  %112 = load ptr, ptr %points, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %112)
  %113 = load ptr, ptr %contour_lengths.addr, align 8
  %114 = load ptr, ptr %113, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %114)
  %115 = load ptr, ptr %contour_lengths.addr, align 8
  store ptr null, ptr %115, align 8
  %116 = load ptr, ptr %num_contours.addr, align 8
  store i32 0, ptr %116, align 4
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %error, %for.end118, %if.then9, %if.then4
  %117 = load ptr, ptr %retval, align 8
  ret ptr %117
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL16stbtt__rasterizeP13stbtt__bitmapP12stbtt__pointPiiffffiiiPv(ptr noundef %result, ptr noundef %pts, ptr noundef %wcount, i32 noundef %windings, float noundef %scale_x, float noundef %scale_y, float noundef %shift_x, float noundef %shift_y, i32 noundef %off_x, i32 noundef %off_y, i32 noundef %invert, ptr noundef %userdata) #4 {
entry:
  %result.addr = alloca ptr, align 8
  %pts.addr = alloca ptr, align 8
  %wcount.addr = alloca ptr, align 8
  %windings.addr = alloca i32, align 4
  %scale_x.addr = alloca float, align 4
  %scale_y.addr = alloca float, align 4
  %shift_x.addr = alloca float, align 4
  %shift_y.addr = alloca float, align 4
  %off_x.addr = alloca i32, align 4
  %off_y.addr = alloca i32, align 4
  %invert.addr = alloca i32, align 4
  %userdata.addr = alloca ptr, align 8
  %y_scale_inv = alloca float, align 4
  %e = alloca ptr, align 8
  %n = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %k = alloca i32, align 4
  %m = alloca i32, align 4
  %vsubsample = alloca i32, align 4
  %p = alloca ptr, align 8
  %a = alloca i32, align 4
  %b = alloca i32, align 4
  store ptr %result, ptr %result.addr, align 8
  store ptr %pts, ptr %pts.addr, align 8
  store ptr %wcount, ptr %wcount.addr, align 8
  store i32 %windings, ptr %windings.addr, align 4
  store float %scale_x, ptr %scale_x.addr, align 4
  store float %scale_y, ptr %scale_y.addr, align 4
  store float %shift_x, ptr %shift_x.addr, align 4
  store float %shift_y, ptr %shift_y.addr, align 4
  store i32 %off_x, ptr %off_x.addr, align 4
  store i32 %off_y, ptr %off_y.addr, align 4
  store i32 %invert, ptr %invert.addr, align 4
  store ptr %userdata, ptr %userdata.addr, align 8
  %0 = load i32, ptr %invert.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load float, ptr %scale_y.addr, align 4
  %fneg = fneg float %1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load float, ptr %scale_y.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %fneg, %cond.true ], [ %2, %cond.false ]
  store float %cond, ptr %y_scale_inv, align 4
  store i32 1, ptr %vsubsample, align 4
  store i32 0, ptr %n, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %3 = load i32, ptr %i, align 4
  %4 = load i32, ptr %windings.addr, align 4
  %cmp = icmp slt i32 %3, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %wcount.addr, align 8
  %6 = load i32, ptr %i, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr inbounds i32, ptr %5, i64 %idxprom
  %7 = load i32, ptr %arrayidx, align 4
  %8 = load i32, ptr %n, align 4
  %add = add nsw i32 %8, %7
  store i32 %add, ptr %n, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load i32, ptr %i, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !146

for.end:                                          ; preds = %for.cond
  %10 = load i32, ptr %n, align 4
  %add1 = add nsw i32 %10, 1
  %conv = sext i32 %add1 to i64
  %mul = mul i64 20, %conv
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %e, align 8
  %11 = load ptr, ptr %e, align 8
  %cmp2 = icmp eq ptr %11, null
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  br label %return

if.end:                                           ; preds = %for.end
  store i32 0, ptr %n, align 4
  store i32 0, ptr %m, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond3

for.cond3:                                        ; preds = %for.inc80, %if.end
  %12 = load i32, ptr %i, align 4
  %13 = load i32, ptr %windings.addr, align 4
  %cmp4 = icmp slt i32 %12, %13
  br i1 %cmp4, label %for.body5, label %for.end82

for.body5:                                        ; preds = %for.cond3
  %14 = load ptr, ptr %pts.addr, align 8
  %15 = load i32, ptr %m, align 4
  %idx.ext = sext i32 %15 to i64
  %add.ptr = getelementptr inbounds %struct.stbtt__point, ptr %14, i64 %idx.ext
  store ptr %add.ptr, ptr %p, align 8
  %16 = load ptr, ptr %wcount.addr, align 8
  %17 = load i32, ptr %i, align 4
  %idxprom6 = sext i32 %17 to i64
  %arrayidx7 = getelementptr inbounds i32, ptr %16, i64 %idxprom6
  %18 = load i32, ptr %arrayidx7, align 4
  %19 = load i32, ptr %m, align 4
  %add8 = add nsw i32 %19, %18
  store i32 %add8, ptr %m, align 4
  %20 = load ptr, ptr %wcount.addr, align 8
  %21 = load i32, ptr %i, align 4
  %idxprom9 = sext i32 %21 to i64
  %arrayidx10 = getelementptr inbounds i32, ptr %20, i64 %idxprom9
  %22 = load i32, ptr %arrayidx10, align 4
  %sub = sub nsw i32 %22, 1
  store i32 %sub, ptr %j, align 4
  store i32 0, ptr %k, align 4
  br label %for.cond11

for.cond11:                                       ; preds = %for.inc77, %for.body5
  %23 = load i32, ptr %k, align 4
  %24 = load ptr, ptr %wcount.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idxprom12 = sext i32 %25 to i64
  %arrayidx13 = getelementptr inbounds i32, ptr %24, i64 %idxprom12
  %26 = load i32, ptr %arrayidx13, align 4
  %cmp14 = icmp slt i32 %23, %26
  br i1 %cmp14, label %for.body15, label %for.end79

for.body15:                                       ; preds = %for.cond11
  %27 = load i32, ptr %k, align 4
  store i32 %27, ptr %a, align 4
  %28 = load i32, ptr %j, align 4
  store i32 %28, ptr %b, align 4
  %29 = load ptr, ptr %p, align 8
  %30 = load i32, ptr %j, align 4
  %idxprom16 = sext i32 %30 to i64
  %arrayidx17 = getelementptr inbounds %struct.stbtt__point, ptr %29, i64 %idxprom16
  %y = getelementptr inbounds %struct.stbtt__point, ptr %arrayidx17, i32 0, i32 1
  %31 = load float, ptr %y, align 4
  %32 = load ptr, ptr %p, align 8
  %33 = load i32, ptr %k, align 4
  %idxprom18 = sext i32 %33 to i64
  %arrayidx19 = getelementptr inbounds %struct.stbtt__point, ptr %32, i64 %idxprom18
  %y20 = getelementptr inbounds %struct.stbtt__point, ptr %arrayidx19, i32 0, i32 1
  %34 = load float, ptr %y20, align 4
  %cmp21 = fcmp oeq float %31, %34
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %for.body15
  br label %for.inc77

if.end23:                                         ; preds = %for.body15
  %35 = load ptr, ptr %e, align 8
  %36 = load i32, ptr %n, align 4
  %idxprom24 = sext i32 %36 to i64
  %arrayidx25 = getelementptr inbounds %struct.stbtt__edge, ptr %35, i64 %idxprom24
  %invert26 = getelementptr inbounds %struct.stbtt__edge, ptr %arrayidx25, i32 0, i32 4
  store i32 0, ptr %invert26, align 4
  %37 = load i32, ptr %invert.addr, align 4
  %tobool27 = icmp ne i32 %37, 0
  br i1 %tobool27, label %cond.true28, label %cond.false36

cond.true28:                                      ; preds = %if.end23
  %38 = load ptr, ptr %p, align 8
  %39 = load i32, ptr %j, align 4
  %idxprom29 = sext i32 %39 to i64
  %arrayidx30 = getelementptr inbounds %struct.stbtt__point, ptr %38, i64 %idxprom29
  %y31 = getelementptr inbounds %struct.stbtt__point, ptr %arrayidx30, i32 0, i32 1
  %40 = load float, ptr %y31, align 4
  %41 = load ptr, ptr %p, align 8
  %42 = load i32, ptr %k, align 4
  %idxprom32 = sext i32 %42 to i64
  %arrayidx33 = getelementptr inbounds %struct.stbtt__point, ptr %41, i64 %idxprom32
  %y34 = getelementptr inbounds %struct.stbtt__point, ptr %arrayidx33, i32 0, i32 1
  %43 = load float, ptr %y34, align 4
  %cmp35 = fcmp ogt float %40, %43
  br i1 %cmp35, label %if.then44, label %if.end48

cond.false36:                                     ; preds = %if.end23
  %44 = load ptr, ptr %p, align 8
  %45 = load i32, ptr %j, align 4
  %idxprom37 = sext i32 %45 to i64
  %arrayidx38 = getelementptr inbounds %struct.stbtt__point, ptr %44, i64 %idxprom37
  %y39 = getelementptr inbounds %struct.stbtt__point, ptr %arrayidx38, i32 0, i32 1
  %46 = load float, ptr %y39, align 4
  %47 = load ptr, ptr %p, align 8
  %48 = load i32, ptr %k, align 4
  %idxprom40 = sext i32 %48 to i64
  %arrayidx41 = getelementptr inbounds %struct.stbtt__point, ptr %47, i64 %idxprom40
  %y42 = getelementptr inbounds %struct.stbtt__point, ptr %arrayidx41, i32 0, i32 1
  %49 = load float, ptr %y42, align 4
  %cmp43 = fcmp olt float %46, %49
  br i1 %cmp43, label %if.then44, label %if.end48

if.then44:                                        ; preds = %cond.false36, %cond.true28
  %50 = load ptr, ptr %e, align 8
  %51 = load i32, ptr %n, align 4
  %idxprom45 = sext i32 %51 to i64
  %arrayidx46 = getelementptr inbounds %struct.stbtt__edge, ptr %50, i64 %idxprom45
  %invert47 = getelementptr inbounds %struct.stbtt__edge, ptr %arrayidx46, i32 0, i32 4
  store i32 1, ptr %invert47, align 4
  %52 = load i32, ptr %j, align 4
  store i32 %52, ptr %a, align 4
  %53 = load i32, ptr %k, align 4
  store i32 %53, ptr %b, align 4
  br label %if.end48

if.end48:                                         ; preds = %if.then44, %cond.false36, %cond.true28
  %54 = load ptr, ptr %p, align 8
  %55 = load i32, ptr %a, align 4
  %idxprom49 = sext i32 %55 to i64
  %arrayidx50 = getelementptr inbounds %struct.stbtt__point, ptr %54, i64 %idxprom49
  %x = getelementptr inbounds %struct.stbtt__point, ptr %arrayidx50, i32 0, i32 0
  %56 = load float, ptr %x, align 4
  %57 = load float, ptr %scale_x.addr, align 4
  %58 = load float, ptr %shift_x.addr, align 4
  %59 = call float @llvm.fmuladd.f32(float %56, float %57, float %58)
  %60 = load ptr, ptr %e, align 8
  %61 = load i32, ptr %n, align 4
  %idxprom52 = sext i32 %61 to i64
  %arrayidx53 = getelementptr inbounds %struct.stbtt__edge, ptr %60, i64 %idxprom52
  %x0 = getelementptr inbounds %struct.stbtt__edge, ptr %arrayidx53, i32 0, i32 0
  store float %59, ptr %x0, align 4
  %62 = load ptr, ptr %p, align 8
  %63 = load i32, ptr %a, align 4
  %idxprom54 = sext i32 %63 to i64
  %arrayidx55 = getelementptr inbounds %struct.stbtt__point, ptr %62, i64 %idxprom54
  %y56 = getelementptr inbounds %struct.stbtt__point, ptr %arrayidx55, i32 0, i32 1
  %64 = load float, ptr %y56, align 4
  %65 = load float, ptr %y_scale_inv, align 4
  %66 = load float, ptr %shift_y.addr, align 4
  %67 = call float @llvm.fmuladd.f32(float %64, float %65, float %66)
  %68 = load i32, ptr %vsubsample, align 4
  %conv58 = sitofp i32 %68 to float
  %mul59 = fmul float %67, %conv58
  %69 = load ptr, ptr %e, align 8
  %70 = load i32, ptr %n, align 4
  %idxprom60 = sext i32 %70 to i64
  %arrayidx61 = getelementptr inbounds %struct.stbtt__edge, ptr %69, i64 %idxprom60
  %y0 = getelementptr inbounds %struct.stbtt__edge, ptr %arrayidx61, i32 0, i32 1
  store float %mul59, ptr %y0, align 4
  %71 = load ptr, ptr %p, align 8
  %72 = load i32, ptr %b, align 4
  %idxprom62 = sext i32 %72 to i64
  %arrayidx63 = getelementptr inbounds %struct.stbtt__point, ptr %71, i64 %idxprom62
  %x64 = getelementptr inbounds %struct.stbtt__point, ptr %arrayidx63, i32 0, i32 0
  %73 = load float, ptr %x64, align 4
  %74 = load float, ptr %scale_x.addr, align 4
  %75 = load float, ptr %shift_x.addr, align 4
  %76 = call float @llvm.fmuladd.f32(float %73, float %74, float %75)
  %77 = load ptr, ptr %e, align 8
  %78 = load i32, ptr %n, align 4
  %idxprom66 = sext i32 %78 to i64
  %arrayidx67 = getelementptr inbounds %struct.stbtt__edge, ptr %77, i64 %idxprom66
  %x1 = getelementptr inbounds %struct.stbtt__edge, ptr %arrayidx67, i32 0, i32 2
  store float %76, ptr %x1, align 4
  %79 = load ptr, ptr %p, align 8
  %80 = load i32, ptr %b, align 4
  %idxprom68 = sext i32 %80 to i64
  %arrayidx69 = getelementptr inbounds %struct.stbtt__point, ptr %79, i64 %idxprom68
  %y70 = getelementptr inbounds %struct.stbtt__point, ptr %arrayidx69, i32 0, i32 1
  %81 = load float, ptr %y70, align 4
  %82 = load float, ptr %y_scale_inv, align 4
  %83 = load float, ptr %shift_y.addr, align 4
  %84 = call float @llvm.fmuladd.f32(float %81, float %82, float %83)
  %85 = load i32, ptr %vsubsample, align 4
  %conv72 = sitofp i32 %85 to float
  %mul73 = fmul float %84, %conv72
  %86 = load ptr, ptr %e, align 8
  %87 = load i32, ptr %n, align 4
  %idxprom74 = sext i32 %87 to i64
  %arrayidx75 = getelementptr inbounds %struct.stbtt__edge, ptr %86, i64 %idxprom74
  %y1 = getelementptr inbounds %struct.stbtt__edge, ptr %arrayidx75, i32 0, i32 3
  store float %mul73, ptr %y1, align 4
  %88 = load i32, ptr %n, align 4
  %inc76 = add nsw i32 %88, 1
  store i32 %inc76, ptr %n, align 4
  br label %for.inc77

for.inc77:                                        ; preds = %if.end48, %if.then22
  %89 = load i32, ptr %k, align 4
  %inc78 = add nsw i32 %89, 1
  store i32 %inc78, ptr %k, align 4
  store i32 %89, ptr %j, align 4
  br label %for.cond11, !llvm.loop !147

for.end79:                                        ; preds = %for.cond11
  br label %for.inc80

for.inc80:                                        ; preds = %for.end79
  %90 = load i32, ptr %i, align 4
  %inc81 = add nsw i32 %90, 1
  store i32 %inc81, ptr %i, align 4
  br label %for.cond3, !llvm.loop !148

for.end82:                                        ; preds = %for.cond3
  %91 = load ptr, ptr %e, align 8
  %92 = load i32, ptr %n, align 4
  call void @_ZL17stbtt__sort_edgesP11stbtt__edgei(ptr noundef %91, i32 noundef %92)
  %93 = load ptr, ptr %result.addr, align 8
  %94 = load ptr, ptr %e, align 8
  %95 = load i32, ptr %n, align 4
  %96 = load i32, ptr %vsubsample, align 4
  %97 = load i32, ptr %off_x.addr, align 4
  %98 = load i32, ptr %off_y.addr, align 4
  %99 = load ptr, ptr %userdata.addr, align 8
  call void @_ZL29stbtt__rasterize_sorted_edgesP13stbtt__bitmapP11stbtt__edgeiiiiPv(ptr noundef %93, ptr noundef %94, i32 noundef %95, i32 noundef %96, i32 noundef %97, i32 noundef %98, ptr noundef %99)
  %100 = load ptr, ptr %e, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %100)
  br label %return

return:                                           ; preds = %for.end82, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZL16stbtt__add_pointP12stbtt__pointiff(ptr noundef %points, i32 noundef %n, float noundef %x, float noundef %y) #2 {
entry:
  %points.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %x.addr = alloca float, align 4
  %y.addr = alloca float, align 4
  store ptr %points, ptr %points.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  store float %x, ptr %x.addr, align 4
  store float %y, ptr %y.addr, align 4
  %0 = load ptr, ptr %points.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load float, ptr %x.addr, align 4
  %2 = load ptr, ptr %points.addr, align 8
  %3 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds %struct.stbtt__point, ptr %2, i64 %idxprom
  %x1 = getelementptr inbounds %struct.stbtt__point, ptr %arrayidx, i32 0, i32 0
  store float %1, ptr %x1, align 4
  %4 = load float, ptr %y.addr, align 4
  %5 = load ptr, ptr %points.addr, align 8
  %6 = load i32, ptr %n.addr, align 4
  %idxprom2 = sext i32 %6 to i64
  %arrayidx3 = getelementptr inbounds %struct.stbtt__point, ptr %5, i64 %idxprom2
  %y4 = getelementptr inbounds %struct.stbtt__point, ptr %arrayidx3, i32 0, i32 1
  store float %4, ptr %y4, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define internal noundef i32 @_ZL22stbtt__tesselate_curveP12stbtt__pointPifffffffi(ptr noundef %points, ptr noundef %num_points, float noundef %x0, float noundef %y0, float noundef %x1, float noundef %y1, float noundef %x2, float noundef %y2, float noundef %objspace_flatness_squared, i32 noundef %n) #4 {
entry:
  %retval = alloca i32, align 4
  %points.addr = alloca ptr, align 8
  %num_points.addr = alloca ptr, align 8
  %x0.addr = alloca float, align 4
  %y0.addr = alloca float, align 4
  %x1.addr = alloca float, align 4
  %y1.addr = alloca float, align 4
  %x2.addr = alloca float, align 4
  %y2.addr = alloca float, align 4
  %objspace_flatness_squared.addr = alloca float, align 4
  %n.addr = alloca i32, align 4
  %mx = alloca float, align 4
  %my = alloca float, align 4
  %dx = alloca float, align 4
  %dy = alloca float, align 4
  store ptr %points, ptr %points.addr, align 8
  store ptr %num_points, ptr %num_points.addr, align 8
  store float %x0, ptr %x0.addr, align 4
  store float %y0, ptr %y0.addr, align 4
  store float %x1, ptr %x1.addr, align 4
  store float %y1, ptr %y1.addr, align 4
  store float %x2, ptr %x2.addr, align 4
  store float %y2, ptr %y2.addr, align 4
  store float %objspace_flatness_squared, ptr %objspace_flatness_squared.addr, align 4
  store i32 %n, ptr %n.addr, align 4
  %0 = load float, ptr %x0.addr, align 4
  %1 = load float, ptr %x1.addr, align 4
  %2 = call float @llvm.fmuladd.f32(float 2.000000e+00, float %1, float %0)
  %3 = load float, ptr %x2.addr, align 4
  %add = fadd float %2, %3
  %div = fdiv float %add, 4.000000e+00
  store float %div, ptr %mx, align 4
  %4 = load float, ptr %y0.addr, align 4
  %5 = load float, ptr %y1.addr, align 4
  %6 = call float @llvm.fmuladd.f32(float 2.000000e+00, float %5, float %4)
  %7 = load float, ptr %y2.addr, align 4
  %add1 = fadd float %6, %7
  %div2 = fdiv float %add1, 4.000000e+00
  store float %div2, ptr %my, align 4
  %8 = load float, ptr %x0.addr, align 4
  %9 = load float, ptr %x2.addr, align 4
  %add3 = fadd float %8, %9
  %div4 = fdiv float %add3, 2.000000e+00
  %10 = load float, ptr %mx, align 4
  %sub = fsub float %div4, %10
  store float %sub, ptr %dx, align 4
  %11 = load float, ptr %y0.addr, align 4
  %12 = load float, ptr %y2.addr, align 4
  %add5 = fadd float %11, %12
  %div6 = fdiv float %add5, 2.000000e+00
  %13 = load float, ptr %my, align 4
  %sub7 = fsub float %div6, %13
  store float %sub7, ptr %dy, align 4
  %14 = load i32, ptr %n.addr, align 4
  %cmp = icmp sgt i32 %14, 16
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %15 = load float, ptr %dx, align 4
  %16 = load float, ptr %dx, align 4
  %17 = load float, ptr %dy, align 4
  %18 = load float, ptr %dy, align 4
  %mul8 = fmul float %17, %18
  %19 = call float @llvm.fmuladd.f32(float %15, float %16, float %mul8)
  %20 = load float, ptr %objspace_flatness_squared.addr, align 4
  %cmp9 = fcmp ogt float %19, %20
  br i1 %cmp9, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.end
  %21 = load ptr, ptr %points.addr, align 8
  %22 = load ptr, ptr %num_points.addr, align 8
  %23 = load float, ptr %x0.addr, align 4
  %24 = load float, ptr %y0.addr, align 4
  %25 = load float, ptr %x0.addr, align 4
  %26 = load float, ptr %x1.addr, align 4
  %add11 = fadd float %25, %26
  %div12 = fdiv float %add11, 2.000000e+00
  %27 = load float, ptr %y0.addr, align 4
  %28 = load float, ptr %y1.addr, align 4
  %add13 = fadd float %27, %28
  %div14 = fdiv float %add13, 2.000000e+00
  %29 = load float, ptr %mx, align 4
  %30 = load float, ptr %my, align 4
  %31 = load float, ptr %objspace_flatness_squared.addr, align 4
  %32 = load i32, ptr %n.addr, align 4
  %add15 = add nsw i32 %32, 1
  %call = call noundef i32 @_ZL22stbtt__tesselate_curveP12stbtt__pointPifffffffi(ptr noundef %21, ptr noundef %22, float noundef %23, float noundef %24, float noundef %div12, float noundef %div14, float noundef %29, float noundef %30, float noundef %31, i32 noundef %add15)
  %33 = load ptr, ptr %points.addr, align 8
  %34 = load ptr, ptr %num_points.addr, align 8
  %35 = load float, ptr %mx, align 4
  %36 = load float, ptr %my, align 4
  %37 = load float, ptr %x1.addr, align 4
  %38 = load float, ptr %x2.addr, align 4
  %add16 = fadd float %37, %38
  %div17 = fdiv float %add16, 2.000000e+00
  %39 = load float, ptr %y1.addr, align 4
  %40 = load float, ptr %y2.addr, align 4
  %add18 = fadd float %39, %40
  %div19 = fdiv float %add18, 2.000000e+00
  %41 = load float, ptr %x2.addr, align 4
  %42 = load float, ptr %y2.addr, align 4
  %43 = load float, ptr %objspace_flatness_squared.addr, align 4
  %44 = load i32, ptr %n.addr, align 4
  %add20 = add nsw i32 %44, 1
  %call21 = call noundef i32 @_ZL22stbtt__tesselate_curveP12stbtt__pointPifffffffi(ptr noundef %33, ptr noundef %34, float noundef %35, float noundef %36, float noundef %div17, float noundef %div19, float noundef %41, float noundef %42, float noundef %43, i32 noundef %add20)
  br label %if.end23

if.else:                                          ; preds = %if.end
  %45 = load ptr, ptr %points.addr, align 8
  %46 = load ptr, ptr %num_points.addr, align 8
  %47 = load i32, ptr %46, align 4
  %48 = load float, ptr %x2.addr, align 4
  %49 = load float, ptr %y2.addr, align 4
  call void @_ZL16stbtt__add_pointP12stbtt__pointiff(ptr noundef %45, i32 noundef %47, float noundef %48, float noundef %49)
  %50 = load ptr, ptr %num_points.addr, align 8
  %51 = load i32, ptr %50, align 4
  %add22 = add nsw i32 %51, 1
  %52 = load ptr, ptr %num_points.addr, align 8
  store i32 %add22, ptr %52, align 4
  br label %if.end23

if.end23:                                         ; preds = %if.else, %if.then10
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end23, %if.then
  %53 = load i32, ptr %retval, align 4
  ret i32 %53
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL22stbtt__tesselate_cubicP12stbtt__pointPifffffffffi(ptr noundef %points, ptr noundef %num_points, float noundef %x0, float noundef %y0, float noundef %x1, float noundef %y1, float noundef %x2, float noundef %y2, float noundef %x3, float noundef %y3, float noundef %objspace_flatness_squared, i32 noundef %n) #4 {
entry:
  %points.addr = alloca ptr, align 8
  %num_points.addr = alloca ptr, align 8
  %x0.addr = alloca float, align 4
  %y0.addr = alloca float, align 4
  %x1.addr = alloca float, align 4
  %y1.addr = alloca float, align 4
  %x2.addr = alloca float, align 4
  %y2.addr = alloca float, align 4
  %x3.addr = alloca float, align 4
  %y3.addr = alloca float, align 4
  %objspace_flatness_squared.addr = alloca float, align 4
  %n.addr = alloca i32, align 4
  %dx0 = alloca float, align 4
  %dy0 = alloca float, align 4
  %dx1 = alloca float, align 4
  %dy1 = alloca float, align 4
  %dx2 = alloca float, align 4
  %dy2 = alloca float, align 4
  %dx = alloca float, align 4
  %dy = alloca float, align 4
  %longlen = alloca float, align 4
  %shortlen = alloca float, align 4
  %flatness_squared = alloca float, align 4
  %x01 = alloca float, align 4
  %y01 = alloca float, align 4
  %x12 = alloca float, align 4
  %y12 = alloca float, align 4
  %x23 = alloca float, align 4
  %y23 = alloca float, align 4
  %xa = alloca float, align 4
  %ya = alloca float, align 4
  %xb = alloca float, align 4
  %yb = alloca float, align 4
  %mx = alloca float, align 4
  %my = alloca float, align 4
  store ptr %points, ptr %points.addr, align 8
  store ptr %num_points, ptr %num_points.addr, align 8
  store float %x0, ptr %x0.addr, align 4
  store float %y0, ptr %y0.addr, align 4
  store float %x1, ptr %x1.addr, align 4
  store float %y1, ptr %y1.addr, align 4
  store float %x2, ptr %x2.addr, align 4
  store float %y2, ptr %y2.addr, align 4
  store float %x3, ptr %x3.addr, align 4
  store float %y3, ptr %y3.addr, align 4
  store float %objspace_flatness_squared, ptr %objspace_flatness_squared.addr, align 4
  store i32 %n, ptr %n.addr, align 4
  %0 = load float, ptr %x1.addr, align 4
  %1 = load float, ptr %x0.addr, align 4
  %sub = fsub float %0, %1
  store float %sub, ptr %dx0, align 4
  %2 = load float, ptr %y1.addr, align 4
  %3 = load float, ptr %y0.addr, align 4
  %sub1 = fsub float %2, %3
  store float %sub1, ptr %dy0, align 4
  %4 = load float, ptr %x2.addr, align 4
  %5 = load float, ptr %x1.addr, align 4
  %sub2 = fsub float %4, %5
  store float %sub2, ptr %dx1, align 4
  %6 = load float, ptr %y2.addr, align 4
  %7 = load float, ptr %y1.addr, align 4
  %sub3 = fsub float %6, %7
  store float %sub3, ptr %dy1, align 4
  %8 = load float, ptr %x3.addr, align 4
  %9 = load float, ptr %x2.addr, align 4
  %sub4 = fsub float %8, %9
  store float %sub4, ptr %dx2, align 4
  %10 = load float, ptr %y3.addr, align 4
  %11 = load float, ptr %y2.addr, align 4
  %sub5 = fsub float %10, %11
  store float %sub5, ptr %dy2, align 4
  %12 = load float, ptr %x3.addr, align 4
  %13 = load float, ptr %x0.addr, align 4
  %sub6 = fsub float %12, %13
  store float %sub6, ptr %dx, align 4
  %14 = load float, ptr %y3.addr, align 4
  %15 = load float, ptr %y0.addr, align 4
  %sub7 = fsub float %14, %15
  store float %sub7, ptr %dy, align 4
  %16 = load float, ptr %dx0, align 4
  %17 = load float, ptr %dx0, align 4
  %18 = load float, ptr %dy0, align 4
  %19 = load float, ptr %dy0, align 4
  %mul8 = fmul float %18, %19
  %20 = call float @llvm.fmuladd.f32(float %16, float %17, float %mul8)
  %call = call float @sqrtf(float noundef %20) #12
  %21 = load float, ptr %dx1, align 4
  %22 = load float, ptr %dx1, align 4
  %23 = load float, ptr %dy1, align 4
  %24 = load float, ptr %dy1, align 4
  %mul9 = fmul float %23, %24
  %25 = call float @llvm.fmuladd.f32(float %21, float %22, float %mul9)
  %call10 = call float @sqrtf(float noundef %25) #12
  %add = fadd float %call, %call10
  %26 = load float, ptr %dx2, align 4
  %27 = load float, ptr %dx2, align 4
  %28 = load float, ptr %dy2, align 4
  %29 = load float, ptr %dy2, align 4
  %mul11 = fmul float %28, %29
  %30 = call float @llvm.fmuladd.f32(float %26, float %27, float %mul11)
  %call12 = call float @sqrtf(float noundef %30) #12
  %add13 = fadd float %add, %call12
  store float %add13, ptr %longlen, align 4
  %31 = load float, ptr %dx, align 4
  %32 = load float, ptr %dx, align 4
  %33 = load float, ptr %dy, align 4
  %34 = load float, ptr %dy, align 4
  %mul14 = fmul float %33, %34
  %35 = call float @llvm.fmuladd.f32(float %31, float %32, float %mul14)
  %call15 = call float @sqrtf(float noundef %35) #12
  store float %call15, ptr %shortlen, align 4
  %36 = load float, ptr %longlen, align 4
  %37 = load float, ptr %longlen, align 4
  %38 = load float, ptr %shortlen, align 4
  %39 = load float, ptr %shortlen, align 4
  %mul16 = fmul float %38, %39
  %neg = fneg float %mul16
  %40 = call float @llvm.fmuladd.f32(float %36, float %37, float %neg)
  store float %40, ptr %flatness_squared, align 4
  %41 = load i32, ptr %n.addr, align 4
  %cmp = icmp sgt i32 %41, 16
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end45

if.end:                                           ; preds = %entry
  %42 = load float, ptr %flatness_squared, align 4
  %43 = load float, ptr %objspace_flatness_squared.addr, align 4
  %cmp17 = fcmp ogt float %42, %43
  br i1 %cmp17, label %if.then18, label %if.else

if.then18:                                        ; preds = %if.end
  %44 = load float, ptr %x0.addr, align 4
  %45 = load float, ptr %x1.addr, align 4
  %add19 = fadd float %44, %45
  %div = fdiv float %add19, 2.000000e+00
  store float %div, ptr %x01, align 4
  %46 = load float, ptr %y0.addr, align 4
  %47 = load float, ptr %y1.addr, align 4
  %add20 = fadd float %46, %47
  %div21 = fdiv float %add20, 2.000000e+00
  store float %div21, ptr %y01, align 4
  %48 = load float, ptr %x1.addr, align 4
  %49 = load float, ptr %x2.addr, align 4
  %add22 = fadd float %48, %49
  %div23 = fdiv float %add22, 2.000000e+00
  store float %div23, ptr %x12, align 4
  %50 = load float, ptr %y1.addr, align 4
  %51 = load float, ptr %y2.addr, align 4
  %add24 = fadd float %50, %51
  %div25 = fdiv float %add24, 2.000000e+00
  store float %div25, ptr %y12, align 4
  %52 = load float, ptr %x2.addr, align 4
  %53 = load float, ptr %x3.addr, align 4
  %add26 = fadd float %52, %53
  %div27 = fdiv float %add26, 2.000000e+00
  store float %div27, ptr %x23, align 4
  %54 = load float, ptr %y2.addr, align 4
  %55 = load float, ptr %y3.addr, align 4
  %add28 = fadd float %54, %55
  %div29 = fdiv float %add28, 2.000000e+00
  store float %div29, ptr %y23, align 4
  %56 = load float, ptr %x01, align 4
  %57 = load float, ptr %x12, align 4
  %add30 = fadd float %56, %57
  %div31 = fdiv float %add30, 2.000000e+00
  store float %div31, ptr %xa, align 4
  %58 = load float, ptr %y01, align 4
  %59 = load float, ptr %y12, align 4
  %add32 = fadd float %58, %59
  %div33 = fdiv float %add32, 2.000000e+00
  store float %div33, ptr %ya, align 4
  %60 = load float, ptr %x12, align 4
  %61 = load float, ptr %x23, align 4
  %add34 = fadd float %60, %61
  %div35 = fdiv float %add34, 2.000000e+00
  store float %div35, ptr %xb, align 4
  %62 = load float, ptr %y12, align 4
  %63 = load float, ptr %y23, align 4
  %add36 = fadd float %62, %63
  %div37 = fdiv float %add36, 2.000000e+00
  store float %div37, ptr %yb, align 4
  %64 = load float, ptr %xa, align 4
  %65 = load float, ptr %xb, align 4
  %add38 = fadd float %64, %65
  %div39 = fdiv float %add38, 2.000000e+00
  store float %div39, ptr %mx, align 4
  %66 = load float, ptr %ya, align 4
  %67 = load float, ptr %yb, align 4
  %add40 = fadd float %66, %67
  %div41 = fdiv float %add40, 2.000000e+00
  store float %div41, ptr %my, align 4
  %68 = load ptr, ptr %points.addr, align 8
  %69 = load ptr, ptr %num_points.addr, align 8
  %70 = load float, ptr %x0.addr, align 4
  %71 = load float, ptr %y0.addr, align 4
  %72 = load float, ptr %x01, align 4
  %73 = load float, ptr %y01, align 4
  %74 = load float, ptr %xa, align 4
  %75 = load float, ptr %ya, align 4
  %76 = load float, ptr %mx, align 4
  %77 = load float, ptr %my, align 4
  %78 = load float, ptr %objspace_flatness_squared.addr, align 4
  %79 = load i32, ptr %n.addr, align 4
  %add42 = add nsw i32 %79, 1
  call void @_ZL22stbtt__tesselate_cubicP12stbtt__pointPifffffffffi(ptr noundef %68, ptr noundef %69, float noundef %70, float noundef %71, float noundef %72, float noundef %73, float noundef %74, float noundef %75, float noundef %76, float noundef %77, float noundef %78, i32 noundef %add42)
  %80 = load ptr, ptr %points.addr, align 8
  %81 = load ptr, ptr %num_points.addr, align 8
  %82 = load float, ptr %mx, align 4
  %83 = load float, ptr %my, align 4
  %84 = load float, ptr %xb, align 4
  %85 = load float, ptr %yb, align 4
  %86 = load float, ptr %x23, align 4
  %87 = load float, ptr %y23, align 4
  %88 = load float, ptr %x3.addr, align 4
  %89 = load float, ptr %y3.addr, align 4
  %90 = load float, ptr %objspace_flatness_squared.addr, align 4
  %91 = load i32, ptr %n.addr, align 4
  %add43 = add nsw i32 %91, 1
  call void @_ZL22stbtt__tesselate_cubicP12stbtt__pointPifffffffffi(ptr noundef %80, ptr noundef %81, float noundef %82, float noundef %83, float noundef %84, float noundef %85, float noundef %86, float noundef %87, float noundef %88, float noundef %89, float noundef %90, i32 noundef %add43)
  br label %if.end45

if.else:                                          ; preds = %if.end
  %92 = load ptr, ptr %points.addr, align 8
  %93 = load ptr, ptr %num_points.addr, align 8
  %94 = load i32, ptr %93, align 4
  %95 = load float, ptr %x3.addr, align 4
  %96 = load float, ptr %y3.addr, align 4
  call void @_ZL16stbtt__add_pointP12stbtt__pointiff(ptr noundef %92, i32 noundef %94, float noundef %95, float noundef %96)
  %97 = load ptr, ptr %num_points.addr, align 8
  %98 = load i32, ptr %97, align 4
  %add44 = add nsw i32 %98, 1
  %99 = load ptr, ptr %num_points.addr, align 8
  store i32 %add44, ptr %99, align 4
  br label %if.end45

if.end45:                                         ; preds = %if.else, %if.then18, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL17stbtt__sort_edgesP11stbtt__edgei(ptr noundef %p, i32 noundef %n) #4 {
entry:
  %p.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %p, ptr %p.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i32, ptr %n.addr, align 4
  call void @_ZL27stbtt__sort_edges_quicksortP11stbtt__edgei(ptr noundef %0, i32 noundef %1)
  %2 = load ptr, ptr %p.addr, align 8
  %3 = load i32, ptr %n.addr, align 4
  call void @_ZL26stbtt__sort_edges_ins_sortP11stbtt__edgei(ptr noundef %2, i32 noundef %3)
  ret void
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL29stbtt__rasterize_sorted_edgesP13stbtt__bitmapP11stbtt__edgeiiiiPv(ptr noundef %result, ptr noundef %e, i32 noundef %n, i32 noundef %vsubsample, i32 noundef %off_x, i32 noundef %off_y, ptr noundef %userdata) #4 {
entry:
  %result.addr = alloca ptr, align 8
  %e.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %vsubsample.addr = alloca i32, align 4
  %off_x.addr = alloca i32, align 4
  %off_y.addr = alloca i32, align 4
  %userdata.addr = alloca ptr, align 8
  %hh = alloca %struct.stbtt__hheap, align 8
  %active = alloca ptr, align 8
  %y = alloca i32, align 4
  %j = alloca i32, align 4
  %i = alloca i32, align 4
  %scanline_data = alloca [129 x float], align 16
  %scanline = alloca ptr, align 8
  %scanline2 = alloca ptr, align 8
  %scan_y_top = alloca float, align 4
  %scan_y_bottom = alloca float, align 4
  %step = alloca ptr, align 8
  %z = alloca ptr, align 8
  %z34 = alloca ptr, align 8
  %sum = alloca float, align 4
  %k = alloca float, align 4
  %m = alloca i32, align 4
  %z79 = alloca ptr, align 8
  store ptr %result, ptr %result.addr, align 8
  store ptr %e, ptr %e.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  store i32 %vsubsample, ptr %vsubsample.addr, align 4
  store i32 %off_x, ptr %off_x.addr, align 4
  store i32 %off_y, ptr %off_y.addr, align 4
  store ptr %userdata, ptr %userdata.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %hh, i8 0, i64 24, i1 false)
  store ptr null, ptr %active, align 8
  store i32 0, ptr %j, align 4
  %0 = load ptr, ptr %result.addr, align 8
  %w = getelementptr inbounds %struct.stbtt__bitmap, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %w, align 8
  %cmp = icmp sgt i32 %1, 64
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %result.addr, align 8
  %w1 = getelementptr inbounds %struct.stbtt__bitmap, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %w1, align 8
  %mul = mul nsw i32 %3, 2
  %add = add nsw i32 %mul, 1
  %conv = sext i32 %add to i64
  %mul2 = mul i64 %conv, 4
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul2)
  store ptr %call, ptr %scanline, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %arraydecay = getelementptr inbounds [129 x float], ptr %scanline_data, i64 0, i64 0
  store ptr %arraydecay, ptr %scanline, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %4 = load ptr, ptr %scanline, align 8
  %5 = load ptr, ptr %result.addr, align 8
  %w3 = getelementptr inbounds %struct.stbtt__bitmap, ptr %5, i32 0, i32 0
  %6 = load i32, ptr %w3, align 8
  %idx.ext = sext i32 %6 to i64
  %add.ptr = getelementptr inbounds float, ptr %4, i64 %idx.ext
  store ptr %add.ptr, ptr %scanline2, align 8
  %7 = load i32, ptr %off_y.addr, align 4
  store i32 %7, ptr %y, align 4
  %8 = load i32, ptr %off_y.addr, align 4
  %9 = load ptr, ptr %result.addr, align 8
  %h = getelementptr inbounds %struct.stbtt__bitmap, ptr %9, i32 0, i32 1
  %10 = load i32, ptr %h, align 4
  %add4 = add nsw i32 %8, %10
  %conv5 = sitofp i32 %add4 to float
  %add6 = fadd float %conv5, 1.000000e+00
  %11 = load ptr, ptr %e.addr, align 8
  %12 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %12 to i64
  %arrayidx = getelementptr inbounds %struct.stbtt__edge, ptr %11, i64 %idxprom
  %y0 = getelementptr inbounds %struct.stbtt__edge, ptr %arrayidx, i32 0, i32 1
  store float %add6, ptr %y0, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.end82, %if.end
  %13 = load i32, ptr %j, align 4
  %14 = load ptr, ptr %result.addr, align 8
  %h7 = getelementptr inbounds %struct.stbtt__bitmap, ptr %14, i32 0, i32 1
  %15 = load i32, ptr %h7, align 4
  %cmp8 = icmp slt i32 %13, %15
  br i1 %cmp8, label %while.body, label %while.end85

while.body:                                       ; preds = %while.cond
  %16 = load i32, ptr %y, align 4
  %conv9 = sitofp i32 %16 to float
  %add10 = fadd float %conv9, 0.000000e+00
  store float %add10, ptr %scan_y_top, align 4
  %17 = load i32, ptr %y, align 4
  %conv11 = sitofp i32 %17 to float
  %add12 = fadd float %conv11, 1.000000e+00
  store float %add12, ptr %scan_y_bottom, align 4
  store ptr %active, ptr %step, align 8
  %18 = load ptr, ptr %scanline, align 8
  %19 = load ptr, ptr %result.addr, align 8
  %w13 = getelementptr inbounds %struct.stbtt__bitmap, ptr %19, i32 0, i32 0
  %20 = load i32, ptr %w13, align 8
  %conv14 = sext i32 %20 to i64
  %mul15 = mul i64 %conv14, 4
  call void @llvm.memset.p0.i64(ptr align 4 %18, i8 0, i64 %mul15, i1 false)
  %21 = load ptr, ptr %scanline2, align 8
  %22 = load ptr, ptr %result.addr, align 8
  %w16 = getelementptr inbounds %struct.stbtt__bitmap, ptr %22, i32 0, i32 0
  %23 = load i32, ptr %w16, align 8
  %add17 = add nsw i32 %23, 1
  %conv18 = sext i32 %add17 to i64
  %mul19 = mul i64 %conv18, 4
  call void @llvm.memset.p0.i64(ptr align 4 %21, i8 0, i64 %mul19, i1 false)
  br label %while.cond20

while.cond20:                                     ; preds = %if.end26, %while.body
  %24 = load ptr, ptr %step, align 8
  %25 = load ptr, ptr %24, align 8
  %tobool = icmp ne ptr %25, null
  br i1 %tobool, label %while.body21, label %while.end

while.body21:                                     ; preds = %while.cond20
  %26 = load ptr, ptr %step, align 8
  %27 = load ptr, ptr %26, align 8
  store ptr %27, ptr %z, align 8
  %28 = load ptr, ptr %z, align 8
  %ey = getelementptr inbounds %struct.stbtt__active_edge, ptr %28, i32 0, i32 6
  %29 = load float, ptr %ey, align 4
  %30 = load float, ptr %scan_y_top, align 4
  %cmp22 = fcmp ole float %29, %30
  br i1 %cmp22, label %if.then23, label %if.else24

if.then23:                                        ; preds = %while.body21
  %31 = load ptr, ptr %z, align 8
  %next = getelementptr inbounds %struct.stbtt__active_edge, ptr %31, i32 0, i32 0
  %32 = load ptr, ptr %next, align 8
  %33 = load ptr, ptr %step, align 8
  store ptr %32, ptr %33, align 8
  br label %do.body

do.body:                                          ; preds = %if.then23
  br label %do.end

do.end:                                           ; preds = %do.body
  %34 = load ptr, ptr %z, align 8
  %direction = getelementptr inbounds %struct.stbtt__active_edge, ptr %34, i32 0, i32 4
  store float 0.000000e+00, ptr %direction, align 4
  %35 = load ptr, ptr %z, align 8
  call void @_ZL17stbtt__hheap_freeP12stbtt__hheapPv(ptr noundef %hh, ptr noundef %35)
  br label %if.end26

if.else24:                                        ; preds = %while.body21
  %36 = load ptr, ptr %step, align 8
  %37 = load ptr, ptr %36, align 8
  %next25 = getelementptr inbounds %struct.stbtt__active_edge, ptr %37, i32 0, i32 0
  store ptr %next25, ptr %step, align 8
  br label %if.end26

if.end26:                                         ; preds = %if.else24, %do.end
  br label %while.cond20, !llvm.loop !149

while.end:                                        ; preds = %while.cond20
  br label %while.cond27

while.cond27:                                     ; preds = %if.end51, %while.end
  %38 = load ptr, ptr %e.addr, align 8
  %y028 = getelementptr inbounds %struct.stbtt__edge, ptr %38, i32 0, i32 1
  %39 = load float, ptr %y028, align 4
  %40 = load float, ptr %scan_y_bottom, align 4
  %cmp29 = fcmp ole float %39, %40
  br i1 %cmp29, label %while.body30, label %while.end52

while.body30:                                     ; preds = %while.cond27
  %41 = load ptr, ptr %e.addr, align 8
  %y031 = getelementptr inbounds %struct.stbtt__edge, ptr %41, i32 0, i32 1
  %42 = load float, ptr %y031, align 4
  %43 = load ptr, ptr %e.addr, align 8
  %y1 = getelementptr inbounds %struct.stbtt__edge, ptr %43, i32 0, i32 3
  %44 = load float, ptr %y1, align 4
  %cmp32 = fcmp une float %42, %44
  br i1 %cmp32, label %if.then33, label %if.end51

if.then33:                                        ; preds = %while.body30
  %45 = load ptr, ptr %e.addr, align 8
  %46 = load i32, ptr %off_x.addr, align 4
  %47 = load float, ptr %scan_y_top, align 4
  %48 = load ptr, ptr %userdata.addr, align 8
  %call35 = call noundef ptr @_ZL17stbtt__new_activeP12stbtt__hheapP11stbtt__edgeifPv(ptr noundef %hh, ptr noundef %45, i32 noundef %46, float noundef %47, ptr noundef %48)
  store ptr %call35, ptr %z34, align 8
  %49 = load ptr, ptr %z34, align 8
  %cmp36 = icmp ne ptr %49, null
  br i1 %cmp36, label %if.then37, label %if.end50

if.then37:                                        ; preds = %if.then33
  %50 = load i32, ptr %j, align 4
  %cmp38 = icmp eq i32 %50, 0
  br i1 %cmp38, label %land.lhs.true, label %if.end46

land.lhs.true:                                    ; preds = %if.then37
  %51 = load i32, ptr %off_y.addr, align 4
  %cmp39 = icmp ne i32 %51, 0
  br i1 %cmp39, label %if.then40, label %if.end46

if.then40:                                        ; preds = %land.lhs.true
  %52 = load ptr, ptr %z34, align 8
  %ey41 = getelementptr inbounds %struct.stbtt__active_edge, ptr %52, i32 0, i32 6
  %53 = load float, ptr %ey41, align 4
  %54 = load float, ptr %scan_y_top, align 4
  %cmp42 = fcmp olt float %53, %54
  br i1 %cmp42, label %if.then43, label %if.end45

if.then43:                                        ; preds = %if.then40
  %55 = load float, ptr %scan_y_top, align 4
  %56 = load ptr, ptr %z34, align 8
  %ey44 = getelementptr inbounds %struct.stbtt__active_edge, ptr %56, i32 0, i32 6
  store float %55, ptr %ey44, align 4
  br label %if.end45

if.end45:                                         ; preds = %if.then43, %if.then40
  br label %if.end46

if.end46:                                         ; preds = %if.end45, %land.lhs.true, %if.then37
  br label %do.body47

do.body47:                                        ; preds = %if.end46
  br label %do.end48

do.end48:                                         ; preds = %do.body47
  %57 = load ptr, ptr %active, align 8
  %58 = load ptr, ptr %z34, align 8
  %next49 = getelementptr inbounds %struct.stbtt__active_edge, ptr %58, i32 0, i32 0
  store ptr %57, ptr %next49, align 8
  %59 = load ptr, ptr %z34, align 8
  store ptr %59, ptr %active, align 8
  br label %if.end50

if.end50:                                         ; preds = %do.end48, %if.then33
  br label %if.end51

if.end51:                                         ; preds = %if.end50, %while.body30
  %60 = load ptr, ptr %e.addr, align 8
  %incdec.ptr = getelementptr inbounds %struct.stbtt__edge, ptr %60, i32 1
  store ptr %incdec.ptr, ptr %e.addr, align 8
  br label %while.cond27, !llvm.loop !150

while.end52:                                      ; preds = %while.cond27
  %61 = load ptr, ptr %active, align 8
  %tobool53 = icmp ne ptr %61, null
  br i1 %tobool53, label %if.then54, label %if.end57

if.then54:                                        ; preds = %while.end52
  %62 = load ptr, ptr %scanline, align 8
  %63 = load ptr, ptr %scanline2, align 8
  %add.ptr55 = getelementptr inbounds float, ptr %63, i64 1
  %64 = load ptr, ptr %result.addr, align 8
  %w56 = getelementptr inbounds %struct.stbtt__bitmap, ptr %64, i32 0, i32 0
  %65 = load i32, ptr %w56, align 8
  %66 = load ptr, ptr %active, align 8
  %67 = load float, ptr %scan_y_top, align 4
  call void @_ZL28stbtt__fill_active_edges_newPfS_iP18stbtt__active_edgef(ptr noundef %62, ptr noundef %add.ptr55, i32 noundef %65, ptr noundef %66, float noundef %67)
  br label %if.end57

if.end57:                                         ; preds = %if.then54, %while.end52
  store float 0.000000e+00, ptr %sum, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end57
  %68 = load i32, ptr %i, align 4
  %69 = load ptr, ptr %result.addr, align 8
  %w58 = getelementptr inbounds %struct.stbtt__bitmap, ptr %69, i32 0, i32 0
  %70 = load i32, ptr %w58, align 8
  %cmp59 = icmp slt i32 %68, %70
  br i1 %cmp59, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %71 = load ptr, ptr %scanline2, align 8
  %72 = load i32, ptr %i, align 4
  %idxprom60 = sext i32 %72 to i64
  %arrayidx61 = getelementptr inbounds float, ptr %71, i64 %idxprom60
  %73 = load float, ptr %arrayidx61, align 4
  %74 = load float, ptr %sum, align 4
  %add62 = fadd float %74, %73
  store float %add62, ptr %sum, align 4
  %75 = load ptr, ptr %scanline, align 8
  %76 = load i32, ptr %i, align 4
  %idxprom63 = sext i32 %76 to i64
  %arrayidx64 = getelementptr inbounds float, ptr %75, i64 %idxprom63
  %77 = load float, ptr %arrayidx64, align 4
  %78 = load float, ptr %sum, align 4
  %add65 = fadd float %77, %78
  store float %add65, ptr %k, align 4
  %79 = load float, ptr %k, align 4
  %80 = call float @llvm.fabs.f32(float %79)
  %81 = call float @llvm.fmuladd.f32(float %80, float 2.550000e+02, float 5.000000e-01)
  store float %81, ptr %k, align 4
  %82 = load float, ptr %k, align 4
  %conv67 = fptosi float %82 to i32
  store i32 %conv67, ptr %m, align 4
  %83 = load i32, ptr %m, align 4
  %cmp68 = icmp sgt i32 %83, 255
  br i1 %cmp68, label %if.then69, label %if.end70

if.then69:                                        ; preds = %for.body
  store i32 255, ptr %m, align 4
  br label %if.end70

if.end70:                                         ; preds = %if.then69, %for.body
  %84 = load i32, ptr %m, align 4
  %conv71 = trunc i32 %84 to i8
  %85 = load ptr, ptr %result.addr, align 8
  %pixels = getelementptr inbounds %struct.stbtt__bitmap, ptr %85, i32 0, i32 3
  %86 = load ptr, ptr %pixels, align 8
  %87 = load i32, ptr %j, align 4
  %88 = load ptr, ptr %result.addr, align 8
  %stride = getelementptr inbounds %struct.stbtt__bitmap, ptr %88, i32 0, i32 2
  %89 = load i32, ptr %stride, align 8
  %mul72 = mul nsw i32 %87, %89
  %90 = load i32, ptr %i, align 4
  %add73 = add nsw i32 %mul72, %90
  %idxprom74 = sext i32 %add73 to i64
  %arrayidx75 = getelementptr inbounds i8, ptr %86, i64 %idxprom74
  store i8 %conv71, ptr %arrayidx75, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end70
  %91 = load i32, ptr %i, align 4
  %inc = add nsw i32 %91, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !151

for.end:                                          ; preds = %for.cond
  store ptr %active, ptr %step, align 8
  br label %while.cond76

while.cond76:                                     ; preds = %while.body78, %for.end
  %92 = load ptr, ptr %step, align 8
  %93 = load ptr, ptr %92, align 8
  %tobool77 = icmp ne ptr %93, null
  br i1 %tobool77, label %while.body78, label %while.end82

while.body78:                                     ; preds = %while.cond76
  %94 = load ptr, ptr %step, align 8
  %95 = load ptr, ptr %94, align 8
  store ptr %95, ptr %z79, align 8
  %96 = load ptr, ptr %z79, align 8
  %fdx = getelementptr inbounds %struct.stbtt__active_edge, ptr %96, i32 0, i32 2
  %97 = load float, ptr %fdx, align 4
  %98 = load ptr, ptr %z79, align 8
  %fx = getelementptr inbounds %struct.stbtt__active_edge, ptr %98, i32 0, i32 1
  %99 = load float, ptr %fx, align 8
  %add80 = fadd float %99, %97
  store float %add80, ptr %fx, align 8
  %100 = load ptr, ptr %step, align 8
  %101 = load ptr, ptr %100, align 8
  %next81 = getelementptr inbounds %struct.stbtt__active_edge, ptr %101, i32 0, i32 0
  store ptr %next81, ptr %step, align 8
  br label %while.cond76, !llvm.loop !152

while.end82:                                      ; preds = %while.cond76
  %102 = load i32, ptr %y, align 4
  %inc83 = add nsw i32 %102, 1
  store i32 %inc83, ptr %y, align 4
  %103 = load i32, ptr %j, align 4
  %inc84 = add nsw i32 %103, 1
  store i32 %inc84, ptr %j, align 4
  br label %while.cond, !llvm.loop !153

while.end85:                                      ; preds = %while.cond
  %104 = load ptr, ptr %userdata.addr, align 8
  call void @_ZL20stbtt__hheap_cleanupP12stbtt__hheapPv(ptr noundef %hh, ptr noundef %104)
  %105 = load ptr, ptr %scanline, align 8
  %arraydecay86 = getelementptr inbounds [129 x float], ptr %scanline_data, i64 0, i64 0
  %cmp87 = icmp ne ptr %105, %arraydecay86
  br i1 %cmp87, label %if.then88, label %if.end89

if.then88:                                        ; preds = %while.end85
  %106 = load ptr, ptr %scanline, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %106)
  br label %if.end89

if.end89:                                         ; preds = %if.then88, %while.end85
  ret void
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL27stbtt__sort_edges_quicksortP11stbtt__edgei(ptr noundef %p, i32 noundef %n) #4 {
entry:
  %p.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %t = alloca %struct.stbtt__edge, align 4
  %c01 = alloca i32, align 4
  %c12 = alloca i32, align 4
  %c = alloca i32, align 4
  %m = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %z = alloca i32, align 4
  store ptr %p, ptr %p.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end79, %entry
  %0 = load i32, ptr %n.addr, align 4
  %cmp = icmp sgt i32 %0, 12
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load i32, ptr %n.addr, align 4
  %shr = ashr i32 %1, 1
  store i32 %shr, ptr %m, align 4
  %2 = load ptr, ptr %p.addr, align 8
  %arrayidx = getelementptr inbounds %struct.stbtt__edge, ptr %2, i64 0
  %y0 = getelementptr inbounds %struct.stbtt__edge, ptr %arrayidx, i32 0, i32 1
  %3 = load float, ptr %y0, align 4
  %4 = load ptr, ptr %p.addr, align 8
  %5 = load i32, ptr %m, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx1 = getelementptr inbounds %struct.stbtt__edge, ptr %4, i64 %idxprom
  %y02 = getelementptr inbounds %struct.stbtt__edge, ptr %arrayidx1, i32 0, i32 1
  %6 = load float, ptr %y02, align 4
  %cmp3 = fcmp olt float %3, %6
  %conv = zext i1 %cmp3 to i32
  store i32 %conv, ptr %c01, align 4
  %7 = load ptr, ptr %p.addr, align 8
  %8 = load i32, ptr %m, align 4
  %idxprom4 = sext i32 %8 to i64
  %arrayidx5 = getelementptr inbounds %struct.stbtt__edge, ptr %7, i64 %idxprom4
  %y06 = getelementptr inbounds %struct.stbtt__edge, ptr %arrayidx5, i32 0, i32 1
  %9 = load float, ptr %y06, align 4
  %10 = load ptr, ptr %p.addr, align 8
  %11 = load i32, ptr %n.addr, align 4
  %sub = sub nsw i32 %11, 1
  %idxprom7 = sext i32 %sub to i64
  %arrayidx8 = getelementptr inbounds %struct.stbtt__edge, ptr %10, i64 %idxprom7
  %y09 = getelementptr inbounds %struct.stbtt__edge, ptr %arrayidx8, i32 0, i32 1
  %12 = load float, ptr %y09, align 4
  %cmp10 = fcmp olt float %9, %12
  %conv11 = zext i1 %cmp10 to i32
  store i32 %conv11, ptr %c12, align 4
  %13 = load i32, ptr %c01, align 4
  %14 = load i32, ptr %c12, align 4
  %cmp12 = icmp ne i32 %13, %14
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %15 = load ptr, ptr %p.addr, align 8
  %arrayidx13 = getelementptr inbounds %struct.stbtt__edge, ptr %15, i64 0
  %y014 = getelementptr inbounds %struct.stbtt__edge, ptr %arrayidx13, i32 0, i32 1
  %16 = load float, ptr %y014, align 4
  %17 = load ptr, ptr %p.addr, align 8
  %18 = load i32, ptr %n.addr, align 4
  %sub15 = sub nsw i32 %18, 1
  %idxprom16 = sext i32 %sub15 to i64
  %arrayidx17 = getelementptr inbounds %struct.stbtt__edge, ptr %17, i64 %idxprom16
  %y018 = getelementptr inbounds %struct.stbtt__edge, ptr %arrayidx17, i32 0, i32 1
  %19 = load float, ptr %y018, align 4
  %cmp19 = fcmp olt float %16, %19
  %conv20 = zext i1 %cmp19 to i32
  store i32 %conv20, ptr %c, align 4
  %20 = load i32, ptr %c, align 4
  %21 = load i32, ptr %c12, align 4
  %cmp21 = icmp eq i32 %20, %21
  br i1 %cmp21, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %22 = load i32, ptr %n.addr, align 4
  %sub22 = sub nsw i32 %22, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 0, %cond.true ], [ %sub22, %cond.false ]
  store i32 %cond, ptr %z, align 4
  %23 = load ptr, ptr %p.addr, align 8
  %24 = load i32, ptr %z, align 4
  %idxprom23 = sext i32 %24 to i64
  %arrayidx24 = getelementptr inbounds %struct.stbtt__edge, ptr %23, i64 %idxprom23
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %t, ptr align 4 %arrayidx24, i64 20, i1 false)
  %25 = load ptr, ptr %p.addr, align 8
  %26 = load i32, ptr %m, align 4
  %idxprom25 = sext i32 %26 to i64
  %arrayidx26 = getelementptr inbounds %struct.stbtt__edge, ptr %25, i64 %idxprom25
  %27 = load ptr, ptr %p.addr, align 8
  %28 = load i32, ptr %z, align 4
  %idxprom27 = sext i32 %28 to i64
  %arrayidx28 = getelementptr inbounds %struct.stbtt__edge, ptr %27, i64 %idxprom27
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx28, ptr align 4 %arrayidx26, i64 20, i1 false)
  %29 = load ptr, ptr %p.addr, align 8
  %30 = load i32, ptr %m, align 4
  %idxprom29 = sext i32 %30 to i64
  %arrayidx30 = getelementptr inbounds %struct.stbtt__edge, ptr %29, i64 %idxprom29
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx30, ptr align 4 %t, i64 20, i1 false)
  br label %if.end

if.end:                                           ; preds = %cond.end, %while.body
  %31 = load ptr, ptr %p.addr, align 8
  %arrayidx31 = getelementptr inbounds %struct.stbtt__edge, ptr %31, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %t, ptr align 4 %arrayidx31, i64 20, i1 false)
  %32 = load ptr, ptr %p.addr, align 8
  %33 = load i32, ptr %m, align 4
  %idxprom32 = sext i32 %33 to i64
  %arrayidx33 = getelementptr inbounds %struct.stbtt__edge, ptr %32, i64 %idxprom32
  %34 = load ptr, ptr %p.addr, align 8
  %arrayidx34 = getelementptr inbounds %struct.stbtt__edge, ptr %34, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx34, ptr align 4 %arrayidx33, i64 20, i1 false)
  %35 = load ptr, ptr %p.addr, align 8
  %36 = load i32, ptr %m, align 4
  %idxprom35 = sext i32 %36 to i64
  %arrayidx36 = getelementptr inbounds %struct.stbtt__edge, ptr %35, i64 %idxprom35
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx36, ptr align 4 %t, i64 20, i1 false)
  store i32 1, ptr %i, align 4
  %37 = load i32, ptr %n.addr, align 4
  %sub37 = sub nsw i32 %37, 1
  store i32 %sub37, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %if.end60, %if.end
  br label %for.cond38

for.cond38:                                       ; preds = %for.inc, %for.cond
  %38 = load ptr, ptr %p.addr, align 8
  %39 = load i32, ptr %i, align 4
  %idxprom39 = sext i32 %39 to i64
  %arrayidx40 = getelementptr inbounds %struct.stbtt__edge, ptr %38, i64 %idxprom39
  %y041 = getelementptr inbounds %struct.stbtt__edge, ptr %arrayidx40, i32 0, i32 1
  %40 = load float, ptr %y041, align 4
  %41 = load ptr, ptr %p.addr, align 8
  %arrayidx42 = getelementptr inbounds %struct.stbtt__edge, ptr %41, i64 0
  %y043 = getelementptr inbounds %struct.stbtt__edge, ptr %arrayidx42, i32 0, i32 1
  %42 = load float, ptr %y043, align 4
  %cmp44 = fcmp olt float %40, %42
  br i1 %cmp44, label %if.end46, label %if.then45

if.then45:                                        ; preds = %for.cond38
  br label %for.end

if.end46:                                         ; preds = %for.cond38
  br label %for.inc

for.inc:                                          ; preds = %if.end46
  %43 = load i32, ptr %i, align 4
  %inc = add nsw i32 %43, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond38, !llvm.loop !154

for.end:                                          ; preds = %if.then45
  br label %for.cond47

for.cond47:                                       ; preds = %for.inc56, %for.end
  %44 = load ptr, ptr %p.addr, align 8
  %arrayidx48 = getelementptr inbounds %struct.stbtt__edge, ptr %44, i64 0
  %y049 = getelementptr inbounds %struct.stbtt__edge, ptr %arrayidx48, i32 0, i32 1
  %45 = load float, ptr %y049, align 4
  %46 = load ptr, ptr %p.addr, align 8
  %47 = load i32, ptr %j, align 4
  %idxprom50 = sext i32 %47 to i64
  %arrayidx51 = getelementptr inbounds %struct.stbtt__edge, ptr %46, i64 %idxprom50
  %y052 = getelementptr inbounds %struct.stbtt__edge, ptr %arrayidx51, i32 0, i32 1
  %48 = load float, ptr %y052, align 4
  %cmp53 = fcmp olt float %45, %48
  br i1 %cmp53, label %if.end55, label %if.then54

if.then54:                                        ; preds = %for.cond47
  br label %for.end57

if.end55:                                         ; preds = %for.cond47
  br label %for.inc56

for.inc56:                                        ; preds = %if.end55
  %49 = load i32, ptr %j, align 4
  %dec = add nsw i32 %49, -1
  store i32 %dec, ptr %j, align 4
  br label %for.cond47, !llvm.loop !155

for.end57:                                        ; preds = %if.then54
  %50 = load i32, ptr %i, align 4
  %51 = load i32, ptr %j, align 4
  %cmp58 = icmp sge i32 %50, %51
  br i1 %cmp58, label %if.then59, label %if.end60

if.then59:                                        ; preds = %for.end57
  br label %for.end71

if.end60:                                         ; preds = %for.end57
  %52 = load ptr, ptr %p.addr, align 8
  %53 = load i32, ptr %i, align 4
  %idxprom61 = sext i32 %53 to i64
  %arrayidx62 = getelementptr inbounds %struct.stbtt__edge, ptr %52, i64 %idxprom61
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %t, ptr align 4 %arrayidx62, i64 20, i1 false)
  %54 = load ptr, ptr %p.addr, align 8
  %55 = load i32, ptr %j, align 4
  %idxprom63 = sext i32 %55 to i64
  %arrayidx64 = getelementptr inbounds %struct.stbtt__edge, ptr %54, i64 %idxprom63
  %56 = load ptr, ptr %p.addr, align 8
  %57 = load i32, ptr %i, align 4
  %idxprom65 = sext i32 %57 to i64
  %arrayidx66 = getelementptr inbounds %struct.stbtt__edge, ptr %56, i64 %idxprom65
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx66, ptr align 4 %arrayidx64, i64 20, i1 false)
  %58 = load ptr, ptr %p.addr, align 8
  %59 = load i32, ptr %j, align 4
  %idxprom67 = sext i32 %59 to i64
  %arrayidx68 = getelementptr inbounds %struct.stbtt__edge, ptr %58, i64 %idxprom67
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx68, ptr align 4 %t, i64 20, i1 false)
  %60 = load i32, ptr %i, align 4
  %inc69 = add nsw i32 %60, 1
  store i32 %inc69, ptr %i, align 4
  %61 = load i32, ptr %j, align 4
  %dec70 = add nsw i32 %61, -1
  store i32 %dec70, ptr %j, align 4
  br label %for.cond, !llvm.loop !156

for.end71:                                        ; preds = %if.then59
  %62 = load i32, ptr %j, align 4
  %63 = load i32, ptr %n.addr, align 4
  %64 = load i32, ptr %i, align 4
  %sub72 = sub nsw i32 %63, %64
  %cmp73 = icmp slt i32 %62, %sub72
  br i1 %cmp73, label %if.then74, label %if.else

if.then74:                                        ; preds = %for.end71
  %65 = load ptr, ptr %p.addr, align 8
  %66 = load i32, ptr %j, align 4
  call void @_ZL27stbtt__sort_edges_quicksortP11stbtt__edgei(ptr noundef %65, i32 noundef %66)
  %67 = load ptr, ptr %p.addr, align 8
  %68 = load i32, ptr %i, align 4
  %idx.ext = sext i32 %68 to i64
  %add.ptr = getelementptr inbounds %struct.stbtt__edge, ptr %67, i64 %idx.ext
  store ptr %add.ptr, ptr %p.addr, align 8
  %69 = load i32, ptr %n.addr, align 4
  %70 = load i32, ptr %i, align 4
  %sub75 = sub nsw i32 %69, %70
  store i32 %sub75, ptr %n.addr, align 4
  br label %if.end79

if.else:                                          ; preds = %for.end71
  %71 = load ptr, ptr %p.addr, align 8
  %72 = load i32, ptr %i, align 4
  %idx.ext76 = sext i32 %72 to i64
  %add.ptr77 = getelementptr inbounds %struct.stbtt__edge, ptr %71, i64 %idx.ext76
  %73 = load i32, ptr %n.addr, align 4
  %74 = load i32, ptr %i, align 4
  %sub78 = sub nsw i32 %73, %74
  call void @_ZL27stbtt__sort_edges_quicksortP11stbtt__edgei(ptr noundef %add.ptr77, i32 noundef %sub78)
  %75 = load i32, ptr %j, align 4
  store i32 %75, ptr %n.addr, align 4
  br label %if.end79

if.end79:                                         ; preds = %if.else, %if.then74
  br label %while.cond, !llvm.loop !157

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZL26stbtt__sort_edges_ins_sortP11stbtt__edgei(ptr noundef %p, i32 noundef %n) #2 {
entry:
  %p.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %t = alloca %struct.stbtt__edge, align 4
  %a = alloca ptr, align 8
  %b = alloca ptr, align 8
  %c = alloca i32, align 4
  store ptr %p, ptr %p.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  store i32 1, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %1 = load i32, ptr %n.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %p.addr, align 8
  %3 = load i32, ptr %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds %struct.stbtt__edge, ptr %2, i64 %idxprom
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %t, ptr align 4 %arrayidx, i64 20, i1 false)
  store ptr %t, ptr %a, align 8
  %4 = load i32, ptr %i, align 4
  store i32 %4, ptr %j, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end, %for.body
  %5 = load i32, ptr %j, align 4
  %cmp1 = icmp sgt i32 %5, 0
  br i1 %cmp1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %6 = load ptr, ptr %p.addr, align 8
  %7 = load i32, ptr %j, align 4
  %sub = sub nsw i32 %7, 1
  %idxprom2 = sext i32 %sub to i64
  %arrayidx3 = getelementptr inbounds %struct.stbtt__edge, ptr %6, i64 %idxprom2
  store ptr %arrayidx3, ptr %b, align 8
  %8 = load ptr, ptr %a, align 8
  %y0 = getelementptr inbounds %struct.stbtt__edge, ptr %8, i32 0, i32 1
  %9 = load float, ptr %y0, align 4
  %10 = load ptr, ptr %b, align 8
  %y04 = getelementptr inbounds %struct.stbtt__edge, ptr %10, i32 0, i32 1
  %11 = load float, ptr %y04, align 4
  %cmp5 = fcmp olt float %9, %11
  %conv = zext i1 %cmp5 to i32
  store i32 %conv, ptr %c, align 4
  %12 = load i32, ptr %c, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  br label %while.end

if.end:                                           ; preds = %while.body
  %13 = load ptr, ptr %p.addr, align 8
  %14 = load i32, ptr %j, align 4
  %sub6 = sub nsw i32 %14, 1
  %idxprom7 = sext i32 %sub6 to i64
  %arrayidx8 = getelementptr inbounds %struct.stbtt__edge, ptr %13, i64 %idxprom7
  %15 = load ptr, ptr %p.addr, align 8
  %16 = load i32, ptr %j, align 4
  %idxprom9 = sext i32 %16 to i64
  %arrayidx10 = getelementptr inbounds %struct.stbtt__edge, ptr %15, i64 %idxprom9
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx10, ptr align 4 %arrayidx8, i64 20, i1 false)
  %17 = load i32, ptr %j, align 4
  %dec = add nsw i32 %17, -1
  store i32 %dec, ptr %j, align 4
  br label %while.cond, !llvm.loop !158

while.end:                                        ; preds = %if.then, %while.cond
  %18 = load i32, ptr %i, align 4
  %19 = load i32, ptr %j, align 4
  %cmp11 = icmp ne i32 %18, %19
  br i1 %cmp11, label %if.then12, label %if.end15

if.then12:                                        ; preds = %while.end
  %20 = load ptr, ptr %p.addr, align 8
  %21 = load i32, ptr %j, align 4
  %idxprom13 = sext i32 %21 to i64
  %arrayidx14 = getelementptr inbounds %struct.stbtt__edge, ptr %20, i64 %idxprom13
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx14, ptr align 4 %t, i64 20, i1 false)
  br label %if.end15

if.end15:                                         ; preds = %if.then12, %while.end
  br label %for.inc

for.inc:                                          ; preds = %if.end15
  %22 = load i32, ptr %i, align 4
  %inc = add nsw i32 %22, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !159

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZL17stbtt__hheap_freeP12stbtt__hheapPv(ptr noundef %hh, ptr noundef %p) #2 {
entry:
  %hh.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  store ptr %hh, ptr %hh.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %hh.addr, align 8
  %first_free = getelementptr inbounds %struct.stbtt__hheap, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %first_free, align 8
  %2 = load ptr, ptr %p.addr, align 8
  store ptr %1, ptr %2, align 8
  %3 = load ptr, ptr %p.addr, align 8
  %4 = load ptr, ptr %hh.addr, align 8
  %first_free1 = getelementptr inbounds %struct.stbtt__hheap, ptr %4, i32 0, i32 1
  store ptr %3, ptr %first_free1, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define internal noundef ptr @_ZL17stbtt__new_activeP12stbtt__hheapP11stbtt__edgeifPv(ptr noundef %hh, ptr noundef %e, i32 noundef %off_x, float noundef %start_point, ptr noundef %userdata) #4 {
entry:
  %retval = alloca ptr, align 8
  %hh.addr = alloca ptr, align 8
  %e.addr = alloca ptr, align 8
  %off_x.addr = alloca i32, align 4
  %start_point.addr = alloca float, align 4
  %userdata.addr = alloca ptr, align 8
  %z = alloca ptr, align 8
  %dxdy = alloca float, align 4
  store ptr %hh, ptr %hh.addr, align 8
  store ptr %e, ptr %e.addr, align 8
  store i32 %off_x, ptr %off_x.addr, align 4
  store float %start_point, ptr %start_point.addr, align 4
  store ptr %userdata, ptr %userdata.addr, align 8
  %0 = load ptr, ptr %hh.addr, align 8
  %1 = load ptr, ptr %userdata.addr, align 8
  %call = call noundef ptr @_ZL18stbtt__hheap_allocP12stbtt__hheapmPv(ptr noundef %0, i64 noundef 32, ptr noundef %1)
  store ptr %call, ptr %z, align 8
  %2 = load ptr, ptr %e.addr, align 8
  %x1 = getelementptr inbounds %struct.stbtt__edge, ptr %2, i32 0, i32 2
  %3 = load float, ptr %x1, align 4
  %4 = load ptr, ptr %e.addr, align 8
  %x0 = getelementptr inbounds %struct.stbtt__edge, ptr %4, i32 0, i32 0
  %5 = load float, ptr %x0, align 4
  %sub = fsub float %3, %5
  %6 = load ptr, ptr %e.addr, align 8
  %y1 = getelementptr inbounds %struct.stbtt__edge, ptr %6, i32 0, i32 3
  %7 = load float, ptr %y1, align 4
  %8 = load ptr, ptr %e.addr, align 8
  %y0 = getelementptr inbounds %struct.stbtt__edge, ptr %8, i32 0, i32 1
  %9 = load float, ptr %y0, align 4
  %sub1 = fsub float %7, %9
  %div = fdiv float %sub, %sub1
  store float %div, ptr %dxdy, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %10 = load ptr, ptr %z, align 8
  %tobool = icmp ne ptr %10, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %do.end
  %11 = load ptr, ptr %z, align 8
  store ptr %11, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %do.end
  %12 = load float, ptr %dxdy, align 4
  %13 = load ptr, ptr %z, align 8
  %fdx = getelementptr inbounds %struct.stbtt__active_edge, ptr %13, i32 0, i32 2
  store float %12, ptr %fdx, align 4
  %14 = load float, ptr %dxdy, align 4
  %cmp = fcmp une float %14, 0.000000e+00
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %15 = load float, ptr %dxdy, align 4
  %div2 = fdiv float 1.000000e+00, %15
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %div2, %cond.true ], [ 0.000000e+00, %cond.false ]
  %16 = load ptr, ptr %z, align 8
  %fdy = getelementptr inbounds %struct.stbtt__active_edge, ptr %16, i32 0, i32 3
  store float %cond, ptr %fdy, align 8
  %17 = load ptr, ptr %e.addr, align 8
  %x03 = getelementptr inbounds %struct.stbtt__edge, ptr %17, i32 0, i32 0
  %18 = load float, ptr %x03, align 4
  %19 = load float, ptr %dxdy, align 4
  %20 = load float, ptr %start_point.addr, align 4
  %21 = load ptr, ptr %e.addr, align 8
  %y04 = getelementptr inbounds %struct.stbtt__edge, ptr %21, i32 0, i32 1
  %22 = load float, ptr %y04, align 4
  %sub5 = fsub float %20, %22
  %23 = call float @llvm.fmuladd.f32(float %19, float %sub5, float %18)
  %24 = load ptr, ptr %z, align 8
  %fx = getelementptr inbounds %struct.stbtt__active_edge, ptr %24, i32 0, i32 1
  store float %23, ptr %fx, align 8
  %25 = load i32, ptr %off_x.addr, align 4
  %conv = sitofp i32 %25 to float
  %26 = load ptr, ptr %z, align 8
  %fx6 = getelementptr inbounds %struct.stbtt__active_edge, ptr %26, i32 0, i32 1
  %27 = load float, ptr %fx6, align 8
  %sub7 = fsub float %27, %conv
  store float %sub7, ptr %fx6, align 8
  %28 = load ptr, ptr %e.addr, align 8
  %invert = getelementptr inbounds %struct.stbtt__edge, ptr %28, i32 0, i32 4
  %29 = load i32, ptr %invert, align 4
  %tobool8 = icmp ne i32 %29, 0
  %cond9 = select i1 %tobool8, float 1.000000e+00, float -1.000000e+00
  %30 = load ptr, ptr %z, align 8
  %direction = getelementptr inbounds %struct.stbtt__active_edge, ptr %30, i32 0, i32 4
  store float %cond9, ptr %direction, align 4
  %31 = load ptr, ptr %e.addr, align 8
  %y010 = getelementptr inbounds %struct.stbtt__edge, ptr %31, i32 0, i32 1
  %32 = load float, ptr %y010, align 4
  %33 = load ptr, ptr %z, align 8
  %sy = getelementptr inbounds %struct.stbtt__active_edge, ptr %33, i32 0, i32 5
  store float %32, ptr %sy, align 8
  %34 = load ptr, ptr %e.addr, align 8
  %y111 = getelementptr inbounds %struct.stbtt__edge, ptr %34, i32 0, i32 3
  %35 = load float, ptr %y111, align 4
  %36 = load ptr, ptr %z, align 8
  %ey = getelementptr inbounds %struct.stbtt__active_edge, ptr %36, i32 0, i32 6
  store float %35, ptr %ey, align 4
  %37 = load ptr, ptr %z, align 8
  %next = getelementptr inbounds %struct.stbtt__active_edge, ptr %37, i32 0, i32 0
  store ptr null, ptr %next, align 8
  %38 = load ptr, ptr %z, align 8
  store ptr %38, ptr %retval, align 8
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %39 = load ptr, ptr %retval, align 8
  ret ptr %39
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL28stbtt__fill_active_edges_newPfS_iP18stbtt__active_edgef(ptr noundef %scanline, ptr noundef %scanline_fill, i32 noundef %len, ptr noundef %e, float noundef %y_top) #4 {
entry:
  %scanline.addr = alloca ptr, align 8
  %scanline_fill.addr = alloca ptr, align 8
  %len.addr = alloca i32, align 4
  %e.addr = alloca ptr, align 8
  %y_top.addr = alloca float, align 4
  %y_bottom = alloca float, align 4
  %x0 = alloca float, align 4
  %x011 = alloca float, align 4
  %dx = alloca float, align 4
  %xb = alloca float, align 4
  %x_top = alloca float, align 4
  %x_bottom = alloca float, align 4
  %sy0 = alloca float, align 4
  %sy1 = alloca float, align 4
  %dy = alloca float, align 4
  %height = alloca float, align 4
  %x = alloca i32, align 4
  %x56 = alloca i32, align 4
  %x1 = alloca i32, align 4
  %x2 = alloca i32, align 4
  %y_crossing = alloca float, align 4
  %y_final = alloca float, align 4
  %step = alloca float, align 4
  %sign = alloca float, align 4
  %area = alloca float, align 4
  %t = alloca float, align 4
  %denom = alloca i32, align 4
  %x132 = alloca i32, align 4
  %y0 = alloca float, align 4
  %x1136 = alloca float, align 4
  %x2138 = alloca float, align 4
  %x3 = alloca float, align 4
  %y3 = alloca float, align 4
  %y1 = alloca float, align 4
  %y2 = alloca float, align 4
  store ptr %scanline, ptr %scanline.addr, align 8
  store ptr %scanline_fill, ptr %scanline_fill.addr, align 8
  store i32 %len, ptr %len.addr, align 4
  store ptr %e, ptr %e.addr, align 8
  store float %y_top, ptr %y_top.addr, align 4
  %0 = load float, ptr %y_top.addr, align 4
  %add = fadd float %0, 1.000000e+00
  store float %add, ptr %y_bottom, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end190, %entry
  %1 = load ptr, ptr %e.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %do.body

do.body:                                          ; preds = %while.body
  br label %do.end

do.end:                                           ; preds = %do.body
  %2 = load ptr, ptr %e.addr, align 8
  %fdx = getelementptr inbounds %struct.stbtt__active_edge, ptr %2, i32 0, i32 2
  %3 = load float, ptr %fdx, align 4
  %cmp = fcmp oeq float %3, 0.000000e+00
  br i1 %cmp, label %if.then, label %if.else10

if.then:                                          ; preds = %do.end
  %4 = load ptr, ptr %e.addr, align 8
  %fx = getelementptr inbounds %struct.stbtt__active_edge, ptr %4, i32 0, i32 1
  %5 = load float, ptr %fx, align 8
  store float %5, ptr %x0, align 4
  %6 = load float, ptr %x0, align 4
  %7 = load i32, ptr %len.addr, align 4
  %conv = sitofp i32 %7 to float
  %cmp1 = fcmp olt float %6, %conv
  br i1 %cmp1, label %if.then2, label %if.end9

if.then2:                                         ; preds = %if.then
  %8 = load float, ptr %x0, align 4
  %cmp3 = fcmp oge float %8, 0.000000e+00
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.then2
  %9 = load ptr, ptr %scanline.addr, align 8
  %10 = load float, ptr %x0, align 4
  %conv5 = fptosi float %10 to i32
  %11 = load ptr, ptr %e.addr, align 8
  %12 = load float, ptr %x0, align 4
  %13 = load float, ptr %y_top.addr, align 4
  %14 = load float, ptr %x0, align 4
  %15 = load float, ptr %y_bottom, align 4
  call void @_ZL26stbtt__handle_clipped_edgePfiP18stbtt__active_edgeffff(ptr noundef %9, i32 noundef %conv5, ptr noundef %11, float noundef %12, float noundef %13, float noundef %14, float noundef %15)
  %16 = load ptr, ptr %scanline_fill.addr, align 8
  %add.ptr = getelementptr inbounds float, ptr %16, i64 -1
  %17 = load float, ptr %x0, align 4
  %conv6 = fptosi float %17 to i32
  %add7 = add nsw i32 %conv6, 1
  %18 = load ptr, ptr %e.addr, align 8
  %19 = load float, ptr %x0, align 4
  %20 = load float, ptr %y_top.addr, align 4
  %21 = load float, ptr %x0, align 4
  %22 = load float, ptr %y_bottom, align 4
  call void @_ZL26stbtt__handle_clipped_edgePfiP18stbtt__active_edgeffff(ptr noundef %add.ptr, i32 noundef %add7, ptr noundef %18, float noundef %19, float noundef %20, float noundef %21, float noundef %22)
  br label %if.end

if.else:                                          ; preds = %if.then2
  %23 = load ptr, ptr %scanline_fill.addr, align 8
  %add.ptr8 = getelementptr inbounds float, ptr %23, i64 -1
  %24 = load ptr, ptr %e.addr, align 8
  %25 = load float, ptr %x0, align 4
  %26 = load float, ptr %y_top.addr, align 4
  %27 = load float, ptr %x0, align 4
  %28 = load float, ptr %y_bottom, align 4
  call void @_ZL26stbtt__handle_clipped_edgePfiP18stbtt__active_edgeffff(ptr noundef %add.ptr8, i32 noundef 0, ptr noundef %24, float noundef %25, float noundef %26, float noundef %27, float noundef %28)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then4
  br label %if.end9

if.end9:                                          ; preds = %if.end, %if.then
  br label %if.end190

if.else10:                                        ; preds = %do.end
  %29 = load ptr, ptr %e.addr, align 8
  %fx12 = getelementptr inbounds %struct.stbtt__active_edge, ptr %29, i32 0, i32 1
  %30 = load float, ptr %fx12, align 8
  store float %30, ptr %x011, align 4
  %31 = load ptr, ptr %e.addr, align 8
  %fdx13 = getelementptr inbounds %struct.stbtt__active_edge, ptr %31, i32 0, i32 2
  %32 = load float, ptr %fdx13, align 4
  store float %32, ptr %dx, align 4
  %33 = load float, ptr %x011, align 4
  %34 = load float, ptr %dx, align 4
  %add14 = fadd float %33, %34
  store float %add14, ptr %xb, align 4
  %35 = load ptr, ptr %e.addr, align 8
  %fdy = getelementptr inbounds %struct.stbtt__active_edge, ptr %35, i32 0, i32 3
  %36 = load float, ptr %fdy, align 8
  store float %36, ptr %dy, align 4
  br label %do.body15

do.body15:                                        ; preds = %if.else10
  br label %do.end16

do.end16:                                         ; preds = %do.body15
  %37 = load ptr, ptr %e.addr, align 8
  %sy = getelementptr inbounds %struct.stbtt__active_edge, ptr %37, i32 0, i32 5
  %38 = load float, ptr %sy, align 8
  %39 = load float, ptr %y_top.addr, align 4
  %cmp17 = fcmp ogt float %38, %39
  br i1 %cmp17, label %if.then18, label %if.else21

if.then18:                                        ; preds = %do.end16
  %40 = load float, ptr %x011, align 4
  %41 = load float, ptr %dx, align 4
  %42 = load ptr, ptr %e.addr, align 8
  %sy19 = getelementptr inbounds %struct.stbtt__active_edge, ptr %42, i32 0, i32 5
  %43 = load float, ptr %sy19, align 8
  %44 = load float, ptr %y_top.addr, align 4
  %sub = fsub float %43, %44
  %45 = call float @llvm.fmuladd.f32(float %41, float %sub, float %40)
  store float %45, ptr %x_top, align 4
  %46 = load ptr, ptr %e.addr, align 8
  %sy20 = getelementptr inbounds %struct.stbtt__active_edge, ptr %46, i32 0, i32 5
  %47 = load float, ptr %sy20, align 8
  store float %47, ptr %sy0, align 4
  br label %if.end22

if.else21:                                        ; preds = %do.end16
  %48 = load float, ptr %x011, align 4
  store float %48, ptr %x_top, align 4
  %49 = load float, ptr %y_top.addr, align 4
  store float %49, ptr %sy0, align 4
  br label %if.end22

if.end22:                                         ; preds = %if.else21, %if.then18
  %50 = load ptr, ptr %e.addr, align 8
  %ey = getelementptr inbounds %struct.stbtt__active_edge, ptr %50, i32 0, i32 6
  %51 = load float, ptr %ey, align 4
  %52 = load float, ptr %y_bottom, align 4
  %cmp23 = fcmp olt float %51, %52
  br i1 %cmp23, label %if.then24, label %if.else28

if.then24:                                        ; preds = %if.end22
  %53 = load float, ptr %x011, align 4
  %54 = load float, ptr %dx, align 4
  %55 = load ptr, ptr %e.addr, align 8
  %ey25 = getelementptr inbounds %struct.stbtt__active_edge, ptr %55, i32 0, i32 6
  %56 = load float, ptr %ey25, align 4
  %57 = load float, ptr %y_top.addr, align 4
  %sub26 = fsub float %56, %57
  %58 = call float @llvm.fmuladd.f32(float %54, float %sub26, float %53)
  store float %58, ptr %x_bottom, align 4
  %59 = load ptr, ptr %e.addr, align 8
  %ey27 = getelementptr inbounds %struct.stbtt__active_edge, ptr %59, i32 0, i32 6
  %60 = load float, ptr %ey27, align 4
  store float %60, ptr %sy1, align 4
  br label %if.end29

if.else28:                                        ; preds = %if.end22
  %61 = load float, ptr %xb, align 4
  store float %61, ptr %x_bottom, align 4
  %62 = load float, ptr %y_bottom, align 4
  store float %62, ptr %sy1, align 4
  br label %if.end29

if.end29:                                         ; preds = %if.else28, %if.then24
  %63 = load float, ptr %x_top, align 4
  %cmp30 = fcmp oge float %63, 0.000000e+00
  br i1 %cmp30, label %land.lhs.true, label %if.else131

land.lhs.true:                                    ; preds = %if.end29
  %64 = load float, ptr %x_bottom, align 4
  %cmp31 = fcmp oge float %64, 0.000000e+00
  br i1 %cmp31, label %land.lhs.true32, label %if.else131

land.lhs.true32:                                  ; preds = %land.lhs.true
  %65 = load float, ptr %x_top, align 4
  %66 = load i32, ptr %len.addr, align 4
  %conv33 = sitofp i32 %66 to float
  %cmp34 = fcmp olt float %65, %conv33
  br i1 %cmp34, label %land.lhs.true35, label %if.else131

land.lhs.true35:                                  ; preds = %land.lhs.true32
  %67 = load float, ptr %x_bottom, align 4
  %68 = load i32, ptr %len.addr, align 4
  %conv36 = sitofp i32 %68 to float
  %cmp37 = fcmp olt float %67, %conv36
  br i1 %cmp37, label %if.then38, label %if.else131

if.then38:                                        ; preds = %land.lhs.true35
  %69 = load float, ptr %x_top, align 4
  %conv39 = fptosi float %69 to i32
  %70 = load float, ptr %x_bottom, align 4
  %conv40 = fptosi float %70 to i32
  %cmp41 = icmp eq i32 %conv39, %conv40
  br i1 %cmp41, label %if.then42, label %if.else55

if.then42:                                        ; preds = %if.then38
  %71 = load float, ptr %x_top, align 4
  %conv43 = fptosi float %71 to i32
  store i32 %conv43, ptr %x, align 4
  %72 = load float, ptr %sy1, align 4
  %73 = load float, ptr %sy0, align 4
  %sub44 = fsub float %72, %73
  %74 = load ptr, ptr %e.addr, align 8
  %direction = getelementptr inbounds %struct.stbtt__active_edge, ptr %74, i32 0, i32 4
  %75 = load float, ptr %direction, align 4
  %mul = fmul float %sub44, %75
  store float %mul, ptr %height, align 4
  br label %do.body45

do.body45:                                        ; preds = %if.then42
  br label %do.end46

do.end46:                                         ; preds = %do.body45
  %76 = load float, ptr %height, align 4
  %77 = load float, ptr %x_top, align 4
  %78 = load i32, ptr %x, align 4
  %conv47 = sitofp i32 %78 to float
  %add48 = fadd float %conv47, 1.000000e+00
  %79 = load float, ptr %x_bottom, align 4
  %80 = load i32, ptr %x, align 4
  %conv49 = sitofp i32 %80 to float
  %add50 = fadd float %conv49, 1.000000e+00
  %call = call noundef float @_ZL30stbtt__position_trapezoid_areafffff(float noundef %76, float noundef %77, float noundef %add48, float noundef %79, float noundef %add50)
  %81 = load ptr, ptr %scanline.addr, align 8
  %82 = load i32, ptr %x, align 4
  %idxprom = sext i32 %82 to i64
  %arrayidx = getelementptr inbounds float, ptr %81, i64 %idxprom
  %83 = load float, ptr %arrayidx, align 4
  %add51 = fadd float %83, %call
  store float %add51, ptr %arrayidx, align 4
  %84 = load float, ptr %height, align 4
  %85 = load ptr, ptr %scanline_fill.addr, align 8
  %86 = load i32, ptr %x, align 4
  %idxprom52 = sext i32 %86 to i64
  %arrayidx53 = getelementptr inbounds float, ptr %85, i64 %idxprom52
  %87 = load float, ptr %arrayidx53, align 4
  %add54 = fadd float %87, %84
  store float %add54, ptr %arrayidx53, align 4
  br label %if.end130

if.else55:                                        ; preds = %if.then38
  %88 = load float, ptr %x_top, align 4
  %89 = load float, ptr %x_bottom, align 4
  %cmp57 = fcmp ogt float %88, %89
  br i1 %cmp57, label %if.then58, label %if.end64

if.then58:                                        ; preds = %if.else55
  %90 = load float, ptr %y_bottom, align 4
  %91 = load float, ptr %sy0, align 4
  %92 = load float, ptr %y_top.addr, align 4
  %sub59 = fsub float %91, %92
  %sub60 = fsub float %90, %sub59
  store float %sub60, ptr %sy0, align 4
  %93 = load float, ptr %y_bottom, align 4
  %94 = load float, ptr %sy1, align 4
  %95 = load float, ptr %y_top.addr, align 4
  %sub61 = fsub float %94, %95
  %sub62 = fsub float %93, %sub61
  store float %sub62, ptr %sy1, align 4
  %96 = load float, ptr %sy0, align 4
  store float %96, ptr %t, align 4
  %97 = load float, ptr %sy1, align 4
  store float %97, ptr %sy0, align 4
  %98 = load float, ptr %t, align 4
  store float %98, ptr %sy1, align 4
  %99 = load float, ptr %x_bottom, align 4
  store float %99, ptr %t, align 4
  %100 = load float, ptr %x_top, align 4
  store float %100, ptr %x_bottom, align 4
  %101 = load float, ptr %t, align 4
  store float %101, ptr %x_top, align 4
  %102 = load float, ptr %dx, align 4
  %fneg = fneg float %102
  store float %fneg, ptr %dx, align 4
  %103 = load float, ptr %dy, align 4
  %fneg63 = fneg float %103
  store float %fneg63, ptr %dy, align 4
  %104 = load float, ptr %x011, align 4
  store float %104, ptr %t, align 4
  %105 = load float, ptr %xb, align 4
  store float %105, ptr %x011, align 4
  %106 = load float, ptr %t, align 4
  store float %106, ptr %xb, align 4
  br label %if.end64

if.end64:                                         ; preds = %if.then58, %if.else55
  br label %do.body65

do.body65:                                        ; preds = %if.end64
  br label %do.end66

do.end66:                                         ; preds = %do.body65
  br label %do.body67

do.body67:                                        ; preds = %do.end66
  br label %do.end68

do.end68:                                         ; preds = %do.body67
  %107 = load float, ptr %x_top, align 4
  %conv69 = fptosi float %107 to i32
  store i32 %conv69, ptr %x1, align 4
  %108 = load float, ptr %x_bottom, align 4
  %conv70 = fptosi float %108 to i32
  store i32 %conv70, ptr %x2, align 4
  %109 = load float, ptr %y_top.addr, align 4
  %110 = load float, ptr %dy, align 4
  %111 = load i32, ptr %x1, align 4
  %add71 = add nsw i32 %111, 1
  %conv72 = sitofp i32 %add71 to float
  %112 = load float, ptr %x011, align 4
  %sub73 = fsub float %conv72, %112
  %113 = call float @llvm.fmuladd.f32(float %110, float %sub73, float %109)
  store float %113, ptr %y_crossing, align 4
  %114 = load float, ptr %y_top.addr, align 4
  %115 = load float, ptr %dy, align 4
  %116 = load i32, ptr %x2, align 4
  %conv75 = sitofp i32 %116 to float
  %117 = load float, ptr %x011, align 4
  %sub76 = fsub float %conv75, %117
  %118 = call float @llvm.fmuladd.f32(float %115, float %sub76, float %114)
  store float %118, ptr %y_final, align 4
  %119 = load float, ptr %y_crossing, align 4
  %120 = load float, ptr %y_bottom, align 4
  %cmp78 = fcmp ogt float %119, %120
  br i1 %cmp78, label %if.then79, label %if.end80

if.then79:                                        ; preds = %do.end68
  %121 = load float, ptr %y_bottom, align 4
  store float %121, ptr %y_crossing, align 4
  br label %if.end80

if.end80:                                         ; preds = %if.then79, %do.end68
  %122 = load ptr, ptr %e.addr, align 8
  %direction81 = getelementptr inbounds %struct.stbtt__active_edge, ptr %122, i32 0, i32 4
  %123 = load float, ptr %direction81, align 4
  store float %123, ptr %sign, align 4
  %124 = load float, ptr %sign, align 4
  %125 = load float, ptr %y_crossing, align 4
  %126 = load float, ptr %sy0, align 4
  %sub82 = fsub float %125, %126
  %mul83 = fmul float %124, %sub82
  store float %mul83, ptr %area, align 4
  %127 = load float, ptr %area, align 4
  %128 = load i32, ptr %x1, align 4
  %add84 = add nsw i32 %128, 1
  %conv85 = sitofp i32 %add84 to float
  %129 = load float, ptr %x_top, align 4
  %sub86 = fsub float %conv85, %129
  %call87 = call noundef float @_ZL26stbtt__sized_triangle_areaff(float noundef %127, float noundef %sub86)
  %130 = load ptr, ptr %scanline.addr, align 8
  %131 = load i32, ptr %x1, align 4
  %idxprom88 = sext i32 %131 to i64
  %arrayidx89 = getelementptr inbounds float, ptr %130, i64 %idxprom88
  %132 = load float, ptr %arrayidx89, align 4
  %add90 = fadd float %132, %call87
  store float %add90, ptr %arrayidx89, align 4
  %133 = load float, ptr %y_final, align 4
  %134 = load float, ptr %y_bottom, align 4
  %cmp91 = fcmp ogt float %133, %134
  br i1 %cmp91, label %if.then92, label %if.end100

if.then92:                                        ; preds = %if.end80
  %135 = load i32, ptr %x2, align 4
  %136 = load i32, ptr %x1, align 4
  %add93 = add nsw i32 %136, 1
  %sub94 = sub nsw i32 %135, %add93
  store i32 %sub94, ptr %denom, align 4
  %137 = load float, ptr %y_bottom, align 4
  store float %137, ptr %y_final, align 4
  %138 = load i32, ptr %denom, align 4
  %cmp95 = icmp ne i32 %138, 0
  br i1 %cmp95, label %if.then96, label %if.end99

if.then96:                                        ; preds = %if.then92
  %139 = load float, ptr %y_final, align 4
  %140 = load float, ptr %y_crossing, align 4
  %sub97 = fsub float %139, %140
  %141 = load i32, ptr %denom, align 4
  %conv98 = sitofp i32 %141 to float
  %div = fdiv float %sub97, %conv98
  store float %div, ptr %dy, align 4
  br label %if.end99

if.end99:                                         ; preds = %if.then96, %if.then92
  br label %if.end100

if.end100:                                        ; preds = %if.end99, %if.end80
  %142 = load float, ptr %sign, align 4
  %143 = load float, ptr %dy, align 4
  %mul101 = fmul float %142, %143
  %mul102 = fmul float %mul101, 1.000000e+00
  store float %mul102, ptr %step, align 4
  %144 = load i32, ptr %x1, align 4
  %add103 = add nsw i32 %144, 1
  store i32 %add103, ptr %x56, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end100
  %145 = load i32, ptr %x56, align 4
  %146 = load i32, ptr %x2, align 4
  %cmp104 = icmp slt i32 %145, %146
  br i1 %cmp104, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %147 = load float, ptr %area, align 4
  %148 = load float, ptr %step, align 4
  %div105 = fdiv float %148, 2.000000e+00
  %add106 = fadd float %147, %div105
  %149 = load ptr, ptr %scanline.addr, align 8
  %150 = load i32, ptr %x56, align 4
  %idxprom107 = sext i32 %150 to i64
  %arrayidx108 = getelementptr inbounds float, ptr %149, i64 %idxprom107
  %151 = load float, ptr %arrayidx108, align 4
  %add109 = fadd float %151, %add106
  store float %add109, ptr %arrayidx108, align 4
  %152 = load float, ptr %step, align 4
  %153 = load float, ptr %area, align 4
  %add110 = fadd float %153, %152
  store float %add110, ptr %area, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %154 = load i32, ptr %x56, align 4
  %inc = add nsw i32 %154, 1
  store i32 %inc, ptr %x56, align 4
  br label %for.cond, !llvm.loop !160

for.end:                                          ; preds = %for.cond
  br label %do.body111

do.body111:                                       ; preds = %for.end
  br label %do.end112

do.end112:                                        ; preds = %do.body111
  br label %do.body113

do.body113:                                       ; preds = %do.end112
  br label %do.end114

do.end114:                                        ; preds = %do.body113
  %155 = load float, ptr %area, align 4
  %156 = load float, ptr %sign, align 4
  %157 = load float, ptr %sy1, align 4
  %158 = load float, ptr %y_final, align 4
  %sub115 = fsub float %157, %158
  %159 = load i32, ptr %x2, align 4
  %conv116 = sitofp i32 %159 to float
  %160 = load i32, ptr %x2, align 4
  %conv117 = sitofp i32 %160 to float
  %add118 = fadd float %conv117, 1.000000e+00
  %161 = load float, ptr %x_bottom, align 4
  %162 = load i32, ptr %x2, align 4
  %conv119 = sitofp i32 %162 to float
  %add120 = fadd float %conv119, 1.000000e+00
  %call121 = call noundef float @_ZL30stbtt__position_trapezoid_areafffff(float noundef %sub115, float noundef %conv116, float noundef %add118, float noundef %161, float noundef %add120)
  %163 = call float @llvm.fmuladd.f32(float %156, float %call121, float %155)
  %164 = load ptr, ptr %scanline.addr, align 8
  %165 = load i32, ptr %x2, align 4
  %idxprom123 = sext i32 %165 to i64
  %arrayidx124 = getelementptr inbounds float, ptr %164, i64 %idxprom123
  %166 = load float, ptr %arrayidx124, align 4
  %add125 = fadd float %166, %163
  store float %add125, ptr %arrayidx124, align 4
  %167 = load float, ptr %sign, align 4
  %168 = load float, ptr %sy1, align 4
  %169 = load float, ptr %sy0, align 4
  %sub126 = fsub float %168, %169
  %170 = load ptr, ptr %scanline_fill.addr, align 8
  %171 = load i32, ptr %x2, align 4
  %idxprom128 = sext i32 %171 to i64
  %arrayidx129 = getelementptr inbounds float, ptr %170, i64 %idxprom128
  %172 = load float, ptr %arrayidx129, align 4
  %173 = call float @llvm.fmuladd.f32(float %167, float %sub126, float %172)
  store float %173, ptr %arrayidx129, align 4
  br label %if.end130

if.end130:                                        ; preds = %do.end114, %do.end46
  br label %if.end189

if.else131:                                       ; preds = %land.lhs.true35, %land.lhs.true32, %land.lhs.true, %if.end29
  store i32 0, ptr %x132, align 4
  br label %for.cond133

for.cond133:                                      ; preds = %for.inc186, %if.else131
  %174 = load i32, ptr %x132, align 4
  %175 = load i32, ptr %len.addr, align 4
  %cmp134 = icmp slt i32 %174, %175
  br i1 %cmp134, label %for.body135, label %for.end188

for.body135:                                      ; preds = %for.cond133
  %176 = load float, ptr %y_top.addr, align 4
  store float %176, ptr %y0, align 4
  %177 = load i32, ptr %x132, align 4
  %conv137 = sitofp i32 %177 to float
  store float %conv137, ptr %x1136, align 4
  %178 = load i32, ptr %x132, align 4
  %add139 = add nsw i32 %178, 1
  %conv140 = sitofp i32 %add139 to float
  store float %conv140, ptr %x2138, align 4
  %179 = load float, ptr %xb, align 4
  store float %179, ptr %x3, align 4
  %180 = load float, ptr %y_bottom, align 4
  store float %180, ptr %y3, align 4
  %181 = load i32, ptr %x132, align 4
  %conv141 = sitofp i32 %181 to float
  %182 = load float, ptr %x011, align 4
  %sub142 = fsub float %conv141, %182
  %183 = load float, ptr %dx, align 4
  %div143 = fdiv float %sub142, %183
  %184 = load float, ptr %y_top.addr, align 4
  %add144 = fadd float %div143, %184
  store float %add144, ptr %y1, align 4
  %185 = load i32, ptr %x132, align 4
  %add145 = add nsw i32 %185, 1
  %conv146 = sitofp i32 %add145 to float
  %186 = load float, ptr %x011, align 4
  %sub147 = fsub float %conv146, %186
  %187 = load float, ptr %dx, align 4
  %div148 = fdiv float %sub147, %187
  %188 = load float, ptr %y_top.addr, align 4
  %add149 = fadd float %div148, %188
  store float %add149, ptr %y2, align 4
  %189 = load float, ptr %x011, align 4
  %190 = load float, ptr %x1136, align 4
  %cmp150 = fcmp olt float %189, %190
  br i1 %cmp150, label %land.lhs.true151, label %if.else154

land.lhs.true151:                                 ; preds = %for.body135
  %191 = load float, ptr %x3, align 4
  %192 = load float, ptr %x2138, align 4
  %cmp152 = fcmp ogt float %191, %192
  br i1 %cmp152, label %if.then153, label %if.else154

if.then153:                                       ; preds = %land.lhs.true151
  %193 = load ptr, ptr %scanline.addr, align 8
  %194 = load i32, ptr %x132, align 4
  %195 = load ptr, ptr %e.addr, align 8
  %196 = load float, ptr %x011, align 4
  %197 = load float, ptr %y0, align 4
  %198 = load float, ptr %x1136, align 4
  %199 = load float, ptr %y1, align 4
  call void @_ZL26stbtt__handle_clipped_edgePfiP18stbtt__active_edgeffff(ptr noundef %193, i32 noundef %194, ptr noundef %195, float noundef %196, float noundef %197, float noundef %198, float noundef %199)
  %200 = load ptr, ptr %scanline.addr, align 8
  %201 = load i32, ptr %x132, align 4
  %202 = load ptr, ptr %e.addr, align 8
  %203 = load float, ptr %x1136, align 4
  %204 = load float, ptr %y1, align 4
  %205 = load float, ptr %x2138, align 4
  %206 = load float, ptr %y2, align 4
  call void @_ZL26stbtt__handle_clipped_edgePfiP18stbtt__active_edgeffff(ptr noundef %200, i32 noundef %201, ptr noundef %202, float noundef %203, float noundef %204, float noundef %205, float noundef %206)
  %207 = load ptr, ptr %scanline.addr, align 8
  %208 = load i32, ptr %x132, align 4
  %209 = load ptr, ptr %e.addr, align 8
  %210 = load float, ptr %x2138, align 4
  %211 = load float, ptr %y2, align 4
  %212 = load float, ptr %x3, align 4
  %213 = load float, ptr %y3, align 4
  call void @_ZL26stbtt__handle_clipped_edgePfiP18stbtt__active_edgeffff(ptr noundef %207, i32 noundef %208, ptr noundef %209, float noundef %210, float noundef %211, float noundef %212, float noundef %213)
  br label %if.end185

if.else154:                                       ; preds = %land.lhs.true151, %for.body135
  %214 = load float, ptr %x3, align 4
  %215 = load float, ptr %x1136, align 4
  %cmp155 = fcmp olt float %214, %215
  br i1 %cmp155, label %land.lhs.true156, label %if.else159

land.lhs.true156:                                 ; preds = %if.else154
  %216 = load float, ptr %x011, align 4
  %217 = load float, ptr %x2138, align 4
  %cmp157 = fcmp ogt float %216, %217
  br i1 %cmp157, label %if.then158, label %if.else159

if.then158:                                       ; preds = %land.lhs.true156
  %218 = load ptr, ptr %scanline.addr, align 8
  %219 = load i32, ptr %x132, align 4
  %220 = load ptr, ptr %e.addr, align 8
  %221 = load float, ptr %x011, align 4
  %222 = load float, ptr %y0, align 4
  %223 = load float, ptr %x2138, align 4
  %224 = load float, ptr %y2, align 4
  call void @_ZL26stbtt__handle_clipped_edgePfiP18stbtt__active_edgeffff(ptr noundef %218, i32 noundef %219, ptr noundef %220, float noundef %221, float noundef %222, float noundef %223, float noundef %224)
  %225 = load ptr, ptr %scanline.addr, align 8
  %226 = load i32, ptr %x132, align 4
  %227 = load ptr, ptr %e.addr, align 8
  %228 = load float, ptr %x2138, align 4
  %229 = load float, ptr %y2, align 4
  %230 = load float, ptr %x1136, align 4
  %231 = load float, ptr %y1, align 4
  call void @_ZL26stbtt__handle_clipped_edgePfiP18stbtt__active_edgeffff(ptr noundef %225, i32 noundef %226, ptr noundef %227, float noundef %228, float noundef %229, float noundef %230, float noundef %231)
  %232 = load ptr, ptr %scanline.addr, align 8
  %233 = load i32, ptr %x132, align 4
  %234 = load ptr, ptr %e.addr, align 8
  %235 = load float, ptr %x1136, align 4
  %236 = load float, ptr %y1, align 4
  %237 = load float, ptr %x3, align 4
  %238 = load float, ptr %y3, align 4
  call void @_ZL26stbtt__handle_clipped_edgePfiP18stbtt__active_edgeffff(ptr noundef %232, i32 noundef %233, ptr noundef %234, float noundef %235, float noundef %236, float noundef %237, float noundef %238)
  br label %if.end184

if.else159:                                       ; preds = %land.lhs.true156, %if.else154
  %239 = load float, ptr %x011, align 4
  %240 = load float, ptr %x1136, align 4
  %cmp160 = fcmp olt float %239, %240
  br i1 %cmp160, label %land.lhs.true161, label %if.else164

land.lhs.true161:                                 ; preds = %if.else159
  %241 = load float, ptr %x3, align 4
  %242 = load float, ptr %x1136, align 4
  %cmp162 = fcmp ogt float %241, %242
  br i1 %cmp162, label %if.then163, label %if.else164

if.then163:                                       ; preds = %land.lhs.true161
  %243 = load ptr, ptr %scanline.addr, align 8
  %244 = load i32, ptr %x132, align 4
  %245 = load ptr, ptr %e.addr, align 8
  %246 = load float, ptr %x011, align 4
  %247 = load float, ptr %y0, align 4
  %248 = load float, ptr %x1136, align 4
  %249 = load float, ptr %y1, align 4
  call void @_ZL26stbtt__handle_clipped_edgePfiP18stbtt__active_edgeffff(ptr noundef %243, i32 noundef %244, ptr noundef %245, float noundef %246, float noundef %247, float noundef %248, float noundef %249)
  %250 = load ptr, ptr %scanline.addr, align 8
  %251 = load i32, ptr %x132, align 4
  %252 = load ptr, ptr %e.addr, align 8
  %253 = load float, ptr %x1136, align 4
  %254 = load float, ptr %y1, align 4
  %255 = load float, ptr %x3, align 4
  %256 = load float, ptr %y3, align 4
  call void @_ZL26stbtt__handle_clipped_edgePfiP18stbtt__active_edgeffff(ptr noundef %250, i32 noundef %251, ptr noundef %252, float noundef %253, float noundef %254, float noundef %255, float noundef %256)
  br label %if.end183

if.else164:                                       ; preds = %land.lhs.true161, %if.else159
  %257 = load float, ptr %x3, align 4
  %258 = load float, ptr %x1136, align 4
  %cmp165 = fcmp olt float %257, %258
  br i1 %cmp165, label %land.lhs.true166, label %if.else169

land.lhs.true166:                                 ; preds = %if.else164
  %259 = load float, ptr %x011, align 4
  %260 = load float, ptr %x1136, align 4
  %cmp167 = fcmp ogt float %259, %260
  br i1 %cmp167, label %if.then168, label %if.else169

if.then168:                                       ; preds = %land.lhs.true166
  %261 = load ptr, ptr %scanline.addr, align 8
  %262 = load i32, ptr %x132, align 4
  %263 = load ptr, ptr %e.addr, align 8
  %264 = load float, ptr %x011, align 4
  %265 = load float, ptr %y0, align 4
  %266 = load float, ptr %x1136, align 4
  %267 = load float, ptr %y1, align 4
  call void @_ZL26stbtt__handle_clipped_edgePfiP18stbtt__active_edgeffff(ptr noundef %261, i32 noundef %262, ptr noundef %263, float noundef %264, float noundef %265, float noundef %266, float noundef %267)
  %268 = load ptr, ptr %scanline.addr, align 8
  %269 = load i32, ptr %x132, align 4
  %270 = load ptr, ptr %e.addr, align 8
  %271 = load float, ptr %x1136, align 4
  %272 = load float, ptr %y1, align 4
  %273 = load float, ptr %x3, align 4
  %274 = load float, ptr %y3, align 4
  call void @_ZL26stbtt__handle_clipped_edgePfiP18stbtt__active_edgeffff(ptr noundef %268, i32 noundef %269, ptr noundef %270, float noundef %271, float noundef %272, float noundef %273, float noundef %274)
  br label %if.end182

if.else169:                                       ; preds = %land.lhs.true166, %if.else164
  %275 = load float, ptr %x011, align 4
  %276 = load float, ptr %x2138, align 4
  %cmp170 = fcmp olt float %275, %276
  br i1 %cmp170, label %land.lhs.true171, label %if.else174

land.lhs.true171:                                 ; preds = %if.else169
  %277 = load float, ptr %x3, align 4
  %278 = load float, ptr %x2138, align 4
  %cmp172 = fcmp ogt float %277, %278
  br i1 %cmp172, label %if.then173, label %if.else174

if.then173:                                       ; preds = %land.lhs.true171
  %279 = load ptr, ptr %scanline.addr, align 8
  %280 = load i32, ptr %x132, align 4
  %281 = load ptr, ptr %e.addr, align 8
  %282 = load float, ptr %x011, align 4
  %283 = load float, ptr %y0, align 4
  %284 = load float, ptr %x2138, align 4
  %285 = load float, ptr %y2, align 4
  call void @_ZL26stbtt__handle_clipped_edgePfiP18stbtt__active_edgeffff(ptr noundef %279, i32 noundef %280, ptr noundef %281, float noundef %282, float noundef %283, float noundef %284, float noundef %285)
  %286 = load ptr, ptr %scanline.addr, align 8
  %287 = load i32, ptr %x132, align 4
  %288 = load ptr, ptr %e.addr, align 8
  %289 = load float, ptr %x2138, align 4
  %290 = load float, ptr %y2, align 4
  %291 = load float, ptr %x3, align 4
  %292 = load float, ptr %y3, align 4
  call void @_ZL26stbtt__handle_clipped_edgePfiP18stbtt__active_edgeffff(ptr noundef %286, i32 noundef %287, ptr noundef %288, float noundef %289, float noundef %290, float noundef %291, float noundef %292)
  br label %if.end181

if.else174:                                       ; preds = %land.lhs.true171, %if.else169
  %293 = load float, ptr %x3, align 4
  %294 = load float, ptr %x2138, align 4
  %cmp175 = fcmp olt float %293, %294
  br i1 %cmp175, label %land.lhs.true176, label %if.else179

land.lhs.true176:                                 ; preds = %if.else174
  %295 = load float, ptr %x011, align 4
  %296 = load float, ptr %x2138, align 4
  %cmp177 = fcmp ogt float %295, %296
  br i1 %cmp177, label %if.then178, label %if.else179

if.then178:                                       ; preds = %land.lhs.true176
  %297 = load ptr, ptr %scanline.addr, align 8
  %298 = load i32, ptr %x132, align 4
  %299 = load ptr, ptr %e.addr, align 8
  %300 = load float, ptr %x011, align 4
  %301 = load float, ptr %y0, align 4
  %302 = load float, ptr %x2138, align 4
  %303 = load float, ptr %y2, align 4
  call void @_ZL26stbtt__handle_clipped_edgePfiP18stbtt__active_edgeffff(ptr noundef %297, i32 noundef %298, ptr noundef %299, float noundef %300, float noundef %301, float noundef %302, float noundef %303)
  %304 = load ptr, ptr %scanline.addr, align 8
  %305 = load i32, ptr %x132, align 4
  %306 = load ptr, ptr %e.addr, align 8
  %307 = load float, ptr %x2138, align 4
  %308 = load float, ptr %y2, align 4
  %309 = load float, ptr %x3, align 4
  %310 = load float, ptr %y3, align 4
  call void @_ZL26stbtt__handle_clipped_edgePfiP18stbtt__active_edgeffff(ptr noundef %304, i32 noundef %305, ptr noundef %306, float noundef %307, float noundef %308, float noundef %309, float noundef %310)
  br label %if.end180

if.else179:                                       ; preds = %land.lhs.true176, %if.else174
  %311 = load ptr, ptr %scanline.addr, align 8
  %312 = load i32, ptr %x132, align 4
  %313 = load ptr, ptr %e.addr, align 8
  %314 = load float, ptr %x011, align 4
  %315 = load float, ptr %y0, align 4
  %316 = load float, ptr %x3, align 4
  %317 = load float, ptr %y3, align 4
  call void @_ZL26stbtt__handle_clipped_edgePfiP18stbtt__active_edgeffff(ptr noundef %311, i32 noundef %312, ptr noundef %313, float noundef %314, float noundef %315, float noundef %316, float noundef %317)
  br label %if.end180

if.end180:                                        ; preds = %if.else179, %if.then178
  br label %if.end181

if.end181:                                        ; preds = %if.end180, %if.then173
  br label %if.end182

if.end182:                                        ; preds = %if.end181, %if.then168
  br label %if.end183

if.end183:                                        ; preds = %if.end182, %if.then163
  br label %if.end184

if.end184:                                        ; preds = %if.end183, %if.then158
  br label %if.end185

if.end185:                                        ; preds = %if.end184, %if.then153
  br label %for.inc186

for.inc186:                                       ; preds = %if.end185
  %318 = load i32, ptr %x132, align 4
  %inc187 = add nsw i32 %318, 1
  store i32 %inc187, ptr %x132, align 4
  br label %for.cond133, !llvm.loop !161

for.end188:                                       ; preds = %for.cond133
  br label %if.end189

if.end189:                                        ; preds = %for.end188, %if.end130
  br label %if.end190

if.end190:                                        ; preds = %if.end189, %if.end9
  %319 = load ptr, ptr %e.addr, align 8
  %next = getelementptr inbounds %struct.stbtt__active_edge, ptr %319, i32 0, i32 0
  %320 = load ptr, ptr %next, align 8
  store ptr %320, ptr %e.addr, align 8
  br label %while.cond, !llvm.loop !162

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL20stbtt__hheap_cleanupP12stbtt__hheapPv(ptr noundef %hh, ptr noundef %userdata) #4 {
entry:
  %hh.addr = alloca ptr, align 8
  %userdata.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  %n = alloca ptr, align 8
  store ptr %hh, ptr %hh.addr, align 8
  store ptr %userdata, ptr %userdata.addr, align 8
  %0 = load ptr, ptr %hh.addr, align 8
  %head = getelementptr inbounds %struct.stbtt__hheap, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %head, align 8
  store ptr %1, ptr %c, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %2 = load ptr, ptr %c, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load ptr, ptr %c, align 8
  %next = getelementptr inbounds %struct.stbtt__hheap_chunk, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %next, align 8
  store ptr %4, ptr %n, align 8
  %5 = load ptr, ptr %c, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %5)
  %6 = load ptr, ptr %n, align 8
  store ptr %6, ptr %c, align 8
  br label %while.cond, !llvm.loop !163

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define internal noundef ptr @_ZL18stbtt__hheap_allocP12stbtt__hheapmPv(ptr noundef %hh, i64 noundef %size, ptr noundef %userdata) #4 {
entry:
  %retval = alloca ptr, align 8
  %hh.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %userdata.addr = alloca ptr, align 8
  %p = alloca ptr, align 8
  %count = alloca i32, align 4
  %c = alloca ptr, align 8
  store ptr %hh, ptr %hh.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store ptr %userdata, ptr %userdata.addr, align 8
  %0 = load ptr, ptr %hh.addr, align 8
  %first_free = getelementptr inbounds %struct.stbtt__hheap, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %first_free, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %hh.addr, align 8
  %first_free1 = getelementptr inbounds %struct.stbtt__hheap, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %first_free1, align 8
  store ptr %3, ptr %p, align 8
  %4 = load ptr, ptr %p, align 8
  %5 = load ptr, ptr %4, align 8
  %6 = load ptr, ptr %hh.addr, align 8
  %first_free2 = getelementptr inbounds %struct.stbtt__hheap, ptr %6, i32 0, i32 1
  store ptr %5, ptr %first_free2, align 8
  %7 = load ptr, ptr %p, align 8
  store ptr %7, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %8 = load ptr, ptr %hh.addr, align 8
  %num_remaining_in_head_chunk = getelementptr inbounds %struct.stbtt__hheap, ptr %8, i32 0, i32 2
  %9 = load i32, ptr %num_remaining_in_head_chunk, align 8
  %cmp = icmp eq i32 %9, 0
  br i1 %cmp, label %if.then3, label %if.end11

if.then3:                                         ; preds = %if.else
  %10 = load i64, ptr %size.addr, align 8
  %cmp4 = icmp ult i64 %10, 32
  br i1 %cmp4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then3
  br label %cond.end

cond.false:                                       ; preds = %if.then3
  %11 = load i64, ptr %size.addr, align 8
  %cmp5 = icmp ult i64 %11, 128
  %cond = select i1 %cmp5, i32 800, i32 100
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond6 = phi i32 [ 2000, %cond.true ], [ %cond, %cond.false ]
  store i32 %cond6, ptr %count, align 4
  %12 = load i64, ptr %size.addr, align 8
  %13 = load i32, ptr %count, align 4
  %conv = sext i32 %13 to i64
  %mul = mul i64 %12, %conv
  %add = add i64 8, %mul
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %add)
  store ptr %call, ptr %c, align 8
  %14 = load ptr, ptr %c, align 8
  %cmp7 = icmp eq ptr %14, null
  br i1 %cmp7, label %if.then8, label %if.end

if.then8:                                         ; preds = %cond.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end
  %15 = load ptr, ptr %hh.addr, align 8
  %head = getelementptr inbounds %struct.stbtt__hheap, ptr %15, i32 0, i32 0
  %16 = load ptr, ptr %head, align 8
  %17 = load ptr, ptr %c, align 8
  %next = getelementptr inbounds %struct.stbtt__hheap_chunk, ptr %17, i32 0, i32 0
  store ptr %16, ptr %next, align 8
  %18 = load ptr, ptr %c, align 8
  %19 = load ptr, ptr %hh.addr, align 8
  %head9 = getelementptr inbounds %struct.stbtt__hheap, ptr %19, i32 0, i32 0
  store ptr %18, ptr %head9, align 8
  %20 = load i32, ptr %count, align 4
  %21 = load ptr, ptr %hh.addr, align 8
  %num_remaining_in_head_chunk10 = getelementptr inbounds %struct.stbtt__hheap, ptr %21, i32 0, i32 2
  store i32 %20, ptr %num_remaining_in_head_chunk10, align 8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.else
  %22 = load ptr, ptr %hh.addr, align 8
  %num_remaining_in_head_chunk12 = getelementptr inbounds %struct.stbtt__hheap, ptr %22, i32 0, i32 2
  %23 = load i32, ptr %num_remaining_in_head_chunk12, align 8
  %dec = add nsw i32 %23, -1
  store i32 %dec, ptr %num_remaining_in_head_chunk12, align 8
  %24 = load ptr, ptr %hh.addr, align 8
  %head13 = getelementptr inbounds %struct.stbtt__hheap, ptr %24, i32 0, i32 0
  %25 = load ptr, ptr %head13, align 8
  %add.ptr = getelementptr inbounds i8, ptr %25, i64 8
  %26 = load i64, ptr %size.addr, align 8
  %27 = load ptr, ptr %hh.addr, align 8
  %num_remaining_in_head_chunk14 = getelementptr inbounds %struct.stbtt__hheap, ptr %27, i32 0, i32 2
  %28 = load i32, ptr %num_remaining_in_head_chunk14, align 8
  %conv15 = sext i32 %28 to i64
  %mul16 = mul i64 %26, %conv15
  %add.ptr17 = getelementptr inbounds i8, ptr %add.ptr, i64 %mul16
  store ptr %add.ptr17, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end11, %if.then8, %if.then
  %29 = load ptr, ptr %retval, align 8
  ret ptr %29
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZL26stbtt__handle_clipped_edgePfiP18stbtt__active_edgeffff(ptr noundef %scanline, i32 noundef %x, ptr noundef %e, float noundef %x0, float noundef %y0, float noundef %x1, float noundef %y1) #2 {
entry:
  %scanline.addr = alloca ptr, align 8
  %x.addr = alloca i32, align 4
  %e.addr = alloca ptr, align 8
  %x0.addr = alloca float, align 4
  %y0.addr = alloca float, align 4
  %x1.addr = alloca float, align 4
  %y1.addr = alloca float, align 4
  store ptr %scanline, ptr %scanline.addr, align 8
  store i32 %x, ptr %x.addr, align 4
  store ptr %e, ptr %e.addr, align 8
  store float %x0, ptr %x0.addr, align 4
  store float %y0, ptr %y0.addr, align 4
  store float %x1, ptr %x1.addr, align 4
  store float %y1, ptr %y1.addr, align 4
  %0 = load float, ptr %y0.addr, align 4
  %1 = load float, ptr %y1.addr, align 4
  %cmp = fcmp oeq float %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end92

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body1

do.body1:                                         ; preds = %do.end
  br label %do.end2

do.end2:                                          ; preds = %do.body1
  %2 = load float, ptr %y0.addr, align 4
  %3 = load ptr, ptr %e.addr, align 8
  %ey = getelementptr inbounds %struct.stbtt__active_edge, ptr %3, i32 0, i32 6
  %4 = load float, ptr %ey, align 4
  %cmp3 = fcmp ogt float %2, %4
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %do.end2
  br label %if.end92

if.end5:                                          ; preds = %do.end2
  %5 = load float, ptr %y1.addr, align 4
  %6 = load ptr, ptr %e.addr, align 8
  %sy = getelementptr inbounds %struct.stbtt__active_edge, ptr %6, i32 0, i32 5
  %7 = load float, ptr %sy, align 8
  %cmp6 = fcmp olt float %5, %7
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end5
  br label %if.end92

if.end8:                                          ; preds = %if.end5
  %8 = load float, ptr %y0.addr, align 4
  %9 = load ptr, ptr %e.addr, align 8
  %sy9 = getelementptr inbounds %struct.stbtt__active_edge, ptr %9, i32 0, i32 5
  %10 = load float, ptr %sy9, align 8
  %cmp10 = fcmp olt float %8, %10
  br i1 %cmp10, label %if.then11, label %if.end16

if.then11:                                        ; preds = %if.end8
  %11 = load float, ptr %x1.addr, align 4
  %12 = load float, ptr %x0.addr, align 4
  %sub = fsub float %11, %12
  %13 = load ptr, ptr %e.addr, align 8
  %sy12 = getelementptr inbounds %struct.stbtt__active_edge, ptr %13, i32 0, i32 5
  %14 = load float, ptr %sy12, align 8
  %15 = load float, ptr %y0.addr, align 4
  %sub13 = fsub float %14, %15
  %mul = fmul float %sub, %sub13
  %16 = load float, ptr %y1.addr, align 4
  %17 = load float, ptr %y0.addr, align 4
  %sub14 = fsub float %16, %17
  %div = fdiv float %mul, %sub14
  %18 = load float, ptr %x0.addr, align 4
  %add = fadd float %18, %div
  store float %add, ptr %x0.addr, align 4
  %19 = load ptr, ptr %e.addr, align 8
  %sy15 = getelementptr inbounds %struct.stbtt__active_edge, ptr %19, i32 0, i32 5
  %20 = load float, ptr %sy15, align 8
  store float %20, ptr %y0.addr, align 4
  br label %if.end16

if.end16:                                         ; preds = %if.then11, %if.end8
  %21 = load float, ptr %y1.addr, align 4
  %22 = load ptr, ptr %e.addr, align 8
  %ey17 = getelementptr inbounds %struct.stbtt__active_edge, ptr %22, i32 0, i32 6
  %23 = load float, ptr %ey17, align 4
  %cmp18 = fcmp ogt float %21, %23
  br i1 %cmp18, label %if.then19, label %if.end28

if.then19:                                        ; preds = %if.end16
  %24 = load float, ptr %x1.addr, align 4
  %25 = load float, ptr %x0.addr, align 4
  %sub20 = fsub float %24, %25
  %26 = load ptr, ptr %e.addr, align 8
  %ey21 = getelementptr inbounds %struct.stbtt__active_edge, ptr %26, i32 0, i32 6
  %27 = load float, ptr %ey21, align 4
  %28 = load float, ptr %y1.addr, align 4
  %sub22 = fsub float %27, %28
  %mul23 = fmul float %sub20, %sub22
  %29 = load float, ptr %y1.addr, align 4
  %30 = load float, ptr %y0.addr, align 4
  %sub24 = fsub float %29, %30
  %div25 = fdiv float %mul23, %sub24
  %31 = load float, ptr %x1.addr, align 4
  %add26 = fadd float %31, %div25
  store float %add26, ptr %x1.addr, align 4
  %32 = load ptr, ptr %e.addr, align 8
  %ey27 = getelementptr inbounds %struct.stbtt__active_edge, ptr %32, i32 0, i32 6
  %33 = load float, ptr %ey27, align 4
  store float %33, ptr %y1.addr, align 4
  br label %if.end28

if.end28:                                         ; preds = %if.then19, %if.end16
  %34 = load float, ptr %x0.addr, align 4
  %35 = load i32, ptr %x.addr, align 4
  %conv = sitofp i32 %35 to float
  %cmp29 = fcmp oeq float %34, %conv
  br i1 %cmp29, label %if.then30, label %if.else

if.then30:                                        ; preds = %if.end28
  br label %do.body31

do.body31:                                        ; preds = %if.then30
  br label %do.end32

do.end32:                                         ; preds = %do.body31
  br label %if.end58

if.else:                                          ; preds = %if.end28
  %36 = load float, ptr %x0.addr, align 4
  %37 = load i32, ptr %x.addr, align 4
  %add33 = add nsw i32 %37, 1
  %conv34 = sitofp i32 %add33 to float
  %cmp35 = fcmp oeq float %36, %conv34
  br i1 %cmp35, label %if.then36, label %if.else39

if.then36:                                        ; preds = %if.else
  br label %do.body37

do.body37:                                        ; preds = %if.then36
  br label %do.end38

do.end38:                                         ; preds = %do.body37
  br label %if.end57

if.else39:                                        ; preds = %if.else
  %38 = load float, ptr %x0.addr, align 4
  %39 = load i32, ptr %x.addr, align 4
  %conv40 = sitofp i32 %39 to float
  %cmp41 = fcmp ole float %38, %conv40
  br i1 %cmp41, label %if.then42, label %if.else45

if.then42:                                        ; preds = %if.else39
  br label %do.body43

do.body43:                                        ; preds = %if.then42
  br label %do.end44

do.end44:                                         ; preds = %do.body43
  br label %if.end56

if.else45:                                        ; preds = %if.else39
  %40 = load float, ptr %x0.addr, align 4
  %41 = load i32, ptr %x.addr, align 4
  %add46 = add nsw i32 %41, 1
  %conv47 = sitofp i32 %add46 to float
  %cmp48 = fcmp oge float %40, %conv47
  br i1 %cmp48, label %if.then49, label %if.else52

if.then49:                                        ; preds = %if.else45
  br label %do.body50

do.body50:                                        ; preds = %if.then49
  br label %do.end51

do.end51:                                         ; preds = %do.body50
  br label %if.end55

if.else52:                                        ; preds = %if.else45
  br label %do.body53

do.body53:                                        ; preds = %if.else52
  br label %do.end54

do.end54:                                         ; preds = %do.body53
  br label %if.end55

if.end55:                                         ; preds = %do.end54, %do.end51
  br label %if.end56

if.end56:                                         ; preds = %if.end55, %do.end44
  br label %if.end57

if.end57:                                         ; preds = %if.end56, %do.end38
  br label %if.end58

if.end58:                                         ; preds = %if.end57, %do.end32
  %42 = load float, ptr %x0.addr, align 4
  %43 = load i32, ptr %x.addr, align 4
  %conv59 = sitofp i32 %43 to float
  %cmp60 = fcmp ole float %42, %conv59
  br i1 %cmp60, label %land.lhs.true, label %if.else66

land.lhs.true:                                    ; preds = %if.end58
  %44 = load float, ptr %x1.addr, align 4
  %45 = load i32, ptr %x.addr, align 4
  %conv61 = sitofp i32 %45 to float
  %cmp62 = fcmp ole float %44, %conv61
  br i1 %cmp62, label %if.then63, label %if.else66

if.then63:                                        ; preds = %land.lhs.true
  %46 = load ptr, ptr %e.addr, align 8
  %direction = getelementptr inbounds %struct.stbtt__active_edge, ptr %46, i32 0, i32 4
  %47 = load float, ptr %direction, align 4
  %48 = load float, ptr %y1.addr, align 4
  %49 = load float, ptr %y0.addr, align 4
  %sub64 = fsub float %48, %49
  %50 = load ptr, ptr %scanline.addr, align 8
  %51 = load i32, ptr %x.addr, align 4
  %idxprom = sext i32 %51 to i64
  %arrayidx = getelementptr inbounds float, ptr %50, i64 %idxprom
  %52 = load float, ptr %arrayidx, align 4
  %53 = call float @llvm.fmuladd.f32(float %47, float %sub64, float %52)
  store float %53, ptr %arrayidx, align 4
  br label %if.end92

if.else66:                                        ; preds = %land.lhs.true, %if.end58
  %54 = load float, ptr %x0.addr, align 4
  %55 = load i32, ptr %x.addr, align 4
  %add67 = add nsw i32 %55, 1
  %conv68 = sitofp i32 %add67 to float
  %cmp69 = fcmp oge float %54, %conv68
  br i1 %cmp69, label %land.lhs.true70, label %if.else75

land.lhs.true70:                                  ; preds = %if.else66
  %56 = load float, ptr %x1.addr, align 4
  %57 = load i32, ptr %x.addr, align 4
  %add71 = add nsw i32 %57, 1
  %conv72 = sitofp i32 %add71 to float
  %cmp73 = fcmp oge float %56, %conv72
  br i1 %cmp73, label %if.then74, label %if.else75

if.then74:                                        ; preds = %land.lhs.true70
  br label %if.end91

if.else75:                                        ; preds = %land.lhs.true70, %if.else66
  br label %do.body76

do.body76:                                        ; preds = %if.else75
  br label %do.end77

do.end77:                                         ; preds = %do.body76
  %58 = load ptr, ptr %e.addr, align 8
  %direction78 = getelementptr inbounds %struct.stbtt__active_edge, ptr %58, i32 0, i32 4
  %59 = load float, ptr %direction78, align 4
  %60 = load float, ptr %y1.addr, align 4
  %61 = load float, ptr %y0.addr, align 4
  %sub79 = fsub float %60, %61
  %mul80 = fmul float %59, %sub79
  %62 = load float, ptr %x0.addr, align 4
  %63 = load i32, ptr %x.addr, align 4
  %conv81 = sitofp i32 %63 to float
  %sub82 = fsub float %62, %conv81
  %64 = load float, ptr %x1.addr, align 4
  %65 = load i32, ptr %x.addr, align 4
  %conv83 = sitofp i32 %65 to float
  %sub84 = fsub float %64, %conv83
  %add85 = fadd float %sub82, %sub84
  %div86 = fdiv float %add85, 2.000000e+00
  %sub87 = fsub float 1.000000e+00, %div86
  %66 = load ptr, ptr %scanline.addr, align 8
  %67 = load i32, ptr %x.addr, align 4
  %idxprom89 = sext i32 %67 to i64
  %arrayidx90 = getelementptr inbounds float, ptr %66, i64 %idxprom89
  %68 = load float, ptr %arrayidx90, align 4
  %69 = call float @llvm.fmuladd.f32(float %mul80, float %sub87, float %68)
  store float %69, ptr %arrayidx90, align 4
  br label %if.end91

if.end91:                                         ; preds = %do.end77, %if.then74
  br label %if.end92

if.end92:                                         ; preds = %if.end91, %if.then63, %if.then7, %if.then4, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define internal noundef float @_ZL30stbtt__position_trapezoid_areafffff(float noundef %height, float noundef %tx0, float noundef %tx1, float noundef %bx0, float noundef %bx1) #4 {
entry:
  %height.addr = alloca float, align 4
  %tx0.addr = alloca float, align 4
  %tx1.addr = alloca float, align 4
  %bx0.addr = alloca float, align 4
  %bx1.addr = alloca float, align 4
  store float %height, ptr %height.addr, align 4
  store float %tx0, ptr %tx0.addr, align 4
  store float %tx1, ptr %tx1.addr, align 4
  store float %bx0, ptr %bx0.addr, align 4
  store float %bx1, ptr %bx1.addr, align 4
  %0 = load float, ptr %height.addr, align 4
  %1 = load float, ptr %tx1.addr, align 4
  %2 = load float, ptr %tx0.addr, align 4
  %sub = fsub float %1, %2
  %3 = load float, ptr %bx1.addr, align 4
  %4 = load float, ptr %bx0.addr, align 4
  %sub1 = fsub float %3, %4
  %call = call noundef float @_ZL27stbtt__sized_trapezoid_areafff(float noundef %0, float noundef %sub, float noundef %sub1)
  ret float %call
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef float @_ZL26stbtt__sized_triangle_areaff(float noundef %height, float noundef %width) #2 {
entry:
  %height.addr = alloca float, align 4
  %width.addr = alloca float, align 4
  store float %height, ptr %height.addr, align 4
  store float %width, ptr %width.addr, align 4
  %0 = load float, ptr %height.addr, align 4
  %1 = load float, ptr %width.addr, align 4
  %mul = fmul float %0, %1
  %div = fdiv float %mul, 2.000000e+00
  ret float %div
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef float @_ZL27stbtt__sized_trapezoid_areafff(float noundef %height, float noundef %top_width, float noundef %bottom_width) #2 {
entry:
  %height.addr = alloca float, align 4
  %top_width.addr = alloca float, align 4
  %bottom_width.addr = alloca float, align 4
  store float %height, ptr %height.addr, align 4
  store float %top_width, ptr %top_width.addr, align 4
  store float %bottom_width, ptr %bottom_width.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body1

do.body1:                                         ; preds = %do.end
  br label %do.end2

do.end2:                                          ; preds = %do.body1
  %0 = load float, ptr %top_width.addr, align 4
  %1 = load float, ptr %bottom_width.addr, align 4
  %add = fadd float %0, %1
  %div = fdiv float %add, 2.000000e+00
  %2 = load float, ptr %height.addr, align 4
  %mul = fmul float %div, %2
  ret float %mul
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN18ImFontBuildSrcDataD2Ev(ptr noundef nonnull align 8 dereferenceable(272) %this) unnamed_addr #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %GlyphsList = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %this1, i32 0, i32 9
  call void @_ZN8ImVectorIiED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %GlyphsList) #12
  %GlyphsSet = getelementptr inbounds %struct.ImFontBuildSrcData, ptr %this1, i32 0, i32 8
  call void @_ZN11ImBitVectorD2Ev(ptr noundef nonnull align 8 dereferenceable(16) %GlyphsSet) #12
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI18ImFontBuildSrcDataE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.14, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Capacity = getelementptr inbounds %struct.ImVector.14, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.14, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data2 = getelementptr inbounds %struct.ImVector.14, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
  %Data3 = getelementptr inbounds %struct.ImVector.14, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorIiED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.16, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Data2 = getelementptr inbounds %struct.ImVector.16, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  invoke void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %invoke.cont, %entry
  ret void

terminate.lpad:                                   ; preds = %if.then
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #13
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN11ImBitVectorD2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Storage = getelementptr inbounds %struct.ImBitVector, ptr %this1, i32 0, i32 0
  call void @_ZN8ImVectorIjED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %Storage) #12
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr void @_ZN8ImVectorIjED2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #2 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.13, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Data2 = getelementptr inbounds %struct.ImVector.13, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  invoke void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %invoke.cont, %entry
  ret void

terminate.lpad:                                   ; preds = %if.then
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #13
  unreachable
}

; Function Attrs: mustprogress uwtable
define internal void @_ZL7ImQsortPvmmPFiPKvS1_E(ptr noundef %base, i64 noundef %count, i64 noundef %size_of_element, ptr noundef %compare_func) #4 {
entry:
  %base.addr = alloca ptr, align 8
  %count.addr = alloca i64, align 8
  %size_of_element.addr = alloca i64, align 8
  %compare_func.addr = alloca ptr, align 8
  store ptr %base, ptr %base.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 %size_of_element, ptr %size_of_element.addr, align 8
  store ptr %compare_func, ptr %compare_func.addr, align 8
  %0 = load i64, ptr %count.addr, align 8
  %cmp = icmp ugt i64 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %base.addr, align 8
  %2 = load i64, ptr %count.addr, align 8
  %3 = load i64, ptr %size_of_element.addr, align 8
  %4 = load ptr, ptr %compare_func.addr, align 8
  call void @qsort(ptr noundef %1, i64 noundef %2, i64 noundef %3, ptr noundef %4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZL19rect_height_comparePKvS0_(ptr noundef %a, ptr noundef %b) #2 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %p = alloca ptr, align 8
  %q = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  store ptr %0, ptr %p, align 8
  %1 = load ptr, ptr %b.addr, align 8
  store ptr %1, ptr %q, align 8
  %2 = load ptr, ptr %p, align 8
  %h = getelementptr inbounds %struct.stbrp_rect, ptr %2, i32 0, i32 2
  %3 = load i32, ptr %h, align 4
  %4 = load ptr, ptr %q, align 8
  %h1 = getelementptr inbounds %struct.stbrp_rect, ptr %4, i32 0, i32 2
  %5 = load i32, ptr %h1, align 4
  %cmp = icmp sgt i32 %3, %5
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load ptr, ptr %p, align 8
  %h2 = getelementptr inbounds %struct.stbrp_rect, ptr %6, i32 0, i32 2
  %7 = load i32, ptr %h2, align 4
  %8 = load ptr, ptr %q, align 8
  %h3 = getelementptr inbounds %struct.stbrp_rect, ptr %8, i32 0, i32 2
  %9 = load i32, ptr %h3, align 4
  %cmp4 = icmp slt i32 %7, %9
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  %10 = load ptr, ptr %p, align 8
  %w = getelementptr inbounds %struct.stbrp_rect, ptr %10, i32 0, i32 1
  %11 = load i32, ptr %w, align 4
  %12 = load ptr, ptr %q, align 8
  %w7 = getelementptr inbounds %struct.stbrp_rect, ptr %12, i32 0, i32 1
  %13 = load i32, ptr %w7, align 4
  %cmp8 = icmp sgt i32 %11, %13
  br i1 %cmp8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end6
  br label %cond.end

cond.false:                                       ; preds = %if.end6
  %14 = load ptr, ptr %p, align 8
  %w9 = getelementptr inbounds %struct.stbrp_rect, ptr %14, i32 0, i32 1
  %15 = load i32, ptr %w9, align 4
  %16 = load ptr, ptr %q, align 8
  %w10 = getelementptr inbounds %struct.stbrp_rect, ptr %16, i32 0, i32 1
  %17 = load i32, ptr %w10, align 4
  %cmp11 = icmp slt i32 %15, %17
  %conv = zext i1 %cmp11 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ -1, %cond.true ], [ %conv, %cond.false ]
  store i32 %cond, ptr %retval, align 4
  br label %return

return:                                           ; preds = %cond.end, %if.then5, %if.then
  %18 = load i32, ptr %retval, align 4
  ret i32 %18
}

; Function Attrs: mustprogress uwtable
define internal { i64, ptr } @_ZL29stbrp__skyline_pack_rectangleP13stbrp_contextii(ptr noundef %context, i32 noundef %width, i32 noundef %height) #4 {
entry:
  %retval = alloca %struct.stbrp__findresult, align 8
  %context.addr = alloca ptr, align 8
  %width.addr = alloca i32, align 4
  %height.addr = alloca i32, align 4
  %node = alloca ptr, align 8
  %cur = alloca ptr, align 8
  %next17 = alloca ptr, align 8
  %next28 = alloca ptr, align 8
  store ptr %context, ptr %context.addr, align 8
  store i32 %width, ptr %width.addr, align 4
  store i32 %height, ptr %height.addr, align 4
  %0 = load ptr, ptr %context.addr, align 8
  %1 = load i32, ptr %width.addr, align 4
  %2 = load i32, ptr %height.addr, align 4
  %call = call { i64, ptr } @_ZL28stbrp__skyline_find_best_posP13stbrp_contextii(ptr noundef %0, i32 noundef %1, i32 noundef %2)
  %3 = getelementptr inbounds { i64, ptr }, ptr %retval, i32 0, i32 0
  %4 = extractvalue { i64, ptr } %call, 0
  store i64 %4, ptr %3, align 8
  %5 = getelementptr inbounds { i64, ptr }, ptr %retval, i32 0, i32 1
  %6 = extractvalue { i64, ptr } %call, 1
  store ptr %6, ptr %5, align 8
  %prev_link = getelementptr inbounds %struct.stbrp__findresult, ptr %retval, i32 0, i32 2
  %7 = load ptr, ptr %prev_link, align 8
  %cmp = icmp eq ptr %7, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %y = getelementptr inbounds %struct.stbrp__findresult, ptr %retval, i32 0, i32 1
  %8 = load i32, ptr %y, align 4
  %9 = load i32, ptr %height.addr, align 4
  %add = add nsw i32 %8, %9
  %10 = load ptr, ptr %context.addr, align 8
  %height1 = getelementptr inbounds %struct.stbrp_context, ptr %10, i32 0, i32 1
  %11 = load i32, ptr %height1, align 4
  %cmp2 = icmp sgt i32 %add, %11
  br i1 %cmp2, label %if.then, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %lor.lhs.false
  %12 = load ptr, ptr %context.addr, align 8
  %free_head = getelementptr inbounds %struct.stbrp_context, ptr %12, i32 0, i32 7
  %13 = load ptr, ptr %free_head, align 8
  %cmp4 = icmp eq ptr %13, null
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false3, %lor.lhs.false, %entry
  %prev_link5 = getelementptr inbounds %struct.stbrp__findresult, ptr %retval, i32 0, i32 2
  store ptr null, ptr %prev_link5, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false3
  %14 = load ptr, ptr %context.addr, align 8
  %free_head6 = getelementptr inbounds %struct.stbrp_context, ptr %14, i32 0, i32 7
  %15 = load ptr, ptr %free_head6, align 8
  store ptr %15, ptr %node, align 8
  %x = getelementptr inbounds %struct.stbrp__findresult, ptr %retval, i32 0, i32 0
  %16 = load i32, ptr %x, align 8
  %17 = load ptr, ptr %node, align 8
  %x7 = getelementptr inbounds %struct.stbrp_node, ptr %17, i32 0, i32 0
  store i32 %16, ptr %x7, align 8
  %y8 = getelementptr inbounds %struct.stbrp__findresult, ptr %retval, i32 0, i32 1
  %18 = load i32, ptr %y8, align 4
  %19 = load i32, ptr %height.addr, align 4
  %add9 = add nsw i32 %18, %19
  %20 = load ptr, ptr %node, align 8
  %y10 = getelementptr inbounds %struct.stbrp_node, ptr %20, i32 0, i32 1
  store i32 %add9, ptr %y10, align 4
  %21 = load ptr, ptr %node, align 8
  %next = getelementptr inbounds %struct.stbrp_node, ptr %21, i32 0, i32 2
  %22 = load ptr, ptr %next, align 8
  %23 = load ptr, ptr %context.addr, align 8
  %free_head11 = getelementptr inbounds %struct.stbrp_context, ptr %23, i32 0, i32 7
  store ptr %22, ptr %free_head11, align 8
  %prev_link12 = getelementptr inbounds %struct.stbrp__findresult, ptr %retval, i32 0, i32 2
  %24 = load ptr, ptr %prev_link12, align 8
  %25 = load ptr, ptr %24, align 8
  store ptr %25, ptr %cur, align 8
  %26 = load ptr, ptr %cur, align 8
  %x13 = getelementptr inbounds %struct.stbrp_node, ptr %26, i32 0, i32 0
  %27 = load i32, ptr %x13, align 8
  %x14 = getelementptr inbounds %struct.stbrp__findresult, ptr %retval, i32 0, i32 0
  %28 = load i32, ptr %x14, align 8
  %cmp15 = icmp slt i32 %27, %28
  br i1 %cmp15, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.end
  %29 = load ptr, ptr %cur, align 8
  %next18 = getelementptr inbounds %struct.stbrp_node, ptr %29, i32 0, i32 2
  %30 = load ptr, ptr %next18, align 8
  store ptr %30, ptr %next17, align 8
  %31 = load ptr, ptr %node, align 8
  %32 = load ptr, ptr %cur, align 8
  %next19 = getelementptr inbounds %struct.stbrp_node, ptr %32, i32 0, i32 2
  store ptr %31, ptr %next19, align 8
  %33 = load ptr, ptr %next17, align 8
  store ptr %33, ptr %cur, align 8
  br label %if.end21

if.else:                                          ; preds = %if.end
  %34 = load ptr, ptr %node, align 8
  %prev_link20 = getelementptr inbounds %struct.stbrp__findresult, ptr %retval, i32 0, i32 2
  %35 = load ptr, ptr %prev_link20, align 8
  store ptr %34, ptr %35, align 8
  br label %if.end21

if.end21:                                         ; preds = %if.else, %if.then16
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end21
  %36 = load ptr, ptr %cur, align 8
  %next22 = getelementptr inbounds %struct.stbrp_node, ptr %36, i32 0, i32 2
  %37 = load ptr, ptr %next22, align 8
  %tobool = icmp ne ptr %37, null
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %38 = load ptr, ptr %cur, align 8
  %next23 = getelementptr inbounds %struct.stbrp_node, ptr %38, i32 0, i32 2
  %39 = load ptr, ptr %next23, align 8
  %x24 = getelementptr inbounds %struct.stbrp_node, ptr %39, i32 0, i32 0
  %40 = load i32, ptr %x24, align 8
  %x25 = getelementptr inbounds %struct.stbrp__findresult, ptr %retval, i32 0, i32 0
  %41 = load i32, ptr %x25, align 8
  %42 = load i32, ptr %width.addr, align 4
  %add26 = add nsw i32 %41, %42
  %cmp27 = icmp sle i32 %40, %add26
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %43 = phi i1 [ false, %while.cond ], [ %cmp27, %land.rhs ]
  br i1 %43, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %44 = load ptr, ptr %cur, align 8
  %next29 = getelementptr inbounds %struct.stbrp_node, ptr %44, i32 0, i32 2
  %45 = load ptr, ptr %next29, align 8
  store ptr %45, ptr %next28, align 8
  %46 = load ptr, ptr %context.addr, align 8
  %free_head30 = getelementptr inbounds %struct.stbrp_context, ptr %46, i32 0, i32 7
  %47 = load ptr, ptr %free_head30, align 8
  %48 = load ptr, ptr %cur, align 8
  %next31 = getelementptr inbounds %struct.stbrp_node, ptr %48, i32 0, i32 2
  store ptr %47, ptr %next31, align 8
  %49 = load ptr, ptr %cur, align 8
  %50 = load ptr, ptr %context.addr, align 8
  %free_head32 = getelementptr inbounds %struct.stbrp_context, ptr %50, i32 0, i32 7
  store ptr %49, ptr %free_head32, align 8
  %51 = load ptr, ptr %next28, align 8
  store ptr %51, ptr %cur, align 8
  br label %while.cond, !llvm.loop !164

while.end:                                        ; preds = %land.end
  %52 = load ptr, ptr %cur, align 8
  %53 = load ptr, ptr %node, align 8
  %next33 = getelementptr inbounds %struct.stbrp_node, ptr %53, i32 0, i32 2
  store ptr %52, ptr %next33, align 8
  %54 = load ptr, ptr %cur, align 8
  %x34 = getelementptr inbounds %struct.stbrp_node, ptr %54, i32 0, i32 0
  %55 = load i32, ptr %x34, align 8
  %x35 = getelementptr inbounds %struct.stbrp__findresult, ptr %retval, i32 0, i32 0
  %56 = load i32, ptr %x35, align 8
  %57 = load i32, ptr %width.addr, align 4
  %add36 = add nsw i32 %56, %57
  %cmp37 = icmp slt i32 %55, %add36
  br i1 %cmp37, label %if.then38, label %if.end42

if.then38:                                        ; preds = %while.end
  %x39 = getelementptr inbounds %struct.stbrp__findresult, ptr %retval, i32 0, i32 0
  %58 = load i32, ptr %x39, align 8
  %59 = load i32, ptr %width.addr, align 4
  %add40 = add nsw i32 %58, %59
  %60 = load ptr, ptr %cur, align 8
  %x41 = getelementptr inbounds %struct.stbrp_node, ptr %60, i32 0, i32 0
  store i32 %add40, ptr %x41, align 8
  br label %if.end42

if.end42:                                         ; preds = %if.then38, %while.end
  br label %return

return:                                           ; preds = %if.end42, %if.then
  %61 = load { i64, ptr }, ptr %retval, align 8
  ret { i64, ptr } %61
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZL19rect_original_orderPKvS0_(ptr noundef %a, ptr noundef %b) #2 {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %p = alloca ptr, align 8
  %q = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  store ptr %0, ptr %p, align 8
  %1 = load ptr, ptr %b.addr, align 8
  store ptr %1, ptr %q, align 8
  %2 = load ptr, ptr %p, align 8
  %was_packed = getelementptr inbounds %struct.stbrp_rect, ptr %2, i32 0, i32 5
  %3 = load i32, ptr %was_packed, align 4
  %4 = load ptr, ptr %q, align 8
  %was_packed1 = getelementptr inbounds %struct.stbrp_rect, ptr %4, i32 0, i32 5
  %5 = load i32, ptr %was_packed1, align 4
  %cmp = icmp slt i32 %3, %5
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load ptr, ptr %p, align 8
  %was_packed2 = getelementptr inbounds %struct.stbrp_rect, ptr %6, i32 0, i32 5
  %7 = load i32, ptr %was_packed2, align 4
  %8 = load ptr, ptr %q, align 8
  %was_packed3 = getelementptr inbounds %struct.stbrp_rect, ptr %8, i32 0, i32 5
  %9 = load i32, ptr %was_packed3, align 4
  %cmp4 = icmp sgt i32 %7, %9
  %conv = zext i1 %cmp4 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ -1, %cond.true ], [ %conv, %cond.false ]
  ret i32 %cond
}

declare void @qsort(ptr noundef, i64 noundef, i64 noundef, ptr noundef) #1

; Function Attrs: mustprogress uwtable
define internal { i64, ptr } @_ZL28stbrp__skyline_find_best_posP13stbrp_contextii(ptr noundef %c, i32 noundef %width, i32 noundef %height) #4 {
entry:
  %retval = alloca %struct.stbrp__findresult, align 8
  %c.addr = alloca ptr, align 8
  %width.addr = alloca i32, align 4
  %height.addr = alloca i32, align 4
  %best_waste = alloca i32, align 4
  %best_x = alloca i32, align 4
  %best_y = alloca i32, align 4
  %prev = alloca ptr, align 8
  %node = alloca ptr, align 8
  %tail = alloca ptr, align 8
  %best = alloca ptr, align 8
  %y11 = alloca i32, align 4
  %waste = alloca i32, align 4
  %xpos = alloca i32, align 4
  %y49 = alloca i32, align 4
  %waste50 = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  store i32 %width, ptr %width.addr, align 4
  store i32 %height, ptr %height.addr, align 4
  store i32 1073741824, ptr %best_waste, align 4
  store i32 1073741824, ptr %best_y, align 4
  store ptr null, ptr %best, align 8
  %0 = load i32, ptr %width.addr, align 4
  %1 = load ptr, ptr %c.addr, align 8
  %align = getelementptr inbounds %struct.stbrp_context, ptr %1, i32 0, i32 2
  %2 = load i32, ptr %align, align 8
  %add = add nsw i32 %0, %2
  %sub = sub nsw i32 %add, 1
  store i32 %sub, ptr %width.addr, align 4
  %3 = load i32, ptr %width.addr, align 4
  %4 = load ptr, ptr %c.addr, align 8
  %align1 = getelementptr inbounds %struct.stbrp_context, ptr %4, i32 0, i32 2
  %5 = load i32, ptr %align1, align 8
  %rem = srem i32 %3, %5
  %6 = load i32, ptr %width.addr, align 4
  %sub2 = sub nsw i32 %6, %rem
  store i32 %sub2, ptr %width.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %7 = load i32, ptr %width.addr, align 4
  %8 = load ptr, ptr %c.addr, align 8
  %width3 = getelementptr inbounds %struct.stbrp_context, ptr %8, i32 0, i32 0
  %9 = load i32, ptr %width3, align 8
  %cmp = icmp sgt i32 %7, %9
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.end
  %10 = load i32, ptr %height.addr, align 4
  %11 = load ptr, ptr %c.addr, align 8
  %height4 = getelementptr inbounds %struct.stbrp_context, ptr %11, i32 0, i32 1
  %12 = load i32, ptr %height4, align 4
  %cmp5 = icmp sgt i32 %10, %12
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %do.end
  %prev_link = getelementptr inbounds %struct.stbrp__findresult, ptr %retval, i32 0, i32 2
  store ptr null, ptr %prev_link, align 8
  %y = getelementptr inbounds %struct.stbrp__findresult, ptr %retval, i32 0, i32 1
  store i32 0, ptr %y, align 4
  %x = getelementptr inbounds %struct.stbrp__findresult, ptr %retval, i32 0, i32 0
  store i32 0, ptr %x, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %13 = load ptr, ptr %c.addr, align 8
  %active_head = getelementptr inbounds %struct.stbrp_context, ptr %13, i32 0, i32 6
  %14 = load ptr, ptr %active_head, align 8
  store ptr %14, ptr %node, align 8
  %15 = load ptr, ptr %c.addr, align 8
  %active_head6 = getelementptr inbounds %struct.stbrp_context, ptr %15, i32 0, i32 6
  store ptr %active_head6, ptr %prev, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end29, %if.end
  %16 = load ptr, ptr %node, align 8
  %x7 = getelementptr inbounds %struct.stbrp_node, ptr %16, i32 0, i32 0
  %17 = load i32, ptr %x7, align 8
  %18 = load i32, ptr %width.addr, align 4
  %add8 = add nsw i32 %17, %18
  %19 = load ptr, ptr %c.addr, align 8
  %width9 = getelementptr inbounds %struct.stbrp_context, ptr %19, i32 0, i32 0
  %20 = load i32, ptr %width9, align 8
  %cmp10 = icmp sle i32 %add8, %20
  br i1 %cmp10, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %21 = load ptr, ptr %c.addr, align 8
  %22 = load ptr, ptr %node, align 8
  %23 = load ptr, ptr %node, align 8
  %x12 = getelementptr inbounds %struct.stbrp_node, ptr %23, i32 0, i32 0
  %24 = load i32, ptr %x12, align 8
  %25 = load i32, ptr %width.addr, align 4
  %call = call noundef i32 @_ZL25stbrp__skyline_find_min_yP13stbrp_contextP10stbrp_nodeiiPi(ptr noundef %21, ptr noundef %22, i32 noundef %24, i32 noundef %25, ptr noundef %waste)
  store i32 %call, ptr %y11, align 4
  %26 = load ptr, ptr %c.addr, align 8
  %heuristic = getelementptr inbounds %struct.stbrp_context, ptr %26, i32 0, i32 4
  %27 = load i32, ptr %heuristic, align 8
  %cmp13 = icmp eq i32 %27, 0
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %while.body
  %28 = load i32, ptr %y11, align 4
  %29 = load i32, ptr %best_y, align 4
  %cmp15 = icmp slt i32 %28, %29
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.then14
  %30 = load i32, ptr %y11, align 4
  store i32 %30, ptr %best_y, align 4
  %31 = load ptr, ptr %prev, align 8
  store ptr %31, ptr %best, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %if.then14
  br label %if.end29

if.else:                                          ; preds = %while.body
  %32 = load i32, ptr %y11, align 4
  %33 = load i32, ptr %height.addr, align 4
  %add18 = add nsw i32 %32, %33
  %34 = load ptr, ptr %c.addr, align 8
  %height19 = getelementptr inbounds %struct.stbrp_context, ptr %34, i32 0, i32 1
  %35 = load i32, ptr %height19, align 4
  %cmp20 = icmp sle i32 %add18, %35
  br i1 %cmp20, label %if.then21, label %if.end28

if.then21:                                        ; preds = %if.else
  %36 = load i32, ptr %y11, align 4
  %37 = load i32, ptr %best_y, align 4
  %cmp22 = icmp slt i32 %36, %37
  br i1 %cmp22, label %if.then26, label %lor.lhs.false23

lor.lhs.false23:                                  ; preds = %if.then21
  %38 = load i32, ptr %y11, align 4
  %39 = load i32, ptr %best_y, align 4
  %cmp24 = icmp eq i32 %38, %39
  br i1 %cmp24, label %land.lhs.true, label %if.end27

land.lhs.true:                                    ; preds = %lor.lhs.false23
  %40 = load i32, ptr %waste, align 4
  %41 = load i32, ptr %best_waste, align 4
  %cmp25 = icmp slt i32 %40, %41
  br i1 %cmp25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %land.lhs.true, %if.then21
  %42 = load i32, ptr %y11, align 4
  store i32 %42, ptr %best_y, align 4
  %43 = load i32, ptr %waste, align 4
  store i32 %43, ptr %best_waste, align 4
  %44 = load ptr, ptr %prev, align 8
  store ptr %44, ptr %best, align 8
  br label %if.end27

if.end27:                                         ; preds = %if.then26, %land.lhs.true, %lor.lhs.false23
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.else
  br label %if.end29

if.end29:                                         ; preds = %if.end28, %if.end17
  %45 = load ptr, ptr %node, align 8
  %next = getelementptr inbounds %struct.stbrp_node, ptr %45, i32 0, i32 2
  store ptr %next, ptr %prev, align 8
  %46 = load ptr, ptr %node, align 8
  %next30 = getelementptr inbounds %struct.stbrp_node, ptr %46, i32 0, i32 2
  %47 = load ptr, ptr %next30, align 8
  store ptr %47, ptr %node, align 8
  br label %while.cond, !llvm.loop !165

while.end:                                        ; preds = %while.cond
  %48 = load ptr, ptr %best, align 8
  %cmp31 = icmp eq ptr %48, null
  br i1 %cmp31, label %cond.true, label %cond.false

cond.true:                                        ; preds = %while.end
  br label %cond.end

cond.false:                                       ; preds = %while.end
  %49 = load ptr, ptr %best, align 8
  %50 = load ptr, ptr %49, align 8
  %x32 = getelementptr inbounds %struct.stbrp_node, ptr %50, i32 0, i32 0
  %51 = load i32, ptr %x32, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 0, %cond.true ], [ %51, %cond.false ]
  store i32 %cond, ptr %best_x, align 4
  %52 = load ptr, ptr %c.addr, align 8
  %heuristic33 = getelementptr inbounds %struct.stbrp_context, ptr %52, i32 0, i32 4
  %53 = load i32, ptr %heuristic33, align 8
  %cmp34 = icmp eq i32 %53, 1
  br i1 %cmp34, label %if.then35, label %if.end83

if.then35:                                        ; preds = %cond.end
  %54 = load ptr, ptr %c.addr, align 8
  %active_head36 = getelementptr inbounds %struct.stbrp_context, ptr %54, i32 0, i32 6
  %55 = load ptr, ptr %active_head36, align 8
  store ptr %55, ptr %tail, align 8
  %56 = load ptr, ptr %c.addr, align 8
  %active_head37 = getelementptr inbounds %struct.stbrp_context, ptr %56, i32 0, i32 6
  %57 = load ptr, ptr %active_head37, align 8
  store ptr %57, ptr %node, align 8
  %58 = load ptr, ptr %c.addr, align 8
  %active_head38 = getelementptr inbounds %struct.stbrp_context, ptr %58, i32 0, i32 6
  store ptr %active_head38, ptr %prev, align 8
  br label %while.cond39

while.cond39:                                     ; preds = %while.body42, %if.then35
  %59 = load ptr, ptr %tail, align 8
  %x40 = getelementptr inbounds %struct.stbrp_node, ptr %59, i32 0, i32 0
  %60 = load i32, ptr %x40, align 8
  %61 = load i32, ptr %width.addr, align 4
  %cmp41 = icmp slt i32 %60, %61
  br i1 %cmp41, label %while.body42, label %while.end44

while.body42:                                     ; preds = %while.cond39
  %62 = load ptr, ptr %tail, align 8
  %next43 = getelementptr inbounds %struct.stbrp_node, ptr %62, i32 0, i32 2
  %63 = load ptr, ptr %next43, align 8
  store ptr %63, ptr %tail, align 8
  br label %while.cond39, !llvm.loop !166

while.end44:                                      ; preds = %while.cond39
  br label %while.cond45

while.cond45:                                     ; preds = %if.end80, %while.end44
  %64 = load ptr, ptr %tail, align 8
  %tobool = icmp ne ptr %64, null
  br i1 %tobool, label %while.body46, label %while.end82

while.body46:                                     ; preds = %while.cond45
  %65 = load ptr, ptr %tail, align 8
  %x47 = getelementptr inbounds %struct.stbrp_node, ptr %65, i32 0, i32 0
  %66 = load i32, ptr %x47, align 8
  %67 = load i32, ptr %width.addr, align 4
  %sub48 = sub nsw i32 %66, %67
  store i32 %sub48, ptr %xpos, align 4
  br label %do.body51

do.body51:                                        ; preds = %while.body46
  br label %do.end52

do.end52:                                         ; preds = %do.body51
  br label %while.cond53

while.cond53:                                     ; preds = %while.body57, %do.end52
  %68 = load ptr, ptr %node, align 8
  %next54 = getelementptr inbounds %struct.stbrp_node, ptr %68, i32 0, i32 2
  %69 = load ptr, ptr %next54, align 8
  %x55 = getelementptr inbounds %struct.stbrp_node, ptr %69, i32 0, i32 0
  %70 = load i32, ptr %x55, align 8
  %71 = load i32, ptr %xpos, align 4
  %cmp56 = icmp sle i32 %70, %71
  br i1 %cmp56, label %while.body57, label %while.end60

while.body57:                                     ; preds = %while.cond53
  %72 = load ptr, ptr %node, align 8
  %next58 = getelementptr inbounds %struct.stbrp_node, ptr %72, i32 0, i32 2
  store ptr %next58, ptr %prev, align 8
  %73 = load ptr, ptr %node, align 8
  %next59 = getelementptr inbounds %struct.stbrp_node, ptr %73, i32 0, i32 2
  %74 = load ptr, ptr %next59, align 8
  store ptr %74, ptr %node, align 8
  br label %while.cond53, !llvm.loop !167

while.end60:                                      ; preds = %while.cond53
  br label %do.body61

do.body61:                                        ; preds = %while.end60
  br label %do.end62

do.end62:                                         ; preds = %do.body61
  %75 = load ptr, ptr %c.addr, align 8
  %76 = load ptr, ptr %node, align 8
  %77 = load i32, ptr %xpos, align 4
  %78 = load i32, ptr %width.addr, align 4
  %call63 = call noundef i32 @_ZL25stbrp__skyline_find_min_yP13stbrp_contextP10stbrp_nodeiiPi(ptr noundef %75, ptr noundef %76, i32 noundef %77, i32 noundef %78, ptr noundef %waste50)
  store i32 %call63, ptr %y49, align 4
  %79 = load i32, ptr %y49, align 4
  %80 = load i32, ptr %height.addr, align 4
  %add64 = add nsw i32 %79, %80
  %81 = load ptr, ptr %c.addr, align 8
  %height65 = getelementptr inbounds %struct.stbrp_context, ptr %81, i32 0, i32 1
  %82 = load i32, ptr %height65, align 4
  %cmp66 = icmp sle i32 %add64, %82
  br i1 %cmp66, label %if.then67, label %if.end80

if.then67:                                        ; preds = %do.end62
  %83 = load i32, ptr %y49, align 4
  %84 = load i32, ptr %best_y, align 4
  %cmp68 = icmp sle i32 %83, %84
  br i1 %cmp68, label %if.then69, label %if.end79

if.then69:                                        ; preds = %if.then67
  %85 = load i32, ptr %y49, align 4
  %86 = load i32, ptr %best_y, align 4
  %cmp70 = icmp slt i32 %85, %86
  br i1 %cmp70, label %if.then77, label %lor.lhs.false71

lor.lhs.false71:                                  ; preds = %if.then69
  %87 = load i32, ptr %waste50, align 4
  %88 = load i32, ptr %best_waste, align 4
  %cmp72 = icmp slt i32 %87, %88
  br i1 %cmp72, label %if.then77, label %lor.lhs.false73

lor.lhs.false73:                                  ; preds = %lor.lhs.false71
  %89 = load i32, ptr %waste50, align 4
  %90 = load i32, ptr %best_waste, align 4
  %cmp74 = icmp eq i32 %89, %90
  br i1 %cmp74, label %land.lhs.true75, label %if.end78

land.lhs.true75:                                  ; preds = %lor.lhs.false73
  %91 = load i32, ptr %xpos, align 4
  %92 = load i32, ptr %best_x, align 4
  %cmp76 = icmp slt i32 %91, %92
  br i1 %cmp76, label %if.then77, label %if.end78

if.then77:                                        ; preds = %land.lhs.true75, %lor.lhs.false71, %if.then69
  %93 = load i32, ptr %xpos, align 4
  store i32 %93, ptr %best_x, align 4
  %94 = load i32, ptr %y49, align 4
  store i32 %94, ptr %best_y, align 4
  %95 = load i32, ptr %waste50, align 4
  store i32 %95, ptr %best_waste, align 4
  %96 = load ptr, ptr %prev, align 8
  store ptr %96, ptr %best, align 8
  br label %if.end78

if.end78:                                         ; preds = %if.then77, %land.lhs.true75, %lor.lhs.false73
  br label %if.end79

if.end79:                                         ; preds = %if.end78, %if.then67
  br label %if.end80

if.end80:                                         ; preds = %if.end79, %do.end62
  %97 = load ptr, ptr %tail, align 8
  %next81 = getelementptr inbounds %struct.stbrp_node, ptr %97, i32 0, i32 2
  %98 = load ptr, ptr %next81, align 8
  store ptr %98, ptr %tail, align 8
  br label %while.cond45, !llvm.loop !168

while.end82:                                      ; preds = %while.cond45
  br label %if.end83

if.end83:                                         ; preds = %while.end82, %cond.end
  %99 = load ptr, ptr %best, align 8
  %prev_link84 = getelementptr inbounds %struct.stbrp__findresult, ptr %retval, i32 0, i32 2
  store ptr %99, ptr %prev_link84, align 8
  %100 = load i32, ptr %best_x, align 4
  %x85 = getelementptr inbounds %struct.stbrp__findresult, ptr %retval, i32 0, i32 0
  store i32 %100, ptr %x85, align 8
  %101 = load i32, ptr %best_y, align 4
  %y86 = getelementptr inbounds %struct.stbrp__findresult, ptr %retval, i32 0, i32 1
  store i32 %101, ptr %y86, align 4
  br label %return

return:                                           ; preds = %if.end83, %if.then
  %102 = load { i64, ptr }, ptr %retval, align 8
  ret { i64, ptr } %102
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZL25stbrp__skyline_find_min_yP13stbrp_contextP10stbrp_nodeiiPi(ptr noundef %c, ptr noundef %first, i32 noundef %x0, i32 noundef %width, ptr noundef %pwaste) #2 {
entry:
  %c.addr = alloca ptr, align 8
  %first.addr = alloca ptr, align 8
  %x0.addr = alloca i32, align 4
  %width.addr = alloca i32, align 4
  %pwaste.addr = alloca ptr, align 8
  %node = alloca ptr, align 8
  %x1 = alloca i32, align 4
  %min_y = alloca i32, align 4
  %visited_width = alloca i32, align 4
  %waste_area = alloca i32, align 4
  %under_width = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  store ptr %first, ptr %first.addr, align 8
  store i32 %x0, ptr %x0.addr, align 4
  store i32 %width, ptr %width.addr, align 4
  store ptr %pwaste, ptr %pwaste.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  store ptr %0, ptr %node, align 8
  %1 = load i32, ptr %x0.addr, align 4
  %2 = load i32, ptr %width.addr, align 4
  %add = add nsw i32 %1, %2
  store i32 %add, ptr %x1, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body1

do.body1:                                         ; preds = %do.end
  br label %do.end2

do.end2:                                          ; preds = %do.body1
  br label %do.body3

do.body3:                                         ; preds = %do.end2
  br label %do.end4

do.end4:                                          ; preds = %do.body3
  store i32 0, ptr %min_y, align 4
  store i32 0, ptr %waste_area, align 4
  store i32 0, ptr %visited_width, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end35, %do.end4
  %3 = load ptr, ptr %node, align 8
  %x = getelementptr inbounds %struct.stbrp_node, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %x, align 8
  %5 = load i32, ptr %x1, align 4
  %cmp = icmp slt i32 %4, %5
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %6 = load ptr, ptr %node, align 8
  %y = getelementptr inbounds %struct.stbrp_node, ptr %6, i32 0, i32 1
  %7 = load i32, ptr %y, align 4
  %8 = load i32, ptr %min_y, align 4
  %cmp5 = icmp sgt i32 %7, %8
  br i1 %cmp5, label %if.then, label %if.else20

if.then:                                          ; preds = %while.body
  %9 = load i32, ptr %visited_width, align 4
  %10 = load ptr, ptr %node, align 8
  %y6 = getelementptr inbounds %struct.stbrp_node, ptr %10, i32 0, i32 1
  %11 = load i32, ptr %y6, align 4
  %12 = load i32, ptr %min_y, align 4
  %sub = sub nsw i32 %11, %12
  %mul = mul nsw i32 %9, %sub
  %13 = load i32, ptr %waste_area, align 4
  %add7 = add nsw i32 %13, %mul
  store i32 %add7, ptr %waste_area, align 4
  %14 = load ptr, ptr %node, align 8
  %y8 = getelementptr inbounds %struct.stbrp_node, ptr %14, i32 0, i32 1
  %15 = load i32, ptr %y8, align 4
  store i32 %15, ptr %min_y, align 4
  %16 = load ptr, ptr %node, align 8
  %x9 = getelementptr inbounds %struct.stbrp_node, ptr %16, i32 0, i32 0
  %17 = load i32, ptr %x9, align 8
  %18 = load i32, ptr %x0.addr, align 4
  %cmp10 = icmp slt i32 %17, %18
  br i1 %cmp10, label %if.then11, label %if.else

if.then11:                                        ; preds = %if.then
  %19 = load ptr, ptr %node, align 8
  %next = getelementptr inbounds %struct.stbrp_node, ptr %19, i32 0, i32 2
  %20 = load ptr, ptr %next, align 8
  %x12 = getelementptr inbounds %struct.stbrp_node, ptr %20, i32 0, i32 0
  %21 = load i32, ptr %x12, align 8
  %22 = load i32, ptr %x0.addr, align 4
  %sub13 = sub nsw i32 %21, %22
  %23 = load i32, ptr %visited_width, align 4
  %add14 = add nsw i32 %23, %sub13
  store i32 %add14, ptr %visited_width, align 4
  br label %if.end

if.else:                                          ; preds = %if.then
  %24 = load ptr, ptr %node, align 8
  %next15 = getelementptr inbounds %struct.stbrp_node, ptr %24, i32 0, i32 2
  %25 = load ptr, ptr %next15, align 8
  %x16 = getelementptr inbounds %struct.stbrp_node, ptr %25, i32 0, i32 0
  %26 = load i32, ptr %x16, align 8
  %27 = load ptr, ptr %node, align 8
  %x17 = getelementptr inbounds %struct.stbrp_node, ptr %27, i32 0, i32 0
  %28 = load i32, ptr %x17, align 8
  %sub18 = sub nsw i32 %26, %28
  %29 = load i32, ptr %visited_width, align 4
  %add19 = add nsw i32 %29, %sub18
  store i32 %add19, ptr %visited_width, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then11
  br label %if.end35

if.else20:                                        ; preds = %while.body
  %30 = load ptr, ptr %node, align 8
  %next21 = getelementptr inbounds %struct.stbrp_node, ptr %30, i32 0, i32 2
  %31 = load ptr, ptr %next21, align 8
  %x22 = getelementptr inbounds %struct.stbrp_node, ptr %31, i32 0, i32 0
  %32 = load i32, ptr %x22, align 8
  %33 = load ptr, ptr %node, align 8
  %x23 = getelementptr inbounds %struct.stbrp_node, ptr %33, i32 0, i32 0
  %34 = load i32, ptr %x23, align 8
  %sub24 = sub nsw i32 %32, %34
  store i32 %sub24, ptr %under_width, align 4
  %35 = load i32, ptr %under_width, align 4
  %36 = load i32, ptr %visited_width, align 4
  %add25 = add nsw i32 %35, %36
  %37 = load i32, ptr %width.addr, align 4
  %cmp26 = icmp sgt i32 %add25, %37
  br i1 %cmp26, label %if.then27, label %if.end29

if.then27:                                        ; preds = %if.else20
  %38 = load i32, ptr %width.addr, align 4
  %39 = load i32, ptr %visited_width, align 4
  %sub28 = sub nsw i32 %38, %39
  store i32 %sub28, ptr %under_width, align 4
  br label %if.end29

if.end29:                                         ; preds = %if.then27, %if.else20
  %40 = load i32, ptr %under_width, align 4
  %41 = load i32, ptr %min_y, align 4
  %42 = load ptr, ptr %node, align 8
  %y30 = getelementptr inbounds %struct.stbrp_node, ptr %42, i32 0, i32 1
  %43 = load i32, ptr %y30, align 4
  %sub31 = sub nsw i32 %41, %43
  %mul32 = mul nsw i32 %40, %sub31
  %44 = load i32, ptr %waste_area, align 4
  %add33 = add nsw i32 %44, %mul32
  store i32 %add33, ptr %waste_area, align 4
  %45 = load i32, ptr %under_width, align 4
  %46 = load i32, ptr %visited_width, align 4
  %add34 = add nsw i32 %46, %45
  store i32 %add34, ptr %visited_width, align 4
  br label %if.end35

if.end35:                                         ; preds = %if.end29, %if.end
  %47 = load ptr, ptr %node, align 8
  %next36 = getelementptr inbounds %struct.stbrp_node, ptr %47, i32 0, i32 2
  %48 = load ptr, ptr %next36, align 8
  store ptr %48, ptr %node, align 8
  br label %while.cond, !llvm.loop !169

while.end:                                        ; preds = %while.cond
  %49 = load i32, ptr %waste_area, align 4
  %50 = load ptr, ptr %pwaste.addr, align 8
  store i32 %49, ptr %50, align 4
  %51 = load i32, ptr %min_y, align 4
  ret i32 %51
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN24ImFontGlyphRangesBuilder6SetBitEm(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %off = alloca i32, align 4
  %mask = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %shr = lshr i64 %0, 5
  %conv = trunc i64 %shr to i32
  store i32 %conv, ptr %off, align 4
  %1 = load i64, ptr %n.addr, align 8
  %and = and i64 %1, 31
  %sh_prom = trunc i64 %and to i32
  %shl = shl i32 1, %sh_prom
  store i32 %shl, ptr %mask, align 4
  %2 = load i32, ptr %mask, align 4
  %UsedChars = getelementptr inbounds %struct.ImFontGlyphRangesBuilder, ptr %this1, i32 0, i32 0
  %3 = load i32, ptr %off, align 4
  %call = call noundef nonnull align 4 dereferenceable(4) ptr @_ZN8ImVectorIjEixEi(ptr noundef nonnull align 8 dereferenceable(16) %UsedChars, i32 noundef %3)
  %4 = load i32, ptr %call, align 4
  %or = or i32 %4, %2
  store i32 %or, ptr %call, align 4
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 4 dereferenceable(4) ptr @_ZN8ImVectorIjEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.13, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds i32, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef nonnull align 4 dereferenceable(4) ptr @_ZNK8ImVectorIjEixEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %i) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.13, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds i32, ptr %0, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef zeroext i1 @_ZL14ImCharIsBlankAc(i8 noundef signext %c) #2 {
entry:
  %c.addr = alloca i8, align 1
  store i8 %c, ptr %c.addr, align 1
  %0 = load i8, ptr %c.addr, align 1
  %conv = sext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 32
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load i8, ptr %c.addr, align 1
  %conv1 = sext i8 %1 to i32
  %cmp2 = icmp eq i32 %conv1, 9
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %cmp2, %lor.rhs ]
  ret i1 %2
}

; Function Attrs: mustprogress uwtable
define internal noundef ptr @_ZL20stb_decompress_tokenPKh(ptr noundef %i) #4 {
entry:
  %i.addr = alloca ptr, align 8
  store ptr %i, ptr %i.addr, align 8
  %0 = load ptr, ptr %i.addr, align 8
  %1 = load i8, ptr %0, align 1
  %conv = zext i8 %1 to i32
  %cmp = icmp sge i32 %conv, 32
  br i1 %cmp, label %if.then, label %if.else40

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %i.addr, align 8
  %3 = load i8, ptr %2, align 1
  %conv1 = zext i8 %3 to i32
  %cmp2 = icmp sge i32 %conv1, 128
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.then
  %4 = load ptr, ptr @_ZL9stb__dout, align 8
  %5 = load ptr, ptr %i.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %5, i64 1
  %6 = load i8, ptr %arrayidx, align 1
  %conv4 = zext i8 %6 to i32
  %idx.ext = sext i32 %conv4 to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr = getelementptr inbounds i8, ptr %4, i64 %idx.neg
  %add.ptr5 = getelementptr inbounds i8, ptr %add.ptr, i64 -1
  %7 = load ptr, ptr %i.addr, align 8
  %arrayidx6 = getelementptr inbounds i8, ptr %7, i64 0
  %8 = load i8, ptr %arrayidx6, align 1
  %conv7 = zext i8 %8 to i32
  %sub = sub nsw i32 %conv7, 128
  %add = add nsw i32 %sub, 1
  call void @_ZL10stb__matchPKhj(ptr noundef %add.ptr5, i32 noundef %add)
  %9 = load ptr, ptr %i.addr, align 8
  %add.ptr8 = getelementptr inbounds i8, ptr %9, i64 2
  store ptr %add.ptr8, ptr %i.addr, align 8
  br label %if.end39

if.else:                                          ; preds = %if.then
  %10 = load ptr, ptr %i.addr, align 8
  %11 = load i8, ptr %10, align 1
  %conv9 = zext i8 %11 to i32
  %cmp10 = icmp sge i32 %conv9, 64
  br i1 %cmp10, label %if.then11, label %if.else26

if.then11:                                        ; preds = %if.else
  %12 = load ptr, ptr @_ZL9stb__dout, align 8
  %13 = load ptr, ptr %i.addr, align 8
  %arrayidx12 = getelementptr inbounds i8, ptr %13, i64 0
  %14 = load i8, ptr %arrayidx12, align 1
  %conv13 = zext i8 %14 to i32
  %shl = shl i32 %conv13, 8
  %15 = load ptr, ptr %i.addr, align 8
  %arrayidx14 = getelementptr inbounds i8, ptr %15, i64 1
  %16 = load i8, ptr %arrayidx14, align 1
  %conv15 = zext i8 %16 to i32
  %add16 = add nsw i32 %shl, %conv15
  %sub17 = sub nsw i32 %add16, 16384
  %add18 = add nsw i32 %sub17, 1
  %idx.ext19 = sext i32 %add18 to i64
  %idx.neg20 = sub i64 0, %idx.ext19
  %add.ptr21 = getelementptr inbounds i8, ptr %12, i64 %idx.neg20
  %17 = load ptr, ptr %i.addr, align 8
  %arrayidx22 = getelementptr inbounds i8, ptr %17, i64 2
  %18 = load i8, ptr %arrayidx22, align 1
  %conv23 = zext i8 %18 to i32
  %add24 = add nsw i32 %conv23, 1
  call void @_ZL10stb__matchPKhj(ptr noundef %add.ptr21, i32 noundef %add24)
  %19 = load ptr, ptr %i.addr, align 8
  %add.ptr25 = getelementptr inbounds i8, ptr %19, i64 3
  store ptr %add.ptr25, ptr %i.addr, align 8
  br label %if.end

if.else26:                                        ; preds = %if.else
  %20 = load ptr, ptr %i.addr, align 8
  %add.ptr27 = getelementptr inbounds i8, ptr %20, i64 1
  %21 = load ptr, ptr %i.addr, align 8
  %arrayidx28 = getelementptr inbounds i8, ptr %21, i64 0
  %22 = load i8, ptr %arrayidx28, align 1
  %conv29 = zext i8 %22 to i32
  %sub30 = sub nsw i32 %conv29, 32
  %add31 = add nsw i32 %sub30, 1
  call void @_ZL8stb__litPKhj(ptr noundef %add.ptr27, i32 noundef %add31)
  %23 = load ptr, ptr %i.addr, align 8
  %arrayidx32 = getelementptr inbounds i8, ptr %23, i64 0
  %24 = load i8, ptr %arrayidx32, align 1
  %conv33 = zext i8 %24 to i32
  %sub34 = sub nsw i32 %conv33, 32
  %add35 = add nsw i32 %sub34, 1
  %add36 = add nsw i32 1, %add35
  %25 = load ptr, ptr %i.addr, align 8
  %idx.ext37 = sext i32 %add36 to i64
  %add.ptr38 = getelementptr inbounds i8, ptr %25, i64 %idx.ext37
  store ptr %add.ptr38, ptr %i.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.else26, %if.then11
  br label %if.end39

if.end39:                                         ; preds = %if.end, %if.then3
  br label %if.end190

if.else40:                                        ; preds = %entry
  %26 = load ptr, ptr %i.addr, align 8
  %27 = load i8, ptr %26, align 1
  %conv41 = zext i8 %27 to i32
  %cmp42 = icmp sge i32 %conv41, 24
  br i1 %cmp42, label %if.then43, label %if.else63

if.then43:                                        ; preds = %if.else40
  %28 = load ptr, ptr @_ZL9stb__dout, align 8
  %29 = load ptr, ptr %i.addr, align 8
  %arrayidx44 = getelementptr inbounds i8, ptr %29, i64 0
  %30 = load i8, ptr %arrayidx44, align 1
  %conv45 = zext i8 %30 to i32
  %shl46 = shl i32 %conv45, 16
  %31 = load ptr, ptr %i.addr, align 8
  %arrayidx47 = getelementptr inbounds i8, ptr %31, i64 1
  %32 = load i8, ptr %arrayidx47, align 1
  %conv48 = zext i8 %32 to i32
  %shl49 = shl i32 %conv48, 8
  %33 = load ptr, ptr %i.addr, align 8
  %arrayidx50 = getelementptr inbounds i8, ptr %33, i64 2
  %34 = load i8, ptr %arrayidx50, align 1
  %conv51 = zext i8 %34 to i32
  %add52 = add nsw i32 %shl49, %conv51
  %add53 = add nsw i32 %shl46, %add52
  %sub54 = sub nsw i32 %add53, 1572864
  %add55 = add nsw i32 %sub54, 1
  %idx.ext56 = sext i32 %add55 to i64
  %idx.neg57 = sub i64 0, %idx.ext56
  %add.ptr58 = getelementptr inbounds i8, ptr %28, i64 %idx.neg57
  %35 = load ptr, ptr %i.addr, align 8
  %arrayidx59 = getelementptr inbounds i8, ptr %35, i64 3
  %36 = load i8, ptr %arrayidx59, align 1
  %conv60 = zext i8 %36 to i32
  %add61 = add nsw i32 %conv60, 1
  call void @_ZL10stb__matchPKhj(ptr noundef %add.ptr58, i32 noundef %add61)
  %37 = load ptr, ptr %i.addr, align 8
  %add.ptr62 = getelementptr inbounds i8, ptr %37, i64 4
  store ptr %add.ptr62, ptr %i.addr, align 8
  br label %if.end189

if.else63:                                        ; preds = %if.else40
  %38 = load ptr, ptr %i.addr, align 8
  %39 = load i8, ptr %38, align 1
  %conv64 = zext i8 %39 to i32
  %cmp65 = icmp sge i32 %conv64, 16
  br i1 %cmp65, label %if.then66, label %if.else90

if.then66:                                        ; preds = %if.else63
  %40 = load ptr, ptr @_ZL9stb__dout, align 8
  %41 = load ptr, ptr %i.addr, align 8
  %arrayidx67 = getelementptr inbounds i8, ptr %41, i64 0
  %42 = load i8, ptr %arrayidx67, align 1
  %conv68 = zext i8 %42 to i32
  %shl69 = shl i32 %conv68, 16
  %43 = load ptr, ptr %i.addr, align 8
  %arrayidx70 = getelementptr inbounds i8, ptr %43, i64 1
  %44 = load i8, ptr %arrayidx70, align 1
  %conv71 = zext i8 %44 to i32
  %shl72 = shl i32 %conv71, 8
  %45 = load ptr, ptr %i.addr, align 8
  %arrayidx73 = getelementptr inbounds i8, ptr %45, i64 2
  %46 = load i8, ptr %arrayidx73, align 1
  %conv74 = zext i8 %46 to i32
  %add75 = add nsw i32 %shl72, %conv74
  %add76 = add nsw i32 %shl69, %add75
  %sub77 = sub nsw i32 %add76, 1048576
  %add78 = add nsw i32 %sub77, 1
  %idx.ext79 = sext i32 %add78 to i64
  %idx.neg80 = sub i64 0, %idx.ext79
  %add.ptr81 = getelementptr inbounds i8, ptr %40, i64 %idx.neg80
  %47 = load ptr, ptr %i.addr, align 8
  %arrayidx82 = getelementptr inbounds i8, ptr %47, i64 3
  %48 = load i8, ptr %arrayidx82, align 1
  %conv83 = zext i8 %48 to i32
  %shl84 = shl i32 %conv83, 8
  %49 = load ptr, ptr %i.addr, align 8
  %arrayidx85 = getelementptr inbounds i8, ptr %49, i64 4
  %50 = load i8, ptr %arrayidx85, align 1
  %conv86 = zext i8 %50 to i32
  %add87 = add nsw i32 %shl84, %conv86
  %add88 = add nsw i32 %add87, 1
  call void @_ZL10stb__matchPKhj(ptr noundef %add.ptr81, i32 noundef %add88)
  %51 = load ptr, ptr %i.addr, align 8
  %add.ptr89 = getelementptr inbounds i8, ptr %51, i64 5
  store ptr %add.ptr89, ptr %i.addr, align 8
  br label %if.end188

if.else90:                                        ; preds = %if.else63
  %52 = load ptr, ptr %i.addr, align 8
  %53 = load i8, ptr %52, align 1
  %conv91 = zext i8 %53 to i32
  %cmp92 = icmp sge i32 %conv91, 8
  br i1 %cmp92, label %if.then93, label %if.else114

if.then93:                                        ; preds = %if.else90
  %54 = load ptr, ptr %i.addr, align 8
  %add.ptr94 = getelementptr inbounds i8, ptr %54, i64 2
  %55 = load ptr, ptr %i.addr, align 8
  %arrayidx95 = getelementptr inbounds i8, ptr %55, i64 0
  %56 = load i8, ptr %arrayidx95, align 1
  %conv96 = zext i8 %56 to i32
  %shl97 = shl i32 %conv96, 8
  %57 = load ptr, ptr %i.addr, align 8
  %arrayidx98 = getelementptr inbounds i8, ptr %57, i64 1
  %58 = load i8, ptr %arrayidx98, align 1
  %conv99 = zext i8 %58 to i32
  %add100 = add nsw i32 %shl97, %conv99
  %sub101 = sub nsw i32 %add100, 2048
  %add102 = add nsw i32 %sub101, 1
  call void @_ZL8stb__litPKhj(ptr noundef %add.ptr94, i32 noundef %add102)
  %59 = load ptr, ptr %i.addr, align 8
  %arrayidx103 = getelementptr inbounds i8, ptr %59, i64 0
  %60 = load i8, ptr %arrayidx103, align 1
  %conv104 = zext i8 %60 to i32
  %shl105 = shl i32 %conv104, 8
  %61 = load ptr, ptr %i.addr, align 8
  %arrayidx106 = getelementptr inbounds i8, ptr %61, i64 1
  %62 = load i8, ptr %arrayidx106, align 1
  %conv107 = zext i8 %62 to i32
  %add108 = add nsw i32 %shl105, %conv107
  %sub109 = sub nsw i32 %add108, 2048
  %add110 = add nsw i32 %sub109, 1
  %add111 = add nsw i32 2, %add110
  %63 = load ptr, ptr %i.addr, align 8
  %idx.ext112 = sext i32 %add111 to i64
  %add.ptr113 = getelementptr inbounds i8, ptr %63, i64 %idx.ext112
  store ptr %add.ptr113, ptr %i.addr, align 8
  br label %if.end187

if.else114:                                       ; preds = %if.else90
  %64 = load ptr, ptr %i.addr, align 8
  %65 = load i8, ptr %64, align 1
  %conv115 = zext i8 %65 to i32
  %cmp116 = icmp eq i32 %conv115, 7
  br i1 %cmp116, label %if.then117, label %if.else136

if.then117:                                       ; preds = %if.else114
  %66 = load ptr, ptr %i.addr, align 8
  %add.ptr118 = getelementptr inbounds i8, ptr %66, i64 3
  %67 = load ptr, ptr %i.addr, align 8
  %arrayidx119 = getelementptr inbounds i8, ptr %67, i64 1
  %68 = load i8, ptr %arrayidx119, align 1
  %conv120 = zext i8 %68 to i32
  %shl121 = shl i32 %conv120, 8
  %69 = load ptr, ptr %i.addr, align 8
  %arrayidx122 = getelementptr inbounds i8, ptr %69, i64 2
  %70 = load i8, ptr %arrayidx122, align 1
  %conv123 = zext i8 %70 to i32
  %add124 = add nsw i32 %shl121, %conv123
  %add125 = add nsw i32 %add124, 1
  call void @_ZL8stb__litPKhj(ptr noundef %add.ptr118, i32 noundef %add125)
  %71 = load ptr, ptr %i.addr, align 8
  %arrayidx126 = getelementptr inbounds i8, ptr %71, i64 1
  %72 = load i8, ptr %arrayidx126, align 1
  %conv127 = zext i8 %72 to i32
  %shl128 = shl i32 %conv127, 8
  %73 = load ptr, ptr %i.addr, align 8
  %arrayidx129 = getelementptr inbounds i8, ptr %73, i64 2
  %74 = load i8, ptr %arrayidx129, align 1
  %conv130 = zext i8 %74 to i32
  %add131 = add nsw i32 %shl128, %conv130
  %add132 = add nsw i32 %add131, 1
  %add133 = add nsw i32 3, %add132
  %75 = load ptr, ptr %i.addr, align 8
  %idx.ext134 = sext i32 %add133 to i64
  %add.ptr135 = getelementptr inbounds i8, ptr %75, i64 %idx.ext134
  store ptr %add.ptr135, ptr %i.addr, align 8
  br label %if.end186

if.else136:                                       ; preds = %if.else114
  %76 = load ptr, ptr %i.addr, align 8
  %77 = load i8, ptr %76, align 1
  %conv137 = zext i8 %77 to i32
  %cmp138 = icmp eq i32 %conv137, 6
  br i1 %cmp138, label %if.then139, label %if.else158

if.then139:                                       ; preds = %if.else136
  %78 = load ptr, ptr @_ZL9stb__dout, align 8
  %79 = load ptr, ptr %i.addr, align 8
  %arrayidx140 = getelementptr inbounds i8, ptr %79, i64 1
  %80 = load i8, ptr %arrayidx140, align 1
  %conv141 = zext i8 %80 to i32
  %shl142 = shl i32 %conv141, 16
  %81 = load ptr, ptr %i.addr, align 8
  %arrayidx143 = getelementptr inbounds i8, ptr %81, i64 2
  %82 = load i8, ptr %arrayidx143, align 1
  %conv144 = zext i8 %82 to i32
  %shl145 = shl i32 %conv144, 8
  %83 = load ptr, ptr %i.addr, align 8
  %arrayidx146 = getelementptr inbounds i8, ptr %83, i64 3
  %84 = load i8, ptr %arrayidx146, align 1
  %conv147 = zext i8 %84 to i32
  %add148 = add nsw i32 %shl145, %conv147
  %add149 = add nsw i32 %shl142, %add148
  %add150 = add nsw i32 %add149, 1
  %idx.ext151 = sext i32 %add150 to i64
  %idx.neg152 = sub i64 0, %idx.ext151
  %add.ptr153 = getelementptr inbounds i8, ptr %78, i64 %idx.neg152
  %85 = load ptr, ptr %i.addr, align 8
  %arrayidx154 = getelementptr inbounds i8, ptr %85, i64 4
  %86 = load i8, ptr %arrayidx154, align 1
  %conv155 = zext i8 %86 to i32
  %add156 = add nsw i32 %conv155, 1
  call void @_ZL10stb__matchPKhj(ptr noundef %add.ptr153, i32 noundef %add156)
  %87 = load ptr, ptr %i.addr, align 8
  %add.ptr157 = getelementptr inbounds i8, ptr %87, i64 5
  store ptr %add.ptr157, ptr %i.addr, align 8
  br label %if.end185

if.else158:                                       ; preds = %if.else136
  %88 = load ptr, ptr %i.addr, align 8
  %89 = load i8, ptr %88, align 1
  %conv159 = zext i8 %89 to i32
  %cmp160 = icmp eq i32 %conv159, 4
  br i1 %cmp160, label %if.then161, label %if.end184

if.then161:                                       ; preds = %if.else158
  %90 = load ptr, ptr @_ZL9stb__dout, align 8
  %91 = load ptr, ptr %i.addr, align 8
  %arrayidx162 = getelementptr inbounds i8, ptr %91, i64 1
  %92 = load i8, ptr %arrayidx162, align 1
  %conv163 = zext i8 %92 to i32
  %shl164 = shl i32 %conv163, 16
  %93 = load ptr, ptr %i.addr, align 8
  %arrayidx165 = getelementptr inbounds i8, ptr %93, i64 2
  %94 = load i8, ptr %arrayidx165, align 1
  %conv166 = zext i8 %94 to i32
  %shl167 = shl i32 %conv166, 8
  %95 = load ptr, ptr %i.addr, align 8
  %arrayidx168 = getelementptr inbounds i8, ptr %95, i64 3
  %96 = load i8, ptr %arrayidx168, align 1
  %conv169 = zext i8 %96 to i32
  %add170 = add nsw i32 %shl167, %conv169
  %add171 = add nsw i32 %shl164, %add170
  %add172 = add nsw i32 %add171, 1
  %idx.ext173 = sext i32 %add172 to i64
  %idx.neg174 = sub i64 0, %idx.ext173
  %add.ptr175 = getelementptr inbounds i8, ptr %90, i64 %idx.neg174
  %97 = load ptr, ptr %i.addr, align 8
  %arrayidx176 = getelementptr inbounds i8, ptr %97, i64 4
  %98 = load i8, ptr %arrayidx176, align 1
  %conv177 = zext i8 %98 to i32
  %shl178 = shl i32 %conv177, 8
  %99 = load ptr, ptr %i.addr, align 8
  %arrayidx179 = getelementptr inbounds i8, ptr %99, i64 5
  %100 = load i8, ptr %arrayidx179, align 1
  %conv180 = zext i8 %100 to i32
  %add181 = add nsw i32 %shl178, %conv180
  %add182 = add nsw i32 %add181, 1
  call void @_ZL10stb__matchPKhj(ptr noundef %add.ptr175, i32 noundef %add182)
  %101 = load ptr, ptr %i.addr, align 8
  %add.ptr183 = getelementptr inbounds i8, ptr %101, i64 6
  store ptr %add.ptr183, ptr %i.addr, align 8
  br label %if.end184

if.end184:                                        ; preds = %if.then161, %if.else158
  br label %if.end185

if.end185:                                        ; preds = %if.end184, %if.then139
  br label %if.end186

if.end186:                                        ; preds = %if.end185, %if.then117
  br label %if.end187

if.end187:                                        ; preds = %if.end186, %if.then93
  br label %if.end188

if.end188:                                        ; preds = %if.end187, %if.then66
  br label %if.end189

if.end189:                                        ; preds = %if.end188, %if.then43
  br label %if.end190

if.end190:                                        ; preds = %if.end189, %if.end39
  %102 = load ptr, ptr %i.addr, align 8
  ret ptr %102
}

; Function Attrs: mustprogress nounwind uwtable
define internal noundef i32 @_ZL11stb_adler32jPhj(i32 noundef %adler32, ptr noundef %buffer, i32 noundef %buflen) #2 {
entry:
  %adler32.addr = alloca i32, align 4
  %buffer.addr = alloca ptr, align 8
  %buflen.addr = alloca i32, align 4
  %ADLER_MOD = alloca i64, align 8
  %s1 = alloca i64, align 8
  %s2 = alloca i64, align 8
  %blocklen = alloca i64, align 8
  %i = alloca i64, align 8
  store i32 %adler32, ptr %adler32.addr, align 4
  store ptr %buffer, ptr %buffer.addr, align 8
  store i32 %buflen, ptr %buflen.addr, align 4
  store i64 65521, ptr %ADLER_MOD, align 8
  %0 = load i32, ptr %adler32.addr, align 4
  %and = and i32 %0, 65535
  %conv = zext i32 %and to i64
  store i64 %conv, ptr %s1, align 8
  %1 = load i32, ptr %adler32.addr, align 4
  %shr = lshr i32 %1, 16
  %conv1 = zext i32 %shr to i64
  store i64 %conv1, ptr %s2, align 8
  %2 = load i32, ptr %buflen.addr, align 4
  %rem = urem i32 %2, 5552
  %conv2 = zext i32 %rem to i64
  store i64 %conv2, ptr %blocklen, align 8
  br label %while.cond

while.cond:                                       ; preds = %for.end42, %entry
  %3 = load i32, ptr %buflen.addr, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.body
  %4 = load i64, ptr %i, align 8
  %add = add i64 %4, 7
  %5 = load i64, ptr %blocklen, align 8
  %cmp = icmp ult i64 %add, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load ptr, ptr %buffer.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %6, i64 0
  %7 = load i8, ptr %arrayidx, align 1
  %conv3 = zext i8 %7 to i64
  %8 = load i64, ptr %s1, align 8
  %add4 = add i64 %8, %conv3
  store i64 %add4, ptr %s1, align 8
  %9 = load i64, ptr %s1, align 8
  %10 = load i64, ptr %s2, align 8
  %add5 = add i64 %10, %9
  store i64 %add5, ptr %s2, align 8
  %11 = load ptr, ptr %buffer.addr, align 8
  %arrayidx6 = getelementptr inbounds i8, ptr %11, i64 1
  %12 = load i8, ptr %arrayidx6, align 1
  %conv7 = zext i8 %12 to i64
  %13 = load i64, ptr %s1, align 8
  %add8 = add i64 %13, %conv7
  store i64 %add8, ptr %s1, align 8
  %14 = load i64, ptr %s1, align 8
  %15 = load i64, ptr %s2, align 8
  %add9 = add i64 %15, %14
  store i64 %add9, ptr %s2, align 8
  %16 = load ptr, ptr %buffer.addr, align 8
  %arrayidx10 = getelementptr inbounds i8, ptr %16, i64 2
  %17 = load i8, ptr %arrayidx10, align 1
  %conv11 = zext i8 %17 to i64
  %18 = load i64, ptr %s1, align 8
  %add12 = add i64 %18, %conv11
  store i64 %add12, ptr %s1, align 8
  %19 = load i64, ptr %s1, align 8
  %20 = load i64, ptr %s2, align 8
  %add13 = add i64 %20, %19
  store i64 %add13, ptr %s2, align 8
  %21 = load ptr, ptr %buffer.addr, align 8
  %arrayidx14 = getelementptr inbounds i8, ptr %21, i64 3
  %22 = load i8, ptr %arrayidx14, align 1
  %conv15 = zext i8 %22 to i64
  %23 = load i64, ptr %s1, align 8
  %add16 = add i64 %23, %conv15
  store i64 %add16, ptr %s1, align 8
  %24 = load i64, ptr %s1, align 8
  %25 = load i64, ptr %s2, align 8
  %add17 = add i64 %25, %24
  store i64 %add17, ptr %s2, align 8
  %26 = load ptr, ptr %buffer.addr, align 8
  %arrayidx18 = getelementptr inbounds i8, ptr %26, i64 4
  %27 = load i8, ptr %arrayidx18, align 1
  %conv19 = zext i8 %27 to i64
  %28 = load i64, ptr %s1, align 8
  %add20 = add i64 %28, %conv19
  store i64 %add20, ptr %s1, align 8
  %29 = load i64, ptr %s1, align 8
  %30 = load i64, ptr %s2, align 8
  %add21 = add i64 %30, %29
  store i64 %add21, ptr %s2, align 8
  %31 = load ptr, ptr %buffer.addr, align 8
  %arrayidx22 = getelementptr inbounds i8, ptr %31, i64 5
  %32 = load i8, ptr %arrayidx22, align 1
  %conv23 = zext i8 %32 to i64
  %33 = load i64, ptr %s1, align 8
  %add24 = add i64 %33, %conv23
  store i64 %add24, ptr %s1, align 8
  %34 = load i64, ptr %s1, align 8
  %35 = load i64, ptr %s2, align 8
  %add25 = add i64 %35, %34
  store i64 %add25, ptr %s2, align 8
  %36 = load ptr, ptr %buffer.addr, align 8
  %arrayidx26 = getelementptr inbounds i8, ptr %36, i64 6
  %37 = load i8, ptr %arrayidx26, align 1
  %conv27 = zext i8 %37 to i64
  %38 = load i64, ptr %s1, align 8
  %add28 = add i64 %38, %conv27
  store i64 %add28, ptr %s1, align 8
  %39 = load i64, ptr %s1, align 8
  %40 = load i64, ptr %s2, align 8
  %add29 = add i64 %40, %39
  store i64 %add29, ptr %s2, align 8
  %41 = load ptr, ptr %buffer.addr, align 8
  %arrayidx30 = getelementptr inbounds i8, ptr %41, i64 7
  %42 = load i8, ptr %arrayidx30, align 1
  %conv31 = zext i8 %42 to i64
  %43 = load i64, ptr %s1, align 8
  %add32 = add i64 %43, %conv31
  store i64 %add32, ptr %s1, align 8
  %44 = load i64, ptr %s1, align 8
  %45 = load i64, ptr %s2, align 8
  %add33 = add i64 %45, %44
  store i64 %add33, ptr %s2, align 8
  %46 = load ptr, ptr %buffer.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %46, i64 8
  store ptr %add.ptr, ptr %buffer.addr, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %47 = load i64, ptr %i, align 8
  %add34 = add i64 %47, 8
  store i64 %add34, ptr %i, align 8
  br label %for.cond, !llvm.loop !170

for.end:                                          ; preds = %for.cond
  br label %for.cond35

for.cond35:                                       ; preds = %for.inc41, %for.end
  %48 = load i64, ptr %i, align 8
  %49 = load i64, ptr %blocklen, align 8
  %cmp36 = icmp ult i64 %48, %49
  br i1 %cmp36, label %for.body37, label %for.end42

for.body37:                                       ; preds = %for.cond35
  %50 = load ptr, ptr %buffer.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %50, i32 1
  store ptr %incdec.ptr, ptr %buffer.addr, align 8
  %51 = load i8, ptr %50, align 1
  %conv38 = zext i8 %51 to i64
  %52 = load i64, ptr %s1, align 8
  %add39 = add i64 %52, %conv38
  store i64 %add39, ptr %s1, align 8
  %53 = load i64, ptr %s1, align 8
  %54 = load i64, ptr %s2, align 8
  %add40 = add i64 %54, %53
  store i64 %add40, ptr %s2, align 8
  br label %for.inc41

for.inc41:                                        ; preds = %for.body37
  %55 = load i64, ptr %i, align 8
  %inc = add i64 %55, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond35, !llvm.loop !171

for.end42:                                        ; preds = %for.cond35
  %56 = load i64, ptr %s1, align 8
  %rem43 = urem i64 %56, 65521
  store i64 %rem43, ptr %s1, align 8
  %57 = load i64, ptr %s2, align 8
  %rem44 = urem i64 %57, 65521
  store i64 %rem44, ptr %s2, align 8
  %58 = load i64, ptr %blocklen, align 8
  %59 = load i32, ptr %buflen.addr, align 4
  %conv45 = zext i32 %59 to i64
  %sub = sub i64 %conv45, %58
  %conv46 = trunc i64 %sub to i32
  store i32 %conv46, ptr %buflen.addr, align 4
  store i64 5552, ptr %blocklen, align 8
  br label %while.cond, !llvm.loop !172

while.end:                                        ; preds = %while.cond
  %60 = load i64, ptr %s2, align 8
  %shl = shl i64 %60, 16
  %conv47 = trunc i64 %shl to i32
  %61 = load i64, ptr %s1, align 8
  %conv48 = trunc i64 %61 to i32
  %add49 = add i32 %conv47, %conv48
  ret i32 %add49
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZL10stb__matchPKhj(ptr noundef %data, i32 noundef %length) #2 {
entry:
  %data.addr = alloca ptr, align 8
  %length.addr = alloca i32, align 4
  store ptr %data, ptr %data.addr, align 8
  store i32 %length, ptr %length.addr, align 4
  %0 = load ptr, ptr @_ZL9stb__dout, align 8
  %1 = load i32, ptr %length.addr, align 4
  %idx.ext = zext i32 %1 to i64
  %add.ptr = getelementptr inbounds i8, ptr %0, i64 %idx.ext
  %2 = load ptr, ptr @_ZL18stb__barrier_out_e, align 8
  %cmp = icmp ugt ptr %add.ptr, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i32, ptr %length.addr, align 4
  %4 = load ptr, ptr @_ZL9stb__dout, align 8
  %idx.ext1 = zext i32 %3 to i64
  %add.ptr2 = getelementptr inbounds i8, ptr %4, i64 %idx.ext1
  store ptr %add.ptr2, ptr @_ZL9stb__dout, align 8
  br label %while.end

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %data.addr, align 8
  %6 = load ptr, ptr @_ZL18stb__barrier_out_b, align 8
  %cmp3 = icmp ult ptr %5, %6
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %7 = load ptr, ptr @_ZL18stb__barrier_out_e, align 8
  %add.ptr5 = getelementptr inbounds i8, ptr %7, i64 1
  store ptr %add.ptr5, ptr @_ZL9stb__dout, align 8
  br label %while.end

if.end6:                                          ; preds = %if.end
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end6
  %8 = load i32, ptr %length.addr, align 4
  %dec = add i32 %8, -1
  store i32 %dec, ptr %length.addr, align 4
  %tobool = icmp ne i32 %8, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %9 = load ptr, ptr %data.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %9, i32 1
  store ptr %incdec.ptr, ptr %data.addr, align 8
  %10 = load i8, ptr %9, align 1
  %11 = load ptr, ptr @_ZL9stb__dout, align 8
  %incdec.ptr7 = getelementptr inbounds i8, ptr %11, i32 1
  store ptr %incdec.ptr7, ptr @_ZL9stb__dout, align 8
  store i8 %10, ptr %11, align 1
  br label %while.cond, !llvm.loop !173

while.end:                                        ; preds = %while.cond, %if.then4, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define internal void @_ZL8stb__litPKhj(ptr noundef %data, i32 noundef %length) #2 {
entry:
  %data.addr = alloca ptr, align 8
  %length.addr = alloca i32, align 4
  store ptr %data, ptr %data.addr, align 8
  store i32 %length, ptr %length.addr, align 4
  %0 = load ptr, ptr @_ZL9stb__dout, align 8
  %1 = load i32, ptr %length.addr, align 4
  %idx.ext = zext i32 %1 to i64
  %add.ptr = getelementptr inbounds i8, ptr %0, i64 %idx.ext
  %2 = load ptr, ptr @_ZL18stb__barrier_out_e, align 8
  %cmp = icmp ugt ptr %add.ptr, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i32, ptr %length.addr, align 4
  %4 = load ptr, ptr @_ZL9stb__dout, align 8
  %idx.ext1 = zext i32 %3 to i64
  %add.ptr2 = getelementptr inbounds i8, ptr %4, i64 %idx.ext1
  store ptr %add.ptr2, ptr @_ZL9stb__dout, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %data.addr, align 8
  %6 = load ptr, ptr @_ZL17stb__barrier_in_b, align 8
  %cmp3 = icmp ult ptr %5, %6
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %7 = load ptr, ptr @_ZL18stb__barrier_out_e, align 8
  %add.ptr5 = getelementptr inbounds i8, ptr %7, i64 1
  store ptr %add.ptr5, ptr @_ZL9stb__dout, align 8
  br label %return

if.end6:                                          ; preds = %if.end
  %8 = load ptr, ptr @_ZL9stb__dout, align 8
  %9 = load ptr, ptr %data.addr, align 8
  %10 = load i32, ptr %length.addr, align 4
  %conv = zext i32 %10 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %8, ptr align 1 %9, i64 %conv, i1 false)
  %11 = load i32, ptr %length.addr, align 4
  %12 = load ptr, ptr @_ZL9stb__dout, align 8
  %idx.ext7 = zext i32 %11 to i64
  %add.ptr8 = getelementptr inbounds i8, ptr %12, i64 %idx.ext7
  store ptr %add.ptr8, ptr @_ZL9stb__dout, align 8
  br label %return

return:                                           ; preds = %if.end6, %if.then4, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorI6ImVec2E14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI9ImDrawCmdE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 56
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 56
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %4, ptr align 8 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorI9ImDrawCmdE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.0, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorItE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 2
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 2
  call void @llvm.memcpy.p0.p0.i64(ptr align 2 %4, ptr align 2 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorItE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.1, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI10ImDrawVertE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 20
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 20
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %4, ptr align 4 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorI10ImDrawVertE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.2, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI6ImVec4E7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 16
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 16
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %4, ptr align 4 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorI6ImVec4E14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.3, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorIPvE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 8
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %4, ptr align 8 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorIPvE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.4, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorI13ImDrawChannelE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.5, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.5, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.5, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memmove.p0.p0.i64(ptr nocapture writeonly, ptr nocapture readonly, i64, i1 immarg) #3

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorIP10ImDrawListE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.8, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 8
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.8, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.8, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.8, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %4, ptr align 8 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.8, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.8, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.8, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorIP10ImDrawListE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.8, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.8, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.8, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_Z9IM_DELETEI6ImFontEvPT_(ptr noundef %p) #4 comdat {
entry:
  %p.addr = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %p.addr, align 8
  call void @_ZN6ImFontD1Ev(ptr noundef nonnull align 8 dereferenceable(118) %1) #12
  %2 = load ptr, ptr %p.addr, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorIP6ImFontE5clearEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %Data = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %Capacity = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 1
  store i32 0, ptr %Capacity, align 4
  %Size = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 0
  store i32 0, ptr %Size, align 8
  %Data2 = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 2
  %1 = load ptr, ptr %Data2, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %1)
  %Data3 = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 2
  store ptr null, ptr %Data3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorIP6ImFontE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 8
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %4, ptr align 8 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorIP6ImFontE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.9, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI12ImFontConfigE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 144
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 144
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %4, ptr align 8 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorI12ImFontConfigE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.11, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI21ImFontAtlasCustomRectE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 32
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 32
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %4, ptr align 8 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorI21ImFontAtlasCustomRectE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.10, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI10stbrp_rectE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.12, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 24
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.12, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.12, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.12, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 24
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %4, ptr align 4 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.12, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.12, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.12, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorI10stbrp_rectE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.12, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.12, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.12, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorI11ImFontGlyphE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.7, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 40
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.7, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.7, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.7, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 40
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %4, ptr align 4 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.7, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.7, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.7, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorI11ImFontGlyphE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.7, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.7, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.7, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

; Function Attrs: mustprogress uwtable
define linkonce_odr void @_ZN8ImVectorIfE7reserveEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %new_capacity) #4 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %new_capacity.addr = alloca i32, align 4
  %new_data = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i32 %new_capacity, ptr %new_capacity.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i32, ptr %new_capacity.addr, align 4
  %Capacity = getelementptr inbounds %struct.ImVector.6, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %new_capacity.addr, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 4
  %call = call noundef ptr @_ZN5ImGui8MemAllocEm(i64 noundef %mul)
  store ptr %call, ptr %new_data, align 8
  %Data = getelementptr inbounds %struct.ImVector.6, ptr %this1, i32 0, i32 2
  %3 = load ptr, ptr %Data, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %new_data, align 8
  %Data3 = getelementptr inbounds %struct.ImVector.6, ptr %this1, i32 0, i32 2
  %5 = load ptr, ptr %Data3, align 8
  %Size = getelementptr inbounds %struct.ImVector.6, ptr %this1, i32 0, i32 0
  %6 = load i32, ptr %Size, align 8
  %conv4 = sext i32 %6 to i64
  %mul5 = mul i64 %conv4, 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %4, ptr align 4 %5, i64 %mul5, i1 false)
  %Data6 = getelementptr inbounds %struct.ImVector.6, ptr %this1, i32 0, i32 2
  %7 = load ptr, ptr %Data6, align 8
  call void @_ZN5ImGui7MemFreeEPv(ptr noundef %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %new_data, align 8
  %Data8 = getelementptr inbounds %struct.ImVector.6, ptr %this1, i32 0, i32 2
  store ptr %8, ptr %Data8, align 8
  %9 = load i32, ptr %new_capacity.addr, align 4
  %Capacity9 = getelementptr inbounds %struct.ImVector.6, ptr %this1, i32 0, i32 1
  store i32 %9, ptr %Capacity9, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr noundef i32 @_ZNK8ImVectorIfE14_grow_capacityEi(ptr noundef nonnull align 8 dereferenceable(16) %this, i32 noundef %sz) #2 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %sz.addr = alloca i32, align 4
  %new_capacity = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i32 %sz, ptr %sz.addr, align 4
  %this1 = load ptr, ptr %this.addr, align 8
  %Capacity = getelementptr inbounds %struct.ImVector.6, ptr %this1, i32 0, i32 1
  %0 = load i32, ptr %Capacity, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %Capacity2 = getelementptr inbounds %struct.ImVector.6, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %Capacity2, align 4
  %Capacity3 = getelementptr inbounds %struct.ImVector.6, ptr %this1, i32 0, i32 1
  %2 = load i32, ptr %Capacity3, align 4
  %div = sdiv i32 %2, 2
  %add = add nsw i32 %1, %div
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 8, %cond.false ]
  store i32 %cond, ptr %new_capacity, align 4
  %3 = load i32, ptr %new_capacity, align 4
  %4 = load i32, ptr %sz.addr, align 4
  %cmp = icmp sgt i32 %3, %4
  br i1 %cmp, label %cond.true4, label %cond.false5

cond.true4:                                       ; preds = %cond.end
  %5 = load i32, ptr %new_capacity, align 4
  br label %cond.end6

cond.false5:                                      ; preds = %cond.end
  %6 = load i32, ptr %sz.addr, align 4
  br label %cond.end6

cond.end6:                                        ; preds = %cond.false5, %cond.true4
  %cond7 = phi i32 [ %5, %cond.true4 ], [ %6, %cond.false5 ]
  ret i32 %cond7
}

attributes #0 = { mustprogress uwtable "frame-pointer"="all" "min-legal-vector-width"="64" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { mustprogress nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #4 = { mustprogress uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #6 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #7 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #8 = { nounwind willreturn memory(read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #9 = { mustprogress uwtable "frame-pointer"="all" "min-legal-vector-width"="128" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { noreturn nounwind uwtable "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #11 = { nocallback nofree nosync nounwind willreturn memory(none) }
attributes #12 = { nounwind }
attributes #13 = { noreturn nounwind }
attributes #14 = { nounwind willreturn memory(read) }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"uwtable", i32 2}
!3 = !{i32 7, !"frame-pointer", i32 2}
!4 = distinct !{!4, !5}
!5 = !{!"llvm.loop.mustprogress"}
!6 = distinct !{!6, !5}
!7 = distinct !{!7, !5}
!8 = distinct !{!8, !5}
!9 = distinct !{!9, !5}
!10 = distinct !{!10, !5}
!11 = distinct !{!11, !5}
!12 = distinct !{!12, !5}
!13 = distinct !{!13, !5}
!14 = distinct !{!14, !5}
!15 = distinct !{!15, !5}
!16 = distinct !{!16, !5}
!17 = distinct !{!17, !5}
!18 = distinct !{!18, !5}
!19 = distinct !{!19, !5}
!20 = distinct !{!20, !5}
!21 = distinct !{!21, !5}
!22 = distinct !{!22, !5}
!23 = distinct !{!23, !5}
!24 = distinct !{!24, !5}
!25 = distinct !{!25, !5}
!26 = distinct !{!26, !5}
!27 = distinct !{!27, !5}
!28 = distinct !{!28, !5}
!29 = distinct !{!29, !5}
!30 = distinct !{!30, !5}
!31 = distinct !{!31, !5}
!32 = distinct !{!32, !5}
!33 = distinct !{!33, !5}
!34 = distinct !{!34, !5}
!35 = distinct !{!35, !5}
!36 = distinct !{!36, !5}
!37 = distinct !{!37, !5}
!38 = distinct !{!38, !5}
!39 = distinct !{!39, !5}
!40 = distinct !{!40, !5}
!41 = distinct !{!41, !5}
!42 = distinct !{!42, !5}
!43 = distinct !{!43, !5}
!44 = distinct !{!44, !5}
!45 = distinct !{!45, !5}
!46 = distinct !{!46, !5}
!47 = distinct !{!47, !5}
!48 = distinct !{!48, !5}
!49 = distinct !{!49, !5}
!50 = distinct !{!50, !5}
!51 = distinct !{!51, !5}
!52 = distinct !{!52, !5}
!53 = distinct !{!53, !5}
!54 = distinct !{!54, !5}
!55 = distinct !{!55, !5}
!56 = distinct !{!56, !5}
!57 = distinct !{!57, !5}
!58 = distinct !{!58, !5}
!59 = distinct !{!59, !5}
!60 = distinct !{!60, !5}
!61 = distinct !{!61, !5}
!62 = distinct !{!62, !5}
!63 = distinct !{!63, !5}
!64 = distinct !{!64, !5}
!65 = distinct !{!65, !5}
!66 = distinct !{!66, !5}
!67 = distinct !{!67, !5}
!68 = distinct !{!68, !5}
!69 = distinct !{!69, !5}
!70 = distinct !{!70, !5}
!71 = distinct !{!71, !5}
!72 = distinct !{!72, !5}
!73 = distinct !{!73, !5}
!74 = distinct !{!74, !5}
!75 = distinct !{!75, !5}
!76 = distinct !{!76, !5}
!77 = distinct !{!77, !5}
!78 = distinct !{!78, !5}
!79 = distinct !{!79, !5}
!80 = distinct !{!80, !5}
!81 = distinct !{!81, !5}
!82 = distinct !{!82, !5}
!83 = distinct !{!83, !5}
!84 = distinct !{!84, !5}
!85 = distinct !{!85, !5}
!86 = distinct !{!86, !5}
!87 = distinct !{!87, !5}
!88 = distinct !{!88, !5}
!89 = distinct !{!89, !5}
!90 = distinct !{!90, !5}
!91 = distinct !{!91, !5}
!92 = distinct !{!92, !5}
!93 = distinct !{!93, !5}
!94 = distinct !{!94, !5}
!95 = distinct !{!95, !5}
!96 = distinct !{!96, !5}
!97 = distinct !{!97, !5}
!98 = distinct !{!98, !5}
!99 = distinct !{!99, !5}
!100 = distinct !{!100, !5}
!101 = distinct !{!101, !5}
!102 = distinct !{!102, !5}
!103 = distinct !{!103, !5}
!104 = distinct !{!104, !5}
!105 = distinct !{!105, !5}
!106 = distinct !{!106, !5}
!107 = distinct !{!107, !5}
!108 = distinct !{!108, !5}
!109 = distinct !{!109, !5}
!110 = distinct !{!110, !5}
!111 = distinct !{!111, !5}
!112 = distinct !{!112, !5}
!113 = distinct !{!113, !5}
!114 = distinct !{!114, !5}
!115 = distinct !{!115, !5}
!116 = distinct !{!116, !5}
!117 = distinct !{!117, !5}
!118 = distinct !{!118, !5}
!119 = distinct !{!119, !5}
!120 = distinct !{!120, !5}
!121 = distinct !{!121, !5}
!122 = distinct !{!122, !5}
!123 = distinct !{!123, !5}
!124 = distinct !{!124, !5}
!125 = distinct !{!125, !5}
!126 = distinct !{!126, !5}
!127 = distinct !{!127, !5}
!128 = distinct !{!128, !5}
!129 = distinct !{!129, !5}
!130 = distinct !{!130, !5}
!131 = distinct !{!131, !5}
!132 = distinct !{!132, !5}
!133 = distinct !{!133, !5}
!134 = distinct !{!134, !5}
!135 = distinct !{!135, !5}
!136 = distinct !{!136, !5}
!137 = distinct !{!137, !5}
!138 = distinct !{!138, !5}
!139 = distinct !{!139, !5}
!140 = distinct !{!140, !5}
!141 = distinct !{!141, !5}
!142 = distinct !{!142, !5}
!143 = distinct !{!143, !5}
!144 = distinct !{!144, !5}
!145 = distinct !{!145, !5}
!146 = distinct !{!146, !5}
!147 = distinct !{!147, !5}
!148 = distinct !{!148, !5}
!149 = distinct !{!149, !5}
!150 = distinct !{!150, !5}
!151 = distinct !{!151, !5}
!152 = distinct !{!152, !5}
!153 = distinct !{!153, !5}
!154 = distinct !{!154, !5}
!155 = distinct !{!155, !5}
!156 = distinct !{!156, !5}
!157 = distinct !{!157, !5}
!158 = distinct !{!158, !5}
!159 = distinct !{!159, !5}
!160 = distinct !{!160, !5}
!161 = distinct !{!161, !5}
!162 = distinct !{!162, !5}
!163 = distinct !{!163, !5}
!164 = distinct !{!164, !5}
!165 = distinct !{!165, !5}
!166 = distinct !{!166, !5}
!167 = distinct !{!167, !5}
!168 = distinct !{!168, !5}
!169 = distinct !{!169, !5}
!170 = distinct !{!170, !5}
!171 = distinct !{!171, !5}
!172 = distinct !{!172, !5}
!173 = distinct !{!173, !5}
